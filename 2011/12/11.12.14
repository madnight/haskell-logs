00:00:15 <mauke> not necessarily before
00:00:23 <cl1> and that whole group of code creates a function that a -> (a,b)
00:00:33 <mauke> b -> (a,b)
00:00:42 <mauke> it's waiting for the second element of the pair
00:00:45 <cl1> that's what i said >_>
00:00:50 <cl1> lol
00:04:48 <mauke> @src ($!)
00:04:49 <lambdabot> f $! x = x `seq` f x
00:04:56 <mauke> yeah, that's what I thought
00:07:19 <cl1> mauke: does (bounds arr) force the memoization?
00:07:26 <mauke> no
00:07:36 * cl1 facepalm
00:08:19 <cl1> is ! the indexer for arr like !! is for lists?
00:08:22 <mauke> yes
00:09:18 <cl1> so if the starting number is in the array (which is 1/3 the size of the range) then it gets it from the array, otherwise it computes it?
00:09:48 <mauke> yes
00:09:53 <cl1> we have a winner
00:09:58 * cl1 cheers
00:10:34 <mauke> the tricky bit is that it computes it via prim, which may call mem, which may use arr
00:10:46 <mauke> which is computed using prim
00:11:20 <cl1> yes
00:11:31 <cl1> and extend is basically what does the counting as it builds the list
00:11:52 <cl1> the tuple that contains the list
00:12:04 <mauke> yeah
00:12:30 <cl1> so now i can answer your original question with "yes, i understand that code"
00:12:44 <mauke> I thought, why call length at the end when I already know how many steps I went through?
00:13:02 <cl1> i don't know how its memoized, but i understand what the code is doing
00:13:09 <cl1> I just learned a whole bunch
00:13:16 <mauke> arr is a memoization table
00:13:53 <mauke> the problem is that a directly recursive version does a lot of duplicate work
00:14:04 <mauke> i.e. many chains share a common tail
00:14:29 <mauke> and there's no point in recomputing common tails
00:14:55 <mauke> so we store those in a lookup table
00:14:59 <jessopher> is there a type that only contains bottom?
00:15:14 <mauke> jessopher: yes, two
00:15:16 <cl1> oh, i see it now
00:15:31 <cl1> | otherwise = extend x (mem (step x))
00:15:35 <mauke> jessopher: 'data Foo' needs a language extension, 'newtype Void = V Void' should be H98
00:15:45 <cl1> it reuses the prebuilt array
00:16:16 <mauke> cl1: thanks to laziness I don't have to be careful about the order in which the array is built
00:17:08 <mauke> that is, the entry for index i may make use of arr ! j and arr ! k, no matter if j < i or i < k
00:17:26 <mauke> the array elements will be computed as needed
00:17:34 <cl1> that is cool
00:17:55 <mauke> (lazy arrays)++  # totally cool
00:18:56 * hackagebot trace-call 0.1 - functions for logging the arguments and results of function calls  http://hackage.haskell.org/package/trace-call-0.1 (BramSchuur)
00:19:45 <cl1> mauke .. thanks for helping me, i've learned alot
00:20:07 <mauke> yay!
00:20:59 <cl1> i'm gonna add that link to my favorites and go over it again tomorrow.
00:21:29 <cl1> for now I should see about getting some sleep
00:28:47 <hpaste> jessopher pasted “type synonym familys” at http://hpaste.org/55264
00:30:54 <VHD> odd, why would this book refer to the "standard function partitions" when its not found on hoogle nor in the standard library.
00:30:55 <VHD> :/
00:31:10 <Jerrry> hoogle? :O
00:31:39 <VHD> Jerrry, http://haskell.org/hoogle/
00:32:00 <Jerrry> Oh, I didn't know about that. Sorry, I'm newb at Haskell.
00:32:36 <VHD> me too :D
00:33:14 <Jerrry> I'm reading the learn you a haskell book.
00:33:43 <mauke> :t partition
00:33:45 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:34:52 <VHD> ok thats very odd, says its not in scope for me (winghci)
00:34:58 <Jerrry> Is it okay if I skip the part about list comprehension? My friend told me that part wasn't necessary to know.
00:35:16 <mauke> @index partition
00:35:17 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
00:35:24 <mauke> VHD: import Data.List
00:35:58 <VHD> I see
00:36:18 <VHD> why did it not show up on hoogle? Does that not include the standard library stuff?
00:36:24 <jessopher> jerrry: its not necessary, but go back to it when you get a chance
00:36:43 <mauke> VHD: http://www.haskell.org/hoogle/?q=partition
00:36:52 <Jerrry> Thanks jessopher.
00:37:03 <VHD> fuuuuuuuu
00:37:11 <VHD> ok I must have made a spelling error, sorry.
00:37:55 <VHD> actually, no. The book refers to partitions with an s DX
00:38:31 <jessopher> might me a spello
00:38:38 <VHD> yeah must be
00:38:39 <jessopher> be*
00:55:33 <Blkt> good morning everyone
00:56:06 <Jerrry> Good morning.
00:59:10 <issactrotts`> Good morning
01:05:32 <ahax> good mornig
01:07:19 <wutwut> Hwy can't I do the following? map (+5) ['I',' ','l','o','v','e',' ','y','o','u','!']
01:08:11 <wutwut> Would be a sweet solution to Cæcar's encryption.
01:08:15 <mux> wutwut: because the + operator is restricted to work on types who have a Num instance, and Char does not
01:08:30 <mux> > map (chr . (+5) . ord) "foo bar baz"
01:08:32 <lambdabot>   "ktt%gfw%gf\DEL"
01:08:36 <mux> you can do that however
01:09:12 <wutwut> Thanxalot!
01:12:28 <issactrotts`> I keep getting Error_EOF while using http-enumerator. I added a bunch of catchErrors, but my crawler still crashes.
01:14:02 <issactrotts`> I also ran from ghci according to the instructions here: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/ghci-debugger.html. It showed "thread killed" when I printed out _exception.
01:19:33 <issactrotts`> \join #yesod
01:20:06 <issactrotts`> Anyone have experience with http-enumerator?
01:20:44 <issactrotts`> Guess not... Good night.
01:20:47 <issactrotts`> \quit
01:33:56 * hackagebot fixhs 0.1.3 - FIX (co)parser  http://hackage.haskell.org/package/fixhs-0.1.3 (ArvinMoezzi)
01:48:53 <salisbury> haskell code is some of the best looking, except for IO...
01:48:53 <lambdabot> salisbury: You have 1 new message. '/msg lambdabot @messages' to read it.
01:49:14 <shachaf> salisbury: IO code in Haskell can be pretty nice, depending on what sort of thing you're doing.
01:49:18 <shachaf> It's first-class, after all. :-)
01:49:47 <salisbury> I'm writing this index thing I came up with to a file
01:50:13 <salisbury> except, its too big to ever hold in memory at once, so the file is full of pointers to other places in the file
01:50:20 <salisbury> that all have to be updated and ugh..
01:51:10 <Botje> and you can't mmap it ? :]
01:51:55 <salisbury> say what
01:51:57 <salisbury> ..
01:52:09 <salisbury> if I go and discover some package that is really useful
01:52:11 <Botje> mmap allows you to map a file into memory
01:52:18 <Botje> without actually loading it into memory
01:53:22 <salisbury> can the file grow to be of extraordinary sizes?
01:53:29 <kmc> yes
01:53:31 <kmc> you can memory-map a file which is much bigger than physical memory
01:53:53 <kmc> the operating system will move pages into and out of physical memory
01:54:01 <kmc> as they are needed
01:54:14 <salisbury> no, rather, what I mean is
01:54:15 <mux> that sounds like a perfect use-case for a B+-tree
01:54:47 <salisbury> I can have a huge file the way in which I do it now
01:55:01 <salisbury> because hSeek and hTell both do Integer
01:55:30 <kmc> you are limited by the amount of virtual address space
01:55:32 <salisbury> so I can go to file position 192198312837912871, or some such
01:55:38 <kmc> so in a 32-bit binary you can only map about 3GB or so
01:55:42 <kmc> in a 64-bit binary you can map a lot more
01:55:49 <kmc> > log 192198312837912871 / log 2
01:55:50 <lambdabot>   57.415373284935335
01:55:50 <shachaf> > 192198312837912871 < (maxBound::Int)
01:55:51 <lambdabot>   True
01:56:14 <kmc> many "64-bit" CPUs only implement 48 or so bits of address space
01:56:43 <kmc> so if your file is really 170 petabytes, and you're not just making that number up
01:56:48 <kmc> then you might have trouble
01:56:49 <ddarius> What is one to do with there > 256 TB files?
01:57:09 <ddarius> s/there/their/
01:57:25 <kmc> anyway memory mapped files are a good thing
01:57:30 <ddarius> I concur.
01:57:32 <kmc> it's one of the main features an OS provides
01:57:51 <kmc> (with lots of hardware support, too)
01:57:52 <kmc> and a ton of work goes into providing it effectively and efficiently
01:57:55 <shachaf> How does GHC handle reading memory-mapped files blocking an OS thread?
01:58:18 <kmc> and then userspace apps ignore this and implement the same thing poorly
01:58:41 <salisbury> >100 petabytes was an exaggeration..
01:58:43 <kmc> shachaf, good question; I don't know if there's anything clever you can do
01:58:48 <shachaf> kmc: Or they implement it non-poorly, when mmap isn't sufficient.
01:59:02 <mellum> there's some downsides, though. If for example someone truncates the file while you work on it, you get a segfault.
01:59:17 <salisbury> but it can get quite large. It indexes pointers to another file, which are looked up with strings
01:59:25 <kmc> define "quite large"
01:59:25 <salisbury> of which I can get up to 10 000 000 an hr
01:59:45 <salisbury> avg str_len ~ 100 chars
01:59:47 <kmc> 1 GB? 10 GB? 100 GB?
02:00:03 <ddarius> 300 TB?
02:00:38 <salisbury> I'm not sure where I am going to cap it yet
02:00:49 <salisbury> it will depend on funding more than anything,
02:01:03 <ddarius> What is the storage capacity of your SAN?
02:01:04 <kmc> ok well that's like 270 kBps
02:01:19 <salisbury> say 100 TB to start with anyways,
02:01:25 <salisbury> its on the cloud
02:01:45 <shachaf> Just to be on the safe side, you should make sure it works with zettabyte drives.
02:02:17 <salisbury> ..
02:02:22 <erus`> are there any other actively developed purely functional languages i might not know about? (i know haskell, clean, pure schemes)
02:02:37 <kmc> cue huge argument about what "pure" means
02:02:39 <ddarius> Excel
02:03:19 <erus`> and are also turing complete
02:03:29 <kmc> i thought clean has impure functions, it just tracks them in the type system
02:03:40 <kmc> but people say that about haskell too, and they're wrong
02:03:42 <kmc> so maybe i am wrong
02:03:55 * shachaf likes kmc's line of reasoning there. :-)
02:05:26 <kmc> thanks shachaf
02:05:50 <ddarius> Clean uses explicit world-passing with uniqueness types.
02:06:47 <ddarius> You can do type IO = State World and have an IO monad exactly like Haskell's.
02:06:49 <jessopher> arent linear/uniqueness types being considered for a ghc extension?
02:07:12 <kmc> i haven't heard about that
02:07:32 <jessopher> i read some proposal somewhere at some point, or i just made it up, i dont remember
02:07:54 <kmc> at the level of IRC discussion sure
02:07:55 <ddarius> jessopher: You just made it up.
02:09:04 <jessopher> :(
02:09:22 <kmc> what would you use it for?
02:09:41 <kmc> you could use it to make GHC's implementation of the IO monad a bit more obviously correct
02:10:14 <blackmirroxx> if someone needs to run ghc  on a non intel machine like PowerBook G4   I know how it works  (at least for me )
02:10:31 <kmc> i don't think ordinary Haskell code should use side-effecting functions with uniqueness types
02:10:59 <jessopher> they dont need to be side-effecting, i would just like to explore uniqueness types in haskell
02:11:00 <ddarius> Uniqueness types aren't in Clean solely for IO.
02:11:01 <kmc> not for IO anyway
02:11:06 <kmc> but yeah, it can be used for other things
02:11:15 <ddarius> Also, even for IO there are some benefits.
02:12:01 <ddarius> For example, you can pull out the file system and have subsets of functions that pass around the file system uniquely.  These functions would be guaranteed not to do network IO.
02:12:12 <kmc> that's cool
02:14:05 <kmc> clean's uniqueness world-passing IO functions are still impure functions, right?
02:14:27 <kmc> in the sense that there's no meaning you can assign to that World value for which they are referentially transparent
02:14:31 <kmc> because the world can change on its own, too
02:14:46 <erus`> not if the function takes no time to complete
02:16:08 <jessopher> and not if all successive values are considered unique, you cant ever apply the function to a previous state of the world
02:16:47 <antilect> Everything made so much sense to me... Then I hit Monads :D
02:16:48 <antilect> Haha.
02:18:40 <jessopher> the uniqueness(ness) prevents the value from ever having more than one reference, so you cant just WorldSnapshot = World
02:21:01 <jessopher> i dunno if that referential transparency, or just referential lack of options, but it seems to have the same net consequences
02:21:17 <kmc> i'm not talking about what the language allows you to do in practical terms
02:21:28 <kmc> i'm talking about whether you can model the functions of the language as mathematical functions
02:22:54 <kmc> which i think you can't, because each "world transformer" not only does something to the world, but also "does" the unrelated things which happened concurrently
02:23:08 <kmc> antilect, oh yeah? what confusion have you run into?
02:23:19 <antilect> Sorting it out, by reading :)
02:24:20 <kmc> "monad" is a difficult concept not because it's so complicated, but because it's so simple yet abstract
02:25:16 <kmc> there are also a lot of prerequisites... you need to understand type classes, algebraic data types, and higher-order functions before you can understand monads
02:25:40 <jessopher> kmc: what do you mean by unrelated? and where is concurrency comming into the picture?
02:26:39 <salisbury> kmc: If there is an external write to the mmap'ed file, it may or may not be propagated into the mmap..
02:27:24 <kmc> jessopher, well, I don't know Clean, so let's talk about the Haskell analogy where IO a = World -> (a, World)
02:27:38 <salisbury> There is an external program that uses the same file, I'll have to see if I can incorporate it with the C FFI. Could be promising though
02:27:41 <salisbury> thanks for the tip
02:28:11 <kmc> say I have an IO action which increments the value in an IORef by one
02:28:24 <jessopher> alright
02:28:30 <kmc> you can say that's a function which takes a world where that IORef has value n, and returns a world where it has value n+1
02:29:06 <kmc> now say another thread writes 5 to that IORef just as my function is finishing
02:29:21 <kmc> now my same function takes the same initial world, and returns a different final world
02:29:30 <kmc> so it's not referentially transparent
02:30:11 <jessopher> well with linear types, the world value would not ever be referenced in both threads concurrently
02:30:32 <jessopher> you would have to pass the world between threads
02:30:34 <kmc> so you can't have shared mutable state in this system of linear-typed IO?
02:30:59 <kmc> what about accessing a file on disk, which some other process may have changed?
02:31:15 <_riba> because searching for "@" on google is not easy: what exactly does @ do in haskell?
02:31:23 <kmc> what about receiving a network packet, which returns a different World depending on some other host's actions
02:31:26 <kmc> _riba, in patterns?
02:31:38 <kmc> the pattern x@p matches the same things as p, but also binds the variable x to the whole thing matched
02:32:06 <kmc> > let a@(b:c) = "xyz" in (a,b,c)
02:32:07 <lambdabot>   ("xyz",'x',"yz")
02:32:30 <_riba> I see, thanks!
02:32:33 <quicksilver> jessopher: with that model you can't explain networks or external devices or.. anything outside of your own little programming language
02:32:50 <kmc> right
02:32:52 <quicksilver> which is a bit of a deficiency since IO's main purpose is to explain those things.
02:32:58 <kmc> you can write filesystem and network programs in this framework
02:33:00 <_riba> exactly what I needed, just wasn't sure
02:33:01 <kmc> and they have well-defined semantics
02:33:07 <kmc> but they are not the semantics of pure function application
02:33:26 <shachaf> It doesn't work if you take IO primitives as being completely opaque?
02:33:37 <jessopher> i think it does
02:33:41 <kmc> Haskell's IO execution also has well-defined semantics, and doesn't require a special type system feature
02:34:21 <jessopher> im not saying its better than haskells current IO semantics, just that linear types are useful for abstracting state
02:34:37 <kmc> and i'm not saying they aren't useful
02:34:51 <kmc> just that your "functions" with linear types and side effects are not functions
02:35:17 <kmc> not unless your program really is a closed universe
02:36:18 <quicksilver> (if your program really is a closed universe there is a natural model of it which doesn't require linear types at all :P)
02:36:54 <quicksilver> linear types just let you avoid the presumably expensive operation of 'duplicating the close universe'
02:39:24 <kmc> except it's not even expensive if your interpreter uses shared persistent data :D
02:39:27 <jessopher> i dont really follow. if there are never two identical values in the history or future transformations of the value, the the domain is never the same. so reguardless of the range, you arent 'really' violating function purity
02:40:43 <kmc> this gets into heavy philosophy
02:40:51 <kmc> about whether you can ever perform "the same experiment" more than once
02:42:05 <kmc> so yeah, you can fix it by putting an absolute time in your World type
02:43:27 <kmc> and then you say "receivePacket is the function which, for a World at December 14, 11:15:09.683742 UTC, returns a world where packet P has been received, but for a World at December 14, 11:15:09.683743 UTC, returns a world where packet Q has been received"
02:43:45 <kmc> and i guess that's a pure function
02:43:56 <kmc> but you have no hope of ever describing this function accurately
02:47:10 <quicksilver> kmc: I don't think that's the point
02:47:19 <quicksilver> I think the point is that the world can change at the same time.
02:47:33 <kmc> that's what i'm getting at too
02:47:37 <quicksilver> you can make a case that the function "does the same time" given a precise description of the realworld at time A
02:47:46 <quicksilver> s/same time/same thing/
02:48:01 <quicksilver> but you can't do anything about the fact that the realworld evolves on its own
02:48:09 <quicksilver> which is why IO is nondeterministic
02:49:44 <kmc> but if your world contains an absolute time, then you can never perform the experiment again to notice that the World has evolved on its own differently
02:50:02 <kmc> you just say that, at time t, the world is fated to do x on its own, and at time t+1, it's fated to do y
02:50:46 <kmc> but then it is impossible to reason about the inputs and outputs of this World → World function
02:53:49 <quicksilver> kmc: that amount to saying the semantics is an unknown function
02:54:13 <quicksilver> "we believe this is represented fully by a function World -> World, but we are unable to describe that function"
02:54:21 <quicksilver> not very useful for anything.
02:55:00 <jessopher> unless you consider the rest of the program that isnt that function
02:56:33 <hpaste> “_riba” pasted “:(” at http://hpaste.org/55267
02:57:17 <_riba> it has to be such a simple mistake
02:57:50 <shachaf> _riba: "succ ++ ..." ?
02:57:51 <_riba> but I really don't get where the [State] ( = [Integer]) is supposed to come from
02:58:01 <shachaf> Oh, wait, that's not the function succ.
02:58:23 <shachaf> _riba: Well, it's coming from the type of your function. :-) Or what do you mean?
02:58:49 <_riba> apparently "x" is not Integer, but [Integer]
02:59:22 <shachaf> _riba: Well, we don't know the type of allSuccessors.
02:59:29 <shachaf> Or of "succ".
02:59:31 <_riba> but the type of "allSuccessors", which I forgot to include, is [Integer] and not [[Integer]], so map should work just fine
02:59:46 <etpace> @hoogle (a -> m b) -> Maybe a -> m (Maybe b)
02:59:48 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:59:48 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:59:49 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
03:00:19 <shachaf> allSuccessors returns [Integer], then x is an Integer.
03:00:42 <shachaf> s/^/If /
03:01:11 <shachaf> Which would make allPossibleSuccessors graph x (d - 1) an [Integer]
03:01:34 <shachaf> Which would make map (\x -> allPossibleSuccessors graph  (d - 1)) succ :: [[Integer]]
03:01:40 <shachaf> Maybe you want concatMap?
03:01:57 <int-e> aka >>=
03:02:16 <shachaf> int-e: I don't think bringing that up helps make anything clearer. :-)
03:02:18 <_riba> Oh, that's my mistake. Why would it be [[Integer]]?
03:02:31 <shachaf> _riba: Because of the reasoning I just gave.
03:02:36 <_riba> :D
03:02:45 <shachaf> You're mapping a function :: Integer -> [Integer] on a list :: [Integer].
03:03:06 <shachaf> map :: (a -> b) -> [a] -> [b]; a = Integer; b = [Intger]
03:03:27 <shachaf> map :: (Integer -> [Integer]) -> [Integer] -> [[Integer]]; it's the only way the types could work.
03:03:44 <shachaf> int-e: If I said "you want function composition, which is called (.)", would you say "aka fmap"? :-)
03:04:25 <int-e> shachaf: rarely
03:05:01 <_riba> shachaf: Thanks, I think I got it now.
03:05:12 <etpace> my mapM doesn't have a traversable type :(
03:05:18 <shachaf> Of course, I don't actually know what you're trying to do. :-)
03:05:50 <shachaf> etpace: Well, you'd better import the one that has a Traversable type from where Hoogle tells you it is, then. :-)
03:06:51 <etpace> hah, doh
03:07:41 <int-e> @type fmap fmap fmap join fmap
03:07:42 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
03:07:50 <int-e> shachaf: but since you asked ;)
03:08:30 <_riba> Too bad I don't know how to fix it :D
03:13:59 * hackagebot paragon 0.1.4 - Paragon  http://hackage.haskell.org/package/paragon-0.1.4 (NiklasBroberg)
03:16:49 <_riba> concatMap was exactly what I wanted
03:17:08 <_riba> Thanks :D
04:12:37 <_riba>  No instance for (Num Row) arising from the literal `3'
04:12:39 <_riba> what
04:14:47 <mauke> you're trying to use 3 where a Row is expected
04:15:29 <_riba> Row = [Integer], and 3 is the last element of a list
04:16:50 <mauke> ok, you're trying to use 3 where a list is expected
04:18:25 <_riba> I call a function that takes an [Integer]. The exact list is [1, 50, 30, 10, 40, 20, 3]. Why would it expect 3 to be a list?
04:18:41 <mauke> what's the exact error message?
04:19:31 <_riba> http://pastebin.com/34JCtvSC
04:19:33 <mauke> The paste 34JCtvSC has been copied to http://hpaste.org/55269
04:19:59 <mauke> _riba: :t isValidSkyline
04:20:24 <_riba> isValidSkyline :: Skyline -> Bool
04:20:33 <mauke> _riba: :info Skyline
04:20:33 <_riba> and Skyline is [Integer]
04:21:45 <_riba> Wait, it's not
04:22:49 <_riba> Okay, I just found the mistake my group partner made
04:23:14 <_riba> Working with foreign code can be very confusing
04:23:18 <_riba> Thanks for helping!
04:24:54 <_riba> (For some reason, there's a Skyline = [[Integer]] and a Skyscraperline = [Integer] that got mixed up...)
04:40:39 <geheimdienst> i don't see a way to check the value of a QSem (readonly, e.g. for only printing an informational message "16 things remaining") http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-QSem.html
04:41:07 <geheimdienst> is there some philosophical problem with that, or could an enterprising young man add a function for that?
04:41:19 <geheimdienst> s/with that//
04:41:55 <hpc> "A QSem is a simple quantity semaphore, in which the available "quantity" is always dealt with in units of one. "
04:42:17 <hpc> so... use a different type if you want to count things remaining? :P
04:42:28 <Cale> geheimdienst: You can keep track of it separately, but there's clearly no way to get the remaining quantity
04:42:30 <flux> geheimdienst, I think you're not supposed to use the value for anything. but of course, it wouldn't hurt for debugging/informational purposes.
04:43:24 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Concurrent-QSem.html#QSem -- the implementation is fairly trivial though.
04:44:06 <Cale> It would be even simpler using STM
04:44:17 <geheimdienst> cale, you mean a tvar?
04:44:21 <Cale> Yeah
04:45:39 <Cale> You could just use a TVar, and operations which incremented/decremented that, and retried when the value would otherwise become negative.
04:46:38 <geheimdienst> "retried" in the sense of "blocked", right?
04:46:44 <ClaudiusMaximus> @hoogle Sem
04:46:45 <lambdabot> System.Posix.Semaphore data Semaphore
04:46:45 <lambdabot> package semaphore-plus
04:46:45 <lambdabot> System.Posix.Semaphore semCreate :: OpenSemFlags -> Bool
04:47:42 <kmc> geheimdienst, retry :: STM a
04:47:53 <kmc> which has the semantics of immediate retry
04:48:12 <kmc> but GHC will implement it with blocking instead
04:48:31 <kmc> it knows which TVars you read along the path to get there, so it can block until one of those changes
04:48:50 <kmc> STM is really powerful for building new concurrency "primitives"
04:50:00 <kmc> because you have direct control over atomicity, blocking, and alternative actions when blocked
04:51:01 <geheimdienst> ah i see, i've checked out STM's retry function now
04:51:48 <kmc> the best intro I know regarding STM is the last chapter of RWH
04:53:56 <kmc> if 'atomically' is a more composable alternative to locks, then 'retry' is a more composable alternative to condition variables
04:53:57 <Cale> The original paper on STM Haskell is also pretty good
04:54:20 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
04:55:40 <Cale> For some odd reason 'atomic' got renamed to 'atomically'
04:55:53 <kmc> probably for the sake of "atomically $ do"
05:00:31 <MonsterSoul> hi
05:00:44 <kmc> hi MonsterSoul
05:00:55 <MonsterSoul> I would need some help in haskell for getting a score to display in my quiz
05:01:03 <MonsterSoul> for some reason I tried but I get out of scope
05:01:13 <MonsterSoul> (new to functional language
05:01:14 <kmc> ok
05:01:18 <kmc> you can put your code on hpaste.org
05:01:22 <kmc> so we can take a look
05:01:25 <MonsterSoul> okay
05:01:34 <kmc> (and the error message)
05:02:15 <hpaste> MonsterSoul pasted “Haskel quiz” at http://hpaste.org/55270
05:02:53 <MonsterSoul> I did try doing userScore in every then userScore = userScore + 1
05:02:59 <MonsterSoul> or ++ but that didn't work
05:03:17 <MonsterSoul> pretty simple -_- pretty new
05:03:22 <kmc> you're doing the same thing five times
05:03:29 <kmc> you shouldn't copy-paste that code five times
05:03:33 <kmc> write a function and use it five times
05:03:39 <_riba> ++ is for concatenating lists, btw
05:03:39 <MonsterSoul> kk
05:03:51 <MonsterSoul> wr
05:03:54 <kmc> also variables don't work like that in haskell
05:04:00 <kmc> you can't change the value of a variable
05:04:09 <MonsterSoul> ok so immutable
05:04:10 <kmc> you should probably pass the score into that function
05:04:12 <kmc> and return the new score
05:04:18 <kmc> what are you learning haskell from? some tutorial?
05:04:25 <MonsterSoul> yeah bunch of tutorials
05:04:28 <kmc> which ones?
05:04:30 <MonsterSoul> non really in IO
05:04:47 <kmc> i suggest reading through LYAH
05:04:48 <kmc> @where LYAH
05:04:48 <lambdabot> http://www.learnyouahaskell.com/
05:04:57 <MonsterSoul> that one actually
05:05:53 <MonsterSoul> I should try making a function to get the score okay thanks
05:05:59 <kmc> :)
05:06:48 <_riba> I have a [[[a]]] (matrix of [a]). I want to filter by the inner [a], is there some way to do that?
05:08:12 <kmc> :t \f -> map (filter f)
05:08:13 <lambdabot> forall a. (a -> Bool) -> [[a]] -> [[a]]
05:08:18 <kmc> :t \f -> map (map (filter f))
05:08:19 <lambdabot> forall a. (a -> Bool) -> [[[a]]] -> [[[a]]]
05:10:50 <_riba> I thought map would return me a list of Bool
05:11:06 <_riba> Thanks!
05:11:20 <kmc> why?
05:11:30 <kmc> :t map
05:11:30 <_riba> :t map
05:11:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:11:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:11:41 <donri> it does if you map a predicate over a list
05:12:05 <_riba> Now that you ask, I have no idea
05:12:30 <kmc> maybe you were thinking  filter (map f)  instead of map (filter f)
05:12:43 <kmc> the former is a type error, because [b] ≠ Bool, no matter what b is
05:13:01 <yitz> @type (map.map.filter)
05:13:02 <lambdabot> forall a. (a -> Bool) -> [[[a]]] -> [[[a]]]
05:14:51 <_riba> sigh
05:14:55 <_riba> I'll just give up
05:15:13 <kmc> on what
05:15:30 <_riba> On trying to finish this on time, which would be in 16 minutes
05:19:00 <_riba> For weeks now it was always the same, I tried to understand Haskell by reading tutorials, but my group partner just sat there and watched me code
05:19:30 <_riba> Last week, he didn't even show up and I had to do everything
05:20:06 <_riba> And this week I had an exam and did not have the time
05:20:09 <kmc> that sucks
05:20:27 <_riba> And of course, he didn't do anything
05:20:35 <Shammah> kick him out?
05:20:46 <kmc> useless group partner can ruin a class or worse
05:21:09 <arw> lazy group partners are quite annoying. and often, getting rid of them is really hard, depending on the staff in charge...
05:21:14 <MonsterSoul> should this function work for a score
05:21:16 <MonsterSoul> score :: [Int] -> Int --read as "score has the type int list mapped to an int" score ([]) = 0 score (a:b:c:d:e) = a + b + c + d + e
05:21:31 <mauke> no
05:21:38 <kmc> MonsterSoul, no, because in the pattern (a:b:c:d:e),  a,b,c,d have type Int but e has type [Int]
05:21:40 <mauke> d + e is a type error
05:21:42 <kmc> maybe you meant the pattern [a,b,c,d,e]
05:21:51 <kmc> but maybe you should just use the 'sum' function
05:21:54 <kmc> > sum [1,10,100]
05:21:55 <lambdabot>   111
05:22:00 <hpaste> monstersoul annotated “Haskel quiz” with “Haskel quiz (annotation)” at http://hpaste.org/55270#a55271
05:22:27 <kmc> > let f (a:b:c) = (a, b, c) in f [1,2,3,4,5,6,7,8,9,10]
05:22:28 <lambdabot>   (1,2,[3,4,5,6,7,8,9,10])
05:23:18 <MonsterSoul> how could I use the sum function properly in my program
05:23:31 <kmc> i don't know
05:23:55 <kmc> it looks like this function "score" you are trying to write is just like "sum" except that it only works on lists of 0 or 5 elements
05:24:04 * hackagebot atl 15322.1 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15322.1 (MatthewFarkasDyck)
05:25:55 <MonsterSoul> Yeah I just want it to write how many question I got correct and total of 5 question
05:27:06 <Shammah> let score = sum . filter (\x -> length x == 5)
05:27:09 <Shammah> like that?
05:27:14 <MonsterSoul> yeah
05:27:33 <MonsterSoul> but how could I add it up everytime I get a correct one
05:27:41 <Shammah> what defines correct?
05:28:18 <MonsterSoul> I just have a an if statement for current int in my list of answers
05:28:20 <_riba> MonsterSoul, I'm new myself, but I'd say you picked a wrong approach to Haskell
05:28:25 <frerich> MonsterSoul: I think it would be a good idea to not try to wriet the whole program in such an imperatiev style
05:28:37 <PatrickRobotham> What does userScore2 ++ 1 do?
05:28:51 <Shammah> append the element 1 to the end of the list of Nums
05:28:53 <Shammah> eg
05:28:53 <mauke> error
05:29:02 <Shammah> [1,2,3] ++ 4 = [1,2,3,4]
05:29:08 <mauke> Shammah: wrong
05:29:11 <Shammah> wrong?
05:29:13 <PatrickRobotham> > [1,2,3] ++ 4
05:29:14 <MonsterSoul> hmm
05:29:14 <lambdabot>   No instance for (GHC.Num.Num [t])
05:29:14 <lambdabot>    arising from a use of `e_11234' at <in...
05:29:19 <geheimdienst> > [1,2,3] ++ [4] -- this works
05:29:19 <MonsterSoul> that might actually work
05:29:20 <lambdabot>   [1,2,3,4]
05:29:22 <MonsterSoul> add to a list
05:29:30 <Shammah> oh, ofcourse yes
05:29:35 <_riba> [1,2,3] : 4 = [1,2,3,4], correct?
05:29:37 <MonsterSoul> wow thats simple
05:29:44 <geheimdienst> :t (:)
05:29:45 <lambdabot> forall a. a -> [a] -> [a]
05:29:47 <PatrickRobotham> That's the first time userScore appears in the program
05:29:54 <Shammah> > [1,2,3] : 4
05:29:55 <lambdabot>   No instance for (GHC.Num.Num [[t]])
05:29:55 <lambdabot>    arising from a use of `e_11234' at <...
05:30:01 <PatrickRobotham> _riba: You've confused appending with prepending
05:30:02 <Shammah> apparantly not
05:30:08 <_riba> :(
05:30:11 <PatrickRobotham> It's 1 : [] , not [] : 1
05:30:12 <geheimdienst> _riba: (:) takes on its left an element, and on its right a list. the reverse isn't possible
05:30:28 <PatrickRobotham> geheimdienst: Unless you're polish :P
05:30:58 <MonsterSoul> so should I write 1: [ ] every time I get then keyword then just add them up
05:31:03 <MonsterSoul> is that possible
05:31:22 <MonsterSoul> so I keep add one to the char list
05:31:29 <MostAwesomeDude> MonsterSoul: There's helper syntax for lists; you can write [1] instead of 1:[]
05:31:30 <geheimdienst> MonsterSoul: be aware that haskell lists are immutable again. [1,2,3] ++ [4] does not change the list [1,2,3], instead it gives you a new list [1,2,3,4]
05:31:46 <MonsterSoul> okay
05:31:50 <frerich> MonsterSoul: Instead of using an imperative mindset, I think it would be good to try to express the program like this: You have a list of 'questions', where each question is the actual text, the possible answers, and the nubmer of the correct answer. You then ahve a function, say, 'askQuestion', which takes a question and yields a bool (True if the answer is correct, False otherwise). You can then map this function
05:31:50 <frerich>  over your list of questions and finally count the number of 'True' in the list to get the final score.
05:32:58 <PatrickRobotham> MonsterSoul: you can use sum to write your score function
05:33:03 <PatrickRobotham> > sum [1,2,3,4,5]
05:33:03 <lambdabot>   15
05:33:27 <_riba> ...or use a list of Integer and append 1 or 0, so that you can sum it up like you wanted
05:33:44 <frerich> MonsterSoul: So instead of this 'first ask one question, then - if the answer is correct - increment a list/counter by one, then ask next question' sequential approach, try to use a more 'declarative' style - I think it fits Haskell much better and your resulting program will probably be much neater, too :-)
05:34:18 <PatrickRobotham> So you have a list of IO Bool?
05:34:45 <frerich> PatrickRobotham: Yep
05:38:51 <PatrickRobotham> frerich: Forgive my ignorance, but how do you fold over a list of IO Bool?
05:39:15 <PatrickRobotham> frerich: Say I wanted to do the monadic equivalent of and
05:39:22 <quicksilver> first use sequence
05:39:24 <kmc> :t and . sequence
05:39:25 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
05:39:25 <lambdabot>       Expected type: [[a]] -> [Bool]
05:39:25 <lambdabot>       Inferred type: [[a]] -> [[a]]
05:39:26 <quicksilver> then you have an IO [Bool]
05:39:35 <quicksilver> which is more useful then [IO Bool]
05:39:35 <kmc> :t fmap and . sequence
05:39:36 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
05:39:39 <WQL> :q
05:39:55 <kmc> in a sense, it's *less* useful.  once the actions are glued together, you can't reorder them, duplicate them, drop them
05:40:00 <kmc> but i understand what you mean
05:40:33 <PatrickRobotham> :t sequence
05:40:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:41:06 <MostAwesomeDude> Isn't sequence just liftM map ?
05:41:12 <kmc> :t liftM map
05:41:13 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
05:41:16 <PatrickRobotham> fmap map?
05:41:36 <kmc> MostAwesomeDude, doubtful, because 'sequence' is a Monad-specific thing, whereas fmap map would work for any Functor
05:42:01 <MostAwesomeDude> Oh, right, it doesn't map another function onto there, it just puts the listed actions into order.
05:42:03 <kmc> PatrickRobotham,  [IO Bool] is a list of "IO actions", i.e. imperative programs... sequence gives you IO [Bool], i.e. a single program which spits out a list of bools
05:42:16 <kmc> there are many ways to glue together a bunch of IO actions
05:42:40 <kmc> sequence glues them together in left-to-right order, without dropping or duplicating any of them
05:44:04 <quicksilver> kmc: yes, good point :)
05:44:11 <quicksilver> kmc: it was a very contextual "more useful"
05:44:15 <kmc> *nod*
05:47:33 <PatrickRobotham> :t sequence
05:47:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:48:05 <PatrickRobotham> Ok, cool
05:48:11 <PatrickRobotham> Thanks guys :)
05:48:46 <dgpratt> I may not be able to look at that type signature again without thinking of sausage
05:49:21 <frerich> PatrickRobotham: So yeah, I refrained from asking your question since I'm not super familiar with Haskell yet. I just thought that if you have an [IO Bool] you could use some lifting to use the plain 'and' and 'length . filter' (to count correct answers) functions into the IO monad. But kmc and quicksilver know a lot more about this than I do, so I let them give you the actual details :)
05:49:30 <frerich> PatrickRobotham: s/asking/answering/
05:49:50 <frerich> I'm actually quite surprised nobody bashed my 'declarative' approach to writing this little game. :-}
05:51:09 <lukish> newtype State s a = State {  state :: (s -> (s, a))
05:51:09 <lukish> }
05:51:19 <lukish> What does it mean?
05:51:26 <PatrickRobotham> That's the good thing about #haskell, everyone knows a trick or two,
05:51:35 <kmc> lukish, it's declaring a data type named State
05:51:38 <lukish> That state is type constructor?
05:51:45 <kmc> it's the record syntax
05:52:13 <kmc> newtype State s a = State (s -> (s, a));  state :: State s a -> (s -> (s, a));  state (State x) = x
05:52:21 <lukish> So, if I have x :: State, state x :: s -> (s,a) ?
05:52:31 <kmc> it gives you a function which does the opposite of the State data constructor
05:52:45 <kmc> but you can also use that name 'state' with record-creation and record-update syntax
05:53:02 <kmc> in this case, though, it's probably done just to get the function
05:53:03 <kmc> read about haskell records
05:54:02 <dgpratt> lukish: the answer to your last question is yes, btw
05:55:06 <kmc> PatrickRobotham, frerich, [IO Bool] might be a convenient type for defining the questions to ask, but once you ask those questions you're going to want IO [Bool]
05:55:22 <lukish> dgpratt: okay
05:56:55 <kmc> [IO Bool] is a list of independent imperative programs; the order of execution hasn't been fixed yet
05:57:17 <kmc> to ask the questions once each, you'll feed that to 'sequence' to get IO [Bool], and stick that on the left-hand side of (>>=) so you can use the [Bool] result
06:00:36 <yujie> test
06:00:51 <arw> > 1/0
06:00:52 <lambdabot>   Infinity
06:00:58 <arw> still works
06:01:30 <kmc> > text (map pred "ifmmp!zvkjf")
06:01:31 <lambdabot>   hello yujie
06:02:01 <kmc> > map succ "HAL"
06:02:02 <lambdabot>   "IBM"
06:02:25 <kmc> > map succ "VMS"
06:02:26 <lambdabot>   "WNT"
06:14:13 <EvanR-work> lol
06:21:38 <frerich> Hm I was just thinking about whether or not I like it that "succ 'A'" works but "'A' + 1" doesn't, and that got my side tracked to the different type classes. I wondered - is there a type which is a member of Enum but not of Ord, or does the former always imply the latter?
06:23:08 <tromp> you can define such a type trivially
06:23:08 <EvanR-work> > True > False
06:23:09 <lambdabot>   True
06:23:24 <EvanR-work> > GT > LT
06:23:25 <lambdabot>   True
06:23:43 <ClaudiusMaximus> frerich: Enum is for making [a..] and [a..b] and [a,b..] and [a,b..c] work, using it for anything else is a bit hacky imo
06:23:56 <tromp> although every Enum type implies an ordering through the fromEnum function
06:24:02 <EvanR-work> ClaudiusMaximus: in that case, Ord is an obvious extension
06:24:17 <EvanR-work> would it make sense NOT to have Ord
06:24:32 <mauke> x > y = null [x .. y]
06:24:47 <vasilica> cum sa te cheme mauke
06:25:00 <quicksilver> > () > ()
06:25:01 <frerich> tromp: Yes I could of course come up with a contrived example, I was more thinking of 'useful' types.
06:25:01 <lambdabot>   False
06:25:24 <int-e> > null [0.1 .. 0.0]
06:25:25 <lambdabot>   False
06:25:28 <arw> EvanR-work: one could argue, that it would make sense to have different Ord instances for the same Enum. like e.g. different orderings of letters, depending on the locale.
06:26:18 <EvanR-work> arw: but the same Enum mapping?
06:26:18 <arw> EvanR-work: also, vectors of int are (in a mathematical sense) enumerable, but there is no natural or obvious ordering
06:26:21 <quicksilver> frerich: looking at the list here I think they are all Ord - http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#t%3AEnum
06:26:44 <quicksilver> I think there is a natural ordering on vectors.
06:27:01 <tromp> > () < ()
06:27:02 <lambdabot>   False
06:27:06 <quicksilver> furthermore, "Enum" doesn't really represent enumerable in haskell.
06:27:08 <byorgey> augur: ?
06:27:24 <quicksilver> "Enum" really represents ".." or "supports ranges"
06:27:33 <arw> quicksilver: that is of course true, and also why those examples of mine suck :)
06:27:39 <quicksilver> it's a bad class or a bad name depending how you look at it :)
06:27:58 <tromp> > [0.0 .. 1.5]
06:27:59 <lambdabot>   [0.0,1.0,2.0]
06:28:07 <quicksilver> and the notion of "ranges" or ".." is pretty intimately linked to order, I'd say
06:28:13 <quicksilver> like mauke's definition.
06:28:30 <quicksilver> > [1.1 .. 1.2]
06:28:31 <lambdabot>   [1.1]
06:28:32 <tromp> for doubles it's not the usual sense of range:(
06:28:47 <byorgey> > [1.2 .. 1.1]
06:28:47 <lambdabot>   [1.2]
06:28:53 <quicksilver> yes, it's the weird haskell sense.
06:29:21 <byorgey> > [1.2 .. 1.1] :: [Rational]
06:29:22 <lambdabot>   [6 % 5]
06:29:26 <byorgey> HATE
06:29:34 <cheater_> you just need an order where the elements indicating the ends of the range are "total" elements
06:29:39 <frerich> I'm glad nobody came up with something like "Oh well of course, consider the numbers in the Markov space of homonoid bi-functors, the co-domain is enumerable but there is no order!!" or that :-}
06:29:42 <cheater_> meaning that they're comparable to all other elements.
06:30:02 <EvanR-work> > [1%2 .. 7%8]
06:30:03 <cheater_> which lets you, for example, define ranges on graphs.
06:30:03 <lambdabot>   [1 % 2]
06:30:06 <Cale> The only thing which bothers me about the Enum instance for Float etc. is the approximating treatment of the end point.
06:30:08 <byorgey> frerich: well, that goes without saying
06:30:17 <Cale> Otherwise, it's pretty convenient.
06:30:20 <EvanR-work> > [1%2 .. 99%8]
06:30:21 <lambdabot>   [1 % 2,3 % 2,5 % 2,7 % 2,9 % 2,11 % 2,13 % 2,15 % 2,17 % 2,19 % 2,21 % 2,23...
06:30:22 <arw> quicksilver: does haskell require pred and succ or their repeated application to be unique? if not, one obvious example for "does Enum but not Ord" would be modular arithmetics.
06:30:25 <byorgey> Cale: agreed
06:30:33 <cheater_> not all ranges on all graphs, but still
06:30:34 <quicksilver> arw: haskell doesn't require anything I don't think
06:30:42 <cheater_> EvanR-work: what does that syntax do?
06:30:49 <EvanR-work> its not syntax
06:30:49 <quicksilver> arw: the class is pretty weird / underspecificed.
06:30:58 <EvanR-work> % is constructor for rational
06:30:59 <Cale> I don't think it should enumerate all possible Floats or that the instance should be missing or anything like that.
06:31:03 <cheater_> EvanR-work: oh
06:31:04 <Cale> It's not underspecified.
06:31:14 <ClaudiusMaximus> > succ maxBound :: Word8
06:31:14 <Cale> The Report specifies what Enum is quite clearly.
06:31:15 <lambdabot>   *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
06:32:47 <EvanR-work> Enum for Rational should enumerate them all in order ;)
06:33:18 <quicksilver> arw: OK, it is forbidden
06:33:22 <frerich> Hm, I didn't realize that 'Float' is a member of Enum, but I guess it actually makes sense somehow (ahem...) if you consider that Float is not arbitrary precision. Actually, in that case - why isn't Float a member of Bounded?
06:33:25 <quicksilver> The calls succ maxBound and pred minBound should result in a runtime error
06:33:41 <Cale> frerich: What does arbitrary precision have to do with it?
06:33:47 <quicksilver> frerich: the Enum instance for Float is not an enumeration of Floats
06:33:50 <quicksilver> it's just about ranges.
06:33:57 <quicksilver> ""Class Enum defines operations on sequentially ordered types""
06:34:00 <Cale> > [1.0, 1.5 .. 6.0]
06:34:01 <lambdabot>   [1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0]
06:34:04 <quicksilver> why aren't they Ord instances then I wonder?
06:34:10 <Cale> > [1.0 .. 6.0] :: [Float]
06:34:12 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0]
06:34:28 <Cale> > [e .. pi^2] :: [Float]
06:34:29 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
06:34:29 <lambdabot>         against inferred typ...
06:34:30 <EvanR-work> how is Float bounded ;)
06:34:30 <tgeeky> > [1.0, 1.25, .. 6.0]
06:34:31 <lambdabot>   <no location info>: parse error on input `..'
06:34:40 <tgeeky> > [1.0, 1.25 .. 6.0]
06:34:41 <lambdabot>   [1.0,1.25,1.5,1.75,2.0,2.25,2.5,2.75,3.0,3.25,3.5,3.75,4.0,4.25,4.5,4.75,5....
06:34:47 <Cale> > [exp 1 .. pi^2] :: [Float]
06:34:48 <lambdabot>   [2.7182817,3.7182817,4.7182817,5.7182817,6.7182817,7.7182817,8.718282,9.718...
06:35:13 <frerich> Cale: Maybe I'm just being stupid, but doesn't arbitrary precision mean that you never know what the next number is because there is an infinite number of them? Hm, but then I guess quicksilvers point about 'Enum' mroe being about 'ranges' than 'enumerating values' comes into play.
06:35:36 <Cale> frerich: It counts by 1
06:35:39 <quicksilver> frerich: Enum isn't about next numbers
06:35:41 <quicksilver> it's about +1
06:35:45 <quicksilver> > succ 1.0
06:35:46 <lambdabot>   2.0
06:35:50 <frerich> Yes yes, I realize that slowly but sure. :-)
06:35:53 <quicksilver> as I've been saying, it's a terrible name for a class
06:35:56 <EvanR-work> its about succ, not +1 ;)
06:36:07 <frerich> I somehow thought Enum Float adds epsilon or so :-}
06:36:15 <tibbe> @seen nominolo
06:36:16 <preflex>  nominolo was last seen on #haskell 43 days, 13 hours, 16 minutes and 21 seconds ago, saying: @tell chrisdone #:foo in common lisp are uninterned symbols, I think
06:36:16 <lambdabot> Unknown command, try @list
06:36:25 <Cale> frerich: That would rarely be very useful.
06:36:28 <EvanR-work> > fromEnum 4.567
06:36:29 <tgeeky> now now
06:36:29 <lambdabot>   4
06:36:34 <EvanR-work> > fromEnum 4.569
06:36:35 <lambdabot>   4
06:36:39 <EvanR-work> heh
06:36:48 <EvanR-work> collision
06:37:02 <Cale> fromEnum is a bit weird for the fractional case
06:37:04 <frerich> Thanks everybody, I now have a much better idea of what Enum is *not*. :-)
06:37:23 <Cale> Enum is basically a class which defines how the '..' list syntax works
06:37:28 <Cale> and not much more than that
06:37:39 <tgeeky> so
06:37:53 <tgeeky> > [1.0,0.5 .. 0.015625]
06:37:54 <lambdabot>   [1.0,0.5,0.0]
06:37:57 <blackmirroxx> Hi people I want to compile a stand alone file with hugs ... (an equivalent to gcc -o test test.c --> and can execute it with ./test) for file like example.hs - man hugs leads me alwas to "livemode"
06:37:59 <Cale> So, [a..], [a..b], [a,b..], [a,b..c]
06:38:02 <tgeeky> you might expect that to (reasonably) work
06:38:10 <frerich> Yeah, so maybe thinking of it as 'Interval' would be good.
06:38:20 <kmc> blackmirroxx, well, hugs isn't a compiler
06:38:23 <tgeeky> but haskell won't enumerate downwards
06:38:29 <kmc> why do you want to use it this way
06:38:34 <EvanR-work> > [1.5 .. 6.2] :: [CReal]
06:38:35 <Cale> Interval is similarly, if not more confusing terminology-wise :P
06:38:35 <tgeeky> kmc: generating functions
06:38:36 <lambdabot>   [1.5,2.5,3.5,4.5,5.5]
06:38:45 <quicksilver> Cale: I think fromEnum/toEnum are a mistake
06:38:48 <Cale> blackmirroxx: hugs isn't a compiler
06:38:50 <blackmirroxx> well ghc doesnt work on a PowerBook G4
06:38:54 <tgeeky> I think we are expecting too much of Enum
06:38:56 <Cale> blackmirroxx: hugs is strictly an interpreter
06:38:59 <blackmirroxx> but hugs does
06:38:59 <kmc> blackmirroxx, it should, but anyway
06:38:59 <quicksilver> Cale: or, at least, they shouldn't be in the same class as enumFromThenTo
06:39:04 * hackagebot unordered-containers 0.1.4.4 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.4.4 (JohanTibell)
06:39:08 <Cale> blackmirroxx: What?
06:39:08 <kmc> you can put "#!/usr/bin/env runhaskell" at the top of a file
06:39:20 <kmc> then you can run it as if it were an executable
06:39:23 <quicksilver> I used GHC for years on an iBook G4
06:39:31 <kmc> (on your system, might be runhugs instead of runhaskell)
06:39:32 <quicksilver> from macports
06:39:38 <quicksilver> took about 8 hours to compile but worked fine.
06:39:42 <tgeeky> so with something like [1.0 .. 1.2], you'd need at least one extra peice of information (and probably more) the step size?
06:39:47 <kmc> tgeeky, ?
06:39:53 <Cale> blackmirroxx: I ran GHC on a G4 machine for work several years ago.
06:40:06 <blackmirroxx> @Cale well I tried to install ghc on mac  G4
06:40:06 <lambdabot> Unknown command, try @list
06:40:10 <tgeeky> if you really wanted to (randomly) generate real numbers in a range
06:40:13 <blackmirroxx> yes
06:40:19 <blackmirroxx> it is freaking old
06:40:25 <EvanR-work> random?
06:40:25 <tgeeky> you'd need to tell the range how sparse to make the interval
06:40:27 <kmc> blackmirroxx, so what happened when you tried?
06:40:37 <tgeeky> EvanR-work: right, in theory, not practice
06:40:42 <donri> isn't it easier to say that Enum defines pred/succ?
06:40:42 <EvanR-work> how is it random ;)
06:40:51 <blackmirroxx> another solution is to log to my server with ssh ... and work than on my ghc machine
06:40:56 <tgeeky> donri: but it doesn't define pred/succ in general
06:41:03 <Cale> sure it does...
06:41:06 <Cale> > succ pi
06:41:07 <lambdabot>   4.141592653589793
06:41:13 <donri> hah
06:41:14 <Cale> > pred pi
06:41:14 <lambdabot>   2.141592653589793
06:41:21 <kmc> blackmirroxx, another solution is to install Linux on your G4, directly or in a VM
06:41:24 <tgeeky> yes, I'm pretty sure Pi isn't in the integers
06:41:27 <tgeeky> hehe
06:41:32 <blackmirroxx> well on PowerBook G4 I alwazs receive "bad CPU type "
06:41:52 <Cale> blackmirroxx: Are you trying to install the intel build of GHC?
06:42:00 <EvanR-work> > pi :: Complex Double
06:42:01 <lambdabot>   3.141592653589793 :+ 0.0
06:42:08 <EvanR-work> > succ pi :: Complex Double
06:42:09 <lambdabot>   No instance for (GHC.Enum.Enum
06:42:09 <lambdabot>                     (Data.Complex.Complex GH...
06:42:23 <blackmirroxx> well  have found macport
06:42:37 <Cale> blackmirroxx: It's quite possible that you'll have to take the time to compile your way up from an old version if you want to run it on PPC now...
06:42:37 <blackmirroxx> and then it should work "port install ghc"
06:43:06 <Cale> blackmirroxx: Though that sucks, one would hope that someone has binaries of recent releases for PPC machines.
06:43:09 <blackmirroxx> but for an unknown reason macport desides for ghc as the newest version ....
06:43:26 <blackmirroxx> so I installed an old ghc for my mac
06:43:44 <blackmirroxx> PPC ok
06:44:04 * hackagebot atl 15322.2 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15322.2 (MatthewFarkasDyck)
06:46:21 <blackmirroxx> well on an PPC you can take the source code and compile it directly on the machine .... and so I build my own packages ... it worked for hugs but not for ghc
06:46:43 <kmc> what problem did you encounter building ghc
06:47:07 <kmc> i.e. specific error messages
06:47:14 <Cale> blackmirroxx: The newest version of GHC which provided a PPC package seems to be 6.8.3.
06:47:17 <blackmirroxx> well mac port does not "see" dependencies
06:47:23 <Cale> blackmirroxx: You can probably work your way up from that
06:47:25 <blackmirroxx> like autoconf264
06:47:27 <Cale> http://www.haskell.org/ghc/download_ghc_683
06:47:30 <blackmirroxx> so i install it
06:47:47 <Cale> That's for 10.4
06:47:55 <blackmirroxx> than it continues with the next missing dependency and so forth
06:48:01 <blackmirroxx> i did it for hours
06:48:22 <Cale> See if you can get that binary package working
06:48:29 <Cale> You need a working GHC binary to compile GHC anyway
06:48:53 <blackmirroxx> of course
06:49:48 <blackmirroxx> @Cale .... that was exactly what I was looking for
06:49:49 <lambdabot> Unknown command, try @list
06:51:24 <kmc> irc is not twitter :)
06:51:41 <blackmirroxx> sorry
06:52:31 * kmc should change his nick to something which auto-corrects to 'nixon'
06:52:45 <cheater_> vixen?
06:53:06 <kmc> @cheater_ lol irc #fail #wtf #noob #pwned
06:53:06 <theorbtwo> mixon.  Then you can sound like an obscure category theory term, too!
06:53:07 <lambdabot> Unknown command, try @list
06:53:26 <cheater_> theorbtwo: what term?
06:53:41 <byorgey> or how about "mixin"
06:53:51 <cheater_> @mixin
06:53:51 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
06:53:52 <theorbtwo> cheater_: I don't know, but doesn't "mixon" just sound like such a thing?
06:53:59 <tgeeky> mixon sounds like a string theory particle
06:58:28 <adrake___> Hello, has anyone here used the mongoDB library that is on Hackage?
06:59:07 <kmc> it's usually best to just ask your question
07:01:05 <aadrake> kmc: My question is that after I load the library and (in ghci) try con <- connect "127.0.0.1" [] as in the tutorial I get a message complaining about the function 'connect' being applied to two arguments but the type 'Host -> IOE Pipe' has only one.
07:02:25 <yshavit> style question: do people always explicitly declare the type signature (or whatever it's called in haskell?) of functions? or are some functions obvious enough that you just define them?
07:02:49 <kmc> yshavit, i put a type signature on every top-level declaration (whether or not it's a function)
07:02:56 <yshavit> kmc: okay, thanks
07:02:58 <kmc> but not always on things defined inside 'let' or 'where'
07:03:11 <kmc> if you use ghc -Wall, it will warn you about missing type signatures
07:03:14 <kmc> you should use ghc -Wall
07:03:27 <kmc> i don't understand why it's not the default
07:03:39 <parcs__> aadrake, that's not a question
07:03:42 <yshavit> kmc: okay, neat. It adds a tad of verbosity, but certainly nothing that's overwhelming!
07:03:49 <kmc> which? the type signature?
07:03:53 <yshavit> kmc: yeah
07:03:56 <kmc> yeah
07:04:00 <kmc> i think of them as machine-checkable comments
07:04:02 <aadrake> parcs__: Fair enough.  That's my problem.  The question is, why am I having that problem?
07:04:06 * hackagebot case-insensitive 0.4.0.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.4.0.1 (BasVanDijk)
07:04:12 <yshavit> kmc: that's exactly how I have been :)
07:04:33 <parcs__> aadrake, what is the output of ':i Host'?
07:04:43 <kmc> aadrake, http://hackage.haskell.org/packages/archive/mongoDB/1.1.1/doc/html/Database-MongoDB.html
07:04:48 <kmc> has an example that uses 'connect' differently
07:05:32 <parcs__> aadrake, never mind, listen to kmc. try 'con <- runIOE $ connect (host "127.0.0.1")'
07:05:34 <yshavit> kmc: reason I ask is that yesterday I wrote a function, trim :: (Eq a) => a -> [a] - [a]. Today I decided to make it more generic, trim_while :: (a -> Bool) -> [a] -> [a], and define trim c = trim_while (c==). So, that has a pretty trivial signature, and I didn't know whether it's idiomatic to declare it anyway.
07:05:40 <yshavit> Sounds like it is, which is totally fine with me.
07:06:19 <kmc> it's not trivial...
07:06:46 <yshavit> kmc: well, given the signature for trim_while, trim is pretty easy.
07:07:07 <kmc> "pretty easy" ≠ "trivial"
07:07:13 <kmc> anyway it's not obvious to me
07:07:14 <yshavit> kmc: fair enough
07:07:18 <kmc> maybe it's obvious from knowing what the functions do
07:07:20 <aadrake> parcs__: kmc: success now.  For some reason that is not the way it is written in the example on github.  Thank you both.
07:07:41 <yshavit> kmc: that's a good point
07:07:43 <kmc> i'd guess the example is either too old or too new
07:08:15 <yshavit> kmc: my example? how so?
07:08:23 <kmc> i meant that for aadrake
07:08:46 <yshavit> kmc: makes more sense that way
07:08:48 <yshavit> :)
07:09:06 * hackagebot inch 0.1.0 - A type-checker for Haskell with integer constraints  http://hackage.haskell.org/package/inch-0.1.0 (AdamGundry)
07:09:54 <aadrake> kmc: I think it's too old.  It looks like it was last modified in April 2010.
07:12:09 <aadrake> kmc: I'm not familiar enough with Haskell yet to be able to write code based only on type signatures in the documentation, and there isn't much in the way of examples or tutorials for integrating with mongoDB, so thank you.
07:13:55 <yshavit> I have a question about function composition...
07:13:56 <hpaste> yshavit pasted “composition” at http://hpaste.org/55273
07:14:29 <yshavit> in that example, I have:  not(f(c')).  If I change that to not.f(c'), it doesn't compile. I thought the two were equivalent?
07:14:38 <kmc> (not . f) c'
07:14:43 <kmc> or:  not . f $ c'
07:14:56 <kmc> function application syntax always binds tighter than infix operators
07:15:04 <yshavit> kmc: aaah. Okay. Thanks!
07:15:17 <kmc> so «not.f(c')» is «not . (f c')»
07:15:22 <kmc> also you wouldn't write f(c') anyway
07:15:44 <kmc> as the second warning on hpaste says
07:15:45 <yshavit> kmc: oh, right.
07:16:36 <yshavit> kmc: is there any preference usually as far as not (f c') vs (not.f) c' vs not.f $ c' ?
07:17:03 <cheater_> not $ f c
07:17:39 <yshavit> okay
07:17:46 <kmc> i would go with not (f c)
07:17:50 <kmc> for something so small
07:18:00 <yshavit> $ strictly evaluates things, right? (not saying it's bad here, just confirming)
07:18:02 <kmc> no
07:18:06 <kmc> $! adds strictness
07:18:10 <kmc> @src ($)
07:18:10 <lambdabot> f $ x = f x
07:18:11 <kmc> @src ($!)
07:18:11 <lambdabot> f $! x = x `seq` f x
07:18:21 <yshavit> oooh, seq. Sorry.
07:18:32 <yshavit> So $ is purely a precedence helper
07:18:37 <kmc> no
07:18:40 <yshavit> sigh
07:18:44 <kmc> it's a real operator, you can use it in other contexts
07:18:46 <yshavit> okay, I need to go back to rtfms
07:18:47 <kmc> > map ($ 3) [pred, succ]
07:18:48 <lambdabot>   [2,4]
07:19:03 <kmc> > zipWith ($) [pred, succ] [1, 10]
07:19:04 <lambdabot>   [0,11]
07:19:25 <yshavit> I don't know what just happened...
07:19:41 <kmc> which one?
07:19:51 <yshavit> both, but let me try and figure it out for a sec
07:20:00 <yshavit> oh, I get it
07:20:05 <kmc> > map (+ 1) [10, 20]
07:20:06 <lambdabot>   [11,21]
07:20:16 <cheater_> map ($ 3) [pred, succ] = [($ 3) pred, ($ 3) succ] = [ pred $ 3, succ $ 3 ]
07:20:28 <yshavit> so, I think this should fail...
07:20:30 <cheater_> > ($ 3) pred
07:20:31 <lambdabot>   2
07:20:34 <yshavit> > map (3 $) [pred, succ]
07:20:35 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:20:35 <lambdabot>    `GHC.Enum.Enum a'
07:20:35 <lambdabot>      ar...
07:20:37 <yshavit> woot
07:20:38 <kmc> right
07:20:43 <kmc> > [3 pred, 3 succ]
07:20:44 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:20:44 <lambdabot>    `GHC.Enum.Enum a'
07:20:44 <lambdabot>      ar...
07:20:47 <kmc> > [pred 3, succ 3]
07:20:47 <lambdabot>   [2,4]
07:21:04 <yshavit> I think I'm getting the hang of it
07:21:32 <kmc> yshavit, I would write (f . g . h $ x) in contexts where f, g, h, x are pretty big expressions
07:21:39 <kmc> to avoid piling up a bunch of parentheses at the end
07:22:00 <kmc> if it's just «not (f c)» then i find the parentheses less noisy
07:22:05 <yshavit> kmc: and that's equivalent to f ( g (h x) ), right?
07:22:08 <kmc> yeah
07:22:17 <kmc> of course this is a matter of taste
07:22:25 <yshavit> alright, neat.
07:22:29 <kmc> sometimes i will go through old code and decide i should have done it differently
07:22:30 <_oz> anyone to tell me why this doesn't terminate? (i.e. why can't it be lazier)
07:22:32 <_oz> > take 4 $ fromJust $ some (Just 1)
07:22:36 <lambdabot>   mueval-core: Time limit exceeded
07:22:39 <kmc> :t some
07:22:40 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
07:23:15 <kmc> > some (Just 1)
07:23:18 <yshavit> kmc: alright, I think I'm pretty happy with my trim functions  now. :)
07:23:19 <lambdabot>   mueval-core: Time limit exceeded
07:23:54 <kmc> hmm
07:24:06 * hackagebot network 2.3.0.8 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.8 (JohanTibell)
07:24:07 <_oz> kmc: some (Just 1) should be Just [1,1,..]
07:25:08 <_oz> > take 4 $ fromJust $ Just $ repeat 1
07:25:09 <lambdabot>   [1,1,1,1]
07:25:41 <kmc> > let many_v = some_v <|> pure []; some_v = (:) <$> Just 1 <*> many_v in some_v
07:25:45 <lambdabot>   mueval-core: Time limit exceeded
07:25:56 <mokus> _oz: it can't know without evaluating forever that there isn't a Nothing at the "very end"
07:26:08 <kmc> > (:) <$> Just 1 <*> undefined
07:26:09 <lambdabot>   *Exception: Prelude.undefined
07:26:23 <_oz> @src some
07:26:23 <lambdabot> some v = some_v
07:26:23 <lambdabot>   where many_v = some_v <|> pure []
07:26:23 <lambdabot>         some_v = (:) <$> v <*> many_v
07:26:28 <cl1> is instance Bar Foo where ... the same as data Bar = derived Foo?
07:26:32 <kmc> no
07:26:33 <acowley> I have a library I've been working on that currently defines Data.Ring, Data.DivisionRing, and Data.DualNumber. Should I bury those in a Package.Algebra name space instead to avoid potential clashes?
07:26:57 <kmc> cl1, with "instance" you define the functions yourself.  with "deriving" you tell the compiler to do it for you
07:27:02 <kmc> which it can only do for certain built-in classes
07:27:21 <_oz> mokus: I don't think I get it.
07:27:41 <msieradzki> why does Cabal reference haskell98 other than to cause conflicts with Prelude in base?
07:27:53 <kmc> reference how?
07:28:13 <kmc> > (:) <$> Just 1 <*> Just undefined
07:28:14 <lambdabot>   Just [1*Exception: Prelude.undefined
07:28:20 <_oz> my understanding of some is that it returns every val in Just val, until it sees a Nothing
07:28:26 <_oz> so it can return things earlier
07:28:30 <msieradzki> my bad, hsc2hs
07:28:43 <kmc> reference how?
07:28:49 <blackmirroxx> I have installed ghc (PowerPC) version http://www.haskell.org/ghc/dist/6.8.3/maeder/ghc-6.8.3-powerpc-apple-darwin.2.tar.bz2 from http://www.haskell.org/ghc/download_ghc_683#macosxppc d but I have excactly the same problem as mentioned in http://www.cse.unsw.edu/~homecomputing/cdrom/html/ghc.html :... with other words Library is missing - Does anyone know how to fix this ? - (thx to Cale - the installation process configure + make 
07:28:54 <msieradzki> build-depends
07:29:11 <kmc> msieradzki, build-depends where? hsc2hs.cabal?
07:29:15 <msieradzki> yes
07:29:21 <kmc> the one i just grabbed doesn't have it
07:29:30 <mokus> _oz: it could probably be implemented that way, my guess is that it uses the default implementation defined in the Alternative class though
07:29:32 <kmc> oh, but the version on hackage is super old
07:30:09 <msieradzki> oh, you're right, it's just in my 7.0.4
07:30:20 <mokus> _oz: which is the @src you looked at
07:30:44 <kmc> msieradzki, i don't seem to have that dependency in my ghc-7.2.1 copy
07:30:56 <msieradzki> yes, nevermind that as I see it was already removed
07:32:37 <_oz> mokus: there is a recent discussion on haskell-cafe, people say some and many cannot be implemented for functors which "sometimes succeed and sometimes don't"
07:32:48 <_oz> I don't see why that has to be the case
07:33:15 <kmc> acowley, i say no, unless your idea of DivisionRing etc. is somehow very specific to your library
07:33:26 <kmc> if it's in principle a general purpose division ring library, then don't bury the names
07:33:32 <mokus> _oz: Actually, it's that they only make sense for functors where there are specific values that can go either way depending on some hidden inputs
07:33:36 <mokus> or hidden state
07:33:37 <kmc> you can also check hackage for other packages defining those modules
07:34:06 <_oz> they make perfect sense for maybe in my mind
07:34:35 <mokus> _oz: they could probably be made to make some kind of sense, but it's really not the sense that they were designed for I don't think
07:35:17 <mokus> _oz: just like groupBy and nubBy can be abused to do some things pretty far outside their intended scope
07:35:35 <_oz> like what?
07:36:06 <quicksilver> _oz: some (pure 1) is not supposed to be Just [1,1,1,1,1,1,1,1....]
07:36:30 <quicksilver> some (pure 1) is supposed to me [1] or [1,1] or [1,1,1] or [1,1,1,1] or [1,1,1,1,1] or .....
07:36:41 <quicksilver> and Maybe doesn't have the structure to support that.
07:36:49 <mokus> I'd have to look that up, it's been a while since i've seen the offending usages, but using them with non-equivalence relations lets you do some "interesting" things
07:37:00 <quicksilver> > Just [1] <|> Just [1,1]
07:37:00 <lambdabot>   Just [1]
07:37:29 <_oz> I see what you mean by the number of 1's.
07:37:39 <_oz> but the last example isn't an example for that, is it?
07:37:56 <_oz> > Just [1] <|> Just [2] -- this is Just [1] as well.
07:37:57 <lambdabot>   Just [1]
07:38:00 <quicksilver> well the semantics of alternative for Maybe are "first success"
07:38:09 <Ptival> is it weird to use an option type as an optional refinement, "Nothing" meaning "Everything"?
07:38:38 <quicksilver> but the alternatives for 'some' are perhaps not in any particular order
07:38:47 <quicksilver> which makes it hard for a biased-choice Alternative like Maybe.
07:39:01 <_oz> so for the case of "some" since we know there won't be a Nothing coming up later (for Maybe), we can return Just (repeat 1) ?
07:39:06 <quicksilver> > pure (some 1) :: [[1]]
07:39:07 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
07:39:07 <lambdabot>         against inferred t...
07:39:18 <quicksilver> oops
07:39:30 <quicksilver> > some (pure 1) :: [[Int]]
07:39:34 <lambdabot>   mueval-core: Time limit exceeded
07:39:46 <acowley> kmc: Thanks for the input. edwardk's algebra package is probably what I would lean on in an ideal world, but it's a rather large pill to swallow. And the pill is mostly unlabelled (uncommented). My classes are instead extensions of the vector-space classes.
07:40:41 <_oz> quicksilver: btw, some (pure 1) :: Maybe [Int] already returns Just [1,1,..]
07:40:42 <cheater_> acowley: consider talking to edwardk about better documentation
07:41:48 <_oz> (and when I say returns, what I mean is "evaluates to". screw my imperative language)
07:42:15 <quicksilver> > some (pure 1) :: Maybe [Int]
07:42:19 <lambdabot>   mueval-core: Time limit exceeded
07:42:24 <acowley> Ptival: it's not weird, but you might consider using your own datatype isomorphic to Maybe with a more helpful name.
07:42:25 <quicksilver> _oz: it does?
07:42:25 <kmc> what, you mean swallowing unlabeled pills is a bad idea?
07:42:34 <_oz> oops.
07:42:35 <quicksilver> surely it doesn't, and that's what we were talking about?
07:42:46 <_oz> yes, right.
07:42:57 <acowley> cheater_: his hackage output is too prolific for documentation, and I don't know who besides him is qualified to document his work.
07:43:12 <cheater_> acowley: BS
07:43:19 <acowley> let me rephrase
07:43:47 <acowley> *I* don't want to undertake to document all his hackage output both due to its volume and sophistication when all I need are a few morsels.
07:43:48 <_oz> quicksilver: I still don't see why it doesn't. to me it is the only sensible thing to do for Maybe.
07:44:21 <quicksilver> _oz: to me it seems it is one thing it cannot be.
07:44:38 <cheater_> acowley: i was talking about him writing the docs.
07:44:43 <cheater_> suggest to him that it's a good idea.
07:44:55 <quicksilver> if some (Just 1) is supposed to be (Just [1] <|> Just [1,1] <|> Just [1,1,1] .... )
07:45:02 <quicksilver> then it certainly can't be Just [1,1,1,.....]
07:45:03 <cheater_> he seemingly needs this input if according to you the docs are lacking.
07:45:10 <quicksilver> it has to be one element in the list
07:45:13 <acowley> cheater_: oh, well that I can do -- in fact, I do so as often as I feel I can without being too annoying
07:45:19 <quicksilver> depending which concreate order you choose
07:45:24 <cheater_> that's wrong
07:45:44 <cheater_> people will generally only do what keeps them in their comfort zone
07:45:57 <cheater_> if you don't get annoying they're still in their comfort zone -> no action :p
07:46:10 <_oz> quicksilver: so you say some (pure 1) should be Just [1] ?
07:46:32 <acowley> Also, he is tremendously helpful in person. I think what is needed is to come up with a strategy of breaking down some of his large packages so as to farm out the labor of applying polish in manageable amounts.
07:46:47 <kmc> also prioritize
07:47:04 <kmc> it's probably not important to document the obscure "for completeness" parts of category-extras or whatever
07:47:14 <kmc> zygochronohyloplasmofunctor
07:47:31 <quicksilver> _oz: well there is no value which satisfies the two equations in the docs.
07:47:36 <quicksilver> (which is why it fails)
07:47:38 <nooodl> hi, what's wrong with this function: f x = (conjugate x) * (0 :+ 1) + (realPart x)
07:47:45 <kmc> you tell us
07:47:48 <nooodl> it gives an "infinite type" error. i'm not sure why
07:47:55 <kmc> :t conjugate
07:47:56 <lambdabot> forall a. (RealFloat a) => Complex a -> Complex a
07:48:03 <kmc> :t realPart
07:48:03 <lambdabot> forall a. (RealFloat a) => Complex a -> a
07:48:04 <acowley> what is the type of the result of the (*) operation?
07:48:16 <kmc> maybe you mean:  f x = (conjugate x) * (0 :+ 1) + (realPart x :+ 0)
07:48:18 <quicksilver> I suspect you want (realPart x :+ 0)
07:48:19 <_oz> quicksilver: and which is why some (and many) are part of the type-class. so the Maybe instance can define its own "some"
07:48:31 <nooodl> ah, i'm adding a Complex and a RealFloat
07:48:32 <quicksilver> _oz: I'm not talking about the default definitoins.
07:48:43 * acowley abandons being Socratic
07:48:46 <quicksilver> _oz: I'm talking about the *rules* in the documentation.
07:48:52 <pumpkin> acowley: time for plato?
07:49:01 <quicksilver> _oz: (which, admittedly, happen to resemble the default definitions precisely)
07:49:09 <_oz> ok, I need to check those a bit more closely then.
07:49:18 <_oz> anyway. I'll just leave this on the side of my brain to brew for a while.
07:49:45 <pumpkin> cheater_: edwardk mostly writes his packages for his own edification, so usually isn't too interested in writing documentation
07:49:47 <acowley> #haskell is full of platonic relationships
07:50:00 <_oz> quicksilver: thanks.
07:51:15 <cheater_> pumpkin: he should at least write co-dumentation
07:51:34 <acowley> no, that's what he does!
07:51:38 <cheater_> pumpkin: but seriously, i would call BS on that too :)
07:51:57 <cheater_> "i do it only for myself so i don't need docs" == bs
07:52:02 <acowley> Co-documentation is socratic documentation. The user asks, "What the heck is this?" and must educate themselves to understand.
07:52:25 <pumpkin> cheater_: he obviously isn't interested in doing it, and who are you to tell him to? :P
07:52:31 <pumpkin> he likes the problem solving aspect of it
07:52:40 <pumpkin> I work right next to him, and have seen him write most of these packages
07:52:45 <cheater_> pumpkin: i think you have just imagined i am telling him to, while i am not telling him to.
07:52:53 <pumpkin> you told acowley to tell him
07:52:59 <cheater_> pumpkin: then you have projected this.
07:53:00 <acowley> cheater_: even when it's frustrating, I'd rather have his undocumented epic poems of algebra publically available then give them up all together.
07:53:00 <msieradzki> does anybody find it weird how little of ghc-7.0.4 code is accepted when compiling with ghc-7.2.1? :)
07:53:06 <cheater_> pumpkin: no, i told acowley to make a suggestion :)
07:53:29 * pumpkin shrugs
07:53:32 <kmc> "who are you to tell him"  uh, a prospective user of the code?
07:53:37 <acowley> I should really delegate that to pumpkin due to physical proximity
07:53:37 <quicksilver> right
07:53:41 <quicksilver> exactly what kmc said.
07:53:58 <quicksilver> there is nothing wrong or inappropriate or offensive about asking someone to explain their package
07:54:02 <cheater_> oh right i forgot, type signatures are all the documentation we need, right?
07:54:06 <quicksilver> it's taking an interest in their work.
07:54:13 <copumpkin> kmc: yeah, but he's made it clear that he isn't interested in that part of it, and is mostly making them available in the hopes that enterprising users will write the documentation for him
07:54:21 <cheater_> copumpkin: has he
07:54:22 <cheater_> ?
07:54:23 <copumpkin> quicksilver: yeah, I guess it's just easy to get annoyed with cheater
07:54:27 <cheater_> when/where?
07:54:29 <quicksilver> copumpkin: he hasn't made that remotely clear.
07:54:37 <quicksilver> copumpkin: unless it was a private conversation with some people not including me
07:54:48 <quicksilver> and I reserve the right not to be aware of such :)
07:55:07 <kmc> if acowley wants to suggest things that's fine; edwardk can ignore suggestions and i don't think his feelings will be mortally wounded
07:55:07 <cheater_> here's the thing copumpkin
07:55:11 <cheater_> and it's the crux of the matter
07:55:15 <quicksilver> I'm *fairly* sure I've heard him say stuff like "yeah, I should write that up a bit"
07:55:21 <cheater_> no one can write documentation for edwardk's code except edwardk
07:55:25 <quicksilver> but I can't be entirely sure since I'm quite senile.
07:55:28 <cheater_> it will never work in any other way
07:55:28 <copumpkin> cheater_: that's not true at all
07:55:29 <quicksilver> cheater_: well that's not true either ;)
07:55:51 <cheater_> you can only scratch the surface if you're not the original maker of the code
07:55:58 <copumpkin> no, that's not true
07:56:01 <quicksilver> plenty of people have the skills and the comprehension to doc his code, or large parts of it.
07:56:22 <quicksilver> and gaps can be filled by asking him direct questions.
07:56:35 <quicksilver> I could doc 95% of data-lens
07:56:41 <quicksilver> and ask him about the remaining 5%
07:56:48 <quicksilver> I'm not volunterring though
07:56:57 <copumpkin> quicksilver: oh, I know that he wants people to get interested, but usually in the form of writing a monolithic chunk of text (a blog post) telling people how it works on a high level, not per-function, per-module documentation. I think his crapload of undocumented packages attest to his lack of interest in the latter problem
07:56:59 <Philonous_> So when are you going to do it? ;)
07:57:35 <acowley> I've been using data-lens a lot recently, I actually thought it was documented
07:57:48 <acowley> ..and it mostly is
07:58:11 <cheater_> i'm not saying edwardk is doing something wrong, you know
07:58:19 <cheater_> he's very friendly for making his code available at all
07:59:04 <cheater_> but i think an aggressively apologetic stance towards bad practice in our dev ecosystem is very bad
07:59:17 <cheater_> take it or leave it
07:59:25 <acowley> For my own code, I actually find it much easier to keep up reasonable documentation while working than to go back and add the documentation later.
07:59:38 <kmc> it would help if there were some clear delineation on hackage between "production-ready libraries" and "stuff i half finished one day for fun"
07:59:41 <kmc> and a way to search only the former
07:59:56 <kmc> perhaps Hackage 2.0 Nukem Forever will have this feature
08:00:04 <copumpkin> lol
08:00:17 <copumpkin> at this rate, we might get textmate 2 before hackage 2
08:00:21 <kmc> Hackage 2.0nd Avenue Subway
08:00:25 <quicksilver> kmc: it would be hard to classify edwardk's work into those two.
08:00:52 <quicksilver> textmate 2 already exists, it's called emacs *duck*
08:00:59 <copumpkin> lol
08:01:04 <copumpkin> there's also an alpha that was just released
08:01:34 <acowley> emacs - split windows, etc.... but prettier and easier to customize in certain ways
08:01:38 <benmachine> thanks for volunteering to work on hackage 2 you guys :P
08:02:31 <acowley> you have shamed us all
08:03:34 <erus`> im waiting for hackage 2.1 before i switch
08:03:48 <erus`> im not gonna be a beta tester for a big software company
08:05:37 <acowley> Hackage 2.1 is how they will host hackage 2.0. The key is lazy evaluation.
08:05:45 <cheater_> kmc: it's naiive to think that this sort of hard classification would work at all
08:06:04 <cheater_> kmc: the only way to improve things is from within each developer, by them adhering to standards on their own
08:06:30 <cheater_> not by a decision-by-commitee which tells you if your code should ride the back of the bus
08:06:55 <kmc> yeah i must have missed where i said "committee"
08:07:00 <acowley> the power is within us all!
08:07:12 <kmc> but congrats cheater_, you have once again strawmanned someone's suggestion in an obnoxious way
08:07:21 <cheater_> kmc: well who decides if your code is "production ready" or "just a hack"?
08:07:34 <cheater_> there's an infinite spectrum between those two
08:07:42 <cheater_> when does gray stop being white and start being black?
08:07:42 <acowley> kmc's suggestion is something I think will help hackage quite a bit, but edwardk's output will still be a wrench in the works
08:07:47 <acowley> cheater_: The author decides
08:08:01 <cheater_> yeah, and every author has a different cutoff
08:08:11 <kmc> some combination of the author's own statements, voting, comments left by others, reverse dependency tracking, etc.
08:08:24 <acowley> cheater_: pair that with a way to evaluate popularity, and the most-used packages deemed by their authors to be production-worth will float to the top
08:08:28 <cheater_> some kid who installed ghc yesterday downloads a lens package, renames some functions, uploads it as production ready
08:08:30 <kmc> perhaps "clear delineation" is overstating the case
08:09:01 <acowley> cheater_: this mechanism will have false positives, but if an author marks his/her package as "weekend hack" then you have an a priori limit on your expectations
08:09:11 <cheater_> you've just come up with an extremely subjective, error-prone, low-data-output (because binary) metric
08:09:38 <cheater_> i don't think the quality of a complex package of code can be encoded into a single bit
08:09:42 <acowley> it's designed to be one input in a larger decision-making procedure
08:09:51 <acowley> cheater_: nobody is saying that it can
08:09:56 <cheater_> it's not about "false positives" it's about it being completely out of touch with the reality of things
08:10:04 <acowley> that is a false positive
08:10:05 <cheater_> you guys have just argued about a binary flag
08:10:07 <cheater_> either on or off
08:10:21 <cheater_> either it's production ready or a hack
08:10:21 <acowley> no, we said a binary flag raised by the author would be a useful bit of information
08:10:27 <acowley> it is not the God bit of hackage
08:10:28 <kmc> in this business you're a one or a zero, alive or dead
08:10:58 <cheater_> kmc: prepare your Light Disc, Program
08:11:26 <cheater_> acowley: it'll have loads of false positives and false negatives
08:11:45 <cheater_> acowley: there will be people who will mark anything they release as "hack"
08:11:52 <cheater_> edwardk could probably be one of those people
08:12:22 <kmc> http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
08:12:35 <kmc> "The unskilled therefore suffer from illusory superiority, rating their ability as above average, much higher than it actually is, while the highly skilled underrate their own abilities, suffering from illusory inferiority."
08:12:42 <acowley> And if they do so, then I shouldn't expect my feature requests to be answered, so I should think twice before taking it as a dependency of a project I really care about.
08:13:14 <JuanDaugherty> and "this business" is commercial IT?
08:13:18 <cheater_> kmc has put it well
08:13:25 <JuanDaugherty> or academic computing?
08:13:48 <cheater_> acowley: what you just mentioned is an increase in semantic meaning that you tacked on
08:14:02 <cheater_> no one ever said the "hack" category means "no feature requests considered"
08:14:06 <acowley> no, it's an common-sense interpretation of "weekend hack"
08:14:24 <cheater_> in fact maybe a "hack" program is a "hack" only because it doesn't support an esoteric xpath selector
08:14:34 <cheater_> and it would be implemented if you requested it!
08:14:44 <acowley> Sure, I can always ask!
08:14:44 <JuanDaugherty> since haskell has a non-zero but small footprint in commercial IT
08:14:52 <cheater_> see the thing is "common sense" is not quantifiable
08:14:57 <cheater_> it's not common
08:14:58 <acowley> Yes it is
08:14:59 <cheater_> and it's not a sense.
08:15:00 <acowley> it is 1 or 0
08:15:03 <acowley> dead or alive
08:15:12 <acowley> or alive or dead, I'm not sure
08:15:28 <acowley> cheater_: I just don't see the contradictions you seem to see
08:16:10 <cheater_> that's a predicate for me even pointing them out to you
08:16:20 <donri> doesn't hackage/cabal already have an author-controlled metric of "stability"?
08:16:36 <acowley> cheater_: but you're not pointing at anything
08:16:50 <cheater_> i differ
08:16:52 <acowley> donri: Yes, but no way to easily search by it from the landing page
08:16:56 <cheater_> but i won't make another attempt
08:17:08 <cheater_> you seem dissatisfied with my critique of kmc's idea
08:17:10 <donri> in my experience with python, where pypy has such a metric, few packages are ever set to "stable"
08:17:21 <donri> most author call their packages beta-quality indefinitely :P
08:17:36 <cheater_> donri: you mean pypi
08:17:41 <donri> ...yes :)
08:17:47 <cheater_> pypy is an interpreter.
08:17:49 <cheater_> confusing.
08:18:11 <donri> sorta like cabal/Cabal/cabal-install
08:18:48 <cheater_> donri: many languages and frameworks have this sort of categorization, it's always plain wrong.
08:18:52 <cheater_> there's never a use for it.
08:19:01 <acowley> When in doubt about cabal, just refer to them all as a package manager until ivanm comes to explain it to you.
08:19:09 <donri> acowley: better browsing/searching of hackage in general +1
08:19:22 <cheater_> it's not a new idea, it wasn't even invented in the last decade. and since then you won't show me a "code quality" metric that works, other than the tucows system
08:19:43 <cheater_> and the tucows system will not work for us because the community just ain't big enough
08:20:08 <cheater_> we could do that if those 800 people in here would all work with haskell fulltime
08:20:19 <acowley> The metric doesn't have to be taken as gospel truth, it's just another data point.
08:20:33 <cheater_> yeah, let's add noise to our data
08:20:50 <cheater_> why not? all data is good right?
08:21:11 <donri> i'm prone to agree with cheater but for the reverse reasons (most packages will just end up marked as hacks, aka. too many false negatives)
08:21:43 <acowley> I never say no to more data
08:21:44 <cheater_> donri: i mentioned that too.
08:22:01 <cheater_> acowley: then you could find a job as a quant.
08:22:20 <cheater_> never saying no to more data is exactly what brought the credit crunch upon us.
08:23:04 <acowley> No it's not. But this seems to have veered fairly OT.
08:23:24 <donri> possibly useful might be some sort of summarized list of possible warning signs, listing things such as no recent release, build failures on new ghc's, lack of tests, low test coverage...
08:23:34 <cheater_> because the quant models being used rarely if ever got checked for correct functioning, the whole world was running their business on false assumptions, based on false assumptions, based on... 20 levels deep.
08:23:40 <donri> not sure how much of that can be objectively measured though, and some of it is already listed on the package pages
08:24:22 <acowley> donri: Yes, all those are useful data points. None by themselves provide truth, but they can help you make a decision.
08:24:36 <cheater_> donri: i think what *would* work for hackage, at the size it's at now, is a set of clear guidelines how a package should be released, how the code should work, comments, tests, access to VCS history, etc
08:24:54 <acowley> donri: the build failures one is currently tricky due to some working libraries have external dependencies
08:24:56 <donri> but we already have that too, don't we
08:25:04 <cheater_> donri: haskell doesn't have THAT many packages that could become popular enough to be eligible for this sort of check.
08:25:10 <cheater_> at this point someone could review such a package.
08:25:49 <cheater_> what i just named is a community process, as opposed to a button somewhere that one person may or may not click or forget to click
08:27:08 <donri> +1 on community process / quality standards, but also +1 on objectively measured data on hackage. +-0 on author-controlled metrics.
08:27:35 <donri> i already find it quite useful that hackage lists build failures
08:27:50 <cheater_> you cannot measure code objectively
08:28:01 <cheater_> and in any case it needs to be measured subjectively
08:28:17 <donri> you can measure some things somewhat objectively, such as percentage of public APIs that have documentation
08:28:35 <cheater_> except, instead of it being measured with subject to the author's perception of it, it should be measured with subject to the people using it.
08:29:06 * hackagebot uu-parsinglib 2.7.3.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.3.1 (DoaitseSwierstra)
08:29:19 <donri> listing revdeps would help too, "who else is using this, anyone who i already trust?"
08:29:22 <cheater_> donri: that's a good one until people start adding boilerplate documentation
08:29:37 <donri> but is that likely?
08:29:49 <cheater_> (i'm commenting on the percentage of documentation thing)
08:29:52 <donri> it's paranoid to think people will do that just to get better metrics
08:30:00 <cheater_> donri: not only likely but happens more often than not
08:30:05 <cheater_> in all languages
08:30:20 <cheater_> you can't automatically check documentation for it being worth crap
08:30:47 <donri> true, but it still isn't meant to be a one-stop metric
08:30:54 <donri> it's suggestive, and if wrong you'll notice soon enough
08:31:20 <alistra> @src either
08:31:21 <lambdabot> either f _ (Left x)     =  f x
08:31:21 <lambdabot> either _ g (Right y)    =  g y
08:31:30 <alistra> @src eitherM
08:31:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:39:47 <alistra> hoogle either
08:39:50 <alistra> @hoogle either
08:39:51 <lambdabot> Prelude data Either a b
08:39:51 <lambdabot> Data.Either data Either a b
08:39:51 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
08:40:06 <alistra> @hoogle maybe
08:40:06 <lambdabot> Prelude data Maybe a
08:40:06 <lambdabot> Data.Maybe data Maybe a
08:40:06 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
08:46:54 <Philonous> I wonder why ADT and pattern matching don't seem to get much traction even in newly invented languages like Go. Am I missing something that makes them less useful in those languages?
08:48:51 <kissyboy> they're not *~*~object oriented~*~* i guess
08:49:06 <cheater_> ✌object✌ ✌oriented✌
08:49:07 <arw> Philonous: unsuitable type system.
08:49:19 <cheater_> arw: i was trying to phrase that somehow
08:49:36 <cheater_> arw: but then i thought to myself, hey, if a pattern is not applicable just make it not-match.
08:50:04 <Philonous> OO can't really be the problem, as ocaml shows
08:50:06 <arw> cheater_: yes. but what if weird overloading or dynamic typing makes such a pattern suddenly match?
08:50:17 <cheater_> arw: then it's fine!
08:50:43 <quicksilver> Philonous: I'm not sure that's really a valid inference.
08:50:45 <cheater_> take your side-effecting for the good and the bad.
08:50:58 <quicksilver> the OO parts of ocaml are weird, and mostly cordonned off into a sublanguage
08:51:08 <quicksilver> none of the ocaml programmers I know ever use them.
08:51:14 <quicksilver> (anecdotal evidence I know)
08:51:58 <ahf> Philonous: man, i would sell my first born for ADT's in Go.
08:52:48 <cheater_> ahf: lol?
08:54:41 <ahf> cheater_: it is much of an issue given that i have no kids.
08:54:56 <arw> ahf: you have unions, what do you need type-safety for? *g*
08:55:18 <ahf> heh. i really hate the whole empty-interface crap in go :(
08:55:26 <ahf> feels like dealing with void-pointers in C
08:56:06 <cheater_> lol
09:01:33 <joe9> 19
09:02:15 <donri> 18
09:02:19 <noam> 17
09:02:59 <benmachine> 16
09:03:41 <joe9> sorry, i was switching windows and it typed wrong.
09:03:53 <alistra> 15
09:03:56 <Philonous> quicksilver:  Isn't that true for all languages, OO being weird and a bad Idea?
09:04:12 <alistra> it's true that oo is weird and a bad idea
09:06:13 <quicksilver> Philonous: well, in Java/C# OO are central and all the programmers I know use it heavily.
09:06:25 <quicksilver> Philonous: in ocaml OO is a side feature and the programmers I know use it not at all.
09:06:29 <quicksilver> YMMV.
09:07:10 <samira> SALAM
09:07:13 <samira> HELLO
09:07:16 <arw> in most languages that support other programming styles besides OO, OO is only used as some different way to pass the first function parameter.
09:07:19 <arw> e.g. perl
09:07:34 <samira> GENZEN
09:07:47 <quicksilver> samira: hello. are you learning to program in haskell?
09:07:48 <sshine> arw, you mean objects are used as containers?
09:08:04 <samira> hello
09:08:05 <samira> yes
09:08:19 <donri> ...and then there's python OO, where the first parameter is explicit in the definition but not the call
09:08:22 <samira> i want to start learn haskell
09:08:26 <quicksilver> great, good luck.
09:08:43 <sshine> samira, yes, I agree. whether you have a collection of functions for a specific type/purpose in a module, or as methods in a class, does seem like similar ways to structure code.
09:08:45 <donri> samira: what are you reading?
09:09:07 <benmachine> I like python OO, it seems straightforward enough
09:09:12 <aninhumer> donri: unless you call it directly
09:09:13 <benmachine> ...and ignorable :P
09:09:23 <samira> i got your source code about  gentzen system
09:09:33 <arw> sshine: well, as a way to encapsulate the necessary global state for a function call. yes.
09:09:42 <cheater_> donri: it's explicit in the call, except it's written differently
09:09:43 <samira> i want to khnow how it run?
09:09:49 <cheater_> it's written with a dot, and before the function name.
09:09:51 <cheater_> that's all.
09:09:59 <donri> yea, python oo has its benefits, such as that you can use them as functions (Class.method(instance, ...))
09:10:19 <samira> who can help me
09:10:20 <donri> cheater_: but it behaves differently for classes and instances
09:10:23 <samira> say your id?
09:10:27 <cheater_> donri: explain
09:10:43 <dolio> Gentzen.
09:10:52 <dolio> Gerhard Gentzen.
09:10:54 <dolio> Junior.
09:10:55 <cheater_> do you mean Class.function() vs instance.method()?
09:10:57 <samira> i want a person who know haskel , about gentzen system, say your id
09:11:01 <donri> cheater_: "foo".upper() vs str.upper("foo")
09:11:18 <donri> cheater_: it's not the dot syntax that is special here
09:11:25 <cheater_> donri: what then?
09:12:00 <donri> instance magic
09:12:19 <cheater_> ?
09:12:24 <cheater_> can you illustrate?
09:12:39 <donri> instances delegate to the class functions with the first parameter "bound"
09:13:16 <cheater_> "foo".upper() ====== str.upper("foo")
09:13:17 <sshine> samira, I'm afraid your request is not understood. you want someone inhere to identify themselves as being able to help you with some software written in haskell?
09:13:19 <cheater_> there is no difference
09:13:50 <Philonous> quicksilver:  I'd infer that Java is weird and a bad idea (how original, java bashing). Ah, but that's just unqualified ranting, please disregard it.
09:14:04 <donri> cheater_: exactly. to be consistent, the latter would receive "str" as the first argument.
09:14:29 <cheater_> donri: no... it wouldn't!
09:14:38 <cheater_> donri: it owuld receive "foo" as the first argument.
09:14:42 <cheater_> because "foo" is the instance.
09:15:25 <donri> you said "it's explicit in the call, except it's written differently", but this depends on how/what you call it
09:16:05 <cheater_> how does it depend
09:16:51 <donri> i can't explain it better than i already did
09:17:05 <cheater_> maybe you should try to delve deeper
09:17:18 <cheater_> the inability to explain something often indicates uncertainty
09:17:34 <donri> not when the person you're explaining to is just randomly contradicting you at every turn
09:17:35 <cheater_> in technical topics that is
09:17:57 <cheater_> well, i am unable to better contradict you
09:17:59 <benmachine> donri: I don't understand what you're saying either, if it helps
09:18:08 <benmachine> donri: recall that str is not a string, it is a type
09:18:25 <cheater_> bear in mind i work with python for a living, so i'm by no means a stranger to that language
09:18:33 <donri> <first argument>.<method>(<further arguments>)
09:18:52 <cheater_> so i'm sure i can understand what you're trying to tell me
09:19:29 <donri> i think python3 has gotten rid of this distinction anyway
09:19:46 <cheater_> yes what distinction
09:19:56 <cheater_> you have just showed the method call syntax
09:19:57 <donri> bound methods
09:20:08 <cheater_> what is the distinction with static function calls?
09:20:11 <benmachine> donri: I think I can see what you're saying; if you have a.b() then whether this means type(a).b(a) or just a.b() depends on what the things are
09:20:28 <benmachine> donri: is that what you mean?
09:21:05 <donri> well, no, because that is exactly how it works :P I'm saying it is a non-obvious gotcha
09:21:35 <cheater_> you still haven't explained *what* is a non-obvious gotcha.
09:21:37 <donri> actually no now i'm just confusing myself
09:21:58 <cheater_> i think you said something, you don't actually know what you have meant, and are now trying to untangle it
09:22:05 <cheater_> :)
09:22:23 <cheater_> happens to me all the time
09:22:25 <cheater_> ...
09:22:27 <donri> cheater_: that the method call "syntax" doesn't translate directly to the "first argument", contrary to the method def syntax
09:22:45 <cheater_> why does it not
09:23:00 <cheater_> give me an example when it does not
09:23:04 <donri> well, it can. but instances add convenience magic (bound methods)
09:23:20 <cheater_> don't tell me it can
09:23:22 <cheater_> give me an example when it does not
09:23:31 <donri> str.upper() doesn't even get a first argument
09:23:46 <donri> and upper is looked up with attribute-access
09:23:49 <cheater_> str.upper() is not valid python code
09:23:53 <donri> sure it is
09:23:57 <cheater_> no, it is not
09:24:10 <donri> ??
09:24:15 <cheater_> >>> str.upper()
09:24:15 <cheater_> Traceback (most recent call last):
09:24:18 <cheater_> and so on.
09:24:22 <donri> yes, because missing argument
09:24:30 <donri> you're just proving my point
09:24:47 <cheater_> ...no, i am not, because by now it is obvious you have no point :)
09:24:52 <cheater_> ok, bbl
09:24:53 <donri> ...
09:25:12 <chrisdone> preflex: seen ivanm
09:25:12 <preflex>  ivanm was last seen on #haskell-blah 27 days, 11 hours, 11 minutes and 30 seconds ago, saying: (I wasn't even at home when this was going on :s)
09:25:12 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:25:18 <donri> "i think you said something, you don't actually know what you have meant, and are now trying to untangle it" would seem this is one of those times it does happen to you.
09:25:20 <donri> oh well.
09:26:47 <donri> a professional python dev who thinks that an exception means "invalid code"? hurr
09:27:04 <i1126> Hey guys!
09:27:26 <i1126> I'm all new to Haskell, but I want to learn it.. so I might be asking a few questions in the future ;)
09:27:31 <cheater_> yeah i'm sure it's valid in your personally developed implementation of python
09:27:36 <cheater_> i1126: welcome :)
09:27:42 <mparusinski> hello everyone
09:27:48 <i1126> My first question though is not programming-related.. it's Haskell-related..
09:27:51 <i1126> I gues..
09:27:51 <cheater_> i1126: do you have any good materials for learning it? there's lots of stuff out there
09:27:52 <i1126> guess
09:28:08 <chrisdone> where's ivanm?  (￣ー￣)
09:28:15 <i1126> I thought I'll stick with Learn You A Haskell and the wiki for a while, good enough? ;)=
09:28:26 <mparusinski> I have an issue with Haskell some of you might think to be controversial. I wonder how some of you would tackle it
09:28:32 <cheater_> chrisdone: i ask myself this question every time before i fall asleep.
09:28:32 <_riba> Yes, LYAH is great
09:28:36 <mparusinski> I need a function that does something only once
09:28:41 <cheater_> i1126: sounds good :)
09:28:42 <benmachine> mparusinski: ooh this sounds like fun :P
09:28:48 <benmachine> oh, eep
09:28:55 <cheater_> mparusinski: State
09:28:56 <benmachine> go on
09:29:20 <mparusinski> I am using the criterion package and it performs many runs of the same IO function
09:29:32 <mparusinski> in the first run i want that function to print something
09:29:45 <mparusinski> but not in the next ones
09:29:47 <cheater_> mparusinski: State.
09:30:04 <chrisdone> cheater_: and when you wake up ivanm asks “where's cheater_?”
09:30:17 <cheater_> chrisdone: that would be very dual, wouldn't it.
09:30:23 <mparusinski> I don't control the way the functions are called and hence I can't pass around the state monad
09:30:28 <rwbarton> mparusinski: you can use an IORef
09:30:34 <cheater_> mparusinski: hmm.
09:30:34 <i1126> So.. I'm setting up a new system and tried to install xmonad-utils via cabal.. (that's my first question) .. it's complaining though ... It says that it requires base <4 and that there are "these packages base-3.0.31 and base-3.0.32. However none of them are available." What can I do about it?
09:30:38 <chrisdone> i'm looking for graphviz experts. anyone know how to tell graphviz to flow nodes within a certain width?
09:30:50 <chrisdone> cheater_: coivanm :)
09:30:51 <i1126> Or is this the wrong channel to ask? ;)
09:30:59 <cheater_> i1126: no this is the right channel
09:31:07 <i1126> Nice :)
09:31:08 <cheater_> chrisdone: :p
09:31:14 <Saizan> i1126: what's not saying explicitly is that it can't install another version of base
09:31:23 <mparusinski> maybe you know if criterion can be configure to handle that?
09:32:06 <i1126> Okay, right.. I tried that and it says impossible.. I get it.. but is there a way for me to get xmoand-utils installed?
09:32:18 <i1126> I tried installing another version of base.. newbie that I am ;)
09:32:21 <mparusinski> anyway there are many ideas for me to explore, thanks everyone
09:33:16 <jessopher> i1126: you could try installing an older version of ghc that is packaged with that version, or changing the dependency version while crossing your fingers
09:35:17 <i1126> jessopher: How do I change the dependencies when installing with cabal?
09:35:51 <rwbarton> i1126: what version of ghc and what version of xmonad-contrib?
09:37:13 <i1126> rwbarton: the version that ships with haskell-platform, 7.0.3 and xmonad-contrib 0.10
09:38:23 <Rotsor> How do you call sets of values constructed with the same constructor?
09:38:51 <jessopher> Call them?
09:38:55 <Rotsor> For example, Just 8 and Just 3 belong to the same ..., but not Nothing?
09:39:08 <Rotsor> In Scala that would be 'type' :)
09:39:41 <jessopher> there is no straight forward way, but there are a few ways that are probably not what you want
09:39:47 <xplat> have the same tag or the same constructor
09:39:58 <Rotsor> Oh, same tag
09:39:58 <xplat> but don't belong to the same anything
09:40:09 <Rotsor> That's useful
09:40:42 <jessopher> the most obvious way would be to pattern match on the values, since they are all constructed with the same constructor, and of the same type
09:41:17 <xplat> jessopher: Rotsor was just asking about terminology
09:41:18 <chrisdone> he's not asking how to do it, he's asking what you call Just
09:41:30 <jessopher> oh
09:41:31 <Rotsor> Yes, the question was about terminology.
09:41:51 <rwbarton> i1126: I'm a little confused because I don't see where the "base <4" constraint is coming from
09:42:00 * jessopher now understands 'call them'
09:42:04 <chrisdone> you pattern match on the constructor so i would persoanlly say they have the same constructor
09:42:06 <Saizan> i guess they belong to the same open set
09:42:08 <xplat> i miss 'base <3'
09:42:27 <Saizan> rwbarton: xomand-utils not xmonad-contrib
09:42:32 <rwbarton> oh
09:42:45 <rwbarton> oh, well there you go.
09:42:48 <rwbarton> Good catch
09:42:50 <i1126> ;)
09:43:00 <i1126> Oh, I didn't saw it either..
09:43:03 <chrisdone> > "going home, " ++ fix ("bye"++)
09:43:05 <lambdabot>   "going home, byebyebyebyebyebyebyebyebyebyebyebyebyebyebyebyebyebyebyebyeby...
09:43:09 <i1126> installing xmonad-contrib went well ;)
09:43:13 <FUZxxl> hehe
09:43:37 <rwbarton> did you actually want xmonad-utils?
09:43:54 <xplat> > cycle "wash, rinse, "
09:43:54 <lambdabot>   "wash, rinse, wash, rinse, wash, rinse, wash, rinse, wash, rinse, wash, rin...
09:44:32 <xplat> or more pointfully
09:44:44 <rwbarton> fix $ \repeat -> ...
09:44:55 <i1126> Well, I did want it for hhb, but then there's unclutter.. but it did bother me ;)
09:45:01 <xplat> > let repeat = "wash, rinse, " ++ repeat in repeat
09:45:03 <lambdabot>   "wash, rinse, wash, rinse, wash, rinse, wash, rinse, wash, rinse, wash, rin...
09:45:08 <i1126> And well, yeah, I wanted to say Hello anyway :P
09:54:00 <Soulest> hello I got a question about add up a score could I do sum [1,1,1] so il get 3 as score
09:54:14 <Soulest> to add a list I could do 1:[ ]
09:55:33 <EvanR-work> Soulest: (n:)
09:55:48 <EvanR-work> > (3:) [1,1,1]
09:55:48 <lambdabot>   [3,1,1,1]
09:56:23 <Soulest> okay thanks
09:56:33 <ion> Oh. I was still waiting for the question.
09:56:37 <EvanR-work> lol
09:56:50 <EvanR-work> i used the crystal ball
09:57:05 <Soulest> lol well I got another one following to that one but il try something with that first
09:58:24 <xplat> > sum [1,1,1]
09:58:25 <lambdabot>   3
09:58:30 <benmachine> $ cabal install --only-dependencies --dry-run | wc -l
09:58:30 <benmachine> 105
09:58:33 <benmachine> ^ ffffuuuuu
09:59:42 <cheater_> why
10:00:59 <benmachine> cheater_: only two of those lines are not names of packages this thing wants to install
10:01:00 <xplat> > let fibs = 1:1:zipWith(+)`ap`tail fibs in fibs
10:01:00 <lambdabot>   Couldn't match expected type `[a -> t]'
10:01:01 <lambdabot>         against inferred type `[a1]...
10:01:19 * benmachine doesn't want to spend the next two hours compiling
10:01:22 <xplat> aw
10:01:55 <benmachine> > let fibs = 1:1:(zipWith(+)`ap`tail) fibs in fibs
10:01:56 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:02:13 <xplat> oh, hurr
10:03:27 <Rotsor> > fix ((0:).(1:).(zipWith(+)`ap`tail)
10:03:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:03:42 <Rotsor> > fix ((0:).(1:).(zipWith(+)`ap`tail))
10:03:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:07:13 <xplat> > let fibs = 1:1:(zipWith(+)`ap`tail) fibs; rpt = flip take . repeat in zipWith((. rpt 'u').(++).rpt 'f')`ap`tail $ fibs
10:07:15 <lambdabot>   ["fu","fuu","ffuuu","fffuuuuu","fffffuuuuuuuu","ffffffffuuuuuuuuuuuuu","fff...
10:07:44 <roconnor> fibs starts with 0
10:08:01 <acowley> I am confused by bos's stance on that cafe thread about Alternative.
10:08:05 <xplat> roconnor: ffffffffuuuuuuuuuuuuu
10:08:12 <rwbarton> "no u"?
10:08:37 <roconnor> xplat: thought I must admit that is a satifying progression
10:09:53 <xplat> it is pretty satisfying
10:10:47 <xplat> and if you want to be *really* pedantic, fibs doesn't start at all
10:11:18 * roconnor reads the alternative thread
10:11:45 <roconnor> xplat: right, by start I meant that the 0th fib number is 0
10:11:57 <Rotsor> rpt = flip replicate ?
10:12:22 <xplat> :t replicate
10:12:22 <lambdabot> forall a. Int -> a -> [a]
10:12:26 <xplat> i guess so
10:12:49 <acowley> Maybe I misunderstood, but it seemed like he started out by saying that any instance that always infinite loops for some/many is broken and shouldn't be an instance, then argued that banning a potential infinite loop is impractical, and can't understand where other people suggesting the merits of a split are coming from.
10:12:55 <xplat> i always forget that one when i don't have tab completion or anything
10:13:40 <acowley> It seems like the discussion should be whether the distinction between useful Alternative types and types that have useful implementations of some/many is worth making.
10:16:12 <Saizan> i think bos's points is that we have a definition of some and many in terms of the old Alternative interface, so any type supporting Alternative - some - many has to have an implementation of them that makes at least as much sense as the default one
10:17:22 <roconnor> many/some correspond to star and plus from star-semirings presumably.
10:17:39 <xplat> gah, why does pipermail not wrap paragraphs?
10:19:04 <monochrom> I think it strives to preserve the original message rather than aesthetics?
10:19:06 <roconnor> @hoogle repeatM
10:19:06 <lambdabot> No results found
10:19:21 <roconnor> Hmm
10:19:36 <Saizan> forever?
10:19:44 <roconnor> I was going to say that if we were going to get rid of many we might as well get rid of repeatM
10:19:52 <xplat> monochrom: the problem is that most real MUAs will wrap a message even if the originating MUA didn't
10:19:53 <roconnor> ... but repeatM doesn't exist :(
10:19:59 <Saizan> ?type forever -- roconnor
10:20:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:20:05 <Shammah> let toBase 0 base = []
10:20:06 <Shammah> let toBase x base = x `mod` base : toBinary (x `div` base) base
10:20:15 <roconnor> repeatM :: (Monad m) => m a -> m [a]
10:20:15 <acowley> I don't think it's a question of getting rid of
10:20:18 <Shammah> somehow this creates an infinite list, yet I fail to see how
10:20:20 <monochrom> after all, if I included haskell code with "long" lines, and if some smartass middleman "wrapped" some of my lines, you would get broken code, no?
10:20:26 <arw> hrm. i've got a question regarding STM. when I use some data structure like TVar (Map String SomethingComplex) and insert stuff into the map with an atomically block, the map is always empty afterwards.
10:20:43 <acowley> but if it makes sense to distinguish types that usefully support such operations
10:20:44 <arw> if I use TVar Int and increment the Int, it works with otherwise identical code
10:20:57 <vrook> Meta-Haskell social question: I notice disdain for static typing often appears to come from people comparing C++ with Python, with apparently little or no reference to languages like Haskell. Conversely, I wonder if disdain of dynamic typing comes from experience with Python, which does not provide compilation and inference annotations like good Lisp implementations.
10:20:57 <roconnor> arw: that sounds weird
10:20:59 <xplat> monochrom: it would presumably use a soft wrap
10:21:08 <Saizan> roconnor: i think the analogy holds with forever too, it's not going to be useful with Maybe either
10:21:52 <monochrom> is pipermail supposed to be a MUA or is it just an archive?
10:21:54 <acowley> I guess it's this quote that I don't agree with, "If many or some always go into an infinite loop for some Alternative instance, then I suspect that the instance itself is either broken or shouldn't exist."
10:22:13 <benmachine> Saizan: so the problem is bad docs, augmented by the implied importance they are given by membership of the class
10:22:28 <Saizan> acowley: yeah, that seems just wrong
10:22:34 <roconnor> acowley: right, that is like saying that Maybe shouldn't be a monad because forever goes into an infinite loop
10:22:34 <monochrom> also define "soft wrap". depending on your definition, and depending on context, it may or may not exist at all.
10:22:34 <benmachine> acowley: I think that is wrong too
10:22:40 <roconnor> > forever (Just 3)
10:22:40 <arw> roconnor: i'll try to put together some readable and short test, currently the code is a mess.
10:22:44 <lambdabot>   mueval-core: Time limit exceeded
10:23:07 <vrook> For example I saw a comment that refactoring is easier in statically typed languages. This overlooks the fact that arity (and often type) warnings are given in most Lisp implementations, so it's really a small difference between an error and a warning with regard to refactoring.
10:23:11 <roconnor> acowley: did some/many get moved into the typeclass as methods?
10:23:24 <roconnor> acowley: because they used to be definitions
10:23:26 <acowley> roconnor: that's my understanding from the thread
10:23:27 <vrook> But in Python and Ruby, no such warnings are given, hence the skewed comparison.
10:23:29 <roconnor> (like forever)
10:23:37 <roconnor> right
10:24:02 <roconnor> so if we moved "forever" into the monad class (which wouldn't be terribly unreasonable) then people would be complaining that Maybe isn't a Monad.
10:24:26 <donri> vrook: perl6 too gives compile-time errors for some such things fwiw
10:24:31 <acowley> Okay, well I'm glad I'm not the only one who thinks he's wrong. I don't think anybody's really arguing with him though as he seems pretty determined and it's not an issue too many people are going to get passionate about.
10:24:43 <roconnor> acowley: warn me if people are seriously going to implement this crazy Alternative splitting proposal.
10:24:51 <benmachine> acowley: I'd be arguing with him except I don't subscribe to -cafe these days
10:24:57 <acowley> roconnor: I think putting the method in the class is what makes the idea of a split seem more reasonable
10:25:00 <xplat> donri: is supposed to or does?
10:25:09 <donri> xplat: does in recent rakudo
10:25:42 <Shammah> ah nvm, fixed it :D
10:25:44 <donri> http://6guts.wordpress.com/2011/10/15/an-optimizer-lands-bringing-native-operators/
10:26:07 <xplat> if we knew what an Alternative was supposed to be, we could say one way or the other
10:26:20 <acowley> roconnor: Even though I disagree with his arguments, I think bos's stance will prevent the split from happening.
10:26:53 <acowley> benmachine: you're missing out on extended bickering about the importance of a mascot to a programming language.
10:26:58 <roconnor> xplat: that would help
10:27:10 <benmachine> acowley: oh no
10:27:16 <acowley> Alternative is precisely that which allows us to say one way or the other.
10:27:17 * benmachine cries self to sleep
10:27:29 <benmachine> also I agree with xplat
10:27:40 <roconnor> acowley: some sort of abelian enriched functor thingy?
10:27:48 <benmachine> haha
10:27:49 <roconnor> er
10:27:53 <roconnor> xplat: some sort of abelian enriched functor thingy?
10:28:02 <benmachine> roconnor: write the docs plx
10:28:14 <roconnor> I tried to figure it out once, but failed
10:28:15 <benmachine> "Alternative: a type class for abelian enriched functor thingies"
10:28:22 <monochrom> recall that forever is not a class method. perhaps you can get a consensus on many,some not being class methods.
10:28:24 <acowley> Docs that say "some sort of abelian enriched functor thingy?" vs. no docs: fight!
10:28:34 <roconnor> edwardk probably knows what it is
10:28:36 <roconnor> maybe Cale
10:29:00 <kmc> vrook, seems plausible to me
10:29:11 <benmachine> monochrom: it sounds from the thread like some people actually implement many or some with different semantics to the defaults
10:29:34 <kmc> there's really a continuum between static and dynamic type systems
10:29:36 <benmachine> which concerns me somewhat
10:29:39 <kmc> lots of things in Haskell are not statically checked
10:29:46 <roconnor> benmachine: that is a little worrying
10:30:04 <benmachine> roconnor: maybe I misinterpreted
10:30:07 <kmc> and even very dynamic languages can have fancy static checkers
10:30:22 <cheater_> vrook: i like to look at haskell as a dynamically typed language, except the types are static.
10:30:34 <acowley> So perhaps there should be many,some :: Alternative f -> f a -> f [a] and then another class that parsers and whatnot can use to override related functionality?
10:30:35 <cheater_> because of its type inference i don't have to care about types.
10:30:41 <xplat> vrook: i don't recall type annotations being particularly well-designed in any lisp i'm aware of, and the cleverness those compilers need to work at all blows way too much of the complexity budget for optimization
10:30:45 <cheater_> your lisps are doing the exact same thing
10:30:51 <kmc> especially if you're interested in catching bugs heuristically but don't require "soundness", i.e. the complete exhaustion of certain bug classes
10:30:52 <cheater_> there is no difference, vrook.
10:30:58 <kmc> no i think there is a difference cheater_
10:31:04 <cheater_> what is it?
10:31:09 <kmc> the lisp implementations are not guaranteeing to catch all arity / type errors
10:31:38 <benmachine> roconnor: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/94520/focus=94548 is where I'm taking this from
10:31:43 <roconnor> benmachine: though I find it plausible that any implementation of many and some such that many x = mzero <|> some x and some x = (:) <$> x <*> many x is acceptable.
10:31:47 <kmc> plus it's implementation-dependent
10:31:56 <kmc> whereas the Haskell report specifies exactly which programs must be rejected
10:32:02 <roconnor> benmachine: which, now that I think about it, suggest that many and some should be split out of the class :/
10:32:24 <benmachine> roconnor: heh. it's a bit tricky really
10:32:30 <benmachine> but I'm inclined to agree
10:32:52 <xplat> vrook: although as compilers in general get more ambitious the latter objection is gradually fading in importance
10:32:52 <benmachine> Alternative means you have a type-correct implementation, but you already had that actually
10:32:58 <benmachine> some x = undefined -- :P
10:33:05 <benmachine> which in some cases is about as helpfully
10:33:14 <benmachine> helpful
10:33:49 <vrook> kmc: you have brought up another issue, which is that people compare a single implementation of language X to all implementations of Lisp. It's not a fair comparison. Compare a particular Lisp implementation to X. SBCL does a heck of a lot of inference annotations, and does fail-fast for any type mismatches with safety checks set.
10:34:26 <kmc> anyway i think designing a language without a sound static type system, but with an eye towards nonetheless statically analyzing it, is potentially a good idea
10:34:36 <kmc> i'm not sure many languages have been designed with this in mind
10:34:43 <kmc> Dart is a newcomer in this area
10:34:53 <vrook> kmc: Shen is the only one I know.
10:34:56 <cheater_> why is it a good idea
10:35:13 <roconnor> benmachine: I may of got the order of parameters to <|> backwards.
10:35:32 <roconnor> benmachine: in my mind <|> is supposed to be commutative, but it isn't in practice.
10:35:35 <xplat> vrook: the finger on the scale can go either way there.  compare with elisp, guile, gcl ... sbcl, and lisp ends up looking a lot worse or maybe a lot better than it is overall
10:35:49 <roconnor> oh righ, that is why the whole abelian enriched thingy doens't work
10:36:55 <acowley> why would it be commutative?
10:37:06 <kmc> cheater_, well take Dart as an example.  they don't want to force people to change existing Javascript codebases, nor do they want to require people to learn about covariant and contravariant subtyping
10:37:16 <kmc> yet there's a lot of low-hanging fruit for statically analyzing javascript
10:37:30 <kmc> with relatively minor changes to the language
10:37:49 <xplat> javascript in many ways is one of the better-designed dynamic languages
10:37:59 <roconnor> acowley: I don't know; it is always commutative in category theory.
10:38:05 <xplat> but most of the 'low-hanging' fruit doesn't actually hang that low
10:38:08 <acowley> it seems very much monoidal to me
10:38:24 <roconnor> acowley: I supsect if you write out the "obvious" laws you are forced to derive commutativity.
10:38:33 <acowley> roconnor: I didn't actually even know it existed in CT
10:38:46 <cheater_> kmc: ok i understand what you mean
10:39:03 <cheater_> kmc: you're arguing that one is a heuristic whereas another is a well-defined rule that always snaps into the socket
10:39:10 <xplat> for one thing, in any language that has all symbols rebindable at runtime (without regard to type) you can't make any guarantees
10:39:13 <cheater_> i just say the latter is a better version of the former
10:39:21 <kmc> better in some ways, worse in others
10:39:23 <kmc> i
10:39:25 <vrook> kmc: Again I wonder to what extent static typing advocacy reflects actual experience or the general warm-fuzziness feeling of it. From a lisper's point of view, it solves something that is not a problem.
10:39:29 <cheater_> yeah
10:39:38 <xplat> you could have a js program that doesn't call any function but f() through its whole run
10:39:39 <roconnor> acowley: I'm imagining some sort of Eckmann-Hilton argument: http://en.wikipedia.org/wiki/Eckmann%E2%80%93Hilton_argument
10:39:43 <kmc> i fear that a discussion in #haskell of "is static typing better" will reach a foregone conclusion
10:39:48 <cheater_> i mean you could possibly make a version of haskell which turns off rejection of programs.
10:39:55 <roconnor> acowley: of course one needs to first know what the "obvious" laws are.
10:40:00 <cheater_> i don't think static typing is better
10:40:06 <Philonous> vrook:  Isn't the point there exactly that you add static type checking back into a dynamic language?
10:40:07 <roconnor> acowley: yes, I'm sorry I'm being very vague here
10:40:08 <cheater_> i do think being able to lean on it is very convenient
10:40:13 <cheater_> as opposed to having heuristics
10:40:15 <kmc> vrook, is SBCL's inference really as good at catching errors as Haskell's type system?
10:40:22 <kmc> have you used both systems enough to tell?
10:40:55 <kmc> how does one typically represent data in Lisp?  does the inference system see through lists, cons cells, records, whatever?
10:41:20 <acowley> roconnor: so your requirement is that (a <|> b) <|> (c <|> d) = (a<|>c) <|> (b<|>d) ?
10:41:42 <kmc> anyway you are certainly correct that most people arguing about static vs. dynamic typing are not comparing Haskell and Lisp.  at least not correctly.
10:41:48 <rwbarton> acowley: it has to do with interchange between <|> and <*>
10:41:51 <roconnor> acowley: I think that is a derived requirement from <|> being a homomorphism for <*>
10:41:52 <kmc> because relatively few people understand each language, and very few understand both
10:42:07 <roconnor> acowley: ie it isn't aprori
10:42:07 <kmc> usually they are comparing C++ and Python, or so
10:42:15 <kmc> and yeah, that is mostly a strawman argument
10:42:26 <cheater_> what kmc said
10:42:30 <acowley> I see, because that seems like a bad law to start with given that it doesn't describe the intended behavior :)
10:42:32 <kmc> what cheater_ said
10:42:53 <roconnor> acowley: right; You don't start with the law, but are simply forced to conlcude it from interactions with <*> that would would like.
10:42:57 <cheater_> comparing C++ and Python is like comparing hershey bars and lollipops according to their nutritional value
10:43:00 <vrook> kmc: Yes my point is that the only fair comparison is Lisp vs Haskell. Other popular languages (Python, Ruby, C++, Java) are sub-optimal versions of Lisp and Haskell.
10:43:01 <monochrom> dynamic typing is runtime dependent typing
10:43:02 <xplat> the question really comes down to this: do you design your language around making static analysis work well, or do you come in later with a patchwork of analysis tools and hope people will design their programs around making the tools work well?
10:43:06 <rwbarton> er not interchange between <|> and <*>, but that <*> distributes over <|> in each argument
10:43:11 <acowley> I actually don't see how <|> is a homomorphism for <*>
10:43:12 <ion> I just got stuck in an infinite loop. Fortunately my operator rebooted me.
10:43:23 <rwbarton> or, well, I remember this being a somewhat involved discussion
10:43:31 <kmc> vrook, disagree, each of those languages has its own advantages
10:43:40 <kmc> saying things like that makes you sound like a smug asshole
10:43:40 <rwbarton> actually maybe it was interchange
10:43:53 <kmc> it may be endemic in Lisp and Haskell communities but still
10:44:02 <cheater_> i'm with kmc on the saying things part
10:44:08 <roconnor> acowley: specifically you want (x <|> y) <*> z = (x <*> z) <|> (y <*> z)  and z <*> (x <|> y) = (z <*> x) <|> (z <*> y)
10:44:10 <acowley> oh
10:44:12 <kmc> @remember cheater_ i'm with kmc on the saying things part
10:44:12 <lambdabot> Done.
10:44:15 <vrook> kmc: We are talking about typing. It's not an overreach to say they are objectively suboptimal with regard to typing.
10:44:18 <acowley> right
10:44:20 <acowley> yes exactly
10:44:23 <roconnor> acowley: but in reality the second law fails almost always
10:44:34 <vrook> kmc: Which has better typing, Haskell or Java?
10:44:35 <acowley> it does?
10:44:41 <roconnor> acowley: yep
10:44:47 <kmc> "better" has to be judged with respect to a goal
10:44:47 <cheater_> although being a smug asshole is just a sub-optimal version of being a true language researcher
10:45:03 <kmc> i can argue that Java's type system is easier to understand and therefore better
10:45:11 <roconnor> > [(+1),(+2)] <*> ([3,4] <|> [5,6])
10:45:12 <lambdabot>   [4,5,6,7,5,6,7,8]
10:45:14 <vrook> kmc: How about "more powerful" instead of "better"? Replace all my "betters" with "more powerfuls".
10:45:21 <cheater_> i could argue that haskell sucks because it doesn't have duck typing
10:45:22 <kmc> that's another slippery, loaded term
10:45:26 <roconnor> > ([(+1),(+2)] <*> [3,4]) <|> ([(+1),(+2)] <*> [5,6])
10:45:27 <lambdabot>   [4,5,5,6,6,7,7,8]
10:45:28 <cheater_> or type juggling like php does
10:45:29 <xplat> kmc: maybe you could argue that before 1.5
10:45:35 <kmc> i've been through this conversation enough times to know it doesn't go anywhere good
10:45:38 <kmc> so good luck with it
10:45:38 <cheater_> therefore haskell is sub-par for web development
10:45:40 <acowley> argh
10:45:58 <ion> Some people are smug assholes against my being a smug asshole.
10:45:58 <roconnor> acowley: but really, for the non determinism monad, those two representations are equivalent
10:46:05 <vrook> kmc: yes you certainly appear to be bringing in a lot of baggage. Best to drop it.
10:46:09 <roconnor> acowley: so the law does hold in some sort of semantic domain
10:46:22 <cheater_> ion: this relatonship is smug.
10:46:23 <acowley> list/set and whatnot
10:46:32 <roconnor> list/multiset
10:46:33 <acowley> multiset
10:46:35 <acowley> :/
10:46:43 <roconnor> well yes list/set too
10:46:50 <acowley> roconnor: that was a very helpful example, thanks
10:47:02 <roconnor> acowley: anyhow if we assert these two laws
10:47:08 <roconnor> I think you can derive commutativity of <|>
10:47:18 <acowley> yes it looks like it
10:47:30 <acowley> so we're up the creek without a paddle
10:47:33 <acowley> good times
10:47:48 <roconnor> well, like I said, there is some semantic sense in which both laws hold
10:48:13 <acowley> actually, isn't it a problem that <*> doesn't have its own empty?
10:48:18 <rwbarton> the issue is -- f a is a monoid under <|>, if you want <*> to distribute like this then you are saying it factors through the "tensor product" f (a -> b) (x) f a, but the tensor product only makes sense for commutative monoids, or at least it is itself a commutative monoid
10:48:22 <roconnor> acowley: it has pure
10:48:40 <acowley> but pure /= empty
10:48:44 <roconnor> sure
10:48:48 <roconnor> but pure is the unit for <*>
10:48:52 <acowley> which Eckman-Hilton requires
10:49:05 <rwbarton> and the reason for that is eventually that a monoid object in monoids is a commutative monoid (http://en.wikipedia.org/wiki/Eckmann%E2%80%93Hilton_argument)
10:49:07 <roconnor> right, I'm not entirely sure you can derive commutativity
10:49:25 <xplat> yeah, if pure was empty then <|> would be (the pair version of) <*>
10:49:31 <roconnor> but I still think you can tweek the argument to make it work
10:49:38 <roconnor> probably using pure id
10:49:56 <xplat> which doesn't seem like what you want
10:50:02 <xplat> you want more of a riggy thing
10:50:27 <roconnor> <*> corresponds to (x)  <|> corresponds to (+) ,  mempty corresponds to 0 and pure id or something like it corresponds to 1.
10:50:52 <acowley> yeah
10:50:57 <roconnor> but anyhow I haven't worked it out
10:50:59 <xplat> rigs do have to be abelian in (+)
10:51:01 <roconnor> so it might not go
10:51:10 <Philonous> Can someone recommend a good book about the theoretical underpinnings of object orientation?
10:51:15 <xplat> categorical rigs i think have to be symmetric
10:52:01 <mokus> object orientation has theoretical underpinnings?
10:52:01 <roconnor> acowley: actually the E-H argument won't work since they also show that the two monoids are the same
10:52:03 <xplat> Philonous: no
10:52:11 <roconnor> acowley: and certainly <|> isn't the same as <*>
10:52:12 <roconnor> ...
10:52:17 <xplat> because what mokus said
10:52:20 <roconnor> still I'm pretty sure I can prove commutativiity
10:52:22 <Saizan> TAPL has quite a bit about subtyping and objects
10:52:50 <Saizan> though that might be biased to a particular meaning of OOP
10:52:54 <mokus> there's a lot of theory that can be retrofitted to object-oriented concepts, but none are native that i know of
10:53:08 <Philonous> xplat:  Well, surely all those shiny OO languages are not clobbered together willy-nilly?
10:53:57 <acowley> TAPL is great for instilling a healthy fear of subtyping
10:54:23 <Philonous> acowley:  Ha, I've so far skipped that chapter. I think I'll go read that
10:55:26 <acowley> It's a very good treatment, and the development of featherweight java is quite convincing that parts of OO languages make some sort of sense.
10:56:32 <xplat> Philonous: i wouldn't say all of them, but all the ones that are *not* clobbered together willy-nilly have their own theory of what OO is
10:56:39 <Philonous> Saizan:  Actually I'd really appreciate a definition of what exactly OO is supposed to mean. One could come to the conclusion that it's key point is writing functions in a silly postfix style ;)
10:57:27 <xplat> the only stuff they can agree on amounts to first-order lambda calculus, maybe with some kind of subtyping conditional on having types at all
10:59:02 <acowley> xplat: I think that's an important takeaway though, width and depth subtyping with lambda calculus gets you somewhere interesting
11:02:48 <Philonous> xplat:  What OO language would you say has the soundest theory behind it?
11:02:49 <vrook> Almost everyone associates OO with single-parameter dispatch, i.e. sending a message to an object, which is very constraining and leads to "pattern" boilerplate code. Lisp has multi-parameter dispatch, called generic functions, which simply many issues (at the cost of more abstract ideas being held in the programmer's head).
11:03:41 <roconnor> vrook: what type of dispatch does haskell have?
11:03:46 <jessopher> i hate having those in my head
11:04:18 <acowley> I only use return-type polymorphism. Anything else is whack.
11:04:33 <copumpkin> lol
11:04:44 <trinithis> I'm trying to create an instance of Binary, but my data uses CDouble. There is no instance for (Binary CDouble). What should I do?
11:04:51 <vrook> s/simply/simplifies
11:05:44 <vrook> roconnor: I'm not sure dispatch in this sense has meaning in Haskell. It's all compile-time dispatch, so Haskell has 0-parameter dispatch.
11:06:06 <acowley> trinithis: I would do something like this, "putWord64le . unsafeCoerce" but I am not a role model
11:06:46 <acowley> Charles Barkley taught me how to code
11:06:52 <copumpkin> generalized newtype deriving, probably
11:06:54 <trinithis> Perhaps I can convert it to a Rational and serialize that?
11:06:57 <copumpkin> with standalone derivings
11:07:11 <copumpkin> not sure if that'll work but it might
11:07:28 <xplat> Philonous: Sather was pretty solid, Cecil was the closest thing to the Haskell of OO, Scala is a recent one that really tries to have a good theory although its theory is not very simple
11:07:37 <roconnor> vrook: if you say so.  I'm not convinced passing dictionaries around counts as any less run-time dispatch than passing around pointers to vtables
11:08:13 <xplat> Occam could be too if you consider Occam as OO, which is a controversial viewpoint.
11:08:50 <salisbury> if one has a function func :: a -> b, is func a value
11:09:10 <copumpkin> yep
11:09:11 <rwbarton> salisbury: Sure.
11:09:12 <Philonous> roconnor:  I think existantials even give you honest-to-god dynamic dispatch
11:09:29 <copumpkin> yep
11:09:51 <roconnor> Philonous: are dictionaries not passed around in Haskell '98 implementations?
11:10:01 <salisbury> thanks
11:10:09 <roconnor> ... maybe they could all be compiled away in principle?
11:10:18 <Philonous> roconnor:  Possibly, but if the compiler can optimize them away statically, maybe not?
11:10:43 <trinithis> Does anyone know if (fromRational . toRational) is guaranteed to be id for Real instances that come with GHC?
11:11:03 <copumpkin> it isn't
11:11:17 <vrook> roconnor: I think you misunderstand. Whether you're passing a dictionary or a vtable, it's still tied to a single object. You're confusing methods with the dispatch mechanism of the language.
11:11:32 <copumpkin> vrook: multiparameter type classes?
11:11:36 <rwbarton> > fromRational . toRational $ 1/0
11:11:37 <lambdabot>   Infinity
11:11:46 <rwbarton> > toRational $ 1/0
11:11:46 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:12:26 <xplat> rwbarton: wat
11:12:44 <xplat> where do those digits come from?
11:12:47 <roconnor> > fromRational . toRational $ 0/0
11:12:48 <lambdabot>   -Infinity
11:12:56 <copumpkin> I love how toRational is a method of Real
11:12:58 <rwbarton> > log (fromRational . toRational $ 1/0) / log 2 :: CReal
11:13:00 <lambdabot>   1024.0
11:13:06 <copumpkin> @src Real
11:13:07 <lambdabot> class  (Num a, Ord a) => Real a  where
11:13:07 <lambdabot>     toRational      ::  a -> Rational
11:13:10 <rwbarton> yes
11:13:17 <rwbarton> the only method!
11:13:33 <roconnor> trinithis: not for (0/0 :: Double), but 0/0 isn't even equal to itself, so it hardly counts.
11:13:34 <copumpkin> best number hierarchy evar
11:14:02 <rwbarton> i'd expect that fromRational (toRational x) == x for x which is actually a number
11:14:03 <copumpkin> xplat: nobody knows where the digits come from
11:14:17 <arw> http://pbot.rmdir.de/5dbea95442968e40ec20dff65dcc6abe
11:14:17 <copumpkin> xplat: one of the greatest mysteries in computer science
11:14:18 <trinithis> I'm just trying to serialize CDouble. All the values will be finite values
11:14:25 <xplat> just make sure you sterilize them before use?
11:14:30 <acowley> of course, once you have that method, what more do you need?
11:14:36 <roconnor> trinithis: I woudl use encodeFloat and decodeFloat
11:15:13 <arw> roconnor: somewhat more minimal failing example: http://pbot.rmdir.de/5dbea95442968e40ec20dff65dcc6abe
11:15:25 <trinithis> ah, cool
11:15:26 <acowley> It's the Godel number of fix
11:15:38 <xplat> it seems like with Num and Ord you could almost write toRational
11:15:56 <xplat> i guess it's only there to make sure you don't have infinite reals
11:15:57 <arw> roconnor: I guess either I'm using STM wrong or map does stuff differently from other data types
11:15:57 <tgeeky> but it only seems that way
11:16:17 <xplat> except of course that floats do have infinite reals
11:16:24 <roconnor> trinithis: er, though I don't know how portable encodeFloat and decodeFloat are
11:16:34 <Nafai> Are there any guides to writing Windows applications with Haskell (making Win API calls, etc?)
11:16:45 <roconnor> trinithis: probably good in practice. ... though I don't know about theory
11:16:53 <trinithis> roconnor: What if all the serialization happens only on one machine?
11:17:01 <trinithis> and deserialization
11:17:03 <roconnor> trinithis: that is more likely to work
11:17:09 <roconnor> > encodeFloat (0/0)
11:17:10 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
11:17:10 <lambdabot>    arising f...
11:17:16 <rwbarton> > M.update (\s -> Just 5) "foo" (M.empty)
11:17:17 <lambdabot>   fromList []
11:17:18 <roconnor> what?
11:17:21 <rwbarton> there is your problem
11:17:32 <xplat> roconnor: from the existence of near-semirings i deduce that a proof of commutativity for + must use both left and right distributive laws.
11:17:48 <roconnor> arw: see rwbarton's commen
11:17:59 <roconnor> xplat: sounds right
11:18:05 <xplat> although technically speaking that's abduction, but who's counting?
11:18:13 * arw slaps head
11:18:14 <roconnor> xplat: or maybe left
11:18:32 <arw> roconnor, rwbarton: thank you.
11:18:37 <roconnor> what does M.update do?
11:18:58 <xplat> trinithis: if you only care about one machine you could cheat through Storable i guess
11:19:02 <arw> use the function to update a value in a map
11:19:40 <trinithis> Thanks guys, the encodeFloat and decodeFloat functions suit my needs
11:20:11 <roconnor> > encodeFloat (0/0 :: Double)
11:20:12 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
11:20:12 <lambdabot>         against inf...
11:20:16 <arw> > M.alter (\s -> Just 5) "foo" (M.empty)
11:20:17 <lambdabot>   fromList [("foo",5)]
11:20:17 <roconnor> > decodeFloat (0/0 :: Double)
11:20:18 <lambdabot>   (-6755399441055744,972)
11:20:31 <roconnor> ... those names seem backwards
11:20:53 <xplat> > decodeFloat (sqrt(-1) :: Double)
11:20:54 <lambdabot>   (-6755399441055744,972)
11:20:56 <arw> yes. usually its updateOrInsert or something...
11:21:18 <roconnor> arw: actually I mean the encode/decodeFloat functions :P
11:21:25 <arw> ah, okay :)
11:21:48 <xplat> sqrt(-1) is the same NaN as 0/0?
11:21:50 <ion> I don’t see how they are backwards.
11:22:04 <rwbarton> @hoogle alter
11:22:04 <lambdabot> Control.Applicative class Applicative f => Alternative f
11:22:04 <lambdabot> Data.IntMap alter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a
11:22:05 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
11:22:12 <trinithis> > isNaN (sqrt(-1))
11:22:13 <lambdabot>   True
11:22:14 <roconnor> To me  (-6755399441055744,972) is the encoding of the NaN float.
11:22:16 <rwbarton> alter is the fully general one
11:22:33 <xplat> roconnor: i thought there were supposed to be several NaN floats
11:22:38 <roconnor> right
11:22:57 <roconnor> this is the encoding of the specific NaN float produced by (0/0) I guess
11:23:06 <roconnor> anyhow
11:23:23 <xplat> but sqrt(-1) seems to produce the same one, i thought it would produce a different one.  weird.
11:24:00 <vrook> What's the lambdabot command for looking up functions which match a given type?
11:24:21 <Cale> hoogle
11:24:25 <roconnor> xplat: what happens in C?
11:24:33 <xplat> if you use Double's equality i guess they are different, though :)
11:24:38 <Cale> but you're probably better off using http://www.haskell.org/hoogle/
11:25:00 <vrook> thanks, didn't know about that
11:25:18 <Philonous> There is also http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:25:37 <roconnor> > (0/0) == (0/0)
11:25:38 <lambdabot>   False
11:25:48 <roconnor> xplat: they are different even if they are the same
11:26:15 <mokus> > compare (0/0) (0/0)
11:26:15 <lambdabot>   GT
11:26:19 <xplat> yes, i just noted that
11:26:21 <jessopher> ha
11:26:44 <mokus> the Ord is a lie!
11:26:51 <jessopher> left always wins!
11:26:55 <xplat> takeaway: don't try to bubblesort a list of (0/0) naively
11:27:13 <roconnor> the way I figure, any function can do any (pure) thing when passed (0/0)
11:27:17 <mokus> or put doubles in a map unless you know they can't be NaN
11:27:18 <vrook> It's neat that I found the function I was looking for. I was using map2 f as bs = map (uncurry f) (zip as bs). I put the signature into hoogle I find zipWith.
11:27:29 <copumpkin> don't put doubles into a map in the first place
11:27:31 <copumpkin> or floats
11:27:31 <mokus> (as keys)
11:27:34 <copumpkin> you're not going to find them
11:27:41 <xplat> compare (0/0) 1
11:27:45 <xplat> > compare (0/0) 1
11:27:46 <lambdabot>   GT
11:27:50 <xplat> > compare 1 (0/0)
11:27:51 <lambdabot>   GT
11:28:19 <roconnor> @src zipWith
11:28:19 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:28:19 <lambdabot> zipWith _ _      _      = []
11:28:58 <xplat> zipWith is a great function
11:29:19 <acowley> how does cabal come up with a "Missing C library" error?
11:29:23 <acowley> cabal-install that is
11:29:59 <vrook> I didn't find it originally because the name is sorta misleading. I think of zip as producing tuples, but zipWith doesn't do that.
11:30:30 <vrook> I assumed it was generated mapped tuples.
11:30:35 <vrook> *generating
11:31:12 <xplat> > let alphadd a b = fromEnum a + fromEnum b - fromEnum '`' in zipWith alphadd "hello" "airman"
11:31:13 <lambdabot>   [105,110,126,121,112]
11:31:18 <Shammah> is it possible to have a fold with two accumulators?
11:31:20 <xplat> er
11:31:28 <pikhq_> It's a bit better to think of zip as applying (,) to the elements of each list in sequence, and zipWith letting you apply a function f instead.
11:31:47 <Cale> Shammah: it's possible to accumulate a pair
11:31:50 <xplat> > let alphadd :: Char -> Char -> Char; alphadd a b = toEnum $ fromEnum a + fromEnum b - fromEnum '`' in zipWith alphadd "hello" "airman"
11:31:51 <byorgey> Shammah: sure, just use a tuple as your accumulator
11:31:51 <lambdabot>   "in~yp"
11:32:01 <Shammah> oh ofcourse, thanks!
11:33:09 <xplat> > let alphadd :: Char -> Char -> Char; alphadd a b = toEnum $ fromEnum a + fromEnum b - fromEnum '`' in zipWith alphadd "boba" "fett"
11:33:10 <lambdabot>   "htvu"
11:33:42 <vrook> Well I still think zipWith should be called map2 or similar, since its analogues are liftA2 and liftM2.
11:34:05 <roconnor> vrook: zipWith is called liftA2 in ZipList
11:34:06 <vrook> er, not liftM2
11:34:38 <monochrom> you can write your own prelude and name functions your way and upload to hackage
11:34:40 <roconnor> vrook: oh, you know that
11:35:21 <monochrom> in fact I recommend everyone to do that. absolutely everyone. and end all naming discussions already.
11:35:30 <monochrom> @quote monochrom polymorphic
11:35:30 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
11:36:58 <acowley> I would enjoy setting that put into practice in real life arguments.
11:37:00 <saati> is there a way to write a function that takes a function f and depending on f-s type  it produces map, or zipWith or zip3 etc?
11:38:12 <parcs__> saati: yes with type classes
11:38:26 <roconnor> saati: not in any reasonable way
11:38:41 <roconnor> saati: due to polymorphism, the "arity" of a type isn't very clear.
11:38:55 <copumpkin> if you make it less polymorphic you can do it
11:39:00 <copumpkin> but obviously it's less flexible
11:39:52 <xplat> > let ǃ=ZipList []; h∶ZipList t = ZipList$h:t in liftA2 (+) (1∶2∶3∶ǃ) (5∶3∶1∶ǃ)
11:39:53 <lambdabot>   No instance for (GHC.Show.Show
11:39:53 <lambdabot>                     (Control.Applicative.Zip...
11:39:53 <copumpkin> saati: if I pass in a function A -> B -> C -> D and only pass in [A] and [B], I might just want the return type to be [C -> D]
11:40:02 <monochrom> due to newtype wrapping, syntactic arity and semantic arity are divorced.
11:40:13 <xplat> no Show for ZipList?  what?
11:40:24 <copumpkin> xplat: yeah, I've run into that before
11:40:25 <copumpkin> it's great
11:40:35 <copumpkin> I suppose the correct thing to do would be a libraries proposal
11:40:41 <xplat> what is the unziplister called again?
11:41:00 <copumpkin> getZipList I htink
11:41:05 <parcs__> @src ZipList
11:41:05 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:41:08 <xplat> > let ǃ=ZipList []; h∶ZipList t = ZipList$h:t in getZipList $ liftA2 (+) (1∶2∶3∶ǃ) (5∶3∶1∶ǃ)
11:41:08 <lambdabot>   No instances for (GHC.Num.Num
11:41:09 <lambdabot>                      (Control.Applicative.Zip...
11:41:23 <xplat> er.
11:41:41 <augur> byorgey!
11:42:23 <xplat> :t \ xs ys -> getZipList $ liftA2 (+) xs ys
11:42:24 <lambdabot> forall a. (Num a) => ZipList a -> ZipList a -> [a]
11:43:29 <ski> vrook : (re "Meta-Haskell social question") it's not impossible
11:43:44 <ski> kmc : re "i think designing a language without a sound static type system, but with an eye towards nonetheless statically analyzing it, is potentially a good idea" -- in some ways i think Scheme does this
11:43:55 <ski> Philonous : i'm not sure there is that much in that way. i know at least Luca Cardelli has some papers on typing in OO
11:44:39 <ski> i found some of Erik Poll's papers intesting re inheritance and coinheritance
11:44:44 <ski> @where ErikPoll
11:44:44 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
11:44:45 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
11:44:45 <lambdabot> pdf>
11:44:52 <ski> vrook : an implementation passing a dictonary for a class constraint is not "tied to a single object"
11:46:58 <Philonous> ski:  Noted, thanks
11:47:35 <byorgey> augur: what's up?
11:48:55 <vrook> ski: that was in response to the comparison between dictionary and vtables for carrying methods. Perl/python/ruby all use a dictionary-like-thing to look up methods; C++ uses a vtable. They are all single dispatch. The fact that you have a single dictionary or a single vtable means single dispatch.
11:49:00 <ski> (i've heard it said that only Booch is worth reading on OO design and methodology)
11:49:07 <vrook> To implement multiple dispatch, you'd have multiple of those.
11:49:28 <xplat> there are lots of papers on type systems, etc, for things vaguely like OO, which however have no OO language implementation backing them up
11:49:37 <augur> byorgey: you should write a blog post on division of species :)
11:49:49 <byorgey> augur: I plan to!
11:49:54 <xplat> OO languages with both foundational papers and implementations are considerably rarer
11:49:54 <augur> byorgey: :)
11:49:57 <ski> vrook : the dispatch isn't just selecting from the table, it's also selecting *which* table to use
11:50:12 <byorgey> augur: it hsa recently been decided that I will return to species for my dissertation
11:50:19 <byorgey> augur: so you can expect lots more species goodness from me
11:50:27 <augur> i've been thinking about taylor expansions for species definition, and i realized that in order to do that, you need subtraction, division, and differentiation
11:50:41 <augur> byorgey: ooo what were you doing for a while?
11:50:55 <vrook> ski: Are you talking about simulating multiple dispatch in a single-dispatch language with the "vistor pattern" or whatever?
11:51:17 <ski> vrook : i'll say upfront that i don't understand CLOS, so i probably can't make any interesting point about how it does dispatch. my point here is that in Haskell, the dictionary isn't directly tied to any particular object
11:51:26 <byorgey> augur: name binding; extensions to GHC
11:51:50 <xplat> vrook: when other people were mentioning dictionaries here, they mean haskell's typeclass dictionaries, which ar considerably different than perl/python/ruby's dictionaries
11:52:00 <vrook> ski: Haskell can't be compared because there is no dictionary. That's why I playfully called it 0-parameter dispatch since it's resolved at compile-time.
11:52:04 <augur> byorgey: was that just a temporary side thing or was it a possible focus?
11:52:06 <ski> vrook : so, possibly we need more distinctions that just "single-dispatch" vs. "multiple-dispatch"
11:52:18 <byorgey> augur: those were possible focuses (foci?)
11:52:30 <Cale> vrook: oh?
11:52:31 <augur> byorgey: odd
11:52:35 <byorgey> augur: what's odd?
11:52:38 <augur> species are way better :)
11:52:42 <Cale> vrook: What do you mean, "there is no dictionary"? :)
11:52:48 <ski> vrook : implementations use dictionaries. and in case of polymorphic recursion and existentials, i don't see how they could use anything else
11:52:50 <byorgey> augur: hehe, agreed =)
11:52:53 <augur> actually i dont know what name binding is so
11:52:56 <Cale> There certainly are typeclass dictionaries in GHC's implementation
11:53:00 <augur> but extensions to GHC sounds like a boring focus
11:53:12 <Cale> and you can write programs for which there are an unbounded number of instances of a typeclass required
11:53:15 <Cale> pretty easily
11:53:19 <byorgey> augur: but no one else at Penn knows anything about them, which is why I tried doing other more collaborative stuff
11:54:07 <vrook> Cale: I just mean that dispatch is resolved at compile-time. At runtime, no dictionary is needed.
11:54:27 <Cale> > let foo :: (Show a) => a -> [String]; foo x = show x : foo (x,x) in foo 1
11:54:28 <lambdabot>   ["1","(1,1)","((1,1),(1,1))","(((1,1),(1,1)),((1,1),(1,1)))","((((1,1),(1,1...
11:54:37 <Cale> ^^ how does that compile?
11:54:50 <acowley> byorgey: I think nobody knowing anything about what you're doing is a core part of the thesis process
11:55:06 <byorgey> acowley: haha, good point =)
11:55:15 <mokus> dispatch in Haskell is not resolved at compile time except when the compiler can figure out how to do so, which is by no means always
11:55:20 <acowley> Congrats on picking a topic btw
11:55:22 <augur> its not so good if noone knows _anything_ tho
11:55:33 <Cale> vrook: That program needs infinitely many instances of Show
11:55:34 <augur> hard to talk with your advisor if you have to teach him everything ground up :(
11:55:42 <rwbarton> also resolving the dispatch in the sense of inlining the dictionary lookups is a space/time context even if it can be done at compile time
11:55:42 <acowley> it forces you to learn it
11:55:44 <Cale> vrook: Constructing them all at compile time is going to be hard
11:55:55 <rwbarton> er, what? a space/time tradeoff
11:56:04 <Cale> Or rather, it needs Show dictionaries at infinitely many monomorphic types
11:56:04 <xplat> acowley: but how will people know that nobody knows anything about what you're doing unless one of them knows a lot about things that are almost what you're doing?
11:56:33 <Cale> Polymorphic recursion for fun and profit?
11:56:48 <byorgey> acowley: thanks! yep, indeed
11:57:16 <augur> byorgey: ive been thinking recently i should learn some combinatorics. i wrote a paper a few days ago that i think vaguely has something to do with combinatorics, and i think the issue i raise at the end implies syntacticians should know some combinatorics, but i wanna know what you think
11:57:30 <ski> vrook : "dispatch is resolved at compile-time" is false, when using polymorphic recursion or existentials
11:57:35 <tgeeky> everyone should know how to count!
11:57:41 <acowley> xplat: the only question after your defense should be "What?"
11:57:43 <byorgey> augur: everyone should learn some combinatorics.
11:57:43 <xplat> vrook: anyway anybody who's had to resolve a performance problem due to large numbers of dictionary allocations would take issue with 'there is no dictionary' :)
11:57:56 <augur> byorgey: :p
11:58:02 <DukeDave> Cale: That example melted my mind :(
11:58:07 <acowley> byorgey teaches his pets combinatorics, he's biased
11:58:18 * byorgey doesn't have pets
11:58:26 <acowley> does cabal by default define a constant I can #ifdef on depending on the OS?
11:58:35 <augur> byorgey: i think your audiences are your pets
11:58:44 <augur> then acowley's statement is true!
11:58:51 <vrook> Cale: Well in terms of the overall point I'd say that's splitting hairs. When I say resolved at compile time I'm contrasting it with dynamic dispatch a la Lisp or whatever. That it's not actually resolved but nonetheless straightforwardly computable is a fair point, but not an important one here.
11:58:53 <acowley> byorgey: I can get you a goldfish or something
11:58:54 <byorgey> hehe
11:58:56 <hpaste> tgeeky pasted “resumable folding” at http://hpaste.org/55275
11:58:56 <xplat> acowley: technically it should be 'will you marry me?' from all present regardless of sex and marital status, or you haven't done your job
11:58:59 <platzhirsch1> m
11:59:08 <byorgey> acowley: how about a bag of goldfish?
11:59:10 <Philonous> Cale:  Doesn't that actually only need the dictionaries for a and (,) so that the respective functions could be inlined?
11:59:12 <byorgey> the snack kind
11:59:16 <xplat> oh, also regardless of orientation
11:59:19 <acowley> xplat: you have mastered academia
11:59:19 <tgeeky> how am I supposed to write the second pattern match for 'foldlr' (which is, "resumed" foldl) http://hpaste.org/55275
11:59:29 <Cale> Philonous: It uses a dictionary and a function from dictionaries to dictionaries
11:59:39 <acowley> byorgey: those would certainly be good for demonstrating combinatorics!
11:59:44 <byorgey> agreed!
12:00:16 <Cale> Philonous: The instance (Show a, Show b) => Show (a,b) compiles to a function on dictionaries which is used to compute the dictionary of Show for pairs from the dictionaries for the components.
12:00:41 <xplat> Philonous: how are you going to inline an infinite number of functions?
12:00:42 <ski> vrook : the point is that for polymorphic recursion and existentials, it's *impossible* to resolve fully at compile-time
12:01:46 <Cale> I could also have written something like  foo :: (Show a) => Integer -> a -> String; foo 0 x = show x; foo n x = foo (n-1) (x,x)
12:01:55 <Cale> and then taken the Integer from the user's input
12:02:03 <vrook> ski: Is Haskell equated with GHC and all its extensions now? I guess it is in a de facto way.
12:02:14 <rwbarton> that example didn't even use any extensions!
12:02:16 <Cale> vrook: Pretty much
12:02:23 <Cale> But this doesn't use extensions
12:02:28 <ski> vrook : if you want Haskell98, restrict the attention to polymorphic recursion. the problem is still there
12:02:30 <Cale> This is plain H98 typeclasses
12:02:33 <xplat> polymorphic recursion does not require extensions
12:02:47 <hpaste> byorgey annotated “resumable folding” with “resumable folding - with view patterns” at http://hpaste.org/55275#a55276
12:02:54 <byorgey> tgeeky: ^^^
12:03:44 <tgeeky> byorgey: darnit. I feared I couldn't put "snoc" or "unsnoc" there
12:03:49 <tgeeky> ok, thanks
12:03:59 <vrook> So Haskell needs run-time type information for polymorphic recursion?
12:04:44 <rwbarton> it needs the dictionaries
12:05:03 <ski> vrook : yes
12:05:13 <ski> well, not reall "run-time type information"
12:05:23 <ski> rather "run-time *instance* information"
12:05:29 <vrook> Frankly I'm surprised any run-time type information is needed in Haskell at all, including its extensions. This subverts my mental model of Haskell.
12:05:32 <acowley> Can I not put an if in the Test-suite section of a cabal file?
12:05:58 <copumpkin> vrook: with typeclasses, haskell types are necessary for its semantics
12:06:00 <ski> vrook : so, when you call that `foo' function above, there is *no* need to pass any representation of the type `a' to `foo'
12:06:01 <xplat> vrook: in many cases you can get by without, but you could say the same about lisp
12:06:01 <vrook> but aren't instances known at compile time?
12:06:07 <mokus> i wouldn't really call it run-time type information at all - it's jsut dictionaries and functions for transforming dictionaries
12:06:13 <byorgey> run-time type information is never needed in Haskell.
12:06:18 <ski> vrook : however, there *is* a need to pass a representation of the class constraint `Show a' to it
12:06:19 <Cale> vrook: It forgets all the types.
12:06:21 <byorgey> nor is it available.
12:06:40 <vrook> So aren't the dictionaries known at compile time?
12:06:51 <mokus> no, as Cale's example shows
12:06:51 <xplat> saying 'it forgets all the types' is a technicality
12:06:52 <Cale> vrook: Nope, many of them will be computed at runtime
12:07:00 <mokus> each recursive call to foo creates a new dictionary
12:07:11 <Cale> vrook: any instance which depends on other typeclass instances gets compiled into a function on dictionaries
12:07:23 <Cale> vrook: which is used to compute the instance at runtime
12:07:24 <xplat> there are some cases where it's important, like probably when using NewtypeDeriving, but mostly the instances determine the type one way or another
12:08:18 <Cale> vrook: and if you were to try to do all that computation at compile time in my program's case, you'll do an infinite amount of work at compile time
12:08:21 <ski> mokus : well, if the implementation uses some kind of hash-consing or similar, it could possibly reuse instances
12:08:23 <acowley> Perhaps I should reword that, is there a reason branches aren't allowed in the test-suite section of a .cabal file?
12:08:29 <ski> (but not in every case)
12:08:46 <xplat> you could say 'haskell doesn't need to know the type at runtime' in the same way you could say 'java doesn't need to know the type at runtime' if you have a program with no downcasts
12:08:55 <mokus> ski: true, but i would be really surprised if GHC would do that in this case
12:09:33 <mokus> ski: and in any case, it can't do that an infinite number of times
12:09:57 <ski> xplat : or "O'Caml doesn't need to know the type at run-time" (it has subtyping, but no downcasts)
12:09:58 <mokus> ski: (at compile time anyway)
12:10:12 <ski> mokus : *nod*, hence the "not in every case"
12:11:30 <acowley> Also, even when tests aren't enabled, a problem in the Test-suite section of a cabal file prevents building the package
12:11:42 <xplat> the main things are 1) the runtime 'type' information is not bundled into the object 2) once unbundled, it is only passed to places it might be needed 3) chunks of 'type' information don't even have to be 1-1 associated with objects
12:14:15 <benmachine> acowley: that doesn't surprise me terribly, depending on what the problem is; if it's "parse error" then it's probably bad to try to guess what the remainder of the package means, if it's "build depends not met" that's admittedly stranger
12:14:33 <xplat> so really what you have, operationally, is a dictionary-based multiple dispatch that is assisted heavily, but not entirely determined, by the type information present at compile time
12:14:39 <acowley> it's build depends not met
12:14:53 <acowley> I need to put a lib behind a conditional
12:14:59 <acowley> but I can't put an if the test-suite definition
12:15:14 <acowley> and without it, even with tests disabled, cabal halts because it can't find the lib
12:15:55 <monochrom> perhaps install the not-found lib manually first
12:15:56 <ski> xplat : well, you should also distinguish between "run-time representation of a type" and "run-time representation of a class constraint"
12:16:20 <ski> xplat : you don't need to pass around the former, but you do need to pass around the latter
12:16:32 <acowley> there are 419 open bugs on cabal
12:16:48 <acowley> monochrom: it's a C library that works differently on mac
12:17:11 <monochrom> there are a thousand times more bugs on ubuntu
12:17:13 <acowley> monochrom: for the normal build, I can branch on the os and use a Frameworks line for the mac, but I can't do that in the test
12:18:40 <ski> vrook : btw, note that it is possible to view the instance which is used for dispatch as the "main object" in itself, and then this is a sort of single-dispatch -- however this is usually an unnatural way to think about things; also these "objects" are singletons, there can be at most one of them for each "class"
12:18:42 <benmachine> my impression is that cabal and hackage are both understaffed
12:18:47 <vrook> For polymorphic recursion, are we talking about data Tree a = Leaf a | Node a (Tree a) (Tree a) ? You can't define instances of Leaf and Node, so it's still compile-time known. Is this only about the sliver of data that distinguishes Leaf and Node?
12:19:22 <copumpkin> data Tree a = Leaf a | Node a (Tree (Tree a)) (Tree (Tree a)) would need polymorphic recursion
12:19:31 <acowley> benmachine: that's probably a tremendous understatement
12:19:31 <ski> vrook : that is a "regular data type", so using that would usually not mean you have to use polymorphic recursion
12:19:39 <monochrom> that is not polymorphic recursion. polymorphic recursion example: data Whee a = C0 | C1 (Whee (Whee a))
12:19:50 <benmachine> acowley: well, go staff them then :P
12:20:07 <ski> vrook : a more interesting example is a type of *perfectly-balanced* binary trees : `data BinTree a = Elements a | Double (BinTree (a,a))'
12:20:30 <ski> vrook : a value of type `BinTree a' contains `2^n' elements of type `a', for some natural number `n'
12:21:03 <ski>   Elements 0 :: BinTree Integer
12:21:17 <ski>   Elements (0,1) :: BinTree (Integer,Integer)
12:21:30 <ski>   Double (Elements (0,1)) :: BinTree Integer
12:21:44 <ski>   Elements ((0,1),(2,3)) :: BinTree ((Integer,Integer),(Integer,Integer))
12:21:53 <ski>   Double (Elements ((0,1),(2,3))) :: BinTree (Integer,Integer)
12:22:02 <ski>   Double (Double (Elements ((0,1),(2,3))) :: BinTree Integer
12:22:04 <ski>   &c.
12:22:17 <acowley> benmachine: can I just file a bug report instead, and have the next person say, "Wow 420 open issues!"
12:22:32 <benmachine> acowley: you can, if you like
12:22:41 <roconnor> how many open issues does firefox have?
12:22:50 <ski> vrook : to be able to do any useful nontrivial computation on a "nested" datatype like this, you must use polymorphic recursion
12:22:54 <acowley> why does the GHC version on the bug report form only go up to 6.12.3?
12:23:07 <ski> vrook : try e.g. writing an `Eq' instance for this type
12:23:34 <jessopher> you cant really compare cabal & its exposure to the deathstar or walmart or 'look at all the craters on the moon'
12:23:40 <vrook> OK I think I understand why people keep saying "instances". New instances can be generated at run-time because Double (Double (Elements stuff)) is legit. Am I getting close?
12:23:52 <vrook> where stuff is only known at runtime
12:24:24 <Heffalump> yes, though it's actually quite rare for programs to make use of that: most instances can in theory be determined at compile-time, though the compiler doesnt' actually bother.
12:24:30 <ski> vrook : well, maybe i should show how to write `instance Eq a => Eq (BinTree a)' ?
12:24:39 <copumpkin> yeah
12:24:44 <Heffalump> an example of when it isn't runtime determinable is called "polymorphic recursion"
12:24:44 <ski> (also, what Heffalump said)
12:24:45 <copumpkin> I think JHC tries to roll them in at compile time?
12:24:47 <rwbarton> it might be clearer to just write eqBinTree without type class machinery
12:24:57 <copumpkin> Heffalump: yeah, we were just talking about that :)
12:25:00 <rwbarton> since otherwise I think it will be rather dull/magical
12:25:02 <unsafePerformIO> how can I evalute my data structure fully, i.e. every member and every sub-member and so on are evaluated?
12:25:08 <ski> (Heffalump : also, define "most" ;)
12:25:17 <Heffalump> sorry, I should read scrollback before I talk :-)
12:25:43 <ski> unsafePerformIO : in general you cannot, if it contains stuff like functions or `IO'-actions e.g.
12:26:13 <ski> unsafePerformIO : however, see `DeepSeq' and `rnf'
12:26:14 <ski> @hoogle rnf
12:26:15 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
12:26:41 <unsafePerformIO> ski: ok. my data structure only contains Bool, Double's and so on (primitive types), or such types as Maybe or tuples
12:27:08 <ski> @hoogle deepseq
12:27:08 <lambdabot> Control.DeepSeq module Control.DeepSeq
12:27:08 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
12:27:08 <lambdabot> package deepseq
12:27:10 <cl1> i'm having a bit of trouble wrapping my head around Functor, or i should say typeclasses that are implemented like Functor.
12:27:12 <unsafePerformIO> I want that data structure to be evaluated, even if it is not used
12:27:43 <ski> unsafePerformIO : so try something like `deepseq' or `rnf' (but don't expect this will necessarily magically improve the efficiency of your program)
12:27:44 <Philonous> unsafePerformIO:  You might also want to use strict data structures. Those are always fully evaluated (or not at all)
12:27:46 <monochrom> you can write a DeepSeq instance for your data structure. or you can screw DeepSeq and just put the same code in your own function.
12:28:02 <acowley> oddly enough, deepseq magically improved the efficiency of a program I worked on this week
12:28:13 <cl1> its like generic generics in c# if they existed correct?
12:28:57 <unsafePerformIO> Philonous: how do I use strict data structures? And I think I learned that bang patterns only evalute until constructor found. is this correct?
12:29:05 <applicative> cl1, how do you mean 'type classes that are implemented like Functor'
12:29:22 <cl1> class Functor<T> where T : class<U> { public abstract T<Z> fmap<V,Z>(Func<V,Z> f, T<V> a); }
12:29:30 <monochrom> data Whee = W !Int !Bool
12:29:37 <cl1> applicative, the ones that take type constructors instead of concreate types
12:29:42 <dynamicfish> monochrom: good name!
12:30:01 <applicative> cl1, yes all the best type classes do that!
12:30:24 <ski> vrook : you are probably getting closer, yes. the compiler can't in general know "which types actually be used at run-time" -- what it can do is statically check things so that any types "actually used at run-time" will not generate any run-time type error
12:30:29 <gwern> anyone know where the repo for this is http://hackage.haskell.org/package/torrent ?
12:30:33 <gwern> Lemmih: ^ ?
12:30:56 <ski> vrook : therefore, it can omit passing around types at run-time (since there is no way for the program to (directly) extract information out of types) -- consider a function `foo :: forall a. [a] -> [a]', there is no way for this `foo' to behave differently for different types `a'
12:31:04 <gwern> preflex: seen Lemmih
12:31:05 <preflex>  Lemmih was last seen on #haskell 2 days, 4 hours, 4 minutes and 15 seconds ago, saying: andsens: Tell it what 'a' is and the error will go away.
12:31:06 <Philonous> unsafePerformIO:  define your data types with bangs in front of the fields, like "data Foo = Foo !Int !Bar". Then the fields will be evaluated whenever the constructor is.
12:31:09 <monochrom> yes, "Whee" is my typical blanket name. beats foo bar baz. especially since everyone else already uses foo, and it is not easy to distinguish bar from baz. (wonder what kind of moron invented that convention, to have baz when bar is around)
12:31:31 <cl1> i'm just having difficulty wrapping my head around it
12:31:43 <vrook> Is there a simple example of how existentials require extra run-time tracking?
12:31:52 <ski> vrook : however, if we have `foo :: forall a. Blah a => [a] -> [a]', then because the program at run-time can behave differently depending on which *instance* is used for `Blah a', it can *indirectly* depend on the type `a'
12:31:54 <unsafePerformIO> Philonous: what if the data structure contains a Maybe-field?
12:32:03 <Philonous> unsafePerformIO:  Also, there are libraries with strict variants of the common structures, for example http://hackage.haskell.org/package/strict
12:32:23 <jessopher> plus, everyone can relate to a whee, nobody knows or cares what a baz is
12:32:32 <gwern> hm, I guess lemmih isn't here much lately
12:32:37 <Philonous> unsafePerformIO:  Then it will only force the constructor, but see the strict package for a strict Maybe variant
12:32:40 <cl1> if Int is a concrete type the what is Maybe?
12:32:57 <cl1> i know maybe is not a concreate type, what is it called?
12:33:00 <c_wraith> Maybe is a type constructor
12:33:28 <monochrom> if you have a non-primitive type, you can call it a non-primitive type...
12:33:33 <applicative> there is the jargon of the kind system cl1, but i'm not sure how illuminating it is at this point.  Int :: *, Maybe :: * -> *
12:33:37 <ski> vrook : existentials don't require "extra" run-time tracking. it's just that both in the case of polymorphic recursion and existentials, it's in general impossible to resolve instances at compile-time -- so the point is that this is a case that a perfect optimization is impossible
12:33:51 <acowley> the strict package has a haddock typo right at the top of Data.Strict.Tuple
12:34:09 <roconnor> today I had trouble explaining that (,)  on the type level is a type constructor and at the term level is a constructor of a type.
12:34:19 <vrook> ski: thanks, that helps. anything else apart from polymorphic recursion and existentials?
12:34:22 <acowley> but it's not on github, so I am powerless
12:34:33 <cl1> so Maybe is the same thing as a generic class in c#. and type classes are more meta than that, like a generic class that generates generic classes
12:34:40 <acowley> roconnor: type constructor vs. data constructor?
12:34:53 <roconnor> acowley: can I say that?
12:35:20 <applicative> roconnor, it was nice when they tried to keep them separate data Pair a b = MkPair a b has something to be said for it
12:35:22 <acowley> I don't know... I've certainly said it
12:35:51 <ski> vrook : if you have an existential like `data Queue a = forall q. Q {this :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (q,a)}' there is *no* "existentials require extra run-time tracking" when using this
12:35:52 <applicative> roconnor: c_wraith just said it
12:35:54 <monochrom> both "type constructor" and "data constructor" are sanctioned by Haskell 2010
12:36:26 <monochrom> section 4.1.2: "Just as data values are built using data constructors, type values are built from type constructors."
12:36:27 <roconnor> okay
12:36:39 <unsafePerformIO> Philonous, ski: basically, my program uses a (object of) data which is updated in the beginning of every iteration. I want that data to be evaluated, even if the data is not used in the iteration. How do you think I should solve this? (The datastructure only contains primitive types like Bool, Double, or them tupled, Maybeed)
12:36:53 <applicative> it is the going  jargon, i'm not sure something else mightn't have been better.
12:37:10 <monochrom> also it is "type class" not "typeclass".
12:37:37 <acowley> datatype, typeclass, foobar
12:37:38 <monochrom> also "the Maybe type", "the IO type" are sanctioned by Haskell 2010
12:37:43 <acowley> !
12:37:44 <applicative> such dogmatism!
12:37:45 <xplat> cl1: the kind of typeclass that functor is is called a 'constructor class'
12:37:47 <EvanR-work> typeclass sounds good to me
12:37:52 <EvanR-work> bring the progress
12:37:59 <ski> vrook : however, if you instead use `data Queue a = forall q. IsQueue a q => Q {this :: q}', and e.g. write a function `foo :: Queue Int -> ...', *then* there is no way of knowing until run-time the instance `IsQueue q' that is packaged into the input of type `Queue Int'
12:38:21 <applicative> whatever Haskell 2010 is it ought to just specify the language, not how we talk about it
12:38:35 <monochrom> Haskell 2010 says only "type class" but says both "algebraic data type" and "algebraic datatype".
12:38:42 <ski> vrook : "anything else apart from polymorphic recursion and existentials" -- possibly associated types/type families, i'm not sure
12:38:56 <applicative> monochrom: it shouldn't be datatype, it should be data type.
12:38:58 <acowley> I actually would like to have a standard to point to for datatype and typeclass vs their two-word variants
12:39:01 <EvanR-work> and the king james version of the bible has words like 'thee' and 'thou' ;)
12:39:49 * applicative proposes typeClass and dataType as the via media
12:39:50 <copumpkin> EvanR-work: "thou shalt spell thy data type as two wordes; not as one"
12:39:55 <acowley> I prefer the two-word versions, too. The language spec seems like the best place to put a stake in the ground that everyone can see.
12:40:03 <mokus> copumpkin: three is right out!
12:40:06 <ski> cl1 : `Maybe' is sometimes called a "type constructor", but i think that's not so good terminology, because imo `Either Int' isn't a type *constructor*, but we want to treat `Maybe' and `Either Int' the same here
12:40:11 <andsens> Hey guys. let x = [1..100]. Will " length x " take O(n) time or is the length on finite lists stored?
12:40:11 <ski> @kind Maybe
12:40:12 <xplat> the first commandment of jargon: thou shalt not quibble over single spaces or hyphens
12:40:12 <lambdabot> * -> *
12:40:13 <acowley> da ta type
12:40:13 <ski> @kind Either Int
12:40:14 <lambdabot> * -> *
12:40:16 <ski> @kind Either
12:40:17 <lambdabot> * -> * -> *
12:40:24 <rwbarton> "type term"?
12:40:30 <copumpkin> "type"
12:40:32 <EvanR-work> the scramble to find external legimiate authority
12:40:36 <Philonous> unsafePerformIO:  If you have access to the data type declaration and never need lazy behaviour I'd go for strict data types, they seem more predictable and less intrusive than seq and rnf everywhere
12:40:38 * applicative thinks it should be datum type anyway
12:40:41 <copumpkin> I had a good argument with applicative over this on reddit
12:40:41 <EvanR-work> legitimate
12:40:48 <acowley> the authority doesn't have to be legitimate
12:41:07 <unsafePerformIO> Philonous: thank you.
12:41:08 <applicative> oh god the kind nonsense, i resigned from reddit not too long after
12:41:08 <EvanR-work> illegitimate authority sounds like a contradiction
12:41:19 <ski> cl1 : *nod* that "generic generics" intuition isn't that bad
12:41:34 <copumpkin> applicative: man, I guess my points were so good that you had to resign in shame!
12:41:48 <gwern> ah, I forgot what fun bytestring was, '    Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'                 with actual type `ByteString''
12:41:55 <applicative> i think it was a little more complicated
12:42:01 <copumpkin> I win, you lose!
12:42:03 <copumpkin> simple!
12:42:06 <copumpkin> </troll>
12:42:09 <ski> cl1 : types with kind `*' are "ordinary" (non-generic) types, e.g. `Int',`[(Bool,String)]',`[Double -> Either String Bool]'
12:42:14 <acowley> now he's going to quit IRC
12:42:14 * applicative resigns
12:42:29 <copumpkin> I love being right on the internet
12:42:32 <byorgey> acowley: sadly, I have come to the conclusion that, just as in cases like "cupboard" and "email" the move to "typeclass" and "datatype" is linguistically inevitable.
12:42:33 <acowley> copumpkin: visit him at home, see how far this can go
12:42:36 <monochrom> sticking to Haskell 2010 terminology is one way to standardize terminology so we are on the same page. here is why. just yesterday a question was asked and it was incomprehensible because partly it spoke like "instance of the Vector type ... instance of the Storable type class ... instance this ... instance that ..."  If it stuck to Haskell 2010 terminology, it would be "value of Vector, instance of Storable" and the last two
12:42:37 <monochrom>  "instance"s would be disambiguated.
12:42:37 <copumpkin> lol
12:42:42 <byorgey> acowley: however, I also prefer "type class" and "data type".
12:42:47 <ski> cl1 : `Maybe' and `Either Int' have kind `* -> *', which means that they transform one ordinary (concrete) type into a new concrete type
12:42:48 <andsens> Guys? Anybody have a second?
12:42:56 <copumpkin> I prefer "classtype" myself, and "typedata"
12:42:56 <applicative> andsens: this is irc
12:43:05 <byorgey> hehe
12:43:12 <andsens> Thanks applicative, I noticed… :-)
12:43:12 <cl1> my mind has just been blown
12:43:14 <cl1> this is cool stuff
12:43:15 <ski> cl1 : and of course `Either :: * -> * -> *' means that it transforms two concrete types into a concrete type (in a curried way)
12:43:23 <andsens> mMaybe I'll just repeat my question:
12:43:29 <xplat> nobody is going to be confused because somebody said 'typeclass' instead of 'type class'
12:43:33 <andsens> let x = [1..100]. Will " length x " take O(n) time or is the length on finite lists stored?
12:43:38 * applicative wonders if cl1s mind was blown by classtype or by typedata
12:43:45 <byorgey> andsens: length is O(n).
12:43:46 <cl1> class MyFoo<T> : Either<Int,T> { } class Mabye<T> { }
12:43:48 <acowley> it was blown by the idea of quitting reddit
12:43:49 <donri> but some body might
12:43:54 <cl1> I can't write Functor in c# but I get it
12:44:10 <classtype-typeda> now I can annoy people more easily
12:44:31 <byorgey> typeda? is that like lambda?
12:44:34 * classtypedata too
12:44:45 <andsens> thx byorgey, so I will have to maintain it manually if I want to get O(1) time when using stuff like " length . tail x " etc.?
12:44:45 <acowley> type level lambdas!
12:44:47 <EvanR-work> dataclass
12:44:57 <EvanR-work> datasuperclass
12:45:02 <acowley> we've got big lambdas, and we can not lie
12:45:02 <jessopher> those are called 'families'
12:45:02 <cl1> curried types, how interesting
12:45:08 <acowley> datSuperClass
12:45:09 <ski> cl1 : however, let's say you define `type List a = IORef (Cell a); data Cell a = Nil | Cons a (List a)' -- this is a bit like an ordinary list, but each "tail" of the list is mutable
12:45:12 <classtypedata> oh hey classytypeofdata nice to meet you!
12:45:14 <copumpkin> my job here is done
12:45:14 <EvanR-work> familyclass
12:45:22 <cheater_> datclass
12:45:22 <vrook> The section "Existentially quantified data constructors" in http://haskell.org/ghc/docs/6.12.1/html/users_guide/data-type-extensions.html doesn't tell me what the LANGUAGE flag is.
12:45:44 <jessopher> familambda
12:45:48 <byorgey> andsens: yes, but you may also be interested in http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html
12:45:56 <byorgey> which supports O(1) length, among other things
12:46:19 <andsens> uuuuuh. Exactly what I was fishing for, thanks byorgey
12:46:22 <applicative> vrook, i always wait for ghci to tell me which language Im using
12:46:25 <ski> cl1 : now (say in another module) you want to do some STM programming, so you define `type List a = TVar (Cell a); data Cell a = Nil | Cons a (List a)' -- this is a different type as the previous one, the difference is the `TVar' instead of `STM', so this type list is indirected through `TVar's which is the mutable cells that are used in STM programming
12:46:27 <Philonous> andsens:  tail is usually a bad idea, btw.
12:46:47 <EvanR-work> so is head ;)
12:47:03 <andsens> …? What? Isn't it a single linked list?
12:47:06 <copumpkin> this is why you want to be safe with head
12:47:09 <copumpkin> use safeHead
12:47:10 <ski> cl1 : however, these are *almost* the same type, so it'd be nice if we could generalize this somehow, and so that common convenience functions that we write on such would work in both cases
12:47:16 <applicative> andsens, really, they're fine, you should just restrict yourself to infinite streams, thats what I do
12:47:19 <vrook> I don't see it in http://www.haskell.org/haskellwiki/Existential_type either. What's the secret code word to get forall?
12:47:20 <Philonous> andsens:  Sure it is, but use pattern matching instead
12:47:23 <rwbarton> lol
12:47:29 <rwbarton> what great "advice"
12:47:31 <xplat> unfortunately safeHead is called listToMaybe
12:47:40 <EvanR-work> ye
12:47:44 <andsens> oooh. Yeah of course, I generally do
12:47:48 <cl1> ski: whoa there, i'm only on my 3rd day of haskell, your gonna make my brain blow out. LOL
12:47:48 <ski> cl1 : so, the obvious thing to try is to factor out the `IORef' vs. `TVar' thing, so we get `type List ref a = ref (Cell ref a); data Cell ref a = Nil | Cons a (List ref a)'
12:47:50 <benmachine> 'drop 1' is a good replacement for tail as well
12:47:52 <applicative> vrook: ExistentialQuantification Rank2Types etc
12:48:08 <copumpkin> ExplicitForall I think, too
12:48:11 <applicative> > drop 1 ""
12:48:12 <lambdabot>   ""
12:48:19 <applicative> > tail ""
12:48:20 <lambdabot>   "*Exception: Prelude.tail: empty list
12:48:24 <xplat> benmachine: depends if you need to detect failure or if you can just ignore it
12:48:39 <monochrom> "if null xs then c else f (head xs) (tail xs)" is a roundabout way to say case xs of { [] -> c; h:t -> f h t }
12:48:48 <rwbarton> drop 1 is only a good replacement for tail if you've actually thought about what you want to do with the empty list and it happens to be returning the empty list
12:48:49 <rwbarton> in general, using tail is safer
12:48:56 <ski> cl1 : now, the cool thing is that now `List' (and `Cell') will be a type that takes as argument a (simply) "generic" type like `Maybe' or `IORef' (whose kind is `* -> *'), and also a concrete type (the list element type), and give back a concrete type
12:49:11 <ski> cl1 : e.g. `List IORef Int' is a concrete type, it has kind `*'
12:49:23 <monochrom> "if null xs then c else f (head xs) (tail xs)" is popular because people come from lisp, scheme... 1970s languages.
12:49:35 <byorgey> cl1: "your gonna make my brain blow out" -- get used to it ;)
12:50:01 <vrook> applicative: thanks
12:50:01 <acowley> what's the closest thing to a HEREDOC in Haskell?
12:50:08 <ski> cl1 : i.e. `List IORef Int :: *'. but we know `Int :: *' (it's a concrete type), so `List IORef' is a type function that takes a concrete type and gives a concrete type, so its kind is as follows : `List IORef :: * -> *'
12:50:10 <cl1> byorgey, LOL
12:50:11 <acowley> the TH solution seems almost okay
12:50:13 <monochrom> what does HEREDOC do?
12:50:14 <vrook> "Someone" should add that info to the page
12:50:25 <acowley> monochrom: just a way to have multiline strings
12:50:31 <xplat> cl1: if you come to Hac Boston you will see how we all look like Talosians from having our brains blow out of our skull so many times
12:50:32 <rwbarton> <<<EOF
12:50:44 <ski> cl1 : finally, `IORef Int' is a concrete type, so `IORef' must be a "generic" type, so `IORef :: * -> *'
12:50:49 <monochrom> quasiquoting and a bit of your own code
12:50:53 <hpaste> gwern pasted “bytestring problems” at http://hpaste.org/55279
12:50:54 <gwern> so anyone with a little C want to help me out?
12:51:04 <ski> cl1 : so, this means that `List' is a "generic-generic" type : `List :: (* -> *) -> * -> *'
12:51:17 <monochrom> but yeah, quasiquoting is a special case of TH
12:52:31 <ski> cl1 : and of course the possibilities doesn't stop here. if you want, you could define a type `Foo' which wants as argument types like `List', so then `Foo' might have kind `((* -> *) -> * -> *) -> *', e.g.
12:52:34 <cl1> xplat: wonderful
12:52:45 <gwern> problem is even old bytestring seemed to require 2 Ints, so I'm not clear how this ever worked - eg. http://hackage.haskell.org/packages/archive/bytestring/0.9/doc/html/Data-ByteString-Internal.html#v%3AfromForeignPtr
12:52:53 <ski> cl1 : the main point is : this is *just* like higher-order functions like e.g. `map' -- only for types instead
12:53:38 <ski> cl1 : btw, this would be true even if we had no type classes at all -- type classes doesn't add to the "generic-meta" here, in this sense
12:54:39 <ski> cl1 : hm, i forgot to mention, `*' is the "kind" (think "like type, but for types instead of for values") of all concrete types
12:54:54 <rwbarton> gwern: since SHA-1s are 20 bytes long, I assume 20 is the length and the offset should be 0
12:55:02 <ski> (and a concrete type is a type for which it makes sense to ask whether there could be any values of that type)
12:55:10 <gwern> rwbarton: that's what I was inclining towards too
12:55:26 <rwbarton> also because I can imagine that the API used to be "ptr + length" but I can't imagine it was ever "ptr + offset" :P
12:55:34 <rwbarton> since then, what is the length?
12:55:40 <cl1> ski: thanks for the info, i'm still trying to process it all
12:55:50 <vrook> Are any of these ghc extensions able to produce undecidable types? I'm looking at all the forall examples and I'm wondering if I can build a turing machine out of it.
12:56:06 <cl1> ski: it just curried types, and the concrete type is the edge condition?
12:56:07 <vrook> ...using other extensions...
12:56:11 <vrook> ..as well
12:56:57 <xplat> vrook: normally not, but there are the occasional extensions like UndecidableInstances that put you in the same situation as a C++ compiler
12:57:41 <cl1> or should i say, the concrete type is the result of the function
12:58:13 <cl1> until you have a concrete type it is simply a partial application
12:58:20 <cl1> does this all sound like i'm understanding it?
12:58:35 <jessopher> it does to me
12:58:49 <salisbury> do I have to explicitly evaluate each IO action to ensure they are sequenced correctly? Or will, say, openBinaryFile >> hSeek >> funcThatReads >>= hTell >> hClose always happen in that order at some point in time
12:58:49 <ski> cl1 : in some sense concrete types is a special case, yes
12:59:03 <acowley> "-cl-fast-relaxed-math" is a fantastic name for an option
12:59:04 <salisbury> (params omitted)
12:59:11 <ski> @type ord
12:59:11 <mzero> salisbury: that is fine
12:59:11 <lambdabot> Char -> Int
12:59:28 <rwbarton> gwern: btw, I think you could write this more simply as   sha1 fs = BS.unsafeCreate 20 (\ptr -> BS.unsafeUseAsCString fs (\cstr -> c_sha1 cstr (BS.length fs) ptr))
12:59:29 <applicative> concrete types are a special case, where the type is ... a type
12:59:38 <mzero> for IO a,  >> and >>= garuntee ordering of operations
12:59:41 <gwern> rwbarton: not my code, it's Lemmih's code
12:59:49 <rwbarton> well, it's your code now ;)
12:59:50 <ski> cl1 : you know basic type checking, right ? so e.g. if `ord :: Char -> Int' and `myChar :: Char', then `ord myChar :: Int' ?
12:59:54 <rwbarton> but fair enough
13:00:05 <ski> > let myChar = 'a in  ord myChar
13:00:06 <lambdabot>   <no location info>:
13:00:06 <lambdabot>      lexical error in string/character literal at chara...
13:00:12 <ski> > let myChar = 'a' in  ord myChar
13:00:13 <lambdabot>   97
13:00:31 <salisbury> ahh, so I guess it is poor form to have the result of IO actions as params
13:00:50 <cl1> myChar is an instance of Char
13:00:51 * tgeeky holds up a placard with a 5.5 on it
13:00:53 <cl1> yes i get that
13:00:54 <gwern> (auugh these bytestring errors)
13:00:58 <tgeeky> ooh, he lost some points for that one. bad form!
13:01:44 <cl1> the power of this type system is quite profound
13:01:48 <Shammah> map (read :: Int) [1, 2, 3]
13:01:54 <Shammah> obviously this doesnt work
13:02:05 <Shammah> but how do I correctly pass a read function like I want to?
13:02:25 <applicative> salisbury, It is part of the idea of the IO interpretation of >>= that there is a temporal succession, no doubt there are ample curiosities
13:02:37 <dschoepe> cl1: Wait till you see a dependently typed language.. :)
13:02:50 <xplat> > map (read :: String -> Int) ["1", "2", "3"]
13:02:50 <cl1> dschoepe, such as?
13:02:51 <lambdabot>   [1,2,3]
13:02:57 <jessopher> agda
13:02:59 <dschoepe> cl1: Agda or Epigram
13:03:01 <opqdonut> > map read ["1", "2", "3"] :: [Int]   -- also this
13:03:02 <lambdabot>   [1,2,3]
13:03:11 <applicative> don't worry cl1, our type system has ample things to meditate on for the moment
13:03:14 <xplat> ninja'd by opqdonut
13:03:36 <Shammah> ah, thanks :D
13:03:46 <cl1> applicative, yeah, "be like a postage stamp, stick to one thing until you get there"
13:04:12 <jessopher> or atleast wait until the compilers compile programs
13:05:04 <cl1> does f#(ocaml) have this same concept of curried types?
13:05:47 <monochrom> yes
13:05:48 <xplat> ocaml does, i don't really know about f#
13:05:54 <cl1> awesomeness
13:06:00 <cl1> f# is like ocaml on .net
13:06:09 <xplat> ocaml doesn't have Functor, though
13:06:36 <Heffalump> by curried types you mean a type with multiple type arguments where you can partially apply it?
13:06:40 <Heffalump> if so, F# doesn't ahve that.
13:06:41 <xplat> ml variants tend to use modules rather than typeclasses
13:06:48 <monochrom> ocaml doesn't have type class, so it doesn't have Functor.
13:06:59 <cl1> Heffalump, that's what i was asking, yes
13:07:00 <xplat> or type-classes or type classes or type-effing-classes
13:07:17 <xplat> (for anyone who's confused by my nonstandard terminology)
13:07:20 <Heffalump> it also lacks higher-kinded types in general, so there's not much you could do with a partially applied type even if you could make one
13:08:04 <cl1> well i can skip using my newfound knowledge in .net for a while then
13:08:09 <hpc> haha
13:08:21 <vrook> The only thing I know about F# is that a zealous crazy person advocates it on comp.lang.lisp.
13:08:34 <fryguybob> cl1: Don't worry, it will haunt you.
13:08:34 <xplat> cl1: you could maybe use it if they have scala running on .net again
13:08:37 <Heffalump> you can play some other fun games with the F# type system though because it incorporates the .NET object system
13:08:40 <Heffalump> vrook: Harrop?
13:08:44 <vrook> yep
13:09:13 <xplat> yes, harrop definitely fits 'zealous crazy person'
13:09:15 <monochrom> that's certainly worth celebration. he discovers the lisp community finally
13:09:16 <applicative> harrop, haven't heard from him for so long.  I feel lonely somehow.
13:09:20 * hackagebot sindre 0.2 - A programming language for simple GUIs  http://hackage.haskell.org/package/sindre-0.2 (TroelsHenriksen)
13:09:27 <xplat> it's amazing how you can get famous for that
13:09:28 <cl1> f# is ocaml on .net, just remember that, it even has an ocaml compatability mode
13:09:37 <cl1> so now you know all about f#
13:09:38 <Heffalump> cl1: but without functors
13:09:49 <applicative> life is not worth living?
13:09:51 <cl1> ocaml has functors but f# does not?
13:10:01 <monochrom> well, seriously, pick one: harrop harasses the haskell community, harrop harasses the lisp community. :)
13:10:01 <Heffalump> applicative: he mostly seems to have given up ragging on haskell, perhaps he doesnt think it's a threat any more
13:10:07 <xplat> ml functors are different from haskell Functors
13:10:07 <Heffalump> cl1: correct
13:10:09 <xplat> of course
13:10:18 <Heffalump> right
13:10:19 <cl1> i hate microsoft
13:10:24 <applicative> Haskell, not a threat, I wonder what changed?
13:10:27 <Heffalump> cl1: it's a rational choice given the platform
13:10:27 <mokus> monochrom: he harasses the non-f# community
13:10:30 <monochrom> (and before you think of him doing both, consider his time and effort a zero-sum game...)
13:10:35 <vrook> I didn't even know Harrop hassles Haskell too.
13:10:40 <Heffalump> lately he's been harrassing the Mathematical guys on stackoverflow
13:10:46 <Heffalump> *Mathematica*
13:11:03 <rata_> hi guys
13:11:10 <xplat> what?  seriously?
13:11:12 <vrook> Oh right, the Haskell Map performance thing.
13:11:14 <applicative> vrook: he used to troll Haskell lists all the time
13:11:20 <monochrom> well, any newfound community other than haskell he harasses is good!
13:11:31 <gwern> oh my god, these integer/int issues...!
13:11:37 <xplat> isn't programming in mathematica enough suffering for anyone?  why does he need to bother them more?
13:11:43 <gwern> screw Lemmih's code, I'm going to look at some more recent haskell torrent work
13:11:43 <cl1> Heffalump, why is that?
13:12:01 * cl1 has been doing .net since it came out (literally)
13:12:02 <Heffalump> cl1: F# is quite faithful to .NET which means it can be a (nearly) first-class citizen on the platform
13:12:15 <Heffalump> functors would substantially diminish interoperability
13:12:21 <applicative> first you write in a language like mathematica, then harrop dumps on you, it's all so cruel....
13:12:26 <Heffalump> and objects are a 95% replacement from the point of view of non-ML developers.
13:12:44 <copumpkin> cl1: keep in mind that microsoft funds a lot of haskell development, too :)
13:12:55 <xplat> pickled radish alert
13:12:57 <salisbury> applicative: I meant more along the lines of doing     g (f a)     where    f :: a -> IO b , g :: IO b -> IO c    is a bad thing
13:13:17 <salisbury> ?
13:13:19 <cl1> maybe hate is a strong word then
13:13:42 <xplat> salisbury: not so much 'a bad thing' as 'not usually what you want, though sometimes it is'
13:14:11 <cl1> isn't the guy in charge of ghc a microsoft employee?
13:14:15 <applicative> salisbury, but it type checks.
13:14:38 <applicative> salisbury: there are important  functions of types like  IO _ -> IO _
13:14:47 <rwbarton> @type forever
13:14:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:15:27 <xplat> > forever [()]
13:15:28 <lambdabot>   *Exception: stack overflow
13:15:34 <xplat> :(
13:15:48 <applicative> salisbury: e.g. forkIO :: IO () -> IO ThreadId
13:16:05 <cl1> > take 5 $ forever [()]
13:16:06 <lambdabot>   *Exception: stack overflow
13:16:19 <Heffalump> cl1: yes
13:16:35 <salisbury> ahh, yes
13:16:51 <cl1> .Net: y u no has Functor?
13:16:52 <hpc> ?run forever []
13:16:53 <lambdabot>   []
13:16:59 <applicative> salisbury: so "forkIO $ readFile x" isn't bad, though admittedly it's a special case and your basic thought seems right
13:17:00 <cl1> lol
13:17:11 <Heffalump> cl1: generics solve roughly the same problem as functors
13:17:21 <applicative> sorry, that's not IO () need a different case
13:17:27 <gwern> seems jlouis has abandoned his torrent client
13:17:32 <applicative> salisbury, this is why God gave me a type checker
13:17:36 <xplat> > snd . runWriter . forever . tell $ "a"
13:17:37 <salisbury> forkIO $ writeFile x
13:17:37 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
13:17:38 <cl1> Heffalump, close, but not the same
13:17:43 <Heffalump> right
13:18:19 <mokus> > fix forever :: Maybe ()
13:18:22 <salisbury> :t writeFile
13:18:23 <lambdabot>   mueval-core: Time limit exceeded
13:18:23 <lambdabot> FilePath -> String -> IO ()
13:18:26 <applicative> salisbury, "forkIO $ writeFile x" makes good sense
13:18:30 <salisbury> yay
13:18:33 <dgpratt> cl1: LINQ select seems quite close
13:18:34 <salisbury> :)
13:18:41 <applicative> right
13:18:46 <johnfn> is there a nice way to get a machine readable form of haddock?
13:18:47 <Heffalump> oh, and F# does add monadic syntax
13:19:07 <cl1> I can do a static function: public static T<a> fmap<a,b>(Func<a,b> f, Mabye<b>) { } that works like fmap, however I cannot create a contract over it for all generics that have a single type argument
13:19:10 <gwern> johnfn: haddock is machine-readable, that's the point is it not?
13:19:11 <Heffalump> johnfn: have you investigated what's in the .haddock files?
13:19:16 <xplat> dgpratt: wrong functor
13:19:36 <cl1> T<a> was supposed to be Maybe<a>
13:19:43 <dgpratt> xplat: oh, what functor are we talking about today?
13:19:45 <xplat> dgpratt: this is the 'parameterized module' kind of functor
13:19:52 <dgpratt> xplat: ah
13:19:52 <Heffalump> cl1: because of the lack of higher-kinded types
13:20:00 <cl1> right
13:20:17 <cl1> learning is fun, you all have been quite helpful
13:20:24 <gwern> haskell-torrent has no support for multi-file torrents... well so much for that
13:20:25 <cl1> irc = the teacher I never had
13:21:09 <xplat> hm, or maybe we're talking about both :)
13:21:33 <xplat> gwern: yeah, there probably isn't a modern fully-featured and unrotted one you can pick up off the shelf
13:21:55 <gwern> xplat: all I want to do is take a particular .torrent and delete 2 files with >255 byte size names
13:22:13 <xplat> oh come on, you can do that with vim
13:22:39 <gwern> xplat: I don't think I can, because apparently there's an overall file hash and stuff
13:22:50 <gwern> xplat: not to mention all the utf8 encoding makes it hellish to look at
13:23:19 <xplat> the hash is on the 'info' key of the main dictionary
13:24:11 <vrook> When I see extensions like the existential forall, it makes me think about "ultimate" solutions as opposed to little special-purpose extensions. If there were a metalanguage for types then at least some things wouldn't require a language extension. I am beginning to appreciate Shen a little more, though nobody uses it.
13:24:32 <gwern> vrook: go use Shen, you reprobate!
13:24:42 <Heffalump> vrook: do you know how existentials look in Agda?
13:24:46 <xplat> which is contiguous in the file, so once you have the offsets, save, use 'tail' and 'head' to pipe it through sha1sum in another terminal, and paste the hex in
13:24:59 <vrook> Heffalump: nope, I know nothing of agda
13:25:01 <gwern> xplat: offsets?
13:25:11 <Heffalump> (I don't, but I have a perhaps naive hope that a dependent-typed language will give you a nice language at every level)
13:25:17 <hpc> vrook: /join #agda and learn!
13:25:29 <xplat> vim's hex-editing mode lets you see offsets
13:25:54 <hpc> Heffalump: it does, in the sense of giving you the SAME language at every level
13:25:55 <xplat> the beginning is the 'd' right after the word 'info', the end is the corresponding 'e'
13:26:02 <gwern> xplat: you assume I use vim
13:26:10 <ClaudiusMaximus> if you delete the files, the piece hashes won't match up - making the names shorter should work
13:26:19 <xplat> well, any hex editor that lets you change lengths
13:26:57 <xplat> ClaudiusMaximus: it's not like you could use it with people who don't have the new torrent anyway
13:27:32 <xplat> if you need to do that, you need to use a torrent client that supports excluding files and just shut out the long files in the client
13:27:33 <vrook> freenode numbers: haskell 842, agda 86, shen 8.
13:27:48 <applicative> shen?
13:28:11 <gwern> applicative: qi
13:28:22 <xplat> actually iirc the info-hash isn't even in the .torrent file, it's just computed from it to use in the protocol, so you can just hexedit and that's as good as you're going to get
13:28:31 <applicative> I see. My interest lasted about 6 seconds
13:29:39 <ClaudiusMaximus> xplat: by piece hashes i meant the "map shasum . splitEvery pieceSize . concat `fmap` mapM readFile files" thing
13:29:53 <applicative> well maybe a little more.   shen contains an embedded prolog; why not an embedded haskell?
13:30:04 <gwern> xplat: no, it is not as simple as just telling the client to exclude the evil files
13:30:08 <xplat> ClaudiusMaximus: oh shit, you're right
13:30:14 <gwern> xplat: believe, I've already tried that and many other things, in 7 or 8 clients now
13:30:38 <xplat> gwern: what exactly is the problem with having files with long names?
13:30:47 <gwern> xplat: instant death on Linux
13:30:50 <gwern> 255 byte limit
13:31:38 <xplat> i must have never come across torrents like that
13:32:07 <gwern> kind of unusual to come across long foreign files whose utf8 encodings blow the 255 byte limit, yes
13:32:10 <Axman6> lol wut?
13:32:12 <hpc> gwern: renaming didnt work?
13:32:13 <gwern> first time in all the years I've been torrenting
13:32:32 <gwern> hpc: renaming in the clients happens after the error is caused in clients' code
13:33:03 <mauke> hook open() and silently remap overlong names
13:33:22 <gwern> mauke: yes, I'll do that right after I master hex editors
13:33:32 <xplat> mauke wins the prize
13:33:54 <mauke> shouldn't be hard
13:34:04 <xplat> you can probably do that in a like 3-line hack of fakeroot
13:35:11 <xplat> maybe a little more if you also need to hit rename and unlink
13:35:13 <gwern> xplat: I only know fakeroot as something I once typed to do with debian kernels, so that is not helpful
13:35:25 <xplat> apt-get source fakeroot and hack away
13:35:43 <mauke> how does fakeroot work? ptrace?
13:35:53 <xplat> dynamic loader hooks
13:35:58 <shachaf> mauke: I think it's just LD_PRELOAD.
13:36:01 <mauke> ah, the easy way :-)
13:36:24 <shachaf> "easy" as in "easy to circumvent". :-)
13:36:35 <mauke> int $0x80, baby
13:36:56 <xplat> if anybody cares to circumvent it, which they won't in this case
13:37:02 <shachaf> Sure.
13:37:33 <shachaf> mauke: Real system callers use sysenter/syscall/VDSO/whatever.
13:38:19 <gwern> I think I'll just see how emacs's hex-editor mode works and whether I can edit the file...
13:38:32 <xplat> gwern: no, actually that won't work
13:38:41 * monochrom has used linux's syscall(SYS_gettid)
13:38:52 <gwern> xplat: maybe transmission will be forgiving of any checksum problems
13:39:08 <gwern> it's better than hacking LD_PRELOAD. 'now he has two problems...'
13:39:15 <xplat> gwern: i thought it would, but i was wrong, partly because of your use case, partly for more fundamental reasons
13:39:20 * hackagebot gsmenu 3.0 - A visual generic menu  http://hackage.haskell.org/package/gsmenu-3.0 (TroelsHenriksen)
13:39:37 <xplat> the best you can do is change the name, but then unless you hacked the client you won't pick up anyone in the existing swarm
13:40:01 <gwern> huh
13:40:22 <xplat> the filenames are part of the info that is hashed to compute the swarm identifier
13:40:31 <andsens> Is there another way to pattern match this? rot [] r:_ a = r:a
13:40:57 <andsens> I don't want the "rs" (after the r: )
13:41:14 <mzero> did you mean   rot [] (r:_) a = r:a    ?
13:41:18 <xplat> so hooking open() is actually the easiest way
13:41:25 <andsens> oh...
13:41:26 <vrook> I have a gripe. Indexing is zero-based, but range values are inclusive. So there's "length - 1" everywhere. It's almost like ranges are a holdover from a 1-based predecessor.
13:41:30 <mzero> and no, that is the correct way to pattern match the first element of a non-empty list
13:41:35 <andsens> why is that necessary mzero?
13:41:47 <mzero> what, the parens?
13:41:52 <andsens> I assume it is because pattern matching is not right associative?
13:41:53 <mzero> or the _ ?
13:41:54 <andsens> yes.
13:41:58 <andsens> no the parens
13:42:11 <ski> xplat : O'Caml doesn't have higher-order type functions : the allowed kinds are `*' and `*^n -> *', for `n' being a positive integer
13:42:14 <gwern> xplat: that doesn't help me very much - at least with editing a .torrent I have a basic idea of what's in it and what I want to do, hooking open() means nothing to me
13:42:17 <rwbarton> function application is higher precedence than infix operators, even in patterns
13:42:26 <mzero> because without them, the : will be an operator with   rot [] r   on the left and  _ a on the right
13:42:32 <rwbarton> rot [] r:_ a means (rot [] r):(_ a)
13:42:32 <mzero> which, won't actually work
13:42:41 <andsens> oooh
13:42:42 <rwbarton> (yes and this means nothing of course)
13:42:46 <andsens> of course
13:42:50 <andsens> thank you
13:42:59 <xplat> ski: huh, with all the crazy type system extensions they have they don't have something that basic?
13:43:09 <xplat> ski: i thought that was just a limitation of f#
13:43:12 <ClaudiusMaximus> > listArray (minBound, maxBound) "-=+" ! compare "this" "that"
13:43:13 <lambdabot>   '+'
13:43:58 <xplat> gwern: that's why i said hack fakeroot.  fakeroot already hooks open(), you just have to add a nice if() or something where it's already being done
13:44:00 <andsens> I can do it in records though? Like " fn Stuff { list=x:xs, otherstuff } = ...."
13:44:07 <ski> xplat : you can get sortof the same thing (but not quite) by making a module functor that takes as input a module containing the argument type(s) and creating a module containing the result type
13:44:13 <gwern> xplat: eg https://forum.transmissionbt.com/viewtopic.php?f=2&t=10948&start=15 describes it as hairy
13:45:07 <ski> xplat : the problem is that this is all static -- with extensions you can do this module application at run-time, but it's still regenerate the code in the output module -- there's no way to use the same polymorphic code over type variables with kind other than `*'
13:46:04 <xplat> oh, right, have to hook stat() too
13:46:15 <ski> xplat : maybe some SML *implementation* supports higher-order types, i'm not sure (well, i know the experimental MetaML implementation does, but there's no work being done on that atm)
13:46:27 <ski> (except that i'm trying to hack a little on it ;)
13:46:28 <Axman6> andsens: is that from a queue implementation?
13:46:38 <andsens> yep
13:46:42 <xplat> but that's nothing, and fakeroot hooks *everything* you need to hook, you just have to modify the hooks it has already
13:46:59 <edwardk> woot! we've assimilated sclv. =)
13:47:11 <andsens> Why do you ask Axman6?
13:47:14 <Axman6> thought it looked familliar.
13:47:15 <copumpkin> b0rgwardk
13:47:18 <Heffalump> edwardk: ?
13:47:24 <Axman6> andsens: turns out those don't actually perform very well :(
13:47:34 <ski> (with extensions in some SML implementations at least, you can put functors inside modules/structures, so you can then approximate not just second-order types like this, but also third-order, &c.)
13:47:40 <andsens> The paper by Chris Okasaki?
13:47:45 <Axman6> yeah
13:48:10 <andsens> hm, well thats disappointing....
13:48:25 <andsens> Gotta do it for a report. Gonna benchmark it
13:48:37 <andsens> absolute performance is not really important
13:48:40 <Axman6> I tried making a schedualer for the monad-par library that used those queues instead of ... lists i think... and it performed a hell of a lot worse :(
13:49:05 <copumpkin> Axman6: you want a deque!
13:49:10 <ski> andsens : you can do it there because brackets aren't needed to disambiguate there
13:49:21 <Axman6> copumpkin: hmm?
13:49:27 <copumpkin> double-ended queue
13:49:30 <copumpkin> work-stealing etc. etc.
13:49:41 <andsens> … which chris okasaki also talks about.
13:49:47 <andsens> thx ski
13:49:59 <xplat> the okasaki structures don't perform competitively for small sizes on current hardware, especially if you don't optimize them aggressively
13:50:16 <andsens> ah, ok
13:50:24 <Axman6> well, really what we want is the deque in ghc to be exposed. I has a talk to Simon Marlow about it a while ago after i tried implementing this queue and get disappointed
13:50:59 <xplat> this goes double for the hard constant-time ones you'll find in standalone papers, a lot of those are just proving a point
13:51:01 <applicative> edwardk: what is this sclv assimilate?
13:51:54 <xplat> getting rid of either an intermittent log n factor or an overall inverse ackermann factor at the expense of the typical case
13:52:14 <vrook> Axman6: do the queues use regular OS locks or are there spinlock contraptions?
13:53:16 <xplat> also, if you just want a one-way queue and it's not realtime you'll get the best overall throughput with the 'two lists' queue
13:53:17 <Axman6> vrook: locks? who needs locks? we have fast atomic operations on IORefs
13:53:45 <copumpkin> we do have locks if you want them, but they don't use OS locks
13:53:52 <copumpkin> since we have our own scheduler
13:54:20 <Axman6> which performs much better
13:54:25 <vrook> Axman6: but a queue has to block somehow while waiting. How is the block done?
13:54:56 <c_wraith> hook's into GHC's scheduler
13:55:01 <c_wraith> err.  *hooks
13:55:02 <xplat> (and that's if it needs to be pure-functional, you can do better than two-lists if you're in a situation where you can use mutable arrays)
13:55:18 <Axman6> vrook: in thise case, I think it just looked at other queues and stole work, unless all the queues were all empty, then it idled until some work became available
13:55:31 <Axman6> the implementation is pretty clear, go have a look at the source for monad-par
13:56:14 <xplat> ... and of course concurrent queues are an entirely different beast altogether from queues you'd use in graph algorithms or internally in a single-core scheduler
13:56:45 <vrook> Axman6: Alright, but because I'm lazy could you tell me how it idles? The methods I see are OS lock + condition variable, which is slow, or spinning, which can also be slow.
13:56:58 <vrook> ... or fast.
13:57:07 <vrook> Scheduling is a hard problem.
13:57:50 <edwardk> applicative: we lured him into the office and locked the door.
13:57:57 <xplat> most GHC threads are not OS threads at all
13:58:07 <Axman6> I'm pretty sure neither of those are used. we don't need OS locks, we have a very good scheduler that knows all about things like MVars, and which threads need to be woken up when an MVar is written to
13:58:21 <andsens> omfg. I started writing haskell two days ago. One monday afternoon and a wednesday evening, seem to be enough to implement the okasaki paper without fault. I luuuuuuv haskell!
13:58:26 * applicative was imagining an ideological assimilation
13:58:42 <vrook> Axman6: by thread you mean a non-OS thread?
13:58:43 <Ke> and userspace spinlocks =oP
13:58:48 <Axman6> yes, of course
13:58:53 <Axman6> we almost never use OS threads directly
13:59:17 <Axman6> there's no need for threads to use any computational resources if they're waiting on an MVar
13:59:36 <copumpkin> lockClosure in the RTS
13:59:41 <Axman6> the scheduler just runs another thread straight away
13:59:43 <vrook> OK if we're not talking about OS threads then my question is moot.
13:59:52 <Axman6> yes =)
13:59:59 <Axman6> OS threads--
14:00:07 <copumpkin> but we still need to interact with OS threads
14:00:17 <vrook> How do you manage OS threads efficiently, then? You have to multicore somehow.
14:00:17 <copumpkin> the RTS does some crazy stuff to get SMP on real OS threads
14:00:27 <vrook> Or do you fork?
14:00:28 <Axman6> vrook: it's not that uncommon to write haskell programs with 1000's or 10s of thousands of threads without any issues
14:00:34 <edwardk> applicative: yes, we indoctrinated him into the ideology of wanting to work with us
14:00:36 <copumpkin> vrook: http://snapplr.com/4n23
14:00:42 <edwardk> and then we unlocked the door
14:00:54 <copumpkin> http://darcs.haskell.org/ghc/includes/rts/storage/SMPClosureOps.h
14:00:57 <Axman6> no, ghc has an N by M scheduler
14:01:18 <copumpkin> the actual mvar code happens in http://darcs.haskell.org/ghc/rts/PrimOps.cmm
14:01:19 <applicative> what what's this "Inch is a type-checker for a subset of Haskell (plus some GHC extensions) with the addition of integer constraints."
14:01:23 <copumpkin> but it calls out to that
14:01:25 <Axman6> vrook: the RTS runs M OS threads, which run the N Haskell threads, using work steaking queues
14:01:38 * applicative studies
14:01:53 <copumpkin> applicative: a new typenat
14:02:06 <Axman6> vrook: haskell threads actually have less overhead per thread than even erlang threads
14:02:08 <copumpkin> applicative: this one doesn't do any voodoo in its solver, though
14:02:17 <copumpkin> applicative: I almost feel a bit more comfortable with it, despite it being less powerful
14:02:21 <applicative> i see. is voodoo good or bad in this context
14:02:46 <xplat> but if there's no voodoo, why not just use datakinds?
14:02:46 <copumpkin> applicative: well, I was uncomfortable with typenats attempting to solve peano arithmetic heuristically, and having that in our type system
14:02:56 <copumpkin> xplat: it still has a presburger solver
14:03:04 <Axman6> vrook: there's a reason my Haskell program tops the thread-ring benchmark in the language shootout: http://shootout.alioth.debian.org/u32/performance.php?test=threadring
14:03:10 <xplat> so some voodoo, but not enough?  :)
14:03:17 <copumpkin> xplat: no, just the right amount!
14:03:18 <Axman6> hmm, Go has improved a lot
14:03:27 <copumpkin> xplat: I'm objecting to a heuristic solver rather than something we know is complete
14:03:37 <copumpkin> it's pretty hard to build a mental model of when it'll succeed/fail otherwise
14:03:39 <Axman6> and I'm glad to see C is not the top again, they weren't even using threads at all
14:03:40 <Saizan> completeness++
14:03:42 <copumpkin> and there's no fall-through if it does fail
14:03:49 <copumpkin> beyond unsafeCoerce
14:04:15 <Saizan> you could do some GADT proofs, i hope :)
14:04:33 <copumpkin> Saizan: I'm not sure they really have any facility for that planned right now
14:04:36 <xplat> copumpkin: well, some fallback would be nice
14:04:43 <copumpkin> vrook: there's a decent amount of commentary on it in the GHC commentary wiki
14:04:50 <copumpkin> which is remarkably informative about how everything works
14:05:02 <copumpkin> some parts of it are sketchier than others though
14:05:09 <xplat> but i would really like a pure-universal ring solver, for instance, in my magic integer constraint solver as well
14:05:16 <copumpkin> xplat: yeah!
14:05:32 <copumpkin> if we can phrase it as complete fragments then I'm happy with it
14:05:44 <copumpkin> but once it starts failing unpredictably I'm not so happy
14:05:49 <xplat> so mostly it's the phrasing you're unhappy with?
14:05:58 <copumpkin> I want to have a model in my head of when it can work and when it can't
14:06:11 <copumpkin> so I don't have to try compiling and have it say "nope, couldn't figure it out, sorry"
14:06:30 <mauke> minor problem
14:06:35 <mauke> fopen is doing something retarded
14:06:53 <xplat> fopen?  people still use fopen?
14:07:04 <copumpkin> xplat: well, we can split it up into presburger for addition/constant mult/equalities/inequalities, and omega/semiring solver for non-constant multiplication and only equality
14:07:18 <copumpkin> xplat: typenat tries to do other stuff too, though, and doesn't seem particularly principled
14:07:29 <xplat> i thought everyone and their brother's dog was doing their own buffering over OS IO now
14:12:13 <djahandarie> Dude...
14:12:20 <copumpkin> duuuude...
14:12:23 <djahandarie> My brother's dog died 2 years ago
14:12:28 <djahandarie> Totally not cool
14:12:42 <alistra> my brother dies 2 god years ago
14:13:02 <alistra> my brother died* 2 dog* years ago
14:13:05 * djahandarie checks to see if alistra is a markov chain
14:13:08 <djahandarie> Ah, damn, guess not
14:13:11 <applicative> inch has a nice examples directory, maybe the one on units, quantities etc. will be readily intelligible
14:13:12 <donri> future past supernatural tense?
14:13:36 <djahandarie> Is there a reasonable way to make GUIs in Haskell now?
14:13:40 <xplat> copumpkin: i guess, say, http://library.thinkquest.org/18242/diophantine_ga.shtml is something i would not want to see in my type system
14:13:45 <donri> is gtk2hs reasonable?
14:14:05 <mauke> gwern: I've written a small library to redirect the most common filename functions in case the length exceeds 255 bytes
14:14:10 <alistra> i'm did the random talk, but can walk the random walk
14:14:18 <djahandarie> Seemed clunky when I tried it out awhile back donri.
14:14:30 <gwern> mauke: oh yes?
14:14:33 <copumpkin> xplat: lol
14:14:41 <donri> would be nice to see something that works via gobject introspection magic
14:15:41 <mauke> gwern: http://mauke.dyndns.org/tmp/reopen/
14:16:06 <xplat> so if you complain about long filenames in bittorrent on #haskell, someone will write you a custom library in C?  cool.
14:16:13 <monochrom> I think gtk2hs is reaonsable
14:16:30 <mauke> s/write/hack/
14:16:40 <acowley> djahandarie: I believe the answer is "No" but http://haskell.org/haskellwiki/Reactive-banana may be worth a try
14:16:48 <alistra> fuuuuuuuuu mauke
14:16:59 <alistra> i stumbled upon an omega term
14:17:07 <alistra> in your tmp folder
14:17:09 <mauke> hmm?
14:17:28 <gwern> mauke: right now my torrent isn't failing; I don't know whether this is just because it just isn't randomly downloading the evil files or whether my complaining caused the torrent to be changed or maybe tracker settings changed
14:17:49 <alistra> lolcrash.html
14:17:51 <gwern> mauke: once it does resume failing I guess I will give that a try
14:18:26 * gwern sees Bad Apple!!; the torrent is http://www.nyaa.eu/?page=torrentinfo&tid=256613 btw
14:19:02 <mauke> 224 GiB?
14:19:15 <xplat> ... holy crap
14:19:27 <xplat> touhou fandom never does anything by halves, do they?
14:19:38 <gwern> xplat: up to 52G so far, and think, this is the lossy torrent
14:21:01 <mauke> heh, the .torrent alone is 6.5 MB
14:21:26 <xplat> that's quite possibly bigger than my entire lossy music collection, including the stuff i downloaded but never once listened to
14:21:32 <copumpkin> wow
14:21:36 <copumpkin> that's a big torrent
14:21:36 <gwern> hm, my .torrent is 6.7M
14:21:39 <copumpkin> what is it?
14:21:51 <mauke> gwern: which one is the evil file?
14:21:53 <Axman6> In wonder if they'd get pissed at me for downloading that at work, it'd only take an hour or so :P
14:22:06 <djahandarie> Is that the comiket torrent? *click*
14:22:19 <djahandarie> Oh, guess not.
14:22:20 <gwern> mauke: there's two that I know of - one of them is in [BLUE TRAIN], and the other is in [COOL&CREATE], the 2005 album IIRC
14:22:26 <djahandarie> The comiket torrent is pretty enormous too
14:22:35 <gwern> djahandarie: hm, ln? I wonder if they overlap
14:22:39 <mauke> ooh, german
14:23:09 <Axman6> which GHC make --make the default?
14:23:15 <Axman6> 7?
14:23:45 <applicative> is --make the default?
14:23:53 <Axman6> yes
14:24:38 <applicative> oh indeed, I hadnt noticed
14:25:57 <monochrom> 200GB of mp3 takes more than 4 months to play continuously
14:26:13 <gwern> good thing I don't plan on dying any time soon
14:26:28 <merijn> I suspect that is highly dependent on the quality of the encoding :p
14:26:33 <Axman6> monochrom: only if you listen to them at normal speed
14:26:38 * gwern actually sets mplayer to only play the first ~1:30 of files
14:28:03 <djahandarie> gwern, I *think* it was this one: http://www.nyaa.eu/?page=torrentinfo&tid=189328
14:28:28 <merijn> At 320kbps it's only about 2 months
14:28:42 <merijn> If you have higher quality encoding it drops drastically further :p
14:29:08 <donri> i thought mp3 beyond 320CBR was pointlessish
14:29:08 * djahandarie questions the use of 'quality' when talking about things higher than 320kbps ;p
14:29:36 <aninhumer> If it's electronic music maybe you could run length encode the audio for faster listening "bleep bleep bloop - 'four bars of that'"
14:30:03 <Axman6> heh
14:30:04 <gwern> djahandarie: hm, spot checking a few, looks like that's mostly new
14:30:09 <merijn> donri: Dunno, I usually rip to 320 since that is already way above the threshold for what I could possibly perceive different with any reasonable stereo :p
14:30:22 <merijn> aninhumer: That exists, yes
14:30:26 * gwern chuckles. I'm hard of hearing, anything above like 128kbps is wasted on me!
14:30:27 <donri> i keep everything in 24bit flac just because
14:30:46 <merijn> I have some FLAC because I refuse to transcode high quality to lower :p
14:31:15 <cl1> i just have a private band that plays what I ask them too :P
14:31:30 <merijn> aninhumer: tracker music is made that way and commonly stored in that format too. For example the soundtrack of Unreal Tournament. The result is high quality music with ridiculously low storage costs
14:32:18 <merijn> cl1: That only works if you only listen to music that is playable by said band
14:32:22 <aninhumer> merijn: I know, I meant actually shorten the audio by detecting repeating bars and only playing them once :P
14:32:36 <aninhumer> so you can get through 200GB of music faster
14:32:49 <merijn> I have plenty of music that I reckon is far to hard to play for the average band to play :p
14:32:58 <gwern> merijn: that sounds a little weird... shouldn't formats like vorbis or mp3 already be handling trivially compressible stuff which can be done with RLE?
14:33:10 <merijn> Hmm, I seem to have added a redundant verb there
14:33:16 <donri> 200 gb is about 400 songs in 24bit flac ;P
14:33:54 <merijn> gwern: tracker music vs normal mp3's is more like vector graphics vs rasters
14:34:04 <Axman6> bahahaha, chrome's page translation struggled for a while when i went tp show all filea for that torrent
14:34:14 <merijn> gwern: You can do thinks as "repeat this sample n times, alternating them between these two filters"
14:34:28 <merijn> gwern: So you can do much more complex things than just RLE
14:34:42 <gwern> merijn: hm. so this is kind of like MIDI, a simple programming language?
14:34:44 <merijn> You just specify a data flow graph of sounds and effects
14:34:51 <gwern> well that explains small encodings
14:35:19 <gwern> djahandarie: looking at it, I think that's just all sorts of doujin, not just touhou, which is why most/all aren't showing up in my big touhou torrent
14:35:34 <monochrom> you are going to suggest a music "encoding" that supports a static type system, GADTs, and kind constraints
14:35:35 <djahandarie> Yes, it is all sorts of doujin
14:35:41 <djahandarie> And only from C79
14:36:08 <donri> wth is that touhou stuff anyway
14:36:11 <djahandarie> The touhou torrent is probably just a big touhou collection
14:36:17 <aninhumer> monochrom: you can get your compiler to ensure your lyrics rhyme and keep the meter
14:36:24 * djahandarie is not a touhou expert :p
14:36:31 <xplat> touhou is a series of danmaku ('bullet hell') shoot-em-up games
14:36:53 <gwern> djahandarie: I'm not either, I just like the instrumental rock
14:37:00 <cl1> merijn, it was supposed to be a joke. i don't really have a private band
14:37:02 <xplat> where the player sprites and enemies are all cute anime girls
14:37:16 <gwern> with hats. they all must have hats
14:37:23 <gwern> or they will die!
14:37:24 <donri> i thought this was supposed to be music
14:37:31 <merijn> cl1: I realise that, but that doesn't mean I can't poke holes in your logic!
14:38:04 <monochrom> I see that none of you have claimed "I just read the scores"
14:38:06 <xplat> donri: well, there's a lot of (actually very good) music in the game soundtracks, and the fans make remixes and their own original compositions, etc
14:38:16 * merijn facepalms
14:38:30 * monochrom just looks at the CD
14:38:37 <merijn> Well, I earned another notch on my classic programming mistakes belt...
14:39:02 * aninhumer just extrapolates what music will be made in future
14:39:03 <gwern> rm -rf *?
14:39:19 <merijn> Wrote my own allocator, accidentally call the normal free on memory allocated that way, trashing the malloc arena
14:39:26 <merijn> gwern: That's not really a programming mistake
14:39:31 <gwern> sure it is
14:40:11 <donri> rm -rf / path/to/file
14:40:22 <xplat> touhou-related music is actually so good it almost makes the fandom respectable.  by fandom standards anyway.
14:40:51 <gwern> I'd say as good as vocaloid, but they're pretty distinct - touhou is almost entirely instrumental/classical rock, and vocaloid j-pop
14:40:58 <gwern> apples and oranges, neh?
14:41:17 <mauke> incidentally, http://www.youtube.com/watch?v=dMruuDQp8Jw
14:41:28 <monochrom> fuji apples and fuji oranges :)
14:41:42 <merijn> As usually I don't understand half the words in the conversation, with the only difference that it is not programming speak this time...
14:42:25 <xplat> some things never change, eh?
14:42:40 <monochrom> touhou is just an abelian endo-instrumentoid
14:42:58 <gwern> merijn: we're too hipster here to discuss music *you* would have heard of
14:43:04 <xplat> in the category of Nice Hats
14:43:20 <gwern> as the joke goes, 'what's a hipster's favorite number? A: it's really obscure, you've probably never heard of it'
14:43:40 <mauke> yay, just got the "file name too long" error in transmission
14:43:41 <EvanR-work> as soon as everyone finds out though, its not cool anymore
14:43:53 <merijn> gwern: I'm not wapanese enough, I think
14:44:33 <xplat> my favorite number is my private ssh key :)  when everyone finds out it's not cool indeed :)
14:45:15 <Axman6> merijn: what OS?
14:45:15 <mauke> also, http://www.youtube.com/watch?v=H1ofnslOBRs
14:45:20 <Axman6> uh, mauke
14:45:27 <mauke> Axman6: linux
14:45:44 <donri> what fs, moreimportantly?
14:45:45 <Axman6> i'm really surprised that linux has such limitations
14:46:07 <mauke> donri: ext3
14:46:08 <gwern> Axman6: 255 characters is pretty reasonable. 255 bytes is not.
14:46:17 <gwern> the latter, unfortunately, is the case.
14:46:20 <donri> i wonder if it holds true for btrfs too
14:46:26 <xplat> i don't find either very reasonable
14:46:41 <Axman6> me eiher
14:46:43 <Axman6> t*
14:46:48 <xplat> at least it should be adjustable
14:47:08 <Axman6> huh, HFS+ has a max of 255 characters (UTF-16)
14:47:08 <djahandarie> It should be 140 characters.
14:47:10 <gwern> it probably hurts performance to have >255 chars - that's a lot!
14:47:21 <djahandarie> That way I can tweet all my filenames.
14:47:22 <monochrom> hahaha 140
14:47:29 <gwern> (this is just the filename of course, not the full path)
14:47:31 <mauke> twitterfs
14:47:41 <merijn> Axman6: File or full path?
14:47:49 <Axman6> file
14:48:00 <merijn> Seems reasonable enough
14:48:09 <aninhumer> Hmm, is there a good reason not to allow arbitrary length?
14:48:10 <EvanR-work> people will never need more than 8+3 characters in filenames
14:48:18 <Axman6> Allowed characters in filenamesUnicode, any character, including NUL. OS APIs may limit some characters for legacy reasons
14:48:28 <mauke> aninhumer: yes, because people like me will then create multi-gigabyte filenames
14:48:42 <EvanR-work> Axman6: '/' is allowed o_O?
14:48:50 <aninhumer> well, if you do that you deserve the consequences
14:49:00 <Axman6> EvanR-work: yeah, it gets replaces with : though. can't remember what happens if you use :
14:49:08 <xplat> EvanR-work: using / as a separator is a unix thing, no need to care on the fs level
14:49:21 <EvanR-work> really?
14:49:29 <Axman6> I'm pretty sure / is valid on my HS's, yuou just need to escape it in the comand line
14:49:31 <aninhumer> maybe do something like the DOS compatibility, but with 255 chars instead of 8+3
14:49:31 <merijn> EvanR-work: Of course
14:49:36 <xplat> it might make the file hard to access from unix, though
14:49:37 <vrook> a filesystem with an adjustable record size has probably never existed, and probably never will.
14:49:43 <merijn> EvanR-work: Filesystems have no notion of a path
14:49:46 <EvanR-work> well on mac it replaces your / in the filename with a special interest character
14:49:56 <EvanR-work> merijn: are you trolling?
14:50:02 <merijn> EvanR-work: No
14:50:19 <xplat> vrook: if it allows 255 byte filenames and the records are fixed-size i want my money back
14:50:39 <merijn> Why would a filesystem have a path? In unix they just have inodes and data blocks
14:50:41 <xplat> since my typical names are nowhere near 255
14:51:04 <xplat> some filesystems have a notion of a path
14:51:06 <EvanR-work> merijn: have you tried putting a / in the filename
14:51:21 <merijn> EvanR-work: Limitation of the OS/programs interfacing with the filesystem
14:51:32 <xplat> among those, though, only some consider them as a string, most would think of them as a sequence of strings
14:51:35 <EvanR-work> might as well call that the filesystem
14:51:39 <EvanR-work> because its impossible
14:51:40 <merijn> The OS has a concept of paths, and thus won't let you create files it can find back
14:52:08 <djahandarie> EvanR-work, if you're redefining terms on the fly, you should really be careful who you're calling the troll ;p
14:52:27 <EvanR-work> nah
14:52:42 <merijn> Edit /dev/ad0 (or whatever it's called under linux) with any binary editor and you can create files with a '/' in the name just fine
14:52:56 <EvanR-work> and the api fails?
14:53:01 <EvanR-work> apps fail?
14:53:08 <merijn> You can easily write tools that succesfully access those files
14:53:22 <EvanR-work> in a fs independent manner?
14:53:26 <xplat> so even for most path-knowledgeable filesystems the thing with all the /s in it is just the upper-layer's serialization of what they would call a path
14:53:59 <EvanR-work> seems like all the stdlibs process paths using the / character
14:54:06 <merijn> No, but why does it need to be FS independent? That's orthogonal to the discussion
14:54:10 <mauke> EvanR-work: duh?
14:54:26 <merijn> Because the unix standard says that '/' is the separator character
14:54:38 <EvanR-work> so you effectively cant have a file with / in it or the sky will fall
14:55:04 <merijn> My points was that that is not due to the FS but due to the OS
14:55:15 <EvanR-work> hmm
14:55:38 <aninhumer> merijn: more like due to the tools surely
14:55:39 <merijn> "<xplat>	EvanR-work: using / as a separator is a unix thing, no need to care on the fs level" <-- you were questioning this statement
14:56:11 <jessopher> technically, on GNU Linux (and most unixes), the os is made of the tools
14:56:38 <xplat> fs's don't care about / any more than your car's steering column has a pair of hands at the bottom end of it that it uses to turn a steering wheel to turn the car when you turn *its* steering wheel at the top end
14:57:09 <merijn> aninhumer: The kernel also has a notion of paths, so it is a restriction in the kernel too, making it impossible to write other tools (that work with the kernel) that ignore the restriction
14:57:13 <aninhumer> xplat: I think that's how early power steering basically worked?
14:57:47 <merijn> If you don't care about using the kernel to access files (because you're running as root and accessing /dev/hda directly, for example) then you it'd be just a tool restriction, yes
14:58:11 <aninhumer> merijn: Ah, yeah, I was just thinking you could use C functions, I forget they deal with /s too
14:58:53 <aninhumer> Hmm, is that in libc or actually in the syscalls?
14:59:20 <mauke> syscalls
14:59:25 <merijn> Some syscalls accept paths, so
14:59:34 <xplat> syscalls are the last layer guaranteed by unix to use /, if by syscalls you mean those things under section 2 of man
14:59:42 <mauke> userspace can't see the fs
14:59:48 <Patinho`Busy> o/
15:00:30 <xplat> theoretically those could all be C wrappers that deserialize the path before sending it to kernel space
15:00:46 <xplat> and serialize ones that come back
15:01:07 <aninhumer> xplat: well obviously that has to be done somewhere
15:01:07 <xplat> (tricky in the case of ioctl though, who knows what that will do, or with unix sockets)
15:01:12 <acowley> The funniest part of working with random numbers is when you look at a range of data and think, "That doesn't look random...."
15:01:27 <ddarius> acowley: Humans are rather bad at that.
15:01:32 <mauke> that's the thing about random numbers: you never know
15:01:49 <xplat> of course that depends what you mean by 'random'
15:01:55 <merijn> Finally a discussion were my homework of writing a simple defragmenter pays off :p
15:02:01 <xplat> and by 'you never know'
15:02:28 <jessopher> maybe your brain is doing the hashing subconciously
15:02:30 <acowley> mauke: that is exactly it
15:02:35 <xplat> there are definitely definitions of 'random' for which you can tell by inspection that some data is not random, but can't tell if it is
15:03:01 <djahandarie> Sounds like something a constructivist would like!
15:03:04 <merijn> If you have a Bayesian view of the universe it's irrelevant, you can never be certain anyway
15:03:18 <xplat> and other definitions where you can't tell by definition without observing the numbers being generated
15:03:25 <merijn> Just varying degrees of certainty
15:03:29 <Axman6> hmm, does defragmenting basically boil down to sorting?
15:03:54 <accel> is there a functional pearl for serializing persistent structures to disk?
15:04:02 <merijn> Axman6: No, much simpler since you know the correct order in advance
15:04:06 <xplat> merijn: that's like saying there's no gravity because it's all space-time curvature anyway
15:04:08 <ddarius> merijn: Bayesianism doesn't rule out certainty.  Rationality and realism do for pretty much everything but tautologies.
15:04:19 <Axman6> merijn: what do you mean?
15:05:03 <ddarius> Axman6: The are multiple "sortings" that make correct defragmentations.  Sorting would be a massive overspecification.
15:05:17 <merijn> Axman6: I have 10 data blocks, they are already in order, but not adjacent
15:05:33 <merijn> Defragmenting is just copying them in order to new blocks which *are* adjacent
15:05:47 <vrook> We can think of types as being a meta-language whose purpose is to verify the language. We could additionally have a meta-meta-language to verify the meta-language. Is there anything like this in reality? A type checker for types?
15:05:54 <vrook> I'm still thinking about the "forall" thing and how a higher-level language might be interesting in which we get forall for free.
15:05:55 <acowley> oh my goodness, converting between CFloat and Float is such an awful annoyance
15:05:58 <merijn> In other words, it defragging has O(n) complexity
15:06:06 <mauke> vrook: the kind system
15:06:08 <ddarius> vrook: Haskell already has kinds.
15:06:18 <xplat> vrook: dependent type systems can use the same type system to type types that they do to type values
15:06:32 <Axman6> do kinda have sorts yet?
15:06:33 <jessopher> turtles all the way up
15:06:35 <vrook> but I'm guessing the kind system is not powerful enough to express forall.
15:06:37 <aninhumer> I remember people talking about superkinds at a Hackathon once...
15:06:40 <ddarius> More generally, see Pure Type Systems.
15:06:46 <ddarius> Axman6: Yes.
15:06:54 <merijn> vrook: See, Coq/Agda/Epigram/etc. :p
15:06:55 <ddarius> vrook: It is now.
15:07:02 <Axman6> ddarius: is that new in GHC?
15:07:04 <ddarius> Where now = GHC head.
15:07:43 <xplat> wow, is *that* in for 7.4?  or still going to stew a while?
15:07:59 <Axman6> xplat: should be
15:08:14 <merijn> My programmering prayer: cross fingers and repeating "please don't segfault, please don't segfault" over and over again >.>
15:08:42 <xplat> merijn: the computer won't listen to you unless you pray that in code :)
15:09:05 <merijn> xplat: I have noticed that, unfortunately
15:09:06 <c_wraith> meh.  just trap segfaults
15:09:08 <johnfn> how can i check to see if a handle has more output that i can read?
15:09:32 <dropdrive> Is there a standard typeclass that provides pairwise max (e.g. Ord) but also a "succ" function such that "succ x > x"?
15:09:35 <c_wraith> johnfn: why do you want to do that?  (this is probably the best answer for that question in ghc)
15:09:59 <merijn> c_wraith: Only works if you're segfaults don't happen in kernel mode :p
15:10:11 <johnfn> c_wraith: i have opened up the stderr of a process, and i want to print out any stderr that it happens to get
15:10:12 <ByronJohnson> @hoogle hIsEOF
15:10:12 <lambdabot> System.IO hIsEOF :: Handle -> IO Bool
15:10:12 <lambdabot> GHC.IO.Handle hIsEOF :: Handle -> IO Bool
15:10:20 <Axman6> ddarius: what's wrong with Ord and Enum?
15:10:24 <Axman6> uh, dropdrive
15:10:35 <c_wraith> johnfn: so forkIO a process that just reads from it and prints until EOF.
15:10:35 <ByronJohnson> @hoogle hReady
15:10:35 <lambdabot> System.IO hReady :: Handle -> IO Bool
15:11:09 <c_wraith> johnfn: ghc's IO system is carefully set up so that the implementation for that will be a select (or similar) loop.
15:11:20 <johnfn> hmmm
15:11:49 <byorgey> Axman6: presumably that succ does not guarantee that succ x > x
15:11:51 <johnfn> the thing is, hReady keeps giving me false when i KNOW it's not false
15:12:01 <byorgey> although I imagine that is true for pretty much every instance of both Ord and Enum
15:12:02 <johnfn> (because if i do hGetLine, i get stuff...)
15:12:10 <Axman6> byorgey: but no type class can. only the semantics that people implement can right?
15:12:21 <byorgey> Axman6: right, I mean that Enum has no semantics =P
15:12:26 <c_wraith> yeah, don't trust functions like hReady.  read is the only thing that will really tell you.
15:12:27 <Axman6> indeed
15:12:30 <ddarius> succ maxBound is required to be undefined by the Report.
15:12:38 <Axman6> instance Enum Int where succ x = x
15:12:43 <ddarius> Of course if you're not an instance of Bounded that doesn't apply.
15:12:43 <monochrom> forkIO-created threads are dirt cheap and close to rolling your own select loop cost-wise. of course if you philosophically hate threads and not because of cost, that's another matter
15:12:47 <johnfn> but if i read and there's nothing there... :/
15:13:09 <merijn> johnfn: Then your block, which is why you do it in a separate thread :)
15:13:31 <johnfn> ah...hm, that makes sense :o
15:13:38 <accel> haskell is a constructive proof that there exists a programming language I am not smart enough to use
15:13:39 <merijn> monochrom: I philosophically hate threads, just not in Haskell since Haskell removes my main objection to threads :p
15:13:45 <merijn> (shared mutable state)
15:14:02 <aninhumer> accel: but does it prove it for all future times?
15:14:35 <aninhumer> there's only one solution, we'll have to kill you
15:14:44 <merijn> johnfn: Haskell's threads (i.e. forkIO) are lightweight threads and the runtime automatically uses select/kqueue/epoll for blocking functions like read
15:14:55 <ddarius> aninhumer: No great loss, apparently.
15:15:11 <mm_freak_> merijn: haskell has shared mutable state
15:15:14 <mm_freak_> but in a clean way
15:15:17 <merijn> mm_freak_: Hush!
15:15:27 <ddarius> Haskell has shared mutable state alse in a dirty way.
15:15:28 <monochrom> of course merijn means that.
15:15:53 <merijn> unsafeShootSelfInFoot
15:16:19 <monochrom> sorry, what is "alse"?
15:16:31 <jessopher> i would have just named it shootSelfinFoot
15:16:53 <hpc> unsafeInterleaveBulletWithToes
15:17:04 <jessopher> lol
15:17:08 <gwern> mauke: think I like that o-life piece. while I'm downloading all these gigs, might as well toss in http://www.nyaa.eu/?page=torrentinfo&tid=128539 ...
15:17:22 <monochrom> I see, "also"
15:19:40 <ByronJohnson> c_wraith: Sounds like there's a bug if I can't trust hRead
15:21:03 <jessopher> hReady
15:22:36 <ddarius> hReady always returning False is a valid implementation as far as I can tell.
15:25:37 <c_wraith> you can trust that if it returns true, there is data ready
15:25:45 <c_wraith> But if it returns false, it doesn't mean much
15:35:59 <mm_freak_> if i were to write a safe ByteString wrapper encoding the string length in the type system, is there a neat trick to get along without CPS?
15:36:29 <mm_freak_> fromBS :: ByteString -> (forall n. Length n => SafeStr n -> b) -> b
15:37:46 <mm_freak_> oh, i got an idea
15:37:53 <benmachine> it would be nice if there was an exists keyword, and you could write exists n. Length n => SafeStr n
15:38:14 <benmachine> I think it would amount to roughly the same thing insofar as where you could use it
15:38:14 <merijn> benmachine: You can write that, afaik. Just not with that syntax :p
15:38:23 <benmachine> merijn: well sure, it's the syntax I want
15:38:41 <merijn> So hack it together and propose it's included! :p
15:38:49 <byorgey> it's not that simple
15:39:06 <merijn> byorgey: I suspect that that's why it doesn't exist yet?
15:39:20 <byorgey> you'd need a new special form of 'case' to match on existentials, or something like that
15:39:26 * hackagebot plugins-auto 0.0.4 - Automatic recompilation and reloading of haskell modules.  http://hackage.haskell.org/package/plugins-auto-0.0.4 (FacundoDominguez)
15:39:40 <byorgey> currently you don't need that because the way existentials work, you are required to have a data constructor
15:39:41 <c_wraith> doesn't UHC have exists ?
15:39:51 <byorgey> matching on that data constructor is what unpacks the existential
15:39:53 <byorgey> does it?
15:40:06 <c_wraith> I thought some not-commonly-used compiler does
15:40:49 <byorgey> hmm, so it does
15:40:51 <byorgey> I wonder how it works
15:41:00 <mm_freak_> benmachine: yeah, i'm thinking of something along those lines
15:41:20 <mm_freak_> a special return type instead of a continuation
15:41:22 <byorgey> aha
15:41:27 <byorgey> it doesn't work with class constraints
15:41:37 <byorgey> for precisely the reason I said.
15:42:27 <byorgey> well, not precisely what I said.  but the problem is how you package up a class dictionary along with a value
15:44:22 * byorgey apologizes for being vague.  back to grant proposal writing.
15:44:50 <Saizan> you get your type directed desugared to insert a snd everywhere you use it as the value?:)
15:44:57 <Saizan> *desugarer
15:45:35 <ski> byorgey : i think it ought to be `exists n. Length n *> SafeStr n'
15:46:05 <byorgey> ski: where *> is an actual type constructor?
15:46:10 <ski> no
15:46:38 <ski> where `*>' : `=>' :: `(,)' : `(->)'
15:46:52 <byorgey> ah.
15:46:59 <tsou> Could someone reason about why Float and Double are instances of Enum?  It seems strange to me..
15:47:09 <ski> something of type `Blah a => ..a..' expects the environment to provide the instance `Blah a'
15:47:16 <ddarius> So people can write [1.0 .. 10.0]
15:47:19 <tsou> I can only think of the .. notation..
15:47:22 <byorgey> well, now that we have Constraint Kinds I guess you could get away with something like   exists n. (Dict (Length n), SafeStr n)
15:47:26 <ski> something of type `Blah a *> ..a..' would provide the `Blah a' instance itself
15:47:33 <ski> byorgey : iirc, UHC allows `exists' to the left of `->' (which is simple to implement)
15:47:34 <tsou> which in turns seems to be a bad idea with such types..
15:47:46 <ski> byorgey : *nod*
15:47:48 <tsou> ddarius: any other reason than this "convenience"?
15:48:01 <ddarius> tsou: Not to my knowledge.
15:48:06 <c_wraith> tsou: no, that's about it.  and it often works out badly
15:48:29 <merijn> floats and doubles in general work out badly :p
15:48:30 <ski> byorgey : btw, i'm not sure that a `case' would be needed ..
15:48:31 <c_wraith> > [0.1, 0.3 .. 0.6]
15:48:31 <lambdabot>   [0.1,0.3,0.5,0.7]
15:48:36 <tsou> c_wraith: that's what i've figured.. so I was wondering why it is an instance of it to begin with..
15:49:00 <benmachine> tsou: the .. syntax is more or less what the Enum class is *for*
15:49:06 <c_wraith> everyone expected 0.7 to be in that result, right?
15:49:14 * ski . o O ( "Someone please think of the `..'s !" )
15:49:16 <copumpkin> > [0,2%7..1]
15:49:17 <lambdabot>   [0 % 1,2 % 7,4 % 7,6 % 7,8 % 7]
15:49:35 <benmachine> what copumpkin highlights here is completely perverse
15:49:37 <benmachine> btyg :P
15:49:38 <c_wraith> > [1, 3 .. 6]
15:49:38 <lambdabot>   [1,3,5]
15:49:50 <copumpkin> benmachine: just pointing out that c_wraith's behavior isn't Double/Float-specific
15:49:52 <copumpkin> :)
15:50:01 <c_wraith> still completely perverse
15:50:08 <tsou> heheh hadn't thought that rationals would be Enum too..
15:50:10 <c_wraith> I can't think of any reason you'd ever want that behavior
15:50:22 <mokus> > [1, 3 .. 6] :: [Float]
15:50:23 <lambdabot>   [1.0,3.0,5.0,7.0]
15:50:24 <byorgey> tsou: just a bad decision made by the committee designing Haskell in the first place, and now we're stuck with it
15:50:26 <mauke> trolling programmers
15:50:27 <copumpkin> tsou: cause they're countable, duh
15:50:31 <byorgey> tsou: fortunately they made a lot of good decision too
15:50:52 <tsou> copumpkin: heh, still the implemented "enumeration" is not an enumeration of them :P
15:51:02 <copumpkin> tsou: yeah, that's annoying
15:51:13 <copumpkin> luckily I wrote a package to enumerate all of them and many other types (including functions)
15:51:22 <benmachine> that is lucky
15:51:27 <tsou> sheer luck
15:51:42 <copumpkin> you can also get an Ord instance for functions
15:51:53 <copumpkin> assuming the domain is enumerable and the codomain is in Eq
15:51:54 <byorgey> hehe, someone should make an Enum instance for Rational using the Gibbons-Lester-Bird "Enumerating the Rationals" algorithm =)
15:52:03 <copumpkin> *finitely enumerable
15:52:06 * ski hopes that package includes a `Compact' class
15:52:13 <byorgey> copumpkin: which package?
15:52:30 <copumpkin> ski: I think it does actually (possibly not on hackage yet), but I lost interest before writing any more
15:52:42 <copumpkin> byorgey: enumerable or something like that. 'twas my first package and I lost interest
15:52:59 <copumpkin> I'd also thrown a newtype in there so you could ask for enumerations with bottoms and without
15:53:11 <byorgey> http://hackage.haskell.org/package/enumerable
15:53:37 <byorgey> haha, Data.Enumerable.ControversialFunctionEquality
15:53:55 <copumpkin> yeah
15:54:01 <copumpkin> (+1) == (+2) give false
15:54:06 <copumpkin> just don't ask for (+1) == (+1)
15:54:25 <copumpkin> I don't think I have the Ord instances in there either
15:54:42 <c_wraith> does ControversialFunctionEquality ever return true?
15:54:45 <copumpkin> no
15:54:50 <c_wraith> that's what I thought
15:54:53 <ski> copumpkin : do you have `Eq' on `(Nat -> Bool) -> Bool' (e.g.) ?
15:54:53 <copumpkin> that's why it's controversial
15:54:57 <byorgey> enumerate = nub . map (uncurry (%)) . filter ((/=0) . snd) $ enumerate   -- what a terrible way to enumerate rationals =)
15:54:59 <mauke> _ == _ = False -- optimized
15:55:00 <copumpkin> ski: nope, I don't think so
15:55:05 <copumpkin> byorgey: yeah! :P
15:55:09 <Saizan> for finite domains?
15:55:16 <copumpkin> for finite domains it'll return true, sure
15:55:18 <ski> copumpkin : using that, it could return `True'
15:55:20 <copumpkin> I think they might just win the prize for the least efficient Ord instance ever
15:55:29 <djahandarie> Packages should use the newtype package more ;p
15:55:40 <copumpkin> it didn't exist in 2009
15:56:10 <djahandarie> I didn't even know what a monad was in 2009 :(
15:56:11 <copumpkin> byorgey: don't be hatin'! I was young and impressionable!
15:56:16 <copumpkin> poor djahandarie
15:56:33 <djahandarie> If only my parents knew about monads
15:56:47 <merijn> djahandarie: I know how you feel :p
15:58:08 <benmachine> c_wraith: it does for finite types
15:58:15 <byorgey> > let next r = (let (n,y) = properFraction r in recip (fromInteger n + 1 - y)) in iterate next 1
15:58:16 <lambdabot>   [1.0,0.5,2.0,0.3333333333333333,1.4999999999999998,0.6666666666666665,2.999...
15:58:24 <byorgey> > let next r = (let (n,y) = properFraction r in recip (fromInteger n + 1 - y)) in iterate next 1 :: [Rational]
15:58:25 <benmachine> oh wait
15:58:25 <lambdabot>   [1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 % 5,5 ...
15:58:27 <benmachine> someone said that
15:58:42 <c_wraith> benmachine: speaking of which, Float and Double should be instances of Bounded
15:58:55 <benmachine> c_wraith: maxBound is infinity?
15:59:17 <c_wraith> sure, why not.  it's a value in the type
15:59:46 <copumpkin> byorgey: that's even cuter than Cale's usual secret sauce
16:00:06 <copumpkin> I guess it's the same thing
16:00:14 <copumpkin> > let xs = 1 : concat [ [x+1, 1/(x+1)] | x <- xs] in xs :: [Rational]
16:00:15 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
16:00:17 <benmachine> hmm
16:00:27 <benmachine> > (1/0) >= (0/0)
16:00:27 <copumpkin> it's just a different approach to writing it
16:00:27 <lambdabot>   False
16:00:37 <benmachine> c_wraith: that doesn't sound very maxboundy :P
16:01:02 <c_wraith> Int64 has a maxbound.
16:01:05 <ski> > fix $ \xs -> return 1 `mplus` do x <- xs; [x+1, 1/(x+1)] :: [Rational]
16:01:06 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
16:01:09 <byorgey> copumpkin: that's a direct construction of the Calkin-Wilf tree.  Gibbons, Lester, & Bird show how to derive the version I give in their paper.
16:01:21 <copumpkin> ah, okay
16:01:45 <ski> (that's an interesting example of "left-recursion", btw)
16:01:47 <byorgey> copumpkin: the version I gave is much more memory-efficient
16:01:50 <c_wraith> and Int64's maxbound takes longer to iterate to than Float's...  assuming you are iterating in a way that always makes progress.  (+1 won't always make progress)
16:01:53 <copumpkin> byorgey: ooh
16:02:08 <copumpkin> byorgey: feel free to spruce up enumerable if you want :)
16:02:53 <byorgey> copumpkin: it only needs to maintain a single Rational as state, whereas the CW-tree version needs to keep around a list half as long as what it's generated so far
16:03:03 <byorgey> copumpkin: hehe, I might =)
16:03:05 <copumpkin> clever
16:03:08 <byorgey> copumpkin: is there a repo somewhere?
16:03:43 <copumpkin> hmm, I think it's on my other computer
16:03:46 <copumpkin> I'll have to dig it up
16:04:35 <benmachine> c_wraith: what's your point? I was arguing infinity wasn't a maxbound because, well, really because Float isn't totally ordered
16:05:03 <benmachine> the canonical ordering on it is a mathematical structure known as a "bloody stupid" order
16:05:09 <c_wraith> it's mostly-ordered, if you ignore NaN :)
16:05:38 <mokus> as well you should ;)
16:06:03 <benmachine> heh
16:07:57 <DukeDave> I don't suppose there is anyone around who's like to spare a minute to test my work on wxhaskell?
16:08:47 <DukeDave> You get to be a part of the thrill of *open source*
16:09:22 <Axman6> OOOOOOOOPPPPPEEEEENNNNN SSSOOOOUUURRRCCCCEEEEE!
16:09:22 <alistra> Z҉A҉L҉G҉O̚̕̚, he's coming
16:10:52 <DukeDave> Axman6: Shhh, don't let Apple here you :O
16:11:06 <Axman6> Apple love open source :\
16:11:06 <DukeDave> Erm, or "hear" you :|
16:11:35 <Axman6> WebKit, LLVM, launchd.. plenty of other stuff
16:11:51 <dxq> opensource.apple.com
16:11:54 <dxq> macosforge.com
16:12:00 <DukeDave> Ah, yes,
16:12:22 <DukeDave> I retract my previous statement.
16:12:55 <Axman6> good, or we're taking back all the webkit and LLVM based stuff you use, including GHC (even if you don't use -fllvm!)
16:14:23 <DukeDave> Erm, deal!
16:17:54 <ski> i suppose being able to express time-dependent values (a bit like in dataflow programming languages like Lucid, or perhaps more like Functional Reactive Programming -- or maybe just adaptive/incremental computation) would help, here
16:17:59 <ski> ECHAN
16:19:12 <tsou> 0 has type Num a => a.  read "True" has type Read a => a.  However on ghci a simple 0 is "by default" Integer, while read "True" by itself is erroneous
16:19:26 <tsou> how can i define a "default" type like Integer for a typeclass?
16:20:54 <monochrom> cannot
16:21:07 <c_wraith> you can't..  There are the few built-in ones, but only for classes with polymorphic literals
16:21:17 <tsou> aha..
16:21:44 <tsou> which means that the "built-in" ones are not defined in haskell itself, right?
16:21:47 <tsou> *the = those
16:23:03 <c_wraith> they actually are all defined in haskell
16:23:16 <c_wraith> at least, the classes are
16:23:24 <c_wraith> the part that's built-in is the defaulting rules
16:23:57 <tsou> ah, ok
16:24:04 <tsou> thanks :)
16:31:22 <mm_freak_>     My brain just exploded
16:31:22 <mm_freak_>     I can't handle pattern bindings for existential or GADT data constructors.
16:31:23 <mm_freak_> lol
16:31:29 <mm_freak_> never seen that one before
16:31:42 <Axman6> GHC error?
16:31:55 <mm_freak_> yeah
16:32:01 <Axman6> heh, nice
16:32:02 <hpaste> cl1 pasted “Data.Map Functor first attempt at implementation” at http://hpaste.org/55285
16:32:03 <Axman6> @ghc
16:32:04 <lambdabot> ghc says: Ambiguous constraint
16:32:07 <Axman6> @ghc
16:32:07 <lambdabot> ghc says: Only unit numeric type pattern is valid
16:32:14 <cl1> does that look correct?
16:33:41 <Axman6> cl1: sure, but it would likely be more efficient if you cad direct access to the map constructors, so you could just traverse the map and create a new one with the same shape. this one will rebalance the whole tree at each insert i think
16:33:50 <Axman6> had*
16:35:15 <Axman6> I'd ptobably use fromlist . map f . toList
16:35:21 <cl1> Axman6, thanks for the info, i'm just worried about correctness to ensure that I understand type classes
16:38:35 <hpaste> James pasted “Deduction system for the natural logica propositional” at http://hpaste.org/55286
16:41:21 <hpaste> Patinho`Busy pasted “sum of elements from tuples, lists, [newbie problem]” at http://hpaste.org/55287
16:41:32 <Patinho`Busy> help pls... anyone?  :)
16:42:28 <aavogt> > let xxs = [ ("a","a",[(1,"a","b"),(2,"a","b")]),("b","b",[(3,"a","b"),(4,"a","b")])] in sum (listify xxs) :: Integer
16:42:29 <lambdabot>   Couldn't match expected type `r -> GHC.Bool.Bool'
16:42:29 <lambdabot>         against inferred ...
16:42:34 <aavogt> :(
16:42:53 <Axman6> :t listify
16:42:54 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
16:43:03 <aavogt> > let xxs = [ ("a","a",[(1,"a","b"),(2,"a","b")]),("b","b",[(3,"a","b"),(4,"a","b")])] in sum (listify (const True) xxs) :: Integer
16:43:04 <lambdabot>   10
16:43:09 <Axman6> ha
16:43:14 <Axman6> that's pretty awesome
16:43:26 <Patinho`Busy> :O
16:43:38 <Axman6> Patinho`Busy: don't use that though...
16:43:46 <aavogt> yes it's inefficient
16:44:05 <aavogt> you can do it without the intermediate list
16:44:13 <Patinho`Busy> how?
16:44:31 <Axman6> > let xxs = [ ("a","a",[(1,"a","b"),(2,"a","b")]),("b","b",[(3,"a","b"),(4,"a","b")])] in sum [x | (_,_,ys) <- xs, (x,_,_) <- ys]
16:44:32 <lambdabot>   Not in scope: `xs'
16:44:37 <Axman6> > let xxs = [ ("a","a",[(1,"a","b"),(2,"a","b")]),("b","b",[(3,"a","b"),(4,"a","b")])] in sum [x | (_,_,ys) <- xss, (x,_,_) <- ys]
16:44:38 <lambdabot>   Not in scope: `xss'
16:44:44 <Axman6> > let xxs = [ ("a","a",[(1,"a","b"),(2,"a","b")]),("b","b",[(3,"a","b"),(4,"a","b")])] in sum [x | (_,_,ys) <- xxs, (x,_,_) <- ys]
16:44:45 <lambdabot>   10
16:44:48 <Patinho`Busy> aavogt ... this is a length 2 list... my real list is lenght n ++
16:45:56 <ski> Patinho`Busy : after you've computed `fob', you should process it more, to omit the `b',`c' parts from each element of shape `(a,b,c)' (here `a' is the number part)
16:46:39 <Axman6> 'for each 3-tuple in xxs, pull out the list in the third position, and name it ys, then for each 3-tuple in ys, pull out the number and name it x, and sum all x values'
16:46:50 <ski> Patinho`Busy : so you need something like `aux2' to get rid of the initial garbage, then you need something similar to get rid of the rest of the garbage
16:47:10 <Patinho`Busy> hum...
16:47:33 <hpaste> James pasted “Deduction system for the natural logica propositional” at http://hpaste.org/55288
16:48:41 <Patinho`Busy> thanks for the help.
16:49:03 <aavogt> > let xxs = [ ("a","a",[(1,"a","b"),(2,"a","b")]),("b","b",[(3,"a","b"),(4,"a","b")])] in  everything (+) (mkQ 0 id) xxs :: Integer
16:49:04 <lambdabot>   10
16:49:37 <Patinho`Busy> aavogt ... you are having fun with my assignment
16:49:39 <Patinho`Busy> :|
16:49:40 <Patinho`Busy> XD
16:49:41 <Patinho`Busy> lol
16:49:47 <aavogt> well maybe that's less efficient... not sure whether it's better to add 0 or whatever listify does
16:53:06 <Axman6> :t forever
16:53:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
16:53:23 <Axman6> > forever (Just 1)
16:53:27 <lambdabot>   mueval-core: Time limit exceeded
16:54:13 <djahandarie> :t forever (Just 1) :: Maybe String
16:54:14 <lambdabot> Maybe String
17:11:57 <hpc> :t forever const
17:11:58 <lambdabot> forall a b. a -> b
17:18:08 <patrick1> :t forever forever
17:18:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> b
17:18:17 <Patinho`Busy> I could achieve it a simple comprehension list!! damn, I'm a n00b :/
17:18:41 <ski> @let subst :: Monad m => (var -> m var) -> (m var -> m void); subst env expr = do var <- expr; subst env (env var)
17:18:42 <lambdabot>  <local>:9:90:
17:18:42 <lambdabot>      Ambiguous occurrence `subst'
17:18:42 <lambdabot>      It could refer to eithe...
17:19:26 <ski> @type subst
17:19:26 <lambdabot> forall a. (Num a) => String -> Sym a -> Sym a -> Sym a
17:19:34 <ski> bah, useless
17:19:38 <ski> Patinho`Busy : nice :)
17:19:52 <Patinho`Busy> xD
17:20:01 <ski> @let substitute :: Monad m => (var -> m var) -> (m var -> m void); substitute env expr = do var <- expr; substitute env (env var)
17:20:02 <lambdabot>  Defined.
17:20:09 <ski> > substitute (const Nothing) (Just 1)
17:20:11 <lambdabot>   Nothing
17:22:24 <copumpkin> does lambdabot have any monds that would actually do something interesting with that?
17:22:27 <copumpkin> :k Tree
17:22:28 <lambdabot> * -> *
17:22:32 <copumpkin> hm, okay
17:22:36 <copumpkin> :t Bin
17:22:37 <lambdabot> Not in scope: data constructor `Bin'
17:22:40 <copumpkin> :t Node
17:22:41 <lambdabot> forall a. a -> Forest a -> Tree a
17:22:45 <copumpkin> aha
17:24:23 <augur> copumpkin: it'd be nice if lambabot let you look up the definitions of data types
17:24:50 <copumpkin> yeah, I agree
17:24:57 <copumpkin> well, @src is just a textual lookup
17:25:00 <copumpkin> so it's not impossible
17:25:06 <augur> @src Tree
17:25:09 <lambdabot> Source not found. My mind is going. I can feel it.
17:25:33 <augur> who runs lambdabot again? cale?
17:26:27 <Cale> I run it, lispy has the hosting that it's on
17:26:38 <augur> o
17:26:41 <augur> well whoever
17:29:35 <fryguybob> @pl let go g (f:fs) = go g fs >>= blah f in go
17:29:35 <lambdabot> fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip blah . (((.) . flip . ((>>=) .)) .))
17:30:05 <ski>   data Tree a = Node {rootLabel :: a,subForest :: Forest a}
17:30:06 <ski>   type Forest a = [Tree a]
17:30:08 <ski> augur ^
17:30:23 <augur> ski: well yes i know that
17:30:26 <augur> thats not the point :P
17:30:37 <ski> oh, ok
17:31:05 <augur> the point was more that it'd be convenient if lambdabot could give that so that copumpkin wouldtve had to guess
17:43:05 <dylukes> ski: default haskell tree is a rose tree?
17:44:06 * ski is not sure he'd call it "default haskell tree"
17:44:53 <byorgey> the type defined in Data.Tree is a rose tree.
17:45:33 <aavogt> it's not in the standard, right?
17:45:57 <byorgey> no
17:46:05 <byorgey> I mean, right, it isn't
18:00:19 <tgeeky> CORRECT! Tell him what he's won.
18:01:00 * tgeeky wonders out loud if there are any "relations" packages in haskell?
18:01:25 <tgeeky> is the best way to do this the way partial-isomorphism does?
18:06:18 <tgeeky> from: http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf -- "Functional programmers appear to regard relations as an arcane creation, which is an unfortunate misunderstanding. Dijkstra argued that, for program derivation, non-determinism should be the norm and determinism a special case...
18:06:28 <tgeeky> Really? Is that why?
18:07:06 <Axman6> isn't that what we use lists for?
18:07:07 <xplat> well, fortunately we have prolog for that
18:07:26 <tgeeky> Axman6: I use lists for groceries.
18:07:34 <Axman6> that too
18:07:46 <tgeeky> Seriously, though, this paper is about folding/unfolding
18:07:48 <xplat> i use prolog for groceries
18:07:59 <cheater> tgeeky: all IO is non-deterministic
18:08:01 <tgeeky> you poor thing
18:08:12 <tgeeky> cheater: yes, this isn't IO
18:08:12 <xplat> :- buy([bread, milk, eggs]).
18:08:16 <xplat> No.
18:09:19 <tgeeky> "In this pearl, we view folds as the relational converse of unfolds, and an unhom is a relation converse of a list homomorphism
18:09:22 <tgeeky> '
18:25:47 <ski> tgeeky : the book "The Algebra of Programming" (which uses lots of point-less^free notation) by Richard Bird and Oege de Moor, uses relations to derive functional programs
18:26:57 <tgeeky> ski: ok. thanks for the reference.
18:27:33 <ski> (and the book is quite fun)
18:30:58 <ski> tgeeky : you might also have seen notation with brackets like `[( ... )]',`(| ... |)' for various folds, unfolds, &c.
18:31:40 <ski> tgeeky : that notation, called Squiggol, was developed by Richard Bird and Lambert Meertens, and is used in that book
18:31:51 <ski> @google bananas lenses barbed wire
18:32:05 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
18:32:05 <lambdabot> Title: CiteSeerX — Functional Programming with Bananas, Lenses, Envelopes and Barbed  ...
18:32:25 <ski> also see that paper, if you haven't
18:35:18 <ski> @google bananas in space type
18:35:19 <lambdabot> http://www.cs.nott.ac.uk/~gmh/bananas.ps
18:35:24 <ski> also that paper
19:13:54 <shapr> @yow !
19:13:55 <lambdabot> Couldn't find fortune file
19:14:01 <shapr> That's what they all say :-(
19:18:03 <ski> Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!
19:23:09 <shapr> ski: exactly!
19:27:05 * ski hugs shapr
19:27:23 <Axman6> @unmtl ErrorT e m a
19:27:23 <lambdabot> m (Either e a)
19:27:37 <Axman6> @unmtl ErrorT ErrorCode IO a
19:27:37 <lambdabot> IO (Either ErrorCode a)
19:27:48 * shapr hugs ski
19:27:52 <shapr> ski: How's code?
19:28:12 * ski is attempting to hack some on MetaML
19:28:12 <Axman6> :t maybe Left (const (Right ())
19:28:13 <lambdabot> parse error (possibly incorrect indentation)
19:28:17 <Axman6> :t maybe Left (const (Right ()))
19:28:18 <lambdabot>     Couldn't match expected type `a -> Either a b'
19:28:18 <lambdabot>            against inferred type `Either a1 ()'
19:28:18 <lambdabot>     In the second argument of `maybe', namely `(const (Right ()))'
19:28:29 <Axman6> :t maube
19:28:30 <lambdabot> Not in scope: `maube'
19:28:31 <Axman6> :t maybe
19:28:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:29:16 <ski> (specifically, i'm atm trying to convince it that local type variables can have kinds other than `*' ..)
19:29:16 <Axman6> :t maybe (Right ())
19:29:17 <lambdabot> forall a a1. (a1 -> Either a ()) -> Maybe a1 -> Either a ()
19:29:27 <Axman6> :t maybe (Right ()) Left
19:29:28 <lambdabot> forall a. Maybe a -> Either a ()
19:29:40 <Axman6> hmm, that's just what i wanted...
19:29:57 <Axman6> looks like ErrorT would be quite useful for working with OpenCLRaw
19:30:11 <ski> @unmtl ErrorT [Integer] (State Bool) a
19:30:12 <lambdabot> Bool -> (Either [Integer] a, Bool)
19:31:01 <Axman6> also, need maor info on this: http://developer.amd.com/zones/OpenCLZone/publications/assets/MakingOpenCLSimplewithHaskell.pdf
19:32:52 <Axman6> hmmmmmmmmm, could you implement a monad that would implement something like the defer keyword in Go? so, you say defer <some computation> and it's run when you leave the scope (ie, allocate something, then defer the deallocation, and it's guaranteed to be run at the end of the current function, before the function returns)
19:34:17 <Axman6> i think you quite easily could... I'll have to look into this
19:35:12 <Axman6> trying to come up with a nice interface to using OpenCL in Haskell, that you could use in a way that makes handling resources mugh easier
19:36:28 <Axman6> much even
19:37:49 <abiii> what's the best HTML parsing library for Haskell?
19:37:59 <ski> Axman6 : you'd probably need an explicit combinator for establishing a "scope" (rather an extent here, i think)
19:38:05 <Axman6> regluar expressions!
19:38:07 <Axman6> >_>
19:38:15 <Axman6> ski: yeah, i was thinking that
19:38:17 <ski> @slap Axman6
19:38:17 * lambdabot secretly deletes Axman6's source code
19:38:21 <patrick1> :O
19:38:21 <Axman6> D:
19:38:39 <Axman6> @quote regular
19:38:39 <lambdabot> ddarius says: When a programmer has a problem and says "I'll use regular expressions," they have two problems.  When the programmer says "I'll use Haskell," they have a lifetime of problems.
19:38:48 <Axman6> @quote regular
19:38:48 <lambdabot> Wadler says: "You know how they say that when you have a problem and you decide to use regular expressions to solve it, you now have two problems? Well, Haskell is the opposite in that regard. You
19:38:49 <lambdabot> start out with a problem, then you go through a lot of trouble to actually learn the language and then you no longer have the problem in the first place because you have lost interest in programming.
19:38:49 <lambdabot> " - by Ph
19:39:11 <Axman6> haha
19:40:01 <abiii> LOL
19:40:03 <abiii> just great
19:40:13 <abiii> now, what's the best HTML parsing library for HTML?
19:41:26 <patrick1> maybe xmlhtml
19:44:59 <jmcarthur> Axman6: is this defer thing any different from, say, bracket?
19:45:01 <jmcarthur> :t bracket
19:45:02 <lambdabot> Not in scope: `bracket'
19:45:09 <jmcarthur> :t Control.Exception.bracket
19:45:10 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:45:15 <Axman6> jmcarthur: hmm, probably not, now i think of it
19:45:30 <Axman6> though, it does let you write code that's a bit more flat
19:45:42 <confab> oh man, that quote from wadler is rich
19:45:50 <jmcarthur> so use bracket with Cont, i guess
19:46:08 <Axman6> so do x <- foo; defer (release x); y <- bar; defer (release y) ...
19:46:19 <Axman6> but, that's not too different to bracket at all i guess
19:46:29 <Axman6> hmm, I have no idea how you'd use bracket with Cont
19:46:50 <jmcarthur> code would look like this if you made a bracket for ContT IO:    do x <- bracket foo release; y <- bracket bar release
19:47:12 <jmcarthur> @unmtl ContT IO a
19:47:12 <lambdabot> Plugin `unmtl' failed with: `ContT IO a' is not applied to enough arguments, giving `/\A. (A -> a IO) -> a IO'
19:47:23 <jmcarthur> oops
19:47:37 <jmcarthur> meh, i'll just say Cont
19:48:15 <jmcarthur> :t \f g -> Cont $ bracket f g
19:48:15 <lambdabot> Not in scope: data constructor `Cont'
19:48:16 <lambdabot> Not in scope: `bracket'
19:48:22 <jmcarthur> grr
19:49:05 <jmcarthur> \f g -> ContT $ bracket f g :: IO a -> (a -> IO b) -> ContT r IO a
19:49:45 <jmcarthur> i guess you'd really want it to be more like ContT r IO a -> (a -> ContT r IO b) -> ContT r IO b... might be harder
19:49:59 <augur> anyone know of any literature on answering the question "when is a problem necessarily a minimization/maximization problem"?
19:50:22 <jmcarthur> come to think of it, i think bracket is one of those functions that is hard to lift into Cont, but this may be a different lifting than that
19:51:17 <cmasseraf> augur: That's a very broad question to be anwsered directly
19:51:27 <augur> cmasseraf: :)
19:51:33 <augur> im well aware!
19:52:46 <augur> im not looking for anything specific, or definitive, just something in that general direction
19:52:54 <cmasseraf> augur: but it's basically when you want to find the best possible values for a set of paremeter and can model a "quality" or fitness function given these parameters
19:53:05 <augur> well sure, but i mean
19:53:16 <augur> lots of things can be phrased as minimization problems
19:53:25 <augur> without having to be minimization problems
19:53:45 <cmasseraf> yes
19:53:57 <cmasseraf> many things can be adapted to fit these terms
19:54:25 <augur> for instance, heres a dumb example: the set a^n b^n can be phrased as   min n { (a*b*, n) : n = |len a's - len b's| }
19:55:34 <augur> but testing if aaabbb is in a^n b^n doesnt have to be done by searching the set a*b* for whether it minimizes the length difference
19:56:23 <augur> so im curious if theres any general sense about when something _must_ be done via minimization
19:56:31 <augur> even if its for a subclass of problems, i dont care
19:57:02 <cmasseraf> i agree, and you will find many places where you can state the problem as a minimization, and there's no rule to what problems can or can't
19:57:04 <cmasseraf> well
19:58:20 <cmasseraf> you can thing of some things like the MLP (neural network) example
19:59:34 <augur> actually im more interest in knowing when i can avoid minimization :)
20:00:00 <cmasseraf> it's algorithm is defined as a minimization problem... and there's no way around it because the final objective is that the NN predicts your data (so minimizes the error). In this case minimization is the result, not the middle
20:00:02 <cmasseraf> so
20:00:20 <cmasseraf> MAYBE, you can avoid it when the objective is not to minimize something
20:00:25 <cmasseraf> but this is my guts talking
20:00:46 <cmasseraf> (that's why the big maybe)
20:02:43 <cmasseraf> I am going to bed now.. it's 2:30 am here! I hope I helped at least a little :) good night everyone!
20:08:49 <Axman6> @unmtl ContT r IO a
20:08:49 <lambdabot> (a -> IO r) -> IO r
20:09:31 <Axman6> :t runContT
20:09:32 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
20:38:20 <deech> Hi all, is anyone using continous Haskell compilation in their text editor and if so what mode?
20:38:51 <mzero> I generally have it turned on in Leksah
20:39:37 <deech> mzero: And it's responsive for large packages?
20:39:43 <mzero> no
20:40:03 <mzero> for packages of about ~10 source files, it is resonable
20:57:45 <Patinho`Busy> !nn all. :w
21:00:06 <Guest61932> i know (.) is part of the Category type class, is ($) part of any type class?
21:02:27 <copumpkin> no
21:02:59 <copumpkin> something roughly similar is ArrowApply
21:03:15 <copumpkin> one of the categories packages might have an Exponential class
21:03:34 <copumpkin> jmcarthur had a Mapping class we played with for a while, but I don't think it ever made it into a package
21:19:51 <Guest61932> copumpkin, k, thanks
21:30:48 <conal> anyone happen to know where the Monoid o => Monad ((,) o) instance is defined (i.e., what to import)?
21:36:48 <shachaf> conal: There's Control.Monad.Writer with a newtype.
21:37:05 <shachaf> I don't think the instance directly on (,) is defined anywhere in the standard library.
21:37:25 <conal> shachaf: i guess not. i want the unadorned pair. thx.
21:37:38 <conal> strange that it's not in Control.Monad.Instances.
21:38:10 <conal> which has functor + monad for -> and for +, but only functor for *
21:38:15 <conal> oh well.
21:39:02 <shachaf> Writer also seems to have the order reversed.
21:39:04 <shachaf> @ty runWriter
21:39:05 <lambdabot> forall w a. Writer w a -> (a, w)
21:39:31 <conal> shachaf: yeah. lame :(
21:39:40 * ski str it was in `Control.Monad.Writer', previously
21:40:02 <conal> time to sleep.  later, haskell friends.
21:40:23 <ski> `Functor (o,)' is in `Data.Functor', btw -- and `Monad (rho ->)' is in `Data.Either'
21:40:53 <ski> possibly `Monad (o,)' should be in `Data.Tuple' ?
21:41:23 <shachaf> ski: Data.Either?
21:41:37 <ski> <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Either.html>
21:41:56 <ski> er, sorry, i misstated
21:42:09 <ski> i meant that `Monad (Either e)' is in `Data.Either''
21:42:13 <ski> (i'm tired)
21:42:15 <shachaf> Ah. That makes more sense. :-)
21:42:20 <ski> (:
21:42:24 <shachaf> Monad (r ->) is in Control.Monad.Instances, I think.
21:42:56 <ski> yeah
21:58:02 <copumpkin> not for long
22:02:48 <mzero> where is it moving
22:02:56 <mzero> or did you mean *you* were not for long?
22:03:41 <shachaf> Maybe there's a different instance for Monad (CLong ->)
22:04:07 <copumpkin> mzero: a recent proposal for killing Control.Monad.Instances altogether
22:04:17 <copumpkin> since it's just a bunch of orphan instances and there's no point to separating them
22:04:31 <copumpkin> (also, sorry I still haven't replied to your email! :( I'll get to it this weekend!)
22:05:08 <Sgeo> :t maybe
22:05:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:05:29 <mzero> no problem on the e-mail - we've got like a whole quarter for that
22:05:38 <copumpkin> :D
22:06:11 * shachaf approves of killing C.M.I.
22:06:28 <mzero> maybe was the the first thing I fell in love with about Haskell..... so simple, yet so clear, expressive, and right.
22:06:31 <copumpkin> mm_freak: thanks for your answer on stackoverflow! it took some minor adaptation (I need to check for EOF since reading doesn't actually throw exceptions)
22:49:57 <copumpkin> preflex: seen sclv
22:49:58 <preflex>  sclv was last seen on #haskell 185 days, 9 hours, 48 minutes and 30 seconds ago, saying: that goes for any type, not just function types
23:21:15 <hpaste> icee pasted “haskell function” at http://hpaste.org/55290
23:21:21 <augur> beep
23:25:31 <mauke> :t take 1 .: filter . elem
23:25:31 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [[a]]
23:25:45 <saati> what is .:
23:25:55 <mauke> (.)(.)(.)
23:26:15 <saati> 3 breasts?
23:26:41 <mauke> :t fromMaybe mempty .: find . elem
23:26:42 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [a]
23:27:31 <icee> hi all, how do you write a function that take a value x and a list of list, find the 1st list that x is a member and return that list, if no match, then return empty list?  The function can have signature such as matchFirst :: Eq a => a -> [[a]] -> [a]
23:27:44 <mauke> where are you stuck?
23:28:22 <icee> matchFirst x list = ???
23:28:23 <Axman6> icee: what do you have so far?
23:28:34 <Axman6> :t elem
23:28:34 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:28:40 <mauke> icee: proceed by structural recursion
23:28:41 <Axman6> > elem 1 [1..10]
23:28:42 <lambdabot>   True
23:28:47 <Axman6> > elem 11 [1..10]
23:28:48 <lambdabot>   False
23:29:31 <geheimdienst> > 7 `elem` [1..10] -- elem is also often used with backticks like this. might be more intuitive
23:29:31 <lambdabot>   True
23:30:30 <saati> where is .: defined?
23:30:47 <mauke> lambdabot
23:31:22 <geheimdienst> saati: it's not in the standard library. afaik they are considering including it
23:31:51 <saati> > (fromMaybe mempty .: find . elem) 1 [[1],[2]]
23:31:52 <lambdabot>   [1]
23:32:02 <salisbury> not sure if 7 `elem` [1..10] == True  or lambdabot thinks backticks are more intuitive
23:32:43 <saati> how do you come up with such magic
23:33:12 <mauke> you write it manually, then you @pl it
23:33:30 <icee> still stuck, i got the pseudocode but don't know how to write it in haskell
23:33:35 <icee> so
23:33:48 <icee> matchFirst x null = []
23:33:59 <saati> icee: wtf is null
23:34:08 <icee> dam
23:34:14 <icee> i mean if the list is null
23:34:20 <DanBurton> > null []
23:34:21 <lambdabot>   True
23:34:25 <saati> thats mF x [] = []
23:34:25 <icee> matchFirst x [] = []
23:34:34 <icee> ok
23:34:37 <icee> next
23:34:56 <DanBurton> null in Haskell is a function
23:35:01 <icee> mF x list = if x is element of list.head
23:35:05 <icee> return head
23:35:19 <mauke> icee: don't write list.head
23:35:19 <icee> else mf (x, list.tail)
23:35:21 <saati> icee: do you know how to do pattern match for that?
23:35:22 <mauke> use pattern matching instead
23:35:26 <icee> no
23:35:35 <icee> can you show me?
23:35:40 <DanBurton> sometimes I wish Haskell had the scheme/racket convention of adding ? to the end of predicates. Then it would be "null?"
23:35:42 <mauke> ok, this is homework and you're lacking the basics
23:35:50 <saati> matchFirst x (y:ys)
23:35:53 <mauke> icee: have you tried a haskell tutorial?
23:35:59 <icee> yeah
23:36:02 <saati> mauke: he will fail the exam anyway
23:36:04 <icee> didn't quite get it
23:36:15 <mauke> oh well
23:36:20 <Axman6> what don't you get
23:36:34 <geheimdienst> saati: could you please concentrate on discussing haskell in here, thank you
23:36:55 <icee> how do you write if in haskell?
23:37:07 <saati> icee: with if or with guards
23:37:22 <Axman6> if <boolean expression> then <true statement> else <false statement>
23:37:29 <mauke> s/statement/expression/g
23:37:35 <Axman6> > if 1 == 1 then "Hello" else "Bye"
23:37:36 <lambdabot>   "Hello"
23:37:39 <geheimdienst> icee, there is an 'if' in haskell, but more often you use pattern matching where in another language you'd use if
23:37:43 <Axman6> > if 1 == 2 then "Hello" else "Bye"
23:37:44 <lambdabot>   "Bye"
23:37:46 <mauke> icee: I recommend avoiding 'if' and using 'case' instead
23:37:58 <Axman6> case? not guards?
23:38:15 * DanBurton prefers case over if, even for bools.
23:38:16 <int-e> case <boolean expression> of True -> ...true...; False -> ...false...?
23:38:20 <icee> mf x (y:ys) = if (elem x [y]) then return y
23:38:38 <icee> else then mf (x, ys)
23:38:45 <icee> does that look right?
23:38:51 <int-e> or case () of _ | condition -> blah; | othewise ->  blubb? (mauke)
23:39:01 <geheimdienst> icee: it's not quite right yet, but we're getting somewhere
23:39:18 <mauke> icee: no, you've got a "return" in there
23:39:27 <mauke> icee: [y] should be y
23:39:34 <mauke> icee: "else then" is a syntax error
23:39:36 <geheimdienst> first, in haskell, you apply functions by saying "f 1 2". in another language that might be "f(1,2)"
23:41:51 <icee> ok , so
23:42:05 <icee> if (elem x[y]) then y
23:42:15 <icee> else mF x ys
23:42:24 <Axman6> icee: have you paid any attention in lectures? :\
23:42:39 <icee> lol
23:42:51 <icee> the professor was a bit diff. to understand
23:42:52 <saati> icee: x[y] is a syntax error, and y is a list anyway
23:43:04 <mauke> x[y] is not a syntax error
23:43:06 <geheimdienst> icee: that's one step better already. one issue left is "elem x[y]". what does y contain?
23:43:08 <Axman6> > elem 1[1,2,3]
23:43:09 <lambdabot>   True
23:43:16 <saati> wow
23:43:19 <icee> head of list
23:43:27 <DanBurton> it's a type error, assuming y is a list, and x is not.
23:43:35 <saati> icee: yes it's a head of a list of lists
23:43:40 <saati> so it's a list in itself
23:43:46 <icee> yeah
23:44:04 <saati> if you wrap it in [] the only member is y
23:44:13 <geheimdienst> icee: right, y is the head of the list. so what is [y] ?
23:44:32 * hackagebot hfann 0.3 - Haskell binding to the FANN library  http://hackage.haskell.org/package/hfann-0.3 (DavidHimmelstrup)
23:44:55 <icee> so say list is [[2,3],[4,5],[1,2]] and x is 4
23:44:59 <saati> there is a special case in the tokenizer for [ ?
23:45:04 <icee> isn't y = [2,3]
23:45:26 <saati> icee: it is, but [y] is [[2,3]]
23:45:40 <icee> oh
23:45:45 <koeskoes_> what's the motivation of using case over ifs?
23:45:54 <DanBurton> @quickCheck let f1 = (==); f1 :: Int -> Int -> Bool; f2 x y = elem x [y]; f2 :: Int -> Int -> Bool in \x y -> f1 x y == f2 x y
23:45:54 <lambdabot> Unknown command, try @list
23:45:56 <opqdonut> ifs are ugly, case is great
23:45:58 <int-e> saati: which tokenizer?
23:46:00 <icee> so it should be if (elem x y)
23:46:03 <opqdonut> case gives you pattern matching
23:46:04 <DanBurton> @check let f1 = (==); f1 :: Int -> Int -> Bool; f2 x y = elem x [y]; f2 :: Int -> Int -> Bool in \x y -> f1 x y == f2 x y
23:46:04 <lambdabot>   Not in scope: `myquickcheck'Not in scope: type constructor or class `Int'No...
23:46:09 <DanBurton> boo
23:46:10 <opqdonut> if is just for bools
23:46:12 <saati> int-e: the ghc one, that tokenizes haskell code
23:46:21 <int-e> > [ ]
23:46:22 <lambdabot>   []
23:46:41 <int-e> saati: I don't think so, it's a single character token just like th eother parentheses.
23:47:37 <saati> > (+) 1(1)
23:47:38 <lambdabot>   2
23:47:44 <DanBurton> is something wrong with lambdabot's quickcheck?
23:47:48 <ski> > let x = null; y = 2 in  x[y]
23:47:49 <lambdabot>   False
23:47:54 <DanBurton> @check \x -> x == x
23:47:54 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `=='Not in scope: `$'
23:47:57 <ski> @check False
23:47:58 <lambdabot>   Not in scope: `myquickcheck'Not in scope: data constructor `False'Not in sc...
23:48:08 <DanBurton> :(
23:48:11 <ski> seems so
23:48:32 <ski> Cale might (or might not) know what the problem is
23:48:49 <DanBurton> @tell Cale there seems to be something wrong with Lambdabot's quickCheck plugin
23:48:49 <lambdabot> Consider it noted.
23:48:51 * ski str it worked maybe one or two months ago
23:49:20 <yitz> preflex: seen Cale
23:49:20 <preflex>  Cale was last seen on #haskell 6 hours, 23 minutes and 2 seconds ago, saying: I run it, lispy has the hosting that it's on
23:49:32 <yitz> on topic
23:50:18 <DanBurton> anyways, << \x y -> elem x [y] >> is exactly the same as << \x y -> x == y >>
23:52:03 <mm_freak> copumpkin: oh, you're welcome =)
23:52:08 <DanBurton> @djinn a -> b -> (a,b)
23:52:09 <lambdabot> f a b = (a, b)
23:52:11 <mm_freak> didn't know it was you
23:52:14 <icee> thanks guys, works great
23:52:57 <geheimdienst> icee: you're welcome
23:53:21 <mm_freak> copumpkin: in case you haven't seen the additional note i added later, you have to find a way to close the handle at some point…  i'd go with a concurrent solution…  make a thread for reading and an MVar enumerator
23:53:35 <int-e> > elem (error "a") $ error "b"
23:53:36 <lambdabot>   *Exception: b
23:53:44 <int-e> > error "a" == error "b"
23:53:45 <lambdabot>   *Exception: a
23:53:57 <ski> those have the same denotation :)
23:54:12 <ski> (using imprecise exceptions semantics)
23:56:07 <int-e> ski: yeah but I could do the same with an Eq instance that violates the symmetry law.
23:56:29 <int-e> and there doesn't seem any absolute agreement on whether these should be allowed or not :)
