00:00:12 <wavewave> proge: definitely.. if you are doing text job much..
00:00:19 <wavewave> proge: try some parsing library.
00:00:29 <wavewave> proge: for example, parsec
00:00:39 <proge> i'm regex king :)
00:00:45 <wavewave> parsec itself can be a sole reason why you have to learn haskell.
00:01:07 <wavewave> parsec is completely different.
00:01:10 <proge> googling me some parsec
00:01:27 <wavewave> it's just following the definition of parsing.
00:02:08 <wavewave> in RWH, there is a chapter for parsec.
00:02:28 <wavewave> Chapter 16.
00:02:51 <wavewave> it clearly shows what's the benefit of declarative programming.
00:03:13 <jessopher> or atleast whats really good about high order functions
00:04:20 <proge> ok i'm excited :)
00:04:54 <proge> only because wavewave is lol
00:05:03 <proge> lets hope i can get it into my head
00:05:06 <wavewave> thanks ;-)
00:05:24 <wavewave> just come to visit #haskell any time you have a question.
00:05:38 <wavewave> the best of haskell is community, i think
00:06:26 <proge> yes thanks for the input jes
00:06:37 <proge> everyone was most polite
00:06:45 <jessopher> now get out!
00:06:47 <jessopher> jk
00:06:51 <proge> hehe
00:07:31 <proge> i'll try digest as much of this as i can
00:07:47 <proge> i'll be back
00:07:49 <proge> GG
00:11:11 <jessopher> the language im writing an interpreter for seems to beable to handle things like parser combinators pretty well, and it is only declarative in a naive sense. It has no static type system
00:15:39 <nomism> hello. i recently became interested in functional languages. my background is dsp, mostly done in matlab and c. do you think i could benefit from learning a language like haskell in this particular scenario?
00:16:05 <wavewave> nomism: definitely.
00:16:21 <wavewave> nomism: like functional reactive programming
00:16:59 <wavewave> or making some domain specific language
00:17:35 <wavewave> try to google yampa or haskell lava
00:17:46 <nomism> ok. my idea was, that i might be able to express the underlying mathematical algorithms in a way as compact as in matlab, but much cleaner due to the lack of side effects
00:17:54 <nomism> if i have the right understanding ...
00:18:41 <wavewave> controlling side effect is one of haskell's benefit, but not all the reason.
00:19:21 <wavewave> it's benefitted from a combination of controlling side effect, higher order function, strong type system etc.
00:19:53 <nomism> ok
00:19:56 <nomism> thanks!
00:20:02 <wavewave> some concepts like monad and arrow are very helpful.
00:24:17 <carpi> is it possible to pattern match in a let clause?
00:24:26 <wavewave> yes
00:24:42 <carpi> thx
00:57:36 <adimit> If I want a *fast* sha-1 in Haskell, I'm best off with the SHA2 package on hackage, no? the other SHA package doesn't seem to go for performance as much…
00:57:52 <adimit> (I care about performance because I'm going to be building billions of SHAs…)
01:12:28 <suped> I don't know if this is the right place for this, but I seem to have ghc 7.0.3 installed, but cabal tells me 6.10.4 is installed.
01:12:39 <suped> Of course I get all kinds of build errors.
01:12:48 <suped> Can someone maybe help me with this?
01:14:08 <carpi> i just realized you can maintain some semblance of state in a recursive function using let expression.. eureka )
01:14:51 <wobsite> suped: what OS are you running on?
01:15:02 <suped> OS X Lion.
01:15:48 <suped> I installed the haskell platform for OSX, and /Library/Frameworks/GHC.framework/Versions/7.0.3-i386/usr/bin
01:16:07 <wobsite> first time installing it?
01:17:10 <suped> You mean, in my life or on this computer? I did a fresh install of lion this summer with the platform after.
01:17:23 <wobsite> I meant on that machine.
01:17:38 <suped> I dont understand how I could have such an outdated version in cabal.
01:17:45 <suped> On this machine ive installed it once.
01:18:27 <wobsite> Did you copy over any files from a previous system? I'm kinda guessing here, but perhaps if your user directory got moved over it may have taken old stuff with it.
01:18:57 <suped> Nope, nothing. A clean install with no moving.
01:19:44 <_oz> suped: how does cabal tell you about ghc version?
01:19:48 <_oz> what command do you use
01:20:50 <suped> So when I so ghc -V anywhere it says version 6.10.4 (also in cabal), but ghc 7.0.3 is installed in the Library/Frameworks/GHC.framework/Versions/.
01:21:14 <suped> cabal info ghc also says 6.10.4
01:21:27 <wobsite> try : which ghc
01:21:51 <suped> which ghc says : /opt/local/bin/ghc
01:22:11 <_oz> ls -l `which ghc`
01:22:52 <suped> Also, cabal says Versions available: [ Not available from server ] in ghc info ghc, is that normal?
01:22:59 <_oz> suped: yes
01:23:22 <wobsite> do you have macports or something of that nature set up?
01:23:28 <suped> ls -l 'which ghc' gives -rwxr-xr-x  1 root  admin  142 Dec  2 16:30 /opt/local/bin/ghc
01:23:47 <suped> yeah,I use macports.
01:23:56 <_oz> wobsite: he probably does
01:24:02 <suped> Could that be the porblem?
01:24:20 <carpi> is it possible to pattern match with !!?
01:24:24 <wobsite> my guess is you've got a version of ghc installed from macports, and it's picking that up.
01:25:01 <_oz> try : /Library/Frameworks/GHC.framework/Versions/7.0.3-i386/usr/bin/ghc -V
01:25:08 <wobsite> macports usually puts things in /opt
01:25:38 <suped> It says The Glorious Glasgow Haskell Compilation System, version 7.0.3,_oz
01:25:53 <_oz> yay, you found it! :)
01:26:10 <wobsite> yeah, so that's what's happening: the version of ghc from macports is the one that's being found.
01:26:48 <wobsite> you probably want to put  /Library/Frameworks/GHC.framework/Versions/7.0.3-i386/usr/bin/ghc ahead of /opt/local/bin in your path.
01:27:05 <wobsite> or rather, /Library/Frameworks/GHC.framework/Versions/7.0.3-i386/usr/bin
01:27:06 <suped> thats ~/.profile?
01:27:06 <_oz> or remove the macports installed ghc?
01:27:23 <wobsite> you could also just remove the macports version of ghc, yeah.
01:27:40 <wobsite> which might be a cleaner way to do it.
01:27:47 <suped> Maybe Ill try to remove the ports version. I wont use that anyway.
01:27:49 <_oz> i'd just do that, macports is crap anyway :)
01:28:04 <suped> Thanks a lot. Ill try that and let you know how it went.
01:28:41 <suped> Is there a better package manager for OSX then ports? I used fink before but that was equally buggy,
01:28:59 <wobsite> so are all the other package management solutiosn for OS X. I don't care what opengroup says, OS X is a poor excuse for unix.
01:29:07 <_oz> i am currently using homebrew and liking it to a certain extent
01:29:29 <wobsite> I think homebrew's a bit better. I'm not really the person to ask though; I use a linux box primarily
01:30:07 <_oz> homebrew is nice in that, the "formulas" usually do what i'd have done myself
01:30:53 <_oz> carpi: what do you mean? it is just another function, nothing special.
01:33:55 <carpi> _oz: what are you referring to?
01:35:03 <_oz> "carpi: is it possible to pattern match with !!?"
01:35:54 <carpi> oh.. cos i saw a line like this.. "(x:_) !! 0 = x" and it made me wonder
01:36:10 <nomism> http://haskelldsp.sourceforge.net/ <- is this a well maintained library for things like convolution, fft etc.? are there alternatives? it say last update in 2003...
01:36:13 <carpi> but then i realized. (!!) is just a function..
01:36:26 <carpi> so nothing special there like you mentioned
01:36:26 <hpaste> Gavri pasted “xmonad.hs” at http://hpaste.org/54804
01:36:55 <_oz> yeah, that's someone defining (!!) using pattern-matching.
01:37:25 <danr> carpi: you might want to look into viewpatterns
01:37:36 <danr> f ((!! 5) -> x) = ...
01:37:56 <danr> and _oz
01:42:41 <shachaf> I have no context on this conversation other than the last few lines, but you might want to look into not using (!!).
01:43:21 <ANIE> ciao
01:43:24 <ANIE> !list
01:44:10 <jessopher> :t !!?
01:44:10 <lambdabot> parse error on input `!!?'
01:44:21 <jessopher> :t (!!?)
01:44:22 <lambdabot> Not in scope: `!!?'
01:44:42 * jessopher fires lambdabot
01:45:05 <shachaf> jessopher: What?
01:45:23 <jessopher> i think i may have misread his original question
01:45:39 <wobsite> he was asking about !!, not !!?
01:46:09 <shachaf> "!!," isn't even a valid Haskell operator.
01:46:19 <jessopher> the original question was 'is it possible to pattern match with !!?'
01:46:36 <wobsite> ...and english and haskell don't merge and maintain an unambigious grammar.
01:46:45 <jessopher> right
01:47:07 <wobsite> shachaf: the comma was part of the english phrase, not the function name.
01:47:26 <jessopher> now everyone is doing it
01:47:49 <wobsite> also, am I the only one who thinks a lot of haskell libraries have really, really, really terrible variable names?
01:48:45 <suped> whoop. It worked guys.
01:49:07 <shachaf> wobsite: Right. Your sentence suffered from the same ambiguity as the original. :-)
01:49:24 <suped> But I had to remove /opt/local/bin from my path to make it work, after uninstalling ghc in ports
01:49:42 <suped> thanks wobsite and _oz
01:49:56 <wobsite> no problem.
01:50:40 <suped> Is having that path in my path neccesary?
01:50:47 <wobsite> shachaf: and people try to specify law in this horrifically ambiguous langauge. no wonder governments think they can do whatever they want.
01:51:04 <wobsite> suped: only if you want to use stuff from macports.
01:51:05 <suped> I mean, is it real bad to not have /opt/local/bin in my path?
01:51:17 * jessopher forks his government and rewrites it in haskell
01:51:53 <hiptobecubic> Why is the length of a Data.Serialize.encoded Float 13 bytes?
01:52:05 * hackagebot fixplate 0.1.1 - Uniplate-style generic traversals for fixed-point types, with some extras.  http://hackage.haskell.org/package/fixplate-0.1.1 (BalazsKomuves)
01:52:20 <hiptobecubic> Instead of 16 or 8, for example.
01:54:05 <jessopher> i dont think government would typecheck
01:55:25 <wobsite> jessopher: it's not even a lack of typechecking I'm concerned about. It's the near impossibility of absence of contradiction; and of course a contradiction, if accepted, let's you come to any conclusion youw ant.
01:55:39 <wobsite> s/youw ant/you want/
01:56:19 <jessopher> :t fix fix
01:56:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
01:56:21 <lambdabot>     Probable cause: `fix' is applied to too many arguments
01:56:21 <lambdabot>     In the first argument of `fix', namely `fix'
01:56:27 <jessopher> thats governments type
01:57:44 <wobsite> It's also why legalease is so damn opaque: natural langauge doesn't even try to be unambigious; it depends on a very sophisticated interpreter to try to piece together what was meant. legalease completely ignores this and treats english like a specification language, which it has no hope of being.
01:58:13 <JuanDaugherty> that's wrong, silly in fact
01:58:28 <JuanDaugherty> i was tryin to figure out if
01:58:48 <JuanDaugherty> you were talking about government as in "government and binding"
01:59:04 <JuanDaugherty> or like Westminster, the PRC, etc.
01:59:17 <hiptobecubic> Also, the bytestring for Int type make sense as an 8 byte long. But i don't understand Float
02:01:28 <JuanDaugherty> the laws of various jurisdictions are in effect a complex logic program that can be automated, said automation is at some degree of advancement already
02:02:59 <ddarius> @google the paradox of self-amendment
02:03:01 <lambdabot> http://www.earlham.edu/~peters/writing/psa/
02:03:01 <lambdabot> Title: Peter Suber, Paradox of Self-Amendment, Table of Contents
02:04:06 <wobsite> JuanDaugherty: my point was that it's treated like that, but the logic has so many damn inconsistencies (as is inevitable when you try to use a natural langage for logic programming) that instead whoever's judging the rules just does whatever they want.
02:04:12 <ddarius> wobsite: The "very sophisticated interpreter" that interprets natural language also interprets legalese.
02:04:18 <jessopher> well then 'they' should hurry up with that, I think the maintainers of the executive branch is merging unstable changes
02:05:17 <ddarius> At least with regards to criminal law, the law is not trying to be and should not try to be rigid and unambiguous.
02:06:56 <JuanDaugherty> neither the fact those who execute laws are corrupt, incompetent, whatever, nor unresolved inconsistencies "still on the books" are germane to the core matter fact,
02:07:14 <JuanDaugherty> s/,/./
02:07:25 <JuanDaugherty> *the fact that
02:07:41 <wobsite> ddarius, agree. Ideally we'd actually use our heads.
02:08:17 <jessopher> i was mostly just trying to keep the conversation on topic :P
02:08:59 <JuanDaugherty> well an interesting thing this sort of brought to me was that the typical haskell programmer may be oblivious to AI
02:10:01 <JuanDaugherty> linguistics, philosophy supporting natural language use, etc.
02:12:59 <jessopher> I don't know any typical haskell programmers, but I am definitely oblivious to AI in any large sense. It seems like an interesting field with an inappropriate name. Like ship building under the name of 'artificial swimming'
02:13:30 <ddarius> jessopher: I like your idea.
02:13:33 <wobsite> reminds me of a dijkstra quote I'm a fan of
02:13:53 <jessopher> its a plagerism
02:14:14 <wobsite> something along the lines of : asking if a computer can think is like asking if a submarine can swim.
02:14:36 <jessopher> that'd be my source
02:14:42 <JuanDaugherty> http://meansofproduction.biz/eg/index.php/AI
02:16:41 <wobsite> The boundaries of AI have always seemed rather ill-defined to me. seems like we call whatever we don't know how to do systematically "AI". not that that's meant as a criticism of the field.
02:19:24 <jessopher> i consider the error reporting of a good compiler as AI under that definition
02:20:31 <ddarius> jessopher: The hard thing there is understanding people not intelligence or any technical hurdle.
02:20:36 <wobsite> it's not much of a "definition" - but much of natural langauge isn't really denotational in nature; we have associations with words, and if something is close enough...
02:21:58 * ddarius thinks wobsite is under the mistaken impression that we listen to what we hear and read what we see.
02:22:47 <wobsite> what did I say that gave you that impression?
02:23:52 * jessopher just blurts out passing thoughts and has weird facinations and a lot of people mistake that for intelligence too
02:25:04 <ddarius> I don't really think it's matter of finding something "close enough."  One, it is often the case that very fine distinctions are made verbally, but more significantly, we simply read/hear what we expect so the issue often just doesn't come up.
02:27:25 <wobsite> well, yes, sometimes we have very precise notions of things. but I think by and large our vocabulary is more a set of associations of things to the symbols than any strict definition.
02:29:07 <wobsite> had a psych prof who went through this exercise of asking us to define the word "cup", then showing us pictures of all sorts of things and asking us if they were cups.  you'd see people constantly trying to revise the definition to fit with their assocations, but it becomes pretty clear pretty quickly that the definition isn't driving the classifcation process, rather the other way around.
02:29:14 <jessopher> i think i agree, other than the 'symbols' part. I don't think there are any concrete symbols
02:30:39 <wobsite> well, yeah. everyone's voice/handwriting is different; it's the same phenomenon of finding something that matches your associations.
02:31:59 <wobsite> which can of course go wrong, even on the level of something as simple as a letter. e.g. http://en.wikipedia.org/wiki/Thorn_(letter)
02:32:12 <wobsite> everybody these days seems to think that's meant to be a Y.
02:32:24 <jessopher> haha
02:35:06 <ddarius> wobsite: The fine distinctions don't have to be unambiguous.  Precision is not in conflict with having a "set of associations."  Think poetry.  You probably have some very abrupt distinctions between, say, "curvy" and "sinuous" even though they largely overlap in meaning.  My choice of using "sinuous" in a sentence would probably cause you to exclude a large number of things that are merely "curvy" even though you'd pr
02:35:06 <ddarius> obably agree that "sinuous" would not be an unreasonable description of them.
02:35:44 <jessopher> so the study of this phenomenon should be called þornography
02:37:31 <ddarius> yornography?
02:37:41 <jessopher> no no, thornography
02:40:36 <wobsite> ddarius: fair point.
02:44:09 <wobsite> I suppose my assocations with the word definition don't match many things that are ambiguous. too much math I suppose.
02:52:05 <hpaste> hiptobecubic pasted “Lazify this?” at http://hpaste.org/54807
02:52:34 <hiptobecubic> It runs forever and never prints, how can I lazily print out the bytestrings in the list?
02:54:55 <hiptobecubic> I've tried using map / list comprehensions to apply B.putStrLn to the elements of sig, but then the laziness means it never prints anything at all.
02:55:32 <jessopher> i would profile it to see where the evaluation of the whole list is happening
02:55:48 <wobsite> hiptobecubic: what that will give you is a list of IO actions. you need to actaully execute them.
02:56:35 <wobsite> I think mapM_ may be what you want.
02:56:55 <hiptobecubic> i'll look, thanks
02:57:43 <hiptobecubic> what's the difference in mapM and mapM_ ?
02:58:01 <carpi> danr: hiptobecubic mapM returns the result of the IO..
02:58:05 <carpi> mapM_ doens't
02:58:18 <wobsite> exactly. depends on whether you want the result or not.
02:58:31 <hiptobecubic> the result being the empty list?
02:58:40 <carpi> depends on the IO
02:58:48 <Jafet> @src mapM
02:58:48 <lambdabot> mapM f as = sequence (map f as)
02:58:52 <Jafet> @src sequence
02:58:53 <lambdabot> sequence []     = return []
02:58:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:58:53 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
02:59:02 <Jafet> @src mapM_
02:59:03 <lambdabot> mapM_ f as = sequence_ (map f as)
02:59:03 <jessopher> in the case of printing, probably a list of ()
02:59:08 <wobsite> well, if you mapM over a series of putStrLn, you'll have a list of empty tuples as the result. probably not what you want.
02:59:24 <wobsite> mapM_ throws that out and just gives you a ()
02:59:33 <hiptobecubic> ah i see
03:10:16 <hiptobecubic> My sine wave generator sounds like ass.
03:12:31 <ddarius> hiptobecubic: You probably have a bug.
03:12:46 <hiptobecubic> ddarius, i'm probably just doing wrong.
03:12:50 <hiptobecubic> doing it*
03:13:06 <ddarius> I believe that would fall under "bug."
03:13:41 <Botje> would that be an asinine wave generator?
03:13:49 <Botje> (sorry, somebody had to make that joke)
03:14:11 <AfC> Botje: not bad
03:14:44 <ddarius> hiptobecubic: If you are doing sound generation, you may find the Karplus-Strong algorithm an amusing exercise.
03:16:08 <TheLemonMan> is allowed to supply to mapM_ a partial function ?
03:16:30 <Botje> if it's of type a -> m b, sure
03:16:54 <Botje> or do you mean partial as in not defined for ALL inputs?
03:17:05 <TheLemonMan> the latter
03:17:07 * hackagebot monad-control 0.3.0.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.0.1 (BasVanDijk)
03:17:20 <ddarius> Botje: What was the alternative meaning you had in mind?
03:17:59 <Botje> curried function
03:18:06 <Botje> it's early :)
03:18:10 <DevHC> is there a mapless version of mapM? :}
03:18:20 <ddarius> sequence
03:18:27 <ddarius> @src mapM
03:18:28 <lambdabot> mapM f as = sequence (map f as)
03:20:57 <TheLemonMan> hrm, it pretends the return to be m0 b0 but my return value isnt wrapped in a monad
03:22:08 * hackagebot lifted-base 0.1.0.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.1.0.1 (BasVanDijk)
03:24:42 <aika>  hey
03:25:34 <hiptobecubic> M
03:33:27 <hpaste> Kona-chan pasted “try1” at http://hpaste.org/54808
03:35:45 <hpaste> Kona-chan pasted “try1” at http://hpaste.org/54809
03:37:09 * hackagebot hakyll 3.2.3.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.3.1 (JasperVanDerJeugt)
04:12:49 <carpi> how do you visualize the data flow in an expression like "((+) . (const 1))"?
04:13:09 <carpi> assuming x = ((+) . (const 1))
04:14:17 <carpi> is it possible for a function composition to take 2 parameters?
04:16:58 <carpi> it seemm not.. atleast thats what 'learn you a haskell" says
04:17:27 <carpi> in a compostion functions that take more than 1 param must be partially applied
04:18:11 <Axman6> > ((+) . (const 1)) x y
04:18:13 <lambdabot>   1 + y
04:18:49 <Axman6> so, it's basically: (\x -> (\y -> (const 1 x) + y))
04:18:57 <Axman6> hmm, not sure that makes it clearer
04:22:02 <carpi> how is it possible to pass the param y to the inner lambda?
04:22:29 <aristid> carpi: all function application with more than one parameter is multiple function applications
04:22:58 <aristid> 1 + 2 is ((+) 1) 2
04:23:15 <DevHC_> he probably means:
04:23:41 <DevHC_> @let (...) f g x y = f (g x y)
04:23:42 <lambdabot>  Defined.
04:24:02 <aristid> :t (...)
04:24:03 <lambdabot> forall t2 t3 t t1. (t2 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
04:24:28 <DevHC_> > ((const 1) ... (+)) x y
04:24:30 <lambdabot>   1
04:24:49 <aristid> :t fmap.fmap
04:24:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:25:10 <Axman6> @src (.)
04:25:11 <lambdabot> (f . g) x = f (g x)
04:25:11 <lambdabot> NB: In lambdabot,  (.) = fmap
04:26:08 <Axman6> so, ((+) . (const 1)) x => ((+) (const 1 x)) => ((const 1 x) +)
04:28:03 <carpi> so something like ((+) . (const 1)) 0 4 become (+0) 4?
04:28:56 <Axman6> no, it becomes (1+) 4 or 1 + 4
04:29:16 <DevHC_> 0
04:29:22 <Axman6> no, 1
04:29:35 <DevHC_> </wrong window> :}
04:29:41 <Axman6> heh, ok :)
04:29:51 <carpi> my bad.. '
04:39:19 <carpi> is ther a way to stop at a certain point in a fold ?
04:39:37 <carpi> ..wihtout having to traverse the rest of the list
04:40:15 <Ke> doesn't lazy evaluation do that for you for foldr
04:40:20 <aristid> carpi: well, there is lazy evaluation, so depending on which kind of fold it is, you can simply stop using the argument
04:40:31 <Ke> @type takeUntil
04:40:32 <lambdabot> Not in scope: `takeUntil'
04:41:13 <Ke> @type takeWhile
04:41:15 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:41:50 <sipa1024> carpi: if you use foldr f [1,2,3] a, you actually do f 1 (f 2 (f 3 a))
04:42:01 <sipa1024> if f 1 x doesn't use x, you don't traverse it
04:43:33 <carpi> for a moment i forgot haskell is lazy. goes to show im still in that OOP mindset..
04:46:08 <Philippa> carpi: eh, FP and laziness aren't the same thing either
04:47:18 <sipa1024> lazyness is a language feature (though you can emulate it), FP and OOP are paradigms (which can be encouraged by a language)
04:49:07 <Philippa> sipa: *golf clap*
04:49:39 <Philippa> we say haskell's a lazy functional language for a reason too - lazy isn't implied by functional
04:52:45 <hpc> technically we say haskell is a lazy pure functional language :P
04:53:11 <sipa> Philippa: what does golf clap mean?
04:53:19 <Axman6> i thought it was a pure functional language with non-strict semantics?
04:55:49 <bjrn> How do you guys handle smaller/sneaky license violations? Some guy has copy pasted some code from my project, changed it just slightly, and doesn't follow my license
04:56:19 <Axman6> blog about it and stick it on hackernews and reddit
04:56:54 <bjrn> Axman6: That's one option. Another option is to contact the guy first, but that my backlash
04:56:59 <bjrn> *may
04:57:08 <sipa> define backlash?
04:57:34 <Axman6> bjrn: well yeah, that should definitely be the first course of action
04:57:57 <Peaker> Does Parsec have a name for:  choice . map try ?
04:58:10 <bjrn> sipa: May be honest mistake or similar. Perhaps I'm giving him too much credit
04:58:33 <sipa> never ascribe to malice that which can be adequately explained by incompetence :)
04:58:40 <hpc> choice :: [Parser a] -> Parser a?
04:58:50 <hpc> Peaker: don't know of one but i think i would call it "select"
04:58:52 <bjrn> Thanks,I will contact him and see what happens
05:13:04 <aristid> :t foldr (<|>) empty
05:13:06 <lambdabot>     Ambiguous occurrence `empty'
05:13:06 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
05:13:06 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
05:13:15 <aristid> :t foldr (<|>) Control.Applicative.empty
05:13:16 <lambdabot> forall (f :: * -> *) a. (Alternative f) => [f a] -> f a
05:13:33 <aristid> hpc: that's choice, right?
05:14:18 <hpc> aristid: dunno; i don't parsec
05:14:28 <hpc> i suppose so, yeah
05:14:30 <aristid> hpc: Y U NO PARSEC? :)
05:14:38 <hpc> :P
05:14:59 <hpc> ive been meaning to write some serious code with it, but i haven't needed it
05:16:31 <Philippa> sipa: a golf clap is less than entirely honest congratulations
05:18:32 <aristid> hpc: well there's the alternative plan of trying to use trifecta and in order to do so bugging edwardk to write a tutorial :)
05:19:23 <hpc> heh
05:37:17 * hackagebot plugins-auto 0.0.1 - Automatic recompilation and reloading of haskell modules.  http://hackage.haskell.org/package/plugins-auto-0.0.1 (FacundoDominguez)
05:57:54 <MaskRay> Can ghc generate portable C code which can be compiled by gcc afterwards?
05:59:13 <mzero> yes - but you need an "unregisterised" version of GHC
05:59:56 <Igloo> It's platform-specific C code
06:02:43 <mzero> ah yes, true enough -  look at the docs for the flags -funregisterised and -C
06:03:28 <mzero> though, really, it is only specific to things like the size of int, long, etc....  right?
06:04:42 <MaskRay> so i have to compile GHC by myself...what a nightmare
06:05:08 <Gothmog_> Ah, it's not that hard.
06:05:47 <rtharper> it's really not so bad
06:05:49 <rtharper> just time-consuming
06:05:57 <ClaudiusMaximus> 30mins on a quad-core with make -j4  -- could be worse...
06:07:21 <ClaudiusMaximus> (i tried uhc the other day, with the C backend it took 2mins to compile helloworld.hs only to fail during linking, maybe i should have tried a git version)
06:07:40 <Gothmog_> Yeah, could be worse. You could be compiling KDE, for instance. ;)
06:08:21 <Valodim> libreoffice is a lot of fun, too
06:11:05 <cking> lol
06:11:40 <cking> wine is fun too, especially when you have to do it over and over.
06:12:18 <MaskRay> webkit is fun too
06:12:25 <cking> sorry, wining about my pet peeve hurr hurr.
06:13:09 <MaskRay> jhc can produce C code, however, it's not full featured
06:27:32 <unsafePerformIO> I want to write Word8's to file, creating a binary file. How is the efficiency, typically,  of putting each Word8 vs putting ByteStrings?
06:28:12 <hpc> unsafePerformIO: without buffering the handle, disasterously slower
06:28:18 <hpc> with buffering, less disasterously
06:28:37 <unsafePerformIO> hpc: ok, so I should use the 'binary'-package?
06:28:39 <hpc> there's overhead involved in each handle write
06:28:50 <hpc> yeah
06:29:08 <hpc> or there's redefinitions of the relevant IO functions in the same package that has byte strings
06:29:21 <hpc> ...which i think is binary
06:29:51 <hpc> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.0/doc/html/Data-ByteString.html#g:26 -- those will work too
06:30:43 <ClaudiusMaximus> @hoogle hPutBuf
06:30:44 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
06:30:44 <lambdabot> GHC.IO.Handle hPutBuf :: Handle -> Ptr a -> Int -> IO ()
06:30:44 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
06:30:57 <Peaker> is there a "NOT this lookahead here" primitive in Parsec?
06:30:57 <Peaker> or, how do you compose    lookahead (not this) *> ... ?
06:30:58 <ClaudiusMaximus> but that's a bit low-level / unsafe
06:31:02 <unsafePerformIO> ok. but I will typically write Word8's one by one, so 'binary' looks like the best choice for me.
06:31:39 <hpc> @src isSpace
06:31:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:31:42 <Waldteufel> Peaker: i think there is something called notFollowedBy
06:31:53 <Peaker> I want something like:  literalString = char '"' *> many (lookahead (not (char '"')) *> anyChar) <* char '"'
06:32:01 <hpc> Peaker: i am pretty sure there's a way
06:32:03 <unsafePerformIO> (I like lamdabot)
06:32:28 <hpc> aha
06:32:30 <hpc> @hoogle satisfy
06:32:31 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
06:32:31 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
06:32:31 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
06:32:55 <hpc> many (lookahead (satisfy (/= '"'))
06:33:19 <roconnor> > 1/(1 + 8/998) :: Rational
06:33:19 <lambdabot>   499 % 503
06:33:21 <hpc> there's also noneOf
06:33:28 <Peaker> hpc: thanks.. I'm wondering if there's a way that generalizes to any Parser
06:33:29 <roconnor> > 1/(1 + 8/998) :: Double
06:33:30 <lambdabot>   0.9920477137176938
06:33:58 <hpc> or if you are silly, anyChar and guard
06:33:59 <hpc> :t guard
06:34:01 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:34:30 <hpc> anyChar >=> (guard . (/= '"'))
06:34:31 <Peaker> ok, notFollowedBy is really just a disallow-lookahead
06:34:43 <Peaker> it seems badly named, has nothing to do with "followed" at all
06:35:46 <unsafePerformIO> btw, does 'hPutChar' convert a Char-value into [0, 256) and writing a byte, or may it use more than one byte?
06:36:40 <hpc> unsafePerformIO: depends on the encoding of the handle, i believe
06:37:13 <hpc> unsafePerformIO: in general, i will assume it crashes on unicode unless i look up the right encoding and set it myself
06:37:41 <hpc> @hoogle hSetEncoding
06:37:42 <lambdabot> System.IO hSetEncoding :: Handle -> TextEncoding -> IO ()
06:37:42 <lambdabot> GHC.IO.Handle hSetEncoding :: Handle -> TextEncoding -> IO ()
06:39:44 <hpc> (the other side of that is that sometimes i get lucky and it can read/write that stuff fine, but reads it as multiple ascii chars)
06:43:49 <Peaker> is there a way to "debug-print" in a Parsec? To see if it reached somewhere?
06:43:59 <Peaker> I guess I could trace on the do statement itself
06:44:53 <hpc> you can use ParsecT IO
06:45:11 <hpc> trace works too, if changing the type isn't an option
06:45:13 <Peaker> Just debugging though, don't want to complicate structure for it
06:45:16 <hpc> yeah
06:45:26 <hpc> that's exactly what trace is for, then :P
06:45:40 <unsafePerformIO> Peaker: there is something called 'labels', but not sure exactly how it works (maybe only for "expecting"-errors?)
06:46:07 <Peaker> unsafePerformIO: I think it replaced "expected ';' or .." with expected labels -- which is actually not as nice for my purpose :)
06:46:57 <hpc> unsafePerformIO: stuff like that is better served by (<?>) iirc
06:47:09 <hpc> @hoogle (<?>)
06:47:09 <lambdabot> Text.Parsec.Prim (<?>) :: (ParsecT s u m a) -> String -> (ParsecT s u m a)
06:47:09 <lambdabot> Text.ParserCombinators.Parsec.Prim (<?>) :: (ParsecT s u m a) -> String -> (ParsecT s u m a)
06:48:06 <hpc> yeah, (parser <?> "oh crap") -- means if parser fails, the error message is "oh crap" instead of "expecting ..."
06:48:14 <binsh> hey guys, im having some trouble converting int to a string. Im trying " ls = read (show a)::String " atm, but im getting an Exception. a is the Int
06:48:35 <binsh> anyone who can help me on my way?
06:48:36 <Waldteufel> isn't int to string just (show a)?
06:48:39 <hpc> > show 100 -- binsh
06:48:40 <lambdabot>   "100"
06:48:47 <hpc> > read "100" :: Int -- binsh
06:48:48 <lambdabot>   100
06:48:59 <hpc> > read "100" :: String -- binsh
06:49:00 <Waldteufel> when you _read_ a string it has to be in double quotes
06:49:00 <lambdabot>   "*Exception: Prelude.read: no parse
06:49:11 <hpc> > read "\"100\"" :: String
06:49:12 <Waldteufel> > read "\"1000\"" :: String
06:49:13 <lambdabot>   "100"
06:49:13 <lambdabot>   "1000"
06:49:19 <hpc> > show "100"
06:49:20 <lambdabot>   "\"100\""
06:49:26 <binsh> nice it worked :P
06:49:29 <hpc> > fix show -- and the grand finale
06:49:30 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
06:49:35 <binsh> thought that was only for the command line
06:49:38 <binsh> ghci
06:49:49 <binsh> thx ;)
06:53:40 <pierre10> Hi, I'm a beginner trying to write a simple temperature conversion calculator. I have a question about how I should model the data. It looks like if I just define them to be data Temperature = C | F | K (without the numeric values), then I can write a converter Temperature -> Temperature -> Double -> Double. But it seems to be cleaner to define them as C Double | F Double etc. However, i don't know how to write a single function that
06:53:40 <pierre10> could convert between the different types of Temperature because I can't just talk about the "Fahrenheit" system, I have to talk about Fahrenheit values. Does anyone have any suggestions?
06:54:25 <hpc> data TempUnit = C | F | K -- pierre10
06:54:38 <hpc> data Temperature = Temperature Double TempUnit -- pierre10
06:55:01 <pierre10> hpc: brilliant. thank you
06:55:02 <hpc> roomTemp = Temperature 72.0 F
06:55:08 <hpc> freezing = Temperature 0 C
06:55:29 <shlevy> hpc: But shouldn't freezing ALSO = Temperature 32 F?
06:55:53 <sipa> you can write a nice instance for Ord and Eq now :)
06:55:54 <shlevy> I guess you'd want to manually write an Eq instance
06:56:14 <hpc> shlevy: sure; you would have a function to normalize stuff (ideally to kelvin), then all the functions you export normalize temperatures before use
06:56:17 <hpc> or something like that
06:57:19 <hpc> for real use (beyond a conversion calculator), you would have one unit and different functions to return different Doubles, but that's not what he's writing :P
06:57:29 <hpaste> “_Mikey” pasted “IO Int” at http://hpaste.org/54820
06:57:39 <_Mikey> hey guys
06:57:56 <_Mikey> I'm kinda confused with printing Ints
06:58:02 <hpc> :t randomRIO
06:58:02 <_Mikey> or PutStr'ing them
06:58:04 <lambdabot> forall a. (Random a) => (a, a) -> IO a
06:58:25 <_Mikey> so I'm getting an IO a
06:58:30 <hpc> :t read -- _Mikey
06:58:32 <lambdabot> forall a. (Read a) => String -> a
06:58:35 <hpc> :t show -- _Mikey
06:58:36 <lambdabot> forall a. (Show a) => a -> String
06:58:38 <hpc> :t print -- _Mikey
06:58:40 <lambdabot> forall a. (Show a) => a -> IO ()
06:58:54 <hpc> use "print x" or "putStrLn (show x)
06:58:56 <hpc> "
06:59:02 <byorgey> _Mikey: 'read num' doesn't make sense; 'num' is an Int and 'read' is for Strings
06:59:14 <_Mikey> ahh
06:59:14 <_Mikey> but
06:59:30 <_Mikey> if I use show x I'll get as string
06:59:35 <_Mikey> which I can then putStr?
06:59:38 <hpc> _Mikey: yes
06:59:49 <_Mikey> :t show
06:59:50 <lambdabot> forall a. (Show a) => a -> String
06:59:56 <hpc> _Mikey: you can also use print
06:59:56 <_Mikey> oh it takes a variable
06:59:57 <_Mikey> ok
06:59:58 <hpc> @src print
06:59:59 <lambdabot> print x = putStrLn (show x)
07:01:48 <sal23> is there a way to compile GHC 7+ on Redhat 5 without glibc 2.7? Redhat 5 has lower version of glibc
07:05:53 <_Mikey> @hoogle IO a -> a
07:05:54 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
07:05:54 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
07:05:54 <lambdabot> Foreign unsafePerformIO :: IO a -> a
07:06:12 <_Mikey> :( why is that all unsafe?
07:06:54 <rwbarton> because you don't understand IO
07:07:21 <_Mikey> yea I think so
07:07:32 <rwbarton> why do you think it should be safe?
07:07:56 <_Mikey> because a could be a different value each time the function is called?
07:07:58 <hpc> @hoogle (a -> b) -> IO a -> IO b
07:07:58 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
07:07:59 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
07:07:59 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
07:08:09 <hpc> @hoogle IO a -> (a -> IO b) -> IO b
07:08:11 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:08:11 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:08:11 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:08:21 <hpc> ...
07:08:25 <hpc> @hoogle (>>=)
07:08:26 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:08:26 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:08:26 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:08:34 <rwbarton> that is part of why it is unsafe yes
07:08:41 <hpc> _Mikey: instead of bringing IO values to the functions, bring the functions to IO
07:08:53 <_Mikey> ok
07:08:56 <_Mikey> but I've been finding
07:09:07 <_Mikey> when I try and bind values from unsafe functions
07:09:18 <_Mikey> they're still of an IO t
07:09:21 <rwbarton> "unsafePerformIO act" will perform act when it is *evaluated* and you have no good way in general of controlling whether it is evaluated or how many times it is evaluated or when it is evaluated
07:10:01 <hpc> _Mikey: can you paste some hypothetical code? it's easier to offer a specific way of solving the problem than to generally solve the problem of "doing something besides unsafePerformIO"
07:10:13 <_Mikey> ok
07:12:52 <hpaste> “_Mikey” annotated “IO Int” with “IO Int (annotation)” at http://hpaste.org/54820#a54821
07:13:14 <_Mikey> I'm nor sure if that compiles
07:13:23 <vrook> :t getRandomR
07:13:25 <lambdabot> forall a (m :: * -> *). (MonadRandom m, Random a) => (a, a) -> m a
07:13:31 <carpi> in a pattern match is it possible to do something like (x1:sublist@x2:xs)?
07:13:32 <vrook>  getRandomR (1, 6)
07:13:35 <vrook> > getRandomR (1, 6)
07:13:37 <lambdabot>   No instance for (GHC.Show.Show (m t))
07:13:37 <lambdabot>    arising from a use of `M3877853429...
07:13:52 <carpi> or rather something like (x1:sublist@(x2:xs))?
07:14:23 <vrook> why does getRandomR (1,6) work in ghci?
07:14:33 <ClaudiusMaximus> > case "hello" of whole@(h:t@(hh:rest)) -> (whole, h, t, hh, rest)
07:14:33 <lambdabot>   ("hello",'h',"ello",'e',"llo")
07:14:46 <hpc> vrook: ghci executes IO
07:15:04 <hpc> vrook: if it helps, you can imagine ghci to be a giant interactive IO do-block
07:15:27 <vrook> hm ok thanks
07:15:32 <_Mikey> :t (>>=)
07:15:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:15:52 <donri> > readFile "/etc/passwd"
07:15:53 <lambdabot>   <IO [Char]>
07:16:12 <hpc> vrook: the longer answer is that lambdabot uses mueval, which is strictly for evaluating expressions
07:16:29 <hpc> vrook: meaning, it takes an expression, calls "show" on it, then displays as much of the result as it can
07:16:35 <hpc> or wants to
07:16:42 <vrook> So where is the state being tracked in ghci? The implicit do-block continues forever and ever? getRandomR (1, 6) returns different values
07:16:47 <hpc> donri: that's not a very safe password ;)
07:16:57 <donri> hah
07:17:06 <hpc> vrook: there's a hidden magic random generator
07:17:16 <hpc> :t randomIO
07:17:17 <lambdabot> forall a. (Random a) => IO a
07:17:21 <hpc> @src randomIO
07:17:22 <lambdabot> Source not found. That's something I cannot allow to happen.
07:17:27 <carpi> ClaudiusMaximus: Thank you emperor )
07:17:36 <carpi> oops.. that was marcus aurelius.. my bad
07:17:46 <hpc> :t getStdGen
07:17:48 <lambdabot> IO StdGen
07:17:56 <ClaudiusMaximus> hmm, System.Exit.exitSuccess doesn't in ghci
07:18:05 <hpc> vrook: getStdGen lets you peek at that magic random generator, i think
07:18:14 <hpc> it might create a new one
07:18:44 <roconnor> @type System.Exit.exitSuccess
07:18:45 <lambdabot> forall a. IO a
07:18:48 <vrook> hpc: yeah, getStdGen changes after a call to getRandomR
07:18:56 <vrook> but is the same between calls
07:19:14 <vrook> so Haskell cheats after all with a global variable here?
07:19:14 <hpc> ClaudiusMaximus: yeah, i get an *** Exception
07:19:30 <hpc> vrook: indeed, or at least ghc
07:19:46 <hpc> dunno if that's standardized trickery
07:19:47 <roconnor> @type getRandomR
07:19:48 <lambdabot> forall a (m :: * -> *). (MonadRandom m, Random a) => (a, a) -> m a
07:20:16 <hpc> vrook: there's also a pure function to make an StdGen from a seed
07:20:30 <roconnor> vrook: If you use the IO instance of MonadRandom, why would you expect getStdGen to stay the same?
07:23:21 <Sembiance> I'm trying to compile a haskel program from src (xmobar) and I'm running ghc 7.0.4 and mtl 1.1.1.1 I get the following error: http://pastebin.com/tLkAeLia
07:23:23 <mauke> The paste tLkAeLia has been copied to http://hpaste.org/54822
07:23:49 <vrook> roconnor: are you saying getStdGen is rebound in the implicit do block in ghci?
07:23:59 <Sembiance> I'm not very familiar with haskell and an internet search has only revealed that this problem was seen with someone running 6.x of ghc but he upgraded to 7.0.3 and the problem went away
07:24:27 <Sembiance> Someone suggested that I may need an additional import, that stuff in mtl/ghc may have changed/moved
07:25:03 <roconnor> vrook: it isn't rebound. getStdGen is a procedure that gets the standard generator which is stored in something like an IORef.
07:25:13 <hpc> Sembiance: i think you can open that file and import Control.Monad.Instances at the top or something?
07:25:33 <hpc> it's ridiculous for that instance to not be there already
07:25:41 <byorgey> it is in the latest mtl.
07:25:46 <byorgey> but not in mtl-1.1.1.1
07:25:52 <hpc> ah
07:25:56 <cwl> > let len' !s [] = s; len' !s (x:xs) = len' (s+1) xs in len' [1..10]
07:25:57 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t1])
07:25:57 <lambdabot>    arising from a use...
07:26:00 <byorgey> Sembiance: actually, I'm surprised that you only have mtl-1.1.1.1
07:26:23 <hpc> Sembiance: http://hackage.haskell.org/package/mtl -- a more recent mtl will solve your problem
07:26:30 <cwl> <interactive>:1:11: Parse error in pattern: s
07:26:46 <hpc> Sembiance: you may need to install transformers too
07:26:48 <cwl> why? if i remove the !, it is ok
07:27:09 <byorgey> the latest Haskell Platform (which comes with ghc-7.0) includes mtl-2.0.1.0
07:27:21 * hackagebot effects 0.2.1 - Computational Effects  http://hackage.haskell.org/package/effects-0.2.1 (SjoerdVisscher)
07:27:23 <hpc> cwl: turn on the bang patterns extension
07:27:32 <ClaudiusMaximus> hooray, profiling fun - so far found that 43%/50% of time/alloc is in one function called 75k times - testing some possible fix now...
07:27:46 <cwl> hpc: thanks
07:27:47 <hpc> ClaudiusMaximus: fix would make it run even slower! :P
07:28:42 <Sembiance> byorgey: running gentoo with bleeding edge packages (~x86) but I guess they must not have an active maintainer
07:28:47 <alistra> what should i do if i want to do a :break on some predule or data.list function?
07:28:48 <Sembiance> for the haskell packages
07:29:00 <byorgey> Sembiance: ah, I guess not
07:29:14 <ClaudiusMaximus> hpc: currently testing if this helps:   f a b c d = i (g a b c (h d))  with  f a b c = let g' = g a b c in \d -> i (g' (h d))
07:29:20 <alistra> it says it's not interpreted
07:29:22 <Sembiance> byorgey: I'm gonna see if I can find a more recent gentoo package for mtl
07:29:23 <byorgey> Sembiance: seems the blood is all dried and clotted
07:29:23 <ClaudiusMaximus> s/with/replaced with/
07:29:36 <Sembiance> byorgey, hpc: thank you both very much for your help :)
07:30:28 <roconnor> vrook: if you call randomRIO between getStdGen you will get different values
07:30:42 <roconnor> vrook: if you call newStdGen between getStdGen you will get different values
07:30:55 <roconnor> vrook: if you call setStdGet between getStdGen you will (likely) get different values
07:31:00 <roconnor> *setStdGen
07:31:29 <alistra>  what should i do if i want to do a :break on some predule or data.list function?
07:31:31 <roconnor> @hoogle getStdRandom
07:31:31 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
07:32:37 <roconnor> vrook: and if you call (getStdRandom f) between getStdGen you will get (snd . f) applied to the first value of getStdGen for the second call to getStdGen
07:33:09 <ClaudiusMaximus> hm, no change in the profile results...
07:38:55 <vrook> roconnor: ok thanks. The random monad works differently than I had anticipated. Wouldn't it be better for it to track a given stdGen rather than calling newStdGen?
07:39:22 <vrook> I have a bunch of functions which pass and return stdGen, I thought the Random monad would just abstract that.
07:39:31 <vrook>  But the monad is doing more with newStdGen
07:45:26 <joe9>  /ws 19
07:45:49 <Sembiance> byorgey: created a gentoo package for the latest mtl and also transformers. That fixed the build/compile error. Now I have a different one that I'm working on tracking down.
07:46:38 <joe9> quick question. I cannot add a show instance to a type, correct? For example, I have  "type Address = Int". I cannot add a Show to Address unless I encapsulate it with a newType or data, correct?
07:46:45 <ClaudiusMaximus> gnargh :'( ... with integer-gmp this test runs in <20s, compared to >200s with integer-simple
07:49:18 <Sembiance> Any ideas on this error? http://pastebin.com/30NBvGAm
07:49:19 <mauke> The paste 30NBvGAm has been copied to http://hpaste.org/54824
07:49:23 <Sembiance> Source Code: https://github.com/jaor/xmobar/blob/master/src/Parsers.hs#L163
07:49:39 <azaq23> joe9: yes, a type synonym doesn't create a new type
07:51:42 <joe9> azaq23: ok, thanks.
08:02:28 <byorgey> Sembiance: what is the type of wrapSkip?
08:02:54 <Sembiance> byorgey: figured out the problem. I'm running an outdated parsec
08:03:02 <byorgey> Sembiance: ah, ok =)
08:03:08 <Sembiance> gentoo again :)
08:04:08 <ClaudiusMaximus> Sembiance: not used gentoo for a long time, so this might be nonsense: but isn't there a haskell-overlay with newer haskell stuff?
08:05:20 <Mathnerd314> I want Haskell to go mainstream. So I'm going to make a really good FFI with C++, and then spam everyone on teh interwebs with it. Sound like a plan?
08:05:39 <Philippa> ...good luck?
08:05:43 <hpc> lol
08:06:07 <Philippa> have you done yourself a basic feasability study on it?
08:06:56 <Mathnerd314> umm... yes? Haskell has an LLVM backend, and there's clang for C++ which compiles to LLVM, and so all that's needed is lots of work
08:07:02 <Sembiance> ClaudiusMaximus: oh, would you look at that, there is :)  thanks :)
08:08:07 <hpc> Mathnerd314: "all"? :P
08:08:24 <hpc> Mathnerd314: my experience with coding says that when something needs "lots of work" it never gets done
08:08:34 <hpc> by comparison, hard problems tend to be solved and lead to easy solutions
08:08:38 <russellw> Mathnerd314, sounds like a good strategy
08:08:51 <byorgey> my experience with coding is that when everyone tells someone that something can't be done, it never gets done.
08:08:57 <byorgey> Mathnerd314: go for it!
08:08:59 <hpc> byorgey: that too ;)
08:11:07 <Philippa> Mathnerd314: um, that sounds backasswards to me. Why should I care what my C++ was compiled with?
08:11:26 <Philippa> (hint: that's not a rhetorical question)
08:11:51 <Mathnerd314> byorgey: the problem is I have (difficult) classes right now, and I'm coming up with 5 simultaneous plans of action for the summer.
08:12:04 <byorgey> hehe, story of my life.
08:12:17 <russellw> Philippa, the alternative is to parse C++ yourself. Parsing C let alone C++ is an ill posed problem.
08:12:44 <Philippa> russellw: is the wrong answer. You might have to find something to read the headers, but ABIs exist for a reason
08:12:46 <byorgey> Mathnerd314: at least it's worlds better than the alternative, which would be to have no plan of action for the summer.
08:13:23 <Mathnerd314> byorgey: admittedly, 3 of them are GSOC projects... so I could just submit multiple applications and let fate decide.
08:13:37 <byorgey> Mathnerd314: haha, fair enough
08:13:39 <russellw> ABIs are based on C not C++. But the bigger problem is 'might have to find something to read the headers'
08:14:11 <Philippa> yeah. But that's not the same as looking for interaction between two LLVM-based backends
08:14:26 <Philippa> basically, the LLVM bit's irrelevant
08:14:48 <russellw> It is once you decide that something is going to be clang, which outputs llvm format
08:15:54 <Philippa> perhaps: you're still going to ignore the bulk of clang's back end, but hey
08:16:43 <russellw> Oh sure, using clang to parse C++ doesn't in and of itself commit you to using the llvm code generator
08:17:25 <Mathnerd314> Philippa: not really. I'm going to borrow the Itanium ABI it implements to do some fun things.
08:17:36 <Philippa> *nod*. Also relevant because GHC has multiple back ends and someone somewhere's going to want to use another
08:20:08 <Mathnerd314> so we have these two toolchans: clang->llvm->code and ghc->llvm->code. They have to be structured very similarly, which means I can skip over large portions of the code and just use their API.
08:20:51 <roaldfre> What would be the datatype of choice to implement a Z buffer (2D mutable array, it's for a rasterizer) in Haskell? Data.Array.ST?
08:21:07 <roaldfre> (Repa seems nice, but it's immutable, afaict)
08:22:56 <Philippa> Mathnerd314: given LLVM's level, I wouldn't assume "have to" - check it
08:23:13 <Philippa> odds are there's quite a lot of plumbing to be done
08:23:22 <Philippa> (don't let that put you off, but do think about how to handle it!)
08:25:41 <Mathnerd314> yeah, I have be very careful to avoid combinatorial explosions. but my impression is that those are due to implementation strategies and not designs. If I do it in Haskell and refactor endlessly it should work out.
08:25:53 <jchia> is there a special reason why foldr and foldl take functions that have different signature? For foldl, the function expects the 'accumulated value' first. For foldr, that value comes second.
08:26:01 <jchia> i find it hard to remember
08:26:18 <hpc> jchia: it might help to take a look at how it expands
08:26:25 <hpc> > foldr f [1, 2, 3, 4, 5] z
08:26:27 <lambdabot>   Couldn't match expected type `[a]'
08:26:27 <lambdabot>         against inferred type `SimpleRef...
08:26:30 <hpc> > foldr f [1, 2, 3, 4, 5] z :: Expr
08:26:31 <lambdabot>   Couldn't match expected type `[a]'
08:26:32 <lambdabot>         against inferred type `SimpleRef...
08:26:35 <hpc> :t foldr
08:26:37 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:26:37 <Peaker> is there a standard/good way of doing a tokenizing pass before the parsing pass with Parsec -- and keeping the source location info?
08:26:38 <hpc> oh
08:26:45 <hpc> > foldr f z [1, 2, 3, 4, 5]
08:26:46 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
08:26:51 <hpc> jchia: compare with foldl
08:26:58 <hpc> > foldl f z [1, 2, 3, 4, 5]
08:26:59 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
08:27:49 <hpc> jchia: it could easily be changed to be more consistent type-wise, but i think this is why they chose to have it be different
08:28:13 <Philippa> Peaker: write the parser in Parsec, build your own Token type, use Parsec's location calls to put location info in the tokens?
08:28:21 <Philippa> or the equivalent with a more specialised lib, if you prefer
08:28:40 <Philippa> (I've done the former, not bothered with the latter but there's definite room for something to perform better if you're specialised to regexes)
08:28:51 <jchia> i see the pattern they make the order the same as what you get after expansion
08:29:37 <Philippa> Peaker: did you see what I wrote? I meant tokeniser rather than parser, but same difference
08:29:55 <jchia> > foldr f z [0,1,2]
08:29:56 <lambdabot>   f 0 (f 1 (f 2 z))
08:29:59 <Philippa> if you give me a moment I might be able to dig up some code from the last time I did it
08:30:20 <Philippa> (admittedly a few years back: I haven't had to touch that part of the code base in a very long time)
08:30:27 <jchia> hpc: how do i make my ghci do the same expansion instead of complaining "Not in scope: 'z'"?
08:30:44 <hpc> jchia: it's a package, but i forget which one
08:30:51 <hpc> @hoogle simple-reflect
08:30:52 <lambdabot> package simple-reflect
08:30:57 <hpc> oh, that one i think
08:31:03 <byorgey> yep, that's the one
08:31:07 <Philippa> @where paste
08:31:08 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
08:31:17 <Peaker> when using Parsec's token parser -- which parsers eat the intermediate whitespace?
08:31:27 <hpaste> Philippa pasted “Lexing a symbol with Parsec” at http://hpaste.org/54826
08:31:45 <hpc> jchia: be warned, it might have some ridiculous dependencies that make it annoying to install
08:31:52 <Philippa> oh, yeah, you'll need the outer loop too
08:31:53 <Peaker> it seems the token parser is simply a collection of parsers for various token types -- but where's the whitespace removal/tokenizing phase?
08:32:05 <hpc> (i know there's at least one part of lambdabot's dependencies that seems to go on forever)
08:32:09 <Philippa> I call a whitespace muncher once then let the individual token parsers do it
08:32:14 <Peaker> ah, it skips "trailing whitespace", which incidentally is the same ad-hoc strategy I used...
08:32:33 <Philippa> wspace = (many (oneOf "\f\r\n ")) >> optional (comment >> wspace)
08:32:57 <hpc> \t, perhaps?
08:33:17 <Mathnerd314> jchia: if you write out the data types from those folds, the two are [a] = a : [a] and [a] = [a] ::: a. Do you find that a satisfactory explanation?
08:33:18 <Philippa> hpc: I deliberately didn't include \t because it's for haskell-like langs I control the specs for :p
08:33:40 <jchia> hpc: i'll try. if it's too hard, i'll just chat with lambadot
08:33:56 <Philippa> you'd have to make a call re pragmas, but they probably want to be their own tokens
08:34:35 <hpc> Mathnerd314: even /I/ can't understand that
08:34:56 <jchia> Mathnerd314: I've no idea what ::: is
08:35:03 <Mathnerd314> ok, I'll try without syntax sugar
08:35:08 <Mathnerd314> :t foldl
08:35:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:35:40 <Philippa> Peaker: you pretty much have a choice between "eat trailing", "eat preceding" and "let the outer loop do it"
08:36:11 <Philippa> the last's perfectly valid - as it happened, I refactored from one-pass code which used "eat trailing"
08:36:15 <jchia> Mathnerd314: i don't understand. my ghci just gives me "foldl :: (a -> b -> a) -> a -> [b] -> a". where's forall from?
08:36:16 <Mathnerd314> data Foldl a = Cons a (Foldl a) | Unit a, data Foldr a = Cons (Foldr a) a | Unit a
08:36:25 <unsafePerformIO> I suppose the functions readFile and writeFile of bytestring may throw exceptions (but I can't find it documented). How do I handle such?
08:36:43 <hpc> jchia: forall is optional; lambdabot prints it because it has some extensions turned on
08:36:46 <Mathnerd314> jchia: lambdabot is magic. just accept it.
08:37:02 <hpc> (it's not really optional, but the extension that makes forall into a thing is)
08:37:25 <unsafePerformIO> because I want to wrap these two into functions not throwing exceptions (using Either)
08:37:42 <Philippa> jchia: we can explain the forall - it's not haskell2010 but it's valid in most implementations and it's valid logically. Or you can just treat it as ignorable magic unless it appears somewhere other than the front of the type. Want the explanation?
08:37:47 <Mathnerd314> hpc: do you understand that data type?
08:37:58 <ClaudiusMaximus> @hoogle bracketOnError
08:37:58 <lambdabot> Control.Exception.Base bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:37:58 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:37:59 <lambdabot> Control.OldException bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:38:06 <hpc> Mathnerd314: ah, nicer
08:38:40 <ClaudiusMaximus> hm, not the right one, but Control.Exception is what you;d use for handling exceptions
08:38:41 <hpc> jchia: hint: you don't want the explanation yet ;)
08:39:25 <jchia> Mathnerd314,Philippa: ok, i follow the data. is this related to how haskell actually computes foldl and foldr?
08:40:45 <Mathnerd314> jchia: yeah. foldr is never actually used, because its performance sucks. There's only foldl and foldr'
08:41:03 <Philippa> foldr is used all the time, by people who can't be bothered to optimise :p
08:41:18 <hpc> Mathnerd314: wrong; foldr and foldl' are the common ones
08:41:25 <hpc> and foldr is the one that works on infinite lists
08:41:25 <Philippa> also yeah, that
08:41:29 <Philippa> thought it looked off
08:41:32 <Mathnerd314> hpc: oops. :p
08:41:48 <Mathnerd314> they are easy to mix up...
08:41:51 <Philippa> jchia: so foldr's quicker to explain. What would happen if I replaced every : and the [] in a list with arbitrary functions?
08:42:14 <Philippa> (keep the associativity of the list - [] is inside a ton of brackets)
08:43:45 <Mathnerd314> Philippa: they are equally easy to explain. foldr is what you get if you evaluate it in a call-by-name language, foldl' is what you get if you evaluate it in a call-by-value language. The code is the same in all cases
08:45:13 <Philippa> Mathnerd314: Isn't that only true if the cons replacement's associative?
08:45:36 <hpc> > foldl (+) z [1..5]
08:45:38 <lambdabot>   z + 1 + 2 + 3 + 4 + 5
08:45:47 <hpc> > foldr (+) z [1..5]
08:45:48 <lambdabot>   1 + (2 + (3 + (4 + (5 + z))))
08:46:19 <Philippa> hpc: quite
08:47:13 <Mathnerd314> Philippa: "it" is the natural transformation you get between data types and pairs of cata/ana morphisms.
08:47:59 <Philippa> Mathnerd314: yeah, so you're now invoking a bunch of additional concepts you really, really shouldn't be
08:48:02 <Mathnerd314> by "the code" I really meant "the data"
08:48:06 <Philippa> jchia: sorry about this
08:48:34 <Mathnerd314> off to #haskell-in-depth ...
08:48:48 <unsafePerformIO> ClaudiusMaximus: Thank you. I have not used exceptions since the days of OldException
08:48:50 <Philippa> jchia: hpc's examples are good. For foldl, the brackets would be on the left if they'd been written out
08:48:59 <hpc> jchia: you've bumped into the "ask a simple question, get a deep answer" problem - something #haskell excels at :P
08:53:27 <ClaudiusMaximus> unsafePerformIO: g'luck - gotta go now..
08:53:45 * Philippa proposes #haskell-not-messing-up-pedagogy
08:54:58 <hpc> #haskell: the channel where (456 - 123) depends on what number base you are using
08:54:58 <Kaidelong> Is there any maintainer of the Gtk2hs package on? If not, whom should I leave a memo for?
08:55:47 <hpc> http://hackage.haskell.org/package/gtk -- see the maintainers section
08:55:53 <Philippa> hpc: not to mention which numbers
08:56:02 <hpc> or dcoutts if you need someone on IRC
08:56:05 <Kaidelong> ah okay I'll just email them then
08:56:18 <Kaidelong> or I could just tell dcoutts
08:56:21 <Kaidelong> that's nice and quick
09:01:32 <DevHC_> [2 of 5] Compiling H[boot]          ( src/hsscr/H.hs-boot, -x/H.o-boot )
09:01:32 <DevHC_> touch: illegal option -- x
09:01:44 <DevHC_> surprize ! ghc passes arguments incorrectly
09:03:21 <JoeyA> Unless -x is a flag introduced in some bleeding-edge version of coreutils
09:03:25 <JoeyA> err, nvm
09:03:33 <JoeyA> there needs to be a -- before the file names
09:04:12 <donri> ghc: could not execute: trhsx -- does ghc or cabal ignore $PATH? this is using cabal-dev with cabal-dev/bin in $PATH
09:04:28 <DevHC_> -x is introduced by my "-outputdir -x" arguments to ghc
09:05:00 <JoeyA> donri: Does the trhsx binary exist in that path?  Maybe the package forgot to include it as a dependency.
09:05:12 <Saizan> donri: do you have '~' in $PATH?
09:05:28 <donri> wait, it works with an absolute path
09:05:41 <donri> relative paths work in the shell though :/
09:05:55 <JoeyA> Yeah, export PATH="~/foo" won't work, IIRC
09:06:05 <Saizan> you want $HOME/cabal-dev/bin
09:06:17 <DevHC_> ~ is replaced with /home/blargious by the shell
09:06:20 <donri> no, I wanted $PWD/cabal-dev/bin :)
09:06:21 <JoeyA> :PATH (of course)
09:06:24 <DevHC_> and only if it's not quoted
09:06:28 <JoeyA> err, :$PATH
09:06:35 <Saizan> ah, whatever :)
09:07:02 <JoeyA> Too bad the syntax for defining a new path isn't: export PATH="/foo:/bar:[]"
09:07:06 <donri> point is that the relative path works fine in bash, ghc should mimic
09:07:13 <DevHC_> how about "."? :}
09:07:52 <Saizan> nah, better have the shell do its job
09:08:12 <donri> but ghc is bypassing the shell
09:08:33 <DevHC_> ghc shouldn't be really using the shell
09:08:55 <donri> it's already handling $PATH, only incompletely
09:09:34 <Saizan> i mean have the shell do its job in providing ghc with a normalized $PATH :)
09:09:56 <donri> it's just an environment variable that it passes along as is
09:10:19 <Saizan> $PWD gets interpreted by the shell, ~ doesn't
09:10:22 <Saizan> or ..
09:10:28 <DevHC_> ~ does
09:10:40 <donri> i don't have a ~ in my $PATH or $PWD
09:10:52 <Saizan> now you have?
09:10:55 <donri> nope
09:11:03 <Saizan> just an absolute path?
09:11:14 <donri> relative, but had to make it absolute for cabal-dev to function
09:11:29 <donri> ~/bla is not a relative path, mind you
09:11:55 <Saizan> i know, there are 2 problems
09:12:16 <Saizan> one is shell syntax like ~, which one shouldn't expect ghc to know about
09:12:35 <donri> i don't expect it to understand ~ and i never said anything about using that :)
09:12:58 <Saizan> the other is stuff like .. which has a relative meaning and ghc/cabal-dev might not be using the same working directory as you expect
09:13:23 <donri> that sounds broken, but understandable
09:13:46 <donri> it should then at least track where it was called from, and resolve $PATH relative to that
09:15:02 <Saizan> i disagree :)
09:15:35 <donri> it's clearly a bug to get an error for program not found when the program in question works fine in the calling shell
09:17:57 <_Mikey> :t (>>=)
09:17:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:18:04 <_Mikey> oops
09:18:22 <DevHC_> donri: once u think about what sort of fancy syntax a shell can have, such as:
09:19:12 <donri> i'm not using fancy syntax or shell-local behavior such as aliases; it's a plain executable located in a directory referenced in the PATH env var
09:19:15 <DevHC_> $${file} to specify (as an argument or arguments) text from the said file
09:20:06 <DevHC_> :/path/to/file to specify... i have no idea what, like the system admin's file: /root/path/to/file
09:20:35 <DevHC_> then u will understand that fancy extensions don't belong in ghc
09:21:28 <donri> i have no idea what you're on about, and i'm still not doing anything fancy
09:22:35 <DevHC_> i also have no idea what u're doing, but u shouldn't be surprized if some program doesn't parse $PATH in strings, if u're surprized by that
09:23:45 <donri> it's clearly parsing $PATH, only incorrectly
09:24:04 <DevHC_> orly
09:25:51 <decaf> how could you manage to parse $PATH incorrectly?
09:26:11 <donri> it is ignoring relative paths
09:26:26 <donri> or handling them relative to the wrong working dir
09:26:57 <donri> i can work around it, but it's counter intuitive
09:28:59 <clsmith_> hey all. how come getArgs :: IO String? they aren't going to change during runtime, so why is it monadic?
09:29:19 <clsmith_> *IO [String]
09:29:20 <hpc> clsmith_: to annoy you ;)
09:29:27 <clsmith_> <.<
09:29:31 <hpc> beyond that, no idea
09:29:39 <hpc> perhaps because in the future they might change
09:29:52 <hpc> or a foreign function can do nasty things that mutate the arguments, or something
09:30:08 <clsmith_> do you think i could just unsafePerformIO them?
09:30:28 <hpc> naively, yes
09:30:50 <hpc> though i would still be mindful of there being a good reason for getArgs being in IO
09:30:52 <donri> still, getArgs is something that is runtime, not compile time
09:31:18 <clsmith_> oh, i suppose
09:31:51 <donri> you could argue that readFile doesn't need to be IO if the file isn't written during runtime :)
09:32:31 <monochrom> heh
09:32:36 <_Mikey> @hoogle -> a
09:32:37 <lambdabot> Unknown flag: ->
09:32:37 <lambdabot>  
09:32:48 <clsmith_> context: i'm writing a compiler, and i want to have flags to switch different optimisations, strategies, etc. and i don't want to have to pass them to *every* function
09:33:45 <donri> there are other ways around that than unsafePerformIO, surely?
09:33:54 <monochrom> if you use global variables, I won't stop you
09:34:07 <clsmith_> but then i'd have to make *every* function IO, no?
09:34:21 <hpc> clsmith_: ReaderT?
09:34:27 <donri> either that, or select functions based on getArgs up front?
09:34:32 <donri> etc
09:34:39 <azaq23> since IO marks something as being connected to the "outside" world, as being beyond the program in some way, IO [String] seems like a more correct description of the type of getArgs than getArgs ::
09:34:40 <azaq23> [String] would be
09:34:40 <DevHC_> here's a trick:
09:35:08 <monochrom> basically xmonad pass flags to every function by a ReaderT or equivalent
09:35:23 <DevHC_> indent ur whole module, and write a leading f :: [String] -> whatever function, where the first argument should the the program command line arguments
09:35:24 <donri> making you pass args around make for better testable/modular code too
09:36:01 <monochrom> there is also a scary Oleg way
09:38:06 <Philonous> monochrom:  You mean that thing where they reflect a memory address in the type system and "ask" it by reifying it again?
09:38:15 <monochrom> yes, that one
09:38:37 <clsmith_> :| what.
09:38:41 <clsmith_> is there a link for that? :p
09:38:44 <monochrom> see? scary :)
09:38:47 <Philonous> monochrom:  I always thought that was batshit insane
09:39:14 <byorgey> it is.
09:39:17 <monochrom> yeah, it is why I didn't bookmark it, so now it will take me forever to find the link :)
09:39:21 <Philonous> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
09:45:15 <BMeph> Is someone going to change the MOTD for 7.2.2?
09:45:48 <BMeph> That is, someone else, and nge it soon? :)
09:46:01 <BMeph> nge -> change
09:46:15 <monochrom> in what sense?
09:47:17 <conal> There's a fundamental reason that getArgs does not have type String, namely that it would violate an important principle of typed, denotative ("genuinely functional") languages: the meaning of the type is the type of the meaning. For instance, the type of meaning of getArgs does is not the meaning of the type String. See http://conal.net/blog/posts/notions-of-purity-in-haskell/ .
09:47:42 <azaq23> +
09:48:13 <Clint> what does "Can't find transitive deps for haddock" indicate?
09:48:56 <MarkusRamikin> id
09:52:18 <conal> More clearly (I hope), if 'e :: t', then 'meaning e :: meaning t'. And the meaning of String is deliberately too simple/tractable to capture something like getArgs.
09:55:35 <conal> IO doesn't signify "connected to the outside world", but rather "non-denotative".
09:58:53 <Philonous> conal:  So IO is actually an even worse misnomer than one would initially be led to think
10:00:05 <conal> Philonous: yes. an accurate name might be "StuffWeDontUnderstand".
10:00:41 <conal> which is i think what simon pj was getting at in describing IO as the Haskell community's "sin bin".
10:00:49 <hpc> haha
10:03:03 <mm_freak> hi there people
10:03:29 <mm_freak> does anyone know an alternative to forkable-monad that builds with recent base libraries?
10:04:06 <parcs_> mm_freak: lifted-base :)
10:04:29 <mm_freak> ah, indeed…  read about it today =)
10:04:54 <clsmith_> a compiler could partially-evaluate an entire program except for the bits which involve IO, right?
10:05:42 <hpc> clsmith_: indeed
10:06:00 <hpc> clsmith_: in practice it doesn't because stuff like [1..] :P
10:06:30 <sipa> a compiler would definitely not evaluate *more* than what needs to be done at run time, right?
10:07:23 <clsmith_> hpc: i suppose at that point it has to say, well, once i get to the monad do i end up with more constant data than i'd like?
10:08:17 <clsmith_> so 'print [1..10000]' would remain like that becuase it would swell up otherwise. but 'foldl (+) [1..10000]' would partially-evaluate fine
10:08:21 <hpc> sipa: it can evaluate constant terms at compile-time if it sees it as "easy"
10:08:28 <clsmith_> *0
10:08:34 <mm_freak> sipa: it evaluates exactly as much as you tell it to
10:08:39 <mm_freak> evaluation is based on strictness and demand
10:08:48 <hpc> or what other people say :P
10:09:02 <mm_freak> execution demands and functions/constructors can be strict
10:09:28 <mm_freak> finally you can also add explicit dependencies using seq
10:10:13 <clsmith_> why is seq necessary, ever?
10:10:17 <clsmith_> just efficiency?
10:10:48 <hpc> clsmith_: yeah
10:10:55 <hpc> clsmith_: it can make some things asymptotically faster
10:11:01 <hpc> ...or slower, if you do it wrong
10:13:53 <mm_freak> seq can also be used for breaking the monad laws =)
10:14:27 <parcs_> hpc: do you have an example where asymptotics change due to seq?
10:15:03 <hpc> parcs_: (fix id) `seq` 5
10:15:15 <hpc> (admittedly a pathological example)
10:15:16 <mm_freak> parcs_: foldl'
10:15:28 <mm_freak> changes memory behaviour asymptotically
10:16:00 <parcs_> oh right
10:18:15 <roconnor> mm_freak: seq can be used for breaking the category laws
10:22:24 <sipa> roconnor: how so?
10:22:33 <sipa> (except for causing non-termination)
10:23:17 <roconnor> well, if you take the likely mistaked idea that the laws applies to partial values then I think you can break associativity of . in some obsurce way
10:23:25 <roconnor> *mistaken
10:23:49 <roconnor> probably the left or right identity laws as well
10:53:28 <Veinor> hmm
10:53:57 <Veinor> i'm trying to decide whether my 'quantity with a unit' datatype should be data Quantity a = Quantity Unit a or data Quantity a = (Num a) => Quantity Unit a
10:58:14 <monochrom> data Quantity a = Quantity Unit a. save the Num for actual functions
10:59:57 <monochrom> rationale: if you will export the type as abstract, who cares. if you will export the type as concrete, why add Num to forbid other people's novel use.
11:00:19 <yitz> Veinor: i agree with monochrom. Class constraints on data types don't add anything useful.
11:04:28 <mm_freak> Veinor: i use the vector-space package for a monetary type
11:04:49 <mm_freak> it captures the difference between scalar and vector multiplication
11:05:12 <mm_freak> newtype GenMoney c a = GenMoney a
11:05:39 <mm_freak> instance (Currency c, Num a) => VectorSpace (GenMoney c a)
11:05:57 <mm_freak> works quite well
11:08:40 <hpaste> 2 pasted “1” at http://hpaste.org/54831
11:10:54 * roconnor agrees with yitz
11:11:48 <roconnor> mm_freak: too bad vector-space uses a zillion extensions
11:12:14 <Yankovsky> hi there!
11:12:39 <Yankovsky> Can't decide what to learn first Haskell or Lisp
11:12:49 <roconnor> Yankovsky: what do you already know?
11:13:04 <Yankovsky> C# java
11:13:04 <sipa> Yankovsky: people might be somewhat biased here :)
11:13:08 <roconnor> also replace Lisp with Scheme in your decision
11:13:08 <Yankovsky> )
11:13:15 <Yankovsky> i know
11:13:21 <byorgey> and replace Scheme with Racket
11:13:24 <Yankovsky> but anyway i want to learn both of them
11:13:32 <roconnor> byorgey: oh really?
11:13:39 <byorgey> roconnor: the name has changed!
11:13:44 <roconnor> whoa?
11:13:48 <byorgey> I know right
11:13:49 <Yankovsky> i ve already bought two books
11:13:52 <Yankovsky> Land of Lisp
11:13:54 <roconnor> WTF?
11:14:01 <Philippa> roconnor: eh, both're good. Encountering a proper dynamic system is pretty much down to that or Smalltalk variants in practice still, for example
11:14:01 <Yankovsky> and Learn Haskell for great good
11:14:15 <byorgey> Yankovsky: both are great books
11:14:30 <parcs_> i didn't like land of lisp
11:14:40 <hiptobecubic> it's a good song
11:14:44 <hiptobecubic> if that helps
11:15:06 <roconnor> Yankovsky: anyhow, I think you should learn Agda.
11:15:08 <roconnor> :)
11:15:20 <roconnor> hmm
11:15:28 <Yankovsky> I don't know what it is)
11:15:30 <roconnor> though in practice there may not be enough material to do that well
11:15:36 <Yankovsky> I like "Try Haskell" console
11:15:38 <roconnor> :/
11:15:42 <Yankovsky> cool
11:15:52 <bfig> hello, i'm running into trouble installing Vty
11:16:18 <byorgey> roconnor: ah, I guess it's only PLT Scheme which changed its name to Racket, but that's the implementation you want to use for learning
11:16:19 <bfig> cabal tells me i need curses... so i do cabal install curses and it fails after trying to download text
11:16:26 <bfig> any ideas what is going wrong?
11:16:30 <byorgey> Scheme the Language (as defined by RnRS) is still called Scheme
11:16:31 <Yankovsky> What about F#?
11:16:53 <roconnor> Yankovsky: Haskell is a better programming language IHMO than Scheme/Racket/Lisp.  But the error messages can be rather obtuse which makes learning it a bit more challenging than it ought to be.
11:16:55 <byorgey> bfig: paste the error or it didn't happen.
11:17:09 <roconnor> Yankovsky: Ideally you'd learn Helium, if you can find lessons.
11:17:15 <Yankovsky> )
11:17:26 <roconnor> Helium is a Haskell varient with better error messages
11:17:46 <mm_freak> roconnor: i use a zillion extensions, too, particularly those that vector-space uses =)
11:18:07 <bfig> byorgey, i just did cabal install text and got through the problem... now it asks me for other stuff. let me get back to you if i have any other problems :)
11:18:19 <Freejacker> what language is Singularity likely to be achieved in?
11:18:38 <roconnor> mm_freak: UndecidableInstances?
11:19:58 <roconnor> maybe I should edit learn you a haskell and trim it down to support Hellium
11:20:07 <roconnor> Learn you a Helium for somewhat good
11:20:22 <_Mikey> XD
11:20:27 <Yankovsky> nice community!
11:20:47 <mm_freak> roconnor: ok, not that one
11:21:04 <roconnor> Freejacker: lisp
11:21:07 <bfig> it is complaining now that it needs C libraries ncursesw and panel. ncursesw dev is findable through synaptic, but 'panel'... any ideas which one it is?
11:21:09 <mm_freak> anyway, vector-space is a nice package…  i like it
11:21:20 <roconnor> Freejacker: er scratch that
11:21:22 <roconnor> Freejacker: php
11:21:31 <sipa> loi
11:21:32 <roconnor> no
11:21:40 <roconnor> Freejacker: I'll change back: Lisp
11:21:41 <mm_freak> Freejacker: Singularity?
11:22:05 <roconnor> mm_freak: An AI that is intellegent enough to improve it's own code.
11:22:15 <roconnor> to make it more intellegent
11:22:25 <mm_freak> ah
11:22:42 <mm_freak> lisp is a good choice for that
11:22:47 <roconnor> mm_freak: http://penny-arcade.com/patv/episode/the-singularity
11:24:19 <mm_freak> i wonder what language will be used to achieve total static checking of everything
11:24:26 <parcs_> bfig: libpanel is an ncurses library
11:24:27 <mm_freak> "please adjust the universe"
11:24:36 <roconnor> mm_freak: Epigram 2
11:24:39 <roconnor> no
11:24:40 <roconnor> mm_freak: Epigram 3
11:24:41 <parcs_> bfig: or rather, it comes with ncurses
11:24:50 <bfig> if you typecheck the universe you kill us all
11:25:02 <_Mikey> :t runState
11:25:03 <lambdabot> forall s a. State s a -> s -> (a, s)
11:25:21 <Yankovsky_> What about Haskell on windows?
11:25:28 <roconnor> runState is so backwards
11:25:37 <sipa> Yankovsky_: download the haskell platform
11:25:39 <roconnor> should be State s a -> s -> (s, a)
11:25:43 <mm_freak> @where haskell platform
11:25:44 <lambdabot> http://haskell.org
11:25:49 <_Mikey> hmm?
11:25:49 <mm_freak> @where "haskell platform"
11:25:49 <lambdabot> I know nothing about "haskell.
11:26:02 <roconnor> (s,) is a nice functor
11:26:04 <mm_freak> Yankovsky_: http://hackage.haskell.org/platform/
11:26:17 <Yankovsky_> Thanks!
11:26:18 <roconnor> (,s) doesn't even work
11:26:43 <_Mikey> oh,
11:26:51 <bfig> holy fucking shit
11:26:54 <_Mikey> ??
11:27:04 <bfig> a bomb just went off outside my house.
11:27:11 <bfig> sorry, that was for another window
11:27:11 <_Mikey> woah
11:27:17 <_Mikey> no worries
11:27:36 <_Mikey> bfig, where do you live?
11:27:42 <bfig> UrUgUaY
11:27:47 <bfig> it's just some assholes with fireworks
11:27:52 <_Mikey> oh..
11:27:53 <bfig> and they threw it right next to the goddamn window
11:28:01 <monochrom> "my brain has just exploded"
11:28:03 <_Mikey> kids these days :)
11:28:08 <roconnor> bfig: do you live in the Iraqi Green Zone?
11:28:13 <bfig> they handle quite a lot of firepower....
11:28:18 <bfig> roconnor, UrUgUaY
11:28:42 <sipa> that's a lot of u's
11:28:56 <_Mikey> monochrom, give me all the bits that know about monads please!
11:29:02 <bfig> parcs_ cabal is complaining i don't have it
11:30:08 <parcs_> bfig: ok
11:30:10 <parcs_> get it
11:30:23 <bfig> bah, this is absurd... now i installed ncurses (instead of ncursesw) and it worked
11:30:24 <_Mikey> cabal install everything pls
11:30:35 <bfig> why are there ncurses and ncursesw ?
11:31:06 <bfig> and why are the dependencies so bizarre? shouldn't it need ncurses and ncursesw instead of 'panel', which sounds as generic as 'os'
11:33:32 <parcs_> complain about that in #ncurses
11:33:37 <bfig> yeah! compiling vty already :D
11:33:43 <mm_freak> when using Applicative instead of Arrow, i seem not to get along without the ugly side channels, just that now i have to express them explicitly
11:33:49 <mm_freak> i think i still prefer Arrow over Applicative
11:34:23 <bfig> what are arrows good for?
11:34:35 <mm_freak> bfig: in my case automata for AFRP
11:34:39 <mm_freak> those are not monads
11:34:44 <bfig> AFRP?
11:34:53 <mm_freak> arrowized functional reactive programming
11:34:58 <bfig> lol
11:37:07 <mm_freak> also i don't seem to find a really good Applicative-based equivalent for ArrowChoice, only a straightforward translation, and you really don't want to use that one without syntactic sugar
11:39:37 <mm_freak> Cale: btw, now i'm at up to one million FPS with netwire without an ArrowPair preprocessor =)
11:39:43 <mm_freak> for moderately complicated signal networks
11:39:58 <mm_freak> thanks for your support and the discussions
11:40:51 <`Zerax`> Is there some comparison of the numerous available GUI libraries and bindings for Haskell application development?
11:40:56 <bfig> do you feel somebody without serious training can do with haskell?
11:41:15 <mm_freak> bfig: training in what?
11:41:20 <bfig> `Zerax`, there is wxHaskell, that is pretty fine
11:41:23 <MostAwesomeDude> bfig: I don't think that that question depends on the language.
11:41:39 <bfig> how can it not depend on language?
11:41:48 <MostAwesomeDude> `Zerax`: qt, gtk, wx are the big three. They all have their own up- and downsides independent of language bindings.
11:42:03 <MostAwesomeDude> bfig: Because the answers don't depend on which language you're learning. :3
11:42:10 <`Zerax`> Ah.
11:42:23 <bfig> MostAwesomeDude, that is a tautology assuming you are right, but why is that?
11:42:30 <mm_freak> MostAwesomeDude: really?  what about PHP?  haskell took me months to really pick up
11:42:34 <`Zerax`> To be honest, as I'm fairly familiar with qt on native, the idea of using it with Haskell is pretty horrific.
11:42:38 <bfig> why is it harder to train a haskell programmer than a java programmer?
11:42:51 <MostAwesomeDude> bfig: Personal experience in a university setting, training lots of young programmers.
11:43:03 <mm_freak> you can learn PHP in two hours…  it turns every idiot into something resembling a programmer
11:43:07 <`Zerax`> But I'll take a look at gtk, and wx, thanks.
11:43:08 <MostAwesomeDude> bfig: It's not. It's easier for a Java programmer to appear to be competent due to Eclipse.
11:43:28 <bfig> what happens when appear gets close to competent?
11:43:29 <MostAwesomeDude> mm_freak: You can't learn *good* PHP in two hours. Learning enough of PHP to be able to compensate for its brain-damage takes a long time.
11:43:32 <bfig> sometimes you just need a monkey...
11:43:46 <cking> hey MostAwesomeDude, have you ever taught Erlang?
11:43:48 <mm_freak> bfig: actually teaching haskell isn't that hard…  it's easier for people without any programming experience
11:43:59 <cking> Or OCaml? As a question of pure curiosity.
11:44:03 <bfig> i had a real real struggle with monads
11:44:05 <MostAwesomeDude> bfig: It is totally possible and legal to write your Haskell as an entire do-block of main. Just like C, and just as poor.
11:44:06 <mm_freak> MostAwesomeDude: PHP doesn't force you to do that
11:44:14 <MostAwesomeDude> mm_freak: ===, !==, $$
11:44:18 <monochrom> teaching java is harder than teaching haskell because of subtyping
11:44:27 <MostAwesomeDude> cking: Only to myself, and I didn't finish learning Ocaml.
11:44:32 <bfig> i literally spent months trying to understand the abstraction
11:44:35 <monochrom> in fact, these days, subtyping mixed with parametricity
11:44:51 <mm_freak> MostAwesomeDude: …?
11:44:56 <MostAwesomeDude> When I teach Python to new programmers at work, the most laborious part is unteaching them all of their Java.
11:44:57 <bfig> what is subtyping and parametricity?
11:45:05 <MostAwesomeDude> mm_freak: Sorry, your Unicode isn't showing up.
11:45:11 <mm_freak> MostAwesomeDude: ...?
11:45:34 <monochrom> parametricity is for example id :: a->a. subtyping is Liskov substitution
11:45:42 <MostAwesomeDude> mm_freak: Getting the weak, easily-coerced types to line up in PHP is a PITA. Also. which order are implode() and explode()'s arguments in?
11:46:08 <mm_freak> MostAwesomeDude: my point =)
11:46:20 <`Zerax`> Learning any language to an advanced level is a large time commitment, I think the only difference between languages is whether you actually learn transferable knowledge because of it.
11:46:22 <mm_freak> PHP rather let's you write a buggy program
11:46:40 <MostAwesomeDude> mm_freak: My point was that mastery of a language is dependent on the time committed and not the language learned.
11:46:44 <hpc> `Zerax`: and how long it takes to get to that advanced level
11:46:47 <mm_freak> when starting with haskell and coming from a language like PHP it can be quite a struggle to get past the type checker at the beginning
11:47:00 <`Zerax`> True enough
11:47:00 <mm_freak> MostAwesomeDude: it also depends on your present knowledge
11:47:01 <hpc> `Zerax`: it took me about two years to learn java and all the "design patterns"
11:47:08 <MostAwesomeDude> But that's the unlearning problem. Everybody's second language is more difficult than the first.
11:47:20 <monochrom> you can easily troll an OOP community by asking sincerely "a square is a rectangle, true or false? a rectangle is a square, true or false?" that will start a flame war.
11:47:23 <hpc> i still don't consider myself to be "advanced" in haskell
11:47:23 <mm_freak> learning haskell is much easier for people with no programming experience than for people with experience in PHP, java or C++
11:47:36 <MostAwesomeDude> Because you don't need to just learn the new language, but also the underlying schemas required to hold both the new and old language in comparison with each other.
11:48:36 <monochrom> whereas in the haskell community you can't even start a controversy with "everything is a function, true or false?" they will answer "false" unanimously
11:48:47 <mm_freak> hehe
11:48:48 <luite> mm_freak: is that really true? people keep saying that, but I just don't really believe it
11:49:14 <mm_freak> luite: it's my experience
11:49:17 <MostAwesomeDude> monochrom: Python: Everything is an object. You can have class Square(Rectangle) or class Rectangle(Square) but not both. Most of the OOP trolls don't work in object-*based* languages.
11:49:32 <cking> I'm finding Java makes more sense than weird-ass "objects", and it's my first language.
11:49:57 <mm_freak> luite: when you teach haskell to a programmer, they will ask you weird questions all the time, and your answers can confuse them more than help them at the beginning
11:50:22 <MostAwesomeDude> At some point, you start to see all of the bytes and ideas behind everything, and you stop caring about your language as anything more than a way to express those bytes and ideas.
11:51:04 <luite> mm_freak: I think that people with programming experience expect to be more productive quicker, so they try to take shortcuts, relating concepts to things they already know, not always succesfully... but I doubt it really make much of a difference in the end
11:51:19 <monochrom> MostAwesomeDude, either one you pick, there is controversy and potential breakage of the Liskov substitution principle
11:51:21 <cking> MostAwesomeDude, and your programs become challenges of "How do I implement my abstract idea?" right?
11:51:38 <cking> I'm finding Java = I'm finding Haskell.
11:51:48 <MostAwesomeDude> cking: Exactly.
11:52:17 <MostAwesomeDude> monochrom: Python's types aren't checkable syntactically. It's okay if you break Liskov substitution because Pythonic polymorphism doesn't require it.
11:52:44 <monochrom> but runtime behaviour breaks
11:52:51 <MostAwesomeDude> monochrom: What matters in Python is that your MRO is unambiguous, and there *is* a declaration-time checker for that.
11:52:54 <sbi> lol
11:53:15 <MostAwesomeDude> monochrom: Remember, duck typing means never having to explain that your Square is actually a RectangleWithSpocksBeardGluedOn.
11:54:25 <monochrom> sure, but depending on details, a square object could break a context that expects a rectangle object, and vice versa. I carefully say object here.
11:54:55 <MostAwesomeDude> Oh, sure, because at no time is it actually guaranteed that an object provides the methods and attributes declared on its class.
11:55:40 <MostAwesomeDude> It's the "we're all adults here" approach: Declare in your docs what you expect people to do, and if it breaks, they get to keep the pieces since you won't catch their exceptions.
11:56:39 <MostAwesomeDude> Anyway, Python isn't on-topic for #haskell, right? :3
11:58:09 <cking> Blind idiot question, what does a backslash signify? say in arr f :: \s -> \t -> f (s t)
11:58:19 <monochrom> lambda
11:58:20 <MostAwesomeDude> cking: Lambda.
11:58:39 <gbacon> > (\x -> x + 3) 5
11:58:40 <lambdabot>   8
11:59:42 <gbacon> ?ty \s -> \t -> f (s t)
11:59:43 <lambdabot> forall t t1 t2. (SimpleReflect.FromExpr (t1 -> t2)) => (t -> t1) -> t -> t2
12:00:22 <monochrom> @type let f s t = f (s t) in f
12:00:22 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
12:00:22 <lambdabot>     Probable cause: `f' is applied to too few arguments
12:00:23 <lambdabot>     In the expression: f (s t)
12:00:26 <monochrom> hehe
12:02:32 <cking> okay, so, in English, arr f means "some anonymous function s, bound to some anonymous function t, lifted to some function f over s and t"
12:02:36 <erider> > [x**x | x <- [1,2,3,4]]
12:02:37 <lambdabot>   [1.0,4.0,27.0,256.0]
12:03:06 <gbacon> cking: should that have been arr f = ... ?
12:03:31 <cking> actually => is "bound to" isn't it, and -> is "maps to"?
12:03:35 <MostAwesomeDude> cking: "An anonymous function taking a parameter s is an anonymous function taking a parameter t is f of s and t."
12:03:40 <cking> gbacon: in reference to  arr f :: \s -> \t -> f (s t)
12:03:48 <mbetter> => is a constraint on
12:04:06 <MostAwesomeDude> cking: \ is the actual lambda character; it's possible to have, say...
12:04:07 <gbacon> cking: yes. as written, it's an unnatural mixture of notation from different contexts
12:04:10 <cking> "is an"... I like that.
12:04:18 <MostAwesomeDude> @type \ -> "Shh, I'm anonymous!"
12:04:19 <lambdabot> parse error on input `->'
12:04:44 <cking> yeah, I'm just checking I've understood what "lambda" means in that context
12:04:46 <MostAwesomeDude> @type (\ -> "Shh, I'm anonymous!")
12:04:47 <lambdabot> parse error on input `->'
12:04:52 <MostAwesomeDude> Okay, well fine then.
12:05:10 <gbacon> cking: where's this arr you're using coming from? the type of arr from Control.Arrow is arr :: Arrow a => (b -> c) -> a b c
12:05:25 <cking> it's the arr from Yampa
12:06:51 <gbacon> cking: lambda creates an anonymous function, so the simple example above of \x -> x + 5 is a function of some Num that maps to another Num where the latter is 5 greater than the former
12:07:31 <gbacon> yes, you can think of the arrow as being similar to the "maps to" arrow in domain -> range notation
12:07:54 <cking> awesome
12:08:34 <erider> brb
12:08:53 <gbacon> cking: so arr is a higher-order function that transforms f into another function
12:10:33 <cking> oops, it's arr :: (a -> b) -> SF a b
12:10:42 <cking> which is less confusing for all parties involved
12:11:39 <gbacon> cking: does the notation make sense? you can think of -> in types as being right-associative, so (a -> b) means a function from A to B
12:11:47 <cking> yup
12:11:54 <cking> no, signal functions make perfect sense
12:12:51 <gbacon> cking: when you see \x -> \y -> ..., that's currying
12:13:07 <gbacon> > (\x -> \y -> x + y) 5 7
12:13:08 <lambdabot>   12
12:13:12 <Cale> Yeah, arr's job is to turn an arbitrary Haskell function into the structure of another instance of Arrow. Unfortunately, its unrestricted use in the Arrow class (and most importantly in the desugaring of proc/do notation) takes away a lot of the purpose of Arrow relative to Monad.
12:15:00 <Cale> The main thing which makes Arrow nice over what Monad has to offer as a choice of combinator library style is that if you're writing a monadic computation, and you have some computation x >>= f, you can't tell anything ahead of time about what f is, while if you're writing in a more arbitrary choice of Arrow, and have f >>> g, then f and g are both values of a datatype that you have some control over
12:15:27 <Cale> and so you might be able to do some optimisation to make the composite more efficient than simply "running f and then running g"
12:16:38 <Cale> But arr sort of spoils this property, because any arr is a black box through which you can't hope to optimise, and the proc/do notation uses arr extensively at basically every line.
12:17:23 * hackagebot hashtables 1.0.1.1 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.1 (GregoryCollins)
12:19:25 <cking> okay, what would \_ -> do mean?
12:19:45 <Cale> \ is lambda, _ is a pattern which matches anything without binding a variable
12:20:03 <Cale> So that's a constant function which produces the given do-expression as its result
12:20:45 <Cale> Make sense, or can I clarify that more?
12:21:06 <cking> I'll get back to you when I can valuate properly if it makes sense or not :P
12:21:19 <Cale> > (\_ -> 5) 3
12:21:21 <lambdabot>   5
12:21:26 <Cale> > map (\_ -> 5) [1..10]
12:21:27 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
12:21:39 <Cale> > map (\k -> 5) [1..10]
12:21:41 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
12:22:01 <Cale> It's the same as \x -> do ... where x is a fresh choice of variable
12:24:25 <gwern> lambdabot: @join #lesswrong
12:25:06 <cking> yeah, for maths stuff that makes sense
12:25:17 <cking> but I'm trying to wrap my head around how it's being used in this example
12:25:21 <Cale> okay :)
12:25:25 <Cale> what's the example?
12:26:31 <hpaste> wiki pasted “Animas reactimation example” at http://hpaste.org/54834
12:26:44 <cking> under "sense"
12:26:49 <cking> which is part of reactimate
12:27:24 <mizu_no_oto> Are there any current tutorials for parsec?
12:28:36 <mizu_no_oto> It seems that the switch to 3.0.0 changed a lot of the types, and AFAIK, most of the tutorials are based off of 2.*.*
12:29:16 <Cale> cking: okay, so reactimate is really poorly documented in the current version of the Animas Haddock, but the original Yampa source code documented the parameters to it better :P
12:29:28 <Cale> http://hackage.haskell.org/packages/archive/Yampa/0.9.2.3/doc/html/src/FRP-Yampa.html#reactimate -- scroll up a little to see the comment
12:29:51 <mizu_no_oto> In particular, I'd like to figure out how to compose two parsers
12:30:55 <Cale> So, the first argument to the sense function is supposed to represent whether or not the action is allowed to block, but awkwardly, they never put this argument to any real use. :P The version of reactimate in Animas is identical to the original Yampa code, and it always passes False for that parameter.
12:31:13 <Cale> (which is really kinda derpy, but there you go)
12:31:33 <Cale> So that's why the lambda, to ignore that useless parameter
12:31:44 <Cale> mizu_no_oto: Compose in what way?
12:31:57 <Cale> mizu_no_oto: The new Yampa isn't that different from the old ones.
12:32:07 <Cale> In terms of how you actually build your parsers
12:32:30 <`Zerax`> Parsec? :)
12:32:47 <Cale> `Zerax`: A really lovely parser combinator library
12:32:55 <Philippa> mizu_no_oto: there are type synonyms for the old ones last I saw, and if you use it like it was the old version it should mostly just work
12:33:06 <Cale> Yeah
12:33:09 <`Zerax`> I was meaning that perhaps you meant Parsec opposed to Yampa.
12:33:24 <Cale> `Zerax`: I'm answering two separate questions :)
12:33:27 <Philippa> (admittedly last I saw was when I mentored the SoC project - oops? :p)
12:33:28 <`Zerax`> Cunning
12:33:36 <cking> no, I think Cale mistagged mizu instead of me, lol
12:33:45 <Cale> oh, did I?
12:33:56 <cking> "The new Yampa isn't that different from the old ones"
12:33:57 <Cale> oh, derp
12:33:59 <Cale> yeah
12:34:03 <mizu_no_oto> ^_^
12:34:07 <Cale> That should have been Parsec
12:34:22 <Cale> Well, it's true too
12:34:28 <cking> okay, that makes more sense
12:34:38 <Cale> The new Yampa, which I guess is Animas, isn't that different from the old Yampa, which is Yampa :P
12:35:27 <`Zerax`> mizu_no_oto: If you had some specific problem you were looking at solving, perhaps it would be easier to give you a concrete answer.
12:35:30 <MostAwesomeDude> Hey, is there any convenient way to have a record with replaceable values? The idea is that I want to easily say "This record that I just had, I want a copy of it, but with this field changed."
12:36:04 <roconnor> MostAwesomeDude: foo{bar = baz}
12:36:07 <Cale> myRecord { field2 = newValue }
12:36:39 <MostAwesomeDude> I know about records, but I didn't see anything along the lines of how to replace just a single field in a record.
12:36:50 <Cale> MostAwesomeDude: ^^ that's how you do it
12:36:53 <roconnor> MostAwesomeDude: for more sophisticated stuff, use the data-lens package.
12:36:56 <cking> so in my Animas example there, the "lambda of anything" just means "this is going to evaluate False anyway, so just proceed on to the do block"
12:37:04 <MostAwesomeDude> Oh, sorry, I thought you were showing me how to declare a record. :3
12:37:05 <Cale> cking: yeah
12:37:14 <Cale> MostAwesomeDude: note the lowercase m
12:37:39 <Cale> MostAwesomeDude: you just use your record value and put braces after it with the field updates
12:37:46 <mizu_no_oto> hmm
12:38:24 <MostAwesomeDude> Cale: Nifty. I guess I must have somehow missed that when I learned records.
12:38:54 <shachaf> (field2 ^= newValue) myRecord
12:39:21 <Cale> Yeah, the record syntax isn't that great, but this is one use-case that was anticipated by it :)
12:39:28 <mizu_no_oto> so something like "anyChar >>= \x -> anyChar >>= \y -> anyChar >>= return [x,y]" types, but  "anyChar >>= \x -> anyChar >>= \y -> anyChar >>= return [x,y]" doesnt.  I guess that makes sense, so I guess I'll have to do something like "anyChar >>= \x -> anyChar >>= \y -> anyChar >>= \ignored -> return [x,y]", but that seems ugly
12:39:45 <Cale> mizu_no_oto: use >>
12:39:54 <Cale> mizu_no_oto: Or just use do-notation
12:39:54 <mizu_no_oto> >_<
12:40:13 <Cale> do x <- anyChar; y <- anyChar; return [x,y]
12:40:18 <Cale> er
12:40:23 <Cale> do x <- anyChar; y <- anyChar; anyChar; return [x,y]
12:40:44 <MostAwesomeDude> do-notation for parsers helps so much.
12:41:01 <cking> okay Cale, thanks for your help. I better get back to work :)
12:41:04 <`Zerax`> Also there are some cases when making use of the Applicative instance is useful.
12:41:18 <Cale> Or:  fmap (take 2) (replicateM 3 anyChar)  ;)
12:41:29 <mizu_no_oto> ah
12:41:54 <mizu_no_oto> going through and uncommenting my source, I see that my problem is somehow due to the monomorphism restriction
12:41:56 <roconnor> or (replicateM 2 anyChar <* anyChar)  ?
12:42:01 <Cale> Without the do-sugar, it'd look like:
12:42:10 <roconnor> er
12:42:15 <roconnor> (replicateM 2 anyChar <$ anyChar)  ?
12:42:16 <Cale> anyChar >>= \x -> anyChar >>= \y -> anyChar >> return [x,y]
12:42:20 <roconnor> something like that
12:42:40 <mizu_no_oto> i.e. my code compiles if I have {-# OPTIONS_GHC -XNoMonomorphismRestriction #-}, but it doesn't compile if i don't have that
12:43:04 <aristid> 6:t (<*)
12:43:08 <Cale> btw, {-# LANGUAGE NoMonomorphismRestriction #-}
12:43:10 <mizu_no_oto> and complains:   No instance for (Text.Parsec.Prim.Stream s m Char)
12:43:11 <mizu_no_oto>       arising from a use of `nchars' at tsuru.hs:42:25-33
12:43:13 <mizu_no_oto>     Possible fix:
12:43:13 <shachaf> ap (<$) (replicateM 2) anyChar
12:43:14 <mizu_no_oto>       add an instance declaration for (Text.Parsec.Prim.Stream s m Char)
12:43:16 <mizu_no_oto>     In a stmt of a 'do' expression: issueCode <- nchars 12
12:43:16 <aristid> :t (<*)
12:43:17 <Cale> but yeah, not too surprising
12:43:17 <mizu_no_oto>     In the expression:
12:43:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:43:18 <shachaf> Er, that's backwards.
12:43:33 <Philonous> mizu_no_oto:  That problem should go away if you add type declarations to all you top level definitions
12:43:47 <mizu_no_oto> D'oh
12:43:52 <Cale> mizu_no_oto: Giving an explicit type signature to nchars will solve the problem, but for parsers, that can be really annoying sometimes.
12:43:53 <aristid> :t replicateM 2 anyChar <* anyChar
12:43:54 <lambdabot> Not in scope: `anyChar'
12:43:54 <lambdabot> Not in scope: `anyChar'
12:44:05 <Cale> mizu_no_oto: just turning off the MR might be your best option
12:44:21 <aristid> :t replicateM 2 (return 'X") <* (return 'Y')
12:44:22 <lambdabot>     lexical error in string/character literal at character '"'
12:44:30 <aristid> :t replicateM 2 (return 'X') <* (return 'Y')
12:44:31 <lambdabot> forall (f :: * -> *). (Monad f, Applicative f) => f [Char]
12:44:52 <aristid> roconnor: i think <* was right
12:44:52 <Cale> also if nchars were a function, (though I suspect it's actually a Parser), you could add an explicit parameter to the definition to side-step the MR
12:44:56 <roconnor> aristid: ok
12:44:59 <Philonous> mizu_no_oto:  But the monomorphism restriction is evil, I always add -XNoMonomorphismRestriction to the top of all haskell files before I even write anything
12:45:17 <Cale> Use LANGUAGE instead of OPTIONS_GHC when you can.
12:45:25 <roconnor> Philonous: X-)
12:45:27 <aristid> Philonous: alias ghc=ghc -XNoMonomorphismRestriction :D
12:45:28 <mizu_no_oto> nchars  :: (Text.Parsec.Prim.Stream s m Char) => Int -> Text.Parsec.Prim.ParsecT s u m [Char]
12:45:45 <Cale> It's nicer syntactically, and gives other compiler authors a little more hope that they can compile your code ;)
12:45:47 <mizu_no_oto> i.e. nchars 3 is a parser that parses 3 characters
12:46:20 <shachaf> Cale: "other compiler authors" for Haskell? Sounds like some sort of bogeyman.
12:46:54 * shachaf agrees about LANGUAGE, of course.
12:46:57 <Cale> shachaf: There are a few little projects, though I haven't really heard much about them lately.
12:47:09 <osaunders> I’ve been trying to come up with a way to create a bidirectional map without storing the value twice (assume it could be large). Anyone have any suggestions how I might approach this?
12:47:46 <shachaf> osaunders: Well, presumably it's only a pointer to the value that would be stored?
12:47:47 <Cale> osaunders: Something like a quadtree?
12:48:01 <shachaf> Oh, the map could be large, not the value.
12:48:05 <mm_freak> MonadRandom defines:  instance MonadRandom m => MonadRandom (StateT s m)
12:48:36 <mm_freak> that's quite unfortunate
12:48:58 <hpaste> osaunders pasted “Bimap without double storage” at http://hpaste.org/54835
12:49:08 <osaunders> ^ my best attempt so far
12:49:23 <Cale> osaunders: err...
12:49:30 <Cale> There are two Maps in that
12:49:46 <osaunders> Cale: Yep but only one instance of v
12:49:49 <Cale> So you've saved exactly zero space by doing that
12:49:55 <mm_freak> does anyone know a better alternative to MonadRandom that doesn't assume that no programmer would ever store random number state using StateT?
12:50:14 <Cale> Because the secondary map only ever holds a second pointer to each of the keys in the first map
12:50:18 <Cale> anyway
12:50:28 <osaunders> Cale: I don’t mind storing a couple of integers extra, but v could be a very large bytestring in this case
12:50:39 <shachaf> osaunders: It's still not going to copy it.
12:50:41 <tlorenz>  Hey, I have a problem with the (=~) operator
12:50:44 <Cale> Actually, this will use a little more space than just two maps
12:50:50 <Cale> because you have additional Int values
12:50:53 <shachaf> tlorenz: Don't we all? :-)
12:51:13 <Saizan> osaunders: you wouldn't get a copy of the bytestring in the Maps, you'll only have pointers to the bytestrings in them
12:51:14 <Cale> tlorenz: Parsec
12:51:16 <tlorenz> while working my way through real world haskell i tried:  "i foobarbar a quux" =~ pat :: [(Int,Int)]
12:51:37 <osaunders> Saizan: WHat?!
12:51:41 <Cale> tlorenz: ah, the library has changed since the book was written ;__;
12:51:41 <osaunders> God dammit
12:51:53 <osaunders> Is that specific to byte strings?
12:51:55 <Cale> osaunders: see what I mean?
12:51:57 <Cale> osaunders: no
12:51:57 <Saizan> nope
12:52:00 <tlorenz> I get this error: No instance for (RegexContext Regex [Char] [(Int, Int)])       arising from a use of `=~'
12:52:04 <shachaf> osaunders: No, it's how (GHC) Haskell works.
12:52:06 <Cale> osaunders: Every Haskell value is a pointer to code.
12:52:08 <shachaf> osaunders; Immutable values and all.
12:52:19 <osaunders> I asked that question on here before and somebody said different
12:52:21 <Cale> osaunders: which returns the value when jumped into
12:52:22 <osaunders> Cale: Yes I do now
12:52:22 <Saizan> osaunders: it's different only with unboxing
12:52:23 <tlorenz> @Cale that's what I wanted to confirm
12:52:24 <lambdabot> Unknown command, try @list
12:52:46 <osaunders> FFS I might as well just used BiMap then
12:52:51 <mm_freak> Cale: as said, from my benchmarks i don't have the impression that you really need to optimize 'arr' that much
12:52:54 <Cale> tlorenz: To be perfectly honest, that regex library is kinda awful :(
12:53:07 <shachaf> The new API is x =~ y :: [(Int,Int,Double,[Bool],Maybe (Maybe Char))]
12:53:13 <Cale> tlorenz: It out-perls perl by somewhat abusing the typeclass system
12:53:15 <shachaf> (The previous statement is untrue.)
12:53:20 <shachaf> Oops, sorry about that, Cale.
12:53:28 <tlorenz> so what is the new way of doing this? I will use Parsec in the future, but want to understand what I'm doing first
12:53:40 <Cale> shachaf: Oh, sorry, is it yours? :)
12:54:02 <shachaf> Cale: I meant to "the previous statement is untrue" my own statement, but I wasn't fast enough.
12:54:07 <Cale> oh
12:54:34 <Cale> mm_freak: It's not really optimising arr that's important, it's getting arr out from in between other pairs of things which you can optimise
12:54:39 <tlorenz> thanks @shachaf
12:55:04 <Cale> tlorenz: okay, let me look up how to do this :)
12:55:11 <Cale> tlorenz: shachaf was joking
12:55:23 <shachaf> tlorenz: (The "@person" syntax isn't going to work very well in this IRC channel, partly because the bot responds to it.)
12:55:38 <shachaf> tlorenz: And, yes, I was just joking about how silly the (=~) API is. Apologies.
12:56:01 <Cale> http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base-RegexLike.html#v:matchM -- the list of instances for RegexContext is here
12:56:07 <tlorenz> shachaf: sorry (too much twitter)
12:56:43 <tlorenz> Cale: thanks
12:57:05 <Cale> tlorenz: RegexLike a b => RegexContext a b (AllMatches [] (MatchOffset, MatchLength))
12:57:11 <Cale> I think that's the one you're interested in
12:57:23 <monochrom> @monochrom hi there!
12:57:24 <lambdabot> Unknown command, try @list
12:57:26 <Cale> So, you can write...
12:57:43 <Cale> getAllMatches ("i foobarbar a quux" =~ pat) :: [(Int, Int)]
12:57:48 <Cale> and have it work, I believe
12:57:53 <Cale> I'll check too :)
12:58:32 <Cale> well, maybe lambdabot...
12:58:35 <Cale> > getAllMatches ("i foobarbar a quux" =~ pat) :: [(Int, Int)]
12:58:37 <lambdabot>   Not in scope: `pat'
12:58:40 <Cale> oh of course
12:58:57 <Cale> > getAllMatches ("i foobarbar a quux" =~ "bar") :: [(Int, Int)]
12:58:58 <lambdabot>   [(5,3),(8,3)]
12:59:11 <Cale> > getAllMatches ("i foobarbar a quux" =~ "b.*") :: [(Int, Int)]
12:59:12 <lambdabot>   [(5,13)]
12:59:27 <Cale> that's not exactly what I'd consider "all matches", derp
12:59:37 <Cale> > getAllMatches ("i foobarbar a quux" =~ "b.*?") :: [(Int, Int)]
12:59:39 <lambdabot>   [(5,13)]
12:59:43 <Cale> well, whatever :P
13:01:10 <ion> :-)
13:01:27 <tlorenz> thanks Cale, this worked perfectly (once you define pat): getAllMatches ("i foobarbar a quux" =~ "bar") :: [(Int, Int)]
13:03:06 <Sgeo> :i (=~)
13:03:26 <Sgeo> Isn't =~ the thing people hate due to the (imo interesting) overloading on the return type?
13:03:36 <Cale> yes, see the link I posted above
13:04:02 <shachaf> "May you live in interesting types."
13:04:08 <Cale> (and then apparently close the silly synopsis tab thingy)
13:05:30 <Cale> Some polymorphism on return type is great, but once you get to the point of having 30 different things all called the same thing, it starts to become pretty questionable what you're doing.
13:05:54 <ion> RegexLike a b => RegexContext a b (b, b, b, [b])
13:05:59 <ion> What does that even do? :-)
13:06:03 <Cale> exactly :P
13:06:28 <ion> I wish those had links to the instance definitions.
13:06:40 <`Zerax`> Well in keeping with the spirit of Regex I suppose.
13:07:19 <Cale> I believe it returns the part before the match, the matched portion, the part after, and the list of matches of parenthesised subexpressions of the regex :)
13:16:48 <tickle`> what's a good name for: maybe a return
13:17:28 <mm_freak> tickle`: maybeM
13:18:23 <Saizan> ?type \a -> maybe a return
13:18:24 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> Maybe a -> m a
13:18:56 <Saizan> maybeM isn't really a good name
13:19:00 <_oz> tickle`: returnDef ?
13:19:53 <mm_freak> returnMaybe
13:20:08 <mm_freak> well, i'd really just leave it as "maybe a return"
13:20:48 <_oz> actually, it is very similar (in type) to fromMaybe
13:20:51 <_oz> :t fromMaybe
13:20:52 <lambdabot> forall a. a -> Maybe a -> a
13:20:59 <tickle`> I came up with fromMaybeM
13:20:59 <_oz> so I suggest fromMaybeM
13:21:09 <_oz> :)
13:21:54 <tickle`> thanks!
13:22:24 * hackagebot zeromq-haskell 0.8.1 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.8.1 (ToralfWittner)
13:41:41 <wavewave> higgs may be discovered finally at 126 GeV. .
13:42:02 <Axman6> :o
13:42:24 <mbetter> it's always in the last place you look
13:42:26 <Axman6> i thought they were saying it was probably non-existant not too long ago
13:42:59 <wavewave> no..  if somebody said so, it's very premature opinion.
13:43:29 <wavewave> On Dec 12, CERN will hold  a press conference.
13:43:48 <mbetter> dec 13
13:44:03 <mbetter> Heuer.s message to all CERN personnel says the December 13 announcements will be .significant progress in the search for the Higgs boson, but not enough to make any conclusive statement on the existence or non-existence of the Higgs.. Presumably they.re waiting for 5 sigma before claiming conclusive proof.
13:44:37 <wavewave> december 13 may be official.
13:45:01 <wavewave> they will meet on 12th and 13th
13:45:52 <mbetter> 126 GeV sounds like a pretty interesting number
13:46:10 <wavewave> it's just in arbitrary unit.
13:46:32 <mbetter> i don't mean the number itself
13:46:40 <wavewave> 126 GeV is one of the hardest point for seeking for higgs.
13:46:42 <mbetter> but how it relates to the standard model
13:48:39 <PhilRod> mbetter: how so?
13:48:41 <wavewave> in SM it's quite natural.
13:49:16 <wavewave> a little higher than we expected from other precision measurement but not too high
13:49:20 <mbetter> i was just reading this:
13:49:43 <mbetter> http://arxiv.org/abs/0912.0208
13:50:37 <mbetter> about SM plus gravity "valid up to arbitrarily high energies"
13:52:55 <mizu_no_oto> Why is there both Text.Parsec and Text.ParserCombinators.Parsec?  They seem to define a lot of the same functions, but Text.Parsec has some (e.g. runParserT ) that aren't in the other one)
13:53:09 <wavewave> it's version 2 and version 3
13:53:28 <mizu_no_oto> So new code should always just use Text.Parsec?
13:53:30 <wavewave> Text.ParserCombinators.Parsec = parsec v.2
13:53:39 <wavewave> Text.Parsec = v3
13:54:12 <mizu_no_oto> Why didn't they just make v3 in Text.ParserCombinators.Parsec?
13:54:34 <MostAwesomeDude> Namespaces are a great idea.
13:54:35 <wavewave> Probably.. some time ago, there was some performance lag in parsec 3
13:55:12 <wavewave> parsec v3 is not backward compatible.
13:55:53 <wavewave> anyway Text.Parsec is better than Text.ParserCombinators.Parsec for brevity in my opinion
14:03:20 <mizu_no_oto> Also, is there a good way to parse something like "randomjunkGOOD_INPUT", given a parser that parses GOOD_INPUT?  That is to say, it's allowable for the parser to fail without consuming input as long as it parses the input after the random garbage has been read through?
14:05:23 <wavewave> use try
14:06:04 <wavewave> if I understand your question correctly.
14:06:12 <jchia> question about class vs instance. Why do we say "class Eq a where ..." and "instance Eq SomeClass where..."? a is a variable because it's lower case and SomeClass is is a type instance because it's MixedCase. Why does haskell require the distinction between 'class' and 'instance' when the use case can be inferred?
14:06:41 <jchia> is there a good reason other than to make it clearer?
14:07:01 <mbetter> instance will be different for different types
14:07:06 <wavewave> class and instance should be different
14:07:26 <wavewave> class keyword is just to declare typeclass
14:07:38 <mbetter> oh, i get what you're asking
14:07:44 <wavewave> instance is for actual definition for a given type.
14:08:10 <jchia> mbetter,wavewave: a related question is, is there a case where "class Eq MixedCase ..." is valid haskell?
14:08:14 <mbetter> wave: i think he's saying that which one you want could be inferred by the token after "class" or "instance"
14:08:36 <parcs_> jchia: no, but instance Eq a is
14:08:46 <wavewave> jchia: no .
14:08:50 <mizu_no_oto> wavewave:  "The parser try p behaves like parser p, except that it pretends that it hasn't consumed any input when an error occurs."  I don't want to pretend that I haven't consumed any input, I'd like to skip over the random junk that may or may not be preceeding the "payload" of the valid stuff I can parse
14:09:09 <parcs_> jchia: thus you must be able to discern 'class Eq a' from 'instance Eq a'
14:09:45 <jchia> parcs_: ok, i haven't come across "instance Eq a" yet. i'm still on page 139 of lyahfgg
14:10:05 <jchia> thanks
14:10:06 <wavewave> mizu_no_oto: how will you signal non-random junk?
14:10:35 <wavewave> mizu_no_oto : by "G"?
14:10:43 <mizu_no_oto> Is this built into parsec, or do I need to make some sort of recursive parser, something like p = try actualParser <|> (anyChar >> p)
14:10:48 <mizu_no_oto> Point
14:10:59 <mzero> mizu_no_oto: so, you want to parse for some leading string, like "HELO", but skip stuff until you find it?
14:11:11 <mizu_no_oto> mzero: exactly
14:11:19 <mzero> mizu_no_oto: you've written it
14:11:30 <mzero> that is what you need - because that *is* the grammar you're trying to parse!
14:11:37 <mizu_no_oto> k
14:11:45 <wavewave> then just use skipTill or something like that
14:12:29 <mzero> 'course depending on what real-world conditions you are expecting, that could be highly in-effiient
14:12:42 <wavewave> i don't remember combinator name correctly now
14:12:48 <mzero> also, don't put the whole acutalGrammar in there - just matching the lead in sequence
14:12:54 <mizu_no_oto> right
14:13:07 <mzero> you don't want to get through 2 MB of parse, to find an error - and then re-try the whole thing one byte later
14:13:27 <mzero> presumably once you've found the lead-in sequence, it will be considered an error if things fail further on
14:13:31 <mizu_no_oto> Well, the thing I'm parsing is fairly short, so it shouldn't really matter
14:13:40 <mizu_no_oto> namely, it's just a packet
14:14:06 <mzero> ah then- unless you're building a high-performance server --- parse away the clearest way!
14:16:01 <mizu_no_oto> Also, what's a good way to get the character corresponding to a certain byte sequence?
14:16:31 <mizu_no_oto> e.g. (char) 0xff, in C
14:17:01 <mizu_no_oto> and not the string corresponding to "FF"
14:17:59 <wavewave> first use Word8
14:18:31 <shlevy> How does haskell represent functions that need closures in memory?
14:19:14 <shlevy> Erm, s/haskell/ghc I suppose
14:19:46 <mizu_no_oto> You might want to check out the STG machine paper, iirc it answers that question
14:19:56 <shlevy> :t toHex
14:19:57 <lambdabot> Not in scope: `toHex'
14:20:03 <shlevy> Hmm
14:20:06 <shlevy> What was it...
14:20:27 <ion> > showHex 42 ""
14:20:28 <lambdabot>   "2a"
14:20:33 <tromp> :t showHex
14:20:34 <lambdabot> forall a. (Integral a) => a -> String -> String
14:20:36 <shlevy> There we go. Use that mizu_no_oto  :)
14:21:02 <mizu_no_oto> shlevy: thanks
14:21:04 <ion> Reading mizu’s question, that’s not it.
14:21:10 <ion> > chr 0xff
14:21:11 <lambdabot>   '\255'
14:21:21 <shlevy> Did I go the wrong way?
14:21:21 <ion> > toEnum 0xff :: Char
14:21:22 <lambdabot>   '\255'
14:22:01 <ion> That’s not exactly (char) 0xff, though. It’s the character representation of U+00FF.
14:22:02 <shlevy> mizu_no_oto: Where is that paper?
14:22:27 <ion> Char isn’t an equivalent of char. ByteString is more like it.
14:22:36 <ion> (Well, char[])
14:22:45 <ion> Word8 is an equivalent to C char.
14:22:46 <mizu_no_oto> http://research.microsoft.com/apps/pubs/default.aspx?id=67083
14:23:04 <ion> Well… actually, Word8/uint8_t, Int8/int8_t.
14:23:12 <tromp> Word8 is unsigned char
14:23:47 <ion> > Data.ByteString.singleton 0xff
14:23:47 <lambdabot>   Not in scope: `Data.ByteString.singleton'
14:24:37 <ion> That’s quite close to (char) 0xff if you’re thinking in terms of C strings and not in terms of int8_t. 0xff :: Int8 in that case.
14:33:42 <Philonous> Is the runtime supposed to release the memory it no longer needs?
14:35:12 <FUZxxl> Philonous: IIRC it didn't until the latest release
14:36:46 <Philonous> FUZxxl: That's 7.2 ?
14:39:05 <FUZxxl> Philonous: 7.3 is the latest release.
14:39:10 <FUZxxl> Philonous: 7.2 is the latest release.
14:39:15 <FUZxxl> (yes, 7.2)
14:39:28 <FUZxxl> Actually 7.2.2
14:39:43 <FUZxxl> But freeing memory is supported for a longer time now
14:40:00 <ClaudiusMaximus> if i have 5 executables in my .cabal file which all have pretty much the same deps, is there any way to avoid the tedious repetition?
14:41:06 <dcoutts__> ClaudiusMaximus: currently, only if you have a lib in the package which all the exes depend on
14:41:06 <lambdabot> dcoutts__: You have 1 new message. '/msg lambdabot @messages' to read it.
14:41:31 <dcoutts__> there's no support yet for "convenience" libs that are there just for sharing, not to be installed
14:41:52 <ClaudiusMaximus> dcoutts__: thanks
14:42:22 <Philonous> FUZxxl:  I just saw the ticket concerning it. It's supposed to be 7.0. That means I'm looking at a real leak. Damn.
14:42:46 <Jafet> Philonous: +RTS -s
14:43:29 <FUZxxl> good night, anyway!
14:44:28 <DanBurton> Have you guys seen this discussion? http://stackoverflow.com/questions/8367426/why-cant-one-put-type-signatures-in-instance-declarations-in-haskell
14:44:33 <FUZxxl> Yes
14:44:46 <DanBurton> I think allowing type signatures in instance decls would be a Good Thing
14:44:46 <FUZxxl> I like the idea of adding redundant signatures.
14:44:52 <FUZxxl> full ack
14:44:58 <DanBurton> :)
14:45:25 <aristid> but they would have to be precisely right. no looser or stronger type declarations allowed
14:45:36 <DanBurton> definitely a noob-friendly idea, since you can check if the type you think it should be is the right type
14:46:35 <DanBurton> aristid: I think a looser type decl would be OK, as long as it is ignored :P
14:46:57 <aristid> DanBurton: no, i think that would lead to confusion.
14:47:13 <DanBurton> you're right, it could
14:47:22 <Jafet> compare = compare' where compare' :: Foo -> Foo -> Ordering; compare' (Foo a) (Foo b) = compare a b
14:47:54 <aristid> Jafet: possible, but ugly:)
14:50:25 <FUZxxl> I would also like the idea to be able to declare more functions than neccessary in a class instance.
14:50:44 <FUZxxl> All superfluous functions are ignored. That has two advantages:
14:51:20 <FUZxxl> 1) subfunctions that are needed by multiple functions of the instance can be shared without lifting them out of the instance
14:51:42 <FUZxxl> 2) If you compile against a library that does not have the functions you define, your code still compiles
14:52:22 <FUZxxl> Any comments?
14:52:44 <Jafet> Patches welcome!
14:53:23 <FUZxxl> Jafet: Well, if you explain me the GHC source first, I am going to do it
14:53:27 <FUZxxl> :ð
14:54:15 <Axman6> FUZxxl: you can provide default definitions for function classes when defining the class
14:54:44 <FUZxxl> Axman6: That's not what I mean
14:54:56 <FUZxxl> I want to allow things like this:
14:55:09 <FUZxxl> instance Show where myFun = ... ; show = ...
14:55:17 <FUZxxl> (myFun is not a member of Show)
14:55:31 <Axman6> you want to be able to extend classes after their definition?
14:55:34 <FUZxxl> The scope of myFun should be limited to the instance
14:55:42 <mauke> ah, I get it
14:55:48 <Axman6> why should it habe anything to do with the class then?
14:55:56 <DanBurton> I'm making a ghc trac ticket right now for the feature request
14:56:14 <FUZxxl> Axman6: Semantics. Sometimes, I am writing instances and multiple methods share some code
14:56:21 <mauke> FUZxxl: I don't understand your advantage #2
14:56:26 <FUZxxl> Naturally, I want to refactor that out
14:56:52 <Axman6> FUZxxl: then just write the functions, and use them inside the instantiation of the class :\
14:56:54 <FUZxxl> But if I want to add another function, I have to do that at top level. This feels semantically incorrect
14:56:55 <Axman6> it's pretty common
14:57:02 <FUZxxl> Yes, I know
14:57:21 <FUZxxl> mauke: For instance, given A class
14:57:27 <FUZxxl> SomeClass
14:57:38 <FUZxxl> version 1.0 of myLibrary defines
14:57:50 <FUZxxl> class SomeClass a wher foo :: ... ; bar :: ...
14:57:58 <FUZxxl> but version 2 also defines member baz
14:58:23 <FUZxxl> If you want to write an instance for both 1.0 and 2.0, you currently have to use the preprocessort.
14:58:25 <FUZxxl> That's uggly.
14:58:41 <mauke> FUZxxl: workaround for #1: instance Class T where { (methodA, methodB) = (..., ...) where { privateFunction = ... } }
14:58:48 <FUZxxl> So why not allow extra functions in an instance that are ignored if not present in the class' declaration?
14:59:04 <FUZxxl> mauke: urgs... that's uggly.
14:59:04 <mauke> because missing definitions aren't an error either
14:59:17 <mauke> so that gets really ugly with misspellings
14:59:19 <Axman6> classes shouldn't be complicated enough that you need to add much to them imo. someone once said all classes should only have one function, and there's definitely some wisdom to that
14:59:29 <FUZxxl> mauke: Why not make it a warning?
14:59:37 <FUZxxl> Axman6: ack
14:59:40 <mauke> FUZxxl: what's the difference?
14:59:48 <FUZxxl> mauke: between what and what?
14:59:53 <mauke> warning and error
15:00:05 <FUZxxl> That you're not forced
15:00:23 <mauke> I don't release code with warnings
15:00:43 <mauke> basically that would solve #2, but not #1
15:00:51 <FUZxxl> There is no reason in forbidding such declarations. It's similar to those extra type declarations DanBurton mentioned
15:01:00 <FUZxxl> mauke: Why not #1?
15:01:15 <mauke> because you can't use that feature without causing compiler warnings
15:01:25 <FUZxxl> The warning is only triggered if an extranous function is not used inside the declaration
15:01:58 <FUZxxl> That would cover most cases. (You don't misspell a function twice, do you?)
15:02:07 <mauke> hmm
15:02:20 <DanBurton> How's this guys? http://hackage.haskell.org/trac/ghc/ticket/5676
15:02:21 <mauke> I think that would work
15:03:27 <FUZxxl> DanBurton: Great! What do you think about my proposal?
15:04:00 <DanBurton> FUZxxl: hold on let me read it :) I was busy writing
15:04:20 <FUZxxl> DanBurton: BTW, why category Compiler and not Compiler (Typechecker)?
15:04:51 <DanBurton> FUZxxl: good idea; I'll change it
15:05:02 <DanBurton> FUZxxl: your idea sounds cool too. You should make a ticket
15:06:05 <FUZxxl> DanBurton: I already changed the category
15:06:13 <DanBurton> FUZxxl: i just saw xD
15:06:15 <DanBurton> thanks
15:07:15 <FUZxxl> It would be really nice to have a category "language" or so
15:10:42 <FUZxxl> What's the markup for lists on the tracker?
15:14:38 <DanBurton> lists?
15:15:09 <FUZxxl> Like
15:15:11 <FUZxxl> 1. foo
15:15:13 <FUZxxl> 2. bar
15:15:15 <FUZxxl> 3. baz
15:15:30 <DanBurton> oh that. no clue. try #
15:16:18 <FUZxxl> okay.
15:19:57 <FUZxxl> DanBurton: Now how's that: http://goo.gl/w2qsT
15:22:06 <zezikaro> may i ask for haskell programming help here? I'm trying to make a recursive function to multiply 3 numbers and i think i've got the idea, but i'm not too sure
15:22:19 <mauke> why recursive?
15:22:23 <FUZxxl> zezikaro: Of course
15:22:24 <mauke> foo x y z = x * y * z
15:22:29 <zezikaro> to learn more
15:22:36 <mauke> about what?
15:23:22 <FUZxxl> good night. See you all tomorrow!
15:23:51 <DanBurton> FUZxxl: g'night. looks good!
15:24:09 <shachaf> foo x y z = const (x*y*z) foo
15:24:23 <mauke> nice!
15:24:24 <FUZxxl> DanBurton: Please help me and correct my wording if neccessary
15:24:31 <FUZxxl> hehe
15:24:47 <FUZxxl> @pl foo x y z = x*y*z
15:24:47 <lambdabot> foo = ((*) .) . (*)
15:24:49 <shurikas> @type (\a -> \b -> \c -> a (b c)
15:24:50 <lambdabot> parse error (possibly incorrect indentation)
15:24:54 <shurikas> @type (\a -> \b -> \c -> a (b c))
15:24:55 <lambdabot> forall t t1 t2. (t1 -> t2) -> (t -> t1) -> t -> t2
15:25:01 <shurikas> @type fmap
15:25:02 <mauke> shachaf++  # excellent recursion
15:25:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:25:05 <shurikas> how is this different?
15:25:18 <mauke> shurikas: one is less general
15:25:50 <azaq23> > let foo x y z = g [x, y, z] where g (x : xs) = x * g xs; g [] = 1 in foo 1 2 3
15:25:51 <lambdabot>   6
15:25:55 <shurikas> @hoogle (f a)
15:25:56 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
15:25:56 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
15:25:56 <lambdabot> Text.Regex.Base.RegexLike getAllTextSubmatches :: AllTextSubmatches f b -> (f b)
15:26:15 <shurikas> I don't get what's so special about functors
15:26:20 <azaq23> @type fmap `asTypeOf` (.)
15:26:21 <shurikas> and why we need them
15:26:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:26:27 <mauke> shurikas: "need"?
15:26:30 <MostAwesomeDude> shurikas: Do you understand monads yet?
15:26:37 <shurikas> not yet
15:26:40 <mauke> shurikas: I don't get what's so special about programs and why we need them
15:26:41 <shachaf> "understand monads" :-(
15:26:44 <azaq23> shurikas: Read the section on functors at learnyouahaskell.com
15:26:44 <shurikas> but will after I understand functors
15:26:53 <shurikas> azaq23, I am :)
15:27:21 <MostAwesomeDude> shachaf: Hey, don't get on me. I didn't get it either until I realized that functors and monads are supposed to be related.
15:27:37 <DanBurton> azaq23: caleskell has (.) = fmap
15:27:42 <Freejacker> i'm learning haskell by watching you chat
15:27:45 <shachaf> MostAwesomeDude: I just dislike the phrase "understand monads" as applied to Haskell.
15:28:00 <Jafet> @quote monads.are
15:28:00 <lambdabot> monochrom says: If you come across "monads are fun!" it's probably Wadler.  If you come across "continuations are fun!" it's probably Appel.
15:28:04 <azaq23> shurikas: functors, like any mathematical abstraction, lets you view things in a different light, which helps you think about things in a different way and see connections which you had not seen
15:28:04 <azaq23> before
15:28:10 <azaq23> DanBurton: I know :)
15:28:13 <DanBurton> @type (+1) . (undefined :: IO Int)
15:28:15 <lambdabot> IO Int
15:28:17 <MostAwesomeDude> shachaf: I view "understand" in this channel as being the younger, more naive sibling of "grok".
15:28:34 <DanBurton> azaq23: so what you wrote is essentially fmap `asTypeOf` fmap
15:28:35 <shurikas> isn't functor just a function a -> b ?
15:28:51 <shachaf> shurikas: No, that's usually called a "function".
15:28:56 <MostAwesomeDude> shachaf: Also, the Deferred monad amuses me to no end, because I grok Deferred but not the Deferred monad.
15:28:56 <shachaf> That's the technical term, anyway.
15:29:02 <DanBurton> Well you see...a functor is like a burrito...
15:29:03 <azaq23> DanBurton: Oh, true
15:29:18 <shachaf> MostAwesomeDude: Too much emphasis on "monads".
15:29:24 <shachaf> We should ban that word in here for a while.
15:29:31 <shachaf> The plural form, in particular.
15:29:36 <MostAwesomeDude> Noes! Then we'd have to learn arrows!
15:29:36 <FUZxxl> DanBurton: A monad is just a monoid on the category of endofunctors. WHAT IS YOUR PROBLEM?
15:29:40 <DanBurton> shachaf: warm fuzzy things?
15:30:02 <shachaf> kmc is completely right.
15:30:17 <Freejacker> it ranks up there with singletons
15:30:56 <shachaf> What does "learning arrows" even mean? Individual arrows, like (->)? The Arrow type class?
15:31:12 <irene-knapp> learning what people mean when they say "arrows" :D
15:31:17 <shachaf> MostAwesomeDude: "Deferred monad"?
15:31:28 <Jafet> A functor is just a morphism between two categories.
15:32:05 <DanBurton> or for those of us that use Haskell...a functor is just a type that defines fmap
15:32:43 <shachaf> DanBurton: Well, that's a different sort of functor.
15:33:07 <DanBurton> given we're in #haskell and not #categorytheory I'd say it's the right sort
15:36:03 <shurikas> @hoogle (a -> b) -> Maybe a -> Maybe b
15:36:04 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
15:36:05 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
15:36:05 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
15:36:12 <DanBurton> "learning arrows" ^ is the "up arrow", > is the "right arrow", v is the "down arrow", < is the "left arrow". Most useful for the kirby dance ^(o.0^) (>o.0)> (vo.0)v <(o.0<)
15:36:39 <DanBurton> :)
15:36:59 <shachaf> ↑→↓←
15:38:11 * DanBurton is unicode deficient
15:40:54 <ClaudiusMaximus> hmmm porting some idioms from glut to gtk, ending up in pain:  No instance for (Graphics.UI.Gtk.Gdk.EventM.HasCoordinates EKey)
15:41:26 <ClaudiusMaximus> so is there no way to get the current mouse position from a keypress event?  do i have to manually track mouse movements?
15:48:56 <shurikas> @type Maybe
15:48:57 <lambdabot> Not in scope: data constructor `Maybe'
15:49:00 <shurikas> @src Maybe
15:49:01 <lambdabot> data Maybe a = Nothing | Just a
15:49:26 <shurikas> so Maybe is a functor, because it holds a value of another type?
15:49:38 <shurikas> @src ([])
15:49:39 <lambdabot> Source not found.
15:49:43 <shurikas> @src (List)
15:49:44 <lambdabot> Source not found. You speak an infinite deal of nothing
15:49:51 <shurikas> damn.
15:50:11 <shurikas> I just had a dejavu. Did I ask this question in these days?
15:50:36 <shurikas> anyway, [] is also a functor because it holds value of any type?
15:51:08 <Jafet> grep -r 'shurikas.*Did I ask this question in these days?' ~/irclogs/
15:51:27 <shurikas> :| seriously?
15:52:00 <shurikas> ok, feeling is over, I don't believe I asked this before.
15:52:35 <Jafet> Anything is a Functor if you can write fmap.
15:52:45 <Jafet> @instances Functor
15:52:46 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
15:52:50 <shurikas> oh, nice
15:52:54 <azaq23> shurikas: "Holding a value" is one part of the deal, the other is that there exists a function with the type like as fmap and the functor laws apply
15:53:08 <Jafet> IO doesn't "hold a value"
15:53:16 <shurikas> well but IO is a functor, right?
15:53:17 <unlink> @pl char x >> return y
15:53:18 <lambdabot> char x >> return y
15:53:23 <shurikas> isn't function also a value ?
15:53:30 <shurikas> oh, I mean action (for IO)
15:53:31 <unlink> @pl \x y -> char x >> return y
15:53:31 <lambdabot> (. return) . (>>) . char
15:54:15 <Jafet> Functions are values, actions are values
15:55:08 <shurikas> is IO a functor?
15:55:18 <shurikas> oh
15:55:19 <shurikas> sorry
15:55:20 <Jafet> @src IO Functor
15:55:21 <shurikas> it's on the list
15:55:21 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:55:43 <azaq23> yes, any monad is a functor
15:55:45 <shurikas> <Jafet> Anything is a Functor if you can write fmap.
15:55:50 <Jafet> Any Monad is a Functor; fmap = liftM
15:55:54 <shurikas> you mean if it implements Functor instance ?
15:56:05 <shurikas> instance Functor (something) where
15:56:12 <Jafet> Since writing fmap is implementing a Functor instance...
15:56:17 <shurikas> ahh, ok
15:56:23 <shurikas> uhm, yeah
15:56:25 <shurikas> true
15:56:50 <shurikas> so only fmap is dealing with Functors?
15:58:16 * Axman6 doesn't understand that sentense
15:59:10 <shurikas> me neither
16:03:06 <ddarius> Axman6: What about that hyakutense?
16:05:42 <MostAwesomeDude> If I'm doing a significant amount of string handling, is there any downside to using Text from Data.Text for all of my string needs?
16:07:29 <Philonous> MostAwesomeDude:  You can't pattern match on it. But why would anyone want to do that
16:08:35 <MostAwesomeDude> I could think of a couple instances where pattern-matching would be snazzy, but that's not really necessary, no.
16:08:55 <ddarius> You can use view patterns and/or pattern guards if you need to.
16:09:37 <MostAwesomeDude> Nah, I'm just trying and failing to find any problems with Text. It seems like a really great way to do all the Unicodey stuff I need to do.
16:09:41 <saml> hey,  can I have data constructor of same name?
16:09:42 <ddarius> MostAwesomeDude: Text should be your default choice of string type.
16:09:51 <saml> data D = C Int | C String
16:09:55 <ddarius> saml: No.
16:10:00 <saml> is there a way?
16:10:04 <ddarius> saml: No.
16:10:06 <shurikas> > fmap (+3) [5]
16:10:07 <lambdabot>   [8]
16:10:11 <shurikas> > fmap (+3) 5 : []
16:10:13 <lambdabot>   No instance for (GHC.Num.Num (f a))
16:10:13 <lambdabot>    arising from a use of `e_135' at <in...
16:10:20 <shurikas> how is this different if 5 : [] is [5] ?
16:10:29 <BMeph> saml: Just curious, but what would be the point?
16:10:30 <saml> I want to do something like:   5 :-> factorial :-> output    where :-> constructs some data
16:10:51 <saml> and the data will be transformed to code (assembly)
16:11:16 <ddarius> saml: Why does it need to be a data constructor?  Why can't it just be a function that calls the appropriate data constructor?
16:11:27 <MostAwesomeDude> > fmap (+3) ( 5 : [] )
16:11:28 <lambdabot>   [8]
16:11:30 * BMeph thinks ':->' looks suspiciously like 'flip ($)'.
16:11:31 <saml> ah, I can do     Int 5 :-> Gate "factorial" :-> Gate "output"
16:11:50 <MostAwesomeDude> shurikas: Parentheses.
16:12:01 <shurikas> oh, thanks :D
16:12:20 <Philonous> MostAwesomeDude:  Text uses 2 bytes per char (UTF16), String 5 bytes, I think that alone should be a good reason to ditch it
16:12:39 <ddarius> Philonous: That's wildly inaccurate.
16:12:41 <saml> i don't see a point of the language i'm trying to create. i give up
16:12:58 <Axman6> Philonous: i'm pretty sure it's quite a bit more than 5 bytes per Char in String
16:13:09 <Jafet> GHC's String uses 5 words.
16:13:11 <MostAwesomeDude> Philonous: I can't see the astral planes in Text? :c
16:13:25 <Axman6> Jafet: yeah that sounds a lot more realistic
16:13:42 <Jafet> Text uses however many bytes per character UTF-16 uses, which may be greater than 2.
16:13:49 <BMeph> shurikas: The difference is that one is a function applies to two arguments (FSVO 'a' and 'two'...;), while another is syntactic sugar for the result after aforesaid application is done (again, FSVO 'after' and 'done').
16:13:52 <ddarius> Philonous: Stirng uses more like 12-24 bytes per character.
16:13:56 <Philonous> Sorry, I meant to say 5 words
16:14:03 <ddarius> Philonous: That's better.
16:14:06 <MostAwesomeDude> UTF-16 is at least 2 bytes per character, up to 8 bytes for the super-astral stuff.
16:14:21 <MostAwesomeDude> But the "common" planes are all 2 bytes per character.
16:15:18 <BMeph> shurikas: But yeah, the big point is that 'f w x y z' parses as '(((f w) x) y) z', not 'f (w (x (y z)))'. :)
16:15:48 <zezikaro> is there a way of expressing primitive recursion in haskell?
16:15:52 <ddarius> BMeph: All that matters for shurikas' example, is that application binds tighter than any infix operator.
16:16:07 <Philonous> MostAwesomeDude:  Yeah well, of course, and you have some static overhead in Text. The point is, 2bytes per char is a good enough approximation
16:16:59 <BMeph> ddarius: True, true.
16:17:23 <MostAwesomeDude> Philonous: Well, in other languages, it'd matter for random access times. There's a reason that most imperative languages use UCS-4 instead of UTF-16 or UTF-32 for internal representation.
16:17:32 <shurikas> ok, I get what is a Functor and how to use fmap. Thanks ;)
16:17:47 <Jafet> zezikaro: uhh yes, you can write primitive recursion in Haskell.
16:17:56 <Philonous> MostAwesomeDude:  Can hardly be much worse than linear access (as in Strings)
16:18:31 <engla_> MostAwesomeDude: is there a difference between ucs-4 and utf-32?
16:18:46 <MostAwesomeDude> Philonous: It's exactly linear time. The reasoning is that random access can be constant-time in arrays of homogenous items.
16:19:59 <MostAwesomeDude> engla_: Yes. The former is exactly four bytes, at all times, and exactly encodes one codepoint per four bytes. UTF-32 can use the top bit of each first byte in four to signal that there will be additional bytes following.
16:20:31 <MostAwesomeDude> So the former is seekable in constant time, the latter isn't.
16:21:26 <engla_> this doesn't sound like utf-32 to me
16:22:26 <MostAwesomeDude> There's a lot of misinformation on exactly how all of the encodings work.
16:22:47 <MostAwesomeDude> What's worth remembering is that UTF-size is *at least* size bytes per codepoint, UCS-size is *exactly* size bytes per codepoint.
16:22:55 <engla_> utf-8 is 1-4 bytes per codepoint, utf-16 is 2-4 and utf-32 is 4 per codepoint
16:23:20 <engla_> utf-16 is 2 or 4 to be precise
16:23:59 <mauke> bonus difficulty: unicode defines "codepoint" differently
16:24:14 <mauke> I think what we call a "codepoint" is "scalar value" there
16:24:16 <ion> Wasn’t UTF-8 1…5 bytes per codepoint?
16:24:29 <mauke> no, 1..4
16:24:36 <ion> ok
16:24:39 <engla_> ion: there are specifications for up to six bytes but that's not the official utf-8
16:25:07 <mauke> perl uses the extended version internally to allow full 32-bit codepoints but that's explicitly disallowed by unicode
16:25:14 <Axman6> http://triptico.com/docs/unicode.html
16:25:20 <engla_> the unicode range fits in 21 bits (I think it is that), so no reason for something like utf-32 to be variable length (and it's not)
16:35:21 <shurikas> @hoogle [a -> b]
16:35:21 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
16:35:22 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
16:35:22 <lambdabot> Data.Generics.Schemes everythingBut :: (r -> r -> r) -> GenericQ (r, Bool) -> GenericQ r
16:35:51 <shurikas> @type fmap (+3) (+5)
16:35:52 <lambdabot> forall a. (Num a) => a -> a
16:36:11 <shurikas> > (fmap (+3) (+5)) 5
16:36:12 <lambdabot>   13
16:36:25 <shurikas> interesting
16:49:08 <DanBurton> What do you guys think, is this a bug with IncoherentInstances? http://stackoverflow.com/questions/8371499/how-does-incoherentinstances-work/8372400
16:50:16 <dafis> DanBurton: I expect GHC HQ will soon close one of the two as dupe
16:56:53 <dafis> DanBurton: interestingly, 6.12.3 says:
16:56:55 <dafis> *Arity> arity (\ _a _b -> 3)
16:56:56 <dafis> 1
16:57:54 <DanBurton> dafis: o_O really? odd
16:59:02 <dafis> DanBurton: quite, GHC's arity-analysis is strange
16:59:34 <dafis> 7.0 and 7.2 both say arity is 0, though, unless I give a type signature
16:59:56 <shachaf> "arity"?
17:00:50 <alistra> isn't each function of arity 1 when we have currying?
17:01:05 <dafis> shachaf: as in un-ary, bin-ary, tern-ary, ...
17:01:15 <dafis> alistra: yep
17:01:39 <shachaf> dafis: Right. What does it mean in the context of Haskell?
17:01:41 <dafis> but it can also have higher arities
17:02:02 <ddarius> alistra: It's not that Haskell "has" currying (which is like saying you "have dancing") it's simply that Haskell doesn't have a notion of multi-argument functions.
17:02:39 <DanBurton> not really. technically all functions take exactly 1 input and return exactly 1 result. This arity stuff is just a fun hack to kinda sorta get the feel for how many inputs a function "really" takes
17:02:49 <shachaf> dafis: What's the "arity" of id?
17:02:49 <DanBurton> *all functions in Haskell
17:03:09 <dafis> DanBurton: but, 7.2.2 says (\True False -> False) has arity 2, while 6.12.3 says 1 for that too
17:03:34 <dafis> shachaf: that depends on which type it's used at
17:05:20 <shachaf> dafis: So "arity" isn't a property of a function but of...
17:05:49 <DanBurton> warm fuzzy things?
17:06:08 <dafis> shachaf: types, really
17:06:17 <n0den1te> hey guys, got a failure with a lib install using cabal? https://gist.github.com/1428760
17:07:25 * hackagebot git-annex 3.20111203 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20111203 (JoeyHess)
17:07:56 <DanBurton> n0den1te: looks like you have an older cabal library? perhaps try cabal install cabal or even cabal install cabal-install
17:08:00 <n0den1te> ah, nvm. got an older version of cabal
17:08:35 <n0den1te> DanBurton: but it's odd why a library would have to specifically ask for newer version of the _installer_ ?
17:08:56 <dafis> shachaf: but in Haskell, I'd go with "all functions have arity 1"
17:09:29 <DanBurton> n0den1te: yep, that is pretty weird
17:10:02 <dmwit> Can somebody with GHC 7.2 test out a program for me?
17:10:03 <hpaste> dmwit pasted “gtk2hs segfault” at http://hpaste.org/54838
17:10:22 <dmwit> Just hit any key in the text box that this throws up. Does it segfault?
17:11:02 <n0den1te> DanBurton: Okay, I'll try cabal-install. Off for now, thanks!
17:11:36 <dafis> n0den1te: it's not asking for a newer cabal-install, but for a newer Cabal library
17:12:48 <shapr> What are the "two of three" options you get from dependently typed languages? General recursion, terminating typechecking, and something else?
17:12:54 * DanBurton got a new computer and only installed Haskell Platform with 7.0.3 :(
17:13:48 <dmwit> I think general recursion and terminating typechecking are basically a "one of two" kind of thing.
17:14:29 <dmwit> Unless you don't have an equality operator. But then what's the point of having dependent types?
17:14:40 <DanBurton> dafis: although the latest cabal-install would probably require the latest cabal
17:14:52 <dafis> DanBurton: true
17:15:53 <n0den1te> dafis: sure, the question is: will doing cabal install cabal-install or cabal upgrade Cabal get me a newer version of Cabal libs?
17:16:53 <dafis> n0den1te: cabal install cabal-install will probably also install a newer Cabal, check with --dry-run first
17:18:15 <n0den1te> dafis: I get this when I do "cabal update": To upgrade, run: cabal install cabal-install
17:18:48 <dafis> n0den1te: then I would advise doing that
17:19:04 <n0den1te> dafis: I think I need to do this as a global update as root. Will do a dry run and if anything, would put that for laters. Thanks again!
17:39:31 <dmwit> shapr: Maybe dependent types, general recursion, and decidable type-checking *are* the two-out-of-threes. =)
17:40:33 <tgeeky> omg wtf! my package doesn't use 'text' at all, why is it even trying to compile it!?
17:40:45 <dmwit> Perhaps a dependency of yours uses it.
17:41:05 * ddarius would be surprised if a dependency -wasn't- using it.
17:41:11 <ddarius> Unless you have no dependencies.
17:41:21 <dmwit> Why not "cabal install --constraint 'text installed'" or some other similarly unsatisfiable constraint, and see what cabal complains about?
17:41:22 <tgeeky> i have no dependencies.
17:41:28 <tgeeky> though it's not exaclty true, since I depend on quickcheck
17:41:43 <tgeeky> dmwit: yeah, about to do that
17:52:25 * hackagebot rivers 0.1.0 - Rivers are like Streams, but different.  http://hackage.haskell.org/package/rivers-0.1.0 (DrewDay)
17:52:37 <djahandarie> Hahaha
17:54:23 <dmwit> But it doesn't define rivers... only streams. =/
18:01:57 <Veinor> is HUnit worth working with?
18:09:44 <lars__> is Yi-Editor practically dead?
18:10:06 <Jafet> Just stillborn
18:14:50 <lars9> hope it can born before next extinction
18:17:05 <dmwit> lars9: Make it so!
18:19:56 <shapr> Veinor: HUnit is unit testing, quickcheck is generative testing
18:19:58 <lars9> dmwit: the code base is too large for me to understand now
18:20:03 <shapr> Veinor: there's some test framework that does both
18:25:45 <dmwit> :m + Foo.Bar prefers Foo/Bar.hs over a package-provided Foo.Bar. Can I change that temporarily?
18:27:57 <amindfv> does there already exist a function somewhere, such that (some_sort_f (\(_, x) -> x) [(7, 3), (3, 1), (2, 2)]) == [(3, 1), (2, 2), (7, 3)] ?
18:28:27 <Jafet> sortBy (comparing snd)
18:28:30 <dmwit> > sortBy (comparing snd) [(7,3), (3,1), (2,2)]
18:28:31 <lambdabot>   [(3,1),(2,2),(7,3)]
18:28:58 <dmwit> ?index sortBy
18:28:58 <lambdabot> Data.List
18:30:13 <amindfv> ?index comparing
18:30:13 <lambdabot> bzzt
18:30:19 <tgeeky> dmwit: I don't know exactly what Rivers are, except that Streams are simple versions of them.
18:30:25 <dmwit> amindfv: That's annoying.
18:30:27 <dmwit> ?hoogle comparing
18:30:27 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
18:30:37 <tgeeky> dmwit: that said, rivers is (in some senses) the most compliete Streams package yet
18:30:44 <dmwit> =)
18:30:50 <lars9> > let sort [(7, 3), (3, 1), (2, 2)] = [(3, 1), (2, 2), (7, 3)] in sort [(7, 3), (3, 1), (2, 2)]
18:30:51 <lambdabot>   [(3,1),(2,2),(7,3)]
18:30:55 <lars9> yay!
18:31:06 <DanBurton> o.0
18:31:08 <dmwit> tgeeky: I look forward to the time when the docs are available on Hackage.
18:31:34 <tgeeky> dmwit: be prepared to be disgusted at Streams, but happy (I hope) with Ecology
18:31:47 <DanBurton> > let sort [(7,3), (3,1), (2,2)] = "FFFF UUU" in sort [(7,3), (3,1) (2,2)]
18:31:49 <lambdabot>   Couldn't match expected type `t2 -> (t, t1)'
18:31:49 <lambdabot>         against inferred type ...
18:31:58 <DanBurton> boo
18:32:12 <DanBurton> missed a comma
18:32:47 <amindfv> dmwit: what is?
18:33:11 <dmwit> amindfv: It's annoying that ?index doesn't know about comparing.
18:34:49 <amindfv> dmwit: thought I was being annoying...
18:35:03 <amindfv> lars9: I'm having a little trouble generalizing that
18:35:46 <dmwit> sortOn should really be in the libraries.
18:36:13 <dmwit> And should be implemented as a decorate-sort-undecorate algorithm rather than a direct call to sortBy.
18:38:30 <amindfv> it seems like you'd do extra traversal with sortby (comparing snd)
18:38:39 <amindfv> (not relevant for my use)
18:38:55 <dmwit> sortBy (comparing snd) can't be made much more efficient.
18:39:12 <dmwit> It basically *is* already decorate-sort-undecorate, but with the decoration baked in.
18:39:31 <DanBurton> snd is about as fast as it gets. just access a field
18:39:38 <dmwit> yes
18:39:47 <DanBurton> sortBy (comparing length)  on the other hand
18:39:52 <DanBurton> costly
18:39:57 <dmwit> Right, you'd definitely want dsu for that.
18:40:24 <DanBurton> or memoization
18:40:37 <dmwit> dsu is just a particular memoization choice, no?
18:40:47 <Jafet> map fst . sortBy (comparing snd) . ap zip (map length)
18:40:58 <Jafet> What is with these rubyisms
18:41:10 <dmwit> sortOn f = map fst . sortBy (comparing snd) . map (id &&& f)
18:43:49 <lars9> :src sortBy
18:43:59 <lars9> @src sortBy
18:43:59 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:44:06 <ion> @check \x -> (id &&& (+42)) x == ((,) <*> (+42)) x
18:44:06 <lambdabot>   "OK, passed 500 tests."
18:52:36 <zezikaro> could anyone help me with http://ideone.com/XyfKl please
18:53:13 <mauke> zezikaro: missing a print?
18:53:23 <mauke> you can't just set main to a number
18:53:27 <accel> so I need to use clojure instead of haskell :-(
18:53:35 <accel> and i'm wondering if there's existing work on impelemtngin haskell like type checking
18:53:39 <ion> Why all the tuples?
18:53:41 <accel> on top of a dyamicc system like clojure
18:53:46 <accel> all I really want ... is NOT the optimiations ...
18:53:48 <accel> but ust the compile time checks
18:53:52 <zezikaro> main = print mult3(937, 281, 399)
18:54:09 <zezikaro> mauke like that?
18:54:27 <zezikaro> http://ideone.com/5KQtI
18:55:03 <ion> That’s “print” applied to the two parameters “mult3” and “(937, 281, 399)”.
18:55:26 <ion> Typical Haskell code would look like main = print (mult3 937 281 399).
18:55:37 <zezikaro> oh
18:55:38 <zezikaro> thanks :)
18:56:01 <ion> I recommend reading LYAH.
18:56:04 <ion> @where lyah
18:56:04 <lambdabot> http://www.learnyouahaskell.com/
19:02:02 <tgeeky> i've never watched haddock's paint dry (render docs), but it is booooorrrring
19:10:08 <carpi> how would you convince a lisper to atleast give haskell a try?
19:10:20 <zezikaro> break their legs
19:10:25 <mauke> I'd shove a cudder down his throat
19:10:44 <Clint> hypnotize with ((()))
19:11:02 <Jafet> @quote defun
19:11:02 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
19:11:27 <tgeeky> tell them that a gang lf ('s kidnapped their entire family, and the only way out is to stop using them.
19:11:32 <tgeeky> s/lf/of/
19:11:34 <mauke> preflex: quote . defun
19:11:35 <preflex>  no quotes found
19:12:15 <ion> > (show (subtract 3 (length (map toUpper "foo"))))  -- Like this
19:12:16 <lambdabot>   "0"
19:12:22 <carpi> lol.. i have a die hard lisper friend.. and i can't get him to just give haskell a try.... but i don't get it.. whats soo dang special about lisp anyways?
19:12:41 <ion> carpi: How it blurs the line between code and data with s-exprs.
19:12:46 <Jafet> @quote funbox
19:12:47 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
19:13:23 <carpi> ion: but you could do that in haskell too i think
19:13:37 <ion> Not quite like that.
19:14:25 <carpi> but if its such a good feature, why does haskell not have it? Im not complaining.. but wondering..
19:15:06 <ion> Haskell has low syntactic noise as a higher priority.
19:16:10 <carpi> i agree... even some of non-functional code looks like poetry
19:17:20 <mauke> carpi: tell him lisp is blub
19:17:34 <carpi> blub?
19:18:01 <Jafet> lisp is meta-blub.
19:19:43 <jyre> hello
19:20:01 <SavageSimian> anybody here familiar with Programmer's Notepad?
19:20:29 <Jafet> Is that another moniker for emacs?
19:20:44 <jyre> i am learnign haskell and i am trying to wrap my head around the application function
19:20:51 <SavageSimian> no. it's a moniker for Programmer's Notepad. :p
19:21:23 <saml> hey, what's ~/.local ? why does cabal install stuff to ~/.local/bin ?
19:21:29 <SavageSimian> it's not emacs. it's a code editor for windows that has Haskell support.
19:21:36 <azaq23> jyre: what function? $?
19:21:43 <jyre> the problem i am having is when i try to write "fib' $ x - 1" i expect it to be similar to "fib' ( x - 1 )"
19:21:46 <zezikaro> http://codepad.org/aZ5wf5bd how can i output print functions in my haskell functions?
19:21:50 <jyre> yeah $
19:22:23 <SavageSimian> will emacs do automatic indents, code completion, and something similar to VS Intellisense?
19:22:39 <azaq23> jyre: fib' $ x - 1 should be fib' (x - 1) - if you don't use $, fib' x - 1 would be interpreted as (fib' x) - 1
19:23:36 <jyre> but i get a compile time error, "Occurs check: cannot construct the infinite type: a = a -> a"
19:23:37 <zezikaro> i've changed it to http://codepad.org/P2guwfaP actually
19:23:52 <zezikaro> i didn't realise = was the return, rather than the definition
19:23:56 <jyre> when i do use "$"
19:24:43 <azaq23> jyre: that doesn't seem to be directly related to $; you should paste your code at hpaste.org
19:24:48 <jyre> oh is it because fib' does not take a function?
19:24:59 <jyre> yeah i think pastebin is necessary
19:25:13 <azaq23> > let f x = x * 2 in (f $ 2 - 5, f (2 - 5), f 2 - 5)
19:25:15 <lambdabot>   (-6,-6,-1)
19:25:42 <hpaste> hiptobecubic pasted “text transposition” at http://hpaste.org/54840
19:26:04 <hiptobecubic> looking at   transpose'  how could it be written in a less hideous way?
19:26:56 <hiptobecubic> It took me several hours to get it to actually work (different length strings, etc) but i feel like it came out poorly done
19:26:58 <azaq23> zezikaro: that doesn't make any sense in haskell
19:27:17 <zezikaro> azaq23 i just want to make the return a + b + c
19:27:23 <zezikaro> and have a debug output line
19:27:46 <DanBurton> it's usually best not to try and understand Haskell in terms of other languages, because it's nothing like most other languages
19:28:16 <azaq23> zezikaro: no you don't, print is function which returns an IO action, you can't print things like this
19:28:27 <hpaste> jyre pasted “application operator” at http://hpaste.org/54842
19:29:02 <jyre> nice pastebin
19:29:20 <azaq23> @src transpose
19:29:21 <lambdabot> transpose []             = []
19:29:21 <lambdabot> transpose ([]   : xss)   = transpose xss
19:29:21 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:29:36 <zezikaro> azaq23 .. why wouldn't it be void? D:
19:30:15 <azaq23> jyre: x + fib' $ x - 1 is parsed as (x + fib) $ (x - 1), so you try to add a number (x) to a function in your left case
19:31:02 <azaq23> zezikaro: void?
19:31:11 <hiptobecubic> zezikaro, haskell doesn't do things like you think it does. It's not a C clone like most things. It will help you a lot to do some reading
19:31:38 <zezikaro> may i have the 'quick answer' please? I just want to simply print "testing" and return a + b + c
19:31:41 <jyre> would it help to put a $ in between the + and the fib?
19:31:58 <mbetter> more $ always helps
19:32:35 <tomprince> jyre: I am guessing your error is because x is forced to be a function (by adding it to fib) and also is passed to that function (since it is added to 1)
19:32:38 <zdod> Newbie Q: Cabal didn't install a bin directory in .cabal.  Any idea why?
19:33:04 <hiptobecubic> zezikaro, the quick answer is that what you wrote makes no sense and it looks like you haven't bothered to learn even the most basic syntax
19:33:05 <azaq23> jyre: no, $ is an operator like + is, and both are actually functions, + $ does not make sense, just write x + (fib' $ x - 1)
19:33:29 <dafis> zdod: maybe it waits until it installs the first executable?
19:33:30 <jyre> okay
19:33:31 <hiptobecubic> zezikaro, really, just read for ten minutes.
19:33:33 <tomprince> or x + fib' (x-1)
19:33:55 <zezikaro> i've read http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes hiptobecubic
19:33:59 <zezikaro> but it doesn't cover a print within a function
19:34:08 <zezikaro> it onyl mentions putstrline within the main
19:34:15 <dafis> zezikaro: because that's unhaskellish
19:34:16 <zdod> dafis: I just installed snap, but no executable.
19:34:21 <jyre> azaq23, tomprince  thanks for the help
19:34:35 <azaq23> zezikaro: what hoptobecubic said, this isn't java and it's not really possible to give you a quick answer - it's a fact that haskell is in certain areas so different from java, that what you wrote
19:34:35 <azaq23> doesn't make any sense whatsoever
19:34:46 <mbetter> you can only print in a function that's in the IO monad
19:34:52 <dafis> zdod: is snap supposed to be an executable?
19:35:08 <zdod> of course...but I think I've found the problem...
19:35:23 <azaq23> zezikaro: read learnyouahaskell.com
19:37:14 <carpi> is there a way to page the output in ghci ..? because sometimes the output is soo big that is simply scrolls over the top of the terminal
19:37:30 <hiptobecubic> zezikaro, the short answer is just do eveything in 'main' and you can pretend this is still python for a few more hours. Then you have to go read again and be frustrated like the rest of us newly converted
19:37:52 <dmwit> I don't know of one off the top of my head, but you can certainly use your terminal's scrollback. shift+pageup and shift+pagedown work in every terminal I know.
19:38:01 <zdod> OK, maybe someone can help my newbie self with this:
19:38:02 <dmwit> Except screen, where you have to enter scrolling mode.
19:38:03 <zdod> Configuring zlib-0.5.3.1...
19:38:03 <zdod> cabal: Missing dependency on a foreign library:
19:38:03 <zdod> * Missing header file: zlib.h
19:38:03 <zdod> * Missing C library: z
19:38:25 <dmwit> zdod: Have you installed the -dev versions of zlib through your package manager?
19:39:02 <ehuber> hiptobecubic: what are your current frustrations? :)
19:39:10 <zdod> dmwit: perhaps not (I'll check), but if cabal depends on zlib, then shouldn't the package manager have installed it first?
19:39:50 <dmwit> zdod: It doesn't look to me like you're installing cabal-install (as distinct from Cabal) through your package manager.
19:39:53 <hiptobecubic> ehuber, well i'm getting monads, although just how to use them and what they are, not really when it's appropriate to invent one, etc.
19:39:56 <dmwit> So how could your package manager possibly have known?
19:40:16 <hiptobecubic> ehuber, the latest frustration is just getting shit to pass the type checker
19:40:38 <dmwit> zdod: Sorry, I misread your error.
19:40:43 <dmwit> zdod: Let me correct my response.
19:40:53 <mbetter> hiptobecubic: try to think about it a minute before you just reflexively change stuff
19:41:00 <ehuber> you know about annotating types manually, right, hiptobecubic ?
19:41:08 <dmwit> zdod: It doesn't look to me like you're installing the Haskell bindings to zlib through your package manager, so how could your package manager possibly have known to install zlib-dev or similar?
19:41:25 <hiptobecubic> mbetter, s/a minute/several hours/
19:41:29 <ehuber> it can help if you say to yourself "well, this is DEFINITELY a [Char]" and mark it as such
19:41:44 <ehuber> sorry, im also new, just trying to help :)
19:42:03 <hiptobecubic> ehuber, yes, but sometimes i get that wrong, and then it takes a long time for me to realize that THAT's why it won't build. because i lied about what it was supposed to be doing.
19:42:07 <mbetter> hiptobecubic: that's good if you can manage it :) i think for a minute and then try adding $'s
19:42:25 * hackagebot X11 1.5.0.1 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.5.0.1 (DanielWagner)
19:45:49 <hiptobecubic> How does one do repeated application? like iterate but without storing intermediates
19:46:07 <dmwit> iterate f x !! 32
19:46:11 <dmwit> doesn't store intermediates
19:46:17 <ezyang> hiptobecubic: Because Haskell is lazy, the intermediates aren't generated
19:46:23 <hiptobecubic> oh right
19:46:40 <ezyang> I can't remember if that will unfold or not though
19:46:49 <Saizan> iterate f x !! n could be a stack overflow if f is strict and n is large
19:47:03 <hiptobecubic> Sometimes I worry that I won't be able to write anything reasonable in strict languages once i get used to this
19:47:04 <mbetter> i can't make up my mind whether to use screen or tmux
19:47:21 <dmwit> Flip a coin.
19:47:25 * hackagebot tuple-th 0.2.2 - Generate (non-recursive) utility functions for tuples of statically known size  http://hackage.haskell.org/package/tuple-th-0.2.2 (DanielSchuessler)
19:47:42 <hiptobecubic> mbetter, if you really don't care either way, go with screen. it's on every machine ever.
19:47:49 <dmwit> Trust the coin's answer at least until you have a complaint.
19:47:49 <mbetter> tmux is better in every way except the way it deals with multiple sessions connected to the same screen
19:48:01 <mbetter> i have complaints about both
19:48:18 <mbetter> hell, i have both open right now
19:48:20 <dmwit> You better not trust the coin's answer very long, then. =P
19:48:24 <ezyang> screen is universally installed, tmux isn't?
19:48:31 <hiptobecubic> right
19:48:41 <ezyang> This is a little off topic though :^)
19:48:45 <mbetter> true
19:50:26 <ddarius> dafis: The snap package produces an executable.  The only thing that you can do with that executable is 'snap init' which will make a very basic file layout and an simple example web application.
19:50:45 <DanBurton> wait intermediates have to be *generated*, but not *stored*
20:01:42 <hiptobecubic> @srt transpose
20:01:43 <lambdabot> transpose []             = []
20:01:43 <lambdabot> transpose ([]   : xss)   = transpose xss
20:01:43 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
20:07:20 <zdod> Problem with my snap install: It needs base16-bytestring, but cabal can't install it (ExitFailure 1)
20:07:45 <shachaf_> zdod: "ExitFailure 1" provides approximately the same amount of information as "it doesn't work". :-)
20:08:52 <zdod> shachaf_: my thought exactly.
20:09:03 <zdod> So how does one install snap?
20:09:09 <Saizan> zdod: earlier in the log there should be a real error message
20:09:37 <ddarius> Or using cabal install -v3 will provide more informatino.
20:09:43 <shapr> zdod: Perhaps base16-bytestring needs a -dev lib that's missing?
20:09:44 <zdod> Saizan: yes: "Couldn't match kind `#' against `*'
20:11:29 <dmwit> How come when I add "+RTS -N2" to my command line, I get the same thing as "+RTS --help"?
20:11:46 <dmwit> I compiled with -threaded (and -N<n> is listed as an available runtime option).
20:11:51 <Saizan> zdod: ghc version?
20:11:55 <monochrom> is it because you didn't link with --rtsopts?
20:12:01 <zdod> shapr: shouldn't cabal install know what base16-bytestring requires?  In any case, cabal list doesn't show any dependencies.
20:12:14 <zdod> Saizan: 6.12.1
20:12:21 <dmwit> monochrom: I did link with that (and +RTS --help does give the nice long help message, which I think it wouldn't without -rtsopts).
20:12:25 <ddarius> zdod: The error you're getting is a compile error.
20:12:37 <monochrom> ah, then I don't know
20:12:54 <shachaf> dmwit: Does the nice long help message include "-N"?
20:12:58 <zdod> ddarius: yes, I know.
20:13:08 <dmwit> shachaf: As mentioned above, yes. =)
20:13:21 <shachaf> Oh, so you did.
20:13:25 <shachaf> dmwit: Which version of GHC is it?
20:13:36 <Saizan> zdod: my guess is that it has only been tested on ghc-7.x and some typing rules were different for 6.12
20:13:36 <dmwit> The Glorious Glasgow Haskell Compilation System, version 7.2.2
20:14:00 <zdod> shit
20:14:05 <zdod> (excuse me)
20:15:50 <zdod> Ubuntu's aptitude has only ghc 6, it seems...
20:16:13 <ddarius> Yes, and also 6.12.1 had some pretty bad bug if I remember correctly.
20:16:52 <ddarius> Incidentally, 7.0.1 will build snap 0.6 but doesn't work properly with it due to some issue in the event manager.
20:17:01 <monochrom> the bug uses higher-valued abi hash to shadow the lower-valued one, rather than --user shadowing --global
20:17:45 <ddarius> zdod: I would recommend just installing 7.2.2 from the generic Linux binary.
20:18:16 <mjrosenb> ghc-7.2.2?
20:19:14 <zdod> ddarius: Sorry but this is just too complicated.  The 7.0.4 page says only devs should download it.
20:19:42 <zdod> When do you think version 7 will make it into Ubuntu's aptitude?
20:19:48 <ddarius> It's too complicated to go to haskell.org/ghc and download the latest released version.
20:19:51 <ddarius> ?
20:21:16 <shachaf> zdod: I think it'll make i on October 2011.
20:21:41 <zdod> shachaf: was that a joke? ;-)
20:21:52 <shachaf> zdod: Only the tense.
20:22:04 <shachaf> zdod: http://packages.ubuntu.com/oneiric/ghc
20:22:06 <zdod> ddarius: please go to that download page and check out the headachey warnings.
20:22:27 <shachaf> zdod: I installed GHC 7 manually on Ubuntu and it worked fine.
20:22:36 <dmwit> zdod: Congratulations! You're a dev.
20:22:39 <dmwit> Now install 7.2.2.
20:22:57 <saiko-chriskun> :D
20:23:00 <ddarius> Also, if you want you can install the Haskell Platform, but that will take longer and install a whole crapton more stuff than you need.
20:23:35 <shachaf> zdod: The warnings tell you to use the Haskell Platform, and link to a page which tells you to either get it from your distribution's repository or ignore the warnings.
20:23:41 <SavageSimian> wow. it's that easy to become a dev? i wish i'd have known that 20 yrs ago before i put all the effort into it... :p
20:23:42 <mjrosenb> ddarius: not relevant, but i do enjoy having my package manager managing all of my packages.
20:23:48 <monochrom> the "STOP!" warning is for windows and mac os x
20:24:09 <shachaf> "Stop! For most users ..."
20:24:11 <ddarius> mjrosenb: That's nice.
20:24:16 <shachaf> But you are not most users, you are only one user.
20:24:58 <ddarius> zdod: You could install the latest Ubuntu instead.  I'm sure that's less complicated.
20:26:02 <zdod> ddarius: no, actually, I'd like to stick to the latest "long-term supported" release.
20:26:19 <zdod> I will figure this out tomorrow morning...
20:26:21 <shachaf> zdod: Well, GHC 7 will never make it into that release.
20:26:28 <shachaf> That's why it's "long-term supported".
20:26:57 <zdod> Yes, I'll get the binary tomorrow. Thank you all for the guidance!
20:27:10 <shachaf> mjrosenb: There's always checkinstall.
20:27:33 <mjrosenb> shachaf: checkinstall?
20:28:14 <shachaf> mjrosenb: checkinstall.
20:28:44 <ddarius> Dental plan.
20:30:03 <mbetter> lisa needs braces
20:30:40 <dmwit> checkinstall doesn't really seem like a replacement for a proper package manager.
20:31:03 <dmwit> Oh, never mind, I didn't read it carefully enough.
20:31:07 <shachaf> dmwit: It's not; it works with your proper package manager.
20:31:24 * dmwit nods agreement
20:31:36 <shachaf> The point is that you can download a binary GHC package and checkinstall it so that your package manager knows about it.
20:33:18 <dmwit> darcs is going nuts =/
20:35:27 <zezikaro> how can i do this? http://ideone.com/zgGvv
20:35:32 <zezikaro> i want to be able to get the value of sum first
20:35:34 <zezikaro> then return it
20:35:46 <zezikaro> i potentially have to do something with monads?
20:36:29 <mbetter> first, you don't need that Int
20:36:59 <dmwit> mult3(a+1, b, c) = ans where { ans = blah; otherUsefulComputation = baz }
20:37:41 <dmwit> I assume somebody has enunciated the usual philosophical misgivings about using trace, right?
20:37:52 <dfijofad> >
20:37:58 <zezikaro> i'm okay with the trace, it's just for debuggin
20:38:01 <zezikaro> to help me understand more
20:38:39 <dfijofad>  > 1 + 1
20:38:45 <dmwit> > 1 + 1
20:38:46 <lambdabot>   2
20:38:53 <dmwit> Space after the '>', but not before, dfijofad.
20:39:14 <dfijofad> > 1 + 1
20:39:15 <lambdabot>   2
20:39:22 <mbetter> zezikaro: return doesn't mean what you think it does
20:39:44 <zezikaro> well how does it know what to return
20:39:58 <zezikaro> when i do http://ideone.com/leDr2
20:40:01 <zezikaro> somehow it knows what to return
20:40:20 <mbetter> it "returns" whatever is on the right of the equals sign
20:41:01 <dmwit> Along with mbetter's answer, you must also understand that trace returns its second argument.
20:41:11 <dmwit> Semantically, you are supposed to think of trace being defined as
20:41:14 <dmwit> trace _ x = x
20:41:44 <shachaf> zezikaro: You'll probably be better off reading a bit more about how Haskell works before writing this sort of program.
20:42:02 <dmwit> ...this program seems pretty simple to me so far.
20:42:19 <zezikaro> shachaf i'm doing it not to learn haskell, but to learn primitive recursive functions -.-
20:42:25 <zezikaro> lol
20:42:45 <shachaf> dmwit: Well, even so it's very unidiomatic.
20:42:46 <zezikaro> since i googled that i can test primtiive recursions in haskell
20:43:19 <mbetter> sounds like turning one problem into two problems
20:43:30 <Jafet> mbetter: divide and conquer
20:43:42 <mbetter> lol
20:43:53 <zezikaro> mbetter yeah, i couldn't find anywhere to help me with primitive recursion, so i decided to try it in haskell
20:44:19 <BMeph> "I needed to learn about primitive recursion, and I heard that Haskell can di that, so I tried it in Haskell...."
20:44:22 <shachaf> Multiply and surrender.
20:44:27 <BMeph> di -> do
20:44:40 <mbetter> problem mitosis
20:44:49 <BMeph> "...Now I have two problems." ;)
20:45:04 <mbetter> zezikaro: http://learnyouahaskell.com/recursion
20:46:23 <mbetter> haskell was probably recommended for your purpose because pattern matching can make for very pretty definitions of base/edge cases
20:46:23 <shachaf> zezikaro: Is there another programming language you're more familiar with? It's probably also able to express recursion. :-)
20:46:39 <zezikaro> it is yes
20:46:48 <zezikaro> but not in terms of the syntax that the primitive recursion uses
20:46:55 <zezikaro> IE the base case being defined as a seperate function
20:47:10 <zezikaro> doing int mult3(int a, int b, int c){ if(a == 0){ return ;} etc}
20:47:16 <zezikaro> kinda defeats the purpose
20:47:46 <shachaf> f (x+1) = ... syntax is generally frowned upon and I think was taken out in the recent version of Haskell.
20:48:32 <siracusa> zezikaro: Hey, still trying to force a recursion into that function? ;-)
20:48:52 <cmasseraf> even if it isn't it's not a good practice
20:49:06 <shachaf> Wait, is this the same person as before?
20:49:12 <shachaf> Oh, so it is.
20:49:32 <zezikaro> yeah :)
20:50:23 <shachaf> zezikaro: Probably what you want is to use a lazy natural type like data Nat = Zero | Succ Nat
20:50:51 <zezikaro> where | is or right?
20:51:01 <soiamso> zezikaro: n+k patterns
20:51:10 <zezikaro> variadic args?
20:51:59 <parcs_> monads?
20:53:10 <DanBurton> shachaf: n+k patterns were removed in Haskell 2010
20:53:31 <shachaf> DanBurton: I think that's what I said.
20:53:42 <DanBurton> indeed
20:54:00 <DanBurton> but you said "I think" so I was just comfirming it
20:54:02 <DanBurton> *con
20:54:03 <shachaf> zezikaro: In that context "|" is usually pronounced "or", yes.
20:54:05 <DanBurton> firming
20:54:44 <DanBurton> you can get something like n+k patterns back with view patterns if you want though
20:54:47 <dmwit> | is not variadic args.
20:55:05 <DanBurton> f (succ -> x) = ... or something like that
20:56:18 <shachaf> > let f ((-3) -> x) = x in f 0
20:56:19 <lambdabot>   -3
20:56:21 <soiamso> zezikaro:  “n+k pattern support is enabled by default. To disable it, you can use the -NoNPlusKPatterns flag” from GHC 7.2.2 user guide
20:58:02 <parcs_> in 7.3/7.4 it's disabled by default
21:01:15 <zezikaro> soiamso why would i disable it D:
21:01:56 <dmwit> It's sort of a wart. But if you're not intending to write Haskell anyway, who cares if you use Haskell's warts?
21:02:39 <zezikaro> i intend to, but not now. not when my concern is primitive recursive functions
21:19:49 <amindfv> \quit
21:45:25 <DanBurton> @google monads scary
21:45:26 <lambdabot> http://www.algorithm.com.au/downloads/talks/monads-are-not-scary/monads-are-not-scary-chak.pdf
21:45:27 <lambdabot> Title: Monads are Not Scary!
21:45:42 <djahandarie> @google "Monads are scary"
21:45:43 <lambdabot> http://www.algorithm.com.au/downloads/talks/monads-are-not-scary/monads-are-not-scary-chak.pdf
21:45:43 <lambdabot> Title: Monads are Not Scary!
21:45:47 <djahandarie> :(
21:47:25 <yitz> there, it's been proven. monads just aren't scary.
21:49:52 <DanBurton> lol
21:50:01 <DanBurton> proven by top google hit
21:51:54 <ddarius> If an Australian says it, you know it's true.
21:53:55 <GordonFreeman> C is not scary either
21:54:15 <GordonFreeman> though not initializing a struct can be a brainfuck
21:55:05 <ddarius> +
21:59:31 <Saizan> so Jaynes in 1996 still thought quantum mechanics could be shown to simply be dealing with incomplete information, rather than nature itself being incomplete
22:00:47 <Saizan> i wonder how plausible that would look if i knew physics :)
22:10:26 <mbetter> can you import only part of a module qualified?
22:10:54 <mauke> yes
22:10:59 <mauke> use two import lines
22:11:05 <mbetter> ok, sweet
22:11:06 <mbetter> thanks
22:14:08 <cads> What's a good paper to read to begin to understand how the spineless tagless g-machine for lazy FP languages works?
22:15:26 <cads> I kind of want to get a bit of theory and intuition at the same time
22:15:49 <cads> right now I don't really know how the STG machine is defined or how it works
22:16:44 <Saizan> "implementing lazy functional languages", maybe
22:17:15 <ezyang> Yeah, that's what I would recommend.
22:17:54 <cads> I kind of want to understand more about the semantics in general of lazy languages, but I also want to see that through the eyes of an interpreter for the language
22:18:18 <cads> is the stg machine hard to understand?
22:18:30 <ezyang> Maybe the actual paper itself.
22:18:51 <ezyang> I dunno, I haven't looked closely enough :^)
22:19:37 <cads> found the paper, thanks for the rec
22:20:06 <ezyang> Maybe  you can convince edwardk to write an STG interpreter :-)
22:23:23 <ddarius> Saizan: The ideas and history covered here http://geocalc.clas.asu.edu/html/GAinQM.html suggests that there has typically been a lot of confusion in the interpretation of simply the equations of quantum mechanics.
22:26:15 <cads> ddarius: that geometric algebra stuff looks pretty cool
22:26:25 <ddarius> cads: Geometric algebra is life changing.
22:27:51 <shachaf> ezyang: Wasn't he trying to convince you to write an STG JIT? :-)
22:28:28 * ezyang goes "hee hee" 
22:29:10 <cads> ddarius: is GA described in terms of categories and toposes?
22:29:22 <ddarius> No.
22:30:19 <cads> I mean, can a I find papers that use categorical language to describe its constructions and stuff
22:30:46 <ddarius> Probably somewhere.
22:40:52 <kirstin> Hi!
22:40:59 <shachaf> Good morning.
22:41:05 <mbetter> hello
22:41:05 <kirstin> I was trying to follow the happstack crash course
22:41:26 <mbetter> kirstin: i've been living in that for a few weeks now
22:41:58 <kirstin> But ran into problems with the heist part: it seems like it's a bit out of date with regard to current versions of heist
22:42:03 <kirstin> Any pointers?
22:42:28 <mbetter> oh, sorry no.. i'm working on a REST api, so i don't have any html stuff going on
22:42:31 <mbetter> just json
22:42:34 <kirstin> ah
22:42:45 <kirstin> Well, as long as I'm here,
22:43:00 <mbetter> i'm not sure if i dig that heist stuff.. looks too much like php to me
22:43:07 <kirstin> Any feelings on which web framework is the one to go with?
22:43:14 <mbetter> code and presentation all intermingled
22:43:22 <kirstin> Apart from happstack state
22:43:27 <ddarius> mbetter: Have you actually looked at heist?
22:43:31 <kirstin> Eh
22:43:34 <mbetter> ddarius: i havent
22:43:36 <kirstin> Looks like Lift
22:43:40 <mbetter> just an opinion
22:43:45 <mbetter> i mean, feeling
22:44:12 <shachaf> kirstin: There's #haskell-web.
22:44:15 <ddarius> mbetter: You may want to actually look at it at some point.
22:44:15 <mbetter> kirstin: acid-state replaces happstack-state
22:44:18 <shachaf> And also #snapframework and #yesod.
22:44:32 <ddarius> kirstin: Happstack, Yesod, and Snap are the three big ones right now.
22:44:38 <mbetter> ddarius: i will, when i get into the html stuff
22:44:53 <ddarius> Yesod is probably the most "mature" of them currently, though they are all very young.
22:44:55 <mbetter> i've been digging happstack, haven't messed around with the other ones too much
22:45:17 <kirstin> Happstack seems the most haskelly.
22:45:20 <mbetter> there are definitely holes in it, though, i've had to patch up some low-level stuff
22:46:09 <kirstin> But, you know, iteratrees
22:46:36 <mbetter> i like web routes for routing
22:47:13 <shachaf> ddarius: Are you using one of them?
22:47:24 <ddarius> I've been using Snap a bit of late.
22:47:40 <ddarius> The recent change in Heist syntax was due to me reading the tutorial.
22:47:47 <mbetter> what are the main differences?
22:48:26 <mbetter> yesod seemed like it had a bit more black magic involved
22:49:49 <kirstin> Template Haskell should be an emergency fallback, imho
22:50:33 <mbetter> i understand the usefulness of TH but as somebody who's just learning this stuff, i think it can make it harder to understand how it's actually working
22:51:08 <djahandarie> I still don't understand the usefulness of TH.
22:51:26 <djahandarie> It's just an easy way to avoid the right solution.
22:51:37 <ddarius> djahandarie: Which is?
22:51:44 <djahandarie> Rewrite Haskell.
22:51:48 <kirstin> Exactly
22:52:28 <djahandarie> Or in many cases, write/use a GHC extension.
22:52:52 <DanBurton> I disagree with the TH hate, especially the way Yesod uses it.
22:53:09 <DanBurton> Yesod provides some super-simple DSLs that happen to use quasiquoting
22:53:24 <DanBurton> they'd be a lot uglier without TH
22:53:30 <kirstin> But shouldn't we be able to do DSLs directly?
22:53:38 <kirstin> With combinators?
22:53:57 <DanBurton> well does it matter how the DSL is implemented, if you are the user of it?
22:54:21 <ddarius> DanBurton: It does when it limits functionality.
22:54:33 <kirstin> There's a difference between arrows and monads and TH
22:54:33 <ddarius> But I agree, I don't understand why people seem so hostile to the use of TH.
22:54:52 <kirstin> It feels like cheating.
22:54:55 <DanBurton> lol
22:55:02 <ddarius> I can understand why people are hostile toward TH, since TH still has a lot of improving to do.
22:55:19 <djahandarie> I just don't like it because it's too complicated. Meta-programming should be as clear as possible, not the jumbled mess that TH is.
22:55:24 <DanBurton> we're all preachy about type safety and elegance of Haskell and stuff, and then I guess people somehow equate that to macros = bad
22:55:41 <djahandarie> Though there were some steps towards improving it awhile back, I wonder what came of those.
22:55:44 <DanBurton> agree TH looks like a jumbled mess
22:57:01 <DanBurton> i dunno; does any macro system look "better" than TH?
22:59:45 <ddarius> DanBurton: MetaOCaml, syntax-case etc., even CL's macros.  TH just has a lot of usability issues as well as completeness issues.
23:00:51 <kirstin> Ack. I think the core of the hate is that the language shouldn't need a meta-language in the first place.
23:02:34 <DanBurton> well ideally it shouldn't
23:02:55 <DanBurton> but I don't think any language exists that can completely eliminate the usefulness of a meta-language
23:03:14 <ddarius> Correct.  Virtually no language has no second-class aspects.
23:03:22 <kirstin> Math?
23:03:34 <DanBurton> math is a meta-language xD
23:04:19 <mbetter> are there any haskell style guides out there?
23:04:28 <ddarius> Yes.
23:04:50 <mbetter> my code is a mess, i need to pick some rules and stick to them
23:05:04 <kirstin> put the commas in front
23:05:13 <djahandarie> And then it'll only be an organized mess.
23:05:17 <mbetter> haha
23:05:42 <morolin> djahandarie: If I'm looking at someone else's code I'd much rather look at an organized mess
23:06:01 <morolin> And "someone else" is usually "past me"
23:06:13 <morolin> And boy does past me know how to make a mess of code.
23:06:57 <kirstin> well, there's really style on two levels: one is indentation
23:07:20 <kirstin> the other is whether to do things as abstractly as possible.
23:08:24 <ddarius> On the flip side, I really don't understand people who think "macros" are some God-like feature that immediately solves all problems.
23:08:55 <mbetter> i just noticed that some of my code is like: f x y = do ... and some is like f x y =\n    do
23:08:57 <kirstin> They are if you are programming in Java
23:09:09 <mbetter> and sometimes the = on the second line
23:10:56 <kirstin> As a survivor of pep8, all I can say is that you should feel free to use any style you like, assuming your intention is for maximal comprehension
23:11:25 <mike-burns> hlint
23:11:34 <kirstin> oh no
23:12:15 <ddarius> mbetter: I always put do on the same line as the = sign, immediately followed by a newline, unless it's a one-line block.
23:14:46 <bwright_> When reading in arguments with getArgs what is the most elegant way to have the strings directly converted to int.
23:14:56 <gavri> I'd like to add a configuration file to my app that would be git ignored. I'm thinking of having it as a haskell module with settings assigned in it. however, I'd like there to be default settings if the configuration file does not exist. I'm not sure how to achieve this. is there a way to import one module if another does not exist?
23:15:46 <kirstin> there's a argument config library
23:16:45 <kirstin> http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm
23:17:01 <ddarius> kirstin: There's more than one of those.
23:17:11 <kirstin> there is always
23:18:07 <ddarius> gavri: You could use CPP.
23:19:05 <gavri> ddarius: can cpp check for the existence of a file?
23:19:05 <kirstin> http://conal.net/blog/posts/the-c-language-is-purely-functional
23:20:01 <ddarius> gavri: Not directly, but that is probably not too crucial.
23:20:30 <ddarius> You could also pull the settings from somewhere with TH.
23:20:40 <ddarius> Or you could just have a settings file.
23:20:49 <kirstin> gak
23:21:07 <kirstin> a settings thing is a good excuse to use the reader monad
23:24:39 <gavri> ddarius, kirstin: looking up these options. thanks
23:24:49 <bwright_> How in haskell do I read n number of chars in?
23:24:59 <bwright_> or a EOF
23:25:21 <kirstin> take n ?
23:25:56 <bwright_> So that will be lazily evaluated I guess.
23:26:06 <bwright_> take 1000 getContents
23:26:15 <kirstin> Easiest thing to do, if you don't have performance constraints, is to rely on the lazy.
23:26:53 <kirstin> or
23:27:07 <kirstin> takeWhile
23:39:31 <Codingtales> How do you get a haskell program built statically on Ubuntu 11.10 running on 11.04?
23:46:54 <ddarius> Codingtales: You copy and paste it, then execute it.\
