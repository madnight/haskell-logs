00:04:55 <augur> peeps!
00:05:01 <augur> why do these have different efficiencies
00:05:03 <augur> (\xs -> head xs + last xs) [1..100000000]
00:05:09 <augur> (\xs -> last xs + head xs) [1..100000000]
00:05:31 <augur> the first runs almost immediately and has no real space cost. the second doesnt finish and starts hogging memory
00:07:19 <Cale> augur: Because + evaluates its left parameter first
00:07:31 <augur> Cale: right but
00:07:37 <augur> why should that matter here?
00:07:40 <Cale> augur: and xs is a variable, so it won't be recomputed
00:07:49 <augur> right but ...
00:08:02 <Cale> Okay, so we compute last xs
00:08:17 <Cale> but xs is still in scope and can't be proved to be garbage
00:08:28 <augur> ahh so its GC related
00:08:47 <Cale> So as last xs is being computed, the list is being constructed and put in memory, and not being garbage collected because it's not technically garbage
00:08:55 <augur> ok
00:08:58 <augur> so its about GCing
00:09:00 <Cale> yep
00:09:31 <Cale> It's generally a good plan to try to access the elements of a list in the order in which they occur in the list whenever possible
00:09:33 <Veinor> so last xs forces the construction of the entire billion-element list or whatever?
00:09:51 <augur> Cale: theres like.. some clear optimization that could be done i think
00:10:14 <Cale> Veinor: yeah, and the head xs forces that list to stay in memory
00:10:29 <augur> supercompile head xs to elimiate a use of xs, and tco the application of 1 + last xs
00:10:36 <augur> well, pseudo tco
00:10:51 <Veinor> whereas the other way around the gc can go 'welp' and just ignore xs
00:11:18 <Cale> yeah, because head xs computes quickly, and then there are no further references to xs elsewhere as last xs is computed
00:11:27 <Cale> So the list becomes garbage as it's computed
00:11:47 <Veinor> makes sense.
00:28:44 <q0tw4> Who tests Supero? Can it optimize somthing like (\xs -> last xs + head xs) [1..100000000]?
00:34:43 <tickle`> why does ((read "1") == (read "2")) throw a parse error exception instead of a type error?
00:35:00 <shachaf> tickle`: Why would it be a type error?
00:35:15 <shachaf> (The parse error isn't GHC complaining, it's "read".)
00:35:25 <Veinor> tickle`: it doesn't know what to read them 'as'
00:35:35 <Veinor> so it makes a guess, and tries to read them as ()
00:35:40 <tickle`> shachaf: I know it's read
00:35:42 <Veinor> which naturally fails
00:36:02 <Veinor> > read "1" == read "2"
00:36:03 <lambdabot>   *Exception: Prelude.read: no parse
00:36:06 <Veinor> > read "()" == read "()"
00:36:06 <lambdabot>   True
00:36:10 <tickle`> but shouldn't it give a type error about ambiguity? since there isn't enough context to determine what to read as?
00:36:26 <shachaf> tickle`: No, it defaults to the type ().
00:36:38 <tickle`> shachaf: where does it say that?
00:36:43 <Veinor> tickle`: that'd make 'print 2' not work
00:37:03 <tickle`> Veinor: no. ghc has a defaulting mechanism for numeric types
00:37:29 <tickle`> ie, default (Integer,Double)
00:37:37 <tickle`> so where is the () default coming from?
00:39:04 <Veinor> ah
00:39:08 <Veinor> "The unit type () is added to the start of the standard list of types which are tried when doing type defaulting.
00:39:13 <Veinor> in ghci
00:39:27 <tickle`> Veinor: where's that from?
00:39:37 <Veinor> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/interactive-evaluation.html
00:39:42 <shachaf> @google "The unit type () is added to the start of the standard list of types which are tried when doing type defaulting."
00:39:45 <lambdabot> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/interactive-evaluation.html
00:39:45 <lambdabot> Title: 2.4.�Interactive evaluation at the prompt
00:40:16 <tickle`> ah, excellent
00:40:17 <tickle`> thanks
00:40:49 <tickle`> it appears to be ghci-specific
00:41:22 <Veinor> yeah
00:41:41 <Veinor> like it says, it's so printf works
00:45:30 <tickle`> hugs behaves stranger:
00:45:32 <tickle`> Hugs> read "5" == read "6"
00:45:32 <tickle`> False
00:45:54 <Veinor> huh
00:46:00 <Veinor> what's it reading them as?
00:46:20 <tickle`> Integer, I think
00:57:06 <The_Journey> hi, what is the syntax "=>" in haskell?
00:57:11 <The_Journey> *for
00:57:43 <carpi> The_Journey: i think it means that a certain type variable must belong to a certain typeclass
00:58:05 <The_Journey> carpi: can you give an example where one might use it?
00:58:32 <Veinor> doubler :: (Num a) => a -> a
00:58:35 <Veinor> doubler x = 2 * x
00:59:04 <The_Journey> Veinor: so what does the (Num a) => a do exactly?
00:59:08 <carpi> like say if you see "(Num a) => a -> [a]" in a function signature then it implies that the function takes a value of any type as long as it is an instance of the num typeclass and returns a list of the same type
00:59:16 <alistra> The_Journey: it's a type class
00:59:30 <Veinor> The_Journey: the (Num a) applies to the entire signature, not just a
00:59:32 <alistra> it's like a java interface~
00:59:35 <Veinor> so it's (Num a) => (a -> a)
00:59:58 <Veinor> and it means 'doubler can be of type a -> a for any type a that is an instance of Num'
00:59:58 <The_Journey> so like it will work with double or ints?
01:00:03 <Veinor> yeah
01:00:06 <alistra> for each a, implementing the type class methods of num
01:00:07 <shachaf> alistra: It's really not helpful to make jokes about things that confuse people just when people are asking questions and are confused.
01:00:08 <The_Journey> oh!
01:00:14 <carpi> yup
01:00:16 <Veinor> because Double, Int, Integer, and Float and all that are instances of Num
01:00:21 <The_Journey> gotcha
01:00:22 <Veinor> but, say, Bool and String aren't
01:00:24 <q0tw4> something like Num -> Num but this is not valid for haskell
01:00:32 <alistra> shachaf: jokes?
01:00:33 <shachaf> The_Journey: It's called a "constraint".
01:00:47 <alistra> type class mechanism is exactly java interface mechanism
01:00:53 <shachaf> alistra: What does "~" actually mean when *you* say it?
01:01:05 <carpi> so you can pass arguments of type Double, Int, Integer and FLoat to a function with type signature (Num a) => a -> [a] for instance
01:01:05 <shachaf> "exactly"? That's going a bit far.
01:01:06 <Veinor> alistra: java interfaces don't have default implementations
01:01:12 <alistra> "something like"
01:01:18 <The_Journey> can I declare my own typeclass like Num?
01:01:29 <shachaf> Veinor: They also can't overload on return value. And a bunch of other things.
01:01:30 <shachaf> The_Journey: Yes.
01:01:39 <The_Journey> what would be the syntax?
01:01:44 <shachaf> The_Journey: However, when people first learn about type classes, they tend to overuse them. :-)
01:01:48 <Veinor> . o O (the type system your type system could check like)
01:01:58 <alistra> Veinor: what's a default implementation
01:02:15 <Veinor> alistra: for Eq, (==) defaults to the negation of (/=) and vice-versa
01:02:20 <Veinor> you implement one, you get the other
01:02:24 <shachaf> The_Journey: class Foo a where { f :: Int -> Foo; b :: Foo -> Int }
01:02:50 <Veinor> shachaf: you mean f :: Int -> a, i assume
01:02:53 <shachaf> Veinor: That's not a particularly interesting feature of type classes.
01:03:00 <shachaf> Veinor: ...Yes.
01:03:03 <Veinor> shachaf: well, sure, but it was the first thing that sprang to mind
01:03:10 <shachaf> class Foo a where { f :: Int -> a; b :: a -> Int }
01:03:20 <shachaf> Also, s/b/g/
01:03:25 * shachaf sighs.
01:04:38 <alistra> the only interfaces i remember in java were serializable and enumerable
01:04:53 <alistra> from my 2 week java experience
01:04:59 <Veinor> anyway, i need sleep
01:05:21 <alistra> @src Traversable
01:05:21 <lambdabot> class (Functor t, Foldable t) => Traversable t where
01:05:21 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
01:05:21 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
01:05:21 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
01:05:21 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
01:07:11 <alistra> > ??(1,2,3??)
01:07:12 <lambdabot>   <no location info>: parse error on input `??'
01:07:19 <alistra> no trigraph support
01:07:40 <alistra> another example, why C is better
01:08:48 <Saizan> doesn't ghc have an optimization called something like "projection thunks"? google doesn't find anything about it
01:17:35 <salisbury> augur: you around?
01:17:43 <augur> always!
01:17:48 <salisbury> :)
01:18:31 <Saizan> oh, it's selector thunks
01:18:42 <salisbury> Ever since I read that paper of yours the other day, I've been thinking on a linguistics bend
01:19:13 <salisbury> Do you know of any good reading on processes by which humans acquire language?
01:19:24 <salisbury> specifically grammar
01:20:10 <augur> salisbury: lol. well, noone really knows. but im also definitely not the person to ask.
01:20:18 <augur> email jeff lidz, im sure he could give you some good pointers
01:21:45 <salisbury> from maryland?
01:23:04 <augur> yeah
01:23:37 <The_Journey> what is the typeclass Ord in Haskell?
01:24:52 <salisbury> Will do, thanks
01:25:55 <salisbury> I'm going through the stuff on grammar @ augury as well. I'm convinced that knowledge from linguistics can help in machine learning. Just not sure how yet
01:26:32 <augur> lol
01:26:35 <augur> well good luck ey
01:26:50 <salisbury> thanks
01:27:28 <augur> i dont do acquisition, so jeff is my only access to that world of thought
01:27:35 <augur> i would trust anyone he trusts, basically
01:27:43 <The_Journey> if I'm going to write a type signature of a function that takes in a list of a numeric type and returns the maximum element in that list, what would it look like? (Num a)  => [a] -> a?
01:29:38 <q0tw4> :t maximum
01:29:39 <lambdabot> forall a. (Ord a) => [a] -> a
01:31:14 <Saizan> :t maximum :: Num a => [a] -> a
01:31:15 <lambdabot>     Could not deduce (Ord a) from the context (Num a)
01:31:15 <lambdabot>       arising from a use of `maximum' at <interactive>:1:0-6
01:31:15 <lambdabot>     Possible fix:
01:32:03 <Saizan> The_Journey: to use stuff like max, (>=) or compare you need Ord, because that's the typeclass for types with an order on them, and which provides those methods
01:32:38 <Saizan> The_Journey: Num doesn't provide those, even indirectly it only provides (==)
01:32:48 <Saizan> since Eq is a superclass of Num
01:32:54 <Saizan> ?type (==)
01:32:55 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:32:57 <q0tw4> :t maximum :: (Num a, Ord a) => [a] -> a
01:32:58 <lambdabot> forall a. (Ord a, Num a) => [a] -> a
01:32:59 <carpi> can it be said that '>>=' is composition at the level of monads whereas '.' is composition for functions?
01:33:05 <carpi> or would i be wrong?
01:33:46 <carpi> maybe its not a 1-1 relationship.. .. but i just want to know if it is safe to think like that..
01:34:48 <augur> salisbury: in case it wasnt obvious, im at umd, so jeff is one of the people ive taking classes with
01:35:03 <The_Journey> would I represent an empty string as [] ?
01:35:17 <carpi> The_Journey: nope.. use ""
01:36:02 <carpi> but i think you can pattern match an empty string using []
01:36:17 <The_Journey> I'm trying to write a function that checks how the frequency of a char in a string, would it be better to write the empty case as foo [] = 0 or foo st
01:36:43 <The_Journey> nvm
01:40:40 <shachaf> The_Journey: [] is an empty String, yes. "" is a more specialized name for it. It's the same value but has a more specific type.
01:44:55 <The_Journey> how do I pattern match the first and the last element of a list? would it be (f:xs:l)?
01:45:46 <shachaf> The_Journey: No, you can't do that.
01:45:59 <shachaf> The_Journey: In order to get the last element of a list, you have to traverse the whole list.
01:46:23 <shachaf> This can be an expensive, inefficient, unlazy operation, so you should develop a distaste for it like the rest of us.
01:46:42 <shachaf> (Also, you should learn what : is.)
01:48:29 <The_Journey> what would be the efficient way to drop the last element of a list?
01:48:55 <ion> > init [0..5]
01:48:57 <lambdabot>   [0,1,2,3,4]
01:49:01 <Saizan> @remember shachaf In order to get the last element of a list, you have to traverse the whole list. This can be an expensive, inefficient, unlazy operation, so you should develop a distaste for it like the rest of us.
01:49:02 <lambdabot> It is forever etched in my memory.
01:49:24 <ion> FSVO efficient
01:49:35 <augur> you know
01:49:37 <augur> at some point
01:49:41 <augur> once i understood categorical monads
01:49:49 <shachaf> The_Journey: "init" has all the same problems as "last".
01:49:56 <augur> the monads-as-computation thing became my predominant mental conception of monads
01:50:03 <augur> so.. hooray category theory
01:50:19 <ion> Perhaps not exactly the same. last can’t return anything until it reaches the last element. init can behave lazily.
01:50:20 <The_Journey> shachaf: what problem?
01:50:37 <ion> > take 10 . init $ [0..]
01:50:39 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
01:51:17 <shachaf> Oh, well, fine, not the same problem.
01:52:47 <ion> the_journey: Something like Data.Sequence might be more appropriate if you want finite sequences you can access from both ends.
01:53:35 <Saizan> The_Journey: to recap, init has to traverse the whole input list to produce one without the last element, though this is mitigated by the fact that if you only access the first n elements of the result init only has to look at the (n+1) of the input list because of lazyness
01:55:41 <Saizan> The_Journey: anyhow, it's not a mortal sin to use init if it helps keeping things simple for the moment
01:56:27 <The_Journey> what's the function to capitalize entire string?
01:56:33 <shachaf> map toUpper
01:56:38 <The_Journey> thanks
01:57:06 <shachaf> Saizan: It's not a mortal sin, but I imagine that it'll lead a beginner down the wrong path while they're trying to develop an intuition for lists.
01:57:44 <augur> salisbury: what is your interest in linguistics?
01:59:56 <Saizan> shachaf: i agree, but also that it's fine if being aware of the implications one decides to focus on other parts of the code instead
02:00:12 <shachaf> Saizan: Fair enough.
02:06:01 <The_Journey> say if I was going to write a palindrome checker that ignores the case, would it be like this? palindrome xs = (head (map toUpper xs)) == (last (map toUpper xs)) & palindrome (init (map toUpper (tail xs))), what would be a better so that I don't have to use toUpper everywhere?
02:07:00 <shachaf> First, comparing the toUpper of a character isn't sufficient to compare it case-insensitively.
02:07:04 <shachaf> But let's ignore that.
02:07:06 <augur> The_Journey: palindrome xs = let xs' = map toUpper xs in xs' == reverse xs'
02:07:16 <shachaf> Second, you don't need to map toUpper on every iteration. Just once.
02:07:27 <shachaf> Third -- well, augur already gave an answer away.
02:07:41 <augur> :)
02:07:54 <The_Journey> lol dude calm down, learning Haskell for first time
02:07:57 <shachaf> augur: I think The_Journey was trying to figure it out rather than be given a solution.
02:08:05 <shachaf> The_Journey: Right! That's why I'm saying these things. :-)
02:09:13 <ion> “Calm down”?
02:09:23 <Saizan> palindrome xs = let ys = map toUpper xs in head ys == last ys && palindrome (init (tail ys)) -- this would be how you just avoid repeating map toUpper everywhere
02:09:49 <The_Journey> what does map toUpper xs in xs' do exactly?
02:09:53 <ion> Generally, avoid Data.Char.toUpper. Use Data.Text.toUpper instead.
02:10:21 <augur> The_Journey: let xs' = map toUpper xs in ... just derives a new version of xs where everything is toUpper-ed
02:10:26 <augur> and calls it xs'
02:10:30 <ion> (Although in thise case you might want toCaseFold.)
02:10:54 <augur> you want to compare only the uppercased version of xs with its reverse
02:11:01 <augur> so you just make the uppercased version!
02:11:07 <augur> and then you work on that.
02:11:16 <Saizan> The_Journey: "let x = <expression> in <body>" defined x to be equal to <expression> in the scope of <body>
02:11:22 <Saizan> *defines
02:12:04 <ion> let xt = T.toCaseFold (T.pack xs) in xt == T.reverse xt
02:14:01 <carpi> is there any way to stop a fold and return the result it has so far?
02:15:54 <ion> > foldr (\x acc -> if x < 10 then x:acc else [-2]) [-1] [0..]
02:15:55 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,-2]
02:16:19 <The_Journey> if I try to write palindrome xs = let xs' = map toUpper xs in xs' = (head xs) == (tail xs) && palindrome (init (tail xs)), ghci spits an error at me, how should I fix it?
02:17:02 <Saizan> The_Journey: palindrome xs = let xs' = map toUpper xs in (head xs') == (tail xs') && palindrome (init (tail xs'))
02:17:35 <Saizan> i guess you also want last instead of tail in the first occurrence
02:17:50 <Saizan> The_Journey: so like this: palindrome xs = let xs' = map toUpper xs in (head xs') == (last xs') && palindrome (init (tail xs'))
02:17:56 <The_Journey> how would that work if I were to pass in two string instead of one and I want to toUpper both of them?
02:18:16 <ion> map palindrome [string, another]
02:18:47 <etpace> Is there a "stack trace" monad? Something applicable to all functions that take an argument of the same type and on "fail" calls a stacktrace function with a list of the arguments currently called?
02:19:41 <Saizan> The_Journey: if you have a function that takes two strings and want to toUpper both you can write "f xs ys = let xs' = map toUpper xs; ys' = map toUpper ys in ...", where f is the name of the function in question
02:19:54 <The_Journey> Saizan: ah ok, thanks
02:20:12 <The_Journey> crazy functional language >_>
02:20:59 <Saizan> of course giving a name to the toUpper versions is only useful if you use them more than once, just like before
02:27:19 <beefcube> i'm trying to install haskell locally under debian squeeze, when running: ./configure --enable-user-install --prefix=/home/jpf/local/hp-2011.2.0.1 ; make I get the error: "<command line>: cannot satisfy -package Cabal-1.10.1.0, " I'm pretty sure this is because I have cabal 1.10.2.0 instead in: /home/jpf/.cabal/lib/Cabal-1.10.2.0/ghc-7.0.3, what is the fix for this?
02:28:19 <Saizan> is that version of the haskell platform supposed to work with your compiler?
02:28:49 <beefcube> Saizan: checking..
02:29:28 <beefcube> Saizan: yes
02:30:48 <Saizan> do you have more than one ghc installed? you might need to point ./configure to the correct one, otherwise see if ghc-pkg list Cabal also lists the other version
02:31:06 <beefcube> compiler is: ghc-7.0.3-x86_64-unknown-linux installed to /home/jpf/local/ghc-7.0.3
02:32:18 <jobski> what's a good start for learning haskell
02:32:20 <Saizan> is it in the $PATH ?
02:32:26 <Saizan> @where LYAH
02:32:26 <lambdabot> http://www.learnyouahaskell.com/
02:32:32 <Saizan> jobski: that ^^^
02:32:39 <jobski> good hehe
02:32:54 <jobski> need to sharpen up.. my chops are blunt
02:35:02 <beefcube> Saizan: yes, /home/jpf/local/ghc-7.0.3/bin
02:35:29 <beefcube> Saizan: I had to manually delete a prior install to /usr/local/bin, i'm not sure if i omitted something else
02:35:55 <The_Journey> does anyone have a source of good practice programs so one can practice writing Haskell?
02:37:41 <beefcube> Saizan: ah, WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
02:37:42 <beefcube> /home/jpf/local/ghc-7.0.3/lib/ghc-7.0.3/package.conf.d
02:37:42 <beefcube>    Cabal-1.10.1.0
02:37:42 <beefcube> /home/jpf/.ghc/x86_64-linux-7.0.3/package.conf.d
02:37:43 <beefcube>    Cabal-1.10.2.0
02:43:39 <Saizan> beefcube: ah, so maybe Cabal-1.10.1.0 is broken? what does ghc-pkg check says?
02:43:57 <Saizan> othersie it might be that configure's check is not quite appropriate
02:44:26 <beefcube> some rm'ing of those and reinstall of the compiler did the the trick (its gotten past that and into the compile) thanks
02:52:18 <Polarina> Why do the get and put instances for Float and Double in both binary and cereal use decode-/encodeFloat instead of IEEE754? Are they somehow more accurate, more convenient?
02:53:48 <carpi> can someone please tell me how to go about solving Problem 6 at http://haskell.org/haskellwiki/99_questions/21_to_28
02:53:58 <Saizan> Polarina: maybe they are more portable?
02:54:36 <Polarina> Saizan, decodeFloat function is of type (Integer, Int), and the size of Int isn't exactly portable...
02:55:48 * hackagebot base-unicode-symbols 0.2.2.3 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.2.3 (RoelVanDijk)
02:56:41 <Saizan> well, i guess the assumption is that the exponend won't ever be more than 30bits large :)
02:57:41 <carpi> just a hint would be nice )
03:00:50 * hackagebot containers-unicode-symbols 0.3.0.6 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.0.6 (RoelVanDijk)
03:14:36 <sanjoyd> How to make a Monad out of (Either String)?
03:15:32 <Philonous_> @type return
03:15:33 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
03:15:33 <shachaf> They need to do way import module>
03:15:49 <shachaf> Control.Monad.Instances, I think.
03:15:51 <shachaf> Or .Error.
03:15:56 <shachaf> Or maybe it's Data.Either.
03:16:02 <shachaf> Something like that.
03:20:35 <Saizan> we should push a gsoc project to solve this
03:23:24 <shachaf> Saizan: Solve what?
03:24:19 <Saizan> have hoogle or haddock or both aware of where instances are defined/exported
03:42:57 <carpi> anyone? :(
03:46:12 <mauke> carpi: I'd probably start by writing select :: [a] -> [(a, [a])]
03:46:38 <mauke> select "abc" = [('a', "bc"), ('b', "ac"), ('c', "ab")]
03:47:13 <mauke> hmm, that may not help because of ordering
03:47:37 <carpi> mauke: shouldnt it be select :: Int -> [a] -> [[a]] ??
03:47:51 <mauke> no
03:48:25 <carpi> mauke: because the problem statement mentions that the funtion must produce all combinations of list [a] with length 'Int'
03:48:43 <mauke> not "the function"
03:48:52 <mauke> the function 'combinations'
03:50:45 <carpi> ah yes.. so "combinations" must produce a list of 'a' where each 'a' is itself a list of length Int
03:51:11 <carpi> the thing is i am trying to visualize the output
03:51:37 <carpi> in the example given, the output is ["abc", "abd", "abe"...]
03:52:18 <carpi> but im sure that also implies ["bca", "bac", "cba", cab".....]
03:52:44 <mauke> what do you mean by "implies"?
03:53:05 <carpi> maybe i should stop inventing my own idea of what the output should be and just look at what the problem says the output shold be
03:53:56 <mauke> got a working solution
03:54:15 <carpi> mauke: in the given example.. i assume they didn't list out all possible combinations of length 3 for brevity.. and that is why i assumed that the rest of the list implies ["bca", "bac", "cba"...] and so on
03:54:21 <carpi> mauke: i envy you.. pffff
03:54:23 <mauke> what do you mean by "implies"?
03:55:56 <carpi> i meant that the problem might have given a misleading example
03:56:08 <mauke> how?
03:56:18 <carpi> ah shite.. im complaining like bith.. i must solve it..
03:56:39 <carpi> mauke: you ssaid you solved it.. can you please tell me what is your output like?
03:56:50 <mauke> in what way?
03:57:13 <carpi> like just the signature
03:57:20 <mauke> *> length (combinations 3 (replicate 12 'X'))
03:57:21 <mauke> 220
03:57:28 <mauke> combinations :: Int -> [a] -> [[a]]
03:57:49 <carpi> so the sginature is as i thought it should be )
03:58:26 <carpi> why am i even learning haskll.. i cant even spell
03:58:34 <carpi> s/haskll/haskell
03:58:43 <ciaranm> because haskell uses lots of <*$*> operators instead of words
03:58:45 <mauke> haspell
04:00:15 <mauke> *> take 10 (combinations 3 [0 ..])
04:00:15 <mauke> [[0,1,2],[0,1,3],[0,1,4],[0,1,5],[0,1,6],[0,1,7],[0,1,8],[0,1,9],[0,1,10],[0,1,11]]
04:01:02 <ciaranm> @hoogle (<$?>)
04:01:02 <lambdabot> Text.Parsec.Perm (<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
04:01:02 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
04:08:48 <carpi> mauke: major breakthrough.. here ) The wording of the problem statement is defeintely wrong. it should be permutuations and not combinations.. because the order of the sublists matter - )
04:09:08 <mauke> no, order doesn't matter
04:09:54 <carpi> if order doesn't matter then a list like [1, 3 , 2] is equal to [1,2,3]
04:10:01 <carpi> which is not the case
04:10:07 <mauke> yes, it is
04:15:42 <carpi> my bad.. it is combinations yup.. but combinations without repetitions.. : (
04:26:19 <hpaste> Flippeh pasted “Whyyy” at http://hpaste.org/55365
04:26:24 <FliPPeh_> Why can't I do that?
04:26:54 <FliPPeh_> I mean, the result type may be generic, but it's also typeclassed and thus has a known behavior
04:27:04 <FliPPeh_> The compiler should be able to reason about it just fine
04:28:44 <Stevo> hey guys,  currently doing a 234 tree in haskell http://ultrastudio.org/en/2-3-4_tree, and need help with a function to do with insertion. One of the properties is that when you get to a certain node that is full that you have to go create a new node
04:28:54 <Stevo> how can i check to see if anode is full?
04:29:21 <mroman> What's NBTValue?
04:29:50 <FliPPeh_> In this case it's an ADT like NBTValue = TagEnd | TagFloat Float | TagDouble Double | ..
04:29:53 <Botje> Stevo: that depends on your representation.
04:29:55 <FliPPeh_> A few ints mixed in there
04:30:04 <FliPPeh_> I just want to unbox the float and double there
04:30:24 <Botje> Stevo: if you have separate constructors for each case in your tree it's easy
04:30:26 <Stevo> Botje: here is my data type data Tree234 a = EmptyTree | TwoNode a  (Tree234 a) (Tree234 a) | ThreeNode a a (Tree234 a) (Tree234 a) (Tree234 a)| FourNode a a a (Tree234 a) (Tree234 a) (Tree234 a) (Tree234 a) deriving (Show, Read, Eq)
04:30:42 <Botje> so a node is full if it's a FourNode, surely?
04:30:44 <FliPPeh_> I mean, the prelude "pi" returns a "(Floating a) => a" without any parameters
04:30:50 <FliPPeh_> So it should be possible, right?
04:32:22 <FliPPeh_> Otherwise I'd have to use float2Double or something :/
04:32:50 <Stevo> Botje: ah okay so if a node is a four node go do the split no need to check to see if the four node is full because by definition it should be full when it is created
04:33:15 <mroman> FliPPeh_: The type of a can not be deduced I guess.
04:33:17 <Botje> to be honest, i haven't read the entirety of the article you linked
04:33:21 <Botje> but I know about B-trees :)
04:33:23 <mroman> unboxFloating (TagFloat v) = Just v
04:33:28 <mroman> requires v to be Float
04:33:32 <FliPPeh_> yep
04:33:39 <mroman> and (Floating a) does not say that v is a Float.
04:33:53 <Philonous_> FliPPeh_:  It's the other way around. You are not free to return any type with a Floating instance but you instead promise to deliver for ALL of them
04:33:58 <FliPPeh_> I thought it would deduce that both would contain a member of Floating
04:34:03 <Botje> Stevo: ah, the part where nodes are sent up the tree is .. less fun.
04:34:45 <FliPPeh_> Well, float2Double it is
04:34:50 <FliPPeh_> Thanks anyways :)
04:35:21 <Philonous_> FliPPeh_:  What did you expect to do with it, anyway?
04:36:08 <Botje> okay!
04:36:09 <FliPPeh_> Philonous_: Well, both TagFloat and TagDouble contain members of Floating, so I thought instead of forcing the Float to become a Double, I could just return a generic floating point
04:36:13 <Stevo> Botje: let's just say this has been one of my least fun assignments iv gotten over the past few years :P mainly because it seems like there is so much to acount for! Well i know b trees are directly related to 234 trees so understanding some of the common aspects is probably a good appraoch
04:37:01 <Botje> nice and hard algorithms stretch the brain
04:37:05 <Philonous_> FliPPeh_:  Existentials would actually allow you to do it. data Floats  = forall a . Floating a => Floats a
04:37:19 <Stevo> on a cold saturday morning what more could i ask for!
04:37:20 <Botje> Stevo: implement the "down" insert first
04:37:45 <Botje> that is, expand the nodes in your tree
04:37:46 <Philonous_> FliPPeh_:  You can than package up anything with a Floating instance and pass it around
04:37:50 <Botje> and handle the split case when that's done
04:38:11 <Botje> because splitting requires you to insert values nodes back up the tree
04:38:21 <Philonous_> FliPPeh_:  The problem ist, when you take it out again you don't know anything about it except that it is a float (any old float, really), so you can't do much with it
04:38:43 <Botje> << gaming!
04:38:45 <Philonous_> FliPPeh_:  Pardon, I meant except that it has a Floating instance
04:40:14 <Stevo> Botje: okay well i have my single node insertion done that s simple enough singleNode :: a -> Tree234 a singleNode x = TwoNode x EmptyTree EmptyTree but would i also need to create seperate functions to add for specific nodes or should they all be in the same function?
04:40:42 <Botje> Stevo: your insert function should have different cases for the varying amounts of nodes
04:41:01 <Botje> and it's only the FourNode case that requires you to propagate a value back up the tree
04:41:52 <Stevo> yeah the four node is the one that will test my mind and will
04:42:05 <Stevo> the others are fairly straight forward applications and i undersand their princeples
04:42:55 <mroman> Philonous_: How would you unbox from existential types?
04:43:10 <mroman> data NBTValue = forall a. Floating a => TagSomeFloat a
04:43:50 <mroman> unbox (TagSomeFloat a) = Just a ain't valid.
04:43:58 <carpi> mauke: can you please show me how you did your version?
04:45:16 <mroman> unbox :: NBTValue -> Maybe p
04:45:25 <mroman> GHC can't deduce (a ~ p)
04:46:10 <Stevo> Botje: you wouldnt have a implementation of a b tree that I could use a reference by any chance? just to double check that my functions are making sense
04:46:26 <Botje> not really, no
04:48:44 <Botje> best to run the algorithm by paper a few times to get the hang of it
04:55:57 <mauke> carpi: just a second, I need to adapt my paste script
04:56:14 <carpi> ok )
04:59:38 <phoinex> Hi I am new in Haskell and I am looking to learn more about it :D
05:00:59 <carpi> phoinex: problem 6 at http://haskell.org/haskellwiki/99_questions/21_to_28
05:01:05 <carpi> thats a good place to start )
05:01:24 <mauke> carpi: except it's problem 26
05:01:38 <phoinex> I also got some books :D and I use XMonad as my window manager...
05:02:07 <carpi> ah yes.. problem 26. sry
05:02:49 <Stevo> :phoinex : http://learnyouahaskell.com
05:03:02 <phoinex> I have that in e-book form :D
05:03:10 <phoinex> very good...
05:05:12 <byorgey> phoinex: awesome!
05:05:18 <byorgey> you have come to the right place.
05:05:40 <mauke> carpi: http://hpaste.org/55369
05:05:44 <phoinex> Yes I shoud think so :D
05:05:50 <mauke> and now I have to debug my paste script because it still doesn't work
05:07:17 <carpi> mauke: you mean it doesn't give the output we seek?
05:07:26 <Stevo> Botje: how would i say if  Node2 then do this? like i know it may be used with a guard but its the actually command im confused on how im supposed to write it
05:07:30 <mauke> carpi: who is "we"?
05:08:41 <byorgey> Stevo: use pattern-matching?
05:08:50 <Stevo> Botje: i guess what i have written down in psuedo code is,  Insert Element B : If Node2 then create Node3 (a,b)
05:08:58 <byorgey> f (Node2 _) = ... ;  f _ = ...
05:10:25 <Stevo> bygorgey: So that literally says if Node2 (ignore its elements) equals something then do this
05:11:51 <carpi> i meant me.. or rather I oopsy
05:14:12 <mauke> carpi: I wasn't aware you had a copy of my paste script
05:14:37 <carpi> you gave the url earlier
05:16:06 <mauke> no, I didn't
05:17:56 <carpi> http://hpaste.org/55369
05:18:31 <mauke> that's my 'combinations' solution
05:19:05 <carpi> yea.. what other solution are you referring to?
05:19:22 <mauke> none
05:19:28 <mauke> I only mentioned this one solution
05:21:11 <Philonous_> mroman:  That's the point, you can't. You can only use it's Floating interface
05:22:20 <byorgey> Stevo: no, there's no equality testing going on there
05:22:27 <Philonous_> > let combinations n = filter ( (==n) . length) . (filterM (const [True,False])) in combinations 3 "abcde"
05:22:29 <lambdabot>   ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
05:22:58 <byorgey> Stevo: it says 'if the argument to f is of the form Node2 (ignoring its contents), then f should evaluate to this. Otherwise, f should evaluate to that.
05:23:37 <Stevo> oke doke
05:23:52 <shachaf> Philonous_: (==n) . length :-(
05:24:56 <Philonous_> shachaf:  Not pretty, but works. I have yet to come up with a better one-liner (-ish)
05:27:06 <byorgey> :m +Math.Combinatorics.Species; map getSet $ enumerate (ksubset 3) "abcde"   -- ;)
05:28:25 <Feuerbach> carpi: I guess mauke meant some script that can upload code to hpaste.org, not something he posted there
05:28:48 <Feuerbach> but it was indeed a bit confusing when I read the chat logs
05:33:31 <carpi> oh.. it would be really nice if there was such a script.. it would avoid the manual copying and pasting.. to hpaste.org..
05:35:49 <byorgey> there used to be, http://hackage.haskell.org/package/PastePipe
05:35:54 <byorgey> but it has bit-rotted
05:36:33 <carpi> bit rotted?
05:36:41 <carpi> not maintained?
05:36:58 <byorgey> Not maintained and no longer works due to outdated dependencies etc.
05:37:09 <byorgey> there is, however, an emacs module for uploading to/downloading from hpaste from within an emacs buffer, http://www.haskell.org/haskellwiki/Hpaste.el
05:40:19 <etpace> If I have ConT with a the Reader monad, and I jump to an "upper" level with a callCC, will I have the inner env of the reader monad or the outter? (I guess the outter?)
05:41:10 <carpi> mauke: why do you use '<-' with tails xs in your try.hs code?
05:41:45 <carpi> after all tails is returns a proper list without having to do all that unboxing
05:42:23 <mauke> ... unboxing?
05:42:38 <carpi> wrong word sory
05:42:42 <Feuerbach> carpi: it's a list monad
05:43:08 <carpi> but tails doesn't have type IO [a]? i tried that line in ghci.. gives an error
05:43:23 <Feuerbach> IO is not the only monad
05:43:32 <Feuerbach> [] is a monad as well
05:44:52 <carpi> but when i do "(n : ns) <- tails "abcdef" i get this error "Couldn't match expected type `IO t0' with actual type `[[a0]]'
05:44:58 <carpi> in ghci that is
05:45:51 <Feuerbach> > do (n : ns) <- tails "abcdef"; return (n,ns)
05:45:51 <lambdabot>   [('a',"bcdef"),('b',"cdef"),('c',"def"),('d',"ef"),('e',"f"),('f',"")]
05:46:35 <Feuerbach> can someone recommend a good tutorial on monads for carpi?
05:46:42 <mauke> carpi: yes, because ghci runs in IO
05:49:05 <Feuerbach> carpi: try e.g. http://en.wikibooks.org/wiki/Haskell/Understanding_monads and then http://en.wikibooks.org/wiki/Haskell/Advanced_monads#The_List_monad
05:50:19 <carpi> thanks.. im going thru them )
05:52:20 <carpi> I just went through the first paragraph.. and I realized something...
05:52:28 <hpaste> mauke pasted “apparently it works now” at http://hpaste.org/55377
05:53:01 <carpi> that im a long ways away from writing a minecraft clone )
05:53:06 <Nibble> carpi: you need help?
05:53:07 <byorgey> hahahaha
05:53:36 <byorgey> carpi: why would you want to do that?
05:53:47 <Nibble> why wouldn't you
05:54:51 <byorgey> =)
05:55:22 <Feuerbach> carpi: this one uses list comprehensions instead of monads, maybe it's easier to understand http://hpaste.org/55378
05:57:14 <mauke> carpi: http://mauke.dyndns.org/stuff/perl/pastebin
05:57:58 <mroman> Philonous_: But what's the point of doing stuff with it when you can not get the result?
05:58:08 <carpi> Feuerbach: this one seems like it makes more sense for me.thanks
05:58:30 <carpi> Nibble: thanks for offer. Ill remember )
05:58:33 <mroman> It's like putting something in a box, do the calculations in the box
05:58:40 <mroman> but you can not actually take it out of the box.
05:58:56 <mroman> you can write
05:59:00 <Nibble> carpi: I just joined in, care to TLDR it for me?
05:59:11 <mroman> let add (SomeTagFloat a) (SomeTagFloat b) = SomeTagFloat $ a + b
05:59:23 <carpi> byorgey: i think it would be super nice to have a minecraft clone.. with one big difference though.. instead of manually controlling the  character.. you write haskell code to control the character to build whatever you want : )
06:00:02 <byorgey> carpi: hehe, awesome =)
06:00:06 <mroman> hm no.
06:00:11 <mroman> that is illegal too
06:00:23 <carpi> Nibble: TLDR?
06:01:08 <Nibble> carpi: too long, did not read
06:01:37 <mroman> although let square (TagSomeFloat a) = TagSomeFloat $ a*a
06:01:39 <mroman> works.
06:01:46 <Philonous_> mroman:  Yes, it's illegal because you know that both are Floating, but not that they have the same type
06:01:56 <mroman> But how am I supposed to get the result of that computation?
06:02:05 <byorgey> by calling Floating methods on it
06:02:17 <Philonous_> mroman:  Types are reased during compile time, so all you have left during runtime is the associated dictionary of the Instances
06:03:40 <carpi> Nibble: oh.. in summary.. i've been scratching my head since morning over a 'combinations' problem.. and some benevolent haskellers on this channel were helpful. and just when i though i got the hang of it.. mauke introduced list monads. So im engaged in another round of learning = ). the journey goes on . And in between we've been talking about haskraft. The yet to be made minecraft clone : D
06:03:53 <mauke> it's not "list monads"
06:04:03 <mauke> I just used the fact that list is a monad to write my code
06:04:15 <mauke> it's really just hiding calls to concatMap
06:04:31 <mauke> well, the pattern matching thing is cute
06:04:46 <carpi> hmm
06:04:50 <mroman> I can only extract the value through hacks
06:04:51 <mroman> like
06:05:26 <mroman> let unbox (TagSomeFloat a) = (read (show a)) :: Float
06:06:13 <mroman> Which is in some way a typecast :)
06:06:18 <mauke> carpi: combinations n xs = concatMap (\tmp -> case tmp of { [] -> []; y : ys -> concatMap (\cs -> [y : cs]) (combinations (n - 1) ys)) (tails xs)
06:06:34 <mauke> pretty unreadable, but I think that's the 'do'-less version
06:06:37 <mroman> typeCast = read . show
06:07:23 <mroman> except that let typeCast = read . show is not valid.
06:07:24 <Philonous_> mroman:  That won't work. You are implying that showing you value will yield a meaningful representation of a float
06:07:50 <mroman> Philonous_: It works if there is a Float inside TagSomeFloat
06:08:00 <Nibble> carpi: ah, list monads. well, they are magic
06:08:06 <Philonous_> mroman:  Yeah, but if you knew it where Floats you could just say so
06:08:29 <carpi> mauke: im still happy with the 'do' version.. gives me something new to learn about : )
06:08:39 <mroman> Philonous_: How?
06:08:48 <mroman> let unbox (TagSomeFloat a) = a :: Float is not valid.
06:08:59 <mauke> carpi: 'do' mostly hides calls to >>=
06:09:14 <mauke> so if you want to understand that code, you need to look up how >>= is implemented for lists
06:09:27 <Philonous_> mroman:  You want to mix values of different type without remembering which ones are which. Of course you can't do anything with the resulting mess. On the bright side you can get a handle on them by asserting that they have some Type class and use that
06:09:40 <Philonous_> mroman:  Data TagSomeFloat = TagSomeFloat Float
06:10:03 <mroman> That's not the same anymore.
06:10:06 <mroman> I can't stuff Doubles in that.
06:10:31 <Philonous_> mroman:  Of course not. As I said, if you don't remember which types your values have you can't do anything meaningful with them
06:10:42 <Feuerbach> Philonous_: it's similar how things work in OO-languages, isn't it. There they have to make addition a method that takes the other operand (of a possibly different type)
06:13:01 <Philonous_> mroman:  You could however store an explicit type representation (and get something akin to dynamic typing), then you can cast them back to their original type.
06:13:11 <Philonous_> mroman:  http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Dynamic.html
06:17:21 <Stevo> Botje: right this is what i have so far http://pastebin.com/TPwL0SP1 does it look like im on the right track?
06:17:23 <mauke> The paste TPwL0SP1 has been copied to http://hpaste.org/55379
06:23:28 <benmachine> unbox (TagSomeFloat a) = realToFrac a -- probably faster than read . show
06:24:02 <benmachine> < mroman> except that let typeCast = read . show is not valid <-- why not?
06:41:13 <Stevo> right got a bit of these insertion functions for a 234 tree http://pastebin.com/qk09xDN2 anyone want to have a look?
06:41:15 <mauke> The paste qk09xDN2 has been copied to http://hpaste.org/55382
06:41:38 <etpace> Hmm.. I've rolled my own monad for "exit with stacktrace" which has the unwiedly type of: StackTrace msg e r a = StackTrace { runStack :: [e] -> (msg -> [e] -> r) -> (a -> r) -> r }, now I'm
06:41:43 <etpace> sure this could be cleaned up using transformers
06:41:44 <Nibble> Stevo: goddamn thats a lot of repetetive action
06:42:01 <etpace> Is it something like a double Cont and reader?
06:42:34 <Stevo> Stevo: Such is life !
06:42:43 <Stevo> Nibble: Such is life !
06:44:37 <hpc> etpace: write Monad and MonadCont instances and see if it becomes nicer to use
06:45:21 <Nibble> lol you pinged yourself
06:45:50 <benmachine> etpace: looks a *bit* like [e] -> Either (msg, [e]) a
06:46:07 <benmachine> hmm is that some combination of ErrorT and StateT perhaps
06:46:14 <ddarius> Stevo: What do you do if x == y in various cases
06:52:03 <Feuerbach> Is automatic dictionary capture (like this http://hpaste.org/55383) possible to express without the GADT syntax?
06:53:09 <mauke> why is Foo :: * -> * and not *?
06:53:29 <benmachine> mauke: if it was * then the Eq instance wouldn't work
06:53:38 <mauke> why not?
06:53:54 <benmachine> because two Foos would contain equatable types but not necessarily the same one
06:54:07 <mauke> ah
06:54:13 <benmachine> Foo 'x' :: Foo, Foo () :: Foo
06:54:20 <benmachine> but equating them makes no sense
06:54:31 <Feuerbach> yes, existentials won't do here
06:54:45 <hpc> Feuerbach: data Eq a => Foo a = Foo a
06:54:56 <ddarius> hpc: That doesn't do the same thing.
06:55:02 <Feuerbach> hpc: that doesn't capture the dictionary
06:55:11 <Feuerbach> just gives a constraint
06:55:32 <hpc> oh i see
06:55:46 <hpc> you would still have to say instance Eq a => Eq (Foo a) where
06:55:50 <mauke> data Foo s = (Eq s) => Foo s
06:57:52 <Feuerbach> mauke: nice, I didn't expect that to work. thanks.
06:59:56 <Stevo> ddarius: http://pastebin.com/Ud5CKtTG the otherwise should of caught them but apparently not
06:59:58 <mauke> The paste Ud5CKtTG has been copied to http://hpaste.org/55384
07:02:06 <ddarius> Stevo: The otherwise does handle it for the cases you had otherwises.
07:02:59 <Stevo> ddarius: well now it seems to get around the problem of identical elements
07:03:57 <benmachine> mauke: does that work?
07:04:02 <benmachine> oh wait it does
07:28:19 <Botje> Stevo: I don't think you need the cases for EmptyTree.
07:28:36 <Botje> since addNode x EmptyTree = TwoNode
07:28:55 <Botje> sp you can drop lines 19-22 and 12-14 i think
07:29:17 <Botje> oh wait, no
07:29:20 <Botje> it's not always like that
07:29:23 <Botje> brr :[
07:57:50 <Stevo> Botje: well at the moment im trying to think about how to deal with the split, was thinking i have to record the depth and we recursively go back and re add things?
08:05:24 <Ornedan> How do I direct a file to stdin with ghci :main? Like when running "./Main < /path/to/file"
08:06:36 <kmc> hm, not sure you can
08:11:42 <matrixhelpneeded> hi guys: I have a list of matrizes [[[a,b],[a,b]],[[a,b],[a,b]]] for example. What I want is something similar to "zip", Index 1 of Matrix forming a new matrix with index 1 of all other Matrizes...
08:12:14 <benmachine> matrixhelpneeded: so what type would your function have?
08:12:31 <kmc> can you give some examples inputs/outputs of this function?
08:12:45 <matrixhelpneeded> Yeah sure, give me a sec
08:13:06 <carpi> could someone please tell .. what is the differnece between fmap and map? is the only difference that map only works on lists whereas fmap can work on any type that is instance of functor?
08:13:11 <matrixhelpneeded> [[[Integer]]] -> [[[Integer]]] bascially
08:13:43 <kmc> carpi, yes
08:13:47 <matrixhelpneeded> Practically what I have is a sudoku, and i just divided my 9x9 field into 9 single 3x3 Fields
08:13:49 <kmc> on lists, fmap and map do the same thing
08:14:12 <kmc> carpi, it would be sensible to eliminate 'map' and then rename 'fmap' to 'map'
08:14:32 <carpi> so fmap is a more generalized version of map?
08:14:35 <kmc> yes
08:14:47 <kmc> instance Functor [] where { fmap = map }
08:14:50 <wereHamster> very informative: http://www.haskell.org/cabal/users-guide/#cabal-file-format
08:14:51 <matrixhelpneeded> This is one example of my output: I entered a [[Integer]] and got as output: [[[0,0,3],[0,0,6],[0,8,9]],[[0,3,1],[0,7,5],[6,9,4]],[[9,1,2],[0,0,0],[0,0,0]],[[4,5,0],[0,0,6],[1,2,3]],[[6,7,4],[0,0,0],[5,3,0]],[[3,0,0],[2,9,0],[8,4,0]],[[0,0,0],[1,2,3],[4,5,6]],[[8,9,5],[3,0,0],[2,0,0]],[[0,0,0],[6,0,0],[0,0,0]]]
08:15:09 <carpi> how come we don't have something like ffilter?
08:15:37 <carpi> ah i guess that wouldn't be necessary because filter only takes types that are instances of EQ
08:15:40 <kmc> that requires more structure than Functor
08:15:48 <kmc> that's not true
08:15:50 <kmc> :t filter
08:15:50 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:15:58 <carpi> yup .. not ture
08:16:08 <matrixhelpneeded> Isn't it possible that i have a [[[Integer]]] -> [[[Integer]]] which zips together the single indizes of the inner matrizes?
08:16:44 <kmc> carpi, i'm not sure what the generalization of filter is, but it will require more than Functor
08:17:15 <kmc> take a look at Data.Foldable and Data.Traversable
08:17:37 <matrixhelpneeded> me?
08:17:41 <kmc> carpi
08:18:43 <benmachine> I'm not sure even traversable is enough for filter
08:18:47 <carpi> kmc: yea?
08:18:55 <kmc> no, i don't think it is
08:18:58 <benmachine> Alternative'll do it
08:19:00 <benmachine> I think
08:19:02 <wereHamster> where can I find documentation of the cabal file format?
08:19:03 <benmachine> or MonadPlus
08:19:10 <benmachine> but they may be overkill
08:25:08 <mzero> carpi - think of it this way: one can't generalize filter for Functor because the filtering operation has to know how to exclude values from the resulting "structure" - Functor doesn't specify a way to modify the structures
08:27:07 <MiggyX> Hi guys, has anyone here done any research on Haskell from the point of view of productivity?
08:27:50 <mzero> Only personal experience!
08:28:04 <mzero> but I wouldn't be surprised if someone had
08:29:34 <parcs`> how do you measure productivity?
08:30:54 * hackagebot transformers-base 0.4.1 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.4.1 (MikhailVorozhtsov)
08:31:43 <heatsink> How does shrinking work in QuickCheck?
08:31:52 <MiggyX> One of the things I'm looking into at the moment, is how various software engineering methodologies focus on time and project management but focus relatively little on the aspects of programming. There are lots of tedious things with development that eat brain power but aren't very productive.
08:32:04 <mzero> there are standard experimental methods: set half dozen teams to do some series of programming tasks - see how many each team completes in some time.... and yes, there are loads of caveats to such an approach
08:32:39 <MiggyX> mzero: that's part of the problem - very hard to build convincing evidence for it
08:33:04 <mzero> MiggyX: this is my gripe with Scrumm --- when I started leading teams doing "eXtreme programming", over a decade ago, it was very heavily focused on the act of programming - I loved, and the teams were productive
08:33:10 <hpaste> Carpi pasted “scope anomoly” at http://hpaste.org/55392
08:33:11 <carpi> can someone please take a look..? ^^^ I might have found a bug in haskell..
08:33:18 <carpi> just kidding :D
08:33:36 <mzero> then a few years ago the shop I was at went "Scrumm" and I was told by "certified scrum masters" that programing and coding were not part of the process
08:33:37 <mzero> !
08:33:40 <jessopher> wereHamster: its at http://www.haskell.org/cabal/users-guide/ sort of. the format changes between versions, and you can use historical versions of cabal  from any version, so its kind of hard to nail it down
08:34:02 <danr> carpi: lambdas extend as far as possible to the left (also linebreaks)
08:34:07 <MiggyX> mzero: I'm thinking that it might be a case of not seeing the wood for the trees :) These methodologies are too focused on project management rather than the programmers creativity
08:34:41 <simon> mzero, programming isn't part of the process of software development?
08:34:45 <danr> carpi: gf in in scope exactly because it is defined in a lambda in the previous line
08:34:52 <MiggyX> It's surprising how much time can be spent deciding on directory structure or even what to name classes etc...
08:35:02 <mzero> no, simon, they told me that programming wasn't part of the "Scrumm process"
08:35:07 <MiggyX> mzero: I dread to think what they think IS part of the process lol
08:35:18 <mzero> that was a niggling detail for mechanicals to worry about  (okay, my wording)
08:35:50 <simon> MiggyX, planning how to spend your time.
08:35:51 <carpi> danr: oh.. so if i define a lambda in a function, then the names i use inside are available thru out the function?
08:36:01 <ion> heatsink: You can try it out yourself. Run e.g. “shrink 42”, “shrink 2”, “shrink 1”, “shrink 0”, “shrink [0, 1]” in ghci.
08:36:01 <simon> MiggyX, I reckon timeplanning is crucial. :-P
08:36:04 <mzero> MiggyX: that is one of the things I *love* about pair programming: I find pairs tend to settle those questions quicker -- individuals tend to waffle for long periods of time on such issues
08:36:14 <MiggyX> simon: which is precisely the issue I'm raising ;)
08:36:33 <MiggyX> mzero: agreed :)
08:36:41 <simon> mzero, pair programming as in two people in front of a computer, or two people working on two computers in parallel?
08:36:43 <mzero> carpi: no throughout the lambda only - which in your past starts after the open-paren on line 3 and extends to the last close on line 4
08:36:59 <danr> carpi: what mzero said :)
08:37:00 <mzero> simon: two people, one computer
08:37:29 <mzero> (though it is nice if you have two keyboards and two mice... now if only most code editors would allow two cursors and two edit points)
08:37:47 <heatsink> What's the strategy used to choosing values that are "smaller" but still likely to trigger a bug?
08:38:10 <MiggyX> I was also wondering whether the "no side effects" of Haskell would help with brain power conservation :)
08:38:15 <heatsink> For example, I noticed that shrinking negative ints can produce positive ints, but shrinking positive ints won't produce negative ints
08:38:39 <Nibble> heatsink: wat
08:38:40 <mzero> (we sometimes pair programmed using SubEthaEdit and two computers, but editing the same set of files -- that way we could each select and type - at the same time - in the same file - as we talked and programmed together. A totally delightful way to code, and very effective )
08:39:04 <heatsink> > shrink (-101)
08:39:05 <lambdabot>   Not in scope: `shrink'
08:39:27 <matrixhelpneeded> hi guys: I have a list of matrizes [[[a,b],[a,b]],[[a,b],[a,b]]] for example. What I want is something similar to "zip", Index 1 of Matrix forming a new matrix with index 1 of all other Matrizes...
08:39:34 <ziman> I can't talk when programming.
08:39:48 <matrixhelpneeded> I need help on this problem, can't figure out a good way to realize it
08:39:58 <ion> heatsink: I suppose one can think of dropping the minus sign as reducing the amount of information.
08:39:59 <carpi> mzero: ah yes.. got it.. i failed to notice the extra parenthesis at the end
08:40:00 <jmcarthur> matrixhelpneeded: transpose?
08:40:10 <simon> I think I like to vary between talking and programming as well.
08:40:12 <MiggyX> mzero: Figured this might be an interesting area to do research in but I thought I'd test the water first :)
08:40:20 <jmcarthur> > transpose [[[a,b],[a,b]],[[a,b],[a,b]]]
08:40:21 <lambdabot>   [[[a,b],[a,b]],[[a,b],[a,b]]]
08:40:26 <jmcarthur> err
08:40:30 <jmcarthur> > transpose [[a,b],[a,b]],[[a,b],[a,b]]
08:40:30 <matrixhelpneeded> huch?
08:40:31 <lambdabot>   <no location info>: parse error on input `,'
08:40:38 <ion> heatsink: If shrink (-1) resulted in 1 and shrink 1 resulted in (-1) you’d get an infinite loop.
08:40:39 <matrixhelpneeded> I want something different jmarthur
08:40:40 <simon> but synchronizing your thoughts often does reduce the amount of stupid choices I make.
08:40:50 <simon> s/your/my/
08:40:58 <jmcarthur> oh i see
08:41:07 <jmcarthur> matrixhelpneeded: maybe you should just look into repa
08:41:11 <matrixhelpneeded> i have a LIST of matrices
08:41:14 <matrixhelpneeded> repa?
08:41:37 <jmcarthur> it's a library for working with multidimensional arrays
08:41:54 <mzero> matrixhelpneeded: your example is a bit confusing as you have only two things in that list -- what do you expect to happen if you have five matrices in the list?
08:42:16 <heatsink> Ok, ion, so shrink should define a partial order with a least element.  X > Y means that X is a more complex input than Y.
08:42:21 <heatsink> Is that right?
08:42:30 <matrixhelpneeded> look: practically what i have is a sudoku, and for some reasons i need to make 9 3x3 matrixes out of it
08:42:50 <matrixhelpneeded> and i store these 3x3 submatrices (of the big 9x9 matrix) in a list
08:42:54 <jmcarthur> matrixhelpneeded: in repa you could make a 9x3x3 array
08:43:09 <matrixhelpneeded> i have it already jmarthur
08:43:12 <jmcarthur> and then collapse it along any one of those dimensions (which i think is what you want)
08:43:15 <jmcarthur> calm down
08:43:18 <jessopher> i can imagine a vcs where you have a split view of the checked out code you are working on, and the checked out code your other is working on, with a 'conversation' view where you each comment on each others edits
08:43:36 <mzero> ah - matrixhelpneeded, is this a problem set with a given input format? that would be good to know!
08:43:38 <matrixhelpneeded> this is what I have to work with: [[[0,0,3],[0,0,6],[0,8,9]],[[0,3,1],[0,7,5],[6,9,4]],[[9,1,2],[0,0,0],[0,0,0]],[[4,5,0],[0,0,6],[1,2,3]],[[6,7,4],[0,0,0],[5,3,0]],[[3,0,0],[2,9,0],[8,4,0]],[[0,0,0],[1,2,3],[4,5,6]],[[8,9,5],[3,0,0],[2,0,0]],[[0,0,0],[6,0,0],[0,0,0]]]
08:43:41 <jessopher> i dunno if that would help productivity though
08:43:53 <jmcarthur> matrixhelpneeded: i'm suggesting that lists are not a good idea for matrix stuff
08:44:01 <jmcarthur> they are awkward and slow for this purpose
08:44:11 <jmcarthur> and repa already supports the operation you want
08:44:14 <mzero> jmcarthur: I suspect we are dealing with a homework problem
08:44:24 <jmcarthur> yeah i'm thinking so too
08:44:25 <matrixhelpneeded> totally not
08:44:32 <mzero> then why is the list mandated?
08:44:36 <wereHamster> jessopher: I looked here: http://www.haskell.org/cabal/users-guide/#cabal-file-format. Pretty useless I have to say
08:44:38 <matrixhelpneeded> mandated?
08:45:11 <matrixhelpneeded> I think it's the best way to solve it, as I thought i could do a thing like zip
08:45:13 <mzero> sorry - we interpreted your remarks as indicating that you couldn't look at repa because the list of matrix format was mandated from outside your control
08:45:25 <jessopher> wereHamster: yeah the easiest way to get a handle on it is to look at the cabal file for a recent package, and reference the user guide
08:46:00 <mzero> so - okay, you've got a list of 9 3x3 matrices - what is the "zip like" operation you are after? apply a nine-argument function to each of the 3x3 positions?
08:46:01 <matrixhelpneeded> checking out repa....but I think as far as I am, there has to be a way to do it with prelude...
08:46:09 <matrixhelpneeded> nope
08:46:11 <jmcarthur> you can do it with prelude
08:46:23 <jmcarthur> it's just going to be awkward
08:46:34 <mzero> so I'm unclear on what the "zip like" operation you are after is
08:46:41 <jmcarthur> i'm suspecting it's more of a fold
08:46:44 <matrixhelpneeded> well, if it is possible
08:46:49 <jmcarthur> collapse a list of matrices down to one matrix
08:46:54 <matrixhelpneeded> i don't even have to compute it this way
08:47:22 <matrixhelpneeded> I just need a check that all of the matrices in the list have a certain property...let's formulate it this way
08:47:26 <mzero> do you want to combine two matrices, get a result, then combine that result with the next matrix in the list, etc?
08:47:28 <jmcarthur> so if you write the operation you want with two matrices then you should be able to fold it over your list
08:47:46 <jmcarthur> if i'm making the right assumptions here
08:48:02 <matrixhelpneeded> maybe it helps you understand if i give you the concrete problem
08:48:08 <mzero> ah, so you want     all  f  myBitListOfMatrices   where f is a 3x3 -> Bool   ?
08:48:25 <mzero> yes, matrixhelpneeded, it would!
08:48:27 <matrixhelpneeded> i want: [[[Integer]]] -> Bool
08:48:32 <jmcarthur> ah
08:48:42 <MiggyX> Also out of curiosity, has anyone here ever used Haskell to solve a finite difference problem?
08:48:44 <jmcarthur> mzero is on the right track then
08:48:57 <mzero> do you decide the bool over each 3x3 matrix individually, and then 'and' the results together?
08:48:58 <matrixhelpneeded> and it should be true WHEN
08:49:04 <matrixhelpneeded> wait
08:49:10 <matrixhelpneeded> Not individually, combined
08:49:30 <roconnor> MiggyX: finite diffrences of types or of numbers?
08:49:35 <matrixhelpneeded> index 1 of matrix 1, index 1 of matrix 2, index 1 of matrix 3, ...... index 1 of matrix 9, and THEN index 2 of matrix 1, index 2 of matrix 2, .....
08:49:59 <matrixhelpneeded> all index 1 of all matrices have to differ from each other, for ALL indices
08:50:14 <MiggyX> roconnor: numbers. I figured it would look much cleaner with recursion, but after searching around I couldn't find that much on it
08:50:36 <mzero> matrixhelpneeded: - so you want to compute a Bool given, say, the top-left of all nine matrices?   - then and that with the top-middle of all nine, etc...?
08:50:48 <matrixhelpneeded> yes! YES that's it mzero!
08:50:54 * hackagebot happstack-plugins 6.3.1 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.3.1 (JeremyShaw)
08:50:57 <matrixhelpneeded> well
08:51:03 <matrixhelpneeded> basically with ALL 9 of these matrices
08:51:03 <roconnor> MiggyX: ah; I have nothing then
08:51:29 <matrixhelpneeded> i have 3x3 so i want to compare each of top lefts, each of the top middles, each of the top rights, etc
08:51:52 <MiggyX> roconnor: not to worry, I just saw people talking about matrices and thought it was worth asking :)
08:51:55 <mzero> matrixhelpneeded: one last question -- is this operation only defined if there are 9 matrices? or is the same idea if there are n --- I'm asking if the boolean test is    [Int] -> Bool    or Int -> Int -> (... 9x) -> Bool
08:52:21 <matrixhelpneeded> only for 9 matrices!  it should look like this
08:52:40 <mzero> ah -
08:52:42 <matrixhelpneeded> [[[Integer]]] -> Bool
08:52:49 <matrixhelpneeded> for example
08:53:35 <matrixhelpneeded> if the function is named check: check [[[0,0,3],[0,0,6],[0,8,9]],[[0,3,1],[0,7,5],[6,9,4]],[[9,1,2],[0,0,0],[0,0,0]],[[4,5,0],[0,0,6],[1,2,3]],[[6,7,4],[0,0,0],[5,3,0]],[[3,0,0],[2,9,0],[8,4,0]],[[0,0,0],[1,2,3],[4,5,6]],[[8,9,5],[3,0,0],[2,0,0]],[[0,0,0],[6,0,0],[0,0,0]]] -> True
08:54:16 <_oz> matrixhelpneeded: great, that can be one of the cases. you just need to enumerate all the others :)
08:54:27 <heatsink> lol
08:54:42 <matrixhelpneeded> lol _oz
08:55:01 <matrixhelpneeded> mzero are you still here?
08:55:07 <_oz> matrixhelpneeded: you are trying to implement a sudoku checker right?
08:55:08 <mzero> yes, I'm thinking
08:55:15 <mzero> and experimenting in ghci
08:56:25 <_oz> if yes, (to me) an easier way to think about it is to partition the 9x9 matrix into lists and check if they satisfy the property
08:56:26 <mzero> matrixhelpneeded:        map test $ concatMap transpose $ transpose m
08:56:47 <mzero> you need transpose from Data.List
08:56:56 <matrixhelpneeded> let me check that
08:57:16 <_oz> no need to deal with 3x3 matrices, as that information isn't needed. if you are implementing sth else, ignore this tho.
08:58:13 <mzero> > let byPositions = concatMap transpose . transpose in byPositions [["abc","def","ghi"],["123","456","789"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
08:58:15 <lambdabot>   ["a1A!","b2B@","c3C#","d4D$","e5E%","f6F^","g7G&","h8H*","i9I+"]
08:58:15 <matrixhelpneeded> hmm mzero....I'm a bit confused
08:58:54 <matrixhelpneeded> but mzero u only have [[]], and i have a list of these....?
08:59:11 <mzero> no "abc" is [Char]
08:59:28 <matrixhelpneeded> true
08:59:52 <matrixhelpneeded> okay this works....
09:00:38 <matrixhelpneeded> let byPositions = concatMap transpose . transpose in byPositions [["abc","def","ghi"],["123","456","789"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:00:40 <mzero> > let byPositions = concatMap transpose . transpose in byPositions [[[1,2,3],[4,5,6],[7,8,9]],[[11,12,13],[14,15,16],[17,18,19]],[[21,22,23],[24,25,26],[27,28,29]],[[31,32,33],[34,35,36],[37,38,39]]]
09:00:41 <lambdabot>   [[1,11,21,31],[2,12,22,32],[3,13,23,33],[4,14,24,34],[5,15,25,35],[6,16,26,...
09:00:49 <matrixhelpneeded> this is cool
09:01:30 <matrixhelpneeded> dont know if i get how it works yet
09:01:57 <mzero> it isn't too hard to see:
09:01:58 <jmcarthur> @src transpose
09:01:58 <lambdabot> transpose []             = []
09:01:59 <lambdabot> transpose ([]   : xss)   = transpose xss
09:01:59 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:02:05 <mzero>  transpose [["abc","def","ghi"],["123","456","789"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:02:14 <mzero>  > transpose [["abc","def","ghi"],["123","456","789"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:02:25 <jmcarthur> > transpose [["abc","def","ghi"],["123","456","789"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:02:26 <lambdabot>   [["abc","123","ABC","!@#"],["def","456","DEF","$%^"],["ghi","789","GHI","&*...
09:02:39 <matrixhelpneeded> wow
09:02:47 <jmcarthur> > transpose ["foo", "bar", "baz"]
09:02:48 <lambdabot>   ["fbb","oaa","orz"]
09:03:04 <mzero> so that puts all the rows together from the various sets
09:03:21 <jmcarthur> > unwords . transpose . words $ "foo bar baz"
09:03:22 <lambdabot>   "fbb oaa orz"
09:03:30 <matrixhelpneeded> it works yes
09:03:35 <matrixhelpneeded> it's exactly what i need
09:03:44 <matrixhelpneeded> why is it a simple transpose? i don't get why but it works
09:04:02 <jmcarthur> think about transpose as an index transformation
09:04:18 <mzero> it "spreads" the rows out, essentially --- it is easier to see how it works when you let the elements be strings --- as the first transpose essentially ignores the rows - treated them as individual elements
09:04:25 <jmcarthur> (count the outer list in your indices)
09:04:29 <mzero> then the map transpose does the inner
09:05:43 <matrixhelpneeded> that's it mzero, i don't even need this
09:05:48 <mzero> matrixhelpneeded: probably worth spending some time to see if you can make a narrative for yourself that explains
09:06:00 <matrixhelpneeded> the simple transpose it the solution, no map needed the way i see it
09:06:22 <mzero> well, that'll give you a different answer
09:06:30 <matrixhelpneeded> ???
09:06:50 <mzero> > transpose [["abc","def","ghi"],["123","456","789"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:06:51 <lambdabot>   [["abc","123","ABC","!@#"],["def","456","DEF","$%^"],["ghi","789","GHI","&*...
09:07:04 <mzero> this grouped the top rows of each matrix together, then the middle rows, etc....
09:07:28 <mzero> but then you don't want to apply your boolean test to "abc", right? that's just the row of the first matrix --
09:07:50 <mzero> you wanted to apply your boolean test to 'a', '1' and 'A' considered together, the top-left of each matrix
09:07:52 <mzero> right?
09:08:44 <matrixhelpneeded> but what i have is a list of the top rights then
09:09:06 <matrixhelpneeded> the first list is a list of the top rights, the 2nd list is a list of the top middles, isn't it?
09:09:56 <mzero> in the simple transpose? no
09:10:02 <fryguybob> > unwords . transpose . words $ "atom tame omen mend"
09:10:03 <lambdabot>   "atom tame omen mend"
09:10:08 <mzero> think of what ["abc","def","ghi"]
09:10:12 <mzero> is
09:10:14 <mzero> it is
09:10:17 <matrixhelpneeded> a list of lists
09:10:21 <matrixhelpneeded> a 3x3 matrix
09:10:23 <mzero> abc
09:10:23 <mzero> def
09:10:23 <mzero> ghi
09:10:26 <matrixhelpneeded> yes
09:10:43 <mzero> right and the next one is 123  456 789
09:10:49 <matrixhelpneeded> yep
09:11:02 <mzero> so don't you want, in the end to apply your boolean to   a  1  A  !
09:11:05 <mzero> ?
09:11:11 <matrixhelpneeded> and this makes the list abc,123,....
09:11:24 <mzero> then apply it to    b 2 B @
09:11:26 <mzero> etc...
09:11:27 <matrixhelpneeded> ooh...you are right
09:11:31 <mzero> :-)
09:11:40 <matrixhelpneeded> damn i still don't get it then, ok i have my transpose
09:11:47 <matrixhelpneeded> and now?
09:12:14 <mzero> so transposing a list of matrices, brings all the same rows together ---- all the first rows in a list, then all the second rows, etc....
09:12:30 <matrixhelpneeded> yes
09:12:58 <mzero> right so lot at the first result, all the rows:    ["abc","123","ABC","!@#"]
09:13:16 <matrixhelpneeded> > transpose [["abc","def","ghi"],["123","456","789"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:13:17 <lambdabot>   [["abc","123","ABC","!@#"],["def","456","DEF","$%^"],["ghi","789","GHI","&*...
09:13:19 <mzero> now you want all the first elements, then all the seconds, then all the thirds...e tc...
09:13:21 <mzero> right?
09:13:40 <mzero> so we apply transpose to each of the "sets or rows" produced by the first transpose
09:13:42 <matrixhelpneeded> yes, i nmy example i want: a, 1, A, !
09:13:43 <matrixhelpneeded> exactly
09:13:56 <mzero> > transpose  ["abc","123","ABC","!@#"]
09:13:57 <lambdabot>   ["a1A!","b2B@","c3C#"]
09:14:06 <matrixhelpneeded> aaah yes
09:14:07 <mzero> so we do that for each group, hence:
09:14:18 <mzero> map transpose . transpose
09:14:20 <mzero> BUT
09:14:25 <matrixhelpneeded> what is this dot
09:14:33 <matrixhelpneeded> like Dollar sign?
09:14:36 <matrixhelpneeded> $?
09:15:18 <mzero> oh ----  learn that ---- function composition       (g . f)  x    is    g $ f x    or   g (f x)
09:15:41 <matrixhelpneeded> i see, thanks
09:15:41 <mzero> so it was just a way of talking about the operations we are going apply to the input without specifying the matrix input
09:15:44 <mzero> anyhoot
09:16:02 <matrixhelpneeded> you were about to name a big BUT
09:16:16 <mzero> so, we've now got:
09:16:37 <mzero> > map transpose $ transpose [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:16:38 <lambdabot>   [["a1A!","b2B@","c3C#"],["d3D$","e4E%","f5F^"],["g6G&","h7H*","i8I+"]]
09:16:53 <mzero> but, we don't need this in "matrix" form --- so    concat
09:17:01 <mzero> > concat $ map transpose $ transpose [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:17:02 <lambdabot>   ["a1A!","b2B@","c3C#","d3D$","e4E%","f5F^","g6G&","h7H*","i8I+"]
09:17:06 <mzero> or just simply
09:17:17 <mzero> > concatMap transpose $ transpose [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:17:18 <lambdabot>   ["a1A!","b2B@","c3C#","d3D$","e4E%","f5F^","g6G&","h7H*","i8I+"]
09:17:31 <mzero> OR
09:17:36 <mzero> if you  want to be a Haskellista
09:17:46 <matrixhelpneeded> it's fine like this
09:17:49 <mzero> > transpose [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]] >>= transpose
09:17:50 <lambdabot>   ["a1A!","b2B@","c3C#","d3D$","e4E%","f5F^","g6G&","h7H*","i8I+"]
09:18:54 <matrixhelpneeded> the problem that i have now is....i need to apply a following function: isValid :: [[Integer]] -> Bool
09:19:23 <mzero> map isValid
09:19:31 <matrixhelpneeded> or [Integer] -> Bool
09:19:54 <mzero> or - if you want "if all are true", then    all isValid
09:20:37 <benmachine> > tranpose <=< transpose $ [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:20:38 <lambdabot>   Not in scope: `tranpose'
09:20:42 <benmachine> > transpose <=< transpose $ [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:20:42 <lambdabot>   ["a1A!","b2B@","c3C#","d3D$","e4E%","f5F^","g6G&","h7H*","i8I+"]
09:20:44 <matrixhelpneeded> grr...snytax errors, guess it's confusing
09:20:53 <benmachine> mzero: the real haskellista way :P
09:21:12 <mzero> break it out into local functions and where clauses
09:21:26 <matrixhelpneeded> can i do something like this? all (==True) function(matrix) ?
09:21:41 <mzero> doesn't your function return Bool?
09:21:51 <matrixhelpneeded> it does
09:22:05 <mzero> then just      all isValid $ concatMap transpose $ transpose m
09:22:32 <benmachine> matrixhelpneeded: (==True) is kind of unnecessary
09:22:38 <benmachine> it's a function which takes a bool
09:22:45 <benmachine> and returns True if it's True, or False if it's False
09:22:53 <matrixhelpneeded> aaargh
09:22:53 <benmachine> I can think of another simpler function that does that :P
09:23:20 <matrixhelpneeded> *** Term           : all *** Type           : (e -> Bool) -> [e] -> Bool *** Does not match : a -> b -> c -> d
09:23:22 <mzero> > let isValid = not . ('-' `elem`)  in all isValid $ concatMap transpose $ transpose [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$%^","&*+"]]
09:23:24 <lambdabot>   True
09:23:57 <mzero> > let isValid = not . ('-' `elem`)  in all isValid $ concatMap transpose $ transpose [["abc","def","ghi"],["123","345","678"],["ABC","DEF","GHI"],["!@#","$-^","&*+"]]
09:23:58 <lambdabot>   False
09:24:01 <benmachine> matrixhelpneeded: all (==True) function(matrix) is wrong, btw
09:24:07 <matrixhelpneeded> i have
09:24:12 <benmachine> all (==True) (function matrix) might be what you want
09:24:15 <matrixhelpneeded> all isValidRowSDK (transpose $ transpose (make3x3Sudokus s)) Basic = True
09:24:26 <matrixhelpneeded> and it does not like me
09:24:33 <benmachine> huh?
09:24:33 <mzero> you forgot the concatMap
09:24:47 <matrixhelpneeded> but isValidSDK has following signature
09:24:59 <matrixhelpneeded> isValidSDK :: [[Integer]] -> Variant -> Bool
09:25:03 <benmachine> ahh
09:25:16 <benmachine> at the moment you're passing Basic as the fourth argument to all
09:25:23 <benmachine> not the second argument to isValidSDK
09:25:24 <matrixhelpneeded> that's np
09:25:26 <matrixhelpneeded> totally np
09:25:32 <mzero> why is it a matrix - did you want to "preserve" the top-lefts (say) in the 3x3 matrix form that they came from?
09:25:36 <matrixhelpneeded> oh?
09:25:56 <benmachine> you need something more like all (\xs -> isValidSDK xs Basic) (transpose etc)
09:26:20 <matrixhelpneeded> no, but this is a function which removes all the invalid values in the matrix and then does the check for each row
09:26:33 <ziman> > sequence [[1,2],[3,4]]
09:26:34 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
09:26:36 <mzero> "all the top-lefts" is not a matrix
09:26:38 <mzero> it is a list
09:26:46 <matrixhelpneeded> yes
09:26:52 <mzero> you presented the original input as a list of matrixes, not a matrix of matrices
09:27:03 <matrixhelpneeded> yes it is a list of matrices
09:27:10 <mzero> isValidSDK looks like it wants the top-lefts in a matrix, not a list
09:27:26 <matrixhelpneeded> isValidSDK wants a [[Integer]]
09:27:35 <mzero> that looks like a matrix
09:27:46 <matrixhelpneeded> it is one, but it does List operations
09:27:52 <matrixhelpneeded> wait, ill simply use my rowCheck
09:28:36 <mzero> all (\xs -> rowCheck xs Basic) $ concatMap transpose $ transpose m
09:28:47 <matrixhelpneeded> Ok I'm doing it with this now: isCorrectBasicRow :: [Integer] -> Bool
09:29:15 <mzero> isCorrectBasicRow takes a list of nine elements and checks that there are no dupes? (I'm guessing)
09:29:29 <matrixhelpneeded> yep
09:29:32 <mzero> okay
09:29:42 <mzero> all rowCheck $ concatMap transpose $ transpose m
09:29:43 <matrixhelpneeded> True if no dupes
09:29:57 <mzero> I'd call it .... noDuplicates
09:30:01 <mzero> but hey, call me crazy
09:30:57 <matrixhelpneeded> it compiles
09:31:18 <matrixhelpneeded> need to create a testcase to see if it works give me 1 min
09:31:51 <mzero> matrixhelpneeded: you seem to be writing very long expressions - perhaps you should use local defitions (where) to break things up - will help you following GHC's crazy-moon-poetry error messages
09:32:01 <matrixhelpneeded> yes, it works
09:32:16 * mzero takes a small bow
09:32:24 <matrixhelpneeded> yeah, guess so too
09:32:31 <matrixhelpneeded> mzero, THANK you very very much
09:33:01 <mzero> you're quite welcome
09:33:01 <carpi> in ghci when i start a construct with ':{' and end it with ':}' ... does it mean i can write any haskel code in between?
09:33:23 <benmachine> carpi: I think you write ghci commands in between
09:33:42 <carpi> haskell code can also be use yes?
09:33:48 <ByronJohnson> carpi: Yes
09:33:50 <benmachine> yeah, but not /any/ haskell code
09:33:55 <benmachine> not e.g. data declarations
09:34:03 <benmachine> (at least not until GHC 7.4 :P)
09:34:11 <ByronJohnson> benmachine: :D
09:34:39 <carpi> cos i noticed in ghci .. when im using :{ :} i have to use 'let' if i am defining something..but in a normal file.. i don't have to
09:34:43 <ByronJohnson> carpi: Those are for things that you write in ghci that span multiple lines
09:34:48 <matrixhelpneeded> cool, now I have everything to write my solve function with SOLVES my Sudokus
09:34:56 <matrixhelpneeded> that will be a nice bunch of work, but thanks guys!
09:37:20 <kmc> carpi, :{ :} doesn't change the set of syntax accepted by ghci really
09:37:24 <kmc> it just allows you to use multiple lines
09:37:35 <kmc> anything which can be done with multiple lines in Haskell can also be done with braces and semicolons
09:38:10 <kmc> carpi, you have to use "let" to define stuff in ghci (whether or not using :{ :}) because the GHCi prompt is like an IO "do" block, and not like the top level of a file
09:38:54 <carpi> ah okay.. but the truth is.. even in files.. if you are defining do blocks.. it seems like 'let' must be used
09:39:06 <ByronJohnson> carpi: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html § 2.4.2
09:39:46 <ByronJohnson> carpi: do blocks don't need to be in let
09:40:39 <ByronJohnson> > do {x <- [2,3,4]; guard (even x); return $ x + 3}
09:40:39 <lambdabot>   [5,7]
09:40:49 <benmachine> carpi: if you are in the middle of a do-block, then you must use let to make new bindings
09:40:52 <benmachine> or
09:40:52 <benmachine> <-
09:41:16 <carpi> ByronJohnson: i meant that it seems like let must always be used inside do blocks if defining new bindings
09:42:03 <jmcarthur> new bindings?
09:42:13 <jmcarthur> you mean like local variables?
09:42:30 <jmcarthur> you could always just use   x <- return y,  but i don't see why you'd want to
09:42:30 <carpi> yea
09:43:24 <jmcarthur> that let syntax is a very do-notationy kind of thing. in fact, this is kind of why you have to use it in ghci
09:43:35 <jmcarthur> since ghci is kind of like glorified do notation
09:46:30 <carpi> thanks.. helps with the visualization )
09:47:16 <aavogt> > do let x = x; let y = 1; y <- return (y+1); Just (y,x)
09:47:16 <lambdabot>   <no location info>: parse error on input `<-'
09:47:58 <aavogt> > do { let { x = x }; let { y = 1 }; y <- return (y+1); Just (y,x) }
09:48:02 <lambdabot>   mueval-core: Time limit exceeded
09:48:12 <aavogt> well the y should come out as 2
09:48:40 <aavogt> and the x doesn't since let lets definitions be recursive
09:57:06 <phoinex>  
10:01:46 <junk> [a,b,z,d,e]: How can i insert a value at a specific position into a list to make it [a,b,c,d,e]?
10:02:06 <junk> !!2 makes me access it, but how to set a value?
10:02:21 <mauke> manually
10:03:07 <junk> manually? how?
10:03:42 <mauke> @src []
10:03:42 <lambdabot> data [] a = [] | a : [a]
10:03:52 <mauke> you can write all list functions in terms of that
10:04:18 <monochrom> split up the list, join them again, but with some new stuff and omit some old stuff
10:04:31 <junk> is this the only solution?
10:04:46 <ByronJohnson> monochrom: That sounds inefficient
10:04:47 <dolio> Your desired operation is not a very common one.
10:04:48 <monochrom> and I am too lazy to say more because I don't find it useful
10:04:54 <dolio> So it doesn't have a name.
10:04:56 <junk> because i thought, i can do something like this too: map (\a -> 5) [0,9]
10:05:00 <mauke> junk: what did you expect?
10:05:02 <monochrom> yes it is inefficient and I don't use it.
10:05:26 <junk> cant i say something like map(\a -> 5 for index 2) [0,9]
10:05:33 <junk> or index 1
10:05:35 <dolio> No.
10:05:38 <mauke> yes
10:05:57 <junk> yes?
10:06:03 <mauke> > zipWith (\i x -> if i == 2 then 5 else x) [0 ..] [0, 9]
10:06:04 <lambdabot>   [0,9]
10:06:21 <junk> didn't work
10:06:25 <mauke> yes, it did
10:06:43 <junk> it printed out [0,9]
10:06:46 <mauke> yes
10:06:49 <mauke> so it worked
10:07:11 <junk> but i want to make [0,9] -> [0,5]
10:07:20 <holla> What is the difference between foldl and foldl' ?
10:07:20 <ByronJohnson> > let ins :: (Integral i) => i -> a -> [a] -> [a]; ins 0 i xs = i:xs; ins n i (x:xs) = x : ins (pred n) i xs in ins 4 ':' ['a'..'k']
10:07:20 <monochrom> [0,9] is the right answer if you're asking for replacing the guy at position 2. well [0,9] doesn't have a position 2.
10:07:21 <lambdabot>   "abcd:efghijk"
10:07:26 <mauke> > zipWith (\i x -> if i == 1 then 5 else x) [0 ..] [0, 9]
10:07:27 <lambdabot>   [0,5]
10:07:30 <monochrom> [0,9] -> [0,5] is position 1
10:07:37 <ByronJohnson> junk: That's a "manual" way to write it
10:07:40 <junk> ofc
10:07:47 <mauke> ByronJohnson: no, that inserts an element
10:07:52 <junk> this is waht i wanted, thanks
10:08:01 <aavogt> change the [0 .. ] to  [1 .. ] if it's supposed to start at 1
10:08:04 <ByronJohnson> junk: You're welcome :)
10:08:47 <junk> huh
10:08:55 <junk> sorry, not your solution, i meant the zipWith (\i x -> if i == 1 then 5 else x) [0 ..] [0, 9]
10:09:24 <junk> but that's the problem for 1-dimensional lists....can i adept it to [[a]] matrices?
10:10:11 <monochrom> you can keep working harder for that.
10:10:19 <monochrom> or you can just use an array.
10:10:30 <mauke> > (\(splitAt 1 -> (p, _ : q)) -> p ++ 5 ++ q) [0,9]
10:10:31 <lambdabot>   No instance for (GHC.Num.Num [a])
10:10:31 <lambdabot>    arising from a use of `e_11509' at <in...
10:10:41 <mauke> > (\(splitAt 1 -> (p, _ : q)) -> p ++ [5] ++ q) [0,9]
10:10:42 <lambdabot>   [0,5]
10:10:44 <monochrom> or you can rewrite the whole algorithm to not rely on random-access replacements
10:11:03 <djahandarie> copumpkin, we should add a Newtype instance.
10:11:41 <junk> mauke i meant something like: [0,3][1,2] now modify the number at index 1/1
10:11:53 <copumpkin> djahandarie: I refuse to use the newtype package until it uses type families
10:12:00 <djahandarie> :((
10:12:00 <junk> [[0,3][1,2]]
10:12:19 <copumpkin> djahandarie: clearly the only option is to make newtype-tf
10:12:32 <copumpkin> and to make a conversion between instances ;)
10:12:51 <monochrom> or rather, I mean, use an algorithm that doesn't rely on random-access replacements
10:13:44 <junk> monochrom: then gimme an idea how to do it in another way :)
10:14:13 <junk> mauke: any idea?
10:14:16 <monochrom> I do not know what problem you are solving. And so I do not know what solutions we can choose from.
10:14:30 <junk> solving a half-finished sudoku :)
10:14:41 <mauke> junk: yeah, stop using lists
10:14:48 <monochrom> use an array
10:16:15 <monochrom> there are actually a million sudoku solvers on the haskell wiki. it used to be hot. now no one cares.
10:16:46 <monochrom> http://www.haskell.org/haskellwiki/Sudoku
10:17:44 <kmc> i suggest making a solver for http://en.wikipedia.org/wiki/Kakuro just to be different
10:18:04 <kmc> i have a half-finished blog post with one of these
10:18:09 <kmc> where first you write it using lists
10:18:11 <monochrom> some of those solvers use [[a]]
10:18:24 <kmc> then you change only a few lines of code to generalize to arbitrary MonadPlus
10:18:37 <kmc> then you run that in parallel with http://hackage.haskell.org/package/parallel-tree-search
10:19:09 <kmc> i also wrote a kakuro solver which uses yices
10:19:45 <timthelion> hello, excuse me if i'm completely confused, but are ==> in the list monad and map the same function?
10:19:52 <kmc> because it was the more straightforward way, and i had only about 10 min to write the code
10:20:01 <kmc> timthelion, you mean >>= ?
10:20:01 <jmcarthur> timthelion: i've never seen that operator
10:20:07 <kmc> (>>=) = flip concatMap
10:20:15 <monochrom> I have only seen ==> from QuickCheck
10:20:23 <jmcarthur> ah yeah i have seen that one
10:20:58 <timthelion> oh, yes, sorry I mean >>=
10:21:58 <kmc> > concatMap (\x -> [x, 10*x]) [1,2,3]
10:21:59 <lambdabot>   [1,10,2,20,3,30]
10:22:27 <kmc> > (\x -> [x, 10*x]) =<< [1,2,3]
10:22:28 <lambdabot>   [1,10,2,20,3,30]
10:22:44 <kmc> > [1,2,3] >>= (\x -> [x, 10*x])
10:22:45 <lambdabot>   [1,10,2,20,3,30]
10:23:00 <kmc> > do { x <- [1,2,3]; [x, 10*x] }
10:23:01 <lambdabot>   [1,10,2,20,3,30]
10:23:22 <merijn> timthelion: It's not the same as map, since "map f l" (where f returns a list and l ist type [a]) returns [[a]] where as "l >>= f" returns [a]
10:29:46 <jmcarthur> it's the same as using map and then applying concat to the result
10:29:55 <timthelion> I see.  thank you, I will stick with syntax which does not obfuscate
10:30:20 <jmcarthur> what syntax are you saying obfuscates?
10:30:24 <jmcarthur> >>= ?
10:30:44 <timthelion> yes
10:31:06 <ion> > (permutations <=< subsequences) [0..2]
10:31:06 <jmcarthur> not sure i agree with that entirely, but i see it being kind of weird if you aren't used to it
10:31:07 <lambdabot>   [[],[0],[1],[0,1],[1,0],[2],[0,2],[2,0],[1,2],[2,1],[0,1,2],[1,0,2],[2,1,0]...
10:31:15 <kmc> timthelion, whether it's obfuscation depends on context
10:31:18 <jmcarthur> as with most things in haskell, i guess
10:31:20 <timthelion> horribly :)  any operator that has so many books written about it clearly should be banned ;)
10:31:33 <ion> +
10:31:36 <kmc> the "do" syntax for lists has a natural interpretation as nondeterministic programming
10:31:40 * jmcarthur wonders what books are solely about >>=  ;)
10:31:53 <kmc> that can be much clearer than a big chain of concatMaps
10:32:08 <monochrom> there are more books written about "+" than there are written about ">>="
10:32:32 <monochrom> just ask school math teachers
10:32:51 <kmc> and once you're using the generic operators, it's easy to switch to another implementation of nondeterministic programming
10:32:59 <kmc> like parallel tree search
10:33:19 <kmc> or one of the CPS-based logic monads, which can perform better
10:33:46 <kmc> at my university the graduate-level number theory course was called "introduction to arithmetic"
10:33:53 <kmc> which i guess is also a book by Nicomachus
10:33:55 <monochrom> aptly!
10:33:58 <jmcarthur> i wish it was easier to show newbies that >>= isn't really all that different in how you can approach it from something like +
10:34:19 <kmc> we can do that by inventing burrito analogies for (+)
10:34:22 <ion> It is easy. The explanation involves burritos.
10:34:25 <kmc> ha
10:34:28 * jmcarthur facepalms
10:34:31 <monochrom> I already do. "what 'is' monad?" -> "what 'is' number?"
10:34:32 <kmc> yeah sorry ;)
10:34:38 <merijn> Once I ignored the existence of monads and just looked at the type signature >>= made perfect sense
10:34:46 <jmcarthur> same here
10:34:51 * ArchGT signs for burritos
10:35:57 <monochrom> "I want to 'understand' monad" -> "nothing to understand, no one asks to understand numbers. just go ahead use it, or learn how to use it. use."
10:36:14 <kmc> said book by nicomachus is the origin of the sieve of eratosthenes
10:36:33 <monochrom> it is particularly apt because we have the Num type class to go with it, too. "I want to 'understand' Num"
10:36:42 <timthelion> jmcarthur, well the book i'm reading is gentle introduction to haskell.  and it is written very much with the math major in mind.  I dont know of a comprehensive haskell book in which things like iffs aren't typoes.
10:36:54 <kmc> LYAH?
10:36:55 <ion> Try LYAH.
10:37:00 <timthelion> it is hard to understand just due to the vocabulary gap
10:37:20 <merijn> timthelion: Oh hell, stop reading Gentle Intro
10:37:37 <merijn> I'm not even sure I understand it...
10:38:17 <timthelion> I understood everything up till the chapter on monads and some of the io chapter
10:38:22 <merijn> @quote Brend Gentle
10:38:22 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
10:38:41 <ion> @where lyah
10:38:42 <lambdabot> http://www.learnyouahaskell.com/
10:38:42 <kmc> i learned from the Gentle Introduction and I'm not a math major...
10:38:51 <kmc> but still pretty close to the target audience
10:39:06 <kmc> it's not unreasonable to expect computer scientists to know what "iff" means
10:39:15 <merijn> kmc: Yes, but from what I can tell you're crazy smart like most people here :p
10:39:28 <kmc> but, if you don't like the book, then you should read a different one :)
10:39:42 <ion> “iff you don’t like the book”
10:39:48 <kmc> nice one
10:39:55 <timthelion> merijn, does that detract from my point about the use of vocabulary?
10:41:03 <timthelion> kmc, I understood the part except the monads.  you know, back when it was all just algebra
10:41:11 <merijn> timthelion: You're right that there's quite a bit of vocabulary gap between Gentle Intro and most programmers
10:41:53 <merijn> timthelion: As others said, I personally recommend Learn You a Haskell, the start is a bit slow if you already got far into Gentle Intro. But it does nicely cover everything without assuming any prior knowledge/vocabulary
10:42:01 <kmc> "Our goal is to provide a gentle introduction to Haskell for someone who has experience with at least one other language, preferably a functional language"
10:42:39 <merijn> Also, the writing style and pictures of LYAH just rock :)
10:42:49 <kmc> either that or they're annoying as hell :)
10:42:54 <timthelion> kmc: I have been programming for over a decade :)
10:42:56 * mateu likes both LYAH and RWH
10:43:05 <kmc> timthelion, good for you
10:43:18 <merijn> Real World Haskell is also nice, but I usually recommend it as a follow up to LYAH
10:43:38 <merijn> Since I think the practical examples nicely build on LYAH's fundaments
10:43:55 <mateu> I find reading the two in parallel  is helpful
10:44:20 <monochrom> iff is a great word
10:44:32 <merijn> Agreed
10:44:39 <ion> mateu: Or concurrently?
10:44:42 <mateu> :)
10:44:53 <mateu> left brain RWH, right brain LYAY
10:44:58 <mateu> LYAH*
10:45:02 <monochrom> left eye, right eye
10:45:04 <kmc> my point is that all the jokes about "it's not gentle!!" might be missing the point
10:45:44 <ion> IFF is also the container format i used for the first image and audio files i ever saved.
10:45:47 <merijn> kmc: I know, but they're funny and not nearly as harmful as the useless monad confusion jokes :p
10:46:03 <kmc> if you are already comfortable with functional programming, then the Gentle Introduction is a reasonable way to get up to speed on the details of Haskell
10:46:50 <kmc> whereas i think most of the people we refer to LYAH are also trying to learn how to think functionally
10:46:57 <timthelion> google on iff: 'did you mean if?'
10:48:03 <merijn> Google is becoming increasingly useless to me with their "auto-correct my precise technical terms to commonly searched terms"-behaviour
10:48:30 <Saizan> i get the wikipedia article for if and only if as the third result
10:48:34 <kmc> me too
10:48:38 <ion> Try quotation marks around the search terms.
10:48:42 <kmc> the customization of search results is also annoying
10:49:21 <merijn> I've switched to duckduckgo as default search engine a while back, I still occasionally use Google for obscure errors because their index is larger
10:49:26 <monochrom> your citing google's suggestion is all very well. sure, google suggests that based on statistics from a large corpus. that doesn't have any bearing on what I say about iff being a great word.
10:49:36 <kmc> i'm still not sure if Haskell is a good language for learning "functional programming"
10:49:44 <merijn> But their autocorrect is making the results for those queries less and less useful to me
10:50:09 <merijn> monochrom: That remark was tangential to iff being great :p
10:50:31 <monochrom> oh, I mean the "google on iff: 'did you mean if?'"
10:50:54 * hackagebot HHDL 0.1.0.0 - Hardware Description Language embedded in Haskell.  http://hackage.haskell.org/package/HHDL-0.1.0.0 (SergueyZefirov)
10:51:01 <monochrom> but yes it is tangential. I agree. actually I push for the stronger: irrelevant
10:51:15 <dons> ?yow
10:51:15 <lambdabot> Couldn't find fortune file
10:51:21 <copumpkin> failyow
10:52:24 <timthelion> kmc. I think that haskells main advantage is in opensource projects were you have to read and edit other peoples code.  its easier to understand a third parties haskell then a third parties c. but monads are tough
10:52:40 <dons> just some advertising that the HP release is coming up later today (if things go to plan in the next hour)
10:52:48 <merijn> I think haskell strings being char lists is an advantage for newbies
10:52:56 <kmc> timthelion, i'm not sure the point of comparing Haskell to C here
10:53:02 <kmc> i mean there are hundreds of languages more high-level than C
10:53:15 <merijn> I taught the ocaml practical at uni this month and strings and lack of functions for them really tripped people off
10:53:24 <merijn> Also, lack of generic print functions, etc
10:54:26 <Philonous_> merijn:  Does ocaml even have ad-hoc polymorphism?
10:54:28 <kmc> how did they feel about + and +.
10:54:40 <merijn> kmc: Awful as well
10:54:41 <timthelion> kmc, so compair it to python, its also hard to edit other peoples python code
10:54:45 <kmc> it has super-ad-hoc polymorphism :)
10:54:54 <kmc> meaning, there is one built-in thing which is kind of like the Eq typeclass
10:54:54 <Philonous_> kmc:  How do you mean?
10:55:02 <ion> dons: HP?
10:55:05 <dons> haskell platform
10:55:07 <merijn> timthelion: Really? I haven't had that much trouble
10:55:08 <ion> Ah :-)
10:55:10 <monochrom> oh yikes, dons is coming! every look busy. :)
10:55:16 <monochrom> err
10:55:21 <monochrom> dons is coming! everyone look busy. :)
10:55:21 <dons> hehe
10:55:30 <ion> Is this the second coming?
10:55:33 <kmc> but you can't define other things like this
10:56:08 <Philonous_> kmc:  I haven't looked into it, but don't they have some form of subtyping?
10:56:59 <kmc> also has a magical built-in type for printf format strings
10:57:03 <kmc> Philonous_, guess so; what's the relevance?
10:57:27 <Philonous_> kmc:  That should give you ad-hoc polymorphism, no?
10:57:36 <kmc> what do you mean by "ad-hoc polymorphism"?
10:57:38 <eikke> they have the value restriction!
10:58:03 <merijn> Philonous_: They have structural subtyping
10:59:17 * eikke gave a presentation to students with Haskell knowledge earlier this week, also about ocaml -> http://t.co/RfOnKE04
11:00:33 <copumpkin> dons: have you thought any more about hac boston? :)
11:00:50 <copumpkin> edwardk/ezyang got us lots more space
11:00:58 <copumpkin> we now have room for 80 people!
11:01:14 <dons> yikes.
11:01:19 <copumpkin> (40 wasn't enough)
11:01:26 <dons> haven't thought about it. i have so little spare time these days
11:01:43 <copumpkin> aw, okay
11:02:06 <copumpkin> yeah, your lack of reddit posts suggested that your free time might be limited
11:02:12 <dons> i'm enjoying my work though. :)
11:02:28 <copumpkin> sounds good! many have also remarked that you're enjoying your sunsets
11:02:31 <copumpkin> :P
11:02:44 <dons> its just a lot of 60 hr weeks and coding across 3 timezones.
11:02:49 <copumpkin> wow
11:03:08 <copumpkin> well, if it's fun haskell that you might be writing anyway, it still sounds pretty good
11:03:21 <dons> yeah, its some pretty cool haskell stuff.
11:03:21 <kmc> eikke, nice slides, reading
11:03:26 <copumpkin> 60-hour weeks doing shit work might not be so fun
11:03:47 <eikke> kmc: thanks
11:04:31 <copumpkin> dons: do you know if your company has any plans on releasing shake to the general public? I think ndm mentioned there was some talk going on about it, but I haven't heard any news since
11:04:44 <kmc> oh, i didn't know the haXe compiler is written in ocaml!
11:04:49 <dons> ndm would know. its almost impossible to release stuff.
11:04:55 <copumpkin> ah :/ okay
11:04:55 <dons> pity, since we have some pretty amazing tools
11:05:07 <kmc> dons, where do you work these days?
11:05:13 <copumpkin> I guess bolingbroke made an open-source version, but it's hard to tell how it compares :)
11:05:17 <dons> most of it is all finance-oriented though, so not generally interesting
11:05:25 <dons> kmc: standard chartered.
11:05:50 <kmc> cool
11:08:37 <kmc> copumpkin, 40 people and still only 3 listed projects! :)
11:08:52 <copumpkin> kmc: pfft, listed projects are lame!
11:09:00 <kmc> yeah
11:09:03 <copumpkin> you want organic impromptu projects!
11:09:09 <copumpkin> the kind that blow the world away
11:09:11 <kmc> i'm sure people will be working on things so secret they can't tell me
11:09:14 <kmc> right
11:10:12 * eikke is happy his work is mainly in the open
11:10:21 <ddarius> kmc is Mr. Trustworthy.  Who wouldn't want to gratuitously entrust him with all their secrets?
11:10:35 <ddarius> eikke: What about when it rains?
11:10:41 <eikke> lol
11:15:17 <kmc> regarding ocaml: "Easy to reason about efficiency, predict compiler output; If necessary (unlike GHC) native assembly can be read/interpreted by humans"
11:15:30 <kmc> i wonder if there is demand for a Haskell compiler with similar properties
11:15:43 <copumpkin> I've interpreted GHC assembly before
11:15:46 <copumpkin> it isn't too ridiculous
11:15:52 <eikke> kmc: check the blog on a post about the case I'm referring to. it was a life-saver
11:15:58 <kmc> copumpkin, you're not a human
11:16:01 <kmc> rather some kind of gourd
11:16:10 <kmc> it would be harder to get acceptable performance from a "straightforward" Haskell compiler
11:16:28 <hpc> kmc: he is a co-gourd
11:16:29 <copumpkin> oh, good point
11:16:31 <kmc> "On segmentation faults, stack overflows, GDB and OCaml" ?
11:16:31 <copumpkin> it's easy to forget sometimes
11:16:36 <eikke> that one
11:17:39 <kmc> i started working on a thing to automatically annotate GHC-generated machine code
11:17:54 <kmc> and "decompile" it to some degree
11:18:01 <kmc> but i didn't have a compelling use case so i got bored with the project
11:18:12 <eikke> haha
11:18:34 <kmc> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode has some nice examples
11:18:48 <kmc> also i have a suspicion the ghc runtime system is much larger than the ocaml runtime system
11:18:50 <kmc> is that correct?
11:19:24 <lpsmith> I don't suppose a FFI guru could take a quick peek at this chunk of code,  and see if it's ok.   Is it safe to keep a regular pointer as a finalizer to a foreign pointer and use it outside withForeignPtr?
11:19:33 <kmc> i'll try lpsmith
11:19:36 <lpsmith> https://github.com/lpsmith/haskell-libpq/commit/1c00077423f886715ed00199a2f877f9dadc10cb
11:19:58 <kmc> do you have a self contained example of what you mean?
11:20:51 <eikke> kmc: yes it is, ocaml's runtime is minimal, to say at least
11:21:08 <kmc> of course the GHC runtime provides some great features
11:21:17 <lpsmith> I'm concerned about the "FC.newForeignPtr connPtr (pqfinish connPtr)" part
11:21:24 <kmc> but it's also a source of difficult bugs, since it's basically another operating system
11:21:26 <lpsmith> kmc, no not really, not yet
11:21:48 * BMeph believes the GHC runtime system is larger than many small countries.
11:21:59 <kmc> the GHC RTS is about 50% of the size of linux's "kernel/" directory
11:22:41 <dons> kmc: its larger
11:22:49 <kmc> it's better documented though :)
11:22:56 <dons> its also more useful :)
11:23:32 * BMeph wonders if the GHC RTS is bigger than Windows XP...
11:23:39 <kmc> uh, no
11:23:42 <cgroza> Is there a function that applies a list of functions to a value and return a list of the results?
11:23:50 <kmc> > map ($ 3) [pred, succ]
11:23:51 <lambdabot>   [2,4]
11:23:51 <copumpkin> :t sequence
11:23:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:23:54 <hpc> cgroza: map
11:24:03 <copumpkin> > sequence [(*2), (+5)] 4
11:24:03 <lambdabot>   [8,9]
11:24:08 * BMeph wonders if the GHC RTS is bigger than Windows NT 4, now.
11:24:12 <copumpkin> > flip [(*2), (+5)] 4
11:24:13 <hpc> cgroza: also known as fmap, also known as (<$>), also known as liftM
11:24:13 <lambdabot>   [8,9]
11:24:15 <hpc> cgroza: ;)
11:24:21 <copumpkin> but that flip is magic, so sequence is safer
11:24:28 <hpc> oh, or sequence
11:24:32 <cgroza> hpc: I am looking for something to replace [countWords s, countUniqueWords s, countSentences s]
11:24:46 <dons> ghc's rts is kind of the size of a microkernel
11:24:49 <copumpkin> sequence [countWords, countUniqueWords, countSentences] s
11:24:53 <kmc> lpsmith, FC = Foreign.Concurrent?
11:25:01 <dons> a large microkernel
11:25:07 <lpsmith> The thing is that Foreign.Concurrent.newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
11:25:09 <lpsmith> kmc, aye
11:25:10 <copumpkin> cgroza: sequence is in Control.Monad
11:25:14 <sp3ctum> hi guys. i'm looking for a function that lets me call a shell command and gets its output. how can this be done?
11:25:15 <cgroza> copumpkin: will try it. :D
11:25:18 <BMeph> dons: A macrokernel? ;)
11:25:21 <hpc> > flip' fs x = fmap ($ x) fs in flip' [f, g, h] x :: [Expr]
11:25:22 <lambdabot>   <no location info>: parse error on input `='
11:25:27 <kmc> sp3ctum, http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/process-1.0.1.5/System-Process.html
11:25:28 <hpc> > let flip' fs x = fmap ($ x) fs in flip' [f, g, h] x :: [Expr]
11:25:28 <lambdabot>   [f x,g x,h x]
11:25:37 <kmc> sp3ctum, also http://hackage.haskell.org/packages/archive/shqq/0.1/doc/html/System-ShQQ.html
11:25:45 <lpsmith> so is it safe to keep a copy of the "Ptr a" around inside a closure as part of the finalizer
11:25:46 <sp3ctum> thanks kmc
11:26:44 * BMeph supposes "The GLorious GLasgow Haskell Compilation Run-Time Microkernel" doesn't sound as sexy...
11:26:51 <cgroza> copumpkin: thanks :D.
11:26:53 <kmc> lpsmith, I think it's okay, but I don't have a real compelling argument
11:27:07 <lpsmith> Yeah, I would think it's ok.
11:27:28 <kmc> 'cause the main reason not to keep Ptrs outside withForeignPtr is that they might get finalized while the Ptr is still reachable
11:27:37 <kmc> but this is in the finalizer itself
11:27:40 <lpsmith> Maybe I should read the Foreign.Concurrent paper =)
11:27:46 <lpsmith> yeah, that's kind of my thinking too
11:27:48 <kmc> maybe i should too
11:28:25 <kmc> also seems like this use would be pretty common
11:28:44 <kmc> if it weren't safe, they'd pretty much need to make it newForeignPtr :: Ptr a -> (Ptr a -> IO ()) -> IO (ForeignPtr a)
11:32:11 <lpsmith> yup, I agree
11:32:17 <cgroza> copumpkin: it works in ghci, the same file loads ok. But it errors when compiling with ghc.
11:32:29 <copumpkin> cgroza: "errors"? :)
11:33:12 <cgroza> copumpkin: No instance for (Monad ((->) String)) arising from a use of `sequence'
11:33:22 <copumpkin> import Control.Monad.Instances
11:33:25 <copumpkin> you won't have to do that for long
11:33:29 <copumpkin> but you do right now
11:33:38 <cgroza> copumpkin: ok.
11:33:40 <kmc> oh, is it being moved into Control.Monad?
11:33:41 <hpc> copumpkin: ooh, good news!
11:33:46 <copumpkin> yeah, it's being moved
11:33:58 <lpsmith> kmc, oh, the "Foreign.Concurrent paper" is about C++, not Haskell
11:34:09 <kmc> i think moving it is possibly a bad idea
11:34:10 <cgroza> copumpkin: thanks. it worked.
11:34:21 <kmc> having that instance in scope can make certain type errors into type-correct but wrong code
11:34:30 <kmc> so can most instances, but this is one i've run into in practice
11:34:44 <copumpkin> kmc: that's the reason it was relegated there
11:34:59 <copumpkin> but chances are in any large development, you're going to have someone put it into scope
11:35:11 <kmc> oh?
11:35:17 <copumpkin> and you don't get to hide it after one of your depenencies imports it, so you might as well just accept it
11:35:19 <lpsmith> http://www.hpl.hp.com/techreports/2002/HPL-2002-335.html
11:35:23 <copumpkin> :P
11:35:26 <hpaste> Carpi pasted “IO.ByteString” at http://hpaste.org/55405
11:35:27 <kmc> hmm
11:35:28 <carpi> can someone please take a loot at that? ^^^
11:35:28 <kmc> i guess so
11:35:50 <kmc> carpi, do you have a better error message than "Im getting error here :("
11:36:06 <copumpkin> kmc: for example, Control.Applicative will give you the instance anyway
11:36:26 <kmc> carpi, I'm guessing you wanted to execute the «readFile» IO action and get a bytestring
11:36:34 <kmc> rather than just creating a local alias for that IO action
11:36:46 <carpi> sorry.. the error is "Couldn't match exptected type B.ByteString with actual type IO B.ByteString
11:36:54 <lpsmith> carpi, it would help a lot if you include imports at the top of the hpaste
11:37:06 <kmc> in other words you probably want something like  do { inpfByteStr <- readFile inpf;  crypt' CFB pwdByteStr getIV Encrypt inpfByteStr }
11:37:56 <hpaste> Carpi pasted “with Imports” at http://hpaste.org/55406
11:37:56 <hpaste> Carpi pasted “with Imports” at http://hpaste.org/55407
11:38:10 <carpi> ah shite.. i pressed submit twice
11:38:27 <hpc> carpi: crypt' :: stuff -> B.ByteString?
11:38:49 <carpi> hpc: yup
11:38:56 <carpi> that is the signature..
11:39:03 <carpi> crypt' returns a B.ByteString
11:39:39 <hpaste> monochrom annotated “IO.ByteString” with “IO.ByteString (annotation)” at http://hpaste.org/55405#a55408
11:39:40 <hpc>         inpfByteStr = B.readFile inpf
11:39:49 <hpc> inpfByteStr :: IO B.ByteString
11:39:57 <monochrom> carpi: http://hpaste.org/55405#a55408  which is what everyone says
11:40:04 <hpc> but it's being used as a B.ByteString
11:40:21 <monochrom> I do not understand why you did not just do all your I/O in main.
11:40:43 <carpi> monochrom: because later on i plan on adding some more features.. and didnt want to clutter main
11:40:51 <monochrom> It is the same as: I do not understand why C++ beginners do I/O in their constructors.
11:41:41 <carpi> monochrom: ooh.. i think now i get it..so you mean.. all IO in main.. and pure functionality in rest of code
11:42:00 <hpc> carpi: it helps to put type signaures on things
11:42:18 <hpc> carpi: and not use large where clauses unless they REALLY help with code readability
11:42:42 <monochrom> here is what I mean. you ask students to write a C++ class for complex numbers. (you also say that it is part of a complete program that asks users to input complex numbers, then print out sums etc). here is what they do: the asking-for-user-input happens in the f*cking ctor of Complex.
11:43:49 <monochrom> my conclusion: the urge to do I/O in every function that could have been pure (I mean I/O-less here) is not exclusive to Haskell beginners
11:43:51 <hpc> monochrom: yeah, that makes no sense; a constructor for an HTTP request might do IO though, to begin the connection
11:44:08 <hpc> (doesn't damage your conclusion though)
11:44:21 <monochrom> right, ctor for http or iostream whatever must do I/O. but complex numbers?
11:44:29 <carpi> hpc: to be honest.. the where does look a bit ugly.. and hinders readability.. but how else might you have done it? could you please tell?
11:44:56 <hpc> carpi: trunc can be its own function
11:45:10 <hpc> getIV doesn't need a name
11:45:44 <hpc> and you can make pwdByteStr its own function too
11:45:53 <hpc> parameterize over pwd instead of closing over it
11:45:53 <monochrom> here is my theory of why people have an urge to do that. you know how people write things by stream of consciousness, not by well organization and re-organization and re-factoring. you see this in everyone's blogs. it's the same with everyone's code.
11:46:13 <carpi> hpc: but getIV produces random bytestrings of length 16..
11:46:27 <hpc> carpi: no it doesn't; it's undefined in your paste
11:46:37 <merijn> monochrom: Which is why I think my obsessive-compulsive constant refactoring drive is the main cause of my improvement as a programmer
11:46:52 <monochrom> so, why do people do I/O in Complex's ctor? because writing the ctor is the point when their stream of consciousness say, oh, shoot, I need to ask user for input.
11:46:58 <merijn> I write most of my code about 30 times
11:47:28 <carpi> monochrom: i can tell you what the real problem is.. as folks who have no exprience with medium to large scale software development..its hard to understand why certain forms of coding are preferred over others..
11:47:49 <carpi> and by folks.. i was referring myself.. and others new to haskell
11:48:18 <monochrom> no, do-not-know-what-is-better does not explain the phenomenon
11:48:28 <monochrom> as much as we would love too.
11:48:53 <hpaste> hpc annotated “with Imports” with “with Imports (annotation)” at http://hpaste.org/55407#a55409
11:49:05 <monochrom> 50% of students doing I/O in Complex's ctor and 50% doing I/O in main can be explained by do-not-know-better
11:49:07 <hpc> carpi: ^
11:49:58 <carpi> monochrom: i think to a small extent it is true.. because.. now that you told me about confining IO to main.. next time i write some piece of code i would atleast try to adhere to that rule. if i didn't know about that rule.. from another source i would have to spend a lot of time digging haskell before I realize it by myself
11:49:58 <monochrom> the observation is that 90% do I/O in Complex's ctor. you need a they-have-a-preference to explain that
11:50:11 <hpc> carpi: i think i also would have written elem, or hoogled for it, as opposed to using any and a section of (==)
11:50:17 <kmc> "confine IO to main" is a bad rule
11:50:26 <kmc> abstraction is important for IO code as much as for pure functions
11:50:50 <carpi> monochrom: i think a way..  all learning is like that.. And that is precisely why folks that have teachers or some guides..learn quicker )
11:50:51 <monochrom> well yeah, I/O is just an example
11:50:59 <kmc> Haskell excels at abstracting over stateful, IO code
11:51:02 <hpc> kmc: i think monochrom means for really small programs
11:51:18 <hpc> of the size carpi gave
11:51:32 <kmc> the better advice is to think about the separation between IO and computation
11:51:44 <kmc> and then use appropriate abstraction on both sides
11:52:05 <monochrom> well yeah in general it's separation of concerns
11:52:08 <kmc> hpc, maybe so, I don't know if that's how carpi took it
11:53:29 <monochrom> "most people write by stream of consciousness, not by separation of concerns" is the way I put it previously
11:53:31 <Philonous_> monochrom:  What IO could you possibly do in the ctor of Complex?
11:54:17 <monochrom> class Complex { public: Complex() { cout << "please enter the real part: "; cin >> this.real; ...
11:55:01 <monochrom> 90% of the students do that. you cannot explain it by "they don't know better". if they don't know better, you should be seeing fair coin flips.
11:55:22 <Philonous_> monochrom:  Oh, I guess I just didn't have enough fantasy to even think that you could do it that way.
11:55:28 <monochrom> you must accept that they know --- they know worse.
11:56:53 <BMeph> monochrom: Do you have an SoC blog post? (hint, hint) :)
11:57:20 <shachaf> @remember monochrom <monochrom> 90% of the students do that. you cannot explain it by "they don't know better". if they don't know better, you should be seeing fair coin flips. <monochrom> you must accept that they know --- they know worse.
11:57:21 <lambdabot> It is stored.
11:57:39 <monochrom> I don't. I have never done SoC.
12:00:12 <cgroza> This may sound stupid, but does pointfree style have the potential of running a bit slower than its counterpart? I have some function generated by lambdabot and it runs around 0.05 slower.
12:00:27 <shachaf> cgroza: How are you measuring it?
12:00:37 <cgroza> shachaf: time ./program
12:00:49 <shachaf> A single run of time ./program?
12:01:04 <shachaf> 0.05 does not seem very statistically significant.
12:01:09 <shachaf> Unless it's 0.05 years or something.
12:01:12 <cgroza> shachaf: i did a few. Most of the time it is slower.
12:01:19 <BMeph> monochrom: Maybe you should. Please, do. :)
12:01:36 <shachaf> cgroza: You should put a little more work into benchmarking this sort of this than that. :-)
12:01:40 <shachaf> Also, compile with optimizations.
12:01:41 <kmc> cgroza, benchmark the difference with Criterion
12:02:03 <shachaf> Anyway, the answer is "yes", of course, because two different implementations of the same program aren't necessarily the same speed.
12:02:03 <hpc> monochrom: alternative data point: my boss is mentoring some SoC spamassassin work, and hates every second of it
12:02:05 <cgroza> ok.
12:02:06 <kmc> criterion is the easiest-to-use benchmarking library i've seen for any language
12:02:10 <monochrom> I am no longer elibigle for SoC.
12:02:17 <shachaf> Point-free style can also be faster than the alternative in some cases, I imagine.
12:02:20 <hpc> they changed the site from last year and it is a buggy slow nightmare of a javascript application
12:02:21 <kmc> and it does accurate measurements, statistics,... science.
12:02:26 <shachaf> monochrom: Why not?
12:02:27 <dons> cgroza: assuming you have -O2 on, it won't be any slower
12:02:35 <shachaf> dons!
12:02:39 <dons> its all optimized to the same low level code, as long as you don't do something super weird
12:03:12 <shachaf> To what do we owe this rare pleasure?
12:03:15 <monochrom> I am not an undergrad student
12:03:22 <dons> shachaf: hp release time
12:03:36 <ddarius> monochrom: Yeah, I don't know why BMeph would think you qualified for SoC.
12:03:50 <BMeph> monochrom: Sorry: "SoC" as in "Separation of Code", not "Summer of Code". :)
12:04:09 <BMeph> monochrom: Rather, "Sepeartion of Concerns".
12:04:21 * BMeph gives up
12:04:34 <ddarius> "Separation" is the correct spelling.
12:04:36 <monochrom> I don't have a blog on separation of concerns, but haha
12:05:06 <BMeph> monochrom: I meant, to do a blog article on Separation of Concerns, and why it's "a Good Idea"
12:05:12 <monochrom> yes, it also took me much effort to drill the correct spelling into my mind, so don't you worry
12:05:27 <ddarius> I think there are many, many, many articles on separation of concerns and why it's a good idea.
12:05:41 <BMeph> monochrom: Oh, no, I know the sepelling of it well, I just suck at typing. :\
12:05:48 * BMeph sighs
12:05:54 <monochrom> heh
12:05:56 <BMeph> monochrom: Case in point.
12:06:25 * BMeph patiently waits for ddarius to tell him how to spell "spelling"... ;)
12:07:03 <kmc> i asked some people if there was a library like Criterion for C or C++ and they said "no, sounds like a fun weekend project"
12:07:07 <ddarius> BMeph: I only correct people who were already correct.
12:07:10 <kmc> at least they did not use the word "trivial"
12:07:24 <dons> hehe
12:07:30 <monochrom> well, actually, separation of concerns was most heatedly advocated in the days when Hoare was still mid-aged etc. no one cares by now. at least not in that name. people now talk about re-factoring, which is an incarnation I guess, but slightly different.
12:08:00 <kmc> i thought "refactoring" just meant "making the code better"
12:08:14 <kmc> not always by separating concerns better
12:08:16 <Philonous> kmc:  Small matter of programming
12:08:25 <BMeph> kmc: Maybe for those people "a weekend project" means something to take up all the time on their weekends for a year. :)
12:08:25 <dons> hey guys, can i get some testin on  http://code.haskell.org/haskell-platform/download-website/  ?
12:08:41 <dons> check the links are working. download the package for your favorite OS and let me know YES or NO if it worked
12:08:59 <monochrom> a winter tree I see
12:09:16 <kmc> in fact i think you could write a decent approximation of Criterion in a single weekend
12:09:49 <shachaf> dons: Is it still required to download HP source and a GHC 7 binary separately for Linux if your distribution's packages aren't up to date?
12:09:57 <monochrom> oh noes, now you have a haddock page!!!
12:10:43 <dons> shachaf: you still need ghc   7 on the machine to build the src
12:11:41 <shachaf> All the other platforms get everything packages, though.
12:11:57 <monochrom> yes, you get GHC separately, from distro or from GHC website
12:13:39 <monochrom> it doesn't have to be this way. but I think it is this way now because people are split on what to do for linux
12:14:12 <monochrom> people are split between "you should just stick to distro" and "you should forget the distro" and every point in between
12:14:57 <monochrom> then again, following my own...
12:15:02 <monochrom> @quote monochrom polymorphic
12:15:03 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
12:15:24 <monochrom> a satisfactory way out is to offer solutions to all options :)
12:19:18 <monochrom> i.e., you offer all of: "here is a source tarball, but doesn't have GHC", "here is a source tarball, and it has GHC binary but no GHC source", "here is a source tarball, it builds GHC too" (wait, that hides a bootstrap question), "here is a binary tarball, but it doesn't have GHC binary", "here is a binary tarball, and it has GHC binary", "here is a mixture of source and binary: GHC binary, cabal binary, parsec binary, QuickC
12:19:18 <monochrom> heck source, HTTP source..." ...
12:19:26 <ByronJohnson> "The Haskell Browser" overlaps "Documentation" on my browser, Firefox 8.0.1
12:20:08 <kmc> "here is a ZIP file with GHC and also GCC in it"
12:20:24 <ddarius> monochrom: I would not describe that as polymorphic.
12:21:34 <shachaf> kmc: Make sure to stick a ZIP file extractor in there.
12:21:53 <kmc> and a copy of the zip file itself
12:22:23 <shachaf> People have made a zip file that extracts into itself, right?
12:22:39 <ddarius> Yes.
12:22:40 <monochrom> and oh! you must not forget my: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg11944.html
12:24:00 <dons> okkk. HP is live. tweeted and reddited. tell yr friends.
12:24:07 <dons> and give mzero a high five when you see him.
12:24:28 <hpaste> Carpi pasted “stdin gibberish” at http://hpaste.org/55410
12:24:29 <carpi> can someone please take a look ^^^? i solved the problem i had earlier..but now when i try to print a bytestring to stdin..it give me some gibberish..
12:24:47 <holla> How can I convert an Int  to a Word8 (Int -> Word8) ....I know that the size of my int will fit
12:24:51 <monochrom> wait, stdin? stdout?
12:24:55 <kmc> holla, fromIntegral
12:25:08 <carpi> monochrom: oh..sor. i meant stdout
12:25:16 <holla> @run fromIntegral 2
12:25:17 <lambdabot>   2
12:25:32 <merijn> > fromIntegral 2 :: Word8
12:25:33 <lambdabot>   2
12:25:34 <hpc> > fromIntegral (2 :: Int) :: Word8
12:25:35 <lambdabot>   2
12:25:51 <ddarius> > fromIntegral 1343 :: Word8
12:25:52 <lambdabot>   63
12:26:43 <monochrom> you are encrypted things, so the output is supposed to be like gibberish, no?
12:26:44 * shachaf read that as ":: Int -> Word8 (Int -> Word8)", was confused by the kind error among other things.
12:27:39 <carpi> monochrom: i am not printing the encrypted content.. i am only printing an unencrypted bytestrying of length 16
12:28:47 <hpc> > BS.pack "some gibberish"
12:28:48 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
12:28:48 <lambdabot>         against inferred type...
12:29:03 <hpc> > read "some gibberish" :: BS.ByteString
12:29:03 <lambdabot>   "*Exception: Prelude.read: no parse
12:29:09 <hpc> bleh
12:29:23 <monochrom> that's iV, which is obtained by "iV <- randBytes 16". I don't know what that means, but I am willing to bet that "randBytes" is supposed to be like gibberish
12:30:04 <ddarius> > BSC.pack "aoeu"
12:30:05 <lambdabot>   "aoeu"
12:30:39 <dons> reddited and ycombinatored. http://www.reddit.com/r/programming/comments/ngngc/the_haskell_platform_20114_is_now_available/ http://news.ycombinator.com/newest
12:30:43 <monochrom> in any case, unless you explicitly say "B.putStrLn inpfByteStr", I have no reason to expect non-gibberish.
12:30:51 <carpi> monochrom: but in ghci randBytes prints a proper bytestring..albeit a unicode string i think..because there are a lot of escape sequences in the random bytestrng
12:31:01 <carpi> could that be the problem..?
12:31:06 <holla> @run fromIntegral 'a'
12:31:06 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
12:31:07 <lambdabot>    arising from a use of...
12:31:13 <shachaf> dons++
12:31:14 <carpi> the escape sequences..
12:31:23 <monochrom> "in ghci randBytes prints a proper bytestring" is obtained by print iV not B.putStrLn iV
12:31:30 <kmc> carpi, bytestrings are strings of bytes
12:31:34 <shachaf> How long until we get a Platform with GHC 7.4? :-)
12:31:35 <kmc> they are like [Word8] not like [Char]
12:31:57 <kmc> carpi, ghci is invoking the Show instance, which (somewhat misleadingly) represents those bytes as a string literal
12:32:10 <dons> mzero++
12:32:16 <ddarius> shachaf: Presumably many months.
12:32:18 <monochrom> and print iV is obtained by show iV, and what show iV does is at the mercy of dons, who happens to be here today as a rarity, you're the luckiest man of the world
12:32:20 <dons> (mzero did the release, i just pushed the .html :)
12:32:33 <kmc> carpi, but it's really just a sequence of uninterpreted bytes, so that's what you get on output
12:32:34 <copumpkin> mzero++
12:33:12 <carpi> so the gibberish is to be expected then? if thats true.. then ill have to change some of that code
12:33:15 <kmc> carpi, when I'm running a program which produces arbitrary bytes, and I want to see what those bytes are, I'll pipe it to 'hexdump -C' or 'cat -v'
12:33:40 <kmc> what output did you want?
12:33:54 <kmc> if you want the misleading string literal syntax, you can call 'show' on that ByteString
12:34:07 <monochrom> he wants escape codes. use print.
12:34:27 <monochrom> print leads to show. show leads to fear.
12:34:34 <dons> ok. done.
12:34:51 <monochrom> actually... ghci leads to print, print leads to show, show leads to fear
12:35:09 <holla> @run toInteger 'a'
12:35:10 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
12:35:10 <lambdabot>    arising from a use of...
12:35:41 <lukish> Proceeding solving these exercises http://blog.tmorris.net/20-intermediate-haskell-exercises/
12:35:48 <carpi> M-jM-x!gi^@M-DM-^VM-^B=^PM-^TM-7?M-^NM-^J that is what i get piping it to cat -v
12:35:54 <lukish> I stucked on 14 one
12:35:54 <irene-knapp> hah!
12:36:04 <holla> how do i convert a char to a word32?
12:36:11 <carpi> i think thats more like it..but ill know when i use that to decrypt
12:36:17 <irene-knapp> > fromIntegral $ ord 'A'
12:36:17 <copumpkin> fromIntegral . ord
12:36:18 <lambdabot>   65
12:36:26 <lukish> About a week ago someone tell me, that I can get a from m a with banana
12:36:27 <kmc> assuming you wanted the Unicode scalar value of that Char
12:36:35 <lukish> But actually I cannot get how
12:36:40 <carpi> kmc: thanks forthe cat-v )
12:36:41 * ddarius should use :join more.
12:36:41 <shachaf> lukish: You can't.
12:36:49 <kmc> there are of course many functions of type «Char -> Word32»
12:36:59 <shachaf> :join?
12:37:21 * ddarius can't believe lukish has spent this much time on these exercises.
12:37:28 <holla> @run digitToInt 'a'
12:37:29 <lambdabot>   10
12:37:44 <lukish> ddarius: there are a lot of things I can't spent time with
12:37:51 <monochrom> carpi, WYSIWYG is usually false in programming. remember that.
12:37:51 <holla> @run fromIntegral (digitToInt 'a')
12:37:52 <lambdabot>   10
12:38:06 <lukish> So, basic question is how can I break that problem to pices
12:38:09 <monochrom> even "plain text editors" lie to you these days.
12:38:17 <holla> @ fromIntegral 'a'
12:38:21 <kmc> "how do I convert A to B" is a way of asking "pick a random function of type A -> B"
12:38:33 <holla> @run fromIntegral 'a'
12:38:34 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
12:38:34 <lambdabot>    arising from a use of...
12:38:38 <ddarius> monochrom: They always lied to you.
12:38:40 <kmc> yes, there is no such thing as "plain text"
12:38:46 <alistra> s/error "todo"/undefined/gi done
12:38:49 <irene-knapp> > (fromIntegral . (\n -> 5 * n - 100) . ord) 'A'
12:38:50 <lambdabot>   225
12:40:38 <ddarius> > case True of False -> 1
12:40:38 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
12:41:06 <ddarius> s/undefined/(case True of False -> undefined)/
12:41:12 <dons> http://news.ycombinator.com/item?id=3365100
12:41:21 <ddarius> We need empty cases.
12:42:16 <alistra> maybe just let f in f
12:43:27 <shachaf> "let f in f" doesn't let f be some particular value. It just lets f be.
12:44:03 <alistra> shachaf: let f be
12:44:37 <holla> @run fromIntegral
12:44:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
12:44:38 <lambdabot>    arising from a use of `...
12:45:49 * shachaf wonders what sort of output holla expected.
12:46:15 <alistra> @run 1
12:46:16 <lambdabot>   1
12:46:38 <monochrom> what is @run ?
12:46:42 <alistra> > ?
12:46:42 <lambdabot>   <no location info>: parse error on input `?'
12:47:36 <azaq23> @help @run
12:47:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:47:37 <Philippa> dons: any idea if the Platform docs work okay under Windows with the new release?
12:51:47 <kmc> wonder what's going on here: http://hackage.haskell.org/packages/archive/oi/0.0.2/doc/html/Data-OI.html
12:52:01 <shapr> codata?
12:52:09 <dons> Philippa: unsure. will check on monday (when i get back to my windows box
12:52:23 <shapr> The original comonads had an OI datatype
12:52:29 <irene-knapp> OI, haha?  I see
12:52:30 <Philippa> eh, I'll have an approximate answer in minutes - just installed
12:52:39 <kmc> this one is a Monad and also a Comonad
12:52:55 <Philippa> first link I check's still broken :-(
12:52:59 <dons> okk. thanks
12:53:09 <Philippa> (Text.XHtml.Strict)
12:53:10 <dons> how are the docs broken on windows?
12:53:10 <kmc> type :-> a b = OI a -> b;  run :: (a :-> b) -> IO b
12:53:12 <kmc> that's kinda weird
12:53:37 <kmc> 'run' uses unsafeInterleaveIO and MVars and... what is this i don't even
12:53:46 <Philippa> if it's like the previous version, most packages just don't have documentation installed - so the library docs index has dangling links to a bunch of nonexistant pages
12:54:06 <dons> hmm
12:54:21 <Philippa> the xhtml package is affected, some non-base packages are okay
12:54:27 <dons> http://lambda.haskell.org/platform/doc/current/frames.html
12:54:45 <kmc> ah, there are examples, cool
12:54:55 <Philonous> kmc: run looks suspiciously like fixIO
12:54:56 <dons> i'll talk to mikhail about getting the doc bundel
12:54:57 <Philippa> mtl is affected
12:55:30 <Philippa> *nod* - I know where to find the docs online, yeah. I guess I should wget the lot
12:55:55 <ion> I can’t help reading “OI” as “oi!” with a British accent.
12:55:59 <irene-knapp> same here
12:56:04 <Philippa> want me to get you a list of the affected packages?
12:56:05 <kmc> same
12:56:24 <dons> Philippa: nah
12:58:53 <mm_freak> is there a way to emulate kind polymorphism in GHC 7.0.3?
12:59:12 <irene-knapp> I doubt it very much
12:59:48 * Philippa is looking forward to ConstraintKinds making it to the Platform
13:00:09 <irene-knapp> indeed!
13:00:18 <Philippa> I probably should've checked the discussion about them on -cafe
13:00:22 * irene-knapp nods
13:00:28 <irene-knapp> it wasn't that enlightening I don't think
13:01:14 <ByronJohnson> I'm really excited for 7.4 to make it to the Platform
13:01:14 <Philippa> I'm more interested in what it's prompting people to do
13:01:28 <dons> once its stable, ByronJohnson
13:01:36 <Philippa> "restricted" versions of half the typeclassopedia, for example
13:02:15 <Philippa> there's a lot of awesome stuff you can do once we've got the same kind of infrastructure for those as we have for unrestricted applicatives, monads etc
13:02:31 <lukish> What is main principle of all lift* functions?
13:02:36 <lukish> What are they lifting?
13:02:45 <irene-knapp> heavy weights
13:02:46 <Philippa> values into some functor or monad
13:02:56 <lukish> :t liftM
13:02:57 <Philippa> (or "equivalently", their types)
13:02:57 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:04:14 <lukish> @hoogle forall
13:04:15 <lambdabot> Test.QuickCheck.Property forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
13:04:15 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
13:04:15 <lambdabot> keyword forall
13:05:06 <BMeph> @hoogle something
13:05:07 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
13:05:52 <ddarius> @google ralf hinze lifting
13:05:54 <lambdabot> http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
13:05:54 <lambdabot> Title: Lifting Operators and Laws
13:06:37 <kmc> lukish, there are a lot of functions named 'lift*' in Haskell and they're not all related
13:06:50 <kmc> Control.Monad's liftM, liftM2, liftM3, etc. form one family
13:06:59 <kmc> Control.Applicative's liftA, liftA2, etc. are very similar
13:07:49 <kmc> but there's also, say, Control.Monad.Trans.lift, and Language.Haskell.TH.Syntax.lift
13:07:53 <kmc> and these are not related
13:08:25 <mm_freak> why exactly can't a newtype constructor have an existential context?  is it because of the dictionary?
13:08:28 <Philippa> Control.Monad.Trans.lift could probably be made related easily enough by generalising from "0-ary" to n-ary
13:08:31 <mm_freak> even in the fully polymorphic case?
13:09:03 <ByronJohnson> Philippa: It'd be great to see ByteString be a Functor and Monad
13:09:33 <Philippa> what would the Monad do? I can see at least one restricted functor, but it's somewhat boring...
13:09:42 <Philippa> (which isn't to say not useful)
13:09:46 <kmc> it will confuse further the question "what is a monad, really"
13:10:08 <Philippa> y'know, I'm putting my current explanation on the to-write pile for my blog
13:10:25 <Philippa> which isn't to say that it won't crawl down the list because other stuff is more researchy...
13:10:27 <ByronJohnson> I wonder whether the class duplication could be avoided by somehow making the original classes equivalent to the restricted ones
13:11:09 <Philippa> not easily unfortunately
13:11:22 <Philippa> I guess you could default the constraint to *
13:11:55 <lukish> Well
13:11:56 <lukish> λ> :t liftBanana2
13:11:57 <lukish> liftBanana2 :: Misty m => (a -> a1 -> b) -> m a -> m a1 -> m b
13:11:59 <carpi> is it possible to use guards in let expressionss?
13:12:09 <lukish> What that function actually lift?
13:12:18 <monochrom> mm_freak: "If there is no overloading involved, then there is more of a case for allowing an existentially-quantified newtype, because the data version does carry an implementation cost, but single-field existentially quantified constructors aren't much use. So the simple restriction (no existential stuff on newtype) stands, unless there are convincing reasons to change it."
13:12:53 <carpi> oops.. i don't think so.. i think that is why we have case expressions
13:13:27 <monochrom> > let x | 0>1 = "first" | otherwise = "second" in x
13:13:28 <lambdabot>   "second"
13:13:49 <monochrom> you can do it
13:14:31 <mm_freak> monochrom: thanks…  so there is no technical reason for the fully polymorphic case?
13:14:34 <kmc> lukish, you say that it lifts the function to operate on monadic, err, "misty" actions rather than the original values
13:14:42 <Philippa> lukish: it depends on the type class involved. Usually it's either a class member or a function implemented in terms of class members, so it changes depending on the type
13:14:44 <carpi> monochrom: thank you)
13:14:45 <monochrom> right, no technical reason
13:14:57 <Philippa> lukish: for example, liftA* all use <$> and <*>
13:15:12 <kmc> lukish, it's just a word.  the word "lift" does not have a single precise meaning in mathematics or Haskell
13:15:21 <lukish> Ok
13:15:28 <Philippa> whereas Control.Monad.Trans.lift is a typeclass member
13:15:53 <Philippa> kmc: The paper ddarius linked above argues that it does
13:15:59 <kmc> maybe i should read that paper
13:16:31 <Philippa> (albeit one that the Platform isn't capable of formalising yet - GHC 7.4's powerful enough unless I've misunderstood something though)
13:16:52 <mm_freak> monochrom: well, one reason for allowing existential contexts would be to have newtype semantics on a single-constructor type…  for newtypes pattern-matching on the constructor is a no-op
13:17:02 <mm_freak> though you can probably emulate it by using lazy patterns
13:17:08 <carpi> monochrom: but i think using case would be more elegant instead of guards in let.. no?
13:17:14 <Philippa> there's a problem though: you run into the situation where there isn't a /unique/ applicative functor you want to use
13:17:57 <Philippa> which is one thing newtypes are for, but hey
13:18:23 <monochrom> "let x = case garbage_here of _ | 1>0 -> ..."? you call that more elegant? don't kid me
13:19:16 <parcs`> wouldn't 'newtype N = N N' be the fully-polymorphic newtype?
13:19:17 <monochrom> unless you can eliminate the "let" altogether
13:19:28 <carpi> monochrom: i meant without the let..
13:19:36 <carpi> yea.. eliminating the let ..
13:19:52 <monochrom> the peril of asking out of context
13:21:04 <monochrom> if you eliminate the "let", I actually go back to if-then-else
13:23:24 <Philippa> parcs`: nah, it's isomorphic to sod all :-)
13:24:14 <parcs`> sod all?
13:24:21 <carpi> let x = 3 | x == 3 = "T" | otherwise = "F" in x  I think im erring somewhere
13:24:32 <carpi> ghci doesn't like it
13:25:13 <Guest55173> k
13:25:21 <Philippa> parcs`: nothing
13:26:08 <monochrom> > let x | x == 3 = "T" | otherwise = "F" in x
13:26:08 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
13:26:09 <lambdabot>    arising from the literal ...
13:26:32 <ddarius> The expression doesn't make any sense.
13:26:50 <monochrom> let x = 3 | x == 3 = "T" is an obvious syntax error
13:27:10 <ddarius> "Let x be three and if it is three then x is T otherwise it is F."
13:27:12 <parcs`> pack x = N (pack x); unpack (N x) = unpack x
13:27:13 <irene-knapp> > let x = 3 in case x of 3 -> "T" _ -> "F"
13:27:14 <lambdabot>   <no location info>: parse error on input `->'
13:27:23 <irene-knapp> > let x = 3 in case x of { 3 -> "T" ; _ -> "F" }
13:27:24 <lambdabot>   "T"
13:27:27 <holla> how do I split a list into a list of lists that each have 4 elements
13:27:31 <irene-knapp> that's probably what carpi meant
13:29:29 <carpi> that does seem correct..but i was also curious about using guards with let..since monochrom said it was possible. only thing is i couldn't do by definiing a name inside the let
13:29:55 <holla> @run splitEvery 4 [0,1,2,3,4,5,6,7,8,9,10,11]
13:29:56 <lambdabot>   Not in scope: `splitEvery'
13:29:56 <ddarius> monochrom didn't just say it was possible, he provided an example.
13:30:06 <ddarius> @hackage split
13:30:06 <lambdabot> http://hackage.haskell.org/package/split
13:30:12 <irene-knapp> > let { x = 3 ; result | x == 3 = "T" | otherwise = "F" } in result
13:30:13 <lambdabot>   "T"
13:30:24 <carpi> ddarius: but that example was without a binding for the let
13:30:32 <carpi> i was trying to do with binding
13:30:42 <carpi> i think it can be extrapolated
13:30:45 <monochrom> let x | 1>0 = blah in ...  certain binds x
13:30:55 <holla> @run Data.List.Split.splitEvery 4 [0,1,2,3,4,5,6,7,8,9,10,11]
13:30:55 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
13:30:58 <ddarius> carpi: No, you can't not bind variables in Haskell ever.
13:31:34 <carpi> i mean being able to bind a value to x and then being able to use the name of that value in a gurad..
13:31:46 <irene-knapp> carpi: I did that in my first example, see above
13:31:49 <monochrom> then it's irene-knapp's example
13:31:56 <ddarius> carpi: Your example, if it had made any sense or as "corrected" by monochrom, was attempting to bind x to two different things which is also not something that can be done in Haskell.
13:32:17 <monochrom> irene-knapp's example defines both x and result
13:32:46 --- mode: ChanServ set +o copumpkin
13:32:52 <monochrom> I actually say bind too
13:33:13 --- mode: ChanServ set +o dons
13:33:17 <ByronJohnson> < ByronJohnson> I wonder whether the class duplication could be avoided by somehow making the original classes equivalent to the restricted ones — Would there be any reason not to have an implied constraint for every class that defaults to ()?  Regardless of which approach is chosen, I think we should try to avoid duplicating the classes by making them equivalent if possible
13:33:17 --- topic: set to '["Haskell Platform 2011.4: http://goo.gl/rjq6z", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/",  "admin/spam issues: #haskell-ops' by dons
13:33:31 --- mode: ChanServ set -o dons
13:33:50 <alpounet> yay, platform released!
13:33:53 <carpi> irene-knapp: thans... thats what i had in mind..
13:33:56 <irene-knapp> np
13:34:04 --- topic: set to '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/",  "admin/spam issues: #haskell-ops' by copumpkin
13:34:36 <monochrom> > length "http://bit.ly/Clv5r" - length "http://goo.gl/rjq6z"
13:34:36 <lambdabot>   0
13:34:59 --- mode: copumpkin set -o copumpkin
13:35:05 <alpounet> copumpkin, there's a missing ]
13:35:06 <copumpkin> monochrom: they point different places
13:35:14 --- mode: ChanServ set +o copumpkin
13:35:22 <alistra> i would add some more things to the topic
13:35:23 --- topic: set to '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/",  "admin/spam issues: #haskell-ops' by copumpkin
13:35:28 <copumpkin> topic is too long
13:35:29 <alistra> it doesn't look cluttered at all
13:35:48 <copumpkin> let me shorten the tunes.org link
13:36:07 <alistra> i can do it for you
13:36:21 --- topic: set to '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]' by copumpkin
13:36:33 * alistra googles shortened rick-roll links
13:36:33 <Philippa> a single page with most of those links on might be a good idea
13:36:45 --- mode: copumpkin set -o copumpkin
13:36:47 <copumpkin> Philippa: yeah
13:37:01 <holla> @run intToDigit 10
13:37:02 <lambdabot>   'a'
13:37:44 <basti_> i just implemented a partial fortran parser in happy.
13:38:16 <mike-burns> Is there a good list of what's new in HP in comparison with the prior version?
13:39:04 <Philippa> http://hackage.haskell.org/platform/changelog.html
13:39:23 <monochrom> which is not a real change log
13:39:35 <mike-burns> That does have the word "changelog" in the title, though.
13:40:03 <Philippa> *nod* - sorry, should've actually looked at it. Yeah, that's not good
13:41:23 <parcs`> it ships with 7.0.4 instead of 7.0.3
13:41:25 <parcs`> dunno what else
13:42:44 <mzero> if you are on OS X Lion, this should work out of the box for your
13:42:47 <mzero> for you
13:42:57 <mzero> and by box, I mean package
13:43:11 <monochrom> oh, dons says everyone should high five mzero!
13:43:18 <mzero> aw, geee
13:43:19 * monochrom high-fives mzero
13:43:26 * copumpkin high-fives mzero 
13:43:35 * mike-burns high-fives mzero
13:43:48 * Philippa ^5s mzero
13:44:22 <monochrom> yikes
13:44:23 <aristid> is mzero mark lenczer?
13:44:39 <aristid> damn i wrote the name wrong
13:44:41 * Heffalump wonders what the best way to manage the Copyright, License, Maintainer, Portability and Stability haddock fields is. It's a bit of a pain to have to maintain them in each file of a project.
13:44:45 <aristid> lentczner
13:44:49 <Heffalump> aristid: /whois is your friend :-)
13:45:00 <aristid> Heffalump: but it could lie!
13:45:12 <aristid> Heffalump: also he is not online
13:45:19 <copumpkin>  /whowas then
13:45:30 <alistra> who was phone
13:45:39 <aristid> copumpkin: a wonderful command.
13:45:50 <copumpkin> I like it
13:46:14 <lukish> How can I define element of Staty type from http://blog.tmorris.net/20-intermediate-haskell-exercises/ ?
13:46:55 <monochrom> can't find Staty
13:47:43 <lukish> State*
13:48:09 <alistra> is it really that hard?
13:48:19 <monochrom> but if you want State, State(\s -> (not s, if s then 'x' else 'y')) :: State Bool Char
13:48:32 <alistra> it's like a puzzle with 5 or so elements
13:48:39 <monochrom> but I don't know about apple and banana3
13:49:36 <monochrom> oh God, now I see apple and banana3
13:50:55 * hackagebot http-types 0.6.8 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.8 (AristidBreitkreuz)
13:55:47 <aristid> currently uploading packages to hackage seems to be a bit finicky
13:56:09 <lukish> monochrom: can you give some non-lambda example?
13:56:31 <monochrom> no
13:56:46 <lukish> Why?
13:57:00 <monochrom> because I am lazy
13:57:00 <aristid> @pl \s -> (not s, if s then 'x' else 'y')
13:57:00 <lambdabot> liftM2 (,) not (flip (flip if' 'x') 'y')
13:57:06 <aristid> lukish: there :)
13:57:18 <aristid> lukish: State (iftM2 (,) not (flip (flip if' 'x') 'y'))
13:57:42 <Philonous> Except that if' is completely made up by lambdabot
13:57:59 <aristid> Philonous: it's just an example!
13:58:08 <alistra> it's probably curried if
13:58:14 <aristid> alistra: yeah.
13:58:17 <alistra> if' a b c = if a then b else c
13:58:27 <aristid> i still think if should not be special syntax
13:58:33 <aristid> if as a function works just fine
13:59:02 <alistra> yeah and #lisp is on #lisp
13:59:04 <alistra> :D
13:59:37 <alistra> they like their syntax simple
13:59:51 <kmc> Common Lisp syntax is pretty complicated
14:00:08 <kmc> just because it's specified over trees rather than character streams
14:00:15 <kmc> and can be changed
14:00:18 <kmc> does not make something not-syntax
14:00:46 <kmc> like, is it (let ((a x) (b y)) ...)  or (let (a x b y) ...) ?  different lisps make different choices.  this is a syntactic question
14:01:50 <Philonous> kmc:  Isn't let just a macro?
14:02:20 <ddarius> CL lexical or abstract syntax is more complicated than Haskell's, and at the very least is far from the simplest possible syntax.
14:02:29 <aristid> Philonous: probably not, but what if it is? just because macros can define syntax, it's not not syntax
14:02:35 <irene-knapp> @hoogle MaybeT
14:02:35 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:02:36 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
14:02:36 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
14:02:36 <kmc> what aristid said
14:02:45 <irene-knapp> hm
14:02:52 <irene-knapp> what I wanted to know was what package that's in so I could find the source ><
14:02:57 <irene-knapp> @hackage transformers
14:02:57 <lambdabot> http://hackage.haskell.org/package/transformers
14:02:59 <ddarius> Forth and Joy have claims of having some of the simplest possible syntaxes in a usable language.
14:03:11 <irene-knapp> ah, guessed it :)
14:03:12 <hpc> agda even has a syntax keyword
14:03:19 <kmc> after all, even if you want to change the syntax, you do that by writing macros using the existing syntax
14:03:19 <hpc> which kind of acts like a macro
14:03:23 <kmc> so you have to know it
14:03:23 <aristid> irene-knapp: the web hoogle is a bit more useful for that :)
14:03:28 <irene-knapp> ah, indeed :)
14:03:34 <irene-knapp> but then I'd have to use google first to remember where it is :)
14:03:40 <kmc> i think people confuse the notions "syntax" and "unchangeable builtin"
14:03:41 <ddarius> @where hoogle
14:03:41 <lambdabot> http://haskell.org/hoogle
14:03:41 <hpc> @where hoogle
14:03:41 <lambdabot> http://haskell.org/hoogle
14:03:45 <irene-knapp> haha okay!
14:03:47 <kmc> macros are libraries providing syntax; they are still syntax!
14:03:48 <irene-knapp> simpler url than it used to be
14:03:56 <Philonous> aristid:  I'd think the presence of macros makes the syntax arbitrarily complex.
14:04:13 <kmc> Philonous, there is a finite amount of syntax specified in the Common Lisp spec...
14:04:27 <kmc> because it is a document of finite length (barely)
14:04:30 <ddarius> The Common Lisp spec isn't short.
14:04:36 <hpc> strictly speaking, lisp has a turing-complete syntax because you can run arbitrary lisp during parsing
14:04:39 <Philonous> kmc:  Yes, but you can introduce potentially infinite syntax extensions via macros
14:04:41 <ddarius> Sure, C++ has it beat though.
14:04:43 <hpc> or even during lexing
14:05:14 <kmc> for answering the question "How much syntax does Lisp have" it is relevant what stuff is in scope in a fresh session according to the CL spec
14:06:04 <kmc> anyway Lisp programmers of all people should understand that libraries which provide syntax are still providing syntax
14:06:46 <kmc> so the claim from some that "Lisp has no syntax!" is disingenuous
14:06:49 <hpc> they should know that you can't write a pointer to a macro, for instance
14:06:56 <hpc> you need another macro for that
14:07:16 <monochrom> wait, what? there is a macro for pointers to macros?!
14:07:25 <hpc> monochrom: i believe so
14:07:32 <irene-knapp> actually, you can use the macro's name, since symbols are first-class objects, and invoke macroexpand and eval by hand
14:07:44 <hpc> right, that's what it was
14:07:51 <Patinho`B> hi all o/
14:08:01 <kmc> anyway, on a practical level, if I am learning Lisp and I ask the question "is it (let ((a x) (b y)) ...)  or (let (a x b y) ...)?", this is a syntactic question about the Lisp language
14:08:03 <monochrom> I am impressed. at the same time, I am glad I don't use lisp and am not in the community. :)
14:08:28 <mike-burns> Teaching Lisp is the best way to learn that there is an amazingly large amount of confusing syntax in Lisp.
14:08:34 <hpc> im glad i learned lisp
14:08:45 <mike-burns> Especially if you teach it to pedantic teenagers.
14:09:08 <hpc> and even more glad i waited this long; the sheer number of features can definitely trick people into thinking certain lisp quirks are the "right way"
14:09:11 <monochrom> well yeah, I'm glad I learned some of it, too. but I would hate all of it.
14:10:15 <kmc> hpc, how dare you even question for a second that Lisp is the absolute pinnacle of human achievement
14:10:23 <hpc> it's always fun to troll people by asking "why can't i use #'if?"
14:10:31 <hpc> "but it's just a function!"
14:10:56 <Philonous> hpc:  Actually, why can't you?
14:11:11 <aristid> what's #'if?
14:11:21 <hpc> aristid: theoretically, a function pointer to if
14:11:23 <mauke> \&if if you're a perl programmer
14:11:28 <Rusky> does anyone here know how to get lambdabot to build on arch linux?
14:11:47 <hpc> Rusky: did you cabal install lambdabot?
14:12:00 <alpounet> i'd rather darcs get it
14:12:08 <alpounet> iirc the package hasn't been updated for a while
14:12:16 <Rusky> yeah- I'm getting bad generated assembly with non-const .size directives
14:12:23 <Rusky> although I've tried it from darcs as well
14:12:24 <hpc> ah, do that then
14:12:30 <Rusky> in which case I get dependency issues
14:12:38 <alpounet> that's easier to fix :p
14:12:48 <hpc> ive never compiled lambdabot; just adapted a few modules for my own use
14:13:13 <hpc> i am afraid to try on a machine that already has halfway-broken haskell packages
14:13:42 <lukish> Is there some lambdabot command to figuring out what module is some function from?
14:13:44 <alpounet> cabal-dev ftw
14:13:51 <kmc> lukish, there is a GHCi command, :i
14:13:56 <MostAwesomeDude> Hey, if I want to make a subcommand-style CLI tool, what's the right package to use for handling argv?
14:14:01 <alpounet> lukish, if it's from the standard library, yeah, @index
14:14:03 <kmc> MostAwesomeDude, cmdargs
14:14:08 <MostAwesomeDude> e.g. $ git subcommand --subopt ...
14:14:23 <lukish> Great
14:16:34 <kmc> MostAwesomeDude, http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm
14:18:27 <merijn> lukish: Hoogle is also pretty great
14:19:29 <mm_freak> will GHC ever get the 'exists' keyword?
14:20:29 * mateu is part existentialist
14:20:53 <MostAwesomeDude> kmc: Thanks.
14:20:55 <copumpkin> mm_freak: I hope not!
14:21:19 <copumpkin> fine, I don't really
14:21:44 <mm_freak> copumpkin: huh?  why?
14:21:51 <mm_freak> it seems like a useful thing
14:21:58 <mm_freak> at least for my current purpose
14:22:05 <copumpkin> just use a rank-2 continuation! :D
14:22:15 <copumpkin> then it's obvious where the quantification happens, too!
14:22:19 <mm_freak> that's inconvenient…  i'm using a proxy type right now
14:22:45 <mm_freak> data ListP a = forall n. Length n => ListP (List n a)
14:23:09 <mm_freak> hence i can have easily accessible functions like:  head :: ListP a -> Maybe a
14:23:26 <copumpkin> or List (S n) a -> a :P
14:23:51 <Rusky> so, I installed mueval-0.8.1 but "cd lambdabot && cabal install" complains that it can't configure mueval-0.8.1, it requires mtl <1.2, but lambdabot-4.2.3.3 requires mtl >2
14:23:59 <Rusky> this is from darcs
14:24:01 <mm_freak> sure, that's the base function…  my goal is to have a statically length-checked list library without the inconvenience of using CPS everywhere
14:24:36 <copumpkin> mm_freak: you should only have to use CPS at the boundary between what is statically known/knowable and what isn't. Everywhere else can stay static
14:25:02 <mm_freak> copumpkin: even there it gets annoying, especially when dealing with IO
14:25:09 <mm_freak> one reason is that you basically lose mfix
14:25:19 <Sgeo> :t mfix
14:25:20 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:25:44 <mm_freak> copumpkin: an in my particular case you also lose stuff like ArrowLoop
14:25:49 <mm_freak> an → and
14:25:53 <copumpkin> hmm
14:26:31 <lukish> Can I use Control.Arrow in solutions to 20 intermediate haskell exercises?
14:26:48 <ddarius> lukish: You can do whatever you want.
14:28:28 <mm_freak> copumpkin: that's why "getLine :: IO (exists n. Length n => List n a)" is better than the CPS variant
14:29:03 <copumpkin> mm_freak: ski argues that => should turn to *> there
14:29:15 <kmc> lukish, that's a question for whoever is grading your solutions
14:29:31 <mm_freak> copumpkin: what's that?
14:29:35 <lukish> No one
14:29:36 <copumpkin> mm_freak: that would also be impredicative
14:29:57 <copumpkin> mm_freak: => is a function, *> is a pair
14:29:58 <kmc> data Exists f where { W :: f a -> Exists f }
14:30:55 <copumpkin> data Exists (ctx :: * -> Constraint) (f :: * -> *) where S :: ctx a => a -> Exists ctx f
14:30:55 * hackagebot BiobaseFasta 0.0.0.1 - Iteratee-based FASTA parser  http://hackage.haskell.org/package/BiobaseFasta-0.0.0.1 (ChristianHoener)
14:31:32 <mm_freak> interesting
14:31:47 <mm_freak> i can't wait to get my hands on ConstraintKinds and kind polymorphism =)
14:32:11 <gienah> Rusky: a patch for mueval: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/mueval/files/mueval-0.8.1-ghc-6.12.3-ghc-7.0.1.patch
14:32:31 <mm_freak> with them i can unify the interfaces to List and ListP
14:32:47 <kmc> you can have your hands on them within an hour or two
14:32:49 <hpc> mm_freak: just grab ghc head
14:33:12 <mm_freak> well, i prefer to wait for them to get available on arch
14:33:25 <copumpkin> pfft
14:33:30 <kmc> with all these new kinds, might it be nice to rename * to Type?
14:33:38 <copumpkin> or Constraint to some random symbol1
14:33:40 <kmc> is there at least a way to create a synonym?
14:33:43 <Rusky> gienah: awesome thanks
14:33:43 <mm_freak> all these?  what other kinds are there?
14:33:56 <kmc> data kinds
14:33:57 <copumpkin> data Type a = Type a
14:34:09 <copumpkin> now you lift that!
14:34:22 <kmc> http://hackage.haskell.org/trac/ghc/wiki/Status/Oct11 see "data type promotion"
14:34:26 <gienah> Rusky: no worries
14:34:56 <Rusky> I'm not entirely sure where to apply it though- can I just "cabal unpack mueval" and do it there?
14:35:02 <kmc> also we could come up with sensible names for # and (#) and ? and ??
14:35:13 <mm_freak> i see it coming…  in GHC 8.0 the borders between value, type and kind level breaks down
14:35:19 <mm_freak> finally we get dependent types =)
14:35:22 <copumpkin> lol no
14:35:22 <gienah> Rusky: I guess so (I don't use cabl much)
14:35:39 <kmc> no, we'll never have dependent types, just a less elegant pile of hacks to approximate them
14:35:41 <hpc> kmc: perhaps (#) and (##)
14:35:47 <kmc> is there a kind (##) now?
14:35:58 <hpc> kmc: i mean, for ? and ??
14:35:58 <copumpkin> for a while there was a secret kind called !
14:36:13 <hpc> kmc: ? includes unboxed, and ?? includes unboxed tuples too
14:36:14 <kmc> well (#) is already a kind, distinct from ?
14:36:18 <hpc> oh
14:36:22 <kmc> copumpkin, what was it
14:36:24 <mm_freak> what about custom kinds?  it would be nice to have kind checking
14:36:26 * hpc needs to learn this
14:36:29 <mm_freak> data Zero :: Nat
14:36:39 <kmc> in GHC 7.4, every data type is lifted to a kind
14:36:45 <copumpkin> mm_freak: you'd write
14:36:50 <copumpkin> data Nat = Zero | Suc Nat
14:36:55 <copumpkin> then you can use Nat at the type level
14:37:01 <mm_freak> amazing
14:37:06 <mm_freak> is that really already implemented?
14:37:09 <copumpkin> yup
14:37:12 <mm_freak> ok, forget arch
14:37:15 <copumpkin> lol
14:37:16 <mm_freak> i'm getting GHC 7.4 =)
14:37:17 <kmc> haha
14:37:29 <copumpkin> kmc: something to do with unlifted arrays I think
14:37:48 <copumpkin> they just recently killed it I think
14:38:13 <kmc> ok
14:38:14 <kmc> i never saw that one
14:38:15 <mm_freak> this is insanely brilliant…  i'll rewrite my library using that feature
14:38:21 <mm_freak> and that Nat kind is kind-checked?
14:38:30 <kmc> yes
14:38:38 <copumpkin> yup
14:38:39 <copumpkin> I think you have to use a quote to lift constructors
14:38:42 <copumpkin> which is slightly annoying
14:38:44 <copumpkin> but ah well
14:38:48 <mm_freak> data List :: Length -> * -> *
14:38:51 <mm_freak> right?
14:38:59 <copumpkin> Nat -> * -> *, presumably
14:39:05 <kmc> data List (n :: Nat) (t :: *) where ...
14:39:21 <mm_freak> that looks like agda
14:39:22 <hpc> that would be a vector though, yes?
14:39:26 <kmc> or you could just, you know, use Agda
14:39:26 <kmc> yeah
14:39:32 <hpc> :P
14:39:37 <kmc> well what's a vector?
14:39:39 <hpc> agda isn't turing-complete though
14:39:42 <kmc> it is
14:39:48 <kmc> you can ignore the termination checker
14:39:51 <copumpkin> hpc: I don't need it to be
14:39:58 <copumpkin> nor do you
14:40:01 <hpc> kmc: oh, cool
14:40:07 <mm_freak> hpc: agda has codata
14:40:21 <mm_freak> although it's weird to use
14:40:28 <xplat> it's also turing-complete in a monad if you don't mind unwrapping a stack of 'still computing' guards at the end
14:40:46 <copumpkin> the turing-completeness monad!
14:40:49 <copumpkin> muahaha
14:40:54 <copumpkin> nontermination is just another effect
14:40:56 <hpc> bahaha
14:40:59 <kmc> does the Agda implementation notice when you ignore the termination checker, and then try to use the result as evidence in a type coercion?
14:41:14 <xplat> anyway, you can probably count the number of times you wrote a function that was a) correct and b) not at least secretly primitive recursive on the fingers of one hand
14:41:28 <xplat> there was that time you wrote the ackermann function and ... um ... well.
14:41:48 * copumpkin uses mccarthy 91 in all his real-world software
14:42:07 <dolio> What do you mean by "ignore"?
14:42:49 <kmc> we used to judge web frameworks by their ability to compute fibonacci numbers but soon it will be mccarthy 91 instead
14:42:54 <merijn> mm_freak: Codata is just the fancy way of saying infinite data structure, right? (i.e. let l = 1:l in l)
14:43:45 <roconnor> > 10**100
14:43:46 <lambdabot>   1.0e100
14:43:51 <xplat> codata is data that can be infinite
14:43:52 <Rusky> where does cabal find what a package's dependencies? I've installed a patched mueval depending on mtl<2.1, but cabal is still asking for mtl<1.2
14:43:56 <xplat> and can't be foldr'd
14:44:58 <xplat> but it can be unfoldr'd into
14:45:23 <hpc> xplat: you can't foldr codata?
14:45:49 <copumpkin> no
14:46:03 <copumpkin> you don't know it'll ever terminate
14:46:31 <copumpkin> you can write fold-like things over it that produce other codata as they go along
14:46:44 <hpc> ah
14:46:47 <copumpkin> but you can't write a general fold over it
14:47:02 <kmc> so recursion over data requires that recursive calls are made on subterms only
14:47:07 <hpc> or you can get ordinary data out of it, sometimes
14:47:12 <kmc> and recursion over codata requires that recursive calls are made under a codata constructor
14:47:18 <kmc> (meaning the function is productive)
14:47:26 <kmc> but, then, how do you inspect codata at all?
14:47:28 <copumpkin> hpc: the proof of sometimesness would be data, itself, and you'd recurse over that
14:47:59 <hpc> copumpkin: i mean, you can get the head of an infinite list
14:48:04 <copumpkin> sure
14:48:21 <hpc> oh, i see what you mean
14:48:31 <copumpkin> you could also have a proof that your infinite list is finite
14:48:38 <hpc> if you wanted to fold over a finite "head" of codata, you would get that data, then fold over it
14:48:39 <copumpkin> (good luck writing a decision procedure for that, though)
14:48:42 <xplat> @ty \f -> foldr (const f) undefined (repeat ())
14:48:43 <lambdabot> forall b. (b -> b) -> b
14:48:47 <copumpkin> nah, something like
14:48:54 <xplat> (why you can't foldr on infinite lists)
14:49:00 <copumpkin> Finite : Colist A -> Set
14:49:03 <kmc> nice, xplat
14:49:12 <copumpkin> Finite would be data
14:49:14 <kmc> this is my new favorite implementation of 'fix'
14:49:18 <copumpkin> then if you have something like
14:49:31 <kmc> > let fix f = foldr (const f) undefined (repeat ()) in fix ((0:) . scanl (+) 1)
14:49:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:49:52 <copumpkin> (A -> B -> B) -> B -> (xs : Colist A) -> Finite xs -> B
14:49:56 <copumpkin> that'd work
14:49:58 <kmc> > let fix f = foldr (const f) () (repeat ()) in fix ((0:) . scanl (+) 1)
14:49:59 <lambdabot>   Couldn't match expected type `()' against inferred type `[t]'
14:50:15 <copumpkin> except then you're recursing over the Finite xs proof, not over xs directly
14:50:19 <kmc> > let fix f = foldr1 (const f) (repeat ()) in fix ((0:) . scanl (+) 1)
14:50:20 <lambdabot>   Couldn't match expected type `()' against inferred type `[t]'
14:51:09 <xplat> @ty foldr1
14:51:10 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:51:54 <xplat> you need the undefined to define a polymorphic fix
14:52:01 <kmc> *nod*
14:52:18 <xplat> but without it you can still define a monomorphic fix at any type that's already nonempty
14:53:40 <xplat> there's probably an evil way to get undefined out of that, though
14:55:08 <dolio> Get rid of the [] case. It's irrelevant.
14:55:13 <dolio> Use streams.
14:57:23 <Axman6> preflex: seel ehird
14:57:27 <Axman6> preflex: seen ehird
14:57:27 <preflex>  ehird was last seen on #haskell 1 year, 314 days, 29 minutes and 52 seconds ago, saying: yairchu: She.
14:59:52 <Axman6> Dybber: ping
15:00:03 <Axman6> preflex: seen Dybber
15:00:03 <preflex>  Dybber was last seen on #haskell 61 days, 14 hours, 13 minutes and 24 seconds ago, saying: Does anyone have experience with running HPC on a code base which relies heavily on C2HS? I can't get it to give any reasonable output.
15:03:55 <monochrom> but I prefer to place the undefined elsewhere
15:04:40 <shachaf> Axman6: ehird = elliott
15:04:44 <shachaf> preflex: seen elliott
15:04:44 <preflex>  elliott was last seen on #haskell 8 days, 21 hours, 9 minutes and 38 seconds ago, saying: partial no more! :-)
15:07:25 <Axman6> ah ha, thanks shachaf
15:08:53 <xplat> my god, it's fullofcars
15:08:59 <copumpkin> ?
15:09:14 <xplat> 18:37 -!- [1]fullofcars is now known as fullofcars
15:10:30 <monochrom> > let myfix f = foldr1 (const f) (repeat undefined) in myfix ((0:) . scanl (+) 1)
15:10:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:10:42 <monochrom> that is a better place to hide my undefined
15:12:15 <monochrom> "my god, it's foo of bars"
15:13:51 <merijn> monochrom: >.>
15:15:03 <monochrom> say that every time you see generic example code of the form "foo bar = ...", "data Foo bar = ...", "foo[bar]"
15:15:14 <tgeeky> i want to murder you
15:15:39 <tgeeky> i mean, hello
15:15:39 <monochrom> thank you for the compliment!
15:15:44 <merijn> tgeeky: Oh, you'd have gotten along splendidly with our "data structures" professor
15:16:05 <monochrom> eh? what did your data structures professor do?
15:16:06 <tgeeky> I can't stand using foo and bar as examples in any nontrivial data structure
15:16:19 <tgeeky> and I clearly can't think in the same way people who do, do
15:16:24 <hpc> much better to use snargle and zazzle
15:16:59 <monochrom> well, I am no fan of foo bar baz either. at least not bar baz used together.
15:17:11 <merijn> Data structures being "inheritance in Java" and his idea of a test being: We have a class A inherited by class B inherited by class C with instance variables a, b, c and functions a, b, c. We instantiate a mix of them in variables named a, b and c. "a.b.a.c()" which method is called?
15:17:27 <tgeeky> yes. :?
15:17:36 <merijn> There have been very few times were I wanted to murder someone more badly than that exam...
15:17:44 <tgeeky> a,b,c are not interesting letters, and foo, bar, baz, are not interesting words.
15:18:12 <monochrom> apparently my "data Whee a = ..." wins a lot of love
15:18:33 <tgeeky> the thing that's annoying, I suppose, is that the world is filled to the brim of interesting things which readily form good analgoies
15:19:12 <tgeeky> analogies*, but we instead just made up words and arbitrary ordering of an arbitrary alphabet
15:20:52 <popsch> Absolute haskell newbie here. I just want to compile a program. It complains about this: Could not find module `Distribution.GetOpt'
15:21:04 <popsch> what do I have to add, please?
15:21:16 <monochrom> would you prefer class Network inherited by class Internet inherited by class Web with methods click, doubleclick, repeatedlyclick?
15:21:49 <basti_> popsch: i would suppose that you'd have to find a module named "Distribution".
15:21:55 <tgeeky> monochrom: not in Haskell
15:21:58 <mauke> basti_: disagree
15:22:04 <monochrom> let's say java
15:22:07 <tgeeky> you need getopt
15:22:48 <tgeeky> monochrom: if your example is an example about the intersection of browser usage and a mouse
15:22:49 <popsch> how do I add the module distribution or getopt? It's something with cabal
15:22:55 <mauke>  Could not find module `Distribution.GetOpt':   it is a hidden module in the package `Cabal-1.10.2.0'
15:22:58 <mauke> o hai
15:23:10 <mauke> popsch: what program is this?
15:23:20 <popsch> http://www.bortzmeyer.org/eustathius-test-grammars.html
15:23:21 <monochrom> no, not an example about browser mouse etc. an exam question on method overriding.
15:23:21 <tgeeky> cabal install cabal?
15:23:23 <alistra> -package cabal
15:23:30 <alistra> ghci -package cabal file.hs
15:23:35 <popsch> cabal install parsec solved the first problem
15:23:53 <kmc> tgeeky, the world is full of words which readily form *bad* analogies
15:23:57 <kmc> no analogy is better than a bad one
15:24:12 <tgeeky> kmc: uh, perhaps
15:24:30 <tgeeky> kmc: analogies are, good or bad, are symmetries
15:24:36 <jmcarthur> analogies are a great way to overfit an explanation
15:24:40 <Axman6> urgh, does c2hs still not supports blocks in C code >_<
15:24:45 <tgeeky> s/are//
15:24:54 <alistra> Axman6: what's c2hs?
15:24:56 <kmc> bad analogies encourage false beliefs
15:25:02 <alistra> @hackage c2hs
15:25:02 <lambdabot> http://hackage.haskell.org/package/c2hs
15:25:07 <Axman6> that
15:25:15 <copumpkin> analogies are like this time when I visited my parents
15:25:16 <alistra> @hackage testlol
15:25:16 <lambdabot> http://hackage.haskell.org/package/testlol
15:25:17 <copumpkin> I had a cake
15:25:17 <monochrom> analogies are like egg muffins
15:25:28 <copumpkin> and it all went horribly
15:25:29 <merijn> monochrom: Delicious?
15:25:29 <alistra> it's a dumb rewriter
15:25:34 <companion_cube> the cake is a lie
15:25:36 <copumpkin> so you shouldn't like analogies
15:25:47 <alistra> analogies are like monads
15:25:50 <tgeeky> kmc: True enough, but since it's a very effective way of learning (which you are implicitly admitting by the false belief argument), so then it just becomes very important to have good analgoies
15:26:06 <popsch> so is there a way to install the Distribution.GetOpt package, so I can compile the program?
15:26:08 <jmcarthur> i don't think analogies are all that effective
15:26:16 <kmc> @hoogle Distribution.GetOpt
15:26:16 <lambdabot> No results found
15:26:21 <merijn> jmcarthur: Depends on the person and analogy :p
15:26:41 <tgeeky> jmcarthur: it really only matters what people's brains think :o
15:26:44 <kmc> tgeeky, yes, good analogies are good, but in some cases it may be very hard to find one ;P
15:26:45 <mike-burns> @hoogle getopt
15:26:45 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
15:26:45 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
15:26:45 <lambdabot> System.Console.GetOpt module System.Console.GetOpt
15:26:58 <monochrom> oh alistra, I have done @hackage HaltingProblemSolver numerous times :)
15:27:11 <mauke> popsch: it's not a package
15:27:15 <tgeeky> kmc: yeah, I just think it's easier than many people admit, and that smart people can put warnings with analogies
15:27:22 <kmc> i mean lots of people have been looking for The Monad Analogy for years
15:27:24 <jmcarthur> tgeeky: what matters is whether their brain thinks the correct thing after having heard the analogy. this is rare
15:27:41 <alistra> @hackage jhaskell
15:27:42 <lambdabot> http://hackage.haskell.org/package/jhaskell
15:27:45 <merijn> kmc: Oh! I know one!
15:28:04 <popsch> mauke, hm. how come the program doesn't compile then. It's a pity, because I could use an EBNF-based test case generator
15:28:08 <tgeeky> jmcarthur: I don't have any evidence either way. I know there are a lot of operating physicists who understand difficult concepts only by analogy
15:28:16 <monochrom> analogies are like converting IO Char to Char :)
15:28:20 <companion_cube> monad analogy = fix (monad analogy)
15:28:28 <tgeeky> and otherwise don't understand things but become skilled enough practicioners to get on with life.
15:28:31 <jmcarthur> i will loosen my argument slightly
15:28:34 <kmc> popsch, it's a module;  packages are collections of modules and are what you install
15:28:35 <merijn> kmc: A monad is like a Turing-machine. An incredibly useful and fascinating theoretical idea which you don't need to understand to use the results, so shutup and start coding!
15:28:39 <alistra> monads are like a cake with frosting
15:28:53 <kmc> i am trying to find out which package provides that module
15:29:04 <kmc> i suspect it is an old version of Cabal
15:29:08 <monochrom> monads are like copumpkin cake :)
15:29:12 <cl1> howdy folks
15:29:15 <popsch> kmc, thanks a lot
15:29:16 <copumpkin> I WOULD NOT KNOW
15:29:16 <kmc> which is not so great
15:29:25 <alistra> this^
15:29:27 <tgeeky> jmcarthur: I think, in computer science, which is endlessly abstract, analogies do not fit as well.
15:29:34 <kmc> Cabal has often copied and modified libraries from elsewhere
15:29:35 <jmcarthur> analogies can sometimes be an okay way to spread information from person A to person B, but then they get in the way of person B exploring the boundaries of his knowledge
15:29:41 <merijn> monochrom: Does that mean cake made of anything but pumpkins?
15:29:47 <kmc> http://www.haskell.org/cabal/release/old/cabal-0.1-api/Distribution.GetOpt.html
15:29:48 <copumpkin> a right kan extension is kind of like a car
15:29:50 <jmcarthur> i don't think computer science differs much from physics in this regard
15:30:00 <kmc> so let's see if any current package matches this API
15:30:05 <monochrom> a foo is like a bar :)
15:30:11 <tgeeky> jmcarthur: that sounds much more precise
15:30:12 <cl1> yay for bad car analogies! my favorite
15:30:25 <alistra> it's like a mustang from 1960s
15:30:31 <jmcarthur> since many of the theories in physics are unobservable (yet, or forever) anyway
15:30:33 <kmc> popsch, try changing the name 'Distribution.GetOpt' to 'System.Console.GetOpt'
15:30:41 <copumpkin> alistra: the mustang from the 60s is like a left kan extension
15:30:47 <copumpkin> a right kan extension is a ford fusion
15:30:48 <kmc> which is in the 'base' package, so it must already be installed
15:31:15 <tgeeky> jmcarthur: no, that's wrong. there is much mathematics (string theory) which isn't "yet" physics, because of an inability to make an observation
15:31:26 <cl1> i'm up to applicative functors in my learning
15:31:29 <tgeeky> jmcarthur: but by definition, the physics that we know about must be observable
15:31:29 <monochrom> so tgeeky, suppose I am designing a java exam question to test knowledge on method overriding and dynamic dispatch, and I use class names Network, Internet, Web, and method names click doubleclick, do you approve or disapprove or have better suggestions?
15:31:34 <jmcarthur> eh, i don't want to start a metaargument about the line between math and physics :)
15:31:37 <cl1> still haven't written any real code tho
15:31:42 <holla> whatst the best way to take a word8 and return each bit as an array of word8's   (word8 -> [word8])
15:31:50 <kmc> holla, that's a list, not an array
15:32:02 <mike-burns> cl1: Get writing! It's not learning unless you're doing.
15:32:04 <popsch> kmc, works! great. thanks a lot
15:32:05 <holla> sorry, i mean a list!
15:32:09 <kmc> holla, you can do it with the stuff in Data.Bits; I'm not aware of a ready-baked solution
15:32:11 <jmcarthur> a word8 is an array of bits ;)
15:32:12 <kmc> popsch, cool!
15:32:18 <cl1> mike-burns: you would be suprised
15:32:26 <alistra> i totally can't make threads out of what people talk about now
15:32:29 <mike-burns> I certainly would.
15:32:43 <holla> how do i get that array?
15:32:58 <Axman6> not array >_<
15:32:59 <tgeeky> monochrom: hmm. No, I disapprobe, because click and doubleclick have no meaning for anything but web -- but if it actually works as an example, why not. It's just Java.
15:33:03 <Axman6> list!
15:33:14 <Axman6> they are fundamentally different things holla
15:33:21 <cl1> mike-burns, sound advice none the least
15:33:24 <kmc> > let bits = map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) in bits 1337
15:33:25 <lambdabot>   [1,0,0,1,1,1,0,0,1,0,1]
15:33:50 <Axman6> and it is quite important to understanding a hell of a lot of what we do in haskell
15:34:04 <jmcarthur> let bits w = map (Data.Bits.testBit w) [0..63] in bits 357832
15:34:07 <monochrom> tgeeky: well, many end-users have no problem saying things like "click on the internet", "download the internet"... :)
15:34:14 <jmcarthur> > let bits w = map (Data.Bits.testBit w) [0..63] in bits (357832 :: Word64)
15:34:15 <lambdabot>   [False,False,False,True,False,False,True,True,True,False,True,False,True,Tr...
15:34:29 <jmcarthur> > let bits w = map (Data.Bits.testBit w) [63,62..0] in bits (357832 :: Word64)
15:34:30 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
15:34:45 <cl1> > (++) <$> Just "w" <*> Just "00" <*> Just "t"
15:34:45 <lambdabot>   Couldn't match expected type `a -> b'
15:34:46 <lambdabot>         against inferred type `[GHC.T...
15:34:53 <tgeeky> monochrom: oh, they must have learned from the internet :o
15:34:59 <monochrom> there are some rumours circulated by tech support people about a question "how to download the internet to my hard disk"
15:35:14 <alistra> applicative style is more unreadable than pointfree
15:35:20 <tgeeky> they must work at places where employees go on murderous rampages
15:35:33 <tgeeky> alistra: change it to suit your readability needs
15:35:54 <holla> @run let bits = map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) in bits 0
15:35:55 <lambdabot>   []
15:35:56 * hackagebot monad-control 0.3.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.1 (BasVanDijk)
15:36:16 <alistra> in bdsm, m stands for monads
15:36:42 <cl1> alistra, i'm still learning, even if that is harder to read
15:37:23 <monochrom> anyway, concrete examples are necessary early, Piaget's theory etc. I think people are obsessed with analogies because people are rightfully hungry for concrete examples, but the teacher is too lazy to come up with correct ones, and so the teacher looks for incorrect ones elsewhere and hopes that it passes
15:43:04 <Philonous> "The usual way in which we plan today for tomorrow is in yesterday's vocabulary. We do so, because we try to get away with the concepts we are familiar with and that have acquired their meanings in our past experience. Of course, the words and the concepts don't quite fit because our future differs from our past"
15:43:46 <alistra> so deep
15:46:01 <tgeeky> Philonous: I would also want to add something like "because today and tomorrow are always assembled from the vestiges accidentally left behind by yesterday's todays."
15:46:09 <tgeeky> or something even more cheeky
15:47:33 <cl1> > (++) <$> (++"00") <$> Just "w" <*> Just "t"
15:47:34 <lambdabot>   Just "w00t"
15:47:38 <cl1> :D
15:48:55 <MostAwesomeDude> > Just "w00t"
15:48:56 <lambdabot>   Just "w00t"
15:48:59 <MostAwesomeDude> :3
15:49:56 <parcs`> > text "Just \"w00t\""
15:49:57 <lambdabot>   Just "w00t"
15:49:58 <mike-burns> > return "w00t" :: Maybe String
15:49:58 <lambdabot>   Just "w00t"
15:50:08 <mike-burns> Hah.
15:53:03 <_oz> > let (<++>) = liftA2 (++) in  Just "w" <++> Just "00" <++> Just "t"
15:53:05 <lambdabot>   Just "w00t"
15:55:46 <cl1> _oz, you win
15:55:52 <cl1> that was what I was trying to do
15:56:12 <_oz> cl1: yay! I won! :)
15:56:50 <ddarius> > mconcat [Just "w", Just "00", Just "t"]
15:56:51 <lambdabot>   Just "w00t"
15:57:00 <parcs`> > Just "W" ++ Just "00"
15:57:02 <lambdabot>   Just "W00"
15:57:11 <_oz> :t (++)
15:57:11 <lambdabot> forall m. (Monoid m) => m -> m -> m
15:57:16 <cl1> i will have to say, i had no clue that there were that many ways to produce that result
15:57:19 <irene-knapp> heh
15:57:20 <irene-knapp> indeed
15:57:21 <_oz> parcs`: that's cheating.
15:57:54 <mike-burns> > mconcat $ map Just ["w", "00", "t"]
15:57:54 <lambdabot>   Just "w00t"
15:58:03 <MostAwesomeDude> read "Just \"w00t\"" :: Maybe String
15:58:08 <MostAwesomeDude> > read "Just \"w00t\"" :: Maybe String
15:58:09 <lambdabot>   Just "w00t"
15:58:40 <hpc> incidentally, the definition of monoid for Maybe includes mconcat = (<++>)
15:58:46 <ddarius> _oz: Your (<++>) is just a special case of mappend. (++) is bound to mappend in lambdabot.
15:58:47 <hpc> er, mappend
15:59:02 <ClaudiusMaximus> > sequenceA [Just "w", Just "00", Just "t"]
15:59:03 <lambdabot>   Not in scope: `sequenceA'
15:59:10 <kmc> :t liftA2 (++)
15:59:11 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
15:59:29 <ddarius> ClaudiusMaximus: sequence will do the wrong thing.
15:59:29 <kmc> :t mappend
15:59:29 <parcs`> > map (($ Just "i") . ($ Just "H")) [mplus, mappend]
15:59:30 <lambdabot> forall a. (Monoid a) => a -> a -> a
15:59:31 <lambdabot>   [Just "H",Just "Hi"]
15:59:34 <cl1> its like giving a cat a ball of string, they just can't put it down. LOL
15:59:37 <alistra> > ['w', 0, 0, 't']
15:59:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:59:38 <lambdabot>    arising from the literal `0...
15:59:39 <ClaudiusMaximus> ddarius: oh
15:59:42 <_oz> ddarius: yes. I only said it was cheating because it is not normally bound to mappend.
15:59:42 <alistra> > ['w', 0, 0, 't'] - 1
15:59:42 <kmc> i don't think they're equivalent; they coincide on Maybe
15:59:43 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:59:43 <lambdabot>    arising from the literal `0...
15:59:47 <kmc> or something
16:00:00 <kmc> cl1, :)
16:00:20 <mike-burns> alistra: Those are different types.
16:00:42 <kmc> 0 and 'w' can have the same type
16:00:47 <kmc> if you have an instance Num Char
16:02:12 <_oz> list literals and integer literals cannot have the same type tho. at least without extensions.
16:02:30 <ddarius> _oz: Sure they can.
16:02:54 <_oz> ddarius: how?
16:03:22 <hpc> _oz: instance Num a => Num [a] where ...
16:03:25 <ddarius> instance Num [a] is a perfectly legitimate instance head in Haskell 98/2010
16:03:47 <_oz> oh yes. you're right.
16:04:25 <kmc> there are some good reasons not to have instance Num Char
16:04:26 <kmc> :)
16:04:35 <alistra> why?
16:04:44 <alistra> > 'a' + 'a'
16:04:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
16:04:45 <lambdabot>    arising from a use of `GHC....
16:04:51 <alistra> > 'a'
16:04:52 <hpc> kmc: the usual "complicated prelude errors" thing?
16:04:52 <lambdabot>   'a'
16:05:04 <hpc> or is it stuff like '1' + '5'?
16:05:25 <mercury^> Because then addition of strings would be pointwise addition of characters.
16:05:26 <ddarius> There are plenty of issues caused by having "characters" be numeric types in C.
16:05:37 <mercury^> Huh?
16:05:46 <mercury^> ddarius: can you elaborate?
16:05:57 <kmc> one reason is that you want to catch mistakes
16:06:14 <alistra> you want to have
16:06:17 <kmc> as type errors, rather than doing some bizarre unintended calculation on codepoints
16:06:20 <mike-burns> I strongly dislike when people turn  +  into a function that doesn't commute.
16:06:24 <alistra> 'a' < x && x < 'z'
16:06:36 <kmc> another is that Num is too big, and so you'd have to implement things like (*)
16:06:41 <shachaf> alistra: You don't need Num for (<).
16:06:46 <alistra> yes i know
16:06:56 <alistra> you have ord for that
16:07:07 <kmc> also the space of valid Unicode scalar values is not a contiguous interval of the integers
16:07:10 <shachaf> (+) doesn't make much sense on characters.
16:07:19 <kmc> though GHCi's Char will let you represent those invalid values too
16:07:21 <kmc> but maybe it shouldn't
16:07:36 <aavogt> so Char shouldn't be Enum either?
16:07:53 <ddarius> Enum says absolutely nothing about contiguousness.
16:08:10 <alistra> @src Bounded
16:08:10 <lambdabot> class  Bounded a  where
16:08:10 <lambdabot>     minBound, maxBound :: a
16:08:37 <ByronJohnson> < ByronJohnson> I wonder whether the class duplication could be avoided by somehow making the original classes equivalent to the restricted ones — Would there be any reason not to have an implied constraint for every class that defaults to ()?  Regardless of which approach is chosen, I think we should try to avoid duplicating the classes by making them equivalent if possible
16:09:07 <cl1> why do they call it point-free if it has lots of points in it
16:09:09 <kmc> as i understand, this is one reason why default instances for associated type (synonyms) was also added in GHC 7.4
16:09:17 <cl1> (*3) . (+100) 5
16:09:18 <kmc> http://en.wikipedia.org/wiki/Pointless_topology
16:09:19 <aavogt>  fromInteger (toInteger x + 1) == succ x --- so fromInteger is supposed to be partial?
16:09:22 <cl1> > (*3) . (+100) 5
16:09:22 <lambdabot>   No instance for (GHC.Num.Num (f a))
16:09:23 <lambdabot>    arising from a use of `e_131005' at ...
16:09:31 <cl1> > (*3) . (+100) $ 5
16:09:32 <lambdabot>  Terminated
16:09:39 <ddarius> aavogt: fromInteger has nothing to do with Enum.
16:09:43 <kmc> aavogt, where does that rule come from?
16:09:45 <alistra> cl1: the point is not (.) but the argument of the function in this context
16:10:00 <aavogt> oops, I meant   fromEnum and toEnum
16:10:01 <ByronJohnson> < kmc> as i understand, this is one reason why default instances for associated type (synonyms) was also added in GHC 7.4 — Was that a response to the class duplication discussion?
16:10:11 <alistra> not sure, but i think it's you know like a point on a plot of a function :D? cl1
16:10:24 <kmc> ByronJohnson, yes -- it allows you to provide a default constraint of ()
16:10:39 <ddarius> aavogt: succ x is not required to be fromEnum (toEnum x + 1).  Also, the Report explicitly states that succ -is- partial on Bounded types.
16:10:56 <cl1> > (+) . (*) $ 3 5
16:10:56 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a -> a)
16:10:57 <lambdabot>    arising fro...
16:11:39 <ByronJohnson> kmc: Oh, GHC 7.4 already has implied constraints?
16:11:45 <kmc> instance Monad m where { type Ctx m :: * -> Constraint; type Ctx m = (); return :: (Ctx m a) => a -> m a }
16:11:46 <cl1> > (*3) . (+100) $ 5
16:11:48 <lambdabot>   315
16:11:50 <kmc> i think it something like that
16:11:56 <kmc> based on http://hackage.haskell.org/trac/ghc/wiki/Status/Oct11
16:12:27 <cl1> alistra, so its point-free because there are no arguments?
16:12:39 <cl1> ala, (*3) . (+100)
16:12:49 <alistra> in the definition, yes
16:12:52 <ddarius> Furthermore, you could still map a contiguous range of Ints to codepoints if you wanted to, and regardless, toEnum is partial.  Not all Ints are valid codepoints.
16:13:55 <jmcarthur> > (+100) * 3 $ 5
16:13:55 <lambdabot>   315
16:15:20 <jmcarthur> > (id + 100) * 3 $ 5
16:15:21 <lambdabot>   315
16:15:21 <ddarius> e rice at s brains
16:15:21 <alistra> (on (>) fst) (1,2) (2,3)
16:15:24 <alistra> > (on (>) fst) (1,2) (2,3)
16:15:25 <lambdabot>   False
16:15:54 <cl1> what does on do?
16:15:59 <mike-burns> :t on
16:16:00 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:16:09 <cl1> i don't get that in ghci
16:16:10 <alistra> on g f x y = g (f x) (f y)
16:16:11 <ByronJohnson> Ah, excellent!
16:16:16 <cl1> i get a not in scope error
16:16:17 <alistra> @src on
16:16:17 <mike-burns> Hah.
16:16:17 <jmcarthur> > (+) `on` fst $ (1,2) (3,4)
16:16:17 <lambdabot> (*) `on` f = \x y -> f x * f y
16:16:18 <lambdabot>   Precedence parsing error
16:16:18 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
16:16:28 <jmcarthur> > ((+) `on` fst) (1,2) (3,4)
16:16:29 <lambdabot>   4
16:16:48 <jmcarthur> cl1: Data.Function.on
16:17:02 <cl1> jmcarthur, thanks
16:17:03 <alistra> cl1: :m Data.Function
16:17:06 <mike-burns> :t (on (>) fst)
16:17:07 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Bool
16:17:11 <kmc> err, that's "class Monad m where ..." ofcourse
16:17:32 <alistra> on is aweseme
16:17:38 <alistra> on is ON!
16:18:03 <alistra> there's also comparing, but nobody likes that
16:18:08 <mike-burns> I like comparing.
16:18:16 <alistra> > comparing fst (1,2) (4,3)
16:18:16 <lambdabot>   LT
16:18:18 <mike-burns> I assume `on' is best read as infix?
16:18:20 <jmcarthur> i wish it was possible to type such that  (on (>) fst) :: (a, b) -> (a, c) -> Bool
16:18:26 <jmcarthur> i like comparing, too
16:18:28 <alistra> mike-burns: i never read it as infix
16:18:38 <Axman6> dcoutts: are you around by any chance?
16:19:03 <jmcarthur> i mean this, of course:   (on (>) fst) :: Ord a => (a, b) -> (a, c) -> Bool
16:19:20 <cl1> > on (>) fst $ (1,2) (2,3)
16:19:21 <lambdabot>   Couldn't match expected type `t -> (a, b)'
16:19:21 <lambdabot>         against inferred type `(...
16:19:27 <alistra> jmcarthur: so then the fst would have been hardcoded
16:19:36 <alistra> imagine snd instead of fst
16:19:38 <cl1> (on (>) fst) (1,2) (2,3)
16:19:39 <alistra> :O
16:19:42 <jmcarthur> huh?
16:19:53 <cl1> > (on (>) fst) (1,2) (2,3)
16:19:54 <lambdabot>   False
16:20:00 <jmcarthur> i just meant i wish it was possible to write on such that that expression would have that type
16:20:11 <alistra> you can't
16:20:14 <jmcarthur> i know...
16:20:15 <Axman6> > ((>) `on` fst) (1,2) (3,4)
16:20:15 <lambdabot>   False
16:20:19 <alistra> it can't be parametrized by fst
16:20:22 <jmcarthur> that's why i said "i wish"
16:20:24 <mike-burns> I bet jmcarthur knows that he can't.
16:20:32 <alistra> yeah, but it wouldn't make any sense
16:20:34 <alistra> if you could
16:20:40 * mike-burns watches
16:21:01 <jmcarthur> it doesn't make sense in the type system we have right now
16:21:55 <alistra> :t second
16:21:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:22:20 <alistra> maybe there's an arrow for that
16:22:22 <jmcarthur> actually i bet it could be done with a silly associated type synonym thing
16:22:28 <ddarius> alistra: The issue is that when inlined, the expression has a more general type.
16:22:55 <ddarius> A similar thing happens with twice f = f . f
16:22:57 <jmcarthur> but it would restrict the function to things that are instances of the type class
16:23:08 <jmcarthur> :t \f -> f . f
16:23:09 <lambdabot> forall b. (b -> b) -> b -> b
16:23:24 <ddarius> :t (:[]) . (:[])
16:23:25 <lambdabot> forall a. a -> [[a]]
16:23:30 <mkscrg> anybody know: does enumerator export a function to compose enumeratees?
16:23:34 <ddarius> :t let twice f = f . f in twice (:[])
16:23:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
16:23:34 <lambdabot>       Expected type: a
16:23:34 <lambdabot>       Inferred type: [a]
16:23:59 <ddarius> mkscrg: Aren't they just instances of Monad?
16:24:02 <ByronJohnson> mkscrg: I recommend looking at iterIO; you'll probably be impressed once you get into it
16:24:37 <copumpkin> mkscrg: no, and there's not an easy way to do that either
16:24:41 <copumpkin> ddarius: they're type synonyms around a function
16:24:53 <copumpkin> and the function monad instance isn't the one you really want
16:25:07 <mkscrg> copumpkin: yeah, that's what it looked like but i wanted to check
16:25:08 <mkscrg> right
16:25:29 <cl1> > (+3) <$> (3,4)
16:25:30 <lambdabot>   (3,7)
16:25:39 <cl1> why does it make sense to add to snd?
16:25:51 <copumpkin> cl1: the type is (,) a b
16:25:53 <hpc> cl1: because that's what the types say to do
16:26:01 <mkscrg> ByronJohnson: are you telling me that iterIO is to enumerator what enumerator was to iteratee?
16:26:52 <cl1> i know that is what the types say to do, otherwise it wouldn't be doing that. why does it say to do that?
16:27:04 <ByronJohnson> mkscrg: Yes.
16:27:09 <copumpkin> because fmap :: (a -> b) -> f a -> f b
16:27:21 <copumpkin> the only way that fits is if f = (,) k
16:27:33 <copumpkin> so that boils down to
16:27:35 <cl1> oic
16:27:39 <copumpkin> (a -> b) -> (k, a) -> (k, b)
16:27:55 <lars9> can iterIO be used for random access? for example if we want to implement the tail command, we need to seek to end of file first, then seek back for '\n's
16:28:22 <cl1> is it possible to get it to (a -> b) -> (a, k) -> (b, k)?
16:28:23 <mkscrg> ByronJohnson: now i can't resist, despite hundreds of lines of enumerator code
16:28:27 <mkscrg> :P
16:28:44 <sipa> @pl \f (a,b) -> (f a,b)
16:28:45 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
16:28:51 <kmc> cl1, no
16:29:09 <cl1> always left to right then
16:29:12 <kmc> similarly you can have (a -> b) -> (Either c a -> Either c b)
16:29:20 <kmc> but not (a -> b) -> (Either a c -> Either b c)
16:29:59 <alistra> type Rehtie a b = Either b a
16:30:00 <cl1> so basically if i need to do work like that on the first item in the tuple I would have to swap them first
16:30:13 <dylukes> alistra: stop doing that >.<
16:30:19 <dylukes> just use bimap.
16:30:27 <alistra> what's a bimap
16:30:31 <dylukes> :t bimap
16:30:32 <lambdabot> Not in scope: `bimap'
16:30:37 <dylukes> It's fmap for Bifunctors.
16:30:38 <alistra> nice bimap
16:30:51 <mike-burns> @hoogle bimap
16:30:51 <lambdabot> package bimap
16:30:53 <alistra> what's a bifunctor?
16:30:54 <dylukes> bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
16:30:59 <copumpkin> I want a bimap that works on all variances
16:31:13 <copumpkin> in fact, I wrote one a while ago
16:31:20 <copumpkin> kind of overkill, though
16:32:46 <jmcarthur> cl1: you could use Control.Arrow.first
16:33:08 <ByronJohnson> lars9: Yes; it's pretty simple, too
16:33:37 <dylukes> "all variances"?
16:33:51 <copumpkin> dylukes: that type would almost work for p = (->)
16:33:58 <copumpkin> except (->) is contravariant in its first argument
16:34:01 <lars9> ByronJohnson: which function allows it to do so?
16:34:27 <jmcarthur> how would you have it work for all variances?
16:34:43 <jmcarthur> through some type family or fundep hackery i guess?
16:34:45 <copumpkin> crazy type families, I can't remember how I did last time
16:34:49 <copumpkin> but yeah
16:35:05 <jmcarthur> yeah that doesn't really sound very useful to me, i think
16:35:10 <copumpkin> :(
16:35:43 <ByronJohnson> lars9: I'd suggest reading the documentation first, because its documentation really is excellent.  But, basically, the iteratee can return returns a control request (CtlArg)
16:36:09 <ByronJohnson> lars9: You could define your own CtlCmd if you wanted to, but theer is already http://hackage.haskell.org/packages/archive/iterIO/latest/doc/html/Data-IterIO-ListLike.html#t:SeekC for this purpose
16:36:12 <lars9> ByronJohnson: i'll have a look, thanks
16:36:12 <ddarius> copumpkin: All functors are covariant.  You need to change the category, man.
16:36:19 <copumpkin> yeah yeah :P
16:36:59 * ddarius doesn't recall if his Monad Reader article had bifunctors, but it did have a class for functors of arbitrary variance.
16:37:26 <dylukes> copumpkin: Oh that kind of variance.
16:38:14 <hpaste> kmc pasted “trouble with constraint kinds + associated type synonym default” at http://hpaste.org/55412
16:38:33 <kmc> this is all beautiful except that the associated type synonym default doesn't work :/
16:39:05 <copumpkin> I thought they'd lifted that restriction
16:39:11 <copumpkin> oh
16:39:13 <kmc> i need a type expression equivalent to λx. ()
16:39:21 <copumpkin>     type Ctx f a :: Constraint
16:39:22 <shachaf> kmc: type Ctx f a :: Constraint?
16:39:32 <copumpkin> kmc: you can get one of those too, but it's ugly
16:39:42 <kmc> you can't have parameters not part of the instance
16:39:51 <copumpkin> that's what they changed, I thought
16:39:53 <copumpkin> class Trivial a
16:39:56 <copumpkin> instance Trivial a
16:40:03 <kmc> also i need to require it for all a
16:40:13 <shachaf> kmc: http://blog.omega-prime.co.uk/?p=127 does that, at least.
16:40:42 * shachaf doesn't have GHC with ConstraintKinds yet.
16:41:28 <kmc> hmm
16:41:55 <ByronJohnson> kmc: (ByteStrings can also be Functors)
16:42:12 <copumpkin> wrong kind, right now
16:42:15 <shachaf> ByronJohnson: They can?
16:42:42 <shachaf> I suppose if you had a context like (Word8 ~) and the right kind...
16:42:46 <ByronJohnson> type Cxt B.ByteString = (Word8 ~)
16:42:52 <copumpkin> ByronJohnson: still wrong kind
16:42:54 <ByronJohnson> Ah, I forgot about the kind
16:42:56 <shachaf> Can you actually partially apply (~)?
16:43:02 <copumpkin> this feels strangely deja vuish
16:44:00 <ByronJohnson> shachaf: (~) :: * -> * -> Contraints, IIRC
16:44:11 <shachaf> Ah, neat.
16:44:17 <copumpkin> ByronJohnson: even more powerful
16:44:19 <kmc> huh, don't know what i was doing wrong before
16:44:28 <kmc> but now it's okay with class Functor f where { type Ctx f a :: Constraint ... }
16:44:39 <copumpkin> kmc: well, in the past, you couldn't have more parameters than in the class head
16:44:40 <dylukes> It seems GHC 7.4 is a bit of a game changer ;~;
16:44:41 <copumpkin> but now they lifted that
16:44:55 <kmc> they changed the game
16:45:13 <ByronJohnson> copumpkin: Bummer.  I really wish there were some way to make ByteStrings Functor
16:45:22 <ByronJohnson> copumpkin: Perhaps.. Const Functor!
16:45:32 <copumpkin> ByronJohnson: probably is, once you get polymorphic kinds and all that nastiness
16:45:33 <shachaf> The game ain't like it used to be. semicolontildesemicolon
16:45:34 <kmc> 7.2 also added cool new features
16:45:39 <kmc> Platform is behind :/
16:45:51 * shachaf is also behind.
16:45:58 <dylukes> Feels like Prelude is going to be behind in 7.4.
16:46:00 <ByronJohnson> copumpkin: Aha, polymorphic kinds!
16:46:16 <shachaf> dylukes: Why? The Prelude should stay Haskell 2010.
16:46:25 <dylukes> oh true.
16:46:33 <shachaf> Anyway what's wrong with it?
16:46:43 <shachaf> I hope you're not suggesting RMonad as new the Monad.
16:46:43 <dylukes> No I mean, it seems we can be more expressive now.
16:46:49 <copumpkin> not RMonad
16:46:53 <dylukes> I don't know much about RMonad.
16:46:57 <copumpkin> a fancier monad though
16:47:07 <dylukes> I still think MonadPlus should be split.
16:47:08 <copumpkin> the problem is that it'll infect all our type signatures
16:47:18 <shachaf> copumpkin: Fancier how?
16:47:33 <copumpkin> well, we build off of the fancier Functor like how kmc was doing it
16:47:41 <copumpkin> but I think we should rename them all to RawFunctor and RawMonad
16:47:43 <irene-knapp> wait, they made Functor fancier?
16:47:46 <copumpkin> (of course, Monad will derive from it)
16:47:48 <copumpkin> no
16:47:55 * irene-knapp pays half-attention
16:47:56 <copumpkin> then
16:47:59 <kmc> so is there a way to accommodate ByteString also, with KindPolymorphism?
16:48:13 <copumpkin> type Monad f a = (RawMonad f, Ctx f a)
16:48:22 <irene-knapp> hm
16:48:23 <kmc> hmm
16:48:23 <copumpkin> kmc: I dunno, I'm not sure people have played with it
16:48:38 <rostayob> uff, I was expecting GHC 7.4 when I saw "New haskell platform out"
16:48:46 <kmc> GHC 7.4 isn't even out
16:49:00 <dylukes> Do you think the 7.4 features will be in H2012?
16:49:04 <rostayob> yeah I know now, I haven't been following closely
16:49:11 <kmc> dylukes, the Haskell 2012 language?
16:49:14 <dylukes> Yeah.
16:49:23 <kmc> will all GHC 7.4 extensions be in Haskell 2012?
16:49:28 <kmc> certainly not
16:49:30 <dylukes> Well, will some of them.
16:49:31 <dylukes> :P
16:49:33 <rostayob> that would surprise me
16:49:34 <rostayob> yeah
16:49:35 <dylukes> The ones that are more vetted.
16:49:38 <rostayob> like?
16:49:44 <dylukes> I don't know yet :P
16:49:46 <irene-knapp> none of them are vetted :)
16:49:49 <kmc> yes, GHC extensions are the primary source of new features for standard Haskell
16:50:03 <kmc> i don't think any of the extensions which are new in GHC 7.4 will be standardized any time soon
16:50:04 <copumpkin> dylukes: for that to happen, someone's gotta propose them
16:50:23 <shachaf> You gotta do what you gotta do.
16:50:23 <rostayob> i mean not even multi param type classes are in the report, afaik
16:50:32 <kmc> right
16:50:42 <shachaf> rostayob: Let alone zero-param type classes.
16:50:43 <dylukes> MPTC's seem pretty... agreed on?
16:50:51 <kmc> yeah
16:50:52 <copumpkin> dylukes: not really
16:50:56 <rostayob> and that's pretty much standard in other Haskell compilers
16:51:03 <dylukes> Maybe not how they're implemented...
16:51:04 <kmc> but people usually want either fundeps or asstypes to go with
16:51:06 <rostayob> apart from GHC
16:51:09 <kmc> and this is more contentious
16:51:10 <dylukes> kmc: Right.
16:51:15 * merijn snickers at asstypes
16:51:18 <dylukes> I personally find asstypes nicer.
16:51:19 <kmc> :D
16:51:23 <merijn> Clearly it's time for me to go to bed
16:51:29 <hpc> @remember dylukes I personally find asstypes nicer.
16:51:29 <lambdabot> Done.
16:51:35 <dylukes> XD
16:51:53 <shachaf> How droll, #haskell.
16:51:59 <kmc> you can replace every fundep with an asstype if you allow superclass equality constraints
16:52:09 <kmc> but it's pretty verbose to do so
16:52:51 <dylukes> asstypes seem more elegant usually.
16:53:00 <dylukes> there are probably cases where this doesn't work out though.
16:53:07 <kmc> yeah
16:53:15 <dylukes> Can fundeps be defined as sugar for asstypes?
16:53:25 <kmc> probably
16:55:24 <copumpkin> simulating the full power of fundeps requires superclass equality constraints
16:55:28 <copumpkin> which are now supported as well
16:55:37 <kmc> yeah, as of 7.2
16:55:45 * Saizan wonders if that's really enough
16:56:00 <dylukes> superclass equality constraints?
16:56:17 <benmachine> one thing you /definitely/ need for MPTCs is flexibleinstances, and probably contexts
16:56:24 <benmachine> even those aren't h2011
16:56:35 <kmc> i think those extensions are pretty uncontroversial though, and could get ratified easily
16:56:35 <Sgeo> zero-param type classes?
16:56:41 <copumpkin> but I think it's nice to have both of them
16:56:42 <copumpkin> yeah, those should be added
16:56:46 <copumpkin> someone should propose them
16:56:49 * copumpkin puts finger on nose
16:56:50 <Sgeo> What's the point of them?
16:57:13 <bd_> Sgeo: you can use zero-parameter type classes to write comments in type declarations
16:57:19 <dylukes> >_>.
16:57:20 <bd_> foo :: This, Is, A, Comment => ....
16:57:22 <dylukes> Really?
16:57:25 <benmachine> hah
16:57:27 <kmc> «class C a b | a -> b where ...»  ⇒  «class (T a ~ b) => C a b where type T a»   -- dylukes
16:57:28 <dylukes> hahaha
16:57:44 <dylukes> oh ~ in the superclass?
16:57:45 <kmc> the class C has a superclass constraint which is an equality constraint over an asstype defined within C
16:57:51 <kmc> yea
16:58:03 <copumpkin> although in that case, you don't need equality
16:58:10 <benmachine> kmc: well, that particular constraint can just be modelled by class C a where type T a
16:58:12 <copumpkin> well, you could drop the extra parameter
16:58:13 <kmc> yes
16:58:18 <copumpkin> however, for bidirectional you do
16:58:19 <kmc> but there are some other cases where you can't
16:58:22 <benmachine> sure
16:58:41 <benmachine> I think assoctypes are more natural than fundeps but fundeps do seem to express some things more neatly
16:58:55 <benmachine> we could ofc have both
16:58:59 <dylukes> Yeah as I said,
16:59:05 <dylukes> fundeps as sugar for asstypes maybe.
16:59:18 <kmc> so how do I use kind polymorphism on types?
16:59:19 <copumpkin> can we stop calling them asstypes?
16:59:37 <kmc> aww
16:59:50 <kmc> ghc rejects «class C (t :: k)»
16:59:53 <kmc> i'm using 7.3.20111026
17:00:13 <kmc> err i meant "kind polymorphism on classes"
17:00:18 <Saizan> class C k (t :: k) ?
17:01:03 <FliPPeh> So I'm having a case of the stupids again. Say I have the type "newtype MPD a = MPD { runMPD :: ErrorT (StateT MPDState IO) a }", when running it with "evalStateT (runErrorT . runMPD $ f)", why is it that I have to start "f" with "MPD $ do <stuff>" before being able to use, say, "get", when I can use functions within a normal state monad like I would use an IO functio, without manually building the monad type?
17:01:34 <parcs`> kmc: it's implicit
17:01:39 <dylukes> copumpkin: what do you have against asstypes?
17:01:48 <copumpkin> just sounds a little wrong
17:01:59 <parcs`> do class C a; instance C Int; instance C []; then in ghci do ':i C'
17:02:29 * Philippa suggests "astypes" to remind us that it's not actually pronounced like donkey types
17:03:05 <kmc> parcs`, no good :/
17:03:19 <kmc> i will update ghc again
17:03:26 * irene-knapp wiggles her asstype =p
17:03:30 <parcs`> strange, works for me
17:03:32 <kmc> is there a LANGUAGE name for it?  i don't have KindPolymorphism...
17:03:51 <FliPPeh> :(
17:04:00 <parcs`> PolyKinds
17:04:15 <benmachine> ghc --supported-languages | grep -i kind
17:04:16 <benmachine> :P
17:04:25 <kmc> yeah i did that, and didn't see it
17:04:39 <kmc> i guess my ghc is too old
17:04:47 <kmc> (less than 2 months old ;P)
17:04:51 <Saizan> FliPPeh: derive (MonadState MPDState)
17:05:11 <parcs`> the extension is a little immature yet
17:05:25 <parcs`> for instance the kind String is not the same as the kind [Char]
17:05:41 <kmc> o_O
17:05:47 <kmc> it doesn't normalize type synonyms?
17:05:50 <FliPPeh> Saizan: Wow, thanks, that actually works!
17:05:51 <Axman6> kmc: gotta keep up! if you're not installing a new GHC each week, you'll get left behind
17:05:57 <parcs`> vague/innapropriate type errors
17:06:15 <FliPPeh> Saizan: What about does that?
17:06:40 <irene-knapp> but it takes all week to install ghc!
17:06:48 <Saizan> FliPPeh: defines a MonadState MPDState MPD instance for you
17:06:53 <xplat> i like big asstypes and i cannot lie
17:07:05 <xplat> irene-knapp: your own fault for using macs :)
17:07:11 <irene-knapp> bah :)
17:07:33 <FliPPeh> Saizan: Yes, that much I know, but what magic does MonadState do so I don't have to manually wrap the functions anymore?
17:07:50 <ddarius> :t get
17:07:51 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
17:07:56 <Saizan> :t put
17:07:57 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
17:08:11 <FliPPeh> hoogle to the rescue
17:08:20 <FliPPeh> Thanks :)
17:08:33 <parcs`> many type/kind errors reveal kinds that you can't use, eg BOX, AnyK... also the extension breaks the kind Constraint, as it is thought to be a data constructor and not a special kind
17:08:55 <parcs`> so you can't annotate kinds as Constraint, which breaks associated types/kinds
17:08:58 <kmc> oh noes
17:09:41 <xplat> should ConstraintKinds turn Constraint into a reserved word?
17:10:06 <kmc> * isn't a reserved symbol
17:10:15 <xplat> it is in that position
17:10:19 <kmc> sure
17:10:24 <kmc> what do you mean then
17:10:59 <Saizan> data S x = S x; does the data-constructor S clash with the type S when lifted up?
17:11:05 <xplat> maybe ConstraintKinds should turn Constraint into a reserved word so it can coexist with DataKinds
17:11:16 <xplat> Saizan: one of them has a quote
17:11:20 <xplat> of some sort
17:11:40 * kmc builds GHC 7.5.20111216
17:11:55 <mkscrg> can someone give me a good reason to use iterIO over enumerator? its primary advantage seems to be greater ease of learning (and i'm not really convinced of that, even)
17:12:06 <parcs`> 'S is a type, S a kind
17:12:22 <mkscrg> mkscrg: maybe ByronJohnson, who suggested it?
17:13:47 <parcs`> wait 'S is the type of kind S, S the the type of kind *
17:15:37 <mkscrg> looks like it does a better job of allowing enumerator(ee) composition
17:15:40 <mkscrg> interesting
17:18:59 <xplat> enumeratee composition works really badly in enumerator afaict
17:19:43 <xplat> the main advantage of enumerator to me is it's the most commonly used and hence has the most prebuilt iteratees and enumerators for it
17:19:58 <xplat> some other people like it for other reasons that i can't get behind
17:21:55 <mkscrg> xplat: what are those reasons, unsupportable as they may be?
17:22:38 <xplat> some like that iteratee is a simple concrete type and the presence of the separate 'Step' type
17:23:34 <xplat> some like that the chunks are always lists and thus there are fewer typeclasses to think about
17:24:57 <xplat> some think the CPS transformation in "iteratee" (the other of the Big 2 iteratee libs) is redundant because an iteratee is already a CPS-transformed loop and it hurts performance rather than helps (i have no opinion on this)
17:25:47 <xplat> i don't know which of these would apply in comparisons with iterIO rather than iteratee either
17:25:48 <Axman6> i've seen it lead to massive memory leaks too
17:26:15 * ddarius thinks monad-coroutine is the right way to think about/approach iteratees.
17:30:03 <xplat> Axman6: when does that happen?
17:31:16 <Axman6> it happened in a program that was used at Tsuru capital while i was there. it was a bitch to debug too
17:34:56 <mkscrg> iterIO's development was funded by DARPA. lol
17:35:58 <dolio> copumpkin: You should get DARPA funding for derpa.
17:36:22 <xplat> and then use it to write a program called dirpa
17:37:00 <xplat> which is used to manufacture dorpas for durpa, inc
17:37:19 <dolio> The cycle is complete.
17:37:23 <dolio> Unless we need dyrpa.
17:37:31 <xplat> only sometimes
17:38:17 <xplat> probably will sponsor the IPO
17:41:21 <copumpkin> dolio: omg good idea
17:45:31 <dolio> Iteratees fairly clearly aren't already CPS transformed.
17:45:54 <benmachine> I think that iteratee is written by a guy who knows how to benchmark
17:46:02 <dolio> Because the original definition is very close to being a free monad.
17:46:11 <benmachine> so I'd be surprised if the CPS transform wasn't a genuine optimisation
17:46:13 <peterjoel> hi, I'd like to fix some spelling errors in the platform installer/uninstaller. Where can I find that repository to fork?
17:46:16 <dolio> And not the CPS transformed free monad.
17:47:32 <dolio> You just have to recognize that you can have trees that involve using functions as the branching factor, and traversing those trees isn't magically cheaper than traversing normal trees.
17:47:46 <dolio> At least, I don't think so.
17:47:59 <copumpkin> magictrees
17:48:09 <Sgeo> Ooh, new Haskell platform
17:48:11 <Sgeo> What's new?
17:48:37 <dolio> It now works with GHC 7.0.3 or something.
17:48:46 <copumpkin> 7.0.4!
17:48:50 <copumpkin> don't get it wrong
17:49:02 <dolio> My mistake.
17:49:26 <benmachine> 7.0.4 covered under "something"
17:50:04 <dolio> Yeah. I'm totally vindicated.
17:50:22 <dolio> Anyhow, whatever is prior to 7.2.x.
17:50:25 * copumpkin glares menacingly at benmachine 
17:50:54 * benmachine cries
17:52:33 <peterjoel> so can anyone help me with my question? I'm looking for the repository for the platform installer
17:54:45 <Saizan> ddarius: Coroutine ~ free monad transformer is a nice concept, but all the combinators have funny types
18:05:55 <kmc> bah, hit some inscrutable Cmm parse error in building GHC
18:06:09 <kmc> apparently the solution is to make maintainer-clean and try again :/
18:06:30 <kmc> build systems: still sucking
18:06:47 <cl1> peterjoel, i think you want the info on this page http://hackage.haskell.org/trac/ghc/wiki/GettingStarted
18:07:22 <roconnor> Is it possible build a website with login/authentication without using cookies?
18:07:43 <hpc> roconnor: use 401 auth
18:08:24 <kmc> you can save data in a hidden form and arrange for each link to resubmit it somehow
18:08:55 <cl1> 401 auth is not secure
18:09:01 <roconnor> kmc: using https?
18:09:12 <kmc> oh, you didn't say good authentication.  but, yeah
18:09:27 <cl1> kmc: -_-
18:09:29 <roconnor> cl1: what about digest access authentication?
18:09:38 <parcs`> ?PHPSESSID=... :P
18:09:39 <lambdabot> Unknown command, try @list
18:09:39 <kmc> you can also make a "website" which is a single page that runs a javascript application which talks to the server by ajax or websockets
18:10:19 <roconnor> what does REST have to say about all this?
18:10:37 <mux> nothing
18:11:00 <roconnor> Digest access authentication is vulnerable to a man-in-the-middle (MitM) attack. For example, a MitM attacker could tell clients to use basic access authentication or legacy RFC2069 digest access authentication mode.
18:11:41 <mux> the only "good" authentication scheme would be to use TLS with client certificates
18:11:42 <cl1> roconnor, why are you against using a cookie?
18:11:52 <roconnor> cl1: oh hmm.
18:12:02 <roconnor> cl1: I guess I thought it was complicated
18:12:14 <ddarius> ?
18:12:15 <kmc> making a site robust to MitM attacks is pretty hard...
18:12:35 <roconnor> cl1: I have a problem with state
18:12:42 <kmc> if you care about security then you need to outline requirements, threat model, etc.
18:12:46 <roconnor> expecially in the presence of the back/forward buttons
18:13:20 <cl1> if you send the cookie on every request you do not have to maintain state on the server
18:13:50 <roconnor> cl1: what would the cookie hold?
18:13:56 <parcs`> only with sessions you have to maintain state on the server
18:14:00 <cl1> you can generate an encrypted value and store that in a cookie, then you can verify that cookie on the server by decrypting it
18:14:06 <mux> which is kinda the point of cookies; if you have state on the server, cookies aren't very useful
18:14:08 <cl1> the user only has to log in once to generate the cookie
18:14:40 <cl1> and for additional security you can stored salt with each user and add that to the encryption algo, that way one user cannot reverse engineer the scheme
18:14:51 <roconnor> cl1: so a cookie would be a signed message stating that the holder of this token is allowe to access whatever until some time?
18:14:58 <cl1> even if they do, they will have to brute force the salt
18:15:00 <irene-knapp> roconnor: what about digest authentication when using https?  is it still MitMable?  because this came up at work :/
18:15:07 <cl1> roconnor, exactly
18:15:11 <mux> roconnor: why don't you just use TLS if you really need security?
18:15:12 <roconnor> irene-knapp: ya, I'm wondering that myself.
18:15:15 <irene-knapp> ya
18:15:19 <mux> irene-knapp: nope
18:15:26 <irene-knapp> hmmm good
18:15:44 <roconnor> mux: I'm happy to use TLS, but that just authenticates me, the server;  I need to authenticate users.
18:15:56 <mux> roconnor: as I already said, use client certificates
18:16:11 <cl1> https with a valid certificate would go a long ways to helping with security as well
18:16:14 <roconnor> mux: ah I missed that message
18:16:20 <roconnor> mux: that's not a terrible idea
18:16:28 <xplat> cookie schemes are as vulnerable as digest to mitm for the short term, but it is harder to create a lasting compromise
18:16:29 <cl1> that way the client logging in could verify that the server is in fact the correct one that they are logging into
18:16:31 <roconnor> though I'm curious why most people don't use it
18:16:35 <mux> roconnor: it's rarely used, but it's the only sensible way I know of.
18:17:05 <mux> because in most cases you just want to authenticate the server; and having client certificates is more involved than having a simple login/password scheme
18:17:13 <roconnor> any of these Haskell web framework things support client certificates?
18:17:20 <ddarius> Clients don't usually have certificates.
18:17:22 <cl1> roconnor, you can store the timestamp in the encrypted cookie and refresh it on each request if you want to simulate a login timeout on the server
18:17:46 <roconnor> cl1: you mean signed cookie, not encrypted, right?
18:18:08 <roconnor> ddarius: I know that, but why not?
18:18:18 <xplat> (at least if you do the actual login over certified HTTPS)
18:18:22 <roconnor> I guess transporting client certificates from computer to computer is a pain
18:18:37 <cl1> i mean encrypted, you can sign it to verify that it has not been tampered with, but if you encrypt the cookie data you can store all kinds of information that generates a new cookie on each request
18:18:45 <ddarius> roconnor: If I want to check my GMail on your computer, I won't have my private key memorized.
18:18:58 <mux> roconnor: that and having clients generate & use a keypair plus have the server sign it is a lot more complicated than login/password
18:19:02 <cl1> the brute force necessary to crack a single cookie would generally take longer than the life of the cookie
18:19:14 <ddarius> roconnor: But, with the ubiquity of cell phones, this will hopefully change.
18:19:20 <cl1> this means that once a person has cracked that cookie, it is no longer useful
18:19:23 <mux> roconnor: but if you want to avoid MITM you want TLS anyways
18:19:39 <cl1> mux is correct
18:19:41 <roconnor> yes yes, I will use HTTPS
18:20:02 <mux> roconnor: in France, the government server used to pay your taxes uses client certificates
18:20:20 <mux> I mean, using those is not entirely unheard of
18:20:28 <roconnor> I have a client certificate for openid, and I think that is it
18:20:46 <ddarius> mux: Of course not.  The entire US military uses them.  Yay smart cards.
18:20:50 <roconnor> er, so I'm not sure what the conclusion is.
18:21:41 <roconnor> client certificates?
18:22:01 <mux> it all depends on the level of security you want to achieve
18:22:12 <mux> using a login/password scheme over HTTPS is not _that_ bad
18:23:05 <roconnor> Unfortunately I'm in the ususal akward situtation that I get to determine the security for my clients, while they are the ones who should determine how much security they want.
18:23:23 <roconnor> I guess that suggests I should impelment multiple options.
18:23:25 <mux> the major problems I see with it is that people chose stupid passwords & reuse them, and you'll have to store the passwords on the server
18:23:30 <ddarius> mux: Actually, public key cryptography would be -more- convenient as well as secure than the current scheme once the use of them becomes (more) ubiquitous.
18:23:30 <roconnor> so that users can choose
18:24:08 <mux> ddarius: except that users have to carry their certificates arounds
18:24:29 <ddarius> mux: Yes, which you do by having their certificates be on their mobile devices.
18:24:34 * mux wonders if Chrome Sync could help with that
18:24:44 <xplat> yeah, the convenience of userid-password doesn't hold up past the first 5 sites you sign up at
18:24:47 <mux> ddarius: I don't see that helping a lot
18:24:48 <ddarius> Essentially everyone always has a cell phone available.
18:24:56 <roconnor> do these haskell webframework libraries provide some of these supports?
18:25:00 <xplat> unless you reuse passwords, and then you might as well not bother
18:25:10 <mux> ddarius: it's still cumbersome and "hard" for John Doe users
18:25:16 <ddarius> mux: I agree.
18:25:19 <mux> I'm all for it though :-)
18:25:21 <ddarius> But there's no reason for that.
18:25:51 <xplat> using the same password for multiple accounts is like putting resistors in parallel
18:25:51 <roconnor> okay, for sake of argument, lets say no client certificates, but username/login
18:25:55 <ddarius> You should be able to simply press a button on your phone to respond to a challenge when a login screen comes up, much like BlueTooth pairing.
18:26:19 <ddarius> This is much less effort than typing in a password (let alone thinking up new, "good" passwords.)
18:26:31 <xplat> it makes 'a chain is as strong as its weakest link' seem like a recommendation
18:26:37 <roconnor> is the way to go is to have login generate one of these signed messages as a cookie?
18:26:58 <mux> roconnor: you don't need to maintain state with HTTPS
18:27:12 <ddarius> Resistors in parallel helps lessen the chance of failure of any one resistor.
18:27:17 <roconnor> mux: how do I avoid that?
18:28:08 <xplat> ddarius: if you do the analogy that way, it's like putting them in series
18:28:18 <xplat> putting christmas lights in series
18:29:16 <irene-knapp> okay, so, naming challenge!
18:29:22 <irene-knapp> I have typeclasses Serializable and Deserializable
18:29:38 <mux> roconnor: actually with a login/password scheme you probably still do need to maintain state, but how is that a problem exactly?
18:29:43 <irene-knapp> wait, never mind
18:29:47 <irene-knapp> my design was a bad one :)
18:30:03 <irene-knapp> I was going to ask what a typeclass encompassing both of those should be called
18:30:17 <roconnor> mux: well state = complexity
18:30:17 <ddarius> mux: Heck, using a smart card and entering a PIN is still a lot nicer than typing in a password in such environments.
18:30:37 <mux> roconnor: if you use 401 auth over HTTPS, you don't need to maintain state, the browser sends credentials with each request
18:30:42 <mux> ddarius: agreed
18:31:23 * benmachine wonders what good a type you can serialise is if you can't deserialise it
18:31:36 <xplat> maybe someone else can deserialize it
18:31:41 <kmc> libraries/integer-gmp/dist-install/build/cbits/gmp-wrappers_o_split/gmp-wrappers__1.o: file not recognized: File truncated
18:31:42 <kmc> o_O
18:31:43 <roconnor> mux: basic authentication or digest access authentication?
18:31:50 <irene-knapp> benmachine: well, not much, but the definitions needed for the typeclasses are so damn long that I wanted to split them into two files
18:31:57 <mux> roconnor: it doesn't matter since it's over TLS
18:32:13 <mux> you can just use basic auth unless I'm missing something
18:32:15 <roconnor> mux: oh good; this was my orginal idea
18:32:17 <irene-knapp> benmachine: actually!  wait a tick, I just figured something out :D I won't split them up after all
18:32:21 <parcs`> benmachine: for things like lambdabot
18:32:27 <ddarius> HTTPS makes everything better.
18:32:33 <roconnor> mux: Well, I'm not much of a web-app person; so I'm full of fear
18:32:58 <mux> roconnor: caution is good, I wish more people would be "full of fear" :-)
18:33:00 <benmachine> parcs`: that's not really serialisation in my book
18:33:07 <roconnor> so I just run happstack over HTTPS with basic authentication and I'm good to go?
18:33:08 <irene-knapp> true, it's not
18:33:15 <mux> roconnor: that sounds good to me
18:33:58 <roconnor> is happstack still a popular choice?
18:34:20 <roconnor> I have no particular preference since I have no experience
18:34:48 <ddarius> Yes, though Yesod seems the loudest right now.
18:35:01 <roconnor> I just picked happstack because acid-state looked interesting
18:35:11 <xplat> put your hands together for ... yesod!
18:35:15 <luite> you can use it without happstack of course
18:35:24 <parcs`> happstack doesn't use acid-state
18:35:25 <luite> (same that you can use persistent without yesod)
18:35:40 <roconnor> parcs`: oh?
18:35:55 <xplat> supposedly you can mix-and-match your most favorite things regardless of which framework you use
18:35:59 <roconnor> happstack acid-state in darcs now has the ability for clients to connect to a server and perform updates/queries remotely! #haskell 41 days ago
18:36:04 <xplat> for the most part, anyway
18:36:05 <benmachine> I tried to use yesod but yesod init frigtened me
18:36:07 <roconnor> xplat: likely true
18:36:23 <parcs`> roconnor: in darcs :P but happstack uses happstack-state which is the predecessor of acid-state
18:36:29 <benmachine> and after I installed ghc 7.2.2 and decided "right I will install me some dependencies"
18:36:35 <roconnor> parcs`: oh
18:36:38 <benmachine> the list was over 100 packages
18:37:10 <parcs`> roconnor: anyway it's easy to hook acid-state into any framework
18:37:29 <roconnor> parcs`: do you have a preference?
18:37:54 <luite> benmachine: hehe that;s a well-known problem, they've modified the scaffold to make it simpler, but then it also lost much flexibility. now they've added some customizability again, but it's still hard to fnd the right balance
18:38:18 <parcs`> roconnor: i would say snap + acid-state
18:38:49 <roconnor> hmm, tough choice
18:39:29 <parcs`> happstack has a really good tutorial thought
18:40:21 <benmachine> my life is made that much harder by the fact I want to deploy cgi
18:40:33 <benmachine> I've heard yesod can do this but it sounds upsetting
18:41:22 <parcs`> create your own mini framework on top of wai :P
18:45:19 <irene-knapp> instance Monad (FallibleContextualOperation failure context) where
18:45:24 <irene-knapp> ... yeahhhhh
18:45:31 <irene-knapp> I'm just the queen of clear, concise names :(
19:02:25 <ddarius> benmachine: If you mean SlowCGI, then in the absolute worst-case scenario, you can just use a handler that spawns the process and sets the environment variables and handles appropriately.
19:03:10 <benmachine> ddarius: I guess so
19:03:16 <benmachine> that sounds fairly worst-case though :P
19:04:34 <ddarius> It's one ugly function, but it's -one- ugly function.  Also, I doubt that it hasn't been done somewhere by someone.
19:05:41 <shachaf> @remember ddarius It's one ugly function, but it's -one- ugly function.
19:05:41 <lambdabot> I will remember.
19:07:24 <parcs`> benmachine: what sounds upsetting?
19:07:54 <benmachine> parcs`: mostly the 103 dependencies and a bunch of files and directories for what is essentially a very simple script
19:08:20 <benmachine> I don't think I can install 103 packages on my web server, my quota is kind of small
19:08:29 <benmachine> (I wonder if I can use acid-state with the cgi package)
19:10:45 <ddarius> benmachine: Why wouldn't you?
19:11:39 <benmachine> ddarius: use acid-state with cgi? because I don't know anything about acid-state at all, basically
19:11:55 <benmachine> since I heard lots of people say "you can use this with that" I assumed there was something special to it
19:12:12 <parcs`> benmachine: why do you want to use cgi anyway
19:13:00 <benmachine> parcs`: you mean the technology, or the package?
19:13:44 <parcs`> the tech
19:13:46 <augur> someone posted something about an AST haskell editor
19:13:53 <augur> i dont want an AST editor
19:13:58 <augur> i want an interactive editor
19:14:00 <augur> with holes
19:14:11 <irene-knapp> somebody posted something RECENTLY
19:14:14 <irene-knapp> or are you referring to mine?
19:14:17 <irene-knapp> mine is what you said
19:14:20 <irene-knapp> or rather, will be
19:14:21 <irene-knapp> someday :)
19:14:52 <augur> chrisdoner's link
19:14:56 <augur> http://www.reddit.com/r/haskell/comments/ngn2c/a_concept_for_editing_haskell_as_an_ast_rather/
19:15:25 <irene-knapp> ah, this is just a concept
19:15:28 <augur> yeah
19:15:35 <augur> but i would still prefer just type checking with hole
19:15:36 <augur> s
19:15:40 <irene-knapp> yes, agreed
19:16:00 <irene-knapp> the comments, as usual, haven't put much thought into this so the most intelligent one claims it can't possibly work :/
19:16:22 <irene-knapp> :t return
19:16:23 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:16:34 <benmachine> parcs`: seems the easiest option, my host doesn't support fastcgi
19:16:37 <benmachine> I guess I could proxy?
19:16:57 <augur> i like the idea of tree editing. its an interesting possibility. but i agree with the commenter on the need for keyboard commands for it
19:17:02 <irene-knapp> oh, for sure
19:17:02 <augur> so thatll be interesting when it happens
19:17:03 <benmachine> but I need something that's lightweight even to compile, because I can't upload binaries (because locally I have a different version of some library)
19:17:14 <irene-knapp> returnHelper :: (m a -> t m a) -> (a -> t m a)         returnHelper constructor = constructor . return
19:17:17 <augur> and i also agree with the issue about unknown extensions
19:17:18 <irene-knapp> what's wrong with this definition :(
19:17:35 <irene-knapp> well, the trick to unknown extensions is to IMPLEMENT EVERYTHING!!!
19:17:38 <irene-knapp> CODE ALL THE THINGS
19:18:26 <augur> or make syntax extensions easy to describe in a metalanguage...
19:18:27 <Saizan> irene-knapp: Monad m => ?
19:18:33 <shachaf> PUT "ALL THE THINGS" IN FRONT OF ALL THE VERBS
19:18:34 <irene-knapp> Saizan: oh, yes, hm
19:18:47 <irene-knapp> shachaf: then go ahead and REVERSE it so that it is BEHIND the verbs! :D
19:19:29 <augur> shachaf: ALL THE THINGS SAY?
19:19:36 <augur> surely you mean after all the verbs!
19:19:46 <augur> ALL THE DIRECT OBJECTS PREPOSE
19:19:52 <irene-knapp> haha
19:20:27 <shachaf> "in front" means that it comes first.
19:20:41 <shachaf> Also, I shun linguists.
19:20:55 <augur> yes shachaf
19:20:56 <irene-knapp> Saizan: hmmm, so, it's a rigid type variable can't-match thingy :(
19:21:07 <augur> "ALL THE THINGS" in front of all the verbs
19:21:07 <augur> means
19:21:09 <irene-knapp> I was hoping it was something simple.  maybe the solution is to just not try a helper.
19:21:12 <augur> "ALL THE THINGS <verb>"
19:21:27 <shachaf> Oh.
19:21:35 <shachaf> No, "in front" means it's forward.
19:21:42 <irene-knapp> um
19:21:45 <shachaf> Imagine This letter as a person looking ahead: S
19:21:45 <irene-knapp> hm
19:21:49 <irene-knapp> no, on second thought, you two fight it out
19:21:50 <augur> in text, "in front of" means to the left
19:21:58 * shachaf is done fighting.
19:22:01 <irene-knapp> that letter really does not look much like a person looking ahead.  maybe you should have tried P instead.
19:22:01 <shachaf> Especially linguists.
19:22:27 <irene-knapp> ALL THE THINGP <verb>
19:22:30 <irene-knapp> sounds like Lisp
19:22:31 <Saizan> irene-knapp: you just have to give the right type to it? or even omit the type signature
19:22:36 <irene-knapp> Saizan: oh hmmmm
19:22:46 <shachaf> Enough gnonsense.
19:22:57 <Saizan> ?type (. return)
19:22:58 <lambdabot> forall b a (m :: * -> *). (Monad m) => (m a -> b) -> a -> b
19:23:03 <irene-knapp> omitting the signature gets me errors throughout the file, I fear :(
19:23:04 <irene-knapp> hmmm
19:23:07 <irene-knapp> that's an interesting thing
19:24:11 <irene-knapp> okay, possibly doing that gets me errors throughout because I have a deeper problem.  meh.  I just wanted to define a buncha monads tersely.
19:24:12 <augur> afk
19:24:25 <irene-knapp> maybe the solution is to do it verbosely, the way I actually understand it :)
19:24:58 <benmachine> irene-knapp: paste some code?
19:25:03 <irene-knapp> sure, one sec
19:25:17 <benmachine> preferably some that is relevant to your problem
19:25:23 <irene-knapp> yes, of course
19:25:24 <benmachine> but if you haven't got that just pick any you like
19:25:28 <irene-knapp> haha yes yes
19:25:40 <benmachine> (excuse my silliness it is 4am)
19:25:43 <irene-knapp> np :)
19:25:48 <irene-knapp> helpful people are entitled to be silly :)
19:25:59 <benmachine> well I haven't been helpful /yet/ :P
19:26:25 <irene-knapp> prospectively helpful people, because I don't have KindPolymorphism yet, are only entitled to be prospectively silly
19:26:43 <irene-knapp> but I think your "but if ..." accomplishes that!
19:26:52 * kmc is building ghc-7.5.20111216 in order to have kind polymorphism
19:27:01 <kmc> seems that make -j12 is causing problems too
19:27:03 <hpaste> irene-knapp pasted “Some code, relevant to my problem” at http://hpaste.org/55414
19:27:04 <kmc> so it might take a while :(
19:27:11 <irene-knapp> eep
19:27:30 <irene-knapp> okay so as you can see I have these two classes MonadSerial and MonadContext, right
19:27:35 <shachaf> kmc: 7.5.20111216? Don't they only go to .5 after .4 is out?
19:27:37 <benmachine> right
19:27:48 <shachaf> Oh, I guess .5 is for features that didn't make it into the .4 freeze?
19:27:50 <kmc> shachaf, beats me, man.  that's what ./configure decided the version number should be
19:27:51 <conal> kmc: kind polymorphism -- sweet!
19:27:57 <kmc> ah cool
19:28:02 <parcs`> shachaf: 7.4 has been branched off
19:28:22 <irene-knapp> and what I want is for Serialization context and Deserialization context to both be monads with implementations of both those classes
19:28:40 <irene-knapp> if you're wondering, they are separate classes because I have two implementations of MonadSerial for each of them, for a total of four
19:28:45 <jmcarthur> yeah, i've been looking forward to kind polymorphism!
19:28:46 <conal> does ghc head have data kinds yet?
19:28:47 <irene-knapp> (for the two backends, which are bytestrings and files)
19:29:03 <kmc> conal, yeah, it's supposed to (haven't used them)
19:29:32 <conal> kmc: fun. :)
19:29:38 <hpaste> kmc pasted “generalized Functor?” at http://hpaste.org/55415
19:30:44 <irene-knapp> so I wanted to define this monad FallibleContextualOperation, right
19:30:46 <shachaf> kmc: Don't you need to specify kind polymorphism explicitly or something?
19:31:07 <kmc> parcs` told me it's implicit
19:31:07 <irene-knapp> and have them be synonyms defined in terms of that, but they can't be synonyms because of some reason
19:31:19 <irene-knapp> so I thought maybe newtypes but they can't be newtypes because of the existential (on "backend")
19:31:29 <Saizan> kmc: btw, there are binaries for unreleased versions too http://www.haskell.org/ghc/download
19:31:32 <irene-knapp> the reason that I want that existential is so that client code doesn't even know there's such a thing as a backend
19:31:41 <irene-knapp> so I guess what I'm doing is vaguely weird, an existentially-quantified monad...
19:32:30 <benmachine> irene-knapp: tried making them data?
19:32:44 <irene-knapp> benmachine: well, in fact that's what you see in the paste there :)
19:32:48 <benmachine> oh right yes
19:32:53 <parcs`> kmc: why not 'type Ctx f a b; fmap :: Ctx f a b => ...'
19:32:55 <irene-knapp> that's the final option so it had better work :D
19:33:00 <kmc> could do
19:33:05 <benmachine> existentials need to be data, yeah
19:33:12 <benmachine> pretty sure
19:33:12 <irene-knapp> yeah, understandably of course
19:33:20 <irene-knapp> they do, I got a specific error message about it :)
19:33:23 <benmachine> they can't have the same representation as the underlying type because that would be weird
19:33:28 <irene-knapp> right
19:33:36 <copumpkin> how about an existential with no dictionary?
19:33:47 <benmachine> copumpkin: that would be weird
19:33:49 <irene-knapp> copumpkin: wait, how does that work?  how do I do it? :D
19:33:52 <copumpkin> benmachine: not necessarily
19:33:55 <Saizan> Serialization's type doesn't match (m a -> t m a)
19:34:06 <parcs`> and i'm not sure the f in 'type f `Of` a :: *' will be kind-polymorphic
19:34:10 <irene-knapp> Saizan: yeah, but (Serialization context)'s does
19:34:13 <benmachine> copumpkin: that would be weird because it is required to be so for my argument to work
19:34:25 <irene-knapp> it's a monad with an extra parameter, ish
19:34:30 <Saizan> irene-knapp: i meant the data constructor
19:34:31 <irene-knapp> oh!  right
19:34:32 <irene-knapp> duh
19:34:39 <parcs`> i've only noticed the implicit kind polymorphism in type class parameters
19:34:39 <irene-knapp> so that's my error, actually
19:35:06 <ski> benmachine : e.g. `newtype Some p = forall a. Wrap (p a)'
19:35:19 <copumpkin> ski: does that work?
19:35:25 <ski> copumpkin : unfortunately not
19:35:30 <ski> (it ought to work, imo)
19:35:48 * benmachine tries to work out what it means
19:35:53 <kmc> yeah
19:35:59 <ski>   Wrap :: p a -> Some p
19:36:18 <kmc> how about  data Foo = forall a. Foo (a, (a -> a -> a), (a -> String))
19:36:19 <benmachine> oh right
19:36:23 <kmc> this is a little abstract data type
19:36:28 <kmc> it doesn't use type classes
19:36:40 <ski> it's only if you have constraints on the existential variable you would need `data'
19:36:41 <kmc> and the guts are a tuple, so the Foo constructor should not be needed at runtime
19:36:53 <irene-knapp> I can't tell if people are talking about my thing or about kind polymorphism haha
19:36:59 <irene-knapp> though I suspect the latter haha
19:37:05 <benmachine> irene-knapp: well, both :P
19:37:07 <kmc> i'm just talking about existentials and newtype
19:37:08 <irene-knapp> haha okay
19:37:15 <benmachine> irene-knapp: but it's a side issue not directly related to your thing
19:37:20 <kmc> parcs`, can i do explicit kind polymorphism there?
19:37:21 <irene-knapp> well, I can't compile HEAD (see #ghc), so that's moot for me :)
19:37:28 <shachaf> I hope GHC 7.6 will come with a ring of polymorphism control.
19:37:35 <irene-knapp> that would be awesome
19:37:39 <benmachine> irene-knapp: did Saizan's comment fix your problem
19:37:44 <irene-knapp> no
19:37:52 <irene-knapp> I thought it did for a glorious moment
19:38:00 <irene-knapp> then I realized I have no clue wtf the type of the data constructor is :)
19:38:09 <benmachine> Serialization?
19:38:11 <benmachine> it's
19:38:12 <benmachine> let's see
19:38:12 <irene-knapp> yeah
19:38:35 <Saizan>  :t Serialization would tell :)
19:38:42 <irene-knapp> forall backend . FallibleContextualOperation (SerializationFailure backend) context a -> Serialization context a
19:38:47 <irene-knapp> ah, true, if I comment shit to make it buildable
19:38:57 <benmachine> ...yeah that
19:39:02 <irene-knapp> wait, or copy-paste into a new file, this depends on other files so I'd better do that
19:39:04 * benmachine just wrote all that out >:\
19:39:07 <benmachine> :P
19:39:07 <irene-knapp> aw :/ sorry
19:39:15 <benmachine> you and your descriptive names
19:39:19 <irene-knapp> yes haha!
19:39:25 <irene-knapp> IreneCodeWriterKnapp
19:41:13 <copumpkin> ski: I might make a ticket for it
19:42:19 <Saizan> anyhow i think it's hopeless to try to make (Serialization context) a Monad
19:42:35 <irene-knapp> Saizan: really?  hmmm.  unfortunate if so!
19:42:42 <irene-knapp> I mean StateT does a similar trick!
19:42:47 <Saizan> because of (>>=)
19:42:58 <irene-knapp> but I like
19:43:03 <irene-knapp> well I haven't gotten the whole file to compile yet
19:43:08 <irene-knapp> but I think I've gotten that part to work
19:43:15 <irene-knapp> or at least, to typecheck, haha
19:43:44 <irene-knapp> hold on, I'll paste the instance definition of
19:43:54 <irene-knapp> Monad (FallibleContextualOperation failure context)
19:43:56 <Saizan> in (m >>= f) you won't be able to deduce that the backend quantified in m is the same as the backend quantified in the result of f
19:44:01 <irene-knapp> oh, I already did
19:44:06 <irene-knapp> see line 28
19:44:11 <irene-knapp> hmmmm
19:44:15 <Saizan> so you won't be able to use the FallibleContextualOperation failure context instance
19:44:16 <cl1> what kind of database support does haskell have? (i'm thinking vendors, not a lib I can write a driver for)
19:44:18 <irene-knapp> that sounds like a problem I might have at some point yes heh
19:45:02 <irene-knapp> hmmmm
19:45:12 <irene-knapp> yeah indeed, I actually am receiving that error now
19:45:13 <irene-knapp> hmm
19:45:16 <ski> copumpkin : ok
19:45:20 <copumpkin> ski: oh, it's already there
19:45:20 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/1965
19:45:22 <parcs`> kmc: i just checked and indeed kind polymorphism happens there
19:45:38 <ski> oh
19:45:40 <parcs`> i don't think it's possible to do explicit kind polymorphism
19:46:06 <irene-knapp> okay, so I can't use FallibleContextualOperation as an abstraction here.  Saizan, do you think I can basically manually inline its semantics into Serialization and Deserialization and then make the Monad (Serialization/Deserialization context) instances work?
19:46:20 <irene-knapp> or do you think that will run into the same problem?
19:46:24 <parcs`> unfortunately your code doesn't compile
19:48:00 <Saizan> irene-knapp: that could work
19:48:08 <copumpkin> ski: wanna chime in? they closed it and asked people to chime in if they had reason to care :)
19:48:12 <irene-knapp> Saizan: okay, good :) thanks!
19:48:20 <irene-knapp> I shall doubtless report back when it doesn't :)
19:48:43 <Saizan> irene-knapp: another option would be to change Serialization slightly
19:48:48 <irene-knapp> oh?
19:48:49 <benmachine> in the meantime I will go to bed having not been useful after all
19:49:05 <irene-knapp> benmachine: it's okay - your not-ultimately-justified silliness is forgiven!
19:49:11 <irene-knapp> and night~
19:49:14 <copumpkin> irene-knapp: you might want to chime in too since you do actually have an application I think?
19:49:17 <benmachine> woo :) night, good luck
19:49:25 <irene-knapp> copumpkin: oh, probably!  what am I looking at?
19:49:30 <Saizan> data SomeSerializationFailure = forall backend. Some (SerializationFailure backend)
19:49:30 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/1965#comment:5
19:49:31 <copumpkin> that
19:49:35 <ski> copumpkin : well, i'd have to figure out some larger useful application
19:49:43 <irene-knapp> ah, looking!
19:50:00 <irene-knapp> Saizan: oh hmmmm, interesting thought, hmmm
19:50:02 <Sgeo> http://hackage.haskell.org/packages/archive/ftphs/1.0.7/doc/html/src/Network-FTP-Client.html
19:50:19 <irene-knapp> copumpkin: oh!  you were like discussing my thing!  well, yeah :)
19:50:25 <Saizan> data Serialization context a = Serialization { serializationOperation :: FallibleContextualOperation SomeSerializatioFailure context a }
19:50:26 <Sgeo> Would anything bad happen if I just deleted all instances of unsafeInterleaveIO then uploaded it?
19:50:38 <Sgeo> I'm really tempted to do so
19:50:54 <Sgeo> (Well, relocate it to Network.FTP.Client.Strict or something)
19:51:24 <copumpkin> mokus: your stackoverflow question suggests you too were interested in this at some point :)
19:51:24 <irene-knapp> copumpkin: writing something up for it now
19:51:27 <ski> (copumpkin : since i suspect the argument "it makes sense" wouldn't be enough)
19:51:45 <Saizan> irene-knapp: see my two previous lines, in case not prepending your nick made you miss them :)
19:51:54 <irene-knapp> Saizan: it did lol, looking
19:52:08 <irene-knapp> Saizan: oh, fascinating :)
19:52:15 <cl1> if haskell has been around for 19 years, and its so powerful, why isn't it used everywhere?
19:52:29 <cl1> its like people think functional programming has cooties or something
19:52:35 <jmcarthur> that's basically it
19:52:44 <irene-knapp> Saizan: I think I'll do the manual-inlining though, because actually, the thing is that writing these monad and related instances is going to be a vegetarian pita with fresh bean sprouts and involve the same work as inlining anyway
19:52:53 <copumpkin> cl1: oh, I have an answer for you
19:53:06 <copumpkin> cl1: http://www.paulgraham.com/avg.html
19:53:11 <copumpkin> djahandarie was annoyed by it
19:53:16 <copumpkin> but it had some good points
19:53:21 <irene-knapp> okay, so in trac, how do I introduce a blockquote of pre-wrapped text?
19:53:24 <irene-knapp> oh
19:53:26 <irene-knapp> there's a handy link
19:53:27 <irene-knapp> nm :)
19:53:42 <Saizan> copumpkin: you'd want something like newtype Foo a where Bar :: X -> Foo Y ?
19:53:58 <copumpkin> Saizan: not that
19:54:11 <copumpkin> that'd make sense too, but I can see why that'd be trickier
19:54:23 <copumpkin> Saizan: just newtype Foo f where Foo :: f a -> Foo f
19:54:27 <shachaf> copumpkin: That's the article that says "no one is able to understand that there are languages more expressive than their favourite language, and, by the way, my favorite language is *actually* the most expressive you can get", right?
19:54:40 <copumpkin> shachaf: yeah
19:54:46 <copumpkin> shachaf: he still makes some good points
19:54:59 <shachaf> Yep.
19:55:15 <copumpkin> he's also all about "dynamic languages are the pinnacle of programming"
19:55:15 <shachaf> I've always found that part of it rather amusing, though.
19:55:18 <copumpkin> in several of his articles
19:55:19 <Saizan> copumpkin: mine would almost surely lead to unsoundness, yours doesn't seem to use much about GADTs
19:55:21 <Sgeo> WTF
19:55:22 <copumpkin> but I gloss over that shit
19:55:23 <Sgeo> WTFWTFWTF
19:55:42 <copumpkin> Saizan: oh, in my example I meant that f would be instantiated to a GADT
19:55:44 <Axman6> FTW?
19:55:53 <Saizan> copumpkin: ah, i see
19:56:06 <copumpkin> Saizan: so it'd just be a lightweight way to hide a GADT value with indices
19:56:08 <Sgeo> The person who made ftphs is apparently a co-author of Real World Haskell
19:56:18 <copumpkin> in fact
19:56:27 <copumpkin> data Exists f = forall a. Exists (f a)
19:56:29 <Axman6> Sgeo: so?
19:56:34 <Saizan> yeah, a cheap exists
19:56:41 <copumpkin> that could be a newtype
19:56:55 <ski> Saizan : unsoundness, how ?
19:57:23 <Sgeo> Axman6, until now, I was berating ftphs for using ill-conceived lazy IO
19:57:31 <shachaf> copumpkin: What if you parameterized it with a context with the new GHC?
19:57:36 <copumpkin> does anyone know of someone constructing a standard Data.Map-like thing using fingertrees? I'm getting tired of writing annoying splits + joins
19:57:45 <copumpkin> shachaf: then it certainly couldn't be a newtype
19:57:46 <Saizan> ski: i could cast anything to Y without bumping into a bottom
19:58:18 <ski> how ?
19:59:09 <Axman6> Sgeo: it's probably pretty old, from the time before people knew better
19:59:12 <copumpkin> ski: normally unsafeCoerce on newtypes is supposed to be safe, but here it would introduce a coercion of something else
19:59:29 <copumpkin> which could be completely unrelated to the payload of the newtype
19:59:31 <Saizan> ski: cast :: x -> Foo x -> Y; cast x (Bar _) = x; -- this would typecheck if matching on Bar does the refinement you'd expect from a gadt
19:59:44 <irene-knapp> copumpkin: okay, so I commented on that ticket.  thanks for calling my attention to it!
19:59:52 <Saizan> ski: now since the match on Bar is actually irrefutable, use \x -> cast x undefined
20:00:06 <ski> Saizan : yeah, so i think here we rather want something like `newtype {Foo Y0 = FX X0; Foo Y1 = FY X1}
20:00:32 <copumpkin> irene-knapp: thank you!
20:00:33 <ski> Saizan : i.e., to be able to match on `FX x' we must already know the type is `Foo Y0'
20:00:45 <Saizan> ski: yeah
20:01:12 <Saizan> but we already have that with type families + a wrapper
20:01:16 <ski> (i think this kind of closed-type functions could be useful)
20:01:33 <ski> (s/closed-type functions/closed type-functions/)
20:01:41 <ski> type families are open
20:01:59 <Saizan> we all want closed type families :)
20:02:15 <copumpkin> especially now that we have custom closed kinds
20:02:19 <copumpkin> it'd be a lot easier
20:02:22 <copumpkin> conceptually at least
20:02:52 <copumpkin> if I have a type family take takes a type of kind Nat
20:03:13 <copumpkin> it's not that hard to make sure it's closed :P
20:04:42 * ski would like to play with definitions like `newtype k (Flip f b a) = MkFlip (k (f a b))'
20:04:58 <irene-knapp> f.a.b. ulous
20:05:11 <Saizan> what you want additional support for is overlapping patterns, for a start
20:05:27 <ski> hm ?
20:05:49 <copumpkin> ordered type instances?
20:06:35 * ddarius practices Dsus4 position.
20:07:06 <Saizan> yeah, once they are closed you can just check the patterns in order like normal functions
20:07:54 <ski> "they" ?
20:08:09 <Saizan> type families
20:08:57 <ski> oh, you mean permitting overlapping type patterns for (closed) type functions ?
20:09:11 * ski isn't sure that's a good idea
20:09:18 <Saizan> yeah
20:09:36 <ski> say
20:09:51 <ski>   type UnMaybe (Maybe a) = a
20:10:00 <ski>        UnMaybe        a  = Maybe a
20:10:10 <Axman6> > let xs = map fromIntegral xs in xs
20:10:14 <lambdabot>   mueval-core: Time limit exceeded
20:10:56 <ski> now, let's say we're looking at `UnMaybe (f a)' -- to know how this reduces, we need to know that either `f = Maybe' or that 'f =/= Maybe'
20:11:14 <ski> so, we need a way now to talk about type inequalities in the type system
20:12:33 <Saizan> it's pretty similar to how you decide which constructors are relevant when pattern matching on a value of a gadt type
20:13:48 <ski> but in the GADT case, after matching on the data constructor, we know which instantiations of the type variables to make. here there's nothing similar
20:14:38 <Sgeo> I sent this email
20:14:38 <Sgeo> http://pastie.org/private/zjkg6rkhdfetjyq49gytw
20:14:47 <Saizan> in the GADT case when you match on G X you refute all the constructors whose return type doesn't unify with G X
20:16:25 <ski> yeah, but in the above case, `UnMaybe a = Maybe a' really means `UnMaybe a | (not exists b. a = Maybe b) = Maybe a' -- i don't see how there's any similar negation in GADTs
20:18:13 * ddarius wants Am#5.
20:19:01 <xplat> with a closed domain you can macro away the overlaps
20:19:20 <Saizan> yeah, but a closed domain is a pain
20:19:29 <xplat> you know if it's not X it's Y, Z, or W
20:19:39 <xplat> Saizan: not for datakinds
20:19:56 <xplat> since they're closed to begin with
20:20:11 <Saizan> ski: when i'm not allowed to match on a gadt constructor because of its type, isn't there a negation going on there?
20:20:26 <xplat> and overlap on an open domain gets you all kinds of dwarf fortress-style Fun
20:20:43 <The_Journey> just a question, how does one implement dynamic data structures like binary tree if Haskell does not allow state modification?
20:20:49 * Saizan never played dwarf fortress
20:20:53 <cl1> copumpkin, good article, thanks
20:20:53 <irene-knapp> you what!
20:21:01 <irene-knapp> play it! :D
20:22:39 * ddarius has also never played dwarf fortress.
20:23:26 * cl1 googles dwarf fortress
20:23:27 * ski has no idea what kind of game DF is
20:23:47 <xplat> look for the dfwiki entry on Fun
20:24:44 <xplat> not only will that explain my reference, it's a good introduction to the spirit of the game
20:25:52 <cl1> i no has time for games
20:26:05 <cl1> i must be learning me a haskell for greater good
20:26:16 <passerby> http://community.haskell.org/~ndm/darcs/hlint/hlint.htm claims you can ignore module hints like this: {-# ANN module "HLint: ignore Eta reduce" #-}; but it doesn't seem to recognize it. Any ideas?
20:26:32 <Saizan> xplat: do you have a tldr?:)
20:26:35 <xplat> yeah, but you have time to google games
20:26:46 <xplat> so at least read the right page :P
20:27:08 <shachaf> ghci takes 6 seconds to start. :-(
20:28:09 <irene-knapp> the tldr is "Losing is fun!"
20:28:11 <shachaf> It might have something to do with the 68 imports in my .ghci.
20:28:22 <ski> Saizan : i don't think it's similar, if you have `data UnMaybe :: * -> * where A :: a -> UnMaybe (Maybe a); B :: Maybe a -> UnMaybe a', then if you have `x :: UnMaybe (f a)', then you will have `case x of A y -> ..y..; B z -> ..z..' with `f = Maybe',`y :: a' in the first branch and `z :: Maybe (f a)' in the second branch
20:28:39 <ski> Saizan : nowhere does a `f =/= Maybe' constraint enter the picture
20:29:27 <xplat> and so by symmetry, ...
20:30:06 <Sgeo> Based on what someone else said in here a while ago, I think I could fix ftphs without removing laziness
20:30:18 <Sgeo> Just force evaluation of the previous FTP command when the next command is done
20:30:37 <ski> (that might have been me)
20:30:50 <ddarius> Sgeo: Is the author John Goerzen?
20:30:55 <Sgeo> ddarius, yes
20:31:07 <ski> <http://hackage.haskell.org/packages/archive/ftphs/1.0.7/doc/html/src/Network-FTP-Client.html> says so, yes
20:31:25 <kmc> " Type indexes must match class instance head, Found `k' but expected `k' "
20:31:44 <ski> nice :)
20:31:49 <xplat> your other k
20:31:57 <Saizan> ski: yeah, but suppose x :: UnMaybe (Either () a), why would your case statements fail to typecheck?
20:32:07 <Saizan> *expression
20:32:14 <augur> Saizan: Unmaybe? lol
20:32:15 <augur> what
20:32:34 <ski> augur : just a silly example
20:32:37 <xplat> shouldn't that be ToggleMaybe anyway?
20:32:51 <ski> (xplat : possibly)
20:33:15 <ski> Saizan : i'm not sure it should fail to typecheck
20:33:38 <ski> (in the `data' GADT case)
20:34:04 <Sgeo> I'm thinking IORef (IO ()) that sorts an IO action that would force the value
20:34:18 <Sgeo> Store it in whatever data structure the ftp connection is stored in
20:34:22 <ski> Saizan : i.e., i don't think it would be a problem if it type-checked. but pragmatically one might want to disallow it, since it's probably not that useful
20:34:23 <Sgeo> *stores
20:34:33 <augur> oi, xplat
20:34:49 <Sgeo> At the end of every IO action that gives a lazy result, store the action
20:34:58 <Sgeo> And at the beginning, force whatever's in there
20:35:21 <hpaste> irene-knapp pasted “As a self-contained and very short module now” at http://hpaste.org/55416
20:35:27 <ski> (Saizan : of course, removing the `A y -> ..y..' branch, it should certainly typecheck)
20:35:33 <irene-knapp> okay so as I read the type error in the above paste
20:35:35 <Sgeo> There will still be lazy IO, to, say, not make dealing with large files painful, but they won't step on eachother's toes FTPwise
20:36:29 <irene-knapp> it's saying that the return types of the first and second parameters to "bind" aren't the same
20:36:33 <irene-knapp> but they aren't supposed to be the same!
20:36:39 <irene-knapp> what did I do wrong that makes it think they have to?
20:36:57 <ski> Sgeo : just make sure that forcing the earlier results from `unsafeInterleaveIO' later will just fetch the cache, instead of trying to perform the I/O again
20:37:04 <robinbb> @type map
20:37:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:37:12 <robinbb> @type fmap
20:37:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:37:19 <Saizan> ski: in any case, the criterion would a type inequality (some version of GHC used to error out on those cases, but not 7.2.1, Agda does)
20:37:25 <Sgeo> ski, o.O
20:37:35 <Sgeo> Why would it try to perform the IO again?
20:38:16 <ski> Saizan : yeah, but here the inequality is concrete : we only have to consider it when we know both types -- i'm not sure the same would hold in the other case
20:39:08 <ski> Sgeo : i'm not sure whether it would. just something to check
20:39:24 <ski> s/check/look out for/
20:41:03 <Sgeo> I don't know enough about unsafePerformIO to understand that that can happen
20:41:06 <Sgeo> Or how
20:41:12 <Sgeo> Erm, unsafeInterleaveIO
20:42:26 <Saizan> irene-knapp: failure@(Left _) -> return failure
20:42:28 <peterjoel> hi, any ideas why leksah can't find Control.Monad.Error, while I can load that in GHCi?
20:42:35 <ski> irene-knapp : replace `failure@(Left _) -> return failure' with `Left str -> return (Left str)' ?
20:42:42 <irene-knapp> hmmmmm!
20:42:58 <irene-knapp> now it compiles
20:43:00 <irene-knapp> thanks, both of you :D
20:43:08 <ski> it's the same issue as in
20:43:14 <ski> @src Either (>>=)
20:43:14 <lambdabot> Left  l >>= _ = Left l
20:43:14 <lambdabot> Right r >>= k = k r
20:43:18 <irene-knapp> hmmm okay
20:43:21 <irene-knapp> yeah, I suppose it is
20:43:28 <ski> where saying `e@(Left _) >>= _ = e' doesn't work
20:43:51 <ski> (and i hope you see why, now)
20:43:57 <irene-knapp> yes, I do now
20:44:00 <augur> anyone know of some examples of using shapely functors in haskell?
20:44:10 <irene-knapp> I'm a shapely functor!
20:44:11 <ski> "shapely functors" ?
20:44:37 <irene-knapp> sorry, no clue
20:44:38 <augur> or shapely types, rather
20:44:46 <augur> or more generally, container types
20:50:04 <ski> augur : "Container Types" <http://sneezy.cs.nott.ac.uk/containers/blog> ?
20:52:27 <augur> ski: yes well
20:54:58 * ski isn't sure what augur is looking for
20:55:10 <augur> container types in haskell!
20:55:18 <augur> just some examples of using them in haskell
20:55:24 <ski> and what do you mean by "container types" ?
20:55:30 <augur> separation of shape from content
20:55:36 <cl1> shapely? are we starting to get a little too attached to our programming language?
20:55:41 * cl1 chuckles
20:55:58 <ski> augur : you mean like `Tree [Int]', then ?
20:56:19 <irene-knapp> cl1: try to keep up, I made that joke more sexily a page ago
20:56:47 <cl1> bah i'm chatting in lisp too, those peeps are quiet
20:57:03 <kmc> engage troll powers
20:57:07 <irene-knapp> haha
20:57:16 <cl1> that article copumpkin posted made me go ask some questions about lisp
20:57:16 <augur> ski: well, it works best in a dependent setting of course, where its something like Sg Tree \ t -> Pos t -> A
20:57:21 <irene-knapp> that would be a cute trick
20:57:22 <irene-knapp> you like
20:57:24 <augur> i think thats roughly how its supposed to look
20:57:30 <irene-knapp> join two channels of languages with opposing design decisions
20:57:40 <irene-knapp> and start paraphrasing them at each other, without telling them that's what you're doing
20:57:43 <cl1> they said haskell is king of static and CL is king of dynamic, so i left happy having chose haskell to learn functional programming
20:57:48 <augur> but obviously in haskell you would just have (Tree, Pos -> a)
20:57:49 <augur> or something
20:58:07 <augur> irene-knapp: hey, stop revealing my secrets!
20:58:22 <irene-knapp> augur: haha!
20:58:22 <cl1> LMAO
20:58:53 <Sgeo> cl1, I'd think Picolisp is the king of dynamic
20:59:40 <cl1> Sgeo, i'm not splitting hairs, i should have just said lisp in general
20:59:56 <ski> augur : where `Sg Tree \ t -> ..t..' is `(t : Sg Tree) -> ..t..' ?
21:00:06 <Sgeo> Although hmm
21:00:16 <Sgeo> Picolisp primitives aren't written in terms of picolisp
21:01:38 <augur> ski: er.. no. Exists(t : Tree)(... t ...)
21:01:45 <augur> its just a dependent pair, really
21:01:59 <augur> cmon ski, youre in #agda
21:02:07 <augur> you know what Sg Tree \ t -> ...t... means!
21:12:44 <ski> augur : oh, a lambda. i was initially thinking `\' was an ordered implication (like in `np \ s / np')
21:13:01 <augur> lol :)
21:13:11 <augur> too much CG on the brain!
21:13:29 <cl1> cg?
21:13:37 <ski> Categorical Grammar
21:13:45 <ski> (no relation to category theory)
21:13:52 <cl1> omg, moar stuff to learn
21:13:57 <augur> ski: lambek would beg to differ!
21:14:06 * ddarius wonders if poor communication skills is what motivates some linguists to enter the field.
21:14:10 <cl1> my brain hurts already
21:14:19 <ski> augur : well, no *immediate* relation, at least :)
21:14:27 <augur> ski: lambek woul-- oh forget it :P
21:14:40 <augur> ACGs are just CCCs!
21:14:55 <augur> thats actually kind of why i like ACGs a little bit
21:15:04 <augur> they say ahh fuck it, its just LC all the way down
21:15:28 <mjrosenb> ACG,CCC?
21:15:42 <ski> (at least afaic, categorical grammar had no connection with category theory initially, which was what i was after here)
21:15:50 <ddarius> It's just the simply typed lambda calculus with pairs and constants all the way down?
21:16:00 <ski> presumably "CCC" is "Cartesian Closed Category", here
21:16:03 <augur> mjrosenb: ACG = abstract categorial grammar
21:16:08 <augur> what ski said about CCC.
21:16:31 <augur> ddarius: that too
21:17:23 <ski> (augur : or are you claiming the term "Categorical Grammar" had a relation to category theory, from its inception ?)
21:17:45 <augur> no im not :P
21:17:53 <ski> ok, fine :)
21:17:53 <augur> categorial, no c
21:17:55 <augur> well
21:17:56 <augur> one c
21:18:46 <ski> (i'm not disputing that people manage to find connections to category theory for almost anything. i was only talking about the term itself)
21:18:55 * ski anyway isn't sure what `Sg' is exactly
21:18:58 <kmc> cl1, i wouldn't call Haskell "king of static"
21:19:16 <kmc> maybe Haskell + all the wacky GHC extensions is
21:19:18 <ddarius> Yeah, I mean come on, Haskell has dynamic allocation.
21:19:21 <augur> ski: sigma
21:19:38 <ski> ah, ok
21:19:41 <cl1> what would be the king of static then?
21:20:00 <kmc> shrug
21:20:08 <kmc> i think it's hard to arrive at a strict ordering
21:20:15 <augur> cl1: agda!
21:20:19 <augur> agda is pretty static
21:20:27 <ski> cl1 : dependent types
21:20:34 <augur> ski: so, agda
21:20:45 <ski> well, there's also Coq and Twelf
21:21:01 <augur> pfft
21:21:06 <kmc> standard Haskell and standard ML are pretty similar in terms of "static" and what you can verify at compile time
21:21:19 <augur> coq, pfft.
21:21:24 <mm_freak> kartesian klosed kategory
21:21:25 <augur> coq be damned!
21:21:28 <kmc> then there are a whole bunch of other reasons why one or the other would be better to learn
21:21:46 <ski> yeah (though SML doesn't have higher-order types -- but it does have a cool module system)
21:21:59 <kmc> cl1, why did you decide you want to learn FP by learning a very static functional language?
21:22:39 <cl1> i didn't know it was static, i picked it because everyone said the learn you a haskell was the easiest introduction to functional programming
21:22:45 <ski> cl1 : i would suggest learning Scheme (including hygienic macros and continuations) before diving too deep into CL
21:22:47 <kmc> ski, what do you mean by higher-order types?  type constructors which take other type constructors as parameters?
21:22:58 <kmc> Haskell is really an unusual functional language
21:23:02 <cl1> i tried learning f# and when i got to monads .. well lets just say it wasn't pretty
21:23:07 <ski> kmc : yes (or take other type functions as arguments)
21:23:19 <ddarius> It's unusually strange by virtue of being a functional language.
21:23:28 <cl1> ski: i will be writing a scheme interpreter when i get done with this learn you a haskell tutorial
21:24:00 <mm_freak> cl1: F# doesn't have monads on a level where haskell has them
21:24:18 <mm_freak> F# doesn't really support monads, it rather supports do-notation
21:25:12 <kmc> Haskell is a good first functional language because it has lots of libraries, an active and helpful community, good implementations, good books online, etc.
21:25:27 <jessopher> and will ruin your for the rest of fp
21:25:27 <ski> cl1 : btw, iirc, "Write Yourself a Scheme in 48 Hours" doesn't implement a scheme in the sense of e.g. R5RS -- just something vaguely Scheme-like
21:25:58 <ddarius> ski: Most people who "write a Scheme" don't implement R5RS but just something vaguely Scheme-like.
21:25:58 <mm_freak> and the implementation is rather messy…  they introduce language features (currying in particular) and don't use them in their own abstractions
21:26:00 <ski> mm_freak : because of lack of higher-order types, yes ?
21:26:24 * ski tries to recall whether that tutorial even get proper tail recursion right
21:26:25 <kmc> the language itself is not so suitable for FP beginners but I think the other stuff I listed makes up for it
21:26:34 <mm_freak> ski: F# has the problem all .NET languages have:  polymorphism is only allowed for types of kind *
21:26:41 <mm_freak> Monad needs * -> *
21:26:52 <cl1> well i need to learn compiler theory, and read that its much easier to implement with functional programming languages, that is why i'm so focused on learning FP in general
21:27:00 <kmc> yeah
21:27:06 <kmc> Haskell is a great language for writing compilers
21:27:15 <ski> mm_freak : ok, i see. but is it possible to parameterize over types of higher kinds (i suspect not) ?
21:27:22 <cl1> so i'm on the right track then
21:27:28 <mm_freak> ski: no, that's precisely the problem
21:27:30 <kmc> (but so are the ML family)
21:27:34 <mm_freak> you can't even write a generic mapM in F#
21:27:43 <mm_freak> (or C# or VB or … for that matter)
21:28:10 <cl1> generic being the key word there
21:28:12 <mm_freak> not to say that F# isn't a major improvement over all other .NET languages, of course
21:28:17 * ddarius writes all his monads in VB.
21:28:20 <ddarius> mm_freak: It isn't.
21:28:45 <ski> ddarius : i think one should do proper tail recursion, continuations, and lexically scoped syntax at least
21:29:09 <mm_freak> ddarius: what's your reasoning?  at least F# gives you a much better information/source code length ratio
21:29:19 <ski> mm_freak : well, polymorphism is distinct from (but related to) parameterized types ..
21:29:30 <cl1> kmc, why is it not so suitable for FP beginners?
21:29:43 <mm_freak> ski: sure, hence the mapM example
21:30:05 <mm_freak> problem is:  you get bind and return, but you don't get Monad
21:30:22 <mm_freak> no monad transformers, no contained effects, no genericity, etc.
21:30:47 <ski> yeah, i know :)
21:30:58 <ddarius> mm_freak: ML syntax is fugly.  F# is a fairly bastardized O'Caml.  The .NET framework isn't really a good match to F#.
21:31:02 <ski> (been there, tried to do that, in ML)
21:31:12 <cl1> this is whyI ask these questions, this stuff is relevent to my interests
21:31:19 * ski doesn't think ML syntax is that bad
21:31:28 <mm_freak> ddarius: do you say that knowing that F# has a "lightweight" syntax resembling haskell?
21:31:29 <kmc> cl1, Haskell makes you learn a lot of new things: lazy evaluation (and the alien space/time behavior of lazy programs), static types, type classes, IO as an embedded language, etc.
21:31:40 <kmc> these are mostly good things but it's a lot to take in at once
21:31:55 <kmc> none of that is core to the ideas of "functional programming"
21:32:02 <cl1> kmc .. that's no joke
21:32:22 <mm_freak> ddarius: you are right about the .NET stuff though…  the .NET library is not really functional, so they add an F#-specific library for all that
21:32:24 <cl1> i had a bit of trouble with several items in that list
21:33:04 <ddarius> mm_freak: I'd be extremely amazed if they replicated the entire .NET Framework in a more F#-friendly interface, let alone the assemblies outside of the Framework.
21:33:36 <ski> (mm_freak : what you can do is make a functor that takes a monad as input, and returns e.g. `mapM' for that monad as output -- however this generates new code each time (and can only be done statically (modulo dynamic functor instantiation extensions)), instead of just reusing the same polymorphic code)
21:33:39 <mm_freak> ddarius: i don't think they are going to do that, but they replicated data and control structures pretty completely
21:33:42 <kmc> cl1, so maybe it's better to start with Scheme or ML.  i honestly don't know
21:33:57 <cl1> kmc .. i'm in too deep now
21:34:28 <kmc> sure, I'm not saying you should switch tracks
21:34:32 <mm_freak> ski: i tried it…  it works, but is very ugly…  you have to use downcasting and all that
21:34:39 <kmc> but you asked why Haskell is not so suitable for FP beginners
21:34:43 <mm_freak> the code is a horrible mess
21:34:50 <ski> mm_freak : huh ? -- i'm not sure what you mean
21:34:51 <cl1> kmc .. you make good points
21:34:59 <ski> mm_freak : no subtyping should be needed here
21:35:30 <mm_freak> ski: then how did you mean it?  remember that an F# "monad" is actually a value and that the RTTI is significant
21:35:57 <cl1> rtti?
21:36:03 <mm_freak> run-time type information
21:36:05 <cl1> ah
21:36:19 <ddarius> mm_freak: Most of my issues with the .NET environment have to do with the libraries (though the .NET Framework itself isn't -too- bad.)  Most of the things F# could have provided over C# were incorporated into C# before F# was released.  At best, F# is somewhat etter than C#.  It's not a major improvement though.
21:36:38 <ski> mm_freak : i meant making a functor (module function) that takes a module containing a type `m' with `unit' and `bind' on it, and returns a module containing the `mapM' (and possibly more utilities) for that `m'
21:36:59 <mm_freak> ddarius: oh well, F# still introduces algebraic types and proper TCO
21:37:08 <mm_freak> that alone makes a major improvement
21:37:10 <Axman6> bleh, is is ScopedTypeVariables that's supposed to let you do things like foo :: .. b .. foo = ... x :: b ..?
21:37:20 <Axman6> because it's not working for me at the moment
21:37:23 <kmc> Axman6, yes, but you have to put a 'forall' on that b
21:37:33 <Axman6> ah, thanks
21:37:50 <mm_freak> ski: ah, i wouldn't know how to do that in F# though
21:38:32 <ski> mm_freak : afaik, F# is more or less O'Caml with some things tacked on. so module functors should presumably be possible (i'm not sure what the syntax is, though)
21:38:44 <ddarius> My understanding is that the 64-bit CLR always did TCO.  Algebraic data types are notable.  Every now and then I encode them in C#, but for most of what I do, I haven't really missed them.
21:38:58 <ddarius> ski: F# doesn't have any of ML's module system.
21:39:02 <mm_freak> i don't know ocaml either (except that it has ugly syntax)
21:39:03 <ski> ah, ok
21:39:18 * ski is more familiar with SML than with O'Caml
21:39:34 <mm_freak> ski: note that F# is really a scripting language
21:39:41 <ski> (but both of those has this module system with module functors)
21:39:49 <mm_freak> it contains commands, not definitions
21:39:53 <kmc> the sheer amount of activity in the Haskell universe means there are a lot of resources, and overall makes it more fun to learn
21:40:03 <kmc> i think this makes up for the fact that learning FP by learning Haskell is jumping into the deep end
21:40:30 <mm_freak> ddarius: a trivially tail-recursive function in C# blows the stack…  at least it did for me when i was using it (2009)
21:40:33 <ski> mm_freak : hm, how does that work with static typing ?
21:40:36 <cl1> this room has certainly made it easier
21:40:37 <kmc> but of course many people try and don't get very far
21:40:39 <mm_freak> perhaps they have improved it now
21:40:49 <ddarius> mm_freak: There is a 32-bit CLR.
21:40:50 <kmc> so it evidently doesn't do it for them
21:41:07 <cl1> c# doesn't have TOC, it can't
21:41:08 <mm_freak> ski: no problem with that…  defining types is also a command
21:41:29 <ski> mm_freak : yeah, but i wondered how the scoping would work then
21:41:34 <cl1> or more appropriately it is not allowed
21:41:56 <mm_freak> ski: like in C:  from top to bottom first define, then use
21:41:57 <ddarius> cl1: Why and where is it disallowed?
21:42:16 <mm_freak> ski: for mutually recursive things you need to use special keywords, which i don't remember
21:42:20 <mm_freak> i think it was 'let' and 'and'
21:42:30 <kmc> that's like ocaml then
21:42:31 <cl1> I don't know where specifically, but some stuff in the language standard prevents it. That was what I was told.
21:43:17 <ski> mm_freak : i'm not convinced this is actually commands rather than declarations
21:43:42 <mm_freak> ski: microsoft sells F# as a scripting language
21:44:04 * ski isn't really sure what "scripting language" means ..
21:44:08 <cl1> mm_freak: ms sells F# as a multi-paradigm language
21:44:12 <mm_freak> i think the main indicator is that you don't have any main function or anything
21:44:22 <mm_freak> you just write expressions in the top level
21:44:31 <kmc> one problem in F#, Scala, etc. is that, sure, you have access to all these .NET or JVM libraries, but their APIs are designed around objects with pervasive mutation, so you can't use them cleanly from functional code
21:44:32 <ski> mm_freak : well, that is irrelevant
21:44:42 <ski> it's the same in SML and O'Caml
21:44:47 <kmc> i'm wondering how much of a problem this is in practice, and how it factors into ddarius's opinion that F# doesn't improve much on C#
21:45:06 <cl1> mm_freak .. where are you getting this information. you can specify any function as the main function in an f# application
21:45:16 <ddarius> cl1: The CLR has a tailcall opcode and as far as I'm aware there are people having "issues" with their C# code being TCO'd.
21:45:32 <mm_freak> ski: to have /some/ definition of "scripting language" i'd say that their key property is that they contain commands executed from top to bottom and any additional structure is added by the programmer
21:45:54 <ddarius> I've never heard anything that says C# can't optimize tail calls.  There may be some residual back in the days where they thought "stack inspecting security" made tail calls impossible.
21:46:02 <ddarius> (for Java)
21:46:07 <ski> mm_freak : yeah. i'm just not convinced this really applies to F# :)
21:46:15 <mm_freak> cl1: sure you can, but importing modules will execute the top level code
21:46:33 <kniu> so what's the news on the Haskell LLVM package and LLVM 3.0?
21:46:37 <mm_freak> anyway, my last use was in 2009, when F# wasn't even part of the VS distribution =)
21:46:49 <cl1> mm_freak .. i see
21:46:59 <kniu> the former at version 10.1 doesn't seem to build against the latter
21:47:21 <mm_freak> in F# even the sole import of a module can cause side effects
21:47:49 <kmc> there's also the design difference of e.g. Scala, which tries to incorporate all of Java as first-class constructs, vs Clojure, which treats it more like a foreign-function interface
21:47:53 <ski> yeah. that happens in SML and O'Caml as well
21:48:24 <kmc> as with Haskell's C FFI, you're expected to wrap Java libraries in Clojure before you use them from Clojure apps
21:48:31 <ski> still, those distinguished between commands (which really are expressions whose value are ignored) and declarations
21:48:31 <kmc> that's my sketchy understanding, anyway
21:48:42 <ski> (s/shed/shes/)
21:49:14 <ddarius> http://blogs.msdn.com/b/clrcodegeneration/archive/2009/05/11/tail-call-improvements-in-net-framework-4.aspx
21:49:21 <mm_freak> ski: i think that really is a matter of interpretation…  when a type is not defined above its declaration, the to me the declaration itself is a command
21:50:23 <mm_freak> of course that view would be stronger, if that actually allowed you to write lexically scoped types or even handle them as first class objects, but i don't know whether that's possible in F#
21:50:46 <mm_freak> not lexically, but dynamically
21:51:28 <ski> mm_freak : in e.g. SML, there is no syntactic class of "command", a command is simply an expression whose value is ignored; where an expression is expected, you can't put a declaration, and vice versa -- however, in some contexts (like in the top-level of the module) both expressions and declarations are allowed
21:52:02 * ski suspects the same holds in F#, but isn't sure
21:52:31 <mm_freak> sure, but that isn't really relevant…  the scope of the declarations matters
21:52:50 <ski> (cf. with both `<pattern> <- <expression>' and `<expression>' being allowed in `do')
21:52:51 <mm_freak> and yet it's still just an interpretation…  your view is perfectly fine
21:56:51 <ski> if `let x = x+1' (non-recursive) was a command in the dynamic sense, i'd expect it to take the old value of `x' and put the incremented value into `x', if `let x = x+1' was in e.g. a `for' loop
21:57:06 <ddarius> My understanding is the top level of all MLs is not mutually recursive, so there isn't a difference with F# here either.
21:57:57 <ski> (where each time `let x = x+1' was executed, a fresh variable `x' would be created, and the old one shadowed)
21:59:32 <monochrom> the SML I know makes you write declarations at the top level, even for "the main program". you have to write "val _ = go()", not "go()".
21:59:54 <etpace> Hmm... say I have a simple AST datatype (abstraction, application, ints) - would it be possible (with some type hackery) to have haskell's engine itself type my AST? something like typeThis :: TypeOfAST t => Expr -> t? (I ask because I would like to add quickcheck tests to my type checker and if I could ahve a property of my typechecker == haskell typechecker, it would be quite fun)
22:00:10 <ddarius> monochrom: That was my understanding too, though the REPL allows expressions, no?
22:00:21 <monochrom> yes, the REPL allows everything
22:00:24 <ddarius> Well, I guess it would have to.
22:00:25 <ski> monochrom : ok, i was probably thinking of O'Caml there, then
22:01:29 <ski> etpace : you could try using GADTs
22:02:23 <etpace> do you know of an introductory link for them?
22:02:36 <zirayn> etpace: just be careful, GADTs are not in haskell standard, just in GHC
22:03:22 <ddarius> zirayn: What is he being careful of?
22:03:58 <cl1> ddarius, from microsoft: There are few real C# methods where it would be legal to emit tail calls (other languages encourage coding patterns which have more tail recursion, and many that rely heavily on tail call optimization actually do global re-writing (such as Continuation Passing transformations) to increase the amount of tail recursion).
22:04:06 <etpace> that's ok - it's mainly for a learning experience. As my language is a subset of haskell randomly generating AST and then verifying with GHC evaluation and GHC typechecking would be fun
22:04:18 <ski> etpace : i think abstraction (and other binders) are probably the hardest thing to do nicely
22:04:58 <ddarius> cl1: The first sentence is only saying that most C# functions don't have tail calls, and particularly, tail recursion.  This is not surprising at all.
22:05:57 <ddarius> There are definitely things in C# that I could see making TCO difficult in particular cases like varargs and stackalloc, but neither of those are pervasive either.
22:05:57 <cl1> okay so its not impossible, just rare
22:06:13 <cl1> varargs are used alot
22:06:33 <cl1> void Foo(params whatever[] foo)
22:06:50 <ddarius> cl1: People don't write code tail recursively because it wasn't and isn't a reliable optimization, and also typical C# developers aren't really aware of the issue.
22:06:52 <ski> etpace : something like `data Expr :: * -> * where EVal :: a -> Expr a; EApp :: Expr (a -> b) -> (Expr a -> Expr b); EPair :: Expr a -> Expr b -> Expr (a,b); EFst :: Expr (a,b) -> Expr a; ...' isn't hard to do
22:07:31 <ski> etpace : randomly generating the existentially quantified types might take some ingenuiety
22:07:38 <ddarius> cl1: They are used, but they aren't used a lot.  It's not like calling/writing a single vararg function anywhere in your program is going to eliminate the possibility to do tail calls anywhere.
22:07:49 <cl1> true
22:08:16 <cl1> I forget how long ago i was told that and by whom, but at the time they were a reliable source of information
22:08:38 <cl1> i've been working with c# since before it was released, so ...
22:08:41 <ddarius> cl1: It is true that you can't -rely- on TCO in C# and thus you can't write in that style regardless.
22:08:43 <cl1> who knows when that was
22:10:01 <cl1> .net in general has come a long ways since then
22:10:11 <etpace> thanks ski, i'll have a go
22:11:22 <ddarius> cl1: Yeah. C# 1.0 was Java.  Already in 2.0 they took large strides, and 4.0 is pretty nice.  Similarly for the libraries.
22:12:49 <etpace> If this proves too bad - I wonder how difficult it is to right a toHaskell :: Expr -> Haskell and then have GHC type it from a call or something, and then extract that type..
22:12:53 <cl1> wow, its been 10 years
22:13:29 <ddarius> Yes.
22:15:37 <cl1> I just hit the monad section, wish me luck
22:16:07 <ddarius> cl1: Stop worrying about it so much and you'll do better.
22:16:09 <etpace> ski: http://okmij.org/ftp/tagless-final/tagless-typed.html#tc-GADT-tc seems to be on point too
22:16:09 <Axman6> cl1: they're easy, really.
22:33:06 <mm_freak> i remember trying to write a server application with a custom protocol in C# using the .NET library
22:33:14 <mm_freak> it was pure horror…  i felt like i was writing C
22:39:48 <mm_freak> i'd like to have a version of GHC with the new type system features related to kinds…  should i pick HEAD or STABLE?
22:41:31 <ddarius> mm_freak: For byte level protocols, none of C#, Java, or Haskell are particularly compelling.
22:41:50 <ddarius> I like C++ for that.
22:43:04 <mm_freak> ddarius: i'm using haskell for that…  it works well and is convenient
22:43:25 <mm_freak> using proper libraries of course
22:44:38 <ddarius> Being able to read in a packet or whatever and then just placement new a structure over it is really nice.
22:49:00 <mm_freak> true
22:51:46 <cl1> ddarius, ada is really good for that
23:01:05 <russellw> cl1, what does Ada do better than C/C++ in that regard? I used Ada a long time ago, but never for byte level protocols
23:08:05 <cl1> i dunno if its better, but ada is good for that too, you can specify the size of members
23:08:54 <russellw> yeah, you need to be able to do that in systems programming
23:42:11 <MostAwesomeDude> @instances Typeable
23:42:12 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
23:42:22 <MostAwesomeDude> @instances-importing Typeable
23:42:22 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
23:45:53 <hpaste> MaskRay pasted “Could not deduce (Elems a ~ Elems a1)” at http://hpaste.org/55419
23:48:42 <MaskRay> hello, i'm working on an 8-puzzle program and encounter some issues with type families, can you do me a favor to figure out the reason?
23:49:23 <Polarina> How can I see what packages depend on a certain package in Hackage?
23:50:22 <MaskRay> the working program can be found on https://github.com/MaskRay/hsnippet/blob/master/toy/8-puzzle.hsc
23:51:01 <shachaf> MaskRay: Are you sure a type class is the right approach for this sort of thing?
23:51:15 <MaskRay> it implemented two approaches to solve the puzzle, and now i'm trying to exploit type families to make it more general.
23:51:56 <MaskRay> shachaf: can you suggest a better one?
23:52:03 <Cale> MaskRay: hmm, perhaps you're just looking for a function parameter to solve?
23:53:26 <MaskRay> Cale: do you mean Functional Dependency?
23:53:29 <Cale> no
23:53:35 <Cale> I just mean a normal parameter
23:54:23 <shachaf> There's the classic "use values instead of type classes" post.
23:54:25 <Cale> solve :: (State -> Map Int Int) -> State -> IO ()
23:54:45 <shachaf> I'm not sure if that exact argument applies here, but probably something close to it does.
23:54:50 <MaskRay> i define two phantom types (BFS and Heuristic) and they use different containers for states. this is the reason why i choose type families
23:56:00 <Cale> I mean, if the code with CPP macros is currently in a working state, then you don't need anything too special type-wise it seems...
23:56:20 <MostAwesomeDude> Man. cmdargs is so difficult to understand.
23:56:25 <Cale> the #ifdef'd lines both have the same type, Map Int Int
23:56:32 <Cale> and they both only depend on src
23:56:37 <Cale> which has type State
23:56:55 <Cale> So you can add a parameter of type  State -> Map Int Int
23:57:03 <Cale> and factor that out with no magic at all
23:57:15 <shachaf> Cale++ # no magic
23:57:26 <shachaf> "Shun magic, and shun the appearance of magic! Shun everything, and then shun shunning!"
23:58:06 <MaskRay> i need State with the bfs approach, while (Int,State) with the heuristic
23:58:36 <Cale> hm?
23:58:44 <Cale> I'm failing to see the problem
23:59:04 <Cale> Let me grab this code and I'll just do what I'm thinking of to it
23:59:38 <shachaf> MaskRay: I think Cale is suggesting that you pass in a function like (\src -> astar (SS.singleton (heuristic src, src)))
