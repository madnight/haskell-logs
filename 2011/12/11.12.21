00:00:18 <ski> Tuna-Fish> :t multiplex
00:00:32 <ski> Tuna-Fish> :t newTJono
00:00:37 <Tuna-Fish> ski: multiplex :: TJono String -> [ (TJono String)] -> IO ()
00:00:58 <Tuna-Fish> ski: newTJono :: STM (TJono a)
00:01:55 <opqdonut> Tuna-Fish: oh, right, splitRTJono should have a return type that is IO Something
00:02:04 <opqdonut> probably IO [TJono String]
00:02:21 * ski nods
00:02:23 <opqdonut> you see, it thought you were working in the list monad
00:02:40 <Tuna-Fish> opqdonut: thank you very very much
00:02:42 <Blkt> good morning everyone
00:02:53 <ski> Tuna-Fish : note that
00:02:58 <drdo> How does one represent pathnames in haskell?
00:03:06 <ski>   jonot <- sequence $ map (\ _ -> (atomically newTJono)) [1 .. count]
00:03:09 <ski> is really the same as
00:03:12 <opqdonut> drdo: as Strings
00:03:14 <ski>   jonot <- sequence $ map (\ _ -> atomically newTJono) [1 .. count]
00:03:15 <Blkt> (yes, it is a /amsg, but I love to greet everyone)
00:03:20 <ski> which can be written as
00:03:28 <ski>   jonot <- mapM (\ _ -> atomically newTJono) [1 .. count]
00:03:38 <ski> which in this case can be simplified to
00:03:50 <ski>   jonot <- replicateM count (atomically newTJono)
00:04:05 <opqdonut> yep
00:04:11 <Tuna-Fish> not only does it work now , I think I actually understand now why it didn't and why it shouldn't have. Thanks again
00:04:28 <drdo> opqdonut: How does not run into portability problems?
00:04:29 <ski> Tuna-Fish : see above
00:04:39 <drdo> *does one
00:05:00 <Tuna-Fish> ski: my excuse is that it started much more complicated and I've been trimming it down from that. thanks for you too
00:05:04 <ski> @src mapM
00:05:04 <lambdabot> mapM f as = sequence (map f as)
00:05:32 <opqdonut> drdo: I actually have no idea.
00:06:21 <MiggyX> okay, here's a weird one‚Ä¶   JS.decode "{}"   works in GHCI  but not when it's compiled‚Ä¶  am I doing something dense?  It can't parse the String‚Ä¶.
00:06:26 <Entroacceptor> drdo: there are libs for that
00:07:02 <Entroacceptor> system.directory or something
00:07:17 <etpace> Does anyone know of the overhead in createProcess etc from System.Process? I'd like to benchmark some cmd line things with criterion and wondered if the overheard of such would bring too much variance
00:09:36 <opqdonut> etpace: well criterion will measure the variance, so you should be fine
00:09:59 <opqdonut> etpace: it will have some constant overhead but if you're all the things with createProcess your comparison will still be valid
00:10:09 <opqdonut> s/you're/you run/
00:10:25 <opqdonut> my brain hasn't completely waken up yet, clearly
00:10:56 <etpace> great
00:11:00 <etpace> thanks
00:11:56 * Sgeo wants to make a quantum thingy based off one of the existent ones but with more of a multiple worlds feel
00:12:10 <Sgeo> Probably no reason to though
00:12:18 <Sgeo> And I don't really understand quantum stuff that well
00:16:38 <MiggyX> any ideas on this JSON String problem? I've been at it for a few hours and I'm completely stuck :/
00:18:27 <drdo> What problem?
00:18:52 <MiggyX> drdo:  For some reason   JS.decode "{}"   works in GHCI but not in a compiled program
00:18:57 <MiggyX> and I don't understand why
00:19:41 <drdo> Am i supposed to imagine the code and then debug my imagined code? :P
00:19:56 <MiggyX> that is the code
00:20:03 <drdo> ?
00:23:19 <MiggyX> drdo: http://pastebin.com/jEVWCFnY
00:23:21 <mauke> The paste jEVWCFnY has been copied to http://hpaste.org/55537
00:24:05 <MiggyX> the top one works perfectly in GHCI.  The bottom part is the snippet from the main section - which doesn't work.  I don't think it's the way I'm encoding the string because even if I hard code it, it fails. So I'm doing something else that's dense :)
00:26:02 <drdo> MiggyX: I don't know the code for JS.decode
00:26:41 <MiggyX> drdo: It's not one of mine, it's from Hackage. I just don't get why it works in GHCI and not in GHC. I didn't know if I was doing something obviously wrote
00:26:43 <MiggyX> wrong even
00:46:51 <sattar> A haskell program built on Ubuntu 11.10 does not run 11.04 or earlier. I get mkTextEncoding: invalid argument (Invalid argument) error. Can anyone help me out here?
00:52:32 <Eduard_Munteanu> sattar: did you link it statically? Note, by default, it only links statically to Haskell libs, so libc and all that isn't covered.
00:53:18 <sattar> I built it using this command: ghc -static -optl-static -optl-pthread --make app.hs
00:55:30 <sattar> @Eduard_Munteanu I'm trying to deploy it to Heroku using the Cedar stack. If I compile my binary on a 11.04 or earlier version of Ubuntu, it works fine. I get this error only when I use 11.10
00:55:30 <lambdabot> Unknown command, try @list
00:58:00 <Eduard_Munteanu> sattar: I'd try passing -static to the C compiler as well
00:58:22 <Eduard_Munteanu> And check if it links to anything dynamically (e.g. ldd)
00:59:27 <Eduard_Munteanu> (why -optl-pthread though?)
00:59:44 <sattar> Eduard_Munteanu: When compiled using ghc --make app.hs, it links everything statically, except a few binaries (libgmp.so.10) which are linked dynamically
01:00:17 <Eduard_Munteanu> sattar: what else? How about libiconv?
01:00:17 <sattar> That library is dynamically linked due to some licensing issues
01:00:25 <sattar> I don't know
01:00:52 <sattar> Some guy here faced the same problem: http://stackoverflow.com/questions/7344744/haskell-program-built-on-ubuntu-11-10-doesnt-run-on-ubuntu-10-04
01:01:17 <sattar> I used his solution, but it raises a whole new error with a large list of warnings
01:04:17 <gomon> ÓÔ... Á‰ÓÓ‚‡ ‚ÒÂÏ. ÛÒÒÍËÂ ÂÒÚ¸?
01:06:50 <gomon> ÂÒÚ¸ ÍÚÓ ÊË‚ÓÈ?
01:06:50 <opqdonut> nice letters you have there
01:07:02 <gomon> hello
01:07:33 <sattar> Eduard_Munteanu: you there?
01:08:49 <ion> gomon: Your IRC client seems to use a legacy charset which is guaranteed to render incorrectly for most other users. I recommend UTF-8.
01:10:41 <Eduard_Munteanu> sattar: yeah, but I don't have any ideas. Might try using -optc-static as well, dunno
01:13:53 <gomon> Greetings to all. Here there are those who knows Haskell and not against to help with it?
01:14:57 <quicksilver> yes, indeed, gomon
01:15:00 <quicksilver> lots of people like that
01:15:00 <Eduard_Munteanu> Oh but indeed there are.
01:15:11 <quicksilver> go ahead and ask any question you might have.
01:15:40 <frerich> gomon: There are those who don't know Haskell and yet are not against helping with it, too!
01:15:48 <etpace> @hoogle ([a] -> [[a]]) -> ([(a,b)] -> [[(a,b)]])
01:15:48 <lambdabot> No results found
01:15:51 <etpace> bah
01:16:02 <Eduard_Munteanu> Yes... come forward speaketh thy problem, for it will be advised upon. :P
01:16:21 <etpace> Given a function that does some shuffling/grouping on a, how can I easily lift it so that I can keep my associated data of a around
01:16:29 <gomon> At university have set to solve pair of problems. To write them it is necessary on haskell. I in it am not strong! Only in with ++!
01:18:36 <Eduard_Munteanu> What problems?
01:19:00 <Eduard_Munteanu> @where lyah
01:19:00 <lambdabot> http://www.learnyouahaskell.com/
01:19:06 <iPeter> how can I move files , not copying, from one folder to an other on a mac
01:19:19 <Eduard_Munteanu> ^ in case you're looking for something to read
01:19:35 * frerich knows he married the right girl since she recently bought him the paperprint version of LYAH as a present :)
01:19:54 <Eduard_Munteanu> Heh.
01:20:16 <Eduard_Munteanu> iPeter: mv?
01:20:26 <iPeter> sory whats mv?
01:20:37 <gomon> hmm
01:21:10 <Eduard_Munteanu> iPeter: a terminal command
01:21:18 <Eduard_Munteanu> Dunno why you're asking in here though.
01:21:41 <iPeter> where shall I ask?
01:21:51 <DrTeggy> On #scala, iPeter
01:21:56 <Eduard_Munteanu> LOL
01:22:07 <frerich> iPeter: Do you want to know how to move a file on the file system in a Haskell program?
01:22:13 <Eduard_Munteanu> iPeter: how did you stumble upon #haskell anyway?
01:22:34 <Eduard_Munteanu> Hm, fair question.
01:22:36 <iPeter> i don't even know what a haskell program is
01:22:48 <Eduard_Munteanu> Fair answer :)
01:22:56 <iPeter> so tell me
01:23:02 <frerich> Eduard_Munteanu: My guess: #haskell is way up in the list of IRC channels when sorted by number of users in the channel.
01:23:13 <Eduard_Munteanu> Ah.
01:23:26 <iPeter> what is haskell about?
01:23:51 <limetree> i can't imagine moving files would be difficult using Finder. in fact, I thought it was the default action.
01:23:52 <frerich> iPeter: Haskell is a programming language used to make the computer do more or less useful stuff. People are talking about using this programming language in here. If you would like to talk about how to move files on the Mac, you should probably try to find a more appropriate chat channel for that.
01:24:02 <Eduard_Munteanu> @wiki
01:24:03 <lambdabot> http://www.haskell.org/haskellwiki/
01:24:05 <Eduard_Munteanu> iPeter: ^
01:25:14 <Eduard_Munteanu> Maybe there's a Mac-related channel around.
01:25:15 <iPeter> thanks what chanal is appropriate for general mac questions?
01:25:19 <Eduard_Munteanu> (but I don't know)
01:25:41 <frerich> iPeter: There is a #macosx channel, which seems appropriate.
01:25:54 <Eduard_Munteanu> Hm, there's a ##mac
01:27:14 <gomon> Write function which summarizes all natural numbers less
01:27:14 <gomon> 1000 which are multiple 3 and 5.
01:27:14 <gomon> How it to solve?))
01:27:34 * mux sighs
01:27:49 <Phlogistique> isn't this like the first project euler problem?
01:28:29 <frerich> gomon: There are many ways to do that. Did you discuss the Haskell feature called 'list comprehensions' in your class yet? That would be one way to tackle the issue.
01:28:36 <iPeter> interesting - I am writing in Python , what is the most important difference to haskell
01:28:59 <Phlogistique> iPeter: Python is a dynamic language, whereas Haskell is a static language
01:29:27 <Phlogistique> iPeter: which means Python emphasises speed and easiness of programming, when Haskell emphasizes correctness
01:29:34 <iPeter> what das static mean
01:30:11 <gomon> To me have advised here so:
01:30:11 <gomon> 1 sum ([from 1 to 1000 | frequency rate conditions])
01:30:21 <gomon> frerich:
01:30:25 <Phlogistique> iPeter: I suggest you use wikipedia
01:32:09 <Eduard_Munteanu> iPeter: it's statically typed and compiled
01:32:31 <Eduard_Munteanu> Not interpreted like Python.
01:32:42 <frerich> gomon: Here is a page with a few examples of the Haskell 'list comprehension' feature, and they are probably useful for your problem. In general, the list comprehension is a possible way to get the list of numbers you need (each number is less than 1000, each is a multiple of 3 and 5) - but then you still have to find out how to add them all up to get the sum (there's a function for that): http://zvon.org/other/haskell/Outputsyntax/listQcomprehension_refer
01:32:43 <frerich> ence.html
01:32:54 <frerich> gomon: Oh, note that URL got wrapped.
01:33:26 <lpsmith> I don't suppose there is a hassle-free way of finding the size of a malloc'ed block from it's pointer in C, is there?
01:33:46 <mux> nope, at least not in a portable way
01:33:47 <DrTeggy> lpsmith, no portable way, I guess.
01:33:55 <mux> but you're the one who allocated it, so you should know
01:33:58 <lpsmith> that's what I was afraid of
01:34:03 <lpsmith> No, unfortunately I didn't allocate it
01:34:11 <mux> then you shouldn't need to know
01:34:27 <DrTeggy> That's true.
01:34:49 <mux> software has been successfully written under these premises for dozens of years, I see no excuse for needing such a thing
01:34:58 <lpsmith> If every C library was flawlessly designed,  that's true.  And strictly speaking, I don't have to know,  but it would be a lot more efficient if I did.
01:36:12 <Phlogistique> then you can try to find it out on a non-portable way, and fallback in the general case
01:36:17 <koala_man> billions have been lost in buffer overflows because software didn't know the size of allocations
01:36:20 <lpsmith> mux,  no offense intended,  but with that attitude why are you in #haskell?   Software has been successfully written without higher order functions or lazy evaluation for decades.
01:36:34 <lpsmith> =)
01:37:03 <enoksrd> @pl \xs -> map sum $ transpose xs -- yes, i know this is map sum . transpose
01:37:03 <lambdabot> map sum . transpose
01:37:33 <mux> lpsmith: I think you're incorrectly interpreting my tone, and that is quite possibly my fault; this was not meant to be agressive, but firm.
01:37:54 <mux> maybe because I've been asked this question a billion times before already and have yet to find a reasonable need for it
01:38:20 <mux> koala_man: but that has nothing to do with the fact that you cannot get the size of a malloc() allocation from the pointer...
01:39:17 <lpsmith> well,  I have a C structure consisting of pointers to two null-terminated strings,  all allocated as one contiguous block
01:39:59 <lpsmith> I'd like to turn those into ForiegnPtr ByteStrings without having to traverse the second string to find out how long it is
01:40:08 <lpsmith> I already can find out how long the first string is.
01:40:25 <frerich> lpsmith: I think it's not uncommon that some meta information about the allocated memory block is stored in the bytes before where your returned pointer points. I seem to recall that on a few systems you could do something like 'char *x = malloc( 18 );' and then 'size_t size = *((size_t *)(x - 8));' or something like that.
01:40:27 <mux> lpsmith: blame C strings and/or the library you're binding to, not malloc() :-)
01:40:39 <frerich> lpsmith: Not nice, implementation dependant, but you have been warned. :)
01:41:08 <mux> frerich: must malloc() implementations actually separate meta-data from data properly, for performance reasons (because if you don't, you end up allocating a little more than what the user asks for, which is typically a power-of-2)
01:41:14 <mux> s/must/most/
01:41:27 <mux> older implementations often did as you described
01:41:44 <lpsmith> frerich, yeah I'm aware of that technique,  but I don't know much about how the memory allocators I actually use on a daily basis actually work.
01:41:59 <lpsmith> And I'd like to avoid implementation-dependence =)
01:42:20 <frerich> lpsmith: I think if you want an implementation-independant function, they you have to resort to #ifdef :-}
01:42:36 <mux> frerich: and also to avoid touching (dirtying) the memory to write meta-data before the end consumer does so
01:44:41 <lpsmith> well, here's the thing.  You have to have some way of knowing how big the block is so you can free() it, right?   So unless there is some magical technique I'm not aware of,  shouldn't every malloc/free implementation also support a dynamic sizeof with at least somewhat reasonable efficiency?
01:45:17 <mux> well sure, every malloc() implementation has meta-data somewhere to that effect
01:45:21 <DrTeggy> uh
01:45:38 <frerich> lpsmith: There clearly must be some bookkeeping, so that 'free' can do it's work - it's just that I think there is no standard (or at least POSIX) function to query that meta-data.
01:45:46 <mux> but you don't even necessarily need to know the exact size to free the data
01:46:08 <lpsmith> frerich, exactly what I'm getting at :)
01:46:18 <quicksilver> you can conceive of systems in which the kernel/OS might know the size of the block
01:46:21 <quicksilver> but libc might not
01:46:36 <quicksilver> malloc/free might just be an interface to something lower level
01:46:52 <mux> when your allocations reach a certain size, many malloc() implementations will switch to allocating pages of memory using anonymous mmap() instead of sbrk()
01:47:02 <mux> in such a setup, you don't even need to remember the size
01:47:08 <quicksilver> (common systems are not like that, of course. But maybe that's why the feature isn't there)
01:48:18 <lpsmith> sigh.  It would be a lot nicer if I had pointers to the end of the strings,  other than that would be rather non-standard.  One of the pointers is pretty much redundant,  as it's just a constant offset in the structure itself
01:48:49 <lpsmith> but that's a vestigal feature that arouse out of path-dependence,  basically at some point they moved to a contiguous allocation
01:49:36 <frerich> lpsmith: A crazy idea: you could use a warpper function around e.g. malloc which does the bookkeeping yourself. You could even make it transparent by using LD_PRELOAD (or patching kernel32.dll) :-)
01:49:58 <mux> a lot more troubles than it's worth if you ask me
01:50:11 <frerich> Similiar to how some leak checkers work. Not super-precise (the 'real' malloc could allocate more than you specify) but you get the idea.
01:50:14 <lpsmith> An idea to keep in mind for something important,  but yeah, for what I want I totally agree with mux.
01:51:38 <lpsmith> a lot more trouble, and it would probably slow down the system as such a solution doesn't pay it's own way,  optimizing one (usually) minor case at the expense of everything else.
01:51:50 * mux nods
01:52:17 <mux> heh, that being said, I think it would be even worse to try and have a look into the allocator meta-data
01:52:39 <lpsmith> well, at least that approach pays it's own way
01:52:52 <lpsmith> even if it'd probably break on a moment's notice
01:52:54 <mux> which might even be extremely complicated to do properly for thread-aware allocators, like most are today
01:53:11 <mux> but that's just a guess now
01:53:55 <Eduard_Munteanu> If you can figure out the length of the second string on an as-needed basis, why bother?
01:54:32 <Eduard_Munteanu> Or will it try to compute it every time?
01:55:25 <sattar> @where rwh
01:55:25 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:56:22 <lpsmith> Eduard_Munteanu, I probably shouldn't bother,  but I thought it was worth asking anyway,  if there was some obscure way to do it that I'm not aware of.
01:56:37 <lpsmith> (obscure, but reasonably nice that is)
01:58:05 <mux> if you could have some confidence as to what the meta-data format is, and could properly isolate that piece of code to only get used when it's absolutely safe to do so, then it could be a possibility, in order to give a slight speedup when all the conditions are met
02:02:22 <frerich> lpsmith: Sorry, I should probably stop, but *if* you can touch the source code where the strings are allocated, you could have a specialized 'strmalloc' function which does somethjing like 'char *buf = malloc( size + 4 ); *((int *)buf) = size; return buf + 4;' (i.e. write the string size before the returned pointer yourself).
02:03:44 <etpace> I'm trying write a function that converts top level decleration pattern matching into a case statement -- does anyone know where this piece of code in GHC is located? My mind is getting a bit boggled trying to solve it
02:04:24 <lpsmith> frerich, I could touch the source code,  but then that's a large jump in the maintenance overhead :)
02:04:50 <lpsmith> Considering all I have to do at the moment is apt-get install :)
02:06:35 <lpsmith> But at that point, why not just fix the data structure and change the pointer to the first string to the length of the second string,  and add a field to represent the first pointer?
02:08:01 <lpsmith> also,  worse, that makes sharing what I'm working on that much more painful
02:08:42 <frerich> lpsmith: I didn't claim there are no downsides :) I'm just trying to think of hacks to achieve the original goal.
02:09:30 <wereHamster> how would I express 'parse lines until the first blank line' (basically until the first \n\n) in attoparsec?
02:09:49 <mux> well, if he could touch the source code, he could simply remember sizes where he needs to and be done with it :-)
02:17:50 <lpsmith> wereHamster,    assuming a parseLine,   you could do   parseLines =  do  { x <- parseLine,  if null x then return [x] else do { xs <- parseLines, return (x:xs) }}
02:18:16 <wereHamster> lpsmith: I managed to do it with <$> manyTill header separator <*> message
02:18:37 <wereHamster> where separator is "\n", and header consumes lines until EOL
02:18:48 <lpsmith> sweet
02:18:57 <lpsmith> better than mine, probably :)
02:33:11 <jessopher> does anyone know where i might find an exampe usage of ReadPrec?
02:33:17 <jessopher> example*
02:40:03 <Cale> jessopher: there's always: http://www.google.com/search?q=%22import+Text.ParserCombinators.ReadPrec%22
02:40:49 <Cale> jessopher: But to be honest, I don't know. The original Functional Pearl by Koen Claessen on ReadP doesn't seem to mention the small extension to ReadPrec
02:41:43 <rostayob> There is no emacs mode for Alex/Happy filex right?
02:45:07 <jessopher> Cale: yeah, my google searching has lead me to a couple hpastes, nothing that gives me a big picture of ReadPrec's interacting. thanks
03:25:29 <norm2782> how can I make cabal build against a specific versie of my library's dependency?
03:27:59 <hpaste> srhb pasted ‚ÄúFirst experiments with acid-state and Happstack‚Äù at http://hpaste.org/55542
03:28:25 <srhb> In the above paste, how do I actually extract the msg using viewMessage?
03:31:49 <Cale> srhb: I can probably help you out, one sec while I look up the Happstack documentation ;)
03:32:26 <srhb> Cale: Thank you, I've got it open myself but as I'm new to both Happstack, Acid-state and Haskell itself, I'm having trouble with it. The happstack documentation also seems horribly outdated.
03:32:32 <bru`> Hi! I got trouble trying to compile libmpd
03:32:50 <bru`> in Setup.lhs there is "> import Distribution.Simple" and this fails
03:33:07 <Cale> srhb: Yeah, you can stick with the haddock documentation on hackage, as that can't be too far out of date...
03:33:20 <srhb> Cale: Ah, I hadn't thought of that.
03:33:58 <bru`> when I do a ghc-pkg dump | grep Distribution.Simple I get 20 packages
03:34:06 <bru`> er, 19
03:34:09 <donri> srhb: huh, the crash cource isn't that outdated?
03:34:28 <bru`> but it is Distribution.Simple.Build... ..Compile.. ....GHC.. etc
03:34:34 <srhb> donri: Very much so, it uses happstack-state which they very firmly say on the front page should not be used, since acid-state supercedes it.
03:34:34 <bru`> not just "Distribution.Simple"
03:34:39 <bru`> what am I doing wrong?
03:34:43 <bru`> I'm using archlinux
03:35:31 <donri> srhb: oh, well yes in that particular case. acid-state supersedes happstack-state in the upcoming happstack 7, though you can use it right now. acid-state has its own docs and examples too.
03:35:57 <donri> srhb: the rest of the crash cource is not as outdated
03:36:18 <srhb> donri: Yeah, I'm looking at one example right now, and the issue is less with understanding acid-state and more with understanding Haskell, I think. :-)
03:36:28 <donri> :)
03:36:30 <cwl> where can I find all the *reserved tokens*
03:36:41 <cwl> *reserved*
03:36:45 <cwl> *tokens*
03:37:10 <donri> srhb: if you understand how to use the state monad and pure data structures, acid-state is a no-brainer on top of that. but you should first understand those two. :)
03:37:39 <srhb> donri: Perhaps I was being silly in choosing to learn to understand the state monad by working with it in acid-state then. :)
03:37:54 <cwl> > let b@__ = 'hi'
03:37:55 <lambdabot>   <no location info>:
03:37:55 <lambdabot>      lexical error in string/character literal at chara...
03:38:03 <donri> well, that works too
03:38:03 <cwl> let __ = 'hi'
03:38:12 <donri> just be prepared to learn multiple things at once :)
03:38:13 <cwl> > let __ = 'hi'
03:38:13 <lambdabot>   <no location info>:
03:38:14 <lambdabot>      lexical error in string/character literal at chara...
03:38:14 <Cale> srhb: what is the intended type of addMessage?
03:38:41 <Cale> srhb: You seem to want to use a reader monad transformer over... well, just about any monad
03:38:42 <srhb> Cale: I might be wrong here, but I think Message -> () ?
03:38:45 <Cale> no
03:38:50 <Cale> Can't be
03:39:08 <Cale> because  put $ Database msg  doesn't look like an empty tuple to me ;)
03:39:16 <donri> oh yea acid-state uses the reader monad too, for queries that don't need to update the state
03:39:47 <srhb> Cale: I guess I skipped over figuring out what type "put" has.
03:40:11 <srhb> So it's State Message ()
03:40:16 <srhb> (I think)
03:40:20 <srhb> Ahhh
03:40:25 <Cale> yeah, that's more reasonable
03:40:30 <Cale> Message -> State Message ()
03:40:34 <srhb> Indeed.
03:40:36 <_Mikey> If I have a structure which contains Int's would zipping on them make them Integers?
03:40:50 <Cale> or more generally... (MonadState Message m) => Message -> m ()
03:41:02 <_Mikey> and how do I change things back from Integers to Ints.
03:41:24 <Cale> _Mikey: to convert between Int and Integer in either direction, you can use fromIntegral
03:41:38 <Cale> _Mikey: none of the operations on either type will automatically convert anything
03:41:41 <Cale> :t (+)
03:41:42 <lambdabot> forall a. (Num a) => a -> a -> a
03:41:44 <_Mikey> so I can just map that acrross.
03:41:48 <Cale> ^^ type of arguments = type of result
03:41:54 <Cale> yeah
03:42:06 <_Mikey> hmm  wierd
03:42:18 <Cale> what?
03:42:18 <_Mikey> I've stripped down a graph
03:42:22 <_Mikey> into lists
03:42:29 <_Mikey> I've only used zip and map
03:42:49 <_Mikey> and I've swapped two elements in the list of nodes and zipped everything back together
03:43:00 <_Mikey> I've now got a list of edges to build
03:43:14 <_Mikey> which looks identical to my previous list which built fine
03:43:28 <_Mikey> except the types of the Vertices have changed from Ints
03:43:31 <_Mikey> to Integers.
03:43:41 <Cale> okay...
03:43:52 <Cale> Did you tell it which type of vertex you wanted anywhere?
03:45:07 <_Mikey> you mean with type defs?
03:45:10 <Cale> Integer is the default numeric type which is picked at the top level when compiling a module if a type variable would otherwise be ambiguous and is only constrained by Num and other Prelude classes which Integer is an instance of
03:45:38 <Cale> So if you're seeing some type being defaulted to that, it's not so surprising.
03:45:47 <_Mikey> hm ok
03:45:59 <_Mikey> so I just need to add type definitions.
03:46:14 <Cale> Or just use it in a way which lets the compiler infer that you want Int
03:46:35 <Cale> But adding type annotations to top-level things is almost never a bad plan.
03:46:46 <wereHamster> what's the best strategy with (atto-)parsec, first parse the big bytestring into chunks, then parse these chunks into my own datastructures, or directly parse the bytestring into my own data?
03:48:10 * hackagebot snaplet-hdbc 0.7.1 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.7.1 (JurrienStutterheim)
03:48:12 * hackagebot snaplet-hdbc 0.7.1.1 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.7.1.1 (JurrienStutterheim)
03:49:35 <_Mikey> Cale, Yess!
03:49:41 <_Mikey> worked a charm! :)
03:49:44 <_Mikey> thanks.
03:50:58 <ski> lpsmith,quicksilver : btw `FreeMem' on the Amiga requires knowing the size of the block to free
03:59:13 <srhb>  data Message = Message String <-- what's wrong here?
03:59:40 <quicksilver> nothing.
03:59:46 <srhb> Funky.
03:59:59 <quicksilver> the only way that would be an error is if there already was a 'Message' type
04:00:23 <srhb> from whence do I get the String constructor?
04:00:45 <srhb>  Not in scope: data constructor `String'
04:01:08 <quicksilver> that error cannot result from the line you pasted
04:01:17 <quicksilver> the line you pasted uses a type called String
04:01:20 <quicksilver> not a data constructor.
04:01:29 <quicksilver> perhaps paste the actual code onto hpaste?
04:01:42 <srhb> quicksilver: Thanks, I'll try isolating what's going on first.
04:02:03 <etpace> Do I need to list all modules used internally in Other-modules: in my cabalb uild file?
04:07:36 <etpace> Hmmm.. I get a 'cabal: can't find source for src/P2C/Main in src' when trying to build my project in cabal, cd src; ghci P2C/Main.hs works fine though, any ideas?
04:22:52 <Phlogistique> etpace: looks like it looks for src/src/P2C/Main.hs
04:22:56 <Phlogistique> no idea why
04:26:23 <donri> etpace: paste .cabal?
04:26:45 <etpace> It seems I fixed it, I needed a `.' in my source-dirs too
04:27:29 <donri> hs-source-dirs: src
05:20:32 <statusfailed> What's "Alternative"?
05:26:41 <Peaker> hah -- I patched Cabal to ignore upper version constraints
05:26:51 <Peaker> and everything seems to install smoothly now
05:26:58 <Peaker> hehe
05:27:05 <Peaker> I think I'm going to keep that :)
05:27:34 <cheater> make sure you disconnect your computer from any networks that have ICBM control systems on them
05:38:11 * hackagebot fclabels 1.1.0 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.0 (SebastiaanVisser)
05:46:21 <sanjoyd> Is there some way to import a module without the typeclass instances declared in it?
05:47:49 <mike-burns> No, and this sucks.
05:49:12 <ski> statusfailed : a class like `MonadPlus', but for `Applicative' instead of for `Monad'
05:53:32 <sanjoyd> So if I have my own `instance Monad (Either String)` and want to also import stuff from Control.Monad, then?
05:53:54 <sanjoyd> (Since I get an overlapped instance error about the Monad instance declared in Control.Monad.Instances)
05:55:06 <Saizan> use a newtype for your own
05:55:37 <Saizan> or define yoir own Either, even
06:17:41 <Sebasti0n> When I have "map (\x -> x *x) list" the x is evaluated twice, right?
06:18:05 <flux> no. if it has a name, it's evaluated once.
06:18:42 <Sebasti0n> ok, thanks
06:22:22 <juturna> How can I take an (a->b) that might throw an error and change it into an (a -> Maybe b) that won't?
06:22:46 <quicksilver> depends what you mean by 'throw an error' but, probably the answer is your can't.
06:22:54 <quicksilver> exceptions can only be caught in IO.
06:29:09 <Falda> lolwut
06:29:19 <Piet> sup homies
06:29:22 <Piet> hz represent!
06:29:24 <Maes> sup there
06:29:28 <Maes> im haskellin like a pro yo
06:29:33 <Piet> haskelling 4 lyfe
06:29:37 <Maes> try this code for size: reverse "piet"
06:29:39 <Sjaak> haai
06:29:44 <Piet> sjaaaaak
06:29:45 <Maes> it comes out as teip!!!!
06:30:02 <Piet> i heard alt+f4 is an easter egg
06:30:29 <_Mikey> o.o
06:30:39 <Piet> watcha doin mikey
06:30:45 <_Mikey> haskellin'
06:30:46 <Calihero> donkey kong
06:30:51 <Piet> yeaaap
06:30:54 <Maes> ye me too
06:30:57 <Maes> just haskellin' a bit
06:31:02 <_Mikey> not like a pro though ;/
06:31:10 <Calihero> Haskell for life!
06:31:13 <Piet> this chat isn't for noobs
06:31:15 <Maes> if you wanna be pro just type this: reverse "noob"
06:31:17 <Maes> comes out as boon
06:31:18 <Maes> super cool
06:31:23 <Calihero> this is a chat for expert of haskell
06:31:34 <_Mikey> I noticed
06:31:34 --- mode: ChanServ set +o quicksilver
06:31:38 <Calihero> so shut up if you dont know how to haskell
06:31:40 <lolwut> u did?
06:32:02 <Maes> did whut?
06:32:04 <Piet> everyone who's pro haskeltor say "ai"
06:32:17 <Sjaak> ai
06:32:17 <Maes> AI!
06:32:26 <Maes> i can prove it: reverse "i am the shiz"
06:32:34 <Maes> comes out as zihs eht ma i
06:32:37 --- mode: quicksilver set +b *!*@gateway/web/freenode/ip.145.19.*
06:32:49 <donri> ia
06:32:58 <donri> that's agreement in lojban *and* "ai" reversed
06:33:11 <donri> except i'm lying, it's belief
06:33:11 * hackagebot generic-tree 15329.1 - Generic Tree data type  http://hackage.haskell.org/package/generic-tree-15329.1 (MatthewFarkasDyck)
06:33:40 <_Mikey> so confused.
06:39:11 <hpaste> srhb pasted ‚ÄúType problem related to happstack and acid-state and do-blocks‚Äù at http://hpaste.org/55549
06:39:46 <srhb> So I'm getting a type error that I can't figure out in the above paste. Am I misunderstanding how to use the inner do-block?
06:39:59 --- mode: quicksilver set -b *!*@gateway/web/freenode/ip.145.19.*
06:40:32 <Piet> let me just take a look at that for you hpaste
06:40:35 <quicksilver> srhb: paste the error too please.
06:40:52 <Piet> i'm sure i''ll have it figured out in no time
06:41:23 <srhb> quicksilver: I added it to the bottom of the paste now. :)
06:41:47 <hpaste> srhb annotated ‚ÄúType problem related to happstack and acid-state and do-blocks‚Äù with ‚ÄúType problem related to happstack and acid-state and do-blocks (annotation)‚Äù at http://hpaste.org/55549#a55550
06:41:56 <srhb> (Or at least now I did)
06:42:39 <quicksilver> srhb: the problem is that 'update' is an IO monad action
06:42:48 <Piet> yeah i think the problem is in the directive association interlope
06:42:56 <quicksilver> srhb: and simpleHTTP doesn't take an IO monad parameter
06:43:02 <roconnor> @hoogle f (a -> b) -> a -> f b
06:43:02 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
06:43:03 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
06:43:03 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
06:43:11 * hackagebot xtest 0.2 - Thin FFI bindings to X11 XTest library  http://hackage.haskell.org/package/xtest-0.2 (IlyaPortnov)
06:43:11 <roconnor> @hoogle+
06:43:11 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:43:12 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
06:43:12 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:43:17 <srhb> quicksilver: But I thought the expression at the end of the do-block was its "value", is that mistaken?
06:43:30 <etpace> :3
06:43:34 <quicksilver> srhb: that's correct but that's not the only requirement
06:43:36 <etpace> oops, mistype
06:43:37 <srhb> Aha.
06:43:43 <quicksilver> srhb: each statement must be in the correct monad
06:43:46 <donri> who maintains haskellwiki?
06:43:49 <quicksilver> (and, indeed, the same monad)
06:44:07 <srhb> quicksilver: Thank you.
06:44:44 <quicksilver> srhb: I suspect the solution is "a <- liftIO $ update acid (AddMessage "added")"
06:44:59 <quicksilver> but I'm just checking the type of simpleHTTP
06:45:35 <quicksilver> yes, that's right
06:45:44 <quicksilver> ServerPart (that's the simpleHTTP monad) is an instance of MonadIO
06:45:55 <quicksilver> so you can run arbitrary IO actions in it using 'liftIO'
06:46:03 <srhb> quicksilver: Actually my AddMessage returns unit, so can I just chain it somehow?
06:46:06 <Andre__> He
06:46:07 <Andre__> y
06:46:33 <Piet> okay uhm i got a question...  how do i create like a variable: int meow = 10;   ?  only ppl that know what they are talking about please
06:46:38 <Calihero> test
06:46:58 <quicksilver> srhb: then you don't need the a <- part
06:47:03 <Guest15583> hoi piet :P
06:47:05 <srhb> quicksilver: Indeed.
06:47:14 <Guest15583> Piet ik weet wie je bent
06:47:15 <Maes> piet: I think it's this: let meow = '10'
06:47:23 <Blaat_> wie is piet
06:47:31 <Guest15583> Die kerel bij de deur :)
06:47:32 <Blaat_> ze komen je halen
06:47:45 <quicksilver> keep it english and on-topic
06:47:52 <Guest15583> I know Piet. :)
06:48:04 <Calihero> its a stalker
06:48:05 <Piet> i agree quicksilver
06:48:11 <Guest15583> Herpderp!
06:48:11 <Piet> you and me are very alike
06:48:19 <quicksilver> srhb: you could write do { update acid (AddMessage "added"); ok "added" } or 'update acid (AddMessage "added") >> ok "added"'
06:48:26 <quicksilver> srhb: gah, missing liftIO.
06:48:30 <donri> srhb: you're welcome in #happs too btw
06:48:49 <quicksilver> srhb: you could write do { liftIO $ update acid (AddMessage "added"); ok "added" } or '(liftIO $ update acid (AddMessage "added")) >> ok "added"'
06:48:53 <Gorillamadness> hey guys
06:48:59 <Maes> hey
06:49:00 <quicksilver> srhb: there is really no strong reaons to choose between >> and do notation.
06:49:01 <Gorillamadness> how is it hang today?
06:49:15 <Maes> to the left
06:49:23 <Piet> hey gorillaman
06:49:23 <Maes> i just swapped it because it was hanging to the right all morning
06:49:23 <Guest15583> How do i create a function?
06:49:24 <srhb> quicksilver: Ok, perfect, thank you, I'll try on my own now :(
06:49:30 <srhb> quicksilver: :)*
06:49:53 <Piet> niek haartsen from breskens
06:49:59 <Gorillamadness> nice to hear that mr maes
06:50:04 <Calihero> Piet kromhout from biggekerke
06:50:05 <Gorillamadness> always swap it to the left
06:50:18 <quicksilver> Piet, Gorillamadness, Guest15583 : if you're trying to learn haskell, check out the introduction in Learn You a Haskell
06:50:23 <quicksilver> @where lyah
06:50:23 <donri> srhb: might want to make your own query/update functions that do liftIO for you e.g. https://github.com/dag/kibr/blob/master/src/Kibr/State.hs#L21
06:50:23 <lambdabot> http://www.learnyouahaskell.com/
06:50:34 <Piet> definetly bro i'm following the tut right now
06:50:38 <Calihero> Piet stop it
06:50:40 <donri> srhb: don't let that type scare you xD
06:50:41 <Calihero> i wanna learn
06:50:43 <Gorillamadness> kromhout i remember that name from WoW. I joined a guild called bomenzijnrelaxt
06:50:44 <Calihero> haskell
06:51:00 <Guest15583> So what is this game
06:51:02 <Piet> wtf
06:51:06 <Piet> is thisrealife.jpg
06:51:08 <Calihero> <-- nice tut
06:51:09 <Piet> i was in that guild
06:51:17 <Gorillamadness> your kidding me
06:51:30 <Gorillamadness> you where kinda a noob
06:51:31 <mux> quicksilver: at some point you'll have to get mad. I for one won't blame you.
06:51:43 <Piet> lol i quit like 1 week after joining
06:51:48 <mux> any chance you guys stop with taht stupidity and keep the signal/noise ratio sane?
06:52:00 <Saizan> Gorillamadness, Piet: please avoid non haskell-related comments
06:52:06 <mux> we have absolutely 0 interest in your WoW guilds.
06:52:12 <Piet> got it mux i'll be quieter than a cat in a desert storm
06:52:55 <Gorillamadness> aah sadly a long lost friend
06:53:01 <srhb> donri: That looks very useful! I'll see if I can understand it a bit later. :)
06:53:11 * hackagebot generic-tree 15329.2 - Generic Tree data type  http://hackage.haskell.org/package/generic-tree-15329.2 (MatthewFarkasDyck)
06:53:43 <Calihero> Nederlands praten dan verstaan ze je niet
06:53:47 <Guest15583> I farted :) giggity.
06:53:47 <Piet> it's pretty weird you remeber my name.. you stalking cuzzz?
06:53:58 <Calihero> lolz
06:54:00 --- mode: quicksilver set +b *!*9113f99a@*.145.19.249.154
06:54:00 --- kick: Calihero was kicked by quicksilver (Guest15583 Piet )
06:54:10 --- mode: quicksilver set +b *!*9113fa8c@*.145.19.250.140
06:54:10 --- kick: Guest15583 was kicked by quicksilver (Guest15583)
06:54:10 <mux> tried a multiple ban eh?
06:54:13 --- mode: quicksilver set +b *!*9113f8f4@*.145.19.248.244
06:54:13 --- kick: Piet was kicked by quicksilver (Piet)
06:54:15 <donri> srhb: i have some ugly shit in https://github.com/dag/kibr/blob/master/src/Kibr/Http.hs you might look at
06:54:19 <mux> quicksilver: thanks
06:54:24 <Maes> pfew, much better
06:54:24 <earthy> Calihero: you better watch out. more people understand dutch than you might think. :P
06:54:25 <Maes> thanks
06:54:28 <quicksilver> mux: yes, initially I banned the whole /16
06:54:35 <quicksilver> mux: but someone pointed out that was a bit wide-ranging.
06:54:42 <mux> heh indeed
06:55:02 <Gorillamadness> quicksilver
06:55:03 <wereHamster> what's the best way to parse an email address (name <user@domain.tld>) with parsec? You need backtracking for the closing '>', don't you?
06:55:12 <Gorillamadness> can u help me to understand haskell>
06:55:26 <donri> srhb: (seriously though, join #happs ;P)
06:55:34 <mux> quicksilver: this guy needs to go too.
06:55:49 <quicksilver> Gorillamadness: lots of people here can help you but first you need to help yourself.
06:55:59 <quicksilver> start by going through a good tutorial and feel free to ask questions if you get stuck
06:56:02 <earthy> wereHamster: not if there's no alternative valid parsing that starts with (name <
06:56:14 <mux> he's most definitely trolling you
06:56:15 <srhb> donri: I felt like I wouldn't pester in specialized channels until I don't make Haskell mistakes all the time :P
06:56:17 <Gorillamadness> well iam kinda stuckat lesson 3
06:56:38 <donri> srhb: oh don't be silly :)
06:56:38 <earthy> wereHamster: (because then if you hit end-of-string without having parsed > you know the string doesn't match)
06:57:57 <hpaste> ‚Äú,,kkkk‚Äù annotated ‚ÄúGUI-CAlculator‚Äù with ‚ÄúGUI-CAlculator (annotation)‚Äù at http://hpaste.org/55467#a55551
06:57:59 <wereHamster> earthy: any idea how I can test parsec in ghci?
06:58:15 <wereHamster> like with test strings..
06:58:26 <quicksilver> just call runParser from ghci
06:58:38 <quicksilver> it can be a bit easier if you set up a function which plumnbs in the necessary bits
06:58:39 <wereHamster> hm, it's actually attoparsec, which makes working with strings a bit of a pain
06:58:40 <saati> is undefined a nullptr in ghc generated code?
06:58:54 <wereHamster> first need to convert them to a strict bytestring :-/
06:59:01 <quicksilver> saati: nope
06:59:15 <donri> no one knows who maintains haskellwiki eh?
06:59:23 <saati> quicksilver: what is it
06:59:31 <quicksilver> donri: mostly, the community.
06:59:33 <quicksilver> saati: it's an exception.
06:59:38 <donri> quicksilver: i mean administratively
06:59:43 <quicksilver> donri: I expect the haskell.org committee, then.
06:59:59 <donri> they have an irc?
07:00:08 <quicksilver> :)
07:00:13 <quicksilver> some of them do.
07:00:28 <donri> channel i mean :)
07:00:32 <quicksilver> not that I know of.
07:00:57 --- mode: quicksilver set -o quicksilver
07:01:32 <donri> http://www.haskell.org/haskellwiki/Haskell.org_committee ugah i hope i don't have to be a member to get some admin caps at the wiki? looks kafkaesque
07:01:47 <donri> i just want to remove spam -.-
07:02:29 <donri> guess i'll email them
07:02:46 <kmc> does removing spam require more than standard edit privs?
07:02:46 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
07:03:03 <quicksilver> donri: I'm sure you don't.
07:03:15 <quicksilver> donri: they're just the people who would know who sets up the wiki admins :)
07:03:21 <donri> kmc: yep
07:03:27 <kmc> why's that?
07:03:38 <donri> normal users can't delete stuff
07:03:47 <kmc> oh, delete a whole page?
07:03:51 <donri> yep
07:04:14 <donri> there's a flood of new pages that are purely spam
07:04:20 <mm_freak> wereHamster: if you have strings you could just as well use parsec
07:04:21 <donri> i also have some other concerns
07:06:14 <quicksilver> donri: the logs suggests that gwern is an active admin,so nudging him would be a start.
07:09:37 <carpi> is it necessary that the name of hte module and the name of the file in which it resides..must be same?
07:11:01 <donri> carpi: nope
07:11:16 <donri> not even the case for hierarchical modules ;)
07:11:42 <carpi> but RWH says otherwise.. maybe this was the case in 2008 when the book was written
07:11:58 <Gorillamadness> its kinda bizzy btw on this chat
07:12:08 <Gorillamadness> didnt even knew haskell was this popular
07:13:02 <donri> carpi: well, Main might be an exception then. i based my answer on Main.
07:13:18 <donri> carpi: in any case i certainly suggest you name the file and module consistently
07:13:20 <Maes> does anyone know how many lessons are in this haskell tutorial
07:13:28 <Maes> im at llike lesson 28 now and i'm losing interest
07:13:33 <donri> what tutorial?
07:13:38 <Maes> tryhaskell.org
07:14:14 <donri> i don't think it has 28 lessons
07:14:21 <donri> the list says six lessons
07:14:37 <srhb> donri: I got it working! ;) I'm very proud and it looks very clever!
07:14:38 <donri> do you mean steps?
07:14:50 <donri> srhb: that doesn't sound good! clever is bad mkay!
07:14:58 <srhb> donri: Darnit.
07:15:00 <donri> :D
07:15:16 <donri> clever is also subjective
07:15:54 <donri> Maes: looks like 33 steps, almost there!
07:16:02 <Maes> thanks!
07:17:25 <Sgeo> I don't think Try Haskell is necessarily the best way to learn Haskell
07:18:44 <srhb> I think the worst part of learning any language is finding something to DO in it.
07:18:47 <srhb> :P
07:19:05 <carpi> i disagree
07:19:19 <srhb> I also think it's very different from person to person :P
07:19:20 <Sgeo> Is Try Haskell even working?
07:19:24 <Sgeo> I keep getting Terminated
07:19:46 <srhb> Sgeo: Looks like it's working from here.
07:19:56 <Sgeo> I see it working now
07:24:02 <alistra> hi
07:29:02 <kmc> the best kind of cleverness is hidden cleverness
07:29:22 <kmc> that is, you do something clever which allows other people to go about their work in a nicer way, without knowing about the clever thing
07:29:41 <donri> ...until it blows up in their faces
07:29:48 <kmc> ("other people" can also be yourself wearing a different hat)
07:30:35 <kmc> donri, the ideal is to make an abstraction which does not do that ;P
07:30:58 <kmc> obviously you can only approximate, but you can come pretty close
07:31:29 <donri> :)
07:32:09 <kmc> i don't think Try Haskell is a good way to "learn Haskell", because the tutorial is basic and the REPL is limited
07:32:17 <kmc> i don't think that's really the point
07:32:32 <kmc> it's a low-friction way to get a taste
07:32:36 <kmc> so you can decide whether to learn it "for real"
07:32:39 <donri> the point is to "try haskell", for that it works wonderfully
07:33:07 <kmc> which i support wholeheartedly because the alternative is that people come here and ask "should i learn haskell? is haskell good?" and that never ends well
07:33:24 <donri> wait, is it good then?
07:33:28 <donri> i never asked this question.
07:33:37 <kmc> haha
07:33:48 <donri> how could i have forgotten to ask fanatics if their favorite thing is good
07:33:58 <kmc> i know, right?
07:34:42 <Saizan> [insert obscure joke about unicycling]
07:35:14 <donri> [insert sneaky remark regarding obscure joke about unicycling]
07:35:33 <kmc> [derails channel into wanking about in-jokes]
07:36:27 <Waldteufel> [returns to computer and sees stuff about unicycling before typing "ohai"]
07:38:47 <kmc> i often complain that programmers are ignorant of huge pieces of the computing stack... but really this indicates the success of "hidden cleverness"
07:43:11 * hackagebot temporary 1.1.2.3 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1.2.3 (MaxBolingbroke)
07:52:50 <dino-> I'm writing something where I forkIO an IO action that is using runCommand and waitForProcess. I think I'm doing something wrong because the forkIO blocking along with the thing I'm forking.
07:53:17 <dino-> Isn't the point of forkIO that I'm not waiting for the thing I just forked?
07:53:20 <kmc> can you put your code on hpaste.org?
07:53:57 <dino-> kmc: Ok, I'll tone it down to simple ex of this
07:53:58 <kmc> did you build with ghc -threaded?
07:54:16 <dino-> kmc: Ah no
07:54:19 <kmc> try that
07:57:12 <dino-> kmc: Well that changed things.
07:58:16 <kmc> does it work now? :D
07:59:36 <dino-> Well, no, but forkIO doesn't block like that anymore.
07:59:59 <kmc> ok
08:00:32 <kmc> i usually find http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html more convenient than forkIO
08:00:42 <kmc> (that's why i uploaded it to hackage ;)
08:17:02 <etpace> How can I set cabal to --enable-tests by default so I dont have to pass it in every time I use cabal configure?
08:18:11 * hackagebot safe-globals 0.1.1 - Safe top-level mutable variables which scope like ordinary values  http://hackage.haskell.org/package/safe-globals-0.1.1 (KeeganMcAllister)
08:18:17 <kmc> there's probably a setting in ~/.cabal/config
08:18:20 <kmc> i don't know the name though
08:18:28 <mux> I just looked there and couldn't find it
08:18:35 <mux> I also thought it would exist
08:18:40 <kmc> sucks
08:19:13 <mux> but maybe my ~/.cabal/config doesn't have all the possible settings commented out if it was created some time ago?
08:19:14 <orbital_fox> wrap it in a script of yours?
08:19:30 <orbital_fox> not very neat.. but..
08:19:59 <kmc> mux, yeah, that was my thinking as well
08:26:43 --- mode: ChanServ set +o quicksilver
08:26:44 --- mode: quicksilver set -b 147!*@*
08:27:30 --- mode: quicksilver set -b *!*9113f8f4@*.145.19.248.244
08:27:30 --- mode: quicksilver set -b *!*9113fa8c@*.145.19.250.140
08:27:30 --- mode: quicksilver set -b *!*9113f99a@*.145.19.249.154
08:27:37 --- mode: quicksilver set -o quicksilver
08:28:22 <drdo> Is there something i can use to print out where a Maybe computation fails?
08:29:58 <rostayob> drdo: what do you mean "a maybe computation fails"?
08:30:18 <ksf> is there a way to completely disable the safe infrastructure?
08:30:30 <ksf> separate compilation seems to utterly mess things up.
08:30:42 <ClaudiusMaximus> > fail "oops" :: Maybe Int
08:30:43 <kmc> you might have an easier time in GHC 7.4; it's been reworked
08:30:43 <lambdabot>   Nothing
08:30:47 <drdo> rostayob: The first time you get a Nothing in there
08:30:51 <ksf> kmc, heh.
08:30:55 <ClaudiusMaximus> > fail "oops" :: Either String Int
08:30:55 <lambdabot>   *Exception: oops
08:30:57 <ksf> 7.4 doesn't build for me.
08:31:14 <rostayob> drdo: ? can you give an example?
08:31:31 <rostayob> you mean when you expect a Just and you get a Nothing?
08:31:44 <drdo> foo >>= bar >>= lol >>= wtv
08:31:57 <drdo> If the result is a Nothing, i want to know where it came from
08:32:07 <kmc> drdo, no there's not; you can use a richer error-handling monad like (Either String)
08:32:08 <rostayob> ah. you can't
08:34:22 * ksf would expect there to be a "dammit don't bother about -XSafe just let me compile"-flag.
08:36:39 <drdo> hmm
08:37:02 <drdo> Couldn't I just use something like Maybe but have bind do an unsafePerformIO ?
08:37:16 <rostayob> drdo: you could
08:37:26 <rostayob> drdo: just use Debug.Trace
08:37:59 <rostayob> which does what you want more or less, but you don't have to unsafePerformIO explicitly
08:38:41 <rostayob> but kmc is right, you should use some more informative error monad
08:38:50 <rostayob> unless you're just debugging
08:39:23 <drdo> just debugging
08:39:29 <rostayob> yeah then go for Debug.Trace
08:39:47 <drdo> but wouldn't i have to sprink trace's everywhere?
08:39:50 <rostayob> yes
08:39:51 <drdo> it's quite a huge thing
08:39:58 <rostayob> but printing something on >>= wouldn't help much
08:40:12 <rostayob> you can't print any relevant information to the context
08:40:19 <kmc> in GHC HEAD there is a function to print a stack backtrace
08:40:23 <kmc> added to Debug.Trace
08:40:25 <drdo> I can print the other value
08:40:29 <drdo> that is not a nothing
08:40:29 <kmc> but, no luck in released GHC
08:40:33 <rostayob> drdo: yeah I guess, you can do that
08:40:34 <kmc> the other value is a function
08:40:39 <rostayob> oh, true
08:40:42 <rostayob> you can't do that :P
08:41:17 <drdo> shit, true
08:41:34 <kmc> well you can do something like:  Just x >>= f  = case f x of Nothing -> trace ("failed after " ++ show x) Nothing;  y -> y
08:41:50 <parcs``> why is ghci warning me that my ~/.ghci is writable by someone else
08:42:06 <parcs``> (which it is not), and who cares
08:42:07 <drdo> kmc: oh yes
08:42:21 <kmc> whoever can write to ~/.ghci can make your user execute arbitrary code
08:43:37 <parcs``> patrick:patrick owns the file and the permissions are 664 i believe
08:43:44 <parcs``> effectively no one but me can write to it
08:43:49 <kmc> so other users in that group could write to it
08:44:15 <kmc> it's probably just checking a mask of 022
08:45:03 <dmwit> ?quote oasis
08:45:03 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
08:45:13 <parcs``> good point on the arbitrary code thing
08:45:54 <donri> :!rm -rf /
08:46:11 <donri> ok more like rm ~
08:56:39 <monochrom> haha, on haskell-cafe, skipping "If you'd design a Haskell-like language, what would you do different?" reduces the volume by half :)
08:57:07 <ksf> ...i'd leave out unary minus.
08:57:29 <ksf> it's got no syntactic, semantic, or other kind of warrant.
08:57:30 <monochrom> haha, now I have got #haskell on it
08:57:33 <drdo> Hmm, Monad doesn't require for the thing to be in Show, so i can't use Monad, but then i can't use do notation, which my code uses a lot of
08:58:00 <russellw> What syntax would you use instead of unary minus? 'negate'? Or just subtract from zero?
08:58:09 <rostayob> russellw: negate
08:58:12 <ksf> subtract from zero, yes.
08:58:12 <rostayob> which is already there
08:58:26 <russellw> Fair enough, makes sense
08:58:36 <sw17ch> show (negate 9) --> "negate 9"
08:58:37 <sw17ch> ?
08:58:46 <monochrom> I would keep unary minus but change it to --
08:58:46 <quicksilver> ksf: would you make it part of the syntax of numeric literals though?
08:58:52 <rostayob> > show (negate 9)
08:58:53 <lambdabot>   "-9"
08:58:59 <ksf> sw17ch, nah, showing it as 0-9 would be better.
08:59:06 <ksf> not relying on imports, that is.
08:59:10 <rostayob> sw17ch: how the show function behaves has nothing to do with -, the unary operator :P
08:59:13 <saati> @pl tf a = trace (show a) a
08:59:14 <lambdabot> tf = trace =<< show
08:59:20 <ksf> map's fromList serialisation is also dodgy.
08:59:23 <saati> how can i make this work?
08:59:29 <saati> No instance for (Monad ((->) b0))
08:59:36 <sw17ch> ksf, rostayob, I'm aware. it's just nice to have some reflexivity there.
09:00:12 <rostayob> well another thing that'd be nice to have is a nice hierarcy of type classes for Functor, Applicative, Pointed, Monad
09:00:20 <sw17ch> and representing show (negate 9) as "0 - 9" seems like the wrong path as well. less ambiguous, yes, but correct? ehhh...
09:00:58 <monochrom> the post I like most in that thread is "a mascot" :)
09:00:58 <rostayob> sw17ch: I don't think displaying "-9" is ambiguous. the unary minus is ugly because it's an exception (haskell doesn't permit unary operators)
09:01:13 <rostayob> but when showing the number is ok imho
09:01:44 <sw17ch> i can buy that
09:01:58 <sw17ch> so, leave show as is, just murder unary operators (all one of them)
09:02:09 <monochrom> theorem: haskell implementations don't use Read instances to parse source code
09:02:12 <rostayob> sw17ch: there's only one
09:02:22 <rostayob> -
09:02:34 <sw17ch> rostayob: hence my parenthetical statement ;)
09:02:43 <kmc> drdo, you can define your own (>>=) with a different type, and then use ghc -XNoImplicitPrelude
09:03:19 <Saizan> it's ugly if you can't paste the output of show back into your source code
09:03:21 <rostayob> sw17ch: ah, i missed the "one" :)
09:03:31 <monochrom> theorem: haskell implementations don't use Read instances to parse source code
09:04:02 <kmc> i think Show should mostly be derived, and used for testing / debugging only
09:04:04 <kmc> ditto Read
09:04:10 <Waldteufel> would it be a problem to allow ‚Äû-9‚Äú (no spaces) in source code but not ‚Äû- (x * 3 + y)‚Äú?
09:04:14 <Saizan> monochrom: so?
09:04:53 <monochrom> don't paste show output into source code. or, paste it with an explicit call to read.
09:04:58 <rostayob> Waldteufel: so have the - embedded in number literals?
09:05:02 <rostayob> that's actually not a bad idea
09:05:13 <kmc> this is the solution i favor
09:06:49 <Saizan> monochrom: it's nice to be able to
09:07:29 <drdo> kmc: And if i define a class named Monad i get do notation?
09:07:46 <kmc> class does not matter
09:07:55 <kmc> it just desugars "do" with whatever (>>=) is in scope
09:08:00 <drdo> oh ok
09:08:10 <kmc> (and 'fail' and maybe (>>))
09:08:22 <kmc> without -XImplicitPrelude it uses (Prelude.>>=)
09:08:24 <kmc> err
09:08:30 <kmc> without -XNoImplicitPrelude it uses (Prelude.>>=)
09:08:49 <Qaxz> Hmm
09:08:59 <drdo> Hmm, but i do use stuff from Control.Monad and Control.Monad.State
09:09:02 <Qaxz> So you can actually shadow (>>=) and break do?
09:09:07 <kmc> yes
09:09:14 <kmc> with ghc -XNoImplicitPrelude
09:09:23 <Qaxz> DAmn u haskell, y u no have hygienic macros?
09:09:42 <kmc> what does this have to do with macros
09:09:52 <drdo> do is a macro
09:09:55 <donri> and how is template haskell not hygienic?
09:10:20 <kmc> haskell doesn't "have" template haskell, it's an extension
09:10:35 <donri> drdo: how would you know, do you have like a doctorate in do-notation or something
09:10:39 <drdo> haskell for all pratical purposes really means "what ghc does" :P
09:10:47 <kmc> no, that's stupid
09:11:07 <kmc> but anyway TH has the property that a macro expands using the definition was in scope when the macro was defined, not where it's used
09:11:09 <kmc> by default
09:11:18 <kmc> that seems like the relevant "hygenic" property
09:11:20 <cheater> "haskell is anything that you can find in a .hs file"
09:11:37 <kmc> dd if=/dev/urandom of=foo.hs count=1
09:12:33 <donri> {-# OPTIONS_GHC -pgmF "cat /dev/urandom" #-}
09:12:48 <sw17ch> donri++
09:17:50 <kmc> there are many good reasons to distinguish "Haskell" from "what GHC implements this week" even if you're only using GHC
09:19:50 <DukeDave> Is there a "Wikipedia similar product comparison table"-esque summary of Haskell compilers somewhere?
09:20:12 <geheimdienst> this may sound silly, but where is runErrorT? grep doesn't find it in mtl, and also not in mtl's dependencies (transformers + base)
09:20:21 <kmc> @hoogle runErrorT
09:20:21 <lambdabot> Control.Monad.Error runErrorT :: ErrorT e a -> m (Either e a)
09:20:22 <lambdabot> Control.Monad.Trans.Error runErrorT :: ErrorT e m a -> m (Either e a)
09:20:35 <geheimdienst> (or am i doing it wrong? how do you normally tell an ErrorT to do its thing?)
09:21:06 <DukeDave> Ala: http://en.wikipedia.org/wiki/Comparison_of_BitTorrent_clients#Applications
09:21:20 <kmc> there is http://www.haskell.org/haskellwiki/Implementations
09:21:22 <kmc> not a chart though
09:21:50 <geheimdienst> clarification: i mean, where is runErrorT defined. i can use it when i say import C.M.Error, but i'd like to see how it's implemented
09:22:49 <kmc> :i runErrorT
09:22:50 <kmc> newtype ErrorT e m a = ErrorT {runErrorT :: m (Either e a)}  -- Defined in Control.Monad.Trans.Error
09:24:30 <kmc> also http://en.wikipedia.org/wiki/Haskell_(programming_language)#Implementations
09:26:26 <geheimdienst> kmc: thanks, but that's only the type, right?
09:27:14 <geheimdienst> ah whatever ... i give up
09:27:28 <parcs``> geheimdienst, runErrorT is the field name
09:28:20 <geheimdienst> parcs``: oh right!
09:28:57 <geheimdienst> the penny is maybe not dropping, but at least uncontrolledly rolling around near the edge
09:29:27 <parcs``> all runErrorT does is unwraps the ErrorT newtype
09:30:49 <geheimdienst> yeah, got it now. there's things like "ErrorT f" in the code. i somehow fixated on the thought "there must be 'runErrorT ... = ...' somewhere"
09:31:07 <geheimdienst> thanks guys, i guess it was more of a brainfart on my part
09:31:53 <HaskellElephant> I recently asked why init is a partial function on Stackoverflow: http://stackoverflow.com/questions/8591359/why-is-init-a-partial-function , but I am having hard time trying to understand why invariants play a part
09:32:57 <HaskellElephant> if I have an invariant, say length xs == 1 + length (init xs) , I have to assume it type checks, so xs has to be a list, furthermore I have to assume xs is nonempty so that init is defined for it
09:33:53 <HaskellElephant> So when writing it out it is, (xs :: [a] and xs /=[]) => length xs == 1 + length (init xs)
09:34:13 <HaskellElephant> So I don't see any harm in defining init for empty list. Am I missing something?
09:34:18 <c_wraith> yes.
09:34:46 <c_wraith> length [] = 0.  1 + length (init xs) = 1, with your proposal
09:34:54 <c_wraith> err, 1 + length (init [])
09:35:20 <c_wraith> you're assuming init has both behaviors at once
09:35:30 <HaskellElephant> Yes, that is true but the invariant doesn't hold at all when xs /= [] in the first place
09:35:41 <HaskellElephant> sorry when xs == []
09:36:09 <c_wraith> Well, it does, in that it doesn't result in "1" as a result.
09:36:24 <c_wraith> It doesn't actually have a result, denotationally
09:36:36 <HaskellElephant> yes, that is the part I don't understand...
09:37:01 <HaskellElephant> You might say I don't understand why that is "nice" =D
09:37:17 <etpace> @hoogle Either a b -> Either a b' -> Either a (b, b')
09:37:18 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
09:37:42 <c_wraith> HaskellElephant: I found http://en.wikibooks.org/wiki/Haskell/Denotational_semantics to be a useful introduction to the concept of denotational semantics
09:38:15 <HaskellElephant> Thank you c_wraith, I will have a look at that
09:39:40 <dmwit> HaskellElephant: The answer to your question points at another question; did you read that other question (and its answer)?
09:39:58 <HaskellElephant> Yes, I looked into it dmwit.
09:40:00 <dmwit> It actually gives an invariant that would be broken (unlike the one you posted here).
09:40:31 <HaskellElephant> Oh really? Wich one?
09:40:45 <dmwit> f (init []) = init (map f [])
09:41:10 <Saizan> that doesn't typecheck
09:41:14 <dmwit> for all f
09:41:20 <dmwit> err
09:41:26 <dmwit> quite, the example given was for head
09:41:32 <dmwit> ?free [a] -> [a]
09:41:33 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
09:41:43 <dmwit> ?free init :: [a] -> [a]
09:41:43 <lambdabot> $map f . init = init . $map f
09:42:02 <dmwit> Okay, then the troublesome equation is
09:42:10 <dmwit> map f (init []) = init (map f [])
09:42:17 <HaskellElephant> Yes, that was what made it a bit weird for me, I totally get head [] being undefined, so I didn't read so much of that question.
09:42:42 <sw17ch> > init [1,2,3]
09:42:43 <lambdabot>   [1,2]
09:43:00 <dmwit> hm, yes, okay, so the comments about head don't apply to init
09:43:01 <Saizan> dmwit: that holds if you make init [] = []
09:43:03 <dmwit> So that's interesting.
09:43:21 <monochrom> > init []
09:43:21 <lambdabot>   *Exception: Prelude.init: empty list
09:43:27 <monochrom> ah, interesting
09:43:31 <HaskellElephant> Well, doesn't map f (init xs) == init (map f xs) hold even if init [] == [] ??
09:43:33 <ClaudiusMaximus> > liftM2 (liftM2 (,)) [Left "foo", Right 'x'] [Left "bar", Right "X"] -- etpace  (with Control.Monad.Instances)
09:43:34 <lambdabot>   [Left "foo",Left "foo",Left "bar",Right ('x',"X")]
09:43:36 <geheimdienst> HaskellElephant: you know, the more we talk about it, the less clear it is to me that init must be partial ...
09:43:45 <dmwit> HaskellElephant: Yes, you're right.
09:44:10 <geheimdienst> obviously "head []" or "last []" can't give you an element out of nothing, but for init and tail it's less clear
09:44:14 <Saizan> in fact, free theorems must hold for total functions, regardless of how they are defined
09:44:28 <dmwit> indeed
09:45:03 <monochrom> the free theorem contains the fact that you can't define init [] = [True]
09:45:10 <dmwit> Alright, so here's my answer. "head" makes sense, and "tail" is supposed to be analogous to "head", so it is undefined exactly when head is.
09:45:22 <monochrom> > last []
09:45:22 <HaskellElephant> If I would rule the world I would make init give "all the elements that are not the last element" ie. init [] should be [] since there are no such elements.
09:45:23 <lambdabot>   *Exception: Prelude.last: empty list
09:45:29 <dmwit> Similarly, "last" makes sense, and "init" is supposed to be analogous to "last", so *it* is undefined exactly when last is.
09:45:44 <dmwit> If you want the version that is defined everywhere, you can implement it yourself, of course.
09:45:55 <HaskellElephant> Yes, I define that all the time.
09:46:11 <Saizan> i think xs = init xs ++ [last xs] is the crucial one, [] /= [ _|_ ], so init [] should be _|_ :P
09:46:14 <HaskellElephant> I just wanted to understand the reason why init is that way
09:46:18 <dmwit> So, there's no reason other than "to be symmetric with head" or "to be symmetric with last", respectively.
09:46:55 <dmwit> Saizan: but [] /= _|_, so your equation isn't true even for the current definition of xs.
09:47:06 <dmwit> s/xs/init/
09:47:10 <monochrom> > inits []
09:47:11 <lambdabot>   [[]]
09:47:13 <HaskellElephant> Oh, so in a way you would want init xs == [x | x != last xs]¬†in a way?
09:47:20 <monochrom> > inits [True]
09:47:21 <lambdabot>   [[],[True]]
09:48:23 <Saizan> dmwit: ah, true, but i guess at least lub [] _|_ = []
09:48:32 <chadz> anyone here familiar with vty-ui? i'm thinking of ways to dynamically proportion ui elements in response to resizing
09:49:27 <Saizan> xs = head xs : tail xs doesn't hold even in that sense
09:50:16 <HaskellElephant> What do you mean Saizan? I didn't get it, when doesn't xs == head xs :tail xs hold?
09:50:33 <dmwit> HaskellElephant: when xs == []
09:50:34 <monochrom> [] = head [] : tail []
09:50:48 <HaskellElephant> ofcourse not, head is undefined for []
09:51:00 * dmwit feels as if we're going in circles
09:51:04 <chadz> haha
09:51:07 <HaskellElephant> He he he
09:51:15 <chadz> is head [] were [], what would break?
09:51:17 <monochrom> more pointedly, [] = ?:? doesn't fly
09:51:24 <dmwit> chadz: head wouldn't be well-typed
09:51:26 <chadz> does any code rely on that exception? haha
09:51:31 <chadz> how not?
09:51:44 <dmwit> head :: [a] -> a -- note the lack of "list" brackets in the return type
09:51:44 <Saizan> head :: [a] -> a
09:51:48 <monochrom> if head [] were [], type error. THE END.
09:51:51 <geheimdienst> HaskellElephant: it seems to me it's largely tradition. at the time they made the choice that head-tail and init-last should be pairs, i.e. they should all give 'error' for []. imho they could plausibly have made the other choice with tail [] and init [] working, and head [] and last [] erroring
09:51:51 <chadz> ohm, duh
09:51:54 <chadz> lol
09:52:05 <dmwit> geheimdienst++
09:52:05 <monochrom> if you use scheme, I would understand
09:52:24 <chadz> Maybe a would be a bit too heavyweight
09:52:35 <dmwit> (for believing the same answer as me)
09:53:23 <Saizan> anyhow, you shouldn't use any of these much :P
09:53:49 <HaskellElephant> geheimdienst: That is what I would do if I was simon, err I mean king =D ...
09:55:09 <Yrogirg> hey, does anybody have a link to the ghc bug about compile-time calculation of numeric constants? That is for example  sin(3 + (exp 7)) is not evaluated during compilation.
09:55:15 <HaskellElephant> Saizan: yea, but for some reason whenever I need to fix something quick my brain goes "Oh I'll use init/tail" when in fact I would want the safe behavior
09:56:44 <dmwit> Well, "drop 1" is a nice quick drop-in replacement for tail.
09:56:54 <dmwit> Nothing as succinct exists for init, but you can do
09:56:57 <monochrom> is that a bug? sin(3 + (exp 7)) is too polymorphic for compile-time
09:57:02 <dmwit> \xs -> zipWith const xs (drop 1 xs)
09:57:25 <dmwit> ?pl \xs -> zipWith const xs (drop 1 xs)
09:57:25 <lambdabot> zipWith const `ap` drop 1
09:57:35 <dmwit> infix ap???
09:57:46 <dmwit> Oh lambdabot, you card!
09:57:54 <Yrogirg> oh, found it http://hackage.haskell.org/trac/ghc/ticket/4101
10:03:41 <mizu_no_oto> Is there any way to just create a nominalDiffTime?  I'd like to do something like "diffAndRoundToNearestMin = (* min) . floor . (/ min) . diffUTCTime", but I can't see how to construct a NominalDiffTime (i.e. min) except by creating two UTCTimes which are a minute apart and using diffUTCTime, which seems like a massive kludge
10:04:22 <dmwit> NominalDiffTime is an instance of Num
10:04:38 <dmwit> so... (*60) . etc.
10:05:04 <dmwit> As with the rest of the "time" package, all the magic is in the instances.
10:05:26 <hpaste> AndrewC pasted ‚ÄúGtk2Hs installation probs‚Äù at http://hpaste.org/55554
10:05:54 <mizu_no_oto> ah
10:06:25 <mizu_no_oto> So can haskell read any numeric literal as an instance of anything which is a Num?
10:06:36 <dmwit> :t 60
10:06:37 <lambdabot> forall t. (Num t) => t
10:06:38 <parcs``> HaskellElephant, take a look at the "safe" package
10:06:44 <dmwit> mizu_no_oto: That answer your question?
10:06:45 <donri> @instances Num
10:06:47 <lambdabot> Double, Float, Int, Integer
10:06:54 <donri> :t 60 :: Double
10:06:55 <lambdabot> Double
10:06:57 <mizu_no_oto> dmwit: yes
10:07:05 <geheimdienst> mizu_no_oto: note that "123 :: NominalDiffTime" works in ghci, if you have Data.Time imported
10:08:04 <dmwit> AndrewC: Just to double-check, are you following the "Building on Windows" instructions found at http://code.haskell.org/gtk2hs/INSTALL ?
10:25:20 <monochrom> oh shoot, ghc 7.4.1 is now doing rc
10:25:49 <OceanSpray> why 7.4.1
10:26:02 <tgeeky> sweet, today?
10:26:16 <monochrom> yeah
10:26:38 <sw17ch> rc?
10:26:45 <OceanSpray> also, http://hackage.haskell.org/trac/ghc/milestone/7.4.1
10:26:49 <OceanSpray> 34%?
10:26:53 <monochrom> release candidate
10:30:06 <mroman> Can I somehow "Wildcard" Match Patterns?
10:30:07 <mroman> like
10:30:25 <tgeeky> once nice feature of 7.4.1 (hopefully it's done) is that you can essentially "paste" code into GHCI and it will just work
10:30:28 <mroman> foobar (Bar a) = Bar $ a + a
10:30:35 <mroman> foobar (Baz a) = Baz $ a + a
10:30:41 <tgeeky> since all top-level stuff is supported
10:30:44 <mroman> => foobar (m a) = m $ a + a ?
10:30:54 <monochrom> cannot
10:30:55 <c_wraith> mroman: no, there's no support for that.
10:31:52 <mroman> http://codepad.org/FR0HQRVk <- because this looks awfully verbose.
10:32:39 <c_wraith> mroman: a slight refactoring of that can give you something better.  Replace all of Mul, Add, Div, Sub with a single BinOp constructor, that takes 3 args.
10:32:51 <c_wraith> and its first arg is what operation
10:33:04 <c_wraith> Then things that work purely on the structure can ignore what the operation is
10:33:10 <c_wraith> But things that care have it right there
10:33:22 <roconnor> mroman: you need multiplate
10:33:38 <roconnor> mroman: (or regular old uniplate)
10:33:46 <c_wraith> roconnor: I think going directly to generic programming is a bit over-the-top with what looks like a homework assignment
10:34:02 <roconnor> god
10:34:27 <roconnor> is it just me or are homework assignments training people to write terrible haskell code.
10:34:57 <monochrom> it is just you
10:34:58 <mroman> You may substitute haskell with any arbitary language ;)
10:35:15 <c_wraith> mroman: does my suggestion make sense?
10:35:28 <mroman> c_wraith: Yes.
10:35:33 <c_wraith> (also, is it something you'd be allowed to do in the context of what's going on?)
10:35:41 <mroman> That's a very good an easy suggestion.
10:35:52 <mroman> c_wraith: Yes @allowed
10:36:04 <c_wraith> well, then, sounds like it's helpful for this case.
10:36:23 <roconnor> monochrom: how come whenever anyone asks a homework question, my awesome solution isn't allowed?
10:36:45 <monochrom> it is awesome to you
10:36:50 <geheimdienst> roconnor: maybe the it isn't elegant, but at least it's practical real-world code. i write pocket calculator languages with constants and four operations all the time, for all kinds of things ;)
10:37:00 <monochrom> in any case, it is allowed, sure
10:37:09 <mroman> It would be allowed.
10:37:19 <mroman> But it'd much more complicated.
10:37:23 <roconnor> geheimdienst: multiplate isn't real world code?
10:37:30 <mroman> (I actually had to read what multiplate is :) )
10:37:33 <monochrom> someone was just saying it has a high cost
10:37:38 <mroman> *I'd have to
10:38:19 * roconnor vows to patch ghc to use multiplate
10:38:33 <monochrom> and I will just add that it goes against the pedagogical progression of from concrete to abstract, specific to general
10:38:44 <roconnor> monochrom: I guess that is true
10:39:15 <roconnor> mroman: okay, but just remember there are advanced libraries to make what you are writing less terrible.
10:39:33 <roconnor> mroman: so don't dismiss haskell because of this ugly code.
10:40:05 <monochrom> you are encouraged to suggest switching to agda for every haskell homework question, on the ground that agda is less terrible than haskell
10:40:36 <roconnor> monochrom: funny, that hasn't really come up yet
10:40:59 <mroman> roconnor: I wouldn't dare to dismiss haskell :)
10:40:59 <monochrom> I'll do it next time
10:42:04 <roconnor> monochrom: when do monoidal natural transformations come up in the CS curriculum?
10:42:33 <geheimdienst> mroman: i'd think of that homework as smelly because of all the copy-pasted lines with one tiny change. but when you're just starting they sometimes have you do smelly things or take the long route, just to have seen it
10:43:05 <mroman> It's not exactly homework, actually.
10:43:12 <mroman> Let's call it "learning by doing".
10:43:18 <mroman> Homework is Java only ;)
10:43:29 <tigger_> Hi there, I'm writing a typeclass here: https://gist.github.com/1507263, where there is some input (type a), and a state machine (type b), and an output type (type c), I'm just wondering if there was something with state monads that I could just use instead, to express this idea.
10:44:28 <roconnor> @hoogle mapAccum
10:44:29 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:44:29 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
10:44:29 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:44:31 <mroman> But I like to write the "same" code in haskell.
10:45:35 <eviltwin_> is there a function in haskell which, given an int, will return the int with the appropriate "st" "nd" "rd" "th" prefix as a string?
10:46:13 <roconnor> eviltwin_: nice
10:46:16 <roconnor> er
10:46:18 <roconnor> no
10:46:24 <eviltwin_> damn
10:46:32 <eviltwin_> oh well, it's a quickie to write :)
10:46:32 <mroman> let gimme n = (show n) ++ (["st","nd","rd"]++(cycle ["th"]))!!n ?
10:46:43 <roconnor> monochrom: 31th?
10:46:45 <roconnor> er
10:46:49 <monochrom> except for 11st
10:46:50 <roconnor> mroman: 31th?
10:46:51 <geheimdienst> eviltwin_: i don't think so, but it shouldn't be too difficult to write (you know about (%), right?)
10:47:05 <eviltwin_> yes, I can write it
10:47:07 <mroman> roconnor: Oh. right.
10:47:28 * roconnor isn't sure he can even write it
10:47:31 <eviltwin_> but it seemed interesting and generic enough for me to wonder if there was a library for it somewhere
10:47:42 <eviltwin_> roconnor: would using a guard seem like cheating?
10:47:53 <monochrom> I think people decided to not bother.
10:48:10 <eviltwin_> thinking about it, if I peak inside a date formatting library I might find it ;)
10:48:45 <monochrom> a date formatting library doesn't do 101st or 111th
10:49:41 <roconnor> sorry, I mean I that I don't think I can write this function
10:49:49 <monochrom> unless some format still goes "the 2011th year of our lord" but I doubt it
10:50:10 <roconnor> eviltwin_: guards seem reasonable here
10:50:28 <mroman> is it 30th?
10:50:39 <monochrom> thirtieth
10:50:48 <eviltwin_> ys
10:50:50 <eviltwin_> yes*
10:51:19 <roconnor> I wonder if there are internationalization libraries for haskell :D
10:51:37 <mroman> gimme d = (show d) ++ ("th":"st":"nd":"rd":(cycle ["th"]))!!(d `mod` 10)
10:51:49 <mroman> in that case :)
10:52:08 <mroman> roconnor: Good question :)
10:52:37 <sal23> let gimme n = (show n) ++ (["st","nd","rd"]++(cycle ["th"]))!!((n - 1) `rem` 10)
10:53:27 <mroman> Crashes if n = 0.
10:53:54 <mroman> or not.
10:53:58 <sal23> mroman, is there ever a date zero?
10:54:56 <mroman> Nobody said anything about dates.
10:55:51 <monochrom> @let gimme n = (show n) ++ (["st","nd","rd"]++(cycle ["th"]))!!((n - 1) `rem` 10)
10:55:53 <lambdabot>  Defined.
10:55:57 <monochrom> > gimme 1
10:55:59 <lambdabot>   "1st"
10:56:02 <sal23> ahem, from the discussion, it seemed it was for date
10:56:03 <mroman> > gimme 0
10:56:04 <monochrom> > gimme 11
10:56:04 <geheimdienst> eviltwin_: er, i'm an idiot, i confused `mod` and (%) earlier :-) just a heads-up
10:56:05 <lambdabot>   "0*Exception: Prelude.(!!): negative index
10:56:05 <lambdabot>   "11st"
10:56:28 <monochrom> on the elevenst day of christmas my true love sent to me...
10:56:34 <mroman> oh yeah. Lines later. My mistake.
10:56:47 <mroman> Do you use th for 0?
10:56:49 <mroman> like
10:56:53 <mroman> the 0th element of a list?
10:56:58 <monochrom> zeroth. yes.
10:57:05 <monochrom> or maybe zeroeth.
10:57:15 <eviltwin_> geheimdienst: no problem, I got what you were suggesting :)
10:57:39 <monochrom> I have just long decided to screw it all and say "items #0, #1, and #11 in the list"
10:58:24 <monochrom> it also generalizes to "items #n and #(n+1)". none of that "n+1st" nonsense
10:59:19 <sal23> @let gimme n = (show n) ++ (["st","nd","rd"]++(cycle ["th"]))!!(if n > 0 then (n - 1) `rem` 10 else 3)
10:59:19 <lambdabot>  <local>:4:0:
10:59:19 <lambdabot>      Warning: Pattern match(es) are overlapped
10:59:19 <lambdabot>               In...
10:59:32 <sal23> > gimme 0
10:59:34 <lambdabot>   "0*Exception: Prelude.(!!): negative index
10:59:40 <monochrom> use @undefine to erase mine first
10:59:53 <sal23> @undefine gimme
11:00:08 <hpaste> ‚ÄúGraham Lyon‚Äù pasted ‚Äúindex postfixes‚Äù at http://hpaste.org/55557
11:00:10 <sal23> @let gimme n = (show n) ++ (["st","nd","rd"]++(cycle ["th"]))!!(if n > 0 then (n - 1) `rem` 10 else 3)
11:00:10 <lambdabot>  Defined.
11:00:15 <sal23> > gimme 0
11:00:17 <lambdabot>   "0th"
11:00:21 <sal23> > gimme 9
11:00:22 <lambdabot>   "9th"
11:00:23 <monochrom> in fact it erases everything. you can just @undefine, or you can @undefine nothing
11:00:33 <sal23> thanks for tip
11:00:37 <wereHamster> is there a way to construct a UTCTime when I have the unix timestamp (seconds) and timezone offset as Num/Int?
11:00:43 <eviltwin_> see the paste :)
11:01:01 <roconnor> wereHamster: I think so
11:01:03 <wereHamster> the only way I found is to use parseTime.. but that seems stupid if I already have the data in numeric format
11:01:46 <sal23> if I were to define a Storable instance for ForeignPtr, what would it look like? Just store a ptr to ForeignPtr?
11:02:02 <roconnor> @hoogle minutesToTimeZone
11:02:02 <lambdabot> Data.Time.LocalTime minutesToTimeZone :: Int -> TimeZone
11:02:08 <roconnor> @hoogle hoursToTimeZone
11:02:08 <lambdabot> Data.Time.LocalTime hoursToTimeZone :: Int -> TimeZone
11:02:33 <roconnor> @hoogle ZonedTime
11:02:33 <lambdabot> Data.Time.LocalTime ZonedTime :: LocalTime -> TimeZone -> ZonedTime
11:02:33 <lambdabot> Data.Time.LocalTime data ZonedTime
11:02:33 <lambdabot> Data.Time.LocalTime zonedTimeToLocalTime :: ZonedTime -> LocalTime
11:02:45 <roconnor> @hoogle zoneTimeToUTC
11:02:45 <lambdabot> No results found
11:02:48 <roconnor> @hoogle zonedTimeToUTC
11:02:48 <lambdabot> Data.Time.LocalTime zonedTimeToUTC :: ZonedTime -> UTCTime
11:03:30 <roconnor> wereHamster: I think some combination of hoursToTimeZone/MinutesToTimeZone with ZonedTime and zonedTimeToUTC will work
11:03:40 <roconnor> wereHamster: I'm looking for something a bit simpler
11:03:53 <roconnor> wereHamster: what is the data you have again?
11:03:55 <wereHamster> I'd still have to figure out how to create a LocalTime, right?
11:04:19 <wereHamster> roconnor: unix timestamp (seconds since epoch) and zone in offset
11:04:36 <roconnor> wereHamster: aren't unix timestamps in UTC more or less?
11:04:54 <wereHamster> I think so
11:05:01 <roconnor> wereHamster: So the time zone is irrellevent
11:05:20 <roconnor> wereHamster: just use posixSecondsToUTCTime
11:05:38 <roconnor> http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Clock-POSIX.html
11:05:43 <wereHamster> and how do I create POSIXTime ?
11:05:50 <roconnor> wereHamster: use realToFrac
11:08:04 <monochrom> wait, create from what?
11:08:22 <roconnor> monochrom: from a unix timestamp
11:08:46 <monochrom> alright then
11:20:05 <wereHamster> works beautifully, thanks
11:20:39 <roconnor> good to know
11:25:11 <mdxbhmt> Ayone willing to discuss this ?  http://www.reddit.com/r/haskell/comments/njejk/convertion_string_to_bytestring_done_by_the/
11:27:26 <mee> you'll probably have better luck if you just throw your question out in the open
11:28:36 <krakrjak> Is there a better way to write ["pi"|x <- [3.01,3.02..4], x == 3.14]?
11:29:09 <monochrom> > ["pi"|x <- [3.01,3.02..4], x == 3.14]
11:29:09 <lambdabot>   []
11:29:16 <monochrom> apparently, yes :)
11:29:19 <krakrjak> It never matches due to floating point rounding errors.
11:29:44 <mdxbhmt> > [3.01,3.02..3.2]
11:29:45 <lambdabot>   [3.01,3.02,3.0300000000000002,3.0400000000000005,3.0500000000000007,3.06000...
11:29:51 <krakrjak> > ["pi"|x <- [3.0,3.1..4], x == 3.1]
11:29:52 <lambdabot>   ["pi"]
11:29:59 <yrlnry> close_enough(x, 3.14) where close_enough(a,b) = abs(a-b) < epsilon where epsilon = ...;
11:30:21 <monochrom> don't rely on x==3.14. see http://floating-point-gui.de/errors/comparison/
11:30:37 <rwbarton> > ["pi"|x <- [3.01,3.02..4], x == 3.14 :: Rational]
11:30:37 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
11:30:37 <lambdabot>         against inferred t...
11:30:45 <rwbarton> > ["pi"|x <- [3.01,3.02..4], x == (3.14 :: Rational)]
11:30:45 <lambdabot>   ["pi"]
11:31:22 <krakrjak> rwbarton: thanks!  In my code it was using RealFloat and just wouldn't work.
11:31:54 <rwbarton> monochrom's advice is also good.
11:32:18 <mdxbhmt> you also shouldnt make your list like that
11:32:29 <mdxbhmt> it's accumulating sum errors
11:32:45 <yrlnry> floating-point numbers suck.
11:33:18 <krakrjak> I wanted an easy fixed point for this as it's only a toy...  Am I missing something?
11:33:38 <mdxbhmt> what you expect as output?
11:33:48 <krakrjak> "pi"
11:34:38 <monochrom> there is Data.Fixed
11:35:06 <krakrjak> Yeah I saw that.  I'm still too much of a neophyte to take advantage of it yet...
11:35:16 <mdxbhmt> it's not happening because you never get x=3.14, you actually have 3.140000000000003
11:35:42 <krakrjak> mdxbhmt: right...  Which to me is a strange "feature" of the texas ranges.
11:36:11 <mdxbhmt> krakrjak: texas range?
11:36:13 <rwbarton> it's a "feature" of floating point
11:36:22 <krakrjak> in the 3.1 case using 0.1 steppings it will always match.  When you move to 0.01 steppings you get 100 intermediate values that are not locked into that stepping.
11:36:46 <mdxbhmt> it's because the list is done by sum
11:36:48 <krakrjak> rwbarton: right it happens in every language.  I thought I might dodge the issue in haskell....  guess not.
11:37:11 <mdxbhmt> each new value is build with the precedent, so the error goes up
11:37:14 <monochrom> well, Rational dodges the issue
11:37:28 <mdxbhmt> if you build your list with independent values is going to work
11:37:40 <krakrjak> so the [3..9] or [2.01,2.02..3] both are implemented with sum?
11:38:07 <rwbarton> you can even use a "default" declaration to prefer Rational over Double
11:38:27 <krakrjak> monochrom: it does in that list comprehension...  When I add change RealFloat to Rational in the function's type definition ghci gives me an error:
11:38:38 <EvanR-work> > 2.345 + pi :: Data.Fixed
11:38:39 <lambdabot>   Not in scope: type constructor or class `Data.Fixed'
11:38:45 <EvanR-work> > 2.345 + pi :: Centi
11:38:46 <lambdabot>   No instance for (GHC.Float.Floating Data.Fixed.Centi)
11:38:46 <lambdabot>    arising from a use...
11:38:47 <rwbarton> RealFloat and Rational are not the same kind of thing
11:38:52 <EvanR-work> > 2.345 + 6.345 :: Centi
11:38:52 <lambdabot>   8.68
11:39:02 <rwbarton> @src RealFloat
11:39:02 <lambdabot> Source not found.
11:39:03 <mdxbhmt> >  ["pi"|x <- map (+3) $ map (*0.01) [1.. 100]], x == 3.14]
11:39:04 <lambdabot>   <no location info>: parse error on input `,'
11:39:35 <mdxbhmt> > ["pi"|x <- (map (+3) $ map (*0.01) [1.. 100]), x == 3.14]
11:39:36 <lambdabot>   ["pi"]
11:40:04 <mdxbhmt> (not a beauty, but you won't have float error)
11:40:15 <krakrjak> so the second map does the truncation to fixed point?
11:40:32 <EvanR-work> > realToFrac (3.14 :: Float) :: CReal
11:40:33 <lambdabot>   3.1400001049041748046875
11:40:38 <krakrjak> sorry I can read it now...  very nice!
11:40:47 <rwbarton> this solution is still playing with fire a bit
11:41:33 <monochrom> it is fine because the act of parsing "3.14" and the act of 3+14*0.01 are the same
11:41:33 <krakrjak> can you expand on the map still being a little hairy?
11:41:41 <mdxbhmt> I think that when i do 1:0.01:100 in matlab, it's making something like that
11:42:12 <mdxbhmt> krakrjak: what exactly?
11:42:19 <monochrom> also by map fusion it is map ((+ 3) . (* 0.01))
11:42:39 <EvanR-work> 0.01 is an independent undefined concept, and can have any value ;)
11:42:45 <EvanR-work> abstract basis
11:42:49 <monochrom> if you pointize it, it is map (\x -> x * 0.01 + 3)
11:43:35 <mdxbhmt> monochrom: great, that make the code much better
11:43:54 <krakrjak> mdxbhmt: I like that code and the map fusion version.  Saves the extra type requirements and module loading for Data.Fixed  I was just curious where the other gotchas are if any.
11:44:07 <Peaker> Floating point is one of the most painful corners of computing
11:44:18 <EvanR-work> another is finite memory
11:44:37 <EvanR-work> we need to fix both ;)
11:44:39 <mdxbhmt> And it's funny because they came from the infancy of computing
11:44:46 <mdxbhmt> they are still here*
11:44:58 <krakrjak> I guess we just haven't gotten them right yet...
11:45:00 <Peaker> mdxbhmt: why? It seems like it's an inherent trade-off
11:45:13 <Peaker> trade accuracy/simple-semantics for speed
11:45:18 <krakrjak> Even after 60-70 years....  One day... one day...
11:45:40 <EvanR-work> Peaker: whats more ideal (and possible), rationals?
11:45:54 <monochrom> rationals face memory issues
11:46:07 <EvanR-work> why?
11:46:27 <rwbarton> > sum [ 1 / n | n <- [1..20] ] :: Rational
11:46:27 <lambdabot>   55835135 % 15519504
11:46:31 <rwbarton> > sum [ 1 / n | n <- [1..100] ] :: Rational
11:46:32 <lambdabot>   14466636279520351160221518043104131447711 % 2788815009188499086581352357412...
11:46:37 <EvanR-work> relative to Integer?
11:46:37 <rwbarton> etc.
11:47:03 <monochrom> yes. twice the size of integer
11:47:03 <mdxbhmt> > sum [ 1 / n | n <- [1..100] ] :: Double
11:47:04 <lambdabot>   5.187377517639621
11:47:16 <EvanR-work> twice as big doesnt sound like an 'issue'
11:47:23 <rwbarton> relative to Double
11:47:26 <EvanR-work> thats like the differences between double and float
11:47:39 <mdxbhmt> it's much more than twice
11:47:59 <rwbarton> > sum [ 1 / n^2 | n <- [1..100] ] :: Double
11:48:00 <lambdabot>   1.6349839001848923
11:48:04 <dropdrive> How might I capture (in the type) the fact that a function depends on the value of the environment variable "$FOO"?
11:48:13 <rwbarton> > pi^2/6
11:48:13 <lambdabot>   1.6449340668482264
11:48:16 <rwbarton> > sum [ 1 / n^2 | n <- [1..100] ] :: Ratoinal
11:48:17 <lambdabot>   Not in scope: type constructor or class `Ratoinal'
11:48:18 <rwbarton> > sum [ 1 / n^2 | n <- [1..100] ] :: Rational
11:48:18 <EvanR-work> dropdrive: pass in the $foo
11:48:19 <Peaker> EvanR-work: Rationals have performance issues
11:48:19 <lambdabot>   158950869413303787311229792851755385970238349854370985988943283480381813109...
11:48:25 <Peaker> EvanR-work: I think it's an inherent pain
11:48:33 <Peaker> EvanR-work: for maximum performance, one must endure pain
11:48:48 <monochrom> if I just want integers between 0 and 100, I already know the memory bound. if I want rationals between 0 and 100, I don't know the memory bound. that is what I mean.
11:48:49 <yitz> by this time i'm sure it would have been possible to design some replacement for floating point that would be just as deeply wired into the hardware and just as fast but with better semantics. but there's not enough demand for it.
11:48:57 <EvanR-work> Peaker: i know, i was responding to what you said about trade off between accuracy/simple semantics and 'speed', so i was asking, if you dont care about 'speed', are rationals better
11:49:25 <EvanR-work> guess not since we throw in the memory issue for general use
11:49:27 <Peaker> EvanR-work: I'd guess that memory use would grow -- as the dual of inaccuracies accumulating
11:49:46 <wereHamster> how can I express 'up to this substring' in attoparsec?
11:50:01 <Peaker> Also, Rationals cannot do interesting things (e.g: rational exponents)
11:50:03 <EvanR-work> Peaker: another thing i just thought of... the square root of 2 isnt rational :)
11:50:24 <Peaker> EvanR-work: yeah.. you can go fully symbolic, but then you're undecidable :)
11:50:25 <EvanR-work> so were basically screwed
11:50:31 <mokus> a lot more numbers aren't rational than are
11:50:34 <roconnor> Peaker: algebraics are deciable
11:50:38 <yitz> wereHamster: manyTill, takeTill. it depends
11:50:41 <mdxbhmt> EvanR-work: also it's far from being fixed lenght
11:50:50 <EvanR-work> mdxbhmt: what?
11:51:02 <EvanR-work> who cares about that
11:51:04 <mdxbhmt> EvanR-work: i meant infinite decimals
11:51:05 <EvanR-work> see Integer
11:51:06 <yitz> wereHamster: it depends what you are expecting up until then
11:51:23 <Peaker> roconnor: Can you compare equality of two integrals over a range?
11:51:30 <monochrom> to use rationals in a known interval and still impose a memory bound, you start omitting some rationals. then you run into the exact same problems with floating point.
11:51:34 <mdxbhmt> EvanR-work: you always gonna need to throw something out
11:51:39 <wereHamster> yitz: anything
11:51:52 <EvanR-work> mdxbhmt: if youre talking about rationals, you dont care about place value notation
11:51:56 <wereHamster> I want to capture everything up to but not including " <"
11:51:58 <Peaker> roconnor: integrals as in continuous sigmas
11:52:48 <EvanR-work> when i said 'more ideal' im pretty sure that implies you dont care about memory, why else do people use Integer ;)
11:53:33 <monochrom> interval arithmetic is how you mitigate most of floating point problems
11:53:37 <EvanR-work> but sqrt 2 basically throws a wrench into it all
11:53:50 <FUZxxl> Hi!
11:54:22 <EvanR-work> > realToFrac (sqrt 2) :: Rational
11:54:23 <lambdabot>   6369051672525773 % 4503599627370496
11:54:37 <EvanR-work> pythagoras was wrong!
11:54:40 <rwbarton> > 6369051672525773^2 - 2 * 4503599627370496^2
11:54:41 <lambdabot>   5545866846675497
11:54:47 <mdxbhmt> >  6369051672525773 / 4503599627370496
11:54:48 <lambdabot>   1.4142135623730951
11:54:52 <EvanR-work> > realToFrac (sqrt 2 :: CReal) :: Rational
11:54:53 <lambdabot>   *Exception: CReal.toRational
11:55:13 <FUZxxl> I am amazed that I got so many responses to my post...
11:55:27 <mdxbhmt> > (sqrt 2, sqrt 2) :: (float, double)
11:55:28 <lambdabot>   Could not deduce (GHC.Float.Floating float) from the context ()
11:55:28 <lambdabot>    arising ...
11:55:40 <monochrom> yes. I skipped all of them and the volume reduces by half.
11:55:50 <mdxbhmt> > (sqrt 2 , sqrt 2) :: (Float , Double)
11:55:50 <lambdabot>   (1.4142135,1.4142135623730951)
11:55:51 <monochrom> the volume of haskell-cafe, I mean
11:56:23 <FUZxxl> monochrom: hehe
11:56:35 <roconnor> Peaker: I still don't know what an integral is :/
11:56:40 <monochrom> I only like the "a mascot" answer.
11:56:42 <FUZxxl> Well, it seems that it's an interestin topic
11:56:43 <yitz> wereHamster: it's easier if you can take everything up to '<'
11:56:50 <monochrom> all else is garbage.
11:57:03 <wereHamster> yitz: and then strip whitespace at the end?
11:57:32 <FUZxxl> monochrom: Mine included?
11:57:33 <yitz> wereHamster: if that's acceptable, then yeah. then you can use manyTill.
11:58:03 <monochrom> I am not sure.
11:58:11 <wereHamster> yitz: I currently use this: AP.takeWhile (not . (\x -> x == c2w '<')) <* char '<'
11:58:14 <yitz> wereHamster: it means you'll also find '<' when not preceded by whitespace.
11:58:24 <wereHamster> that's ok
11:59:05 <yitz> wereHamster: c2w?
11:59:20 <wereHamster> it's a Word8 bytestring
11:59:32 <yitz> ah
11:59:44 <wereHamster> is there a builtin function to strip whitespace?
11:59:53 <yitz> you mean char8, from A.B.Char8
12:00:06 <FUZxxl> monochrom: Well, sorry for flooding haskell-cafe with pointless posts then
12:00:12 <xil> hi. Could someone recommend a mutable thread safe variable for me? The situation is that I have one thread that exclusively, and only, writes to the variable, and all other threads only ever read from it, and they need to be able to read the same content from it, so read operations can't remove the content
12:00:46 <yitz> wereHamster: yes, for Text. not sure for ByteString. Is this really text? If so, why are you using ByteString? It's usually not a great idea.
12:01:16 <donri> xil: TVar?
12:01:18 <dolio> MVar or TVar
12:01:41 <EvanR-work> Text ftw
12:01:42 <wereHamster> yitz: it comes from a file, and part of it is ascii, other parts is binary
12:01:55 <yitz> wereHamster: I see.
12:03:52 <yitz> wereHamster: well look in Data.ByteString.Char8, maybe there's something for you. I don't remember anymore. That's mostly for legacy support, you'd usually use Text for text stuff.
12:03:53 <xil> donri: why TVar over MVar?
12:04:00 <xil> dolio: do you think one would be more appropriate?
12:04:12 <dolio> TVar is probably better if you only have one writer.
12:04:16 <dolio> No contention.
12:04:28 <xil> guaranteed that there is only one writer
12:04:42 <yitz> wereHamster: if not, could also be that it had convenient functions for doing stuff at the right end of the bytestring, which is almost as good.
12:05:24 <xil> dolio: what happens with MVar if there is more than one writer?
12:08:16 * hackagebot force-layout 0.1.0.1 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.1.0.1 (BrentYorgey)
12:08:19 <yitz> wereHamster: anyway, what i suggest is pretty much what you are already doing. C.takeTill (== '<') == C.takeWhile (/= '<') == B.takeWhile (/= c2w '<') == what you wrote
12:09:54 <EvanR-work> xil: a 'full' mvar blocks on write
12:10:19 <EvanR-work> and unblocks in order
12:10:26 <EvanR-work> fifo
12:10:50 <xil> EvanR-work: ah, I see. And TVar will just overwrite when I write to it and only block on read?
12:11:51 <EvanR-work> ive never used TVar, the doc suggests yes
12:11:54 <monochrom> no no no. "retry" is the block point
12:11:54 <mgsloan> what's the stance on hackage inter-related package quantity vs dependency?  I'm working on a package that could have convenience functions that relate it to a few other packages, but otherwise does not depend on them.  Should these convenience functions be stuck in separate packages?  This hurts discovereability and contributes to hackage-cruft..
12:12:17 <mgsloan> It seems like there should be considerations for optional components of a package that compile when possible.
12:12:32 <mgsloan> this would be cool for example code.
12:13:21 <EvanR-work> mgsloan: being able to mix and match composable modules seems to be ideal
12:13:25 <wereHamster> yitz: thanks. will do
12:13:36 <EvanR-work> monolithic is the root of all evil!
12:13:54 <mgsloan> you don't download the dependencies of a package's examples until you "cabal unpack" and explicitly install the examples' dependencies.  I suppose this could currently be done with a cabal file in a subdirectory?
12:14:02 <EvanR-work> so im calling into question the idea of 'hackage cruft'
12:14:34 <mgsloan> Yeah, perhaps there is no such thing, and we just need a better way of aggregating and displaying the available libraries
12:14:41 <EvanR-work> its kind of like php / js people saying 'dont make a function for that, its simple enough to write out directly in the code'
12:14:53 <EvanR-work> only in reverse ;)
12:15:13 <mgsloan> the hackage index is just becoming a bit monolithic.  Not a bad thing, success is unavoidable at times ;)
12:15:19 <monochrom> sorry, I can't figure out what is the reverse of that.
12:15:27 * EvanR-work reverses it
12:15:33 <Andrew__C> Hi folks. I was wondering if any of you could help me out with an error I've got trying to install Gtk2Hs? http://hpaste.org/55554
12:16:00 <yitz> > reverse "dont make a function for that, its simple enough to write out directly in the code"
12:16:01 <lambdabot>   "edoc eht ni yltcerid tuo etirw ot hguone elpmis sti ,taht rof noitcnuf a e...
12:16:27 <EvanR-work> im sure there was a connection
12:16:52 <EvanR-work> to the concept of 'you only need one library with all the functions in it'
12:17:23 <manenko> > reverse "o_O"
12:17:24 <lambdabot>   "O_o"
12:17:40 <manenko> > tail []
12:17:40 <lambdabot>   *Exception: Prelude.tail: empty list
12:17:49 <manenko> nice :o)
12:18:05 <mgsloan> yeah, conditional modules is a terrible idea.  Maybe cabal support for 'multi-packages', that still give unique names / version numbers to each
12:18:15 <EvanR-work>  > northOf NorthPole
12:18:41 <yitz> EvanR-work: oh oh now you've done it
12:19:19 <Andrew__C> > unwords $ reverse $ words "'dont make a function for that, its simple enough to write out directly in the code"
12:19:20 <lambdabot>   "code the in directly out write to enough simple its that, for function a m...
12:20:33 <EvanR-work> > last (repeat "turtle")
12:20:38 <lambdabot>   mueval: ExitFailure 1
12:20:38 <lambdabot>  mueval: Prelude.undefined
12:21:17 * mgsloan is hopefully going to put up diagrams-turtle soon
12:21:17 <yitz> ah i see mueval has solved the halting problem
12:23:01 <Andrew__C> Anyone know what they're doing with C header file problems in a cabal install?
12:24:05 <EvanR-work> > (\y -> the (\x -> suchThat (x*x == y))) 2
12:24:05 <lambdabot>   Not in scope: `the'Not in scope: `suchThat'
12:24:48 <EvanR-work> should really implement the
12:25:03 <shachaf> Andrew__C: If anyone does, they can't answer your question, because you haven't asked it (unless that was your question). :-)
12:25:37 <Axman6> in which case we need more info
12:25:41 <ClaudiusMaximus> @check \x -> x * x /= (2 :: Double)
12:25:42 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `*'Not in scope: type constructor...
12:25:49 <xil> hello again. So it turns out it'd be better if I had a mutable array that was thread safe like TVars. Would IOArray work?
12:26:11 <byorgey> preflex: seen roconnor
12:26:11 <EvanR-work> STArray ?
12:26:11 <preflex>  roconnor was last seen on #haskell 29 minutes and 37 seconds ago, saying: Peaker: I still don't know what an integral is :/
12:26:23 <roconnor> preflex: seen byorgey
12:26:23 <preflex>  byorgey was last seen on #haskell 12 seconds ago, saying: preflex: seen roconnor
12:26:26 <Axman6> xil: no!
12:26:36 <byorgey> roconnor: heh, good thing that doesn't cause a loop =)
12:26:40 <roconnor> :D
12:26:43 <gwern> quickn question, I have two [String], and want to check how many of the former are in the latter; what's the elegant approach? I could chain elem, filter, and length
12:26:44 <xil> EvanR-work: oh I think I misunderstood what STArrays were. Back to the wiki!
12:26:46 <EvanR-work> http://hackage.haskell.org/packages/archive/stm/2.1.1.2/doc/html/Control-Concurrent-STM-TArray.html
12:26:55 <byorgey> roconnor: are you planning to make a new release of colour that compiles under ghc 7.4.1?
12:27:03 <byorgey> roconnor: I could send you a patch if you want
12:27:07 <Andrew__C> I'm trying to cabal install gtk but it fails while installing pango because it can't find glib-2.0\glib.h but it's there, and in my %INCLUDE% env var (winXP)
12:27:14 <roconnor> byorgey: but but ... it's haskell 98!
12:27:29 <byorgey> roconnor: yes, well, ghc 7.4.1 isn't!
12:27:38 <byorgey> in particular Num no longer has a Show superclass
12:27:43 <roconnor> oh
12:27:49 <roconnor> ... that is sort of a good change
12:27:55 <ClaudiusMaximus> :t intersect
12:27:55 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:27:59 <byorgey> roconnor: agreed =)
12:28:13 <gwern> ClaudiusMaximus: ah. should've known there was a function for that
12:28:19 <roconnor> byorgey: oh so I need to add more superclass constraints?
12:28:35 <xil> EvanR-work: do you know why it isn't listed on the MArray page?
12:28:37 <roconnor> byorgey: and it would still be compatible with haskell 98?
12:28:44 <EvanR-work> xil: because MArray isnt concurrent
12:29:00 <xil> EvanR-work: ah, okay. Thanks =]
12:29:37 <EvanR-work> er, MArray is an interface to mutable arrays
12:29:52 <EvanR-work> STArray and TArray are implementations
12:30:08 <xil> right, and STArray is listed in the instances of MArray, but TArray isn't
12:31:30 <roconnor> there is a TArray?
12:31:37 <EvanR-work> http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Concurrent-STM-TArray.html
12:31:44 <EvanR-work> Array ix (TVar e) ;)
12:32:48 <EvanR-work> xil: theres no requirement for each class to list all its implementations in the universe
12:33:02 <EvanR-work> for some that would be a huge list
12:33:14 <xil> of course not. But I just wonder how they pick which ones to list
12:33:22 <roconnor> byorgey: if you want to make a patch, I'll accept it.
12:33:31 <rwbarton> xil: probably the ones that are implemented in that module
12:33:37 <EvanR-work> the ones that invite them to dinner at the fancy italian restaurant
12:33:40 <rwbarton> or at least in scope when that module is built
12:33:44 <roconnor> byorgey: do you want me to publish my darcs repo or will you just use old school patch files?
12:33:47 <byorgey> roconnor: yes, you just need to add some Show constraints, it would be completely backwards compatible
12:33:48 <OscarZ> im trying to define my own datatype like this: data (Enum a, Ord a, Show a) => Range a = Range a a ... is there some way to define a "type variable synonym" so that i wouldnt have to copy all those type constraints in function type signatures
12:33:54 <OscarZ> if that makes any sense..
12:33:57 <xil> EvanR-work: lol
12:34:02 <byorgey> roconnor: darcs would be easier, but it's up to you
12:34:06 <ksf> or at least in scope when that module is haddocked, which is usually less.
12:34:14 <xil> rwbarton: okay. I was thinking it might be which ones are "better" if you could say that
12:34:30 <xil> like a recommendation to use those if you can
12:34:54 <roconnor> byorgey: I don't have a public darcs repo for colour yet;  Might be easier with a patch file in this case since it is a pretty simple change.
12:35:05 <byorgey> roconnor: ok, sure.
12:35:11 <ksf> OscarZ, depends.
12:35:24 <ksf> ghc 7.4 has constraint synonyms.
12:35:53 <ksf> prior to that, you can enable -XUndecidableInstances and make a typeclass that captures those constraints.
12:37:00 <ksf> I don't think any ghc release prior to 7. 4 was ever so anticipated
12:38:02 <OscarZ> ksf: ok thank you, I'll check those out..
12:38:07 <EvanR-work> how about constraint constructors ;)
12:38:48 <ksf> ...in other news, did anyone notice that the ghc library is as messy as my cupboards?
12:43:17 * hackagebot chell 0.1.3 - Quiet test runner  http://hackage.haskell.org/package/chell-0.1.3 (JohnMillikin)
12:43:19 * hackagebot chell 0.2.1 - A quiet test runner  http://hackage.haskell.org/package/chell-0.2.1 (JohnMillikin)
12:43:19 <byorgey> roconnor: is your cs.ru.nl address still the right place to send this?  or do you have a more recent address?
12:45:57 <roconnor> byorgey: that address will work
12:47:45 <OscarZ> if i have type like this: data Range Int = Range Int Int ... is there a way with which I could make some sanity checks right away when that data constructor is used somewhere, for example to check that the first Int is smaller than the second Int ?
12:48:20 <yrlnry> Never use the data constructor directly; instead, always use a wrapper function that performs the sanity checks and then uses the real constructor.
12:48:36 <yrlnry> The sanity checks will only be applied at run-time though.
12:48:44 <shachaf> @wiki Smart constructors
12:48:45 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
12:48:55 <shachaf> yrlnry: I wouldn't say "never".
12:49:03 <shachaf> Oh, you mean never for this specific case. Sure.
12:49:08 <yrlnry> Right.
12:49:41 <yrlnry> You could even change the representation so that Range a b represents the range from a to a+b.
12:50:16 <OscarZ> thanks, exactly what i need
12:50:31 <byorgey> roconnor: sent.
12:50:49 <shachaf> Smart constructors are the easy way out of expressing your constraints in the type system. :-)
12:52:15 <OscarZ> would it be somehow possible though ? just out of curiosity..
12:52:31 <shachaf> Would what be possible?
12:52:41 <OscarZ> to put those constraints directly on the data constructor somehow
12:52:53 <byorgey> blargh, cairo needs to be updated re: Show/Num as well.
12:53:17 * hackagebot split 0.1.4.2 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.4.2 (BrentYorgey)
12:55:42 <OscarZ> or type definition.. can you say something like data (Int a, a < b) =>  Range a = Range a a ... heh
12:56:10 <OscarZ> that doesnt make any sense
13:00:32 <aavogt> OscarZ: if you want runtime checking of that you're better off hiding the Range constructor, and defining say     (range a b | a < b = Range a b | otherwise = error "range: a >= b")
13:00:41 <alistra> hi
13:01:19 <aavogt> but you don't really have to hide the Range constructor, just make sure it isn't used when you aren't sure about whether one number is larger
13:06:27 <Peaker> roconnor: an integral == I mean the area under a graph
13:08:18 <roconnor> Peaker: I suspect it is as undecidable as determining if two continous functions are equal or not
13:08:33 <roconnor> but I don't know
13:10:04 <xplat> what was the question?
13:13:27 <OscarZ> thanks aavogt
13:13:57 <xplat> roconnor: Peaker: ?
13:23:17 * hackagebot system-filepath 0.4.4 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.4 (JohnMillikin)
13:23:19 * hackagebot system-filepath 0.3.5 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.3.5 (JohnMillikin)
13:24:35 <ricree> is parsec still considered the go to library for general parsing needs?
13:24:56 <periodic> ricree: I believe so.  Though it's a bit slower than Attoparsec if you care a lot about performance.
13:25:08 <Axman6> it's also more powerful i think
13:25:10 <periodic> but Attoparsec doesn't do things like track line/column number the way parsec will.
13:25:33 <periodic> Attoparsec is simpler, but faster.  Parsec is more powerful, suitable for just about any parsing task, but slower.
13:25:37 <Axman6> ricree: it depends what you need to parse
13:26:03 <ricree> thanks.  I remembered reading somewhere about alternatives, but I couldn't remember anything concrete.
13:26:55 <Phyx-> Is there a package i can use to parse a haskell file and get the general structure of such a file, even if there are syntax errors within the definition of functions?,
13:27:24 <xplat> trifecta has a lot of power too, but it's not as well-documented
13:27:31 <Phyx-> I could probably rip out UHC's parsers, but was wondering if there was a simpler way
13:28:27 <c_wraith> Phyx-: does UHC use uu-parsinglib?
13:28:31 <c_wraith> err, *doesn't
13:28:45 <xplat> if haskell-src-exts doesn't work for you i don't know what to tell you, for parsing haskell
13:28:52 <Phyx-> c_wraith: yeah, afaik, so it should be able to correct small mistakes
13:29:13 <c_wraith> Phyx-: I've used uu-parsinglib.  It certainly does correct issues like that
13:29:21 <Phyx-> xplat: I beleive haskell-src-exts would stop on the first error
13:29:51 <xplat> that's really the only one aimed for reuse afaik
13:30:10 <xplat> you might find more by pawing around hackage, though
13:30:19 <Phyx-> c_wraith: yeah, I guess i should evaluate which is simpler, taking out the parsers from UHC and strip it down, or just implement a simple one using uulib.
13:30:53 <Phyx-> xplat: yeah, i'll take a look, I just though i'd ask first here :)
13:31:01 <xplat> you might try porting haskell-src-exts to uulib if all else fails
13:31:33 <xplat> not sure if it's built on top of something that would make that easy or hard
13:32:14 <xplat> but it sounds like it would be easier than either of your alternatives
13:32:17 <Phyx-> xplat: well, when compiling UHC the core parts are registered with ghc as a lib, so i could just call the parsers from that package. but I don't need the entire file parsed, On average i just need to know the location of top level functions and functions declared in a where
13:32:58 <Phyx-> and maybe the type signatures aswel
13:33:03 <xplat> 'on average'?
13:34:19 <Phyx-> you can remove that part :P. I just always need those locations and quickly,
13:35:45 <Phyx-> i'm currently using the ghc api, but if the file has any syntax errors in it, i get nothing back
13:36:03 <nelyud> hi all, I am here for first time. pretty resource.
13:37:16 <Phyx-> hi nelyud
13:38:52 <byorgey> hi nelyud, welcome.
13:39:02 * Phyx- hands nelyud a cookie
13:39:04 <byorgey> nelyud: feel free to ask questions in here.
13:39:13 <nelyud> I decided to learn Haskell (know Python).
13:39:37 <nelyud> I don't have questions at this moment)
13:40:28 <alistra> nelyud: they're basically the same thing
13:40:32 <Phyx-> lol, that's funny, i've just started learning python
13:40:42 <byorgey> alistra: hahaha, what
13:40:56 <alistra> reduce(lambda x y: x + y, map(lambda x: 2 * x, [1,2,3]))
13:40:58 <alistra> is like
13:41:05 <byorgey> Haskell and Python are basically the same, except for Haskell
13:41:15 <DrSyzygy> *snrk*
13:41:20 <alistra> > foldl1 (+) $ map (*2) [1..3]
13:41:20 <lambdabot>   12
13:41:44 <rostayob> python and haskell are like... very different :D
13:42:01 <Clint> but they both have list comprehensions
13:42:04 <rostayob> nelyud: anyway, check out LYAH
13:42:26 <rostayob> @where LYAH
13:42:27 <lambdabot> http://www.learnyouahaskell.com/
13:42:36 <alistra> @where your mom
13:42:36 <lambdabot> I know nothing about your.
13:42:43 <alistra> @where your_mom
13:42:43 <lambdabot> I know nothing about your_mom.
13:43:22 <alistra> @where where_that_has_been_Don't_touch_it
13:43:22 <lambdabot> I know nothing about where_that_has_been_don't_touch_it.
13:46:01 <nelyud> rostayob, thanks, I downloaded it today.
13:46:25 <rostayob> nelyud: it's a nice book. "Programming in Haskell" is good too
13:47:02 <acowley> huzzah! I tracked down a memory leak
13:47:03 <rostayob> but if you like LYAH that's the nicest introduction imho
13:47:18 <Phyx-> acowley: huzzah!
13:47:29 <Phyx-> acowley: FFI?
13:47:35 <acowley> Phyx-: OpenCL
13:47:39 <acowley> so yes
13:47:40 <Phyx-> ah
13:47:52 <acowley> I have this little shim for the OpenCL package
13:48:10 <acowley> it's turning out to be a very nice way of interoperating with Vector and OpenCL
13:48:26 <Phyx-> :)
13:48:43 <acowley> But I wasn't releasing event objects. Most operations in OpenCL are asynchronous, and give you and event object you can sync on.
13:49:00 <acowley> I didn't notice a problem until I stressed a little test app in a loop, and then :(((
13:50:10 <acowley> Now I need to write a cool demo app instead of these little teases
13:51:35 <hpaste> acowley pasted ‚ÄúEZ OpenCL‚Äù at http://hpaste.org/55564
13:51:56 <acowley> those are the tiny tests I wrote
13:52:02 <Phyx-> hah, a "Small tutorial".. 55pages..
13:53:23 * hackagebot unordered-containers 0.1.4.6 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.4.6 (JohanTibell)
13:55:35 <eikke> acowley: I'll need to use OpenCV shortly... what's the current state of haskell bindings? there's a couple of packages on hackage, but kinda hard to figure out what to use...
13:56:29 <acowley> I have a fork of OpenCL on github that builds cleanly on OS X
13:56:46 <acowley> and I have some utilities for making simple things slightly easier
13:57:06 <acowley> I think OpenCL is pretty great for a low-level binding
13:57:30 <acowley> it has yet to offer up any nasty surprises, and lets me use the OpenCL spec as a reference
13:57:51 <eikke> ok, then I'll go with that initially
13:58:07 <eikke> still looking forward to DPH-over-OpenCL and alike too, though
13:58:25 <acowley> There's an Accelerate backend that targets OpenCL but I haven't tried it
14:12:05 <alpounet> looks very interesting! http://www.scs.stanford.edu/11au-cs240h/projects/jones.pdf
14:13:44 <Phyx-> Does anyone know where haterm is these days? http://www.cwi.nl/projects/MetaEnv/haterm/ seems to be dead
14:15:03 * Andrew__C likes Haskell
14:15:19 * Andrew__C does not like C or having anything to do with C
14:15:33 * Clint likes both.
14:16:00 * Andrew__C wishes he could install some graphics library without irritating .h missing file problems
14:16:05 <Phyx-> googling "haterm" sure gets you useless results..
14:16:14 <Andrew__C> http://hpaste.org/55554
14:18:01 <Andrew__C> Can anyone restore my faith in C by helping me fix my Gtk2Hs install?
14:18:36 <hiptobecubic> How would one write cycle using a fold? After you fold over the list, you return the accumulator and that's it. How do you get the infinite list without recursion?
14:19:33 <hiptobecubic> or perhaps you cannot, i suppose it suggests that for some, folds aren't applicable. (RWH ch4)
14:19:47 <c_wraith> you definitely need recursion.  It doesn't need to be explicit recursion
14:20:15 <c_wraith> :t cycle
14:20:16 <lambdabot> forall a. [a] -> [a]
14:20:20 <c_wraith> let c xs = fix (xs ++) in c "hello "
14:20:27 <c_wraith> > let c xs = fix (xs ++) in c "hello "
14:20:28 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
14:20:41 <c_wraith> that's one approach.  It moves the recusion into the fix function
14:21:12 <Andrew__C> dmwit: I am, as far as I can tell following the "Building on Windows" instructions found at http://code.haskell.org/gtk2hs/INSTALL ? 1
14:23:43 <Andrew__C> perhaps I'm wrong to assume that running a GtK+Glade install is idempotent...
14:23:49 * Andrew__C sighs and starts again
14:25:21 <donri> stupid haskel makes me commit untested code "hey it compiles, probably fine!"
14:26:26 <Andrew__C> donrj: getting the type signatures right is fully half the work already done a lot of the time
14:27:35 * Phyx- runs some benchmarks on the UHC parsers
14:29:19 <rs46> I've been scanning around. Could some one enlighten me on the chances of implementing a lazy Control.Monad.Parallel.mapM ?
14:29:26 <rs46> this function returns m [a]
14:29:43 <rs46> but I'd like to consume [a] as it is being produced
14:29:54 <rs46> In Control.Parallel, there is a parBuffer
14:29:58 <Axman6> that implies a sequential execution though
14:30:14 <rs46> and I'd like something like parBuffer for monadic computation
14:30:15 <rs46> ?
14:30:46 <Axman6> i think the buffers version is what you'd be after
14:31:16 <rs46> but there isn't isn't a buffers version for monadic functions
14:31:18 <c_wraith> rs46: for most values of m, doing computation in parallel is nearly impossible, as >>= necessarily passes information along the line sequentially
14:31:56 <rs46> c_wraith: oh...
14:32:09 <kmc> there's nothing in the Monad class which lets you do parallel (>>=)ing
14:32:26 <rs46> kmc: thanks. Isn't this a highly desirable feature ?
14:32:34 <rs46> I'd certainly make use of it
14:32:37 <c_wraith> It's generally not a *possible* feature.
14:32:37 <rs46> :-|
14:32:41 <kmc> you could define a different class of monads which allows this
14:32:47 <c_wraith> I mean, what specific value do you want for m?
14:32:47 <rs46> ok
14:33:20 <Axman6> hmm, i wonder if a parallel list monad makes sense...
14:33:26 <c_wraith> take a look at a simple state computation:  do { x <- get ; put (x + 1) ; return x }
14:33:26 <rs46> is there anything in the IO Monad that'd allow >>= to be consumed lazily ?
14:33:38 <kmc> Axman6, http://hackage.haskell.org/packages/archive/parallel-tree-search/0.4.1/doc/html/Control-Parallel-TreeSearch.html
14:33:56 <kmc> rs46, maybe you'd be interested in parMapIO from http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html
14:33:57 <c_wraith> rs46: there are a bunch of things you can do with IO, in particular.
14:34:01 <sipa> rs46: unsafeInterleaveIO?
14:34:10 <c_wraith> rs46: they just don't apply to *all* monads, which is what you were asking for
14:34:49 * rs46 is taking a look at the link....
14:34:59 <kmc> note that replacing mapM with parMapIO can add nondeterminism, whereas replacing map with parMap can't
14:36:16 <kmc> rs46, you can also use ¬´sequence . parMap rwhnf¬ª or whatever.  this will compute the actions in parallel, and then combine them sequentially
14:36:26 <kmc> probably not what you want for IO, but it could be the right thing for e.g. Maybe
14:37:06 <kmc> can you be more specific about what you're trying to do?
14:37:10 <periodic> Does anyone else have problems reasoning about non-lazy languages after programming in Haskell a lot?  I have a memory leak in PHP and I keep thinking about thunks...
14:37:35 <c_wraith> periodic: Every once in a while, I get shocked that writing foo = bar can perform effects :)
14:37:51 <hiptobecubic> :t fix
14:37:52 <lambdabot> forall a. (a -> a) -> a
14:37:52 <kmc> isn't it 'bar' which is performing effects there?
14:38:10 <c_wraith> kmc: yes.  but I get so used to the idea that = is just name-binding...
14:38:10 <periodic> Oh god, the side effects...
14:38:19 <kmc> well, it is
14:38:21 * kmc pedantic
14:38:39 <c_wraith> well.  name-binding that's necessarily free of effects
14:39:10 <periodic> He's shocked that a name binding can perform effects.  He never said he was shocked that bar performs effects.
14:39:38 <periodic> the evaluation of the assignment necessitates the evaluation of the rvalue, so the assignment is indirectly having effects through the evaluation of the RHS.
14:39:52 <periodic> Anyway...
14:39:58 <c_wraith> it's especially bad in ruby, where there's no syntactic hint what's even a function call, vs a local name lookup.
14:40:16 <c_wraith> foo = bar might be calling a function named bar.  It might be referring to a local variable named bar!
14:40:28 <periodic> It seems so hard to reason about that a call that returns just an int may cause arbitrary side effects.
14:40:43 <Phyx-> hmm i'm getting "cabal.exe: internal error: could not construct a valid install plan." when trying to install network
14:40:49 <Phyx-> anyone got any suggestions?
14:41:00 <periodic> Phyx-: nuke it from orbit.
14:41:37 <Phyx-> :(
14:41:52 <periodic> Phyx-: you might have to upgrade cabal-install.
14:42:01 <rs46> kmc: In essence, I'm looking for a non-blocking mapM, something that allow evaluation of lines of code in a function after the mapM line, and any lines that require elements from the results of the list from mapM will wait lazily.
14:42:07 * rs46 too vague, perhaps.
14:42:10 <Andrew__C> periodic, c_wraith: in Delphi, if you define a property cheese, you do it by defining getCheese and setCheese procedures: cheese = 3; can have side effects!
14:42:11 <periodic> try "cabal install cabal-install"
14:42:17 <Phyx-> periodic: yeah, update just told me there's a new version, upgrading now
14:42:19 <Entroacceptor> c_wraith: what about overloading () in C++?
14:42:35 <Phyx-> periodic: well, that didn't work, got the same erorr.. it appears i get that error on all packages now
14:42:56 <periodic> Phyx-: hmm... what does "cabal list cabal-install" tell you about the version?  Up to date?
14:43:01 <Phyx-> ah, no i can install pony
14:43:02 <kmc> rs46, maybe you want mapM (spawn . f)
14:43:04 <Phyx-> so not on all packages
14:43:10 <c_wraith> Entroacceptor: what about it?  It's just currying, done the really hard way.
14:43:16 <periodic> I think that error has to do with intra-package dependencies.
14:43:32 <rs46> kmc: thanks.
14:43:46 <kmc> that will execute all the f actions concurrently, and give you a list of IO actions... when you execute an action from that list, it will wait for the respective thread to finish
14:43:54 <mizu_no_oto> What's the standard advice for dealing with command line arguments?
14:43:57 <Phyx-> periodic: yeah, but it's giving me errors on packages not installed, and no my cabal-install is 0.9.2, but it won't let me install the new one
14:44:01 <Phyx-> maybe there's a binary
14:44:03 <kmc> mizu_no_oto, use the cmdargs library
14:44:14 * shachaf is still not happy with the name "parMapIO".
14:44:17 <periodic> Phyx-: you can't install th enew one?  0.10 is what you need.
14:44:27 <periodic> cabal install 'cabal-install >= 0.10'?
14:44:30 <hiptobecubic> I do not understand what fix actually does.
14:44:33 <gwern> > (119 / 958) * 100
14:44:34 <lambdabot>   12.421711899791232
14:44:40 <Phyx-> periodic: no, it gives me the same dependency error. but the cabal site has a binary, i'll try that
14:44:50 <kmc> hiptobecubic, returns the least fixed point of a function, where "least" is defined with respect to a peculiar ordering
14:44:56 <Axman6> > fix f :: Expr -- hiptobecubic
14:44:57 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
14:45:02 <periodic> Phyx-: K.  Well, I think that's the correct solution.  GL.
14:45:06 <Axman6> > fix (1:)
14:45:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:45:13 <hiptobecubic> i can see how it does it, but what is that for?
14:45:22 <kmc> hiptobecubic, practically, 'fix' is a way to introduce recursion without using any of the explicitly recursive language constructs
14:45:38 <Axman6> it's all you need for general recursion. anything you can write using recursion you can write using fix
14:45:51 <kmc> > fix (\self n -> if n == 0 then 1 else n * self (n-1)) 5
14:45:51 <lambdabot>   120
14:46:02 <kmc> note how i defined the standard recursive factorial, without giving it a name
14:46:20 <kmc> the anonymous function refers to itself through an argument passed to it, 'self' here
14:46:32 <kmc> hiptobecubic, did you see http://www.vex.net/~trebla/haskell/fix.xhtml ?
14:46:35 <kmc> this is the best intro i've seen
14:46:47 <hiptobecubic> reading..
14:47:11 <Entroacceptor> do you ever use that in actual code?
14:47:16 <Phyx-> periodic: yeah, that did the trick, thanks!
14:47:19 <kmc> Haskell has explicit recursion in "let" and "where", but 'fix' is nice for certain idioms
14:47:33 <shachaf> Entroacceptor: What, "fix"? Occasionally.
14:47:36 <Axman6> hiptobecubic: the most common way i've seen fix used it to show off how tiny someone can make something though, i've ever used it in real code (i know some people do, but i prefer the explicit recursion)
14:47:40 <kmc> e.g.  fix (\again -> do { ...; when (whatever condition) again })
14:47:43 <shachaf> fix $ \loop -> do { ...; when (...) loop }
14:48:01 <Axman6> > fix ((0:).scanl(+)1)
14:48:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:49:13 <Sgeo> hiptobecubic, do you know the recursive definition of factorial?
14:49:39 <Sgeo> hiptobecubic, here's how to do it in a lambda and calling fix (I'm still a bit shaky on fix, but I know how this works):
14:50:00 <Sgeo> fix (\factorial x -> if x > 0 then x * factorial (x-1) else 1)
14:50:06 <Sgeo> > fix (\factorial x -> if x > 0 then x * factorial (x-1) else 1) 5
14:50:07 <lambdabot>   120
14:50:07 <shachaf> Sgeo: <kmc> > fix (\self n -> if n == 0 then 1 else n * self (n-1)) 5
14:50:11 <Sgeo> Oh
14:50:22 <kmc> anyway i think the link i posted is a great intro
14:50:28 <shachaf> I wonder how many thousands of results I'd get if I grepped #haskell logs for that phrase.
14:50:38 <otters> which phrase
14:50:42 <kmc> when you get bored with that, read http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html for fix at type level!
14:50:51 <Sgeo> kmc, what link?
14:51:16 <kmc> <kmc> hiptobecubic, did you see http://www.vex.net/~trebla/haskell/fix.xhtml ?
14:51:22 <Sgeo> Ah, ty
14:53:19 <kmc> Andrew__C, if your OOP language allows public fields, it's important to allow custom getters and setters ("properties").  otherwise the implementation detail of whether something's a field or a method is part of your interface
14:53:47 <kmc> so the wtf there isn't that "foo.cheese = 3" could have side effects, but that it's allowed at all.
14:54:02 <hiptobecubic> kmc, fix... hurts
14:54:12 <kmc> once you allow it, you should allow custom getters/setters, and resign yourself to the fact that it's a sugared function call
14:54:24 <shachaf> kmc: What's wrong with calling a setter with the syntax "foo.cheese = 3"?
14:54:37 <shachaf> Oh, I see, that's what you're saying.
14:54:43 <kmc> why does this particular type of method call need special syntax?
14:54:58 <kmc> maybe it makes things more clear, but maybe not
14:55:22 <kmc> but the "compromise" where you allow public fields, but not custom property getter/setter, is definitely the worst of both worlds
14:55:32 <kmc> if you make something a dumb field, you have to keep it so forever
14:55:37 <shachaf> Sure.
14:55:51 <Andrew__C> kmc: I'm not saying it's bad, I'm saying it's far from Haskell.
14:56:11 <kmc> and if you want to reserve the right to put some smarts into the field later, you have to write boilerplate like  private int foo; public int getFoo() { return foo; }; public void setFoo(int x) { foo = x; }
14:56:26 <Andrew__C> In fact I like properties, they let me write clear, clean code in what might otherwise be very ugly tangled code.
14:56:37 <kmc> ok, well that wasn't clear from context
14:57:20 <shachaf> kmc: Would you use the same argument to say that no constructors should ever be exported in Haskell?
14:57:34 <shachaf> (Sadly you can't pattern-match on smart constructors.)
14:57:42 <Andrew__C> I've just come across Tangible Values (TV) which seems to be providing me with something similar which I've always wanted: neat UI wrapper which I can mess with by just altering data.
14:57:47 <kmc> if there were better sugar for view patterns, then maybe
14:57:58 <Andrew__C> shame I can't get Gtk to install so I can play!
14:59:03 <kmc> shachaf, but i think it's a different situation... a lot of data is just data, whereas fields vs. properties vs. methods is a tradeoff which applies to objects which are already complicated bundles of data / state / identity / behavior / invariants
14:59:47 <shachaf> kmc: That's true to a degree. But there are still quite a few places that do use smart constructors.
14:59:48 <kmc> shachaf, maybe my rule in C++ would be: no public fields, except for Plain Old Data
14:59:53 <kmc> yes
15:00:10 <shachaf> Is it necessarily obvious when you're first making a type whether it's "just data" or not?
15:00:23 <kmc> i think it's more obvious than when you make an object
15:00:25 <kmc> still not perfect
15:00:27 <shachaf> Another thing that using a function instead of data allows you to do is maintain backwards compatibility while adding new fields.
15:00:29 <kmc> *shrug*
15:02:00 <mlb-> I'm working with log files: if a log file has a couple of lines at the 500MB offset, I want to handle the log differently. Is just seeking to that offset and comparing expected strings the most straightforward way to do this?
15:02:13 <hpc> :t hSeek
15:02:13 <lambdabot> Not in scope: `hSeek'
15:02:18 <hpc> @hoogle hSeek
15:02:18 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
15:02:19 <lambdabot> GHC.IO.Handle hSeek :: Handle -> SeekMode -> Integer -> IO ()
15:02:37 <kmc> sounds ok.  you might have trouble if you seek into the middle of a multi-byte character
15:02:41 <Sgeo> If I have a type that's an instance of Data, is there a function to make a zipper out of it?
15:02:56 <Sgeo> Actually, does that even make sense? :/
15:03:11 <c_wraith> Sgeo: I think there's been research in that direction.  Not sure it's on hackage
15:03:22 <Axman6> if there were, it would have to use template haskell
15:03:39 <c_wraith> Not necessarily.  That's sort of the point of Data
15:04:01 <Axman6> yeah? :\
15:04:06 <Sgeo> c_wraith, to define the type of the zipper maybe? Though perhaps not to use it?
15:04:49 <Sgeo> Erm, I mean, you can look at how a type is defined with Data, but I guess you can't just make a new type?
15:05:04 <mlb-> hpc: yeah, I found those
15:05:10 <mlb-> @hoogle hGetLine
15:05:11 <lambdabot> System.IO hGetLine :: Handle -> IO String
15:05:11 <lambdabot> GHC.IO.Handle hGetLine :: Handle -> IO String
15:05:11 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
15:05:43 <Andrew__C> ARRRRGGGGGHHHHH again: Graphics\Rendering\Pango\Structs.hsc:25:27: fatal error: glib-2.0/glib.h: No such file or directory
15:05:51 <kmc> mlb-, is it really a precise offset? does this file have fixed-size fields?
15:05:59 <mlb-> how would I best do the comparison? having to bind each hGetLine and then compare seems a little...
15:06:02 <c_wraith> Sgeo: well, that's true.  But you can create functions to work with some sort of suitably-generic representation.  maybe, anyway
15:06:04 <hpaste> gwern pasted ‚Äúwikipedia reference checker‚Äù at http://hpaste.org/55567
15:06:09 <c_wraith> Sgeo: I know there's been research on this topic
15:06:30 <Axman6> Andrew__C: are you trying toi get this working on windows? o.O
15:06:36 <gwern> anyone want to look at this? I'm pretty sure 'parallel', 'trimmer', and 'diff' could be improved
15:06:44 <gwern> trimmer is especially awful
15:06:59 <mlb-> kmc: either it will have the expected string at 500mb, or it won't. If it does, then the frontend that spits out the logs started overwriting after the offset.
15:07:13 <kmc> ok
15:07:30 <kmc> 500mb being exactly 524,288,000 bytes into the file
15:07:39 <gwern> hm, can probably rewrite trimmer with isPrefixOf
15:07:40 <mlb-> yup
15:07:51 <kmc> you said "strings" so it sounds like this is character data.  what encoding?
15:07:58 <mlb-> hSeek h AbsoluteSeek $ 500*1024^2
15:08:05 <mlb-> seems to work for me,
15:09:15 <hpaste> acowley pasted ‚ÄúOpenCL quasicrystals‚Äù at http://hpaste.org/55568
15:09:39 <kmc> mlb-, this is one of those situations where ignoring character encoding will mostly work fine and will occasionally break in a completely incomprehensible way
15:09:43 <eyebloom> Is there a theorem proover whose syntax matches haskell?
15:09:48 <hpc> eyebloom: agda
15:09:49 <kmc> not exactly, but Agda is similar
15:10:01 <kmc> it's also not a "theorem prover", more of a proof checker and proof assistant
15:10:03 <Phyx-> hmm sorry for the random questions today. Is there a haskell src mutator? so I can generate different (possibly invalid) variant of a file. Or should I just randomly change things in the file
15:10:08 <hpaste> gwern annotated ‚Äúwikipedia reference checker‚Äù with ‚Äúwikipedia reference checker (annotation)‚Äù at http://hpaste.org/55567#a55569
15:10:15 <gwern> fixed trimmer there
15:10:18 <kmc> also a dependently-typed programming language, which can even be used for practical stuff (by calling Haskell)
15:10:26 <kmc> /join #agda
15:10:33 <kmc> :D
15:10:35 <eyebloom> how does agda compare to isabelle/HOL
15:10:41 <kmc> you could ask #agda
15:10:45 <alistra> kmc: you're the theorem prover, while using agda
15:11:14 <kmc> :)
15:13:17 <gwern> any thoughts on ast and ast' in "diff"?
15:14:28 <gienah> eyebloom: my impression is that there is more tutorials/documentation on coq and isabelle than agda (isabelle looks great, I've only used coq so far)
15:14:55 <kmc> agda doesn't really have haskell syntax.  it has the syntax haskell wishes it had :)
15:15:26 <alistra> well agda is the definition of a toy language
15:15:26 <kmc> also a cool interactive mode for emacs
15:15:41 <hpc> "look at your language, now back at me; what am i? im the language your language could look like; im on a mac"
15:15:59 <alistra> i have a type system
15:16:26 <mlb-> kmc: Just checked - it's utf8
15:16:27 <hpc> look down, look up, my types are now values
15:16:35 <eyebloom> I'm finding isabelle fairly difficult to work on more complex haskell programs so I'm poking around for alternatives.
15:16:39 <hpc> anything's possible when you use universe polymorphism
15:16:54 <kmc> mlb-, ok.  any chance that seeking to offset 524,288,000 will put you in the middle of a utf8 sequence?
15:17:01 <alistra> look, my code has so many proof adnotations i can barely read it
15:17:22 <mlb-> entirely possible, but only if it's not going to be the expected string constant marking it otherwise
15:17:26 * mee waits for xDependentType, the window manager
15:17:53 <alistra> each agda program has to stop
15:18:01 <alistra> so you can't really have a window manager
15:18:06 <alistra> that is expected to last forever
15:18:14 <alistra> (just very very long)
15:18:18 <hpc> alistra: each agda program has to stop after input stops
15:18:20 <kmc> no, you can disable the termination checker
15:18:26 * hackagebot iterio-server 0.0 - Library for building servers with IterIO  http://hackage.haskell.org/package/iterio-server-0.0 (AmitLevy)
15:18:30 <hpc> also that
15:18:34 <alistra> kmc: even with that
15:18:37 <alistra> you have a prover
15:18:38 <gienah> isabelle and coq use proof general in emacs. its sort of possible to extract haskell code in coq, this is difficult in practice though, it looks like it would be useful for type theory stuff
15:18:47 <alistra> you have to pass the typecheck
15:19:57 <mlb-> kmc: if I seek to the middle of a utf8, does hGetLine not work properly?
15:20:02 <kmc> https://github.com/larrytheliquid/Lemmachine here's a web framework for Agda
15:20:08 <Andrew__C> Axman6: yes indeed I am - currently trying cabal install glib --reinstall, but I think it'll fail on cabal install pango again with that error. I'll try anyway.
15:20:11 <kmc> mlb-, i think it'll crash, yeah
15:20:28 <kmc> i don't remember if there's a way to set the standard IO to permissive decoding
15:20:40 <kmc> but, since you are looking for a fixed string, maybe you are looking for a fixed sequence of bytes
15:20:43 <kmc> so you can use ByteString IO
15:21:24 <kamyzi`e> hello, is there a function of type   spaces
15:21:24 <kamyzi`e>   return res
15:21:28 <kamyzi`e> woops
15:21:51 <alistra> @hoogle spaces
15:21:51 <lambdabot> Text.Parsec.Char spaces :: Stream s m Char => ParsecT s u m ()
15:21:51 <lambdabot> Text.ParserCombinators.Parsec.Char spaces :: Stream s m Char => ParsecT s u m ()
15:21:51 <lambdabot> Text.ParserCombinators.ReadP skipSpaces :: ReadP ()
15:21:53 <kamyzi`e>   spaces
15:21:53 <kamyzi`e>   return res
15:21:59 <kmc> that's not a type
15:22:03 <kamyzi`e> hmm, sorry typo
15:22:12 <alistra> kamyzi`e: xorg paste buffers problems?
15:22:22 <kamyzi`e> Monad m => m a -> m b -> m a1 -> m b
15:22:24 <kamyzi`e> alistra: yup
15:22:31 <alistra> kamyzi`e: try autocutsel
15:22:40 <kmc> :t liftM3 (\_ x _ -> x)
15:22:40 <lambdabot> forall a1 a2 a3 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a3 -> m a2
15:22:41 <Axman6> @hoogle Monad m => m a -> m b -> m a1 -> m b
15:22:41 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:22:41 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
15:22:41 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
15:22:51 <alistra> it copies your cutbuffer to clipboard and owns the clipboard, so you'll never lose your copied text again
15:23:04 <Axman6> or you can use ma *> mb <* mc
15:23:15 <kmc> :t ?ma *> ?mb <* ?mc
15:23:15 <lambdabot> forall (f :: * -> *) a a1 b. (?ma::f a, ?mb::f a1, Applicative f, ?mc::f b) => f a1
15:23:20 <Axman6> :t \ma mb mc -> ma *> mb <* mc
15:23:21 <kamyzi`e> alistra: I'll give it a try, this problem is a real pain, thanks for the tip
15:23:21 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f a -> f a1 -> f b -> f a1
15:23:30 <alistra> kamyzi`e: yeah, that was the best day ever
15:23:34 <alistra> i discovered it
15:23:41 <alistra> autocutsel -s PRIMARY &
15:23:41 <alistra> autocutsel -s CLIPBOARD &
15:23:48 <alistra> remember to start it like that :P
15:24:06 <gienah> eyebloom: just fyi slides on extracting haskell code from coq: http://www.cs.ru.nl/~wouters/Talks/BrouwerExtraction.pdf
15:25:03 <hpaste> acowley annotated ‚ÄúOpenCL quasicrystals‚Äù with ‚ÄúOpenCL quasicrystals (annotation)‚Äù at http://hpaste.org/55568#a55570
15:25:21 <Andrew__C> Ahhh.... Applicative functors......   byebye horrid sequential programming in monads, hello higher orfer functions win the day!
15:25:49 <kmc> Andrew__C, ap, return, and liftM{,2,3,...} existed before Applicative
15:26:27 <Andrew__C> OK, but Applicative has nice notation that makes it clearer for me
15:26:45 <eyebloom> gienah: thanks
15:26:45 <kamyzi`e> alistra: works like a charm, thanks
15:26:57 <alistra> kamyzi`e: glad to help
15:27:01 * Andrew__C likes <*> <$> <* *> etc
15:27:54 <kamyzi`e> it would be useful if parsec had a combinator like that, f *> g <* h
15:28:17 <kmc> between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a
15:28:47 <shapr> between parens?
15:29:43 <kmc> (you can also use (*>) and (<*) with parsec, naturally)
15:30:03 <Andrew__C> kamyzi`e: someone wrote an Applicative wrapper for parsec in a tutorial for Applicative - I'll have a look see if I can find it again.
15:30:32 <kmc> for any monad M, the applicative wrapper is:   instance Applicative M where { pure = return; (<*>) = ap }
15:30:54 <kmc> but, parsec3 already has the Applicative instance
15:30:58 <kamyzi`e> I don't fully understand Applicative yet
15:32:26 <kmc> the remaining annoyance is that some names in Parsec (e.g. 'many') conflict with names in Control.Applicative, which generalize them
15:32:47 <kamyzi`e> just encountered that now
15:32:53 <kmc> so using Applicative with Parsec requires  import Text.Parsec hiding ((<|>), many)
15:32:55 <kmc> maybe others
15:32:56 <Andrew__C> kamyzi`e: Applicative parsec: http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
15:32:59 <kmc> but it doesn't require writing new instances
15:33:43 <kmc> bos's blog post is for parsec 2, i believe
15:34:40 <Andrew__C> kamyzi`e: it does explain Applicative reasonably well imo
15:35:02 <kmc> also I don't agree that monadic programming is "horrid"
15:35:13 <kamyzi`e> Andrew__C: thank you
15:35:27 <kmc> when you actually want to express a sequence of actions, and complicated data flow between them
15:35:33 <kmc> it's more explicit in a good way
15:35:38 <mlb-> kmc: the strings I'm looking for are ascii; would I "hGet handle $ length constString" and then compare?
15:35:52 <kmc> mlb-, hGet still returns Char, no?
15:36:01 <kmc> i would use ByteString IO
15:36:20 <mlb-> @hoogle hGet
15:36:20 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
15:36:20 <lambdabot> GHC.IO.Handle hGetBuf :: Handle -> Ptr a -> Int -> IO Int
15:36:20 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
15:36:25 <kmc> the Applicative combinators have an implicit assumption of executing effects in left-to-right order, which causes confusino
15:36:57 <copumpkin> indexed applicative ftw
15:37:05 <mlb-> hGetChar returns Char, hGet is from Data.ByteString, from what I can tell
15:37:09 <kmc> a common question here is "why isn't (*>) = flip (<*)"
15:37:26 <kmc> the types are the same, but they do different things
15:37:38 <kmc> mlb-, oh, my bad then.  if you're using the thing from ByteString then you're probably fine
15:39:14 <kamyzi`e> why is =<< defined in the prelude but << is not ?
15:39:21 <mlb-> kmc: I'm rather new and stumbling about. I just vaguely remember reading about using ByteString from jlouis's post on Erlang vs Haskell for bittorrent clients
15:39:28 <hpc> kamyzi`e: it's unclear what the order of operations should be
15:39:50 <Andrew__C> kmc: monadic programming is indeed great when I want to express a sequence of actions with complex data flow..... I just hate having to to do sequential programming. UI is the primary example. It should all be declarative, but
15:39:59 <Andrew__C> it's always messy
15:40:03 <hpc> kamyzi`e: would side-effects and return values flow in the same direction?
15:40:16 <Andrew__C> the high level libs aren't finished and the low level ones are ugly
15:40:25 <kmc> the other thing is that (>>=) and (=<<) have different types, but (>>) and (<<) have similar types, which makes it a more dangerous typo
15:40:42 <kamyzi`e> hpc: not sure, I'd assume it worked similarly to =<<
15:41:13 <hpc> kamyzi`e: indeed, and that is at odds with the way (<*) works
15:41:26 <hpc> kamyzi`e: both implementations have equal merit, hence the tricky situation
15:43:56 <kamyzi`e> I'll have to study Applicative first to fully understand why they are at odds
15:44:50 <kmc> putStr "world!\n"  <*  putStr "Hello, "
15:45:14 <irene-knapp> haha
15:45:23 <c_wraith> yes, <* and << work differently.
15:45:36 <c_wraith> if you don't know that, you're likely to end up making a mistake.
15:45:44 <c_wraith> and it's not especially obvious that they work differently
15:45:53 <kmc> and it's not hypothetical, that confusion comes up here often
15:46:02 <c_wraith> I agree, it's a real issue
15:46:17 <kmc> is (<<) actually defined anywhere standard?
15:46:48 <hpc> kmc: no; it's overloaded in various libs
15:47:08 <c_wraith> @hoogle (<<)
15:47:08 <shachaf> kmc: No.
15:47:09 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
15:47:09 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
15:47:09 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
15:47:13 <c_wraith> hmm
15:47:14 <c_wraith> ok
15:47:25 <shachaf> There's argument about whether it should be like (<*) or like flip (>>).
15:47:39 <kmc> yeah, that's what we were talking about :)
15:51:20 <kamyzi`e> if a datatype has kind *, having no type variable, is there a way to make it into a functor so that I may map a function on its elements?
15:51:41 <Axman6> no
15:52:00 <Axman6> ibut you can write your own mapFoo function
15:52:36 <Axman6> though, i'm not sure that makes sense, unless you've used ... existential types? (forall a...)
15:52:53 <kmc> if you want to update particular fields, you could use a lens library
15:53:03 <kmc> like fclabels or data-lens
15:53:28 <kamyzi`e> I've heard a lot of good things about them, I'll take a look
15:54:24 <kamyzi`e> I don't necessarily want to update particular fields, I'd just like to lift the datatype and apply a function and then return it back
15:55:05 <Axman6> kamyzi`e: what is the type of thye thing you're working on?
15:55:13 <Axman6> the*
15:55:42 <kamyzi`e> Symbol String, for example
15:56:11 <Axman6> then write an instance for Functor Symbol?
15:56:35 <kamyzi`e> Symbol String is a construct for the datatype Exp
15:56:53 <Axman6> so it's not a type? or is it a GADT thing?
15:57:20 <kamyzi`e> it's like the datatype here https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Return_Values
15:57:54 <ddarius> kamyzi`e: Look at a generics library.
15:58:11 <Axman6> so what do you want to actually do to the type LispVal with this function you're after?
15:58:13 <nus> @hoogle Symbol
15:58:13 <lambdabot> Text.Read.Lex Symbol :: String -> Lexeme
15:58:14 <lambdabot> Text.Read Symbol :: String -> Lexeme
15:58:14 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
15:58:22 <The_Journey> hi, how can I take the sqrt of an Integer?
15:58:23 <Andrew__C> what is the?
15:58:30 <Axman6> mapLVString :: (String -> String) -> LispVal -> LispVal?
15:58:42 <ddarius> The_Journey: You write an Integer sqrt function.
15:59:01 <Axman6> The_Journey: we don't have one defined by default for good reason...
15:59:06 <ddarius> I suspect what you said isn't quite what you want.
15:59:06 <Andrew__C> The_Journey: depends what you want to do when the answer isn't a whole number.... what do you want to do?
15:59:07 <kmc> :t sqrt . fromIntegral
15:59:08 <lambdabot> forall a a1. (Floating a, Integral a1) => a1 -> a
15:59:21 <kamyzi`e> Axman6: as an example I'd like to be able to do: fmap (1+) (Number 2) => (Number 3)
15:59:46 <parcs``> The_Journey, what would be the type of its result
16:00:06 <Axman6> kamyzi`e: that's simple enough to write. you could do it explicitly, or use something like Data.Data (i think)
16:00:20 <kmc> or uniplate
16:00:45 <kamyzi`e> I thought maybe there was a better way than an explicit function
16:00:57 <The_Journey> how can I generate a list of doubles from 1 to n where n is an integer?
16:01:22 <The_Journey> like 1.0, 2.0, 3.0...
16:01:23 <acowley> map fromIntegral [1..n]
16:01:42 <acowley> > map fromIntegral [1..5] :: [Double]
16:01:43 <lambdabot>   [1.0,2.0,3.0,4.0,5.0]
16:01:47 <ddarius> > [fromIntegral 1 .. ] :: [Double]
16:01:47 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
16:01:59 <parcs``> > [1..] :: [Double]
16:01:59 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
16:02:01 <ddarius> acowley's way is better.
16:02:09 <acowley> I'm trying to support the effort to discourage uses of floating point ranges
16:04:09 <periodic> Hmmm... I applied for a job at a shop that uses mostly Ruby, JavaScript, Java, and C++.  They have a programming test question and they say I can use "any language".  Would it be a good idea to use Haskell?
16:04:29 <acowley> Why not?
16:04:44 <parcs``> use the language you are most familiar with
16:04:53 <Axman6> parcs``: go for it. make sure it's well commented though
16:04:58 <Axman6> uh, periodic
16:04:59 <ddarius> They might think you just wrote a specification instead of an actual implementation.
16:05:00 <NihilistDandy> Make sure to use lots of arrow notation
16:05:14 <int80_h> @src Maybe
16:05:15 <lambdabot> data Maybe a = Nothing | Just a
16:05:15 <c_wraith> also, use flip a lot
16:05:27 <periodic> Obviously I'd try to make it readable, at least.
16:05:32 <c_wraith> @pl f a b c = c b c a
16:05:32 <lambdabot> f = flip (flip . join . flip id)
16:05:38 <int80_h> Maybe doesn't derive any type classes?
16:05:54 <periodic> I honestly feel the most comfortable thinking in Haskell.  It's been an amazing experience learning it over the last few years.
16:05:56 <c_wraith> int80_h: @src doesn't actually give the source
16:05:59 <Axman6> those definitions don't show whether they do or not
16:06:08 <c_wraith> int80_h: it just gives a way it *could* be defined
16:06:17 <int80_h> gotcha
16:06:17 <Axman6> int80_h: :info Maybe in ghci
16:06:27 <int80_h> ah info!
16:06:36 <periodic> I know it defines Eq, Show, Read...
16:06:46 <int80_h> info did the trick
16:06:51 <int80_h> thanks
16:06:55 <Andrew__C> I see I have to walk sadly away from Gtk and will have to stick to <shudder> imperative development if I want a GUI. Time/stress cost of installing Gtk > time/stress cost of manipulating text and filenames outside Haskell.
16:07:36 <Axman6> Andrew__C: GUIs are overrated. also, webpages usually make by far the best cross platform GUIs
16:07:48 <int80_h> why not use something like lua for the GUI and Haskell for the back end?
16:08:03 <periodic> Andrew__C: I just was working on a very simple GUI in Haskell.  I started with wxWidgets and failed.  I got something working with GTK, but the resulting code is 10MB when zipped...
16:08:54 <acowley> I wish it was easier to make a static library out of Haskell code
16:09:20 <acowley> so you don't need GHC to do the linking and you don't need to manually track down everything the linker needs
16:09:26 <periodic> Speaking of which, is there a decent way I could call into Haskell from a Windows GUI?  I have all my parsing code in Haskell already.
16:09:55 <Andrew__C> periodic: exactly -  too expensive. GtKTV seems nice, but can't **** get Gtk to install. C headers. Hate them.
16:09:57 <periodic> acowley: at least with the GTK stuff you can just bundle the DLLs, which isn't too hard.
16:10:09 <Axman6> parcs``: as long as you can make C calls, it should be fine
16:10:10 <periodic> Andrew__C: I had no trouble installing GTK.  What system?
16:10:29 <parcs``> Axman6, stop that!!!
16:10:32 <periodic> Axman6: again!
16:10:36 <acowley> periodic: that's just the thing that is a pain to do
16:10:37 <Axman6> pargh!
16:10:52 <Axman6> periodic: see my last comment to parcs`` :P
16:11:25 <acowley> Axman6: most uses of foreign export have GHC running the final build step
16:11:34 <periodic> Axman6: Yeah, the issue is callbacks.  My main use case is prompting the user for a directory, then spawning a worker thread while updating the GUI with my progress.
16:11:41 <acowley> Axman6: which is a non-starter for a lot of situations
16:11:56 <Axman6> ah, i see :\
16:12:10 <ddarius> The FFI fully supports callbacks either way.
16:12:13 <periodic> I think the part I really need from the parsing code on the client-side is small enough that I'll just end up writing it in something more native at some point.
16:12:15 <Andrew__C> periodic: winXP.
16:12:30 <kmc> "haskell doesn't go GUIs well therefore GUIs suck and are for losers"
16:12:59 <periodic> Andrew__C: hmm... If I recall, I had to get and unpack the GTK files, then install the gtk-buildtools (or whatever) then install gtk.  What's the error you're getting now?
16:13:00 <kmc> just like IDEs and stack backtraces ;P
16:13:27 <mjrosenb> kmc: and terminals, and keyboards :-p
16:13:28 <companion_cube> and variables, and loops
16:13:42 <ddarius> On either Windows or Linux, I've never had any trouble using Gtk2hs or wxWindows, though I've mostly avoiding wx.
16:13:44 <Andrew__C> cabal install gtk fails because it can't find glib-2.0/glib.h
16:13:56 <Entroacceptor> the'[Dsre
16:14:00 <Entroacceptor> arg
16:14:00 <kmc> did you install the glib development package for your system?
16:14:07 <kmc> e.g. debian apt-get install libglib-dev
16:14:09 <Entroacceptor> there's a howto on the wiki
16:14:12 <ddarius> kmc: WinXP.
16:14:14 <periodic> Andrew__C: isn't that provided by your gcc?  What's your compiler?  I was using MinGW.
16:14:15 <kmc> :)
16:14:21 <ddarius> kmc: He just doesn't know how to install software.
16:14:37 <kmc> that sucks
16:14:40 <Entroacceptor> a friend got that to work without much hassle, I think
16:14:48 <NihilistDandy> brew info libglib
16:15:19 <kmc> periodic, many companies will love you for knowing haskell, even if they don't plan for you to write any on the job
16:15:33 <periodic> kmc: assuming they know what it is.
16:15:52 <mjrosenb> kmc: i'd mostly found that the people interviewing me were intimidated by it :/
16:15:54 <kmc> well, if you have the luxury of only working at companies where your coworkers have at least heard of haskell, i recommend it
16:16:21 <kmc> periodic, it correlates with intelligence -- not even because Haskell is hard, but just because learning a weird language for fun correlates with intelligence
16:16:26 <kmc> mjrosenb, oh, interesting -- can you elaborate?
16:16:33 <Andrew__C> I installed Gtk and Glade, which apparently also did install glib, anyway when I did cabal install glib it was already there, so I --reinstalled it anyway - no joy
16:16:54 <periodic> kmc: It's true.  If they'd never heard of Haskell I probably wouldn't want to work there anyway.
16:16:56 <ddarius> kmc: See.
16:17:00 <NihilistDandy> kmc: intelligence/next-big-thing syndrome
16:17:22 <periodic> I think mjrosenb has the main objection.  Some people dismiss it as pretentious or too abstract.
16:17:35 <kmc> the last job i had was writing python and systems-level C, at a company where most of the developers know haskell
16:17:39 <kmc> it was great
16:17:49 <ddarius> Then Oracle came...
16:17:57 <kmc> basically i think the language you use on the job doesn't matter all that much, but the people do
16:17:58 <eikke> oh, another Oracle victim?
16:17:59 <mjrosenb> periodic: or "oh god, I don't want this person writing C++ code that looks like haskell code"
16:18:03 <ddarius> Oracle destroys all that is good.
16:18:18 <kmc> if by "victim" you mean they gave my friends a huge amount of cash and increased the importance and exposure of the product
16:18:22 <kmc> then yes, another oracle victim
16:18:23 <mgsloan> one dismissal I've heard, which I don't agree with, is that Haskell tends to be "write only"
16:18:23 <eikke> ddarius: been there :) (startup -> Sun -> Oracle)
16:18:36 <periodic> I think its a huge benefit to have the team all think alike, and when you have one person who is basically writing their C++ to be assembly, and someone who is writing it to look like Haskell, you're going to have issues.
16:18:37 <kmc> so terrible to be given a huge amount of cash and an army of people to sell the thing you made
16:18:38 <eikke> ah, killed ours, and no big cash :P
16:18:39 <c_wraith> write-only haskell is doing it wrong
16:19:05 <mgsloan> yup, but it's an easy trap to fall into, particular if you get too zealously pointless
16:19:14 <kmc> c_wraith, or the reader is just at the "saw a quicksort once" level
16:19:17 <Andrew__C> ddarius: then can you explain?
16:19:24 <kmc> there is a lot to learn before you can read real-world haskell code
16:19:32 <kmc> even if it's written in clean, idiomatic ways
16:19:37 <kmc> there are a lot of idioms :)
16:19:49 * Andrew__C is annoyed if he's expected to be able to use C before using Haskell
16:19:53 <periodic> Andrew__C: hmm... I'm not sure.  Just start at the bottom and try to rebuild things all the way up, satisfying dependencies as you go.
16:20:06 * Andrew__C is annoyed if the how to do it on the webpage fails
16:20:17 <mgsloan> that's the thing, there're library specific idioms, which is both a great thing and a potential damper on readability
16:20:19 <ddarius> Andrew__C: No, you just need to know how to install C development libraries, and only before using a Haskell binding to a C library.
16:20:21 <periodic> kmc: same can be said of lots of C++ code too
16:20:26 * Andrew__C is annoyed if the system is so complex it's not deterministic
16:20:35 <kmc> assessing how people will write C++ is different from assessing how they write almost anything else
16:20:45 <kmc> but, i fear i'm derailing this into one of the Standard Off-Topics
16:20:50 <ddarius> Andrew__C: cabal install glib won't help you in any way.  glib is not a Haskell library.
16:20:52 <Axman6> i'm helping reqrite the first year haskell course at my university (sort of, giving advice and writing the second assignment anyway), and we've decided that we need to use a pared down version of haskell. we're going to completely ignore things like if statements, and encourage pattern matching, and probably guards too
16:20:57 <monochrom> japanese is unreadable, write-only, etc
16:21:11 <ddarius> monochrom: Not as much as Chinese.
16:21:14 <Axman6> rewrite*
16:22:08 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg46008.html
16:22:17 <Andrew__C> ddarius: what should I install, how? I already installed libxml and libxml-dev and Gtk. should I try installing glib from some Gnome website?
16:22:30 <Sgeo> I know that DSL is domain-specific language, but what's an EDSL?
16:22:41 <Axman6> Sgeo: Embedded
16:22:41 <jessopher> embedded
16:22:49 <Sgeo> ah
16:23:31 <NihilistDandy> –ù–∏–∫—Ç–æ –Ω–µ –º–æ–∂–µ—Ç —á–∏—Ç–∞—Ç—å –ø–æ —Ä—É—Å—Å–∫–∏.
16:23:33 <eikke> Sgeo: instead of writing your own lexer/parser/compiler for some custom language, you embed a DSL in a host language, using the constructs provided by the host language
16:23:55 * Sgeo is planning on making an EDSL for writing LSL scripts
16:24:04 <ddarius> monochrom: I agree with your email 100%.
16:24:08 <Sgeo> Rather than my original plan of making a new programming langyage
16:24:09 <monochrom> hehe
16:24:39 <Sgeo> Although it will be harder to teach LSL people enough Haskell to get them to be able to comfortably use this thing
16:24:40 <AfC> I've been unable to figure out what the difference is between an embedded domain specific language ... and a library API
16:25:03 <c_wraith> AfC: in haskell, there isn't one
16:25:17 * BMeph wishes -cafe had a "+1" feature, now...
16:25:39 <nus> NihilistDandy, –≤–æ—Ç –≤–æ–∑ –∑–∞—Ç –ª–∞–π–Ω –Ω–æ–π–∑?-)
16:25:39 <Andrew__C> Axman6: I would go for web interface if I didn't have to learn a DSL. There are some encouraging things on Yesod, but still.... anyway, web frontend no use for hacking own filesystem, surely
16:25:46 <AfC> c_wraith: right, which is why I wonder why such a big deal is made of the concept round these parts.
16:25:57 * monochrom excels at writing parodies
16:27:25 <NihilistDandy> nus: :P
16:27:28 <Andrew__C> AfC: I'd say the difference between EDSL and library API is how much you need to change the way you think to use it
16:28:14 * BMeph prefers monochrom to the Onion!
16:28:26 * hackagebot propane 0.1 - Functional synthesis of images and animations  http://hackage.haskell.org/package/propane-0.1 (KeeganMcAllister)
16:28:26 <Andrew__C> AfC: API: learn some new functions and typeclasses, use, mix with existing paradigm. EDSL: think in new way, use solely new way
16:28:27 <ddarius> BMeph: That's not saying anything.
16:28:43 <kmc> there is no hard distinction between an EDSL and a library.
16:28:48 <kmc> that's true in Haskell and it's true in other libraries
16:29:00 <kmc> "EDSL" is a fuzzy term for describing a philosophy of designing and using libraries
16:29:06 <Axman6> i think the LLVM package is a great example of an EDSL. you feel like you're writing LLVM code, but it's all in Haskell
16:29:18 <BMeph> ddarius: And yet, I (didn't?) said it.
16:29:23 <jessopher> or any GUI library
16:29:23 <Andrew__C> kmc: I agree
16:29:36 <jessopher> since you get a whole new set of primitives
16:29:36 <kmc> NihilistDandy, –¥–∞ –Ω–µ—Ç –≤–æ–¥–∫–∞
16:29:40 <Sgeo> Is it a bad idea to write a Haskell EDSL targetted to people who don't know Haskell?
16:29:43 <Sgeo> >.>
16:29:56 <kmc> Sgeo, xmonad config files are a successful example of that
16:30:02 <Axman6> i believe it's been done at at least one bank Sgeo
16:30:05 <kmc> it's tricky but doable
16:30:17 <kmc> it depends how much they need to do, how smart they are, how easily they will get frustrated or bored
16:30:22 <kmc> basically how much they care
16:30:49 * monochrom prefers the Bloomin' Onion to the Onion :)
16:31:07 <hiptobecubic> what's that thing that shows you via parens the evaluation precedence of an expression?
16:31:10 <Axman6> is that the australian version?
16:31:32 <hiptobecubic> lambdabot does it, but i forgot the keyword
16:31:33 <monochrom> I only know the version by the Outback Restaurants
16:31:48 <NihilistDandy> kmc: That's a very odd expression
16:31:51 <Axman6> those places are3 so amazingly unaustralian
16:31:55 <Axman6> -3
16:32:32 <monochrom> right, but I don't mind
16:32:36 <Axman6> i decided I'd go to one in Tokyo... never got in the door. i read the menu and was offended
16:32:43 <kmc> yes, and panda express is so un-chinese, but it's still effing delicious
16:33:06 <kmc> though after eating there i usually want to avoid it for several months
16:33:09 <monochrom> panda express doesn't feature panda steak :)
16:33:14 <jessopher> parsers are generally pretty easy to write (for small languages), i would go through that extra trouble to shield a set of users unfamiliar with the host language. if they need access to arbitrary libraries in the host language to suplement their usage of dsl, then its different
16:33:23 <kmc> monochrom, not on the menu, you have to know the passphrase ;)
16:33:30 <monochrom> oh yikes
16:33:33 <kmc> jessopher, parsing is not the issue.
16:34:27 <monochrom> I don't know of a lambdabot command for adding back parentheses
16:34:34 <kmc> basically everything starts as "just a config file" and eventually grows variables, conditionals, loops, functions, lists, other data structures, and eventually a bastardized lambda calculus
16:34:37 <Axman6> me either...
16:34:44 <kmc> if you approach it as "just a config file" then each step of that is painful and ugly
16:34:45 <monochrom> but I do know a monochrom command for that.
16:34:50 <drdo> Lemmih: bencode's bRead is throwing exceptions
16:34:52 <Axman6> hiptobecubic: if such a sommand exists, :help will tell you what it is
16:36:15 <sebz> is Hask a topos?
16:37:40 <acowley> Axman6: I tied the quasicrystal demo into gloss for a live display. It is awesome :P
16:38:06 <Axman6> awesome :D
16:38:29 <Axman6> at some point, you'll have to stop playing, and start blogging :P
16:38:46 <acowley> I need to cook dinner sooner than that or I won't be very popular around here :/
16:39:00 <Axman6> i need to go get lunch... starving
16:39:27 <jessopher> kmc:  so you are basically saying that writing parsers for a dsl, is premature optimization, and will end up convoluting the interface as it grows?
16:39:42 <kmc> it's not about "parsers"
16:39:49 <jessopher> what isnt?
16:40:00 <kmc> it's about whether you reimplement every standard language feature, or borrow it from somewhere else
16:40:35 <kmc> for example there are alternative syntaxes for Ocaml, with their own parsers, but they use the same language semantics implementation
16:40:39 <kmc> ditto the She preprocessor for Haskell
16:41:10 <ddarius> sebz: Tell me how you make it into a category first.
16:42:11 <Mathnerd314> kmc: I want to re-implement call-by-name/value, syntax, type classes, and records. (starting from Haskell)
16:42:34 <kmc> most Lisp EDSLs have a "custom parser" in that they define custom context-free abstract syntax
16:42:37 <kmc> using macros to do so
16:42:47 <kmc> but they are still embedded in Lisp and have all Lisp features available
16:42:49 <Mathnerd314> kmc: where should I start?
16:43:07 <Mathnerd314> and if I'm being annoying please tell me
16:43:15 <kmc> Mathnerd314, don't know
16:43:23 <kmc> for types see "Typing Haskell in Haskell"
16:43:47 <kmc> for efficient compilation see "Implementing lazy functional languages on stock hardware: the spineless tagless G-machine" and "How to make a fast curry"
16:44:01 <kmc> see the Haskell Report for syntax especially layout
16:44:28 <sebz> ddarius: is Hask not a category?
16:44:31 <wereHamster> how can I load multiple files into ghci?
16:44:47 <wereHamster> :l file1 file2 doesn't seem to work, functions from file2 are not available
16:45:00 <Andrew__C> wereHamster: :a other.hs
16:45:55 <Mathnerd314> kmc: I am amazed that Google made the paper the first result for "How to make a fast curry"
16:46:11 <wereHamster> Andrew__C: hm, if I :a other, then the functions from the first file disappear
16:46:53 <Andrew__C> wereHamster: no, they're there, but yes, you can only use them if you're currently in that module.
16:47:19 <foobarbaz> @unpl id
16:47:19 <lambdabot> (\ a -> a)
16:47:20 <Andrew__C> wereHamster: why not add import other.hs at the top of first.hs for the time being?
16:47:22 <wereHamster> so what's the best way if I want to use functions from different modules?
16:47:54 <kmc> Mathnerd314, Google customizes search results
16:48:01 <jessopher> kmc: well the lisp case is substantially different from the general case. and DSL does not imply any sort of relation to a host language anyway. So if you are chosing between an EDSL interface, and a DSL that is independent of the host language, then parsing becomes significant
16:48:14 <Andrew__C> wereHamster: make one module that uses them all, add import statements for the modules you're using
16:48:44 <wereHamster> Andrew__C: thanks, I'll do that
16:48:59 <Andrew__C> wereHamster: instead of :a Other.hs, put import Other - you don't need the .hs on an import statement
16:49:04 <kmc> jessopher, yes, parsing is significant
16:49:15 <ddarius> sebz: Define Hask.
16:49:22 <kmc> you said "parsers are generally pretty easy to write" and my point is that's not so relevant to the benefits of an EDSL
16:49:34 <jessopher> no, not edsl
16:49:35 <kmc> not having to write a parser is a secondary benefit
16:49:43 <kmc> of edsls
16:49:43 <jessopher> oh, i see
16:49:46 <kmc> it's a benefit only for the implementor
16:50:03 <kmc> having real language features instead of some crap added hack-by-hack is the real benefit
16:50:20 <kmc> i'm sure you've seen these "config file languages" which have grown bizarre forms of loops, variables, etc.
16:50:27 <kmc> as, over the years, people decided they needed them
16:50:35 <jessopher> yeah
16:50:38 <Axman6> @unpl (,,,)
16:50:39 <lambdabot> (,,,)
16:50:44 <Axman6> :(
16:50:50 <hpaste> acowley pasted ‚ÄúOpenCL quasicrystal gloss animation‚Äù at http://hpaste.org/55571
16:51:25 <Mathnerd314> kmc: ok. I am confused that he is discussing push vs. eval when there isn't really a choice
16:52:11 <Axman6> acowley: mind pasting the kernel code too? just interested in seeing it
16:52:19 <Mathnerd314> kmc: I guess that's his conclusion?
16:52:28 <kmc> how do you mean there isn't a choice
16:52:41 <hpaste> acowley pasted ‚ÄúOpenCL quasicrystal animation kernel‚Äù at http://hpaste.org/55572
16:53:11 <Axman6> thanks =)
16:53:11 <kmc> jessopher, and Lisp, She, Coffeescript, Ocaml's revised syntax, etc. show how you can have that primary benefit even if you want a custom parser with custom syntax
16:53:24 <sebz> ddarius: Cppo‚ä•? Just going off of ttp://www.cs.gunma-u.ac.jp/~hamana/Papers/cpo.pdf
16:53:34 <sebz> http://www.cs.gunma-u.ac.jp/~hamana/Papers/cpo.pdf
16:53:37 <Mathnerd314> kmc: the choice I'm familiar with is between call-by-name and call-by-value, but in a compiler you can't choose between them
16:53:47 <Mathnerd314> because they're basically the same
16:53:59 <kmc> Mathnerd314, well... that's not what push/enter and eval/apply are about, in the context of that paper
16:54:02 <acowley> Axman6: I should be able to write it up tomorrow
16:54:07 <kmc> it implies that both strategies were implemented in GHC at some point
16:54:28 <Axman6> acowley: fantastic! I look forward to it, and being able to play with the code
16:55:06 <Mathnerd314> kmc: ah. I read the slides instead of the paper... (PDF vs. PS)
16:56:00 <Mathnerd314> that has little relevance actually
16:56:32 <Mathnerd314> so what should I get from that paper, other than that "GHC has a bunch of stuff that's good"?
16:56:44 * Axman6  -> lunch
16:57:04 <kmc> tricks for producing efficient machine code for lazy (call-by-need) evaluation
16:57:05 <Andrew__C> OK: Gtk install may now work: advice: mingw installation is NOT optional!
16:57:38 <ddarius> sebz: The answer is in slide 5 if you can interpret what it is saying.
16:57:48 <Andrew__C> oh I spoke too soon. same failure!
16:58:33 <Mathnerd314> kmc: but those tricks are implemented in GHC already. So since I'm starting from GHC...
16:59:12 <Mathnerd314> I'm trying to figure out which parts I need to replace
16:59:18 <kmc> Mathnerd314, oh, I misunderstood your goal then
16:59:54 <jessopher> kmc: though, i do believe that the presence/absense of a parser is a benefit/detriment to more than just the implementor. My (maybe poorly stated) point was that parsers aren't too hard, so if your users will benefit from not having to think about the host language, they can be a good idea.
17:00:29 <kmc> it depends
17:01:09 <kmc> a lot of projects start off with a custom parser because "we don't want to make them learn Python syntax" and end up with something which is equivalent in complexity to Python syntax, but much harder to learn because there are fewer resources
17:01:24 <jessopher> true
17:01:34 <kmc> i mean, whatever you design has to be learned too
17:02:06 <shapr> Thus xmonad works nicely for me... since I just write Haskell to configure my window manager.
17:02:10 <Mathnerd314> kmc: my design is "EBNF"
17:02:42 <jessopher> yes, if you users are people who are willing to learn, or already know the host language, then EDSL's are ideal
17:02:56 <Mathnerd314> kmc: slanted towards Haskell
17:02:56 <kmc> jessopher, or the small subset of the host language that they need in order to do their job
17:03:04 <jessopher> right
17:03:11 <kmc> which might be simpler than whatever you can throw together custom
17:03:15 <kmc> or at least better documented
17:03:24 <drdo> How do i tell haskell-mode to pass some arguments to ghci?
17:03:38 <drdo> (or how do i tell it the search path)
17:04:38 <kmc> jessopher, it's a complicated tradeoff, hard to say anything general about it
17:05:38 <kmc> i do think in general that there's a bias towards reinventing systems which look too complex, because you haven't yet realized that you'll need the complexity
17:05:57 <kmc> real systems have known, real flaws and so are unattractive.  hypothetical projects at the design stage have no flaws :)
17:06:02 <mike-burns> Hence why people re-invent `make' all the time.
17:06:40 <kmc> also a mature, stable, tested, documented implementation of 200% of what you need might be less net complexity than a custom implementation of exactly 100% what you need
17:06:55 <kmc> shrug
17:06:58 <kmc> these are hard questions
17:07:01 <kmc> that's why we get the big bucks
17:07:05 * jessopher . o (hence why i prefer parser combinators to parser generators)
17:08:32 <shapr> kmc: On the good side, the reinvention is a great way to educate yourself about the project you discarded as too complicated at the beginning.
17:08:43 <kmc> yeah
17:09:23 <mreh> I had the choice of drupal, with all its flaws, over a happstack
17:09:29 <mreh> i chose drupal, simple choice
17:09:39 <kmc> but you might get stuck with the inferior reimplementation due to pride, sunk costs, inertia, etc.
17:11:09 <mike-burns> Re-inventing for education is fantastic, so long as you throw it away and use the existing one when you've learned.
17:11:11 <kmc> mreh, how did it work out?
17:11:40 <jessopher> but sometimes it works out, if maybe only because you are lucky
17:11:54 <kmc> fwiw I'm not saying reimplementing things is always bad... I think several of the reimplementations of the 'make' idea are much better than make
17:12:01 <mreh> kmc, pretty well, i implemented the whole thing in about the time it took me to implement sessions in haskell
17:12:26 <shapr> Did you try yesod?
17:12:33 <mreh> no
17:13:11 <mreh> what's it like
17:13:21 <kmc> probably still more work than installing drupal ;P
17:14:48 <kmc> implementing a full-featured CMS is going to be a lot of work no matter what webapp framework or magical messiah language you use
17:15:20 <mreh> i spent so long dreaming up an FRP webserver where the lines between client and server are blurred i got behind schedule
17:15:34 <kmc> theoretically uninteresting, time-consuming work
17:15:56 <kmc> i think sometimes we lose sight of the fact that theoretically uninteresting "solved problem" work is still work
17:16:09 <Axman6> :(
17:16:17 <mreh> the problem of CMSs has not been siffienctly solved to warrant an implementation yet
17:16:51 <ddarius> kmc: I would say the problem is that people are all to aware of that fact.
17:16:58 <ddarius> s/to/too/
17:16:59 <shapr> I worked on HAppS from early on, yesod is much more like a full framework. But it's still not drupal.
17:17:12 <mreh> so we like drupal here?
17:17:15 * monochrom has solved the CMS problem with http://www.vex.net/~trebla/humour/lmcify.html
17:17:16 <shapr> I use hakyll
17:17:25 <ddarius> Drupal is a specific application.
17:17:55 <kmc> monochrom, sweet, this is the perfect app for my wikipedia citations
17:18:40 <monochrom> I might yet use it for my thesis :)
17:18:50 <kmc> ddarius, how's that?
17:18:55 <kmc> ("too aware")
17:20:00 <ddarius> kmc: Dreaming up FRP webservers is play.  Most people would rather play than work.
17:20:18 <kmc> heh
17:20:21 <kmc> yes, fair enough
17:20:25 <mike-burns> I agree with the first half of that claim.
17:20:29 <mreh> i wan't conal's job, that seems like play
17:21:41 <monochrom> I want cron's job
17:21:43 <mreh> ddarius: you never worked at the last place i did
17:21:48 <ddarius> Last I heard, conal was unemployed.  Admittedly, last I heard was a while ago.
17:21:56 <shapr> I want to get a Haskell job, after I finish my degree.
17:21:56 <ddarius> mreh: Probably not.
17:22:14 <shapr> Hopefully somewhere I can work with generating code for embedded systems.
17:22:41 <mreh> conal is at tabula
17:22:50 <kmc> ddarius, i refer to the phenomenon where you ask here "how do I do foo in Haskell" and the answer is "it's trivial, using Data.Baz" and what this really means is "i cannot immediately see how any unsolved problem of mathematics would obstruct writing from scratch a program that does foo, using Data.Baz in one place"
17:22:51 <mreh> i was referring to his research actually
17:24:25 <kmc> i wonder how many employees Tabula has
17:24:46 <monochrom> no. I say that to mean "I am too lazy to write it".
17:25:06 <ddarius> I say that to mean "STFU."
17:25:37 <monochrom> or rather, "I cannot immediately see how me not getting paid obstructs you writing it"
17:26:58 <monochrom> also, I delete "it's trivial"
17:27:28 <ddarius> I delete "using Data.Baz."
17:27:40 <shachaf> monochrom: Your authoritative source is not so authoritative.
17:28:00 <shachaf> (See: <http://www.vex.net/~trebla/humour/lmcify.html?t=http://www.vex.net/~trebla/humour/lmcify.html+is+not+so+authoritative>.)
17:28:22 <ricree> Is there a way to pattern match on constructor type rather than the constructor itself?  Like if I had a type "data Foo = A String | B Int | C Int", could I have a function that matched on B and C on one line in such a way that I'd still have the Int?
17:28:24 <drdo> Is there a lib for conversion between Words and ByteStrings? (reading big endian integers from the network)
17:28:36 <mreh> i always forget jules bean's nick
17:28:52 <shachaf> ricree: You can define a record accessor with the same name for both of them.
17:29:05 <shachaf> ricree: As in data Foo = A String | B {x :: Int} | C {x :: Int}
17:29:12 <shachaf> ricree: And then call x.
17:29:46 <shachaf> ricree: Alternatively, you can do something like data BorC = B | C; data Foo = A String | NotA BorC Int
17:31:55 <shachaf> mreh: quicksilver
17:32:10 <mreh> shachaf: yo
17:32:18 <shachaf> mreh: (See also: /who *jules bean*)
17:32:33 <mreh> brap!
17:32:56 <ricree> thanks shachaf.  Out of curiosity, it there any reason something like "myFunc (A str) = ...;myFunc (_ n) = ..." couldn't be valid?  Having tried it, I see it isn't something you can do, but I'm curious if there's any particular hangup beyond it not actually being in the language
17:34:12 <shachaf> ricree: Well, It only makes sort of sense in a very limited case where you have multiple constructors with the exact same type.
17:34:47 <shachaf> (Unless you're suggesting that data Foo = A Char Int | B Bool Int; f :: Foo -> Int; f (_ _ x) = x should work?)
17:35:32 <shachaf> Also, "_" generally means "ignore this argument"; but if you're pattern-matching on a constructor then you can't ignore it.
17:35:50 <kmc> you can also get all the Int fields of a value using Data.Data / syb
17:35:56 <kmc> but it's probably not very nice / worth it
17:35:59 <shachaf> It would be a very odd thing to do, in general.
17:36:11 <kmc> Haskell is a pretty boilerplatey language, sometimes one just has to live with that
17:37:37 <kmc> sometimes you can avoid it by refactoring your data type, as shachaf suggested
17:37:48 <hpaste> tgeeky pasted ‚Äúpango under 7.4.1rc1‚Äù at http://hpaste.org/55573
17:38:09 <tgeeky> suggestions on how to proceed
17:38:13 <tgeeky> woo, approve of new announce format
17:38:24 <kmc> but that introduces its own boilerplate (such as additional constructors)
17:39:04 <shachaf> lambdanaut: Your nick is the bane of tab completers everywhere in #haskell.
17:39:14 <alistra> preflex: seen edwardk
17:39:14 <preflex>  edwardk was last seen on #haskell 2 days, 19 hours, 5 minutes and 8 seconds ago, saying: rwbarton: i think the key is just accepting that overlapping instances isn't just a slightly bad idea, but that types with 1-2 overrides like it tends to encourage lead to bad overall behavior for the type system in general
17:40:50 <alistra> lambdabot should be able to have a userlist of the irc and logs
17:40:53 <lambdanaut> Yeah, but sometimes people message me accidentally and it gives me a short period of life in which I'm not desperately lonely
17:41:17 <jessopher> hah
17:41:30 <kmc> aww
17:41:53 <jessopher> do you try to respond like labdabot to prolong the interaction?
17:41:54 <alistra> @where lambdabot
17:41:54 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
17:44:25 <alistra> @hackage lambdabot
17:44:25 <lambdabot> http://hackage.haskell.org/package/lambdabot
17:45:08 <Sgeo> :i (>>=)
17:45:14 <Sgeo> @info (>>=)
17:45:14 <lambdabot> (>>=)
17:45:19 <Sgeo> Useful.
17:45:20 <kmc> try ghci
17:45:25 <alistra> @vixen help
17:45:25 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
17:45:37 <alistra> @vixen help
17:45:37 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
17:46:00 <Sgeo> infixl 1
17:46:04 <kmc> vixen said something about masturbation and so was banned for being offensive
17:46:38 <parcs``> "Type indexes must match class instance head Found `k' but expected `k'" :(
17:46:48 <kmc> apparently nixon's racism, anti-semitism, and homophobia is not as offensive as the idea that women masturbate
17:47:14 <alistra> freedom of speech
17:47:18 <alistra> is the shit
17:47:27 <shachaf> kmc: That seems like a sexist interpretation of it.
17:47:45 <shachaf> kmc: I doubt that the objection was because of vixen's "gender".
17:47:47 <kmc> maybe, i don't even know what the original vixen quote was
17:47:48 <shapr> Feel free to take this discussion to #haskell-blah
17:48:03 * shachaf takes it to #haskell-/dev/null
17:48:11 <kmc> but i have a hard time imagining it's more offensive than the average @nixon quote
17:48:13 <kmc> having seen many of each
17:48:28 * hackagebot colour 2.3.2 - A model for human colour/color perception  http://hackage.haskell.org/package/colour-2.3.2 (RussellOConnor)
17:49:05 <shapr> truly, @nixon quotes get way offensive
17:49:08 <shapr> Why the heck are they in there?
17:49:26 <kmc> amusement
17:49:32 * shapr shrugs
17:49:44 <parcs``> kmc, did you get your generic Functor thing to work
17:49:48 <kmc> no
17:49:49 <alistra> shouldn't they be there because of the offensiveness?
17:49:58 <kmc> i think vixon should be restored, but i think the current double standard is way more offensive than any of the quotes
17:50:05 <kmc> but that's just me
17:52:58 <ddarius> kmc: What double standard?  If @nixon offends you, and you object to it, I'm sure it will be removed as well.
17:53:12 * ddarius feels offended by @run.
17:53:35 * Axman6 gets offended by (.) in lambdabot
17:53:38 <kmc> ddarius, the double standard where @vixen's quotes were offensive, but @nixon's are apparently fine
17:53:50 <kmc> there are two ways to resolve this double standard, I am okay with either
17:53:51 <mreh> everyone hates nixon, it's okay
17:54:03 <shachaf> kmc: I think it's more that someone complained about @vixen, as ddarius says.
17:54:11 <kmc> anyway, I have said this multiple times here, does that not qualify as "object[ing] to it"
17:54:12 <ddarius> shachaf understands.
17:54:25 <kmc> do i have to PM an op, or sign my name or something?
17:54:28 <monochrom> you have to raise it when Cale is around
17:54:43 <ddarius> kmc: So you want @nixon removed because it offends you?
17:54:53 <kmc> nope
17:55:01 <kmc> i want @nixon removed or @vixen reinstated
17:55:14 <roconnor> O_o
17:55:36 <roconnor> Axman6: I'm offended by (.) . (.)
17:55:42 <ddarius> kmc: Then, no, what you have said does not qualify as objecting to @nixon because @nixon offends you.
17:55:47 <kmc> ok
17:56:06 <kmc> i'll bring it up when Cale is around
17:56:08 <roconnor> And I'm really offended by (.) . (.) . (.)
17:56:19 <Axman6> star wars boobies!
17:56:21 <alistra> being offended is ridiculous
17:56:27 <jessopher> ^^
17:56:29 <ddarius> alistra: I agree.
17:56:30 <hpc> Axman6: bahaha, was about to say exactly that
17:56:32 <alistra> there is no thing in the world that can offend me
17:56:34 <hpc> Axman6: down to the character
17:56:35 <Axman6> XD
17:56:42 <Axman6> hahaha
17:56:48 <mreh> alistra: justin bieber
17:56:48 <kmc> alistra, so you don't find nazi ideology offensive?
17:56:50 <rostayob> kmc: i remember when they banned vixen, it was something she said about horny teenagers
17:56:56 <alistra> and i don't respect people being offended by stuff
17:57:25 <hpc> kmc: it's like @protontorpedo
17:57:30 <kmc> i thought it was this one: <lambdabot> girls masturbate too you know... probably more than guys. we can do it anywhere discretely
17:57:31 <alistra> i won't sacrifice my convinience and funny quotes, because 'lol nixon killed 6mln jews and that offends me'
17:57:41 <hpc> kmc: a jab at crazy people by means of quote db
17:57:47 <rostayob> kmc: mhmm... i'm not sure now
17:57:53 <rostayob> what do you care anyway
17:57:59 <rostayob> (about vixen & nixon)
17:58:16 <kmc> i care because the current state indicates a warped, offensive set of values in the community
17:58:30 <rostayob> well vixen could offend someone
17:58:33 <rostayob> i don't think that nixon can
17:58:38 <alistra> kmc: nope, why would it be offensive?
17:58:41 <shachaf> Well, in one person.
17:58:43 <kmc> <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
17:58:53 <kmc> <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it is because most of them are psychiatrists.
17:58:53 <rostayob> kmc: hah ok.
17:58:54 <alistra> kmc: how can an idea be offensive
17:59:12 <rostayob> fair point, you're right then
17:59:20 <rostayob> i never got those out of nixon :)
17:59:29 <kmc> http://hpaste.org/55526 is the full list
17:59:37 <parcs``> vixen got removed because of sexism or something
17:59:42 <alistra> lol @ those being to offensive
17:59:45 <rostayob> parcs``: yes
17:59:51 <Axman6> alistra: i reckon :\
17:59:58 <kmc> parcs``, right, so we're saying sexism is bad but homophobia and anti-semitism are fine
18:00:01 <rostayob> because it could scare the few females here apparently
18:00:10 <rostayob> i doubt that anyways
18:00:23 <kmc> "You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to..."
18:00:24 <alistra> well that's sad @ rostayob
18:00:27 <mreh> oh, god that argument
18:00:50 <alistra> kmc: :D
18:00:58 <rostayob> kmc: they'll probably ban both if you bring it up
18:01:07 <kmc> it's possible some of these were removed from the running instance of lambdabot
18:01:12 <kmc> the first two i got just now in PM
18:01:47 <kmc> rostayob, well i've brought it up at least three times now, in this channel
18:02:04 <parcs``> really the removal of vixen was quite abrupt
18:02:18 <kmc> nope i just got the "the blacks" quote in PM too
18:02:19 <rostayob> yeah byorgey wanted it banned (iirc)
18:02:19 <parcs``> someone complained, told Cale, 2 min later it was removed
18:02:58 <kmc> i'm not sure which quote it was
18:03:09 <kmc> but if it was the "women masturbate" quote then it's an instance of a common double standard
18:03:10 <rostayob> kmc: do you have a list of vixen's quote?
18:03:12 <ddarius> Yes, I suspect this is more a matter of timing than "community values."  I highly suspect the vast majority of people here don't give a fuck what @vixen or @nixon say.
18:03:28 <mreh> i thought vixen was a bot
18:03:44 <Axman6> mreh: exactly -_-
18:03:53 <shachaf> ddarius's suspicion seems correct to me.
18:03:55 <Axman6> how someone can be that offended by s sinple bot i have no idea
18:04:05 <kmc> let's add @hitler too
18:04:08 <alistra> lol, people take those quotes seriously? i always laughed at them not because i'm racist, but i laughed at people who think such things. Like for example there's no good reason why intelligence would distribute in a different way because of the race or gender, there's maybe like 1% difference, but it's not really affecting anything
18:04:09 <mreh> hah
18:04:09 <kmc> on that basis
18:04:10 <Axman6> ok
18:04:20 <jessopher> i think people like to claim offense, just to make a point
18:04:22 <kmc> anyway
18:04:24 <kmc> having godwin'd myself
18:04:30 <kmc> you can all get to work on that
18:04:33 <kmc> i'll bbl
18:04:34 <ddarius> kmc: I highly suspect the vast majority of people here would not care a whit if you added a @hitler.
18:05:05 <alistra> jessopher: it's called the holocaust card
18:05:15 <mreh> we have proved that hitler was better than vixen
18:05:22 <Axman6> apart form the fact i don't think much he said was funny. i wouldn't be offended, but i wouldn't be interested either
18:05:33 <ben> I don't have a strong opinion about irc bot features but I'd rather not be reminded of random republican homophobia
18:05:43 <alistra> @meinkampf
18:05:43 <lambdabot> Unknown command, try @list
18:05:45 <jessopher> the only time ive ever seen off color jokes lead to real problems, is when a) people who complained about them are taken seriously, or b) when its in person, and persistent, and the offended party has no means of avoidance
18:06:14 * ddarius appends "and a shotgun" to the end of jessopher's comment.
18:06:23 <jessopher> :P
18:06:36 <alistra> why colored people don't joke about white people? or do they? i don't know?
18:06:40 <Axman6> also, @haskhitler has the potential to be hilarious: We must eliminate all the mutations! .... actually, that is quite offencive if taken wrong o.O
18:07:00 <alistra> why don't everybody just joke about whatever [s]he wants
18:07:09 <rostayob> alistra: because white people are not a minority here :(
18:07:20 <rostayob> it's hard to joke about majorities
18:07:33 <alistra> is it, cracker?
18:07:37 <ben> alistra: race relations aren't symmetrical
18:07:59 <alistra> ben: so what?
18:08:09 <rostayob> alistra: cmon you're not going to hurt my feelings calling me cracker
18:08:11 <alistra> i don't see the difference lol
18:08:35 <jessopher> alistra: if there is nobody there to laugh at your joke, it looses its effect
18:08:44 <jessopher> loses too
18:09:07 <alistra> hey, when people joke about me i even laugh sometimes
18:09:26 <ddd> hi
18:09:30 <ddarius> The remaining times alistra murders.
18:09:34 <jessopher> alistra: if only everyone were as even keeled as you, the world would be rainbows and unicorns
18:09:34 <alistra> one of the best about me is 'you're so fat that your blood type is snickers'
18:09:48 <alistra> ddarius: remaining times the jokes aren't too good
18:10:20 <alistra> @define keeled
18:10:23 <alistra> @wn keeled
18:10:24 <lambdabot> *** "keeled" wn "WordNet (r) 3.0 (2006)"
18:10:24 <lambdabot> keeled
18:10:24 <lambdabot>     adj 1: having a ridge or shaped like a ridge or suggesting the
18:10:24 <lambdabot>            keel of a ship; "a carinate sepal" [syn: {ridged},
18:10:24 <lambdabot>            {carinate}, {carinated}, {keeled}]
18:10:26 <parcs``> snickers actually isn't that fattening
18:11:01 <alistra> parcs``: well i'm actually fat :P
18:11:52 <jessopher> @wn even keeled
18:11:53 <lambdabot> *** "even" wn "WordNet (r) 3.0 (2006)"
18:11:53 <lambdabot> even
18:11:53 <lambdabot>     adv 1: used as an intensive especially to indicate something
18:11:53 <lambdabot>            unexpected; "even an idiot knows that"; "declined even to
18:11:53 <lambdabot>            consider the idea"; "I don't have even a dollar!"
18:11:55 <lambdabot> [40 @more lines]
18:12:10 <jessopher> bah
18:12:17 <alistra> @wn "even keeled"
18:12:17 <lambdabot> No match for ""even keeled"".
18:12:49 <alistra> jessopher: you and your white-people-aristocratic-speak
18:12:56 <jessopher> :D
18:13:21 <alistra> (still don't know what it means)
18:13:33 <alistra> > users
18:13:34 <lambdabot>   Not in scope: `users'
18:13:38 <alistra> > names
18:13:39 <lambdabot>   Not in scope: `names'
18:14:11 <shachaf> alistra: Are you aware of /msg lambdabot?
18:14:47 <hpc> > /msg lambdabot -- :D
18:14:47 <lambdabot>   <no location info>: parse error on input `/'
18:14:49 <alistra> shachaf: yeah, but if it worked as i intended, it would list the users on the channel, and it really doesn't have any sense on priv, does it?
18:17:23 <jessopher> alistra: the websters definition is: characterized by stability or consistency (in this case, in regarding how possibly offensive statements are internalized) "i am not offended by jokes at the expense of others, therefore, i am not offended by jokes at my expense"
18:17:26 <alistra> when i'll learn dars, i'll write a lambdabot patch that does that :3, and I will able to check who else has a problem with same prefixes and tab completion like lambdabot lambdanaut
18:24:59 <byorgey> shapr: (1) a native SVG backend is under development, I will be hacking on it in the next few days, and am open to any suggestions re: features
18:25:30 <byorgey> shapr: (2) sorry about the redirect loop, I updated the google code wiki but haven't yet updated the home page... the wiki is at haskell.org/haskellwiki/Diagrams
18:29:38 <Axman6> hmm, this looks quite interesting: http://www.haskell.org/pipermail/glasgow-haskell-users/2011-December/021319.html
18:31:55 <gwern> text src =  head $ map (takeWhile (/= ' ') . drop 17) [x | " has been viewed " `isInfixOf` x, (TagText x) <- src]
18:32:02 <gwern> throws an error about x not being defined?
18:32:53 <Axman6> you need to do the (TagText ,x) <- src first no?
18:32:56 <byorgey> gwern: scoping goes from L -> R
18:33:00 <gwern> oh
18:33:13 <Axman6> remember, it's basically just do notation... with some extra fluff
18:33:27 <byorgey> except that everything after the | is also in scope before the |
18:33:57 <ddarius> Mathematicians are not always the best people to use as sources of notation.
18:34:12 <Axman6> well, that's just because everything before the | is the same as putting return <stuff> at the end of the stuffon the right =)
18:34:51 <ddarius> (To be more precise "unambiguous notation.")
18:37:34 <roconnor> byorgey: colour is updated
18:37:52 <byorgey> roconnor: thanks!
18:42:12 <Sgeo> :t liftM2 (,)
18:42:13 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
18:42:21 <Sgeo> :t mzip
18:42:21 <lambdabot> Not in scope: `mzip'
18:42:27 <Sgeo> @hoogle mzip
18:42:27 <lambdabot> No results found
18:42:47 <Sgeo> ...
18:43:02 <Axman6> what nmakes you think it should already exist?
18:43:23 <Sgeo> This article that was in the Monad.Reader that I'm reading
18:43:34 <Sgeo> About monad comprehensions
18:43:59 <Sgeo> Although the type is different, mzip :: (MonadZip m) => m a -> m b -> m (a,b)
18:44:38 <Sgeo> liftM2 (,) [1,2,3] [4,5,6]
18:44:40 <Sgeo> > liftM2 (,) [1,2,3] [4,5,6]
18:44:41 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
18:44:48 <Sgeo> Yeah, mzip would do something different
18:45:03 <pchiusano> copumpkin: man that implicit params trick is pretty sweet for getting the expected type of different subexpressions
18:50:44 <irene-knapp> finicky problem here
18:51:33 <irene-knapp> I want to have a data type Serialization context a, and a monad subclass Monad (m context) => MonadSerial m, right?
18:51:58 <irene-knapp> in other words, I do NOT want the context type to be a parameter of the MonadSerial instance
18:52:07 <irene-knapp> but I DO want it to be a parameter of the actual datatype
18:52:13 <irene-knapp> I'm not sure this is even sensible
18:52:19 <irene-knapp> but let me ramble on a bit about why I want it, hm?
18:53:02 <irene-knapp> so, this monad is to be basically like ReaderT IO, you see
18:53:11 <irene-knapp> (well, actually it's substantially more complicated than that, or I'd just use mtl!)
18:53:15 <irene-knapp> (but in this aspect)
18:54:01 <irene-knapp> the wrinkle is that I want there to be an operation withContext :: MonadSerial m => context -> m a -> m a, which runs the inner computation with a different context value
18:54:31 <irene-knapp> I guess that isn't sensible really, because the type of the inner computation HAS to include context or, even if it could be accessed, it would only be as an existential with nothing known about it, and therefore useless
18:55:14 <irene-knapp> wait, no, I wrote that wrong
18:55:31 <irene-knapp> I can still have withContext :: MonadSerial m => context' -> m context' a -> m context a
18:55:33 <irene-knapp> in principle
18:56:42 <irene-knapp> so I think what I'm trying to do makes some sort of sense?
18:57:33 <irene-knapp> except I can't, like, write the definition of MonadSerial, because ? hmm ?
18:57:40 <irene-knapp> I guess because, fundamentally, m isn't a monad - only m context is
18:58:05 <irene-knapp> what I wanted to assert in MonadSerial was that m context was a monad /for some context/
18:58:09 <irene-knapp> but I don't think I can do that
18:58:30 <irene-knapp> so maybe I need to not assert there that it's a monad, and move the assertion that m context is a monad to the client code?
18:58:33 <irene-knapp> let's see if that's possible...
19:02:54 <cl1> does haskell have anything coresponding to attributres?
19:02:58 <cl1> like in c#
19:03:10 <ddarius> No.
19:03:23 <irene-knapp> what are those?  (I believe ddarius, but I'm curious)
19:03:48 <ddarius> irene-knapp: If you know (relatively modern) Java, they are essentially the same thing as Annotations in Java.
19:03:55 <irene-knapp> I do not :)
19:04:18 <ddarius> Generically, they are metadata attached to source code objects that is queryable at run-time (and compile-time.)
19:04:22 <irene-knapp> hmmmm okay
19:04:29 <irene-knapp> that's cute
19:04:40 <cl1> http://msdn.microsoft.com/en-us/library/z0w1kczw(v=VS.100).aspx
19:04:51 <cl1> does haskell have reflection?
19:04:55 <irene-knapp> no
19:05:16 <roconnor> irene-knapp: what about the stupid typeable and friends?
19:05:20 <cl1> generally you use reflection to get the attributes off of your properties and perform some operations based on them
19:05:24 <irene-knapp> oh, yeah, we do, I guess
19:05:43 <irene-knapp> but the whole idea of reflection is kinda useful only with dynamic typing
19:05:47 <irene-knapp> I mean, we have Data.Dynamic, certainly
19:06:14 <irene-knapp> if you know your types statically, you also know everything about them statically, so it's not really useful to query them at runtime
19:06:29 <ddarius> cl1: Reflection at that level is not particularly challenging.  It's basically just the compiler providing you with some information you could have manually and explicitly provided.
19:08:32 <cl1> ddarius .. we have attributes that you apply to classes that are mvc view model classes. Those attributes are smart enough to know how to save the data to mongo when an mvc controller is done.
19:09:00 <cl1> there is nothing that a user has to do if they want their data saved other than placing an attribute on the property to be saved
19:09:03 <cl1> they can do alot
19:09:12 <irene-knapp> mm
19:09:28 <irene-knapp> I mean, we can do analogous things with Data.Data and whatever
19:09:49 <irene-knapp> ddarius isn't saying that attributes aren't useful; he's saying that they aren't difficult to implement yourself in a Haskell-like system
19:10:12 <irene-knapp> or that's my understanding
19:10:20 <ddarius> cl1: The code that understands those attributes (which may be in the attribute class itself) is smart, but the actual annotating and reading the annotations is just some data automatically generated by the compiler and made available through a standard interface.
19:10:29 <nus> cl1, the interesting question is, how big you want your RTL?
19:10:41 <cl1> rtl?
19:10:46 <irene-knapp> runtime library
19:11:28 <cl1> i've not had an issue with RTLs taking up too much memory. the stuff they operate on is usually of more concern
19:13:04 <cl1> but, y'all are saying that the same things can be accomplished in haskell relativly easy?
19:13:16 <irene-knapp> you do kinda have to know more about what you're doing to do it in Haskell, I'll grant that
19:13:21 <irene-knapp> but yes, that's my position
19:13:41 <ddarius> cl1: At the technical level, more or less, yes.  The real value in these approaches, though, is the standarization and automation.
19:14:10 <irene-knapp> so yes, it is a nice thing that C# has that built-in
19:14:41 <ddarius> It would certainly be valuable for Haskell to provide something vaguely akin to C#'s attributes, though there would be some rather significant differences.
19:14:46 <cl1> when I get to know haskell better, i can then ask more specific questions to see how to replace the functionality from c#
19:14:50 <irene-knapp> yes, indeed
19:14:56 <irene-knapp> (to both)
19:15:11 <cl1> ddarius, i would think that in order to get benefit from the attributes you would also need reflection
19:15:47 <irene-knapp> well, the attribute and reflection could be viewed as a way of kludging around the fact that you don't have typeclasses :)
19:15:47 <cl1> but then again you have the whole typeclass thing going for you, and that might be able to provide the exact same thing
19:15:53 <irene-knapp> what you really need is? yes
19:16:14 <ddarius> cl1: Again, at this level, all that "reflection" is is the API to this compiler-generated data.  The deeper reflection that C# does provide, is not something that you could easily add to Haskell.  In some ways it goes very much against the grain of Haskell.
19:16:24 <irene-knapp> just a way for the type to specify what fields of it are serialized (or, indeed, what information from it, since you don't always want to serialize the type "literally", in the case of structures that work better in memory than they do on disk!)
19:16:55 <irene-knapp> (I'm thinking of hash tables, for example)
19:17:07 <irene-knapp> (although, of course, we don't really use hashes in Haskell, so.)
19:17:19 <cl1> i'm soooooo interested in seeing how haskell can solve some of the things we do in c#
19:17:23 <irene-knapp> hehe, yes
19:17:40 <ddarius> cl1: You should take a problem-oriented approach to it though, not a solution-oriented approach.
19:18:00 <Axman6> cl1: so are MS, that's why they keep adding things from Haskell to the language :P
19:18:32 <cl1> ddarius, i do, its just my problem solving approach has been with c# for the past decade
19:18:53 <Sgeo> cl1, LINQ is inspired by HaskellDB, a Haskell library
19:19:08 <shachaf> C# has been around for a decade. :-(
19:19:19 <cl1> i plan to use haskell to the best of is capabilities, I just have concepts from c# that I have not learned a better way in haskell yet
19:19:25 <Axman6> shachaf: kinda makes you feel old eh...
19:19:30 <cl1> remember I didn't get monads the first time around
19:19:41 <Axman6> cl1: no one does
19:19:54 <cl1> i'm starting over with realworldhaskell, and now that I understand parametric polymorphism, the monads shouldn't be a problem
19:20:01 <Axman6> because what there is to "get" is not what people are looking for when they want to "get monads"
19:20:39 <ddarius> cl1: Again, that's taking a solution-oriented approach.  Don't think "I know how to solve problem X with Y in C#, so I need to learn how to do Y in Haskell" but just think "how do I solve X in Haskell?"
19:20:49 <Axman6> i think a lot of people struggle with the idea that monads aren't 'a thing', they're something you can implement with many different things.
19:21:07 <cl1> Axman6, had i understood parametric polymorphism, i wouldn't have had problems with learning monads. I think that is the big disconnect
19:21:29 * shachaf still dislikes the phrase "learning monads".
19:21:44 <Axman6> cl1: even people who do understand it struggle with "learning monads" though
19:22:18 <ddarius> Not understanding parametric polymorphism strongly suggests not understanding the type system.  Not understanding the type system is a huge barrier to learning almost any concept in Haskell or programming effectively in Haskell.
19:22:41 <Axman6> couldn't agree more
19:22:52 <ddarius> It's much, much, much more important and valuable to get a good grasp of the type system than it is to "learn monads."
19:23:03 <cl1> well i have to go back and remember all the stuff i forgot while reading lyah because I didn't have any exercises to help me remember what i read. i'm sure i'll rip through functors and monads and all that this time around
19:23:15 <Sgeo> Learning how to use monads is probably a good idea though.
19:23:22 <nus> ddarius, hear hear
19:23:22 <Sgeo> Although type system > *
19:23:53 <Axman6> shachaf: yeah, my advice these days is, go and learn how to use a few monads first, then you can learn what monads are.
19:23:58 <Axman6> uh, Sgeo even
19:24:03 * Axman6 really must stop doing that
19:24:08 <nus> hmm, is there "a gentle introduction to types" or something?
19:24:43 <roconnor> I learned monads when I saw how it could make all my my case Nothing -> Nothing code go away.
19:24:51 * Sgeo only recently got the idea that having a function that only processes, say, MyMonad MyType can actually be useful
19:24:51 <Sgeo> Thanks to HaskellDB
19:24:55 <Sgeo> >.>
19:25:07 <MiggyX> Hi guys, this is kinda a follow up from something I was stuck on yesterday, but I've posted full example code and was wondering if anyone would help with my sanity and take a quick look at http://stackoverflow.com/questions/8587407/can-parse-json-using-the-json-package-in-ghci-but-not-when-compiled-with-ghc
19:25:08 <shachaf> Sgeo: What?
19:25:21 <Sgeo> Also, <$> and <*> make it convenient to use non-monadic functions as though they accepted monadic arguments
19:27:09 <Axman6> MiggyX: but putStrLn can only print Strings, and I assume the result, as you've shown in the first code snippet, is not something that gives a String
19:27:48 <Axman6> MiggyX: what happens when you use JS.Ok value -> print (value :: JSValue)?
19:29:18 * Axman6 has just realised that MiggyX /= MissPiggyX, as he's been saying it to himself in his head
19:30:38 <cl1> i'm going to explain monads and you tell me if i have the concept down ..
19:30:44 <irene-knapp> that's how I've been reading it too haha
19:30:44 <cl1> monads are like burritos
19:30:48 <cl1> :D
19:30:56 <Axman6> cl1: only sometimes
19:31:00 <irene-knapp> yes - monads are like burritos in that I want one now
19:31:10 <ben> if monads are like burritos, what is kind polymorphism like?
19:31:11 <Axman6> some onads have no filling, so they're just tortillas
19:31:16 <cl1> seriously, a monad contains data that you can't get to that alters the functionality of your program in some way
19:31:20 <Axman6> m*
19:31:22 <MiggyX> Axman6: that works! Oh thank god‚Ä¶.. lol
19:31:23 <irene-knapp> kind polymorphism is like quiche in that it seems nice but I don't really understand it
19:31:35 <Axman6> cl1: ...no
19:31:53 <Axman6> lists are monads, and you can get to all their data
19:32:28 <cl1> but you can't get to how the list stores the data, you can only call functions on the list to get the data out because the list provides them
19:32:52 <MiggyX> Axman6: do you have a stack overflow account?
19:34:33 <Axman6> MiggyX: i do, and I've not put the answer on there
19:34:36 <Axman6> now*
19:35:08 <cl1> can pure functions in a mabey monad not be executed if nothing is returned earlier on?
19:35:24 <Axman6> what do you mean? all functions are pure...
19:35:52 <Axman6> cl1: what the Maybe monads lets you do is fail early. if one computation in the chain fails, the computations fails immediately
19:35:54 <monochrom> depends on actual code
19:36:20 <cl1> i mean if i have do foo1; foo2; foo3; and foo2 returns nothing, then foo3 doesn't get called. is that correct or incorrect?
19:36:31 <monochrom> correct
19:36:32 <MiggyX> Axman6: accepted and up voted :)
19:37:26 <cl1> in that case "the rest" doesn't get called by the monad, the continuation passing stops there?
19:37:34 <monochrom> see how one clear example of a dozen characters can be saved by vague natural language of three dozen characters
19:38:01 <monochrom> the Maybe monad does not do continuation passing at all.
19:38:31 <cl1> then wtf does bind do?
19:38:50 <monochrom> it pattern-matches on Just and Nothing
19:39:02 <cl1> and if Just?
19:39:34 <monochrom> like this: (>>=) (Just x) f = f x
19:40:18 <cl1> it calls the function f. I thought that was coninuation passing
19:40:22 <monochrom> that is, if Just, foo3 is called, if we're looking at the "foo2; foo3" part
19:40:42 <cl1> and if nothing then foo3 isn't called
19:40:52 <monochrom> if you say that, then "sin 0" is also continuation-passing.
19:41:42 <ddarius> foo2 would not "return" Nothing it would be Nothing.  (Or if foo2 "returned" Nothing in the appropriate sense, foo3 would get executed.)
19:42:08 <cl1> right
19:42:43 <cl1> but the maybe monad will take that value and not unwrap it and pass it on to the next function in the do statement. it just exits the do statement and returns Nothing
19:43:14 <cl1> if it were Just 4 it would pass 4 onto foo3
19:43:45 <cl1> okay, my example was missing parameters and return values, so foo3 would just be called
19:43:48 <ddarius> No, (>>=) would pass 4 to const foo3.
19:44:29 <cl1> so how is that not continuation passing?
19:44:31 <monochrom> depends on whether foo2 >>= foo3 or foo2 >>= \_ -> foo3
19:44:57 <monochrom> I am passing 4. is 4 a continuation?
19:45:24 <monochrom> perhaps in another case I pass the boolean True. is True a continuation?
19:45:29 <cl1> no, but bind calling foo3 is
19:45:38 <cl1> isn't it?
19:46:07 <cl1> foo3 is "the rest" when continuation passing?
19:46:30 <monochrom> if you say that foo3 is a continuation, and that I pass foo3 to >>=, sure.
19:46:45 <cl1> okay
19:47:39 <monochrom> but then the continuation-passing is not stopped at all. I pass the continuation foo3 to >>=. foo2 >>= foo3. there, I wrote it, it is passed. no one can stop me.
19:47:55 <cl1> lol
19:48:00 <cl1> okay you win
19:48:03 <Axman6> rarg, bloody internet
19:48:07 <monochrom> if foo2 becomes Nothing, that still cannot stop me.
19:48:37 <cl1> but bind's implementation in the maybe monad can decide not to call foo3
19:48:40 <Axman6> hmm, i reckon it's raining at home... i can hear thunder here... and rain usually means disconnections at home -_-
19:48:42 <monochrom> in fact, Nothing >>= foo3. there, even with Nothing, you can't stop me from passing foo3 to >>=.
19:48:50 <cl1> :( @ Axman6
19:49:01 <cl1> monochrom, you are unstoppable
19:49:06 <Axman6> @src Maybe (>>=)
19:49:06 <lambdabot> (Just x) >>= k      = k x
19:49:07 <lambdabot> Nothing  >>= _      = Nothing
19:49:09 <monochrom> sure, >>= decides not to call foo3. doesn't stop me from passing foo3 to >>=
19:49:27 <monochrom> "does not call" != "does not pass"
19:50:04 <cl1> what is "the rest" called that may or may not get executed in the Maybe monad?
19:50:24 <cl1> "the rest" being foo3 in my example
19:50:47 <Axman6> hooray! moar SO reputation. thanks MiggyX =)
19:51:00 <cl1> in some other Mabye monad "the rest" would be the rest of the functions in the monad that didn't get called
19:51:04 <ddarius> Axman6: Keep it up and you might just win.
19:51:15 <Axman6> yeah!
19:51:16 <cl1> win what?
19:51:20 <MiggyX> Axman6: Now that you point it out, it's obvious but bloody hell the time I spent looking at that code lol
19:51:22 <monochrom> you can continue to call it a continuation. I see no problem.
19:51:47 <Axman6> i think this is my first time someone's marked one of my answers as being the answer to their problem...
19:51:55 <monochrom> what makes you think that if you say that something is a continuation, then someone else must use it?
19:53:29 * hackagebot http-proxy 0.0.1 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.1 (ErikDeCastroLopo)
19:53:31 <cl1> monochrom, i don't, i understand the concept, but apparently my ability to properly refer to items in it is quite lacking
19:53:53 <cl1> i thought the continuation was the rest of the code to be executed
19:54:21 <m3ga> was waiting for that :-)
19:55:35 <Axman6> m3ga: looks cool =)
19:55:36 <monochrom> I know an application in which you pass two continuations to a combinator, and the purpose of the combinator is to choose at most one of the two to run; the unchosen one is subsequently forgotten.
19:56:03 <m3ga> thank Axman6. head nearly exploded getting it working though.
19:56:19 <Axman6> heh, how come? iteraree madness?
19:57:02 <Axman6> m3ga: also, line 20 of Network.Proxy: runds -> runs
19:57:15 <m3ga> i liked iteratees so much i had to put an iteratee inside an iteratee (well enumerator actually)
19:57:16 <Axman6> jesus, that's a hell of a lot of imports...
19:57:16 <cl1> monochrom, that actually made sense
19:57:35 <m3ga> Axman6: thanks
19:58:56 <monochrom> one such combinator actually does a little bit of I/O, reading stuff from a file, and based on what is read, decides which of the two continuations to drop.
20:00:10 <cl1> monochrom, how do they both get passed to it?
20:00:23 <monochrom> now, if the file happens to be /dev/microphone or something and the hardware wires of it are left floating and there are some diodes to make quantum noise... you may joke about some Schr√∂dinger's continuation
20:00:53 <monochrom> like "foo2 <|> foo3" if the combinator is named "<|>"
20:01:35 <cl1> and foo2 and foo3 are both of the same type? like IO String or something?
20:01:57 <cl1> err, they both take the same type
20:02:03 <monochrom> like Char -> Blah
20:02:33 <cl1> @type (>>=)
20:02:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:02:54 <cl1> where Blah is the monad
20:03:01 <Axman6> m3ga: heh, firstSuccessful looks like a fun function
20:03:45 <m3ga> Axman6: yeah, thats from Warp
20:04:04 <m3ga> Axman6: check out enumIteratee
20:04:28 <Axman6> yeah i saw that... looks... interesting...
20:05:05 <cl1> monochrom: so either foo2 or foo3 will get called and return a Blah which is then unwrapped by the next bind call and passed to the next line in the do statement, if that's what the currently executing monad decides to do
20:05:05 <Axman6> what's it used for?
20:05:12 <cl1> is that correct?
20:05:24 <monochrom> yes
20:05:35 <cl1> see i told you i get them :P
20:05:45 <m3ga> Axman6: it generates an Enumerator that pulls data from an Iteratee
20:05:52 <ksf> monoid syntax, anyone?
20:05:52 <Axman6> cl1: talking about unwrapping isn't a great idea... (at least i got told off when i talk about unwrapping values from monadic values)
20:05:53 <sedillard> hi I'm trying to get up an running with the latest ghc and cabal-install. I installed ghc-7.2.2 and cabal-install 0.10.2 (from the first google hit for cabal-install) and ./bootstrap.sh gives me this: Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
20:06:02 <cl1> i know its not a burrito
20:06:03 <ksf> too many bogous monads around.
20:06:18 <ksf> bougous, even.
20:06:19 <Axman6> sedillard: see the topic
20:06:20 <monochrom> there is no burrito or flying teapot monster
20:06:36 <cl1> lol @ flying teapot monster
20:06:37 <sedillard> the topic?
20:06:43 <monochrom> but spaghetti bologna is ok
20:06:43 <Axman6> sedillard: /topic
20:06:52 <ksf> if not bouhgouse
20:06:58 <sedillard> oh right. thanks
20:07:23 <mgsloan> the oppressive bourgeois monad
20:07:31 * monochrom will use "flying burrito monster" next time
20:07:32 <cl1> Axman6, well wtf am i supposed to call getting the value that is passed along?
20:07:39 <sedillard> wait, no. that's not it. I don't want the platform. I want ghc-7.2. In fact I really want 7.4 but 7.2 will do
20:07:48 <Axman6> m3ga: planning on splitting it into smaller, more manageable modules?
20:08:08 <cl1> hmm
20:08:15 <cl1> i guess you don't "get the value" it just exists in the monad
20:08:26 <jessopher> 'decoding'
20:08:30 <jessopher> idk
20:08:36 <cl1> you just pass it along, if that's what you want to do, being the badass monad that you are
20:08:38 <cl1> correct?
20:08:40 <Axman6> cl1: well, there are plenty of monads where there is no actual value passed along, for example: data NullMonad a = Null; instance Monad NullMonad where return = Null; (>>=) _ _ = Null
20:08:41 <ksf> actually, no. the monad is the algebraic structure, not the values associated with it.
20:08:42 <m3ga> Axman6: yeah, probably. its still experimental and i'm figuring out how to put it together.
20:08:58 <ksf> you might say "pass a value inside a monad"
20:09:26 <ddarius> Where "plenty" = 1 up to isomorphism.
20:09:41 <ddarius> Maybe 2.
20:09:48 <ksf> just passing stuff along is boring, though. applicatives can do that, too. the fun starts when you start to influence the future of the computation based on the passed value.
20:10:05 <cl1> ksf, indeed
20:10:06 <Axman6> ddarius: well, in the list monad, there's not 'a' value, there's many. and i'm not even sure how the cont monad comes into this...
20:10:12 <cl1> my mind is expanding as we speak
20:10:52 <cl1> but i first must get a better handle on some other basics before using my new super powers
20:11:25 <Sgeo> @help
20:11:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:11:28 <Sgeo> @list
20:11:28 * ksf wants 7.4, too.
20:11:28 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:11:46 <Sgeo> Is there a nice way to bring lambdabot into a channel?
20:11:54 <cl1> for example point-free notation and the ($) operator still screw with me becuase i have not had to pay so close attention to operator associativity before
20:12:09 <ksf> Sgeo, if you could, you knew.
20:12:36 <cl1> Axman6, i upvoted ur answer on SO
20:12:48 <Axman6> heh, thanks
20:13:42 <ksf> $ binds *very*, *very* loosely.
20:13:54 <ksf> in general, operator precedence is easier in haskell than in c.
20:14:21 <ksf> first because there's only 10, not 50 or something levels, and then because ghc will mostly complain if you got the precedence wrong.
20:15:19 <ksf> 18 levels.
20:15:24 <sedillard> the cabal-install package on hackage has a bootstrap.sh, but it appears to be broken with the latest stable (7.2.2?) version of ghc. Anyone know anything about this?
20:15:42 <ksf> 16 without c-only stuff.
20:16:03 <ksf> sedillard, build it with an old version.
20:16:47 * jessopher thinks the usefulness of applicatives and monads programatically are easier to digest if you learn them in terms of idris's do and idom syntax
20:17:25 <jessopher> idiom*
20:17:33 * ddarius thinks the usefulness is easier to digest if you can parse the language you are using the understand them.
20:17:59 <cl1> ddarius, i agree
20:18:13 <jessopher> i agree too
20:18:18 <monochrom> sedillard: 2nd in the topic, "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)"
20:18:48 <Sgeo> :t pi
20:18:49 <lambdabot> forall a. (Floating a) => a
20:19:04 <cl1> hmm floating pie
20:21:25 <byorgey> pi in the sky
20:21:43 <byorgey> preflex: seen djahandarie
20:21:44 <preflex>  djahandarie was last seen on #haskell 1 day, 4 hours, 19 minutes and 47 seconds ago, saying: I think everyone is uncrazy now though.
20:22:45 <byorgey> @ask djahandarie ever thought about adding functions  under2 and over2  to newtype?
20:22:45 <lambdabot> Consider it noted.
20:25:50 <jessopher> actually, i think i am going to have to backtrack on that a little, i don't think its easier to learn them in a language you can already parse, if their expression in that language is unnatural. I would have never been able to undestand the usefulness of monads in some language like ruby, even though when i first started looking into them, i could parse ruby much more readily than haskell
20:28:17 <cl1> what is a kind * -> * that would be a monad that is not a container? something i would grok without knowing haskell. the Maybe monad is a container, even though it has its additional functionallity
20:28:45 <ddarius> jessopher: If you can't understand what you are reading, it doesn't matter how "natural" the expression of the idea is.
20:29:48 <cl1> a logging monad?
20:29:55 <Axman6> cl1: there's the ((->) a) monad
20:30:29 <sedillard> ghc-7.2 doesn't seem to come with an uninstall make target. Anyone know how to uninstall it cleanly?
20:30:31 <Axman6> > do { x <- (*2); y <- (^3); return x+y} 7
20:30:32 <lambdabot>   <no location info>: parse error on input `7'
20:30:38 <Axman6> > (do { x <- (*2); y <- (^3); return x+y}) 7
20:30:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
20:30:47 <Axman6> hmm
20:30:55 <Axman6> > (do { x <- (*2); y <- (^3); return (x+y)}) 7
20:30:56 <lambdabot>   357
20:31:00 <Axman6> there we go
20:32:42 <cl1> interesting
20:34:29 <cl1> i can't say i know how to explain that
20:34:47 <ddarius> Axman6: That could be viewed as a potentially infinite Map.  More particularly, if a were Bool, this would be the same thing as a monad on data Dup a = Dup a a.
20:35:05 <jessopher> ddarius: i understand what you are saying, but on the otherhand, the work required to understand the 'unnatural' expression in one language, might be less than that of just learning the language in which its expression is 'natural'. If we aren't even considering the possibility of someone having the capacity to learn another language, they don't have a very bright future learning abstract mathematical concepts anyhow
20:35:06 <cl1> 7 gets passed to (*2) and then it gets passed to (^3) and return takes both those values and adds them
20:35:22 <ddarius> State, though, does not seem at all like a container to me.
20:35:42 <Axman6> yeah, state is a better example than my reader monad...
20:35:47 <cl1> so would i do let foo = (do { x <- (*2); y <- (^3); return (x+y)}) 7
20:36:17 <ddarius> jessopher: Yes, but you do have to do that "learning the language" -before- you go on to attempting to understand ideas expressed in the language.
20:37:11 <jessopher> well, the subset of the language that is relevant in any case. I dont understand dependently typed languages in any deep sense, but i do understand certain expressions in those languages
20:37:43 <parcs``> @src (->) Monad
20:37:44 <lambdabot> Source not found. Are you on drugs?
20:37:48 <parcs``> @src Monad (->)
20:37:49 <lambdabot> Source not found. That's something I cannot allow to happen.
20:38:12 <cl1> :t do { x <- (*2); y <- (^3); return (x+y)}
20:38:13 <lambdabot> forall a. (Num a) => a -> a
20:38:28 <cl1> it did not report like ghci
20:38:47 <parcs``> cl1, import Control.Monad.Instances
20:38:49 <cl1> (Num b, Monad ((->) b)) =>  b -> b
20:40:02 <cl1> parcs``, in lambdabot? how would i do that?
20:40:17 <Axman6> in ghci
20:40:25 <Axman6> lambdabot already has it impoerted
20:40:28 <Axman6> imported*
20:41:06 <cl1> why did mine list that way without the import?
20:41:55 <Axman6> because the instance for Monad ((->) e) isn'ty defined in the prelude
20:43:03 <parcs``> @src Maybe Monad
20:43:03 <lambdabot> Source not found. It can only be attributed to human error.
20:43:19 <parcs``> @src Monad Maybe
20:43:19 <lambdabot> Source not found. You type like i drive.
20:43:29 <parcs``> didn't this work previously?
20:43:34 <rwbarton> @src return Maybe
20:43:34 <lambdabot> Source not found. You type like i drive.
20:43:37 <Axman6> no, only for the functions:
20:43:38 <rwbarton> @src Maybe return
20:43:39 <lambdabot> return              = Just
20:43:43 <Axman6> @src Maube (>>=)
20:43:43 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:43:48 <Axman6> @src Maybe (>>=)
20:43:48 <lambdabot> (Just x) >>= k      = k x
20:43:48 <lambdabot> Nothing  >>= _      = Nothing
20:43:53 <parcs``> oh
20:44:07 <parcs``> @src (->) return
20:44:07 <lambdabot> return = const
20:44:12 <parcs``> @src (->) (>>=)
20:44:13 <lambdabot> f >>= k = \ r -> k (f r) r
20:46:42 <xil> hi. What is a legal way to do something like "myDataObject {field1 = value1, ...} {fielda = valuea, ...}"? Can I just do it right like that or do I need brackets or something?
20:47:10 <parcs``> you want to update the record twice?
20:47:11 <Axman6> get rid of the middle brackets, and use a comma
20:47:18 <xil> I need to update it twice
20:47:41 <Axman6> myData {field1 = value1, field2=value2,...}
20:47:43 <xil> technically the first update is general stuff, and the second update will be buffered by an if-then-else to determine what fields to update
20:48:26 <parcs``> > Node { rootLabel = True } { rootLabel = False }
20:48:27 <lambdabot>   Node {rootLabel = False, subForest = *Exception: <interactive>:3:0-24: Miss...
20:48:37 <parcs``> it works how you have it
20:49:17 <parcs``> i wonder why you didn't test it yourself before asking
20:49:21 <xil> thanks =]. Out of ignorance for how to put together an example like that, it was faster to ask here than try myself
20:50:16 <xil> my code is no where near compilable, and I couldn't extract just what I need easily enough. And don't know Haskell well enough quite yet to do what you just did as fast as you did it
20:50:30 <byorgey> xil: fair enough, no worries =)
20:50:44 <parcs``> yeah, i feel like an ass now for inquiring
20:50:58 <xil> would have probably taken me half an hour to figure that out. But I try real hard to learn from when y'all do stuff like that =]
20:51:22 <xil> oh no worries. It's a legit question
20:51:34 <xil> people in other channels would be downright rude about it
20:51:46 <xil> I love this channel because you're all so nice =]
20:52:15 <shachaf> xil: It's a confusing thing that record-creation syntax looks just like record-update syntax.
20:52:18 <shachaf> But they're distinct.
20:52:21 <shachaf> For example:
20:52:29 <shachaf> > Node {rootLabel = True}
20:52:30 <lambdabot>   Node {rootLabel = True, subForest = *Exception: <interactive>:3:0-22: Missi...
20:52:32 <shachaf> > (Node) {rootLabel = True}
20:52:33 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
20:52:33 <lambdabot>         against inferred ty...
20:52:40 <Sgeo> Is HJScript a good example to follow for making my own thing that will output code?
20:53:01 <parcs``> xil, :)
20:54:56 <xil> shachaf: yeah, well the particular reason I wasn't sure about the double update is because I'm doing this on multiple lines and wanted to make sure brackets weren't necessary or something like that
20:55:41 <shachaf> xil: That's not a double update.
20:55:51 <shachaf> parcs``'s example isn't, anyway.
20:55:57 * shachaf reads more context.
20:56:07 <shachaf> > (Node {rootLabel="a"})
20:56:08 <lambdabot>   Node {rootLabel = "a", subForest = *Exception: <interactive>:3:1-20: Missin...
20:56:11 <shachaf> > (Node {rootLabel="a"}) {rootLabel="b"}
20:56:12 <lambdabot>   Node {rootLabel = "b", subForest = *Exception: <interactive>:3:1-20: Missin...
20:56:16 <shachaf> > (Node {rootLabel="a"}) {rootLabel="b"} {rootLabel="c"}
20:56:17 <lambdabot>   Node {rootLabel = "c", subForest = *Exception: <interactive>:3:1-20: Missin...
20:56:21 <shachaf> *That's* a double update.
20:56:31 <shachaf> And, yes, it's also allowed. :-)
20:56:42 <xil> wait....which one's the double update?
20:56:50 <Axman6> yeah...
20:57:46 <parcs``> > (Node True []) { rootLabel = True }
20:57:47 <lambdabot>   Node {rootLabel = True, subForest = []}
20:58:24 <jessopher> @type (Node _ _)
20:58:24 <lambdabot> Pattern syntax in expression context: _
20:58:25 <lambdabot> Pattern syntax in expression context: _
20:58:31 <jessopher> oh duh
20:59:51 <parcs``> the last one is a double update
21:00:02 <xil> why isn't the one before it a double update?
21:00:05 <xil> oh got it
21:00:21 <parcs``> the one before it constructs a record then updates it
21:00:21 <xil> first one creates it. Second updates. Third updates a second time
21:00:24 <parcs``> as does my update
21:00:29 <parcs``> example*
21:00:31 <parcs``> yep
21:00:50 <parcs``> > Node { rootLabel = True } { rootLabel = True } { rootLabel = False }
21:00:50 <lambdabot>   Node {rootLabel = False, subForest = *Exception: <interactive>:3:0-24: Miss...
21:01:20 <karoyakani> @pl \xs -> map sum $ transpose xs
21:01:20 <lambdabot> map sum . transpose
21:03:05 <parcs``> > Node {} { rootLabel = True } { rootLabel = False }
21:03:06 <lambdabot>   Node {rootLabel = False, subForest = *Exception: <interactive>:3:0-6: Missi...
21:03:17 <parcs``> > Node {} {}
21:03:18 <lambdabot>   <no location info>: Empty record update
21:03:57 <byorgey> I seem to recall a package for "inlining" Template Haskell -- i.e. pasting TH-generated code directly into a module, so you don't need the TH dependency anymore
21:04:16 <byorgey> anyone know what it's called?  I can't seem to find it
21:05:06 <byorgey> ah, found it, it's zeroth
21:06:04 <karoyakani> @unpl map sum . transpose
21:06:04 <lambdabot> (\ c -> map sum (transpose c))
21:06:55 <xil> okay so I wrote up an example to illustrate exactly what I'm doing. Is this legal? The important bit is in the "doubleUpdate" function
21:06:59 <hpaste> xil pasted ‚Äúdouble update‚Äù at http://hpaste.org/55577
21:07:21 <cl1> > (*) >>= (\f x -> f x) $ 7
21:07:22 <lambdabot>   49
21:07:24 <parcs``> :t let node = Node { rootLabel =  putStrLn "hello" } in (node, node { rootLabel = return () })
21:07:25 <lambdabot> (Tree (IO ()), Tree (IO ()))
21:07:28 <cl1> > (*) >>= (\f x -> f x) $ 7.0
21:07:29 <lambdabot>   49.0
21:08:09 <shachaf> cl1: (\f x -> f x) === id
21:09:01 <parcs``> :t let node = Node { rootLabel =  return () } in (node, node { rootLabel = return () })
21:09:02 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => (Tree (m ()), Tree (m1 ()))
21:09:16 <cl1> > (*) >>= id $ 7
21:09:17 <lambdabot>   49
21:09:19 <jessopher> :t {foo = 1}
21:09:20 <lambdabot> parse error on input `{'
21:09:28 <jessopher> ^^ record updates arent expressions
21:09:40 <Axman6> cl1: it seems you've discovered one of the interesting monad laws
21:09:51 <Axman6> join x = x >>= id
21:10:02 <shachaf> THat's not a monad law.
21:10:05 <shachaf> It's a definition.
21:10:23 <cl1> > pure >>= id $ 7
21:10:23 <lambdabot>   7
21:10:40 <Axman6> i thought you had to satisify that for it to be a monad...
21:10:49 <shachaf> Axman6: It's the definition of join.
21:11:00 <Axman6> fucken, why does this shit seem to change every week, depending on who you talk to
21:11:01 <shachaf> join x = x >>= id is in Control.Monad
21:11:08 <Axman6> sure...
21:11:21 <hpaste> parcs annotated ‚Äúdouble update‚Äù with ‚Äúdouble update (annotation)‚Äù at http://hpaste.org/55577#a55578
21:11:24 <Axman6> but, it says something about how join and/or >>= have to be defined
21:11:51 <shachaf> Axman6: There are several ways of defining Monad. Two popular ones are return,(>>=) and join,fmap,return
21:11:58 <rwbarton> if you think of both >>= and join as being part of the structure of a monad, then that is a law which they must satisfy
21:12:01 <cl1> > id >>= pure $ 7
21:12:01 <lambdabot>   7
21:12:02 <Axman6> i'm well aware of this shachaf
21:12:25 <shachaf> Axman6: Right, so you just give one in terms of the other.
21:12:47 <xil> parcs``: aha. That I can see will work. Thank you very much =]
21:12:47 <Axman6> -_-
21:12:50 <Axman6> forget it
21:13:00 <karoyakani> @help
21:13:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:13:09 <gienah> byorgey: zeroth
21:13:16 <karoyakani> @list
21:13:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:13:18 <byorgey> gienah: thanks
21:13:34 <shachaf> Yes, I suppose that if you had both, then that would be a law. It's also a law that liftM2 f m n = m >>= (\x -> n >>= (\y -> return (f x y)))
21:13:40 <shachaf> In that sense.
21:13:56 <gienah> byorgey: I think it needs work to convince it to compile
21:13:58 <Axman6> @src Monad
21:13:58 <lambdabot> class  Monad m  where
21:13:58 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
21:13:58 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
21:13:58 <lambdabot>     return      :: a -> m a
21:13:58 <lambdabot>     fail        :: String -> m a
21:14:26 <hpaste> parcs annotated ‚Äúdouble update‚Äù with ‚Äúdouble update (annotation) (annotation)‚Äù at http://hpaste.org/55577#a55579
21:14:37 <byorgey> gienah: I am just discovering that now.  more work than I am willing to put into it.
21:15:23 <karoyakani> quit
21:15:33 <jessopher> no, you quit
21:16:56 <hpaste> p annotated ‚Äúdouble update‚Äù with ‚Äúdouble update (annotation) (annotation)‚Äù at http://hpaste.org/55577#a55580
21:18:05 <parcs``> xil, the first annotation won't work due to layout rules i don't understand. the subsequent two annotations should work, however
21:18:51 <xil> parcs``: thank you =]. I think for my particular implementation that the let-in syntax will be more convenient. Nice to learn though =]
21:19:17 <xil> parcs``: oh wait. You said "first *annotation* won't work." I misread
21:19:49 <parcs``> yeah; the last annotation uses let though
21:20:01 <parcs``> anyone know why the first annotation fails to parse?
21:20:13 <xil> parcs``: oh wasn't getting the 3rd annotation. Got it now
21:21:11 <rwbarton> parcs``: the indentation of the block after "let" is determined by the position of "x" on that line
21:21:27 <cl1> @type pure 7 >>= (*)
21:21:28 <lambdabot> forall t. (Num t) => t -> t
21:21:46 <rwbarton> since the next line is less indented the layout rules produce "doubleUpdate ...... = let { x = input } { f1 = v1 + 1 } in ..."
21:21:47 <cl1> @tpure 7 >>= (*) $ 7
21:21:48 <lambdabot> Unknown command, try @list
21:21:52 <cl1> @t pure 7 >>= (*) $ 7
21:21:52 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:22:03 <cl1> @type pure 7 >>= (*) $ 7
21:22:04 <lambdabot> forall a. (Num a) => a
21:22:11 <cl1> > pure 7 >>= (*) $ 7
21:22:12 <lambdabot>   49
21:22:14 <hpaste> xil annotated ‚Äúdouble update‚Äù with ‚Äúdouble update (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/55577#a55581
21:22:20 <xil> will that work?
21:22:52 <cl1> so why does (*) >>= id $ 7 apply 7 to both sides of (*)?
21:23:02 <rwbarton> xil: no
21:23:44 <parcs``> xil, the curlies would have to be indented more than 5 spaces past the beginning of the let block
21:23:58 <ybit> i thought haskell was the scholar's programming language of choice?
21:24:00 <rwbarton> in "let x = ... in ..." everything between "let" and "in" needs to be at least as indented as "x"
21:24:13 <hpaste> aeaoe annotated ‚Äúdouble update‚Äù with ‚Äúdouble update (annotation) (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/55577#a55582
21:24:33 <ybit> there are only 369 hits for "haskell programming language" compared to 1720 for "r programming language"
21:24:41 <ybit> on google scholar
21:24:47 <parcs``> more than 4 spaces*
21:25:15 <cl1> > (*) >>= id $ 7
21:25:15 <lambdabot>   49
21:25:25 <parcs``> > join (*) 7
21:25:26 <lambdabot>   49
21:25:27 <xil> that explains a lot of problems I have in another program
21:25:43 <cl1> @type (*) >>= pure 7
21:25:43 <lambdabot> forall a b. (Num a, Num b) => a -> b
21:25:59 <cl1> (*) >>= pure 7 $ 7
21:25:59 <xil> I thought the indentation had to be farther than the beginning of the let
21:26:09 <cl1> > (*) >>= pure 7 $ 7
21:26:09 <lambdabot>   7
21:26:26 <xil> okay, I think I got this now. Thanks everyone that helped =]
21:27:59 <cl1> so: (*) >>= id $ 7; first applies 7 to (*) and then applies 7 to (*7)?
21:29:54 <parcs``> it applies 7 to (*) twice
21:30:25 <xil> um....wait so about this indentation. Is the rule that "if the following line is indented more than the first character of a non reserved word then it is treated as an extension of the current line."?
21:30:42 <parcs``> yep
21:30:43 <xil> not just for let statement, but for anything I want
21:30:58 <cl1> parcs``: id returns *7 or 7*7?
21:32:05 <cl1> or 7?
21:32:06 <parcs``> xil, no, it only applies to layout blocks, ie 'where' 'do' 'of' and 'let'
21:32:55 <xil> is there a way to safely break one very very long line into multiple, so I can, say, fit within an 80 column limit?
21:33:50 <JoeyA> xil: You can break a string: "Hello\
21:33:55 <JoeyA>        \world!"
21:34:18 <xil> I'm looking for more than strings =/
21:34:29 <JoeyA> oh
21:34:32 <dmwit> Just about any line can be broken.
21:34:36 <dmwit> You just do it.
21:34:46 <JoeyA> There are whitespace issues, though
21:34:58 <dmwit> Not many. Don't accidentally start a new line if you're in a block.
21:34:59 <dmwit> That's it.
21:35:29 <dmwit> where by "start a new line" I really mean "start a new line of the block" -- you can go ahead and put it on another line, just make the indentation different from the surrounding block.
21:35:46 <xil> but it can be different in any way I want
21:35:55 <xil> more or less indentation
21:36:02 <dmwit> Hm. It may have to be different by being more indented.
21:36:06 <dmwit> Let's test!
21:36:18 <cl1> @kind (->)
21:36:19 <lambdabot> ?? -> ? -> *
21:36:23 <hpaste> ‚ÄúJoey Adams‚Äù pasted ‚ÄúAbusing do layout for nicer if-then‚Äù at http://hpaste.org/55583
21:36:28 <cl1> wtf is ?? and ?
21:36:42 <dmwit> xil: Yes, it must be more indented.
21:37:05 <dmwit> cl1: They are superkinds of *, #
21:37:23 <cl1> superkinds?
21:37:25 <dmwit> cl1: You can read them simply as * most of the time.
21:37:31 <dmwit> cl1: Yes. You know about subtyping?
21:37:37 <dmwit> cl1: Well, there's subkinding, too. =)
21:37:43 <cl1> wow
21:37:50 <cl1> its turtles all the way up too!
21:38:22 <cl1> well i have to call it quits this evening
21:38:49 <dmwit> cl1: http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
21:38:57 <xil> dmwit: forgetting that you don't know what the named things in this example are, do you think this is probably legal?
21:39:09 <dmwit> cl1: grep for "subtyping" to see an explanation of all the kinds available in GHC
21:39:20 <JoeyA> What I pasted comes from the GHC source code, with details removed.  Although it "breaks the rules" (shadowed variables, nonconventional alignment), I like how it takes back some of the imperative feel.
21:39:22 <xil> dmwit: http://hpaste.org/55584
21:39:28 <parcs``> cl1, '(*) >>= id' expands to '\r -> id (r *) r' which simplifies to '\r -> r * r'
21:39:48 <dmwit> xil: Yes, I expect so.
21:40:04 <parcs``> in general, 'm >>= f' is defined as '\r -> f (m r) r'
21:40:10 <xil> dmwit: thanks =]. I'll go with it and when I'm ready to compile hopefully it'll work
21:40:21 <dmwit> xil: The only block in that snippet is the "let" block, so the indentation of the "in" clause can be even more relaxed than it is there.
21:40:54 <xil> dmwit: you mean that I don't need to put 'in' on a different line than what comes after it?
21:41:11 <dmwit> The location of the in and everything after it is immaterial, yes.
21:41:55 <xil> dmwit: I see. So 'in' isn't a block then? Is there a list of blocks?
21:42:08 <dmwit> The Report likely has a reference list somewhere.
21:42:26 <dmwit> let, where, do, and case
21:42:28 <dmwit> I think that's all.
21:42:42 <xil> ah okay. Thank you =]
21:43:32 <dmwit> "The layout (or 'off-side') rule takes effect whenever the open brace is omitted after the keyword where, let, do, or of."
21:43:35 <dmwit> xil: ^^
21:43:53 <dmwit> Section 2.7, http://www.haskell.org/onlinereport/lexemes.html
21:44:40 <dmwit> ("of" is only ever paired with "case", so I was mostly right)
21:45:06 <xil> so basically, if I include brackets, commas, and progressive indentation, then it doesn't matter how I indent?
21:45:35 <dmwit> If you include brackets and semicolons everywhere, then it doesn't matter how you indent at all. It need not even be progressive.
21:45:40 <dmwit> Or did I misunderstand your question?
21:45:57 <xil> dmwit: nope, you got it. I meant semicolons
21:48:44 <dmwit> The only wart (NB: in my opinion, of course) in the indentation rule is that it treats tabs as padding out to eight spaces.
21:49:12 <shachaf> dmwit: Whereas it should treat tabs as a #error pragma? :-)
21:49:24 <dmwit> Whereas it should treat tabs and spaces as incomparable.
21:49:42 <dmwit> No need to force your views on tabs onto other people.
21:49:54 <xil> sometimes I wish we didn't have tabs
21:50:05 <dmwit> whoops
21:50:13 <shachaf> Sorry, dmwit.
21:50:16 <dmwit> I shouldn't have mentioned this. Sorry. I won't feed this discussion any more.
21:50:19 * shachaf quiet
21:50:19 <xil> sometimes
21:50:29 <jessopher> hah
21:50:35 <shachaf> dmwit: (Anyway, I agree.)
21:53:22 <cl1> so f >>= m $ x takes x and applies it to f then applies f x and x to m
21:54:57 <dmwit> err... no?
21:55:08 <dmwit> Or maybe you just use the word "applies" backwards compared to me.
21:55:27 <dmwit> Okay, then yes.
21:55:43 <dmwit> But I think most people would say that it applies f to x, and then applies m to f x and x.
21:56:03 <The_Journey> how would I pattern match to get values of an Algebraic Data Type?
21:56:18 <dmwit> use "case"
21:56:31 <dmwit> Or the usual function application syntax.
21:56:44 <The_Journey> dmwit: can you show an example? thanks
21:56:49 <dmwit> ?src map
21:56:50 <lambdabot> map _ []     = []
21:56:50 <lambdabot> map f (x:xs) = f x : map f xs
21:56:53 <dmwit> The_Journey: ta-da
21:57:09 <The_Journey> but that's matching for a list?
21:57:13 <dmwit> Yes.
21:57:16 <The_Journey> ...?
21:57:19 <jessopher> lists are ADTs
21:57:21 <dmwit> Lists are an algebraic data type.
21:57:57 <The_Journey> can you do another example with like say data Foo = Foo { bar :: String, var :: String} ?
21:58:13 <dmwit> munge (Foo x y) = 3
21:58:31 <dmwit> munge (Foo x y) = x ++ y -- if you actually want to do something useful with your pattern
21:58:50 <The_Journey> so I can't do stuff like munge (Foo bar = "some" var = "other) = ...?
21:58:53 <jessopher> or munge (Foo {x = bar,y = var} = ...
21:58:59 <dmwit> munge foo = bar foo ++ var foo -- if you changed your mind about demanding pattern matching
21:59:10 <dmwit> The_Journey: Yes, you can do that.
21:59:24 <dmwit> munge Foo { bar = "some", var = "other" } = 3
21:59:32 <The_Journey> ah gotcha, thanks
21:59:46 <dmwit> jessopher: backwards
21:59:55 * jessopher slaps head
22:01:59 <The_Journey> do I have to pattern match all of the fields in ADT's?
22:02:23 <jessopher> you can  use the _ pattern, and for records, you can omit the field
22:02:24 <The_Journey> can I do stuff like munge Foo {bar = "some} = ...?
22:02:35 <dmwit> You can, yes.
22:02:39 <The_Journey> ok thanks
22:02:53 <dmwit> Don't forget that closing quotation mark.
22:03:00 <The_Journey> yea keep forgetting that lol
22:03:23 <The_Journey> is records syntax the usual way to write ADT in Haskell? Is there a preferred way?
22:03:42 <dmwit> Both with and without record syntax are common.
22:03:53 <dmwit> Each is preferred in different situations.
22:04:09 <The_Journey> when would it be better not to use records syntax?
22:04:16 <dmwit> I think I prefer records for single-constructor types and non-records for multi-constructor types.
22:04:25 <dmwit> I'm not sure what other people's rules of thumb are, though.
22:04:34 <The_Journey> ok thanks
22:04:39 <jessopher> i prefer records for single constructor types, with more than 3 arguments
22:05:10 <dmwit> Ah. Yeah, I don't bother with records for short argument lists, either, nice catch.
22:06:15 <jessopher> unless! its a newtype, then i generally go ahead and make an unFoo field
22:06:58 <dmwit> Actually, I've taken to writing unFoo as a function.
22:07:08 <dmwit> It makes the derived "Show" instance just that much less cluttered. =)
22:07:58 <jessopher> yeah that makes sense. plus its not like you are going to pattern match on it, might as well not be a field
22:19:18 <nexion> if I use the standard 'recv' in Network.Socket like: "recv clientSocket 3", will it wait until 3 UTF-8 characters are received, or 3 bytes?
22:20:39 <c_wraith> nexion: according to the comments, 3 bytes.  and yes, it'll mangle unicode
22:20:49 <c_wraith> nexion: the comments say not to use that function
22:21:23 <nexion> I'd like to support UTF-8 and have it perform well -- what should I use?
22:22:15 <c_wraith> use recv in Network.Socket.ByteString, and decode it yourself
22:23:32 <c_wraith> be aware the UTF-8 is variable-width
22:24:17 <nexion> yep
22:24:30 <nexion> should I use Codec.Binary.UTF8.String to encode/decode?
22:24:40 <c_wraith> I'd use Data.Text
22:25:07 <c_wraith> it's probably the fastest and correctest.
22:25:11 <etpace> Does anyone here know much about the llvm? In particular is loading/storing an array of two pointers faster than calling load/store twice, or do they get compiled to the same thing?
22:25:25 <etpace> Or actually, does anyone know what size the x86 load/store from memory is
22:26:03 <Enigmagic> etpace: typically a cache line at a time, but sometimes two
22:26:11 <Enigmagic> the size of which depends on the processor
22:26:41 <etpace> Hmm, that might mean the former is quicker
22:26:47 <etpace> it all depends on how the LLVM optimises I guess
22:26:49 <Enigmagic> well no
22:27:07 <Enigmagic> unless you're issuing a fence or interlocked it will most likely sit in L1
22:27:08 <etpace> it depends if it changes the latter into one isntruction right?
22:27:35 <Enigmagic> the processor will try to coalesce writes
22:28:02 <Enigmagic> if you're really concerned about fast stores then using a 128 bit store (via the sse registers) will be the fastest
22:28:08 <Enigmagic> on x86_64
22:28:10 <c_wraith> the answer is "performance is hard on modern architectures"
22:28:22 <Enigmagic> providing you meet the alignment requirements and all that
22:28:38 <etpace> I'm trying to figure out why my (initial iteration) compiler is 300x slower than GHC, and what I should work on first
22:29:01 <Enigmagic> profile the results and look?
22:29:05 <etpace> My two thoughts are not supporting vector application yet and secondly im doing twice as many load/stores because of what I said
22:29:36 <Enigmagic> GHC doesn't do vector operations typically either
22:29:37 <etpace> llvm-prof seemed to only show functions that are taking up time, not instructions
22:29:45 <Enigmagic> get a copy of v-tune
22:30:35 <etpace> Maybe badwording: f x y z -> my compiler builds f x, f x y, f x y z and then walks FV list etc, which is a lot of extra load/stores. if arity(f) == 3 then does GHC simply put x y z in registers and run f?
22:30:46 <Enigmagic> and also check the post-optimized llvm bitcode
22:31:27 <Enigmagic> if all the call slots are filled then it will just load them into registers and jump to the function
22:32:07 <Enigmagic> though if you're inlining aggressively and using ccall in llvm it may produce similar code
22:32:15 <Enigmagic> (from my experience it does)
22:32:41 <etpace> yeah, my implementation something like 12~ loads to build f x y z
22:32:43 <Enigmagic> aside from the tail calls
22:32:48 <rodayo> Hi all, I'm following this tutorial to learn haskell: learnyouahaskell.com but I feel it takes a purely bottom-up approach but I'd rather sorta jump and learn how to write a program and compile it. Is there another resource I should be looking at?
22:32:50 <etpace> sorry, ccall?
22:32:59 <Enigmagic> C calling convention
22:33:08 <Enigmagic> vs the STG cc that GHC uses
22:33:15 <etpace> sure
22:33:26 <etpace> Alright, i'll have a look at v-tune, thanks a lot
22:33:33 <Enigmagic> llvm's built-in optimization passes probably won't touch non ccall/fastcall functions
22:33:33 <c_wraith> rodayo: for most people, haskell is enough different than anything else they've seen, they're best off starting over.  you can try real-world haskell, but parts of it are out of date.
22:33:37 <c_wraith> @where rwh
22:33:37 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:34:48 <Enigmagic> etpace: are you compiling your bitcode to machine code?
22:34:55 <Enigmagic> 300x still seems huge
22:34:55 <rodayo> c_wraith, you'd think so but I find that I learn faster by jumping in, making a bunch of mistakes then fixing them and learning what I did wrong. =P
22:35:22 <etpace> Yeah I am, and yeah - thats why I think its something fundamentally stupid with my code generation
22:35:22 <rodayo> c_wraith, but thanks for the links, I'll take a look at them =]
22:35:26 <etpace> rather than a small tweak
22:35:32 <etpace> IE: doing twice as many loads as needed etc
22:35:41 <c_wraith> rodayo: it may be closer to what you're looking for.  and you can never have too many free books online
22:35:58 <rodayo> c_wraith, amen to that
22:36:10 <Enigmagic> etpace: are you running opt -O2/-O3 or the equivalent type of API calls?
22:36:36 <etpace> Oh uh -- sorry, 30x - misread my result
22:37:07 <Enigmagic> 30x is still really large
22:37:11 <etpace> Yep
22:37:15 <etpace> I'm running it through -O3
22:37:47 <Enigmagic> do you have a simple example in llvm assembly?
22:38:16 <rodayo> By the way, I heard there are a bunch of backends for the compilers and llvm performs best. Which one does GHC use?
22:38:46 <Enigmagic> rodayo: GHC uses its own assembly printer by default, llvm is available as an option if you have it installed
22:38:51 <c_wraith> ghc defaults to a built-in code generator, but supports llvm
22:39:32 <c_wraith> also, for most code, the llvm backend doesn't give much of a performance improvement.  It's not well-optimized yet.
22:39:33 <rodayo> I see, I guess it doesn't come packaged with it by default then. I'll look around, thanks =]
22:39:36 <etpace> Enigmagic: I'll get you something now, one moment
22:40:24 <Enigmagic> etpace: k
22:40:48 <rodayo> c_wraith: I think you're right there were a few cases it performed significantly better but generally the difference was marginal
22:42:52 <Enigmagic> i think it can be improved a fair bit still
22:43:05 <Enigmagic> i'd really like to see GHC using LLVM for link time optimization
22:46:54 <etpace> Enigmagic: https://github.com/etpace/p2c/blob/master/dis.ll unfortunately, it's quite hard to read: thats "foo x y z = x + y + z; main = foo 1 2 3" and the currying that goes inbetween. https://github.com/etpace/p2c/blob/master/sample.ll is an example of me "hand compiling" when I initially thought how my code generator would work
22:48:32 <Enigmagic> etpace: k, i'll take a look
22:52:10 <Enigmagic> etpace: any reason why %fValue/%list are defined as vectors?
22:53:02 <etpace> Hmm.. No special reason than just to declaratively explain the type
22:53:14 <etpace> perhaps they should both be size 2 array of pointers?
22:54:03 <Enigmagic> etpace: i'd try that
22:55:08 <Enigmagic> i know the vector support isn't that great in llvm 2.x, supposed to get better in 3.1 though for primitives (you'll probably still ahve perf issues with vectors of structs)
22:56:57 <oplacker> What is Haskell
22:57:10 <jessopher> its a programming language
22:57:21 <oplacker> is it for mathematics?
22:57:25 <oplacker> or just like ruby or C++
22:57:55 <jessopher> its for general programming, and some people use it for mathematics, so both
22:58:26 <jessopher> (some people use ruby and c++ for mathematics as well)
22:58:40 <etpace> Enigmagic: Vector == Structs in Llvm?
22:59:00 <etpace> <{}> was packed structs afaik?
22:59:33 <Enigmagic> etpace: oh nevermind :P < > is vectors
23:00:05 <etpace> Hah, Doh
23:00:07 <Enigmagic> :)
23:00:53 <etpace> I'm looking at my dis, and I'm seeing a lot of weird things in main()
23:01:04 <etpace> lots of   store i64* null, i64** %lv1T.i.i
23:01:19 <etpace> I guess it unrolled my init function
23:01:25 <etpace> where I initialise my top level vars
23:02:41 <etpace> Enigmagic: So I store to two adjacent cells often with two seperate stores, changing that to a store array wouldnt make a difference?
23:03:00 <Enigmagic> not 30x difference, no
23:03:31 <etpace> Ok, I'll have a go at shortcircuiting the currying
23:03:32 <Enigmagic> does GC_malloc take a mutex?
23:03:47 <etpace> or it could be my GC running all the time !
23:03:59 <etpace> I'm not sure, it's the bdwgc
23:04:08 <etpace> http://www.hpl.hp.com/personal/Hans_Boehm/gc/
23:04:47 <Enigmagic> sounds like v-tune or something like that would be a good first step
23:04:55 <etpace> Sure, thanks
23:05:24 <Enigmagic> the generated x86_64 assembly really doesn't look that terrible
23:07:18 <etpace> for my hand-codes or disassembled?
23:07:27 <Enigmagic> dis.ll
23:07:32 <etpace> hmm
23:08:13 <etpace> Maybe it was the example program I used to benchmark
23:08:28 <etpace> I could generate code especially bad for it
23:08:28 <Enigmagic> i'd run a profiler anyways
23:08:30 * hackagebot fast-logger 0.0.1 - A fast logging system  http://hackage.haskell.org/package/fast-logger-0.0.1 (KazuYamamoto)
23:08:32 * hackagebot wai-logger 0.1.1 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.1.1 (KazuYamamoto)
23:08:34 * hackagebot wai-logger-prefork 0.1.1 - A logging system for preforked WAI apps  http://hackage.haskell.org/package/wai-logger-prefork-0.1.1 (KazuYamamoto)
23:08:41 <Enigmagic> it may be the malloc calls
23:08:56 <Enigmagic> GHC uses a bump allocator
23:09:09 <Enigmagic> and has a faster GC than the broehm gc
23:12:50 <etpace> hmm
23:13:12 <etpace> What kind of performance would you expect for a basic llvm CG in comparison to ghc? x5?
23:13:24 <The_Journey> how can I create my own typeclass?
23:13:38 <shachaf> The_Journey: "class"
23:13:52 <shachaf> The_Journey: But if you're asking that question, it's quite possible that you shouldn't. :-)
23:14:02 <The_Journey> how so?
23:14:27 <shachaf> Beginners often overuse type classes.
23:14:44 <shachaf> It depends on your specific use case, of course.
23:14:46 <Enigmagic> etpace: hard to say really, there's not a general answer
23:15:05 <The_Journey> shachaf: when should I use it?
23:15:10 <The_Journey> oh nvm
23:15:38 <Enigmagic> etpace: it looks like broehm uses libc malloc, which tends to grab a global lock... which won't be as fast as incrementing a pointer
23:16:28 <Enigmagic> and GHC's GC does things that broehm can't do (since it was designed for C/C++)... it's more like the way a GC would work in C# or Java, with some tweaks for immutable values
23:17:39 <etpace> Hmm
23:17:59 <etpace> well, I'll profile and see what's going on :)
23:18:31 <etpace> This is purely for learning so any result is good!
23:18:35 <Enigmagic> good plan :-)
23:19:00 <shachaf> I once heard third-hand that GHC's GC has a lot of room for improvement.
23:19:41 <Enigmagic> i think all garbage collectors have a lot of room for improvement
23:20:13 <Enigmagic> GHC's isn't particularly great compared to .NET or (probably) the Sun JVM
23:20:44 <shachaf> Yes, compared to HotSpot's.
23:20:50 <Enigmagic> but it does work pretty well if you know how to make it happy, which is pretty much the same way of making the other GCs happy too
23:21:07 <Enigmagic> and you don't run with -N32
23:21:09 <Enigmagic> :-)
23:23:04 <c_wraith> yeah, GC in haskell is a strange problem, for reasons unlike what you'd expect:  crazy amounts of mutation
23:23:37 <etpace> evaluation of thunks?
23:23:39 <Enigmagic> the joys of laziness.
23:23:40 <c_wraith> yep
