00:45:37 * hackagebot acme-realworld 0.1.1 - Primitives for manipulating the state of the universe  http://hackage.haskell.org/package/acme-realworld-0.1.1 (JoeyAdams)
01:00:32 <Joe_> Hi
01:00:42 <Joe_> i try to run yi on ubuntu
01:00:57 <Joe_> but i am newbie on linux
01:01:11 <Joe_> i ve already install it using "cabal install yi"
01:01:35 <Joe_> but don't know hot to run it
01:04:10 <k0ral> hi, I'm having problems generating the documentation for my project: when invoking "cabal haddock", I get "cabal: Can't find transitive deps for haddock"
01:04:22 <k0ral> any clue ?
01:04:36 <danr> cabal update? :)
01:04:53 <k0ral> already done
01:06:15 <Joe_> cabal update
01:06:19 <Joe_> already done
01:06:23 <mm_freak_> k0ral: does your cabal file use 1.8 features?
01:06:37 <mm_freak_> like an executable referring to the library in the same package?
01:07:22 <k0ral> mm_freak_: yes
01:07:42 <mm_freak_> k0ral: haddock seems not to support that yet…  i have to comment out the executable to successfully build the documentation
01:07:57 <k0ral> oh, let me try that
01:08:33 <mm_freak_> for the time being, if your executable is not just a test program, i suggest putting it into a separate package
01:08:46 <mm_freak_> if it's a test program, just comment it out for releases
01:09:50 <k0ral> hmmm it's more than a test program
01:10:35 <k0ral> I'll comment out the executable part each time I want to generate the doc, thank you :)
01:18:43 <danr> Joe_: did you check your .cabal/bin folder?
01:21:55 <ddbbdbdb> Hi!  I'm trying to build a parser with Parsec so that it will read the whole input and fail if the input contains unparseable tokens, but somehow it only returns correct parts and does not touch the wrong token and everything that follows it
01:21:56 <ahax> hello
01:22:28 <ahax> i don't know where to look at to start learning formal proofs
01:22:49 <ahax> everytime i read a paper that has one i'm stuck
01:23:06 <ahax> do you have any references?
01:23:47 <ahax> books, links for example
01:24:04 <ahax> or the right channel :)
01:24:14 <ahax> thanks in advance
01:24:38 <ddbbdbdb> E. g. > parseTest (many1 $ string "a") "aabaaaaaaa"
01:24:42 <ddbbdbdb> ["a","a"]
01:25:03 <ddbbdbdb> Is there a way to make it report an error on encountering "b"?
01:27:07 <MostAwesomeDude> ddbbdbdb: Well, it's not really an error, is it?
01:27:28 <ddarius> ddbbdbdb: End your parser with eof.
01:27:46 <MostAwesomeDude> Aha. Listen to ^^ for I am not good with Haskell.
01:28:12 <ddbbdbdb> ddarius: Thanks a lot!
01:45:57 <Proge> http://www.youtube.com/watch?v=AkNVRKNFXGQ
01:46:48 <Proge> OOOPS
01:47:15 <Proge> :)
01:48:53 <Vasya> Guys please help me
01:49:02 <Vasya> i am linux newbie
01:49:11 <Vasya> trying to run yi text editor
01:49:17 <Vasya> i ve already install it
01:49:42 <Vasya> but i am so stuped and don't get how to run it
01:49:53 <Vasya> from terminal or whatever else
01:50:14 <Proge> haha
01:50:21 <Vasya> )
01:50:43 <Vasya> i just intall ubuntu vm on windows
01:51:05 <Proge> u my king?
01:51:18 <Vasya> ?
01:51:38 <Vasya> no i am not
01:52:45 <Vasya> what should i read to understand this kind of stuff in linux
01:52:51 <Vasya> i know it sounds silly
01:53:04 <Vasya> but in win i have exe files
01:53:12 <Vasya> and it is pretty straighforward
01:53:35 <Vasya> maybe i forget to write some env variables"
01:53:37 <Vasya> ^
01:53:39 <Vasya> ^
01:53:40 <Vasya> ?
01:54:00 <Vasya> nobody cares)
01:54:12 <MostAwesomeDude> Vasya: This isn't a general Linux channel. You should determine what the name of the editor is; in Ubuntu there should be an entry for it in your list of applications, and also an installed executable named "yi" or something similar.
01:55:23 <Vasya> i think maybe it is problem with cabal
01:55:28 <Vasya> something like
01:55:48 <Vasya> it install stuff not in ubuntu apps scope
01:56:24 <MostAwesomeDude> Oh, this is through cabal.
01:56:26 <daimrod> Vasya: I presume you didn't add the directory in which cabal installs packages to your PATH.
01:56:33 <MostAwesomeDude> There should be ~/.cabal/bin/yi or whatever it's called.
01:56:47 <daimrod> export PATH=~/.cabal/bin/:$PATH
01:57:21 <Proge> I CARE
01:57:47 <Vasya> IT WORKS!
01:57:49 <Vasya> GREAT!
01:58:08 <Vasya> daimrod thanks!
02:06:46 <srhb> With regards to class constraints.. If I do :type fmap in ghci, I get fmap :: Functor f => (a -> b) ... Does this mean that (a -> b) is a Functor f? I'm simply unsure of how to read it.
02:07:52 <srhb> Or does it simply relate to the f which comes later in the type signature
02:10:17 <mauke> srhb: the latter
02:10:45 <mauke> [value] :: [constraints] => [type]
02:11:06 <mauke> :t read
02:11:08 <lambdabot> forall a. (Read a) => String -> a
02:11:37 <mauke> this means 'read' has the type 'String -> a' with the additional constraint 'Read a'
02:14:12 <srhb> mauke: Thank you.
02:15:06 <srhb> mauke: So I read that as String -> a where a is an instance of Read? Or derives Read?
02:15:15 <mauke> is an instance of Read
02:15:32 <mauke> 'deriving' refers to a compiler-generated instance
02:15:51 <srhb> So that is a stronger implication which the type signature tells me nothing of?
02:16:10 <srhb> I think I get it. More or less. :-)
02:16:46 <mauke> yeah, you can't see from the type whether a function was written by a human or generated by a program
02:17:53 <srhb> It's funny how being able to understand type signatures seems to be a quite good indicator of "beginner's understanding" of Haskell.
02:19:38 <gtirloni> that gives the impression that after you stop being a beginner, you forget how to read types signatures ;)
02:20:07 <srhb> gtirloni: Ah, I didn't mean to say that. Or at least, I hope it doesn't work like that. :P
02:23:09 <gtirloni> haha
02:23:22 <gtirloni> i got it, just kidding :)
02:24:39 <Sgeo> Given acme-realworld and unsafePerformIO, is it possible to make a halts :: a -> Bool, where halts a never returns _|_, and is always correct as to whether a is bottom or not?
02:24:55 <Sgeo> (Erm, an acme-realworld that actually does what it purports to do, of course
02:28:00 <ahax> srhb: this video clarified many things for me on type classes:
02:28:02 <ahax> http://channel9.msdn.com/posts/MDCC-TechTalk-Classes-Jim-but-not-as-we-know-them
02:28:13 <srhb> ahax: I'll check that out, thank you.
02:28:25 <ahax> it's more than an hour, but very pleasant to watch
02:28:31 <ahax> you're welcome
03:06:30 <GoutamTmv> Is it possible to comfortably integrate Haskell with Cassandra and Hbase ?
03:06:49 <ique> I have a data structure that looks like a standard "store stuff in a name" data:  Record { prop1 :: String, prop2 ::String }; Is there any way to return a new Record with one of the properties changed?
03:07:58 <mauke> yes
03:08:18 <mauke> :t Node
03:08:20 <lambdabot> forall a. a -> Forest a -> Tree a
03:08:35 <mauke> > Node 42 []
03:08:36 <lambdabot>   Node {rootLabel = 42, subForest = []}
03:08:57 <mauke> > (Node 42 []){ rootLabel = 123 }
03:08:59 <lambdabot>   Node {rootLabel = 123, subForest = []}
03:40:28 <harriotq> Hi!  Is there an efficient way to get current "time"  like mach_absolute_time()?  Can't find it in Data.Time*, for example getCTimeval calls gettimeofday(3)
03:41:04 <mauke> @hoogle getCurrentTime
03:41:05 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
03:41:05 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
03:42:52 <harriotq> mauke: getCurrentTime = liftM posixSecondsToUTCTime getPOSIXTime, which in turn calls getCTimeval in some point
03:43:10 <harriotq> lots of conversions happening and it's all based on gettimeofday(3)
03:43:39 <quicksilver> the answer is no, harriotq , in the standard libs
03:43:47 <quicksilver> http://hackage.haskell.org/package/rdtsc-1.2.0.0 might be useful in some circumstances
03:44:41 <quicksilver> also http://hackage.haskell.org/package/clock-0.1 perhaps
03:45:21 <harriotq> quicksilver: thanks
03:56:18 <harriotq> From rdtsc description: "it takes about 950 cycles to call this function twice and to compute the difference, whereas in C the overhead is only about 88 cycles"   Which brings up a question that is there any shortcuts that can be taken around FFI?
03:58:33 <harriotq> A way to "inline" some LLVM assembly perhaps?
04:00:39 <quicksilver> not a simple, supported way, no.
04:01:01 <quicksilver> if you want to add primops you have to recompile ghc agaik
04:01:03 <quicksilver> afaik.
04:45:46 * hackagebot snaplet-hdbc 0.7 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.7 (JurrienStutterheim)
04:54:00 <carpi> what can i do if i get the index too large error?
04:55:18 <Botje> check your index operations
05:00:29 <carpi> i checked and doube checked and in my case the value of the index does not go beyond the length of a common english word
05:01:59 <Cale> carpi: "too large" just means "larger than the array you're indexing into"
05:02:59 <Cale> Maybe the array's bounds are incorrect when it's created somehow?
05:04:11 <hpaste> Carpi pasted “index woes” at http://hpaste.org/55048
05:05:02 <carpi> Cale: actually the length of the array being indexed into is the size of a common english word
05:06:17 <Cale> carpi: is every line of the file of the exact same length?
05:06:26 <Cale> carpi: or at least, shorter than the first line?
05:06:52 <Cale> length (m!!0) is the length of the first line of the file
05:07:19 <Cale> (using length and !! are a sign that you're using lists incorrectly)
05:07:34 <Cale> What is it that you're trying to do?
05:07:36 <carpi> Cale: not really.. its different size
05:07:53 <carpi> Cale: im trying to transpose the entire text in a file
05:07:56 <Cale> yeah, so you're determining the indices from the length of the first line
05:08:00 <hpc> @src transpose
05:08:00 <lambdabot> transpose []             = []
05:08:00 <lambdabot> transpose ([]   : xss)   = transpose xss
05:08:01 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:08:21 <hpc> carpi: you don't need length/!! to transpose a list
05:08:22 <carpi> Cale: actually from the length of the first word
05:08:32 <Cale> I meant what I said.
05:09:02 <Cale> transpS = unlines . trpl . lines, so trpl gets a list of the lines of the file
05:09:12 <Cale> and binds the variable m to that list
05:09:20 <Cale> m !! 0 is then the first line of the file
05:09:47 <carpi> ah.. i think thats where the error is
05:10:02 <Cale> I think the error is in the fact that you're using !! and length ;)
05:10:05 <carpi> because i wrote that list comprehension with the assumption that every line has one word
05:10:20 <carpi> oh and that too ) ill change it
05:10:22 <Cale> The error comes from assuming that every line has the same length
05:11:02 <Cale> specifically, your program assumes that no word is longer than  length (m !! 0)
05:11:14 <Cale> or rather, that no line is longer than that
05:11:26 <carpi> i think its the second one
05:11:37 <Cale> So if your file looks like
05:11:40 <Cale> apple
05:11:42 <Cale> banana
05:11:46 <Cale> you'll get a crash
05:12:15 <Cale> er, sorry, should be the other way around
05:12:17 <Cale> banana
05:12:18 <Cale> apple
05:12:29 <Cale> then length "banana" = 6
05:13:03 <carpi> ah yes.. and then when it goes to the next line it tries accessing an element from apple that does not exist
05:13:06 <Cale> and i <- [0..6], and then when i = 6, the inner list is [x !! 6 | x <- m]
05:13:18 <Cale> and if x = "apple"
05:13:30 <Cale> oh, sorry, I should have subtracted 1 too :P
05:13:34 <Cale> (I'm a bit sleepy)
05:13:37 <Cale> but you see?
05:13:45 <Cale> even [0..5] is problematic
05:13:54 <carpi> shite.. i feel silly now..but thanks for pointing it out.. now i understand
05:13:58 <Cale> because the highest index of an element of "apple" is 4
05:14:36 <Cale> > transpose ["apple", "banana"]
05:14:38 <lambdabot>   ["ab","pa","pn","la","en","a"]
05:14:53 <Cale> If that's what you're trying to do, it's in the standard library :)
05:15:28 <carpi> im doing it as an exercise from RWH.. ) but i wasn't unaware of the function transpose.. )
05:17:19 <erus`> > transpose $ transpose ["apple", "banana"]
05:17:20 <lambdabot>   ["applea","banan"]
05:17:26 <erus`> :|
05:18:18 <Cale> transpose isn't an involution for non-rectangular lists of lists
05:19:05 <carpi> by involution you mean its not the same?
05:19:16 <Cale> @check \xs -> (transpose . transpose . transpose) (xs :: [Integer]) == transpose xs
05:19:17 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `transpose'Not in scope: `transpo...
05:19:36 <Cale> oh, weird, quickcheck is broken now...
05:19:41 <Cale> I'll see if I can fix it later...
05:20:37 <Cale> that had a type error anyway (should have been [[Integer]])
05:20:45 <Cale> ghci> quickCheck $ \xs -> (transpose . transpose . transpose) (xs :: [[Integer]]) == transpose xs
05:20:45 <Cale> +++ OK, passed 100 tests.
05:22:07 <Cale> carpi: I mean that transpose . transpose isn't the same as the identity function (doing nothing)
05:22:39 <Cale> An involution is a function f such that f (f x) = x
05:23:08 <Cale> that is, a function which is its own inverse
05:25:04 <carpi> its such a long non-obvious word. a function with such a property must be given another name.. )
05:25:39 <carpi> but i think it makes sense..involute.. -> to turn inside out
05:25:44 <carpi> or something similar
05:25:59 <Cale> The list of lists that transpose gives as its result always has the property that they are weakly decreasing in length
05:26:06 <Cale> yeah
06:00:46 * hackagebot test-framework 0.4.2.0 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.4.2.0 (MaxBolingbroke)
06:26:28 <Peaker> I'm trying to toy around with pickler combinators, and I'm finding it quite difficult to write the combinators
06:26:51 <conal> Peaker: hi. with hxt?
06:26:59 <Peaker> conal: What's hxt?
06:27:09 <conal> @hackage hxt
06:27:10 <lambdabot> http://hackage.haskell.org/package/hxt
06:27:21 <Peaker> conal: I'm trying to compose value of: data Construct a = Construct { getter :: Get a, putter :: Putter a }
06:27:24 <conal> Peaker: ^^ has pickle combinators.
06:28:02 <conal> Peaker: ah. you're rolling your own combinators. i didn't read closely enough.
06:28:13 <Peaker> conal: I want ones where you control the "wire format"
06:28:15 <conal> Peaker: following andrew kennedy's pickle paper?
06:28:30 <Peaker> conal: Nope, just on my own, though maybe I'll go read soon if I don't make progress :)
06:28:52 <Peaker> I'm finding difficulty writing a sequence-like combinator:  [Construct a] -> Construct [a]
06:29:12 <Peaker> (I could write it by manually implementing the getter/putter, I'm trying to figure out how to compose it nicely
06:29:58 <Peaker> The most useful combinator I managed to get so far is:   Construct a -> (a -> Construct b) -> Construct (a, b)   (Can't quite get rid of the (a,) in the result there)
06:32:29 <Peaker> conal: I haven't found any existing work where you can control the "wire format" -- I'm assuming pickler combinators in hxt do XML pickling?
06:33:08 <conal> Peaker: right. xml pickling. and i don't remember any details about andrew k's work.
06:34:02 <Peaker> conal: I think I saw that one, and it was interesting/nice, but emphasized the ability to compose picklers, without being able to control the wire format
06:34:15 <conal> Peaker: ah. sounds likely.
06:36:19 <Peaker> After I get pickler combinators with wire format control -- I'd also want to leave Hask, and point-free compose something that represents the operations non-opaquely, so I can compile my picklers to (e.g: C)
06:47:19 <Peaker> conal: reading Kennedy's Pickler Combinator paper -- that is great.. :) I can't find it on hackage though
06:47:35 <Peaker> It wouldn't be hard to control the exact representation, I think
06:48:02 <conal> cool.
06:48:19 <conal> Peaker: if you want to compare to hxt pickling, see http://hackage.haskell.org/packages/archive/hxt/9.1.5/doc/html/Text-XML-HXT-Arrow-Pickle.html
06:49:28 <Peaker> I'm a bit allergic to XML :)
06:52:16 <Peaker> conal: These papers make it seem so easy&simple :)
06:52:56 <conal> Peaker: yeah. and often a lot of hard work goes into getting there. :)
06:54:21 <Peaker> I spent a few hours now struggling trying to figure out which combinators I could use.. My   PU a -> (a -> PU b) -> PU (a, b)   is simply changed to   (b -> a) -> PU a -> (a -> PU b) -> PU b         and a big problem of mine is solved (bijective (b <-> (a, b)) is no longer needed)
06:54:42 <Peaker> I am going to try to see if I make progress on my own from there, for the pedagogical value
06:55:13 <conal> Peaker: yeah. more fun that way.
06:56:26 <NotDigital> Hello.
06:56:35 <NotDigital> I've been at haskell for an entire day, and I have a question.
06:57:01 <NotDigital> I've written some trivial nonsense at http://pastebin.com/jtBj2G1L.  I don't understand why I need to specify (Enum a, Num a) instead of just (Num a), but ghci yells at me if I don't include the Enum.
06:57:07 <NotDigital> Can anyone enlighten me?
06:58:02 <conal> NotDigital: do yo want to know why enum is needed? or why num doesn't imply enum?
06:58:22 <NotDigital> why enum is needed.
06:58:54 <NotDigital> I get that there are enumerable types that are not numbers (or at least I think I do)
06:59:19 <conal> NotDigital: [a..b] is syntactic sugar for application of an Enum function
06:59:32 <conal> something like enumFromTo
07:00:12 <ski> NotDigital : not all types in `Num' are in `Enum'
07:00:21 <ski> > [1:+2 .. sqrt (-1)]
07:00:22 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Complex.Complex t))
07:00:22 <lambdabot>    arising from a ...
07:02:46 <NotDigital> Oh, I think I see.
07:02:58 <NotDigital> Haskell is really neat, though at times it makes my brain melt out of my ears.
07:03:52 <ski> @quote brain.melt
07:03:52 <lambdabot> dons says:  its like you can really see the guy's brain melting
07:04:09 <NotDigital> glad to see I'm not alone. :)
07:04:10 <ski> :)
07:05:14 <ski> @quote paperwork
07:05:14 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
07:06:19 <lars9> @quote lisp
07:06:20 <lambdabot> qwe1234 says: lisp is yet another half-assed run-of-the-mill scripting language. absolutely *no different* from something like php in any significant way worth mentioning.
07:06:41 <lars9> @quote c++
07:06:42 <lambdabot> Excedrin says: the Budweiser-Miller type inference algorithm; I'm drinking beer and inferring that it might be water
07:07:03 <lars9> @quote lambdabot
07:07:04 <lambdabot> lambdabot says: Beer, it's so much more than just a breakfast drink!
07:07:17 <ski> that lisp one seems a bit unfair
07:07:28 <lars9> @quote ocaml
07:07:29 <lambdabot> vincenz says: [Ocaml] used to be pretty, Haskell made it ugly
07:07:55 <ski> @quote finally.arrived
07:07:55 <lars9> @quote miranda
07:07:55 <lambdabot> syntaxfree says: Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
07:07:56 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
07:08:07 <ski> @quote lambdabot
07:08:08 <lambdabot> lambdabot says: <tristes_tigres> @vixen unsafe <lambdabot> you're turning me on :)
07:08:35 <lars9> @quote haskell
07:08:36 <lambdabot> haskell says: "a programming language"
07:08:41 <lars9> @quote haskell
07:08:42 <lambdabot> haskell says: Haskell - it's like a Lamborghini in the village. A little jerk - and went to work on the tractor.
07:08:55 <scooty-puff> does haskell use what could be considered the HM(X) type system?
07:09:03 <scooty-puff> minus let generalization except at the top level?
07:10:01 * ski thought let-generalization was everywhere ..
07:13:12 <quicksilver> let generalisation is everywhere afaik.
07:13:30 <TTimo> I lol'ed
07:13:36 <quicksilver> the top-level isn't special in any way I can think of just now
07:15:59 <scooty-puff> k, couldn't recall if it was to be removed or something, related to impredicative types or something?
07:16:43 <scooty-puff> anyways, was looking at this: type inference with constrained types
07:16:54 <scooty-puff> (its readily available from a google search)
07:17:07 <scooty-puff> and was trying to handle (in an imperative languages):
07:17:22 <scooty-puff> var x; x = true; x = void; (true of type bool, void of type void)
07:17:27 <scooty-puff> which desugared to:
07:17:56 <scooty-puff> (\ x -> (\ _ -> x = void;) (x = true)) (<undefined?>)
07:18:05 <wereHamster> > void
07:18:07 <lambdabot>   Not in scope: `void'
07:18:08 <scooty-puff> well, insert a few const's
07:18:28 <scooty-puff> well, could just as well have data Void = Void, then its more in line with haskell
07:18:29 <scooty-puff> so:
07:19:22 <scooty-puff> (\ x -> (_ -> const () (x := Void)) (const () (x := True))) (<undefined>))
07:19:28 <scooty-puff> prob got the paren count wrong..
07:19:42 <scooty-puff> from some (:=) :: forall a. -> a -> a -> a
07:20:08 <lars9> want to generate some vectorized images, what lib is preferred?
07:24:00 <byorgey> @package diagrams
07:24:01 <lambdabot> http://hackage.haskell.org/package/diagrams
07:24:06 <byorgey> lars9: try that ^^^
07:24:57 <lars9> byorgey: gallery seems promising
07:25:06 <lars9> byorgey: thanks to the author
07:27:30 <lars9> byorgey: does facebook use haskell? =)
07:31:33 <erus`> byorgey: yeah a little bit for tools and stuff
07:31:37 <erus`> not for the site though
07:31:56 <scooty-puff> > let stmt = const ()
07:31:57 <lambdabot>   not an expression: `let stmt = const ()'
07:32:03 <scooty-puff> > stmt = const ()
07:32:04 <lambdabot>   <no location info>: parse error on input `='
07:32:21 <erus`> i mean lars9
07:32:23 <scooty-puff> > const ()
07:32:24 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> ())
07:32:24 <lambdabot>    arising from a use of ...
07:32:40 <scooty-puff> stmt = const ()
07:32:42 <scooty-puff> meh..
07:33:44 <erkin> Hello. What's the best cross-platform GUI library for Haskell?
07:35:46 * hackagebot HaTeX-meta 1.1.0 - HaTeX monad modules builder.  http://hackage.haskell.org/package/HaTeX-meta-1.1.0 (DanielDiaz)
07:35:48 * hackagebot HaTeX 3.1.0 - LaTeX code writer.  http://hackage.haskell.org/package/HaTeX-3.1.0 (DanielDiaz)
07:36:54 <carpi> "func :: (Enum a) => JValue -> Maybe a" is such a type signature valid?
07:36:58 <turiya> hi
07:37:16 <turiya> can someone explain what this line of code means: "plot_lines_values :: forall x[aNtR] y[aNtS]. T (PlotLines x[aNtR] y[aNtS]) ([] ([] ((,) x[aNtR] y[aNtS])))"
07:37:37 <turiya> from http://hackage.haskell.org/packages/archive/Chart/0.14/doc/html/Graphics-Rendering-Chart-Plot-Lines.html
07:40:18 <quicksilver> turiya: it's a bug in the docs
07:40:20 <fryguybob> turiya: Those lines come from some template Haskell.
07:40:29 <quicksilver> related, I suspect, to those functions being generated by TH
07:44:00 <turiya> i see... i also dont understand what the symbols ^= do in the expression "sinusoid1 = plot_lines_values ^= [[ (x,(am x)) | x <- [0,(0.5)..400]]]"
07:44:34 <quicksilver> they're not magic symbols, turiya
07:44:41 <quicksilver> that's a user defined operator
07:44:47 <quicksilver> from the Data.Accessor package
07:45:18 <turiya> aahh, ok..
07:45:52 <turiya> what do they do?
07:46:07 <Eduard_Munteanu> Look there :)
07:49:16 <lars9> byorgey: how to use diagrams-lib without whole diagrams installed? gtk2hs does not compile in my mac
07:49:38 <turiya> An Accessor r a is an object that encodes how to get and put a subject of type a out of/into an object of type s. Should the last letter be r?
07:49:56 <dcoutts> lars9: can you install just cairo?
07:52:20 <turiya> Eduard_Munteau: thanks for reminding me I should not be lazy :)
07:52:43 <turiya> Eduard_Munteanu:^^
07:53:29 <Eduard_Munteanu> :)
07:54:29 <ulfdoz> namd
07:56:36 <scooty-puff> let a $= b = a `asTypeOf` b in let stmt = const () in (\ x -> (\ _ -> stmt (x $= True)) (stmt (x $= (0 :: Int)))) undefined
07:56:53 <scooty-puff> would that be about how you would represent the syntax tree to a type inferencer
07:57:08 <scooty-puff> for: var x; x = true; x = 0; (some hypothetical imperative language)
07:57:36 <lars9> dcoutts: no, glib does not compile
07:59:09 <Eduard_Munteanu> scooty-puff: mm, I wouldn't say so... you probably want an ADT that represents the syntax tree, e.g. application, abstraction etc.
08:00:29 <Eduard_Munteanu> Anyway, in the case of imperative languages you'd have expressions and statements. And perhaps declarations.
08:01:50 <Eduard_Munteanu> For example.... data Stmt = ... | Assignment Name Expr
08:02:16 <scooty-puff> well, the ast is represent like that - just trying to sort out how to handle the app, abs, etc. hm primitives in the imperative language
08:02:25 <Eduard_Munteanu> GADTs might help enforce additional invariants.
08:03:21 <Eduard_Munteanu> scooty-puff: evaluation/execution? You'd define that by induction on expressions/statements
08:03:51 <Eduard_Munteanu> eval (App f x) = ...
08:06:51 <dcoutts> lars9: out of interest, what system are you using? macports, homebrew?
08:07:52 <dgpratt> Axman6: around, perchance?
08:18:23 <lars9> dcoutts: homebrew
08:19:45 <dcoutts> lars9: oh, hmm, that's the one that's supposed to work
08:20:03 <dcoutts> lars9: I don't suppose we could bother you for a build log for cabal install glib
08:20:09 <lars9> i used cabal install diagrams
08:20:29 <lars9> dcoutts: i'll try
08:20:29 <dcoutts> I presume it's the glib Haskell package that failed, not the glib homebrew package
08:21:28 <dcoutts> lars9: right? you did have the homebrew glib/cairo/etc packages installed ok?
08:22:13 <lars9> dcoutts: i didn't install them...
08:22:25 <dcoutts> ah then that's probably the issue
08:22:34 <lars9> do i need to? i just switched to mac from arch and know little about it
08:22:37 <dcoutts> the C libs need to be installed before the Haskell bindings
08:23:34 <dcoutts> lars9: with arch if you were using arch packages for everything then it's easy because the Haskell binding packages can have deps on the C libs and the package manager will sort it out
08:24:02 <dcoutts> lars9: with the combo of homebrew + cabal, there is no automatic resolution of Haskell packages on C libs/packages
08:24:29 <lars9> dcoutts: understood, let me install glib cairo etc
08:26:50 <lars9> glib is installed already
08:27:38 <ga2arch> hi =)
08:27:56 <hpaste> lars9 pasted “can not install glib” at http://hpaste.org/55052
08:28:22 <lars9> dcoutts: that's the error log
08:30:09 <ga2arch> how can i create a function like the : for lists but for my own type so i can do something like (DdString "hi"):(DdList []) -> (DdList [DdString "hi"]) ?
08:37:44 <dcoutts> lars9: ok, just follow the advice in the error message
08:38:42 <Botje> ga2arch: you probably don't want to call it ':'
08:38:55 <Botje> ga2arch: call it `Dcons` or something
08:39:11 <ga2arch> ok, but i dunno how to implement it
08:39:23 <Botje> what does a DdList look like?
08:39:35 <ga2arch> [Decoded]
08:39:43 <Botje> okay
08:40:02 <Botje> the first argument can be anything, right?
08:40:05 <Botje> so call that 'el'
08:40:17 <Botje> and the second argument has to be a DdList, which carries a [Decoded]
08:40:23 <Botje> so pattern match on that as well
08:40:31 <Botje> then you get the left hand side of the function:
08:40:44 <Botje> dcons el (DdList list) = ...
08:41:05 <Botje> and now you have to construct a new DdList on the right-hand side
08:41:12 <Botje> which has el added to the list somehow
08:42:15 <ga2arch> ah ok i see thanks, what bothers me know is .. with that can i "dcon" more than one element at a time ?
08:42:19 <ga2arch> ex:
08:42:31 <ga2arch> (DdString "hi"):(DdInt 5):(DdList [])
08:42:55 <ga2arch> with : replace with dcon ofcorse
08:43:56 <Botje> ga2arch: sure.
08:44:07 <Botje> ga2arch: you could also call dcons :*: or something.
08:44:23 <Botje> > let f :*: g = (f,g) in 1 :*: 2
08:44:24 <lambdabot>   Couldn't match expected type `t GHC.Generics.:*: t1'
08:44:24 <lambdabot>         against inferr...
08:44:41 <Botje> and of course that's an identifier taken by something >_<
08:45:14 <rwbarton> you can't name a function with a name starting with a :
08:45:53 <rwbarton> ga2arch: it just needs to be grouped like this:  (DdString "hi"):((DdInt 5):(DdList []))
08:48:31 <asante> how can i define recursive functions like "foo (2*n) = foo n" ?
08:48:34 <ga2arch> thanks, now i see =)
08:49:26 <rwbarton> asante: you can't pattern match against "2*n" so you would need to use guards or whatever
08:49:37 <shachaf> asante: foo n = foo (n `div` 2) or foo n = foo (n / 2) or whatever you want.
08:49:37 <rwbarton> foo m | even m = let n = m `div` 2 in foo n
08:49:50 <asante> ok thanks
08:49:50 <shachaf> Oh, or what rwbarton said.
08:49:59 <asante> i just wonder, cause (n+1) would work
08:50:48 <shachaf> asante: (n+1) is a slightly-hacky special case that was removed in Haskell 2010.
08:51:20 <shachaf> It's meant to make numeric types look like peano naturals, i.e., pattern-matching on Succ.
08:51:20 <asante> ah ok, interesting
08:51:32 <shachaf> Actually, what I said is probably not true, because it works with (n+k), not just (n+1).
08:52:16 <asante> why shouldn't that be used?
08:52:47 <shachaf> Well, because it's unlike every other pattern in the language.
08:53:10 <shachaf> You can't say foo (f n) = ...; why should (+) get special treatment?
08:54:44 <shachaf> Of course, you can use the same argument against matching on numeric constants. :-)
08:54:48 <asante> ya, right.. and why can't i use functions in pattern matching?
08:55:04 <asante> isn't a numeric constant something like a constant function?
08:55:23 <shachaf> asante: Do you want GHC to invert arbitrary functions for you? :-)
08:55:31 <shachaf> asante: Not really.
08:55:56 <shachaf> It doesn't take an argument so it's not a function.
08:57:25 <asante> mh, why would that invert arbitrary functions?
08:58:09 <shachaf> foo (f x) = ... x ... requires the program to invert f.
08:58:34 <rwbarton> foo (0*x) = foo x -- uh-oh??
08:58:40 <asante> ya. ok i see :)
08:58:43 <ajf> hi
08:59:00 <asante> thanks!
08:59:35 <shachaf> rwbarton: That one's easy: It translates to foo x = foo (x/0)
09:01:37 <scooty-puff> Eduard_Munteanu: so like var x; x = true; would be [VarDeclS <id of x> Nothing, ExprS (AssignE <id of x> (LitE (Bool True)))] or some such - when the type inference is run, would treat a (VarDeclS .<id of x> Nothing: xs) just like (FunE <id of x> ...), etc.
09:01:51 <scooty-puff> Eduard_Munteanu: not sure if that really cleared much up about what i mean and am trying to do
09:03:44 <scooty-puff> the ast won't be transform to something more like HM(X), but would be treated like the transform had happenned - the ast is for a compiler
09:07:12 <mzero> ajf: hello - looking for something?
09:07:55 <ajf> just using the interactive turtoial ting
09:08:41 <mzero> ah, well then, welcome!
09:08:49 <ajf> thank you! :)
09:13:05 <copumpkin> sjoerd_visscher: your effects package looks nice
09:13:15 <copumpkin> I haven't played with it much yet though :)
09:17:43 <sjoerd_visscher> thanks
09:17:58 <sjoerd_visscher> I haven't really played with it either
09:21:06 <sjoerd_visscher> mzero: about the HP rc
09:21:14 <mzero> ah yes
09:21:28 <sjoerd_visscher> I deleted ghc* and haddock*, that fixed it
09:21:58 <mzero> you didn't have to recreate them?
09:22:09 <mzero> or you installed after doing that?
09:22:19 <sjoerd_visscher> maybe you can reproduce it by installing ghc-7.2.1, run uninstall-hs and then installing the HP
09:22:29 <sjoerd_visscher> I ran the installer again after deleting them
09:23:42 <sjoerd_visscher> I don't dare to try to reproduce it, since it's been a while that I had a properly working haskell setup
09:27:44 <carpi> could someone please tell me what is the undefined function for? is it for creating errors that occur when the control flow reaches the part of code that is not supposed to be reached?
09:28:01 <carpi> ghci simply says undefined :: a
09:29:02 <Eduard_Munteanu> carpi: it's an undefined value of any type. Evaluation will trip on it at runtime.
09:29:31 <carpi> Eduard_Munteanu: so i can use it to produce errors?
09:29:43 <Eduard_Munteanu> carpi: error "foo" might be better
09:29:59 <Eduard_Munteanu> Yet better is handling errors gracefully.
09:30:12 <Eduard_Munteanu> (e.g. using Maybe, Either or exceptions)
09:30:54 <Eduard_Munteanu> carpi: you'd normally use stuff like "error" for stuff that really shouldn't happen, like an assertion "this branch shouldn't be taken"
09:31:41 <carpi> to me it seems like the purpose of undefined is to purposfully disorient the type system
09:31:58 <mzero> thanks sjoerd_visscher  -- I wonder what was up with those symlinks…. hmmmm….. I'll look into it
09:32:45 <Eduard_Munteanu> carpi: the type system is already "disoriented" you could say, since every type has a bottom (undefined) value.
09:33:21 <carpi> bottom value?
09:34:15 <Eduard_Munteanu> carpi: every type is trivially inhabited in Haskell, even stuff that shouldn't be, like   data Void
09:37:38 <aavogt> how about newtype Void?
09:40:23 <roconnor> aavogt: Eduard_Munteanu means undefined :: Void
09:40:42 <rwbarton> carpi: One use for undefined is when you've written part of a function and want to type check what you have so far before completing it
09:40:57 * hackagebot resource-pool 0.2.0.4 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.0.4 (BryanOSullivan)
09:41:21 <roconnor> carpi: the purpose of bottom is to derive fixpoint solution to every recursive function.
09:41:46 <Eduard_Munteanu> One additional reason you might use undefined is making "postulates" in Haskell, but in that case you're barking up the wrong tree anyway :)
09:41:53 <roconnor> carpi: (I agree it isn't really a great reason)
09:42:44 <roconnor> you guys can post-facto produce all the excuses for bottom that you like, but if we give denotational semantics to our language without using bottoms, then there wouldn't be bottoms.
09:42:52 <rwbarton> or general recursion
09:42:56 <roconnor> *if we could give
09:43:47 <roconnor> to be more specific, bottom is great from a "theory of computation" point of view, but not so great from a practical programming point of view.
09:45:58 * hackagebot cpsa 2.2.6 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.6 (JohnRamsdell)
09:46:17 <rwbarton> Yeah, it's just so impractical to use a Turing-complete language. (??)
09:46:30 <roconnor> indeed
09:47:03 <copumpkin> yeah, I hate those
09:47:24 <copumpkin> who needs general recursion anyway
09:47:29 <arw> much too complicated. regular automatons should be enough for everybody.
09:47:29 <copumpkin> way overrated
09:47:39 <copumpkin> arw: except I'm actually being serious ;)
09:48:19 <sjoerd_visscher> Prelude Data.Void> undefined :: Void
09:48:19 <sjoerd_visscher> Void (Void (Void (Void (Void (Void (Void (Void (Void ...
09:48:33 <copumpkin> data Void = Void Void deriving (Show)
09:48:34 <copumpkin> whoops
09:48:35 <copumpkin> newtype :)
09:49:07 <arw> copumpkin: then I need to learn more to understand it :)
09:50:04 <hpc> sjoerd_visscher: ahaha!
09:52:58 <carpi> confusion confirmed
09:53:19 <alistra> @src sequence
09:53:20 <lambdabot> sequence []     = return []
09:53:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:53:20 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
09:54:12 <carpi> rwbarton: so you're saying i can write a half working function and put the undefined type in the signature to test what im working with so far?
09:54:28 <rwbarton> no
09:54:35 <rwbarton> undefined is a value
09:54:37 <rwbarton> not a type
09:55:18 <carpi> ah.. so i can pass it the undefined value which will be accepted no matter what type the functions takes..
09:55:48 <fryguybob> @type undefined
09:55:49 <lambdabot> forall a. a
09:55:50 <carpi> i mean.. so i can pass the half working function an undefined value...to test it
09:55:52 <rwbarton> suppose I am writing foo x y = banana x + banana y + banana (x * y) where banana t = sin t
09:56:28 <rwbarton> I can write that first line and then "where banana = undefined" and then I can type check what I have so far before I worry about how to actually implement banana
09:57:41 <rwbarton> and that way I don't try to write several lines of code before giving it to the type checker, which is good because when there are several type errors, the error messages tend to be more confusing
09:58:15 <carpi> rwbarton: when you say type check you mean if "foo" accepts and returns the prescribed types so far?
09:58:46 <rwbarton> sure, like if I typoed one of the + as ++ then I would get a type error before I even define banana
09:59:12 <rwbarton> or if I wrote a type signature for foo, I could check that what I have so far is consistent with that type signature
10:00:00 <carpi> ah.. now i think i understand..
10:00:44 <arw> would an undefined value ever turn up at runtime or is it really just there for the typechecker at compile time?
10:01:41 <rwbarton> well if you're using this method to type check a function as you write it, and then you get an undefined value at runtime, that means you didn't finish writing your function
10:01:43 <roconnor> arw: sadly undefined values can turn up at runtime
10:02:03 <rwbarton> roconnor is from another planet, don't worry about him.
10:02:32 <rwbarton> In general, though, if you write "undefined" in your program, that probably was a mistake (or indicates you haven't finished writing your program)
10:03:21 <arw> okay, let me rephrase. some guy doesn't like type safety and Maybe. so on error, he returns undefined. do i really need to check for that on every call i make to have a correct program?
10:03:40 <rwbarton> you can't check for it
10:03:43 <roconnor> arw: it is very difficult to check for undefined
10:04:16 <Eduard_Munteanu> You don't have to check just for literal 'undefined'.
10:04:23 <roconnor> arw: if this guy doesn't like type safety, there is very little you can do to use his library safely.
10:04:32 <Eduard_Munteanu> You also have to check for  f x = f x etc.
10:04:40 <rwbarton> this guy could also have returned an infinite loop, yeah
10:04:59 * roconnor won't bring up the horrible library "spoon" for dealing with this problem.
10:07:10 <rwbarton> in GHC, at least, "undefined" actually raises an exception which you can catch from within IO; but morally returning undefined is the same as entering an infinite loop, which you can't catch of course
10:07:30 <mm_freak_> does anyone know a library for web forms that is not tied to a particular web framework?
10:07:46 <Eduard_Munteanu> Having an undefined which you could pattern-match on would be just as evil I guess.
10:07:48 <mm_freak_> there is 'formlet', but it seems a bit outdated
10:08:04 <mm_freak_> formlet → formlets
10:08:33 <shachaf> copumpkin: Did you hear what roconnor said?
10:08:45 <shachaf> He's seen your true colors!
10:09:45 <arw> okay, but from a practical point of view (and for a ghc user) its just another runtime exception one would have to catch (or not).
10:09:49 <donri> mm_freak_: digestive-functor?
10:10:06 <shachaf> arw: Catching "undefined" is rarely what you want to do.
10:10:23 <shachaf> arw: Really, "undefined" is just a slightly more convenient form of infinite recursion.
10:10:44 <rwbarton> if you're using a function from someone's library and it throws undefined at you the right course of action is to yell at the library author.
10:10:52 <Eduard_Munteanu> Just use Maybe or something else if you want to handle that stuff nicely.
10:11:26 <shachaf> rwbarton: Hackage doesn't have a package for doing that, though.
10:12:28 <arw> shachaf: exceptions are rarely something one wants to do, except to yell at somebody about how Maybe is nicer :)
10:13:01 <donri> @hackage safe
10:13:01 <lambdabot> http://hackage.haskell.org/package/safe
10:13:40 <rwbarton> exceptions are possibly reasonable when the exceptional condition is "the client disconnected" or "the hard drive is full", but if you encounter undefined then the condition is "the program is incorrect"
10:14:10 <shachaf> rwbarton: It depends on how broad your definition of "exception" is. :-)
10:14:26 <rwbarton> I mean exceptions as in exceptions as in GHC.
10:14:47 <mike-burns> I'd rather an Either.
10:14:49 <arw> rwbarton: yes, but in most cases it boils down to "can't handle this, tell the user and abort"
10:15:24 <Saizan> it's not composable to write functions that want to abort
10:15:28 <rwbarton> if you're writing a web server or something maybe you want some isolation between components of the server where a program error in one part will not bring down the whole server, then it might be reasonable to catch an exception from undefined/error
10:15:35 <Saizan> since aborting is a pretty global action.
10:15:39 <mike-burns> Well, if the machine is out of RAM I'd rather an exception, but in every library I use I'd rather an Either.
10:15:54 <Saizan> the UI code should be the one deciding to abort or not
10:15:55 <shachaf> mike-burns: Why use Either when you're using IO? IO does everything!
10:16:04 <mike-burns> Hah, it sure does.
10:16:39 <donri> why doesn't someone create a programming language that runs in an IO monad!
10:16:47 <donri> with every type as Data.Dynamic
10:16:49 <shachaf> Someone needs to introduce Cont right into IO on top of State and Either and whatever else it has.
10:16:51 <donri> it'd be so convenient!
10:16:58 <shachaf> IO, Supermonad.
10:17:19 <Eduard_Munteanu> ContT over IO kinda is
10:17:26 <dgpratt> well, somehow I managed to get through "20 Intermediate Haskell Exercises" despite the fact that I lost track of what was going on after about exercise 10 :-)
10:17:31 <arw> rwbarton: there is the "handle-able" half of exceptions, like "our tcp connection just closed unexpectedly" which imho is just nicer as an Either or something. and then there is the half which you usually can't handle in any sensible way, disk full, ram full, universe collapsing, stack overflow. those are fine as exceptions.
10:17:46 <mike-burns> Yeah!
10:18:15 <rwbarton> yes and there is also "the programmer thought this condition was impossible, but it turns out it is not impossible"
10:18:16 <dgpratt> though I don't think I would have gotten through exercise 14 without some significant help from Axman6
10:19:43 <rwbarton> that's where it is reasonable to use error/undefined
10:19:46 <rwbarton> preferably error
10:19:53 <rwbarton> or an incomplete pattern match, or something
10:20:19 <copumpkin> shachaf: no I didn't
10:20:23 <copumpkin> oh
10:20:28 <copumpkin> roconnor: I can't believe you insulted my library
10:20:30 <copumpkin> :'(
10:22:31 <ByronJohnson> spoon should probably only be used as a workaround for libraries that throw exceptions when they should use Either
10:24:04 <ByronJohnson> binary is one such library
10:24:32 <mike-burns> That looks handy.
10:24:36 * mike-burns bookmarks this.
10:24:59 <mike-burns> Bummer that it throws the exception away, though.
10:25:12 <ByronJohnson> zlib, IIRC, also throws exceptions when it decompresses invalid input
10:25:12 <mm_freak_> donri: digestive-functors sounds promising…  thanks
10:25:28 <copumpkin> ByronJohnson: yeah, that's what it was designed for
10:25:34 <copumpkin> ByronJohnson: I think the description even says so
10:25:43 <copumpkin> I don't encourage anyone to use it for new libraries
10:25:56 <copumpkin> but if you're stuck with a library that throws exceptions when it shouldn't, it makes your life easier
10:26:07 <donri> @hackage spoon
10:26:07 <lambdabot> http://hackage.haskell.org/package/spoon
10:26:38 <donri> why not Either?
10:26:48 <rwbarton> well zlib's decompress is lazy
10:27:19 <copumpkin> donri: we tried to make ourselves feel better about being non-monotonic by not giving you any information on why it failed
10:27:29 <donri> :)
10:27:31 <copumpkin> even roconnor admitted it wasn't 100% bad
10:27:57 <rwbarton> what % bad is it?
10:28:07 <copumpkin> probably about 93
10:28:39 <ByronJohnson> I've considered forking binary and fixing it
10:29:21 <glguy> copumpkin: your Spoon reminds me of a debugging function I wrote this week: http://fpaste.org/8KMk/
10:30:00 <sjoerd_visscher> BytonJohnson: do you know the cereal package?
10:30:03 <ByronJohnson> It might also be nice to support more strings than just lazy bytestrings, perhaps with ListLike and a "charish" type class for…characters
10:30:04 <copumpkin> yeah :) I could probably add some more exceptions to catch
10:30:13 <ByronJohnson> sjoerd_visscher: Yes, but it only supports strict bytestrings
10:31:02 <rwbarton> there is a reason for that...
10:31:39 <sjoerd_visscher> ByronJohnson: there seem to be lazy functions now
10:32:28 <rwbarton> well I guess the issue is with the laziness of the output, not the laziness of the input
10:36:16 <teneen> Why can't lambdabot get a working pointfree definition of fix?
10:36:32 <teneen> @pl fix f = f (fix f)
10:36:33 <lambdabot> fix = fix (ap id)
10:36:50 <teneen> @pl fix f = let x = f x in
10:36:51 <lambdabot> (line 1, column 7):
10:36:51 <lambdabot> unexpected "="
10:36:51 <lambdabot> expecting variable, "(", operator or end of input
10:36:53 <teneen> @pl fix f = let x = f x in x
10:36:54 <lambdabot> fix = fix id
10:36:56 <rwbarton> @pl id x = id x
10:36:56 <lambdabot> id = fix id
10:36:59 <teneen> both are wrong
10:37:01 <rwbarton> what
10:37:12 <rwbarton> @pl f x = sin x
10:37:12 <lambdabot> f = sin
10:37:20 <rwbarton> oh I see
10:37:39 <rwbarton> @pl id x = x
10:37:40 <lambdabot> id = id
10:38:03 <Eduard_Munteanu> Heh.
10:38:19 <Eduard_Munteanu> @pl id
10:38:20 <lambdabot> id
10:38:26 <Eduard_Munteanu> @pl f (fix f)
10:38:27 <lambdabot> fix f
10:38:46 <Eduard_Munteanu> @pl \x -> x
10:38:47 <lambdabot> id
10:39:13 <kulakowski> @pl \x -> (x,x)
10:39:14 <lambdabot> join (,)
10:39:15 <rwbarton> what's wrong with fix (ap id)?
10:39:36 <Eduard_Munteanu> @pl \fix f -> f (fix f)
10:39:37 <lambdabot> ap id
10:39:46 <rwbarton> > fix (ap id) (0 :)
10:39:48 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:40:31 <rwbarton> @pl \f -> let x = f x in x
10:40:31 <lambdabot> fix
10:40:38 <teneen> anybody knows why lambdabot can't get a pointfree definition for fix?
10:40:54 <rwbarton> ?
10:41:20 <hpc> teneen: try it out yourself
10:41:24 <Eduard_Munteanu> What would you expect?
10:41:48 <rwbarton> what's wrong with fix (ap id)?
10:41:51 <hpc> @pl fix f = f (fix f)
10:41:51 <lambdabot> fix = fix (ap id)
10:42:03 <teneen> hpc: Ok I know it's hard (if not impossible), but then it shouldn't return a wrong answer :)
10:42:06 <rwbarton> @pl myfix f = f (myfix f)
10:42:06 <lambdabot> myfix = fix (ap id)
10:42:10 <hpc> lol
10:42:29 <Eduard_Munteanu> @pl \x -> (x,x) = \x -> x
10:42:29 <rwbarton> @pl myfix f = let x = f x in x
10:42:30 <lambdabot> (line 1, column 13):
10:42:30 <lambdabot> unexpected "="
10:42:30 <lambdabot> expecting variable, "(", operator or end of input
10:42:30 <lambdabot> myfix = fix
10:42:40 <Eduard_Munteanu> Ok, just testing
10:42:53 <rwbarton> @pl fix f = let x = f x in x
10:42:54 <lambdabot> fix = fix id
10:43:04 <rwbarton> apparently it gets confused by that kind of shadowing
10:44:16 <rwbarton> anyways 'fix' is already pointfree isn't it?
10:44:42 <teneen> @rwbarton: no
10:44:43 <lambdabot> Unknown command, try @list
10:44:47 <rwbarton> lambdabot just gets a little confused when you introduce a function name that is the same as one of the basic function it wants to write things in terms of
10:44:55 * rwbarton gives up
10:45:30 <Eduard_Munteanu> Then   f . g   isn't pointfree either.
10:45:33 <teneen> rwbarton: It's a bug, it should give an error message like in other cases then
10:46:13 <rwbarton> so your question is actually "why does lambdabot get confused when you introduce a function name that is the same as one of the basic function it wants to write things in terms of"
10:46:15 <kulakowski> Eduard_Munteanu: of course not, the . is there plain as day :)
10:58:08 <letrec> Could someone explain (or provide a link to some explanation) about why the conversion function from lazy to strict ByteString take a single lazy ByteString but returns a list of strict ByteStrings ?
11:00:22 <hpc> letrec: a strict ByteString is a totally normal char array underneath (iirc)
11:00:35 <hpc> letrec: a lazy ByteString is split into "chunks"
11:00:56 <hpc> letrec: as it so happens, the easiest way to implement these chunks are as strict ByteStrings
11:01:42 <hpc> and since the lazy ByteString is a list of them, it gets implemented as more or less [ByteString]
11:01:43 <rwbarton> basically a lazy ByteString is just a list of strict ByteStrings
11:01:56 <hpc> so the "conversion" is doing zero work
11:02:34 <hpc> in ghc, it might even be safe to convert from [ByteString] to Lazy.ByteString with unsafeCoerce
11:02:55 <hpc> based on how it builds data structures in memory
11:05:12 <rwbarton> if you have some function that consumes strict ByteStrings (toy example: "length") then you might be able to implement it more efficiently on lazy ByteStrings by using the representation as a list of strict ByteStrings (example: "sum . map length") than by converting the lazy ByteString to a strict one by concatenating all the chunks
11:06:14 <rwbarton> I don't know why there isn't also a convenient lazy ByteString to strict ByteString function, though
11:06:46 <rwbarton> maybe it's exactly so that you will learn what a lazy ByteString really is :)
11:07:25 <Saizan> rwbarton: it's because it's an expensive operation that you should avoid
11:07:34 <rwbarton> I mean...
11:07:35 <letrec> hpc: rwbarton: That makes sense, Thx. If I concatenate a list of strict ByteStrings, I basically break the laziness, right?
11:07:42 <rwbarton> if it's the operation you need, it's not "expensive"
11:07:55 <Saizan> need is relative :)
11:11:16 <rwbarton> maybe I want to download a PNG file from a web server, and then do some image analysis on it, possibly my HTTP library will give me a lazy bytestring, and the PNG decoder will want a strict bytestring, so I am going to convert
11:16:38 <keep_learning> :t takeWhileP
11:16:39 <lambdabot> Not in scope: `takeWhileP'
11:17:58 <keep_learning> Parprime: Prelude.takeWhileP: not implemented yet. I am using ghc-7.0.3 so takeWhileP is not implemented yet ?
11:20:12 <keep_learning> while in ghc-7.2.1 , i see only GHC.PArr.PArr  GHC.PArr.[::]. Why all the functions are removed ?
11:23:58 <shadyp\> is that DPH stuff?
11:25:57 <copumpkin> yeah
11:26:11 <keep_learning> shadyp\, yes
11:27:30 <copumpkin> keep_learning: I don't think DPH is supported much at all until the upcoming 7.4 release
11:27:43 <copumpkin> it worked briefly 6.10 and maybe 6.12
11:29:07 <keep_learning> copumpkin, when i compiled it with ghc-7.0.3  , it compiled but i tried to execute it say takeWhileP is not implemented :(
11:29:15 <shadyp\> cool that people use it :)
11:29:26 <copumpkin> keep_learning: which strongly suggests it's not supported ;)
11:30:33 <keep_learning> but it shows lot of function . In ghc7.2.1  nothing except GHC.PArr.PArr  GHC.PArr.[::]
11:30:46 <keep_learning> I am waiting for ghc-7.4
11:47:44 <eggerton> hi. i'm trying to prove that alpha-equivalence of closed lambda terms is undecidable. I've been trying to use the Scott-Curry theorem with A the equivalence class of closed terms equivalent to some 's' and B the set of closed lambda terms setminus A, but I can't show that my sets are closed under beta-equality. Am I going about this completely the wrong way?
11:48:15 <sbi> my nose is bleeding
11:48:49 <alistra> is this a metaphore?
11:52:27 <Saizan> eggerton: alpha-beta-equivalence ?
11:52:30 <shachaf> eggerton: Alpha-equivalence is undecidable?
11:53:16 <alistra> depends if the lambda calculus is typed?
11:53:30 <alistra> not sure :P
11:53:48 <mizu_no_oto> I've got a slight problem with timezones and packets.  In particular, I've got a pcap file.  Part of the header contains the posix timestamp or when it was received, and part of the packet itself is the time it was sent out at in HH:MM:SS format.  The problem is that one of these seems to implicitly have the timezone factored into it, and, since it's a pcap file, the timezone it was recorded...
11:53:50 <mizu_no_oto> ...in isn't neccessarily going to be the one it
11:53:58 <mizu_no_oto> 's processed in
11:54:45 <eggerton> Saizan, shachaf, I mean that there's no term f such that for closed terms s and t,  f s t = true if s \equiv t, false if s \not\equiv t
11:54:51 <eggerton> and yes, untyped lambda calc
11:55:00 <mizu_no_oto> For example, one packet was sent out at 2011-02-16 00:00:03 and received at 09:00:03.00004
11:55:37 <mizu_no_oto> Presumably it didn't take 9 hours to transmit a packet
11:55:38 <eggerton> not sure what "alpha-beta-equivalence" means, but maybe that's what I meant :P
11:56:07 <alistra> eggerton: using alpha-equivalence and beta-reductions in two ways
11:56:08 <Saizan> eggerton: that you allow both alpha and beta rules in the equivalence relation
11:56:15 <alistra> i mean you can reverse a beta reduction i think
11:56:20 <mizu_no_oto> Is there any decent way to handle the timezone problem?
11:56:34 <shachaf> eggerton: Isn't alpha-equivalence just about renaming variables?
11:56:52 <eggerton> oh no I just mean \equiv, as in syntactic equality
11:56:57 <eggerton> shachaf, yes
11:57:11 <Saizan> then it should be decidable
11:57:14 <alistra> so it's decidable
11:57:17 <alistra> for finite terms :D
11:57:45 <Saizan> unless you mean from within the same lambda calculus, then i'm not sure
11:58:03 <eggerton> what term f could possibly determine f s t for any closed terms s and t though?
11:58:07 <eggerton> surely it's not decidable
11:58:56 <alistra> eggerton: since when you have true and false in lambda calculus or do you mean true and false in \xy.x and \xy.y
11:59:02 <shachaf> eggerton: Ah, so you do mean from within the same lambda calculus, like Saizan says.
11:59:19 <eggerton> i mean true = \xy.x and false = \xy.y yes
11:59:23 <Saizan> eggerton: usually such decision procedures take a representation of the terms that's inspectable, not opaque functions
11:59:29 <eggerton> shachaf, yes, same lambda calculus
12:00:29 <shachaf> eggerton: In that case there's only one sort of equivalence you can really hope to look for. :-)
12:00:34 <shachaf> (And it's undecidable.)
12:00:52 <eggerton> shachaf, what one?
12:01:05 <eggerton> I know how to prove beta-equivalence is undecidable (I think)
12:01:11 <eggerton> but not alpha
12:01:28 <shachaf> I mean extensional equality.
12:01:34 <shachaf> If all you have is opaque functions.
12:01:41 <alistra> can you reduce it to beta equivalence?
12:01:49 <alistra> hmm
12:01:52 <alistra> wait :P no
12:01:53 <eggerton> isn't alpha stronger than beta?
12:01:57 <eggerton> :P
12:02:00 <shachaf> As far as opaque functions are concerned, I wouldn't even consider alpha-conversion to be a thing. It's mostly just syntax for expressing a directed graph. :-)
12:02:11 <alistra> yeah
12:02:35 <alistra> you can have de broliesomethingsomething form
12:02:43 <alistra> and you don't have variables, only numbers
12:02:49 <alistra> depending on the depth
12:02:51 <shachaf> De Bruijn, yes.
12:02:54 <alistra> yes
12:02:56 <alistra> this one
12:03:32 <shachaf> The same one as in De Bruijn sequences. :-)
12:03:33 <eggerton> hmm, I'll have a read about that I guess
12:03:37 <shachaf> (And a bunch of other things.)
12:03:47 <shachaf> eggerton: Anyway, it's not completely clear wht you're trying to do.
12:04:09 <shachaf> Are you trying to write a function f :: (a -> b) -> (a -> b) -> Bool?
12:04:14 <shachaf> (Or an untyped equivalent.)
12:04:48 <shachaf> If so, extensionality is the only thing you can even talk about testing for.
12:04:57 <shachaf> (Because the only thing you can do with the function is apply it.)
12:05:16 <alistra> shachaf: treat booleans as lamba terms
12:05:22 <alistra> \xy.x and \xy.y
12:05:43 <alistra> so type Bool = a -> a -> a
12:05:44 <alistra> :P
12:05:45 <shachaf> alistra: What does that have to do with anything?
12:05:59 <eggerton> I'm trying to prove that there's no term f in (untyped) lambda calculus which can distinguish between syntactically distinct closed terms. i.e. there's no f such that, for all s and closed s and t,  f s t =  \xy.x if s \equiv t   and   \xy.y if s \not\equiv t
12:06:02 <saml> is there haskell convention?
12:06:12 <saml> i want to attend convention
12:06:39 <eggerton> and I'm not trying to write anything in Haskell, I asked in #math and they suggested you guys might be able to help
12:06:47 <eggerton> although I do ruv Haskell.
12:06:48 <alistra> haha
12:07:34 <shachaf> eggerton: Syntactically-distinct but alpha-equivalent?
12:08:08 <saml> eggerton, what's closed term?
12:08:22 <alistra> witout free variables?
12:08:43 <shachaf> saml: The Wikipedia page on [[lambda calculus]] will answer that sort of question in more detail than someone in IRC can. :-)
12:08:43 <eggerton> shachaf, what's the distinction? I just mean \equiv_\alpha, taken modulo alpha-equivalence
12:08:49 <Saizan> shachaf: look at it like an approximation of extensionality
12:09:03 <eggerton> saml, the set of all lambda terms s with FV(s) = \emptyset
12:09:05 <saml> use CamelCaseVerboseEnglishStuff not greet letters
12:09:16 <Saizan> shachaf: i.e. this would be a first step to prove that extensionality holds (maybe)
12:09:47 <shachaf> Saizan: Yes, I understand eggerton's question now (I think).
12:10:58 <mateu> hmm, I run cabal install cabal-install to update it and get no error but it doesn't seem to install the newer version
12:12:03 * mateu is trying to debug "The following packages are involved in a dependency cycle buildwrapper-0.2.1"
12:13:38 <dgpratt> mateu: probably not your issue, but I've had a somewhat similar issue that turned out to be that cabal was being loaded from my local profile (and I was trying to update it at a machine-level)
12:14:20 <dgpratt> mateu: anyway, you might try to verify the one you're updating is the one you're running
12:14:21 <mateu> i'm intalling packages as a normal user.
12:16:03 <mm_freak_> hmm, i'm looking for a solution for statically typed routes that goes in both directions and gets along without QQ/TH
12:16:27 <mm_freak_> (and that is not a hell to work with)
12:16:40 <parcs> mm_freak_: boomerang?
12:17:43 <mm_freak_> parcs: needs TH to be nice =/
12:19:08 <mm_freak_> i wonder if there is a nice pure library for that
12:19:55 <eggerton> <shachaf> Are you trying to write a function f :: (a -> b) -> (a -> b) -> Bool?
12:20:00 <mm_freak_> it's very easy to go from path strings to routes, but the way back seems much more difficult
12:20:09 <eggerton> <shachaf> If so, extensionality is the only thing you can even talk about testing for
12:20:14 <mm_freak_> although i'm really thinking of just writing a simple type class for that
12:20:44 <eggerton> shachaf: so if the only thing you can talk about testing for is extensionality, how do you show that? :P
12:21:58 <keep_learning> Could some one suggest me introductory  book fjor parallel algorithms ( some think like when we start learning algorithm then we suggest Introduction to Algorithm )
12:25:09 <hpc> @djinn f :: (a -> b) -> (a -> b) -> Bool
12:25:10 <lambdabot> Cannot parse command
12:25:15 <hpc> @djinn (a -> b) -> (a -> b) -> Bool
12:25:16 <lambdabot> f _ _ = False
12:25:39 <hpc> i think you need some constraints on a and b
12:26:28 <Saizan> that type was just an analogy, we're talking of untyped lc anyhow
12:26:37 <hpc> oh
12:28:45 <eggerton> I was thinking maybe Böhm's theorem had something to do with it
12:28:48 <Saizan> the original question is how to show that you can't have a term f in the ulc that returns true if its two arguments are \alpha-equivalent and false otherwise
12:32:52 <eggerton> well "syntactically equivalent" not \alpha-equivalent
12:32:57 <Clint> where did hpaste go?
12:33:07 <eggerton> i assume they mean the same?
12:34:00 <Saizan> eggerton: let's use ~ for alpha-beta-equivalence, then x ~ y implies x and y evaluate to the same, but you can also show that if x ~ y then f x ~ f y
12:34:18 <Saizan> eggerton: for every f x and y
12:36:33 <Saizan> eggerton: now if we call your term that decides syntactic equivalence 'd', we know that d x x should return true, but d x y should also return true for every y ~ x, now we just have to find two x and y such that x ~ y but that aren't syntactically equivalent to derive a contradiction
12:36:57 <Saizan> eggerton: e.g. (\x -> x) and (\x -> x) (\x -> x)
12:37:26 <tigger__> hi there. maybe someone could help me out with this one. I have a list of functions mylist: type [a -> b -> Maybe c], and I want to apply arguments arg1 :: a, and arg2 :: b. I am doing the following (fmap (\x -> x b) $ fmap (\x -> x a) $ mylist)
12:37:38 <tigger__> I feel like there has to be an easier way
12:37:54 <tigger__> sorry shoudl be
12:38:15 <tigger__> (fmap (\x -> x arg2) $ fmap (\x -> x arg1) $ mylist)
12:38:42 <byorgey> tigger__: well, for starters you could do  fmap (\x -> x arg1 arg2) mylist
12:39:25 <tigger__> lol thanks... wow im a noob
12:39:36 <byorgey> well, I said 'for starters' but actually that's probably as good as it's going to get
12:39:59 <eggerton> Saizan, i don't understand how (\x -> x) and (\x -> x)(\x -> x) is an example?
12:40:13 <tigger__> I think I recall somewhere, but is there a library function to reduce a list of [Maybe a] to either the first Maybe or Nothing?
12:40:36 <Saizan> eggerton: they are alpha-beta-equivalent (they both reduce to (\x -> x)) but not syntactically equivalent
12:41:00 <rwbarton> @hoogle msum
12:41:00 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
12:41:01 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
12:41:08 <byorgey> tigger__: since that is the MonadPlus semantics for Maybe, you can use msum
12:41:33 <tigger__> byorgey: rite, thanks for the help
12:41:38 <byorgey> sure
12:42:40 <eggerton> Saizan, the problem is introducing the beta 'element' to the question
12:42:44 <Saizan> eggerton: d (\ x -> x) (\x -> x) should return true; and d (\x -> x) ((\x -> x) (\x -> x)) should return false
12:43:10 <eggerton> yes
12:43:33 <Saizan> eggerton: but we know that they should return the same because of how beta-reduction works, which is how we evaluate lambda terms in general, so you have a contradiction
12:44:02 <shadyp\> how does one contribute to the haskell community? work on GHC?
12:44:09 <Saizan> even if d is not supposed to care about beta-reduction it's still a LC program, so we evaluate it with beta-reduction
12:44:26 <byorgey> shadyp\: there are lots of ways.
12:45:30 <Saizan> eggerton: i should give a proof of "forall f x y, (x ~ y) -> (f x ~ f y)" to complete my argument, but i don't feel like doing so on irc :)
12:45:35 <byorgey> shadyp\: make a library that does something useful and put it on Hackage.  Help work on some existing project.  Help improve documentation for existing packages, or improve explanations of things on the Haskell wiki.  Respond to people's questions on the mailing lists or StackOverflow.  Explain things in blog posts.
12:46:28 <eggerton> Saizan, hmm ok thanks, i see
12:47:02 <byorgey> shadyp\: working on GHC is one particular niche way to contribute, but the vast majority of people who contribute to the community have never worked on GHC.
12:47:21 <eggerton> Saizan, I'm going to sit down with it and mull it over :)
12:48:24 <Saizan> actually, i think forall f x y, (x ~ y) -> (f x ~ f y) is almost by definition, since you want ~ to be congruence on lambda terms
12:48:48 <jessopher> help me with my project, its a mess
12:49:02 <Saizan> *a congruence
12:49:11 <shadyp\> byorgey: thanks.
12:50:37 <eggerton> Saizan, btw the last page of http://api.cld.me/1G1s132G453k162B090q/download/derp.pdf is how i was going about it
12:50:39 <Saizan> i.e. in the definition of ~ you'll find a rule M1 ~ M2 , N1 ~ N2 => (M1 N1) ~ (M2 N2)
12:51:22 <eggerton> Saizan, does ~ have a 'proper' name?
12:51:28 <eggerton> in the literature
12:51:51 <Saizan> alpha-beta-equivalence
12:52:00 <eggerton> Saizan, ok thanks
12:53:42 <shadyp\> byorgey: are you aware of any TODO-lists or similar for missing packages or GHC features? it's kinda hard to figure what packages are missing, especially when you're not into advanced math.
12:54:22 <Saizan> eggerton: i still wonder if this is really what you want to prove, given your pdf :)
12:54:27 <ezyang> shadyp\: In my experience, things tend to work better if you start off scratching your own itch.
12:54:43 <byorgey> shadyp\: there's the Haskell proposals subreddit (ass has empty, shift, read, write operations
12:54:46 <byorgey> (11:38) <ClaudiusMaximus> possibly over-generic, but i'll see how it goes
12:54:50 <byorgey> whoops
12:55:05 <byorgey> http://www.reddit.com/r/haskell_proposals/
12:55:22 <eggerton> Saizan: from the pdf, I basically want to replace the =_\beta with \equiv
12:55:33 <byorgey> shadyp\: if you're interested in contributing to a specific project like GHC or Haddock or cabal, take a look at their bug trackers
12:55:46 <shadyp\> okay, thanks
12:56:12 <byorgey> shadyp\: but I agree with ezyang.  What are you interested in? What excites you? Find a project doing that, and contribute.  Or, if none exists, write your own.
12:57:18 <eggerton> Saizan: on the last page, I was letting A be the set of closed terms \equiv to x and B the set of closed terms not \equiv to x. But I couldn't show that the sets are closed under \beta-reduction (in fact I don't think they are) :(
12:57:54 * byorgey goes back to writing a grant proposal. sigh.
12:58:26 <rwbarton> eggerton: but that notion of decidability is not what you asked about at all
12:58:43 <eggerton> rwbarton: how so?
13:04:28 <rwbarton> eggerton: what these notes are talking about is not actually passing the terms s and t to your decision procedure, but rather representations of those terms (as a Godel number encoded as a Church numeral)
13:06:42 <Clint> how can i do http://paste.debian.net/148757/ more sanely?
13:07:28 <eggerton> rwbarton, are they not equivalent?
13:09:06 <eggerton> rwbarton, I suppose I want to do what is in the pdf
13:09:51 <roconnor> Clint: http://www.haskell.org/ghc/docs/latest/html/libraries/pretty-1.1.0.0/Text-PrettyPrint-HughesPJ.html might have useful stuff (I've never used it)
13:10:05 <roconnor> Clint: for example sizedText looks useful
13:11:10 <Clint> roconnor: thanks
13:12:12 <pshrmn> Is there a better way to convert a Char to Word8? charToWord8 c = fromIntegral $ fromEnum c
13:12:16 <roconnor> I'd probably use chunk <http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v:chunk> instead of working mod 7
13:12:21 <roconnor> Clint: ^^
13:13:10 * Clint nods.
13:14:36 <roconnor> Clint: I'd probably use hpaste instead of paste.debian
13:14:39 <roconnor> :P
13:15:03 <Clint> roconnor: i tried that but i keep getting Bad Gateway
13:15:17 <roconnor> :O
13:15:52 <Clint> see also 15:59 < Clint> where did hpaste go?
13:26:37 <parcs> pshrmn: fromIntegral . ord
13:29:44 <joe9>  /ws 19
13:38:34 <gavri1> I get the following error when trying to start the yesod server. how should this be fixed?
13:38:41 <gavri1> `Unique' has no constructors (-XEmptyDataDecls permits this)
13:41:41 <mkscrg> anybody know of good resources for learning netwire?
13:42:07 <koral> hi, will libsoup get a Haskell binding any time soon ?
13:43:02 <byorgey> koral: it will if you write one.
13:44:51 <koral> byorgey: I guess this is a no :)
13:47:03 <ddarius> I don't think I'd be interested in using a libsoup binding even if I were to write a program targetted for the Gnome environment.
13:49:09 <byorgey> mkscrg: the author of netwire hangs out in here as mm_freak
13:51:01 <mkscrg> byorgey: thanks for the heads up
13:53:32 <parcs> mkscrg: are you familiar with arrows yet?
13:56:20 <shadyp\> why are they called arrows?
13:57:41 <Jafet> Because they are arrows.
13:57:54 <Jafet> Or based on category-theoretic arrows.
13:58:56 <Jafet> @instances Arrow
13:58:58 <lambdabot> (->), Kleisli m
13:59:04 <koral> ddarius: I quite agree, but when you talk to webkit, it only speaks libsoup so, not much of a choice...
14:02:05 <mkscrg> parcs: yeah. i'm trying to figure out whether netwire is a good fit for my problem. basically i'm trying to elegantly model a branching asynchronous workflow
14:02:27 <tsousa> in this code http://paste.pocoo.org/show/518588/ a and b is applyed the function f ?
14:03:00 <donri> f is a functor, not a function
14:03:07 <donri> (a -> b) is a function
14:03:17 <jessopher> plus, 'arrow' doesn't sound like some kind of transcendental monster.
14:03:23 <donri> f a is a functor of a's, f b a functor of b's
14:03:36 <aninhumer> tsousa: a and b are the type parameters of the functor f
14:03:45 <donri> fmap applies a function (a -> b) to a functor f a to produce a functor f b
14:03:49 <tsousa> aninhumer, i am not getting it
14:04:15 <rwbarton> a functor is a type constructor like "Maybe" or "Either Int"
14:04:22 <rwbarton> that is an instance of this class
14:04:22 <donri> list is a functor, in that case you can think of "f" as [] aka. [a]
14:04:26 <aninhumer> tsousa: for example the f could be Maybe, a coukl
14:04:28 <aninhumer> whoops
14:04:34 <mkscrg> say you have an input node A that needs to do something fast (like return a confirmation response to the user), as well as some number of other nodes B, C, D … that have lower priority and take input from A. what's the "right" way to model this kind of concurrency in haskell?
14:05:41 <rwbarton> "f a" is the application of the constructor f to the type a
14:06:43 <tsousa> Haskell is so hard, men
14:06:53 <incluye> i know it doesn't even make sense
14:07:26 <mkscrg> any takers?
14:07:51 <donri> tsousa: do you grok normal map? [a] is just sugar for something like ([] a); in this case "f" is the []
14:07:59 <aninhumer> tsousa: a Functor is anything that can be mapped over, the f, a and b are placeholders which describe the pattern of such a thing
14:08:13 <tsousa> yes
14:08:31 <aninhumer> :t map
14:08:32 <donri> @where LYAH
14:08:32 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:08:33 <lambdabot> http://www.learnyouahaskell.com/
14:08:37 <aninhumer> :t fmap
14:08:38 <donri> did you read ^^^ on functors?
14:08:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:09:09 <tsousa> donri, yes
14:10:30 <tsousa> aninhumer, what i dont understand is that f a and f b are? what they will create?
14:11:15 <rwbarton> "f a" is the application of the constructor f to the type a
14:11:19 <rwbarton> it is some new type
14:11:37 <rwbarton> for example if your functor f is Maybe
14:11:41 <ddarius> jessopher: We could have called them indexed closed Freyd categories or closed kappa categories.
14:11:51 <rwbarton> then "a" could be Bool, and that type "f a" would be Maybe Bool
14:11:56 <rwbarton> that's all there is to it
14:12:09 <aninhumer> tsousa: the class describes the pattern of the types, and instances fill in what some of the values are
14:12:19 <tsousa> humm
14:12:21 <tsousa> nice
14:12:35 <aninhumer> for example, for the Functor Maybe, fmap :: (a -> b) -> Maybe a -> Maybe b
14:12:37 <tsousa> now i get
14:12:42 <tsousa> it create a new type
14:12:51 <tsousa> and map also create a new type?
14:13:23 <miden> hello!! Can someone explain me why unsafePerformIO (newIORef [ ]) is s troublesome??
14:13:41 <ddarius> miden: Define "troublesome."
14:13:53 <miden> is not good :D
14:14:04 <ddarius> miden: It has unsafePerformIO in it.
14:14:26 <miden> yes but why ?
14:14:40 <ddarius> Why does it have unsafePerformIO in it?
14:15:30 <miden> it's a question and i cannot understand the meaning of unsafePerformIO
14:15:48 <shachaf> miden: No one can.
14:15:53 <shachaf> unsafePerformIO is a mysterious function.
14:16:15 <shachaf> miden: Anyway, if you don't understand what unsafePerformIO does, you oughtn't use it.
14:16:23 <aninhumer> miden: it lets you break the guarantees that the Haskell IO system normally provides
14:17:20 <Patrek> I want to write a overloaded function, one for types that are member of Eq and one for types that are not?
14:17:23 <miden> like the garantee of the sequencial execution?
14:17:47 <aninhumer> miden: which is generally a bad idea unless you're absolutely sure you need to do it, and you nearly always don't
14:18:06 <sbi> shachaf, if it worked that way i wouldn't have had sex til i was 30
14:18:30 <aninhumer> miden: well the main thing it breaks is the guarantee that pure functions will not do IO
14:18:36 <exFalso> @hoogle t1 m a -> t1 (t2 m) a
14:18:38 <lambdabot> No results found
14:18:47 <donri> unsafePerformSexualActs
14:19:21 <aninhumer> miden: but yes, uncertain evaluation order is also a potential problem
14:19:25 <rwbarton> miden: it also makes it very hard to know when or whether or how many times your IO action will be executed
14:19:26 <roconnor> Patrek: that is very difficult and would be generally be bad from if you manage to hack your way into haskell accepting that.
14:19:32 <shadyp\> unsafePutDickInCrazy
14:19:49 <sbi> stuffInFirstHole
14:20:04 <donri> stuffInOnlyHole
14:20:17 <donri> You know what I mean.
14:20:18 <miden> what about the newIORef ... u have to define it somehow in the IO block
14:20:19 <exFalso> is there a way to do (t1 m a -> t1 (t2 m) a) without explicit unlifting?
14:21:01 <aavogt> roconnor: can it even be done?
14:21:12 <shapr> error "inappropriate references"
14:21:20 <sbi> donri, now unsafe has a whole new meaning
14:21:26 <roconnor> aavogt: probably with all the crazy UnsafeFlexiableIncoherentUnsoundInstances
14:21:27 <shapr> Please move all sexual references to #haskell-blah
14:21:37 <aavogt> roconnor: there's this http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap but you have to basically write up Eq and all of it's instances to be able to choose whether a type is in that class
14:21:41 <donri> sbi: are you absolutely hiv positive?
14:21:58 <shapr> donri, sbi : Please move all sexual references to #haskell-blah
14:22:33 <shapr> While the channel was originally created due to an excess of unicycling discussion here, sexual references are equally distracting.
14:22:35 <EvanR-work> please move all off topic stuff to haskell-blah, rather than declaring your own prudish immaturity to be global channel policy
14:22:48 <shachaf> #haskell-/dev/null is also a good place.
14:23:20 <Patrek> aavogt: that page is rather old, does constraint kind extension help?
14:23:22 <aavogt> Patrek: if you have specific types in mind, rather than "all types in Eq" that is easy to do with -XOverlappingInstances
14:23:53 <aavogt> maybe it does. I have not looked into that one
14:26:40 <Patrek> aavogt: lets say I have a list of types, for them I need one common implementation of the function and for the rest another
14:27:19 <aavogt> that is covered by -XOverlappingInstances
14:27:39 <aavogt> in that you have one instance for every type in your list of types
14:28:07 <aavogt> and a more general instance which overlaps all those other instances whose implementation is your other
14:28:12 <aavogt> other function
14:29:55 <aavogt> you should be aware that these extensions make the choice of instances a bit less obvious
14:30:06 <aavogt> (ex. adding imports can change the behavior of a program)
14:34:45 <Patrek> then I have duplicated code, for example: class Test (a-> D1) where ...  and class Test (a->b) where ... and class Test (a->D2) where ...
14:34:53 <Patrek> D1 and D2 are the types in the list
14:36:04 <Patrek> ah, I meant: instance Test (a-> D1) where ...  and instance Test (a->b) where ... and instance Test (a->D2) where ...
14:37:36 <Patrek> if it was possible to write instance List b => Test (a -> b) where ... and instance Test (a -> b) where ..., then there would be no duplicated code
14:41:32 <dolio> GHC has no extensions for that kind of thing.
14:44:54 <Saizan> you could do it with a bit of boilerplate by defining a IsSpecialCase t bool | t -> bool class and then have an instance like "instance (IsSpecialCase b bool, Test' a b bool) => Test (a -> b) where" but you also have to define an write two instances for the class Test', so it might be worse than your original duplication :)
14:45:28 <roconnor> Patrek: The show class has a trick to make a "special instace" for lists
14:45:53 <Patrek> Hlist paper?
14:46:01 <roconnor> no no
14:46:07 <roconnor> the standare Haskell 98 show class
14:46:11 <roconnor> *standard
14:46:24 <tacoman> what exactly does <- do? I've seen it used in both list comprehensions and for binding values from I/O
14:46:28 <roconnor> I don't know, maybe it isn't the same as your problem
14:46:42 <roconnor> But recall that Strings are shown in a different way from ordinary lists
14:46:55 <roconnor> the Show class does a bit of cleverness to do this
14:47:13 <Patrek> I see
14:47:31 <shachaf> "cleverness" :-(
14:47:33 <roconnor> anyhow, it sounds vaguely like your kind of problem
14:47:36 <mm_freak_> tacoman: given "x <- c", where c is of type 'm a', x is of type 'a' for some monad m
14:48:05 <mm_freak_> tacoman: example, "line <- getLine" in IO, where getLine :: IO String and line :: String
14:48:27 <tacoman> ahhh. I have yet to actually get through monads, so that's probably why I hadn't hit it
14:48:27 <mm_freak_> roughly speaking, <- allows you to give monadic results names
14:48:30 <tacoman> thanks!
14:48:45 <mm_freak_> well, for your two examples IO and [] are the monads in question
14:48:54 <rwbarton> when you do, you will see that list comprehension syntax is almost the same as do syntax actually
14:48:59 <Patrek> is it possible to somehow lift a constraint to a type function, ex: Eq a => ...  to data family Eq x => Fun x = CTrue  and data  family x = CFalse
14:49:04 <mm_freak_> 'x <- xs', where xs :: [] a and x :: a
14:49:19 <mm_freak_> "[] a" is just a different way to say [a]
14:49:50 <tacoman> 3 minutes in #haskell and I learn more than I do in a week of class >_>
14:50:12 <mm_freak_> =)
14:50:43 <shachaf> tacoman: You can probably ignore the word "monad" for now.
14:50:55 <hpc> @where lyah
14:50:56 <lambdabot> http://www.learnyouahaskell.com/
14:50:59 <hpc> tacoman: ^
14:51:00 <shachaf> tacoman: It happens to be an abstraction that unifies the <- in lsit comprehensions with the <- in IO and the <- in a few other places.
14:51:20 <Patrek> again I meant Eq a => ...  to data family Fun x    and  data instance (Eq x) => Fun x = CTrue  and data  instance Fun x = CFalse	
14:51:26 <shachaf> tacoman: But you can just treat each of those as its own thing perfectly well, and figure out the abstraction later when you have a better understanding of concrete cases.
14:51:29 <tacoman> yeah, I've been going through learn you a haskell, I'm *almost* to monads. class has essentially been giving me a very bare bones look at the language
14:51:46 <parcs> Patrek: nope
14:51:48 <tacoman> I've seen a lot of the other cases, it just suddenly bothered me that I was seeing that syntax in two different cases
14:51:57 <shachaf> tacoman: People make a bigger deal about "monads" when they should.
14:52:04 <shachaf> tacoman: See section 8 of the FAQ.
14:52:06 <shachaf> @where faq
14:52:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:52:32 <tacoman> good to know. I'll probably still end up going through it just out of curiosity
14:52:46 <mm_freak_> tacoman: whenever you see "<-", just think of the "(x :: a) <- (getX :: m a)" pattern
14:52:58 <mm_freak_> and as a beginner you can probably replace "m" by "IO" most of the time
14:53:07 <shachaf> tacoman: OK, but it might be a good idea to read the FAQ first. :-)
14:53:11 <tacoman> I shall
14:53:12 <Philippa> tacoman: monads are a typeclass, hence the two different cases
14:53:30 <shachaf> tacoman: "Monad" just describes a generic API that many specific things happen to implement.
14:53:54 <shachaf> Ooh, an opportunity for pedantry! Monad is a type class; monads aren't. :-)
14:54:06 <shachaf> Actually that pedantry is flawed.
14:54:08 <sully> I feel like every single time I look at this channel, somebody is trying to explain monads to a newbie
14:54:12 <Patrek> just remember Monad = programmable semicolon:)
14:54:25 <shachaf> No, don't remember that. :-(
14:54:28 <tacoman> this all makes the name of XMonad all the more amusing. well, I'll put them on the backburner for the moment
14:54:35 <mm_freak_> sully: it happens a lot lately, yes
14:54:43 <mm_freak_> but it's rather the exception
14:55:08 <sully> (or specifically, some people are telling them not to worry about monads, some people are offering unhelpful quips, and probably multiple people are explaining in very different ways)
14:55:31 <mm_freak_> Patrek: with that intuition you can explain to a C/C++ programmer, "why monads?", but not really what they are and how they work
14:55:49 <mm_freak_> so to someone actually already willing to learn haskell, i wouldn't give that intuition
14:57:31 <copumpkin> @tell kfish this looks nice for your javascript front-end http://bits.shutterstock.com/?p=103
14:57:32 <lambdabot> Consider it noted.
14:58:05 <mm_freak_> btw javascript…  has anyone made an effort lately to compile haskell or a similar language to javascript?
14:58:34 <MostAwesomeDude> Ugh, JS. :c
14:58:38 <shachaf> mm_freak_: There have been various.
14:58:43 <mm_freak_> (not haxe, but a more functional language)
14:58:46 <ddarius> copumpkin: Looks like a blank page to me.
14:59:06 <Saizan> ddarius: maybe that's the suggestion
14:59:10 <mm_freak_> shachaf: anything usable?  can be experimental, but shouldn't be in pre-pre-pre-alpha state =)
14:59:22 <donri> mm_freak_: http://chrisdone.com/posts/2011-08-20-ghcjs.html
14:59:32 <copumpkin> ddarius: works here
15:01:10 <mm_freak_> donri: great, thanks
15:02:01 <ddarius> copumpkin: For some reason all the content is commented out.
15:03:18 <copumpkin> ddarius: weird
15:05:56 <ddarius> Suffice to say, I'm less than impressed by their web "expertise."
15:06:40 * ddarius is hungry.
15:07:09 <shachaf> ddarius: I recommend Ginseng Korean BBQ.
15:07:49 * ddarius tries to remember the last time he had Korean BBQ.
15:08:28 <shachaf> Long ago, far too long.
15:09:08 <ddarius> I did have some Korean food in Shin-Okubo a few years ago, but I wouldn't describe it as Korean BBQ, though it wasn't that far from it.
15:10:06 <shachaf> ddarius: There's a good place in Mountain View, CA.
15:12:01 <dgpratt> I recommend anything besides Ethiopian food
15:12:35 <shachaf> Yes, as long as there's Ethiopian food next to you, anything will be good.
15:13:40 <copumpkin> I love ethiopian food
15:13:53 <dgpratt> copumpkin: you would :-)
15:15:18 * ddarius doesn't think he's had Ethiopian food.
15:15:35 <ville> no one has - hence the hunger.
15:15:37 <dgpratt> ddarius: probably not; you'd remember :)
15:16:26 <dgpratt> ville: an inaccurate stereotype, but funny nonetheless
15:18:07 <dolio> Find some Sri Lankan food.
15:22:05 * hpaste is back up (now being monitored by angel).
15:29:08 <thoughtpolice> copumpkin: that rickshaw lib does look neato. i've been toying around with the idea of moving hp2any etc to use a web interface and i wanted something to do realtime plotting
15:29:13 <thoughtpolice> that looks like it might fit the bill perfectly
15:29:30 <thoughtpolice> (it could also be used for eventlogs, too)
15:29:35 <copumpkin> thoughtpolice: yeah, assuming they get over their html issues that ddarius encountered :)
15:34:57 <dgpratt> though I've finished the exercise, I'm still thinking on the "20 Intermediate Haskell Exercises"...
15:35:25 <dgpratt> particularly the implementation of banana2, banana3, banana4...
15:35:35 <hpaste> dgpratt pasted “misty bananas” at http://hpaste.org/55054
15:36:51 <shachaf> dgpratt: What about them?
15:37:00 <dgpratt> for one thing, supposedly one gets a bonus for using apple + furry' to implement banana2, but that's really the only way I could think to do it (of course I didn't think much further about it once I saw the solution)
15:37:27 <dgpratt> likewise for using apple + banana to implement the others
15:38:27 <Axman6> o/ dgpratt how goes the bananas?
15:38:32 <dgpratt> also, I really wish I could internalize the obvious pattern that appears in these functions; I feel like my skill with Haskell would increase significantly
15:39:32 <dgpratt> Axman6: I finished it, but I'm still thinking about it; thanks again for your help, by the way; I doubt I would've gotten through otherwise
15:40:16 <Axman6> no worries. I remember that was probably one of the most helpful single exercises I did when learning haskell, and i remember it being pretty difficult
15:40:30 <shachaf> dgpratt: You can use banana and unicorn to do it.
15:40:32 <gavri1> what do I commit to source control for a virthualenved project? I'd like to only commit metadata about the virtual environment and not everything inside .virthualenv
15:40:44 <shachaf> dgpratt: Assuming I'm getting the names right.
15:41:16 <Axman6> was apple :: m (a -> b) -> m a -> m b?
15:41:19 <parcs> gavri1: what
15:41:29 <Axman6> gavri1: wrong channel?
15:41:41 <dgpratt> shachaf: yeah, it seems if I expand the definition of apple and then furry', that's what I'd end up with
15:41:42 <gavri1> I'm using virthualenv
15:41:59 <Axman6> never heard of virtualenv
15:42:01 <dgpratt> Axman6: apple :: (Misty m) => m a -> m (a -> b) -> m b
15:42:10 <shachaf> dgpratt: Ah, there's a missing type class in between Furry and Misty. :-)
15:42:14 <Axman6> ah
15:42:15 <gavri1> it's a lot like capri or cabal-dev I guess
15:42:37 <gavri1> http://hackage.haskell.org/package/virthualenv-0.2
15:42:38 <parcs> gavri1: isn't virtualenv python-specific
15:42:44 <parcs> oh, virthualenv
15:42:51 <Axman6> shachaf: well no, it' possible with Misty
15:43:29 <ddarius> Apply?
15:43:33 <parcs> that's an unfortunate name.. the h is hard to catch
15:43:33 <dgpratt> shachaf: you mean between Fluffy and Misty?
15:43:41 <ddarius> Hmm, that didn't turn out the way I intended it.
15:43:50 <gavri1> I don't know what here is the metadata file I could commit. guess I'll dig around a bit
15:44:58 * KirinDave sighs
15:45:09 <KirinDave> Is anyone ever going to cut a good version of cabal-dev for 7.2.*?
15:45:40 <parcs> KirinDave: what is the problem with cabal-dev and 7.2?
15:45:51 <KirinDave> I still get the cabal: dist/src/sdist.-6488/HSH-2.0.3: does not exist bug
15:46:04 <KirinDave> err, cabal-install, sorry!
15:46:11 <KirinDave> I guess it's cabal-dev too.
15:46:13 <_oz> hi all. quick question. I use the package readline, and want to try haskeline now. It is a very simple application so the only two functions I use from readline are "addHistory" and "readline". Is there a readline compatibility interface for haskeline that I can use as a drop-in replacement for these two functions?
15:46:20 <KirinDave> One or the other has to be fix'd.
15:47:05 <dgpratt> Misty ~= Monad, I'm quite sure, and Fluffy ~= Functor, right? Ah, typeclassopedia tells me maybe you mean Applicative
15:47:23 <parcs> KirinDave: is downgrading to 7.0.4 an option?
15:47:46 <KirinDave> parcs: Of ghc?
15:47:52 <parcs> yeah
15:47:56 <KirinDave> parcs: outrageous.
15:48:19 <thoughtpolice> KirinDave: i've never seen that bug and i use cabal-dev w/ ghc 7.2 daily. is there a ticket on it somewhere? what reproduces it?
15:48:30 <KirinDave> thoughtpolice: add-source
15:48:32 <thoughtpolice> also, OS X? linux?
15:48:33 <parcs> 7.2 doesn't offer much, and it actually has some compilation time regressions
15:48:36 <KirinDave> thoughtpolice: OSX.
15:49:29 <parcs> why is downgrading an outrageous suggestion?
15:50:30 <thoughtpolice> parcs: well, it does add better generics (-XGenerics,) equality superclasses, and monad comprehensions among other things (also compiler plugins, but nobody has quite yet used them besides max and i.) overall 7.2 is considered fairly experimental however
15:50:47 <KirinDave> I have code that uses monad comprehensions.
15:50:49 <KirinDave> I like them.
15:50:51 <KirinDave> But also
15:50:54 <thoughtpolice> (don't use casMutVar# in 7.2 for example, because it's totally borked)
15:50:56 <KirinDave> parcs: how long is reasonable to wait.
15:51:00 <KirinDave> thoughtpolice: Indeed.
15:51:49 <thoughtpolice> KirinDave: i think the date for 7.4 has been pushed back into early janurary, IIRC. did you submit a bug to the cabal-dev guys (i don't have 7.2 on this os x machine but i can try to reproduce on linux)
15:52:10 <dylukes> oh? we have monad comprehensions back?
15:52:18 <thoughtpolice> yep
15:52:41 <dylukes> What's another good monad to use them with, btw?
15:52:55 <dylukes> I guess a database query... perhaps.
15:53:23 <KirinDave> dylukes: ALL OF THE MONADS :0
15:53:40 <thoughtpolice> the implementors original motivation for bringing monad comprehensions back was related to databases, actually. they wanted it for DSH (which is a library that kind of makes an external database a coprocessor for haskell code)
15:53:52 <thoughtpolice> @hackage DSH
15:53:53 <dylukes> I guess it would work nicely in parser combinators too.
15:53:53 <lambdabot> http://hackage.haskell.org/package/DSH
15:54:19 <KirinDave> Yeah
15:54:32 <KirinDave> Not to mention stream parsing...
15:54:45 <KirinDave> Pretty sure that could be a whacky way to chain iteratees. :)
15:54:52 <dylukes> >_<
15:55:01 <KirinDave> dylukes: Whaaat? :D
15:55:14 <KirinDave> Actually, that might be pretty good.
15:55:17 <KirinDave> I'd have to play with it and see.
15:55:30 <shachaf> dgpratt: Yes.
15:55:39 <KirinDave> Anyways, I was under the impression that 7.2.2 got the whitehole fix?
15:55:47 <KirinDave> This is what someone told me in -blah, anyways.
15:56:01 <dylukes> whiteholes?
15:56:07 <JoeyA> My problem with calling Haskell a "declarative language" is that the principal methods of abstraction only work in the domain of Haskell values.  I suppose you can use GADTs and such to type-check operations on types extrinsic to Haskell, but you don't get to use lambdas and cases.
15:56:48 <dylukes> huh?
15:56:56 <shachaf> dgpratt: Nowadays we have something that looks more or less like class Fluffy f where { furry :: (a -> b) -> f a -> f b }; class Fluffy f => Appley f where { unicorn :: a -> f a; apple :: f (a -> b) -> f a -> f b }; class Appley m => Misty m where { banana :: (a -> m b) -> m a -> m b }
15:56:58 <JoeyA> I'm just babbling.
15:57:04 <KirinDave> dylukes: There is a pretty nasty bug with the parallel runtime and performUnsafeIO
15:57:18 <KirinDave> dylukes: I think even 7.0.* has it if I recall correctly.
15:57:21 <dylukes> Oh, is it the one kmc wrote the blog post on?
15:57:23 <KirinDave> yeah
15:57:26 <dylukes> mmk.
15:57:36 <thoughtpolice> KirinDave: kmc's bug fix will go into 7.4
15:57:42 <KirinDave> I had been told that 7.2.2 had a fix because my project is actually provoking that bug in 7.2.1
15:58:04 <thoughtpolice> the release notes for 7.2.2 don't mention the ticket number that the bug was for, lemme see if i can find it
15:58:05 <KirinDave> thoughtpolice: So do I downgrade to 7.0 and rewrite the parts of my code that use -XGeneric?
15:58:12 <thoughtpolice> KirinDave: it went all the way to 6.12.3
15:58:14 <KirinDave> Doesn't 7.0.* have the bug too? :(
15:58:15 <KirinDave> Efff.
15:58:35 <thoughtpolice> KirinDave: kmc has a workaround package called 'global-lock' that is a good stop-gap, however
15:58:49 <thoughtpolice> it works by storing a global mvar inside a stableptr on the C side, so GHC can't optimize around it in any way
15:59:10 <thoughtpolice> KirinDave: this is the actual bug - http://hackage.haskell.org/trac/ghc/ticket/5558
16:00:26 <thoughtpolice> it's rather unfortunate that such a common idiom was broken for so long, however.
16:00:38 <shachaf> thoughtpolice: Wasn't it just broken in GHC 7?
16:00:40 <thoughtpolice> it's one of those kinds of things you can never really be sure is there, or if you've ever totally fixed it
16:00:44 <dgpratt> shachaf: ah, interesting
16:00:45 <KirinDave> shachaf: No.
16:01:03 <thoughtpolice> shachaf: no, reports on the ticket say it's reproducible in 6.12.1
16:01:07 <donri> in essence, what is the difference between TVar and TMVar?
16:01:14 <shachaf> Ah.
16:01:21 <shachaf> I thought it was introduced fairly recently, at any rate.
16:01:31 <shachaf> I guess even 6.12-7.4 is quite a long period of time, though. :-)
16:01:36 <thoughtpolice> like i said, fairly unfortunate it's been broken for seemingly so long. :(
16:01:41 <thoughtpolice> it is a long time in haskell land, yeah
16:01:49 <shachaf> donri: TMVar is implemented as a TVar of a Maybe, I think.
16:03:01 <shachaf> donri: Do you know what an MVar is?
16:03:15 <donri> perhaps not as good as i thought i did
16:03:20 <thoughtpolice> KirinDave: but yes, http://hackage.haskell.org/package/global-lock should be a decent stop gap. you do need a version of GCC that's been released in like the last, uh, 5-7 years or something, but i imagine that won't be a problem :)
16:04:33 <KirinDave> So the official recommendation is use ghc 7.0.* and global_lock
16:04:40 <thoughtpolice> also on the note of kmc, i want him back moar :(
16:04:50 <thoughtpolice> preflex: xseen kmc
16:04:50 <preflex>  kmc was last seen on freenode/#haskell 3 days, 6 hours, 3 minutes and 12 seconds ago, saying: or whatever it is that you want
16:04:51 * ddarius isn't sure why people misrefer to unsafePerformIO as performUnsafeIO.
16:04:52 <shachaf> FVO "official" that are "thoughtpolice", yes. :-)
16:05:01 <thoughtpolice> ^^
16:05:20 <shachaf> thoughtpolice: He grew tired of the monad jokes in #haskell.
16:05:24 <shachaf> I can't say I blame him.
16:05:29 <dgpratt> shachaf: part of the challenge of that exercise for me was constructing (what I think of as) more primitive functions out of the...less primitive functions
16:05:55 <JoeyA> ddarius: The same reason people say Foxfire, maybe?
16:05:59 <shachaf> dgpratt: Well, the modification I made doesn't take that challenge away. :-)
16:06:35 <thoughtpolice> shachaf: heh, can't say i'd blame him either
16:08:12 <ddarius> @src join
16:08:13 <lambdabot> join x =  x >>= id
16:08:28 <ion> @src (>>=)
16:08:29 <lambdabot> Source not found. I am sorry.
16:08:37 <ion> @src (=<<)
16:08:38 <lambdabot> f =<< x = x >>= f
16:08:45 <ion> Sadly
16:09:08 <shachaf> dgpratt: Yes, an alternative definition of Misty is class Appley m => Misty m where { joy :: m (m a) -> m a }
16:09:15 <hpc> it's too bad @src can't read L.hs
16:09:17 <shachaf> dgpratt: It works if you also have furry and apple.
16:09:44 <ddarius> hpc: You could fix that...
16:09:54 <hpc> > fix @src
16:09:55 <lambdabot>   Pattern syntax in expression context: fix@src
16:10:01 <hpc> nope :P
16:10:04 <shachaf> Fixing it would possibly be slightly tricky.
16:10:12 <shachaf> You'd need to parse L.hs; @src is just key-value lookup.
16:10:30 <hpc> i have no interest in messing with λbot when i have my own bot to maintain
16:10:34 <ion> @fix @src
16:10:34 <ddarius> shachaf: And we all know how difficult parsing is.
16:10:35 <lambdabot> Maybe you meant: bid faq ft id thx
16:10:43 <ion> @thx
16:10:44 <lambdabot> you are welcome
16:10:53 <ion> @bid
16:10:53 <lambdabot> Invalid argument ''
16:11:03 <ddarius> shachaf: At any rate, you could require L.hs to be in a particular format, at least as far the @src visible functions are concerned.
16:11:22 <ddarius> @help bid
16:11:23 <lambdabot> bid symbols.  Sum up the bid and ask prices for symbols.
16:11:32 <irene-knapp> @bid AAPL
16:11:33 <lambdabot> AAPL: bid $394.10, ask $394.35
16:11:36 <irene-knapp> @bid GOOG
16:11:36 <lambdabot> GOOG: bid $628.78, ask $629.07
16:11:38 <irene-knapp> huh
16:11:41 <irene-knapp> who knew we had that
16:11:53 <incluye> a stock tracker
16:11:54 <hpc> ...neat
16:11:56 <incluye> why even have that
16:11:59 <MostAwesomeDude> I learned something today.
16:12:02 <ddarius> It's lambdabot.
16:12:02 <incluye> what the tits
16:12:21 <irene-knapp> obviously, lambdabot implemented it herself to help with her portfolio!
16:12:49 <ddarius> @bid LBOT
16:12:50 <lambdabot> Can't find 'LBOT'
16:12:53 <irene-knapp> haha
16:13:18 <irene-knapp> here's something about the stock market that blows my mind: there are one-letter stock symbols.
16:13:34 <irene-knapp> like AT&T is "T"
16:13:43 <shachaf> WHOA, DUDE. FAR OUT.
16:13:46 <irene-knapp> haha
16:14:11 <hpc> @bid T
16:14:12 <lambdabot> Can't find 'T'
16:14:15 <irene-knapp> hmmm
16:14:19 <hpc> @bid ATT
16:14:20 <lambdabot> Can't find 'ATT'
16:14:33 <irene-knapp> http://www.google.com/finance?q=T
16:14:35 <incluye> @bid MSFT
16:14:35 <lambdabot> MSFT: bid $25.72, ask $25.75
16:14:38 <incluye> heh
16:14:40 <irene-knapp> @bid NYSE:T
16:14:41 <lambdabot> Can't find 'NYSE:T'
16:14:44 <MostAwesomeDude> @bid RHT
16:14:45 <lambdabot> Can't find 'RHT'
16:14:56 <donri> @bid GNU
16:14:56 <MostAwesomeDude> @bid NYSE:RHT
16:14:57 <lambdabot> Can't find 'NYSE:RHT'
16:14:57 <lambdabot> Can't find 'GNU'
16:15:28 <lars9> @google tsurucapital
16:15:30 <lambdabot> http://www.tsurucapital.com/
16:15:31 <MostAwesomeDude> Clearly she doesn't like RHEL. I don't blame her.
16:15:52 <lars9> this trading firm is using haskell to build trading systems
16:16:12 <irene-knapp> I have a secret plan to use trading systems to build Haskell!
16:16:21 <irene-knapp> it's nicely metacircular
16:16:21 <lars9> it seems to be the 1st haskell only company?
16:16:52 <shachaf> irene-knapp: The real question is what the 'T' stands for.
16:16:59 <Enigmagic> lars9: one of the tsuru guys hangs out in here sometimes
16:17:00 <irene-knapp> "Telephpone", I believe
16:17:05 <irene-knapp> it dates back to Bell
16:17:17 <irene-knapp> sp
16:17:24 <lars9> standard chartered bank and barclays are also using haskell but that's in a team
16:17:26 <irene-knapp> I managed to misspell "Telephone", go me ><
16:18:24 <shachaf> Enigmagic: More than one.
16:18:32 <lars9> so finance is the pioneer industry of FP usage
16:18:58 <shachaf> There is plenty of other industry use of Haskell.
16:19:08 <shachaf> I'm sure you can find other examples if you look. :-)
16:19:21 <lars9> IT companies are too c/java addicted
16:20:13 <donri> dons haven't been updating this since june http://www.haskell.org/haskellwiki/index.php?title=Template:Main/News&action=history maybe remove it from the front page?
16:20:38 <lars9> shachaf: yea but talking about FP, ocaml and F# also count
16:21:09 <lars9> donri: that's when he joined standard chartered
16:23:27 * donri updates it himself
16:24:02 <Saizan> shouldn't it update automatically?
16:24:19 <donri> one would think, but seems not
16:24:29 <donri> http://hackage.haskell.org/package/hackage2hwn
16:24:41 <lars9> Haskell Communities and Activities Report
16:24:42 <lars9> http://tinyurl.com/haskcar
16:24:43 <donri> but its output is outdated, so you can only use the list it produces
16:26:13 <lars9> this report sad the haskllers in barclays capital are considering using Commutative Arrows to solve their problems...
16:26:38 <ion> I’d be sad, too.
16:26:49 <lars9> s/sad/said/g
16:30:56 <lars9> damn, how to scroll up history of irssi in mac's terminal? fn+up scroll terminal history...
16:31:04 <hpc> pgup
16:31:10 <ion> Page up, meta-p
16:31:19 <hpc> or meta-p, apparently
16:31:38 <ion> I don’t remember if meta-up arrow is there by default or that’s something i added for a mobile ssh client.
16:31:39 <lars9> oh cool
16:31:49 <lars9> it worked
16:33:42 <lars9> can curses embed and compose? less (the command) would be a better history window for irssi
16:34:30 <lars9> at least it makes search easier
16:35:56 <lars9> ncurses is so anti linux style, too hard to compose and reuse
16:39:30 <jms> .
16:54:53 <DukeDave> Here's an cabal architectural style question for you all..
16:55:53 <DukeDave> So I'm working on wxhaskell, and I've now changed Setup.hs such that it compiles and links the C++ code in to a shared library (doing the compilation and linking itself, rather than the simple build system).
16:57:24 <DukeDave> That building happens in a custom build hookk, but the resulting .so must be given to the "extraLibs" in the BuildInfo during the conf hook.
16:58:08 <DukeDave> This creates a chicken and egg problem, because I have to reference the lib before it's built; cabal is wise to this and errors during the conf hook.
16:58:54 <DukeDave> As a result you have to do build twice, once to build the shared lib, and again to build Haskell code (which now needs the shared lib)
16:59:02 <shachaf> DukeDave: Why a shared library? Wouldn't a shared library typically be installed separately?
16:59:43 <DukeDave> shachaf: Read all about it: http://hpaste.org/55027
17:00:22 <DukeDave> But yes, I'm now thinking that building the shared lib should be a separate cabal project, upon which the first depends
17:00:52 <DukeDave> However, both projects must share the same C++ code, well, they must share the headers at least
17:01:23 <DukeDave> And I don't know of an elegant way to share the headers between two projects..
17:01:34 <TankC> Hey everyone
17:02:00 <TankC> I'm having a linker error on the cabal package when attempting to compile the haskell 2011.2.0.1 package
17:03:01 <TankC> I was wondering if anyone here might have any insight, I tried googling around but the only other reference I found to this error was asked by someone in this chat back in July and he never got an answer :)
17:03:50 <TankC> I don't mean to spam, but the following is what I'm getting...
17:03:53 <TankC> [44 of 44] Compiling Main             ( Main.hs, dist/build/cabal/cabal-tmp/Main.o ) Linking dist/build/cabal/cabal ...  Error: Building the cabal-install-0.10.2 package failed make: *** [build.stamp] Error 2
17:04:17 <TankC> Not a whole lot to work off of
17:14:35 <_oz> TankC: what is the command you use?
17:14:52 <TankC> ./configure && make
17:15:00 <TankC> from a fresh unpack of the haskell-platform source
17:15:26 <_oz> and you get the source from?
17:17:08 <TankC> http://lambda.galois.com/hp-tmp/2011.2.0.1/haskell-platform-2011.2.0.1.tar.gz
17:17:21 <TankC> http://hackage.haskell.org/platform/linux.html
17:20:17 <TankC> I'm pretty much following the directions from here, http://sporkcode.wordpress.com/2009/07/11/installing-the-haskell-platform-in-ubuntu/
17:20:41 <TankC> of course, with the more recent generic binary package
17:21:50 <_oz> I don't use the platform, so I don't really know how the install script works
17:22:13 <_oz> if you have ghc installed already, you can try installing cabal-install and you should be good to go
17:23:56 <TankC> How do you suggest I install cabal-install?
17:24:31 <TankC> I don't want to get it from my package manager because that will force me to get their version of ghc.. which is pretty outdated
17:25:00 <Cale> TankC: get the tarball from hackage and run the bootstrap.sh script in it
17:25:09 <_oz> which version of ghc do you have?
17:25:29 <TankC> _oz: 7.0.3
17:26:38 <_oz> you can get http://www.haskell.org/cabal/release/cabal-install-0.10.2/cabal-install-0.10.2.tar.gz
17:26:41 <_oz> from http://www.haskell.org/cabal/download.html
17:26:58 <_oz> and run bootstrap.sh
17:27:04 <_oz> should work fine
17:27:24 <lewis1711> noob question: I know about 'deriving (show)', but I want to implement show for a type myself. what's the correct lingo so I can google it?
17:27:27 <_oz> there are a few problems with 7.2.*, but should be fine for 7.0.3
17:27:56 <Cale> lewis1711: You want to write an instance of the typeclass Show
17:28:00 <Cale> instance Show MyType where
17:28:04 <Cale>   show x = ...
17:28:37 <lewis1711> thanks Cale
17:32:09 <TankC> Cale: I'm getting the same error when compiling cabal-install from it's own package and running the boostrap
17:32:51 <TankC> No explanitave errors..
17:32:52 <Cale> hmm
17:38:29 <hpaste> irene-knapp pasted “Uses so many extensions that I don't even know where to begin debugging” at http://hpaste.org/55055
17:38:37 <irene-knapp> wait
17:38:38 <irene-knapp> ignore that one
17:38:42 <irene-knapp> correction forthcoming
17:39:01 <hpaste> irene-knapp pasted “Uses so many extensions that I don't even know where to begin debugging” at http://hpaste.org/55056
17:39:05 <Cale> irene-knapp: It would be good to know what problem you're having too ;)
17:39:05 <irene-knapp> there we go
17:39:07 <irene-knapp> much cleaner
17:39:20 <irene-knapp> Cale: haha yeah, the error messages are at the bottom :) I pasted the wrong file entirely the first time :)
17:39:49 <irene-knapp> it looks as though it isn't letting me dissect the existential
17:40:03 <irene-knapp> but it has the extension turned on, and afaik I'm using it within the rules
17:40:55 <irene-knapp> do existentials not work with type families, or something?
17:41:04 <irene-knapp> it doesn't seem as though they should affect each other
17:42:30 <Cale> Where is the definition of the data constructor TypeConstructorName?
17:42:45 <irene-knapp> oh!  sorry, I was too aggressive in my snipping
17:42:51 <irene-knapp> that's a key aspect of this
17:43:07 <Cale> indeed
17:43:13 <irene-knapp> it's defined in the Keyed TypeConstructor instance as data Key TypeConstructor = TypeConstructorName ConstructorName
17:43:19 <irene-knapp> (and ConstructorName is a synonym for String)
17:43:59 <cmccann> philsophical existentialism is often characterized by confusion and dismay in the face of a meaningless and purposeless universe, a fact which occasionally strikes me as relevant to the subject of existential quantification.
17:44:08 <irene-knapp> cmccann: hahaha
17:44:11 <irene-knapp> indeed
17:45:59 <Cale> irene-knapp: So the problem is that you're matching on a data constructor of that type when there's no evidence to show that the v in SomeKey v = someKey is actually of that type.
17:46:18 <irene-knapp> hmmm
17:46:19 <Cale> So it wouldn't be safe to just go ahead with the pattern match.
17:46:45 <Cale> (because, at an implementation level, the constructor tags are integer values which overlap between datatypes)
17:46:49 <irene-knapp> but don't existentials carry a type tag around with them, or something?
17:46:53 <irene-knapp> hmmmmm
17:47:04 <Cale> Existentials explicitly *forget* the types that they generalise over
17:47:11 <Cale> That's kind of the point of them :)
17:47:14 <irene-knapp> ah, hmmm :)
17:47:32 <irene-knapp> so I'm actually breaking the rules of existentials and the fact that I'm using type families as well is unrelated
17:47:43 <Cale> yeah
17:48:05 <irene-knapp> right, okay.  so I can only call methods of the Keyed typeclass on values of AnyKey...
17:48:08 <irene-knapp> hmmm
17:48:17 <irene-knapp> or rather
17:48:26 <irene-knapp> well, it's data AnyKey = forall keyed . Keyed keyed => SomeKey (Key keyed)
17:48:36 <irene-knapp> not sure I can call /any/ methods on it, heh
17:50:25 <irene-knapp> okay, right
17:50:28 <Cale> You need some other witness to the type equality. This reminds me of some code that Ryan (my boss) and I have been working on lately, for typed heterogeneous graphs. We end up doing a fair amount of safe unsafeCoerce'ing, after getting hold of value level witnesses that node types have to be equal (because the references are to the same node) :)
17:50:35 <irene-knapp> interesting
17:50:43 <Cale> But in your case, maybe you don't need to go that far
17:50:53 <irene-knapp> I'm definitely up for suggestions :)
17:51:22 <Cale> well...
17:51:30 <irene-knapp> one thing that comes to mind is
17:51:41 <irene-knapp> I have an Ord instance for AnyKey (it uses Typeable and Show...)
17:51:54 <Cale> How many instances of Keyed do you have?
17:51:58 <irene-knapp> so I could do this thingy that I want by sticking everything in a Map
17:52:07 <irene-knapp> right now, less than ten
17:52:07 <Cale> Is it absolutely necessary for that to be extensible?
17:52:55 <irene-knapp> well, it's kinda...  I just like the code factored in this way, because this is to be a toy compiler and names of various sorts are kinda its bread and butter
17:53:25 <irene-knapp> I mean, if it's unsafeCoerce or don't use type families, I guess I'd go with the latter
17:55:24 <Cale> Well, I'm not sure the type families are your problem...
17:56:10 <irene-knapp> well, yeah, hm.  rather, I could do it without the existential I guess, by explicitly enumerating every constructor of Key keyed
17:57:39 <irene-knapp> okay!  I got it working by using a Map
17:57:50 <irene-knapp> Map AnyKey AnyInspectable, which is possible because of the Ord and Show instances :)
17:58:05 <shapr> Man, Yesod is srsly awesome and shockingly simple.
18:01:23 <cmccann> personally Yesod makes me think of some sort of giant, hulking behemoth crafted from arcane metaprogramming black magic that looms over you ominously, then gently pats you on the head and gives you a cookie
18:03:32 <irene-knapp> Cale: anyway, thanks!
18:04:56 <byorgey> @remember cmccann Yesod makes me think of some sort of giant, hulking behemoth crafted from arcane metaprogramming black magic that looms over you ominously, then gently pats you on the head and gives you a cookie
18:04:56 <lambdabot> Nice!
18:09:53 <cmccann> byorgey, heh :]
18:11:07 <n0den1te> @quote Yesod
18:11:08 <lambdabot> cmccann says: Yesod makes me think of some sort of giant, hulking behemoth crafted from arcane metaprogramming black magic that looms over you ominously, then gently pats you on the head and gives
18:11:08 <lambdabot> you a cookie
18:11:13 <n0den1te> :)
18:20:11 * mysticc check
18:26:05 <lewis1711> what type should i use for lots of precision in adding floating point numbers?
18:27:25 <ion> Do you *need* floating point numbers?
18:27:52 <ion> For precise rational numbers i’d use Rational.
18:28:18 <ion> Also, CReal might or might not be useful for your needs.
18:28:56 <arw> or, if applicable, Integer. adding floats, especially when the exponents are very unequal, is problematic
18:28:58 <lewis1711> ion: yes. they're for molecular masses.
18:29:30 <cmccann> there's also fixed point numbers
18:30:14 <russellw> lewis1711, then 64 bit floating point should suffice, right?
18:31:14 <lewis1711> Double? getting rounding errors pretty quickly
18:31:55 <russellw> You will always get some rounding errors unless you use exact rational numbers (in which case you will quickly run out of memory). But how big are your rounding errors?
18:31:59 <arw> depends, I guess the problem is something like "oh, there is this very heavy molecule. how i'll add 1 hydrogen." problem there is, that kills precision, since you are adding some large to some small number.
18:32:30 <russellw> Double is good for about sixteen decimal digits of precision, molecular masses aren't known to that much. Even a heavy molecule might be what, 1e5? You can add a hydrogen to that with eleven digits of precision
18:32:43 <lewis1711> I suppose you're right, it'll do
18:33:04 <irene-knapp> astronomy is, in fact, the sole context I'm aware of where Doubles are insufficient
18:33:35 <irene-knapp> hence the term "astronomical numbers" :)
18:34:06 <russellw> And even in astronomy, isn't that only true when you're running things like investigations of whether the solar system is stable billions of years in the future, i.e. simulations with very many time steps?
18:34:11 <irene-knapp> yes.
18:34:23 <irene-knapp> well, no, I mean, I've seen it in real-measurement contexts
18:34:32 <russellw> oh, how?
18:34:49 <irene-knapp> positions of small objects near the sun, to about a meter of precision, as measured from Earth, originally in degrees of arc
18:35:28 <irene-knapp> I went out and found that example years ago when a professor expressed the belief that there was no such need :)
18:35:28 <russellw> Okay but the distance from the Sun to the Earth is only about 1e8 meters, so lots of margin there
18:35:53 <irene-knapp> yes, but the thing is that the angular measurement is so small that it also uses a lot of digits
18:36:01 <arw> uhm. well. a Double has 16 digits and many things will fit into those 16 digits.
18:36:28 <arw> but the problem is, with calculations those 16 digits start to degrade quite heavily.
18:36:33 <irene-knapp> anyway, I know that these astronomers had a library that represented their quantities as a pair of doubles, right
18:36:46 <irene-knapp> with functions to normalize these pairs so that they didn't overlap themselves
18:36:55 <russellw> Fair enough
18:36:56 <irene-knapp> I didn't check their work to make sure they really needed it :)
18:36:57 <arw> so you can, at best, rely on about 10 after a few of additions
18:37:05 <irene-knapp> but I can't envision anybody doing that very difficult and clever library without needing it :)
18:37:24 <russellw> true :)
18:38:35 <arw> multiplications and divisions are less problematic, everything more complex like matrix multiplication depends on the amount of additions involved.
18:38:52 <irene-knapp> yeah
18:39:07 <cmccann> has anyone brought up the Things Every Computer Scientist Should Know paper yet?
18:39:10 <cmccann> or whatever the title was
18:39:20 <irene-knapp> no, feel free to remember its title and point us at it
18:39:29 <irene-knapp> (I've read it though)
18:39:44 <lewis1711> the one about floating point numbers? yeah i keep forgetting wht it said
18:39:46 <lewis1711> obviously
18:39:47 <mauke> @google ncg goldberg
18:39:48 <lambdabot> http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
18:39:48 <lambdabot> Title: What Every Computer Scientist Should Know About Floating-Point Arithmetic
18:39:56 <cmccann> yeah, that
18:40:09 <irene-knapp> ah, I thought it covered character encodings in the same document
18:40:10 <irene-knapp> apparently not :)
18:40:13 * mauke remembers url components o_O
18:40:20 <irene-knapp> hahaha so I see!
18:40:25 <mauke> @google joel on unicode
18:40:26 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
18:40:27 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know A ...
18:41:08 <russellw> Unlike the one on floating-point, and unlike most of Joel's writing, I don't agree with his position on Unicode
18:41:15 * irene-knapp nods
18:41:20 <irene-knapp> which part of it?
18:41:35 <russellw> The whole thing. Here's how I see it:
18:42:10 <russellw> Bad news, text processing is a job for a linguist not a programmer. If you're a programmer you can't get it right, because you aren't a linguist, end of story
18:42:27 <irene-knapp> mm
18:42:29 <mauke> no
18:42:31 <cmccann> between floating point, unicode locale stuff, calendars, and timezones, I continue to maintain that the three most difficult things to work with in programming are text, numbers, and time offsets
18:42:51 <irene-knapp> I agree that they're the three topics with the most subtle non-programmatic issues involved
18:42:56 <cmccann> all that category theory stuff in haskell is dead simple in comparison, really
18:42:56 <mauke> you can't program without dealing with text
18:42:59 <mauke> unless you write in Piet
18:43:01 <irene-knapp> but there is no excuse for not making the effort to understand them
18:43:03 <russellw> Good news, programs that really need to do text processing are vanishingly rare. If you think you need to process text, it's almost certain what you actually need is:
18:43:33 <byorgey> cmccann: to that list I might also add 'color'
18:43:48 <ski> @where floating-point
18:43:49 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
18:43:49 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
18:43:55 <russellw> 1. To handle some semiformal format (programming languages, XML, whatever) where the parts you need to recognize are actually defined in ASCII, and all you need to do with the Unicode parts is carry them unchanged
18:43:59 <irene-knapp> since, for one thing, it's simply unacceptable to tell your boss or your users "sorry about that security vulnerability that wiped out our forty years of business data, but I can't be expected to understand text encodings, I'm not a linguist."
18:44:08 <cmccann> byorgey, haha that definitely qualifies if you're doing anything interesting with it, but that's easier to avoid than the other three I think
18:44:12 <irene-knapp> you won't just be fired - you'll go to jail =p
18:44:14 <byorgey> cmccann: true.
18:44:15 <russellw> 2. To take in text and spit it out again without breaking it
18:44:50 <russellw> irene-knapp, yep. That's why you need to realize you aren't a linguist _upfront_ and don't try to do something you're not qualified to do
18:44:58 <mauke> russellw: how mnay of your programs deal with user input?
18:44:58 <monochrom> no, I don't get any "you are not a linguist" impression from joel
18:45:05 <irene-knapp> russellw: okay, so first off, linguists are not qualified to do text encodings
18:45:18 <irene-knapp> since it's not a linguistics issue - they are qualified to debate codepoints and character unifications endlessly, perhaps
18:45:23 <russellw> A programmer can be expected to slurp in UTF-8 text and spit it out again unchanged. That is within his competence, as long as he doesn't try to understand the contents
18:45:27 <irene-knapp> it's a binary-data issue =p
18:45:40 <irene-knapp> so who IS qualified to do it, if it's neither linguists nor programmers?
18:45:44 <russellw> mauke, I've written quite a few. They worked successfully because I didn't try to do something I wasn't qualified to do
18:45:56 <mauke> wat
18:45:59 <irene-knapp> I assert that since nobody else is capable of doing it, and a rational outsider would expect us as programmers to take care of the issue, it's our responsibility
18:46:02 <cmccann> there are quite a few people who are both linguists and programmers, actually
18:46:08 <arw> one of the major braindamages of unicode stems from the fact that linguists often get caught up in weird politics about what is a language/sign/glyph/whatever
18:46:12 <irene-knapp> cmccann: oh, certainly; augur is one of them
18:46:26 <russellw> sure. If you are both a linguist and a programmer, or if you can hire both for your project, great, knock yourself out
18:46:28 <irene-knapp> cmccann: and I'm sort of a linguistic enthusiast :)
18:46:42 <irene-knapp> but the point is, there are a great many projects which really do have text-processing needs, right
18:46:50 <russellw> But if you are a programmer and not a linguist, just concentrate on being able to read UTF-8 and carry it where it's needed without breaking it
18:46:55 <mauke> irene-knapp: anything that interacts with the world
18:47:02 <mauke> filenames are user input are text
18:47:03 <cmccann> irene-knapp, my knowledge of linguistics is limited to reading Language Log on occasion and having a deep and abiding appreciation for how little I actually know
18:47:07 <irene-knapp> and there are comparatively few people qualified to do it, by your claim that only the intersection of linguists and programmers are...
18:47:14 <irene-knapp> mauke: yes, indeed :)
18:47:24 <irene-knapp> cmccann: yeah :) fun blog
18:47:44 <irene-knapp> russellw: so what's your position, then?  the world is just broken and we have to accept that?
18:47:47 <mauke> case insensitivity and case folding are three cans of cans of worms
18:47:54 <irene-knapp> russellw: there's no way to get what everybody needs, in the present day?
18:48:18 <cmccann> mauke, and each worm has a collection of cans containing more, smaller worms, all of which have razor-sharp teeth
18:48:31 <irene-knapp> russellw: because in that case, explain why anybody should ever hire a programmer who asserts that not only can he not do the basic functions of his job, neither can anybody else?
18:48:34 <russellw> There is no way to get what everybody wants. What we can do is make sure we don't break things any further by thinking we understand things we don't
18:48:58 <russellw> irene-knapp, by all means disagree with me if you like, but please at least first read what I wrote
18:48:58 <irene-knapp> worms with teeth!
18:49:00 <cmccann> I think the main lesson to take is that handling text correctly is actually difficult and something you should leave to experts instead of rolling your own, much like crypto
18:49:25 <irene-knapp> russellw: I did read it, but I was typing quickly, yes.  anyway, I do disagree with you.
18:49:46 <irene-knapp> what cmccann just said is closer to my position - don't unnecessarily write your own low-level routines for it, and trouble to understand the issues that can't be factored into libraries.
18:49:50 <cmccann> and that you should really think twice before trying to implement your own algorithms to do something very tricky, like "converting to uppercase"
18:49:51 <irene-knapp> but that isn't what russellw was saying at all
18:50:02 <russellw> mauke, indeed, case insensitivity and case folding are big enough cans of worms that you won't and can't handle them correctly. Either don't try, or do it ASCII only if you're handling a pure ASCII file format, or call a library that hopefully was written by a linguist
18:50:16 <russellw> That is exactly one of the things I'm saying
18:50:36 <russellw> If you aren't a linguist, don't try to write a library function for converting Unicode to uppercase, because you won't get it right, and then you will be rightly blamed when it gives wrong answers
18:50:37 <irene-knapp> well, then you're saying it quite poorly, as you SOUND like you're saying "run far away from text and never deal with it"
18:50:42 <mauke> "ASCII only" will still kick your ass with combining characters
18:50:47 <irene-knapp> which is a rather impractical attitude since, news flash, you have to deal with it
18:51:08 <russellw> mauke, since when were combining characters part of ASCII?
18:51:18 <cmccann> the only difference is that if you screw up crypto you'll get hacked and lose a bunch of money, if you screw up text encoding you'll just get someone killed because you changed a letter in a text message to something offensive and started a fight
18:51:23 <mauke> russellw: oh, you mean all ascii
18:51:27 <irene-knapp> it's like saying "taxation is a subject that only experts should have anything to do with.  if you aren't an expert, don't pay your taxes."
18:51:27 <cmccann> the latter has actually happened, btw
18:51:27 <mauke> right
18:51:30 <russellw> irene-knapp, I didn't say that. I said repeatedly, take it in and pass it where it needs to go, just don't assume you understand it
18:52:17 <irene-knapp> russellw: okay, I guess, but I think if you reread what you said, you'll see how it didn't come off that way.
18:52:18 <russellw> mauke, yes. As I said, it's a situation that arises when you aren't dealing with natural language text, you are dealing with some legacy format that's defined in terms of ASCII - a Pascal compiler, for example
18:52:54 <russellw> irene-knapp, okay then, that's what I'm saying. And that's what I disagree with Joel about, because he advocates programmers trying to learn just enough linguistics to be dangerous and not enough to understand how much they don't know
18:53:04 * cmccann also got more of a "just avoid text" impression from russellw, rather than "defer to stuff experts already wrote"
18:53:13 <russellw> And that's going to lead to people trying to write their own homebrew case conversion functions, and getting it hopelessly wrong
18:53:18 <irene-knapp> okay.  well, correction accepted.
18:53:27 <irene-knapp> I see how you get that from Joel's article, in that case
18:53:36 <mauke> > toLower 'ẞ'
18:53:38 <lambdabot>   '\223'
18:53:44 <mauke> heh, nice
18:53:46 <cmccann> yeah I think we all agree that trying to do it yourself is the worst approach :P
18:54:02 <mauke> > toLower 'ẞ' == 'ß'
18:54:04 <lambdabot>   True
18:54:06 <arw> > toUpper 'ß'
18:54:07 <lambdabot>   '\223'
18:54:07 <irene-knapp> I agree that Joel should have done more to emphasize "there are good libraries that do this and you should use them", which is the point that those of us who do actually have some knowledge take from it
18:54:08 <mauke> > toUpper (toLower 'ẞ') == 'ß'
18:54:09 <lambdabot>   True
18:54:12 <thierrygar>  I spent two years on a project with running battles over whether French ligatures are typographic or alphabetic. Fistfights etc. Won't go there again.
18:54:25 <russellw> Right, then we are in agreement
18:54:27 <irene-knapp> to that end, he probably shouldn't have spent as much time showing specific bit-patterns and the like
18:54:30 <irene-knapp> okay
18:55:24 <shachaf> mauke: There's a capital 'ß'?!
18:55:29 <shachaf> I had no idea.
18:55:40 <arw> shachaf: not really. or "in some way".
18:55:43 <irene-knapp> yeah, it's one of the bizarre, er, cases
18:56:06 <arw> shachaf: some typographers invented it and unicode of course has the character.
18:56:13 <mauke> oh, that reminds me
18:56:22 <mauke> I still have no way to type a reverse ?
18:56:25 <irene-knapp> heh
18:56:26 <arw> shachaf: but the correct anser to toUpper 'ß' is still 'SS'.
18:56:26 <irene-knapp> hmm
18:56:37 <mauke> what key combination should I map it to?
18:56:50 <irene-knapp> no idea!
18:56:56 <irene-knapp> why do you want to type it?
18:57:03 <ion> compose ? ?: ¿
18:57:03 <shachaf> mauke: AltGr-shift-s?
18:57:10 <mauke> for use in rhetorical questions and irony
18:57:11 <shachaf> Hmm, I have that mapped to §.
18:57:14 <mauke> shachaf: ſ
18:57:17 <monochrom> I completely did not get what you got from joel's article. what I got: there is no longer a character-to-8-bits mapping, in fact there is no longer a fixed mapping. which mapping is actually used is metadata. I definitely didn't get: go rewrite your case conversion function
18:57:20 <shachaf> mauke: Oh.
18:57:26 <russellw> Do you need to use it often enough that you can't just copy paste from a small text file of unusual characters?
18:57:32 <mauke> ion: that's an upside down ?, not ⸮
18:57:49 <arw> monochrom: ignore the Joel-article. read the first answer here: http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default
18:57:54 <shachaf> What's the reverse question mark for?
18:57:58 <shachaf> Arabic?
18:58:01 <mauke> for use in rhetorical questions and irony
18:58:07 <arw> monochrom: quite perl-centric, but quite interesting.
18:58:09 <irene-knapp> monochrom: well, but I do see a point that Joel's article could be counterproductive in that it needs to spend more time on "here are some specific things that have gone badly in the past for people, to motivate your studies"
18:58:16 <shachaf> russellw: That's not the mauke way.
18:59:16 <russellw> arw, yes, that's one of the best articles I've ever seen on the subject
18:59:26 <russellw> shachaf, fair enough :)
19:00:12 <mauke> what I can type: s, S, ß, ſ, ẞ, ¿, ⁇, ⁈, ⁉, ‽
19:02:24 <thierrygar>  shachaf: ¿ is ordinary Spanish punctuation.
19:02:32 <mauke> ok, I put it on <compose> r ? for now
19:02:43 <pikhq> mauke: Yeah, but can you type 鬱?
19:02:45 <shachaf> thierrygar: <mauke> ion: that's an upside down ?, not ⸮
19:03:12 <mauke> pikhq: only by entering the keycode
19:03:14 <shachaf> mauke: ⁈ and ⁉, but no ‽?
19:03:20 <mauke> pikhq: ctrl-shift-9b31
19:03:23 <clsmith_> re:upper(unicode), iirc the unicode specification defines the uppercase for any given character, if any
19:03:24 <pikhq> mauke: Neat.
19:03:37 <pikhq> That's definitely easier than trying to write it. :P
19:03:52 <pikhq> (and yet harder than remembering how to type it with an IME)
19:03:55 <mauke> shachaf: ‽ was in my list
19:03:57 <mauke> last character
19:04:45 <mauke> also, wtf is that thing even
19:04:58 <mauke> it looks like an unholy chimera of 6 or 7 smaller characters
19:04:59 <cmccann> what, the interrobang?
19:05:18 <clsmith_> 鬱?
19:05:20 <mauke> yeah
19:05:26 <cmccann> ah
19:05:30 <cmccann> unreadable is what it is
19:05:39 <cmccann> at least at the font size I'm using
19:06:03 <pikhq> mauke: Gloss "depression", onyomi "utsu", kunyomi I-don't-know-and-don't-particularly-care.
19:06:14 <mauke> I pasted it in http://mauke.dyndns.org/stuff/javascript/unicode.html?q=%E9%AC%B1 and used ctrl+mousewheel to increase the font size
19:06:35 <pikhq> cmccann: In most fonts at stock reading size it's recognisable as "that motherfucking blur"
19:07:08 <clsmith_> it looks very different in a proper chinese font than in gnu unifont...
19:07:17 <cmccann> I can make out some of the radicals, mostly the top and right
19:07:22 <clsmith_> in gnu unifont it looks somewhat like a pot of plants
19:07:29 <clsmith_> art deco
19:07:30 <cmccann> the lower left is just a smudge though
19:08:08 <cmccann> haha, it has 29 strokes
19:09:18 <clsmith_> what's others' opinions on this?: grep -i <chinese> should match the appropriate traditional and simplified characters
19:09:52 <pikhq> clsmith_: Not all that good; there's not a one-to-one mapping between the two sets.
19:09:53 <cmccann> my opinion is that question sounds like a great way to start flamewars
19:09:53 <mauke> mmh, tasty worms
19:10:01 <mauke> fresh out of the can
19:10:18 <mauke> in fact, I propose grep --worms
19:10:31 <clsmith_> cmccann: i have never had a flame war over unicode :(
19:11:15 <pikhq> (yes, that's right, there's not a one-to-one mapping between traditional and simplified. No, I cannot explain the logic behind this.)
19:11:35 <mauke> http://mauke.dyndns.org/stuff/javascript/unicode.html?q=fire
19:11:40 <clsmith_> pikhq: that's weird, but that doesn't matter, does it?
19:12:08 <pikhq> clsmith_: It'll get you pretty darned weird matches.
19:12:14 <cmccann> clsmith_, I think you need a critical mass of people who know enough about linguistics to have strong opinions about random things to get a unicode flamewar started
19:12:33 <clsmith_> cmccann: sounds like a challenge! <.<;
19:12:34 <mauke> cmccann: strong opinions don't require knowledge
19:13:05 <russellw> But they do require at least an illusion of knowledge :)
19:14:06 <DanBurton> mauke: holy crap the source on that page is a beast
19:14:21 <mauke> tee hee
19:14:29 <lewis1711> is there anything like "words", but allows you to pass in what you want to split strings by? for example i want to use numbers as a token delimiter, not whitespace
19:14:41 <cmccann> mauke, yeah true
19:14:51 <shachaf> lewis1711: See Data.List.Split.
19:14:53 <mauke> DanBurton: yeah, I wanted to make a self-contained page and javascript's support for unicode sucks, so I had to inline the whole unicode character db
19:14:53 <DanBurton> lewis1711: check out the split package
19:14:58 <lewis1711> thanks
19:14:58 <shachaf> lewis1711: Unfortuantely there's nothing in base.
19:18:03 <lewis1711> blergh, I want something like splitOn but that includes the delemiter
19:18:37 <lewis1711> > mySplitOn "x" "axbxc"  ["ax","bx","cx"]
19:18:38 <lambdabot>   Not in scope: `mySplitOn'
19:21:28 <lewis1711> keepDelimsR, or something
19:23:44 <Jafet> clsmith: hell, it should match kanji, too!
19:24:09 <JoeyA> From a language design standpoint, would it have been a good idea for Haskell to use type classes and dot syntax for record selectors instead of what it currently uses?  I'll explain.
19:24:12 <shachaf> lewis1711: Just implement your own recursively with break or something like that.
19:24:28 <shachaf> JoeyA: No. "." is overloaded too much already.
19:24:35 <shachaf> JoeyA: And type classes aren't good for record selectors.
19:24:52 <shachaf> However, there exist various TDNR proposals that might be something like what you're after.
19:24:53 <JoeyA> shachaf: Your second point is precisely what I want to ask about.  Why?
19:27:37 <JoeyA> What's wrong with making the .x function polymorphic?  In the vast majority of useful cases, it will be used in a monomorphic context (i.e. the compiler can write in the appropriate selector, eliminating dictionary overhead)
19:28:52 <JoeyA> What I'm thinking is, .identifier is a record selector function (perhaps postfix in syntax), in a distinct namespace from other functions.
19:29:00 <Jafet> JoeyA: .x has a row-polymorphic type, so you'll probably need to extend the type system
19:29:16 * cmccann still suspects that "type classes + record selectors" proposals are almost inevitably attempts to implement a broken and incomplete form of structural subtyping
19:29:40 <Jafet> JoeyA: and before you do that, why not use ocaml?
19:29:57 <JoeyA> Jafet: Still need to learn it
19:30:15 <Jafet> I figured as much
19:30:17 <JoeyA> What's broken about Haskell records is that you lose the namespace benefit provided by struct members in e.g. C.
19:30:29 <shachaf> @google tdnr haskell
19:30:31 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
19:30:31 <lambdabot> Title: TypeDirectedNameResolution – Haskell Prime
19:31:03 <JoeyA> Jafet: Why would you need to extend the type system?
19:31:05 <shachaf> I don't like this proposal much, actually, looking at it.
19:31:25 <monochrom> oh, I mocked TDNR greatly :)
19:31:37 <JoeyA> Even if .x has two different types in two different contexts, a multi-parameter type class should do, no?
19:32:13 * monochrom would drop the "record selector" part and just use the "type class" part. already available today.
19:32:13 <JoeyA> Suppose we have data Point = Point { x :: Int, y :: Int }  and data Point3D = Point3D { x :: Float, y :: Float, z :: Float }
19:32:31 * cmccann likes the idea of combining type-directed name resolution with name-directed type resolution, what could go wrong
19:33:06 <monochrom> type-resolved name direction!
19:33:07 <shachaf> cmccann: Let's just stick with NDNR and TDTR.
19:33:47 <Jafet> Resolute directive
19:34:06 <JoeyA> But I'm still not convinced that having a selector be polymorphic (i.e. (Selector s v) => s -> v) would be problematic.
19:34:10 <BMeph> Type-loop Directed Resolution? ;)
19:34:31 <monochrom> resolution-directed name typation
19:35:06 <monochrom> intuition-directed brain constipation
19:35:17 <cmccann> direct resolution type naming
19:35:22 <lewis1711> err, is there anyway to see if a string has a number in it? :/
19:35:25 <JoeyA> I want to write a random Haskell extension generator
19:35:36 <JoeyA> -XTuplePolymorphism
19:35:47 <cmccann> I'm still holding out for -XPolymorphismRestriction
19:36:12 <monochrom> look for '0' to '9' in the string? but beware of other number-category characters in unicode
19:36:16 <JoeyA> I'd like -XWhereInstances
19:36:31 <shachaf> monochrom: instance Num n => Category n where?
19:36:32 <JoeyA> (which is most useful with -XWhereTypes)
19:36:46 <monochrom> no, not that kind of category
19:36:48 * shachaf isn't even going to kind that properly.
19:37:16 <JoeyA> (to be able to satisfy typeclass contexts with dynamically-defined functions)
19:37:31 * cmccann thinks shachaf needs some conversation-directed name resolution
19:38:11 <shachaf> cmccann:
19:38:34 <lewis1711> monochrom: how would I even do that? I am trying so split something like "CH3CH3" into ["CH3, CH3"]. so far I have 'split (keepDelimsR $ oneOf SOMETHING)'
19:38:35 * BMeph prefers name-directed conversation resolution
19:38:58 <monochrom> what is the type of oneOf?
19:39:49 <lewis1711> oneOf :: Eq a => [a] -> Splitter a
19:40:32 <monochrom> ['0'..'9']
19:40:50 <lewis1711> ...oh yeah
19:45:13 <lewis1711> in the future, programming will be more like haskell and less like java, right?
19:45:50 <ezyang> one can only hope
19:46:13 <strager> It seems to be going that way with newer and more used languages.
19:46:20 <cmccann> probably
19:46:29 <cmccann> the question is whether it will be enough like haskell to really help
19:46:30 <strager> JavaScript's becoming more popular due to HTML5 hype.
19:46:36 <strager> C#'s becoming more popular.
19:46:40 <strager> Both have functional components.
19:46:50 <ricree> there definitely seems to be a trend towards more functional features, though it may not be as close as we'd like
19:46:58 <ricree> yeah, I was actually thinking C# as well
19:47:00 <lewis1711> I'm only beginning in C# but i am not very impressed by its functional bits.
19:47:01 <Jafet> In the future, EVERYONE WILL USE ARC
19:47:10 <lewis1711> the lisp dialect?
19:47:12 <strager> lewis1711: Tons better than nothing.  =]
19:47:24 <cmccann> I suspect the more likely scenario is that the future will look like scala, only with more misfeatures
19:47:26 <arw> the cynic says: it will become a mixture of java, javascript and because its popular, php.
19:47:48 <cmccann> at least as far as static typed languages go
19:47:54 <ricree> maybe I'm just a bit insulated, but php seems to be falling out of favor
19:47:57 <arw> (javascript is there for the now hip functional part...)
19:48:16 <cmccann> there will continue to be huge amounts of code written in languages that enable writing bugs faster
19:48:23 <parcs> was it ever proposed to have heterogenous lists replace the tuple types?
19:48:35 <lewis1711> how would that work?
19:48:39 <cmccann> not very well
19:48:44 <parcs> the heterogenous list type*
19:48:45 <lewis1711> massive noob alert: what type would it be?
19:48:47 <lewis1711> oh
19:49:03 <parcs> cmccann: are you referring that what i said?
19:49:11 <cmccann> parcs, yeah
19:49:27 <parcs> cmccann: why wouldn't it work very well?
19:49:44 <strager> I think that'd be mixing responsibilities.
19:49:47 <parcs> i think it would work exactly the same, if not better, than the current tuple magic
19:50:04 <cmccann> I suspect it would be too clumsy to offer any real benefits over tuples
19:50:17 <cmccann> unless it included more substantial changes to the language as a whole
19:50:49 <parcs> but with heterogenous lists you can define pseudo n-tuple-like functions using type classes and induction
19:50:57 <cmccann> so when I say "not very well" I mean "as something added to Haskell proper"
19:51:05 <parcs> with current tuples you can't do that
19:51:06 <strager> But is there really a need for that, parcs?
19:51:18 <cmccann> parcs, I know
19:51:21 <cmccann> I've written quite a few of those
19:51:23 <cmccann> :]
19:51:30 <parcs> i'm sure many people have :P
19:52:01 <shachaf> By heterogeneous lists you just mean cons/nil-style tuples, right?
19:52:23 <parcs> i mean 'data a :| b = a :| b' or something like that
19:52:25 <shachaf> (a,(b,(c,()))
19:53:04 <parcs> and (a, b, c, ...) would be sugar for (a :| b :| c ... :| ())
19:53:20 <parcs> infixr :| obviously
19:53:33 <shachaf> That would seem to be a Yes. :-)
19:53:34 <strager> :| is a smiley.  This won't do.
19:53:35 <cmccann> parcs, https://github.com/isomorphism/typewriter/blob/master/Data/Typewriter/Variadic/Apply.hs  :P
19:53:40 <shachaf> parcs: You get extra _|_s.
19:53:51 <roconnor> :[]
19:54:11 <shachaf> :▯
19:54:19 * cmccann spent some time trying to trick GHC into unpacking the constructors for the tuples
19:54:22 <shachaf> :▬▯
19:54:35 <shachaf> cmccann: Ooh, did it work?
19:54:47 <cmccann> didn't seem to be happy about it
19:54:48 <shachaf> cmccann: It seems way too complex to use even if it did work, of course. :-(
19:55:00 <cmccann> it doesn't need to be that complex to use, really
19:55:11 <parcs> strager: re whether there is a need for that, i can't say. but it is often asked how to define functions that work on n-tuples
19:55:12 <cmccann> but it's a pain to implement in a way that's usable
19:55:20 <shachaf> I mean, too complex in the implementation for me to want to use it.
19:55:51 <shachaf> parcs: Would this proposal help you with that in any way?
19:56:09 <parcs> yes
19:56:42 <cmccann> I could definitely see GHC supporting something like unpacked cons/nil pseudo-tuples like what I was trying to accomplish
19:56:50 <cmccann> given what else is in there
19:57:24 <shachaf> @where e_10
19:57:24 <lambdabot> let(!)=div;f n=1:n:1:f(n+2);w@(x:y)%[a,b,c,d]|t<-a!c,c+d>1,t==b!d=t:w%[10*(a-c*t),10*(b-d*t),c,d]|0<1=y%[x*a+b,a,x*c+d,c]in(2:f 2)%[1,0,0,1]>>=show
19:57:36 <shachaf> Golf, #haskell!
19:57:42 <parcs> > let(!)=div;f n=1:n:1:f(n+2);w@(x:y)%[a,b,c,d]|t<-a!c,c+d>1,t==b!d=t:w%[10*(a-c*t),10*(b-d*t),c,d]|0<1=y%[x*a+b,a,x*c+d,c]in(2:f 2)%[1,0,0,1]>>=show
19:57:43 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
19:57:57 <shachaf> You need to fit it in 140 characters.
19:58:25 <roconnor> > exp(1) :: CReal
19:58:26 <lambdabot>   2.7182818284590452353602874713526624977572
19:58:33 <cmccann> shachaf, anyway in theory my tuples should have been unpackable if they were defined directly I think, but my type family trickery and whatnot to get generic operations didn't seem reconcilable with unpacking :[
19:58:41 <roconnor> done
19:59:16 <shachaf> roconnor: Does not count.
19:59:21 <roconnor> ;(
20:02:48 <PiRSquared17> What does endofunctor want say?
20:03:07 <shachaf> What?
20:03:19 <PiRSquared17> Err, been doing too much Frencj
20:03:23 <PiRSquared17> What does endofunctor mean?
20:03:45 <roconnor> PiRSquared17: a functor whose codomain equals its domain
20:03:59 <PiRSquared17> OK
20:04:01 <PiRSquared17> Thank you
20:06:54 <parcs> shachaf: if the :| constructor were hidden, and you can only pattern match using the comma notation/sugar, there wouldn't be any extra bottoms, practically speaking
20:07:46 <parcs> ah but if the constructor were hidden you can't define n-tuple-like functions
20:08:23 <parcs> time to go nap nap
20:20:55 <Jafet> > let f d(p,q)=p*d`div`q;g d(x:y:s)|f(d^2)y-f(d^2)x<1=mod(f d x)10:g(10*d)s|True=g d s in 2:g 10(scanl(\(p,q)i->(p*i+1,q*i))(1,1)[1..])>>=show -- shachaf
20:20:57 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
20:21:00 <Jafet> Easy!
20:24:45 <Jafet> > let f d(p,q)=p*d`div`q;g(x:y:s)d|f(d^2)y-f(d^2)x>0=g s d|True=mod(f d x)10:g s(10*d)in 2:g(scanl(\(p,q)i->(p*i+1,q*i))(1,1)[1..])10>>=show -- 138
20:24:46 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
20:25:47 <Saizan> is it still the same algorithm?
20:26:04 <shachaf> Doesn't look like it. :-(
20:26:10 <shachaf> Jafet: That can be cut down further. :-)
20:26:22 <shachaf> Jafet++
20:26:49 <shachaf> > let f d(p,q)=p*d`div`q;g(x:y:s)d|f(d^2)y-f(d^2)x>0=g s d|0<1=mod(f d x)10:g s(10*d)in 2:g(scanl(\(p,q)i->(p*i+1,q*i))(1,1)[1..])10>>=show
20:26:50 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
20:27:05 <Jafet> Heh
20:27:41 <shachaf> Jafet: This one is much slower than the other one, though.
20:28:26 <Jafet> It's also not proven to be correct.
20:29:06 <shachaf> It also has an annoying \ in it which makes "length" take extra effort to use.
20:30:15 <shachaf> > let w(p,q)i=(p*i+1,q*i);f d(p,q)=p*d`div`q;g(x:y:s)d|f(d^2)y-f(d^2)x>0=g s d|0<1=mod(f d x)10:g s(10*d)in 2:g(scanl w(1,1)[1..])10>>=show -- same length, no \
20:30:16 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
20:31:00 <Jafet> wc -c is your friend
20:31:27 <Jafet> length <*> getLine
20:31:40 <Jafet> Er, <$>
20:31:44 <shachaf> Jafet: How do I get it from my ghci prompt to wc -c?
20:31:56 <Jafet> :! ?
20:32:16 <shachaf> And echo?
20:34:15 <Jafet> I used my algorithm because it is much, much simpler
20:34:34 <Jafet> However, proving its correctness might be less simple
20:37:58 <Jafet> And I highly doubt this one is correct
20:38:02 <Jafet> > let f d(p,q)=p*d`div`q;g(x:y:s)d|f d y-f d x>0=g s d|0<1=mod(f d x)10:g s(10*d)in 2:g(scanl(\(p,q)i->(p*i+1,q*i))(1,1)[1..])10>>=show
20:38:03 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
20:38:56 <Josh_> hey people watch this funny vidoe i found
20:38:58 <russellw> The output looks correct to me, or did you mean that was the first test?
20:39:09 <Josh_> http://www.youtube.com/watch?v=_hU6iZyEVX8
20:39:15 <Josh_> http://www.youtube.com/watch?v=hVQG1MswY-k
20:39:40 <shachaf> @where ops
20:39:41 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:39:52 --- mode: ChanServ set +o copumpkin
20:40:07 <Jafet> Well, if you want to look at all infinity outputs
20:40:14 <copumpkin> Josh_: please don't do that in here
20:40:34 <mauke> Josh_: that was stupid
20:40:47 <lewis1711> probably a bot
20:41:20 <russellw> I will grant no finite quantity of output constitutes formal proof of correctness, but you said highly doubt, and that's enough digits that for them to be all correct by chance would seem less probable than hallucinating the experience of having seen a formal proof?
20:41:29 <Josh_> who you called a bot i am a robot
20:41:45 <copumpkin> Josh_: are you interested in haskell?
20:41:53 <Josh_> yes
20:42:05 <mauke> what's a haskell?
20:42:09 <copumpkin> Josh_: tell me more
20:43:44 <Jafet> By the way, they're not as funny as this video: http://www.youtube.com/watch?v=XZ5TajZYW6Y
20:43:49 <lewis1711> haskell is like both programming things with maths except instead of regular maths there's a computer there that tells you exactly how you messed up
20:44:09 <copumpkin> Jafet: ತ
20:44:13 <copumpkin> ತ_ತ
20:44:15 <mzero> Is there a funny use of monads in it? otherwise, I'm not interested...
20:44:38 * cmccann needs to make a "monads and strife" flash video
20:44:50 <copumpkin> ooh, cmccann is back!
20:45:26 <lewis1711> monads are monoids of something something
20:45:41 <copumpkin> lewis1711: monoid objects in the monoidal category of endofunctors
20:46:00 <cmccann> copumpkin, following a month or so of lots of annoying real life crap taking all my free time
20:46:06 <copumpkin> aww
20:46:07 <mikeplus64> "monoid objects" "monoidal category" "endofunctors", wat
20:46:11 <lewis1711> lambdabot should have that, if he doesn't
20:46:14 <copumpkin> cmccann: is it over?
20:46:15 <lewis1711> lambdabot: .monads
20:46:20 <copumpkin> @quote monoid
20:46:21 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
20:46:29 <augur> russellw: you are wrong about the job of a linguist.
20:46:42 <cmccann> copumpkin, yeah, was just a confluence of being busy at work and little things all coming up at once
20:46:47 <lewis1711> I should learn what an endofunctor is. monoid I'm cool with
20:46:52 <copumpkin> cmccann: ah, good :)
20:46:55 --- mode: copumpkin set -o copumpkin
20:46:59 <augur> copumpkin: hey!
20:47:01 <DanBurton> @google what is an endofunctor
20:47:02 <lambdabot> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
20:47:02 <lambdabot> Title: haskell - A monad is just a monoid in the category of endofunctors, what's the p ...
20:47:23 <copumpkin> greetings, sir augur
20:47:24 <cmccann> ended up half burned out and decided to hide from the world until stuff blew over, heh
20:47:27 <DanBurton> category theorists should probably be mad that SO is the first hit for that
20:47:41 <PatrickRobotham> DanBurton: A functor F turns a category C in to a category D
20:48:00 <PatrickRobotham> DanBurton: The functor obeys the following rule: F(g.f) = F(g) . F(f)
20:48:05 <cmccann> DanBurton, how could anyone be mad after reading that excellent history of programming languages though
20:48:21 <lewis1711> what's the single associative binary operation of a monad?
20:48:27 <PatrickRobotham> DanBurton: An endofunctor is a functor from C to C.
20:48:50 <copumpkin> lewis1711: it's a slightly more general notion of monoid than you're used to
20:49:06 <lewis1711> oh
20:49:08 <copumpkin> but it'd be composition of functors
20:49:08 <lewis1711> :(
20:49:33 <lars9> is a >=> b >=> c == a >=> (b >=> c) ?
20:50:04 <lars9> :t a >=> b >=> c
20:50:05 <lambdabot>     Couldn't match expected type `a -> m b'
20:50:05 <lambdabot>            against inferred type `Expr'
20:50:06 <lambdabot>     In the first argument of `(>=>)', namely `a'
20:50:22 <copumpkin> lewis1711: the identity is the identity functor
20:51:22 <DanBurton> lars9: >=> is associative, so it's equivalent
20:51:43 <DanBurton> @info (>=>)
20:51:43 <lambdabot> (>=>)
20:51:50 <DanBurton> ...
20:51:51 <cmccann> that much of it really isn't any different from the monoid of function composition
20:52:08 <lewis1711> meh i still suck too much at haskell for this. I'm annoyed there's nothing more on FP at my university
20:52:31 <copumpkin> lewis1711: study it on your own :) most of us didn't get much or any FP at school :/
20:52:35 <DanBurton> infixr 1
20:53:02 <cmccann> all I learned in school was C++, as taught by people who used it like C
20:53:12 <cmccann> except for one guy who used it like pascal
20:53:16 <lars9> :t (let f a = [a] in f >=> f >=> f)
20:53:16 <copumpkin> you mean it's not meant to be used that way??
20:53:17 <lambdabot> forall a. a -> [a]
20:53:25 <lars9> :t (let f a = [a] in f >=> (f >=> f))
20:53:26 <lambdabot> forall a. a -> [a]
20:53:28 <lewis1711> copumpkin: yeah I am :) still
20:53:29 <cmccann> copumpkin, C++ is not meant to be used at all
20:53:34 <cmccann> if you really get down to it
20:53:37 <lewis1711> cmccann: my condolences
20:53:39 <DanBurton> cmccann: I was a TA this semester for a teacher that taught C++ but used it like Racket :)
20:53:50 <lewis1711> lol
20:54:02 <lars9> > let f a = [a, a] in (f >=> f >=> f) 1
20:54:04 <lambdabot>   [1,1,1,1,1,1,1,1]
20:54:07 <cmccann> DanBurton, that's perturbing in novel ways
20:54:13 <lars9> > let f a = [a, a] in (f >=> (f >=> f)) 1
20:54:15 <lambdabot>   [1,1,1,1,1,1,1,1]
20:54:26 <DanBurton> I'm doing research for him next semester; working on Typed Racket; I'm pretty excited.
20:54:40 <cmccann> ah, that sounds neat
20:55:00 <lars9> its cool excepts (((((s
20:57:52 <Saizan> C++ might be the new BASIC
20:59:44 <lars9> i've used c++ for many years but still don't remember how constructor works in all situations, sometimes i made to remember them all, but only lasted several days
21:01:17 <dbelange_> C++ is easy
21:01:27 <dbelange_> I know all of C++'s features forwards and backwards
21:01:54 <dbelange_> I like haskell because it's more of a challenge
21:02:07 <mauke> I know C++ forwards and backwards: ++C
21:02:29 <mauke> dbelange_: are you serious?
21:02:43 <lars9> mauke: no that's not revered C
21:02:46 <cmccann> learning all of C++'s features isn't that hard, I wrote at least three segfaults in my first week using it
21:03:16 <luite> is that the most important C++ feature?
21:03:24 <copumpkin> it's the only one
21:04:10 <cmccann> copumpkin, no there's also buffer overrun vulnerabilities
21:04:21 <luite> hmm, I'i'd better stat looking for segfault tutorials then
21:04:40 <copumpkin> cmccann: don't forget the ever-important format string vulnerabilities
21:04:56 <cmccann> though maybe buffer overruns just count as legacy support for C programs, where properly written C++ should just crash hard
21:05:15 <mauke> cin >> str;  // perfectly good C++ buffer overrun
21:05:48 <cmccann> mauke, hm, fair enough. been a while since I've used C++ to any significant extent
21:05:53 <shachaf> dbelange_: Do you know how name resolution works in C++?
21:07:30 <dbelange_> name resolution in C++ is extremely complicated as it involves:
21:07:31 <dbelange_> * namespaces, which make it possible for an identifier to have different meanings depending on its associated namespace;
21:07:34 <dbelange_>  * scopes, which make it possible for an identifier to have different eanings at different scope levels, and which involves various scope overriding and hiding rules. At the most basic level name resolution usually attempts to find the binding in the smallest enclosing scope, soc that for example local variables supersede global variables; this is called shadowing. * visibility rules, which determine whether identifiers from specific namespac
21:07:40 <dbelange_>  * accessiility, which determines whwether identifiers from an otherwise visible scope are actually accessible and participate in the name resolution process.
21:08:13 <mauke> dbelange_: is that a "no"?
21:08:21 <clsmith_> hey all. what would be the best way to 'show' a unicode haskell String as a valid C string (this is for a compiler)?
21:08:39 <dbelange_> mauke I said features, not bugs
21:08:56 <mauke> dbelange_: so name resolution is a bug?
21:09:18 <mauke> clsmith_: depends on how you want to encode it
21:09:26 <soiamso> clsmith_: encode to utf8 as bytestring ?
21:09:27 <dbelange_> yeah, dynamic name resolution was a bug
21:09:38 <clsmith_> i want utf8, sorry
21:09:41 <dbelange_> but the programmers started to like it so they couldn't just standard it out
21:09:41 <mauke> C++ doesn't do dynamic name resolution
21:10:06 <clsmith_> soiamso: does showing a bytestring 'render' to a valid C string?
21:10:06 <mauke> and the question was about name resolution in general
21:10:25 <shachaf> clsmith_: A ByteString is a string of bytes.
21:10:42 <shachaf> It doesn't have an encoding. However, you can use encodeUtf8 or something like that to encode into a ByteString.
21:10:48 <shachaf> I don't think that'll give you the \0, though.
21:10:51 <soiamso> clsmith_: pass pointer
21:11:33 <mauke> shachaf: what \0?
21:11:52 <shachaf> mauke: I think that's usually associated with the phrase "C string".
21:11:54 <clsmith_> i don't need \0, i suppose i just need escaped quotes and chars outside printable ascii
21:11:59 <mauke> ah, interpretation differences
21:12:00 <shachaf> Oh.
21:12:03 <shachaf> I must have misunderstood.
21:12:08 <mauke> I thought the goal was to generate C code
21:12:13 <clsmith_> yeah
21:12:13 <mauke> including C data literals
21:12:17 <shachaf> mauke: Apparently it was. :-)
21:12:29 <mauke> if you're lazy, just escape everything
21:12:40 <mauke> I mean represent every byte in hex or octal
21:13:44 <clsmith_> yeah, i suppose i could
21:13:57 <clsmith_> i'll see how it looks when i show a bytestring
21:15:21 <mauke> > BS.pack [65, 66, 255]
21:15:23 <lambdabot>   "AB\255"
21:15:26 <mauke> not good
21:16:34 <shachaf> Yes, GHC uses decimal escapes.
21:16:47 <clsmith_> that's weird
21:17:47 <soiamso> clsmith_: base64 ?
21:18:28 <clsmith_> what about base64?
21:18:37 <clsmith_> also, what utf8 lib should i use? there seem to be many.
21:19:20 <clsmith_> i think i'll go with utf8-string, on the basis that it's newer :p
21:19:31 <lars9> how to generate this kind of infinite list: l!!n = f (take n l)
21:21:26 <mauke> f [], f [f []], f [f [], f [f []]], ... whoa
21:22:09 <mauke> lars9: like that
21:22:23 <mauke> l = map (\n -> f (take n l)) [0 ..]
21:23:35 <lars9> > let f = length in let l = map (\n -> f (take n l)) [0 ..] in l
21:23:37 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
21:23:42 <lars9> mauke: neat
21:27:36 <nkp> hi
21:28:39 <nkp> hi
21:28:52 <nkp> hi
21:29:20 <Clint> go on
21:29:35 <shapr> nkp: What's your opinion of OCaml?
21:31:48 <nkp> what?
21:32:49 <lars9> shapr: you scared him away
21:33:22 <shapr> Oh well.
21:33:25 <shapr> I do that sometimes.
21:33:36 <mauke> shapr++  # nicely done
21:33:38 <shapr> lars9: but YOU aren't scared, right?
21:33:51 <lars9> shapr: no, i like ocaml
21:34:09 <shapr> OCaml scares me, or maybe it's just Harrop that scares me.
21:35:27 <lars9> when using ocaml, i miss typeclasses in haskell; when using haskell, i miss modules in ocaml.
21:35:55 * araujo throws a sugar lambda at shapr 
21:36:06 * shapr eats the sugar lambda
21:36:12 <araujo> shapr!!
21:36:16 <araujo> long time no see
21:36:17 <araujo> :)
21:36:22 <shapr> araujo: hola! long time no see indeed!
21:36:27 <shapr> araujo: How's code lately?
21:36:35 <araujo> shapr, hehehe, how that goes mate?
21:36:45 <araujo> shapr, it goes good .. though not much haskell these days :(
21:36:59 <shapr> Same here, I'm doing mostly C++ for my undergrad degree.
21:37:13 * araujo in middle of C/C++ too!
21:37:13 <shapr> But tonight I'm learning Yesod, and that is a mighty fine framework!
21:37:25 <shapr> araujo: Are you getting your CS undergrad as well?
21:37:34 <araujo> shapr, hehe no, not really .. job
21:37:38 <araujo> :P
21:38:12 <shapr> Ah, I see. I've actually had a job doing Haskell, and have been offered other FP jobs, but I want to finish my degree no matter what.
21:39:08 * araujo thinks shapr could easily found a haskell co. too
21:39:27 <araujo> shapr, aah good!, ... that is the reason i don't usually see you around here too often?
21:40:07 <shapr> Yes, slowly working my way through my undergraduate degree.
21:40:32 <araujo> shapr, not much Haskell there atm?
21:40:58 <shapr> No, none of my professors use Haskell. Though one of them did just get into Python.
21:41:15 <araujo> aaah... well, that is good ....
21:41:20 <shapr> She tried to get me to be a TA for the Python class, but I ended up working night shift instead.
21:41:42 <shapr> Does your job let you write C++ on Linux?
21:42:05 <araujo> shapr, yeah
21:42:08 <kniu> why do we need operator precedences?
21:42:12 <araujo> I see :P
21:42:22 <shapr> kniu: What order should things be done without parentheses?
21:42:24 <kniu> like, what if every operator had the same associativity and precedence?
21:42:52 <kniu> shapr, I'm asking for more parentheses
21:42:59 <shapr> kniu: Then how would you decide the result of 2 + 3 * 4 ?
21:43:10 <kniu> 2 + (3 * 4)
21:43:21 <kniu> just
21:43:25 <kniu> make everything right associative
21:43:30 <kniu> or left
21:43:32 <kniu> or whatever
21:43:50 <shapr> 4 * 3 + 2 would be different, yes?
21:43:55 <Jafet> Why not go use APL
21:44:00 <mauke> kniu: smalltalk does that AFAIK
21:44:15 <mauke> tends to surprise people, though
21:44:16 <shapr> kniu: 4 * 3 + 2 would not be the same as 2 + 3 * 4, right?
21:44:30 <kniu> shapr, yes
21:44:32 <mauke> in most cases people expect operator precedence
21:45:09 <mauke> because there's only one sensible way to interpret x == y + 1 || x * 2 < z
21:45:12 <shapr> kniu: A big part of programming is communication with other humans. The more you can use what humans already know outside of programming, the easier it is to communicate.
21:45:21 <kniu> hm
21:45:23 <kniu> good point
21:45:29 <shapr> kniu: In math class, certain operators are taught with precedence already.
21:45:47 <mauke> I think the +/*/math class stuff is a red herring (or at least less important)
21:46:07 <shapr> Well, the principle of least surprise is handy.
21:46:19 <shapr> http://en.wikipedia.org/wiki/Principle_of_least_astonishment
21:46:34 <kniu> I try to abide by the principle of "I don't want to have to memorize stuff"
21:46:46 <shapr> I also treasure that principle.
21:46:46 <russellw> I agree with mauke, the big issue is that the usual way of doing things usually does what you want
21:46:50 <mauke> the point is that a human can look at x == y + 1 || x * 2 < z and see only one sensible way to evaluate it
21:47:08 <russellw> The alternative of having to explicitly bracket everything is the way Lisp does things
21:47:18 <mauke> hmm
21:47:21 <kniu> and people don't like lisp?
21:47:26 <kniu> (don't answer that)
21:47:30 <russellw> And the reason most people don't use Lisp isn't because it surprises them, it's because they don't like it
21:47:33 <shapr> I do like lisp! But I prefer Haskell.
21:47:41 <russellw> ... Sorry, I was already halfway through writing the answer :-)
21:47:47 <mauke> in a way, like HM type systems, operator precedence occupies a sweet spot in language design
21:47:59 <russellw> yeah
21:48:00 <shapr> mauke: I'm not convinced humans can look at that expression and see only one sensible way to evaluate it.
21:48:16 <mauke> you could have type-directed parsing or something
21:48:20 <russellw> And if you're going to have any at all, you might as well use the usual precedence list
21:48:28 <mauke> or have everything associate to the left, as kniu suggested
21:48:55 <mauke> but giving each operator a fixed "precedence" is simple, efficient, and fairly intuitive for humans
21:49:12 <kniu> until you find yourself in the land of a hundred operators defined by other people
21:49:22 <mauke> depending on the operators you may then have to memorize a precedence table, but that's another issue
21:49:31 <kniu> a.k.a. Haskell combinator libraries
21:50:06 <russellw> Well that's the question of whether it's a good idea to allow code to define new operators with new levels of precedence
21:50:06 <shapr> So maybe a good question to ask is... is there a good way to come up with operator precedence and associativity for user defined operators?
21:50:26 <russellw> I'm not convinced it is, but that doesn't mean throwing out precedence for the built-in operators
21:51:11 <kniu> there were a few instances in which a confusion of precedence between (>>=), (.), and <$> caught me with my pants down
21:51:27 <kniu> or maybe it was (<=<)
21:51:39 <russellw> I mean prolog had a very neat way to define new operators three decades ago, but it by and large didn't catch on, and I think that's because the value isn't worth the added complexity
21:52:13 <russellw> kniu, well honestly I think Haskell goes a little over the top with the profusion of infix operators it defines
21:52:27 <russellw> But a little over the top doesn't mean they should all be abolished
21:53:19 <augur> russellw: you are wrong about the job of linguists vis-a-vis everything you said earlier
21:53:28 <russellw> oh?
21:53:52 <augur> yes.
21:53:59 <shapr> russellw: Are you a recent convert to the world of Haskell?
21:54:08 <shapr> russellw: Just curious, haven't seen you around much before.
21:54:29 <russellw> augur, care to elaborate? :)
21:54:42 <shapr> I've been a loooong time.
21:54:50 <shapr> er, been here
21:54:51 <augur> russellw: theres nothing to elaborate on. you're just wrong. that is not what linguists do.
21:55:40 <russellw> shapr, sort of, yeah. I'm working on a scripting language for an inference engine, and I've ended up with a design... Whether you would call it _like_ Haskell might be a matter of opinion, but it's more similar to Haskell than to any other language I've seen
21:56:31 <russellw> augur, then what word would you use to describe people whose field of expertise involves knowing things like the fact that collation order for exactly the same strings depends on the political affiliation of the person doing the sorting?
21:56:45 <russellw> Because it sure as hell isn't 'programmer'
21:57:21 <mauke> software engineer?
21:57:27 <russellw> rofl
21:57:37 <augur> russellw: "not linguist"
21:57:48 <russellw> If you said pizza delivery guy, you would probably be closer
21:58:10 <augur> i dont think there _is_ anyone who's field of expertise involves knowing that sort of thing
21:58:43 <tomprince> Unicode comitte members?
21:58:56 <mauke> "unicoder"
22:00:04 <russellw> Regardless, my point stands: if you need to collate general natural language strings, use a library designed by an expert in this field that cannot be named. Don't try to hack up a homebrew solution unless you yourself are such an expert
22:00:29 <russellw> It's like databases or cryptography in being an area where DIY should be positively discouraged
22:01:26 <augur> russellw: there are no such experts
22:02:04 <russellw> Then people have a problem, don't they? :)
22:02:52 <Jafet> Damned politics
22:03:04 <augur> russellw: yes, they do
22:03:10 <augur> now you know why Unicode is such a clusterfuck
22:03:55 <russellw> That's the sort of thing that makes me glad I'm just trying to solve nice straightforward NP-complete problems
22:04:04 <lewis1711> I don't see why we all can't use ASCII. if it was good enough for jesus when he wrote the king james bible, it's good enough for me
22:05:29 <augur> russellw: hahaha
22:05:30 <Sgeo> Given these functions that do what they claim to do, is it possible to write a bottom :: a -> Bool that is correct and never returns bottom?
22:05:31 <Sgeo> http://hackage.haskell.org/packages/archive/acme-realworld/0.1.1/doc/html/Acme-RealWorld.html
22:05:33 <augur> well, yes.
22:14:39 <Maxdamantus> > hypothetically (putStrLn "abcd") >>= print
22:14:41 <lambdabot>   Not in scope: `hypothetically'
22:24:44 <kniu> I just realized what my beef was with the number comparison operators
22:24:51 <kniu> you can't chain them
22:25:12 <kniu> they're not one of those "foldable" operators, like arithmetic ones
22:28:23 <shachaf> kniu: Also true of (==).
22:28:50 <kniu> yeah
22:29:10 <kniu> I think making operators should be reserved for things that you want to chain together
22:29:22 <shachaf> I don't.
22:29:30 <kniu> shachaf, why?
22:29:56 <mauke> that would remove ==, /=, >, <, >=, <=
22:30:15 <kniu> which I think is the Right Thing to do
22:30:29 <kniu> because the only reason we have them is because of culture
22:30:44 <kniu> if there was no cultural precedence we'd just define them as plain old functions
22:30:52 <shachaf> kniu: That's true for a lot more of Haskell than those operators.
22:31:02 <mauke> kniu: and?
22:31:07 <mauke> that's a pretty good reason to have them
22:31:08 <kniu> I dunno
22:31:17 <kniu> frees them up for other purposes
22:31:29 <mauke> oh, like IO
22:31:36 <mauke> cout << "hello world";
22:32:10 * applicative flees in horror
22:32:16 <kniu> more like
22:32:21 <kniu> combinators
22:33:02 <kniu> what if we could just write (>=) instead of (>>=)?
22:33:37 <kniu> and (<=) makes a good "arrow" of some kind
22:33:38 <vhd> In gtk2hs program, I need to track users actions. What is the best route to doing this?
22:33:44 <catface> $ ought to be an arrow
22:33:48 <shachaf> kniu: <= is implication!
22:34:15 <shachaf> kniu: Except in the opposite direction of the arrow's direction.
22:34:27 * shachaf notes that you can fold comparison operators if you happen to use them on Bool. :-)
22:34:41 <mauke> explication?
22:44:38 <vhd> in wadlers paper monads for functional programming (http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf) in section 4.2 he rewrites the interpreter, the function "eval (Var i) = fetch i" confused me, you still need to pass in as an argument the state, yes?
22:47:57 <vhd> which leads me to the point, how can one keep track of state and pass it around in a app using gtk2hs as the main loop is done by Gtk+.
22:48:53 <vhd> what would be the "right" way to handle signals that vary depending on users past actions.
22:52:37 <kniu> vhd, do you want something like a "global variable"?
22:52:57 <vhd> kniu, yes that would be ideal.
22:53:58 <kniu> well
22:54:18 <kniu> the Haskell Way to do it is to define your own monad
22:54:56 <vhd> I get that, which is why wadlers paper confused me, because the state monad would still require passing in the state?
22:54:59 <kniu> where you have some thing :: m (Ref t)
22:55:00 <vhd> or am I missing something.
22:55:26 <kniu> so that you can write do {ref <- thing; do_whatever_with_thing)
22:55:32 <kniu> vhd, well yes
22:55:38 <kniu> but it hides the actual "passing" in the monad itself
22:55:50 <kniu> so you don't have to thread thing everywhere
22:56:17 <kniu> it quickly gets annoying to have to specify the same thing as a parameter for every function you write
22:56:26 <mauke> I didn't read the paper. kniu: did you read the paper?
22:56:43 <kniu> I didn't either, but I came across his problem before.
22:56:54 <mauke> unlikely
22:56:59 <kniu> oh/
22:57:00 <kniu> ?
22:57:05 <Enigmagic> vhd: just make a global variable?
22:57:06 <mauke> since the question is about code from the paper
22:57:24 <kniu> how can one keep track of state and pass it around in a app
22:57:28 <kniu> that's what he asked
22:57:38 <mauke> now I have to look at the paper
22:57:45 <kniu> and I'm telling him he can't have state as a global variable in Haskell
22:57:59 <Enigmagic> kniu: you certainly can
22:58:01 <kniu> it just doesn't work (unless you hack it with UnsafePerformIO, but he shouldn't do that)
22:58:01 <vhd> mauke, you dont really have to look at the paper, kniu is on the right track
22:58:36 <kniu> I'm telling him that his "global variable" does, yes indeed, have to be passed into every function he writes
22:58:44 <vhd> kniu, have you used the gtk2hs library before?
22:58:51 <kniu> but the Haskell way is to abstract that away into his own custom monad
22:58:55 <kniu> vhd, no
23:00:22 <vhd> ok, well the library has its own loop, which handles signals you set up and what to do at these signals, I dont know how I would be able to pass in "updated" states.
23:00:38 <kniu> first off, what do you mean by "pass in"?
23:01:07 <vhd> I mean, pass in as a parameter to a function.
23:01:18 <kniu> what function, then?
23:01:22 <kniu> can you hpaste your code?
23:01:26 <vhd> a function that I define
23:01:46 <vhd> uh, I do not have anything I can paste, just trying to wrap my head around this first.
23:01:57 <kniu> well, whip up some pseudocode
23:02:02 <kniu> it doesn't even have to be haskell
23:02:07 <vhd> ok hold on
23:02:13 <mauke> ah, I see. fetch is indeed monadic
23:03:42 <kniu> actually, I was wrong
23:03:50 <kniu> he doesn't have to define his own monad
23:03:55 <kniu> just use State
23:04:29 <kniu> where s is the type of the "global variable" in "State s a"
23:05:01 <mauke> won't quite work if you're in IO ()
23:05:14 <kniu> StateT?
23:05:24 <mauke> won't quite work if you're in IO ()
23:06:27 <vhd> kniu, http://hpaste.org/55059 in this code I use function swap to change image to cross if it is circle and vice versa, say I wanted to track what the previous two images were and only swap if previous two images were circle. That is effectively what I want to do.
23:08:12 <Enigmagic> vhd: i'd say you're probably stuck with using a global variable
23:08:22 <kniu> no, don't listen to him
23:08:34 <Enigmagic> kniu: yeah, so what would you recommend instead?
23:08:49 <vhd> Enigmagic, I think so too but want to see if there is a "proper" way first.
23:08:58 <kniu> vhd, read this http://www.haskell.org/haskellwiki/Simple_StateT_use
23:09:03 <vhd> im not very experienced with haskell anyway
23:09:08 <Enigmagic> kniu: how does StateT work in IO?
23:09:29 <Enigmagic> particularly in (IO Bool).
23:09:44 <kniu> it lets you use liftIO?
23:09:55 <kniu> like, that's pretty simple
23:10:16 <kniu> in StateT s IO a you can liftIO any_io_action
23:10:17 <Enigmagic> kniu: yeah, so how do you return a StateT a IO Bool when the type should be IO Bool?
23:10:25 <mauke> kniu: won't quite work if you're in IO ()
23:10:37 <kniu> runStateT
23:10:44 <mauke> kniu: that buys you nothing
23:11:01 <Enigmagic> kniu: how does runStateT return an IO Bool?
23:11:18 <mauke> Enigmagic: no, where do you get the initial state from?
23:11:32 <mauke> and will you do with the new state
23:11:37 <Enigmagic> mauke: it's the same question really.
23:11:49 <Enigmagic> the state is discarded
23:11:49 <kniu> > runStateT
23:11:50 <lambdabot>   Overlapping instances for GHC.Show.Show
23:11:50 <lambdabot>                              (Contr...
23:11:52 <mauke> no, because returning an IO Bool from runStateT is trivial
23:11:52 <kniu> hm
23:12:17 <kniu> > runStateT (do {s <- get; return s}) True
23:12:18 <lambdabot>   No instance for (GHC.Show.Show (m (GHC.Bool.Bool, GHC.Bool.Bool)))
23:12:18 <lambdabot>    arisi...
23:12:41 <Sgeo> @unmtl StateT s IO a
23:12:42 <lambdabot> s -> IO (a, s)
23:13:07 <kniu> mauke, what is your objection
23:13:27 <mauke> kniu: where do you get the initial state from and where are you going to store the final state?
23:13:39 <kniu> you pass in the initial state to runStateT
23:13:44 <mauke> kniu: irrelevant
23:13:45 <mauke> kniu: where do you get the initial state from and where are you going to store the final state?
23:14:06 <kniu> what he hell are you getting at?
23:14:10 <mauke> dude.
23:14:15 <Enigmagic> vhd: short answer is: start with an IORef and unasfePerformIO. it's not preferred but the API you're using is poorly designed.
23:14:18 <mauke> which part of this is unclear?
23:14:22 <kniu> Enigmagic, stop that nonsense
23:14:22 <mauke> Enigmagic: why unsafePerformIO?
23:14:29 <kniu> mauke, how would you do it
23:14:35 <mauke> kniu: do what?
23:14:35 <Enigmagic> kniu: go write some code that compiles.
23:14:45 <mauke> Enigmagic: I mean, I can see how IORef would solve the problem, but why would you need unsafePerformIO?
23:14:46 <kniu> like, I'm pretty sure StateT Int IO a would solve his problems
23:14:53 <Enigmagic> kniu: go write some code that compiles.
23:15:01 <kniu> okay fine
23:15:08 <Enigmagic> mauke: you don't need an unsafePerformIO but he's writing a GUI app.
23:15:12 <mauke> kniu: you could start by answering my question
23:15:14 <Enigmagic> it's already single threaded.
23:15:18 <mauke> Enigmagic: ok, and?
23:15:37 <kniu> mauke, I'm seeing where you're getting at now
23:15:38 <vhd> Enigmagic, ok, I will have a look at that. Thank you.
23:15:44 <kniu> you want the thing to be stored in an IORef
23:15:45 <kniu> very well
23:15:51 <kniu> we'll store the damn thing in an IORef
23:16:11 <Enigmagic> vhd: no problem :^)
23:16:17 <mauke> at an abstract level we want the button click handler to have memory
23:16:37 <mauke> and since the handler is in IO, it makes sense to use a mutable variable for this
23:16:53 <mauke> what I don't understand is where State and unsafePerformIO come in
23:17:33 <kniu> @hoogle newIORef
23:17:34 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
23:18:03 <Enigmagic> mauke: State/StateT do not come into the picture at all. unsafePerformIO is reasonable when you're dealing with single threaded GUI frameworks for global state, imo. sometimes its required, sometimes its not.
23:18:11 <mauke> Enigmagic: why global state?
23:18:13 <mauke> this is local state
23:18:17 <Enigmagic> in this particular case, it's probably not required.
23:18:40 <Enigmagic> is there anything gained when the C/C++ code is single threaded by design? i'm not so sure.
23:19:02 <mauke> and where do threads come in?
23:19:06 <mauke> why does that matter?
23:19:25 <MostAwesomeDude> Haskell threads are not POSIX threads.
23:19:47 <Enigmagic> video cards work better when a single thread talks to them.
23:19:57 <MostAwesomeDude> Kinda but not really.
23:20:21 <MostAwesomeDude> Those video cards that don't have context switching in HW (intel, radeon, etc.) have to resend state regardless of what's happened in-between frames.
23:21:35 <Enigmagic> gross oversimplification, but there tends to be a reason why there is a single render thread or a global lock around the video card.
23:22:10 <MostAwesomeDude> The reason is that D3D and GL have their own internal thread-local state which can be clobbered if not locked, so multiple threads tend to contend the GL/D3D context.
23:22:41 <Enigmagic> yep, because locking a region is slow
23:22:50 <MostAwesomeDude> Modern GPU command submission is lockless and blocking, and in fact a couple Mesa drivers use threading to handle that blocking submission while allowing their clients to continue sending GL commands.
23:23:03 <MostAwesomeDude> (Modeled after fglrx, which I'm told does the same thing.)
23:24:12 <MostAwesomeDude> Anyway, I think we're off-topic. :3
23:24:23 <hpaste> kniu pasted “This is Stupid” at http://hpaste.org/55060
23:24:30 <Enigmagic> i usually am
23:24:32 <kniu> it compiles
23:24:34 <kniu> run it
23:24:44 <kniu> no unsafePerformIO needed
23:24:48 <mauke> kniu: and where's the IO () part?
23:25:00 <Enigmagic> heh
23:25:02 <mauke> heh, "return 0"
23:25:10 <mauke> that is cute
23:25:21 <mauke> kniu: ghc will ignore anything you return from main
23:25:26 <kniu> shit
23:25:31 <kniu> I was stuck in C mode for some reason
23:26:04 <lewis1711> can you not use "read" in interactive mode or something?
23:26:07 <lewis1711> > read "3"
23:26:08 <lambdabot>   *Exception: Prelude.read: no parse
23:26:13 <mauke> sure you can
23:26:17 <mauke> > read "()"
23:26:19 <lambdabot>   ()
23:26:22 <kniu> mauke, I still don't understand what you're getting at
23:26:35 <mauke> kniu: which part of "IO ()" is unclear?
23:26:41 <lewis1711> > read "3" :: Int
23:26:42 <lambdabot>   3
23:26:45 <bertolo> hi all
23:26:46 <kniu> what needs to be :: IO ()
23:26:47 <lewis1711> oic
23:26:53 <kniu> what is it that you want to have that type
23:26:55 <mauke> kniu: the code that reads from the IORef
23:26:59 <mauke> kniu: i.e. the callback
23:27:20 <bertolo> can anyone help me with very newbie fuction?
23:27:42 <Enigmagic> bertolo: sure, unless you're using gtkhs ;-)
23:27:53 <bertolo> can i pm you?
23:28:32 <bertolo> i have a funtion that trows me some IO()
23:28:36 <bertolo> recursively
23:28:42 <bertolo> i get it well
23:28:45 <Enigmagic> sure
23:28:47 <bertolo> first 20 lines are ok
23:28:53 <bertolo> next 20 lines are ()
23:28:56 <bertolo> "()"
23:28:59 <bertolo> without ""
23:29:00 <kniu> vhd, do you need a callback?
23:29:10 * mauke cries
23:29:18 <bertolo> i think its better for you to check code
23:29:19 <bertolo> :S
23:29:23 <vhd_> kniu: I don't know what that is, yet.
23:29:35 <kniu> mauke, you're making me cry
23:29:36 <Enigmagic> kniu: it might be a good idea to look at the sample he posted first
23:29:38 <kniu> jesus christ
23:29:42 <kniu> I read it
23:29:57 <kniu> I'm pretty sure what I got solves his problem
23:29:59 <mauke> vhd_: your button handler
23:30:02 <Enigmagic> bertolo: put it up on gist.github.com or hpaste and send out a link
23:30:33 <Enigmagic> kniu: if the API he was using allowed arbitrary MonadIO instances it would with a little work
23:30:45 <kniu> then just
23:30:54 <kniu> do the runReaderT
23:31:00 <kniu> and get back the IO ()
23:31:00 <hpaste> bertolo pasted “bertolonooob” at http://hpaste.org/55061
23:31:03 <kniu> that you stuff into the callback
23:31:10 <kniu> it's not that frickin complicated
23:31:14 <Enigmagic> kniu: where do you stuff the state?
23:31:18 <mauke> kniu: or I could make it a function parameter
23:31:24 <mauke> kniu: why bother with ReaderT at that point?
23:31:28 <bertolo> Enigmagic, check main function execute it with main 2.7 0.1 20
23:31:41 <bertolo> this will be solved
23:31:48 <bertolo> in 30 seconds by experienced user im sure
23:32:45 <kniu> you know, mauke
23:32:50 <Enigmagic> bertolo: are you trying to fix a build break or a logic bug?
23:32:55 <kniu> you could have said that in the first place
23:33:07 <bertolo> no logic bugs i think
23:33:12 <bertolo> i mean, the code compiles
23:33:16 <kniu> instead of being all cute and asking me a bunch of pointed questions
23:33:30 <bertolo> and it does correctly, but somehow im adding () n times in end of output
23:33:47 <bertolo> must be something in function mainAux
23:33:50 <mauke> kniu: why did you assume my questions were pointed?
23:33:53 <kniu> vhd_'s original question was that he needed a "global variable"
23:34:14 <kniu> which indicated to me that he wanted something he didn't have to pass around all the time
23:34:27 <bertolo> Enigmagic, this is my last problem in some work i have to present in some hours, if u find it il worship you forever
23:34:35 <bertolo> :D
23:34:36 <kniu> which is why I suggested the ReaderT because that would save him from that
23:34:44 <mauke> no, you suggested State
23:34:56 <Enigmagic> bertolo: lemme take a look
23:34:59 <bertolo> okok
23:35:05 <kniu> which also solves his "global variable" problem, in the situation where IO was not a factor
23:35:18 <bertolo> haskell has global variables?
23:35:20 <bertolo> o_O
23:35:37 <bertolo> nevermind
23:36:25 <Enigmagic> bertolo: https://gist.github.com/20c04a83bff576eafa9c
23:36:43 <Enigmagic> bertolo: modified line 126
23:37:06 <bertolo> il test sec
23:37:08 <mauke> kniu: in fact, looking back I think I asked you two questions
23:37:23 <mauke> kniu: and one now
23:37:27 <Enigmagic> i had to rename main to main2 to let it load in ghc 7.2
23:37:28 <mauke> kniu: and you never answered any of them
23:37:32 <bertolo> wow
23:37:38 <mauke> kniu: this is extremely annoying
23:37:58 <bertolo> Enigmagic,  thanks btw can u explain what i was doing?
23:38:16 <bertolo> i am new to haskell, very new
23:38:25 <kniu> <mauke> kniu: where do you get the initial state from and where are you going to store the final state?
23:38:30 <bertolo> i dont understand how can i get 2 outputs using IO
23:38:36 <bertolo> like i just did lol
23:38:39 <bertolo> a and b
23:38:40 <mauke> kniu: yes, that's the first question
23:38:47 <kniu> what's the other one?
23:38:55 <Enigmagic> bertolo: plotState returns a (), so x <- plotState; print x; was printing out a lot of "()" strings
23:39:01 <mauke> <mauke> kniu: and where's the IO () part?
23:39:14 <mauke> kniu: you were talking about "a bunch of questions"
23:39:38 <mauke> no, "a bunch of pointed questions"
23:39:45 <kniu> weren't those pointed?
23:39:46 <Enigmagic> bertolo: you could also change "a <- plotState s" to "plotState s" and it would work just as well :-)
23:39:50 <kniu> you obviously had an objection
23:39:58 <kniu> and you didn't say what it was
23:40:01 <mauke> kniu: no
23:40:15 <bertolo> Enigmagic, thanks alot
23:40:21 <bertolo> can we delete both codes?
23:40:28 <bertolo> so i dont get ppl copying it
23:40:29 <bertolo> plz
23:40:36 <bertolo> not likely to happen anywya
23:40:38 <Enigmagic> bertolo: sure, i've just deleted it.
23:40:45 <bertolo> dude thanks alot
23:40:47 <bertolo> <3
23:40:48 <Enigmagic> no problem
23:40:50 <bertolo> for real
23:40:52 <bertolo> u finished my work
23:40:53 <bertolo> :D
23:41:01 <kniu> asking something like "where is the IO () part?" when somebody posts a piece of code using StateT s IO a
23:41:03 <Enigmagic> hope your presentation goes well
23:41:07 <kniu> and liftIO
23:41:07 <bertolo> thanks
23:41:45 <mauke> kniu: no, let's stay with the first one
23:41:45 <kniu> that question is obviously not meant to be answered
23:41:50 <kniu> okay, the first one
23:42:06 <kniu> asking "where do you get the initial state from" when somebody suggests using State s a
23:42:15 <kniu> that's also obviously not meant to be answered
23:42:20 <mauke> what? why not?
23:42:27 <kniu> where do you get the initial state from?
23:42:33 <mauke> because that's precisely my object: I don't see where you're going to get the initial state from
23:42:38 <mauke> er, my objection*
23:42:46 <kniu> just
23:43:00 <kniu> I still don't get what that means
23:43:07 <kniu> where am I gonna get the original state from?
23:43:09 <kniu> anywhere?
23:43:18 <mauke> ... how?
23:43:26 <mauke> you can't just teleport values in
23:43:54 <kniu> you have a computation that needs to keep some state
23:44:05 <kniu> that state has some initial value that the programmer wants
23:44:18 <kniu> that the programmer decides he wants
23:44:19 <kniu> that is
23:44:21 <mauke> incomplete
23:44:28 <kniu> he KNOWS how to get it
23:44:34 <mauke> I have a computation OF TYPE IO () that needs to keep some state
23:44:46 <mauke> to which you said 'just use runStateT then'
23:45:00 <mauke> :t runStateT
23:45:01 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
23:45:10 <kniu> I am gonna scroll up and try to find where I answered that
23:45:12 <lewis1711> oh no, I have to learn about the maybe type
23:45:27 <mauke> but to use runStateT I need 1) an input and 2) I need to something with the result state
23:45:36 <Enigmagic> kniu: https://gist.github.com/3835cdb637678acf6829
23:45:54 <Enigmagic> kniu: please solve my programming question
23:45:56 <MostAwesomeDude> You'd fill it in as StateT s IO ()
23:46:14 <mauke> MostAwesomeDude: fill what in?
23:46:37 <MostAwesomeDude> mauke: Your StateT.
23:46:41 <mauke> what?
23:46:45 <mauke> MostAwesomeDude: I don't have a StateT
23:46:56 <MostAwesomeDude> Oh. Why aren't you using that to keep state?
23:47:07 <mauke> MostAwesomeDude: because I need to use IO ()
23:47:15 <kniu> mauke, you might notice
23:47:20 <kniu> that when I suggested State
23:47:28 <kniu> IO was not brought up yet
23:47:32 <mauke> yes, it was
23:47:36 <kniu> where?
23:47:46 <kniu> he said he wanted to pass state around
23:47:51 <Enigmagic> kniu: look at the original example.
23:48:23 <Saizan> is this still the gtk2hs question?
23:48:32 <vhd> unfortunately yes,
23:48:36 <kniu> Wadler's interpreter?
23:48:43 <mauke> kniu: <vhd> which leads me to the point, how can one keep track of state and pass it around in a app using gtk2hs as the main loop is done by Gtk+.  <vhd> what would be the "right" way to handle signals that vary depending on users past actions.  <vhd> ok, well the library has its own loop, which handles signals you set up and what to do at these signals, I dont know how I would be able to pass in "updated" states.
23:48:49 <kniu> IO was not mentioned in there anywhere
23:48:56 <Enigmagic> kniu: <kniu> like, I'm pretty sure StateT Int IO a would solve his problems
23:48:58 <mauke> kniu: but gtk2hs and its main loop was
23:49:10 <Enigmagic> kniu: you mentioned IO, so i guess it was relevant
23:49:44 <mauke> kniu: and you mentioned State right before vhd pasted the example with the button click handler
23:49:53 <kniu> right, before
23:50:02 <mauke> yeah
23:50:09 <Enigmagic> kniu: StateT Int IO a came up after
23:50:17 <mauke> in other words, while completely ignoring the gtk2hs/event stuff
23:50:53 <mauke> when you're dealing with a main loop that calls you, you have to make do with whatever interface the loop provides
23:50:53 <lewis1711> what is the point of maybe. shouldn't it just raise an exception?
23:50:57 <Saizan> vhd: did you get a solution btw?
23:51:11 <Enigmagic> kniu: so, regardless of what we've talked about so far. how would you modify this app with or without State/StateT? https://gist.github.com/3835cdb637678acf6829
23:51:18 <vhd> Saizan, I got some pointers. I have yet to work on it further.
23:51:19 <kniu> okay fine
23:51:22 <kniu> you're right
23:51:23 <mauke> lewis1711: huh?
23:51:38 <lewis1711> in lookup
23:51:45 <kniu> I did ignore the fact that he needed IO
23:51:48 <lewis1711> why doesn't it just throw an error if it's not there
23:51:59 <kniu> and the StateT Int thing was completely off course
23:52:01 <kniu> BUT
23:52:11 <mauke> vhd: the answer is basically: add an IORef parameter to your onclick function and fill it in when you define the handler
23:52:12 <Enigmagic> kniu: yeah, so how would you modify my sample app to work? https://gist.github.com/3835cdb637678acf6829
23:52:12 <MostAwesomeDude> lewis1711: Haskell's a LBYL language.
23:52:17 <BMeph> lewis1711: Why raise an exception for preditable, non-exceptional behavior? :)
23:52:27 <kniu> mauke, you still were being cute with me
23:52:30 <BMeph> *predictable
23:52:44 <mauke> kniu: I'm never cute
23:52:53 <kniu> would it have been so difficult to just TELL ME what the objection was, instead of saying "it won't work with IO"
23:52:57 <lewis1711> blergh I just don't get what I'm supposed to do with a maybe datatype thing
23:53:04 <kniu> leaving me to wonder what "with IO" means
23:53:11 <mauke> kniu: I said "with IO ()"
23:53:24 <MostAwesomeDude> lewis1711: Well, Maybe is a monad, so there's that. Also you could just unwrap it with a case statement or pattern match. Depends on what you intend to do with it.
23:53:37 <MostAwesomeDude> What would you prefer to happen if your thing fails and you get Nothing?
23:53:45 <kniu> mauke, and that's a different question how?
23:53:54 <Enigmagic> kniu: you might consider what other people say first before saying that we're wrong.
23:53:55 <mauke> it's not a question
23:54:22 <lewis1711> MostAwesomeDude: an exception with a helpful error message. it's a commandline utility program
23:54:35 <Enigmagic> kniu: if there is a vocab or skills issue, that's ok too. haskell isn't super easy to learn.
23:54:54 <kniu> Enigmagic, did you miss the part where I admitted he was right?
23:55:36 <Enigmagic> kniu: no, i got that part. we were trying to tell you why it wouldn't work but there was either a language or experience gap and it didn't come across very well.
23:55:50 <Saizan> communication surely went wrong in this situation
23:56:10 <MostAwesomeDude> lewis1711: Hm. Well, I don't know why you couldn't just handle the problem gracefully. Which function is Maybe-ing for you?
23:56:13 <kniu> okay then
23:56:23 <Enigmagic> Saizan: this is very true :-)
23:56:39 <mauke> kniu: my objection was "there's no source where this state can come from and no sink to pass it on"
23:57:18 <mauke> except phrased in form of a question because I wasn't 100% sure I hadn't misunderstood your suggestion
23:57:43 <lewis1711> MostAwesomeDude: probably because I don't understand it. https://gist.github.com/1454822 line 47
23:57:53 <lewis1711> sorry, 49
23:58:41 <BMeph> I.e., "lookup". :)
23:59:07 <vhd> :o IORef, this looks like some cool stuff "A mutable variable in the IO monad"
23:59:26 * vhd gets all emotional
