02:05:05 --- topic: '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]'
02:05:05 --- topic: set by monochrom on [Sat Sep 03 10:10:12 2011]
02:05:05 --- names: list (clog posteverything ambroff ksf__ Dybber Jeanne-Kamikaze looopy ramusara stianhj alim gwicke bru` hrolf zhulikas DuoSRX dogmaT balor carpi eikke antilect aidenhong ukl owst SeroPositief jimmy1980 THC4k applicative_ keep_learning skchrko Chaze mm_freak_ cfricke hirsch_ Itkovian ahax copumpkin binsh k0ral danten _1amzave zul_netbsd kstt takuan caligula_ Blkt Quantumplation jaspervdj YuleAthas Kerbik dmos srhb insomniaSalt mrtimuk alip MUILTRFN ejackson Solver)
02:05:05 --- names: list (dimmy danvet wicope Shin-LaC ppMuppetqq JaffaCake suiside adam4 Snark Smokey` ftrvxmtrx_ wayne Beetny silver Eduard_Munteanu hrehf nkpart wtw wlangstroth jsgf m3ga amiri ramkrsna Palmik TacticalGrace neurogeek blackh kushal amuck RayNbow`TU shintah scm plutoniix stchang jpf_ idoru jrslepak_ Jafet Nisstyre sopvop alang_ Vulpyne nexx sbahra recycle otto_s bos wespee conal Pseudonym Philonous_ T_X mrdomino seats GreaseMonkey vili zenzike nlogax cubi abiii ion)
02:05:05 --- names: list (kmels drwho kurtosis Bwild master_of_master siracusa stepnem lambdabot incluye Axman6 Muad_Dibber_ eZet ski scaturr Sgeo aavogt Anoq ousado_ alexrn pikhq JuanDaugherty gripz Polarina akosch imphasing theorbtwo fcr ciaranm jgrimes wagle tvynr noam_ bbee sbi tibell_ julmuri saimazoon descender polux_ waterlaz juhp musically_ut gtirloni dmwit augur Spockz_ milkpost AtnNn proq wmoss|away ajhager dabradley BMeph_ purpleposeidon brisbin beginner spasquali jamil_1)
02:05:05 --- names: list (localhost junsuijin jamiely_desktop ftrvxmtrx hiptobecubic bwright DasIch_ armence Jonno_FTW Megant mbetter _kit_ mpiechotka hamishmack joe9 eniirane statusfailed The_third_man Nshag Enigmagic kephas setmeaway niko self ben o1iver araujo rby danm_ rmunoz_ overrosy moonlite xinming jim`` ngochai MrNibbles kakos GordonFreeman dRbiG Philippa albel727 dreixel ath_ rgrinberg lokydor Modius_ gentz parcs ps-auxw trez ormaaj yeltzooo kongo zeiris Amadiro brandonw)
02:05:05 --- names: list (Tordek lnostdal chops vav monochrom borkman gerard0 noj gehho2 mauke CindyLinz Thropp teiresias c1de0x Zephyrus confab srid meanburrito920 keith_ ido kevc Newky AlpT maloi waern A1kmm_ Phyx- tromp skangas shadyp\ ArchGT Raviolo Internet13 dropdrive dcolish sipa incandenza snorble yam smiler fall_ opqdonut fasta alios sohum akahn milli` geekounet KaneTW tg ceii _habnabit earthy cjay flamingspinach @ChanServ samek mimico justicefries hackagebot kpal liesen)
02:05:05 --- names: list (levitation[A] shutdown_-h_now jlouis Gunni sordina2 Obfuscate ivan` chra mrd Clint ahkurtz BrianHV zakwilson saati joni6128 aristid majoh idnar tswett aliak Ke smly- herself kalven dilinger davidL endojelly devn Eelis skrblr mendez hyko quaestor dcoutts_ ccasin ernst adimit mythmon SonicvanaJr lefant _jesse_ IvdSangen brixen poucet sm ocharles srh jd10_ ahf Damn3d Lemmih confound strager Nafai janne jaj masterzora lispy edwtjo jcapper Igloo eno hpc cods)
02:05:05 --- names: list (integral ibid Martty tridactyla duairc tomlok pranq naneau shlevy xcvii taupin smeltzek Belgarion0 saiam orbitz HalfWayMan jbalint audunska_ qbyt_ othiym23 rwbarton thorkilnaur Corey burp raek blast_hardcheese ikj frerich bcoppens aleator atsampson inimino orangejuice snappy Paks Ferdirand leod drbean PreciousMetals comak levi tomku nihtml luite schroedinbug jonafan mee aszlig Sunhay_ CosmicRay lomeo_ Eliel Ornedan clsmith_ alpounet Counter-Strike Cale)
02:05:05 --- names: list (DRMacIver aculich_ welterde koala_man ricky kolmodin_ dbelange_ aditya jtg sagelywizard SamB_XP_ vithos Baughn frigga znutar lopex a11235 puzza007 unlink zorzar si14 joeytwiddle arnihermann agolsme derrida bradwright d34df00d Jaak bremner` KernelTrap ec kniu russellw tgeeky eyck mxweas hydo jtannenbaum kissyboy untwisted etabot linduxed froztbyte joogi EvanR-work arlinius franny wto jknick Yarou jix Ptival hvr Valodim absentia exobit BRMatt danols_work srcerer)
02:05:05 --- names: list (mokus ttvd magicman kolmodin cwb stroan preflex jmcarthur Draconx iFire` almostsi1 szbalint_ shachaf TomMD_ irene-knapp scshunt mroman ezyang tlockney koninkje_away pdxleif mjrosenb int-e jrk__ Gothmog_ tessier_ noddy2000 abbe hiredman callen jk4 wayne[mo1ile] quicksilver mrshoe Hunner xnyhps Yahovah ve jaredj techieshark 64MABFT82 copton biio mateu mortberg Boney ortmage mikemol ian_mi LeNsTR|off bxc impl pesco yottis cynick jabirali newsham rfgpfeiffer)
02:05:05 --- names: list (eigenweave byorgey sp3ctum Arnar Guest42999 Draggor mapreduce dcoutts FireFly tomprince chee1 McManiaC robbert anders^^ deggis companion_cube __main__ Ken` pettter SimonRC Khisanth lukish mndrix tomh sShintah mercury^ nullzzz Corwinoid jyyou synthomat TML ByronJohnson mdwright_ elliottt_ gdsx aoh desaiu2 willb MostAwesomeDude certainty bmiddleton KitB Yacoby djanatyn saurik cbad brett- def-lkb carlocci ixzkn dom96 jbauman Intensity Boxo sjl dabailey Innominate)
02:05:05 --- names: list (Bassetts gmcabrita TheMute helgikrs1 Taggnostr2 vicegrip Botje obcode alek_b Derander mrapple Dashkal norm2782 Liskni_si jlewis mux kaol yrlnry hammi jakeskik arpunk sunfun `0660 skaar absence thoughtpolice mattp_ krishna And[y] }ElectrowolF{ olsner taruti cao DustyDin1o grouzen jonke kloeri arkx Jaxan lebastr_ charro_ TweyII dannynn erg rhodesd Guest99195 plat0 dino- freiksenet djahandarie Cerise jrockway solarus chris2 profmakx electrogeek jlaire inr petanqk)
02:05:05 --- names: list (saruman_ Mitar wires liyang lpsmith dju tavelram bezik hpaste traviscline ray deavid peddie jml OnionKnight thirsteh __root__ geekosaur gf3 tuv limetree gredman Starfire Veinor MK_FG ptrf Maxdamantus Vq PHO_ c2thunes dxq mike-burns angstrom andrewsw twn ScooterAmerica thetallguy A1kmm Zarathu ddarius mejalx ft pi8027 marienz jessopher nazgjunk mjhan xrl johs mfoemmel mlh wavewave kosmikus SHODAN scsibug bd_ udoprog drmegahertz DrSyzygy davean mhweaver bqf)
02:05:05 --- names: list (Saizan tnks dMazz xplat danr em osfameron sajkr sully davv3_ amsl_ Dodek alistra pyryp bogner mornfall cjolowicz zygoloid d-snp shawn_ sunnavy smop robinbb` EyesIsServer aninhumer ville birkenfeld gajop perlite adnap tew88 Nereid pantski poindontcare benmachine wunki larsrh magog Deewiant pr tamiko kate__r tauntaun wyfrn_ ClaudiusMaximus zmoazeni_ sonoflilit `Zerax` Nimatek lnostdal_ ujm SyntaxNinja bl4ckcomb flu_ Waldteufel ahihi2 Gilly peterhil` alexbobp)
02:05:05 --- names: list (nimred whoops hiroaki_ iulian Laney tafryn ybit vold Nanar wereHamster warpy mlb- nighty^ flux bddn Dave2 ChongLi Will| zenazn Masxmasx dlmalloc wtetzner daimrod shoerain Varakh snarkyboojum gemelen ssalbiz dixie felipe_ tomaw klugez mietek emias noplamodo ziman mike1703 dumael sgronblo ehamberg nniro proqesi gseitz)
02:05:36 <dmwit> > read "3 {- umm -}" :: Int
02:05:37 <lambdabot>   *Exception: Prelude.read: no parse
02:08:46 <int-e> > read ('"' : repeat ' ') :: Char
02:08:52 <lambdabot>   mueval: Prelude.undefined
02:08:52 <lambdabot>  mueval: ExitFailure 1
02:09:10 <kstt> how possible is it with latest GHCs to load a module at runtime ?
02:09:29 <int-e> quicksilver: that's what it's for? *g*
02:09:37 <kstt> provided modules have been built by the same GHC of course
02:10:46 <kstt> the use case is for pandoc and its highlighting capabilities. There are tons of parsers modules built into the executable which make it quiet big.
02:11:27 <kstt> I'm wondering if compiled parsers could be loaded on demand, when they really have something to parse
02:12:49 <dmwit> dynamic libraries are supported by GHC now
02:13:13 <dmwit> Furthermore, the GHC API for parsing, interpreting, and compiling code is getting halfway decent.
02:13:19 <dmwit> So, "very possible".
02:13:55 <Axman6> kstt: see hs-plugins (i think that's what it's called)
02:17:42 <int-e> simply 'plugins' on hackage. does that still work? I thought everybody switched to 'hint'.
02:18:50 <quicksilver> there is also dyre, for a different niche
02:39:46 <kstt> thanks for your pointers
02:39:53 <kstt> I'm now reading them
02:48:12 <_Mikey> hey guys!
02:48:42 <_Mikey> Is it possible to store anything other than an Int in a Data.Graph
02:49:07 <_Mikey> :t graphFromEdges
02:49:10 <lambdabot> forall node key. (Ord key) => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)
02:49:26 <_Mikey> :t Data.Graph.node
02:49:27 <lambdabot> Not in scope: `Data.Graph.node'
02:49:34 <_Mikey> :t node
02:49:35 <lambdabot> Not in scope: `node'
02:49:45 <gtirloni> carpi: http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009
03:13:31 * hackagebot yeganesh 2.4 - small dmenu wrapper  http://hackage.haskell.org/package/yeganesh-2.4 (DanielWagner)
03:39:21 <co_dh> greeting!  Is there a way to write the following code ? newtype State s a = s -> (a,s) ?
03:39:55 <dmwit> ?src State
03:39:55 <lambdabot> Source not found. My pet ferret can type better than you!
03:40:03 <co_dh> I want to remove the tag ( the second State ) of the normal haskell way: newtype State s a = State ( s -> (a,s))
03:40:04 <dmwit> newtype State s a = State (s -> (a, s))
03:40:12 <dmwit> No, there is no way to remove the tag.
03:40:36 <co_dh> why?
03:41:20 <dmwit> http://www.reddit.com/r/haskell/comments/mxz3k/name_your_type_variables/c34v2sd
03:41:47 <dmwit> tl;dr to keep type inference tractable
03:42:05 <co_dh> dmwit:  thanks!
03:42:31 <dmwit> Note that the tag is source-syntax-overhead only; the in-memory representation of State s a and s -> (a, s) is exactly the same.
03:43:05 <dmwit> So there is no memory or time cost associated with newtypes, only programmer annoyance costs.
03:43:14 <dmwit> The latter can be greatly mitigated by appropriate typeclass instances.
04:13:37 * hackagebot tls 0.8.3.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.8.3.2 (VincentHanquez)
04:21:05 <simon> I'm writing a parser for a toy language. when it comes to code generation, is there a generic register allocator module available?
04:22:12 <kmc> llvm does register allocation and a lot more
04:22:53 <Jafet> There was an unexpected leap from parsing to register allocation
04:23:37 <kmc> if you really wanted to roll your own register allocator, using Hoopl might help
04:23:49 <kmc> but it's much more common to compile to something higher-level, be it LLVM or C or Haskell
04:25:05 <simon> kmc, LLVM it is.
04:25:14 <kmc> and i agree with Jafet, parsing really shouldn't be tied up with register allocation
04:25:20 <simon> right :)
04:36:39 <vrook> deal, deal', deal'' are all equivalent. Any other interesting ways to write it? https://gist.github.com/1438120
04:37:58 <vrook> I wonder if do-blocks are overused? The liftM style seems the best in this case.
04:39:14 <quicksilver> vrook: I would simply write groupsOf (numCards `div` numHands) <$> evalRandIO (shuffle deck)
04:39:41 <quicksilver> and certainly do-blocks are overused by some people.
04:42:01 <carpi> can someone please tell what are these "#" symbols that i keep seeing often in code downloaded from hackage?
04:44:18 <vrook> quicksilver: thanks, added deal'''. How widespread is Applicative use? I like that operator.
04:44:50 <kmc> carpi, you mean at the end of names?  addInt# and such?
04:45:00 <carpi> yea
04:45:06 <kmc> well it's just a name
04:45:12 <kmc> GHC allows # in names with the -XMagicHash extension
04:45:21 <kmc> but by convention, such names usually refer to low-level GHC internal stuff
04:45:41 <kmc> unboxed types, primitive operations, and the like
04:46:32 <carpi> ah okay.. thankx.. so now i know i don't have to bother with it.. atleast not yet )
04:46:47 <kmc> :)
04:47:06 <kmc> it's used by very high-performance code, or code which needs to do strange low-level things
04:47:29 <kmc> and it's used by GHC's own libraries, for implementing built-in stuff like Int
04:47:40 <carpi> so you mean it is possible to use haskell to do access hardware directly?
04:47:47 <quicksilver> vrook: well <$> could be a synonym for fmap or liftM
04:48:03 <quicksilver> vrook: it just happens to be the case that applicative is the neatest place
04:48:13 <quicksilver> so using it doesn't really count as using applicatives )
04:49:00 <quicksilver> vrook: in general I dislike the pattern where you name something which is only used ones. (x = foo bar where { foo = w; bar = u } )
04:49:13 <quicksilver> vrook: if it's used multiple times then, of course, it's worthwhile naming it.
04:49:16 <kmc> carpi, define "access hardware directly".  also define "Haskell", because strictly speaking, GHC extensions aren't part of Haskell
04:49:53 <vrook> quicksilver: I'm the same usually -- this is for pedagogy for recognizing the top-level construct.
04:49:54 <quicksilver> however, in practice I think the answer is "yes" - if you're prepared to write a little bit of C code to wrap the hardware access
04:50:07 <quicksilver> or if that has already been done for you
04:50:33 <kmc> putStr accesses hardware directly
04:50:40 <kmc> the "little bit of C code" is the Linux kernel and libc
04:50:44 <carpi> kmc: accessing hardware as in being able to access mem locations, maybe CPU registers or even being able to write device drivers.. and to be honest.. i've always thought haskell was whatever i got when i installed it the first time )
04:51:06 <kmc> carpi, well, Haskell is a standardized language... GHC implements what's in the standard but it also implements a lot more
04:51:11 <carpi>  i never knew there were 2 different haskells
04:51:15 <kmc> there aren't
04:51:30 <kmc> and yeah you can read and write memory by pointer
04:51:38 <kmc> the Foreign module is enough for that, and it is actually in the standard
04:52:04 <carpi> kmc: there is a pointer type in haskell?
04:52:08 <kmc> yes
04:52:20 <kmc> @hoogle Ptr
04:52:20 <lambdabot> Foreign.Ptr module Foreign.Ptr
04:52:20 <lambdabot> Foreign.Ptr data Ptr a
04:52:20 <lambdabot> GHC.Exts data Ptr a
04:52:31 <carpi> holy.. i think that should be sufficient for doing many hardware related things
04:52:34 <kmc> and the level of memory locations and CPU registers is still far from "accessing hardware directly"
04:52:54 <kmc> the CPU does all kinds of things to your instruction stream before it's actually manipulating hardware registers
04:53:51 <kmc> or talking to main memory
04:54:47 <vrook> Wouldn't it be better form to use liftM instead of <$> or fmap? It enforces the Monad class and makes the reader aware.
04:55:02 <carpi> so i see that some things are possible and some not
04:55:29 <kmc> that's generally the case
04:57:55 <kmc> you can't "access [CPU] hardware directly" in Haskell or C or assembly or machine code
04:58:25 <quicksilver> vrook: Not sure that really adds information. It is simply a fact that IO is Monad, Applicative,  and Functor. I see no reason not to use that.
04:58:31 <carpi> i think its possible in c or x86 assembly
04:58:44 <quicksilver> vrook: (all Monads can be made Applicative and most should be already)
04:59:25 <kmc> carpi, a register name like %rax does not refer to a specific location on the chip... the CPU has hundreds of hardware registers and dynamically allocates the exposed registers between them
05:00:10 <kmc> it also recompiles incoming instructions to an undocumented internal form before reordering them, predicting branches, performing speculative evaluation, and doing other optimizations
05:01:58 <carpi> i was talking about being able to access the primary registers like eax for example.. but i understand its not possible in haskell.. and i don't think those kinds of capabilities are required
05:02:17 <kmc> it is possible in a sense
05:02:30 <kmc> you can call functions written in assembly or C (with inline assembly)
05:02:49 <kmc> but there's no point accessing %eax directly because you have no idea what the surrounding ghc-generated code was using it for
05:03:09 <kmc> but (for example) messing with debug registers or reading the timestamp counter register is a fine idea
05:03:22 <kmc> (though iirc debug registers are privileged on x86)
05:03:58 <kmc> http://hackage.haskell.org/package/rdtsc
05:04:29 <int-e> rdtsc is a corner case :)
05:04:55 <kmc> how do you mean
05:05:49 <int-e> reading the tsc can be made privileged if the OS wants to, https://en.wikipedia.org/wiki/Control_register#CR4
05:05:55 <kmc> *nod*
05:06:04 <kmc> but they generally don't because it's useful :)
05:06:22 <kmc> linux has gone the opposite way, making gettimeofday() call rdtsc from userspace behind your back ;)
05:06:29 <Eduard_Munteanu> Yeah, *when* it works. :P
05:07:56 <Eduard_Munteanu> kmc: gettimeofday() probably tries to pick something sensible, the TSC might e.g. be out of sync across cores.
05:08:16 <kmc> yeah they have put in some effort to get it right
05:08:17 <mux> yeah, and omst often is
05:08:32 <mux> also, most TSCs do not account for frequency scaling
05:08:35 <kmc> there are some cpuid bits that tell you whether the tsc is synched between cores, and also whether it's invariant with cpu freq scaling
05:08:46 <kmc> but there are also ways to work around these problems
05:09:09 <mux> a modern OS is not likely to use the TSC as its clock, but modern ACPI timecounters (HPET), or their older incarnations
05:09:38 <kmc> but those can't be accessed from ring 3, can they?
05:09:38 <Eduard_Munteanu> The HPET can also be accessed directly AFAIU, if mmaped.
05:09:43 <kmc> hmm
05:09:55 <mux> kmc: not AFAIK
05:10:10 <Eduard_Munteanu> Though unsafe in some cases, as there's a compile-time option to disable that in Linux.
05:10:15 <mux> but x86 is full of loopholes to allow that in some way or the other, I believe
05:10:34 <kmc> i don't know how vsyscall gettimeofday works exactly, but my guess is that it uses rdtsc only for the fine-grained part of timing, since the process was last scheduled in
05:10:56 <mux> RDTSC is still quite slow, even if you avoid syscall overhead
05:11:14 <kmc> yeah and it's much worse in virtualization
05:11:24 <Eduard_Munteanu> Because it triggers serialization or something?
05:11:38 <kmc> it potentially traps to the hypervisor
05:11:53 <kmc> no, sorry, i'm thinking of CPUID
05:11:54 <Eduard_Munteanu> Ah.
05:12:03 <kmc> there was a linux patch which improved performance of gettimeofday() by something like 80x in virtualization
05:12:10 <Eduard_Munteanu> Heh, CPUID serializes too.
05:12:23 <kmc> they were using CPUID for serialization and switched to MFENCE
05:12:44 * kmc is off topic, sorry
05:13:43 <mux> eh? what would CPUID have to do with MFENCE? last I checked, CPUID advertises cpu features & stuff, and mfence is a memory barrier mechanism on amd64
05:14:11 <kmc> yeah but CPUID is also specified to be a memory barrier
05:14:14 <kmc> for no particular reason
05:14:15 <Eduard_Munteanu> mux: it does act like a barrier, as a side effect
05:14:18 <mux> ok
05:14:27 <mux> it still sounds very hackish that people would sue it for that purpose :-)
05:14:39 <kmc> it is hackish
05:14:46 <kmc> welcome to x86, welcome to systems programming ;)
05:14:53 <mux> lol
05:14:54 <kmc> anyway it is supported on more processors than MFENCE
05:15:04 <kmc> which iirc is not amd64-only, but does require some level of MMX/SSE
05:15:17 <mux> but on those CPUs without mfence, you probably have strong memory ordering guarantees
05:15:27 <kmc> so really the CPUID barrier was replaced with an altinstructions thingy to use CPUID or MFENCE as necessary
05:15:27 <kmc> iirc
05:15:57 <mux> well these things apparently changed a lot recently
05:16:12 <mux> x86 used to just have a fully coherent memory model
05:16:25 <mux> now you have memory barriers and what not, and NUMAcc for amd64 etc
05:18:14 <kmc> mfence is pretty old, it was added in SSE2 it seems
05:18:47 <mux> yeah, it's not amd64 specific as I first though. Still, SSE2 is what I'd call "recent" :-)
05:19:02 <kmc> 10 years ago :)
05:19:11 <mux> already that much? god damnit I'm old
05:19:13 <vrook> If there was an opportunity to rewrite the standard, would it be class (Applicative m) => Monad m where ... ?
05:19:15 <kmc> i know, right?
05:19:20 <mux> yeah :-(
05:19:22 <kmc> vrook, most likely yes
05:19:46 * mux remembers the days when 10 years felt like an eternity
05:20:28 <kmc> vrook, some proposed GHC extensions would allow that rewrite without breaking existing code
05:21:09 <quicksilver> well all the proposals will break *some* code I think
05:21:19 <quicksilver> it's a case of choosing the ones which break the least.
05:21:19 <kmc> mm, probably
05:25:53 <geheimdienst> oleg pointed out practical downsides of Monads becoming Functors (other than breaking code). not sure how much weight that carries http://www.haskell.org/pipermail/haskell-prime/2011-January/003312.html
05:27:17 <quicksilver> geheimdienst: yes, but some of the proposals do indeed address those objections
05:27:46 <geheimdienst> quicksilver: oh, interesting
05:28:10 <quicksilver> for example, default methods so that fmap = liftM would be used if you didn't write the Functor instance specifically.
05:28:27 <quicksilver> addressing those kind of objections has been a big part of the (drawn out) discussions on this point.
05:28:34 <quicksilver> SHE has implemented one approach I think.
05:29:19 <mauke> why does his last example require undecidable instances?
05:29:33 <mauke> and why is there a Monad constraint in the instance?
05:29:58 <geheimdienst> mauke: re your last question, i think because he wants to use return
05:30:12 <mauke> ... so?
05:31:14 <Eduard_Munteanu> Perhaps the idea is we should be able to get a Functor from a Monad.
05:31:24 <mauke> ok, you may need (Monad m)
05:31:32 <mauke> but that looks decidable to me
05:32:03 <FUZxxl> Hello!
05:32:33 <int-e> mauke: the point of the instance head is that it can be generated automatically
05:32:50 <vrook> Does it ever happen that the monad constraint of liftM resolves an ambiguity that would be present with fmap?
05:33:39 <quicksilver> vrook: additional constraints never resolve ambiguities.
05:33:47 <vrook> ok so why does liftM even exist?
05:33:52 <kmc> historical reasons
05:34:33 <quicksilver> an additional constraint can only (a) propogate (b) simplify or (c) error (if incompatible with explicit type sig)
05:35:37 <vrook> Is there any reason to use liftM apart from the "human" factor?
05:35:58 <vrook> like familiarity, etc
05:36:54 <quicksilver> vrook: well if you only have a Monad constraint, you can't use fmap
05:37:10 <quicksilver> so if you're coding to an external interface which fixes the type sig, you can be forced to use liftM
05:37:24 <quicksilver> however, this situation has never occurred to me. So, I've never had any reason to use liftM.
05:37:43 <kmc> you might have a poorly behaved type where fmap and liftM do different things
05:38:30 <quicksilver> yeah, but in that case you should consider yourself lucky you don't have demons coming out of your nose
05:38:35 <Phyx-> lambdabot: welcome back
05:38:38 <kmc> yeah
05:38:49 <kmc> still, working around bugs in code you can't fix (for whatever reason) is a fact of life
05:38:55 <quicksilver> true
05:39:05 <kmc> and it's a non human-factors reason why you might use liftM over fmap
05:39:10 <kmc> hasn't happened to me though, thankfully!
05:39:45 <kmc> i think you can probably find reasonable-ish cases where liftM and fmap differ at least with respect to ⊥
05:39:53 <FUZxxl> I found out that J has currying, function composition and all that stuff...
05:40:12 <FUZxxl> Now I am happy
05:40:46 <kmc> every decent language defines function composition or lets you define it easily
05:41:03 <kmc> from one perspective, currying makes it harder to define generic function composition
05:41:23 <osfameron> it does?
05:41:47 <kmc> yep, Haskell's (.) can compose  f :: (a,b) -> c  with g :: c -> d
05:41:54 <kmc> but not f :: a -> b -> c  with g :: c -> d
05:42:00 <lars9> after reading stephens arrow tutorial, i kinda started to understand how arrows works
05:42:17 <osfameron> kmc: oh yes, that's a pain
05:42:19 <lars9> but still didn't see its advantage
05:42:38 <kmc> arrows aren't used very much...
05:42:48 <osfameron> again, you can define a function to do it quite easily.  I think I've done something like: (.:) = (.).(.)  iirc
05:42:55 <kmc> yeah
05:43:03 <lars9> it's so hard to do a lot of things
05:43:04 <kmc> but it's still a different function from (.)
05:43:08 <Ferdirand> @pl \a b -> g (f a b)
05:43:08 <lambdabot> (g .) . f
05:43:18 <kmc> and different still for "three arguments", and for four, etc.
05:43:26 <osfameron> yeah
05:44:44 <quicksilver> kmc: lambda notation is quite a good notation for specifying arbitrary compositions.
05:44:46 <FUZxxl> I have a question.
05:45:06 <FUZxxl> WOuldn't it be much more sensible to define the tuples as a list-type?
05:45:12 <kmc> quicksilver, not convinced.  having to invent all those names...
05:45:14 <FUZxxl> Such as data a , b = a , b
05:45:20 <quicksilver> kmc: in fact, I think it might be in some essential sense the "best" notation, if you restrict yourself to 1D streams of characters.
05:45:20 <FUZxxl> infixl ... ,
05:45:27 <kmc> FUZxxl, how is that a list type?
05:45:33 <kmc> aside from special syntax, that's how (,) is defined
05:45:38 <kmc> data Pair a b = Pair a b
05:45:43 <kmc> Pair will act the same as (,)
05:45:53 <FUZxxl> Well, the difference is, that one does needs only one tuple-type. Not many.
05:46:03 <FUZxxl> (x,y,z) == (x,(y,z))
05:46:06 <simon> is there an operator for subtracting elements from a list?
05:46:09 <kmc> you're just saying that instead of using (a,b) we could use... yeah, that
05:46:10 <FUZxxl> Or ((x,y),z)
05:46:19 <kmc> FUZxxl, but that's not a language feature... you just get your libraries to do that and you're set
05:46:23 <FUZxxl> Making , a type-constructor would be funny
05:46:25 <kmc> the existing (,) does that just fine
05:46:29 <kmc> it is a type constructor
05:46:33 <kmc> :k (,) Int Char
05:46:34 <lambdabot> *
05:46:38 <kmc> and a value constructor
05:46:40 <kmc> > (,) 2 3
05:46:41 <FUZxxl> Well, the difference is the syntax.
05:46:41 <lambdabot>   (2,3)
05:46:49 <FUZxxl> I want , to be a constructor, not (,)
05:46:59 <FUZxxl> Such that 2,3 is a valid expression
05:47:07 <kmc> i see
05:47:07 * FUZxxl is happy that lambdabot is online again
05:47:17 <kmc> quicksilver, depends how broadly you define "arbitrary compositions"
05:47:29 <Phyx-> FUZxxl: so am I
05:47:46 <FUZxxl> The compiler could use internal magic to optimize that into a n-ary tuple when neccessary
05:48:34 <kmc> not so easily
05:48:41 <kmc> ((a,b),c) has more ⊥'s in it than (a,b,c)
05:48:48 <quicksilver> kmc: well my line of reasoning is that, at the very least, you need to be able to move arguments around arbitrarily. If you allow pictures you can draw string diagrams, but if you're struck with linear text I think you need to name. But do you know something better?
05:49:05 <kmc> but if you're talking strict pairs, then it seems more doable
05:49:33 <kmc> data Pair a b = Pair !a {#- UNPACK #-} !b
05:50:24 <mux> I'd like it if there was a strict product type in the standard libraries
05:50:30 * kmc too
05:50:34 <mux> everyone defines it's own SPair or :*: thingie
05:51:01 <mux> and maybe 75% of the time when I've got space leaks, it's due to lazy pairs...
05:51:05 <kmc> is there a good hackage library for them
05:56:12 <int-e> http://hackage.haskell.org/package/strict-0.3.2 perhaps
05:56:20 <int-e> (kmc, mux)
05:57:50 <mm_freak_> which GHC version do i need for the ConstraintKinds extension?
05:57:53 <FUZxxl> Fact is, that many instances were simpler if , was defined like this.
05:57:58 <mm_freak_> found my first use case for it =)
05:58:00 <FUZxxl> mm_freak_: 7.2?
05:58:10 <FUZxxl> 7.2.2?
05:58:16 <mm_freak_> FUZxxl: are you asking me or telling me?
05:58:20 <quicksilver> FUZxxl: HList.
05:58:29 <quicksilver> HList is tuples defined generically.
05:58:43 <quicksilver> with a host of instance machinery which you can ignore / use some of / use none of.
05:58:59 <FUZxxl> okay
05:59:08 <FUZxxl> @hackage HList
05:59:08 <lambdabot> http://hackage.haskell.org/package/HList
05:59:11 <keep_learning> hello all
05:59:19 <Baughn> @pl \a -> f a a
05:59:19 <lambdabot> join f
05:59:49 <keep_learning> i am going through real world Haskell chapter 24 .
05:59:59 <FUZxxl> If I decided to create my own functional language, would such a definition of tuple be a good alternative to the current system?
06:00:00 <keep_learning> it says forkIO (writeFile "xyzzy" "seo craic nua!") >> doesFileExist "xyzzy" will return False
06:00:01 <FUZxxl> Or not?
06:00:04 <Baughn> ..ooh. The reader monad, of course. Right.
06:00:14 <quicksilver> FUZxxl: @hackage is not a search tool, it's a dumb URL constructor.
06:00:24 <FUZxxl> quicksilver: It worked.
06:00:31 <FUZxxl> I wanted this URI
06:00:46 <quicksilver> FUZxxl: it worked because the package was called exactly 'HList' yes :)
06:00:48 <keep_learning> because while my system return True
06:01:05 <kmc> keep_learning, it will return either True or False nondeterministically
06:01:12 <keep_learning> means that forkIO  thread is executing first
06:01:35 <FUZxxl> hehe
06:01:45 <FUZxxl> quicksilver: I know that. I hoped so.
06:01:47 <FUZxxl> It often works.
06:01:51 <kmc> there's no guarantee that it's even consistent if you run the program again
06:03:27 <keep_learning> kmc, Could you explain me why it can return both.
06:04:05 <kmc> scheduling of threads is non-deterministic
06:04:12 <kmc> maybe it lets the forkIO thread run first, maybe it lets the main thread run first
06:04:40 <kmc> in the book they're showing you one example run
06:04:45 <kmc> doesn't imply that's the result you will always get
06:04:45 <statusfailed> How do I show implementation of a function with lambdabot?
06:04:55 <kmc> statusfailed, can't really, but it has some simple things with @src
06:04:56 <kmc> @src map
06:05:03 <kmc> derp
06:05:11 <statusfailed> haha
06:05:18 <kmc> small netsplit
06:05:18 <quicksilver> @src causes netsplits now?
06:05:20 <nazgjunk> *g*
06:05:21 <quicksilver> odd feature
06:05:24 <statusfailed> Can I get the implementation of liftM?
06:05:27 <geheimdienst> cale: you around? lambdabot has gone dancing
06:05:31 <statusfailed> @src liftM
06:05:38 <statusfailed> oh ^^
06:05:40 <Phyx-> hmm I wonder how much work it would be to modify my C# irc code to run/evaluate haskell code..
06:05:46 <Baughn> geheimdienst: He can't really do anything about netsplits.
06:05:50 <quicksilver> liftM f a = a >>= return f
06:05:50 <Baughn> Just avoid using @src again
06:05:51 <kmc> liftM f m = do { x <- m; return (f x) }
06:06:00 <quicksilver> missing .
06:06:00 <kmc> 's one way
06:06:01 <statusfailed> oh wow, lambdabot was in the netsplit
06:06:02 <quicksilver> liftM f a = a >>= return . f
06:06:03 <statusfailed> what timing
06:06:17 <Phyx-> i spent a great deal of time implementing code to detect splits and switch servers etc
06:06:23 <kmc> keep_learning, it's the same as preemptive threads in any other environment
06:06:24 <quicksilver> but maybe kmc's do notation way is easier to fullow
06:06:29 <Phyx-> call it, FrankenBot
06:06:41 <statusfailed> quicksilver: actually I have trouble with do notation :p
06:07:08 <Phyx-> @where lambdabot
06:07:10 <Phyx-> whoops
06:07:14 <statusfailed> at least in terms of trying to understand Monad
06:07:20 <keep_learning> kmc, thank you
06:07:30 <statusfailed> @src liftM
06:07:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:07:40 <statusfailed> :)
06:07:40 <kmc> "The new thread starts to execute almost immediately, and the thread that created it continues to execute concurrently."
06:07:42 <keep_learning> @src ap
06:07:43 <lambdabot> ap = liftM2 id
06:07:59 <quicksilver> however, @src is a bit rubbish and in general it's better to use the webpages
06:08:03 <quicksilver> which have the source of everything.
06:08:03 <statusfailed> ah ok
06:08:17 <Phyx-> lamndabot does spell checking?
06:09:02 <Phyx-> and has a brainfuck interpreter?
06:09:05 <Phyx-> @commands
06:09:05 <lambdabot> Unknown command, try @list
06:09:08 <Phyx-> @list
06:09:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:09:16 <benmachine> @lust
06:09:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:09:21 <keep_learning> kmc, looks like the the thread which creates the file is finished before the thread that created it.
06:09:32 <keep_learning> kmc, almost all the time i am getting True
06:09:40 <keep_learning> i ran it almost 10 times
06:10:11 <kmc> yeah but you have no guarantee
06:10:52 <quicksilver> keep_learning: I think you're missing the point
06:11:02 <kmc> 1 in 10 is nothing
06:11:05 <quicksilver> keep_learning: certainly on a particular GHC version, with a particular OS, it may *happen* be consistent
06:11:13 <quicksilver> but it's not guaranteed
06:11:27 <quicksilver> on other days, on other GHCs, on other OSes, on a more heavily loaded machine it might be different
06:11:32 <quicksilver> so you mustn't rely on it.
06:11:32 <kmc> there are concurrency bugs in the Linux kernel where the strategy to reproduce it is to have hundreds of 48-core machines pound the code for a month
06:11:35 <kmc> and it will happen once
06:11:56 <quicksilver> the absence of a systematic way of testing different interleavings is a bit sad :(
06:12:14 <cheater> kmc: you running your gamma ray burst detector again?
06:12:29 <mux> make -j128 buildworld is how we do it in FreeBSD :-)
06:12:35 <kmc> keep_learning, if you want to understand why the implementation happens to schedule your threads this way under these circumstances, that can be a worthwhile exercise
06:12:40 <kmc> but you mustn't rely on that behavior
06:13:14 <kmc> if your threads need to be synchronized then you need to synchronize them
06:13:19 <kmc> with IORef, MVar, Chan, STM, etc.
06:13:55 <keep_learning> quicksilver, kmc  thank you both
06:16:13 <Ferdirand> quicksilver: so how could we implement systematic interleavings in haskell ?
06:19:30 <quicksilver> Ferdirand: for an embedded DSL of parallelism it's fairly trivial and well discussed.
06:19:38 <quicksilver> for haskell threads, you'd need a custom RTS
06:19:41 <kmc> "fairly trivial"?
06:19:50 <quicksilver> of course, number of interleavings is exponential
06:19:52 <kmc> what ever happened to the word "easy"
06:20:04 <quicksilver> kmc: trivial != easy
06:20:09 <quicksilver> at least the way I use the words
06:20:14 <kmc> quicksilver, yeah, that's my point
06:20:17 <geheimdienst> kmc: it doesn't show you have a mathematical background, and it's not latin enough :)
06:20:17 <quicksilver> something can be trivial but requiring a lot of effort
06:20:22 <Ferdirand> I have no idea what an embededd DSL of parallelism would look like, i'm just a noob
06:20:30 <kmc> imo if something is "fairly trivial" then it is better described as "easy"
06:20:45 <quicksilver> Ferdirand: then you probably want my secod answer
06:20:50 <quicksilver> someone woul dhave to modify the RTS
06:20:53 <cheater> easy includes doing work
06:21:00 <quicksilver> I wonder if JaffaCake has ever considered that
06:21:02 <Ferdirand> but i'm just asking this out of pure curiosity
06:21:09 <cheater> trivial means just practice.
06:21:16 <JaffaCake> considered what?
06:21:22 <kmc> anyway i'm with geheimdienst ;)
06:21:28 <cheater> you seem to be missing the difference between the trivium and the quadrivium, kmc.
06:21:31 <quicksilver> JaffaCake: adding something to the RTS to help explore the place of possible interleavings
06:21:37 <quicksilver> JaffaCake: (space of)
06:22:03 <JaffaCake> short answer is "no" :)
06:22:13 <quicksilver> would help a lot for testing
06:22:13 <JaffaCake> (I haven't considered it)
06:22:22 <quicksilver> random testing of interleaves like quickcheck does for values
06:22:32 <JaffaCake> isn't the space really really big?
06:22:44 <JaffaCake> oh, I see
06:22:56 <JaffaCake> actually yes, you could do that
06:23:04 <Ferdirand> as everything in haskell is a monad of course, I was wondering if something could be build, akin to State but letting the user compose threads with a fork-like operator
06:23:18 <JaffaCake> so you can context switch after a random amount of allocation
06:23:34 <JaffaCake> that would do the trick
06:27:37 <DevHC_> internal error: allocGroup: free list corrupted
06:27:37 <DevHC_>     (GHC version 6.12.1 for i386_unknown_linux)
06:28:21 <kmc> sucks, do you have a reproducer?
06:28:26 <DevHC_> yes
06:29:10 <DevHC_> that happens on some other d00d's system, not on mine (i have a later GHC version)
06:29:57 <kmc> i'm interested in memory corruption bugs in ghc rts
06:30:25 <kmc> there are lots of people running untrusted Haskell code from the internet
06:30:55 <DevHC_> and my project is about using Safe mode and run untrusted haskell code from "teh internetz" :P
06:31:03 <DevHC_> running*
06:31:04 <kmc> haha well then
06:31:20 <DevHC_> but GHC7.2 is just ... too buggy
06:31:58 <Philonous_> quicksilver:  A new primitive split :: IO a -> (Maybe IO (), IO a) would even allow one to muck around with a self-implemented scheduler
06:32:48 <copumpkin> what would the Maybe do?
06:33:07 <copumpkin> seems like it'd need to be in IO too, whatever it does
06:33:40 <Philonous_> copumpkin:  AH, I meant Maybe (IO ()). In case it can't be split
06:33:55 <copumpkin> Philonous_: yeah, IO (Maybe (IO ())) probably?
06:34:11 <copumpkin> or probably IO (Maybe (IO ()), IO a)
06:34:15 <copumpkin> :P
06:35:28 <frigga> Anyone know what kind of a situation would lead to me getting a stack overflow when I compile with -O2 and run my app from the command line, but work fine when I run from inside ghci?
06:36:22 <aavogt> ghci has a bigger stack
06:37:14 <Philonous_> copumpkin:  Yes, probably
06:38:02 <frigga> aavogt: Oh, interesting.  I didn't realize that.
06:38:42 * kmc is thinking now about Mu IO
06:38:57 <aavogt> there might be other explanations (maybe the output is buffered differently... I'm not sure how that can have an effect)
06:39:12 <Philonous_> copumpkin:  IO a -> IO (Either (IO a) a) would probably make more sense
06:39:51 <frigga> aavogt: In the past, I usually see stack overflows in ghci, but not when compiling with -O2 and running the binary.
06:48:49 * hackagebot timeplot 0.3.14 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.14 (EugeneKirpichov)
07:06:05 <endojelly> it should be easy to write a "goto"-Arrow, I thin
07:06:05 <endojelly> k
07:06:18 <endojelly> where you set labels, and can jump to those labels at any point
07:06:39 <endojelly> a bit like the continuation monad, but with cleaner syntax?
07:08:55 <byorgey> http://hackage.haskell.org/package/GotoT-transformers
07:08:57 <byorgey> http://hackage.haskell.org/package/BASIC
07:20:02 <fcul> hi!
07:20:10 <byorgey> hi fcul
07:20:32 <byorgey> trying you a Haskell?
07:20:41 <fcul> I have a question: I need to print an array and change the N'th position of it to Int -> X
07:20:56 <endojelly> byorgey, not sure, but I think the GotoT monad transformer is not exactly what I mean. or rather, it's what I meant when I said that an arrow might have "cleaner syntax"
07:21:13 <FUZxxl> How do you call pointless-programming in German?
07:21:27 <endojelly> byorgey, I suppose for GotoT, you have to write stuff like do foo; bar; alabel <- do... ?
07:22:00 <endojelly> byorgey, and I was thinking more along the lines of: do foo; bar; label alabel; baz; xyzzy; goto alabel;
07:22:08 <Nimatek> Please use English terminology when talking about programming in German.
07:22:20 <Nimatek> That was @ FUZxxl
07:22:38 <endojelly> FUZxxl, punktfrei? (I'm pretty sure it's also point*free* by the way)
07:22:40 <earthy> FUZxxl: sinnlose programmierung... I'd say. :)
07:22:55 <kmc> http://en.wikipedia.org/wiki/Pointless_topology
07:22:59 <kmc> but it dosen't have a link to de.
07:23:15 <FUZxxl> hehe
07:23:16 <fcul> I have a question: I need to print an array and change the N'th position of it to Int -> X
07:23:22 <FUZxxl> I have to go off now.
07:23:26 <FUZxxl> I use "fixpunktfrei"
07:23:50 * hackagebot Hipmunk 5.2.0.6 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.6 (SoenkeHahn)
07:24:41 <fcul> I have a question: I need to print an array and change the N'th position of it to Int -> X
07:24:52 <kmc> fcul, we heard you the first two times
07:25:08 <byorgey> fcul: what do you mean, change the Nth position to Int -> X ?
07:25:27 <fcul> Sorry. 1st timer here, not sghure on the rules
07:26:29 <fcul> I have an array of chars (all periods . ) and I need to change the given position (X) to the said Int (Eg: change the 4th position = ...4.)
07:26:41 <byorgey> endojelly: well, for GotoT it looks like 'goto' takes not a label but an actual computation.
07:26:56 <byorgey> endojelly: I think the label ... goto sort of thing is what that BASIC package does
07:27:11 <kmc> fcul, do you have an array, or a list?
07:27:32 <fcul> an array atm, but either can work
07:28:00 <kmc> for an array you could use  foo // [(4,'4')]
07:28:14 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/array-0.3.0.2/Data-Array.html#v:-47--47-
07:28:35 <fcul> KMC, Kudos to you sir!
07:28:51 <endojelly> byorgey, right! and I'd like to do that using simple arrow commands... so no "constructor keyword" tricks like the basic package but also no need to nest computations. it's just for fun by the way %)
07:29:06 <fcul> Still very new to haskell, still getting along with the lambda.haskel and all
07:29:32 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html here are the docs for everything which comes with Haskell Platform
07:30:35 <fcul> Btw... one more question: Can you use loop cycles in haskel?
07:30:48 <kmc> what's a loop cycle
07:31:37 <fcul> for's, While's, etc
07:31:49 <kmc> the basic way of looping in haskell is recursion
07:31:54 <kmc> but there are functions which act like for and while
07:31:59 <kmc> they are ordinary functions, not special syntax
07:32:10 <fcul> ok. thank you =)
07:32:14 <kmc> programming in Haskell is very different
07:32:33 <fcul> Yes, i've noticed =) But so far, liking it a lot
07:32:36 <kmc> cool
07:32:39 <fcul> feels "light" =)
07:34:19 <kmc> heh
07:34:29 <kmc> i think haskell is not that light in an absolute sense
07:34:33 <kmc> but it has a nice power-to-weight ratio
07:34:35 <geheimdienst> > map (\x -> x*2) [1..5] -- fcul: the 'map' function is used in places where other languages might use a foreach loop
07:34:37 <lambdabot>   [2,4,6,8,10]
07:35:07 <fcul> geheimdienst: Thanks. Will add to the "look it up" list =)
07:35:21 <kmc> any decent tutorial will cover 'map'
07:35:30 <fcul> KMC: the solution you posted about the array should work with floats as weel right?
07:35:40 <geheimdienst> fcul, put it near the top of the "look up" list :) map is a very useful, very often used function
07:35:54 <kmc> fcul, are you following some tutorial?
07:35:58 <fcul> and then using "putStr foo" print it out
07:36:35 <hpc> @where lyah
07:36:35 <lambdabot> http://www.learnyouahaskell.com/
07:36:36 <fcul> kmc: computer engineering in college. Could call it a tutorial :P
07:36:43 <kmc> i mean a document about haskell
07:36:53 <roha> newbie question: does somebody know how to make OcaIDE's autocomplete work with batteries?
07:37:12 <kmc> learning haskell usually requires learning a new way to think
07:37:25 <fcul> Well.. .we do have them in classes. Although the theachers aproach is very much like: look it up and try it
07:37:32 <kmc> it's very useful to follow a document which describes that in a systematic way
07:37:43 <kmc> you can't just decide how to solve the problem in another language, and then look up the haskell syntax
07:37:45 <roha> List.<ctrl-space> shows the possible standard library functions instead of the ones from Batteries.
07:38:01 <kmc> (which is how learning a "new language" often works)
07:38:06 <kmc> fcul, i recommend LYAH and RWH
07:38:07 <kmc> @where lyah
07:38:08 <lambdabot> http://www.learnyouahaskell.com/
07:38:08 <kmc> @where rwh
07:38:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:38:24 <geheimdienst> fcul: both books are available for free online
07:38:42 <fcul> kk. will do =)
07:38:43 <hpc> LYAH is an extremely accessible tutorial, and RWH is a bit closer to a reference, especially the later chapters
07:39:03 <fcul> thank you very much for your help
07:39:04 <roha> oups wrong channel
07:39:34 <roha> i already thought there's a lot haskell talk for a ocaml channel, hehe. nvm then
07:39:35 <aavogt> some of the libraries RWH describes have since changed
07:42:53 <huangyi> There is no binary literal in haskell, right?
07:43:29 <quicksilver> if you mean in the style of 0b10010110101111
07:43:31 <quicksilver> then, no.
07:43:57 <geheimdienst> > (0x123, 0o123) -- no binary, but hex and octal are available
07:43:59 <lambdabot>   (291,83)
07:53:07 <geheimdienst> so what's the public opinion on an infix flip?
07:53:22 <geheimdienst> > let (␣) = flip ; f = map ␣ [1..5] in f succ -- example
07:53:25 <lambdabot>   [2,3,4,5,6]
07:54:32 <fcul> Well... I'm off. thank you all!! Great tips!
07:54:34 <kmc> interesting, i haven't heard that proposal before
07:54:46 <kmc> nice choice of symbol by the way
07:55:03 <geheimdienst> :D thanks kmc
07:55:13 <Eduard_Munteanu> Hrm, too bad it doesn't work for the last arg.
07:55:25 <geheimdienst> the (huge) caveat is of course that it'd only work in the second-to-last position. f 1 2 ␣ 3 is good, f 1 ␣ 3 4 is not. this must be confusing as hell for a newbie
07:55:26 <danr> geheimdienst: nice, looks just like a hole
07:55:35 <danr> ah
07:55:39 <danr> that's too bad of course
07:55:52 <danr> maybe some typeclass-hackery would enable you to make a real hole :)
07:56:07 <geheimdienst> you have to fix it like this: "f 1 ␣ 2 $ 3"
07:56:08 <kmc> probably at the expense of your own soul
07:56:45 <Eduard_Munteanu> Overlapping instances maybe.
07:57:32 <kmc> at that point i'd rather just add real hole syntax as a ghc extension
07:57:45 <danr> that would be nice
07:57:49 <danr> a bit like tuple sections
07:57:50 * roconnor feels that continuations are the solution to this problem
07:57:50 <kmc> or a preprocessor or a th thing
07:57:51 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:57:53 <geheimdienst> Eduard_Munteanu: i didn't consider the last position thing a big problem because you can just leave the ␣ off :) f 1 2 3 is the same as (f 1 2) 3
07:57:56 <mroman> `flip` ?
07:58:25 <Eduard_Munteanu> mroman: yeah, but that's arguably uglier and doesn't show the intent
07:59:03 * Eduard_Munteanu somewhat wishes for infixes like _␣ :)
07:59:20 <Eduard_Munteanu> Though that probably doesn't solve it.
07:59:22 <geheimdienst> what would the _ do in that?
07:59:34 <mroman> I want (->>) = flip ($)
08:00:06 <Eduard_Munteanu> geheimdienst: ah like Agda's stuff... _␣ (f x y) = (f x y) ␣
08:00:16 <roconnor> dmwit: ya, sorry, I haven't documentened how to use HSV and HSL in my colour tutorial. :(
08:00:17 <Eduard_Munteanu> or  f x y ␣  plainly
08:00:41 <geheimdienst> yeah, but "f x y ␣" is the same as "f x y", isn't it?
08:00:50 <Eduard_Munteanu> Yeah.
08:00:53 <mroman> map (+2) [1..9] ->> reverse
08:01:51 <Eduard_Munteanu> mroman: (>>>) is somewhat useful there
08:02:07 <Eduard_Munteanu> map (+2) >>> reverse $ [1..9]
08:02:09 <Eduard_Munteanu> > map (+2) >>> reverse $ [1..9]
08:02:11 <lambdabot>   [11,10,9,8,7,6,5,4,3]
08:02:41 <kmc> i think using OverlappingInstances so that you can write «f ␣ x y z»  instead of  «\v -> f v x y z»  is getting into obfuscated haskell contest territory
08:02:56 <mroman> Is that from Arrow?
08:03:01 <mroman> @>>>
08:03:02 <Eduard_Munteanu> :t (>>>)
08:03:02 <lambdabot> Unknown command, try @list
08:03:03 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
08:03:11 <Eduard_Munteanu> Control.Category
08:03:13 <kmc> here it's just flip (.)
08:03:22 * geheimdienst looks up overlapping instances ...
08:03:26 <aavogt> kmc: does it work?
08:03:32 <Eduard_Munteanu> Yeah, cat = (->)
08:03:43 <kmc> does what work
08:03:55 <aavogt> OverlappingInstances for that problem
08:04:03 <kmc> i have no idea, but it was suggested a moment ago
08:04:14 <mroman> @list
08:04:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:04:26 <kmc> i expect it will work in some common cases and fail in hilarious ways
08:04:27 <aavogt> how does the instance know how many additional arguments    f ␣ x  will be expecting
08:04:47 <Eduard_Munteanu> I was considering an instance for a -> (b -> c), and one for a -> b.
08:05:09 <Eduard_Munteanu> Not sure if it works though.
08:05:45 <roconnor> @tell dmwit uncurryRGB sRGB . hsv
08:05:46 <lambdabot> Consider it noted.
08:06:29 <geheimdienst> what about the case "f ␣ ␣ 42"? does the OverlappingInstances witchcraft help there? (i have no clue)
08:07:06 <kmc> haskell is just not the right language if you want to customize syntax at that low level
08:07:38 <byorgey> now, if RebindableSyntax extended to function application... well!
08:07:59 <Eduard_Munteanu> Overloaded whitespace :P
08:07:59 * byorgey is not actually advocating such a state of affairs
08:08:27 <byorgey> we already have overloaded semicolons, why not overloaded whitespace? ;)
08:08:50 <copumpkin> overload all the things!
08:08:58 <Eduard_Munteanu> Semicolons? Hm, do you mean do syntax?
08:09:04 <geheimdienst> overload wall street
08:09:11 <mroman> Everyday I find a haskell feature I've no clue about and probably never will have.
08:09:18 <copumpkin> mroman: aw, don't say that
08:09:24 <copumpkin> they're fun to learn and very educational
08:09:34 <mroman> btw: Is it possible to hack do-syntax for something non-monadic?
08:09:41 <Philonous_> mroman:  Yes
08:09:43 <mroman> like
08:10:06 * Eduard_Munteanu remembers playing with that for a co-do syntax
08:10:09 <mroman> using other functions instead of >> and >>=
08:10:16 <Eduard_Munteanu> (which didn't make much sense after all)
08:10:24 <Eduard_Munteanu> mroman: yeah
08:10:24 <Philonous_> mroman:  You need to define (>>=) and (>>) and enable RebindableSyntax and NoImplicitPrelude
08:10:31 <geheimdienst> at this point i'm thinking ␣ is best implemented as a small extension, or as some TH thingy. question is if it's worth it
08:10:33 <kmc> you can't do it in standard Haskell though
08:10:44 <rwbarton> if you enable certain GHC options, it will use whatever (>>=) and (>>) are in scope
08:12:22 <ezyang> http://hackage.haskell.org/trac/ghc/changeset/92e7d6c92fdd14de424524564376d3522f2a40cc whooo
08:13:33 <kmc> nice
08:13:47 <kmc> what's the main use case?
08:14:07 <copumpkin> not having to predict capability use at program startup, maybe?
08:14:32 <kmc> if you just want one capability per core, you can compile with ghc -with-rtsopts=-N
08:14:34 <quicksilver> geheimdienst: take a look at the thread here - http://www.haskell.org/pipermail/haskell-cafe/2007-July/027848.html
08:14:53 <ezyang> http://hackage.haskell.org/trac/ghc/ticket/3210
08:14:59 <quicksilver> geheimdienst: and in particular conor's reply to me http://www.haskell.org/pipermail/haskell-cafe/2007-July/027896.html
08:15:09 <ezyang> hlint -j3 is in particular a pretty good reason, IMO.
08:15:15 <ezyang> Esp if rtsopts is disabld
08:15:22 <geheimdienst> quicksilver: wow, interesting, checking it out
08:15:30 <Eduard_Munteanu> kmc: pffft.... don't you hotplug CPUs? :P
08:15:43 <kmc> only when i'm testing altinstructions
08:16:29 * quicksilver hotunplugs all his CPUs and runs his IRC client on a NIC with hacked firmware
08:19:46 <roconnor> quicksilver: using Nix I can seemlessly transfer live my entire operating environment to the firmware of my router while I hot unplug my CPU.
08:25:19 <KirinDave> So… I am a bit confused by something
08:25:30 <KirinDave> Using HSH with haskell 7.2.*, I get the error
08:25:43 <KirinDave> "Exception: HSH/Command.hs:(289,14)-(295,45): Missing field in record construction System.Process.Internals.create_group"
08:25:51 <KirinDave> How on earth is this a runtime error?!
08:26:00 <kmc> you mean GHC 7.2.*?
08:26:09 <quicksilver> it's a "feature" of records, KirinDave
08:26:11 <KirinDave> kmc: Sorry, yes.
08:26:14 <quicksilver> you can construct them partially.
08:26:24 <KirinDave> Man I didn't even know that.
08:26:27 <kmc> yeah, it is sometimes useful
08:26:29 <quicksilver> it's designed as a way to produce hard to track down errors.
08:26:32 <KirinDave> I guess no one told me.
08:26:37 <KirinDave> Because that is a horrible idea.
08:26:49 <kmc> at least you got a line number, right?  cause that's better than you usually do with runtime errors in haskell
08:26:54 <parcs> it is a compile-time error if you compile with -Wall and -Werror
08:26:55 <Eduard_Munteanu> Not much different than filling them with 'undefined' yourself, though.
08:26:56 <KirinDave> Yeah
08:26:57 <rwbarton> not like you can't do the same thing without record syntax
08:27:07 <geheimdienst> i think it produces "omg uninitialized record fields" warnings if you compile with -Wall
08:27:08 <rwbarton> it is just easier to do so accidentally with record syntax
08:27:11 <KirinDave> Eduard_Munteanu: actually in this case I suspect I know how to patch it.
08:27:31 <KirinDave> I am just surprised that hsh isn't already patched for this, though.
08:27:44 <kmc> Eduard_Munteanu, it allows the person defining the record to add fields without modifying every piece of code that uses it
08:27:50 <KirinDave> It is not a subtle error, and hsh has updates as recently as Oct 11.
08:27:53 <Eduard_Munteanu> KirinDave: I'd check latest git/darcs/release
08:27:55 <kmc> but i think this isn't usually what you want
08:28:28 <KirinDave> Oh interesting, the code IS there
08:28:34 <KirinDave> https://github.com/jgoerzen/hsh/blob/master/HSH/Command.hs#L313
08:28:38 <KirinDave> But it's hidden behind a conditional.
08:28:51 * hackagebot twitter-enumerator 0.0.1.1 - Twitter API package with enumerator interface and Streaming API support.  http://hackage.haskell.org/package/twitter-enumerator-0.0.1.1 (TakahiroHimura)
08:28:55 * geheimdienst is disliking CPP more and more
08:28:59 <kmc> did you build HSH with cabal?
08:29:05 <kmc> it should automatically define that macro
08:29:12 <kmc> and ghc-7.2 ships with process-1.1.something
08:29:29 <KirinDave> kmc: Well it is surely not, for me.
08:29:37 <mm_freak_> which GHC version do i need for the ConstraintKinds extension?
08:29:38 <kmc> but you are using cabal
08:29:45 <KirinDave> kmc: cabal-dev, yes.
08:29:54 <parcs> mm_freak_: 7.3/7.4
08:29:55 <KirinDave> kmc: So this becomes a nastier bug now, huh?
08:29:59 <mm_freak_> parcs: thanks
08:30:05 <kmc> KirinDave, what do you see in dist/build/autogen/cabal_macros.h
08:30:35 <geheimdienst> mm_freak_: here's a good overview of 7.4 http://hackage.haskell.org/trac/ghc/wiki/Status/Oct11
08:30:41 <KirinDave> kmc: Process isn't even mentioned there
08:30:52 <KirinDave> kmc: Oh wait, for...
08:30:58 <KirinDave> kmc: For an install of hsh?
08:31:14 <Eduard_Munteanu> Is HSH supposed to be a Haskell shell?
08:31:15 <kmc> in the source tree where you built it
08:31:16 <KirinDave> kmc: Like you want me to unpack hsh into a dir and build it?
08:31:22 <KirinDave> kmc: I didn't build hsh
08:31:27 <kmc> Eduard_Munteanu, http://hackage.haskell.org/package/HSH
08:31:29 <Eduard_Munteanu> Or it's just a piece of that picture?
08:31:39 <KirinDave> kmc: Or rather I let cabal-install do it
08:31:45 <kmc> ok
08:32:02 <Eduard_Munteanu> kmc: yeah, I've seen that, but I was wondering if it's usable as a shell (say bash) replacement
08:32:18 <kmc> well try installing it again with 'cd /tmp; cabal unpack HSH; cd HSH-*; cabal install'
08:32:22 <kmc> then you can poke around that dist/ directory
08:32:31 <Eduard_Munteanu> IIRC there were some projects like that.
08:34:36 * KirinDave winces at the pages and pages of linker warnings.
08:34:49 <geheimdienst> KirinDave: mac os x?
08:34:51 <KirinDave> Yes
08:36:23 <geheimdienst> right, there's something borked. other people are having the same trouble
08:37:38 <KirinDave> kmc: Yeah the macro definition is there and looks like it will succeed on 1.1.0
08:38:00 <quicksilver> Eduard_Munteanu: HSH isn't really a shell; it's some shell-like composition styles to use in a program. You could use it in ghci for a slightly shell-like experience
08:38:10 <Eduard_Munteanu> Ah.
08:40:15 <KirinDave> Hum
08:40:33 <KirinDave> Eduard_Munteanu: it's useful when you need to do things like move groups of files or react to shell globs
09:15:53 <balodja> One small question. Can Writer monad be represented as adjunction of functors between categories Hask and W, where W is some subcategory of Hask?
09:16:06 <DukeDave> Ah there any cabal devs around? I have an outlandish question..
09:16:49 <kmc> just ask
09:19:08 <DukeDave> I'm working on wxhaskell, and we're trying to reduce compile times by eliminating the needless recompilation of all the c-sources every time a build is called (this occurs even if none of the c-sources have changed).
09:19:42 <acowley> I think that's a GHC thing rather than a cabal thing
09:19:48 <dcoutts> no, it's a cabal thing
09:20:11 <acowley> well then, I'll go with dcoutts's answer over mine :)
09:20:17 <dcoutts> DukeDave: I don't have any particular suggestions (except to build the lib externally)
09:20:49 <DukeDave> dcoutts: Okay, that's what I'm working on: I wrote a little function which filters out the c-sources which haven't changed
09:21:06 <DukeDave> The problem now is that files which aren't in c-sources don't appear to be linked in..
09:21:24 <DukeDave> .. Even though their corresponding .o files are still present in ./dist
09:21:33 <dcoutts> DukeDave: right
09:21:40 <dcoutts> it doesn't just link in *.o :-)
09:21:57 <dcoutts> it knows which files you asked for and it compiled
09:22:14 <DukeDave> I just wanted to check there's no complex reason this doesn't happen already
09:22:27 <DukeDave> On the assumption that the cabal team are smarter than I am :)
09:22:48 <dcoutts> the simple reason is that cabal's "Simple" build system isn't very good
09:22:52 <sefb1704> Hey guys i will get to the point right away: i got a function. i want to create a contract for it. my function takes another function and a list as an argument. my proposal: ([a] -> [a]) -> [a] -> [a] okey i will explain this. the thing in the brackets? its the function that i give to my function. the following list is the list i give to the function and the last list should be my result what is also a list
09:23:00 <DukeDave> dcoutts: Excellent :)
09:23:01 <dcoutts> it's got no real dependency tracking
09:23:15 <dcoutts> but the solution to that problem is not simple
09:24:03 <roconnor> sefb1704: sounds resonablish so far
09:24:26 <endojelly> sefb1704, yes.
09:24:32 <kosmikus> only that we call it "type" rather than "contract"
09:25:13 <kmc> also you can just write the function and then ask ghci what its type is
09:25:13 <endojelly> (and even in languages where it's common to talk about contracts they still have types, which aren't the whole contract)
09:25:17 <sefb1704> okay. i get errors because i dont give haskell what it expects :/ but posting the error code wont help you because this is somehow part of a sudoku code and i hope its not necessary to post the whole sudoku code to solve the problem
09:25:39 <endojelly> sefb1704, posting the error might still totally help
09:25:47 <geheimdienst> sefb1704: you can use hpaste for longer messages
09:25:48 <geheimdienst> @where hpaste
09:25:49 <lambdabot> http://hpaste.org/
09:25:51 <kmc> what if you leave off the type signature entirely
09:25:54 <kmc> and then ask in ghci
09:26:05 <kmc> with :t
09:26:39 <sefb1704> @kmc okey, does this work?!
09:26:39 <lambdabot> Maybe you meant: ghc rc src
09:26:42 <sefb1704> i will try
09:26:49 <kmc> does what work?
09:26:58 <DukeDave> dcoutts: So, it's gcc specific, but my implementation uses: "gcc -M"  ( http://gcc.gnu.org/onlinedocs/cpp/Invocation.html )
09:27:08 <kmc> in Haskell you are usually not required to write a type
09:27:14 <kmc> because the compiler can infer the correct type
09:27:29 <sefb1704> oh wow
09:27:29 <kmc> it's considered good style to write type signatures for everything defined at the module top level, though
09:27:40 <sefb1704> haskell tells me that the type of my function is the following: ([a] -> t) -> [a] -> [t]
09:27:45 <sefb1704> this is an awesome trick! :O
09:27:50 <kmc> yeah
09:28:12 <kmc> type inference has been around for at least 40 years
09:28:23 <kmc> but "mainstream languages" don't seem to have caught onto it yet
09:28:45 <mercury^> kmc: mainstream languages such as C++? :P
09:28:46 <sefb1704> i wonder why the function i give to my function does not return a list but okey ..
09:29:04 <kmc> sefb1704, well, it can return a list, but in that case the whole thing returns a list of lists
09:29:06 <kmc> t = [b]
09:30:00 <sefb1704> kmc! t = [b] i didnt know that! thank you :)
09:30:26 <kmc> ?
09:30:29 <endojelly> sefb1704, t *can* be [b], it doesn't have to!
09:30:39 <kmc> yeah, that is what i meant
09:30:51 <kmc> t is just a variable like any other
09:30:53 <sefb1704> so why do i write [a] at all, if i could just write a ?
09:30:58 <endojelly> sefb1704, but if t is [b], then the function which takes it as an argument returns [[b]]
09:31:05 <kmc> sefb1704, sometimes something *has* to be a list
09:31:18 <kmc> sefb1704, and sometimes it's allowed to be a list, but the function is oblivious to this
09:31:22 <sefb1704> endojelly, yes thats right, this also kind of annoys me but im okey with that
09:31:48 <sefb1704> kmc, okey, thanks
09:32:34 <sefb1704> i was thinking about this for at least 1 hour last weakend without being able to solve it and now i just enter this irc and get a simple answer right away :O
09:35:07 <roconnor> or if the type signature isn't what you expect, maybe your function isn't implemented correctly.
09:35:46 <acowley> Is there a canonical type (and instances) for dual numbers anywhere?
09:36:12 <roconnor> acowley: is that Dif?
09:36:22 <roconnor> from the numbers package?
09:38:25 <acowley> roconnor: it's close, but that's not quite what I was looking for
09:38:46 <roconnor> there are several packages implementing variants of Dif IIRC
09:39:09 <acowley> roconnor: what I need is something like Complex, but instead of i, uses a coefficient ε² = 0
09:39:17 <roconnor> acowley: that's what Dif is
09:39:50 <acowley> it seems to be quite a bit more
09:40:02 * roconnor looks
09:40:25 <acowley> there is a Dual type in FAD, but I don't want a dependency on FAD
09:40:42 <acowley> err
09:40:42 <roconnor> acowley: you are right
09:40:46 <acowley> but it's quite similar to Dif
09:40:55 <Sgeo> FAD?
09:40:58 <roconnor> I've implement dual numbers
09:41:00 <acowley> well, I wrote my own anyway
09:41:22 <roconnor> And, like I said, there are several versions of Dif like libraries
09:41:34 <roconnor> one or more will be what you want
09:42:20 <acowley> I think I'm going to stick with my own for the time being. I don't want to pull in anything massive for this little ordered pair type.
09:42:53 <roconnor> http://vandreev.wordpress.com/2006/12/04/non-standard-analysis-and-automatic-differentiation/
09:42:53 <acowley> @hackage fad
09:42:54 <lambdabot> http://hackage.haskell.org/package/fad
09:43:05 <roconnor> http://blog.sigfpe.com/2005/07/automatic-differentiation.html
09:43:48 <acowley> roconnor: ah! the one at the first link is almost exactly what I wrote
09:44:53 <roconnor> http://r6.ca/blog/20070820T175938Z.html <- click on "my own implementation"
09:45:17 <acowley> hm, with some differences
09:45:40 <acowley> yes, that one is even closer to what I wrote
09:45:59 <roconnor> that last one is mine
09:46:25 <acowley> one thing that I picked up from yet another blog post was the idea of making pi = pi :+ (2*pi)
09:46:47 <acowley> http://ardoris.wordpress.com/2010/12/10/dual-numbers-automatic-differentiation-haskell/
09:49:41 <roconnor> acowley: why is it snowing on the letters on the page?
09:49:47 <roconnor> or maybe I'm having a siezure
09:50:20 <acowley> roconnor: I think you have an extra negate in your acosh definition
09:50:30 <acowley> roconnor: yes, I went through the seizure self-diagnosis earlier, too
09:50:55 <byorgey> hahaha
09:51:02 <rwbarton> oh wow that's creepy
09:51:12 <byorgey> wordpress has this really really stupid feature where you can enable "snow" on your blog during december or something
09:51:16 <scshunt> win 4
09:51:59 <rwbarton> I didn't see it for a while even after roconnor mentioned it
09:52:00 <kmc> what if you live in the southern hemisphere
09:52:08 <rwbarton> then the snow falls up, duh
09:52:20 <byorgey> kmc: don't be silly, no one actually lives there
09:52:22 <dmos> cabal q: is the new test-suite mechanism setting a flag I can test against in the cabal config?
09:52:46 <dcoutts> dmos: no, why would you want that?
09:53:19 <dcoutts> you shouldn't be altering anything outside the test suite based on whether or not you're building the test suite
09:53:19 <dmos> dcoutts: I don't want to duplicate dependencies in different configurations. I'd rather list all deps conditionally in the library section.
09:53:31 <acowley> dcoutts: to substitute in a version of the library that passes the tests
09:53:35 <rwbarton> I don't understand "pi = pi :+ (2*pi)"...
09:53:37 <roconnor> acowley: that definition of Pi is interesting
09:53:44 <byorgey> acowley: hahaha
09:53:48 <dcoutts> acowley: ;-)
09:53:50 <acowley> rwbarton: don't overlook the (:+)
09:54:08 <rwbarton> no it just doesn't make sense
09:54:33 <byorgey> oh man, I was going to read that blog post but the snow is really too distracting =P
09:54:48 <dcoutts> dmos: don't do that. Users who choose to enable tests for packages they build would end up with something different.
09:54:48 <rwbarton> I mean... if you are working over a field then you have automorphisms of your ring of dual numbers where you scale "ε" by any nonzero factor
09:55:13 <acowley> byorgey: it really took me several minutes because I sat there blinking really hard thinking my sight was going, then started pricing out a new laptop, and *then* realized it was the stupid page
09:55:22 <byorgey> hahaha
09:55:38 <dcoutts> dmos: if you're doing external testing then you can make your testsuite depend on the lib
09:55:59 <dmos> dcoutts: how would they end up with something different?
09:55:59 <rwbarton> so you can't distinguish pi :+ (2*pi) from any other pi :+ x for nonzero x
09:56:07 <roconnor> rwbarton: I'm not entirely convinced by it either
09:56:17 <dmos> dcoutts: and what do you mean by external testing? a separate cabal file?
09:56:19 <dcoutts> dmos: they'd end up with a lib that depends on lots of extra packages unnecessarily.
09:56:24 <rwbarton> by the same token if you look at his formula > cos (D a b) = D (cos a) (b*(- sin a)) there is no way to get his definition of pi from that
09:56:35 <dcoutts> dmos: external as in only using the exposed modules of the package
09:56:45 <dmos> dcoutts: no, that's why they are included conditionally on whether --enable-tests was set.
09:57:06 <dcoutts> dmos: yes, exactly, users who enable tests will get a different library installed
09:57:16 <dcoutts> that's not a good thing
09:57:26 <dmos> dcoutts: ok, gotcha.
09:57:40 <acowley> rwbarton: okay, I'll put my definition back to the traditional one
09:57:55 <dcoutts> paranoid users should be able to enable tests for all packages
09:58:25 <dmos> dcoutts: so is there no possibility to 'include everything that the lib dependent upon'?
09:58:34 <dcoutts> dmos: not currently
09:58:35 <roconnor> rwbarton: I see you are right
09:58:49 <dmos> dcoutts: ok.
09:58:57 <dcoutts> dmos: there's some ideas floating around for how we might reduce redundancy, but we've not implemented any yet
10:02:34 <sefb1704> umm one question: how do use composition ( . ) on two functions that have 2 arguments each?
10:02:44 <kmc> can't
10:02:46 <kmc> won't do what you want
10:03:07 <byorgey> sefb1704: can you give an example of what you are trying to do?
10:03:15 <kmc> you can write a lambda expression like  (\x y -> f (g x y) q)
10:03:23 <kmc> or whatever it is that you want
10:03:37 <sefb1704> i want to use map to the result of another function i have created myself
10:03:41 <dmos> dcoutts: ok. There's also the issue that --enable-tests doesn't work with install --dependencies-only and I think I saw a bugreport on that one (can't seem to find it right now).
10:03:48 <dmos> dcoutts: Has that been fixed by any chance in cabal darcs?
10:04:02 <sefb1704> kmc, its a task, i am forced to use composition
10:04:08 <dcoutts> dmos: not yet, it was just reported a couple days ago I think
10:04:25 <byorgey> sefb1704: well, if you partially apply map you get a function which only takes one argument
10:04:52 <byorgey> > map succ . replicate 3 $ 'a'   -- like this
10:04:54 <lambdabot>   "bbb"
10:05:07 <dmos> dcoutts: ok. Thanks for the help. I'll run with the duplicated depencies/external tests for now.
10:05:38 <sefb1704> byorgey, mapstride = (map . stride) and stride and map both take 2 arguments, i want to give 9 and a list to stride and a function and the result of stride to map ^^
10:06:38 <sefb1704> byorgey, my try: mapRows f xs = mapstride f (9 xs) but thats wrong
10:06:41 <byorgey> sefb1704: perhaps you want   map f . stride 9
10:06:48 <sefb1704> okay
10:06:51 <roconnor> sefb1704: mapstride f x y = map f (stride x y)  ?
10:07:11 <sefb1704> roconnor, i have to use the stupid composition thing ^^
10:07:27 <roconnor> oh
10:07:31 <roconnor> pfft
10:07:37 <roconnor> @pl mapstride f x y = map f (stride x y)
10:07:38 <lambdabot> mapstride = (. stride) . (.) . map
10:08:30 <sefb1704> byorgey, mapRows f xs = map f . stride 9 doesnt work :(
10:08:43 <byorgey> sefb1704: well you have to do something with xs
10:09:23 <sefb1704> maybe mapstride f = map f . stride 9 and then the main function = mapstride xs
10:09:23 <sefb1704> ?
10:09:35 <byorgey> sefb1704: sounds good to me
10:09:45 <sefb1704> byorgey, yay :)
10:09:49 <byorgey> sefb1704: err, almost
10:09:59 <byorgey> sefb1704: the first argument to mapstride has to be the function you want to map
10:10:03 <sefb1704> byorgey, i was just about to test this but okey ;D
10:10:05 <byorgey> sefb1704: so you can't just say  mapstride xs
10:10:17 <byorgey> maybe I should just let you see what error you get =)
10:10:17 <sefb1704> hmkay..
10:10:23 <sefb1704> okey
10:11:40 <sefb1704> ah i got it. i corrected it while testing it ^^
10:11:44 <byorgey> sefb1704: great =)
10:11:47 <sefb1704> mapRows f xs = mapstride f xs
10:12:20 <sefb1704> mapstride f = map f . stride 9
10:12:30 <byorgey> sefb1704: in that case  mapRows and mapstride are exactly the same, so there's no need for both
10:12:39 <byorgey> sefb1704: looks good though
10:13:16 <sefb1704> okey .. but i cant imagine how i use composition on them .. mapRows f xs = (map f . stride 9) xs ?
10:13:31 <byorgey> sefb1704: yep
10:13:35 <Botje> yes.
10:13:42 <byorgey> sefb1704: you can also just write  mapRows f = map f . stride 9.
10:13:43 <sefb1704> yay :)
10:13:45 <byorgey> no need to mention xs.
10:13:50 <sefb1704> okay Oo
10:14:34 <byorgey> sefb1704: instead of saying 'here is what mapRows f does to an argument xs' you are just saying 'here is how mapRows f is defined: it is a composition of two other functions'
10:15:03 <byorgey> @where ops
10:15:03 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
10:15:09 <sefb1704> oh nice this even works :O
10:15:18 <byorgey> any #haskell ops have any idea why shepheb can't seem to talk in #haskell?
10:15:42 <byorgey> sefb1704: heh, always nice when it is theoretically correct AND it works! =)
10:15:58 <Botje> 19:40 -!- #haskell q *!*@taurine.csclub.uwaterloo.ca  ChanServ!ChanServ@services. 1323132389
10:16:12 <byorgey> Botje: what does that mean?
10:16:16 <roconnor> I thought that ban as excessive when I first saw it go up
10:16:22 <Botje> quieted
10:16:37 <Botje> someone at that host was being abusive some time in the past, i guess
10:16:48 <byorgey> oh. yes, that does seem excessive.
10:16:53 --- mode: ChanServ set +o roconnor
10:17:00 <sefb1704> this is just awesome, thanks guys i will try to solve the rest of the tasks without asking you ^^ by the way i am working on a haskell - textadventuregame ! i will post it in here when its finished so you can play it ;D
10:17:16 <mzero> any of the foldrTree students here?
10:17:20 <byorgey> sefb1704: sounds fun!
10:17:21 <DevHC^> WAT? someone denying free speech here?
10:17:35 <Botje> no free speech for trolls ;)
10:17:42 <DevHC^> NO U
10:17:55 <sefb1704> ok bye
10:18:14 <roconnor> okay, so it seems I don't know how to unquite / quiet people
10:18:29 <Botje> /mode -q *!*@taurine.csclub.uwaterloo.ca
10:18:30 --- mode: ChanServ set +o Saizan
10:18:33 <Botje> I'd think.
10:18:45 <Botje> unless you have to do it using chanserv
10:18:53 --- mode: Saizan set -q *!*@taurine.csclub.uwaterloo.ca
10:19:04 --- mode: Saizan set -o Saizan
10:19:19 --- mode: roconnor set -o roconnor
10:19:20 <Saizan> Botje: yeah
10:22:36 <shepheb> testing
10:22:42 <shepheb> Botje: byorgey: thank you
10:23:01 <shepheb> so now, my question: I saw the thread on using GHC->LLVM->Javascript using Emscripten to compile the LLVM to Javascript. no one updated the thread to say how well it worked, though. has anyone tried it?
10:23:18 <copumpkin> shepheb: sorry about that. I asked chanserv to quiet someone but it picked a very general hostmask to do so
10:23:58 <shepheb> copumpkin: no worries. hopefully whoever from the CS Club was being annoying has given up.
10:24:10 <copumpkin> it's kind of a recurring person :)
10:24:13 <copumpkin> we'll see if they keep recurring
10:37:13 <Lajla> Is there a  'null monad' as in, an IO () that does nothing?
10:37:17 <Lajla> Like an identity of the >> operator?
10:37:23 <Lajla> Bcause I want it
10:37:25 <Lajla> it must be mine
10:37:27 <Lajla> Yeees
10:37:35 <Lajla> I much so require it
10:38:56 <doserj> Lajla: are you looking for mzero? or for Control.Monad.Identity?
10:39:10 <mzero> I'm here!
10:39:14 <mzero> :-)
10:39:33 <mzero> :t return ()
10:39:35 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
10:39:45 <mzero> is that what you're after?
10:39:50 <Lajla> doserj, ehh, I dunno yet. Basically I want the x such that randomMonand >> x has the same result as randomMonad
10:40:16 <mzero> can't do that… as >> will discard the left-hand result, right?
10:40:22 <rwbarton> return () is what you're looking for
10:40:33 <mzero> but      randomMonad >>= return     works
10:40:42 <mzero> assuming you want the result of randomMonad
10:40:51 <Lajla> Yeah, (return ()) seems to work.
10:40:53 <mzero> and if not, then yes,     randomMonad >> return ()
10:40:55 <Lajla> I do not
10:40:57 <rwbarton> oh, well, it won't have the same "result" unless randomMonad :: IO (), but it has the same effects
10:41:04 <Lajla> it is not a cog in my plans for world domination.
10:41:09 <Lajla> It suffices
10:41:25 <Lajla> I am most grateful, when this world is mine I will kill you last.
10:43:08 <mreh> you won't get far using pseudo random number generation
10:43:14 <mreh> all your cryptography will be weak
10:45:51 * jessopher scratches his head, pondering a Const monad.
10:47:06 <jessopher> yeah, that wouldnt make any sense
10:48:00 <mzero> see http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:Const
10:48:13 <mzero> though it isn't a Monad instance -- though can't see why not
10:48:25 <jessopher> because of the type of >> i think
10:48:34 <dmwit> roconnor: thanks =)
10:49:08 <byorgey> mzero: there is no way to implement join sensibly, in general
10:49:12 <mzero> ah - no, because of return --- what value of a would it choose
10:49:21 <byorgey> mzero: ah, that too =)
10:49:34 <byorgey> mzero: I think it would work if a is an instance of Monoid
10:50:35 <mzero> now     data MConst a = MConst; instance Monad MConst where; return _ = MConst; a >>= f = MConst;
10:50:38 <mzero> I think that works
10:51:13 <jessopher> some evil twin of monad where (foo :: m a >> bar :: m b) :: m a
10:51:41 <mzero> instance (Monoid a) => Monad (Const a) where; return _ = Const mzero; a >>= f = Const mzero
10:52:08 <byorgey> mzero: yes, that works if you interpret the monad laws in a strict subset of Haskell
10:52:11 <byorgey> (which is fine with me)
10:52:50 <byorgey> mzero: I was thinking more like  instance (Monoid a) => Monad (Const a) where; return _ = Const mzero; (Const a) >>= (Const f) = Const (a `mappend` f)
10:53:32 <mzero> your type of the right hand side of >>= is incorrect
10:53:48 <mzero> must be a function that … well… can't ever be called
10:53:51 <byorgey> ah, right, sorry
10:54:04 <mzero> … 'cause we have no value of type b
10:54:09 <byorgey> oh, yeah, this doesn't work
10:55:50 * byorgey goes back to working on grant proposal =P
10:55:56 <simon> do people generally use liftM2/3/4, or does some other style often superseed it?
10:56:58 <mzero> I sometimes use liftM2 … but never the others -- then I use ap   or <$> and <*> if possible
10:57:00 <Ferdirand> theres f <$> a <*> b <*> c
10:57:29 <simon> Ferdirand, ah yes.
10:57:43 <mzero> and I suppose I think liftM is clearer in many cases, but it isn't in the Prelude, so if I don't have Control.Monad imported…. I just use fmap
10:57:54 <mzero> and now…. after doing that for so long… I just use fmap all the time
10:58:09 <shachaf> mzero: Why is liftM clearer than fmap?
10:58:18 <simon> mzero, I'd use fmap if it wasn't because I use liftM2 and liftM3 just as much in this parser.
10:58:35 <mzero> well - they're identical --- so it is just I like emphasizing the "lifting" aspect of the operation
10:58:47 <shachaf> mzero: As opposed to what?
10:58:55 <shachaf> You could at least use "liftA"...
10:58:55 <mzero> fmap doesn't include the letters "lift"
10:59:05 <mzero> well - that isn't in the Prelude either!
10:59:20 <shachaf> True.
10:59:31 <shachaf> But when you get to liftA2 you can use it. :-)
11:01:32 <xplat> > map succ . "xplat"
11:01:34 <lambdabot>   Couldn't match expected type `[a]'
11:01:34 <lambdabot>         against inferred type `GHC.Types...
11:01:46 <xplat> > map succ "xplat"
11:01:47 <lambdabot>   "yqmbu"
11:01:50 <xplat> > map pred "xplat"
11:01:52 <lambdabot>   "wok`s"
11:07:15 <Philonous_> > succ . "HAL 9000"
11:07:17 <lambdabot>   "IBM!:111"
11:07:24 <mzero> I use map succ to encode hints in my Haskell tutorial!
11:07:56 <shachaf> > rot13 "shachaf"
11:07:58 <lambdabot>   "funpuns"
11:08:13 <mzero> you're seekret is out!
11:08:18 <mzero> >rot13 mzero
11:08:25 <mzero> > rot13 "mzero"
11:08:28 <lambdabot>   "zmreb"
11:08:56 <Philonous_> > rot13 [0..9]
11:08:58 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:08:58 <lambdabot>    arising from the literal `0...
11:09:01 <Philonous_> > rot13 . [0..9]
11:09:02 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:09:03 <lambdabot>    arising from the literal ...
11:09:30 <mzero> oooo - two pairs of mutual encoded characters in mzero!!
11:10:20 <mzero> Philonous_seems dot-happy  :-)
11:14:51 <monochrom> wait, is that why you chose shachaf to be your nick? because it's funpuns?
11:15:55 <shachaf> monochrom: I chose it because it's my first name.
11:16:06 <shachaf> monochrom: But it's a happy coincidence.
11:16:12 <aristid> shachaf: so your parents chose it because it's funpuns?
11:16:18 <donri> tldr shachaf didn't chose it, ey's parent's did
11:16:30 <monochrom> the plot thickens
11:16:33 <shachaf> aristid: Unlikely; "shachaf" is a transliteration.
11:16:46 <shachaf> donri: "ey's"? Wouldn't that be "eir" or something?
11:17:11 <donri> fuck if i know!
11:17:22 <donri> let's just settle for "its"
11:17:30 <acowley> there are worse ways of coming up with children's names
11:17:38 <acowley> take a popular name of the day, rot13 it
11:17:41 <acowley> > rot13 "tyler"
11:17:44 <lambdabot>   "glyre"
11:17:51 <donri> i recall reading about a couple who taught their child only pig latin
11:18:44 <shachaf> > rot13 "acowley"
11:18:46 <lambdabot>   "npbjyrl"
11:18:48 <shachaf> > rot13 "anthony"
11:18:50 <lambdabot>   "nagubal"
11:18:50 <shachaf> Hmm, not bad.
11:18:56 <shachaf> "nagubal" is a pretty good nick.
11:19:08 <monochrom> > rot13 "monochrom"
11:19:10 <lambdabot>   "zbabpuebz"
11:19:13 <donri> > rot13 . rot13 $ "rot13"
11:19:15 <lambdabot>   "rot13"
11:19:20 <donri> ROT THIRTEEN
11:20:04 <acowley> "zbabpuebz" now there's a name no peer could tease you over!
11:20:11 <donri> > rot13 "bögjävel"
11:20:13 <lambdabot>   "o\246tw\228iry"
11:21:45 <Philonous_> acowley:  Try introducing yourself with that name without everyone thinking you where having a seizure
11:22:54 <acowley> Hm, my parents could have named me "Nagubal" which I think would have required I marry a woman named Zuul.
11:24:32 <shachaf> > rot13 "ivan"
11:24:34 <lambdabot>   "vina"
11:24:50 <keep_learning> :t putMVar
11:24:51 <lambdabot> Not in scope: `putMVar'
11:25:01 <donri> @hoogle putMVar
11:25:02 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
11:25:02 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
11:28:26 <aristid> > rot13 "Nagubal"
11:28:28 <lambdabot>   "Anthony"
11:28:40 <aristid> > rot13 "Zuul"
11:28:42 <lambdabot>   "Mhhy"
11:28:54 * hackagebot csv-enumerator 0.10.1.0 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.10.1.0 (OzgunAtaman)
11:28:56 * hackagebot type-unary 0.1.13 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.1.13 (ConalElliott)
11:35:01 <plat0> I would like to make a "binary tree" where there is sharing of subtrees, so that going down the left path, then the right path gets you to the same node as going down the right, then left.  Then I would like to propagate information from the leaves to the root in polynomial time, rather than in exponential as would happen in the case without sharing.  My naive effort has failed.  Any hints?
11:36:34 <Saizan> you can use a graph representation to make the sharing explicit
11:36:34 <simon> plat0, what you want is a DAG.
11:36:43 <simon> plat0, (directed, acyclic graph)
11:37:08 <plat0> OK one would certainly suffice
11:37:33 <plat0> (although my case is much simpler than a general DAG, so perhaps there's a less complicated way)
11:38:35 <plat0> I thought GHC might notice that large parts of my structure were shared, and take that into account, but it didn't.
11:40:28 <plat0> I feel I need a more cunning data representation.
11:42:47 <Botje> like a fox!
11:42:57 <Botje> or a weasel
11:44:10 <plat0> I feel it needs to be as cunning as a fox who has just been appointing professor of cunning Oxford University.
11:44:47 <carpi> what does it mean when ghci says cannot construct infinite type a0 = [a0]? Does it mean, that I am creating an infinite list?
11:45:12 <roconnor> dmwit: I'm curious if you used uncurryRGB or not before my message?
11:45:54 <tomprince> It means you are trying to create a type, who elements are lists of things of that type.
11:46:18 <carpi> a recursive type?
11:46:25 <tomprince> Yes.
11:46:41 <carpi> are you saying i managed to confuse ghci? :D
11:46:45 <carpi> just kidding.
11:47:28 <tomprince> I suspect you are tring to use a variable both as a list, and an element of list.
11:47:37 <aristid> carpi: recursive types are not allowed :)
11:47:55 <hpaste> Carpi pasted “recursive type?” at http://hpaste.org/54936
11:47:56 <aristid> carpi: at least not this kind
11:47:57 <tomprince> :t x : x
11:47:59 <lambdabot>     Couldn't match expected type `[Expr]' against inferred type `Expr'
11:47:59 <lambdabot>     In the second argument of `(:)', namely `x'
11:47:59 <lambdabot>     In the expression: x : x
11:48:05 <naf456> haha
11:48:43 <aristid> carpi: you probably need ++ rather than :
11:49:40 <donri> :t x : x : []
11:49:41 <lambdabot> [Expr]
11:50:03 <carpi> aristid: true.. but there should be a way to do it without ++ because my logic in that code was to flatten the elements of the list one by one
11:50:20 <aristid> @src (++)
11:50:21 <lambdabot> []     ++ ys = ys
11:50:21 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:50:21 <lambdabot> -- OR
11:50:21 <lambdabot> xs ++ ys = foldr (:) ys xs
11:50:28 <monochrom> what is myConcat supposed to do?
11:50:42 <aristid> monochrom: i was guessing by the name.
11:50:46 <carpi> the same as concat.. : D
11:51:00 <monochrom> then screw makeFlat
11:51:13 <carpi> please ignore my ignorance.. im as fresh as they get when it comes to all things haskell : )
11:51:23 <aristid> i guess carpi added makeFlat in an attempt to "fix" the type error
11:51:27 <monochrom> @src concat
11:51:28 <lambdabot> concat = foldr (++) []
11:51:35 <monochrom> ah, I'll write it out
11:51:41 <Shammah> let f a b = f b a    I know there was a function exactly like this in Prelude but I can't find it's name :(
11:51:53 <mux> flip
11:52:01 <Shammah> ah, thanks ;D
11:52:10 <monochrom> myconcat [] = []; myconcat (x:xs) = x ++ myconcat xs
11:52:15 <aristid> :t foldr (flip $ foldr (:))
11:52:16 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:52:27 <carpi> monochrom: i added makeFlat so that it returns an incomplete list which would be completed by a recursive call to myconcat
11:52:37 <aristid> > foldr (flip $ foldr (:)) [] [[1,2,3],[4,5,6]]
11:52:38 <lambdabot>   [1,2,3,4,5,6]
11:52:48 <monochrom> @let myconcat [] = []; myconcat (x:xs) = x ++ myconcat xs
11:52:49 <lambdabot>  Defined.
11:53:00 <monochrom> > myconcat [[1,2,3], [], [4,5,6]]
11:53:02 <lambdabot>   [1,2,3,4,5,6]
11:53:11 <aristid> @unpl foldr (flip $ foldr (:)) []
11:53:12 <lambdabot> foldr (\ b c -> foldr (:) c b) []
11:53:25 <aristid> lambdabot: that was not very ambitious
11:53:41 <monochrom> if you don't like the existing (++) you can define your own too.
11:54:05 <carpi> what if there were nested lists within nested lists?
11:54:08 <carpi> would it still work?
11:54:17 <aristid> carpi: concat . concat
11:55:13 <monochrom> if you mean arbitrary levels of nesting, write down the type of such as beast. (hint: impossible)
11:55:25 <monochrom> s/ as / a /
11:55:26 <acowley> Eq and Show constraints on Num really chafe some times
11:56:15 <monochrom> don't worry about something that doesn't have a type
11:56:18 <shachaf> flatten :: Mu [] -> [a]; flatten _ = [] -- Flatten a (potentially infinitely-) nested list.
11:56:48 <monochrom> yeah but without using Mu or any other type. just [].
11:56:52 <carpi> monochrom: does this count ? "data NestedList a = Elem a | List [NestedList a]
11:57:09 <carpi> it was in the solutions to one of the 99 problems
11:57:13 <monochrom> that doesn't count because myconcat is for [] only.
11:57:36 <carpi> monochrom: i mean a list with arbitrary levels of nesting?
11:57:52 <shachaf> carpi: The free monad of []. :-)
11:58:06 <acowley> Is there a preferred Ring class?
11:58:10 <monochrom> well, your own words, "a list", that's [] exclusively
11:58:33 <monochrom> if you want to do "data NestedList a = Elem a | List [NestedList a]", sure, but don't call it a list. list means [].
11:59:00 <shachaf> acowley: Maybe the one in "algebra"?
11:59:00 <monochrom> but if you want to do that, you're changing the question.
11:59:20 <shachaf> NestedList is more often called a "tree".
11:59:29 <carpi> i don't want to do that.. i was simply curious )
11:59:37 <monochrom> or perhaps you aren't changing the question because you never had a clear question.
11:59:51 <acowley> edwardk's commenting discipline is always a joy to rediscover
12:00:15 <geheimdienst> acowley: is that pure sarcasm?
12:00:21 <monochrom> if you're just saying broadly "I'm writing a program", sure, you can keep it a moving target so I'm forever frustrated.
12:00:31 <acowley> geheimdienst: 110%
12:00:48 <geheimdienst> :D
12:01:09 <shachaf> http://hackage.haskell.org/packages/archive/trifecta/0.49.1/doc/html/Text-Trifecta-Parser-It.html
12:01:29 <shachaf> I like the "It is a cofree comonad" comment.
12:01:45 <acowley> hahaha
12:01:49 <acowley> all is clear!
12:02:59 * geheimdienst lols. the whole thing reads like that daft punk song. "need it want it run it fill it" ...
12:03:08 <acowley> I tend to think of the mysteries he leaves for us on hackage as "good for the spirit" as you have to learn a lot to use it, but I may just roll my own here.
12:03:44 <shachaf> geheimdienst: I believe that was the goal (see the comment at the top).
12:03:55 * hackagebot random 1.0.1.1 - random number library  http://hackage.haskell.org/package/random-1.0.1.1 (RyanNewton)
12:04:02 <acowley> Found this gem
12:04:03 <acowley> class Distinguished r => Complicated r where
12:05:00 <hpaste> keep_learning pasted “Threading” at http://hpaste.org/54939
12:05:08 * geheimdienst has a lot of difficulty containing his laughter (being in the library)
12:05:26 <keep_learning> hello all
12:05:43 <keep_learning> i am learning threading and tried a code from real world haskell
12:06:24 <keep_learning> i feel every time it should terminate by itself ( normal execution ) but some times i need to kill ( ctrl-c )
12:06:38 <keep_learning> could some one please explain me why ?
12:06:42 <keep_learning> http://hpaste.org/54939
12:06:45 <acowley> keep_learning: is it really not terminating?
12:06:53 <acowley> it's not just the GHCi prompt getting out of sync?
12:07:41 <shachaf> You're probably best off not testing threading in ghci.
12:07:44 <keep_learning> acowley, i am not getting out of ghci prompt
12:08:03 <monochrom> testing threading in ghci is fine.
12:09:02 <needstuff> Hi.I need Haskell 2010 complete reference , is the a standard available.Thanks.:)
12:09:05 <monochrom> yeah just interleaving ghci prompt and program output. press return to see.
12:09:11 <Lemmih> keep_learning: It works for me.
12:09:23 <acowley> keep_learning: I'm not sure what you mean by that, but with your program I just have to hit return to get the prompt back cleanly
12:09:39 <keep_learning> Lemmih, sometimes it works for me. sometime not
12:09:58 <astory> is there a way to tell ghc to be more generous with stack space?  I don't want to have to specify it with -RTS all the time
12:10:02 <Lemmih> keep_learning: I keep running it, nothing bad happens.
12:10:13 <shachaf> astory: You can speciy default RTS options.
12:10:13 <acowley> @google Haskell 2010
12:10:14 <alistra> @pl \x y -> off y x
12:10:14 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
12:10:15 <lambdabot> flip off
12:10:28 <shachaf> astory: Are you sure you want to be using that much stack space, though?
12:10:31 <keep_learning> acowley, yes , hitting return also works.
12:10:33 <monochrom> add "threadDelay 1000000" at the end.
12:10:41 <shachaf> Or "getLine"
12:10:49 <astory> I'm reading a large file with a few hundred kilobytes of nucleotides, I don't really know why it's taking over 8 megs though
12:10:55 <needstuff> Thanks.:)
12:10:57 <keep_learning> acowley, but what i want to say , sometimes its return to ghci prompt without hitting return.
12:11:03 <shachaf> astory: Probably a laziness issue.
12:11:11 <astory> this is a one-off script, so I don't really care about performance, I just want my data out
12:11:15 <acowley> keep_learning: so the program is working correctly, it's just a race of when things print out
12:11:35 <shachaf> astory: If it's a one-off script, you can just specify it with +RTS. :-)
12:11:42 <keep_learning> acowley, yes , just saw monochrom's response
12:11:49 <acowley> keep_learning: in other words, this is not a problem, but demonstrates a potential danger of doing IO to one destination from multiple sourcing threads
12:11:52 <monochrom> clearly, "putStrLn $ "recived  " ++ show v" and the ghci prompt are being concurrent.
12:11:52 <astory> scshunt: fair enough
12:12:09 <shachaf> astory: Can you @paste your code, possibly?
12:12:39 <shachaf> astory: At any rate, pass something like --with-rtsopts="..." to GHC when compiling.
12:12:55 <shachaf> You can also use the environment variable GHCRTS.
12:14:40 <astory> shachaf: thanks.  I'll paste the code in a moment
12:16:13 <hpaste> astory pasted “Too Much Stack” at http://hpaste.org/54940
12:16:27 <astory> shachaf: there you are
12:16:37 <astory> (it works now, with the increased stack)
12:16:38 <acowley> is there a way to show :info for a class without listing all its instances in ghci?
12:17:04 <scshunt> astory: thanks
12:17:35 <shachaf> astory: If you can make it work with foldl' instead of foldr it might well solve your problem. :-)
12:17:48 <astory> I'll try that
12:17:49 <shachaf> You might need a bit more strictness, actually; not sure.
12:18:11 <ciao> ciaooooooooo
12:18:15 <ciao> !list
12:18:25 <ciao> list!
12:19:04 <monochrom> what is !list supposed to mean?
12:19:10 <acowley> the dual of list!
12:19:17 <monochrom> haha
12:19:34 <dmwit> roconnor: I did, and additionally I found it strange that all the functions were not already uncurried.
12:19:45 <geheimdienst> ciao, you are probably looking for the command @list. lambdabot is available in private windows as well
12:19:53 <dmwit> roconnor: There seems to be no rhyme or reason between which functions accept RGB's and which expect three arguments.
12:19:59 <astory> shachaf: nope, that doesn't do it
12:20:01 <monochrom> no, pretty sure looking for files to download
12:20:52 <shachaf> astory: If you had a sample data file I would try it out and see. :-)
12:22:39 <hpaste> astory pasted “Too Much Stack - data” at http://hpaste.org/54941
12:22:40 <astory> shachaf: it's a little large, but here you go (it'll paste eventually)
12:22:43 <carpi> is there any way to stop a list comprehension midway?
12:22:51 <dmwit> filter, takeWhile
12:22:53 <rwbarton> unplug your computer
12:23:01 <carpi> lol
12:23:19 <monochrom> in what sense?
12:23:58 <shachaf> astory: What "window" do you usu?
12:24:17 <carpi> like for example .. in [x | x <- ls, isLower x] returns abcdefm if ls = "abcdefABCDm"
12:24:32 <carpi> i was wondering if it was possible to stop it at "abcdef"
12:24:38 <shachaf> carpi: takeWhile isLower ls
12:25:12 <monochrom> yeah, you have to do that outside
12:25:32 <carpi> shachaf: yes.. that is one solution but i was wondering if list comprehension had the ability to be stopped midway.. short of unpluggin the computer like rwbarton said. P
12:25:58 <monochrom> list comprehension can't do it
12:26:57 <shachaf> carpi: List comprehensions aren't that great, for the most part.
12:27:28 <carpi> because they're slow? or are there other reasons?
12:27:46 <shachaf> astory: I can't make it fail.
12:27:59 <monochrom> because you can't stop it in the middle. and various other things.
12:28:49 <acowley> Although rwbarton's suggestion is not to be dismissed. I've certainly used the line, "And that's the end of the demo!" at key junctures for just this purpose.
12:29:29 <maurer> Anyone know how to get dph installed? I wanted to try it out, but it complains about lacking a number of components when I try to build.
12:29:36 <maurer> cabal install dph doesn't seem to do anything
12:29:37 <monochrom> takeWhile and unplugging are both doing it outside
12:30:21 <acowley> maurer: I think it's only enabled by default on quite recent GHCs
12:31:20 <maurer> The Glorious Glasgow Haskell Compilation System, version 7.2.1
12:31:23 <maurer> New enough?
12:32:57 <acowley> I guess you've tried to cabal install dph-examples?
12:33:04 <shachaf> astory: By the way, are you shadowing the name "list" on purpose there?
12:34:56 <maurer> acowley: Trying that now
12:38:56 <astory> shachaf: sorry about that, connection died :(
12:39:24 <carpi> why cant i do "data Bite = 0 | 1"?
12:39:44 <astory> and no, I wasn't shadowing it on purpose.  I'm a pretty new haskeller, and make lots of mistakes...
12:39:45 <applicative> 0 and 1 arent capital letters?
12:39:52 <tromp> constuctors must start wth capital
12:40:04 <applicative> data Bite = O
12:40:13 <bd_> Because 0 and 1 are already defined as having type (a :: Num => a)
12:40:13 <applicative> data Bite = O | I
12:40:14 <carpi> how do you capitalize numbers?
12:40:25 <astory> shachaf: I was using windows of 100 to 1000
12:40:44 <carpi> so i can't use 0 and 1 since they are already a part of another type?
12:40:47 * applicative insists they are already capitalized, it's just that they're not letters
12:41:12 <monochrom> PL/I would let you do it.
12:41:30 <hpaste> “[]” annotated “Too Much Stack” with “Too Much Stack (annotation -- some stylistic changes since I can't reproduce the actual problem)” at http://hpaste.org/54940#a54942
12:41:31 <applicative> carpi, no it's totally syntactic, constructors have initial capitals or else are operators beginning with ':' , some other details I think
12:41:32 <DevHC^> lol is there a built-in, named function for (:[])
12:41:33 <shachaf> astory: Ah.
12:41:33 <DevHC^> ?
12:41:51 <shachaf> astory: Still can't get it to fail. :-(
12:41:53 <tromp> return
12:41:57 <DevHC^> lol
12:41:58 <astory> hrmf :(
12:42:03 <astory> well, it definitely fails on me
12:42:07 <tromp> > return 'a'
12:42:08 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
12:42:08 <lambdabot>    arising from a use of...
12:42:09 <shachaf> astory: See my annotation, though. Not that it matters much.
12:42:20 <tromp> > return 'a' :: String
12:42:22 <lambdabot>   "a"
12:42:36 <astory> cool, I get my style guides mixed up since I'm programming in python ocaml and haskell all recently
12:43:01 <bd_> carpi: fwiw, you can convert 0 and 1 to Bite if you define an instance Num Bite
12:43:18 <bd_> and then define an appropriate fromInteger
12:43:33 <shachaf> astory: Some of those changes are a matter of taste, of course. :-)
12:43:36 <carpi> you mean something like "data Bite a = Zero a | One a"?
12:43:51 <xplat> augur[iphone]: 'john ate pizza' is now parsed with 2 johns, 2 eats, 2 pizzas, 2 agros, a v and a T?
12:43:52 <bd_> carpi: No. I mean we do something like instance Num Bite where fromInteger 0 = Zero; fromInteger 1 = One
12:44:12 <carpi> ah okay.. you mean making Bite an instance of Num?
12:44:20 <monochrom> just data Bite = Zero | One
12:44:21 <bd_> yes
12:44:27 <bd_> :t 1
12:44:28 <lambdabot> forall t. (Num t) => t
12:45:42 <tromp> :t 0
12:45:44 <lambdabot> forall t. (Num t) => t
12:47:33 <maurer> Anyone know what to do about <command line>: cannot satisfy -package-id ghc-7.2.1-1300f1e6c6896eb152f7d5475af1179a:
12:47:46 <maurer> Do I really have to reinstall ghc?
12:49:03 <astory> uh, so now ghc isn't making a binary for me
12:49:37 <roconnor> dmwit: thanks for the feedback.
12:50:05 <dmwit> =)
12:50:35 <roconnor> dmwit: I was/am torn as to whether sRGB24, sRGBBounded, and sRGB should take one RGB parameter or three parameters or if I should provide both curried and uncurried versions and what to name them if I do provide both.
12:51:40 <dmwit> Well, foo (RGB r g b) is not so much more annoying that foo r g b.
12:52:05 <Phyx-> maurer: what's the id when you do ghc-pkg describe ghc
12:52:12 <roconnor> ya, but sRGB (RGB r g b) seems like an awful lot of r g and b's to type
12:52:14 <dmwit> And the curried version doesn't compose as nicely with the functions that return RGB's.
12:52:24 <Shammah> when using map on a String, it treats each element as a Char, eg: "hello", the first element will be seen as 'a'
12:52:35 <Phyx-> maurer: you should be able to swap the new id for the old one in the package.conf file... but you're working with fire there
12:52:37 <Shammah> Is it however possible, to see it as a String, "a", instead of a Char 'a'?
12:52:52 <Shammah> "hello" -> 'h'
12:52:53 <Shammah> btw
12:52:56 <Shammah> my mistake
12:52:59 <relation> can somebody recommend me good generic graph library? with generic vertices and edges
12:53:05 <relation> thanks
12:53:06 <roconnor> dmwit: oh, and also a bit of an explaination about why HSV is the way it is...
12:54:05 <roconnor> dmwit: HSV defines how to convert those coordinates to an RGB triple; however there is no specification as to what that RGB triple means: does it mean sRGB, does it mean linear RGB does it mean HDTV rgb does it mean SDTV rgb, etc...
12:54:07 <Jafet> > map (:[]) "hello"
12:54:08 <lambdabot>   ["h","e","l","l","o"]
12:54:39 <roconnor> dmwit: so the solution is that the HSV functions only deal with RGB triples, and you need a second step to choose what colour basis you are goint to use to get a colour
12:54:39 <acowley> relation: fgl
12:54:40 <Shammah> Hmmm Jafet, indeed, you're giving me an idea :D
12:54:48 <dmwit> roconnor: Sure. I read a bit in your documentation about transfer functions, etc.
12:55:02 <roconnor> dmwit: in your case you've chossen sRGB, which is likely a reasonable choice.
12:55:08 <roconnor> dmwit: oh good :D
12:55:12 <dmwit> roconnor: I think the only thing I couldn't work out from the documentation was how to construct an RGBSpace.
12:55:35 <maurer> Phyx-: I'm trying dumping my .ghc first
12:55:36 <Shammah> Jafet, thanks, that works :D
12:55:46 <relation> acowley: thanks, looks great, i just wanted to know opinion of someone with experiences
12:55:48 <maurer> Phyx-: It's possible that some stuff I was messing around with was a dependency for the ghc package
12:55:50 <dmwit> roconnor: Well, I chose sRGB because it seems (?) to be the space that Cairo uses, sort of.
12:56:22 <roconnor> dmwit: yep; it is basically the space you should use if you have no idea what an RGB space is :D
12:56:59 <dmwit> Ah, no, it was Gamuts that I couldn't understand how to create.
12:57:04 <roconnor> in .SRGB there is a sRGBSpace :: (Ord a, Floating a) => RGBSpace a which gives you the RGBSpace that sRGB will use.
12:57:10 <dmwit> Once you've got your hands on one of those, making an RGBSpace seems pretty easy.
12:57:19 <Phyx-> maurer: i've had this before when building ghc from source and modifying and recompile. sometimes the dependencies would have the old ids still
12:57:36 <dmwit> Yeah, once rwbarton pointed me at the SRGB module everything seemed much simpler. =)
12:58:12 <Jafet> astory: for minimal space, use ByteString or Text
12:58:49 <roconnor> the SRGB gamut is exported form .SRGB.Liner.sRGBGamut :: RGBGamut
12:59:04 <roconnor> sRGBGamut = RGBGamut (RGB (mkChromaticity 0.64 0.33)
12:59:05 <roconnor>                          (mkChromaticity 0.30 0.60)
12:59:07 <roconnor>                          (mkChromaticity 0.15 0.06))
12:59:08 <roconnor>                     d65
12:59:13 <roconnor> but anyhow
12:59:25 <roconnor> normal users shoudln't be playing aroung with RGBspaces and Gamuts
12:59:28 <Jafet> (Wavelength -> Irradiance)
13:00:05 <roconnor> Jafet: well, the colour module doesn't get into physics since it is the about the human perception of colour.
13:00:05 <dmwit> Before that it was like this infinite regress... convert hsv to rgb, then call rgbUsingSpace, which needs an RGBSpace, so call mkRGBSpace, which needs a gamut and a transfer function, so use (say) linearTransferFunction and call mkRGBGamut, which needs some Chromaticity's, so read about Chromaticity... and then I gave up. =P
13:00:14 <roconnor> :D
13:00:26 <roconnor> I should add HSV and HSL to my little tutorial
13:00:33 <roconnor> that is something users should be using.
13:01:02 <roconnor> maybe later this week
13:01:17 <malchev> when I do (maxBound :: Int) + 1, I get an integer overflow.  This makes sense, but why does Haskell allow me to do that, and not something like ((maxBound :: Int) :: Integer) + 1?  It seems safer to be able to do the latter and not be able to do the former.
13:01:23 <dmwit> I feel a little better knowing I wasn't supposed to understand all the gamut stuff. =P
13:01:47 <Jafet> malchev: :: is a type signature, not a type conversion.
13:02:00 * roconnor 's goal for Data.Colour is for it to be easier to use than Data.Time, ... but not by much. =D
13:02:01 <Jafet> :t fromIntegral
13:02:03 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:02:04 <hpc> malchev: it doesn't do anything for you but regular type inference
13:02:08 <dmwit> hahaha
13:02:20 <Jafet> roconnor: set a more lofty goal!
13:02:25 <dmwit> Why is it that all the simple stuff is hard? text, time, color...
13:02:29 <hpc> malchev: (+) :: Num a => a -> a -> a -- addition takes two things of the same type and returns a thing of that type
13:02:32 <Cale> Hello
13:02:33 <dmwit> stupid humans
13:02:39 <hpc> malchev: so when you add (something :: Int) and 1
13:02:40 <shapr> hi Cale !
13:02:50 <luite> roconnor: does it also support tone mapping between gamuts?
13:02:51 <hpc> the result is an Int (as is that use of "1")
13:03:21 <roconnor> luite: nope, but that would more or less be in scope; maybe in a more advanced package.
13:03:27 <malchev> Jafet, hpc: thanks, the fromIntegral thing makes it make sense :)
13:03:57 <roconnor> luite: unless by tone mapping you mean cliping; which it does support.
13:03:58 * hackagebot utility-ht 0.0.7.1 - Various small helper functions for Lists, Maybes, Tuples, Functions  http://hackage.haskell.org/package/utility-ht-0.0.7.1 (HenningThielemann)
13:04:15 <DukeDave> Do we know where GHC decides to look for external libs? Specifically: On Ubuntu?
13:04:34 <DukeDave> I.e. When compiling "c-sources"
13:04:44 <dmwit> I assume it just uses pkg-config.
13:04:48 <dmwit> That would be the same thing.
13:04:51 <dmwit> s/same/sane/
13:05:07 <Cale> shapr: Hi!
13:05:12 <salisbury> Does anyone know  the most haskell-idiomatic version of fseek
13:05:23 <salisbury> as seen in C, that is
13:05:33 <dmwit> salisbury: hSeek
13:06:21 <shapr> Cale: How's code?
13:06:24 <salisbury> oh, nice.. how'd I miss that one?
13:06:30 <luite> roconnor: yeah the colorimetric mappings are the easiest, but perceptual mapping (compression) probably isn't so easy, I'm not sure what exactly existing CMS's do
13:07:21 <dmwit> So, if you were designing an HDMI adapter for color-blind people, how would you do it? Cut a chunk out of the H wheel and compress everything into the remaining bits of the wheel? Or something else?
13:07:22 <Cale> shapr: Pretty good, been working on optimisers for the typed heterogeneous graph in our FRP system. :)
13:07:52 <dmwit> (This question is just idle speculation -- not related to what I'm actually using the package for. =)
13:07:59 <roconnor> dmwit: what do you mean an HDMI adaptor for colour-blind people?
13:08:20 <roconnor> dmwit: if you just do nothing colour blind people will see colours as well as they can manage.
13:08:28 <roconnor> dmwit: I don't know what else can be done.
13:08:29 <dmwit> Like, a thing that let (say) a red-green color-blind person see the difference between red and green images.
13:08:41 <shapr> Cale: Sounds interesting, anything like the arrow containers in the original FRP?
13:08:47 <Cale> shapr: The graph thing is simultaneously some of the most typesafe and least typesafe code I've worked on :)  Lots of GADTs and a fair amount of unsafeCoerce.
13:08:53 <dmwit> Say, for an FPS with red and green teams. =)
13:08:54 <roconnor> dmwit: or do you want to save on cables since the colour blind person can't see all the data anyways?
13:09:33 <dmwit> No, I want to have an adapter that warps colors somehow, so the picture looks wrong, but the usually-indistinguishable colors are distinguishable.
13:09:46 <NemesisD> ddarius: ping
13:10:34 <Cale> shapr: Basically we're taking the structure of the constructed Arrow and picking it all apart into an explicit graph representation so that we can do things to it easily. We actually have our own hierarchy of Arrow classes and preprocessor as well, because the one in GHC overuses 'arr' (but is essentially forced to because Arrow is missing a bunch of stuff that it should have)
13:10:34 <roconnor> dmwit: so "colour", techincally chromoticity, is a 2-d affine space (say  vector space if you don't know what an affine space is).
13:10:40 <NemesisD> ddarius: i was talking with you the other night about using the "pool" package to pool database resources. i was wondering why you didn't use resource-pool which offers an api that blocks until a resource is freed
13:10:43 <dmwit> (I do.)
13:10:58 <roconnor> dmwit: typical colour blind people can only see a 1-d affince space of chromaticity
13:11:11 <shapr> Cale: ooh, what do your arrow typeclasses look like?
13:11:21 <roconnor> dmwit: it is typically a slice from purple though yellow.
13:12:01 <roconnor> dmwit: so our chromaticity is projected onto this purple-yellow line, and that is the colour they perceive.
13:12:22 <dmwit> Alright, I'm with you so far.
13:12:39 <dmwit> You're about to tell me that any such projection has a largish null space, aren't you?
13:12:42 <dmwit> =/
13:13:16 <roconnor> dmwit: so yes, you could preprocess and rotate / shear this our chromaticity space so that you effectively choose how our entire chromaticity space is projected onto their 1-d space.
13:13:17 <luite> you could make it adaptive, find some projection that maximizes spread, and vary that over time... but that's going to be costly at hdmi data rates
13:13:51 <Cale> shapr: Well, we have explicit representation of const :: c -> (b ~> c), as well as forget :: b ~> (), and we have more explicit operations on pairs, there's an ArrowPair class with  swap :: (b,c) ~> (c,b),  assocL :: (a,(b,c)) ~> ((a,b),c), assocR :: ((a,b),c) ~> (a,(b,c))
13:13:57 <dmwit> Well... any *linear* projection, I guess.
13:13:57 <roconnor> dmwit: but some choice has to be made, and whatever choice you make will be very lossy
13:14:54 <Cale> shapr: We also insist that  (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k), which excludes most monads from being Arrows, but we think that's a good thing :)
13:14:56 <roconnor> dmwit: linear projections would be easiest, though I suppose you could do non-linear projections and actually perform the projection yourself during the preprocessing (rather than wait for their eyes to do their linear projection).
13:15:42 <dmwit> It seems a bit weird to me that we have r, g, and b receptors (at least according to wikipedia) but that somehow chromaticity is a 2d and not 3d space.
13:15:58 <luite> luminance is the other axis
13:16:00 <dmwit> Not that it has bearing on the current discussion, I guess.
13:16:07 <luite> the total color space is 3D
13:16:11 <dmwit> aha
13:16:24 <FUZxxl> Is recursive backtracking the best approach for this or is there a more systematic one? http://goo.gl/cVJnB
13:16:27 <dmwit> Yeah, I guess it makes sense to preserve luminance under any such transformation.
13:16:29 <opqdonut> and some people have r' !
13:16:41 <FUZxxl> (I solved it using recursive backtracking but it was quite slow)
13:16:48 <Cale> shapr: Basically, the idea is that the proc/do notation constructs a graph of operations, and the order of those operations are only allowed to matter up to data dependencies, so you can only have local state
13:16:52 <Jafet> You could project signals directly into the colour-blind people's optical nerves, and make use of colours that don't exist
13:17:19 <dmwit> This is clearly the best possible solution.
13:17:22 <dmwit> Then they can't even look away!
13:17:30 <Cale> shapr: Which is much more sensible if you think of these things like wiring diagrams -- it sucks for the layout of a circuit on a PCB to affect its behaviour ;)
13:17:42 <shapr> Cale: Is that like the commutative monads spj once mentioned?
13:18:16 <Cale> shapr: Yeah, it's related, in that commutative monads will produce valid arrows in our sense.
13:18:25 <shapr> Nifty
13:18:48 <shapr> Cale: Are there any writings about the new arrow typeclass, and why the changes were made?
13:18:51 <copumpkin> Cale: have you considered proposing an amendment to GHC's arrow notation/classes to address the issues you had?
13:19:24 <Cale> Not yet, we hope to write some papers / get some things into GHC / release some fraction of our libraries once our game is out :)
13:20:57 <Cale> But yeah, Arrow as it stands in GHC is much less useful to DSL authors than it could be.
13:21:42 <Cale> The whole point of Arrow relative to Monad, say, is that when you write f >>> g, the f and g are both values of some type that you have some control over, and so they can be examined in order to do some optimisation.
13:22:02 <Cale> Whereas with x >>= f, the f is always a black box.
13:22:35 <Cale> But there's a big case where you can't usefully analyse f >>> g, and that's when f or g is an 'arr'
13:23:00 <Cale> and the proc/do translator sticks 'arr' in between almost every line of your arrow code, making it completely inscrutable.
13:23:15 <Cale> (by necessity)
13:27:25 <shapr> So, making arrows an explicit graph with explicit commutativity makes sense.
13:29:01 <roconnor> @type arr
13:29:03 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
13:29:32 <shapr> @arr
13:29:33 <lambdabot> I want me grog!
13:30:15 <roconnor> @undo proc { y <- f <- y }
13:30:16 <lambdabot>  Parse error at "<-" (column 10)
13:30:26 <acowley> I'm uncomfortable with this badmouthing of the glorious function
13:30:27 <roconnor> @undo proc { y <- f -< z }
13:30:28 <lambdabot>  Parse error at "<-" (column 10)
13:31:11 <Axman6> :t \x y z -> proc {x <- y -< z}
13:31:13 <lambdabot> parse error on input `<-'
13:31:48 <saml> how can I get current time?
13:31:59 <roconnor> @hoolge getCurrentTime
13:32:00 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
13:32:00 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
13:33:11 <Axman6> also exported in Data.Time (to save you some typing)
13:35:56 <saml> > sum [1..100000]
13:35:57 <lambdabot>   5000050000
13:36:02 <saml> that's wrong, right?
13:36:11 <Axman6> no
13:36:20 <Axman6> > sum [1..10]
13:36:21 <lambdabot>   55
13:36:23 <Axman6> > sum [1..100]
13:36:24 <lambdabot>   5050
13:36:25 <Axman6> > sum [1..1000]
13:36:26 <lambdabot>   500500
13:36:27 <Axman6> > sum [1..10000]
13:36:28 <lambdabot>   50005000
13:36:28 <saml> > 100000*(100000+1)/2
13:36:30 <lambdabot>   5.00005e9
13:36:33 <dmwit> > (100000 * 100000+1) `div` 2
13:36:34 <lambdabot>   5000000000
13:36:39 <dmwit> derp
13:36:43 <dmwit> > (100000 * (100000+1)) `div` 2
13:36:44 <lambdabot>   5000050000
13:38:59 <saml> i don't get it
13:39:17 <Axman6> what don't you get?
13:39:24 <vodik> math is cool
13:39:41 <saml> > sum [0..100000] == sum [1..99999]
13:39:42 <lambdabot>   False
13:39:45 <roconnor> saml: a young Gauss was told by his teacher to add up all the numbers from 1 to 1000 as punishment ... he go the answer in a few minutes.
13:39:53 <alistra> roconnor: old
13:40:00 <alistra> :3
13:40:15 <saml> in scala, it's all different
13:40:24 <saml> maybe it uses int and overflows
13:40:31 <Axman6> almost certainly
13:40:40 <Axman6> > sum [1..10000] :: Int
13:40:41 <lambdabot>   50005000
13:40:46 <Axman6> > sum [1..100000] :: Int
13:40:47 <lambdabot>   5000050000
13:40:49 <alistra> > on (==) length [0..100000] [1..99999]
13:40:50 <roconnor> > sum [1..10000] :: Int32
13:40:51 <lambdabot>   False
13:40:51 <lambdabot>   can't find file: L.hs
13:40:54 <Axman6> > sum [1..1000000] :: Int
13:40:55 <lambdabot>   *Exception: stack overflow
13:41:03 <clsmith_> so... are supercombinators a form of deforestation (where the tree structure is the lambda itself)?
13:41:06 <Axman6> > foldl' (+) 0 [1..1000000] :: Int
13:41:07 <roconnor> Axman6: Gauss wouldn't stack overflow
13:41:07 <lambdabot>   500000500000
13:41:13 <saml> what do you think about scala?
13:41:14 <alistra> > on (==) length [1..100000] [0..99999]
13:41:15 <lambdabot>   True
13:42:49 <gwern> roconnor: I belive the story actually goes it was 1 to 100 and it was for the whole class
13:43:06 <roconnor> gwern: ah thanks
13:43:21 <roconnor> there seem to be some varients of this story
13:44:25 <saml> scala is bad, right?
13:44:58 <roconnor> saml: how bad could something with types be?
13:45:06 <mirari_> saml: As a Scala programmer, I would say no.
13:45:12 * Axman6 thought scala was a language
13:45:36 <donri> roconnor: php has types right? :)
13:45:36 <mirari_> saml: or, bad compared to what?
13:45:50 <Axman6> donri: sure, string
13:45:51 <saml> yammer went back to java because scala is bad
13:45:57 <roconnor> er
13:46:03 <roconnor> how about typechecking?
13:46:19 <donri> i bet you can check the types of values ;)
13:46:24 * roconnor has the opinion that any language without typechecking has no types.
13:46:47 <donri> yea i knew what you meant, i'm just being an arse
13:46:49 <roconnor> :)
13:47:07 <roconnor> if only scala didn't have mutable variables; but you can just avoid mutating things I suppose.
13:47:08 <saml> everything has types
13:47:10 <saml> Object
13:47:30 <roconnor> types with an s!  We aren't allowed only one type.
13:47:53 <mirari_> Scala is a pragmatic language. You can pretty much do what you want.
13:48:37 <Axman6> mirari_: that isn;t a good thing imo
13:48:50 <donri> depends on your goal with using the language
13:48:59 <mirari_> Axman6: I think it depends on what kind of softaware you're working on.
13:49:24 <roconnor> If your goal is to write software with a particular behavour in mind, then doing being able to do pretty much whatever you want is no good.
13:49:24 <Axman6> I can do quick and dirty in Haskell, and having strong types (and to a lesser extent purity) seems to make that easier imo
13:49:33 <saml> Object and null
13:49:35 <saml> two types
13:49:50 <Axman6> saml: they're just values of the same type imo
13:49:56 <roconnor> if your goal is to make a self improving super artifical intellegence, maybe being able to do pretty much whatever you want is okay.
13:50:09 <Axman6> if they were different types, you couldn't use them interchangably
13:50:47 <mirari_> roconnor: I don't really see the connection?
13:51:13 <DevHC> mirari_: both of ur sentences (Scala...) may be true; they don't have much cohesion, though, lol
13:51:25 <roconnor> mirari_: I'm not certain the self-improving super artifical intellegence wants to be constrained; but maybe it does.
13:51:49 <wmoss> I have a project where I'm pretty sure a dependency is forking a thread and then calling head on an empty list (of course this happens at random times, so I'm not 100% sure), but I can't seem to catch the exception.
13:51:55 <donri> i expect that something like haskell would be better for self-improving AI
13:51:59 <wmoss> Is there a way to ask cabal to download all the source for the depencies
13:52:03 <donri> certain assumptions it can make about its code etc
13:52:04 <wmoss> so I can look through it?
13:53:44 <Nafai> byorgey: I think I remember you saying you use cabal to manage all of your Haskell packages on Arch.  Did you also install ghc and the haskell-platform from the tarballs downloaded from haskell.org?
13:54:16 <donri> roconnor: an AI smart enough to program itself would probably not find the constraints of haskell that limiting
13:54:27 <roconnor> heh
13:54:30 <roconnor> that's true
13:54:34 <roconnor> stupid haskell
13:55:05 <donri> but consider stuff like quickcheck etc. the types would probably help such an AI.
13:55:13 <mirari_> It would probably start by bootstrapping its own virtual machine and language, and then take it from there :)
13:55:25 <roconnor> mirari_: I guess that is true
13:56:28 <roconnor> I guess I was thinking about the genetic algorithms used to derive untypable functions to compute subtraction on church numbers.
13:56:33 <donri> also stuff like @pl. you can *reason* about haskell code *programmatically* in ways that are much more difficult in other languages.
13:56:43 <roconnor> that is the only case I can think of where using an untype language may be useful.
13:58:21 <donri> well if you need it for any reason you can do anything in haskell you can in other languages. Data.Dynamic, unsafePerformIO, etc etc.
14:00:40 <gwern> roconnor: one of the last AI papers I read implemented its universal agents using BF - because every string is a valid program, which makes it easy to search starting with the shortest
14:01:27 <roconnor> gwern: what does "]" do?
14:01:38 <gwern> roconnor: heck I dunno BF
14:01:38 * roconnor isn't a BF expert
14:01:47 <roconnor> join #brainfuck
14:01:54 <gwern> I assume they all had timeouts set
14:03:00 <dmwit> I don't think every string is a valid program in brainfuck.
14:03:06 <dmwit> But every string with matched brackets is.
14:03:12 <roconnor> gwern: from my reading "]" isn't a legal BF program
14:03:46 <dmwit> Program texts are easy to "correct" by putting a string of "[" at the beginning or a string of "]" at the end.
14:03:50 <roconnor> maybe they should use the game of life instead.
14:04:25 <dmwit> Maybe they should use a binary tree (of () values).
14:04:37 <roconnor> good ol X combinator
14:07:25 <Cale> shapr: (Sorry I went away for a bit there), yeah, if you add a few extra things, you can make it possible to analyse the full structure of the computation, and limit the usage of arr to pattern matching and construction of values to the right of -< in the proc syntax.
14:09:22 <Cale> (matching on pairs or single variables all boils away into other things)
14:10:52 <Cale> X combinator goot programming language.
14:11:16 <Cale> Much better brainfuck than brainfuck :)
14:11:30 <monochrom> what is the X combinator?
14:12:02 <Cale> X = \x. ((xS)K)
14:12:06 <aristid> Cale: better than unlambda?
14:12:24 <Cale> unlambda is basically SK calculus, you can be simpler
14:12:37 <Cale> X (X (X X)) = K
14:12:43 <Cale> X (X (X (X X))) = S
14:12:50 <monochrom> yikes!
14:12:53 <Axman6> >_<
14:13:39 <monochrom> the mother of all combinators
14:13:56 <Axman6> what about iota?
14:14:06 <Cale> Yeah, iota is basically the X combinator :P
14:14:14 <Axman6> probably equivalent? (or even another name for the same thing?)
14:14:18 <Cale> If you're talking about http://en.wikipedia.org/wiki/Iota_and_Jot
14:14:20 <Axman6> heh, ok
14:23:38 <Renze> Good evening!
14:24:22 <shachaf> Renze: Good morning.
14:26:58 <mzero> good afternoon!
14:27:08 <Renze> I'm trying to profile my function, with: 'ghc -prof -auto-all -o main --make main.hs' and then 'main +RTS -K100M -p -hc' or 'main.exe +RTS -K100M -p -hc' (windows), hoping to get some nice data, but it doesn't! It doesn't do anything, as main.prof says 'total time = 0.00secs (0 ticks @ 20ms)', while it should take +-4seconds and loads of ticks. What am I doing wrong?
14:27:08 <mzero> there- Haskell covers the world
14:27:13 <danlei> just to be sure: there is no functionality to replace occurences of an element in a list with another? something like a -> a -> [a] -> [a]?
14:27:25 <copumpkin> mzero: I got your email by the way, haven't had time to digest it yet :)
14:27:26 <danlei> (in the standard library that is)
14:27:40 <Nafai> mzero: I keep meaning to tell you I enjoyed your Google Tech Talk.
14:28:00 <shachaf> danlei: map (\x -> if x == y then z else x), maybe?
14:28:06 <mzero> copumpkin: cool - I realize it was a lot
14:28:10 <shachaf> No standard function to do it as far as I know.
14:28:11 <mzero> Nafai: thank you!
14:28:15 <fcr> Question: which regex library can I use with support to backreferences?
14:28:16 <copumpkin> kfish: I think I may have a possible use for your zoom-cache and scope but I had a question about it
14:28:46 <danlei> shachaf: ok, thanks. just wanted to be sure that there is not a predefined function
14:28:56 <Renze> danlei: there is, in Network.CGI.Protocol (http://haskell.org/hoogle/?hoogle=a+-%3E+a+-%3E+[a]+-%3E+[a])
14:29:15 <shachaf> @hoogle a -> a -> [a] -> [a]
14:29:16 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
14:29:16 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
14:29:16 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
14:29:21 <shachaf> So there is.
14:29:25 <shachaf> Odd place to put it.
14:29:27 <danlei> Renze: ah, yes
14:30:42 <Renze> Odd place to put it, but not to use it
14:31:45 <danlei> thanks anyways, I actually should have seen that in hoogle, but I guess I somehow skipped it when I saw something about network
14:36:10 <kfish> copumpkin, great, shoot
14:36:23 <Axman6> o/ kfish
14:36:32 <kfish> morning Axman6
14:36:32 <mzero> maybeRead in Network.CGI.Protocol is a nice utility to have, too
14:37:02 <copumpkin> kfish: basically, I want to use something like zoom-cache for 2-dimensional data (market depth) and view cross-sections (mostly at a specific time, but being able to pick a cumulative depth point against time would be awesome, too; would probably require a dedicated disk-based datastructure and lots of thinking) of it
14:37:21 <copumpkin> it doesn't seem quite like what zoom-cache was designed for
14:37:45 <Axman6> a zoom-cache of zoom-caches? =)
14:37:53 <copumpkin> :P
14:37:56 <copumpkin> something like that
14:38:11 <copumpkin> it's really just 1d data at every time
14:38:17 <kfish> copumpkin, all zoom-cache cares about is that something is linear in eg. time
14:38:30 <copumpkin> yeah
14:38:42 <copumpkin> I don't suppose I can use your fancy GUI app though, right?
14:38:47 <kfish> when you say 1d data, do you mean a fixed-length array?
14:39:04 <kfish> yes you will be able to use scope, which is/will be a library
14:39:26 <copumpkin> not really, although I could quantize it and clamp it at the two sides against ridiculous/joke orders (some people might place a limit order for a trillion dollars but that's not particularly interesting)
14:39:27 <kfish> you supply a rendering function which is folded across the visible data
14:39:38 <kfish> i c
14:39:42 <copumpkin> kfish: how do you handle gaps in the GUI?
14:39:54 <kfish> each data point has a timestamp
14:40:06 <copumpkin> yeah, I saw that
14:40:13 <kfish> what do you mean by gaps?
14:40:21 <copumpkin> well, my data source is kind of unreliable ;)
14:40:24 <carpi> is there a framework to do scrapping?
14:40:32 <copumpkin> so I lose my connection that feeds me the data every so often
14:40:42 <copumpkin> I was just wondering how the GUI might represent that
14:40:55 <copumpkin> does it keep a big empty chunk for the missing data or does it compress it to the next available point?
14:40:59 <kfish> copumpkin, ah ok ... well that's a good point, we have a similar thing
14:41:51 <kfish> so you can write constant or variable samplerate data; for variable you supply explicity timestamps, which takes a bit more space but will handle gaps
14:42:09 <kfish> and you can explicitly flush a summary block when the feed drops out
14:43:19 <kfish> i also have a (currently reverted) patch for drawing 1d textures
14:43:25 <kfish> currently working on multichannel support to clean that up a bit
14:43:41 <kfish> which is more for matrix data, where multiple parallel summaries are handled automatically
14:44:22 <kfish> (using type-level nats to choose summary functions yay)
14:48:10 <copumpkin> kfish: ah, I see
14:48:18 <cgroza> I am a little confused about when should I use arrows and when shord I use monads. Can anyone enlighten me?
14:49:05 <ddarius> cgroza: Use whichever when you need them.
14:49:14 <shachaf> cgroza: Use the things you want to use, and if they happen to be monads then use the Monad API, and if they happen to be arrows then use the Arrow API.
14:49:46 <cgroza> But they do the some thing in their own way right?
14:49:52 <shachaf> What?
14:49:54 <cgroza> same***
14:50:00 <shachaf> Who does?
14:50:08 <cgroza> Arrows and monads.
14:50:30 <monochrom> no
14:50:36 <copumpkin> kfish: one other question. The most natural way for me to serialize this data is to write out "summaries" (not necessarily in the sense you use) periodically, then tiny diffs over time that affect the view of the most recent snapshot
14:51:09 <kfish> copumpkin, ok
14:51:30 <copumpkin> kfish: then the viewer would need to show me the latest snapshot from before my selected time and then walk over the diffs since then and let me apply them
14:51:49 <kfish> copumpkin, ok, like video keyframes
14:52:50 <copumpkin> yep
14:52:54 <copumpkin> exactly
14:52:56 <xtea> hello looking for some chelp with getChar
14:53:01 <mzero> cgroza: are you building a new data type that will be an Arrow or an Monad instance?
14:53:30 <xtea> by some reason it expects me to press enter befor it progress
14:53:49 <shachaf> xtea: You can try hSetBuffering stdin NoBuffering
14:54:04 * hackagebot heist 0.7.0.1 - An (x)html templating system  http://hackage.haskell.org/package/heist-0.7.0.1 (DougBeardsley)
14:54:19 <xtea> shachaf: thx
14:54:42 <copumpkin> kfish: so basically, I'd have large timestamped variable-size messages (every 30 seconds maybe) with snapshots and then small timestamped fixed-size messages with diffs between those
14:54:43 <mzero> does the functioning of the type depend on the input to functions as well as the output - that is,   when we work with monads, we create have functions of the type    a -> m b    -- the monadic value is independent of the input to that function     --- but in Arrow, we'd have    a b c    -- abstractly representing taking type b, yielding type c
14:55:03 <copumpkin> not sure if the variable-sized-ness is annoying
14:55:20 <mzero> at least- that is how I determine which I need… which is to say ---- I've never needed Arrow!
14:55:41 <cgroza> mzero: no. but never mind. I found a haskell wiki page.
14:55:56 <cgroza> is (.) part of some class?
14:56:07 <copumpkin> it can be part of Category
14:57:29 <ocharles> Does something that composes without identity form anything? Like a monoid without idenity is a semigroup
14:57:37 <copumpkin> semigroupoid
14:57:40 <copumpkin> @hackage semigroupoids
14:57:41 <lambdabot> http://hackage.haskell.org/package/semigroupoids
14:57:47 <kfish> copumpkin, the sizes etc. are up to you, for the rendering etc. can you make some kind of summary type that is a semigroupoid
14:57:53 <ocharles> ah yea
14:57:59 <kfish> lol
14:58:01 <copumpkin> kfish: wait, a semigroupoid :O
14:58:09 <cgroza> copumpkin: yeah, that's why I was asking. But now if I look closer, I see that Control.Arrow hides the Prelude (.)
14:58:16 <kfish> good timing ocharles :)
14:58:20 <ocharles> :)
14:58:21 <copumpkin> crazy
14:58:41 <copumpkin> (and cool)
14:58:55 <ocharles> shame I was too busy messing around with my irc client and now don't have back scroll :P
14:59:57 <copumpkin> kfish: well, I think I have enough to get started now, thanks! I'm excited :) then I'll need to solve the hardest problem in computer science of course
14:59:57 <shachaf> And a semigroupoid with identities is called a monoidoid.
15:00:08 <kfish> heh
15:00:11 <copumpkin> kfish: namely, to install gtk/cairo on Mac OS
15:00:38 * AfC makes sure to write down this wisdom of shachaf's somewhere
15:00:56 <kfish> copumpkin, cool, let me know if you have any other qs/ideas ... btw. we are using this for market analysis too so probably have similar needs
15:01:06 <ocharles> @remember <shachaf> And a semigroupoid with identities is called a monoidoid.
15:01:07 <lambdabot> Done.
15:01:22 <copumpkin> kfish: cool :) it might take me a while to get something going cause it's just a free-time project, but I really like the look of it so far
15:01:46 <kfish> ok cool
15:02:04 <kfish> also let me know if you get gtk/cairo going on mac os, i've heard it works but no idea
15:02:32 <copumpkin> will do
15:11:07 <xtea> shachaf: It didn't help any other suggestions ? c <- getCharis within hSetEcho False <--- can this matter ?
15:12:31 <shachaf> xtea: What?
15:13:10 <xtea> shachaf: sorry, getChar still awaits Enter - buffers input
15:13:52 <copumpkin> kfish: what kind of datastructure are you using, out of curiosity? is it some sort of b-tree as an index to seek by timestamp plus a streamy data file?
15:14:32 <xtea> shachaf: I can c&p code for that if you wish
15:16:09 <kfish> copumpkin, currently just the streamy data file, haven't done the seek index yet (tho i've got code for something similar in ght, implementing git's .idx files using mmap)
15:16:43 <shachaf> xtea: I don't understand what's going on at all.
15:16:50 <shachaf> xtea: This program works for me: main = hSetEcho stdin False >> hSetBuffering stdin NoBuffering >> getChar >>= print
15:16:51 <mzero> xtea: hSetBuffering h NoBuffering
15:17:26 <copumpkin> kfish: ah okay, so with long streams it gets slower as you go along?
15:17:46 <xtea> mzero: thx I'll give it a try
15:18:09 <copumpkin> dumpRawPackIndex :: FilePath -> IO String
15:18:11 <copumpkin>     return "Woot"
15:18:13 <copumpkin> lol
15:18:21 <xtea> mzero: ow sorry I've done this already doesn't work :(
15:18:39 <hpc> copumpkin: is that actual haskell code?
15:18:49 <copumpkin> hpc: well, I omitted the actual meat of the function
15:18:52 <copumpkin> I just thought it was cute :)
15:18:53 <hpc> ah
15:19:01 <hpc> was gonna say...
15:20:27 <xtea> I'll give it a try here again getChar should not buffer input but it does
15:20:31 <xtea> getCh :: IO Char
15:20:31 <xtea> getCh = do
15:20:31 <xtea>   hSetBuffering stdin NoBuffering
15:20:31 <xtea>   hSetEcho stdin False
15:20:31 <xtea>   c <- getChar
15:20:33 <xtea>   hSetEcho stdin True
15:20:36 <xtea>   
15:20:38 <xtea>   if c `elem` buttons
15:20:41 <xtea>     then do
15:20:43 <xtea>     putChar c
15:20:46 <xtea>     return c
15:20:48 <xtea>     else do
15:20:51 <xtea>     if c == '\n'
15:20:53 <xtea>       then do
15:20:56 <xtea>       return c
15:20:58 <xtea>       else do
15:21:01 <xtea>       getCh
15:21:36 <Axman6> don't do that!
15:21:41 <Axman6> use a paste website
15:21:44 <xtea> ghc 7.0.3
15:21:46 <Axman6> @hpaste
15:21:46 <lambdabot> Haskell pastebin: http://hpaste.org/
15:21:53 <xtea> ops sorry
15:21:54 <mzero> but your first four lines in a function by itself - and call it from ghci and see if it works
15:21:57 <kfish> copumpkin, currently, maybe not by next week lol
15:22:05 <mzero> when I type    hSetEcho stdin False >> hSetBuffering stdin NoBuffering >> getChar >>= print      into ghci -- it works just fine
15:22:18 <mzero> no echo, no buffering
15:22:22 <shachaf> mzero: ghci isn't good for testing this because it does its own buffering.
15:22:27 <mzero> k
15:22:34 <shachaf> However it also works when you put it into a .hs file and runghc. :-)
15:23:10 <xtea> well I'll try to set noEcho first and then noBuffering then
15:23:15 <mzero> same here
15:24:53 <copumpkin> kfish: sweet :)
15:25:25 <xtea> no success :(
15:27:47 <mzero> what OS are you on, xtea?
15:30:13 <xtea> mzero: osx
15:34:31 <kfish> copumpkin, sweet, multichannel is working (um, building) now, encoding pcm audio in zoom-cache-sndfile, with channel count at type-level
15:34:41 <copumpkin> cool :)
15:34:54 <copumpkin> kfish: I assume you use the sndfile parts extensively at tsuru
15:35:21 <kfish> yeah, for the cranking techno DJing while we trade
15:35:28 <kfish> s/techno/dnb/
15:36:23 <copumpkin> :)
15:38:50 <kfish> hmm, should i split the type-level stuff into a separate package to avoid dependency hell, or drop to a value-level representation ...
15:39:29 * kfish hates it when deployment issues get in the way of fun type-hackery
15:47:31 <xtea> ok guys you were 100% right I've got it screwed somewhere else ;) sorted now. sorry for being annoying and thx for help
15:50:51 <Nafai> When you do ghc-pkg list, what does it mean when a package name is in curly braces?
15:53:52 <shachaf> Nafai: Hidden?
15:53:55 <benmachine> Nafai: is this an old ghc-pkg list?
15:54:11 <shachaf> Hmm, there's also ().
15:54:18 <shachaf> Which apparently show up as red and blue for me.
15:54:22 <benmachine> shachaf: I think... yeah, parentheses seems to be hidden
15:54:27 <benmachine> red is broken
15:54:52 <Nafai> from 7.0.3
15:54:58 <benmachine> Nafai: hm
15:55:09 <shachaf> Oh.
15:55:16 <benmachine> mine does pretty colours
15:55:24 <benmachine> Nafai: try ghc-pkg check
15:55:29 <benmachine> see if that says anything interesting
15:55:39 <Phyx-> he said curly not parenthesis though
15:55:50 <Phyx-> i'm thinking broken packages?
15:55:56 <shachaf> Yep, I think so.
15:56:57 <Nafai> Yeah, broken.
15:57:04 <Nafai> thanks, I can figure it out from here. :)
16:04:11 <keep_learning> > [1..] `seq` 2
16:04:13 <lambdabot>   2
16:04:19 <keep_learning> > [1..] `deepseq` 2
16:04:20 <lambdabot>   Not in scope: `deepseq'
16:04:30 <keep_learning> @hoogle deepseq
16:04:31 <lambdabot> Control.DeepSeq module Control.DeepSeq
16:04:31 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
16:04:31 <lambdabot> package deepseq
16:04:39 <keep_learning> > [1..] `deepseq` 2
16:04:40 <lambdabot>   Not in scope: `deepseq'
16:05:41 <benmachine> :t deepSeq
16:05:42 <lambdabot> Not in scope: `deepSeq'
16:05:55 <benmachine> :t Control.DeepSeq.deepseq
16:05:57 <lambdabot> forall a b. (Control.DeepSeq.NFData a) => a -> b -> b
16:06:30 <keep_learning> > [1..] `Control.DeepSeq.deepseq` 2
16:06:31 <kissyboy> is forall r. (forall a. a -> r) -> r equivalent to exists a. a?
16:06:31 <lambdabot>   Not in scope: `Control.DeepSeq.deepseq'
16:09:57 <ddarius> It's equivalent to forall r. ((exists a. a) -> r) -> r
16:10:42 <benmachine> ddarius: which is /pretty close/ to the same thing, right?
16:10:51 <kissyboy> ah, i see.
16:13:36 <erider> > take 10 [10..]
16:13:37 <lambdabot>   [10,11,12,13,14,15,16,17,18,19]
16:13:55 <kissyboy> i'm still having trouble understanding how you jump from forall to exists
16:14:05 * hackagebot stripe 0.1 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.1 (MichaelSchade)
16:14:08 <shachaf> > ap take enumFrom 10
16:14:09 <lambdabot>   [10,11,12,13,14,15,16,17,18,19]
16:14:17 <harrison> for some values of 2
16:14:18 <kissyboy> like also how data Foo = forall a. Foo a is equivvalent to data Foo = Foo (exists a. a)
16:14:39 <kissyboy> i mean i know that it is somehow, i just have no intuition for it
16:15:16 <erider> shachaf: what is the ap function?
16:15:50 <shachaf> kissyboy: monochrom might link to http://www.cs.toronto.edu/~trebla/personal/weblog/any-all-some.html
16:16:48 <shachaf> kissyboy: By the way, it might be helpful to use GADT syntax for that sort of thing: data Foo where { Foo :: forall a. a -> Foo }
16:17:00 <shachaf> erider: In this context, ap = S = \x y z -> x z (y z)
16:17:08 <kissyboy> thanaks i'll check that out
16:19:29 <ddarius> Hom is continuous in its first argument.  QED.
16:27:35 <harrison> http://www.youtube.com/watch?v=X5T2GwNZTt0
16:29:13 <dmwit> mischan?
16:30:34 <Axman6> harrison: why am i watching this?
16:31:31 <harrison> y? y is because of x the unknown...
16:31:49 <Axman6> are you looking for a ban or what?
16:32:20 <harrison> why are you being so cruel?
16:33:01 <Axman6> why are you spamming the channel with off topic, boring videos?
16:33:31 <dmwit> I wouldn't say he's spamming just from one message.
16:33:35 <dmwit> But it is off-topic.
16:34:25 <Axman6> well, i got the feeling that since this is one of the largest channels in freenode, and we've never heard anything from him before, it's likely to be spam
16:35:11 <harrison> no, to be honest, i posted it in haskell-game (where it is arguably relevant) first -- but there was almost noone there.
16:35:25 <Axman6> is it written in haskell?
16:35:29 <harrison> so i would say that it is not spam
16:35:57 <Axman6> then make that clear, there was no reason to not think it was spam without you giving us more information
16:36:12 * Axman6 -> lunch
16:36:24 <dmwit> harrison: Are you the author? =)
16:36:25 <AfC> harrison: (perhaps you might have prefaced your link with a few words of context. {shrug})
16:36:32 <harrison> very much so
16:36:45 <dmwit> Cool!
16:36:47 <harrison> and i have a channel #xolotl-hybrid
16:36:55 <Axman6> then why didn't you tell us what it was >_<
16:37:17 <harrison> because i am laconic and austere
16:37:38 <harrison> no, it isn't in haskell
16:37:41 <dmwit> So, now that you know we want context... WTF are we looking at?
16:38:04 <harrison> but it might have been; that is, i considered ocaml and haskell before i started coding
16:38:17 <dmwit> ...
16:38:24 <Axman6> so why are you here then
16:38:30 <harrison> and i really wanted to use manticore, john reppy's multicore ml
16:38:39 <harrison> but it isn't ever ready to use
16:38:59 <Axman6> urgh, i'm leaving before I get more annoyed by stupidity
16:39:29 <Rotaerk> that's my thought on the road to work
16:39:34 <Rotaerk> but I can't leave :(
16:39:34 <harrison> the petty and the small / are overcome by gall / when Genius, having faltered, fails to fall
16:42:59 <ga2arch> hi =)
16:48:44 <ga2arch> i'm trying to learn haskell, so i'm just a beginner
16:49:09 <ga2arch> but i just cannot figure it out how to do some simple stuff like
16:49:22 <ga2arch> given a list like ["hi", 1, 2]
16:49:39 <dmwit> 1 is not a String.
16:49:54 <dmwit> (...and lists are homogeneous.)
16:50:40 <dmwit> Alternately: "hi" is not a number.
16:50:41 <ga2arch> damn it, i always forget that :S
16:50:50 <ga2arch> that's explain a lot
16:50:55 <shachaf> dmwit: "hi" *could* be a number!
16:51:02 <dmwit> shachaf: Yes, and 1 *could* be a string!
16:51:04 <shachaf> And, with OverloadedStrings, 1 could be a String!
16:51:10 <dmwit> But thank $DEITY they're not.
16:51:26 <Peaker> No sigils here please! :)
16:51:29 <nexion> ...
16:51:38 <dmwit> shachaf: You got it backwards. OverloadedStrings is needed to make "hi" a number; no extensions are needed to make 1 be a String.
16:51:53 <shachaf> dmwit: Oh, yes.
16:52:02 <shachaf> dmwit: Actually, "hi" can be made a number without OverloadedStrings.
16:52:23 <dmwit> Okay, I'll bite: how?
16:52:33 <shachaf> Well, an instance of Num, I mean.
16:52:46 <dmwit> Right, okay.
16:52:50 <shachaf> I guess you need FlexibleInstances or something.
16:52:58 <shachaf> Or you could use IsChar.
16:53:12 <shachaf> ga2arch: Anyway, yes, lists are homogeneous.
16:53:17 <shachaf> ga2arch: What are you trying to do?
16:53:27 <TangoArgentino> Hi, i'm looking for a web framework in haskell, does anyone have experience with http://snapframework.com/ ? or is there a better alternative?
16:53:45 <dmwit> Snap and yesod seem to be the top contenders these days.
16:53:51 <dmwit> Happstack still gets some serious love.
16:53:55 <dmwit> ?wiki web frameworks
16:53:55 <lambdabot> http://www.haskell.org/haskellwiki/web_frameworks
16:54:04 <dmwit> hm
16:54:06 * hackagebot dx9d3d 0.1.0.2 - A binding to the Microsoft DirectX 9 API.  http://hackage.haskell.org/package/dx9d3d-0.1.0.2 (KidoTakahiro)
16:54:08 * hackagebot dx9d3d 0.1.1.1 - A binding to the Microsoft DirectX 9 API.  http://hackage.haskell.org/package/dx9d3d-0.1.1.1 (KidoTakahiro)
16:54:15 <dmwit> ?wiki web/frameworks
16:54:15 <lambdabot> http://www.haskell.org/haskellwiki/web/frameworks
16:54:23 <ga2arch> trying to write something that allow me to convert int, string, list to bencode values
16:54:27 <dmwit> wut
16:55:01 <dmwit> ga2arch: No problem; just define a data type that tags ints, strings, and lists with appropriate constructors.
16:55:10 <dmwit> ?wiki Web/Frameworks
16:55:10 <lambdabot> http://www.haskell.org/haskellwiki/Web/Frameworks
16:55:10 <donri> ?wiki Web/Frameworks
16:55:11 <lambdabot> http://www.haskell.org/haskellwiki/Web/Frameworks
16:55:14 <donri> ^_^
16:55:30 <TangoArgentino> thanks, i did read the wiki but for me is not clear which to choose...
16:56:01 <ga2arch> done that :)
16:56:28 <TangoArgentino> from the website appearance snap looks far better than the rest... but it´s still version 0.6 and is this version still beta and unstable?
16:56:34 <ddarius> TangoArgentino: How is someone else going to know what's better for you?
16:56:40 <ddarius> The latest version is 0.7.
16:56:43 <ga2arch> thanks for the quick help, now i see how to go on.
16:57:49 <dmwit> streampunk would be a cute name for something
16:58:00 <ddarius> TangoArgentino: The latest version of Yesod is 0.9.3.5
16:58:01 <dmwit> I wonder if that's strmpnk had in mind.
16:58:06 <TangoArgentino> ddarius, yeah you´re right. i just need something like ruby´s sinatra, simple and lightweight and stable with some community...
16:59:19 <dmwit> If you have some more specific technical question than "will it work for me", we may have a chance at helping you.
16:59:22 <donri> TangoArgentino: yesod gives you scaffolding and lots of quasi-quoters with custom syntax for things like routing and templating. happstack likes to stick to haskell in for example its preference for persistence of native haskell values and common use of blaze-html or even hsp for that matter. i have no idea what people find interesting in snap.
16:59:23 <ddarius> The only web frameworks with any "community" at all are Snap, Yesod, and Happstack.  They are all fairly young projects.
16:59:24 <dmwit> Like, "does it do SSL?".
16:59:29 <dmwit> That kind of thing is Knowable.
17:00:12 <ddarius> There is a web framework that attempt to mimic Sinatra on Hackage somewhere, but I don't know if even the author still uses it.
17:00:47 <Peaker> TangoArgentino: I know Yesod aims to be as type-safe as possible. I don't know about the other frameworks
17:01:08 <TangoArgentino> thanks i will testdrive yesod and happstack and will come back with more detailed questions...
17:01:09 <donri> snap might be more practically-oriented than its contenders, e.g. using xhtml templates and routing via pattern matching.
17:01:39 <Peaker> doesn't sound very nice/safe
17:02:08 <donri> no, i'm not personally all that impressed by snap, but i don't know enough.
17:04:20 <donri> Peaker: not sure if yesod does anything WRT typesafety that happstack doesn't do too, though?
17:04:49 <ddarius> Really the choice of web framework is really how you want to handle routing.  Many of the components are largely interchangeable and likely will become more so in the future.
17:04:52 <donri> last i checked yesod's typesafe routing even used a happstack-spawned package (web-routes)
17:05:55 <mightybyte_> TangoArgentino: There's a StackOverflow question about the differences between Snap and Yesod at http://stackoverflow.com/questions/5645168/
17:06:13 <ddarius> Both Happstack and Yesod use warp as their actual web server (or Happstack soon will if not yet.)  You can use Heist with any of them.  I would think you can use Hamlet with any of them.  You can certainly use blaze-html with any of them.
17:06:58 <mightybyte_> ddarius: Yes, that's essentially the thrust of my answer to the above S.O. question.
17:07:40 <copumpkin> anyone know of a decent websocket client for haskell (ideally one that supports wss://)
17:07:41 <copumpkin> ?
17:08:38 <donri> as i understand it you can use hamlet/shakespeare completely independent of any web stuff at all
17:08:44 <Peaker> donri: It has type-safe URLs, where you match/route and generate them based on the same declarative code, with TH to generate safe from/to functions, or some such
17:08:54 <donri> similarly, happstacks' acid-state, ixset and web-routes are completely independent of anything happstack
17:09:03 <ddarius> Windows SharePoint Services has a url scheme?
17:09:03 <Peaker> donri: happstack may be as safe -- but snap apparently isn't
17:09:23 <donri> Peaker: http://happstack.com/docs/crashcourse/WebRoutes.html
17:09:31 <TangoArgentino> hmm, the yesod-link in the wiki is not working anymore, i got a 404
17:09:37 <Peaker> donri: I was mentioning snap as the unsafe one above, not happstack
17:09:40 <ddarius> @where yesod
17:09:41 <lambdabot> I know nothing about yesod.
17:09:45 <donri> Peaker: I know
17:10:08 <TangoArgentino> https://github.com/snoyberg/yesod
17:10:21 <donri> Peaker: I'm just curious since I know you're right about typesafety being one of the major ideas behind yesod, and yet I can't think of anything it does in that regard that happstack doesn't
17:10:26 <TangoArgentino> found it : https://github.com/yesodweb/yesod
17:10:41 <Peaker> donri: I don't know either one of them :)
17:17:46 <ddarius> @quote 17-ary
17:17:47 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
17:19:06 * hackagebot Workflow 0.5.8 - library for transparent execution of interruptible computations  http://hackage.haskell.org/package/Workflow-0.5.8 (AlbertoCorona)
17:20:18 <l5cx> i need help with this piece, please: http://haskell.org/haskellwiki/Runtime_compilation
17:21:51 <l5cx> am i correct in assuming that it's about generating a new function at runtime?
17:22:22 <l5cx> i.e., a function is generated and compiled into asm?
17:24:32 <ddarius> l5cx: No.
17:25:57 <l5cx> i see; any way to do it?
17:26:14 <Axman6> yes, with LLVM
17:27:08 <l5cx> i was hoping to find a substitute for eval
17:27:22 <ddarius> Or Harpy, or many other ways.
17:27:35 <stepcut> l5cx: mueval or hs-plugins
17:27:45 <Axman6> harpy was the other thing i was trying to remember =)
17:29:05 <copumpkin> can package names contain a dot?
17:29:27 <stepcut> copumpkin: in my experience no
17:29:46 <copumpkin> people call their protocol "socket.io", grr
17:29:52 <stepcut> copumpkin: so my packages are named things like, happstackDotCom
17:30:03 <Axman6> copumpkin: socketdotio!
17:30:31 <Axman6> dotio is kinda fun to say too
17:31:24 <mauke> preflex: zenc socket.io
17:31:25 <preflex>  socketziio
17:31:25 <stepcut> socket full stop io
17:31:35 <mauke> problem solved~
17:31:47 <Axman6> i like that
17:32:03 <benmachine> Axman6: is it otio like in potion?
17:32:06 <ddarius> preflex: zenc ASP.NET
17:32:07 <preflex>  ASPziNET
17:32:21 <mauke> preflex: zenc C#
17:32:22 <ddarius> benmachine: No, that would be insane.
17:32:22 <preflex>  Czh
17:32:24 <EvanR> the only valid characters should be A and B, to allow for maximum out of band communication
17:32:32 <EvanR> AAABBABABABBBBBAABAAAABBBB
17:32:40 <EvanR> AAABBABABABBBBpeanutbutterBAABAAAABBBB
17:33:05 <siracusa> preflex: zenc zenc
17:33:06 <preflex>  zzenc
17:33:34 <Axman6> preflex: zenc int main(){puts("Hello");}
17:33:34 <preflex>  intz20UmainZLZRz7bUputsZLz22UHelloz22UZRz3bUz7dU
17:34:06 * hackagebot couchdb-enumerator 0.3.4 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.3.4 (JohnLenz)
17:34:28 <ddarius> preflex: zenc U
17:34:29 <preflex>  U
17:34:53 <Axman6> preflex: zenc Z
17:34:53 <preflex>  ZZ
17:35:02 <ddarius> preflex: zenc "
17:35:02 <preflex>  z22U
17:36:36 <scshunt> Wom 4
17:37:00 * ddarius considers rereading "Probability Theory: The Logic of Science."
17:40:48 <gwern> > 115 + 14
17:40:49 <lambdabot>   129
17:41:36 <ddarius> ...
17:50:21 <pshrmn> I am thinking about making a website like project Euler, but specific to haskell over the winter break for a couple credits.
17:50:21 <pshrmn> Where each week a new problem would be posted. The site would include a CLI and some testing tools. Any ideas?
17:55:19 <ddarius> pshrmn: There are already existing sites that do more or less that.  All you would need to do is think up problems.
17:55:51 * ddarius <3 CSS
17:56:54 <parcs> pshrmn: go for it
17:58:22 <EvanR> alright, i will now checkout acid state
17:58:43 <stepcut> EvanR: awesome!
17:59:35 <EvanR> is it nosql(tm) ? ;)
18:00:35 <stepcut> it's better than nosql!
18:00:55 <Axman6> it's SooooNoSQL
18:01:07 <EvanR> so i have to have a shitload of memory
18:01:12 <EvanR> do i*
18:01:17 <stepcut> only if you have a shitload of data
18:01:22 <EvanR> thats the idea
18:01:28 <stepcut> :)
18:01:38 <roconnor> ddarius: I wish that book were better written.  It probably would have helped if the author didn't die in the middle of writing it. ;(
18:01:40 <EvanR> an infinitely growth transaction record
18:01:56 <EvanR> growing*
18:02:58 <stepcut> EvanR: but does it grow faster than your ability to buy RAM?
18:03:14 <cgroza> > arr (+1)
18:03:15 <lambdabot>   No instance for (GHC.Show.Show (a a1 a1))
18:03:15 <lambdabot>    arising from a use of `M442175...
18:03:27 <EvanR> stepcut: considering ive never operated a 64bit computer, yes
18:03:36 <cgroza> What is the difference between:
18:03:41 <cgroza>  > arr (+8) &&& arr (+100) $ 1
18:03:41 <stepcut> then acid-state may not be for you
18:03:46 <stepcut> at this time anyway
18:03:46 <EvanR> k
18:03:48 <cgroza> and
18:03:56 <cgroza> > (+8) &&&  (+100) $ 1
18:03:57 <lambdabot>   (9,101)
18:04:02 <EvanR> stepcut: so does it keep all the data in memory
18:04:05 <stepcut> yup
18:04:09 <stepcut> for now anyway
18:04:11 <cgroza> When do I need to use the arr?
18:04:15 <mauke> :t arr
18:04:16 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
18:04:20 <EvanR> what about swap ;)
18:04:29 <mauke> cgroza: when you use an arrow that isn't ->
18:04:32 <donri> stepcut: not with ixset though right?
18:04:34 <stepcut> EvanR: hopefully not
18:04:39 <EvanR> k
18:04:48 <cgroza> mauke: could you please clarify?
18:04:54 <mauke> no
18:05:00 <EvanR> stepcut: how much memory does stuff have these days?
18:05:02 <stepcut> donri: ixset is a pure data structure. There are ideas on how to create a varient of ixset that can store the keys in RAM but the data on disk
18:05:05 <parcs> ;t fix . arr
18:05:09 <parcs> :t fix . arr
18:05:10 <lambdabot> forall a. (a -> a) -> a
18:05:12 <cgroza> mauke: what do you mean by ->
18:05:12 <stepcut> EvanR: stuff?
18:05:16 <parcs> i am genius
18:05:23 <mauke> cgroza: the function type constructor
18:05:34 <stepcut> EvanR: I think facebook has something like terrabytes of memcached servers caching 80%+ of their working data set
18:05:49 <EvanR> thats with multiple PCs though
18:05:50 <donri> stepcut: ah, i was under the impression that it was already so
18:06:03 <EvanR> does acid state support multiple computers?
18:06:07 <donri> yep
18:06:15 <stepcut> EvanR: acid-state attempts to do away with the need for memcached
18:06:15 <EvanR> whoa really?
18:06:18 <donri> there's a client/server thing
18:06:51 <EvanR> yes no memcached would be nice, but utilizing all my existing computers for storage would be nice
18:07:23 <cgroza> mauke: I still don't get what you meant.
18:07:24 <donri> not sure you can split it up arbitrarily easily, but you could keep different states on different computers and connect remotely
18:07:33 <stepcut> EvanR: yes. acid-state is optimized for speed. not cost.
18:07:39 <Axman6> :t fix arr
18:07:41 <lambdabot> forall b c. b -> c
18:08:25 <donri> stepcut: do you know if there's anything similar to acid-state that is not kept in memory all the time? but still provides the acidity and seamless serialization?
18:08:27 <stepcut> EvanR: acid-state does not currently have replication or sharding. happstack-state did have two different experimental replication backends.
18:08:39 <EvanR> hum
18:08:59 <stepcut> donri: how would you write queries?
18:09:04 <parcs> :t let f = f . arr in f
18:09:06 <lambdabot> forall b c b1. (b -> c) -> b1
18:09:53 <EvanR> i like speed, but i would also like space ;)
18:09:59 <EvanR> a lot of space
18:10:07 <donri> stepcut: duno, is it all that different from the server-based model with acid-state?
18:10:09 <EvanR> a friggin lot of space
18:10:16 <roconnor> stepcut: what is sharding?
18:10:33 <EvanR> roconnor: technology to achieve webscale
18:10:43 <roconnor> what's webscale?
18:10:47 <stepcut> EvanR: then you need a disk-based solution. But it certainly won't be as fast.
18:11:10 <EvanR> stepcut: hum... is there something like this for haskell?
18:11:42 <stepcut> roconnor: in this context, it means a scheme that would allow you to split your data set over several servers in a manageable way
18:12:25 <stepcut> EvanR: a database for haskell that stores a lot of data on disk?
18:12:37 <EvanR> yeah
18:12:52 <EvanR> a nice interface
18:12:57 <stepcut> EvanR: you can use bindings to other database libraries..
18:13:07 <stepcut> EvanR: persistent maybe?
18:13:21 <stepcut> EvanR: depends on your data and how you want to access it
18:13:26 <EvanR> at this very moment id like to avoid setting up yet another RDBMS server
18:13:37 <donri> sqlite? :)
18:13:39 <EvanR> a single file would be good
18:13:57 <stepcut> EvanR: what sort of queries?
18:14:36 <EvanR> something like, a large set of (a,b,c,d) with searches on a and b
18:14:39 <EvanR> a or b
18:15:05 <cgroza> mauke: so I don't need to use arr on functions because there is a Arrow (->) instance?
18:16:00 <mauke> no
18:16:10 <mauke> the only thing you can use arr on is functions
18:16:14 <donri> arr is id for function arrows
18:16:15 <mauke> look at the type
18:17:18 <xplat> > rot13 "xplat"
18:17:20 <lambdabot>   "kcyng"
18:17:27 <Axman6> arr is for lifting functions into some other arrow
18:17:42 <stepcut> EvanR: there are a bunch of key/value nosql things these days.. but I do not know of anything haskell specific
18:17:53 <Axman6> (that terminology is probably wrong)
18:18:11 <cgroza> What I do not understand is why do I have to use arr in this code: second' a =  arr swap' >>> first a >>>  arr  swap' , but not in this one f =  length  >>> (+3) ?
18:18:24 <stepcut> EvanR: in theory, you want the version of ixset that transparently stores data on the disk ..
18:18:47 <stepcut> EvanR: but no one has written it yet
18:18:48 <donri> cgroza: the latter is using the (->) Arrow instance, the former perhaps not
18:19:23 <cgroza> donri: what makes the first one not use the arrow instance?
18:19:31 <xplat> does setNumCapabilities allow for a combination of parallelism and safe daemonization?
18:19:41 <EvanR> stepcut: ixset, sounds interesting, dunno its interface ;)
18:19:51 <EvanR> would it let you index on more than one slice of the records
18:19:56 <Axman6> :t length >>> (+3)
18:19:57 <lambdabot> forall a. [a] -> Int
18:20:09 <donri> cgroza: depends, i don't know its type
18:20:12 <Axman6> :t arr length >>> arr(+3)
18:20:13 <lambdabot> forall a (cat :: * -> * -> *). (Arrow cat) => cat [a] Int
18:20:37 <stepcut> EvanR: yes. ixset is an indexed set type. You can have mulitple indices.
18:20:42 <cgroza> donri: the type is : second' :: Arrow a => a b c -> a (d, b) (d, c)
18:21:13 <EvanR> stepcut: sounds great
18:21:23 <donri> cgroza: ah, so it's polymorphic
18:21:39 <EvanR> stepcut: how about relational algebra onto of that ;)
18:21:50 <donri> cgroza: if you make it monomorphic to Arrow (->) i suspect you might not need arr
18:21:57 <cgroza> donri : I have to use arr on polymorphic situations?
18:22:16 <donri> cgroza: to lift functions into arbitrary arrows, yes
18:22:25 <stepcut> EvanR: it could be done. I have experimented with that in the past, but I tried to do too much in the type system :)
18:22:29 <cgroza> donri: thanks. That clears it a bit.
18:22:42 <stepcut> EvanR: like, sub-select rewriting in the type system :-/
18:22:49 <EvanR> ok
18:22:53 <EvanR> you are mad
18:23:19 <EvanR> i was about to say haskell stuff makes me think the future is bright for computers ;)
18:23:30 <stepcut> :)
18:23:42 <EvanR> but then some fool comes along implementing doom II in the type system
18:23:43 <donri> cgroza: (->) is just *one* of many arrows, and the arrow instance can vary widely. "arr" can be overridden for an instance.
18:24:03 <EvanR> lol
18:24:03 <donri> it's not necessarily doing the same thing for every arrow.
18:24:20 <stepcut> EvanR: Haskell is a great language.. for writing the first Agda compiler in ;)
18:24:22 <cgroza> donri: so arr for different types can differ?
18:24:37 <donri> yep
18:24:47 <donri> just like return can differ between monads, etc
18:24:57 <cgroza> donri: and that is the reason it is required in polymorphic situations?
18:25:03 * stepcut gets back to work
18:25:14 <donri> yes, it's just coincidence that arr = id for (->)
18:25:29 <cgroza> donri: I get it now. thanks.
18:25:33 <donri> \o/
18:26:31 <cgroza> So when the exact type is known, the complier can deduce the exact arrow for my function ?
18:26:44 <xplat> Cale: your arrow class sounds very similar to garrows
18:27:32 <donri> cgroza: yes, because "arr" refers to the definition in the arrow instance for that type
18:28:01 <donri> cgroza: you do understand type classes and instances?
18:28:31 <cgroza> donri: I think so. I mean, I have no problems with them when working with monads.
18:29:00 <mauke> cgroza: 'arr' is the 'return' of Arrow
18:29:02 <donri> cgroza: so remember that "arr" is part of the Arrow class, and not just a plain function
18:29:43 <cgroza> mauke: donri: thank you for your help. I am going to practice now :D
18:30:03 <donri> in fact, "arr" is even part of the minimal complete definition, meaning it must be defined for every instance of Arrow
18:30:10 <Cale> xplat: is that on hackage?
18:30:11 <preflex>  Cale: you have 2 new messages. '/msg preflex messages' to read them.
18:30:51 <Cale> xplat: hah! Music of the spheres
18:32:29 <donri> cgroza: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Arrow.html#line-114 there you can compare arr for (->) and Kleisli
18:35:06 <donri> hey is Kleisli actually useful for anything or is it mostly there as an example / proof for arrows-as-monads?
18:35:34 <Cale> xplat: Thanks very much for that reference!
18:35:35 <fullofcars> In parsec I'm trying to separate exprs with sepBy using whitespace, but this fails since it thinks the ) is an expression in - "(+ 2 2 )""
18:35:43 <Cale> xplat: It's almost identical to what we've been doing
18:35:50 <fullofcars> Can anyone show me how to build a parse that fixes that?
18:36:24 <Axman6> I wouldn;t use sepBy for that
18:37:04 <fullofcars> ah, what might be my alternative(s)?
18:37:15 <fullofcars> currently I'm just using - let readExprs = sepBy readExpr skipWhitespace1
18:37:32 <fullofcars> it definitely does not work :)
18:38:30 <fullofcars> maybe just many readExpr
18:39:37 <xplat> > rot13 "EvanR"
18:39:39 <lambdabot>   "RinaE"
18:39:46 <fullofcars> ya, that seems to work
18:40:38 <xplat> Cale: i don't know, they've got a project page
18:41:25 <fullofcars> man I feel dumb
18:41:32 <fullofcars> thanks all
18:42:00 <xplat> Cale: oh, i see you found it :)
18:42:10 <dented42> @type fix
18:42:11 <lambdabot> forall a. (a -> a) -> a
18:42:11 <dbelange_> how do I printf
18:42:11 <dbelange_> in haskell
18:42:21 <Axman6> using printf =)
18:42:22 <endojelly> pointfree random choice: (uncurry $ liftM . (!!)) $ (second (randomRIO . (0,))) . (id &&& ((+ (-1)) . length)) $ ["one","two","three"]
18:42:31 <monochrom> I would write a little parser for "(" that eats whitespaces afterwards (if any), a little parser for "+" (or other operators) that eats whitespaces afterwards (if any), a little parser for numbers like "2" that eats whitespaces afterwards (if any), etc etc, you get the idea.
18:42:32 <endojelly> > (uncurry $ liftM . (!!)) $ (second (randomRIO . (0,))) . (id &&& ((+ (-1)) . length)) $ ["one","two","three"]
18:42:33 <lambdabot>   Illegal tuple section: use -XTupleSections
18:42:36 <fullofcars> is it common to do lexing and parsing in a single pass in parsec for simple languages?
18:42:40 <Axman6> > printf "%d: %02x" 12 5
18:42:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:42:41 <lambdabot>    `Text.Printf.PrintfType ...
18:42:45 <Axman6> > printf "%d: %02x" 12 5 :: String
18:42:46 <lambdabot>   "12: 05"
18:43:06 <endojelly> > (uncurry $ liftM . (!!)) $ (second (randomRIO . (,) 0)) . (id &&& ((+ (-1)) . length)) $ ["one","two","three"]
18:43:07 <lambdabot>   <IO [Char]>
18:43:15 <Axman6> fullofcars: yeah, it's usually done like that. you can also lex before parsing if you prefer
18:43:18 <monochrom> then to parse "(+ 2 2)" I write: do {openparen; plus; x <- number; y <- number; closeparen; ...}
18:43:31 <monochrom> and it will also work for ( + 2 2 )
18:43:41 <fullofcars> cool thanks ax :)
18:43:57 <monochrom> somewhere in the very beginning, you should eat leading whitespaces, just once and for all, of course
18:44:02 <Axman6> fullofcars: also, listen to monochrom :P
18:44:36 <fullofcars> ok
18:46:33 <fullofcars> is there a simple way to read strings with escaped chars with parsec?
18:47:48 <fullofcars> currently when I parse a string like "\n" it becomes ['\\' 'n']
18:48:14 <fullofcars> but I want it to see it as an escaped char like ['\n']
18:48:30 <endojelly> @pl \x -> randomRIO (0::Int, length x - 1) >>= return . (x !!)
18:48:30 <lambdabot> ap ((>>=) . randomRIO . (,) (0 :: Int) . subtract 1 . length) ((return .) . (!!))
18:48:51 <donri> do string "\n"; return '\n' -- something like that?
18:48:54 <JoeyA> fullofcars: Consider looking at http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Language.html , which provides token parsers for various languages.
18:49:10 <donri> uhm string "\\n" i guess
18:50:09 <dbelange_> > printf "oh %d %d doodoo" 453 -2 : String
18:50:10 <lambdabot>   Not in scope: data constructor `String'
18:50:16 <dbelange_> > printf "oh %d %d doodoo" 453 -2 :: String
18:50:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
18:50:17 <lambdabot>    arising from the literal `...
18:50:30 <Axman6> need (-2)
18:50:34 <mauke> (negate 2)
18:51:02 <dbelange_> this is hard guys O.o
18:51:08 <dbelange_> does printf use space suits
18:51:14 <dbelange_> i mean monads
18:51:18 <Axman6> no
18:51:26 <Axman6> it uses type classes
18:51:31 <Cale> > printf "oh %d %d doodoo" 453 (-2) :: String
18:51:32 <lambdabot>   "oh 453 -2 doodoo"
18:51:46 <mauke> > $(printf)
18:51:48 <lambdabot>   <no location info>: parse error on input `$'
18:51:48 <dbelange_> could it be modified to use space suits
18:51:53 <donri> @src printf
18:51:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:51:55 <Cale> dbelange_: You can make it :: IO () and it'll be the IO action for printing
18:52:09 <Cale> dbelange_: so it does both printf and sprintf
18:52:17 <Cale> essentially
18:54:39 <tomprince> :t printf
18:54:40 <lambdabot> forall r. (PrintfType r) => String -> r
18:54:59 <tomprince> :info PrintfType
18:56:59 <darkf> Can anyone explain monads? I've read many texts on them, but I can't grasp them
18:57:12 <mauke> ignore monads
18:57:18 <mauke> they're not that important
18:57:26 <darkf> why?
18:57:42 <darkf> a lot of people use them and I feel like I'm missing out by not understanding them; I'd like to use them
18:57:49 <mauke> you're already using them
18:57:55 <mauke> [] is a monad
18:58:27 <darkf> I asked for someone to explain, not complain about them :p
18:58:36 <mauke> I'm not complaining
18:58:38 <djahandarie> mauke has the right idea.
18:58:54 <djahandarie> If you don't understand them atm then that just means it's because you're skipping ahead
18:58:55 <Clint> Maybe he does
18:59:02 <darkf> no, it's not the right idea to brush them off as "herp, empty lists are monads"
18:59:17 <tomprince> monads are seen as hard, not because they are complicated, but because they are simple.
18:59:24 <djahandarie> Lists are monads. How is that brushing them off?
18:59:34 <darkf> and what I wasked for is an explanation, not a vague statement.
18:59:42 <darkf> if you can't deliver that, I didn't ask for your "help"
18:59:44 <darkf> the end
18:59:48 <djahandarie> ...
18:59:52 <Clint> you should demand a refund
18:59:52 <mauke> darkf: empty lists aren't monads
19:00:05 <mauke> darkf: I was talking about the type, not the value
19:00:08 <tomprince> There are a lot of explantions, written people who have just started to get them, and so aren't explained well.
19:00:14 <mauke> well, the type constructor
19:00:24 <darkf> tomprince: and that is why I *asked for one* :p
19:00:37 <mauke> darkf: do you understand Show?
19:00:52 <darkf> mauke: yes.
19:00:55 <monochrom> there is nothing to explain about monads, or arrays, or numbers, or functions. you just use them.
19:00:58 <mauke> darkf: do you understand Read and Functor?
19:01:04 <darkf> mauke: no.
19:01:10 <mauke> ok, that would be a good next step
19:01:36 <darkf> mauke: I'm just saying, I've somehow understood them at an abstract level, but I don't get why or how they're used
19:01:41 <darkf> or really what they're for.
19:02:09 <mauke> me neither
19:02:09 <monochrom> reading too much text on monads is why you are lost. as you are if you read too much philosophy on numbers.
19:02:33 <darkf> monochrom: I haven't read them in months. I'm asking for a clear explanation on them, that is all.
19:02:38 <tomprince> which I think was what prompted mauke's first suggetion.
19:02:43 <mauke> that is, I know how to use >>= but I don't know the abstract essence of monadicity
19:02:46 <ski> darkf : a monad is a type `M', together with operations `return :: a -> M a', `(>>=) :: M a -> (a -> M b) -> M b' satisfying the laws `forall a,amb. return a >>= amb = amb',`forall ma. ma >>= return = return',`forall ma,amb,bmc. ma >>= (\a -> amb a >>= bmc) = (ma >>= amb) >>= bmc' -- satisfied ?
19:02:58 <clsmith_> for me, the typeclassopedia really explained monads to me
19:03:08 <darkf> ski: no.
19:03:10 <mauke> ski: at least one of those laws looks wrong
19:03:24 <clsmith_> most explanations are like "monads are a spacesuit!" no, no they're not.
19:03:29 <darkf> mauke: then, how do I use >>=, unit and return? what are monads used for?
19:03:34 <mauke> ski: 'return a >>= amb = amb a'
19:03:35 <ski> sorry, the first law should be `forall a,amb. return a >>= amb = amb a'
19:03:41 <mauke> darkf: there is no "unit"
19:03:43 <endojelly> using Monad ((->) r) is pretty mindblowing...
19:04:05 <mauke> darkf: I don't know
19:04:06 <ski> and the second should be `forall ma. ma >>= return = ma'
19:04:19 <Axman6> darkf: monads are used for everything!
19:04:23 <darkf> mauke: if you don't know what they're used for, how do you understand them?
19:04:32 <mauke> darkf: I said I didn't
19:04:39 * ski takes this as a sign that he's too sleepy to say anything sensible
19:04:53 <darkf> cool, now is anyone going to be useful?
19:04:54 <mauke> darkf: I understand every monad separately
19:05:00 <mauke> not the concept "monad" itself
19:05:58 <tomprince> darkf: Like mauke said, I think you should try to understand Functor first.
19:06:01 <monochrom> recall how you learned numbers. you didn't ask, "explain 'three'". you were shown concrete examples: three apples, three cups, three fingers... you practiced adding numbers by first adding apples, adding cups, adding fingers. And so you will practice with concrete examples of monads. you use lists, you use Maybe, you use IO, you use parsec... they are all concrete examples, they have similarities and differences. use them. ge
19:06:01 <monochrom> t used to them.
19:06:27 <darkf> tomprince: I suppose it would be helpful, but I don't see why. All I'm looking for is how and why to use monads.
19:06:34 <mauke> heh. "all"
19:06:54 <mauke> you use "monads" when writing an abstract library like Control.Monad
19:07:12 <mauke> all of the fun stuff happens in the non-monad parts
19:07:15 <darkf> how does IO () work?
19:07:18 <shachaf> monochrom: I hear that 4 is a metaphor for death.
19:07:27 <mauke> darkf: ok, now that's a completely separate and much easier question
19:07:31 <shachaf> darkf: Reading the backlog in this channel, people are giving you good advice.
19:07:39 <mauke> darkf: do you happen to know javascript?
19:07:43 <darkf> mauke: yes.
19:07:45 <shachaf> darkf: You should listen rather than get offended. Ignore "monads" for now.
19:07:55 <mauke> darkf: ok. familiar with setTimeout and async http requests?
19:07:58 <shachaf> If you want to learn how "IO" works in Haskell, that's a very different question. :-)
19:08:00 <Axman6> darkf: how does IO work in C or Java?
19:08:00 <darkf> mauke: yep
19:08:07 <mauke> darkf: good, because IO is callback based
19:08:13 <darkf> Axman6: those are not pure functional languages and I/O is not implemented via monads
19:08:16 <Philippa> monochrom: most people I know don't actually recall learning numbers, FWIW
19:08:22 <mauke> darkf: Haskell IO is not implemented via monads
19:08:31 <darkf> state is, though
19:08:34 <shachaf> darkf: No.
19:08:37 <darkf> >.>
19:08:39 <mauke> State is just s -> (a, s)
19:08:42 <Axman6> darkf: you miss the point of my question though. the question you asked doesn't make much sense in the context
19:08:45 <mauke> there's no magic here
19:08:58 <bd_> darkf: technically speaking execution ordering is implemented with the IO monad
19:08:58 <shachaf> darkf: A good exercise is "Let's take Haskell, the purely functional language, as I know it. How might *I* implement IO in it?".
19:09:02 <Philippa> darkf: monad is an interface - there's no implementation to the concept
19:09:03 <Axman6> yeah, state is just functions
19:09:07 <mauke> bd_: fuck your "the IO monad"
19:09:10 <bd_> D:
19:09:18 <clsmith_> (remember this is a (terrible) metaphor.) 'return jam' puts jam into the jar. jar >>= upsidedownjar takes the jar and binds them, opening-to-opening, and slides the jam from one to the other; upsidedowning it in the process! you couldn't take it out of the monad with bind, of course, because you'd get jam all over the floor. >.>;;;
19:09:24 <djahandarie> lol
19:09:25 <shachaf> darkf: Figure out about five different answers.
19:09:25 <mauke> clsmith_: you're fired
19:09:29 * Axman6 senses mauke may need a nap
19:09:30 <clsmith_> :<
19:09:34 <shachaf> clsmith_: Why give terrible metaphors when you know they're terrible?
19:09:47 <bd_> mauke: GHC.Prim.State# then :(
19:09:49 <djahandarie> I sense that too many people are trying to help. :)
19:09:51 <clsmith_> it made me smile :(
19:09:51 <shachaf> It really doesn't help. It just confuses people, and people seem to be confused enough.
19:09:52 <darkf> shachaf: In a pure functional language? Well I'd have myself a read :: Int -> Maybe Char.
19:09:54 <Philippa> shachaf: because they highlight the "use this as a tool, not a precise description" nature
19:09:59 * djahandarie leaves it to mauke
19:10:05 <bd_> darkf: what's that int argument?
19:10:11 <shachaf> bd_: I don't think the Report talks about GHC.Prim.
19:10:13 <darkf> bd_: n bytes to read
19:10:25 <bd_> darkf: ah, but then if I do (read 1), it'll always return the same value
19:10:30 <Philippa> darkf: that's not pure functional
19:10:32 <shachaf> Philippa: If it was helpful in understanding, then it wouldn't be a terrible metaphor. :-)
19:10:35 <mauke> darkf: but "pure" means given the same arguments it will always return the same value
19:10:37 <bd_> darkf: (that's what pure means)
19:10:40 <shachaf> darkf: But remember that "read" has to be a function, i.e., referentially transparent.
19:10:44 <Axman6> darkf: but Maybe Char can only return zero or one chars
19:10:44 <shachaf> Ot
19:10:54 <shachaf> s/.*//
19:10:56 <djahandarie> Did 5 people really just say the exact same thing?
19:10:59 <mauke> yes
19:10:59 <bd_> djahandarie: yes.
19:10:59 <xplat> when you jam some jive about jamming jam in jam jars, you jar people's minds and jam communication
19:11:02 <Philippa> shachaf: I think you'll find there are multiple properties that "terrible" can be applied to there :p
19:11:07 <Behi> hi all
19:11:11 <darkf> bd_: how can an unpredictable operation such as I/O be referentially transparent?
19:11:19 <mauke> darkf: that's exactly the problem
19:11:21 <shachaf> Philippa: Fine. My point was that mauke is justified in firing clsmith_.
19:11:21 <Behi> I had a somehow theoretical question
19:11:23 <shachaf> darkf: It can't.
19:11:26 <clsmith_> shachaf: i didn't even get to the bit where i flip the jam upsidedown by thwacking it with a rolled-up map
19:11:28 <darkf> then how is it?
19:11:35 <shachaf> darkf: That's your exercise. :-)
19:11:38 <mauke> darkf: we invert control
19:11:40 * ddarius agrees with djahandarie's earlier statement.  More than 0 is already too many.
19:11:48 <darkf> mauke: how so?
19:11:56 <mauke> darkf: that is, we have an outside layer that does I/O and calls pure Haskell functions with the result
19:12:07 <mauke> darkf: because calling *into* Haskell doesn't cause problems
19:12:08 <Cale> darkf: I'll try to help
19:12:27 <djahandarie> Cale, there are definitely too many people helping right now.
19:12:30 <Cale> darkf: First of all, have you read my http://www.haskell.org/haskellwiki/Monads_as_computation
19:12:36 * mauke fades out
19:12:38 <Behi> In a hybrid OO/functional language where all variables are immutable, let's pretend we are displaying a list of objects in a table widget on the screen. Then the user clicks on a cell to edit its value. How could this be implemented?
19:12:44 <PatrickRobotham> Is there any way to express this as a type synonym? [(a,b)] such that a and b are members of Eq
19:12:50 <mauke> PatrickRobotham: no
19:13:02 <PatrickRobotham> Blast.
19:13:03 <darkf> Cale: One time or another, probably.
19:13:12 <Cale> darkf: Okay...
19:13:13 <shachaf> I think people trying to understand IO should probably not be linked to any article that has the M word in its name.
19:13:16 <bd_> PatrickRobotham: why does it need to be a type synonym?
19:13:27 <PatrickRobotham> bd_: Well, just to make my code shorter.
19:13:30 <Axman6> darkf: in Haskell, we sometimes talk about it being like a set fo instructions that is given to the runtime system to execure. when we ask for a new line of text from the user, the runtime system will ask the user to give it a new line of text, and then pass it to the set of haskell instructions
19:13:31 <mauke> bd_: so you don't have to type (Eq a, Eq b) => ... everywhere
19:13:39 <Cale> Behi: How could the user clicking be implemented?
19:13:48 <clsmith_> oh, that reminds me. tuples. are they basically type-level lists?
19:13:50 <Cale> Behi: I totally don't understand the question.
19:13:53 <darkf> Axman6: Cool, so how do monads play into all this?
19:13:54 <bd_> PatrickRobotham: so wrap it in a newtype with such a restriction?
19:13:54 <shachaf> It's possible to express it as a type synonym if you add forall. :-) But that's probably not what you want.
19:13:55 <PatrickRobotham> mauke: So would newtype work?
19:14:04 <mauke> PatrickRobotham: no
19:14:10 <PatrickRobotham> Oh.
19:14:16 <shachaf> darkf: Why do you care about "monads" so much? Did you read the FAQ entry about that?
19:14:19 <shachaf> @where faq
19:14:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:14:20 <ski> Behi : generating a new table value to place in the table widget, the same as in any other language ?
19:14:23 <Philippa> clsmith_: for rather loose values of "basically" - you can construct type-level lists from them, and HList does
19:14:24 <Cale> darkf: First off, do you understand type constructors?
19:14:29 <darkf> Cale: Yes.
19:14:41 <Cale> darkf: Okay, so a monad is just a type constructor which supports a specific API.
19:14:45 <Philippa> shachaf: "I messed up and this Monad typeclass appeared in the error" isn't an uncommon reason
19:14:57 <darkf> Cale: being (>>=) and return, right? So then what?
19:15:13 <Cale> darkf: and the reason we abstract over this, is because a) it's a fairly common pattern, and b) there are a bunch of useful things we can write in terms of it
19:15:19 <shachaf> Philippa: True.
19:15:22 <Axman6> data IO a = PutStr String (IO a) | GetChar (Char -> IO a) ...
19:15:25 <mauke> darkf: the upper 10% of the IO system match the operations in Monad, so the library makes it an instance of Monad
19:15:29 <Axman6> hmm, I think I buggered that up
19:15:38 <Cale> It has nothing to do with side effects or anything like that.
19:15:41 * Axman6 stops trying to steal Cale's usual explanation of IO
19:15:42 <darkf> Cale: Cool, so what can you write in it? How are theyh useful?
19:15:46 <Cale> But *specific* monads do.
19:15:49 <clsmith_> Philippa: i was just thinking, you could essentially concat two tuples at the type level, so (a,b,c,d) :: ((w,x) ++ (y,z))
19:15:53 <Behi> Cale, ski: in Java as variables are mutable, we can use a list of say Person objects, and find the object representing the row and say call setName("New Name") on it. But as in a language with immutable variables, we cannot have something like setName("...") to change the value of the name variable (instance variable), how can we update its value?
19:15:59 <Cale> So for example, there are parsing libraries
19:16:05 <clsmith_> s/concat/append/
19:16:06 <Cale> Which provide a type constructor Parser
19:16:06 <shachaf> Axman6: Even simpler: data IO = PutChar Char IO | GetChar (Char -> IO) | Exit
19:16:13 <bd_> PatrickRobotham: the problem with newtype is it will give you the implication that a, b are Eq, but if you explicitly write out a type formula, you need to make that explicit, or it'll complain because you just claimed that you can instantiate your newtype without an Eq restriction. or something.
19:16:26 <bd_> PatrickRobotham: You could avoid it with GADTs, I suppose.
19:16:31 <Axman6> shachaf: yeah, I was struggling to think there where the a would be used :P
19:16:40 <Philippa> clsmith_: they're not quite the same types unfortunately. But I'd prefer it if n-tuples were sugar on top of 2-tuples
19:16:42 <shachaf> Axman6: The a isn't even important.
19:16:48 <shachaf> @google r6.ca monad
19:16:49 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
19:16:49 <lambdabot> Title: I/O is not a monad
19:16:51 <Axman6> i know
19:16:54 <Cale> Parser t is a representation of a parser which consumes the initial part of a string and produces a value of type t
19:17:32 <Cale> return :: t -> Parser t is then a primitive parser which doesn't eat any of the string, and produces the given value as its result
19:17:43 <ski> Behi : you could have a list of `IORef CellState's, and execute `modifyIORef (setName "New Name")' on it
19:18:09 <Cale> (>>) :: Parser a -> Parser b -> Parser b  takes two parsers and produces their concatenation, throwing away the result of the first, and producing the result of the second parser
19:18:27 <Cale> So, parse the initial part of the string with the first parser, and the rest with the second
19:18:34 <Cale> make sense so far?
19:18:37 <darkf> yup
19:19:05 <Cale> and (>>=) :: Parser a -> (a -> Parser b) -> Parser b is similar, but it lets you use the result of the first parser to determine what the second parser is
19:19:28 <ski> @type Data.IORef.modifyIORef
19:19:29 <lambdabot> forall a. GHC.IORef.IORef a -> (a -> a) -> IO ()
19:19:35 <Behi> but wouldn't that mean that name is no longer immutable?
19:19:38 <Cale> (Is that clear? I could explain it in more detail)
19:19:58 <Cale> Behi: We produce a new map of values.
19:20:03 <ski> Behi : no, the contents of the mutable cell is replaced by a new contents, just as in e.g. Java
19:20:07 <Cale> Behi: which is different from some initial map
19:20:09 <darkf> Cale: It looks like it returns a function of type a and returns ... blah, please do.
19:20:19 <Cale> Behi: if we want to do things using immutable structures
19:20:34 <hpaste> bd_ pasted “Using GADTs to encapsulate equality (for PatrickRobotham)” at http://hpaste.org/54946
19:20:40 <bd_> PatrickRobotham: would that work for you?
19:20:52 <bd_> it does carry some overhead, note (you could put it outside the list to minimize this of course)
19:20:56 <tomprince> darkf: (Parser a) -> (a -> (Parser b) -> (Parser a)
19:20:58 <Cale> darkf: In x >>= f, the x is a Parser a, which eats some initial portion of the string, and produces a result of type a
19:21:06 <NemesisD> anyone ever used pool or resource-pool in a project?
19:21:06 <ski> Behi : you could alternatively, as Cale is suggesting, use an immutable list/map, and replace the whole list/map value by a new one
19:21:06 <tomprince> should be darkf: (Parser a) -> (a -> (Parser b)) -> (Parser a)
19:21:21 <Cale> and the f is a function a -> Parser b, which takes the result of the first parser, and produces a parser for parsing the rest of the input
19:21:34 <darkf> Cale: ah, nice.
19:22:02 <Cale> darkf: and then in terms of these primitives, we get a whole library of useful parser-combining operations from Control.Monad
19:22:13 <darkf> Cale: :D
19:22:31 <Cale> for example,  sequence :: [Parser a] -> Parser [a] will take a list of parsers, and combine them together into a single parser with a list of results.
19:22:46 <darkf> Cale: Thank you, very much! You seem to get it, unlike these other people.
19:22:47 <Cale> and we get that for free for implementing return and >>=
19:23:20 <Cale> Well, everyone gets it in their own way, but I've spent a lot of time figuring out how to explain it to beginners too :)
19:23:26 <darkf> :D
19:23:42 <darkf> It makes much more sense now, so you did a good job :)
19:23:42 <ski> darkf : i suspect that it's more that Cale is often pretty good at *explaining* (rather than getting it oneself, which is easier) :)
19:23:46 <Axman6> darkf: an example I used just yesterday was to use the function replicateM to parse a list of 10 numbers: I start with a parser than can aprse a single number, and then I use replicateM :: Int -> m a -> m [a] to say replicateM 10 num, and I get back a list of 10 numbers from the input string
19:24:01 <Axman6> you can also use replicateM in IO to do something n times
19:24:07 <darkf> ski: no, I just think you guys are annoying trying to intentionally be vague and brush off questions.
19:24:13 <darkf> whereas he actually attempts to explain things
19:24:15 <Axman6> crap, I just realised I've been using forM_ to do exactly that XD
19:24:26 <shachaf> darkf: Did you read the FAQ entry on this particular question?
19:24:36 <darkf> Axman6: that's pretty cool.
19:24:42 <darkf> shachaf: are you still talking?
19:24:47 * shachaf sighs.
19:24:52 <shachaf> Why do I bother?
19:24:57 <Philippa> darkf: it's actually pretty difficult to explain well for most people, though I think a lot of people here are... collectively less than clever about it
19:25:05 <tomprince> darkf: Part of the problem was that too many people tried to answer at once.
19:25:11 <ski> darkf : i suspect that one problem is that a many of us is trying to answer the question you asked, not the question you wanted to ask
19:25:35 <Philippa> it's hard to have a 1 <-> many conversation effectively
19:25:38 <darkf> Philippa: Indeed, I see that. I'm glad some of you have the ability to articulate explanations of things :-)
19:25:52 <darkf> ski: Sure, that's the problem I have with the Haskell community, say.
19:26:06 <ddarius> shachaf: That's the attitude.
19:26:12 <mauke> darkf: you're not the one trying to help
19:26:17 <mauke> you're the one with the question
19:26:18 <ddarius> shachaf: Look at me.  I didn't bother and I'm not annoyed at all.
19:26:42 * shachaf could probably learn a thing or two from ddarius.
19:26:44 <Philippa> ddarius: nor were you annoying anyone!
19:26:44 <Axman6> :t foldM
19:26:45 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
19:26:56 <tomprince> darkf: You also seemed to be brushing off all the answers you were given.
19:26:58 <Axman6> hmmm
19:27:07 <Axman6> I need a mix between foldM and replicateM
19:27:21 <NemesisD> ddarius: ah there you are. i was wondering if i could pick your brain about connection pooling. i was curious why you preferred 'pool' over 'resource-pool' since pool provides no blockinng in the api
19:27:23 <mauke> <darkf> if you can't deliver that, I didn't ask for your "help"
19:27:24 <ski> (darkf : anyway, i might have tried explaining more fully, but then Cale chimed in and .. :)
19:27:30 <vrook> foldl' f i xs = foldr (flip f) i (reverse xs) -- is this how Data.List.foldl' is defined?
19:27:32 <darkf> tomprince: because they were the opposite direction of what I seek ;)
19:27:38 <mauke> ^ I read that as "if you don't give me answers I like, you can fuck off"
19:27:47 <Axman6> vrook: definitely not
19:27:48 <darkf> mauke: that is as was intended, yes.
19:27:50 <Axman6> @src foldl'
19:27:51 <lambdabot> foldl' f a []     = a
19:27:51 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:27:53 <darkf> ski: thank you anyway :-)
19:27:55 <Philippa> darkf: it's better to explain to people why they're in the wrong direction
19:28:00 <mauke> darkf: well, then fuck you too
19:28:04 <Philippa> better: pick *one* first
19:28:18 <Philippa> tell everyone else you don't have the bandwidth for all at once
19:28:26 <darkf> Philippa: I tried. I said I wanted to learn what they are so that I can use them etc, that's the best I can do :)
19:28:27 <Philippa> the hive mind has too many echoes
19:28:31 <darkf> mauke: love you too man
19:28:51 <bd_> But it's so easy - a monad is just a functor with a join operation, right? Simple! ;)
19:28:54 <bd_> *hides*
19:28:58 <djahandarie> (Though the hive mind should have realized that no one has bandwidth for the hive mind and shut up. :))
19:28:58 <tomprince> darkf: You aren't the first person to ask about monads here, so even if the answers don't look like exactly what you want doesn't mean they aren't useful.
19:29:01 <bd_> oh, also a unit operation. can't forget that.
19:29:02 <darkf> bd_: :3
19:29:07 <vrook> is there a ghci command to query function source, as lambdabot does?
19:29:13 <Philippa> darkf: yeah. I have a pretty good somewhat concrete answer for what monads-in-haskell are (I won't speak for monads more generally). It seems to run contrary to current chan dogma
19:29:15 <copumpkin> darkf: I think the issue is that many people here get frustrated with people who try to learn monads prematurely due to all the hype, then fail, then give up on haskell because they think they need to understand something that they really don't have to understand to do basic things like IO
19:29:20 <Philippa> but I used to take a while and expect to
19:29:23 <Nisstyre> vrook: :info I think
19:29:23 <copumpkin> darkf: your attitude didn't help, either
19:29:26 <bd_> vrook: no, but you can hit :i to describe datatypes and typeclasses
19:29:32 <ski> @quote category.of.endo
19:29:32 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
19:29:33 <darkf> copumpkin: Sure, that makes sense.
19:29:40 <Nisstyre> oh right :info doesn't give the full source
19:29:48 <bd_> vrook: :i will also give the module for functions
19:29:48 <Cale> bd_: A *pointed* functor with a join operation.
19:29:48 <darkf> Philippa: Dogma is bad :-)
19:29:56 <copumpkin> darkf: many of us have been around here for years and see dozens of people coming here (and on mailing lists and reddit) asking about monads just because of all the hype
19:29:57 <bd_> Cale: Hm. What's the difference? :)
19:30:02 <mauke> bd_: return
19:30:03 <copumpkin> darkf: and it contributes to the hype
19:30:05 <Cale> bd_: You can't get return for free
19:30:09 <copumpkin> darkf: unwarranted hype :)
19:30:11 <Philippa> darkf: the dogma/karma intersection suffices
19:30:14 <bd_> mauke: right, I mentioned that shortly after
19:30:14 <donri> vrook: you could set up hoogle inside ghci and use the -l option to get a link to the haddocks which has a source link
19:30:17 <bd_> 22:53 < bd_> oh, also a unit operation. can't forget that.
19:30:23 <Cale> ah, missed that
19:30:27 <Philippa> copumpkin: worse - mostly-warranted-but hype
19:30:29 <Cale> yeah
19:30:47 <copumpkin> well, in the sense that people think they're necessary for haskell or something
19:30:50 <Philippa> my own programming style is intensely... well, not just monadic but monads are one of the more usefully-general forms
19:30:52 <copumpkin> monads are an observation
19:30:55 <copumpkin> not a necessity
19:31:04 <bd_> Didn't Haskell 1.3 use lazy lists for IO?
19:31:05 <darkf> copumpkin: That's unfortunate, but I believe you would have less of these people if there were an article or two explaining monads /in english/ instead of "lol, let me just give you the type signature for (>>=) and return, here, you figure it out yourself."
19:31:13 <Philippa> *nod*. They're a form, as in formalism
19:31:16 <ddarius> NemesisD: I use resource-pool, not pool.
19:31:17 <mauke> darkf: explaining them how?
19:31:21 <copumpkin> darkf: part of the hype is the dozens of articles doing just that
19:31:23 <mauke> darkf: how would you explain monads?
19:31:27 <darkf> mauke: In clear words, instead of abstractions.
19:31:30 <copumpkin> darkf: there are way too many shitty monad tutorials out there
19:31:30 <Philippa> darkf: hahahahaha
19:31:31 <Cale> bd_: I'm not sure if 1.3, but some older versions, certainly 1.0 did.
19:31:33 <darkf> mauke: If I understood monads, I would explain them fine, bro.
19:31:38 <copumpkin> darkf: with analogies all over the place
19:31:40 <darkf> Philippa: sup?
19:31:41 <mauke> darkf: monads are an abstraction
19:31:41 <tomprince> darkf: There are, but they tend to get lost in the noise of all the bad articles.
19:31:54 <Nisstyre> darkf: http://youtu.be/wMFPe-DwULM
19:31:58 <darkf> mauke: then explain the abstraction and *why* it's useful as an abstraction
19:32:04 <darkf> don't just go "herp, here's an abstraction, deal with it."
19:32:08 <Philippa> darkf: sorry, they're actually an absolute bastard to explain like that and have a concrete explanation. The only one that works IME is that they're a skeleton for an embedded language with particular properties
19:32:09 <mauke> darkf: why?
19:32:11 <darkf> that's insanely unuseful
19:32:13 <copumpkin> darkf: no, we're worried about that! half of those shitty tutorials are people who learned haskell last week, decided to learn monads this week, then next week think they get it and compare the monad to a burrito and how it's awesome
19:32:24 <mauke> darkf: no one said monads were useful
19:32:27 <Cale> darkf: You're right, examples are kinda necessary to really get the point.
19:32:28 <Philippa> that ends up needing a lot of padding out
19:32:30 <bd_> darkf: personally I'm of the opinion that the functor/join/return construction is significantly less damaging than giving people (>>=) and return. But it's still pretty bad if you just hand them the definition and laws and leave them on their own :)
19:32:32 <Nisstyre> darkf: listen to Richard Feynman. You need a "framework of understanding"
19:32:34 <Philippa> mauke: I rather think I implied it
19:32:38 <darkf> Cale: that's why I enjoyed yours.
19:32:40 <Philippa> Nisstyre: yes!
19:32:41 <Nisstyre> you can't learn by analogies that don't work
19:32:41 <Cale> Recognising the monad abstraction *is* useful
19:32:43 <reltuk> just link like the monad tutorial fallacy and move on :-P
19:32:47 <Philippa> and they're a bugger to communicate
19:32:47 <NemesisD> ddarius: ahhh ok. yeah it seems nicer
19:32:57 <Cale> But not *that* useful, it just saves some time, and gives us some common notation.
19:33:11 <Cale> Monads are not a big deal, really. :)
19:33:33 <NemesisD> ddarius: though i don't really understand stripes. it says it will block if a single stripe is exhausted even if other stripes have idle resources
19:33:37 <Nisstyre> Philippa: I think that's why a lot of explanations fail
19:33:45 <Nisstyre> because they try to make analogies that break down
19:33:47 <darkf> copumpkin: that's one reason I'd like to understand them more (besides being an ogler of type systems) -- I want to find ways to explain them where anyone can, because there are very much none
19:33:50 <fullofcars> I just don't like using monads for state / side-effects
19:34:02 <tomprince> darkf: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
19:34:11 <copumpkin> darkf: I think part of the issue is that they're an abstraction at a level that most programmers are not used to dealing with
19:34:16 <fullofcars> but they are great for other, less prevasive things
19:34:23 <Philippa> Cale: well, they're not useful if you stay with just monads. If you treat them with the same abandon as you might objects, that's different IME
19:34:25 <Cale> darkf: Once you get it, don't immediately go out and write a tutorial. Or if you do, don't immediately put it on the web :)
19:34:27 <darkf> copumpkin: Then explain it that way :-)
19:34:28 <copumpkin> darkf: so you can't really compare them to a _thing_
19:34:41 <Philippa> Cale: Or tag it "free lulz"
19:34:41 <darkf> Cale: I won't :-) I'll make sure I actually somewhat understand them
19:34:46 <Cale> Everyone does that, and usually the results are... not wonderful :)
19:34:48 <darkf> Philippa: you're free lulz!
19:34:55 <darkf> actually, this channel is.
19:34:58 <darkf> you're all hilarious <3
19:35:06 <Philippa> mmm. Sometimes we even aim to be
19:35:23 <darkf> I love people who try to act smart, they're cute :3
19:35:34 <Cale> A lot of the people here really are smart though.
19:35:47 <fullofcars> you have to be smarter than me to use haskell
19:35:50 <darkf> Cale: that doesn't make them any less socially competent, though. :-)
19:35:58 <darkf> fullofcars: me as well. I much prefer the ML styles
19:35:59 <fullofcars> honestly, I'm just too dim
19:35:59 <ski> fullofcars : imo, every monad corresponds to a side-effect
19:36:03 * ddarius subtly reminds copumpkin of earlier conversations he's had with copumpkin.
19:36:03 <Philippa> darkf: yeah, 'swhy I don't bother
19:36:04 <NemesisD> ddarius: do i want to keep a stripe count of 1 and then set the resources/stripe to my desired pool size?
19:36:10 <copumpkin> ddarius: I'm done :)
19:36:14 <Philippa> ski: what's the "side" in the identity monad? :p
19:36:17 <Nisstyre> Philippa: you would like this: http://youtu.be/n8m7lFQ3njk
19:36:22 <Philippa> ("degenerate")
19:36:23 <ddarius> NemesisD: Probably.
19:36:36 <darkf> copumpkin: ohoho, what conversations? did you degenerate into cybersex convos~?
19:36:38 <Cale> Yeah, it's possible to regard each *Haskell* monad as a type of computational effect.
19:36:39 <bd_> ski: What's the side-effect for List or Cont?
19:36:52 <ski> Philippa : cf. the null GC, the identity translation on `|R^2', &c.
19:36:54 <shachaf> Philippa: The identity effect!
19:36:57 <Philippa> Nisstyre: possibly. I'm rather picky about lecture-style videos
19:36:57 <Cale> But... that's more of a definition of "effect" than a consequence of what monads are. :)
19:37:02 <Nisstyre> Philippa: he's funny
19:37:08 <shachaf> For [] it's non-determinism.
19:37:11 <Nisstyre> it's not a typical lecture
19:37:15 <Philippa> *nod*. I'd rather a transcript though
19:37:21 <fullofcars> but anyway, the truth is that this stuff is infuriating to learn, and by sticking to ML, we can at least put it off till later :)
19:37:22 <ski> bd_ : for lists, the effect is (angelic) nondeterminism, for `Cont', it's continuation effects
19:37:24 <copumpkin> darkf: about dealing with people on the internet :)
19:37:25 <Nisstyre> there's a visual component though
19:37:25 <Philippa> tl;dr is one thing: tl;dw is much stronger for me
19:37:29 <Nisstyre> he uses an overhead
19:37:30 <fullofcars> that is, until F# gets type classes :)
19:37:40 <bd_> ski: I'm not sure I'd call those 'side-effects', but to each their own definition I guess
19:37:53 <Nisstyre> Philippa: anyway, it's just more stuff about analogies
19:37:53 <Cale> fullofcars: What's infuriating to learn?
19:37:54 <darkf> fullofcars: so do you understand monads in F# land?
19:37:56 <Nisstyre> and learning
19:38:03 <Cale> fullofcars: I might be able to help :)
19:38:06 <fullofcars> monads, et al
19:38:14 <Cale> ah, did you read my explanation just now?
19:38:22 <ski> bd_ : with continuation side-effects, you can write a function `argfc :: () -> a -> a', such that calling `map (argfc ()) [0,1,2,3]' will give `[0,0,0,0]' (assuming left-to-right evalaution)
19:38:22 <darkf> fullofcars: because as I understand it, F# has do! notation :D
19:38:27 <Philippa> Nisstyre: yeah. FWIW, my language comment was something that specifically isn't an analogy. It's got rather stronger mathematical backing than that
19:38:28 <fullofcars> no, I actually understand them well enough already, but I remember how painful it was to learn
19:38:34 <Cale> oh, okay :)
19:38:41 <fullofcars> so if someone is frustrated, I understand why
19:38:50 <darkf> fullofcars: then do explain~
19:39:03 <ski> bd_ : do you think exceptions are side-effects ? how about environment ? nondeterminacy ?
19:39:11 <Nisstyre> Philippa: someone told me that category theory is about making analogies in a precise way
19:39:15 <fullofcars> heh, I don't yet understand it well enough to explain it :)
19:39:23 <darkf> fullofcars: aw, alright :D
19:39:29 <Nisstyre> but that's probably a poor analogy
19:39:46 <fullofcars> I just sort of get by :)
19:39:48 <Philippa> Nisstyre: heh. Yeah, I sometimes describe it as the maths of analogy
19:40:03 <Philippa> especially the foo:bar::baz:quux question
19:40:14 <bd_> ski: I assume you mean mapM_ :) But I see your point. Monads do tend to have non-local effects - I'd accept Cont into that, but List's (and Maybe's) nondeterminism is local in nature *shrug*
19:40:14 <darkf> foo::foo
19:40:25 <bd_> I guess 'side-effects' is an ill-defined term
19:40:45 <fullofcars> I suppose I would recommened the Type Classopedia to learn this stuff
19:40:48 * monochrom uses this definition: a side-effect is what an Applicative does.
19:41:02 <fullofcars> then study various thing and let is sink in for a few months
19:41:10 <Cale> bd_: Yeah, it's defined more via monads than without :)
19:41:20 <Philippa> monochrom: I'd say applicative functor rather than Applicative. Spot the nitpick?
19:41:31 <Cale> But even then, monads are not the be-all and end-all of such definitions.
19:41:58 <darkf> Cale: so, what were monads brought into functional programming land for? what problem do they solve? :D
19:42:00 <Philippa> (I'm also not convinced that "also has a static analysis" is a side-effect)
19:42:13 <darkf> Cale: *why were
19:42:22 <Cale> darkf: They abstract over a common pattern in libraries written in a traditional style.
19:42:24 <ski> bd_ : one general indication that the expression `E' has side effects is that one of the following equalities fail : (a) copyability `(E,E) = (let x = E in (x,x))'; (b) discardability `() = (let _ = E in ())'; (c) commutativity `(let x = E in let x2 = E2 in (x,x2)) = (let x2 = E2 in let x = E in (x,x2))' (for any other expression `E2')
19:42:32 <Philippa> darkf: they came via denotational semantics, which is "really" specifying language semantics via a functional interpreter
19:42:37 <vrook> I would plug Hutton's "Programming in Haskell" which introduces monads via making a parser without telling you they're monads.
19:42:48 <darkf> vrook: sounds like fun!
19:42:53 <ski> bd_ : i didn't have `mapM_' in mind at all no
19:42:58 <darkf> Cale: ah :-)
19:43:11 <fullofcars> darkf - they allow you to specify a common interfaces to multiple libraries
19:43:14 <bd_> ski: ah, yes, List would violate discardability and commutativity, I suppose.
19:43:14 <Cale> darkf: It's common in functional programming to write libraries which look like small programming languages, with primitives, and combining operations defined by the library, and a means of abstraction which is usually borrowed from the host language.
19:43:16 <Philippa> darkf: it was noticed that you could add "language features" via them, which also looks a lot like that traditional style
19:43:19 <ski> bd_ : can you explain in more detail what you mean by "non-local effects" ?
19:43:32 <Cale> darkf: Many such "combinator libraries" have the right shape to contain an instance of Monad.
19:43:37 <darkf> Cale: what about combinators?
19:43:42 <ski> bd_ : and copyability :)
19:43:44 <darkf> Cale: don't they do the same thing?
19:43:51 <fullofcars> it's just an abstraction facility
19:43:51 <bd_> ski: indeed
19:43:58 <Cale> darkf: Well, (>>=) is "a combinator" in the sense that we're using it
19:44:02 <Philippa> Cale: did you see my mishap recently with what turned out to be a relative monad rather than a monad because I missed an instance out somewhere?
19:44:11 <fullofcars> you can remove lots of code duplication with them too
19:44:11 <edwardk> darkf: monads were introduced in haskell originally to provide a coherent story for how to deal with side-effects in a world where everything is lazily evaluated. They replaced a couple of other approaches one based on lazy streams of requests and responses and one based on continuation passing style. Along the way people realized there were lots of other things you could use the same
19:44:11 <edwardk>  trick to encode. so lists, trees, logging, adding environment, state, etc all became monadic as well
19:44:31 <Cale> It's a particularly-shaped combinator, which if such a thing occurs in a library, we automatically can write lots of useful things in terms of it.
19:44:41 <Cale> Philippa: I don't think I did
19:44:43 <darkf> edwardk: awesome, thanks! I only really see CPS used in scheme
19:44:46 <Philippa> and there are other combinators that're related to it
19:44:57 <fullofcars> so all these things are just a way to cut down further on duplication - just like any good language facility
19:45:00 <edwardk> darkf: monads are just a pair of combinators that have 3 laws, which happen to crop up over and over again for some very fundamental reasons
19:45:06 <ddarius> CPS would be one of the craziest languages to use CPS in.
19:45:09 <Cale> edwardk: This is one case where the fake history is more coherent than the real one ;)
19:45:12 <ddarius> s/CPS/Scheme/
19:45:14 <Philippa> darkf: CPS is pretty common in haskell, but it's better to abstract behind a monad or monads as the code grows
19:45:20 <darkf> ddarius: it is used, though :D
19:45:41 <darkf> ddarius: I've seen some people doing CPS in javascript
19:45:45 <darkf> lord knows why
19:45:47 <bd_> darkf: node.js?
19:45:50 <Philippa> Cale: I built a monad-like-thing for constraint programming, restricted to a typeclass that did metavariable substitution
19:45:51 <ddarius> darkf: Javascript doesn't have call/cc.
19:45:55 <darkf> bd_: nope, he was writing a parser
19:45:56 <edwardk> darkf: i built a whole javascript -> javascript compiler just to CPS it ;)
19:45:59 <bd_> darkf: you don't need call/cc to do CPS
19:46:02 <darkf> ddarius: which you don't specifically *need* for CPS
19:46:07 <Philippa> Cale: it's on my blog @ flippac.wordpress.com, not much there not related to it at the moment
19:46:09 <ski> darkf : the point of having `call-with-current-continuation' in Scheme is so that you *don't* have to write in CPS :)
19:46:24 <Philippa> ski: until it turns out it's not sufficient, anyway?
19:46:29 <ddarius> darkf: You have it completely backwards.  CPS is a way of providing call/cc.  With call/cc you have no -need- for CPS.
19:46:40 <ski> Philippa : well, that's nqCPS
19:46:45 <darkf> ski: which isn't my area anyway :) the only thing I can write with call/cc is a `return` style function with (call/cc (lambda (return) (return 5)))
19:47:09 <vrook> scheme is implicitly CPS, you just can't see the parameter.
19:47:31 <fullofcars> vrook, head asplode
19:47:32 <ski> darkf : you can implement iterators,generators, coroutines, cooperative multi-tasking, backtracking with continuations
19:47:33 <Philippa> ski: there're CPS transforms for delimited continuations in the absence of a mutable cell, IIRC?
19:47:42 <fullofcars> you just blew up my whole mind
19:47:45 <darkf> ski: that's why I'd love to understand those as well!
19:47:52 <ski> darkf : in fact, if you have continuations and state, you can turn *any* monad into an implicit side-effect
19:48:00 <ddarius> Philippa: Just double CPS.
19:48:01 <darkf> ski: unfortunately I see precious few examples of using them for awesomesauce
19:48:12 <ddarius> Or you can have non-tail calls in your CPS.
19:48:23 <Philippa> ddarius: ah, fair enough. Last time I skimmed through it was a sloppy usage, then
19:49:17 <ski> darkf : imagine writing in Scheme `(let ((expr0 (parse-expression)) (_ (parse-plus)) (expr1 (parse-expression))) (make-addition expr0 expr1))', including backtracking the parsing if something doesn't work
19:49:55 <shachaf> Why double-CPS when you can take the fixed point of CPS?
19:50:20 <ddarius> Because 2 is all you need.
19:50:27 <darkf> ski: fun -- so how do you backtrack? if the parse fails, call the continuation?
19:50:29 <ski> Philippa : in fact, if you do the double CPS, and look closely at it, you'll see that the other continuation is passed around like a state, which motivates using primitive state to implement it :)
19:50:39 <ddarius> But you could, actually, have an infinitely iterated CPS transform.
19:50:51 * BMeph thinks Io is made of CPS-imprired awesomeness!
19:51:00 <darkf> Io is made of sex
19:51:10 * BMeph meant "CPS-inspired"
19:51:21 <ski> darkf : yes, each time there might be multiple ways to parse, you store a continuation that points to the next possible way (called a "choice-point"), and try the first one. if anything fails, you jump back to the last choice-point
19:51:32 <ski> darkf : the same idea is used in Prolog, btw
19:51:38 <darkf> ski: that's awesome! :D
19:51:50 <Philippa> BMeph: but mixed it with CPS-impaired?
19:52:02 <BMeph> darkf: Naugh, that's Ganymede. Ganymede is all about "the ol' in-out, in-out". ;þ
19:52:16 <ski> @where Io
19:52:17 <lambdabot> Raphael Finkel's language with continuations as fundamental structure, described in chapter 2 of his book `APLD', implementation `Amalthea'
19:52:21 <ski> BMeph : that one ^ ?
19:52:52 <ski> @where APLD
19:52:52 <lambdabot> "Advanced Programming Language Design" by Raphael Finkel in 1996 at <http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/>
19:53:30 <ski> ddarius : *nod*, which is often known as nqCPS
19:53:47 <BMeph> ski: Exactly. I'm working on a translation of the Amalthea code. :)
19:54:39 <BMeph> Philippa: More like "CPS-infused". ;)
19:55:25 <Philippa> aka CPS-cocoinfused?
19:55:38 <ski> (fyi, the language Io doesn't have functions, it just have continuations. to implement the functionality of a function, you define a continuation which takes a "return" continuation as argument. naturally you can take as many as you like)
19:56:24 <ski> (so, in a sense, the single type constructor is an "NAND" one)
19:56:42 <ddarius> A ⇒ B ≡ ¬(A∧¬B)
19:57:13 <Axman6> putty, Y U NO UTF-8 :(
19:57:19 <Axman6> even when I tell you to
19:57:36 <monochrom> two things: set it to utf-8, and need fonts
19:57:55 <BMeph> MOAR FONTS pl0x, kthxbai
19:57:58 <monochrom> the monospace fonts on windows are very limited.
19:58:21 <Nisstyre> Andale Mono > *
19:58:24 <BMeph> ... fonts on windows are very limited.
19:58:39 <xplat> and monospace fonts are very limited.
19:58:42 <Axman6> I installed Annonymous Pro, which works fine on my Mac, but it could be that OS X substitutes characters that are missing from fonts
19:58:49 <BMeph> ... windows are very limited.
19:58:49 <Nisstyre> monospace fonts are easier to read
19:59:30 <xplat> they're pretty much essential on terminals
19:59:48 <mauke> hmm, I'm missing some amharic characters
19:59:53 <vrook> Does reverse strictify a list?
19:59:55 <mauke> but I can see kannada now!
20:00:04 <mauke> vrook: only the spine
20:00:05 <Axman6> vrook: only the spine, not the elements
20:00:10 <ski> vrook : it forces the spine of the list, yes
20:00:17 <vrook> k thanks
20:00:28 <Axman6> > head $ reverse [undefined, undefined,1]
20:00:29 <lambdabot>   1
20:00:31 <xplat> but it's a matter of 'pick any 1' -- good CJK space coverage, good non-CJK unicode coverage, ascii subset doesn't look like ass
20:01:00 <monochrom> I reckon that most people go for the last one, ascii subset appearance
20:01:19 <monochrom> I myself couldn't care less
20:01:21 <ddarius> I would think most go for the first.
20:01:30 <vrook> foldl' f i xs = foldr (flip f) i (reverse xs) -- so for instance this will run in constant space (I know it's hacky)?
20:01:31 <xplat> font substitution helps some, but the frankenstein effect is even worse with monospace than proportional fonts
20:01:38 <ddarius> Maybe the second.
20:02:10 <copumpkin> @hoogle ByteString -> String
20:02:11 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
20:02:11 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
20:02:11 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
20:02:14 * BMeph goes for the second. Right after he goes for the eyes...
20:02:17 <monochrom> I use proportional fonts for irc
20:02:38 <xplat> i would, but irssi runs in a terminal
20:03:50 <xplat> somebody needs to invent a nice equivalent of a terminal for proportional fonts.  sadly, a web browser is *so* not it.
20:03:51 <monochrom> mainly because it's more compact
20:04:38 * ski won't use proportional, unless there's an easy way to align stuff
20:05:40 <Axman6> vrook: I'm poretty damn sure that will not run in constant space, reverse uses O(n) space before it returns any result
20:05:43 <monochrom> 15 years ago, monospace for irc would be wise, because people pasted multi-line code or multi-line ascii art, and you would want them to align.
20:05:50 <monochrom> today, who cares.
20:06:17 * ski , obviously :)
20:06:30 <russellw> Personally I think one of the benefits of proportional fonts for code is that it discourages attempts to make things align, which is a maintenance nightmare in any case :)
20:06:45 <xplat> but how can you confuse everyone with a 5-letter name beginning with d if they end up different widths?  :)
20:06:48 <monochrom> today, you would even set up channel-guarding bots to ban multi-line pastes. they are spam.
20:07:50 <ski> monochrom : i don't think it would be so easy to do for ones typed in real-time
20:08:17 <Axman6> russellw: it's also quite important in haskell :P
20:08:35 <russellw> Axman6, how/why?
20:08:40 <xplat> ski: presumably you don't care how they're produced, just how fast
20:08:48 <Axman6> because Haskell is indentation sensitive?
20:08:59 <monochrom> sure. the bots catch the too-fast-to-be-by-hand category.
20:09:01 <xplat> if someone types that fast, kick them anyway
20:09:30 <monochrom> as for spams typed by hand, slow enough to be handled by human ops.
20:09:35 <shachaf> The wonders of modern technology!
20:10:04 <russellw> Axman6, Sure, but what of it? A tab (or four spaces if you lean that way) is always the same width even if you use a proportional font. I haven't written more than a few lines of Haskell yet, but I've written a nontrivial amount of Python and F# in proportional fonts, worked fine
20:10:12 <ski> xplat : well, i semi-regularly type multi-line stuff in real-time (not overly long, though)
20:10:42 <shachaf> If tabs were sane, maybe proportional fonts for code would approach sanity.
20:10:43 <shachaf> Maybe.
20:10:57 <xplat> if you spam automatically, we'll kick you automatically, but if you're polite enough to take the time to spam by hand, we'll also ban you by hand?  :)
20:11:06 <russellw> shachaf, what problems do you have with tabs?
20:11:15 <xplat> i suppose that's a sane policy
20:11:21 <ski> if you use tabs for layout in Haskell, you should break line after each layout-introducing keyword
20:11:36 <shachaf> Let's not get into a discussion about tabs. :-)
20:11:47 <Nisstyre> I use 4 spaces
20:11:53 <ski> shachaf : too late
20:11:53 <monochrom> russellw: consider "f x | x>0 = 0" on one line and "| x<0 = 1" on the next line and align the |'s.
20:12:03 <shachaf> ski: :-(
20:12:29 <xplat> ski: if you code haskell in proportional fonts, you should use an IDE that tabs to layout-introducing keywords, and saves in fixed-width space-based format
20:12:31 <monochrom> if you don't write that way, sure, "4 spaces is always the same length" suffices for you
20:12:51 <russellw> oh! Well of course that wouldn't work. What I did in F# - and would do regardless of what font I was using and whether spaces or tabs - would be to put every | including the first, on a separate line. Doesn't that work in Haskell?
20:13:16 <ski> xplat : i count that as not using tabs :)
20:13:30 <monochrom> yes that works. a draconian restriction to me, but sure, you are welcome to restrict yourself
20:13:50 * BMeph types that way "naturally", FSVO that.
20:14:01 <shachaf> Just use {}; syntax.
20:14:07 <russellw> But isn't the other way an endless maintenance nightmare? Every time you rename something to a name of a different length, don't you have to go in and realign things?
20:14:15 <xplat> came out of the womb with a silver USB keyboard in your mouth?
20:14:23 <Nisstyre> russellw: yes
20:14:25 <ski> russellw : it works (and is what i usually do). note that the `|' doesn't have to be aligned though, i just do it for prettiness
20:15:24 <ski> russellw : i don't really think about it
20:15:25 <xplat> as a pedant, that is the only value of 'naturally' i will accept for typing :)
20:15:28 <monochrom> I don't rename too often. when I rename and it affects indentation, I don't have tons of lines to realign too often.
20:16:07 <russellw> Fair enough, different tastes. Me, I don't mind restrictions on things that don't matter - I get a headache when I have to make a Buridan decision, i.e. one where both options are equally good, so there is no objective basis for making it
20:16:21 <russellw> Restrictions that make those kind of decisions for me can be good things :)
20:16:22 <BMeph> xplat: I'm old school; DP-5 4 Life! ;þ
20:16:33 <xplat> russellw: you should carry around a coin!
20:16:48 <shachaf> Mmm, a burritoän decision.
20:16:50 <monochrom> if I have like 10 lines of "| condition = blah"s in tandem, I put them all on their own lines for stable indentation, sure. but how often do I have like 10 of them?
20:16:59 <ski> xplat : but what if the coin shows the WRONG answer !?
20:17:00 <xplat> russellw: although i guess if you think about it too hard which is heads and which is tails is another Buridan decision
20:17:23 <russellw> xplat, that only works for decisions I can't reverse once made. Source code is so _editable_ :P
20:17:56 <xplat> russellw: you need to work on the virtue of Laziness, i see :)
20:18:03 * ddarius doesn't understand why people pay Douglas Hofstadter.
20:18:07 <russellw> Yes, yes I do :)
20:19:06 * hackagebot yesod-core 0.9.3.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.3.6 (MichaelSnoyman)
20:19:40 <shachaf> @context ddarius
20:19:41 <lambdabot> Unknown command, try @list
20:19:49 <ski> ddarius : research or books or ?
20:20:01 <xplat> if you really want to fix something, there's more than enough that *is* broke
20:20:32 <dbelange_> broken
20:20:50 <BMeph> Doesn't "working" at Lazyness defeat its purpose? :)
20:20:52 <xplat> dbelange_: what did i *just* say?
20:21:59 <ddarius> ski: For any purpose whatsoever.
20:21:59 <dbelange_> something about perl
20:22:43 <xplat> BMeph: work on, not work at.  learning how to work on laziness without working at it is precisely how you achieve it
20:23:53 * ski has only read GEB, can't comment of whether Hofstadter should be payed for anything
20:24:38 <xplat> i've read some other Hofstatder, and none of it was as good as GEB
20:25:00 * ski vaguely recalls GEB as sortof boring, sortof interesting
20:25:02 <vrook> I Am a Strange Loop is very good, though the first part is basically GEB-lite.
20:25:12 <russellw> yeah, GEB is his masterpiece
20:25:19 <scshunt> ugh, hofstader :(
20:25:25 <tgeeky> ski: it's only boring if you read it in reverse
20:25:29 <Nisstyre> he hates people calling GEB his masterpiece
20:25:32 <ski> (i can't recall any part which i especially liked)
20:25:41 <shachaf> xplat: _The Mind's I_ was much better than GEB, although it was mostly not by Hofstadter.
20:25:42 <russellw> that's a pity
20:26:02 <ddarius> shachaf: Maybe that's the trick.
20:26:11 <shachaf> ddarius: I imagine it is.
20:26:14 <ddarius> Quality of book increases the less it's written by Hofstadter?
20:26:19 <endojelly> > ap (liftM . (!!)) (randomRIO . (,) 0 . (+ (-1)) . length) ["one","two","three"]
20:26:20 <Cale> There was a collection of articles by Hofstadter bound into a book, which one was that?
20:26:21 <lambdabot>   <IO [Char]>
20:26:28 <endojelly> can't I do IO in lambdabot?
20:26:30 <xplat> shachaf: i've read much of that, and without touching on the other parts, i didn't like the Hofstatder parts
20:26:38 <ski> tgeeky : heh, i assume that fails inconsistency because `sortof A' doesn't imply `A'
20:26:41 <shachaf> Cale: _Metamagical Themas_?
20:26:42 <Cale> endojelly: You can construct IO actions, but you can't run them.
20:26:48 <Cale> shachaf: yeah, that's it
20:26:55 <Cale> It had some interesting things in it
20:26:57 <Axman6> endojelly: no, but you don't need IO for that, just use mkStdRandom and randomR
20:27:02 <ski> @help run
20:27:02 <shachaf> xplat: I wasn't thinking of the Hofstadter parts. :-)
20:27:02 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
20:27:03 <byorgey> endojelly: you can do all the IO in lambdabot you like.  lambdabot just can't do IO in you.
20:27:05 <ski> endojelly ^
20:27:17 <endojelly> okay, thanks.
20:27:45 <xplat> shachaf: the non-Hofstadter parts seem irrelevant to the quality of Hofstadter
20:27:47 <endojelly> Axman6, no, I wanted to play around with IO
20:28:10 <shachaf> xplat: Well, it's mostly that his name was on the cover of the book.
20:30:33 <xplat> anyway, of course he hates when people call GEB his masterpiece.  there are bands that break up because the places they play empty out after they play That One Single too ...
20:30:59 <ddarius> So play it last.
20:31:05 <fullofcars> GEB?
20:31:26 <endojelly> so, yes, using Monad ((->) r) is pretty fantastic.
20:31:50 <xplat> _gödel, escher, bach: an eternal golden braid_
20:31:56 <Nisstyre> fullofcars: http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach
20:31:56 <fullofcars> ok
20:32:54 <morolin> I was a bigger fan of I Am A Strange Loop, out of Hofstadter.
20:33:03 <Cale> GEB is more interesting if you read it before you know all of the mathematics it discusses.
20:33:27 <morolin> Also a big fan of trying to remember how to spell his damn name.
20:33:35 <Cale> It will be a bit tedious if you read it afterward, though there's still a fair amount in it which should be amusing.
20:33:35 <xplat> most any popular book is, for an appropriate value of 'mathematics'
20:34:08 <monochrom> http://www.amazon.com/Learn-You-A-Haskell/dp/0465026567/ and http://www.amazon.com/Godel-Escher-Bach/dp/1593272839/ :)
20:34:32 <Nisstyre> monochrom: this would be a good thing to write in Haskell http://en.wikipedia.org/wiki/MU_puzzle
20:35:13 <vrook> Nisstyre: maybe you misread. the point of the puzzle is that it can't be solved.
20:35:31 <Nisstyre> vrook: no I understand. I meant the system in general.
20:35:43 <xplat> now compare _the emperor's new mind_, which has considerably more advanced and fascinating mathematical content than GEB (but in the same vein)
20:35:59 <vrook> oh my, emperor's new mind is woo.
20:36:05 <Nisstyre> xplat: Roger Penrose right?
20:36:14 <AfC> I'm reading that right now, actually
20:36:24 <xplat> unfortunately my enjoyment of the math was interrupted repeatedly by my involuntarily flinging the damn book into the wall
20:36:40 <ddarius> xplat: I can understand that.
20:36:41 <copumpkin> what happens if I write to a handle from multiple threads at once
20:36:47 <AfC> perhaps with less flinging, though
20:36:49 <copumpkin> ?
20:36:55 <ddarius> copumpkin: Try it and find out.
20:37:09 <AfC> copumpkin: there's a MVar down there, apparently.
20:37:15 <copumpkin> AfC: oh, good
20:37:31 <xplat> AfC: sounds like you've got poor reflexes, you should see someone about that :)
20:37:34 <AfC> copumpkin: (at least, that's the impression I got from reading Marlow's very recent parallelism and concurrency tutorial paper)
20:38:05 <vrook> emperor's new mind is woo obfuscated. Just replace "non-algorithmic" with "spirit" or "The Force" or whatever.
20:38:10 <AfC> xplat: yeah, I'm learning Haskell. That ought to snap me out of my inappropriate stupor.
20:38:29 <ddarius> xplat: I read "The Road to Reality" which is a pretty amazing book to write for as a "science popularization."  I strongly disagree with various fundamental facets of Penrose's beliefs.  Some in ways where I don't just disagree with him, but feel he is actively wrong and misleading.
20:39:18 <monochrom> http://hpaste.org/54939 is what happens when two threads write to stdout concurrently
20:39:23 <russellw> Well the Emperor's new mind is a very mixed bag. The parts about magic non-algorithmic super quantum gravity are woo, sure. On the other hand, the parts about real quantum mechanics and thermodynamics are very good
20:39:54 <xplat> russellw: yeah, in a way that doubles the frustration though
20:40:07 <ddarius> Going by "The Road to Reality," Roger Penrose's understanding of thermodynamics is seriously damaged, admittedly in a rather common way.
20:40:18 <Axman6> hpaste, why are you so slow?
20:41:12 * ski . o O ( bar induction )
20:41:27 <xplat> ddarius: it seems like all his fundamental errors are frighteningly common ones, despite the sophistication with which he dresses soem of them up
20:42:36 <ddarius> xplat: Well some are personal quirks.  His fascination with complex numbers is well-placed, but attributing physical significance to them in the way he does and to the extent he does is unpleasant and fairly unusual.
20:43:18 <Saizan> i wonder why we still keep thermodynamics around instead of going with the stuff that actually makes sense
20:43:40 <ddarius> Saizan: Thermodynamics makes sense.
20:43:44 <vrook> ddarius: I remember that. I kept thinking, Doesn't he know about the 2x2 matrix isomorphism with C?
20:43:58 <ddarius> vrook: That's not what he's missing.
20:44:06 * hackagebot Workflow 0.5.8.0 - library for transparent execution of interruptible computations  http://hackage.haskell.org/package/Workflow-0.5.8.0 (AlbertoCorona)
20:44:30 <ddarius> In fact, one way is to view what he is doing as -addressing- that.  Quite the opposite, he's missing doing "the same thing" to C.
20:45:30 <ddarius> Saizan: One notable thing about thermodynamics, and more generally, statistical mechanics, is that very little of it actually has to do with physics, which is why it's so generally applicable (including being applicable to physics.)
20:45:54 <xplat> ddarius: if you abstract away from complex numbers, it's a trait he shares with wolfram, archimedes plutonium, and a number of others.  but it's true, that's a much more elite company than he keeps in most of his other errors.
20:45:55 <ddarius> Saizan: I'll prescribed you some Jaynes.
20:46:25 <vrook> ddarius: is it about operator vs tensor representations?
20:46:29 <russellw> For example, the solution to Maxwells Demon is one of the most elegant and beautiful results in all of science, in my opinion
20:46:58 <ddarius> xplat: I was actually pointing out the specific fascination with complex numbers.
20:47:01 <Saizan> ddarius: statistical mechanics is the part that makes sense i was referring to, i think
20:47:11 <ski> "Probability Theory: The Logic of Science" by E. T. Jaynes
20:47:34 <ddarius> ski: That doesn't really cover the statistical mechanics stuff, but is a useful thing to read beforehand.
20:48:07 <ski> ddarius : what did you have in mind ?
20:48:18 <ddarius> Saizan: If you remove the statistical mechanics from thermodynamics, you have almost nothing remaining.  I mean you have conservation of energy, but not much more.
20:48:29 <xplat> russellw: one of the more fascinating things about thermodynamics is that unlike so many fields where the results come out better if you postulate your entities outside the system, thermodynamics works better when your entities are all on the inside
20:49:05 <russellw> ddarius, are you counting Liouville's theorem as part of statistical mechanics?
20:49:16 <Saizan> ddarius: as it was thaught to me you've some bad analogies about entropy and a plethora of stuff about heat machines
20:49:36 <russellw> xplat, not quite sure what you mean, what would be a pair of examples?
20:50:01 <ddarius> ski: I'd have to go through to find one of the better articles to start on, but things like "Information Theory and Statistical Mechanics I and II", "Predictive Statistical Mechanics", "The Evolution of Carnot's Principle", "The Gibbs Paradox"
20:50:06 <xplat> ddarius: well, you could have macroscopic thermodynamics where 'entropy' was a mysterious quantity and 'heat' was a mysterious form of energy, but it would be kind of silly to go back to that
20:50:21 <ddarius> Saizan: It's usually taught extremely poorly because the teachers were taught extremely poorly.
20:50:57 <xplat> but i guess we go back to that all the time in certain classrooms
20:50:58 <ddarius> Saizan: I recommend looking at "The Evolution of Carnot's Principle" as a start and some of Jaynes' other stuff.  It will be massively clearer and make a whole lot of sense.
20:51:31 <ddarius> russellw: Lioville's theorem isn't a part of statistical mechanics in my view.
20:52:05 <russellw> ddarius, me neither, whereas it is a very significant part of thermodynamics
20:52:22 <xplat> i can understand wanting to drill 'we can't build perpetual motion machines' into the heads of people who will never pass an intro stats course in case they become NASA bureaucrats somehow, but it doesn't seem to really work anyway
20:52:31 <ddarius> It's important -for- thermodynamics, but I don't consider it a result -of- thermodynamics.
20:53:28 <xplat> cf zero point energy
20:53:50 * Axman6 wonders when this channel will get back on topic
20:53:53 <russellw> hmm, okay, then I guess while we disagree on classification/terminology, we probably don't disagree on substance as much as it might have first seemed
20:54:39 <xplat> Axman6: when we tell copumpkin what happens when he writes to a handle from multiple threads
20:54:55 <ddarius> xplat: We did, but maybe we are just demonstrating now.
20:55:33 <xplat> the only detail i recall hearing is 'there's an MVar down there somewhere'
20:55:48 <ddarius> xplat: monochrom also referred to a paste.
20:56:15 <xplat> well i guess we're on topic then
20:56:34 * ski . o O ( "Thermodynamics and Garbage Collection" by Henry G. Baker in 1993 at <http://www.pipeline.com/~hbaker1/ThermoGC.html> )
20:56:40 <ddarius> Saizan: I also recommend "Clearing up Mysteries" by Jaynes as another area where he brings a massive amount of clarity.
20:57:35 <Saizan> i think most of clearing up mysteries went over my head
20:57:43 <ddarius> Really?
20:58:16 <Saizan> unless it was another by jaynes
20:58:22 <monochrom> thermodynamics and garbage collection are somewhat related because if you turn off GC (for example JHC did), you have reversible computing or pretty close to. GC destroys the reversibility.
20:59:48 <Saizan> ddarius: i could follow the text pretty well, but lots of the math/notation was quite opaque, i guess i'm not used to doing physics that way
21:00:34 <ddarius> If I remember correctly, it wasn't too crucial to follow the math unless you were worried that Jaynes was lying to you.
21:00:39 <xplat> monochrom: i am just too tired to correct that in detail, but haskell without GC is far from reversible
21:01:37 <kamatsu> hi all
21:01:38 <Saizan> yeah, though it's pretty unsatisfying to not be able to follow the steps
21:01:47 <kamatsu> wondering about generic programming library
21:01:55 <monochrom> alright, I believe you.
21:02:14 <kamatsu> I have an AST, but it includes in its type a parameter that specifies the type of identifier it uses
21:02:21 <ddarius> Saizan: His notation is pretty standard, but he does take very big steps in the examples.
21:02:25 <kamatsu> e.g AST Name, AST TypecheckedName
21:03:07 <kamatsu> I was wondering if, given a function from TypecheckedName->Name, there was an easy way using generic programming libraries to go from AST TypecheckedName to AST Name.
21:03:20 <kamatsu> otherwise I have to manually traverse an ugly AST
21:03:24 <ddarius> There are.
21:04:26 <Saizan> kamatsu: tried {-# LANGUAGE DeriveFunctor #-} ?
21:04:43 <kamatsu> saizan, the AST is the GHC API's
21:04:44 <kamatsu> not mine
21:05:04 <Saizan> there's StandaloneDeriving too :)
21:05:31 <kamatsu> I suppose I could try that
21:06:07 <Saizan> otherwise you can look at uniplate or syb, you'd want to derive instances for those too, but there's the derive package for uniplate
21:06:27 <kamatsu> it already has data and typeable instances
21:06:41 <kamatsu> uniplate I couldn't get to work
21:07:15 <kamatsu> uniplate's transformBi function essentially assumes that "transform f" will be a function from some type A -> A.
21:07:31 <kamatsu> i.e the changing type parameter throws it off
21:07:45 <ddarius> transformBi wouldn't be what you use for this.
21:08:16 <kamatsu> what would?
21:11:11 <Saizan> i thought syb exported a gmap, but anyhow you should be able to do this with everywhere, i think
21:11:16 <Saizan> ?type everywhere
21:11:19 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
21:11:53 <kamatsu> doesn't look like it
21:11:59 <kamatsu> a -> a
21:12:06 <kamatsu> this is F a -> F b
21:12:24 <Axman6> I don't suppose you can derive Functor?
21:12:32 <kamatsu> that's what i'm trying now
21:12:39 <kamatsu> i might have to write a few instances myself, but may be promising
21:13:26 <copumpkin> omg it's a kamatsu
21:13:40 <kamatsu> it's a copumpkin
21:13:46 * copumpkin hides
21:16:17 <kamatsu> ah crap
21:16:32 <Axman6> D:
21:16:38 <kamatsu> Haskell AST's type parameters are a little more complicated
21:16:57 <kamatsu> HSBinds a is just a synonym for HSBindsLR a a...
21:17:07 <kamatsu> so the real type is like "F a a -> F b b"
21:17:28 <kamatsu> i suppose i could put an instance on the synonym
21:17:32 <kamatsu> would that work?
21:18:17 <ski> no
21:18:36 <kamatsu> ski's right
21:18:37 <kamatsu> :(
21:18:50 <kamatsu> looks like i might have to traverse this after all
21:21:07 <ddarius> You could make a newtype and then use something else to derive Functor, assuming it is actually a functor.
21:21:26 <kamatsu> that's going to be a lot of newtypes
21:21:30 <Saizan> you could write your gmap :)
21:21:51 <kamatsu> this just seems much more complicated than it needs to be
21:21:59 <Saizan> mh, but even that would have the a a problem
21:22:08 <kamatsu> if the whole thing was *less* type safe i'd have an easier time
21:23:28 <kamatsu> perhaps I can wrap the whole thing in an existential type?
21:23:48 <kamatsu> then the type is, conveniently, Exists HsBinds -> Exists HsBinds
21:24:07 * hackagebot thumbnail 0.4 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.4 (KatsutoshiItoh)
21:26:32 <ddarius> kamatsu: To do what you wanted, you'd need to have, at least, a Typeable constraint on the existentially bound variable.
21:26:45 <kamatsu> ddarius, yeah, figured that
21:26:59 <ddarius> But at that point, you could then use something like a SYB gmap.
21:27:21 <kamatsu> right
21:27:24 <kamatsu> i'll see how i go
21:27:33 <ddarius> The problem, though, is to get your input into that form or get it out, you'd already need a Functor instance or something equivalent.
21:27:43 <kamatsu> why?
21:33:15 * DanBurton slowly goes insane as the question remains unanswered
21:33:38 <ddarius> Well, you could get in to that form easily enough I guess.  But to get out, you'd have an exists a. Typeable a => AST a and to get rid of the 'a' variable you'd need something that could turn all those 'a's into something concrete (or at least not using 'a'.)
21:33:50 <ddarius> Though maybe Typeable1 can save the day.
21:34:49 <Saizan> http://www.haskell.org/pipermail/generics/2008-July/000349.html <- too bad the links are dead
21:34:56 <kamatsu> this is getting very confusing
21:36:32 <ddarius> No it wouldn't.
21:37:20 <DanBurton> @google haskell upgrade yorgey peyton jones
21:37:25 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/
21:37:25 <lambdabot> Title: Simon Peyton Jones: papers
21:37:40 <DanBurton> promotion, that's it
21:41:05 <ddarius> kamatsu: It may just be easiest to write an Applicative (or possibly even Monad) instance by hand, which would immediately give you Functor and be useful for things like Multiplate and others, if you should still need them.  There are tools which derive things that may well be able to handle this example.
21:44:11 <kamatsu> the problem is it's not of kind *->*
21:46:09 <ddarius> That's where the newtype would come in (which is no more hassle than what you'd need to do for the existential).
21:52:42 <kamatsu> can't seem to derive a data instance of an existential anyway
21:53:11 <kamatsu> problem is I really don't want to have to write these instances by hand
21:53:25 <kamatsu> it's very long and very annoying
21:54:32 <hydo> kamatsu: generics!
21:54:47 <hydo> Probably not, but it was the first thing that popped into my head.
21:55:19 <ddarius> kamatsu: See if the derive package can do it, or be tricked into doing it.
21:56:04 <kamatsu> hydo, that's what i've been trying to do for some time ;)
21:56:35 <hydo> kamatsu: oh! hehe, sorry.  Just came back to the party. :)
21:57:32 * hydo loves generics.  Except when he forgets to provide a default instance when it's needed and his code spins in place really fast and then blows its stack.
22:00:23 <kamatsu> hydo, the problem here is I have an ast with a bunch of type parameters and the action I want to perform changes those type parameters
22:02:14 <kamatsu> i think derive produced a functor instance for me
22:02:34 <kamatsu> i wonder how well that worked
22:03:23 <kamatsu> oh wait, typo :(
22:03:55 <kamatsu> nope
22:03:56 <kamatsu>     Exception when trying to run compile-time code:
22:04:14 <kamatsu> damnation
22:05:40 <ddarius> What's the exception?
22:08:20 <kamatsu> that's what is ays
22:08:25 <kamatsu> "could not convert qname to name"
22:08:40 <kamatsu> also "non exhaustive patterns in function conv"
22:14:30 <wavewave> i remember that generics over existential was not available and being actively researched.
22:14:55 <kamatsu> wavewave, yeah, but this is just a  type that looks like this:
22:15:00 <kamatsu> data Blah a = Con a a
22:15:01 <kamatsu> er
22:15:06 <kamatsu> data Blah a = Con (Foo a a)
22:15:16 <kamatsu> can't derive functor for that
22:15:47 <wavewave> hm. that's not an existential
22:15:51 <ddarius> Well, you could "fix" that in Language.Haskell.Convert.
22:16:35 <kamatsu> i think that's entering a rat-hole of yaks
22:16:59 <kamatsu> very hairy yaks
22:17:48 <kamatsu> wavewave, I know, already abandoned the existential
22:17:52 <ddarius> You'd just add some cases to the Convert instance that either name them what they are e.g. "[]", or possibly more safely, name them something like "List" and you have 'type List = []' in your file, or you just don't worry about that and copy-paste the output and %s/List/[]/
22:17:57 <ddarius> g
22:18:55 <kamatsu> er, i don't understand
22:19:19 <ddarius> The problem is near the bottom of http://hackage.haskell.org/packages/archive/derive/2.5.4/doc/html/src/Language-Haskell-Convert.html#Convert, the instance for QName and Name.
22:21:40 <kamatsu> i still don't understand -- what's wrong with the code that's there?
22:21:52 <kamatsu> (also, this really smells like yak-shaving)
22:23:14 <ddarius> It doesn't cover all the cases for Special.
22:23:28 <ddarius> kamatsu: I already that you just write the instance.
22:26:50 <kamatsu> yeah, i guess
22:26:56 <kamatsu> it just feels so cumbersome
22:30:58 <tomprince> kamatsu: If it is a GHC type, you should just write the instances, and then submit it, so that people who come after you don't need to repeat the work.
22:38:19 <Algo> what good habits does Haskell instill in programmers?
22:39:02 <sbi> washing
22:39:14 <mzero> thinking
22:39:20 <hydo> Don't forget teeth brushing...
22:39:35 <ski> Algo : separating I/O from internals, hopefully
22:40:18 <EvanR> data is more important than algorithms
22:40:19 <ion> I use Haskell and i never do any of that.
22:40:55 <mzero> you don't wash?!?
22:41:13 <EvanR> if data has definite meaning, your program wont collapse later on, maybe
22:41:43 <mzero> what good habits does Haskell instill?   Laziness!
22:41:54 <ski> @where wash
22:41:55 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
22:41:59 * mzero don't know why we didn't see that earlier.....
22:42:20 <Axman6> Algo: the virtues of pure functions
22:43:11 <ddarius> I hear pure functions are the wildest.
22:43:14 <ski> Algo : avoiding unfair discrimination of null cases
23:11:03 <YuleAthas> Is it possible do remove packages from Hackage?
23:12:00 <ezyang> You can hide them with ghc-pkg, which is about just as good.
23:12:08 <ezyang> Oh wait, you're talking about Hackage.
23:14:42 <YuleAthas> Yeah, some programs I wish to upload depend on forked versions of other packages, and I'd want those forks removed if my patches are eventually accepted upstream.
23:15:14 <ezyang> I think you have to ask the Hackage maintainers to delist packages.
23:15:46 <ddarius> I just wouldn't upload the forks.
23:16:15 <YuleAthas> How would you release your programs on Hackage then?
23:16:36 <ddarius> YuleAthas: Either I wouldn't, or I would just include the "forked" packages in my package for the time being.
23:17:00 <YuleAthas> I've tried the former option for over half a year, so maybe I'll try the latter.
23:17:43 <ddarius> If it's taking half a year, then either the packages you forked aren't maintained, and you could take over maintainership, or your patches are not acceptable for some reason and you should probably find a way to work with the existing packages.
23:18:53 <YuleAthas> I assume the maintainers are just busy.
23:37:28 <squiggle_> what does it mean for a constructor application to be saturated?
23:43:51 <DanBurton> no clue
23:43:58 <DanBurton> where'd you hear that?
23:44:11 <DanBurton> @google haskell constructor application saturated
23:44:12 <lambdabot> http://darcs.haskell.org/ghc/docs/comm/the-beast/data-types.html
23:44:12 <lambdabot> Title: The GHC Commentary - Data types and data constructors
23:44:33 <squiggle_> read it in a few papers, including the System F_C one
23:46:11 <ddarius> Saturated means it's "fully" applied.
23:48:48 <DanBurton> that makes sense
23:49:03 <squiggle_> ddarius: it doesn't imply anything about the constructor arguments being evaluated?
23:51:04 <ddarius> I wouldn't think so, but what you are reading should give a precise definition.
23:51:26 <squiggle_> nothing I've read gives a precise definition for that word
