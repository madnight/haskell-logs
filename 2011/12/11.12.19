00:00:16 <aib> wow, yeah. I was actually trying to get the signature correct so I could ask. wow, didn't know an automated search could answer :)
00:00:32 <ski> (cl1 : i.e. we say that `<expr>' was here ascribed the type `<type>' -- also not how this thing, which is an expression, is different from a type signature, which is a declaration)
00:01:13 <ski> (s/not how/note how/)
00:02:15 <cl1> ski, yes I get that
00:02:22 <nus> ski, was suggesting it to help mental decoupling from 'casting' as autocoercion
00:03:01 <ski> nus : yeah, i understood :)
00:03:01 <nus> ski, also unsafeCoerce
00:03:13 * ski doesn't really like that name
00:03:18 <cl1> ski: ascribing forces a specific type signature for an expression, does it not?
00:03:31 <ski> it forces a specific type
00:03:50 <ski> (more specifically a monotype. while a type signature holds a polytype)
00:04:34 <cl1> :t read "1" :: Int
00:04:35 <lambdabot> Int
00:04:39 <ski> (well, with extensions, you could ascribe a polytype as well, with explicit `forall')
00:04:46 <cl1> :t read "3.0" :: Float
00:04:47 <lambdabot> Float
00:04:56 <ski> > (reads :: ReadS Int) "2\n3"
00:04:57 <lambdabot>   [(2,"\n3")]
00:05:02 <cl1> :t \x -> read x
00:05:03 <lambdabot> forall a. (Read a) => String -> a
00:05:08 <ski> @src ReadS
00:05:08 <lambdabot> Source not found. Sorry.
00:05:14 <cl1> :t \x -> read x :: Float
00:05:14 <lambdabot> String -> Float
00:05:22 <ski>   type ReadS a = String -> [(a,String)]
00:05:43 <yitz> @type read "1" :: (Read a, Num a) => a
00:05:44 <lambdabot> forall a. (Num a, Read a) => a
00:06:10 <yitz> you can annotate with a polymorphic type too
00:06:54 <cl1> yitz, interesting
00:07:16 <ski> @type let foo :: a -> [a]; foo (x :: a) = reverse y where y :: [a]; y = ([x,x] :: [a]) in foo
00:07:17 <lambdabot> forall a. a -> [a]
00:07:21 <ski> @type let foo :: a -> [a]; foo (x :: a) = reverse y where y :: [a]; y = ([x,x] :: forall a. [a]) in foo
00:07:22 <lambdabot>     Couldn't match expected type `a1' against inferred type `a'
00:07:22 <lambdabot>       `a1' is a rigid type variable bound by
00:07:23 <lambdabot>            an expression type signature at <interactive>:1:83
00:07:33 <ski> @type let foo :: a -> [a]; foo (x :: a) = reverse y where y :: forall a. [a]; y = ([x,x] :: [a]) in foo
00:07:34 <lambdabot>     Couldn't match expected type `a1' against inferred type `a'
00:07:34 <lambdabot>       `a1' is a rigid type variable bound by
00:07:34 <lambdabot>            the type signature for `y' at <interactive>:1:64
00:07:46 <ski> @type let foo :: a -> [a]; foo x = reverse y where y :: [a]; y = ([x,x] :: [a]) in foo
00:07:47 <lambdabot>     Couldn't match expected type `a1' against inferred type `a'
00:07:47 <lambdabot>       `a1' is a rigid type variable bound by
00:07:47 <lambdabot>            an expression type signature at <interactive>:1:70
00:07:51 <ski> @type let foo :: forall a. a -> [a]; foo x = reverse y where y :: [a]; y = ([x,x] :: [a]) in foo
00:07:51 <lambdabot> forall a. a -> [a]
00:08:42 <ski> yitz : yes, but i'm not sure that's what's happening in `read "1" :: (Read a, Num a) => a'
00:09:12 <mbetter> OverloadedStrings is awesome. That is all
00:09:41 <ski> @type let foo :: Bool -> Bool; foo (x :: a) = x || (False :: a) in foo
00:09:42 <lambdabot>     The scoped type variable `a' is bound to the type `Bool'
00:09:42 <lambdabot>       You can only bind scoped type variables to type variables
00:09:42 <lambdabot>     In the pattern: x :: a
00:10:20 <yitz> ski: ?
00:10:40 <ski> ok, it seems to really do that -- i wonder what the scope of `a' in something with `read "1" :: (Read a, Num a) => a' as a subexpression is, though
00:10:52 <yitz> mbetter: OverloadedStrings is terrible. it fills a real need, but in a very wrong way.
00:11:13 <mbetter> yitz: no doubt.
00:11:19 <MiggyX> is there a more idiomatic way to split a string at a known index then join it together again?  For example if you wanted to turn  "123000" into "12:30:00".   My current test case only has two parts so I can use a tuple with fst and snd but that seems a bit messyâ€¦.
00:11:41 <yitz> ski: i think of it as just within the type expression itself. though i haven't thought of what it means with the scoped type variable extension.
00:12:01 <cl1> > read "1" :: (Read a, Num a) =:> a
00:12:02 <lambdabot>   Class `GHC.Read.Read' used as a type
00:12:07 <ski> yitz : it's possible you're right
00:12:17 <mbetter> yitz: but i've been chasing down this filename encoding problem for the better part of the day and somehow fromString got it right
00:12:23 <ski> s/=:>/=>/
00:12:39 <yitz> mbetter: it allows library authors to undermine the safety of your program behind your back, working around type safety. and there are libraries that do that.
00:12:40 <cl1> > read "1" :: (Read a, Num a) => a
00:12:40 <lambdabot>   1
00:12:45 <cl1> whoa
00:12:49 <mbetter> even though i still don't have the slightest idea what is going on
00:12:51 <cl1> >read "1"
00:13:04 <ski> > (read "1" :: forall a. (Read a, Num a) => a) :: Integer
00:13:04 <lambdabot>   1
00:13:08 <cl1> > read "1"
00:13:08 <ski> > (read "1" :: forall a. (Read a, Num a) => a) :: Bool
00:13:09 <lambdabot>   *Exception: Prelude.read: no parse
00:13:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
00:13:09 <lambdabot>    arising from an expression t...
00:13:26 <cl1> interesting
00:13:33 <mbetter> I think I'm more confused than ever about what a String actually is
00:13:41 <nus> @type read 2 :: 1
00:13:42 <lambdabot>     No instance for (Read Unit)
00:13:42 <lambdabot>       arising from a use of `read' at <interactive>:1:0-5
00:13:42 <lambdabot>     Possible fix: add an instance declaration for (Read Unit)
00:13:51 <ski> cl1 : in those latter two examples of mine, there's an implicit specialization of the polymorphic value (and its type) between the two ascriptions
00:14:32 <ski> cl1 : in the same way as in `id False', there's an implicit specialization of `id' from type `forall a. a -> a' to `Bool -> Bool', before applying it on the expression `False' having type `Bool'
00:14:47 <yitz> mbetter: String is a specific type. normally that is the type of string literals in Haskell. But the OverloadedStrings extension changes that, turning their type into IsString a => a, similar to the way numeric literals have the type Num a => a or Integral a => a.
00:15:06 <aib> aha! (:) <$> Just x <*> Just y also results in Just (x:y)
00:15:24 <ski> aib : yes, it has to, by an applicative functor law
00:15:25 <mbetter> yitz: so I have a String and I want to feed it to a function that takes a ByteString
00:15:40 <mbetter> which it proceeds to marshall into a CString
00:15:44 <ski> (because `pure = Just', here)
00:15:48 <cl1> > (read "1" :: forall a. (Read a, Num a) => a) :: Bool
00:15:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
00:15:49 <lambdabot>    arising from an expression t...
00:15:52 <yitz> mbetter: we do need to change the old default type for string literals, because nowadays Text should really be the default type for strings.
00:16:06 <cl1> > (read "1" :: forall a. (Read a, Num a) => a)
00:16:07 <lambdabot>   1
00:16:14 <cl1> > (read "1" :: forall a. (Read a, Num a) => a) :: Float
00:16:14 <lambdabot>   1.0
00:16:23 <ski> > (read "1" :: forall a. (Read a, Num a) => a) :: Rational
00:16:24 <lambdabot>   *Exception: Prelude.read: no parse
00:16:27 <ski> there
00:16:28 <yitz> mbetter: to do that manually, you would use Data.BytesString.Char8.pack
00:16:30 <ski> (better example)
00:16:46 <yitz> @hoogle pack
00:16:46 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage Pack :: PixelStoreDirection
00:16:46 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
00:16:46 <lambdabot> Data.Text.Lazy pack :: String -> Text
00:16:46 <ski> > 1 :: Rational
00:16:46 <lambdabot>   1 % 1
00:17:15 <ski> > (read "1" :: forall a. Read a => a) :: Bool  -- also
00:17:15 <lambdabot>   *Exception: Prelude.read: no parse
00:17:51 <cl1> > 1 :: Bool
00:17:52 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
00:17:52 <lambdabot>    arising from the literal `1'...
00:17:57 <cl1> 1 :: Rational
00:18:04 <cl1> > 1 :: Rational
00:18:04 <lambdabot>   1 % 1
00:18:26 <mbetter> I'll be damned, it works
00:18:58 <shachaf> mbetter: Data.ByteString.Char8 is evil and racist.
00:19:05 <mbetter> I was trying Data.ByteString.UTF8 fromString
00:19:08 <aib> ski: yeah, but it's still a bit of an effort on my part. I still think "inside", "outside", "boxing" etc. I think I need a tutorial just on applicatives and monads..
00:19:08 <shachaf> mbetter: You probably want to encode UTF-8 or something.
00:19:21 <shachaf> mbetter: Please don't use Data.ByteString.Char8. :-(
00:19:47 <yitz> mbetter: well yeah, if it's UTF-8. what i gave you uses just ASCII.
00:19:51 <ski> @where Typeclassopedia
00:19:51 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
00:19:57 <ski> aib : maybe that ^ helps ..
00:19:58 <kmc> DON'T USE CHAR8
00:20:02 <mbetter> hm
00:20:11 <yitz> kmc: right
00:20:11 <kmc> for fuck's sake
00:20:24 <mbetter> so maybe it's not utf8
00:20:25 <ski> aib : and i hope you're aware of the better monad tutorials
00:20:56 <mbetter> which confuses me even more
00:21:08 <shachaf> What's not UTF-8?
00:21:10 <yitz> kmc: but if someone fed you bytes as a string, it's their fault. and you've still got to deal with it. make sure not to perpetuate such a crime, though.
00:21:30 <kmc> *nod*
00:21:37 <shachaf> yitz: It sounds to me like mbetter is converting a String to a ByteString.
00:21:51 <shachaf> If it's a String (as opposed to, say, Word8), then it's made of characters.
00:21:54 <mbetter> this is filepath stuff
00:21:58 <shachaf> s/Word8/[Word8]/
00:22:14 <kmc> also i disagree that Text should be the "default string type" though i'm not exactly sure what that means
00:22:24 <kmc> generally the stuff in Prelude is conceptually simple, not fancy and optimized
00:22:25 <mbetter> files on a mounted network share i'm trying to enumerate and open
00:22:34 <aib> ski: I assume they're on haskell.org ?
00:22:35 <kmc> i think that's how it should be
00:22:46 <yitz> kmc: i just mean that when i write any serious program that processes text, i use Text nowadays, not String anymore.
00:22:55 <kmc> sure
00:23:05 <mbetter> getDirectoryContents feeds me [FilePath], those need to get passed to TagLib
00:23:10 <yitz> mbetter: yeah file path stuff leads to that kind of ugliness, we're working on fixing that.
00:23:42 <mbetter> you said something just now that matched what I was thinking earlier today
00:23:47 <kmc> yitz, but even if you have a Latin1-encoded ByteString, or a String you want to encode in Latin1, there are better, more explicit ways than Char8
00:23:56 <yitz> mbetter: that stuff works ok already on Windows and Mac, but it's trickier on non-Mac Unix-like platforms.
00:23:58 <mbetter> "but if someone fed you bytes as a string, it's their fault"
00:24:06 <yitz> kmc: yep agreed
00:24:13 <shachaf> mbetter: Did someone actually feed you bytes as a string?
00:24:24 <kmc> Char8 tries to hide and ignore these issues
00:24:34 <mbetter> afaik, a filename on linux is just a bunch of bytes
00:24:42 <yitz> shachaf: one way you can get fed bytes as a string is when it's a file path or command line argument on Unix
00:24:43 <kmc> and it perpetuates the "lol dumb foreigners lern 2 speak english" attitude that still pervades software
00:25:22 <mbetter> ok, i'm not completely nuts then
00:25:33 <mbetter> good to know
00:25:48 <shachaf> yitz: I would say that you should convert a String which isn't actually a list of characters to the appropriate type as soon as you're able to.
00:25:57 <yitz> shachaf: agreed
00:26:10 <mbetter> shachaf: hence the Word8 pack
00:26:25 <shachaf> mbetter: Where areyou actually getting these bytes from?
00:26:36 <mbetter> shachaf: getDirectoryContents
00:26:51 <mbetter> System.Directory
00:26:52 <yitz> mbetter: yep, bingo.
00:27:06 <yitz> on unix that gets you bytes in a String.
00:27:14 <yitz> currently
00:27:28 <shachaf> OK, so that's a bug. :-)
00:27:31 <ski> aib : for just doing I/O : <http://www.haskell.org/haskellwiki/Introduction_to_IO>,<http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html> (<http://blog.ezyang.com/2011/11/how-to-read-haskell/> might also be interesting)
00:27:36 <ski> aib : on monad tutorials, note that there's many not-very-good tutorials out there, see <http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/>. for some which are better, try <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html>,<http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html>,<http://www.haskell.org/haskellwiki/Monads_as_containers>,<http://www.haskell.or
00:27:41 <yitz> in a future version of ghc coming to your neighborhood soon that will change.
00:27:43 <shachaf> You could write a wrapper around getDirectoryContents.
00:27:53 * ski suspects that got cut off around the end
00:27:57 <shachaf> ski: It did.
00:28:06 <mbetter> shachaf: :) i very much plan to
00:28:12 <yitz> there's a new library (in System.Posix, I think) that provides it as ByteString as it should.
00:28:13 <kmc> yeah, these problems in System.Process got fixed in GHC 7.2, I don't know about System.Directory but it might be the same story
00:28:16 <ski> shachaf : at ?
00:28:24 <shachaf> ski: Mid-fifth-link.
00:28:37 <kmc> in GHC 7.2 System.Process still uses String, but it properly encodes/decodes according to the locale
00:28:40 <aib> ski: excellent, thanks again
00:28:43 <kmc> that's what I usually want, not ByteString
00:28:51 <shachaf> I don't know why _You Could Have Invented Monads_ is so popular.
00:28:58 <ski> aib : ...,,<http://www.haskell.org/haskellwiki/Monads_as_computation>,<http://www.haskell.org/haskellwiki/All_About_Monads>,<http://www.haskell.org/haskellwiki/What_a_Monad_is_not>
00:28:58 <shachaf> It's always seemed very confusing to me.
00:29:04 <kmc> if I get a Unicode filename from somewhere, I want to construct a path without having to guess the system locale encoding
00:29:40 <shachaf> kmc: What do you want getDirectoryContents to do if it encounters an invalid string of bytes?
00:29:47 <kmc> exception
00:30:03 <yitz> kmc: oh the String *is* encoded from the locale currently. but that's also bug, because unix file paths are actually bytes, not text. encoding it loses information.
00:30:04 <kmc> i mean, having the ByteString API is also good
00:30:13 <kmc> ok
00:30:13 <mbetter> This came up when I started trying to use a wrapper around a foreign library
00:30:30 <kmc> you know I used to think Haskell was a rare programming language that actually handles Unicode correctly...
00:30:33 <ski> shachaf : i'm not sure. i think the only one which existed when i was fresh on monads was the "What the hell are Monads?" one -- i'm just repeating some ones which i've heard people here recommend at some point
00:30:55 <ski> (well, apart from some papers by e.g. Wadler, i mean)
00:31:00 <shachaf> ski: There's always Wadler's -- yes.
00:31:12 <kmc> the point of byorgey's article isn't just that there's a lot of bad monad tutorials
00:31:15 <kmc> though there are
00:31:18 <yitz> shachaf: right there was a recent discussion about that. ghc currently puts in some kind of user-defined custom Unicode characters. kind of a mess, and doesn't even always work.
00:31:30 <shachaf> "type StateT s a = s -> (a,s)" :-)
00:31:59 <shachaf> yitz: Sounds like a mess.
00:32:34 <yitz> shachaf: yeah. but it's very very tricky to get it right.
00:33:35 <ski> (kmc : i know :)
00:33:35 <kmc> the more monad tutorials there are, the more people think monads are some really deep esoteric concept, and the more they seek out and eventually write monad tutorials
00:33:38 <cl1> :t (***)
00:33:39 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:33:52 <kmc> it's some kind of inane death spiral
00:33:59 * ski didn't feel like writing an essay here, when he could link to one instead, though :)
00:34:08 <everyonemines> I tried to read a monad tutorial once and it made no sense
00:34:19 <everyonemines> it was some bizarre metaphor that I didn't follow at all.
00:34:29 <cl1> kmc: kinda like this http://xkcd.com/927/
00:34:37 <mbetter> everyonemines: with space suits?
00:34:45 <kmc> if current trends continue, then in 20 years the entire world will spend all day everywhere all the time talking about monads and saying only complete nonsense
00:34:50 <everyonemines> (ML programmer here)
00:35:11 <ski> (ML as in SML and O'Caml, or as in Machine Language ?)
00:35:22 <yitz> <modad-tutorial>
00:35:23 <mbetter> modern literature, maybe
00:35:23 <kmc> "monads must be really complicated, i'll look for a complicated metaphor"
00:35:24 <yitz> @type (>>=)
00:35:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:35:26 <yitz> @type return
00:35:26 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:35:30 <yitz> </modad-tutorial>
00:35:36 <everyonemines> ski: the former
00:35:43 <kmc> versus "monad is a small type class, i'll look for some examples with concrete types"
00:35:44 <ski> ok
00:36:05 <everyonemines> hey is there a channel for D
00:36:08 <everyonemines> the language?
00:36:14 <kmc> i'm not saying "monads are easy" because there's difficulty in abstract simplicity
00:36:22 <mbetter> #D
00:36:39 <everyonemines> haha
00:36:40 <kmc> but there's really less to it than most beginners think
00:36:41 <everyonemines> of course
00:36:56 <ski> everyonemines : you should read Andrzej Filinski's paper "Representing Monads" from 1994 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RM.ps.gz>
00:36:56 <cl1> monads may not be difficult, but as someone in here said, unless you understand parametric polymorphism, you aren't going to understand Functors
00:37:06 <kmc> (or monads)
00:37:21 <kmc> monads are functors with some additional operations
00:37:28 <yitz> cl1: i think category theory is sufficient
00:37:29 <cl1> maybe there should be more importance placed on understanding parametric polymorphism before explaining Monads
00:37:45 <kmc> cl1, i think so!
00:37:46 <aib> I was really surprised to see monads turn out to be a type class with two functions. but, of course, simplicity breeds complexity
00:38:05 <mbetter> i think that haskell tutorials introduce do notation too early
00:38:06 <cl1> yitz: why should I have to learn category theory in order to write software, i'm not a CS major
00:38:07 <mbetter> in general
00:38:18 <kmc> unfortunately there is so much monad hype that total beginners come here and want to "learn monads" immediately
00:38:30 <kmc> without knowing type classes, polymorphism, or even higher-order functions
00:38:45 <yitz> cl1: you wouldn't. but if you did, you don't need to know about parametric polymorphism to understand functors.
00:39:04 <cl1> in my defense, i made it to monads in f# before coming here and starting with haskell
00:39:29 <cl1> yitz: which is more difficult to learn?
00:39:39 <ski> (everyonemines : i assume you've heard of the (more or less) monadic library Lwt (light-weight threads) in O'Caml. <https://ocsigen.org/lwt/manual/>)
00:40:21 <yitz> cl1: the very basics of category is really simple, and almost the first thing you learn about is functors. after that it starts to make your brain explode.
00:40:29 <kmc> there are many aspects of how Functor works in Haskell which have nothing to do with category theory
00:40:35 <kmc> because Haskell is a programming language
00:40:42 <yitz> kmc: i suppose so
00:40:50 <kmc> i've tried explaining Haskell functors to category theorists and they get pretty confused
00:40:56 <yitz> their's only one category
00:41:02 <yitz> s/their/there/
00:41:17 <kmc> and the thing we call "the functor" is only the map-on-objects, not the map-on-morphisms
00:41:27 <kmc> and it's always injective
00:41:30 <ski> (`fmap' is the map-on-morphisms)
00:41:34 <kmc> and they're all endofunctors
00:41:40 <yitz> kmc: yeah that did confuse me at first
00:42:17 <ski> kmc : yeah, but you can define alternate classes -- maybe with kind arguments to type classes, we could get a way to fold them back into one
00:42:33 <everyonemines> I don't see the point of monads if you have imperative sequence and parametric polymorphism like ML does.
00:42:37 <everyonemines> Am I missing something?
00:42:41 <kmc> yes
00:42:50 <kmc> monads give you overloading for that sequence operator
00:42:58 <kmc> it could be imperative sequencing but it can be something totally different
00:43:08 <everyonemines> what's an example of how that's useful
00:43:13 <ski> everyonemines : the point is to avoid side-effects. to know what effects *can't* happen in a particular piece of code, just by looking at the type
00:43:14 <kmc> parsers
00:43:19 <kmc> monadic parser combinator libraries
00:43:28 <kmc> or nondeterminism / logic programming
00:43:39 <kmc> or describing parallel evaluation strategies
00:43:39 <everyonemines> you can do that with ML
00:43:45 <kmc> which
00:43:50 <everyonemines> all of them
00:44:14 <kmc> you're saying you can write parsers in ML?
00:44:29 <kmc> of course you can
00:44:33 <kmc> you can also write them in assembly
00:45:05 <kmc> monads are a particularly nice way to describe parsers
00:45:31 <ski> everyonemines : can you write `let val x = parseTerm () val _ = parsePlus () val y = parseExpr () in Plus (x,y) end' and have the call backtrack between the parser calls, until it finds how much the earlier calls has to eat, to be able to parse successfuly ?
00:45:32 <kmc> and by identifying "monad" as an abstraction, we get some useful generic functions which work over imperative programs, and also over parsers, and also over logic programs, and etc.
00:46:02 <everyonemines> ski: What is that supposed to do?
00:46:37 <kmc> everyonemines, I haven't said anything yet about *why* monads are a nice way to describe parsers, so I can understand if you're unconvinced on that point
00:47:02 <ski> everyonemines : or, say, have `listify (fn () => let val x = unlistify [2,3] val y = unlistify [40,50] in x + y end)' evaluate to `[42,52,43,53]' ?
00:47:05 <kmc> but the fact that you can also write parsers without monads is not very relevant
00:48:00 <kmc> for the most part language features are not about expanding the boundaries of possibility, but rather making things nicer / easier / safer / ...
00:48:23 <kmc> (and monads aren't really a language feature, but for a variety of reasons they are harder to use in most other languages)
00:48:37 <ski> everyonemines : the former was supposed to be an analogue of the kind of style in which you write monadic (or applicative) parsers
00:49:50 <ski> everyonemines : so, do you think one can implement  val listify : (unit -> 'a) -> 'a list  and  val unlistify : 'a list -> 'a  so that the above example works ?
00:49:59 <kmc> everyonemines, here's another example of why overloading sequencing is useful.  GHC Haskell supports transactional memory for composable concurrent programming.  you need the operator for sequencing transactions to be different from the operator for sequencing normal imperative code, in order to provide transactional guarantees
00:50:19 <everyonemines> ski: The latter could be done with List.map2 (+) x y
00:50:39 <everyonemines> If I understand correctly.
00:50:40 <kmc> since that operator is overloaded, we can take the syntax and many of the helpers from traditional imperative programming, and use them on transactions
00:50:46 <ski> everyonemines : yes, but imagine the calls to `unlistify' are buried deep inside other functions
00:51:07 <everyonemines> So?
00:51:08 <Blkt> good morning everyone
00:51:24 <mbetter> Morning? I should probably get to bed.
00:51:28 <mbetter> 'night all
00:52:06 <Peaker> everyonemines: there's the *concept* of monads which is useful (the kind of combinators you can use in various contexts) and the interface that allows us to write general code for all monads, which is useful.. Which of them are
00:52:15 <Peaker> you asking for?
00:52:24 <Peaker> or asking about?
00:52:52 <everyonemines> I'm asking, what's useful that you can't do with ML style constructs?
00:52:57 <everyonemines> Because apparently I'm missing something.
00:52:59 <Peaker> everyonemines: ML can definitely encode the former, I'm not sure about the latter -- maybe it can do that too
00:53:11 <everyonemines> ski: That's very weird ML code.
00:53:26 <Peaker> everyonemines: In ML you'd have to pass the Monad dictionary manually
00:53:43 <kmc> again, it's not about "can" but "is the code actually nice"
00:54:00 <Peaker> everyonemines: consider the function:   filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
00:54:02 <ski> everyonemines : and actually, it's not `List.map2', but rather `List.concat (List.map (fun x -> List.map (fun y -> x + y) [40;50]) [2;3])'
00:54:13 <kmc> everyonemines, how about the transaction example?
00:54:24 <ski> (everyonemines : anyway, i was using SML syntax here, but you seem to be an OCamlist)
00:54:53 <ski> everyonemines : yes, this is weird ML code. it is weird in the same way that *all* side-effects are weird, more precisely :)
00:54:56 <everyonemines> ski: I don't see how that connects to the monad version.
00:55:07 <everyonemines> There's no concat in the monad version.
00:55:40 <everyonemines> oh I see, it's a double map
00:55:42 <ski> everyonemines : in case of the list monad, `bind l f = concat (map f l)'
00:56:26 <everyonemines> I don't see how map-concat is useful, but you could easily define a function for it.
00:56:26 <ski> everyonemines : well, the fun part is that you actually *can* write the above code (in SML/NJ), using monadic reflection (see the Filinski link above). but to do this, you *first* have to define a parser monad, or a list monad, &c.
00:56:49 <kmc> everyonemines, bind on the list monad naturally models nondeterministic programming
00:57:11 <everyonemines> I would implement things using a dynamic programming solution
00:57:19 <everyonemines> where a recursive function modifies an array.
00:57:26 <everyonemines> That's generally much faster too.
00:57:36 <kmc> > do { x <- [1..10]; y <- [5..20]; guard (odd (x+y)); return (x*y) }
00:57:37 <lambdabot>   [6,8,10,12,14,16,18,20,10,14,18,22,26,30,34,38,18,24,30,36,42,48,54,60,20,2...
00:58:01 <aib> @hoogle mplus
00:58:01 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
00:58:24 <kmc> everyonemines, how would you provide an interface to software transactional memory in ML?
00:58:45 <everyonemines> kmc: There are already several libraries for parallel programming in ocaml.
00:58:47 <kmc> (there's probably a paper on it)
00:58:53 <kmc> of course
00:59:02 <kmc> i didn't say "parallel programming" i said "software transactional memory"
00:59:20 <ski> everyonemines : consider the code `listify (fun () -> let z = between 1 100 in let y = between 1 z in let x = between 1 y in guard (x*x + y*y = z*z); (x,y,z))' for computing pythagorean triples
00:59:21 <cl1> @quote monadtype
00:59:21 <lambdabot> No quotes match. :(
00:59:22 <kmc> which is more about concurrency than parallelism
00:59:32 <everyonemines> do { x <- [1..10]; y <- [5..20]; guard (odd (x+y)); return (x*y) }
00:59:37 <everyonemines> I understand this but I don't see how it's useful.
00:59:47 <kmc> you seem to be bad at seeing how things are useful
00:59:55 <kmc> sorry bro
01:00:01 <ski> > do z <- enumFromTo 1 100; y <- enumFromTo 1 z; x <- enumFromTo 1 y; guard (x*x + y*Y == z*z); return (x,y,z)
01:00:02 <lambdabot>   Not in scope: data constructor `Y'
01:00:07 <ski> > do z <- enumFromTo 1 100; y <- enumFromTo 1 z; x <- enumFromTo 1 y; guard (x*x + y*y == z*z); return (x,y,z)
01:00:08 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24...
01:00:21 <ski> > [(x,y,z) | z <- enumFromTo 1 100 , y <- enumFromTo 1 z , x <- enumFromTo 1 y; guard (x*x + y*y == z*z)]
01:00:22 <lambdabot>   <no location info>: parse error on input `;'
01:00:29 <ski> > [(x,y,z) | z <- enumFromTo 1 100 , y <- enumFromTo 1 z , x <- enumFromTo 1 y , guard (x*x + y*y == z*z)]
01:00:30 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
01:00:30 <lambdabot>         against inferred type ...
01:00:35 * ski sighs
01:00:39 <ski> > [(x,y,z) | z <- enumFromTo 1 100 , y <- enumFromTo 1 z , x <- enumFromTo 1 y , x*x + y*y == z*z]
01:00:39 <everyonemines> let x = 1 -- 10 let y = 5--20 in List.filter (odd (x+y))
01:00:40 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24...
01:01:08 <ski> everyonemines : yes, the point is to write code which backtracks, instead of writing code which explicitly handles lists
01:01:23 <everyonemines> Er, sorry, let x = 1 -- 10 let y = 5--20 in List.filter odd (List.map2 (+) x y)
01:01:29 <everyonemines> So it'
01:01:38 <everyonemines> So it's just a form of ad-hoc polymorphism?
01:01:58 <everyonemines> I mean, you can open the List module, it's not a big deal in practice.
01:02:14 <everyonemines> but ad hoc polymorphism would be nice
01:02:30 <everyonemines> of course it makes compilation much slower
01:03:09 * shachaf isn't sure what everyonemines is saying, but it doesn't seem right.
01:03:12 <Peaker> everyonemines: the idea is writing generic combinators like those in Control.Monad that work on all monads
01:03:26 * ski isn't sure exactly what everyonemines means by "ad hoc polymorphism" here, but is pretty sure it's not much related to the point of using monads
01:03:30 <everyonemines> You can do that with functors.
01:03:52 <ski> you can do that, sortof, using functors, yes
01:04:07 <Peaker> everyonemines: Maybe, I don't know enough ML -- I think I've seen an example of doing it with functors and it was tedious
01:04:23 <everyonemines> yes, functors are annoying
01:04:37 <ski> (but you have to generate new code for each time you want to use it on a different monad, when it really is executing the exact same thing -- this is because the MLs sadly doesn't allow higher-order types)
01:04:52 <Peaker> everyonemines: in Haskell, I can re-use the same function:  filterM  for very different purposes.   For example:  filterM promptUser decisions  -- would ask prompt the user (as an IO action) for each decision, and return a list of accepted decisions
01:05:16 <Peaker> everyonemines: filterM (\x -> [True, False]) [1..10]   will run in the list/non-determinism monad ,and I'll get each element both filtered in, and out (i.e: a powerset)
01:05:27 <everyonemines> Peaker: You haven't actually used ML have you?
01:05:33 <Peaker> everyonemines: nope
01:05:34 <everyonemines> You just need a different version for lists and arrays
01:05:37 <everyonemines> not for every list type
01:05:37 <ski> everyonemines : anyway, yes, you can do monads in the MLs, defining a signature / module type specifying the monadic interface, and then define functors over that
01:05:48 <Peaker> everyonemines: I didn't say you would need one for every list type
01:06:01 <Peaker> everyonemines: But filterM works with parsers, exceptions, transactions, lists, IO, ...
01:06:28 <Peaker> everyonemines: in ML, having a function that's polymorphic like that requires either functors, tediously, or passing a dictionary of functions (which then requires rank-2 types, which I don't know if ML sports)
01:06:56 <everyonemines> ocaml has first class modules
01:06:58 <Peaker> everyonemines: I know
01:07:04 <ski> everyonemines : with extensions in O'Caml which allow polymorphic components of records (or maybe it was only objects ?), you can also pass around monad dictionaries, and then you can actually execute a *single* `filterM' operation, for any monad
01:07:23 <everyonemines> but I have never used first class modules
01:07:26 <everyonemines> it just has them
01:07:40 <Peaker> everyonemines: similarly, the fact Haskell has the Monad type-class means that when I learn a new library (e.g: a parser library) I already *know* how I compose parsers in various ways because it just re-uses the monad interface. If I want a parser that repeats another parser 5 times, I use Control.Monad.replicateM 5 theParser
01:08:18 * ski suspects that everyonemines will just have to try using monads (e.g. monadic parsing), to see how it can be useful
01:08:20 <Peaker> everyonemines: I don't have to look for the reimplementation of every monadic combinator in the parser lib and hope they used the same name
01:09:02 <Peaker> everyonemines: "do" syntax is also pretty nice
01:09:08 <MiggyX> stupid question:  How do you create a default instance of something? For example, I have a function that returns UTCTime.  I initially check to see if the time stamp can be parsed, if not I just want to return the "default" UTCTime - but I'm not entirely sure that even makes sense :)
01:09:32 <Peaker> everyonemines: and the fact we compose IO in Haskell only via the monadic combinators -- means that we get fine-grained control over effects, but that's a tangent to monads
01:09:54 <everyonemines> So we have a library of operators on *sequence*
01:10:18 <Peaker> everyonemines: monads are not a "sequence"
01:10:18 <everyonemines> and a standard syntax to mark points for manipulation
01:10:31 <ski> everyonemines : anyway, you should read the paper i linked :)
01:10:37 <Peaker> everyonemines: unless you mean something very specific when you say "sequence" :)
01:10:48 <Peaker> MiggyX: You want the function to return a UTCTime anyway -- then the default handling is inside it?
01:11:35 <ski> Peaker : s/specific/general/, no ?
01:11:59 <MiggyX> Peaker: for example, if the string is the wrong size in my parse function, I want to create a default UTCTime - basically the same as calling parseTime with "0".
01:12:12 <aib> one last thing, is there a way to simplify "(:) <$> (return x) <*> Just y" ?
01:12:41 <Peaker> ski: specific generalization :)
01:12:44 * ski thinks `do z <- [1 .. 100]; y <- [1 .. z]; x <- [1 .. y]; guard (x*x + y*y == z*z); return (x,y,z)' performs a "sequence" of effectful operations, one after another :)
01:13:03 <Peaker> MiggyX: I'd first define a parser function that returns a "Maybe UTCTime", and then use "fromMaybe <defaultUTCTime>" on it
01:13:15 <ski> aib : `Just (x : y)'
01:13:20 <everyonemines> ski: right
01:13:32 <Peaker> ski: well, the "sequence" here is allowed to look at previous results, and that's not conveyed by "sequence"
01:13:38 <Peaker> ski: Applicative is also a "sequence"
01:13:43 <everyonemines> So you have functions on a sequence.
01:13:52 <everyonemines> Which manipulate how it's traversed and can backtrack.
01:14:01 <Peaker> everyonemines: That is not meaningful enough to describe what Monad is.. For example it cannot distinguish Applicative from Monad
01:15:10 <everyonemines> I wonder if I could troll haskell people by writing something about how "goto considered harmful" means monads are bad.
01:15:22 <ski> everyonemines : anyway, there's two points of monads here. (a) being able to rely on which effects are *not* done in a piece of code, just by looking at the type; (b) being able to define your own custom computational effects; (well, also (c) being able to define generic operations working on any computational effects)
01:15:34 * aib slaps himself on the forehead.
01:15:40 <aib> right, that was not my actual problem, of course
01:15:59 <ski> everyonemines : since the MLs has side-effects, you can't do (a), but (b) (and (c)) could still be quite useful (cf. Lwt)
01:16:09 <aib> gotta run, I'll do it as an exercise
01:16:15 <aib> it's been enlightening. thank you all
01:16:32 <Peaker> ski: I think (a) is really the point of IO, not of monads
01:16:40 <ski> everyonemines : hehe, goto isn't really related to monads in any direct way
01:16:45 <shachaf> Peaker: It's not really about types, there, either.
01:16:57 <Peaker> (and that IO uses monadic combinators for a tiny fraction of its interface is slightly related)
01:17:01 <MiggyX> Peaker: okay, first I must learn about Maybe and Nothing :)
01:17:09 <ski> Peaker : when i use `STM Foo', i rely on this not performing any arbitrary parsing side-effects behind my back
01:17:10 <shachaf> Peaker: I mean, getLine is a fundamentally different *value* from any String.
01:17:22 <shachaf> Not just a String with a slightly different type.
01:17:31 <Peaker> ski: that's just sanity, not monads :)
01:17:35 <ski> Peaker : it's just that we're not used to things having parsing side-effects in other languages that we don't consider this possibility
01:17:49 <Peaker> ski: but why is that a monad thing?
01:18:08 <ski> Peaker : in a side-effectful language, there's no reason why it couldn't have parsing side-effects built-in
01:18:13 <everyonemines> OK, if I understand correctly, where in Haskell you would use parsing monads, in ML you might use a set of states which have a dictionary function repeatedly applied which calls a different function depending on the state.
01:18:16 <Peaker> shachaf: I'm not saying IO a is related to a
01:18:32 <ski> Peaker : because encapsulating the side-effects as *effects* in a monad is in a sense what monads is all about
01:18:54 <Peaker> shachaf: just that separating effects is not really a monadic thing -- monadic combinators are enablers of that idea
01:18:55 <everyonemines> (Which I have actually done. :-) )
01:19:03 <ski> Peaker : Moggi started using monads in denotational semantics to be able to *describe* computational side-effects of various kinds
01:19:40 <shachaf> Peaker: I agree.
01:20:01 <ski> (and then Wadler came along and realized that Moggi's denotational semantics of imperative programs in terms of monads in a pure math language worked just fine for "simulating side-effects" in a pure language like Haskell)
01:20:19 <everyonemines> Any monad process can be represented by an interpreter loop, that's turing equivalence for you, the question is whether it's a more elegant way of expressing it
01:20:26 <everyonemines> and that depends on how you think about something, partly.
01:20:30 <shachaf> everyonemines: What?
01:20:45 <Peaker> everyonemines: What's a "monad process"?
01:20:47 <everyonemines> What?
01:21:15 <Peaker> everyonemines: You mean every monadic composition?
01:21:31 <everyonemines> sure
01:21:32 <ski> everyonemines : "in ML you might use a set of states which have a dictionary function .." -- well, are you talking about a mutable state, or are you talking about state-passing-style ?
01:21:48 <Peaker> everyonemines: Monads are not about computational power in Haskell. Monads are about *generalization* power -- so Turing equivalence is not really relevant
01:22:47 <everyonemines> ski: In this case it doesn't really matter...
01:22:48 <ski> Peaker : well, it's related to what you can express without having to do a *global* transformation of the program
01:22:48 <Peaker> everyonemines: (a) the ability to write a function that works with parsers, continuations, exceptions, non-determinism, ... simultaneously while only being implemented once
01:22:54 <ski> everyonemines : it does
01:23:08 <Peaker> everyonemines: (and the availability of many such pre-existing functions/vocabulary, of course)
01:23:34 <ski> everyonemines : in case it's using mutable state, that makes it harder to reason about "equationally" (especially if you use higher-order functions, and store functions in data structures, to be called later)
01:23:45 <Peaker> everyonemines: (b) no need to learn hundreds of equivalent combinators for each library
01:23:58 <Peaker> (or to reimplement the same combinators over and over)
01:24:26 <ski> everyonemines : in case you're doing state-passing-style, then monads is a way to abstract away from the tedium of doing that (including the risk of accidentally passing the wrong state onward)
01:24:26 <everyonemines> Hmm, I think I see the benefit of representing structure with sequence in code in addition to names.
01:24:44 <everyonemines> with anonymous marker tokens
01:25:13 <Peaker> I don't think that thinking of monads as a "sequence with names" is a good way to understand them
01:25:26 <Peaker> in some fuzzy way, it approximates what they can express
01:25:35 <everyonemines> no, I meant a structure defined by sequence
01:25:41 <everyonemines> rather than one defined only by names
01:25:54 <ski> everyonemines : let's say you write `let foo x y s0 = let s1 = f x s0 in let z,s2 = g y z s1 in h x z s2'
01:26:28 <everyonemines> ...yes?
01:26:40 <Peaker> monads are defined by: (a) having a type-arg (m::*->*). (b) having a   return :: a -> m a     (c) having a   (>>=) :: m a -> (a -> m b) -> m b
01:26:46 <ski> everyonemines : using monads, you can instead write `let foo x y = bind (f x) (fun () -> bind (g y z) (fun z -> h x z))', completely hiding the state-passing
01:27:31 <Peaker> (and having certain laws relating (b) and (c))
01:27:33 <everyonemines> My understanding of computers is from the ground up. So hiding how it's actually working is to me obfuscation.
01:27:50 <Peaker> everyonemines: then why do you like polymorphism? It hides the concrete types
01:27:50 <everyonemines> I like to be able to imagine how registers will transfer if necessary.
01:27:58 <Peaker> everyonemines: and definitely the registers
01:28:21 <ski> everyonemines : using some kind of monadic syntactic sugar, this could even look something like `let foo x y = mlet {state} () = f x in mlet {state} z = g y z in h x z'
01:28:44 <Peaker> everyonemines: if you want to see registers transfers, you should be using assembly. Even C will generate vastly different register use in different compilers
01:29:18 <everyonemines> Well, I exaggerate, but it's true that haskell makes it hard to tell when code is efficient.
01:30:00 <Peaker> everyonemines: Polymorphism does too, unless you look at the entire specialized thing -- which is the same with the monad generalization and the automatic threading of state
01:30:36 <ski> everyonemines : but, now imagine that you're doing some kind of simulation, so in addition to computing new states, you sometimes need to "split the world" into two parallel simulations, which may then evolve in different directions
01:30:41 <cl1> preemptive optimization is the root of all evil
01:30:58 <Peaker> everyonemines: Hiding implementation details is generally considered a good thing :)  Every abstraction does that -- and so if you like the abstraction, you accept the benefits, and if you don't, you reject it as "obfusctating what goes on"
01:31:02 <ski> everyonemines : using monads, you don't have to change `foo' above *at all* -- so monads here abstracts from the details of the "simulation"
01:31:07 <cl1> you shouldn't care if your code is optomized unless its slow
01:31:35 <mux> cl1: it's "premature"
01:31:39 <everyonemines> ski: I think I got your last example but I don't see how the monad version is better. It's just harder to read to me.
01:31:42 <MostAwesomeDude> There's a big difference between knowing your time and space complexity, and micro-optimizing your code.
01:31:45 <Peaker> everyonemines: Haskell's difficult-to-predict operational semantics don't have much to do with the monadic generalization
01:31:45 <ski> everyonemines : otoh, if you had the original state-passing `let foo x y s0 = let s1 = f x s0 in let z,s2 = g y z s1 in h x z s2', you'd have to add lists (or some other kind of sequence) here
01:32:01 <MiggyX> cl1: actually that depends on the code you're writing - i.e. where speed gives you an edge. It's pre-mature optimization that's the root of all evil imho ;)
01:32:23 <everyonemines> ski: No, you can pass all the type-specific functions
01:32:31 <ski> everyonemines : the point here is abstraction, and decoupling of this "application code" from the code that describes the internals of how simulations work in general
01:32:33 <everyonemines> and have a type-agnostic higher-order function.
01:32:47 <ski> everyonemines : yes, and that's what using monads here will do
01:32:56 <cl1> preemptive: taken as a measure against something possible, anticipated, or feared;
01:33:27 <everyonemines> ski: But here's a tradeoff; code becomes harder to read.
01:33:50 <everyonemines> You're separating things across the codebase, harder to see what's going on.
01:34:03 <ski> everyonemines : let's say the type of `foo' is currently `X -> Y -> S -> R * S' -- now i want to change it to `X -> Y -> S -> (R * S) list' -- to allow for the "split world" simulation step
01:34:19 <everyonemines> That's why I never write in point-free style; explicit argument names help document code.
01:34:31 <Peaker> everyonemines: That argument works both-ways.  Implementing state passing everywhere obfuscates what actually goes on, because state threading is cluttering the entire code
01:34:44 <everyonemines> ski: So you pass it a different function that produces a list.
01:34:52 <mux> everyonemines: except when it doesn't because there is no sensible name to use; that happens with very polymorphic code.
01:34:56 <everyonemines> Using a function as an argument.
01:35:00 <ski> everyonemines : yes, it's a bit harder to trace exactly how code will execute. but the nice part about monads is that they come with *laws*, which you can use to reason about and refactor your code, while not having to care exactly how this particular monad works
01:35:00 <Peaker> everyonemines: and explicit argument names are worthless if the argument is polymorphic and there's nothing interesting to say about it in the general case
01:35:10 * mux ^5's Peaker 
01:35:23 <ski> everyonemines : obviously `f',`g',`h' now also returns lists
01:35:48 <ski> everyonemines : so, how would you rewrite the code of `foo', e.g. using a type-agnostic higher-order function ?
01:36:04 <yitz> everyonemines: combinator style, as opposed to gratuitous point-free, is better documented than writing explicit function arguments where they're not needed
01:36:12 <yitz> usually
01:36:14 <Peaker> everyonemines: either your code hides the details of state threading and non-determinism and the operational details, while making the details of the *simulation* clearer, or it hides what the *simulation* is doing as it is buried in these details
01:36:57 <Peaker> everyonemines: State threading is really a mechanical notion not to be reimplemented over and over by humans :)
01:37:15 <everyonemines> ski: You only changed the type at the last step. If that's all you want to do, just add "h" to the parameters.
01:37:28 <Peaker> everyonemines: hiding it is similar to hiding memory management -- surely you accept GC despite it hiding the details of allocations/freeing?
01:37:30 <everyonemines> You can pass another function to "h" to adapt it for different types if necessary.
01:37:59 <everyonemines> Peaker: Actually I mentally track how the GC works.
01:38:05 <Peaker> everyonemines: how?
01:38:06 <everyonemines> it's important for numerical code.
01:38:26 <Peaker> everyonemines: do you write code for a specific version of a specific compiler?
01:38:33 <everyonemines> no
01:38:39 <Peaker> everyonemines: then how do you even know which GC algorithm is used?
01:38:50 <ski> everyonemines : i also changed the type of `f' from `X -> S -> S' to `X -> S -> S list', the type of `g' from `X -> Y -> S -> Z * S' to `X -> Y -> S -> (Z * S) list', and the type of `h' from `X -> Z -> S -> R * S' to `X -> Z -> S -> (R * S) list'
01:38:52 <everyonemines> it's more about the principles of how you can pass references around
01:38:55 <everyonemines> without causing memory explosion
01:39:11 <Peaker> everyonemines: different GC's will release memory at very different times, and will have different cost profiles
01:39:13 <ski> (that's what "<ski> everyonemines : obviously `f',`g',`h' now also returns lists" meant)
01:39:22 <everyonemines> ski: You can add a function "i" to the function which is passed to f, g, h inside it.
01:39:31 <everyonemines> so change the type of that single function
01:39:43 <ski> everyonemines : so, how should `let foo x y s0 = let s1 = f x s0 in let z,s2 = g y z s1 in h x z s2' be changed, in your opinion, to accomodate this change ?
01:39:46 <Peaker> everyonemines: The things you're saying about the abstractions you're not used to -- are the exact things a C programmer will tell you about the abstractions that you do use
01:39:53 <Peaker> everyonemines: they obscure what's *actually* happening
01:40:10 <everyonemines> a C programmer? I use C all the time.
01:40:21 <ski> everyonemines : code please :) this isn't really a very complicated example, no ?
01:40:35 <Peaker> everyonemines: I'm talking about your use of ML
01:41:14 <everyonemines> let foo x y fn s0 = let s1 = f fn x s0 in let z,s2 = g fn y z s1 in h fn x z s2
01:42:00 <everyonemines> at least that's one way
01:42:20 <ski> this doesn't work
01:42:30 <everyonemines> sure it does
01:42:52 <ski> the new `f' returns a *list* of `S's, so in that cose `s1' will be a list, which can't be passed directly to `g'
01:43:06 <ski> (s/cose/case/)
01:43:17 <everyonemines> fn determines the type handled
01:43:22 <ski> how ?
01:43:32 <everyonemines> it's passed as an argument to the functions
01:43:51 <ski> if you are arguing that you can simulate the type changes i did to `f',`g',`h' with other type changes, i want to see how
01:44:17 <ski> for my new `g' e.g., i have
01:44:18 <everyonemines> you understand higher order functions right?
01:44:28 <carpi> is it wrong to assume that all data constructors are also functions?
01:44:29 <ski>   g : X -> Y -> S -> (Z * S) list
01:44:36 <ski> you seem to have something like
01:44:54 <ski>   g : ? -> X -> Y -> S -> Z * S
01:44:56 <ski> instead
01:45:07 <ski> how will this latter function simulate the former ?
01:45:26 <ski> carpi : yes. e.g. `False' and `Nothing' are not functions
01:46:06 <ski> everyonemines : yes, i do understand HOFs :)
01:46:27 <ski> i'm just not sure how you want to simulate `g : X -> Y -> S -> (Z * S) list' by `g : ? -> X -> Y -> S -> Z * S'
01:46:33 <carpi> ski: what about 'Just'?
01:46:40 <Peaker> carpi: Just is also a function, yes
01:46:42 <ski>   Just :: a -> Maybe a
01:46:59 <carpi> so some data constructors can be used as functions..but not all?
01:47:00 <ski> carpi : since there's a `->' in the type there (at the "top"), it's a function
01:47:23 <ski> carpi : yes. the ones with types of the form `blah -> bleh' are functions
01:47:46 <ski> (and this holds regardless of whether they are data constructors, or just any plain old value)
01:48:15 <carpi> thanks for the clarification )
01:48:35 <ski> everyonemines : one simple way to simulate one of these `g's by the other would be if you could write a HOF `(? -> X -> Y -> S -> Z * S) -> (X -> Y -> S -> (Z * S) list)' -- can you ?
01:48:52 <ski> (there might be another way to simulate it as well, but i'm not sure)
01:49:47 <ski> (btw, i still don't know what type the `?' here is -- this is the type of your `fn' function argument, whatever it is supposed to be)
01:51:22 <cl1> ping
01:53:11 <everyonemines> ski: You can write a function that does that, but there are many possible desired outputs of that type.
01:54:03 <ski> everyonemines : how ?
01:54:29 <ski> you should be able to tell, without knowing how the types `X',`Y',`Z',`R',`S' are defined
01:54:56 <ski> i can rewrite the original code in the way i asked you, without knowing that
01:55:49 <everyonemines> let foo f = let fn x = [x;x] in fn f
01:56:03 <ski> (but i claim that doing so is cumbersome, and will occlude the real important points in whatever algorithm `foo' is supposed to implements -- using monads (reflected or not) will hide this unnecessary detail, so that one can focus on the algorithm itself)
01:56:06 <everyonemines> Not useful, but it does that.
01:56:19 <everyonemines> I personally find the monad version harder to read.
01:56:30 <everyonemines> But how about this: suppose you have an array of functions
01:56:38 <everyonemines> this corresponds to the monad structure
01:56:44 <everyonemines> and then some functions manipulating that array
01:56:51 <everyonemines> corresponding to the monad operators
01:56:58 <everyonemines> can this do everything monads can?
01:57:20 <ski> hm, that code is equivalent to `let foo f = [f;f]', which looks like it doesn't have the right type at all
01:57:30 <everyonemines> no, not equivalent
01:58:11 <ski> you call `fn' on `f', and since `f' is a value here (no side-effect), we can just replace `x' in the body with `f'
01:58:20 <everyonemines> er wait
01:58:22 <everyonemines> i did that wrong
01:58:35 <ski> np
01:59:18 <ski> re array of functions, no monads are (a bit) more general than that -- but the basic idea of a datastructure with functions in it is not bad
01:59:32 <everyonemines> what else can monads do
01:59:34 <everyonemines>  that that cant
02:00:00 <Peaker> everyonemines: http://hpaste.org/55447 -- you said you find the state threading more readable?
02:00:17 <Peaker> everyonemines: which is easier to verify for correctness, for example?
02:00:18 <ski> to do it in a nice way, you do need GADTs (which istr hearing about an experimental implementation of in O'Caml, though possibly not in the main trunk)  (well, or you can do a CPS data-structure, which is not as nice)
02:00:22 <quicksil1er> everyonemines: thread information from one function to the next.
02:00:40 <ski> so, you *can* do monads by doing a custom datastructure "holding functions", yes
02:00:41 <quicksil1er> everyonemines: Applicative can be modelled by a list of function, in a sense.
02:01:01 <ski> (but just a list/array of functions will not do, it's a bit more complicated than that -- you need a kind of tree)
02:02:00 <everyonemines> Peaker: Huh? You can write an imperative version like the top version, you just use assignment.
02:02:08 <everyonemines> Of course imperative code without mutation looks silly.
02:03:06 <hpaste> Peaker annotated â€œMonads vs state-threadingâ€ with â€œWhich is more readable?â€ at http://hpaste.org/55447#a55448
02:03:13 <ski> everyonemines : you can only use mutation if you're ok with using an ephemeral datastructure. if you need a persistant one (e.g. for undo/redo, or for comparing multiple versions), you can't easily use mutation
02:03:43 <everyonemines> So you copy it when you want a copy.
02:03:58 <everyonemines> forks? huh?
02:04:12 <Peaker> everyonemines: forks are when the simulation wants to split into multiple possible futures
02:04:17 <ski> but then you very often end up being too conservative, which can be quite inefficient
02:04:31 <Peaker> everyonemines: represented by returning not just a new state, but a list of new possible states (with just 1 state if no fork)
02:04:37 <ski> i.e., if you copy everytime that some function call *might* need to mutate the copy
02:05:01 <everyonemines> ski: I don't think you understand what the haskell compiler is doing.
02:05:11 <ski> of course, you could let the function return a flag that tells whether it mutated or not, but that's hardly better than explicit state-threading
02:05:24 <ski> everyonemines : doing in which example ?
02:05:48 <cl1> just looking for a yes or no. is this correct: instance Functor' ((,) e) where fmap g (x,y) = (x, g y)
02:06:05 <ski> cl1 : yes
02:06:12 <cl1> w00t!
02:06:30 <ski> cl1 : did you try `Either e', yet ?
02:06:32 <everyonemines> Peaker: Uh, I would use a binary tree of states which expands as needed.
02:06:41 <everyonemines> Or something like that.
02:06:42 <Peaker> everyonemines: why binary?
02:06:51 <Peaker> everyonemines: note the example I pasted -- it implements forks with lists and concatMap
02:07:00 <everyonemines> Lists are unacceptable performance-wise.
02:07:08 <cl1> instance Functor' Either e where fmap _ (Left a) = Left a; fmap g (Right b) = Right (g b)
02:07:16 <Peaker> everyonemines: lists can often be fused away
02:07:38 <Peaker> everyonemines: also, I can represent forks with a CPS representation of lists
02:07:46 <ski> # let concat_map f l = List.concat (List.map f l);;
02:07:47 <ski> val concat_map : ('a -> 'b list) -> 'a list -> 'b list = <fun>
02:07:48 <cl1> am i correct that the ordering of my fmap implementations for Either e does not matter?
02:08:04 <everyonemines> Peaker: You also need to be able to tell the state to advance.
02:08:08 <Peaker> cl1: you're missing () there around (Either e)
02:08:24 <everyonemines> Monad coordination of forks is awkward imo, compared to message-passing.
02:08:33 <Peaker> cl1: the order of matching Left or Right does not matter, because the patterns don't overlap at all
02:08:38 <cl1> Peaker, nice catch. I didn't miss it in my code, just missed it typing it out
02:08:49 <Peaker> everyonemines: Maybe you should try to use them before claiming they are awkward for that :)
02:09:05 <ski> cl1 : (see Peaker), yes it looks ok, yes the ordering of the two defining equations/clauses for `fmap' doesn't matter, just as usual when you have disjoint patterns
02:09:13 <ksf> wasn't there some new iteratee library besides iteratee and enumerator?
02:09:15 <Peaker> everyonemines: Using monad transformers, I can compose the state monad with the non-determinism monad, and be able to both tell the state to advance, and to "fork" into multiple possible continuations
02:09:26 <Peaker> ksf: iterio?
02:09:41 <ksf> no, not that one.
02:09:54 <Peaker> everyonemines: And my code won't be riddles with state threading details -- and doing concats on the possible futures
02:09:58 <Peaker> riddled*
02:10:23 <cl1> Peaker, i think both words fit that spot in the sentance
02:10:25 <Peaker> everyonemines: you can do that too -- by implementing a function that threads the states and does the concats too -- and using that function (namely "bind") to compose your simulation's stages
02:10:49 <everyonemines> Peaker: Actually, my solution to your problem would be mutation of a storage structure
02:10:54 <Peaker> everyonemines: but then you might realize you've reimplemented "bind" the 1000th time, and it's time to generalize, then you will have reinvented monads :)
02:10:55 <everyonemines> where each fork mutates a different area
02:11:13 <Peaker> everyonemines: mutation and forks requires unmutating a lot -- a persistent data structure is likely to outperform it
02:11:40 <everyonemines> No, I'd use a btree and let the GC handle it.
02:12:12 <everyonemines> in practice, dynamic control requires control over mutation patterns for serious programming
02:12:22 <everyonemines> i deal with numerical stuff where speed is relevant
02:15:35 <russellw> everyonemines, high-performance numbercrunching is not a domain traditionally associated with functional programming languages, I'm curious about your reason for choosing Haskell for it?
02:15:52 <everyonemines> russellw: I don't use haskell for that.
02:16:02 <everyonemines> but ocaml works
02:16:32 <russellw> ah, okay
02:16:52 <everyonemines> The idea of manipulating trees of functions using other functions is interesting though.
02:17:32 <everyonemines> but haskell monads make me feel lost in syntax. I feel like it would be better to use the same structure definitions you use for data.
02:17:49 <quicksil1er> the syntax of monads is unimportant
02:18:00 <quicksil1er> feel free to ignore the do and <- and rewrite it in your head to >>=
02:18:21 <everyonemines> I disagree. It takes up more mental space to have a different representation of structures.
02:18:22 <quicksil1er> c.f. the chapter on writing parsers in Paulson's ML book
02:18:37 <quicksil1er> that's not what I'm saying.
02:18:58 <quicksil1er> I'm not saying syntax has no cost. I'm saying, if the syntax is blocking your understanding of monads, look past it for now.
02:19:23 <quicksil1er> once you've written f >>= \y -> g >>= \z -> .... a few times you can see why people invented the syntax
02:19:39 <everyonemines> I understand the concept now, what was blocking my understanding
02:19:53 <everyonemines> was bad explanations of it.
02:20:25 <cl1> everyonemines, what kind of number crunching do you do?
02:20:48 <everyonemines> kind?
02:21:28 <cl1> yes kind
02:21:35 <everyonemines> between what options
02:21:36 <cl1> in what context do you crunch numbers?
02:21:42 <everyonemines> at work?
02:21:46 <cl1> yes
02:21:57 <everyonemines> you need to be more specific
02:22:16 <everyonemines> but I'm not going to name the company I work for
02:22:36 <cl1> you don't have to in order to describe what they do
02:23:25 <cl1> what does the business do?
02:23:32 <everyonemines> not answering that, sorry
02:24:05 <cl1> that's what i thought
02:24:14 <cl1> he or she is full of shit
02:26:10 <MostAwesomeDude> Just assume they work for a porn company.
02:26:18 <MostAwesomeDude> Embarrassing, but somebody's gotta do it.
02:26:52 <cl1> lol
02:28:23 <MostAwesomeDude> Actually, the people I know in that industry tend to be very upfront about what they do. Apparently it's a mark of pride?
02:28:38 <Philippa> that's its own bias, though
02:28:47 <cl1> no his persistence that squeezing cycles out of code was so important, today number crunching is limited by throughput not processor speed. He would be working on distributable algorithms that could run on many machines. instead of blathering about the crap he was talking about
02:28:51 <Philippa> (the ones you know [about] are the ones who're upfront about it)
02:29:13 <MostAwesomeDude> (True.)
02:29:34 <Philippa> well, I'd expect at least some ability to talk about what kind of patterns without giving away what the underlying problem domain is
02:30:21 <Philippa> my current problem: convincing the rail companies here to get me train times faster than I could get to the station to check myself
02:31:07 <cl1> you would have better luck getting them to publicly expose an api that you could call and write the software yourself
02:31:42 <Philippa> the API would be a form of them getting me train times
02:31:52 <cl1> true
02:32:00 <Philippa> anyway, brb
02:32:07 <quicksilver> cl1: they deliberately obfuscate their web pages so they can charge for access to train times
02:32:26 <quicksilver> cl1: and they actively write cease and desist letters to people who write convenient train time apps
02:32:29 <quicksilver> nice isn't it?
02:32:37 <cl1> wow
02:32:48 <quicksilver> apparently just paying for your ticket isn't enough
02:32:57 <cl1> what country is this in?
02:32:59 <quicksilver> you're supposed to also pay for a mobile app to find out train times.
02:33:02 <quicksilver> the UK.
02:34:14 <cl1> i'm guessing they have no competition
02:35:28 <Philippa_> basically no. "Privatisation" here mostly means handing (smaller but partitioned) monopolies to private bidders
02:37:18 <Saizan> it seems that the only privatizations done well are in other countries
02:38:04 <Philippa_> as in, never where the person commenting on it has to experience it?
02:38:18 <Saizan> yeah
02:38:37 <cmasseraf> true
02:38:59 <cl1> lol
02:39:34 <cmasseraf> put keeping estatal companies around is not much better also (since they are slow and stationary in terms of changes and advances)
02:39:57 <sohum> :t \a t i -> any a . foldM t i
02:39:58 <lambdabot> forall a b. (a -> Bool) -> (a -> b -> [a]) -> a -> [b] -> Bool
02:40:08 <Philippa_> the train wifi'd probably be free that way round though
02:40:27 <hpaste> cl1 pasted â€œITree functorâ€ at http://hpaste.org/55449
02:40:42 <cl1> is that a correct Functor implementation for ITree?
02:41:05 <cl1> no it is not
02:41:17 <Philippa_> in other news, multiple tornados (not Tornados) are making an attack on my island
02:42:16 <hpaste> cl1 annotated â€œITree functorâ€ with â€œITree functor (annotation)â€ at http://hpaste.org/55449#a55450
02:42:26 <cl1> okay, is that one correct
02:44:22 <Philippa_> do you mean g . a?
02:44:36 <Philippa_> (in the Leaf branch)
02:44:55 <cl1> the whole thing, i'm learning functors
02:45:17 <Philippa_> yeah, you picked a slightly awkward type to learn with because it's got functions in it :-)
02:45:44 <cl1> its one of the exercises here: http://www.haskell.org/haskellwiki/Typeclassopedia
02:45:47 <Philippa_> at a glance I'm not sure g a would typecheck, have you put it through a haskell implementation?
02:45:54 <Philippa_> fair enough
02:50:09 <cl1> no i haven't and apparently my Pair implementation won't compile either
02:50:09 <Philippa_> (what exactly do you intend to take g of?)
02:50:17 * cl1 goes back to the drawing board
02:50:33 <Philippa_> typecheck early, typecheck often :-) It helps figure out what you might've meant, too
02:50:44 <cl1> yes yes
02:51:28 <cl1> data Pair a = Pair a a
02:51:51 <cl1> how do i pattern match that to get the two values in Pair?
02:52:39 <quicksilver> f (Pair x y) = x + y
02:52:40 <quicksilver> e.g.
02:53:07 <cl1> that's what I thought,thanks
02:55:01 <newbee> can someone help in making a getInteger function
02:55:03 <newbee> ?
02:55:29 <Philippa_> doing what?
02:55:48 <newbee> It should get a integer from stdin and return it
02:57:01 <newbee> getInt = do {     n <- getLine;     let nn = read n::Int;     return nn; }
02:58:28 <newbee> this function when i use to generate a Integer list gives error "Couldn't match expected type `Int' against inferred type `IO Int'"
02:59:11 <newbee> how can I get a list of n integers from stdin
02:59:14 <newbee> ?
03:00:33 <newbee> I used getInt function along with this function "getlist n = if n==0 then [] else do getInt : getlist (n-1)"
03:01:05 <newbee> to input n integers from stdin
03:01:22 <Saizan> replicateM n getInt
03:02:21 <Saizan> or if you want to do it yourself: getlist n = if n == 0 then return [] else do i <- getInt; is <- getlist (n-1); return (i:is)
03:02:39 <ski> cl1 : that `fmap g (Leaf a) = Leaf (g a)' is not correct -- and neither is `fmap g Node xs = Node (fmap g xs)'
03:02:51 <ski> cl1 : neither are very far from fine, though
03:03:04 <cl1> ski: working on it :)
03:03:52 <ski> @wiki Introduction to IO
03:03:52 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
03:03:53 <Philonous_> unfoldWhileM (> 0) getLine
03:03:59 <ski> newbee : see that ^ link
03:04:15 <Philonous_> unfoldWhileM (> 0 :: Int) (read . getLine) -- rather
03:04:26 <Philonous_> unfoldWhileM (> 0 :: Int) (read <$> getLine) -- even rather
03:12:41 <newbee> thank you for the advices i tried all 3, i'm still struck with error messages :(
03:13:26 <Saizan> well, errors might come from elsewhere
03:13:43 <newbee> replicate n getInt, says "Couldn't match expected type `Int' against inferred type `String' "
03:14:06 <Saizan> you need replicateM
03:14:21 <Saizan> ?type replicateM
03:14:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:14:43 <Philonous_> You need to import Control.Monad , too
03:14:43 <Saizan> and n has to be an Int
03:14:49 <Saizan> yeah
03:14:55 <newbee> and "getlist n = if n==0 then [] else do i <- getInt; is <- getlist(n-1); return (i:is)" says "Couldn't match expected type `IO Int' against inferred type `[Int]'"
03:15:26 <Saizan> newbee: you forgot "return []" instead of "[]"
03:16:24 <newbee> Saizan: added return
03:16:29 <newbee> still same problem
03:16:40 <Saizan> there's a problem where you're using it then
03:16:51 <newbee> "Couldn't match expected type `Int' against inferred type `[a]'"
03:17:17 <Saizan> add a "getlist :: Int -> IO [Int]" signature over the definition, it'll probably point to the problem elsewhere
03:17:57 <Saizan> or, put your code on hpaste.org :)
03:19:10 <hpaste> newbee pasted â€œGet List - Haskellâ€ at http://hpaste.org/55452
03:19:21 <newbee> http://hpaste.org/55452
03:19:32 <Peaker> newbee: there's another way to write getlist, if you're interested (after you fix the type errors :)
03:19:56 <newbee> Peaker: I'll be glad to know that :)
03:19:56 <Peaker> newbee: you don't need the explicit type annotation on "nn"
03:20:00 <Saizan> yeah, the problem is in main
03:20:39 <newbee> Saizan: it is?
03:20:49 <hpaste> Saizan annotated â€œGet List - Haskellâ€ with â€œGet List - Haskell (annotation)â€ at http://hpaste.org/55452#a55453
03:21:16 <Saizan> newbee: try that ^^^
03:21:58 <newbee> "No instance for (Show (IO [Int]))"
03:22:27 <newbee> initially i had it that way only
03:22:43 <newbee> while trying out different things, i forgot to put it back
03:24:06 <Peaker> newbee: I annotated with a slight improvement
03:24:20 <Peaker> newbee: (no type annotations for read, and using pattern matching instead of if) but there's more improvement possible
03:24:26 <Saizan> newbee: does it work now? it typechecks fine here
03:24:51 <Saizan> newbee: the second version here i mean http://hpaste.org/55452#a55453
03:26:00 <hpaste> Peaker annotated â€œGet List - Haskellâ€ with â€œGet List - Haskell (annotation) (annotation)â€ at http://hpaste.org/55452#a55454
03:28:21 <Peaker> newbee_: The last annotation can be generalized to any readable type instead of Int, but may be harder to read before you're used to =<< and <$> :)
03:29:10 <newbee_> it worked once
03:29:17 <newbee_> now i'm getting "a.out: Prelude.read: no parse"
03:29:20 <newbee_> :(
03:30:56 <Saizan> that happens when you're feeding it malformed inputs
03:32:01 <newbee_> got it
03:32:13 <newbee_> i was giving inputs space separated
03:32:29 <Peaker> it didn't paste my annotation
03:32:38 <Peaker> Saizan: and partial-everywhere prelude functions :(
03:32:44 <hpaste> Peaker annotated â€œGet List - Haskellâ€ with â€œGet List - Haskell (annotation) (annotation) (annotation)â€ at http://hpaste.org/55452#a55455
03:33:35 <Peaker> newbee_: your implementation of getlist can be generalization to any action, rather than just "getInt", and it becomes replicateM (which too can be composed from sequence and replicate)
03:33:41 <Peaker> generalized*
03:35:09 <newbee_> thanks, both the implementations are working :)
03:37:08 <Peaker> newbee_: note that if you remove the type signature -- and look at the type, you see that "getInt" works for any type, and so does getList
03:37:16 <Peaker> (rather than be specific to ints)
03:37:49 <newbee_> thanks :)
03:38:08 <Peaker> actually, the god-damn monomorphism restriction will make getInt be int-specific in my code due to its use as the input for replicateM (which is an int)
03:38:18 <Peaker> but if you disable the MR you get the sane, general type :)
03:47:39 <sefb1704> hey
03:48:55 <frerich> > subsequences []
03:48:56 <lambdabot>   [[]]
03:49:16 <frerich> Does anybody know the reasoning behind that? Why is the empty list a subsequence of any other list, even of itself?
03:49:26 <AfC> I'm trying to use a library that uses Control.Failure; can someone suggest a code snippet that shows how to handle errors raised by such a library?
03:49:53 <byorgey> frerich: is [1,2,3] a subsequence of [1,2,3]?
03:50:04 <sefb1704> what is wrong about: if (a == 1) putStrLn "a exists and"; if (b == 1) putStrLn "b exists and"; if (c == 1) putStrLn "c exists." ? error message: parse error (possibly incorrect indentation)
03:50:27 <byorgey> sefb1704: if must always have an accompanying else
03:50:29 <ben> sefb1704: you always need a "then" and "else" for if, it looks like you want "when (a == 1) $ putStrLn ..."
03:50:52 <ben> @type when
03:50:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:51:05 <sefb1704> ah yes, i guess when is good..
03:51:05 <frerich> byorgey: No, but [] is, I think:
03:51:09 <frerich> > subsequences [1,2,3]
03:51:09 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
03:51:22 <frerich> byorgey: Oh, it *is* a subsequence.
03:52:11 <byorgey> frerich: the point is that the notion of "subsequence" includes that every list is a subsequence of itself.
03:52:27 <frerich> Ah...
03:52:39 <ben> > take 10 . subsequences $ repeat ()
03:52:41 <lambdabot>   [[],[()],[()],[(),()],[()],[(),()],[(),()],[(),(),()],[()],[(),()]]
03:52:48 <sefb1704> Not in scope: when :(
03:52:53 <ben> Control.Monad
03:52:58 <ben> sorry, I forgot :)
03:53:19 <sefb1704> where do i have to write Control.Monad?
03:53:20 <byorgey> you could of course define the notion of "proper subsequence" which does not include the list itself
03:53:22 <sefb1704> at the top?
03:53:32 <ben> Sorry, import Control.Monad at the top of your program
03:53:38 <sefb1704> ah okey thanks ben
03:54:09 <frerich> byorgey: I see that if every list is a subsequence of itself, then [] is a subsequence of [], but why is [] a subsequence of [1]?
03:54:36 <byorgey> frerich: how would you define subsequence?
03:54:36 <ben> > [] `isPrefixOf` [1]
03:54:37 <lambdabot>   True
03:54:50 <byorgey> I mean intuitively, not how would you code it
03:54:55 <arw> frerich: mostly to get some nice mathematical properties.
03:55:04 <frerich> byorgey: I mean, why is it "conveinent" for the caller
03:55:17 <frerich> I guess there must be something handy about this.
03:55:39 <byorgey> it's not about convenience, it's about elegance.
03:55:44 <arw> frerich: like '1' is part of the factorization of every integer.
03:56:02 <byorgey> for example the connection to isPrefixOf that ben showed.
03:56:42 <frerich> Hmm
03:56:46 <byorgey> also, if  x ++ y == z, then subsequences x and subsequences y  are both subsets of subsequences z
03:57:02 <byorgey> even if x or y is the empty list
03:58:30 <byorgey> arw: more like how if you wrote a function to give you all the divisors of a number, you would want it to include 1.
03:59:33 <byorgey> frerich: also, if [] is a subsequence of itself, then the most natural recursive way to define subsequences means that [] is a subsequence of every list
03:59:45 <byorgey> otherwise [] is a weird special case
03:59:49 <arw> byorgey: didn't I say that?
04:00:34 <byorgey> arw: I usually think of 'factorization' as meaning the list of prime divisors
04:01:18 <byorgey> i.e. factorization 12 -> [2,2,3]; divisors 12 -> [1,2,3,4,6,12]
04:01:58 <arw> hrm, yes, you are right.
04:02:20 <hpaste> cl1 annotated â€œITree functorâ€ with â€œITree functor (annotation2)â€ at http://hpaste.org/55449#a55456
04:02:31 <arw> the 'prime' requirement of course makes a difference.
04:02:41 <cl1> do my functor implementations look correct?
04:04:04 <byorgey> cl1: does it type check?
04:04:16 <cl1> byorgey, what does that mean?
04:04:30 <cl1> i can load it into ghci if that's what you are asking
04:04:34 <byorgey> cl1: I mean does ghc accept it?
04:04:36 <byorgey> yes
04:04:53 <cl1> ghci will load it
04:05:12 <byorgey> cl1: you have to work very hard to make a Functor instance which type checks but is not correct =)
04:05:28 <byorgey> (in other word, yes, it looks correct =)
04:05:36 <cl1> good
04:06:09 <byorgey> cl1: however, the type you wrote for fmap' in a comment is not correct
04:06:34 <cl1> i should have deleted that, it was trash left over from me trying to think
04:06:40 <byorgey> ok =)
04:07:38 <yitz> > map length . fix $ subsequences . (():) . concat
04:07:40 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
04:07:41 <byorgey> cl1: "type check" just means that you do not get any type errors
04:08:04 <cl1> byorgey, I will remember that for future reference
04:08:05 <byorgey> also sometimes one word, "typecheck"
04:08:11 <ski> cl1 : looks fine
04:08:23 <cl1> does Int satisfy this : Give an example of a type which cannot be made an instance of Functor (without using undefined).
04:08:47 <cl1> I have no answer key to look and see if i'm correct, or else I would just do that instead of pestering y'all
04:08:55 <byorgey> cl1: well, yes, because it has the wrong kind
04:09:17 <cl1> i wasn't sure because I don't know what (without using undefined) is
04:09:39 <byorgey> cl1: that question really ought to say "an example of a type of kind * -> * which cannot..."
04:09:54 <yitz> @. oeis run map length . fix $ subsequences . (():) . concat
04:09:56 <lambdabot>  Sequence not found.
04:10:12 <byorgey> cl1: "undefined" is the undefined value which has any type
04:10:28 <cl1> Set
04:10:30 <byorgey> cl1: you can use it to implement anything but it's cheating
04:11:06 <cl1> Set cannot be an instance of Functor because it requires an Ord constraint on its elements
04:11:35 <byorgey> cl1: true
04:12:00 <byorgey> cl1: can you think of something that does not involve constraints?
04:14:37 * cl1 is thinking
04:15:48 * byorgey fixes the question
04:16:32 <ski> cl1 : well, i'd say no, because it has the wrong kind, so the question "Is `Int' an example of <above> ?" isn't even a meaningful question (it's neither true nor false, it's meaningless -- or type-incorrect (or rather kind-incorrect), if you like :)
04:16:32 <ski> cl1 : for a type to make sense as an answer, it ought to have kind `* -> *', imo, so you should look for such a type, which can't be made an instance of `Functor' (satisfying the functor law)
04:16:46 * hackagebot uuagc-bootstrap 0.9.40.2 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.40.2 (JeroenBransen)
04:17:04 <ski> whee
04:20:32 <newbee> can we print the value of string variable without quotes around it?
04:20:41 <cl1> ski: I have already mentioned Set, but byorgey said I should find another (Set is mentioned in the tutorial)
04:21:00 <yitz> > text "yes" -- newbee
04:21:01 <lambdabot>   yes
04:21:20 <hpc> :t putStrLn -- better, if you are using "print"
04:21:22 <lambdabot> String -> IO ()
04:21:24 <newbee> yitz: how?
04:21:25 <cl1> i cannot think of another, I don't know enough types
04:21:39 <yitz> newbee: like hpc said
04:21:51 <yitz> @. oeis run text . init . tail . show . take 10 . map length . fix $ subsequences . (():) . concat
04:22:00 <byorgey> cl1: just make up your own
04:22:02 <lambdabot>  1's-counting sequence: number of 1's in binary expansion of n (or the binary...
04:22:02 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
04:22:18 <ski> newbee : i'm not sure what you want to do ..
04:22:29 <ski> cl1 : well, you do know functions, i hope
04:22:30 <byorgey> cl1: like for example  Char -> a  (but that is not an answer)
04:22:41 <yitz> thanks oeis. that sequence sure looked mysterious to me, but now that makes sense.
04:22:54 <newbee> was using print for output of variables
04:23:14 <hpc> @src print
04:23:14 <lambdabot> print x = putStrLn (show x)
04:23:17 <newbee> it prints quotes around string values
04:23:22 <hpc> > "string"
04:23:23 <lambdabot>   "string"
04:23:34 <hpc> > show "string" -- why it has quotes
04:23:35 <lambdabot>   "\"string\""
04:25:10 <newbee> print works on string array also, but putStrLn doesnt
04:25:22 <ski> > fix $ \ns -> ((0 :) . drop 1) (ns /\/ map succ ns)  -- yitz
04:25:24 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
04:25:26 <cl1> data Foo a = Foo (a -> Int) ?
04:25:29 <newbee> what can we do for string array then?
04:26:00 <yitz> ski: /\/ ??
04:26:21 * hackagebot uuagc 0.9.40.2 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.40.2 (JeroenBransen)
04:26:29 <ski> (morally, `let ns = (0:_) `unamb` (ns /\/ map succ ns) in ns')
04:26:40 <xplat> print or fmap putStrLn
04:26:46 <ski> > [0,3 ..] /\/ [1,4 ..]  -- yitz
04:26:48 <lambdabot>   [0,1,3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,31,33,34,36,37,39,...
04:27:09 <yitz> ah
04:27:20 <ski> > fix $ \ns -> repeat 0 /\/ map succ ns
04:27:22 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
04:27:47 <yitz> ski: is that in some library, or did someone @let it?
04:28:06 <xplat> that last one is the 'which bit changes in Gray code' sequence
04:28:56 <ski> > map (fix $ \loop n -> case n `divMod` 2 of (n,0) -> 1 + loop n; (_,1) -> 0) [1 ..]
04:28:57 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
04:28:59 <yitz> wow freenode really seems to be under attack today.
04:29:14 <ski> xplat : aka the exponent of `2' in the prime factorization
04:29:20 <russellw> Under attack?
04:29:39 <yitz> russellw: netsplitting every couple of minutes
04:29:45 <russellw> ah!
04:30:05 <xplat> ski: indeed
04:30:10 <ski> yitz : i just `let'ed `(/\/)', privately
04:30:25 <yitz> ski: ah ok. nice operator.
04:30:49 <ski> i might have seen it in "The Craft", i'm not sure
04:30:53 <cl1> sk: byorgey: data Foo a = Foo (a -> Int)
04:31:02 <xplat> i didn't realize you could have '\' in operators
04:31:19 <ski> cl1 : what's the argument that it can't be an instance of `Functor' ?
04:31:31 <mux> > [1..10] \\ [1,3..10]
04:31:32 <lambdabot>   [2,4,6,8,10]
04:31:51 <cl1> because you can't pass Int into (a -> b)
04:31:54 <cl1> ?
04:32:21 <ski> well, you have `a -> Int', not `a -> b'
04:32:31 <ski> and passing `Int' here or not isn't very relevant
04:32:45 <ski> first, what would be the concrete type of `fmap', for this `Foo' ?
04:32:54 <xplat> @djinn (a -> b) -> (a -> Int) -> (b -> Int)
04:32:55 <lambdabot> Error: Undefined type Int
04:33:04 <xplat> @djinn (a -> b) -> (a -> Integer) -> (b -> Integer)
04:33:04 <lambdabot> Error: Undefined type Integer
04:33:07 <yitz> (the answer is because that is a *contravariant* functor)
04:33:13 <xplat> @djinn (a -> b) -> (a -> c) -> (b -> c)
04:33:13 <lambdabot> -- f cannot be realized.
04:33:49 <byorgey> yitz: that is *an* answer but, I suspect, not a helpful one for cl1 =)
04:34:11 <xplat> djinn knows where it's at.  or isn't, in this case
04:34:20 <yitz> byorgey: i know it won't be very helpful here. but i think that's the real answer.
04:34:24 <cl1> ((a -> Int) -> (b -> Int)) -> f (a -> Int) -> f (b -> Int)?
04:34:30 <ski> cl1 : no
04:34:40 <ski> start from the generic type of `fmap', i.e.
04:34:52 <cl1> (a -> b) -> f a -> f b
04:34:56 <ski> yes
04:35:01 <ski> or, if one's really explicit
04:35:08 <ski>   fmap :: forall a b. (a -> b) -> f a -> f b
04:35:17 <ski> (but that doesn't matter so much, here)
04:35:27 <ski> then, in our particular case, `f' is what ?
04:35:35 <cl1> Foo
04:35:49 <ski> yes, so what does the type signature become, then ?
04:35:53 <cl1> (a -> b) -> Foo a -> Foo b
04:35:56 <ski> yes
04:36:08 <ski> so, this maybe doesn't say very much
04:36:24 <byorgey> now expand the definition of Foo
04:36:26 <ski> we know that a `Foo x' is basically a `x -> Int', though
04:36:35 <cl1> correct
04:36:39 <ski> if you wanted to, you could use a helper, like
04:36:57 <ski>   fmap f (Foo ai) = Foo bi
04:37:00 <ski>     where
04:37:09 <ski>     bi = helper f ai
04:37:21 <ski> and where the task is now to write `helper'
04:37:30 <ski> so, what would the type signature of `helper' be, here ?
04:38:12 <ski> (what the above does is just to unwrap the `Foo' data constructor in the input, and rewrap the result from `helper' back into the `Foo' data constructor -- this is just to make it more clear in `helper' what would need to be done)
04:38:18 <cl1> (a -> b) -> a -> b
04:38:36 <ski> if you prefer, you can ignore this `helper' and imagine that `Foo x' is the same type as `x -> Int', for any `x'
04:38:39 <ski> cl1 : no
04:39:01 <cl1> Foo a -> b
04:39:02 <cl1> ?
04:39:09 <ski> so, either give the type of helper, or give the type of `fmap', when you "imagine that `Foo x' is the same type as `x -> Int', for any `x'", so that you don't mention `Foo' anymore in the type
04:39:14 <ski> no
04:39:20 <ski> ok
04:39:30 <ski> first, what's the type of `f' in the snippet above ?
04:39:48 <cl1> Foo?
04:40:00 <ski> let's look at
04:40:09 <ski>   fmap :: (a -> b) -> Foo a -> Foo b
04:40:17 <_Mikey> [a]->[a]
04:40:18 <ski> now look at
04:40:25 <ski>   fmap f (Foo ai)
04:40:30 <_Mikey> @hoogl [a]->[a]
04:40:30 <lambdabot> Maybe you meant: hoogle hoogle+
04:40:37 <ski> the type of `f' must be the argument type in the type of `fmap'
04:40:49 <_Mikey> @hoogle[a]->[a]
04:40:49 <lambdabot> Unknown command, try @list
04:40:55 <_Mikey> @hoogle [a]->[a]
04:40:56 <ski> (and the type of `Foo ai' must be the next argument type)
04:40:56 <lambdabot> Prelude cycle :: [a] -> [a]
04:40:56 <lambdabot> Data.List cycle :: [a] -> [a]
04:40:56 <lambdabot> Prelude init :: [a] -> [a]
04:41:12 <cl1> helper :: (a -> b) -> a -> b
04:41:27 <ski> (and the type of the whole `fmap f (Foo ai)', which is the same as the type of `Foo bi', must be the result type)
04:41:31 <ski> ok, let's take a step back
04:41:34 <ski> let's consider
04:41:40 <ski>   bar :: A -> B
04:41:44 <ski> and we're looking at
04:41:49 <ski>   bar (frob x)
04:41:56 <ski> what's the type of `frob x' ?
04:42:13 <cl1> B?
04:42:19 <ski> no, that's the result type
04:42:22 <cl1> or is it A -> B?
04:42:30 <ski> no, that's the type of `bar'
04:42:30 <cl1> oh, A
04:42:32 <ski> yes
04:42:59 <marijn`> is there any paper/overview/blog post about the low-level representation GHC uses for the dictionaries it passes (for type classes)?
04:43:04 <ski> `frob x' is here the argument to `bar', so the type of it must be the argument type in the type of `bar' which is `A -> B', which is `A'
04:43:22 <ski> similarly, the type of the *whole* expression `bar (frob x)' is here -- is what ?
04:43:51 * wereHamster raises his hand
04:44:02 <cl1> B
04:44:10 <newbee> how can we display different elements of a list in separate line without quotes?
04:44:24 <ski> wereHamster : not you, you've already answered many questions today
04:44:26 <ski> ;)
04:44:28 <ski> cl1 : yes
04:44:36 <wereHamster> not here. I barely know haskell
04:44:37 <ski> cl1 : now, consider this example
04:44:48 <newbee> I tried this function "printlist lst n = do {     if n>0 then do { printlist (n-1); }     putStrLn (lst !! n); }"
04:44:53 <ski>   x :: (Int,String)
04:45:04 <ski>   baz [x,x] :: Bool
04:45:10 <ski> cl1 : what's the type of `baz' ?
04:46:05 <cl1> Bool?
04:46:12 <ski> wereHamster : yeah, i was just joking :)
04:46:16 <wereHamster> [] -> Bool ?
04:47:02 <ski> cl1 : we can see that `baz' is applied to an argument here, so `baz' must be a function, so it must have a type of basic shape `... -> ...', so it can't be `Bool', no
04:47:44 <ski> > False 3  -- see, applying a `Bool' to an argument isn't going to work
04:47:45 <lambdabot>   Couldn't match expected type `t1 -> t'
04:47:46 <lambdabot>         against inferred type `GHC.B...
04:48:03 <cl1> [((Int,String),(Int,String))] -> Bool
04:48:09 <ski> almost :)
04:48:47 <cl1> [(Int,String)] -> Bool?
04:49:05 <ski> `((Int,String),(Int,String))' there is a type of pairs of two pairs, both having the same type : first component being `Int', and second `String'
04:49:08 <ski> cl1 : yeah :)
04:49:34 <cl1> so you don't always need parenthesis when using tuples
04:49:40 <cl1> [x,x] threw me off
04:50:02 <ski> cl1 : so, my point here is : you should exercise being able to go from type of `bar' to type of result `bar (frob x)' and type of argument `frob x' here
04:50:34 <ski> cl1 : *and* you should exercise beingh able to go from type of argument `x' and type of result `baz [x,x]', to type of the function `baz'
04:50:51 <wereHamster> it's all simple substitution :)
04:51:07 <ski> cl1 : well, in `[x,x]', `x' itself *is* a tuple (a pair)
04:51:26 <ski> cl1 : only when you're writing a "concrete" tuple should you write brackets and commans
04:51:50 <ski> cl1 : whis is similar to that if `xs' is a list, then you don't write `[' and `]', `xs' is a list in itself
04:51:53 <wereHamster> [x,x] is a list with two elements, where each of those element is x
04:52:05 <ski> only if you're writing a concrete list, in terms of elements, do you use `[',`]'
04:52:12 <cl1> ski: so then why is the type [(Int,String] instead of [((Int,String),(Int,String))] for baz [x,x] :: Bool
04:52:26 <ski> cl1 : because the type of all elements in a list have to be the same
04:52:28 <mux> the latter makes no sense
04:52:30 <ski> if we have
04:52:33 <ski>   [a,b,c,d]
04:52:34 <mux> lists are homogeneous
04:52:46 <ski> then all of `a',`b',`c',`d' has to have the same type, say `X'
04:52:52 <cl1> nm, i'm being dumb, i should probably get some sleep
04:52:59 <ski> and then the whole list has a type which is written like `[X]'
04:53:09 <cl1> so its [(Int,String)] because that's what type x has
04:53:38 <cl1> yeah, i should put this down for the night, i'm pushing myself too hard today if i missed that bit right there
04:53:59 <ski> cl1 : anyway, from knowing that `fmap :: (a -> b) -> Foo a -> Foo b', and seeing the definition of `fmap' above in terms of `helper' (and from knowing how `Foo' was defined), you should be able to see/derive what the type of `helper' must be
04:54:12 <ski> cl1 : ok, no worry
04:54:29 <cl1> ski: i wrote it down, maybe I can pick that bit up later
04:54:33 <ski> ok
04:55:57 <ski> cl1 : good night. and good luck :)
05:02:47 <joe9> has anyone tried haskell-platform 2011.4 with ghc 7.2.2? I can install it with the --ghc-unsupported-version, but, am not sure how it works in practice.
05:07:46 <stevo> hey could anyway help me out with how  to split a 4node recurisvely in a 234 tree?
05:08:04 <stevo> anyone*
05:11:31 <stevo> anyone?
05:14:00 <JuanDaugherty> stick around stevo, this channel is a sucker for homework questions like that
05:16:09 <ski> stevo : what have you tried, so far ?
05:17:20 <stevo> the idea i had was to check before a insertion that there is a 4 node there and then not have to worry about recursively inserting all the elements again
05:17:44 <stevo> im just a bit stumped in how your supposed to "remember" what all the elements are
05:18:38 <stevo> http://pastebin.com/zJKAe7bM
05:18:40 <mauke> The paste zJKAe7bM has been copied to http://hpaste.org/55457
05:20:45 <ski> @karma+ maukebot
05:20:45 <lambdabot> maukebot's karma raised to 1.
05:24:02 <stevo> what do you think ski?
05:24:25 <_Mikey> hey guys
05:24:30 <_Mikey> is there something like zip
05:24:38 <_Mikey> to make a 3 tuple
05:24:57 <_Mikey> if I already have a list of tuples
05:25:13 <_Mikey> or something that takes three lists
05:25:59 <_Mikey> @hoogle [a]->[b]->[c]->[(a,b,c)]
05:26:00 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
05:26:00 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
05:26:07 <_Mikey> winning!
05:26:22 * hackagebot attosplit 0.1.0.0 - Split a lazy bytestring at boundaries defined by an attoparsec parser  http://hackage.haskell.org/package/attosplit-0.1.0.0 (YitzGale)
05:26:24 <ski> stevo : well, i haven't looked at 2-3-4-trees (or even 2-3-trees) in detail, but i suppose that looks ok, so far
05:26:51 <_Mikey> ski?
05:27:10 <stevo> ski: well the problem i have is really how i move on from where i am and that involves splitting up nodes which is a bit of a head wreck
05:27:22 <ski> stevo : you need to add cases for adding into a `FourNode x y z leftLeft middleLeft middleRight rightRight', as well
05:27:25 <_Mikey> do you know much about graphs?
05:27:35 <ski> what kind of graphs ?
05:27:43 <_Mikey> Data.Graph graphs?
05:28:43 <ski> @type graph :: (a -> b) -> (a -> (a,b))  -- this kind ?
05:28:44 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
05:28:47 <ski> hum
05:29:05 <ski> _Mikey : no, i don't know very much about those
05:29:13 <_Mikey> ahh, ok
05:29:42 <_Mikey> I've just got a weird hunch I'm going about this the wrong way
05:29:46 <benmachine> :t (id &&&)
05:29:47 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
05:29:58 * ski peeks at <http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.1.0/Data-Graph.html>
05:30:03 <ski> @type graph
05:30:04 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
05:30:10 <ski> @type cograph
05:30:11 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
05:30:38 <frerich> ski: For the Graph-challenged among us - how is (a -> b) -> (a -> (a,b)) a graph?
05:31:29 <_Mikey> the kind I'm using is actually (a,b,[a])
05:31:51 <_Mikey> where [a] is a list of nodes it connects to
05:32:23 <ski> frerich : the graph of a function from `A' to `B' can be thought of as a binary relation from `A' to `B' -- or, equivalently, a subset of `A * B'
05:32:32 <ski> (where `*' is cartesian product of sets)
05:32:45 <ski> (so, `(A,B)', in Haskell terms)
05:33:35 <ski> frerich : a subset of a set `X' can be represented as a "domain" set `S' and an injective function from `S' to `X' -- which set `S' is chosen doesn't matter
05:34:04 <ski> frerich : so, in this case `a -> (a,b)' is an injective function from `a' to `(a,b)', which acts like a subset of `(a,b)'
05:34:22 <ski> (if you will, the subset is the image of this injective function)
05:34:36 <_Mikey> hmm
05:35:10 <ski> _Mikey : actually, that's a type, not a kind
05:35:22 <_Mikey> oh
05:35:45 <ski> so, are you using `Data.Graph.stronglyConnComp' ?
05:36:03 <ski> frerich : ok ?
05:36:08 <_Mikey> I'm not using it, but I believe my Graph is strongly Conn
05:36:35 <ski> ok
05:36:46 <hpaste> â€œ_Mikeyâ€ pasted â€œGraphStructureâ€ at http://hpaste.org/55458
05:37:02 <_Mikey> this is the structure of my graph
05:37:17 <_Mikey> I'm currently using different types for the nodes
05:37:45 <_Mikey> my question is I want to move a node to a different position in the graph
05:38:13 <_Mikey> being immutable I need to greate a function graph -> foo -> graph
05:38:43 <_Mikey> I'm slowly getting there but I'm wondering shouldn't there be a function within Data.Graph that does this?
05:41:30 <_Mikey> @hoogle Graph ->Graph
05:41:30 <lambdabot> Data.Graph transposeG :: Graph -> Graph
05:41:39 <_Mikey> seriously ;/
05:41:58 <_Mikey> @hoogle Graph ->Vertex ->Vertex ->Graph
05:41:59 <lambdabot> No results found
05:45:27 <ClaudiusMaximus> _Mikey: maybe 'fgl' would be better than 'containers' for a graph library?
05:45:31 <ClaudiusMaximus> @hoogle nmap
05:45:32 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
05:45:32 <lambdabot> Test.QuickCheck.Function functionMap :: Function b => (a -> b) -> (b -> a) -> (a -> c) -> (a (:->) c)
05:45:32 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans ReflectionMap :: TextureGenMode
05:46:05 <ski> _Mikey : possibly it would be nice if one could use zippers to traverse a graph, and modify it -- i don't see operations for any such there, though
05:46:24 <ski> (try ClaudiusMaximus' suggestion ?)
05:46:31 <ClaudiusMaximus> @hackage fgl
05:46:31 <lambdabot> http://hackage.haskell.org/package/fgl
05:46:33 <_Mikey> ClaudiusMaximus,  possibly.
05:46:37 <_Mikey> I'll give it a go
05:46:44 <_Mikey> cheers
05:47:04 <_Mikey> yes!
05:47:09 <_Mikey> zippers would be perfect
05:49:04 <stevo> okay im still pretty much stumped by this splitting function =S
05:49:45 <_Mikey> what I'm doing now is some pretty weird chain of functions
05:50:02 <_Mikey> spliting a list of nodes and swapping elements in the list
05:50:12 <_Mikey> then concatting the list
05:50:22 <_Mikey> then rezipping up to recreate the graph
05:50:55 <_Mikey> Data.Graph.Inductive seems to have those examples though :)
05:51:38 <ClaudiusMaximus> are you just relabelling some nodes?  i think nmap does that
05:52:15 <_Mikey> swapping the information at nodes
05:52:27 <_Mikey> but I guess relabelling works.
05:53:22 <ClaudiusMaximus> you could define nswap a b = nmap (\n -> case () of ()| n == a = b | n == b = a | otherwise = n)
05:54:49 * benmachine would write that as fromMaybe n (lookup n [(a,b),(b,a)])
05:54:50 <ClaudiusMaximus> oops, missyntax, but anyway
05:55:12 <ClaudiusMaximus> yes, much sensibler
05:57:07 <_Mikey> ClaudiusMaximus,  hmm that makes alot of sense
05:57:13 <_Mikey> I'll give it ago in a bit
05:58:39 <ski> stevo : you haven't said what you're stumped on
05:59:41 <stevo> splitting a node recurisvely. In the 234 tree when you meet a fournode during a insertion you have to go about rearrange the pretty much all the previous nodes
06:01:30 <ski> stevo : yeah, but i don't really know how 2-3-4-trees work
06:01:47 <ski> if there's any particular code you have trouble with, i could take a look
06:02:17 <nand`> Any built-in function of the type (c -> d) -> (a -> b -> c) -> (a -> b -> d) that works like (.) but on dyadic functions? eg. dot x y a b = x $ y a b
06:04:43 <stevo> does anyone have experience with B-Trees by any chance?
06:05:41 <Jeanne-Kamikaze> experience as in implementing them ?
06:06:01 <benmachine> > Node 'B' [Node 'B' [], Node 'B' [Node 'B' [], Node 'B' []]]
06:06:02 <lambdabot>   Node {rootLabel = 'B', subForest = [Node {rootLabel = 'B', subForest = []},...
06:06:03 <stevo> yeah
06:06:07 <Jeanne-Kamikaze> nope sorry
06:07:16 <org> @help
06:07:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:07:26 <org> @help list
06:07:26 <lambdabot> list [module|command]
06:07:26 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
06:07:49 <org> @run 3+5
06:07:50 <lambdabot>   8
06:08:43 <org> @pl f x = x+3
06:08:43 <lambdabot> f = (3 +)
06:09:06 <org> @pl f x = 3+x
06:09:06 <lambdabot> f = (3 +)
06:09:24 <org> @pointful f = (3+)
06:09:24 <lambdabot> f a = 3 + a
06:11:15 <lmatos> What is the easiest way to tell if I have 32-bit or 64-bit haskell installed? I'm looking to upgrade to the latest Haskell Platform.
06:17:05 <ksf> you know, sometimes having no proper language support for extending sum types is a real pain.
06:18:32 <ksf> (it's also kinda lame that we don't habitually use XML schema as types)
06:19:26 <hvr> lmatos: $ ghc +RTS --info | grep Word
06:19:48 <ksf> let's say I want to implement some xml doc format. I write a xml-enumerator parser for it, and then notice that the whole thing consists of two namespaces: the base one, and a teeny weeny extension to it, adding a single element.
06:20:41 <ksf> ...so I have to add some extension field in the ADT of the base namespace, and the resulting application code then smells.
06:21:07 <ksf> ...nesting a sum type in a sum type.
06:21:42 <ksf> actually, nesting a sum type in a sum type in a sum type.
06:22:00 <ksf> first the base type, then a namespace selector, then the type for the selected namespace.
06:26:56 <lmatos> hvr: thanks a bunch!
06:30:57 <mm_freak> now that GHC automatically promotes types to the kind level, the only missing thing is to promote functions to the type level =)
06:31:52 <ksf> mm_freak, feel like writing a hlist-thingie that can express pushdown grammars on the type level?
06:32:03 <heiz> Hi! Tell me please how can I get HandleStream? I want to use Network.HTTP.receiveHTTP...
06:32:11 <mm_freak> ksf: i don't know what that is
06:32:14 <ksf> though I think nested word is more than enough. if everything else fails, regex and an escape.
06:32:36 <ksf> mm_freak, an XML schema at the type level.
06:32:44 <mm_freak> ah
06:32:46 <marijn`> can anyone say whether the approach outlined in "Dictionary-free Overloading by Parial Evaluation" by Mark Jones is actually being used today? or do implementations stick closely to Wadler's original outline of dictionary-passing?
06:32:50 <mm_freak> what would you need that for?
06:33:10 <ksf> hlist can do records, and I guess repetition, too, but xml can do stuff like "two to three of those elements"
06:33:44 <ksf> mm_freak, currently I'm annoyed by ADTs being so much more inflexible than xml
06:34:00 <mm_freak> ksf: huh?  they're not
06:34:14 <mm_freak> what you want sounds like ordinary lists to me
06:34:28 <mm_freak> almost ordinary
06:34:38 <ksf> well, yes, they can express any xml *value*. but take xrd and host-meta, for example.
06:34:49 <Saizan> marijn`: haven't read that paper, but GHC tries to compile the dictionary passing away
06:34:52 <ksf> host-meta takes the xrd schema and adds a single tag in its own namespace.
06:35:27 <ksf> you have to a) take extensibility into account while coding the xrd ADT and b) then suffer pain using the combined abomination.
06:35:31 <mm_freak> ksf: data VecFromTo :: Nat -> Nat -> * -> *
06:35:59 <mm_freak> i'll have a look into it laterâ€¦  gotta go now
06:36:14 <marijn`> Saizan: cool, that's useful to know (if you have links to any relevant papers or resources handy, i'd love to see them)
06:36:25 * hackagebot monad-par 0.1.0.3 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.1.0.3 (SimonMarlow)
06:36:29 <ksf> hmmm, yes. groceries.
06:36:51 <Saizan> marijn`: nope, though you might find something in ghc's commentary on its trac
06:39:12 <heiz> So what about my question? How is it possible to get HandleStream?
06:41:25 * hackagebot snaplet-tasks 0.1.2 - Snaplet for Snap Framework enabling developers to administrative tasks akin to Rake tasks from Ruby On Rails framework.  http://hackage.haskell.org/package/snaplet-tasks-0.1.2 (KamilCiemniewski)
06:41:33 <geheimdienst> hmm, i dimly recall that n+k was thrown out in haskell 2010? but this seems to say the opposite: "n+k pattern support is enabled by default. To disable it, you can use the -XNoNPlusKPatterns flag", from http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html#n-k-patterns
06:42:16 <ksf> ghc doesn't do strict h2010 if you don't specify it, possibly?
06:42:41 <stevo> okay i want to make a function which checks to see if a node is present , how would i go about doing that?
06:43:00 <geheimdienst> ksf, that's possible ...
06:43:26 <Saizan> heiz: check the HStream class, it has methods to create them
06:43:41 <heiz> thanks
06:44:11 <ski> @tell hsf yes, sometimes subtyping (<http://www.haskell.org/haskellwiki/O'Haskell>), alternatively row polymorphism a la "polymorphic variants" in O'Caml (<http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc36>), or maybe some kind of module mixins (<http://www.mpi-sws.org/~rossberg/mixml/>), or possibly refinement types (<http://www.cs.ucla.edu/~palsberg/tba/papers/freeman-thesis94.pdf>)
06:44:11 <lambdabot> Consider it noted.
06:44:56 <ksf> ski, was that addressed at me?
06:45:12 <ski> um, actually it was
06:45:22 <hsf> @messages
06:45:22 <lambdabot> ski said 1m 11s ago: yes, sometimes subtyping (<http://www.haskell.org/haskellwiki/O'Haskell>), alternatively row polymorphism a la "polymorphic variants" in O'Caml (<http://caml.inria.fr/pub/docs/
06:45:22 <lambdabot> manual-ocaml/manual006.html#toc36>), or maybe some kind of module mixins (<http://www.mpi-sws.org/~rossberg/mixml/>), or possibly refinement types (<http://www.cs.ucla.edu/~palsberg/tba/papers/
06:45:22 <lambdabot> freeman-thesis94.pdf>)
06:45:30 <ski> ty
06:45:49 <ski> just some links you might find interesting to look into
06:46:16 <ksf> well, I'm aquainted with the general topic, and with the pain involved on ghc's type level.
06:50:58 <xplat> ksf: you might want to look into cduce if you're doing simple transformations on schematized xml
06:52:06 <xplat> it fails at straight-up parametric polymorphism, but it's great at things like that
07:04:48 <etpace_> Hmm... If I have a Test.Test file that depends on some external file (always stored in Test/datafile, next to my Test/Test.hs) how can I make it such that Test.Test can always find datafile? Is there a way to find the directory of the current script? Or what's the "correct" way?
07:11:25 * hackagebot parallel 3.2.0.2 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.2.0.2 (SimonMarlow)
07:15:52 <unsafePerformIO> I try to write a typeclass for 'w' of kind *, as "class w | w -> e where getEvents :: w -> e". So the type 'e' is unique for 'w'. But I get "Not in scope: type variable `e`". Should I remove "| w -> e"?
07:16:47 <ceilingcat> unsafePerformIO: i'm watching you, dude. very closely.
07:16:54 <quicksilver> you need 3 to be a paramter of the class.
07:16:56 <quicksilver> e
07:17:13 <quicksilver> as in class SomeClass w e | w -> e where getEvents :: w -> e
07:17:23 <unsafePerformIO> quicksilver: so 'w' must be of kind * -> *?
07:17:37 <quicksilver> no, w is of kind *
07:18:02 <quicksilver> 'e' is not a paramter of 'w'
07:18:09 <quicksilver> both 'e' and 'w' are parameters of SomeClass
07:18:23 <unsafePerformIO> quicksilver: I thought "w e" meant e applicated on w
07:18:29 <ceilingcat> etpace_: try this maybe http://hackage.haskell.org/package/system-argv0-0.1
07:18:43 <xplat> unsafePerformIO: application associates left, not right
07:18:46 <quicksilver> unsafePerformIO: "w e" on its own would mean that, yes.
07:18:59 <quicksilver> unsafePerformIO: but "SomeClass w e" means that SomeClass has two parameters, w and e
07:19:43 <unsafePerformIO> quicksilver: ok, so I could likewise have written "SomeClass e w"?
07:21:48 <xplat> unsafePerformIO: sure, that's the same parameters in a different order
07:21:55 <Philonous_> unsafePerformIO:  You can swap the parameters if you do so everywhere, yes
07:22:23 <unsafePerformIO> now it is working at least. thank you
07:24:25 <unsafePerformIO> btw: do we say "f applicated on x" or "x applicated on f" for f(x)?
07:24:44 <xplat> neither
07:24:55 <xplat> f applied to x
07:24:57 <Botje> f applied to x
07:25:14 <tromp> f of x
07:25:20 <DukeDave> Has anyone heard f of x?
07:25:27 <Botje> sure
07:25:29 <DukeDave> tromp:  Ah, ha, good :)
07:25:31 <tromp> actually we just say f x
07:25:46 <copumpkin> effects?
07:25:48 <ksf> xplat, not very integrated into haskell, is it?
07:26:00 <xplat> ksf: no, not very
07:26:06 <xplat> or, er, at all
07:26:13 * ksf has a look at what haxml is up to
07:26:14 <xplat> out of the box, anyway
07:26:15 <DukeDave> My old maths teacher said, "f of x" and it stuck, but I just realised that it doesn't make too much sense to use "of"?
07:26:35 <DukeDave> I suppose "of" as in "coming from", makes sense
07:26:40 <xplat> but it's so good at what it does that it can be worth it to bend your program around it a bit
07:27:06 <ksf> well, I'm not planning on doing lots of xml stuff.
07:27:20 <xplat> DukeDave: it comes from the pattern 'sine of x, cosine of x, tangent of x, square root of x ...'
07:27:46 <DukeDave> xplat: Ah yes, but why "of"?
07:28:00 <DukeDave> Why not, "at" for example?
07:28:12 <DukeDave> Or, "when"
07:28:20 <unsafePerformIO> ok ok. but if we was inside Applicative (f :: F (x -> y), x :: F x)?
07:28:31 <xplat> DukeDave: the idea originally was that the argument was the important thing
07:28:33 * DukeDave is just musing, and has no answers :)
07:28:57 <xplat> DukeDave: each number would have its own sine, cosine, tangent, square root, etc
07:29:38 * DukeDave nods
07:29:43 <xplat> only later came the concept of abstracting the same 'attribute' of each number into a separate entity known as a 'function'
07:30:23 <DukeDave> Those clever people
07:30:31 <xplat> basically in order to be able to construct HOFs, in fact
07:30:58 <xplat> differentiation, integration, plotting on a graph
07:31:22 <DukeDave> Mm, a nice definition of, "of": "Expressing the relationship between a part and a whole:  "the sleeve of his coat"."
07:31:25 * hackagebot authenticate 0.10.4 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.10.4 (FelipeLessa)
07:31:55 <geheimdienst> possibly it's like in a recipe. take x, do this and that, then you get the sine of x. "the cake is made _of_ eggs, milk, etc."
07:33:06 <ksf> argh xhaskell is abandoned.
07:33:16 <xplat> 'sleeve' is a function mapping garments to arm-enclosing parts thereof
07:34:00 <tromp> :t showHex
07:34:01 <lambdabot> forall a. (Integral a) => a -> String -> String
07:34:07 <xplat> usually multivalued where it is defined
07:34:10 <tromp> > showHex 2012
07:34:11 <lambdabot>   Overlapping instances for GHC.Show.Show
07:34:11 <lambdabot>                              (GHC.B...
07:34:23 <tromp> > showHex (2012::Int)
07:34:24 <lambdabot>   Overlapping instances for GHC.Show.Show
07:34:24 <lambdabot>                              (GHC.B...
07:34:32 <tromp> > showHex (2012::Int) ""
07:34:33 <xplat> > showHex 2012 "bob"
07:34:34 <lambdabot>   "7dc"
07:34:34 <lambdabot>   "7dcbob"
07:35:27 <mm_freak> what would be the problems met when you want to promote regular functions to the type level?
07:35:53 <mm_freak> automatically i mean
07:35:55 <yrlnry> Undecidability?
07:36:16 <xplat> yeah, recursive functions couldn't be promoted safely
07:36:42 <xplat> also, overlapping pattern matches would need to be rewritten to remove overlap if you wanted them to work nicely
07:36:55 <mm_freak> well, some functions would certainly require UndecidableInstances, but you probably wouldn't want them on the type level anyway
07:37:02 <xplat> that's not necessarily a killer, but it is annoying
07:37:37 <mm_freak> how about promoting certain functions explicitly?
07:37:42 <mm_freak> promote add Add
07:38:07 <mm_freak> it would just have to rewrite the function as a type family
07:38:10 <mokus> inference would require being able to solve equations involving those functions
07:38:36 <mm_freak> then depending on the function you may or may not have to turn on UndecidableInstances
07:38:50 <dolio> Overlapping isn't actually a problem if you're promoting ordinary closed function definitions.
07:39:00 <dolio> Because that falls into the case where it's safe.
07:39:09 <xplat> also, simple substitutions could be promoted to type aliases, which are of kind * -> * or the like, but for more sophisticated functions you'd need type families and a kind like * -> Constraint
07:39:31 <mm_freak> well, according to the documentation type families must never overlap, and you get that checked for you for free
07:40:07 <mm_freak> append :: Vec n1 a -> Vec n2 a -> Vec (n1 + n2) a
07:40:10 <mm_freak> how cool is that
07:40:34 <mm_freak> ok, it's really just slightly nicer syntax, and you probably can have that without the promotion
07:40:52 <mm_freak> append :: Adder (+) => Vec n1 a -> Vec n2 a -> Vec (n1 + n2) a
07:40:55 <xplat> can you even promote things like Int or Integer to begin with?
07:41:03 <xplat> they're not exactly normal datatypes
07:41:27 <Philonous_> xplat:  Not yet, but afaik they are working on it
07:41:30 <xplat> well, you'd want Nat there anyway, and i guess you could Peano it up
07:41:31 <mm_freak> xplat: GHC 7.4 promotes custom types to the kind level automaticallyâ€¦  of course that won't work with Int/Integer (even though it would be great)
07:41:33 <ksf> anyone ever used http://hackage.haskell.org/package/compdata-0.5 ?
07:42:16 <Saizan> there's going to be a TypeNat at some point
07:42:18 <mm_freak> xplat: i don't actually see a problem with promoting Integer, as long as you be careful about which operations you promote
07:42:19 <Philonous_> xplat:  Type level strings would give you extensible records
07:42:29 <xplat> i'm disappointed that no form of TypeNat/TypeInteger made it to 7.4
07:42:40 <mm_freak> Saizan: really?  as far as i see you don't need it anymore
07:43:10 <mm_freak> Saizan: with GHC 7.4 when you write "data Nat = Zero | Succ Nat" you don't only get a type, you also get a kind Nat with types Zero and Succ (n :: Nat)
07:43:12 <ksf> ...especially as it's, strictly speaking, only a syntax issue.
07:43:13 <xplat> mm_freak: technically you don't need it, but in practice some special treatment would help a lot
07:43:32 <ksf> it's not like there wouldn't be a gazillion implementations of type-level naturals around.
07:43:41 <ksf> it's the hello world of type-level hacking.
07:43:42 <Saizan> mm_freak: you haven't used those at the typelevel enough if you think they are enough in practice :)
07:44:01 <mm_freak> Saizan: what are the shortcomings?  efficiency?
07:44:06 <xplat> yeah, us agda veterans know better than to think 'it's just a syntax issue'
07:44:28 <ksf> mm_freak, try writing Int128 with S and Z
07:44:48 <xplat> besides efficiency, you have to do all kinds of contortions to cast a 'Foo (a + b)' to a 'Foo (b + a)'
07:44:51 <Saizan> mm_freak: you like commutativity or that 0 is a right identity of + i guess, and those aren't free
07:44:52 <Philonous_> mm_freak:  Your function definitions have to coincide with you type level function definitions. For example you get into trouble if your type level (+) recurses over the wrong parameter
07:44:54 <mm_freak> ksf: my vectors didn't get that long yet, but yes, i see what you're trying to say
07:45:11 <mm_freak> Saizan: ok, i see the problem
07:45:19 <ksf> you could do S001 .. S999, of course.
07:45:26 <ksf> base 1k-arithmetic is manageable.
07:45:40 <ksf> *000 - 999
07:45:42 <ksf> duh.
07:45:47 <mm_freak> Philonous_: actually that's not entirely trueâ€¦  GHC gives you a clue about that
07:46:08 <mm_freak> Philonous_: if you have to turn on UndecidableInstances, then most likely you've got something wrong
07:47:12 <mm_freak> Saizan: how would you establish identities at the type level, if you have to do it yourself?  is that even possible?
07:47:41 <xplat> mm_freak: basically you construct inefficient identity functions
07:47:57 <xplat> and hope the runtime optimizes them to the efficient kind
07:48:17 <xplat> at least i think that's how it would work with GADTs
07:48:26 <mm_freak> i could imagine something like:  append :: (Add n1 n2 ~ Add n2 n1 ~ n) => Vec n1 a -> Vec n2 a -> Vec n a
07:48:35 <mm_freak> but i'm almost sure that that won't work
07:50:09 <mm_freak> so far i haven't run into the problem where i would need such an identity, but i see the point
07:50:32 <xplat> there was a paper on 'type-safe casts' that used haskell GADTs, you should probably google it up
07:51:04 <Philonous_> mm_freak:  I meant you have to give an annoyingly explicit witness the to commutativity of (+) if you defined it "the wrong way around" for your function. A smart compiler might figure this out for you
07:51:24 <xplat> looks like it was a functional pearl?
07:51:29 <faiyaz26> why should i use heskell!
07:51:33 <mm_freak> to me a more important issue is that there is no 'exists'
07:51:42 <mm_freak> with type level arithmetic it would be very useful
07:52:09 <mm_freak> getLine :: IO (exists n. Length n => Vec n Char)
07:52:47 <xplat> i wouldn't be surprised if you could make your own with GADTs and ConstraintKinds and TypeFamilies
07:53:07 <mm_freak> nah, you just need ExistentialQuantification, which is what i do right now:
07:53:20 <mm_freak> data VecP a = forall n. Length n => VecP (Vec n a)
07:53:36 <mm_freak> giving me sort of a vector proxy
07:53:38 <xplat> no, i mean a general one, rather than making a new named type every time
07:53:54 <mm_freak> you can do thatâ€¦  some examples were given here yesterday
07:54:06 <xplat> ah, see then?
07:54:14 <mm_freak> you just need ConstraintKinds
07:54:25 <mm_freak> IIRC
07:55:05 <xplat> even agda doesn't have 'exists' built-in, you get a parameterized dependent record type in the library that does it
07:55:32 <Saizan> i wonder if we can carry out the induction needed for proofs like (n + 0) ~ 0 at the typeclass level
07:55:58 <xplat> TFs can do that
07:56:25 * hackagebot yesod-auth 0.7.8 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.8 (FelipeLessa)
07:56:41 <xplat> pretty sure, anyway
07:57:10 <mm_freak> xplat: how would that work?  like a class IsZero?
07:57:16 <Saizan> they can provide such a context?
07:58:08 <mm_freak> hmmâ€¦  a class IsTrue might do it
07:58:35 <hpaste> asd pasted â€œtinulaâ€ at http://hpaste.org/55459
07:58:46 <mm_freak> instance IsTrue (Equals (Add n1 n2) (Add n2 n1))
07:59:33 <mm_freak> instance IsTrue (Equals (Add n1 n2) (Add n2 n1)) => Addition Add  -- pseudo-code
08:00:02 <mm_freak> append :: Addition (+) => Vec n1 a -> Vec n2 a -> Vec (n1 + n2) a
08:04:36 <mm_freak> trying to install a GHC 7.4 nightly buildâ€¦  it gives me:  checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
08:04:48 <parcs`> mm_freak: arch linux?
08:05:17 <mm_freak> yes
08:05:22 <parcs`> install gmp4 from the aur
08:05:29 <mm_freak> thanks
08:05:57 <mm_freak> parcs`: can i just replace it?  a lot of packages depend on GMP
08:06:39 <mm_freak> or can i install it additionally?
08:06:50 <parcs`> gmp4 is installed side-by-side with gmp
08:07:12 <mm_freak> ah, alright
08:09:03 <ksf> compdata looks *really* nice.
08:10:15 <xplat> oh, it's based on that functional pearl
08:10:38 <xplat> i didn't know someone actually made a library out of it, or i'd have recommended it
08:10:39 <ksf> fusion support.
08:11:09 <ksf> ...and if it's good enough for compilers, it's gonna be good enough for some xml.
08:12:24 <mm_freak> ksf: why exactly do you want XML on the type level anyway?
08:12:55 <ksf> I just want a non-ugly way to deal with namespaces.
08:13:01 <xplat> presumably to prevent ... accidents
08:13:24 <xplat> just like anything else on the type level
08:13:42 <ksf> or, rather, the extending involved when you have a base schema and an extension on top of it.
08:13:50 <mm_freak> i see
08:13:58 <mm_freak> so you are actually dealing with XML
08:14:03 * byorgey doesn't even know why you would want XML on the value level ;)
08:14:04 <ksf> yep.
08:14:11 <xplat> if your program is spec'd to parse or generate a schema, you should be able to typecheck that it does
08:14:25 <mm_freak> hehe
08:14:39 <xplat> and in the cases where schemas can be reused, it would be nice if accompanying programs could be reused that way too
08:14:57 <mm_freak> not a big fan of XML myself, but yeah, you've got all those existing applications using XML
08:15:01 <mm_freak> most notably the web
08:15:18 <ksf> I don't mind xml as long as I don't have to touch the syntax.
08:15:51 <xplat> i don't mind xml as long as i don't have to touch the syntax and the schemas are relaxng?
08:16:26 <xplat> xml schema is ... :(
08:16:29 <hvr> byorgey: btw, got the email-patch for "split"?
08:16:30 <ksf> I don't care what schema language is used as long as there's a converter to adts
08:16:50 <ksf> but in my case now, the whole thing is small enough to just do the parsers by hand.
08:16:57 <ksf> not everything is a beast like html
08:17:02 <mm_freak> relaxng isn't that bad, but XSLT is horror
08:17:18 <byorgey> hvr: yes, thanks! I actually just responded
08:17:46 <byorgey> hvr: I am going to wait until there is a release candidate of 7.4, then I will update the dependency and run some tests before uploading a new version of split
08:17:47 <xplat> XSLT isn't exactly in the same class as relaxnd, you'd want to compare XSD and XSI
08:18:14 <xplat> the annoying thing is w3c built an entire generation of standards on top of XSD
08:18:36 <xplat> which practically nobody even implements, because, XSD
08:19:48 <xplat> major library maintainers specifically say things like 'version 2.0 of xpath will never be supported because it depends on XSD'
08:19:59 <hvr> byorgey: btw, fwiw, I'm currently using the GHC-7.4.0 stable builds from http://www.haskell.org/ghc/dist/stable/dist/ and I got most libraries to build (with some local fixups, see also https://gist.github.com/1496342 )
08:20:41 <ectod> hi
08:21:00 <ectod> i have a problem with a monadic function implying the "Prob" monad of the LYAH haskell book
08:21:03 <xplat> considering people support TIFF just to process JPEGs a little more accurately, that's a pretty strong dislike of XSD
08:21:48 <hpaste> ectod pasted â€œProb Monadâ€ at http://hpaste.org/55460
08:23:27 <mm_freak> uh
08:23:33 <mm_freak> pandoc fails to install with GHC 7.4 =/
08:23:59 <mm_freak> anything i can do about it?
08:24:09 <xplat> fix it!
08:24:12 <hvr> mm_freak: annoy the maintainer to update the library deps :)
08:24:37 <mm_freak> hehe
08:24:51 <xplat> isn't a common problem needing fixed a lack of Eq or Ord constraints on types with a Num constraint?
08:25:01 <ectod> I think the code is fairly easy, but the patterns don't seem to 'match' and i don't understand why
08:25:05 <xplat> that's pretty easy to fix, almost mechanical
08:25:08 <hvr> xplat: not as common as you'd think
08:25:27 <hvr> xplat: most fixes are restricted to fixing the .cabal file
08:26:15 <mm_freak> the compiler feels orders of magnitude faster compared to 7.0.3
08:26:35 <xplat> oh, then you want to use cabal-install to grab the bundle, unpack it, fix the deps, and do the build and install from the unpacked bundle
08:26:55 <ksf> "cabal unpack"
08:27:47 <mm_freak> ok, SDL fails too, and there it's not a dependency issue
08:28:03 <mm_freak>     Could not deduce (Eq a) arising from the literal `0'
08:28:03 <mm_freak>     from the context (Num a)
08:28:13 <xplat> yeah, that's the problem i just mentioned
08:28:18 <mm_freak> i see
08:28:36 <xplat> just add the Eq a constraint where it's being complained about
08:28:56 <mm_freak> why is that?  did they finally make Num independent of Eq?
08:29:02 <xplat> yes
08:29:08 <mm_freak> Show, too?
08:29:09 <ksf> wtf?
08:29:19 <ksf> is that still valid haskell?
08:29:23 <xplat> that too, i think
08:29:45 <roconnor> @hoogle StateT
08:29:45 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
08:29:45 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
08:29:45 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
08:29:57 <mm_freak> i'm impressed, though slightly annoyed =)
08:30:02 <xplat> there were a lot of complaints about having to make invalid instances of those things to support arithmetic
08:30:11 <byorgey> ksf: no, technically it now does not match the Haskell 2010 report
08:30:24 <byorgey> but it was decided that we Didn't Care
08:30:27 <mm_freak> ah, my solution to that was to use the vector-space package instead of Num
08:30:44 <kmc> the behavior should at least change if you specify -XHaskell2010
08:30:46 <kmc> but it doesn't :(
08:30:49 <ksf> how do you manage to get a ring without equality?
08:30:50 <byorgey> oh, whoops
08:31:05 <byorgey> ksf: why would you need equality?
08:31:20 <byorgey> ksf: rather, I should say, why would you need *decidable* equality?
08:31:20 <xplat> ksf: think more like 'how do you manage to get a ring without decidable equality?'
08:31:23 <kmc> the real numbers are a ring without computable equality
08:31:25 <ksf> so I don't have to scatter eq constraints all over the place?
08:31:25 <kmc> :)
08:31:28 <xplat> ninja'd
08:31:40 * ksf doesn't care for decidability.
08:31:48 <ectod> anyone for my problem ? :)
08:31:50 <mm_freak> hmm, OpenGL fails, tooâ€¦  seems like i'll have to do some manual work to get happy with GHC 7.4
08:32:20 <hvr> mm_freak: yes, manual work is necessary for the mean time :-)
08:32:23 <ksf> also, how do you get a ring *involving numbers* without having at least partly decidable equality?
08:32:40 <hvr> mm_freak:  I'm running a GHC-7.4.0 compiled xmonad  here :)
08:32:44 <ksf> that inf = succ inf doesn't work is a thing people just have to deal with.
08:32:44 <mm_freak> hvr: gonna do that thoughâ€¦  i love the new type system extensions =)
08:32:55 <xplat> ksf: one-way decidable equality is not technically enough for an eq instance
08:32:55 <byorgey> ectod: what's the problem, exactly?
08:33:11 <ksf> xplat, unamb.
08:33:15 <ksf> I don't care.
08:33:15 <mm_freak> my first test was to go onto GHCi and type:  "data MyType = MyValue deriving Show"
08:33:19 <mm_freak> and wth, it worked!
08:33:24 <byorgey> =D
08:33:25 <ectod> well i want to get rid of the double values in the Prob Bool value i pass to the function joinOutcomes
08:33:31 <ksf> if you do such outlandish things just don't use the Num typeclass but a custom one.
08:33:51 <ectod> just like i did with the list in the function just below, supprDoubles
08:34:17 <ksf> ...float equality is dodgy, too, and noone ever cared.
08:34:21 <ectod> seems easy but the function joinOutcomes makes errors because of the pattern matching
08:34:42 <byorgey> ectod: BTW, there is a function 'nub' in Data.List which is the same as supprDoubles
08:34:46 <xplat> ksf: you lose a lot when you lose Num, remember you might want to use functions that *someone else wrote*
08:34:53 <xplat> ksf: and, people did care
08:34:57 <byorgey> ectod: what errors?
08:35:14 <ectod> Couldn't match expected type `Prob Bool' with actual type `[(Bool, Rational)]'
08:35:26 <roconnor> LYAH needs a chapter on Data.Lens
08:35:28 * roconnor nods
08:35:40 <ectod> but it's odd because Prob Bool IS a wrapper for [(Bool, Rational)]
08:35:42 <byorgey> ectod: can you please paste the entire error message along with the code?
08:35:52 <byorgey> ectod: yes, but they are not the *same*
08:36:00 <byorgey> ectod: that is the point of having a newtype.
08:36:19 <ectod> yeah sure i'm missing some point here ^^
08:36:23 <ectod> pasting the errors
08:36:32 <mm_freak> i unpacked and installed the "xhtml" library myself adjusting its cabal fileâ€¦  when doing "cabal install -fhighlighting pandoc" it still wants to install xhtml
08:36:34 <xplat> the whole idea of a wrapper is they're the same inside, but outside they look different
08:36:35 <mm_freak> why is that?
08:36:50 <byorgey> ectod: oh, I see the problem.  You are passing 'rest' to joinOutcomes recursively.  But 'rest' is a list, and joinOutcomes expects a Prob Bool.
08:36:52 <xplat> so if you want to use a Prob Bool as [(Bool, Rational)] you have to unwrap it
08:37:05 <mm_freak> "cabal info xhtml" says that xhtml is installed
08:37:23 <ectod> yes that's what i thought, but i don't know how to do it another way
08:37:26 <mm_freak> and it's the same version that pandoc tries to install
08:37:28 <byorgey> ectod: if I were you I would write  joinOutcomes (Prob xs) = joinOutcomes' xs   where joinOutcomes' ...
08:37:30 <xplat> likewise if you want to use a [(Bool, Rational)] as a Prob Bool you need to wrap it up
08:37:46 <byorgey> ectod: err, sorry, I meant
08:38:05 <byorgey> ectod: joinOutcomes (Prob xs) = Prob (joinOutcomes' xs)   where joinOutcomes' ...
08:38:09 <mm_freak> xplat: you proposed the solutionâ€¦  help me =P
08:38:19 <byorgey> then joinOutcomes' just has to work on lists and not worry about Prob
08:38:59 <byorgey> ectod: (the other way would be to change 'joinOutcomes rest' to 'joinOutcomes (Prob rest)'
08:39:16 <byorgey> oh, actually, that doesn't work in the second case
08:39:26 <byorgey> right, do it the way I suggested at first =)
08:39:32 <ectod> byorgey, thanks i was gonna ask you if i could do that :)
08:39:45 <ectod> going to try some tweaking with all this
08:39:56 <xplat> mm_freak: probably the installed xhtml depends on other things that pandoc conflicts with, and cabal-install is trying to rebuild with deps that won't conflict
08:40:36 <xplat> so you may need to do further adjustments on pandoc's deps to match what you did with xhtml
08:41:10 <mm_freak> it specifically tries to install xhtml
08:41:17 <mm_freak> (again)
08:41:28 <xplat> i know it does
08:41:36 <xplat> i'm telling you why it wants to do that
08:42:00 <ectod> byorgey, it seems okay for the first guard, but the oterwise guard doesn't work for obivous reasons
08:42:12 <xplat> it wants the same version, but it thinks it can't build pandoc against the libs that xhtml is built against
08:42:29 <xplat> so it wants to rebuild xhtml (even at the same version) to avoid ABI skew
08:42:55 <ectod> byorgey, the thing is i don't quite get how i can 'keep' the previous value and recurse on the other part of the Prob
08:43:00 <xplat> so you have to let it know that the libs that were good enough to build that xhtml are good enough to build pandoc against too
08:44:09 <hvr> mm_freak: btw, if you change the deps in .cabal, you should also add a .1 to the package version, otherwise cabal will still pick up the .cabal file from the hackage index
08:44:17 <hvr> when trying to resolve deps
08:45:09 <roconnor> @type (>>>)
08:45:09 <xplat> er, that too, i forgot about that ... ^_^;
08:45:10 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
08:46:30 <xplat> roconnor: all that should be redesigned now that there is Constraint :(
08:46:37 <mm_freak> hvr: you are right
08:46:42 <mm_freak> that worked
08:46:44 <mm_freak> thanks
08:47:06 <carpi> if i want to use Maybe types outside the ghci..do i need to import any module?
08:47:27 <carpi> because i get the "data constructor Not in scope" error
08:47:53 <xplat> roconnor: but when i think about how much work has gone under the bridge without successfully making Monad a subclass of Functor ... :(
08:48:27 <danm__> Maybe is in prelude I think, so no
08:48:44 <ClaudiusMaximus> some extra functions are in Data.Maybe
08:48:57 <kissyboy_> you're probably using Maybe as the data constructor instead of Just
08:49:08 <ClaudiusMaximus> but if you didn't need that in ghci, you won't need it in code
08:49:24 <ectod> byorgey, i did     | otherwise = joinOutcomes (Prob $ tail rest)    in the second guard, seems okay i guess
08:49:36 <kissyboy> @type Just 'foo'
08:49:37 <lambdabot>     lexical error in string/character literal at character 'o'
08:49:47 <kissyboy> @type Just "foo"
08:49:48 <lambdabot> Maybe [Char]
08:51:33 <alistra> hi
08:54:21 <hvr> byorgey: oh, and btw... cabal currently just falls back to split-0.1.2.3 which had more relaxed base-package constraints...
08:57:17 <mm_freak> wow, it's hard to get GHC 7.4 runningâ€¦  lots of broken dependencies =/
09:00:02 <ectod> byorgey, works fine now.  thanks for giving me the leads :)
09:06:26 * hackagebot atto-lisp 0.2.1.1 - Efficient parsing and serialisation of S-Expressions.  http://hackage.haskell.org/package/atto-lisp-0.2.1.1 (ThomasSchilling)
09:06:28 * hackagebot canonical-filepath 1.0.0.2 - Abstract data type for canonical file paths.  http://hackage.haskell.org/package/canonical-filepath-1.0.0.2 (ThomasSchilling)
09:08:43 <hpaste> mizu_no_oto pasted â€œcabal dependency hellâ€ at http://hpaste.org/55461
09:09:16 <mizu_no_oto> Anyone know how to fix that and get the package installed?
09:10:13 <cygnus> mizu_no_oto: mime-mail's dependency is probably unnecessarily constrained.
09:10:35 <Peaker> mizu_no_oto: what does ghc-pkg list directory   say?
09:11:02 <Peaker> I think it's because someone is over-conservative on their dependency on directory, forcing in a very old directory + filepath
09:11:41 <cygnus> Peaker: that may be, but mime-mail could probably work just fine with an older version of filepath
09:12:23 <Peaker> cygnus: I really dislike forcing in older versions (potentially buggy, bad performance, resolved problems) in
09:12:31 <mizu_no_oto> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
09:12:33 <mizu_no_oto> /var/lib/ghc-6.12.3/package.conf.d
09:12:34 <mizu_no_oto>    directory-1.0.1.1
09:12:36 <mizu_no_oto> /home/foo/.ghc/x86_64-linux-6.12.3/package.conf.d
09:12:55 <cygnus> Peaker: agreed. :)
09:13:15 <Peaker> mizu_no_oto: try: cabal install yesod --constraint="filepath >= 1.2"
09:13:24 <Peaker> mizu_no_oto: which package demands the older filepath?
09:13:45 <Peaker> mizu_no_oto: the constraint will expose that
09:15:09 <mizu_no_oto> cabal: cannot configure directory-1.0.1.1. It requires filepath ==1.1.*
09:17:21 <Peaker> mizu_no_oto: ah then it seems your choices are:  try to install mime-mail with an older file-path than it wants
09:17:27 <Peaker> mizu_no_oto: or upgrade to ghc 7
09:18:19 <Peaker> mizu_no_oto: to do the former, you can try to use: cabal unpack mime-mail-0.4.1.0    and edit the .cabal file in there: A) change the version to 0.4.1.0.1   and B) change the filepath dep lower bound to >=1.1
09:21:26 <mizu_no_oto> What's the best way to install the new haskell platform on ubuntu?
09:21:49 <mizu_no_oto> since there's no reason to run around with ghc 6 just because it's what's in the repo
09:22:40 <c_wraith> mizu_no_oto: the best approach is generally to not use the platform, in my experience
09:23:17 <mizu_no_oto> c_wraith: What's the best thing to do?  Just grab the ghc7 binary?
09:23:21 <Philippa> c_wraith: one may understandably have to standardise on it, though
09:23:35 <Philippa> mizu_no_oto: use the platform to build the latest source release?
09:23:53 <c_wraith> mizu_no_oto: I use the binary installer, and then install cabal-install via bootstrap.sh
09:26:26 * hackagebot nettle-openflow 0.2.0 - OpenFlow protocol messages, binary formats, and servers.  http://hackage.haskell.org/package/nettle-openflow-0.2.0 (AndreasVoellmy)
09:27:58 <estan> hi folks. taking a class which is a hodgepodge of different languages, and in a recent exam we were given this example piece of code: http://ideone.com/XCfP5
09:28:18 <estan> it doesn't even compile, saying Tenta.hs:10:25: Not in scope: `dagar'
09:28:57 <estan> so, i'm no haskell expert, could anyone point out what was the intention of the examinor (who wrote the exam) here?
09:29:30 <kmc> i assume it's supposed to be:   restid (Resa _ tid _) = tid
09:29:34 <kmc> like the other two
09:29:38 <estan> (it is supposed to compile, but this class is a joke and none of the teachers involved are really experts in the language they're teaching)
09:30:00 <estan> doh.
09:30:36 <estan> ok damn. shame on me, that was me typing it out wrong. thanks though.
09:31:01 <estan> (they put up a scanned copy of the exam, so i manually typed it in).
09:34:52 <augur> salisbury!
09:36:26 * hackagebot nettle-netkit 0.2.0 - DSL for describing OpenFlow networks, and a compiler generating NetKit labs.  http://hackage.haskell.org/package/nettle-netkit-0.2.0 (AndreasVoellmy)
09:36:44 <simon> estan, if you use a record in your type, you get the getters for free.
09:37:23 <yitz> simon: i don't think estan has much of a choice. that is what was written on the exam.
09:38:26 <estan> simon: yep. i think i remember that much from class.. this was a contrived example from an exam.
09:43:16 <simon> here's how I'd write it: http://ideone.com/ShIdb
09:46:26 * hackagebot snap-blaze 0.0.0.2 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.0.0.2 (JasperVanDerJeugt)
09:52:11 <shachaf> tibbe: By the way, apparently there's a bahaskell meeting on Wednesday.
09:52:12 <hpaste> tiph15 pasted â€œhs-ffmpeg patch for compatibility with GHC 7 (unified)â€ at http://hpaste.org/55462
09:55:40 <tibbe> shachaf: saw, not sure if I'll make it
10:16:12 <psionski> guys
10:16:16 <psionski> newb question here
10:16:17 <psionski> ...
10:16:31 <hpaste> psionski pasted â€œnumber of comparisonsâ€ at http://hpaste.org/55463
10:16:48 <psionski> in the following, how many comparisons will be executed?
10:17:18 <psionski> I tried looking in the C-- output, but it's scary over there :D
10:20:48 <kmc> psionski, it can depend on how much of the result you demand
10:20:51 <kmc> because of lazy evaluation
10:21:20 <psionski> no, I mean n compares or 2n
10:21:34 <kmc> right, that can depend on how much of the result is evaluated
10:21:41 <psionski> will the compiler optimize the list comprehensions, because they are mutually exclusive
10:21:52 <kmc> not in general, no
10:22:01 <psionski> so 1 element gets compared once, and then assigned to appropriate list
10:22:05 <psionski> or not
10:22:11 <psionski> or shouldn't I even care about that :)
10:22:20 <kmc> you have no guarantees about that; I don't think it can even see that (<=) and (>) are mutually exclusive
10:22:29 <ClaudiusMaximus> > partition even [1..10]
10:22:30 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
10:22:32 <rwbarton> @src partition
10:22:33 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
10:22:33 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
10:22:33 <lambdabot>                               | otherwise = (ts, x:fs)
10:22:52 <psionski> neat
10:22:55 <kmc> yeah, use Data.List.partition if you don't want to duplicate the comparison
10:23:08 <psionski> wow, that was cool
10:23:12 <psionski> I have so much to learn...
10:23:15 <kmc> also the number of comparisons will depend on how lucky you are with picking the pivot
10:23:26 <psionski> yeah, but that's the algorithm
10:23:31 <psionski> I was worried about the language
10:23:34 <psionski> :P
10:23:38 <psionski> compiler*
10:24:34 <kmc> yeah, the Haskell language gives very few guarantees about optimization
10:24:41 <kmc> GHC is sometimes clever and sometimes very stupid
10:25:03 <psionski> yeah, that's to be expected
10:25:12 <psionski> but you get to have a high level of abstraction...
10:25:18 <kmc> yeah
10:25:18 <psionski> it's either / or :)
10:25:34 <psionski> but so far I'm amazed by Haskell
10:25:35 <kmc> the tradeoff of abstraction and performance is good
10:25:39 <psionski> how most of the stuff just works
10:25:41 <psionski> :D
10:25:50 <psionski> you try something and it compiles
10:25:59 <psionski> (and gives correct results, too!)
10:28:07 <psionski> > partition (<=42) [40..45]
10:28:08 <lambdabot>   ([40,41,42],[43,44,45])
10:28:46 <kmc> > break (<=42) [40..45]
10:28:48 <lambdabot>   ([],[40,41,42,43,44,45])
10:28:51 <psionski> > partition (<=42) [45..40]
10:28:52 <lambdabot>   ([],[])
10:28:55 <kmc> > span (<=42) [40..45]
10:28:55 <lambdabot>   ([40,41,42],[43,44,45])
10:29:21 <psionski> > [45..40]
10:29:22 <lambdabot>   []
10:29:22 <miden> hey
10:29:24 <kmc> > span (<=42) ([40..45] ++ [30])
10:29:26 <lambdabot>   ([40,41,42],[43,44,45,30])
10:29:29 <psionski> > [45,44..40]
10:29:30 <kmc> > partition (<=42) ([40..45] ++ [30])
10:29:30 <lambdabot>   can't find file: L.hs
10:29:30 <lambdabot>   [45,44,43,42,41,40]
10:29:55 <psionski> > partition (<=42) [45,44..40]
10:29:55 <lambdabot>   ([42,41,40],[45,44,43])
10:35:09 <ksf> can ghci expand type synonyms for me?
10:35:43 <c_wraith> from what I've seen, it tries really hard not to
10:36:42 <psionski> which OS ?
10:39:36 <ClaudiusMaximus> psionski: btw, you don't need the Num constraint on your qsort
10:44:38 <psionski> ClaudiusMaximus thx again :)
10:44:48 <psionski> btw quicksort reduced to a one-liner
10:44:52 <psionski> soooo unfair to other languages
10:45:04 <cheater> it might have reduced..
10:45:07 <cheater> but has it mapreduced?
10:45:30 <raichoo> that's not really quicksort. Quicksort is an in place algorithm.
10:46:11 <psionski> qsort (n:ns) = let part = partition (<=n) ns in qsort (fst part) ++ [n] ++ qsort (snd part)
10:46:18 <psionski> raicho it's OK, though :)
10:46:20 <yrlnry> quacksort
10:46:21 <psionski> does what advertised
10:46:29 <donri> but not "quickly"
10:46:42 <raichoo> Technically it's treesort.
10:46:48 <monochrom> but you can still claim: mergesort is reduced to a one-liner
10:47:02 <psionski> i don't know the other algorithms
10:47:04 <q0tw4> even quick sort with arrays works too slow
10:47:16 <psionski> like i said, i'm a newb
10:47:16 <psionski> :)
10:47:25 * ksf tries to wrap his head around that he can't use [Foo :+: Bar] with compdata
10:47:46 <ksf> ...which is rather annoying, because neither Foo nor Bar should care that they are in a list.
10:48:27 <ksf> but it's data Foo e = Foo e and then ye olde data fixpoint.
10:48:52 <hpaste> q0tw4 pasted â€œquicksort with arraysâ€ at http://hpaste.org/55464
10:49:08 <raichoo> psionski: everyone is a learner ;)
10:49:31 <psionski> wow
10:49:32 <ksf> :+: should arguably be kind-arity polymorphic.
10:49:33 <psionski> q0tw4
10:49:55 <ksf> muahahaha
10:49:56 <q0tw4> tests shows me n^2. I don't know why
10:50:10 <ksf> psionski will never know whether I'm talking sense or pulling his leg.
10:51:15 <yitz> ksf: no guarantee, unless you have access to tunes.org
10:52:14 <rostayob> this is not really an haskell specific question, BUT
10:52:26 <q0tw4> Maybe qsort for List (IORef a) will be ineresting. It will be quick sort and stable.
10:52:30 <cheater> rostayob: try #linux
10:52:34 <ksf> hmmm. is kind-arity polymorphism even possible?
10:52:51 <rostayob> is there a nice way to thread the position in the original file when representing the source in a compiler
10:53:02 <rostayob> so for example through lexing, parsing, type checking, etc
10:53:51 <rostayob> ksf: mh? no. non even function-arity polymorphism is supported directly in haskell
10:53:57 <rostayob> (but possible through type classes)
10:55:06 <ksf> duh.
10:56:34 <ricree> Any idea why this would give me an ambiguous type variable error in ghci?  "let x = arr (+3)".  It gives the expected type when I do ":t arr (+3)"
10:56:35 <roconnor> @hoogle lookup
10:56:35 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:56:35 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:56:35 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
10:56:42 <roconnor> @hoogle Data.Map.lookup
10:56:42 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
10:56:42 <lambdabot> Data.Map lookupIndex :: Ord k => k -> Map k a -> Maybe Int
10:56:42 <lambdabot> Data.Map insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
10:57:34 <miden> is it possible to take the first 15 stdGen numbers?
10:59:20 <ksf> well, functor-less types work (of course, as evidenced by duh)... but actually, the fun starts with those zero-or-one and zero-or-more constraints expressed at the type level.
10:59:29 <ksf> ...with arbitrary ordering.
11:00:16 <rostayob> ksf: i'm not sure i follow you. functor-less types?
11:00:19 <augur> salisbury!
11:00:28 <ksf> rostayob, data Fix f
11:01:06 <ksf> (the answer is yes, you can put types into a list if you fix them, and I'm an idiot)
11:01:08 <rostayob> ksf: oh. why do you say functor less? also, if 'f a' is a Functor, Fix f is a functor
11:02:41 <rostayob> actually... no
11:03:11 <rostayob> i was thinking of other two level recursive types
11:03:19 <rostayob> anyway i still don't get your question!
11:03:28 <ksf> functor is even the wrong word. I was considering a list of a sum type vs. a sum type that contains tails in every option and an extra null.
11:04:06 <ksf> that is, whether the list wraps the sum or the other way round.
11:04:36 <ksf> I bet there's some smart algebraic laws, there, proving that everything I can ever dream of is isomorphic.
11:04:51 <rostayob> contains which tails?
11:04:56 <ksf> of the list.
11:05:48 <rostayob> wait, the list itself is a sum
11:05:50 <ksf> data F e = F Float e, data I e = I Int e, data Null e = Null vs. the same thing without Null and those e's and a [] wrapped around it.
11:06:20 <rostayob> list a = Nil + (a * list a)
11:06:35 <ksf> yes!
11:06:36 <ksf> exactly.
11:06:43 <Philippa> ksf: I'd be worried if everything I can ever dream of is isomorphic. It'd be the triumph of chaos (in the ancient sense)
11:06:54 <ksf> but haskell adt /= compdata's abstraction-foo.
11:07:06 <rostayob> ksf: well but.. that's the classic definition of list
11:07:27 <rostayob> you can build a list
11:07:35 <rostayob> i mean if you have
11:07:48 <rostayob> data F e = F Float e | Null
11:07:51 <Saizan> ricree: it's the MonomorphismRestriction
11:07:55 <rostayob> then Fix F is a list of floats
11:08:01 <rostayob> in the same way that
11:08:07 <ksf> also it's more like List a e = Nil + (a * e)
11:08:20 <rostayob> data Tree t = Leaf Int | Node t t, Fix Tree
11:08:21 <rostayob> and so on
11:08:27 <rostayob> yeah you can do
11:08:41 <ClaudiusMaximus> how to solve ambiguous module names / multiple packages within ghci-7.0.4? i tried :set -XPackageImports ; import "mtl" Control.Monad.State  but no joy..  :set -package mtl  similarly doesn't solve it (and also "resets" ghci, oops)
11:09:08 <rostayob> data L a t = Nil | Cons a t, type List a = Fix (L a)
11:09:25 <rostayob> i still don't get where you're heading at, but ok :P
11:10:04 <rostayob> ksf: you might be interested in this http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
11:10:29 <ksf> rostayob, http://hackage.haskell.org/package/compdata-0.5
11:10:47 <rostayob> yeah, that paper is linked in the first line :P
11:11:15 <rostayob> it's an interesting paper (i don't know the package)
11:11:25 <rostayob> but i don't get to use those ideas often
11:11:38 <rostayob> but it's really cool anyways ehe
11:11:50 <parcs`> ClaudiusMaximus: the packageimports syntax doesn't work in ghci unfortunately. it seems the only ways to resolve ambiguous module names within ghci are through loading a file that uses PackageImports or through the -hide-package command-line ghci option
11:12:04 <rostayob> specifically the trick to build arbitrary data types on the fly
11:12:11 <ksf> I'm trying to use it like hlist, though, and then see whether I can abuse it to express regular-language constraints on the type level.
11:12:15 <parcs`> maybe you can use -hide-package through the :set comamnd
11:12:24 <jnhnum1> why is it that ghci's behavior is so different from ghc?
11:12:43 <parcs`> in what way?
11:12:56 <jnhnum1> like you need different syntax to declare everything
11:12:58 <jnhnum1> you can't make new types
11:13:12 <q0tw4> use ghc 7.4
11:13:13 <rostayob> ksf: i don't know hlist
11:13:30 <rostayob> ksf: regular language constraints = ?
11:13:46 <ksf> regexen.
11:13:47 <rostayob> those kind of tricks don't really add anything in terms of type level constraints, they just provide flexibility
11:13:58 <rostayob> ah
11:14:46 <ClaudiusMaximus> parcs`: :set -hide-package does the trick (though it also resets ghci, so, not ideal but better than nothing)
11:15:02 <rostayob> ksf: what kind of constraints can you put on regex?
11:15:08 <parcs`> jnhnum1: you mean having to use 'let' to declare a binding?
11:15:12 <ksf> also, reading the paper I just realised that compdata's notion of product isn't what I thought it was, because taking the product of two functor is a different beast than taking that of two types
11:15:47 <rostayob> ksf: this is the central datatype regarding the type injection: https://github.com/rostayob/typeinj/blob/master/Data/Injection.hs
11:16:31 <ksf> rostayob, I am aware of the functional pearl and everything.
11:16:35 <jnhnum1> parcs`: that, and also what what you were saying about the different package import syntax, and also the thing that was fixed in ghc 7.4 about data type declarations
11:16:43 <ksf> but you do make for an excellent rubber duck ;)
11:16:57 <rostayob> oh well i like rubber ducks
11:17:54 <ksf> rostayob, what I want to do, currently, is to constrain maximal occurence of certain elements of a sequence.
11:18:22 <ksf> like with html, where you can only have one title but multiple whatever in the header.
11:18:35 <monochrom> the REPL is different from the compiler because, much as it would be "nice" for end-users if they were the same, it has not been a priority
11:19:03 <monochrom> and then, for a language that supports forward references, the REPL will never be the same as the compiler.
11:19:36 <c_wraith> heh.  no name errors, just deferred execution until the necessary names are bound
11:19:42 <ksf> pascal: the ultimate repl language?
11:19:51 <monochrom> forward references means: you can write "f :: MyType -> Int" at line 15, and "data MyType = ..." at line 100.
11:20:07 <kumil> When I'm using parsec, the error messages are all nonsense because it encounters the actual error, and then backtracks and complains that it hasn't reached the end of whatever entire structure it was parsing
11:20:11 <Philippa> I suspect FORTH has a better claim to it than pascal
11:20:43 <ksf> kumil, did you try adding some annotations?
11:20:46 <rostayob> ksf: you can probably do something like that if you are just adding elements to a list-like structure... but i'm not sure
11:20:46 <ksf> <?> or something
11:20:59 <kumil> ksf: no
11:21:01 <ksf> also, backtracking is evil.
11:21:01 <_Mikey> :t<***>
11:21:04 <_Mikey> :t <***>
11:21:04 <lambdabot> parse error on input `<***>'
11:21:09 <ksf> in general, parsec is evil.
11:21:17 <_Mikey> :t (***)
11:21:17 <rostayob> ksf: i'd suspect that you can "easily" do that with KindPolymorphism :P
11:21:18 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:21:21 <Philippa> parsec's more evil for not backtracking by default
11:21:24 <monochrom> and also "instance Show MyType ..." at line 42.
11:21:49 <kumil> Philippa: When I first started using it that confused me so much...
11:21:58 <ksf> parsec's more evil for not left-factoring stuff by default.
11:22:22 <ksf> I've never looked at the core, but looking at the interface it can't be that sophisticated.
11:22:33 <kumil> Philippa: I mean, I expected it not to backtrack when it had consumed input but I expected the combinators to backtrack at least
11:23:35 <Philippa> nope, the combinators expect the things they combine to do any backtracking
11:23:51 <Philippa> (unless it's strictly required to implement the combinator)
11:24:38 <monochrom> if you don't use "try" you get little or no backtracking
11:24:40 <Philippa> the core's not massively sophisticated by modern standards, but it's not easy for parsing combinator languages in haskell - let alone ones of monadic power - to start performing grammar transformations to start with
11:26:54 <Philippa> parsec maximises power at the expense of analysis
11:28:38 <lukish_> Solving last exercise from http://blog.tmorris.net/20-intermediate-haskell-exercises/
11:28:47 <lukish_> Stuck on unicorn definition
11:29:26 <hpaste> mizu_no_oto pasted â€œmore cabal problemsâ€ at http://hpaste.org/55466
11:29:57 <mizu_no_oto> I just uninstalled ghc6 and installed ghc7.2.2
11:30:08 <parcs`> wasn't there a parallelize cabal GSoC thing this year?
11:30:08 <mizu_no_oto> And I'm running into problems with cabal
11:31:17 <lukish_> Any advices, hints?
11:32:32 <ksf> ...and parsec was concieved before applicative parsing became popular.
11:33:10 <ksf> and you can do *a lot* of analysis in the applicative parts.
11:33:24 <Philippa> *nod*. FFTSAP and all that
11:33:45 <mizu_no_oto> anyone have any ideas of what to do to solve that cabal problem?
11:34:03 <Philippa> it'd be awesome to see - I'd still rather work on something that knows when it's dealing with a finite grammar if I'm going to compete with trifecta though
11:34:19 <Philippa> (and for applicatives it's worth adding VPL combinators!)
11:34:56 <ksf> I'd be perfectly content with a sane regex interface and iteratees for the rest.
11:35:47 <xplat> wat
11:36:00 <kumil> I at least want to parse context-free stuff
11:36:14 <ksf> that's what the iteratees are for.
11:36:23 <xplat> no, higher-level parsing stuff (that bare iteratees can't handle) is still pretty helpful
11:36:28 <kumil> How can I write a parser that only accepts non-halting haskell programs?
11:36:38 <ksf> you can write an alternative interface for iteratees, no problem.
11:37:02 <ksf> kumil, you restrict it to "<identifier> = <identifier>"
11:37:04 <Saizan> FFTSAP?
11:37:20 <ksf> (you didn't mention that you want to parse *all* non-halting haskell programs...)
11:38:00 <xplat> alternative is the wrong way to parse
11:38:00 <monochrom> if you add "all" but delete "haskell" and add "a language you design", I have an idea...
11:38:52 <xplat> start with brainfuck, remove halt?
11:39:35 <lukish_> State has kind * -> * -> *, so what actually means State m?
11:39:41 <kumil> start with brainfuck, remove nonhalting, accept nothing
11:40:01 <kumil> then it's still turing complete
11:40:36 <xplat> i had a problem: my iteratees couldn't parse languages requiring lookahead
11:40:56 <xplat> so i wrote an Alternative instance for iteratees
11:41:00 <xplat> now i have two problems
11:42:59 <byorgey> lukish_: it is a type constructor for making computations that have access to a state of type m
11:43:17 <byorgey> lukish_: State m a  is a computation which has access to a state of type m, and produces a value of type a
11:43:19 <ksf> the thing is: regexen can avoid backtracking completely. iteratees give you full control over backtracking.
11:43:41 <Philippa> Saizan: "Feel Free To Submit A Patch"
11:43:56 <ksf> for half-way sane grammars, that's enough to write a strictly incremental parser, even when it needs context.
11:44:05 <ksf> er on-line parser.
11:44:09 <lukish_> So, unicorn :: a -> State a ? Right
11:44:44 <lukish_> But how can I define State a without defining second argument?
11:45:03 <Saizan> unicord :: a -> State s a
11:45:10 <Saizan> *unicorn
11:45:28 <Saizan> Philippa: ah, thanks
11:46:14 <ksf> yeh, that should work. compdata can do gadts, and I can encode states in phantom types.
11:46:30 <lukish_> Saizan: and how can I leave m undefined?
11:47:23 <Saizan> lukish_: i don't understand
11:48:09 <lukish_> Saizan: unicorn :: a -> State m a. But what is m?
11:48:27 <byorgey> lukish_: m is anything.  The caller of unicorn gets to choose.
11:48:42 <byorgey> lukish_: your job is to write unicorn in such a way that it works no matter what m is.
11:49:02 <lukish_> a is anything, because it's argument
11:49:10 <Saizan> it's the same as for 'a'
11:49:27 <lukish_> let x = State (\x -> ((1 + x),(x==2)))
11:49:28 <lukish_> x :: State Integer Bool
11:49:47 <lukish_> But how can I define only one part of it
11:50:56 <cobra-the-joker> Hey there every one ... when i make something like "do str = str ++ "a"  as an event in a GUI ... it hangs up and the program stop responding ... whereas  when i write something like "do str = "a" " ... it works nicely .. any help ?
11:55:13 <kumil> Hmm, I kind of see what I need to do to fix my parser. I can get better error messages if I avoid backtracking altogether by factoring out prefixes that both code paths allow
11:55:26 <Saizan> cobra-the-joker: let str = str ++ "a" is a circular definition, since the str on the right of = is the same you are defining there
11:55:38 <Saizan> > let ones = 1 : ones in ones
11:55:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:55:46 <cobra-the-joker> aha
11:56:06 <cobra-the-joker> Saizan, then how can i concatenate a string on it self ?
11:56:24 <Saizan> but (++) is not lazy enough to make str any definite value
11:56:24 <kumil> cobra-the-joker: you can, you just can't do it on the left side
11:56:43 <Saizan> > let str = "a" ++ str in str
11:56:45 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:57:04 <FUZxxl> > let str = fix ('a':)
11:57:05 <lambdabot>   not an expression: `let str = fix ('a':)'
11:57:08 <kumil> > fix ('a':)
11:57:09 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:57:11 <FUZxxl> > fix ('a':)
11:57:12 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:57:24 <kumil> > fix ('a':'b':'c':)
11:57:24 <lambdabot>   The operator `:' [infixr 5] of a section
11:57:25 <lambdabot>      must have lower precedence th...
11:57:31 <cobra-the-joker> > let str = "a" : tail (str)
11:57:32 <lambdabot>   not an expression: `let str = "a" : tail (str)'
11:57:45 <cobra-the-joker> > let str = ("a" : tail (str) )
11:57:46 <lambdabot>   not an expression: `let str = ("a" : tail (str) )'
11:58:05 <kumil> > fix (\xs -> 'a':'b':'c':xs)
11:58:06 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
11:58:07 <Goosey_> What are monads in the most simple concise meaning?
11:58:14 <Saizan> you can't use let without an "in" in lambdabot
11:58:24 <cobra-the-joker> i worked it out ... str = str 2 .. str2 = str ++ "a"
11:58:38 <cobra-the-joker> but i think it can be made more gentally
11:58:42 <Saizan> Goosey_: monoid objects in the category of endofunctors?
11:58:48 <kumil> Goosey_: a class associated with the do-notation syntatic sugar and some rules that instances must follow
11:59:03 <ricree> cobra-the-joker, maybe you should post a larger example to hpaste so we know what you're trying to do
11:59:18 <cobra-the-joker> ricree ok
11:59:30 <kumil> Goosey_: but besides the syntatic sugar and the rules your instances is supposed to follow, it's just a normal class
12:00:13 <Goosey_> kumil: thanks, I'm still a bit confused, but I'm sure that will help
12:00:51 <alistra> Goosey_: ask Philippa, he was bragging, that he understands monads better
12:01:11 <QQII> Ohai
12:01:20 <kumil>  Goosey_ ignore all the category theory stuff. It's entirely unnecessary for understanding monads
12:01:34 <kumil> unless you're a mathematician of course
12:01:49 <monochrom> http://memegenerator.net/instance/12243661 "I don't always try to study / but when I do, I end up here" :)
12:02:05 <Goosey_> Okay.
12:02:25 <ricree> By the way, can anyone tell me why this causes an ambiguous type error in ghci?  "let x  = (arr (+3))".  When I check the right hand side, ":t (arr (+3))" seems to give the result I'd expect.
12:02:55 <hpaste> cobra-the-joker pasted â€œGUI-CAlculatorâ€ at http://hpaste.org/55467
12:02:59 <rwbarton> ricree, the monomorphism restriction
12:03:01 <rwbarton> @type arr (+3)
12:03:02 <lambdabot> forall a (a1 :: * -> * -> *). (Num a, Arrow a1) => a1 a a
12:03:39 <rwbarton> value bindings like "let x = ..." (as opposed to function bindings) aren't allowed to be polymorphic in a variable that has a type class contraint
12:03:52 <rwbarton> unless you give an explicit type signature
12:04:01 <cobra-the-joker> ricree, its a GUI calculator ... buttons num0 ..num9 are just numeric buttons
12:04:19 <rwbarton> ricree: use :set -XNoMomonorphismRestriction to disable this
12:04:39 <ksf> weee, this is fun.
12:04:57 <ksf> polymorphic lists with arbitrary numerical constraints on individual members.
12:05:37 <ricree> rwbarton, shouldn't "let x = ((arr (+3)) :: (Arrow a, Num c) => a c c" work, then?
12:05:52 <rwbarton> yes
12:06:00 <rwbarton> well, if the parentheses were balanced
12:06:03 <cobra-the-joker> ricree , now ... numb doesnt keep its value ... so when i click on any button ... numb just have the current number only not the whole string !
12:06:11 <alistra> oh my god, dexters season finalle
12:06:18 <rwbarton> hmm
12:06:30 <rwbarton> oh
12:06:35 <Saizan> let x :: (Arrow a, Num c) => a c c; x = arr (+3)
12:06:51 <frigga> alistra: Nooooo!  Don't spoil it.
12:06:51 <rwbarton> yes, write that instead
12:07:03 <alistra> frigga: i'm watching atm
12:07:21 <alistra> hank moody dies
12:07:25 <ricree> ah, thank you very much Saizan and rwbarton
12:07:57 <xplat> jr "bob" dobbs dies
12:08:27 <xplat> wait, don't tv spoilers belong in #-blah?
12:08:42 <xplat> or possibly the 5th circle of hell?
12:08:49 <Saizan> they surely don't belong here :)
12:09:09 <carpi> in an 'if' construct.. am i correct in assuming that if the then part is an IO action then the else part must also be an IO action?
12:09:16 <ricree> cobra-the-joker, the gui library you're using presumably has some sort of function for state variables.  There will functions to explicitly get and set those.
12:09:40 <alistra> > if True then 5 else putStrLn "k"
12:09:41 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.IO ()))
12:09:41 <lambdabot>    arising from the literal...
12:09:46 <alistra> oh my god
12:09:49 <mike-burns> carpi: Yes.
12:10:07 <cobra-the-joker> ricree , i want to just set and get the numb variable at the beginning of the file
12:10:16 <carpi> mike-burns: but what if I have nothing to do for the else part?
12:10:30 <ksf> carpi, return ()
12:10:32 <ksf> or "when"
12:10:34 <ksf> :t when
12:10:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:11:00 <carpi> when?
12:11:06 <carpi> its not here in ghci
12:11:14 <ksf> it's in Control.Monad
12:11:20 <ksf> :m +Control.Monad
12:11:21 <alistra> @hoogle when
12:11:21 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
12:11:21 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
12:11:21 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
12:11:22 <mike-burns> @src when
12:11:22 <lambdabot> when p s = if p then s else return ()
12:11:35 <mike-burns> It handles the   return ()   for you.
12:12:09 <carpi> you mean i can replace the entire if construct with a simple 'when'?
12:12:36 <ksf> yep.
12:12:51 <xplat> when lifeIsGood whistleALittleTune
12:13:03 <ricree> cobra-the-joker, it would help if you pasted what you had so far.  but basically you'll just want to get the current value, change it based on what button was pressed, then update the display
12:13:12 <ksf> ...modulo parenthesis and such, "when" isn't a keyword but a function.
12:13:52 <cobra-the-joker> ricree . i pasted it early on http://hpaste.org/55467
12:14:33 <ricree> missed that, sorry
12:14:33 <kumil> > let when bool m = if bool then m else return () in when True (print "Hello")
12:14:34 <lambdabot>   <IO ()>
12:14:44 <carpi> thanks for the 'when' .. )
12:16:21 <kumil> > let when bool m = if bool then m else return () in when True (getLine)
12:16:22 <lambdabot>   Couldn't match expected type `()'
12:16:22 <lambdabot>         against inferred type `[GHC.Types...
12:16:33 <kumil> > let when bool m = if bool then m else return () in when True (getLine >> return ())
12:16:34 <lambdabot>   <IO ()>
12:16:59 <kumil> that's a bit tricky so watch out for that
12:17:00 <alistra> why lambdabot is afraid of IO?
12:17:16 <xplat> lambdabot is hosted in a missile silo
12:17:24 <xplat> so enabling IO is very dangerous
12:17:57 <ricree> cobra-the-joker,  it looks like you're trying to set an immutable variable.  I'm not totally familiar with the GTK lib, but there will be a function to pull the current text from calculation
12:18:06 <augur> are there undecidable problems that arent just versions of the halting problem?
12:18:11 <alistra> all i hear is pussy talk
12:18:18 <alistra> don't have the balls to do it
12:18:20 <cobra-the-joker> ricree , aha i will see that
12:18:33 <xplat> > launchMissiles
12:18:34 <lambdabot>   <IO ()>
12:18:39 <alistra> augur: yes
12:18:48 <augur> do tell
12:18:50 <alistra> augur: context grammars
12:18:57 <xplat> augur: there are ones that are even worse!
12:19:02 <augur> xplat: oh?
12:19:02 <alistra> post-correspondence problem
12:19:13 <alistra> arithmetic-decidability
12:19:17 <rwbarton> halting problem for a machine equipped with an oracle for the halting problem
12:19:25 <rwbarton> probably this isn't the class of example you are interested in though
12:19:28 <xplat> arithmetic truth is much worse than the halting problem
12:19:38 <cheater> rwbarton: it's a very interesting example though
12:19:45 <alistra> basically each problem that you have to traverse an infinite graph and the answer may not exist :P
12:19:46 <xplat> validity of ordinal notations is much worse than even arithmetic proof
12:19:48 <cheater> rwbarton: since it shows a very clear way to always construct a new one
12:19:52 <rwbarton> yes
12:20:02 <xplat> er, truth
12:20:38 <ricree> cobra-the-joker, wild guess is that it will look something like "numb <- get calculation entryText" as the first line
12:20:42 <rwbarton> augur: http://en.wikipedia.org/wiki/Turing_degree
12:20:49 <ricree> but I'm not certain
12:20:54 <Saizan> "stuff that's not semi-decidable" is a start
12:21:05 <xplat> and then you get into ones like 'validity of ordinal notations that are able to condition on the validity of normal ordinal notations' but those while harder aren't very interesting
12:21:06 <cobra-the-joker> ricree, yep it is
12:21:56 <rwbarton> augur: there are also problems that are "easier" than the halting problem but still undecidable
12:22:01 <alistra> augur: i can try to find my old computational complexity exams
12:22:08 <alistra> they probly have some undecidable thingies
12:22:37 <rwbarton> easier in the sense that even if you have a Turing machine with an oracle for this other problem, you cannot solve the halting problem
12:22:43 <alistra> or not
12:23:20 <alistra> oh A COOL ONE
12:23:31 <alistra> checking if 2 programs are equivalent is undecidable
12:23:45 <alistra> (not syntactically, but intentionally)
12:23:53 <alistra> like mergesort and quicksort
12:24:35 <shachaf> alistra: You mean extensionally?
12:25:24 <alistra> extensionally is like beta-reduction
12:25:28 <alistra> and is decidable
12:25:37 <alistra> intensionally is undecidable
12:26:41 <alistra> but i saw that http://klee.llvm.org
12:26:59 <alistra> it checks by bruteforcing all code paths
12:27:14 <alistra> (but it loops if those programs loop, so it's stull undecidable)
12:28:14 <xplat> alistra: you're mixing um intensionally and extensionally
12:28:16 <rwbarton> what?
12:28:20 <xplat> mixing up
12:28:22 <alistra> am i?
12:29:37 <xplat> yes
12:30:00 <xplat> extensionally equivalent == compute the same values on the same inputs
12:30:29 <xplat> intensionally equivalent == programs themselves have same normal form
12:30:35 <dolio> Intensional is, 'have the same defintion, up to computational rewrite rules.'
12:30:50 <alistra> oh
12:30:54 <alistra> so i mixed them up
12:30:55 <dolio> Extensional is, 'behave the same up to observation.'
12:31:07 <xplat> (assuming your calculus normalizes well enough to say that, otherwise intensional is what dolio said)
12:33:14 <dolio> You can move them around a bit, too.
12:33:34 <dolio> Conceivably you might want an even more intensional relation where you don't even compute.
12:33:52 <dolio> Or, you might consider eta expansion intensional or extensional.
12:34:01 <alistra> ok
12:34:15 <alistra> so extensionally checking if 2 programs are equal is undecidable
12:34:16 <xplat> so one of the interesting things is
12:34:35 <dolio> Eta isn't usually a compute rule, and it needs to be type-directed, unlike beta.
12:34:55 <xplat> deciding which of the undecidable problems easier than halting reduce to each other
12:35:05 <ryuk58> how can i make this: system "ls -lR" , to give String
12:35:07 <xplat> is much harder than deciding halting
12:35:25 <rwbarton> can any of those problems be written down explicitly?
12:35:32 <xplat> (as hard as deciding arithmetic truth)
12:35:36 <rwbarton> oh I guess so
12:35:58 <rwbarton> fsvo explicitly
12:37:14 <mike-burns> :t system
12:37:14 <lambdabot> Not in scope: `system'
12:37:31 <xplat> ryuk58: there's a package to do that sort of thing nicely
12:37:39 <xplat> i think it's called 'process'?
12:39:03 <alistra> metaspoiler: dexter has a cool season finalle
12:39:33 <Botje> god dammit
12:39:52 <ricree> yeah System.Process.  readProcess is probably what ryuk58 is looking for
12:39:53 <Botje> I'm like four episodes behind, with no hope of seeing them all before newyear :(
12:40:28 <mike-burns> @hoogle readProcess
12:40:28 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
12:40:28 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
12:41:23 <lukish_> Question about banana from ex20 from http://blog.tmorris.net/20-intermediate-haskell-exercises/
12:41:27 <lukish_> banana f (State s) = State (\x -> state ( f . snd . s $ x ) x)
12:42:02 <lukish_> s $ x -- here s :: State s m and x :: ?
12:44:35 <lukish_> Actually, what is type of s in (State s) ?
12:46:04 <cobra-the-joker> ricree, you said that i am trying to change an immutable variable ... how can i make it changable ?
12:46:20 <kumil> cobra-the-joker: Data.IORef
12:46:29 <cobra-the-joker> kumil, ok
12:46:40 <kumil> cobra-the-joker: but they you're stuck in the IO monad
12:46:43 <kumil> but then*
12:47:20 <cobra-the-joker> hmmm
12:47:55 <cobra-the-joker> kumil, this Data.IORef will be as a C global variable .. right ?
12:48:26 <Botje> more like a piece of memory you allocated with malloc or new
12:48:36 <carpi> out of curiosity..is it possible for 2 types to have the same values?
12:48:37 <cobra-the-joker> aha ok
12:48:58 <Botje> *a pointer to a piece of ..
12:49:19 <carpi> like for example is it possible for a data type D to have value Enc or Dec and another data type C to have Enc or Dec as well?
12:49:31 <Botje> what would the type of Enc be?
12:49:40 <donri> it's possible with qualified imports
12:49:40 <cheater> seeing "*a pointer" makes me think "pointer to *a" which means "pointer to pointer to a"
12:49:56 <Botje> that is so meta :
12:50:37 <carpi> Botje: thats the question.. cos if i knew the type of Enc in C and Enc in D was resolvable.. then I wouldn't have had this doubt
12:51:14 <Botje> carpi: you can put C and D in different modules
12:51:21 <dmwit> carpi: No, a single fully-qualified constructor may not inhabit two different fully-qualified types.
12:51:25 <Botje> then you get CModule.Enc and DModule.Enc
12:51:34 <Botje> but that's about as close as the compiler will allow you to get
12:51:41 <carpi> donri: thanks for the clarification. so .. as long as i don't defined C and D in the same module and as long as I import them as qualified then i can use them
12:51:54 <rwbarton> CModule.Enc and DModule.Enc will be totally unrelated values though
12:52:01 <dmwit> rwbarton: exactly
12:52:03 <Botje> carpi: of course, why do you want this?
12:52:14 <lukish_> mzero: hi
12:53:20 <carpi> Botje: i was writing some code and I was using a package from hackage. And i realized that I unintentionally gave the same values for one of my data types that the author of the package im using, gave to his data types.. so i was wondering if i should change my code or if it is okay to leave it be..
12:53:25 <carpi> seems like i have to change my code : (
12:53:42 <rwbarton> you didn't give the same values.
12:53:46 <rwbarton> you used the same name.
12:53:50 <dmwit> Yeah, you're misunderstanding our answers.
12:53:59 <Botje> you can hide the module author's data constructors.
12:54:06 <Botje> or explicitly qualify them.
12:54:06 <carpi> ah yes.. same name for the values
12:54:27 <stulli> is x <- return y considered an anti pattern or is it actually useful in certain circumstances?
12:54:45 <donri> personally i find it sad that the apparent clumsiness of qualified imports make people namespace identifiers, e.g. liftM vs M.lift
12:54:46 <opqdonut> it will always be the same as "let x = y"
12:54:57 <opqdonut> or well, for all monads that obey the monad laws
12:55:07 <opqdonut> stulli: ^
12:55:27 <cobra-the-joker> complete headache
12:55:31 <dmwit> carpi: You might enjoy my explanation of naming in Haskell: http://stackoverflow.com/questions/8327032/write-this-scala-matrix-multiplication-in-haskell/8331995#8331995
12:55:44 <stulli> opqdonut: Thanks, i just saw it in the Darcs code and was wondering if it might be more performant or something.
12:55:57 <donri> also relevant http://www.haskell.org/haskellwiki/Import_modules_properly
12:56:05 <opqdonut> dmwit: hah! I still like my answer
12:56:17 <rwbarton> it's not quite the same
12:56:22 <opqdonut> strictness?
12:56:30 <rwbarton> x can't be polymorphic
12:56:35 <rwbarton> if you write x <- return y
12:56:46 <rwbarton> that said, it is most likely an antipattern
12:57:02 <opqdonut> oh, right.
12:57:23 <donri> do x <- y; return y -- *snicker*
12:57:28 <donri> uh, return x
12:57:58 <donri> hlint detects that one, not sure about yours
12:58:00 <dmwit> opqdonut: bleh. This was like his third question asking the same thing, and your answer was basically the same answer he had failed to understand on the other questions. =P
12:58:18 <Patinho`Busy> hi all
12:58:27 <opqdonut> dmwit: most of the other answers were hand-waving. it was quite understandable that he didn't get them
12:58:39 <dmwit> That's true enough.
12:58:45 <opqdonut> but I'm not sure he got anything in the end
12:59:10 <stulli> donri: Just checked, hlint indeed gives a warning
13:00:08 <donri> nice
13:01:19 <rwbarton> "x <- return y" usually means the author doesn't know about the existence of the "let x = y" syntax
13:01:43 <Saizan> or wants the shadowing
13:02:00 <donri> or wasn't thinking of it at the time
13:02:02 <rwbarton> oh, true
13:02:12 <opqdonut> donri: yeah, refactoring
13:03:05 <salisbury> augur !
13:03:08 <dmwit> This *must* be a duplicate: http://stackoverflow.com/questions/8567743/how-to-extract-value-from-monadic-action
13:05:12 <carpi> dmwit: could you please tell me what you mean by "A typeclass includes a class name, a list of type variables bound by that class, and a collection of variables with type signatures that refer to the bound variables"? in the answer at the link you gave me?
13:05:51 <dmwit> carpi: Did you take a look at the example directly below it?
13:06:31 <dmwit> ?src Num
13:06:31 <lambdabot> class  (Eq a, Show a) => Num a  where
13:06:31 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:06:32 <lambdabot>     negate, abs, signum     :: a -> a
13:06:32 <lambdabot>     fromInteger             :: Integer -> a
13:06:35 * hackagebot network-bitcoin 0.1.4 - Interface with Bitcoin RPC  http://hackage.haskell.org/package/network-bitcoin-0.1.4 (MichaelHendricks)
13:06:42 <carpi> i did.. but somehow i dont seem to get it.. sry
13:06:48 <dmwit> Okay, no problem.
13:07:01 <kumil> Is there any way to write this so it works without writing my own version of sepBy? http://codepad.org/L7KPMGZL
13:07:06 <dmwit> So, the class name part should be pretty clear: each class defines a new name at the type level.
13:07:28 <dmwit> The list of type variables are the "a b c" or "m" or "x y z" after the class name.
13:07:29 <carpi> by type level you mean type class level?
13:07:33 <dmwit> I do not.
13:07:35 <kumil> as you see, passing try to sepBy doesn't work
13:07:46 <dmwit> There are only two naming levels in Haskell: value-level and type-level.
13:07:56 <dmwit> So types and classes share the same naming level.
13:08:08 <carpi> ..which is the type level?
13:08:30 <carpi> and by classes.. you mean.. 'types and type classes share the same naming level'?
13:08:40 <Botje> kumil: you could use many1 space
13:08:48 <dmwit> To the latter question, yes.
13:08:50 <Botje> kumil: but spaces matches zero or more spaces, so why not use that?
13:08:57 <dmwit> To the former, I'm not sure how to answer.
13:09:09 <dmwit> You are familiar with sneaky data types like "data Nil = Nil"?
13:09:11 <rwbarton> the type level is the level that types are on.
13:09:19 <Botje> kumil: you only need try if your parser will eat chars that another parser needs
13:09:27 <dmwit> That defines two distinct names, Nil at the type level (the type Nil), and Nil at the value level (the data constructor Nil).
13:09:39 <kumil> Botje: the try doesn't work. My parser fails
13:09:47 <kumil> Botje: see the output, it doesn't work
13:10:00 <carpi> ah yes..that i understand.. cos types and values can have the same name since each is used in a different context in code
13:10:12 <stulli> Saizan: I fail to see what is being shadowed by "x <- return y". Could you give a quick hint?
13:10:13 <dmwit> That's all I meant by two levels: you can have two distinct things with each particular name, and which thing they refer to depends on where in the syntax they appear.
13:10:20 <dmwit> carpi: exactly
13:10:35 <ryuk58> what's the error in this: readProcess "system" ["ls -lR"] [] "
13:10:46 <dmwit> Okay, so a type class starts out by creating a new type-level name (e.g. Num or Monad or whatever).
13:10:52 <ryuk58> forget the last "
13:10:56 <Saizan> stulli: well, not there in particular, but e.g. x <- return (x + 1)
13:10:58 <dmwit> ?hoogle readProcess
13:10:58 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
13:10:59 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
13:11:13 <dmwit> ryuk58: Looks fine, the error is in the context.
13:11:13 <Botje> kumil: oh. I see. you want sepEndBy
13:11:14 <rwbarton> ryuk58: well you could start by telling us what kind of error you are getting
13:11:15 <carpi> for some silly reason.. i always thought that there were 4 levels in haskell.. 1) typeclass 2) data types 3) functions and 4) normal values
13:11:19 <Botje> kumil: instead of sepBy.
13:11:27 <rwbarton> however, you probably don't have an executable named "system"
13:11:29 <stulli> Saizan: Oh, i see, thanks
13:11:34 <dmwit> carpi: Ah, nope. The first two and the last two are the same.
13:11:36 <carpi> but now i understand that typclass and data types are one level and functions and values are at the value level
13:11:42 <kumil> Botje: oh. thanks
13:12:20 <dmwit> carpi: Okay; does that clear up the sentence you were worried about in my explanation, or would more explanation be helpful?
13:12:23 <monochrom> "functions and values" = "values". just like "circles and conic sections" = "conic sections"
13:12:24 <ryuk58> readProcess: system "ls -lR" (exit 127): failed
13:12:26 <Botje> kumil: if you have more complicated inputs, consider switching to a tokenizing parser, which does the spaces stuff for you.
13:12:40 <donri> ryuk58: maybe you mean something like readProcess "ls" ["-lR"], not sure about that last String argument
13:12:41 <dmwit> ryuk58: Oh, you probably want system "ls" ["-lR"]
13:12:57 <dmwit> system "ls" ["-lR"] ""
13:13:10 <dmwit> argh
13:13:14 <dmwit> s/system/readProcess/
13:13:20 <carpi> one more question that would clarify it for me.. is.. by 'type variables' are you referring to the parameters passed to the class?
13:13:33 <dmwit> Yes.
13:13:45 <dmwit> For example, in "class Num a where ...", the "a" is the type variable.
13:14:03 <carpi> and the parameter is surely another type from the type level?
13:14:06 <ryuk58> thx its working
13:14:09 <carpi> ah yup
13:15:44 <carpi> and why do you refer to foo as a variable when in fact its a function? Is it because functions are values and values can be variables?
13:16:16 <dmwit> Values are not variables.
13:16:26 <dmwit> I refer to foo as a variable because it is a variable.
13:16:41 <dmwit> Maybe it's clearer to say foo is a name?
13:16:41 <kumil> Botje: what if I had (word `sepBy` (spaces >> string "," >> spaces) and I don't want to allow a trailing comma but I do want to allow trailing spaces?
13:17:12 <dmwit> "variable" and "name" are pretty much the same thing, as far as I'm concerned.
13:17:25 <Nisstyre> dmwit: equation maybe?
13:17:37 <dmwit> No, I explicitly don't care whether it's coming from an equation or an import.
13:17:47 <carpi> dmwit: something like let x = 3.. would be a variable .. no? and i think in haksell lingo.. the word 'name' is clearer..
13:17:56 <carpi> but thats just me
13:18:07 <dmwit> "let x = 3" is not a variable, though "x" would be a variable.
13:18:09 <Nisstyre> well variables are constant in mathematics...
13:18:28 <carpi> oh sory..thats what i mean.. x is a variable.. 'let x = 3' would be an expression
13:18:48 <Nisstyre> constant in the current scope of course
13:19:07 <dmwit> Nisstyre: Not sure I see how that affects our discussion.
13:19:27 <Nisstyre> dmwit: Haskell takes a lot of the naming from mathematics
13:19:31 <Nisstyre> afaict
13:20:40 * dmwit nods agreeably and continues awaiting the punchline
13:20:51 <Botje> kumil: so you don't want "word word ," ?
13:20:55 <Nisstyre> dmwit: there is no punchline
13:21:09 <Botje> uh
13:21:12 <Botje> "word, word ,"
13:21:21 <Nisstyre> I'm saying calling things a variable is a legitimate thing to do in Haskell
13:21:21 <kumil> Botje: yes, I don't want to allow that
13:21:35 <kumil> Botje: but I do want to allow "word, word  "
13:21:52 <ique> @pl (\f -> \a -> \b -> \c -> (f a b c) ++ (f a b c))
13:21:53 <lambdabot> ap =<< (liftM2 (liftM2 (++)) .)
13:22:06 <monochrom> do you also like "word   ,word"?
13:22:22 <Botje> kumil: I think spaces will eat the spaces after your word, and then the parser will fail as there is no comma.
13:22:23 <kumil> yup
13:22:31 <mm_freak> interesting
13:22:38 <mm_freak> you can actually use Integer kinds
13:23:01 <kumil> Botje: exactly. What's the canonical solution to this problem?
13:23:09 <Botje> kumil: there you need the try.
13:23:13 <monochrom> word = many1 letter <* spaces
13:23:18 <mm_freak> what the hell
13:23:19 <mm_freak> append :: Vec n1 a -> Vec n2 a -> Vec (n1 + n2) a
13:23:21 <mm_freak> it works!
13:23:22 <carpi> dmwit: thanks for answer over there at SO. it was clear the for most part.. though i wish you went on to discuss more about typeclasses : ). But i guess that answer was sufficient for the question asked
13:23:23 <monochrom> comma = char ',' <* spaces
13:23:37 <monochrom> whole_thing = word `sepBy` comma
13:23:44 <mm_freak> am i dreaming or does GHC give me dependent types there?!
13:23:45 <dmwit> carpi: Well, what do you want to know?
13:23:45 <ique> @pl (\a -> \b -> \c -> (f a b c) ++ (f a b c))
13:23:45 <lambdabot> (line 1, column 5):
13:23:45 <lambdabot> unexpected "\FS"
13:23:45 <lambdabot> expecting "->"
13:23:54 <monochrom> entry_point = spaces >> whole_thing
13:24:03 <dmwit> mm_freak: You're dreaming. =)
13:24:17 <dmwit> mm_freak: n1 and n2 aren't values, they're types, so it's still not dependent.
13:24:30 <dmwit> mm_freak: GHC *is* getting awfully close to full-spectrum dependency, though. =D
13:24:33 <mm_freak> true
13:24:39 <mm_freak> i'm amazed
13:24:46 <mm_freak> data Vec :: Integer -> * -> * where
13:24:58 <dmwit> yeah
13:25:05 <ique> Is there an online lambdabot somewhere that you can bother with pl's so that I don't have to bug the channel? :P
13:25:06 <monochrom> so, the convention is: at the entry point, skip leading spaces once and for all. now you only have trailing spaces to worry. for each token-level parser, skip trailing spaces.
13:25:25 <Axman6> ique: /msg lambdabot @pl foo  bar
13:25:29 <dmwit> ique: /msg lambdabot ?pl \x y -> x
13:25:29 <carpi> dmwit: its just that.. from a technical standpoint.. i feel like typeclasses are understandable.. but most resources fail to talk about the mindset required to use them in a practical way. For instance if we have a function '*'.. it is imediately obvious as to which situations we can use them..
13:25:51 <aristid> carpi: it is?
13:25:59 <carpi> but not so with typeclassess... they are undeerstanble.. but it seems like it requires a deeper abstract understanding to use them prooperly
13:26:05 <ique> Axman6, dmwit: ah ^^ thanks :D
13:26:16 <mm_freak> dmwit: what really astonishes me is that GHC actually /does/ lift all functions to the type level when you enable PolyKinds
13:26:23 <aristid> carpi: bs, type classes are easy :P
13:26:32 <mm_freak> we were discussing how this could be done earlier this day
13:26:32 <ksf> did really noone do type level regular expressions yet?
13:26:38 <kumil> monochrom: oh. my solution of rewriting sepBy to just backtrack everywhere is probably a worse idea
13:26:41 <dreixel> mm_freak: no, it doesn't?
13:26:51 <carpi> aristid: maybe true for you )
13:27:20 <monochrom> actually entry_point = spaces >> (whole_thing <* eof)
13:27:22 <Axman6> @src functor
13:27:22 <lambdabot> Source not found. There are some things that I just don't know.
13:27:25 <Axman6> @src Functor
13:27:25 <lambdabot> class  Functor f  where
13:27:25 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
13:27:38 <monochrom> actually the parentheses are optional
13:28:02 <Botje> ksf: so how do you parse HTML using regular expressions in the type system? *ducks*
13:28:26 <mm_freak> dreixel: 7.4 seems to
13:28:49 <aristid> carpi: instead of complaining how complicated they are, just write some code and experiment with them
13:28:49 <ksf> Botje, one has to start somewhere.
13:28:54 <monochrom> there is also a reason we don't do the other way (every token-level guy skips leading spaces, entry point finishes up with skipping trailing spaces). I forgot the details, it has something to do with how to detect or ask for eof.
13:29:05 <dreixel> mm_freak: what do you mean by lifting functions to the type level?
13:29:08 <Nisstyre> Botje: you could make a tokenizer with regular expressions, which would technically be parsing using regular expressions if it was part of a parser
13:29:29 <dreixel> like, it would make add :: Nat -> Nat -> Nat into a type family?
13:29:46 <carpi> aristid: thanks for the suggestion.. i will try )
13:29:48 <Botje> ksf: I came across a paper that describes general recursive data types though
13:29:58 <mm_freak> dreixel: yeah
13:30:23 <dreixel> mm_freak: O_o
13:30:24 <Botje> it can give types for arbitrary trees in a lispy language
13:30:39 <dreixel> mm_freak: do you have some code that shows how to do this?
13:30:50 <monochrom> so, if you use the first convention, you never need backtracking to see whether you're at eof. if you use the second convention, you have to go "let me try eating spaces, do I hit eof yet? oh, no? darn, backtrack"
13:31:14 <ksf> Botje, I just used compdata's gadt support and an ad-hoc type level list membership test to validate XRD on the type level.
13:31:39 <ksf> well, or at least I started doing so and it's working for the zero-or-one restraints.
13:31:46 <mm_freak> dreixel: working on it
13:31:46 <rwbarton> x-ray diffraction at the type level?
13:32:03 <ksf> but automagically translating schemas to the type level would be sweet, yes.
13:32:36 <rwbarton> translating relax ng to the type level sounds very interesting and very non-trivial
13:33:04 <ksf> what kind of grammars can relax ng parse?
13:33:05 <rwbarton> I mean, generating appropriate types from a relax ng schema
13:33:07 <Botje> ksf: shiny.
13:33:22 <mm_freak> dreixel: not as straightforward as i expected though
13:33:33 <dreixel> mm_freak: it better be impossible.
13:33:49 <ksf>     Expires :: TElem Exp l (IsFalse m) => Int -> e l -> XrdBase e (TCons Exp l)
13:34:16 <dreixel> I mean, it would be a cool feature.
13:34:16 <ksf> ...it's even generating a half-way readable type error.
13:34:23 <dreixel> but it doesn't exist so far.
13:34:40 <rwbarton> ksf: I am not sure exactly, but it seems non-trivial, for example it has an "interleave" operator
13:34:59 <dreixel> datatypes are promoted to kinds, and constructors are promoted to types
13:35:08 <kumil> monochrom: hmm, I can't eat trailing spaces at the token level because it messes up detecting spaces between tokens
13:35:09 <dreixel> but functions aren't promoted
13:35:19 <kumil> monochrom: I think there's a level at which I can safely eat trailing spaces though
13:36:07 <kumil> wait... I can't use sepEndBy with spaces1
13:36:17 <mm_freak> dreixel: ok, i was overexcited
13:36:27 <kumil> oh wait I defined spaces1, I mean (space >> spaces)
13:36:40 <dreixel> mm_freak: still, PolyKinds are really cool!
13:37:14 <kumil> everything was so easy when I just backtracked everywhere until I noticed my error messages were garbage
13:37:39 <_Mikey> :O
13:37:46 <monochrom> I don't actually believe that spaces are all that important to be preserved
13:37:46 <_Mikey> my graph is eating nodes!!!
13:37:55 <c_wraith> kumil: if you want good error messages, you should use a parser designed for them, like trifecta
13:38:05 <xplat> mm, delicious nodes
13:38:16 <_Mikey> I hate bugs like this.. -.-
13:38:39 <xplat> yes, trifecta is good at making nice error messages and all those other things you want a parser for a human-writable format to do
13:38:43 <dmwit> dreixel, mm_freak: So, I guess automatic lifting of functions isn't possible? But writing your own type family *should* be possible, and you get to give it a kind that restricts its use to exactly type-level numbers. Which is a huge improvement.
13:39:29 <dreixel> dmwit: definitely so.
13:39:57 <dreixel> see the paper for examples: http://dreixel.net/research/pdf/ghp.pdf
13:40:44 <dmwit> Ah!
13:40:53 * dmwit adds a connection in his mental IRC-RL graph
13:41:16 <ksf> rwbarton, having a quick look at its semantics interleave seems perfectly regular.
13:41:38 <ksf> some grammar explosion, yes, but nothing major.
13:42:11 <mm_freak> dmwit: i think lifting functions to the type level is possible, but it should require explicit lifting
13:42:14 <ksf> in fact, relax ng means "regular language for xml next generation"
13:42:25 <mm_freak> dmwit: for example you have to give a name
13:42:40 <Goosey_> I'm a bit confused about this: applyTwice :: (a -> a) -> a -> a; applyTwice f x = f (f x)  is it (a -> a) because applyTwice curried will first take f and return f?
13:42:43 <xplat> interleave like 'bob' interleave 'eve' parses 'bobeve', 'evebob', 'eboveb', etc?
13:43:05 <xplat> that's regular, yeah, similar to the product construction for intersection
13:43:29 <ksf> xplat, not even that, 'eboveb' isn't in it.
13:43:36 <mm_freak> Goosey_: "applyTwice f" returns f . f
13:43:48 <mm_freak> so the type makes sense:  (a -> a) -> (a -> a)
13:43:49 <rwbarton> it isn't?
13:44:03 <ksf> it gets a bit more complicated because bob and eve can have different constraints on how often they may occur, but that's still regular.
13:44:03 <rwbarton> xplat: that's what i thought it was
13:44:08 <Goosey_> mm_freak: What is the purpose of .?
13:44:18 <Axman6> Goosey_: the (a -> a) says it takes a function which takes as and returns as
13:44:19 <xplat> ksf: i'm assuming you spell them <b/><o/><b/> and <e/><v/><e/>
13:44:23 <mm_freak> Goosey_: function composition:  (f . g) x = f (g x)
13:44:34 <ksf> well, then yes, yes.
13:44:59 <ksf> actually, no. interleave boev means you can write bobeve
13:45:10 <ksf> or evebob.
13:47:47 <Goosey_> for a function with two parameters, like the one I gave...With this input: applyT (+1) 1 would it do  applyT (+1) = (+1) (+1) x) then do applyT (+1) ((+1) 1)
13:48:57 <mm_freak> Goosey_: i don't see a function of two arguments there
13:50:32 <mm_freak> Goosey_: leave out the second argument of applyTwice, then it's clearer
13:50:42 <mm_freak> applyTwice (+ 1) = (+ 1) . (+ 1)
13:50:54 <mm_freak> ((+ 1) . (+ 1)) 1 = 3
13:50:58 <xplat> oh, right, interleave was a little wack
13:51:01 <Goosey_> then what does it do with the second argument?
13:51:09 <xplat> not as much so as the version in DTDs, though, iirc
13:51:11 <salisbury> augur?
13:51:18 <ksf> hmmm. relax ng is closed under union, which is *nice*. and gets me thinking.
13:51:24 <mm_freak> Goosey_: haskell is a curried language
13:51:24 <xplat> and still regular
13:51:26 <Goosey_> How do I say, it makes x part of the function body rather than the head, and then moves on to it sort of like changing f x y = x+y to f x = f y+x
13:51:33 <Goosey_> or am I off?
13:51:52 <ksf> xplat, well, it's syntactic sugar.
13:51:52 <mm_freak> Goosey_: it's a matter of simple equation rewriting
13:52:00 <mm_freak> if f = g, then f x = g x
13:52:05 <gabor> I am trying to bootstrap a 32-bit Ghc704 on a 64-bit RHEL machine. Using Ghc6.12.3 (patched to correctly compile with -m32). When Stage1 Ghc is built, cabal kicks in and thinks that it can create 64-bit libs, that messes up everything. How can I convince cabal to build 32-bit libs too?
13:52:05 <ksf> to quickly say that the schema doesn't care about the order of img and p elements.
13:52:08 <Goosey_> oh...
13:52:20 <Goosey_> I see
13:52:22 <mm_freak> applyTwice (+ 1) x = ((+ 1) . (+ 1)) x
13:52:29 <kumil> c_wraith: uh trifecta doesn't seem to be documented yet
13:52:29 <mm_freak> you are applying x to both sides
13:52:45 <Goosey_> I guess I'm still looking at this too imperatively.
13:52:55 <mm_freak> let's say uncurriedly =)
13:52:56 * Axman6 would say applyTwice (+1) = \x -> (+1) ((+1) x)
13:53:00 <Goosey_> :P
13:53:15 <c_wraith> kumil: it does have that problem, yes.  edwardk, its author, is frequently in here.  You could just bug him with enough questions he'll decide documenting it is easier. :)
13:53:21 <Goosey_> So, currying uses anon functions?
13:53:41 <Axman6> Goosey_: it might be helpful to go and learn a bit about lambda calculus, and have some fun actually evaluating some expressions in LC
13:53:57 <mm_freak> Goosey_: basically currying means that a function of two arguments is really a function of one argument returning a function of another argument
13:54:12 <Goosey_> Lets say I hyeah
13:54:22 <Goosey_> I read that about currying, what's confusing me is HOW it's doing it really
13:54:24 <ksf> meaning... the data type could come with witnesses that build themselves into a minimal schema, and be closed under union, too.
13:54:35 <ksf> deriving schemas from code is a *very* useful thing.
13:54:43 * byorgey thinks the Haskell community should all chip in to pay someone to document edwardk's packages full-time
13:54:47 <mm_freak> Goosey_: well, look at the types:  a -> b -> c = a -> (b -> c)
13:54:57 <mm_freak> Goosey_: the function arrow (->) is right-associative
13:55:06 <Goosey_> Okay
13:55:33 <mm_freak> and there is function application, which is left-associative:  f x y = (f x) y
13:56:09 <Axman6> byorgey: i agree -_-
13:56:10 <donri> byorgey: +1
13:56:18 <rwbarton> ksf: schemas from code?
13:56:27 <mm_freak> Goosey_: look at it from a mathematical perspective, not the technical perspective
13:56:53 <Goosey_> Okay,  I think my major confusion is just how it's getting the second argument inside the scope of the new function.
13:56:54 <c_wraith> byorgey: I'd contribute $5/mo.  Just need a few more like me. :)
13:57:10 <Axman6> Goosey_: the way these things are actually implemented is going to be pretty foreign to most programmers
13:57:30 <mm_freak> Goosey_: f x y = â€¦ â‡’ f = \x y -> â€¦ â‡’ f = \x -> (\y -> â€¦)
13:57:33 <Axman6> i'd love ot see trifecta get some docs (if ity hasn't yet)
13:57:42 * byorgey was half-joking but wonders if it is actually feasible.
13:57:56 <Goosey_> I'm getting errors there mm_freak
13:58:08 <ksf> rwbarton, yes, though there are problems.
13:58:10 <mm_freak> Goosey_: that's conceptual
13:58:17 <mm_freak> Goosey_: say you have:  add x y = x + y
13:58:20 <Goosey_> What I mean is, the text has errors
13:58:23 <Philippa> byorgey: it'd be worth explaining to some of the foundations etc just what his stuff's like, too
13:58:27 <mm_freak> Goosey_: oh, it's UTF-8
13:58:30 <ksf> the first one, 0,1, infinity is quite natural, the other one is exploding the grammar.
13:58:37 <Goosey_> Okay, let me change
13:58:38 <Philippa> in that it's definite "if you could see the docs to test it yourself..." territory
13:58:42 <mm_freak> Goosey_: i recommend getting a UTF-8-capable client for this channel =)
14:00:16 <Goosey_> mm_freak: Could you query that to me
14:01:08 <mm_freak> Goosey_: done, but please let's talk here
14:01:28 <Goosey_> Yeah
14:01:39 * hackagebot smtLib 1.0 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.0 (IavorDiatchki)
14:01:40 <Goosey_> Strange, I changed my encoding, but it still has errors :/
14:02:08 <mm_freak> Goosey_: f x y = ... means f = \x y -> ... means f = \x -> (\y -> ...)
14:02:49 <Goosey_> I see, is this what they call lambda abstraction?
14:03:06 <mm_freak> \x -> ...
14:03:15 <mm_freak> that's lambda abstraction, where the backslash means lambda
14:04:09 <Goosey_> so then this: f x y z = x+y+z would be f = \x -> (\y -> (\z -> x+y+z))
14:04:15 <Axman6> yep!
14:04:17 <mm_freak> yes, they are equivalent
14:04:28 <Axman6> Goosey_: what does f 7 become then?
14:04:31 <Goosey_> but the second is curried so it takes one argument
14:04:44 <mm_freak> f 7 = (\x -> \y -> \z -> x + y + z) 7
14:04:50 <Goosey_> OH
14:04:56 <Axman6> which becomes...
14:04:56 <mm_freak> = (\y -> \z -> 7 + y + z)
14:04:59 <Goosey_> So that's how it gets the data into the code...
14:05:38 <mm_freak> well, in haskell it will stay (\x -> \y -> \z -> x + y + z) 7 at first
14:05:44 <mm_freak> until you actually ask for the value of that
14:05:48 <Axman6> then f 7 3 = (\x -> \y -> \z -> x + y + z) 7 4 = (\y -> (\z -> 7 + y + z)) 4 = (\z -> 7 + 4 + z)
14:05:51 <Goosey_> The more I read about haskell, the more I get confused, but the more interested I become :|
14:06:07 <mm_freak> don't worry, that happened to all of us =)
14:06:35 <mm_freak> (most of us, taking into account that some people actually /made/ haskell to begin with)
14:06:38 <Philippa> mmm. Then you get confused on a higher level
14:07:09 <Goosey_> okay
14:07:10 <kumil> I still don't understand laziness/strictness very well but the rest of the semantics are fairly straightforward
14:07:13 <Goosey_> This is making so much more sense.
14:07:29 <mm_freak> Goosey_: you will get used to it, and once that happened, you will be ruined for all other programming languages
14:07:50 <xplat> the people who made haskell were confused by miranda or whatever
14:08:00 <kumil> mm_freak: what about logic programming?
14:08:10 <Goosey_> I use prolog a lot
14:08:18 <mm_freak> kumil: prolog doesn't make me happy and i didn't try mercury yet
14:08:19 <Goosey_> used* I suppose.
14:08:43 <kumil> I prefer tape-based programming
14:08:44 <mm_freak> reason:  i'm an application programmer, and haskell is just better at that
14:09:42 <xplat> if you prefer tape-based programming your brain is ... funged :)
14:09:52 <Goosey_> befunge lol
14:10:36 <Goosey_> so based on all this...lets see if I can make the map function with foldr now
14:10:50 <mm_freak> yeah, go ahead =)
14:11:53 <Goosey_> @t foldr
14:11:53 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:12:04 <Goosey_> > :t foldr
14:12:05 <lambdabot>   <no location info>: parse error on input `:'
14:12:08 <mm_freak> :t foldr
14:12:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:12:40 <mm_freak> better ask GHCi thereâ€¦  lambdabot has some language extensions turned on, which might confuse you
14:12:47 <Axman6> @help thanks
14:12:48 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,19)-(43,48): Non-exhaustive patterns in case
14:12:55 <Goosey_> Yeah, forall is strange..
14:13:11 <Axman6> forget the forall a b., you can completely ignore it
14:13:19 <Goosey_> Why do they put it then :O
14:13:29 <Axman6> no idea
14:13:44 <mm_freak> Goosey_: when the "forall" is on the left side with no parentheses, then it's equivalent to not having it at all
14:13:50 <mm_freak> forall a. a -> a = a -> a
14:13:54 <Axman6> but the type of foldr is (a -> b -> b) -> b -> [a] -> b
14:14:23 <Axman6> forall in that position is implicit in haskell, and you really don't need to worry about it
14:14:59 <Goosey_> let's see the type means: so does (a -> b -> b) mean a is a function which returns (b -> b)?
14:15:09 <mm_freak> yes
14:15:17 <Goosey_> and b is a function which returns b?
14:15:19 <Axman6> but, it might be worth learning how to read those types to yourself. I'd read it as: for all types a anb , if i have a function which can take an a and a b and return a b, and a, and a list of bs, then i can produce a b using foldr
14:15:20 <mm_freak> a -> b -> b = a -> (b -> b)
14:15:34 <Axman6> wait, no
14:15:44 <mm_freak> and b -> b is the type of a function that takes a value of type b and returns a value of type b
14:16:05 <Axman6> Goosey_: (a -> b -> b) says you need to give a function which can take an a and a b and return a b
14:16:30 <Goosey_> So it first takes a then takes a b?
14:16:40 <mm_freak> Goosey_: it's not 'a', which is a functionâ€¦  the whole thing is only a type and the letters you see there are variable types
14:16:42 <Axman6> yes
14:17:21 <kumil> Goosey_: it's the same as function types are written in mathematics
14:17:21 <mm_freak> Goosey_: just like 'id :: a -> a', which means:  'id' (!) is a function that takes a value of type 'a' and returns a value of type 'a'
14:18:04 <Goosey_> so basicallyh (a -> b -> b) -> b -> [a] -> b means it takes a value of a, then it takes a value of b(currying)....Wait >_<
14:18:14 <mm_freak> nope
14:18:15 <Goosey_> Is the last variable the only output?
14:18:25 <augur> salisbury!
14:18:25 <mm_freak> it takes a value of type 'a -> b -> b', which is a function
14:18:30 <augur> jeff said you havent emailed him
14:18:30 <mm_freak> so the first argument to foldr is a function
14:18:34 <Goosey_> meaning the first 3 are inputs?
14:18:38 <salisbury> Ahh, no, I haven't as yet
14:18:45 <salisbury> Its been an odd weekend
14:18:47 <Goosey_> and (a -> b -> b) is considered one input
14:18:50 <Axman6> Goosey_: yes, you can think of it as that
14:18:53 <kumil> Goosey_: think of the universal quantification as implying the existence of a potentially infinite number of functions
14:18:57 <Axman6> (i do)
14:18:58 <Goosey_> but to do that, it needs to take an input of a and b and return b
14:19:05 <mm_freak> kumil: uh, don't do that ;)
14:19:08 <Axman6> kumil: wut?
14:19:10 <Goosey_> so (a -> b -> b) is a function itself?
14:19:24 <Goosey_> meaning one of foldr's inputs has to be a function?
14:19:28 <Axman6> yes!
14:19:28 <mm_freak> Goosey_: foldr f z xs
14:19:28 <kumil> mm_freak: do what? I mean that when your function is used the type variables will take on values
14:19:34 <mm_freak> Goosey_: f :: a -> b -> b
14:19:34 <Goosey_> I'm having a period of enlightenment xD
14:19:39 <mm_freak> z :: b
14:19:41 <kumil> mm_freak: err take on types, specific types that is
14:19:44 <mm_freak> xs :: [a]
14:19:46 <kumil> mm_freak: what's wrong with doing that?
14:20:01 <Goosey_> wow, so b is the output of foldr?
14:20:07 <Axman6> kumil: when someone's never done any kind of type theory, or even lambda calculus, it;s extremely confusing to use such language
14:20:11 <Goosey_> and the function modifies b
14:20:12 <salisbury> I'm trying to finish up this data input section, which will allow me to focus entirely on the machine learning side of things, but I was interrupted by some Christmas parties
14:20:13 <Axman6> Goosey_: yes
14:20:13 <mm_freak> kumil: not saying you're wrong, but i think Goosey_ isn't ready for that yet
14:20:35 <Cale> Goosey_: Every list is built up using the function (:) and the value [], what foldr f z does is to replace every occurrence of the function (:) in the list with the function f, and replace the [] at the end (if any) with z
14:20:50 <Goosey_> okay
14:20:52 <salisbury> I'll probably contact him tonight
14:20:53 <ziman> @pl \(m,(n,x)) -> (f m n, x)
14:20:53 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . f)
14:21:13 <Cale> http://cale.yi.org/share/Folds.svg <-- here's a diagram :)
14:21:20 <mm_freak> Goosey_: the function modifies a value of type 'b'
14:21:25 <mm_freak> it doesn't modify b (the type)
14:21:41 <hpc> > foldr (+) z [a, b, c, d] :: Expr
14:21:42 <lambdabot>   a + (b + (c + (d + z)))
14:21:47 <Goosey_> Cale: so the function to make map would require : in it?
14:21:47 <mm_freak> Goosey_: Cale's explanation is probably the most useful one, once you understood the type signature =)
14:21:54 <Cale> Goosey_: yeah
14:22:06 <Goosey_> God dang, this channel is amazing xD
14:22:08 <Goosey_> Thanks guys.
14:22:12 <hpc> > foldr (+) z (a : b : c : d : []) :: Expr
14:22:13 <lambdabot>   a + (b + (c + (d + z)))
14:22:16 <salisbury> augur forgot to include your name on those ^
14:22:26 <Cale> Goosey_: One surprisingly useful thing to notice is that foldr (:) [] does nothing
14:22:39 <Cale> (because it replaces (:) with (:) and [] with [])
14:22:45 <Axman6> Goosey_: we're not leaving you be until you get that map using foldr working though! :P
14:22:45 <Goosey_> lol
14:22:57 <Goosey_> Axman6: I sure hope not! :D
14:23:04 <mm_freak> Goosey_: try to understand the type signature unrelated to foldrâ€¦  i.e. learn reading type signatures
14:23:24 <mm_freak> for example try to write a type signature for your myMap =)
14:23:24 <Goosey_> :t map
14:23:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:23:28 <Cale> Goosey_: so if we tweak that first bit, and instead of using a function which adds an element to the beginning of a list, use a function which applies some other function f to that element before adding it to the beginning of the list
14:23:33 <Cale> then we get map :)
14:23:39 <Cale> well, map f
14:23:40 <mm_freak> ok, that exercise is moot now that you cheated =P
14:23:52 <Goosey_> xD sorry freak
14:24:00 <augur> salisbury: ah
14:24:17 <Cale> So,  map f = foldr ((:) . f) []
14:24:29 <Axman6> Cale!
14:24:34 <Cale> (that's being a little fancy about it)
14:24:37 <hpc> SPOILERS!
14:24:39 <Goosey_> is this close: (\x -> f x :)
14:24:39 <Cale> What?
14:24:43 <Axman6> i reckon
14:24:49 <mm_freak> Cale: writing map was his exercise ;)
14:24:51 <Cale> yeah, that's pretty close, except for the syntax
14:25:02 <Cale> (\x xs -> f x : xs) would work
14:25:06 <Axman6> Cale: the whole point of this exercise was for him to figure out how to do it
14:25:15 <Cale> Ah, I wasn't around in the beginning
14:25:18 <Peaker> hlint takes a     foldr cons nil . map f   and suggests:   foldr (cons . f) nil
14:25:22 <Peaker> which is weird!
14:25:41 <Cale> Peaker: cool, it knows the free theorem :)
14:25:42 <mm_freak> Peaker: why is that weird?
14:26:01 <Peaker> because usually hlint gives nice-style hints, not optimization hints
14:26:17 <Peaker> and I think style-wise, seeing it's a map is nicer
14:26:23 <mm_freak> is that an optimization, when you consider lazy evaluation?
14:26:36 <Cale> Yes, it is, in terms of allocation which needs to be done
14:26:38 <Peaker> mm_freak: it probably gets rid of the extra intermediate list)
14:26:47 <Cale> But it's only a constant factor
14:26:51 <mm_freak> true
14:26:59 <Peaker> Cale: almost all optimizations are a constant factor :)
14:27:27 <mm_freak> for time complexity, yes =)
14:27:32 <dolio> Cale: What brand of magnet balls is best?
14:27:55 <Axman6> ha
14:28:08 <Cale> dolio: I really like Zen Magnets and people who have compared them say that they're the best, but I haven't played with any of the others.
14:28:22 <dolio> Okay.
14:28:23 <Goosey_> > [1..10]
14:28:24 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:28:28 <Goosey_> erm
14:28:35 <Goosey_> my map omits the last one..
14:28:40 <Cale> Zen Magnets has this program where if you take nice pictures and get them accepted to the gallery, you can win more free magnets.
14:28:44 <mm_freak> Cale: is it true that zen magnet rings are magnetically neutral?
14:28:49 <Goosey_> map' f (x:xs) = foldr (\x xs -> f x : xs) xs []
14:28:57 <Cale> and almost half of the magnets I own were free :)
14:29:07 <alistra> i want a free magnet
14:29:12 <alistra> link!
14:29:16 <Cale> mm_freak: Well, from far enough away, pretty much, yeah.
14:29:17 <Axman6> Goosey_: almost, swap xs and [] at the end
14:29:17 <mm_freak> Goosey_: try that one out
14:29:30 <Axman6> :t foldr
14:29:31 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:29:43 <Goosey_> Oh
14:29:47 <Cale> alistra: you win 216 at a time, even!
14:29:52 <Cale> http://zenmagnets.com/
14:30:02 <mm_freak> Goosey_: try to define 'map' in terms of the first two arguments of 'foldr'
14:30:02 <Goosey_> Axman6: Now it leaves out the first one >_<
14:30:10 <Cale> alistra: (but they're all 5mm balls)
14:30:10 <mm_freak> Goosey_: in other words, write it like this:  map f = foldr â€¦
14:30:14 <alistra> Cale: want to give me a referral for a magnet?
14:30:16 <Goosey_> okay
14:30:19 <Axman6> the types you're aftwer are actually: (a -> [b] -> [b]) -> [b] -> [a] -> [b]
14:30:24 <Axman6> gmm, that really not very helpful XD
14:30:25 <alistra> Cale: do they have referrals?
14:30:29 <Cale> I don't know
14:30:45 <Axman6> Goosey_: map' f xs = ...,m there's no need to pattern match on (x:xs)
14:30:53 <Axman6> -m
14:31:11 <Cale> But they're cool guys, the owner of the company was my SC2 practice partner for a while :)
14:31:24 <Axman6> SC2?
14:31:29 <Cale> StarCraft 2
14:31:33 <Axman6> ah, heh
14:31:43 <byorgey> Subtyping Calculus
14:31:56 <Axman6> sounds more likely
14:32:01 <mm_freak> Goosey_: notice that "map f xs = foldr ff fz xs" can be simplified to "map f = foldr ff fz"
14:32:07 <mm_freak> Goosey_: so your task is to find ff and fz =)
14:32:22 <Goosey_> okay
14:33:15 <alistra> you have to have magnets
14:33:17 <alistra> to win more
14:33:17 <alistra> :/
14:34:29 <mm_freak> Goosey_: if you are lost, look at the definitions of (explicitly recursing) map and foldr
14:34:44 <Axman6> @src map
14:34:44 <lambdabot> map _ []     = []
14:34:44 <lambdabot> map f (x:xs) = f x : map f xs
14:34:47 <Axman6> @src foldr
14:34:47 <lambdabot> foldr f z []     = z
14:34:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:35:06 <byorgey> alistra: no, you can bootstrap the process using photoshop ;)
14:35:06 <Axman6> hmmmm, that look quite similar :o
14:35:20 <Axman6> byorgey: or any decent raytracer
14:35:24 <byorgey> that too
14:35:31 <Axman6> probably more fun too =)
14:35:56 <Axman6> i wonder what they'd do if you wrote a raytracer explicitly for the purpose
14:36:00 <alistra> also you have to be good at design
14:36:21 <mm_freak> alistra: with a raytracer?  not reallyâ€¦  grab an existing scene and add the balls to it ;)
14:36:29 <Axman6> ha
14:36:37 <alistra> i mean those contest
14:36:41 <alistra> are for the prettiest X
14:36:43 <mm_freak> me too =)
14:36:46 <Axman6> I should write a GPU raytracer some time... maybe I'll start with a CPu one though
14:36:52 <Axman6> U*
14:36:56 <alistra> i consider myself a backend guy, i don't like graphics
14:37:04 <alistra> and other gay shit like that :P
14:37:08 <mm_freak> alistra: yes, raytracers are for people like us
14:37:22 <mm_freak> you write the scene as source code ;)
14:37:29 <alistra> still
14:37:34 <alistra> you have to imagine it
14:37:42 <Axman6> yeah me too.. but graphics shit can mean sweet HPC stuff. anything to male my CPU/GPU hot makes me happy :P
14:37:51 <mm_freak> alistra: you could use a physics simulator
14:37:52 * hpc stuff
14:38:04 <Axman6> hpc: you make me hot'
14:38:09 <hpc> :D
14:40:08 <alistra> anybody here know rtnetlink?
14:40:39 <Axman6> I think I got trolled by a knife I just bought. I'm pretty sure some of the text on it is in comic sans
14:40:59 <alistra> pictures!
14:41:00 <Axman6> hmm, maybe not... but it's close enough
14:41:52 <Cale> Axman6: SPJ Knife
14:41:57 <alistra> also why do you buy knives
14:42:00 <JeroenDL> Can someone give me an example of how I can create a recursive function in pure lambda calculus that counts up from 1 to infinity ?
14:42:06 <Goosey_> mm_freak: I'm confused
14:42:14 <Axman6> Cale: ha, yes :)
14:42:22 <Goosey_> How is it that it can be simplified to foldr xx yy if foldr has 3 arguments?
14:42:33 <alistra> JeroenDL: recursive in pure lambda calculus?
14:42:37 <Cale> JeroenDL: In untyped lambda calculus?
14:42:44 <mux> what's pure lambda calculus? untyped lambda calculus?
14:42:49 <JeroenDL> Uhm, yeah
14:42:53 <Axman6> Goosey_: it's called point free style, and i'd advice you ignore it for a while
14:43:02 <alistra> still even in pure you don't have recursion
14:43:03 <alistra> i think
14:43:06 <Cale> JeroenDL: and what counts as counting from 1 to infinity? Producing an infinite list?
14:43:08 <Axman6> JeroenDL: homework?
14:43:12 <Cale> (in Church encoding?)
14:43:21 <JeroenDL> Basics for an assignment
14:43:21 <simon> JeroenDL, if you want a recursive function in lambda calculus, you need something like a Y-combinator.
14:43:32 <Cale> Or just calling itself forever with new parameters?
14:43:34 <Goosey_> I'm not sure how to create map without doing (x:xs)
14:43:36 <tensorpudding> in the untyped lambda calculus you can do recursion using one of the functions that does it
14:43:36 <mux> alistra: I don't think there is such a thing as a "pure lambda calculus", but in untyped lambda calculus, you have general recursion via the Y combinator
14:43:42 <mux> you lose it in simply typed calculus
14:43:44 <tensorpudding> Y is the standard one
14:43:59 <Cale> Goosey_: You didn't see my definition of it?
14:43:59 <simon> Cale, oh, yeah
14:44:00 <Axman6> Goosey_: foldr takes case of doing all the (x:xs) stuff for you
14:44:10 <Axman6> you just give it a list, and tell it how to process it
14:44:11 <Goosey_> Cale: I tried to ignore it so that I could figure it out on my own
14:44:18 <tensorpudding> so called fixed point combinators
14:44:23 <Cale> Goosey_: ah, fair enough :)
14:44:29 <Goosey_> @src foldr
14:44:29 <lambdabot> foldr f z []     = z
14:44:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:44:34 <Goosey_> Oh...
14:44:38 <Goosey_> foldr will do that on it's own
14:44:45 <tensorpudding> there's a fixed-point combinator of a kind in haskell but it's not the Y combinator
14:44:50 <JeroenDL> (the actual assignment is on turing machines btw)
14:45:00 <tensorpudding> @type fix
14:45:00 <lambdabot> forall a. (a -> a) -> a
14:45:18 <tensorpudding> well, not quite the same thing
14:45:33 <alistra> JeroenDL: why don't you do it on a turing machine then
14:45:37 <copumpkin> :t cont
14:45:38 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
14:45:40 <tensorpudding> > fix cos
14:45:41 <JeroenDL> Already did that :D
14:45:42 <copumpkin> :t cont fix
14:45:42 <lambdabot> forall a. Cont a a
14:45:44 <lambdabot>   mueval-core: Time limit exceeded
14:45:45 <copumpkin> yay
14:45:58 <hpc> > fix error -- if only it were that easy
14:45:59 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:45:59 <tensorpudding> well, it doesn't find the fixed point
14:46:04 <copumpkin> cont fix is the ultimate value
14:46:25 <Goosey_> map' f xs = foldr (\x xs -> f xs : y:[]) y xs
14:46:25 <alistra> JeroenDL: your task seems underdefined for lambda calculus :D
14:46:26 <Goosey_> I did that
14:46:33 <Goosey_> and now it says map' isn't in scope >_<
14:46:58 <Goosey_> oh god
14:47:00 <alistra> let before the definition
14:47:00 <Goosey_> hold on
14:47:12 <Goosey_> I HAVE A PLAN
14:48:10 <Axman6> alistra: http://dl.dropbox.com/u/43370/Photo%2020-12-11%2010%2013%2037%20AM.jpg
14:48:24 <JeroenDL> alistra: I have a solution that I can use that just chains a bunch of constants. I can argue that its an encoding for a natural number, so thats good enough
14:48:42 <alistra> it's like italics comic sans
14:49:06 <Axman6> damn you Columbia River Knife and Tool!
14:49:17 <alistra> Axman6: such a tool
14:50:39 <simon> JeroenDL, if you define a successor function, and you define a recursive function that applies the successor on its input and applies itself to that, then you have a function that counts upwards.
14:50:46 <alistra> you can have a picture of my keyring (or whatever that part is called in english, i don't know since my program with google translate api went off) http://alistra.ath.cx/stuff/brelok.jpg
14:52:14 <JeroenDL> simon: you're right. Haskell/lambda calculus is just so far away in the back of my head that I'm finding even the basics hard. But I got what I need now :)
14:53:21 <Axman6> alistra: can you make the picture a little bigger? my 10Gbit connection is downloading it too fast
14:54:09 <alistra> well i can upload it on imgur :D my upload speed is hshity
14:54:35 <ksf> wait, let me help downloading it
14:54:47 <dolio> @type let reset m = runCont m id ; ultimate = cont fix in reset ultimate
14:54:48 <lambdabot> forall a. a
14:54:50 <Axman6> well, it'll still take the same amount of time if i'm downloading it from the same host...
14:55:29 <ksf> not really, no. you've got 70 to 90 kB/s less.
14:55:38 <ksf> gentoo \o/
14:55:43 <alistra> https://github.com/alistra/imgur-directory-listing-yesod https://github.com/alistra/Imgur-Directory-Listing that's why i've written those :P http://alistra.ath.cx:3001 if anybody wants a peek
14:55:49 <alistra> http://i.imgur.com/Ledqa.jpg this is the keyring
14:55:52 <Axman6> u suck
14:56:18 <mm_freak> Goosey_: that's the currying
14:56:22 <Axman6> alistra: resize and then relink me >_<
14:56:23 <ksf> alistra, don't feel bad, my upload isn't better either.
14:56:30 <mm_freak> again:  if 'f = g', then 'f x = g x'
14:56:33 <Axman6> because i'm pretty sure the download has stopped
14:56:37 <Axman6> oh, there it goes
14:56:40 * hackagebot show 0.4.1.2 - 'Show' instances for Lambdabot  http://hackage.haskell.org/package/show-0.4.1.2 (TwanVanLaarhoven)
14:56:46 <mm_freak> so whenever you write 'f x = g x' you could just as well write 'f = g'
14:56:49 <alistra> i'm not even offtopping, because one of the links was yesod :3
14:57:10 <alistra> Axman6: 604kb
14:57:10 <Peaker> mm_freak: The dreaded MR :-(
14:57:23 <alistra> doesnload the imgur link, it'll be faster
14:57:38 <ksf> 618233 bytes, to be precise.
14:57:47 <ksf> 2592px × 1944px
14:58:02 <mm_freak> Goosey_: remember that '=' in haskell really makes an equation and the correct equiation for 'map' in terms of 'foldr' will be of the form 'map f = foldr ff fz'
14:58:13 <mm_freak> or equivalently:  map f xs = foldr ff fz xs
14:58:32 <mm_freak> in other words, if you /need/ the additional argument, you are doing it wrong =)
14:58:47 <mm_freak> Peaker: miller-rabin?
14:58:54 <Peaker> mm_freak: Monomorphism restriction
14:59:02 <ksf> ...but we really need people with slow connections. ascii porn is a cultural good that's got to be kept alive.
14:59:02 <Peaker> mm_freak: makes f = g   different from f x = g x
14:59:19 <Peaker> mm_freak: if you don't have a type signature for f
14:59:20 <mm_freak> ok, sorry
14:59:37 <alistra> ksf: i have FLOPPY DISKS of those
14:59:41 <Peaker> funny that some people thought the MR would make things *less* confusing
14:59:47 <alistra> except i don't own a pc with a floppy drive
14:59:50 <mm_freak> Goosey_: given that 'f' is actually a function and you are writing a type signature for it, then 'f = g' is the same as 'f x = g x' =)
15:00:14 <monochrom> MR makes performance less confusing
15:00:35 <mm_freak> i think i've never encountered the MR
15:00:47 <monochrom> which is actually not a very noticeable effect in the grand scheme of things
15:01:07 <mm_freak> MoRe performance
15:01:41 <monochrom> conceivably, compiler optimizations already monomorphize for you where applicable
15:02:48 <monochrom> after all, it is not like your program can do: "please enter the name of a Num instance for the rest of my operations"
15:02:52 <Peaker> monochrom: it makes the notion of a definition more confusing
15:02:56 <Peaker> which is a horrible trade-off
15:02:56 <Goosey_> I want to do something like this map' f xs = foldr (\x xs -> f xs : y) y:[] xs
15:03:08 <monochrom> yes of course
15:03:27 <Goosey_> I just don't know where to store the data, because y is actually out of scope
15:03:44 <Axman6> Goosey_: you're prtetty close
15:03:57 <Axman6> but remember, that f has type a -> [b] -> [b]
15:04:03 <Axman6> and xs there has type [b]
15:04:17 <Axman6> also, that is that y and : doing in y:[]?
15:04:29 <Sgeo> Is safe-lazy-io decent?
15:04:38 <Axman6> uh, f doesn't have that type, the lambda you're making does
15:04:47 <roconnor> Sgeo: safe?
15:05:12 <roconnor> Sgeo: lazy io is all right for very trivial throw away code.
15:05:29 <Sgeo> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/safe-lazy-io
15:05:38 <monochrom> map' f xs = foldr (\x xs -> f x : xs) [] xs
15:05:45 <mm_freak> Goosey_: remember what Cale said:  foldr replaces every occurence of (:) by the first argument and the [] at the end by its second argument
15:05:46 <roconnor> O_o
15:05:52 <roconnor> what's unsafe about the existing lazy io?
15:05:57 <Axman6> mm_freak: you suck at helping learning :(
15:06:03 <Axman6> uh, monochrom, not mm_freak
15:06:15 <mm_freak> Axman6: i do anyway =P
15:06:17 <roconnor> Sgeo: okay I have no idea what that package is
15:06:27 <Goosey_> So, basically I need to make a map function that does [1+1,1+2..]
15:06:33 <monochrom> at some point you just have to see a correct solution for why wrong solutions are so wrong
15:06:35 <c_wraith> roconnor: "leaking" file descriptors.  accidentally closing files before finished reading from them. etc
15:06:41 * hackagebot vector-space-points 0.1.0.0 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.1.0.0 (BrentYorgey)
15:07:09 <mm_freak> Goosey_: for 'map f' you basically want to replace the list x : (y : (z : [])) by f x : (f y : (f z : []))
15:07:55 <mm_freak> Goosey_: your folding function is of the form (\y ys -> ...)
15:07:59 <Goosey_> wait
15:08:03 <Goosey_> I think I get it
15:08:07 <Goosey_> the anonymous function
15:08:10 <Axman6> gogogo!
15:08:12 <Goosey_> is named x
15:08:16 <Goosey_> and I can tag that onto the front of xs
15:08:22 <monochrom> also, hiding solutions is an antithesis to learning from concrete examples
15:08:23 <Goosey_> right?
15:08:28 <mm_freak> Goosey_: sort of a contradiction, no?  "the anonymous function named â€¦" ;)
15:08:29 <Axman6> well no, it if was names anything, it wouldn't be anonymous
15:08:33 <Goosey_> xD
15:08:37 <Goosey_> well...
15:08:40 <Goosey_> Erg >_<
15:08:45 <mm_freak> Goosey_: the 'xs' in the lambda is totally unrelated to your argument 'xs'
15:08:57 <Goosey_> what does the \x mean
15:09:00 <Axman6> Goosey_: the annonymous functions (\y ys -> ...) takes twp arguments, y and ys
15:09:02 <Goosey_> remind me again xD
15:09:03 <mm_freak> hence me naming it ys instead of xs =)
15:09:08 <Goosey_> OH
15:09:15 <Goosey_> \x is actually an argument...
15:09:20 <mm_freak> x is an argument
15:09:21 <Axman6> it's like saying let g y ys = ... in foldr g [] xs
15:09:22 <mm_freak> and so is xs
15:09:42 <Goosey_> and does x hold the anonymous function?
15:09:47 <Axman6> Goosey_: this is wehy it's an anonymous function, it has no names, but its arguments do
15:09:52 <Axman6> no
15:09:54 <mm_freak> no, it's an argument to the anonymous function
15:10:01 <Goosey_> hrm
15:10:05 <mm_freak> the whole thing in parentheses is an anonymous function
15:10:05 <Goosey_> Oh
15:10:06 <Goosey_> I see
15:10:10 <mm_freak> > (\x y -> x + y) 3 5
15:10:10 <lambdabot>   8
15:10:13 <Axman6> (\x y -> x+y) is a function that takes x and y, and adds them
15:10:16 <Goosey_> \x xs is created in the scope of it
15:10:52 <mm_freak> Goosey_: the \ introduces the lambda abstraction:  (\<arguments> -> <body>)
15:11:00 <Goosey_> I was confusing myself
15:11:22 <mm_freak> Goosey_: which other languages do you know?
15:11:31 <Goosey_> C and Prolog mainly
15:11:41 * hackagebot vector-space-points 0.1.1.0 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.1.1.0 (BrentYorgey)
15:11:41 <mm_freak> javascript perhaps?  or python?
15:11:45 <mm_freak> or even PHP or C#?
15:12:06 <Goosey_> I know some python
15:12:13 <Goosey_> Not much though
15:12:23 <mm_freak> ok, what you write as "lambda x y: ..." in python you write as "\x y -> ..." in haskell
15:12:26 <ksf> Goosey_, if you know C reading the STG paper will be enlightening.
15:12:34 <ksf> quite outdated by now, but still.
15:12:36 <Goosey_> STG paper?
15:12:43 <ksf> spineless, tagless g-machine
15:13:15 <Goosey_> when haskell has a list xs
15:13:25 <Goosey_> and you write (x:xs)
15:13:26 <ksf> http://research.microsoft.com/apps/pubs/default.aspx?id=67083
15:13:32 <ksf> one x, more xes.
15:13:35 <Goosey_> does it automatically break xs iup?
15:13:39 <Goosey_> up*
15:13:48 <monochrom> suggesting to learn the STG at this stage is a long shot
15:13:51 <Goosey_> into it's head and tail
15:13:51 <ksf> leet people write icksen.
15:13:57 <mm_freak> nope, x:xs is the list that is 'x' followed by the list 'xs'
15:13:59 <Axman6> > let f (x:xs) = (x,xs) in f "Hello"
15:14:00 <lambdabot>   ('H',"ello")
15:14:08 <ksf> : is the "cons" constructor.
15:14:13 <ksf> :t (:)
15:14:13 <lambdabot> forall a. a -> [a] -> [a]
15:14:23 <ksf> ...and you can pattern match on constructors.
15:14:28 <Goosey_> let f xs = (x:xs) in f "Hello"
15:14:33 <Goosey_> > let f xs = (x:xs) in f "Hello"
15:14:34 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:14:34 <lambdabot>         against inferred ...
15:14:38 <Goosey_> okay
15:14:50 <ksf> and : starts, as every construcor, with an uppercase letter. evidently, : is upper-case . ;)
15:15:35 <hoob> whats a monad
15:15:49 <Axman6> hoob: have you ever had a burrito?
15:15:55 <alistra> xD
15:16:06 <hoob> yes
15:16:08 <ksf> hoob, a lax functor from a terminal bicategory.
15:16:19 <monochrom> why do you ask what a monad is?
15:16:32 <alistra> what is monad
15:16:36 <alistra> baby don't hurt me
15:16:38 <hoob> how is monad formed
15:16:54 <Axman6> to form a monad, first you must create the universe
15:16:58 * Axman6 should stop
15:17:28 <hoob> is creating the universe an io monad
15:17:41 <ksf> no, but running probably is.
15:17:55 <Axman6> there's is only one IO monad, so saying an IO monad doesn't make much sense really
15:17:56 <ksf> I don't give metaphysical advice at 00:50.
15:18:07 <ksf> *running it
15:18:08 <Axman6> actually, that's probably not true, but anyway
15:18:54 <Goosey_> how can I trace the GHC's entire interpretation of my map' function
15:19:02 <hoob> use a monad
15:19:07 <hoob> im not sure
15:19:10 <monochrom> can't. actually probably can, but pretty hard
15:19:23 <monochrom> and I haven't done it, so I can't tell you how
15:19:26 <Goosey_> Ugh >_<
15:19:28 <Peaker> Goosey_: what do you mean? What kind of output would you want?
15:19:28 <ksf> in reality, your computer is stringing the universe through itself to make side-effects happen. every time it runs some IO funciton, it copies you and the rest of the universe, having mutated it a bit.
15:19:35 <Goosey_> I just want to see the steps it takes to solve it
15:19:38 <bwright> The superiority complex in #haskell is almost as high as in ##c++
15:19:39 <Peaker> Goosey_: tracing of the compilation of that function, or the execution of it?
15:19:40 <Axman6> Goosey_: just test it. first start with map' f [] and make sure you get get []
15:19:45 <Goosey_> Like in prolog, the trace shows you the steps of unification
15:19:48 <Peaker> Goosey_: you can use Debug.Trace
15:19:49 <Axman6> where f = (+1) i guess
15:19:50 <hoob> my monads hurt
15:19:54 <hoob> i have to go
15:20:01 <Peaker> Goosey_: for execution/values' trace. For the type unification, you can't
15:20:03 <monochrom> oh, I forgot Debug.Trace. yes that works, and pretty easy
15:20:24 <ksf> hoob, the principal question is: do you want to do some IO, or do you want to learn about monads? both are, strange as it may seem, completely distinct, when it comes to explaining stuff.
15:20:29 <monochrom> but you have to rewrite map' a bit for Debug.Trace to work
15:20:36 <ksf> as IO is a fuminantely bad example of a monad.
15:20:36 <Axman6> Goosey_: there's no 'solving' it like in prolog. you've given a set of rules for the computer to execute (note this is different from a set of instructions to execute, like in C)
15:20:55 <rwbarton> ksf, as he left, I guess the answer is "neither".
15:20:55 <monochrom> but how about I trace it out for you
15:21:27 <ksf> Goosey_, if you want you can do a bit of type level programming with fundeps. you'll feel right at home as a prolog guy.
15:22:01 <Goosey_> monochrom: map' f xs = foldr (\x xs -> f x : xs) [] xs  you added the x : I'm trying to figure out how it figures out x is the head of the list..
15:22:18 <ksf> there's no cuts, you enable turing completeness separately, but otherwise it's quite the same.
15:22:29 <Axman6> @src foldr -- Goosey_
15:22:29 <lambdabot> Source not found. I feel much better now.
15:22:33 <Axman6> @src foldr
15:22:33 <lambdabot> foldr f z []     = z
15:22:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:22:37 <Axman6> you suck lambdabot
15:23:33 <Goosey_> but doesn't x stay in foldr's scope?
15:23:41 <ksf> bwright, well, I guess he should learn how babbies are formed, first.
15:23:47 <mm_freak> ksf: not if you view IO as a simple EDSL
15:23:57 <ksf> heresy!
15:24:01 <mm_freak> then the actual running of your program is just outside the scope of haskell
15:24:19 <Axman6> Goosey_: so: foldr (\x ys -> f x : ys) [] xs meant that we now have: foldr f z (x:xs) = (\x ys -> f x : ys) x (foldr f [] xs)
15:24:25 <Axman6> hmm, that wasn't very helpful either
15:24:33 <ksf> mm_freak, if there was an outside, then why are you staring at the inside of your eyeballs?
15:24:58 <Axman6> Goosey_: istrongly suggest you start using more variable names. you're just going to cofuse yourself if you use x and xs everywhere
15:25:26 <Goosey_> Okay Axman6, Thanks.
15:25:27 <ksf> and for goodness sake, AXMAN, don't use \x ys
15:25:36 <Axman6> yeah...
15:25:49 <hpaste> monochrom pasted â€œa trace of foldrâ€ at http://hpaste.org/55472
15:25:58 <monochrom> Goosey_: http://hpaste.org/55472
15:26:39 <dgpratt> I have a need to convert a bunch of files to a different encoding and I thought it would be fun to try this in Haskell (I haven't done much IO so far)
15:26:52 <monochrom> with a typo about parenthesis but it doesn't matter since it is at the end of a line
15:27:23 <monochrom> anyway, good job boring the monad asker :)
15:27:33 <Axman6> dgpratt: look at the Text package. notsure if it will do that for you, but it's a good place to start
15:27:41 <Axman6> alsi, i'm sure there's iconv bindings
15:27:42 <dgpratt> one thing I think I need to figure out is how to read the file contents into a string strictly and then get the underlying file handle close (so I can write back out)
15:27:42 <Goosey_> Hm, thanks
15:27:44 <Axman6> also*
15:28:01 <ksf> dgpratt, why strictly?
15:28:06 <dgpratt> Axman6: looked at it briefly, but I'll take another look
15:28:08 <Axman6> dgpratt: String--, use Text or ByteStrings
15:28:12 <ksf> what if one of your files is a couple of gigabytes?
15:28:20 <rwbarton> he said why
15:28:36 <dgpratt> ksf: these are smallish text files
15:28:38 <Axman6> dgpratt: remember, that in String, each character has something like 5(!) words(!) of overhead
15:28:41 <Goosey_> monochrom: That was exactly what I was looking for
15:29:07 <ksf> dgpratt, you should still write to a different file. if you're finished, move them. but never, ever, leave files in limbo.
15:29:14 <dgpratt> Axman6: yeah, I know String has a lot of overhead; this is a one-off, so I wasn't *too* concerned
15:29:16 <Axman6> dgpratt: also, Chars also already have an encoding, they're not just single byte characters
15:29:22 <ksf> and the memory of a running process is, by definition, limbo.
15:29:32 <Goosey_> I'll be back later, thanks everyone.
15:29:36 <Axman6> basically, String is absolutely the wrong type to be using =)
15:30:00 <dgpratt> ksf: well, these are source-control backed files, so again, not *too* worried
15:30:11 <ksf> well, that's an argument.
15:30:51 <rwbarton> dgpratt: the quick hackish way to do it is something like    s <- readFile "foo.txt"; length s `seq` ...
15:31:04 <ksf> dgpratt, http://hackage.haskell.org/packages/archive/text/0.9.0.1/doc/html/Data-Text-Encoding.html
15:31:14 <ksf> if that's not enough, there's text-icu
15:31:18 <dgpratt> rwbarton: ok, thanks
15:31:19 <rwbarton> there is also some package with a more civilised set of strict IO functions
15:31:44 <rwbarton> but at that point you might as well do it properly with Text/ByteString
15:31:48 <dgpratt> although I suppose half the point of this exercise is to learn the *right* way to do it
15:32:19 <ksf> lazily, with data.text (which has fusion), not erasing stuff as you go.
15:32:35 <Axman6> dgpratt: Text and ByteStrings really aren't that scary. just make sure you import them qualified (import qualified Data.Text as T) and almost all the functions you'd use on Strings will be available as T.foo
15:33:28 <ksf> ...if you want to use the opportunity to go deeper, you could code your own codec with iteratees.
15:34:04 <dgpratt> another thing that's nice about readFile is that it appears to guess the encoding; is there a way to do that with the Text/Bytestring based APIs?
15:34:09 <Sgeo> Where is the data in an IORef actually stored?
15:34:15 <Axman6> i'd start with Data.Text.Lazy. then possibly move to using iteratees... in  a few months :P
15:34:20 <ksf> they should do the same.
15:34:21 <rwbarton> ByteString will give you a ByteString, which by definition has no encoding
15:34:32 <Sgeo> Is it in the IORef itself, even though it should be immutable, or is it "outside", in the RealWorld, or something?
15:34:32 <rwbarton> it is a string of bytes
15:34:34 <Axman6> Sgeo: what do you mean?
15:34:58 <dgpratt> rwbarton: right, I was referring to the Data.Text.Encoding module
15:35:02 <ksf> Sgeo, in memory. somewhere.
15:35:07 <ksf> implementation detail.
15:35:09 <dgpratt> or something akin to that
15:35:22 <rwbarton> Sgeo: you can think of the IORef as a pointer to a mutable cell
15:35:30 <rwbarton> the pointer itself is not mutable
15:35:50 <rwbarton> you can compare two pointers for equality to test whether they are the same cell, etc.
15:36:01 <dgpratt> I wish for something (ByteString -> Text) that guesses the encoding
15:36:14 <ksf> dgpratt, icu.
15:36:23 <ksf> http://hackage.haskell.org/package/text-icu
15:36:29 <c_wraith> icu isn't perfect, but there's no such thing as a perfect solution.
15:36:33 <dgpratt> ksf: ok, thanks
15:36:43 <monochrom> "intensive care for unicode" :)
15:36:45 <c_wraith> icu is as good as you'll get without external information
15:36:48 <rwbarton> (btw, I don't think readFile "guesses" the encoding, at least not from the file. It just uses the locale specified in the environment.)
15:36:54 <ksf> you *really* don't want to guess yourself. noone does. that's why ibm sponsored a hundred-banana job for it.
15:37:19 <monochrom> GHC's System.IO doesn't guess the encoding from file contents. never.
15:37:31 <dgpratt> rwbarton: it seemed to work for two files with different encodings, so...
15:37:39 <monochrom> it does guess encoding from OS, env vars
15:37:40 <rwbarton> probably a coincidence
15:37:52 <dgpratt> ...I assumed it was guessing based on the BOM
15:38:07 <rwbarton> for example if you read in a file and then write it out again, that may work even if the String representation was the wrong one.
15:38:07 <monochrom> which is more like s/guess/assume/
15:38:16 <ksf> BOMs are an abomination.
15:38:51 <ksf> ...ask linus about it.
15:39:10 <ksf> unicode in the kernel? who are we? plan9?
15:43:38 <cobra-the-joker> Thanx every one for the help !
15:44:13 <pikhq> Here's the rule for handling text encoding: assume UTF-8.
15:44:25 <pikhq> Everything else is broken.
15:45:21 <ksf> utf-8 does an excellent job of distinguishing itself from other encodings
15:46:01 <dylukes> utf-8 is well done too.
15:46:24 <ksf> well, plan9
15:46:41 <ksf> I still wonder how they managed to design go, with that kind of track record.
15:46:59 <Axman6> gmm?
15:47:01 <Axman6> hmm*
15:49:14 <Axman6> ksf: care to elaborate?
15:50:40 <ksf> Axman6, it seems ill-designed.
15:50:50 <Axman6> in what ways?
15:50:53 <ksf> that is, there's a lot of power lacking.
15:51:17 <Axman6> a lot of the code i've seen, it looks like they wanted to take C, and make it even harder to read
15:51:43 * hackagebot hxournal 0.6.0.0 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.0.0 (IanWooKim)
15:51:47 <ksf> they chose to replace the usual imperative object model with typeclasses, that's fine, even good, but why did they have to castrate them?
15:52:23 <kumil> because otherwise they might try to sieze the throne for their children
15:54:32 <pikhq> ksf: It helps to remember that they think C was a genuinely good design.
15:54:41 <BMeph> pikhq: My cutesy summary is this: There are two encodings in use today, UTF-8, and WTF-8. ;)
15:54:46 <pikhq> BMeph: :)
15:56:11 <Axman6> wtf, i'm reading about some GPU computing tech that MAD seems to have... and the example code uses floats to index arrays... o.O
15:56:28 * BMeph thinks C was an outstandingly goof design...for the 60's. ;)
15:56:37 <kumil> goof?
15:56:43 <Axman6> d
15:56:49 <Axman6> i assume
15:56:55 <BMeph> Er, I meant a "good" design, but it works either way. ;)
15:56:56 <ddarius> And C was made in the 70s and Lisp was made in the 60s
15:57:08 <ddarius> Admittedly, early lisps were piles of crap.
15:57:36 <kumil> better than piles of depleted uranium
15:57:47 <kumil> unless you're into that kind of stuff
15:57:49 <ddarius> That was the 50s.
15:58:13 <BMeph> I like piles of depleted uranium! Better than weaponizing the stuff, that's dangerous! ;Ã¾
15:58:36 <ddarius> @google atomic pile
15:58:37 <lambdabot> http://www.fi.edu/learn/case-files/fermi/pile.html
15:58:38 <lambdabot> Title: Enrico Fermi: Atomic Pile
15:58:56 <kumil> http://www.theonion.com/articles/us-intelligence-confirms-the-hillbillies-have-the,1116/
15:59:13 <BMeph> Note to Fermi: Make sure it's depleted first, THEN keep it in a pile. ;)
16:00:23 <cmccann> weaponizing depleted uranium would be quite the trick.
16:02:26 <pikhq> cmccann: Quite trivial to do, really.
16:02:32 <pikhq> Simply give it sufficient momentum.
16:02:44 <BMeph> I think the "better" trick, is making bullets so heavy that the machine gun threatens to make the plane stall if they're fired for too long.
16:03:02 <cmccann> pikhq, okay, that's true :P
16:03:28 <pikhq> BMeph: Been done. There was a plane with a giant machine gun that actually counteracted the engine thrust.
16:03:34 <Axman6> uranium bullets seems like a bad idea to me...
16:03:59 <pikhq> Axman6: Depleted uranium is pretty common in armor-piercing rounds.
16:04:01 <Axman6> pikhq: the A1 warthog? (A1? hmm)_
16:04:06 <pikhq> Nice and dense.
16:04:13 <c_wraith> Axman6: wasn't that A10?
16:04:14 <Axman6> pikhq: yeah, i meant non-depleted
16:04:16 <BMeph> A10, actually. :)
16:04:19 <Axman6> A10 yes
16:04:41 * Axman6 is mixing up warplanes and super computers for some reason
16:04:43 <BMeph> A-10, if you're a pedant.
16:04:43 <pikhq> Non-depleted uranium rounds sounds like a terrible idea.
16:04:51 <cmccann> depleted uranium bullets are also good for contaminating the surrounding area with toxic heavy metals
16:05:24 * BMeph thinks non-depleted uranium rounds sounds like a weapon upgrade for Fallout IV
16:05:25 <pikhq> cmccann: Most munitions suffer from that, though. You think lead's better?
16:05:46 <Axman6> pikhq: i believe the early (maybe even later?) nuclear weapons worked by basically firing two radioactive bullets into each other
16:05:49 <pikhq> (not, mind you, that this means "we shouldn't care", just that DU's not unique in this.)
16:05:52 <kumil> pikhq: they shouldn't do any fighting then. fighting is bad
16:05:55 <cmccann> if memory serves me uranium actually is worse
16:06:24 <cmccann> but lead is a lot more common so it's not really a major concern relatively speaking
16:06:54 <Ke> you can use tungsten as well in sabot rounds, it's not strictly as good though
16:07:08 <ddarius> kumil: How 'bout we just go back to swords?
16:07:17 <ksf> tungsten carbide?
16:07:29 <Axman6> ddarius: THOSE WERE PRETTY HEAVEY, AND METAL TOO
16:07:34 <cmccann> ddarius, what's this newfangled technology swords nonsense about
16:07:40 <ksf> it's not like the americans would actually *need* the firepower of uranium.
16:07:40 <Axman6> that wasn't meant to be in caps, but i think it turned out better that way
16:07:46 <cmccann> let's stick with tradition and club each other with large sticks
16:07:54 <kumil> no, fighting is bad
16:07:55 <ksf> the people they're up against have paper sheets as armor.
16:08:29 <hpc> paper armor can be pretty effective
16:08:41 <Axman6> fricken terrists, need more K-mart!
16:09:02 <BMeph> Fighting is hard, let's go clubbing! ;Ã¾
16:09:06 * acowley uses two sticks to make a lambda
16:10:16 <ksf> if I was american, I'd rather worry that the US can't build abrahms, any more. they're just recycling the stuff, hoping to have enough spare engine parts, and they never produced the cannons themselves, anyway.
16:10:22 <acowley> To quote RHCP: Lambda, the great name binder, use two sticks to make it in the nature.
16:10:23 * cmccann invents armor-piercing rounds made from weaponized monad tutorials
16:11:12 <Axman6> dropped from the sky from the monad-transformer superfortress
16:11:33 <ksf> (and you're lucky if you get 40-60 shots out of those cannons, btw. not because they're bad, but because they're doomsday)
16:11:38 <acowley> Monad tutorials already are weapons to #haskellers. Think of the wailing and lamentations whenever somebody writing one pops in here.
16:12:51 <ksf> I reckon categorical descriptions of monads are weapons of mass destruction, then?
16:12:58 <ksf> how come we only have two of them, then?
16:12:58 <ddarius> acowley: You forgot to mention the gnashing of teeth.
16:13:57 <ksf> I *bet* monads can be described in terms of zygohistomorphic prepromorphisms.
16:14:05 <ddarius> They can't.
16:14:14 <acowley> hahaha
16:14:28 <acowley> joke derailed by math
16:14:34 <acowley> a holiday tradition
16:14:56 <ksf> ddarius, just make it "monads are isomorphic to..." and chose your domain and codomain carefully.
16:14:59 <cmccann> if I've learned anything from monad tutorials, it's that they can be described in terms of anything
16:15:18 <mike-burns> Monads are like typeclasses.
16:15:23 <cmccann> whether the description makes sense is another matter
16:15:36 <hpc> recursion is like recursion
16:24:29 <bwright> If I have some format that specifies a bunch of types and I want to match them and then have haskell interp. them as their corresponding types in haskell.
16:24:36 <bwright> What would be the best way to approach that?
16:25:08 <alistra> write a parser? bwright
16:25:41 <alistra> using alex+happy/parsec/whatever
16:25:50 <alistra> @hackage whatever
16:25:50 <lambdabot> http://hackage.haskell.org/package/whatever
16:27:24 <elliottt> has anyone tried out shake?
16:28:26 <copumpkin> there are at least three public ones now
16:28:31 <copumpkin> and one private one
16:28:49 <Axman6> public whats?
16:29:20 <kfish> shakes
16:29:26 <alistra> i tried a vanilla shake once
16:29:30 <salisbury> can one use the underscore char in function clause pattern matching?
16:29:31 <kfish> everybody's shaking in public
16:29:54 <alistra> what's a shake in this context
16:30:00 <alistra> not kfish's context
16:30:03 <parcs`> @hackage shake
16:30:03 <lambdabot> http://hackage.haskell.org/package/shake
16:30:03 <alistra> i know what he meant
16:30:31 <mike-burns> salisbury: I assume you've tried it by now, and yes.
16:30:56 <ddarius> mike-burns: You can't trust compilers, but you can trust the internet.
16:31:36 <salisbury> mike-burns I've got it in there, but its nestled down in some incomplete code, so the compiler is going on about indentation, rather than telling be whether it works
16:31:42 <salisbury> me*
16:31:56 <mike-burns> I can't wait until ghc just hpastes code into here, then after three people give it approval it declares it typesafe and spits out the binary.
16:32:15 <mike-burns> salisbury: Well you could write a small function and try it in ghci.
16:32:29 <salisbury> oh yeah, I always forget about ghci..
16:32:59 <mike-burns> > case True of _ -> "hello"
16:33:00 <lambdabot>   "hello"
16:33:04 <mike-burns> Do you mean an underscore like that?
16:33:12 <salisbury> yeah
16:33:20 <mike-burns> Yeah, it's fair game.
16:33:51 <alistra> why do people always write make replacements
16:33:57 <alistra> like rake
16:34:06 <mike-burns> Because they don't understand that it's a complicated problem.
16:34:07 <elliottt> it's pretty fun
16:34:15 <mike-burns> Heh, OK that's a good reason.
16:34:27 <alistra> write and publish*
16:34:31 <mike-burns> Oh.
16:34:38 <Pseudonym> Everyone knows that make is inadequate, though.
16:34:49 <Pseudonym> The problem is that there isn't a critical mass for a make replacement.
16:34:49 <mike-burns> Sure, but so is everything else, for different reasons.
16:35:10 <alistra> bsd has its own make
16:35:13 <alistra> there's cmake
16:35:19 <mike-burns> GNU has their own make.
16:35:37 <Pseudonym> What's happened is that different languages have converged on different tools.
16:35:49 <Pseudonym> Java usually uses ant, modern C++ often uses bjam.
16:35:52 <alistra> dmake, omake, tmake
16:35:58 <pikhq> "Inadequate" doesn't even begin to describe make.
16:35:58 <mike-burns> sbt in Scala.
16:35:58 <alistra> lol
16:36:12 <Pseudonym> pikhq: I'm going to disagree with you there.
16:36:32 <Pseudonym> There are some semantic warts, but there's really only two main features that make is missing.
16:36:36 <Pseudonym> One of them is very big.
16:36:44 <pikhq> Pseudonym: It literally doesn't even handle C dependencies without a lot of hacks.
16:36:47 <mike-burns> A typechecked DSL?
16:36:54 <Pseudonym> That's support for multiple directories/packages/subsystems.
16:37:03 <Pseudonym> The other is language integration.
16:37:07 <pikhq> And C is the language it's *principly intended* for.
16:37:16 <alistra> generate all the .o files from all the .c files in one keyword?
16:37:27 <pikhq> alistra: .h files.
16:37:56 <alistra> aren't like
16:37:59 <alistra> automakes
16:38:02 <alistra> for this
16:38:09 <pikhq> Unless you're using one of the more sophisticated Makefile generators, you're basically using make as a buggy shell script.
16:38:12 <alistra> i don't know, i always was afraid to try
16:38:20 <pikhq> (yes, automake handles it)
16:38:32 <alistra> unix philosophy
16:38:37 <alistra> tool partitioning
16:38:41 <alistra> you know the drill
16:39:10 <Pseudonym> Besides, any make invented today would have to handle clusters, too.
16:39:25 <alistra> clusters what
16:39:31 <Pseudonym> The problem is only getting bigger.
16:39:38 <Pseudonym> alistra: Compile farms.
16:40:07 <alistra> but like one project on few servers or few projects on few servers at once?
16:40:13 <alistra> a few*
16:40:19 <Pseudonym> Building one project on multiple machines.
16:40:32 <ddarius> Make your next compiler have replication and sharding so that it is web scale.
16:40:33 <Pseudonym> There are enough codebases which have multi-hour compile times on a single machine.
16:40:37 <mike-burns> With all the talk about Haskell and DSLs I'm slightly disappointed in shake's syntax.
16:40:57 <ddarius> mike-burns: Maybe you shouldn't listen to the talk about Haskell and DSLs.
16:41:02 <alistra> well make has -j
16:41:08 <mike-burns> ddarius: Good advice!
16:41:26 <pikhq> alistra: And you need to be careful to not break with that. :)
16:41:29 <Pseudonym> alistra: Which a) only works on one box, and b) doesn't load balance across subprojects.
16:41:49 <alistra> yeah, most projects crash
16:41:52 <pikhq> (you basically make it easier to hit undefined behavior in make doing that)
16:41:57 <alistra> if you give -j1>
16:42:00 <mike-burns> All of these make replacements compete against sbt in my mind.
16:42:00 <Pseudonym> Since make's answer to multiple subprojects is "recursively call make".
16:42:07 <alistra> because they don't have up-to-date deps
16:42:22 <pikhq> Actually, most projects anymore don't break with -j anymore, because it's so incredibly common.
16:42:38 <pikhq> Your typical distro compiles nearly everything with -j.
16:42:39 * alistra is a gentoo user and he knows
16:42:56 <ddarius> mike-burns: Your head must be a busy place.
16:43:04 <Draconx> many build systems don't achieve as much concurrency as they should be able to, though.
16:43:05 <Axman6> urgh, how do i find a string in all Makefiles recursively using something like `find`?
16:43:10 <mike-burns> ddarius: It is. Lots of voices, shouting.
16:43:26 <pikhq> Axman6: grep -r
16:43:28 <mike-burns> Axman6: grep the-string **/Makefile  ?
16:43:32 <alistra> i once used make to throttle downloading of like 10k images (using -j10 as only 10 connections were accepted at once from the server)
16:43:34 <Pseudonym> It's like a brain version of core wars.
16:43:36 <pikhq> Oh, wait, just Makefiles.
16:43:42 <pikhq> Yeah, grep foo **/Makefile
16:44:08 <alistra> Axman6: find . -iname makefile |xargs grep string
16:44:09 <pikhq> Or if you insist, find . -name Makefile -print0 | xargs -0 grep foo
16:44:10 <hiptobecubic> i compile with -j by default, only thing that still can't handle it is QT, that i've run into
16:44:43 <alistra> makefiles don't have spaces pikhq
16:44:59 <alistra> in names that is
16:45:17 <Axman6> FFFFUUUUU, why is LAMMPS so difficult to compile >_<
16:45:29 <hiptobecubic> find . -iname makefile -exec grep string {} +   :)
16:45:34 <Pseudonym> Personally, bjam is the most elegant build system I've seen, but it's very hard to customise for a new language.
16:45:42 <pikhq> alistra: Paths can.
16:45:54 <alistra> find . -iname makefile -exec rm -rf {} +
16:45:57 <mm_freak> GHC 7.4 is great, but for now i'm going back to 7.0.3
16:46:02 <Pseudonym> It's not necessarily the best, but it's elegant.
16:46:08 <exFalso> good evening!
16:46:08 <exFalso> if i have a pure monad computation (someComputation :: m a) can i be sure that ghc will treat it as transparent and only evaluate it once?
16:46:12 <hiptobecubic> Pseudonym, you still haven't said what's wrong with make other than you don't like "recursively call make" as a strategy
16:46:15 <pikhq> alistra: Remember, file and directory names can have anything but / and \0.
16:46:16 <mike-burns> I'll take the best over the most elegant.
16:46:30 <hpc> isn't make recursive by design anyway?
16:46:32 <alistra> pikhq: yeah and nobody sane uses that
16:46:33 <Pseudonym> hiptobecubic: I nominated two things. 1) No support for subprojects, and 2) no language integration.
16:46:41 <pikhq> hpc: No, recursive Make is Broken.
16:46:50 <mike-burns> http://miller.emu.id.au/pmiller/books/rmch/ - Recursive Make Considered Harmful.
16:46:52 <Axman6> exFalso: no, GHC is free to execute any pure computation as many times as it wants
16:46:55 <pikhq> alistra: I use spaces in names all the freaking time.
16:47:01 <pikhq> Unfortunately, it breaks make.
16:47:07 <pikhq> Because make is stupid.
16:47:11 <hiptobecubic> ah yes, there is that problem.
16:47:28 <exFalso> Axman6: can i somehow signal ghc that it is a costly computation?:) should i put the return value in a reader?
16:47:31 <alistra> pikhq: why do you use spaces lol
16:47:48 <Pseudonym> The syntax of make is more than a little inelegant, but that's not a deal breaker.
16:47:50 <mike-burns> Space is easier to hit than any other key on the keyboard. It makes sense.
16:47:56 <pikhq> alistra: Because I like my names to be meaningful. Sometimes more than one word is desirable.
16:47:57 <alistra> my\ favorite\ picture.jpg
16:48:07 <pikhq> Especially for media.
16:48:13 <alistra> use _ or camelcase like normal people
16:48:13 <Axman6> exFalso: you can give its result a name it will only be executed once: let foo = funBar m x in ...foo...
16:48:15 <alistra> or dots
16:48:24 <alistra> The.Simpsons.S23E09.720p.HDTV.X264-DIMENSION.mkv
16:48:31 * jessopher isnt sure thats the norm for 'normal people'
16:48:36 <hiptobecubic> dots break other things, like latex
16:48:38 <mike-burns> "like normal people". That was amazing.
16:48:43 <Pseudonym> Space is easy to hit, but backslash isn't.
16:48:44 <Axman6> alistra: fuck that
16:48:56 <hiptobecubic> -1 for "camelcase"
16:48:58 <Axman6> Pseudonym: tab is pretty easu to hit...
16:48:59 <pikhq> "~/video/Star Trek TNG/Season 3/26 - The Best of Both Worlds: Part I.mkv" seems quite reasonable to me.
16:49:11 * jessopher nods
16:49:11 <Pseudonym> Axman6: Tell that to xargs.
16:49:12 <Axman6> Pseudonym: agreed
16:49:34 <Pseudonym> I probably use xargs more than most, though.
16:49:41 <mike-burns> I never use xargs.
16:49:46 <mike-burns> We must fight.
16:49:50 <pikhq> Pseudonym: Meh, -print0|xargs -0 isn't hard.
16:49:52 <alistra> well it has cancer when you type it into mplayer
16:50:00 <alistra> all those "\ "
16:50:27 <Axman6> alistra: use a decent OS then
16:50:27 <Axman6> >_>
16:50:37 <pikhq> alistra: Ain't my fault if programs can't handle reasonable use of printable characters.
16:51:05 <alistra> pikhq: how often do you use a terminal?
16:51:06 <ddarius> pikhq: Why limit yourself to printable characters?
16:51:12 <dgpratt> did my last message (~30 seconds ago) make it in? I just got disconnected
16:51:12 <exFalso> Axman6: but don't i give a name to it when i do someComputation :: m a? i mean ghc should only reduce it once as the pureness guarantees it's transparent...
16:51:22 <mike-burns> dgpratt: No.
16:51:26 <alistra> dgpratt: no
16:51:31 <pikhq> I no more care about that than programs objecting to "~/video/ã‚«ã‚¦ãƒœãƒ¼ã‚¤ãƒ“ãƒœãƒƒãƒ—/01 - ã‚¢ã‚¹ãƒ†ãƒ­ã‚¤ãƒ‰ãƒ»ãƒ–ãƒ«ãƒ¼ã‚¹.mkv".
16:51:39 <pikhq> alistra: Essentially always.
16:51:40 <Axman6> exFalso: to give you meaningful answers, i'd need to know more about what you;re doing
16:51:42 <hiptobecubic> alistra, mplayer "Other<tab>   ->  mplayer "Other Words Were Autocompleted"
16:52:26 <jessopher> depending on your shell of course
16:52:36 <alistra> yeah i know what tab does
16:52:46 <mike-burns> I'm a terminal junkie. I refuse to change phones because any lesser keyboard would hinder my terminal use. Nearly every program I use is a command-line program. I know how to, and often do, use ed. And I also put spaces in file names.
16:52:59 <mike-burns> But I use totem to watch movies.
16:53:05 <alistra> but still imo it's more convinent not to use spaces in names
16:53:06 <hiptobecubic> jessopher, if you are using a shell without autocomplete, i can only imagine the patience you must have.
16:53:13 <jessopher> :P
16:53:22 <mike-burns> Or ignorance!
16:53:24 <alistra> mike-burns: so gay lol
16:53:26 <jessopher> or both
16:53:27 <alistra> @ totem
16:53:29 <dgpratt> major connection flakiness tonight for some reason :(
16:53:30 * mike-burns pauses
16:54:08 <alistra> mike-burns: paused by clicking "|>" shaped button in your gui?
16:54:50 <pikhq> alistra: It's also more convenient to just abandon computers altogether. But convenience is just one consideration for me. :P
16:54:51 <hiptobecubic> totem is pretty low on the list of media players i can stand.  right above RealONE player and WinAMP > 3
16:55:19 <alistra> pikhq: no, it's not convinient to abandon computers
16:55:37 <alistra> but you always have to quote shit, when you use names with spaces
16:55:50 <alistra> this means reaching all the way to Shift
16:56:00 * ddarius references tab again.
16:56:14 <pikhq> Ah, I can see that this "shift" key usage is quite difficult for you.
16:56:17 <pikhq> As is "period".
16:56:18 <Draconx> alistra, you may have to do more than just quoting.
16:56:18 <hiptobecubic> you have to use shift for _ as well.
16:56:40 <_Mikey> :o
16:56:43 * BMeph hates all Real Networks products with a pure and burning passion!
16:56:58 <ddarius> BMeph: So does everyone else.
16:57:04 <alistra> hiptobecubic: shift two times for " begining and ending qiote
16:57:07 <alistra> quote*
16:57:08 <hiptobecubic> I don't understand why they are still out in the wild.
16:57:09 * hpc uses vlc and foobar
16:57:14 <hiptobecubic> alistra, tab. tab tab tab.
16:57:33 <alistra> hiptobecubic: i know lol
16:57:35 <Draconx> exercise: write a bourne shell program which reads a filename from standard input, possibly containing spaces, and prints it out twice.
16:57:41 <parcs`> mike-burns: real terminal junkies uses mplayer, rendering with libcaca to their terminal
16:57:42 <alistra> i don't rename those files when i get them
16:57:48 <alistra> but i don't create ones with spaces
16:58:00 <BMeph> ddarius: That explains their Marketing department... ;)
16:58:45 <exFalso> Axman6: http://pastebin.com/dEPzz454
16:58:47 <mauke> The paste dEPzz454 has been copied to http://hpaste.org/55475
16:58:51 <alistra> IFS="$(printf '\n\t')"
16:58:51 <alistra> for file in /var/transmission/config/torrents/*
16:58:51 <alistra> do
16:59:02 <pikhq> I'm surprised he didn't even comment on my using UTF-8 filenames as well.
16:59:03 <alistra> real fun to write such bash scripts to handle all filenames
16:59:19 <alistra> each time when i write a shell script i want to kill somebody
16:59:48 <ddarius> Don't write shell scripts.  Alternatively, kill more people.
16:59:53 <alistra> pikhq: utf characters arent the usual delimiters in the shell
17:00:00 <cmccann> ddarius, can't I do both?
17:00:17 <alistra> pikhq: as opposed to spaces
17:00:19 <Axman6> exFalso: what's the problem?
17:00:23 <BMeph> cmccann: Only if you use emacs. :D
17:00:30 <JoeyA> @remember ddarius
17:00:30 <lambdabot> Incorrect arguments to quote
17:00:52 <Axman6> exFalso: you've bound myMap to a name, which means it will only be executed once, for each time toy run function
17:01:06 <hiptobecubic> you just have to quote your variables in your shell scripts, which is good practice anyway
17:01:13 <The_Journey> hi, why can't I convert argument like this: main = do args <- getArgs x <- read (args !! 0)?
17:01:19 <Axman6> exFalso: oh, wait, i see
17:01:34 <dmwit> The_Journey: Because "read" doesn't do IO.
17:01:35 <alistra> hiptobecubic: not really if you want to use for loops
17:01:40 <Axman6> :t read
17:01:41 <lambdabot> forall a. (Read a) => String -> a
17:01:42 <dmwit> The_Journey: Instead, try "let x = read (args !! 0)".
17:01:44 <alistra> this is he recomended way
17:01:52 <dmwit> The_Journey: Also possible is to use readIO.
17:01:59 <dmwit> "x <- readIO (args !! 0)"
17:01:59 <JoeyA> @remember ddarius Don't write shell scripts.  Alternatively, kill more people.
17:01:59 <lambdabot> I will remember.
17:02:00 <dmwit> :t readIO
17:02:00 <lambdabot> forall a. (Read a) => String -> IO a
17:02:03 <The_Journey> dmwit: so why does that work instead?
17:02:05 <pikhq> alistra: Meh, just use better languages.
17:02:09 <pikhq> Like, anything.
17:02:15 <Axman6> exFalso: if computing the result is expensive, compute it once, and pass the result to whereever it's needed
17:02:23 <dmwit> The_Journey: For now, if you want a rule of thumb, "<-" is for binding to IO, and "let" is for doing pure computations.
17:02:25 <The_Journey> so if I'm using IO(), the expression has to be of type IO?
17:02:28 <pikhq> If it's longer than 5 lines, don't use shell.
17:02:34 <dmwit> The_Journey: When you want to know more, there are dozens of good tutorials available.
17:02:49 * Axman6 -> lunch
17:02:49 <dmwit> The_Journey: Well, IO is not a type -- it's a type constructor.
17:02:59 <exFalso> Axman6: ok thanks
17:02:59 <alistra> pikhq: yeah i will execute an interpreter to do a onelines
17:03:03 <alistra> so it makes it a 2 liner
17:03:05 <JoeyA> let xs be a list of ascending numbers... but what if x doesn't want to be that?
17:03:11 <dmwit> The_Journey: A type of the form "IO a" is a computation that does some IO to figure out an "a" value.
17:03:31 <Axman6> exFalso: your question seems to be whether GHC will do common subexpression elimination, and the answer is no
17:03:36 <dmwit> The_Journey: e.g. "IO ()" means "do some input/output, then return a useless () value".
17:03:40 <alistra> http://www.cyberciti.biz/tips/handling-filenames-with-spaces-in-bash.html
17:03:50 <Axman6> JoeyA: it's only being allowed to, not forced
17:03:50 <dmwit> The_Journey: Or "IO String" means "do some input/output, then return a String".
17:03:50 <The_Journey> dmwit: so why does let x = read ( args !! 0) work?
17:04:14 <Axman6> > let x = read "1" in x :: Int
17:04:15 <lambdabot>   1
17:04:17 <dmwit> The_Journey: I'm not sure how to answer that question, actually. There's just a bit of syntax in do-blocks named "let".
17:04:38 <dmwit> Why does "for(i = 0; i < 10; i++) sleep(1);" work?
17:04:39 <jessopher> its an illusion, you arent really using a let expression
17:04:53 <pikhq> :t read
17:04:53 <lambdabot> forall a. (Read a) => String -> a
17:04:57 <pikhq> The_Journey: ^
17:04:58 <Pseudonym> That's not entirely true. It's compiled to a let expression.
17:05:14 <Pseudonym> > [ y | x <- [1..5], let { y = x+1 } ]
17:05:15 <lambdabot>   [2,3,4,5,6]
17:05:23 * pikhq sees nothing about read that implies IO
17:05:38 <Pseudonym> > concatMap (\x -> let y = x+1 in y) [1..5]
17:05:39 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
17:05:39 <lambdabot>    arising from a use...
17:05:42 <Pseudonym> Erm.
17:05:42 <dmwit> :t read :: Read (IO a) => String -> IO a
17:05:43 <lambdabot> forall a. (Read (IO a)) => String -> IO a
17:05:47 <dmwit> pikhq: *evil grin*
17:05:48 <ddarius> Pseudonym: @undo
17:05:49 <JoeyA> > let x = hello'' in x
17:05:51 <lambdabot>   "bite me"
17:05:54 <Pseudonym> > concatMap (\x -> let y = x+1 in [y]) [1..5]
17:05:54 <lambdabot>   [2,3,4,5,6]
17:05:57 <Pseudonym> Yeah.
17:06:15 <alistra> > let x = hello'' in x
17:06:16 <Pseudonym> Artificial example, but that's more or less what it compiles to./
17:06:16 <lambdabot>   "bite me"
17:06:18 <dmwit> The_Journey: To begin with, you might like
17:06:25 <dmwit> ?google the io monad for people who just don't care
17:06:26 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
17:06:27 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
17:06:39 <alistra> > let x = hello' in x
17:06:40 <lambdabot>   Not in scope: `hello''
17:06:42 <dmwit> The_Journey: If you do care, then you might like this one instead:
17:06:50 <dmwit> ?google you could have invented monads and maybe you already have
17:06:50 <Pseudonym> How can you understand the IO monad with your hands in the air?
17:06:51 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:06:51 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
17:06:52 <alistra> > hello''
17:06:54 <lambdabot>   "bite me"
17:07:22 <Pseudonym> Those who reinvent monads are doomed to understand them.
17:07:38 <jessopher> hah
17:07:43 <hpc> @remember Pseudonym Those who reinvent monads are doomed to understand them.
17:07:43 <lambdabot> It is stored.
17:07:52 <JoeyA> Those who don't know history are doomed to study it.
17:08:03 <alistra> @quote _pizza_
17:08:03 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
17:08:06 <exFalso> > let x = x in x
17:08:10 <lambdabot>   mueval-core: Time limit exceeded
17:08:16 <exFalso> ah niec
17:08:26 <JoeyA> > fix error
17:08:27 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:08:35 <hiptobecubic> how helpful
17:08:49 <alistra> fix undefined
17:08:53 <alistra> > fix undefined
17:08:54 <lambdabot>   *Exception: Prelude.undefined
17:08:58 <hpc> JoeyA: so glad i learned java so fast; would hate to repeat it
17:08:58 <alistra> meh
17:09:14 <JoeyA> > fix fix error
17:09:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:09:19 <JoeyA> > fix (fix error)
17:09:20 <lambdabot>   Couldn't match expected type `a -> a'
17:09:20 <lambdabot>         against inferred type `[GHC.T...
17:09:54 <hiptobecubic> > scratch my back
17:09:55 <lambdabot>   Not in scope: `scratch'Not in scope: `my'Not in scope: `back'
17:10:09 <alistra> s/ack/utt/
17:10:17 <hpc> > do not want
17:10:19 <lambdabot>   False
17:10:27 <hiptobecubic> > who was phone
17:10:28 <lambdabot>   Not in scope: `who'Not in scope: `was'Not in scope: `phone'
17:10:40 <hiptobecubic> Not so smart afterall....
17:10:42 <JoeyA> > Not_in_scope'Not_in_scope
17:10:42 <lambdabot>   Not in scope: data constructor `Not_in_scope'Not_in_scope'
17:10:49 <JoeyA> pfft
17:11:09 <JoeyA> > one `on` one
17:11:10 <lambdabot>   Not in scope: `one'Not in scope: `one'
17:11:12 <irene-knapp> hpc's is good haha
17:11:26 <alistra> > want
17:11:28 <lambdabot>   True
17:11:42 <jessopher> @src want
17:11:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:11:53 <hiptobecubic> > do my taxes
17:11:54 <lambdabot>   Not in scope: `my'Not in scope: `taxes'
17:11:59 <JoeyA> > launchMissiles
17:12:00 <lambdabot>   <IO ()>
17:12:04 <JoeyA> lol
17:12:06 <exFalso> haha
17:12:06 <irene-knapp> hah!  it knows that one
17:12:13 <hiptobecubic> lol
17:12:14 <JoeyA> > launchMissilesSTM
17:12:15 <lambdabot>   Not in scope: `launchMissilesSTM'
17:12:23 <JoeyA> @src launchMissiles
17:12:23 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:12:26 <jessopher> > hypothetically launchMissles
17:12:27 <lambdabot>   Not in scope: `hypothetically'Not in scope: `launchMissles'
17:12:29 <irene-knapp> > unsafeLaunchMissiles
17:12:30 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
17:12:30 <jessopher> baw
17:12:42 <hpc> now see, that's just bad design
17:12:51 <irene-knapp> see, my toy language, right
17:12:52 <hiptobecubic> safety first
17:12:52 <alistra> > launchMissiles :: Int
17:12:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:12:53 <lambdabot>         against inferred type ...
17:12:55 <hpc> a good programmer would make launchMissiles :: City -> IO ()
17:12:59 <irene-knapp> needs to have an implementation of Missile Command in it, right
17:13:02 <irene-knapp> hpc: hahaha!
17:13:23 <jessopher> these missles are not very modular
17:13:26 <alistra> :t launchMissiles
17:13:27 <lambdabot> IO ()
17:13:30 <JoeyA> launchMissilesAt
17:13:31 <alistra> :t launchMissilesCity
17:13:31 <lambdabot> Not in scope: `launchMissilesCity'
17:13:35 <JoeyA> That, or bump the major version
17:13:51 <rwbarton> :t launchMissilesWith
17:13:52 <lambdabot> Not in scope: `launchMissilesWith'
17:13:54 <JoeyA> launchMissilesAt :: Target t => t -> IO ()
17:14:17 <JoeyA> detonatePrematurely :: IO (Maybe a)
17:14:21 <alistra> JoeyA: more like Traversable ;o
17:14:33 <alistra> @hoogle missilies
17:14:33 <lambdabot> No results found
17:14:33 <hpc> launchMissilesAt :: Target t a => t -> IO a
17:14:36 <alistra> @hoogle missiies
17:14:37 <lambdabot> No results found
17:14:44 <alistra> @hoogle missiles
17:14:44 <lambdabot> package acme-missiles
17:14:44 <hpc> instance Target NewYork Wasteland
17:14:50 <hpc> instance Target Tokyo Godzilla
17:14:56 <jessopher> lol
17:15:01 <JoeyA> yay, hoogle knows about my acme module!
17:15:05 <JoeyA> @hoogle hypothetically
17:15:05 <lambdabot> No results found
17:15:14 <JoeyA> bah, I guess it gets updated once in a blue moon
17:15:24 <JoeyA> @hoogle launchMissilesSTM
17:15:24 <lambdabot> No results found
17:15:26 <alistra> what's a blue moon
17:15:32 <irene-knapp> @google blue moon
17:15:33 <lambdabot> http://www.bluemoonbrewingcompany.com/
17:15:36 <irene-knapp> no =p
17:15:42 <irene-knapp> @google blue moon -alcohol
17:15:43 <lambdabot> http://en.wikipedia.org/wiki/Blue_moon
17:15:43 <lambdabot> Title: Blue moon - Wikipedia, the free encyclopedia
17:16:31 <alistra> why hoogle index isn't updated daily
17:16:46 <JoeyA> I guess it only crawls Important modules.
17:16:47 <dgpratt> can it be coincidence that every time I send a message to this room, my internet connection drops off; either way, pretty exhasperating!
17:16:54 <JoeyA> It knows about the names of other modules.
17:17:00 <JoeyA> @hoogle realworld
17:17:00 <lambdabot> Control.Monad.ST data RealWorld :: *
17:17:00 <lambdabot> Control.Monad.ST.Lazy data RealWorld :: *
17:17:02 <alistra> how can you distinct an important module
17:17:07 <irene-knapp> certainly, it could be coincidence
17:17:07 <JoeyA> @hoogle acme
17:17:08 <lambdabot> package acme-colosson
17:17:08 <lambdabot> package acme-dont
17:17:08 <lambdabot> package acme-missiles
17:17:20 <irene-knapp> @hackage acme-dont
17:17:20 <lambdabot> http://hackage.haskell.org/package/acme-dont
17:17:31 <irene-knapp> hahaha
17:17:32 <irene-knapp> nice
17:17:35 <JoeyA> @hackage does-it-validate
17:17:36 <lambdabot> http://hackage.haskell.org/package/does-it-validate
17:17:36 <hpc> have you seen perl's acme-dont?
17:17:40 <irene-knapp> nope
17:17:55 <JoeyA> @hackage javascript:<script>alert 'XSS'</script>
17:17:55 <lambdabot> http://hackage.haskell.org/package/javascript:<script>alert 'XSS'</script>
17:17:55 <irene-knapp> I like the type signature of don't, haha
17:18:01 <irene-knapp> m a -> m ()
17:18:10 <JoeyA> bah
17:18:16 <hpc> perl's acme modules are even better than haskell's
17:18:25 <alistra>  @hackage test
17:19:11 <dgpratt> ok, so I'm trying to convert the encoding of a bunch of text files from UTF-16 to UTF-8
17:19:12 <irene-knapp> javascript:alert('XSS');
17:19:18 <irene-knapp> see I can do that without going through the bot =p
17:19:50 <dgpratt> I think it would be very easy, except that some files are likely to be UTF-8 already
17:19:57 <irene-knapp> (although it doesn't run, because my Mac has no protocol handler set for Javascript)
17:20:20 <irene-knapp> dgpratt: do you by chance know that the first few bytes of the files will be in the ASCII codepoint range?  because if so, you can detect their encodings by looking at the pattern of 0x00
17:20:53 <dgpratt> irene-knapp: they all have a BOM; I'm looking for an API that will deal with that automatically
17:20:55 <irene-knapp> for example, if the first few bytes are a schebang or an XML declaration, that would be sufficient
17:20:58 <irene-knapp> oh, a BOM, good
17:21:00 <hiptobecubic> "Note that the code in the don't block must be syntactically valid Perl. This is an important feature: you get the accelerated performance of not actually executing the code, without sacrificing the security of compile-time syntax checking."
17:21:09 <hiptobecubic> At least it's well done
17:21:10 <irene-knapp> hiptobecubic: hah! :D
17:21:48 <ksf> perl does *not* have http://hackage.haskell.org/packages/archive/acme-realworld/0.1.1/doc/html/Acme-RealWorld.html
17:22:34 <irene-knapp> "Program values are not affected by this operation, but the rest of the universe is."
17:23:00 <hpc> ksf: that is so delightfully dangerous
17:23:11 <irene-knapp> omg, the description of hypothetically!
17:23:14 <irene-knapp> the second paragraph!
17:24:13 <alistra> hypothetically rm -rf
17:24:39 <irene-knapp> alistra: hmm, that does seem like a problem, yes, in that the command can never actually complete (it will at some point delete essential files that it needs to restore the state of the universe)
17:25:19 <alistra> doesn't it have the process code
17:25:21 <alistra> in memory
17:25:21 <irene-knapp> therefore it will run until the universe ends, which seems undesirable
17:25:25 <irene-knapp> depends on the OS
17:25:36 <irene-knapp> the swapfile on Windows resides inside the filesystem, for example
17:25:50 <alistra> well windows isn't a real operating system
17:26:00 <irene-knapp> yes, yes, but we run on it anyway
17:26:14 <alistra> you can't delete a running binary there iirc
17:26:17 <alistra> that's weird
17:26:21 <irene-knapp> curious
17:26:31 <alistra> how are you supposed to update your mv
17:26:37 <irene-knapp> haha
17:26:48 <alistra> if you can't mv your mv to get the new mv
17:27:01 <hpc> alistra: copy it, then run the copy on the original
17:27:02 <alistra> oh, i know, with the new mv
17:27:08 <irene-knapp> well, anyway, so the point is, don't run hypothetically fix fix on Windows, unless you want to die of old age
17:27:12 <irene-knapp> > fix fix
17:27:13 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:27:15 <irene-knapp> aw
17:27:26 <hpc> irene-knapp: if it ain't an endomorphism, don't fix it
17:27:33 <alistra> > fix fix on
17:27:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:27:35 <irene-knapp> hpc: fair :)
17:27:57 <irene-knapp> so an endomorphism is what, a functor or something?  haha
17:28:05 <JoeyA> @remember hpc If it ain't an endomorphism, don't fix it
17:28:05 <lambdabot> It is stored.
17:28:05 <hpc> @hoogle Endo
17:28:06 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
17:28:06 <lambdabot> Data.Monoid newtype Endo a
17:28:06 <lambdabot> System.Posix.Terminal EndOfFile :: ControlCharacter
17:28:25 <alistra> inb4 in your endo joke
17:28:38 <JoeyA> An endomorphism in the Haskell category is a function of type a -> a.  (correct, right?)
17:28:41 <hpc> newtype Endo a = Endo {appEndo :: a -> a}
17:28:45 <hpc> JoeyA: yes
17:28:48 <irene-knapp> ah hm, okay
17:29:09 <wavewave> hehe.. my hxournal now has undo/redo functionality
17:29:14 <hpc> endomorphisms form a very convenient monoid too, incidentally
17:29:22 <irene-knapp> :t fix
17:29:23 <lambdabot> forall a. (a -> a) -> a
17:29:28 <hpc> which you can use to "reverse" applications of mappend to another monoid
17:29:42 <hpc> see: difference lists
17:29:46 <wavewave> very easy to make undo/redo in functional programming.
17:29:55 <irene-knapp> I wonder what it would mean to construct an infinite type, if the compiler could allow it
17:30:04 <ksf> endomorphines are anamorphisms in the category of mu-opioid-algebras
17:30:08 <hpc> irene-knapp: look for Mu
17:30:10 <hpc> @hoogle Mu
17:30:10 <lambdabot> Text.ParserCombinators.ReadP munch :: (Char -> Bool) -> ReadP String
17:30:10 <lambdabot> Text.ParserCombinators.ReadP munch1 :: (Char -> Bool) -> ReadP String
17:30:10 <lambdabot> package mucipher
17:30:13 <roconnor> IIRC foldl is simply a fold on an Endo
17:30:16 <irene-knapp> wavewave: oh, hxournal is yours?  nice.  (haven't tried it, but I've seen your posts about it)
17:30:19 <cmccann> irene-knapp, it'd be similar to constructing an infinite type, except a bit larger
17:30:20 <hpc> @src Mu
17:30:20 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:30:28 <irene-knapp> hm, cute
17:30:34 <mike-burns> I use acme-realworld for undo/redo.
17:30:38 <wavewave> irene-knapp : thanks!
17:30:40 <hpc> irene-knapp: Mu f represents the infinite type f (f (f ...
17:31:14 <irene-knapp> hmm
17:31:20 <irene-knapp> yes, okay
17:31:23 <wavewave> my design gets better and better. (in my thought :-P)
17:31:24 <mike-burns> Oh hah, I just jumped in without scrolling back, and sure enough you were talking about acme-realworld.
17:31:30 <JoeyA> mike-burns: That affects the rest of the universe, too (unless you use it just to grab the program state at some point earlier in the program)
17:31:47 <irene-knapp> you can't - it explicitly does not affect the program state
17:31:51 <irene-knapp> only things outside of it
17:32:04 <JoeyA> The benefit here is that the user will never even *know* they used undo; they'll just be astonished at how few mistakes they (appear to) make.
17:32:15 <irene-knapp> unless of course you encode the program state in the outside world and read it back, but that requires IO :D
17:32:16 <JoeyA> irene-knapp: Program *values*
17:32:24 <The_Journey> what does the "of" keyword do?
17:32:27 <JoeyA> I'm not sure about IORefs
17:32:33 <hpc> The_Journey: it's part of case syntax
17:32:35 <JoeyA> > case 5 of 5 -> 5
17:32:36 <lambdabot>   5
17:32:37 <irene-knapp> JoeyA: I actually saw both that device and a related one, in two separate books by James P. Hogan
17:32:50 <JoeyA> irene-knapp: Interesting
17:33:09 <cmccann> does acme-realworld provide a means to discard the outside world so that it can be garbage collected?
17:33:11 <alistra> let x = 5 of _ -> 5
17:33:17 <irene-knapp> JoeyA: the exact device was a message-through-time machine that cannot be used to send a message that would create an infinite loop, because the nature of the universe is such that you actually get an ALMOST infinite loop until time randomly mutates enough that you don't think to do it
17:33:19 <alistra> > let x = 5 of _ -> 5
17:33:20 <lambdabot>   <no location info>: parse error on input `of'
17:33:21 <The_Journey> hpc: wait so what does it do exactly?
17:33:33 <JoeyA> cmccann: putWorld $ unsafeCoerce () -- VERY unsafe
17:33:39 <irene-knapp> JoeyA: the other one was a computer that peeks at nearby universes and averages the input among all such universes - so that it lets you draw a perfect circle freehand, every time
17:33:44 <hpc> The_Journey: it performs pattern matches
17:34:02 <hpc> The_Journey: which is (in VERY basic terms) how all evaluation in haskell happens
17:34:05 <Axman6> case "Hello" of
17:34:07 <Axman6>     ('H':xs) -> True
17:34:08 <Axman6>     _ -> False
17:34:12 <ksf> btw, you might still be able to save the post from grayfaces: http://www.reddit.com/r/programming/comments/nj9kk/the_prime_reason_you_should_be_using_haskell/
17:34:39 <hpc> The_Journey: so say you had a number; you could match it on 1 and return "yay", 2 and return "blarg", or anything else and return "schnoz"
17:35:05 <hpc> > case 100 of 1 -> "yay"; 2 -> "blarg"; _ -> "schnoz"
17:35:05 <lambdabot>   "schnoz"
17:35:10 <hpc> > case 2 of 1 -> "yay"; 2 -> "blarg"; _ -> "schnoz"
17:35:11 <lambdabot>   "blarg"
17:35:14 <irene-knapp> oh, right, this was actually a puzzle in that very-meta ICFPC one year, wasn't it!
17:35:20 <irene-knapp> where the player character is a robot, right
17:35:33 <The_Journey> oh ok I see
17:35:38 <irene-knapp> and the robot has a security system outside its direct control that will censor its access to certain information, and to any information that depends on that information
17:35:54 <irene-knapp> but you can recover the one bit that you need by making it destroy a real-world object depending on the censored information
17:36:03 <irene-knapp> because the censorship system can't un-destroy it
17:36:04 * ksf tries to pronounce "schnoz" according to english spelling and it's even harder than scot (not to mention german)
17:36:26 <irene-knapp> it was very clever.  I wish I had gotten anywhere in the competition that year :)
17:36:42 <alistra> ksf: it seems like a word Pinky would say (from Pinky and the Brain)
17:37:03 <ksf> I think that word would be "shnord"
17:37:22 <alistra> zort
17:37:23 <ksf> but I can assure you that he says "narf" in german, too.
17:37:41 <jessopher> im pretty sure thats what he says in english too
17:38:24 <ksf> I'm pretty sure I saw all the episodes as a kid and then thrice again as an adult, in english...
17:38:44 <alistra> He speaks with an exaggerated cockney accent. He has several verbal tics, such as "narf", "zort", "poit", and "troz" (the last of which he started saying after noticing it was "zort in the mirror")
17:38:47 <kumil_> Having a nondeterministic turing machine is pretty much an instant victory condition
17:39:12 <alistra> i watched it recenyl
17:39:15 <alistra> all the episodes
17:39:34 <ksf> wait, no, that can't have been cockney. after all, I was capable of understanding him.
17:40:34 <ksf> I understand indian accents better than cockney, and scottish ones are a walk in the park, in comparison.
17:40:48 <ksf> (and my favourite happens to be icelandic)
17:40:58 <kumil_> not to mention the risk that you create an infinite loop of such complex redundancy that it's easier to randomly generated an actor to methodically destroy it than to destroy it directly. The more redundancy you add on top of that, the more powerful the actor
17:41:49 <kumil_> anyway, your use for sending messages back in time is pretty much the most boring thing you could ever do with it
17:41:58 <irene-knapp> which, mine?
17:42:00 <irene-knapp> oh, certainly
17:42:01 <kumil_> yes
17:42:10 <irene-knapp> but it was a very interesting thing in the book
17:42:23 <irene-knapp> because the book was about these scientists investigating the properties of the time-message-machine :)
17:42:24 <ksf> kumil_, no, it isn't.
17:42:32 <MiggyX> hi guys, I'm working on a simple little tool in Haskell but I think it needs to use state. After having my ass handed to me for making that assumption before, I thought I would ask about the problem itself :)  Basically I have to detect certain packets on the network and wait for the reply. Basically timing the request/response procedure. In the current code, I just record when I see a packet going out and watch for the next response coming back inâ€¦
17:42:33 <MiggyX> any ideas how I can do this without state?
17:42:37 <ksf> it's the way my turing machine outhalts all others.
17:43:21 <ksf> :t getCurrentTime
17:43:21 <lambdabot> Not in scope: `getCurrentTime'
17:43:26 <kumil_> Anyway, I wonder if you are really at risk of generating AIs or if there will always be lower complexity task-specific actors to break the loop
17:43:45 <ksf> @hoogle getCurrentTime
17:43:45 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
17:43:46 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
17:43:52 <kumil_> irene-knapp: what do you think?
17:44:10 <mike-burns> MiggyX: I don't understand really, but I think you've described a state machine?
17:44:17 * ksf knows such things. game programmer. we know how to calculate fps, because it's the most important display to have, even if it's the only thing that's getting displayed.
17:44:50 <ksf> MiggyX, long story short: you do it with state.
17:44:57 <irene-knapp> kumil_: that's an interesting thought!  I have no idea :)
17:45:00 <russellw> kumil_, it will always be more probable, by far, to have an existing actor break the loop than to generate a complex new actor from nothing
17:45:01 <JoeyA> You can implement a "state machine" by implementing a collection of functions and tail-calling.
17:45:06 <MiggyX> mike-burns:  basically I'm looking for a particular packet going out on the wire. When I see that packet, I wait to see when the next packet comes in reply - but there could be multiple packets at any given time etc...
17:45:21 <irene-knapp> kumil_: it seems likely that as long as you can ensure that the experiment was some human's idea in the first place,
17:45:37 <irene-knapp> kumil_: which is to say, as long as there are no existing AIs, since it isn't going to conduct itself by accident,
17:46:13 <irene-knapp> kumil_: that the easiest way to break it is always to have the human not think of or order the experiment.  that said, it might be easier to have a sufficiently creative human get hit by a bus, so manager-types are not in danger :)
17:46:14 <ddarius> ksf: If it's the only thing being displayed, it's hard pressed to be not the most important display.
17:46:25 <kumil_> russellw: well, you could always carry out the experiment in  a time loop outside the light-cone of any humans
17:46:50 <irene-knapp> well, but, right, it's outside the laws of relativity, surely
17:46:54 <irene-knapp> since time travel isn't possible in relativity :)
17:47:03 <ksf> ddarius, you don't understand. it's the eternal magic of fixM (update >>= draw)
17:47:05 <russellw> kumil_, only if you are an alien or have a faster than light spaceship, each of which has its own solution to that :)
17:47:09 <irene-knapp> anyway that would be an interesting experiment in its own right
17:47:20 <JoeyA> Would an Alternative instance of IO make sense?  (where (<|>) = onException)
17:47:52 <JoeyA> err
17:47:54 <ksf> ddarius, us game programmers don't care about your heathen RealWorld#. we create our own and pass it through our own monad.
17:48:00 <irene-knapp> but yeah - what russellw just said is actually related to what I said; the underlying principle is that experiments don't happen by chance, people have to think of them
17:48:07 <russellw> yes
17:48:10 <ddarius> JoeyA: How about (<|>) = mplus
17:48:25 <irene-knapp> at some point in the retrotemporal light-cone of the device, there must have been a human who had the idea, because otherwise the device could not have been set up
17:48:34 <JoeyA> ddarius: That's moving the problem to MonadPlus
17:48:44 <Axman6> :t onException
17:48:45 <lambdabot> Not in scope: `onException'
17:48:45 <ddarius> JoeyA: There is a MonadPlus instance for IO.
17:48:54 <JoeyA> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
17:49:08 <ksf> irene-knapp, who says there needs to be a reason for it to be set up? your mind is caught in pesky cause and effect.
17:49:12 <JoeyA> Not for me
17:49:23 <kumil_> russellw: no, you dump the experiment, set it to start up in a few years, move 5 light minutes away, and then in a few years it goes 4 minutes into the past
17:49:27 <MiggyX> JoeyA: I'm not sure how I'd even start that with functions. I have a function that returns a new packet each time it is "called" and there could be multiple "sent" packets before I see any reply i.e. I can't "block" waiting for a responseâ€¦ Can you give me any pointers for where to read up on this?
17:49:28 <ddarius> @instances MonadPlus
17:49:29 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:50:07 <ksf> irene-knapp, though I agree of course that there must have been a human to come up with the universe so all can witness it, that human being me :)
17:50:18 <irene-knapp> ksf: haha okay haha
17:50:21 <JoeyA> MiggyX: Do you consider foldl as using state?
17:50:27 <irene-knapp> also, it's not an experiment if it happens by accident :D
17:50:47 <kumil_> irene-knapp: oh! the temporal mutation effect isn't limited to the time loop. I thought you meant that stuff changes a little bit each time a message is sent back, not that the whole timeline is changing
17:51:01 <irene-knapp> ksf: so long as you agree that you did it /because of/ me, so that it's compatible with the Extremely Strong Anthropogenic Principle as applied to Irene Knapp...
17:51:06 <irene-knapp> kumil_: oh!  yes :)
17:51:09 <MiggyX> JoeyA:  honestly? I can't say I've thought about it. As you can tell I'm obviously very new to this - but I'm keeping an open mind and I've learned a ton of new concepts in here :)
17:51:26 <kumil_> russellw: nevermind, misunderstood the conditions
17:51:32 <irene-knapp> kumil_: it's the universe that changes :) it does this naturally, too, at a very low error rate, and the erstwhile scientists eventually devised an experiment to measure that rate, hahaha
17:51:53 <Pseudonym> Wouldn't that be a gynopic principle?
17:51:53 <JoeyA> MiggyX: foldl has an accumulator, so in a sense, it needs state.
17:51:57 <ksf> irene-knapp, well, at some point in time we all have to accept that our reason for existence is to serve as a bad example for others...
17:52:06 <kumil_> irene-knapp: what aout the butterfly effect?
17:52:26 <irene-knapp> Pseudonym wins.  Yes, a gynopic principle, haha.
17:52:33 <JoeyA> MiggyX: If you need to keep track of previously-received packets, you'll need "state", perhaps in the form of a parameter you pass around.
17:52:35 <irene-knapp> ksf: bah!
17:52:46 <JoeyA> e.g. loop :: MyState -> IO ()
17:52:48 <irene-knapp> kumil_: not explicitly dealt with.  the book was written a couple years before chaos theory took off :)
17:52:49 <MiggyX> JoeyA:  I guess it does. I suppose you just create a "baton" that you pass between the functions
17:52:58 <JoeyA> MiggyX: Exactly
17:53:05 <ksf> kumil_, you mean the magic by which lemon butterflies turn yellow after spending their youth quite green? I never got to the bottom of that.
17:53:05 <MiggyX> JoeyA:  that wouldn't create state because each function would be called with different parameters
17:53:22 <JoeyA> You could also use the StateT monad transformer to do it for you (at the expense of having to "lift" IO operations)
17:53:24 <irene-knapp> kumil_: sounds like the book needs updating.  you can be in charge of that :D
17:53:34 <JoeyA> MiggyX: Right, but it simulates state.
17:53:38 <ksf> it'd be easier if those buggers actually *liked* lemons. but they don't even care.
17:54:05 <Pseudonym> Mmmmm... lemon butter...
17:54:11 <JoeyA> MiggyX: Alternatively, you could use an IORef.
17:54:58 <JoeyA> MiggyX: I nibbled on your question because I'm writing threaded client and server programs, and I'm finding it hard to do elegantly.
17:55:27 <JoeyA> I'm frequently torn between IORef and TVar (STM).
17:55:29 <Pseudonym> You can also, by the way, use a ReaderT which passes an IORef (or several IORefs).
17:56:26 <MiggyX> JoeyA: this particular app should be simple. At least it is in Python :)  Receive packet, get reply, calculate time difference, send to other app for processing. Job done :)
17:56:32 <JoeyA> For example, I'll use an IORef to track state in my program loop (because I don't think it'll be used in other threads), then realize I *do* want to use it in another thread.
17:56:48 <JoeyA> MiggyX: Then I guess we're in the same boat on this one.
17:57:02 <JoeyA> (except I don't know Python well :( )
17:57:07 <MiggyX> JoeyA: well, if you're having trouble with it, I'm pretty much screwed lol
17:57:37 <JoeyA> MiggyX: Not nececellery.
17:58:05 <JoeyA> My code would probably be better if I used monad transformers like ReaderT.
17:58:28 <JoeyA> Pseudonym: That's a good idea.  An advantage is that it's harder to accidentally use the IORef in the wrong thread.
17:58:40 <JoeyA> (unless you lift forkIO)
17:59:43 <JoeyA> Recently, I've been battling with the logistics more than the communication.
17:59:58 <JoeyA> In particular, I receive database notifications when rows are updated.
18:00:11 <MiggyX> JoeyA: the current script is simple but doesn't do multi threading - problem is, too much data on the wire and I can't easily filter itâ€¦ long story short, packets get dropped and sadly usually ones I need to see :/
18:00:22 <JoeyA> When a row "changes", "subscribers" to that row need to be notified.
18:00:33 <JoeyA> Every time I try to implement it, it's messy.
18:00:55 <JoeyA> And there can be different types of rows, of course.
18:01:28 <JoeyA> newtype ConfigType r k c = ConfigType (IORef (Map k [(Handler r c, IORef ())]))
18:01:38 <JoeyA> There's got to be a better way...
18:02:15 <JoeyA> MiggyX: So it's a performance issue?
18:02:30 <hpc> JoeyA: you could try making more data types, like an explicit one for the tuple
18:02:45 <hpc> JoeyA: and you can also try moving what gets IORef'd
18:02:54 <hpc> JoeyA: see if moving it "deeper" into the structure might help at all
18:04:11 <hpc> JoeyA: if you don't mind it taking a while, you can write the program once without worrying about abstractions, then use the best functions you get out of that design to help you do it again correctly
18:04:43 <MiggyX> JoeyA: Yeah, at least I believe that to be the case. tcpdump gets the data fine, but my script doesn'tâ€¦ not that I've really optimized the script. However I'm also looking to try Haskell in real world situations. I could rewrite the script in C but I was hoping to demonstrate the benefits of a functional language. At least that's the plan :)
18:05:26 <JoeyA> hpc: I guess I sort of did that.  Still, I end up with a 30-line tall IO function that creates IORefs and TVars at the top and uses them all over the place.
18:06:32 <hpc> JoeyA: sometimes that's inevitable; at work we have a 1000-line perl function that 30 people over 7 years couldn't figure out how to refactor
18:06:55 <hpc> i have a partial refactor that uses what amounts to ContT, but it isn't particularly nice
18:07:12 <hpc> sometimes a problem is just fundamentally going to require "ugly" code
18:07:38 <hpc> where you initialize lots of things and reuse them in odd patterns
18:07:54 <Pseudonym> The secret is hiding the ugliness behind a good API.
18:07:55 <JoeyA> hpc: I find it easier to work with messy code in weaker-typed languages (e.g. C, PHP).  However, it tends to be my own code.
18:08:23 <JoeyA> When I'm working with messy code in Haskell, it just feels harder.
18:08:30 <kumil_> ...weaker typed has an entirely different meaning in C and PHP
18:08:40 <Axman6> void *
18:08:47 <Axman6> ... string?
18:09:21 <JoeyA> kumil_: By weakly typed, I mean the type system is less involved in the program.
18:09:32 <hpc> JoeyA: it's definitely harder the first time, but i find that effort pays off when it comes time to refactor
18:10:27 <hpc> and if you can happen across the right abstraction up front, the entire program may end up being trivial
18:11:31 <JoeyA> hpc: I suppose I agree.  When I added a simple enhancement to cabal-install ( http://hackage.haskell.org/trac/hackage/ticket/889 ), I hardly knew what how cabal was put together, but I managed to get it working quickly.
18:11:41 <JoeyA> I spent a lot of time chasing down data constructor names.
18:11:58 <JoeyA> configuredPackageLicense (ConfiguredPackage a _ _) = PD.license $ PD.packageDescription $ packageDescription a
18:12:17 <Axman6> writing quick and dirty haskell is always made much easier if you don't do it so quickly, and think about the problem first
18:12:19 <hpc> i think for a client-server program (which i think you said yours is), i would start with "how does data need to move about the program" and work from there, using forkIO and IORefs to split up work as needed
18:13:15 <hpc> then only later worry about needing transaction support, if concurrency-related bugs become frequent
18:13:57 <hpc> JoeyA: also remember that you can pass IO actions as parameters to other functions
18:14:07 <JoeyA> hpc: As opposed to the usual inclination of? : What workers will I need?  Let's see, the database thread, the "main thread", etc.
18:14:46 <JoeyA> hpc: Indeed.  I independently discovered join $ atomically $ do
18:15:37 <hpc> JoeyA: if you feel like a bad enough dude, you can see if Cont provides some useful abstractions
18:15:47 <hpc> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
18:16:25 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11 -- basically the same thing as sigfpe's, only with more intermediate steps
18:18:06 <JoeyA> hpc: Thanks for the pointers.
18:18:30 <hpc> np
18:21:43 <MiggyX> JoeyA: soâ€¦ what should I read up on next? :)
18:26:04 <Pseudonym> JoeyA: You shouldn't be using pointers.
18:37:00 <JoeyA> Pseudonym: So I should be using std::<a>_pointer ?  (where <a> is one of about six choices)
18:37:50 <JoeyA> MiggyX: What are you using to read the data?  Is there some way you can avoid String in favor of ByteString or such?
18:37:54 <Pseudonym> Or references, yes.
18:38:53 <JoeyA> That's the problem with C++; so many ways to point to things.  At least with Haskell, all you have to worry about is IORef... or MVar... or TVar...
18:41:25 <Pseudonym> Mutable global state is hard. Let's go shopping!
18:43:59 <JoeyA> Queue a 1980s-looking educational video describing how computers are everywhere, including shopping malls.
18:44:31 <irene-knapp> Cue
18:44:32 <irene-knapp> not Queue
18:44:37 <JoeyA> Enqueue*
18:44:57 <irene-knapp> yes, okay
18:44:59 <JoeyA> irene-knapp: Indded, my bad
18:45:19 <Pseudonym> Priority cue.
18:45:22 <JoeyA> Of course, financial "transactions" are not quite like transactions in programming, unfortunately.
18:45:29 <JoeyA> They're sort of like missiles.
18:45:49 <Pseudonym> They are like transactions, in that they must either completely succeed or completely fail.
18:46:13 <JoeyA> Well, you request an EFT from your bank.
18:46:31 <JoeyA> But the product may be shipped before the bank gets the memo.
18:46:50 <Pseudonym> The EFT payment is the financial transaction, though.
18:47:15 <Pseudonym> You can't have the money disappear from your account and not appear in the vendor's account, or appear in the vendor's account without disappearing from yours.
18:47:22 <JoeyA> Then the bank finds you don't have $xxx in your account, so they charge you a fee and tell the online store it failed... after your product has been shipped.
18:47:24 <Pseudonym> That's what makes it a "transaction".
18:47:42 <irene-knapp> oh
18:47:49 <irene-knapp> that wasn't a misspelling of "exchange-traded fund"
18:47:51 <irene-knapp> that was some other word
18:48:03 <Pseudonym> Electronic funds transfer.
18:48:04 <JoeyA> Electronic Funds Transfer
18:48:07 <irene-knapp> oh, yes, okay
18:48:17 <JoeyA> oblig. I am not an accountant
18:48:22 * irene-knapp nods
18:48:34 <Pseudonym> Me neither, but I know people who hack banking systems.
18:48:39 <irene-knapp> meanwhile, I have lost a total of $10 in the stock market!
18:48:43 <irene-knapp> be proud of me
18:48:45 <irene-knapp> most people lost a lot more
18:48:49 <JoeyA> Nor am I a lawyer, a doctor, or a guitar player.
18:49:33 <Pseudonym> I don't know anything, but I reckon lots of stuff.
18:49:53 * mike-burns shoots a questioning look at his "guitar tips by JoeyA" file.
18:50:39 <JoeyA> https://www.google.com/search?q=%22I+am+not+a+*%22 -- hmm, "I am not a lawyer" isn't anywhere near the top.
18:50:58 <irene-knapp> hm
18:51:00 <rwbarton> in Repa, how do I avoid these "Data.Array.Repa: Performing nested parallel computation sequentially." messages?
18:51:16 <rwbarton> Is my approach of randomly inserting calls to force and deepSeqArray the correct one?
18:55:51 <MiggyX> JoeyA: I'm using pcap which does use byte string. Not expecting any performance issues in Haskell, it's more how to approach the problem from a functional mind set :)
18:56:27 <Axman6> MiggyX: what are you trying to do?
18:57:11 <JoeyA> MiggyX: Let me get this straight: your Haskell program is dropping packets because it isn't performant enough?
18:57:22 <MiggyX> Axman6: I look for a particular packet on the wire, and then wait for the response from the server. From that I get a round trip timestamp
18:57:25 <JoeyA> Or is it your Python program that's dropping packets, so you're writing it in Haskell instead?
18:57:44 <MiggyX> JoeyA: No, the Python program is dropping packets. Normally I would rewrite it in C - but I am trying to learn Haskell and figured this would be a good real world project to try
18:57:55 <JoeyA> MiggyX: Ah, okay
18:58:28 <JoeyA> I was gonna say: if you wrote a program in Haskell and it isn't performing well, "thinking functionally" is probably not the right tool for the job :-)
18:59:48 <JoeyA> MiggyX: But it's perfectly functional to think in terms of: Packet -> FilterState -> (Maybe Timestamp, FilterState)
19:00:01 <MiggyX> JoeyA: For now it's just figuring out where to start :) I can read packets off the wire - I'm just not sure how to best handle the state issues we talked about :)
19:00:14 <JoeyA> MiggyX: That's a functional encoding of state right there.
19:00:42 <JoeyA> You have a state, and you have a packet.  What's the next state gonna be, and did we get any results?  It's a pure function!
19:01:57 <JoeyA> MiggyX: FilterState could be defined as: data FilterState = FilterState { fsFoo :: TimeStamp, fsBar :: Int } -- it's your job to figure out what it's for
19:02:17 <JoeyA> (just demonstrating basic record syntax)
19:03:22 <leo2007> does github.com/nominolo/scion.git support ghc 7.0?
19:05:26 <JoeyA> Searching instead for https://github.com/nominolo/scion
19:05:50 <JoeyA> "authored August 13, 2011"
19:06:12 <MiggyX> JoeyA:  okay, but there could be many outgoing packets before I receive a single response - would this approach still work? Or would I just need a list of filter states?
19:07:46 <JoeyA> MiggyX: So you're uninterested in outgoing packets, or do you filter them conditionally, based on past information?
19:08:50 <MiggyX> JoeyA: I look for a specific destination. If I see it, then I want to find out how long it took for a response
19:09:05 <JoeyA> Ah
19:09:38 <JoeyA> So you're accumulating response filters
19:09:58 <JoeyA> Your state might have something like Map Address TimeStamp
19:10:17 <JoeyA> (where TimeStamp is whatever format you're using for time values)
19:11:17 <JoeyA> MiggyX: If your python script is traversing a list of previously-encountered addresses, that may be O(n) per packet, and the reason for the performance issue.
19:11:43 <JoeyA> But if you're storing those addresses in a dictionary (which ought to support at least O(log n) accesses), you should be fine.
19:12:16 <MiggyX> JoeyA:  hash map keyed on the source / dest ips and ports
19:12:47 <MiggyX> the hash map itself should be quite small - as soon as I have the timestamp, I drop the entry from the map. So at most I would never expect more than 30 entries really
19:13:20 <JoeyA> MiggyX: Good
19:14:22 <JoeyA> MiggyX: The key idea behind Haskell and purely functional programming is that all of your context must be explicit.
19:15:46 <JoeyA> Packet -> Map Address Timestamp -> Map Address Timestamp is pretty clear about what the function can do.
19:16:44 <MiggyX> true
19:17:16 <JoeyA> However, if you want to be able to produce results (e.g. [(Address, Interval)]), you could say: Packet -> Map Address Timestamp -> (Maybe (Address, Interval), Map Address Timestamp)
19:17:44 <JoeyA> Your connection loop could keep invoking this function and processing the results.
19:19:22 <JoeyA> MiggyX: On the other hand, Packet -> State -> IO (Result, State) is what you might expect: the same as Packet -> State -> (Result, State), but some IO can happen to produce the return value.
19:20:03 <MiggyX> JoeyA:  makes sense :)
19:21:21 <JoeyA> If you want to use monad transformers, Packet -> State -> ([Result], State) can be formulated as a state and writer monad.
19:23:01 <ferromagnificent> Hello all, I'm a new xmonad user. I have what I'd imagine is a beginner question, but my Google-Fu has failed me. How can I change t he colors of xmobar's StdinReader? It doesn't seem to take arguments like some of the other plugins.
19:23:03 <MiggyX> JoeyA: I will have to read up on all of this lol
19:23:35 <Axman6> ferromagnificent: you might get better responses in #xmonad
19:23:49 <ferromagnificent> Ah, thank you. My apologies
19:23:55 <JoeyA> So you could say processPacket :: Packet -> StateT (Map Address Timestamp) (WriterT [(Result, State)] Identity) ()
19:24:02 <JoeyA> MiggyX: Easy as cake, right?  :-)
19:24:10 <MiggyX> as a side question,  how can you do something like   if String contains X then print it else, don't print anything :)
19:24:24 <MiggyX> JoeyA: not sure about easy as cake but I have a much better understanding than I did before thanks to you :)
19:24:34 <Axman6> when (x `isInfixOf` str) $ print str
19:24:54 <Axman6> putStrLn str is probably what you want actually
19:24:56 <JoeyA> I'd start with the functional encoding first, but it's enlightening to think of Foo -> (Bar, Foo) as being a state thingy over Foo.
19:24:59 <Axman6> @hoogle when
19:24:59 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
19:24:59 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
19:24:59 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
19:27:35 <Goosey_> albel727: Successful troll is successful
19:27:59 <albel727> indeed )
19:28:03 <Patinho`Busy> !nn all. :w
19:28:14 <Goosey_> That's the first avatar I've seen on IRC.
19:28:35 <albel727> strange. they are not that rare.
19:28:44 <MiggyX> At the moment I have the problem where I am using a case statement to ID packets but need to have an else - but I don't care about the else. Still, at least it's exercising my brain :)
19:28:52 <Axman6> Goosey_: did you end up writing that map function?
19:29:36 <Goosey_> Axman6: monochrom added that : x to mine and it worked, I asked him for a trace and learned how it worked
19:30:09 <Goosey_> I was so close, then I saw his comment and so I had no choice :/
19:30:19 <Axman6> yeah :\
19:30:31 <Goosey_> Either way, I was almost there :/
19:30:48 <Axman6> Goosey_: want another, slightly harder problem?
19:30:51 <Goosey_> I did 21/22 of it :P
19:30:55 <Goosey_> Axman6: Of course :D
19:30:58 <Axman6> heh, indeed :P
19:31:12 <JoeyA> MiggyX: Sounds like you want the _ pattern (match and discard anything)
19:31:34 <Goosey_> > let map' f xs = foldr (\x xs -> f x : xs) [] xs  in map' (*3) [1..10]
19:31:35 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
19:31:57 <JoeyA> case packet of (Send, addr, t) -> ...; _ -> (Nothing, state)
19:32:20 <MiggyX> JoeyA:  can you do anything similar with an if then statement?
19:32:28 <mdxbhmt> hey, i just posted a question on reddit, could you guys say if it's a good idea or i'm missing something?
19:32:48 <Axman6> Goosey_: ok, i'll see if i can exaplin this one. your task is to take a list of numbers, and return a tuple with their sum, and a list of their sums from the right: sumThing [1,2,3,4] = (10,[10,9,7,4]). you should be able to implement this using foldl, and it will look something like: foldl f (0,[]) xs
19:33:13 <Axman6> :t scanr
19:33:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
19:33:14 <JoeyA> MiggyX: if-then-else is rather boring in Haskell.  You may want to use pattern matching and guards instead.
19:33:37 <MiggyX> JoeyA:  fair enough - let me have a go at that :)
19:34:06 <JoeyA> (I'm not saying don't use if-then-else, but patterns and guards are more powerful, and definitely worth looking into if "if" isn't good enough ;-)
19:34:35 <Goosey_> axman,  a tuple, where the first one is their sum, and the second one is the list of ALL their sums?
19:34:37 <MiggyX> well in this case I don't have an else value :)
19:34:54 <JoeyA> MiggyX: Then what you have is a guard ;-)
19:34:59 <Goosey_> Axman6*
19:35:36 <Axman6> Goosey_: the second is a list of summing the numbers from the right together: so, [1,3,5,2] -> [11,10,7,2]
19:35:37 <Goosey_> cabal: Error: some packages failed to install: lambdabot-4.2.3.2 failed during the building phase. The exception was: ExitFailure 1
19:35:40 <Goosey_> That was usefull :/
19:35:41 <MiggyX> JoeyA: but doesn't the function still have to return some value? :)
19:35:57 <JoeyA> MiggyX: I'm getting to that
19:36:07 <JoeyA> plural str = if str == "cat" then "cats" else ... I don't know! ...
19:36:14 <Axman6> Goosey_: there's usually a more helpful error above that somewhere. but lambdabot is notorious for being annoying to install i think
19:36:15 <JoeyA> Not valid syntax, but you could say:
19:36:21 <JoeyA> plural str | str == "cat" = "cats"
19:36:24 <JoeyA> or:
19:36:29 <JoeyA> plural "cat" = "cats"
19:36:35 <Goosey_> ax so the list is [2+5+3+1,2+5+3,2+5,2]
19:37:17 <Axman6> [a,b,c,d] -> [a+b+c+d,b+c+d,c+d,d]
19:37:27 <Goosey_> yeah
19:37:48 <JoeyA> MiggyX: Patterns and guards are matched from top to bottom.  If no pattern matches, an exception is thrown.  It is generally considered bad practice to have these cases.
19:37:54 <Axman6> which i see is what you had... but the order was different, so yes :)
19:38:05 <JoeyA> The easiest alternative is to throw a descriptive error message.
19:38:06 <JoeyA> @src head
19:38:06 <lambdabot> head (x:_) = x
19:38:07 <lambdabot> head []    = undefined
19:38:25 <MiggyX> ah
19:38:28 <JoeyA> I think GHC uses something like: head [] = error "Prelude: head"
19:38:45 <Goosey_> Ax, let me see what I can do :D
19:38:55 <Goosey_> "'a':'b':'c':[] GIMMEH SOME SHUGAH"
19:39:07 <Axman6> Goosey_: before you go any further what should sumThing [] equal?
19:39:11 <JoeyA> MiggyX: But if you're in the IO monad and want if without else, you just make the else case be return ()
19:39:25 <JoeyA> MiggyX: Unlike in most imperative languages, return does not exit the function!
19:39:26 <Goosey_> sumThing [] = 0
19:39:31 <Goosey_> or rather
19:39:37 <Goosey_> (0,[0])
19:39:40 <JoeyA> return () does nothing.  You need continuation support to jump out of functions.
19:39:41 <Axman6> almost
19:39:45 <Axman6> (0,[])
19:39:48 <Goosey_> >_<
19:40:07 <JoeyA> MiggyX: So in IO, you might say: if x < y then launchMissiles else return ()
19:40:18 <Goosey_> Should I use pattern matching for that?
19:40:40 <JoeyA> MiggyX: The 'when' combinator in Control.Monad can be used instead: when (x < y) launchMissiles
19:40:43 <JoeyA> @src when
19:40:43 <lambdabot> when p s = if p then s else return ()
19:41:48 <Axman6> Goosey_: no! only foldr, and a combining function you define :)
19:41:54 <Goosey_> okay :D
19:42:04 <Axman6> Goosey_: to test your results, you can use sumThingAx [1,2,3]
19:42:12 <Axman6> > sumThingAx [1,2,3]
19:42:14 <lambdabot>   (6,[6,5,3])
19:42:25 <Goosey_> okay
19:42:38 <Axman6> > sumThingAx [a,b,c]]
19:42:39 <lambdabot>   <no location info>: parse error on input `]'
19:42:40 <Axman6> > sumThingAx [a,b,c]
19:42:41 <lambdabot>   (0 + c + b + a,[0 + c + b + a,0 + c + b,0 + c])
19:42:59 <MiggyX> JoeyA: ah right - that's pretty sweet
19:43:00 <Axman6> that might give you some clue
19:44:36 <Goosey_> would the type be sumThing :: [a] -> (b,[b])
19:44:52 <Axman6> Num a => [a] -> (a,[a])
19:45:00 <Axman6> :t sumThingAx
19:45:00 <lambdabot> forall a. (Num a) => [a] -> (a, [a])
19:45:06 <Goosey_> Aha
19:45:14 <Axman6> but, well done for being so close
19:45:30 <Axman6> shows you're learning haskell types
19:45:35 <Goosey_> I had this copied thinking I was wrong: (Num a) => [a] -> (a,[a]) xD
19:45:45 <Axman6> heh
19:46:47 * hackagebot carray 0.1.5.1 - A C-compatible array library.  http://hackage.haskell.org/package/carray-0.1.5.1 (JedBrown)
19:47:20 <Goosey_> also, :t * doesn't work in a query with lambdabot
19:47:57 <Axman6> :t (*)
19:47:58 <lambdabot> forall a. (Num a) => a -> a -> a
19:48:23 <Axman6> you might need to use @type in a private message though
19:48:25 <Goosey_> Axman6: by * I meant the widlcard
19:48:31 <Goosey_> wildcard*
19:48:31 <Goosey_> ah
19:48:41 <MiggyX> JoeyA: so, one last question before I leave you in peace :)  Say you've got a couple of functions that test a packet - like to see if it's of a certain type or length. What's the best way to string that together?  For example if you want to print a header value if the packet is say 100 bytes long and contains a TCP packetâ€¦   The function always receives a packet, but say you want to return the packet if it's valid or "null" if it's not?  I'm not even
19:48:41 <MiggyX> sure I'm making sense now lol
19:48:41 <Goosey_> That does it :D
19:49:55 <XexonixXexillion> MiggyX: Using Maybe perhaps?
19:50:54 <JoeyA> MiggyX: If you're just printing packets, you could just use Packet -> State -> IO (Result, State), where the IO you're doing is printing packets.
19:51:39 <JoeyA> But as XexonixXexillion says, Maybe is what NULL is in other languages.
19:51:50 <MiggyX> okay, I will look into that :)
19:51:51 <JoeyA> except better
19:51:57 <MiggyX> btw the code looks a lot nicer rewritten with guards
19:52:10 <Goosey_> Axman6: I'm actually not really sure what to do. I'm thinking on each fold it appends to the list but I don't know >_<
19:52:14 <MiggyX> brb
19:53:02 <Axman6> Goosey_:  start with this: sumThing xs = foldr (\x (ysum,ys) -> ...) (0,[]) xs
19:59:20 <Goosey_> @src zip
19:59:20 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
19:59:20 <lambdabot> zip _      _      = []
20:01:39 <Goosey_> I'm a freaking beast
20:01:47 <Goosey_> (ysum + x, x : ys)
20:01:50 <Goosey_> That was the missing part :D
20:02:13 <Axman6> i think it's close, but but quite matching the described problem
20:02:22 <Goosey_> let sumThing xs = foldr (\x (ysum,ys) -> (ysum + x, x : ys)) (0,[]) xs in sumThing [1,2,3,4]
20:02:34 <Goosey_> Wait, what?
20:02:37 <Goosey_> > let sumThing xs = foldr (\x (ysum,ys) -> (ysum + x, x : ys)) (0,[]) xs in sumThing [1,2,3,4]
20:02:38 <lambdabot>   (10,[1,2,3,4])
20:02:39 <irene-knapp> wow, heh
20:02:46 <irene-knapp> I just hit my first-ever situation
20:02:49 <Axman6> > foldr (\x (ysum,ys) ->  (ysum + x, x : ys)) (0,[]) [a,b,c,d]
20:02:50 <irene-knapp> in which I need to use Rank2Types
20:02:50 <lambdabot>   (0 + d + c + b + a,[a,b,c,d])
20:03:25 <Axman6> Goosey_: try adding ysum to the x in the list maybeh >_>
20:03:26 <Goosey_> > sumThingAx [a,b,c,d]
20:03:27 <lambdabot>   (0 + d + c + b + a,[0 + d + c + b + a,0 + d + c + b,0 + d + c,0 + d])
20:03:37 <Goosey_> Oh
20:03:39 <Goosey_> I see now >_<
20:04:03 <Axman6> good work though :D
20:04:04 <Goosey_> I forgot about the second part once I figured out the first xD
20:04:15 <Axman6> ^5
20:04:53 <Goosey_> I think I'm doing well for the second day of haskell :D
20:05:03 <Axman6> yeah man, you should be proud
20:05:26 <Axman6> want another problem?
20:05:27 <Goosey_> I am ^^; Thanks for helping me, I probably wouldn't have gotten so far without this channel's help.
20:05:38 <Goosey_> Axman6, I'll take another :D
20:05:54 <Axman6> the only one i can think of off the top of my head is pretty similar to the last one... we'll see how it goes
20:06:20 <Axman6> so, like the last one, return a tuple with the sum of all the elements, and also a list with all the elements squared
20:06:36 <Axman6> one sec and i'll have an implementation defined for you
20:06:44 * Axman6 goes behind the curtain to mess with things
20:07:26 <Goosey_> Like this: sumThing xs = foldr (\x (ysum,ys) -> (ysum + x,  x*x : ys)) (0,[]) xs
20:08:08 <Goosey_> > let sumThing xs = foldr (\x (ysum,ys) -> (ysum + x,  x*x : ys)) (0,[]) xs in sumThing [1..10]
20:08:09 <lambdabot>   (55,[1,4,9,16,25,36,49,64,81,100])
20:08:37 <Axman6> damn, you got back before i'd even finished it!
20:08:43 <Goosey_> ;D
20:09:20 <Axman6> oh i know a good one, you have to define the `and function: it takes a list of Bools and tells you whether they're all true or not:
20:09:29 <Goosey_> :O
20:09:31 <Axman6> > and [True,True]
20:09:31 <lambdabot>   True
20:09:36 <Axman6> > and []
20:09:36 <lambdabot>   True
20:09:42 <periodic> Gah, what's the best way to do ByteString -> String?  Hoogle is being unhelpful.
20:09:42 <Goosey_> and [True,True,True]
20:09:42 <Axman6> > and [True,False]
20:09:43 <lambdabot>   False
20:09:47 <Goosey_> > and [True,True,True]
20:09:48 <lambdabot>   True
20:09:54 <Goosey_> Hm
20:10:07 <aavogt> @hackage utf8-string -- periodic
20:10:08 <lambdabot> http://hackage.haskell.org/package/utf8-string -- periodic
20:10:19 <Axman6> > and ([True,False] ++ repeat True) -- this one's important, and the reason we use foldr and not foldl
20:10:20 <lambdabot>   False
20:10:28 <Eduard_Munteanu> periodic: why do you want to do that?
20:10:30 <aavogt> or if you have other encodings there are probably packages for that too
20:10:38 <Axman6> Goosey_: ok, so what're your base case? and [] = ?
20:10:46 <Goosey_> and [] = True
20:10:54 <Axman6> good!
20:11:06 <Axman6> now, you need the step case
20:11:13 <periodic> Eduard_Munteanu: Printing to a GTK gui buffer.
20:11:19 <Axman6> remember that you have at your disposal the function (&&):
20:11:22 <Goosey_> step case?
20:11:23 <Axman6> :t (&&)
20:11:24 <lambdabot> Bool -> Bool -> Bool
20:12:00 <periodic> aavogt: thanks.
20:12:04 <Eduard_Munteanu> periodic: ah, that's fair. I thought you just wanted to 'unpack' the bytestring, which probably isn't a good idea.
20:12:28 <periodic> Eduard_Munteanu: Yeah.  I used to always want to retreat to the safety of strings, but I have become wiser. :)
20:13:00 <dday> periodic: are you the person who just asked the same question on reddit?
20:13:24 <Goosey_> Axman6: and' :: (Bool a) => [a] -> a is that the type?
20:13:25 <Axman6> Goosey_: it's language used when talking about defining functions inductively. if you can prove the base case is true (often when xs = [] or n = 0 say), and if by assuming a smaller case is true, a larger one can be proved to be true, then you can prove that something is correct. ... not sure how useful that explanation is for you at the moment
20:13:32 <Axman6> :t and
20:13:33 <lambdabot> [Bool] -> Bool
20:14:03 <MiggyX> sweet, my function now either returns a string ID'ing the packet - or Nothing
20:14:13 <periodic> dday: not I.
20:14:19 <MiggyX> now to get it to only print when it gets a String :D
20:14:42 <dday> periodic: http://www.reddit.com/r/haskell/comments/njejk/convertion_string_to_bytestring_done_by_the/
20:15:13 <dday> periodic: I suppose that person asked for the inverse process
20:15:24 <periodic> dday: oh, huh.  Well, I'm periodic on Reddit too.
20:16:13 <Axman6> Goosey_: it would be kinda cool to have Bool as a type class, but we don't. so we're just working with the Bool type
20:16:24 <Goosey_> Oh okay xD
20:16:54 <Axman6> Goosey_: anyway, so, you should have something like: and' xs = foldr (\x ys -> ...) True xs right?
20:17:01 <Eduard_Munteanu> Axman6: how so, like Num?
20:17:03 <Goosey_> yeah
20:17:06 <Goosey_> this is what I have right now
20:17:13 <JoeyA> instance Bool FileNotFound where
20:17:27 <Goosey_> nevermind
20:17:28 <Goosey_> My idea
20:17:35 <Goosey_> hold on actually >_<
20:17:42 <Axman6> Eduard_Munteanu: i guess basically what i'm describing if the bits class, but it would be nise to not have to use the ugly bits operators
20:18:27 <lukish_> Why did that question http://stackoverflow.com/q/8567743/ have +6? I supposed to see -3 there
20:18:28 <Axman6> Eduard_Munteanu: and we could do symbolic stuff like we do with Expr but with boolean functions like (||)
20:18:57 <XexonixXexillion> Just a random question - why is (a -> a) not an instance of Monoid?
20:19:34 <Axman6> XexonixXexillion: because Endo is
20:19:37 <Axman6> @src Endo
20:19:38 <lambdabot> Source not found. There are some things that I just don't know.
20:19:40 <Axman6> bleh
20:19:53 <Axman6> > appEndo (Endo id)
20:19:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:19:54 <lambdabot>    arising from a use of `...
20:19:58 <Axman6> > appEndo (Endo id) 5
20:19:59 <lambdabot>   5
20:20:23 <Axman6> newtype Endo a = Endo {appEndo :: (a -> a)}
20:21:19 <Goosey_> Oh
20:21:21 <Goosey_> that wasn't too hard
20:21:47 <Goosey_> > let ltru xs = foldr (&&) True xs in ltru [True,True]
20:21:48 <lambdabot>   True
20:21:55 <Goosey_> > let ltru xs = foldr (&&) True xs in ltru [True,False]
20:21:56 <lambdabot>   False
20:22:07 <Axman6> \o/
20:22:25 <Eduard_Munteanu> lukish_: why?
20:22:44 <Goosey_> I'm going to know foldr like the back of my hand :P
20:22:58 <Axman6> lukish_: what's your problem with the question?
20:23:19 <Axman6> Goosey_: i assume you can do the list identity using foldr?
20:23:37 <Axman6> listIdentity xs = xs
20:23:39 <dday> Goosey_: then, learn about unfoldl/unfoldr, and then about the second and third list homomorphism theorems
20:24:47 <Goosey_> Axman6: List identity being just returning the list given?
20:24:53 <Axman6> yep
20:24:57 <Axman6> but, using foldr
20:25:00 <Goosey_> Okay
20:25:02 <Goosey_> Let me try
20:25:18 <Axman6> hint, think about how you defined map'
20:26:06 <Goosey_> listId xs = foldr (\x xs -> x : xs) [] xs
20:26:26 <Axman6> good, now simplify, like you did with and'
20:27:26 <Goosey_> so, without an anon function?
20:27:34 <Axman6> yep
20:27:50 <ybit> about to knock out a gentle intro in the next few hours, woot
20:28:02 <ybit> almost through!
20:28:37 <Goosey_> hrm
20:28:49 <ybit> the one problem i have is that with the project euler problems, i can google for most of the problems and still have a different way of accomplishing a task
20:28:54 <ybit> this is not the case with haskell
20:28:58 <Axman6> Goosey_: because it's more a syntax thing, i'll just shw you: foldr (:) [] xs
20:29:04 <Axman6> show*
20:29:07 <Goosey_> oh
20:29:10 <Goosey_> >_<
20:29:10 <ybit> and my assumption is that project euler would be the ideal method of using haskell practically
20:29:18 <Goosey_> I was trying some complex crap
20:29:51 <Axman6> ybit: many people will tell you it isn';t, but i thought it was a great way to learn to do interesting things in haskell. got to implement lots of interesting algorithms
20:30:10 <byorgey> ybit: I don't know if PE counts as "practical" =)
20:30:12 <byorgey> but it is fun
20:30:12 <XexonixXexillion> Goosey_: you can also remove the xs from both sides to make it points-free
20:30:14 <Axman6> Goosey_: want another one? thsi one is quite different to the others...
20:30:18 <ybit> byorgey: :)
20:30:24 <Goosey_> Sure.
20:30:36 <Axman6> Goosey_: you have to implement the (++) function:
20:30:40 <Goosey_> XexonixXexillion: I don't know what point's free is yet :P
20:30:44 <Axman6> > [1,2,3] ++ [4,5,6]
20:30:45 <lambdabot>   [1,2,3,4,5,6]
20:30:49 <ybit> it's a great way to quickly "implement lots of interesting algorithms" as Axman6 mentions
20:30:50 <Goosey_> Ohohoh :3
20:30:53 <Axman6> > "hello" ++ " world"
20:30:54 <lambdabot>   "hello world"
20:31:13 <Goosey_> Using foldr still?
20:31:16 <Axman6> yep
20:31:20 <Goosey_> I have an idea
20:31:39 <Axman6> it's actually pretty cool when you see it, and you'll probably think it's really obvious when you do get it
20:32:02 <Axman6> Goosey_: so, start with the types. append :: ?
20:32:32 <Goosey_> lets see append :: [a] -> [a] -> [a]
20:32:35 <_Ray_> Hi :) Is there a native way to split a string by some character?
20:32:48 <_Ray_> Oh, "lines". Nvm :)
20:32:50 <Axman6> ybit: i found PE a fantastic way tp find out about, and learn new features/libraries in haskell
20:32:59 <_Ray_> (I wanted the char to be exactly "\n" ;))
20:33:01 <Axman6> Goosey_: bam! yes :)
20:33:26 <Axman6> Goosey_: ok, so, you've got append xs ys = ? to implement now
20:33:31 <ybit> Axman6: how many did you go through and did you end up cheating when you were stuck just to see the interesting implementation?
20:33:33 <Goosey_> yeah
20:33:42 <Eduard_Munteanu> _Ray_: there's Data.List.Split if you want something more general
20:33:48 <Eduard_Munteanu> @hackage split
20:33:48 <lambdabot> http://hackage.haskell.org/package/split
20:33:48 <Axman6> Goosey_: when you have append xs ys, what should the result be?
20:33:53 <_Ray_> Thanks :)
20:33:54 <Axman6> uh...
20:33:55 <Goosey_> xs:ys
20:33:58 <Axman6> append [] ys
20:34:03 <Goosey_> oh xD
20:34:03 <Axman6> not quite
20:34:21 <Goosey_> ys:[] ?
20:34:31 <Axman6> xs:ys will be a type error. remember that (:) adds an a to a [a] right?
20:34:31 <Goosey_> well, ys >_>
20:34:39 <Goosey_> oh okay
20:34:50 <Axman6> > [] ++ [1,2,3]
20:34:51 <lambdabot>   [1,2,3]
20:35:06 <Axman6> > "" ++ " hmm"
20:35:08 <lambdabot>   " hmm"
20:35:21 <Axman6> looks a lot like it's just the second argument right? ie ys
20:36:12 <Axman6> Goosey_: sorry, but I've got to leave, got a meeting at uni, and need to pick someone up on the way. feel free to PM me your answers/questions, and i'll try and answer them tonight
20:36:27 <Goosey_> Axman6:  Thanks man, you've been helpful, we'll talk later :D
20:36:34 <Eduard_Munteanu> Or you can continue asking here.
20:36:45 <Axman6> good luck, and yes keep asking in here!
20:36:50 <Goosey_> :D
20:37:02 <Axman6> and make sure you tell people not to just give you answers, or you'll leane about 5% as much
20:37:08 <Axman6> learn*
20:37:14 * Axman6 -> out
20:37:57 <Goosey_> > let append x y = foldr (:) x y in append [1,2] [3,4]
20:37:58 <lambdabot>   [3,4,1,2]
20:38:02 <Goosey_> >_<
20:38:12 <Eduard_Munteanu> Close ;)
20:38:44 <Goosey_> > let append x y = foldr (:) y x in append [1,2] [3,4]
20:38:45 <lambdabot>   [1,2,3,4]
20:38:45 <Goosey_> :P
20:39:23 <Goosey_> > let x = [1,2], y = [3,4] in x ++ y
20:39:24 <lambdabot>   <no location info>: parse error on input `,'
20:39:39 <Goosey_> > let x ++ y in x = [1,2], y = [3,4]
20:39:40 <lambdabot>   <no location info>: parse error on input `in'
20:39:42 <Goosey_> :/
20:39:46 <Eduard_Munteanu> s/,/;/
20:39:52 <Goosey_> oh
20:40:01 <Goosey_> > let x = [1,2]; y = [3,4] in x ++ y
20:40:03 <lambdabot>   [1,2,3,4]
20:40:20 <_Ray_> Inside a "main", would this be the correct way to read some lines from a file for further processing? "    fc <- liftM lines $ readFile "input.txt" "
20:41:56 <Eduard_Munteanu> :t (<$>)  -- might be nicer
20:41:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:42:01 <Goosey_> @src $
20:42:02 <lambdabot> f $ x = f x
20:42:09 <Goosey_> wait...what?
20:42:31 <_Ray_> it just has more precedence
20:42:34 <Goosey_> What's $ for? Association?
20:42:35 <Eduard_Munteanu> Goosey_: it's exactly application, except it has really low precedence
20:42:42 <Goosey_> oh
20:43:02 <Eduard_Munteanu> Goosey_: compare   (f . g) x   with   f . g $ x
20:43:02 <Goosey_> so like () except on the other end of the precedence spectrum?
20:43:17 <_Ray_> Eduard_Munteanu, so fc <- lines <$> readFile "input.txt"?
20:44:08 <Eduard_Munteanu> _Ray_: both are correct, it was mainly a style-related suggestion
20:44:18 <_Ray_> Yeah, it's what I was looking for :)
20:44:54 <Goosey_> @src .
20:44:54 <lambdabot> (f . g) x = f (g x)
20:44:54 <lambdabot> NB: In lambdabot,  (.) = fmap
20:45:07 <Goosey_> . is another precedence operation?
20:45:14 <Goosey_> well, notation
20:45:48 <MiggyX> hmm, okay I can get a function to return a String or Nothing which is greatâ€¦ but how can I use it  with another function?  like   trackThis  (isTCP (isRightSize packet))      Basically isRightSize either returns the packet or Nothing.  Is that the idiomatic way to do it or am I on the wrong path again? :)
20:46:07 <Goosey_> Interesting, anyways, I'm going to take a break for now, thanks again.
20:46:57 <Clint> isRightSize sounds like it should -> Bool
20:47:59 <Eduard_Munteanu> Goosey_: no, it's function composition
20:48:11 <MiggyX> Clint:  it was before I tried to be clever and make the code easy to read ;)
20:48:21 * MiggyX is still getting used to moving data around
20:49:53 <Eduard_Munteanu> MiggyX: well you can either pattern-match at every step, or use the Maybe monad and let it fall through the Nothings
20:50:35 <MiggyX> Eduard_Munteanu: can you still use Maybe and keep the function pure?  I tried  do and when but that didn't go so well :D
20:50:42 <Goosey_> Eduard_Munteanu: But all it does is redefine the syntax of a function..Does it also change it's precedence? What would it's effect be?
20:50:46 <XexonixXexillion> MiggyX: If you want easy to read, and isTCP and isRightSize are returning Maybe values, why not isRightSize packet >>= isTCP >>= trackThis
20:51:14 <Eduard_Munteanu> > (*2) . (+1) $ 5
20:51:15 <lambdabot>   12
20:51:54 <Eduard_Munteanu> MiggyX: using monads doesn't make it impure
20:52:09 <hpaste> â€œ_Ray_â€ pasted â€œNewbie do-notation questionâ€ at http://hpaste.org/55481
20:52:11 <Goosey_> > (*3) . (+1) . (*2) $ 2
20:52:13 <lambdabot>   15
20:52:22 <Goosey_> seems like it works like rpn :P
20:52:25 <MiggyX> I still have the issue of  the function expecting ByteString but getting a Maybe ByteString instead
20:52:34 <Eduard_Munteanu> Goosey_: (f . g) x = f (g x)
20:52:46 <shachaf> MiggyX: What do you mean by "pure"?
20:53:11 <Goosey_> :t .
20:53:11 <lambdabot> parse error on input `.'
20:53:19 <Goosey_> @type .
20:53:20 <lambdabot> parse error on input `.'
20:53:35 <Eduard_Munteanu> @src Maybe (>>=)
20:53:36 <lambdabot> (Just x) >>= k      = k x
20:53:36 <lambdabot> Nothing  >>= _      = Nothing
20:53:50 <XexonixXexillion> MiggyX: Which function is expecting a ByteString?
20:53:58 <_Ray_> What am I doing wrong in the paste above?
20:54:06 <MiggyX> isTCP
20:54:19 <MiggyX> which will either get a ByteString from isRightSize or a Nothing
20:54:26 <Clint> _Ray_: what are you expecting "return 0" to do?
20:54:48 <_Ray_> Well I just wanted to "return" to end the main, but it complained because it wants an IO ()
20:55:01 <_Ray_> return () doesn't work either, however :(
20:55:02 <XexonixXexillion> MiggyX: instead of isTCP (isRightSize packet) use isRightSize packet >>= isTCP
20:55:14 <XexonixXexillion> _Ray_: return does not end a function in haskell
20:55:32 <_Ray_> Well the binds need to end somewhere...
20:55:38 <Eduard_Munteanu> _Ray_: main :: IO ()  normally
20:55:49 <_Ray_> Right, so what would be the correct return for that?
20:55:54 <Eduard_Munteanu> And yeah, it doesn't alter control at all
20:56:26 <_Ray_> Let's call it "pure", so we're all aware it doesn't have anything to do with C's return :p
20:57:14 <Eduard_Munteanu> _Ray_: return ()
20:57:17 <_Ray_> In any case, what would be the correct way to end main, then? Even removing the return, I get "    The last statement in a 'do' construct must be an expression:"
20:57:27 <_Ray_> I tried that, but it still returns the above error.
20:57:51 <MiggyX> XexonixXexillion: It just errors and says could not match expected type ByteString with inferred type MaybeByteString
20:58:19 <Eduard_Munteanu> To alter control you'd have to use stuff from System.Exit, or ContT with callcc
20:58:45 <Clint> _Ray_: why are you using mapM, what is data supposed to be for, etc.?
20:58:53 <_Ray_> Right, I'm not interested in that, I just wanted to know what the proper way to end a function returning "IO ()" is.
20:59:25 <Eduard_Munteanu> @hoogle exit
20:59:25 <lambdabot> System.Exit data ExitCode
20:59:25 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
20:59:26 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
20:59:31 <Eduard_Munteanu> @more
20:59:37 <Eduard_Munteanu> Hrm.
20:59:41 <_Ray_> Clint, data has to be an IO [Float].
20:59:44 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
20:59:45 <Clint> putStrLn "IO action time"
20:59:57 <Eduard_Munteanu> It will only work in IO.
21:00:28 <Clint> _Ray_: why? you're not using it at all
21:00:30 <Eduard_Munteanu> callcc would be a more general approach to getting C-ish returns
21:01:02 <_Ray_> Clint, it's clear my intention is to use it at some later line, I just want this to compile before writing more code.
21:01:51 <Eduard_Munteanu> (Also, exit[...] stuff will end the whole program)
21:01:55 <_Ray_> fc is [String], I want to take each String, and use readCoord on it, giving me a [[Float]]. But I'm in IO, so I mapM to get IO [[Float]].
21:02:55 <_Ray_> The two lines, as written, seem to be perfectly fine. I seem to be missing some syntax to let main end.
21:03:01 <Clint> you need to have main evaluate to an IO action
21:03:30 <_Ray_> I already tried returning (), same error.
21:03:59 <hpaste> â€œ_Ray_â€ annotated â€œNewbie do-notation questionâ€ with â€œNewbie do-notation question (annotation)â€ at http://hpaste.org/55481#a55482
21:04:14 <_Ray_> Still get a parse error.
21:04:37 <hpaste> gienah pasted â€œfoldM questionâ€ at http://hpaste.org/55483
21:04:37 <Eduard_Munteanu> 'data' is a reserved keyword
21:04:53 <Eduard_Munteanu> _Ray_: ^^
21:04:55 <_Ray_> Aaaaaah.
21:05:04 <_Ray_> What is it for?
21:05:12 <Eduard_Munteanu> @src Maybe
21:05:13 <lambdabot> data Maybe a = Nothing | Just a
21:05:16 <_Ray_> Ok, that makes it all work :)
21:05:21 <_Ray_> Oh you're right, the constructor syntax :)
21:05:27 <gienah> hi, I was wondering how to use foldM, in my tiny borked example I pasted to http://hpaste.org/55483
21:05:33 <_Ray_> Thank you :)
21:06:02 <_Ray_> (Is there something that means "mapM (return . f)"?)
21:07:05 <Eduard_Munteanu> _Ray_: you should just use map...    let foo = map bar xs
21:07:42 <scshunt> Eduard_Munteanu: That doesn't work on non-monads
21:07:42 <BMeph> Yah, that would just be (return.).map, or return . map f
21:07:53 <_Ray_> Does that type?
21:07:54 <scshunt> unless I'm greatly mistaken
21:08:01 <scshunt> I might be
21:08:02 <scshunt> I'm tired
21:08:17 <_Ray_> Seems to type :)
21:08:32 <Eduard_Munteanu> In his case it's what he needs.
21:09:09 <scshunt> oh wait, yes, that's fine
21:09:47 <_Ray_> Is there a practical difference between those two definitions of 'foo'?
21:10:21 <Eduard_Munteanu> gienah: I think you want getContext >>= foldM f ([], [])
21:10:30 <Eduard_Munteanu> :t foldM
21:10:31 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:10:53 <Eduard_Munteanu> Since   getContext :: (Monad m) => m [Either String String]
21:11:27 <gienah> Eduard_Munteanu: thanks, will see if this helps (I'm trying to patch hint to compile with ghc 7.4 snapshot)
21:11:46 <BMeph> Yeah, that works.
21:11:47 <Eduard_Munteanu> Gentoo patch? :)
21:12:50 <gienah> Eduard_Munteanu: yes, we have ghc 7.4 snapshot in the gentoo haskell overlay :-)
21:13:00 <Eduard_Munteanu> Hm, nice.
21:13:50 <bananaman> :3
21:16:47 * hackagebot bmp 1.2.0.1 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.0.1 (BenLippmeier)
21:17:01 <gienah> Eduard_Munteanu: thanks, your suggestion gets me past that hint error (working on the rest now)
21:21:50 * hackagebot simple-sendfile 0.2.0 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.0 (KazuYamamoto)
21:22:52 <Eduard_Munteanu> Mm... sendfile()
21:23:32 * Eduard_Munteanu wonders about splice() and friends
21:23:34 <shachaf> Eduard_Munteanu: What about splice()?
21:23:48 <shachaf> Curses.
21:23:51 <Eduard_Munteanu> :)
21:28:34 <Sgeo> Is Control.Exception.evaluate in haskell98?
21:31:32 <Eduard_Munteanu> Not sure, but you could try looking here: http://www.haskell.org/onlinereport/
21:32:01 <Eduard_Munteanu> Anyway, aren't you supposed to be looking at Haskell2010?
21:36:50 * hackagebot wai-app-file-cgi 0.4.2 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.4.2 (KazuYamamoto)
21:48:46 <cwl> Snap: index = writeBS "hello"
21:48:59 <cwl> the output contains no Content-Length header
21:49:40 <cwl> why, how to force snap to contain an content-length header
21:56:20 <ChengWei> Hello, Everyone.
21:56:41 <Guest11260> May I ask a question about FFI, finalizerPtr?
21:57:16 <shachaf> Guest11260: Just ask your question. Someone in here might know.
21:58:03 <Guest11260> Suppose there's a c function del_an_entry(Entry *e), how can I turn it into FinalizerPtr?
21:58:29 <Guest11260> I see some example use makeFinalizer, but cannot find any document about it.
22:00:35 <Guest11260> The example in RealWorldHaskell uses only FreeFinalizer, but many c libraries requires running an explicit function to free an struct.
22:00:50 <parcs`> cwl: maybe ask on #snapframework
22:01:34 <cwl> parcs`: asked, but no answer
22:02:12 <Guest11260> Normally, the function has type "Ptr S -> IO ()", then how can I turn it to FinalizerPtr, which is FunPtr (Ptr S -> IO ()) ? Thanks.
22:09:04 <_Ray_> Is "let pts = (. normalizer) . zip . normalizer" preferred over "let pts = zip (normalizer fst) (normalizer snd)"?
22:09:15 <shachaf> _Ray_: No.
22:10:18 <shachaf> However, (zip `on` normalizer) or something along those lines might be.
22:10:30 <shachaf> _Ray_: What are "fst" and "snd"?
22:10:39 <_Ray_> The usual fst and snd from Prelude.
22:11:03 <_Ray_> Where's on? I'd assume Applicative but... :s
22:11:09 <shachaf> Data.Function, I think.
22:11:10 <shachaf> @hoogle on
22:11:10 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:11:11 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
22:11:11 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
22:11:26 <_Ray_> Ah.
22:11:28 <_Ray_> Thanks :)
22:12:31 <_Ray_> So (zip `on` normalizer) fst snd would be preferred?
22:12:41 <_Ray_> Or at least, wouldn't be much worse than.
22:12:43 <shachaf> _Ray_: There's an easy way to test that.
22:12:45 <shachaf> Do you prefer it?
22:13:09 <_Ray_> My tastes wrt. Haskell syntax are pretty poor :s
22:13:16 <ski> Guest11260 : i'm not sure, but you could try making a simple C function that returns a pointer to `del_an_entry', then `foreign import' that one as `FunPtr (Ptr S -> IO ())'
22:13:20 <_Ray_> (But no.)
22:14:43 <ski> Guest11260 : or maybe something like `foreign import ccall "blah.h &del_an_entry" delAnEntry :: FunPtr (Ptr S -> IO ())' will actually work for function pointers as well, not just data pointers, i dunno
22:15:42 <Guest11260> Ski: Thanks. It seems there's a way to use makeFinalizer as  foreign import ccall "wrapper"  makeFinalizer :: (Ptr a -> IO ()) -> IO (FinalizerPtr a).
22:16:06 <shachaf> _Ray_: I think your original version is fine.
22:16:09 <Guest11260> But I don't know where is the document mentioning about this.
22:16:20 <shachaf> There's no reason to abstract for no reason.
22:16:50 * hackagebot bmp 1.2.0.2 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.0.2 (BenLippmeier)
22:18:40 <ski> Guest11260 : oh, right .. i didn't realizr that one could help here
22:20:13 <Guest11260> Ski: Thanks for your help. Do you know where can I find the document about   foreign import ccall "wrapper"
22:21:19 <ski> Guest11260 : for docs, see "Dynamic wrapper" at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-190004.1.3>, together with the definition of `FinalizerPtr' at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-300005.5>
22:21:52 <shachaf> Or http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
22:22:20 <ski> hm, yeah
22:22:25 * ski just followed
22:22:27 <ski> @where ffi
22:22:28 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
22:22:30 <ski> here
22:24:39 <Guest11260> Ski: Thanks. Now I understand. "wrapper" actually turns a haskell function into a pointer to foreign function. Thanks a lot for all your help.
22:25:19 <Sgeo> Hmm, just because it uses the haskell98 package doesn't mean it doesn't support normal stuff
22:25:19 <ybit> in (x:xs) ++ ys = x : (xs++ys)
22:25:39 <ybit> i've wondered how you read the ":" aloud
22:25:52 <ybit> ignored that for awhile
22:25:57 <ybit> but now i want to know :)
22:26:40 <ski> Guest11260 : yeah. but to me it seems that this common case should have a shorthand like `foreign import ccall "blah.h &del_an_entry" delAnEntry :: FinalizerPtr S'
22:27:22 <Guest11260> Ski: I will try your method now.
22:27:24 <ski> ybit : it's often read aloud as "cons" (coming from lisp `cons', short for "(list) constructor")
22:27:40 <ski> Guest11260 : i suspect that one doesn't work, but do try
22:29:08 <ski> @hoogle snoc
22:29:09 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
22:29:09 <lambdabot> Data.ByteString.Lazy.Char8 snoc :: ByteString -> Char -> ByteString
22:29:09 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
22:29:12 <ski> @type Data.ByteString.cons
22:29:13 <lambdabot> Word8 -> BSC.ByteString -> BSC.ByteString
22:30:42 <ybit> thanks ski
22:32:51 <Guest11260> ski: Actually your method works, and it is better. 1) there's no *_stub.c/h created. Second, now we have to use foreign.concurrent.newForeignPtr if "wrapper" is used.
22:33:08 <Guest11260> ski: you method makes things much simpler. :)
22:34:20 <Guest11260> ski: sorry, 1) is wrong. There's still *_stub.c/h created.
22:35:04 <dmwit> Is there a recommended hashing library?
22:35:41 <Guest11260> \help
22:35:51 <parcs`> dmwit: hashable?
22:36:35 <quicksilver> dmwit: http://hackage.haskell.org/packages/archive/hashable/1.1.2.2/doc/html/Data-Hashable.html
22:36:38 <quicksilver> I would have thought.
22:36:50 * hackagebot asn1-data 0.6.1.2 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.6.1.2 (VincentHanquez)
22:36:52 <dmwit> Cool, thanks.
22:36:52 <jessopher> @src concat
22:36:53 <lambdabot> concat = foldr (++) []
22:37:01 <quicksilver> it's had work done on it recently in hte context of the unordered containers package so it shoulud be current.
22:37:03 <dmwit> I asked because there seems to be about two dozen different choices.
22:37:17 <quicksilver> and tibbe cares about speed
22:40:30 <Guest11260> ski: ok, my fault. There's no any *_stub created. Previously forgot to remove the old code.
22:40:30 <jessopher> @src foldr
22:40:30 <lambdabot> foldr f z []     = z
22:40:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:40:55 <jessopher> :t foldr
22:40:56 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:41:58 <Guest11260> @src finalizerFree
22:41:58 <lambdabot> Source not found. stty: unknown mode: doofus
22:42:14 <Guest11260> :t finalizerFree
22:42:15 <lambdabot> Not in scope: `finalizerFree'
22:47:51 <MiggyX> okay, I've been at this for a couple of hours now so I think it's time to ask the experts :)  I've got a function that I need to accept either  Just ByteString or Nothing. So far everything I've tried has gone a bit awryâ€¦.
22:48:24 <MiggyX> I've been following through the learn yourself a haskell for great good ( just ordered the book as it happens ) but I'm obviously missing something well obvious :)
22:48:34 <sipa> can you paste your code somewhere?
22:49:57 <ski> Guest11260 : ok, that's nice
22:50:28 <penelope> hi! q: is there a standard form for: map' :: a -> [(a -> b)] -> [b]
22:50:35 <penelope> e.g
22:50:47 <penelope> map' x = foldr (\ f acc -> f x : acc) []
22:50:48 <penelope> ?
22:51:32 * ski wonders whether `foreign import ccall "blah.h my_&function" myFunctionPtr :: FunPtr (Blah -> IO Bleh)' is really supported, or whether it just happens to work
22:51:42 <MiggyX> ski:  https://pastebin.com/hBhuBPye    bear in mind I've been fiddling about with it for some time, this is just where I got to before I decided to get help :)
22:52:09 <ski> @type map . flip ($)
22:52:10 <lambdabot> forall a b. a -> [a -> b] -> [b]
22:52:33 <penelope> ah! thx!
22:52:36 <ski> @type flip flip  -- lambdabot specific
22:52:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
22:53:14 <jessopher> MiggyX: test :: Maybe Bytestring -> Bytestring
22:53:16 <ski> > map ($ 2) [(3 +),(3 *),(3 ^)]
22:53:16 <lambdabot>   [5,6,9]
22:53:21 <ski> > map ($ 2) [(3 +),(3 *),(3 ^)] :: Expr
22:53:22 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
22:53:22 <lambdabot>         against inferred ...
22:53:25 <ski> > map ($ 2) [(3 +),(3 *),(3 ^)] :: [Expr]
22:53:26 <lambdabot>   [3 + 2,3 * 2,3 * 3]
22:54:23 <jessopher> MiggyX: Just and Nothing are constructors for Maybe. and so Maybe has to be  part of the domain of the function
22:54:38 <ski> MiggyX : your type signature `test :: (Monad m) => m ByteString -> ByteString' promises to work for *any* monad `m', but your code only works for the `Maybe' monad
22:55:19 <MiggyX> jessopher: what should I update the pattern matching to? If I put Maybe ByteString , I get a mismatch on the number of arguments
22:55:30 <ski> MiggyX : when you write `test :: (Monad m) => m ByteString -> ByteString', with a type variable `m', it means the *caller* of this code will get to decide what `m' should be (here, which monad it should be) -- you have no control over that in this piece of code
22:55:59 <MiggyX> ski:  ah right
22:56:22 <ski> note that `test :: (Monad m) => m ByteString -> ByteString' is short for `test :: forall m. Monad m => m ByteString -> ByteString'
22:56:43 <ski> the `forall' here means that you promise this to work for all monads `m' the caller decides to use here
22:56:50 * hackagebot trace-function-call 0.1 - Easy lightweight tracing of function arguments and results for ad hoc debugging  http://hackage.haskell.org/package/trace-function-call-0.1 (DaveHinton)
22:57:31 <ski> but it seems your code actually wants this to be `test :: exists m. Monad m *> m ByteString -> ByteString', or possibly `test :: (forall m. Monad m => m ByteString) -> ByteString'
22:57:50 <penelope> ah. so I need flip $ map . flip ($)
22:57:51 <ski> in the former case, you claim that this works for *some* monad, but you won't tell *which* one
22:58:21 <ski> in the latter case, the *caller* promises that the argument will work for any monad the *callee* (i.e. `test') chooses to decide to use
22:58:28 <MiggyX> ski:  I want the function to accept either ByteString or Nothing   as I'm using it with Maybe.   I tried Maybe ByteString  but I'm not sure what I should use for the pattern matching to match Nothing or the contents of the Just x
22:58:48 <ski> MiggyX : but the simplest solution is to just fix the type to say it wants `Maybe' : `test :: Maybe ByteString -> ByteString'
22:59:22 <MiggyX> ski: That's actually what I started with - but then I couldn't figure out what patterns to use in the guard
22:59:24 <ski> MiggyX : the pattern-matching you have looks fine, if you're going to just work with `Maybe ByteString' here
22:59:46 <ski> if you still get some error, that must in that case be because of the code after the `='s
23:00:05 <MiggyX> hmm
23:00:09 <Enigmagic>            
23:00:13 <ski> MiggyX : i see no guard here, and as i said, the patterns look ok, i think
23:00:19 <MiggyX> okay let me go back and dig again - thanks a lot :)
23:00:25 <ski> @type flip $ map . flip ($)
23:00:26 <lambdabot> forall a b. [a -> b] -> a -> [b]
23:00:39 <ski> @type flip
23:00:39 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
23:00:46 <ski> > flip [(3 +),(3 *),(3 ^)] 2
23:00:48 <lambdabot>   [5,6,9]
23:00:54 <ski> > sequence [(3 +),(3 *),(3 ^)] 2
23:00:55 <lambdabot>   [5,6,9]
23:01:13 <ski> penelope : note that the above use of `flip' relies on the generalied `flip' which lambdabot uses
23:01:30 <ski> (the `sequence' otoh just relies on `instance Monad (rho ->)')
23:01:40 <augur> hey peeps
23:01:50 <augur> any good videos lately?
23:02:11 * jessopher 's brain is dead for haskell after a good 2-3 hours of agda
23:04:01 * ski . o O ( Jogeir Liljedahl - Tiny Tunes - <http://www.youtube.com/watch?v=NQmTTSgTld0> )
23:05:28 <penelope> agda is huh.
23:05:40 <augur> penelope: agda is awesome
23:06:14 <penelope> It makes my ears bleed.
23:06:24 <augur> penelope: why?
23:06:53 <penelope> I think because one is doing proofs with programming notation?
23:07:05 <sully> proofs are programs!
23:07:08 <sully> programs are proofs!
23:07:08 <jessopher> im doing programs
23:07:11 <penelope> Ye, yes.
23:07:13 <sully> delicious curry howard.
23:07:27 <penelope> But the mindset is a bit different.
23:07:28 <augur> penelope: dont think of it as proofs then! think of it as wonky data types
23:08:14 <penelope> Eh, I have two weeks off. If I get done my pent up projects, I'll get back at it.
23:08:24 <jessopher> haskell to agda feels about the same as ruby/c to haskell did
23:08:42 <penelope> Very true!
23:09:05 <augur> i think using good dependently typed practices is really a tricky thing
23:09:28 <augur> remembering to think about your properties as data types and trying to construct nice informative types
23:09:42 <augur> as opposed to just defaulting to Set / Top / Bot
23:10:12 <penelope> I heard someone suggest that sql was the ultimate depenent first order language.
23:11:25 * ski stares blankly
23:11:36 <jessopher> i think theres a video on youtube that explains dependent types in terms of SQL
23:11:50 * hackagebot smtLib 1.0.1 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.0.1 (IavorDiatchki)
23:12:12 <penelope> I just wish haskell had a nice latex to unicode emacs transcoder like agda.
23:12:31 <augur> thats a horrible analogy
23:12:39 <augur> the SQL thing
23:12:58 <jessopher> well im not that familiar with SQL, so i didnt bother watching it
23:13:10 <ski> penelope : you can enable the `Agda' input method used in `agda2-mode' in other buffers, as well. just run `set-input-method'
23:13:25 <penelope> Oh! My!
23:17:03 <rainman85> Any idea on how I can go about converting the return value of getPOSIXTime to Int?
23:17:28 <pikhq_> :t getPOSIXTime
23:17:28 <lambdabot> Not in scope: `getPOSIXTime'
23:17:36 <pikhq_> Beats me. :)
23:17:43 <augur> @where getPOSIXTime
23:17:43 <lambdabot> I know nothing about getposixtime.
23:17:46 <augur> :O
23:18:02 <rainman85> it's in Data.Time.Clock.POSIX
23:18:58 <rainman85> Or how I would get the epoch seconds in haskell in some other way?
23:19:51 <Sgeo> What's the type?
23:19:53 <penelope> posixSecondsToUTCTime?
23:20:39 <pikhq_> Looks like POSIXTime is an instance of Num.
23:20:40 <rainman85> I still need to convert that to an Int..
23:20:53 <pikhq_> Hmm.
23:20:59 <Sgeo> POSIXTime is a synonym for NominalDiffTime
23:21:10 <rainman85> yes
23:23:03 <augur> uh
23:23:09 <augur> if POSIXTime is an instance of Num
23:23:19 <augur> then shouldnt it had a toInteger method
23:24:04 <hpaste> rainman85 pasted â€œEpoch Secondsâ€ at http://hpaste.org/55484
23:24:31 <rainman85> this is what i have so far
23:24:34 <rainman85> and it doesnt work..
23:24:56 <penelope> Looks like DiffTime is actually an integer...
23:25:50 <pikhq_> augur: Not really; that's Integral
23:25:54 <penelope> that is : secondsToDiffTime = fromInteger
23:26:18 <augur> pikhq_: i couldve sworn that the def for the Num class included a toInteger method
23:26:19 <augur> hmm
23:26:20 <penelope> Which means it's changing the package
23:26:22 <augur> @where Data.Num
23:26:23 <lambdabot> I know nothing about data.num.
23:26:24 <penelope> but not the value
23:26:29 <augur> @where Data.Numeric
23:26:29 <lambdabot> I know nothing about data.numeric.
23:26:31 <augur> :|
23:26:33 <pikhq_> augur: fromInteger, but no toInteger
23:26:37 <augur> oh, fromInteger
23:26:37 <augur> ok
23:26:39 <pikhq_> augur: toInteger is in Integral.
23:27:15 <pikhq_> rainman85: Try truncate; POSIXTime is an instance of RealFrac, so that should work.
23:27:21 <rainman85> okay
23:27:42 <rainman85> instead of toInteger, truncate?
23:27:43 <pikhq_> And it *appears* it's defined such that that will get you a standard POSIX timestamp.
23:27:46 <pikhq_> Yeah.
23:27:48 <rainman85> It didnt compile..
23:28:04 <rainman85> No instance for (Monad ((->) POSIXTime))
23:28:13 <pikhq_> Oh, wait, I see the issue.
23:28:28 <pikhq_> rainman85: posixSecondsToUTCTime won't get you a POSIX timestamp.
23:28:38 <pikhq_> It will convert from UTCTime to POSIXTime.
23:28:46 <rainman85> I see
23:28:53 <rainman85> What would work then?
23:29:03 <rainman85> getPOSIXTime?
23:29:30 <penelope> but "subtracting" from the start of the epoch should get you the seconds in a DiffTime
23:29:53 <pikhq_> Try "seed <- getPOSIXTime >>= return . truncate", I think
23:30:19 <rainman85> it still needs to be converted to an integer
23:30:23 <rainman85> after truncating
23:30:44 <rainman85> seed = getPOSIXTime >>= return .toInteger . truncate
23:30:52 <pikhq_> rainman85: Actually, truncating should get you a value :: (Integral a).
23:30:53 <rainman85> this gives me  Couldn't match expected type `Int' with actual type `IO Integer
23:31:52 <rainman85> Leaving out the .toInteger function gives Couldn't match expected type `Int' with actual type `IO b0'
23:32:00 <pikhq_> Well, *yeah*. You can't do "let foo = IO-stuff-here" and expect to get anything but a value of IO Integer
23:32:13 <rainman85> okay
23:32:13 <pikhq_> There's a reason I said "seed <-"
23:32:15 <rainman85> :)
23:32:18 <pikhq_> You need to execute the IO action.
23:32:22 <pikhq_> :)
23:32:30 <Varan> Can someone point me to a good proof assistant too proof properties of haskell source code?
23:32:41 <pikhq_> "let n = 20 in seed <- ...; print ..."
23:34:27 <hpaste> rainman85 annotated â€œEpoch Secondsâ€ with â€œEpoch Seconds (annotation)â€ at http://hpaste.org/55484#a55485
23:34:35 <rainman85> still doesnt compile right...
23:34:50 <pikhq_> rainman85: Omit the toInteger
23:34:52 <rainman85> parse error on input `<-'
23:35:09 <pikhq_> Oh, *bleh*
23:35:14 <pikhq_> Add a "do"
23:35:20 <pikhq_> "let ... in do ..."
23:35:31 <pikhq_> Also, remove the toInteger
23:35:34 <pikhq_> :t toInteger
23:35:35 <lambdabot> forall a. (Integral a) => a -> Integer
23:35:39 <pikhq_> And you want Int.
23:35:46 <rainman85> it worked!
23:35:48 <rainman85> :)
23:35:49 <pikhq_> (hint: Int is Integral.)
23:35:59 <rainman85> Yes
23:36:33 <rainman85> Thank you
23:51:11 <penelope> hmm
23:51:23 <penelope> ghci is not happy with unicode: e.g.
23:51:48 <penelope> Î» = \
23:51:55 <penelope> makes in unhappy.
23:52:02 <penelope> it
23:54:01 <shachaf> penelope: Yes. Î» is a valid identifier in Haskell.
23:54:37 <shachaf> penelope: There are some editor extensions that translate Î»s to \s when writing(/reading) a Haskell file, though. I think Emacs is one of them. Maybe it can do the same thing in ghci.
23:56:44 <penelope> well, apparantly we can't bind a new name to lambda.
