00:00:08 <kmc> sgronblo2, yes, I don't think what I was talking about is "there's only one way to do it"
00:00:17 <Sgeo> sgronblo2, what language are you coming from?
00:00:23 <Cale> sgronblo2: Honestly, it wouldn't be so out of place to have a negated version, I think
00:00:24 <carpi> i have a statement like "takeWhile (<=(halfx x)) primes" and halfx x = truncate (sqrt x) and ghci pinpoints this part of teh code as the location of the error
00:00:24 <kmc> sgronblo2, it's the principle that, sometimes a function's whole code is a better name than any name you'd come up with
00:00:29 <kmc> (< 5) is a better name than lessThanFive
00:00:42 <Cale> except that the name 'filter' is too ambiguous in the way you described to admit a natural opposite
00:00:56 <Cale> any/all already kind of do that
00:00:58 <kmc> that's not a statement
00:01:04 <kmc> carpi, you're trying to sqrt an Integer, I bet
00:01:11 <Cale> and yeah, span/break
00:01:11 <carpi> kmc: true
00:01:14 <kmc> can't
00:01:21 <kmc> try:   sqrt (fromIntegral x)
00:01:29 <sgronblo2> Cale: thanks for the support! :)
00:01:59 <sgronblo2> Sgeo: well I guess I "come from" python/perl/php/java/ruby
00:02:01 <Cale> I don't think we need it all that much though, even if it wouldn't be out of place.
00:02:14 <kallisti> yeah I don't see a problem with another name for a negated filter, but I don't particularly see it as important to have either.
00:02:43 <kmc> carpi, do you understand type classes generally
00:02:47 <Sgeo> Ah. Ruby uses select/reject, not sure about anything in the other languages, although I should be more familiar with Python
00:02:59 <Cale> filter (not . p) is usually about as readable as you could hope for
00:03:09 <kallisti> Python has filter and list comprehensions which work like filter and map combined.
00:03:24 <Cale> filter and concatMap, hopefully
00:03:26 * Sgeo is embarrassed
00:03:27 <kallisti> perl has grep which works like filter. it's not an uncommon idiom.
00:03:34 <kallisti> Cale: no. just map.
00:03:34 <carpi> kmc: i think i do.. but i missed the reason for the error..because i don't understand ghci error messages that very well
00:03:36 <kmc> iirc python just has 'filter', but it's dogmatically unPythonic and you're supposed to use list comprehensions instead
00:03:46 <carpi> kmc: thanks for the suggestion.. now it works )
00:03:46 <kallisti> Cale: perl's map is actually a concatMap of sorts though.
00:03:51 <Sgeo> kmc, just like lambdas are unpythonic
00:03:53 <Sgeo> >:(
00:04:01 <Sgeo> At least it has them *cough* Java *cough*
00:04:22 <Sgeo> Well, not unpythonic, but usually ugly
00:04:28 <kmc> eh "lambda" is just syntax.  python supports nested first-class functions, they aren't anonymous but that's a minor inconvenience
00:04:33 <kmc> the bigger inconvenience is that scoping is fucked up
00:04:55 <Sgeo> Python was my primary language for a long time. How did I lose so much
00:06:29 <kmc> i used to think that guido van rossum just had weird opinions
00:06:46 <kmc> then i saw http://www.reddit.com/r/haskell/comments/lxoo0/guido_van_rossums_criterion_for_when_a_language/ and realized that no, he's factually misinformed about basic aspects of functional programming
00:06:59 <carpi> in ghci when i do something like "sqrt 3" it works even though '3' is not a value of a type that is an instance of Floating..how come?
00:07:14 <kmc> carpi, but it is a type that is an instance of Floating!
00:07:17 <Cale> kmc: hah, I thought you were just going to leave it at the first line there, and let us infer what you meant about him :)
00:07:25 <kmc> carpi, numeric literals in Haskell are overloaded
00:07:38 <kallisti> hmm, so my ghc has -ghci-script and -read-dot-ghci in its man page, but these options don't seem to work correctly.
00:07:39 <lambdabot> kallisti: You have 4 new messages. '/msg lambdabot @messages' to read them.
00:08:08 <kmc> carpi, «3» is actually syntactic sugar for «fromInteger (3 :: Integer)»
00:08:28 <kmc> :t fromInteger
00:08:29 <lambdabot> forall a. (Num a) => Integer -> a
00:08:42 <kmc> :t sqrt (fromInteger (3 :: Integer))
00:08:43 <lambdabot> forall a. (Floating a) => a
00:08:45 <carpi> so it basically makes the number more generic
00:08:55 <sgronblo2> How do you split up a list into smaller lists of size n?
00:08:55 <kmc> dunno what that means
00:08:59 <Sgeo> Apparently, Data.Enumerator.List.head came into existence in version 0.4.5
00:09:12 <Sgeo> What was used before then to get the next element from the stream?
00:09:16 <kmc> sgronblo2, splitEvery from this library: http://hackage.haskell.org/packages/archive/split/0.1.4.2/doc/html/Data-List-Split.html
00:09:56 <kallisti> carpi: that doesn't precisely describe what is happening, but that's an effect of it.
00:09:57 <sgronblo2> kmc: nice thanks
00:10:13 <Cale> Or if you don't want to incur an import, you can just write  map (take n) . takeWhile (not . null) . iterate (drop n)
00:11:00 <Cale> > let splitEvery n = map (take n) . takeWhile (not . null) . iterate (drop n) in splitEvery 5 [1..20]
00:11:01 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
00:11:28 <sgronblo2> nice
00:13:43 <carpi> thansk
00:15:59 <kmc> sgronblo2, yeah.  it really ought to be in the standard library, but isn't
00:17:18 <kmc> carpi, when you just write «3», that's as generic as a number gets.  «(Num a) => a».  when you apply sqrt, it gets a Floating constraint, but Floating is a subclass of Num anyway, so it's «(Floating a) => a»
00:17:52 <carpi> what are those arrow symbols? is that valid haskell syntax?
00:17:57 <kmc> yes
00:18:04 <kmc> wait, which?
00:18:07 <kmc> «these»?
00:18:09 <carpi> the <<3>>
00:18:10 <carpi> yea
00:18:21 <carpi> shite i dont have a key for it on my keyboard :(
00:18:25 <kmc> those are guillemets
00:18:29 <Sgeo> No, that's just separating code from chat
00:18:31 <kmc> quotation marks used in various natural languages
00:18:45 <kmc> i use them to delimit Haskell code, precisely because they *aren't* part of Haskell syntax :)
00:19:17 <carpi> how may i type them myself?
00:19:18 <kmc> if you're running X and have a compose key, you can type Compose < <
00:19:38 <kmc> compose key is the best
00:20:00 <carpi> compose on the command line or ghci..? command line yea?
00:20:18 <kmc> what?
00:20:22 <carpi> oh wait.. you're talking about a key.. my bad
00:20:27 * hackagebot xournal-render 0.3.0.0 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.3.0.0 (IanWooKim)
00:20:29 * hackagebot hxournal 0.6.0.1 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.0.1 (IanWooKim)
00:20:30 <kmc> http://en.wikipedia.org/wiki/Compose_key
00:20:37 <Saizan> athey are valid operator names though :)
00:20:46 <kmc> don't believe so
00:20:48 <kmc> > generalCategory '«'
00:20:49 <lambdabot>   InitialQuote
00:20:58 <kmc> > let («) = (+) in 2 « 3
00:20:59 <lambdabot>   <no location info>: lexical error at character '\171'
00:21:19 <Saizan> ah, there must be some Punctuation that looks the same
00:21:33 <kmc> on debian you can type «Compose C C C P» to get ☭
00:22:02 <kmc> also «Compose < 3» for ♥
00:25:44 <sgronblo2> kmc: so how do I install this package?
00:26:27 <carpi> my computer doesn't have a compose key (
00:26:37 <kmc> sgronblo2, cabal install split
00:26:47 <kmc> carpi, it's easy to set one up, in X
00:26:51 <kmc> if you have a key you're not using
00:27:19 <carpi> ⇧
00:27:34 <carpi> okay something happened..
00:27:42 <sgronblo2> kmc: ah, thanks
00:28:27 <sgronblo2> is there anything like ruby's bundler for haskell?
00:30:37 <kmc> i don't know anything about ruby's bundler
00:32:06 <sgronblo2> it allows you to lock the versions of the gems you are using in case you have different projects using different versions
00:34:26 <kmc> cabal-dev does something like that
00:34:31 <kmc> http://hackage.haskell.org/package/cabal-dev
00:35:07 <Sgeo> Do other languages have things like enumerator?
00:35:51 <kmc> other languages have much simpler ways to do incremental IO
00:38:11 <Sgeo> I ... think, the thing that happened in my C# project may have been that I was using an event-based framework
00:39:20 * Sgeo vaguely wonders what the Haskell-y way to deal with that is
00:39:46 <kmc> event-based, as in inversion of control?
00:39:52 <Sgeo> Yeah
00:39:56 <kmc> you register callbacks and then give up control to a main looop?
00:39:56 <Sgeo> I guess
00:39:59 <Sgeo> Yes
00:40:13 <kmc> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html is a cool blog post on this topic
00:40:34 <Sgeo> Hmm, thanks
00:40:47 <kmc> not sure it's relevant but... it's cool :)
00:40:54 <Sgeo> Didn't look yet, but would something similar work in C#? (I have no idea what the article is doing)
00:41:49 <Sgeo> " And that includes languages like Python that support linear continuations in the form of generators."
00:42:03 <Sgeo> C# has the same facility that Python has for generators. Well, almost, I think
00:42:18 <kmc> yeah, i think 'yield' is enough to do this
00:42:53 <kmc> this post is easier to understand if you've used OpenGL / GLUT
00:43:00 <Sgeo> I have not.
00:43:37 <kmc> so, you might wish you could describe an animation as straight-line imperative code
00:43:42 <kmc> "draw this, then draw that, then draw that"
00:43:53 <kmc> but GLUT is callback-based, so you can't
00:44:06 <kmc> you register an "idle callback" which gets invoked every so often, and can update the animation
00:44:14 <kmc> also a display callback which does the drawing, once per frame
00:44:48 <Sgeo> Well, my issue in my C# program was a subportion that needed that reinversion, not the program as a whole
00:45:12 <kmc> the trick from the article is that you can define a monad which looks like "draw this, then draw that"
00:45:30 <kmc> but actually at each step it returns to the mainloop, and registers the remaining program as the next idle callback
00:46:46 <kmc> and that monad is ContT () IO
00:47:20 * Sgeo wants to use enumerator for his Active World binding
00:47:24 <Sgeo> *Active Worlds
00:47:36 <Sgeo> I think I see how to write Enumerators now
00:47:58 <Sgeo> Hmm, would it be ok to use threads for reinversion of control?
00:48:06 <kallisti> "You can write reduce() in a few lines of Python. Not so in a functional language."
00:48:09 <kallisti> what
00:48:29 <kmc> yeah...
00:48:56 <Sgeo> Make ALL the things enumerators!
00:49:15 * Sgeo is currently slightly on the obsessed side
00:49:26 <copumpkin> kallisti: oh I love that
00:49:45 <kmc> it turns out everyone defines "functional language" in whatever way supports the point they're trying to make
00:49:53 <kmc> including #haskell
00:50:08 <copumpkin> no no, my definition is objective
00:50:10 <Sgeo> A functional language is any language with functions!
00:50:12 <copumpkin> ayn rand approved it
00:50:43 <kmc> "yeah, a functional language needs to have first class functions, obviously... but it should also have static types, so you know how those functions combine, and laziness, and probably it should use {- -} for multi-line comment syntax"
00:50:52 <kallisti> lol
00:51:04 <silver> nice
00:51:19 <Peaker> You can also forkIO and do all the GLUT stuff in a new IO thread, so other threads have whatever mainloops you want
00:51:36 <kmc> even the _Gentle Introduction to Haskell_ dismisses ML and Scheme as "almost-functional"
00:52:02 <Sgeo> The Gentle Introduction to Haskell also calls itself gentle...
00:52:25 <kmc> yeah well, you have to understand the audience in order to judge any work...
00:52:42 <silver> but thing about reduce is straightforward lie
00:52:43 <kallisti> I make a distinction between "purely functional", "functional", and "functional style".
00:52:52 <silver> wtf he was thinking writing this?
00:53:01 <kmc> silver, people are wrong, on the internet
00:53:05 <Peaker> (or in the old IO thread, don't recall if it wants to be the main thread)
00:53:07 <copumpkin> some people more than others
00:53:12 <copumpkin> guido more than anybody
00:53:13 <kmc> you can go to reddit /r/programming and find 10 people like this every day
00:53:19 <kmc> you can correct them and the next day there will be 10 more
00:53:30 <kmc> it's like one of those video games where the enemies just keep spawning, faster and faster
00:53:37 <silver> heh
00:53:43 <kmc> there is no way to win
00:53:49 <Sgeo> Is it safe to say that Haskell is purely functional but not always written in functional style?
00:53:55 <kmc> it's not safe
00:54:06 <kmc> it's dangerous, because it will provoke a ton of completely pointless bickering
00:54:18 <Sgeo> unsafeArgueOnTheInternet
00:54:40 <copumpkin> unsafeArgueOnTheInternet :: IO a -> IO b
00:54:46 <kmc> unsafe at any speed
00:54:54 <kmc> damn that would be a good name for a band
00:55:01 <kallisti> so, using my nomenclature, there are purely functional languages such as Haskell, functional languages which would include Scheme, and "languages that allow you to write in a functional style" which would be like perl.
00:56:21 <kmc> the interesting thing about Haskell isn't that the language is "purely functional"
00:56:30 <kmc> that's a very specific technical thing, and there are loopholes anyway
00:56:46 <kmc> the interesting thing is that the standard libraries and the community take pure functions seriously
00:57:01 <kmc> not saying "this is the only way to write code ever"
00:57:07 <kmc> but just like... providing immutable collections at all
00:57:44 <kmc> the idea that you should think a little before you add state into the mix
00:57:57 <kmc> it's not a language thing, it's a matter of community norms
00:59:20 <Sgeo> kmc, my April Fools 2012 project has kind of the aim of demonstrating that, by providing a highly imperative prelude and tutorial
00:59:26 <kmc> haha
01:00:01 <kmc> that kind of dovetails with my april fools project
01:00:38 <Sgeo> Guess I shouldn't ask?
01:00:54 <kmc> which is to rename Haskell and claim it's something new
01:01:03 <Sgeo> hehe
01:01:44 <kmc> "Blub combines the theoretical beauty of Haskell with practical, real-world features like lightweight concurrency, scalable multithreaded IO, a C function interface, Unicode support, and a large base of libraries"
01:02:15 <Sgeo> :D
01:02:31 <kmc> i think this is why PLT Scheme renamed to Racket
01:02:35 <kmc> maybe a little bit of why
01:02:52 <kmc> everyone knows Scheme as "that useless language they made us learn in first year"
01:03:07 <kmc> but if you change the name now it's a hip new dynamic language
01:05:25 * kallisti is still planning his Haskell/Perl hybrid language.
01:05:40 <kmc> Clojure has almost the same "community norm" that I was just talking about, but they're better at marketing it to the mainstream of programmers
01:06:45 <kmc> (which isn't necessarily the goal with Haskell, though)
01:14:42 <Peaker> kmc: "Denotational programming" could be a better term
01:14:42 <Peaker> that way it is more about programs than programming languages
01:16:28 <Peaker> (about the "functional" discussion)
01:16:29 <Sgeo> :( SWIG doesn't support Haskell
01:17:05 <kmc> yeah
01:17:35 <kmc> i like "denotational" and i like "declarative"
01:18:58 <augur> :t Mu
01:19:02 <lambdabot> Not in scope: data constructor `Mu'
01:19:05 <augur> :t Fix
01:19:05 <lambdabot> Not in scope: data constructor `Fix'
01:19:08 <augur> :t Data
01:19:09 <lambdabot> Not in scope: data constructor `Data'
01:19:13 <Sgeo> ...I apparently called users of my "library" lazy bums at one point
01:19:17 <kallisti> oh man these record syntax redesigns are a mess..
01:19:31 <Sgeo> I was too lazy to attempt to implement a function that returns the callback that the user set previously
01:19:33 <kallisti> particularly OverloadedRecordFields
01:23:22 <kallisti> oh hey. Check out this cat program I made. I think it's particlarly nice looking: http://sprunge.us/hRMf
01:29:06 <WarzoneCommand> hmm question: Is there an HxT pickler that allows me to pickle a Data.Map to a bunch of attributes?
01:29:22 <WarzoneCommand> i.e. with the key as attributename and the value as the attribute value
01:36:46 <kallisti> WarzoneCommand: I don't know, but you could try passing the type of the function you want to @hoogle and it might be able to find it.
01:36:50 <kallisti> @hoogle a -> a
01:36:51 <lambdabot> Prelude id :: a -> a
01:36:51 <lambdabot> Data.Function id :: a -> a
01:36:51 <lambdabot> GHC.Exts breakpoint :: a -> a
01:37:59 <kallisti> WarzoneCommand: hmmm and http://www.haskell.org/haskellwiki/HXT/Conversion_of_Haskell_data_from/to_XML
01:43:59 <WarzoneCommand> kallisti: I know that page
01:44:07 <WarzoneCommand> it is actually very helpfull
01:44:26 <WarzoneCommand> but from what I can tell the only picklers for attributes require you to specify the attribute name
01:52:55 <kallisti> WarzoneCommand: no it seems to me that with xpPair and xpAttr you can just plug in any key value.
01:58:01 <kallisti> WarzoneCommand: it looks to me like you could use a combination of xpWrap and xpList
01:59:01 <WarzoneCommand> xpAttr has type : String -> PU a -> PU a
01:59:06 <WarzoneCommand> that string is the attribute name
01:59:21 <WarzoneCommand> shouldn't that be something of type PU again as well ?
01:59:51 <WarzoneCommand> because I think what you are proposing works for pickling the values
01:59:54 <WarzoneCommand> but not for unpickling them
02:08:48 <WarzoneCommand> on second hand, I don't think you can even express that
02:09:10 <WarzoneCommand> or at least, not just with xpPair and xpAttr
02:14:12 <carpi> is it true that there is no one element tuple?
02:15:11 <kallisti> indeed.
02:15:36 <kallisti> carpi: a one element tuple is completely isomorphic to the inner type itself, so there's no point.
02:16:18 <carpi> isomorphic meaning similar/same?
02:16:27 <kallisti> the main benefit of a one-field constructor is to be able to write newtype wrappers the redefine typeclass instances.
02:16:38 <kallisti> carpi: yes
02:16:46 <kallisti> s/the/that/
02:16:54 <kmc> it's not isomorphic, in Haskell
02:16:59 <kmc> it would have an extra ⊥
02:17:19 <kmc> http://hackage.haskell.org/packages/archive/OneTuple/0.2.1/doc/html/Data-Tuple-OneTuple.html
02:17:25 <carpi> that sybmol means bottom?
02:17:31 <kmc> yeah
02:17:37 <kmc> written in ASCII as _|_
02:17:38 <kallisti> kmc: well it would have a bottom and (bottom), but yes I didn't consider that.
02:17:59 <kmc> ⊥ is distinguishable from (OneTuple ⊥)
02:18:01 <carpi> so it will have an extra pattern matching case which is unnecessary
02:18:07 <kmc> just like ⊥ is distinguishable from (⊥,⊥)
02:18:17 <kmc> carpi, hmm?
02:18:18 <kallisti> kmc: right
02:18:53 <kmc> and redefining typeclass instances is not the main benefit of newtype
02:19:16 <kallisti> kmc: it's not? that's what I typically see it used for.
02:19:20 <kmc> an equal if not greater benefit is the ability to keep distinct types distinct, even if they happen to have the same representation
02:19:37 <kmc> newtype Gold = Gold Int;  newtype HitPoints = HitPoints Int
02:19:47 <kmc> now you won't accidentally add someone's gold to their hitpoints
02:20:12 <aristid> kmc: why if you buy medic packs you can convert gold to hitpoints
02:20:12 <carpi> not as confused as before but still maybe a little confused. however thanks for the clarification )
02:20:25 <kmc> it's common to have many things which are represented by Int or String, but are logically separate types
02:20:53 <aristid> you could use String for EVERYTHING, in fact. tcl proves that.
02:20:58 <kallisti> kmc: ...eh
02:21:10 <kmc> eh?
02:21:12 <kallisti> there are certainly some applications where that is an advantage.
02:21:32 <kallisti> and in others it would be an inconvenience.
02:21:46 <kmc> yeah
02:21:55 <kmc> as with nearly any feature
02:22:16 <WarzoneCommand> err
02:22:20 <SailorReality> http://www.youtube.com/watch?v=fqyjOc3EpT4&feature=related
02:22:35 <WarzoneCommand> why is it that my module compiles/typechecks perfectly fine
02:22:46 <WarzoneCommand> but when I enable the TypeFamilies extention it no longer does
02:23:01 <kmc> kallisti, in general I think types in a high-level language should be based on the problem domain, and not on the detail of how you want the machine to represent them
02:23:43 <kmc> WarzoneCommand, in recent GHC, some extensions like TypeFamilies enable MonoLocalBinds
02:23:59 <kmc> which means it will not infer a polymorphic type for a local variable
02:24:11 <kmc> the direct fix is to put a type signature on that variable
02:29:03 <kallisti> kmc: I think basing types on abstract behavior is a good idea, which is what most Haskell code does. Basing it strictly on problem domain requires you to do unecessary conversions when two types, otherwise with the same behavior, and used for different problems. The typesafety could be beneficial though.
02:30:03 <kmc> you call them "unnecessary", but i could say that read :: String -> Int is an "unnecessary conversion"
02:30:14 <kmc> after all, perl does fine with   "3 foo bar" + 4
02:30:19 <kmc> fsvo "fine"
02:30:52 <kallisti> indeed it does.
02:31:29 <kallisti> but in Haskell strings and integers have wildly different behavioral properties, and so a conversion is quite necessary.
02:33:03 <kmc> but you also gain safety that way
02:33:09 <SailorReality> this video is about haskell programmers
02:33:25 <SailorReality> http://www.youtube.com/watch?v=fqyjOc3EpT4&feature=related
02:33:42 <kmc> but you said that too
02:35:00 <kmc> anyway I think this is an important use of single-field data (preferably newtype)
02:35:10 <kmc> and i try to do it whenever it does not seem especially cumbersome
02:35:25 <kallisti> yes it's basically a superset of the overriding instances case.
02:35:38 <kmc> the exact cost/benefit ratio depends on the program
02:36:23 <kmc> for example, if you're writing a compiler, you have to handle lots of different kinds of names... files, functions, global variables, local variables, types, modules, whatever
02:36:50 <kmc> you might use String for all of them, but it's a serious benefit to prevent mixing them up
02:37:59 <kmc> another (related) use is creating abstract types
02:38:45 <kmc> i have a module providing an imperative Haskell API on top of a C library
02:38:58 <kmc> an "instance" of the library is implemented by an MVar holding a record with a bunch of Ptrs and other crap
02:39:03 <kmc> but i don't want users to see any of that
02:39:22 <kmc> so I wrap the MVar in a newtype and do not export its data constructor
02:40:30 <kallisti> I think in that case a similar effect is achieved with type.
02:40:38 <kmc> no it isn't
02:41:18 <kmc> 'type' is just a synonym; the user can access that MVar and whatever else
02:42:11 <kmc> you can't use it to hide irrelevant details, and you can't use it to enforce invariants
02:42:14 <kallisti> right, but the idea is to hide the ugly type and give it a more meaningful name. But yes, obviously type and newtype do different things.
02:42:42 <kmc> it's not really hidden
02:42:53 <kmc> the user can easily screw up and touch the internals of that value by accident
02:42:53 <kallisti> not really no.
02:43:04 <kallisti> (to the first statement)
02:44:18 <kmc> so it's not a similar effect to 'type'
02:44:47 <kmc> 'type' accomplishes some of the same goals, but fails at others
02:44:54 <kallisti> correct
02:45:02 <kallisti> these same ones are the ones that make it similar
02:45:17 <kallisti> incredible, right?
02:46:29 <kmc> it's not similar from my perspective, because those are not the goals i care about :)
02:46:37 <kmc> (not in this case, and not in many other cases like it)
02:46:40 <kallisti> using type is taking the stance that it's okay for programmers to mess around with the internals while not being cognitively over-burdened by long type names when they wish to use the type abstractly.
02:46:50 <kallisti> newtype + hiding construct is basically creating an opaque type.
02:47:05 <kmc> yeah
02:47:32 <kmc> but it's not just allowing them to mess with internals, it's enabling them to make more mistakes
02:47:38 <kmc> messing with internals by accident
02:48:14 <kmc> you can separate the two better by having an 'Internals' module
02:48:21 <kmc> which you import if you want access to internals
02:48:28 <kmc> i like this design, but it's more work to implement
02:48:29 <kallisti> sounds good
02:50:48 <sgronblo2> Umm, so how do I print all the string in a list?
02:51:02 <kmc> in what format
02:51:20 <sgronblo2> how do you mean?
02:51:54 <kmc> never mind
02:52:08 <kmc> just try 'print xs',  'mapM_ print xs', and 'mapM_ putStrLn xs'
02:52:13 <kmc> and decide which one you like best
02:52:49 <ChemisTree> Anyone home?
02:52:53 <kmc> yep
02:52:56 <ChemisTree> Word
02:53:00 <Peaker> ChemisTree: I'm on the train, particularly
02:53:07 <ChemisTree> hah
02:53:25 <sgronblo2> kmc: thanks, the third one was the one I wanted
02:53:29 <ChemisTree> well Merry CHRISTmas to you all
02:53:45 <ChemisTree> I prefer to celebrate the solstice, so
02:53:52 <ChemisTree> happy solstice in particular
02:53:54 <kmc> and happy THORsday to you
02:53:56 <sgronblo2> I seemed to remember from learn you a haskell that that weird mapM_ function was involved
02:54:38 <kmc> kallisti, 'type' is better in some cases; I'm not disputing that.  but in the other cases you often want single-constructor data/newtype, and that's at least as important a use case as defining new typeclass instances
02:54:59 <kmc> in the context of IO you have
02:55:05 <kmc> mapM :: (a -> IO b) -> [a] -> IO [b]
02:55:18 <kmc> mapM_ :: (a -> IO b) -> [a] -> IO ()
02:55:29 <kmc> each one executes an IO action for every element of a list
02:55:41 <kmc> mapM accumulates the results into a list; mapM_ discards the results
02:56:05 <kmc> the result of putStrLn is a useless (), so you might as well discard them
02:56:35 <Peaker> sgronblo2: What's weird about mapM_?
02:56:39 <ChemisTree> What is an IO action?
02:57:23 <kmc> ChemisTree, http://www.haskell.org/haskellwiki/Introduction_to_IO
02:57:32 <Peaker> I wish GHC was smart enough to specialize functions to versions that keep/discard their result -- and if the result is unused, use the one that doesn't accumulate it in the first place. So we wouldn't need sequence_, mapM_, etc
02:57:41 <ChemisTree> better question, how can I ask GHCI to tell me more about IO?
02:57:57 <kmc> what do you want GHCi to tell you about IO
02:58:01 <ChemisTree> :? IO    doesnt do it
02:58:15 <ChemisTree> :t  IO   says nothing
02:58:16 <lambdabot> Not in scope: data constructor `IO'
02:58:16 <lambdabot> Not in scope: `says'
02:58:16 <lambdabot> Not in scope: `nothing'
02:58:21 <sgronblo2> Peaker: Just calling it weird, because I'm still a noob at haskell
02:58:27 <kmc> right, because it's a type... types don't have types
02:58:31 <kmc> if you type ":i IO" it will tell you about GHC's implementation of IO, which is... massively confusing and irrelevant
02:58:44 <kmc> it will also tell you that IO is an instance of Monad and Functor, which is useful information
02:59:02 <ChemisTree> ah, thanks
02:59:19 <Peaker> sgronblo2: Do you find the "map" or "sequence" functions weird?
02:59:20 <kmc> what IO actions are, conceptually, has nothing to do with how GHC implements them
03:00:24 <ChemisTree> and how GHC describes actions,  has very little significance to me
03:00:36 <ChemisTree> Haskell is new to me, but I like it nonetheless
03:00:45 <ChemisTree> any of you know about Haskore?
03:01:24 <kallisti> yes I'm familiar with it.
03:01:25 <sgronblo2> Peaker: not map, but I haven't used sequence yet
03:01:34 <kmc> sequence :: [IO a] -> IO [a]
03:01:48 <kmc> mapM f = sequence . map f
03:02:34 <ChemisTree> have you programmed Haskore?
03:03:10 <Sgeo> Hmm
03:03:24 <Sgeo> I have .. things that almost resemble transistors, but aren't.
03:03:42 <ChemisTree> is that in reply to
03:03:45 <ChemisTree> haskore?
03:03:48 <Sgeo> No
03:03:52 <ChemisTree> good
03:03:53 <kmc> are they silicon-controlled rectifiers?
03:03:55 <sgronblo2> kmc: ok that doesn't seem so bad, is it when you evaluate the actions that stuff actually gets printed to the display?
03:04:03 <kmc> sgronblo2, s/evaluate/execute/
03:04:10 <Sgeo> I know that they're TC (well, not TC, but the equivalent thought restricted to finite memory), because I implemented NAND
03:04:11 <kmc> evaluation and execution are distinct; that's the whole point
03:04:22 <Sgeo> So, I'm thinking of making a DSL to easily combine them
03:04:30 <kmc> evaluation is what happens when you apply functions to arguments and demand the result
03:04:30 <Sgeo> I do need a source of unique identifiers
03:04:50 <Sgeo> Should I make this a monad, or just make .&&. operations etc?
03:05:01 <kmc> this never causes IO.  it doesn't matter whether the function returns an IO action or not
03:05:19 <Sgeo> sgronblo2, forget about GHCi for a minute
03:05:25 <kmc> the only IO action which actually gets executed is the one named 'main', or something you type at the ghci prompt
03:05:27 <sgronblo2> so first the expression print something is evaluated to yield something that can be executed to actually print something?
03:05:32 <kmc> yes
03:05:53 <sgronblo2> and does the evaluated expression yield the io action?
03:06:00 <kmc> Haskell programs are functional programs which compute and then execute imperative programs
03:06:06 <kmc> yes
03:06:27 <kmc> (print "foo") evaluates to an IO expression, the way (2+2) evaluates to an integer 4
03:06:37 <kmc> both are pure, first-class values
03:06:48 <sgronblo2> IO expression? that's different from an IO action?
03:06:53 <kmc> sorry, I meant IO action
03:09:00 <kmc> IO actions are abstract data; the constructor(s) are not exported, so you can't look at what's really inside
03:09:15 <kmc> and they don't implement Eq or Show type classes, so you can't compare them with (==) or print them
03:09:20 <kmc> but they are values nonetheless
03:09:43 <ChemisTree> When 'Tab' is pressed in GHC, it is list possible fuctions?                                                 EX:  "su "   Tab,   sum shows up
03:10:07 <kmc> you can create 'primitive' IO actions using functions like putStrLn, getChar, return
03:10:11 <sgronblo2> ah thats one of the things that i had been wondering about the io actions. if it was possible to compare them.
03:10:17 <kmc> and you can glue them together using the (>>=) operator (for which "do" is syntactic sugar)
03:10:51 <kmc> and since they're values, you can pass them to functions, return them from functions, store them in lists, etc.
03:11:07 <kmc> so you can use ordinary functions to implement whatever loops or control flow operators you like
03:11:49 <ChemisTree> Why does the tutorial tell me "sort" is a function, but GHC doesnt recognize?
03:11:58 <sgronblo2> btw, is modifying the file system an io action?
03:11:58 <Sgeo> @hoogle sort
03:11:58 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
03:11:58 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:11:58 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
03:12:01 <kmc> "the tutorial"? which?
03:12:05 <Peaker> sgronblo2: sequence takes a bunch of (m a) values and composes them in order to yield one big value, that has all of the results: m [a]
03:12:08 <Sgeo> ChemisTree, you might need to import Data.List
03:12:10 <kmc> you'll have to import Data.List.  type ":m + Data.List"
03:12:31 <kmc> sgronblo2, yes, there are IO actions for modifying the filesystem
03:12:46 <kmc> see System.IO, System.Directory, etc.
03:12:49 <Peaker> ignore me, I was not paying attention :)
03:13:12 <ChemisTree> THANKS
03:13:20 <Sgeo> There's even an IO action for launching missiles
03:13:35 <Sgeo> (It doesn't actually launch missiles. But if Haskell were used for such stuff, there would be)
03:13:47 <Sgeo> @hoogle launchMissiles
03:13:48 <lambdabot> No results found
03:13:50 <Sgeo> Bluh
03:14:02 <ChemisTree> Did I have to import because I had a file open with little content?
03:14:06 <kmc> no
03:14:31 <kmc> you had to import because 'sort' is defined in a library which is not imported by default
03:14:31 <Sgeo> ChemisTree, you had to import because sort is defined in Data.List
03:14:43 <kmc> what tutorial are you following? and what programming experience do you have?
03:14:48 <Sgeo> The only functions you have automatically, without importing, are those in Prelude
03:15:03 <Sgeo> launchMissiles: http://hackage.haskell.org/packages/archive/acme-missiles/0.2.1/doc/html/Acme-Missiles.html
03:15:06 <ChemisTree> why would the tutorial teach a function that is not loaded by default?
03:15:18 <Sgeo> "Cause serious international side effects."
03:15:20 <kmc> "the tutorial"
03:15:23 <kmc> which tutorial?
03:15:33 <ChemisTree> In haskel.org
03:15:37 <sgronblo2> kmc: so is it then possible to assert that a function modifies a filesystem correctly by somehow inspecting the returned filesystem IO actions (if as you said you can't compare the IO actions directly)?
03:15:42 <Sgeo> ChemisTree, can you link to where you are right now?
03:15:49 <ChemisTree> http://tryhaskell.org/#6
03:15:55 <ChemisTree> very basic.
03:15:56 <ChemisTree> haha
03:15:57 <kmc> sgronblo2, not with GHC's implementation of IO.  there's essentially no way to inspect IO actions
03:16:21 <kmc> ChemisTree, well, it's loaded in tryhaskell's own interpreter
03:16:30 <ChemisTree> I am also walking through "Learn You a Haskell for Great Good"
03:16:36 <_Mikey> can you add multiple class constraints to an instance?
03:16:39 <kmc> yes, that's a more comprehensive introduction
03:16:41 <kmc> _Mikey, yes
03:16:45 <_Mikey> ChemisTree, awesome where are you at?
03:16:47 <Sgeo> LYAH is preferable to tryhaskell, I think
03:16:52 <kmc> instance (Show a, Show b) => Show (a, b)
03:17:01 <ChemisTree> Washington
03:17:04 <Sgeo> But both can't hurt
03:17:07 <kmc> Sgeo, they are totally different, with different goals
03:17:14 <_Mikey> ahh cool cheers kmc!
03:17:24 <kmc> tryhaskell is a low-friction way to get a taste of what you can do
03:17:39 <kmc> as such it glosses over many things, like importing sort from Data.List
03:17:54 <ChemisTree> kmc, is this comment highlighted for you>
03:17:55 <ChemisTree> ?
03:17:57 <kmc> yes
03:18:00 <sgronblo2> kmc: ah that's too bad. it was something I thought would be useful and was wondering if perhaps haskell's IO actions allowed you to do it easily.
03:18:01 <ChemisTree> word
03:18:18 <kmc> sgronblo2, yeah, it would be useful.  you could maybe make an alternative implementation which allows it
03:18:32 <Sgeo> I guess you could make your own IO-like thing that requires a key to the filesystem to do filesystem stuff
03:18:33 <kmc> sgronblo2, unfortunately it's pretty hard because you have to support this operator:   (>>=) :: IO a -> (a -> IO b) -> IO b
03:18:56 * Sgeo wonders if anyone's done object-based capabilities in Haskell before
03:19:06 <kmc> meaning, an IO action can consist of "do this action, then pass the result to this function, and do whatever that function returns"
03:19:11 <kmc> the function is in a sense part of the composite IO action
03:19:15 <kmc> and you can't inspect functions very well
03:19:36 <sgronblo2> yeah, the way I imagined it would be implemented is probably too trivial to work for any case
03:19:39 <ChemisTree> How can I get to this back 'chat room' another time, without having to do this tutorial again  http://tryhaskell.org/#6
03:19:42 <Sgeo> Haskell seems more suited for it, possibly, than other languages that weren't designed with object-based capibilties in mind
03:20:02 <kmc> sgronblo2, stuff you can do with IO actions includes:  actual console/file/network IO;  accessing mutable variables;  random numbers;  creating additional threads of execution (which are scheduled nondeterministically)
03:20:04 <Sgeo> ChemisTree, http://webchat.freenode.net channel #haskell
03:20:16 <ChemisTree> Sgeo, thanks
03:20:20 <Sgeo> You're welcome
03:20:37 <sgronblo2> but I thought that instead of having a method directly modify a filesystem and have to use some sort of fake filesystem to see that it does the right it would instead return a collection of filesystem that you would have some sort of filesystemactionexecutor perform.
03:20:42 <Sgeo> Or, if you forget, tryhaskell.org does not require you to do the tutorial to get to chat
03:20:53 <Sgeo> Just typing in chat works. But webchat.freenode.net is better.
03:20:56 <ChemisTree> is this channel "#haskell"?
03:20:59 <kmc> yes
03:21:08 <Sgeo> ChemisTree, without quotes
03:21:18 <ChemisTree> right...
03:21:20 <alistra> i can't get -XDisambiguateRecordFields to work, anyone had any experience? even the ghc manual example doesn't work
03:21:29 <ChemisTree> and without the "?"
03:21:36 <Sgeo> ChemisTree, sorry
03:21:40 <ChemisTree> haha
03:21:51 <ChemisTree> your welcome?
03:22:05 <ChemisTree> Foldplop? anyone
03:22:08 <Sgeo> ...I lost something. I am now confused
03:22:13 <Sgeo> ChemisTree, hmm?
03:22:29 <ChemisTree> sgeo, music. Foldplop
03:22:42 <ChemisTree> haskell programmed
03:22:46 <ChemisTree> some of it
03:22:55 <Sgeo> Ah, cool
03:23:13 <ChemisTree> really good electronic music, very original and he needs more listeners
03:23:32 <ChemisTree> http://www.foldplop.com/
03:27:06 <ChemisTree> First time around Haskell kicked my ass! Now I am back to embrace it.
03:27:44 <drwho> I am stuck on monads
03:27:46 <ChemisTree> I still have massive troubles with it. Very different way of thinking. so ABSTRACT
03:27:56 <drwho> I read it and it blew my mind but I am getting use to it now
03:28:24 <ChemisTree> drwho, what do you mean you "read it"?
03:29:23 <drwho> read about it sorry
03:30:02 <_Mikey> me too drwho
03:30:21 <kmc> what did you read
03:30:46 <kmc> there are many articles written about monads which are worse than useless
03:30:47 <_Mikey> I didn't read anything
03:30:54 <_Mikey> well
03:30:58 <_Mikey> I've read everything
03:31:03 <_Mikey> but it feels like I've read nothing
03:31:13 <ChemisTree> kmc, what you use Haskell for?
03:31:14 <drwho> kmc: the haskell wiki
03:32:50 <kmc> if you're reading stuff about monads, it's worth reading this first: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
03:33:17 <kmc> it's actually a very general point about how people learn, but especially relevant to monads
03:33:36 <drwho> thanks kmc
03:34:09 <_Mikey> I read the burrito thing about monads
03:34:19 <_Mikey> I heard it was a bad move. ;/
03:36:00 <kmc> mostly in programming, things are difficult because they are too complex, too many parts
03:36:16 <kmc> 'monad' is difficult because it's too simple, and that's new for a lot of people
03:36:40 <_Mikey> and its quite "meta" apparently
03:36:45 <alistra> they're like a space suit
03:36:54 <kmc> _Mikey, what does that mean
03:37:03 <_Mikey> its what I've heard
03:37:14 <_Mikey> they're an abstraction, of an abstraction
03:37:25 <alistra> my first monad problem was
03:37:27 <kmc> all of CS is that
03:37:41 <alistra> why (>>=) :: ma -> (a -> m b) -> mb
03:37:42 <_Mikey> its like you have maps and more general functors and more general monoids and more general monads.
03:37:47 <_Mikey> but I maybe wrong.
03:37:50 <alistra> and not :: ma -> (a -> b) -> m b
03:37:52 <ChemisTree> is there a way to ":t   monad", but other than type, because monad is not a type. I want to do this because I do not know what gonad.. I mean monad is
03:37:58 <kmc> ":i Monad"
03:38:04 <kmc> ":i" is the general "info" command
03:38:06 <ChemisTree> ah, caps
03:38:23 <alistra> most of the problems with monads is probably matching the types
03:38:41 <kmc> _Mikey, Monad is more *specific* than Functor
03:38:47 <_Mikey> oh
03:38:48 <kmc> you have it backwards
03:38:57 <kmc> every Monad is a Functor
03:39:03 <ChemisTree> know of a good forum for Haskell Q and A
03:39:06 <ChemisTree> ?
03:39:07 <kmc> here
03:39:10 <_Mikey> hmm
03:39:12 <rtharper> ChemisTree: Haskell-cafe mailing list
03:39:19 <kmc> a Monad is a Functor with some additional properties
03:39:25 <kmc> ChemisTree, also http://stackoverflow.com/
03:39:26 <_Mikey> StackOverflow have been nice to my Haskell newbieness
03:39:31 <ChemisTree> ok
03:39:31 <_Mikey> XD
03:39:53 <kmc> _Mikey, the other two don't really fit in there, as far as I see
03:40:01 <_Mikey> ok
03:40:28 <_Mikey> I'm still learning so I was bound to be wrong.
03:40:46 <kmc> :)
03:40:59 <_Mikey> I attacked monads really fast cause people told me earlier on that I could just gloss over the learning part and just use them
03:41:07 <_Mikey> because it would all become intuitive
03:41:12 <_Mikey> but that failed.
03:41:40 <kmc> i think you can learn to do IO without knowing or caring that IO is a monad
03:41:54 <kmc> but it doesn't generalize to other monads
03:42:09 <_Mikey> hmm maybe I was told that and made the generalization up in my head
03:42:17 <kmc> i mean, if your understanding generalizes to all monads, then you understand monads ;)
03:42:35 <kmc> for some reason there is a lot of hype about monads
03:42:43 <kmc> and so people try to learn it sooner than they should
03:43:04 <kmc> it's the strange word everyone hears associated with haskell, so they think it must be super important and fundamental
03:43:12 <_Mikey> I was reading about Monads in my second week of learning Haskell... too soon?
03:43:34 <kmc> did you have a solid understanding of higher-order functions, polymorphism, and type classes?
03:43:43 <_Mikey> nada XD
03:43:53 <kmc> well, Monad is a type class containing a polymorphic higher-order function
03:44:03 <kmc> so if you can't put those concepts together, you're pretty much doomed
03:44:12 <_Mikey> XD
03:44:28 <kmc> that's why the hype is a problem; people skip ahead
03:44:37 <_Mikey> over the last month or so I have got High order functions and type classes down.
03:45:09 <ChemisTree> If Monad is a typeclass, than why does ":t Monad" not work...
03:45:17 <kmc> why would it
03:45:30 <kmc> you give an expression to :t
03:45:32 <_Mikey> I believe :t works on functions. not type classes
03:45:34 <kmc> it prints the type of that expression
03:45:39 <ChemisTree> because it is a typeclass
03:46:02 <copumpkin> :k Monad
03:46:02 <lambdabot>     Class `Monad' used as a type
03:46:03 <lambdabot>     In the type `Monad'
03:46:07 <copumpkin> that will work soon
03:46:22 <alistra> anybody knows how to invoke alexes and happys from cabal?
03:46:28 <ChemisTree> if I do ":t sum" it gives "sum :: Num a => [a] -> a
03:46:47 <copumpkin> ChemisTree: they're "at different levels"
03:46:52 <copumpkin> Monad is a statement about types
03:46:56 <copumpkin> so it doesn't have a type itself
03:46:57 <alistra> isn't monad something more than a kind? :D
03:46:59 <copumpkin> it has a kind, if anything
03:47:03 <kmc> ChemisTree, read LYAH
03:47:07 <copumpkin> Monad :: * -> Constraint
03:47:09 <alistra> has *
03:47:12 <copumpkin> in GHC 7.4
03:47:19 <_Mikey> oh the stars have come out XD
03:47:27 <alistra> :k Just
03:47:28 <lambdabot> Not in scope: type constructor or class `Just'
03:47:31 <_Mikey> :t (***)
03:47:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:47:36 <alistra> :k Maybe
03:47:37 <lambdabot> * -> *
03:47:54 <sipa> :k StateT
03:47:55 <lambdabot> * -> (* -> *) -> * -> *
03:48:19 <_Mikey> does anyone know a better tutorial on arrows than http://www.haskell.org/arrows/syntax.html
03:48:29 <kmc> ChemisTree, LYAH will explain the difference between expressions, types, and type classes
03:48:31 <kmc> @where LYAH
03:48:31 <lambdabot> http://www.learnyouahaskell.com/
03:48:34 <_Mikey> cause it doesn't really talk much about usage.
03:48:44 <_Mikey> I reccomend LYAH
03:48:44 <kmc> that's ok because nobody uses arrows ;)
03:48:58 <_Mikey> not even for FRP?
03:49:06 <kmc> nah, i'm lying ;P
03:49:10 <_Mikey> ahh :pp
03:49:12 <kmc> they're dramatically less popular than monads, though
03:49:30 <_Mikey> oh ok.
03:51:27 <kmc> when I was first learning Haskell, I heard about Arrows and thought "this is the next step from Monads, this must be what all the Haskell super wizards use"
03:51:35 <kmc> but it's not really
03:51:49 <kmc> unless all the super wizards are hiding themselves and all their code from me
03:52:04 <_Mikey> :(
03:52:17 <_Mikey> My dissertation supervisor is a super wizard
03:52:30 <_Mikey> he did a chunk of his PhD in haskell.
03:52:59 <kmc> cool
03:53:03 <kmc> i'm going to disappear now, ttyl all
03:53:06 <Sgeo> In enumerator, can I compose two enumerators?
03:53:14 <_Mikey> ok Merry xmas!
03:53:17 <Sgeo> Bye kmc
03:53:19 <kmc> you too :)
03:53:29 <Sgeo> Because I might want to write an enumerator that initializes some IO stuff
03:53:58 <nexion> does Control.Exception.finally consume the exception or let it propagate up to a potential handler outside?
03:57:01 <drwho> wow I need to sit and read through a tutorial still some basic things I need to study..
03:57:31 <_Mikey> which things?
03:59:06 <ChemisTree> so my computer restarted at a bad time... right after I asked a question about ":t Monad" and why it does not understand this in GHC
03:59:08 <drwho> like what the double columns mean and how to read something the code
03:59:42 <drwho> because I run into some things like a -> b -> Int or of that sort and I think of it in a C/C++ matter and that's not good heh
03:59:57 <ChemisTree> no need to backtrack though, I have no need to use Monad any time soon
04:00:06 <_Mikey> oh no.. C++ isn't good
04:00:22 <drwho> how to read the code*
04:00:31 <_Mikey> ahh,
04:00:33 <drwho> I prefer C over C++
04:00:54 <_Mikey> do you tend to read the code and replace some symbols with words?
04:01:10 <drwho> yes
04:01:12 <_Mikey> like & = "the memory location of" ect..
04:01:20 <_Mikey> ahh
04:01:31 <_Mikey> maybe..
04:01:36 <_Mikey> maybe....
04:01:42 <mike-burns> :t maybe
04:01:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:01:43 <_Mikey> I'm not a Haskell wizard yet so don't quote me
04:01:48 <_Mikey> but this might help http://www.haskell.org/haskellwiki/Keywords#.40
04:02:16 <Sgeo> Help who?
04:02:19 * Sgeo reads scrollup
04:02:32 <drwho> what is this
04:02:32 <drwho> lol
04:02:33 <_Mikey> drWho in terms of reading code.
04:02:36 <Sgeo> ChemisTree, Monad isn't a value
04:02:50 <Sgeo> :t only does values
04:02:51 <lambdabot> Not in scope: `only'
04:02:51 <lambdabot> Not in scope: `does'
04:02:51 <lambdabot> Not in scope: `values'
04:02:56 <Sgeo> :t True
04:02:57 <lambdabot> Bool
04:03:01 <Sgeo> :t Bool
04:03:01 <lambdabot> Not in scope: data constructor `Bool'
04:03:12 <Sgeo> ChemisTree, get it?
04:03:17 <drwho> :t Bool :: a
04:03:18 <lambdabot> Not in scope: data constructor `Bool'
04:03:29 <Sgeo> (Although Monad and Bool are different things also, so don't get confused)
04:03:37 <ChemisTree> I get that monad isn't a value, yes
04:04:08 <ChemisTree> sgeo, and monad isnt a function either?
04:04:13 <Sgeo> ChemisTree, correct.
04:04:19 <Sgeo> All functions are values.
04:04:28 <dylukes> I'm hoping that today, as a Christmas miracle, we can all agree to use the same present/tree metaphors for monads/comonads.
04:04:30 <Sgeo> So Monad not being a value implies that it isn't a function.
04:04:39 <dylukes> "Haskell is like Christmas..."
04:04:46 <Sgeo> lol
04:04:50 <ChemisTree> but a function may draw information from monad?
04:04:50 <drwho> _Mikey: thanks but maybe I should read this http://ccfit.nsu.ru/~ikuznecov/doc/Haskell%20Tutorial%20for%20C%20Programmers/intro.html
04:05:03 <drwho> seems like something up my alley
04:05:14 <dylukes> ChemisTree: It's a type constructor, so it can be pattern matched on and dissasembled.
04:05:15 <_Mikey> cool
04:05:19 <mike-burns> ChemisTree: A monad is a collection of functions signatures.
04:05:20 <Sgeo> ChemisTree, for now, let's forget about what "Monad" specifically is, and talk about its role in the type system instead.
04:05:35 <Sgeo> dylukes, what are you talking about?
04:05:55 <dylukes> What's the difference between "data Id a = Id a" and "id a = a" ChemisTree?
04:06:02 <Sgeo> ChemisTree, Bool is a type. Functions can take it, functions can return it
04:06:13 <ChemisTree> is there anything I can type into my compiler to see how monad might work?
04:06:14 <mike-burns> I assume he's talking about gifts, still. He pattern matches on presents.
04:06:27 <mike-burns> :i Monad
04:06:28 <ChemisTree> something simple, like proving a bool function
04:06:56 <mike-burns> @info Monad
04:06:56 <lambdabot> Monad
04:07:00 <Sgeo> dylukes, you may be jumping the gun?
04:07:10 <mike-burns> I always forget just how useless @info is.
04:07:14 <Sgeo> ChemisTree, by contrast, Monad is a thing that ... argh
04:07:25 <Sgeo> Let's look at Num instead. Num and Monad are similar.
04:07:30 <Sgeo> :t 5
04:07:31 <lambdabot> forall t. (Num t) => t
04:07:47 <Sgeo> That type means that t can be any type that is a Num
04:07:59 <Sgeo> Num is called a typeclass. A bunch of types can fulfill the typeclass.
04:08:03 <Sgeo> Typeclasses are not types.
04:08:05 <dylukes> Type classes are constraint kinds.
04:08:12 <dylukes> The biggest kind is *, which holds all the types.
04:08:21 <dylukes> type classes are smaller sets that only hold some.
04:08:33 <dylukes> (Num t) => t is saying "any t, which is in Num"
04:08:57 <dylukes> and it is, not coincidentally, identical to write "forall t. Num t => t"
04:09:13 <ChemisTree> ":i Monad" is pretty confusing to me right now. I think I will stick to "Learn You a Hakell for Great Good" until I understand more of this Language called Haskell
04:09:21 <dylukes> (assuming you don't have any other arguments... the for all needs to stay to the left...
04:09:34 <Sgeo> ChemisTree, :i is not a language construct
04:09:47 <Sgeo> It's a tool you can use in GHCi to find out more information about something.
04:09:48 <mike-burns> But typeclasses are.
04:10:11 <mike-burns> Stick with LYAH until you understand typeclasses some more.
04:10:14 <dylukes> Sgeo: okay so,
04:10:27 <dylukes> 1, 2, 3, "a", "hello", [1,2,3], etc,
04:10:30 <dylukes> are all values right?
04:10:33 <mike-burns> Then Num and Monad and Show and a whole bunch of others are pretty similar.
04:10:44 <ChemisTree> sgeo, I mean Haskell the language, in general. It is still very new and foreign to me.
04:11:16 <ChemisTree> does that make sense? ...
04:11:25 <sipa> :i Monad
04:11:27 <Sgeo> dylukes, um, I'm not a Haskell newbie. Unless you're trying to explain pattern matching on type constructors.
04:11:44 <Sgeo> sipa, lambdabot does not handle :i decently
04:11:49 <dylukes> Sgeo: No I'm not, I meant ChemisTree
04:11:52 <dylukes> :P
04:12:15 <Sgeo> lol, ok
04:19:10 <ChemisTree> what specifically do you personally use Haskell for? Do you make programs that assist you in some way, or are you using to build ascii art? or what?
04:19:42 * Sgeo hasn't used Haskell as much as he'd like to
04:20:02 <Sgeo> Used it to write some code in an annoying language for me, planning on putting it to use for similar tasks in the future.
04:20:09 <mike-burns> I use it as a type-safe sh replacement, for the most part.
04:21:36 <ChemisTree> Personally I want to use it to program a personalized version of Haskore, with an end goal of composing music with it. hopefully attatching it to some sort of visual interface to make it more entertaining to follow with the eye
04:22:01 <mike-burns> Noble, if lofty!
04:22:05 <ChemisTree> However that is a long term goal...
04:22:14 <ChemisTree> I still don
04:22:27 <ChemisTree> 't understand what you use haskell for?
04:22:35 <ChemisTree> entertainment?
04:22:50 <Sgeo> ChemisTree, have you ever programmed before?
04:22:51 <ChemisTree> Job?
04:23:03 <mike-burns> It's a general purpose programming language. So, general stuff.
04:23:15 <ChemisTree> I have programmed in school
04:23:34 <mike-burns> Basically no one in #haskell is paid to do Haskell. The people who are paid have better things to do, apparently.
04:23:36 <ChemisTree> made a bank emulator in C
04:24:27 <ChemisTree> In Haskell I walked through tutorials, but that was numbing. Now I want to learn it as a hobbie,
04:24:41 <ChemisTree> It seems like Haskell has  a huge potential
04:24:59 <mike-burns> Someone just needs to write a killer app in it.
04:25:01 <mike-burns> Any day now.
04:25:09 <drwho> :t fuu :: Int -> Int
04:25:09 <lambdabot> Not in scope: `fuu'
04:25:13 <Sgeo> I thought Parsec was the killer app
04:25:28 <mike-burns> Is it?
04:27:23 <ChemisTree> Are any of you working on something like that?
04:27:49 <mike-burns> I don't do anything with Parsec.
04:27:53 <ChemisTree> It seems like this would be a good place to work on a Open source, Bazaar style, program in haskell
04:28:04 <mike-burns> As opposed to?
04:28:34 <ChemisTree> as opposed to 10 people paid to work on a secret program in a closet
04:28:48 <mike-burns> Well if you can find that job, go for it.
04:28:52 <ChemisTree> with deadlines and such
04:28:59 <ChemisTree> ?what?
04:28:59 <lambdabot>  @where <key>, return element associated with key
04:29:14 <ChemisTree> no thanks. ! hah
04:30:49 <mike-burns> Most paid Haskell jobs seem to do stuff with finance, or so they claim.
04:36:17 <ChemisTree> hmm, I could see that happening.
04:37:01 <ChemisTree> I bet Haskell could make a killer program for  chash registers at a store
04:37:14 <ChemisTree> such as a food coop (grocery store)
04:37:42 <ChemisTree> Inventory everyting while ringing up customers
04:37:53 <ChemisTree> and so much more!
04:40:37 <ChemisTree> I wonder if Haskell could be used to detect incoming Midi signals or even audio in general, and evaluate the sound in terms of Frequency, Amplitude and other sound quality aspects.
04:40:42 <hpaste> mreh pasted “reactive” at http://hpaste.org/55705
04:40:51 <hpaste> alistra pasted “DisambiguateRecordFields doesn't work” at http://hpaste.org/55706
04:41:10 <ChemisTree> hpaste, what is this?
04:42:43 <Sgeo> ChemisTree, a convenient way of sharing Haskell code
04:43:03 <Sgeo> It's a pastebin, which is a website which is a convenient way of sharing a lot of lines of whatever without spamming chat.
04:43:27 <Sgeo> hpaste is specialized for Haskell. Among other things, it checks to see whether there are style issues or probable errors.
04:43:38 <Sgeo> (Using hlint, which you can use without using hpaste)
04:43:42 <mreh> quicksilver: what do you think of my event merging implementation?
04:43:55 <mreh> http://hpaste.org/55705
04:44:18 <ChemisTree> did that link pop up because I was typing too much?
04:44:33 <Sgeo> ChemisTree, no.
04:44:36 <ChemisTree> hinting at me..
04:44:41 <mreh> ChemisTree: there's a bot in this channel
04:44:56 <ChemisTree> are you the bot?
04:44:58 <Sgeo> It popped up because hpaste has a feature that, when someone puts code on hpaste, they can have it be announced to this channel.
04:44:58 <mreh> she reports any pastes she's directed to at hpaste.org
04:44:59 <ChemisTree> mreh
04:45:02 <Sgeo> ChemisTree, hpaste is the bot.
04:45:05 <mreh> :)
04:45:07 <ChemisTree> ah
04:45:44 <ChemisTree> well, mreh is kind of a bot-like  name
04:45:51 <pshf> I don't want "signum" in the Num class; can anything go wrong if I define an instance without defining signum (and I never use signum)?
04:46:17 <sipa> ChemisTree: sure, but analysis code like FFT's will probably be more efficient in a lower-level language like C
04:46:33 <mreh> @tell quicksilver I've done an event merging implementation without improving values because of the observation that all the events I can imagine will only provide any information on their occurence time at the instance they occur
04:46:33 <lambdabot> Consider it noted.
04:46:35 <sipa> nothing prevents you from using C code in a haskell program though
04:46:42 <mreh> @tell quicksilver http://hpaste.org/55705
04:46:42 <lambdabot> Consider it noted.
04:46:49 <mreh> can i leave two messages?
04:47:03 <Sgeo> mreh, yes, I think
04:48:41 <ChemisTree> Any suggestions for a Text Editor, Windows OS.Notepad is a little primitive
04:48:44 <mreh> someone leave me two :)
04:48:47 <mreh> ChemisTree: vim or emacs
04:48:57 <ChemisTree> vim, thats the one
04:48:58 <ChemisTree> thanks
04:49:38 <mike-burns> pshf: `signum' doesn't have a default definition; I'm not sure if you're even able to define the instance without defining it.
04:49:39 <mreh> merry christmas everyone :)
04:50:44 <pshf> mike-burns: ok, thanks. so what's the best strategy, just writing a bogus implementation is not very elegant
04:51:07 <pshf> I'd like to avoid having to define a "MyNum" class which is like Num except you don't have to define signum :D
04:51:50 <nexion> is it possible to catch all exceptions while doing a putStrLn for those that are showable?
04:52:27 <mike-burns> pshf: I don't know the best strategy but you could get away with   signum = id   .
04:52:52 <pshf> yeah sure, that's what I meant with the bogus implementation :P
04:53:29 <mike-burns> I honestly don't know anything better. A common complaint is that typeclasses are too big, and Num is the best example of that.
04:54:08 <pshf> yeah, well that's fine really, it was just in case there was a better solution
04:54:20 <pshf> I do think the standard prelude classes are a bit misguided in their definition to be honest though
04:54:27 <mike-burns> I suppose   signum = undefined    is actually better, but yeah, still sucks.
04:54:48 <mike-burns> I'm sure they'd love to change the Prelude but it's a little late for that.
04:55:08 <mike-burns> Splitting Monad and all that.
04:55:21 <Sgeo> Is signum = error "No signum definition for XYZ" better?
04:56:22 <mike-burns> Yeah; it raises a better message.
04:56:27 <pshf> yeah I'll use that actually just to make sure nothing funny's happening :P
05:00:32 * hackagebot xournal-types 0.2 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.2 (IanWooKim)
05:00:34 * hackagebot xournal-builder 0.1.0.0 - text builder for xournal file format  http://hackage.haskell.org/package/xournal-builder-0.1.0.0 (IanWooKim)
05:02:56 <Jeanne-Kamikaze> oh yes it worked
05:04:53 <Jeanne-Kamikaze> can one take a Ptr to a given value ?
05:05:32 * hackagebot xournal-parser 0.3.0.0 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.3.0.0 (IanWooKim)
05:06:09 <Jeanne-Kamikaze> I want to pass a pointer to a struct; these tutorials make it an instance of Storable and then use alloca / peek / poke to interact with the C code, but apparently that's doing a temporary copy of the value so it must be a performance hit
05:07:36 <ChemisTree> http://www.foldplop.com/
05:07:39 <Botje> Jeanne-Kamikaze: i think you have to create a stableptr out of it first.
05:07:45 <Jeanne-Kamikaze> oh
05:08:16 <Jeanne-Kamikaze> but then I lose memeory management
05:08:33 <Jeanne-Kamikaze> and have to free it manually ?
05:08:37 <ahihi2> ChemisTree: what about it?
05:08:50 <ChemisTree> Listen. It's music
05:08:56 <ahihi2> I know, it's my website :)
05:09:04 <ChemisTree> !!!!!!!!!!!!!
05:09:10 <ChemisTree> I love you
05:09:14 <ChemisTree> :)
05:09:23 <ahihi2> :P
05:09:26 <ChemisTree> haha
05:09:36 <ChemisTree> This is sorta surreal
05:10:21 <ChemisTree> I have to congratulate you on your music
05:10:34 * hackagebot xournal-render 0.4 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.4 (IanWooKim)
05:10:34 <ChemisTree> I could talk about it for a while
05:10:36 * hackagebot hxournal 0.6.1 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.1 (IanWooKim)
05:10:38 * hackagebot dstring 0.4.0.3 - Difference strings  http://hackage.haskell.org/package/dstring-0.4.0.3 (BasVanDijk)
05:10:45 <ChemisTree> ahihi2
05:10:49 <ahihi2> thanks! I'm glad I'm not the only one who likes it
05:11:18 <ChemisTree> ahihi2, I have a friend who REALLY like it too
05:11:47 <ahihi2> cool
05:12:15 <ChemisTree> ahihi2, I used to listen to shpongle, almost religiously, and the music you have put out thus far is on par
05:12:20 <ChemisTree> more down to earth
05:12:25 <ChemisTree> I like it for that reason
05:13:07 <ChemisTree> that may seem weird, to call your music down to earth, cause it can be so... alien, at times,
05:13:10 <ahihi2> they are one of my main inspirations
05:13:28 <ChemisTree> Dude, this is really great
05:14:00 <ChemisTree> It is rare to be able to chat with another musician that makes music that I listen to
05:14:14 <ahihi2> hehe
05:14:32 <ChemisTree> ahihi2, I only found it a few days ago.
05:14:45 <ChemisTree> searching for Haskore music
05:15:05 <ChemisTree> do you mind me asking you questions about your music?
05:15:13 <ahihi2> not at all
05:15:17 <ChemisTree> nice
05:15:18 <ahihi2> it might be a bit off topic here though
05:15:25 <ChemisTree> right...
05:15:32 * hackagebot string-combinators 0.6.0.2 - Polymorphic functions to build and combine stringlike values  http://hackage.haskell.org/package/string-combinators-0.6.0.2 (BasVanDijk)
05:15:45 <ChemisTree> one time cant hurt
05:16:08 <ChemisTree> anyway, is your music made on Haskore?
05:16:24 <ChemisTree> that would be very on topic, since haskore is programmed in haskell
05:16:29 <ahihi2> no, I use Reason
05:16:41 <ChemisTree> ah, do you use midi instruments?
05:18:04 <ahihi2> I have a couple of midi keyboards but mostly it's point-and-click sequencing
05:19:15 <ChemisTree> ahihi2, for your melodies, do you do point and click?
05:19:28 <ahihi2> depends on my mood :p
05:20:11 <ahihi2> I'm not a good keyboardist so I have to do adjustments in any case
05:20:26 <ChemisTree> nice. In the song Tui, when the 'beat drops', there is a wobble (like a subtle dub step), is that midi instrument made?
05:20:38 <ChemisTree> Oh ok
05:21:51 <mike-burns> Use #haskell-blah for this.
05:22:16 <ahihi2> that's a good idea
05:22:24 <ahihi2> seems I am already there
05:23:47 <ChemisTree> is it possible to have multiple IRS tabs open?
05:23:53 <ChemisTree> Not sure how to do that
05:24:12 <ChemisTree> mike-burns
05:24:30 <mike-burns> I can't help you with your IRC client.
05:24:47 <ChemisTree> no worries
05:25:05 <ahihi2> /join #haskell-blah will probably create a new window/tab/whatever
05:26:42 <ChemisTree> ahihi2, I really like Memory song, especially at 1:13
05:27:09 <ChemisTree> so nice with the slow tempo
05:30:28 <Sgeo> "As a proof method, general recursion is wholly bogus—its type, ∀P ⇒ (P → P ) → P is a blatant
05:30:28 <Sgeo> lie.
05:30:28 <Sgeo> "
05:30:34 * hackagebot repr 0.4.1.2 - Render overloaded expressions to their textual representation.  http://hackage.haskell.org/package/repr-0.4.1.2 (BasVanDijk)
05:36:15 <augur> @tell edwardk is there any in-depth discussion of the recursion schemes you mention in your fieldguide? i cant get an intuition from the haskell code
05:36:16 <lambdabot> Consider it noted.
05:45:02 <augur> @tell edwardk actually im reading some of your blog posts about specific schemes and they mention really interesting stuff but it doesnt look like you go into detail about it anywhere. :\
05:45:03 <lambdabot> Consider it noted.
05:45:34 * hackagebot rss 3000.2.0.1 - A library for generating RSS 2.0 feeds.  http://hackage.haskell.org/package/rss-3000.2.0.1 (BasVanDijk)
05:50:34 * hackagebot unbounded-delays 0.1.0.4 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.4 (BasVanDijk)
05:57:27 <mreh> unbounded thread delay? hang = threadDelay maxBound >> hang
05:58:33 <mreh> oh, unbounded Integer
05:59:50 <mreh> > fix ("ho"++)
05:59:51 <lambdabot>   "hohohohohohohohohohohohohohohohohohohohohohohohohohohohohohohohohohohohoho...
06:00:00 <alistra> fix error
06:00:05 <alistra> > fix error
06:00:06 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:01:12 <alistra> :t fix
06:01:13 <lambdabot> forall a. (a -> a) -> a
06:01:23 <alistra> @hoogle a -> a
06:01:23 <lambdabot> Prelude id :: a -> a
06:01:24 <lambdabot> Data.Function id :: a -> a
06:01:24 <lambdabot> GHC.Exts breakpoint :: a -> a
06:01:32 <alistra> > fix breakpoint
06:01:33 <lambdabot>   Not in scope: `breakpoint'
06:01:39 <alistra> @hoogle a -> String
06:01:40 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
06:01:40 <lambdabot> Prelude show :: Show a => a -> String
06:01:40 <lambdabot> Text.Show show :: Show a => a -> String
06:01:43 <mreh> how does ghc figure out the type for hang = threadyDelay maxBound >> hang
06:01:51 <alistra> > fix show
06:01:51 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
06:02:01 <mreh> that's a good one
06:03:16 <alistra> @hoogle a -> Int
06:03:17 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
06:03:17 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
06:03:17 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
06:03:28 <alistra> @hoogle String -> String
06:03:28 <lambdabot> Data.Data tyconModule :: String -> String
06:03:28 <lambdabot> Data.Data tyconUQname :: String -> String
06:03:28 <lambdabot> Test.QuickCheck.Text bold :: String -> String
06:03:37 <alistra> > fix bold
06:03:37 <nand`> Could values in haskell be considered morphisms from () -> T?
06:03:38 <lambdabot>   Not in scope: `bold'
06:04:11 <alistra> nand`: wouldn't we be on #ocaml now?
06:04:30 <nand`> alistra: I know nothing of ocaml
06:04:36 <darkgerm> hi, I'm learning Haskell now. but I don't know how to run the sample...
06:04:37 <darkgerm> f n = if n==0 then 1 else n*f(n-1)
06:04:43 <nand`> I was thinking about the Hask category
06:04:54 <alistra> > let f n = if n==0 then 1 else n*f(n-1)
06:04:54 <lambdabot>   not an expression: `let f n = if n==0 then 1 else n*f(n-1)'
06:04:59 <alistra> > let f n = if n==0 then 1 else n*f(n-1) in f 6
06:05:00 <lambdabot>   720
06:05:45 <nand`> darkgerm: alternatively, if you're using GHCi, you can use a special syntax: “let f n = if n ==0 then 1 else n*f(n-1)”
06:05:50 <nand`> and then, in the next line write “f 6”
06:05:52 <nand`> or whatever
06:06:14 <nand`> this is what I recommend doing when you're learning
06:06:31 <nand`> I never actually compiled a haskell file for weeks, I'm sure
06:06:40 <darkgerm> I've installed GHCI, but I still got error.
06:07:34 <darkgerm> ghci <-- is this the command to run GHCI?
06:07:35 <nand`> darkgerm: http://pastebin.com/Ce5MSzVy
06:07:37 <mauke> The paste Ce5MSzVy has been copied to http://hpaste.org/55707
06:07:41 <nand`> here is a full transcript of my GHCI session
06:07:43 <nand`> yes
06:08:15 <darkgerm> oh I forgot the "let"
06:08:45 <nand`> do note that GHCi differs from regular GHC in a few other ways
06:08:56 <nand`> for example the “where” shorthand doesn't work in GHCi at all
06:09:31 <nand`> you can also include multiple lines by separating them with a semicolon, eg
06:09:42 <nand`> let f 0 = 1; f n = n * f (n-1)
06:10:25 <darkgerm> f n | n==0 = 1
06:10:40 <darkgerm>     | otherwise = n*f(n-1)
06:11:37 <nand`> same line also in GHCI, let f n | n==0 = 1 | otherwise = n*f(n-1)
06:11:54 <mreh> where is not part of an expression?
06:14:25 <darkgerm> thanks, it very useful!
06:17:41 <mugenken> hi. i am trying to use Data.ConfigFile with the full example from the docs http://hackage.haskell.org/packages/archive/ConfigFile/1.0.5/doc/html/Data-ConfigFile.html where i get an error included here http://pastebin.com/4f8jiF53
06:17:43 <mauke> The paste 4f8jiF53 has been copied to http://hpaste.org/55708
06:18:29 <nand`> mreh / darkgerm: let me take that back, where works fine: let x = y where y = 5
06:18:37 <nand`> Did they change that or do I have it wrong in memory?
06:19:12 <mugenken> hm.. i got it.. empty has to be emptyCP
06:23:06 <_Mikey> is everyone busy eating?
06:26:36 <_Mikey> hey tensor?
06:49:43 <sgronblo2> So anyway, clojure also has a remove in addition to filter.
07:00:22 <ChemisTree> #haskell-blog
07:01:46 <ChemisTree> how does one make a private channel with another use?
07:01:56 <ChemisTree> how does one make a private channel with another user?
07:02:10 <alistra> ChemisTree: you don't make a channel
07:02:16 <alistra> you just join it
07:02:16 <ChemisTree> oh...
07:02:25 <alistra> each channel exists always
07:02:32 <alistra> (don't worry about the implementation_
07:02:55 <ChemisTree> alistra, I was chatting with someone earlier on a channel with his user name
07:02:58 <alistra> practically channel exists when there are people on it
07:02:59 <ChemisTree> how did we do that?
07:03:19 <alistra> or you queried him /q hisname
07:03:28 <alistra> or you both joined a channel #hisname
07:16:37 <nand`> in http://www.haskell.org/haskellwiki/Category_theory/Natural_transformation#Functor_and_natural_transformation
07:16:51 <nand`> it says “fmap maybeToList :: Parser (Maybe [String]) -> Parser [String]” but shouldn't it be “fmap maybeToList :: Parser (Maybe String) -> Parser [String]”?
07:22:35 <nand`> I got disconnected so I did not see any responses to my question ~5 minutes ago, if there were any
07:23:10 <Clint> nand`: there weren't any
07:23:14 <nand`> I see
07:40:36 * hackagebot cabal2nix 1.23 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.23 (PeterSimons)
07:42:03 <brill> Merry Christmas.
07:42:12 <alistra> merry xmas
07:52:33 <applicative> nand`: yeah, that page has a typo, everything else seems right but contradicts the signature  Parser (Maybe [String]) -> Parser [String]
07:53:04 <chucky> "you typed it perfect" to be changed to "you typed it perfectly"
07:54:53 <applicative> man that natural transformation wiki page seems unnecessarily complicated, or anyway unnecessarily ugly
07:55:56 <nand`> https://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category <- on the second exercise in this section
07:56:30 <nand`> is it correct to say that since (f . g) . h = f . (g . h) and g.h = 1a and f.g = 1b (as mentioned earlier), then 1b . h = f . 1a thus follows h = f and this is what's causing it to be not a category?
07:58:45 <nand`> err, exchange 1a and 1b but otherwise it's the same
08:05:38 <cads> hi
08:07:04 <cads> I'd like to use the yahoo finance .Net api to pull some options data
08:07:12 <cads> and I was wondering if I could do that from a haskell environmnet
08:07:19 <cads> environment^
08:09:22 <cads> should I use the FFI, or is there something else
08:13:48 <c_wraith> cads: it's almost certainly just making http requests
08:21:29 <mekeor> i once heard of a function (say `f') in a module which allows you to evaluate/interpret a string. for example the result of `f "(+)"' would be `(+)' do you know that function/module?
08:21:52 <mekeor> (sry, i missed the dot (".").)
08:22:53 <mike-burns> read ?
08:23:30 <mekeor> er… no no.
08:24:11 <nand`> there's no instance declaration for function types in Read, as far as I'm aware
08:25:38 <mike-burns> Searching the Web for "haskell eval" has some solutions, of various types.
08:26:18 <monochrom> the easiest packages to use for that are "hint" and "mueval"
08:26:38 <mike-burns> > (\f -> case f of "(+)" -> (+)) "(+)" 1 2
08:26:39 <lambdabot>   3
08:28:17 <mekeor> monochrom: yea. thanks! i think i am/was looking for "hint". or more precisely, Language.Haskell.Interpreter
08:28:19 <mekeor> ty
08:33:24 <mreh> ping
08:34:25 <mike-burns> Just me, I'm afraid.
08:48:35 <patrickL> newbie to haskell here
08:48:53 <patrickL> anyone here?
08:49:10 <mekeor> yea
08:49:17 <patrickL> is this the place to ask haskell questions?
08:49:24 <mekeor> indeed.
08:49:56 <mekeor> how are you, patrickL? :)
08:49:58 <patrickL> i'm trying to figure out how haskell and category theory work together
08:50:15 <patrickL> i'm fine thank you and merry christmas
08:51:01 <patrickL> bye
08:51:09 <mekeor> :) (i'm not christian, but ty anyway :)
08:51:14 <mekeor> patrickL: you leave us?
08:51:34 <mike-burns> Well!
08:51:40 <mekeor> mike-burns: huh?
08:51:52 <mike-burns> That was interesting.
08:52:02 <mekeor> yes.
08:55:05 <monochrom> this is a place to say merry christmas or (belly christmas if you like eating)
08:55:26 <Eduard_Munteanu> Who doesn't? :D
08:56:13 <monochrom> some haskell libraries (including some standard ones) apply category theory. that's the relation.
08:56:47 <byorgey> well, and there are deep relationships between logic, lambda calculus, category theory, etc.
08:57:09 <monochrom> for example the type class Functor and the class method fmap applies functor from category theory.
08:57:14 <mike-burns> He's gone.
08:57:24 <byorgey> I know, I just like talking about category theory.
08:57:29 <Eduard_Munteanu> Heh.
08:57:32 <mike-burns> Hah, fair enough.
08:58:19 <Eduard_Munteanu> byorgey: might want to autojoin the youknowitsname channel then ;)
08:58:41 <monochrom> the deep relation between logic, lambda calculus, category theory, type theory, and topology is applicable to all programming languages, not specific to haskell, so for example it holds for x86 assembly and PHP, too.
08:58:58 <mekeor> does anyone have a fire extinguisher? mike-burns!
08:59:06 * mike-burns gets it.
08:59:37 <mekeor> =)
08:59:51 <byorgey> Eduard_Munteanu: ah, didn't know it existed =)
09:01:04 <byorgey> monochrom: well, of course.  But Haskell is a particularly nice environment for learning about such things.  So it's not ridiculous that someone should ask about the relationship.
09:02:05 <monochrom> no, not ridiculous
09:04:41 <djahandarie> I'd like to see an application of topology to x86 ASM.
09:09:06 <ddarius> @google topology x86 assembly
09:09:07 <lambdabot> http://docs.oracle.com/cd/E19575-01/821-0259/bacdigfhx/index.html
09:09:07 <lambdabot> Title: x86: N+1 (Star) Topology (Sun Cluster Concepts Guide for Solaris OS)
09:12:10 <Eduard_Munteanu> Kinda different meaning of topology.
09:17:09 <monochrom> first application. write an assembly program and run it. now I also hook up some input device to I/O port 0x200, and some output device to I/O port 0x201. I feed a bit string into the input device at 1 bit per second, and I sample the output device at 1 bit per second for output. the bit strings are a topology, and your program is a continuous function. (oh, your program doesn't touch either I/O ports? then tough luck for me,
09:17:09 <monochrom>  but doesn't stop me from trying, and your program is still a continuous function.)
09:22:09 <lukish_> There is f :: Int -> Int -> Int and a,b :: [Int] length n. So I want to do something like map, and have c = f [a] [b], c :: Int with length n
09:22:19 <lukish_> How can I do do that?
09:22:45 <ion> zipWith f a b
09:23:13 <ion> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
09:23:13 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
09:23:13 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
09:23:13 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:24:29 <ion> liftA2 also has the same type, but judging from the fact that you want the same length, you probably want zipWith.
09:24:37 <lukish_> Ok
09:24:39 <ion> > zipWith (+) [1,2,3] [10,20,30]
09:24:40 <lambdabot>   [11,22,33]
09:24:43 <ion> > liftA2 (+) [1,2,3] [10,20,30]
09:24:44 <lambdabot>   [11,21,31,12,22,32,13,23,33]
09:25:06 <monochrom> second application. an x86 processor is an interpreter, a loop or tail recursion that looks at the state and the I/O ports, mutates the state and/or outputs to a port, and again. (your assembly program is part of the state.) The denotational semantics of the x86 processor is the limit of this sequence: run it 0 iterations, run it 1 iterations, run it 2 iterations... you can use topology for the sequence and its limit.
09:38:29 <monochrom> this second application is particularly apt for Perl. it is hellish to give Perl programs a denotational semantics, since it turns out that parsing a Perl program fragment depends on running another fragment first, which is the antithesis to the denotational semantics requirement of a statically known parse tree. But giving a denotational semantics to the Perl interpreter itself, treating the progress of parsing and running y
09:38:29 <monochrom> our Perl program as a state, is much more doable and elegant.
09:38:29 <Eduard_Munteanu> Yeah, but it sounds a lot more complicated.
09:38:29 <Eduard_Munteanu> monochrom: also, what if the interpreter is self-hosted?
09:38:29 <monochrom> fortunately, the perl interpreter is not self-hosed.
09:38:32 <monochrom> some lisp interpreters are self-hosted or close enough to be. fortunately, parsing their lisp dialects probably depends little or none on executing. as long as parsing is static, you can give a denotational semantics, no worries about self-hosting.
09:39:21 <monochrom> it is the combination of both self-hosting and non-static parsing that defies all logic. just take away one of them, and the world is sane again.
09:41:15 <monochrom> actually, in the worst case, you just pull the same trick again. move up one meta level. that's what I did: instead of treating perl programs, I treat the perl interpreter. I moved up one meta level. you can move up one more if necessary.
09:41:30 <carpi> how would you go about writing a function to produce the prime factors of a number without using recursion assuming there is already a list of all primes called 'primes'?
09:42:04 <carpi>  i already did it recursively.. but it seems very difficult to write the same without recursion
09:42:41 <monochrom> use unfoldr as the outermost function
09:43:07 <monochrom> unfoldr over the number to be factored and the list of primes
09:44:15 <monochrom> and there are more tricks necessary
09:45:20 <mike-burns> :t unfoldr
09:45:21 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:45:38 <carpi> unfoldr seems like it returs a maybe tuple.. how would that be helpful? something like 'unfoldr (fn) 315 primes'? where fn returns a tupe of the successive quotients of b?
09:45:50 <carpi> in this case b would be 315 ofcourse
09:46:13 <monochrom> inside the b -> Maybe (a, b) function you pass to unfoldr, you use a foldl
09:46:38 <monochrom> the foldl is for trial division
09:47:24 <monochrom> actually, dropWhile is better
09:48:17 <morel> hi. which module/library do you recommend for creating a sound with haskell (on a unix/linux-machine)?
09:49:08 <saati> morel: i used Data.WAVE to create wav files
09:50:36 <morel> saati: i do not want to write the sound into a file. i actually just want my boxes to play that sound directly.
09:50:56 <morel> s/boxes/loudspeaker/
09:54:23 <mike-burns> @hoogle gstreamer
09:54:24 <lambdabot> package gstreamer
09:54:48 <mike-burns> morel: The gstreamer package, as part of gtk2hs, can do that. I've never tried it in Haskell, though.
09:54:55 <Eduard_Munteanu> monochrom: presumably you could give denotational semantics at assembly level, assuming no self-modifying code?
09:55:05 <monochrom> yes
09:55:22 <morel> mike-burns: hm. thanks so far =)
09:55:28 <saati> does gstreamer actually do anything aside from leaking a lot of memory?
09:55:54 <monochrom> yes, it plays some audio or video :)
09:56:01 <mike-burns> saati: Yes; it also solves morel 's question.
09:56:04 <monochrom> or maybe just transform
09:56:05 <russellw> Eduard_Munteanu, in principle yes, but surely easier said than done - how would you give denotational semantics to the system and dynamic library calls?
09:56:34 <morel> that, right?: http://hackage.haskell.org/package/gstreamer
09:56:38 <mike-burns> Yup.
09:56:52 <Eduard_Munteanu> Right.
09:57:10 <monochrom> russellw: we're contemplating the easier-said-than-done-but-not-yet-ridiculously-insane :)
09:57:35 <Eduard_Munteanu> Well, you could always give the semantics to the x86 CPU I guess, but even then the way some stuff really works is unknown.
09:57:37 <russellw> Point :)
09:58:06 <russellw> I mean I looked into the question of doing that sort of thing a while ago, and my conclusion was you can give semantics to the x86 CPU sure, but that's the easy part
09:58:23 <russellw> The problem is that a chunk of machine code has no meaning in isolation without the semantics of the entire machine
09:58:45 <russellw> And for the machine, well, the source code of virtualbox is three million lines
09:58:51 <russellw> Admittedly that's optimized for efficiency, but still
09:59:36 <monochrom> the source code of the CPU itself is more succint but no more readable, yes
09:59:37 <morel> mike-burns: where's the documentation of the gstreamer package (for haskell)?
10:01:42 <morel> wtf!?! it really doesnt seem to have a docu! O_O
10:01:53 <ben> I'm looking for a library to draw stuff similar to libxosd but not restricted to words and bars, is X11 the right place to go or are there more convenient wrappers?
10:04:18 <mike-burns> morel: Sorry! I think it's completely undocumented. If it helps, here are the docs for the C lib: http://gstreamer.freedesktop.org/documentation/
10:04:33 <mike-burns> I don't know of a better lib, maybe maybe someone else does.
10:04:45 <morel> mike-burns: ;(
10:05:09 * morel hates undocumented libs! they are senseless!
10:05:45 <mike-burns> It's all we got, for the most part.
10:08:53 <ddarius> Does the Haskell library change anything noticably from the C library?  If not, why do we need to copy the C library's documentation?  You are presumably expected to be familiar with the C library to use the Haskell library.
10:09:06 <mike-burns> That last sentence is why.
10:09:54 <ben> I'm not familiar with xlib and I'd like to use it from haskell :(
10:11:37 <ddarius> For higher level interfaces, I expect documentation.  For interfaces that are more or less in one-to-one correspondence with the bound library, I don't expect documentation.
10:12:00 <ksf> is there some TH magic around to derive hashable instances?
10:13:11 <ben> Maybe I've been spoiled by gtk bindings but I'd expect a motivating tutorial and reference documentation for every binding :V
10:13:26 <hpaste> monochrom pasted “factoring with canned recursion” at http://hpaste.org/55716
10:13:35 <monochrom> carpi: http://hpaste.org/55716
10:14:02 <mike-burns> I expect documentation for everything I'm supposed to use.
10:14:20 <ksf> wait, I can serialise with binary and hash that.
10:14:41 <ddarius> ben: Gtk2hs doesn't provide that, but it does to the extent that it notably changes the Gtk API.
10:14:58 <ben> then i guess I'm really just a fan of gtkmm
10:15:22 <ddarius> mike-burns: The documentation exists, it's just stored with the C library.
10:15:41 <ksf> that's almost *too* easy.
10:17:14 <carpi> monochrom: thanks for the solution.. im seeing features of haskell in that, that i haven't seen before.. i have quite a bit to ponder tonight )
10:17:46 <monochrom> well, at least I tried not to pointfreeize \p -> mod f p /= 0 :)
10:19:20 <ddarius> @pl \p -> mod f p /= 0
10:19:20 <lambdabot> (0 /=) . mod f
10:25:04 <augur> newton day! :D
10:41:09 <roconnor>     Couldn't match expected type `network-2.3.0.2:Network.URI.URI'
10:41:09 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
10:41:10 <roconnor>            against inferred type `URI'
10:41:12 <roconnor>       Expected type: [(network-2.3.0.2:Network.URI.URI, [String] -> [a])]
10:41:13 <roconnor>       Inferred type: [(URI, [String] -> QuoteDB)]
10:41:21 <roconnor> I can for the life of me figure out how to fix this error
10:41:24 <roconnor> *can't
10:42:33 <Saizan> more than one URI type
10:42:50 <Saizan> possibly from different versions of the network package
10:43:48 <roconnor> Saizan: why would two different version of network be visible to ghc
10:44:46 <parcs`> you are using a module of a package that is compiled against an older version of network and a module of the latest network package
10:44:56 <Saizan> yeah, that
10:45:13 <roconnor> ah some sort of cabal thingy
10:45:50 <parcs`> what package are you using btw
10:45:57 <roconnor> and debugging info that will tell me what versions are depending on what?
10:46:02 <Saizan> roconnor: cabal won't configure your lib if it has to use two versions of the same package
10:46:24 <Saizan> but ghc gives you enough rope instead
10:48:26 <roconnor> I have not idea what I need to reinstall
10:49:24 * roconnor tries reinstalling http
10:49:32 <mike-burns> Is this a global vs user issue?
10:49:51 <roconnor> there we go
10:50:10 <roconnor> mike-burns: no, I installed snap recently which upgraded network but not http
10:50:31 <roconnor> so now my other program doesn't compile
10:50:37 <roconnor> ... I guess I should be using cabal-dev
10:50:40 <parcs`> 'cabal install network http snap'
10:50:50 <parcs`> it should reinstall everything it has to
10:51:51 <parcs`> installing all three at once makes sure that dependencies among them are consistent
10:51:56 <roconnor> right
10:57:52 <roconnor> @tell edwardk I'm okay with that
10:57:52 <lambdabot> Consider it noted.
11:01:54 <drdo> Is there some function like openFile that can make directories if they don't exist?
11:02:23 <ion> System.Directory.createDirectoryIfMissing
11:02:28 <drdo> thanks
11:02:39 <ion> I don’t know how much it’s “like openFile”, though.
11:04:12 <drdo> I'll just use takeDirectory to make it and then open
11:05:05 <mike-burns> Probably want to open then create the directory in the `catch` handler.
11:05:19 <mike-burns> To avoid race conditions.
11:05:37 <ion> I’d be surprised if that’s not how createDirectoryIfMissing works.
11:06:29 <ion> It is indeed: http://hackage.haskell.org/packages/archive/directory/latest/doc/html/src/System-Directory.html#createDirectoryIfMissing
11:07:10 <ion> So, just use createDirectoryIfMissing and then assume it exists. No race conditions in there.
11:09:01 <drdo> hmm, what race could there possibly be?
11:09:44 <mike-burns> mkdir; something else rmdirs; open a new file in the dir -> race condition.
11:11:18 <drdo> then i'll just get an exception on openFile
11:11:20 <drdo> that's fine
11:12:12 <ion> “Something else keeps deleting everything you’re trying to create” isn’t that big a concern IMO. :-)
11:12:44 <drdo> you can't fight against that :P
11:12:50 <mike-burns> Life and death are just a part of being a ... file.
11:13:19 <roconnor> BTW, does anyone know how to compute the optimal bandwith from one node to another in a weighted directed (multi-)graph?
11:14:43 <ion> With brute force? :-)
11:15:14 <nazgjunk> roconnor: sounds about as complex as a travelling salesman
11:15:27 <roconnor> nazgjunk: you think?
11:15:28 <nazgjunk> although I guess there would be some heuristics
11:15:52 <nazgjunk> oh wait I think I'm misinterpreting your case
11:16:50 <ion> Would traversing the graph with A* search help?
11:17:14 <kmc> roconnor, can you do that with max-flow min-cut?
11:17:16 <roconnor> ion: I don't know; bandwith isn't exactly like path-length
11:17:28 <roconnor> kmc: possibly; I'm not familar with that
11:17:33 <kmc> (i'm going to name every graph algorithm i've heard of)
11:18:19 <Shin-LaC> the maximum flow between two nodes is the minimal bandwidth of any cut separating them
11:25:37 * hackagebot regular 0.3.4 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.3.4 (JosePedroMagalhaes)
11:27:15 <roconnor> looks like a linear programming problem
11:40:09 <kmc> yeah max-flow is, but there are also specific algorithms for it
11:41:28 <roconnor> it looks like max-flow is exactly what I meant by bandwidth
11:42:05 <xil> hello everyone. So I noticed Hoogle doesn't search the SDL libraries. Anyone know how I can search through them in a hoogle like way?
11:42:18 <roconnor> xil: maybe Hayoo
11:43:04 <kmc> i think there's also a way to install hoogle locally and point it at your packages
11:43:19 <xil> roconnor: thanks, that works
11:43:59 <kmc> sometimes all you really need is google search for  sdl site:hackage.haskell.org/packages
11:44:34 <xil> yeah sometimes I'll even just ctrl-f through the index for the package on hackage
11:45:11 <xil> but for some reason the SDL package won't let me view the entire index at once
11:48:35 <xil> roconnor: any ideas why hayoo only shows 10 results when it's found 42?
11:48:37 <roconnor> kmc: I dont' suppose any haskell pacakges privide solution to max-flow
11:48:43 <roconnor> xil: nope
11:49:11 <roconnor> kmc: apparently my blog post doesn't solve *all* graph problems.
11:49:21 <kmc> roconnor, it seems to be in FGL
11:49:27 <kmc> which blog post is that?
11:49:33 <kmc> http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Query-MaxFlow.html
11:51:18 <roconnor> kmc: http://r6.ca/blog/20110808T035622Z.html
11:54:46 <kmc> cool
11:58:41 <ion> Interesting. I’ll have to read it.
12:01:04 <monochrom> please don't solve all graph problems! we want something left to do. :)
12:01:21 <silver> http://dpaste.org/AwZrw/
12:01:30 <silver> why I get this error?
12:02:14 <silver> it seems I cannot use context of where (function g)
12:03:04 <monochrom> delete "h :: [[a]] -> a -> [[a]]"
12:03:06 <silver> if i remove explicit type signature in where block it compiles, or if I partially apply g to modified h
12:03:26 <kmc> http://try.ocamlpro.com/  very nice
12:03:26 <silver> I more curious why it doesn't work this way
12:04:17 <BMeph> silver: BEcause you're doing it wrong. ;)
12:04:21 <monochrom> the "a" in "where h :: [[a]] -> a -> [[a]]" is divorced from the "a" in "groupBy' :: (a -> a -> Bool) -> [a] -> [[a]]". for all you know, you could have written "where h :: [[b]] -> b -> [[b]]", and of course that is just as broken
12:06:04 <silver> oh I see, I've tried to change it to b, but it leads to another problem (from compilers point of view)?
12:06:35 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/src/FastBool.html
12:06:36 <monochrom> to the compiler, whether you say "h :: ...a..." or "h :: ...b..." makes no difference.
12:06:37 <silver> with a's I try to rebind a and with b's compiler cannot connect a and b
12:06:45 * ksf seriously hopes that's a fossil from olde days.
12:06:45 <silver> oh
12:07:02 <silver> so it's the same
12:07:17 <monochrom> to you, it has the difference of misleading yourself into "it's the same 'a' as someone else's type" or not
12:08:12 <silver> BMeph, yeah, my friend toying with haskell asking me questions, he kinda cornered me with this one
12:08:13 <ksf> the only thing that matters is if two variables are the same or distinct.
12:08:22 <parcs`> "note that fastOr and fastAnd are strict in both arguments"
12:08:24 <parcs`> lol
12:08:51 <ksf> if they are the same, the actual types will have to be the same, if they are distinct, the actual types *may* be distinct.
12:09:18 <monochrom> eh? ksf, I don't think that's related.
12:09:33 <kmc> they seem to have compiled the standard ocaml toplevel interpreter using http://ocsigen.org/js_of_ocaml/
12:09:59 <ksf> the third thing that matters about variables is that they *are* variables. That is, saying foo :: a -> Int; foo x = x won't work.
12:10:30 <ksf> as by saying "a" you say "any type", and "any type" doesnt' match "Int"
12:10:37 <ksf> that's all there's to know about type variables.
12:11:49 <ksf> I guess ghc's version of Binary could be folded, too.
12:12:33 <ksf> a lot of the codebase could use some love towards using standard libraries.
12:12:55 <silver> fearing to be too annoying: why is it different types? and how I can "pass" type variables to 'where' aside from using type inference and explicit function-argument?
12:13:19 <dolio> You need an extension called ScopedTypeVariables.
12:13:38 <kmc> it would be cool to do something similar for Haskell
12:13:44 <ksf> ...or some ingiunity.
12:13:55 <ksf> Data.Data does it both ways iirc.
12:13:56 <kmc> my understanding is that it would be very hard to compile ghci with ghcjs or uhc's js backend
12:14:01 <ksf> that is, depending on a preprocessor switch.
12:14:14 <monochrom> if you must insist on passing type variables, add {-# LANGUAGE ScopedTypeVariables #-} near the head of the file, add "forall a." to the type sig of group'. then you can use your type sig for h
12:14:27 <kmc> cause ghci is tied into the rest of ghc and the runtime system (written in C)
12:14:39 <monochrom> but it is completely unnecessary for this example
12:14:41 <kmc> ocaml seems to have a better separation of frontend, bytecode, bytecode interpreter, and native compilation for bytecode
12:14:52 <kmc> i'd love to see a haskell implementation which works that way
12:15:03 <silver> http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables
12:15:11 <silver> oh that helps
12:15:15 <silver> dolio, thanks
12:15:29 <silver> so it's just a design decision
12:15:45 <ksf> fsvo "design decision"
12:15:50 <silver> monochrom, thank you
12:16:07 <monochrom> that's pretty old. http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables is better. it's in the GHC manual
12:16:20 <ksf> haskell is designed by a comittee, and that comittee consisted to a significant degree of compiler writers caring about their laziness.
12:16:38 <silver> :-)
12:16:39 <silver> hehe
12:17:22 <dolio> I don't see how it's laziness here.
12:17:32 <dolio> You have to make an arbitrary decision.
12:17:41 <dolio> Given Haskell's type signatures.
12:18:35 <Saizan> i think it's fairly consistent with the implicitness of forall, also quite surprising though
12:18:40 <ksf> so, when are MultiParamTypeClasses, Flexible[Instances|Contexts] going to become standardised?
12:18:52 <xil> kmc: I'm reading over that SDL example you hpasted for me -- thank you so much for that btw, I can't find anything as on point. But there's one thing I get stuck on. I understand the C version of surfaceGetPixels and how to use that to set pixel data directly, but the Haskell verson is less clear. The two things I'm getting hung up on, really, are fmap and the return type for surfaceGetPixels, since 'Pixels' is seemingly undefined.
12:18:56 <ksf> it's hard to come across code that doesn't use them.
12:19:01 <dolio> The decision is essentially: type signatures always stand alone.
12:20:39 * monochrom proposes for irony: type-directed type variable scope resolution!
12:21:09 <Saizan> madness :D
12:21:13 <ksf> xil, http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/Graphics-UI-SDL-Color.html
12:21:35 <xil> ksf: that's Pixel, this is Pixels
12:21:40 <ksf> ...oh.
12:21:50 <xil> and I can't find Pixels anywhere
12:22:05 <ksf> data PixelsData
12:22:06 <ksf> type Pixels = Ptr PixelsData
12:22:08 <ksf> it's in the source.
12:22:16 <ksf> that is, it's a raw pointer.
12:22:58 <monochrom> so it's a pointer to hopefully an array (in the C sense)
12:23:17 <ksf> something like UArray Pixel would probably work, but then you never know the pitch.
12:24:00 <ksf> is pitch the same as stride? I hope so, otherwise my terminology is confused.
12:24:10 <xil> I see....well that explains that part. The other thing is fmap. I don't really understand Functors and can't find an actual explanation. I mean it looks like just a conversion inside a monad or something
12:24:30 <ksf> freetype is the worst offender when it comes to stride, btw. negative *and* different-from-length stride.
12:24:52 <ksf> it squeezes a function into the monad, so to speak.
12:24:52 <ben> can anyone recommend xhb?
12:25:15 <ksf> :t map
12:25:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:25:19 <ksf> :t fmap
12:25:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:25:28 <ksf> basically the same thing. the latter is just more general.
12:25:29 <monochrom> yes, Functor is just like a conversion
12:25:59 <ksf> so fmap also works over trees, maybes, arbitrary monads, and a lot of other stuff.
12:26:06 <xil> oh so map = fmap where the Functor is []?
12:26:08 <ksf> :t liftM
12:26:09 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:26:10 <ksf> yep.
12:26:11 <monochrom> yes
12:26:33 <monochrom> fmap is pretty easy to explain for container types like lists, trees, arrays
12:27:16 <monochrom> in fact, upon hearing that, you can already imagine it, say no more
12:27:21 <ksf> it's easy, anyway. Functors are just covariant endofunctors in Hask.
12:28:44 <xil> okay so in terms of Ptr as the Functor, it's just like a list, in that fmap will just map over the entire contents of the Ptr?
12:28:54 <ksf> ben, are you are masochist and/or an x11 wizard?
12:29:06 <ben> nope
12:29:09 <monochrom> wait, Ptr is a Functor instance?
12:29:26 <ksf> I don't think Ptr has a functor instance.
12:29:27 <ben> My goal is to draw an rgba bitmap on a transparent clickthrough surface over other processes' windows and shit
12:29:33 <xil> I have this example: pixels  <- castPtr `fmap` S.surfaceGetPixels surface
12:29:45 <xil> oh IO is the Functor
12:29:49 <Saizan> yeah
12:29:51 <zezikaro> could anyone help me with this error please http://ideone.com/lX1fm
12:30:27 <xil> oh that's kind of awesome. So I can do a bunch of pure operations on the results of IO operations by using fmap?
12:30:30 <monochrom> in the IO case it is: do { x <- S.surfaceGetPixels surface; return (castPtr x) }
12:30:32 <ksf> xil, that's equivalent to pixels <- surfaceGetPixels surface >>= return . castPtr
12:30:49 <monochrom> yes, it saves creating the name "X"
12:30:51 <ksf> @quote stereo
12:30:51 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
12:30:52 <monochrom> err, "x"
12:30:58 <ksf> @quote haskell.stereo
12:30:58 <lambdabot> No quotes match. That's something I cannot allow to happen.
12:31:04 <ksf> @quote stereo
12:31:04 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
12:31:13 <ksf> uhm.
12:31:13 <xil> that's kind of awesome, haha. Thanks =]. I love Haskell
12:31:23 <ksf> someone else remind lambdabot of that quote.
12:32:04 <monochrom> "get an input line from the user, count how many 'x's are in it": (length . filter ('x' ==)) `fmap` getLine
12:32:34 <xil> that is why Haskell is awesome
12:33:10 <monochrom> perhaps the quote is lost
12:33:17 <monochrom> @quote fugue
12:33:18 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
12:33:29 <monochrom> mine is not lost, and I don't know why
12:33:34 <ion> Banach Tyvski?
12:34:08 <alistra> Tarski
12:34:19 <monochrom> fugue: http://www.youtube.com/watch?v=N2JFgfc7c70
12:34:20 <ben> Tue Oct 23 2007 22:29 < oerjan> @quote stereo < lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused
12:34:23 <ben> heh
12:34:46 <monochrom> fugue is a more accurate description anyway :)
12:35:05 <ben> "Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!" okay, I expected somethin more different
12:35:26 <ben> I didn't realise I had logs of #haskell going back to 2007. You'd think I would be better at it after so long
12:35:38 <xil> uh...hmmm...so I have "a `fmap` b c" and rather than that translating to "fmap a b c" it translates te "fmap a (b c)". Why is that? Can infix operators not have more than 2 inputs?
12:35:40 <monochrom> next time someone is unhappy about too-many-chefs, please remind me to bring up the fugue youtube!
12:36:13 <ksf> space binds tightest.
12:36:19 <monochrom> you can have "fmap a b c" but it means "(fmap a b) c". are you sure you want that?
12:36:29 <ksf> it's translating to a `fmap` (b c)
12:36:51 <ion> Btw, <$> is the same as `fmap`.
12:37:06 <monochrom> in any case, "infix" has "2 parameters" written all over it
12:37:11 <roconnor> http://en.wikipedia.org/wiki/Monstrous_moonshine
12:37:25 <ion> > ("foo" `length`)
12:37:26 <lambdabot>   3
12:37:38 <xil> oh the infix binds last, so there's no way to have an infix operator with 3 parameters?
12:37:57 <ion> xil: (foo `bar` baz) thirdParameter
12:37:59 <monochrom> at any rate, in your concrete example, you absolutely want fmap castPtr (getpixels surface)
12:38:26 <monochrom> I have never heard of 3-operator infix. in any language, not just haskell.
12:38:39 <monochrom> (how would you write it?)
12:38:47 <xil> monochrom: oh of course. But in another program I wrote an infix ternary function that I would have misused without ion's clarification
12:39:16 <tigger_> I'm using a package on hackage, and installed it with cabal install, but I've found that there is a piece of unfriendly code, I have found a way to fix that code, but I am unsure how I should inject my changes and rebuild that module on my system and then load the modified version for testing. I'm also not really sure where those modules actual reside on my computer (just used defaults). any help is much appreciated!
12:39:24 <xil> (?:) True a _ = a
12:39:24 <xil> (?:) False _ b = b
12:39:30 <ksf> monochrom, there's a blog post about ?: in haskell, somewhere.
12:40:05 <xil> I also have a version where instead of Bool -> a -> a -> a it is Bool -> (a,a) -> a
12:40:08 <ksf> tigger_, in the project's base directory, type "cabal install"
12:40:20 <ksf> ...and play around a bit with ghc-pkg.
12:40:30 <ion> > I’d find a -> a -> Bool -> a more useful.
12:40:30 <lambdabot>   <no location info>: lexical error at character '\8217'
12:40:53 <xil> hadn't thought about that approach
12:41:32 <ksf> I call that function "cap". as in foo >>= cap consequent alternative
12:41:58 <monochrom> the parse tree for "(b ?: a) b" still gives only 2 children to ?:. I am talking about the parse tree, not the unfortunate notation "(b ?: a) b" itself. fudge precedences all you want, makes no difference to the parse tree
12:43:03 <tigger_> ksf: will give it a try, I downloaded it from github, but its complaining about a ton of build errors, hmmm... will try and figure out what the problem is
12:43:42 <ksf> tigger, try "cabal unpack <foo>"
12:44:15 <ksf> that's going to unpack the version it'd install, which might just have less bugs than the git one.
12:44:35 <chrisdone> what's up
12:47:55 <tigger_> ksf: great! thanks! is there any difference between cabal unpack and just git clone, (i was referring to https://github.com/twittner/zeromq-haskell), maybe just the github version isn't stable?
12:50:58 <roconnor> (?:) a -> a -> Bool -> a seems like it would make reasonable infix notation
12:51:05 <mightybyte_> tigger_:  Cabal unpack only gets you a single released version from hackage.
12:51:13 <zezikaro> is haskel compiled?
12:51:14 <roconnor> though I'm not so sure about the sumbol
12:51:26 <roconnor> zezikaro: it can be compiled or interpreted
12:51:34 <zezikaro> 'generally' what is it?
12:51:39 <roconnor> genreally compiled
12:51:41 <zezikaro> ty
12:51:58 <tigger_> mightybyte_: okay, gotcha
12:52:16 <ion> I’d go with “bool” to follow the style of “maybe” and “either”.
12:55:46 <chrisdone> roconnor: ion: fwiw… don't think anyone's using it tho http://hackage.haskell.org/packages/archive/higherorder/0.0/doc/html/Data-Bool-Higher.html
12:56:29 <ion> Thanks
12:56:40 <monochrom> eh? it's chrisdone!
12:56:49 <chrisdone> where‽ oh
12:57:18 <chrisdone> hi monochrom :) what's happening?
12:57:41 <monochrom> doing nothing
12:59:03 <chrisdone> party time
12:59:11 <chrisdone> oh
13:02:02 <chrisdone> i have a little thing i'm dabbling with, http://chrisdone.com:10001/ you control the DOM from haskell like this http://hpaste.org/55698 and it seems sufficiently responsive for UI. can't make games with it but a web app should be ok. anyway, i'm having a hard time thinking of a particularly dynamic demonstration web app to make with it, to test how it feels. any ideas?
13:03:11 <monochrom> convert my http://www.vex.net/~trebla/humour/missing_dollar.html to your scheme
13:03:34 * chrisdone peers over it
13:03:43 <monochrom> also my http://www.vex.net/~trebla/homework/extended-euclid.html
13:03:49 <ksf> why does button1 lag but button2 not?
13:05:25 <ksf> chrisdone, make a haskell->js compiler.
13:05:36 <ksf> (yet another one)
13:05:39 <chrisdone> ksf: you can see in the code, it's an intentional 1s delay to test event scheduling
13:05:46 <ksf> oh.
13:06:02 <chrisdone> ksf: i tried to compile uhc today but it gave linker errors. i'll try again later
13:06:13 <xil> does anyone know if SDL packs pixels in BGR by default? And if so how to change it?
13:06:27 <ksf> there's also javascript as an edsl
13:06:40 <ksf> that is, lifting a portion of haskell to javascript.
13:07:09 <ksf> ...not the whole solution, but great if you're sick and tired of writing the same input verification code in two languages.
13:07:57 <ksf> does pnacl have dom access by now?
13:11:12 <chrisdone> monochrom: i've read the first one three times and it's confused me each time. i'm going to read it again
13:11:51 <chrisdone> ksf: oh, thank you for mentioning that. i saw that ages ago and then forgot the name, tried googling and couldn't find it. if that project takes off it will be Good™ for the web
13:14:28 <mightybyte_> Is it possible to write explicit type signatures for the last two functions here?  https://gist.github.com/1519792
13:15:34 <aristid> mightybyte_: what's wrong with the type sigs suggested by ghc?
13:15:49 <aristid> oh.
13:16:05 <aristid> sorry, should have read the full comment :D
13:16:10 <mightybyte_> aristid: When I put them in, GHC gives me an error.
13:16:38 <aristid> mightybyte_: you have to use type families in HasAcid.
13:16:49 <aristid> or live with that problem
13:16:53 <mightybyte_> Seems like it might be something along the lines of the Read/Show problem.
13:17:15 <aristid> hmm
13:17:38 <mightybyte_> Is there a way to specify the type signature of st inside the functions in terms of the same type variables in the outside type signature?
13:17:39 <aristid> mightybyte_: or where does the st in HasAcid s st actually come from? fundep?
13:18:59 <mightybyte_> It doesn't have to be a fundep.
13:19:04 <chrisdone> monochrom: so the question is a trick? adding what was spend and what was subtracted from the change shouldn't add up. is that the cleverness of it or am i missing something?
13:19:43 <mightybyte_> aristid: …although maybe it could be.
13:20:19 <mightybyte_> which I guess also suggests a type family implementation
13:20:34 <aristid> mightybyte_: what's the type of A.createCheckpoint ?
13:20:56 <mightybyte_> http://hackage.haskell.org/packages/archive/acid-state/0.6.2/doc/html/Data-Acid.html#v:createCheckpoint
13:22:47 <aristid> mightybyte_: i don't see anything actually fixing in the st there. is it just being defaulted to ()?
13:25:14 <mightybyte_> aristid: In A.createCheckpoint?  I think it just gets whatever type is appropriate for the context.
13:25:56 <mightybyte_> I guess I can just leave it as-is since it works fine without a type signature.
13:26:02 <aristid> mightybyte_: and where does it get that type from? i _am_ prone to blindness, so maybe i just missed it
13:26:18 <mightybyte_> Is there a pragma that lets me suppress those two warnings?
13:26:29 <chrisdone> monochrom: anyway, this is a nice little example to try, thanks
13:26:33 <aristid> mightybyte_: if it's actually just () there, you can explicitly tell it to use () inside the function
13:26:50 <mightybyte_> It comes from whatever the inferred type parameter is for AcidState.
13:27:56 <aristid> and how is it inferred?
13:28:26 <aristid> AcidState itself is just a data, so it can't infer anything there
13:29:13 <chrisdone> monochrom: did you just rename the title from The Extra Dollars to The Missing Dollars? either that or i'm going barmy
13:30:00 <mightybyte_> aristid: Well, the m from my function will have a (MonadState s) instance.  And then that s will have a (HasAcid s) instance.
13:30:11 <mightybyte_> Hmmmm, then I guess it does need a functional dependency.
13:30:38 * hackagebot xournal-render 0.4.0.0 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.4.0.0 (IanWooKim)
13:32:50 <aristid> mightybyte_: yeah although in order not to bleed the type out everywhere, type families might be nicer
13:33:06 <Sgeo> Could one mix enumerators and FRP? How would that even make sense?
13:33:09 <monochrom> chrisdone: you have correctly assessed the nature of the "where is the missing dollar?" question. I use javascript to create a large, indexed family of parodies, in essence. I think that a family of parodies is the most effective explanation.
13:33:32 <mightybyte_> aristid: right
13:33:47 <monochrom> and yes, the javascript program can switch the title, too.
13:34:36 <monochrom> more precisely what's in the <h1>
13:35:05 <chrisdone> monochrom: that's cute :)
13:35:40 * hackagebot hxournal 0.6.1.0 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.1.0 (IanWooKim)
13:35:47 <mike-burns> parseargs vs cmdlib vs cmdargs: is there something I should keep in mind when deciding which to use?
13:36:12 <chrisdone> if you're a pirate, use cmdaaaargs
13:36:27 <mike-burns> Hah.
13:37:00 <monochrom> hahahha
13:37:19 <monochrom> @remember chrisdone if you're a pirate, use cmdaaaargs
13:37:19 <lambdabot> I will remember.
13:37:50 <monochrom> and oh, did you see my great invention yesterday?
13:37:57 <monochrom> @quote monochrom christmas
13:37:57 <lambdabot> monochrom says: "on the 4th day of christmas my true love sent to me, 4 cabal failures, 3 cabal failures, 2 cabal failures, and a cabal failure"
13:38:05 <mike-burns> Hahah.
13:38:07 <chrisdone> hahaha
13:40:12 <BMeph> monochrom: In a parse tree! ;þ
13:41:31 <chrisdone> BMeph: fiiiiiive ByyyyteStriiings
13:42:16 <monochrom> "cabal failure in a parse tree" is a bit too many syllables. however, I did think of: 5 type errors, 4 type errors, 3 type errors, 2 type errors, and a type error in a parse tree
13:42:34 <monochrom> and also: on the 1st day ... a parse error in the parse tree
13:42:49 <mike-burns> cabal failures are rather topical right now.
13:43:02 <mike-burns> They're the record syntax complaints of early 2012.
13:43:17 <monochrom> but cabal failure is more humorous than all other problems you ever meet
13:45:23 <Saizan> shouldn't it be cmdarrrrgs ?
13:45:33 <mike-burns> Well it was already funny.
13:45:35 <monochrom> yes
13:46:06 <monochrom> oh well, I didn't notice it back then
13:47:58 <mike-burns> Going to try cmdlib, I guess.
14:10:33 <_Mikey> I get "ExitFailure 1" when I Cabal install haskell-src-exts-1.11.1 ;/
14:10:39 <_Mikey> anyone had this before?
14:13:41 <lcfrs> jaspervdj: i don't know whether to commend you for working on websockets over christmas day or tell you to relax
14:13:47 <astor> when evaluating a case statement in ghc, and finding which constructor to map to, is the pointer tags inspected, or the header of the pointer-to object?
14:14:10 <astor> s/pointer-to/pointed-to/
14:17:07 <Roark_> can someone give me a pointer on how to a write a QuickCheck arbitrary instance for  Data.Set
14:22:23 <xil> hi. Am I right that there's no Functor instance for IORef?
14:24:28 <kmc> xil, sorry, I was afk
14:25:00 <xil> kmc: oh no problem. Some other people understood the question and helped out =]
14:25:10 <kmc> yeah.  as far as i can tell that 'Pixel' type is unexported, which is weird
14:25:18 <kmc> but you can cast the pointer to something else (Ptr Word8 here)
14:25:30 <kmc> xil, correct.  IORef can't be a functor
14:25:37 <kmc> a read-only IORef could be a functor
14:25:38 * hackagebot gps2htmlReport 0.3 - GPS to HTML Summary Report  http://hackage.haskell.org/package/gps2htmlReport-0.3 (RobStewart)
14:25:42 <kmc> and a write-only IORef could be a contravariant functor
14:26:39 <xil> the one thing I noticed is that your example tries packing the pixels as RGB, but it comes out backwards, making me think they are packed as BGR. Know anything about that?
14:26:51 <kmc> not really
14:27:05 <kmc> I don't know if SDL specifies the exact pixel format
14:27:14 <xil> okay, doesn't matter too much
14:27:14 <jaspervdj> lcfrs: :-)
14:27:15 <Saizan> _Mikey: there should be a proper error message in the log
14:27:15 <kmc> i think it doesn't, but it gives you functions to ask the surface what format it is
14:27:27 <kmc> since different hardware will support different formats
14:27:31 <Philonous_> Has someone here done the "SOftware foundations" exercises?
14:27:48 <Saizan> _Mikey: anyhow you're likely to need "cabal install happy" first, and make sure the happy exe is in your $PATH
14:27:54 <kmc> Roark_, instance (Arbitrary a) => Arbitrary (S.Set a) where { arbitrary = S.fromList `fmap` arbitrary }
14:27:58 <kmc> something like that
14:28:03 <kmc> Philonous_, I've done most of them
14:28:05 <xil> also, I realized I don't need fmap for IORef because there's modifyIORef
14:28:23 <kmc> well they do different things
14:28:34 <Philonous_> kmc:  I wonder what they expect me to do here: http://www.cis.upenn.edu/~bcpierce/sf/Poly.html#lab98
14:29:00 <xil> I wanted the functionality of modifyIORef. Just learned about fmap so I'm abusing it, haha
14:29:03 <kmc> hmm, I don't think I did this one :/
14:29:38 <kmc> xil, :)
14:29:52 <kmc> fmap is very useful
14:30:03 <kmc> the module Control.Applicative defines an infix operator for fmap, namely <$>
14:30:15 <kmc> > succ <$> [1,2,3]
14:30:16 <lambdabot>   [2,3,4]
14:30:32 <kmc> > map (succ <$>) [Just 3, Nothing]
14:30:33 <lambdabot>   [Just 4,Nothing]
14:30:42 <Sgeo> I think Data.Functor also defines the operator? Control.Applicative might be more useful though, since it also defines <*>
14:30:57 <kmc> Sgeo, ah, yeah, it does
14:31:04 <otters> you guys don't get very many n00bs or script kiddies in here, do you?
14:31:23 <Philonous_> kmc: The thing is, I'm stuck with "prod_curry (prod_uncurry f) x y = f x y" And I don't see how to do anything about that at all. "compute" just knocks the whole thing out, but it wasn't introduced yet.
14:31:23 <kmc> otters, don't know what you mean, but we get a ton of Haskell beginners
14:31:37 <Sgeo> "compute"?
14:31:41 <Sgeo> @hoogle compute
14:31:41 <lambdabot> Test.QuickCheck.State computeSize :: State -> Int -> Int -> Int
14:31:43 <otters> okay fair point
14:31:57 <kmc> Sgeo, Philonous_ is doing Coq exercises, see link above
14:32:00 <Philonous_> Sgeo:  Ah, it's a coq tactics
14:32:04 <Sgeo> Ah, ok
14:32:20 <kmc> otters, why do you ask?
14:32:35 <otters> just comparing this channel to some of the other ones I hang out in
14:32:44 <otters> like ##php
14:32:53 <otters> there's a striking contrast
14:32:58 <kmc> yeah
14:33:02 <Sgeo> #nethack occasionally gets people who think it's about hacking.
14:33:06 <kmc> so does #hackage :D
14:33:08 <otters> heh
14:33:25 <Saizan> Philonous_: so you're worried that the proof is too easy?
14:33:36 <kmc> otters, people mainly learn Haskell for fun, so they're usually fairly motivated people, who already know a bit about programming
14:33:44 <otters> yeah
14:33:53 <Philonous_> Saizan:  I'm worried I'm writing something down that I don't understand what it does. The proof itself is trivial.
14:33:54 <kmc> we get some who are new to programming, but they generally don't stick around long unless they are very ambitious
14:34:06 <otters> or too lazy to give up :P
14:34:08 <Philonous_> Saizan:  It's a coq-driving question
14:34:10 <kmc> we also get people who are taking university classes, and they're occasionally obnoxious, but there aren't too many
14:34:59 <kmc> but Haskell isn't that popular in industry, so we don't see too many "HALP I NEED 2 MAEK WEBSITE!?!?!?!?"
14:35:04 <Philonous_> Saizan:  Which, I realize, doesn't exactly belong here. Apologies.
14:35:41 <kmc> there is a coq channel
14:35:50 <kmc> they helped me more than once with software foundations :)
14:36:11 <drdo> coq is quite fun to play around with
14:36:34 <Philonous_> kmc:  I asked there 20 minutes ago.
14:37:19 <Saizan> Philonous_: ah, ok, i just misunderstood, i don't know about introduction but the idea that compute is the only thing you can do with such a goal makes sense to me, even if i've never used coq myself
14:38:36 <Philonous_> Saizan:  I'm only using it because of this online book. (But I'm liking it)
14:40:38 * hackagebot concurrent-extra 0.7.0.3 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.3 (BasVanDijk)
14:49:54 <_Mikey> Cheers Saizan!
14:51:17 <Saizan> cheers :)
14:51:38 <_Mikey> but
14:51:53 <_Mikey> $Path?
14:53:23 <Saizan> _Mikey: which OS are you on?
14:53:30 <HugoDaniel> hello
14:53:33 <_Mikey> debian
14:54:31 <Saizan> $PATH is the environment variable which contains the directories where to look for executables, colon separated
14:55:06 <_Mikey> hmm I know where that is on windows XD
14:55:24 <_Mikey> maybe it needs to be in the bin folder
14:55:30 <Saizan> cabal installs exes in $HOME/.cabal/bin by default, so you've to add that
14:55:56 <_Mikey> ah ok
14:56:09 <_Mikey> I just cabal info happy
14:56:18 <_Mikey> and apparently my version is unknown
14:56:24 <_Mikey> I just installed it ;/
14:56:38 <Saizan> well, you could just use "export PATH=$HOME/.cabal/bin:$PATH" to alter $PATH for your current shell
14:57:06 <_Mikey> ok cheers
14:57:15 <Saizan> and/or put the same command in .bashrc or .bash_profile (i never remember which is the more adequate) to make that permanent
15:05:38 <hpc> Saizan: i always use .bashrc
15:05:44 <hpc> it's served me well enough
15:10:38 * hackagebot hamlet 0.10.6 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.6 (FelipeLessa)
15:19:21 <mreh> what's the suggested way to interface reactive with user input
15:37:11 <ksf> > ("foo" ++ "bar" ++) "baz"
15:37:12 <lambdabot>   The operator `L.++' [infixr 5] of a section
15:37:12 <lambdabot>      must have lower precedence...
15:37:21 * ksf thinks that ought work.
15:37:57 <alistra> infixr
15:38:11 <ksf> > (++ "foo" ++ "bar") "baz"
15:38:13 <lambdabot>   "bazfoobar"
15:38:16 <alistra> see
15:39:02 <ksf> that still doesn't explain why it doesn't work. It's unambigious, as far as I can see.
15:39:18 <alistra> (++ ("foo" ++ "bar"))
15:39:32 <alistra> ("foo" ++ ("bar" ++ ?))
15:39:50 <ksf> well, start to parse from the section operator.
15:40:04 <alistra> what's a section operator
15:40:05 <ksf> ...ignoring its precedence completely.
15:40:20 <ksf> ...the operator of a section.
15:40:29 <ksf> that is, of a partial section in this case.
16:02:15 <hughfdjackson> i'm reading a paper on functional game programming
16:13:53 <djahandarie> Hmm, so, I got "<interactive>: connect: timeout (Connection timed out)" in ghci, and that seemed to entirely kill the thread that was polling a website every once in awhile... is there any way to protect against that? As in, catch that error and have some softer fail without killing the thread.
16:14:39 <kmc> using Control.Exception?
16:14:45 <ByronJohnson> @hoogle catch
16:14:45 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
16:14:45 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
16:14:45 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
16:15:39 * hackagebot HTTP 4000.2.2 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.2 (GaneshSittampalam)
16:16:14 <djahandarie> Hmm, are you sure that is an Exception I can catch with catch? It looks like something else...
16:17:44 <kmc> what else would it be
16:17:56 <kmc> anyway, just try it
16:20:13 <siracusa> What was that extension called to allow (n + 1) in patterns?
16:20:43 <Silvah> Heretic detected!
16:20:54 <Bynbo7> siracusa: 'terrible' :P
16:21:19 <alistra> lol what's wrong with those
16:21:22 <alistra> they're awesome
16:21:38 <Silvah> Another heretic.
16:21:43 <alistra> come on
16:21:50 <Sgeo> siracusa, I know it's called n+k patterns
16:21:51 <dolio> If you understood them, you'd realize how awful they are.
16:21:56 <kmc> NPlusKPatterns
16:21:59 <alistra> Integers are isomorphic to lists
16:22:07 <alistra> constructor wise
16:22:14 <kmc> i don't think it's much more terrible than numeric pattern-matching otherwise
16:22:15 <alistra> so why not pattern match on them
16:22:16 <Axman6> eh?
16:22:18 <alistra> nearly~
16:22:19 <siracusa> Thanks, kmc
16:22:30 <kmc> alistra, standard Haskell does not say what the constructors of Integers are
16:22:48 <alistra> i don't say to do it implementation wise
16:22:51 <alistra> lol
16:22:58 <alistra> you can term-rewrite it to a
16:23:10 <kmc> i'm not talking about implementation
16:23:10 <alistra> normal definition
16:23:34 <alistra> i was saying you can think that works similiary
16:23:37 <alistra> i was saying you can think that works similiar
16:23:37 <kmc> you said "Integers are isomorphic to lists constructor wise"; that's not a true statement about standard Haskell
16:23:40 <kmc> ok
16:23:44 <tech2> alistra: are you really considering treating integers as peano numbers?
16:23:47 <alistra> i mean about like abstract
16:23:52 <alistra> Succ ~ Cons
16:23:55 <alistra> or whatever
16:24:03 * tech2 shudders involuntarily
16:24:13 <alistra> i'm not saying be all like agda
16:24:13 <kmc> [()] has a lot more ⊥'s in it than Integeer
16:24:19 <alistra> but those patterns are cool
16:24:24 <alistra> if you need them
16:24:38 <kmc> anyway you can define inductive naturals as a plain old Haskell type
16:24:41 <kmc> and match them that way
16:24:52 <kmc> you can also use the GHC ViewPatterns extension to generalize NPlusKPatterns
16:25:10 <alistra> i know, but it will be slow as agda
16:25:16 <alistra> :D
16:25:37 <alistra> still don't know what's wrong about them
16:25:58 <kmc> much slower, because Agda has implementation magic for naturals
16:26:33 <alistra> f (n+k) = ... <=> f n' = let n = n' -k in case n of border cases/normal cases
16:26:55 <dolio> Wrong.
16:27:04 <alistra> why?
16:27:08 <dolio> That's not how it works.
16:27:17 <wavewave> spent all the chirstmas day long for haskell coding
16:27:26 <alistra> wavewave: best christmas ever
16:27:47 <wavewave> I am now in the God's nirvana.
16:27:52 <luite> spent all the christmans day skiing fresh powder :p
16:28:49 <alistra> dolio: how does it work
16:29:17 <dolio> It converts your type to an Integer, does some calculations, and then converts it back to whatever type you had originally.
16:29:38 <alistra> what
16:29:48 <alistra> i assumed n+k was on integers
16:29:59 <wavewave> lots of lesson learned while developing a big program
16:30:04 <dolio> It's on any Integral type.
16:30:29 <alistra> and what's the rationale of the conversion?
16:35:05 <kmc> alistra, see Haskell 98 Report §3.17.3, figure 4, case (s)
16:35:06 <kmc> http://www.haskell.org/onlinereport/exps.html#case-semantics
16:35:21 <kmc> case v of { x+k -> e; _ -> e' }  =   if v >= k then (\x -> e) (v-k) else e'
16:35:44 <kmc> that doesn't say anything about converting to Integer
16:36:47 <kmc> it should work on any type which is an instance of Ord (for (>=)) and Num (for fromInteger and (-))
16:37:33 <kmc> but the "Informal Semantics" section also says "An n+k pattern can only be matched against a value in the class Integral."
16:40:53 <kmc> so i'm still a little confused
16:41:04 <kmc> ghc -XHaskell98 does indeed require the Integral constraint
16:41:27 <kmc> though recent GHC has stopped caring what the Report says
16:41:52 <ski> ksf : i think the idea is that if you have `(blah ++) bleh', that ought to be the same as `blah ++ bleh' -- to show they are the same in the case above, you need associativity
16:41:59 <kmc> ghc-7.4 -XHaskell98 drops the Eq, Show superclass constraints on Num
16:42:10 <kmc> even though this is against the spec and breaks existing code
16:42:18 <kmc> (reported in the wild, building standard libraries)
16:42:36 <dolio> Is -XHaskell98 supposed to pull in different libraries?
16:42:52 <kmc> i think it un-hides the haskell98 package
16:43:01 <kmc> but anyway, it's supposed to give you a Haskell 98 compiler ;P
16:43:37 <dolio> A Haskell 98 compiler will compile a prelude that doesn't have Eq and Show as superclasses of Num.
16:43:53 <kmc> but it's supposed to import a prelude that has those, by default
16:44:16 <kmc> Haskell has never been super clear about the degree to which library compliance is part of the spec
16:44:37 <kmc> but it seems especially important for Num.  it's in Prelude, which is imported automatically, and it's used in the desugaring of built-in constructs
16:44:48 <kmc> (by the way, Num still has those superclasses in H10)
16:45:29 <kmc> so we have these haskell98 and haskell2010 packages which are supposed to provide what the Reports say
16:45:37 <kmc> and mainly reexport stuff from 'base', etc
16:46:25 <kmc> i guess the problem is that code built against the Haskell 2010 Num wouldn't interoperate with libraries built against the GHC Num
16:46:49 <Sgeo> o.O
16:46:55 <Sgeo> Why wouldn't it?
16:47:14 <rpglover64> I have a question about ST and STRefs. In particular I'm trying to write an interpreter in haskell for a simple language that has state, and I'd like to have references as values; Does this mean that my value type has to have the s parameter, or can I hide it inside a forall somewhere inside the type?
16:48:54 <kmc> rpglover64, you can't really hide it
16:49:19 <kmc> rpglover64, that 's' has to be exposed, so that the compiler can check that everything is using 'the same s'
16:49:22 <ski> you could abstract over the reference type (so that you can then plug in `IORef' or `STRef s')
16:49:31 <kmc> this is what makes it safe to invoke runST
16:49:55 <rpglover64> kmc: That's what I thought; it makes the code less pretty, though :(
16:49:58 <kmc> indeed
16:50:07 <rpglover64> ski: How do you mean?
16:50:40 <ski> instead of `data Value s = ..(STRef s (...))..', you could do `data Value ref = ..(ref (..))..'
16:50:56 <ski> then you recover the original by using `Value (STRef s)'
16:51:04 <kmc> Sgeo, well, haskell2010:Prelude.Num would be a different class from base:Prelude.Num
16:51:15 <kmc> if you write an instance for one, it does not satisfy a constraint for the other
16:51:42 <rpglover64> ski: ah; it's not any neater. I'll only be using ST anyway.
16:52:31 <ski> rpglover64 : if you try this, you will probably want a class like `class Monad m => MonadRef ref m where newRef :: a -> m (ref a); readRef :: ref a -> m a; writeRef :: ref a -> a -> m ()'
16:52:37 <ski> ok
16:53:05 <rpglover64> ski: like this, right: http://hackage.haskell.org/packages/archive/ref-fd/0.3.0.1/doc/html/Control-Monad-Ref.html
16:53:39 <ski> yeah, except i'm not sure i like the FD there
16:54:19 <rpglover64> there's also a tf version
16:56:53 <ski> rpglover64 : yeah, that's basically the same thing :)
16:59:21 <ben> @pl \[a, b, c] -> f a b c
16:59:21 <lambdabot> (line 1, column 2):
16:59:21 <lambdabot> unexpected "["
16:59:21 <lambdabot> expecting pattern
16:59:34 <ben> @pl \(a:b:c:[]) -> f a b c
16:59:34 <lambdabot> (line 1, column 9):
16:59:35 <lambdabot> unexpected "["
16:59:35 <lambdabot> expecting "()", natural, identifier, "_" or "("
17:02:02 <randomperson> Is there a type class for finite data?
17:02:16 <rpglover64> Bounded + Enum?
17:02:29 <randomperson> That might do it
17:02:39 <kmc> what do you want to do with your finite data
17:03:07 <kmc> there's also http://hackage.haskell.org/packages/archive/enumerable/0.0.3/doc/html/Data-Enumerable.html
17:03:08 <randomperson> Lets say I have a function from some finite type to some finite type
17:03:17 <randomperson> say Int to bool
17:03:35 <hpc> randomperson: sounds like enumerable to me
17:03:43 <randomperson> then I want to be able to exaustively check what that function does.
17:03:54 <mike-burns> Like with QuickCheck?
17:03:59 <kmc> randomperson, the 'enumerable' library has that
17:04:10 <randomperson> I'll check it out.
17:05:49 <ski> @let listCase :: r -> (a -> [a] -> r) -> ([a] -> r); listCase nil cons as = case as of [] -> nil; a:as -> cons a as
17:05:50 <lambdabot>  Defined.
17:05:59 <ski> @let unCons :: (a -> [a] -> r) -> ([a] -> r); unCons = listCase (error "{unCons _ []}")
17:05:59 <lambdabot>  Defined.
17:06:07 <hpc> that won't add it to @pl
17:06:20 <ski> @type \f -> unCons (\a -> unCons (\b -> (unCons (\c -> const (f a b c)))))
17:06:21 <lambdabot> forall a a1. (a -> a -> a -> a1) -> [a] -> a1
17:06:33 <ski> @type \f -> unCons (unCons . unCons .: const .:: f)
17:06:33 <lambdabot> forall a a1. (a -> a -> a -> a1) -> [a] -> a1
17:06:38 <hpc> er, nvm; got nicks confused
17:06:44 <ski> @type unCons . unCons .: unCons .:: const .::: id
17:06:45 <lambdabot> forall a a1. (a -> a -> a -> a1) -> [a] -> a1
17:07:02 <nand`> @type (.:)
17:07:07 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:07:07 <ski> ben : happy ?
17:07:07 <hpc> :D (.::)
17:07:13 <hpc> glad im not the only one that uses that
17:07:46 * ski was the one who suggested using `.:',`.::',`.:::',&c. ..
17:07:54 <mike-burns> @type (.::)
17:07:55 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:08:09 <ski> (i'm not sure whether that's something to be proud of, though)
17:08:16 <nand`> where is .: defined?
17:08:20 <ski> in lambdabot
17:08:25 <hpc> nand`: a lambdabot exclusive
17:08:25 <nand`> oh
17:08:33 <hpc> (.:) = fmap fmap fmap
17:08:39 <ben> :D
17:08:41 <nand`> and .::?
17:08:44 <hpc> it's the "compose twice" function
17:08:46 <ski>   (.) = (.) . (.)  -- the original definition
17:08:50 <ski> er
17:08:52 <hpc> and (.::) is the "compose thrice" function
17:08:52 <ski>   (.:) = (.) . (.)  -- the original definition
17:08:58 <hpc> (.:) = fmap .: fmap
17:09:04 <ski>   (.::) = (.) . (.) . (.)  -- &c.,&c.
17:09:09 <hpc> er, (.::) = fmap .: fmap
17:09:24 <ski> @type let (.) = (Prelude..) in (.) . (.)
17:09:24 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:09:27 <ski> @type let (.) = (Prelude..) in (.) . (.) . (.)
17:09:27 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
17:09:29 <ski> @type let (.) = (Prelude..) in (.) . (.) . (.) . (.)
17:09:30 <lambdabot> forall a a1 a2 b c a3. (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
17:09:38 <ski> @type let (.) = fmap in (.) . (.)
17:09:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:09:40 <ski> @type let (.) = fmap in (.) . (.) . (.)
17:09:41 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:09:42 <ski> @type let (.) = fmap in (.) . (.) . (.) . (.)
17:09:43 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
17:09:51 <monochrom> "on the 6th day of christmas my true love sent to me, fmap fmap fmap fmap fmap fmap..."
17:09:57 <ski> (the latter is what lambdabot uses)
17:10:27 <hpc> monochrom: what did you get on the ωth day?
17:10:49 <monochrom> waiting for that day, actually :)
17:10:54 <hpc> :D
17:21:21 <inetic> hi, long time ago I used to use perl for work, at that time I was quite impressed by the CPAN library and the way one can install packages `perl -M CPAN -e "install XYPackage"`, is there something similar in haskell? As I understand haskell-platform only groups a small number of packages. What my distro provides (ArchLinux) is often broken.
17:21:44 <mauke> wtf
17:21:49 <cmccann> inetic, hackage.haskell.org/packages/archive/pkg-list.html
17:21:56 <mauke> you know you can just say 'cpan XYPackage', right?
17:22:10 <kmc> inetic, yes, 'cabal install foo' will download the package named 'foo' from http://hackage.haskell.org/packages/archive/pkg-list.html
17:22:13 <inetic> mauke, didn't know :-)
17:24:24 <inetic> thanks guys, gonna try. (I almost feel embarased I didn't know :) )
17:24:32 <kmc> inetic, also Arch is supposed to have good support for Haskell packages
17:24:38 <kmc> there's a way to install them through pacman as well
17:25:00 <kmc> looks like Hackage has about 15% as many packages as CPAN
17:25:08 <kmc> i'll wager Haskell has far fewer than 15% as many users as Perl
17:25:10 <kmc> what to make of this
17:25:42 <hpc> kmc: i would like to see those statistics filtered by date of activity
17:25:53 <inetic> kmc, yes, arch's pacman it's often good, but once in a while I try to install something and like now the dependencies for haskell-grapefruit are broken
17:26:01 <hpc> filter out contributors and packages that have done nothing over the past year
17:26:05 <kmc> inetic, well a lot of packages on hackage are broken too
17:26:16 <kmc> hpc, why?
17:26:44 <mike-burns> I'm more interested in the size of their Acme.
17:27:06 <kmc> anyway i would be interested to see more comparisons over time
17:27:10 <hpc> kmc: because cpan is fairly old, users can upload multiple packages, and older packages break
17:27:12 <kmc> the entire hackage upload log is available at http://hackage.haskell.org/packages/archive/log
17:27:23 <hpc> recent activity better-reflects the health of the community
17:27:48 <kmc> oh
17:27:53 <kmc> well measuring the health of the community is one thing
17:28:04 <hpc> an over-time statistic would be neat too
17:28:16 <kmc> measuring the ease of reusing existing code is another
17:28:28 <kmc> both are hard to measure from raw upload statistics
17:28:33 <hpc> agreed
17:28:54 <kmc> but i think it's bad to ignore packages which haven't had an upload in a year
17:29:14 <hpc> i would expect perl to be better about code reuse, simply because the weak type system makes everything a "universal remote", as it were
17:29:40 <kmc> if the library works well, is tested, does what people need, why should it need a new version every year
17:29:49 <hpc> and also because perl favors "glue" packages, which are where a lot of the hard work is anyway
17:29:57 <kmc> lots of churn on important libraries is a bad sign
17:30:25 <kmc> in Haskell if you try to use code from 5 years ago, it's pretty likely several things will be broken
17:30:29 <kmc> i think that's less true in Perl
17:30:49 <hpc> i think the opposite will become increasingly true as perl6 grows
17:30:56 <mike-burns> as?
17:31:11 <kmc> oh, I'm treating perl6 as an unrelated language here
17:31:14 <mike-burns> Did it come out today? It is Christmas, afterall.
17:31:15 <inetic> I think thats a different topic :-)
17:31:29 <hpc> inetic: don't worry, people can be on topic in -blah :P
17:31:45 <inetic> :-)
17:32:17 <inetic> If I may, have you guys tried: http://searchpath.org/ ?
17:32:43 <kmc> i haven't
17:38:16 <kmc> hpc, what do you mean by "perl favors glue packages"?
17:38:23 <kmc> does haskell favor glue packages and if not, should we?
17:38:45 <hpc> kmc: haskell doesn't seem to, and dunno, respectively
17:39:01 <chrisdone> monochrom: so this took a while but i'm up to other stuff, anyway http://chrisdone.com:10002/ https://github.com/chrisdone/ji/blob/master/examples/MissingDollars.hs code-wise i'm happy with it, i.e., it matches up 1-1 with the original js/html one. it's helped to identify one speed issue of getting multiple input values from the client
17:39:21 <kmc> what's a glue package?
17:39:22 <hpc> kmc: i mean like, perl has a package for iptables, http access, various forms of compression, etc
17:39:45 <hpc> haskell has automatic differentiation, relational algebras, and category-extras :P
17:40:26 <cmccann> it's not like Haskell entirely lacks that sort of thing
17:40:43 <kmc> there are lots of glue packages on Hackage, but more would be nice :)
17:41:07 <kmc> (in fact there are several for each category of example you gave)
17:41:15 <chrisdone> monochrom: i think i may be able to sort that speed problem though
17:42:37 <cmccann> my bigger complaint would be that many ffi bindings are painful to use because they just wrap an imperative API in a clumsy way
17:43:20 <mike-burns> And there are few high-level abstractions over the FFI.
17:43:37 <cmccann> especially when the underlying library is mostly doing things that make sense as pure functions but nobody wants to slog through and figure out whether it's safe to throw an unsafePerformIO over something
17:43:56 <cmccann> and it often isn't safe even though it should be because imperative languages lend themselves to being thread-unsafe for no good reason
17:44:06 <cmccann> or other random annoyances
17:44:32 <kmc> yeah, I'm usually fine with an imperative API, but half the time it's not threadsafe, or it just segfaults randomly
17:44:47 <kmc> or there are some weird rules about safe use which aren't enforced in the types
17:45:02 <mike-burns> My complaint is the incompleteness of important libraries; a general feeling of "only one person uses this". The JSON and HTTP libs are what I've been dealing with the most, and they have that.
17:45:11 <kmc> which JSON library?
17:45:12 <cmccann> mike-burns, that also happens
17:45:21 <cmccann> someone will wrap the 85% of the functionality that they personally use
17:45:29 <kmc> i think aeson is the best / most popular json library
17:45:39 <cmccann> and then someone else will wrap their own 85% in a slightly-incompatible way and upload that too
17:45:48 <mike-burns> I'm kinda happy with Aeson. The clumsiness of records is the biggest annoyance there.
17:46:08 <Clint> i'm annoyed that it went TH
17:46:11 <kmc> about half the libraries i've uploaded are "glue" by that definition
17:46:32 <kmc> FFI imports, or dealing with external programs and data formats
17:47:00 <cmccann> anyway, one example that really stuck in my craw was... I think it might have been SDL? not sure, but an FFI wrapper where the underlying library had a "convert RGB values to correct pixel format" function that used IO for no good reason
17:47:01 <kmc> the other half is split between applications, algorithms, utilities, and jokes ;P
17:47:34 <mike-burns> Joke libs are important!
17:47:42 <kmc> I don't think SDL has that function, because every SDL tutorial I've seen has a "how to poke a pixel" function you're supposed to copy-paste into your program ;P
17:48:15 <cmccann> the non-good reason of course being that it was using the underlying library's function which may or may not have been pure
17:48:15 <hpc> mike-burns: the only serious advantage haskell has over perl is the apostrophe in the acme don't module
17:48:18 <hpc> :P
17:48:29 <cmccann> hpc, that's a huge benefit to readability though
17:48:39 <chrisdone> dubs = check'em
17:48:55 <mauke> hpc: what do you mean?
17:49:42 * ski . o O ( Olin Shivers, "100% and 80% solutions", 1998-08, <http://www.ccs.neu.edu/home/shivers/papers/sre.txt> )
17:49:50 <hpc> oh whoa, the perl one has an apostrophe too
17:50:13 * hpc just learned something new about perl's parsing rules
17:50:35 <kmc> i wonder if we should have more documentation about how to write FFI bindings that don't suck
17:50:38 <mike-burns> Oh sure, that's how Damien made the Klingon module work.
17:50:42 <kmc> i know a few tricks but I don't remember where I learned them ;P
17:50:58 <cmccann> my favorite trick is waiting for someone else to do it
17:52:49 <kmc> i was surprised that creating a global lock to protect a thread-unsafe C library turned out to be such an ordeal
17:53:01 <kmc> like, the standard way tickles a bug in GHC which was only fixed for 7.4
17:53:24 <kmc> i would have thought this is a common approach but apparently not
17:53:43 <cmccann> ok, yeah, it was SDL, and specifically it was wrapping this function: http://hg.libsdl.org/SDL/file/c5d651a8b679/src/video/SDL_pixels.c#l403
17:54:11 <kmc> huh, i didn't know that function existed
17:56:10 <Philippa> cmccann: "correct format" may be hardware dependent
17:56:11 <chrisdone> oh, that's c's way of returning a tuple
17:56:34 <cmccann> anyway, it's doing something simple that's conceptually pure but I don't think I want to try to figure out whether it's safe to treat it as such from the FFI
17:58:00 <cmccann> Philippa, yes, but I think everything it needs to know is included in the arguments, or could reasonably be included
17:58:10 <mike-burns> Plus the maintainer would need to re-check every time SDL changes that code.
17:58:18 <cmccann> yeah
17:58:57 <cmccann> I'm pretty sure it would be simpler to just reimplement the function instead of calling it through the FFI, but that's not ideal either
17:59:04 <ben> how is the FilePath argument converted to a char* for openFile etc?
17:59:37 <cmccann> anyway, that specific function is just an example, I've noticed similar things in other FFI libraries
17:59:46 <ben> I'm reading a char array from somewhere and it's gotta be a FilePath and work just as if I'd used the original char* for open
18:00:39 * hackagebot snaplet-acid-state 0.1 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.1 (DougBeardsley)
18:02:16 <cmccann> ben, FilePath is just a synonym for String I think
18:03:07 <cmccann> so I assume it would be converted the same way any other String would
18:04:48 <ben> Yeah, that is what I'm wondering :)
18:05:20 <ben> but it turns out I'm actually using shm_open and there's a binding for that which just uses withCAString so I'm all set
18:08:23 <siracusa> Are there any cases where "data Foo where { Foo :: <type> }; foo :: <type>; foo = Foo" is supposed to yield a type error? My actual <type> is rather complex and type families are involved, so making a minimal example would be rather tricky.
18:10:03 <hpc> siracusa: might need to use type equality; dunno much about the quirks and details of GADTs
18:11:10 <siracusa> It complains that the used instance in <type> is not defined but I would think it doesn't need to be.
18:17:15 <PreciousMetals> hello I am having trouble installing synthesizer-core on a clean install of the latest Haskell platform (32-bit) on OS X 10.6.8
18:17:31 <PreciousMetals> here is the complete install log (error is at the way bottom) http://hpaste.org/55723
18:17:42 <cmccann> siracusa, if the context for the constructor has an instance that doesn't exist then yeah, that will probably fail
18:18:03 <PreciousMetals> if anyone could help me I would much appreciate it <:3
18:19:59 <siracusa> cmccann: Even if that function is never used?
18:20:42 <cmccann> siracusa, apparently
18:21:22 <siracusa> Hhm, that's at least inconsistent
18:21:39 <cmccann> siracusa, it's fine if you put the context on the function though
18:22:04 <siracusa> That's the problem, I did!
18:22:05 <mzero> PreciousMetals: I'm guessing that that code hasn't been compiled on GHC 7.0.4 before -
18:22:06 <hpaste> “C. McCann” pasted “weird context stuff” at http://hpaste.org/55724
18:22:28 <PreciousMetals> 3:
18:22:44 <PreciousMetals> on Hackage it lists a build failure for ghc 7.0
18:22:52 <PreciousMetals> but that's just a dependency mismatch
18:22:53 <mzero> Not that I know why it would have compiled prior to 7.0.4
18:23:12 <cmccann> siracusa, see my hpaste example there
18:23:14 <mzero> true - but indicative that the maintainer doesn't build on the 7 line of compilers -
18:23:31 <mzero> though I admit that seems hard to believe given that it is Henning
18:24:56 <siracusa> cmccann: Yes, my function looks like the second foo ... I guess I have to prepare an example
18:24:59 <PreciousMetals> maybe the darcs version will be more up to date?
18:25:07 <kmc> (that's not a function)
18:25:24 <kmc> what's inconsistent?
18:25:39 <cmccann> siracusa, probably something funny going on with GHC not thinking the context you're giving matches the one for the constructor
18:26:16 <cmccann> either because GHC can't figure something out or because it actually doesn't match for a non-obvious reason
18:26:21 <mzero> alas the last build on Hackage that worked was only successfully built on GHC 6.12, so that's suspicious - and it was 0.4.0.4 from back in in sept. 2010 ----
18:26:35 <mzero> --- double alas, that version doesn't have Spatial.hs to go look at
18:30:02 <mzero> PreciousMetals: the darcs repo has comments about getting it to work on GHC 7 from this September and October --- so yeah, that might work better
18:30:15 <PreciousMetals> of course darcs won't compile either
18:30:37 <mzero> sigh
18:30:41 <hpaste> siracusa pasted “Weird type error” at http://hpaste.org/55725
18:30:42 <mzero> time to e-mail henning
18:31:03 <siracusa> cmccann: ^ not minimal tough
18:31:28 <mzero> 'cause that error doesn't look like a problem with your set up at all - it looks like either the code is busted -- or perhaps he as some global GHC settings he didn't realize - so one can't recreate his build
18:32:04 <PreciousMetals> well thanks for helping me :)
18:32:41 <cmccann> siracusa, comp is the definition that causes the error I assume
18:32:49 <siracusa> Yeah
18:35:02 <cmccann> haha, oh boy, that's fun
18:35:16 <cmccann> siracusa, did you notice that it works if you remove the type signature?
18:35:49 <siracusa> cmccann: Not for me
18:36:13 <siracusa> But then there's only a single error
18:36:16 <xil> hi. Hlint gave me no suggestions, but GHC is finding errors
18:36:27 <xil> whoops, meant to ask why that is
18:36:48 <cmccann> siracusa, turn off the monomorphism restriction
18:36:59 <cmccann> or do comp x = PComp x etc.
18:37:50 <siracusa> Ah
18:39:17 <cmccann> anyway, the problem here is that GHC isn't convinced about some type equalities between the results of applying some type functions
18:39:30 <cmccann> which is not too surprising
18:39:44 <cmccann> you really have to hold its hand through that stuff sometimes
18:40:06 <cmccann> assuming that the result actually is necessarily equivalent, of course
18:40:33 <siracusa> You mean add some ~'s?
18:41:04 <cmccann> it may be more complicated than that
18:41:17 <donri> xil: hlint is not a type checker
18:41:29 <xil> donri: aha. That would do it. Thanks =]
18:41:54 <kmc> hlint doesn't check all the things ghc checks, even aside from types
18:41:59 <kmc> hlint exists to check things ghc doesn't
18:42:12 <donri> hlint suggests changes that don't change the program, only the code
18:42:46 <kmc> hlint primarily checks coding style, and suggests simplifications
18:42:48 <parcs`> i wish IntMap were parameterized, ie, insert :: Key k -> IntMap k v -> IntMap k v where newtype Key a = Key Int
18:42:54 <cmccann> on the other hand ghc suggests you fix your dumb code because it's wrong, stupid human
18:43:08 <kmc> it also warns about things which might indicate bugs; ghc also does this if you pass -Wall
18:43:11 <siracusa> cmccann: It just feels strange to me that it doesn't accept it's own inferred type
18:43:19 <kmc> xil, you should always compile with ghc -Wall.  i don't understand why it's not the default
18:43:19 <siracusa> *its
18:43:20 <cmccann> siracusa, yeah I love that
18:43:37 <kmc> (you can use -Wall with ghci too)
18:43:55 <xil> kmc: what does -Wall do?
18:44:01 <kmc> enables all warnings
18:44:05 <kmc> see also: ghc manpage
18:44:13 <siracusa> cmccann: Okay, I'll just leave out the type signature for now and think about that later. Thanks for the help!
18:44:15 <xil> oh found it
18:44:35 <donri> -Werror ;)
18:44:37 <xil> yeah I found it in the man page, but it didn't have a description. Did a search and found the description =]
18:44:38 <cmccann> siracusa, you may hit problems later anyway
18:44:52 <cmccann> the fact that it doesn't accept the inferred type makes me suspicious
18:44:57 <kmc> there's a description at the second occurrence yeah
18:45:47 <aavogt> parcs`: won't that lead to more problems with the monomorphism restriction? Also you've only got 82 or so wrapper functions to write to get that happening...
18:46:26 <aavogt> so the whole module for that will probably be ~ 200 lines
18:46:40 <siracusa> cmccann: The examples I've tested so far work fine if I use PComp directly
18:46:41 <kmc> what's the point of that, parcs`?
18:46:52 <cmccann> siracusa, you may be fine then
18:47:31 <siracusa> Let's see how far I can get :-P
18:47:49 <cmccann> siracusa, my first guess is that the ambiguity of the first argument to :* is the problem
18:48:04 <cmccann> and that anywhere you know what goes there GHC will be able to figure it out
18:50:55 <siracusa> That could very well be, I had to add the ar type parameter to resolve errors like that earlier
18:54:39 <cmccann> siracusa, there could also be issues because of legitimate ambiguity, but only on the assumption that more instances could be added to :*
18:58:55 <xil> if I apply sequence_ to a list of IO () actions is it the same as just putting >> between them all?
18:59:16 <kmc> @src sequence_
18:59:17 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
18:59:21 <xil> lol
18:59:39 <kmc> sequence = foldr (liftM2 (:)) (return [])
18:59:58 <xil> so here's another question. If most of the elements in my list are "return ()" will they take up processing time?
19:00:30 <kmc> some
19:00:44 <xil> okay, thanks =]
19:00:59 <kmc> maybe not, if GHC is particularly clever about inlining and fusing and optimizing your code
19:01:15 <kmc> how big is the list and how fast do you need it to be
19:01:57 <xil> the list has a length on the order of 1 million, and only a few hundred will not be "return ()". But I can do it differently so those aren't in there
19:02:08 <mzero> well, GHC can't inline or fuse the return () expressions that are in a list constructed at run-time!
19:02:29 <mzero> xil: I doubt it is worth your effort to remove them
19:02:37 <kmc> but presumably removing them has some cost too
19:02:57 <xil> I won't be removing them. It's that the way I produce the list could easily be changed to not produce those return ()s in the first place
19:03:04 <xil> I was just curious
19:03:06 <mzero> if your code is smaller, simpler, cleaner with them in, leave 'em --- ~1 million    return ()  won't cost much at all
19:03:26 <xil> once, sure, but many times per second will add up
19:03:46 <mzero> I was just going to ask if you were doing this, say, every millisecond!
19:03:54 <xil> not quite that fast
19:04:03 <xil> doesn't even need to be every 20
19:04:07 <xil> but it's more than once per second
19:04:28 <kmc> mzero, yeah, but it can conceivably fuse the list producer with sequence_
19:04:39 <mike-burns> Is this your bottleneck? Is it what your profiling tool says is the performance issue?
19:05:00 <mzero> kmc: true dat
19:05:38 <xil> haven't even gotten to that point yet mike-burns
19:06:09 <xil> I just had a decision and was curious about the performance of my options
19:06:27 <kmc> i'm gonna run a benchmark to see how long a million 'return ()' take
19:07:24 <kmc> just as soon as i reinstall criterion for the nth time
19:08:23 <Sgeo> sequence_ takes a bit longer than sequence
19:08:29 <Sgeo> sequence_ is really fast
19:08:46 <kmc> wait, sequence_ takes a bit longer than sequence?
19:08:51 <Sgeo> Other way around
19:08:54 <Sgeo> Sorry
19:09:07 <kmc> yeah, that makes more sense :)
19:09:10 * Sgeo isn't actually timing anything though, just playing with GHCi
19:09:32 <kmc> yeah ghci performance isn't that important though
19:09:33 <eyebloom> Is there a good resource that explains all of the language options for ghc?
19:09:43 <kmc> eyebloom, the GHC manual is pretty good
19:10:04 <kmc> it describes pretty much every option, usually with some examples, often with a link to other documents
19:10:53 <mzero> eyebloom: if you're using the HP version (7.0.4): http://lambda.haskell.org/platform/doc/current/ghc-doc/users_guide/ghc-language-features.html
19:11:44 <mzero> if latest release GHC (7.2.2): http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
19:11:46 <cmccann> based on a quick and dirty comparison, sequencing a list with a bunch of return () in it takes a noticeable amount longer than the list without them
19:12:11 <cmccann> whereas sequencing a list with just return () and nothing else takes almost no time, much less than the difference between the other two
19:12:16 <mzero> cmccann: timing? particulars?
19:12:33 <eyebloom> basically I'm looking for a quick map back from the option to an explanation. To try an decode compiler error suggestions.
19:13:04 <kmc> eyebloom, http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Language-Haskell-Extension.html
19:13:16 <eyebloom> There we go.
19:13:19 <kmc> that has short descriptions, and references back into the GHC manual of... some version
19:13:21 <eyebloom> Thank you.
19:13:26 <kmc> probably 6.12
19:13:27 <mzero> eyebloom: or search §4.19: http://lambda.haskell.org/platform/doc/current/ghc-doc/users_guide/flag-reference.html
19:13:34 <mzero> (my favorite page in the GHC docs!)
19:13:38 <kmc> oh, nice
19:14:11 <eyebloom> excellent
19:14:41 <kmc> i think it's nearly impossible to learn Haskell without #haskell
19:15:03 <kmc> there are all these useful documents but it's hard to find them
19:15:22 <kmc> and there's a lot of stuff which isn't written down coherently
19:17:07 <mzero> I think that might be true of most programming languages - only most don't have  #x that is quite as friendly as here!
19:17:18 <cmccann> mzero, about 0.25s for a million elements of which about 30k were actual actions, about 0.14s for just the 30k, 0.06s for a million return ()s alone
19:17:20 <cmccann> or thereabouts
19:17:37 <kmc> mzero, no, I don't think so
19:17:37 <mzero> thanks-  that's quite quite interesting
19:17:50 <cmccann> data collected by building with O2 and running with the time command a few times, which is about the worst possible way to benchmark anything
19:18:01 <kmc> use criterion! (still building)
19:18:40 <cmccann> remembering how to use criterion and all that is just slightly too much effort for something like this, heh
19:19:35 <c_wraith> criterion is like 3 lines.  Installing it can be a pain, though
19:19:37 <kmc> criterion is about the easiest library ever
19:20:01 <kmc> import Criterion.Main;  main = defaultMain [ bench "foo" <your IO action here> ]
19:20:09 <cmccann> yeah, but I'd still have to look that up
19:20:21 <kmc> no you just copy-paste it from the last little benchmark you ran
19:20:22 <cmccann> I don't use it often enough and my memory is pretty bad when it comes to that sort of thing
19:20:38 <cmccann> haha, finding the last one is also more work
19:21:35 <cmccann> the important thing to conclude here is that I don't use criterion often enough
19:23:37 <hpaste> kmc pasted “benchmarking dummy IO actions” at http://hpaste.org/55726
19:23:46 <kmc> 1,000,000 actions:  mean: 7.550028 ms, lb 7.442587 ms, ub 7.660158 ms, ci 0.950
19:26:00 <kmc> so that's like 7.5 nanoseconds per action; not bad ;)
19:26:52 <cmccann> pretty likely to be swamped by anything a non-trivial IO action is going to do
19:28:23 <kmc> ♥ criterion
19:30:12 <cmccann> anyone know if there's a full, usable html parser on hackage
19:30:40 <cmccann> by which I mean something that can parse garbage markup from real web pages and produce a meaningful document tree
19:30:50 <c_wraith> does tagsoup fall short?
19:30:58 <c_wraith> I guess it doesn't make a tree
19:31:02 <cmccann> right
19:31:05 <ben> Does haskell come with an mmap wrapper that does some Fd -> IO (Ptr a) thing instead of wrapping it as Filename -> IO ByteString or whatever?
19:31:15 <c_wraith> I think there's an html5-compliant parser
19:31:25 <kmc> ben, should be in the 'unix' package
19:31:30 <c_wraith> which has all kinds of fallback and recovery behavior in it
19:31:32 <ben> cheers
19:31:43 <cmccann> last time I checked all I found on hackage were "parses well-behaved markup" and "parses tags but doesn't build a tree"
19:32:00 <cmccann> c_wraith, what package? that sounds plausible
19:32:12 <c_wraith> uh, I don't recall.  let me check around
19:32:38 <kmc> ben, huh, I can't find it
19:32:52 <cmccann> c_wraith, awesome, thanks. that's pretty much what I'm going to end up writing myself if it doesn't exist
19:32:57 <cmccann> would be nice to not have to
19:33:09 <c_wraith> oh, nevermind.  There's something that parses html5 documents that are well-formed, but it's not an html5-compliant parser
19:33:13 <c_wraith> not what you want
19:33:15 <mzero> wishes web browsers never accepted ill-formed markup - Postel's Law is corrupt!
19:33:17 <cmccann> yeah
19:33:24 <kmc> why isn't it in there? 'unix' is supposed to have all of POSIX, no?
19:33:35 <kmc> it seems that bytestring-mmap defines its own interface to the C function
19:33:52 <ben> I guess mmap is as unhaskelly as it gets
19:34:02 <cmccann> c_wraith, thanks anyway, guess I'm stuck with plan B
19:34:11 <kmc> whatever, there's tons of stuff for pointers and unsafe memory access in the standard library
19:34:18 <kmc> i mean FFI is part of Haskell, officially
19:35:23 * Sgeo wonders if using Haskell's FFI stuff may end up being simpler than the horrific code I wrote in Python
19:35:33 <Sgeo> Although in Python's defense, I may have been a bit of an idiot.
19:35:33 * cmccann wonders if a full html5-compliant parser would be anything other people would find useful
19:35:51 <c_wraith> yes, people would find it useful, I assure you
19:36:05 <cmccann> Sgeo, haskell's ffi is really easy to use if you're interfacing with C code that only handles basic types and pointers
19:36:06 <c_wraith> Unfortunately, I hear the parser, as specified, is annoyingly stateful
19:36:17 <cmccann> c_wraith, hahahahahahahaha
19:36:20 <Sgeo> cmccann, I'm not
19:36:34 <kmc> it's not that hard otherwise
19:36:38 <Sgeo> I have weird structs with an int specifying the length of a string and a pointer to the string, and other stuff
19:36:38 <kmc> can be a bit tedious
19:36:43 <ben> I'm doing something borderline criminal anyway
19:36:59 <ben> trying to eventually shm_open -> mmap -> cairo surface -> partially transparent gtk window
19:37:04 <cmccann> c_wraith, it's like a huge monstrous vaguely lovecraftian state machine, except with enough extra details and exceptions that you can't model it as a formal state machine easily
19:37:12 <c_wraith> hahaha
19:37:14 <mzero> cmccann: but it would be a real commitment! compliance with a spec that is expected to keep moving for the next decade!
19:39:14 <cmccann> c_wraith, I actually spent a while looking through the html5 spec already, when I couldn't find anything on hackage I figured I'd have to write my own
19:39:18 <cmccann> so yeah I know how bad it is
19:40:27 <cmccann> my current plan is to try to take exhaustive inventory of all the stupid things it requires as actions, build all that into some "html 5 malevolent state machine" monad, then build the thing line-by-line to the spec
19:40:46 <cmccann> easier than trying to make any sense out of the thing in a non-horrible way
19:41:21 <dmwit> Sgeo: ints and pointers to strings both fall under "basic types and pointers"
19:41:29 <c_wraith> doesn't sound the greatest for performance, but probably the best for correctness.
19:41:56 <cmccann> c_wraith, part 2 is using that as a reference implementation if I need to build a less terrible version
19:42:02 <c_wraith> right
19:42:06 <dmwit> Sgeo: So if you believe cmccann's claim (which I do), then those don't necessarily indicate that the FFI will be hard to use.
19:42:08 <cmccann> lots of quickcheck "does this do the same thing"
19:42:27 <c_wraith> an arbitrary instance for malformed markup!
19:42:47 <dmwit> c_wraith: hah
19:42:52 <dmwit> enjoy
19:42:57 <cmccann> c_wraith, yep, which will be fun to write I'm sure
19:43:29 <xil> kmc: thanks for the benchmarks =]. That's really cool
19:43:39 <mzero> the style of the HTML5 definition makes me weep! ditto for ECMAScript's operational semantics
19:44:08 <mzero> cmccann: but, that sounds about the same way I'd go about building an HTML5 parser.
19:44:18 <cmccann> mzero, if you're only weeping I wonder how much time you've spent looking at it
19:44:59 <mzero> actually, at work, I spend tons of time looking at it - but there I'm usually cursing or faceplamning!
19:45:02 <cmccann> my current favorite is the "consume a character reference" where it jumps to doing something completely different with its own little rules
19:45:19 <cmccann> completely ignoring the whole state machine structure that it doesn't quite have
19:45:35 <cmccann> (this is in the tokenizing step)
19:45:40 * hackagebot Configger 0.1 - Parse config files  http://hackage.haskell.org/package/Configger-0.1 (NateSoares)
19:46:06 <kmc> wait, since HTML5 is a new standard, why isn't it XML-only
19:46:15 <cmccann> because html isn't xml
19:46:18 <cmccann> or sgml for that matter
19:46:20 <mzero> I admit though, I hardly ever look at §8 -
19:46:23 <c_wraith> they wanted to formalize bad markup
19:46:26 <cmccann> and never has been in practice
19:46:27 <kmc> cmccann, I'm asking why not >_<
19:46:29 <mzero> that would probably make me gouge my eyes out
19:46:40 <kmc> i mean, XHTML is a thing.  HTML5 is new.  why did they not say "all HTML5 must be XHTML5"
19:46:44 <c_wraith> in particular, they wanted to formalize parsing of real-world markup
19:46:45 <cmccann> mzero, yeah, the tokenizing is what I was looking at most recently
19:46:49 <Sgeo> What is §8
19:46:59 <c_wraith> real-world markup has never been near xml or sgml
19:47:01 <kmc> real-world existing markup?  if HTML5 is new, why would there be any "existing markup"
19:47:03 <iwtu> Hello! I have type ReadableOutput = Data.Map.Map String (Data Set.Set (Int,Int). I would like to have nice output as one key with its values per line. How could I do that? Thanks in advance
19:47:07 <mzero> §8 is the HTML syntax of HTML5
19:47:09 <c_wraith> kmc: because people are idios
19:47:11 <c_wraith> err, idiots
19:47:15 <mzero> §9 is the XHTML syntax of HTML5
19:47:24 <c_wraith> they will throw an html label on top of the same crap they've always written
19:47:29 <c_wraith> and you can't stop them from doing it
19:47:37 <c_wraith> err, html*5* label
19:47:45 <mzero> the difference in the length of those two sections is staggering
19:47:56 <cmccann> html5 is attempting to give a fully defined and unambiguous way to deal with the broken markup that exists
19:48:03 <siracusa> For a type ``data a :+ b = a :+ b'', how do you declare a Functor instance such that the second parameter is fixed? I tried with something like ``type FlipCons b a = a :+ b'' but is doesn't work as ``Functor (FlipCons b)'' is not applied to enough arguments.
19:48:08 <cmccann> it's full of "if X, this is a parse error, so do this to cope with it"
19:48:18 <kmc> iwtu,  printMap = mapM_ printElement . Map.toList;  printElement (str, set) = ...
19:48:41 <Clint> and that's why the whatwg will crush the w3c, and unversioned html will reign supreme
19:49:04 <mzero> kmc: it has to do with history and politics: The XHTML group was totally independent of the HTML group --- and the XHTML group decided that XHTML 2 was going to be a total break from both HTML and XHTML 1.x  ---
19:49:24 <kmc> ....
19:49:25 <mzero> it kind of killed their chances of setting a sane, concise to parse, markup for the web
19:49:58 <cmccann> so now html5 is trying to be a formal specification that describes in complete detail roughly what real browsers already do to cope with the terrible markup that exists
19:50:19 <iwtu> kmc: per line I should use PutStrLn ?
19:50:26 <kmc> i don't know, use it if it does what you want
19:51:10 <siracusa> Type level sections apparently also do not work
19:51:26 <kmc> siracusa, you can't make that functor instance, basically
19:51:27 <mzero> (continuing cmccann )... and thus codify into spec what is, and is no longer, acceptable to parse in the future ... or so they hope
19:51:51 <iwtu> kmc: I thought about overiding show method or somethinkg like that.. can I use putStrLn out of main?
19:52:14 <kmc> yes
19:52:17 <siracusa> kmc: Yeah, actually I don't want a Functor instance but the instance I want has the same problem
19:52:18 <kmc> don't override show
19:52:21 <kmc> just write a function that does what you want
19:52:33 <c_wraith> You can use putStrLn anywhere its type works.
19:52:42 <cmccann> as horrendous as html5 is and as much as I wish their specification was possible to read without rolling 2d4 for sanity loss
19:52:50 <iwtu> thanks. biut why?
19:52:53 <kmc> iwtu, perhaps you should read http://www.haskell.org/haskellwiki/Introduction_to_IO
19:52:57 <cmccann> I have to admit it's probably one of the best ways to go about it these days
19:53:06 <cmccann> given the reality of the web
19:53:13 <c_wraith> that's kind of how I feel about it
19:53:28 <c_wraith> I think it's probably the right approach to a terrible problem.
19:53:46 <donri> kmc: i've put that on @where IO btw
19:53:48 <kmc> nice
19:53:53 <kmc> @where IO
19:53:53 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:54:02 <cmccann> c_wraith, it's possibly the least horrible thing they could do, or close to it
19:55:00 <cmccann> there's basically no way to do an html spec "right" without making it basically irrelevant to real documents
19:55:17 <cmccann> but anyway
19:55:33 <cmccann> tl;dr that's why I'll probably be working on an html5 parser next weekend
19:56:03 <mzero> or.. we could have defined a rational HTML5, that didn't accept inane historical crud, --- the let the browsers accept the crud (as they already do) for, say two years --- but every time they parse markup that is non-compliant -- they should have fetched /dear-webmaster-your-markup-is-not-complaint-fix-or-be-unreadable-by-2013
19:56:16 <mzero> eventually, anyone watching their server stats would have noticed!!!!
19:56:19 <mzero> :-)
19:57:01 <donri> does lambdabot have a way to direct the response at someone [else]?
19:57:08 <kmc> don't think so
19:57:10 <cmccann> and then, in 2013, Berners-Lee would descend from on high wielding a sword of righteous judgment and lay waste to the noncompliant
19:57:24 * mzero really wants to write a spec now that has clients fetching a URL like that as the way of signaling an error condition!
19:57:31 <cmccann> as long as we're in the realm of fantasy, why not go all the way
19:57:31 <donri> @give kmc where IO
19:57:31 <lambdabot> Maybe you meant: dice gsite time
19:57:48 <phao> Does anyone here know any book with compilation of interesting programming challenges/exercises?
19:57:49 <donri> would be nice to have when channel is noisy
19:58:11 <kmc> what kinds of exercises
19:58:16 <kmc> what kinds of programming
19:58:18 <kmc> what languages
19:59:38 <phao> kmc, any
19:59:48 <donri> SICP?
19:59:54 <kmc> if you want to get really good at manipulating integers and don't care about other data types, there's Project Euler
19:59:56 <phao> but I'd like related to functional programming
19:59:57 <kmc> http://projecteuler.net/
20:00:08 <phao> I really don't mind the language
20:00:12 <phao> donri, I've done it already
20:00:13 <kmc> SICP has good exercises on stuff fundamental to functional programming
20:00:23 <phao> ok
20:00:24 <donri> kmc: but some euler problems are about treating numbers as strings ;)
20:00:28 <cmccann> since I'm at it, anyone think my rough plan of making an "html 5 brain damage monad" and doing a literal line-by-line translation of the spec is flawed?
20:00:31 <kmc> there's http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
20:00:36 <kmc> and the same for Lisp and Prolog
20:00:38 <cmccann> I'd love to have a better way to do it but ugh
20:00:40 <kmc> and you could do it in other languages
20:00:43 <phao> I've done all SICP exercises back when I read it
20:00:54 <kmc> for Haskell specifically i like these assignments:
20:00:55 <kmc> @where CS11
20:00:55 <lambdabot> http://web.archive.org/web/20100328151143/http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
20:00:57 <donri> also http://blog.tmorris.net/20-intermediate-haskell-exercises/
20:01:41 <dmwit> Not quite a Haskell question, but how do you kill a zombie? I tried kill -9 already and it's my process...
20:01:54 <c_wraith> dmwit: zombies are already dead
20:02:00 <iwtu> kmc: but still... why is not a good idea to overide show?
20:02:01 <kmc> yes, it's a bad name
20:02:07 <kmc> iwtu, why would it be a good idea?
20:02:09 <c_wraith> dmwit: but they don't disappear from the process list until their parent calls waitpid
20:02:13 <dmwit> aha
20:02:19 <Clint> zombie reaping
20:02:24 <dmwit> So I must kill the zombies' children?
20:02:34 * BMeph recommends nuking it from orbit, because, you know...
20:02:35 <c_wraith> dmwit: not really.  just call waitpid
20:02:43 <iwtu> kmc: because it is a type specially for nice output :-)
20:02:49 <kmc> it's not a type
20:02:58 <kmc> and it's not really for "nice output"
20:02:59 <monochrom> heh, zombies have children? :)
20:03:01 <phao> thkx
20:03:10 <phao> these stuff should keep me busy for a while
20:03:17 <dmwit> c_wraith: Don't I have to be a child to call waitpid?
20:03:25 <kmc> parent probably
20:03:25 <monochrom> but yeah, zombies are waiting for parents to waitpid
20:03:28 <c_wraith> dmwit: usually the parent is responsible for that
20:03:32 <kmc> iwtu, I think since you don't yet understand the basics of Haskell IO, you shouldn't do more advanced stuff like define new type class instances
20:03:36 <dmwit> (The shell's "wait" complains that the shell isn't a child.)
20:03:51 <monochrom> parent does the waitpid
20:03:52 <dmwit> Oh, yes... that the process isn't a child of the shell!
20:03:56 <dmwit> I misread the error.
20:03:58 <kmc> iwtu, it's very common for beginners to think wrongly that they need to do everything with type classes.  the result is always a mess
20:04:16 <dmwit> Okay, how do I tell which process is the parent...
20:04:23 <kmc> ps axf
20:04:32 <Clint> PPID
20:04:35 <kmc> iwtu, do it the simple way; if you want to come back once you understand type classes better, go ahead
20:05:00 <dmwit> The parent has a higher process number than the child!
20:05:07 <dmwit> Okay, let's see what happens if I kill this...
20:05:23 <djahandarie> In before "Remote host closed the connection"?
20:05:24 <dylukes> dmwit just unwittingly recited the erlang mantra ;P.
20:05:29 <dylukes> "Okay, let's see what happens if I kill this..."
20:06:06 <iwtu> kmc: thanks for advices. I very appreciate it. I have one more question. is it simple?
20:06:12 <kmc> is what simple?
20:06:16 <dmwit> Now that one's a zombie too. -_-
20:06:33 <monochrom> trace back the ancestry
20:06:35 <Clint> someone hates SIGCHLD
20:06:36 <iwtu> type classes and all the stuff around Haskell
20:06:50 <kmc> no, Haskell is not simple
20:06:56 <c_wraith> It's not simple, but it's worth it
20:06:58 <cmccann> programming is not simple
20:06:58 <dmwit> monochrom: That was the ancestor untill I killed it. Now it has a new ancestor with a still higher PID.
20:07:07 <kmc> it is very hard to learn, it will take you a long time, and you will feel stupid repeatedly
20:07:10 <dmwit> monochrom: So I think chromium is doing something weird here.
20:07:39 * BMeph still recommends nuking it from orbit
20:07:41 <Clint> i thought chromium did process isolation
20:08:22 <BMeph> dmwit: "It's the only way to be sure." >:D
20:08:33 <monochrom> that is strange. chromium power cannot override kernel rules. kernel rules say that you can't get new parents.
20:08:35 <iwtu> kmc is mathematical analysis hard?
20:08:57 <dmwit> monochrom: Maybe ps axf didn't report the parent of a process for some reason? Can't imagine what that reason would be.
20:09:18 <dmwit> Anyway, one additional kill ended the cycle. It's gone now.
20:09:41 <mzero> iwtu: I disagree with kmc's characterization - Haskell is rich, deep, and full of new stuff to learn how to do, especially if you've been programming enough to think that each new language you learn isn't all that different from the last --- because Haskell is very different (unless your last was, say, ML.... )  --- but you can learn it in a few months of casual evening programming, which will make your brain feel woozy, in a good way (like being drunk
20:09:41 <mzero> repeatedly!
20:09:56 <dmwit> Clint: I'm not sure what the consequences of that claim would be for my situation. Can you clarify?
20:10:15 <monochrom> if your parent vanishes, only one process becomes your new parent, and it's final. that new parent is process number 1, "init". init does waitpid to all children, new and old. that is how zombies eventually disappear.
20:10:53 <kmc> mzero, it all comes down to what you mean by "learn Haskell"
20:11:09 <mzero> kmc: or what one means by "learn programming"!
20:11:15 <cmccann> it also depends on what you mean by "hard"
20:11:20 <kmc> nobody was talking about that, were we?
20:11:27 <kmc> about "learn programming"
20:12:09 <dmwit> monochrom: If anything, I suspect that I failed to interpret ps's output correctly rather than chromium overriding the way the kernel works. =P
20:12:15 <iwtu> recently I have started to think that hard things are not hard if you know what you are doing. if you view from above. Then is just manner of how to write thoughts
20:12:20 <kmc> a lot of people "learn Haskell" well enough to do quicksort and some Project Euler problems and then they get bored
20:12:43 <mzero> well... "learning programming" is something I've been happily doing for 30+ years... Haskell has been just part of the journey!
20:12:48 <monochrom> oh, mixing up the two columns PID and PPID may explain it, then :)
20:13:05 <dmwit> There weren't two columns in ps axf...
20:13:12 <cmccann> I remain unconvinced that learning Haskell is significantly harder than learning programming in any language, if all are taken to the level of knowledge needed to do useful and non-trivial programs with them
20:13:42 <kmc> cmccann, it's much harder given typical background
20:13:48 <dmwit> Not two columns that looked like ID numbers, anyway.
20:14:15 <kmc> it takes a long time before you know Haskell well enough that it's a viable alternative for getting shit done
20:14:19 <cmccann> kmc, I'm talking about having no prior programming background whatsoever
20:14:27 <monochrom> the format of f is that you see trees, roots are ancestors, leaves are descendents
20:14:37 <djahandarie> cmccann, there is no good tutorial for that.
20:14:42 <mzero> I'm with cmccann here, but then again, I've been relishing the challenge of finding a way to teach Haskell to PHP programmers for some time now.... maybe I'll figure out how someday!
20:14:43 <kmc> if you already know another reasonable high-level language
20:15:26 <dmwit> Maybe I just didn't read across correctly and aligned the PID and process name columns incorrectly.
20:15:27 <cmccann> I think most of the supposed difficulty of learning Haskell comes from people who find their background in other languages isn't helping as directly as they think it should
20:15:37 <dmwit> That seems plausible, and would explain (?) my confusion.
20:15:47 <kmc> cmccann, that's not just 'supposed' difficulty
20:15:57 <kmc> you might be wrong in expecting your background to help, but you're still right in realizing it doesn't!
20:16:05 <monochrom> I much recomment htop for listing processes
20:16:11 <cmccann> kmc, yeah, not really the best word there
20:16:15 <iwtu> I was very bounded what teached me at school. facts and facts and facts. theory and theory and thoery. but when I started to think then all makes sense. I think it's wrong. They teach me definition at first. but definition was the last step in develop
20:16:50 <cmccann> it's more that haskell's difficulty seems large because people forget the difficulty involved in learning whatever other language they know
20:17:36 <monochrom> definition is the last step? don't kid me. don't you ever want to apply? applying is the last step. or the last steps in an infinite sequence...
20:17:53 <monochrom> of course, definition is not the first step either.
20:18:22 <cmccann> djahandarie, good tutorial for what, btw? lost the context there, sorry
20:18:30 <kmc> mm, theorizing aside, I think if you survey people who have tried to learn Haskell (successfully or not) and ask them if it's easy to learn, the answer is a resounding "no"
20:18:41 <djahandarie> cmccann, learning Haskell with no programming background.
20:18:58 <iwtu> maybe I use wrong word to express myself. the last step could be whatever
20:18:58 <dmwit> I feel the same way about C.
20:19:12 <dmwit> Yet it doesn't have the same negative stigma *in that department*.
20:19:18 <cmccann> kmc, subjective impressions do not necessarily correlate to actual difficulty, especially relative to other things
20:19:32 <iwtu> C is very easy if you know how a computer works
20:19:42 <kmc> C is very easy if you know how the computer wants you to think it works
20:19:48 <dmwit> C is many people's introduction to how a computer works (and was mine in particular).
20:19:51 <shapr> But C requires that functions return, and that's not how computers work.
20:19:52 <iwtu> if you don't, then it is hard
20:19:57 <kmc> C is very far from the reality of how processors work today
20:20:10 <Ke> =oP
20:20:13 <cmccann> kmc, not that most programmers seem to be aware of that...
20:20:15 <kmc> i'm disappointed to find that "This language is easy to learn" or something like that is not in http://therighttool.hammerprinciple.com/browse
20:20:35 <kmc> cmccann, yeah :/
20:20:35 <monochrom> C is very easy if you know C. http://www.vex.net/~trebla/humour/programming_books.html
20:21:16 <Goose124> Woah...What just happened?
20:21:17 <iwtu> kmc. I meant easy when you have enoght time to think :)
20:21:21 <kmc> netsplit... a small one
20:21:22 <dmwit> Goose124: netsplit
20:21:33 <monochrom> christmas magic just happened
20:21:34 <dmwit> (Google it if that doesn't instantly explain what just happened.)
20:21:47 <Keratin> oh dear the netsplits on 700+ user channels must be something to behold
20:21:52 <Goose124> dmwit, I was already on my way to googling it :D
20:21:52 <kmc> cmccann, you're right about subjective impressions, but if nearly everyone says that something is hard, and you've tried it and decided it's pretty hard, then it's probably pretty hard ;P
20:22:11 <kmc> in the absence of a compelling specific explanation for why all these people are wrong about their own experiences
20:22:16 <djahandarie> monochrom, nice link.
20:22:38 <cmccann> kmc, I'm willing to take it as a given that haskell is, indeed, hard, whatever that actually means
20:22:54 <kmc> i don't want to be the guy who's saying "haskell is actually easy; you just think it's hard because you're crazy/stupid"
20:23:00 <dmwit> Keratin: That was minor from our side, but imagine what it must have looked like from the other side of the split.
20:23:03 <kmc> that's not productive anyway
20:23:07 <Keratin> D:
20:23:10 <iwtu> I red the artcitle. Could you help me to understand why is the overiding of show wrong idea?
20:23:17 <cmccann> my contention is that an imperative programmer complaining that haskell is too hard to learn is full of it because whatever language they learned first was really hard too
20:23:56 <dmwit> However, a non-programmer complaining that Haskell is too hard to learn is not full of it because they're right.
20:24:04 <sully> I mean, it dpends what you mean by "haskell is hard to learn"
20:24:14 <monochrom> I have friends who report that "x = x + 1" made no sense to them in their first languages (c or basic)
20:24:16 <cmccann> dmwit, yes, and they'd say the same thing about most other languages
20:24:17 <sully> I think that basic functional programming isn't too hard
20:24:20 <cmccann> and they'd be right about those as well
20:24:36 <sully> so when you are just doing basic functional programming in haskell, that's fine
20:24:51 <dmwit> "This is hard." "Before I can judge if that's true, I'll need to know a bit more about your childhood..."
20:24:54 <sully> but then you get into real things where people have cranked the abstraction level up to 11
20:25:07 <iwtu> cmccann: I think that first programming language is also easy. But I think very hard is understand words of text. our languge is not efficient to pass new ideas
20:25:27 <monochrom> onoes, freudian theories of programming learning :)
20:25:30 <cmccann> when I was in college I got paid to tutor other students for introductory programming classes which were taught in C++
20:26:03 <cmccann> I honestly think teaching haskell would have been easier
20:26:14 <iwtu> i don't like starting with C++
20:26:20 <iwtu> sure
20:26:25 <monochrom> "is it true that you prefer haskell because you were jealous of your father, and your father's day job used c?" :)
20:26:58 <monochrom> "no, sigmund, my father's day job used f#"
20:27:17 <monochrom> "in fact, my father is Jon Harrop" XD
20:27:26 <cmccann> I do think haskell front-loads the difficulty more than other languages, though
20:27:34 <djahandarie> lolol
20:27:48 <cmccann> in ways that probably could be mitigated somewhat with better teaching material, but eh
20:28:08 <eyebloom> Functional is easy at first but quickly gets difficult as polymorphic types and monads etc come into play.
20:28:42 * mzero heard this all before.... about Object Oriented Programming back in the 80s....
20:28:51 <iwtu> C++ has to be very technicial from begging. Haskell of Python don't have to be. So newbie can most of the time of learning spent on nwi ideas. which is easier like learn new ideas and learn technically things at the same time
20:29:21 <eyebloom> Python is probably the best starter language today.
20:29:59 <cmccann> mzero, speaking of which, I contend that unlike Haskell, OOP actually is too difficult for many programmers until they have more experience under their belt
20:30:26 <cmccann> which is so little code in OOP languages is actually written in anything resembling a reasonable OO style
20:30:27 <iwtu> OOP is not easy I think
20:30:31 <eyebloom> It's hard to appreciate the virtues of pure functional, and strongly typed, until you have worked without it.
20:31:20 <eyebloom> It's also probably not good to start with functional programming since it's so far abstracted from the physical machine.
20:31:49 <mzero> of course, historically, Smalltalk fleshed out what we now call OOP under the mandate to find a way to teach children to program
20:31:50 <monochrom> that's a 50% probably
20:32:03 <mzero> by their accounts, it worked
20:32:09 <eyebloom> New programmers should really be learning  how a computer works as well as how to program one.
20:32:39 <iwtu> eyebloom: you don't care about physical machine when you are not learning C or C++ when you are learning first programming language. I believe ideas are the most important
20:33:03 <iwtu> so C and pointers?
20:33:10 <BMeph> rwbarton: Ping
20:33:14 <iwtu> or even C++ and pointers? :-)
20:33:18 <eyebloom> I disagree.
20:33:26 <aavogt> maybe they have to teach how the mind and body work too
20:33:34 <iwtu> it is what you are saying :)
20:33:51 <monochrom> consider: "it is probably not good to start with using your muscles since it's so far abstracted away from the chemical ATP"
20:34:03 <iwtu> lol
20:34:13 <eyebloom> You're missing the point.
20:34:22 <monochrom> no, I think you are.
20:34:23 <iwtu> byt yeah
20:34:25 <ksf> teaching people first haskell and then c is torture.
20:34:25 <Philippa> the machine doesn't have a lot more to do with OOP than with FP, especially if you understand tail calls sufficiently
20:34:28 <iwtu> show us
20:34:35 <ksf> haskell, then assembly, and then c, now that's sensible.
20:35:05 <mzero> I actually think that while the mechanics of a language can get in the way of learning programming, programming can be about as easily taught with most languages if the emphasis is on programming and thinking about programs, rather than on mechnics
20:35:15 <eyebloom> Python or basic, then assembler, then Haskell or C++.
20:35:16 <cmccann> I think if you're going to give people the "how the machine works" approach, then do it seriously and start from processor architecture
20:35:19 * Philippa remembers her attempt to invent a CPS-based low-level language back before she knew of CPS
20:35:24 <BMeph> @tell rwbarton So, I tried implementing your trick  of using IVars, and noted that to get info out of it uses IO, so, as the old saw goes, "now I have two problems..." ;)
20:35:24 <lambdabot> Consider it noted.
20:35:27 <ben> I feel silly for using system.posix.io's handleToFd to get a Fd to plug into select and then turning right around and using fdToHandle so I can do convenient handle-based io on it
20:35:40 <Philippa> eh. Haskell and assembler simultaneously, the middle if you need it
20:35:44 <ksf> argh don't do select by hand.
20:35:51 <ksf> the IO manager already does that.
20:35:52 <Philippa> really, Haskell isn't as far from the hardware as people usually think
20:35:52 <ben> not by hand but by gtk's mainloop
20:35:56 <ksf> just spawn a thread and block.
20:36:00 <eyebloom> The point I'm making is imperative programming is a more direct path to understanding how the computer works.
20:36:09 <Philippa> it isn't, though
20:36:16 <cmccann> imperative languages have less to do with modern processors than most people think
20:36:40 <mzero> Gosh, if I had a nickel for every Java or C++ programmer that has no idea how the stack actually worked....
20:36:50 <cmccann> even with things like "why does changing the order of indexing a 2D array in nested loops have drastic performance consequences"
20:37:10 <monochrom> eventually, I read a book on quantum physics for how the computer works. nothing to do with programming. nothing. not even microcode.
20:37:30 <Philippa> eyebloom: which of ssa, anf and cps are you familiar with?
20:37:48 <companion_cube> monochrom: even C++ programmers ? :/
20:37:50 * ksf likes cps
20:38:08 <monochrom> anyway, you should take 3 biology classes before you should be allowed to use your muscles.
20:38:12 <companion_cube> how can you write C++ and not know how the stack works, since you have to deal with allocation...
20:38:12 <mzero> for gosh sakes, I think if I were going to teach an intro programming course, I'd start with Lego. Not windstorms, just Lego.
20:38:19 <ksf> ...it's just what complex logic ends up to be, every single time.
20:38:25 <monochrom> and take 5 neurology classes before using your brain
20:38:31 <ksf> usually without ContT, even.
20:38:45 <monochrom> "you have to know how it works before you program it"
20:38:47 <ksf> ...just a k scattered through a handfull of functions.
20:39:00 * BMeph recommends looking at Levien's Io paper, if he "really likes cps"... ;)
20:39:00 <eyebloom> How many programmers here started with pure functional programming?
20:39:08 <mzero> companion_cube: boggles the mind, I know... but there they are, returning pointers to variables on the stack....
20:39:25 * BMeph recommends it to anyone, but particularly to ksf, BTW.
20:39:30 <mzero> ... and having it work much of the time (cause they just use in the calling function...er... quickly!)
20:39:40 <Philippa> Not many currently, I imagine
20:39:41 <ksf> BMeph, are you thinking of *that* language called IO wich has an interpreter called "amalthea"? written in ocaml?
20:39:48 <eyebloom> I would bet none.
20:39:59 <ksf> the language is described in advanced programming language design.
20:40:01 <Philippa> I wouldn't bet on none with this many clients connected
20:40:13 <ksf> a highly recommendable, throughout, and sometimes absurd book.
20:40:32 <monochrom> how many programmers here started with building circuits with logic gates?
20:40:35 <cmccann> eyebloom, Haskell is occasionally used as an introductory language, you know
20:40:36 <ksf> cf. powerloops.
20:40:54 <ksf> monochrom, I learned how to build adders.
20:40:58 <Philippa> I know there is at least one regular who's taught Haskell as a first language. I know at least one person who met Haskell as his first language at uni, but I suspect he'd at least met bash first
20:41:04 <ksf> kv-diagrams, everything.
20:41:05 <cmccann> and I recall one question on SO from a non-programmer who'd learned Haskell mostly independently and no other languages
20:41:06 <ski> (BMeph : not Raphael Finkel ?)
20:41:13 <eyebloom> I'm just arguing that there isn't much evidence that Haskell is a good place to start.
20:41:19 <Philippa> monochrom: I didn't build 'em, but I met the gates before I first programmed. Complete with wooly mammoths
20:41:19 <BMeph> ksf: No, I am not. I am speaking of it. Also, that implementation is based more on Finkel's APLD, which significantly changed the syntax.
20:41:20 <eyebloom> empirical evidence
20:41:24 <Philippa> eyebloom: bullshit
20:41:36 <ksf> ooooh.
20:41:37 <eyebloom> Please... your tone.
20:41:44 <Philippa> you're arguing beyond that into "this means that it isn't"
20:41:44 <aavogt> anecdotal evidence
20:41:48 <ksf> you should tell that guy who implemented amalthea about the original author.
20:41:51 <mzero> eyebloom: I don't think there is much evidence that any one particular place is a good place to start!
20:41:57 <cmccann> I think tony morris would be a good person to ask about this
20:41:59 <ski> BMeph : link to paper ?
20:42:02 <BMeph> ksf: My version of the interpreter is so far a straight rip-off of Amalthea, but I plan on re-doing it right.
20:42:17 <ksf> finkel must've lost a citation, somewhere.
20:42:30 <Philippa> eyebloom: I'll worry about my tone when one of the other ops tells me to, thanks. Stop being disingenuous
20:42:30 * ski only knows about
20:42:32 <ski> @where APLD
20:42:32 <lambdabot> "Advanced Programming Language Design" by Raphael Finkel in 1996 at <http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/>
20:42:47 <BMeph> ski: Looking. I've only found the ACM-corralled version, though. :/
20:43:14 <parcs`> for a data structure like a 'Map Integer' that acts like an autoincrementing sql table wrt insertion, should one just use a Seq?
20:43:15 <ski> ksf : why, powerloops are cool !
20:43:32 <eyebloom> I'm just arguing one side. I think the other side is valid and interesting.
20:43:39 <iwtu> I think tha you, people, take into account just your minds and you experiences. I think is is not good enough
20:43:47 <parcs`> it has constant-time insertion and logarithmentic index lookup
20:43:53 <cmccann> eyebloom, to a first order of approximation there is no evidence that any programming language is a good place to start
20:43:54 <Sgeo> Quick question: Anything more efficient than lists for use in the writer monad? I know prepending to lists is efficient, but using a List for the writer monad doesn't do that by default, I think
20:44:06 <eyebloom> True.
20:44:07 <iwtu> we can argue what is the most important on the begging
20:44:16 <Philippa> eyebloom: then adjust /your/ tone, thanks. Less of the authoritative, factual and final. More of the uncertain and belief-driven.
20:44:23 <ksf> Sgeo, difference lists.
20:44:24 <iwtu> and then find some languages
20:44:33 <monochrom> Sgeo: if you like to append a lot, try Data.Sequence
20:44:40 <iwtu> but argue about langues is quite ...
20:44:47 <Sgeo> Although this might be a premature optimization, I guess.
20:44:52 <ksf> nah, data sequence is for appending *and* prepending.
20:44:53 <Sgeo> WAY WAY WAY premature, for that matter.
20:45:13 <ksf> Sgeo, http://www.haskell.org/haskellwiki/Difference_list
20:45:19 <ksf> well, there's a library to do it.
20:45:35 <Philippa> in the meantime, I can construct a perfectly good machine model in terms of pure FP. And it'll tell you a lot more about keeping it together while doing weird things in asm than the usual model for imperative languages does
20:45:40 * hackagebot http-enumerator 0.7.2.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.2.1 (MichaelSnoyman)
20:45:50 <mzero> parcs`: do you actually need to Integer values? or just unique keys?
20:46:28 <iwtu> there are people for whom minds is best to start with C. there are minds for haskell. there are minds for assembler
20:46:30 <Philippa> this may have some connection with the fact one model brushes all the reasoning tools under the carpet in the name of showing you the machine
20:46:38 <eyebloom> Haskell is also lazy. Which makes it difficult to trace. Which is the main reason I think it's not good for begginers.
20:46:52 <iwtu> and now. can you tell me why overiding show is bad idea? :)
20:47:00 <Philippa> who needs to trace when hand evaluation is so easy?
20:47:14 <Philippa> (not entirely joking there, btw. And yes, I have traced machine execution by hand too)
20:47:44 <mzero> iwtu: that I just don't believe at all - I don't think people have any "intrinsic way of thinking about programming" that would somehow be best served by learning some particular language first
20:47:47 <ksf> iwtu, because it's supposed to be the counterpart of read
20:47:53 <monochrom> all evaluation orders equally easy to trace. at least by hand.
20:48:08 <ksf> there's pretty printing classes around.
20:48:21 <Philippa> mzero: you don't need an instrinsic way of thinking about programming for that. You just need a current set of congitive tools
20:48:41 <nexion> is it possible to make the main thread wait until an exception (such as the one generated by CTRL+C being pressed) occurs? something like doing threadDelay, but permanent
20:48:46 <cmccann> mzero, no, there are intrinsic ways of thinking about programming. they're almost universally wrong ways
20:48:47 <ksf> there's an equally valid point to be made that one should'nt use read/show serialisation, though.
20:48:52 <mzero> iwtu: do you mean implementing show for one of your own types? why would that be bad? though ... it may not be what you're after if you just want a way to format your data for output
20:48:59 <eyebloom> Hand tracing is good, but you can't hand trace an error that you aren't seeing.
20:49:00 <cmccann> programming requires unnatural ways of thinking
20:49:11 <ksf> nexion, block on a TVar or such.
20:49:30 <ksf> caveat: you have to have some code that can actually write to it, or the rts will end your program for you.
20:49:41 <Philippa> eyebloom: and how would you know the error exists in the first place, regardless of language?
20:50:00 <mzero> cmccann: you think there are? Has this been studied?
20:50:02 <Philippa> (honestly? I have a much easier time debugging haskell)
20:50:11 <eyebloom> Because it's not doing what you expect it to?
20:50:18 <iwtu> mzero: peaole are different. people think different. for different people are different natural ways
20:50:27 <Philippa> eyebloom: that sounds like something I can see to me
20:50:29 <ksf> in what sense does laziness make tracing hard, btw?
20:50:42 <nexion> ksf: yeah, I was worried about that.. I guess forever $ threadDelay will do
20:50:46 <Philippa> mzero: yes, it has
20:50:58 <ksf> nexion, why?
20:50:58 <monochrom> in the only sense that no one bothers to write the tracing debugger
20:51:06 <Philippa> it's extremely familiar to university disability departments, for example
20:51:07 <ksf> you *ought* to have some way to terminate the program.
20:51:17 <nexion> just ctrl+c for now
20:51:22 <mzero> iwtu: sure, but I don't think there is any mapping between the different ways people think, and the small differences (compared to differences in thinking) in the ways programming languages code
20:51:39 <aavogt> things like this stack overflow are hard to fix http://hpaste.org/54574 (ie. please fix it :) )
20:51:39 <Philippa> the most extreme differences often correspond to conditions like NVLD, dyslexia, dyscalcula, dyspraxia...
20:51:45 <cmccann> mzero, I'm being somewhat snide. my point is that the kind of mental model necessary to program a computer, to deal with a machine that does exactly what you say and not what you meant, is something that has to be learned
20:51:45 <mzero> Philippa: pointers?
20:52:02 <nexion> I originally had it going into a socket accept loop, but that interfered with exception handling since ctrl+c was being caught there
20:52:14 <cmccann> no matter how someone intrinsically thinks about things, they're almost guaranteed to have a wrong way of thinking about programming at first
20:52:21 <mzero> I agree with that whole heartedly - it is somewhat unnatural  -
20:52:58 <monochrom> aavogt: have you seen my http://www.vex.net/~trebla/haskell/lazy.xhtml ? :)
20:53:18 <iwtu> mzero: pure naturality non-exists. human can change what is natural for their
20:53:21 <eyebloom> I think we should start students off with Agda. Let's not have them screwing around in non dependently typed languages. ;)
20:53:25 <iwtu> *them
20:53:52 <BMeph> ksf: BTW, my interpreter is called Ganymede, and it's on hackage.
20:54:00 <mzero> right- so teaching programming must be about the art of translating the real and social world into the rigid world of computers - and that is the nut to teach - Haskell, C++, Java, or heavens even Basic, is just the tool to teach that --- if instead, you are teaching Basic, or teaching C++, or even teaching Haskell, .... then it is a disservice
20:54:38 <cmccann> @quote babbage
20:54:38 <lambdabot> CharlesBabbage says: On two occasions I have been asked, 'Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?' I am not able rightly to apprehend the kind
20:54:38 <lambdabot> of confusion of ideas that could provoke such a question.
20:55:15 <mzero> that's lovely!
20:55:33 <Philippa> eyebloom: Not totally pointless, but not a tradeoff I'd pick straight away right now. I might well pick descendant of both Haskell and Cayenne if it were still suitably practical though
20:55:55 <cmccann> mzero, as you can see, that fundamental hurdle in understanding programming hasn't changed in a long time :]
20:56:05 <hpaste> xil pasted “SDLMandelbrot” at http://hpaste.org/55727
20:56:13 <iwtu> what is the most important? knowing of alphabet and ability to write or children should use vim when they learn how to write?
20:56:25 <xil> for anyone that's interested, that's all the source for the current state of my mandelbrot program
20:56:33 <mzero> good night all
20:56:44 <monochrom> wait, I think you need to know the alphabet for using vim
20:57:05 <xil> left mouse button zooms in and 'r' resets to the initial view. That's all it can do for now =[. Also be patient for it to render when zoomed in
20:57:14 <cmccann> incidentally, that quote is even funnier with the context that the people asking Babbage that were members of Parliament
20:57:15 <iwtu> I think that C++ is learning to write with vim
20:57:21 <iwtu> :)
20:57:48 <xil> I think it'd be awesome if kids learned Vim in school
20:57:56 <xil> I use gvim for coding
20:58:30 <iwtu> and now we have problem what is and not is healthy :D
20:59:04 <monochrom> how to encourage schools to teach vim: make sure each vim license costs $500 "normally", then tell schools they can get deep discounts
20:59:15 <xil> haha
20:59:17 <Philippa> cmccann: to be fair, they may have believed he was a crank and been fishing for something that was obviously bullshit to confirm it
20:59:46 <Philippa> I think C++ is learning to write with ed
21:00:13 <monochrom> oh, now I see how to parse "c++ is learning to write with blah"
21:00:34 <aavogt> monochrom: I think I follow your examples. But then applying that to see what's causing the stack overflow in a larger piece of code (which references even more code in Data.Map and Numeric.AD.Mode.Forward) seems like it will take at least as much effort as it took to write that in the first place.
21:01:13 <aavogt> maybe I'm just complaining that it's supposed to be easy
21:01:17 <iwtu> Philippa: that's not good comparation. C++ is very poweful, vim too.
21:01:20 <ksf> xil, now make it max out my multi-core cpu and gpu
21:01:42 <ksf> mandelbrot is embarrassingly parallel.
21:01:43 <xil> ksf: haha. Would be nice if I knew how to do that kind of thing
21:01:48 <Philippa> iwtu: fair enough. TECO, then.
21:02:36 <Philippa> alternatively: C++ is learning to write, on paper, at a desk, using a rapier
21:03:28 * monochrom couldn't wait until C++ is learning to sing and dance, too. what a fast-learning kid. :)
21:03:56 <Philippa> C++ is learning to launch missiles!
21:06:06 * ksf still doesn't know how to get at the package database in any other way but calling ghc-pkg by hand or using that package the ghc release notes tell me not to use.
21:06:41 <ksf> ...that might be because cabal is designed from an api pov, however.
21:07:22 <ksf> and getting hold of the raw database is considered low-level enough to be hidden behind a vogon fleet.
21:08:23 <xil> ksf: could you recommend a way for me to parallelize my computation?
21:09:08 <ksf> uh, there's multiple ways. the probably simplest is to start <numcore> workers and give each one of those a chunk to compute.
21:09:21 <ksf> then there's dph, but you need cuda for that.
21:09:31 <ksf> and then there's opencl.
21:09:38 <aavogt> @hackage strategies
21:09:38 <lambdabot> http://hackage.haskell.org/package/strategies
21:10:03 <ksf> the computation is trivial enough to run under glsl, too, though.
21:10:09 <aavogt> @hackage parallel -- actually
21:10:09 <lambdabot> http://hackage.haskell.org/package/parallel -- actually
21:10:12 <Sgeo> @hackage foobar
21:10:12 <lambdabot> http://hackage.haskell.org/package/foobar
21:10:53 <Sgeo> @hackage
21:10:53 <lambdabot> http://hackage.haskell.org
21:10:57 <Sgeo> @hackage
21:10:57 <lambdabot> http://hackage.haskell.org
21:11:07 <xil> ksf: wowowow. GLSL is for running computations directly on the graphics card right? I didn't know Haskell could do that
21:11:42 <ksf> well, glsl is *intended* to display everything on the screen. it's more of a hack to use it for computation.
21:11:48 <ksf> but cuda and opencl are made for it.
21:12:04 <ksf> oh, there's repa, too
21:12:08 <ksf> @hackage repa
21:12:08 <lambdabot> http://hackage.haskell.org/package/repa
21:13:24 <xil> seeing as I'm a beginner, would anyone recommend a single approach for me to start with?
21:17:24 <ksf> definitely start with someone running on the cpu, and gpu stuff is either very low-level (involving writing non-haskell code) or experimental.
21:17:44 <ksf> parallel is probably the right way to do it.
21:18:25 <ksf> but depending on where you're coming from, forkIO/STM might be easier.
21:19:10 <xil> parallel as in Strategies?
21:19:28 <ksf> parallel as in that what aavogt said, yes.
21:20:00 <xil> I definitely feel like I should learn about strategies. I'm big on parallel programming. It's something I find very interesting and love exploring in other languages
21:20:17 <xil> so if it's the right way I guess it's a great time to learn =]
21:21:06 <ksf> you'll love STM if you've ever wrestled with locks.
21:21:42 <JaMeSiTeGeN> Anyone here know how to solve this issue?
21:21:50 <JaMeSiTeGeN> http://sprunge.us/EAZi
21:21:53 <JaMeSiTeGeN> http://sprunge.us/HfdG
21:22:11 <xil> I've gotten to see a bit of STM already and it's pretty awesome
21:22:14 * JaMeSiTeGeN is somewhat new to haskell. and no one it talking in #xmonad.
21:22:21 <ksf> gah no line numbers.
21:22:44 <Sgeo> JaMeSiTeGeN, post it in hpaste?
21:22:50 <Sgeo> Although I guess that might be annoying
21:22:52 <aavogt> $ s -> if   should be   $ \ s -> if
21:22:57 <JaMeSiTeGeN> ^^ my links with line numbers and haskell syntax, add ?haskell
21:23:08 <JaMeSiTeGeN> http://sprunge.us/EAZi?haskell
21:23:10 <JaMeSiTeGeN> There.
21:23:21 <JaMeSiTeGeN> Sgeo: Need to be hpaste?
21:23:25 <Sgeo> JaMeSiTeGeN, no
21:23:30 <JaMeSiTeGeN> Okay.
21:23:31 <cmccann> aavogt seems to have the answer anyway
21:24:16 * aavogt forgets if indentation of the else will matter
21:24:32 <Sgeo> Probably will
21:25:33 <JaMeSiTeGeN> Thanks Sgeo !!
21:26:07 <Sgeo> o.O erm, what did I do?
21:26:14 <JaMeSiTeGeN> egg. wrong name.
21:26:18 <JaMeSiTeGeN> aavogt: ^^ :D
21:26:20 <JaMeSiTeGeN> Thanks!
21:26:31 <JaMeSiTeGeN> Sorry Sgeo
21:26:39 <Sgeo> lol
21:27:32 <Sgeo> np (if me not saying np would make you think I'm angry or something, which I'm not, which... grah)
21:27:38 * Sgeo is a bit weird with social stuff
21:28:14 <JaMeSiTeGeN> err. How do I get back to the gimp work space?
21:29:57 <JaMeSiTeGeN> aavogt: Do you know how to switch to the other workspace?
21:30:27 <aavogt> no
21:31:15 <JaMeSiTeGeN> :(
21:31:20 * JaMeSiTeGeN is trapped away
21:31:32 <JaMeSiTeGeN> hehe, mod4 + g for the gridselect :D
21:35:28 <JaMeSiTeGeN> Humm, the workspace is created at the start. can I make it append instead of prepend?
21:37:54 <cmccann> JaMeSiTeGeN, not sure how many people in here are xmonad users, if you need help with it specifically you may be out of luck
21:38:19 <JaMeSiTeGeN> cmccann: :(
21:41:04 <hpaste> iwtu pasted “IO” at http://hpaste.org/55728
21:41:47 <iwtu> how can I solve this error?
21:42:18 <iwtu> Couldn't match expected type `IO b0' with actual type `[IO ()]'
21:42:28 <Sgeo> What line?
21:42:49 <iwtu> 212
21:44:30 <c_wraith> usually something like mapM_ instead of map
21:45:04 <iwtu> I didn't find what is map_M
21:45:11 <c_wraith> :t mapM_
21:45:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:45:15 <iwtu> mapM_
21:45:37 <c_wraith> @hoogle mapM_
21:45:37 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
21:45:37 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
21:45:37 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
21:49:25 <iwtu> I suppose I need Control.Monad.mapM_
21:49:56 <c_wraith> hoogle's reporting it should be in the Prelude
21:49:56 <iwtu> Not in scope: `Control.Monad.mapM_'
21:52:01 <ksf_> :t sequence
21:52:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:52:05 <ksf_> :t forM
21:52:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
22:24:57 <parcs`> anyone know what mzero would have suggested if the answer to his question "do you actually need to Integer values? or just unique keys?" is yes?
22:25:12 <parcs`> or rather, yes, unique keys?
22:27:01 <parcs`> i'm probably speaking too out of context... disregard
22:30:40 * hackagebot cab 0.1.8 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.8 (KazuYamamoto)
22:51:45 * Sgeo looks for a library that models circuits without modelling physical properties of such, just logical things like NAND
22:52:07 <Sgeo> I want to write logic circuits in a certain virtual world. I have a way of translating some things into it
22:52:15 <Sgeo> But it's different from RL circuitry
22:52:18 <Sgeo> I know it supports NAND
22:55:07 <Sgeo> Maybe I'll see if I could coerce Lava into doing it
22:57:32 <Sgeo> Well, I could ignore writeVHDL perhaps
22:59:52 <Mathnerd314> use Haskell?
23:05:42 <Philippa> Mathnerd314: you don't know what Lava is, do you?
23:05:51 <Mathnerd314> nope
23:06:04 <Philippa> http://raintown.org/lava/
23:07:09 <Mathnerd314> "The number of people that know about both can easily fit inside a medium sized elevator."
23:07:46 <kmc> was "use Haskell?" a suggestion, or a request for clarification about the question?
23:08:13 <Mathnerd314> RFC of course
23:09:05 <kmc> Sgeo, are your circuits combinational logic only, or do they have state
23:09:11 <Sgeo> No idea
23:09:20 <Sgeo> Wait, hmm?
23:09:33 <Sgeo> You mean the "physical" things that make them up?
23:09:38 <Sgeo> They have state, sort of.
23:09:44 <kmc> no
23:10:08 <kmc> you say you want to model circuits.  do you mean combinational logic circuits, where the outputs are a pure function of the current inputs only?
23:10:19 <kmc> or do you mean circuits with stateful components, like flip-flops and registers?
23:10:35 <Sgeo> Flip-flops would be nice
23:11:09 <Mathnerd314> "They have state"
23:11:15 <Sgeo> Although I guess they make things more complicated
23:11:27 <Mathnerd314> yes, that's fine
23:11:43 <Mathnerd314> just so long as I don't see it
23:12:19 <kmc> the distinction between the two is something logic designers think about
23:12:22 <kmc> not just functional programmers ;)
23:12:46 <kmc> when you say you want to "model circuits"... what do you want to do with those models?
23:13:07 <kmc> you want to design them at a high level and produce something lower level?
23:13:10 <kmc> you want to simulate them?
23:13:26 <Sgeo> Design high-level and produce low-level
23:13:30 <kmc> you want to analyze them for desirable properties?
23:13:35 <kmc> ok
23:13:41 <Sgeo> The circuits I design probably can't be too complicated
23:13:50 <Sgeo> Otherwise there won't be space (long story)
23:13:59 <Mathnerd314> Sgeo: make them as complicated as you can
23:14:13 <mjrosenb> kmc: even circuits where the outputs are a pure function of the inputs are kind of annoying to model (gate delay and all)
23:15:22 <kmc> yeah
23:15:38 <kmc> there are real design problems for both
23:15:57 <Peaker> gate delay is a post-synthesis thing, though
23:17:15 <mjrosenb> Peaker: you may want to tweak you HDL in order to get better gate delays though...
23:18:03 <Peaker> mjrosenb: yeah, if you can't minimize the logic, you split it to multiple clocks I hear
23:18:11 <Peaker> (with flops connecting the clocks)
23:18:50 <kmc> on FPGA you also have contention for interconnects
23:21:51 <kmc> i've never done it, but my understanding is that you compile your HDL to a netlist, and feed that into the FPGA toolchain, and it chews for a while and eventually tells you what the max clockspeed is
23:22:03 <kmc> and then you have to figure out wtf to change at the HDL level to improve that
23:24:30 <mjrosenb> yup.
23:25:20 * mjrosenb remembers watching my roommate's laptop with 256 mb RAM swap out for half an hour attempting to optimize
23:30:41 * hackagebot cab 0.1.9 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.9 (KazuYamamoto)
23:59:57 <qnikst> hello, i'm making a simple tcp server, and have a problem how to check that client closed connection?
