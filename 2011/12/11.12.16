00:00:12 <rien> or the name of an algorithm, that would be ideal :)
00:12:43 <salisbury> I read on here the other day that most times in haskell, using !! is not the best solution
00:12:51 <dmwit> yes
00:13:03 <DanBurton> avoid !! and length if you can
00:13:08 <salisbury> how, then, is it recommended to get the nth item in a list?
00:13:14 <DanBurton> !!
00:13:27 <DanBurton> rather, it isn't recommended you get the nth item
00:13:38 <DanBurton> or if you really need random access to your list, use an array instead
00:13:40 <dmwit> It is recommended that you arrange your algorithm to avoid needing to get the nth item in a list.
00:13:57 <earthy> salisbury: if you *absolutely* *positively* need the nth item you can just drop n-1
00:14:01 <dmwit> For example, by treating the whole list uniformly or by not using a list.
00:14:15 <DanBurton> earthy: that would be the same as !!
00:14:29 <dmwit> No, I agree with earthy that drop n is better than !!.
00:14:34 <earthy> danburton: ah... no. drop clarifies that you're dropping work.
00:14:38 <dmwit> Just look at the types. =)
00:14:59 <dmwit> ?quote sprynge
00:14:59 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
00:15:22 <MostAwesomeDude> Hm. Is there an efficient way to do products, combinations, permutations, etc. on [a] instead of [Int]?
00:15:40 <dmwit> :t liftM2 -- products
00:15:41 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:15:46 <dmwit> :t permutations
00:15:46 <lambdabot> forall a. [a] -> [[a]]
00:15:53 <dmwit> :t combinations -- ?
00:15:54 <lambdabot> Not in scope: `combinations'
00:16:08 <earthy> dmwit: is that efficient though? :)
00:16:20 <earthy> (effective in programmer time yes)
00:16:22 <dmwit> MostAwesomeDude: Remind me what combinations are?
00:16:55 <MostAwesomeDude> dmwit: n choose k : given n possibilities, take k of them, order doesn't matter.
00:17:14 <MostAwesomeDude> permutations isn't the right function; I need to be able to specify k.
00:17:29 <dmwit> Perhaps I'm misunderstanding what you want, then.
00:17:31 <yitz> DanBurton: personally, i would say use a sequence or a map. i use arrays only when really needed for optimization, which is extremely rarely. for me, sequences and maps have a more comfortable functional feel to them than arrays.
00:17:44 <MostAwesomeDude> Currently I'm just hammering the list monad, but that's very slow and causing quite a buildup of thunks.
00:18:15 <MostAwesomeDude> do { first <- [0 .. n]; second <- [first .. n]; return (first, second) } or so.
00:19:54 <dmwit> You won't get much more efficient than that, no.
00:20:42 <MostAwesomeDude> Hm. Maybe I need to figure out how to inline my predicates into that monad, then. I'm doing some constraint solving and apparently the domain's pretty large. :3
00:21:16 <dmwit> Yes, for constraint solving, you must have predicates interleaved with samples.
00:21:40 <dmwit> There's some code somewhere on Hackage, I believe, if you want to steal from others.
00:21:40 <MostAwesomeDude> I'm currently on a restricted domain of about 700K. I'm not super-excited about what might happen when I get up to the full domain of, oh, I think around 15T or so.
00:21:52 <MostAwesomeDude> Is there? I couldn't find anything that didn't just interact with Ints.
00:21:57 <MostAwesomeDude> Maybe I should go search again.
00:24:46 <MostAwesomeDude> Hm, cflp might do it, but it's totally undocumented. :T
00:25:31 <MostAwesomeDude> monadiccp doesn't even have API docs!
00:27:43 <hpaste> dmwit pasted “what gives with these type families?” at http://hpaste.org/55332
00:28:23 <ddarius> rien: There is no algorithm.  You just execute the code symbolically.
00:28:43 <sipa> MostAwesomeDude: i'll upload a new version soon
00:28:56 <sipa> strange that there are no docs for 0.7
00:29:04 <ddarius> rien: RPN is just a flattened representation of a tree.
00:29:47 <MostAwesomeDude> sipa: <3
00:30:00 <MostAwesomeDude> sipa: I can specify my own domains? I don't have to work with Ints?
00:30:24 <sipa> you could, but the entire FD layer does use Ints
00:30:48 <sipa> the package should be split into mcp-as-a-generic-framework and the fd layer
00:31:24 <MostAwesomeDude> Well, I can always map in and out of Ints since my domains are Enum'd.
00:31:52 <sipa> yeah, that was one idea i never got to implement: automatically accept any Enum domain
00:32:08 <MostAwesomeDude> Should definitely be possible, just lots of typing.
00:32:23 <sipa> the whole thing is already one mess of types :)
00:47:56 <ddarius> > let plus (x:y:xs) = (x+y):xs; push = (:); rpn = foldr (>>>) id; in rpn [push 1, plus, plus] [1, 2 :: Expr]
00:47:56 <lambdabot>   [1 + 1 + 2]
00:49:04 <rien> I'll look into that Expr stuff, but still...
00:49:12 <rien> gtg now, g'night
00:49:45 <shachaf> rien: ddarius's solution would work just as easily with non-expr values and a non-+ function.
00:49:48 <Axman6> wait, how does that work...
00:51:18 <ddarius> data E = Add E E | Num E; op2 f (x:y:xs) = f x y:xs; rpn [push (Num 1), op2 Add, op2 Add] [Num 1, Num 2]
01:04:15 <augur> anyone awake?
01:04:25 <salisbury> aye
01:04:47 <dmwit> yep
01:05:02 <salisbury> though I'm rarely of any help yet
01:08:37 <salisbury> urgh.. how do I do something like Maybe (IO (a))
01:08:57 <salisbury> without resorting to Maybe a + unsafePerformIO...
01:09:15 <dmwit> :t Just (print 3)
01:09:16 <lambdabot> Maybe (IO ())
01:09:20 <dmwit> You just... do it?
01:09:31 <dmwit> Or did you want something like Maybe (IO a) -> IO (Maybe a)?
01:09:39 <dmwit> :t traverse :: Maybe (IO a) -> IO (Maybe a)
01:09:40 <lambdabot> Not in scope: `traverse'
01:09:47 <augur> what do you peeps think is the next big wave in programming language design
01:09:56 <dmwit> :t Data.Traversable.traverse :: Maybe (IO a) -> IO (Maybe a)
01:09:56 <lambdabot>     Couldn't match expected type `Maybe (IO a)'
01:09:57 <lambdabot>            against inferred type `a1 -> f b'
01:09:57 <lambdabot>     In the expression:
01:09:57 <augur> after functional programming/dependent types of course :p
01:10:19 <ben> something related to javascript, no doubt
01:10:28 <dmwit> :t Data.Traversable.sequence :: Maybe (IO a) -> IO (Maybe a)
01:10:29 <lambdabot> forall a. Maybe (IO a) -> IO (Maybe a)
01:10:35 <salisbury> oh, nice
01:10:39 <salisbury> traverse, thanks
01:10:53 <augur> ben: agda can compile to javascript
01:11:24 <ben> can't UHC too?
01:11:28 <sipa> augur: object-oriented assembly
01:11:51 <salisbury> sipa: hand written binary
01:12:53 <salisbury> I'm not sure why folks like javascript so much
01:13:07 <ben> I suspect it's because it has a really big install base, mostly
01:13:42 <augur> ok whats the next /innovative/ thing :P
01:13:50 <DanBurton> :t let sequenceMaybe Nothing = return Nothing; sequenceMaybe (Just foo) = Just <$> foo in sequenceMaybe
01:13:51 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f) => Maybe (f a) -> f (Maybe a)
01:13:52 <augur> exotic, whacky, out there
01:13:54 <ddarius> ben: There are other languages with really big install bases that aren't particularly liked/popular.  It's not just that it has a large install base, but -what- that install base is.
01:14:34 <dmwit> DanBurton: Yep, that's the implementation of sequence for Maybe.
01:15:03 <DanBurton> cool sauce :)
01:15:32 <dmwit> (Actually, the Maybe instance just defines traverse, and sequence comes for free. But that's what the implementation would be if you expanded it out.)
01:15:49 <salisbury> DanBurton: nice, that is quite enlightening actually
01:15:55 <dmwit> :t traverse id
01:15:55 <lambdabot> Not in scope: `traverse'
01:16:03 <dmwit> :t Data.Traversable.traverse id
01:16:03 <lambdabot> forall (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t (f b) -> f (t b)
01:16:28 <salisbury> augur: I'm interested to see how these new-fangled 'neural computers' and 'quantum computers' will be programmed
01:16:51 <augur> neural computers relates to something ive been interested in for a while
01:18:02 <salisbury> but surely conventional programming techniques will be wildly inapplicable..
01:18:27 <augur> theres this thing
01:18:36 <augur> i dont know if it has a name currently but basically
01:18:57 <augur> your computations are parallel in a way thats different from what we usually think
01:19:22 <salisbury> any linkage?
01:19:38 <augur> i generally think of it as "holographic" computing, but a more fashionable name for it might be precision/accuracy parallelism
01:19:50 <augur> instead of like data parallelism
01:19:53 <augur> i dont really have a link
01:20:24 <augur> but the basic idea is that the computation for any given bit of information happens _everywhere_ simultaneously
01:20:46 <salisbury> well damn
01:20:49 <augur> and as you scale the processor(s), the result is increasingly accurate or precise
01:21:17 <augur> sort of like how a hologram can be broken in two and the result is not half a hologram on each piece but rather two copies of the whole hologram
01:21:22 <augur> with half the information of the original
01:21:56 <salisbury> You know, I remember reading something some time ago speculating that the brain worked in a similar manner
01:22:00 <augur> and i think some people view the brain as being sort of like this -- the computation involved in most tasks isnt localized. the brain is massively parallel, but not by breaking the problem up into smaller chunks or whatever
01:22:03 <salisbury> and we just can't detect it yet
01:22:20 <ddarius> Just a Fourier transform.
01:22:22 <augur> but by having the entire problem computed at smaller levels of accuracy and then composed into a larger more accurate answer
01:22:39 <augur> haha salisbury :)
01:22:56 <augur> im glad were on the same wavelength
01:23:08 <augur> my main interest in this is only to see what such a thing would be like mind you
01:23:48 <augur> its such a weird idea, to compute the whole answer at some low accuracy, and then somehow combine multiple answers to get better accuracy
01:24:08 <dmwit> It isn't so weird if you think about doing sampling from a random distribution.
01:24:11 <dmwit> Let each CPU do one sample.
01:24:16 <dmwit> That's a crappy accuracy.
01:24:27 <dmwit> But combine lots of samples... that's *statistics*.
01:24:33 <augur> :)
01:24:49 <augur> im interested in more principled solutions!
01:25:01 <augur> i dont know if such a thing exists actually
01:25:07 <augur> but if such a thing does, thatd be interesting to me
01:25:29 <salisbury> very,
01:25:34 <dmwit> Corollary: The brain responds randomly. But accurately.
01:25:56 <augur> by principled i mean not probabilistic
01:26:08 <ddarius> augur: Go read Butera's thesis "Paintable Computing"  Most of it is not relevant to your later questions (though it is tenuously related to your initial question), but you'll know when you get to the relevant part.  Also, it's an interesting paper.
01:26:11 <salisbury> There is always that merge/combine step with parallelism though
01:26:13 <shachaf> dmwit: elliott is gone, but even simpler: type family F a; f :: x -> F a; f = undefined; f' a = f a
01:26:33 <augur> salisbury: thats why its such an interesting notion, right
01:26:33 <dmwit> elliott = ehird?
01:26:36 <shachaf> Yes.
01:26:37 <augur> there is no merge
01:26:40 <dmwit> cool
01:26:40 <salisbury> yeah
01:26:44 <shachaf> We were talking about your post in #esoteric.
01:26:45 <dmwit> Thanks for the further simplification. =)
01:27:00 <augur> salisbury: at least not in the usual sense
01:27:02 <dmwit> It's weird, right?
01:27:15 <dmwit> Actually, half the time I can almost believe what GHC is complaining about.
01:27:29 <augur> if theres a merge its a gigantic arbitrary arity operation
01:27:36 <augur> and the computation is only one level deep ever
01:27:39 <salisbury> I've personally bashed my head against many a wall trying to at least make the merge step implicit
01:28:02 <augur> like with a hologram -- the merge step is just two photons smashing into your eye at the same time
01:28:11 <augur> or a million photons
01:28:14 <augur> or whatever
01:28:28 <dmwit> I mean, it's trying to check that a thing has type "F a1 b1", so it infers a type "F a2 b2" and then tries to check that "F a1 b1 ~ F a2 b2", which fails.
01:28:41 <salisbury> you know, matrices
01:28:49 <dmwit> Because it can show that "a1 ~ a2".
01:28:51 <salisbury> you've just given me a fantastic idea augur
01:29:04 <dmwit> So maybe the problem is not enough forall's?
01:29:27 * shachaf >>= sleep
01:29:31 <dmwit> okay =)
01:30:09 <DanBurton> may your dreams be filled with type-safety
01:30:29 <augur> do shachaflette <- shachaf ; sleep shachaflette
01:31:22 <dmwit> Functions aren't even needed, it turns out.
01:36:13 <dmwit> What's the state of the art in Traveling Salesman heuristics?
01:36:52 <dmwit> My Google Scholar search turned up mostly stuff from the 1970's, but I thought there were some more modern takes on the problem.
01:37:41 <ddarius> @google ant colony optimization
01:37:42 <lambdabot> http://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms
01:37:43 <lambdabot> Title: Ant colony optimization algorithms - Wikipedia, the free encyclopedia
01:38:44 <dmwit> thanks
01:39:29 <Sgeo> It's proven that Traveling Salesman can't be done in polynomial time? </troll>
01:46:32 <salisbury> ant colony > genetic algorithms?
01:46:37 <int-e> Sgeo: it depends on your model of computation obviously
01:48:44 <int-e> Sgeo: on a three counterr machine I'll be very impressed if you can do anything interesting in polynomial time :)
01:50:14 * hackagebot xournal-parser 0.2.0 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.2.0 (IanWooKim)
01:50:16 * hackagebot hxournal 0.5.1 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.5.1 (IanWooKim)
02:34:03 <Saizan> yeah
02:58:42 <dskippy> Does anyone know how I can trace a function in Haskell by just telling the interpreter "tell me the inputs and outputs of this particular function"?
02:59:01 <dskippy> I realize this causes problems with not every value being able to be shown.
02:59:36 <sipa> try Debug.Trace's trace
02:59:36 <dskippy> Just wondering if there's an easier way to do this rather than adding print-debug code with the trace librarary.
02:59:42 <sipa> right :)
03:00:16 * hackagebot uuagc-bootstrap 0.9.40.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.40.1 (ArieMiddelkoop)
03:00:18 * hackagebot uuagc-cabal 1.0.2.0 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.2.0 (ArieMiddelkoop)
03:00:20 * hackagebot uuagc 0.9.40.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.40.1 (ArieMiddelkoop)
03:00:30 <dskippy> Yeah so for that I need to add a trace for the whole value, and also add one for the inputs. I have a function that wraps trace into something that will print the value abnd  then return it, to make this a little easier.
03:00:59 <dskippy> But it's annoying to use my process for functions with multiple definition lines.
03:02:00 <mjrosenb1> dskippy: you can wrap the function callsites
03:02:30 <hpaste> papa_smurf pasted “Existential Function Type” at http://hpaste.org/55335
03:02:50 <mjrosenb1> or you can define a wrapped variant of the function
03:02:51 <dskippy> mjrosenb1: Yeah, but if they
03:03:09 <dskippy> If they're recursive it's still more than one place.
03:03:34 <dskippy> Wrap the original caller, possibily many, and then the recursive call.
03:03:49 <mjrosenb1> with the second wrapped one, recursion is simple, just call the wrapped one, rather than the original
03:04:50 <mjrosenb1> i suspect you could even convince template haskell to do that for you
03:04:56 <mjrosenb1> but i've never actually used TH
03:05:06 <dskippy> Yeah possible. I've never used it either.
03:11:56 <papa_smurf> I'm trying to rewrite my Shell-like Pipes in haskell and want to represent an Action as Either a (Shell)Command or a Function. Where Function should represent a binary polymorphic function. http://hpaste.org/55335 Line 17 does not seems to mean what i think it does.
03:12:39 <papa_smurf> *seem
03:14:21 <mjrosenb1> papa_smurf: how are a,c and d related?
03:15:02 <geheimdienst> papa_smurf: i haven't used it myself, but you might be interested in the hsh package
03:15:05 <geheimdienst> @package HSH
03:15:05 <lambdabot> http://hackage.haskell.org/package/HSH
03:15:19 <salisbury> papa_smurf: sounds like arrows may come in handy
03:15:31 <salisbury> (I like arrows)
03:16:29 <salisbury> looking at geheimdienst's suggestion, that is better
03:17:05 <papa_smurf> mjrosenb1: c,d are instances of Content and a frankly i have no idea
03:17:35 <ClaudiusMaximus> i've used HSH some time ago (3 years?) and it was rather nice - i do vaguelly recall having some problems related to ghc no-alloc=no-context-switch optimisations and buffering, but managed to solve them (or at least workaround them..)
03:17:46 <papa_smurf> geheimdienst: i know HSH, the thing is i want to mplement this on my own and exted it
03:18:18 <papa_smurf> *implement *extend
03:18:58 <papa_smurf> slisbury: i feared something like that... i don't get Arrows at all
03:20:06 <salisbury> this conveyor-belt metaphor was really useful for me: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
03:20:59 <mjrosenb1> salisbury: i found it useful for understanding functions-as-arrows
03:21:05 <mjrosenb1> salisbury: and basically nothing else :(
03:22:14 <salisbury> It is also pretty good at explaining concepts such as the ***/&&&/first/second
03:22:16 <papa_smurf> salisbury: i already read that, the point is i didn't get what i can actually do with arrows (in general not just functions)
03:23:17 <salisbury> most of the time arrows are just functions
03:23:49 <salisbury> but the manner in which you compose them allows you to do neat things
03:23:54 <mjrosenb1> i suspect that is like saying "most of the time, Monads are IO"
03:26:43 <papa_smurf> frankly when using combinators like first, second, (***), etc. for functions i can write/use something like that without arrows. that's the point i don't get
03:27:00 <salisbury> not really, if you expand your definition of a function to be more abstract
03:27:07 <salisbury> rather than simply something a -> b
03:27:38 <liyang> With vector, I want to make some Unbox instances for e.g. Maybe. The documentation at http://hackage.haskell.org/packages/archive/vector/latest/doc/html/Data-Vector-Unboxed.html says it "can be very easy."
03:28:03 <liyang> Except that I'm faced with ~50 lines of boilerplate for each instance.
03:28:35 <geheimdienst> i think i understand what first/&&&/*** do for tuples, but besides that, Arrow is a complete mystery to me
03:28:43 <geheimdienst> > (succ *** pred) (4,7)
03:28:44 <lambdabot>   (5,6)
03:28:52 <liyang> Can anyone suggest a less painful way?
03:29:43 <liyang> first/&&&/*** only work on arrows to/from 2-tuples.
03:30:13 <salisbury> I use them a lot for text processing, say you have a url which may be xml or html
03:30:21 <geheimdienst> liyang: right, the type indicates it will always be a tuple
03:30:25 <geheimdienst> :t (&&&)
03:30:26 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:30:58 <salisbury> readAsHtml *** readAsXml &&& getUrl -< url
03:31:09 <salisbury> sure, you could do that without arrows
03:31:15 <salisbury> but with them, it is far clearer
03:31:19 <liyang> So replace (->) with another arrow. :)
03:31:59 <liyang> :t (&&&) :: (b -> c) -> (b -> c') -> (b -> (c, c'))
03:32:00 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
03:32:22 <geheimdienst> salisbury: interesting. doesn't &&& mean "apply these two functions to the same arg"? so you do getUrl on the url and also do (readH *** readX)?
03:32:29 <mjrosenb1> salisbury: what would the type of getUrl be in this case?
03:32:31 <ddarius> You don't gain anything by using the (->) instance of Arrow, other than a few handy functions.  The (->) instance of Arrow is like the Identity instance of Monad.
03:32:33 <geheimdienst> (hmm that doesn't make much sense)
03:33:04 <mjrosenb1> ddarius: what are some interesting instances of Arrow?
03:33:16 <salisbury> sorry, I should have written
03:33:35 <ddarius> mjrosenb1: Automata and Stream processing arrows would be some of the good examples.
03:33:57 <opqdonut> kleisli arrows offer more examples
03:33:58 <salisbury> returnA <<< readAsXml &&& readAsHtml <<< getUrl -< url or so
03:35:20 <mjrosenb1> salisbury: that seems considerably less compact
03:36:26 <salisbury> it is the meat is the same length, I just added a returnA on the end
03:36:45 <ddarius> let u = getUrl url in (readAsXml u, readAsHtml u)
03:37:40 <ddarius> Of course, there's no reason not to write that as (readAsXml &&& readAsHtml) (getUrl url)
03:40:21 <salisbury> ddarius, granted
03:45:19 * hackagebot remote 0.1.1 - Cloud Haskell  http://hackage.haskell.org/package/remote-0.1.1 (JeffEpstein)
03:55:36 <McManiaC> @pl \a b -> f $ a b
03:55:37 <lambdabot> (f .)
04:03:16 <psionski> > tail "wow"
04:03:16 <lambdabot>   "ow"
04:03:32 <psionski> > repeat "wow"
04:03:33 <lambdabot>   ["wow","wow","wow","wow","wow","wow","wow","wow","wow","wow","wow","wow","w...
04:03:38 <psionski> amazing :D
04:03:51 <mjrosenb1> psionski: you mean lambdabot?
04:04:02 <psionski> yeah
04:04:06 <psionski> just saw u using it
04:04:15 <alistra> > fix ("wow":)
04:04:16 <lambdabot>   ["wow","wow","wow","wow","wow","wow","wow","wow","wow","wow","wow","wow","w...
04:04:18 <psionski> I don't have access to haskell at work :)
04:04:22 <alistra> > fix ("wow"++)
04:04:24 <lambdabot>   "wowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwo...
04:04:34 <mjrosenb1> > fix (++"wow")
04:04:38 <lambdabot>   mueval-core: Time limit exceeded
04:04:42 <psionski> hahahha
04:05:00 <alistra> > reverse $ fix ("wow"++)
04:05:05 <lambdabot>   mueval: ExitFailure 1
04:05:05 <lambdabot>  mueval: Prelude.undefined
04:05:12 <alistra> > reverse $ fix ("wow"++)
04:05:16 <lambdabot>   mueval-core: Time limit exceeded
04:05:25 <psionski> how is it guaranteed that it can't be broken ?
04:05:37 <psionski> i'm assuming this isn't just forwarding everything to ghci
04:05:38 <alistra> define broken?
04:05:49 <mjrosenb1> psionski: dons wrote some magic for it
04:05:53 <alistra> IO isn't executed
04:05:58 <mjrosenb1> psionski: thus the mueval in the error message
04:06:04 <alistra> time limit on evaluation
04:06:13 <mjrosenb1> and presumably, a space limit
04:07:11 <psionski> I guess that's just enough safety :)
04:07:12 <alistra> and limit on the output
04:07:30 <psionski> yeah, the limit on the output I already saw :)
04:07:56 <psionski> I mean, it printed my infinite set really fast :D
04:07:57 <alistra> > let f x = f (1 : x) ++ f (2 : x) in f []
04:08:01 <lambdabot>   mueval-core: Time limit exceeded
04:08:29 <McManiaC> whats the notation to add a type to a "forall" variable?
04:08:42 <alistra> > let f x = f (x ++ [1]) ++ f (x ++ [2]) in f []
04:08:44 <lambdabot>   ()
04:08:51 <sipa> McManiaC: example?
04:08:54 <alistra> > let f x = f (x ++ [1]) ++ f (x ++ [2]) in f []
04:08:56 <lambdabot>   ()
04:09:01 <alistra> :t let f x = f (x ++ [1]) ++ f (x ++ [2]) in f []
04:09:03 <lambdabot> forall m. (Monoid m) => m
04:09:20 <alistra> > let f x = f (x ++ [1]) ++ f (x ++ [2]) in f [] :: [Int]
04:09:22 <lambdabot>   *Exception: stack overflow
04:09:24 <McManiaC> sipa: forall a m. Monad m => m a
04:09:25 <alistra> YAY
04:09:54 <alistra> there is a memory limit
04:10:02 <sipa> McManiaC: ok, and what do you want to do now?
04:10:11 <McManiaC>     Expected kind `?', but `FilterMonad m' has kind `(* -> *) -> *'
04:10:11 <McManiaC>     In the type `forall m a. FilterMonad m => a -> m a'
04:10:15 <McManiaC> this is the error I get
04:10:16 <McManiaC> :)
04:10:44 <mjrosenb1> > fix (scanl (+) 1 . (1:))
04:10:45 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
04:11:16 <sipa> > fix $ scanl (+) 1 . (0:)
04:11:17 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:12:01 <mjrosenb1> > fix (scanl (+) 1)
04:12:03 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:12:27 * mjrosenb1 always thought that was an excellent dichotomy
04:12:42 <McManiaC> sipa: no idea?
04:14:06 <sipa> McManiaC: is FilterMonad a class?
04:14:45 <McManiaC> sipa: yes
04:15:01 <sipa> can I see your code?
04:15:19 * hackagebot convertible-ascii 0.1 - convertible instances for ascii  http://hackage.haskell.org/package/convertible-ascii-0.1 (MasatakeDaimon)
04:15:41 <McManiaC> sipa: newtype ResponseCode = ResponseCode { unResponseCode :: forall m a. FilterMonad m => a -> m a }
04:16:04 <McManiaC> FilterMonad is from: http://hackage.haskell.org/packages/archive/happstack-server/6.4.5/doc/html/Happstack-Server-Internal-Monads.html#t:FilterMonad
04:17:49 <McManiaC> sipa: lol nevermind, I didnt see that FilterMonad took two arguments
04:17:50 <McManiaC> sorry
04:17:52 <McManiaC> :)
04:18:02 <sipa> i was just typing that :)
04:25:44 <statusfailed> Is there a trie implementation for lists of any type, not just ByteString?
04:26:34 <statusfailed> wait I think that's a dumb question
04:26:39 <statusfailed> :D
04:26:53 <sipa> why?
04:27:27 <statusfailed> well
04:27:30 <statusfailed> you can do it with a regular tree
04:27:37 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/MemoTrie/0.4.10/doc/html/Data-MemoTrie.html references a paste that no longer seems to exist :(
04:27:46 <statusfailed> but it's not exactly the same I guess
04:28:10 <statusfailed> It seems odd there's only ByteString trie
04:28:20 <ClaudiusMaximus> i guess   Ord k => Map [k] v   would behave like a trie
04:28:51 <ClaudiusMaximus> @src Ord []
04:28:51 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
04:29:05 <statusfailed> :|
04:29:37 <ClaudiusMaximus> well, maybe not
04:30:57 <rostayob> ClaudiusMaximus: no, it doesn't
04:31:16 <statusfailed> trie
04:31:19 <statusfailed> oops
04:31:20 <statusfailed> :D
04:31:20 <rostayob> if you are referring to the containers Map
04:31:20 <ClaudiusMaximus> @hackage list-tries
04:31:21 <lambdabot> http://hackage.haskell.org/package/list-tries
04:32:35 <statusfailed> oh
04:32:35 <statusfailed> nice
04:32:37 <ClaudiusMaximus> @hackage data-inttrie
04:32:38 <lambdabot> http://hackage.haskell.org/package/data-inttrie
04:33:03 <ClaudiusMaximus> @where hayoo
04:33:03 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:33:14 <ClaudiusMaximus> that's where i found them
04:33:25 <statusfailed> that is a great logo
04:33:33 <statusfailed> borderline trademark infringement :D
04:38:07 <hpaste> Flippeh pasted “Lenghty code :(” at http://hpaste.org/55337
04:38:13 <FliPPeh> Oh nice bot
04:38:36 <FliPPeh> Anyways, is there some kind of monad magic that allows me to makes this less verbose?
04:38:50 <FliPPeh> Especially buildung the result in getFullStatResponse
04:40:31 <FliPPeh> Since I'm getting the results as arrays, I thought about writing some kind of function wrapper that treats "f [a, b, c]" as "(((f a) b) c)"
04:41:03 <FliPPeh> But found no way that would end up better than my current approach
04:46:29 <ClaudiusMaximus> > let def = Last ((Just "", Just 0)) in mconcat . map Last . (def:) $ [(Just "hello", Nothing), (Nothing, Just 1338)] -- not sure if this will work, or turn out to be less verbose in the end
04:46:30 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
04:46:30 <lambdabot>         against inferred ...
04:47:23 <FliPPeh> Well, I kind of abused the lookup functions and turned them to lookup' and lookup''
04:47:31 <FliPPeh> No maybe in there anymore, either "" or 0 on error
04:47:47 <ClaudiusMaximus> > let def = (Just "", Just 0) in mconcat . map (Last . Just) . (def:) $ [(Just "hello", Nothing), (Nothing, Just 1338)]
04:47:48 <lambdabot>   Last {getLast = Just (Nothing,Just 1338)}
04:48:50 <FliPPeh> Hmm, what is this "Last" type?
04:48:57 <FliPPeh> @hoogle Last
04:48:58 <lambdabot> Prelude last :: [a] -> a
04:48:58 <lambdabot> Data.List last :: [a] -> a
04:48:58 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
04:50:42 <ClaudiusMaximus> > mconcat [Last Nothing, Last (Just 1), Last Nothing, Last (Just 2), Last Nothing]
04:50:43 <lambdabot>   Last {getLast = Just 2}
04:51:11 <FliPPeh> Ahh, okay
04:51:40 <FliPPeh> But I don't see how this could help me here
04:52:04 <FliPPeh> I'm dealing with a key-value list of type [(String, String)] and another array [String]
04:52:19 <FliPPeh> Got to put those into a FullStat record in some kind of non verbose way
04:52:25 <ClaudiusMaximus> anyway, possibly a wrong route to take (was thinking having a default state and an mappend that adds modifications to the state), and just lump the horrible verbosity
04:52:56 <ClaudiusMaximus> let lookup'' k = read . (maybe "0" id) . lookup k
04:52:58 <ClaudiusMaximus> oops
04:53:20 <ClaudiusMaximus> > let lookup'' k = read . (maybe "0" id) . lookup k in lookup'' "foo" (M.singleton "foo" "bar")
04:53:21 <lambdabot>   Couldn't match expected type `[([GHC.Types.Char],
04:53:21 <lambdabot>                          ...
04:53:28 <ClaudiusMaximus> > let lookup'' k = read . (maybe "0" id) . M.lookup k in lookup'' "foo" (M.singleton "foo" "bar")
04:53:30 <lambdabot>   *Exception: Prelude.read: no parse
04:53:58 <ClaudiusMaximus> you might want to use a safer reader there
04:54:05 <FliPPeh> True
04:54:22 <FliPPeh> I'm kind of depending on the mercy of the server developer here :)
04:55:19 * hackagebot time-http 0.4 - Parse and format HTTP/1.1 Date and Time strings  http://hackage.haskell.org/package/time-http-0.4 (MasatakeDaimon)
04:55:28 <ClaudiusMaximus> well, if you use "case reads x of [(y, "")] -> y" you'll get an error that tells you file and line number :)
04:56:21 <ClaudiusMaximus> anyway, personally i'd not worry too much about the verbosity, i've written worse...
04:56:42 <FliPPeh> But well, the only option to shorten that "FullStat { a = lookup' "a" k, b = ... }" mess would be to write a function that can stuff arrays into functions, eh?
04:58:20 <sajkr> @pl \a b -> foldl (id b) [] a
04:58:20 <lambdabot> flip (flip foldl [])
04:58:47 <WJW> hello everybody
04:59:28 <sajkr> WJW: hello doctor nick!
04:59:47 <WJW> I am confused by the accept function in Network
05:00:04 <WJW> it hangs, even though it shouldn't:(
05:00:23 <FliPPeh> Well, it's blocking IO
05:00:57 <sajkr> @pl \a b -> foldl (foo b) [] a
05:00:57 <lambdabot> flip (flip foldl [] . foo)
05:01:21 <WJW> hmm yes, but thats not what I meant
05:01:35 <WJW> if I do:
05:01:37 <WJW>  print "start accepting"
05:01:38 <WJW>     (conn, _, _) <- accept sock
05:01:38 <WJW>     print "accepted"
05:01:46 <WJW> in a do block
05:01:57 <WJW> it outputs "start accepting"
05:02:11 <sajkr> @pl \a b -> foldl (innerF b) [] a
05:02:11 <lambdabot> flip (flip foldl [] . innerF)
05:02:21 <WJW> but when I try to connect to it with netcat, nothing happens
05:02:49 <FliPPeh> Did you setup listen?
05:03:26 <WJW> i'm trying to make something based on http://haskell.org/haskellwiki/Simple_Servers
05:03:47 <WJW> i used listenON
05:03:48 <WJW> main = withSocketsDo $ do
05:03:48 <WJW>     sock <- listenOn $ PortNumber 5002
05:04:40 <FliPPeh> Works for me :/
05:04:45 <WJW> :S
05:05:00 <FliPPeh> Network> s <- listenOn $ PortNumber 9999
05:05:07 <FliPPeh> Network> (conn, _, _) <- accept s
05:05:10 <FliPPeh> Telnetted to it
05:05:11 <FliPPeh> done
05:05:27 <WJW> hmmm
05:06:51 <FliPPeh> Maybe it's netcats fault?
05:07:17 <WJW> perhaps
05:07:26 <WJW> i just tried with puTTY as well
05:07:37 <WJW> which says "connection refused"
05:07:39 <saati> WJW: are you connecting to the correct port? is the port unfiltered?
05:07:50 <WJW> so its probably not my hs file
05:08:21 <WJW> correct port: yes, unfiltered: i think so
05:09:14 <WJW> win firewall says both nc and ghc are allowed to speak to the network
05:10:02 <saati> and your compiled program?
05:10:32 <WJW> i only used it from ghci or with runghc so far
05:10:52 <FliPPeh> !hpaste
05:11:21 <hpaste> Flippeh pasted “Testcase” at http://hpaste.org/55338
05:11:26 <FliPPeh> This worked for me
05:11:45 <FliPPeh> Via ghci and runhaskell, so it's not your code
05:13:56 <psionski> try adding ghci to your firewall as an exception
05:14:04 <WJW> ill try that
05:14:12 <psionski> the script should run in it's process, I guess
05:14:17 <psionski> its*
05:14:23 <WJW> thanks for all the help
05:17:43 <saati> this is strange freeglut (Main.hs):  ERROR:  Internal error <FBConfig with necessary capabilities not found> in function fgOpenWindow << this happens if i try to run my little glut program with runghc/ghci
05:17:57 <saati> if i compile it, it works correctly
05:18:26 <hpc> saati: i didn't get that exact error, but i got something close last time i did opengl in ghci
05:18:31 <hpc> saati: i think it's a known issue
05:18:42 <FliPPeh> I got something similar when doing GTK via GHCI
05:18:50 <FliPPeh> Some things just don't like interactive mode :)
05:18:55 <hpc> ive never had trouble doing gtk from ghci
05:19:13 <FliPPeh> Well, it kind of locked up my GHCI so I had to kill -9 it
05:19:39 <FliPPeh> Maybe that was just an old version of it tho, didn't do GUI in a long time now
05:20:57 <hpc> yeah, in any event, this sort of crap seems to be par for the course with giant C libs
05:23:19 <vrook> > take 10 $ foldr (\x xs -> (replicate x x) ++ xs) undefined [1..]
05:23:20 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
05:24:04 <vrook> There's still one thing that bothers me about foldr -- the undefined there means that there's a mathematical inconsistency about this.
05:24:20 <vrook> ... if we constrain ourselves to Haskell operations.
05:25:33 <mjrosenb1> vrook: foldr1?
05:25:42 <vrook> There is no formal rule to build the list from left to right, which is what happens in practice.
05:25:51 <vrook> er, inside the implementation that is.
05:26:13 <hpc> vrook: sure there is; that formal rule is non-strict semantics
05:27:03 <vrook> My point is almost a philosophical one, but it's important to me because I think it prevented me from understanding it.
05:27:32 <vrook> There's no end to the list, so it's not clear what append even means.
05:27:56 <vrook> If we call list operations "natural", then what's happening is supernatural.
05:28:16 <vrook> Because we start from an undefined value and get a list out of it.
05:28:58 <vrook> So in the hard rules of the language, it's impossible. But in the implementation it's not. (natural/supernatural)
05:32:08 <mokus> vrook: it's not starting from undefined - it's never even touching undefined
05:32:23 <mokus> the undefined is what it _would_ give the accumulator if it ever reached the end of the list
05:32:30 <mokus> which it won't
05:33:08 <vrook> mokus: of course, of course, that's not my point. I don't think I can explain it any more than that it violates the mathematical rules of list building.
05:33:12 <mokus> it's building the list from the outside in, which is the weird part - not anything about undefined ;)
05:33:38 <vrook> mokus: there are no haskell rules to build lists from front to back.
05:33:48 <mokus> sure there are - lazy evaluation
05:33:52 <vrook> it needs supernatural intervention
05:34:19 <mokus> or as hpc said above, non-strict semantics
05:34:44 <mokus> the 'definedness order' is a central concept there
05:35:10 <mokus> and evaluation is a process of finding least-fixed-points according to that order
05:35:36 <mokus> the gist of that order is that something is 'more defined' than something else, but agrees on every part that is defined
05:35:49 <vrook> well you're still taking me too literally. The point is that there's not a mathematical foundation for it.
05:35:59 <mokus> that _is_ a mathematical foundation
05:36:12 <mokus> just because it's not the usual one doesn't mean it isn't one
05:36:16 * mike-burns watches
05:37:16 <vrook> mokus: you can't build a list from undefined. I understand that undefined isn't touched. I understand there are rules for evaluation. But those are not the simple semantics of list building. The formal induction is gone.
05:37:43 <vrook> I don't think I can explain it any more than that.
05:37:44 <mokus> that's because the induction you're talking about is from a different semantics - a strict one
05:37:45 <mike-burns> Is this a creationism argument?
05:38:33 <WJW> in the beginning there was nothing
05:38:41 <WJW> then mokus made a list
05:38:43 <mokus> then there was the lambda!
05:38:46 <mike-burns> No no, not Nothing!
05:38:54 <vrook> mokus: believe me, I understand what you're talking about. As I said it was a mathematical issue that bothered me.
05:38:58 <mike-burns> It starts with then empty list, not undefined or Nothing!
05:39:07 <WJW> _|_ ?
05:39:32 <mike-burns> Oh I see which side of this debate you're on, WJW .
05:39:49 <plat0> vrook: I think perhaps you want to look into corecursion.
05:39:50 <mokus> vrook: I'm not really trying to make you understand anything technical, just taking issue with the apparent claim that the mathematics that does apply isn't "true" mathematics in some sense
05:40:36 <WJW> I really dont know enough about haskell yet to be on any side
05:41:51 <vrook> mokus: the mathematics is not part of the Haskell language proper, but in how to implement the language.
05:42:07 <vrook> that is, from the programmer's point of view
05:42:18 <vrook> ugh, this is going nowhere, nevermind
05:43:05 <plat0> vrook: the answer to your troubles lies in corecursion and coinduction.
05:43:07 <mokus> if you're interested in the actual machinery that GHC uses to implement lazy evaluation, that's pretty interesting in its own right
05:43:36 <papa_smurf> in the equation: (***) f g ~(x,y) = (f x, g y) -- what does the ~ mean ?
05:43:53 <saati> irrefutable pattern for the touple
05:44:20 <ketil> Anybody with a JFP subscription who wants to help me get a copy of my own article? :-)  I'm stuck at home, and can't work out how to redirect through the university network.
05:45:21 <quicksilver> ketil: tried google scholar?
05:45:58 <papa_smurf> saati: thanks google answered the rest
05:46:06 <roconnor> ketil: maybe you shouldn't give away copyright on your own articles ... just sayin'
05:46:10 <ketil> quicksilver, I can give it a whirl.
05:46:26 <ketil> roconnor, sorry about that.  I try to make everything OA these days.
05:46:56 <roconnor> ketil: all right;  What article do you want?
05:47:15 <ketil> http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=358586
05:48:06 <ketil> Out of 15 I need to include (job application), only two were paywalled, I think.  This is the only one where I'm first author.
05:49:10 <ketil> No, three, a PADL submission too!  The functional programming community isn't too great on open access, unfortunately.
05:49:41 <saati> how much does a jfp subscription cost?
05:50:15 <ketil> http://www.springerlink.com/content/4nrh6203114627q0/
05:50:48 <ketil> saati, no idea, it's usually institutions that pay.  Usually it's quite expensive.
05:52:16 <ukl_> ketil: got disconnected while going under VPN; has someone sent you the springer one yet? (I could)
05:52:38 * roconnor wondres if DCC transfers ever work
05:52:51 <ukl_> that's so 1990.
05:52:57 <mux> about as much as FTP works
05:53:16 <ketil> ukl_: please!  or email: ketil@malde.org
05:53:38 <saati> roconnor: if you open the ports on both sides they do
05:53:47 <roconnor> oh
05:53:49 <ketil> roconnor, I got a popup here, but there was a variety of buttons, and ACCEPT didn't seem to do what it looked like it would.
05:54:41 <ukl_> ketil: sent
06:00:25 <lunaris> Is it correct to assume that Haskell has no equivalent of C++11's decltype?
06:00:41 <lunaris> (Since Language.Haskell.TH.reify is only good for named things)
06:02:38 <osaunders> lunaris: I don’t know much about this but I’m pretty sure you can get the type of things dynamically with TH
06:03:04 <sipa> lunaris: asTypeOf ?
06:03:15 <osaunders> sipa: Not the same
06:03:17 <lunaris> sipa: Not quite.
06:03:18 <osaunders> at all
06:03:30 <lunaris> I want to obtain the type of an expression at compile time.
06:03:40 <lunaris> sipa: Something like f [typeOf| \x -> x |]
06:03:49 <lunaris> sipa: Where f is passed (ForallT ...) or the like.
06:03:59 <sipa> "the type" of an expression is not something that exists at the value level
06:04:01 <lunaris> osaunders: I'm not sure I can, without a name at least.
06:04:06 <lunaris> sipa: In a metaprogram, it does.
06:04:12 <sipa> yes, sure
06:04:21 <lunaris> I'm effectively asking the compiler for it.
06:04:26 <lunaris> Just as decltype does in C++11.
06:04:42 <sipa> but decltype, is it a value that is returned?
06:04:58 <sipa> can you, e.g. print it?
06:05:08 <lunaris> sipa: No, you can use it where you may use any other type.
06:05:22 <sipa> so, you don't need it to be at the value level
06:05:30 <lunaris> Not in that case.
06:05:34 <lunaris> My analogy is false in that sense.
06:05:44 <lunaris> I want the Type field of the VarI constructor of Info, without having a name.
06:05:45 <lunaris> Name*
06:06:03 <sipa> http://haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Typeable.html ?
06:06:14 <lunaris> sipa: Afraid not.
06:06:23 <lunaris> sipa: I'm pretty sure it's not possible.
06:06:26 <Saizan> sipa: i think you're missing the TemplateHaskell context of the discussion
06:06:49 <Saizan> though a TypeRep could probably be converted to a Type
06:06:50 <lunaris> sipa: (This computation is happening at compile time)
06:06:52 <sipa> i'm mainly missing the usecase :)
06:07:00 <lunaris> sipa: I want to be able to walk a context.
06:07:30 <alistra> @pl \y x -> flip x y
06:07:30 <lambdabot> flip flip
06:07:35 <alistra> @pl \y x -> off x y
06:07:35 <lambdabot> flip off
06:09:25 <quicksilver> I am not good at TH but surely that must be possible
06:09:27 <lunaris> :)
06:09:32 <lunaris> [Challenge accepted]
06:10:03 <lunaris> http://haskell.org/ghc/dist/current/docs/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH.html
06:11:07 <ketil> roconnor: DCC not only doesn't work, it invoked Nautilus and the whole Gnome menagerie.  And if I kill it, another just pops up. Sigh.  apt-get remove, here  I come.
06:12:19 <ornicar> hey dudes, I want to by a book to learn about functional programming, any recomendation?
06:12:31 <ornicar> I've read "Programming In Scala" and LYAHFGG, so I'm looking for something maybe less language-centric
06:12:41 <kmc> SICP is free online
06:12:57 <kmc> Scala and Haskell are pretty unusual as functional languages go
06:13:10 <ornicar> I'm really bad at theory, I feel like I should learn about category theory and maybe lambda calculus, but I don't know which book to buy next
06:13:21 <roconnor> ketil: I guess you get what you pay for
06:13:36 <roconnor> @where TTFP
06:13:37 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
06:13:40 <roconnor> ornicar: ^^
06:13:54 <ornicar> thanks guys
06:13:57 <ketil> Oh, double entendre alert!
06:13:58 <ketil> :-)
06:14:04 <kmc> ornicar, if you wanna know functional programming then lambda calculus is way more important than category theory
06:14:18 <ornicar> I take good note of it
06:14:47 <ketil> No worries, but removing nautilus wreaked havoc on xchat, so I needed to restart it.  Gnome is a maze of twisted little programs, all different...
06:15:08 <kmc> gnome is a maze of twisted little daemons that spawn and run forever when all i wanna do is view a pdf
06:15:20 <kmc> yesterday i chmod -x'd most of them
06:15:23 <kmc> we'll see how that goes
06:15:39 <psionski> rm -rf /
06:15:52 <ketil> kmc, removing nautilus (surprisingly) only dragged gnome-session with it.  So I'm good.
06:18:17 <roconnor> kmc: did you see that video about a coq implementation of a PDF parser?
06:18:23 <kmc> no
06:18:45 <roconnor> kmc: there are these XREF(?) tables that need to be chased
06:18:58 <roconnor> kmc: you can manually link these tables in a cycle
06:19:22 <roconnor> and the gnome(?) file viewer will try to preview the pdf and spend 100% CPU running around this cycle.
06:19:35 <roconnor> The coq PDF parser doesn't suffer from this problem.
06:19:56 <donri> kmc: i think that's sorta like complaining that haskell adds a GC to your compiled executable; there's good reasons for it and if you want something else there's C / xpdf etc
06:20:13 <donri> http://mjg59.dreamwidth.org/2414.html half-relevant
06:21:45 <kmc> what are the good reasons why evince needs to launch /usr/lib/gvfs/gvfsd-metadata and /usr/lib/dconf/dconf-service
06:21:52 <kmc> it works fine with these binaries disabled
06:22:06 <kmc> except that it spews errors to the terminal, but so do most gnome apps
06:22:28 <ukl_> dconf is GNOME's registry
06:22:32 <ukl_> well, sort of.
06:22:35 <kmc> I do agree with this statement though: 'when someone says "Lightweight" what they mean is "I don't understand the problems that the alternative solves"'
06:22:56 <kmc> remember "bloated" software is software which does anything i personally don't need
06:22:57 <Saizan> and what is the good reason for needing dbus to remember the last viewed page of pdf's when it can remember the most recent opened files just fine?
06:23:00 <donri> gvfs is the virtual filesystem used for reading files from arbitrary sources
06:23:17 <kmc> so i'm not going to claim that gnome is objectively bloated
06:23:44 <furgos> (quit
06:23:47 <EvanR-work> gnome is relatively extremely bloated ;)
06:23:47 <kmc> but for me personally, i would like to run evince (because it's a better pdf viewer than xpdf) without running gconf and gvfs and dbus and polkit and console-kit-daemon and udisks and whatever the hell else
06:24:08 <donri> maybe it is better in part because of those dependencies :P
06:24:13 <ukl_> Regarding Haskellformaths, how would I have to proceed to define a finite-dimensional vector space?
06:24:18 <kmc> donri, no, because as i said, it works fine if i have disabled them
06:24:42 <donri> gnome is designed as an integrated system, it would require extra developer effort to make the components more independent
06:25:16 <EvanR-work> the question is whether more than a couple people who probably include the friends and family of the gnome developers actually need/use all that extra bureaucracy, its great to say 'well that could be used for something by someone' but
06:25:19 <donri> kmc: FSVO fine; likely it'll revert back to default settings and not allow you to change them etc
06:25:24 <kmc> that's cool
06:25:30 <ukl_> I'm a little confused with the options, i.e., use Vect Q EBasis and pretend it's finite by just using a few;  define a new Basis a la Quaternions, i.e. One|Two|Three; or do something using IntegerAsType.
06:25:50 <ketil> roconnor, ukl_, everybody else: thanks for you help.  I've put everything on http://malde.org:~ketil/CV/ ; if anybody wants to take a look at it and give me some feedback on it, I'd be grateful.  Gotta make dinner for children now, and soap for presents after that, so /msg me (or email) any feedback.  Thanks a lot, great community!
06:26:00 <ukl_> I haven't fully understood the relations between class/data/instance and how haskellformath uses them, though, which might be the reason I'm confused now.
06:26:45 <osaunders> I don’t think TH is really a good idea
06:26:48 <Saizan> i'd lean to define your own basis type, but i've never used it much
06:26:51 <ukl_> ketil: you're welcome ;)
06:26:55 <ketil> (Sorry: http://malde.org/~ketil/CV)
06:27:25 <donri> kmc: i think the pdf rendering engine is a mostly decoupled lib though, (poppler?), perhaps you could make a more stand-alone reader based on it, like all these stripped down webkit wrappers
06:27:31 <osaunders> I mean, it’s cool and all but I think there are better ways 99.9% of the time
06:27:55 <ukl_> kmc: mupdf is a nice one (donri is right)
06:28:02 <roconnor> ketil: do you have permission from the *owners* of those papers to post them?
06:28:18 <kmc> okay, i'll check out mupdf, thanks
06:28:31 <kmc> what about virt-manager?  is there a non-gnomey frontend to libvirt?
06:28:32 <ukl_> and epdfview should also fit this niche, while providing more UI than mupdf
06:28:50 <donri> osaunders: was that continuing some earlier discussion?
06:29:36 <osaunders> donri: A bit, some guy was trying to work out how to get the type of things using TH
06:29:39 <ketil> roconnor: no.
06:29:56 <ketil> roconnor, I'll close that bit, thanks for pointing it out.
06:30:04 <roconnor> Really, 'cause usually authors have permission to post their papers on their own webpage.
06:30:05 <donri> osaunders: use of TH might often be indicative of a need for some addition to the language. until that need is filled, TH is useful in the mean time.
06:31:09 <osaunders> donri: Nah man. I think you can define little sublanguages with normal Haskell data types for that
06:31:21 <osaunders> That’s what I do
06:31:40 <osaunders> I find that a very powerful abstraction and I don’t have to worry about anything as complicated as TH
06:31:49 <ketil> roconnor, well, I'm too lazy to check whatever detailed regime journals force upon my own work, and it's not very relevant to the general public anyway, so I just closed the papers/ subdir.
06:31:59 <roconnor> okay
06:34:18 <donri> osaunders: a common use of TH is to derive typeclass instances for arbitrary algebraic types; not sure that can be done without TH, though some of the other extensions might help (generics, gadts and all that, i don't really know those myself)
06:35:12 <byorgey> donri: that's one of the things generics is for
06:35:25 <donri> not sure i agree TH is all that complicated, though
06:35:29 <byorgey> GADTs don't really have anything to do with deriving type class instances
06:35:32 <osaunders> Well, I don’t really like type classes all that much either except the basic ones
06:35:51 <kmc> TH should be a last resort, but it lets you do things which basically aren't possible otherwise
06:36:47 <osaunders> kmc: What’s impossible without TH?
06:36:50 <kmc> nobody's saying you have to like it, though ;P
06:37:28 <donri> nothing is "impossible" in a turing complete language, but it might require a lot more repetitive boilerplate
06:37:44 <donri> might end up more complicated and confusing than a generalized TH solution
06:37:45 <kmc> that's not true either, because "turing complete" says nothing about the interface to the outside world
06:37:57 <osaunders> Then you can define a sublanguage within Haskell instead of generating Haskell with TH
06:37:58 <andsens> Argh: How do I make this " diff size = 2^(ceiling $ sqrt size)-size-2 " to be Int -> Int ???
06:38:26 <donri> osaunders: and end up having to reinvent the whole type system etc?
06:38:32 <hpc> :t (^)
06:38:33 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
06:38:45 <hpc> andsens: add
06:38:48 <hpc> andsens: add
06:38:49 <hpc> argh
06:38:49 <kmc> i'm going to implement a sublanguage in Haskell and then add features until it's as powerful as Haskell
06:38:57 <kmc> and i will call the compiler for my language GHC
06:38:57 <hpc> andsens: add "diff :: Int -> Int"
06:39:01 <osaunders> donri: Will you? I don’t think most people are dealing with anything nearly that complicated 99% of the time.
06:39:15 <osaunders> If you are then TH is absolutely the best thing for be using.
06:39:18 <mux> hpc: not enough, there's a sqrt there
06:39:19 <roconnor> @wn exceeds
06:39:19 <andsens> hpc: Could not deduce (RealFrac Int) arising from a use of `ceiling'
06:39:20 <lambdabot> No match for "exceeds".
06:39:23 <kmc> osaunders, how would you replace the TH deriving in data-lens or fclabels?
06:39:26 <mux> :t (**)
06:39:27 <lambdabot> forall a. (Floating a) => a -> a -> a
06:39:28 <hpc> :t let diff size = 2^(ceiling $ sqrt size)-size-2 in size
06:39:29 <lambdabot> Not in scope: `size'
06:39:35 <hpc> :t let diff size = 2^(ceiling $ sqrt size)-size-2 in diff
06:39:36 <lambdabot> forall a. (RealFrac a, Floating a) => a -> a
06:39:39 <osaunders> kmc: What do they do?
06:39:40 <hpc> oh
06:39:45 <kmc> why don't you learn about them
06:39:47 <mux> but there's a ceiling call actually, my bad
06:40:00 <kmc> you could at least learn about some of the major uses of template haskell before you declare that it's useless
06:40:02 <hpc> @hoogle Int -> Floating
06:40:04 <hpc> er
06:40:05 <lambdabot> Warning: Unknown type Floating
06:40:05 <lambdabot> Prelude (!!) :: [a] -> Int -> a
06:40:05 <lambdabot> Data.List (!!) :: [a] -> Int -> a
06:40:10 <osaunders> Nah. I said to myself I wouldn’t get into TH until I really needed it. Hasn’t happened yet.
06:40:13 <hpc> @hoogle Floating a => Int -> a
06:40:13 <lambdabot> Prelude (!!) :: [a] -> Int -> a
06:40:13 <lambdabot> Data.List (!!) :: [a] -> Int -> a
06:40:13 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
06:40:14 <kmc> ok
06:40:38 <andsens> rather, the other way around, right hpc? I want Floating->Int
06:41:03 <kmc> that's like saying C is useless because you've never needed to write an OS kernel
06:41:05 <donri> osaunders: might be rarely needed for application code, but can be very useful for libraries
06:41:09 <osaunders> So at the moment I don’t really _get_ TH and I’m just kind of expressing that right now. Could be that I’m just inexperienced
06:41:15 <kmc> yep
06:42:06 <WJW> huzzah, finally got my server working
06:42:09 <hpc> :t let diff size = round res where s = fromIntegral size; res = 2^(ceiling $ sqrt s) - s - 2 in diff
06:42:09 <lambdabot> forall a b. (Integral b, Integral a) => a -> b
06:42:13 * WJW parties
06:42:26 <hpc> :t let diff size = round res where s = fromIntegral size; res = 2^(ceiling $ sqrt s) - s - 2 in (diff :: Int -> Int) -- andsens
06:42:27 <lambdabot> Int -> Int
06:42:32 <hpc> use that ^
06:42:39 <andsens> woooot! Thanks hpc
06:42:49 <andsens> haha, figured it must be something with fromIntegral
06:42:53 <osaunders> kmc: Also I think I would find TH very confusing and difficult so what makes sense for me may not for other people
06:42:58 <hpc> :t fromIntegral -- turns an Integral type into a plain old Num
06:42:59 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:43:13 <hpc> :t round -- replace with a different rounding scheme like floor or ceiling as needed
06:43:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:43:15 <kmc> yes
06:43:39 <kmc> defining TH macros is very difficult
06:43:54 <kmc> partially due to avoidable flaws in GHC's implementation of TH
06:44:10 <kmc> partially due to the intrinsic complexity of reasoning about multi-stage code
06:44:46 <kmc> this does not mean TH is useless or "a bad idea" as you initially said
06:44:50 <kmc> there is a cost-benefit tradeoff
06:45:04 <kmc> it is a difficult but manageable way to do things which are nearly impossible otherwise
06:45:51 <kmc> in many cases, *implementing* the TH macro is challenging, but using it is very simple
06:46:20 <kmc> as with auto-deriving lenses in the libraries i mentioned
06:46:31 <kmc> the authors of those libraries had to write some tricky code
06:46:43 <kmc> but the users just say "gimme lenses for this type" and don't worry about it
06:46:50 <Peaker> Lenses are much like pickler combinators, aren't they?
06:47:36 <kmc> and obviously you hope that your library has more users than authors
06:51:23 <donri> TH gives you the freedom of runtime-dynamic languages but with compile-time guarantees
06:51:41 <kmc> sort of
06:52:44 <kmc> i think it's not very much like typical "dynamic languages"
06:53:49 <kmc> it's pretty easy to say what TH is
06:53:52 <kmc> it's a macro system
06:53:55 <Peaker> donri: it gives you the metaprogramming that's so easy in dynamic languages, with more guarantees, but is also harder to use.  Other properties of untyped languages (no type system learning curve, ease of implementing eval, etc) are independent of that
06:54:32 <kmc> it lets you run code at compile time, and that code can produce other code which becomes part of the compiled program
06:55:14 <kmc> TH does not let you define new types or functions at runtime
06:55:20 <osaunders> I wasn’t communicating very well when I said TH was a bad idea. I meant that choosing to use it is a bad idea most of the time. TH itself is cool.
06:55:43 <kmc> that's the domain of GHC API, hint, etc.
06:55:49 <osaunders> And that opinion only makes sense when you consider the alternative of defining mini-languages within Haskell as an alternative
06:55:59 <kmc> however, it would be cool if these things were tightly integrated
06:56:11 <kmc> then you could actually get rid of the staging boundary
06:56:31 <kmc> osaunders, I still don't see that as much of an alternative
06:56:43 <kmc> obviously you're correct that most Haskell code should not be using TH
06:57:00 <kmc> (other than perhaps invoking someone else's macros as simple black boxes)
06:57:19 <donri> osaunders: perhaps you're thinking mostly of yesod-style quasi-quoters
06:57:30 <donri> if so I agree and prefer e.g. blaze-html over hamlet
06:57:41 <kmc> you can pick a gratuitous, unreasonable use of TH and replace it with a "mini-language"
06:57:46 <kmc> that's not compelling
06:57:55 <donri> but there are completely different situations where TH helps, e.g. deriving typeclasses
06:58:12 <kmc> do you have an example where TH seems like a legitimately good idea, and a "mini-language" alternative to show us?
06:58:19 <osaunders> No
06:58:27 <donri> kmc: i think hamlet vs blaze-html is one
06:58:31 <osaunders> This is all hyperbole really
06:58:38 <kmc> yeah
06:58:51 <kmc> it seems odd that you have such an opinion about TH when as you said yourself, you haven't used it and don't understand it
06:59:06 <donri> most "uncontroversial" use of TH has no "mini-language" counterpart
06:59:17 <osaunders> kmc: Yeah
06:59:54 <osaunders> But I decided to stay clear of it (knowing that it was quite complex and confusing) until I really found a need for it and then I discovered how great mini-languages are
07:00:10 <kmc> yeah
07:00:12 <kmc> that's all good
07:00:16 <osaunders> and that, to me, seems to have mitigated the need for me to ever look into TH
07:00:26 <osaunders> But I could be proven wrong
07:00:30 <kmc> i don't see why you think mini-languages are an alternative to TH
07:00:36 <donri> as i said before, TH is rarely needed at the application level
07:00:43 <kmc> based on that story
07:01:13 <osaunders> OK, don’t worry about it. If you’re right I will probably have a crushing sense of enlightenment at some point in the future
07:01:23 <kmc> i don't think you even understand what i'm saying
07:01:30 <kmc> but whatever
07:01:40 <osaunders> Yeah I probably don’t
07:01:59 <kmc> also -XQuasiQuotes does allow many examples of using TH for superficial syntactic things
07:02:09 <kmc> and you can reasonably contrast these with EDSLs in many cases
07:02:16 <donri> another useful use of TH: generating test suites from test functions matching a naming convention and adding file/lineno information to failing tests
07:02:18 <kmc> however, i think TemplateHaskell without QuasiQuotes provides many fewer examples
07:02:59 <kmc> what you've been saying makes a lot more sense if it's an argument about QuasiQuotes and not TemplateHaskell
07:03:10 <donri> yea
07:03:35 <donri> although quasiquotes can be useful too sometimes, i think, for example string interpolation
07:04:01 <donri> more readable than concat [parts,mixed,with,"literals"]
07:05:13 <Peaker> one useful use of TH is abstracting over things that are not first-class in Haskell (e.g: Data type declarations), a.k.a metaprogramming
07:05:15 <Saizan> we could almost implement pattern synonyms with QuasiQuotes, if there was a nice way to collect declarations of them
07:05:47 <Peaker> But I think a bit of TH and typeclasses (such as the Data class) can probably cover that use
07:06:11 <Peaker> (so that any future needs can be covered by this one TH implementation)
07:06:19 <kmc> all of TH is metaprogramming
07:07:10 <Peaker> Yeah, that was silly of me :)  I'm referring to that particular use of it
07:07:13 <kmc> ok
07:07:26 <shapr> osaunders: writing hamlet inline is really nifty
07:10:21 * hackagebot snaplet-tasks 0.1 - Snaplet for Snap Framework enabling developers to administrative tasks akin to Rake tasks from Ruby On Rails framework.  http://hackage.haskell.org/package/snaplet-tasks-0.1 (KamilCiemniewski)
07:20:21 * hackagebot snaplet-tasks 0.1.1 - Snaplet for Snap Framework enabling developers to administrative tasks akin to Rake tasks from Ruby On Rails framework.  http://hackage.haskell.org/package/snaplet-tasks-0.1.1 (KamilCiemniewski)
07:38:48 <dgpratt> what is the function of "doc mode" in emacs haskell?
07:42:29 <_oz> so, when is ghc 7.4 is to be released?
07:42:34 <_oz> I want my christmas present :)
07:47:00 <kmc> build it from git :)
07:47:12 <kmc> and christmas comes early
07:47:24 <Ke> is there something new in 7.4?
07:48:10 <Ke> haskell-2010 by default?
07:48:25 <djahandarie> Ha
07:48:33 <kmc> there are tons of new things in ghc 7.4
07:48:49 <kmc> http://hackage.haskell.org/trac/ghc/wiki/Status/Oct11
07:49:40 <kmc> the biggest set of new type system extensions in a long time
07:50:17 <_oz> kmc: yes, I could do that.
07:50:21 <kmc> also the ability to declare data types etc. at the ghci prompt
07:50:38 <_oz> is there a known release date though?
07:51:16 <mjrosenb1> kmc: oh man, datatype declarations in the repl?
07:51:25 <mjrosenb1> kmc: it only took 20 years to get that?
07:51:28 <kmc> :)
07:51:36 <parcs`> preflex: seen jaspervdj
07:51:36 <preflex>  jaspervdj was last seen on #haskell 10 days, 23 hours, 33 minutes and 21 seconds ago, saying: kstt: I'm not sure
07:51:37 <kmc> i think hbi had them
07:51:56 <mjrosenb1> hbi?
07:52:03 <kmc> the repl for hbc
07:52:15 <fryguybob> roconnor: I'm building some things with the latest GHC and with the Num Show/Eq constraint changes there are a couple of small changes needed to colour.  Do you have a repo for me to send a patch?
07:52:16 <kmc> which is an old haskell compiler
07:52:20 <kmc> in the days before ghc
07:53:34 <mjrosenb1> speaking of old days... is there any chance that hat will ever work again?
07:54:08 <kmc> don't know
07:54:17 <kmc> i'd also really like a declarative debugger like buddha
07:55:47 * mjrosenb1 has yet to be able to grok debugging in ghc :/
07:56:44 <kmc> i've only tried to use ghci debugger a few times
07:56:47 <kmc> and it was never that helpful
07:58:22 <djahandarie> Will it support type class and instance declarations too?
07:58:41 <kmc> think so
08:00:37 <papa_smurf> class Print a where printOut :: a -> IO ()
08:00:37 <papa_smurf> instance Print Int where printOut a = putStrLn "This is an Integer"
08:00:37 <papa_smurf> instance Print Bool where printOut a = putStrLn "This is a Boolean"
08:00:37 <papa_smurf> foo :: Print s => (forall a. Print a => a -> IO ()) -> s -> IO ()
08:00:37 <papa_smurf> foo f val = printOut val
08:00:43 <papa_smurf> When i have a type and a function like this, are there any kind of runtime typechecks etc. involved ?
08:01:25 <kmc> i don't think that does what you want
08:01:33 <kmc> or, hmm
08:01:45 <kmc> 'foo' doesn't even use f
08:02:35 <papa_smurf> oh damn your right!
08:02:36 <kmc> also if you have more than a few lines of code, put them on hpaste.org
08:02:44 <kmc> damn your left
08:09:14 <hpaste> papa_smurf pasted “little code-snipet” at http://hpaste.org/55341
08:10:23 <papa_smurf> the thing is it actually works like described in the comment (thats where my question came from)
08:10:44 <kmc> i don't think 'foo printOut' is more interesting than calling 'printOut' directly
08:11:13 <kmc> as for "runtime typechecks" it depends on the implementation
08:11:30 <kmc> GHC implements type classes by passing around "dictionaries" of their methods
08:12:11 <kmc> data PrintDict a = PrintDict { dict_printOut :: a -> IO () }
08:12:40 <kmc> foo :: PrintDict s -> (forall a. PrintDict a -> a -> IO ()) -> s -> IO ()
08:12:53 <kmc> foo dict f val = f dict val
08:19:35 <papa_smurf> kmc: thanks for answering my question
08:40:04 <DukeDave> So, I'm trying to install cabal-dev on a machine without an Internet connection
08:40:24 <DukeDave> I've grabbed the latest hackage archive tarball
08:40:43 <DukeDave> And I can: $ sudo cabal install --global ./cabal-dev/0.9/cabal-dev-0.9.tar.gz
08:41:05 <DukeDave> But it errors, with: cabal: There is no package named 'cabal-install'.
08:42:37 <DukeDave> So I cabal install cabal-install (..), which succeeds, but cabal-install doesn't show up in ghc-pkg list
08:42:57 <DukeDave> And of course, cabal-dev still fails on its cabal-install dependency :/
08:42:59 <dcoutts> DukeDave: the issue is that you've not given cabal an index of packages, so it cannot find dependencies of things you're asking for
08:43:21 <DukeDave> dcoutts: Aha, I suspected something of the sort
08:43:38 <dcoutts> it doesn't just magically look around in the local dirs to find related packages
08:43:50 <dcoutts> it uses an index, plus the targets you list on the command line
08:44:02 <DukeDave> I kind-of suspected that the hackage archive would contain an index, and that there'd be a friendly tutorial on the 'net
08:44:38 <dcoutts> so if you happened to do: cabal install --global ./cabal-dev/0.9/cabal-dev-0.9.tar.gz ./cabal-install/cabal-install-0.10.2.tar.gz then that'd solve the immediate issue, and it'd then complain about the next missing dep :-)
08:44:46 <DukeDave> Rejoice!
08:44:58 <DukeDave> That's odd.. Now I'm getting "cabal: data is not in tar format"
08:45:05 <dcoutts> DukeDave: no, the index is separate, that archive isn't really there for offline purposes
08:45:28 <DukeDave> With exactly the same invocation as succeeded only a minute ago :|
08:45:49 <DukeDave> dcoutts: What a tease :)
08:46:20 <DukeDave> I'm using a free trial of this cloud service, but a condition of the trial is that the VMs don't have a 'net connection
08:46:33 <DukeDave> I forgot what dep management used to be like :(
08:46:49 <DukeDave> I believe the popular term was "hell".
08:46:53 <sm> indeed!
08:47:22 <sm> what they call hell nowadays, that's just a luke-warm anteroom
08:47:45 <kmc> kids these days don't know how bad we had it!
08:48:01 <geheimdienst> in my day they had proper hells. they don't make them like that anymore.
08:48:27 <dcoutts> DukeDave: so what you'd need is the 00-index.tar.gz
08:49:48 <DukeDave> dcoutts: And, do you know if there's a way to tell cabal to check a local dir, and not hackage?
08:49:58 * DukeDave thinks a wiki page is about to be created..
08:50:38 <dcoutts> DukeDave: yes, remove the remote-repo: line from the .cabal config, and use the local-repo: line instead
08:50:58 <dcoutts> or just comment it out
09:00:42 <hpaste> DukeDave pasted “Local hackage repo” at http://hpaste.org/55342
09:00:53 <DukeDave> dcoutts: Sorry to pester, any idea &
09:01:24 <dcoutts> DukeDave: it needs the uncompressed .tar version
09:01:31 <DukeDave> Ah
09:01:40 <dcoutts> DukeDave: same format as the local cache for remote repos
09:01:46 <dcoutts> format & layout
09:01:51 * DukeDave nods
09:20:06 <periodic> wavewave: FYI I now hate wxHaskell.
09:20:46 <periodic> It's a very thin layer of functions over an OO core, and it's a very leaky abstraction.  Also, the compiling and linking is a bit of a pain.
09:24:55 <mizu_no_oto> I've got a slight problem with timezones and packets.  In particular, I've got a pcap file.  Part of the header contains the posix timestamp or when it was received, and part of the packet itself is the time it was sent out at in HH:MM:SS:Microsecond format.  The problem is that one of these seems to implicitly have the timezone factored into it, but the other doesn't.  How do I correct for...
09:24:57 <mizu_no_oto> ...this?  It's working on a pcap file, so it can be processed in a location with a different timezone than it was recorded in...
09:31:04 <kmc> is that a haskell question?
09:35:11 <mizu_no_oto> Well, I'm using Network.Pcap.Enumerator to work with the pcap file...
09:35:26 <alistra> i saw that question somewhwere before
09:35:29 <alistra> probably here
09:35:46 <mizu_no_oto> Last time I asked, noone responded
09:36:40 <alistra> this doesn't exactly sound as a haskell problem, but a pcap problem :P
09:36:43 <alistra> #pcap? :D
09:36:45 <periodic> Sounds like the issue is the meaning of these two timestamps, right?
09:36:56 <mizu_no_oto> Yeah
09:37:29 <periodic> Does the pcap documentation explain it?  It would make the most sense to have it in UTC...
09:37:43 <kmc> where do the two timestamps come from?
09:37:47 <kmc> is one part of the protocol you're decoding?
09:38:00 <mizu_no_oto> kmc: yes, it is
09:38:13 <mizu_no_oto> that's the one that's corrected for the time-zone
09:38:16 <kmc> how does that protocol handle timestamps / timezones?
09:38:23 <kmc> meaning the timestamp is in local time?
09:38:58 <mizu_no_oto> It literally has the time at the end of the packet, in HHMMSSMicroMicro format
09:39:55 <mizu_no_oto> and that timestamp is in the local time
09:40:20 <mizu_no_oto> and the posix timestamp in the header isn't corrected for local time
09:41:17 <mizu_no_oto> I suppose I could see what the closest multiple of 15 minutes is between the two time stamps and use that to correct it, but that seems kinda ugly and hackish
09:41:23 <kmc> whose local time? what if two machines in different time zones converse using this protocol?
09:41:54 <kmc> this isn't really a haskell problem or a pcap problem
09:41:55 <mizu_no_oto> Presumably the originating server
09:42:10 <kmc> it's a problem with interpreting the bytes of a (perhaps poorly-designed) protocol
09:42:23 <kmc> why do you need both timestamps?
09:43:55 <mizu_no_oto> essentially to mimic a feature of tcp: reordering the packets based off of when they were sent out
09:44:49 <kmc> well, then you only need relative timestamps, right?
09:44:51 <kmc> and you don't have TCP or another lower-level protocol you can base this on?
09:45:31 <mizu_no_oto> nope
09:45:34 <kmc> also, if the timestamp is set according to the timezone of the originating server, can you determine and record that somehow
09:45:59 <donri> osaunders: http://www.yesodweb.com/blog/2011/10/code-generation-conversation might interest you BTW
09:46:51 <donri> osaunders: counter-point http://www.reddit.com/r/haskell/comments/lp4ya/code_that_writes_code_and_conversation_about/c2uub8j
09:47:05 <rien> shachaf: the problem is that it's awkward for me to be converting ADT-ful code into a plain algorithm
09:48:00 <rtharper> is there a good/canonical library for generating and sending emails?
10:00:06 <yshavit> If I load a file in ghci, do I get to see everything in the module defined by the file, even things not exported?
10:00:18 <kmc> yes
10:00:28 <kmc> if it loads it in interpreted mode
10:00:47 <yshavit> kmc: alright, thanks. I was trying to load a data type but not its constructor, and I was confused because I'm seeing the constructor
10:00:48 <kmc> if you have a compiled .o file of that module sitting around, then it might load that instead
10:01:09 <monochrom>  :load *filename.hs
10:01:16 <yshavit> kmc: yeah, this is just :l myfile.hs
10:03:47 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope
10:05:04 <yshavit> thanks!
10:11:18 <tigger_> since haskell is pure, if I have a very large queue and am consistently inserting and popping elements, will a copy of the queue be made each time I perform such an operation, or is the compiler, in general, smart enough to deal with these cases?
10:14:29 <ski> tigger_ : a copy will be made, but typically that copy will share most of the original queue, so that only very little will need to actually ("physically") be copied each time
10:14:46 <kmc> since haskell is pure you *don't* need to copy everything
10:14:58 <kmc> an immutable structure can share nodes with a previous "version" of that structure
10:15:00 <kmc> because nothing changes in place
10:15:06 <kmc> you very rarely need any kind of "deep copy"
10:15:34 <kmc> and this is the default behavior in even a naive Haskell implementation
10:15:39 <kmc> for example if i have a binary tree and i say
10:15:51 <ski> tigger_ : btw, the same applies to many other data structures than queues
10:15:52 <ziman> and usually, the complexity of push/pop is amortized O(1) so there can't be too much copying going on
10:16:04 <kmc> insert v (Node x a b)   | v < x   =  Node x (insert v a) b
10:16:12 <kmc> note that 'b' appears intact on the right hand side
10:16:19 <mjrosenb1> kmc: functorial inheritence!
10:16:20 <kmc> so that half of the tree will not be copied, you just get a pointer into the old tree
10:16:23 <mizu_no_oto> Is there a reasonable way to round a diffTime to the nearest minute?  DiffTime is only Fractional, so I can't use mod or floor...
10:16:45 <ski> (when i said "a copy will be made", i meant that in a conceptual sense, as in : updates to the "copy" will not affect the original)
10:17:48 <tigger_> interesting, how can the compiler give these sorts of guarantees? in your example kmc, the node may still be in scope of the calling function, so a copy may be dangerous?
10:17:58 <kmc> why would it be dangerous?
10:18:06 <kmc> nothing is changing in place
10:18:12 <ski> mjrosenb1 : we'd get coinheritence if we extended a sum type with a new variant, and added a new case to a (possibly recursive) function which matched on that type
10:18:20 <tigger_> kmc: sorry nvm
10:18:40 <kmc> if you have a language with mutation everywhere, it's very hard to do this kind of efficient sharing on data structures
10:18:43 <ziman> tigger_, try to sketch a specific situation where that would be dangerous
10:18:54 <kmc> but in Haskell it just works
10:18:59 <tigger_> ziman: yeah I'll need to think about it
10:19:39 <kmc> now, you do have the problem of managing the storage used by all these shared nodes, which end up with pointers to them from all kinds of places
10:19:42 <yshavit> is it "bad form" to create a class instance on a parameterized type, where there's a restriction on the parameterized type? E.g. I have a (Bucket a) type, I'm creating instance (Ord a) => Ord (Bucket a). It compiles fine, I'm just wondering if I shouldn't be doing it.
10:19:50 <kmc> that's a job for garbage collection
10:19:55 <mjrosenb1> ski: i was just giving an example of when a deep copy really is what you want
10:20:08 <ski> tigger_ : typically, the path from the root down to the "modified" node will have to be copied. all the subtrees "hanging from the side" of that path will just be reused
10:20:23 <yshavit> The reason I want to do it, btw, is that I want the Bucket's natural ordering to be based on its parameterized type (it has other args that I don't want to factor into the ordering)
10:20:32 <kmc> yshavit, that's very common, what makes you think it's bad form
10:20:37 <ski> mjrosenb1 : hm, then i don't understand what you meant by "functorial inheritence"
10:20:42 <kmc> for example Ord for lists is (Ord a) => Ord [a]
10:20:44 <yshavit> kmc: I didn't think it was, I was just wondering if it was :)
10:21:48 <ski> yshavit : there's also other cases like `instance Monoid w => Monad (Writer w)'
10:21:58 <mjrosenb1> ski: it is something that was developed for writing optimization passes in sml.  You make a module with a simple function that does a deep copy, using separate dispatch functions for each constructor
10:22:42 <mjrosenb1> ski: then you can write a new module where you import the base 'copy' function, and shadow one of the particular branches with a function that does more than a straight clone
10:22:54 <ski> yshavit : note that if you don't *need* the restriction of the type variable, then it can be bad form : e.g. `instance Error e => Monad (Either e)' was bad in this sense -- it would have worked perfectly well (and allowed more uses) to just remove the `Error e' constraint here
10:22:59 <tigger_> ski: thanks!
10:23:21 <mjrosenb1> ski: so you can generate lots of things that all look like "copy the tree, but make these changes to it" with next to no code
10:24:59 <yshavit> ski: right, I knew about that and think I was being too paranoid about it in this case. For this I do need the restriction, because Bucket's ordering comes from its type variable's ordering.
10:24:59 <ski> mjrosenb1 : ok, sounds a bit similar to
10:24:59 <ski> @wiki Multiplate
10:25:00 <lambdabot> http://www.haskell.org/haskellwiki/Multiplate
10:25:15 <ski> and yes, this also sounds similar to coinheritence
10:25:16 <ski> see
10:25:19 <ski> @where ErikPoll
10:25:20 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
10:25:20 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
10:25:20 <lambdabot> pdf>
10:26:01 <mjrosenb1> gah... lambdabot should not split url's over multiple messages :(
10:26:52 <tigger_> ski: the reason I was somewhat confused was after reading this "As we already stated, the update operation on immutable arrays (IArray) just creates a new copy of the array, which is very inefficient, but it is a pure operation which can be used in pure functions", in this case, why don't array's also do the pointer tracking thing like in the binary tree example. please correct me if I may be misunderstanding. here is the link with
10:27:06 <ski> mjrosenb1 : the word "mixin" also rises in my mind, but i can't recall exactly what that does atm, so i'm not sure it
10:27:11 <ski> 's relevant
10:27:40 <ski> tigger_ : because an array is not a tree
10:28:00 <kmc> tigger_, because arrays are flat chunks of memory
10:28:06 <kmc> that's why they have O(1) indexing
10:28:30 <ski> tigger_ : in many cases of arry updates, you can write the code in a way that will perform a whole bunch of updates on the array at the same time -- then copying the array is less efficient -- this is known as "bulk update"
10:28:37 <kmc> but you can't share nodes with the old structure, the way you can with a tree
10:28:42 <kmc> because there's only one "node", the flat chunk of memory
10:28:47 <kmc> this is one reason why Arrays aren't so popular in Haskell
10:28:49 <ski> tigger_ : if you really need individual array update, you can use the ephemeral mutable arrays
10:29:03 <ski> (or use something else than arrays, obviously)
10:29:04 <kmc> Data.Sequence, Data.Map, Data.IntMap have nicer properties
10:29:09 <shachaf> rien: I don't know what "plain algorithm" means.
10:29:20 <tigger_> kmc: okay, i see, thx!
10:29:31 <shachaf> rien: Functions are functions. ddarius's solution seems working to me.
10:29:49 <ski> @type (Data.Array.//)  -- this is a "bulk update" operation on persistent immutable arrays
10:29:50 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
10:30:48 <ski> mjrosenb1 : btw, do you have any implementation or paper references for where i should look for more info on that "functorial inheritence" ?
10:37:05 <rien> shachaf: something I can write in a straightforward manner without having to simulate ADTs in a language that doesn't have them
10:37:45 <mjrosenb1> ski: iirc, it was made by tom7.
10:37:52 <tigger_> hmmm, this is a slightly different question, but I wanted to use/implement some sort of sliding window, or circular index, where I need indexing. the fuctional queue is nice, for the slide in slide out, but doesn't necessairly give you index access. The array does however, but I thought the total copy operation might be large, especially for a large window size. I was thinking a queue, with two arrays instead of lists, but that sti
10:37:56 <tigger_> there are other clever window tricks I could do in a language like c pretty easily, but I'm a relative noob at haskell, so I'm just fishing for ideas.
10:38:25 <ski> mjrosenb1 : is that a person here on freenode ?
10:38:26 <mjrosenb1> ski: i learned about it in hotc; some of the projects there probably have an implementation: http://www.cs.cmu.edu/~crary/hotc/
10:38:39 <kmc> tigger_, look at Data.Sequence
10:39:12 <tigger_> kmc: okay will do! thx again for the help today!
10:39:14 <kmc> it's a nice general-purpose data structure
10:39:23 <ski> tigger_ : cut off at ".. I was thinking a queue, with two arrays instead of lists, but that sti"
10:39:23 <kmc> which supports adding/removing stuff at both ends
10:39:26 <mjrosenb1> ski: he may be on freenode?
10:39:27 <kmc> as well as random indexing
10:39:46 <kmc> all reasonably efficient, all as pure functions
10:39:52 * ski has no idea who tom7 is
10:40:47 <tigger_> ski: I was finishing that sentence with still incurs the copy overhead.
10:41:37 <mjrosenb1> ski: first hit on google :-p http://www.cs.cmu.edu/~tom7/
10:41:49 <shachaf> rien: ddarius's code does not require ADTs in any fundamental way.
10:41:59 <tigger_> kmc: adding/removing at both ends cool, but not necessary, just insertion one end, removal the other. and indexing over the length of the window, without too much entire window copy overhead.
10:42:26 <ski> mjrosenb1 : hehe, ok, ty. will look at those project things
10:42:47 <kmc> tigger_, it should be good for those things
10:42:54 <rien> shachaf: no code does, but can't translate it to a language without adts trivially.
10:43:12 <rien> I can't*
10:43:13 <tigger_> kmc: cool thanks again! really appreciate the help, not sure how long it would have taken me to find that module myself.
10:43:16 <kmc> it's easy to use, you can get something up and running quickly, then profile it to see if you need a more specialized structure
10:43:20 <kmc> no problem tigger_
10:43:30 <kmc> it can be pretty hard to find the right library for a task in haskell
10:43:36 <salisbury> In what type of application would one need to use nanosleep?
10:43:40 <salisbury> :t nanosleep
10:43:41 <lambdabot> Not in scope: `nanosleep'
10:43:43 <salisbury> ..
10:44:36 <kmc> you mean, why would one need ns resolution?
10:44:53 <roconnor> salisbury: in making a camera that films at 10^9 frames per second
10:44:53 <c_wraith> > let numbers = [1..] ; increment = (+1) ; all_the = map in increment `all_the` numbers
10:44:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:45:50 <kmc> 1 ns is not very long but 999 ns is a pretty long time
10:48:10 <kmc> perhaps you are busy-waiting on some hardware, and need to sleep 500 ns until the next possible update
10:49:41 --- mode: ChanServ set +o monochrom
10:50:23 --- mode: monochrom set -bb *!*@182.7.215.51 *!*@gateway/web/freenode/ip.217.252.114.153
10:50:28 --- mode: monochrom set -o monochrom
10:50:49 <salisbury> hmm, I've never really programmed that low-level. I never think of those things.
10:50:55 <salisbury> sounds fun though
10:51:14 <jessopher> most hardware has nowhere near that kind of resolution
10:51:26 <kmc> 2 MHz?
10:52:10 <kmc> i think using nanosleep for very small delays is not going to work well
10:52:16 <kmc> because you still have a system call overhead
10:53:15 <kmc> i thought linux might implement it in userspace with the vsyscall mechanism
10:53:19 <kmc> but this does not appear to be the case
10:53:47 <shachaf> rien: Why not?
10:55:09 <kmc> also POSIX nanosleep is specified to have different behavior wrt signals than usleep
10:55:16 <kmc> so this is another reason you might use it
10:56:01 <kmc> on x86 linux if you need very high-resolution busy waits in userspace, you can use the rdtsc instruction
10:56:17 <kmc> and hope that you are on new enough hardware that multiple cores or CPU frequency scaling will not screw up your measurements
10:57:10 <rien> shachaf: how do you define the List ADT in assembly, for instance?
10:58:14 <monochrom> please don't use assembly
10:59:30 <kmc> it's fun
11:00:23 <rien> it was a rhetorical question, don't worry :)
11:01:20 <kmc> anyway lists are a common datastructure in C and assembly
11:01:57 <rien> I was just trying to say that it's not straightforward to convert ADTful code into ADTfree
11:02:03 <monochrom> I like to say things like "please don't use assembly", "please don't use the Ackermann function", in full anticipation that nobody listens. http://www.vex.net/~trebla/haskell/calculator/Calculator.html#g:6
11:02:23 <kmc> monochrom, http://en.wikipedia.org/wiki/Wikipedia:Don't_stuff_beans_up_your_nose
11:02:42 <monochrom> ooohh, I should try that some time!
11:02:46 <kmc> rien, it depends what you mean by 'straightforward'
11:03:03 <kmc> a translation from Haskell algebraic types to assembly code is pretty simple to describe, and totally mechanical
11:03:13 <kmc> but it's still tedious to implement and use
11:03:43 <rien> for a person to translate, it's mostly never straightforward
11:03:46 <rwbarton> monochrom: Try advising people not to do things they hadn't thought of yet, you mean?
11:03:50 <rien> because it changes the algorithm
11:04:42 <kmc> each value has a tag word identifying the constructor used to construct it
11:04:47 <kmc> followed by a pointer for each data field
11:05:00 <kmc> writing 'case' for these values is probably within the capabilities of a good macro assembler
11:05:38 <kmc> in a language with first-class functions, you don't need to do it this way
11:05:48 <kmc> you can instead represent every data type by its fold function
11:06:21 <rien> but would someone in the real world really translate some haskell code into blub code using fold to emulate the ADTs?
11:06:24 <rien> that's my point :)
11:06:32 * jessopher stuffed beans in his nose
11:06:55 <rien> they would rather read up on the algorithm and go from there, instead of starting from an implementation-specific example
11:09:04 <shachaf> rien: But that code has very little to do with ADTs.
11:09:28 <shachaf> rien: Also, if you're writing it in assembly, yes, you'd write it differently.
11:10:59 <rien> if I said you're wrong I apologize. I only mean to say to me it's not straightforward at all
11:11:56 <rien> the only extent to which I understand his code is that he is simulating a stack with a list. I can do that, but I can't ever end up with [ 1 + 2 + 3 ], I always end up with [6]
11:12:42 <hpc> rien: as in, it's too strict?
11:13:12 <ski> (re rdtsc) "or the system may be hibernated and later resumed (resetting the time stamp counter)" -- huh, why reset ?
11:13:25 <ski> rien : by "ADT" do you mean "Abstract Data Type" or "Algebraic Data Type" ?
11:14:11 * ski wonders what rien's "his code" refers to
11:14:54 <ski> kmc : it's harder to use the fold representation if you want to combine several data structures, or use non-trivial pattern-matching
11:15:56 <rien> ski: ddarius's code, I can paste, hold on
11:16:27 <rien> hpc: perhaps. I think you're right, maybe the code he showed me is exploiting laziness, whereas I can't do that in a straightforward manner
11:16:59 <rien> > let plus (x:y:xs) = (x+y):xs; push = (:); rpn = foldr (>>>) id; in rpn [push 1, plus, plus] [x,y]
11:17:00 <lambdabot>   [1 + x + y]
11:17:01 <rien> ski: ^
11:17:35 <rien> the point is to turn "1 + + " (which is pointfree concatenative code) into "1 + x + y" (assuming the input to the concatenative code is x y)
11:18:39 <ski> rien : do you want to produce an AST, or do you want to produce a computed result ?
11:19:01 <rien> AST
11:19:14 <ski> (also, you still hasn't answered re you meant "Abstract" or "Algebraic" in "ADT" before)
11:19:33 <rien> I meant algebraic
11:19:36 <ski> ok
11:20:17 <ski> well, i think the above should work fine, if you define an AST type
11:20:28 <ski> hm
11:20:47 <ski> yeah
11:21:12 <rien> that's what I need to learn :P
11:21:14 <ski> so, `plus' will take two trees of the top of the stack, and put a combined tree back at the top
11:21:18 <rien> the above code doesn't help me with that
11:21:26 <ski> so, let's say you define
11:21:39 <ski>   type Expr = Lit Integer
11:21:49 <ski>              | Add Expr Expr
11:21:52 <ski> s/type/data/
11:22:03 <ski> then you can define
11:22:17 <rien> yes, then I can do it with the niceties of pattern matching and ADTs :)
11:22:24 <ski>   plus (x1:x0:xs) = Add x0 x1:xs
11:22:40 <ski>   pushLit n xs = Lit n:xs
11:22:52 <ski> rien : is that a problem ? :)
11:23:38 <kmc> ski, if you suspend to disk, it's a reboot as far as the hardware is concerned
11:23:51 <kmc> i guess there is no mechanism for restoring the old value of the time stamp counter
11:24:38 <rien> ski: insofar as I already know how to do that in ML but not in non-ML languages, yes :)
11:24:54 <ski> kmc : it seems to me that that would be an obvious thing to want to do
11:26:01 <ski> rien : oh, by "ML" you must mean "Machine Language" ?
11:27:01 * ski automatically reads "ML" as "one of the languages in the ML family : i.e. SML,Caml,O'Caml,F#,AliceML,Meta(ML/OCaml)"
11:27:28 <rien> ski: I mean that family
11:27:30 <ski> rien : well, know you know how to do it in Haskell as well, at least ..
11:27:37 <ski> oh
11:27:40 <mjrosenb1> > "ml" `isInfixOf` "f#"
11:27:41 <lambdabot>   False
11:27:47 <mjrosenb1> ski: you cand fool me!
11:27:50 <rien> no, I learned that from the wikibook on implementing a scheme in haskell :/
11:28:05 <mjrosenb1> *can't
11:28:08 <ski> well, doing it in the ML languages aren't very different from doing it in Haskell or Clean (or Erlang, say)
11:28:15 <ski> mjrosenb1 ;)
11:28:40 <ski> (mjrosenb1 : well, it's probably the black sheep of the family :)
11:29:31 <ski> (and by "Caml" i mean "Caml Light" -- is anyone still using that ?)
11:30:01 <mjrosenb1> moscow ml is using their bytecode
11:30:16 <mjrosenb1> and moscowml is only *slightly* dead
11:30:19 <rien> ski: so do you know how to do that same thing without using the advantages of ADT and pattern matching?
11:30:57 <rien> ski: also, I actually think what you were saying wouldn't work, because the points may be used more than once
11:30:59 <rien> that's the rub
11:31:15 <rien> it's not the same as turning pointful code into an AST
11:31:51 <ski> mjrosenb1 : ah, didn't know that. ok, hehe
11:32:40 <rwbarton> rien: the only thing you are pattern matching on in that example is the input list
11:32:40 <ski> rien : sorry, "points" ?
11:33:06 <rwbarton> of course you are probably planning to pattern match on the AST later, but then instead of building the AST you could just build up whatever result you ultimately want
11:33:19 <ski> (aka fold)
11:33:45 <rien> rwbarton: yes but I'm pattern matching ADTs which are not available to me in other languages
11:33:51 <rien> ski: yes, variables.
11:33:56 <rwbarton> can you be, like, a lot more specific?
11:34:10 <rwbarton> (maybe there was more context earlier that I missed, sorry)
11:34:24 <rwbarton> you're not pattern matching anything but a list, that's what I just said
11:34:43 <ski> rien : instead of matching on the list, you'd check whether the list was empty, and if not, take head and tail
11:34:44 <rwbarton> in lisp you could just use car/cadr/cddr
11:35:00 <rien> certainly. I need to turn this concatenative pointfree code: 1 + +, assuming input x y, into the AST (+ (+ y 1 ) x)
11:35:10 <ski> rien : instead of calling `Add' you'd call a corresponding subrouting, which allocated (somewhere) the node
11:35:22 <rwbarton> rien, in what language?
11:35:29 <rien> ski: the matching is the easy bit to fix. what I don't know how to translate is the definition of the datatypes
11:35:39 <rien> rwbarton: blub, whichever. ruby, python, etc
11:35:44 <rwbarton> no, *you* pick one :)
11:35:46 <rien> a non-ML language
11:35:48 <rien> ruby!
11:35:51 <rwbarton> okay.
11:36:10 <ski> rien : hm, ok .. for some reason i was thinking here you wanted to write this in assembler
11:36:26 * rwbarton has been down the "but the language X you chose has feature Y which I don't want to use" path too many times before
11:36:42 <rwbarton> this way, when that happens, it'll be your fault ;)
11:36:51 <rien> rwbarton: lol
11:36:55 <rien> fair enough
11:37:07 <rien> ski: that was rhetorical, sorry :)
11:37:08 <ski> rien : so (regardless of whether this is assembler or Ruby) you translate the definition of the datatypes into one subroutine/function for each constructor, that creates (allocates) a node initialized with the arguments of the constructor
11:37:09 <rwbarton> okay, so first you need some way to represent the AST in ruby I guess
11:37:32 <rien> rwbarton: before you begin, hold on a second
11:38:25 <rien> I do not need to be walked through how to turn code into an AST. I appreciate the help but I need something more specific. I need to know how to turn the kind of pointfree concatenative code that I gave as example, into an AST
11:38:38 <rien> my specific problem is how to handle functions like swap for instance
11:38:49 <rien> because 3 2 swap -> 2 3
11:39:10 <rwbarton> okay, so keep a stack of AST nodes
11:39:15 <rien> here's a better example: : dup ( x -- xsquared ) dup * ;
11:39:21 <rien> how do I walk that and turn it into an AST?
11:39:38 <rien> sorry, hold on
11:39:50 <rien> : square ( x -- xsquared ) dup * ;  there we go
11:39:51 <Sgeo> Someone please explain this to me?
11:40:05 <Sgeo> n/m someone else already did
11:40:14 * ski isn't sure what "turn the kind of pointfree concatenative code that I gave as example, into an AST" means
11:40:34 <ski> rien : you parse it, in the usual way ?
11:40:54 <rwbarton> he wants the AST  Mul (Var "x") (Var "x")  as output, I think
11:41:01 <rien> the usual way would be: x x *, which gives (* x x)
11:41:10 <rien> I don't know how to go from dup * to (* x x)
11:41:24 <rien> I hope that's clear and specific now
11:41:31 <ski> hm, ok
11:41:39 <Sgeo> Factor?
11:41:44 <rien> I know how to turn x x * into (* x x) just fine
11:41:45 <rwbarton> just execute your forth program, but with a stack composed of AST nodes rather than values
11:41:47 <rien> Sgeo: yes
11:41:58 <ski> how will you handle e.g. a word that first reads a number from the stack, then discards that number of things from the stack ?
11:42:01 <rien> rwbarton: can you be a bit more concrete? :D
11:42:18 <rwbarton> I'm assuming you don't have things like loops or conditionals, yeah
11:42:26 <rien> oh, I have all of those
11:42:48 <ski> so, you want to translate from a point-free representation to a point-ful, yes ?
11:43:03 <rien> ski: that's with macros, we manipulate the lexer for that and rewrite code. that's a fair quetion but beyong my scope
11:43:03 * ski thinks some kind of abstract interpretation, maybe
11:43:11 <rien> ski: to a pointful AST yes
11:43:30 <rien> say I want to translate it to some lispy syntax
11:43:48 <rwbarton> well if you don't have conditionals/loops then it is pretty straightforward
11:44:01 <rien> I do have those
11:44:08 <rwbarton> well those are problematic
11:44:10 <rien> it's a real language we're talking about :)
11:44:16 <ski> presumably we first assume that the stack effect is static (i.e. doesn't depend on run-time values)
11:44:27 <ski> or does Factor allow those ?
11:44:40 <rien> rwbarton: but please go on. I think the way we have conditionals and loops is not a problme
11:44:47 <rien> since they take thunks as arguments
11:44:56 <rwbarton> okay
11:45:02 <rien> and the thunks are then turned into an AST separately. okay let's have it then :)
11:45:04 <rien> I'm excited
11:45:05 <rwbarton> well, let's target lisp since that is easy and specific
11:45:12 <rwbarton> we store a stack of strings
11:45:27 <rwbarton> initially we have the name of each variable to the function
11:45:30 <rien> ski: in my scope we assume what you assumed, that the stack effect is static
11:45:30 <rwbarton> on the stack
11:45:34 <ski> rien : if you can write a word with stack effect `( n x_1 ... x_n -- )', then i think that would be problematic here
11:45:46 <rien> ski: you can't in my scope
11:45:47 <rwbarton> right, that is exactly the example I was concerned about
11:46:14 <rien> okay, can we use the square function as an example? I think it's simple enough
11:46:17 <rwbarton> sure
11:46:23 <rwbarton> we start with the stack "x"
11:46:24 <rien> it's just dup *, with input x
11:46:26 <rien> yes
11:46:45 <rwbarton> now we execute our program, the interpretation of things like dup is the normal one, so we reach "x" "x"
11:47:11 <ski> rwbarton : how do you handle conditionals ?
11:47:19 <rwbarton> and the interpretation of things like * is to form a sexp "(* " ++ arg1 ++ " " ++ arg2 ++ ")"
11:47:23 <rien> rwbarton: nevermind those for now
11:47:23 <rwbarton> I don't
11:47:33 * ski can't recall how conditionals are written in Factor (nor in Forth)
11:47:48 <rien> ski: boolean [ iftrue ] [ iffalse ] if
11:47:51 <rwbarton> in postscript it's { true-case } { false-case } b if or so
11:47:58 <ski> (iirc something like `if .. else .. then')
11:48:15 <rien> rwbarton: what does the interpretation of dup generate?
11:48:30 <rwbarton> it duplicates whatever the top stack node is
11:48:46 <ski> rien : well, navely, it would duplicate the AST -- nicer would be if it generated a `let' in the resulting code
11:48:49 <rwbarton> so you will lose track of sharing, maybe you want to keep track of it
11:48:51 <rien> oh so we actually are working off of a stack of strings and we duplicate the top? ok.
11:49:10 <yshavit> is there a way to do a sort of "instanceof" test? I have a type variable a, and there's a branch in a method that I don't think I'll ever hit, so I want to call "error" there as an assert. If the object I have happens to be Show, I'd like to print it; but I don't want to require that restriction, since it's just for an assert.
11:49:11 <rien> rwbarton: I do need sharing (if I understand what you mean) because I have words like swap and keep and rot
11:49:23 <rien> I think that's my key problem
11:49:28 <rien> is that what you mean by sharing?
11:49:34 <rwbarton> maybe?
11:49:41 <monochrom> there is no instanceof, unless you involve the type class Typeable
11:49:46 <rien> I need to be able to do this: dup dup * +
11:49:52 <rwbarton> imagine you had x square square
11:49:58 <ski> rien : i don't think you need sharing for that. you'd need sharing for words that have side-effects, or takes much time to compute
11:50:00 <yshavit> monochrom: so does haskell just not (easily) support this use case?
11:50:05 <rwbarton> naively you will produce the result (* (* x x) (* x x)), is that okay?
11:50:13 <rien> ski: ok then I misunderstood "sharing" (luckily!)
11:50:15 <monochrom> that's right, not easily.
11:50:21 <yshavit> okay
11:50:26 <rwbarton> or do you need (let ((y (* x x))) (* y y))?
11:50:42 <rien> rwbarton: definitely the naive version
11:51:05 <rwbarton> okay, then you don't need to do anything special besides just duplicate the string on the stack
11:51:06 <monochrom> in return, you get a pretty strong guarantee that a function of type (a,b)->a must be either the same as fst or non-terminating.
11:51:52 <ski> rwbarton : i'm not sure why you have a stack of strings rather than a stack of ASTs ..
11:51:59 <rien> rwbarton: let me see if I understand, because for now that seems like the recipe for executing a stack language, but not for turning it into an AST
11:52:00 <rwbarton> just to simplify
11:52:37 <shachaf> rien: The difference between "executing" and "turning into an AST" is the different between (\x y -> x * y) and (\x y -> x ++ "*" ++ y)
11:52:48 <shachaf> Or however you want to build your AST up.
11:52:51 <rwbarton> rien: they are the same, the key difference is when executing, when you see + you add, but when building an AST, you just build an Add node
11:52:58 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/a1444af2476a6a53
11:55:07 <rwbarton> and when building the AST, you never actually inspect the nodes you've built as you go
11:55:09 <rien> for executing: x | dup *   x x | *   z | nothing, and for AST'ing: x | dup *   x x | * (gives off what AST?)    z | nothing (gives off (* x x)
11:55:52 <rwbarton> you don't give off anything--the resulting AST is the top node of the final stack
11:56:02 <rwbarton> or nodes, if your function returns multiple values
11:56:02 <ski> rien : i think that to turn `[ iftrue ] [ iffalse ] if' into an AST, you must use the *same* stack of ASTs for both branches
11:56:27 <rien> rwbarton: okay I think a lightbulb went off :) let me think a little now :)
11:56:33 <ski> rien : and afterwards, either some kind of stack merging, or pulling the continuation into the branches (code duplication)
11:56:53 <rien> ski: yes, I honestly don't think the way Factor handles conditionals and loops will be a problem at all
11:57:13 <ski> rien : note that code duplication (as in the `square square' example above) may lead to an exponetial code blowup, in general
11:57:40 <ski> this is why for any non-toy thing, i really think you don't want code duplication (so use `let' instead)
11:57:44 <rwbarton> I had to resist the temptation to switch to the 'double x = x + x' example.
11:57:52 <rien> rwbarton: so to formalize this a bit, I would not generate an AST node for any function that just shuffles the stack, like dup, swap, etc?
11:58:11 <rwbarton> right, those functions don't produce new AST nodes
11:58:37 <rien> that was one of my main issues, I had no clue how to make ast nodes from that
11:58:44 <rwbarton> I guess this is really a sort of choice you're making, but it seems to be the natural choice to make
11:59:00 <yshavit> is there a built-in method (Eq a) => [a] -> [ (Int,a) ] where the Int is the number of consecutive a's?  I'm looking on hoogle and can't find it. I tried to write my own with foldr, and I'm having trouble making it lazy
11:59:20 <c_wraith> yshavit: there are common idioms for doing it
11:59:38 <c_wraith> :t (length *** head) . group
11:59:39 <lambdabot>     Couldn't match expected type `([a], [a1])'
11:59:39 <lambdabot>            against inferred type `[[a2]]'
11:59:39 <lambdabot>       Expected type: [a2] -> ([a], [a1])
11:59:39 <ski> rwbarton : hm -- so which words would generate ast nodes ?
11:59:48 <c_wraith> :t (length &&& head) . group
11:59:48 <lambdabot> forall a. (Eq a) => [a] -> (Int, [a])
11:59:57 <rwbarton> +, *, etc.
11:59:59 <ski> rien : i suppose, for library word which produce multiple results, you could use multiple values
12:00:16 <monochrom> you forgot map
12:00:38 <ski> rwbarton : yeah, but in general library words presumably would always get nodes
12:00:43 <c_wraith> oh, so I did
12:00:49 <c_wraith> :t map (length &&& head) . group
12:00:49 <monochrom> > (map (length *** head) . group . sort) [3,1,4,1,5,9,2,6,5,3]
12:00:50 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
12:00:50 <lambdabot>   Couldn't match expected type `([a], [a1])'
12:00:50 <lambdabot>         against inferred type `[...
12:00:59 <c_wraith> monochrom: he explicitly did not ask for sorting first
12:01:02 <rwbarton> if a word 'foo' produces two results on the stack, you could model that with two nodes, 'foo1' and 'foo2'
12:01:07 <c_wraith> "consecutive"
12:01:09 <rien> rwbarton: 3 | dup dup + *     3 3 3 | + *     3 (+ 3 3) | *     (* 3 (+ 3 3)) | nothing   hooray!
12:01:11 <fonzy> sera
12:01:14 <monochrom> oh yucks, Eq
12:01:22 <rwbarton> and now not generating nodes 'dup1', 'dup2' is just an optimization
12:01:39 <yshavit> c_wraith, monochrom : yeah, I was going to sort previously. More because I thought it would be better compartmentalization than anything else.
12:01:43 <ski> rien : looks fine
12:01:47 <monochrom> > (map (length &&& head) . group) "xxx%yyz"
12:01:49 <lambdabot>   [(3,'x'),(1,'%'),(2,'y'),(1,'z')]
12:01:53 <ski> rwbarton : *nod*
12:02:01 <rwbarton> Barring effects, of course
12:02:10 <ski> yea
12:02:35 * ski would model a word with two results as a procedure that produces two values
12:02:39 <yshavit> monochrom: oh, no, there I would want:  [ (3,'x'), (1,'%'), (2,'y'), (1,'x') ]
12:02:44 <monochrom> BTW this is a reason why head is safe and why the much praised safeHead is an impediment
12:02:45 <rien> ski: :) now we try a function that leaves two values on the stack
12:03:30 <monochrom> > (map (length &&& head) . group) "xxx%yyx"
12:03:32 <lambdabot>   [(3,'x'),(1,'%'),(2,'y'),(1,'x')]
12:03:46 <yshavit> nice. Now I need to figure out what that means! ;)
12:04:00 <c_wraith> group is the only interesting function in there.
12:04:01 <rwbarton> yshavit, are you familiar with group?
12:04:15 <yshavit> rwbarton: it's &&& I'm not familiar with. Hoogling now.
12:04:16 <monochrom> by playing with it bit by bit.
12:04:18 <saati> > map (lenght &&& head) [[]]
12:04:18 <lambdabot>   Not in scope: `lenght'
12:04:21 <saati> > map (length &&& head) [[]]
12:04:23 <lambdabot>   [(0,*Exception: Prelude.head: empty list
12:04:23 <monochrom> > group "xxx%yyx"
12:04:25 <lambdabot>   ["xxx","%","yy","x"]
12:04:51 <saati> how is this safe?
12:04:58 <monochrom> > (length &&& head) "xxx"
12:04:59 <rwbarton> saati: group only produces lists of nonempty lists
12:04:59 <lambdabot>   (3,'x')
12:05:20 <monochrom> > map (length &&& head) ["xxx","%","yy","x"]
12:05:21 <lambdabot>   [(3,'x'),(1,'%'),(2,'y'),(1,'x')]
12:05:22 <rwbarton> er, to be less confusing, each member list in 'group x' is always nonempty
12:05:44 <saati> okay, but head is safe if you are sure t not give it an empty list seems very self evident
12:05:59 <ski> > (mapM (strength . (length &&& safeHead)) . group) "xxx%yyz"  :: Maybe [(Int,Char)]
12:06:01 <lambdabot>   Just [(3,'x'),(1,'%'),(2,'y'),(1,'z')]
12:06:11 <rwbarton> yes, so if I define "rle = map (length &&& head) . group", that is safe
12:06:29 <monochrom> safety is always asserted in context. everything is unsafe when taken out of context. id is unsafe when taken out of context, because without context  you don't even know whether you have enough memory to run id.
12:06:30 <ski> yshavit : `(f &&& g) x = (f x,g x)'
12:06:30 <saati> @type strength
12:06:31 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a, f b) -> f (a, b)
12:07:09 <yshavit> ski: ah, simple enough
12:07:17 <saati> where does strength come from?
12:07:49 <hpaste> Carpi pasted “No instance :(” at http://hpaste.org/55343
12:07:59 <ski> @type uncurry (flip . fmap (,))
12:08:00 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (f a, b) -> f (a, b)
12:08:02 <ski> @type uncurry (fmap . (,))
12:08:03 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
12:08:20 <carpi> could someone pleae tell me why that piece of code wont work?
12:08:22 <ski> saati ^
12:08:36 <saati> thanks
12:09:08 <ski> carpi : and the error is ?
12:09:26 <carpi> no instance for (RandomGen (IO StdGen))
12:10:03 <rien> rwbarton: see if this is what you mean with words producing two results
12:10:04 <ski> saati : there's a concept of "functorial strentgh" in category theory. in Haskell (but not in generall) every functor is strong, which is why i could define `strength' as above, requiring only `Functor f'
12:10:14 <rwbarton> carpi: yes, you tried to pass the IO action "getState" as a the generator to randomR
12:10:24 <rien> rwbarton: suppose we have : p1p2 ( x -- x+1 x+2 ) 1 + dup 1 + ;
12:11:16 <ski> carpi : since `getState' uses `IO', and `getRndElement' calls it, `getRndElement' must also have `IO' in its type
12:11:25 <rien> rwbarton: x | p1p2    x | 1 + dup 1 +    (+ x 1) | dup 1 +    (+ x 1) (+ x 1) | 1 +    (+ x 1) (+ 1 (+ x 1)) | nothing
12:11:45 <ski> carpi : so you should probably use `do'-notation with `<-' as well as some `return's in `getRndElement'
12:12:26 <rwbarton> rien: yes, so (+ x 1) and (+ 1 (+ x 1)) are the two ASTs that describe the two return values of p1p2
12:12:38 <carpi> so there no way to call impure functions from pure functions?
12:13:24 <rwbarton> I probably ought to quibble with your terminology slightly, but "right".
12:13:59 <monochrom> there is a backdoor for that for advanced programmers only
12:14:08 <ski> rien : actually `(+ x 1) (+ (+ x 1) 1) |' at the end (consistency)
12:14:09 <brill> Which IDE are you all using? Been looking at Emacs but so far have not decided.
12:14:40 <ski> carpi : there is no way to do I/O in a function which doesn't have `IO' in its return type (hidden or otherwise)
12:14:56 <monochrom> I use emacs but I have only done small programs. I would use Eclipse for bigger programs.
12:15:03 <kmc> there is no way to do IO from a function, period
12:15:05 <russellw> brill, UltraEdit
12:15:10 <kmc> a function can return a description of how IO might be performed in the future
12:15:18 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
12:15:38 <monochrom> sometimes I am in windows and I use notepad++ there
12:15:41 <yshavit> I'm having trouble understanding &&&'s signature: "a b c -> a b c' -> a b (c, c')"... what's that saying? For instance, with (length &&& head) :: [a] -> [ (Int,a) ] , what types correspond to what methods?
12:15:50 <ski> kmc : i agree :)
12:16:02 <shachaf> yshavit: a corresponds to (->).
12:16:19 <yshavit> shachaf: oooh, man. This is above my head for now.
12:16:20 <shachaf> So it has type forall b c. (b -> c) -> (b -> c') -> (b -> (c,c'))
12:16:26 <rien> ski, rwbarton: it seems easy to derive an AST that uses let so that we don't compute things twice unnecessarily. I just did it on paper.
12:16:29 <carpi> thanks.. ill try to get my hasklel lingo right
12:16:30 <shachaf> yshavit: Just ignore the fact that "a" can be anything else.
12:16:39 <monochrom> &&& is very general type class method. but when specialized to functions, it's just (b->c) -> (b->c') -> (b -> (c,c'))
12:16:43 <yshavit> shachaf: okay :) that will probably help.
12:16:49 <rien> ski: yes, that.
12:16:56 <shachaf> yshavit: That's what we all do anyway.
12:17:01 <shachaf> Except for mm_freak, possibly.
12:17:07 <yshavit> monochrom, shachaf : So out of curiosity, would the other thing it could apply to be a type constructor? or whatever its' called?
12:17:09 <monochrom> so for example (f &&& g) x = (f x, g x)
12:17:09 <saati> @djinn a b c -> a b c' -> a b (c, c')
12:17:10 <lambdabot> -- f cannot be realized.
12:17:12 <yshavit> e.g. Maybe (not Maybe Int) ?
12:17:20 <ski> rien : i'm not saying it's necessarily hard. i think it requires a little thought, though (e.g. interaction with conditionals)
12:17:28 <monochrom> the general type class is Arrow
12:17:32 <shachaf> yshavit: I am not managing to parse your sentence. :-)
12:17:41 <ski> rien : also, you need to handle words generating more than one result, in some way
12:17:59 <rien> rwbarton: ski: thanks a lot for the help, you solved it, and that was exactly what I was looking for, a way to do it, instead of code. next time I'm asked "in what language" I'll say "pen and paper" :)
12:18:21 <yshavit> shachaf: sorry :)  I'm just wondering what, besides (->), a could be. And I'm wondering if it would be something like Maybe, as opposed to Maybe Int, such that Maybe takes a type variable and gives a type
12:18:22 <rwbarton> :)
12:18:31 <rien> ski: neither of those will be a problem I think. returning 2 or more items can be done with the equivalent of scheme's (values)
12:18:40 <shachaf> yshavit: It wouldn't be Maybe, because a takes two argument.
12:18:44 <rien> and conditionals, I'll think about them :)
12:18:46 <shachaf> yshavit: But it would be a type constructor, yes.
12:19:00 <yshavit> shachaf: ah, okay. So for instance, Either ?
12:19:10 <ski> yshavit : `a' could possibly be `Either', since it has the right kind
12:19:19 <shachaf> yshavit: Either has the right kind, but it wouldn't be a valid Arrow.
12:19:20 <FliPPeh_> Is there some kind of generic return? I have a data type that consists of many different constructors, like NByte Int8, NShort Int16, NInt Int32, NLong Int64, NFloat Float, NDouble Double, NString String, ..., is there some way to write a generic "getNValue" function that works with all those wrapped values?
12:19:25 <ski> yshavit : however, there's no instance for that (and can't be, it's not sensible in this case)
12:19:28 <shachaf> yshavit: A simpler type class to look at is Control.Category.Category.
12:19:32 <rien> you guys rock, ski and rwbarton, thanks a lot. gtg to the post office now :)
12:19:35 <monochrom> if you have newtype Mine a b = Mine(a -> Maybe b), then you can have (&&&) :: Mine b c -> Mine b c' -> Mine b (c, c').
12:19:36 <ski> yshavit : a sensible value of `a' could be `Kleisli IO'
12:19:41 <yshavit> hm, okay. That's a weekkend research project, I think.
12:19:57 <yshavit> I'm trying to prototype some stuff in haskell, and getting a bit distracted ;
12:19:58 <yshavit> ;)
12:20:11 <monochrom> perhaps I should write newtype Mine b c = Mine(b -> Maybe c) to match the variable names better
12:20:14 <shachaf> yshavit: class Category cat where id :: cat a a; (.) :: cat b c -> cat a b -> cat a c
12:20:30 <shachaf> yshavit: One instance of Category is just (->).
12:20:32 <ski> rien : *nod* i was thinking values would be nicer here than rwbarton suggestion of splitting each such word -- an alternative would be to generate code in CPS
12:20:35 * hackagebot paragon 0.1.5 - Paragon  http://hackage.haskell.org/package/paragon-0.1.5 (NiklasBroberg)
12:21:08 <shachaf> yshavit: Another instance is this (getter,setter) pair: data Lens a b = MkLens (a -> b) (b -> a -> a)
12:21:13 <yshavit> shachaf: now I'm not parsing what you're saying ;)  but it's more because it's a bit over my experience level in haskell
12:21:23 <rien> ski: yes, I have Appel's Compiling With Continuations, so CPS is definitely a good choice here
12:21:49 <Botje> great book, that.
12:21:50 <rien> ski: I'm not sure what rwbarton meant by his suggestion of splitting
12:22:14 <rien> Botje: Appel, imho, has a terrific way of explaining things and making them sound obvious
12:22:18 <FliPPeh_> Noone? :(
12:22:26 <rien> Botje: his Tiger book is particularly amazing at that
12:22:54 <Botje> tiger book?
12:22:59 <shachaf> yshavit: Better to understand the concrete types before trying to understand the type class. :-)
12:23:02 <rien> Botje: Modern Compiler Implementation
12:23:14 <Botje> i'll have to get taht one then ;)
12:23:16 <monochrom> tiger book doesn't do too much continuations
12:23:30 <shachaf> yshavit: You can come back to this sort of thing later after you've figured out the concepts involved in simpler contexts.
12:23:42 <yshavit> shachaf: that was my intention :)
12:23:45 <monochrom> otoh tiger book covers every topic adequately
12:24:05 * monochrom learned generational garbage collection from tiger book
12:24:11 <yshavit> shachaf: it's a bit difficult to understand the meta when you're still struggling with the base ;)
12:24:26 <rien> monochrom: the continuations are in his Compiling with Continuations book
12:25:03 <rien> monochrom: I can't read his books without smiling, he makes everything seem easy
12:25:36 <rien> I should tell him that, maybe that way he'll write more books
12:26:09 <WJW> does anybody know the current place of the network-bytestring module?
12:26:27 <WJW> it used to be in Network.Socket.ByteString
12:26:35 <WJW> but that one doesn't exist anymore?
12:26:46 <monochrom> you know you can go into an infinite loop converting to CPS and then defunctionalizing and then converting to CPS and then...
12:26:55 <shachaf> WJW: It seems to be there.
12:27:03 <shachaf> WJW: However, the package is now "network".
12:27:24 <ski> rien : instead of `(let-values (((x y) (foo ...))) ...)' he suggested basically `(let ((x (foo-0 ...)) (y (foo-1 ...))) ...)', i.e. two separate invocations to `foo-0' and `foo-1' which corresponds to the single word invocation of `foo' which produces two results
12:27:48 <rien> monochrom: I didn't know defunctionalizing was a step. I thought it was closure-conversion -> cps -> done.
12:28:26 <rien> ski: ouch, that won't work with side effects
12:28:32 <ski> monochrom : any example ?
12:28:47 <nexion> does CSS support parent classes / inheritance? for example, define a class "card" which is then extended by "card220", "card320", etc, inheriting card's style attributes
12:28:50 <nexion> err
12:28:50 <ski> rien : as noted :)
12:28:51 <nexion> wrong channel
12:29:25 <WJW> shachaf: I don't think I understand correctly
12:29:26 <monochrom> if somehow your target architecture is not fit for CPS but more fit for algebraic data types (equivalently tags, branching, jump tables...) you defunctionalize all your continuations, i.e., turn them into algebraic data types and runtime test-and-branch
12:29:36 <ski> rien : you could of course let `foo' generate a compound structure (tuple or list or record) .. but that seems a bit heavy-weight if you're going to take that apart directly at the call sire
12:29:42 <ski> s/sire/site/
12:29:46 <WJW> shachaf: there is no function in Network that takes Bytestring as an argument
12:29:47 <shachaf> WJW: See: http://hackage.haskell.org/package/network-bytestring and http://hackage.haskell.org/package/network
12:29:59 <shachaf> WJW: Not the module "Network". The package "network".
12:30:30 <monochrom> ski, if you CPS-transform an algebraic data type, then defunctionalize, you get back the original algebraic data type
12:30:42 <WJW> shachaf:
12:30:44 <WJW> thanks
12:30:45 <ski> ah, ok
12:31:00 <WJW> the evil capitalized letter strikes again :/
12:31:28 <rien> ski: yes, I think CPS or values is the way to go too
12:35:18 <monochrom> in Appel's days, there were two different reasons to convert to CPS. one was that some target architectures may be friendly to CPS, so you convert to CPS and call it done. but another reason was that though some other target architectures are not friendly to CPS, you convert to CPS anyway for spotting optimizations, then you defunctionalize for the target architectures.
12:36:04 <FliPPeh_> What is the easiest approch to have a minimum amount of unwrap functions for many types ala (TInt Int32), (TLong Int64), (TFloat Float) so I don't have to write n functions for n types all of which do _exactly_ the same exact filtering another type constructor and return that other type
12:36:09 <monochrom> eventually, the second reason went away because someone wrote a paper on how to spot and carry out the equivalent optimizations without the CPS middle form.
12:36:33 <rien> monochrom: is that SSA?
12:36:34 <FliPPeh_> s/exact/except/
12:36:47 <monochrom> not sure, probably not
12:37:20 <mauke> :t ala
12:37:21 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
12:37:36 <parcs`> :t unpack
12:37:37 <lambdabot> forall n o. (Newtype n o) => n -> o
12:37:42 <FliPPeh_> Now I'm confused.
12:38:02 <FliPPeh_> I'm dealing with simple ADTs here :/
12:38:24 <FliPPeh_> type TVal = TByte Int8 | TShort Int16 | TInt Int32 | TLong Int64 | .....
12:38:29 <FliPPeh_> data TVal*
12:39:32 <FliPPeh_> Right now I'd have to write "unboxTint" which ignores everything but TInt, "unboxTbyte" which ignores everything but TByte, etc etc
12:40:09 <rwbarton> why do you "have" to? and what does "ignores" mean?
12:40:52 <rwbarton> in what context would you use this unboxTint?
12:40:53 <FliPPeh_> I have to, because I need to remember the type the value comes from in case it's going to get serialized back to the file it was read from
12:40:59 <monochrom> data TVal = TByte{unboxTByte::Int8} | TShort{unboxTShort::Int16} | ...
12:41:29 <FliPPeh_> Basically, all those values come from a binary file and they have to be written back in the same format they have been read, so I can't decay any IntX to Integer
12:41:44 <ski> monochrom : hm, which paper was that ?
12:41:47 <rwbarton> isn't that exactly what TVal is for?
12:41:58 <FliPPeh_> Yep
12:42:01 <monochrom> I forgot. but likely some Wadler magic
12:42:06 <FliPPeh_> But with that comes the issue of unboxing
12:42:15 <rwbarton> when would you use this "unboxTint"?
12:42:47 <rwbarton> in particular why would you know that you actually have a TInt and not a TByte or something?
12:42:50 <FliPPeh_> When I just need the value inside my program, I don't care if that's and int or a byte, I just want a number to work with, hence my need for a generic "unboxTVal"
12:43:01 <rwbarton> oh well that's totally different, isn't it?
12:43:16 <FliPPeh_> I just have to remember the types for writing it back to the file
12:43:34 <monochrom> pattern-matching suffices for serialization.
12:43:35 <rwbarton> unboxTVal (TByte x) = fromIntegral x; unboxTVal (TShort x) = fromIntegral x; etc.
12:44:07 <FliPPeh_> That covers about 6 of my 10 datatypes
12:44:19 <FliPPeh_> Then there is TString, TByteArry, TList and TCompound, which are NOT numbers
12:45:22 <FliPPeh_> But well, I suppose I could split it up into numeric, string and list accessing
12:45:40 <roconnor> FliPPeh_: This all depends very much on what you want to do with the data
12:45:49 <rwbarton> Don't you need to pattern match to find out what kind of thing you have though?
12:47:43 <FliPPeh_> There are 2 possible scenarios, either I know which type it is because I know the file format or I don't know it when I have to search the structure
12:48:05 <FliPPeh_> It's pretty generic really
12:53:32 <Phlogistique> auuuuggh python
12:53:51 <Phlogistique> why would anyone define a language WITHOUT a proper support for anonymous functions :(
12:54:45 <ion> Indeed :-)
12:54:47 <Axman6> yeah, they're all called lambda, that's not anonymous at all!
12:54:51 <FliPPeh_> I thought they had (lambda x: x)
12:55:02 <mauke> FliPPeh_: they do
12:55:09 <mauke> but there's not much you can do with lambda x: x
12:55:24 <FliPPeh_> That was a silly example and you know it!
12:55:32 <mauke> all python lambda examples are silly
12:55:39 <ion> flippeh: Since they don’t have combinators for combining multiple expressions into one, the lambda expression should support the “;”. It doesn’t.
12:55:42 <mauke> because python lacks proper support for anonymous functions
12:55:46 <mizu_no_oto> Python, AFAIK, essentially has half-assed lambdas
12:55:47 <russellw> You can put any one line expression into a Python lambda
12:55:54 <rwbarton> semicolon(line1, line2)
12:56:00 <russellw> If you need several lines, the overhead of declaring a local named function is trivial
12:56:07 <russellw> So I'm not seeing the problem?
12:56:15 <mauke> russellw: you are blub
12:56:26 <shachaf> rwbarton: Is Python evaluation order left-to-right?
12:56:26 <ion> Blub is my absolute favorite programming language.
12:56:36 <ion> Everything else seems to utterly suck.
12:56:38 <kmc> trivial
12:56:46 <rwbarton> shachaf: the arguments are supposed to be thunks
12:56:49 <russellw> mauke, actually I've used languages from pretty much every family ever created, probably more than you have
12:56:55 <kmc> o snap
12:57:00 <mauke> russellw: bring it on
12:57:05 <kmc> time to whip it out and measure
12:57:21 <ion> The troll light is blinking.
12:57:38 <shachaf> rwbarton: Ah, with lambda for each line?
12:57:44 <russellw> But the relevant question when you move from language foo to language bar is not whether you can write foo in bar. The question is whether you can accomplish the same things with roughly the same effort
12:57:54 <rwbarton> yeah, semicolon(lambda (): print x, lambda (): print y)
12:58:06 <russellw> Or to paraphrase the classic quote, you can write FORTRAN in Haskell, but it's probably not a good idea
12:58:10 <rwbarton> I don't even know whether that has the precedence I intended.
12:58:19 <mauke> rwbarton: print x isn't an expression
12:58:25 <mauke> "multiple lines" is a red herring
12:58:34 <rwbarton> oh, right
12:58:37 <mauke> python's lambda supports a single *expression*, not a statement
12:58:46 <rwbarton> so you also need to expression-ise each kind of statement
12:58:58 <shachaf> rwbarton: Can you expression-ise assignment?
12:59:00 <mauke> we're entering boost territory
12:59:07 <kmc> can you enterprise-ise assignment
12:59:11 <russellw> Similarly it's probably not a good idea to try to write Haskell in Python. But if you do want to write that with lambda, you could write a function that calls print
12:59:27 <mauke> heh
12:59:29 <rwbarton> shachaf: python has a weird notion of scope so that it wouldn't entirely surprise me.
12:59:48 <mauke> python's lambda isn't crippled! all you have to do is lambda x: foo(x)
13:00:00 <mauke> assuming foo() is already defined somewhere
13:00:00 <fullofcars> I've got a general parsec question
13:00:14 <rwbarton> anyways, any guesses as to what "print (lambda x: x, lamdba y: y)" does?
13:00:17 <russellw> If you really want to, you could pull tricks like putting the stuff you want to assign into single element arrays. But I will again suggest declaring a local function is a better way to solve this problem in Python
13:00:47 <mauke> rwbarton: complains about "lamdba"?
13:01:03 <rwbarton> oh hah
13:01:04 <monochrom> haha
13:01:23 <rwbarton> well the error message was pretty vague :/
13:01:25 <monochrom> if you see buddha, kill buddha. if you see lambda, kill lambda.
13:01:31 <rwbarton> SyntaxError: invalid syntax
13:01:39 <mauke> Phlogistique: to answer your original question: because guido doesn't understand functional programming
13:02:40 <MostAwesomeDude> Phlogistique: To answer your original question: Python does not need anonymous functions because Python permits functions to be declared at any scope.
13:03:03 <mauke> MostAwesomeDude: that doesn't answer the question
13:03:16 <mauke> i.e. <Phlogistique> why would anyone define a language WITHOUT a proper support for anonymous functions :(
13:03:29 <MostAwesomeDude> mauke: Oh, *why*?
13:03:53 <MostAwesomeDude> Mu. Why are anonymous functions necessary for a language to be computationally feasible?
13:04:08 <mauke> what do you mean by "computationally feasible"?
13:04:34 <MostAwesomeDude> How about "as capable as C?" C gets along quite well without anonymous functions.
13:04:48 <MostAwesomeDude> Anyway, this isn't going to be a fruitful discussion, and I'm hungry.
13:05:36 <mauke> in C's case the reason is that C doesn't have first-class functions in the first place
13:05:45 <monochrom> COBOL does not need anonymous expressions because COBOL permits expressions to be named at any scope.
13:05:45 <mauke> and the reason for that is probably memory management
13:05:52 <ion> Or assembly. Or hard-wiring a bunch of transistors.
13:06:35 <mauke> monochrom: yeah, requiring local functions to be named would be like a language without ( ) in expressions
13:06:56 <monochrom> here is what anonymous expression means. "v = x + y*z" the y*z part is an anonymous expression. "tmp = y*z; v = x + tmp" now both expressions are given names: tmp and v.
13:07:04 <mauke> "if you want to compute something that goes against the natural order of precedence, you can always create a temp variable"
13:07:29 <xplat> transistors?  you wimps use transistors?  i just sprinkle dopants on a piece of silicon from the top of a ladder until it passes QA testing
13:07:54 <ion> I do that just once and *know* it’ll pass QA testing.
13:08:53 <monochrom> COBOL does not need anonymous expressions because COBOL permits "multiply y by z into tmp \n add x by tmp into v"
13:09:23 <mauke> wow, it permits variables to be declared at any scope
13:09:26 <mauke> this language is amazing
13:09:27 <Phlogistique> hey waiiiiiiiiit
13:09:44 <monochrom> so basically you can say all those FORTRAN fanboys are nuts
13:09:44 <Phlogistique> I go to a random IRC window, rant for one line, go on doing stuff
13:09:45 <mauke> (python doesn't have real scopes either)
13:09:50 <Phlogistique> and whan I come back...
13:09:59 <Phlogistique> *when
13:10:10 <monochrom> and when you come back, it's a COBOL advocacy channel :)
13:10:41 <mauke> Phlogistique: http://nedroid.com/2010/02/pop/
13:11:33 <monochrom> anyway, if you dare to bring up C, I would be more impressed if C didn't allow "v = x + y*z". you should just stick to assembly for your cause.
13:12:39 <xplat> there's no need to declare and name variables, machine code already lets you store values at any address in memory
13:13:13 <ion> Just store values in registers and hope there are enough of them.
13:13:29 <kapStokMuts> hello
13:13:33 <kapStokMuts> anybody here?
13:13:46 <xplat> naming variables and functions is just a shortcut for the lazy to avoid choosing a memory location to store things in
13:13:48 * ion looks at the user count. Not really.
13:13:51 <monochrom> in fact C allowing "f(a + b++, c + d++)" is probably a mistake already. why allow it, only to say no one knows what it does?
13:14:14 * kapStokMuts slaps ion around a bit with a large trout
13:14:17 <xplat> but it's more self-documenting to list the memory addresses explicitly
13:14:29 <kapStokMuts> do you know about parser combinators combined with monad?
13:14:40 <ion> Potentially.
13:14:46 <monochrom> slapping people is not a good start.
13:14:48 <xplat> it's clearer because you understand how everything's laid out and when swapping can occur
13:14:51 <kapStokMuts> haha
13:14:53 <kapStokMuts> sorry
13:15:36 <kapStokMuts> but I have a little function which parses a piece and tries to assign the result to a variable in a do construction
13:16:04 <kapStokMuts> But I get an error: cannot assign [((Int,Int), [Char])] towards var
13:16:15 <kapStokMuts> I thought Monad.Control would solve this for me
13:16:33 <mauke> you're not making any sense
13:16:41 <rwbarton> have you tried running your code through a Haskell compiler?
13:16:46 <kapStokMuts>  do
13:16:47 <kapStokMuts>    (mr, mc) <- parenthesised ((,) <$> natural <* symbol ',' <*> natural) <* spaces
13:16:56 <kapStokMuts> this errors with me
13:17:26 <kapStokMuts> yes of course I tried that
13:17:32 <carpi> could someone please tell me how are functions that are pure different from functions that have 'do' syntax in them? For instance, is it possible to do recursion in functinos that  have 'do' syntax?
13:17:35 <rwbarton> @type (<*)
13:17:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:17:46 <mauke> carpi: all functions are pure
13:17:50 <mauke> carpi: 'do' isn't special
13:18:15 <clsmith> hey all. what kind of templating library would you recommend for producing C files (so i just want to have function skeletons and slot in generated code, basically)
13:18:16 <monochrom> "cannot assign [((Int,Int), [Char])] towards var" is a case of translating "the spirit is willing but the flesh is weak" to Russian and then back to English and getting "the vodka is good but the meat rots"
13:18:19 <Axman6> whoever wrote OpenCLRaw i'm pretty sure has never heard of do notation
13:18:39 <kapStokMuts> ehmm... ??
13:18:47 <xplat> IO and ST are ... a little bit special.  but not because you use do notation with them.
13:18:49 <kapStokMuts> I see many examples on the interner that do work that way
13:18:56 <kapStokMuts> *internet
13:18:58 <mauke> kapStokMuts: start by showing us actual error messages
13:19:02 <mauke> kapStokMuts: and module names
13:19:08 <carpi> ah i think this is what rwbarton was alluding to earlier when he said my terminology was a bit off
13:19:11 <rwbarton> if you have a compiler that actually produces the message "cannot assign [((Int,Int), [Char])] towards var" I will eat some metaphorical rotten meat
13:19:19 <carpi> so all functions are pure..? 100% no exception?
13:19:27 <kapStokMuts>     Couldn't match expected type `[((Int, Int), [Char])]'
13:19:27 <kapStokMuts>                 with actual type `(t0, t1)'
13:19:27 <kapStokMuts>     In the pattern: (mr, mc)
13:19:27 <kapStokMuts>     In a stmt of a 'do' expression:
13:19:27 <kapStokMuts>         (mr, mc) <- parenthesised
13:19:27 <kapStokMuts>                       ((,) <$> natural <* symbol ',' <*> natural)
13:19:28 <kapStokMuts>                   <*
13:19:28 <kapStokMuts>                     spaces
13:19:36 <mauke> nice
13:19:44 <carpi> so whatever i can do with normal functions i can also do with functions with 'do' syntax
13:19:58 <mauke> kapStokMuts: what's the type of parenthesised?
13:19:59 <niteria> hmm, i thought fix was supposed to be (a -> a) -> (a -> a)
13:20:08 <mauke> carpi: functions don't have 'do' syntax
13:20:10 <rwbarton> it looks like his "monad" is [(a,[Char])]
13:20:18 <rwbarton> or \a->[(a,[Char])]
13:20:24 <niteria> on wiki it is (a -> a) -> a
13:20:28 <ion> carpi: “do” is just syntactic sugar for expressions using >>=.
13:20:30 <mauke> carpi: you can use 'do' in expressions, like [ ]
13:20:31 <xplat> fix is (a -> a) -> a
13:20:36 <kapStokMuts> yes ion
13:20:38 <kapStokMuts> what u say is right
13:20:45 <kapStokMuts> but i dont get it why it doesnt work in this case
13:20:54 <rwbarton> actually it doesn't look like that. no idea what you are doing
13:21:21 <mauke> kapStokMuts: what's the type of parenthesised?
13:21:37 <kapStokMuts> type Space = Map Pos Contents
13:21:37 <kapStokMuts> type Size = Int
13:21:37 <kapStokMuts> type Pos = (Int, Int)
13:21:37 <kapStokMuts> data Contents = CEmpty | CLambda | CDebris | CAsteroid | CBoundary
13:21:37 <kapStokMuts> parseSpace :: Parser Char Space
13:21:38 <kapStokMuts> parseSpace =
13:21:38 <kapStokMuts>  do
13:21:38 <rwbarton> oh, \a. (Char -> [(a,[Char])])
13:21:38 <kapStokMuts>    (mr, mc) <- parenthesised ((,) <$> natural <* symbol ',' <*> natural) <* spaces
13:21:38 <kapStokMuts>    -- read mr + 1 rows of mc + 1 characters
13:21:40 <kapStokMuts>    css <- replicateM (mr + 1) (replicateM (mc + 1) contents)
13:21:40 <kapStokMuts>    -- convert from a list of lists to a finite map representation
13:21:40 <kapStokMuts>    return $ L.fromList $ concat $
13:21:40 <kapStokMuts>            zipWith (\r cs ->
13:21:41 <kapStokMuts>            zipWith (\c d -> ((r, c), d)) [0..] cs) [0..] css
13:21:46 <rwbarton> *[Char]
13:21:52 <ion> Yikes
13:21:54 --- mode: ChanServ set +o mauke
13:21:54 <carpi> if there is no difference why is it that i can't call functions with 'do' syntax from functions that don't have 'do'(pure funcs)?
13:21:54 --- kick: kapStokMuts was kicked by mauke (kapStokMuts)
13:22:10 <rwbarton> carpi: has nothing to do with 'do'
13:22:15 <mauke> carpi: there is no such restrictions
13:22:16 <kapStokMuts> oke
13:22:19 <mauke> *restriction
13:22:51 <rwbarton> earlier you had an example like getGenerator = do { x <- newStdGen; return x }
13:22:56 <kapStokMuts> but there is no-one who can concretely tell me why this doesnt compile?
13:22:59 <rwbarton> that is equivalent to getGenerator = newStdGen
13:23:05 <mauke> kapStokMuts: what's the type of parenthesised?
13:23:10 <kapStokMuts> ehm
13:23:15 <kapStokMuts> wait
13:23:43 <kapStokMuts> Parser Char a -> Parser Char a
13:23:47 <kapStokMuts> is parenthesised
13:23:54 --- mode: mauke set -o mauke
13:24:00 <kapStokMuts> That just removes some brackets
13:25:02 <rwbarton> your issue appears to be that Parser is a type synonym
13:25:10 <rwbarton> rather than a newtype
13:25:12 <carpi> thanks for the clarification.. im trying to write a function to pick 'n' random elements from a list with length '>n'.. but since all the System.Random functions have 'IO a' return types.. i can't seem to include them in my getRandomElement funcion
13:25:31 <mauke> carpi: sure you can
13:25:41 <kapStokMuts> nothing goes wrong in the type Parser rwbarton
13:25:41 <mauke> carpi: you just can't magically turn 'IO x' into 'x'
13:26:07 <rwbarton> kapStokMuts: I encourage you to consider what I wrote.
13:26:15 <kapStokMuts> oke...
13:27:05 <carpi> mauke: i think i will try again.. keeping in mind what you said aabout pure funcions
13:27:51 <rwbarton> carpi: your getRandomElement function will need to have IO in its type too, since it perform IO actions
13:28:06 <rwbarton> (better: it is a function which returns an IO action)
13:28:34 <kapStokMuts> yeah oke but then why does it complain about assigning the parenthesised expression
13:28:42 <kapStokMuts> it doesnt complain about the return type
13:36:14 <Veinor> is there any way to speed up cabal's dependency-resolving step?
13:36:30 <monochrom> faster computer
13:36:38 <kapStokMuts> use pep
13:37:18 <Veinor> i'm compiling some stuff that depends on snap and the dependency resolution always seems to take forever
13:38:07 <monochrom> yikes. but yes the input size is big for that.
13:38:09 <c_wraith> Veinor: try using cabal build instead of cabal install?
13:38:14 <dmwit> You can "cabal configure" once, then "cabal build" instead of "cabal install".
13:38:37 <c_wraith> as dmwit points out, configure is the step that does dependency resolution
13:38:41 <Veinor> ah
13:38:44 <Veinor> yeah, that's much faster
13:39:03 <mroman> If foo >>= bar works, why doesn't do { foo; bar}?
13:39:10 <monochrom> "cabal install" repeats "cabal configure" "cabal build" etc
13:39:18 <c_wraith> mroman: because do { foo; bar} is foo >> bar
13:39:24 <Veinor> @undo foo >>= bar
13:39:25 <lambdabot> foo >>= bar
13:39:27 <Veinor> er
13:39:30 <Veinor> @do foo >>= bar
13:39:30 <lambdabot> do { a <- foo; bar a}
13:39:46 <mroman> i.c
13:39:47 <alistra> > 1 >>= 1
13:39:48 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
13:39:48 <lambdabot>    arising from a u...
13:39:53 <dmwit> "cabal install" does much, much more work than "cabal configure".
13:40:03 <dmwit> "cabal configure" does not do dependency resolution at all.
13:40:15 <mauke> > (1 >> 1) 1
13:40:16 <lambdabot>   1
13:40:18 <Veinor> after i cabal build, how do i actually get ghc to see the package?
13:40:34 <monochrom> cabal haddock, cabal copy, cabal register
13:40:37 <dmwit> cabal register
13:40:45 <c_wraith> or cabal install --only
13:41:16 <rwbarton> > (1 >>= 1) 1
13:41:17 <lambdabot>   1
13:41:19 <rwbarton> working fine here.
13:41:21 <monochrom> there is an "--only"?
13:41:24 <c_wraith> yes
13:41:28 <Veinor> oh, neat
13:41:43 <Veinor> i don't see --only in install --help
13:41:54 <monochrom> well, if it exists, it certainly is undocumented
13:42:09 <c_wraith> I had to learn of its existence from dcoutts.
13:42:53 <mroman> @undo do { foo; bar; baz}
13:42:53 <lambdabot> foo >> bar >> baz
13:43:17 <dmwit> ?undo do { Just x <- foo; bar x
13:43:17 <lambdabot>  Parse error at end of input
13:43:20 <dmwit> ?undo do { Just x <- foo; bar x }
13:43:20 <lambdabot> foo >>= \ a -> case a of { Just x -> bar x; _ -> fail ""}
13:43:47 <dmwit> ?undo do { Just x <- foo; bar a }
13:43:47 <lambdabot> foo >>= \ b -> case b of { Just x -> bar a; _ -> fail ""}
13:43:55 <dmwit> oh ho ho
13:43:58 <dmwit> Too clever for me. =)
13:44:35 <niteria> wow, haskell is ideal denotational semantics interpreter
13:45:03 <monochrom> yes
13:45:15 <niteria> I just straightforwardly rewrote my homework assignment to haskell
13:45:31 <mroman> @type (>>)
13:45:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:46:05 <mroman> That means, that you can not write a (Foo a) >> (Foo b) = Foo $ a+b
13:46:22 <mroman> because that does not change the type from a to b
13:46:45 <c_wraith> mroman: it's true, that's not a valid implementation of >>
13:47:11 <monochrom> import Prelude hiding ((+)); (+) = flip const  :)
13:47:18 <rwbarton> data Foo a = Foo Integer
13:47:50 <mroman> Is it possible to write a monad that collects functions in a list?
13:47:51 <mroman> eg
13:48:00 <mroman> do { foo; bar; baz} returns MyMonad [foo,bar,baz]
13:48:27 <Philippa> not really as such, because monads allow bar or baz to be dependent on foo
13:48:45 <Philippa> also some of the monad laws aren't quite compatible with that
13:48:54 <dmwit> Why would you prefer "do { foo; bar; baz }" to "[foo, bar, baz]"?
13:48:54 <Philippa> you can write one that collects all the run-time calls in a list though
13:48:57 <rwbarton> a Writer monad can give you something like that, though
13:48:59 <Philippa> that's just Writer
13:49:04 <Philippa> rwbarton: snap!
13:49:17 <monochrom> yesod
13:49:22 <mroman> dmwit: I wouldn't.
13:49:35 <mroman> But it seems to me that Monads are oddly limited
13:49:57 <mauke> yeah, to being monads
13:49:58 <Philippa> if you want to just embed a full-blown interpreter, you can do it
13:49:58 <dmwit> Monads are limited, but it's not at all odd.
13:50:22 <Philippa> monads are good precisely because they're not that - they're a useful middle point between that and nothing that looks remotely like embedding a language
13:50:51 <mroman> Personally, I'd like (>>=) to be m a -> (m a -> m b) -> m b and (>>) to be m a -> m a -> m a ;)
13:51:02 <carpi> how do you add an element to a list recursively in an action that has a 'do' construct?
13:51:09 <rwbarton> mroman: What you want is not called Monad.
13:51:14 <dmwit> ($) is m a -> (m a -> m b) -> m b
13:51:17 <carpi> in such an action do i "return []" or simply "[]"
13:51:17 <dmwit> Well, flip ($)
13:51:29 <rwbarton> actually, hang on, I don't know what you want.
13:51:31 <mroman> I know @ flip ($)
13:51:48 <mauke> carpi: I recommend you stop using 'do'
13:52:00 <mroman> I'm still not able to grasp why Monads are defined they way they are.
13:52:02 <Philippa> carpi: return []
13:52:12 <Philippa> if you're having type problems, it's because lists also have a Monad instance
13:52:38 <Philippa> mroman: think of >>= as overloading let
13:52:46 <dmwit> mroman: First, people programmed up a bunch of useful types and combinators for those types. Then they noticed that many of those combinators had a very similar flavor.
13:52:50 <Philippa> it turns out that corresponds to a useful intermediate language for compilers
13:53:00 <dmwit> mroman: So they abstracted that pattern. Monad is that abstraction.
13:53:03 <carpi> mauke: but its impossible to write the function any other way because some of the functions used in the function im writing return values of type IO a
13:53:06 <Philippa> you break that property in a variety of ways with most of the alternatives
13:53:14 <mauke> carpi: wrong
13:53:17 <Philippa> some of the alternatives are still useful: they tend to end up in other type classes
13:53:18 <mauke> carpi: 'do' is not magic
13:53:31 <Axman6> hmm, if I have something of type IO (Either e a), how do I make it use ErrorT? apparently I can't access the ErrorT constructor
13:53:55 <ski> carpi : do you have any specific code which you have trouble with ?
13:53:57 <Axman6> ah, my mistake, forgot to export it as ErrorT(..)
13:54:06 <hpaste> Carpi pasted “Stuck” at http://hpaste.org/55345
13:54:12 <Philippa> Axman6: you're probably going to have to manually pattern-match and translate to ErrorT?
13:54:14 <Philippa> and that, yes
13:54:49 <mauke> carpi: 'lst == []' better written as 'null lst'
13:54:51 <carpi> ive been re writing and re orienting and re organizing that piece of code for the past 3 hours.. nothing seems to work : (
13:54:52 <Philippa> carpi: if your last line of a do is a pure value, you need to put return around it
13:55:10 <Philippa> mauke: the perfect is the enemy of the good, give the beginner a break
13:55:25 <mauke> carpi: you're missing a 'return'
13:55:39 <carpi> mauke: a return in the last line?
13:55:43 <mauke> yeah
13:55:43 <mroman> But why does >> need to do a 'type change'?
13:56:09 <dmwit> (>>) is not primitive.
13:56:13 <Philippa> mroman: because the two things being sequenced might have completely different return values
13:56:18 <rwbarton> "x >> y" means "perform action x and then perform action y and throw away the result of x and return the result of y".
13:56:19 <dmwit> m >> m' = m >>= \_ -> m'
13:56:28 <rwbarton> so you can work out its type from that.
13:57:00 <dmwit> (>>=) and return are primitive.
13:57:11 <Axman6> I'm trying to write a more sane OpenCL binding at the moment, and luckily so far the type system has made the conversion from using IO (Either ErrorCode a) everywhere to OpenCL a = ErrorT ErrorCode IO a quite easy
13:57:12 <Philippa> for example, I might want to do some IO action completely ignoring its error code because I'm a bad coder, and then something else with a return value I care about
13:57:41 <mroman> Philippa: But they also could yield the same types.
13:57:48 <carpi> if add "return" to the last line, could you please tell me how does haskell know that it has to use IO type's implementation of "return"?
13:57:56 <carpi> s/if/"if i"
13:57:59 <Philippa> mroman: nothing forces a and b to be different types, they're just allowed to
13:58:01 <mauke> carpi: from the surrounding type context
13:58:04 <Philippa> it could be that a = b
13:58:14 <mroman> Philippa: How?
13:58:17 <mauke> carpi: also known as return type based overloading
13:58:21 <dmwit> carpi: By looking at the rest of the do block, and observing that the randomRIO function uses IO.
13:58:24 <Philippa> mroman: "just so"
13:58:27 <mroman> GHC just complains that it expectd Foo b and not Foo a
13:58:44 <Philippa> well then, we need to see what you're actually trying to do, don't we?
13:58:53 <hpaste> ski annotated “Stuck” with “using `return'” at http://hpaste.org/55345#a55346
13:58:58 <mroman> (Foo a) >> (Foo b) = Foo $ a+b
13:59:01 <mroman> is a type error.
13:59:04 <ski> carpi : ^
13:59:14 <rwbarton> what's "Foo"
13:59:18 <Philippa> a + b forces them to be the same type
13:59:21 <mroman> data Foo a = Foo a
13:59:24 <carpi> ah okay.. but that is the case only when i don't provide a signature.. if i do provide a signature then any ambiguity is removed.. yes?
13:59:25 <Philippa> :t (+)
13:59:26 <lambdabot> forall a. (Num a) => a -> a -> a
13:59:27 <dmwit> mroman: Implementing and using (>>) are different tasks.
13:59:29 <Philippa> see?
13:59:30 <mroman> Philippa: Yes.
13:59:44 <mroman> But as you said, a could be b
13:59:47 <rwbarton> @type (>>=)
13:59:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:59:53 <Philippa> yes, but that doesn't mean you can /require/ them to be the same
13:59:55 <rwbarton> @type (>>)
13:59:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:59:57 <dmwit> mroman: When implementing a type with variables in, you don't get to assume anything about the variables; when using a type with variables in, you can assume anything you like about the variables.
14:00:03 <ski> carpi : the two versions there do exactly the same thing, one is using the `do' syntactic sugar, the other calls `(>>=)' directly, instead
14:00:30 <Philippa> less of the overload factor, folks? I've got this one
14:00:44 <Philippa> hive mind echoes are scary!
14:01:27 <carpi> ski.. thanks.. much. feel like now is making more sense )
14:01:51 <mroman> Ic @require
14:02:07 <monochrom> the only way to win is not to answr
14:02:16 <ski> carpi : note that there's nothing magic about `do' -- it's just sugar which expands to calls to `(>>=)'
14:03:14 <KirinDave> ski: Sugar is a kind of magic. :)
14:03:14 <mroman> on the other hand
14:03:20 <ski> carpi : in the latter version, you just work out the types in the normal way, using `return :: a -> IO a',`(>>=) :: IO a -> (a -> IO b) -> IO b' and `randomRIO :: Random a => (a, a) -> IO a'
14:03:27 <mroman> (Foo a) >> (Foo b) = Foo $ (a,b) is also invalid.
14:03:52 <ski> KirinDave : not really. it's just a *local* code transformation
14:04:05 <Philippa> mroman: now we need to see what a Foo is, I suspect
14:04:11 <KirinDave> ski: Sufficiently advanced local transformations are indistinguishable from magic.
14:04:29 <mroman> Philippa: data Foo a = Foo a
14:04:49 <ski> (otoh, global transformations is in some sense more magic)
14:05:02 <Philippa> okay, that's not valid because the return type has to be that of Foo b
14:05:11 <Philippa> :t (>>)
14:05:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:05:15 <mroman> Yes.
14:05:29 <ski>   (>>) :: Foo a -> Foo b -> Foo b  -- in this case
14:05:30 <mroman> Hm.
14:05:38 <Philippa> if you want to do what I suspect you do, you need to build a tree instead using GADTs
14:05:54 <ski> (mroman uses GADTs ?)
14:06:24 <mroman> I know what they are, but currently no ;)
14:06:39 <Philippa> data FreeMonadish a where {Return :: a -> FreeMonadish a; Bind :: FreeMonadish a -> (a -> FreeMonadish b) -> FreeMonadish b}
14:06:46 <Philippa> does that look something like what you want?
14:06:52 <mroman> If we assume, that b has the type (a,Int)
14:06:53 <mroman> then
14:07:01 <Philippa> then it doesn't work for all b
14:07:08 <mroman> it goes boom, yes
14:07:09 <Philippa> the type says it works forall b
14:07:38 <mroman> That's what I meant with 'odd limitation' ;)
14:07:41 <Philippa> worse, you'd be trying to return a (a, (a, Int))
14:07:56 <dmwit> wut
14:08:03 <Philippa> yeah, but it's not odd at all. It's what makes it possible to build things reliably out of Monads
14:08:25 <mroman> Yes.
14:08:25 <Philippa> there are alternatives if you want to limit a and b, but I can't remember seeing any that limit only b
14:08:26 <mroman> But
14:08:27 <kmc> how does it work, when a thread created in C code which GHC has no knowledge of, suddenly calls a function exported from Haskell?
14:08:53 <mroman> It makes the usage of the syntactic sugar of do bound also to the limitations of Monads
14:08:56 <Philippa> kmc: how does calling Haskell from C work in general? Fire up a fresh RTS?
14:09:13 <kmc> no, i don't think you get a completely fresh RTS
14:09:18 <mroman> And Monads are (at least in my opinion) rather complicated.
14:09:21 <Philippa> mroman: well, do is nice because it gives us those overloaded let statements, but it's not directly relevant
14:09:31 <KirinDave> mroman: They're so simple they're complicared
14:09:35 <kmc> mroman, monads are not complicated -- they are difficult because they are simple and abstract
14:09:35 <KirinDave> mroman: see also pointers
14:10:01 <Philippa> KirinDave: bad analogy, pointers make it much easier to point bullets at your feet :p
14:10:08 <dmwit> You, too, can understand the purpose behind monads, if you put your mind to it.
14:10:11 <kmc> difficulty arising from complexity vs difficulty arising from abstract simplicity
14:10:16 <KirinDave> Philippa: Value judgements left to the reader ;)
14:10:16 <dmwit> Even complicated things yield to sustained effort.
14:10:20 <roconnor> pointers make it much easier to alias pointers
14:10:28 <kmc> Philippa, if you're writing a C program which uses a Haskell library, you're supposed to call a RTS function during your program startup to initialize the RTS
14:10:46 <Philippa> kmc: what're the C types involved?
14:10:48 <kmc> i think this is the one RTS you get
14:10:50 <kmc> hmm?
14:10:53 <bwright> Is there a special name given to an empty tuple ()?
14:10:59 <dmwit> bwright: unit
14:10:59 <kmc> bwright, "unit"
14:10:59 <Philippa> bwright: sometimes "unit"
14:11:04 <mroman> A 'State Monad' could be achieved way easier if >>= and >> were defined otherwise
14:11:08 <bwright> Alright thanks.
14:11:14 <Philippa> mroman: example?
14:11:25 <mroman> 'value passing'
14:11:28 <Philippa> what's your alternative structure?
14:11:48 <Philippa> carry on?
14:11:48 <monochrom> kmc: http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
14:11:58 <Philippa> (have you actually tried doing this, for example?)
14:12:20 <FliPPeh_> Soo, I'm trying to catch a RecSelError
14:12:24 <FliPPeh_> But it won't be catched.
14:12:28 <FliPPeh_> What even?
14:13:06 <kmc> "When C calls Haskell, the GHC RTS creates a fresh bound Haskell thread associated with the calling OS thread, to run the called Haskell"
14:13:18 <kmc> ok
14:13:18 <ique> @pl (\pt -> map (/divby) $ typ pt)
14:13:18 <lambdabot> (line 1, column 14):
14:13:18 <lambdabot> unexpected "/"
14:13:19 <lambdabot> expecting lambda abstraction or expression
14:13:36 <kmc> monochrom, this means the calling OS thread obtains a GHC Capability?
14:13:38 <ique> that's not how it works apparently :P
14:13:40 <monochrom> yes. and presumably the RTS is already properly inited because you already did hs_init and hs_add_root or something
14:14:05 <monochrom> yes. or at least, once in a while it does.
14:14:08 <mroman> Phillipa: flip ($) actually
14:14:08 <ski> @pl (\pt -> map (/divby) $ typ pt)
14:14:09 <lambdabot> map (/ divby) . typ
14:14:19 <kmc> only once in a while?
14:14:35 <mroman> You could allow do to pass state always to the functions as values.
14:15:10 <kmc> mroman, did you write a module which defines (>>=) and (>>) as you want them?
14:15:14 <ski> mroman : i'm not sure how you mean. could you try to write a simple (but complete) example ?
14:15:18 <Philippa> you can, but I don't find flip ($) is anywhere near as useful as a Monad instance
14:15:20 <dmwit> ?tell MostAwesomeDude Apparently the thing I was thinking of was http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html which is not on Hackage (sorry for the misdirection).
14:15:20 <monochrom> depends on how many forkIO's and forkOS's you do
14:15:20 <lambdabot> Consider it noted.
14:15:24 <ique> ski: what did you do different? can't see :S
14:15:27 <Philippa> there's no structure to show what's State
14:15:42 <kmc> monochrom, doesn't an OS thread need to acquire a Capability if it wants to execute Haskell code?
14:15:45 <ski> ique : you had some strange control character pasted right after the `divby'
14:16:01 <ique> ski: oh i see! thanks :)
14:16:32 <monochrom> yes sure. but an OS thread can also be stuck in C code and some other OS thread takes over the capability to run some other haskell code
14:16:41 <kmc> yeah
14:16:50 <FliPPeh_> Alright, today I learned the difference between "return" and "Control.Exception.evaluate"
14:17:03 <kmc> if C code calls Haskell code, and the entry point discovers that the current OS thread already holds a Capability
14:17:22 <kmc> this can only happen because a "foreign import unsafe" function erroneously called back into Haskell code
14:17:24 <kmc> right?
14:17:27 <ique> @pl (\p -> m*(p pla))
14:17:27 <lambdabot> (m *) . ($ pla)
14:17:28 <mroman> http://codepad.org/7DoCp7Jj
14:17:38 <mroman> but that looks way ugly due to lacking syntactic sugar :)
14:17:38 <monochrom> oh, that's devious, but yes
14:18:26 <kmc> so why does calling back into Haskell from an unsafe foreign import cause segfaults etc
14:18:32 <kmc> shouldn't it be easy enough to detect this way
14:18:35 <kmc> or am i missing something
14:19:01 <kmc> (i expect only a deterministic runtime error rather than segfaults; nothing more)
14:19:02 <monochrom> I don't know. but there may be a gazillion other data invariants being violated.
14:19:18 <ski> mroman : is there any point in having `a' and `t' as arguments in `class VPc x a t' ?
14:19:22 <Philippa> mroman: what syntactic sugar would you want? (also, too much code for me to skim, want to give me a walkthrough? Not that that's a good sign)
14:19:46 <kmc> you seem to have a whole school of fish
14:20:06 <dmwit> Lots of weird choices in this code. Why have a typeclass with only one instance? Why define a new tuple type (VPt)? Why have so many different combinators (can't some be derived from others)?
14:20:48 <kmc> is this a finally-tagless EDSL?
14:21:05 <ski> dmwit : for "so many different combinators", maybe "\"OO\" thinking" ?
14:21:12 <mroman> Philippa: They basically just pass the state in a Tuple as arguments to other functions
14:21:54 <Philippa> mroman: so manual state passing? I don't see how that would support better sugar than a monad, and a monad can do everything manual passing can do
14:22:18 <Philippa> not to mention a pile of other things, because it's possible to be polymorphic in which Monad you're using
14:22:18 <kmc> maybe you could name all those fish operators
14:22:26 <kmc> then we could understand the code better
14:23:07 <ski> alternatively, for expository purposes, remove all but the most important ones
14:23:15 <mroman> instead of baz (foo (bar 1) 2) 3 you just write bar 1 ~> foo 2 ~> baz 3
14:23:15 <rwbarton> I think the point is supposed to be this main = ... example at the bottom
14:23:17 <dmwit> I'm not sure I see the reason for VPIoT's existence, either.
14:23:26 <ski> (like e.g., the ones actually *used* in the example)
14:23:38 <kmc> i was kind of hoping for a small example with alternative definitions of (>>=) and (>>)
14:23:57 <kmc> the current Monad class is essentially 3 lines of code
14:24:01 <kmc> (setting aside some uninteresting parts)
14:24:13 <kmc> if your alternative is many dozens of lines, that's already a mark against
14:24:30 <mroman> >>= is afaik what I defined as ~$>
14:24:39 <mroman> (~$>)    :: x a t -> (a -> t -> x a t) -> x a t
14:24:47 <monochrom> a system so complicated that there is no obvious meaning
14:24:53 <Philippa> ~> looks like something I could occasionally use having, but I wouldn't use it for state
14:24:59 <monochrom> vs a system so simple that there is obviously no meaning :)
14:25:02 <ski> mroman : `(>>=)' is more general than that
14:25:30 <mroman> but not in the good way ;)
14:25:33 <Philippa> mmm. Remember what I said about overloading let? (>>=) does that for any language that fits a small number of sensible rules
14:25:36 <ski> (thinking about the insistance to use the same `t')
14:25:51 <Philippa> including languages built out of other languages
14:26:09 <mroman> if do would translate >>= to ~$>
14:26:12 <mroman> you could just write
14:26:17 <rwbarton> "push :: ... => [a] -> (VPIoT a q) -> VPt [a] (VPIoT a q)" -- this looks State'y
14:26:29 <Philippa> I pretty much build systems by picking the right mixture of Monads and Applicatives and so forth to make it easy to express what I intended
14:26:33 <mroman> do { push 5; push 4; pop; }
14:26:34 <rwbarton> but I don't see the actual State >>= logic anywhere
14:26:45 <holla> @run reverse[1,2,3]
14:26:45 <lambdabot>   [3,2,1]
14:26:49 <mroman> with push beeing what it is right now.
14:26:59 <mroman> A simple function which does a++[t]
14:27:25 <mroman> rwbarton: The actual 'State Monad' works different.
14:27:32 <mroman> Due to the definition of a monad.
14:27:54 <Philippa> I often define monads that're wrappers around State that do more specific things with the state - a stack monad'd work fine
14:28:04 <mroman> Yes.
14:28:16 <mroman> I'm able to use the state monad to implement a stack with it.
14:28:17 <Philippa> normally I don't need it because Reader is good enough
14:28:21 <mroman> That's not the problem.
14:28:25 <mroman> I know how to use Monads.
14:28:49 <Philippa> so what's the problem? I mean, I sometimes have cases where I need something more general than Monad, sure
14:29:02 <bwright> If I wanted to get a really strong understanding of the standard prelude and Data.* (and potentially other standard libraries) is there a better way then simply reading the source?
14:29:11 <mroman> I wouldn't be able to implement a 'Stack Monad' from scratch.
14:29:23 <Philippa> (relative monads and monads on some subcategory of Hask instead of all of it, applicative functors that may or may not be on Hask...)
14:29:24 <dmwit> ?let push x = modify (x:); pop = do {x:rest <- get; put rest; return x}
14:29:25 <lambdabot>  Defined.
14:29:32 <dmwit> :t do { push 5; push 4; pop }
14:29:33 <lambdabot> forall (m :: * -> *) b. (MonadState [b] m, Num b) => m b
14:29:36 <dmwit> mroman: ?
14:29:37 <mroman> because you cant just do (a++[t]) with a monad
14:29:48 <rwbarton> bwright: try to implement the prelude functions yourself.
14:30:01 <Philippa> well no, you have to pass the rest around too. I can write it myself pretty easily, but I suspect I have a different angle on it from you
14:30:11 <Philippa> remember that FreeMonadish type I showed you?
14:30:14 <rien> bwright: the 99 haskell problems are pretty good before they get too mathematical
14:30:32 <dmwit> :t runState
14:30:33 <lambdabot> forall s a. State s a -> s -> (a, s)
14:30:42 <mroman> As far as I understand it.
14:30:45 <rwbarton> as far as I can tell this paste is a really obfuscated version of composing a lot of functions together
14:30:45 <dmwit> > runState (do { push 5; push 4; pop }) []
14:30:47 <lambdabot>   (4,[5])
14:30:49 <ski> bwright : also try to implement functions in `Data.List'
14:30:49 <mroman> The State Monad chains functions together.
14:30:55 <mroman> In some magic way.
14:31:00 <Philippa> mroman: if you added Push and Pop constructors to that type, could you write an interpreter for it?
14:31:02 <rwbarton> much like (>=>) for Kleisli (State whatever)
14:31:06 <Philippa> similarly, if you added Get and Put?
14:31:18 <Philippa> mroman: it's entirely unmagical, you just follow the definition
14:31:21 <mroman> interpreter for what?
14:31:33 <rwbarton> except the State type can change I guess
14:31:34 <Philippa> the language with an AST defined by that modified type
14:31:51 * ski isn't sure mroman is ready to think about interpreting DSLs, yet
14:32:07 <dmwit> ?let op (+) = liftM2 (+) pop pop >>= push
14:32:08 <lambdabot>  Defined.
14:32:11 <mroman> No :)
14:32:18 <rwbarton> do these weird names stand for anything?
14:32:19 * Philippa suspects it's easier than writing a shallow interpretation without knowing that's what you're doing
14:32:21 <dmwit> > runState (do { push 5; push 4; op (+) }) []
14:32:21 <lambdabot>   Ambiguous occurrence `op'
14:32:22 <lambdabot>  It could refer to either `L.op', defined at <loc...
14:32:27 <dmwit> > runState (do { push 5; push 4; L.op (+) }) []
14:32:29 <lambdabot>   ((),[9])
14:32:45 <mroman> If you mean an interpreter for a language like
14:32:52 <mroman> "PUSH 4; PUSH 2; ADD" sure
14:33:01 <mroman> I could implement that, yes.
14:33:10 <Philippa> okay. Can you go from a linear sequence to an abstract syntax tree?
14:33:23 <Philippa> data Sum = Val Int | Add Sum Sum | Mul Sum Sum ?
14:33:38 <Philippa> Mul (Add (Val 1) (Val 2)) (Val 3) ?
14:34:03 * ski tries futilely to recall which was which of "shallow embedding" and "deep embedding"
14:34:22 <Philippa> ski: deep has concrete terms for the syntax and an interpreter
14:34:23 <mroman> I'd rename Sum to Expression
14:34:29 <mroman> but yeah, I understand that.
14:34:39 <Philippa> okay. FreeMonadish is just one of those
14:34:44 <Philippa> Return is one command, Bind is another
14:34:56 <Philippa> Bind happens to take a Haskell function as one of its inputs
14:35:31 <Philippa> and all monads in Haskell can be built that way if you want to
14:37:20 <Philippa> does that make sense? Could you use some extra code to demonstrate?
14:37:37 <Philippa> (it'll take me a couple of minutes to dig up, but I actually have code for this lying around somewhere including an implementation of State)
14:40:20 <mroman> You wan't to interpret that with a monad?
14:40:56 <Philippa> no, I want to build a monad where (>>=) = Bind and return = Return, and runMonad is the interpreter
14:41:23 <Philippa> rather, I've already built it :-) Would it help to see the code?
14:41:28 <mroman> Yes
14:41:44 <Philippa> okay, give me a few
14:41:45 <mroman> http://codepad.org/2h9w2gFP <- The interpreting stuff shouldn't be the problem.
14:43:44 <ski> rwbarton : btw, `putStrLn . show = print'
14:43:48 <holla> Is there a function to turn a PriorityQueue.fingertree into a list?
14:44:42 <Philippa> http://hpaste.org/55347 <- identity monad in that style
14:44:58 <Philippa> Give me a mo, I don't have an implementation for State handy so I'll have to knock one together :-)
14:45:44 <ski>   Data.FingerTree.PSQueue.toList :: (Ord k, Ord p) => PSQ k p -> [Binding k p]  -- ?
14:48:32 <hpaste> Philippa pasted “State monad” at http://hpaste.org/55348
14:48:39 <Philippa> done
14:49:04 <Philippa> mroman: do those two chunks of code make any sense?
14:49:22 <Philippa> I missed out the Monad instances, they're both return = Return and (>>=) = Bind though
14:50:38 <Philippa> also: do you understand what the Monad class enables?
14:52:25 <mroman> runState takes the original state and result
14:52:29 <mroman> a new state
14:52:35 <mroman> and packs that in a tupel
14:53:21 <ski> yes
14:53:22 <Philippa> runState returns the new state and the result in a tuple, yes
14:54:08 <Philippa> but what it takes is a "State computation" or a "State program" and an initial state
14:55:54 <mroman> c2 is the result of f r1 with r1 being the result of c1
14:56:17 <Philippa> yeah
14:56:22 <mroman> the Bind is a bit confusing ;)
14:56:33 <Philippa> so c2 is the computation generated by evaluating (f r1)
14:56:45 <mroman> which is then used as the new state
14:56:46 <Philippa> it is, but it's a lot better than the "uninterpreted" version
14:56:53 <mroman> while the old state is placed as the result?
14:57:03 <mroman> in runState c2 s1
14:57:37 <Philippa> there you're running c2 with the state that resulted at the end of c1
14:57:37 <Philippa> so c1 -state> c2
14:57:48 <dyn> hi
14:58:23 <Philippa> hi dyn. Just helping explain the State monad via an implementation using GADTs - code's at http://hpaste.org/55348
14:58:42 <ByronJohnson> mroman: You could, for example, define "data SomeState = SomeState {_counter :: Integer, _sname :: String}", and then a "State computation" "renameAndReturnTheCounter :: String -> State SomeState Integer; renameAndReturnTheCounter name = state $ \theSomeState -> (_counter theSomeState, theSomeState') where theSomeState' = set sname name $ theSomeState"
14:59:17 <dyn> Philippa: i still have a fewhundred pages till the State monad :)
14:59:28 <ByronJohnson> mroman: The {} is record syntax, and "set" is from fclabels - http://hackage.haskell.org/package/fclabels
14:59:29 <Philippa> dyn: No worries :-)
15:00:02 <Philippa> ByronJohnson: that wouldn't actually work with this implementation
15:00:04 <mroman> Makes sense, yes.
15:00:09 <Philippa> but sure
15:00:11 <dyn> currently i'm trying to rewrite init to return a Maybe value.. and stumbling with this: init' (x:xs) = Just [x] : init' xs  (other cases omitted)
15:00:12 <mroman> @Bind
15:00:15 <lambdabot> parse error (possibly incorrect indentation)
15:00:37 <Philippa> mroman: do Get, Put and Return make sense?
15:00:46 <Philippa> Bind is definitely the nastiest of the four :-)
15:01:32 <mroman> Get sets the result to the current state
15:01:45 <dyn> can someone point out my type error above? :|
15:01:53 <Philippa> :t init
15:01:54 <lambdabot> forall a. [a] -> [a]
15:01:59 <mroman> and put replaces the state and "emptying" the result
15:02:27 <dyn> Philippa: mine does [a] -> Maybe [a]
15:02:32 <Philippa> dyn: you have [x], which is a list containing x, but : wants an item on the left?
15:02:48 <Philippa> mroman: yep, good!
15:03:00 <dyn> Philippa: i was trying to do a concat on two (Maybe a) values
15:03:05 <dyn> like Just 2 : Just 3
15:03:08 <mroman> @undo do { x <- get; return x}
15:03:09 <lambdabot> get >>= \ x -> return x
15:03:15 <ski> dyn : you need to check whether your recursive call returns `Nothing', or something of form `Just ys'
15:03:23 <mroman> >>= is bind
15:03:28 <mroman> (how do you call >>?)
15:03:34 <psionski> > init [1,2,3]
15:03:35 <lambdabot>   [1,2]
15:03:37 <mroman> (and wheres >>?)
15:03:37 <dyn> ski: it does, actually.. I even enforced the type
15:03:37 <ski> dyn : hint : what should you do when the recursive call returns `Nothing' ?
15:03:48 <mroman> so
15:03:52 <mroman> we have
15:03:56 <Philippa> mroman: the ordinary version of the monad, btw, is equivalent to "fusing" this one. The only thing you can do with a State s a is runState, so the constructors get replaced with the branches in runState they correspond to
15:03:57 <dyn> ski: i'd think Just 2 : Nothing makes sense, doesn't it?
15:04:06 <ski> dyn : it doesn't make sense
15:04:11 <mauke> dyn: Nothing is not a list
15:04:14 <Philippa> >> has a default implementation. l >> r = l >>= \_ -> r
15:04:18 <ski> `Nothing' is not a list : the thing to the right of `:' must be a list
15:04:26 <Philippa> so I don't need to write >>, it's enough to write >>=
15:04:34 <dmwit> :t (:)
15:04:35 <lambdabot> forall a. a -> [a] -> [a]
15:04:36 <dyn> mauke: thought it's fine as a Maybe [a]
15:04:46 <mauke> dyn: Maybe [a] is not a list either
15:04:56 <ski> dyn : you either want to use a `case', or you want to define a helper function which pattern-matches on the result of the recursive call
15:04:57 <Philippa> dyn: you've got your types inside-out :-)
15:04:59 * dyn nods to dmwit 
15:05:01 <dmwit> dyn: Yes, "Nothing" is a perfectly good "Maybe [a]", but (:) doesn't operate on "Maybe [a]"s.
15:05:08 <mroman> get >>= \x -> return x can be translated to those GADTs, right?
15:05:22 <mroman> (Bind Get (Return .... or so?
15:05:30 <dyn> dmwit: yeah, I see your point.. hmn
15:05:39 <Philippa> mroman: yes, get = Get, (>>=) = Bind etc and it'll just work
15:05:40 <ski>   Bind Get (\x -> Return x) -- yes
15:05:45 <mroman> Bind (Get) (\x -> Return x) ?
15:05:49 <mroman> \o/
15:06:10 <Philippa> or even Bind Get Return
15:06:37 <mroman> Doesn't Return require an argument?
15:06:42 <mroman> (Return *r*)?
15:06:43 * ski . o O ( "eta-reducing the world !" )
15:06:58 <jessopher> not if you go pointless
15:07:03 <Philippa> mroman: no, Return has the same type as \x -> Return x
15:07:17 <ski> mroman : yes, but any time you have `\x -> (...) x', where `...' doesn't mention `x', that can be simplified to just `...'
15:07:32 <ski> this is known as "eta-reduction"
15:07:43 <dmwit> > let init' xs = guard (not (null xs)) >> return (init xs) in init' [1..5] :: Maybe [Int] -- not really a proposal for an implementation, dyn, just a joke
15:07:44 <lambdabot>   Just [1,2,3,4]
15:07:55 <mroman> Ic.
15:08:12 <ski> mroman : e.g. `\xs -> length xs' is the function that, given a list (call it `xs') returns the length of `xs' -- this is the same as the function `length' itself
15:08:24 <mroman> runState $ Bind (Get) (Return)
15:08:29 <mroman> oh
15:08:30 <dmwit> dyn: Anyway, the others here are giving you good advice: use a case statement to inspect the value that your recursive call returns.
15:08:32 <mroman> plus initial State
15:08:39 <mroman> runState (Bind (Get) (Return)) 0
15:08:41 <ski> similarly, `\x -> Return x' is the same function as `Return'
15:08:57 <mroman> (s1,r1) = runState Get 0
15:09:02 <mroman> which is
15:09:06 <mroman> (s1,r1) = (0,0)
15:09:12 <ski> yes
15:09:16 <Philippa> yep, looks like you're getting it
15:09:46 <dyn> init' (x:xs) = Just (x : init' xs)  -- where i somehow need to "unpack" the (Maybe a) return value of the recursion..?
15:09:52 <mroman> c2 = Return 0 ?
15:09:55 <Philippa> you can write a version without the GADT as well, but that's probably going a bit fast for now. Are you happy State isn't magic now?
15:09:56 <Philippa> yes :-)
15:10:05 <dmwit> dyn: Yes, use "case" to unpack the return value.
15:10:28 <mroman> in runState (Return 0) 0
15:10:28 * jessopher <3's gadts
15:10:32 <dyn> case always smellt for me somehow.. cant explain. ok, trying
15:10:35 <MostAwesomeDude> If I have a record that looks like {a :: Int, b :: Int, c :: Int} and want to be able to add these records together piecewise, is there a better way to do it than a first + a second, b first + b second, etc.?
15:10:35 <lambdabot> MostAwesomeDude: You have 1 new message. '/msg lambdabot @messages' to read it.
15:10:38 <mroman> which is (0,0)
15:10:42 <mroman> Ok.
15:10:47 <mroman> Works :-)
15:10:57 <dmwit> MostAwesomeDude: Don't understand the question.
15:11:05 <Botje> MostAwesomeDude: you can pattern match on them.
15:11:06 <mroman> Philippa: Yes. @Magic. Thank you very much.
15:11:32 <Philippa> okay. Want to know why we use the Monad class instead of arbitrary languages?
15:11:38 <dmwit> Ah, I do understand.
15:11:54 <mroman> Syntactic sugar ;)?
15:12:07 <Philippa> mroman: that helps, but it's not the best reason at all
15:12:10 <mroman> It's more abstract and more generic, I guess.
15:12:14 <Philippa> look in Control.Monad
15:12:29 <Philippa> there are lots of functions that work with any instance of Monad - mapM is a good example
15:12:43 <kmc> MostAwesomeDude, f (Foo xa ya za) (Foo xb yb zb) = Foo (xa+xb) (ya+yb) (za+zb)
15:12:54 <Philippa> better yet, there are "monad transformers" - monads that are built out of other monads
15:13:01 <ski> dyn : instead of `case', you could equivalently use a helper function
15:13:04 <Philippa> you can build monads like lego out of them
15:13:11 <Philippa> we couldn't do that with arbitrary languages
15:13:13 <mroman> That makes sense, yes.
15:13:46 <Philippa> so there are times when we need a different structure and that's fine, but we're keen on exploiting the structures we have
15:14:12 <ski> MostAwesomeDude : one way would be to define `data ABC = A | B | C', and then use `ABC -> Int' instead of that record type
15:14:32 <MostAwesomeDude> dmwit, Botje : This is currently a big speed bump in some code; I'm calling it a lot.
15:15:08 <ski> MostAwesomeDude : so, you could write kmc's function like `f a b = \abc -> a abc + b abc'
15:15:09 <MostAwesomeDude> Was curious about any optimizations which could be done.
15:15:11 <hpaste> dyn pasted “init'” at http://hpaste.org/55349
15:15:18 <dyn> \O/
15:15:24 <dyn> not that I like it visually..
15:15:26 <Botje> MostAwesomeDude: probably because your data is too lazy.
15:15:33 <MostAwesomeDude> Botje: Totally possible!
15:15:50 <dyn> any suggestions to improve this or make it shorter somehow?
15:15:51 <MostAwesomeDude> But this function is responsible for like %20 of my allocations; that seems like too much entirely.
15:15:52 <Botje> MostAwesomeDude: try Foo $! (xa + xb) $! (ya+yb) $! (za+zb) or something
15:16:06 <Botje> MostAwesomeDude: that or make the fields of your Foo strict.
15:16:58 <psionski> > init [1]
15:16:58 <lambdabot>   []
15:17:22 <ski> dyn : why `Nothing' in the `[x]' case ?
15:17:30 <psionski> i was wondering the same :D
15:17:35 <psionski> but makes sense
15:17:38 <psionski> init does the same
15:17:44 <mroman> init [x] should be []
15:17:52 <dyn> err.. right :)
15:18:19 <dyn> ok it returns Just [] now
15:18:34 <dyn> but I still think the last statement is a bit long for what it does
15:18:48 <mroman> Wouldn't init' (x:xs) = Just $ init xs also do the job?
15:18:56 <Botje> dyn: look up the either function.
15:19:00 <Botje> uh
15:19:00 <mroman> (x:xs) already guarantees you, that you have at least two elements
15:19:04 <Botje> the maybe function, rather.
15:19:08 <mroman> in which case it is always safe to call init
15:19:27 <Philippa> mroman: it didn't take me long, want to see a version without the GADT?
15:19:33 <mike-burns> I think that last branch would look nicer with a `where'.
15:19:42 <mroman> Philippa: If you have it ready, sure.
15:20:06 <dyn> mroman: it does.. but I need to think this over
15:20:38 <hpaste> Philippa pasted “GADTless State monad” at http://hpaste.org/55350
15:20:56 <mroman> init' xs|empty xs=Nothing|otherwise=Just $ init xs should also work
15:21:11 <Philippa> dear hpaste: the eta expansion is intentional!
15:21:23 <dyn> wouldn't get much smarter than your init'' (_:xs) = Just $ init xs
15:21:29 <rwbarton> (x:xs) means you have at least one element
15:21:31 <Philippa> mroman: compare the commented functions to those in the GADT version
15:21:44 <hpaste> ski annotated “init'” with “using a helper for the matching” at http://hpaste.org/55349#a55351
15:21:45 <rwbarton> oh i see
15:21:55 <ski> dyn ^
15:22:10 <Philippa> what I didn't do (and is normal) is to "box" the tuple in a State type again - that's more typeful and thus higher-level code
15:22:26 <Philippa> but it's also harder to read the code
15:22:45 <mroman> runState is unused?
15:22:48 <Philippa> (except you go back to using runState inside bind again, which helps)
15:22:59 <dyn> ski: ok, I see your point with the helper, nice
15:23:18 <Philippa> right, internally it's just a helper function that I optimised out. But it's part of the interface we were working with
15:23:40 <Philippa> early "boxed" versions of the monad didn't use runState inside either, which was painful to read
15:23:44 <mroman> Yes, because runState doesn't do much anymore
15:24:03 <mroman> hm..
15:24:20 <Philippa> btw, we call the GADT version a "deep" embedding and this version a "shallow" embedding
15:24:33 <Philippa> the difference is surprisingly mechanical, isn't it?
15:24:38 <mroman> looks actually the same
15:24:43 <mroman> except less GADTs ;)
15:25:02 <Philippa> right. But the GADT means Haskell can look at the syntax of the state language as well as its semantics
15:25:14 <Philippa> (which is technically a breach of the monad laws, but is useful for other kinds of language)
15:26:14 <mroman> Why not: runState = id ;P
15:27:01 <Philippa> because then you can't see why it's id
15:27:11 <ski> dyn : oh actually, a bug, `helper x0 [    ] = [x0]' should be `helper x0 [    ] = []'
15:27:18 <mroman> I was just making fun with the "Why not" feature ;)
15:27:49 <ski> (that's what i get for attempting last-second changes)
15:27:49 <mroman> With GADTs you have to use pattern matching
15:27:53 <mroman> now they're gone.
15:27:56 <mroman> But besides that.
15:28:02 <mroman> It's the same.
15:28:18 <Philippa> *nod*. Also, if you write runState first it dictates how you have to implement the other functions
15:29:04 <dyn> mroman: *doh* I just realized that init' (_:xs) = Just $ init xs  is calling the stock init function :)
15:29:05 <hpaste> ski annotated “init'” with “corrected” at http://hpaste.org/55349#a55352
15:29:26 <dyn> mroman: which i'd definetely like to avoid in this exercise..
15:30:01 <dyn> ski: [     ] looks pretty disturbing for me :)
15:30:10 <dyn> gotta get used to it I guess
15:30:12 <irene-knapp> yeah, I'm not at all a fan of using ticks in function names
15:30:13 <Philippa> mroman: anyway, I hope that's helped you understand monads better? I still recommend using monad transformers and wrapping most of the time, but when you have to write them by hand...
15:30:14 <irene-knapp> it's too subtle :(
15:30:28 <mroman> Philippa: I do @better.
15:30:58 <dyn> irene-knapp: i thought I like them but it's too easy to make mistakes like this with them
15:31:08 <irene-knapp> yes
15:31:20 <irene-knapp> and it's too slippery a slope when you have "just three" versions of a variable, right
15:31:22 <mroman> Thanks your help and patience.
15:31:24 <irene-knapp> to have foo, foo', and foo''
15:31:26 <mroman> +for
15:31:35 <aavogt> foo'''''''''''''''''''''''
15:31:37 * dyn agrees
15:31:39 <irene-knapp> when you realize you need a fourth, you find it's a lot easier to add foo''' than to rename the existing ones
15:31:49 <irene-knapp> so it's better to use numeric suffixes from the start :)
15:32:00 <mike-burns> Yeah, just come up with a real name for it that captures what makes it different.
15:32:10 <irene-knapp> yeah, that is another option :)
15:32:18 <dyn> yup
15:32:36 <aavogt> fooIV -- perhaps a reasonable compromise
15:32:45 <irene-knapp> although I don't think it would have worked in my particular nightmare-function case, which was about five hundred lines long and I couldn't see how to break it up (it was the core of an emulator for the 6502 CPU)
15:33:23 <aavogt> or you could write a typeclass and probably get those 4 versions to have the same name
15:33:32 <irene-knapp> depends on what you're doing
15:33:37 <mike-burns> I like aavogt 's suggestions.
15:33:46 <mike-burns> But I'd prefer fooTheIVth.
15:33:59 <irene-knapp> fooIVtheJourneyHome
15:34:24 <mroman> o_O
15:34:31 * aavogt pronounces fooIV as five
15:34:32 <znutar> break it up with one function per gate
15:34:37 <irene-knapp> haha aavogt
15:34:51 <irene-knapp> znutar: haha! :D there are actually only about 10,000 gates in the 6502 I think
15:34:59 <ski> @better
15:35:00 <lambdabot> Unknown command, try @list
15:35:04 <irene-knapp> few enough that JavaScript does a decent job of gate-level simulation, in fact!  heh
15:35:18 <dyn> ok, time to catch some sleep for me.. thanks for all your help
15:35:20 <irene-knapp> night dyn
15:35:35 <mroman> Yeah, me too.
15:35:41 <Philippa> I mostly use ticks for functions that aren't quite "go" - for example, inner functions where the outer function is basically foo = runMonad . foo'
15:35:44 <mroman> Already very late in my time zone :)
15:35:45 <parcs`> is it possible to define a function 'lower :: Proxy (x :: a) -> a' with PolyKinds?
15:35:51 <irene-knapp> yeah that's the other thing with using ticks, right
15:35:58 <znutar> yeah, they did the thing in rubylith on a big table so it can't be too awful
15:36:02 <irene-knapp> it's ambiguous which one is the "real" one and which is the "almost real" one
15:36:29 <irene-knapp> znutar: yeah :)
15:36:36 <ski> Philippa : "which was painful to read" -- hm ?
15:36:53 <Philippa> ski: remember the version in the Gentle Introduction? I had to draw a damn diagram
15:37:30 * ski doesn't recall anything from the Gentle Introduction, except that it was easy
15:38:49 <Philippa> heh. Basically it was the final version I've got except with boxing and unboxing from a State type
15:39:47 <ski> i would think that adding `MkState' and `unState' would make it "more painful to read"
15:39:49 * ddarius is with ski.
15:42:01 <ski> i think it would be nice if we could define `(>>=)' like
15:42:07 <ski>   runState (ma >>= amb) s0 = (b,s2)
15:42:11 <ski>     where
15:42:15 <ski>     (a,s1) = runState   ma    s0
15:42:16 <ski>     (b,s2) = runState (amb a) s1
15:42:50 <ski> i.e. defining what record `ma >>= amb' is, in terms of what all the fields of it are
15:43:24 <ski> (so an indirect definition, in precisely the same sense that `f x = ..x..' is an indirect definition of `f', defining it in terms of what `f x' is, for any value of `x')
15:43:49 <augur> weird
15:43:55 <Philippa> mixfixy
15:43:56 <Philippa> interestingly so
15:44:02 <augur> in closer to nirvana, spj's nose looks a bit flatter than usual
15:44:11 <irene-knapp> heh
15:44:39 <ski> possibly one should say `RunState' here instead, to help parsing by making it clear that `RunState' is an accessor function/selector/method
15:44:58 <augur> he looks a bit like michael york as a consequence
15:44:59 <ski> Philippa : not really mixfixy :)
15:46:22 <ski> Philippa : generally `<lhs> = <lhs> <pattern> | <accessor> <lhs> | <variable> | ...'
15:46:49 <ski> (s/=/::=/)
15:47:31 <eikke> is there any function like "(Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString" ?
15:47:34 <eikke> hoogle doesnt help
15:47:56 <eikke> basically: zipWith on a pair of bytestrings where the result is already encoded as a bytestring
15:48:00 <irene-knapp> hm
15:48:09 <MostAwesomeDude> eikke: I'm pretty sure there's something like that in Data.ByteString, yes.
15:48:49 <Axman6> @hoogle [a] -> Ptr a
15:48:49 <lambdabot> Prelude head :: [a] -> a
15:48:50 <lambdabot> Data.List head :: [a] -> a
15:48:50 <lambdabot> Prelude last :: [a] -> a
15:48:53 <MostAwesomeDude> eikke: Data.ByteString.zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
15:48:54 <Axman6> -_-
15:49:12 <eikke> MostAwesomeDude: turning [Word8] into a ByteString would be a waste of resources
15:49:36 <MostAwesomeDude> eikke: There is no more specific operation, AFAIK. Just pack it afterwards.
15:49:40 <ski> @hoogle+
15:49:40 <lambdabot> Data.List last :: [a] -> a
15:49:41 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
15:49:41 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
15:49:51 <Axman6> ah ha, thanks ski
15:50:18 <augur> so spj says haskell compiles into system f
15:50:24 <augur> anyone have a link discussing this?
15:51:31 <Axman6> @hoogle Ptr a -> Ptr b
15:51:32 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
15:51:32 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
15:51:32 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
15:52:35 <NOTtheMessiah> Having trouble compiling repa-devil on Arch Linux, it's saying that it depends on template-haskell 2.5, and I have 2.6
15:52:51 <Axman6> :t alloca
15:52:52 <NOTtheMessiah> Using the testing package of Haskell
15:52:52 <lambdabot> Not in scope: `alloca'
15:52:57 <Axman6> @hoogle alloca
15:52:57 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
15:52:57 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:52:57 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:53:14 <Axman6> @hoogle a -> Ptr a
15:53:14 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
15:53:15 <lambdabot> Prelude id :: a -> a
15:53:15 <lambdabot> Data.Function id :: a -> a
15:53:17 <Philippa> augur: it's not been true for a while, but GHC's Core language has long been derived from System F to keep the dictionary-passing transformation practical
15:53:22 <Axman6> @hoogle+
15:53:22 <lambdabot> GHC.Exts breakpoint :: a -> a
15:53:23 <lambdabot> GHC.Exts inline :: a -> a
15:53:23 <lambdabot> GHC.Exts lazy :: a -> a
15:53:31 * Axman6 should probably pm lambdabot now
15:53:34 <augur> Philippa: what is it currently?
15:53:44 <Philippa> SPJ&co've published a number of papers as it's evolved
15:53:57 <Philippa> um. Some follow-up of System Fc, which was itself discovered/created for GHC
15:55:26 <augur> aha i see
15:55:44 <augur> system f with type equality coercions
15:55:46 <augur> and others
15:56:04 <tickle`> how does haskell know which Show instance to use in show (1 :: Num a => a) ?
15:56:07 <eikke> MostAwesomeDude: funny enough, the bytestring sources contain zipWith' which is exactly what I'm looking for, but it's not in the documentation, only used by a specialization rule which unpacks the result in case w8->w8->w8 is used with zipWith, grmbl
15:56:17 <irene-knapp> > show (1 :: Num a => a)
15:56:18 <lambdabot>   "1"
15:56:22 <irene-knapp> it uses defaulting
15:56:36 <irene-knapp> there's a way to override the defaulting, which you often want to do since I believe the, ahem, default default is Integer
15:56:36 <MostAwesomeDude> eikke: Well, maybe the author wanted to make sure you didn't have to worry about inefficiency in this particular case.
15:56:41 <augur> tickle`: they're probably all the same, modulo some things
15:56:43 <augur> lets see
15:56:49 <augur> > show (1 :: Float)
15:56:49 <lambdabot>   "1.0"
15:56:51 <augur> o
15:56:52 <augur> nevermind
15:56:54 <augur> :x
15:56:56 <irene-knapp> hehe
15:57:02 <tickle`> irene-knapp: so that's what the default declaration is for?
15:57:09 <eikke> MostAwesomeDude: no, the specialization rule does exactly the opposite of what I want :)
15:57:21 <eikke> and the function I could use isn't exported
15:57:24 <irene-knapp> I think so?  I'm not sure what the syntax is, but yeah, I'd assume.
15:59:17 <tickle`> well, since "default" I think is just for numeric types, how is the Show instance selected in this example: (show ("foo" :: IsString a => a)) -- when OverloadedStrings is enabled?
15:59:44 <irene-knapp> I'm not sure it is!
15:59:53 <irene-knapp> I think that might be an error; either that or it always uses String
16:00:15 <tickle`> Prelude Data.String> show ("foo" :: IsString a => a)
16:00:16 <tickle`> "\"foo\""
16:00:20 <irene-knapp> since Haskell doesn't have subtyping, this problem doesn't come up in general contexts
16:00:36 <irene-knapp> strings with OverloadedStrings and numbers given as literals are the only two cases, I believe
16:00:52 <irene-knapp> hmm, okay, so it does work.  I would assume that it uses String.
16:01:27 <tickle`> hm. alright. do you have any idea how ghc/whatever says that String is the default type for that class?
16:01:35 <irene-knapp> it's very likely hardcoded
16:01:51 <irene-knapp> if you really wanted to change it for some reason, you'd have to dig into the GHC source
16:02:04 <irene-knapp> that's assuming you're correct that default hasn't been extended to let you specify for strings
16:02:23 <tickle`> interesting
16:02:31 <irene-knapp> yeah
16:05:01 <tickle`> actually
16:05:03 <tickle`> "Haskell's defaulting mechanism is extended to cover string literals, when -XOverloadedStrings is specified."
16:05:07 <irene-knapp> ah, yes
16:05:09 <irene-knapp> good :)
16:05:12 <tickle`> cool, thanks
16:05:14 <irene-knapp> np
16:10:57 <dmwit> shachaf: So, GHC 7.3 rejects the un-annotated term, too. =)
16:11:14 <dmwit> (At least as of today, and possibly for up to a month now.)
16:11:44 <dmwit> type family F a; x :: F a; x = undefined; y = x -- now has an error here, whether y has a type signature or not
16:12:05 <MostAwesomeDude> @src maximumBy
16:12:05 <lambdabot> Source not found. Are you on drugs?
16:12:26 <MostAwesomeDude> @src Data.List.maximumBy
16:12:26 <lambdabot> Source not found. Where did you learn to type?
16:13:53 <MostAwesomeDude> Sheesh, she's sure picky today.
16:15:12 <mpiechotka> @pl (\cont _ -> return (cont undefined))
16:15:12 <lambdabot> const . return . ($ undefined)
16:16:44 <osaunders> Is there a monad instance for sets?
16:17:11 <hpc> osaunders: no, but there is a foldable instance
16:17:19 <hpc> and a monoid instance
16:17:23 <irene-knapp> okay, so, the latest Attoparsec appears to have removed Data.Attoparsec.Combinator.many
16:17:49 <JoeyA> irene-knapp: I have a hunch that it's using Applicative.many now.
16:17:54 <hpc> (not sure if it's POSSIBLE to write an instance for Set, but i suspect it isn't, or it would be there)
16:17:55 <osaunders> hpc: Why isn’t there a monad instance?
16:18:02 <irene-knapp> oh, gotcha, thanks!
16:18:09 <irene-knapp> @hoogle many
16:18:09 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
16:18:09 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
16:18:09 <lambdabot> Text.ParserCombinators.ReadP many1 :: ReadP a -> ReadP [a]
16:18:14 <osaunders> Hm
16:18:42 <osaunders> Isn’t just mapping and unioning
16:19:01 <osaunders> You’ve got the Ord class constraint to deal with though
16:19:05 <benmachine> right
16:19:16 <benmachine> return :: a -> m a doesn't work for sets
16:19:33 <JoeyA> I wish Hackage kept track of how many times each package is downloaded.
16:19:38 <irene-knapp> that would indeed be nice
16:19:55 <hpc> benmachine: the term is "not enough parametricity" or something?
16:20:03 * hpc tests his terminology
16:20:04 <benmachine> hpc: I guess so
16:20:10 <benmachine> well
16:20:12 <osaunders> benmachine: because of the class constraint?
16:20:21 <benmachine> osaunders: actually, return was a bad example
16:20:38 <osaunders> Yeah
16:20:43 <benmachine> but you can't implement join :: m (m a) -> m a
16:20:51 <benmachine> because you can only union sets if you've got Ord
16:21:04 <benmachine> actually
16:21:09 <benmachine> more obviously, you can't implement fmap
16:21:21 <benmachine> and if you can't implement fmap you're definitely stuck for Monad
16:21:32 <JoeyA> benmachine: What about Ord a => Monad (Set a) ?
16:21:37 <benmachine> JoeyA: kind error
16:21:46 <JoeyA> Monad Set*
16:21:52 <JoeyA> Can't you get Ord from there, like they do for the Monoid instance?
16:22:08 <benmachine> no
16:22:15 <osaunders> I don’t understand why there isn’t even a unionMap function
16:22:26 <hpc> JoeyA: you write your instance for "Monad Set"
16:22:32 <JoeyA> Oh, I guess because the type variable sort of gets buried.
16:22:39 <benmachine> because the way Monad is designed means it really wants the type to be able to contain anything
16:22:41 <hpc> JoeyA: 'a' is unmentioned and can be any type ever
16:22:50 <benmachine> yeah
16:22:57 <benmachine> and this is actually a /feature/ of monad, sort of
16:23:26 <hpc> at least, if you want something different you use a freakier typeclass feature
16:23:31 <benmachine> yeah
16:23:32 <benmachine> well
16:23:43 <benmachine> there are several ways of writing a monad-like class that can support sets
16:24:03 <benmachine> but basically you end up with a different typeclass, which may not be as useful
16:24:24 <hpc> it might not even have the same laws
16:24:49 <hpc> because of how equal elements of sets get eliminated
16:25:09 <hpc> if you do operations in a different order, you should end up on the same point on the "graph", but the sets got filtered differently
16:25:56 <benmachine> hpc: I think it works out
16:26:18 <benmachine> I think so, anyway
16:26:54 <osaunders> I’m not that hot on type classes. This right here is evidence for that opinion.
16:27:08 <osaunders> So I’m content with a unionMap function.
16:28:16 <hpc> i like type classes, but mostly just as "this is how it works" guarantees
16:28:34 <hpc> and as syntax hacks, in the case of Num and Monad
16:28:54 <benmachine> I think it's important to be clear that the lack of a Functor Set instances is not a technical limitation
16:28:58 <benmachine> it's a conceptual thing
16:29:02 <benmachine> well, that's what I think anyway
16:29:09 <osaunders> I’m glad they are in the language but I think people over-emphasize their usefulness.
16:29:15 <benmachine> oh, I'd agree with that
16:29:28 <benmachine> but Functor/Monad are among the better ones imo
16:29:35 <hpc> the most important lesson imo is that type classes are NOT polymorphism
16:29:37 <osaunders> Yeah
16:29:57 <hpc> nor are they code reuse, unless you try really hard
16:30:02 <benmachine> apparently type classes were originally invented as principled overloading
16:30:12 <hpc> you get to reuse everything defined outside the class itself, but that's it
16:30:16 <benmachine> but I think sometimes people forget the principled bit :P
16:31:08 <hpc> one trick i really want to try sometime is using a monad with a phantom type parameter to make a context-free EDSL
16:32:10 <hpc> the only useful operation would be (>>), but it would have nice syntax
16:34:37 <Sgeo> :t mapM_
16:34:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:36:15 <JoeyA> I wonder how hard it would be to create a type where Typeable.typeOf collides with that of another type.
16:36:48 <JoeyA> (collides on TypeRep's (==), that is)
16:37:43 <JoeyA> (TypeRep uses an md5 fingerprint internally)
16:37:47 <JoeyA> at least in GHC
16:38:06 <Sgeo> @hoogle (<$>)
16:38:06 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
16:38:06 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:39:30 <Sgeo> Blargh
16:39:45 <Sgeo> Stupid :: in front of first argument tripped me up, I didn't notice that I forgot it
16:39:53 <Sgeo> Erm, didn't notice that it was there
16:42:36 <JoeyA> Just curious, is it possible to derive a Typeable instance in a separate module from where the type is defined (i.e. an orphan instance) ?
16:43:25 <parcs`> possibly with StandaloneDeriving
16:43:27 <ski> tried with `StandaloneDeriving' ?
16:44:16 <JoeyA> Ah, good to know, thanks.
16:44:41 <JoeyA> Just wondering, is it even possible to define a Typeable instance without using DeriveDataTypeable?
16:44:55 <kmc> yes
16:44:55 <ski> yes, but it's not recommended
16:45:00 <kmc> the base library does it all over
16:45:03 <kmc> using some CPP macros
16:45:07 <kmc> but you can easily break the type system this way
16:45:22 <The_Journey> hi, I was wondering how to implement the take function, can anyone come with a possible implementation?
16:45:33 <ski> yes
16:45:39 <kmc> @src take
16:45:39 <lambdabot> take n _      | n <= 0 =  []
16:45:40 <lambdabot> take _ []              =  []
16:45:40 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:46:07 <poincare101> kmc: holy crap! That's so cool that lambdabot can do that!
16:46:14 <poincare101> @src !!
16:46:14 <lambdabot> xs     !! n | n < 0 = undefined
16:46:14 <lambdabot> []     !! _         = undefined
16:46:14 <lambdabot> (x:_)  !! 0         = x
16:46:14 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:46:25 <The_Journey> oh, I didn't know you can have multiple definition like that
16:46:36 <ski> lambdabot really just looks those up in a small table it has
16:46:42 <poincare101> ski: oh.
16:46:45 <JoeyA> take 0 _ = []; take 1 (a:_) = [a]; take 2 (a:b:_) = [a,b]; take 3 (a:b:c:_) = [a,b,c]; take 4 _ = error "You ask too much"
16:46:47 <ski> that's not multiple definitions
16:46:52 <kmc> The_Journey, it's pattern-matching
16:46:59 <kmc> @src map
16:46:59 <lambdabot> map _ []     = []
16:46:59 <lambdabot> map f (x:xs) = f x : map f xs
16:47:01 <poincare101> @src head
16:47:01 <lambdabot> head (x:_) = x
16:47:01 <lambdabot> head []    = undefined
16:47:07 <ski> it's a single definition, consisting of multiple defining equations/clauses
16:47:11 <kmc> (you can also private-message lambdabot, by the way)
16:47:11 <poincare101> @src cons
16:47:11 <lambdabot> Source not found. That's something I cannot allow to happen.
16:47:17 <poincare101> @src cat
16:47:17 <lambdabot> Source not found. My brain just exploded
16:47:22 <poincare101> @src tail
16:47:22 <lambdabot> tail (_:xs) = xs
16:47:22 <lambdabot> tail []     = undefined
16:47:25 <poincare101> w00t
16:47:31 <kmc> however @src isn't perfect, it's just reading from a fixed database someone loaded into lambdabot
16:47:44 <ski> > let x = 2; x = 3 in x*x
16:47:45 <lambdabot>   Conflicting definitions for `x'
16:47:45 <lambdabot>  Bound at: <interactive>:1:4
16:47:45 <lambdabot>            <in...
16:47:49 <kmc> poincare101, if you want "the real source" you can find your module in http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html or on hackage
16:47:51 <Cale> where "database" = "text file"
16:47:52 <kmc> and then click the 'source' links
16:48:00 <poincare101> kmc: thanks :0
16:48:05 <hpaste> int80_h pasted “difficulty installing haskell platform on 64-bit ubuntu server.” at http://hpaste.org/55353
16:48:05 <poincare101> I meant :)
16:48:09 <kmc> Cale, i think you mean "webscale NoSQL key-value store"
16:48:19 <Cale> kmc: lol
16:48:59 <mike-burns> The_Journey: Did that help you write `take'?
16:49:10 <hpaste> Sgeo pasted “What's the difference?” at http://hpaste.org/55354
16:49:34 <Sgeo> If I uncomment the first two lines and comment the third, it works. AS is, it does not work.
16:49:38 <Sgeo> Why? What is the difference?
16:49:48 <kmc> it's hard to say in general what the difference between two functions is...
16:49:49 <kmc> :t (<$>)
16:49:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:50:00 <kmc> :t (=<<)
16:50:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:50:03 <mike-burns> :t sin - cos
16:50:03 <lambdabot> forall a. (Floating a) => a -> a
16:50:05 <JoeyA> Sgeo: The second one is a type error, because the function you're applying with <$> returns an action.
16:50:07 <ski> Sgeo : replace `<$>' with `=<<'
16:50:26 <Sgeo> JoeyA, it compiles fine though
16:50:32 <shachaf> JoeyA: Is it a type error? I think it would work fine if you just put "join $" in front of it.
16:50:47 <JoeyA> shachaf: Ah, true
16:50:54 <Sgeo> ski, ty
16:51:00 <ski> @do mapM_ putStrLn =<< nlst ftpConn Nothing
16:51:00 <lambdabot> mapM_ putStrLn =<< nlst ftpConn Nothing
16:51:03 <ski> bah
16:51:05 <ski> @do nlst ftpConn Nothing >>= mapM_ putStrLn
16:51:05 <lambdabot> do { a <- nlst ftpConn Nothing; mapM_ putStrLn a}
16:51:08 <JoeyA> Sgeo: Then compile with -Wall, so your compiler will warn about the discarded value ;-)
16:51:09 <ski> Sgeo ^
16:51:13 <kmc> right, sometimes you end up writing something of type «IO (IO t)» when you wanted «IO t» and this might not be a type error always
16:51:29 <ski> @undo do files <- nlst ftpConn Nothing; mapM_ putStrLn files
16:51:29 <lambdabot> nlst ftpConn Nothing >>= \ files -> mapM_ putStrLn files
16:51:32 <Sgeo> @do mapM_ putStrLn <$> nlst ftpConn Nothing
16:51:33 <lambdabot> mapM_ putStrLn <$> nlst ftpConn Nothing
16:52:00 <alistra> @do your mom
16:52:00 <lambdabot> your mom
16:52:05 <JoeyA> lol
16:52:06 <kmc> amazing
16:52:20 <alistra> magick
16:52:22 <JoeyA> @do your >>= mom
16:52:22 <lambdabot> do { a <- your; mom a}
16:52:42 <kmc> @do preflex: seen lambdabot
16:52:43 <lambdabot> preflex : seen lambdabot
16:52:43 <ski> kmc : especially if you haven't a type signature for your definition, and it's not called from anywhere else ..
16:52:46 <kmc> aww
16:53:12 <JoeyA> @do fix (a >>=)
16:53:12 <lambdabot> fix (a >>=)
16:53:17 <Sgeo> Oh, I think I get it
16:53:27 <mauke> @do preflex seen lambdabot
16:53:28 <lambdabot> preflex seen lambdabot
16:53:28 <preflex>  lambdabot was last seen on #haskell 15 seconds ago, saying: fix (a >>=)
16:53:35 <Axman6> @do your >>= mum >> favour
16:53:35 <lambdabot> do { do { a <- your; mum a}; favour}
16:53:39 <alistra> > fix (Just 3 >>=)
16:53:40 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
16:53:40 <lambdabot>         against infe...
16:53:41 <Sgeo> It's because mapM_ is already returning an IO (), it's not a pure function that wants to use impure arguments
16:53:53 <kmc> there's no such thing as "impure arguments"
16:54:06 <kmc> an IO action is a pure value, like any other
16:54:13 <JoeyA> What about unsafeLaunchMIssiles :: a ?
16:54:21 <kmc> an IO Int is not an "impure Int", it's a pure value which is nothing like an Int
16:54:30 <mike-burns> JoeyA: That's an impure thought.
16:54:44 <JoeyA> @hoogle launchMissiles
16:54:44 <lambdabot> No results found
16:55:09 <The_Journey> what does the syntax (x:xs) in take n (x:xs) = ... ?
16:55:10 <ski> since `mapM_ putStrLn :: [String] -> IO ()', `(mapM_ putStrLn <$>) :: IO [String] -> IO (IO ())', since that's what `(<$>)' does
16:55:19 <kmc> The_Journey, (x:xs) is a pattern which matches any non-empty list
16:55:33 <kmc> it binds the varible 'x' to the first element of the list,  and 'xs' to the rest of the list
16:55:36 <The_Journey> kmc: it matches the first element in the list?
16:55:42 <The_Journey> oh
16:55:49 <mike-burns> x = the first element, xs = the rest.
16:55:55 <ski> The_Journey : if `x' is an element, and `xs' is a list, then `x:xs' is the list that starts with the element `x', and continues with all the elements in `xs' -- in short, `x' added to the front of `xs'
16:55:57 <hpc> The_Journey: you could write your own list type
16:56:09 <hpc> data List a = Nil | Cons a (List a)
16:56:13 <hpc> then write:
16:56:20 <hpc> take n (Cons x xs) = ...
16:56:25 <hpc> take n Nil = ...
16:57:47 <ski> The_Journey : so `take n (x:xs) = ...' matches calls like `take 3 [10,21,33,46]', since `[10,21,33,46]' really is `10 : [21,33,46]' (which really is `10 : 21 : 33 : 46 : []', i.e. `10 : (21 : (33 : (46 : [])))' -- in the syntax of hpc, it's `Cons 10 (Cons 21 (Cons 33 (Cons 46 Nil)))')
16:58:22 <ski> The_Journey : so in the call `take 3 [10,21,33,46]', `n' will become `3', `x' will become `10' and `xs' will become `[21,33,46]'
16:59:08 <ByronJohnson> benmachine: About restricetd monads: have you considered changing things so that every type variable :: * is part of the definition of the type class (with equivalent implicit behavior if it's not defined explicitely)?  class Monad m a b where ...; instance Monad Maybe a b where ..., for example.
16:59:35 <ski> ByronJohnson : yes, people have considered that
16:59:55 <ski> (but imo, it's not really a good idea)
17:00:01 <ByronJohnson> ski: Why not?
17:00:30 <ski> all parametricity guarantees are lost
17:01:05 <benmachine> parametricity is a good thing!
17:01:11 <benmachine> cf. free theorems
17:01:29 <ski> it's better to say something like
17:01:34 <ski>   class RMonad r m
17:01:36 <ski>     where
17:01:48 <ski>     unit :: r a -> a -> m a
17:02:01 <ski>     bind :: (r a,r b) -> m a -> (a -> m b) -> m b
17:02:20 <ski> where e.g.
17:02:31 <ski>   data NoRestriction a = NR a
17:02:42 <ski>   data OrdRestricted :: * -> *
17:02:44 <ski>     where
17:02:57 <ski>     OR :: Ord a => OrdRestricted a
17:03:04 <ski> so you could say
17:03:12 <ski>   instance RMonad OrdRestricted Set
17:03:14 <ski> i think
17:03:31 <ski> (er, s/NR a/NR/)
17:04:13 <ski> so, here `a' and `b' are universally quantified in the types of `unit' and `bind' (as opposed to in the `class Monad m a b where ...' suggestion)
17:04:29 <ski> but the `r a' and `r b' arguments effect a restriction of the types
17:04:40 <ski> in the `OrdRestricted' case that they are in `Ord'
17:05:18 <ski> @hackage rmonad
17:05:18 <lambdabot> http://hackage.haskell.org/package/rmonad
17:05:28 <ski> see that ^ for an implementation of this idea
17:05:45 <ski> ByronJohnson ^
17:12:09 <kmc> now you can do the same thing with ConstraintKinds more directly
17:12:16 <kmc> (that may be where this whole conversation started)
17:12:30 <ski> (it wasn't)
17:13:15 <Sgeo> How would I tell GHC that I only want to type-check, don't bother giving me the output of compilation?
17:15:04 <luite> -fno-code
17:15:52 <Sgeo> ty
17:17:23 <kmc> cool, i failed to find that in the manpage just now
17:17:25 <kmc> thanks luite
17:18:24 <Sgeo> jEdit doesn't color multiline strings properly
17:18:25 <Sgeo> :(
17:20:07 <parcs`> how do i marshal a haskell function into a callable c function?
17:20:23 <ByronJohnson> ski: I had in mind making higher-kinded polymorphism a little mor flexible, so that being able to require universal quantification under the *->* would stil lbe possible (and perhaps the default behavior), and so that instances could be a little less polymorphic if they wanted to, so that you would write the types for that (eg "foo :: forall m a. Monad m {a} => m Integer; foo = return 3"; then
17:20:30 <ByronJohnson> perhaps, if foo was given no type signature (or even {a} was not explicitely given, as in "foo :: forall m a. Monad m a => m Integer"), perhaps it could be inferred to be the more restricted type signature)
17:21:10 <kmc> parcs`, foreign import ccall "wrapper"  foo :: (Int -> Char) -> IO (FunPtr (Int -> Char))
17:21:23 <kmc> see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html#t:FunPtr
17:21:46 <JoeyA> I want to upgrade from GHC 7.0.3 to GHC 7.2.2 .  Should I just unpack the GHC 7.2.2 tarball and make install like I did with 7.0.3, or should I nuke my GHC installation from orbit?
17:21:59 <kmc> you have to free the FunPtr with freeHaskellFunPtr when you're done with it
17:22:01 <benmachine> JoeyA: I see no reason to nuke anything
17:22:01 <ByronJohnson> 01:31:10 < benmachine> cf. free theorems — Link? :)
17:22:17 * benmachine opens new tab, googles "free theorems"
17:22:31 <benmachine> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html "Theorems for free!"
17:22:54 <JoeyA> And if I do, how would I install cabal and such after installing GHC 7.2.2 ?
17:23:40 <ByronJohnson> "(return :: (Ord a, Monad m a) => m a) 3  :: S.Set Integer".  Hmm
17:23:46 <ByronJohnson> benmachine: Haha :D
17:24:10 <JoeyA> Download the Haskell platform tarball?  http://hackage.haskell.org/platform/2011.2.0.0/haskell-platform-2011.2.0.0.tar.gz  <-- 404, by the way
17:24:27 <JoeyA> (the correct link being http://lambda.galois.com/hp-tmp/2011.2.0.1/haskell-platform-2011.2.0.1.tar.gz )
17:25:47 <JoeyA> (Ord a, Monad (\a -> m a)) => m a
17:26:00 <JoeyA> You'll need to implement the TypeLambdas extension first.
17:26:07 <Patinho`Busy> hi all
17:26:12 <JoeyA> hi
17:26:35 <benmachine> type lambdas are a deeply advanced form of wizardry
17:26:39 <benmachine> well
17:26:55 <benmachine> you lose all inference forever, probably
17:27:18 <ski> ByronJohnson : in `class Monad m a b where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b', the type of `return' is now `Monad m a b => a -> m a', it looks strange to have a single `b' in there
17:27:21 <ByronJohnson> benmachine: Sorry, I'm sleep deprived, FWIW; should have just googled it myself
17:28:17 <ski> (i.e. why not `return :: Monad m a b => b -> m b' instead ? and if that, why not the other one instead ?)
17:28:21 <ByronJohnson> benmachine, ski: Then, perhaps, {a} and {b} are implicitely part of the definition of Monad.  When they aren't explicitely referenced, they need to be universally quantified
17:28:51 <ski> ByronJohnson : i'm not sure i understand
17:29:00 <ByronJohnson> ski: It depends on how the syntax is implemented, but you'd probably not write {b}, and it's default to forall b.
17:29:28 <ski> benmachine : i suspect that some restricted form of type lambdas (maybe in the L-lambda fragment) would be ok
17:30:29 <ski> JoeyA : `(Ord a, Monad (\a -> m a)) => m a' doesn't make sense -- the inner `a' isn't in scope in `Ord a', so that's equivalent to saying `(Ord a, Monad (\b -> m b)) => m a' (which is now what you wanted
17:30:46 <ski> )
17:30:49 <ski> (s/now/not/)
17:31:21 <benmachine> ski: isn't it? the Ord still applies to the variable in the actual type
17:31:41 <ski> hm
17:32:03 <ski> in that case, i don't get the point, then it's equivalent to `(Ord a,Monad m) => m a', which you can already say
17:32:40 <benmachine> oh
17:32:44 <benmachine> good point :P
17:32:46 * benmachine shrug
17:33:17 <gwern> > 2288 / 7
17:33:18 <lambdabot>   326.85714285714283
17:34:04 <parcs`> kmc: thanks
17:35:13 <ByronJohnson> ski: Then Set, for example, would only be an instnance when 'a' is an instance of Ord, and ByteString would only be an instance of Foo when 'a' is Word8
17:35:33 <ByronJohnson> ski: If 'a' needs to be universally quantified, then Set wouldn't type-check
17:36:09 <ByronJohnson> ListLike does something like this, but it creates a new type class for the same things; it seems pretty messy and inelegant
17:37:50 <ByronJohnson> 01:55:47 < JoeyA> (Ord a, Monad (\a -> m a)) => m a — Ahah :) (I didn't realize this was part of the class-thing conversation)
17:39:07 <ByronJohnson> (That's not helpful, though; that's euivalent to m)
17:40:20 <byorgey> it's also not valid syntax.
17:41:39 <ski> ByronJohnson : i don't think `ByteString' could be an instance here, it has the wrong kind
17:42:10 <ByronJohnson> Ah, right; hmm.
17:43:10 <gwern> > 6350 / 7
17:43:11 <lambdabot>   907.1428571428571
17:43:26 <ski> of course, you could say `class Monadish ma mb where return :: a -> ma; (>>=) :: ma -> (a -> mb) -> mb', with instances like `instance Monadish (IO a) (IO b)' and `instance (Ord a,Ord b) => Monadish (Set a) (Set b)'
17:43:46 <ski> hm, actually, we need more arguments
17:44:13 <ski> `class Monadish ma mb a b where return :: a -> ma; (>>=) :: ma -> (a -> mb) -> mb', with instances like `instance Monadish (IO a) (IO b) a b' and `instance (Ord a,Ord b) => Monadish (Set a) (Set b) a b'
17:44:30 <Sgeo> That's weird
17:44:31 <ski> and here you could say `instance Monadish ByteString ByteString Word8 Word8'
17:44:39 <ski> Sgeo : indeed :)
17:44:49 <ByronJohnson> Huh, that might work
17:44:54 <ski> however, i don't think this is in any way similar to monads
17:45:02 <Sgeo> compiling with -Wall and -fno-code gave no errors, but without -fno-code it warned me about a dropped value
17:45:10 <ski> e.g. you can't write something similar to `join :: m (m a) -> m a', for `ByteString'
17:45:32 <ski> and if you can't write anything like that, then i don't think it doesn't looks anything like a monad
17:46:17 <ByronJohnson> I wonder how higher-order kinding could be changed so that the already existing type classes could be implicitely equivalent to those explicit definitions
17:46:26 <ski> ByronJohnson : the other problem here (which i've already touched on) is that the `return' method is ambiguous : it doesn't mention the `b' (and `mb') type variable
17:46:37 <ski> you can fix this by breaking `return' out into a superclass
17:46:46 <Sgeo> I'm starting to get annoyed by ftphs
17:46:59 * ski isn't sure what ByronJohnson means by "higher-order kinding", here
17:47:20 <Sgeo> Oh, maybe I'm being hit by that caution
17:47:34 <holla> what is the best way to pack data into bits?
17:47:55 <Sgeo> That's due to the lazy nature of Haskell. This means that, for instance, you can't just iterate over the items nlst returns, trying to getbinary each one of them -- the system is still transferring nlst data while you are trying that, and confusion will ensue. Either open two FTP connections or make sure you consume the nlst data first.
17:48:06 <Sgeo> Is this thing using lazy IO?
17:48:45 <Sgeo> Of course it is
17:48:49 * Sgeo is now ticked off
17:48:49 <Eduard_Munteanu> holla: in what way?
17:48:58 <ByronJohnson> < ski> and if you can't write anything like that, then i don't think it doesn't looks anything like a monad — join would only work for some instances.  A function can require join to work on what it's working with if it needs to.
17:49:04 <ski> Sgeo : if it is, then it's improperly done
17:49:24 <Sgeo> ski, I see usage of unsafeInterleaveIO
17:49:36 <ski> (sorry, s/then i don't think it doesn't looks/then i don't think it looks/)
17:49:39 <Sgeo> http://hackage.haskell.org/packages/archive/ftphs/1.0.7/doc/html/src/Network-FTP-Client.html
17:49:40 <ByronJohnson> A lot of the ListLike-like classes irk me; it's inelegant but sometimes needed / really convenient
17:49:57 <holla> Say I have a as 1's and 0's as a string and I want represent that string as bits
17:50:03 <ski> ByronJohnson : what would be the type of `join' in this concrete example ?
17:51:38 <kmc> yeah
17:52:01 <kmc> it's funny to attribute that behavior to "the lazy nature of Haskell" when you have to use a function named unsafeInterleaveIO to get it
17:53:12 <BMeph_> holla: "You have a string of '0's and '1's, and you want to represent the string as bits." ;)
17:53:24 <holla> yup :)
17:53:30 <Sgeo> :t Data.List.Utils.seqList
17:53:31 <lambdabot> Couldn't find qualified module.
17:53:36 <Sgeo> :t seqList
17:53:37 <lambdabot> forall a. Strategy a -> [a] -> Eval [a]
17:54:24 <BMeph> holla: "You are in a maze of twisty little bit strings, all alike. There is a lambda here." 8D
17:55:54 <ski> Sgeo : obviously that module ought to first perform the outstanding I/O on the network, before attempting to do the one associated with the thunk currently being forced
17:56:08 <ski> Sgeo : so, i'd say it not doing this is a bug
17:56:30 <Sgeo> Are there better easy to use FTP packages?
17:56:37 <Sgeo> Because I think I just might switch
17:56:58 * ski thinks that `ListLike' looks pretty horrible, with all those methods in the class
17:57:26 <ByronJohnson> ski: Explicitely written, you could, perhaps only define join to work only on instances in which a and b are universally quantified: join :: forall m a b. (Monad m {a} {b}) => m (m a) -> (m a); or, perhaps a bit more leniantly, "join :: forall m a b. (Monad m {a} {b}) => m (m a) -> m a", or something; not sure how the syntax would be defined
17:57:45 <kmc> Sgeo, what do you need to do with FTP?  there is a libcurl binding but it's kind of nasty too
17:57:47 <ByronJohnson> Erm, the type could be more leniently defined as..
17:57:55 <kmc> (maybe unavoidably)
17:58:08 <ski> ByronJohnson : what i'm wanting to know is : how will the type of `join' look like in the case of `Word8' and `ByteString' ?
17:58:10 <Sgeo> kmc, get the list of files in a directory, use it to make a PHP file based off the names of those files
18:01:42 <ByronJohnson> Maybe m could be either kind * or * -> *, so that types could look like "forall m a b. (Monad m {c} {d} {m a} {m b}) => ...", or something like that
18:02:11 <ski> you'll have to decide on a fixed kind
18:02:11 <ByronJohnson> ski: There wouldn't be join for that, just like there isn't a type of (==) for.. a type that isn't an instance of of Eq
18:02:42 <ski> in the `ListLike full item' case, we have `full :: *' and `item :: *', which is ok for what it tries to do
18:03:02 <ski> ByronJohnson : ok. which is why i don't think this class should be named `Monad' :)
18:03:20 <ski> if you can't write a sensible `join', it's not a monad, in any reasonable sense
18:03:46 <holla> what i have is a string "101010" and I want to convert it into a bits...what's the best way to do so?
18:04:02 <ski> in the `RMonad' case, you have `join :: (RMonad m, Suitable m a, Suitable m (m a)) => m (m a) -> m a', which is reasonable, in that case
18:04:11 <kmc> holla, "into bits" is underspecified
18:04:30 <kmc> do you want [Bool]?  Word8?  [Word8]?  Word64?  what?
18:04:38 <ski> maybe `Integer' ?
18:05:41 <holla> whatever is the smallest
18:05:51 <kmc> what are you trying to do
18:06:29 <kmc> how many bits
18:06:35 <holla> I have a huffman tree with frequencies...and I want to conver it into bits
18:06:38 <holla> they can vary
18:06:46 <kmc> how about [Bool]
18:06:54 <kmc> maybe that will be the most convenient
18:07:01 <kmc> > map (=='1') "101010"
18:07:02 <lambdabot>   [True,False,True,False,True,False]
18:07:26 <ByronJohnson> < ski> if you can't write a sensible `join', it's not a monad… — join could be defined for some instances of the class (like foo :: (Foo a b, Eq a) -> a or something for a definition for Eq)
18:07:52 <holla> isn't a bool bigger than a bit?
18:08:16 <parcs`> > foldl (\a x -> 2*a+x) 0 . map (toInteger . digitToInt) $ "1001"
18:08:18 <lambdabot>   9
18:08:44 <ByronJohnson> I think Haskell's higher-order polymorphism can be dramatically improved, but I don't know how.
18:11:21 <ByronJohnson> Perhaps Functor could be extended for Data.Set.Set, and possibly even for ByteStrings (ListLike already has done this; intelegantly, though)
18:12:07 <ByronJohnson> In a way that involves making the classes more flexible without copying every type class and modifying it slightly
18:12:19 <copumpkin> ByronJohnson: in 7.4 that will be possible
18:12:26 <kmc> holla, why is size your concern?  did you try it the simple way first?
18:12:28 <copumpkin> it'll probably take a while to improve the typeclasses
18:12:33 <Eduard_Munteanu> holla: I guess you have a stream of bits and want to pack them into bytes?
18:12:35 <kmc> how much data do you need to store
18:12:40 <ByronJohnson> copumpkin: o_O
18:13:04 <ByronJohnson> copumpkin: Erm, what exactly?
18:13:04 <copumpkin> what?
18:13:13 <copumpkin> making Set a functor
18:13:23 <copumpkin> even ByteString
18:13:28 <ByronJohnson> That's great news!! :D
18:13:37 <ByronJohnson> Details? :)
18:13:42 <copumpkin> constraint kinds
18:13:50 <copumpkin> the functor class would need to be amended though
18:13:58 <copumpkin> and it'd pollute a lot of types everywhere
18:14:08 <Eduard_Munteanu> You can use bitwise operations from Data.Bits, that should give reasonable performance.
18:14:29 <ByronJohnson> copumpkin: :D:D:D
18:14:32 <Eduard_Munteanu> I remember ST yields a bit better though.
18:14:39 <ByronJohnson> So glad something was finally done about this!
18:14:54 <parcs`> how can you make ByteString a functor?
18:14:59 <holla> thank you for this : foldl (\a x -> 2*a+x) 0 . map (toInteger . digitToInt) $ "1001"
18:15:12 <holla> why did you use foldl instead of foldr?
18:15:52 <copumpkin> parcs`: you can require the context to be (Word8 ~) :P
18:15:59 <Eduard_Munteanu> (I'd unfold that if performance proves to be a problem.)
18:16:08 <parcs`> copumpkin: lol
18:16:18 <parcs`> i must try this
18:16:19 <copumpkin> hey, nothing wrong with that
18:16:26 <Eduard_Munteanu> holla: no reason to use foldr since integer operations are strict
18:16:27 <siracusa> copumpkin: What's the reason Set isn't already a Functor?
18:16:37 <copumpkin> siracusa: fmap :: (a -> b) -> f a -> f b
18:16:48 <ByronJohnson> ski: Apparantly you were unaware of ConstraintKinds?
18:16:49 <copumpkin> siracusa: for that to work on Set, you need to say Ord b
18:16:54 <Eduard_Munteanu> holla: also, foldl' might be a good idea
18:16:56 * ByronJohnson totally googles this
18:17:00 <holla> \msg Eduard_Munteanu thanks
18:17:18 <siracusa> copumpkin: Ah, forgot about that
18:17:31 <copumpkin> siracusa: if you can restrict it to monotonic functions, you can get away without it
18:17:38 <copumpkin> but someone could screw up the set structure
18:17:39 <Eduard_Munteanu> foldr is useful when the result can be evaluated lazily.
18:18:30 <Eduard_Munteanu> Otherwise you just build a big chain of thunks and collapse them all at once, which isn't a good idea.
18:19:00 <copumpkin> all at once
18:19:05 <copumpkin> I finally took a moment and I'm realizing that
18:19:07 <copumpkin> you're not coming back
18:19:12 <copumpkin> and it finally hit me, all at once
18:19:37 <Eduard_Munteanu> It finally hit me... stack overflow!
18:19:44 <gentleben> hey guys. In yesod how do you switch into the mongoDB (Action m a) monad to run a query
18:20:02 <parcs`> ah damnit, you can't annotate the kinds of associated types :(
18:20:52 <parcs`> copumpkin: wouldn't you have to create a tagged bytestring type?
18:20:55 <gentleben> I need to get out of the handler monad and into the action monad and bind the result of action somehow
18:21:00 <copumpkin> parcs`: good point
18:22:32 <Sgeo> I was having fun fighting with ftphs
18:22:40 <Sgeo> Still more enjoyable than writing PHP code
18:23:01 <kmc> sigh
18:24:04 <Sgeo> @hoogle IO a -> IO ()
18:24:04 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
18:24:04 <lambdabot> Control.Exception.Base block :: IO a -> IO a
18:24:04 <lambdabot> Control.Exception block :: IO a -> IO a
18:24:37 <Sgeo> I'd like a function of that type that I can use to help fight annoyances caused by idiot library writers building in lazy IO
18:24:51 <Sgeo> I ended up putStrLn'ing a bunch of stuff to combat it
18:25:04 <Sgeo> Wait, that's not the type
18:25:06 <kmc> er, what would the function do?
18:25:09 <Sgeo> It would be a -> IO ()
18:25:20 <Sgeo> Force the argument to be evaluated
18:25:22 <kmc> :t Control.Exception.evaluate
18:25:23 <lambdabot> forall a. a -> IO a
18:25:29 <Sgeo> Oh
18:25:34 <kmc> this forces to whnf only
18:25:48 <aavogt> @hackage deepseq
18:25:48 <lambdabot> http://hackage.haskell.org/package/deepseq
18:25:57 <Saizan> ?type \x -> evaluate (rnf x)
18:25:57 <lambdabot> Not in scope: `evaluate'
18:25:58 <lambdabot> Not in scope: `rnf'
18:26:09 <Saizan> booh.
18:26:43 <Eduard_Munteanu> I guess there's no easy/straightforward safeUninterleaveIO :)
18:26:53 <kmc> what would that be
18:27:29 <Eduard_Munteanu> Eh, strictifying IO (undoing unsafeInterleaveIO, hence the pun :D)
18:27:39 <aavogt> you have to know exactly how much to force to get all your IO to happen
18:27:54 <JoeyA> x <- unsafeInterleaveIO $ launchMissiles >> return 5
18:28:07 <JoeyA> This won't launch missiles until you force x
18:28:17 <JoeyA> It's much safer to launch missiles in all cases.
18:28:23 <kmc> you could probably write it with some implementation help
18:28:43 <kmc> but the results might be even more surprising than unsafeInterleaveIO :)
18:28:52 <copumpkin> gwern: someone just told me they read your site for fun
18:28:55 <Eduard_Munteanu> Hm, indeed, deepseq-ing that does more than just strictifying the IO.
18:29:19 <gwern> copumpkin: there must be something wrong with them. better figure out what before you wake up in the basement during the least fun part of a satanic ritual
18:29:31 <copumpkin> :O
18:29:57 <JoeyA> safePerformIO :: IO a -> IO a; safeInterleaveIO :: IO a -> IO a
18:30:14 <aavogt> one example: what order do effects of x and y happen for:    do z <- liftM2 (,) (unsafeInterleaveIO x) (unsafeInterleaveIO y); unsafeUnInterleaveIO z
18:30:36 <JoeyA> safeInterleaveIO ensures the action is not performed until you invoke the resulting action.
18:30:43 <aavogt> JoeyA: that doesn't look like interleaving at all
18:31:00 <JoeyA> aavogt: Exactly :P
18:31:05 <Eduard_Munteanu> Heh.
18:31:12 <shachaf> doubleSafePerformIO :: IO a -> IO (IO a); spawn :: IO a -> IO (IO a)
18:31:24 <copumpkin> satan :: IO (IO a) -> a
18:31:26 <aavogt> there are a bunch of ways to get concurrency
18:31:36 <aavogt> spoon :p
18:31:45 <JoeyA> IO (IO a) -> a: doubleJoin :-)
18:31:47 <Eduard_Munteanu> Wait, doesn't double unsafe make it safe :P
18:31:49 <Eduard_Munteanu> ?
18:32:31 <Eduard_Munteanu> Apparently not if it's unsafePerformIO . join
18:53:43 <ihateurface> haskell is gay, k ty bye
19:08:10 <hpaste> sal pasted “Typeclass implementation doesn't compile” at http://hpaste.org/55356
19:08:50 <sal23> can't get above code to compile
19:11:18 <kmc> i hereby present the employee of the month award to ihateurface
19:12:38 <kmc> sal23, you have to write te instances for AClass and BClass separately
19:12:53 <ski> ByronJohnson : i don't understand your `foo :: (Foo a b, Eq a) -> a' example
19:13:04 <ski> ByronJohnson : no, i wasn't unaware of `ConstraintKinds', that `RMonad' is sortof that (but using true constraint kinds will be nicer)
19:13:08 <ski> parcs` : "how can you make ByteString a functor?" -- you can't
19:13:09 <ski> Eduard_Munteanu : it probably ought to be `interleaveACIO :: ACIO a -> ACIO a'
19:14:08 <sal23> kmc, can you elaborate a bit more? implement f1 for Aclass val, and then f2 for BClass val?
19:14:50 <hpaste> kmc annotated “Typeclass implementation doesn't compile” with “Typeclass implementation doesn't compile (annotation) (for sal23)” at http://hpaste.org/55356#a55357
19:15:29 <sal23> kmc, thanks…and also, add FlexibleInstances declaration, it seems
19:16:22 <kmc> not needed
19:16:33 <kmc> i just loaded the file without it
19:17:41 <sal23> kmc, looks like it depends on the compiler…I am using ghc 7.0.3
19:17:52 <sal23> but thanks…that solved the problem
19:17:53 <kmc> no it doesn't
19:18:00 <kmc> i'm using 7.0.4
19:18:07 <kmc> you must have something else in the file
19:18:20 <sal23> right, my bad…must have fixed something up…now it works
19:18:24 <sal23> mixed
19:18:48 <sal23> and I was confused why flexibleinstance declaration is needed here!
19:18:52 <kmc> Haskell is a standardized language, so any Haskell implementation (regardless of which one or what version) is going to accept the same set of instances by default
19:19:22 <sal23> well, if the code is same, then yes
19:20:21 <sal23> so doing something like this, I could add a function to a vector instance
19:25:55 <copumpkin> I wish there were a structure that was almost a map, built on top of fingertree or the like, but with support for measures
19:26:08 <copumpkin> fingertree is very much like a sequence and I need to build mappiness on top of that
19:26:11 <copumpkin> it's possible but annoying
19:26:27 <nh2> why is there no [a] -> Int -> Maybe a in Data.List?
19:26:44 <copumpkin> :t find
19:26:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
19:27:13 <Nereid> nh2: to generalize (!!)?
19:27:29 <copumpkin> yeah, that's kind of dumb, but indexing into lists is annoying anyway
19:27:30 <nh2> Nereid: yes, I don't want it to error
19:27:34 <shachaf> listToMaybe . drop (n-1)
19:27:58 <Nereid> not drop n?
19:28:19 <shachaf> Oh, wait, drop n.
19:28:30 <newsham> drop n like its hot
19:28:44 <nh2> newsham: lol
19:28:46 * shachaf was thinking of a different thing.
19:29:17 <nh2> copumpkin: sure list indexing is annoying, but with Data.List giving all kind of convenience for this, I wondered why this one is missing
19:29:26 <nh2> time to send a patch hehe
19:29:35 <copumpkin> yeah :)
19:31:00 <nh2> what would you give for negative indices? Nothing or error
19:31:28 <shachaf> Nothing, of course.
19:31:30 <newsham> if you've got a Maybe a result you might as well handle all bad cases with Nothing
19:31:37 <newsham> to make it total
19:32:16 <shachaf> newsham: The justification might be that giving (!!) a negative index probably indicates a bug in your program.
19:33:20 <newsham> and indexing past the end might too
19:33:35 <copumpkin> the fingertree package doesn't even have a toList function :o
19:33:40 <shachaf> newsham: Well, not necessarily.
19:33:45 <shachaf> newsham: You don't know how long a list is.
19:33:58 <copumpkin> I do, though
19:35:40 <wavewave> yeah~~~ I implemented pdf annotation in hxournal
19:36:38 <copumpkin> wavewave: how should I pronounce hxournal? :P
19:36:58 <wavewave> I don't know.. how should I pronounce xournal first?
19:37:17 <wavewave> hks-err-nerl
19:38:10 <nh2> wavewave: hxournal, srsly? Sounds interesting. Is it modeled after xournal?
19:38:14 <JoeyA> Maybe it should be based on how Mexico is pronounced?
19:38:50 <MostAwesomeDude> Or Oaxaca.
19:38:51 <wavewave> nh2: it's aiming at being a clone now.. but with some new function
19:38:58 <JoeyA> http://en.wikipedia.org/wiki/Voiceless_velar_fricative
19:39:05 <nh2> btw: name-giving time for [a] -> Int -> Maybe a. I'm currently for "mylist `at` 3". Other proposals?
19:39:09 <MostAwesomeDude> hya-kk-urr-naal
19:39:15 <wavewave> nh2: it has a split view like an emacs currently
19:39:24 <shachaf> JoeyA: The voiceless uvular fricative is way better than the voiceless velar fricative.
19:39:35 <nh2> wavewave: what do you aim for? Does it have pen thickness detection for tablets already?
19:39:43 <wavewave> nh2: Yeah!
19:40:02 <wavewave> nh2: it uses full X11 extension input for wacom tablet now.
19:40:14 <wavewave> nh2: so pen writing is very smooth.
19:40:25 <JoeyA> shachaf: Not to be outdone by the voiced pharyngeal fricative
19:40:45 <wavewave> nh2: ah.. pen thickness is not implemented though.. it's not difficult at all since it's detected.
19:41:22 <wavewave> nh2: if you have a tablet, give it a try. ;-)
19:41:25 <copumpkin> so guys
19:41:29 <copumpkin> I have a datastructure I want
19:41:31 <shachaf> JoeyA: Yes, it is certainly not outdone by the voiced pharyngeal fricative.
19:41:40 <shachaf> JoeyA: Not by the voiceless pharyngeal fricative.
19:42:20 <copumpkin> I want an accumulator datastructure that's ordered by a particular field of its payload, and accumulates (so the number grows monotonically) that field and another field in an efficient way, so I can query it efficiently by both measures
19:42:20 <nh2> wavewave: sounds cool!
19:42:33 <copumpkin> I'm currently building it on top of a fingertree but if people have a simpler idea I'd like it
19:42:42 <copumpkin> I need to be able to insert efficiently in the middle of it
19:42:51 <JoeyA> Is there a total ordering on phonemes, where the relation is "outdoes" ?
19:42:58 <copumpkin> and query it by the two accumulators, as well as by the unaccumulated order value
19:43:18 <wavewave> I contributed to xournal before for a lasso selection and send that patch to the author. but he didn't update it for two years... so I decided to make my own dear haskell version of it.
19:44:00 <JoeyA> How would I go about renaming a package on Hackage?
19:44:11 <copumpkin> deprecate the old one, upload a new one
19:44:16 <copumpkin> (Basically, you don't)
19:45:49 <wavewave> I found that haskell is very good in GUI programming
19:46:01 <wavewave> opposite to common wisdom.
19:46:14 <wavewave> using Lens and coroutine
19:46:19 <JoeyA> copumpkin: How do you "deprecate" it?  Add a new version and put a message in the description saying ***DEPRECATED   PROCEED WITH ALL CAPS***
19:46:21 <tgeeky> wavewave: I've seen your code. You're an unconvential programmer :O
19:46:28 <copumpkin> JoeyA: pretty much
19:46:42 <copumpkin> JoeyA: you can get someone to hide the package from the main listing on hackage
19:47:07 <shachaf> Upload a new version of the deprecated package with all the exported values deprecated.
19:47:09 <wavewave> tgeeky : I refactored my code much last night... so it would be a little better looking now.
19:47:22 <copumpkin> refuctoring
19:47:25 <JoeyA> copumpkin: I guess I'll look into that after I've made the new version.
19:47:37 <tgeeky> wavewave: hehe. I looked through several of your githubs. Either way, you're certainly more productive than many
19:47:51 <JoeyA> "you can get someone to hide the package from the main listing on hackage" That's what I want, to keep it from showing up in a Google search
19:47:58 <wavewave> tgeeky: basically I was focusing on implementing new features and just copy and paste at first usually.
19:48:09 <wavewave> later, I am renaming things..
19:48:32 <JoeyA> unsafeRenameWavewave
19:48:53 <wavewave> also on the way, I am still learning new concepts.. so... my code is a kind of mixture of archaic and new things.
19:49:08 <tgeeky> wavewave: ah. hehe. I can tell
19:49:36 <wavewave> haskell refactoring is really fun.. I also feel like I am collaborating with compiler.
19:49:49 <jessopher> i agree
19:50:05 <wavewave> first, start from very basic type.. later parameterize it..
19:50:18 <wavewave> and use functor, lenses and other more fancy stuffs.
19:50:31 <wavewave> code becomes shorter and shorter.. compiler detect every possible error.
19:50:41 <wavewave> and once compiled.. it just works as it was.
19:51:18 * jessopher makes sure to run hlint after a bleary eyed night of zombie coding
19:52:21 <JoeyA> I sometimes find it hard to spend a bunch of time changing my program with no observable effect on its behavior.
19:52:40 <davean> JoeyA: But you learn so much from why it suggests them :)
19:52:54 <nh2> wavewave: I agree, just had that all day long ;)
19:53:04 <JoeyA> davean: Why what suggests them?
19:53:13 <davean> hlint suggests the changes
19:53:18 <JoeyA> oh
19:54:26 <davean> See hlint change, consider why it suggests the change, consider if it is infact better (I'd say it is about 80% right)
19:54:38 <wavewave> I need to have a habit to make documentation well.. but it's a little cumbersome before I am sure that this is a good design.
19:54:43 <davean> If you activelyy agree with change, apply it and stop making said change suggested
19:59:47 <jessopher> library documentation is not so big a deal, this does this, that does that... but then when you end up with some large body of code, with a non-programatic interface, it becomes a staring match with an empty text editor
20:01:48 <fullofcars> anyone mind trying to answer a question about fparsec?
20:01:49 <kmc> library documentation is a really big deal
20:02:01 <fullofcars> i posted it on stackoverflow
20:02:16 <salisbury> I second kmc on that.
20:02:23 <kmc> when you have 30 modules and 600 functions it's not enough to document each one with one line on what it does
20:02:29 <kmc> you need a high-level overview, saying what to look at first
20:02:31 <jessopher> it is, but there is more lead in to library documentation, software documentation otherwise lacks tools, and lacks a good starting point
20:02:34 <kmc> preferably with lots of examples
20:03:27 <kmc> not so useful to have 20 pages of {- | Frobnitz the woozles -}  frobnitzWoozle :: Int -> IO Char
20:03:34 <monochrom> haskell tutorial is not a big deal.
20:03:52 <Veinor> i agree with kmc here
20:04:12 <aavogt> the types can be designed to be easier to follow
20:05:03 <ByronJohnson> I'm really impressed by iterIO.  It's very well documented, elegant, simple, consistent, and clean.
20:05:03 <jessopher> i dont think there any disagreement anyhow. Just that documenting a library has a much clearer format, and an audience you as a programmer can relate to more easily
20:05:19 <Veinor> i wrote something on that actually, about not using single-letter type variables unless it's something like m or a
20:05:47 <aavogt> maybe haddock can allow both
20:05:54 <fullofcars> usually when i read code, a like to know what it means
20:05:58 <fullofcars> *I
20:06:12 <jessopher> i think most people like that in anything they read
20:06:23 <fullofcars> true enough
20:07:07 <davean> I prefer well named variables but Iprefer no meaningfull name over a slightly wrong one
20:07:20 <Saizan> i honestly think one should stick to single letter type variables as much as possible
20:07:43 <Saizan> the scope is generally very small, what matters is the structure of the type
20:07:57 <Saizan> though good conventions on which letters to use helps
20:08:01 <drull95> holy moly: ((((((mapMessages .).).).).).) . topDownResolver'
20:08:02 <ski> Veinor : sometimes there's a clear role for the type variable, like `key' and `value', in which case i think it's fine to use long names
20:08:05 <drull95> that's some composing
20:08:22 <jessopher> i read something recently about the 'broader the scope' of the variable, the less verbose it should be. since it is in general going to have a broader meaning, and you are more likely to run into 1 offs, and a lot of redundancy
20:08:27 <Veinor> ski: see, the problem i had was it took me a while to figure out what the b and v in Initializer b v a represent
20:08:28 <parcs`> @unpl ((((((mapMessages .).).).).).) . topDownResolver
20:08:28 <lambdabot> (\ i l o r u x aa -> mapMessages (topDownResolver i l o r u x aa))
20:08:50 <ski> but as davean says, misleading names are worse that meaningless ones
20:09:19 <ski> Veinor : yeah, they should at least document / use long names, when defining the type/class
20:09:31 <ski> (i.e., in case there's sensible long names)
20:09:43 <Veinor> yeah, i mean if there's sensible long names because one type 'represents' something
20:10:01 <Veinor> like Form m input error view a instead of Form m i e v a
20:10:02 <ski> i don't really think `State s result' is better than `State s a'
20:10:10 <ski> (however expanding `s' to `state' is fine)
20:10:25 <ski> Veinor : *nod*
20:10:31 <Veinor> yeah, 'a' is generally pretty reasonable
20:10:34 <Veinor> and so is m
20:11:29 <drull95> parcs', ah i see, one compose for each argument
20:11:44 <jessopher> i think its more important for more complicated sets of variables, 2 variables, x y, whatever. a b x y f g probably deserves some description
20:11:46 <drull95> now i can use it on others :)
20:12:17 <ski> jessopher : heh, i tend to do the opposite -- i.e. use longer names for exported operations than for local ones (especially ones inside `where'/`let' or parameters)
20:12:55 <drull95> all: learn from this one-liner I just posted, there is no need for variable names at all
20:12:58 <drull95> :)
20:13:11 <ski> (however, it's true that for "global" operations, one usually wants more commonly used ones to have shorter names)
20:13:32 <jessopher> i tend to run into more issues with tangled messess of giberish in local scopes.
20:14:00 <jessopher> where things are left for long periods of time to be forgotten
20:23:39 <Axman6> well, this has been fun. just got my first OpenCL from Haskell program working, using the new OpenCL monad I wrote... time to upload to github!
20:23:59 <copumpkin> is there no way to extract a measure from a fingertree?
20:24:11 <copumpkin> other than fmapping it over the entire tree using fmapWithPos?
20:25:21 <hpaste> scooty-puff pasted “Let Generalization Limitations” at http://hpaste.org/55358
20:25:40 <Guest61932> would anyone be able to explain why the above paste does not compile?
20:25:57 <Guest61932> (if i comment out "where h x = ... ", it does compile
20:26:33 <Guest61932> i assume it has something to do with how a modified callset is computed, for use in computing the extra set
20:26:57 <Guest61932> (where the callsets of nested functions are merged into the outer function's callsets - even, apparently, if not called)
20:27:19 <ski> @type let f x = g True `seq` g [] `seq` x; g x = x where h x = f x `seq` False in f
20:27:19 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Bool'
20:27:20 <lambdabot>       Expected type: [a] -> a1
20:27:20 <lambdabot>       Inferred type: Bool -> a2
20:27:22 <ski> @type let f :: a -> a; f x = g True `seq` g [] `seq` x; g x = x where h x = f x `seq` False in f
20:27:22 <lambdabot> forall a. a -> a
20:27:49 <Veinor> Guest61932: even though you don't call h, it still has to typecheck, so f :: a -> Bool
20:27:52 <Guest61932> in that case it makes sense - g is a monotype relative to f
20:28:03 <Guest61932> k
20:28:06 <Guest61932> (my response was to ski)
20:28:20 <Guest61932> (first response was, anyways)
20:29:49 <ski> @type let f x = g True `seq` g [] `seq` x; g :: a -> a; g x = x where h x = f x `seq` False in f
20:29:50 <lambdabot> forall t. t -> t
20:29:55 <Guest61932> ski, to make sure i read it write - the only difference was the addition of an explicit signature?
20:30:02 <ski> yes
20:30:15 <Guest61932> hmm
20:32:09 <drull95> How would I go about trying to find from where a package is being imported from?
20:32:15 <drull95> i'm trying to use Language.Haskell
20:32:24 <ski> i suppose in the case of no explicit signature, it basically compiles like :  f a = fst (fg a); g a = snd (fg a); fg a = (f,g) where f x = g True `seq` g [] `seq` x; g x = x where h x = f x `seq` False
20:32:28 <drull95> but the constructors are different from the documentation
20:33:11 <drull95> i tried grepping through the source of haskell-src package and through ghc 7 source but i don't find what I'm looking for
20:33:19 <ski> i.e. since `f' and `g' are in the same binding group, it insists of the `a' in the types of both being the same -- and you get around this in the same way as for polymorphic recursion
20:33:42 <ski> i'm not sure whether this behaviour in this case is according to the standard or not, though
20:33:47 <drull95> the constructors don't have the hs prefix and some have different arities while a few are not found
20:35:20 <ski> (so, in the expansion above, we have `f :: forall a. a -> a; g :: forall a. a -> a; fg :: forall a. (a -> a,a -> a)' for the top-level bindings, and for the inner bindings we have `f :: a -> a; g :: a -> a; h :: a -> Bool' (note, no `forall a. ', here))
20:38:05 <copumpkin> anyone know about my fingertree question?
20:38:08 <copumpkin> it seems annoying
20:38:21 <shachaf> No, I haven't heard of your fingertree question.
20:38:36 <jessopher> drull95: ghc-pkg will give you some idea of what versions of a package the import if from. You could also constrain your dependency to exactly match the version from the documentation, with cabal
20:38:36 <shachaf> What is the question?
20:38:56 <copumpkin> oh, I guess I can use measured on the subtrees that I split
20:39:07 <copumpkin> I suppose that's the way they expect me to do it
20:39:14 <scooty-puff> ski, ok, that makes sense
20:39:27 <drull95> i tried ghc-pkg find-module "Language.Haskell", it gave me derive
20:39:39 <drull95> it should've given me haskell-src i think
20:39:50 <drull95> but my packages are all messed up anyway
20:40:03 <drull95> they are all fighting over the text package
20:40:22 <jessopher> i get derive as well
20:41:00 <drull95> does it only list one at time? it would make more sense that it would return all matches, but you never know
20:41:16 <jessopher> however, Haskell.Language.Syntax gives me haskell-src
20:42:30 <ski> scooty-puff : see 4.5.1,4.5.2 and 4.5.4 under <http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5>
20:42:43 <jessopher> well if more than one package provides the module without package qualification, your program wouldnt compile
20:42:56 <ski> scooty-puff : in short, i think this behaviour is according to standard
20:43:32 <jessopher> if you want 'the other one' you will have to explicitly state it
20:43:36 <drull95> neither find-module "Haskell.Language.Syntax" or find-module "Language.Haskell.Syntax" returns anything for me
20:44:11 <jessopher> do you have haskell-src?
20:44:12 <drull95> i'm just going cabal unpack everything and grep through that
20:44:21 <ski> scooty-puff : because `f' and `g' are mutually recursive, i think they first get monomorphic types inferred, at the *same* time. these types mention the same type variable `a', which is why the example didn't type check. then these types are generalized, so `forall a. ' is added to them
20:44:37 <copumpkin> how do I construct a plain ol' map out of a fingertree?
20:44:52 * jessopher meant Language.Haskell.Syntax
20:45:06 <drull95> jessopher, i figured :)
20:45:15 <drull95> but i tried it anyway out of curiosity
20:46:22 <copumpkin> can I not do that?
20:47:27 <copumpkin> hmm, I always assumed you could do that without thinking through the details, but it seems I can't
20:50:13 <copumpkin> I really just want an annotated Data.Map
20:51:55 <drull95> copumpkin, looking at the docs i see that pattern matching on ViewL will split a list into the first element and the rest of the stream
20:52:09 <copumpkin> yeah, but how does that help?
20:52:19 <drull95> what kind of key do you want?
20:52:20 <copumpkin> I need to be able to search on an ordered key
20:52:25 <copumpkin> search-tree style
20:53:02 <drull95> you could iterate the viewl over the fingertree and then zip with natural numbers
20:53:40 <drull95> i dont know what im talking about anyway , ignore me
20:53:44 <copumpkin> how does that let me search by an arbitrary number? say my key is an unconstrained number
20:54:09 <drull95> could i have more details about what you're trying to do
20:54:11 <copumpkin> I could map it to a max "monoid", but I don't think that'd give me what I want
20:54:33 <copumpkin> drull95: a Data.Map that lets me efficiently query measures (of the same sort that are used in Fingertree) on its subtrees
20:54:44 <copumpkin> it already does that for a particular meausre, its size
21:04:19 <drull95> copumpkin, could you write your own binary tree?
21:04:45 <drull95> i was looking at the data.map source and aside from all the performance annotations it doesn't seem too difficult
21:05:29 <copumpkin> drull95: it just seems like a horrible duplication of effort
21:05:36 <copumpkin> when it'd be a trivial annotation on an existing tree
21:05:48 <copumpkin> and isn't something I can really add retroactively to it
21:06:57 <byorgey> copumpkin: use a tree of (k,v) pairs, with a Max monoid on k?
21:08:01 <copumpkin> Max isn't really a monoid though
21:08:13 <copumpkin> I could maybify it
21:08:19 <byorgey> oh, right
21:08:29 <byorgey> yeah, you can use  Data.Semigroup.Options
21:08:32 <byorgey> *Option
21:09:48 <drull95>  ok, be patient with me please, but could you use a tree of (interval, v)?
21:10:10 <drull95> where interval is the max, min of measures in the subtree
21:10:15 <copumpkin> that'd get me an interval tree
21:10:47 <drull95> im just asking to learn but that doesn't work for you?
21:11:19 <dthurn> Q: If I want a function that can return Just, Nothing, or an error, should I use Either String (Maybe a) or is there a more correct way?
21:11:35 <drull95> just use maybe
21:11:42 <drull95> error is polymorphic
21:12:05 <drull95> unless you're talking about exceptions
21:12:25 <byorgey> crashing is different than returning an error.
21:12:31 <dthurn> I sort of thought using the "error" function when things go wrong was uncool compared to using Either
21:12:38 <byorgey> dthurn: it is.
21:12:42 <jessopher> if you need more information about failure than nothing, then use either
21:13:18 <drull95> ah. i misunderstood what he was asking
21:13:27 <dthurn> So Either String (Maybe a) is ok then.
21:13:34 <byorgey> dthurn: Either String (Maybe a) sounds fine.  although having the possibility of Nothing *or* an error sounds a bit strange.  But it could make sense depending on the domain.
21:13:41 <jessopher> dthurn thats over kill
21:13:47 <kmc> "error" is a cool way to indicate unrecoverable programmer error
21:13:53 <kmc> not cool for user error which can be caught and handled
21:14:27 <jessopher> yeah, i guess it could make sense
21:14:32 <byorgey> jessopher: Nothing does not have to be used to indicate an error.
21:14:57 <jessopher> byorgey: i know, but intuition tells me that is what he is trying to use it to indicate
21:15:47 <mzero> dthurn: without knowing why you want three distinct return states, it is impossible for any of us to know --- but I can certainly imagine cases that aren't too far fetched where Either String (Maybe a) seems reasonable
21:16:10 <Saizan> there's also Either (Maybe String) a
21:16:17 <mzero> parsers are examples where three states are desirable
21:16:24 <copumpkin> drull95: interval tree searches in a different way
21:16:56 <copumpkin> but I guess a degenerate case of intervals is what I want
21:21:25 <jessopher> pff, nevermind, yeah, he stated that he wanted 3 states. so much for intuition
21:25:43 <drull95> dthurn, is the error string just a description that you're passing on to be printed later? or are you going to take actions based on what's in the string?
21:26:16 <dthurn> drull95: Probably more options than just printing it. User error, not programmer error.
21:27:24 <drull95> then you might prefer a data type  with constructors for different errors, with a printing function for when you need to display a message
21:27:31 <drull95> more convenient
21:28:28 <drull95> but you probably already figured that out. my bad
21:28:49 <drull95> im like a kid that thinks he knows what
21:28:57 <drull95> s going on but doesn't really
21:31:41 <dthurn> Yeah, I ended up going with Either InputError (Maybe x)
21:32:01 <dthurn> Where there are a view different constructors for InputError with different 'show' behaviors
21:34:33 <jessopher> be careful if you are using it within MonadError and instantiating Error InputError. fail as defined in MonadError for Either does not fail 'within' Either. It just fails
21:42:53 <copumpkin>       instance Monoid a => Monoid (Maybe a) -- Defined in `Data.Monoid'
21:42:56 <copumpkin> fuck that instance
21:43:41 <mikeplus64> does someone know what voodoo does printf from Text.Printf perform to have a variable amount of arguments?
21:43:49 <kmc> yes
21:43:59 <mikeplus64> can you tell  me what it is?
21:44:04 <kmc> bunch of type classes
21:44:08 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/src/Text-Printf.html
21:44:11 <shachaf> copumpkin: Should be Semigroup?
21:44:13 <shachaf> Or what?
21:44:17 <copumpkin> shachaf: yeah
21:44:23 <mikeplus64> ok, will look at that
21:44:26 <copumpkin> there's a separate Option type in semigroups that does that
21:44:34 <copumpkin> but it's just shitty that it has to be that way
21:44:36 <shachaf> copumpkin: This is what OverlappingInstances was invented for, obviously.
21:46:34 <ion> What’s the problem with mempty for that instance?
21:47:07 <shachaf> ion: The problem is requiring it.
21:47:20 <copumpkin> ion: it breaks me wanting to use Max/Min for it
21:47:31 <lars9> i'm still waiting for Yi-Editor, but it's not updating...
21:48:03 <ion> Ah, ok
21:48:30 <copumpkin> byorgey: even if I use a fingertree with a max monoid, I still have to write my own insert operation in terms of split, right?
21:48:36 <copumpkin> the <| is going to give me nonsense
21:50:29 <drull95> strange as it may seem, caffiene puts me to sleep
21:50:49 <JoeyA> drull95: Caffeine is like violence.  If it isn't working, you aren't using enough of it.
21:51:01 * JoeyA has the same problem with cola
21:51:21 <kmc> caffeine is like violence, it's an addictive drug
21:51:39 <drull95> i drank an extra-large coffee about 20 mins ago
21:52:16 <drull95> haskell is not like caffiene, it's ten times as addictive
21:52:16 <mzero> mikeplus64: warning, that way lies maddness
21:52:21 <JoeyA> People do crazy things when they're on caffeine, like tap their fingers on a plastic board while staring at a glowing rectangle for hours on end.
21:57:14 <drull95> ok i figured it out, im using haskell-src-exts and not haskell-src like i thought
22:01:33 <drull95> nope. i'm still confused. i've hid haskell-src-exts and haskell-src-meta and installed haskell-src and i'm still getting the different constructors
22:01:51 <drull95> what else defines Language.Haskell?
22:05:28 <drull95> alright people, clap for me. i've figured out the obvious
22:05:56 <drull95> Language.Haskell was coming from derive, like ghc-pkg find-module was telling me
22:06:18 * bytbox claps, slowly and awkwardly
22:06:19 <drull95> i needed to import Language.Haskell.Syntax instead of just Language.Haskell
22:06:52 <drull95> looks like i needed that coffe
22:06:55 <drull95> e
22:21:32 <drull95> yay! my debugger typechecks. now to actually implement it
22:22:33 <drull95> im teaching myself about compiler internals and i thought a simple debugger would be a good way to start
22:27:55 <shachaf> drull95: What sort of debugger/
22:27:58 <shachaf> s/.$/?/
22:31:30 <drull95> it just transforms pure expressions into io ones
22:32:46 <drull95> it binds them to a variable after changing it into an action that will highlight the expression before pausing
22:33:45 <drull95> it will change the performance and probably how it's evaluated
22:33:58 <drull95> but i'm not trying to do anything too fancy
23:11:00 <Axman6> Would anyone mind taking a look at my latest blog post on the improvements I've made for using OpenCL in Haskell? http://www.reddit.com/r/haskell/comments/ng5no/opencl_from_haskell_hello_world_making_opencl/
23:21:25 <salisbury> Axman6 I shall do so.
23:21:37 <Axman6> thanks
23:27:24 <salisbury> Axman6 well written. I am unfamiliar with the content (openCL) so I can't comment much on that though
23:27:56 <salisbury> are you using opencl for the electric meter reading application?
23:29:06 <Axman6> no, but i'm running plenty of OpenCL code which i'm using that code for
23:29:38 <Axman6> the power meter only reports new power readings every second, so there's not much analysis that using OpenCL would be useful for :P
23:30:55 * Axman6 ->  heading out... is welcome to more feedback while he's gone though...
23:43:17 <mikeplus64> bleh, hardly any of the links on the haskell wiki that point to www.cse.unsw.edu.au work
23:43:41 <mikeplus64> which is a huge number of links :(
23:47:59 <Axman6> mikeplus64: it's all dons' stuff, which got removed sadly :(
23:48:13 <mikeplus64> where did it all go?
23:51:29 <shachaf> Axman6: It's not all dons!
23:54:27 <Axman6> mikeplus64: as far as i know, it's mostly been deleted sadly. check out wayback.org to see if you can retrive it
23:58:38 <mikeplus64> Axman6: damn, but ok
