00:00:59 <ion> Because lambdabot has a Num (a -> a) instance.
00:01:01 <ion> > 5 6
00:01:02 <lambdabot>   5
00:01:53 <ion> @unpl ((.).(.).(.)) ((+).(+)) (((+).).(+)) 2 3 4 (+ 1) 5
00:01:53 <lambdabot> ((+) ((2 + 3) + 4)) + \ k -> k + 1 5
00:30:19 <Sgeo> :t f
00:30:20 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
00:30:30 <Sgeo> > f
00:30:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:30:31 <lambdabot>    `SimpleReflect.FromExpr ...
00:30:34 <Sgeo> > f g
00:30:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:30:35 <lambdabot>    `GHC.Show.Show a'
00:30:35 <lambdabot>      a...
00:30:38 <Sgeo> > f 1
00:30:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:30:38 <lambdabot>    `SimpleReflect.FromExpr ...
00:30:48 <Sgeo> Wasn't there a thing where it could show the results?
00:30:51 <Sgeo> > f 'a'
00:30:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:30:52 <lambdabot>    `GHC.Show.Show a'
00:30:52 <lambdabot>      a...
00:30:55 <Sgeo> Not the results
00:31:03 <Sgeo> But something like making folds easier to understand
00:31:18 <Sgeo> foldr f z [1,2,3]
00:31:20 <Sgeo> > foldr f z [1,2,3]
00:31:21 <lambdabot>   f 1 (f 2 (f 3 z))
00:31:24 <Sgeo> Like that
00:32:57 <copumpkin> > f :: Expr
00:32:58 <lambdabot>   f
00:33:04 <copumpkin> > f g :: Expr
00:33:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:33:05 <lambdabot>    `GHC.Show.Show a'
00:33:05 <lambdabot>      a...
00:33:12 <copumpkin> > f (g :: Expr) :: Expr
00:33:13 <lambdabot>   f g
00:35:01 <Sgeo> :t ((undefined::a->b) .) . (. (undefined::a->b))
00:35:01 <lambdabot> forall b a b1 a1. (a -> b1) -> a1 -> b
00:35:25 <Sgeo> Uh, that makes no sense.
00:35:34 <Sgeo> I guess it makes sense that that makes no sense
00:35:36 <copumpkin> why not?
00:35:43 <Sgeo> The b is coming from nowhere
00:35:45 <copumpkin> the a and b aren't the same
00:36:20 <copumpkin> type variables you make up in different type annotations aren't gonna be the same (how could it know the scoping you wanted?)
00:36:32 <Sgeo> That's not what I was referring to
00:36:50 <Sgeo> But n/m my question
00:37:11 <copumpkin> [10:09:40 AM] <Sgeo> The b is coming from nowhere
00:37:19 <copumpkin> that's because you made it up
01:02:18 <Sgeo> Writing a library that exposes enumerator related stuff. Any suggestions on which enumerator library to use?
01:06:30 <akosch> how could I check if a list has at least one element besides pattern matching (and length)?
01:07:58 <mgsloan> > (not . null) []
01:08:00 <lambdabot>   False
01:08:10 <ciaranm> @hoogle [a] -> Bool
01:08:10 <lambdabot> Prelude null :: [a] -> Bool
01:08:10 <lambdabot> Data.List null :: [a] -> Bool
01:08:10 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
01:08:48 <alistra> foldl (\y x -> y +1) 0 [1,2]
01:09:51 <akosch> thanks, null it is
01:10:42 <The_Journey> how would I count up the number of Nothing elements in a list of Maybe a?
01:11:17 <Sgeo> > drop 5 []
01:11:17 <Saizan> length . filter isNothing
01:11:18 <lambdabot>   []
01:11:43 <Sgeo> atLeast = not . null . drop
01:11:43 <Sgeo> ?
01:12:01 <The_Journey> Saizan: could isNothing be a lambda? What would the syntax be?
01:14:19 <The_Journey> I can't pattern match using lambda function right?
01:14:37 <Sgeo> What is meant by pattern matching using lambda?
01:14:49 <Sgeo> > (\(Just x) -> x) (Just 5)
01:14:50 <lambdabot>   5
01:15:14 <Sgeo> I don't know if you can handle separate cases without a case of
01:15:24 <Sgeo> But there is an isNothing function
01:15:26 <Sgeo> :t isNothing
01:15:26 <lambdabot> forall a. Maybe a -> Bool
01:15:43 <The_Journey> Sgeo: yea but let's instead of Maybe, I use my own ADT
01:16:08 <ciaranm> The_Journey: case
01:16:20 <Sgeo> > (\x -> case x of { Just x' -> x'; Nothing -> 0 }) (Just 5)
01:16:21 <lambdabot>   5
01:16:25 <Sgeo> > (\x -> case x of { Just x' -> x'; Nothing -> 0 }) Nothing
01:16:25 <lambdabot>   0
01:16:28 <ciaranm> The_Journey: although a let/in or where might be cleaner
01:16:40 <The_Journey> ciaranm: what would it look like?
01:16:51 <ciaranm> The_Journey: i suggest working your way through LYAH
01:17:28 <Saizan> you need two patterns to write isNothing
01:17:39 <Sgeo> > (let maybeToNum (Just x) = x; maybeToNum Nothing = 0 in maybeToNum 5)
01:17:40 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
01:17:40 <lambdabot>    arising from a use of...
01:17:45 <Saizan> (\(Just x) -> x) is fromJust
01:17:48 <Sgeo> > (let maybeToNum (Just x) = x; maybeToNum Nothing = 0 in maybeToNum (Just 5))
01:17:49 <lambdabot>   5
01:17:56 <Sgeo> > (let maybeToNum (Just x) = x; maybeToNum Nothing = 0 in maybeToNum (Nothing))
01:17:56 <lambdabot>   0
01:18:21 <The_Journey> ciaranm: I already went through LYAH's List Chapter, I just want to know how I can pattern match using lambda, what would the case-in syntax look like?
01:18:32 <ciaranm> The_Journey: carry on reading
01:20:35 <Nereid> to what extent can we say that the types () and (forall a. a) are isomorphic?
01:24:44 <mgsloan> Sgeo: pattern matching on data types with more than one constructor with lambdas gives you partial functions - they can fail
01:32:27 <k0ral> joe9: yes I've tried it
01:34:56 * hackagebot haskell-updater 1.2.0.2 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.2 (SergeiTrofimovich)
01:41:34 <k0ral> hey guys, say we have a :: IO (Maybe a), b :: a -> Maybe a and c :: a -> IO (Maybe a), I would like to write something like a >>= b >>= c but it won't work; is there a trick to use such a monadic syntax ?
01:45:31 <copumpkin> MaybeT IO?
01:48:33 <k0ral> copumpkin: reading about that
02:04:04 <salisbury> what more does the latest GHC have than, say, 6.10.1
02:05:58 <Bynbo7> salisbury: that's pretty ancient...
02:06:06 <Bynbo7> it still has n+k patterns!
02:06:49 <salisbury> yeah, I think it's from 2008
02:06:57 <c_wraith> salisbury: possibly most usefully, a completely rewritten IO manager designed for much higher performance
02:07:07 <c_wraith> But honestly, a lot has changed since then
02:08:08 <salisbury> I'm running 7.0.3, should I upgrade?
02:08:26 <salisbury> (I just saw a reddit link about 7.4.something)
02:09:04 <c_wraith> maybe to 7.0.4
02:09:13 <c_wraith> the 7.2 series is mostly experimental
02:09:17 <c_wraith> and 7.4 isn't done yet
02:09:24 <c_wraith> You saw a link to the release candidate for it
02:10:22 <c_wraith> 7.4 might have some of the biggest new stuff in it, but the release candidate is certainly going to be rough around the edges.  much stuff on hackage won't build with it just yet, for instance
02:10:46 <salisbury> does 7.2 allow anything really interesting?
02:11:42 <c_wraith> I seem to recall it had some neat stuff in it, but I can't recall what...  Aside from the new generics mechanism, anyway
02:12:06 <gienah> snap, darcs, xmonad and other stuff can be persuaded to build with ghc 7.4.1-rc1, persistent and happstack-server look more difficult
02:47:35 <drdo> Is there some library with IO exception handling stuff using MonadIO instead of IO directly?
03:09:59 * hackagebot wai-middleware-route 0.1.0.2 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.1.0.2 (AlexanderDorofeev)
03:10:01 * hackagebot yesod-form 0.3.4.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.3.4.1 (FelipeLessa)
03:20:00 * hackagebot wai-middleware-catch 0.1 - Wai error catching middleware  http://hackage.haskell.org/package/wai-middleware-catch-0.1 (AlexanderDorofeev)
03:40:32 <applicative> are files with the extension "Blah.hs.in" for happy or alex or what?
03:42:07 <alistra> i'm having permanent problems with cabal
03:42:19 <alistra> and i don't have an idea how to fix it
03:43:01 <alistra> http://dpaste.com/677372/ <- it's usually this
03:43:03 <applicative> what is the problem?
03:43:19 <alistra> when i try to recompile cabal/process/directory it crashes other packages
03:43:28 <alistra> and when i recompile them it crashes those again
03:43:54 <applicative> hm, cabal-dev, might introduce complications i wouldn't understand
03:44:05 <applicative> what os are you using
03:44:05 <alistra> not rly
03:44:12 <alistra> i had the same problems
03:44:14 <alistra> gentoo
03:45:28 <alistra> there's no difference if i do it user/system/cabal-dev scoped
03:45:28 <applicative> it looks like you have confused ghc-pkg with more than one version of Cabal-1.10.2.0 , likewise directory.
03:45:33 <alistra> always the same problem
03:46:01 <applicative> one possibility is that you have overwritten them, but maybe it is something more complicated with your distro.  have you installed a lot of packages with emerge or whatever its called
03:46:16 <alistra> uh
03:46:33 <alistra> i havent changed nothing with emerge since the state that cabal worked
03:46:52 <alistra> http://dpaste.com/677373/ ghc-pkg list, maybe that helps
03:46:55 <applicative> ghc-pkg is looking for a lib with a certain hash, but you have overwritten it somehow, by installing in some other way ... <- that's my halfbaked thought
03:47:14 <applicative> what does ghc-pkg check say is broken
03:47:55 <alistra> nothing
03:48:31 <applicative> hm, what bugs me about ghc-pkg list is that there are too many things in the global section, i just keep the libraries grouped in the 'haskell platform' as global, then set cabal install to defaul to my space
03:48:39 <applicative> it looks like you do that too though
03:48:55 <alistra> i need those globals for the xmonad
03:48:59 <alistra> set of packages
03:49:16 <applicative> ah, xmonad, yes
03:49:26 <alistra> also have alex/haddock/happy globally because it crashes if i try to install them from cabal locally
03:49:54 <alistra> with the same thing now
03:50:08 <applicative> hmm hmm. i was going to advise starting over with something like the haskell platform libs only from emerge then local cabal install for everything else, but one would prefer xmonad from emerge
03:50:09 <alistra> how can i unregister a package but only in user scope
03:50:20 <alistra> no
03:50:24 <alistra> i have xmonad from cabal
03:50:59 <applicative> ghc-pkg unregister foo --user , I think
03:51:03 <alistra> oh god
03:51:34 <applicative> oh i see. how did so much get into the global registry for ghc-pkg? i was thinking that was from the distro
03:51:45 <alistra> nope
03:51:56 <alistra> i cabal installed xmonad from root
03:52:35 <applicative> oh, is that necessary? i haven't done that, but i haven t used it lately
03:53:09 <ben_m> Suppose I want a non-Haskeller to check out the program I'm currently writing, what would be the best method to do so, given that we're on different architectures?
03:53:15 <applicative> i mean is it necessary for you to do xmonad as root
03:53:40 <drdo> ben_m: send source and runhaskell ?
03:53:53 <applicative> ben_m, you mean, how does he get ghc on his platform?
03:55:02 <applicative> alistra, my idea, which is totally speculative -- i only have experience not real understanding -- is that the superuser install of xmonad overwrote the old process and so on
03:55:46 <applicative> now the things that depended on e.g. Cabal-xyz-UUSJJAO1281j are desperately looking for it
03:56:02 <alistra> applicative: xmonad was here all along
03:56:12 <alistra> it's something with the other pkgs
03:56:28 <alistra> i'll try to unregister all the local stuff
03:56:41 <alistra> and redo it with cabal-dev
03:56:42 <applicative> alistra, this is how i have gotten errors like that, usually by building ghc-head and not taking precautions to separate cabal installed things from the boot packages or whatever they are called
03:57:38 <alistra> srsly
03:57:43 <alistra> cabal needs fixin
03:57:52 <ben_m> I apologize in advance if I mix up things here, but would it be feasible to set up a private cabal repo for development, so that non-programmers could simply do something like cabal install our-project?
03:57:53 <applicative> the Cabal library was installed with ghc, it is integrated with it
03:58:16 <alistra> ben_m: cabal repo? you can put a project on github
03:58:21 <alistra> with a .cabal file
03:58:31 <alistra> and then somebody can just cabal install from the directory
03:58:34 <alistra> after checking out
03:58:59 <ben_m> alistra, yeah I don't know how the whole building process with cabal actually works, hence the pre apology because I knew I'd get it wrong :P
03:59:12 <ben_m> That sounds good though
03:59:24 <alistra> it looks somehow that my system-wide libs
03:59:34 <alistra> depended on my local user libs (?)
03:59:53 <alistra> ben_m: iirc you do like cabal init
03:59:58 <alistra> and it asks you questions
04:00:37 <alistra> and then you do while(cabal says it needs something) { add that something to deps in .cabal; redo the build }
04:00:55 <alistra> actually it should be a do-while
04:01:33 <alistra> also my process/directory get reinstalled each time, is it intentional?
04:01:56 <ben_m> I'm asking this because I frequently work with people who refuse to do anything but double-click on files, so I used Clojure for a while solely because I could build one giant jar they could run. Really want to use Haskell for my next project though, so I'm looking for ways to make the switch easier for them :)
04:02:22 <alistra> cabal install
04:02:27 <alistra> and they have a binary
04:02:30 <alistra> compiler
04:02:31 <alistra> compiled
04:02:43 <ben_m> Just need the Haskell Platform for that, right?
04:02:56 <alistra> nope
04:03:21 <alistra> haskell platform is a big package of independent packages
04:03:35 <alistra> that someone tested that works with each other withot dependency hell :P
04:03:50 <alistra> you can install all the stuff by hand if you like and it'll work, probably
04:04:36 <ben_m> Ah whatever, they'll learn ;)
04:04:43 <donri> windows or osx?
04:05:10 <ben_m> Question directed at me?
04:05:14 <donri> surely you can precompile for those platforms
04:05:27 <donri> with static linking or whatever
04:06:07 <ben_m> Maybe
04:08:14 <alistra> cabal: Missing dependency on a foreign library:
04:08:14 <alistra> * Missing (or bad) header file: runProcess.h
04:08:14 <alistra> This problem can usually be solved by installing the system package that
04:08:14 <alistra> provides this library (you may need the "-dev" version). If the library is
04:08:14 <alistra> already installed but in a non-standard location then you can use the flags
04:08:15 <alistra> --extra-include-dirs= and --extra-lib-dirs= to specify where it is.
04:08:15 <alistra> If the header file does exist, it may contain errors that are caught by the C
04:08:16 <alistra> compiler at the preprocessing stage. In this case you can re-run configure
04:08:16 <alistra> with the verbosity flag -v3 to see the error messages.
04:08:17 <alistra> cabal: Error: some packages failed to install:
04:08:17 <alistra> process-1.1.0.0 failed during the configure step. The exception was:
04:08:18 <alistra> ExitFailure 1
04:08:18 <alistra> xmonad-0.10 depends on process-1.1.0.0 which failed to install.
04:08:19 <alistra> xmonad-contrib-0.10 depends on process-1.1.0.0 which failed to install.
04:08:30 <alistra> way to go, my system wont have xmonad if i reboot now
04:10:10 <thalll> should ghc 7.0.4 use llvm-gcc-4.2 or gcc-4.2, right know gcc is symlinked to llvm-gcc-4.2. Using osx 10.7
04:14:03 <WarzoneCommand> simple question. I have two values of type Maybe a (with Ord a), and I want to compare them (e.g. using < ) to result in a Bool. What would be the nicest way of doing that?
04:14:33 <dschoepe> WarzoneCommand: What would you want the result of compare Nothing (Just foo) to be?
04:14:37 <WarzoneCommand> so in some sense I want to lift (<) to Maybe a, but I don't want the result to be of type Maybe Bool (but just Bool)
04:15:04 <alistra> on (>) (fromJust) m1 m2
04:15:05 <alistra> :D
04:15:09 <alistra> it will crash on nothing
04:15:22 <alistra> > on (>) (fromJust) (Just 2) (Just 1)
04:15:23 <lambdabot>   True
04:15:45 <dschoepe> > fromMaybe False $ liftA (<) (Just 1) (Just 2)
04:15:46 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Bool.Bool'
04:15:46 <lambdabot>         again...
04:15:52 <dschoepe> > fromMaybe False $ liftA2 (<) (Just 1) (Just 2)
04:15:53 <lambdabot>   True
04:15:58 <dschoepe> > fromMaybe False $ liftA2 (<) (Just 1) Nothing
04:15:59 <lambdabot>   False
04:16:54 <alistra> you kids and your fancy combinators
04:17:00 <alistra> @src liftA2
04:17:00 <lambdabot> liftA2 f a b = f <$> a <*> b
04:17:04 <WarzoneCommand> hmm
04:20:45 <alistra> FUCK YOU CABAL
04:20:53 <alistra> WHAT THE FUCK
04:21:31 <alistra> http://dpaste.com/677378/
04:24:15 <dschoepe> alistra: Did you mix your distro's Haskell packages with manually cabal-install'ed packages?
04:40:56 <alistra> no
04:41:08 <alistra> i don't install packages from gentoo for like 3 months now
04:41:15 <alistra> why does everybody keep suggesting that
04:42:27 <alistra> maybe those 3 months old pkgs are still fucking something up, anyway i'm ripping out all the haskell stuff from my os
04:42:32 <alistra> and redoing it
04:42:53 <gienah> if stuff is cabal installed as root then it is installed in the ghc global database, where it will be mixed up with the os pkgs
04:42:55 <alistra> what's the recommended way on gentoo? haskell platform or the haskell overlay and single pkgs there?
04:43:44 <gienah> the most up to date packages are in the gentoo haskell overlay
04:45:18 <alistra> do i want the most up-to-date pkgs?
04:45:48 <gienah> I'm not sure, but that's what you will mostly find in the gentoo haskell overlay
04:47:22 <gienah> with the gentoo ebuilds, when stuff is bumped (which it is, often), you can run haskell-updater and it will try to rebuild all the broken packages
04:47:58 <alistra> > try
04:47:59 <lambdabot>   Not in scope: `try'
04:48:28 <alistra> it was a quote try, not a eval try, you stupid, stupid robot
04:48:35 <gienah> sometimes if a lots of packages (100s) and a low level package with lots of dependencies, like text, is bumped, then it may be necessary to run haskell-updater more than once
04:49:28 <alistra> gienah: you have gentoo?
04:49:41 <gienah> alistra: I'm a gentoo developer
04:49:47 <alistra> gienah: you have gentoo?
04:50:06 <gienah> alistra: of course :-)
04:50:10 <alistra> i will be a mac developer in a week and i don't own a mac
04:50:12 <alistra> so you know
04:50:27 <alistra> do you have the platform or just single pkgs?
04:50:59 <gienah> just single pkgs, the haskell-platform seems kind of old since its for ghc 7.0.4
04:51:10 <alistra> well that's my ghc :|
04:51:16 <alistra> maybe i'll update it
04:52:15 <gienah> the gentoo-haskell overlay has ghc 7.2.2 and 7.4.1-rc1 as well as 7.0.4 and 6.12.3, of those 7.2.2 is probably best for being capable of building most stuff
04:52:34 <alistra> what's wrong with 7.4?
04:52:39 <nus> alistra, doesn't cabal-dev keep per project GhcPkgDb?
04:52:56 <alistra> nus: it doesn't help in not-crashing
04:53:02 <merijn> alistra: 7.4 is a tech preview release, not a stable release, afaik
04:53:23 <gienah> I really like ghc 7.4.1-rc1, at the moment though happstack-server and persistent fail to build with strange compiler errors which I don't know how to fix
04:53:34 <alistra> gienah: are the 7.2.2 and generally stable packages marked stable in the overlay?
04:53:54 <alistra> not ~
04:54:05 <nus> alistra, you pasted the contents of the system- and user- wide db's, what's in the project's db?
04:54:06 <gienah> alistra: no almost everything in the overlay is masked, and needs to be unmasked
04:54:15 <alistra> nus: how to check it
04:54:25 <alistra> gienah: that's a pity
05:03:02 <nus> aliak, find <projectDir> -name packages*conf
05:03:06 <nus> err
05:03:11 <nus> alistra, ^^^
05:04:06 <alistra> anyway i'll resume it later, christmas eve now
05:04:15 <alistra> or whatever is now
05:04:17 <alistra> easter?
05:12:47 <applicative> alistra, did you read monochrom's page on cabal vs. package managers? http://www.vex.net/~trebla/haskell/sicp.xhtml
05:14:50 <etpace> Enigmagic: I've implemented vector application - I went from x30 to x0.7 :) I was just generating too much garbage! I'm now working on a full implementation of lambda floater to allow me to use vector application is more places
05:37:22 <rostayob> how can I load multiple modules at once in ghci?
05:39:45 <rostayob> my problem is that
05:39:49 <ClaudiusMaximus> rostayob: :m + Module1 Module2
05:40:06 <rostayob> if i do 'ghci This.hs That.hs' and That does import This (something), the rest of This gets shadowed
05:40:50 <ClaudiusMaximus> what about ghci That.hs This.hs -- same effect?
05:40:59 <rostayob> ClaudiusMaximus: probably not, but I'd like a general solution
05:41:19 <rostayob> can I simply tell ghci "load all the modules in these files"?
05:42:15 <ClaudiusMaximus> i guess one way would be a stub everything.hs with just imports, but that's a bit inelegant
05:42:27 <rostayob> ClaudiusMaximus: right, that's a solution I guess...
05:43:13 <mike-burns> That cabal vs. package manager article that monochrom wrote is great! I wish I had read that a while back.
05:44:41 <LucasCampos> mike-burns: Can I get a link?
05:49:35 <mike-burns> LucasCampos: http://www.vex.net/~trebla/haskell/sicp.xhtml
05:50:22 <merijn> mike-burns: I'm disappointed I parsed that as SICP for haskell :p
05:57:27 <hpaste> D pasted “reverse test” at http://hpaste.org/55677
05:59:11 <LucasCampos> mike-burns: Thanks
06:08:33 <k0ral> how would you turn a function (a -> Maybe a) into (a -> MaybeT IO a) using return/lift/whatever ?
06:08:57 <hpc> @src MaybeT
06:08:57 <lambdabot> Source not found. Sorry.
06:09:22 <cgroza> @type filterM
06:09:23 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:09:40 <hpc> k0ral: liftMaybe f = MaybeT . return . f?
06:09:51 <roconnor> k0ral: \f -> MaybeT . return . f I think
06:09:53 <hpc> k0ral: there's no general way for any transformar
06:10:51 <roconnor> @type MaybeT . return
06:10:51 <lambdabot> Not in scope: data constructor `MaybeT'
06:11:40 <k0ral> monad transformers are supposed to avoid boilerplate code but the more I'm digging into them, the more I'm invaded by lift/return/runMonadT
06:13:56 <roconnor> monad transformers are supposed to avoid boilerplate code?
06:15:03 <k0ral> roconnor: according to several tutorials, yes
06:15:52 <roconnor> FWIW, the only way I've used monad transformers is to build an abstract data type, my own primitives, and then I never touch the transformer stuff again
06:16:00 <k0ral> this MaybeT is driving me crazy, now I'm getting "Couldn't match expected type `()' with actual type `Maybe (IO ())'"
06:16:07 <roconnor> I even often rip out the monad transformer stuff to make it more efficent.
06:16:33 <k0ral> roconnor: well, I'm just sick of encapsulating cases
06:16:46 <Saizan> well, they are supposed to avoid you having to implement your own monad
06:17:32 <roconnor> Saizan: that's true.  It does that
06:17:35 <Saizan> k0ral: maybe you just need more familiarity with the type system?
06:17:48 <roconnor> Saizan: (untill you need something more efficent, but that time doesn't always come)
06:19:13 <k0ral> Saizan: maybe
06:27:01 <k0ral> now I got it working but I really find the code ugly
06:27:43 <roconnor> paste it
06:34:41 <hpaste> koral pasted “MaybeT IO a” at http://hpaste.org/55678
06:35:01 <k0ral> roconnor: here we go
06:35:45 <copumpkin> >>= return . is fmap
06:36:00 <copumpkin> why not use do sugar though?
06:36:42 <k0ral> because I would have to add case of syntax
06:36:54 <k0ral> to extract each maybe's result, so twice
06:38:21 <merijn> I agree that this is not readable, but I don't see why case of is a problem?
06:38:50 <Saizan> what's the point of the pure functions if you don't look at the result of the runMaybeT .. action?
06:39:13 <Saizan> anyhow i think using Maybe's >>= directly here rather than MaybeT could be better
06:41:24 <k0ral> merijn: well, given haskell's smart design, I expect it to provide a way to chain the 3 actions in a single line instead of using 2 encapsulated "case of"
06:41:48 <merijn> Could use 1 case of and one >>=
06:42:15 <merijn> But I still fail to see the problem with having 2 case of's, not everything has to be a one liner...
06:43:11 <k0ral> Saizan: sorry I don't see what you mean with your first question; regarding the use of Maybe's >>= directly, how could you do it since there is the IO monad messing around ?
06:43:23 <merijn> fmap?
06:43:40 <k0ral> didn't know of fmap and I'm gonna replace right now every >>= return . with it
06:43:54 <merijn> :t fmap (>>=)
06:43:54 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => f (m a) -> f ((a -> m b) -> m b)
06:44:17 <k0ral> merijn: this is a matter of expectations, and I expect haskell to make it possible to one line this kind of process
06:44:27 <hpaste> Saizan annotated “MaybeT IO a” with “MaybeT IO a (annotation)” at http://hpaste.org/55678#a55679
06:44:38 <k0ral> merijn: since this is basically chaining 3 actions that can fail
06:45:04 <Saizan> k0ral: see my paste
06:45:17 <Eduard_Munteanu> If you're already using the Maybe monad then you don't really need to pattern-match explicitly.
06:45:39 <Saizan> he has some stuff in IO, some in Maybe and some in IO (Maybe a)
06:45:56 <Saizan> what he's finding ugly is the injections from IO and Maybe into IO (Maybe a)
06:46:01 <Eduard_Munteanu> Ah.
06:46:17 <dmwit> liftIO solves one; why not define a "liftMaybe" that solves the other?
06:46:21 <Saizan> k0ral: in your code the effects of labelSetURI gets discarded i think
06:46:41 <Saizan> dmwit: yeah, sounds like the right choice if he needs this more than once
06:46:55 <k0ral> Saizan: yes, but as I want to chain it, I have to return a Maybe something
06:47:47 <k0ral> maybe I should define an ending >>= operator, that feeds the right operand with the monad's content (if any), but doesn't care about it's return type
06:47:52 <Saizan> k0ral: no, you've to lift the IO () result into Maybe IO (), and that's done by lift or liftIO, not return like you were doing
06:48:05 <k0ral> so that a >>= b >>= c >>end d
06:48:48 * k0ral is reading/trying to understand the annotation
06:53:46 <k0ral> Saizan: I can't get why you prefix parseURIReference with >>=
06:54:07 <merijn> k0ral: That's just partial application of the >>= function
06:54:09 <rostayob> is there somewhere a haskell 98 file that covers the whole prelude? assuming basic types (Int, Char, Float, etc.)
06:54:30 <merijn> k0ral: Similar to
06:54:34 <merijn> :t (+1)
06:54:34 <lambdabot> forall a. (Num a) => a -> a
06:54:45 <merijn> > (+1) 3
06:54:46 <lambdabot>   4
06:55:17 <k0ral> merijn: I'm aware of that, my problem is that I would really have removed >>=
06:55:31 <merijn> k0ral: Then it would not do the same thing...
06:55:37 <k0ral> in fmap :: (a -> b) -> f a -> f b, isn't parseURIReference the (a -> b) ?!
06:56:08 <merijn> Yes, but what about the IO monad that's also present?
06:56:25 <hpaste> Saizan annotated “MaybeT IO a” with “using liftMaybe” at http://hpaste.org/55678#a55680
06:56:32 <merijn> fmap takes care of getting into the IO monad and >>= takes care of the maybe monad
06:56:48 <mike-burns> rostayob: http://www.haskell.org/onlinereport/standard-prelude.html - will this suffice?
06:57:06 <rostayob> mike-burns: oh right, why didn't i think of that
06:57:08 <rostayob> thanks
06:57:14 <Saizan> k0ral: see that other version too, btw check if they typecheck first :)
06:57:37 <merijn> k0ral: Without the >>= you would be applying parseURIReference to the Maybe value, not to the contents of the Maybe
06:57:53 <k0ral> so f is Maybe, right ?
06:58:31 <k0ral> and a is IO String
06:58:41 <k0ral> am I right ?
06:58:58 * merijn needs to check the code again
06:59:06 <k0ral> Saizan: looks better to me with these, but now I have 2 questions
07:00:01 <k0ral> 1/ does this mean I have to add liftMaybe/liftIO just about everywhere whenever I use MaybeT ? doesn't that sound boilerplate ?
07:00:25 <k0ral> 2/... I have to check something before asking it
07:00:55 <merijn> (>>= parseURIReference) turns "String -> Maybe URI" into "Maybe String -> Maybe URI" and fmap turns "Maybe String -> Maybe URI" into "IO Maybe String -> IO Maybe URI"
07:02:04 <k0ral> so a is Maybe String and f is IO
07:03:46 <Saizan> k0ral: well, if you start making your action stay in MaybeT IO you'll only need the lifters when you import some "primitives"
07:03:49 <k0ral> the problem with fmap is that it doesn't allow chaining syntax
07:04:18 <ciaranm> :t fmap fmap fmap fmap
07:04:18 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
07:04:25 <Saizan> btw, you might want a exeMaybeT :: MaybeT IO a -> IO ()
07:04:31 <Saizan> *execMaybeT
07:05:40 <k0ral> ciaranm: this is unreadable seriously
07:06:17 <wereHamster> when I do pattern matching on a String, does haskell do a linear search or something smarter?
07:06:50 <merijn> wereHamster: What do you mean? String pattern matches are just list pattern matches
07:06:56 <Saizan> anyhow, as you get more familiar with the combinators and types you should be able to find the right balance for your coding needs
07:06:57 <roconnor> wereHamster: you more or less cannot pattern match on a string
07:07:29 <wereHamster> like: foo :: String -> IO (); foo "something" = x; foo "else" = y; foo "blurb" = z; etc
07:13:01 <k0ral> actually, I like the fmap solution
07:13:20 <k0ral> the only remaining thing I don't like is the maybe (return ()) line
07:14:58 <Saizan> wereHamster: the pattern match there is not like e.g. perl's regexes, it matches those strings exactly
07:15:24 <k0ral> now I'm looking for something like fmap but of type (a -> f b) -> f a -> f b
07:15:30 <Saizan> > let f "foo" = () in f "foobar"
07:15:30 <k0ral> or
07:15:30 <lambdabot>   *Exception: <interactive>:3:4-15: Non-exhaustive patterns in function f
07:15:40 <Saizan> k0ral: that'd be (=<<)
07:16:09 <mike-burns> @hoogle (a -> f b) -> f a -> f b
07:16:09 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
07:16:10 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
07:16:10 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:17:02 <eikke> that's like flatmap, right
07:18:21 <dmwit> eikke: For the list monad, yes; for other monads it can be more exciting.
07:18:34 <jessopher> > (>>=) [1,2,3,4] (\a -> [a+1])
07:18:35 <lambdabot>   [2,3,4,5]
07:19:16 <eikke> dmwit: I somehow remember another way to define monads, not using bind/return, but using flatmap and something else. iirc scala does it that way
07:19:17 <dmwit> > (>>=) [1,2,3,4] (\a -> map (a+) [10, 20, 30, 40])
07:19:18 <lambdabot>   [11,21,31,41,12,22,32,42,13,23,33,43,14,24,34,44]
07:19:34 <dmwit> eikke: flatmap and return =)
07:19:39 <dmwit> eikke: Because flatmap is bind. =)
07:19:50 <Saizan> maybe you're thinking of fmap and join
07:21:01 <eikke> Saizan: most likely
07:21:33 <dmwit> Saizan: Don't you still need return?
07:21:56 <Saizan> dmwit: yep
07:29:21 <nus> wereHamster, http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-7.0.4/FastString.html#t:FastString
07:31:17 <hpaste> koral annotated “MaybeT IO a” with “MaybeT IO a (annotation) (annotation)” at http://hpaste.org/55678#a55681
07:31:39 <k0ral> Saizan, merijn: why wouldn't this new paste work ?
07:32:12 <k0ral> =<< is taking care of the IO and >>= is taking care of the Maybe
07:32:45 <Saizan> your concept of "taking care" is too magical for what (>>=) is actually doing :)
07:33:14 <k0ral> just borrowing merijn's word :)
07:33:57 <Saizan> yeah, the problem is not the word, but the concept associated with it
07:34:04 <k0ral> I think there is an ambiguous interpretation of >>=
07:34:26 <Saizan> ((>>= parseURIReference) `fmap` (webViewGetUri webView)) :: IO (Maybe URI)
07:34:46 <k0ral> yes so basically I imitated your fmap trick but with =<<
07:35:02 <k0ral> since the last action is in the IO monad
07:35:05 <Saizan> (...) =<< ((>>= parseURIReference) `fmap` (webViewGetUri webView)) means that ... has to have type Maybe URI -> IO ()
07:35:43 <wereHamster> Saizan: I know. My question is whether it's efficient if I have 100's f those foo "something" = x lines, or if I should do a binary search in a list with ("foo",x) elements
07:36:44 <Saizan> so you can't place (>>= ..) there, because (>>=) :: Monad m => m a -> (a -> m b) -> m b; so (>>= ..) will have type Monad m => m a -> m b for some m, but m a -> m b doesn't match Maybe URI -> IO ()
07:36:56 <Saizan> since Maybe /= IO
07:37:01 <JoeyA> Where's that GHC issue where the test case involves spawning a bunch of threads and having them read the same top-level mutable state (unsafePerformIO $ newIORef or something) ?
07:37:26 <JoeyA> The bug is that the work was duplicated anyway.
07:37:37 <JoeyA> The closest thing I could find is: http://hackage.haskell.org/trac/ghc/ticket/5558
07:37:46 <Saizan> wereHamster: ah, in that case i suspect it won't do anything smarter than a linear search, but i've never checked
07:38:04 <k0ral> @hoogle Monad m, Monad m' => m a -> (a -> m' b) -> m' b
07:38:04 <lambdabot> Parse error:
07:38:04 <lambdabot>   Monad m, Monad m' => m a -> (a -> m' b) -> m' b
07:38:04 <lambdabot>          ^
07:38:14 <k0ral> @hoogle (Monad m, Monad m') => m a -> (a -> m' b) -> m' b
07:38:14 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:38:15 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:38:15 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:39:03 <Saizan> you need to know more about "m" than just (Monad m) to implement that
07:39:03 <k0ral> so basically this doesn't exist
07:39:23 <k0ral> well, I just want (>>=) but for 2 monads
07:39:54 <Saizan> yeah, that's impossible in general
07:40:00 <k0ral> :_(
07:41:04 <Saizan> Monad m => Maybe a -> (a -> m ()) -> m () is doable
07:41:15 <k0ral> ok things are now pretty clear in my mnd, so basically there is no way to end any monadic chain
07:41:20 <k0ral> s/mnd/mind
07:41:58 <MHD0> merry solstice celebration, everyone
07:42:16 <jessopher> it depends on the type. if there are no exported constructors, or destructive functions, no. thats true for any type though, not just monads
07:42:16 <Saizan> any chain has to stay in the same monad,
07:42:22 <nus> wereHamster, see ghc/compiler/deSugar/ for the gore details (it's using FastStrings in the end)
07:43:26 <k0ral> I'm quite in admiration with the way monads make it possible to chain actions, but I'm getting more and more frustrated to notice that I never need chains longer than 2 actions, which makes chaining a lot less relevant
07:44:05 <cmccann> k0ral, how do you know you only need two actions
07:44:08 <Phlogistique> Hi
07:44:15 <cmccann> what if one of those actions was already created by chaining others together?
07:44:23 <Phlogistique> I would like to separate my config in two files
07:44:33 <Phlogistique> to keep a "local.hs" file on each machine
07:44:35 <k0ral> cmccann: just talking about what I've needed up to now
07:44:59 <Phlogistique> and an xmonad.hs that is versionned in a git repo that I have on every machine
07:45:06 <Phlogistique> how do I do that?
07:45:07 <nus> wereHamster, matchLiterals -- For everything except String we can use a case expression; for String we need a chain of if-then-else
07:45:29 <Saizan> well, the point of monads is not about collapsing your code to one-liners with fancy combinators, it's to provide an abstraction to the chaining at all so that it structures your code
07:46:11 <Eduard_Munteanu> Phlogistique: put the common parts on github?
07:46:28 <Saizan> there's some sense in which mapM f xs is a chain at least as long as xs :)
07:46:43 <Phlogistique> Eduard_Munteanu: that's what I want to do
07:46:56 <Phlogistique> Eduard_Munteanu: now how do I get the local part out of xmonad.hs?
07:47:17 <Eduard_Munteanu> Phlogistique: maybe you should get the common part out of xmonad.hs into its own module
07:47:18 <Phlogistique> (How do I #include "local.hs")
07:48:01 <k0ral> Saizan: thank you for your patience, I think I've understood a key characteristic of monads through this problem :)
07:48:43 <Eduard_Munteanu> Phlogistique: there is a C-ish include pragma IIRC if you really want that
07:49:51 <k0ral> Saizan: basically this function would be "forMaybeM_ = flip $ maybe (return ())", am I right ?
07:49:51 <Phlogistique> OK
07:50:13 <Phlogistique> Eduard_Munteanu: I guess I'll just search githu
07:50:28 <Phlogistique> b for examples of extracted out xmonad configs to see how to do that
07:50:56 <Saizan> k0ral: yeah, maybe there's a more general combinator in Data.Foldable
07:51:43 <Saizan> k0ral: yep, Data.Foldable.forM_
07:58:48 <Phlogistique> ...oh wait, this is #haskell, not #xmonad. sorry
07:59:43 <dmwit> Phlogistique: Name it Local.hs, put "module Local where" at the top, and in your other file, "import Local".
07:59:50 <Phlogistique> anyway, I just noticed that xmonad compiles any haskell file under .xmonad/lib
07:59:56 <dmwit> Phlogistique: If you are not a Haskell expert, you almost certainly don't want #include.
08:00:26 <Phlogistique> dmwit: I did that; the part I was missing out was "and put that under .xmonad/lib, not under .xmonad"
08:00:39 <dmwit> Ah, yes, for xmonad you need to... yes.
08:11:12 <Peaker> What's a recommended/blessed cmdline option parsing lib? System.Console.GetOpt?
08:12:57 <donri> Peaker: getopt is "blessed" in being in base/haskell-platform
08:13:47 <donri> Peaker: as for "recommended", maybe cmdlib
08:14:23 <Peaker> I keep using   [filename] <- getArgs, but that makes for non-useful errors :)
08:14:33 <donri> Peaker: if you like that pattern maybe look at simpleargs
08:15:03 <donri> it uses type hackery to let you getArgs for a tuple, with automatic read'ing
08:15:31 <Peaker> At first look, System.Console.GetOpt looks better than CmdLib
08:15:44 <donri> duno, cmdlib does more (subcommands for example)
08:16:42 <Peaker> donri: well, I dislike that it has an "isOptional" as a Bool, separate from the types. GetOpt does the right thing of having a (Maybe String -> a) or (String -> a) depending on whether its optioanl
08:17:14 <Peaker> ah, getopt is in base
08:17:56 <donri> there's also "cmdargs"
08:19:00 <Peaker> too many libs :)
08:19:02 <Peaker> for the same thing
08:19:21 <Peaker> GetOpt seems not to have sane error handling, unless I'm missing something
08:19:28 <donri> ...and parseargs ;)
08:19:58 <dons> there's no consensus on the best high level lib.
08:21:58 <djahandarie> A wild dons appears :o
08:22:32 <cmccann> wow hey, dons is around :D
08:22:40 <Peaker> cmdargs seems complicated, and the unsafePerformIOs in it are scary
08:23:16 <Peaker> simpleargs seems to be a Read-like class
08:23:24 <Peaker> (not viable in the general case)
08:23:58 <Peaker> cmdlib seems to mess up the required/optional types
08:24:03 <cmccann> I thought the unsafePerformIO in cmdargs were only if you wanted to use the "more magic" setting
08:24:14 <Peaker> GetOpt seems to have bad error handling (though perhaps usable)
08:24:16 <cmccann> and that it still works fine without that
08:24:23 <Peaker> cmccann: It says "The pure version is less type safe"
08:24:43 <cmccann> ah
08:25:15 <Peaker> I don't really mind a bit of extra verbosity -- if I can have type-safety with it (i.e: verbosity that doesn't curtail bugs)
08:25:20 <exFalso> good afternoon happy christmas and all
08:25:21 <exFalso> is there a reason for there not being a MonadSTM class?
08:25:28 <Peaker> I prefer verbose/safe over concise/unsafe
08:26:22 <Peaker> parseargs seems to use Haskell's broken data-type class constraints
08:27:06 <cmccann> exFalso, I assume you mean by analogy to MonadIO?
08:27:23 <exFalso> cmccann: yes
08:27:47 <donri> Peaker: clearly, we need to create a new getopt wrapper
08:27:53 <Peaker> donri: Hehe :)
08:27:59 <donri> Peaker: http://xkcd.com/927/
08:28:04 <Peaker> donri: I counted 5 so far?
08:28:37 <Peaker> I like System.Console.GetOpt best so far -- and it's in base. I'll try that first
08:28:49 <cmccann> exFalso, I don't see any reason as such
08:28:50 <donri> sounds good
08:29:00 <donri> Peaker: in case you missed it http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
08:29:14 <Peaker> donri: thanks
08:30:00 <cmccann> exFalso, though I think the more popular idea is a generalized class for base monads like IO, which would include STM and ST and the like
08:30:46 <exFalso> the only reason i can think of is that when people start stacking transformers they forget that STM computations are atomic? just a guess
08:30:56 <exFalso> yeah that would be nice
08:31:07 <Peaker> Why:  data OptDescr = Option ...    and not: data Option = Option ... ?
08:31:11 <Peaker> weird
08:31:35 <cmccann> exFalso, I doubt it, you'd still have the same basic STM interface
08:32:28 <Peaker> Hmm.. GetOpt doesn't have a "parse-and-usage-on-failure" convenience for use from Main directly...
08:32:39 <cmccann> exFalso, if anything the problem is that atomically produces something in IO, so you might need to juggle things around to deal with the rest of the transformer stack
08:34:24 <cmccann> in some cases, I suspect the ideal would be a variant of atomically that takes something using your stack with STM at the bottom, and gives something using the same stack except with IO at the bottom
08:35:16 <donri> Peaker: you saw the examples for how to do that though? in the getopt haddocks
08:35:16 <kamyzi`e> hello, how do I import a library and hide specific instances of a type class?
08:36:42 <donri> can you even import/hide instances as such?
08:36:54 <Peaker> donri: sure, it seems I'm supposed to getArgs, feed it to getOpt, remember to check the error list that's returned, and if it's an error, use usageInfo to generate an error and return
08:37:10 <Peaker> donri: it seems like a bunch of logic that every user of GetOpt will need to implement, and it's not in there
08:37:38 <cmccann> kamyzi`e, you don't, unfortunately
08:37:47 <cmccann> not the instances themselves
08:37:52 <donri> Peaker: agreed. maybe because getopt is meant to be a very low-level toolkit for creating more complex/custom setups?
08:37:54 <Peaker> kamyzi`e: instances are not meant to be hidden -- you can only newtype
08:38:36 <Peaker> donri: I like the types GetOpt uses over the other over-complicated libs though
08:38:37 <donri> though seems it could easily have a simple function for doing the most common thing
08:38:45 <Peaker> donri: maybe I'll try to make my own little wrapper
08:38:49 <donri> ;)
08:39:19 <donri> someone needs to make up an algebra of option parsing so we can get this right for once
08:39:59 <donri> (re. "You decide to shoot yourself in the foot but get distracted devising a ballistics algebra and wondering if you can do the calculations in the type system.")
08:40:14 <donri> (http://www.haskell.org/haskellwiki/Shooting_your_self_in_the_foot)
08:40:48 <mike-burns> Are we intentionally unable to hide typeclasses? Is this a feature?
08:40:59 <mike-burns> Er, instances.
08:41:09 <cmccann> it's not really a feature
08:41:12 <cmccann> but I think it is necessary
08:41:17 <kamyzi`e> some of the typeclassopedia exercises require reimplementations, such as Applicative Maybe, how would I do this without reimplementing Maybe, and Functor Maybe
08:41:49 <mike-burns> I hate that you can't hide instances but I hadn't heard it as a necessity before.
08:41:51 <donri> kamyzi`e: {-# LANGUAGE NoImplicitPrelude #-}
08:42:13 <donri> in the case where prelude imports the instance you want to hide
08:42:30 <cmccann> if memory serves me there are slightly contrived situations where hiding instances--or rather, anything making instances not completely global--can break type safety
08:42:45 <cmccann> when two modules have different sets of instances in scope for the same type, or whatever
08:42:53 <cmccann> I don't recall the details, though
08:44:01 <kamyzi`e> donri: in this case Control.Applicative has the instance I want to hide
08:44:13 <donri> so don't import it
08:44:26 <donri> the module, at all
08:44:51 <kamyzi`e> but then how would I implement my own Applicative instances?
08:45:36 <cmccann> kamyzi`e, the standard solution to what you're trying to do is a newtype wrapper. there probably isn't a better option.
08:45:45 <merijn> kamyzi`e: I think you can just use newtype define a new name which doesn't derive the Applicative instance
08:46:48 <kamyzi`e> that works but then I still need to reimplement Functor for the newtype
08:47:19 <merijn> I think you can just do "deriving (Functor)"?
08:47:29 <merijn> I haven't really used this before, so I'm not sure
08:47:54 <cmccann> kamyzi`e, use GeneralizedNewtypeDeriving
08:47:57 <donri> for newtypes you can derive any instance that the wrapped type has
08:48:06 <donri> with that extension cmccann mentioned
08:48:10 <cmccann> yes :]
08:48:16 <merijn> \o/
08:48:20 <merijn> I wasn't wrong :>
08:48:28 <kamyzi`e> alright, thanks
08:48:40 <cmccann> there's also an extension that derives Functor independently
08:48:53 <cmccann> but for a newtype wrapper you don't need that
08:49:31 <kmc> i too hate that you can't hide instances, but there are good reasons for it
08:50:54 <mike-burns> What are the reasons, kmc ?
08:51:31 <Peaker> You want all instances of the same type/class in the whole program to be the same for coherency
08:51:32 <kmc> suppose two libraries define conflicting instances Ord T
08:51:41 <kmc> and now you try to pass a (Map T a) between them
08:53:43 <carpi> is it possible to tell a fold to give the value that it has calculated so far?
08:54:03 <mike-burns> There's scanl, if that's what you mean.
08:54:05 <cmccann> carpi, you mean scan?
08:54:17 <kmc> > scanl (+) 0 [1..10]
08:54:18 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
08:54:58 <carpi> but scans give "all" the values calculated so far.. i only want the value when a certain condition is met
08:55:15 <carpi> or maybe its possible to do with some combination of scan and fold
08:55:22 <carpi> or takewhile
08:55:22 <merijn> scan + filter?
08:55:32 <byorgey> carpi: can you say more precisely what you are trying to do?
08:55:39 <cmccann> yeah, use a scan and then find what you need in the list
08:56:05 <carpi> byorgey: whether a number is prime or not.. one of the problems from 99 problems for haskell
08:56:09 <cmccann> the scan produces every intermediate value of the accumulator, so there's not really anything you could do in the fold that you can't do with the result of scan
08:56:57 <byorgey> carpi: and what is the fold for?
08:57:15 <cmccann> if you need to compare the element in the original list as well, just zip the original list with the tail of the output of the scan
08:58:05 <carpi> byorgey: to go thru every number from 2 to half n and check if each element is divisible by n
08:58:38 <byorgey> carpi: and why do you need a fold for that?
08:58:54 <byorgey> checking for divisibility by each number from 2 to half n sounds like a map
08:59:02 <carpi> a map would do yea
08:59:11 <carpi> ah yes
08:59:17 <Cale> carpi: There's a rather nice way to compute the primes by saying that 2 is a prime, and then filtering the list of odd numbers by isPrime, where isPrime n tests whether n is divisible by all the prime numbers p where p*p <= n
08:59:30 <byorgey> then if you get a list of Booleans you can use 'or' or 'and' on it as appropriate
08:59:35 <byorgey> which are short-circuiting
08:59:44 <Cale> rather, I should say it tests if it's not divisible by any of them
09:00:44 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
09:00:45 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:00:51 <ddarius> @src any
09:00:52 <lambdabot> any p =  or . map p
09:01:14 <carpi> byorgey: that is what i did first.. but coming from imperative world i couldn't help but think that it would go do the divisibilty test for all elements from 2 to half n even if one of the tests return True..at which point it is pointless to check any furthur
09:01:16 <ddarius> @src or
09:01:16 <lambdabot> or    =  foldr (||) False
09:01:42 <byorgey> carpi: nope, because of laziness it will only do the divisibility test until it finds one that succeeds
09:01:54 <Cale> It's not the fastest possible way to compute the primes, but it's reasonable if you just need 10000 of them or so.
09:02:28 <Cale> @src (||)
09:02:28 <lambdabot> True  || _ =  True
09:02:28 <lambdabot> False || x =  x
09:02:41 <Cale> ^^ that ignores its second parameter when the first is True
09:02:48 <Cale> (so it won't be computed)
09:03:01 <kmc> carpi, when I have a strange recursion pattern I usually write the explicit recursion first, and then figure out whether it can be replaced with fold / scan / etc
09:03:17 <ion> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in map fst . filter snd . zipWith (\a b -> (a, a+2 == b)) primes (tail primes)
09:03:18 <lambdabot>   Couldn't match expected type `[(a, GHC.Bool.Bool)]'
09:03:18 <lambdabot>         against inferre...
09:03:36 <ion> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in map fst . filter snd $ zipWith (\a b -> (a, a+2 == b)) primes (tail primes)
09:03:38 <lambdabot>   [3,5,11,17,29,41,59,71,101,107,137,149,179,191,197,227,239,269,281,311,347,...
09:04:05 <Cale> @oeis 3,5,11,17,29,41,59
09:04:06 <lambdabot>  Lesser of twin primes.
09:04:06 <lambdabot>  [3,5,11,17,29,41,59,71,101,107,137,149,179,191,197,227,239,269,281,311,347,4...
09:04:58 <carpi> thanks for the suggestions.. i think i will do the map way..
09:05:10 <carpi> and take advantage of shortcircuiting )
09:14:15 <kamyzi`e> my attempt to use newtype to reimplement Applicative Maybe feels convoluted, http://hpaste.org/55682
09:14:52 <cmccann> why are you using the record syntax everywhere?
09:15:25 <cmccann> you can still use Myb like any other type constructor.
09:15:44 <cmccann> So you could even write pure as something like "pure = Myb . Just"
09:16:46 <ion> You can make the “both are Just” case for <*> the first one and handle the other cases with a single pattern.
09:16:48 <kamyzi`e> cmccann: what would be the newtype declaration of Myb? newtype Myb a = Myb (Maybe a) ?
09:16:59 <cmccann> You could also put the final case for (<*>) first, then use--yeah, what ion said
09:17:09 <ion> That would work, but you don’t *need* to change that.
09:17:13 <mike-burns> kamyzi`e: You don't need to change the newtype declaration.
09:17:15 <cmccann> kamyzi`e, no, you can leave the declaration as is but still use the constructor normally
09:17:46 <donri> Myb someMaybe works regardless of Myb being a record or not
09:18:24 <hpaste> “C. McCann” annotated “Applicative Maybe” with “Applicative Maybe (annotation)” at http://hpaste.org/55682#a55683
09:18:30 <cmccann> something like that
09:18:41 <cmccann> except without any typos I might have made
09:19:27 <kamyzi`e> ah, much nicer
09:19:40 <kamyzi`e> thanks
09:30:09 <ocharles> Hi, I'm considering a little hobby project to do multiple-host log analysis with a DSL in haskell. Seems like a perfect job for learning iteratee IO, but I was wondering - has there been any research into combining IO from multiple sources, but retaining some sort of ordering?
09:30:22 <ocharles> Ie. I have 3 log files, all the same format, and I want to treat them as one interleaved log
09:30:35 <ocharles> I can make the assumption that each log is ordered
09:33:04 <Cale> ocharles: An ordered merge is something which is oddly missing from Data.List, but it's not hard to write one which is lazy.
09:33:40 <Cale> But if you want to do that in IO, hmm...
09:33:58 <ocharles> yea, that sounds fine if I loaded the entire logs into memory
09:34:11 <ocharles> but I want to be filtering about 4gb logs
09:34:21 <Cale> Well, I mean, you can just use normal lazy IO stuff if you don't have a million logs to deal with.
09:35:07 <Cale> (the usual problem with lazy IO is that you lose control over file descriptor allocation, and operating systems suck too much with respect to that)
09:35:36 <ocharles> right
09:36:33 <donri> heh, even ghc does the mistake of calling non-(->)-values functions: "The function `DB.word' is applied to one argument, but its type `Data.Lens.Common.Lens DB.Word String' has none"
09:38:25 <monochrom> that is not clear evidence. if you write "DB.word xxx", clearly you think that DB.word to be a function, and ghc is just playing along with you.
09:38:26 <cmccann> to be fair, you're giving GHC mixed messages there by applying a non-function
09:38:43 <cmccann> maybe it is a function and the type is wrong, maybe it isn't a function and you shouldn't be applying it
09:38:43 <Cale> donri: It should probably special case that message...
09:39:08 <donri> cmccann: but what it actually *is*, according to the type, is *not a function* :)
09:39:17 <donri> and it's actually saying "function with no arguments"
09:39:22 <rwbarton> it isn't anything until type checking succeeds
09:39:46 <monochrom> clear evidence would be like "cannot match [a] with IO a in the function readLn"
09:39:53 <Cale> donri: Well, it might be that you intended it to be a function since you're using it as one, but somehow the definition of DB.word is messed up.
09:40:31 <donri> (the actual case is that it *was* a function (record getter) turned into a lens value)
09:40:32 <monochrom> ghc cannot know which one is wrong: "DB.word xxx", or "DB.word :: Blah".
09:41:15 <monochrom> in fact, I cannot know either.
09:41:15 <cmccann> that said, GHC and its documentation aren't entirely consistent on every bit of terminology, I wouldn't blindly take it as normative regardless
09:41:36 <monochrom> in fact, I posit that you do not know, either
09:42:08 <donri> i do know, since it's not really a mistake but a change-in-progress (yay typesystem helpfulness :))
09:42:54 <monochrom> that is what human thinks.
09:44:09 <ddarius> Ah humans.
09:44:12 <ddarius> They're so funny.
09:49:58 <mizu_no_oto> Is there any built in way to apply a function of type (a, b) -> (c, b) to a value of type (a, Either b d)?  That is to say, with functors or something?
09:52:01 <cmccann> how would that work, when you may not have anything of type b?
09:52:42 <monochrom> yeah, f (5, Right False) = ?
09:53:55 <penelope> Sounds like a job for arrows...
09:54:05 <ddarius> Sounds like a job not to be done.
09:54:23 <monochrom> perhaps you can convert (a, b) -> (c, b) to (a, Either b d) -> Maybe (c, b)
09:56:01 <spuz> How do I construct an Int with the value 0?
09:56:20 <penelope> 0 :: Int ?
09:56:29 <monochrom> in some contexts, "0" suffices. in some other contexts, "0 :: Int" suffices.
09:57:18 <penelope> 0 is an overloaded constructor.
09:57:24 <ddarius> In all contexts (0 :: Int) suffices.
09:57:32 <kmc> it's not a constructor
09:57:36 <penelope> It is!
09:57:52 <kmc> no, pattern-matching on numeric literals is special
09:58:08 <mizu_no_oto> Is there any way to "suck" an Either up a tuple?  i.e. (a, Either b c) -> Either (a,b) (a,c) ?
09:58:10 <penelope> It is in theory!
09:58:21 <kmc> @djinn (a, Either b c) -> Either (a,b) (a,c)
09:58:21 <lambdabot> f (a, b) =
09:58:21 <lambdabot>     case b of
09:58:21 <lambdabot>     Left c -> Left (a, c)
09:58:21 <lambdabot>     Right d -> Right (a, d)
09:58:24 <ddarius> penelope: Then in theory it's not overloaded.
09:58:34 <kmc> penelope, in my theory it's not
09:58:37 <ddarius> At any rate, the literal 0 means fromInteger (0 :: Integer)
09:59:12 <ddarius> @djinn Either (a,b) (a,c) -> (a, Either b c)
09:59:12 <lambdabot> f a =
09:59:12 <lambdabot>     case a of
09:59:12 <lambdabot>     Left (b, c) -> (b, Left c)
09:59:12 <lambdabot>     Right (d, e) -> (d, Right e)
09:59:40 <ddarius> One of those two is more special than the other.
10:00:14 <penelope> All we have are functions:
10:00:28 <penelope> 'a' is really a short hand for CharA
10:00:28 <kmc> \(a,e) -> either (Left . (a,)) (Right . (a,)) e
10:01:46 <ski> @type uncurry (liftM2 either (Left .: (,)) (Right .: (,)))
10:01:47 <lambdabot> forall a b a1. (a1, Either a b) -> Either (a1, a) (a1, b)
10:02:02 <kmc> penelope, that's a fine conceptual model, but it's not how GHC's implementation works, and standard Haskell does not allow you to tell the difference.  Char is an abstract type, and pattern-matching is defined via (==)
10:02:46 <kmc> Haskell 2010 Report, §3.17.2(7) "Matching a numeric, character, or string literal pattern k against a value v succeeds if v  ==  k, where == is overloaded based on the type of the pattern. The match diverges if this test diverges."
10:03:47 <penelope> Let me live in my happy magic world, where data Int = 0 | 1 | 2 ...
10:03:57 <monochrom> 3.17.2 is informal semantics. what about 3.17.3 formal semantics?
10:04:07 <ddarius> penelope: That's fine but when you write f 0 = ..., f :: MyCrazyIntType -> ...
10:04:47 <monochrom> rule (h)
10:05:02 <kmc> case v of { k -> e; _ -> e′ }  =  if (v==k) then e else e′
10:05:02 * ddarius wonders if GHC uses (==) in the order specified by the Report.
10:05:09 <kmc> where k is a numeric, character, or string literal
10:05:46 <kmc> penelope, I can make a numeric type where 1 matches 0, which they never would if they were distinct constructors
10:06:43 <Saizan> instance Num ()
10:06:55 <ddarius> kmc: You can make 1 match 0 even for Int.
10:07:02 <penelope> Num is sad
10:07:23 <ddarius> Though you'd probably need NoImplicitPrelude.
10:07:27 <monochrom> how do you make 1 match 0 for Int?
10:31:56 <mizu_no_oto> Also, just out of curiosity, is there a reason why the 'inverse' of Functor doesn't exist?  i.e. something with the signature InverseFunctor i => (b->a) -> i a -> i b?  From what I understand, Functor (among other things) corresponds to transforming the output of a computation.  But a number of types, e.g. (a->b), Iteratee, Arrow, &c. have one or more of their types corresponding to their...
10:31:57 <mizu_no_oto> ...*inputs*.  Is there any reason we don't have a typeclass for transforming inputs?
10:32:19 <kmc> that's called a contravariant functor
10:32:49 <Saizan> there's a Contravariant typeclass somewhere
10:32:50 <kmc> http://hackage.haskell.org/packages/archive/contravariant/0.1.3/doc/html/Data-Functor-Contravariant.html
10:34:30 <mizu_no_oto> Just out of curoisity, what packages does hoogle (i.e. at http://www.haskell.org/hoogle/) not search?
10:37:08 <WarzoneCommand> question, If I use typefamilies in some typeclass, can I require them to have certain properties?
10:37:33 <Saizan> such as?
10:37:52 <WarzoneCommand> i.e. something like: class Container c where Elem c, with Ord (Elem c) .....
10:38:14 <Saizan> you can class Ord (Elem c) => Container c where type Elem c; ..
10:38:14 <kmc> class (Ord (Elem c)) => Container c where { type Elem c;  ... }
10:38:21 <WarzoneCommand> ah cool
10:38:22 <WarzoneCommand> ty
10:38:23 <kmc> requires recent GHC, i think 7.2 or later
10:38:32 <WarzoneCommand> erh
10:38:33 <kmc> or maybe that's only for equality constraints
10:38:36 <kmc> try it :)
10:38:46 <WarzoneCommand> ah k I'll try
10:38:53 <Saizan> yeah, i think Ord would work anyway
10:39:16 <cmccann> kmc, only equality constraints in class contexts
10:39:27 <cmccann> other constraints or equalities in instance contexts always worked I think
10:40:34 <WarzoneCommand> hmm I get
10:40:42 <WarzoneCommand>     Could not deduce (Ord (EventData (Event' k e)),
10:40:43 <WarzoneCommand>                       Eq (EventKind (Event' k e)))
10:40:57 <WarzoneCommand> with ghc 7.0.3
10:41:05 <kmc> maybe your instances don't satisfy the properties you are not requiring?
10:41:11 <kmc> now requiring*
10:41:31 <cmccann> which may just require adding the appropriate context to the instances themselves
10:41:39 <WarzoneCommand> the instance declaration is 'instance (Eq e, Ord e) => IsEvent k e' so that should be fine
10:42:00 <WarzoneCommand> err
10:42:06 <WarzoneCommand> Eq k, Ord e => ...
10:42:39 <kmc> you can put your code on hpaste.org
10:42:46 <rwbarton> what is Event', then
10:42:53 <WarzoneCommand> http://pastebin.com/UgDN795j
10:42:55 <mauke> The paste UgDN795j has been copied to http://hpaste.org/55687
10:43:10 <WarzoneCommand> ^^ I was allready doing that since I realized it might be difficult to follow :P
10:43:45 <WarzoneCommand> ah crap
10:43:50 <kmc> WarzoneCommand, why do you need this type class?
10:43:57 <WarzoneCommand> I just missede the type defs  in the instance declaration
10:44:06 <kmc> i mean doesn't the type Event' already do everything you need?
10:45:19 * hackagebot yesod-auth 0.7.9 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.9 (FelipeLessa)
10:45:22 <WarzoneCommand> yes, however I am building some functions that I would like to have more generic
10:45:44 <WarzoneCommand> e.g. work on any type that have properties like an event
10:45:52 <WarzoneCommand> the type Event' is just a default implementation
10:46:20 <kmc> what other types do you have in mind
10:46:21 <WarzoneCommand> ah nice by the way
10:46:29 <WarzoneCommand> it works now:)
10:46:41 <WarzoneCommand> nothing in particular
10:46:51 <WarzoneCommand> but I'm building a library
10:47:13 <WarzoneCommand> so I would ike to keep it as general as possible
10:47:43 <Saizan> @quote root.of.all.OOP
10:47:43 <lambdabot> No quotes match. It can only be attributed to human error.
10:47:45 <Saizan> @quote root.of.all.OO
10:47:46 <lambdabot> No quotes match. My pet ferret can type better than you!
10:47:49 <Saizan> meh
10:47:56 <cmccann> adding extra type classes isn't always the best way to make something general
10:47:57 <kmc> WarzoneCommand, can't your users just convert whatever type they have to Event'
10:48:17 <Eduard_Munteanu> @quote root.of
10:48:17 <lambdabot> Knuth says: We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.
10:48:32 <WarzoneCommand> they probably could, but I would prfer them not having to
10:49:26 <kmc> WarzoneCommand, so instead of them writing a function of type (Whatever -> Event' e k), they have to define a type class instance using several GHC extensions and provide four definitions in that instance
10:49:42 <kmc> that's not a win
10:50:09 <kmc> this is a pattern i see here all the time
10:50:16 <kmc> people go crazy with type classes and type class extensions
10:50:26 <kmc> overlooking a much simpler solution involving ordinary functions and data
10:50:58 <WarzoneCommand> hmm you may have a point there
10:51:57 <cmccann> as a rule of thumb, if a type class can be compared to converting things to a specific type, then it could be replaced with a conversion function to that type, at which point it can become obvious that the type class isn't doing much good
10:52:33 <kmc> yeah.  remember, with lazy evaluation, you only pay for the parts of that conversion which are used
10:52:39 <cmccann> type classes are for defining the same operation on multiple types in such a way that the implementations are fundamentally different
10:53:44 <Saizan> there's a tradeoff on how often you're going to call this (Whatever -> Even' e k) function though, i.e. people like to define MonadFoo classes to avoid lift's, though those also provide better handling of HOFs
10:54:15 <cmccann> if you can express the same thing as "convert to a single type, do the operation, optionally convert back" the type class isn't really doing much
10:54:41 <cmccann> conversion-based type classes make some sense when the types in question are truly ubiquitous, e.g. strings and numbers
10:55:15 <kmc> in these cases, the functional programming solution is so simple one doesn't notice it, whereas a pile of types and type classes is a familiar comforting sort of infrastructure
10:55:24 <WarzoneCommand> the reason why I looked into using typeclasses was because I want to express that types need to have certain properties
10:55:39 <WarzoneCommand> and I dislike having to wrap/unwrap types all the time
10:56:15 <kmc> it's a question of the lesser of two evils
10:56:30 <cheater> more loc = more quality
10:57:18 <kmc> type classes make the code more implicit, and in doing so they make the code more confusing and error-prone
10:57:27 <cmccann> WarzoneCommand, right, hence my ubiquity criterion. what kind of properties are you trying to express?
10:57:45 <kmc> and the typeclass solution is a lot more code to begin with
10:57:48 <cheater> i dislike implicitly executing code
10:57:54 <cmccann> anything that couldn't be done with phantom types to express restrictions?
10:57:58 <cheater> i thought this was one of the things we wanted to avoid with pure langs
10:58:21 <cmccann> cheater, so how do you feel about monad transformer stacks and the associated type classes :D
10:58:24 <kmc> i'm not a fan of those MonadFoo classes either
10:58:45 <kmc> they exist to make it nicer to write code in a bare monad transformer stack
10:58:49 <kmc> which you shouldn't do very much
10:58:53 <cheater> cmccann: i don't
10:59:11 <cheater> though i guess kmc is right
10:59:27 <cmccann> monadic functions polymorphic over multiple MonadFoo classes are 99% of the time a bad idea
10:59:32 <cheater> if you happen to have the need you probably already know what you'd build in order to do it
10:59:37 <cmccann> and will probably break mysteriously for some transformer stacks
10:59:47 <kmc> use monad transformers to define a custom monad with custom domain-specific operations
10:59:49 <cheater> so in that case you already know about the code behind the curtains, there's no surprise there
10:59:57 <cmccann> yeah
11:00:03 <kmc> then you use those operations elsewhere
11:00:06 <WarzoneCommand> cmccann: well in this particular case that some type can be used as an Event in an EventQueue (in a sweepline algorithm)
11:00:18 <cheater> impilcit code when you're using a number type are surprising otoh
11:00:19 * hackagebot Dangerous 0.1 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.1 (NateSoares)
11:00:25 <cheater> *is
11:00:28 <Saizan> i think that's somewhat ok in an application but not so much for a library
11:01:09 <Saizan> using a MonadFoo class let the user swap the "backend" for another if he needs to
11:01:25 <cmccann> cheater, that's kind of my point--if you're building a transformer stack in one place, and using "any monad with these instances" somewhere else, changing your stack can cause mysterious implicit changes elsewhere
11:01:40 <cmccann> if it's just one MonadFoo class it's probably okay
11:01:49 <cmccann> with more than one you're sensitive to changes in the order
11:02:00 <cmccann> that can have very drastic impacts on what the code means
11:02:08 <cheater> no because if you need to change the stack you probably know it's going to happen
11:02:24 <Saizan> but then it's not anymore just to avoid lift, so it's king of another discussion, unless IsEvent also ends up allowing additional flexiblity like that
11:02:25 <cheater> it's not like you're writing hello world and suddenly the tutorial tells you to change the monad stack
11:02:30 <cmccann> cheater, expecting your code to break in mysterious ways is better than not expecting it, yes
11:02:38 <cmccann> but I'd rather not have unexpected changes at all
11:02:45 <cheater> then don't use it
11:02:57 <cheater> it's very simple
11:03:41 <cmccann> well, I use transformer stacks in a newtype, don't give the newtype most MonadFoo instances, and expose monomorphic operations on the newtype
11:04:01 <cmccann> then if I need to refactor, I change the stack and the exported functions together
11:04:16 <cmccann> it's the same thing in some ways, but much less spooky action at a distance
11:04:35 <kmc> yeah, i like that design
11:05:01 <kmc> monad transformers are for defining new monads, not for general use
11:05:17 <kmc> (or for defining new monad transformers, if you're writing a library)
11:05:22 * hackagebot Dangerous 0.1.1 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.1.1 (NateSoares)
11:05:50 <cheater> MonadTransformerTransformer
11:05:56 <cheater> BeanFactory
11:07:11 <penelope> cheater: it's magic, but it's in-language magic
11:10:33 <cmccann> kmc, for further generality I sometimes define a transformer and create a MonadFoo class for it, which at least still keeps things local
11:10:59 <Saizan> kmc: defining just new monad transformers doesn't always work out well, e.g. if you define some special cased StateT s you're making it hard to use your code with e.g. IO's HOFs, while ReaderT (MVar s) might work fine
11:11:25 <cmccann> usually because I intend to change the base monad out, such as moving between STM and IO
11:14:54 <penelope> Transformers seem to have a pattern smell to them.
11:15:21 <yitz> kmc: sometimes you just use the monad transformer as it is. it's kind of like (,). in some simple cases you just use it. in other cases you define your own more meaningful ADT.
11:15:22 * hackagebot Dangerous 0.1.2 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.1.2 (NateSoares)
11:15:58 <gwern> > (512 / 188000) * 100
11:15:59 <lambdabot>   0.2723404255319149
11:18:35 <donri> “Monad transformers are like onions. At first, they make you cry but then you learn to appreciate them.”
11:20:44 <cmccann> donri, monad transformers are like onions in that they make you cry when you open them up to get at the inside, but are nice once they've been thoroughly cooked. Er, wait...
11:21:06 <kmc> monad transformers are like onions, in that they're better fried
11:21:13 <kmc> is it weird that i hate onions and love garlic?
11:21:30 <ksion> Maybe they are like ogres: they smell funny and make you cry?
11:21:56 <gwern> > sum $ map (0.027 *) [1467.23, 1504.67, 1587.76, 1716.83, 1779.54, 1781.50, 1867.44, 2012.89, 2109.74, 2374.08, 2528.86, 2694.81, 2846.00, 2894.10, 3194.44, 3387.47, 3565.04, 3749.15, 4012.66, 4493.58, 4783.39, 5082.85, 5553.22, 5992.54, 6210.21, 6777.44, 7537.75, 8010.84, 8724.87, 9560.89, 10203.23, 10760.57, 11912.82, 12660.86, 13517.60, 14557.66, 15793.41, 16203.01, 17262.30, 17920.65, 18806.86, 19676.04, 20331.72, 20620.84, 22064.37, 23119.20, ...
11:21:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:22:02 <gwern> ... 24086.62, 25273.98, 26193.01, 26988.90, 28538.82]
11:22:02 <cheater> kmc: garlic scares the womens away
11:22:06 <gwern> no, irc has failed me!
11:22:50 <donri> kmc: it's weird since garlic is an onion
11:24:09 <cmccann> kmc, how do you feel about leeks, shallots, or chives?
11:24:43 <xil> hi. So I'm using OpenGL and I noticed that my idleCallback is being called many many times while my displayCallback isn't, and my idleCallback ends with "postRedisplay Nothing" which I thought issues a command to redisplay
11:25:55 <kmc> cmccann, jatsu tsappari dikkari dallan tittari tillan titstan dullaa dipidapi dallaa ruppati rupiran kurikan kukka ja kirikan kuu
11:27:25 <cmccann> uh
11:27:27 <cmccann> ok
11:39:42 <Cale> cmccann: kmc is referring to http://www.leekspin.com/ which uses the gibberish bits of a Finnish song called Ievan Polkka
11:40:00 <cmccann> ah
11:40:26 <Cale> http://www.youtube.com/watch?v=1ygdAiDxKfI
11:40:47 <_Mikey> Merry Christmas guys!
11:40:51 <cmccann> clearly I'm out of the loop on important developments in internet culture :T
11:41:19 <xil> okay I'm just....I'm totally lost. I think laziness is butchering the logic behind the view side of my program
11:41:23 <ciaranm> did you know that people are photoshopping captions onto cats?
11:41:32 <xil> one thing in my display function is being evaluated, and nothing else
11:42:34 <Cale> xil: What does your program do? Laziness is usually completely transparent -- it'll sometimes reduce the work needed to compute the result of your program, and sometimes it'll result in higher memory consumption, but it'll never change the result of your program
11:42:59 <xil> Cale: I'm hpasting some stuff to help explain
11:43:04 <Cale> That is, unless you use unsafePerformIO
11:43:59 <hpaste> xil pasted “display” at http://hpaste.org/55688
11:44:31 <Cale> Oh, you're using Debug.Trace
11:45:23 * hackagebot Limit 1.0 - Wrapper for data that can be unbounded  http://hackage.haskell.org/package/Limit-1.0 (NateSoares)
11:45:23 <WarzoneCommand> is anyone using familiar with hxt ?
11:45:35 <Cale> Yeah, you can't necessarily rely on the order in which Debug.Trace messages get printed, or even really that they're printed at all, though it's fairly reliable. You seem to be in IO, why not just use putStrLn or something?
11:46:20 <WarzoneCommand> I want to pickle/unpickle the (= all) attributes of an XML-element into a Data.Map
11:46:21 <xil> Cale: oh I had traces in non-IO stuff and just kept putting them without thinking. I'll try putting putStrLns
11:46:25 <WarzoneCommand> but I'm not sure how to do that
11:46:26 <Cale> Or are you talking about how the traces in index2Color aren't printed?
11:47:14 <xil> Cale: oh they are, I took them out of the output by accident
11:47:21 <xil> there is other output I got rid of from other functions
11:47:30 <xil> but they are only output once
11:47:38 <xil> and should be every time "displaying" is
11:47:48 <alistra> hi
11:48:40 <_Mikey> hey!
11:48:55 <_Mikey> Wesołych!
11:49:18 <Cale> xil: So is everything good?
11:49:31 <alistra> _Mikey: lol you
11:50:10 <xil> Cale: well those traces in index2Color aren't being printed as often as they should be. They only output once and should be outputting 360000 times per second or thereabouts
11:51:20 <Cale> xil: Is this your actual code?
11:51:24 <xil> yes
11:51:28 <Cale> okay
11:51:41 <_Mikey> XD
11:51:50 <Cale> Oh, of course those traces will only show up once.
11:52:03 <Cale> Because the result of index2Color in either case is a constant
11:52:11 <xil> oh lol
11:52:19 <Cale> and once that constant is computed, it's not going to be computed again
11:52:22 <xil> okay so then I'm having a different problem
11:52:30 <xil> the screen is black, but clearly should be white
11:53:53 <xil> I think I had this problem once before and found it to be that I used the wrong constructors for PixelData
11:54:17 <xil> but when I try 'UnsignedByte" rather than "ThreeBytes" I get segfaults, so I don't know what to try next
11:54:49 <Cale> Try gloss, lol
11:55:05 <xil> can't because it doesn't handle IO and I need that
11:55:12 <Cale> what?
11:55:22 <xil> sorry I mean
11:55:42 <xil> the function for generating a Picture for gloss has a type ... -> Picture, but I need it to be ... -> IO Picture
11:55:53 <Cale> hmm...
11:55:56 <Cale> Why is that?
11:56:07 <xil> because I have IORefs
11:56:17 <Cale> so?
11:56:23 <xil> go on
11:56:51 <Cale> Well, you're going to be displaying the thing in IO eventually.
11:57:03 <Cale> so you can get the values of the IORefs beforehand?
11:58:03 <xil> but how do I actually do it with gloss? What I saw is that you give gloss a starting 'world' which can be whatever I want, and a function from world -> Picture and another from Float -> world -> world
11:58:07 <Cale> oh, perhaps it's moderately inconvenient that gameInWindow doesn't have a parameter which can accomplish that extra IO on the fly
11:58:12 <xil> so no where in there can I extract the IORef and give it to gloss
11:58:29 <Cale> How is this IORef updated? Continuously?
11:58:36 <xil> idleCallback
11:58:50 <xil> so yes, continuously
11:58:53 <kmc> Debug.Trace is a fairly reliable way to look at evaluation order.  evaluation order is usually not what you care about
11:58:55 <xil> sorry, misread
11:59:01 <kmc> (but might be, if you're diagnosing space leaks)
11:59:48 <Cale> bitmapOfForeignPtr :: Int -> Int -> ForeignPtr Word8 -> Bool -> Picture  -- rofl
11:59:58 <Cale> This is clearly unsafe
12:00:05 <Cale> But it might be what you want anyway
12:01:19 <xil> I almost want to stay away from gloss just because I've come so close to finishing this without it already. I'm going to need to eventually improve upon this and I can go to gloss then
12:01:38 <xil> I just don't see why this won't work as is
12:01:46 <Cale> Well, gloss isn't perfect, it just tends to be easy for simple things
12:01:53 <Cale> hmm
12:02:01 <xil> yeah and I was going to use it from the beginning, until that IO concern
12:02:02 <Cale> Well, maybe I can try running your program?
12:02:06 <monochrom> actually, in the long run, most of your time is spent on memory costs, so most of the time you will worry about evaluation order.
12:02:10 <xil> sure, let me post all the code
12:04:13 <hpaste> xil pasted “Mandelbrot.hs” at http://hpaste.org/55689
12:04:16 <hpaste> xil pasted “MandelbrotModel.hs” at http://hpaste.org/55690
12:04:19 <hpaste> xil pasted “MandelbrotAux.hs” at http://hpaste.org/55691
12:07:37 <monochrom> xil: I do not know whether my gtk2hs example helps you. here is some relevant features. it has a GUI in one thread. it has time-consuming data crunching (String in my case) in another thread, and you already know why. My point is: (let's call the answer fx) in the data-crunching thread, "evaluate fx" is not enough, we have to do something more, equivalent to "deepseq" but I rolled my own. eventually for me it is "evaluate (se
12:07:37 <monochrom> q_all fx)", with "seq_all" doing a deepseq
12:07:47 <monochrom> the url is http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
12:08:42 <xil> monochrom: I brought it all into one thread temporarily, until I can get it to work that way and later I can make it multi-threaded or otherwise parallelized
12:10:09 <monochrom> another of my page, more relevant, but takes more time, is http://www.vex.net/~trebla/haskell/lazy.xhtml
12:10:23 * hackagebot yesod-json 0.2.2.2 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.2.2.2 (MichaelSnoyman)
12:10:25 * hackagebot Focus 0.1 - Tools for focusing in on locations within numbers  http://hackage.haskell.org/package/Focus-0.1 (NateSoares)
12:10:27 * hackagebot Focus 0.1.1 - Tools for focusing in on locations within numbers  http://hackage.haskell.org/package/Focus-0.1.1 (NateSoares)
12:10:53 <monochrom> but it doesn't tell you what happens to "data E = E !Int" yet, so it may be not 100% helpful
12:13:00 <monochrom> it does warn you about accumulating a large "1+(2+(3+(4+..." on the heap before anything useful happens, and that is the major cost to memory in most cases.
12:15:03 <xil> Cale: have you had any luck?
12:15:23 * hackagebot packdeps 0.1.0.1 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.1.0.1 (MichaelSnoyman)
12:15:24 <Cale> I'm seeing the same thing that you are
12:15:42 <xil> Cale: I'm going to check out the C docs for drawPixels =/
12:17:01 <Cale> Unfortunately, OpenGL is one of the most confusingly stateful libraries ever designed, and there are a lot of ways to mess things up so that you get the wrong result (or terrible performance)
12:21:07 <cmccann> opengl is very simple to use, you just write some code, run it, and get an empty black rectangle
12:21:25 <cmccann> supposedly you can do other things with it as well but I think people might be pulling my leg about that
12:21:40 <Cale> haha
12:21:45 <xil> lol
12:22:25 <gwern> > (28.6 + 188) / 2
12:22:26 <lambdabot>   108.3
12:22:28 <_Mikey> wpic
12:22:33 <_Mikey> epic
12:22:36 <_Mikey> I love OpenGL
12:22:49 <xil> I've used OpenGL very successfully in Java and I've made it work in Haskell, but not with drawPixels
12:23:11 <_Mikey> my love OpenGL comes with a C++ condition.
12:23:21 <_Mikey> I need to get busy with it in Haskell soon though
12:23:28 <parcs`> how is the design of opengl compared to directx? i'm not familiar with the latter
12:23:43 <parcs`> or rather direct3d
12:25:09 <OscarZ> lol @ cmccann... exactly what happened when I tried it a long time ago :) there's this higher level lib called glut that makes setting up the cameras easier
12:25:16 <parcs`> i haven't done any serious opengl stuff but i read debugging is a nightmare, espeically with shaders
12:25:23 * hackagebot Dangerous 0.2 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.2 (NateSoares)
12:25:25 * hackagebot lifted-base 0.1.0.2 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.1.0.2 (BasVanDijk)
12:25:27 * hackagebot Dangerous 0.2.1 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.2.1 (NateSoares)
12:28:38 <xil> hmmm...I can't find the import for GLInt
12:29:08 <xil> oh, misspelled
12:31:57 <OscarZ> someone mentioned Curry-Howard correspondence last night.. I know its about relation between type systems of programming languages and mathematical proofs..
12:33:28 <OscarZ> I dont quite get it how it would work.. for example, would it be possible to express Euclid's proof somehow using Haskell type system ?
12:34:10 <hpc> OscarZ: it makes a lot more sense in dependently-typed languages
12:34:26 <OscarZ> would it then work so that if you got your program to compile, you would have it proved?
12:34:35 <hpc> indeed
12:35:17 <merijn> That, or found a bug in your compiler/inconsistency in your type system :>
12:35:21 <byorgey> OscarZ: however, Haskell's type system corresponds to an inconsistent logic
12:35:33 <hpc> OscarZ: sec while i look up some good examples; djinn is a good tool for demonstrating this
12:35:46 <OscarZ> That seems strange for someone who hasnt really thought about types in that depth and coming from imperative background :)
12:36:02 <byorgey> OscarZ: so in the Curry-Howard sense you can prove anything using Haskell.  You can always give 'undefined' as a value/proof for any type/theorem.
12:36:14 <OscarZ> what are dependent types or is that a difficult topic? I dont have much background on this..
12:36:31 <hpc> OscarZ: ignore dependent types for now; i shouldn't have brought it up
12:36:33 <kmc> OscarZ, http://www.cis.upenn.edu/~bcpierce/sf/
12:36:34 <hpc> OscarZ: here's a good example
12:36:45 * byorgey was just going to suggest Software Foundations too
12:36:52 <hpc> OscarZ: suppose you wanted to "prove" the proposition: https://upload.wikimedia.org/wikipedia/en/math/1/f/2/1f259541449e74585dfecef6def5e22d.png
12:37:30 <hpc> OscarZ: as a haskell type, that would be (p -> q, q -> r) -> p -> r
12:37:34 <byorgey> OscarZ: the online textbook kmc linked to is a great (and fun) way to learn about dependent types and the curry-howard isomorphism.
12:37:49 <hpc> OscarZ: or curried, (p -> q) -> (q -> r) -> p -> r
12:37:56 <hpc> OscarZ: and the proof of that proposition is:
12:38:02 <hpc> @djinn (p -> q) -> (q -> r) -> p -> r
12:38:02 <lambdabot> f a b c = b (a c)
12:38:06 <merijn> OscarZ: Dependent types allow you to have values in your type system. Right now you are probably familiar with things like "Maybe a" which is a type that has another type as argument (the a). Dependent types let you create types by using values too. You could than create a type like "Vector a 5" which is the type of all Vectors of length 5 containing elements of type a
12:38:31 <kmc> OscarZ, it's fun because the exercises are interactions with a proof assistant (Coq), so you get instant feedback and it's basically like an addictive puzzle game :)
12:38:43 <OscarZ> thanks I will look at them.. also got a book recommendation from kmc, "Types and programming languages".. shame the book is quite expensive
12:38:45 <kmc> it's by far the best experience i've had learning from a textbook on my own
12:39:02 <merijn> kmc: Is there something similar for Agda or is it just Coq?
12:39:11 <kmc> merijn, not that I've seen
12:39:15 <merijn> Bummer
12:39:20 <kmc> yeah :/
12:39:27 <byorgey> OscarZ: Software Foundations (the online textbook) covers much of the same material as TaPL
12:39:29 <kmc> it would be cool to translate the book
12:39:34 <merijn> Coq syntax gives me brain damage
12:39:35 <xil> AHA!!!!
12:39:38 <byorgey> OscarZ: in fact, the course that used to be taught using TaPL is now taught using SF
12:39:46 <kmc> though, writing proofs in agda is quite different from writing proofs in coq
12:40:15 <merijn> I've got the Agda Tutorial, but that's a bit to abbreviated for me
12:41:32 <kmc> which one is that?
12:41:36 <OscarZ> thanks for the book tips..
12:42:10 <merijn> kmc: It's just called "Agda Tutorial" by Ulf Norell (sp?)
12:42:25 <kmc> oh
12:42:36 <kmc> i read "Dependently Typed Programming in Agda", which is quite good
12:42:39 <kmc> by the same author
12:42:52 <kmc> but it's a taste of what you can do, not a comprehensive tutorial
12:42:57 <xil> okay I figured out why it's black, but the fix causes a segfault, but I think it's a segfault because I'm off by 1 somewhere and can't figure out where =/
12:45:23 * hackagebot unbounded-delays 0.1.0.3 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.3 (BasVanDijk)
12:46:46 <OscarZ> so, Haskell's type system corresponds to an inconsistent logic? whats this "undefined" type? why there has to be such thing?
12:47:00 <kmc> Haskell allows unrestricted recursion
12:47:05 <kmc> because programmers like that, for writing programs
12:47:11 <Cale> The type of undefined is  forall a. a
12:47:15 <kmc> but this means any computation might fail to terminate
12:47:20 <kmc> :t let x = x in x
12:47:20 <lambdabot> forall t. t
12:47:28 <Cale> :t fix
12:47:29 <lambdabot> forall a. (a -> a) -> a
12:47:30 <kmc> that's a "proof" of any statement
12:47:30 <hpc> OscarZ: what makes haskell's type system inconsistent is fix
12:47:38 <Cale> :t fix id
12:47:38 <lambdabot> forall a. a
12:47:46 <kmc> once you have this, you might as well have explicit error / undefined terms also
12:47:53 <hpc> OscarZ: fix's type says "give me a proof that something implies something, and i will prove that something"
12:48:08 <hpc> OscarZ: so you give it the identity function and it has a proof of everything, including false
12:48:10 <Cale> that something implies itself, to perhaps be clearer
12:48:11 <hpc> :t fix id
12:48:11 <lambdabot> forall a. a
12:48:13 <merijn> OscarZ: Haskell's type system is (mostly) strongly terminating, which means all computation terminates. However this also means Haskell wouldn't be Turing complete, which some people seem to think is a handicap
12:48:21 <hpc> er yeah, that it implies itself
12:48:37 <kmc> no, the problem isn't fix
12:48:42 <kmc> the problem is that recursion is built into the language
12:48:46 <kmc> in 'let' and 'where' etc
12:48:53 <kmc> fix is an ordinary function you can write using that
12:49:06 <hpc> fix is an ordinary function you can write without 'let'
12:49:08 <Cale> Well, you can also consider the built-in recursion to be implemented in terms of fix
12:49:15 <hpc> :t let fix f = f (fix f) in fix
12:49:15 <OscarZ> Cale: i remember you telling about fix before.. I didnt realize how it is related to the type system..
12:49:16 <lambdabot> forall t. (t -> t) -> t
12:49:34 <kmc> OscarZ, the type of 'fix' is not a theorem; it's blatantly false
12:49:37 <kmc> (T implies T) implies T
12:49:48 <merijn> Also known as "a filthy lie"
12:50:06 <OscarZ> heh
12:50:10 <kmc> but more directly, «let x = x in x» has type T for any T you like
12:50:13 <kmc> it's a proof of everything
12:50:17 <Cale> It's also blatantly true, in the case of Haskell ;)
12:50:23 * hackagebot Dangerous 0.2.2 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.2.2 (NateSoares)
12:51:05 <dolio> There are lots of loopholes in Haskell's type system.
12:51:11 <dolio> Of course, they'd be inconvenient to use.
12:52:01 <c_wraith> there are intentionally-unsound corners that are convenient to use...
12:52:15 <c_wraith> Given that, there's little reason to use the inconvenient points
12:52:22 <dolio> I guess negative types aren't that inconvenient.
12:52:33 <dolio> Except they cause the optimizer to loop in the case of GHC.
12:52:34 <OscarZ> I've understood Turing complete programming languages have to have some inconsistency like this.. does it have anything to say about a programming language how it chooses to implement this inconsistency?
12:53:07 <monochrom> I don't consider it an inconsistency.
12:53:14 <Jeanne-Kamikaze> how do I wrap a function in a FunPtr ?
12:53:26 <OscarZ> monochrom: how come?
12:53:50 * merijn mumbles something something paraconsistent logic something something
12:53:55 <Jeanne-Kamikaze> I have a Ptra a -> IO (), but now newForeignPtr wants a FinalizerPtr a, which is basically a FunPtr
12:54:56 <monochrom> the right question is, how come you consider it an inconsistency? answer: because you translate data type (t->t)->t to logic proposition (false->false)->false. I say, the inconsistency is in your translation. I don't translate, I get no inconsistency.
12:55:46 <kmc> Jeanne-Kamikaze, there's an answer to "how do I wrap a function in a FunPtr" which I can give, but I think instead you want to use Foreign.Concurrent.newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
12:57:07 <merijn> monochrom: That only means you don't have an inconsistency when there's no inhabitants of t, right? (assuming forall t . (t->t)->t)
12:57:13 <alistra> cabal-dev can't figure out if my alex and happy are only installed locally
12:57:51 <Jeanne-Kamikaze> I just saw the examples in the docs
12:58:28 <dolio> Haskell is clearly inconsistent as a logic. A more relevant question is probably: does that matter. And the answer for most people's purposes is: no.
12:59:54 <monochrom> actually, (t->t)->t is consistent when t is inhabited, by "undefined" for example.
13:00:20 <OscarZ> I'm not even familiar with forall in a type definition..
13:00:23 * hackagebot concurrent-extra 0.7.0.2 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.2 (BasVanDijk)
13:00:25 * hackagebot dstring 0.4.0.2 - Difference strings  http://hackage.haskell.org/package/dstring-0.4.0.2 (BasVanDijk)
13:00:28 <hpc> monochrom: that's kind of like saying "x is true as long as x is true" :P
13:01:08 <dolio> No, it's not consistent.
13:01:11 <dolio> It's sound.
13:01:12 <Sgeo> Can fix be programmed into djinn and we'll see what it can come up with based on that (e.g. if it can prove a->b)?
13:02:07 <dolio> Haskell is also unsound as a logic, but that's even more silly, because what matters is whether it's sound with respect to its own expected models.
13:02:11 <hpc> @djinn (a -> a) -> a
13:02:11 <lambdabot> -- f cannot be realized.
13:02:13 <dolio> In which every type is inhabited.
13:02:14 <xil> hi. Wondering if someone can help me with a segfault. My screen is 600x600 pixels. I just tested and the segfault happens when I try to display more than 392 pixels in width
13:02:43 <hpc> Sgeo: i think djinn is designed so you can assume the resulting function is total
13:02:59 <dolio> Of course, it's unsound with respect to those if you add unsafeCoerce.
13:03:00 <Sgeo> And I guess fix isn't total
13:03:04 <Sgeo> ?
13:03:08 <Sgeo> > fix (1+)
13:03:12 <lambdabot>   mueval-core: Time limit exceeded
13:04:15 <Sgeo> (a -> a) -> Maybe a would be total, I guess. Not that it could be written, though, I think :/
13:04:35 <hpc> Sgeo: yeah; if you pass a defined parameter to fix (ie, not undefined), then it can still produce an undefined result
13:04:44 <kmc> you can model nonterminating computations with a monad
13:04:51 <hpc> and yeah, that total function would be a solution to the halting problem
13:04:56 <dolio> Not with Maybe, though.
13:04:57 <hpc> kmc: lol
13:05:01 <dolio> Unless you have an oracle.
13:05:31 <kmc> in which case the logic is consistent again
13:05:33 <alistra> anybody here experienced with cabal-dev?
13:05:42 <alistra> i would have a few questions
13:05:45 <monochrom> I see that my stance is "Haskell is also unsound as a logic, but that's even more silly".
13:05:48 <kmc> i don't know much about this though; I don't know if it's inconvenient in practice
13:05:49 <OscarZ> when it makes sense to write a type definition as id forall a . a -> a, isnt just "a" enough to mean any type ?
13:05:50 <merijn> hpc: Why is that laughable? I had the same idea when I decided I no longer care about Turing completeness
13:06:13 <hpc> merijn: what's funny is the "by the way, this is a monad" stuff
13:06:32 <merijn> Most non-terminating programs seem to be server/daemon type thingies which can be accurately modelled by an infinite loop calling terminating code for every request
13:06:41 <hpc> merijn: every new "monad" blows my mind
13:06:59 <merijn> In which case you could have a strongly terminating language with a non-termination monad and your set :)
13:07:07 <merijn> Screw this Turing completeness bogus :>
13:07:48 <Sgeo> For every (Monad m) where m follows the monad laws, m is a monad!
13:08:28 <merijn> Sgeo: Yo dawg! We heard you like monads so we put a monad in your monad so you can bind while you bind!
13:08:41 <cmccann> merijn, that would be productive corecursion, then
13:08:45 <kmc> OscarZ, the 'forall' syntax isn't in Haskell; it's a GHC extension.  used for a few different things
13:09:10 <kmc> one is to bring a type variable into scope in nested definitions
13:09:25 <merijn> OscarZ: "a -> a" in haskell is shorthand for GHC's notion of "forall a . a -> a"
13:09:58 <kmc> another is to write the types of functions which require polymorphism from their arguments
13:10:03 <kmc> (higher-rank polymorphism)
13:10:04 <monochrom> you cannot escape turing-completeness
13:10:32 * Sgeo hands HQ9+ to monochrom 
13:10:48 <monochrom> sorry, what is HQ9+?
13:10:56 * cmccann is increasingly unconvinced that turing completeness is a desirable property for general-purpose programming
13:10:56 <dolio> If you have a monad for general recursion, you're effectively Turing complete.
13:11:08 <dolio> Unless you also believe that Haskell is incapable of doing I/O or something.
13:11:19 <kmc> dolio, reddit told me!
13:11:28 <Sgeo> An esoteric programming language with 4 commands. H prints Hello world, Q prints the source code of the program, 9 prints 99 bottles of beer on the wall, + increments the accumulator
13:11:43 <merijn> cmccann: Corecursion in the sense of infinite recursion I guess? Rather than the coroutine sense
13:11:54 <merijn> Sgeo: ...
13:12:09 <cmccann> merijn, corecursion in the sense of an infinite list in Haskell
13:12:30 <OscarZ> <lambdabot> forall t. (t -> t) -> t
13:12:30 <c_wraith> merijn: corecursion isn't required to be infinite, actually.  It's just required to do useful work per step.
13:12:33 <cmccann> where "infinite" is defined as "at least one more than you needed"
13:12:33 <dolio> Productive corecursion is where you're guaranteed to yield some portion of the output in finite time at each step.
13:13:04 <cmccann> and yeah, it doesn't need to be infinite, that's just where the difference is most obvious
13:13:16 <cmccann> since recursing on an infinite structure tends to be less useful
13:14:17 <OscarZ> I dont understand whats inconsistent in that as a type..
13:14:45 <Eduard_Munteanu> OscarZ: it's not
13:14:46 <cmccann> OscarZ, it says that for any proposition t, if t implies itself, then t is true
13:14:51 <monochrom> that's what I am saying. nothing inconsistent if you take that as just a type
13:15:10 <Eduard_Munteanu> Ah.
13:15:30 <cmccann> logically that's silly, but it's a sensible type in a turing complete language
13:15:39 <Eduard_Munteanu> Well, you can't write an implementation for that according to parametricity.
13:16:10 <Eduard_Munteanu> "Here's a function from an unknown set to itself, provide a member of that set".
13:16:15 <merijn> OscarZ: If you treat it as logic (as opposed to just a type) it's silly, "t implies t" is an obvious tautology "(t implies t) implies t" is the same as just saying "t". i.e. I can fabricate any proof out of thin air
13:16:50 <kmc> OscarZ, the type (a -> b) corresponds to the proposition (a -> b) i.e. "a implies b"
13:16:56 <Sgeo> Is "t implies t" a tautology? I was reading about Lob's theorem, and .. I guess I'm a bit confused
13:16:56 <kmc> a term of that type is a proof of the proposition
13:17:14 <kmc> Sgeo, yes, it is.  that's why "(t implies t) implies t" is a problem
13:17:17 <kmc> it lets you prove anything
13:17:34 <kmc> anyway I'm still not sure focusing on "fix" is correct
13:17:41 <kmc> it's not intrinsic to Haskell; it's just a function someone wrote
13:17:42 <Eduard_Munteanu> You might remark t could be ⊥
13:17:46 <merijn> Sgeo: Yes. a -> b is true if "b" is true for all true values of "a"
13:18:03 <Eduard_Munteanu> But there is a ⊥ -> ⊥
13:18:07 <kmc> :t let x = x in x
13:18:08 <lambdabot> forall t. t
13:18:10 <OscarZ> sorry.. im a bit confused here.. i keep thinking of function type a -> b... as something of type a mapped to type b .. but this is a type definition
13:18:27 <Eduard_Munteanu> However ⊥ has no inhabitants.
13:18:37 <monochrom> yes, and I'm saying, nothing wrong with that type
13:18:45 <Sgeo> OscarZ, types can be considered to be logical statements
13:18:53 <merijn> Eduard_Munteanu: Not a problem, _|_ is not true, so it's irrelevant what the right handside of the -> is
13:19:02 <Sgeo> Where the type is a statement and a value of that type is the proof of that statement
13:19:12 <Eduard_Munteanu> Yep.
13:19:14 <monochrom> people start pretending it's logic and seeing problems. that's really their problems.
13:19:44 <Sgeo> merijn, it's irrelevent, in that it makes the whole -> be true
13:19:54 <merijn> Sgeo: Yes
13:20:08 <merijn> monochrom: I think we coved a few times now already that it's not a problem if you disregard the notion of types being a logic
13:20:09 <kmc> OscarZ, the type "T" corresponds to the proposition "T is inhabited", i.e. "T has values"
13:20:16 <Sgeo> Oh, I think I mistakenly thought I disagreed with merijn
13:20:16 <kmc> OscarZ, a value of type T is a proof of that proposition
13:20:21 <kmc> does that make sense?
13:21:22 <Eduard_Munteanu> @google curry-howard
13:21:23 <lambdabot> http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
13:21:23 <lambdabot> Title: Curry–Howard correspondence - Wikipedia, the free encyclopedia
13:21:31 <monochrom> sure, merijn, so explain to me why everyone else is still discussing this, in particular why is the asker still asking.
13:21:48 * Sgeo is a derp, id
13:22:47 <OscarZ> its because of my ignorance.. we can stop this if you are bored of the topic.. i'd better do some reading on it
13:22:49 <merijn> monochrom: If you're interested in types as logic then it's still interesting
13:23:07 <kmc> OscarZ, I'm more than willing to explain Curry-Howard, it's a cool topic :)
13:23:24 <merijn> monochrom: So the question is, did he just want to know about haskell programming or did he want to know about Curry-Howard and type theory
13:23:28 <monochrom> I'm fine with non-stopping it. As long as I'm free to non-stop it, too.
13:23:39 <merijn> I distinctly got the impression that the latter was the case
13:23:54 <OscarZ> should we change to haskell-blah or some other chan?
13:24:03 <kmc> i think it's on-topic enough
13:24:08 <OscarZ> a bit about both..
13:24:09 <kmc> did the thing i said just now make sense?
13:24:20 <monochrom> I get the former impression. the exact wording supports it. "as a type", "this is a type definition". where is the logic?
13:24:45 <OscarZ> yes KMC
13:24:50 <kmc> ok cool :)
13:25:01 <kmc> so propositions like Int and Char are boring; you can 'prove' them immediately
13:25:05 <kmc> 3 is a proof of Int, whatever :)
13:25:21 <kmc> slightly more interesting are (a,b) and (Either a b)
13:25:29 <kmc> which are proofs of "a and b"  and  "a or b" respectively
13:25:31 <cmccann> and the unicode standard is a disproof of char, har har
13:25:40 <monochrom> hahaha
13:25:41 <mike-burns> Hah.
13:25:48 <OscarZ> :P
13:26:12 <kmc> er, I mean values of those types are proofs of those propositions
13:26:19 <OscarZ> ok.. so the value is enough to be proof of the type ?
13:26:21 <kmc> (3,'x') is a proof of "Int and Char"
13:26:33 <kmc> (Left 3) is a proof of "Int or Char".  so is (Right 'x')
13:26:44 <Shin-LaC> what statement corresponds to "Int"?
13:26:48 <kmc> "there are Ints"
13:26:55 <kmc> the type "T" corresponds to the proposition "T is inhabited", i.e. "T has values"
13:26:57 <Shin-LaC> makes sense
13:27:14 <Eduard_Munteanu> Well, trivially.
13:27:19 <OscarZ> ok
13:27:27 <kmc> anyway a function of type "a -> b" is a proof of the proposition "a implies b"
13:27:42 <kmc> a proof that, if type 'a' is inhabited, then type 'b' must be inhabited
13:27:45 <Eduard_Munteanu> The thing that usually matters is proving logical stuff rather than plain inhabitance, it's the other way around.
13:27:47 <monochrom> @remember cmccann <kmc> 3 is a proof of Int, whatever :) <cmccann> and the unicode standard is a disproof of char, har har
13:27:47 <lambdabot> I will remember.
13:28:20 <OscarZ> kmc: right
13:28:24 <Shin-LaC> kmc: I see
13:28:33 <kmc> but in Haskell all types are inhabited
13:28:43 <kmc> by terms like «let x = x in x» or «error "foo"»
13:28:46 <Eduard_Munteanu> Ok... let's all move to #agda now :P
13:28:58 <kmc> so you can "prove" any proposition
13:29:21 <kmc> in particular you can write a function of type (t -> t) -> t
13:29:32 <kmc> which is a logical falsehood
13:29:34 <xil> hmmm....so I think mallocArray, or pokeArray, just broke my computer. I was using withArray to do my pointer stuff, and was suspicious that it just wasn't allocating enough space for the whole list. So I used mallocArray and pokeArray to do it manually and instead of a segfault it broke X and I had to hard reset
13:29:38 <kmc> :t let fix f = f (fix f) in f
13:29:39 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:29:43 <kmc> derp
13:29:44 <kmc> :t let fix f = f (fix f) in fix
13:29:45 <lambdabot> forall t. (t -> t) -> t
13:29:57 <kmc> :t let fix f = (let x = f x in x) in fix
13:29:57 <lambdabot> forall t. (t -> t) -> t
13:30:19 <merijn> xil: That sounds unlikely
13:30:31 <monochrom> it probably broke more than X
13:30:33 <merijn> xil: Unless you run an OS that doesn't do virtual memory and segmentation :p
13:30:53 <xil> what I know is that I didn't change anything but that, and it broke my comp
13:30:54 <Sgeo> Does House do those things?
13:31:04 <xil> and I run Arch Linux
13:31:20 <monochrom> otoh you probably had pointer miscalculations when you malloc'ed and poked
13:31:52 <kmc> most x86 OSes don't use segmentation, but yes they should have memory protection through paging
13:31:58 <kmc> xil, you're using OpenGL?
13:32:02 <xil> yes
13:32:08 <kmc> then i'm not surprised that you crashed X
13:32:20 <merijn> kmc: Yeah, I guess I meant paging
13:32:23 <kmc> not sure exactly what would have caused it, but graphics drivers are often buggy
13:32:32 <xil> UGH!
13:32:36 <kmc> (what i mean is they do use segmentation, but only to the extent required by the architecture)
13:32:52 <kmc> xil, did you try using SDL?
13:32:53 <xil> any ideas why withArray doesn't allocate the whole list?
13:33:11 <xil> kmc: not yet because I have to learn all of SDL, whereas all I had to learn for OpenGL was pointers
13:33:38 <kmc> ok well i told you like two dozen times that what you're doing is easier in SDL
13:33:43 <kmc> and i even provided example code
13:34:02 <kmc> maybe you should suck it up and learn to use the right tool, instead of repeatedly hitting bugs using the wrong tool
13:34:18 <Sgeo> If I've done XNA before, how easy/hard is SDL to learn?
13:34:23 <kmc> 5
13:34:35 <merijn> >.>
13:34:40 <Clint> <.<
13:34:41 <Sgeo> (Only reason I've done XNA before is due to a class)
13:34:45 <Sgeo> kmc, ?
13:34:46 <kmc> %.%
13:34:48 <ion> Yea, about 5.
13:35:03 <Clint> 5 in which base?
13:35:07 <kmc> 0
13:35:15 <merijn> Sgeo: How easy is XNA to work with?
13:35:29 <Silvah> 6
13:35:34 <Sgeo> merijn, I don't remember
13:35:42 <Sgeo> Fairly simple for basic stuff, I guess
13:35:45 <parcs`> Sgeo: C SDL?
13:35:47 <OscarZ> kmc: ok.. so the type (t -> t) -> t is just the type definition of the function that is problematic? but if we pretend that we had a "perfect" type system, there would be no way to define such thing and make it compile?
13:35:51 <merijn> And I guess more importantly, do you need an XBox for it :p
13:36:10 <xil> because OpenGL should be able to do this. You understand more than I do why OpenGL is a horrible choice for this, so it's easier for you to know that I should be using SDL. For me, I already know OpenGL very well and the idea of learning SDL from scratch seems more intimidating than figuring out these problems, which OpenGL shouldn't necessarily be having anyway
13:36:25 <Sgeo> merijn, no, but Linux is probably problematic
13:36:36 <kmc> OscarZ, I don't know what you mean by "problematic" and "perfect"
13:37:04 <kmc> the type  (t -> t) -> t  is a logical falsehood, so if a "perfect type system" is a consistent logic, then you cannot be allowed to write a function of that type
13:37:10 <merijn> Sgeo: Meh, I don't care about linux anyway :p
13:37:13 <xil> kmc: I might have gone with SDL if people pushed it more from the beginning, but when I asked at the start of this project people were kind of all over the place with recommendations, so I went with what I knew
13:37:26 <kmc> the reason you can write a function of that type in Haskell is that Haskell allows unrestricted recursion
13:37:44 <kmc> OscarZ, in languages designed more for theorem proving (Coq, Agda, etc.), recursion is restricted to forms which are logically sound
13:38:30 <kmc> if you want to use recursion in a complicated way, you have to prove that the recursion terminates
13:38:40 <ion> Is there a way to do point-free self-recursion in Agda?
13:40:27 <OscarZ> kmc: yes.. problematic = one that allows infinite loop, perfect = one where such thing would not be possible
13:41:23 <kmc> ion, you can do bounded recursion
13:41:34 <kmc> (a → a) → Nat → Maybe a
13:42:28 <ion> ok
13:42:32 <kmc> this generalizes to the idea of well-founded induction
13:42:34 <kmc> http://www.cse.chalmers.se/~nad/listings/lib/Induction.WellFounded.html#1
13:43:36 <kmc> 'When using well-founded recursion you can recurse arbitrarily, as long as the arguments become smaller, and "smaller" is well-founded.'
13:44:31 <Axman6> merry christmas peeps
13:44:59 <kmc> the "smaller" relation is well-founded if all non-empty sets have a minimal element
13:45:09 <Silvah> Screw christmas.
13:45:11 <monochrom> already? well, merry christmas for you there, not yet here, need a few more hours
13:45:11 <kmc> this prevents you from defining "smaller" in such a way that arguments can become smaller infinitely many times
13:45:55 <monochrom> in other words the lack of infinite descent
13:47:11 <kmc> i think this also relies on the fact that no type has uncountably many elements?
13:47:33 <monochrom> orthogonal to countability
13:48:01 <irene-knapp> I would expect that you don't need to be able to count them for the proof to hold,
13:48:03 <irene-knapp> but I dunno?
13:48:45 <monochrom> of course, countability makes life easier in practice.
13:49:49 <kmc> can't i do well-founded infinite recursion on the nonnegative real numbers, with the usual <-relation and f(n) = f(n/2) ?
13:50:17 <dolio> The usual < isn't well-founded.
13:50:24 <irene-knapp> hmm
13:50:33 <Sgeo> Wouldn't that just be rationals?
13:50:34 <irene-knapp> wait, what prevents "proofs" like
13:50:49 <irene-knapp> wait, never mind
13:51:07 <kmc> oh, because not every subset has a minimal element
13:51:11 <kmc> even though the whole set does
13:51:18 <dolio> Right.
13:51:50 <kmc> anyway i don't think it's the case that well-founded induction always involves a finite number of steps, in math
13:51:57 <russellw> The termination proof technique I remember is that you have to be able to define a variant that's a natural number, and decreases by at least one each step
13:51:59 <kmc> cause it's used for transfinite induction
13:52:22 <russellw> This is a more powerful technique, that can prove termination on things that aren't isomorphic to natural numbers?
13:52:26 <kmc> russellw, yeah, that's an example of well-founded induction
13:52:28 <kmc> right
13:52:29 <kmc>  
13:52:30 <kmc> sorry
13:52:36 <russellw> Okay, cool
13:52:39 <monochrom> no one uses the usual < of the reals for recursion over the reals. the non-well-foundedness of this < is irrelevant.
13:52:47 <alistra> need a cabal-dev professional for a quick qustion
13:53:02 <kmc> alistra, just ask your question
13:53:14 <kmc> anyway, I am wondering what prevents transfinite well-founded induction in e.g. agda
13:53:22 <dolio> Transfinite induction is used to prove things terminate, too. :)
13:53:23 <kmc> and is this related to the fact that all types are countable
13:53:31 <dolio> Finitely.
13:54:00 <kmc> maybe i don't understand what transfinite induction is
13:54:06 <Silvah> Could someone help me with a problem I can't solve? It's not really Haskell-related, but let's pretend it is.
13:54:16 <alistra> well ok, if my cabal-dev ghci works, how am i supposed to compile a project using ghc --make (what flags for includes) without resorting to cabal-dev build/install
13:54:31 <dolio> Essentially, when you come up against a limit ordinal, you're required to make a finitizing (to coin a term) choice.
13:54:36 <alistra> or how to pass arguments to the cabal-dev ghci
13:54:39 <monochrom> if I were writing a total recursive function R->R, I would recurse like f x | abs x >= 1 = ... f (x/2) ... | otherwise = done. now I have a well-founded relation over the reals.
13:55:27 <monochrom> transfinite induction = well-founded induction on ordinals
13:56:09 <russellw> monochrom, but that proposed function can be shown to terminate, using natural numbers
13:56:24 <monochrom> ordinals = my http://www.cs.toronto.edu/~trebla/transfinite.txt
13:56:29 <russellw> Let the variant be the log to the base two of x, rounded to the nearest integer
13:56:58 <exFalso> well foundedness is precisely about termination
13:57:08 <dolio> So, when you're at ω, you can assume you have a proof for any natural number n, with no bound on n.
13:57:13 <dolio> But all those are finite.
13:57:30 <Goosey124> I've decided I'll work on an irc bot with a spell checker using bloom filter...However, I don't know what the networking library is .-.
13:57:40 <monochrom> I suppose you just mean that pulling out a custom-made well-founded relation on the reals is overkill. I disagree, but I respect your view. still, does not contradict my little custom-made well-founded relation.
13:57:52 <exFalso> Silvah: go ahead ask you don't need permission:)
13:58:41 <russellw> Well, mainly I'm just trying to understand what you need a more powerful technique for - but the explanation on that page looks interesting, thanks!
13:59:26 <monochrom> I need a powerful technique to refute the myth that uncountable sets such as the reals are deprived of well-founded relations.
13:59:38 <russellw> fair enough :)
13:59:46 <AfC> Goosey124: https://github.com/dom96/SimpleIRC works alright
14:00:06 <monochrom> there is no flying cannot-be-well-founded monster :)
14:00:14 <Goosey124> AfC: Wow, that's helpful :D Thanks
14:00:54 <dolio> Your recursive function isn't total anyway. :)
14:00:59 <Silvah> It might sound silly, and it really is, but... whatever. How one can efficiently represent a bimap using a notebook and a pencil? It's worth noting that insertions and lookups will be very frequent.
14:01:59 <dom96> AfC: I hope it works a bit better than just "allright" :P
14:02:02 <dolio> Unless it can be written without that test.
14:02:20 <exFalso> Silvah: bipartite graph?
14:02:39 <russellw> Silvah, use the first half of the notebook for the forward map, the second half for the reverse map, do each one in alphabetical order, one page for each letter of the alphabet
14:02:54 <monochrom> russellw, have you seen this? http://math.andrej.com/2008/02/02/the-hydra-game/  this is a fun recursion exercise
14:03:08 <russellw> Which doesn't have optimal asymptomatic complexity, but if you need to worry about asymptomatic complexity, a notebook and pencil is the wrong tool for the job anyway
14:04:12 <russellw> monochrom, I have indeed. I thought it was quite fascinating that you have a function that grows so fast peano arithmetic can't prove it terminates even though ZFC can
14:04:21 <russellw> I even looked at the proof, and completely failed to understand it
14:04:39 <Keratin> does that have anything to do with goodstein sequences?
14:04:46 <Keratin> sounds kinda similar.
14:05:06 <russellw> It seemed to be saying you can count from infinity down to zero in finite time, which obviously would be nonsense. But I'm guessing it was actually invoking a well-founded relation of the kind you are talking about
14:05:08 <AfC> dom96: [actually, I keep getting disconnected after not very long. Haven't been able to diagnose anything in particular, but its definitely faster than the library I used in another language]
14:05:16 <russellw> So it makes sense that it's relevant in this context
14:05:23 * hackagebot explicit-iomodes 0.6.0.4 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.6.0.4 (BasVanDijk)
14:05:28 <monochrom> I am still wondering whether System F is good enough for programming it, i.e., input a tree, output the final tree (or how many steps til end-game, or whatever)
14:05:30 <AfC> (nothing specific hence no bug report)
14:05:58 <dolio> russellw: You don't count down from infinity, per se.
14:06:02 <russellw> Good question, to which I don't know the answer :)
14:06:12 <dolio> When you're at infinity, you get to choose an arbitrarily large natural, and then you count down from there.
14:06:32 <dom96> AfC: I see. Well currently I am not really programming much in haskell, so I haven't really maintained SimpleIRC very much. But if I ever get some times i'll try to test it properly, and fix as many bugs as possible. If you ever find the cause please do report a bug on github.
14:06:33 <russellw> dolio, okay, that sounds like it makes more sense
14:06:42 <dom96> *time
14:06:59 <AfC> dom96: will do
14:08:51 <AfC> dom96: [and lo! This is your big change to get programming with Haskell again :)]
14:08:58 <AfC> chance*
14:09:43 <dom96> AfC: Perhaps. Sadly I'm too busy with other projects.
14:10:40 <Silvah> Damn it, I got disconnected.
14:10:58 <exFalso> can one pattern match somehow with a Maybe return value for failing?
14:11:18 <monochrom> little do I notice that merijn's hostname has "inconsistent" in it :)
14:11:38 <Silvah> And now I don't know if someone said something to me.
14:12:06 <Silvah> I love how reliable computers are.
14:12:28 <monochrom> <russellw> Silvah, use the first half of the notebook for the forward map, the second half for the reverse map, do each one in alphabetical order, one page for each letter of the alphabet
14:12:35 <monochrom> <russellw> Which doesn't have optimal asymptomatic complexity, but if you need to worry about asymptomatic complexity, a notebook and pencil is the wrong tool for the job anyway
14:12:54 <parcs`> alistra: ghc -package-conf cabal-dev/packages-*.conf
14:12:55 <monochrom> I think those were the last things said for you. is that good enough?
14:13:19 <alistra> parcs`: i love you
14:13:24 <alistra> @karma+ parcs`
14:13:24 <lambdabot> parcs`'s karma raised to 1.
14:13:28 <parcs`> =)
14:13:37 <Silvah> monochrom: yeah, thanks.
14:13:40 <alistra> inb4 it doesn't work
14:14:24 <alistra> parcs`: ghc: panic! (the 'impossible' happened)
14:14:25 <alistra>   (GHC version 7.2.2 for i386-unknown-linux):
14:14:25 <alistra>         While parsing "cabal-dev/packages-7.0.4.conf/package.cache": Prelude.chr: bad argument: 1848275
14:14:27 <alistra> :|
14:14:29 <alistra> so close
14:14:42 <Silvah> russellw: right, I just don't trust any of my computers, they tend to crash, so I prefer to keep my dictionaries in the analog form.
14:14:44 <parcs`> strange, let me try
14:15:01 <alistra> parcs`: you have 7.2.2?
14:15:09 <parcs`> yes
14:15:12 <alistra> maybe my cache is fucked
14:15:23 * hackagebot explicit-iomodes-bytestring 0.2.0.1 - Extends explicit-iomodes with ByteString operations  http://hackage.haskell.org/package/explicit-iomodes-bytestring-0.2.0.1 (BasVanDijk)
14:15:30 <parcs`> OH
14:15:32 <parcs`> lol
14:15:42 <parcs`> ghc -package-conf cabal-dev/packages-7.2.2.conf
14:15:45 <alistra> ah
14:15:47 <alistra> yeah
14:15:54 <parcs`> * picks 0 before 2
14:15:58 <alistra> i've noticed that too
14:16:06 <alistra> you naughty glob user you
14:16:11 <parcs`> i wrote * because i didn't know your ghc version :P
14:16:21 <alistra> anyway keep your karma
14:16:23 <alistra> you've earned it
14:16:39 <parcs`> :D
14:16:44 <parcs`> does it work
14:16:49 <alistra> yes
14:16:51 <alistra> i mean
14:16:59 <alistra> now i have to only fix cabal
14:17:00 <alistra> :D
14:17:17 <alistra> doing that since yesterday, already second ghc reinstall
14:17:53 <monochrom> "one the 3rd day of christmas my true love sent to me, 3 GHC installs, 2 GHC installs, and a GHC install"
14:17:56 <parcs`> cabal --config-file=cabal-dev/cabal.config
14:18:18 <alistra> i mean like
14:18:20 <alistra> ghc problems
14:18:26 <parcs`> oh
14:18:35 <alistra> i accidentally rm -rf package*conf/*
14:18:41 <alistra> in the global package*conf
14:18:45 <alistra> :D
14:18:48 <monochrom> oh, that's sad
14:18:54 <alistra> well
14:18:56 <alistra> intentionally
14:19:07 <alistra> it had a lot of shit from earlier ghc
14:19:11 <alistra> and it was a shitstorm
14:19:23 <parcs`> hate when you do intentionally do something by accident
14:19:26 <irene-knapp> monochrom: lol
14:19:48 <alistra> the accident here was letting cabal deteriorate
14:20:10 <FliPPeh> Suppose I'm writing an interpreter for a language, what's the best way to store the line within the source file for each instruction?
14:20:15 <monochrom> "on the 4th day of christmas my true love sent to me, 4 cabal failures, 3 cabal failures, 2 cabal failures, and a cabal failure"
14:20:23 * hackagebot explicit-iomodes-text 0.1.0.7 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1.0.7 (BasVanDijk)
14:20:30 <FliPPeh> Getting the errorous line at parse-time is simple, but how about runtime?
14:20:49 <alistra> FliPPeh: dunno if best, but here's the language-c way http://hackage.haskell.org/packages/archive/language-c/0.4.2/doc/html/Language-C-Data-Node.html#t:NodeInfo
14:20:51 <irene-knapp> it needs to be inside your instruction type, I presume
14:20:51 <Silvah> Just store the line number?
14:20:56 <irene-knapp> I don't really see the difficulty
14:21:09 <alistra> they've made a parametrized type
14:21:13 <alistra> for each AST entry
14:21:22 <FliPPeh> irene-knapp: I have about 10 constructors for each possible AST type, could be clumsy
14:21:25 <alistra> that takes the type of the location data or whatever
14:21:31 <irene-knapp> oh, hm.
14:21:33 <FliPPeh> irene-knapp: Before I do that, I rather get in some more educated opinions
14:21:42 <alistra> and they have an additional argument everywhere
14:21:43 <irene-knapp> can you hpaste your types?
14:21:47 <Silvah> Have done that zillion of times, always have stored it in AST nodes.
14:22:25 <FliPPeh> LispVal = Number Integer LineNumber | String String LineNumber | List [LispVal] LineNumber
14:22:27 <irene-knapp> I actually faced a similar problem when I made my SQL parser/generator, I wanted it to have a whitespace-preserving mode but discovered that there was no easy way to store the same extra data with each AST node and be typesafe,
14:22:29 <FliPPeh> Looks wrong
14:22:41 <irene-knapp> I would use record constructors for this
14:22:43 <irene-knapp> note that you can do
14:22:58 <FliPPeh> (LispVal, LineNumber)
14:22:59 <FliPPeh> Maybe...
14:23:09 <irene-knapp> LispVal = Number { lineNumber :: Int, ? } | String { lineNumber :: Int, ? }
14:23:20 <irene-knapp> I thought at first you were using GADTs
14:23:24 <irene-knapp> but since you're not, that works
14:23:27 <FliPPeh> Questionmarks?
14:23:34 <alistra> FliPPeh: in happy there's a parsing mode that gives you your node plus a pair of column,line
14:23:34 <FliPPeh> Some extension?
14:23:35 <alistra> :P
14:23:36 <irene-knapp> oh, that's a dot-dot-dot
14:23:41 <irene-knapp> my Mac substitutes that ><
14:23:53 <FliPPeh> darn macs!
14:23:57 <kmc> @remember monochrom "on the 4th day of christmas my true love sent to me, 4 cabal failures, 3 cabal failures, 2 cabal failures, and a cabal failure"
14:23:57 <lambdabot> It is forever etched in my memory.
14:23:57 <irene-knapp> because lineNumber has the same type (LispVal -> Int) for all the records, you can reuse the same name
14:24:06 <FliPPeh> Okay, new question: '...'?
14:24:18 <irene-knapp> by that I meant "and your other fields go here"
14:24:30 <FliPPeh> Ah okay
14:24:39 <FliPPeh> Yeah, true, currying to the rescue
14:24:42 <irene-knapp> it sounds like you weren't aware that you can sorta combine algebraic types with record types?
14:24:43 <kmc> FliPPeh, you should factor out the line-number part, rather than making it a field in each constructor
14:24:56 <irene-knapp> that said, kmc seems to disagree with me :)
14:25:02 <FliPPeh> irene-knapp: Yes I am aware, I just was stupid :D
14:25:12 <kmc> the field name thing is a convenient hack but it's not convenient enough
14:25:13 <irene-knapp> but the problem, kmc, is making that well-typed given that this is only one of the AST types, not the entire AST!
14:25:22 <irene-knapp> FliPPeh: okay :)
14:25:29 <FliPPeh> kmc: I thought about something like (LispVal, Position), did you mean that?
14:25:33 <kmc> yes
14:25:39 <kmc> (but probably a new type, not (,))
14:25:42 <FliPPeh> Might require a lot of rewriting
14:25:50 <FliPPeh> I hate rewriting :(
14:25:51 <irene-knapp> the issue there as I understand it is that it's not just LispVal
14:26:04 <irene-knapp> if it is, I would go ahead and do the rewriting =p it's always worth it for cleaner code later
14:26:25 <irene-knapp> if it is, I would go ahead and do the rewriting =p it's always worth it for cleaner code later
14:26:26 <irene-knapp> er
14:26:26 <kmc> you can't have a field named 'lineNumber' in multiple types
14:26:27 <irene-knapp> sorry
14:26:31 <irene-knapp> wrong window to type up-arrow-return in
14:26:34 <kmc> not the way that you suggest
14:26:36 <irene-knapp> kmc: oh, true :(
14:26:44 <irene-knapp> kmc: well, you can always make a typeclass HasLineNumber, ? haha
14:26:48 <kmc> sigh
14:27:00 <FliPPeh> Dear god!
14:27:01 <kmc> i don't think that's the reasonable way
14:27:16 <kmc> data LN t = LN Int t
14:27:19 <irene-knapp> I'm not sure what your proposal is I guess, kmc?
14:27:23 <wavewave> my hxournal has double buffer rendering now. :-)
14:27:24 <irene-knapp> oh, yes, hmm
14:27:26 <irene-knapp> that makes sense
14:27:28 <irene-knapp> wavewave: nice
14:27:53 <wavewave> irene-knapp : thanks ;-)
14:27:57 <irene-knapp> :)
14:28:01 <kmc> data LispVal = Number Integer | String String | List [LN LispVal]
14:28:06 * cmccann starts putting every single function he writes in a type class just to see kmc's reaction
14:28:08 <kmc> type LispValNoReallyUseThisOne = LN LispVal
14:28:21 <kmc> cmccann, class C t where { f :: t }
14:28:37 <kmc> so convenient, no need to remember those pesky function names anymore
14:28:40 <irene-knapp> haha
14:28:41 <cmccann> kmc, sounds good to me
14:28:46 <kmc> just declare a new type every time you need a new function
14:28:51 <cmccann> right
14:29:15 <wavewave> I confirm myself that the best way to learn a programming language is to make a program that I want most.
14:29:31 <Axman6> f f f f (f f f) f (f . f $ f)
14:29:31 <irene-knapp> it is!
14:29:39 <irene-knapp> data False = True
14:29:56 <kmc> FliPPeh, if you want to get really fancy, you can specify the parts of your language (including line numbers) in "open", non-recursive style, and then tie it all together
14:29:58 <cmccann> Axman6, that ($) doesn't look polymorphic enough
14:30:11 <kmc> data LispVal self = Number Integer | String String | List [self]
14:30:23 <FliPPeh> I am confused.
14:30:24 <Axman6> f f f f (f f f) f (f . f `f` f)?
14:30:24 <kmc> data LN t = LN Int t
14:30:26 <FliPPeh> :(
14:30:32 <cmccann> Axman6, yes, much better
14:30:36 <Axman6> =)
14:30:52 <cmccann> Axman6, assuming that (.) is imported from Control.Category at least
14:31:05 <kmc> data Thing = Thing (LN (LispVal Thing))
14:31:10 <kmc> pick better names than i did, though ;P
14:32:01 <wavewave> by the way, if anyone is interested, I also made little tools like devadmin and metapackage
14:32:11 <kmc> not to be confused with meatpackage
14:32:28 <wavewave> kmc: ;-)
14:32:48 <Silvah> Meth package?
14:33:25 <wavewave> metapackage is a kind of scaffolding tool of making an umbrella package of several packages
14:33:54 <Silvah> Yeah.
14:33:58 <wavewave> symbolic linking source files of those original packages.
14:34:06 <Silvah> Meth package is a package with meth in it.
14:34:21 <wavewave> so that compilation time can be much shorter..
14:36:09 <wavewave> I found that cabal dependency checking time was too long and it lags speed of development if I have multiple packages in development
14:38:39 <wavewave> does anyone use yi editor in daily basis?
14:39:22 <FliPPeh> Nope, but one with a very similar name :)
14:39:49 <wavewave> :-) vee?
14:40:01 <FliPPeh> more similar!
14:40:12 <mike-burns> yow?
14:40:45 <Silvah> yj?
14:40:51 <FliPPeh> D:
14:40:56 <wavewave> I just wonder whether yi has some performance issue or not.
14:41:32 <Silvah> It has.
14:41:36 <Silvah> Everything has.
14:42:00 <Axman6> λ!?
14:42:22 <wavewave> Silvah : how is it? is it serious?
14:42:51 <kmc> performance really should not be a concern in a text editor
14:42:52 <Silvah> Don't know, never used it.
14:43:16 <Silvah> It's quite likely that you're the bottleneck.
14:43:16 <mike-burns> Why shouldn't performance be a concern in a text editor?
14:43:31 <FliPPeh> Hint: visual studio, eclipse
14:43:36 <kmc> because it should be extremely easy to provide adequate performance
14:43:59 <mike-burns> It's easy to do a lot of things, but you can only write one line of code at a time.
14:44:17 <kmc> i was not clear what i meant by "not be a concern"
14:44:46 <kmc> what i mean is that if I hear of a new text editor, I don't think "is it fast enough??", and I would be shocked if the answer is 'no'
14:45:32 <mike-burns> OK, sure.
14:45:35 <Clint> once i felt the same way about window managers
14:45:41 <parcs`> vim is 20 years old and is pretty slow at syntax highlighting
14:45:47 <mike-burns> Though I wouldn't be shocked; programming is hard!
14:45:58 <kmc> i've never had trouble with highlighting speed in vim
14:46:08 <kmc> maybe the files i edit are not as large as the files you edit
14:46:14 <wavewave> kmc: yeah, usually that's true. I specifically ask about this because I read some complaints about some algorithm used in yi.
14:46:18 <kmc> ok
14:46:18 <parcs`> well redrawing is slow
14:46:29 <mike-burns> vim chokes when highlighting a very wide long.
14:46:36 <mike-burns> line
14:46:51 <FliPPeh> That's why you don't write very long lines :S
14:47:04 <FliPPeh> Your eyes should choke way before VIM does
14:47:13 <mike-burns> In code, yes!
14:47:40 <Silvah> You DO write very long lines, because you want to see vim choking.
14:47:49 <wavewave> I am now considering to switch to yi so that I can extend by myself. hehe :-)
14:48:00 <kmc> let me know if you manage to compile it
14:48:24 <mike-burns> True fact: I just ported some Haskell to vimscript, and it was extremely painless. There were even two vimscript functions I wanted in Haskell!
14:48:35 <kmc> which functions?
14:48:40 <mike-burns> count and get
14:48:45 <kmc> what do they do
14:49:07 <mike-burns> `count' produces the length of a list, with an optional argument to count only elements matching an expression.
14:49:26 <mike-burns> And `get' is like (!!) but with a default value instead of raising an error.
14:49:48 <kmc> cool
14:50:13 <cmccann> a combined length and filter is plausible
14:50:24 <mike-burns> Oh sure, it can be implemented.
14:50:29 <kmc> sure, these things are not hard to do in haskell
14:50:34 <cmccann> I mean, that's something I could see being common enough to be in a standard library
14:50:36 <kmc> but i have wished for each of those as a standard function
14:50:49 <kmc> @hoogle (a -> Bool) -> [a] -> Int
14:50:50 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
14:50:50 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
14:50:50 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:51:25 <wavewave> in the long run, I would like to experiment interplay between text editor and handwriting notetaking program.
14:52:06 <Silvah> @pl \f xs = length (filter f xs)
14:52:06 <lambdabot> (line 1, column 7):
14:52:06 <lambdabot> unexpected "="
14:52:06 <lambdabot> expecting pattern or "->"
14:52:39 <Silvah> @pl \f xs -> length (filter f xs)
14:52:39 <lambdabot> (length .) . filter
14:52:43 <mike-burns> length . filter f -- is how I'd find it most readable.
14:53:07 <cmccann> a standard version of ((.).(.)) would also be readable
14:53:13 <cmccann> operator sections of (.) are ugly
14:53:31 <mike-burns> But it's actually   \e -> length . filter (e ==)
14:53:58 <Silvah> It's more generic when taking a function.
14:54:03 <cmccann> mike-burns, I think a general predicate would be more useful
14:54:20 <mike-burns> Perhaps, but so far I've only needed it once!
14:58:42 <kmc> yeah, general predicate is better, because it's easy enough to write (== e) at the call site
14:58:49 <kmc> in fact, doing so makes the call clearer
14:59:24 <hpaste> strager pasted “cabal install hlint” at http://hpaste.org/55695
14:59:39 <strager> ^ I'm getting errors when installing hlint
15:00:02 <kmc> cabal install happy
15:00:19 <kmc> iirc cabal doesn't fetch build-program dependencies
15:00:47 <wavewave> success in installing yi!
15:00:56 <kmc> cool!
15:01:02 <Sgeo> Are there languages with language-based ... things like Hackage that are not annoying?
15:01:05 <donri> strager: also maybe install haskell-platform if your system has a package for it
15:01:11 <Sgeo> e.g. is Racket's package stuff not annoying?
15:01:20 <kmc> which things annoy you?
15:01:23 <strager> My eyes travelled over that happy line, kmc =X
15:01:25 <wavewave> cabal install yi is working on haskell-platform 2011.4
15:01:33 <Sgeo> "iirc cabal doesn't fetch build-program dependencies" for example
15:01:40 <kmc> oh
15:01:47 <kmc> i think that's a property of cabal not hackage
15:02:41 <cmccann> it's also a property of not arbitrarily doing things you might not want
15:02:42 <mike-burns> Sgeo: No, there is no language for which it is not annoying.
15:02:54 <kmc> sometimes i wish it were all .dpkgs
15:02:57 <cmccann> not sure I'd really want cabal installing arbitrary executables for me just to build a library
15:03:08 <kmc> shrug
15:03:20 <kmc> it already runs arbitrary code in the process of building haskell code
15:03:30 <cmccann> and while it could do that for Haskell programs that won't help with other stuff
15:03:46 <mike-burns> Racket's package stuff never gave me issues, but there were also like four packages when I last used it.
15:03:48 <cmccann> kmc, it's more about installing stuff outside the control of the system package manager
15:03:48 <strager> I like Node.js's way of doing things; just install the library local to the package (not system-wide).
15:04:00 <kmc> strager, you can do that with cabal too;  see cabal-dev
15:04:11 <mike-burns> That's definitely the way to go. I feel.
15:04:14 <kmc> cmccann, but it's installing libraries outside the system package manager
15:04:46 <kmc> cabal will also install executables it builds by default, just not dependencies
15:04:49 <kmc> so it is kinda arbitrary
15:04:53 <kniu> so how related are static code analysis tools and type systems?
15:05:04 <kmc> i agree that some users somewhere will want this arbitrary default
15:05:05 <cmccann> kmc, yeah, I'm not particularly attached to the way it works
15:05:35 <mike-burns> kniu: Lots of the same people are interested in both?
15:05:48 <kniu> mike-burns, well, the question is more like
15:05:59 <kniu> does a static analysis tool for, say, C
15:06:07 <cmccann> I'd rather minimize the amount of stuff being installed outside the package manager in general to be honest
15:06:14 <kmc> yeah
15:06:22 <cmccann> but since I'd rather not be using GHC 5 or whatever Ubuntu has...
15:06:35 <kniu> do the same kind of thing that a more expressive type system would do?
15:06:36 <mike-burns> I avoid using my OS package manager for my programming libs.
15:06:36 <kmc> cmccann, but you could make cabal build .dpkgs locally, and then install those
15:06:52 <kmc> i mean there is http://hackage.haskell.org/package/cabal-debian
15:06:55 <kmc> but i've not tried it
15:07:00 <cmccann> huh, I didn't know that existed
15:07:08 <cmccann> that sounds nice
15:07:18 <kmc> iirc arch automatically builds all libraries uploaded to hackage
15:07:25 <kmc> and has a good tool  for making them into arch packages
15:07:32 <cmccann> though at this point not sure if it matters... I've got so much Haskell stuff installed directly via cabal
15:07:51 <mike-burns> kniu: I've never written one of these, but I suspect that a more powerful type system lends itself to more static analysis.
15:08:03 <cmccann> isn't the arch stuff mostly because one of the overly-productive Haskell programmers used arch and magic'd it all up?
15:08:18 <kmc> haha, overly-productive Haskell programmers ;)
15:08:40 <Silvah> You guys are normally lazy.
15:08:47 <kmc> never heard that one before...
15:09:17 <Silvah> Just like your language.
15:09:22 <mike-burns> Oh I get it.
15:09:32 <wavewave> how is NixOS stuff? is it also automated ?
15:09:43 <cmccann> kmc, did you see the hackage high score table I did months ago? :P
15:09:52 <kmc> no
15:10:26 <cmccann> I pulled usernames from the hackage upload log, then counted lines per user
15:10:31 <cmccann> and made a "high score table"
15:10:38 <kmc> haha
15:10:49 <wavewave> cmccann: oh... where is it?
15:11:00 <donri> fedora has cabal2spec too
15:11:00 <cmccann> it'd be way out of date now anyway
15:11:01 <kmc> that's... not a good thing to praise / incentivise
15:11:08 <kmc> but you know that
15:11:30 <wavewave> cmccann: yeah.. probably it didn't have my name. he
15:11:36 <cmccann> kmc, what, upload count? yeah, it was a joke
15:11:43 <kmc> yeah
15:11:59 <donri> and arch only does that via aur which doesn't count
15:12:02 <cmccann> though obviously that will reflect productivity to some extent, but only because nobody is trying to game it
15:12:17 <kmc> cmccann, i think it reflects carefulness, inversely
15:12:32 <cmccann> kmc, it reflects that too
15:12:55 <cmccann> as well as opinions about granularity and the kind of code being worked on
15:13:09 <cmccann> anyway, it's probably not too hard to guess most of the top 5 people on the list
15:14:27 <cmccann> ah, found it: http://hpaste.org/50215
15:14:27 <cmccann> heh
15:15:38 <kmc> yeah edwardk is definitely towards the "upload whenever you save a file" side ;P
15:15:48 <kmc> i guess there's nothing actually wrong with that
15:16:00 <kmc> but i prefer to upload only when I've compiled and tested all the new features
15:16:38 <cmccann> he also has a lot of experimental stuff and random tinkering on hackage
15:16:52 <wavewave> is there any way to check all hackages somebody uploaded?
15:16:59 <kmc> http://hackage.haskell.org/packages/archive/log
15:17:06 <mike-burns> By the time someone figures out how to use an edwardk package, he's compiled and tested all the features.
15:18:13 <wavewave> oh.. this is a history of everything. interesting.
15:18:27 <hpaste> kmc pasted “hackage users by number of distinct package-names uploaded” at http://hpaste.org/55697
15:19:05 <cmccann> heh, interesting
15:19:12 <kmc> yeah, still pretty bogus
15:19:25 <cmccann> obviously
15:20:20 <wavewave> we really need some web 2.0 feature of hackage .
15:20:25 <kmc> because uploads ≠ authorship ≠ contributor
15:20:26 <cmccann> for instance, I think gwern has uploaded a lot of stuff that other people wrote, hence being much higher on that list than on mine
15:20:32 <kmc> and that, yeah
15:20:51 <kmc> and because some people put a lot of effort into a few very important libraries
15:20:51 <donri> edward's data-lens is split into three packages and depends on five of his other packages, where others tend to put everything into one kitchen-sink blob package
15:21:07 <donri> i prefer edward's way of doing things
15:21:24 <kmc> yeah.  i wonder how many packages you could split MissingH into :)
15:22:00 <kmc> wavewave, yeah... Hackage 2.0 has been in the works for a long time
15:22:09 <kmc> the code exists, I think it's even public somewhere
15:22:35 <donri> it is, i built it recently to have a look
15:24:23 <cmccann> likewise, michael snoyman's position on both lists probably has a lot to do with the level of granularity in yesod packages
15:25:04 <aristid> cmccann: michael snoyman writes a LOT of code :)
15:25:11 <wavewave> I prefer to have smaller packages in principle, but it significantly slows down compilation spped in practice.
15:25:45 <donri> snoyman doesn't write a lot of code because he generates most of it with template-haskell *snickers*
15:26:06 <cmccann> aristid, amount of code isn't what these ridiculous measurements are looking at, though
15:26:55 <aristid> cmccann: i think he's productive no matter how you measure it
15:27:00 <wavewave> by the way, how many packages in hackage in total?
15:27:13 <cmccann> aristid, certainly, I'm not claiming otherwise
15:27:18 <Silvah> 8
15:27:42 <kmc> wavewave, http://haskell.org/haskellwiki/Hackage_statistics
15:27:48 <mike-burns> I think a plot of number of packages on hackage against number of hours wasted on IRC would help settle this.
15:27:55 <Silvah> So I guessed wrong?
15:29:19 <wavewave> kmc: thanks. btw is it up-to-date?
15:29:30 <kmc> this one is: http://hackage.haskell.org/cgi-bin/hackage-scripts/stats
15:29:35 <kmc> 883 users have uploaded 18406 versions of 3658 packages
15:29:50 <wavewave> Ah yes...
15:30:06 <Silvah> So I was close.
15:31:00 <kmc> what's two orders of magnitude between friends
15:32:00 <wavewave> it's accelerating.. good.
15:32:20 <kmc> mike-burns, yeah, the top people on either cmccann's list or my list aren't seen that much on irc
15:33:19 <kmc> wavewave, I'm not sure it's good.  we're accumulating all these packages but we have no way to categorize them, assess their quality, provide for standards and interoperability, etc.
15:33:44 <mike-burns> Interop would be amazing.
15:33:47 <donri> was it ruby matz who said he avoids irc because it kills productivity?
15:33:56 <wavewave> kmc: yeah. that's social web feature.
15:34:31 <kmc> right now you get fucked constantly because your two libraries disagree about the choice of iteratee or string type or monad transformers or lens library or ...
15:34:37 <Silvah> What's the derivative of f(x) = x * ln x?
15:35:24 * hackagebot Focus 0.1.2 - Tools for focusing in on locations within numbers  http://hackage.haskell.org/package/Focus-0.1.2 (NateSoares)
15:35:33 <aristid> kmc: and right now snoyman is working on an alternative to iteratees that he will port his entire stack to :)
15:35:55 <parcs`> Silvah: ln x + 1
15:35:56 <kmc> x * δ/δx (ln x)  +  1 * ln x   ≡   x * (1/x)  + ln x  ≡  1 + ln x
15:36:05 <donri> conduit?
15:36:10 <kmc> aristid, haha
15:36:10 <aristid> donri: yes
15:36:21 <wavewave> We need some automatic checking program for package upload.
15:36:23 <kmc> the great thing about standards is that there's so many to choose from
15:36:38 <kmc> unfortunately social web 2.0 hackage won't solve that problem :/
15:36:39 <aristid> kmc: well iteratees really are not the nicest thing there could be
15:36:40 <kmc> it might help
15:36:57 <kmc> aristid, right because the nicest thing there could be is a unicorn that i can keep as a pet and also ride
15:37:13 <kmc> which eats garbage and farts gold bricks
15:37:30 <mike-burns> That's it, I'm making another iteratee package and naming it "unicorn".
15:37:34 <wavewave> I am not sure that we can make a standard for individual hackage package
15:37:39 <aristid> kmc: may a thousand flowers bloom, and all but one of them eaten by an elk
15:37:45 <kmc> :D
15:37:46 <kmc> that's deep
15:38:00 <kmc> the flip side to "Hackage contributors don't hang on IRC" is that the people on IRC are providing value to the community in other ways
15:38:06 <wavewave> I think it can be solved by another layer like haskell-platform
15:38:20 <wavewave> haskell-platform tier 0 , tier 1 tier 2
15:38:42 <mike-burns> I like what was attempted by data-object, with data-object-json and data-object-yaml using a common data structure. But, on the other hand, data-object-json isn't as good as Aeson.
15:38:51 <cmccann> kmc, I wish we had some better code analysis tools, there's probably lots that could be automatically done to get hackage under better control
15:38:58 <kmc> like what?
15:39:39 <cmccann> something that can parse and actually understand haskell code that isn't GHC
15:39:50 <kmc> and do what with it?
15:39:59 <kmc> haskell-src-exts does a fine job parsing
15:40:08 <kmc> but what do you want to understand
15:40:13 <cmccann> types, for one thing
15:42:44 <cmccann> as well as the ability to do simple program transformations or compare the structure of code in a meaningful way
15:42:47 <kmc> what about them
15:45:21 <cmccann> kmc, in theory you could do things like analyze code for redundancy between packages or automatically determine some dependency issues
15:46:03 <cmccann> maybe have a better way of handling optional dependencies like instances
15:47:40 <mike-burns> Do other programming language cultures complain about interop this much? I know Ruby doesn't.
15:47:48 <mike-burns> What can we learn from other languages?
15:49:00 * cmccann installs three ruby libraries that all monkey patch built-in classes in different ways
15:49:02 <kniu> I'm going to be in a place without internet for a few weeks
15:49:07 <kniu> but I want to continue coding
15:49:16 <cmccann> kniu, bring a computer
15:49:22 <wavewave> mike-burns: I think this is quite haskelly phenomenon because hackage package tends to be small compared with other language.
15:49:24 <kniu> how do I take the documentation for cabal packages with me?
15:49:33 <donri> cmccann: that's fine, it's not like it all registeres process-globally
15:49:35 <dschoepe> kniu: Set documentation: True in your .cabal/config
15:49:43 <dschoepe> and rebuild needed packages
15:49:55 <kniu> dschoepe, okay thanks
15:49:58 <donri> kniu: what OS?
15:50:11 <mike-burns> wavewave: When I worked on PLT I don't remember this being an issue, and I never heard this complaint in Scala.
15:50:15 <wavewave> network graph of hackage package is probably very rich.
15:50:29 <donri> for example fedora reindexes all your cabal packages (from yum) at file:///usr/share/doc/ghc/html/libraries/index.html
15:51:02 <wavewave> haskell package  is using parameterized type very much
15:51:53 <mike-burns> Maybe if there were more of a culture of posting packages that only define data types without functions? Would that be useful?
15:51:54 <kniu> donri, Debian squeeze
15:51:58 <wavewave> so a package user finds unexpected use of a package and start use it..
15:52:12 <cmccann> anyway, the interop issues in Haskell are mostly exaggerated outside of a few particularly painful issues
15:52:34 <Clint> kniu: install the -doc packages you want
15:52:35 <cmccann> most of which arise from trying to replace lazy IO, the default string type being [Char], or instances being global
15:52:36 <wavewave> cmccann: I agree with it...
15:52:51 <kniu> Clint, you mean for debian?
15:52:58 <Clint> yes
15:53:02 <kniu> okay
15:53:03 <kniu> also
15:53:07 <donri> kniu: http://pkg-haskell.alioth.debian.org/haskell-policy/ch-libs-bin.html#s-libs-bin-files
15:53:21 <kniu> does the haskell platform include documentation for, like, monad transformers and stuff?
15:53:43 <cmccann> iteratees and related stuff are in flux because the idea is persuasive but there's no consensus on how to do it
15:53:55 <donri> kniu: do you mean haddock docs?
15:54:00 <kniu> donri, yes
15:54:14 <donri> i suppose it depends on the packaging, duno if debian splits it up like Clint suggested
15:54:32 <Clint> yes, there's -dev, -prof, and -doc
15:54:42 <Clint> (except in rare cases where one of those is missing)
15:54:45 <kmc> in Python and Ruby etc., you have a built-in string type and you expect the implementation to do magic things with it
15:55:03 <donri> Clint: is there a shared haddock index?
15:55:05 <kmc> likewise for lists/arrays (compare to list, Array, Sequence, Vector, Repa, etc.)
15:55:36 <kniu> you make "built-in" and "magic" sound like Good Things
15:55:55 <mike-burns> They have their up-sides.
15:56:03 <kmc> kniu, do i?
15:56:12 <kmc> i'm just describing why other languages don't have this problem
15:56:15 <cmccann> meanwhile in Java and the like everything is full of painful boilerplate so the kind of interop stuff that's annoying in Haskell just blends in
15:56:17 <kmc> it might be one of them good problems
15:56:36 <kmc> (though Python has a similar problem with numpy... I hear lots of complaints about the fact that some functions/operators will do a completely different thing on lists vs numpy arrays vs numpy matrices)
15:56:47 <donri> are we speaking interop here?
15:56:52 <wavewave> I think interop problem is actually not a problem, but a fun topic to talk. ;-)
15:56:56 <donri> python is majorly broken between version 2 and 3
15:57:00 <donri> because of strings
15:57:10 <companion_cube> and unicode?
15:57:33 <donri> myep
15:57:34 <mike-burns> Oh sure, major version bumps bring interop issues everywhere.
15:57:56 <kmc> we were talking about interoperation between libraries, not compatibility over language / implementation versions
15:58:03 <kmc> Haskell has problems there too, but it's a separate problem :)
15:58:07 <Clint> donri: file:///usr/share/doc/ghc-doc/html/libraries/index.html
15:58:23 <donri> kniu: ^^^
15:58:49 <donri> this of course is only for packages from debian
15:59:01 <kniu> okay
15:59:04 <kniu> thanks guys
15:59:07 <wavewave> this problem is more related to socialogy in some sense.
15:59:16 <donri> but as someone suggested you can build haddocks for your user-local packages too
16:15:22 <bmh> I'm trying to use UTF-8 characters in my program. I'm using setlocale and have set the locale to "en_US.UTF-8", but everything just comes out as '~'
16:15:48 <Axman6> isn't String in Haskell UTF-8 by default?
16:15:56 <kmc> no
16:15:59 <Axman6> i can never remember exactly which encoding it is
16:16:03 <kmc> it's none
16:16:19 <Axman6> what encoding does Char use?
16:16:23 <kmc> is Int big or little endian?
16:16:41 <bmh> for what it's worth I'm also using hscurses
16:16:45 <kmc> Char is a Unicode codepoint; you're not supposed to know or care what the encoding is
16:17:01 <kmc> (but GHC uses UTF-32, iirc)
16:19:17 <Sgeo> @hoogle String -> ByteString
16:19:17 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:19:18 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
16:19:18 <lambdabot> Data.String fromString :: IsString a => String -> a
16:19:23 <Sgeo> :/
16:19:33 <Sgeo> I guess Hoogle won't find functions that need an extra argument?
16:20:23 <kmc> Sgeo, there are many functions of that type.  which character encoding do you want?
16:20:23 <Sgeo> @hoogle UTF9
16:20:23 <lambdabot> No results found
16:20:26 <Sgeo> @hoogle UTF8
16:20:26 <lambdabot> System.IO utf8 :: TextEncoding
16:20:26 <lambdabot> GHC.IO.Encoding utf8 :: TextEncoding
16:20:26 <lambdabot> System.IO utf8_bom :: TextEncoding
16:20:41 <Sgeo> kmc, one that takes a String and converts it to bytes in a certain encoding
16:20:46 <kmc> which encoding
16:20:54 <Sgeo> kmc, presumably that would be given as an argument
16:21:10 <kmc> http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html
16:21:12 <Sgeo> @hoogle TextEncoding -> String -> ByteString
16:21:13 <lambdabot> Data.Text.Encoding.Error ignore :: OnError a b
16:21:13 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
16:21:13 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
16:21:27 <kmc> http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/Data-Text-Encoding.html
16:21:34 <kmc> http://hackage.haskell.org/packages/archive/text-icu/0.6.3.4/doc/html/Data-Text-ICU-Convert.html
16:21:48 <Sgeo> Hmm, thanks
16:21:53 <Clint> there's iconv too
16:21:59 <Sgeo> Not that I'll remember that for when I eventually need it in never months
16:22:08 <bmh> ah -ha: "The mvwaddch function is not exported by HSCurses"
16:22:08 <kmc> write it down
16:22:38 <kmc> fun fact: GHC's Char also allows certain scalar values which aren't valid Unicode codepoints
16:22:51 <kmc> > '\xD800'
16:22:52 <lambdabot>   '\55296'
16:24:18 <kmc> but it won't let you go above '\x10FFFF'
16:24:47 <Sgeo> > '\x110000'
16:24:48 <lambdabot>   <no location info>:
16:24:48 <lambdabot>      lexical error in string/character literal at chara...
16:25:03 <kmc> > succ '\x10FFFF'
16:25:04 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
16:25:21 <Sgeo> > text ['\xD800']
16:25:21 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
16:30:16 <rodayo> Is there a library similar to mechanize available in haskell?
16:30:40 <djahandarie> Hmm, so, I'm opening a handle in one thread, and using it in another, but I can't seem to write to it with hPutStr. (Monitoring the traffic on the port and I definitely don't send anything)
16:30:48 <djahandarie> isWritable is returning True
16:30:55 <djahandarie> The handle is recieved from connectTo
16:31:15 <djahandarie> Not a clue why it's silenting dropping the data I'm putting to the handle
16:31:46 <kmc> buffering?
16:32:39 <djahandarie> Of course I se-- apparently that line is no longer there for some reason.
16:32:41 <djahandarie> -_-
16:33:08 <djahandarie> Surprised that didn't break my input also
16:33:39 <djahandarie> Yeah, that was it. *sigh*
16:34:21 <Eduard_Munteanu> rodayo: what is that supposed to do?
16:34:21 <parcs`> consider using the socket api
16:35:18 <rodayo> Eduard_Munteanu, it's like an http client. it lets you interact with websites and stuff.
16:35:45 <rodayo> it's available in ruby, python and perl so i thought someone may have ported it to haskell
16:36:25 <kmc> http://hackage.haskell.org/trac/summer-of-code/ticket/1107
16:36:26 <kmc> http://stackoverflow.com/questions/3706833/is-haskells-network-browser-module-like-perls-lwp-or-pythons-mechanize
16:38:26 <nexion> is there a decodeUtf8 variant that returns an error code on failure instead of throwing an exception? perhaps a Maybe version
16:39:00 <kmc> Data.Text.Encoding.decodeUtf8' :: ByteString -> Either UnicodeException Text
16:39:11 <kmc> Data.Text.Encoding.decodeUtf8With :: OnDecodeError -> ByteString -> Text
16:40:44 <bmh> I wonder why hscurses doesn't provide mvwchar
16:40:49 <nexion> hm.. where do you see that?
16:41:01 <nexion> I'm at http://hackage.haskell.org/packages/archive/text/0.11.0.1/doc/html/Data-Text-Lazy-Encoding.html
16:41:08 <nexion> also checked the non-lazy version
16:41:21 <bmh> er mvWAddCh
16:41:31 <kmc> http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/Data-Text-Encoding.html
16:42:19 <nexion> ah, a new version :)
16:42:20 <nexion> ty
16:42:29 <kmc> yours still has decodeUtf8With though
16:43:36 <nexion> yeah, but it takes 'OnDecodeError' and I don't see a way to have that function make decodeUtf8With return an error
16:44:13 <nexion> http://hackage.haskell.org/packages/archive/text/0.11.1.9/doc/html/src/Data-Text-Encoding-Error.html#strictDecode
16:44:25 <nexion> the only option there that fails hard is strictDecode
16:44:32 <nexion> but that means I have to catch it in IO
16:44:45 <nexion> the Either version you linked me to is ideal :)
16:51:24 <kmc> nexion, yeah.  i think the best you can do with the old function is substitute 'REPLACEMENT CHARACTER' (U+FFFD)  and scan for that afterward
16:51:37 <kmc> which is probably why the new function was added :)
17:02:34 <rodayo> kmc, thanks. that gives me a lot to go on
17:11:09 <Andrew___C> Happy Christmas, Haskell people!
17:11:45 <Andrew___C> my project just compiled OK and tested OK, so I'm in a good mood and going to bed soon
17:12:30 <russellw> Sounds good ^.^ Happy Christmas!
17:12:49 <hpaste> rostayob pasted “possible?” at http://hpaste.org/55700
17:13:00 <rostayob> ^^^ is it possible to do something like that? GHC doesn't seem to like it
17:13:15 <Andrew___C> (I don't actually think of it as Christmas until I've been to bed, but it's after midnight here in the UK)
17:13:34 <russellw> Same here in Ireland :-)
17:13:37 <rostayob> Andrew___C: it's almost 3 a.m. here in italy and I ate too much.
17:13:45 <rostayob> and tomorrow, again.
17:14:27 <monochrom> belly christmas :)
17:14:33 <rostayob> but i want to figure out if that type class is possible before going to bed :P
17:14:39 <Andrew___C> rostayob: me too. It was my son's birthday today: we overate sausages, yorkshire pudding and mash, then overate cake!
17:14:57 <rostayob> Andrew___C: eheh I like sausages and yorkshire pudding
17:15:07 <rostayob> don't know what overate cake is
17:15:11 <monochrom> ♥ yorkshire pudding and mash potato :)
17:15:14 <Andrew___C> rostayob: sorry - over my head I think.
17:15:25 <rostayob> yorkshire pudding is the bread mushroom right?
17:15:29 <Andrew___C> rostayob: overate = over ++ ate
17:15:34 <rostayob> ah. lol
17:15:58 <cmccann> rostayob, what does GHC complain about?
17:16:08 <rostayob> cmccann: TI/TypeInfer.hs:17:22: Not in scope: type variable `a'
17:16:25 <cmccann> oh, right
17:16:49 <rostayob> but I'm pretty sure you can have constrains with vars out of scope
17:16:53 <rostayob> *constraints
17:17:05 <cmccann> I don't think that works in class constraints
17:17:08 <Andrew___C> rostayob: no, yorkshire pudding is pancake batter cooked in a small dish of very hot oil so it rises at the sides - http://www.bbcgoodfood.com/recipes/9020/best-yorkshire-puddings
17:17:24 <cmccann> are there an fundeps on SubstApply's parameters?
17:17:27 <rostayob> Andrew___C: yeah. it look slike a mushroom made of bread.
17:17:29 <rostayob> cmccann: yes
17:17:40 <rostayob> class SubstApply ty a | a -> ty where
17:17:42 <rostayob>     apply :: Subst ty -> a -> a
17:17:56 <Andrew___C> rostayob: it's not a pudding, it goes with meat and gravy usually, typically beef.
17:18:17 <rostayob> Andrew___C: yeah yeah I've had it before, I've been living in london for a while :)
17:18:37 <Andrew___C> kmc: many, many thanks again for helping the other day :)
17:18:45 <kmc> yw :)
17:18:57 <cmccann> rostayob, also, why do you need the context on the class when you have it on applySubst anyway?
17:19:14 <Andrew___C> tata all, Happy Christmas!
17:19:29 <rostayob> cmccann: oh. right.
17:20:00 <rostayob> cmccann: having the constraint on the typesig it's enough i guess :P
17:20:01 <rostayob> thanks
17:20:50 <cmccann> rostayob, probably you want to either remove that from the class context, or add "a" to the MonadUnify class as well
17:21:25 <rostayob> cmccann: no, I want to be able to use applySubst with different 'a's
17:21:48 <rostayob> it'd be nice to guarantee that there exists a SubstApply ty a
17:21:51 <rostayob> but it's not a big deal
17:21:58 <cmccann> having the constraint on applySubst would let MonadUnify instances be written without a guarantee that applySubst would be usable
17:22:10 <rostayob> cmccann: yep, exactly
17:22:25 <rostayob> that's why I wrote the class declaration that way...
17:22:41 <rostayob> but if I can't have it that way it's fine to have the constraint on applySubst
17:22:44 <cmccann> but you don't necessarily want that, because instances can be added later
17:22:57 <cmccann> yeah
17:23:12 <cmccann> as long as you can still do what you need with just the constraint on applySubst that's probably fine
17:23:46 <rostayob> yeah
17:25:42 <Sgeo> How do I set language pragmas in GHCi?
17:26:12 <cmccann> :set -XEnableFoobar
17:26:13 <rostayob> Sgeo: :set -XWhatever
17:26:22 <Sgeo> ty
17:26:29 <cmccann> you can also enable them from the command line when you run ghci
17:26:43 * Sgeo is such a derp that he tried :set -XLanguageHaskell
17:28:53 <Sgeo> Can't do reify in the IO monad?
17:29:06 <Sgeo> Prelude Language.Haskell.TH> runQ (reify ''Bool)
17:29:19 <Sgeo> Template Haskell error: Can't do `reify' in the IO monad
17:29:19 <Sgeo> *** Exception: user error (Template Haskell failure)
17:44:19 <kmc> Sgeo, right
17:44:46 <kmc> IO monad lacks the context of knowing about definitions
17:45:26 <kmc> there's no -XLanguageHaskell but there is -XHaskell98 and -XHaskell2010 :)
17:49:52 <Sgeo> > 0 == (-0)
17:49:53 <lambdabot>   True
17:49:59 <Sgeo> > 1/0 == 1/(-0)
17:50:00 <lambdabot>   False
17:50:31 <Sgeo> :t subtract
17:50:32 <lambdabot> forall a. (Num a) => a -> a -> a
17:50:37 <Sgeo> > subtract 1 5
17:50:38 <lambdabot>   4
17:51:05 <Sgeo> It's in that order so that (subtract 1) works just like (- 1) should, right?
17:52:36 <kmc> i think so
17:52:45 <luite> yeah
17:52:53 <luite> > 1 `subtract` 3
17:52:54 <lambdabot>   2
17:53:51 <kmc> > 0.0 == -0.0
17:53:51 <lambdabot>   True
17:53:55 <kmc> > show 0.0 == show -0.0
17:53:56 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:53:56 <lambdabot>         against inferred typ...
17:54:07 <kmc> > show 0.0 == show (-0.0)
17:54:08 <lambdabot>   False
18:05:22 <exFalso> how does one enable monad comprehensions?
18:06:53 <exFalso> > isNothing [a | a <- Just 1]
18:06:54 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
18:06:54 <lambdabot>         against inferred ...
18:07:34 <dolio> -XMonadComprehensions
18:08:26 <exFalso> hmm doesnt work, which version of ghc?
18:08:43 <exFalso> i have 7.0.3
18:10:24 * hackagebot gd 3000.7.1 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.7.1 (ChrisDone)
18:10:42 <monochrom> 7.2.x IIRC
18:11:03 <exFalso> monochrom: thanks!
18:11:17 <nand`> I'm beginning to read up on category theory - I believe I understand what categories are (a collection of objects with morphisms between them) and what functors are (a mapping of one category to another while preserves the structure) - but how does this related to the haskell Functor typeclass?
18:11:24 <nand`> relate*
18:11:43 <nand`> Are members of the Functor typeclass objects? Or are they categories? Or functors?
18:12:30 <cmccann> an instance of the Functor type class is a type constructor that loosely corresponds to the part of the functor that maps the objects
18:12:51 <cmccann> whereas fmap corresponds to the part of the functor that maps morphisms
18:12:52 <djahandarie> Any Haskell type with a Functor instance is a functor from Hask to Hask, where Hask is the category of Haskell types with functions as morphims.
18:12:53 <cmccann> :t fmap
18:12:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:13:13 <cmccann> with extra parentheses read that as (a -> b) -> (f a -> f b)
18:13:17 <exFalso> dont forget that Haskell's Functor is an endofunctor!
18:13:33 <cmccann> (a -> b) is the source morphism, and (f a -> f b) is the target
18:13:43 <nand`> exFalso: I was about to say
18:13:50 <nand`> cmccann: I see
18:13:58 <cmccann> note that because of how type classes work, the only functors you can define this way are endofunctors from all of "Hask" to a subcategory of itself
18:15:11 <nand`> If functions are morphisms in the category of haskell types, can I infer from that that a category can have multiple distinct morphisms between the same two types?
18:15:28 <nand`> objects*
18:15:47 <cmccann> isn't that the default assumption in category theory?
18:15:56 <nand`> I wasn't sure
18:16:33 <nand`> Just started about 10 minutes ago, really - is there any good resource other than wikipedia I should be looking at?
18:16:57 <cmccann> there exist such resources, yes
18:17:03 <cmccann> but I don't have any links handy
18:18:46 <lpsmith> Ok,  the executable size that GHC-7.0 produces is rediculous
18:18:50 <lpsmith> gitit is 56MB
18:18:57 <lpsmith> linking it freezes up my computer
18:20:39 <exFalso> http://www.cwru.edu/artsci/math/wells/pub/ctcs.html
18:20:40 <exFalso> is a good one
18:21:05 <nand`> exFalso: Thanks
18:24:05 <ddarius> @google Barr Wells ESSLLI
18:24:07 <lambdabot> http://folli.loria.fr/cds/1999/library/pdf/barrwells.pdf
18:25:34 <nand`> cmccann: so, “fmap m” in category theory would be F(m) where m : a -> b and F(m) : F(a) -> F(b)?
18:25:52 <nand`> F being our particular functor
18:25:53 <kmc> nand`, the "objects" of CT are Haskell types.  the morphisms are functions
18:26:04 <kmc> this confused me for a while 'cause you might think the "objects" are values
18:26:08 <kmc> but it's just unfortunate naming
18:26:46 <kmc> and yeah, a category can have multiple morphisms between the same two types
18:27:06 <nand`> kmc: Yeah, that's where I was going wrong. I was thinking a type constructor is a category with functors mapping from one type constructor to another, but that didn't really make sense either (what would morphisms be?)
18:27:47 <kmc> for example in the category Set, the objects are sets, and the morphisms are functions from one set to another
18:28:19 <nand`> kmc: what are polymorphic functions, then? Does a morphism always require two distinct types?
18:28:31 <kmc> and there are several different functions from the set {0,1} to the set {2,3}
18:28:39 <kmc> but they all have the same "type signature"
18:28:39 <nand`> for example “id”, wouldn't it simultaneously be the identity of every object?
18:28:44 <kmc> yeah
18:28:46 <Eduard_Munteanu> Polymorphism can be modeled by natural transformations in CT.
18:29:09 <kmc> in this context i think it's best to think of 'id' as a family of different functions, one for each monomorphic type
18:29:10 * Eduard_Munteanu would also like to take this opportunity and spam about ##categorytheory   :D
18:29:24 <kmc> i don't know much about how you'd represent polymorphism, but it's a more advanced topic
18:32:30 <ddarius> Eduard_Munteanu: You need dinaturality more generally and even then it's a subtle and tricky affair.
18:32:48 <nand`> Is there a word for a mapping of one category to another which preserves objects but not necessarily morphisms?
18:32:58 <kmc> preserves?
18:33:23 <nand`> well, I was thinking along the lines of a type constructor which is not a functor
18:33:34 <kmc> there are plenty of Haskell type constructors which aren't functors
18:33:47 <kmc> data Foo a = Foo (a -> Int)
18:33:58 <nand`> yeah, I know - I was asking whether they have a special name as well
18:34:01 <Eduard_Munteanu> If it's not a functor then the image of the functor isn't necessarily a category.
18:34:06 <kmc> well that one's a contravariant functor
18:34:09 <kmc> but in general, i don't know
18:34:19 <sohum> if I have a class Foo n a b, can I state to Haskell somehow that n == a or n == b?
18:34:30 <Eduard_Munteanu> ddarius: yeah, I don't really remember the details there, just spreading common (perhaps wrong) wisdom :/
18:34:39 <kmc> nand`, i mean, it's just a map between two things, which happen to be categories, but it doesn't really matter that they are
18:34:50 <kmc> sohum, why
18:35:03 <sohum> kmc: just that it would make the type signatures nicer
18:35:38 <kmc> why do you have such a class in the first place
18:35:59 <sohum> why don't you? :P
18:36:19 <kmc> "how do I do this bizarre thing with type classes?" is usually an XY problem
18:36:28 <kmc> the answer is usually "don't use type classes" or "use fewer type classes in a simpler way"
18:36:45 <sohum> mmm.
18:37:05 <cmccann> however, the answer to "how do I annoy kmc" may very well be type classes
18:37:10 <cmccann> they're very useful there
18:37:17 <kmc> yes, that's the main application
18:37:29 <Eduard_Munteanu> :D
18:38:06 <sohum> In this case, I would normally write two functions of type a -> M a b -> M a b and b -> M a b -> M a b, but I really want them to have the same name because they are doing the same thing
18:38:20 <kmc> if they're doing the same thing, why do they have different types
18:38:46 <sohum> implementation detail versus API detail
18:38:54 <kmc> ok
18:39:01 <kmc> so you want users to be oblivious to which one of these is called
18:39:05 <ddarius> The type checker doesn't search so even if there was a way to state what you wanted, it wouldn't help.
18:39:06 <sohum> yerp.
18:39:46 <sohum> ddarius: fair enough! thanks
18:53:00 <nand`> is (*2) :: (Int -> Int) an identity morphism of Int?
18:53:29 <cmccann> I would hope not
18:53:45 <nand`> well, it maps the object Int to itself
18:54:09 <cmccann> but it isn't the identity
18:54:22 <cmccann> remember, multiple morphisms between the same types
18:54:40 <nand`> Oh, okay. I was thinking that every morphism to a same type is called an identity
18:54:50 <cmccann> er, objects. and that goes for morphisms from an object to itself as well
18:55:40 <cmccann> no, an identity morphism is exactly what it sounds like
18:55:48 <nand`> okay, good
18:56:26 <exFalso> identity is defined as f . id = f and id . g = g
18:56:37 <ddarius> People seem to have a hard time distinguishing category theory from order theory.
19:02:00 <kmc> nand`, it's an endomorphism too
19:02:06 <kmc> nand`, it's an endomorphism though*
19:02:21 <kmc> an endomorphism is any morphism with a "type signature" like A -> A
19:02:25 <nand`> right
19:04:48 <kmc> it's only the identity if composing it with another morphism f gives you f
19:04:57 <kmc> (on either side, like exFalso showed)
19:06:16 <nand`> in other words, if it does nothing
19:07:16 <kmc> careful with that
19:07:23 <kmc> are you talking about composition or application?
19:08:01 <kmc> morphisms look like functions but you can't (in general) apply them to arguments and get results
19:08:06 <nand`> where's the difference between applying the function and applying a composition of a function?
19:08:16 <nand`> ah
19:08:33 <kmc> category theory is like a generalization of the idea of functions, where you talk *only* about composition, and not about application
19:09:30 <kmc> (though in some categories you can talk about things similar to applications)
19:09:54 <nand`> Functors can be applied, can they not? eg. F(x)
19:10:44 <kmc> yeah
19:12:13 <xil> hello. Just wanted to thank everyone who helped me again. I finally got the program working ^_^. I'm learning SDL now so I can move over to that. I also wanted to just apologize if I've been annoying about getting help. You've all been very kind about it.
19:12:24 <kmc> cool, glad you got it working xil :)
19:12:54 <xil> the segfaults were because of something silly, wouldn't you know =P
19:13:30 <cmccann> segfaults usually are
19:13:54 <kmc> what was it
19:17:56 <exFalso> whah does anyone know which arch repo the latest ghc is in?
19:18:00 <nand`> If f is a bijective function from set X to set Y, does this imply that set X and Y have the same number of members?
19:18:19 <nand`> probably wrong channel
19:18:21 <exFalso> they have the same cardinality
19:18:51 <kmc> that's the definition of cardinality, isn't it?
19:19:11 <nand`> yes
19:19:19 <exFalso> well "number" is a bit misleading as infinite cardinalities cant be expressed
19:19:58 <cmccann> import English hiding (number); number = cardinality
19:19:59 <cmccann> problem solved
19:20:04 <kmc> yeah once you get to infinities, ordinals and cardinals aren't the same anymore
19:20:20 <exFalso> in the category of sets bijection means that you have no way of distinguishing between the two sets
19:27:42 <xil> kmc: oh didn't see your question. At the beginning I set the initial size to 600x600 but it should have been 0x0 so that the first call to the display callback wouldn't try do draw anything because the pointer would be empty
19:28:18 <kmc> wouldn't it be safer to set up a correct pointer ahead of time, or to have the display callback check?
19:29:17 <xil> it could check, yeah, but after the first call to the reshape callback everything is synced, so so long as everything is 0 or [] at the beginning it works. But in a more official version I'll put extra safeguards in
19:44:20 <xil> kmc: oh I realize I can use withArrayLen to check very very easily
19:50:37 <Sgeo> :t withArrayLen
19:50:37 <lambdabot> Not in scope: `withArrayLen'
19:52:31 <xil> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Marshal-Array.html#v:withArrayLen
19:52:49 <xil> :t Foreign.Marshal.Array.withArrayLen
19:52:49 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (Int -> GHC.Ptr.Ptr a -> IO b) -> IO b
19:53:00 <xil> Sgeo: ^^
19:54:10 <Sgeo> Ah
19:55:25 * hackagebot Dangerous 0.2.3 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.2.3 (NateSoares)
19:57:05 * Sgeo notes that it doesn't put < restrictions on stuff
19:57:42 <kmc> what's that mean?
19:58:34 <Sgeo> As in, mtl isn't restricted to being at most 2 or something
19:58:40 <Sgeo> Isn't it recommended to do so usually?
19:58:40 <kmc> oh
19:58:54 <kmc> shrug
19:58:56 <kmc> i don't do it
19:58:59 <kmc> nobody's yelled at me yet
20:09:45 * monochrom once had an example of unlimited nesting of ContT
20:10:17 <djahandarie> But then he took an arrow in the knee.
20:10:25 <xil> haha
20:10:40 <monochrom> I don't get it, but ok, haha
20:11:24 <Sgeo> There's an Internet-meme going around about taking an arrow to the knee. Apparently, guards in Skyrim say it a lot
20:11:59 * Sgeo is more of a Homestuck fanatic than a Skyrim fanatic. Main reason I'm aware of Skyrim is due to the fact that 11/11/2011 was an important date for both
20:12:06 <monochrom> there are too many cultural references to keep track of
20:13:24 <xil> I haven't even played Skyrim at all, but I've seen the meme enough
20:13:30 <kmc> in skyrim you can put a bucket over someone's head and then rob them blind
20:13:41 <kmc> they don't consider it an aggressive act that you've put a bucket over their head
20:15:45 <JoeyA> lol
20:16:21 <parcs`> monochrom: do you mean callCC (return . fix)
20:16:36 <parcs`> (is that unlimited nesting of ContT?)
20:17:06 <monochrom> that needs just one Cont or ContT
20:20:20 <monochrom> f :: MonadCont r m => ContT r m a or something like that. m can be another ContT r n a, where n can be ...  Inside f, I have callCC and lift (callCC ...)
20:20:25 * hackagebot postgresql-libpq 0.5 - libpq binding for Haskell  http://hackage.haskell.org/package/postgresql-libpq-0.5 (LeonSmith)
20:39:55 <Sgeo> Is ghc-mtl any easier to use than the raw GHC API?
20:40:30 * Sgeo ignores ghc-mtl in his quest to understand dynamicism in Haskell
20:47:03 <Sgeo> WHat's the best way to learn about the ghc-api
20:47:07 <Sgeo> As in, reading
20:52:37 <Sgeo> Maybe I should just learn hint
20:53:13 <drull95> Sgeo, what are you trying to do?
20:53:30 <Sgeo> Eventually, make HaskellNomic
20:53:54 <drull95> there isn't much documentation for ghc api, you can find some here, http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.2.2/index.html
20:54:10 <drull95> you probably already know about that though
20:55:28 <drull95> what's haskellNomic? I only see one google result
20:56:08 <kmc> Sgeo, if you just want to evaluate some strings, hint or mueval will be a much nicer path than GHC API directly
20:56:31 <Sgeo> o.O there's a google result for haskellNomic?
20:56:38 <kmc> probably these logs ;P
20:56:50 <djahandarie> I don't think Google indexes THAT fast.
20:56:57 <drull95> yeah, a chat log
20:56:59 <kmc> i thought it had been mentioned here before
20:57:00 <drull95> :)
20:57:02 <kmc> GHC API is a misnomer
20:57:05 <djahandarie> Oh, alright.
20:57:35 <miyako> does anyone know if there is an existing haskell wrapper for netfilter? I googled and didn't see anything but I thought I might check here before I go reinventing any wheels
20:57:37 <Sgeo> It would be a Haskell program/game that has players, who can vote to change parts of the code, including the parts that monitor voting
20:58:24 <Sgeo> I would also like it if players could have their private bits of the state, which they could copy the state as a whole into, try their modifications, before submitting it to a vote. That would probably be an improvement over the majority of codenomics
20:58:30 <kmc> "API" implies some kind of designed abstraction
20:59:11 <Sgeo> Haskell doesn't quite seem ... suited, for a codenomic, but whatever
21:00:10 <drull95> you can load a dll, that's a start
21:00:33 <drull95> across the network right? so each player has their own process
21:00:34 <kmc> "GHC API" just means access to every internal module of GHC, which is a giant crufty program written in a largely archaic style
21:00:52 <kmc> i mean i love GHC but... it's like sausages
21:00:56 <luite> hmm, it can also just mean the GHC package
21:01:13 <luite> err
21:01:14 <Sgeo> drull95, well, PerlNomic just had the one process on a webserver.
21:01:14 <luite> module
21:01:17 <pikhq> It seems like every compiler out there is crufty or trivial.
21:01:21 <Sgeo> With a web interface written in Perl
21:01:41 <Sgeo> Should be a lot of Google results for PerlNomic
21:02:16 <drull95> yeah, better than codenomic, i just got usernames for that
21:02:25 <luite> if you just need to eval or compile some code, with a bit more flexibility than hint, then GHC is often enough. otherwise you need other modules and to be prepared to make major changes for every ghc update
21:02:54 <Sgeo> "GHC is often enough."?
21:03:04 <Sgeo> As in, running a ghc process?
21:03:21 <luite> Sgeo: the GHC module
21:03:30 <Sgeo> Ah
21:04:50 <drull95> this sounds like a interesting project, do you mind if i try to help you get something simple up?
21:04:59 * Sgeo is somewhat surprised that there's a paper about PerlNomic
21:05:03 <Sgeo> drull95, o.O
21:05:16 <Goose124> I tried importing Network as it's demonstrated in "Roll your own IRC bot" and it's saying it can't find the module :(
21:05:35 <Sgeo> drull95, I think I'm at a "make vague plans forever and never actually write anything down, then remember them years later" stage
21:06:29 <drull95> yeah. this is a trick i learned from an article i read a long time ago: make what you want to do so simple you can do it right now
21:07:21 <drull95> just getting a page up is a good start for now
21:08:08 <drull95> i think haskell would actually be a good match for this project because if you know how to use the power of types it can make getting it right a lot easier
21:09:26 <djahandarie> THE POWER OF TYPES.
21:09:55 <byorgey> <cue dramatic music>
21:10:01 <drull95> TYPE THEORY! COME TO MY AID!
21:10:32 <drull95> with great power comes a lot of proof obligations
21:10:37 <byorgey> hahahaha
21:10:40 <djahandarie> Hahaha
21:10:56 <byorgey> @rememeber drull95 with great power comes a lot of proof obligations
21:10:56 <lambdabot> Done.
21:11:31 <Sgeo> I've been planning on running a Paranoia session since... 2007
21:12:02 <omg911> trying to compile code from "Monadic parsing in haskell", is a working version online somewhere?
21:12:23 <kmc> link?
21:12:52 <omg911> http://www.cs.nott.ac.uk/~gmh/bib.html#pearl
21:14:30 <tgeeky> eprints.nottingham.ac.uk/archive/00000223/01/pearl.pdf
21:14:41 <tgeeky> http://eprints.nottingham.ac.uk/archive/00000223/01/pearl.pdf
21:16:00 <drull95> ah, nomic, i remember that game
21:17:02 <kmc> yeah, that code is for Haskell 1.3
21:18:02 <drull95> <durr/> omg 2010 - 1.3 == 2008.7 versions behind
21:18:34 <omg911> kmc: heh yeah i just want to get started using this parser
21:18:39 <kmc> (the first version in which you could have classes of constructors, like Monad or Functor)
21:21:43 <hpaste> kmc pasted “diff to "Monadic parsing in Haskell" for modern Haskell (untested)” at http://hpaste.org/55701
21:22:10 <kmc> omg911, try that, it's untested but it typechecks at least
21:22:20 <Goose124> So the module I need to import is documented on hackage, but I don't have it .-. What do I do?
21:22:33 <kmc> what's the name of the package providing that module?
21:22:50 <Goose124> Not sure
21:22:52 <kmc> (you can also send me a link to the module's documentation)
21:22:59 <Goose124> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader.html
21:23:02 <ksf> mtl
21:23:05 <ksf> it's called mtl.
21:23:10 <ksf> cabal install mtl
21:23:14 <kmc> at the top it says 'mtl'
21:23:16 <Goose124> how did you find that out?
21:23:19 <Goose124> oh
21:23:20 <ksf> ...though that will give you mtl 2.0
21:23:20 <Goose124> I see
21:23:21 <kmc> "mtl-1.1.0.2: Monad transformer library"
21:23:39 <kmc> but you should already have mtl, probably version 2
21:23:54 <Goose124> Yeah
21:23:56 <kmc> http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-Reader.html
21:24:01 <kmc> that's the docs for the current version
21:24:08 <Goose124> I'm trying to get the "roll your own irc bot" working
21:24:16 <omg911> kmc: thanks, i will check that out
21:24:21 <kmc> note that different packages can provide a module of the same name
21:24:25 <kmc> like http://hackage.haskell.org/packages/archive/monads-tf/0.1.0.0/doc/html/Control-Monad-Reader.html
21:24:39 <kmc> i'm guessing you want the mtl version
21:25:11 <kmc> (why does hpaste highlight diffs with additions in red and deletions in green?  isn't that the opposite of every tool ever?)
21:25:22 <Goose124> lol
21:25:56 <augur> anyone familiar with FGL?
21:26:11 <kmc> just ask your question
21:26:17 <augur> :|
21:26:24 <kmc> :t (:|)
21:26:28 <lambdabot> Not in scope: data constructor `:|'
21:27:00 <augur> well, i want to see how you would create graph combinators using FGL, where you have things like cartesian products of graphs, etc.
21:28:48 <Goose124> kmc: All these modules on hackage appear out of date, I guess I'll just write my own IRC bot, but I can't even find a network module.
21:29:06 <kmc> what do you mean
21:29:12 <kmc> the modules on hackage appear out of date?
21:29:30 <Goose124> kmc The modules for the pre-written irc source.
21:29:38 <Goose124> "Roll Your Own IRC Bot"
21:29:44 <kmc> the basic network modules under Network.* are provided by the 'network' package, which is included in Haskell Platform
21:29:47 <kmc> you should already have it
21:30:14 <Goose124> kmc, I don't I try to import Network and it says it can't find them
21:30:34 <Sgeo> Can't import Network and have them show up
21:30:39 <Sgeo> You need to import the specific module
21:30:47 <kmc> no, there's a module named 'Network' as well
21:30:51 <Sgeo> Oh
21:30:56 <Goose124> Network isn't a module? Also, the source is trying to import Network.
21:30:59 <kmc> did you install Haskell Platform or did you get GHC another way?
21:31:10 <Goose124> Kmc I just did pacman -s ghci
21:31:22 <kmc> ok
21:31:25 <Goose124> >_> Oh my god..
21:31:36 <kmc> you can 'cabal install network'
21:31:46 <kmc> or you can figure out how Arch wants you to install Haskell packages (i hear it has good support)
21:32:04 <kmc> but your life will be much easier if you install the whole Haskell Platform right away
21:32:11 <kmc> http://hackage.haskell.org/platform/linux.html
21:32:12 <Goose124> It seems Network IS installed
21:32:13 <kmc> http://www.archlinux.org/packages/extra/i686/haskell-platform/
21:32:37 <Sgeo> Is it just me or is Network trivially easy to use
21:32:56 <kmc> i hate the word "trivial" and i'm not going to be subtle about it
21:33:07 <Goose124> Kmc: Try to load this in GHCi and see what I mean: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
21:33:23 <kmc> why don't you try to load it in ghci, and share with us the exact command you ran, and the error messages you got
21:33:33 <Goose124> Okay
21:33:41 <timemage> kmc, how about non-trivial?
21:33:51 <kmc> Goose124, it loads; I get a few warnings only
21:34:03 <Goose124> IRC.hs:6:8:
21:34:03 <Goose124>     Could not find module `Control.Monad.Reader':
21:34:04 <Goose124>       Use -v to see a list of the files searched for.
21:34:04 <Goose124> Failed, modules loaded: none.
21:34:04 <Goose124> Prelude>
21:34:10 <kmc> don't paste in the channel
21:34:12 <Goose124> >_<
21:34:15 <kmc> also, install Haskell Platform
21:34:18 <Goose124> okay
21:34:23 <Goose124> So I don't have the platform?
21:34:26 <kmc> nope
21:34:32 <Goose124> I guess I assumed it was installed with ghci
21:34:40 <kmc> yeah, that's incorrect
21:34:49 <kmc> Haskell Platform is GHC (and GHCi) plus a standard set of libraries
21:34:51 <Goose124> Well thanks for helping me come to this realization >_<
21:35:16 <kmc> timemage, that's a bit better
21:35:46 <kmc> 'trivial' used to have a useful, specific meaning
21:35:50 <kmc> now it is just a douchebag way to say 'easy'
21:36:06 <timemage> kmc, ok.  that was what wondering.
21:36:15 <djahandarie> Understanding the nuances of English is pretty nontrivial.
21:36:41 <kmc> whereas 'non-trivial' can be a bit pretentious, but it's not used to dismiss difficulties
21:36:58 <kmc> also i think 'non-trivial' is still meaningful distinct from 'hard'
21:37:12 <kmc> 'non-trivial' is easier than 'hard' but admits that there will be some difficulties
21:37:21 <kmc> 'trivial' should mean 'so incredibly easy that there is nothing to say about it'
21:37:57 <djahandarie> But now it means 'I think this is easy and if you don't understand you're stupid'?
21:38:02 <kmc> yeah
21:38:11 <Goose124> Yeah...it just loaded fine...Thanks kmc.
21:38:15 <kmc> or even 'this is hard, but the hard parts don't interest me personally, so i will pretend it's easy'
21:38:44 <kmc> in #haskell "trivial" often means "a massive engineering effort with few theoretical research problems"
21:38:47 <Goose124> The only thing that didn't load up was my spellchecking module, but that's because it's not finished :P
21:38:58 <companion_cube> "straightforward" is just a little harder than trivial, isn't it?
21:39:04 <timemage> well, people use "obviously," that way also.    reminds me of the usenet quote about the only intuitive interface being the nipple.
21:39:22 <kmc> to me "straightforward" means that it might be a lot of work, but that you aren't likely to get massively stuck
21:39:27 <kmc> at each point there should be a clear way to proceed
21:39:33 <kmc> a straight... forward path ;)
21:39:55 <Sgeo> :t socket
21:39:56 <lambdabot> Not in scope: `socket'
21:40:02 <kmc> Goose124, cool :)
21:40:02 <Sgeo> :t Network.socket
21:40:03 <lambdabot> Not in scope: `Network.socket'
21:40:20 <companion_cube> I would say "straightforward" means there is no difficulty
21:40:41 <kmc> digging a very large hole is straightforward
21:41:05 <kmc> but it consumes significant time and effort
21:41:16 <companion_cube> yeah, ok
21:42:25 <kmc> documenting a large library is reasonably straightforward, but it consumes significant time and effort *and* it requires care and intelligence
21:42:35 <companion_cube> depends on which library
21:42:46 <kmc> so it's not just a matter of brute force / mechanical tasks, either
21:42:53 <companion_cube> if the library is openssl, it may prove highly non-trivial ;)
21:43:08 <kmc> yeah
21:43:19 <kmc> and writing a  high-level overview isn't really straightforward
21:44:31 <kmc> many Haskell libraries have good documentation at the level of individual functions and type declarations
21:44:43 <kmc> but no examples or high-level overview
21:44:55 <monochrom> my "straightforward" means no thinking
21:45:12 <kmc> not easy to use when a library is 20 modules with 200 well-documented functions in alphabetical order
21:45:57 <monochrom> I think we learned that doc style from javadoc
21:46:32 <edwardk> Can someone proof-read http://comonad.com/reader/2011/searching-infinity/ ?
21:46:32 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
21:46:59 <edwardk> preflex: xseen roconnor
21:46:59 <preflex>  roconnor was last seen on freenode/#haskell 14 hours, 40 minutes and 22 seconds ago, saying: wereHamster: you more or less cannot pattern match on a string
21:47:01 * mgsloan thinks that there needs to be a cabal tradition of examples builtin
21:47:18 <mgsloan> that can have dependencies that differ from the main package
21:47:26 <monochrom> and javadoc probably learned that style from man pages
21:47:29 <mgsloan> (not different, just more)
21:47:43 <kmc> yeah, package docs as we structure them now don't have a good place to put examples
21:47:58 <edwardk> @tell roconnor sounds good. feel like maintaining a package? =)
21:47:58 <lambdabot> Consider it noted.
21:48:27 <mgsloan> yup, this is something that could be designed into haddock / cabal
21:48:41 <Goose124> What are the recommended tutorials for Haskell currently?
21:48:45 <kmc> perhaps there should be a cabal directive to say "in addition to Haddock HTML docs, please build HTML pages from these markdown+lhs files and link them in"
21:48:50 <companion_cube> Goose124: LYAH
21:48:50 <kmc> LYAH and RWH
21:48:52 <kmc> @where LYAH
21:48:52 <lambdabot> http://www.learnyouahaskell.com/
21:48:53 <kmc> @where RWH
21:48:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:49:08 <Goose124> Thanks
21:49:14 <kmc> i love writing in markdown+lhs
21:49:18 <Sgeo> > case "hi" of { "hi" -> 5; _ -> 6 }
21:49:20 <lambdabot>   5
21:49:25 <Sgeo> > case "hiya" of { "hi" -> 5; _ -> 6 }
21:49:26 <lambdabot>   6
21:49:31 <kmc> and pandoc already supports it well
21:49:31 <mgsloan> "and provide an index of examples on the main page" / have a convenient way to declare links to those examples
21:49:33 <Sgeo> Pattern-matching on a string
21:49:52 <kmc> i should see about including rendered markdown+lhs examples in github
21:49:54 <mgsloan> lhs examples would indeed be beautiful
21:50:00 <mgsloan> oooooh
21:50:08 <kmc> (but the nice thing about that format is, even if you don't render it, it's still readable)
21:50:17 <kmc> and most editors will at least highlight lhs properly
21:50:21 <kmc> (bird-style)
21:50:27 <mgsloan> but githubs highlighting / blog format is pretty awesome
21:50:54 <mgsloan> seems like getting them to do markdown lhs wouldn't be too hard
21:52:18 <mgsloan> do/would cabal files in a subdirectory work?
21:53:14 <mgsloan> oh, actually a single cabal file can already do multiple executables + library, I think, with independent deps
21:53:57 <monochrom> I am not comfortable with the prospect that running the examples needs more packages. then again, if it is an option, some libraries can use it when necessary, and some other libraries don't need it. and some users can turn it on to run the examples, and some other users can skip the examples.
21:55:05 <kmc> mgsloan, yeah, it can
21:55:48 <mgsloan> so really mostly a haddock thing, then.  Question is, will hackage / cabal install try to build the auxiliary stuff?
21:55:48 <kmc> it's not all that important that it be very easy to build the examples
21:55:54 <kmc> they're more for looking at
21:56:10 <kmc> automatic build is more important for testsuite; cabal has stuff for that already
21:56:44 <mgsloan> yeah, this isn't /that/ common of a case, but reasonably fleshed out examples would be cool, and often times I'd want to use data structures / combinator libraries that the library does not requre
21:57:06 <kmc> yeah
21:57:28 <mgsloan> backwards-dependencies will help here
21:57:37 <mgsloan> it'd be cool to see per-function backwards-dependencies
21:57:51 <kmc> i think the main missing feature here is a way to get a link from the top package page, directly to highlighted source for some file, which wasn't actually built as part of the library
21:58:04 <kmc> less important whether it's built by an alternative command or not
22:09:03 <hpaste> drull95 pasted “a crappy beginning to hnomic” at http://hpaste.org/55702
22:11:12 <Sgeo> Ah, so basically just compiling the new file and running it
22:11:23 <drull95> i was going to make a web interface but you know what, an irc face might be more fun
22:11:32 <kmc> ah for that see http://hackage.haskell.org/package/dyre
22:11:41 <drull95> yeah, i was going to do dynamic linking but this was easier
22:12:23 <drull95> now im going to stick an irc face on it
22:12:44 <drull95> kmc, thanks for the link
22:38:22 <Sgeo> When writing a library for others to use, is there a preferred iterator package?
22:40:00 * Sgeo reads the IterIO docs
22:40:12 <Goose124> would this define a singleton list: bList :: a -> b -> [(a, b)]
22:40:27 <kmc> that's just a type signature; it doesn't define any list
22:40:29 <augur> anyone know of a connection between church encodings and continuations?
22:40:34 <Goose124> Would the output be a singleton list containing a tuple...
22:40:50 <Goose124> would the output type* :/
22:40:52 <kmc> Goose124, maybe.  or it might be a list of five elements, or an empty list
22:40:58 <kmc> the length of a list is not part of its type
22:41:03 <Goose124> kmc, thanks.
22:41:08 <augur> kmc: not in haskell its not
22:41:09 <augur> :D
22:41:10 <Goose124> That's what I wanted to know :|
22:41:21 <augur> or even more accurately
22:41:28 <augur> not in haskell-without-SHE its not
22:41:28 <kmc> > let bList x y = (let p = (x,y) in [p,p,p,p,p]) in bList 2 'x'
22:41:29 <lambdabot>   [(2,'x'),(2,'x'),(2,'x'),(2,'x'),(2,'x')]
22:41:46 <kmc> augur, no, you can do it in plain Haskell
22:41:47 <Sgeo> Is IterIO easy-to-use?
22:41:53 <Sgeo> Relative to other similar libraries?
22:42:00 <augur> kmc: well you can use type hackery
22:42:07 <augur> to get almost-indexed types
22:42:10 <kmc> GHC extensions make length-tagged lists nicer; SHE or recent GHC extensions make it nicer still
22:42:13 <Goose124> > let bList index elem = [(index, elem)] in bList a b : bList b c
22:42:14 <lambdabot>   Couldn't match expected type `[(SimpleReflect.Expr,
22:42:14 <lambdabot>                        ...
22:42:15 <augur> but type level naturals are themselves not type safe
22:42:26 <kmc> right
22:42:35 <augur> so i dont consider those truly indexed by length
22:42:44 <kmc> dynamically typed programs aren't programs?
22:42:45 <copumpkin> you can use a closed typeclass for naturals
22:42:48 <augur> they're indexed by something which, if you dont misuse it, is length!
22:42:58 <augur> copumpkin: oh? well then!
22:43:02 <augur> thats even better!
22:43:06 <kmc> augur, you can define it in a module an export an API which essentially disallows misuse
22:43:17 <copumpkin> then someone would have to lie if they wanted to be accepted
22:43:22 <augur> but really, if you want indexed types, use SHE
22:43:30 <kmc> or GHC 7.4
22:43:32 <kmc> or Agda ;P
22:43:42 <copumpkin> or use an accusative, duh
22:43:44 <copumpkin> HER
22:43:45 <augur> yeah but agda isn't good for mainstream, yet
22:43:51 <kmc> and SHE is?
22:43:56 <copumpkin> a nominative
22:44:08 <augur> Haskell Extension for Reallyawesomeindexedtypes
22:44:09 <kmc> both GHC 7.4 and Agda probably have more users right now
22:44:19 <kmc> not like i have numbers or anything but,
22:44:52 <augur> agda's main problem for mainstream stuff is its last of elegant syntax for things we do a lot of, like lists
22:44:59 <augur> which i dont think is a problem with agda
22:45:07 <augur> but then, im not trying to get agda to be mainstream
22:45:08 <augur> soo
22:47:19 <augur> i think epigram 2 will be quite nice to use tho
22:47:38 <kmc> omnomnominative
22:47:48 <augur> Desc based data types that have /nice/ representations
22:49:12 <kmc> does GHC let you rebind (:) and [] with appropriate extensions?
22:49:35 <mjrosenb> there's an extension to rebind []?
22:49:46 <mjrosenb> that seems like a bad idea
22:52:37 <Goose124> I'm thinking of a function that iterates through a list comparing each item by  a supplied function and then based on that deciding what it should do with it...
22:53:51 <mjrosenb> Goose124: ok...
22:54:15 <Goose124> mjrosenb, nevermind >_< I'm rambling
22:55:46 <Goose124> :t Compare
22:55:47 <lambdabot> Not in scope: data constructor `Compare'
22:55:51 <Goose124> :t compare
22:55:52 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
23:00:01 <Zamarok> Some quick help, anyone? How would I check if a list of numbers are divisible by n? The function could return a Bool or a [Bool]
23:00:45 <Goose124> map (mod n) list == 0
23:00:56 <Goose124> That might be some pseudocode, but it's the idea.
23:01:29 <Sgeo> IterIO doesn't work on Windows WTF?
23:01:46 <copumpkin> lol
23:02:08 <Zamarok> Goose124: hmm, that'O
23:02:16 <Zamarok> that's good*
23:04:34 <Cale> Goose124: the == 0 will be a type error usually
23:04:40 <kmc> :t let k `divides` n = (n `mod` k) == 0  in  all (7 `divides`)   -- Zamarok
23:04:41 <lambdabot> forall t. (Integral t) => [t] -> Bool
23:04:44 <Cale> Since you're comparing a list to 0
23:05:01 <Cale> You could write map (\k -> n `mod` k == 0) xs
23:05:05 <Goose124> Cale, Yeah, I don't know haskell well, I just knew a technique of finding divisbility..
23:05:10 <kmc> :t all
23:05:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:05:32 <Cale> and replace 'map' with 'any' or 'all' depending on what you might want
23:06:05 <Zamarok> Really I'm going to be mapping that over a [[Number]].. or a list of lists
23:10:26 * hackagebot timeplot 1.0.0 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.0 (EugeneKirpichov)
23:11:01 <kmc> mjrosenb, yeah but GHC allows a lot of things that are bad ideas outside a narrow context ;)
23:11:02 <hpaste> Zamarok pasted “factors” at http://hpaste.org/55703
23:11:05 <kmc> this one I think is not allowed
23:11:19 <Zamarok> That's what I'm trying to do.. anyone know a better way of doing that? It works, but I feel like it is probably very slow
23:11:49 <Zamarok> (parMapStrat can be substituted with map)
23:12:02 <kmc> it's parMap with some strategy?
23:12:10 <Sgeo> Yay, Data.Enumerator Iteratees are monads
23:12:18 <Sgeo> Now, why isn't that made clear in examples?
23:12:53 <kmc> Zamarok, did you test it for speed (in a compiled program with ghc -O2)
23:13:03 <Sgeo> http://hackage.haskell.org/package/enumerator why isn't the Data.Enumerator.IO link working?
23:13:34 <kmc> Sgeo, http://hackage.haskell.org/packages/archive/enumerator/0.4.16/doc/html/src/Data-Enumerator-IO.html
23:13:40 <kmc> the author chose to hide the haddocks, for whatever reason
23:13:43 <kmc> i guess it is deprecated
23:13:52 <kmc> unfortunately that won't hide it from the hackage list
23:13:59 <kmc> even though it does hide it from local haddock's index.html
23:14:56 <kmc> useful trick: doc/html/src/ contains source even for hidden or non-exposed modules
23:15:51 <Zamarok> kmc: Well I haven't tested it for speed, but I know that it works
23:15:57 <kmc> ok
23:15:59 * mjrosenb would not complain about having some characters marked as 'outfix'
23:16:03 <kmc> why do you feel like it's very slow
23:16:06 <Zamarok> kmc: and yes, parMap is parallelism.
23:16:15 <mjrosenb> and letting you define your own outfix values/types
23:16:41 <kmc> Zamarok, whether there's "a better way of doing that" depends on what you mean by "that"
23:16:41 <Zamarok> I feel like it's slow because it has to return Maybe x or Nothing and then concat all the Maybe values in to a list of real values.. is that not slower than a 'filter' ?
23:16:57 <Sgeo> The documentation for enumerator doesn't quite make clear to me how I'd write my own enumerator
23:17:33 <kmc> if you just mean "get a list of factors" then yeah, there are better algorithms using prime numbers and, like, number theory
23:17:53 <kmc> if you're asking about better implementations of this simple algorithm, it seems ok to me
23:18:27 <kmc> is catMaybes + map slower than filter? probably, I don't know by how much.  it's not obviously terrible, to me
23:18:32 <kmc> you should run it and find out
23:18:42 <Zamarok> right ok. Really I was wondering if my 'findMod x' function could be a function applied with 'filter' instead of the way it is now
23:19:06 <kmc> well, it wouldn't be parallel then
23:19:26 <kmc> unless you had a parallel filter, and that's a bit harder to write than parMap
23:19:41 <kmc> to be honest your parallelism here is probably too fine-grained
23:19:56 <Zamarok> Hmm oh I see. Well my parallelism is working to speed it up a bunch according to rtsopts
23:20:01 <kmc> cool
23:20:32 <kmc> (did you compare to the version with 'map'?)
23:20:58 <Zamarok> Yes, a while ago. (parMap rseq) is somewhat faster, but I forget how much
23:21:02 <kmc> the CPU utilization number might be several hundred %, but it's no good if the work you're parallelizing is work that didn't need to be done in the sequential case
23:21:02 <kmc> cool
23:21:14 <kmc> how many sparks did you create, and how many got converted
23:21:43 <Sgeo> I'm starting to think that maybe enumerators are a bragging point of Haskell over other languages.
23:22:04 <kmc> really?
23:22:14 <Zamarok> Ran it for 10 seconds: SPARKS: 22226870 (20748 converted, 20577605 pruned)
23:22:27 <Zamarok> I'm not quite sure how to interpret that info yet
23:22:57 <kmc> you know what a thunk is? and what a spark is?
23:23:26 <Zamarok> A thunk is a lazy value, right?
23:23:35 <Zamarok> That will be evaluated
23:23:46 <kmc> Zamarok, yeah.  it's the operational term for an unevaluated computation
23:24:04 <kmc> a spark is a thunk which was flagged for possible parallel evaluation
23:24:19 <Zamarok> got it
23:24:38 <kmc> when you evaluate (par x y), the GHC runtime will push 'x' onto the spark queue, then evaluate y as normal
23:24:49 <kmc> that's creating a spark
23:25:09 <kmc> later if some CPU is idle, it might take thunks off the spark queue and start evaluating them
23:25:32 <kmc> often it will find that the evaluation was already completed in the meantime
23:25:38 <kmc> those are the 'pruned' sparks, i think
23:26:07 <kmc> creating a spark is pretty cheap, because it's just pushing a pointer onto a lock-free queue
23:26:17 <kmc> it's cheaper than creating a Haskell thread, which is in turn much cheaper than creating an OS thread
23:26:36 <kmc> but it's still not free, and neither is discarding the stale sparks, so it's bad to create tons of sparks which get pruned
23:26:43 <Zamarok> Ahh ok. Well all four CPU cores are close to full blast while this program is running, and rtsopts reports quite a few converted sparks after the program completes
23:26:44 <kmc> you might want to try the parListChunk strategy
23:27:06 <kmc> > 20748 / 22226870.0
23:27:07 <lambdabot>   9.334647658442237e-4
23:27:42 <kmc> a very small percentage of your sparks are getting converted to threads
23:27:45 <Zamarok> Ohh ok, that makes things clearer. I should definitely fix that
23:27:54 <kmc> maybe, or maybe it's fast enough already :)
23:28:09 <sgronblo2> Is vim supposed to have haskell auto indentation? Or do most people just use smartindent or?
23:28:11 <Zamarok> Maybe, but I am only doing this to learn about parallelism
23:28:15 <kmc> cool :)
23:28:35 <Zamarok> sgronblo2: works out of the box for me
23:28:41 <Zamarok> kmc: thanks for your help^^
23:28:52 <sgronblo2> Zamarok: do you have something in indentexpr then or?
23:28:57 <kmc> to me the nice thing about parallelism and concurrency in GHC is not that you get super performance, but that you can get respectable performance with little effort
23:30:35 <Zamarok> Yea, I barely had to change anything at all for a parallel map
23:31:23 <kmc> for the most important performance-critical apps, people are willing to spend months writing it in C and tweaking every aspect of low-level behavior
23:31:46 <kmc> but Haskell makes it easy to use multiple cores even for quick hacks
23:33:25 <Sgeo> http://www.mew.org/~kazu/proj/enumerator/
23:33:27 <kmc> and it's cool because for many years, "parallelism" was the standard answer to why pure FP is good
23:33:30 <Sgeo> "can be composed with another Iteratee by (>>=):
23:33:30 <Sgeo> Iteratee >>= Iteratee --> Iteratee"
23:33:36 <kmc> and for a long time we had nothing concrete to show for it
23:33:36 <Sgeo> That makes no sense.
23:33:38 <kmc> but now we do :)
23:34:37 <Zamarok> It's awesome.. the most attractive part of FP to me is that my programs are less confusing and buggy. Who needs state?!
23:34:55 * kmc sometimes needs state
23:35:05 <kmc> but Haskell gracefully incorporates imperative programming too
23:35:48 <Zamarok> Haven't discovered that part yet
23:37:18 <kmc> if you believe The Internets, the dogma of haskell is "NO STATE EVER", but it's more like "use state only where you need it, and be explicit about it"
23:39:26 <kallisti> any reason why the -ghci-script option isn't working on ghci?
23:41:42 <kmc> i don't see it in the ghc manpage
23:42:59 <kmc> it seems to be an unmerged patch from http://hackage.haskell.org/trac/ghc/ticket/5265
23:43:28 <kallisti> ah
23:47:27 <kallisti> also -read-dot-ghci doesn't seem to work either
23:50:40 <kallisti> ghc -read-dot-ghci  test.ghci
23:50:41 <kallisti> /usr/bin/ld:test.ghci: file format not recognized; treating as linker script
23:50:41 <kallisti> /usr/bin/ld:test.ghci:1: syntax error
23:50:56 <sgronblo2> What's the opposite of filter again?
23:51:21 <kallisti> filter (not.f) ?
23:51:23 <kmc> what does that mean
23:51:25 <kallisti> what do you mean by opposite?
23:51:47 <sgronblo2> as in keep all elements that the function returns false for
23:51:55 <kmc> :t \f -> filter (not . f)
23:51:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
23:52:15 <sgronblo2> so there' nothing like ruby's reject?
23:52:22 <kallisti> sgronblo2: you just apply not to the result of the filtering function
23:52:35 <Zamarok> maybe you mean something like: (filter predicate list) \\ list
23:52:39 <kallisti> :t filter.not
23:52:40 <lambdabot>     Couldn't match expected type `a -> Bool'
23:52:40 <lambdabot>            against inferred type `Bool'
23:52:40 <lambdabot>     Probable cause: `not' is applied to too many arguments
23:52:47 <kallisti> ah right
23:52:49 <kallisti> can't do that.
23:52:51 <kmc> :t (snd .) . partition
23:52:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
23:53:33 <kmc> this seems like a case where writing «filter (not . p)» is clearer than having two names for what's almost the same function
23:53:44 <sgronblo2> well of course i can use filter and define the function in a reversed way or combine it with not, but it would just be a bit surprising to me if prelude didn't already contain a function like that.
23:54:42 <kallisti> the idea is to give you a small set of useful building blocks that you can use to write your own functions. having an extra name for what is a negated filter is unecessary.
23:54:49 <kallisti> when you have filter, (.), and not.
23:54:56 <kmc> it's worse than unnecessary, it makes the code harder to read
23:55:07 <kallisti> eh, possibly.
23:55:10 <sgronblo2> well...
23:55:46 <sgronblo2> I'm all for there's only one way to do it. But I think filter is not a good function name to begin with if you think about it.
23:55:51 <kmc> i mean, should there be a prelude function lessThanFive?  no, you just write (< 5), that's a better name for that function
23:56:00 <kmc> filter (not . p)  is a less clear-cut case of the same principle
23:56:01 <sgronblo2> It's not clear from the name if you are left with the gold nuggets or the sand
23:56:07 <kmc> there are even fuzzier cases
23:56:36 <kallisti> sgronblo2: that's because your function decides what are the gold nuggets.
23:56:38 <kmc> Data.List has both 'break' and 'span', maybe it should have only one
23:57:11 <Sgeo> I'm pretty sure enumerators would have beautifully solved a problem I had in a C# project of mine
23:57:17 <kmc> i agree 'filter' is not the best name
23:57:24 <kmc> fortunately you only have one name to learn and not two
23:57:28 <sgronblo2> but if you have list.select and list.reject for example it's clear that you are attempting to either get stuff that matches or get rid of stuff taht doesnt
23:57:32 <carpi> can someone please tell me what it means when i see something like "No instances for (RealFrac Integer, Floating Integer)"?
23:57:56 <sgronblo2> well in this case i think its a very long shot to claim that its hard to learn select and reject
23:58:09 <kmc> "filter should be renamed to select" is a separate proposal from "\p -> filter (not . p) should be in Prelude)
23:58:10 <kmc> "
23:58:11 <Cale> carpi: Probably that you're trying to use Integer values like they're floating point numbers
23:58:11 <Sgeo> It means you tried to use an integer like a RealFrac or a Floating, I guess.
23:58:15 <kallisti> carpi: it means exactly that. we'd need to see more context in order to figure out what's wrong.
23:58:23 <sgronblo2> in fact, i was just attempting to use filter without looking at the docs, and i remembered that it worked the opposite way that it actually does
23:58:25 <Sgeo> Not sure why that looks like a tuple, but I' not a Haskell expert
23:58:25 <kmc> > (2 :: Integer) / 3
23:58:26 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
23:58:26 <lambdabot>    arising f...
23:58:37 <Cale> > sin (1 :: Integer)
23:58:38 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
23:58:38 <lambdabot>    arising fr...
23:58:48 <kmc> Sgeo, it's a pair of constraints
23:58:50 <sgronblo2> so that proves that at least for me, filter is less intuitive than select/reject
23:58:56 <kallisti> sgronblo2: "it worked the opposite way that it actually does" is that even possible?
23:58:57 <Sgeo> carpi, basically, an instance for A B means that you know how to treat B like an A
23:59:02 <kmc> sgronblo2, no, it proves that filter is less intuitive than select
23:59:17 <kmc> whether 'filter' is a bad name is a separate question from whether both functions should have names
23:59:19 <sgronblo2> kallisti: oops, i meant that it worked differently than i thought
23:59:21 <Sgeo> If there are no instances, it doesn't know how to treat B like an A
23:59:39 <Cale> Except that we need select to mean  select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
23:59:51 <sgronblo2> anyway i didn't think haskell in general cared that much about having only one way to do it
