00:00:24 <kmc> shachaf, a second-order type contains first-order functions?  i don't know, and i don't think it's important
00:03:29 <xil> so I want to process the elements of a list in parallel and ensure that the computation happens in the thread it's written in. I'm thinking "parList rdeepseq mylist"
00:04:02 <shachaf> xil: Why do you care about which thread a computation happens in?
00:04:26 <xil> because I access the data in the thread that handles my GUI, and I don't want that thread to end up computing it, because it's intensive
00:04:55 <c_wraith> I'm not sure how you can even be parallel with that constraint...
00:04:56 <ski> c_wraith : you might be looking for the term "polynomial datatype"
00:05:06 <c_wraith> hmm.  that sounds about right.
00:05:24 <dolio> Context free types.
00:05:59 <xil> well Haskell is free to assign the computation to any number of threads/processors, so long as the GUI is left free to do its thing
00:06:33 <c_wraith> I would worry about it only after you have proof there's a problem.
00:06:36 <xil> my understanding is that parList will let Haskell control precisely how the parallelization is done, and rdeepseq just makes sure it actually happens when I call it
00:06:59 <xil> if I don't use deepseq or parallel strategies then there's a problem
00:07:14 <c_wraith> are you using the threaded runtime with -N2 ?
00:07:24 <c_wraith> (or higher)
00:07:49 <xil> have been neglecting that, but I haven't tried using strategies yet
00:08:07 <c_wraith> well, unless you're running the threaded runtime, you're getting exactly zero parallelism anyway
00:08:33 <xil> but I still get threads right? So the computation can't eat up all of the processor time because Haskell will give time to the GUI thread
00:08:44 <xil> they're software threads, but still, no?
00:08:47 <c_wraith> they're green threads
00:08:53 <c_wraith> they all are run by a single OS thread
00:08:54 * ski idly wonders whether the parallelism is the logarithm of the "breadth" of the computation
00:09:26 <c_wraith> it will do context switching for you, but it won't give you any kind of parallel speedup
00:09:56 <c_wraith> in fact, I'm sure par is implemented as const in the non-threaded runtime
00:10:10 <xil> right right, and I need those flags for using strategies, so I'm very thankful you reminded me
00:10:30 <xil> but it's not like not using the flag caused my problem right?
00:10:44 <xil> hogging the GUI thread is still a repercussion of the wrong thread doing the computation because of laziness
00:10:45 <xil> ?
00:10:49 <c_wraith> no
00:10:57 <c_wraith> oh, well, potentially
00:11:05 <xil> right it's not a guarantee
00:11:15 <c_wraith> well, it depends on exactly what's going on.
00:11:27 <xil> so I'd like to make absolutely sure that the computation is done on the second thread
00:11:37 <c_wraith> don't think of it that way
00:11:53 <c_wraith> think of it as "make absolutely sure the computation is done before the result is stored in the IORef"
00:12:04 <xil> aha, okay
00:12:50 <c_wraith> and you could do that, without using parallelism, just using something like deepseq
00:13:24 <xil> oh right right
00:13:47 <xil> but I'm doing the Mandelbrot stuff, so I thought it'd be an opportunity to learn Strategies
00:13:58 <c_wraith> Sure, but make that the next step along
00:14:08 <c_wraith> deepseq is closely related to strategies, anyway
00:14:17 <xil> very very good point. I keep getting ahead of myself
00:14:26 <xil> I'll get deepseq working first
00:14:33 <xil> thanks =]
00:14:59 <nexion> is there a way to listen for changes to a TVar? or if not, what would be a good way to set up a notification system where threads can tell the database manager thread that the connection is down, causing it to reconnect?
00:15:47 <c_wraith> nexion: if a transaction reads from a TVar, then calls retry, it will block until the TVar (or, well, something it read from) changes
00:15:47 * ski . o O ( incremental/adaptive computation, RETE, &c. )
00:16:43 <xil> well I'm off for the night. Thank you all for the help. Good night =]
00:16:49 <kmc> do x <- readTVar v; when (x == expectedValue) retry
00:17:17 <kmc> 'retry' has the simple semantics of immediate retry, but implementations will provide a more efficient implementation
00:17:52 <kmc> this is very powerful; you can read two TVars atomically and then 'retry' based on some relationship of the values
00:18:14 <mjrosenb> :t retry
00:18:15 <lambdabot> Not in scope: `retry'
00:18:19 <nexion> that will do :)
00:18:25 <nexion> thanks
00:18:29 <kmc> which in effect is like blocking on either of two things at once
00:18:49 <mjrosenb> kmc: i'm guessing retry is not for every monad
00:18:52 <c_wraith> the other neat thing about retry is its interaction with orElse
00:18:56 <kmc> mjrosenb, no, it is part of STM
00:18:57 <c_wraith> retry is part of stm
00:19:02 <c_wraith> just like orElse
00:19:24 <ski> @hoogle retry
00:19:24 <lambdabot> Network.HTTP.Base Retry :: ResponseNextStep
00:19:24 <lambdabot> GHC.Conc.Sync retry :: STM a
00:19:24 <lambdabot> GHC.Conc retry :: STM a
00:19:28 <ski> @hoogle+
00:19:28 <lambdabot> Control.Monad.STM retry :: STM a
00:19:28 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
00:19:28 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()
00:19:30 <kmc> retry :: STM a
00:19:36 <kmc> orElse :: STM a -> STM a -> STM a
00:19:38 <c_wraith> x `orElse` y has the fun property that it's x unless x calls retry, otherwise it's y
00:20:10 <c_wraith> Which gives you the ability to wait on disjunctions of conditions
00:20:27 <ski> s/unless x/unless x, or the continuation of the computation/, no ?
00:20:38 <mjrosenb> sounds neat, i should try using stm again
00:20:47 <shachaf> ski: Continuation of the computation?
00:20:57 <kmc> the last chapter in RWH is a good intro to STM
00:21:04 <c_wraith> ski: orElse shouldn't care what its second argument does...
00:21:05 * hackagebot yesod 0.9.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.4.1 (MichaelSnoyman)
00:21:06 <kmc> http://book.realworldhaskell.org/read/software-transactional-memory.html
00:21:15 <ski> shachaf : you know, if you say `orElse x y >>= k', then `k' is (part of) the continuation
00:21:41 <c_wraith> nor should orElse care what happens outside of its first argument
00:21:47 <ski> and presumably, `orElse x y >>= k' is equivalent to `orElse (x >>= k) (y >>= k)'
00:21:56 <c_wraith> I don't think so
00:22:48 <shachaf> That would be kind of odd.
00:23:26 <mkramer> What's wrong with this type signature?  atoms :: [(Num a) => a -> a] [(Num a) => a -> a -> a] Int
00:23:42 <shachaf> mkramer: What's it supposed to be?
00:23:43 <c_wraith> probably a whole lot
00:23:57 <shachaf> You can't have two types next to each other like that.
00:24:18 <shachaf> And you usually don't have type class constraints inside parameters to other types.
00:24:19 <mkramer> atoms takes a list of functions from (a -> a), where a is in the typeclass Num, a list of functions from (a -> a -> a), where a again is in the typeclass Num, and an Int
00:24:21 <kmc> it's weird to show some code and ask "what's wrong with it" without telling us why you think it's wrong or what you think it should be
00:24:26 <ski> mkramer : (a) you're missing some `->'s; (b) you probably either want a couple of `forall a. 's in there, or (more probably) want to lift the class constraints outside the list types
00:24:27 <shachaf> Especially without quantification.
00:25:37 <ski> mkramer : most probably you want `atoms :: Num a => [a -> a] -> [a -> a -> a] -> SomethingHere', where `SomethingHere' might be `Int', but i suspect you want something with `a' in it
00:26:30 <ski> kmc : well, we're supposed to use our mind-reading powers, obviously
00:26:40 <mkramer> it doesn't compile
00:26:47 <ski> "it" being ?
00:26:55 <dolio> It's pretty obviously wrong.
00:27:02 <mkramer> I don't understand the error message, "is applied to too many type arguments" in the type signature for atoms
00:27:06 <dolio> What the right version is is a harder question.
00:27:15 <ski> (0) tell us exactly what you tried; (1) exactly what the response was; (2) exactly what you expected
00:27:19 <ski> ?
00:27:25 <mkramer> You've already answered the question
00:27:35 <mkramer> :)
00:28:57 <mkramer> (0) I tried the type signature wrote above in a one line file and :load'd it in GHCi, (1) where it failed to compile for the error message I just referenced, and (2) I expected it compile with the type signature meaning what I expressed in english above
00:29:15 <mkramer> and you fixed it, so thanks
00:29:34 <shachaf> mkramer: ski is giving you guidelines for asking questions in general, I think.
00:30:05 <shachaf> * say what you want * show code that you have * show error message
00:30:11 <Rodayo> I've written the fibonacii function like so: fib 0 = 0
00:30:12 <shachaf> (If applicable.)
00:30:36 <Rodayo> I've written the fibonacii function like so: fib 0 = 0 fib 1 = 1 fib n  = fib ( n - 1) + fib (n - 2)
00:31:23 <kmc> and it's really slow?
00:31:32 <Rodayo> I wrote another function that maps that over a list so when I call "map fib [0..100]" or some large number
00:31:37 <Rodayo> it runs quite slowly
00:32:05 <Rodayo> which surprises me, because the previous two numbers are available at each step so it's a simply addition operation. What's the reason for slowness?
00:32:18 <shachaf> Rodayo: The function doesn't look at the list.
00:32:26 <shachaf> Rodayo: It recomputes the whole tree each time.
00:33:07 <c_wraith> hmm
00:33:08 <c_wraith> Prelude Control.Monad.STM> let f b = if b then return b else retry in atomically $ (f False `orElse` return False) >>= f
00:33:08 <c_wraith> ^CInterrupted.
00:33:54 <c_wraith> ski, if I'm awake enough to be testing coherently, that would imply that orElse only handles its first argument retrying, not the whole computation
00:35:03 <c_wraith> but I'm barely awake, so if that's coherent, it's pure luck.  Now I must fall over.
00:36:52 <Rodayo> shachaf, will this happen even if I compile it with ghci?
00:37:51 <shachaf> Rodayo: Why would ghci be any different?
00:38:16 <kmc> Rodayo, your problem is an algorithmic problem, not an implementation problem
00:38:20 <Rodayo> shachaf, I figure it goes through some sort of optimization phase...
00:38:30 <kmc> fib 100 calls fib 99 and fib 98;  fib 99 calls fib 98 and fib 97
00:38:33 <kmc> fib 98 is computed twice
00:39:12 <kmc> code compiled with ghc -O2 will run much faster than code interpreted in ghci
00:39:17 <kmc> and yes ghc does do fancy optimizations
00:39:30 <shachaf> Automatic memoization is not one of those optimizations, though.
00:39:31 <kmc> but nothing which will fix this bad algorithm
00:39:55 <kmc> remembering all previous function results can save time at the expense of space
00:39:59 <Rodayo> kmc, so what would a faster implementation look like?
00:40:15 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   in fibs
00:40:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:40:25 <kmc> it's a data structure which refers back to itself
00:40:43 <kmc> rather than some function which calls itself repeatedly
00:41:13 <kmc> Rodayo, if you want your function to remember previous results, you can wrap it using http://hackage.haskell.org/package/data-memocombinators or http://hackage.haskell.org/package/MemoTrie
00:42:38 <kmc> it's a common myth that haskell compilers memoize all functions
00:42:47 <kmc> but in fact this would produce terrible performance
00:42:58 <ski> @tell c_wraith i can't make sense of that `orElse' example :/
00:42:58 <lambdabot> Consider it noted.
00:43:07 <kmc> most functions don't get called on the same argument many times
00:43:42 <kmc> even for the ones which do, it's often the case that traversing some big memo data structure will be slower than just recomputing it
00:43:57 <Rodayo> kmc, sorry I'm still trying to wrap my heda around all this. I haven't done haskell before
00:44:21 <kmc> that's ok
00:44:39 <kmc> have you used other programming languages?
00:44:50 <kmc> if you write an equivalent 'fib' in another language, it will have the same exponentially bad performance
00:45:16 <Rodayo> kmc, is that right?
00:45:24 <kmc> is what right?
00:45:36 <Rodayo> kmc, that other languages will also have poor performance
00:46:05 <kmc> that algorithm will take exponential time in any language i've ever used
00:46:14 <ski> if you write a bad algorithm, you can't in general expect the implementation to save you
00:46:28 <Rodayo> ski, fair enough
00:46:31 <kmc> of course the real-time performance depends on innumerable practical considerations
00:46:32 <ski> ("bad" here meaning "inefficient")
00:46:42 <Rodayo> it's just a random algo I thought might be a good practise
00:46:48 <kmc> it is good practice!
00:46:54 <kmc> it's one of the most common intro programming problems
00:47:29 <ski> the running time of `fib n', using that algorithm, is `O(phi^n)', with `phi' being `(1 + sqrt 5) / 2'
00:48:21 * ski idly wonders in which finite rings that makes sense
00:48:39 <kmc> Rodayo, the solution i gave (an infinite, self-referential list of fibonacci numbers) is a nice one in Haskell, because of  lazy evaluation
00:48:54 <kmc> but it's ugly in most other functional languages
00:49:38 <kmc> i can show you the solution which is more common in functional programming in general
00:49:57 <Rodayo> kmc, sure
00:50:05 <Rodayo> I'm still looking at your solution :p
00:50:44 <BMeph> > fst . unzip . iterate(\(a,b) -> (b,a+b)) $ (0,1)
00:50:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:51:06 * BMeph likes that one best...
00:52:34 <Rodayo> BMeph, wow
00:52:53 <Rodayo> On a first glance I would never guess thats the fibonacci sequence
00:53:13 <hpaste> kmc pasted “iterative fibonacci (for Rodayo)” at http://hpaste.org/55760
00:53:33 <kmc> Rodayo, this is how you might write it in a language without infinite data structures
00:54:01 <kmc> it's a simpler but more verbose solution, using only basic recursion and arithmetic operations
00:54:04 <copumpkin> you might as well have it spit out intermediate fibonacci numbers along the way
00:54:37 <Rodayo> kmc, that's an interesting one
00:55:07 <kmc> it's an 'iterative' solution because the helper function 'go' calls itself once only, and n counts down to 0
00:55:25 <Rodayo> kmc, I wrote a recursive solution C...calling fib(100) in that outputs the correct number in under a second. The haskell recursive solution takes much longer.
00:55:28 <kmc> while the other arguments do the required computation
00:56:01 <copumpkin> Rodayo: there are different kinds of recursive solutions
00:56:02 <kmc> Rodayo, are you compiling the Haskell code with ghc -O2
00:56:18 <copumpkin> Rodayo: if your fib 100 takes more than a second you're probably using the wrong one :P
00:56:19 <Rodayo> kmc, no still inside ghci
00:56:27 <kmc> ghci is slow
00:56:32 <copumpkin> it's not that slow
00:56:32 <kmc> and C will still beat Haskell often
00:56:33 <Rodayo> You expect them to have the same running time if I compile it?
00:56:42 <kmc> no
00:56:58 <Rodayo> kmc, well "closer" running times?
00:56:59 <kmc> but all of that is dwarfed by the fact that you're using an exponential-time algorithm
00:57:08 <kmc> yes I expect that the code will be faster if you compile it than not
00:58:02 <ski> kmc : s/go v 1 1/go v 0 1/
00:58:08 <Rodayo> alright, i'll see just how much faster it is
00:58:16 <kmc> ski, matching Rodayo's original, I think
00:58:48 <ski> nope
00:58:50 <kmc> Rodayo, if your algorithm takes 2^n steps, then using a language/compiler which is 1,000 times faster will allow an argument only 10 greater
00:58:53 <BMeph> Some...> (fst . unzip . iterate(\(a,b) -> (b,a+b)) $ (0,1))!!100
00:58:53 <BMeph>   354224848179261915075  (0.00 secs, 2643968 bytes)
00:59:19 <kmc> Rodayo, I don't see the point of comparing Haskell/GHC and C performance on a terribly inefficient algorithm
01:01:04 <Rodayo> kmc, okay, I'm still just wondering how your algo was faster. =P
01:01:10 <kmc> which one?
01:01:21 <Rodayo> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   in fibs
01:01:23 <kmc> do you understand why your original code takes exponential time
01:01:59 <Rodayo> kmc, not reallly =/
01:02:10 <shachaf> Rodayo: Did a naïve C program actually calculate fib(100) with your algorithm in under a second?
01:02:13 <kmc> do you believe me that it still takes exponential time in C
01:02:36 <Eduard_Munteanu> shachaf: it possibly didn't blow the stack by chance :/
01:02:45 <Rodayo> shachaf: yeh. might be a little bit faster with chaching
01:02:51 <ski> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in map fib [0 ..] :: [Expr]
01:02:52 <lambdabot>   [1,1,1 + 1,1 + 1 + 1,1 + 1 + 1 + (1 + 1),1 + 1 + 1 + (1 + 1) + (1 + 1 + 1),...
01:02:53 <shachaf> Rodayo: You added "caching"?
01:03:01 <kmc> Rodayo, draw a tree.  at the top you have fib(100).  fib(100) calls fib(99) and fib(98)
01:03:06 <Eduard_Munteanu> Ah, that's another thing then.
01:03:08 <ski> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 6 :: Expr
01:03:09 <lambdabot>   1 + 1 + 1 + (1 + 1) + (1 + 1 + 1) + (1 + 1 + 1 + (1 + 1))
01:03:12 <ski> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 7 :: Expr
01:03:12 <lambdabot>   1 + 1 + 1 + (1 + 1) + (1 + 1 + 1) + (1 + 1 + 1 + (1 + 1)) + (1 + 1 + 1 + (1...
01:03:16 <kmc> fib(99) calls fib(98) and fib(97)
01:03:36 <kmc> fuck it, someone must have already put this tree on the interwebs
01:03:55 <copumpkin> fibotree
01:03:59 <Rodayo> kmc, are you getting at how fib(98) got called twice there/
01:04:00 <copumpkin> fibonatree?
01:04:10 <kmc> Rodayo, yes
01:04:12 <kmc> Rodayo, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2
01:04:18 <kmc> by the way you should read this entire book
01:04:46 <Eduard_Munteanu> I guess by caching he means some explicit form of memoization.
01:04:55 <Eduard_Munteanu> (or analogue, whatever)
01:05:03 <Rodayo> kmc: ooo i get it now.
01:05:14 <Rodayo> Well I get why mine was so slow
01:05:18 <ski> (SICP to the rescue :D )
01:05:47 <Rodayo> shachaf: no but on the first run fib(35) computed in what seemed like under a second.
01:06:08 <kmc> exponentials:  they start small and get pretty big pretty quick
01:06:29 <kmc> didn't you ever play katamari damacy
01:06:34 <Eduard_Munteanu> Heh.
01:08:24 <Rodayo> kmc, so what made your implementation efficient?
01:08:44 <shachaf> Rodayo: It reused previous computations.
01:08:59 <kmc> it's an infinite list.  each element of the list is defined in terms of previous elements
01:09:02 <kmc> each element is computed only once
01:09:32 <kmc> data structures hold onto values
01:09:38 <kmc> this is a simplistic explanation but whatever
01:09:39 <Rodayo> tail [1,2,3,4,5]
01:09:47 <Rodayo> let a = tail [1,2,3,4,5]
01:10:02 <kmc> Rodayo, you may find it easier to understand the iterative-recursive solution in SICP or the one i hpasted, rather than the infinite list
01:10:02 <Rodayo> shouldn't that bot be doing something?
01:10:09 <kmc> > tail [1,2,3,4,5]
01:10:10 <lambdabot>   [2,3,4,5]
01:10:27 <Rodayo> lol i guess i don't have the credentials
01:10:43 <silver> > take 3 $ filter (odd) [1..]
01:10:44 <lambdabot>   [1,3,5]
01:11:01 <Rodayo> kmc, yeh i'm still reading the sicp thing and looking at your function. I was makign sure "tail" did what i thought it did
01:11:10 <kmc> Rodayo, you have to start the line with >
01:11:26 <silver> or @
01:11:48 <silver> @type concatMap
01:11:48 <kmc> it would be bad if lambdabot tried to interpret every line said in the channel as haskell code
01:11:49 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
01:12:36 <Rodayo> kmc, true
01:13:15 <kmc> > let fibtime n = φ^n  in  fibtime 100 / fibtime 35
01:13:16 <lambdabot>   3.838809989301099e13
01:13:53 <kmc> so if your C function for fib(35) took 1 second
01:13:59 <kmc> then fib(100) should take about 3.84 x 10^13 seconds
01:14:14 <kmc> which is 1,216,471 years
01:14:16 <Rodayo> it's cool how it supports unicode
01:14:30 <kmc> it's cool how it supports the languages spoken by the vast majority of the world?
01:14:46 <kmc> i guess that's "cool", i would call it "an essential feature of all software"
01:15:16 <kmc> but often lacking anyway
01:15:35 <Rodayo> kmc, i agree
01:15:44 <kmc> also @type doesn't :/
01:15:48 <Rodayo> well maybe not greek letters
01:15:48 <kmc> @type φ
01:15:49 <lambdabot> <no location info>: not an expression: `'
01:16:14 <Rodayo> kmc, aww that's strange =P
01:20:10 <Rodayo> I'm off for now. kmc, thanks for the insight =]
01:20:54 <ski> Rodayo : if you have access to "Haskell: The Craft of Functional Programming", i think it has a pretty picture of how this `fibs' solution acts in a pipe-line kind of way
01:21:01 <ski> eh
01:23:50 <kmc> i like the tree-recursive fibonacci because it computes its own time complexity :)
01:24:28 <shachaf> In that it sums the leaves, and the leaves are all 1?
01:24:57 <kmc> in that the number of steps taken to compute (fib n) is proportional to (fib n)
01:25:29 * ski . o O ( `data Fib n where Zero :: Fib Z; One :: Fib (S Z); Succ :: Fib n -> Fib (S n) -> Fib (S (S n))' )
01:25:55 <ski> (exercise : define addition and multiplication)
01:26:22 <Eduard_Munteanu> ski: how's that related to fib anymore?
01:26:45 <kmc> > let square n = length . concat $ replicate n (replicate n ())  in square 5
01:26:47 <lambdabot>   25
01:26:56 <ski> the number of constructors in `Fib n' is more or less `fib n'
01:27:38 <ski> (i suppose actually `fib (n+1)'
01:27:41 <ski> )
01:29:03 <ski> (also, check whether there's any connection to fibonacci heaps, via numeral representations)
01:29:29 <ski> (cf. Okasaki)
01:59:33 <The_Journey> how would I pattern match using a case...of expression in a main = ?
02:04:17 <aninhumer> The_Journey: how do you mean? something like main = case ... of ...?
02:04:44 <aninhumer> What do you want to pattern match?
02:05:01 <The_Journey> aninhumer: nvm, I figured it out, I was just being stupid >_>
02:06:11 * hackagebot zlib-conduit 0.0.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.0.0 (MichaelSnoyman)
02:06:13 * hackagebot filesystem-conduit 0.0.0 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.0.0 (MichaelSnoyman)
02:06:15 * hackagebot attoparsec-conduit 0.0.0 - Turn attoparsec parsers into sinks.  http://hackage.haskell.org/package/attoparsec-conduit-0.0.0 (MichaelSnoyman)
02:06:17 * hackagebot blaze-builder-conduit 0.0.0 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.0.0 (MichaelSnoyman)
02:06:19 * hackagebot conduit 0.0.0 - A pull-based approach to streaming data.  http://hackage.haskell.org/package/conduit-0.0.0 (MichaelSnoyman)
02:16:28 <mike-burns> Fine, fine, I'll read about conduit.
02:28:57 <bobry> Folks, is it possible to construct an infinite IO [a] value? something similar to `sequence $ repeat getLine`, but evaluated on demand? I've found a similar question on StackOverflow, but it just explains *why* sequence example doesn't work as expected.
02:30:11 <shachaf> bobry: See unsafeInterleaveIO.
02:30:25 <shachaf> bobry: However, there's a reason it's called "unsafe".
02:30:41 <shachaf> It means that you can make a thunk whose evaluation has side effects.
02:30:44 <shachaf> It's evil.
02:30:54 <bobry> Sure, so there's no 'right' way of achieving this, right?
02:31:31 <shachaf> Not really -- the issue is what you're trying to achieve, not how you're trying to achieve it. :-)
02:31:43 <shachaf> Well, it depends on what you're *actually* trying to achieve, of course.
02:31:53 <shachaf> Anyway lazy I/O, although it's evil, is very convenient.
02:32:06 <shachaf> Which is why functions like getContents and readFile in the standard library use it.
02:32:17 <mike-burns> (return [1..]) :: IO [a] -- this matches the type---is this what you mean?
02:32:59 <bobry> mike-burns: well, not really, there's no side effects in your example :)
02:33:22 <mike-burns> Do you mean [IO a] instead?
02:33:42 <duaneb> ok, can someone help me out with aeson/bytestring madness?
02:33:48 <bobry> shachaf: Thanks, actually, lazy I/O does sound like a bad idea (and an infinite source of bugs).
02:34:01 <mike-burns> duaneb: Maybe. I've been fighting that a ton myself.
02:34:03 <shachaf> mike-burns: I think bobry's example demonstrates what bobry meant. :-)
02:34:17 <shachaf> duaneb: Not if you don't say what the problem is.
02:34:36 <shachaf> bobry: I actually have a vague theory that lazy I/O can be made not evil.
02:34:50 <shachaf> This is perhaps more of a hope than a theory, since it's so nice when it works and all.
02:35:00 <shachaf> Anyway, /me >>= sleep
02:35:00 <duaneb> the program is here: https://gist.github.com/1523318
02:35:11 <duaneb> there are many problems with this program
02:35:43 <duaneb> ultimately, I want to know what I need to do to get `watch` to compile
02:35:48 <duaneb> I can take care of the JSON errors
02:35:57 <duaneb> it's the errors about bytestring I need help with
02:36:17 <duaneb> when I see:
02:36:18 <duaneb> Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
02:36:18 <duaneb>                 with actual type `ByteString'
02:36:18 <mike-burns> I tend to use BS.pack . I also tend to import ByteString qualified.
02:36:22 <duaneb> I want to run away screaming
02:36:42 <shachaf> duaneb: The former is a lazy ByteString, the latter is a strict ByteString.
02:36:52 <shachaf> duaneb: You should probably read a bit about how ByteStrings work before using them.
02:36:52 <mike-burns> That error is on line 72?
02:37:05 <duaneb> shachaf: I agree.
02:37:12 <duaneb> where would be a good place to start?
02:37:23 <duaneb> I just want to use what aeson uses internally
02:37:37 <duaneb> I don't particularly care at this point which one I want to use
02:37:58 <shachaf> Why do you even want to use ByteStrings?
02:38:08 <mike-burns> Because Aeson wants it.
02:38:25 <shachaf> It looks like Aeson is for parsing binary formats/protocols or something?
02:38:54 <shachaf> Maybe you should use a parsing library that's designed for text.
02:39:01 <duaneb> shachaf: I don't particularly care
02:39:16 <duaneb> I just want to use aeson, and I will jump through any type hoop to get to it
02:39:20 <mike-burns> shachaf: Can you recommend a better JSON library?
02:39:35 <duaneb> shachaf: aeson seems to be the best JSON library out there ATM
02:39:44 <shachaf> Wasn't there a port of Aeson to Text or something like that?
02:39:51 <shachaf> Wait, I'm confusing Aeson with Attoparsec. Never mind.
02:40:25 <shachaf> duaneb: If you wrote type signatures on all your functions it would be much easier to help you. :-)
02:40:40 <duaneb> shachaf: I would agree
02:41:05 <duaneb> however, it would help to know A) whether aeson uses lazy or strict bytestrings, and B) what that type signature is
02:41:28 <duaneb> should I just use the internal type?
02:41:35 <duaneb> that's my inclination
02:41:43 <shachaf> The "Internal" type is just reëxported from the non-Interal module.
02:41:45 <shachaf> They're the same type.
02:41:54 <mike-burns> `decode' takes a lazy ByteString.
02:41:57 <duaneb> then why am I getting a type error?
02:42:14 <shachaf> As for the other question, ghci is probably going to be better to ask than this channel. :-)
02:42:24 <HugoDaniel> hello
02:42:43 <mike-burns> You're passing a strict one. import qualified Data.ByteString.Lazy as LBS   and use LBS.pack .
02:43:07 <shachaf> "let links = (decode $ fromString json) :: Maybe Subreddit" -- what?
02:43:25 <shachaf> Wait, maybe I misread again.
02:43:33 <shachaf> At any rate you shouldn't shadow the name "links".
02:43:37 <shachaf> Where is "decode" coming from?
02:43:46 <mike-burns> decode is Aeson.
02:43:48 <duaneb> decode is coming from data.Aeson
02:44:02 <duaneb> and, frankly, I'm a noob at haskell
02:44:09 <duaneb> I do what I can to silence the type errors
02:44:09 <shachaf> It's not in my ghci when I import Data.Aeson...
02:44:10 <shachaf> Hmm.
02:44:13 <duaneb> I can't guarantee it's the best way
02:44:25 <duaneb> it's introduced in a recent version IIRC
02:44:28 <shachaf> It looks like you're just trying random combinations of functions until the type checker stops complaining.
02:44:32 <duaneb> I had to upgrade from 3.x to 5.0
02:44:34 <shachaf> Ah, OK.
02:44:47 <duaneb> shachaf: you bet I am
02:44:57 <duaneb> not random, but certainly arbitrary
02:44:59 <mike-burns> duaneb: http://goo.gl/a8QCd
02:45:19 <duaneb> mike-burns: much thanks.
02:45:54 <mike-burns> You might want that doHttp function, too, though I'm about to refactor it.
02:46:21 <mike-burns> The parseJson function in that code was written pre-`decode'; I'm about to figure out how to use `decode' instead.
02:47:40 <duaneb> mike-burns: decode :: FromJSON a => ByteString -> Maybe a, where FromJSON implements parseJson
02:47:45 <duaneb> so it's not that bad
02:48:11 <mike-burns> Yeah, though that loses the error message.
02:48:59 <mike-burns> The error message (line 45 of my code) has been cruicial in dealing with these inconsistent JSON documents.
02:49:28 * shachaf sleep
02:50:58 <ivanm> preflex: seen kfish
02:50:59 <preflex>  kfish was last seen on #haskell 7 days, 10 hours, 25 minutes and 28 seconds ago, saying: everybody's shaking in public
02:51:39 <ivanm> @ask kfish just to confirm: you're coming to LCA, right?  shall we publically (G+ and -cafe) ask around for interest in a Haskell BoF, maybe to work on vacuum?
02:51:39 <lambdabot> Consider it noted.
02:52:23 <duaneb> This string/text/bytestring nonesence makes me want to shoot haskell
02:52:26 <duaneb> I'm switching to python
02:52:28 <mike-burns> Yes.
02:54:02 <aninhumer> I found the only problem I've had is never being sure what "ByteString" means because there seem to be two
02:54:42 <mike-burns> I have that issue, and I also have the issue where lots of existing functions produce String but lots of new libraries want ByteString.
02:54:50 <mike-burns> So I'm converting, often.
02:55:16 <mike-burns> Oh, gotta run. Literally.
03:01:07 <Veinor> i've found that -XOverloadedStrings helps some
03:01:23 <Veinor> (and then import Data.Monoid and (<>) = mappend
03:05:47 <ivanm> Veinor: but you use the builders if you do lots of mappends, right?
03:07:23 <Veinor> well, sure
03:07:38 <Veinor> i'm just saying so you can do like "foo: " <> bs <> " baz"
03:11:16 * hackagebot zipper 0.4.1 - Generic zipper for families of recursive datatypes  http://hackage.haskell.org/package/zipper-0.4.1 (AndresLoeh)
03:13:45 <Veinor> are there any operations on bytestrings that force the entire bytestring and have asymptotically different performances for lazy/strict BSs?
03:19:36 <applicative> length is O 1  for strict bytestrings, O n
03:19:40 <applicative> for lazy
03:20:47 <Eduard_Munteanu> I guess 'length' needn't be O(n) for some streams, like files.
03:21:51 <applicative> or does ByteString carry length with it internally.  the definition is length (PS _ _ l) = assert (l >= 0) $ l
03:23:20 <applicative> whereas with lazy bytestrings, its like lists length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
03:23:47 <applicative> this isnt seeming like a good answer to Veinor 's question
03:24:08 <Veinor> I'm not sure what my question is any more.
03:24:53 <applicative> yeah, I wasn't clear, I thought I would give the length example, to see what you were thinking
04:01:21 * hackagebot data-structure-inferrer 1.0 - Program that infers the fastest data structure available for your program  http://hackage.haskell.org/package/data-structure-inferrer-1.0 (AleksanderBalicki)
04:01:33 <alistra> \o/
04:06:21 * hackagebot xournal-convert 0.1 - convert utility for xoj files  http://hackage.haskell.org/package/xournal-convert-0.1 (IanWooKim)
04:17:17 <rostayob> why is "newtype" necessary as a language feature? wouldn't it be the same to require implementations to treat all data declarations that look like newtypes like the contained type?
04:18:29 <Saizan> it changes the semantics of pattern matching
04:18:40 <rostayob> for those kind of data declarations, yes
04:19:04 <rostayob> well i see, you might not want that...
04:19:06 <rostayob> mhm
04:36:13 <wavewave> just uploaded a new package on hackage : xournal-convert
04:36:56 <wavewave> a utility to convert xoj files to other format : currently support for making SVG files and index.html so that we can see xournal file as web page
04:38:08 <jaspervdj> preflex: seen chrisdone
04:38:08 <preflex>  chrisdone was last seen on #haskell 1 day, 10 hours, 42 minutes and 43 seconds ago, saying: oh, that's c's way of returning a tuple
04:43:30 <hpc> rostayob: newtype is partially an optimization and partially what Saizan said
04:43:38 <hpc> rostayob: imagine the type
04:43:43 <hpc> data Void = Void Void
04:44:19 <hpc> you can pattern match on it over and over
04:45:11 <saati> couldn't data type and newtype merged into a single keyword with some smarter parsing?
04:45:32 <rostayob> hpc: you can do the same with newtype
04:45:38 <hpc> newtype Void = Void Void -- this has no defined value; pattern matching is a noop
04:45:48 <rostayob> hpc: why not?
04:45:51 <rostayob> foo = Void foo
04:46:03 <copumpkin> saati: no
04:46:06 <hpc> rostayob: indeed, but the constructors are eliminated at runtime
04:46:07 <copumpkin> they have different behavior
04:46:14 <hpc> rostayob: so at runtime, it's the same as foo = foo
04:46:30 <rostayob> hpc: ok, but you can still use it as 'data Void = Void Void'
04:46:35 <hpc> yeah
04:46:46 <rostayob> i understand the issue here
04:47:01 <rostayob> i was just thinking if newtype couldn't be included as an optimization of a special case of data
04:47:15 <rostayob> but yeah, it changes the semantics of pattern matching
04:50:18 <carpi> when i use the 'type' keyword so rename some types.. is it possible to create new values from them by using the new types as value constructors?
04:50:28 <rostayob> carpi: no
04:50:38 <hpc> carpi: no; type synonyms are about as binding as #defines
04:51:01 <carpi> hpc: so they can only be used in type signatures and nothing more? or can they be used anywhere else?
04:51:22 <hpc> they are just type aliases, nothing more
04:51:23 <hpc> yeah
04:51:27 <maurer> carpi: They can be used anywhere a normal type can be used...
04:51:42 <hpc> one of the first steps of compilation is converting aliases to the actual types
04:52:22 <rostayob> carpi: when defining a type synonym you're not creating any type constructor as you do with 'data' and 'newtype'
04:52:26 <rostayob> it's just an alias
04:52:55 <maurer> rostayob: Also, newtype has interesting semantics with some extensions, which allow you do do things like pull some of the typeclass information through the newtype, but not all of it
04:53:07 <maurer> (e.g. GeneralizedNewtypeDeriving)
04:53:10 <carpi> so they are just another name for types and nothing else changes.. and they have the ability to be used just like any other type. In summary is that corect?
04:53:19 <maurer> carpi: Yes.
04:53:39 <carpi> thanks for the clarification - )
04:54:15 <rostayob> maurer: well, but that (pulling most typeclasses out) can be done with that kind of 'data' as well, no?
04:54:16 <maurer> (an example of where you might want it would be if you were writing something inside a state monad, and were going to have a number of functions inside it, you might want to do
04:54:29 <maurer> type MyMon a = State MyStruct a
04:54:40 <maurer> rostayob: No, it can't.
04:54:51 <maurer> rostayob: It uses the limitation of newtypes that they have exactly one member
04:54:59 <rostayob> maurer: yeah that's what i mean
04:55:04 <rostayob> with "that kind of 'data'"
04:55:57 <maurer> rostayob: Technically possible, but I don't think the extension implements it, mostly because the accepted way of dropping typeclass definitions in the first place is via a newtype
04:56:18 <rostayob> maurer: yeah but that's not a limitation in the "newtype as a special case of data" picture :P
04:56:35 <rostayob> i'm designing a toy language and i was thinking of that
04:56:57 <maurer> rostayob: Sure. You could theoretically replace newtype with data everywhere, and detect and optimize out the pattern matching.
04:57:41 <maurer> rostayob: Personally, one of the things I like about newtype is that it gives documentation to the programmer that this is intended to be the same type underneath, but shouldn't match for purposes of abstraction, typeclassing, or something like that
04:57:50 <maurer> Whereas "data" is read as possibly meaning something
04:58:43 <rostayob> maurer: well as Saizan pointed out, you can't really do that while being consistent in your pattern-matching semantics
04:58:43 <maurer> (which I suppose is more of a documentation/sysntactic sugar purpose, but that's half of what a good programming language is about)
04:58:55 * maurer lastlog Saizan to find out what he said
04:59:02 <rostayob> since that special case of data would have unlifted semantics
04:59:27 <rostayob> while the rest of the cases wouldn't
04:59:33 <maurer> Oh, I suppose that would modify the laziness?
04:59:35 <rostayob> so it'd be annoying
04:59:37 <rostayob> yes
04:59:44 <rostayob> that is an effect of it
05:00:03 <maurer> rostayob: Out of curiosity, what is unique about the language you are designing?
05:00:22 <rostayob> maurer: nothing. it's really similar to haskell but with first class records
05:00:29 <rostayob> Kind ::= Type | Name
05:00:41 <rostayob> so you can pass around names and build records
05:00:59 <rostayob> but I'm doing it for kicks
05:01:13 <rostayob> i want to see how hard it is to write a compiler of this kind
05:01:27 <maurer> OK. I need to look into ML style records at some point - their "flex records" look interesting
05:01:46 <rostayob> well SML records are not that "flex" :P. OCaml has more interesting records
05:02:12 <rostayob> I'd like a really loose record subtyping
05:02:20 <rostayob> well loose
05:02:22 <rostayob> permissive
05:02:36 <mike-burns> liberated
05:02:47 <maurer> Honestly, as non-technical as it is, the thing I want most is the ability for multiple records to have the same goddamn field :(
05:02:56 <mike-burns> Yes.
05:03:05 <rostayob> maurer: yeah, that's why I have "named" types
05:03:16 <hpc> maurer: me too
05:03:18 <mike-burns> Apparently someone just has to do it.
05:03:23 <rostayob> so :k #foo : Name
05:03:26 <rostayob> and you can have
05:03:53 <maurer> rostayob: Call me ignorant, but how does having named kinds give you this?
05:04:11 <rostayob> class HasField a (t : Type) (f : Name) where; getField : a -> f -> t
05:04:21 <maurer> Oh, OK
05:04:37 <rostayob> now of course you can fiddle a lot with the scoping of the Names
05:04:40 <maurer> I totally misread what you meant earlier :)
05:04:44 <rostayob> but you get the idea
05:05:10 <maurer> rostayob: I assume you're still going to have things of kind Name be first class?
05:05:14 <maurer> So I can pass them into a function?
05:05:23 <rostayob> maurer: they're not values, they're types
05:05:57 <rostayob> so you'd have to call getField hinting that you want that Name
05:05:58 <maurer> rostayob: Your getField function looks an awful lot like they're values
05:05:58 <rostayob> with a type signature or something
05:06:05 <rostayob> maurer: yeah because I wrote it in haskell notation
05:06:17 <maurer> Oh. I would _like_ them to be values
05:06:24 <rostayob> you could
05:06:27 <Eduard_Munteanu> rostayob: what's a member of 'f'?
05:06:51 <rostayob> (undefined : #foo)
05:07:13 <rostayob> that type class is stupid, the idea is to have a syntax for records which is nice
05:07:29 <rostayob> but you could pass them around too yes
05:07:41 <rostayob> i mean you *can* pass the type aroun
05:07:42 <hpaste> maurer pasted “Sample Record Func” at http://hpaste.org/55761
05:07:43 <rostayob> d
05:07:56 <maurer> rostayob: ^ That is something I'd like to be able to do
05:08:01 <rostayob> maurer: you don't need to have any value
05:08:04 <rostayob> you just need the types
05:08:11 <rostayob> with an explicity type sig for blockSet
05:08:31 <maurer> I suppose since they are finitely enumerated you can embed it in the type system instead
05:08:49 <maurer> And then you might be able to statically verify the safety of using them
05:08:54 <rostayob> yeah definitely
05:09:00 <rostayob> also you get subtyping for free with this approach
05:09:08 <rostayob> i don't have a clear idea on how to do it nicely
05:09:35 <maurer> Yeah, I see the benefits of making them types instead
05:10:01 <rostayob> you might want a nicer syntax, like foo : [f : Name] -> HasRecord a t f -> (t -> t') -> a -> t'
05:10:19 <rostayob> where in the square brackets you can pass types of kind Name
05:10:32 <rostayob> so this is more explicity
05:10:35 <rostayob> *explicit
05:10:36 <maurer> Yeah, it gets a little System-Fish there
05:11:01 <rostayob> yeah i borrowed that from System-F :P
05:11:05 <maurer> But since inference isn't possible, it's quite understandable
05:11:37 <rostayob> anyway i think this is a relatively nice way of doing records
05:11:47 <rostayob> you can already do it in Haskell with empty data decls
05:11:54 <rostayob> you can define a module with common names to use
05:12:04 <rostayob> and then that typeclass
05:12:09 <rostayob> but it's ugly
05:13:49 <maurer> rostayob: As much as I hate to say it, I think Agda has the appropriate machinery for this :P
05:14:21 <rostayob> maurer: i remember reading "Agda" and "record" somewhere, but I can't find some nice docs for agda
05:14:35 <maurer> rostayob: I wasn't talking about record, I was talking about type-application
05:15:01 <rostayob> maurer: ah. well with agda you can do a lot more
05:15:06 <rostayob> as far as i understand
05:15:16 <rostayob> but the thing is that i don't want too much type level machinery
05:18:23 <maurer> rostayob: Sure, I was more suggesting if you were interested in looking at potential modern ways of doing type-level application
05:20:21 <rostayob> maurer: i'd really like to dig into agda but i'd really like a decent programming-oriented introduction to agda too
05:20:36 <rostayob> i tried a few days ago but I had problem with the emacs mode as well, so i gave up
05:20:54 <maurer> rostayob: Yeah, I think I'm going to follow the path of a friend of mine, treating it as a proof language, and then try to understand the programming from there
05:21:03 <maurer> I figure it will leave me less likely to be taking shortcuts
05:21:29 <rostayob> maurer: even that, is there a good introduction to agda as a theorem prover?
05:22:02 <rostayob> for a person with no background in the logic used by agda
05:22:58 <maurer> rostayob: I'll take a look. I was going to just try to mechanize all my proofs for a type theory course I took, and use that as my introduction
05:23:38 <maurer> e.g. I was going to start by attempting to prove that System-F terminates and the like
05:23:50 <rostayob> maurer: well that's not that easy is it?
05:24:00 <maurer> rostayob: Sure, but I already wrote the proof, just not in Agda
05:24:25 <rostayob> yeah but there are probably a lot more details in agda
05:24:27 <maurer> (and I'll probably start with some easier problems first)
05:24:36 <rostayob> if it was as easy as by hand it'd be awesome
05:24:41 <dropdrive> Are there examples of implementing a toy DSL in Haskell which then is turned into (human-readable) Java source code?
05:24:41 <maurer> Quite possibly, which is why it'll be a learning experience rather than following a recipie :P
05:24:59 <maurer> dropdrive: Not that I know of - what are you trying to make?
05:25:05 <rostayob> dropdrive: well that's a pretty specific example
05:25:21 <dropdrive> maurer: I'm just playing around with generating some code for Java and Python.
05:26:03 <maurer> dropdrive: I mean, you can probably just overload bind and use http://hackage.haskell.org/package/language-java
05:26:04 <rostayob> dropdrive: how are you generating the code? you might want to look for a package encoding and pretty printing Java's syntax
05:26:23 <dropdrive> maurer: The DSL I'm thinking of is really simple... e.g. strings, ints, and if statements
05:26:24 <rostayob> ok, maurer linked what i was talking about :)
05:26:35 <dropdrive> rostayob: I don't know yet how I'm generating the code.
05:26:49 <maurer> (If you're just targeting java for portability, there are some other packages that produce .class files directly!)
05:27:00 <maurer> (So you can get your compiler-geek on while you get your dsl on)
05:27:06 <rostayob> dropdrive: well at the high level you need a function of type 'DSL -> ComplilationUnit' - http://hackage.haskell.org/packages/archive/language-java/0.1.0/doc/html/Language-Java-Syntax.html
05:27:11 <rostayob> and then you're dong
05:27:14 <rostayob> *done
05:27:33 <rostayob> dong.
05:27:38 <maurer> rostayob: Depends on how he wants to do it. One way I've made a few things is to overload bind.
05:28:02 <maurer> And then there's still a function of type DSL->Compilation unit, but it ends up being the "easy" part
05:28:08 <dropdrive> rostayob: Cool, and so there's a way to convert from CompilationUnit to java source?
05:28:18 <rostayob> dropdrive: http://hackage.haskell.org/packages/archive/language-java/0.1.0/doc/html/Language-Java-Pretty.html
05:28:26 <maurer> dropdrive: Look at the pretty e:f;b
05:28:29 <lukish_> I'm trying to decompress gzipped response from curl. I've found some Codec.Compression.GZip functions and trying to use them.
05:28:32 <lukish_> (unpack . decompress . pack) link
05:28:45 <dropdrive> maurer: Thanks.
05:28:49 <rostayob> maurer: yeah, but i'd probably do the transformations the simple way
05:28:49 <lukish_> But I get this problem: Couldn't match expected type `ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString'
05:28:57 <dropdrive> rostayob: So is there something similar for Python too?
05:29:00 <lukish_> What am I doing wrong?
05:29:03 <rostayob> dropdrive: I'm not sure
05:29:12 <rostayob> lukish_: you've imported the wrong ByteString methods
05:29:27 <maurer> rostayob: I mean, the cool thing about doing it that way is that you write the bind, which lets you write the DSL in do notation, but it secretly just generates a data structure, which is then converted to code
05:29:28 <rostayob> change 'import Data.ByteString' to 'import Data.ByteString.Lazy'
05:29:38 <maurer> lukish_: There are two bytestrings, lazy and non-lazy
05:29:47 <dropdrive> maurer: Wait, which way are you talking about?
05:30:09 <rostayob> rostayob: lazy bytestrings are cool because they don't get loaded monolitically, but in fixed sized chunks
05:30:11 <lukish_> But I have Strings, not [Word8]
05:30:13 <lukish_>     Couldn't match expected type `GHC.Word.Word8'
05:30:13 <lukish_>                 with actual type `Char'
05:30:26 <maurer> lukish_: Use chr or ord, I forget which one
05:30:38 <rostayob> maurer: yeah i guess i see the advantages
05:30:45 <lukish_> :hoogle String -> [Word8]
05:30:47 <maurer> dropdrive: When I build DSLs, I usually write a Monad definition so that bind and return actually build a datastructure
05:30:54 <lukish_> @hoogle String -> [Word8]
05:30:54 <lambdabot> Control.Monad.Trans.Error listMsg :: ErrorList a => String -> [a]
05:30:55 <lambdabot> Prelude error :: [Char] -> a
05:30:55 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:30:58 <dropdrive> rostayob: Is it right to think of lazy bytestrings as [strict bytestrings] ?
05:31:00 <maurer> dropdrive: Then I convert the resulting datastructure to the target language
05:31:16 <dropdrive> maurer: I see.  Any good (simple) examples?
05:31:19 <lukish_> maurer: fow what?
05:31:21 <lukish_> for*
05:31:26 <rostayob> dropdrive: well
05:31:28 <rostayob> in a way
05:31:37 <maurer> dropdrive: It is somewhat limiting though (e.g. if you use an if branch you're screwed)
05:32:03 <dropdrive> maurer: Why is that?  You can't use a fake "if" function?
05:32:08 <maurer> On my other machine which is back in Pittsburgh :(
05:32:20 <maurer> dropdrive: Yes, you can use a fake if and you're fine
05:32:22 <maurer> but if you do
05:32:28 <maurer> if foo then bar else baz
05:32:35 <maurer> in native haskell, where bar and baz are both in the monad
05:32:42 <maurer> The result ends up not being very happy
05:32:46 <rostayob> lukish_: all you need to do is to import the lazy bytestrings methods. the types have the same names but they're different
05:32:51 <rostayob> you're using the strict pack and unpack
05:32:58 <rostayob> but decompress works with lazy bytestrings
05:33:08 <dropdrive> maurer: I see.
05:33:19 <maurer> dropdrive: It is probably overkill for what you're doing
05:33:19 <dropdrive> rostayob: So in what way is lazy bytestring not really [strict bytestring] ?
05:33:27 <lukish_> @hoogle decompress
05:33:27 <lambdabot> Codec.Compression.Zlib.Raw decompress :: ByteString -> ByteString
05:33:28 <lambdabot> Codec.Compression.GZip decompress :: ByteString -> ByteString
05:33:28 <lambdabot> Codec.Compression.Zlib decompress :: ByteString -> ByteString
05:33:31 <maurer> dropdrive: I was using it to try to do a half-assed mapreduce
05:33:40 <lukish_> But I have String response
05:33:42 <rostayob> dropdrive: well, the interface is exactly the same as a single bytestring
05:33:49 <rostayob> the lazy loading is not in your control
05:33:51 <maurer> lukish_: What curl library are you using?
05:33:57 <rostayob> and it's at a lower level anyway
05:34:02 <maurer> lukish_: String is not a very good thing to be using for network IO
05:34:09 <lukish_> Network.Curl
05:34:31 <lukish_> @hoogle curlGetString
05:34:31 <lambdabot> No results found
05:34:46 <maurer> From the documentation:
05:34:48 <maurer> "The CurlBuffer class encodes the representation of response buffers, allowing you to provide your own app-specific buffer reps to be used..or use one of the standard instances (String and ByteStrings.) "
05:35:03 <maurer> It knows how to use ByteStrings, I suggest they be used >_>
05:35:25 <lukish_> maurer: give me the link please
05:35:32 <maurer> http://hackage.haskell.org/packages/archive/curl/1.3.7/doc/html/Network-Curl.html
05:37:34 <maurer> lukish_: Basically, see where there's the "CurlResponse" type and it's an alias for CurlResponse_ [(String, String)] String
05:37:38 <maurer> You want to use
05:38:02 <maurer> CurlResponse_ [(String, String)] ByteString
05:38:38 <maurer> (String is not an OK output buffer for binary data, so if the server's sending you gzipped stuff, you may suffer errors if you try to hold it in a string)
05:38:48 <maurer> (as you will receive things that are not valid characters)
05:40:12 <lukish_> I don't get it how can I use CurlResponse_ [(String,String)] ByteString
05:41:20 <maurer> There are two ways, depending on what you want
05:41:24 <maurer> If you just want the body, use
05:41:27 <maurer> curlGetString_
05:41:37 <maurer> If you want it to parse the headers for you, use
05:41:38 <maurer> curlGetResponse_
05:42:52 <maurer> And specify hdr however you like, and ty should be ByteString
05:50:24 <lukish_> curlGetString_ link [] >>= return . snd \\\\ After that I get ":: (CurlBuffer a) => IO a" value, right?
05:52:02 <lukish_> Where is the place for decompress and ByteString here?
06:09:37 <JuanDaugherty> .oO(mental note: if you're not fine, don't use a fake if)
06:39:17 <maurer> Hey, when trying to build a package with cabal, I found that making the requirements for the build _more_ restrictive caused the build to succeed
06:39:27 <maurer> This doesn't seem like it should be the case
06:40:18 <maurer> (specifically, I bumped the minimum version on one of the packages it depended on)
06:41:54 <donri> maurer: why is this surprising?
06:41:55 <lambdabot> donri: You have 1 new message. '/msg lambdabot @messages' to read it.
06:42:21 <tgeeky> lambdabot: You have 1 new message.
06:42:21 <maurer> donri: This means that the dependency plan was available to it before, but it didn't select it
06:42:40 <maurer> donri: (Just realized that I left out that the build _failed_ before I made it more restrictive)
06:43:01 <donri> maybe because it used the older version of the dependency which was incompatible?
06:43:16 <dgpratt> I was just looking over the source code for Data.Map and I'm noticing several constructions like this: STRICT_1_OF_3(go)
06:43:26 <dgpratt> what are they for?
06:43:29 <maurer> donri: Sure, but shouldn't it have said "Oh, I will try a newer version since the older version doesn't work"
06:43:42 <donri> don't think cabal does that
06:43:58 <donri> it trusts your version requirements
06:44:10 <donri> thus http://www.haskell.org/haskellwiki/Package_versioning_policy
06:44:29 <maurer> donri: It's not a problem with the package's versions, it's a problem with the rest of the system (which the package shouldn't be thinking about)
06:44:38 <maurer> In this case, the package requires syb >= 0.3
06:44:46 <maurer> syb 0.3.2 Cannot be built on my system
06:44:49 <maurer> But 0.3.3 can
06:45:13 <maurer> It should select the one that can be built, as the package is not lying about its dependencies, it's just that one way to satisfy them can't be built on my system
06:45:18 <donri> maurer: maybe try cabal-dev to isolate the build environment
06:45:45 <maurer> donri: Won't help, the issue is that syb-0.3.2 can't build against the current base
06:45:57 <donri> ok
06:46:26 <maurer> I mean, I've solved it fore me, but it seems that cabal should, if it encounters an inability to fulfill dependencies, backtrack and try a different way to fulfill them
06:46:33 <Saizan> maurer: the dependency solver in cabal-install is not complete
06:46:42 <maurer> :(
06:47:23 <maurer> Saizan: Is there any reason it can't have a --apply-brute-force-and-solve-this flag?
06:50:28 <Saizan> maurer: none that i'm aware of
06:50:44 <Phyx-> free time?
06:51:10 <lukish_> curlGetString_ link [] >>= return . snd \\\\ After that I get ":: (CurlBuffer a) => IO a" value, right?
06:51:13 <lukish_> Where is the place for decompress and ByteString here?
06:52:25 <Saizan> aside from performance, it's harder to provide good diagnostics with backtracking, also given incorrect .cabal files there are lots of "correct" solutions that don't actually work, but those are secondary problems i guess
06:53:24 <Saizan> lukish_: have you looked at the instances of CurlBuffer?
06:54:23 <Saizan> given how the solver is implemented it should be pretty easy to provide a backtracking option
06:56:37 <morel> Do I obligatorily have to use Glade for Gtk2Hs? (I'm new to GUI-programming and want to write a GUI-application using GTK in Haskell.)
06:57:34 <ksion> A quick & basic question: Is there a clean way to combine functions f (a->a->b) and g (c->a) so that result h is:     h x y = f (g x) (g y)   ?
06:57:39 <Patinho`Busy> o/
06:57:52 <donri> morel: no
06:58:04 <morel> donri: cool. what's the alternative?
06:58:09 <opqdonut> ksion: the function "on"
06:58:16 <donri> morel: set it up in code yourself
06:58:21 <opqdonut> :t Data.Function.on
06:58:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:59:08 <morel> donri: hm. okay... thanks so far =)
06:59:36 <ksion> opqdonut: Exactly; Hackage even gives usage which is very similar to mine. Thanks :)
07:04:40 <hpaste> Gavri pasted “From learnyouahaskell.com” at http://hpaste.org/55764
07:05:08 <gavri> could someone explain how shortLinesOnly manages to wait for user input?
07:05:24 <gavri> it works on each individual line
07:05:31 <gavri> before moving on to the next
07:05:59 <gavri> but treats it the entire potential list of lines as one input parameter
07:06:12 <gavri> I guess I'm asking how laziness works in haskell
07:06:30 <timemage> gavri, have you ever used a proxy design pattern in an OO language?
07:06:36 * hackagebot pqc 0.4 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.4 (KidoTakahiro)
07:06:40 <gavri> timemage: yeah
07:06:51 <timemage> gavri, well, it's kind of like a really fine grained proxy pattern.
07:07:52 <timemage> gavri, when you getContents you're really getting a proxy, and that can happen per character.  so the characetrs are being read on demand as they're being consumed by the line split (lines) function.
07:08:09 <timemage> gavri, well, actually it goes further than that.
07:08:24 <gavri> but then shortLinesOnly actually seems to wait for user input
07:09:44 <timemage> gavri, well think of the program as doing nothing putil putStr.  everything before that is just building up a structure in memory.
07:10:12 <timemage> gavri, when putStr runs it tries to get the return value of shortlines it was promised.
07:10:39 <timemage> gavri, when short lines runs it tries to get the input it was promised.  when input runs it reads the file contents it was promised.
07:10:54 <timemage> gavri, does that make any sense?
07:11:55 <gavri> timemage: it does, but I also start getting output as soon as a line is input. which is what is really freaky
07:12:11 <gavri> freaky in a good way, I mean
07:12:14 <timemage> gavri, uhh, well typical terminals are line buffered.
07:12:45 <timemage> gavri, and the lines function in shortLinesOnly   only needs to get to the first \n before it can present the first bit of output to putStr
07:13:06 <gavri> and then it waits for the second line?
07:13:27 <timemage> gavri, in a manner of speaking, yeah.
07:13:53 <gavri> it makes more sense now. thanks
07:13:57 <timemage> gavri, it's like if you were getting widgets off an assembly line and packing them in boxes.  you're not going to put a box on the truck until the box is full
07:14:17 <timemage> putStr won't print a line to the screen until it has a \n
07:14:29 <gavri> do you know of any docs online about how laziness in haskell works?
07:14:36 <timemage> lines won't  split a line until it sees a \n
07:14:50 <timemage> and getcontent won't get one until the terminal gives it one.
07:15:24 <timemage> gavri, i'm kind of out of touch with it.  not even really a good haskell coder.  wikipedia has articles on the different kinds of evaluation though.
07:15:48 <hpaste> Patinho`Busy pasted “all function ... and none? [Beginner problem]” at http://hpaste.org/55765
07:15:51 <Patinho`Busy> I need some litle help pls.. anyone?
07:15:52 <gavri> timemage: thanks a lot. your explanation helped
07:15:52 <timemage> gavri, https://en.wikipedia.org/wiki/Lazy_evaluation  and so on.
07:15:56 <gavri> thanks
07:16:04 <Eduard_Munteanu> timemage: that's just buffering, not laziness
07:16:28 <Eduard_Munteanu> I mean, putStr / hGetContents etc.
07:16:36 * hackagebot ReadArgs 1.0 - Simple command line argument parsing  http://hackage.haskell.org/package/ReadArgs-1.0 (NoahEasterly)
07:17:25 <timemage> Eduard_Munteanu, if there wasn't any laziness involved here putStr wouldn't print anything until lines/unlines was done, right?
07:19:24 <Eduard_Munteanu> timemage: lines/unlines work lazily as well
07:19:42 <Eduard_Munteanu> It depends how much of the result you want to print.
07:20:20 <Eduard_Munteanu> @src lines
07:20:20 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:20:29 <Eduard_Munteanu> @src unlines
07:20:29 <lambdabot> unlines = concatMap (++ "\n")
07:20:38 <timemage> Eduard_Munteanu, you may want to direct this at gavri
07:21:37 <Eduard_Munteanu> gavri: anyway, the idea is standard input/output are line-buffered by default
07:21:54 <Eduard_Munteanu> @hoogle hSetBuffering
07:21:54 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
07:21:54 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
07:23:14 <alistra> > fix (1+)
07:23:18 <lambdabot>   mueval-core: Time limit exceeded
07:23:26 <alistra> > 6 > fix (1+)
07:23:30 <lambdabot>   mueval-core: Time limit exceeded
07:23:50 <alistra> no RULES :|
07:25:33 <Eduard_Munteanu> alistra: I don't think that's about RULES, rather the strictness of integers
07:26:20 <alistra> well if those were nats you could maybe do something about it
07:26:22 <alistra> :P
07:59:35 <lukish_> Saizan: yes I have
08:00:16 <lukish_> But, anyway I don't understad how can I get curl response of ByteStrings
08:01:36 <hpaste> mike-burns pasted “data type with deriving” at http://hpaste.org/55768
08:01:55 <mike-burns> The above-pasted code runs fine but Haddock seems to hate it.
08:02:09 <mike-burns> What is the proper layout/indentation for a `deriving'?
08:12:22 <mike-burns> Oh, it's an issue with the doc comment on the prior line.
08:13:25 <morel> donri: do you know a tutorial/howto for GTK?
08:15:28 <donri> morel: the gtk and gtk2hs websites? :P
08:21:10 <morel> donri: well, yes, there's an howto on http://projects.haskell.org/gtk2hs/docs/tutorial/glade/ but i think/afaik that howto uses a glade-version which doesn't export to gtkbuilder-format rather, it exports the GUI to the deprecated/old libglade-format.
08:21:19 <morel> doesn't it?
08:21:33 <mike-burns> gtk2hs doesn't support GTK3.
08:21:42 <morel> oh.
08:21:43 <donri> builder isn't new in gtk3 though
08:21:55 <morel> actually, best i'd like to not use glade, though…
08:22:44 <morel> i somehow need a general introduction or so
08:23:15 <mike-burns> Sadly you are expected to learn GTK programming in another language first. At least, that's my understanding of it.
08:23:59 <donri> morel: http://code.haskell.org/gtk2hs/gtk/demo/gtkbuilder/
08:26:50 * hackagebot github 0.1 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.1 (MikeBurns)
08:28:06 <morel> donri: yep. i know that one. and i also tried it before but i got an error while compiling it. that was the reason why i supposed that this howto uses an old version of glade which exports GUIs to the libglade-format, and not to gtkbuilder-format; doesn't it?  anyway, i'll try that howto once more.
08:28:24 <JuanDaugherty> mike burns, you are expecting GTK to support haskell as a primary lang?
08:28:37 <mike-burns> Me? No way.
08:28:43 <donri> morel: the one i linked uses the new builder
08:28:55 <morel> donri: hm.
08:29:06 <monochrom> I offer to teach you C if you don't already know C.
08:29:25 * morel does know c.
08:30:14 <morel> donri: okay. thank you. i'll try that tutorial again…
08:30:52 <JuanDaugherty> who doesn't know C? Maybe that guy who came here once bragging that he never programmed or maybe even used a computer, ensconsed in his tower as a pure mathematician
08:31:02 <silver> on a side note, GTK is like language on itself, it have custom run time type-system
08:31:05 <hpc> mike-burns: i think it's entirely possible to learn to program in GTK from haskell; it's a very different kind of style from how you would do it in C, and the ease of navigating hackage docs makes it easier
08:31:40 <ben> easier than what
08:31:50 * hackagebot github 0.1.1 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.1.1 (MikeBurns)
08:31:50 <ben> the gtk docs for other languages are usually very good
08:32:10 <mike-burns> The GTK3 docs are all around bad.
08:32:39 <Silvah> Any ways to improve http://hpaste.org/steps/55769 ? Apart from the fact that it's reinventing the wheel, I know it is, I'm trying to recall myself how to write Haskell by implementing some well-known algorithms in it.
08:36:50 * hackagebot xournal-convert 0.1.0 - convert utility for xoj files  http://hackage.haskell.org/package/xournal-convert-0.1.0 (IanWooKim)
08:38:50 <Silvah> Er, that code was buggy. Fixed it.
08:41:53 <c_wraith> Silvah: where's the fix?
08:41:53 <lambdabot> c_wraith: You have 1 new message. '/msg lambdabot @messages' to read it.
08:42:09 <Silvah> http://hpaste.org/55771
08:43:17 <c_wraith> Silvah: use a bottom-up merge, instead of top-down
08:43:39 <yitz> Silvah: looks fine to me. except it's very unstable, you swap elements whenever equal.
08:43:39 <c_wraith> it's much simpler code
08:44:49 <yitz> c_wraith: it's not *that* much simpler. years ago it was profiled as being faster. don't know if anyone has retested that recently.
08:44:53 <c_wraith> split looks really inefficient, in a way that wouldn't be if you switched to bottom-up merging
08:45:06 <c_wraith> yitz: it'd get rid of the entire split function
08:45:38 <yitz> c_wraith: instead you split the whole thing first. not that different.
08:46:07 <c_wraith> which is a huge gain compared to that split function
08:46:11 <c_wraith> it traverses the list twice
08:46:17 <yitz> not huge. a gain.
08:46:27 <Silvah> yitz: oh yeah, I screwed up stability.
08:46:31 <c_wraith> admittedly, it'd be a much smaller gain compared to a split function that didn't traverse the list twice
08:47:30 <Silvah> The stability problem is easy to fix, though.
08:47:52 <c_wraith> also, at the very least, make split traverse its argument only once. :)
08:48:09 <yitz> c_wraith: this isn't 1960's assembler. that "traverses the list twice" is really just that he's doing an extra test for null list. actually maybe even two extra tests. could be improved, but those don't cost very much.
08:48:42 <c_wraith> yitz: what are you reading?  split calls split1 and split2.  each traverse the whole list
08:48:55 <yitz> c_wraith: this is haskell. it's lazy.
08:49:04 <c_wraith> that's... irrelevant
08:49:30 <c_wraith> they are separate computations that share nothing.
08:49:33 <Silvah> c_wraith: I won't be using this in production code, so efficiency is not so much of a concern.
08:49:34 <yitz> c_wraith: nope. you have a thunk. split1 and split2 each pop off an element. then you move on.
08:50:21 <yitz> Silvah: right, understood. actually, it would be fine in almost any production code. the chances of that being your bottleneck and worthy of your optimization effort are near zero.
08:51:57 <Silvah> yitz: chances of any Haskell code being a bottleneck are exactly zero, in my case. If something is a real bottleneck, then that's what C is made for.
08:52:03 <yitz> Silvah: heh
08:52:44 <yitz> Silvah: not really, though. if your haskell code is too slow, often a small tweak will fix that. you rarely need to rewrite it in C.
08:53:44 <yitz> Silvah: if you need to get down to shootout-style hacking, though, then right, you might be better off just rewriting some inner loop in C.
08:54:22 <Silvah> yitz: yeah, but my Haskell code is never too slow. You know, I'm not using Haskell if performance matters.
08:55:54 <yitz> Silvah: i'm in the middle of a large commercial project in haskell. performance does matter somewhat - we're a kind of image recognition on 100's of thousands of pages. haskell's great for it.
08:55:59 <c_wraith> ugh.  I was going to just do a quick benchmark, but it seems that criterion is not installed.  and compiling the statistics package takes years
08:56:08 <yitz> we're *doing*
08:56:35 <Silvah> yitz: yeah, okay, note that I'm talking about *my* code ;)
08:56:44 <yitz> c_wraith: really? why does it take so long?
08:57:28 <c_wraith> yitz: incredible amounts of inlining.  related to the reason #5539 showed up in ghc 7.4
08:57:34 <yitz> ahhh
08:57:50 <yitz> they've really got to fix that
08:58:06 <yitz> inlining libraries is very important. it's got to work.
08:58:52 <c_wraith> well, it was changed to a warning, but it sounds like it's a warning that your performance is going to be awful
08:59:18 <Silvah> yitz: and I'm not writing any "real" thing in Haskell ATM.
08:59:36 <Silvah> And dunno if I ever will.
09:00:41 <yitz> warning: you are in deep trouble
09:01:29 <Silvah> c_wraith: what warning?
09:01:46 <c_wraith> Silvah: something new in 7.4, regarding simplifier tick exhaustion
09:03:48 <Silvah> Simplifier tick?
09:04:36 <Silvah> Do they put a constraint on how many simplifications can be made?
09:04:42 <c_wraith> yes
09:06:49 <Silvah> That's... unusual.
09:08:45 <Silvah> Okay, I've made 'split' traverse the list only once: http://hpaste.org/55773
09:09:13 <c_wraith> yeah, turns out I was totally wrong about that.  criterion reports it's slower. :)
09:09:54 <Silvah> Could you post the results?
09:10:12 <c_wraith> sure
09:11:24 <hpaste> c_wraith pasted “split timings” at http://hpaste.org/55774
09:12:22 <c_wraith> that shows about 20% slower, actually
09:12:40 <Saizan> nf won't consume the lists like merge does though
09:12:54 <c_wraith> well, that's true
09:13:58 <Saizan> nf . uncurry zip
09:17:59 <c_wraith> that was surprisingly hard to change correctly
09:18:29 <c_wraith> about the same absolute difference in performance
09:18:40 <c_wraith> zipping each just added constant overhead
09:21:35 <hpaste> lukish pasted “json-like response” at http://hpaste.org/55775
09:21:48 <lukish_> How can I get some value from it?
09:22:21 <c_wraith> it already is a value.  If you want a better answer, tell us more specifically what you want
09:22:38 <lukish_> I want to parse it and get some json value
09:22:50 <c_wraith> in particular, it's a lazy bytestring
09:23:17 <c_wraith> so...  run it through a json parser.
09:23:26 <c_wraith> the newest version of aeson is pretty good
09:24:07 <c_wraith> the decode function even takes a lazy bytestring
09:25:42 <ben> What's the FFI type to use for the C type off_t?
09:29:30 <lukish_> Is there some directive like {# #} analog of -XFlexibleContexts
09:29:31 <lukish_> ?
09:29:45 <rwbarton> {-# LANGUAGE FlexibleContexts #-}
09:29:49 <parcs`> ben: CUInt is probably your best bet
09:29:55 <rwbarton> at the top of your file, that works for any -X flag
09:30:10 <lukish_> Great
09:30:37 <ben> parcs`: actually so far I found out that off_t is a signed 64bit type so maybe not
09:31:18 <hpaste> morel pasted “gtk2hs” at http://hpaste.org/55776
09:31:25 <morel> donri: donri: i did exactly what the howto on http://projects.haskell.org/gtk2hs/docs/tutorial/glade/ says, but it doesnt work! :(  i get following this error: http://hpaste.org/55776
09:32:12 <naromainos> I've got a question about "kinds". Image I have a datatype "data T a b = T (a b)", and i asked the kind for it (":k T") i get "(* -> *) -> * -> *", but i fail to see where this  comes from?
09:32:18 <morel> s/donri://; s/following //
09:34:57 <hpc> naromainos: (T a b) is of kind *
09:35:08 <hpc> naromainos: so the kind of T is (k a) -> (k b) -> *
09:35:36 <hpc> a is of kind (k b) -> *
09:36:05 <hpc> because T :: (a b) -> T a b
09:36:27 <hpc> b is of kind *, because there's no need for it to be anything more complex
09:37:26 <ben> Should I represent void* as polymorphic Ptr a or as Ptr ()?
09:37:43 <Silvah> ben: it depends.
09:38:03 <Silvah> What are you trying to achieve?
09:38:09 <ben> I'm ffi-importing mmap and I'm not sure just how I'm gonna use it yet
09:38:09 <hpc> you could represent it as Ptr Word8
09:38:11 <hpc> perhaps
09:38:13 <naromainos> hpc: thanks, this makes sense :)
09:38:41 <ben> Ultimately I'll need to read a whole bunch of either Word32s or Word8s from it representing rgba channels
09:38:52 <Silvah> hpc: yeah, this makes sense. For mmap.
09:39:19 <ben> ok
09:39:25 <rwbarton> the mmap package returns a Ptr a, which makes sense to me
09:39:50 <ben> oh, maybe i could crib from them
09:40:05 <ben> oh, they have their own c-side wrapper
09:40:45 <bgamari> Anyone know of a data structure like [] that gives me O(1) length?
09:40:58 <hpc> bgamari: an augmented list
09:40:59 <EvanR-work> no
09:41:01 <bgamari> Data.Set doesn't work since it doesn't permit multiple membership
09:41:14 <EvanR-work> Data.Sequence is logirthmic
09:41:17 <bgamari> hpc: I guess this didn't make it into containers?
09:41:20 <EvanR-work> logarithmic
09:41:28 <hpc> data ListL a = Nil Int | Cons Int a (ListL a)
09:41:30 <Silvah> System.Posix.* provides no mmap?
09:41:30 <rwbarton> Data.Sequence length is O(1)
09:41:36 <rwbarton> so you can use that
09:41:42 <ben> Silvah: apparently not
09:41:43 <hpc> ah, Sequence works too
09:42:00 <bgamari> EvanR-work: Alright, perhaps Sequence is the solution
09:42:12 <EvanR-work> oh right, length
09:42:28 <bgamari> Thanks all!
09:42:33 <Silvah> ben: poor *nixers, then. System.Win32.* does provide its equivalents.
09:42:48 <ben> Maybe I should just rearrange my stuff to do file io
09:46:28 <Algorith> 2
10:05:49 <ben> If I run a foreignPtr's finalizers with finalizeForeignPtr, will they be run again when I stop refering to the foreignptr?
10:17:25 <yitz> ben: that wouldn't be very good, would it. in fact, perhaps that even GC's it and you shouldn't use anymore. not sure.
10:18:07 <ben> foreignptrs are rather scary anyway
10:18:15 <hpc> on matters of FFI, i take the stance of "if you have to ask, do something else"
10:19:55 <ben> this whole C-style programming is rather distracting me with worries where all the resources are getting cleaned up
10:22:38 <yitz> ben: it's pretty clear from the haddocks for Foreign.ForeignPtr that once the finalizer is run you should assume that the ptr is toast
10:23:08 <ben> well now I'm worried when I'll get around to cleaning up the finalizer
10:23:11 <ben> this won't end well
10:23:39 <yitz> ben: e.g., look at the explanation of withForeignPtr. it says the reason you shouldn't touch the pointer outside the bracket is that the finalizer might have been run.
10:23:45 <ddarius> Open Office is such a pile of crap.
10:24:03 <yitz> ddarius: you think so? try libreoffice
10:25:16 <tech2> Office software is a pile of crap... thus ends the lesson.
10:25:23 <ddarius> yitz: Try type "tHERE " in Open Office (minus the quotes.)  Then close it and see how long it takes you to realize what's wrong.
10:26:01 <yitz> ddarius: that's an interesting kind of easter egg
10:27:17 <yitz> tech2: right. yet so much work gets done with it in the world. by millions and millions of people who you'll never, ever get to use vim or emacs.
10:27:47 <yitz> tech2: of course in hindsight it could have been done so much better.
10:27:53 <companion_cube> ç
10:27:53 <tech2> My biggest bug-bear atm is Excel, it frustrates me that so much business data is locked up in those godawful files.
10:27:55 <companion_cube> oops
10:28:23 <yitz> companion_cube: ça marche
10:28:41 <companion_cube> small shortcut problem :)
10:28:46 <ddarius> At least in a Microsoft environment, getting data out of Excel is pretty easy.  With the new format, it's... possible...
10:29:07 <ben> so finalizers are funptrs. funptrs are made with  foreign import ccall "wrapper" ? How does that not just import a random C function called wrapper?
10:29:28 <yitz> ddarius: it's possible in ods too
10:30:40 <ddarius> yitz: I didn't word my sentence appropriately.  What I meant is, outside of a Microsoft environment it's possible to get at the data in an Excel file with the new format technically without having to know implementation details of Excel.
10:31:41 <yitz> anyway, i usually just locally translate stuff back and forth from csv when i'm working with people who use spreadsheets. delay text formatting to the last possible moment.
10:31:49 <ddarius> But yeah, I was going to say, I don't think it is any easier to get data out of an oocalc file without Open Office tools.
10:31:57 <ddarius> yitz: Indeed.
10:32:01 <yitz> ddarius: ah. also true.
10:32:39 <yitz> ddarius: i've tried unzipping them and trying to do stuff with the data directly. not fun.
10:32:54 <ddarius> That's what I meant about the new format.
10:33:04 <ddarius> Technically it's all documented.  It's just extremely convoluted.
10:33:37 <Eduard_Munteanu> You're probably asking for an independent library that groks that data, I suppose.
10:34:02 <Eduard_Munteanu> As far as Unix philosophy goes, not a bad idea.
10:34:10 <tech2> anything has got to be better than the mess that was the earlier MS binary format which was the equivalent of a memory dump in some cases.
10:34:14 * ddarius works in a Microsoft environment and otherwise doesn't deal with Excel at all, so I'm not asking for anything.
10:34:24 <yitz> Eduard_Munteanu: mm, a haskell library and a convenient command line utility. ah. what a dreadm.
10:34:27 <yitz> dream
10:34:34 <ddarius> tech2: It is better.  It's just extremely non-trivial.
10:34:52 <tech2> agreed, it's been a few years since I've had to pull an OOCalc file apart.
10:35:10 <yitz> tech2: it's better. much better. much much better. and that's *still* not saying much.
10:35:26 <Eduard_Munteanu> yitz, ddarius: nah, I meant maybe OO/LO should be frontends to such libs, rather than trying to make a totally unrelated lib that understands that format
10:36:12 <yitz> Eduard_Munteanu: there's too much stuff in there that's tied directly to gui behavior.
10:36:29 <Eduard_Munteanu> There's the problem :)
10:36:54 * hackagebot persistent 0.6.4.4 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.4.4 (MichaelSnoyman)
10:37:01 <tech2> While we're at it, how about we redefine how software is written world-wide and disallow bad practises? ;)
10:37:11 <yitz> wysiwyg. how ironic.
10:37:33 <yitz> tech2: yay! good suggesion.
10:37:40 * ddarius would just be happy if Oracle and IBM were made to be not allowed to write user interfaces.
10:38:01 <companion_cube> or if Oracle wasn't allowed to write code at all
10:38:12 <companion_cube> they're a lawyer company now
10:38:13 <yitz> ddarius: Oracle tells *you* what you're allowed and not allowed to do, not the other way around.
10:39:38 <Eduard_Munteanu> Anyway, when you're proposing a format for standardization, you might as well provide a reference implementation
10:56:03 <morel> how to UNimport a module?
10:56:14 <morel> i did "import Foo" and i want to undo that.
10:56:27 <morel> (within ghci)
10:56:56 <c_wraith> :m - ModuleName
10:57:05 <c_wraith> the - is the important part
10:57:15 <c_wraith> :m is short for :module
10:57:34 <morel> c_wraith: thank you very much =)
10:57:48 <c_wraith> morel: you're welcome
11:08:55 <ben> http://hackage.haskell.org/packages/archive/unix/2.5.0.0/doc/html/src/System-Posix-SharedMem.html#shmOpen - is it just me or does it not actually pass O_RDONLY (=1) when ReadWrite isn't passed?
11:10:03 <ben> oh, I looked it up wrong. it's 0. :(
11:10:39 <k0ral> in which case would String be a better choice rather than Text ?
11:22:58 <kanak`> How do i handle the UnsupportedOperationException thrown by getTemporaryDirectory? I tried this: catch getTemporaryDirectory (\ _ -> return ".") but I got a "    Ambiguous type variable `e0' in the constraint: arising from the use of catch"
11:26:13 <EvanR-work> kanak`: you need to define the type of (\ _ -> return ".") somehow
11:26:21 <EvanR-work> since _ can be anything
11:28:11 <ksion> EvanR-work: Type of catch specifies it as IOError.
11:28:31 <doserj> ksion: that is only Prelude.catch
11:28:35 <EvanR-work> wrong catch
11:28:44 <ksion> Ah.
11:28:46 <doserj> Control.Exception.catch is polymorphic
11:29:37 <kanak`> sorry yeah i was using Control.Exception.catch because hlint told me to use that instead of prelude's catch. shoud i just use the one from System.IO.Error?
11:30:29 <EvanR-work> welcome to exception handling hell ;)
11:31:07 <kanak`> ok that seems to work :D. Is there a general guideline on when to use Prelude.catch vs System.Exception.catch vs IO.catch?
11:31:52 <ksion> Prelude.catch is IO.catch, no?
11:32:31 <kanak`> ksion: you're right. doh
11:33:41 <doserj> Basically, always use Control.Exception.catch :)
11:35:41 <k0ral> IO.catch is said to be deprecated
11:37:14 <ciaranm> someone needs to write a book called "Current Haskell Conventions"
11:37:32 <kanak`> doserj: how do i use the Control.Exception.catch to tell it to catch just the UnsupportedException thrown by getTemporaryDirectory? I need help with the type signature
11:37:49 <k0ral> ciaranm: this book will be deprecated in a matter of years, if not months
11:37:58 <ciaranm> k0ral: new edition!
11:38:31 * edwardk waves hello.
11:38:31 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:39:33 <edwardk> @tell augur recursion schemes are a dead end, don't worry about them ;)
11:39:33 <lambdabot> Consider it noted.
11:41:21 <edwardk> playing around with trying to get a usable not-quite-finite-domain solver that abuses the sped up version of the infinite search monad, so you can do 'finite domain' searches over cantor space, etc.
11:41:41 <edwardk> as long as you only use it with predicates that can be checked in bounded time
11:42:00 <doserj> kanak`: something like catch getTemporaryDirectory (\IOError _ -> return ".")?
11:42:41 * Saizan wonders which problems fit this spec
11:42:51 <edwardk> saizan: no idea. =)
11:44:21 <edwardk> Saizan: what i'm looking for is something like the overton finite domain solver adapted to allow for variables to be bound to things like the cantor space. where i'll go through and prune down the finite (and cofinite?) variables before evaluating based on the binary predicates you supply
11:44:31 <edwardk> er prune down their domains
11:44:56 <kanak`> doserj: i get an error "not in scope data constructor IOError"... maybe it's an abstract type and i can't pattern match against it?
11:46:05 <doserj> kanak`: you can try (\SomeException -> return ".")
11:46:20 <edwardk> then you can do cute things like search for functions, etc.
11:46:41 <edwardk> as long as you only use them a bounded number of times
11:47:24 <Saizan> nice
11:47:55 <edwardk> and i can use the hidden monadic side effects to inspect which ones you looked at to avoid paying the ridiculously exponential cost or at least reduce it as much as possible
11:48:30 <ddarius> edwardk: VS2008 graph drawing algorithm for fact/dimension tables is ridiculously bad.
11:48:38 <edwardk> ddarius: yep
11:49:15 <edwardk> ddarius: btw- i need to swing by at some point, copumpkin, dolio and i have a christmas present for you
11:50:30 <ddarius> edwardk: That would require me putting on clothes, but it would allow me to give your books back.
11:50:44 <ddarius> And allow me to lend dolio my books.
11:50:49 <edwardk> well, as i'm at the office right now, you'll have plenty of notice
11:51:06 <edwardk> oh yeah, raytheon winter break
11:51:16 <dolio> I'm not in Boston right now.
11:51:51 <ddarius> edwardk: I'm working during it.
11:51:54 <ciaranm> i'm fairly sure the christmas present doesn't require you to be wearing clothes
11:52:00 <ddarius> Hence the comment above.
11:52:08 <edwardk> dolio wandered off to ohio, so i'm busy breaking everything in the compiler behind his back
11:52:57 <ddarius> Maybe I'll walk oven to Ohio again some day.  Probably not.
11:53:15 <ddarius> s/oven/over/
11:55:24 <Octavius> hello
11:57:37 <Eduard_Munteanu> Octavius: hi
12:02:07 <kanak`> doserj: thanks
12:02:50 <Octavius> Someone knows an example of this ? "unlike type synonyms, newtype may be used to define recursive types"
12:03:25 <shachaf> newtype Tree = MkTree [Tree]
12:03:28 <monochrom> newtype USEconomy = USD (Money -> USEconomy)
12:04:10 <Octavius> thanks
12:04:18 <ddarius> edwardk: Also, any good books or, preferably, online resources for SSAS and the VS2008 designer.  I'm comfortable with MDX and the concepts behind the cube, I just want to know what all the bells and whistles are and how to get at them.
12:05:35 <edwardk> ddarius: there isn't much. i dug through the generic MDX code i could find for other platforms, and then hunted through the stuff that sunil used to cargo cult to try to find the underlying logic
12:05:36 <int-e> monochrom: haha
12:06:31 <monochrom> my favourite newtype example :)
12:06:38 <ddarius> The underlying logic I have, but I don't know what real difference it makes when I change a dimension type from Regular to Time.  I mean, I'm sure it's good to know, but does it affect performance or semantics in any way?
12:06:40 <Octavius> shachaf: how can we construct a value of Tree?
12:06:59 <edwardk> Time is mostly useful so that ParallelPeriod, etc. automatically select it
12:07:05 <ddarius> Also, the KPI stuff seems clear enough, but I'm not sure what it does with the trend information.
12:07:05 <edwardk> other than that there is no difference
12:07:31 <monochrom> MkTree [MkTree [], MkTree []]
12:08:08 <ddarius> edwardk: Yeah, that was just an example, but there are many, many options for a lot of these things, and I have no idea what they change since the model itself for the most part doesn't care.
12:08:10 <edwardk> i don't remember how much of the built in kpi support we were able to use
12:08:15 <edwardk> *nods*
12:08:55 <Octavius> and USEconomy?
12:10:07 <monochrom> let x = USD (\m -> x) in x
12:10:36 <monochrom> in fact, also: let t = MkTree [t, t] in t :)
12:10:46 <ddarius> edwardk: We're using them in the new cube, though mildly bastardized.  But, my question there is there's a value and a goal expression specified which are clear enough, but I have no idea what the cube does with that information or how it affects the user interface.
12:10:56 <edwardk> feel free to ping me with any particular questions. a lot of my understanding came from mining through the blogs of the designers and from reverse engineering based on the changes from 2005 and what the mdxml code looked like for cube generation, etc.
12:11:12 <Octavius> what is the second x?
12:11:26 <monochrom> they are all the same x. self-reference.
12:11:30 <edwardk> ah, yeah i think we weren't able to get them to do everything we needed in the old cube
12:11:35 <Octavius> does it works?
12:11:47 <monochrom> self-reference always works in haskell
12:11:50 <edwardk> so you're probably on your own getting KPIs right in analysis services
12:11:54 * hackagebot ekg 0.1.0.0 - Remote monitoring of executables  http://hackage.haskell.org/package/ekg-0.1.0.0 (JohanTibell)
12:12:22 <ddarius> edwardk: I'll just google (or usually Bing on MSDN).  I was just hoping for some fairly concentrated source in one of those typical, crappy, super-shallow technology book sort of style.
12:12:39 <edwardk> there was something fairly basic we needed that we couldn't get out of them.
12:12:46 <edwardk> but its been long enough that i've blanked it
12:13:02 <Octavius> thanks shachaf
12:13:07 <Octavius> thanks monochrom
12:14:04 <ddarius> I don't need KPI stuff, it's just a strange thing I stumbled across and I was wondering "so what the heck does the cube actually do with this."  The status/trend indicator parts are clear enough.  I guess it also calculates differences and/or whether you've hit the goal and such fields will have a bunch of extra attributes.
12:14:48 <Octavius> what could it be useful for? let t = MkTree [t, t]
12:15:14 <Renze> Hi
12:15:49 <edwardk> most of it is for display purposes. one of the various microsoft reporting frameworks has support for automatically displaying KPIs correctly
12:15:58 <Renze> Why is ghci shutting down if I use unsafePerformIO and mkStdGen at the same time (in different functions)?
12:16:22 <edwardk> useful if you want to avoid the craziness we had to go through
12:16:47 <monochrom> cyclic tree. as useful as cycle list.
12:17:57 <edwardk> mkStdGen from random?
12:18:15 <Renze> yes
12:18:32 <edwardk> mkStdGen is a pure function, so i think you're chasing after a red herring
12:18:37 <Octavius> I don't understand
12:18:38 <ddarius> Trees that don't have any data in them are not usually the most useful thing regardless of whether they are cyclic or not.
12:19:42 <xil> hi. Question about strictness. Suppose I create a data type like "data Mine = Mine !Int !Double". It is my understanding that if I write something like "let x = Mine (2+2) (18/12)" then the computations aren't actually done right then and there, but rather than later, when I look at the value of x, the computation will be done regardless of whether I look at either value. Is that correct? Basically, if I want the computation to be done i
12:19:51 <ddarius> That said, you could view these as process trees where you transition based on an number.
12:20:30 <monochrom> tree with no data, not cyclic, maybe not useful, but fun, which is another useful: http://math.andrej.com/2008/02/02/the-hydra-game/
12:20:31 <ehamberg> xil: your message was cut off after “the computation to be done i”.
12:20:45 <xil> Basically, if I want the computation to be done immediately then I have to do "let x = seq $ Mine (2+2) (18/12)" but I don't need deepseq because of the '!'. Is that right?
12:21:04 <ddarius> xil: No.
12:21:36 <Renze> edwardk: I know, I don't use them together, just at the 'same time'. I was thinking of giving an example, but I think the problem lies in ByteString, is this possible? I use unsafePerformIO $ ByteString.readFile somefile
12:21:52 <mcluhan> the tree doesn't carry the data. the tree is the data!
12:21:58 <monochrom> :)
12:22:03 <Renze> (With normal readFile it doesn't close my ghci)
12:22:24 <ddarius> type Natural = [forall a. a]
12:22:27 <edwardk> renze: thats fine as long as the file is actually there, but in general if you're doing that you probably have something that should be monadic
12:23:21 <xil> how do I ensure the computation is done on the stop then?
12:23:34 <Renze> edwardk: I know, but that was already giving me a headache, so I didn't want to use it, as my only IO operations are reading two files at the beginning with values which will never change
12:23:34 <xil> spot
12:24:22 <edwardk> main = go <$> readFile "foo" <*> readFile "bar"; go foo bar = …
12:26:06 <ddarius> xil: A let expression doesn't specify a "spot".  If you want to have x evaluated before returning the result of the let expression, then you would say so with seq in the body.
12:26:54 * hackagebot conduit 0.0.0.1 - A pull-based approach to streaming data.  http://hackage.haskell.org/package/conduit-0.0.0.1 (MichaelSnoyman)
12:26:59 <edwardk> let !x = Mine (2+2) (18/12) in … is one hackish way. what you really want is let x = Mine (2 + 2) (18 / 12) in x `seq` ….
12:27:11 <edwardk> or pseq
12:27:30 <ddarius> pseq is what really should be used most of these times, though it rarely matters in practice.
12:27:31 <edwardk> but seq is probably sufficient for your purposes
12:27:47 <edwardk> if all you care about is strictness
12:27:48 <mux> but that wouldn't even make a difference since his datatype is defined strictly to begin with (data Mine = Mine !Int !Double)
12:28:16 <ddarius> mux: It depends on what is in the ...
12:28:27 <mux> ddarius: right
12:28:58 <ddarius> The former version roughly translates to the latter version.
12:30:07 <edwardk> mux: the seq matters because saying x = Mine (2 + 2) (18 / 12) makes a thunk that may perform both of those calculations and generate the new Mine constructor all at once when it is finally forced. it won't force that calculation to happen now. merely whenever you first look at x
12:30:57 <mux> edwardk: you just paraphrased what ddarius said in a much more complicated manner
12:31:18 <Renze> edwardk: yes I know how IO works, the problem was that I got IO (Array Int (IO (Array Int Int))), and that didn't made me happy
12:32:13 <ddarius> Renze: If you know how IO works then either you shouldn't have gotten that, or that shouldn't be a problem.
12:32:20 <edwardk> renze: if you got an IO (Array Int (IO Array Int Int)) you probably should have made the IO effect a somewhere a long time ago somewhere else, coz you're going to be hitting the disk a lot =P
12:32:48 <edwardk> ddarius++
12:33:22 <Renze> I know how IO works if it's there ones, which took me a looong while to understand
12:34:10 <mux> also, "now" is a very ill-defined term when talking about haskell code :-)
12:34:37 <xil> ah I just realized something. So I have a list of type [Mine] and I go through it, say, incrementing the Int part and doing something to the Double. And I do this repeatedly until the Double meets some condition, at which point I remove that element from the list and add it to a list stored in a TVar. All of that code is in thread 2 then I don't need seq to make sure it is actually done in thread 2, right?
12:34:50 <monochrom> newtype Awesome = Awe (IO (Array Int Awesome))  :)
12:35:00 <edwardk> Renze: the problem is you 'kept the IO in the type' which i where all your problems come from in the first place. you need to learn to use >>= in the _right_ places
12:35:09 <xil> I used to just put the whole list into the TVar after performing the computation, but that just put the thunk in the TVar and the computation was done in thread 1, which is bad
12:35:24 <edwardk> you should be able to make an IO action that returns an IO (Array Int (Array Int Int)) by sequencing that properly
12:35:34 <gajop> every once in a while i turn my eyes to haskell, start learning it a bit by using some guide, and eventually give up on it for a while; it seems i can't find a reason where i'd use it; any suggestion where haskell my be better than imperative programming languages - currently i'm using python/sh whenever i'm scripting something, java/C# if it's a more complex gui/web application, matlab for machine learning,
12:35:36 <gajop> c/c++ for simple applications with high speed requirements, and so on
12:35:39 <edwardk> then you can work with an Array Int (Array Int Int) in the few places that care
12:35:51 <edwardk> and nothing else needs to ever talk about IO
12:37:38 <Renze> Well, almost everything uses the type (as it's a matrix with distances and that's what my program needs constantly), so I need IO almost everywhere if I use it once
12:46:18 <tehgeekmeister> best iteratee tutorial?  anyone have a recommendation
13:00:50 <xil> is there a function that takes a list of type [Bool] and folds it with an AND function?
13:00:58 <parcs`> and
13:01:15 <ion> @hoogle [Bool] -> Bool
13:01:15 <lambdabot> Prelude and :: [Bool] -> Bool
13:01:15 <lambdabot> Data.List and :: [Bool] -> Bool
13:01:15 <lambdabot> Prelude or :: [Bool] -> Bool
13:01:16 <xil> lol. I thought to seacrh that on hoogle after saying it and found it
13:04:20 <jeff_s_> Where might I go to suggest that Hackage start enforcing, or at least suggesting, some package and namespace naming convention? Or maybe there is already some other functionality to address my concern, but it seems that something like the the Java unique package naming standard should be adopted.
13:04:41 <jeff_s_> As more people write libraries, package names and module names are going to get out of hand.
13:06:20 <ksion> jeff_s_: I was under the impression that packages should use semantic namespaces: parsers under Text, monad-related stuff in Control.Monad, etc.
13:07:15 <tehgeekmeister> @hoogle fix
13:07:15 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
13:07:15 <lambdabot> Data.Fixed module Data.Fixed
13:07:15 <lambdabot> Data.Function fix :: (a -> a) -> a
13:07:52 <jeff_s_> Sure, but suppose both you and me want to submit packages containing some Earley parser implementation. Is there a documented way for us to name our packages and modules so they aren't the same?
13:08:29 <jeff_s_> Something like, Text.Parser.Earley.JeffShaw or Me.JeffShaw.Text.Parser.Earley, vs the same things with your name.
13:08:35 <ksion> I guess it's called "first come, first served" :)
13:09:24 <jeff_s_> I'm thinking that that convention isn't very good.
13:09:47 <jeff_s_> I'm thinking something like Java's package name convention would be better.
13:09:57 <ksion> It certainly satisfies a geeky need for keeping everything neatly organized.
13:10:28 <ksion> As for Java convention, I think the uniqueness is about the only real benefit and it's not very big one.
13:11:04 <ksion> A Python does it pretty neatly, I think. A root name must be unique, but no gTLD/ccTLD crap.
13:11:42 <tehgeekmeister> eep.  it appears i need to understand why fix works again.  anyone have a good insight on that?
13:12:55 <tehgeekmeister> >fix (\n -> if n < 9 then n+1 else n)
13:12:56 <Cale> jeff_s_: The package name can be used to disambiguate imports
13:13:33 <ivanm> Cale: isn't that recommended against though?
13:13:58 <Cale> Well, it's not good to use it all the time
13:14:17 <Cale> but that's what it's for, handling the case of ambiguity between packages
13:14:35 <jeff_s_> Doesn't that run into the same problem? Suppose you and me both have Earley packages. I submit mine first, and then you submit yours. Yours is rejected, and you have to redo a bunch of imports and cabal files. Wouldn't it be better if, by following a convention, yours was called something like Me.Cale.Earley, and mine was called Me.JeffShaw.Early?
13:14:56 <jeff_s_> Then there'd hardly ever be a problem.
13:15:02 <natte> how would I go about iterating something like this: http://hpaste.org/55779
13:15:04 <Cale> What?
13:15:20 <natte> cons syntax doesn't seem to work, over the terms in the expression I mean
13:15:52 <Cale> natte: You mean enumerating all possible values of that type?
13:16:09 <Cale> natte: Or just how to recursively pattern match a structure of that type?
13:16:27 <Cale> (cons syntax?)
13:16:46 <Cale> jeff_s_: It's hardly ever a problem anyway
13:16:55 <natte> Cale: (x:xs) :)
13:17:09 <Cale> (x:xs) means a list whose first element is x and whose tail is xs
13:17:21 <natte> yea isn't that cons? :)
13:17:23 <Cale> yes
13:17:24 <natte> : <-
13:17:28 <jeff_s_> I'm pretty sure that as Haskell is used more and more, it's going to become more of a problem.
13:17:33 <Cale> but I don't see what it has to do with that datatype
13:17:43 <natte> was hoping I could do the same with something like (Var "p" :&& (Not (Var "q") :|| Var "r"))
13:17:45 <natte> :)
13:18:04 <Cale> jeff_s_: you're going to want to import two different Earley parsers and use them at the same time in the same project?
13:18:04 <natte> my first guess, but no and I'm kind of stuck since I don't even know what to read about
13:18:30 <Cale> jeff_s_: Even if you want to do that, you can do so already and make it work, even if they use the same module names.
13:18:46 <Cale> (because they'll be in separate cabal packages)
13:19:03 <Cale> natte: er...
13:19:14 <jeff_s_> What if the packages have the same name?
13:19:16 <Cale> natte: That looks like a valid expression of the BoolExp type
13:19:28 <jeff_s_> Or is there a naming convention for cabal packages I don't know about?
13:19:34 <Cale> jeff_s_: you can't have two packages with the same name and same version number installed
13:20:20 <natte> Cale: yep, now I would like to do couple things do it, count the number of occurances of each Var "p" or :&& or :|| or Not (Var "p"), in the conrete example it would be 6
13:20:25 <jeff_s_> Right, and I'm saying it would be a great idea if there was a systematic way for me to name my packages so they wouldn't overlap with your packages.
13:20:29 <Cale> natte: okay...
13:20:47 <natte> oh and then it gets fancy like replacing :&& with or-not using demorgans, but that's step 2 :D
13:20:56 <Cale> natte: so pattern match on the :&& and :|| and Var and Not constructors
13:21:11 <Cale> size (Var x) = 1
13:21:24 <Cale> size (e1 :&& e2) = size e1 + size e2
13:21:30 <natte> doh!
13:21:33 <natte> thanks :)
13:21:36 <Cale> etc.
13:22:14 <natte> elegant and simple, like it :)
13:22:37 <Cale> Even better, invent a fold for your expression type and use that
13:24:06 <Cale> foldExp v a o n = f where f (Var x) = v x; f (e1 :&& e2) = a e1 e2; f (e1 :|| e2) = o e1 e2; f (Not e) = n e
13:24:14 <Cale> and then
13:24:41 <Cale> numVars = foldExp 1 (+) (+) id
13:24:45 <Cale> er
13:24:50 <Cale> numVars = foldExp (const 1) (+) (+) id
13:24:52 <Cale> rather
13:25:38 <lozgod> hello?
13:25:39 <Cale> foldExp takes replacements for each of the 4 constructors of the datatype, and replaces them throughout the expression
13:25:45 <Cale> lozgod: hello
13:25:53 <Cale> natte: cool? :)
13:25:58 <natte> ok that seems even more awesome :D
13:26:45 <Cale> You can do something like:
13:27:02 <Cale> vars = foldExp (Set.singleton) (Set.union) (Set.union) id
13:27:22 <Cale> to collect up a set of all the variable names used in an expression.
13:28:09 <Cale> (similar for free variables, once you have some binders in your language, you just need to subtract elements from your set)
13:29:17 <Cale> and you can also probably do normalisation easily enough...
13:30:24 <Cale> (though it might be easiest to go via a set of sets of BoolExp, where the expressions you put into the sets are just variables or their negations)
13:31:09 <Cale> The replacement for Not is actually interesting in that case :)
13:31:12 <natte> thanks for the tips Cale, I need to process this a bit now but the huge block is gone - there's an idea how to go about solving it :)
13:46:54 * hackagebot gtk-mac-integration 0.1.0.3 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk-mac-integration-0.1.0.3 (HamishMackenzie)
13:48:46 <carpi> Im writing some code for generating permutations of a list. the length of the list can vary from 1 to 50. Whenever the length of list is 9 or more.. the computation takes forever. Could someone please tell me how I may reduce it?
13:49:26 <hiptobecubic> you are generating all permutations of a list of 50 elements? That's going to take a long time, period.
13:49:26 <Botje> carpi: well, there are 9! possible permutations
13:49:28 <Botje> which is ..
13:49:29 <hpaste> morel pasted “indentation-syntax…” at http://hpaste.org/55781
13:49:32 <Botje> > product [1..9]
13:49:33 <lambdabot>   362880
13:49:41 <morel> why does that code-snippet not work? http://hpaste.org/55781
13:49:47 <Botje> > product [1..50] -- pain.
13:49:48 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
13:49:58 <morel> it's a question concerning indentation…
13:50:04 <Botje> carpi: so you will probably have to rethink your approach.
13:50:09 <carpi> yes..but some of those permutations are duplicates and i don't need them all
13:50:27 <Botje> morel: then and else on lines 7--8 need to be indented as well
13:50:30 <hiptobecubic> carpi, some list items are identical?
13:50:34 <Botje> indented more than the if, that is.
13:50:42 <carpi> hiptobecubic: yes. that is true
13:50:44 <Botje> carpi: a naive permutations algorithm won't know that.
13:50:48 <morel> Botje: can you correct my post, pls?
13:50:50 <Botje> carpi: can you tell us about your real problem?
13:51:14 * morel is sorry for carpi to disturb his discussion :(
13:52:18 <Botje> morel: oh .. uh
13:52:23 <Botje> morel: those lets are also a bit weird.
13:52:48 <carpi> the real problem is finding the average of all permutations of a list..
13:53:05 <hiptobecubic> carpi, the average what
13:53:06 <Botje> morel: you will need to give those lets a body or put them in a do block
13:53:16 <hiptobecubic> morel, the code doesn't really make sense. you don't do anything with the values.
13:53:17 <carpi> that is actually the a part of the problem.. i can give you the link to the entire problem if it helps.. one moment
13:53:22 <Botje> carpi: the average of a permutation is the same as the average of the list
13:53:29 <carpi> http://www.interviewstreet.com/recruit/challenges/solve/view/4e1491425cf10/4eed18ded76fe
13:53:48 <carpi> i think its called vertical sticks
13:53:51 <DevHC_> i can haz unicode >>= ?
13:53:57 <morel> hiptobecubic: yep. it doesn't make sense because it's a syntactic/indenting-issue...
13:54:34 <Botje> carpi: uh, that wants me to sign in
13:54:38 <hiptobecubic> morel, is there a big block of code that is supposed to come after this, where you do some computation with these values or is this the whole function?
13:54:50 <carpi> ah shite.. one moment.. i can screen the shot
13:55:00 <hiptobecubic> :D
13:55:04 <Botje> morel: the lets are also a problem
13:55:33 <morel> hiptobecubic: it's not the whole func
13:55:38 <morel> Botje: why?
13:56:00 <Botje> morel: there are two forms of let
13:56:05 <Botje> either let BINDINGS in BODY
13:56:11 <Botje> or, in a do block, let BINDINGS
13:56:22 <morel> okay, ic.
13:56:37 <Botje> but you cannot put a let at the end of a do-block, so it will have to be at least let t = 5 in t or something.
13:57:48 <hiptobecubic> morel, in essence. The code doesn't _do_ anything. You bind some names to some values and then the program ends.
13:58:17 <hiptobecubic> if the rest of the function comes after the 'in' that Botje is talking about then maybe it will work?
13:58:17 <hpaste> morel pasted “@ Botje:  that doesn't work, too” at http://hpaste.org/55782
13:58:42 <morel> hiptobecubic: ↑
13:58:56 <Botje> morel: what are you trying to do with the "let t = ..." ?
13:59:30 <Botje> morel: let doesn't work that way.
13:59:35 <morel> hm
13:59:46 <Botje> morel: a let binding is only valid in the same (or nested) do block
14:00:01 <Botje> each branch of the if-then-else will be a block in itself
14:00:07 <Botje> so your putstrln won't see the t.
14:00:49 <carpi> Here it is http://i41.tinypic.com/9gd0ep.jpg
14:01:01 <vodik> morel: you can put the putStrLn show before the if
14:01:40 <morel> Botje: hm. okay. i'll try to find another solution/way. :)
14:01:54 * hackagebot Workflow 0.5.8.1 - library for transparent execution of interruptible computations  http://hackage.haskell.org/package/Workflow-0.5.8.1 (AlbertoCorona)
14:02:20 <carpi> the thing is that I've written the code to solve that problem and i get correct output for lists that are less than length 7 or 8. but beyond that, it takes forever
14:02:50 <morel> vodik: yea, i'll probably try sth like: putStrLn $ show if x==y then 1 else if y==z then 2 else 3 -- or so
14:02:52 <hpaste> “Simon Gomizelj” annotated “@ Botje:  that doesn't work, too” with “@ Botje:  that doesn't work, too (annotation)” at http://hpaste.org/55782#a55783
14:03:04 <vodik> morel: wouldn't something like this work ^
14:03:50 <morel> vodik: yep =) thanks =)
14:04:07 <vodik> morel: you're thinking too procedurally
14:04:17 <carpi> if the picture is a bit smudged please let me know.. ill reup a clearer one )
14:04:29 <Botje> carpi: first thing that pops in my head is a monte carlo simulatoin
14:04:47 <Botje> but I think you do something a bit more clever by looking at the distribution of the tall lines.
14:04:48 <morel> vodik: i'm sorry. i have imperative origins…
14:05:18 <morel> hehe :D
14:05:50 <vodik> morel: it'll come :) don't worry
14:06:43 <hiptobecubic> carpi, Botje yeah. I think the key is that they only want it to two decimal places. That doesn't take much
14:08:58 <carpi> Botje: hiptobecubic so something like calculating the distribution of the taller lines in a large permutation pool of the input?
14:09:18 <Botje> carpi: generate a few million permutations and take their average
14:09:27 <Botje> alternatively ..
14:09:34 <hiptobecubic> carpi, what Botje said.
14:10:05 <Botje> pick the largest element from the set, put it at a certain position, and then split your set in two parts and recursively calculate
14:10:26 <Botje> but that won't help terribly much.
14:11:18 <bgamari> Anyone have any suggestions regarding how to minimize the pain of writing a concurrent Gibbs sampler?
14:11:21 <hiptobecubic> i'd just go monte carlo. then again, i'm lazy
14:11:35 <bgamari> I was thinking just a bunch of IORefs to encapsulate my state
14:11:46 <carpi> Botje: a few million? i tried 1500. the decimals were off . you think a few million will help? the only problem is I don't have a large data set to test it against.. whatever i can test againast are the few examples mentioned in the problem description itself
14:11:48 <bgamari> but surely there must be a more haskell-ish way to approach the problem
14:12:00 <bgamari> without sacrificing too much in performance
14:12:36 <Botje> carpi: law of large numbers. as you sample more and more permutations your variance will go down
14:14:54 <rwbarton> for n=50 i expect you will need far too many samples
14:16:03 <rwbarton> roughly 10^10 i would estimate
14:16:17 <carpi> ill try the first option.. if it doesn't work then monte carlo. I sound like I know something about monte carlo. Truth is I know jack shite. but on wiki its interesting.. im not lazy or anything..but how long would it take to implement it using monte carlo..approx?
14:17:36 <rwbarton> actually perhaps not, you could try to estimate the variance also
14:18:02 <Botje> carpi: the time it takes you to write the random generation code.. the rest is easy.
14:19:44 <carpi> so in this case.. i would be randomly producing [[Int]] where each [Int] is a random permutation of the input?
14:21:08 <Botje> yes
14:24:15 <carpi> but wouldn't this mean that there will still be duplicates in [[Int]]? but i think the proportion of duplicates to non-duplicates would be less to not be much of an issue. Though I still wonder.. how is this different from taking say 2 millions permutations and randomly generating ..say 2 million permutations?
14:24:52 <ben> How do I tell ghc-pkg that I just deleted my ~/.cabal directory because something was rotten in the state of the package database and I couldn't figure it out?
14:25:28 <pdxleif> ghc-pkg unregister all the things listed as being in .cabal, one by one?
14:25:35 <xrl> what's the recommended haskell library for performing operations on sparse matrices? svd in general?
14:26:54 * hackagebot test-framework-program 1.0 - Test framework support for running simple test programs.  http://hackage.haskell.org/package/test-framework-program-1.0 (AdamWick)
14:28:13 <byorgey> ben: if you want to blow away your package database you need to delete the appropriate subdirectory of ~/.ghc
14:28:19 <byorgey> deleting ~/.cabal is not necessary
14:28:29 <morel> was not…
14:28:57 <ben> ah
14:29:00 <ben> well then
14:29:01 <byorgey> xrl: hmatrix?
14:29:13 <byorgey> dunno about sparse matrices, actually
14:31:07 <rwbarton> upon further reflection my estimates were terrible
14:31:16 <rwbarton> probably monte carlo will be adequate
14:31:54 * hackagebot postgresql-libpq 0.6 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.6 (LeonSmith)
14:32:01 <rwbarton> carpi: just pick random permutations without worrying about duplicates
14:32:08 <rwbarton> you won't have time to detect duplicates anyways
14:32:16 <rwbarton> and it doesn't matter
14:32:57 <Botje> carpi: there will probably be duplicates, yes. but as long are you're getting a large enough sample, who cares :)
14:37:58 <roconnor> > 64 * 5
14:37:59 <lambdabot>   320
14:37:59 <carpi> Botje: rwbarton this particular problem seems to be particularly sensitive.. because i just used the 'take 20000 method' and the 'take 10000 method' and the final result had a difference of about 4. it is not the monto carlo method..but however do you really think the monte carlo method will be a difference to the 'take x method' if large samples were taken in both cases?
14:38:23 <Botje> carpi: what do you mean by "take x method"
14:38:27 <carpi> only good news is that this lists of length 50 are working : )
14:38:28 <Botje> carpi: are you generating the first N permutations?
14:38:38 <Botje> carpi: you need to take *random* samples, not just the first N
14:38:59 <carpi> Botje: yea.. taking the first x permutations
14:39:06 <Botje> that's not a good sample.
14:39:29 <Botje> so use something like fisher-yates shuffle to generate a new permutation, calculate the average, permute again, calculate average, and so on
14:39:38 <carpi> Botje: so its not the same yea? because the first n permutations have some sort of order..which is one following the other
14:39:47 <Botje> indeed.
14:41:24 <JoeyA> Is it possible to add extra repositories to cabal?
14:41:48 <carpi> fisher-yaters shuffle is a way to randomize the placement of the elements in a list?
14:42:46 <JoeyA> I have a proprietary project with multiple modules.  I'd like to be able to automatically install them.  Currently, I'm traversing the dependencies manually and running cabal install.
14:42:58 <JoeyA> Is there a way to "add repositories" for cabal-install to use?
14:43:04 <JoeyA> err, multiple packages
14:43:39 <carpi> nevermind.. wikipedia to the rescue. im unnecssarily wasting your time )
14:43:42 <Botje> carpi: yes. it shuffles a list.
14:44:04 <mzero> JoeyA: you mean you have a project, it has dependencies on hackage projects and you want to install those w/o installing your project?
14:45:10 <JoeyA> mzero: I have multiple packages, and they're proprietary, so I can't upload them to Hackage.  They depend on packages in Hackage, too.
14:46:15 <JoeyA> Running cabal-install on each proprietary package one by one is not only a hassle, but problematic.
14:46:45 <mzero> i see, or PropPackageA depends on PropPackageB and PropPackageC -- you want to have something like "cabal install --only-dependencies" in PropPackageA find and instal B & C
14:46:46 <mzero> ?
14:46:47 <JoeyA> An example I ran into: I compiled A, which was happy with the containers-0.4.0.0 that was already available.
14:47:33 <JoeyA> But when I went to install B, which depends on A and requires containers >= 0.4.1, it failed.
14:47:47 <mzero> right - so if you could install them via   "cabal install --only-dependencies" in PropPackageA, then they'd all have a compatible set of dependencies
14:48:03 <JoeyA> I'm using --upgrade-dependencies to deal with this issue, but I wish I didn't have to.
14:48:07 <mzero> seems like you want to make a local package repo, and add it to the repos that cabal searches
14:48:30 <JoeyA> mzero: Right.  How do I do that?
14:49:21 <JoeyA> I guess that's what the local-repo line is for?
14:49:29 <JoeyA> (in .cabal/config)
14:50:22 <mzero> yeah, but I don't see where there is documentation for how to do it
14:50:34 <mzero> er, no
14:51:25 <mzero> er, yes - though I think you can have multiple remote-repos too .
14:52:25 <JoeyA> Hmm, looks like I can do cabal install ./PropPackageA ./PropPackageB ./PropPackageC
14:53:01 <mzero> oh - that's nice
14:53:04 <augur> edwardk: lol
14:53:05 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
14:53:38 <augur> fair enough, im just looking to understand why!
14:53:42 <Renze> Hi, I've got a problem with unsafePerformIO and mkStdGen, f.e.: let a = head (unsafePerformIO $ readFile "afile.txt"); b = mkStdGen 123456789; this doesn't give any problems, while: let a = myOwnFunction (unsafePerformIO $ readFile "afile.txt"); b = mkStdGen 123456789; does. But myOwnFunction is typecorrect and doesn't give any problems.
14:54:11 <edwardk> augur: once you get past cata/ana/hylo there really is only one 'kinda cute' observation, which is that you can thread a monad or comonad through ana and cata respectively given a distributive law. the others are just special cases of that fact
14:54:12 <Renze> (the problem = quitting ghci without any notice or warning)
14:54:25 <Renze> I thaught the problem lied in ByteString, but it doesn't
14:54:54 <edwardk> there isn't really any secret fusion magic or any deep insight into your code that will come from encoding it using recursion schemes
14:55:07 <augur> edwardk: thats fine. im just curious how you do that. im reading the recursion schemes from comonads paper, but its really hard to grok how it relates to anything real
14:55:14 <djahandarie> You can get *some* fusion magic
14:55:20 <djahandarie> Well, not really magic. Just fusion.
14:55:31 <edwardk> yeah but that fusion comes in at 'hylo' =)
14:55:34 <djahandarie> Yeah.
14:55:43 <djahandarie> It's too bad the stream fusion approach doesn't work out :(
14:55:47 <djahandarie> Stupid Step
14:55:50 <djahandarie> Who needs that crap anyways
14:55:56 <edwardk> ?
14:56:04 <edwardk> what do you mean 'doesn't work out'?
14:56:19 <edwardk> Step is key to making it turn into a single loop
14:56:24 <augur> edwardk: actually im more concerned about what i can say about natural language in relation to the schemes. i dont want to make a claim like "natural language is all about catamorphisms" or something if it turns out well, anything can be done by catamorphisms so its a vacuous statement
14:56:54 <djahandarie> edwardk, yes, and Step doesn't work when you're generalizing it to any Mu-recursive structure, making stream fusion pointless in that case. IIRC.
14:56:54 <JoeyA> mzero: Indeed, cabal install ./PropPackageA ./PropPackageB ./PropPackageC worked
14:57:05 <djahandarie> Or at least no one has figured out how to make it work.
14:57:12 <augur> so i'd need to understand what exactly it means for something to be doable in terms of catamorphisms. if it can be done in terms of catamorphisms with a suitable (co)monad thats one thing
14:57:15 <edwardk> augur: i wouldn't bother to make that claim, catamorphisms are just a way to fold a structure. given a monad and a distributive law you can get paramorphisms from catamorphisms and then you can do general recursion, just in a REALLY awkward way
14:57:37 <dolio> What?
14:57:59 <edwardk> dolio: ?
14:58:00 <dolio> You mean primitive recursion?
14:58:17 <edwardk> yes
14:58:46 <augur> edwardk: im looking at two different views of natural language -- representationality and derivationality -- and i'd like to be able to describe what the difference is, and my instinct is that derivationality = catamorphisms
14:58:56 <edwardk> djahandarie: oh that. yeah. well even without skip you lose the 'fusion' benefits there, because you need to be able to walk back out some kind of stack
14:58:57 <augur> but obviously if everything is catamorphisms thats vacuous
14:59:19 <augur> so i need to understand these things!
14:59:58 <edwardk> you might be able to make a non-vacuous claim using catamorphisms, etc. but be warned the air is a bit thin to start with, and all you do is rule out most of your audience. ;)
15:00:18 <augur> ;P
15:00:34 <augur> i mean, i suspect that what i need to be able to say is something like
15:00:40 <augur> its a catamorphism of this sort over this structure
15:01:03 <edwardk> but what is the purpose of that statement?
15:01:16 <edwardk> to clue someone into the fact that you know what a catamorphism is?
15:01:18 <edwardk> =)
15:01:33 <augur> no, to give a non-fluff definition of derivationality
15:01:34 <ddarius> You can make paramorphisms just with catamorphisms (and pairs), which I guess would be the comonad you'd use?
15:01:45 <edwardk> yeah
15:02:00 <edwardk> i use the product comonad in recursion-schemes for it
15:02:46 <augur> edwardk: right now, "derivationality" is described fluffily as "comes about during the course of the derivation", which doesn't really say anything to anyone
15:02:50 <edwardk> and the product comonad-transformer can be used to augment other recursion schemes
15:03:19 <edwardk> so instead you'll replacement with a statement about catamorphisms which will say something, but to nobody ;)
15:03:45 <augur> well no, i'll be replacing with a statement about X, and X just happens to be catamorphisms if anyones interested in more details
15:04:04 <augur> so back to the question that matters
15:04:13 <augur> do you know of any place i can read about these relationships?
15:05:08 <edwardk> bananas lenses and barbed wire
15:05:13 <edwardk> and my knol on catamorphisms
15:05:28 <edwardk> and a few rather unapproachable papers by people who have disavowed any knowledge of this domain
15:05:43 <augur> lol
15:06:14 <edwardk> martin fokkinga's thesis is also a good introduction, but its written in an odd style
15:06:25 <djahandarie> Cata/ana/hylo is where it's at, and everyone should know about those
15:06:30 <djahandarie> I don't think the other things are that important
15:06:44 <augur> i dont get the disavowing. surely its useful in modelling computation categorically?
15:06:48 <dolio> Or read any of the dozens of papers on algebras.
15:06:51 <edwardk> not so much
15:06:59 <edwardk> not beyond the basics
15:07:12 <augur> edwardk: how do you model non-catamorphic/etc recursive functions then??
15:07:17 <edwardk> after that its just applying obvious distributive laws to obvious monads
15:07:27 <augur> hm
15:07:32 <edwardk> thats the problem. the hylo school never really got around to being able to model anything HARD
15:07:39 <ddarius> 1) Categorists don't talk about zygomorhisms at all, 2) they do talk about catamorphisms/anamorphisms a lot but not with those terms, and often in funky categories, 3) categorists aren't programmers.
15:07:55 <djahandarie> Are programmers categorists?
15:08:00 <ddarius> djahandarie: Nope.
15:08:07 <augur> edwardk: i dont mean anything in particular, but i mean categorical semantics of programming languages in general
15:08:13 <edwardk> given a recursive function there isn't a general procedure to convert it to zygohylowhatevermorphism
15:08:19 <djahandarie> I can only conclude that being a categorist is something you want to avoid.
15:08:22 <ddarius> Though programmers should feel an affinity toward categorists.
15:08:35 <augur> i mean, Hagino's language (i dont remember its name) surely has to have some way to do non-strictly-catamorphic recursion
15:08:48 <ddarius> He uses dialgebras.
15:09:03 <augur> whats a dialgebra
15:09:39 <edwardk> the whole school of thought seems to me to be the result of having picked the wrong abstraction. it works for simple examples, but doesn't scale to the hard stuff, and the fusion laws aren't all that interesting because most code can't be put into a form where they apply
15:10:05 <ddarius> I'd say a lot of code can, but it's rather painful.
15:11:02 <augur> so what is the current thought on the right abstraction?
15:32:21 <augur> edwardk, ddarius: ?
15:32:41 <edwardk> *shrug*
15:32:55 <edwardk> everyone who works in this space has bailed out for greener pastures =)
15:33:02 <djahandarie> The proper abstraction is CHAOS AND DEATH.
15:33:16 <augur> where "this space" is "categorical semantics of programming languages"?
15:35:09 <ddarius> Categorists use initial algebras and final coalgebras for most of the recursion needs.  They tend not to be interested in general recursions.  The people modelling PL semantics have a bunch of ways of modelling general recursion such as retractible objects or omega colimits.
15:35:29 <augur> hmm
15:40:01 <augur> so what are some more contemporary techniques for eliminating unnecessary extra structures/recursive calls/etc.?
15:41:02 <Eduard_Munteanu> augur: I think I remember edwardk blogging about Yoneda as a potential optimization (or abstraction for such a thing)
15:41:28 <edwardk> you can abuse the yoneda lemma for fmap fusion if thats what you mean
15:41:37 <edwardk> and codensity to right associate >>='s
15:41:54 <Eduard_Munteanu> Yeah, I don't remember the details, should probably read your stuff more seriously some time :D
15:42:31 <augur> Eduard_Munteanu: i was thinking more along the lines of things that have similar intentions as fold fusion and so forth
15:43:51 <ddarius> @google lightweight fusion by fixed point promotion
15:43:52 <lambdabot> http://www.sic.shibaura-it.ac.jp/~sasano/pub/OhoriSasanoPOPL07.pdf
15:43:52 <lambdabot> Title: Lightweight Fusion by Fixed Point Promotion
15:43:52 <edwardk> augur: look up foldr/build and unfoldr/destroy fusion, stream fusion is more or less a special case of the latter.
15:44:24 <ddarius> edwardk: augur wants to know what the new hotness in these areas are.
15:44:54 <augur> Eduard_Munteanu: im looking, certainly, but thats also why im asking about other catamorphism techniques, because its hard to do fold fusion without a fold :P
15:45:03 <augur> er, other recursion techniques
15:45:54 <augur> ddarius: reading
15:45:59 <edwardk> oh neat. that ohori is the same guy who came up with the nice model for compiling a calculus with records
15:46:16 <ddarius> Atsushi Ohori has a lot of cool papers.
15:46:32 <ddarius> He has a nice one about the printf trick using delimited continuations.
15:46:40 <augur> ddarius: i just want to understand what people think about these topics before i try to make any real use of them
15:46:55 * hackagebot GtkTV 0.2.0 - Gtk-based GUIs for Tangible Values  http://hackage.haskell.org/package/GtkTV-0.2.0 (ConalElliott)
15:46:57 * hackagebot GtkGLTV 0.2.0 - OpenGL support for Gtk-based GUIs for Tangible Values  http://hackage.haskell.org/package/GtkGLTV-0.2.0 (ConalElliott)
15:47:31 <ddarius> augur: Initial algebras (i.e. catamorphisms) and final coalgebras (i.e. anamorphisms) are fundamentally important.  All the rest of the *morphism stuff is mostly useless.
15:48:21 <Eduard_Munteanu> I guess they're rather abstractions or generalisations of fusion tricks that've been already applied. Or did theory present us a new trick we didn't know about?
15:48:29 <AfC> And here I was wondering if conal was still working on Tangible Values
15:48:34 <augur> mostly useless except when its not. i mean, even if its just initial/terminal (co)algebras, i still need to understand how they relate to the problems that im trying to grasp, which often dont seem to be obviously those as such
15:49:34 <conal> :) i keep trying to get back to work on functional guis & graphics and keep choking on mac-brokenness of low-level graphics & UI libs
15:49:38 <Eduard_Munteanu> s/new/completely new/
15:50:04 <augur> i dont think i can properly address the issues im trying to address without understanding why this or that thing that seems relevant isnt, or whatever
15:50:12 <Eduard_Munteanu> (since I don't mean to downplay identifying common patterns)
15:51:56 <ddarius> augur: Initial algebras and final coalgebras seem directly relevant to your concerns.  I don't know why you care at all about fusion or general recursion.
15:52:12 <AfC> conal: I've been furiously spinning my wheels trying to figure out of the UI paradigm you've described is appropriate to the thing I'm working on.
15:52:40 <AfC> conal: in a way, I hope not :) what you've done with TV is pretty advanced and I'm not sure I'm up to it.
15:52:42 <conal> AfC: ah. cool.
15:52:59 <augur> ddarius: fusion because it relates to questions of inherent inefficiencies in certain models of natural language phenomena
15:53:12 <ddarius> TV seems pretty straightforward to me.  Maybe coming up with it wasn't, but the idea in retrospect seems to be.
15:53:34 <augur> ddarius: specifically, im looking to see if there's a way to eliminate them using calculational techniques alone, and fusion is the first thing im considering
15:53:42 <djahandarie> I think TV is pretty neat. And yeah, I agree with ddarius.
15:54:22 <augur> since the process is most naturally described as two folds, one which builds a very big complicated structure, and one which turns that structure into a number.
15:54:42 <conal> ddarius: that's my take as well. so simple in retrospect, but took me a very long time to see it.
15:55:04 <AfC> conal: but the idea of conceptual composibility (on the part of users) is pretty central to what I'm doing, so I'm trying to understand your work as best I can
15:55:21 <conal> AfC: neat!
15:55:29 <augur> conal: whats a good intro to tangibles?
15:55:47 <conal> augur: have you read the TV wiki page?
15:55:50 <conal> @wiki TV
15:55:50 <lambdabot> http://www.haskell.org/haskellwiki/TV
15:55:51 <AfC> conal: anyway, I much appreciated watching the video they did of you (helped understanding the paper you wrote)
15:56:03 <conal> AfC: the google techtalk?
15:56:15 <augur> hm!
16:01:14 * ddarius wonders what happens if he plugs his tablet into his work computer...
16:01:45 <augur> ddarius: basically, im building up a complicated lattice-like graph structure from trees, and then essentially doing memoized recursion over the structure
16:01:46 <mjrosenb> ddarius: it formats both of them :-p
16:02:05 <ddarius> mjrosenb: You've been living in the modern world too long.
16:02:07 <augur> so my first instinct was to see if fusion could eliminate the intermediate structure and yield some performance increase
16:02:54 <augur> i suppose next ill be looking for calculational techniques that eliminate tree recursion
16:03:25 <bytter> speaking of recursion… does anyone know how to get the first X unique elements of a list without recursion?
16:03:46 <ddarius> If X is a known constant, then there's an obvious way.
16:03:56 <Axman6> read only
16:04:07 <Axman6> whoops,. wrong chan
16:04:12 <bytter> ddarius: not constant
16:04:24 <bytter> ddarius: I just want to keep taking elements as long as they are unique
16:04:33 <ddarius> Actually, even if it was a constant I'm wrong because I missed a detail in what you said.
16:04:53 <dolio> Yeah, you need recursion.
16:04:56 <ddarius> bytter: Then the answer is essentially "no" as the list could be infinitely long.
16:05:00 <bytter> e.g. [1, 2, 3, 4, 5, 1, 2, 3] = [1, 2, 3, 4, 5]
16:05:24 <dolio> Wait, you want the first unique prefix or something?
16:05:43 <hpc> bytter: nub . sort?
16:06:01 <dolio> What is the answer for [1,2,1,2,3,4,5]?
16:06:06 <bytter> [1, 2]
16:06:27 <bytter> keep taking elements as long as they are unique
16:06:41 <ddarius> Okay, that's totally different than what I thought you said.
16:06:44 <ddarius> What's X for then?
16:06:46 <bytter> [1, 4, 8, 10, 20, 4] = [1, 4, 8, 10[
16:06:54 <bytter> forget the X :P
16:07:02 <dolio> Then yes, I can think of ways, depending on what you count as recursion.
16:07:02 <hpc> :t foldl
16:07:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:07:14 <hpc> :t foldr
16:07:15 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:07:34 <bytter> hpc: how do you solve this with a cata?!
16:07:40 <djahandarie> bytter, what happened to the 20?
16:07:54 <bytter> [1, 4, 8, 10, 20, 4] = [1, 4, 8, 10, 20]
16:08:03 <bytter> djahandarie: good point
16:08:09 <hpc> bytter: working it out myself atm
16:08:18 <hpc> > foldl f z [1 .. 5]
16:08:19 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
16:08:53 <hpc> > foldr f z [1 .. 5]
16:08:54 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
16:09:03 <djahandarie> You can do it with dynamic programming and an array ;p
16:09:19 <bytter> djahandarie: well, yeah...
16:09:40 <bytter> djahandarie: I was more hoping to have a way of doing this elegantly
16:09:45 <hpc> you could do it with callCC and forM
16:09:53 <djahandarie> Doing anything useful with a list requires a recursion.
16:10:00 <djahandarie> I don't know what dolio is thinking of
16:10:02 <hpc> i think
16:10:11 <dolio> Corecursion.
16:11:26 <bytter> hpc: ?
16:11:31 <bytter> dolio: ?
16:11:40 <djahandarie> ??????????
16:11:52 <hpc> ignore me, im working on a few problems at once now
16:11:55 <ion> ⸘
16:11:57 <drdo> I can't figure out how to write catch for MonadIO, is this implemented somewhere?
16:12:15 <djahandarie> I can't think of the corecursive version so I'll leave the dirty work to dolio :o
16:12:41 <dolio> Just unfold while keeping track of the seen elements.
16:13:00 <bytter> dolio: that involves recursion, no?
16:13:17 <dolio> Which part?
16:13:33 <bytter> dolio: in my current version I just make a membership test in each recursion step
16:13:39 <bytter> with the head
16:13:41 <MostAwesomeDude> @src nub
16:13:41 <lambdabot> nub = nubBy (==)
16:13:47 <MostAwesomeDude> @src nubBy
16:13:47 <lambdabot> nubBy eq []             =  []
16:13:47 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:14:18 <MostAwesomeDude> Ugh, icky quadratic time. But I guess it'll work well enough for nub $ take 5 $ ...
16:14:46 <ddarius> MostAwesomeDude: It can't be anything other than quadratic time for the type that nub has.
16:14:53 <hpc> it'll have to be quadratic time
16:15:12 <hpc> you could get it down to nlogn if you keep a Set around too
16:15:18 <MostAwesomeDude> ddarius: Yeah, I know, and I know that I could use a fancier data structure, but TBH I don't really mind since I'm only taking 5 or so items off the top.
16:15:29 <MostAwesomeDude> I was worried that it was strict, though.
16:15:53 <ddarius> It is strict.
16:17:03 <MostAwesomeDude> It is? I can do things like...
16:17:11 <MostAwesomeDude> > nub $ take 5 [1..]
16:17:12 <lambdabot>   [1,2,3,4,5]
16:17:22 <MostAwesomeDude> Er, wrong way around.
16:17:31 <MostAwesomeDude> > take 5 $ nub [1..]
16:17:32 <lambdabot>   [1,2,3,4,5]
16:17:52 <ddarius> > nub undefined
16:17:53 <lambdabot>   *Exception: Prelude.undefined
16:18:09 <hpc> MostAwesomeDude: nub isn't undefined on infinite lists
16:18:24 <hpc> > take 5 $ sort [1..] -- sort is strict
16:18:28 <lambdabot>   mueval-core: Time limit exceeded
16:18:35 <hpc> well, fully strict
16:18:37 <hpc> if that's a term
16:18:41 <ddarius> It isn't.
16:18:56 <ddarius> Let's say "incremental."
16:19:07 <hpc> ill go with "productive"
16:19:14 <ddarius> "Productive" would be another term, but nubBy isn't actually productive in the technical sense.
16:19:59 <MostAwesomeDude> I learned a term!
16:20:02 <bytter> is there a fold with a predicate?
16:20:29 <ddarius> What does the predicate do?
16:20:29 <MostAwesomeDude> ddarius, hpc : I see the difference between "strict" and "productive," thanks.
16:20:41 <bytter> ddarius: keeps folding if the predicate holds
16:21:55 <bytter> actually…. hmmm… what is the name of the fold that keeps the "intermediate" values?
16:22:04 <MostAwesomeDude> bytter: scanl?
16:22:10 <bytter> MostAwesomeDude: yes, thank you...
16:22:16 <bytter> I think I can solve this with a scan
16:22:44 <bytter> I just scan the elements of an infinite list into a list and take while they are unique
16:22:45 <hpc> :t \p f -> foldr $ \x xs -> if p x then f x xs else xs
16:22:50 <lambdabot> forall a b. (a -> Bool) -> (a -> b -> b) -> b -> [a] -> b
16:26:25 <alistra> :t map
16:26:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:26:41 <alistra> why does it add forall instead of ommiting it like ghc
16:26:47 <hpc> extensions
16:27:22 <alistra> elaborate
16:28:01 <hpc> RankNTypes makes the position of the forall significant
16:29:51 <MostAwesomeDude> @src words
16:29:51 <lambdabot> words s = case dropWhile isSpace s of
16:29:51 <lambdabot>     "" -> []
16:29:52 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:30:03 <alistra> hpc: do you know any good example when using rankNtypes is useful?
16:30:08 <MostAwesomeDude> Hm. Is there no general-case string splitter? Or do I get to build one?
16:30:13 <hpc> @src ST
16:30:14 <lambdabot> newtype ST s a = ST (STRep s a)
16:30:16 <ivanm> MostAwesomeDude: see the split package
16:30:21 <hpc> :t runSt
16:30:22 <lambdabot> Not in scope: `runSt'
16:30:24 <hpc> :t runST
16:30:25 <lambdabot> forall a. (forall s. ST s a) -> a
16:30:41 <ivanm> or if you must, recursively call something like break
16:30:43 <hpc> alistra: that 's' there is some type magic to make sure that STRefs never escape an ST action
16:31:14 <hpc> alistra: in other words, it lets you write pure functions in an internally impure way, and the type system makes sure that you only see the pure parts
16:31:39 <alistra> @hoogle ST
16:31:40 <lambdabot> Prelude type String = [Char]
16:31:40 <lambdabot> Data.String type String = [Char]
16:31:40 <lambdabot> Control.Monad.ST module Control.Monad.ST
16:36:10 <Eduard_Munteanu> alistra: for higher-rank stuff, an example would be multiplate
16:36:25 <Eduard_Munteanu> @hackage multiplate
16:36:25 <lambdabot> http://hackage.haskell.org/package/multiplate
16:36:50 <Eduard_Munteanu> Funnily, it says "Multiplate does not require GADTs and does not require multi-parameter type classes. It *only* requires rank 3 polymorphism." (emphasis added) :)
16:37:03 <djahandarie> Heh.
16:37:22 <hpc> heh
16:37:36 <djahandarie> IIRC, that's because roconnor thought rank-3 polymorphism was more common that the other stuff.
16:37:38 <hpc> that's a very tenuously valid "only"
16:38:27 <Eduard_Munteanu> Well, I guess it's basically one extension if you ignore the rank-2 / rank-n distinction, no?
16:38:41 <alistra> thank god i didn't got the rank3 joke yet
16:39:07 <Eduard_Munteanu> (and perhaps GADTs are hairier to implement wrt unification?"
16:39:13 <Eduard_Munteanu> s/"/)/
16:40:50 * alistra after seeing a lib that does something equally abstract still doesn't see a good example of using rankNtypes
16:42:35 <rostayob> RankNTypes are not hard to implement
16:42:58 <rostayob> you just allow quantification everywhere in explicity type signature, but the algorithm stays - more or less - the same
16:43:00 <Eduard_Munteanu> Well, you asked about rank-N types and I thought you wanted examples other than rank-2, but as far as programming stuff is involved, I'm at loss.
16:43:08 <MostAwesomeDude> I thought the only catch with rank-n types were that you weren't guaranteed to be able to imply every single type.
16:43:15 <MostAwesomeDude> *was that, even.
16:43:25 <rostayob> MostAwesomeDude: higher ranked types are undecidable if that's what you mean
16:43:31 <Eduard_Munteanu> That's probably easier to see if you look at it from a logic point of view.
16:43:52 <rostayob> Eduard_Munteanu: well even in terms of implementation I'd suspect it isn't much code
16:44:23 <Eduard_Munteanu> (might be more apparent in dependent-type programming, if you're mixing proofs with code, dunno)
16:44:32 <rostayob> the biggest change in the data types is that you allow type schemes
16:44:38 <rostayob> inside types
16:44:51 <rostayob> i've always wondered how GHC manages to do all that different sutff
16:44:55 <BMeph> Is "\ma -> f ma >> g ma" a common-enough function to have gained a name?
16:45:06 <rostayob> if i had wrote that it'd be a mess
16:45:08 <Eduard_Munteanu> rostayob: something written by SPJ whose brain explodes must be at least a bit intricate :P
16:45:13 <rostayob> BMeph: what's g? what's g?
16:45:17 <rostayob> *what's f?
16:45:21 <ddarius> It's called liftM2 (>>)
16:45:36 <augur> grr
16:45:40 <alistra> @src liftM2
16:45:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:45:44 <rostayob> Eduard_Munteanu: oh, that error message.
16:45:49 <Eduard_Munteanu> Yes :)
16:45:56 <rostayob> that had to do with existential quantification iirc
16:46:03 <augur> i just recently read a paper that discussed finding efficient algorithms when call graphs have a lot of overlap
16:46:11 <rostayob> mhm...
16:46:12 <BMeph> ddarius: Specifically, it's liftM2 (>>) for a Reader Monad, but still, has it been given a name?
16:46:13 <rostayob> or maybe not
16:46:14 <augur> but i closed it and now i dont know what it was
16:46:15 <augur> >_<
16:46:18 <rostayob> i got that only once
16:46:19 <Eduard_Munteanu> rostayob: not sure, but it appeared in relation to GADTs IIRC.
16:46:23 <rostayob> yeah
16:46:39 <rostayob> yeah but i think that GADTs are a bit nastier then higher ranked types in terms of implementation
16:46:50 <rostayob> well... mhm...
16:46:54 <ddarius> BMeph: What do you think it's name should be?
16:47:02 <Eduard_Munteanu> I guess it's a bit more straightforward to get them in a language that was designed for it... say something with dependent types.
16:47:07 <alistra> @pl \f g ma -> f ma >> g ma
16:47:07 <lambdabot> liftM2 (>>)
16:47:10 <alistra> :O
16:47:25 <Eduard_Munteanu> I get the impression Haskell must jump through hoops to get all these extensions.
16:47:29 <rostayob> Eduard_Munteanu: I don't have experience with dependent types
16:48:03 <BMeph> ddarius: If I had a good name, I'm use it, and ANNOUNCE: it in -cafe, or somewhere. :)
16:48:20 <rostayob> Eduard_Munteanu: no, the "my brain exploded" thing is related to existential quantification
16:48:54 <Eduard_Munteanu> Hm.
16:48:57 * BMeph grumbles about Haskell making folks spend too much time not re-inventing the wheel...
16:50:20 <ddarius> Incidentally, liftA2 would be a much better implementation.
16:51:16 <rostayob> Eduard_Munteanu: i'm too tired to try to figure out what's the problem with let bindings and existential types, but i remember i laughed when I saw that
16:51:24 <hpc> ddarius: less workaroundy silliness from how liftM2 is defined?
16:51:37 <hpc> (in terms of bind)
16:51:56 <Eduard_Munteanu> Yeah, I don't remember the details either.
16:52:05 * Eduard_Munteanu should probably get some sleep as well
16:52:31 <ddarius> hpc: No.  I don't even know what you are talking about.
16:53:22 <ddarius> I suspect it has to do with the fact that let is a letrec.
16:53:34 <ddarius> (And basically that's what allows the type variable to escape.)
16:54:10 <rostayob> ddarius: well but then it should be the same for functions patterns
16:56:03 <rostayob> while function patterns and existentials work fine
16:56:06 <cobra-the-joker> Hey there every one ... any gtk2hs user here ?
16:57:12 <ddarius> rostayob: Why would it be the same?
16:57:28 <rostayob> ddarius: because function declarations are let recs themselves
16:58:08 <ddarius> The problem is the existentially quantified thing be bound by a letrec, not it occurring in a letrec.
16:58:34 <rostayob> let's say that you have 'data Foo = forall a. Show a => Foo a', then something like 'lol (Foo x) = x' would not work, which prevents what you said (the type var escaping)
16:58:55 <ddarius> rostayob: No, x is not recursively bound there.
16:59:03 <ddarius> Something like let (Foo x) = .... in ... won't work.
16:59:15 <ddarius> And I'm pretty sure that is what is disallowed.
16:59:15 <rostayob> ddarius: it is recursively bound
16:59:23 <rostayob> and in fact that piece of code would not work
16:59:26 <ddarius> lol is, not x.
16:59:36 <ddarius> It doesn't even make sense to say x is recursively bound.
16:59:46 <rostayob> ah right
17:00:26 <rostayob> ah, I see what you mean
17:00:56 <ddarius> The "deep" problem is that when you write let Foo x = ... in x, x is in scope in the ... and it should not be.
17:01:07 <ddarius> In mutually recursive cases the problem gets worse.
17:01:13 <cobra-the-joker> please guys ... really need some help in gtk2hs
17:01:17 <rostayob> ddarius: yep, right
17:01:25 <Eduard_Munteanu> cobra-the-joker: just ask the question directly
17:01:40 <ddarius> (Rather it's the type of x, not x itself that is the problem.
17:01:41 <ddarius> )
17:02:09 <Eduard_Munteanu> ddarius: so it trips inference?
17:02:11 <ddarius> Eduard_Munteanu: Damn you Eduard_Munteanu, why haven't you helped me with a problem I haven't told you about or asked you to help me with?
17:02:16 <cobra-the-joker> Eduard_Munteanu, i am making a minesweeper game in haskell ... but i cant figure out how i am gonna access other buttons with the event of one button
17:02:20 <Eduard_Munteanu> :)
17:02:21 <rostayob> ddarius: still, wouldn't be possible to employ some kind of protection like the one when trying to write 'foo (Foo x) = x'?
17:02:32 <ddarius> Eduard_Munteanu: It has nothing to do with inference.  It's just the semantics of existentials.
17:02:33 <rostayob> (which doesn't compile, just tried)
17:02:47 <Eduard_Munteanu> cobra-the-joker: you can pass the xml stuff around if you're using a Glade file.
17:03:05 <ddarius> rostayob: You could have a non-recursive let, but we already have one.  It's called case.
17:03:10 <Eduard_Munteanu> Or that's what I remember.
17:03:15 <kallisti> any suggestions on how to make this algorithm faster? As of this writing, Python's closures are limited to a single expression. This may be a syntactic problem rather than a semantic one, but it is still something of an annoyance.
17:03:17 <rostayob> ddarius: fair enough :P
17:03:19 <kallisti> By overloading the () operator, it's possible to make closure-like objects even in C++. But if you try this, you'll soon appreciate why, in most languages, closures are garbage collected: if you have to explicitly reason about when the free variables will no longer be needed, you're not much better off from using function pointers.
17:03:24 <kallisti> er... oops
17:03:45 <kallisti> wrong paste. :P
17:03:47 <Eduard_Munteanu> cobra-the-joker: in any case, you could pass around the buttons yourself directly
17:03:57 <kallisti> Any suggestions on how to make this algorithm faster? http://sprunge.us/SgUL
17:03:59 <cobra-the-joker> Eduard_Munteanu, yes using a glade file ... but all i know that i use it in declaration ..like toggleButton <- xmlGetWidget xml castToScaleButton "togglebutton1"
17:04:17 <cobra-the-joker> Eduard_Munteanu, how is that ?
17:04:22 <ddarius> rostayob: That function doesn't work because it blatantly lets the type of x escape.
17:04:30 <ddarius> You'd want f (Foo x) = ().
17:05:08 <Eduard_Munteanu> cobra-the-joker: suppose your event handler takes one more argument (either the xml or a list of the other buttons etc.). Then you register your event handler and partially apply that argument.
17:05:44 <Eduard_Munteanu> So instead of registering 'foo' as the event handler, you use 'foo xml'.
17:05:59 <rostayob> ddarius: exactly, so you could do the same with 'let (Foo x) = ... in something', where in the ... you'd always fail to unify the type of x with anything
17:06:02 <rostayob> *everything
17:06:13 <cobra-the-joker> Eduard_Munteanu, sorry i dont understand .. can you give an example ?
17:06:26 <Eduard_Munteanu> I don't remember the API off the top of my head :/
17:06:48 <cobra-the-joker> :(
17:08:07 <Eduard_Munteanu> cobra-the-joker: here's something a bit more abstract but simpler. Suppose you want to map a function over a list, and you wonder how your mapping function could access some other thing you defined in the caller.
17:08:12 * ddarius wonders if SHE adds free existentials and if not, how hard it would be to add.
17:08:15 <Eduard_Munteanu> What do you do?
17:08:54 <rostayob> ddarius: SHE?
17:08:58 <cobra-the-joker> hmmm
17:09:06 <ivanm> rostayob: a pre-processor
17:09:09 <ivanm> adds some functionality
17:09:16 <ivanm> Strathclyde Haskell Extensions or something
17:09:22 <rostayob> oh, that
17:09:32 <rostayob> anyway, going to bed
17:10:02 <Eduard_Munteanu> cobra-the-joker: are you comfortable with partial application?
17:10:11 <Eduard_Munteanu> (I'm asking because that's the answer.)
17:10:32 <cobra-the-joker> Eduard_Munteanu, i am a very begginer in haskell ... just made a gtk2hs calculator
17:10:45 <shachaf> Are you comfortable with regular application?
17:10:53 <cobra-the-joker> lol
17:10:57 <shachaf> Because that's partial application.
17:11:13 <cobra-the-joker> maybe
17:11:32 <cobra-the-joker> i really dont know what a partial application is !
17:12:03 <shachaf> ddarius: Free existentials?
17:12:21 <mike-burns> How do we pronounce (<|>) ?
17:12:28 <Eduard_Munteanu> > let f :: Int -> Int -> Int; f a b = a * b in map (f 2) [1,2,3,4]
17:12:30 <lambdabot>   [2,4,6,8]
17:12:50 <cobra-the-joker> aha i know that syntax
17:12:54 <Eduard_Munteanu> mike-burns: in my mind, all those are "hrmphs"
17:13:00 <shachaf> mike-burns: "grunt".
17:13:03 <mike-burns> Hahah.
17:13:11 <mike-burns> These answers are way better than I was hoping.
17:13:16 <cobra-the-joker> lol
17:13:22 <ddarius> Enhancement.
17:13:25 <ivanm> mike-burns: why does one need a pronounciation?
17:13:31 <Eduard_Munteanu> cobra-the-joker: now suppose that wasn't '2' but something defined in / obtained by the caller, just like your xml or buttons
17:13:35 <ddarius> shachaf: exists
17:13:43 <mike-burns> ivanm: Because I read code aloud to myself absent-mindedly.
17:13:45 <cobra-the-joker> Eduard_Munteanu, aha
17:14:20 <cobra-the-joker> Eduard_Munteanu, i am trying something now
17:14:48 <exFalso> good evening, how would one go about contributing to a hackage package?
17:15:03 <exFalso> as in i want to add some functionality
17:15:06 <shachaf> exFalso: Ask the maintainer.
17:15:21 <mike-burns> exFalso: Grab the source from the repo as listed on Hackage, make a patch, submit it to the author.
17:15:35 <exFalso> shachaf: thanks! (i thought there is a standardised way)
17:15:36 <mike-burns> If it's on Github, use the pull request and fork functionality.
17:15:59 <exFalso> mike-burns: no repo unfortunately
17:16:05 <mike-burns> Ah.
17:16:06 <shachaf> ddarius: Ah, without a constructor?
17:16:07 <Eduard_Munteanu> mike-burns: good thing we aren't talking about this IRL, but on IRC, I really have no clue what people do when they actually have to talk about it
17:16:22 <ddarius> shachaf: Yes.
17:16:33 <shachaf> Seems like it would be tricky to infer.
17:16:38 <mike-burns> Eduard_Munteanu: Exactly; I like to talk to other people face-to-face and <|> is going to be tricky.
17:16:41 <Eduard_Munteanu> I guess "ahem applied to hrmph gives hum" doesn't cut it.
17:16:48 <shachaf> I guess you can require people to give the type explicitly.
17:16:52 <mike-burns> It works when pointing to a whiteboard.
17:16:56 <shachaf> Is SHE type-aware?
17:17:37 <mike-burns> I guess "alternatively" works for <|> .
17:17:48 <shachaf> mike-burns: Or "or".
17:17:52 <mike-burns> Yeah.
17:24:50 <ddarius> shachaf: The scheme I'm considering as a potential approach would fail to have: (undefined :: exists a. a -> a) :: exists a. a but I think it would otherwise work well enough.
17:27:28 * Eduard_Munteanu wonders if stuff like (<|>) should be read just like the inner symbol, but in a distinctive manner.... pipe + some prefix/suffix?
17:27:54 <ddarius> Eduard_Munteanu: No.
17:28:26 <MostAwesomeDude> Hey, I'm deploying a Yesod app to a slightly old (Debian Lenny) server. What's the recommended way to get a modern-enough Haskell setup onto there?
17:28:39 <MostAwesomeDude> The GHC in Lenny is 6.8.2 and there is no Haskell Platform available.
17:29:36 <hpc> MostAwesomeDude: install the platform from haskell.org, and hope your system isn't so old that it can't install
17:29:40 <ddarius> Download the version of GHC that you want and install it.  There's a script that will download and install the libraries cabal-install needs.  Once you have cabal-install, simply cabal install whatever else you need with whatever versions.
17:29:48 <hpc> or that
17:30:30 <MostAwesomeDude> So I should grab a GHC *source* tarball, build it (and then go mow a lawn, watch a movie, solve world hunger, etc.) and then cabal-install from there to some local prefix?
17:30:42 <ddarius> MostAwesomeDude: No, not if you can avoid that.
17:30:51 <ddarius> If you have to, then you have to.
17:31:09 <hpc> the only people that should ever need to compile ghc are the devs
17:31:29 <MostAwesomeDude> Well, this is a VPS that I can't upgrade, can't install the full platform dependencies (GL, etc.), and it's too old for me to statically link my app on another box and copy it over. (Both GMP and FFI are too old!!!)
17:31:30 <Eduard_Munteanu> Well I guess you have a point for stuff that already has an established name, but if you're introducing a new symbol to an audience you might want to avoid introducing a completely different name as well.
17:32:06 <ddarius> MostAwesomeDude: I don't see how any of that implies that you have to build GHC from source.
17:32:17 <MostAwesomeDude> I grabbed the GHC 7.0.4 binary tarball, but it is too new to be installable; it was linked against a far-newer glibc and so I can't install from it.
17:32:59 <ddarius> Then use an older GHC or I guess you will have to build from source and hope that it works.
17:33:18 <ddarius> (Or install a new glibc)
17:33:54 <MostAwesomeDude> ...Yeah, building GHC sounds like the least painful, if perhaps not the quickest, route. :T
17:34:06 <ddarius> Sounds like it.
17:34:23 <ddarius> GHC doesn't take all that long to build.
17:34:28 <MostAwesomeDude> Oh well, that's life. Thanks for your help.
17:34:41 <hpc> ddarius: doesn't it take a while if you try to bootstrap it?
17:34:49 <MostAwesomeDude> Hm. Is there a reason to avoid GHC 7.2.x as long as I'm doing this?
17:35:03 <ddarius> Arguably, yes.
17:35:21 <ddarius> Especially if you have no need for anything in 7.2.
17:36:02 <MostAwesomeDude> Okay then. I'm not super-eager to run the bleeding edge here. :3
17:36:13 <Eduard_Munteanu> Is there really no sane way to statically link stuff like GMP? It's a private build after all.
17:36:43 <ddarius> I'm pretty sure you can do that in a fairly straightforward manner.
17:36:56 <MostAwesomeDude> GMP doesn't like being statically linked. I could convince it, but FFI *never* statically links, and I don't have the time to fight with it.
17:36:57 * hackagebot gloss 1.6.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.6.0.1 (BenLippmeier)
17:36:59 * hackagebot gloss-examples 1.6.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.6.0.1 (BenLippmeier)
17:37:50 <bytter> ARGH… found it! (reverse . last . takeWhile (\x -> head x `notElem` tail x)) (drop 1 (scanl (\x y -> y : x) [] [1, 2, 3, 4, 1]))
17:37:55 <bytter> can someone help me optimize this :P
17:38:09 <shachaf> bytter: What are you trying to do?
17:38:16 <shachaf> > (reverse . last . takeWhile (\x -> head x `notElem` tail x)) (drop 1 (scanl (\x y -> y : x) [] [1, 2, 3, 4, 1]))
17:38:20 <bytter> shachaf: let me grap the history
17:38:21 <lambdabot>   mueval: ExitFailure 1
17:38:22 <lambdabot>  mueval: Prelude.undefined
17:38:24 <shachaf> > (reverse . last . takeWhile (\x -> head x `notElem` tail x)) (drop 1 (scanl (\x y -> y : x) [] [1, 2, 3, 4, 1]))
17:38:29 <lambdabot>   mueval-core: Time limit exceeded
17:38:37 <ddarius> bytter: My first suggestion is to learn about pattern matching.
17:38:53 <shachaf> That's a good suggestion.
17:39:08 <bytter> ddarius: that's a generic suggestion :P
17:39:42 <shachaf> bytter: What, you want suggestions for how to optimize this specific one-liner?
17:39:47 <shachaf> > (reverse . last . takeWhile (\x -> head x `notElem` tail x)) (drop 1 (scanl (\x y -> y : x) [] [1, 2, 3, 4, 1]))
17:39:51 <lambdabot>   mueval-core: Time limit exceeded
17:40:10 <shachaf> > [1..4] -- Maximum optimization.
17:40:11 <ddarius> It's a generically good suggestion that is specifically relevant, albeit less relevant to the performance (though it will have some minor impact.)
17:40:12 <lambdabot>   [1,2,3,4]
17:40:15 <bytter> sorry, this was a problem I posted here about one hour ago
17:40:24 <bytter> given a list of elements
17:40:25 <ddarius> Maximumer optimization: [1,2,3,4]
17:40:29 <Eduard_Munteanu> > fix fix
17:40:30 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:40:32 <bytter> find the first unique elements of that list
17:40:33 <Eduard_Munteanu> > fix id
17:40:36 <shachaf> ddarius: I was optimizing for space.
17:40:37 <lambdabot>   mueval-core: Time limit exceeded
17:40:42 <Eduard_Munteanu> Another optimization :P
17:40:56 <Eduard_Munteanu> (according to the result above)
17:41:05 <MostAwesomeDude> > nub [1, 2, 3, 4, 1]
17:41:06 <lambdabot>   [1,2,3,4]
17:41:32 <bytter> MostAwesomeDude: that's different… consider this: [1, 2, 3, 4, 3, 10] -> [1, 2, 3, 4] and not [1, 2, 3, 4, 10]
17:42:22 <MostAwesomeDude> bytter: Hm. What's the predicate, exactly?
17:42:44 <bytter> MostAwesomeDude: keep taking elements as long as they are unique… stop once you find a repeated element
17:44:21 <ddarius> bytter: If you care about performance, and given the level of Haskell you seem to be at, I would just write the obvious recursive function.
17:44:33 <bytter> ddarius: sorry, not performance, just conciseness here
17:44:43 <bytter> ddarius: and yeah, recursive is obvious
17:44:54 <bytter> ddarius: i'm trying to wrap my head around non-recursive solutions
17:45:05 <djahandarie> Your solution is recursive
17:45:13 <djahandarie> Just not explicitly
17:45:16 <bytter> djahandarie: true
17:46:22 <bytter> ddarius: speaking about "level of haskell", any obvious blunt in my solution? :P
18:13:34 <cobra-the-joker> Eduard_Munteanu, yes ... i can access different widgets using xml ... thanx for the info
18:14:11 <Eduard_Munteanu> cobra-the-joker: you might want to go through LYAH if you feel like reading a book
18:14:14 <Eduard_Munteanu> @where lyah
18:14:15 <lambdabot> http://www.learnyouahaskell.com/
18:14:22 <Eduard_Munteanu> @where rwh
18:14:22 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:14:29 <Eduard_Munteanu> (RWH later on)
18:14:52 <cobra-the-joker> rwh is the one our instructor gave us
18:15:39 <Eduard_Munteanu> Some say it isn't really friendly as a first material. If so, keep LYAH in mind if you have difficulties with it.
18:16:02 <Eduard_Munteanu> (or want a second take on a topic)
18:17:22 <cobra-the-joker> aha
18:50:10 <hpaste> “Zac Slade” annotated “less imperative style” with “less imperative style -extraneous output” at http://hpaste.org/55748#a55787
19:31:20 <lpsmith> :t \f g -> fmap f . g
19:31:20 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
19:31:39 <lpsmith> is there a nice idiom for that?
19:44:11 <ddarius> @pl \f g -> fmap f . g
19:44:11 <lambdabot> (.) . fmap
19:47:55 <JoeyA> > let f a b c = a+b+c in ((((+10) .) .) .) f 1 2 3
19:47:57 <lambdabot>  Terminated
19:48:15 <ski> > let f a b c = a+b+c in ((((+10) .) .) .) f 1 2 3
19:48:16 <lambdabot>   16
19:48:22 <ski> @type (.:)
19:48:22 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:48:25 <JoeyA> lambdabot likes you better, it seems
19:50:01 <parcs`> > isUpper '∀'
19:50:01 <ski> > let f a b c = a+b+c in ((10 +) .:: f) 1 2 3
19:50:02 <lambdabot>   can't find file: L.hs
19:50:02 <lambdabot>   16
19:50:08 <parcs`> > isUpper '∀'
19:50:10 <lambdabot>   False
19:50:14 <JoeyA> > let f a b c = a + b + c in fmap (fmap (fmap (+10))) f 1 2 3
19:50:14 <lambdabot>   16
19:50:33 <JoeyA> @type .::
19:50:33 <lambdabot> parse error on input `.::'
19:50:35 <parcs`> :t undefined :: forall ∀. ∀
19:50:36 <lambdabot> parse error (possibly incorrect indentation)
19:50:39 <ski> @type (.::)
19:50:40 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:50:41 <ski> @type (.:::)
19:50:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
19:50:54 <JoeyA> @info .::
19:50:54 <lambdabot> (.::)
19:50:56 <ski>   (.:) = (.) . (.)
19:51:00 <ski>   (.::) = (.) . (.) . (.)
19:51:10 <ddarius> (.::) = (.:) . (.)
19:51:14 <ski> (both are `infixr 9')
19:51:22 <JoeyA> Where are they defined?
19:51:31 <JoeyA> @hoogle (.::)
19:51:31 <lambdabot> No results found
19:51:33 <parcs`> functors package
19:51:34 <ski> `(.:)' is defined in lambdabot
19:51:45 <ksf> http://dslab.epfl.ch/pubs/crashonly/
19:51:52 <ski> i defined `(.::)' and `(.:::)' privately, just a minute ago
19:52:05 <ddarius> ksf: You're way behind the times.
19:52:18 <ksf> I suggest every haskell program that has cross-invocation state use that paradigm.
19:52:34 <ksf> ddarius, nah. I got up at 03:00.
19:52:53 <ddarius> It is a cool paper though.
19:52:57 <parcs`> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap  fmap fmap
19:52:58 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:53:00 <ddarius> 
19:53:03 <parcs`> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap  fmap fmap fmap fmap fmap fmap
19:53:04 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:53:11 * ski wonders whether that is related to Armstrong's paper
19:53:12 <ddarius> For (.) . (.) . (.)
19:53:36 <ddarius> Armstrong's thesis is a good read too.
19:53:56 * ski couldn't recall whether it was his thesis, or not
19:54:00 <ksf> ddarius, I do know of that paper for some time, btw. It just popped up again, so I spammed reddit with it and now #haskell.
20:00:51 <augur> waha
20:00:58 <augur> found what i needed :)
20:01:14 <ddarius> Yay UTF8, now looking at binary files means reading a bunch of Chinese.
20:01:53 <tensorpudding> instead of random control characters?
20:02:08 <tensorpudding> i don't see how that is an improvement or not
20:02:29 <monochrom> it helps you learn chinese.
20:05:11 <tensorpudding> the right way to learn chinese is to associate the ideographs with unicode points, right
20:05:50 <ddarius> Well.  I found out how to make Sql Server Analysis Services consistently dump core.
20:06:30 <tensorpudding> reproducible bugs are fixable, in theory
20:06:39 <BMeph> Cinsistency is the key to good computer science! ;þ
20:07:07 <ddarius> Let's see if I can make this bug unreproducible
20:10:59 <hpaste> tsuraan pasted “strange parameter list” at http://hpaste.org/55788
20:11:35 <tsuraan__> can somebody explain to me what the (BI.toForeignPtr -> (bs,offset,len)) "parameter" is doing in that function's parameter list?
20:13:10 <tsuraan__> is that some weird way of calling a function on a paremeter and getting the results back, right in the function's argument list?  is that a sane/normal thing to do?
20:13:17 <tsuraan__> *parameter*
20:14:18 <lpsmith> ddarius, I found a corrupted NTFS system that would make Vista BSOD if you plugged it in to a hot-swap device
20:15:10 <tsuraan__> hm, I guess it's a ViewPattern.  I'm still curious whether it's a sane thing to do
20:22:57 <ddarius> tsuraan__: It is a ViewPattern (and a fairly recent extension) and it's quite sane.  If this BI thing wasn't abstract, you could probably get those fields by pattern matching.
20:23:28 <ddarius> ViewPatterns allow you most of the convenience of pattern matching without having to expose the internals of your data type.
20:24:15 <lpsmith> I dispute "most",  but certainly "a sizable fraction of"
20:24:33 <tsuraan__> ok, cool
20:25:24 <lpsmith> JoeyA, I noticed your haskell-libpq fork, you may be interested in this:  https://github.com/lpsmith/postgresql-simple
20:25:26 <ddarius> lpsmith: The only thing it doesn't give you is the ability to simply swap out a concrete type for an abstract type (and, I guess, it is a bit more verbose to use.)  In exchange, you don't need view declarations and you can use any function.
20:26:54 <The_Journey> hi, I'm trying to follow the State Monad from LYAH but I keep getting the error "Not in scope: data constructor `State'" even though I imported Control.Monad.State, can anyone help me?
20:29:13 <lpsmith> yeah, I definitely like "can use any function".  But what exactly do you mean by swapping out a concrete type for an abstract type?
20:30:10 <ddarius> If I write data Foo = Bar Int; f (Bar i) = i and later decide that I want Foo to be abstract, I need to change all the callers.
20:30:51 <lpsmith> oic, referring to pattern matching, not view patterns
20:31:09 <lpsmith> you could make foo an abstract type with an appropriate use of view patterns
20:32:12 <ddarius> Yes, but I have to know that ahead of time.
20:32:14 <ski> The_Journey : `Control.Monad.State' was recently changed. instead of `State' in an expression, use `state'
20:32:18 <ddarius> Or I have to change all callers.
20:32:22 <ddarius> With views I would not.
20:32:47 <Sgeo> ski, wait what?
20:32:49 <Sgeo> :t state
20:32:50 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:32:53 <The_Journey> ski: uhhh... I'm not following
20:33:03 <ski> The_Journey : and instead of a pattern `State <pat>' you can use a view pattern `runState -> <pat>' -- or just (in some cases) move the `runState' to the uses
20:33:07 <Sgeo> Oh, for making a State out of a function similar to it
20:33:33 <ski> The_Journey : well, which particular code snippet were you having trouble with ?
20:33:46 <ski> (it may be easier to see what i mean, with a concrete example)
20:33:50 <The_Journey> ski: the stack from LYAH for stateful computation
20:34:02 <lpsmith> Ok,  now I get what you are saying.   View patterns also have the disadvantage that it's unlikely to be the first thing people start using,  due to the extra syntactic overhead.
20:34:02 <ski> do you have a link to that ?
20:34:11 <The_Journey> ski: http://learnyouahaskell.com/for-a-few-monads-more
20:34:33 <ski> lpsmith : also, exhaustiveness and non-overlapping is hard to do for view patterns
20:35:14 <tigger_> im looking at the type of stuarry, which is data STArray s i e , and says s: the state variable argument for the ST type. I'm having a hard time understanding what that's supposed to mean, any insight would be appreciated
20:35:26 <lpsmith> ski, but that's true of most generalizations of pattern matching...
20:35:43 <lpsmith> view patterns or user-definable views
20:35:45 <ski> The_Journey : which part ?
20:35:53 <ski> The_Journey : are you looking around `return x = State $ \s -> (x,s)' ?
20:35:54 <lpsmith> (not to mention optimization and compilation...)
20:36:05 <The_Journey> ski: yea
20:36:21 <ski> The_Journey : instead of `return x = State $ \s -> (x,s)', you should now do `return x = state $ \s -> (x,s)'
20:36:40 <ski> and instead of
20:36:42 <ski>   (State h) >>= f = State $ \s -> let (a, newState) = h s
20:36:43 <lpsmith> tigger_, ignore the "s",  i is index, e is element
20:36:48 <ski>                                       (State g) = f a
20:36:49 <lpsmith> (as a first approximation)
20:36:50 <The_Journey> ski: the type of the pop and push functions would still be the same right?
20:36:55 <ski>                                   in  g newState
20:37:02 <ski> The_Journey : yes
20:37:21 <JoeyA> lpsmith: Interesting, looking at it (postgresql-simple) now.
20:37:23 <ski> you can do
20:37:27 <JoeyA> Noticed a typo: "A mid-level client library for the MySQL database, aimed at ease of"
20:37:37 <JoeyA> (in Database.PostgreSQL.Simple)
20:37:49 <tigger_> lpsmith: hmm okay, why si that there exactly, out of curiosity?
20:38:00 <ski>   sh >>= f = state $ \s -> let (a, newState) = h s
20:38:09 <ski> er, actually
20:38:10 <lpsmith> tigger_, "s" is what's known as a "phantom type".   It has no bearing on the data structure itself,  it's just a type-level trick to make sure that mutable references can't escape a ST computation
20:38:14 <ski>   sh >>= f = state $ \s -> let (a, newState) = runState sh s
20:38:18 <ski>                              sg = f a
20:38:26 <ski>                          in  runState sg newState
20:38:37 <tigger_> lpsmith: okay great thanks! thats what I was looking for!
20:39:01 <lpsmith> JoeyA, yeah,  that's to be expected,  it's based off of mysql-simple
20:39:09 <eyebloom> Does anyone know if videos were made of the Haskell Symposium 2011?
20:40:03 <ski> The_Journey : did you get what i mean -- or should i paste it ?
20:40:06 <lpsmith> but unlike pgsql-simple, my postgresql port is libpq based.  Also I've been using pgsql-simple in production for about two months ( something not too critical) and discovered that postgresql sped up one of the applications by a factor of ~40.
20:40:22 <The_Journey> ski: can you paste it? thanks
20:40:45 <JoeyA> lpsmith: Did the libpq package turn into postgresql-libpq ?
20:41:12 <lpsmith> JoeyA, yeah I've modified a bunch of things in haskell-libpq
20:41:19 <lpsmith> also, added large object support
20:41:44 <JoeyA> lpsmith: Ah, so postgresql-libpq is a fork, then?
20:41:47 <lpsmith> yeah
20:43:22 <lpsmith> I too started out by declaring all ffi imports safe,  and then reading the libpq source to decide which ones could be unsafe.   But the more I've learned in the interveneing months the more I realize I was probably overly conservative with the unsafe calls,  and that Grant Monroe probably had them pretty close to right.
20:44:44 <JoeyA> lpsmith: Technically, just about all of them should be safe, including PQgetvalue (probably called more than the other functions)
20:45:20 <lpsmith> Semantically, they can all be either safe or unsafe,  and many of them won't block
20:45:24 <JoeyA> Looking at the source of PQgetvalue, it calls a list of error handlers when the dimensions are off.
20:45:52 <JoeyA> Blocking or not, if any of those event handlers calls into Haskell...
20:48:01 <lpsmith> yeah,  so don't get the dimensions off :)
20:48:12 <lpsmith> so you might block a capability for an bit longer than you should if you get the dimension off,  but that'll lead to bad performance if you use it wrong, but it won't lead to deeper problems
20:51:06 <lpsmith> how do you set the handlers though?
20:51:17 <JoeyA> I don't know.  I think that's internal.
20:51:28 <lpsmith> so it won't call back into haskell
20:51:29 <JoeyA> But there might be a function floating around that lets you set a custom error handler.
20:52:03 <JoeyA> lpsmith: In my Database.PQ.Utils,  I was all proud of my clever use of Applicative so columns can be named in a result conversion, but column names are only looked up once per result set.  Does postgresql-simple have a facility for parsing a PQ.Result using column names?
20:52:05 <lpsmith> I haven't seen it,  not in the part that libpq binds anyhow
20:52:20 <JoeyA> e.g. (,) <$> columnNotNull "x" fromInt <*> columnNotNull "y" fromInt
20:52:55 <lpsmith> JoeyA, yeah, you can convert it to a RawResult and then do as you please, though that part of the API isn't quite as nice as I'd like yet.
20:54:36 <JoeyA> Whoops
20:54:50 <JoeyA> Why on earth would Ctrl+W mean "close the current window" ?!
20:55:21 <lpsmith> that's what most browsers use to close a tab/window
20:55:30 <lpsmith> or at least, Chrome and Firefox
20:55:49 <JoeyA> I've done that a few times since I started using Vim.
20:56:08 <JoeyA> Terminal programs usually treat Ctrl+W as "delete the previous word"
20:58:33 <JoeyA> On the other hand, Ctrl+C in the terminal isn't quite as benign
20:58:54 <JoeyA> For example, it toggles case sensitivity in cscope.
20:59:09 <JoeyA> Oh, and it sends SIGINT to the current process.
20:59:45 <JoeyA> lpsmith: Anyway, how does postgresql-simple handle null values in result conversion?
21:00:02 <lpsmith> Look in Param and Result
21:00:05 <hpaste> ski pasted “\State -> state” at http://hpaste.org/55789
21:00:13 <ski> The_Journey ^
21:00:14 <JoeyA> Ah, I guess instance (Result a) => Result (Maybe a) where
21:00:18 <lpsmith> Nothing can be null, except for Maybe types
21:00:32 <ski> > null Nothing
21:00:33 <lambdabot>   Couldn't match expected type `[a]'
21:00:33 <lambdabot>         against inferred type `Data.Mayb...
21:00:34 <The_Journey> ski: thank you very much :D
21:01:33 <lpsmith> In which case "Nothing" is null.   Of course if you define a conversion for your own type,  you can handle null in any way you see fit
21:02:29 <JoeyA> I wish I would have started my current project at least six months later than I did...
21:03:41 <lpsmith> There is a lot that the -simple API leaves to be desired,  but I think it's a step in the right direction
21:03:55 <JoeyA> I agree.
21:04:45 <JoeyA> What's a simple, real-world example where you would want to select a subset of a SQL table, and be notified any time that subset changes?
21:05:02 * BMeph would rather finish it six months later, and start it six months earlier...
21:05:07 <lpsmith> Probably the next thing I'm going to do is add a longstring-like o that embedding SQL queries in haskell isn't quite so onerous
21:05:25 <JoeyA> BMeph: :-)
21:06:51 <lpsmith> I dunno
21:06:57 <ski> "Null References: The Billion Dollar Mistake" by Tony Hoare in 2009-08-25 at <http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake>
21:07:21 <lpsmith> SQL null is different.  Probably not any better,  but different :)
21:08:04 <lpsmith> for example,  "x == a or x != a" isn't guaranteed to be true, thanks to sql null
21:08:53 <ski> well, the important thing is that it should not be false
21:08:58 <JoeyA> && isn't guaranteed to be associative
21:09:16 <lpsmith> yeah, it's guaranteed not to be false
21:09:49 <lpsmith> if x is null, then the expression is null, which is not true and not false
21:11:40 <ski> of course, `not (x == a or x != a)' should be false
21:15:04 <lpsmith> nope,  that's also "null" if x == null
21:15:39 <ski> @djinn Not (Either a (Not a))
21:15:39 <lambdabot> -- f cannot be realized.
21:16:00 <ski> @djinn NotNot (Either a (Not a))
21:16:00 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
21:16:10 <ski> @djinn Either a (Not a)
21:16:10 <lambdabot> -- f cannot be realized.
21:16:30 * ski . o O ( "quodlibet" )
21:46:58 * hackagebot wai-logger 0.1.2 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.1.2 (KazuYamamoto)
21:51:59 * hackagebot wai-logger-prefork 0.1.2 - A logging system for preforked WAI apps  http://hackage.haskell.org/package/wai-logger-prefork-0.1.2 (KazuYamamoto)
21:52:01 * hackagebot ghc-mod 1.0.5 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.0.5 (KazuYamamoto)
21:54:26 <akosch> I'm having a problem with Takusen. If I want to process query results with an iteratee and the query returns 50 columns: do I really need to define an iteratee with 50 input arguments? Can't I solve this with a list somehow?
21:59:28 <Sgeo> "For the hell of is" is an acceptable reason to abuse typeclasses, right?
22:00:39 <shachaf> Sgeo: Not for you.
22:02:43 <Sgeo> shachaf, I assume you're joking
22:08:00 <Sgeo> {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, UndecidableInstances, OverlappingInstances #-}
22:09:22 * Sgeo thinks he can only get this thing to work on isomorphisms, but not certain
22:10:17 <ski> yikes, `OverlappingInstances'
22:12:01 <Sgeo> I've written this particular abuse before (didn't get up to the overlapping instances bit yet though)
22:12:16 <Sgeo> Now I'm rewriting it for the sake of doing so, and doing the OverlappingInstances bit
22:12:26 <Sgeo> Why yikes for OverlappingInstances?
22:14:35 <Sgeo> As long as it doesn't decide it's incoherent, I feel safe. Which is different from being safe.
22:21:16 <sopvop> So, I'm writing a compiler for c-like language, and want annotations on ast. It would be nice to make annotations of different types for different domains (Statements, expressions, programm etc.). The best solution I've found so far is cram all the data into single GADT. Kind of like here http://pseudo.fixme.fi/~opqdonut/blog/Attribute_Grammars__GADTs_and_MonadFix__part_2_.html . Cramming everythig into single GADT does not look nice. Another approach for 
22:22:54 <sopvop> So, anyone have any good links to read about ast representation in haskell. I've searched the net for two days now, but only found these two links
22:23:23 <sopvop> ^ subst . ?
22:25:43 * Sgeo ignores GHC's suggestion of how to fix this code in favor of a better one
22:26:17 <NihilistDandy> sopvop: You cut off at "Another approach for"
22:26:33 <sopvop> damn
22:26:40 <sopvop> Another approach for annotations is like mentioned in comment by Edward Khmett in here http://pchiusano.blogspot.com/2010/06/spj-trick-for-typesafe-adt-annotations.html . But I can't make it use different types of annotaions for different domains.
22:27:48 <hpaste> sopvop pasted “another ast annotation” at http://hpaste.org/55790
22:27:55 <sopvop> The thing from another approach is this
22:31:58 * hackagebot wai-app-file-cgi 0.4.4 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.4.4 (KazuYamamoto)
22:33:32 <juhp> donri, do you think it is too aggressive targeting ghc-7.4 for Fedora 17?
22:34:20 * Sgeo is partially shocked his thing compiled
22:34:46 <tehgeekmeister> how does one compose two enumeratees using the enumerator library?
22:36:58 * hackagebot mighttpd2 2.4.2 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.4.2 (KazuYamamoto)
22:44:04 <hpaste> 222 pasted “111” at http://hpaste.org/55791
22:48:27 <juhp> hmm HTTP.cabal is now in dos encoding
22:48:32 <juhp> ah fixed in 4000.2.2
22:56:31 * Sgeo does not seem to be smart enough to guess whether the instance he's writing requires IncoherentInstances or not
22:56:34 * Sgeo hopes not
22:57:57 <Sgeo> I can tell from the type that I'm going to need to call my function twice
22:58:02 <Sgeo> Thanks Haskell for making that obvious
23:06:59 <hpaste> Sgeo pasted “Overlap not really ok?” at http://hpaste.org/55793
23:07:17 <Sgeo> Is it not able to decide which instance to use?
23:07:36 <sopvop> It seems the internets can't help me. Will stick to gatds then.
23:08:44 <rwbarton> I wouldn't be able to decide which instance to use.
23:08:57 <tehgeekmeister> why is it not a mistake that splitWhen just deletes subsequences in Data.Enumerator.Text rather than turning a Text into a list of Texts?
23:09:32 <Sgeo> rwbarton, is there a way to give priority to one instance over another?
23:09:56 <rwbarton> not that I know of, though I never use OverlappingInstances so I don't have this problem
23:10:32 <rwbarton> there is probably some awful Oleg-ish trick, actually
23:10:48 <rwbarton> but even if I knew what it was I wouldn't endorse using it!
23:11:49 <Sgeo> I think my entire code may be considered by some to be an awful trick
23:11:55 <rwbarton> (but if you really must know, look up TypeEq)
23:12:03 <Sgeo> http://hpaste.org/55792
23:13:48 * Sgeo wonders if he could simplify the code a bit by having cases of AtoB for non a and b
23:15:06 <rwbarton> you definitely don't want the instance on line 12
23:15:46 <Sgeo> Why not?
23:16:08 <rwbarton> 2:50 am so left as an exercise
23:16:27 <rwbarton> how about the line 23 instance plus instance AtoB a b c c where convertFunc _ _ = id
23:16:43 <rwbarton> also the line 8 instance
23:16:48 <rwbarton> those should subsume your other ones
23:16:57 <Sgeo> rwbarton, I was thinking of that sort of thing in * Sgeo wonders if he could simplify the code a bit by having cases of AtoB for non a and b
23:17:08 <rwbarton> ah
23:17:18 <Sgeo> But ty for giving me the code >.>
23:17:36 <Sgeo> It doesn't subsume the line 12 instance though, I thin
23:17:38 <Sgeo> think
23:18:36 <rwbarton> oh this is going to violate your functional dependency
23:18:56 <Sgeo> Wait what?
23:19:03 <rwbarton> the line 12 instance is just useless
23:19:15 <rwbarton> and it will cause instance resolution to loop
23:19:22 <rwbarton> rather than ever fail
23:19:57 <Sgeo> I seemed to need it for the line 20 instance, although my original plan was a unconvertFunc
23:20:28 <rwbarton> if you ever "need" it you can implement it in that place manually
23:20:51 * Sgeo will look at it in a bit, when he's eating
23:20:54 <Sgeo> tyvm though
23:21:33 <rwbarton> actually maybe the a b c c instance is okay with the functional dependency... overlapping instances are evil!
23:24:00 <Sgeo> Shouldn't it be a b c1 c2?
23:24:49 <rwbarton> wait, how does line 13 typecheck?
23:25:22 <rwbarton> I think adding unconvertFunc is a good idea
23:26:13 <Sgeo> Instead of the isomorphism case. If that's really needed to prevent looping. But line 13 typechecks fine
23:26:45 <rwbarton> I guess it typechecks because--it needs to fulfill a context AtoB a b bFunc z, but that's provided by line 12!
23:27:11 <rwbarton> what happens when you delete the stuff before the => on line 12?
23:27:28 <augur> hmm
23:28:02 <augur> anyone know how to relate catamorphic and anamorphic transformations that produce the same result or similar results?
23:28:06 <rwbarton> just imagine I write an instance like   instance AtoB a b String Int where convertFunc _ _ = length
23:28:22 <augur> like, if i have a fold that transforms a list into a tree, vs. an unfold that does the same?
23:28:25 <rwbarton> you're telling me there is supposed to be an instance AtoB b a Int String where ...?
23:28:32 <Sgeo> rwbarton, o.O it typechecks
23:28:59 <Sgeo> rwbarton, hypothetical users shouldn't write instances
23:29:10 <rwbarton> that's not how type classes work
23:29:51 <rwbarton> if you want to stop me from writing that example, then adding an unconvertFunc is the way to do it
23:30:10 <rwbarton> anyways what I'm really saying is line 13 makes no sense
23:30:20 <Sgeo> But... there should never be a need for an outside user to write an instance
23:30:38 <rwbarton> well, even so line 13 is just wrong
23:30:56 <rwbarton> convertFunc bToA aToB needs to be the inverse of convertFunc aToB bToA, but you wrote that they are equal
23:31:43 <rwbarton> at least, if your intent is to start with a (AtoB a b aFunc bFunc) instance and produce a (AtoB b a bFunc aFunc) instance
23:31:44 <Sgeo> convertFunc bToA aToB and convertFunc aToB bToA should do opposite things
23:32:19 <rwbarton> what you wrote takes a (AtoB a b aFunc bFunc) instance and produces a a (AtoB b a aFunc bFunc) instance
23:32:20 <Sgeo> Wait, I guess they may not necessarily do so
23:32:36 <rwbarton> (oops, extra "a")
23:33:11 <rwbarton> that's a legitimate thing to do, but it's not useful
23:33:28 <Sgeo> If one direction causes a String->Int to turn into an Int->Int, for example, the literal reverse goes into a String->String
23:34:29 <rwbarton> I guess your intent is that if I have an instance of AtoB a b aFunc bFunc then every occurrence of 'a' in 'aFunc' is replaced by 'b' in 'bFunc'?
23:35:36 <Sgeo> Yes
23:36:33 <rwbarton> I think what you want to do is...
23:36:35 <Sgeo> And my instances should be such that convertFunc (as->bs) (bs->as) can convert all instances of a in the argument to b
23:36:41 <rwbarton> add unconvertFunc to your type class
23:36:51 <Sgeo> Without the user writing instances
23:37:19 <rwbarton> then delete lines 11-21
23:37:37 <rwbarton> and add a AtoB a b c c instance, I guess
23:37:52 <Sgeo> Why a b c c and not a b c1 c2?
23:37:59 <rwbarton> because a b c1 c2 isn't right
23:38:12 <rwbarton> that would say replacing a with b in c1 could give you anything...
23:39:31 <rwbarton> the idea is, with these crazy overlapping instances, if you see AtoB a b c d, then either c is a in which case we use the first instance, or c is of the form c1 -> c2 in which case we use the line 23 instance, or it's something else in which case it doesn't have any 'a's in it
23:40:08 <rwbarton> if you like you could add more cases, like AtoB a b c d => AtoB a b [c] [d]
23:40:28 <ddarius> @tell edwardk I didn't realize calculated members could be recursive.
23:40:28 <lambdabot> Consider it noted.
23:40:31 <rwbarton> that will let you replace 'a's inside that kind of structure (the [] type constructor)
23:45:59 <rwbarton> Sgeo: an analogy for why the line 12 instance is useless:
23:46:08 <rwbarton> imagine you want to define multiplication in terms of addition
23:46:14 <rwbarton> and one fact you know is that multiplication is commutative
23:46:21 <rwbarton> so you write a line x * y = y * x
23:46:36 <rwbarton> this doesn't actually help you define multiplication
23:46:47 <Sgeo> Ah, ok
23:46:53 <rwbarton> unless you are doing something fairly unnatural
23:47:15 <Sgeo> Incidentally, my original unconvertFunc was pretty much useless
23:47:29 <shachaf> x*y=y*x might make sense as the last line of some definitions of (*). :-)
23:47:37 <rwbarton> yes, but they would be bad definitions. :P
23:48:57 <rwbarton> in your case, the only place you really inspect what a and b are is in the line 8 instance, and that one is already self-symmetric
23:50:22 <rwbarton> my analogy is not really very good, but I can't think of a better one
23:51:46 <Sgeo> I'm not sure if I can write a useful unconvertFunc
23:53:20 <Sgeo> rwbarton, without the line 12 instance, when would the second argument be used?
23:53:21 <Sgeo> And O
23:53:29 <Sgeo> I'm pretty sure it has to be used at some point
23:53:59 <Sgeo> Oh, the line ~23 instance uses it, I gues
23:57:33 <Sgeo> o.O my AtoB a b q q broke something
