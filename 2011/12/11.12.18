00:01:13 <MaskRay> the working code implemented `bfs' and `heuristic' which i think a bit redundant. i'm trying to simplify
00:01:52 <shachaf> MaskRay: Which part is redundant?
00:02:01 <Cale> er, what package is Data.MultiSet in?
00:02:07 <MaskRay> shachaf: bfs's first argument is Seq State and astar's is MultiSet (Int, State)
00:02:22 <shachaf> Oh, bfs and astar are similar to each other?
00:02:43 <MaskRay> Cale: the `| isJust $ find (==target') ...' line
00:02:43 <Cale> MaskRay: it doesn't matter, just think of those two lines as functions of src
00:03:06 <Polarina> [x | x <- libraries, isQualityLibrary x] == [] -- :/
00:03:14 <shachaf> Cale: "multiset"?
00:03:15 <MaskRay> Cale: `suc = ', `num = ' ...
00:03:35 <Cale> shachaf: yeah, seems so...
00:03:49 <Cale> MaskRay: what input do I give to test this program?
00:03:52 <shachaf> MaskRay: So just abstract those?
00:04:10 <MaskRay> Cale: just one line `123456780'
00:04:13 <shachaf> I mean, Haskell has a facility for removing duplicated code. :-)
00:04:28 <MaskRay> Cale: this means the source state is `123456780'
00:04:42 <MaskRay> the target state is always `123456780'
00:04:47 <hpaste> Cale pasted “Factoring 8-puzzle” at http://hpaste.org/55420
00:04:54 <Cale> MaskRay: ^^
00:05:08 <shachaf> MaskRay: Why is that file ".hsc"?
00:05:23 <Cale> shachaf: Presumably because he was using the C preprocessor
00:05:28 <shachaf> Oh.
00:05:38 <shachaf> .hsc is for things that you run through hsc2hs. :-)
00:05:45 <MaskRay> with input `123456708', the working code will generate .dot file which can be feed to graphviz later
00:06:08 <Cale> MaskRay: Does the code I posted solve your problem?
00:06:53 <Cale> I'm not sure 'next' is an appropriate choice of name, but you're free to rename it of course
00:07:02 <Cale> I really didn't think too hard
00:07:08 <MaskRay> shachaf: then I'll be able to use either approach with a cmd argument -DBFS
00:07:27 <shachaf> MaskRay: .hsc isn't for the C preprocessor.
00:07:48 <MaskRay> shachaf: I don't know a better way
00:07:51 <shachaf> That's just {-# LANGUAGE CPP #-}
00:08:02 <shachaf> .hsc is unrelated.
00:08:33 <Cale> But the C preprocessor is evil
00:08:59 <shachaf> Wait, you're actually running this code through hsc2hs?
00:09:04 <shachaf> ...I guess that would explain it.
00:09:27 <Cale> hsc2hs is blatantly unnecessary for this :)
00:09:36 <MaskRay> Cale: Thank you! More redunduncy lay on lines 68-75 and 86-93...
00:09:36 <shachaf> Yep.
00:10:13 <Cale> MaskRay: yes, you should factor that out too :)
00:10:37 <MaskRay> Cale: Yes. So I
00:10:49 <Cale> You don't need fancy type system extensions, this is just plain functional programming stuff :)
00:11:08 <MaskRay> I'm planning to write getHead to extract the head element from states in Open
00:11:59 <MaskRay> genS is used to merge undealt states and new states generated by getHead
00:13:02 <MaskRay> shachaf: I see
00:26:04 <hpaste> MaskRay pasted “Could not deduce (Elems a ~ Elems a0)” at http://hpaste.org/55421
00:26:17 <MaskRay> Cale: shachaf: What's wrong with line 36?
00:26:57 <shachaf> MaskRay: You're still doing this associated types thing?
00:27:06 <shachaf> Cale gave you a great solution that doesn't involve all that.
00:27:21 <MaskRay> Cale: shachaf: For ghc cannot deduce which a the second search represents?
00:27:36 <shachaf> MaskRay: Why is search a method of Solve, anyway?
00:28:25 <shachaf> Given that you only ever use the default implementation.
00:28:29 <MaskRay> shachaf: Yes, I did't give an suitable name.
00:29:07 <shachaf> MaskRay: I'm not talking about the name. Why is it class Solve a where { ...; search :: ...; search = ... } instead of class Solve a where { ... }; search :: ...; search = ...?
00:29:25 <shachaf> Also, why are you ignoring what Cale said? :-)
00:33:06 <MaskRay> shachaf: Sorry, I'm just wondering how  i can factor out the common search steps both bfs and astar have
00:34:08 <shachaf> MaskRay: I recommend building on what Cale did instead of ignoring it and using that type class.
00:34:18 <shachaf> This is just a general "how do I abstract things" problem.
00:34:54 <MostAwesomeDude> Arg. The Data class hurts my head. Why do I need to understand GHC type introspection in order to make an argument parser?
00:35:10 <shachaf> MostAwesomeDude: You don't need Data to make an argument parser.
00:35:14 <c_wraith> you usually don't need to understand Data
00:35:20 <c_wraith> you can usually just derive it
00:35:42 <MostAwesomeDude> I don't understand how Data lets the argument parser turn Strings into my custom type.
00:36:02 <shachaf> An argument parser that uses SYB sounds vaguely like a bad idea to me.
00:36:30 <MostAwesomeDude> cmdargs requires fields that it fills out to be instances of Data and Typeable.
00:36:44 <shachaf> MaskRay: You can make a thing that has the common structure of the two functions that you want to abstract, and takes the non-common part as an argument.
00:36:49 <MostAwesomeDude> It feels kinda magical. I'm not super-certain I understand what's happening.
00:37:03 <shachaf> MaskRay: That's how functions work. :-)
00:37:18 <shachaf> MostAwesomeDude: Why use cmdargs, then?
00:37:22 <MaskRay> shachaf: I'm sorry, but I think you may misunderstand my means. Lines 72-75 and 90-93 and above are similar in http://hpaste.org/55420
00:37:38 <shachaf> MaskRay: Yes, I know.
00:37:52 <MaskRay> shachaf: These are the codes which I want to simplify most
00:38:02 <MostAwesomeDude> shachaf: It lets me build multiple modes in a single command, and came highly recommended.
00:38:27 <carpi> http://blog.mpacula.com/2011/12/18/counting-collocations-ghc-and-g-benchmarked/
00:38:32 <shachaf> MaskRay: Then write a function that abstracts bfs and astar.
00:38:45 <carpi> is that a generally recurring theme or is on occassion ghc faster? ^^^^
00:40:26 <shachaf> MaskRay: Exercise: Reduce duplication between these two: foo :: [Int] -> IO (); foo [] = return (); foo (x:xs) = do { putStrLn (show (x+1)); foo xs }; bar :: [Double] -> IO (); bar [] = return (); bar (x:xs) = do { putStrLn (show (x/2)); bar xs }
00:40:34 <shachaf> MaskRay: Do you see how one might do that?
00:41:17 <MaskRay> shachaf: This is the purpose I use type families.
00:41:31 <shachaf> MaskRay: What, the exercise I gave you?
00:42:08 <shachaf> If you want to use type families for that, I recommend that you immediately forget about the existence of type families and figure out how to abstract things without them. :-)
00:42:26 <MaskRay> shachaf: Implement a Solve class which have two instances BFS and Heuristic.
00:42:46 <shachaf> MaskRay: Why are you using a type class?
00:43:47 <MaskRay> looks more integral instead of havng codes everywhere
00:44:05 <shachaf> MaskRay: What you're trying to do is better done without a type class.
00:44:19 <shachaf> It looks like you're trying to write C++ in Haskell, or something.
00:48:58 <carpi> can somone please tell me the differenece between rem and div ?
00:49:07 <carpi> i mean quot and div
00:49:14 <carpi> they seem to produce the same output
00:49:24 <ion> > [(-4) `rem` 3, (-4) `div` 3]
00:49:24 <shachaf> @google haskell the difference between quot and div
00:49:25 <lambdabot>   [-1,-2]
00:49:25 <lambdabot> http://stackoverflow.com/questions/339719/when-is-the-difference-between-quotrem-and-divmod-useful
00:49:25 <lambdabot> Title: haskell - When is the difference between quotRem and divMod useful? - Stack Over ...
00:49:54 <ion> “@lmgtfy” should be an alias for @google.
00:51:03 * hackagebot xournal-types 0.1 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.1 (IanWooKim)
00:51:05 * hackagebot xournal-builder 0.1 - text builder for xournal file format  http://hackage.haskell.org/package/xournal-builder-0.1 (IanWooKim)
00:51:07 * hackagebot xournal-render 0.3 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.3 (IanWooKim)
00:51:41 <carpi> thanks )\
00:52:14 <MaskRay> shachaf: The only way I know to solve your exercise is to implement a class...
00:52:34 <shachaf> ion: Comparing `div` and `rem` isn't going to reveal much. :-)
00:53:13 <shachaf> MaskRay: What if Haskell didn't have type classes?
00:53:35 <ion> shachaf: Whoops :-D
00:53:52 <ion> > map (`rem` 3) [-6..6]
00:53:53 <lambdabot>   [0,-2,-1,0,-2,-1,0,1,2,0,1,2,0]
00:53:54 <ion> > map (`mod` 3) [-6..6]
00:53:55 <lambdabot>   [0,1,2,0,1,2,0,1,2,0,1,2,0]
00:53:58 <MaskRay> shachaf: i'll have no idea then...
00:54:31 <ski> > (text . unlines) [showsPrec 10 n " `" ++ s ++ "` " ++ showsPrec 10 d " = " ++ show (n `f` d) | n <- [17,-17], d <- [7,-7] , (f,s) <- [(div,"div"),(rem,"rem")]]
00:54:33 <lambdabot>   17 `div` 7 = 2
00:54:33 <lambdabot>  17 `rem` 7 = 3
00:54:33 <lambdabot>  17 `div` (-7) = -3
00:54:33 <lambdabot>  17 `rem` (-7) = 3
00:54:33 <lambdabot>  (-17...
00:54:45 <ski> @more
00:54:50 <ski> bah
00:55:01 <MostAwesomeDude> MaskRay: Well, they're mostly the same, right? They just have a tiny change in their core.
00:55:48 <ski> MaskRay : what is the difference between shachaf's `foo' and `bar' ?
00:56:08 <MaskRay> MostAwesomeDude: I know this can be solved by Functional Dependency. I'm just wondering how I can solve it with type families
00:56:09 * hackagebot xournal-parser 0.3 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.3 (IanWooKim)
00:56:11 * hackagebot hxournal 0.6 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6 (IanWooKim)
00:56:42 <MostAwesomeDude> MaskRay: Why?
00:57:28 <MaskRay> MostAwesomeDude: I never used type families before. This is a good chance to learn...
00:58:18 <MostAwesomeDude> MaskRay: Really? You've never used, say, "show"?
00:58:26 * ski wonders whether MaskRay has any idea of how to solve shachaf's simple puzzle
00:58:43 <ski> MostAwesomeDude : `show' doesn't use type families
00:59:12 <geheimdienst> :t show
00:59:13 <lambdabot> forall a. (Show a) => a -> String
00:59:15 <MostAwesomeDude> ski: ...Wait, are type families something different from typeclasses?
00:59:21 <ski> yes
00:59:29 <MostAwesomeDude> Oh. Then I learned something today.
00:59:32 <geheimdienst> MostAwesomeDude: "(Show a) =>" indicates a typeclass named Show
00:59:42 <MaskRay> ski: The only way I can figure out is to define a new class and make Int and Double two instances of it
00:59:59 <MostAwesomeDude> Reuse Num, which Int and Double already belong to.
01:00:03 <ski> MaskRay : ok, then you really need to learn how to do it without making type classes
01:00:53 <MaskRay> ski: what's the way?
01:01:01 <ski> MaskRay : let's assume the type signatures of `foo' and `bar' was like `foo :: [Int] -> IO ()' and `bar :: [Int] -> IO ()' instead -- how would you do it then ?
01:01:57 <ski> hm, actually, that doesn't work, so say `foo :: [Double] -> IO ()' and `bar :: [Double] -> IO ()' instead :)
01:02:15 <MaskRay> class (Num a) => G a where foo :: [a] -> IO (); instance G Int where foo (x:xs) = print (x+1); instance G Double where foo (x:xs) = print (x/2)
01:02:23 <ski> (since `x/2' doesn't work when `x :: Int', but `x+1' still works when `x :: Double')
01:02:41 <ski> MaskRay : note that the types of `foo' and `bar' are *identical* now
01:03:04 <ski> so you can't solve this by making two instances for two different types
01:03:22 <ski> MaskRay : "what's the way?" -- the way is to use plain *functions*
01:04:10 <MaskRay> ski: Can't grasp what you said, `since `x/2' doesn't work when `x :: Int', but `x+1' still works when `x :: Double'
01:04:16 <augur> wow
01:04:22 * ski sighs
01:04:28 <augur> apparently all but one person at ESO uses a mac
01:04:29 <MaskRay> ski: I don't know how to exploit the property
01:04:47 <augur> i say all but one, what i mean is all but one of the people i saw in this video of a conference
01:04:53 <ski> MaskRay : ignore that, just assume the code looks like
01:04:59 <ski>   foo :: [Double] -> IO ()
01:05:07 <ski>   foo [    ] = do return ()
01:05:21 <ski>   foo (x:xs) = do putStrLn (show (x+1))
01:05:30 <ski>                   foo xs
01:05:36 <ski>   bar :: [Double] -> IO ()
01:05:40 <ski>   bar [    ] = do return ()
01:05:46 <ski>   bar (x:xs) = do putStrLn (show (x/2))
01:05:50 <ski>                   bar xs
01:06:10 <ski> MaskRay : so, what's the difference between these two definitions ?
01:06:14 <MaskRay> ski: With the property, I can omit the instance for Int...
01:06:25 <ski> there is no `Int' in this cose
01:06:33 <ski> s/cose/code/
01:07:04 <ski> MaskRay : so, what's the difference ?
01:09:29 <ski> MaskRay : i'm just asking you to spot what part of the code that looks different when comparing `foo' and `bar'
01:09:31 <MostAwesomeDude> Huh. I didn't realize this type was illegal: type Comparator = Ord a => Stats -> a
01:10:05 <ski> MostAwesomeDude : `a' isn't bound anywhere there
01:10:12 <MostAwesomeDude> It's because I'm keeping the forall a. to the left of the type instead of above the type, right?
01:10:21 <MaskRay> ski: bar = mapM_ (print.(/2))
01:10:22 <ski> MostAwesomeDude : maybe you meant `type Comparator = forall a. Ord a => Stats -> a' ?
01:10:34 <MaskRay> ski: foo = mapM_ (print.(+1))
01:11:17 <ski> MaskRay : yes, this is using the utility function `mapM_' -- could you have invented
01:11:22 <ski> `mapM_' yourself ?
01:11:24 <MostAwesomeDude> ski: Well, yeah, I could do Rank2Types to get it to compile, I'm just double-checking my thought process to ensure that I really did want that type.
01:12:04 <ski> (MostAwesomeDude : i have no idea what "I'm keeping the forall a. to the left of the type instead of above the type" is supposed to mean)
01:12:13 <shachaf> ski: I used Int and Double because one of MaskRay's objections was that the original code used different types.
01:12:46 <MostAwesomeDude> ski: (IIUC there's this "left of" and "above" idea in existential types. I'm still trying to get it...)
01:13:05 <shachaf> ski: I guess it's easier to demonstrate the futility of type classes if you use the same type, though. :-)
01:13:41 <MaskRay> mapM_' f (x:xs) = f x >> mapM_ f xs
01:13:55 <shachaf> MostAwesomeDude: The important part is that you keep it north-northwest of the type.
01:14:01 <MaskRay> ski: I can
01:14:09 <MostAwesomeDude> shachaf: I can't tell if you're being sarcastic. :c
01:14:23 <shachaf> MostAwesomeDude: Sorry. Yes. I don't know what "above" and "to the left" mean in that context.
01:14:31 <shachaf> MaskRay: That's not inventing it, that's just implementing it. :-)
01:15:01 <shachaf> MaskRay: Anyway, you solved this puzzle. Do you see what it has in common with your problem?
01:16:58 <Sgeo> Are there any nice tutorials on how to use the reflection package (rather than how it works?)
01:17:17 <shachaf> Sgeo: Step 1: Figure out how it works.
01:17:44 <MostAwesomeDude> shachaf: IIUC in runST :: forall m. (forall s. ST s m a) -> m a -- m is "above" the type, s is "left of" the type?
01:17:57 <MostAwesomeDude> I don't feel good at this at all, and the late hour isn't helping.
01:18:28 <ski> MaskRay : good. so use the same idea to factor out the common parts out of `bfs' and `astar' (you should not have to define any classes or instances for that)
01:18:33 <shachaf> MostAwesomeDude: Are there any existential types involved in that? :-)
01:18:44 <MaskRay> shachaf: Do you mean by adding two more arguments representing (extract and merge states)?
01:18:47 <MostAwesomeDude> shachaf: I think so? Yes? No? I dunno!
01:19:02 <Sgeo> Let's play Guess the Teacher's Password!
01:19:07 <Sgeo> >.>
01:19:17 <shachaf> MaskRay: I don't know exactly what I mean.
01:19:40 <shachaf> Just, you know, do something. Pass some arguments in for the things that aren't in common between the two functions.
01:20:10 <ski> MostAwesomeDude : there is no existential in the type of `runST'
01:20:10 <shachaf> It's abstraction.
01:21:01 <MostAwesomeDude> ski: Then I must be remembering another monad runner. I'm sorry, it's late, I'm clearly not thinking clearly.
01:21:19 <ski> MostAwesomeDude : also, i've never head of that "left of" and "above", re existentials, before
01:22:31 <shachaf> MostAwesomeDude: What are you actually trying to figure out?
01:23:08 <Veinor> every time i write a typeclass instance that uses a function in that typeclass i feel kind of weird
01:23:39 <shachaf> 3 = const 3
01:23:47 <ski> why ?
01:23:51 <Veinor> like 'abs = fmap abs'
01:23:52 <MostAwesomeDude> shachaf: Well, I *was* trying to convince GHC to let me craft a type: Ord a => Map String (Stats -> a)
01:23:59 <ski> ah, that
01:24:19 <MostAwesomeDude> But at this point, I've decided that what I wanted was stupid, and have settled for Map String (Stats -> Double) with lots of upcasts.
01:24:20 <ion> fromIntegral = constructorOfSomeKind . fromIntegral
01:24:28 <ion> I don’t feel weird at all about that.
01:24:32 <ski> (so you really mean "using a function from the same class, but a different instance")
01:24:44 <Veinor> yeah
01:24:58 <shachaf> ion: It looks like a recursive definition but it isn't. Presumably that's the weird bit.
01:25:08 <ion> Well, it’s kind of recursive. :-)
01:25:14 <ski> (well, i suppose in some cases it could call itself, so being recursive)
01:25:20 <Veinor> :t fix fmap
01:25:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
01:25:21 <lambdabot>       Expected type: a
01:25:21 <lambdabot>       Inferred type: f a
01:25:22 <shachaf> MostAwesomeDude: That type looks valid to me.
01:25:46 <ion> Just not self-recursive.
01:25:47 <shachaf> Veinor: fix will constraint fmap to some particular monomorphic type, for one.
01:25:50 * ski . o O ( `instance Functor IORef where fmap f ref = fmap f ref' )
01:25:55 <Veinor> shachaf: right, right, i didn't expect that to compile
01:26:00 <Veinor> er, typecheck
01:26:29 <MostAwesomeDude> shachaf: Huh, now it works. I wonder what I was doing wrong before. It was complaining about existential types and stuff.
01:26:49 <shachaf> ski: ?
01:26:58 <ski> MostAwesomeDude : is that `Ord a => Map String (Stats -> a)' part of a data constructor argument type ?
01:27:11 <ski> shachaf : recursive method
01:27:46 <MostAwesomeDude> ski: No.
01:27:47 <ski> MostAwesomeDude : in that case, you probably put the `forall a. ' in the wrong place, before
01:27:50 <ski> ok
01:27:59 <MostAwesomeDude> ski: I wasn't putting any foralls in.
01:28:16 <shachaf> ski: Oh, well, sure, *sometimes* it's recursive, but that's just because you pass it in as an argument. :-)
01:28:24 <ski> ok. if `a' wasn't a parameter then, you should get an error, yes
01:28:48 <ski> shachaf : pass what in as an argument ?
01:28:58 <shachaf> ski: fmap.
01:29:06 <shachaf> Via the Functor constraint, I mean.
01:29:10 * ski doesn't follow
01:29:43 <shachaf> Well, after the type class is expanded into dictionary-passing.
01:30:53 <accel> what is the type signature of a zipper?
01:31:01 <accel> it seems like depending on the type of nodes its in, its type varies
01:31:07 <accel> (context: functional zippers for editing trees)
01:31:50 <shachaf> A zipper isn't a value. What does "type signature" mean?
01:31:59 <accel> I thought a zipper = node + parent
01:32:08 <shachaf> What?
01:32:10 <accel> It sounds like the problem is that I don't understand zippers.
01:32:24 <shachaf> Yes. :-)
01:32:28 <accel> Zippers = a way to store a document + where the cursor is, by storing (1) the current node + (2) the path up to the root. Correct?
01:32:39 <accel> How is this not a value?
01:32:39 <shachaf> accel: I'd suggest starting with a zipper on a list.
01:33:06 <accel> A zipper on a list is, IMHO, a node + 2 stacks.
01:33:06 <shachaf> Oh, well, because it's a type. I don't understand your question.
01:33:21 <carpi> i understand that lists are the bread and butter of haskell..but if i required a structure with much better performance characteristics..are there any suggestions from the standard library or hackage?
01:33:31 <accel> shachaf: good call. Let me clarify my thoughts.
01:33:32 <shachaf> Performance in what?
01:33:39 <ski> (cf. how a monad isn't a value, it's a type (plus a couple of operations, satisfying a few laws))
01:33:46 <carpi> in terms of speed
01:33:48 <shachaf> carpi: Data structures don't have performance.
01:33:51 <shachaf> Or speed.
01:34:12 <kosmikus> carpi: it depends on the operations you want supported efficiently
01:34:33 <kosmikus> carpi: lists, for example, have excellent performance when it comes to accessing the head
01:34:34 <ski> carpi : lists often are good loops
01:34:35 <carpi> ah yes.. that is what i was referring to. apologies for being unclear earlier )
01:34:43 <carpi> good loops?
01:35:42 <ski> yes, e.g. you can do `mapM_ doSomething bigList', and this will often generate one element at a time, process it with `doSomething', then go on to the next, until done
01:35:52 <geheimdienst> carpi: what were you doing, when you noticed lists were not the right choice for your use case?
01:36:36 <ski> carpi : so in a sense, lazy lists are loops that generate elements, one at a time
01:37:28 <carpi> geheimdienst: i was processing very large strings using lists.. and for some reason it was a bit slow.. so i googled and found that strings are long list of  chars..
01:37:47 <shachaf> carpi: Oh, well, use Data.Text.
01:38:07 <Sgeo> I'm looking at the Data.Typeable docs
01:38:18 <Sgeo> And it seems to imply that each TypeRep is associated with one TyCon
01:38:23 <shachaf> Sgeo: Are you doing a thing you shouldn't be doing?
01:38:26 <Sgeo> What about types with more than one constructor?
01:38:48 <carpi> shachaf: hmm..so i was using the wrong DS. i will lok into that package )
01:38:54 <carpi> thanxs
01:39:44 <Sgeo> shachaf, maybe. Planning to use Data.Typeable to convert a subset of Haskell types into something that a different language can handle
01:40:50 <shachaf> Sgeo: What's TyCon?
01:40:58 <shachaf> Do you mean "types with more than one argument"?
01:41:15 <Sgeo> I mean types like data Either a b = Left a | Right b
01:41:24 <shachaf> Which part of that do you mean?
01:41:35 <shachaf> The "Either a b" part or the "Left a | Right b" part?
01:41:43 <Sgeo> The Left a | Right b part
01:41:50 <shachaf> Anyway, Either's kind is different, so there's a class Typeable2 for it.
01:41:52 <MaskRay> shachaf, ski: Thanks
01:41:58 <shachaf> Sgeo: But your objection would seem to apply to Maybe just as well?
01:42:03 <shachaf> data Maybe a = Nothing | Just a
01:42:07 <Sgeo> shachaf, yes it would
01:42:23 <Sgeo> Hmm... I think I confused type constructor with data constructor
01:42:27 <ski> shachaf : `TyCon' is for things like `Int',`Maybe',`Either', not for things like `Nothing',`Just',`Left',`Right'
01:42:39 <ski> s/shachaf/Sgeo/
01:42:43 <MostAwesomeDude> @pl f g x y = (g x) / (g y)
01:42:43 <lambdabot> f = flip =<< (((.) . (/)) .)
01:43:00 <Sgeo> How would I get to the structure of a type?
01:43:16 <ski> > let a = mkTyConApp (mkTyCon "Either") [mkTyConApp (mkTyCon "Int") []]; b = mkTyConApp (mkTyCon "String") []  in (a,b,mkAppTy a b)
01:43:17 <lambdabot>   (Either Int,String,Either Int String)
01:44:48 <Sgeo> Maybe using Data.Data?
01:45:20 <Sgeo> Looks like it
01:45:20 <Sgeo> ty
01:45:55 <Sgeo> I'm going to assume it's better to use Data.Data for my purposes than Template Haskell
01:46:07 <ski> Sgeo : maybe you want `splitTyConApp :: TypeRep -> (TyCon, [TypeRep])' ?
01:46:28 <Sgeo> Although, I'm wondering if I should do something else instead. Do I really need to make the user of my DSL make a data type to use it in the generated LSL program?
01:46:41 <Sgeo> It's not like the Haskell program can really use the data type... well, I guess it can
01:47:40 <Sgeo> Not going to bother to translate recursive datatypes
01:48:40 <MostAwesomeDude> @pl f x g = g x / h x
01:48:40 <lambdabot> f = ap (flip . ((/) .) . flip id) h
01:48:54 <shachaf> @src on
01:48:54 <lambdabot> (*) `on` f = \x y -> f x * f y
01:49:01 <MostAwesomeDude> Nope, still not pretty. Whatever.
01:49:11 <shachaf> MostAwesomeDude: You didn't pass in h.
01:49:17 <shachaf> Also, see "on".
01:49:24 <Sgeo> What happens if I try to do deriving (Data) without the deriving Typeable?
01:49:28 <MostAwesomeDude> shachaf: Oh, I see. @pl is fickle, I guess.
01:49:45 <shachaf> MostAwesomeDude: What do you mean, fickle? It did exactly what you asked it to do.
01:50:14 <MostAwesomeDude> shachaf: Oh. Then I guess I'm bad at asking.
01:51:03 * hackagebot multirec 0.7 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.7 (AndresLoeh)
02:02:40 <hpaste> tiph15 pasted “hs-ffmpeg patch for GHC 7” at http://hpaste.org/55423
02:11:35 <ski> MostAwesomeDude :   ((/) `on` ($ x)) g h  ?
02:12:17 <MostAwesomeDude> ski: Nearly what I have at this point, yes.
02:13:30 <ski> MostAwesomeDude : alternative is  (uncurry (/) . (g &&& h)) x
02:15:48 <carpi> 2:[3,5...] and [2..] ... in the first case when is 2 added to the list?
02:16:03 * hackagebot dataenc 0.14.0.3 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.14.0.3 (MagnusTherning)
02:16:25 <shachaf> carpi: There is no "when".
02:16:46 <shachaf> The list is made up of the constructor (:) which has two arguments.
02:17:26 <shachaf> So when you force the constructor, you have: (:) x y where { x = 2; y = [3,5..] }
02:17:56 <carpi> hm.. that is what im trying to understand.. so you say its lazy which means if i passed that as an argument to another function and that function requires the first element of the list.. then 2 is what it gets lazily?
02:18:36 <shachaf> I never said the word "lazy". :-)
02:19:01 <shachaf> (I did say the word "force", which maybe is a bit too operational, but I think it helps here.)
02:19:22 * ski thinks carpi possibly wants to look up the difference between "call-by-value" and "call-by-name"
02:20:15 <carpi> coming from an imperative world..call by value.. hmm.. i think i understand.. call by name?
02:20:46 <carpi> does it mean..the value is passed around as is..without being furthur evaluated until it is absolutely required?
02:21:09 <ski> yeah, but s/value/expression/
02:21:18 <carpi> or rather..not passed around in the conventional sense.. but..it just is there
02:21:37 <carpi> okay..so it is passed around.. )
02:21:37 <ski> let's say
02:21:52 <shachaf> It is passed around if you pass it around.
02:22:01 <ski>   f x y = y+y
02:22:19 <carpi> the reason for all these questions is.. i wrote a prime sieve.. and the funny thing is.. it takes the same amount of time to generate the output even if the size of my input is halved. :(
02:22:21 <ski> and we want to evaluate `f (2/0) (3*3)'
02:22:43 <ski> if we do this using a call-by-value evaluation strategy, then that can look like
02:22:49 <ski>      f (2/0) (3*3)
02:23:05 <ski>   =  error "division by zero"
02:23:06 <carpi> ski: that would generate error
02:23:16 <ski> ok, so let's try something slightly different
02:23:25 <carpi> but in haskell.. it happily gives 18
02:23:25 <ski>      f (6/3) (3*3)
02:23:32 <ski>   =  f 2 (3*3)
02:23:36 <ski>   =  f 2 9
02:23:38 <saati> isn't it NaN or Infinity and not an error?
02:23:42 <ski>   =  9+9
02:23:45 <ski>   =  18
02:23:53 <ski> this was using *call-by-value*
02:24:00 <ski> now, using call-by-name instead
02:24:06 <ski>      f (2/0) (3*3)
02:24:18 <ski>   =  (3*3) + (3*3)
02:24:22 <ski>   =  9 + (3*3)
02:24:24 <ski>   =  9 + 9
02:24:27 <ski>   =  18
02:24:32 <ski> finally, using call-by-need
02:24:36 <ski>      f (2/0) (3*3)
02:24:54 <ski>   =  let y = 3*3 in y+y
02:25:07 <ski>   =  let y = 9 in y+y
02:25:09 <ski>   =  let y = 9 in 9+y
02:25:13 <ski>   =  let y = 9 in 9+9
02:25:15 <ski>   =  let y = 9 in 18
02:25:19 <ski>   =  18
02:25:28 <ski> (the last step is known as "garbage collection")
02:25:41 <carpi> ski: how so?
02:25:42 <shachaf> ski: Hah. :-)
02:26:06 <ski> note that the only reason why `3*3' was evaluated here was that `y+y' demanded `y' to be evaluated
02:26:18 <carpi> you mean.. all the thunks are dispersed after the result 18 is obtained or something like that?
02:26:55 <ski> carpi : i mean that if there's no reference to the value `y' anymore, then we cal GC the `y' value
02:26:55 <carpi> sry..but i don't know what you mean by "the last step is known as garbage colection"
02:27:01 <ski> (s/cal/can/)
02:27:05 <shachaf> The thunk fairy comes along and collects them.
02:28:15 <carpi> ah okay.. gotcha.. you mean like..since the scope of y has ended and cannot be used anywhere else in the code.. it is GC'ed
02:29:46 <carpi> and what you described as call-by-need is 'lazy evaluation'.. more or less? tak?
02:30:50 <carpi> and it seems like call be need is implicitly using call by name in the background.. unless im mistaken and utterly confused )
02:35:53 <ski> carpi : yes, `call--by-need' is like `call-by-name', except it keeps an expression graph (above done using `let') instead of an expression tree
02:36:06 <Peaker> Attoparsec used to have a "many" combinator and now doesn't. What gives?
02:36:19 <ski> (i'm not sure what you mean by "the scope of y has ended")
02:39:49 <carpi> ski: i meant that there is no possibility for it to be used outside the let construct and since the expression that uses 'y' has no need for 'y' anymore..the GC collects 'y'. Im not sure if this is how the GC actually works though..
02:40:10 <shachaf> carpi: GC isn't really an important property of this system.
02:40:16 <shachaf> You can just ignore it for now.
02:43:15 <ski> carpi : that's more or less how GC works, seen from a quite high level, yes
02:46:24 <saati> is the gc different in some major way from other gcs or is it the same, start looking up some living pointers and mark things that are referenced, dealloc what's not marked?
02:49:50 <yitz> saati: it's "generational GC". so besides that, it keeps track of what was allocated "recently", and it's able to dealloc that stuff quickly without an entire search and mark iteration.
02:50:17 <saati> how big is the first gen?
02:50:31 <yitz> Peaker: use the one from Applicative
02:51:07 <yitz> saati: not sure what the default settings are. you can tweak it with runtime parameters.
03:17:10 <carpi> if i had a type with 2 possible values with the same fields... is there a way to remove redundancy by specifying that both values have the same fields instead of specifying each value seperately and specifying the same fields for each value?
03:17:45 <saati> use Bool?
03:18:17 <shachaf> data Foo = RedFoo Int Char Double | BlueFoo Int Char Double ---> data Colour = Red | Blue; data Foo = Foo Colour Int Char Double
03:18:23 <shachaf> If that's what you're asking.
03:20:39 <mmaruseacph2> @pl \s -> f s `mplus` g
03:20:39 <lambdabot> (`mplus` g) . f
03:20:54 <carpi> shachaf: that works.. thansk you ). so the key is to abstract everything as much as possible instead of cramming a more than necessary into a single entity. That was a very generic statement by the way )
03:21:58 <mmaruseacph2> carpi, yes, that's true
03:22:20 <merijn> carpi: Yes
03:22:54 <shachaf> The trick is to manipulate algebraic data types algebraically. :-)
03:23:27 <merijn> carpi: Since pattern matching and the type system make it fairly easy to pick apart your datatypes anyway there is no real reason to try and make them as compact as possible
03:23:27 <arw> carpi: yes, but do not use illogical abstractions. if fields have the same type but a different logical meaning, do not reuse them, the minimal efficiency gain doesn't outweigh the confusion.
03:24:59 * jessopher is trying to write a parser for an agda-ish expression syntax and running into lots and lots of ambiguity issues
03:26:36 <arw> carpi: e.g. data Stuff = Result String | Error String is imho preferable to data Flag = Result | Error; data Stuff = Flag String;
03:27:23 <Phyx-> that's not valid is it
03:27:44 <arw> oh, right. there is a Stuff missing. should be data Stuff = Stuff Flag String; at the end.
03:27:46 <shachaf> Yes, use your good judgement.
03:27:47 <arw> sorry.
03:28:10 <shachaf> If you lack good judgement...
03:28:35 <jessopher> then just do what works until it stops working..?
03:28:38 <merijn> If you lack good judgement you're f'ed anyway in a programming context :>
03:29:06 <saati> s/in.*//
03:29:23 <merijn> True
03:29:34 <merijn> Except when you're in finance, apparently :>
03:29:39 <Phyx-> merijn: I'm not sure about that, judging from TheDailyWTF, people lacking good judgement are doing ok for themselves :P
03:30:22 <carpi> arw: why is data Stuff = Stuff Flag String valid? its like a recursive type no?
03:30:53 <saati> carpi: why would it be recursive?
03:30:54 <jessopher> Stuff is the name of the type, and a constructor for a value of the type
03:31:07 <Phyx-> no, the first Stuff is a type conconstructor, the second Stuff is the value constructor
03:31:13 <merijn> carpi: No, that defines a datatype Stuff with a constructor named "Stuff" (which takes a flag and a string)
03:31:18 <arw> carpi: the second 'Stuff' after the = is the constructor which is a function, not a type.
03:31:42 <arw> carpi: its ok to name the constructor the same as the type, especially since its the only one.
03:32:12 <merijn> In fact, probably pretty common to name the constructor after the type if there is only one constructor
03:32:14 <arw> carpi: and all syntax in haskell distinguishes between types and functions, so there is no ambiguity.
03:32:16 <carpi> ah shite.. for a moment i forget the type constructor and value constructor can have the same name
03:33:06 <carpi> the minecraft clone..is definitely far far away :(
03:35:53 <jessopher> and by the way, i think good judgment isnt something you just 'have', its something you acquire. Babies dont have good judgement... but they get past that.
03:36:47 <jessopher> nobody says 'hey baby, just use good judgement'
03:37:52 <carpi> arw: and data Stuff = Flag String is not correct because Flag is already defined as a type and cannot be used as one of the possible "values" for Stuff. Am i correct in assuming that?
03:38:03 <shachaf> jessopher: You acquire it, and subsequently you have it. :-)
03:38:11 <shachaf> jessopher: That part was in the ellipsis.
03:38:57 <arw> carpi: no, I think that would work syntactically. it just wouldn't do what I intended it to do.
03:39:22 <arw> carpi: because in that case 'Flag' would be the value constructor for that type and not an element that is stored in it.
03:40:26 <jessopher> shachaf: lol, ok
03:40:30 <carpi> so Flag would just be another possible value for Stuff and not a field ..which is what is required
03:40:37 <arw> yes.
03:43:53 <arw> carpi: http://pbot.rmdir.de/ab884b5e547906ec32aaaefa44eb2458
03:44:56 <arw> carpi: this is valid. the XFlag is only needed because naming yet another type or function named 'Flag' wouldn't work.
03:45:25 <arw> carpi: but of course those types are different and do different things.
03:48:05 <carpi> data DifferentStuff = XFlag Flag String wouldn't work?
03:48:47 <arw> it would also work
03:49:52 <arw> I just wanted to show that the constructor may be named the same as the first contained type
03:51:34 <merijn> carpi: The reason it works is that types and functions/constructors are never used in the same context. So it's never ambiguous which you meant
03:52:41 <carpi> merijn: you mean like types are always constrained to type signatures and value constructors always occur in acutal code..and so no ambiguity?
03:52:51 <merijn> carpi: Yes
03:53:20 <merijn> carpi: And the first argument after data declaration is always a constructor and the others always types, so no ambiguity there either
03:54:14 <carpi> you mean firs argument after data declaration is always 'value' constructor?
03:54:30 <merijn> Yes
04:28:34 <etpace_> If I have some function a ~> b = ..., how can I make it right associative?
04:28:56 <carpi> is the System.Console.GetOpt library limited to taking only one argument for every option? the getOpt library in haskell is a port of the GNU get opt library..so anyone familiar with GNU getOpt might know something about this..?
04:29:05 <ClaudiusMaximus> etpace_: fixity declarations
04:29:43 <ClaudiusMaximus> > let a ~> b = a - b ; infixr 5 ~> in 5 ~> 4 ~> 3
04:29:44 <lambdabot>   4
04:31:15 <Sgeo> Is there a default fixity?
04:33:28 <ClaudiusMaximus> Sgeo: "Any operator lacking a fixity declaration is assumed to be infixl 9"
04:33:50 <Sgeo> Ah
04:33:51 <Sgeo> ty
04:34:19 <ClaudiusMaximus> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2
04:39:15 <etpace_> thanks ClaudiusMaximus
05:50:54 <hpc> wow, a full hour without conversation
05:51:00 <hpc> did #haskell die or something?
05:51:12 * hackagebot MagicHaskeller 0.8.6.2 - Automatic inductive functional programmer by systematic search  http://hackage.haskell.org/package/MagicHaskeller-0.8.6.2 (SusumuKatayama)
05:51:23 <hpc> ^ that doesn't count ;)
05:57:46 <mauke> preflex: quote
05:57:53 <preflex>  <mwc> C++ is multiparadigm in the same way a dog with 4 table legs nailed onto it is an octopus
05:58:41 <hpc> the dog is multiparadigm if the table legs are removable
05:59:07 <jessopher> i think at this point the dog is probably dead
05:59:33 <hpc> unfortunate; if it was a horse we could still beat it
05:59:40 <jessopher> hehe
06:02:47 <jessopher> so to paraphrase, c++ is like a dog corpse in a deadly octopus costume
06:03:27 <jessopher> made out of wood
06:04:51 <otters> "c++ is like a dog corpse in an octopus costume" I like that
06:09:29 <FliPPeh_> How can I make a monad transformer out of a monad transformer that's wrapping a monad transformer?
06:09:42 <FliPPeh_> newtype MPD a = MPD { runMPD :: ErrorT MPDError (StateT MPDConnection IO) a }
06:09:51 <FliPPeh_> The base monad
06:10:01 <FliPPeh_> And now I'd like to make MPDT m a out of that :S
06:10:25 <ddarius> newtype MPDT m a = MPDT { runMPDT :: ErrorT MPDError (StateT MPDConnection m) a }
06:10:34 <ddarius> You just abstract.
06:10:35 <FliPPeh_> newtype MPDT m a = MPDT { runMPDT :: m (MPD a) }
06:10:40 <FliPPeh_> That's what I have so far
06:10:42 <FliPPeh_> And return
06:11:05 <FliPPeh_> Hmm, am I doing it the wrong way around?
06:11:14 <hpc> @unmtl State s a
06:11:14 <lambdabot> s -> (a, s)
06:11:19 <ddarius> FliPPeh_: Yes, you are doing it entirely wrongly.
06:11:21 <hpc> @unmtl StateT s m a
06:11:21 <lambdabot> s -> m (a, s)
06:12:31 <FliPPeh_> Okay then, my "return x = MPDT $ return (return x)" was looking weird anyways, but it at least compiled
06:13:08 <FliPPeh_> Now how would I go about bind?
06:16:26 <ddarius> You derive Monad.
06:17:17 <FliPPeh_> That's some evil compiler magic GHC is doing
06:17:22 <parcs`> FliPPeh_: define a monad transformer first then define the monad in terms of it
06:17:29 <parcs`> you're doing it the other way around
06:17:46 <FliPPeh_> parcs`: Yes understand that now, but I was stuck writing (>>=) for it
06:18:22 <parcs`> defining >>= is so easy that the compiler can do it for you
06:18:32 <ddarius> FliPPeh_: No it isn't.  If you weren't using a newtype (or rather if I wasn't) then there would already be a Monad instance.  All the deriving Monad does is insert the un/wrappers as appropriate.
06:18:55 <FliPPeh_> Is there some way I can let GHC show me what it generated?
06:18:59 <ddarius> In fact, you can do it generically.
06:19:09 <FliPPeh_> 90% of what I'm doing here is trying to learn monad transformers
06:19:20 <FliPPeh_> And being able to see what it just generated would be helpful
06:19:57 <ddarius> FliPPeh_: It's not really important.  Learning how GHC lifts an instance through a newtype has nothing to do with monad transformers.
06:20:13 <ddarius> At any rate, it's pretty much the only way that type checks.
06:28:21 <darkangel> Hi All!. Is there is some helper to represents c++ like enum? I know about Enum class but its not flexible as c++ enums is
06:29:53 <ddarius> darkangel: Your correct.  It's more flexible.
06:30:03 <ddarius> s/Your/You're/
06:30:20 <hpc> darkangel: what do c++ enums do that Enum does not?
06:30:38 <FliPPeh_> Probably that autodecay to int
06:31:32 <darkangel> enum Foo {Bar = 10, Bar1, Bar2, Zoo = 20, Zoo1, Zoo2}; How can I model this is Haskell?
06:31:56 <darkangel> s/is/in
06:32:04 <mike-burns> darkangel: What are you using that for?
06:32:22 <ddarius> data Foo = Bar | Bar1 | Bar2 | Zoo | Zoo1 | Zoo2; instance Enum Foo where fromEnum Bar = 10; fromEnum Bar1 = 11; fromEnum Bar2 = 12; etc...
06:32:28 <saati> darkangel: make a function f :: Num a => Foo -> a
06:32:35 <ddarius> Similarly for toEnum.
06:32:44 <darkangel> Is it metter? Just enum ofsome object properties
06:34:10 <darkangel> ddarius: I don't what to write all that boilerplate code. I want some mo simple thing. Does Haskell have it?
06:34:36 <hpc> darkangel: perhaps you could write it in TH?
06:34:39 <ddarius> darkangel: You can derive Enum if all the values are sequential starting from 0, I think.
06:34:44 <hpc> then put it on hackage for others
06:35:04 <ddarius> You also have -all- of the power of Haskell at your disposal.  You can make an assoc list [(Bar, 10), (Bar1, 11), ...]
06:35:35 <ddarius> then fromEnum and toEnum just look up the value in the assoc list.
06:35:52 <darkangel> :) TH will be rescue but I want to know that this is the only way to have c++ like enum.
06:36:41 <darkangel> ddarius: I know that/ I just want to make sure that there is no other, more simple way of diong this
06:37:50 <darkangel> assoc list is not good - I want to have strong typecheck my code if that possible
06:38:14 <ddarius> darkangel: The association list doesn't lose you any type checking.
06:38:42 <ddarius> In fact, it doesn't lose you anything with regards to writing fromEnum/toEnum out manually.
06:39:17 <saati> isn't the whole c++ enums and fromEnum/toEnum a recepie for disaster?
06:39:29 <saati> especially toEnum
06:39:30 <mike-burns> I still wonder the use case.
06:39:55 <ique> @pl (\a -> \b -> (f a):b)
06:39:55 <lambdabot> (:) . f
06:40:18 <ddarius> I think people are wondering, unless you're coding to some given interface, why do you even need a mapping from your "enum" to Ints?
06:41:06 <darkangel> ddarius: Okay. I describe the root problem. I need to model some bitfield. Some Word32 where each bit represents some property. How would you model such thing?
06:42:40 <FliPPeh_> Man, this MonadTrans business is messing with my head
06:42:52 <FliPPeh_> How do I write a damned MonadTrans implementation with lift?
06:42:53 <ddarius> prop1 x = testBit x 1
06:43:05 <saati> darkangel: http://hackage.haskell.org/packages/archive/data-flags/0.0.3.1/doc/html/Data-Flags.html
06:43:35 <Patinho`Busy> hi all o/
06:43:45 <FliPPeh_> http://hpaste.org/55429
06:43:49 <FliPPeh_> Any help for line 16?
06:45:46 <darkangel> saati: looks like what is need, but TH example is just horrible...
06:46:04 <TurboIslaam> EvanR-work, so, do you have any nice docs for working in liskell
06:46:05 <parcs`> FliPPeh_: look at the source code of the transformers package
06:46:09 <ddarius> darkangel: Using testBit (and set/clearBit if necessary), if you still want an Enum, now it's a sequential one with maybes some reserved entries.
06:49:13 <FliPPeh_> parcs`: I'm trying, but all of the basic transformers wrap some simple monad, I'm wrapping 2 other transformers
06:49:18 <FliPPeh_> It doesn't seem to work that easily
06:49:54 <parcs`> FliPPeh_: you can derive MonadTrans you know
06:50:09 <FliPPeh_> parcs`: It won't let me
06:51:12 <Phlogistique> is one of the high-level/functional user interface libraries really mature and usable?
06:52:10 <parcs`> FliPPeh_: that's strange.. but anyway, the definition is 'lift = MPDT . lift'
06:53:15 <FliPPeh_> parcs`: Couldn't match type `m' with `StateT MPDConnection m'
06:53:32 <FliPPeh_> instance MonadTrans MPDT where
06:53:37 <FliPPeh_> should be correct, no?
06:54:16 <ddarius> flagLens n = lens (`testBit` n) (\b x -> if b then setBit x n else clearBit x n)
06:54:19 <parcs`> oh right it's 'lift = MPDT . lift . lift'
06:54:24 <ddarius> propX = flagLens 1
06:54:47 <FliPPeh_> Thanks, that seems to work
06:54:59 <FliPPeh_> So I have to pass the lift to each inner transformer
06:55:03 <FliPPeh_> makes sense actually
06:55:14 <parcs`> and apparently you can't derive MonadTRans for nested transformers
06:57:20 <ddarius> @tell edwardk A stock lens to add perhaps: flagLens n = lens (`testBit` n) (\b x -> if b then setBit x n else clearBit x n)
06:57:20 <lambdabot> Consider it noted.
07:05:01 <carpi> so far.. i've been writing small programs and never really had a reason to do any unit testing. The size of the code im working on at the moment has grown a bit.. and would help if i can do some unit testing.. is there some framework to test functions ?
07:06:03 <ddarius> carpi: QuickCheck/HUnit.
07:06:43 <carpi> which one do most folks use.. id prefer to use something many foks are using in case i run into some trouble )
07:07:05 <merijn> carpi: Probably quickcheck, it's crazy awesome :>
07:07:59 <ddarius> carpi: They are complementary.
07:08:14 <carpi> thanxk.. ) quickchek it is. i hoe is easy to use
07:08:18 <mike-burns> We use Quickcheck and HUnit.
07:08:20 <carpi> *hope
07:08:49 <ddarius> carpi: Also don't think "framework" these are just libraries.
07:09:30 <parcs`> @check \x -> x * 0 == 0 && x * 1 == x -- a taste of quickcheck
07:09:30 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `*'Not in scope: `=='Not in scope...
07:09:41 <parcs`> guess not :(
07:09:44 <ddarius> @undefine
07:09:47 <ddarius> @check True
07:09:47 <lambdabot>   Not in scope: `myquickcheck'Not in scope: data constructor `True'Not in sco...
07:09:54 <ddarius> Hmm, something is rather broken.
07:09:59 <Nibble> @check for AIDS
07:10:00 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `for'Not in scope: data construct...
07:10:04 <ddarius> (And wtf is "myquickcheck"?)
07:10:07 <hpc> Cale: ping
07:10:12 <hpc> Cale: quickcheck broke
07:10:15 <Nibble> @check vagina
07:10:15 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `vagina'Not in scope: `$'
07:10:20 <Nibble> hahahahahhahahah not in scope
07:10:23 * mike-burns pauses
07:10:39 <ddarius> @tell Cale @check is strangely and completely broken.
07:10:39 <lambdabot> Consider it noted.
07:10:46 * parcs` does a 360 and leaves the room
07:16:21 <carpi> seems like there are many quickcheck packages in hackage..which one is used for testing? haskell-quickcheck?
07:17:32 <merijn> carpi: This one: http://hackage.haskell.org/package/QuickCheck
07:19:31 <carpi> thanks.. that maust be the one
07:20:18 <ByronJohnson> carpi: HUnit and QuickCheck are pretty standard, and IIRC "testpack" provides some functions to use them together
07:20:50 <Nibble> @tell ddarius
07:20:50 <lambdabot> Consider it noted.
07:20:55 <Nibble> YOU SURE GOT TOLD
07:21:20 <merijn> Nibble: Are you thirteen/drunk?
07:21:29 <carpi> unless there are some features that are present in one and absent in the other.. do packages like testpack make a difference?
07:22:00 <Nibble> merijn: would "both" satisfy your curiosity
07:22:27 <merijn> carpi: I'd just get started with HUnit/QuickCheck until you run into problems and only bother searching for solutions once you do
07:24:30 <ddarius> carpi: As I said above, QuickCheck and HUnit are complementary.  They for the most part don't overlap at all, though technically QuickCheck -can- do what HUnit does.
07:26:29 <carpi> thanks for the clarification. i just managed to install quickcheck.. so i think ill use it for now
07:28:43 <ddarius> carpi: HUnit is more like a traditional unit test framework.  QuickCheck is nicer and more powerful for pure code, but HUnit is better suited to IO code.
07:31:18 <ion> QuickCheck can be used for IO code if you want random input.
07:32:13 <ion> IMO IO doesn’t affect the choice much. Random input → use QuickCheck. Constant input → use HUnit or something like that.
07:33:03 <mike-burns> Property testing vs unit testing.
07:33:53 <mike-burns> QC could even drive a HUnit test, if you're into reproducable tests and all that.
07:35:57 <ddarius> ion: Constant input is a special case of random input.
07:37:29 <kmc> why is HUnit better for IO code, compared to http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/packages/QuickCheck-2.4.0.1/doc/html/Test-QuickCheck-Monadic.html
07:37:37 <kmc> granted that module is not documented and not that easy to figure out
07:37:55 <merijn> I think you just answered your own question? :)
07:38:16 <kmc> but see e.g. http://stackoverflow.com/questions/2259926/testing-io-actions-with-monadic-quickcheck
07:38:29 <kmc> merijn, well, is there a reason other than that? ;P
07:38:50 <shapr> kmc: I've never figured out how to test monadic code with QuickCheck, does it work for you?
07:39:00 <kmc> yes
07:39:01 <Nibble> how do I pattern match against a list of x:y:[]
07:39:06 <kmc> Nibble, like that
07:39:06 <Nibble> do I just do x:y:[]
07:39:08 <Nibble> ok
07:39:10 <c_wraith> in parens
07:39:15 <kmc> > case [1,2,3] of (x:y:[]) -> (x,y)
07:39:16 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
07:39:16 <shapr> kmc: I'd like to know how!
07:39:16 <Nibble> obviously
07:39:19 <kmc> > case [1,2] of (x:y:[]) -> (x,y)
07:39:20 <lambdabot>   (1,2)
07:39:23 <kmc> > case [1,2] of ([x,y]) -> (x,y)
07:39:24 <lambdabot>   (1,2)
07:39:37 <kmc> shapr, see the StackOverflow link i pasted :)
07:39:57 <shapr> ohh
07:40:17 <kmc> i used it here: https://github.com/kmcallister/posix-escape/blob/master/test/test.hs
07:40:54 <Martty> is TDD applicable to haskell?
07:40:59 <kmc> sure
07:41:05 <Nibble> yep
07:41:07 <Nibble> obviously
07:41:14 <kmc> why wouldn't it be
07:41:28 <Martty> idk it only seems to make sense if you have objects
07:41:33 <Martty> like, you can test each class on its own
07:41:42 <merijn> I don't think TDD makes sense even with objects
07:41:44 <shapr> Martty: I hacked QuickCheck to do TDD long ago by saving the failing test value seeds and reusing them for future property runs.
07:42:01 <Martty> well i dont like TDD either but i was just curious
07:42:07 <shapr> I like TDD!
07:42:12 <shapr> I think it works well in Haskell.
07:42:42 <c_wraith> I do it when the T stands for "type" :)
07:42:44 <merijn> I'm more a fan of integration and function testing than unit testing
07:42:52 <merijn> c_wraith: Agreed
07:43:30 <kmc> Martty, you can test classes on their own but you can't test functions, data types, or modules on their own?
07:43:55 <shapr> Happily, QC2 explicitly included hooks to pull out the PRNG seed so more TDD could be done with QuickCheck
07:44:15 <ddarius> merijn: Those aren't in conflict at all.
07:44:57 <merijn> ddarius: Assuming finite time, they are
07:45:06 <ddarius> kmc: Nope.  Only classes.  This is why Java is the bestest language.
07:45:07 <merijn> Any time invested in one cannot be invested in the other
07:45:10 <kmc> somehow OOP proponents have convinced people that OOP has a monopoly on the idea of abstraction
07:45:28 <ddarius> merijn: Usually different groups produce integration/function tests v. unit tests.
07:46:09 <merijn> ddarius: In the ideal case maybe, but at very small team sizes where 3 people are doing everything
07:46:54 <shapr> What is possibly in conflict?
07:46:58 <shapr> I missed that part.
07:47:17 <merijn> shapr: I said I preferred integration and functionality testing to unit testing
07:47:28 <shapr> Oh, I like both.
07:47:32 <Nibble> ewww
07:47:39 <kmc> most educational programs massively overstate the significance of objects versus the older idea of abstract data types
07:48:07 <merijn> kmc: As if there's anything other than inheritance!
07:48:14 <kmc> can someone define unit testing vs function testing for me?
07:48:25 <kmc> wikipedia says that 'unit' is the smallest testable unit, which would often be a function ;P
07:48:26 <shapr> I like functionality testing for specifications, and I like unit tests to build trust in my code and a framework for quickly finding new bugs.
07:48:28 <merijn> kmc: I meant functionality testing
07:48:36 <kmc> oh
07:48:44 <ddarius> kmc: "function" in "function testing" is like a feature point.
07:48:55 <kmc> i see
07:49:59 <shapr> This past summer I worked in a two man team where I did the server side python-django code with unit/functional tests, and the other guy did the Android app without tests. I ended up persuading him that he would have saved time overall if he'd written unit tests from the beginning.
07:50:25 <merijn> Anyone have a fancy CV (lay-out wise) they're proud of and don't mind showing me to rip-off^H^H^H^Hbe inspired by?
07:50:46 <shapr> merijn: http://scannedinavian.com/~shae/ErissonResume2.pdf
07:50:51 <hpc> merijn: not enough backspaces ;)
07:50:56 <kmc> i ripped off this layout merijn: http://www.mcnabbs.org/andrew/linux/latexres/
07:51:00 <shapr> merijn: I'm using the moderncv style in LaTeX
07:51:07 <kmc> with some tweeks, but it's a good start
07:51:09 <merijn> hpc: I know :p
07:51:11 * ddarius maybe wrote a resume sorta once.
07:51:54 <kmc> yours looks nice shapr!
07:51:58 <dropdrive> merijn: http://tex.stackexchange.com/questions/80/latex-template-for-resume-curriculum-vitae
07:51:59 * ddarius finds out what Shae was doing all the years he and or I wasn't here.
07:52:03 * ddarius agrees with kmc.
07:52:06 <merijn> shapr: Yeah, I had one using moderncv to, working on a new one from scratch this time to practice my fancy typography skills. But I'm not entirely sure of what I want it to look like
07:52:09 <shapr> ddarius: Yes, now you'll know :-)
07:52:31 <shapr> kmc: thanks! I owe it all to other people's work.. I just put my own text into the example mostly.
07:52:35 <merijn> shapr: hah, that's the exact layout my old version has :p
07:52:44 <irene-knapp> shapr: I like your job title haha
07:53:04 <ddarius> shapr: You should just get rid of the job titles and company names, and just have a list of places.
07:53:11 <shapr> I got really tired of having "software developer" as my desired/current title.
07:53:12 <irene-knapp> my old one is here -- http://ireneknapp.com/himitsu/Resume.pdf
07:53:18 <irene-knapp> shapr: yeah, makes sense
07:53:40 <merijn> dropdrive: Yeah, I'm aware of most/all the LaTeX packages. I'm not looking for help with those. I just need some inspiration for the visual design :)
07:53:44 <shapr> ddarius: I have one joke in the company names, "Enskild Firma" is Swedish for "self owned firm" aka 'self-employed'
07:53:47 <irene-knapp> (that logo is a side-effect of my work on my diagram editor; it's a diagram from Euclid's _Elements_ which I redrew)
07:53:56 <irene-knapp> haha nice
07:54:06 <merijn> shapr: I like the title "software zymurgist"
07:54:14 <irene-knapp> @google zymurgist
07:54:15 <lambdabot> http://dictionary.reference.com/browse/zymurgist
07:54:26 <irene-knapp> brewing and distillation
07:54:26 <irene-knapp> cute
07:54:38 <shapr> nifty
07:54:39 <merijn> Expert in the fermentation process of alcohol :)
07:54:53 <merijn> I like the parallel between fermentation and software development :p
07:54:58 <irene-knapp> yep
07:55:24 <hpc> merijn: make an incomplete product and let it sit in a barrel for 3 years for being deployed? :D
07:55:26 <ddarius> @wn zymurgist
07:55:27 <lambdabot> No match for "zymurgist".
07:55:28 <shapr> ddarius: Now that you mention it, the list of places I've worked would be pretty cool all by itself.
07:55:55 <shapr> And now I'm back in Alabama
07:56:29 <ddarius> shapr: The projected completion date for your degree is 2013?
07:57:00 <shapr> Yes, I need two more terms at five classes per term. I may do one or two of those classes in the summer.
07:57:27 <shapr> Er, two more terms after this upcoming spring term.
07:57:52 <ddarius> shapr: I would have thought you'd be able to leverage some credit one way or another.
07:58:08 <ddarius> shapr: I can't imagine that you'd need to start college as a Freshman.
07:58:15 * shapr shrugs
07:58:26 <merijn> On related note, anyone know of a good category to put before or after the following two: "experienced" "familiar"
07:58:52 <ddarius> "wrote"
07:58:55 <shapr> I tried to get credit for CS155 and other basic programming courses, but UNA has had flagrant failures with former students who tried to skip a bunch of courses.
07:58:56 <kmc> ninja rockstar
07:59:23 <ddarius> shapr: Students with over a decade of professional experience?
07:59:48 <shapr> No, the failures were foreign students who claimed experience in prior courses elsewhere.
08:00:09 <ddarius> shapr: What do you do when the professor is like "Now class, this is a for loop.  Say it with me, 'for loop.'" ?
08:00:18 <irene-knapp> I've been in classes like that
08:00:18 <ddarius> (There was too much punctuation in that sentence.)
08:00:22 <irene-knapp> I say it with them - "for loop"
08:00:24 <shapr> I read about base prime number systems.
08:00:24 <irene-knapp> what else can I do?
08:00:40 <shapr> ddarius: Speaking of which, do you remember that discussion about base prime?
08:00:41 <kmc> skip class
08:00:45 <hpc> irene-knapp: you could say "recursion"
08:00:51 <irene-knapp> yeah, but then there's a homework and they don't tell you :)
08:00:55 <irene-knapp> hpc: haha yeah!
08:00:56 <shapr> kmc: Nah, grades get dropped by one letter for every week missed.
08:01:01 <kmc> what?
08:01:07 <kmc> what kind of university grades on attendance
08:01:09 <ddarius> shapr: Not really.
08:01:09 <ciaranm> you get grades for turning up?
08:01:15 <hpc> kmc: BAD ones
08:01:17 <kmc> isn't that something you do for small children?
08:01:21 <irene-knapp> I know, right!
08:01:24 <irene-knapp> really offends me
08:01:31 <irene-knapp> not uncommon though
08:01:34 <kmc> if you can complete the work without going to class then why the fuck do they care
08:01:34 <shapr> So, I can't skip class, and introduction to programming with C++ is honestly not that exciting, and I can't get wifi in the class.
08:01:48 <kmc> you could get drunk in class
08:01:48 <hpc> kmc: or if you can't, you've failed anyway
08:01:56 <hpc> i figure, let people fail on their own
08:02:03 <ciaranm> "turning up" is something you do for the minimum number of things necessary such that the university isn't legally required to report you to customs and immigration, plus whenever turning up is actually useful
08:02:07 <hpc> no need putting up an artificial penalty
08:02:57 <shapr> On the good side, I got three A (Literature, History, Intro to Programming) and a B (Computer Networking).
08:03:16 <irene-knapp> the university system is just plain failing :(
08:03:29 <irene-knapp> this would not bother me except that we haven't figured out what to replace it with yet
08:03:31 <ddarius> The real answer is: "On the good side, there are a bunch of college freshmen girl running about."
08:03:37 <irene-knapp> haha
08:03:38 <irene-knapp> fair
08:03:45 <shapr> The networking class was an amazing amount of work, I learned lots of useful stuff about networks, and I'm perfectly happy with that B.
08:04:34 <ddarius> shapr: Did you ever work with Sonali?
08:04:55 <shapr> No, what/who is that?
08:05:08 <ciaranm> the thing that pissed me off about "programming" courses was being marked down for giving correct code as opposed to "nice but slightly wrong" code
08:05:46 <shapr> Yah, my teachers abhor my coding style, even if the code works perfectly I usually get a B for lack of comments and formatting.
08:06:03 <kmc> we always told students to comment more.  result:
08:06:06 <ddarius> ciaranm: You should be able to challenge that (though it probably isn't worth it.)
08:06:11 <kmc> int i = 3;  // Declare integer i with initial value 3
08:06:19 <irene-knapp> kmc: yeah :(
08:06:22 <merijn> kmc: I subtract points for that :)
08:06:38 <shapr> Part of my problem is that I no longer know what needs comments. A decent chunk of beginning programming is obvious to me.
08:06:44 <irene-knapp> yes, that's true too
08:06:46 <ddarius> shapr: Indeed.
08:06:48 <FliPPeh> shapr: Be glad they want good coding style. My teacher's programs look as if they were written by monkeys.
08:06:53 <irene-knapp> well, I mean, I use comments for things that require external references
08:06:54 <deech> Hi all, is there a resource for functional versions of imperative algorithms? The pseudo-code in my Cormen algorithms book assumes that they are implemented in an imperative language.
08:07:03 <irene-knapp> "This algorithm was invented by so-and-so and discussed in the following papers..."
08:07:04 <ddarius> Comments are writing.  And as with all writing, the audience needs to be considered.
08:07:19 <shapr> irene-knapp: always cite tarjan!
08:07:25 <irene-knapp> @google tarjan
08:07:26 <lambdabot> http://en.wikipedia.org/wiki/Robert_Tarjan
08:07:26 <lambdabot> Title: Robert Tarjan - Wikipedia, the free encyclopedia
08:07:28 <ciaranm> i lost a whole bunch of marks on a "concurrent programming" exercise because i did it using condition variables etc rather than "thread safe data structures". and the reason i did that was because the "thread safe data structures" way had at least three subtle and very unlikely to actually happen bugs.
08:07:29 <shapr> He invented just about everything.
08:07:33 <irene-knapp> I'd rather cite Tarzan :D
08:07:44 <irene-knapp> oooh interesting
08:07:47 <irene-knapp> yeah looks like he did
08:07:51 <ddarius> I used comments for things that were done for non-obvious reasons.  "This code looks crazy but the 'obvious' code doesn't work because of this that and the other."
08:07:56 <ciaranm> that was when i switched to doing the minimum number of cs courses possible and filling the rest in with maths
08:08:03 <ddarius> I also use comments to curse about EF.
08:08:05 <irene-knapp> ddarius: that too, of course
08:08:07 <kmc> deech, _Purely Functional Data Structures_ is a nice book
08:08:18 <kmc> deech, though it's not a straight-up functional equivalent of CLRS, as the name might suggest
08:08:27 <shapr> kmc: Ooh, Rabhi and Lapalme! I submitted a bug report for that book...
08:08:45 <shapr> Or wait, is that the Okasaki book?
08:08:46 <kmc> haven't seen that one
08:08:49 <kmc> yeah okasaki
08:08:49 * shapr asks Google
08:09:02 <deech> kmc: Read it, love it, presented about it.
08:09:12 <shapr> Ah yes, I thought it was http://www.amazon.ca/Algorithms-Functional-Programming-Fethi-Rabhi/dp/0201596040
08:09:36 <deech> kmc: I can use STRefs and IORefs to traanslate the imperative algorithms into Haskell, but it just doesn't feel right.
08:09:44 <shapr> I loaned my copy of Okasaki to edwardk, and he's still got it!
08:09:54 <kmc> deech, depends what you're trying to do, but yeah
08:10:13 <hpc> deech: STRefs are perfectly kosher if there's a particularly elegant imperative algorithm
08:10:18 <hpc> @quote imperative
08:10:19 <lambdabot> lennart says: I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
08:10:19 <lambdabot> useful for functional code
08:10:27 <hpc> oh, wrong quote
08:10:28 <hpc> @quote imperative
08:10:28 <lambdabot> kmc says: the irony being, the abstraction that gets the most complaining and general noise [from imperative programmers] is the one that captures imperative programming
08:10:50 <ddarius> deech: Many of them can probably be translated in a much more idiomatic way without too much brilliant insight (and/or by reading everything Bird wrote).  Some of them are (potentially) fundamentally imperative.
08:10:51 <hpc> anyhoo, haskell is very good at abstracting over imperative code
08:11:59 <Nibble> haskell is good at everything that it can express
08:12:28 <kmc> no
08:12:31 <deech> ddarius: I see. Agreed. Although I don't know lazy-evaluation enough to be able to translate some of the algorithms to take advantage of memoization etc.
08:12:35 <ciaranm> i dunno if it's representative of university programming courses in general, but i was severly put off by a "model solution" to an exercise which a) would crash on empty input, b) would sometimes end up with most worker threads terminating too soon and just running the whole thing with one thread, and c) had a nearly impossible to trigger but theoretically possible race condition, when my own submission lost marks for "being too compilca
08:13:28 <ciaranm> Nibble: i dunno... i've got quite a few things where haskell really isn't as nice as it should be due to it missing either subtyping or some form of dependent types
08:13:31 <deech> ddarius: Okasaki's final implementation of persistent double-ended queues is brilliant and I would never have gotten there from an imperative algorithm spec.
08:13:38 <dropdrive> So for a function like "fix", how do I decide where to import it from?  Hoogle has several different "fix"'s.
08:14:03 <Nibble> > locate fix
08:14:04 <lambdabot>   Not in scope: `locate'
08:14:05 <ciaranm> dropdrive: you import the one you need, and if necessary you use import qualified
08:14:07 <kmc> import it from Data.Function
08:14:09 <rostayob> dropdrive: Data.Function?
08:14:32 <ddarius> deech: You may want to read some of Bird's work.  He's also pretty good at explaining imperative algorithms functionally.  I'm not sure what a good reference for it would be off the top of my head though.
08:14:47 <deech> ddarius: Ok, I'll google for it. Thanks!
08:15:41 <kmc> is there a resource which explains persistent data and sharing to someone with a typical imperative programming background
08:15:50 <dropdrive> ciaranm: I guess I'll need to understand the difference between Data.Function's fix and Control.Monad.Fix's fix?
08:15:52 <kmc> preferably without requiring them to learn a new language first
08:16:06 <ciaranm> dropdrive: it does help to know what the function you're trying to use does, yes
08:16:09 <kmc> to me this is one of the most important ideas you encounter learning haskell
08:16:18 <kmc> but i feel like i encountered it late and that nobody really spelled it out
08:16:22 <ddarius> dropdrive: There is no difference.  Stuff has just moved about over time.
08:16:38 <dropdrive> ddarius: Ah, so how do I know which the more "modern" location is?
08:16:52 <ddarius> By kmc telling you.
08:17:03 <kmc> i also think persistent data would be useful in a lot of traditional imperative programs
08:17:10 <kmc> particularly concurrent ones
08:17:22 <ddarius> dropdrive: Of course which one is more "modern" doesn't matter.  It's which one works for the compiler/libraries you have.
08:17:36 <Philippa> not to mention just about every app with undo or something approximating versioning
08:17:42 <ddarius> kmc: There is no reason persistent data would not be covered in an imperative setting.
08:17:57 <kmc> yeah, but have you seen it done?
08:18:13 <ddarius> Indeed, I'd expect it to be covered in a late undergraduate course, but more in the stuff like Tarjan's various crazy persistent data structures.
08:18:50 <kmc> maybe i should have taken more data structures courses
08:19:33 <Nibble> if you can find a good data structure to represent it as
08:19:37 <Nibble> you have solved half the problem
08:20:40 <ique> @pl (\f -> foldr ((:).f) [])
08:20:40 <lambdabot> flip foldr [] . ((:) .)
08:20:43 <kmc> i think most required data structures courses get as far as "hash tables are fast!!!!!11" but not "trees are better if you want cheap snapshots / copies"
08:21:20 <ciaranm> i don't get the love affair with hash tables
08:21:28 <ddarius> Hash tables are fast.
08:21:38 <hpc> or even "trees are faster than hashes when your record gets humungous"
08:21:50 <hpc> all hash tables really are is a low constant factor
08:22:12 <ciaranm> hash tables are only fast until someone carefully crafts the input to make them linear time, thus giving a denial of service attack
08:22:23 <ddarius> There are ways to prevent that.
08:22:39 <kmc> in C, a decent hash table is much easier to implement than a decent binary search tree or hash trie etc
08:22:54 <kmc> and in C, you are expected to reimplement all data structures from scratch in every project
08:22:54 <ciaranm> i dunno... avl's pretty easy to do in c
08:22:59 <ddarius> But yes, if you are expecting potentially malicious input, using a tree-based structure gives you more predictable performance.
08:24:01 <kmc> actually i'm not sure i should consider any binary tree as "decent"
08:24:19 <ciaranm> why not? you can't get faster than log n anyway
08:24:26 <kmc> cache effects
08:25:36 <kmc> in the real world, decreasing the number of memory accesses by a factor of 4 can make a huge difference
08:25:41 <kmc> even though they're both "log n"
08:25:52 <kmc> asymptotic analysis is really a shitty way to think about real-world performance
08:26:04 <ciaranm> what's this "real world" people keep going on about?
08:26:11 <kmc> my rule of thumb is that for anything below O(n) you should ignore it
08:26:16 <ddarius> ciaranm: The place where hash tables are fast.
08:26:18 <ion> It’s the state in IO.
08:26:37 <ciaranm> there's nothing "in" IO
08:26:48 <Saizan> except for the elves
08:26:49 <ciaranm> monads are not boxes
08:27:20 <ion> *cough* http://hackage.haskell.org/packages/archive/ghc-prim/0.2.0.0/doc/html/src/GHC-Types.html#IO
08:27:21 <merijn> kmc: Not to mention "classical" complexity of algorithms can be of by orders of magnitude in practice due to caching
08:27:54 <mjburgess> how do i perform mathematical operations (+), etc.  on an Int and Integer ?
08:28:13 <ion> > fromIntegral (42 :: Int) + (42 :: Integer)
08:28:13 <kmc> convert one with fromIntegral
08:28:14 <lambdabot>   84
08:28:29 <merijn> mjburgess: My (potentially completely wrong) instinct says fromIntegral
08:28:31 <hpc> or convert the integer with fromInteger
08:28:41 <kmc> or convert the integer with fromIntegral
08:28:44 <hpc> :t toInteger
08:28:44 <lambdabot> forall a. (Integral a) => a -> Integer
08:28:49 <hpc> or use toInteger
08:29:07 <ion> or use unsafeCoerce
08:29:15 <hpc> lol
08:29:16 <kmc> or write your program in perl instead
08:29:45 <merijn> mjburgess: Also, easy solution for next time you have a similar question:
08:29:49 <merijn> @hoogle a -> Integer
08:29:49 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
08:29:49 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
08:29:49 <lambdabot> Prelude id :: a -> a
08:29:58 <kmc> that's not so helpful
08:30:02 <mjburgess> ok; my problem arose from trying to divide sum [1,2,3]  with length [1,2,3] (which return Integer, Int respectivly), im going to fix this with [1,2,3] :: Int
08:30:24 <kmc> sum doesn't return Integer there...
08:30:35 <kmc> it's polymorphic; it returns whichever type is necessary for the rest of the program to make sense
08:30:47 <kmc> > sum [1,2,3] `div` length [1,2,3]
08:30:47 <lambdabot>   2
08:31:02 <mjburgess> i found fromIntegral, but it seemed overkill; i though that Integer/Int really should be treated equally
08:31:11 <kmc> they're totally different
08:31:21 <mjburgess> yes if you write it on one line the type inference will work
08:31:28 <kmc> Int is a machine integer; Integer is a bignum
08:31:43 <mjburgess> i was doing, let results = [1,2,3]    (which assumes [Integer])
08:31:44 <kmc> what is this "overkill", what is that based on? are you looking at the implementation of fromIntegral or something?
08:31:51 <kmc> no it doesn't
08:31:56 <saati> can ghc generate sse/avx code?
08:31:56 <kmc> you can have polymorphic let-bindings too
08:32:01 <ion> mjburgess: genericLength
08:32:24 <mjburgess> yes, i was looking for genericLength  in this instance :)
08:32:39 <kmc> saati, yes, it uses SSE for floating point on x86-64
08:32:42 <mjburgess> overkill meaning that i would have assumed a more reasonable degree of polymorphism
08:32:55 <kmc> yeah
08:33:01 <kmc> it's dumb that 'length' is not polymorphic
08:33:07 <kmc> in fact i think Int shouldn't be in Prelude
08:33:18 <mjburgess> and let r = [1,2,3]     :type  it   produces [Integer] on my machine
08:33:29 <Ke> sse doesn't really imply vectorized operations though
08:33:37 <kmc> mjburgess, yeah, it's different at the ghci prompt
08:33:49 <irene-knapp> okay, so I want to do class (Monad (m backend context), Serial backend) => MonadSerial m backend context where { data Internals m backend ; ... }
08:33:50 <mjburgess> ah i see, ok; thanks
08:34:17 <irene-knapp> that is, I want the associated data instance to be typed based on only one of the monad's extra type parameters, rather than on both of them
08:34:53 <irene-knapp> will this work or will I discover when I get far enough in my implementation that the typechecker can't prove that Internals m backend is equal to itself or some crap like that?
08:34:56 <ddarius> kmc: While we're at it, we should remove length from the Preldue.
08:35:05 <kmc> maybe
08:35:25 <irene-knapp> hm.
08:35:39 <irene-knapp> length should be polymorphic and I can see a case for Int being in prelude
08:35:42 <irene-knapp> er, not being
08:36:37 <ion> mjburgess: You can uses -XNoMonomorphismRestriction to get polymorphic bindings.
08:36:54 <kmc> or put a type signature on
08:37:14 <parcs`> why does the prelude favor int over integer anyway?
08:37:35 <irene-knapp> because Integer's performance characteristics are surprising :)
08:37:59 <kmc> perhaps bignum performance really sucked 21 years ago
08:38:02 <irene-knapp> hm.
08:38:14 <snappy> my bignum library is pretty lame :/
08:38:43 <kmc> it could also be a careless mistake
08:38:49 <irene-knapp> hmm, yes
08:39:04 <copumpkin> careless whisper?
08:39:22 <mzero> parcs`:  the Prelude doesn't favor Int over Integer ---- the Haskell language spec does.  See §4.3.4 http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
08:40:05 <kmc> huh?
08:40:18 <kmc> do you refer to the default default declaration, or what?
08:40:33 <rwbarton> Int doesn't appear in that section except as an example...
08:40:53 <kmc> anyway Prelude is in the Haskell language spec, isn't it?
08:41:45 <rostayob> yes
08:41:51 <mzero> correct, but the implicit default statement for modules for numeric types is    default (Integer, Double)
08:42:15 <kmc> how does that favor Int over Integer?
08:43:11 <mzero> it doesn't
08:43:18 <mzero> it favors Integer over int
08:43:22 <kmc> ok, I must have misunderstood you
08:43:42 <mzero> aha
08:44:04 <kmc> if i were supreme dictator of Haskell i would probably remove defaulting as well
08:44:19 <mzero> no - *I* misunderstood parcs` comment vis-a-vis mjburgess  --- I thought parcs` was making a claim about defaulting -- it was just about choice of concrete types in functions
08:44:20 <kmc> but i'm less sure of that than removing Int from Prelude
08:44:21 <mzero> my bad
08:44:25 <carpi> in quickcheck is it possible to check for functions that return False as a possible value?
08:44:31 <hpc> kmc: or at least the default defaulting
08:44:32 <Nibble> if I were supreme dictator of GHC I would not change one thing
08:44:37 <Nibble> the name is fucking hilarious
08:44:41 <kmc> carpi, yes / what do you mean
08:44:42 <hpc> keep the 'default' keyword for configurable defaulting
08:44:52 <Nibble> The glorious glasgow haskell compilation system
08:44:54 <Nibble> glorious
08:45:05 <kmc> it's not very configurable anyway
08:45:14 <kmc> or would you also extend it to classes beyond the Prelude numeric classes?
08:45:27 <mzero> one wonders why it isn't referred to as GGHC
08:45:45 <kmc> i can imagine a more general, principled defaulting feature
08:45:47 <hpc> mzero: because then nobody would confuse it with gcc
08:45:49 <carpi> kmc: like..for example.. by default it seems like quik check considers a test passed only if all the tests for the generated data returns True.. but what if for some values of the generated data 'False' is also a valid value?
08:45:54 <kmc> the one that's actually in Haskell is a hack
08:46:18 <mzero> ln -s ghc gcc
08:46:22 <kmc> carpi, so you want to test that your function returns either True or False?
08:46:28 <carpi> yea
08:46:36 <carpi> like true for some values and false for some others
08:46:39 <kmc> so you're just checking that it didn't crash?
08:47:38 <merijn> kmc: No, he has a set of inputs which produce true and a set that produces false
08:47:43 <mzero> Normally, carpi, what I do is create a property that given some input, generates only values that the function should return True for ... and then a different property that given some input generates only values that should be Fasle
08:48:04 <merijn> kmc: I guess he just need to split the invariant into two categories
08:48:27 <carpi> not really.. at the moment im simply experimenting with quick check before i begin to use it with real code
08:48:37 <mzero> like     propEvensAreNotPrime = (\n -> not $ isPrime (2 * n)) ::  Int -> Bool
08:48:39 <mzero> and
08:48:52 <carpi> oop that was for kmc
08:49:18 <merijn> carpi: The idea of quickcheck is to define invariants, such as "under these conditions it should only return true"
08:49:56 <shapr> And quickcheck led to smallcheck...
08:49:58 <mzero>     propHasAHole == (\n -> hasAHole ([0..n] ++ [n + 2]))
08:51:34 <mzero> since if one is testing a boolean property of some input, it is generally fruitless to generate random input and check that the input has the property and then check that your property holds!  (Unless one has an obvious inefficient test)
08:52:24 <carpi> so for some data i can specify that the output should be False and for others it should be true
08:52:52 <carpi> or rather i should define such protperties
08:52:56 <irene-knapp> okay so in my custom monad, right, I have two kinds of state
08:53:30 <irene-knapp> the "context" is set at the time the monad is run from outside, and is never changed except by withContext :: context' -> MyMonad context' -> MyMonad context
08:53:38 <irene-knapp> the "internals" are mutable state akin to what StateT would give me
08:53:45 <hpaste> Patinho`Busy pasted “A different code ?” at http://hpaste.org/55433
08:54:08 <irene-knapp> so I was passing context from statement to statement with a type along the lines of
08:54:18 <Patinho`Busy> humm.. someone... any suggestions on http://hpaste.org/55433 ?
08:54:25 <irene-knapp> data MyMonad context a = MyMonad (context -> IO a)
08:54:40 <irene-knapp> but it looks like I can't do that for internals, because of their mutability?
08:54:51 <irene-knapp> they need to be stored somewhere where bind can find them?
08:54:55 <melan> i have problems with executing two functions consecutively. line 27 on http://hpaste.org/55432
08:54:58 <irene-knapp> so my type becomes
08:55:10 <irene-knapp> data MyMonad context a = MyMonad (internals -> context -> IO (internals, a))
08:55:14 <irene-knapp> is that right?
08:55:17 <irene-knapp> or is there a better way?
08:55:24 <irene-knapp> hmmm
08:55:26 <irene-knapp> @hackage mtl
08:55:26 <lambdabot> http://hackage.haskell.org/package/mtl
08:55:33 <kmc> melan, problems?
08:55:33 <rwbarton> @unmtl ReaderT context (State internals)
08:55:33 <lambdabot> Plugin `unmtl' failed with: `ReaderT context (State internals)' is not applied to enough arguments, giving `/\A. context -> internals -> (A, internals)'
08:55:37 <rwbarton> @unmtl ReaderT context (State internals) a
08:55:37 <lambdabot> context -> internals -> (a, internals)
08:55:39 <jmcarthur> newtype MyMonad context a = MyMonad (ReaderT context (StateT internals IO) a)
08:55:50 <irene-knapp> ah hmmmmm
08:55:52 <jmcarthur> @unmtl ReaderT context (StateT internals IO) a
08:55:53 <lambdabot> context -> internals -> IO (a, internals)
08:55:53 <rwbarton> oh yeah, you have IO there also
08:55:57 <irene-knapp> yeah, I do
08:56:04 <irene-knapp> so it does what I am doing!
08:56:07 <irene-knapp> good to know, thank you!
08:56:12 <melan> kmc, problems in meaning that it doesn't work
08:56:19 <kmc> could you be more specific
08:58:28 <melan> kmc, first question, is my approach correct to call two functions with ((labelGetNew demoLabel1) $ mainQuit)?
08:58:53 <kmc> evidently not, because it doesn't work
08:59:01 <kmc> what are you trying to do
08:59:18 <kmc> you want that the onClicked handler should do two things?
08:59:32 <melan> yes, correct
08:59:42 <kmc> ok
08:59:52 <kmc> that's not "calling two functions" so much as "executing two IO actions"
08:59:59 <kmc> see http://www.haskell.org/haskellwiki/Introduction_to_IO
09:00:16 <kmc> anyway, I think you want  onClicked quitButton (labelGetNew demoLabel1 >> mainQuit)
09:00:26 <kmc> here (>>) :: IO a -> IO b -> IO b
09:00:36 <kmc> alternatively it might be easier to understand as
09:00:47 <rostayob> what did the ? and ?? meant again in kind sigs?
09:00:48 <kmc> onClicked quitButton (do { labelGetNew demoLabel1; mainQuit})
09:00:52 <kmc> :k (->)
09:00:53 <lambdabot> ?? -> ? -> *
09:01:05 <kmc> so ?? means * or #
09:01:09 <kmc> and ? means * or # or (#)
09:01:18 <rostayob> ok, what's #?
09:01:24 <kmc> kind of unboxed types
09:01:38 <rostayob> oh. and what's (#)?
09:01:41 <kmc> kind of unboxed tuples
09:01:59 <kmc> a function can take a boxed or unboxed value, and return a boxed or unboxed value or an unboxed tuple
09:02:06 <rostayob> kmc: ok, thanks
09:02:07 <kmc> (unboxed tuples aren't really values)
09:02:26 <melan> kmc, ok... now i understand, thank you!
09:02:32 <kmc> :)
09:02:43 <melan> my first steps in haskell :)
09:03:06 <kmc> if it's your first steps in Haskell, you probably shouldn't be making a GTK gui app
09:05:05 <mjburgess> im doing something like let div2 = (/) 2    which functions as 2/x  rather than x/2  ; how do i achieve the latter?
09:05:16 <ddarius> (/2)
09:05:38 <merijn> mjburgess: "flip (/) 2" or "(/2)"
09:05:39 <mjburgess> ah; and in the case of subtraction?
09:05:50 <merijn> mjburgess: That notation works for all operators
09:06:12 <mjburgess> hmm i couldnt get subtraction to work earlier
09:06:15 <ciaranm> mjburgess: `subtract`
09:06:18 <merijn> Oh wait
09:06:30 <ciaranm> (-2) is negative two
09:06:36 <mjburgess> yes, i thought so
09:06:38 <merijn> mjburgess: That's because minus can be both negation and minus >.>
09:06:55 <mjburgess> yes: which is why i asked :)
09:07:07 <merijn> flip (-) 2 should work
09:07:22 <merijn> > let f = flip (-) 2 in f 5
09:07:23 <lambdabot>   3
09:07:29 <merijn> :t flip
09:07:30 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:07:35 <merijn> wow
09:07:41 <merijn> That's useless for newbies
09:07:57 <mjburgess> i tired `` earlier, i think it didnt work because ghci doesnt like ` on windows
09:08:07 <merijn> flip :: (a -> b -> c) -> b -> a -> c
09:08:20 <mjburgess> flip is intuitively named
09:08:39 <ben> > let f = subtract 2 in f 5
09:08:39 <lambdabot>   3
09:09:01 <mjburgess> and f (a->b) -> a -> f b   is actually fairly clear
09:11:26 <kmc> if i were the emperor of Haskell I would also remove unary minus
09:11:37 <kmc> though maybe -2 (no space) should remain a valid literal
09:12:01 <donri> i wish hyphen was valid in identifiers
09:12:26 <kmc> rostayob, btw, you probably know this, but all those kinds are GHC extensions.  the Haskell Report only has * and (->), and doesn't even give a way to write kinds iirc
09:12:34 <carpi> is there some help document for quickcheck...? the one on haskell wiki is outdated..
09:12:37 <kmc> and it says nothing about unboxed values or tuples
09:12:43 <kmc> carpi, RWH has a chapter about it
09:12:48 <kmc> it might also be a bit outdated
09:12:54 <kmc> but it's worth reading
09:15:03 <nh2> rostayob: obviously, # was the interpol operator before /someone/ changed it into (^-^) ...
09:15:04 <FUZxxl> kmc: Why not _2 for negative numbers?
09:15:07 <carpi> thankx ill check it
09:15:19 <hpc> FUZxxl: that's ugly
09:15:21 <ddarius> FUZxxl: That's a valid identifier.
09:15:25 <hpc> also that
09:15:26 <ddarius> And ugly, yes.
09:15:33 * irene-knapp blinks
09:15:37 <irene-knapp> interpol operator?  haha
09:15:39 <FUZxxl> Well, it solves a problem.
09:15:51 <irene-knapp> (I don't get it)
09:15:57 <FUZxxl> I would also like ~2
09:16:01 <nh2> irene-knapp: https://github.com/scvalex/interpol
09:16:07 <ddarius> ~2 conflicts with lazy patterns.
09:16:28 <irene-knapp> hmmmm, cute
09:18:40 <FUZxxl> ddarius: Well, ~2 is a valid though pointless pattern.
09:18:41 <FUZxxl> I doubt there is any code that uses ~<integer literal>´
09:19:28 <ddarius> x@(~2)
09:19:49 <rwbarton> how does that desugar?
09:19:55 <FUZxxl> ddarius: Making ~2 an exeption is less confusing than -2. ~ is only allowed while matching patterns anyway.
09:20:03 <hpc> rwbarton: ~x | x == 2
09:20:12 <rwbarton> that looks very different
09:20:14 <FUZxxl> hpc: Really?
09:20:18 <hpc> i believe
09:20:34 <rwbarton> what you wrote is also the same as x | x == 2
09:20:36 <rwbarton> or 2
09:20:38 <FUZxxl> hpc: IMHO the match on x won't ever occur.
09:20:39 <rwbarton> (x@2)
09:21:00 <rwbarton> > let f x@(~2) = 3 in f 4
09:21:00 <lambdabot>   3
09:21:07 <rwbarton> > let f x@(~[]) = 3 in f "hello"
09:21:08 <lambdabot>   3
09:21:10 <FUZxxl> > let f (x@ ~False) = x
09:21:11 <lambdabot>   not an expression: `let f (x@ ~False) = x'
09:21:14 <hpc> oh, fascinating
09:21:17 <FUZxxl> > let f (x@ ~False) = x in f True
09:21:17 <lambdabot>   True
09:21:23 <FUZxxl> You see
09:21:32 <rwbarton> ~(anything without variables) is the same as _
09:21:57 <ddarius> > let f x@(~2) = x in f 4
09:21:57 <lambdabot>   4
09:22:02 <rwbarton> so, I think it would be reasonable to disallow the pattern ~2 somehow
09:22:05 <FUZxxl> That's why writing ~2 is pointless
09:22:21 <FUZxxl> rwbarton: It would be good to warn about it being pointless
09:22:24 <rwbarton> though I don't know exactly how you would go about it in the grammar
09:23:10 <FUZxxl> rwbarton: YOu needed to treat a single ~ specially, as it becomes a prefix function in an expression context
09:23:16 <Skola> I'm having some trouble installing Data.JSON:
09:23:18 <hpaste> Skola pasted “problems installing JSON package” at http://hpaste.org/55434
09:23:30 <FUZxxl> But such a treatment exists with - already, so it shouldn't be too difficult.
09:23:58 <FUZxxl> You also needed to redefine the pattern
09:24:02 <FUZxxl> ~ x = ...
09:24:05 <rwbarton> true, "let ~(x:xs) = ..." could be either a binding of (x:xs) or a definition of a case of ~
09:24:05 <Skola> am on Ubuntu, ghc 6.12.1, cabal 1.10.1.0
09:24:25 <rwbarton> > let - x = x in - 3
09:24:26 <FUZxxl> as a definition of ~ instead of a definition of x
09:24:26 <lambdabot>   <no location info>: Parse error in pattern
09:24:27 <donri> sounds old. LTS?
09:24:34 <Skola> yes
09:24:37 <rwbarton> what even happens here?
09:24:54 <FUZxxl> since bindings are lazy by default, this is quite pointless
09:24:56 <rwbarton> unary - x is built in to mean 0 - x?
09:25:02 <rwbarton> or negate?
09:25:07 <FUZxxl> rwbarton: negate
09:25:13 <FUZxxl> IIRC
09:25:28 <rwbarton> but it is baked into the language, not something a user could define for themselves
09:25:34 <benmachine> yes
09:25:36 <FUZxxl> rwbarton: Yes.
09:25:41 <benmachine> you cannot define prefix operators in haskell
09:25:52 <ddarius> rwbarton: ~(x:xs) could be confused as both an irrefutable pattern and a "negation" pattern if this was added.
09:25:53 <FUZxxl> Making a single ~ a prefix function is still hacky but not that much anymore.
09:26:10 <FUZxxl> ddarius: There won't be any "negation pattern".
09:26:23 <ddarius> So I can't match -2?
09:26:31 <rwbarton> I think the idea is just to have negative literals, not an analogue to (n+k)-patterns
09:26:31 <donri> Skola: maybe try cabal install json-0.4.4
09:26:31 <FUZxxl> "~<num>" matches a negative number, "~<anything else>" is a lazy match
09:26:33 <benmachine> sure you can
09:26:38 <benmachine> you can't match -n though
09:26:48 <FUZxxl> benmachine: Why would one want to do that?
09:26:51 <copumpkin> whoa, GHC-7.5.20111216-i386.pkg
09:26:52 <rwbarton> it is a little ugly, in its own way
09:26:55 <benmachine> FUZxxl: one wouldn't :P
09:27:05 <Skola> donri, that worked, <3
09:27:08 <Skola> cheers
09:27:18 <donri> yay
09:27:21 <mzero> copumpkin: ?
09:27:24 <mzero> 7.5?
09:27:26 <FUZxxl> benmachine: As uggly as the binding cond ? x : y = foo; in C
09:27:30 <copumpkin> mzero: I just built myself a 7.5 package, yep
09:27:35 * benmachine tries to remember if negative patterns ever existed
09:27:39 <mzero> there is a 7.5 branch?
09:27:42 <FUZxxl> benmachine: Nope
09:27:43 <copumpkin> mzero: it's what you get if you just build head
09:27:50 <mzero> huh
09:27:59 <copumpkin> I had nothing to do with it, I promise!
09:28:05 <benmachine> FUZxxl: I think I'm being confused by the strange way haskell-src-exts parses negative literal patterns
09:28:19 <copumpkin> airpumpkin2:MacOS pumpkin$ ghc -v
09:28:19 <copumpkin> Glasgow Haskell Compiler, Version 7.5.20111216, stage 2 booted by GHC version 7.0.4
09:28:27 <FUZxxl> benmachine: Well, technically a negative literal is a negative positive literal...
09:29:03 <benmachine> FUZxxl: HSE parses it as PNeg (PLit (Int 2))
09:29:13 <FUZxxl> uf...
09:29:20 <copumpkin> @tell mzero I hope my very high GHC version didn't offend you! you left just after I pasted my version :(
09:29:20 <lambdabot> Consider it noted.
09:29:29 <benmachine> but afaict you can only ever get PLit inside PNeg
09:29:39 <FUZxxl> benmachine: hehe
09:29:55 <benmachine> so it is all a bit silly
09:30:12 <kmc> air pumpkin
09:30:16 <copumpkin> yup
09:30:20 <copumpkin> you have a problem with that?
09:30:23 <copumpkin> cause i cut u
09:30:25 <kmc> is that like air bud
09:30:36 <ddarius> It's not that there's a 7.5 branch, it's that there is now a 7.4 branch.
09:30:36 <donri> copumpkin: pff, that's two days old.
09:30:59 <copumpkin> donri: weird, cause I just built it yesterday
09:31:20 <Saizan> but today is tomorrow
09:32:17 <copumpkin> oh shit
09:32:47 * ddarius really needs to start churning out BS.
09:33:08 <copumpkin> butterscotch?
09:33:14 <copumpkin> I didn't realize that was churned
09:33:22 <ddarius> Butterscotch is atrocious.
09:35:58 <ddarius> Butterscotch is almost as bad as Reese's.
09:36:16 <alistra> candy thread?
09:42:05 <copumpkin> mokus: thanks for chiming in
09:53:04 <Yrogirg> Hello! Does the ghc clutter like
09:53:04 <Yrogirg> SpecConstr
09:53:04 <Yrogirg>     Function `$j_se64{v} [lid]'
09:53:04 <Yrogirg>       has one call pattern, but the limit is 0
09:53:04 <Yrogirg>     Use -fspec-constr-count=n to set the bound
09:53:04 <Yrogirg>     Use -dppr-debug to see specialisations
09:53:04 <Yrogirg> mean my code is bad?
09:55:55 <mauke> probably not
09:56:13 <mauke> because I get the same thing
09:56:28 <ddarius> Maybe you are both writing bad code.
09:56:37 <mauke> hah
09:56:38 <ddarius> But that message only has to do with optimizations.
09:56:41 <cl1> monads are like the visitor pattern?
09:56:54 <hpc> is the visitor pattern like a burrito?
09:56:54 <ddarius> No.
09:56:58 <mauke> burritos are like the façade pattern
09:57:34 <cl1> monads are like a burrito? o_O
09:57:38 <ion> Space suits are like the checkerboard pattern
09:58:36 <PatrickRobotham> A monad is a monoid in the category of endofunctors.
09:58:47 <PatrickRobotham> (What's the problem?)
09:58:57 <cl1> PatrickRobotham, i'm learning monads
09:58:59 <hpc> a category is a monoid in the category of 2-categories?
09:59:29 <PatrickRobotham> hpc: Is it?
09:59:37 <hpc> PatrickRobotham: i have no idea :P
09:59:43 <hpc> @quote 2-categories
09:59:43 <lambdabot> No quotes match. The more you drive -- the dumber you get.
09:59:49 <cl1> i dunno what an endofunctor is so PatrickRobotham' statement makes no sense to me
09:59:54 <FUZxxl> cl1: Monads are actually just warm-fuzzy-things.
09:59:57 <roconnor_> Is a monoid a monoid in the category of categories?
10:00:15 <kmc> yo dawg i heard you like categories
10:00:21 <PatrickRobotham> cl1: It's a joke from "A inaccurate history of programming languages"
10:00:22 <FUZxxl> roconnor_:  Well, the opposite surely holds
10:00:39 <cl1> oic
10:00:44 <FUZxxl> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
10:00:57 <kmc> cl1, no, monads are not like the visitor pattern
10:01:04 <kmc> they're not like much of anything else besides monads
10:01:13 <cl1> okay
10:01:15 <kmc> it's best not to learn monads (or any other Haskell feature) by analogy
10:01:20 <kmc> but i realize that is hard
10:01:27 <PatrickRobotham> Ah, there we go
10:01:38 <cl1> i guess so
10:01:40 <PatrickRobotham> cl1: Let me break the argument for you down in to steps.
10:01:42 <kmc> i'm sorry that you got a stream of in-jokes instead of an answer to that question
10:01:47 <hpc> the trick to monads is learning functor and applicative first
10:01:53 <kmc> cl1, the burrito meme comes from
10:01:54 <kmc> @where burrito
10:01:54 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
10:01:59 <kmc> which is a good relevant article
10:02:00 <PatrickRobotham> cl1: The standard introduction (the way I learned, and LYAH teaches) is to learn functor and applicative.
10:02:01 <cl1> hpc, i have
10:02:13 <cl1> i get those two
10:02:31 <cl1> i'm on http://learnyouahaskell.com/a-fistful-of-monads
10:02:35 <kmc> cl1, sometimes, the visitor pattern is like an approximation of pattern-matching
10:02:38 <cl1> the first monad stuff
10:02:39 <PatrickRobotham> cl1: Ok, well, monoid has an extra function: m a -> (a -> m b) -> m b
10:02:53 <PatrickRobotham> not monoid, monad
10:03:28 <kmc> each visitor represents a single thing you want to do on your data structure, and implements a method for each type of node in the data structure
10:03:32 <cl1> yes and it allows you to "unwrap" the value contained in your context so that you can pass it to the function that takes that value and produces a new context
10:03:35 <ddarius> A category is a monad in the bicategory of spans of set.
10:03:47 <PatrickRobotham> cl1: Right.
10:03:52 <cl1> i get that part, its a continuation
10:03:55 <kmc> cl1, it's wrong to say that there's a value contained in the context, though
10:03:59 <kmc> there's no Int hiding inside IO Int
10:04:08 <cl1> okay
10:04:12 <kmc> or inside Char -> Int
10:04:13 <kmc> there's zero or many Ints hiding inside [Int]
10:04:16 <PatrickRobotham> kmc: There's not?
10:04:25 <kmc> which?
10:04:36 <PatrickRobotham> No Int hiding inside IO Int
10:04:38 <kmc> correct
10:04:41 <kmc> a value of type IO Int represents an imperative program which has not yet run
10:04:44 <irene-knapp> a loose description is that an IO Int is a set of "IO" instructions that will produce an Int
10:04:47 <kmc> the program, if executed, would produce an Int
10:04:53 <kmc> if you execute it again, it might produce a different Int
10:04:55 <irene-knapp> there's no chocolate cake hiding inside the Joy of Cooking, either
10:04:59 <PatrickRobotham> kmc: Well that's some value of "hiding" isn't it?
10:05:02 <kmc> irene-knapp, maybe not in your copy
10:05:04 <cl1> the IO is the context containing the int
10:05:06 <PatrickRobotham> irene-knapp: Ah, I see.
10:05:09 <irene-knapp> kmc: yeah, haha, not in my copy :)
10:05:10 <ddarius> Damn you kmc.
10:05:11 <PatrickRobotham> Fair enough
10:05:13 <cl1> that int doesn't exist without the context
10:05:16 <PatrickRobotham> That's a good analogy.
10:05:30 <ddarius> @quote /bin/ls
10:05:30 <lambdabot> No quotes match. Take a stress pill and think things over.
10:05:34 <irene-knapp> @quote ls
10:05:34 <lambdabot> mauke says: reading existentials is hard. let's go shopping!
10:05:37 <irene-knapp> @quote bin
10:05:38 <lambdabot> vincenz says: <Philippa> you can catch stuff off someone who's asymptomatic <vincenz> Philippa: only if you allow your body to become assymptotic with his <Binkley> nice typo <vincenz> it's a typo?
10:05:38 <kmc> PatrickRobotham, yeah, if you redefine the word "hiding" to mean something totally unlike its English meaning, then there's an Int hiding inside IO Int
10:05:40 <ddarius> shachaf needs to remember himself.
10:06:01 <kmc> monads are like containers, as long as you forget everything you know about what a container is, and take it to be a term synonymous with "monad"
10:06:07 <hpc> kmc: don't forget "inside"
10:06:29 * PatrickRobotham wilts under kmc's withering sarcasm
10:06:34 * ddarius strongly agrees with kmc's last statement.
10:06:46 <kmc> PatrickRobotham, sorry, I don't mean this to be directed at you specifically
10:06:50 <kmc> it's a common analogy for monads
10:06:57 <kmc> and it has some value
10:07:03 <PatrickRobotham> kmc: Well you can see why, containers are monads
10:07:06 <kmc> but like most analogies there is a point where it breaks down
10:07:09 <kmc> right
10:07:33 <kmc> in fact one can formalize a distinction between "algebraic monads" and "control monads", and the former might be more like containers in a precise sense
10:07:43 <PatrickRobotham> kmc: I mean, Functors can be explained as containers, I learned Functor by someone saying to me "Think of map, and notice how we can do something equivalent to trees."
10:07:43 <kmc> even (Char -> Int) can be seen as a very large container of Ints
10:07:53 <hpc> indexed by Char
10:07:53 <kmc> with one position per Char
10:08:11 <danr> > hpc == kmc
10:08:12 <lambdabot>   Not in scope: `hpc'Not in scope: `kmc'
10:08:13 <PatrickRobotham> So IO Int is indexed by states of the world :P
10:08:46 <kmc> right, but does that description help you reuse any useful intuition about containers
10:08:58 <kmc> lots of things are technically correct but useless or misleading
10:09:06 <PatrickRobotham> Right.
10:09:21 <mux> kmc: only the fact that you can extract a value out of it? sounds fair enough to me.
10:09:28 <PatrickRobotham> I've got this mad ego thing where I hate to admit I'm wrong.
10:09:28 <kmc> but you can't, really
10:09:29 <mux> maybe a bit far-fetched
10:09:37 <mux> you can
10:09:39 <PatrickRobotham> mux: But you can't extract a value from Monad.
10:09:46 <mux> you're not understanding me
10:09:50 <PatrickRobotham> mux: There's no function with the type signature: IO a -> A
10:10:05 <mux> you can in that you can act on that value; use it in the sense that you will perform some aciton with it
10:10:08 <PatrickRobotham> replace A with a
10:10:13 <kmc> you can do what the type of (>>=) says you can do.  describing that with the english word "extract" seems dubious to me
10:10:23 <mux> PatrickRobotham: that's beside the point
10:10:41 <PatrickRobotham> mux: Well shouldn't that be the type signature for extracting?
10:10:46 <mux> extracting doesn't necessarily mean going from a type x a to a type a
10:11:04 <mux> if you like, you can work with those values
10:11:18 <kmc> how about the trivial monad  data M a = M;  instance Monad M where { return _ = M;  _ >>= _ = M }
10:11:19 <mux> you're thinking about the type system, I'm thinking about computation
10:11:22 <cl1> so IO is like a baby sitter with toys, and if I want to play with them, I first have to go over to their house. Then I can ask to play with a specific toy. However, I cannot take any of those toys, home with me.
10:11:27 <kmc> no
10:11:34 <cl1> At home I can play with my toys all I want
10:11:42 <hpc> kmc: i think i would call Identity the trivial monad
10:11:46 <kmc> maybe
10:11:47 <hpc> and M the "vacuous" monad
10:11:49 <kmc> maybe mine is the Const () monad
10:12:04 <kmc> anyway if I use (>>=) on M Int, am i "extracting" an Int so I can "work with" it?
10:12:16 <PatrickRobotham> My analogy for (>>=) is that it works like piping does in unix.
10:12:53 <PatrickRobotham> I'm not sure how misleading this is though
10:13:25 <kmc> my analogy for (>>=) is that if m is an instance of the typeclass Monad, then for any types a and b, (>>=) takes a value of type (m a) and one of type (a -> m b) and returns a value of type (m b)
10:13:41 <rwbarton> ah yes, the trivial analogy
10:13:43 <mux> but you can call that an analogy? you're paraphrasing the type system :-)
10:13:52 <kmc> are you sure it's not the vacuous analogy ?!?
10:14:08 <hpc> :P
10:14:21 <PatrickRobotham> kmc: Is it terribly misleading to think of (>>=) like piping though?
10:14:32 <kmc> no
10:14:37 <kmc> but i don't think it's terribly helpful either
10:14:44 <mux> same here
10:14:46 <cl1> can I get to the string value of IO String outside of a do statement?
10:14:49 <kmc> yes
10:14:55 <kmc> "do" is just syntactic sugar
10:14:58 <mux> cl1: do syntax is just syntax
10:15:05 <PatrickRobotham> cl1: Yes, you can use (>>=).
10:15:06 <kmc> but, like I said several times, there's not really a "String value of IO String"
10:15:20 <kmc> an IO String is a program which, if you executed it, would produce a String
10:15:24 <PatrickRobotham> In fact, you are using (>>=) when you use do statements, the syntactic sugar just hides this for you.
10:15:31 <kmc> Haskell programs are functional programs which compute imperative programs
10:15:37 <PatrickRobotham> kmc: Just like there's no cake inside a cake recipe.
10:15:54 <cl1> but return in a do statement produces IO String, not String
10:16:01 <mux> or an effectful container indexed by the infinite states of the world? *grin*
10:16:06 <kmc> correct cl1
10:16:11 <cl1> so after a do statement I must use >>= to get the string?
10:16:19 <kmc> why don't you read Introduction to IO?
10:16:25 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
10:16:32 <PatrickRobotham> cl1: What do you want to do?
10:16:34 <benmachine> an oddity: the derived Show instance for data types with infix constructor depends on how you constructed the datatype
10:16:40 <donri> monads specify how to lift a value out of a context, apply a function to that value and put it back inside the context
10:16:43 <benmachine> *infix constructors
10:16:46 <kmc> cl1, you're still going wrong, when you say you want to "get the string"
10:16:52 <cl1> PatrickRobotham, learn haskell and understand monads
10:17:00 <cl1> kmc, fine
10:17:21 <Philippa_> you want to put the string through some more code. It doesn't have to come out of the box: the code can go in the box
10:17:30 <PatrickRobotham> cl1: Ok, but what are you trying to do with the string that your do statement will produce? (to satisfy kmc)
10:17:56 <cl1> i don't know, i'm just trying to understand the context
10:18:12 <benmachine> data Foo a = (:<) a a -- show (1 :< 2) = "(:<) 1 2"; data Foo a = a :< a -- show (1 :< 2) = "1 :< 2"
10:18:14 <PatrickRobotham> cl1: Ok, well, the first thing is that IO stays IO.
10:18:44 <PatrickRobotham> cl1: Code that does IO is tainted forever, and can never yield a pure value.
10:18:48 <benmachine> a side-effect of this is that you can only use the first form when using GADT syntax, so GADTs don't Show nicely
10:18:55 <hpc> (except for when it can, but never learn those functions)
10:18:59 <benmachine> hpc: shh
10:19:10 <mux> hahaha
10:19:20 <benmachine> hpc: a bit of outright lying never hurt anyone
10:19:36 <ddarius> Where is the Handle in ioError "file not found" :: IO Handle
10:19:57 <hpc> ddarius: over there -->
10:20:00 <PatrickRobotham> cl1: So, let's take simple IO
10:21:11 <benmachine> copumpkin: rather than me take the billion years necessary to acquire and compile the latest GHC, can you test something for me with yours
10:21:36 <PatrickRobotham> cl1: The following haskell asks a user for their name and welcome them. (print "What is your name?") >>= (\_ -> getLine) >>= (\name -> print $ "Hello " ++ name)
10:21:54 <PatrickRobotham> At least I hope it does, that code isn't bugged is it?
10:22:18 <mux> it looks okay but you have unnecessary parens
10:22:25 <copumpkin> benmachine: if you're on a mac, I've made my custom installer available
10:22:29 <copumpkin> benmachine: but otherwise sure
10:22:33 <hpc> PatrickRobotham: works here
10:22:34 <PatrickRobotham> Cool.
10:22:44 <benmachine> copumpkin: I'm on a macbook running linux, does that count :P
10:22:54 <hpaste> benmachine pasted “prefix/infix constructors” at http://hpaste.org/55435
10:22:56 <PatrickRobotham> cl1: Ok, so let me walk you through the code.
10:23:02 <mux> and you could have used >> but I suppose that was intended
10:23:12 <PatrickRobotham> mux: Yes, that was intended
10:23:17 <benmachine> copumpkin: http://hpaste.org/55435 I'm expecting test1 to be shown infix and test2 to be shown prefix
10:23:44 <benmachine> copumpkin: and then I'm being annoyed about this because it means if I want pretty shows for GADTs with infix constructors I seemingly have to write them myself
10:23:58 <copumpkin> λ> test1
10:23:58 <copumpkin> 1 :. 2
10:23:58 <copumpkin> λ> test2
10:23:58 <copumpkin> (:/) 3 4
10:24:05 <benmachine> neat thx
10:24:12 <copumpkin> np
10:24:13 <benmachine> do you reckon I can call this a bug?
10:24:25 <hpc> benmachine: nah; it's what showsPrec is fr
10:24:25 <PatrickRobotham> cl1: We can read this left to right. print "What is your name?" has type IO ()
10:24:29 <hpc> *for
10:24:34 <cl1> right
10:24:34 <benmachine> hpc: I do not follow
10:24:35 <copumpkin> benmachine: not sure, but it's probably worth a ticket
10:24:42 <copumpkin> benmachine: it does seem annoying
10:24:47 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:showsPrec
10:24:57 <copumpkin> yeah, writing your own show instances is a pain though
10:25:02 <cl1> hang on, dogs are barking
10:25:03 <benmachine> hpc: I know of showsPrec but it doesn't solve my problem
10:25:04 <copumpkin> it's not hard
10:25:05 <PatrickRobotham> cl1: getLine has type IO String
10:25:07 <copumpkin> it's just annoying
10:25:07 <benmachine> afaict
10:26:37 <hpc> benmachine: oh, it looks like you have to give a fixity specification
10:26:43 <hpc> like infixr 5, or something
10:27:01 <benmachine> hpc: why do you think that will help?
10:27:08 <benmachine> (it doesn't on my GHC)
10:27:34 <dropdrive> Hi, I just defined "instance Functor ((->) t)" but it seems like this doesn't make "((->) t)" a monad?
10:28:14 <hpc> dropdrive: all you did was make it a functor
10:28:17 <PatrickRobotham> dropdrive: No, all monads are functors but not all functors are monads.
10:28:44 <PatrickRobotham> dropdrive: You need to implement the following type signatures to make ((->) t) a monad:
10:29:03 <PatrickRobotham> dropdrive: return :: a -> (t -> a)
10:29:07 <PatrickRobotham> not too hard
10:29:09 <cl1> okay, i'm back
10:29:19 <dropdrive> Whoops, I had the inclusion backwards!
10:29:35 <rwbarton> even if you had it the right way, there is no magic here
10:29:46 <PatrickRobotham> (>>=) :: (t -> a) -> (a -> (t -> b)) -> (t -> b)
10:29:47 <rwbarton> Foo will be a Monad instance if you write instance Monad Foo
10:29:49 <rwbarton> and otherwise not
10:29:52 <hpc> PatrickRobotham: return and (>>=)
10:30:00 <mux> yes, the inclusion unfortunately isn't reflected in the typeclass hierarchy
10:30:01 <hpc> oh, nvm
10:30:09 <dropdrive> Okay, thanksa ll.
10:30:26 <PatrickRobotham> cl1: Ok. getLine has type IO string.
10:30:31 <PatrickRobotham> IO String even
10:30:33 <FUZxxl> I have a question.
10:30:51 <FUZxxl> If you would redesign Haskell completely, what would you change?
10:30:57 <dropdrive> So why isn't ((->) t) an instance of Monad?  (I know it is, but it doesn't seem to be in the prelude?)
10:31:08 <PatrickRobotham> cl1: \_ -> getLine has type () -> IO String
10:31:13 <carpi> could someone please tell me what is the purpose of the 'shrink' function in the Arbitrary typeclass in quickcheck? i understand what the arbitrary function is for but shrink confounds me
10:31:17 <Botje> FUZxxl: have you looked into haskell prime? that's a good start about what people would change
10:31:18 <FUZxxl> dropdrive: I don't know... avoid abuse for codegolf?
10:31:23 <PatrickRobotham> Technically, I think it has type a -> IO String, right?
10:31:31 <cl1> yes
10:31:33 <danr> dropdrive: it is in Control.Monad.Instances
10:31:43 <PatrickRobotham> @t \_ -> getLine
10:31:43 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:31:43 <rwbarton> it doesn't look like the Haskell 98 report specifies whether 'show' uses prefix or infix notation except in an example
10:31:45 <cl1> but in this context it has type () -> IO String because it able to infer the type
10:31:57 <hpc> dropdrive: hiding it by default makes a certain class of type errors phenomenally less painful to debug for beginners
10:31:58 <PatrickRobotham> @ypet \_ -> getLine
10:31:58 <lambdabot> Maybe you meant: let type
10:32:05 <PatrickRobotham> @type \_ -> getLine
10:32:05 <lambdabot> forall t. t -> IO String
10:32:06 <cl1> @t \_ -> getLine :: ()
10:32:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:32:06 <FUZxxl> Botje: Well, you need to preserve compatibility in Prime. I mean if you would completely redesign it without caring for compatibility
10:32:16 <rwbarton> oh, I suppose it does via the specification of Read
10:32:18 <PatrickRobotham> cl1: Right.
10:32:41 <PatrickRobotham> cl1: So, our first thing in brackets had type IO (), our second thing in brakets had type () -> IO String
10:32:50 <PatrickRobotham> cl1: Thus we can use >>=
10:33:05 <dropdrive> danr: Does that mean that if I import C.M.I, it will take effect in that file?
10:33:05 <cl1> we are using \_ because we don't care about the parameter, we are calling getLine
10:33:17 <PatrickRobotham> cl1: Right.
10:33:36 <PatrickRobotham> cl1: Also, print returns effectively nothing
10:33:42 <dropdrive> FUZxxl: I really like the proposal where map = fmap = (.)
10:33:44 <PatrickRobotham> () is a way of saying nothing without actually having nothing
10:33:45 <Botje> FUZxxl: http://hackage.haskell.org/trac/haskell-prime/wiki/RemovalCandidates for example
10:33:54 <cl1> you could have used >> instead of >>= (\_ -> ...)
10:34:00 <cl1> correct?
10:34:02 <PatrickRobotham> cl1: Yes
10:34:08 <cl1> okay, just checking
10:34:11 <PatrickRobotham> @type >>
10:34:12 <lambdabot> parse error on input `>>'
10:34:18 <PatrickRobotham> @type )>>)
10:34:19 <lambdabot> parse error on input `)'
10:34:22 <PatrickRobotham> @type (>>)
10:34:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:34:30 <PatrickRobotham> There we go
10:35:05 <FUZxxl> Botje: That's still just changing bits, not radical changes.
10:35:06 <PatrickRobotham> cl1: Anyway, that's fine. The next thing is \name -> print "Hello" ++ name
10:35:27 <PatrickRobotham> cl1: This has type String -> IO ()
10:35:34 <danr> dropdrive: yes indeed
10:35:54 <FUZxxl> dropdrive: Me too
10:36:08 <danr> dropdrive: notice also that import Control.Applicative gives you the ((->) e) Applicative instance
10:37:41 <PatrickRobotham> cl1: So, do you see how all this monadic code fits together?
10:38:05 <cl1> the monad is responsible for getting the string to your function (\name -> print $ ...)
10:38:12 <cl1> yes, i understand all of this
10:38:28 <carpi> could someone please tell me what is the purpose of the 'shrink' function in the Arbitrary typeclass in quickcheck? i understand what the arbitrary function is for but shrink confounds me
10:38:52 <ddarius> carpi: shrink shrinks a counter-example,
10:38:59 <cl1> what I don't understand is 1) how come the monad doesn't "contain" the string if it has to do something to get you a string to pass to your function that takes a string, and 2) why is this useful
10:39:01 <shapr> carpi: If you find a value that fails to meet your property, sometimes it's too large to easily understand.
10:39:35 <merijn> cl1: It does contain the string, you just can't get it out
10:39:36 <ddarius> cl1: Does /bin/ls contain a list of files?
10:39:42 <carpi> ddarius: shrinks a counter example?
10:39:43 <merijn> cl1: Actually, I'm wrong
10:39:57 <ddarius> (to steal shachaf's example)
10:40:01 <cl1> merijn, yes it does not contain the string, i have been told that already
10:40:06 <merijn> cl1: IO a is not "an a in IO" it's "an IO that could potentially produce an a"
10:40:20 <cl1> ddarius, that makes sense
10:40:39 <ciaranm> merijn: that's even more misleading than saying it contains it
10:40:40 <cl1> no ls does not contain the list of files, it goes and gets them
10:40:43 <merijn> cl1: Are you familiar with callbacks/event systems? (Like opengl loops, node.js, python's twisted, etc.)
10:41:23 <cl1> yes I use them when doing multi-threaded programming in c#
10:41:29 <ddarius> cl1: And ls :: IO [Handle] does not contain a list of handles, but is an action that will go and get them, but maybe it will fail and not return at all.
10:41:50 <shapr> carpi: If QuickCheck finds a 25 megabyte counterexample to your QuickCheck property, you probably don't want to comb through that. Instead, QuickCheck snips off parts of the failing counter example and checks to see if the smaller value is still a counter example.
10:41:53 <merijn> cl1: Think of "foo >>= f" as installing a callback f to call on the result of foo when foo actually produces a result
10:41:55 <ddarius> callbacks/event systems are usually done to avoid multi-threaded programming.
10:42:21 <shapr> carpi: So, shrink tries to get you the smallest value that fails to meet your property.
10:43:01 <shapr> carpi: Is that clear?
10:43:30 <merijn> cl1: "IO String" an action that (when executed) produces a String. "(foo :: IO String) >>= f" then produces a new action, which (when executed) produces a String and runs f on that String
10:43:57 <merijn> cl1: The usefulness of IO being explicit in the type system is that it helps you predict what functions can and cannot do
10:44:45 <carpi> shapr: you mean if QS generates a very large value in the the data set.. then it keeps shrinking that particular value until it finds a value that still holds?
10:44:52 <carpi> *QC
10:45:11 <cl1> merijn, that makes a bit more sense
10:45:15 <shapr> carpi: Yes, it's a convenience function for easier reading of the value.
10:45:18 <merijn> cl1: "(a -> Ordering) -> [a] -> [a]" there are only so many things this function can do, because we KNOW it does not do any IO, ever.
10:45:59 <shapr> carpi: Given the choice between a one line value and a multi-page value that both demonstrate I don't understand either the code or the invariants, I'd opt for the one line value.
10:46:31 <carpi> shapr: can you please give me an example..?
10:46:44 <shapr> carpi: The simplest example is the shrink function for lists, where one item is removed from the list and the value is run through the property again.
10:46:51 <rwbarton> carpi: are you trying to write an Arbitrary instance and wondering how to implement shrink?
10:46:52 <merijn> cl1: In imperative languages every statement is executed one after the other. The problem in haskell is (since the language is lazy) how do you enforce the notion of "before" and "after"
10:46:53 <cl1> I get it! IO String doesn't contain a String!
10:47:07 <shapr> So, if [1,2,3,4] fails your test, then shrink will return [1,2,3] and that will checked.
10:47:57 <ciaranm> cl1: you know, by now you could have learned enough to understand what "monoid in the category of endofunctors" means
10:48:02 <cl1> it "produces" a string that can be used
10:48:14 <carpi> so shrink basically has to do with the size of a type and not necessarily the magnitude of the type?
10:48:16 <PatrickRobotham> claranm: Are there people who know what that means?
10:48:19 <merijn> cl1: Yup, and (>>=) tells the compiler how to actually use it
10:48:30 <ciaranm> PatrickRobotham: sure
10:48:33 <carpi> rwbarton: oh no no.. i am simply trying to understand the QC module so i can use it in my code
10:48:47 <PatrickRobotham> ciaranm: In this channel?
10:48:51 <ciaranm> PatrickRobotham: yup
10:49:09 <PatrickRobotham> Ok. So what is the category of endofunctors?
10:49:10 <cl1> so containers are a subset of monads. meaning a container can be a monad, but not all monads are containers
10:49:45 <ciaranm> PatrickRobotham: it's the category where the objects are endofunctors and the morphisms are natural transformations
10:49:46 * PatrickRobotham knows what a category is and what a functor is, if that helps
10:49:55 <rwbarton> carpi: as shapr described,'shrink' is just used as part of quickcheck's heuristic to produce "simple" counterexamples. so it can produce a "simpler" value, in whatever sense is appropriate for the type in question
10:50:00 <ciaranm> PatrickRobotham: an endofunctor is just a functor from A to A
10:50:14 <PatrickRobotham> ciaranm: Ok, so endofunctors of which category?
10:50:23 <PatrickRobotham> ciaranm: Hask?
10:50:24 <rwbarton> there is no formal description of what "simpler" is supposed to mean
10:50:36 <ciaranm> PatrickRobotham: Hask to Hask, in haskell's case
10:50:55 <PatrickRobotham> ciaranm: Ok. So what's a natural transformation?
10:51:01 <rwbarton> except it is supposed to be a value of the same type, of course
10:51:42 <carpi> thanks for the clarification.. atleast now i know what it is really for.
10:52:04 <ciaranm> PatrickRobotham: a natural transformation is pretty much what you expect it to be
10:52:11 <PatrickRobotham> Let F and G be endofunctors, a natural transformation from F to G is...
10:52:20 <merijn> cl1: I think you're right, but I'm not one hundred percent sure whether all containers can be monads
10:52:24 <ciaranm> PatrickRobotham: a "function" that turns F into G
10:52:54 <PatrickRobotham> ciaranm: So how does it do that?
10:53:38 <ciaranm> PatrickRobotham: in haskell? it's a * -> * plus an fmap or something similar
10:53:52 <cl1> merijn, i'm at least "more" right than I was when this conversation started
10:54:13 <PatrickRobotham> ciaranm: Hold on, that seems a bit strange.
10:54:16 <merijn> cl1: Essentially (in the case of IO) >>= just turns small simple IO operations into more complex IO operations by adding callbacks/pure functionality to them
10:54:28 <PatrickRobotham> ciaranm: A * -> * is an endofunctor right?
10:55:16 <ciaranm> PatrickRobotham: draw pictures, and don't pay too much attention to what i'm saying. it's easier!
10:55:22 <PatrickRobotham> ciaranm: Ok, so we've got a functor f with kind * -> *
10:55:27 <PatrickRobotham> ciaranm: Haha
10:55:36 <merijn> cl1: Which is then used to, for example, make: "forM :: Monad m => [a] -> (a -> m b) -> m [b]" where you create a bigger IO operations by combining lots of smaller IO operations (in this case the same one, on different elements of a list)
10:55:43 <ciaranm> PatrickRobotham: a functor doesn't just transform objects. it also transforms morphisms.
10:55:46 * PatrickRobotham mutters about these new-fangled category theorists.
10:56:23 <Guest77027> I'm pretty new to haskell, so I'm doing some exercises I came up with, but I can't seem to get this to work:
10:56:24 <Guest77027> Lem' :: Int -> [a] -> a
10:56:24 <Guest77027> Lem' n [] = 0
10:56:24 <Guest77027> Lem' n (x:xs) = Lem' (n-1) xs
10:56:44 <PatrickRobotham> ciaranm: Ok, so we've got two functors: f and g, and we want to turn f in to g.
10:56:49 <dmwit> Goosey: variables must have a name starting with a lower-case letter.
10:57:02 <PatrickRobotham> ciaranm: How do we do this?
10:57:09 <dmwit> Goosey: Also, you're not returning an "a" in the first case, you're returning a number!
10:57:15 <tomprince> So, you need a map from 'f x' to 'g x' for every type x.
10:57:30 <Goosey> dmwit: so would it be Int -> [a] -> Int
10:57:42 <dmwit> Goosey: That could be a fine type signature.
10:57:45 <tomprince> That needs to behave well with respect to fmap.
10:57:57 <Goosey> Well, what I'm trying to do is find the nth item in a list
10:58:02 <merijn> cl1: Another way to look at it is "foo >>= f" foo is the state of your program and the result of "foo >>= f" is the state of your program after you run f in context foo. In C# and other imperative languages you don't even think about this, because it's what happens at every new line
10:58:05 <ddarius> ciaranm: A natural transformation in Hask is a (particular form of a) polymorphic function.
10:58:19 <Goosey> But I can't even get it started so I can fix the logical errors xD
10:58:23 <donri> Goosey: (!!) already does that, but perhaps you're doing it for practice?
10:58:25 <PatrickRobotham> so nat :: forall a. f a -> g a ?
10:58:28 <dmwit> Goosey: Perhaps you want your base case to be "lem' 0 (x:xs)" instead of "lem' n []", then.
10:58:32 <Goosey> donri: Yeah, that is it
10:58:36 <ddarius> PatrickRobotham: Where f and g are Functors, yes.
10:58:49 <dmwit> Goosey: Anyway, yeah, start with getting it to compile, then get it right. =)
10:58:52 <ddarius> PatrickRobotham: The free theorem is the law that natural transformations have to satisfy.
10:58:57 <cl1> merijn, I get what you are saying
10:58:59 <ciaranm> ddarius, PatrickRobotham: yeah, there's a paper i'm trying to find that had a really nice explanation of natural transformations being polymorphism, complete with the picture
10:59:06 <dmwit> Goosey: So fix the two obvious errors first: lower case names + matching type signatures.
10:59:15 <PatrickRobotham> ddarius: So "playing nice"
10:59:17 <Goosey> Thanks dmwit
10:59:34 <merijn> cl1: It is impossible to separate parts from your program state. But in Haskell the default is that everything is separate from the state and >>= (and also >>, etc) explicitly state "now I *do* want to use the global state"
10:59:44 <PatrickRobotham> let k :: a-> b
11:00:00 <merijn> cl1: Since I got this Haskell has been my favorite imperative language :p
11:00:04 <PatrickRobotham> we want nat.(fmap k) = (fmap k).nat?
11:00:12 <PatrickRobotham> I think that's right...
11:00:26 <Goosey> OH
11:00:28 <Goosey> I got it :D
11:00:37 <PatrickRobotham> fmap k turns f a to f b
11:00:44 <PatrickRobotham> nat turns f b to g b
11:00:47 <ddarius> In general, for functors F, G : C -> D, a natural transformation from t : F -> G is a family of arrows in D indexed by C i.e. t_c : Fc -> Gc such that forall f : c -> c' in C fmap f . t_c = t_c' . fmap f.
11:00:48 <donri> Goosey: but you do want to return an "a" not Int. for the empty list you should throw an error (or use an error-allowing type like Maybe or Either)
11:00:50 <PatrickRobotham> that's on the left
11:01:04 <Goosey> lem' :: Int -> [a] -> a
11:01:04 <Goosey> lem' 1 (x:xs) = x
11:01:05 <Goosey> lem' n (x:xs) = lem' (n-1) xs
11:01:10 <cl1> merijn, i need to let this sink in a bit more
11:01:13 * hackagebot QuickCheck 2.4.2 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.4.2 (NickSmallbone)
11:01:35 <PatrickRobotham> ddarius: Hooray, my intuitions work )
11:01:45 <Goosey> donri: I haven't learned about Maybe or Either yet xD, I'm on the 2nd chapter of Learnyouhaskell. :/
11:01:49 <merijn> cl1: No worries, I think it took me a few months before I realised how simple it actually was :p
11:01:58 <ciaranm> PatrickRobotham: the last paper in "Topology and Category Theory in Computer Science" (1991), which i can't find
11:02:06 <ddarius> PatrickRobotham: So now what's a natural transformation between functors between posets viewed as categories.
11:02:14 <donri> Goosey: ok, then just stick to error "bla"
11:02:32 <PatrickRobotham> ddarius: Oh god.
11:02:37 <donri> @src (!!)
11:02:37 <lambdabot> xs     !! n | n < 0 = undefined
11:02:37 <lambdabot> []     !! _         = undefined
11:02:37 <lambdabot> (x:_)  !! 0         = x
11:02:37 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:02:44 <PatrickRobotham> ok, let's see.
11:03:08 <Goosey> Wow, how handy.
11:03:15 <PatrickRobotham> posets viewed as categories. The objects are the elements of the set and there's an arrow from a to b if a <= b
11:03:22 <ddarius> Check.
11:03:30 <donri> ("undefined" is just error without a custom message)
11:03:44 * ddarius wishes we had case x of {}
11:03:48 <PatrickRobotham> ddarius: So functors are monotonic functions
11:03:48 <Goosey> How would I catch an exception where there isn't an nth list item?
11:03:54 <ddarius> PatrickRobotham: Check.
11:03:58 <PatrickRobotham> i.e. if a <= b then f(a) <= f(b)
11:04:10 <ciaranm> that's not monotonic! grrrr
11:04:17 <merijn> Goosey: I wouldn't worry about that right now if you're only in chapter 2 of LYAH
11:04:17 <Goosey> nevermind, I'll use length
11:04:23 <ddarius> The ordering might change, so this also covers anti-monotonic, though for an endofunctor, it would be forced to monotonic.
11:04:38 <merijn> Goosey: How to do that gets handled later together with alternatives to exceptions (i.e. maybe/either)
11:04:46 <Goosey> Oh okay
11:05:03 <donri> Goosey: length is quite naughty though
11:05:30 <Goosey> :o
11:05:50 <rwbarton> "quite naughty"?
11:05:57 <PatrickRobotham> ddarius: Ok, so for each object in our poset C, we have an arrow in our poset D.
11:06:04 <shapr> w00t, new QuickCheck version!
11:06:04 <Goosey> Also, it seems my function will only accept lists of a single type
11:06:11 <donri> Goosey: it has to consume the whole list which may be infinite
11:06:28 <merijn> Goosey: You mean that it won't accept lists with multiple types in it?
11:06:31 <donri> Goosey: lists only contain one type
11:06:35 <dmwit> length is pretty benign compared to certain other list-based functions.
11:06:38 <merijn> Goosey: That's because lists can only contain one type
11:06:41 <Goosey> I thought you can do a list with ['a',1] etc?
11:06:45 <PatrickRobotham> ddarius: Sorry, I'm a bit confused. Can you help me out here?
11:06:48 <Goosey> Oh, well that could be the problem xD
11:07:19 <donri> Goosey: http://www.haskell.org/haskellwiki/FAQ#How_do_I_make_a_list_with_elements_of_different_types.3F
11:07:22 <dolio> PatrickRobotham: What's the type of the arrow for each object?
11:08:08 <PatrickRobotham> dolio: Um, D -> D -> Bool?
11:08:17 <dolio> No.
11:08:35 <parcs`> donri++
11:08:48 <parcs`> (for linking to the faq :P)
11:08:48 <rwbarton> (do people really use "monotone" to mean "either monotone increasing or monotone decreasing"?)
11:08:54 <dolio> if t is the natural transformation, what is its type at object A?
11:08:56 <donri> yay karma
11:09:20 <dolio> Or, object x if you prefer.
11:09:31 <Philippa_> rwbarton: most of the time it's isomorphic
11:09:39 <Philippa_> you just swap the ordering round first
11:09:46 <PatrickRobotham> dolio: Sorry, I'm not sure what the type of my arrows in a poset is supposed to be.
11:09:52 <rwbarton> well, of course
11:09:58 <dolio> A natural transformation is a family of arrows.
11:10:05 <rwbarton> but you still have to pick a meaning for "a monotone function from P to Q"
11:10:07 <ddarius> rwbarton: It's kind (and by "kinda" I mean "exactly") like contravariant functors being covariant functors.
11:10:19 <ciaranm> rwbarton: i think i've most commonly seen "(strictly) increasing" and "(strictly) decreasing", and monotone meaning "either increasing or decreasing"
11:10:35 <dolio> For each object of C you have an arrow of D.
11:10:43 <rwbarton> I would just always assume "monotone" means "monotone increasing".
11:10:44 <dolio> If x is an object of C, what is the type of the arrow in D?
11:10:46 <Goosey> I haven't even learned how to put multiple statements in a single function, I've tried using ',' but it doesn't work...
11:10:52 <ddarius> rwbarton: If you equip P and Q with orderings, then "monotone" means preserves ordering.  It may be the case that the ordering in Q is the opposite one, in which case it is "decreasing."
11:10:52 <rwbarton> (anyways, sorry for OT)
11:10:56 <dolio> For that object.
11:11:51 <rwbarton> ddarius: right, but "the collection of monotone functions from P to Q" is not "those functions f such that EITHER forall x y. x <= y implies f(x) <= f(y) OR forall x y. x <= y implies f(x) >= f(y)", right
11:11:56 <PatrickRobotham> dolio: Sorry, I don't know.
11:11:56 <hpaste> irene-knapp pasted “Yet another mystery error!” at http://hpaste.org/55437
11:12:16 <irene-knapp> okay, so, I made a short test program that exhibits a problem similar to what my real program has
11:12:20 <irene-knapp> and hpasted it
11:12:29 <ddarius> rwbarton: No.  It is just the collection of functions that preserve the orderings on P and Q.
11:12:41 <irene-knapp> it's saying one of my type variables is ambiguous, which would make sense, since I want this code to work for all values of it ><
11:12:48 <ddarius> And by "No" I mean I'm agreeing with you.
11:13:12 <kmc> i still don't understand the prevalence of weird analogies for IO.  for what reason are people not satisfied with "an IO action is an imperative program as a first-class value"?
11:13:21 <kmc> is the idea of programs manipulating programs just too weird?
11:13:28 <tomprince> kmc: Yes.
11:13:34 <merijn> kmc: To any not doing Lisp/ASM? Yes.
11:13:34 <irene-knapp> kmc: hmm.  yeah, never thought about that, but it shouldn't be too weird :(
11:13:39 <merijn> s/any/anyone
11:13:48 <kmc> it's one of the most important, fundamental ideas in CS...
11:14:01 <ciaranm> most people don't do CS. they do programming.
11:14:02 <dolio> PatrickRobotham: Have you learned about natural transformations yet? I may just be fishing for an answer you don't know.
11:14:11 <irene-knapp> indeed, it's the reason CS exists - if computers couldn't manipulate their own programs, they couldn't, er, compute :)
11:14:14 <kmc> even so, some of the most fundamental ideas in CS are surely relevant to programming
11:14:20 <PatrickRobotham> dolio: No, I'm trying to learn about natural transformations.
11:14:24 <kmc> i think many of the people confused by that idea are happy gluing together strings and passing them to eval() in PHP
11:14:50 <dolio> t is a transformation from f : C -> D to g if for each x in C there is an arrow t_x : ? in D
11:14:56 <kmc> maybe the difficulty is that, sure, an IO action is a program, but it's also a somewhat mysterious opaque value.  it's not clear which tools you get for manipulating it
11:15:02 <dolio> I was asking to fill in the ?
11:15:26 <PatrickRobotham> Ah
11:15:33 <tomprince> PatrickRobotham: You already said what an arrow is, at least implicitly. There is an arrow between two objects in a poset iff a <= b. So an arrow in a poset is just the fact that a <= b.
11:15:56 <PatrickRobotham> that fact isn't a type though!
11:16:08 <PatrickRobotham> Oh god I'm so confused
11:16:10 <ciaranm> category theory doesn't have types
11:16:16 <dolio> It doesn't?
11:16:27 <ciaranm> not in the sense PatrickRobotham is thinking, anyway
11:16:57 <ddarius> That programs can manipulate programs is one of the core ideas of computer science.
11:16:59 <PatrickRobotham> dolio: Is the type you're looking for: t_x : f x -> g x ?
11:17:03 <dolio> Yes.
11:17:07 <PatrickRobotham> Hooray
11:17:16 <dolio> What does f x -> g x mean?
11:17:32 <PatrickRobotham> f(x) <= g(x)
11:17:34 <tomprince> Well, if you wanted to give haskell types to the hom-sets, you would have either unit or void (ignoring undefined).
11:17:47 <PatrickRobotham> if we're talking about posets.
11:17:51 <dolio> Right.
11:18:01 <tomprince> unit if a <= b or void otherwise.
11:18:11 <dolio> So, does that ring any bells now?
11:18:46 <PatrickRobotham> Its image is smaller?
11:18:49 <int-e> irene-knapp: but how should that code work for any 'context'? ghc needs to pick a particular instance for 'MonadSerial' (and 'Monad (m context)') -- which in particular means that m and context need to be fixed.
11:19:13 <PatrickRobotham> I don't know the name for when f(x) <= g(x)
11:19:16 <PatrickRobotham> for all x
11:19:36 <Goosey> I'm not really sure what to do from here:
11:19:36 <Goosey> palin [] = True
11:19:36 <Goosey> palin (x:xs) = x == last(xs)
11:19:36 <Goosey> palin (x:xs) = palin init(xs)
11:19:50 <ddarius> Goosey: I recommend deleting it all and starting over.
11:20:00 <kmc> are you sure you don't mean  palin (x:xs) = palin (init xs)
11:20:03 <irene-knapp> int-e: hmmmmmmm, yes, okay
11:20:03 <dolio> PatrickRobotham: That's a common ordering on functions.
11:20:08 <dolio> Point-wise ordering.
11:20:09 <ciaranm> Goosey: do you know what the (x:xs) means?
11:20:17 <irene-knapp> int-e: I found my workaround, which is to put context in the type parameters of Internals
11:20:17 <dmwit> Goosey: I don't recommend deleting it and starting over.
11:20:18 <kmc> of course, the second equation with the same pattern will never be used
11:20:18 <Goosey> it's the head and tail of a list
11:20:25 <dmwit> Goosey: However, I do recommend learning about function calls in Haskell.
11:20:34 <irene-knapp> for those keeping score at home, that thing which I asked two hours ago whether it would cause me trouble later and nobody really knew?
11:20:35 <kmc> also syntax
11:20:36 <PatrickRobotham> dolio: Ok, makes sense I suppose.
11:20:38 <irene-knapp> it caused me trouble later :)
11:20:40 <dmwit> Goosey: In short, function application doesn't require parentheses as it does in other languages.
11:20:45 <kmc> > let f [] = 3; f [] = 7 in f []
11:20:46 <ciaranm> Goosey: no, i mean, do you know why having (x:xs) there twice doesn't work?
11:20:46 <lambdabot>   3
11:20:53 <dmwit> Goosey: "f(x)" is just "f x".
11:21:00 <dmwit> Goosey: However, parentheses *are* used for grouping.
11:21:13 <dolio> That is, natural transformations are the usual/natural induced ordering on monotone functions.
11:21:29 <dmwit> Goosey: So, "f x y" is "f" applied to the expressions "x" and "y"; "f (x y)" is "f" applied to the expression "x y".
11:21:33 * ddarius can understand people writing f(x) and in fact that will work fine in Haskell.  I don't understand why they aren't consistent with it.
11:21:46 <Goosey> oh...
11:21:48 <kmc> ddarius, because you're also imitating other Haskell code you've seen
11:21:54 <kmc> in LYAH or whatever
11:22:24 <ddarius> kmc: Yeah, but how do they decide palin shouldn't need parentheses but init does?  They didn't see code like that anywhere.
11:22:44 <kmc> *shrug* cargo cult
11:23:12 <dolio> Obviously the init(xs) should bind tighter than the other application.
11:23:16 <ciaranm> you silly liberals putting palin in parentheses. why are you so scared of a strong, well educated, outspoken conservative woman?
11:23:37 <ddarius> ciaranm: I want to put parentheses after palin.
11:24:01 <ddarius> Anyway, I blame VB.
11:24:21 <int-e> irene-knapp: I can imagine what you want -- namely an assertion that the shape of 'm context' does not depend on 'context' -- but since 'm' could be a data or type family, there's no such guarantee. I'm not sure how to express this in Haskell (some helper type class 'Monad1 m where return :: a -> m ctx a' etc. and an instance 'Monad1 m => Monad (m ctx)' could possibly work, but lead into overlapping instances hell.
11:25:47 <irene-knapp> int-e: yeah, hmmmmmmm
11:25:59 <irene-knapp> int-e: that is roughly what I want, but oh well I guess
11:26:03 <dolio> m cannot be a type family, at least.
11:26:06 <dolio> They aren't first-class.
11:26:11 <irene-knapp> and I don't want overlapping-instances hell, obviously :)
11:26:46 <irene-knapp> anyway I'm in the process now of fixing problems introduced by adding "context" as a type parameter of the "Internals" data family
11:27:44 <Goosey> um
11:27:48 <Goosey> I got it working
11:28:00 <Goosey> whenever it's a palindrome it says Exception: prelude.last empty list >_>
11:28:02 <irene-knapp> the major problem is that the thing that runs an action with a different context inside this action doesn't work now
11:28:13 <ddarius> Goosey: Sounds very working to me.
11:28:25 <Goosey> But palin [] = True shuld be catching it
11:28:28 <Goosey> should*
11:28:44 <dmwit> Goosey: Not at all.
11:28:50 <dmwit> Look what list you call "last" on.
11:28:58 <cl1> what was that full "monoid in the category of endofunctors" statement?
11:29:03 <ion> Try adding QuickCheck properties. It’ll tell you the minimum input for which it fails.
11:29:03 <dmwit> (Hint: it's not the same list you call "palin" on.)
11:29:08 <irene-knapp> @quote monoid in the category
11:29:08 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
11:29:08 <Goosey> palin :: String -> Bool
11:29:09 <Goosey> palin [] = True
11:29:09 <Goosey> palin (x:xs) = if x == last xs then palin (init xs) else False
11:29:25 <ddarius> cl1: A monad is a monoid object in the category of endofunctors.
11:29:26 <ciaranm> cl1: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html , although the actual quote is from Mac Lane
11:29:42 <ddarius> cl1: Alternatively, a monad is a lax functor from the terminal bicategory.
11:30:10 <MostAwesomeDude> I thought it was a magical container of hopes, dreams, and ponies.
11:30:19 <ciaranm> monads aren't containers!
11:30:33 <MostAwesomeDude> What about the ponies?
11:30:45 <int-e> ponies are containers. sort of. heh.
11:30:51 <ddarius> @hackage pony
11:30:51 <lambdabot> http://hackage.haskell.org/package/pony
11:31:01 <ion> mostawesomedude: The meat in the burrito is pony/unicorn meat.
11:31:02 <jessopher> monomorphic containers that only hold guts
11:31:06 <irene-knapp> unsafeCoerce :: Hope -> Dream
11:31:08 <ciaranm> isn't a unicorn just a pointed pony?
11:31:14 <dmwit> int-e: Um. Doesn't the existence of fmap make the guarantee irene-knapp wants?
11:31:16 <irene-knapp> ciaranm: haha
11:31:17 <nh2> I've got some stack overflow problem here: I wrote an interpreter running a list of instructions, and memory grows with the size of the list, which it shouldn't. How can I find out where the memory goes?
11:31:20 <nh2> I've already gone through cabal-reinstall-all-dependencies-with-profiling-manually-hell, but the prof output doen't really enlighten me.
11:31:36 <dmwit> I mean, fmap has to be parametrically polymorphic, so it can't depend on the particular types the thing contains in the same way the data type itself can.
11:31:36 <irene-knapp> dmwit: wait, that sounds important! :D
11:31:39 <irene-knapp> hmmm
11:32:14 <Goosey> Scratch that, it causes exceptions on palindromes that have an odd number of letters
11:32:40 <int-e> dmwit: we're talking about a two argument constructor m, such that m context is a monad (which, of course, is also a functor). and the argument that we'd need a similar uniformity constraint for is the first one.
11:32:49 <ddarius> Goosey: And what does it do on "axya"
11:33:09 <int-e> ah right, parametricity.
11:33:29 <Goosey> ddarius, returns false, "rr" returns true, "rrr" returns false.
11:33:39 <nh2> I basically have eval (i:is) = evalSingle i >> eval is, with eval :: ErrorT ... (StateT MyVars IO) (Maybe ReturnVal)
11:33:39 <dmwit> int-e: If the instance is for all ctxt and once, then I think my claim still applies.
11:33:46 <Goosey> "rrr" returns an exception*
11:34:01 <dmwit> int-e: On the other hand, if there are several instances for different ctxt's, then you're probably right -- you don't get the guarantee.
11:34:19 <dmwit> err... oh, I see.
11:34:28 <dmwit> Yeah, okay, fmap doesn't give the right guarantee at all.
11:34:29 <dmwit> Okay, bummer.
11:34:33 <int-e> dmwit: we don't have the instance though, we have a 'Monad (m ctx)' context. I think that's the root of the problem.
11:34:40 <parcs`> Goosey: do you know why an exception is raised?
11:35:02 <Goosey> I have an idea,
11:35:17 <Goosey> when it hits palin [] = True it's a single element list
11:35:26 <Goosey> But when it hits palin (x:xs) = if x == last xs then palin (init xs) else False
11:35:32 <Goosey> xs is transformed into an empty list
11:36:06 <ddarius> Goosey: What does it return on "aaxxxa"?
11:36:15 <int-e> dmwit: so my idea was to define a type class for 'm', but I don't see a nice way to get a monad instance out of it without overlapping instances or (tedious) auxillary newtypes.
11:36:31 <ddarius> Or on "xaax" for that matter.
11:36:50 <dmwit> int-e: More newtype wrappers. ;-)
11:36:55 <Goosey> xaax returns true
11:37:14 <Goosey> aaxxxa returns false
11:37:24 <Goosey> xaaax would cause an exception
11:37:30 <dmwit> Goosey: [] is not a single element list
11:37:36 <Goosey> dmwit, I know
11:37:39 <Goosey> that's the problem
11:37:54 <rwbarton> "it" = the argument to palin
11:38:03 <dmwit> Goosey: ...and in (x:xs), xs is not guaranteed to be a non-empty list.
11:38:11 <Goosey> dmwit, that's the problem :P
11:38:18 <dmwit> Goosey: So fix it.
11:38:47 <Goosey> When it's an odd palindrome, xs will become empty after palin [] and before last xs is performed on it
11:38:57 <Goosey> dmwit: I'm working on that xD
11:40:08 <ciaranm> palin :: String -> Bool ; palin _ = error "the libral lame stream programmer provided a gotcha argument"
11:46:37 <Goosey> ahah
11:46:46 <Goosey> That was so easy, I was making it harder than I thought >_>
11:46:58 <Goosey> I could have just put palin [x] = True
11:47:25 <parcs`> or palin xs = xs == reverse xs :P
11:47:38 <Goosey> :|
11:47:41 <danr> (==) <*> reverse, wee
11:48:09 <Goosey> wait, you can compare entire lists at once?
11:48:28 <parcs`> what?
11:48:57 <Goosey> palin xs = xs == reverse xs
11:49:03 <parcs`> you can do that
11:49:14 <Goosey> I can't believe I went the long way >_>
11:49:32 <ion> You probably learned something by going the long way.
11:49:45 <TomvdZ> Using System.Console.GetOpt, is it possible to parse something like "main.exe inputfile [options]", with there being no flag before inputfile?
11:50:51 <Goosey> I did xD, I learned there are shorter ways :P considering it was an excercise, I'm happy I went the long way.
11:51:29 <irene-knapp> yay!  my thing is doing the thing
11:51:32 <irene-knapp> now it needs to do the next thing
11:51:48 <dmwit> TomvdZ: Yes, I think so.
11:51:57 <dmwit> hold on
11:52:41 <dmwit> ah
11:52:52 <donri> TomvdZ: Permute as first argument to getOpt?
11:52:57 <dmwit> TomvdZ: The way I did something similar in one of my programs was to just strip the first argument off myself.
11:53:23 <dmwit> TomvdZ: e.g. (inputfile:options) <- getArgs -- or so
11:53:48 <dmwit> Bonus points for doing the case statement afterwards and handling []. =)
11:54:27 <dmwit> donri: cool
11:54:37 <dmwit> donri: I didn't know about ArgOrder, I bet I can transition to that.
11:54:47 <donri> yay :)
11:55:14 <TomvdZ> I think I get it now. It returns a list of "non-options" which would probably contain my filename.
11:55:21 <dmwit> right
11:55:38 <TomvdZ> I considered the manual stripping but I don't like that, though using the non-options isn't much better.
11:55:40 <TomvdZ> Thanks!
11:59:47 <dmwit> Wait, what?
11:59:58 <dmwit> TomvdZ: "Using the nonoptions isn't much better"?
12:00:05 <dmwit> Isn't that exactly what they're for?
12:00:21 <TomvdZ> Well, yes, it's the way you're meant to do it
12:00:49 <jmcarthur> danr: i suspect you meant   (==) =<< reverse
12:01:01 <dmwit> :t (<*>)
12:01:01 <jmcarthur> :t (==) =<< reverse
12:01:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:01:02 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:01:09 <jmcarthur> :t (==) <*> reverse
12:01:10 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:01:13 <jmcarthur> hmm
12:01:17 <dmwit> (==) <*> reverse -- looks fine to me
12:01:19 <TomvdZ> However, I would have hoped for nicer abstractions, since this requires an extra check to see if you have enough non-options whereas I'd want GetArgs to do it for me.
12:01:24 <jmcarthur> surely they aren't the same in this case?
12:01:53 <Goosey> How would I take a list and then return each element of it separately?
12:02:10 <jmcarthur> Goosey: depends on what you mean by return
12:02:22 <jmcarthur> what do you want to do with them?
12:02:37 <Goosey> jmcarthur: ie I have a function that takes an int, but I want to have a list of ints that returns each one to the function separately
12:02:43 <dmwit> ?check \x y -> (((==) =<< reverse) x y) == (((==) <*> reverse) x y)
12:02:43 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `=='Not in scope: `reverse'Not in...
12:02:45 <jmcarthur> try map
12:02:51 <jmcarthur> > map (+1) [1,2,3]
12:02:52 <lambdabot>   [2,3,4]
12:04:08 <parcs`> jmcarthur: they should be
12:04:12 <Tom^2> Good evening. I am seeking for rather elementary function. Is there a function in Prelude that inserts an item to a list at a given position, or do I have to write it myself? For example: insertAt :: [a] -> a -> Int -> [a]
12:04:16 <fryguybob> > (,) <*> reverse $ [x,y,z]
12:04:16 <lambdabot>   ([x,y,z],[z,y,x])
12:04:18 <fryguybob> > (,) =<< reverse $ [x,y,z]
12:04:19 <lambdabot>   ([z,y,x],[x,y,z])
12:04:31 <parcs`> (==) =<< reverse = flip (==) <*> reverse
12:04:51 <jmcarthur> oh i see
12:05:05 <jmcarthur> so they are the same when the first argument is commutative
12:05:06 <dmwit> TomvdZ: There's splitAt; implement it from there.
12:05:16 <Nisstyre> Tom^2: such a function would be useless, since it would run in O(n) time
12:05:23 <rwbarton> "useless"
12:05:30 <Nisstyre> well not *useless*
12:05:34 <Nisstyre> but just use a mutable array
12:05:40 <rwbarton> ...
12:05:43 <jmcarthur> a mutable array? really?
12:05:53 <jmcarthur> that is also going to be O(n)
12:05:56 <benmachine> use a Data.Sequence
12:05:58 <Nisstyre> why would you want to insert things in the middle of a linked list though?
12:06:13 * hackagebot shake 0.1 - Build system creator  http://hackage.haskell.org/package/shake-0.1 (NeilMitchell)
12:06:21 <rwbarton> because n is small and that's the easiest way to do it, perhaps
12:06:23 <ddarius> copumpkin:
12:06:31 <benmachine> Tom^2: the easiest way to implement it yourself is to use splitAt, but as other people say this may be a sign that you want to use a different data structure
12:07:53 <Tom^2> I know that the function will be O(n), what I have is a tree that is shown in GUI, to which users add items. So, I don't know in advance how what items will be in the list. Vectors would be not suitable either, because the list needs to grow.
12:08:07 <jmcarthur> Data.Sequence
12:08:20 <jmcarthur> it would have O(log n) insert
12:08:46 <ddarius> You may want to consider a zipper.
12:08:50 <jmcarthur> or, if some circumstances, a zipper might be reasonable
12:08:56 <jmcarthur> beaten again
12:09:13 <jmcarthur> *in some
12:09:20 <alistra> implement a rbt
12:09:27 <fryguybob> shake is getting released?
12:09:29 <jmcarthur> we already have rbts
12:09:42 <alistra> data.sequence are rbts?
12:09:46 <jmcarthur> Data.Map ios
12:09:48 <jmcarthur> *is
12:10:05 <ddarius> alistra: No, Data.Sequence is something far more involved.
12:10:10 <jmcarthur> Data.Sequence is nicer though because it also gives you constant time access to the ends
12:10:21 <jmcarthur> *and* O(log n) split/insert
12:10:26 <Cale> What's an rbt?
12:10:26 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:10:35 <jmcarthur> Cale: red black tree i'm guessing
12:10:38 <Tom^2> How is Data.Sequence implemented?
12:10:43 <ddarius> It's a fingertree.
12:10:44 <Cale> ah, of course
12:10:44 <jmcarthur> Tom^2: it's a finger tree
12:10:45 <alistra> jmcarthur: rbt can also have that, not sure with the split, though
12:11:05 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
12:11:09 <copumpkin> dons: oh wow
12:11:10 <alistra> probably avl can have that
12:11:10 <jmcarthur> alistra: rbt has constant time access to the ends? how?
12:11:10 <copumpkin> ddarius: thanks!
12:11:21 <ddarius> I don't think Data.Map is a RB tree.  It is a size-balanced tree though.
12:11:28 <copumpkin> it isn't RB, no
12:11:31 <jmcarthur> i thought it was rb...
12:11:33 * jmcarthur checks
12:11:39 <copumpkin> it's a loosely balanced tree
12:11:41 <alistra> jmcarthur: Uh in C it has 2 pointers, in haskell those would be probably 2 mutable references?
12:11:56 <alistra> not big on data structures in haskell :]
12:12:06 <nh2> I require a function from containers-0.4.1.0, but my dependencies require 0.4.0.0. Can I force to use 4.1?
12:12:08 <Cale> alistra: Finger trees are immutable
12:12:09 <Goosey> @src reverse
12:12:09 <lambdabot> reverse = foldl (flip (:)) []
12:12:21 <jmcarthur> ah, yeah, i was wrong, not rb
12:12:38 <alistra> jmcarthur: you were asking about general case
12:12:39 <alistra> or haskell?
12:12:43 <ddarius> There is also IntMap for Int keys.
12:12:45 <alistra> with the constant on both ends
12:13:03 <jmcarthur> alistra: pure rb trees can't have constant on both ends, afaik, but sure, with mutation and back pointers it could happen
12:13:47 <alistra> well it's a constant memory cost and constant time
12:13:49 <Cale> alistra: Basically, the tree is designed so that even without involving mutation, you get constant time access to both ends and logarithmic-time splitting and concatenation.
12:13:52 <alistra> so it's really really cheap
12:14:09 <jmcarthur> alistra: not constant time if it's pure
12:14:10 <Cale> (logarithmic in the size of the smaller piece)
12:14:32 <ddarius> alistra: Read Okasaki's thesis (and/or book if you can get it.)
12:14:43 <alistra> i have a copy
12:14:45 <Goosey> lambdabot's source for reverse is giving me parse errors ._.
12:14:46 <alistra> on my toread list
12:14:47 <jmcarthur> alistra: also, what you are speaking of only gives you constant time peek. it doesn't give you constant time removal or addition, afaik (but i suppose it's possible...)
12:14:51 <Cale> @src reverse
12:14:51 <lambdabot> reverse = foldl (flip (:)) []
12:14:56 <alistra> i've read the rbt in haskell paper
12:15:01 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
12:15:03 <lambdabot>   [5,4,3,2,1]
12:15:03 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:15:07 <ddarius> @check True
12:15:08 <lambdabot>   Not in scope: `myquickcheck'Not in scope: data constructor `True'Not in sco...
12:15:14 <ddarius> Cale: ^
12:15:18 <Cale> yeah :P
12:15:19 <Axman6> > let rev = foldl (\xs x -> x:xs) [] in rev "hello"
12:15:20 <lambdabot>   "olleh"
12:15:32 <Cale> need to find out what's happening there
12:15:37 <Philippa_> Cale: I've finally been convinced to at least put a monad tutorial on my blog's "to write" list :-)
12:15:42 <alistra> jmcarthur: i don't think it's possible without a big remodel, because the end could have been black
12:15:47 <Tom^2> Cale: It seems that Data.Sequence is closest to what I want. I even have the "Purely Functional Data Structures" book. Should realy
12:15:54 <alistra> so the invariant would be violated
12:15:56 <Axman6> Philippa_: it's a right of passage
12:15:58 <Tom^2> ...ly read it sometime :-)
12:16:15 <jmcarthur> ah right
12:16:21 <ddarius> Tom^2: Fingertrees aren't covered in it.  I would also recommend reading the paper about fingertrees.
12:16:23 <alistra> yamt, yet another monad tutorial
12:16:38 <ddarius> Axman6: Philippa's been here for a -long- time.
12:16:40 <donri> yamt, your average monad tutorial
12:16:45 <Cale> Philippa_: haha, what'll the approach be? :) Via free monads?
12:16:57 <alistra> why people can't just understand
12:17:03 <jmcarthur> i've considered doing the same, but i try to avoid it
12:17:05 <alistra> that monads are like a box of spacesuits
12:17:16 <alistra> or wait, was that a monad transformer?
12:17:18 <Philippa_> Axman6: I was giving in-person tutorials here back before Cale'd written anything up :-)
12:17:41 <ddarius> Back before the dark days.
12:17:55 <alistra> i think haskell has too much tutorials and not enough code written in it :D
12:17:59 <Cale> Tom^2: at least read the Finger Tree paper, it's really good
12:18:00 <jmcarthur> *before* the dark days? what were (are?) the dark day?
12:18:02 <Philippa_> Cale: Mmm, so going deep->shallow, using overloading let as an initial motivation and ANF as evidence that it's probably the right track ;-)
12:18:03 <jmcarthur> *days?
12:18:17 <Tom^2> Cale: I am reading it now :-)
12:18:18 <Philippa_> jmcarthur: ddarius means the flood of "monads are bad analogies" tutorials
12:18:22 <jmcarthur> ah
12:18:38 <Philippa_> I think I've earned the room to go contrary to established wisdom on this one, anyway!
12:19:00 <ddarius> Back then we only had to worry about "So, monads are all about state, right?"
12:19:59 <alistra> srsly, don't write another tutorial :D
12:20:14 <jmcarthur> everyone thinks they can do a better one
12:20:25 <Philippa_> *nod*. I learned my first chunk of CT to verify my intuitions at the time about what they covered other than "stateful things". These days, I'll concede that monads-in-haskell have a close relationship between the implementation type and the state of something...
12:20:26 <copumpkin> yeah, they should realize that only I can actually write a better one
12:20:29 <alistra> it's not good enough
12:20:46 <jmcarthur> copumpkin: i can write a better one too!
12:20:52 <jmcarthur> we can write better tutorials than each other
12:20:52 <copumpkin> nope
12:20:54 <copumpkin> only me
12:20:58 <Philippa_> alistra: I do have a specific, well-founded angle to follow for what it's worth. And I'm not exactly unused to explaining monads to people
12:21:22 <alistra> Philippa_: the taco explaination/?
12:21:22 <jmcarthur> copumpkin: your tutorials are like rice paper!
12:21:28 <copumpkin> :(
12:22:05 <jmcarthur> you should write up your unicorn analogy. with censored pictures.
12:22:20 <alistra> the horn pixeled out
12:24:19 <BobFunk> what's the best way to get a unix timestamp in haskell?
12:24:49 <alistra> @hoogle date
12:24:49 <lambdabot> System.Locale dateFmt :: TimeLocale -> String
12:24:49 <lambdabot> package datetime
12:24:49 <lambdabot> System.Locale dateTimeFmt :: TimeLocale -> String
12:24:58 <alistra> @hoogle now
12:24:58 <lambdabot> Text.Html nowrap :: HtmlAttr
12:24:58 <lambdabot> Text.XHtml.Transitional nowrap :: HtmlAttr
12:24:58 <lambdabot> package acme-now
12:25:13 <alistra> acme-now is a cool way
12:25:27 <BobFunk> alistra: heh - checking
12:25:40 <alistra> it's actaully unsafePerformIO( somethingReturningIOTime)
12:25:43 <Cale> lol
12:25:53 <BobFunk> haha
12:25:56 <alistra> so it's acme-now :: Int
12:25:59 <Cale> Yeah, that's not the way you want though :P
12:26:01 <Philippa_> alistra: it might come as a shock, but a decade's experience can actually lead to knowing stuff beyond "it's this abstract thing you have to just use until you get it"
12:26:40 <alistra> Philippa_: well, write another project with your 10 year experience instead of wasting it on blog posts :D
12:26:55 <alistra> write a project that awesome, that people will forget xmonad
12:27:05 <alistra> now :: UTCTime
12:27:05 <alistra> now = unsafePerformIO getCurrentTime
12:27:08 <Philippa_> *shrug* - as it happens I'm a lot better at getting writing done than projects (not that that's saying much)
12:27:14 <alistra> so you want getCurrentTime
12:27:16 <alistra> > getCurrentTime
12:27:17 <lambdabot>   Not in scope: `getCurrentTime'
12:27:35 <alistra> Philippa_: that's sad
12:27:35 <Philippa_> though if it helps, if you've used parsec 3 it's partly my fault that got done
12:27:51 <alistra> i like happy better
12:27:55 <alistra> :3
12:27:59 <jmcarthur> i don't think blog posts are wastes of time. in fact, i think it would be better if i blogged more often
12:28:00 <Philippa_> eh, not really. If you're a researcher, the writing's an important part
12:28:15 <Cale> BobFunk:
12:28:17 <alistra> not to brag, but i think i have a 2 line patch in happy myself
12:28:17 <Cale> ghci> :m + Data.Time.Clock.POSIX
12:28:18 <alistra> :P
12:28:21 <Cale> ghci> getPOSIXTime
12:28:21 <Cale> 1324241949.585902s
12:28:41 <BobFunk> Cale: thanks - looks like just what I need
12:28:44 <Philippa_> alistra: I proposed and mentored the GSoC project, fair enough
12:28:46 <Philippa_> ?
12:28:50 <alistra> ok
12:28:52 <alistra> wait
12:28:56 <alistra> it's a trick question
12:29:03 <alistra> what was the topic of the project
12:29:11 <Philippa_> yeah, the indication it is one's on the next line because I typoed, awesome trick!
12:29:13 <Cale> That gives you a NominalDiffTime, which you can round if you just want an Int
12:29:23 <donri> blogging is overrated, people should collaborate on haskellwiki more instead
12:29:57 <Philippa_> alistra: something like "Generalizing Parsec to ParsecT and arbitrary input (ByteStrings)"
12:29:57 <alistra> what was the topic of the project Philippa_
12:30:03 <alistra> ok
12:30:34 <Philippa_> hell, I've still got the t-shirt in the other room
12:30:42 <alistra> picture
12:30:46 <alistra> :D
12:31:12 <Cale> The Data.Time library could probably use a few more IO helpers to make some things more convenient, but that aside, it's one of the best time libraries I've ever seen.
12:31:34 <ddarius> Philippa_: I got rid of my T-shirt when I moved.
12:31:39 <copumpkin> I hate time!
12:31:43 <ddarius> I didn't do anything at all to deserve it though.
12:31:58 <ddarius> copumpkin: Unfortunately, it hates you back and time usually wins.
12:32:02 <copumpkin> :(
12:32:15 <TomvdZ> I've seen data Something = Something { .... } used some times. What is the extra syntax with {...} called?
12:32:17 <Philippa_> ddarius: they did kinda hand it out to anyone who signed up for the critique phase, didn't they? Not that you did nothing for Parsec 3 either
12:32:40 <Philippa_> alistra: you'll have to GTFO instead, I'm afraid
12:32:51 <ddarius> Philippa_: Yeah, though what (little) I did for Parsec 3 was unrelated to GSoC.
12:33:22 <Goosey> would this actually work: adl (x:xs) = x+(head xs)+adl xs
12:33:51 <ddarius> It's syntactically correct.  I don't know what "work" means beyond that.
12:34:03 <Goosey> xD
12:34:29 <Philippa_> assuming the Prelude's in scope, it's not going to typecheck unless you've rebound + or written a /really weird/ Num instance
12:34:31 <copumpkin> Goosey: you should not use head
12:34:34 <Philippa_> oh, wait
12:34:36 <Philippa_> not thinking
12:34:43 <Philippa_> but yeah, don't use head xs, just use x twice
12:34:45 <Goosey> copumpkin: What should I use?
12:34:50 <Philippa_> it's also not got a base case showing...
12:34:51 <copumpkin> just pattern match derper
12:35:03 <Goosey> head xs would be different from x+x
12:35:07 <Philippa_> ...yeah, I'm braindead tonight
12:35:09 <Goosey> x+headxs*
12:35:10 <Philippa_> head xs is different
12:35:17 <Goosey> It would be the second element
12:35:18 <copumpkin> Goosey: I'm not sure why you'd pattern match more deeply though
12:35:20 <Philippa_> what's it supposed to output?
12:35:25 <copumpkin> since it looks like it's just adding them all up
12:35:30 <Goosey> It's supposed to add all the elements of the list
12:35:38 <ddarius> adl = sum
12:35:39 <copumpkin> but you're double counting a bunch of things
12:35:42 <Philippa_> given [1,2,3] that'll give 1 + 2 + 2 + 3 + 3 + pattern match error
12:35:47 <Goosey> ddarius: That's besides the point :/
12:35:52 <Goosey> oh
12:36:13 <ddarius> Oh yeah, they call code reuse cheating in schools.
12:37:05 <copumpkin> depends what the goal of the assignment is :P
12:37:26 <Philippa_> Goosey: do you have a case for adl [] ?
12:37:39 <Goosey> Philippa_: Not yet, I'm not sure how to do it
12:37:40 <alistra> @src sum
12:37:40 <lambdabot> sum = foldl (+) 0
12:37:44 <alistra> well
12:37:47 <copumpkin> you'd want a case for a constant, too
12:37:49 <alistra> :D
12:38:00 <Goosey> alistra, I haven't even gotten to the chapter where they introduce foldl >_>
12:38:19 <ddarius> foldl (+) 0 is a bad implementation anyway.
12:38:26 <Philippa_> Goosey: you use a second line which says what adl [] =
12:38:31 <Nisstyre> seems odd that sum would be implemented with foldl and foldl'
12:38:35 <Nisstyre> why would that be?
12:38:39 <alistra> Goosey: it was a 'well, it won't help you now', not a 'well just rewrite this one'
12:38:52 <Goosey> xD
12:39:14 <alistra> Nisstyre: foldl and foldl'?
12:39:29 <Nisstyre> foldl' is the strict version of fold
12:39:33 <alistra> i know
12:39:43 <ddarius> Nisstyre: foldl' is not even in Haskell 98.
12:39:44 <Goosey> see my problem is x+adl xs are local to adl, but I need to somehow have them output with adl [] =
12:39:50 <alistra> but your sentence doesn't even make sense
12:39:51 <Nisstyre> ddarius: okay, so why not foldr then?
12:39:53 <ddarius> And the Report says that sum is foldl.
12:39:59 <Goosey> @src foldl
12:39:59 <lambdabot> foldl f z []     = z
12:39:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:40:46 <ddarius> Nisstyre: foldr would almost always be the wrong code too.  At least foldl can sometimes be optimized to essentially foldl'.
12:40:55 <ddarius> But really, the Report is just broken here.
12:41:07 <ddarius> This is hardly the only place where the Report is broken.
12:41:10 <alistra> ddarius: you mean it should be foldl' ?
12:41:11 <Nisstyre> okay, fair enough
12:41:19 <ddarius> alistra: Yes.
12:41:33 <Goosey> sum = foldl (+) 0 how does that work?
12:41:40 <Goosey> How does it get a list into foldl
12:41:45 <Goosey> since it's not sum x = or anything
12:41:52 <Philippa_> Goosey: I think you have some funny ideas about how control works in Haskell
12:41:54 <alistra> i just thought that intentionally all prelude isn't strict
12:41:56 <Philippa_> also, that one's partial application
12:42:06 <Philippa_> :t foldl (+) 0
12:42:06 <lambdabot> forall a. (Num a) => [a] -> a
12:42:08 <shachaf> Goosey: It's substitution, like in mathematics.
12:42:11 <Philippa_> does that explain it for you?
12:42:22 <ddarius> alistra: That's not the case, but the Report tended to lean on the non-strict side.
12:42:27 <Goosey> shachaf: But what does it substitute?
12:42:30 <shachaf> x=y*z; a=x+b+c ---> a=(y*z)+b+c
12:42:44 <shachaf> So whenever you have foo = sum [1,2,3], it becomes foo = (foldl (+) 0) [1,2,3]
12:42:46 <copumpkin> man, it sure is nice being able to define data and other typey things at my ghci prompt
12:42:46 <Philippa_> which is understandable given that Haskell's raison d'etre was to be a (or indeed the) non-strict language
12:42:51 <ddarius> alistra: But there are things that are overly strict as well as things that are explicitly, intentionally(, and correctly) strict.
12:43:15 <ddarius> copumpkin: Stop rubbing your GHC 7.5 in our faces.  Do you want us all to follow mzero?
12:43:17 <shachaf> copumpkin: What!
12:43:22 <Goosey> shachaf: Ah, okay
12:43:26 <shachaf> copumpkin: Another of the 1% privileges.
12:43:42 <copumpkin> shachaf: along with being able to use GHC 7.5, yep
12:43:46 <copumpkin> I feel so privileged
12:44:07 <ddarius> Nah, copumpkin is only in the top 15% or so I think, unless he has piles of cash cached away somewhere.
12:44:18 <alistra> @src foldl'
12:44:18 <lambdabot> foldl' f a []     = a
12:44:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:44:26 <ddarius> Well, out of US.  Out of the world that may put him in the top 1%.
12:45:00 <alistra> i thought it was defined with a bang pattern
12:45:08 <ddarius> Bang patterns are an extension.
12:45:14 <ddarius> And a fairly recent one at that.
12:45:26 <Philippa_> yeah, I'm probably still in the global 1% myself
12:45:34 <Philippa_> it's not a small number
12:45:50 <Nisstyre> @src seq
12:45:51 <lambdabot> Source not found. Take a stress pill and think things over.
12:46:01 <Nisstyre> :(
12:46:11 <Philippa_> actually scratch that. But I'd be shocked if I'm not in the top 10% and probably the top 5%
12:46:22 <ciaranm> if you count mortgages, "not being in debt" puts you in the top 10%
12:46:40 <alistra> @src deepseq
12:46:40 <lambdabot> Source not found. Are you on drugs?
12:47:02 <copumpkin> ddarius: I'm in the 0.01%
12:47:16 <Goosey> Wow
12:47:22 <copumpkin> that is right
12:47:31 <Philippa_> ciaranm: yeah, I have a student loan that I'm not going to be paying back any time soon but that's it. My only income's welfare and likely to remain that way a while, though
12:47:31 <Goosey> foldl and sum are pretty clever now that I've looked at them
12:47:43 <alistra> > if 5 == undefined then 1 else 0
12:47:44 <lambdabot>   *Exception: Prelude.undefined
12:47:59 <Philippa_> Goosey: heh, I think you're in for a long, fun ride
12:48:12 <Goosey> Philippa_: I think I am too :D
12:48:15 <Nisstyre> @src undefined
12:48:16 <lambdabot> undefined =  error "Prelude.undefined"
12:48:18 <alistra> how seq works, how to uniformly evaluate something to whnf without looking at the datatype
12:48:21 <alistra> like deepseq
12:48:31 <ddarius> seq is a primitive.
12:48:38 <ciaranm> seq is a lie.
12:48:42 <alistra> well that's a funspoiler
12:49:14 <shachaf> seq is also not a strict function (strictly speaking).
12:49:38 <ddarius> Back in the day there was an Eval class that seq was a member of (though I think it had a different name then.)  I believe it was still a primitive then, but it could conceivable be implemented since it's easy enough to seq most types.
12:50:00 <alistra> with NFData ?
12:50:07 <c_wraith> No, that's backwards
12:50:08 <Enigmagic> with case probably
12:50:13 <c_wraith> NFData is implemented with seq
12:50:21 <alistra> oh
12:50:25 <c_wraith> seq can be implemented with case, for any particular type
12:50:34 <c_wraith> well, any particular *algebraic* type
12:50:39 <c_wraith> not for functions
12:50:39 <ddarius> That's better.
12:50:45 <ddarius> Not for abstract types either.
12:51:05 <alistra> yeah i know, but i couldn't write a polymorphic seq in haskell
12:51:10 <alistra> that would work as the one now
12:51:23 <ddarius> Yes, there's a reason you can't.
12:51:55 <ddarius> You can't weaken the parametricity properties of an entire language from within the language
12:52:37 <Goosey> What's the difference between foldr/foldl
12:52:37 <alistra> i thought that deepseq uses something like a recursive function returning ()
12:52:40 <alistra> and then
12:52:52 <alistra> if rnf a == () then b else error ""
12:53:02 <shachaf> @google the difference between foldr/foldl haskell
12:53:03 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
12:53:03 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
12:53:17 <alistra> so no seq needed in deepseq
12:53:17 <Philippa_> Goosey: (+) has a property called associativity - a + (b + c) = (a + b) + c
12:53:24 <Goosey> yeah
12:53:29 <ddarius> alistra: What do you think rnf is doing?
12:53:40 <Philippa_> foldl and foldr differ in how they act with non-associative operators
12:53:53 <Philippa_> l is the left-associative version, r is right-associative
12:53:55 <alistra> instance NFData Type where
12:53:56 <alistra>     rnf (TInt) = ()
12:53:56 <alistra>     rnf (TBool) = ()
12:53:56 <alistra>     rnf (Ds) = ()
12:53:56 <alistra>     rnf (DsElem) = ()
12:53:56 <alistra>     rnf (TRec aa) = rnf aa
12:53:56 <Goosey> Okay, like division?
12:53:59 <alistra> this :P
12:54:12 <Goosey> Okay
12:54:15 <Philippa_> yeah, or putting a list back together
12:54:18 <snappy> Philippa_: as in it imposes associativity on a non-associative operation; such as Eq?
12:54:23 <ddarius> And what if a does not have type Type.
12:54:26 <copumpkin> alistra: you know
12:54:31 <snappy> er sorry ==
12:54:34 <Philippa_> snappy: as in it interprets the list as left-associative
12:54:36 <copumpkin> alistra: you could just do rnf (TRef aa) = rnf aa; rnf _ = ()
12:54:41 <ddarius> alistra: Also, most of those cases are redundant.
12:54:42 <snappy> k
12:54:42 <Philippa_> (but same difference, yeah)
12:54:44 <Goosey> So does foldl start with the left most element while foldr is the rightmost?
12:54:56 <Philippa_> left-most pair of elements
12:55:04 <alistra> ddarius: then it would typecheck, because deepseq is NFData a => a -> b -> b
12:55:05 <Philippa_> but yeah
12:55:10 <shachaf> foldr also differs significantly from foldl . reverse
12:55:16 <alistra> ddarius: it was generated by DrIFt
12:55:23 <alistra> or whatever the casing is
12:55:23 <shachaf> (Where by "." I mean "appropriate composition".)
12:55:30 <Goosey> Also, what's ghc's equivalent of @src?
12:55:32 <Philippa_> they also both assume the end of the list is "last"
12:55:44 <alistra> ddarius: wouldn't*
12:55:53 <ddarius> Goosey: There isn't one, though you could abuse the debugging features in some cases.
12:55:55 <Philippa_> (where "end of list" = [])
12:56:34 <Goosey> how does lambdabot implement it?
12:56:49 <ddarius> There's a text file that was semi-manually filled in at some point.
12:57:00 <Goosey> Oh >_<
12:57:18 <ddarius> You can go to Hoogle though, and it will provide links to the source for functions.
12:57:18 <Goosey> I thought lambdabot was a front-end for ghc and was dynamically returning them.
12:57:33 <ddarius> @src (.)
12:57:33 <lambdabot> (f . g) x = f (g x)
12:57:33 <lambdabot> NB: In lambdabot,  (.) = fmap
12:57:42 <Philippa_> lambdabot's a bunch of things
12:57:53 <alistra> ddarius: so deepseq doesn't need seq
12:57:53 <ciaranm> > let a=1e-16 in 1+a+a+a+a+a+a+a+a+a+a
12:57:54 <lambdabot>   1.0
12:57:55 <shachaf> ghc is also not the same thing as ghci.
12:58:03 <ciaranm> > let a=1e-16 in 1+(a+a+a+a+a+a+a+a+a+a)
12:58:04 <lambdabot>   1.000000000000001
12:58:08 <ciaranm> not associative!
12:58:10 <ddarius> ghci = ghc --interactive
12:58:24 <Goosey> Oh >_<
12:58:26 <donri> and you can compile lambdabot for yourself, except it will probably fail to build
12:58:37 <Goosey> I feel like a noob, but considering it's my first day. I don't feel to bad about it xD
12:58:46 <Goosey> too*
12:58:48 <ddarius> There's GHCi on Acid which is lambdabot plugged into GHCi.
12:59:02 <Philippa_> ciaranm: yeah, in general (+) isn't but we expect it to be at least "mostly associative". We all know floating point is a mess :-)
12:59:40 <ddarius> I've made plenty of Num instances where (+) wasn't remotely associative.
12:59:54 <ddarius> > (a+b+c,a+(b+c))
12:59:54 <lambdabot>   (a + b + c,a + (b + c))
12:59:56 <Goosey> @src map
12:59:56 <lambdabot> map _ []     = []
12:59:56 <lambdabot> map f (x:xs) = f x : map f xs
13:00:05 <Goosey> @src reduce
13:00:05 <lambdabot> reduce _ 0 = undefined
13:00:06 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
13:00:06 <lambdabot>     where d = gcd x y
13:00:20 <ddarius> @hoogle reduce
13:00:25 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Convolution Reduce :: ConvolutionBorderMode
13:00:25 <lambdabot> Test.QuickCheck.Property reduceRose :: Rose Result -> IO (Rose Result)
13:00:26 <lambdabot> package reducers
13:00:41 <ddarius> Why is that in lambdabot?
13:00:50 <Goosey> is quot division?
13:01:02 <ddarius> It's one form of integer division.
13:01:08 <Goosey> Okay
13:01:10 <ddarius> There's also div which differs slightly.
13:01:57 <Goosey> My friend told me to try making map using reduce
13:02:41 <ciaranm> whut
13:02:43 <ddarius> reduce is another name for "fold"
13:02:45 <alistra> Goosey: reduce in python is fold in haskell
13:03:09 <alistra> :t fold
13:03:09 <lambdabot> Not in scope: `fold'
13:03:11 <Goosey> Hm, well I thought he was referring to a function in haskell known as reduce
13:03:12 <alistra> :t foldl
13:03:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:03:38 <ddarius> There isn't a function named "reduce" in the standard libraries which is why I was surprised that lambdabot returned something.
13:03:58 <Goosey> ddarius: Yeah I noticed, my friend doesn't use python a whole lot either...
13:03:59 <Goosey> Hm
13:04:00 <ddarius> Goosey: Anyway, the most appropriate form of that exercise in Haskell would be to implement map with foldr.
13:04:10 <Goosey> ddarius, okay
13:04:32 <alistra> foldr? not foldl?
13:04:52 <ddarius> Though the "reduce" in, say, Python, would be more akin to foldl, but then it's map would be somewhat different from Haskell's map.
13:05:55 <alistra> why is python map different?
13:06:16 <shachaf> Goosey: foldr is much more "fundamental" a function than foldl.
13:06:27 <Goosey> Map doesn't seem to complicated
13:06:28 <Goosey> I'll try it
13:06:32 <Goosey> too*
13:06:53 <ddarius> Well with generators it probably isn't -that- different, but map can definitely handle infinite lists in Haskell and foldl definitely does not.
13:08:04 <shachaf> Python's map can take a generator but it always returns a list.
13:09:03 <muep> except in python 3 where it returns a map object
13:09:04 <alistra> shachaf: i was just checking that
13:09:17 <ddarius> I'm no Python expert.
13:09:20 <donri> there's itertools.imap
13:09:46 <donri> http://docs.python.org/library/itertools.html#itertools.imap
13:09:56 <Goosey> map' f (x:xs) = foldr f x (map' f xs)
13:10:50 <alistra> i think the point was not to recurse here
13:11:03 <Goosey> >_<
13:11:39 <alistra> > let map' f (x:xs) = foldr f x (map' f xs) in map (+1) [1..10]
13:11:40 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:11:55 <alistra> > let map' f (x:xs) = foldr f x (map' f xs) in map' (+1) [1..10]
13:11:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a] -> [a]
13:12:03 <alistra> typo :P
13:12:13 <monochrom> heh
13:12:16 <ddarius> For a second I was like "I can't believe that actually worked."
13:12:20 <Goosey> lol
13:12:21 <alistra> yeah
13:12:28 <ddarius> Luckily, my incredulity was well founded.
13:12:29 <Goosey> wait
13:12:30 <alistra> i can't believe it's not map
13:12:34 <Goosey> oh >_<
13:13:08 <Goosey> so alistra, what does that error mean?
13:13:38 <alistra> that the types are wrong :P
13:13:41 <alistra> :t foldr
13:13:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:14:11 <Goosey> :t map
13:14:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:14:33 <Axman6> > foldr (*) z [a,b,c,d]
13:14:33 <lambdabot>   a * (b * (c * (d * z)))
13:15:20 <Axman6> > foldr (\x xs -> f x * xs) z [a,b,c,d]
13:15:21 <lambdabot>   f a * (f b * (f c * (f d * z)))
13:15:41 <ddarius> Goosey: In your function, f needs to have type a -> b -> b and also a -> b.  Unifying these requires b = b -> b
13:15:47 <alistra> this foldr would return (f something somethingelse), my f = (+1) so it would be a function of one argument
13:15:55 <alistra> foldr's f takes 2 arguments
13:15:59 <azaq23> :t foldr (:) []
13:16:00 <lambdabot> forall a. [a] -> [a]
13:16:27 <alistra> Goosey: do you know what (:) does?
13:16:28 <ddarius> But alistra's first response was also right insofar as most of the time the exact error message isn't important.  You just look at the line number and figure out what's wrong.
13:16:31 <azaq23> :t \f -> foldr (\x xs -> f x : xs) []
13:16:32 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
13:16:35 <Goosey> alistra: No :(
13:16:41 <donri> > foldr ((:) . (+1)) [] [0..9]
13:16:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:16:59 <Axman6> > foldr (\x xs -> f x : xs) [] [a,b,c,d]
13:17:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:17:00 <lambdabot>    `GHC.Show.Show a'
13:17:00 <lambdabot>      a...
13:17:01 <alistra> ddarius: yeah the type errors aren't the most verbose and information transferring ones
13:17:06 <Axman6> > foldr (\x xs -> f x : xs) [] [a,b,c,d] :: [Expr]
13:17:07 <lambdabot>   [f a,f b,f c,f d]
13:17:27 <alistra> Goosey: (:) is a list constructor
13:17:34 <alistra> it takes a head on the left and tail on the right
13:17:43 <alistra> you know what those are in a list?
13:17:48 <alistra> > 4 : [5,6]
13:17:49 <lambdabot>   [4,5,6]
13:17:50 <monochrom> all type errors mean you can't make up your mind. "can't match Char with Bool" for example means you can't make up your mind whether you want Char or Bool. "Occurs check: a = Maybe a" means you can't make up your mind whether you want Maybe or you don't. the exact wording "Occurs check" is just a technicality.
13:17:57 <Goosey> yeah
13:18:02 <Goosey> alistra: I think I know what it does
13:18:08 <Goosey> I just didn't recognize it in (:) form
13:18:14 <Goosey> I usually use (x:xs)
13:18:15 <alistra> ok
13:18:27 <alistra> yeah, but you use it as a destructor in a pattern match
13:18:33 <Philippa_> monochrom: mostly. Normally the messes I get into that turn up as an occurs check are worse
13:18:33 <alistra> you can construct a list also :P
13:18:37 <Goosey> oh
13:18:39 <ciaranm> :t (,,,,,,,,,,,,,,,,,,,,)
13:18:40 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n,
13:18:40 <lambdabot> o, p, q, r, s, t, u)
13:18:45 <ciaranm> a present for Goosey!
13:18:52 <Goosey> wtf?
13:18:57 <Philippa_> Occurs checks mean you can't make up your mind in a way where the only otherwise-possible answer would be infinite
13:19:00 <Axman6> :t  (,,,,,,,,,,,,,,,,,,,,)
13:19:01 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n,
13:19:01 <lambdabot> o, p, q, r, s, t, u)
13:19:02 <alistra> Goosey: it's a tuple
13:19:03 <Axman6> :t  (,,,,,,,,,,,,,,,,,,,,)  (,,,,,,,,,,,,,,,,,,,,)
13:19:03 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1. b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 ->
13:19:04 <lambdabot>  q1 -> r1 -> s1 -> t1 -> u1 -> (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t,
13:19:04 <lambdabot> u), b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1)
13:19:05 <alistra> constructor
13:19:07 <Axman6> >_>
13:19:12 <alistra> > (,) 4 2
13:19:13 <lambdabot>   (4,2)
13:19:17 <Goosey> :O
13:19:18 <alistra> > (,,) 4 26
13:19:18 <lambdabot>   Overlapping instances for GHC.Show.Show (c -> (t, t1, c))
13:19:19 <lambdabot>    arising from a...
13:19:19 <alistra> > (,,) 4 2 6
13:19:20 <lambdabot>   (4,2,6)
13:19:29 <Goosey> (,,) 3 1 7
13:19:34 <Goosey> .-.
13:19:43 <alistra> leading > and a space Goosey
13:19:47 <Philippa_> occurs checks thus only happen when you did something recursively wrong
13:19:57 <Goosey> (,,) 4 2 6
13:19:57 <Philippa_> (rather, failed ones)
13:20:15 <Goosey> Oh
13:20:20 <Axman6> Goosey: > foo. the > is important
13:20:23 <slack1256> when i Sequence.update a Sequence what happens under the hood is that it returns a new Sequence right? (ie don't mutate the old one)
13:20:24 <alistra> well it's basically unification :D
13:20:33 <Goosey> I didn't even see the > because my irc chat uses that as a delimiter
13:20:35 <Axman6> > text "I only know what to do when you tell me"
13:20:36 <lambdabot>   I only know what to do when you tell me
13:20:40 <Goosey> > (,,) 1 2 3
13:20:41 <lambdabot>   (1,2,3)
13:21:01 <Goosey> It was like reading the the and not noticing the second the
13:21:13 <monochrom> yeah, use better software
13:21:50 <Axman6> slack1256: yes, data structures almost never use mutation in haskell
13:21:54 <slack1256> because in a game of life. i used a Data.Sequence to represent the board and i update by cell
13:21:55 <Goosey> 1:2:[]
13:22:03 <Goosey> > 1:2:[]
13:22:04 <lambdabot>   [1,2]
13:22:19 <Axman6> slack1256: it doesn't mean you get a completely new one, since you know most of the Seq cannot change, a lot of it can be reused
13:22:45 <Goosey> > ((,,) 1 2):((,,)3 4):[]
13:22:46 <lambdabot>   Overlapping instances for GHC.Show.Show (c -> (t, t1, c))
13:22:46 <lambdabot>    arising from a...
13:22:55 <Goosey> .-.
13:22:57 <Axman6> Goosey: too many ,'s
13:23:00 <slack1256> Axman6 should i trust GHC on how to reusate old part of my data then?
13:23:20 <Goosey> oh, thanks
13:23:22 <alistra> Goosey: you should use : when making a map with foldr
13:23:31 <Axman6> slack1256: only if you write your code to do so. but it's pretty hard to not do it properly
13:23:35 <Goosey> > ((,,) 1 2 3):((,,)4 5 6):[]
13:23:36 <lambdabot>   [(1,2,3),(4,5,6)]
13:23:38 <Goosey> :O
13:23:41 <alistra> foldr basically is like traversing a list with an accumulator
13:23:58 <alistra> and the accumulator in your case would also be a list
13:24:04 <slack1256> Axman6: uff thanks, i though i was doing a lot of extra work
13:24:05 <Axman6> alistra: that sounds more like foldl
13:24:25 <alistra> Axman6: i can go both ways
13:24:28 <Goosey> hm, let me try that
13:25:00 <Goosey> > (((,,) 1 2 3):((,,) 4 5 6):[]):(((,,) 7 8 9):((,,) 10 11 12):[])
13:25:01 <lambdabot>   Couldn't match expected type `[(t, t1, t2)]'
13:25:01 <lambdabot>         against inferred type ...
13:25:43 <Axman6> slack1256: nope. you'll see how it works if you implement something like a binary search tree. you'll see that you only need to replace up to log n nodes each time you insert an element, because at each node, you either change the left or the right, so everything to the right or left will remain the same
13:26:00 <CsDezolator> does anybody here have any experience with gstreamer ?
13:27:11 <Goosey> Why doesn't this work (,) (((,,) 1 2 3):((,,) 4 5 6):[]):(((,,) 7 8 9):((,,) 10 11 12):[]) (((,,) 13 14 15):((,,) 16 17 18):[]):(((,,) 19 20 21):((,,) 22 23 24):[])
13:27:42 <monochrom> is it a syntax error?
13:27:42 <alistra> because it's too long and complicated and you've made a typo somewhere
13:27:45 <Axman6> because ... i can't read it
13:27:50 <Goosey> > (,) (((,,) 1 2 3):((,,) 4 5 6):[]):(((,,) 7 8 9):((,,) 10 11 12):[]) (((,,) 13 14 15):((,,) 16 17 18):[]):(((,,) 19 20 21):((,,) 22 23 24):[])
13:27:50 <alistra> > (1,2,3)
13:27:51 <lambdabot>   Couldn't match expected type `t3 -> b -> ([(t, t1, t2)], b)'
13:27:51 <lambdabot>         agains...
13:27:51 <lambdabot>   can't find file: L.hs
13:28:01 <Goosey> hm
13:28:01 <alistra> > (1,2,3)
13:28:02 <lambdabot>   (1,2,3)
13:28:11 <alistra> you can write it like that also lol
13:28:11 <monochrom> why do you even write it that way?
13:28:18 <Goosey> :P
13:28:27 <monochrom> I mean, don't bother telling me why. forget it.
13:28:28 <Goosey> monochrom: Why not :D I'm experimenting
13:28:28 <kmc> why doesn't this work? no.puah8a3ho38ruhra,h8rh,oq9rmui8oyp6qrguh3kqqmr8nfqoryp8oamur3k8q3jfhriu8e569,7834uh9mqkrc738yiufqj938roh3.8kqkh9rop83uh93mor8kq
13:28:44 <jmcarthur> because this
13:28:47 <jmcarthur> > no.puah8a3ho38ruhra,h8rh,oq9rmui8oyp6qrguh3kqqmr8nfqoryp8oamur3k8q3jfhriu8e569,7834uh9mqkrc738yiufqj938roh3.8kqkh9rop83uh93mor8kq
13:28:48 <lambdabot>   <no location info>: parse error on input `,'
13:28:53 <alistra> @pl no.puah8a3ho38ruhra,h8rh,oq9rmui8oyp6qrguh3kqqmr8nfqoryp8oamur3k8q3jfhriu8e569,7834uh9mqkrc738yiufqj938roh3.8kqkh9rop83uh93mor8kq
13:28:53 <lambdabot> (line 1, column 20):
13:28:53 <lambdabot> unexpected ","
13:28:53 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator or end of input
13:29:10 <alistra> @pl no.puah8a3ho38ruhra, h8rh, oq9rmui8oyp6qrguh3kqqmr8nfqoryp8oamur3k8q3jfhriu8e569, h9mqkrc738yiufqj938roh3.8kqkh9rop83uh93mor8kq
13:29:10 <lambdabot> (line 1, column 20):
13:29:10 <lambdabot> unexpected ","
13:29:11 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator or end of input
13:29:24 <alistra> @pl (no.puah8a3ho38ruhra, h8rh, oq9rmui8oyp6qrguh3kqqmr8nfqoryp8oamur3k8q3jfhriu8e569, h9mqkrc738yiufqj938roh3.8kqkh9rop83uh93mor8kq)
13:29:24 <lambdabot> (no . puah8a3ho38ruhra, h8rh, oq9rmui8oyp6qrguh3kqqmr8nfqoryp8oamur3k8q3jfhriu8e569, h9mqkrc738yiufqj938roh3 . 8 kqkh9rop83uh93mor8kq)
13:29:25 <rwbarton> Goosey: You know, you can write (:) in prefix form also!
13:29:26 <Axman6> ,'s don't make sense there
13:29:37 <monochrom> sure, good luck experimenting. but it is not worth other people's time to look for non-obvious typos
13:29:40 <simon> alistra, what are you doing?
13:29:46 <kmc> @yhjulwwiefzojcbxybbruweejw
13:29:46 <lambdabot> "\""
13:29:55 <simon> or rather, what are you all doing?? :)
13:30:08 <kmc> @yhjulwwiefzojcbxybbruweejw
13:30:08 <lambdabot> "\"#$%&'()*+,\""
13:30:14 <jessopher> lol
13:30:16 <kmc> @nixon
13:30:17 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
13:30:17 <alistra> experimenting with our sexualities
13:30:21 <Goosey> AHAH!
13:30:23 <Goosey> > (,) ((((,,) 1 2 3):((,,) 4 5 6):[]):(((,,) 7 8 9):((,,) 10 11 12):[]):[]) ((((,,) 13 14 15):((,,) 16 17 18):[]):(((,,) 19 20 21):((,,) 22 23 24):[]):[])
13:30:24 <lambdabot>   ([[(1,2,3),(4,5,6)],[(7,8,9),(10,11,12)]],[[(13,14,15),(16,17,18)],[(19,20,...
13:30:26 <Goosey> :D
13:30:39 <kmc> now use prefix (:) too
13:30:47 <simon> kmc, why does "@yhjulwwiefzojcbxybbruweejw" interpret as a command?
13:30:52 <Goosey> > (:) 1 2
13:30:53 <lambdabot>   No instance for (GHC.Num.Num [t])
13:30:53 <lambdabot>    arising from a use of `e_112' at <inte...
13:30:59 <Axman6> no!
13:31:03 <Axman6> :t (:)
13:31:04 <lambdabot> forall a. a -> [a] -> [a]
13:31:07 <donri> Goosey: second argument is a list
13:31:08 <kmc> this is actually a nice exercise Goosey, because it shows how uniform these data types are, special syntax aside
13:31:13 <kmc> simon, http://code.haskell.org/lambdabot/COMMANDS
13:31:28 <donri> > (,2) 1
13:31:29 <lambdabot>   Illegal tuple section: use -XTupleSections
13:31:32 <Goosey> > (:) [] 1 2
13:31:33 <lambdabot>   Couldn't match expected type `t1 -> t'
13:31:33 <lambdabot>         against inferred type `[[a]]'
13:31:36 <Goosey> > (:) [] 1
13:31:36 <lambdabot>   No instance for (GHC.Num.Num [[a]])
13:31:37 <lambdabot>    arising from a use of `e_11' at <int...
13:31:46 <monochrom> your exercise is not complete until you change 10 to fromInteger 10 and similarly all the literal numbers
13:31:46 <donri> Goosey: second, not first
13:31:46 <Goosey> I don't know how prefix (:) works
13:31:49 <Axman6> look at the order of the arguments Goosey
13:31:54 <Axman6> :t (:)
13:31:55 <kmc> > (:) 2 [3,4]
13:31:55 <lambdabot> forall a. a -> [a] -> [a]
13:31:55 <lambdabot>   [2,3,4]
13:31:56 <donri> Goosey: same as infix ;)
13:32:00 <Goosey> OH
13:32:02 <Axman6> it takes an a, and a list of a's
13:32:02 <Goosey> >_<
13:32:05 <kmc> like any other infix operator, you put it in parens
13:32:13 <kmc> > case "abc" of ((:) x xs) -> (x, xs)
13:32:13 <lambdabot>   ('a',"bc")
13:32:16 <Goosey> > (:) 1 []
13:32:17 <lambdabot>   [1]
13:32:39 <jessopher> didnt know that worked in patterns
13:32:51 <Goosey> monochrom: I don't quite understand what you meant?
13:33:09 <donri> > 'G':'o':'o':'s':'e':'y':[]
13:33:09 <lambdabot>   "Goosey"
13:33:27 <kmc> every value in Haskell is a function, an algebraic constructor with 0 or more fields, or something opaque and abstract
13:33:43 <Goosey> > read 1
13:33:43 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
13:33:44 <lambdabot>    arising from the literal `...
13:33:46 <kmc> i think this is correct to say
13:33:48 <Goosey> > read 1 + 1
13:33:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
13:33:49 <lambdabot>    arising from the literal `...
13:33:59 <Goosey> > (read 1) + 1
13:34:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
13:34:00 <lambdabot>    arising from the literal `...
13:34:02 <Goosey> >_<
13:34:03 <kmc> there are other things in GHC but not in standard Haskell
13:34:09 <alistra> :t read
13:34:10 <lambdabot> forall a. (Read a) => String -> a
13:34:21 <Goosey> > (read "1") + 1
13:34:22 <lambdabot>   2
13:34:39 <alistra> i don't get it why ghc has so unreadable type errors
13:34:49 <alistra> maybe i'll write a patch :3
13:34:51 <Goosey> Which one is that converts to a string?
13:34:57 <Axman6> show
13:34:59 <jessopher> i can read them
13:34:59 <kmc> :t show
13:35:00 <lambdabot> forall a. (Show a) => a -> String
13:35:05 <Goosey> show 1
13:35:07 <Goosey> > show 1
13:35:08 <Axman6> @hoogle a -> String
13:35:08 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
13:35:08 <lambdabot> Prelude show :: Show a => a -> String
13:35:08 <lambdabot> Text.Show show :: Show a => a -> String
13:35:08 <lambdabot>   "1"
13:35:08 <jessopher> (usually)
13:35:12 <alistra> jessopher: it doesn't mean that they are not unreadable
13:35:14 <kmc> it's nice that strings, lists, records, tuples, enums are treated uniformly, special syntax aside
13:35:14 <copumpkin> alistra: I have no trouble reading its type errors, either
13:35:18 <Goosey> :t string
13:35:19 <lambdabot> Not in scope: `string'
13:35:22 <Goosey> :t String
13:35:23 <lambdabot> Not in scope: data constructor `String'
13:35:24 <copumpkin> alistra: the fact that you can't read them doesn't mean they're unreadable, either
13:35:31 <donri> :i String
13:35:36 <kmc> Goosey, you can also interact with lambdabot by private message
13:35:36 <alistra> copumpkin: i can read them
13:35:42 <alistra> but they can be done better
13:35:43 <Goosey> kmc: sorry >_<
13:35:43 <alistra> lol
13:35:49 <monochrom> Goosey: http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
13:35:53 <copumpkin> alistra: then submit a ticket
13:36:01 <kmc> they can be done much better
13:36:05 <kmc> they're not "unreadable" though
13:36:08 <alistra> i'll write a patch with it
13:36:21 <copumpkin> alistra: it's probably worth discussing with people before writing code
13:36:24 <kmc> i'm sick of the hyperbole where every piece of software is either puppies and rainbows or utter unusable awful broken shit
13:36:38 <alistra> copumpkin: i don't care, i'll use my own patchset if people won't like it
13:36:51 <copumpkin> alistra: just trying to save you wasted work, but it's up to you
13:36:51 <kmc> great! forks and wasted effort!
13:37:02 <alistra> wasted?
13:37:07 <kmc> people can't get along so let's write 10 bad programs instead of one good one
13:37:11 <alistra> i will have an awesome error log
13:37:32 <copumpkin> alistra: you could improve the situation for everyone if you took a few more minutes to get ideas from the developers, or you can improve it for yourself
13:38:01 <jessopher> Dear programmer, did you know that your definition of function x, is not in accord with the infered type of function y? Have a pleasant day.
13:38:11 <jessopher> :P
13:39:08 <monochrom> you can get a great following by posting on reddit complaining about GHC error messages
13:39:27 <alistra> monochrom: i have a silent ban on reddit for trolling
13:39:30 <alistra> or whatever
13:39:34 <Goosey> Does : always act as a list constructor?
13:39:52 <monochrom> oh well then, I guess you have already been there done that!
13:39:57 <roconnor> (:) is a list constructor
13:40:00 <kmc> Goosey, yes
13:40:10 <Goosey> @src map
13:40:10 <lambdabot> map _ []     = []
13:40:10 <lambdabot> map f (x:xs) = f x : map f xs
13:40:11 <kmc> as a pattern it matches a list constructor
13:40:19 <Goosey> in map, is it acting as a list constructor there?
13:40:24 <kmc> yes
13:40:31 <Goosey> I see...
13:40:38 <kmc> in the second equation, in the left-hand side, it's matching a list constructor
13:40:40 <copumpkin> alistra: it doesn't surprise me :)
13:40:43 <kmc> on the right hand side it's constructing a list
13:40:46 <Goosey> well that explains so much
13:40:56 <kmc> > let f (x:xs) = x in f (2:[3,4])
13:40:56 <lambdabot>   2
13:41:07 <Goosey> I feel enlightened
13:41:14 * hackagebot shake 0.1.1 - Build system creator  http://hackage.haskell.org/package/shake-0.1.1 (NeilMitchell)
13:41:20 <kmc> what were you thinking before?
13:41:48 <Goosey> kmc,  I sorta just ignored the : because I didn't realize it was a list constructor
13:42:14 <kmc> heh
13:42:18 <ddarius> Is ndm going to start challenging edwardk for rate of updates?
13:42:31 <Philippa> heh, I could see that duel going on a while
13:42:58 <kmc> Goosey, it's special syntax but it's really no different from other data types; we could instead do
13:43:00 * ddarius feels like going to sleep, but hasn't produced any BS at all today.
13:43:06 <kmc> data List a = Nil | Cons a (List a)
13:43:09 <kmc> map _ Nil = Nil
13:43:19 <kmc> map f (Cons x xs) = Cons (f x) (map f xs)
13:43:22 <Goosey> @src |
13:43:23 <lambdabot> Source not found. Are you on drugs?
13:43:28 <Goosey> I don't know what | is...
13:43:33 <kmc> | is part of the syntax of data declarations
13:43:43 <kmc> maybe you should just come back to what i said once you've learned about those
13:43:48 <Goosey> Okay
13:43:57 <ddarius> Actually, (:) is only the slightest bit special.
13:44:16 <kmc> it's saying that a value of type (List a) is either Nil, or it's (Cons x xs) where x has type a, and xs has type (List a)
13:44:21 <kmc> so the literal reading of "|" would be "or"
13:44:30 <kmc> but it doesn't make sense out of context
13:44:37 <ddarius> The Report says that it's special, but if the Report didn't it would actually be allowable and mean the same thing by other rules.
13:44:52 <kmc> [] is special though
13:44:56 <ddarius> Yeah.
13:45:13 <jessopher> : is special as far as pattern matching is concerned though
13:45:19 <ddarius> jessopher: No it isn't.
13:45:23 <jessopher> no?
13:45:38 <rwbarton> only in the sense that it is the desugaring of [a,b,c] patterns
13:45:51 <ddarius> (:) is special only because the Report says it is arbitrarily.
13:46:11 <ddarius> [a,b,c] syntax is special in a more significant manner.
13:46:30 <kmc> jessopher, you can declare your own infix data constructors
13:46:33 <kmc> and pattern-match them infix
13:46:58 <jessopher> but not with an arbitrary form, only the form :stuff:
13:46:59 <ddarius> If the Report didn't say otherwise, data Foo = Int : Int would be a legal declaration.
13:47:00 <kmc> they have to start with :
13:47:05 <kmc> but : starts with :
13:47:10 <jessopher> ah
13:47:13 <kmc> you don't also need a colon at the end
13:47:19 <jessopher> ok, i see
13:47:20 <kmc> though : also ends with :
13:47:27 <jessopher> thats true too
13:47:41 <ddarius> @src Complex
13:47:42 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
13:47:49 <monochrom> people write :+: for aesthetics
13:48:10 * jessopher nods
13:49:02 <alistra> http://dpaste.com/675217/ probably would look something like this, needs working on details
13:49:18 <kmc> alistra, edwardk is working on something like that
13:49:36 <Goosey> Okay
13:49:40 <alistra> kmc: do you have a contact to him :P?
13:49:46 <Goosey> Will someone confirm my idea
13:49:49 <kmc> he's often here
13:49:49 <Goosey> @src foldr
13:49:49 <lambdabot> foldr f z []     = z
13:49:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:49:54 <kmc> preflex, seen edwardk
13:49:54 <preflex>  edwardk was last seen on #haskell 2 days, 21 hours, 18 minutes and 1 second ago, saying: enough people in here have used parsec over the years =)
13:50:23 <alistra> more clang style errors
13:50:56 <Goosey> nevermind >_<
13:50:58 <Goosey> I confused myself.
13:51:14 * hackagebot shake 0.1.2 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.1.2 (NeilMitchell)
13:51:14 <ddarius> I confirm that you've confused yourself.
13:51:14 <copumpkin> alistra: that's a decent amount of work to add
13:51:20 <Goosey> ddarius: Thanks
13:51:28 <kmc> alistra, one of the major features of edwardk's parsing library 'trifecta' is to produce clang-style errors from parsed input
13:51:48 <kmc> Goosey, hey, do you know what function (foldr (:) []) is?
13:52:25 <Goosey> It looks like it's a function for appending onto an empty list
13:52:35 <kmc> yeah
13:52:51 <ddarius> That's actually correct.
13:53:04 <Goosey> :O
13:53:07 <kmc> it takes an input list, and prepends its elements onto the empty list
13:53:11 <ddarius> An odd way of saying what that does though.
13:53:15 <kmc> > foldr (:) [] "abcde"
13:53:16 <lambdabot>   "abcde"
13:53:24 <Goosey> hm
13:53:44 <Axman6> woah, that looks like an identity! D:
13:53:48 <kmc> Goosey, one way to look at foldr is that it just takes a list and replaces each (:) with f, and each [] with z
13:53:54 <Goosey> > foldr (:) [] [1,2,3]
13:53:55 <lambdabot>   [1,2,3]
13:54:24 <alistra> @foldr (:) [] [1,2,3]
13:54:24 <Goosey> > I see
13:54:25 <lambdabot> No match for "(:)".
13:54:25 <lambdabot> No match for "[]".
13:54:25 <lambdabot> No match for "[1,2,3]".
13:54:25 <lambdabot>   Not in scope: data constructor `I'Not in scope: `see'
13:54:25 <ddarius> Goosey: Your response is like saying that sum adds a bunch of numbers to 0, which is indeed exactly what it does.
13:54:34 <kmc> foldr (+) 0 (1 : 2 : 3 : [])   ≡  (1 + 2 + 3 + 0)
13:54:45 <Goosey> yeah
13:54:48 <Goosey> let me try map again
13:56:26 <Goosey> am I getting closer with this
13:56:34 <ddarius> Is anyone aware of a SQL query using nested selects that is impossible to recast as a query using only joins?
13:56:35 <Goosey> map' _ [] = []
13:56:35 <Goosey> map' f (x:xs) = foldr (f x) : xs
13:56:45 <ddarius> Goosey: No.
13:56:47 <kmc> no
13:57:05 <kmc> Goosey, you should do it without pattern-matching the input list at all
13:57:38 <benmachine> you should also try to give foldr the right number of arguments :P
13:57:43 <Axman6> foldr takes care of all that pattern matching for you
13:57:44 <Goosey> xD
13:57:50 <Goosey> okay let me try again
13:58:08 <Axman6> Goosey: you need to write something that looks like: foldr (\x xs -> ...) []
13:58:20 <Goosey> That's beyond me
13:58:25 <Goosey> I don't know what \x is
13:58:28 <Goosey> or ->
13:58:33 <kmc> anonymous function, i.e. lambda abstraction
13:58:36 <Axman6> maybe foldr (\a bs -> ...) []
13:58:42 <kmc> you should read more before you attempt this exercise
13:58:45 <Goosey> okay
13:58:47 <Axman6> > (\a b -> a + b) 4 6
13:58:48 <lambdabot>   10
13:59:06 <Axman6> > let f a b = a + b in f 4 6
13:59:06 <lambdabot>   10
13:59:22 <Goosey> I'll just read more then
14:01:25 <kmc> cool :)
14:02:45 <Goosey> Currently I haven't learned any form of recursion beyond checking with pattern matching
14:03:05 <ciaranm> that doesn't make sense
14:03:27 <Goosey> Well, like, the only way I know to end recursion is with pattern matching
14:03:41 <ciaranm> that also doesn't make sense
14:03:41 <Goosey> I'm just starting Ch.3 of LYAH
14:03:50 <Goosey> Ch.4*
14:04:27 <monochrom> eventually you will learn to decouple recursion from pattern matching. I mean in your mind. but that will take time and I will wait.
14:05:03 <Axman6> monochrom is vert patient
14:05:52 <Axman6> very too*
14:06:11 <kmc> Goosey, map implemented using foldr is not a recursive definition
14:06:19 <Goosey> kmc, okay.
14:06:25 <kmc> foldr already contains the ability to recurse over a list
14:06:32 <kmc> in fact foldr is the essence of recursion over lists
14:06:51 <Axman6> it will look like: map' f as = foldr (\a bs -> ...) [] as
14:07:20 <Goosey> I was reading this: http://www.haskell.org/haskellwiki/Anonymous_function
14:07:21 <kmc> or like this:   map' f = foldr g []  where  g x xs = ...
14:08:10 <kmc> Goosey, are you reading some Haskell tutorial too?
14:08:17 <Goosey> LYAH
14:09:42 <ddarius> kmc: What craziness is this?  You can learn everything from Wikipedia alone.
14:09:53 <kmc> books are, like, so last year
14:10:25 <kmc> i wish the quality on the Haskell wiki were as consistent as the quality on Wikipedia
14:10:31 <kmc> which is not that consistent
14:10:50 <Goosey> I did something really weird
14:11:03 <monochrom> I think wikipedia people are more willing to delete things than haskell wiki people
14:11:30 <Goosey> > map' f x = foldr (\x -> x f) x:[]
14:11:30 <lambdabot>   <no location info>: parse error on input `='
14:11:37 <Axman6> there's no sense of organisation on the haskell wiki
14:11:44 <kmc> Goosey, why (\x -> x f)
14:11:44 <Axman6> :t foldr
14:11:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:12:03 <Goosey> kmc, I thought it would take x and then perform f on it :/
14:12:11 <Goosey> I'm not really sure >_<
14:12:17 <kmc> it seems like you are just guessing
14:12:26 <Goosey> I'm just going to read LYAH and come back when I get to that point
14:12:59 <ddarius> I miss the old hawiki.
14:13:13 <monochrom> "perform f on x" is written f x, not x f. however, "perform f on x" is insufficient.
14:15:45 <Goosey> I think I have an idea
14:16:36 <ciaranm> i wouldn't do that if i were you
14:17:06 <Goosey> map' f x = foldr ((\f x y -> f x : y) f) x []
14:17:16 <Goosey> This is my idea:
14:17:37 <monochrom> too many parameters. 3.
14:17:38 <Goosey> no...nevermind >_<
14:17:38 <kmc> ((\f x y -> f x : y) f)  should be written as  (\x y -> f x : y)
14:17:45 <kmc> you're getting closer, though
14:17:55 <Goosey> kmc, funny I had that first >_<
14:18:01 <kmc> why did you give it up
14:18:07 <Goosey> See
14:18:11 <Goosey> The problem I'm seeing is
14:18:19 <Goosey> lambda's take their input from whatever comes after them
14:18:23 <ddarius> Goosey: You don't have to present your ideas for judgement.  You can have the compiler judge you first.
14:18:28 <Goosey> if that's true, how does it figure out what f is >_>
14:18:32 <kmc> f is already in scope
14:18:47 <kmc> they don't "take their input from whatever comes after them"
14:18:50 <kmc> not syntactically
14:18:57 <kmc> a lambda expression evaluates to a function
14:18:59 <kmc> that function is a value
14:19:13 <Goosey> well
14:19:14 <kmc> it can be passed to functions, returned from functions, stored in data structures, etc.
14:19:23 <Goosey> ghci doesn't break so far
14:19:24 <kmc> eventually, that function-value is called with some arguments
14:19:28 <Goosey> let me try harder >:D
14:20:14 <kmc> Goosey, you can define a function which "remembers" some stuff that was in scope (here, f) and uses it later when called
14:20:22 <kmc> that's the basis of functional programming
14:20:32 <kmc> we say that the lambda expression "closes over" f
14:20:39 <kmc> and such values are sometimes called "closures"
14:20:54 <kmc> (although that can also refer to an implementation technique only)
14:22:12 <Goosey> kmc, what does that mean exactly?
14:22:16 <Goosey> closing over f
14:22:31 <kmc> it means it "remembers" some stuff that was in scope (here, f) and uses it later when called
14:22:40 <Goosey> Oh >_<
14:24:54 <monochrom> it means: Q: "what does f refer to?" A: "use lexical scoping to find out"
14:25:27 <kmc> Goosey, many languages support functions like this
14:25:38 <kmc> perl, python, ruby, C#, scheme, javascript, ...
14:25:57 <kmc> maybe you have a more familiar setting where you can study this idea
14:26:29 <Goosey> C, Prolog
14:26:36 <kmc> C does not, no
14:26:46 <ddarius> Neither does Prolog.
14:26:55 <Goosey> Well that could be the reason xD
14:27:04 <Goosey> I've only really majorly used those two languages
14:27:13 <Goosey> I've only dabbled in Lisp and Python
14:27:18 <kmc> you could read SICP and learn some Scheme and learn those ideas in this context
14:28:24 <kmc> > let f x = (\y -> x + y)  in  (f 2) 3
14:28:25 <lambdabot>   5
14:28:39 <kmc> (f 2) evaluates to (\y -> 2 + y)
14:28:46 <kmc> i.e. it's a function which has remembered 2
14:29:04 <Goosey> @src foldr
14:29:05 <lambdabot> foldr f z []     = z
14:29:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:29:08 <Goosey> Does z never change?
14:29:17 <kmc> nothing ever changes
14:29:23 <Goosey> well
14:29:28 <Goosey> I mean, in any new instance of z
14:29:28 <kmc> but, if you're asking "is the same z passed to each recursive foldr call", the answer is yes
14:29:32 <Goosey> is it equal to all the old z's
14:29:40 <kmc> in fact you can define foldr in another way as
14:29:42 <Goosey> That's what I mean yes
14:30:02 <kmc> foldr f z = go  where { go [] = z;  go (x:xs) = f x (go xs) }
14:30:05 <jmcarthur> closures are something that many people already use and understand without having attached the name to them
14:30:13 <Goosey> What is the purpose of z?
14:30:17 <ddarius> Good old fashioned old papers where figures were added separately from text.
14:30:22 <kmc> the purpose of z is that foldr f z [] = z
14:30:23 <ion> foldr f z [] = z
14:30:36 <kmc> sum = foldr (+) 0
14:30:39 <kmc> what's the purpose of 0 there?
14:30:43 <Goosey> Ah
14:30:52 <kmc> it's the sum of an empty list, and the base to which other elements are added
14:31:05 <kmc> the formulation of foldr with "go" makes it clear that the same f and z are used throughout
14:31:19 <ddarius> jmcarthur: Well it's a perfectly natural concept.
14:31:39 <kmc> it's also another example of closure:  (foldr f z) evaluates to a function (here defined as 'go') which remembers f and z
14:31:43 <ddarius> And by "perfectly natural" I mean that other possibilities are less natural.
14:33:43 <kmc> ddarius, i don't know, the original lisps didn't have lexical scoping
14:33:54 <kmc> and new languages today still manage to get it wrong
14:34:25 <ddarius> kmc: It's natural to use.  The original Lisp didn't have it because the dynamic scoping was seen as an optimization.
14:34:30 <kmc> oh yeah?
14:34:54 <ddarius> They didn't really realize the consequences of that optimization, just that doing it one way in the interpreter was simpler than doing it the right way.
14:35:25 <ddarius> I suspect this covers many other cases of programming languages.  They usually "fix" this down the line.
14:37:03 <ddarius> kmc: Consider writing an interpreter on a 1960s machine.  You can either cons an environment onto your lambda object at the time of creation, or you can just use the scope list at the time of use.  The latter seems much more efficient.
14:37:33 <kmc> yeah
14:39:11 <Goosey> Oh god
14:39:12 <Goosey> I think
14:39:13 <Goosey> I got it
14:39:25 <kmc> oh god
14:39:26 <kmc> you use
14:39:27 <kmc> too many
14:39:28 <kmc> newlines
14:39:36 <Goosey> Sorry >_< I tend to speak in breaks like that
14:39:38 <Goosey> Okay
14:39:51 <benmachine>  newlines are useful sometimes for emphasis I think
14:39:52 <ddarius> Goosey is really William Shatner!
14:40:05 <Goosey> LOL, I did it again...Anyways I'm so close, my map does the application...but it reverses the list
14:40:14 <kmc> heh, cool
14:40:17 <azaq23> khaaan?
14:40:18 <Goosey> *Main> map' (+1) [1,2]
14:40:18 <Goosey> [3,2]
14:40:21 <kmc> are you sure you're using foldr and not foldl?
14:40:29 <Goosey> I'm using foldr
14:40:39 <kmc> did you try it on some other things?
14:40:45 <kmc> you could use quickcheck
14:40:49 <Goosey> map' f (x:xs) = foldr (\x xs -> f x:xs) xs xs
14:41:13 <kmc> <kmc> Goosey, you should do it without pattern-matching the input list at all
14:41:15 <ddarius> Yeah, that's not reversing anything.
14:41:22 <Goosey> I'm pattern matching?
14:41:26 <kmc> (x:xs)
14:41:30 <kmc> on the left-hand side
14:41:32 <kmc> that's a pattern
14:41:33 <kmc> >
14:41:34 <Goosey> Oh >_<
14:41:35 <kmc> whoops
14:41:43 <ddarius> Writing reverse using just foldr is a bit involved (well, unless you do it the inefficient way, but even then, using -only- foldr is still a bit involved.)
14:41:55 <Makoryu> Say, is there a GHC extension that allows you to write "foo do { ... }" instead of "foo $ do { ... }" or "foo (do { ... })"?
14:42:05 <ddarius> Makoryu: No.
14:42:06 <kmc> no Makoryu
14:42:08 <kmc> > let map' f xs = foldr (\x xs -> f x:xs) [] xs in map' (+1) [1,2]
14:42:09 <lambdabot>   [2,3]
14:42:26 <Makoryu> Why on earth not
14:42:45 <cgroza> Makoryu: because it is redundant.
14:42:46 <kmc> uh, because nobody's implemented it?
14:42:56 <Goosey> Also, you're right, It was only adding on to the first element
14:42:59 <kmc> have you worked out in detail what the consequences would be?
14:43:07 <Goosey> It appeared as if it was reversed >_<
14:44:11 <ddarius> kmc: The consequences would be that I save two characters of typing.  That's surely worth hacking the internals of GHC, adding another case through the code, violating the standard, and adding more special cases.
14:44:26 <monochrom> supporting "foo do {...}" may require completely overhauling Haskell grammar.
14:44:32 <dmwit> Makoryu: Because you haven't written it yet.
14:44:32 <azaq23> wouldn't such an extension make the grammar context sensitive? If there's a function before the "do", do this, else ...
14:44:39 <dmwit> monochrom: Really? Why?
14:44:59 <monochrom> a guess based on experience
14:45:19 <dmwit> Doesn't seem any worse than record syntax, which already allows foo bar { ... } with no trouble.
14:45:34 <Goosey> Thanks guys, I'm going to go back to the tutorial for now.
14:45:37 <ddarius> dmwit: Record syntax requires {}.
14:45:46 <dmwit> True.
14:45:51 <kmc> it's gratuitous sugar but so are -XTupleSections -XNamedFieldPuns -XUnicodeSyntax -XPostfixOperators
14:45:56 <rwbarton> the only thing that can follow do is a block, right?
14:46:10 <kmc> i mean, GHC has extensions named AlternativeLayoutRule *and* AlternativeLayoutRuleTransitional...
14:46:11 <ddarius> But, I do think this is something that can be done with a relatively small change to the grammar, but I haven't thought it through myself.
14:46:35 <dmwit> ddarius: But do-blocks require "do". So it's not that different.
14:46:37 <monochrom> w00t! is there also AlternativeLayoutFrameset? :)
14:46:41 <ddarius> kmc: All of those either allow something that simply wasn't doable before, or save more than two characters, and in many cases remove special-cases.
14:48:13 <ddarius> Well UnicodeSyntax might not.
14:48:21 <lmatos> hi all, I'm new to haskell and following learnyouahaskell and then I plan on reading real-world haskell next. I'm up to list comps and I want to make sure I grok the syntax. The pipe just acts as a delimiter between the "function" and the "set" correct? Sorry if I'm not using proper terms. Still learning. :)
14:48:46 <ddarius> lmatos: You are correct that it is just a delimiter.  It has no meaning on its own.
14:48:56 <monochrom> yes
14:49:03 <lmatos> ddarius: thanks.
14:52:04 <Makoryu> ddarius: There are a handful of keywords that begin expressions that can appear on the right side of "=" and operators and the like, eg. do, case, if
14:52:21 <Makoryu> I guess let also counts
14:52:47 <kmc> heh, GHC 7.5 lets you disable record syntax
14:52:50 <Makoryu> I didn't mean to suggest a special case specifically for do
14:53:02 <kmc> it adds -XTraditionalRecordSyntax, which is on by default, and allows -XNoTraditionalRecordSyntax
14:53:10 <lmatos> If someone could step through this I'd really appreciate it. length' xs = sum [1 | _ <- xs]  Is it essentially for each value in xs convert it to 1 and sum up the 1's? I "get" the code but I'm not sure how it "works" if that makes sense.
14:53:19 <kmc> it doesn't
14:53:33 <kmc> what's the difference between "get" and "know how it works"
14:54:16 <kmc> it's not really "convert it to 1"
14:54:23 <kmc> it's more like "for each element of xs, here's a 1"
14:54:24 <Axman6> lmatos: it's more like, for each x in xs, produce a 1, and then sum all the ones
14:54:32 <ddarius> kmc: What's "non-traditional" record syntax then?
14:54:46 <kmc> [1 | x <- xs]  =  "for each element x in xs, here's a 1"
14:54:50 <kmc> same thing, because x is unused
14:55:02 <ddarius> select sum(1) from xs
14:55:04 <kmc> ddarius, none as of yet
14:55:35 * ddarius has written SQL queries somewhat like that upon occassion.
14:56:53 <kmc> :t sum . (1 <$)
14:56:54 <lambdabot> forall a b. (Num a) => [b] -> a
14:57:02 <Axman6> lmatos: do you understand what _ does by the way?
14:57:21 <hpc> > [1 | [1..15]]
14:57:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:57:22 <lambdabot>         against inferred type ...
14:58:01 <Goosey> I feel like I've learned a lot for the first day.
14:58:33 <hpc> kmc: what's non-traditional record syntax?
14:58:40 <kmc> there is none yet
14:58:45 <hpc> oh lol
14:59:45 <alistra> > {}
14:59:46 <lambdabot>   <no location info>: parse error on input `{'
14:59:59 <hpc> > undefined {}
15:00:00 <lambdabot>   <no location info>: Empty record update
15:00:15 <alistra> Just 5 {}
15:00:23 <alistra> > Just 5 {}
15:00:24 <lambdabot>   <no location info>: Empty record update
15:00:25 <kmc> > let {} in ()
15:00:26 <lambdabot>   ()
15:00:38 <alistra> it should magically know when i want to evaluate it and do it
15:00:40 <hpc> i feel like someone should patch mueval so it has location info on expressions
15:00:42 <Goosey> @src in
15:00:42 <lambdabot> Source not found. :(
15:00:53 <kmc> Goosey, it is part of the "let" syntax
15:00:56 <kmc> let ... in ...
15:00:59 <Goosey> Oh
15:01:12 <kmc> let  (names to define locally)  in  (expression where they are used)
15:01:17 <hpc> the first part is definitions and stuff, the second part is the scope to use them in
15:01:31 <hpc> or what kmc said, which explains it better
15:01:39 <Goosey> let x = 1 in x+1
15:01:43 <Goosey> > let x = 1 in x+1
15:01:44 <lambdabot>   2
15:01:52 <kmc> > let x = 1:x in x
15:01:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:01:58 <Goosey> :O
15:02:10 <alistra> > let x = 1.0 + x in x
15:02:14 <lambdabot>   mueval-core: Time limit exceeded
15:02:24 <donri> > let not' False = True; not' True = False in not' (2 == 3)
15:02:24 <lambdabot>   True
15:02:26 <kmc> > let o = map (+1) e; e = 0 : map (+1) o in o
15:02:27 <alistra> > let x = 1000000000.0 + x in x
15:02:27 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
15:02:30 <lambdabot>   mueval-core: Time limit exceeded
15:02:41 <alistra> > let x = 1000000000.0 * x in x
15:02:43 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:02:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:02:45 <lambdabot>   mueval-core: Time limit exceeded
15:02:49 <donri> > let x + x = 3 in 5 + 10
15:02:51 <lambdabot>   Conflicting definitions for `x'
15:02:51 <lambdabot>  Bound at: <interactive>:1:4
15:02:51 <lambdabot>            <in...
15:03:00 <hpc> > let undefined = 5 in Just {}
15:03:01 <lambdabot>   Just *Exception: <interactive>:3:21-27: Missing field in record construction
15:03:04 <hpc> D:
15:03:09 <Goosey> @src zipWith
15:03:10 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:03:10 <kmc> > let x + y = 3 in 5 + 10
15:03:10 <lambdabot> zipWith _ _      _      = []
15:03:10 <lambdabot>   3
15:03:11 <donri> > let (+) = 3 in 5 + 10
15:03:12 <lambdabot>   3
15:03:45 <Axman6> :t let (+) = 3 in (+)
15:03:46 <lambdabot> forall t. (Num t) => t
15:03:54 <hpc> donri: haha
15:04:05 <donri> \o/
15:04:31 <kmc> > 3 5 10
15:04:32 <lambdabot>   3
15:04:43 <hpc> > do {1;2;3;4} $ 5
15:04:44 <lambdabot>   4
15:04:46 <kmc> lambdabot has some unusual instances defined in order to make this work
15:05:07 <donri> > let _+_ = 3 in 5 + 2 + 7
15:05:08 <lambdabot>   3
15:05:19 <alistra> agda syntax?
15:05:37 <jmcarthur> o_O
15:05:39 <hpc> > let _+_=3in5+2 + 7
15:05:39 <lambdabot>   not an expression: `let _+_=3in5+2 + 7'
15:05:45 <hpc> > let _+_=3 in 5+2 + 7
15:05:45 <lambdabot>   3
15:06:11 <hpc> i could have sworn there was a parsing quirk that made it handle let statements oddly
15:06:15 <alistra> > let _+_*_ = 3 in 5+2*3
15:06:16 <lambdabot>   <no location info>: Parse error in pattern
15:06:20 <jmcarthur> > _+_ = const $ const "foo" in 5 + 4
15:06:21 <lambdabot>   <no location info>: parse error on input `='
15:06:33 <jmcarthur> > let_+_ = const $ const "foo" in 5 + 4
15:06:34 <lambdabot>   <no location info>: parse error on input `='
15:06:36 <jmcarthur> > let _+_ = const $ const "foo" in 5 + 4
15:06:37 <lambdabot>   Overlapping instances for GHC.Show.Show
15:06:37 <lambdabot>                              (b -> ...
15:06:39 <jmcarthur> i suck
15:06:48 <osfameron> huh.  that's odd
15:06:49 <hpc> :t const $ const "foo"
15:06:49 <lambdabot> forall b b1. b -> b1 -> [Char]
15:06:49 <jmcarthur> > let _+_ = "foo" in 5 + 4
15:06:50 <lambdabot>   "foo"
15:06:53 <parcs`> _+_ = _ + _
15:06:56 <jmcarthur> yeah
15:06:57 <endojelly> I didn't know Haskell has Agda syntax for binary operators?!
15:07:03 <jmcarthur> i caught on about half way through that exercise
15:07:03 <osfameron> as let _+_ = 3 in 5 # 5
15:07:08 <jmcarthur> it doesn't
15:07:13 <alistra> _ is not agda syntax, it's 2 times _
15:07:17 <hpc> endojelly: it doesn't; it's patterns written obtusely
15:07:30 <alistra> it's like while(x --> 0)
15:07:33 <endojelly> oh.
15:07:35 <accel> how does the zipper for an empty document look like?
15:07:36 <alistra> in C
15:08:02 <osfameron> oh, it's redefining + temporarily
15:08:07 <hpc> accel: presumably zipper-shaped
15:08:55 <dmwit> accel: There is no corresponding zipper.
15:09:29 <dmwit> Only containers with some contents may have a finger pointing at a particular piece of content.
15:09:30 <donri> let (>>) = (:) in do 1; 2; 3; []
15:09:33 <kmc> #define ever (;;)
15:09:44 <donri> > let (>>) = (:) in do 1; 2; 3; []
15:09:44 <lambdabot>   No instance for (GHC.Num.Num [a])
15:09:45 <lambdabot>    arising from the literal `1' at <inter...
15:10:02 <dolio> The wonders of a texual macro system.
15:10:21 <statusfailed> re: Enumerator/Iteratee: Did it inspire C#'s "IEnumerable"?
15:10:29 <dolio> No.
15:10:38 <statusfailed> seems similar
15:10:46 <dmwit> I'm about 99% sure IEnumerable predated enumerators and iteratees.
15:10:46 <donri> that I probably stands for Interface?
15:10:51 <statusfailed> it does
15:10:54 <dolio> It's almost certain that IEnumerable was around first.
15:10:55 <ddarius> IEnumerable preceded Enumerator/Iteratee by almost a decade.
15:11:05 <statusfailed> including the "yield return" thing?
15:11:10 <dmwit> Also, IEnumerable seems more related to Foldable or Traversable than enumerators/iteratees.
15:11:20 <ddarius> statusfailed: No, but yield return still predated iteratees and enumerators.
15:11:37 <kmc> it's closer to C++ or Java iterators
15:11:43 <CsDezolator> can anyone please take a look at this code http://pastebin.com/Sn7zMBa6 and tell me what's wrong... the camera starts , the file is created, and then.Nothing.
15:11:45 <mauke> The paste Sn7zMBa6 has been copied to http://hpaste.org/55438
15:11:50 <ddarius> IEnumerable is also nothing like the enumerator/iteratee libraries.
15:12:00 <statusfailed> ddarius: oh, ok
15:12:11 <statusfailed> it seemed on light inspection to be very similar but clearly I've misunderstood
15:12:43 <kmc> yikes, a line that starts with 52 spaces
15:13:45 <ddarius> ∀x∈Q.P(x) ⇔ Q ⊆ P, ∃x∈Q.P(x) ⇔ Q ∇ P
15:15:12 <dolio> Is that the standard 'intersects' notation?
15:15:35 <ddarius> No.  There isn't a standard notation for that operation.
15:15:40 <dolio> Ah.
15:16:07 <ddarius> The notation I've seen is parenthesis like )( only overlapping.  The operation is called "overlaps."
15:16:29 <dolio> Eh. I don't know how great that is.
15:16:48 <ddarius> It is equivalent to the intersection being empty (in a setting using classical logic.)
15:16:54 <ddarius> Er nonempty.
15:16:59 <dolio> Right.
15:18:27 <ddarius> It's just an odd lacuna in mathematical notation.
15:20:16 <roconnor> if Snap.Http.Server.simpleHttpServer never returns it should have t
15:20:18 <roconnor>     Home
15:20:19 <roconnor>     About
15:20:21 <roconnor>     Blog
15:20:22 <roconnor>     Download
15:20:24 <roconnor>     Do
15:20:25 <roconnor> ah crap
15:20:44 <roconnor> if Snap.Http.Server.simpleHttpServer never returns it should have return type IO Void or forall a. IO a
15:22:27 <lmatos> Axman6: It acts as a temp var?
15:23:25 <lmatos> that's where I seem to be getting caught up. Any time i've counted I've had some sort of temp counter storage var. Is that what the _ acts as?
15:23:57 <ddarius> No.
15:24:22 * ddarius should grep the logs to see how many times I've responded simply with "No."
15:24:26 <Goosey> _ is just a variable that means you don't care about what it is.
15:24:32 <Goosey> As far as I know at least.
15:25:05 <kmc> it's not a variable
15:25:11 <ddarius> It's not a variable at all.  It's a wildcard pattern.  It's just a way to explicitly ignore something.
15:25:12 <Goosey> It'll unify with anything though
15:25:13 <kmc> it's just a pattern which matches anything and discards it
15:25:32 <Goosey> It seems like it's exactly the same as in Prolog.
15:25:42 <kmc> you can say «f _ _ = 3» but you can't say «f x x = 3»
15:25:49 <ddarius> There is no unification in Haskell, but yes, it will match anything and it is a simpler version of the equivalent thing in Prolog.
15:25:50 <kmc> this shows it's not a variable
15:26:00 <kmc> nothing in Haskell is exactly the same as anything in Blub
15:26:09 <Goosey> ddarius: Simpler? It's pretty simple in prolog xD
15:26:12 <statusfailed> sounds exactly the same as _ in XC :P
15:26:40 <kmc> what's XC
15:27:00 <ddarius> Goosey: _ still allocates a unification variable which can later be bound.
15:27:01 <statusfailed> a language for a chip made by xmos
15:27:18 <kmc> i see
15:28:15 <Goosey> Well, I guess it is more simple, but not by much :P
15:28:53 <shachaf> ddarius: 78 times between ~2002 and 2011 (with the nick "ddarius", at least).
15:29:16 <ddarius> shachaf: I used to use the nick Darius.
15:29:30 <shachaf> Right. I see five occurences for Darius.
15:30:00 <shachaf> Oh, I'm not counting lines of the form "nick: No."
15:30:18 <ddarius> shachaf: Ah.  Yeah, 78 sounded massively too low.
15:30:37 <shachaf> That brings it up to 370 for ddarius and 18 for Darius.
15:30:41 <shachaf> That's a bit more like it. :-)
15:31:19 <shachaf> Actually 368. But anyway.
15:31:46 <Goosey> Is anyone using an IRC client they wrote in haskell?
15:32:11 <ddarius> There are some people.  There's hircules and ManateeLazyCat's one.
15:32:44 <ddarius> I think most people are using whatever because existing ones are more than adequate for most people.
15:33:33 <Goosey> Yeah, when I have the knowledge, I'll write my own in haskell for the hell of it.
15:33:51 <ddarius> Goosey: Why not write something more useful "for the hell of it"?
15:34:09 <Goosey> ddarius: Okay, give me an example xD
15:35:09 <Ke> something running on top of xmonad perhaps
15:35:16 <hpc> Goosey: not a client but my IRC bot was written in haskell
15:35:41 <Ke> ok that's not useful to others though
15:35:50 <hpc> true :P
15:35:52 <shachaf> An IRC bot is an IRC client.
15:36:13 <ddarius> Goosey: Write something to parse and normalize XQuery.
15:36:34 <ddarius> Wait, let me check that that isn't already on Hackage.
15:36:53 <jessopher> i think it is, in several packages, namely XQuery
15:36:56 <ddarius> Damn, looks like it might be.
15:37:32 <ddarius> Well, I had a not-very-important desire for such a thing recently.  Nice to know that it is there.
15:38:06 <ddarius> Anyway, I'm sure people can come up with things they want done but are too lazy to do themselves.
15:38:56 <lmatos> so the code pasted above says, I don't care what the value is, (due to _ ) just pass a 1 to sum and keep passing 1's to sum until the list has been traversed? Sum does all the increment logic? That is where I'm getting confused. Is it making a list of ones to pass to sum or? The list comp is passed as an arg to sum , so it is fully comped (and to what?) and then sumed or  is it passed 1 by 1? :/ I'm sorry I'm having trouble groking this :/
15:39:03 <ddarius> jessopher: There is no XQuery package, but there is a thing that compiles XQuery to Haskell which presumably includes a parser.
15:39:30 <Axman6> > sum [1,1,1]
15:39:31 <lambdabot>   3
15:39:35 <ddarius> lmatos: List comprehensions make lists.
15:39:38 <jessopher> ah, i thought there was one named XQuery, must have been a sub module of something else
15:39:39 <Axman6> > sum [1..10]
15:39:40 <lambdabot>   55
15:39:42 <ddarius> sum is just a function that takes a list.
15:41:07 <lmatos> ah!
15:41:09 <lmatos> Got it!
15:41:23 <ddarius> @src catMaybes
15:41:24 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:42:16 <lmatos> Awesome! Thanks for that ddarius & Axman6 !
15:43:35 * jessopher wishes there was a generic mixfix parsing package with really good documentation
15:45:23 <jessopher> my brain is only partially wrapped around DAG precedence tables
15:46:10 <gwern> gah. what debian libraries do I need to install to get snap-server to compile?
15:47:35 <rostayob> gwern: debian stable? I think that cabal is the only option if you want a decently recent version
15:47:37 <AfC> gwern: hop over to #snapframework and I'm sure we can help you figure it out
15:47:52 <parcs`> gwern: i think snap uses libevent
15:48:00 <gwern> AfC: I think I'd rather mutter imprecations here and slander snap's good name
15:48:07 <rostayob> ah right, the external libraries
15:48:45 <AfC> gwern: well, it's working fine here, so if you can't figure it out, it's only your good name that's being besmirched.
15:49:08 <gwern> bleh, and jasper's git repo for snap-server works when apparently the hackage one doesn't
15:49:21 * gwern doesn't even know why hakyll depends on snap
15:50:08 <Goosey> why does lem' n (x:xs) = if n-1 > 0 then lem (n-1) xs say parse error (possibly incorrect indentation)
15:50:33 <augur> which talk was it where SPJ talked about type functions?
15:50:35 <gwern> which doesn't help because hakyll specifies a lower version, lovely
15:50:50 <jessopher> Goosey: you need an else clause
15:50:56 * gwern disables the preview-server. like I need that
15:51:04 <Goosey> It's absolutely needed? >_>
15:51:09 <jessopher> yep
15:51:20 <jessopher> what would it evaluate to if the condition was false?
15:52:48 <Goosey> Well I don't know >_<
15:52:56 <jessopher> :)
15:53:13 <Axman6> Goosey: what is the result of foo x = if x > 0 then x when x <= 0?
15:55:06 <kmc> > [ 1 | _ <- "hi lmatos"]
15:55:06 <lambdabot>   [1,1,1,1,1,1,1,1,1]
15:57:17 <kmc> lmatos, you asked "Is it making a list of ones to pass to sum or... is it passed 1 by 1?"
15:57:28 <kmc> the answer is a little subtle, because of lazy evaluation
15:57:48 <lmatos> kmc: care to elaborate?
15:57:57 <Axman6> Goosey: you must remember that this is not imperative programming, where you say do this, then do this, then this. you specify what data goes where. all functions must return some data, so if we had `if x then`, we couldn't return anything if x is false
15:58:08 <Goosey> yeah
15:58:24 <Goosey> > let length' n = sum [1|_ <- n] in length' "Hello world"
15:58:25 <lambdabot>   11
15:58:37 <Goosey> @src length
15:58:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:58:42 <Goosey> :O
15:58:48 <Axman6> huh, how odd
15:59:12 <jessopher> @src Data.List.length
15:59:12 <lambdabot> Source not found. My brain just exploded
15:59:14 <Axman6> it's usually defined as something like: foldl (\acc _ -> 1+acc) 0 i think
15:59:19 <jessopher> pfft
15:59:26 <Axman6> > let len = foldl (\acc _ -> 1+acc) 0 in len [1..10]
15:59:27 <lambdabot>   10
15:59:40 <Goosey> @src sum
15:59:41 <lambdabot> sum = foldl (+) 0
15:59:50 <ddarius> @src genericLength
15:59:50 <lambdabot> genericLength []    = 0
15:59:50 <lambdabot> genericLength (_:l) = 1 + genericLength l
15:59:54 <ddarius> Oi.
15:59:56 <Axman6> or, for beginners: length [] = 0; length (x:xs) = 1 + length xs
16:00:46 <Goosey> genericLength "Hello World"
16:00:51 <Goosey> > genericLength "Hello World"
16:00:52 <lambdabot>   11
16:01:18 <Axman6> > genericLEngth "hello" :: Nat
16:01:18 <lambdabot>   Not in scope: type constructor or class `Nat'Not in scope: `genericLEngth'
16:01:22 <Axman6> :(
16:01:40 <mdxbhmt> hey, why it is 'return' in monads?
16:01:51 <mdxbhmt> shouldn't  be something like 'wrap'?
16:02:05 <hpc> mdxbhmt: hysterical raisins
16:02:06 <kmc> lmatos, it's a list of ones.  but the elements of the list are only created as they are demanded
16:02:13 <jessopher> someone thought return was a good name, they could have been wrong
16:02:31 <mdxbhmt> hpc:  hmmmm?
16:02:45 <Goosey> what is my GHCI doing: Prelude> [3*1..10]   [3,4,5,6,7,8,9,10]
16:02:52 <kmc> what do you mean what is it doing
16:02:55 <hpc> mdxbhmt: i believe it's what it was called in a research paper, or it's a term from category theory, or something
16:02:59 <kmc> it's evaluating the expression you gave and printing the result
16:03:01 <hpc> i forget exactly
16:03:06 <Axman6> mdxbhmt: Monad has been around for a very long time, wehen it was created, it wasn't a bad place to put it, but with hindsight we can see it might have been better elsewhere
16:03:08 <dolio> Definitely not a category theory term.
16:03:09 <kmc> lmatos, and a good Haskell implementation can fuse together the code for 'sum' and the list-generating code.  so that it runs in constant space
16:03:17 <jessopher> i like 'encode'. Just do something like wrap = return and you are good to go
16:03:18 <Goosey> kmc, I tohuhgt [3*1..10] would return 3,6,9..30
16:03:19 <kmc> the category theory term is η ;P
16:03:24 <Goosey> thought* wow that was bad...
16:03:24 <kmc> Goosey, why did you think that?
16:03:34 <kmc> > [ (3*1) .. 10 ]
16:03:35 <lambdabot>   [3,4,5,6,7,8,9,10]
16:03:35 <Goosey> because 3*1 is 3, 3*2 is 6...etc
16:03:51 <dolio> > [3, 6 .. 10]
16:03:52 <lambdabot>   [3,6,9]
16:03:56 <kmc> > map (3*) [1..10]
16:03:57 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
16:04:01 <kmc> > [ 3*x | x <- [1..10] ]
16:04:02 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
16:04:19 <Goosey> kmc, beat me to it >_< I was going to do a comprehension
16:04:33 <kmc> lmatos, lists are either data structures or control-flow structures, depending on how you use them
16:04:41 <mdxbhmt> hpc: Axman6, thanks
16:04:55 <kmc> they can act like data or like loops
16:05:30 <lmatos> kmc: you said, haskell implementations. I assume GHC is the "basic/standard" what are others that would be "good" (out of curiosity)
16:05:43 <Axman6> heh, GHC is far from basic
16:05:43 <Goosey> > take 5 (cycle [x*x | x <- [3,6..30]])
16:05:44 <lambdabot>   [9,36,81,144,225]
16:05:48 <kmc> others are good in specific ways but GHC is the main implementation used for pretty much everything
16:05:57 <Axman6> GHC is by far the best Haskell compiler
16:06:08 <kmc> it's by far the best for by far most users
16:06:11 <kmc> not the best for everyone
16:06:14 <Axman6> yeah
16:06:23 <kmc> JHC is the best if you want your output as very small portable C programs
16:06:24 <Axman6> the best allrounder anyway
16:06:36 <kmc> UHC might be the best if you want to implement language extensions (and don't care if other people use them)
16:07:03 <kmc> JHC, UHC, and Hugs all have interesting extensions GHC doesn't
16:07:06 <Goosey> kmc, as compared to GHCs large C programs or what?
16:07:22 <Goosey> GHC's*
16:07:30 <Axman6> GHC produces native code these days, not C
16:07:31 <ddarius> JHC is the best if it's cold.
16:07:39 <kmc> GHC-produced binaries are very large, and they are usually not compiled via C, and even when they are it's not standard portable C
16:07:57 <Goosey> AH.
16:07:59 <Goosey> Ah*
16:08:11 <Axman6> you can't even compile via C any more I think
16:08:29 <Goosey> Wouldn't it be better to compile straight to a binary ANYWAYS?
16:08:36 <Goosey> caps fail*
16:08:42 <jessopher> not in all cases
16:08:43 <kmc> not obviously better
16:08:54 <kmc> if you go via C or LLVM then you get to use someone else's hard work writing backend optimizations
16:08:59 <hpc> Goosey: JHC gets to piggyback on the optimizations of gcc
16:09:03 <lmatos> kmc: can you give me an example of a list behaving each way for clarity? I think I get it, but a simple example would help :)
16:09:11 <Goosey> Ah :P
16:09:12 <Axman6> Goosey: compiling straight to machine code means you have to reimplement all the optimisations a C compiler already has if you want fast code
16:09:24 <kmc> the LLVM backend often beats GHC's direct native-code generation
16:09:27 <ddarius> lmatos: It's more a matter of perspective than some technical thing.
16:09:41 <AfC> assuming the C compiler in question outputs good machine code and does good optimization with what you're feeding it
16:09:50 <Axman6> kmc: sometimes, not often though. depends on the kind of code. I'd love to see GHc updated to work with LLVM 3.0 by the way
16:09:56 <shachaf> lmatos: Lists behave as both data structures and control structures, depending on how you look at them.
16:09:57 <cmasseraf> kmc: but in haskell cases the syntax allows for many optimizations that are ussualy done in the back end that a C program wouldn't aloow
16:10:08 <kmc> hmm?
16:10:09 <Goosey> > if take 20 (cycle [1..])
16:10:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:10:14 <kmc> first of all, what does that have to do with syntax?
16:10:19 <gwern> hm, looks like I need to disable hakyll's citeproc stuff because its using an old citeproc-hs version...
16:10:26 <Axman6> AfC: GHC usually fed in quite strange code, that C compilers had a pretty hard time optimising if i remember rightly
16:10:43 <Goosey> > if take 20 (cycle [1..]) `mod` 0 then 1 else 0
16:10:44 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:10:44 <lambdabot>         against inferred type ...
16:10:45 <kmc> Axman6, -fvia-C is still supported and is indeed the only choice for most platforms.  you have to enable it when building ghc, which is not the default
16:10:57 <kmc> Axman6, what was removed was the registerized C backend and the Evil Mangler
16:11:22 <Goosey> I don't know what I was thinking when I typed that....
16:11:28 <Goosey> cycle [1..]
16:11:29 <Goosey> fail
16:11:29 <kmc> so the remaining -fvia-C is for portability only, and does not even attempt to be fast
16:11:36 <AfC> Axman6: sure, but that's unlikely to change, given their optimizations are, well, targeted at the kind of thing C generates when compiled {shrug}
16:11:40 <Goosey> That's almost as bad as when I did length [1..]
16:11:44 <Axman6> ah, i see. i thought they removed it completely
16:12:01 <kmc> debian still likes to build GHC for every platform
16:14:53 <Goosey> Can I access the text document lamdba bot reads it's source from?
16:15:26 <dolio> The evil mangler was used with -fvia-C.
16:15:33 <donri> maybe http://code.haskell.org/lambdabot/ somewhere in here
16:16:25 <ski> Goosey : which text document ?
16:17:01 <gienah> ski Goosey donri: .lambdabot/State/source
16:18:03 <dolio> What was removed was the high performance C backend.
16:18:03 <donri> Goosey: http://code.haskell.org/lambdabot/State/source (thanks gienah)
16:18:12 <shachaf> Goosey: Note that that file has a number of inaccuracies.
16:18:14 <dolio> Now only the portability one exists.
16:18:29 <Goosey> Oh okay, thanks.
16:18:41 <Goosey> lambdabot's source says it can execute brainfuck...
16:20:36 <donri> @karma #c
16:20:36 <lambdabot> #c has a karma of 1
16:20:40 <donri> ^_^
16:20:58 <shachaf> @karma ##c
16:20:58 <lambdabot> ##c has a karma of 0
16:21:18 <shachaf> preflex: karma #c
16:21:18 <preflex>  #c: 3381
16:21:19 <shachaf> preflex: karma ##c
16:21:19 <preflex>  ##c: 7339
16:21:41 <zmv> preflex: karma c
16:21:41 <preflex>  c: 179847
16:21:41 <zmv> holy shit
16:21:59 <donri> @karma c
16:21:59 <lambdabot> c has a karma of 0
16:22:10 <fullofcars> how might I define take in haskell?
16:22:18 <donri> @src take
16:22:18 <lambdabot> take n _      | n <= 0 =  []
16:22:18 <lambdabot> take _ []              =  []
16:22:19 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:22:31 <fullofcars> ah ty
16:22:46 <shachaf> fullofcars: I recommend ignoring what lambdabot just said and implementing it yourself as an exercise.
16:22:58 <fullofcars> i tried but I'm failing :(
16:23:13 <rohit> hi
16:23:14 <Goosey> @bf ,>,[<[->-]]>[-<+>>]<<.
16:23:14 <lambdabot>  Done.
16:23:19 <Goosey> :/
16:23:29 <fullofcars> er wait, maybe I did write it right
16:23:35 <shachaf> Goosey: You can /msg lambdabot, by the way, if you want to experiment with things. :-)
16:23:54 <fullofcars> ah recursion make me confused :)
16:24:09 <Goosey> Why does he just say done when I try using @bf
16:24:22 <Guest95484> @help
16:24:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:24:25 <Goosey> He doesn't actually evaluate it >_<
16:24:30 <zmv> Goosey: because he's done :D
16:24:33 <zmv> well
16:24:35 <zmv> it's not "he"
16:24:40 <Goosey> <_< it
16:24:41 <shachaf> Probably because you're using ,
16:24:44 <zmv> it's "she". bots are always "she".
16:24:56 <Goosey> Oh, they are? Even the male ones?
16:25:14 <mdxbhmt> all bots are called anna
16:25:17 <zmv> there's no such thing as a male bot.
16:25:28 <donri> no, bots are not girls just because geeks like to pretend they're talking to one
16:25:28 <parcs`> @karma clang
16:25:28 <lambdabot> clang has a karma of 0
16:25:31 <parcs`> @karma g
16:25:31 <lambdabot> g has a karma of 0
16:26:22 <mdxbhmt> @karma lambdabot
16:26:22 <lambdabot> lambdabot has a karma of 3
16:26:32 <jessopher> bots have esperanto genderless personal pronouns.. i just dont speak esperanto, so i dont know what they are
16:26:50 <MostAwesomeDude> lambdabot is a girl.
16:27:02 <zmv> jessopher: ĝi, iirc
16:27:05 <MostAwesomeDude> (So is manatee, if you've run into her before.)
16:27:30 * jessopher hasnt run into any manatees lately :P
16:27:42 <Goosey> Yeah....bf is a useless command >_>
16:28:15 <donri> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
16:28:15 <lambdabot>   Hello World!
16:28:20 <shachaf> Can you take this sort of discussion to #not-haskell?
16:28:50 <Goosey> donri: Ah, it doesn't output the cells memory
16:28:59 <shapr> Or perhaps #haskell-overflow?
16:28:59 <Goosey> also, yeah I'll stop, sorry >_<
16:29:05 <ddarius> It outputs the output.
16:35:02 <ski> preflex: xseen ManateeLazyCat
16:35:02 <preflex>  ManateeLazyCat was last seen on freenode/#haskell 60 days, 7 hours, 50 minutes and 48 seconds ago, saying: Good night all. :)
16:36:12 <Goosey> manatelazycat must have died..
16:38:42 <gienah> Goosey: he is busy working on other stuff at the moment
16:39:09 <Goosey> gienah: He must be working on something big then :P
16:39:37 <ski> @wiki Manatee
16:39:37 <lambdabot> http://www.haskell.org/haskellwiki/Manatee
16:42:07 <Goosey> I see.
16:42:39 <ddarius> That's not what he's working on right now, otherwise he'd be here.  He's doing whatever he does that puts food on his table.
16:43:29 <gienah> there were 2 sets of major api changes to dbus that broke manatee. I patched manatee for the first set, and sent andy the patches, but the second set broke those as well and I could not even see how to fix manatee for the second set
16:47:14 <Goosey> ghci> (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
16:47:35 <Goosey> Why does he use a , and the use another let?
16:47:55 <Goosey> then*
16:48:05 <hpc> Goosey: it's a tuple
16:48:13 <hpc> > let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
16:48:13 <lambdabot>   <no location info>: parse error on input `,'
16:48:16 <Goosey> oh, I didn't notice that
16:48:21 <hpc> or apparently a parse error
16:48:28 <hpc> but with the right braces, it's a tuple
16:48:47 <Goosey> > (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
16:48:49 <lambdabot>   (6000000,"Hey there!")
16:49:07 <hpc> oh, lol
16:58:54 <Goosey> I finally made it to the recursion chapter!
16:59:23 <zmv> good luck getting out of it :P
16:59:41 <Goosey> zmv: My friend just said "You'll never escape it" xD
17:05:27 <Axman6> > let toInteger = foldl (\acc x -> acc * (fromIntegral (ord maxBound)) + fromIntegral (ord x)) 0 in toInteger "Hello"
17:05:27 <lambdabot>   110929458248688619891130450
17:05:38 <zmv> wtf
17:07:33 <Axman6> > let fromInteger = unfoldr (\x -> case x of 0 -> Nothing; n -> Just $ divMod x (fromIntegral (ord maxBound))) in fromIntegral 110929458248688619891130450
17:07:34 <lambdabot>   110929458248688619891130450
17:07:38 <Axman6> hmm
17:10:55 <Axman6> > let swap (a,b) = (b,a); fromInteger = unfoldr (\x -> case x of 0 -> Nothing; n -> Just $ swap $  divMod x (fromIntegral (ord maxBound))) in fromIntegral 110929458248688619891130450
17:10:56 <lambdabot>   110929458248688619891130450
17:11:17 <Axman6> > let swap (a,b) = (b,a); fromInteger = unfoldr (\x -> case x of 0 -> Nothing; n -> Just $ swap $  divMod x (fromIntegral (ord maxBound))) in fromInteger 110929458248688619891130450 -- duh
17:11:18 <lambdabot>   [111,108,108,101,72]
17:11:27 <ski> (:
17:11:32 <Axman6> > let swap (a,b) = (b,a); fromInteger = unfoldr (\x -> case x of 0 -> Nothing; n -> Just $ first chr $ swap $  divMod x (fromIntegral (ord maxBound))) in fromInteger 110929458248688619891130450 -- duh
17:11:33 <lambdabot>   "\38096\1070725\836102\1114110\1114110\1114110\1114110\1114110\1114110\1114...
17:11:38 <Axman6> heh.. nooo
17:11:48 <zmv> wtf...
17:11:57 <Axman6> > let swap (a,b) = (b,a); fromInteger = unfoldr (\x -> case x of 0 -> Nothing; n -> Just $ first chr $  divMod x (fromIntegral (ord maxBound))) in fromInteger 110929458248688619891130450
17:11:57 <lambdabot>   "*Exception: Prelude.chr: bad argument: (-309731814274)
17:15:18 <Axman6> > let fromInteger 0 = []; fromInteger n = let (a,b) = divMod n (fromIntegral (ord maxBound)) in chr b : fromInteger a in fromInteger 110929458248688619891130450
17:15:19 <lambdabot>   "\38096\1070725\836102\1114110\1114110\1114110\1114110\1114110\1114110\1114...
17:15:31 * Axman6 gives up and finishes his lunch
17:16:23 <hpc> Axman6: lunch? are you in japan or something?
17:16:30 <Axman6> .au
17:16:33 <hpc> ah
17:16:59 <Makoryu> Axman6: Hey do you still use Textmate
17:16:59 <kmc> crikey
17:17:07 <Axman6> i do
17:17:10 <kmc> in japan they shut down the stock market for an hour each day to have lunch
17:17:23 <hpc> kmc: that's awesome
17:17:26 <Axman6> heh
17:17:36 <hpc> they should do that everywhere
17:17:51 <kmc> no it adds stupid complexity
17:17:57 <kmc> they should just keep all markets open 24/7
17:18:04 <Makoryu> Axman6: Does the new indent behavior in TM2α drive you crazy
17:18:30 <Axman6> yeah :\
17:18:48 <shachaf> kmc: I'm pretty surprised that they don't.
17:18:53 <shachaf> kmc: Is it just out of tradition, or what?
17:19:11 <kmc> some markets do
17:19:14 <kmc> some of them run 24/5
17:19:33 <Makoryu> Axman6: I never really got the hang of using the indent features but maybe you'll have better luck
17:20:05 <Makoryu> Axman6: https://github.com/avian/haskell.tmbundle <- The official version is on github and also the dudes in #textmate will surely be of tremendous help like always
17:20:21 <kmc> it's convenient to have some downtime, for the execution of operations which are logically atomic
17:20:48 * ddarius has a friend who works for the Tokyo Stock Exchange.
17:20:49 <Goosey> Is there a command for GHCi that performs the same task as trace. in swi-prolog?
17:20:55 <ddarius> There's a good sushi place near it.
17:21:18 <Makoryu> Axman6: After all this bundle is used by Subtext and Vico and god knows what else so
17:21:24 <Makoryu> Y'know
17:21:52 <Axman6> eh, i';ve never really been interested in fixing that stuff. it's another, not particularly useful, language to learn
17:22:28 <Axman6> but, I might have a look and see if i can fix the module ... where indentation, that bites me a lot
17:22:35 <Makoryu> Indeed
17:23:12 <ddarius> Ketchup lasts forever apparently.
17:23:29 <Makoryu> It's looking like TM bundles won't die any time soon even if Allan suddenly gets eaten by a snow shovel and everyone stops using Textmate
17:24:34 <Makoryu> If there's a way to at least turn off auto-re-indent per language that would be useful
17:24:42 <Makoryu> Anyway I'm pretty much washing my hands of this
17:24:56 <Axman6> https://github.com/avian/haskell.tmbundle/blob/master/Syntaxes/Haskell.plist <- like hell i'm going to be able to understand that enough to change it >_<
17:24:59 <Makoryu> Just figured someone should know it's a disaster and yet something can be done about it
17:25:05 <kmc> no doubt
17:25:05 <kmc> publicly traded companies like to make big announcements just after close, so that participants have some time to think, or something like that
17:25:05 <kmc> but people also do after-hours equity trading, and trading of futures on those equities
17:25:09 <Makoryu> Yeah see
17:26:17 <Makoryu> Axman6: It's way easier to edit if you convert it to the human readable format but Apple doesn't want anyone exporting to that format for some insane reason
17:26:25 <Goosey> (Num i, Ord i) => i -> a -> [a]
17:26:28 <Makoryu> IIRC the command line plist tools won't even write it
17:26:35 <Goosey> Does that only constrain i to those classes?
17:26:38 <Makoryu> (They can still read it though)
17:26:45 <Makoryu> Goosey: Yeah
17:28:37 <Axman6> Goosey: it means that i must be a type that implements Ord, and a must be a type that implements Num
17:28:54 <Makoryu> No he had (Num i, Ord i)
17:28:59 * mgsloan wants to make a haskell clone of sublimetext.. (time permitting, which it won't soon)
17:29:10 <Makoryu> mgsloan: Are you mad
17:29:22 <donri> work on yi instead
17:29:34 <ddarius> mgsloan: What's wrong with the existing one?
17:29:44 <Makoryu> Nah actually if you're gonna make a new Haskell text editor it might as well be a Textmate-alike
17:30:03 <Makoryu> I cannot praise the syntax highlighting model enough
17:30:08 <Makoryu> At least the theory behind it
17:30:38 <Axman6> yeah :\
17:30:58 <Makoryu> The indentation model sucks but
17:31:06 <Makoryu> (I mean wow it really is awful)
17:31:45 <Axman6> I was thinking about how to make it better the other day, and I'd do it by defining a tool which spits out an AST  (in json form or something). then any language which has a compiler could theoretically be used for parsing.... but the compilers would need ti support broken code
17:32:01 <donri> how about http://youtu.be/v2ypDcUM06U ^_^
17:32:14 <mgsloan> makoryu - perhaps somewhat unreasonable.  ddarius - just that the source isn't open
17:32:46 <mgsloan> :Mostly in order to be able to intersperse type information in between the lines
17:33:02 <Makoryu> mgsloan: You lost me
17:33:22 <Cale> donri: If it could work well with zero clicks, that looks reasonable ;)
17:33:48 <donri> yea, http://chrisdone.com/posts/2011-12-17-concept-for-editing-asts-rather-than-text.html
17:33:49 <Cale> the clicking makes it super-awkward though
17:33:59 <donri> it's not meant to be mouse-focused
17:35:02 <Cale> All I really want right now is an editor which properly understands the offside rule
17:35:34 <Cale> and it'd be nice if it displayed subtle grey lines along the indentations which matter
17:36:01 <mgsloan> donri - yup! I was pretty excited to see that.  Keyboard driven is definitely necessary, though.  I think that one of the main benefits of having a somewhat richer editing interface would be to give the user information that the compiler knows quite directly (hopefully without being too overwhelming)
17:36:51 <Cale> The correct behaviour in my mind is that any edit which causes the first non-whitespace character after do, let, of, or where to move should cause the entire block to move analogously.
17:37:57 <donri> Cale: http://youtu.be/uQSRD3uIP4o ?
17:38:37 <donri> also http://youtu.be/UXHSiUPKLvg
17:38:41 <Cale> That's nice, but it's not doing what I'm talking about
17:39:15 <Makoryu> Cale: Should the "show invisible characters" option display semicolons, you think?
17:39:21 <Makoryu> (In such an editor)
17:39:25 <mgsloan> Cale - that would be very cool!  I've noticed that Haskell is very amenable to some of the more powerful text editing commands - eg, "df$" in vim
17:39:27 <Cale> Makoryu: I dunno, maybe?
17:41:19 <donri> Cale: i think it does what you mean, but you want it to happen "live" (which the latter video does, but only for imports)
17:42:37 <Cale> donri: possibly... I saw some blocks moving one space at a time, so it seemed to understand at least well enough to recognise the block, but the demo didn't show any example involving moving stuff after an actual layout keyword
17:43:16 <mgsloan> So, I'm inclined to want something that gives somewhat smarter editing, but still based on traditional text editing operations, with a lot more visualization of the artifacts associated with code (types, sample runtime values, profiling)
17:43:32 <Cale> Yeah, that would be pretty awesome
17:44:14 <Cale> Being able to colour the code according to the cost centres by number of entries, time and allocation would be really cool
17:44:14 <donri> i think that's what chrisdone is going for with his emacs mode
17:44:19 <donri> the ast editing idea is separate
17:44:28 <mgsloan> oh, and not to forget pumped up, extra-powerful, hoogley autocomplete
17:45:10 <donri> better base autocomplete on the imports
17:45:35 <Cale> My boss has a little gtk2hs source displayer where you can click on terms in the Haskell code and it prints the type on the terminal
17:46:00 <donri> there's a vim script for that
17:46:05 <Cale> (just as a proof of concept that it can be done using the GHC API)
17:46:58 <mgsloan> donri - definitely.  This will likely happen anyway due to the types, as long as you're not writing heavily polymorphic code.
17:47:03 <Cale> donri: does it work on *any* term? Like local variables and such?
17:47:26 <Cale> or does it just ask GHCi for the type?
17:48:04 <mgsloan> Cale - I have something that gives you types for every part of an expression, even if there are type errors
17:49:02 <Cale> mgsloan: does it use the GHC API?
17:49:26 <fullofcars> are float sqrts usually optimized in a CPU table?
17:49:44 <xplat> what kind of types does it give you if there are type errors?
17:50:46 <donri> duno http://www.vim.org/scripts/script.php?script_id=3204
17:51:12 <Cale> fullofcars: tbh I haven't checked how they compile, but trig functions compile to CPU floating point instructions
17:51:19 <mgsloan> Cale -  It drives GHCI, in the same multithreaded way that ActiveHS does.  I came up with a way to munge the code that lets you get types for all the elements of the expression (it could well be broken, though..).  unfortunately school has been getting in the way of me getting this really packaged up and fixed up in a way that's useful to people - just a wip demo.
17:51:27 <Cale> fullofcars: so I'd expect sqrt is likely similar
17:51:42 <Cale> mgsloan: interesting
17:52:02 <kmc> fullofcars, it's probably not documented how your CPU implements sqrt internally
17:52:10 <kmc> but you can at least see if a sqrt instruction is being used
17:52:23 <byorgey> School: Getting In The Way of Useful Stuff since 1000 BC
17:52:32 <fullofcars> ok
17:52:42 <fullofcars> thanks :)
17:53:04 <Cale> I wonder if someone could work out the method being used from the rounding errors.
17:53:12 <rostayob> is there a mode for alex/yacc files for emacs?
17:53:18 <Cale> (at least make a decent guess...)
17:53:21 <mgsloan> Christmas break is here, though, so hopefully y'all will see 0.0.1 soon! :D
17:54:42 <Cale> Conventional wisdom is that if you want sqrt or trig functions to be fast, you probably want to reimplement approximations to them. I'm not sure how true that still is though.
17:55:13 <Cale> Probably reasonably true. :)
17:55:36 <kmc> yeah, a lot of the conventional wisdom about optimization is cargo-cult rules from 30 years ago
17:55:47 <ddarius> I doubt that, unless you can tolerate quite significant errors.
17:56:36 <xplat> so maybe for realtime graphics where the alternative is using a blatantly less accurate algorithm that doesn't involve trig/sqrt
17:57:32 <kmc> your approximation will involve more memory accesses than just using the FPU
17:57:40 <kmc> and that may wreck any performance gained through optimization
17:57:47 <mgsloan> byorgey - Too true! but teaching you cool stuff, too: most of the reason I didn't haskell as much as I'd like recently was due to working on getting a humanoid robot to imitate your motions while maintaining balance
17:57:58 * kmc has only once coded in x87 assembly, and that was optimized for space rather than speed
17:58:03 <byorgey> mgsloan: nice =)
17:58:19 <xplat> we didn't do that when i was in school :(
17:58:20 <kmc> code size, that is
17:58:25 <shachaf> kmc: For the 446-byte thing?
17:58:28 <kmc> yeah
17:58:31 <ddarius> You consider x87 a distinct assembly language?
17:58:40 <shachaf> I never made your demo run. :-(
17:58:41 * byorgey 's true attitude toward school can be inferred from the number of years he has spent in it
17:58:45 <kmc> ddarius, not exactly but it seemed the clearest thing to say in this context
17:58:48 <mgsloan> yeah, twas a blast!  Oh, and I'm using diagrams for the type system visualizer thing https://github.com/mgsloan/sinuhask/blob/master/src/TypeDiagrams.hs
17:58:49 <jooss> C++ inbetter than haskell
17:59:02 <byorgey> mgsloan: oh, awesome =)
17:59:02 <jooss> (its a joke)
17:59:10 <kmc> FUNNY JOKE JOOSS
17:59:24 <byorgey> mgsloan: any feature requests?
17:59:26 <donri> @karma C
17:59:26 <lambdabot> C has a karma of 0
17:59:37 <byorgey> mgsloan: I'm going to be doing some diagrams hacking over the next week or two
17:59:45 <xplat> @karma g
17:59:46 <lambdabot> g has a karma of 1
18:00:08 <jooss> is there any good tutorial of haskell in spanish you would recommend?
18:00:19 <xplat> byorgey: you have separate scaling for labels yet?
18:00:34 <mgsloan> byorgey - yeah, I think I may be more suited towards autodidactism in the 40 hrs outside of work, instead of gradschool for now, or at least, I think I'd like to go into grad school way too well prepared
18:00:56 <kmc> http://aprendehaskell.es/
18:01:07 <kmc> i can't speak for quality, but it does exist
18:01:38 <mgsloan> byorgey - awesome!  I might join you in some of that, though perhaps not direct diagrams hacking.  Has anyone made a logo DSL for paths?
18:01:47 <jooss> thanks kmc
18:02:04 <byorgey> mgsloan: no, a logo DSL for paths would be great!  We can stick it in diagrams-contrib
18:02:49 <byorgey> xplat: well, Tillmann Vogt just made a new release of SVGFonts which may make it possible
18:02:57 <byorgey> xplat: I haven't looked at it too carefully yet though
18:02:58 <mgsloan> as for specific API feedback, one thing that I feel like was missing a convenience API was extending bounds in a particular direction.  I'd like to be able to say, for example, # expandBounds (1.0) (1.0, 0)
18:03:07 <mgsloan> to expand by 1.0 on the right
18:03:24 <mgsloan> hmm, maybe it should just be the magnitude of the direction vector
18:03:26 <byorgey> mgsloan: ah, ok.  And what would you expect the semantics to be?
18:05:18 <mgsloan> byorgey - good question - it does leave the bounds in the other directions kinda underspecified..  I've been getting around this by assuming rectangular bounds, and querying the bounds of a larger path which has a rectangular convex hull
18:06:50 <byorgey> mgsloan: ah, I see.  we do have a module for rectangular bounding boxes.  So perhaps what you want is a way to extend those, and a nicer way to integrate them with diagrams?
18:06:50 <mgsloan> this is equivalent to margin in the box model, and is something you definitely want to do in practice
18:06:57 <byorgey> right
18:06:59 <mgsloan> yup
18:08:12 <mgsloan> just convenience functions, really. I'll be sure to try to send anything I come up with that seems useful.
18:09:18 <byorgey> mgsloan: would it suffice to have (1) a way to generate a bounding box from a diagram, (2) a way to extend a bounding box in a particular direction, (3) a way to set the bounds of a diagram to a particular bounding box?
18:09:30 <byorgey> then you could compose those three
18:09:46 <byorgey> we already have (1), and (2) and (3) should be easy
18:11:30 <mgsloan> yup! that's perfect.  (2) and (3) do seem like perfect TwoD utilities
18:11:38 <mgsloan> err double perfect, doh
18:12:14 <mgsloan> One non-convenience thing I've been thinking about is writing a layer over diagrams which makes it convenient to cache cairo renderings, and store the hash of the data that directly lead to that particular diagram.  These could then be composed in a higher level diagram of images, that is always re-rendered.  This might make diagrams more practical for realtime / interactive stuff
18:12:37 <byorgey> ooooh, shiny
18:12:55 <Goosey> the darcs repository for haskell-src-exts is 404'd :/
18:13:13 <mgsloan> (pretty much like two levels of memoization. a -> Diagram, and Diagram -> Effect on CairoSurface)
18:13:26 <byorgey> yeah, cool
18:13:38 <byorgey> mgsloan: (also, note the bounding box stuff is not 2d specific)
18:13:45 <mgsloan> inkscape went to pretty far extents to do this kind of thing. It could be pretty clean here
18:15:09 <byorgey> I guess it's really more like "bounding n-dimensional parallelogramish prismy-thing with sides parallel to basis vectors", but that doesn't roll off the tongue as easily
18:15:25 <Guest95778> is there an easy way to stack multiple monad's of the same type class, but different state, env, etc.?
18:15:41 <shachaf> Use monad transformers and lift.
18:15:45 <c_wraith> Guest95778: sure.  But you'll need to lift explicitly
18:16:19 <ddarius> byorgey: Bounding n-blades.
18:16:26 <Guest95778> c_wraith, ok, thanks
18:16:37 <cl1> monads are functional programmers way of making imperitive programing a difficult as possible to understand
18:16:39 <byorgey> ddarius: ah, now that *does* roll off the tongue.
18:16:59 <cl1> i'm trying to get my wife to learn her a haskell
18:17:08 <byorgey> Guest95778: there is no easy way.  One way is explicit lifting but that's annoying.  The other way is using http://hackage.haskell.org/packages/archive/Monatron/0.3.1/doc/html/Control-Monatron-Zipper.html  but that has very little documentation.
18:18:10 <byorgey> basically, the documentation is http://users.ugent.be/~tschrijv/Research/papers/icfp2011.pdf
18:18:19 <Axman6> hmm, i wonder what would happen if you had something like StateT s1 (StateT s2 IO) a when you called get... how would you access the s2 state?
18:18:29 <Axman6> lift get?
18:18:36 <ski> @quote age.11
18:18:37 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
18:18:37 <ddarius> Yep.
18:18:38 <Axman6> :t lift get
18:18:38 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadState a m, MonadTrans t) => t m a
18:18:44 <byorgey> Guest42999: as another approach, if you have, say, two states, you can combine them into one state consisting of a pair
18:19:01 <kmc> see also: the monad zipper
18:19:22 <cl1> lol
18:19:29 <kmc> oh, byorgey mentioned that already
18:20:05 <kmc> yes, "very little documentation" meaning "just read the paper, lol"
18:20:18 <byorgey> yeah, it makes me sad
18:20:21 <byorgey> it's a cool paper.
18:20:25 <kmc> except usually in these cases, the library is secretly different from the paper
18:20:48 <byorgey> I'm pretty sure this case is no different.
18:21:39 * kmc wishes the Template Haskell paper were fully implemented in GHC
18:22:15 <mzero> cl1: I've given up getting my spouse to learn Haskell -- buying a dead-tree version of LYAH didn't work --- he still codes in C++....!
18:22:16 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
18:22:54 <cl1> my wife doesn't code. She said she was interested the other day.
18:23:18 <kmc> having undocumented code is probably better than having no code
18:23:38 <kmc> however it's sad that all the undocumented, untested code is mixed in with the production-ready code on Hackage
18:23:44 <mgsloan> byorgey - they're just hyper-AABBs :D
18:23:57 <kmc> it probably sets low expectations
18:24:34 <cl1> I think she would enjoy it, if I could just motivate her enough to put forth some effort.
18:26:45 <hughfdjackson> :| here again
18:26:51 <cl1> i hate undocumented code
18:27:02 <hughfdjackson> after a while.. :p thinking of making the learning leap to haskell over christmas
18:27:06 <hughfdjackson> with the holiday i have on my hands
18:27:52 <cl1> hughfdjackson, go for it.
18:28:03 <hughfdjackson> xD a notion i'm sure gets support hereabouts
18:28:33 <cl1> i'm about 4 days in on learning it myself. http://learnyouahaskell.com
18:28:43 <hughfdjackson> btw, do you guys have a bot running ghci?
18:28:49 <hughfdjackson> cl1: :D exactly what i'm reading
18:29:22 <byorgey> mgsloan: sure =)
18:30:09 <byorgey> yay, people learning haskell =)
18:30:40 <kmc> http://www.lucduc.com/2010/10/equation-of-finding-top-notch.html
18:31:26 <Axman6> > text                                                     "You're looking for me hughfdjackson"
18:31:27 <lambdabot>   You're looking for me hughfdjackson
18:31:37 <hughfdjackson> :P smooth
18:31:43 <hughfdjackson> > max 3 4
18:31:44 <lambdabot>   4
18:31:46 <hughfdjackson> yaaay
18:31:57 <hughfdjackson> *ahem* i hereby swear not to abuse the bot ;)
18:32:12 <mgsloan> or, do so in private ;P
18:32:17 <hughfdjackson> :D
18:32:35 <byorgey> @botsnack
18:32:36 <lambdabot> :)
18:36:16 * hackagebot convertible-ascii 0.1.0.1 - convertible instances for ascii  http://hackage.haskell.org/package/convertible-ascii-0.1.0.1 (MasatakeDaimon)
18:43:25 <cl1> what does hoogle run on?
18:43:40 <Axman6> computers
18:44:02 <cl1> *sigh*
18:44:30 <Axman6> i don't understand the question :\
18:44:35 <cl1> what software is the search functionality
18:44:58 <_riba> :t zip
18:44:59 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
18:45:07 <kmc> cl1, http://hackage.haskell.org/package/hoogle
18:45:19 <cl1> so its all written in haskell?
18:45:30 <kmc> define "all"
18:45:47 <kmc> it's probably running on an OS not written in Haskell
18:45:52 <kmc> using a Haskell runtime system not written in Haskell
18:46:07 <cl1> solr is written in java, it runs on top of lucene which is written in java
18:46:20 <kmc> and it runs on top of oracle jvm which is written in something else
18:46:29 <kmc> also hackage packages can contain non-haskell code
18:47:01 <copumpkin> cl1: the interesting parts of it are all in haskell, yes
18:47:38 <tsanhwa> @pl flip (.)
18:47:38 <lambdabot> flip (.)
18:48:36 <_riba> I have a list of [(Integer, [[a]])] and I don't know how to get the Integer of the [[a]] a condition I have to specify applies to :/
18:48:55 <Axman6> what?
18:48:58 <cl1> i'm definately going to have to take a look at that code
18:49:01 <kmc> :t find
18:49:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:49:04 <Axman6> oh, i get it
18:49:06 <_riba> (Supposed to be a matrix with row numbers)
18:49:10 <Axman6> yeah, find is what you want
18:49:25 <kmc> :t \f -> fmap fst . find (f . snd)
18:49:26 <lambdabot> forall a b. (b -> Bool) -> [(a, b)] -> Maybe a
18:49:29 <cl1> search is relevant to my interests
18:49:39 <ddarius> Wow, that sentence was far more grammatical than I initially thought.
18:50:15 <cl1> LOL
18:50:32 <_riba> Thanks, I'll try it with find
18:50:45 <tsanhwa> @pl flip ($)
18:50:45 <lambdabot> flip id
18:50:59 <Axman6> ddarius: yeah, it toold a while to parse for me too
18:51:57 <_riba> Sorry, it's late and English is not my native language ;)
18:52:29 <Axman6> _riba: turns out there wasn't really anything wrong with the sentense, it was just confusing the first time it was read :P
18:53:26 <kmc> > let find2 f = fmap fst . find (f . snd) in find2 (< 7) [('x', 9), ('y', 3), ('z', 8)]
18:53:27 <lambdabot>   Just 'y'
18:53:33 <_riba> But correct and understandable is better than just correct :D
18:53:55 <ddarius> Axman6: Well the structure smacks of stereotypical German, and sure enough _riba is likely connecting from Austria.
18:54:07 <Axman6> _riba: I'm not sure how I would have phrased it to make it more understandable :P
18:54:19 <Axman6> heh, i see
18:55:14 <Axman6> I have a feeling someone got the spoecs of this laptop wrong... http://www.allbids.com.au/Buy/?T=IBM-ThinkPad-390X-14%2E1-Inch-Celeron-4MHz-Laptop&ID=488027
18:55:20 <cl1> it appears that my haskell learning experiance has been put on hold. My wife just called and she thinks a rodent is in her car.
18:55:32 <Axman6> D:
18:55:37 <hughfdjackson> cl1: time to don a cape!
18:55:54 <Axman6> ><:3
18:56:46 <fryguybob> cl1: You are right, this is not a job for haskell, only Lisps have rodent in their car
18:57:01 <Axman6> also in their cdr
18:57:25 <_riba> Axman6: Judging from the other specs, it's not that unlikely
18:57:41 <_riba> 6GB HDD... wow :D
18:57:46 <Axman6> 400MHz maybe...
18:58:30 <_riba> Probably
18:59:13 <_riba> let find2 f = fmap fst . find (f . snd) in find2 (< 7) [('x', 9), ('y', 3), ('z', 8), ('a', 1)]
18:59:27 <_riba> uh
18:59:35 <_riba> > let find2 f = fmap fst . find (f . snd) in find2 (< 7) [('x', 9), ('y', 3), ('z', 8), ('a', 1)]
18:59:36 <lambdabot>   Just 'y'
18:59:57 <_riba> No, it's not "find"... I need to find all elements of that list
19:00:10 <cl1> its in the heater system, i'm not taking the car apart tonight. she's just using my car instead
19:00:28 <kmc> > let filter2 f = fmap fst . filter (f . snd) in filter2 (< 7) [('x', 9), ('y', 3), ('z', 8), ('a', 1)]
19:00:30 <lambdabot>   "ya"
19:01:13 <kmc> > let filter2 f xs = [ k | (k,v) <- xs, f v ] in filter2 (< 7) [('x', 9), ('y', 3), ('z', 8), ('a', 1)]
19:01:14 <lambdabot>   "ya"
19:02:31 <_riba> Oh, thanks
19:03:22 <augur> anyone happen to know a good resource for learning to appreciate classical music in a technical way?
19:03:27 <ion> I find myself using map fst . filter (f . snd) quite often. It might be nice to have it in base.
19:03:44 <jmcarthur> :t map fst . filter (f . snd)
19:03:44 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
19:03:45 <lambdabot>       arising from a use of `f' at <interactive>:1:18
19:03:45 <lambdabot>     Possible fix:
19:03:46 <hughfdjackson> augur: technical in terms of music theory, the ABRSM books are good
19:03:51 <jmcarthur> :t \f -> map fst . filter (f . snd)
19:03:52 <lambdabot> forall a b. (b -> Bool) -> [(a, b)] -> [a]
19:03:59 <hughfdjackson> erm, well, they'll give you a good grounding in the underlying theory at least
19:04:00 <companion_cube> learn you a chopin for great good
19:04:02 <kmc> :t map fst . filter (?f . snd)
19:04:02 <lambdabot> forall a b. (?f::b -> Bool) => [(a, b)] -> [a]
19:04:04 <cl1> coudl someone explain how this documentation has enough information for me to understand what Sum is? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t:Sum
19:04:04 <augur> hughfdjackson: will look!
19:04:16 <kmc> cl1, that's easy, it doesn't
19:04:18 <augur> companion_cube: haha yeah. im more of a bach person myself but chopin is good too :)
19:04:20 <hughfdjackson> they're a bit school-bookish ;)
19:04:58 <companion_cube> augur: so you're not romantic? :þ
19:05:01 <jmcarthur> "monoid under addition" isn't enough? is there more than one monoid under addition?
19:05:07 <kmc> cl1, but I can explain what it is anyway
19:05:23 <kmc> the top of that page says that monoids are "types with an associative binary operation that has an identity"
19:05:25 <cl1> kmc, if you would like. I will gladly listen
19:05:43 <_riba> (Btw, it's supposed to be a state transition table and I have to find the states that point to a certain state, while the numbers represent the names :/)
19:05:47 <Axman6> cl1: the Sum monoid uses (+) as mappend and 0 as mzero -- i think
19:05:48 <jmcarthur> oh i guess the issue is not know what to make of "monoid under addition"?
19:05:50 <Axman6> @src Monoid
19:05:50 <lambdabot> class Monoid a where
19:05:51 <lambdabot>     mempty  :: a
19:05:51 <lambdabot>     mappend :: a -> a -> a
19:05:51 <lambdabot>     mconcat :: [a] -> a
19:05:52 <augur> companion_cube: not at all
19:05:53 <kmc> _riba, maybe you want to use Data.Map instead?
19:05:54 <cl1> yes + is associative and 0 is the identity
19:05:56 <jmcarthur> *not knowing
19:06:00 <Axman6> mempty*
19:06:08 <kmc> cl1, ok, sounds like you understand it
19:06:12 <cl1> mempty is the identity and mappend is the associative operation
19:06:25 <kmc> cl1, thing is, any numeric type is a monoid with (0, (+)) *and* with (1, (*))
19:06:33 <companion_cube> augur: you must have done too much haskell, monads are like fugues
19:06:34 <jmcarthur> any?
19:06:42 <kmc> maybe not any...
19:06:46 <augur> companion_cube: yamt :(
19:06:55 <kmc> wouldn't the Num laws basically say as much
19:06:55 <companion_cube> ^^
19:07:05 <jmcarthur> what Num laws? :
19:07:05 <_riba> kmc: I can't change the structure, the matrix has to be a [[[a]]]
19:07:08 <jmcarthur> :\
19:07:09 <ion> > let avg (Sum x, Sum count) = x / count in avg . Data.Foldable.foldMap (\x -> (Sum x, Sum 1)) $ [5..42]
19:07:10 <lambdabot>   23.5
19:07:13 <roconnor> yay (String -> String) -> String
19:07:16 <kmc> cl1, anyway, rather than picking one of these arbitrarily to be the Monoid instance for Int, Float, etc
19:07:23 <kmc> they provide two wrapper types
19:07:27 <roconnor> I made a second-order function parameter
19:07:30 <dolio> Float actually isn't.
19:07:35 <dolio> Although I imagine there are instances.
19:07:49 <cl1> kmc: i'm looking at the source , this makes sense: instance Num a => Monoid (Sum a) where ...
19:07:55 <kmc> so Sum Integer is the integers with mempty = 0 and mappend = (+)
19:07:58 <jmcarthur> ah, i guess a certain amount of convention is assumed in the docs, too
19:08:05 <kmc> Product Integer is the integers with mempty = 1 and mappend = (*)
19:08:08 <cl1> it fails to mention in the simple explaination that a has to be Num
19:08:12 <jmcarthur> the convention of using newtypes to disambiguate instances
19:08:17 <kmc> yeah
19:08:20 <Axman6> @instances Monoid
19:08:20 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:08:24 <kmc> but you can see it in the "instances" section immediately below
19:08:24 <jmcarthur> the docs says that
19:08:26 <jmcarthur> Num a => Monoid (Sum a)
19:08:34 <ion> > let avg (Sum x, Sum count) = x / count; toAvg = Data.Foldable.foldMap (\x -> (Sum x, Sum 1)) in avg (toAvg [31..42] `mappend` toAvg [5..30])
19:08:35 <lambdabot>   23.5
19:08:40 <cl1> kmc, okay i see how to read that thing now
19:09:22 <cl1> jmcarthur, yes, i'm getting it .. slowly .. but i'm getting it
19:10:11 <Axman6> > mconcat $ map First [1..10]
19:10:12 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe a),
19:10:12 <lambdabot>                    GHC....
19:10:22 <Axman6> eh?
19:10:23 <cl1> so Sum derives Monoid and has the constraint that a be Num
19:10:25 <Axman6> :t First
19:10:26 <lambdabot> forall a. Maybe a -> First a
19:10:33 <Axman6> oh, hmm
19:10:51 <Axman6> > mconcat $ map (First.Just) [1..10]
19:10:52 <lambdabot>   Not in scope: data constructor `First.Just'
19:10:55 <kmc> cl1, doesn't derive
19:10:59 <ion> > foldMap (First . Just) [1..10]
19:11:00 <lambdabot>   Not in scope: `foldMap'
19:11:02 <Axman6> > mconcat $ map (First. Just) [1..10]
19:11:03 <lambdabot>   First {getFirst = Just 1}
19:11:05 <ion> > Data.Foldable.foldMap (First . Just) [1..10]
19:11:06 <lambdabot>   First {getFirst = Just 1}
19:11:10 <Axman6> > mconcat $ map (Last . Just) [1..10]
19:11:12 <lambdabot>   Last {getLast = Just 10}
19:11:14 <kmc> cl1, "derives" means you've asked the compiler to write the instance for you.  it's only possible for certain built-in classes
19:11:18 * hackagebot husk-scheme 3.4.4 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.4.4 (JustinEthier)
19:11:29 <ion> > ala' First foldMap Just [1..10]
19:11:29 <lambdabot>   Not in scope: `foldMap'
19:11:31 <jmcarthur> cl1: i hope i don't appear condescending
19:11:36 <ion> > ala' First Data.Foldable.foldMap Just [1..10]
19:11:37 <lambdabot>   Just 1
19:12:15 <cl1> jmcarthur, not at all, i have survived #c
19:12:20 <jmcarthur> ha!
19:12:40 <MiggyX> is Haskell well suited to creating fixed size binary "records" and writing them out to disk? Normally I'd do it in C but I'd like to give it a go in Haskell if I can :)
19:13:06 <ion> miggyx: Sure. See e.g. cereal.
19:13:08 <ion> @hackage cereal
19:13:08 <lambdabot> http://hackage.haskell.org/package/cereal
19:13:15 <MiggyX> ion: Thanks
19:13:16 <MiggyX> :)
19:13:24 <jmcarthur> MiggyX: compared to C it's sometimes a little more verbose, but not that bad
19:13:25 <kmc> 'binary' is a similar library
19:13:36 <cl1> so then Sum is an instance of Monoid?
19:13:40 <jmcarthur> yes
19:13:45 <cl1> this is all so meta
19:13:51 <kmc> instance Num a => Monoid (Sum a)
19:14:03 <ion> IIRC binary’s decode function throws an exception instead of returning Left x or something. :-(
19:14:05 <cl1> Sum is a type that is an instance of Monoid, got it
19:14:09 <kmc> no
19:14:12 <kmc> Sum Int, Sum Integer, Sum Float, etc are all instances of Monoid
19:14:15 <Axman6> what that says is that Sum a is an instance of Monoid, only if a is a Num
19:14:22 <MiggyX> jmcarthur: I'll trade verbose for "clearer code" :)
19:14:32 <kmc> Sum itself can't be; it has the wrong kind
19:14:48 <kmc> it's a 1-argument type constructor, and instances of Monoid are types, not type constructors
19:14:51 <jmcarthur> yeah we have that part down, although an argument can be made that verbosity can make code less clear
19:15:20 <jmcarthur> in fact, we haskellers make that argument a lot...
19:15:43 <cl1> so then what is Sum?
19:15:48 <cl1> it has to be something
19:15:50 <kmc> a type constructor
19:15:56 <cl1> okay
19:16:08 <kmc> it's a type constructor because Sum Integer, Sum Bool, etc. are all types
19:16:12 <kmc> but Sum itself isn't
19:16:15 <cl1> a type constructor that can create types that are instances of monoid?
19:16:20 <ion> A type-level function that takes a type as a parameter.
19:16:21 <kmc> you can't have a value of type Sum, just like you can't have a value of type Maybe
19:16:22 <Axman6> you apply Sum to another type to get a type:
19:16:28 <Axman6> @kind Sum
19:16:29 <lambdabot>     Ambiguous occurrence `Sum'
19:16:29 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
19:16:29 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
19:16:33 <Axman6> -_-
19:16:36 <Axman6> usuk
19:16:43 <ion> @kind Data.Monoid.Sum
19:16:43 <lambdabot> * -> *
19:16:44 <cl1> @kind Control.Monad.Sum
19:16:45 <lambdabot>     Not in scope: type constructor or class `Control.Monad.Sum'
19:17:00 <Axman6> @kind Data.Monoid.Sum Int
19:17:01 <lambdabot> *
19:17:11 <kmc> cl1, right, (Sum a) is an instance of Monoid if 'a' is an instance of Num
19:17:13 <kmc> instance Num a => Monoid (Sum a)
19:17:20 <cl1> so Sum is a type constructor that takes one argument (which is a concrete type) and creates a new type
19:17:25 <kmc> yes
19:17:33 <kmc> not really "creates", just "is"
19:17:35 <kmc> but sure
19:17:39 <Axman6> he's got it!
19:17:45 <cl1> so its like a function that creates types
19:17:49 <kmc> yes
19:17:53 <kmc> it's like a function at type level
19:17:58 <kmc> are you familiar with Maybe?
19:17:58 <ion> Let’s talk about him as if he’s not here! Yay!
19:18:00 <jmcarthur> cl1: and furthermore, *sometimes* the resulting type is an instance of Monoid
19:18:07 <Axman6> cl1: there's a reason for the similat syntax for kinds and types
19:18:12 <Axman6> @kind Data.Monoid.Sum
19:18:12 <lambdabot> * -> *
19:18:18 <Axman6> :t Just
19:18:19 <lambdabot> forall a. a -> Maybe a
19:18:39 <cl1> jmcarthur, when a is of type Num, only then is Sum a Monoid?
19:18:52 <kmc> not "a is of type Num"
19:18:52 <cl1> i think this is starting to sink in
19:18:54 <ion> when a is an instance of Num
19:18:56 <jmcarthur> when a is an instance of Num
19:18:56 <kmc> "a is an instance of the Num type class"
19:19:10 <kmc> a could be Integer, Int, Float, etc.
19:19:13 <Axman6> @qupte stereo
19:19:13 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
19:19:14 <cl1> okay
19:19:23 <Axman6> <3 lambdabot
19:19:32 <Axman6> where's the stereo wuote gone :(
19:19:37 <Axman6> kbd.LSDNFv.kjzdfvcn
19:19:39 <_riba> I'm confused. How do I access the list I'm working with now? I have to check if the !!s element of the list equals val, that is my argument for filter. But the !!s of what?
19:19:40 <ion> Now i want to know what the stereo quote was.
19:19:46 <cl1> does haskell not have the concept of inheritance?
19:19:49 <jmcarthur> nope
19:19:56 <kmc> not really, no
19:19:59 <cl1> covariance and contravariance?
19:20:15 <kmc> it doesn't have subtyping
19:20:21 <kmc> so it doesn't have covariant and contravariant subtyping
19:20:26 <cl1> okay
19:20:28 <kmc> but similar ideas come up in other contexts
19:20:34 <jmcarthur> covariance and contravariance are things we can talk about, but aren't really a part of the language
19:20:34 <cl1> but it has polymorphism
19:20:38 <kmc> yes
19:20:39 <kmc> for example there's this typeclass Functor
19:20:49 <jmcarthur> however, it has a different kind of polymorphism than, say, java
19:20:52 <kmc> class Functor f where { fmap :: (a -> b) -> (f a -> f b) }
19:20:59 <kmc> standard typeclass
19:21:02 <jmcarthur> well, java generics gets close
19:21:04 <kmc> but you could also define one like this:
19:21:13 <cl1> i'm all ears for this explaination of polymorphism
19:21:15 <kmc> class ContraFunctor f where { cofmap :: (a -> b) -> (f b -> f a) }
19:21:15 <jmcarthur> but then type classes change everything in some ways
19:21:34 <kmc> in which case you would say that Functor represents "covariant functors" and ContraFunctor represents "contravariant functors"
19:22:14 <ion> cl1: Well, you’ve already seen some of it. The definition of the “Sum a” monoid instance uses (+) on anything that’s an instance of Num.
19:22:28 <jmcarthur> cl1: one exercise is to think about how you would express the type of addition in the style of haskell in a java-like language
19:22:30 <jmcarthur> :T (+)
19:22:34 <jmcarthur> :t (+)
19:22:34 <cl1> but Int doesn't inherit from Num
19:22:35 <lambdabot> forall a. (Num a) => a -> a -> a
19:22:43 <kmc> "inherit" is still the wrong word
19:22:51 <kmc> Int is a type; Num is a type class
19:22:56 <kmc> they are different kinds of things
19:23:03 <cl1> kmc: OOOOHHHH
19:23:18 <ion> Type :i Num in ghci.
19:23:44 <cl1> am i just being dense, or is it really this difficult to understand (mind you i'm on day 4 of haskell )
19:24:03 <ion> The type class defines, among other things, function names and signatures any instances must implement and potentially default implementations.
19:24:09 <kmc> it's simple once you understand it...
19:24:10 <jmcarthur> cl1: it's very different from other languages
19:24:17 <cl1> so Int is an instance of Num
19:24:20 <kmc> the concepts are simple, there are not many things to learn
19:24:25 <kmc> but they are difficult, abstract things
19:24:31 <kmc> it is common to have great difficulty starting out
19:24:40 <kmc> what book(s) are you reading?
19:25:13 <cl1> i'm reading the learn you a haskell tutorial, i'm on monads right now
19:25:22 <jmcarthur> the usual progression of a haskell programmer is a long series of "aha" moments, each time thinking he finally gets it only to discover later that he didn't get it before, but of course has gotten it now
19:25:22 <Axman6> cl1: people hate me saying this, but classes in Haskell are usually closer to interfaces in languages like java. they define  a bunch of functions and values that types can implement to be instances of that class
19:25:35 <ski> cl1 : see "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli in 1985 at <http://www.cse.ohio-state.edu/~neelam/courses/788/cardelli85understanding.pdf> for a discussion of different kinds of polymorphism (see 1.3)
19:25:42 <kmc> cl1, ok, you definitely need to understand polymorphism and type classes before you can understand monads
19:25:45 <jmcarthur> and each time you grow more positive about yourself until you have deluded yourself into thinking you have learned all there is to know, at which point you stop learning
19:25:51 <_riba> Why does Haskell think I want to use flip in the expression ((!!s) == val)?
19:25:57 <xplat> jmcarthur: so basically like life
19:26:09 <cl1> for background, i have 13 years of programming experiance, i have used javascript (in its proper prototyping form), c, ada, c#, prolog
19:26:15 <kmc> 'cause Monad is a type class declaring some polymorphic functions
19:26:20 <jmcarthur> xplat: pretty much
19:26:26 <kmc> cl1, you asked about polymorphism in Haskell
19:26:28 <ion> riba: Think of the type of (!!s) and the type of val. Are they the same?
19:26:32 <kmc> it doesn't necessarily involve type classes
19:26:37 <kmc> a simple example is map
19:26:44 <jmcarthur> cl1: the more programming background you have, the harder this can be
19:26:44 <kmc> map :: (a -> b) -> ([a] -> [b])
19:26:57 <xplat> basic polymorphism in haskell resembles generics in c#
19:27:00 <kmc> map takes a function, and returns a function on lists
19:27:08 <kmc> it doesn't care what the type of elements of the list are
19:27:16 <cl1> kmc, yes, you asked what I was reading ( i thought some context around taht woulld help others help me)
19:27:17 <kmc> so long as it is compatible with the function it was passed
19:27:19 <Axman6> _riba: you're asking whether the function (!!s) is equal to a value, you almost certainly do not want to do that
19:27:44 <xplat> type classes don't really resemble any of those things much, except that the way the constraints are resolved is a little like how a program runs in prolog
19:27:48 <Axman6> since there is no proper way to do function equality in haskell (or pretty much any language for that matter)
19:27:49 <kmc> cl1, so 'map' is a polymorphic function
19:27:53 <cl1> i see
19:27:54 <kmc> you can use it at many different concrete types
19:27:59 <_riba> No, I don't. But how do I "access" the list I'm currently working on?
19:28:02 <kmc> map :: (Int -> Char) -> ([Int] -> [Char])
19:28:10 <kmc> map :: (Bool -> Bool) -> ([Bool] -> [Bool])
19:28:12 <ski> cl1 : note that Haskell has *parametric* polymorphism, but not *inclusion* polymorphism (subtyping)
19:28:22 <ion> printf ("%d\n", printf == exit);
19:28:27 <kmc> map :: (Int -> (Int -> Int)) -> ([Int] -> [Int -> Int])
19:28:32 <Axman6> _riba: we'd need more context on what you're trying to do, because the sentense doesn't make much sense.
19:28:45 <cl1> ski: note made
19:28:50 <kmc> cl1, now, if you wanted to sum the elements of a list, you might imagine a type like this:
19:28:53 <_riba> ion: I was pretty sure I'm not using the !! correctly, but the error message containing flip didn't help :D
19:28:54 <kmc> sum :: [a] -> a
19:28:59 <xplat> usually in OO languages people talk only about inclusion polymorphism when they use the word
19:29:01 <kmc> and sure enough, sum :: [Int] -> Int makes sense
19:29:06 <kmc> and so does sum :: [Double] -> Double
19:29:10 <ion> @type map `asTypeIn` \map -> map undefined (undefined :: [Integer])
19:29:11 <lambdabot> forall b. (Integer -> b) -> [Integer] -> [b]
19:29:18 <kmc> but not sum :: [Char] -> Char, or sum :: [Bool -> Bool] -> (Bool -> Bool)
19:29:23 <ion> @type map `asTypeIn` \map -> map (undefined :: Integer -> String)
19:29:23 <lambdabot> (Integer -> String) -> [Integer] -> [String]
19:29:34 <xplat> but that's something you just don't have at all in haskell
19:29:36 <kmc> so instead you write:  sum :: (Num a) => [a] -> a
19:29:43 <kmc> which constrains the type 'a' to be a numeric type
19:29:51 <hpaste> “_riba” pasted “?” at http://hpaste.org/55442
19:30:00 <kmc> formally, the type 'a' must be an instance of the Num type class
19:30:11 <kmc> anyway you probably saw some of this in lyah
19:30:21 <_riba> Axman6, I pasted my code
19:30:26 <ion> riba: filter (\x -> …) xs
19:30:50 <cl1> so where i'm used to inheritence, haskell has instances of type classes. I realize they aren't the same, but that is as close as the two concepts get in relation to those things
19:30:57 <ion> > filter (\x -> odd x) [0..]
19:30:58 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
19:31:03 <kmc> cl1, they're not very close
19:31:12 <cl1> i know
19:31:14 <ybit> win 10
19:31:30 <kmc> i think the analogy between them will not help you
19:31:36 <cl1> i need a smoke break to let some of this sink in, brb
19:31:37 <ion> > let filter' f = fmap fst . filter (f . snd) in filter' (\x -> odd x) . zip ['a'..] $ [0..]
19:31:38 <lambdabot>   "bdfhjlnprtvxz|~\128\130\132\134\136\138\140\142\144\146\148\150\152\154\15...
19:31:44 <kmc> the analogy between type classes and Java interfaces might help, but it's not that great either
19:31:53 <ion> ybit: lose 11
19:32:00 <xplat> thinking things like 'i would use inheritance in c#, so i will use a typeclass in haskell' will just lead you astray
19:32:17 <ski> cl1 : to the extent that type classes resemble Java interfaces (or abstract base classes), there is (interface) (multiple) inheritance in the sense that one type class may be a subclass of some other type classes
19:32:30 <_riba> ion: Sorry, I don't get what you are trying to tell me. I don't know how to express the condition, and now I'm not even sure if this works the way I want
19:32:33 <cl1> i'm not making an analogy, i've come to the conclusion that making that analogy is what has made this so confusing, because, from my point of view as an OO programmer, that's what the Num/Int relationship looks like on the surface.
19:32:43 <Axman6> _riba: split it out a bit. define a function p :: a -> Bool, where a is the type of whatever you're trying to filter
19:32:51 <kmc> cool
19:32:52 <kmc> cl1, following on what xplat said, beginners to Haskell tend to massively over-use type classes
19:32:55 <xplat> cl1: ah, yes, you're right that that is the source of your confusion
19:33:09 <kmc> because they see "class" and "instance" and it looks kinda familiar
19:33:22 <cl1> now for that smoke break. brb
19:33:29 <ski> cl1 : from the point of Haskell. Java confuses things by treating an interface (or an abstract base class) as more or less the same kind of things as a concrete class (which can be instantiated)
19:33:30 <_riba> I want to know if the element of the list I'm currently looking at equals "val"
19:33:40 <Axman6> kmc: well, they also get visions od grandure and try to implement things that can easily be extended by others
19:33:43 <kmc> whereas the core FP ideas -- functions and stuff made from functions -- are so simple you'd never notice them
19:34:41 <ski> cl1 : also, the fact that type classes can have multiple type parameters, or can have methods which only mention the type parameter in the result type, makes them less similar to interfaces
19:34:42 <kmc> there is also a more specific problem
19:34:56 <kmc> which is that low-abstraction OOP languages require you to define new types for each new behavior
19:35:14 <kmc> Haskell does not; neither do good OOP languages
19:35:31 <Goosey> Has anyone used haltavista here?
19:35:37 <kmc> a behavior is just a function so it's just a value
19:35:49 <ion> What next? Hing?
19:35:50 <ybit> ion: hmm?
19:35:59 <ybit> oh hah
19:36:11 <xplat> haltavista sounds like a halting oracle
19:36:18 <kmc> haskjeeves
19:36:23 <xplat> heaves
19:37:35 <_riba> hahoo?
19:37:39 <Axman6> damn, why don't we have haskjeevs
19:37:42 <kmc> we already have hayoo
19:37:53 <Axman6> e*
19:39:35 <_riba> what the hell
19:39:36 <cl1> back
19:40:01 <_riba> What type is _64 supposed to be?
19:40:39 <kmc> where?
19:40:48 <kmc> wb cl1
19:41:07 * ski suspects it's possibly an uninstantiated type variable, presumably in a type error
19:41:37 <cl1> generics seem more closely related to instances of types than inheritence
19:41:47 <ion> Now the channel stinks like tobacco.
19:41:53 <cl1> sorry
19:41:56 <cl1> >_>
19:41:59 <cl1> <_<
19:42:07 <kmc> technically cl1 did not specify that they were smoking *tobacco*
19:42:22 <ion> True
19:42:28 * ski imagines cl1 smoking fish
19:42:43 <Axman6> omnomnom
19:43:06 <hpaste> “_riba” annotated “?” with “_64?” at http://hpaste.org/55442#a55443
19:43:25 <kmc> _riba, are you using Hugs?
19:43:35 <_riba> Yes
19:43:41 <kmc> oh, strange
19:43:53 <_riba> I heard it's outdated, but we have to use it
19:43:57 <kmc> *nod*
19:44:11 <cl1> class Smoke a where inhale :: a -> b
19:44:30 <Axman6> obviouslky you never return when you smoke
19:44:41 <ion> The “b” isn’t very useful.
19:45:24 <xplat> hogpile, hexcite, allthehs, galax\, \ycos, gigahask, halexa internet, hsjunkie, hshunt, hamatomu, hsphere, kompasstypes, \exis hexis, haskmenow, endecurry, hexalead, hsarepoint, SAP trexx, homgili, heurekster, hazap, hamalo, trexxy, hink, haccoona, a\\eba, hoo, \andex, ...
19:45:24 <kmc> _riba, in a sense it's not outdated -- it bills itself as an interpreter for standard Haskell 98, and it is still that
19:45:40 <MiggyX> hi guys, I've been trying to parse a simple time in ghci with :    readTime defaultTimeLocale "%H:%M:%S"  "12:30:00"       but no matter what I try, I always get "ambiguous type variable t0 in constraint". I've tried various examples but all give similar results so I figure I'm just doing something dumb… any hints?
19:45:58 <ski> _riba : what is the error message ?
19:45:58 <kmc> but if you want good performance, lots of libraries, or language extensions, it's not the best
19:46:05 <kmc> (however Hugs does have a few extensions which aren't in GHC!)
19:46:23 <ski> (restricted type synonyms,Trex !)
19:46:54 <_riba> ski: I included the error message in the code
19:47:04 <Axman6> MiggyX: have you specified what type you want to return?
19:47:14 <xplat> restricted type synonyms?  what is that, they add a constraint on the argument when you use them?
19:47:40 <kmc> xplat, things which are synonyms over a limited set of declarations, and are opaque types elsewhere
19:47:43 <MiggyX> Axman6: I guess not - I'm using the standard parseTime function
19:47:49 <kmc> it gives another way to do abstract data types
19:47:54 <kmc> http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html
19:48:03 <ski> xplat : Trex <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.2>, restricted type synonyms <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5>
19:48:05 <Axman6> @hoogle parseTime
19:48:05 <lambdabot> Data.Time.Format class ParseTime t
19:48:05 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
19:48:06 <xplat> kmc: kind of reminds me of agda's abstract blocks
19:48:10 <kmc> yeah
19:48:22 <Axman6> MiggyX: you need to tell it what instance of ParseTime you want to return
19:48:27 <xplat> oh, i know about trex, it was an awesome extension, especially for the time
19:48:39 <Axman6> @instances-importing Data.Time.Format.ParseTime
19:48:40 <lambdabot> Couldn't find class `Data.Time.Format.ParseTime'. Try @instances-importing
19:48:43 <Axman6> :(
19:48:48 <ski> the MLs also support this way of hiding that a type synonym is actually that, making it look like any old abstract type
19:48:50 <Axman6> @instances-importing Data.Time.Format ParseTime
19:49:37 <ski> re this, i think there should possibly be a way to `DEPRECATE' that a type is a type synonym (so uses of it which requires not treating it abstractly would get the warning)
19:49:57 <_riba> So no idea why I get that error message?
19:50:30 <ski> _riba : sorry, didn't notice the code until now
19:50:39 <xplat> as long as you plan ahead (yeah, easier said than done) restricted synonyms are basically covered by newtypes with hidden constructors
19:50:43 <Goosey> For some reason, darcs get http://www.code.haskell.org/haskell-src-exts doesn't work
19:51:07 <xplat> a bit more overhead, though
19:51:09 <Axman6> try removing the www.
19:51:41 <ski> _riba : i think `_64' there really means "some type", which it hasn't exactly determined yet
19:51:49 <Goosey> Axman6: There we go...>_<
19:51:49 <xplat> but the standard-conforming substitute for trex is ... HList O_o
19:52:30 <ski> _riba : anyway, the problem is that the `a' in the type of `p' really needs to be the same as the `a' in the type of `predecessors', but as you have written it, those two are separate
19:52:42 <xplat> well, there are a couple of others now, but
19:52:59 <_riba> ski: How do I fix it?
19:53:12 <ski> _riba : you can fix this by changing the pattern `val' into `(val :: a)', to bring the type variable `a' in scope in the body of `predecessors' (including the `where' clause, with the type signature for `p')
19:53:39 <ski> _riba : note that this uses the <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.3> extension to hugs, so you need to start hugs using the `-98' option to enable extensions
19:54:07 <ski> _riba : an alternative way to fix the problem here is just to remove the type signature on `p' (which will then infer it correctly)
19:54:48 <ski> _riba : btw, i don't think you need to have the `Eq a => ' constraint in the type signature of `p' -- you can probably remove it
19:54:58 <ski> (maybe it will even complain if you don't, i'm not sure)
19:55:35 <_riba> Thanks a lot, it seems to work! Now I just have to fix another error :/
19:55:43 <ski> (you don't need to have `Eq a' there since if you're using the pattern `(val :: a)' as i suggested, you're reusing the `a' from the outer declaration, which already has assumed `Eq a')
19:56:12 <_riba> Apparently I'm working on [[a]] here, and I'm not sure why
19:57:21 <ion> Add type annotations to all definitions.
19:58:43 <Sgeo> @hoogle (Eq a) => a -> a -> [a] -> [a]
19:58:43 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
19:58:43 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
19:58:43 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
19:59:04 <Sgeo> The function I want is in Network.CGI.Protocol why, exactly?
20:00:19 <_riba> ion: What do you mean?
20:01:15 <ion> riba: Add the type signatures you expect to all bindings. That might make the error messages more useful.
20:01:41 <ski> (_riba : btw, in case it wasn't clear : you only need the extension if you want a type signature on `p' here -- inferring it will not require an extension (and the same would be true re the corresponding thing in GHC))
20:04:11 <_riba> ski, I followed your second advice and simply got rid of the type signature
20:04:40 <_riba> ion: Thanks, I'll try and see if that helps.
20:04:45 <Axman6> :t foldM
20:04:46 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:05:44 <Axman6> :t any undefined . foldM undefined undefined
20:05:45 <lambdabot> forall b. [b] -> Bool
20:06:06 <ski> _riba : yeah, in this case, that seems unproblematic -- in some cases such local type signatures can really help document the code, though, so it's useful to be aware of this fix
20:06:10 <shachaf> @ty undefined undefined . undefined undefined undefined (undefined undefined)
20:06:11 <lambdabot> forall b (f :: * -> *). (Functor f) => f b
20:06:35 <ion> @type undefined undefined `undefined` undefined undefined undefined (undefined undefined)
20:06:36 <lambdabot> forall t. t
20:06:48 <Axman6> this is pretty cool: https://github.com/leonidas/codeblog/blob/master/2011/2011-12-18-haskell-nfa.md
20:07:47 <ion> @type \undefined -> undefined undefined `undefined` undefined undefined undefined (undefined undefined)
20:07:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:07:48 <lambdabot>     Probable cause: `undefined' is applied to too many arguments
20:07:48 <lambdabot>     In the first argument of `undefined', namely `undefined undefined'
20:07:59 <ski> @type undefined `asTypeIn` \undefimed -> undefined undefined `undefimed` undefined undefined undefined (undefined undefined)
20:08:00 <lambdabot> forall t t1 b. t -> t1 -> b
20:08:15 <shachaf> Ah, good old undefimed.
20:09:21 <_riba> Sigh, I give up :(
20:09:48 * shachaf wonders what _riba is giving up on.
20:11:23 <_riba> On trying to get the possible predecessors of a state out of a transition table which is a [[[a]]] (
20:25:03 <xplat> > let buffalo :: a; buffalo = undefined in buffalo buffalo buffalo `buffalo` buffalo buffalo buffalo
20:25:03 <lambdabot>   *Exception: Prelude.undefined
20:44:45 <hoob> is anyone here?
20:45:34 <drdo> nop, all alone :(
20:47:41 <_riba> I'm awake!
20:47:45 <MiggyX> hmm, how do you implement a counter in Haskell?
20:47:57 <otters> counter of what
20:48:13 <MiggyX> otters: just a simple integer counter from 0,1,2,3..
20:48:18 <Cale> [0..]
20:48:19 <kmc> MiggyX, make a recursive function f n = ..., which calls itself as f (n+1)
20:48:21 <Cale> > [0..]
20:48:21 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:48:36 <hoob> help! how do i write [Word8] to a file?
20:48:46 <kmc> in what format
20:48:48 <kmc> raw bytes?
20:49:06 <hoob> yes raw bytes
20:49:06 <kmc> use Data.ByteString
20:49:10 <kmc> pack the [Word8] to get a ByteString and then use ByteString IO
20:49:29 <ion> Data.ByteString.hPut h . Data.ByteString.pack
20:49:30 <MiggyX> kmc: it's reading lines from a text file and I need to assign a line number to each one...
20:49:42 <hoob> okay let me try that, thanks kmc
20:49:51 <_riba> MiggyX: zip [0..] ?
20:49:52 <kmc> do { xs <- whatever_to_get_lines;  return (zip [0..] xs) }
20:49:58 <kmc> > zip [0..] "like this MiggyX"
20:49:59 <lambdabot>   [(0,'l'),(1,'i'),(2,'k'),(3,'e'),(4,' '),(5,'t'),(6,'h'),(7,'i'),(8,'s'),(9...
20:50:01 <ion> > zip [0..] . lines $ "o hai\nfoo bar\nbaz quux"
20:50:02 <lambdabot>   [(0,"o hai"),(1,"foo bar"),(2,"baz quux")]
20:50:23 <kmc> MiggyX, "how do you implement a counter" is the wrong question; you've accepted as a foregone conclusion that the problem needs mutable state
20:50:48 <MiggyX> kmc: true enough - still trying to change the old mind set :)
20:51:17 <Axman6> banish the mutation from your soul!
20:51:28 <Axman6> feel the glow of the lambda!
20:51:48 <MiggyX> Axman6: lol working on it - though so far I have been less than successful :) I'll get there hopefully though
20:51:57 <kmc> i think it's better to ask practical questions like "how do I assign a line number to each line" and not "how do i emulate imperative construct X"
20:52:24 <kmc> Haskell has full support for imperative programming; the radical thing is that it also has good support for non-imperative programming :)
20:53:35 <MiggyX> kmc: Ultimately I want to read in a line, convert it to a different format, (i.e. a smaller binary format) then write it out to disk.  I'd normally write it in C but I'm trying to write it in Haskell - a real project that will help change the mind set :)
20:53:46 <kmc> *nod*
20:53:58 <shachaf> Imperative statements are also first-class in Haskell, unlike in most imperative languages. :-)
20:54:44 <kmc> i would break that down as: an IO action to read lines; a function to turn a line into some Haskell datatype; a function to turn one of those into a ByteString; an IO action to write those ByteStrings into a file
20:54:55 <kmc> (having only thought about it for a second)
20:55:02 <kmc> (so there might be a better way)
20:55:44 <MiggyX> kmc: That was the way I had in mind - so at least I'm not too far off on the grand scheme of things - just need to learn how to actually put it into practice :)
20:56:21 <kmc> cool :)
20:57:47 <MiggyX> I think the code would look nice and clean in Haskell and it fits in with my usability research.
20:58:10 <MiggyX> but thankfully there are helpful people about :)
20:58:19 <_riba> I'm really stupid :/
20:58:21 <_riba> [19.12.2011-04:24:35] <kmc> > let find2 f = fmap fst . find (f . snd) in find2 (< 7) [('x', 9), ('y', 3), ('z', 8)]
20:59:17 <_riba> I didn't realise this is not what I need
20:59:26 <_riba> Of course it's not going to work :/
21:00:08 <_riba> Sigh...
21:00:52 <_riba> Not being able to think straight because I'm tired, but I have to get it done :|
21:02:04 <kmc> what do you need?
21:04:59 <_riba> Instead of the numbers in your example I have a list of lists of numbers, and I have to check each of those at the same index
21:06:46 <salisbury> is there a way to partially apply the 'second' parameter of a function
21:07:01 <salisbury> before applying the 'first', that is
21:07:03 <kmc> :t Prelude.flip
21:07:03 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:07:15 <salisbury> ahh, thanks
21:07:16 <kmc> > let f = flip map [1,2,3]  in  f succ
21:07:18 <lambdabot>   [2,3,4]
21:08:07 <kmc> :t let find2 i j f = fmap fst . find (f . (!! j) . (!! i) . snd) in find2
21:08:08 <lambdabot> forall a a1. Int -> Int -> (a -> Bool) -> [(a1, [[a]])] -> Maybe a1
21:08:16 <kmc> ^^^ _riba
21:09:13 <_riba> I'm not yet sure what that does, but as I need all fitting elements, "find" seems wrong
21:09:20 <xplat> filter
21:09:48 <kmc> :t let filter2 i j f = map fst . filter (f . (!! j) . (!! i) . snd) in filter2
21:09:49 <lambdabot> forall a a1. Int -> Int -> (a -> Bool) -> [(a1, [[a]])] -> [a1]
21:09:55 <kmc> (we did go through the find -> filter transition before)
21:10:47 <kmc> (filter2 i j f) takes a list of type like  [ ( b, [[a]] ) ],  and returns the list of b's where the (i,j)th element of that [[a]] satisfies the predicate f
21:11:11 <kmc> that's my current best understanding of the function you wanted
21:11:19 <kmc> and i can explain how it works if you like
21:13:20 <_riba> The i-th list has to contain a specific value, there should be no j
21:15:45 <_riba> I'm sorry I'm asking so many probably stupid questions, but my assignments got a lot more difficult all of a sudden and I can't really handle them :/
21:15:51 <kmc> ok
21:16:00 <kmc> well i'll explain how it works, and then you can tweak it
21:16:30 <cl1> _riba, if you had seen some of the stuff i've been asking you wouldn't say that
21:16:46 <kmc> so firstly we can expand it as
21:16:53 <kmc> filter2 i j f xs = map fst (filter (f . (!! j) . (!! i) . snd) xs)
21:17:20 <kmc> do you know about the (.) operator?
21:17:42 <_riba> I think I do
21:17:49 <_riba> cl1: I'm not so sure ;)
21:17:49 <kmc> (f . g) x = f (g x)
21:17:52 <kmc> function composition
21:18:10 <kmc> anyway, look at this sub-part:  filter (f . (!! j) . (!! i) . snd) xs
21:18:37 <kmc> filter is taking a list of type [ ( b, [[a]] ) ]
21:18:54 <kmc> therefore,  (f . (!! j) . (!! i) . snd) :: (b, [[a]]) -> Bool
21:19:00 <_riba> I'm taking the second element of my tuple at the i-th index, and then that list at the j-th index?
21:19:09 <kmc> yeah
21:19:14 <kmc> it's like a pipeline, read right to left
21:19:35 <kmc> take the second element of the pair, then the i'th element of that list, then the j'th element of that, then apply f to get a Bool
21:19:54 <kmc> anyway filter returns that same type  [ ( b, [[a]] ) ]
21:19:55 <kmc> :t filter
21:19:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:20:13 <kmc> so then we apply 'map fst' to get [b]
21:21:06 <_riba> Oh, yes, of course :/
21:21:34 <xplat> that might read easier as a list comprehension
21:22:31 <_riba> And since elem works on Eq, I guess I can simply use that to check if my list contains the value
21:23:04 <_riba> map fst (filter (f . (elem val) . (!! i) . snd) xs)
21:23:14 <_riba> Is that correct?
21:23:56 <xplat> what happened to j?
21:23:58 <Axman6> :t \xs -> map fst (filter (f . (elem val) . (!! i) . snd) xs)
21:23:59 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
21:23:59 <lambdabot>     In the second argument of `(!!)', namely `i'
21:23:59 <lambdabot>     In the first argument of `(.)', namely `(!! i)'
21:24:10 <Axman6> :t \i j xs -> map fst (filter (f . (elem val) . (!! i) . snd) xs)
21:24:11 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
21:24:11 <lambdabot>       arising from a use of `f' at <interactive>:1:28
21:24:11 <lambdabot>     Possible fix:
21:24:21 <Axman6> :t \f i j xs -> map fst (filter (f . (elem val) . (!! i) . snd) xs)
21:24:21 <lambdabot> forall t a a1. (Bool -> Bool) -> Int -> t -> [(a, [[Dif a1 -> a1]])] -> [a]
21:26:04 <_riba> xplat: I don't need that, I just need to know if that list contains the value I need, the index doesn't matter
21:26:30 <_riba> So I tried elem
21:28:49 <tsanhwa> @pl \a -> (f a, g a)
21:28:49 <lambdabot> liftM2 (,) f g
21:29:19 <xplat> _riba: well, it's probably right then
21:29:34 <tsanhwa> @hg liftM2
21:29:34 <lambdabot> Maybe you meant: . ? @ bf bug do ft ghc id msg pl rc thx v wn
21:29:46 <xplat> :t \f i val xs -> map fst (filter (f . (elem val) . (!! i) . snd) xs)
21:29:47 <lambdabot> forall a a1. (Eq a1) => (Bool -> Bool) -> Int -> a1 -> [(a, [[a1]])] -> [a]
21:29:54 <tsanhwa> :t liftM2
21:29:55 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:30:04 <xplat> er, f is redundant
21:30:09 <ion> Also, f &&& g
21:30:21 <tsanhwa> :t (&&&)
21:30:22 <xplat> :t \i val xs -> map fst (filter (elem val . (!! i) . snd) xs)
21:30:22 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:30:23 <lambdabot> forall a a1. (Eq a1) => Int -> a1 -> [(a, [[a1]])] -> [a]
21:30:23 <_riba> Yeah, I just noticed
21:30:58 <kmc> yeah, xplat is right that it might be nicer as a list comprehension
21:31:00 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
21:31:01 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
21:31:32 <ion> @type liftA2 (,)
21:31:32 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
21:31:43 <ion> @type liftA2 (,) `asAppliedTo` (undefined :: a -> b)
21:31:43 <lambdabot> forall a b a1. (a1 -> a) -> (a1 -> b) -> a1 -> (a, b)
21:31:47 <kmc> filter2 i j f xs = [ k  |  (k,v) <- xs, f (v !! j !! i) ]
21:33:16 <xplat> :t \i val xs -> [ k | (k,v) <- xs, val `elem` (v !! i) ]
21:33:17 <lambdabot> forall t a. (Eq a) => Int -> a -> [(t, [[a]])] -> [t]
21:33:31 <_riba> holy shit it works
21:33:45 <_riba> Thanks for all your help
21:34:22 <_riba> To think this was just a auxiliary function... :(
21:34:25 <_riba> *an
21:52:58 <Lemon> @pl \x -> maybe (f2 x) Just (f1 x)
21:52:59 <lambdabot> ap (flip maybe Just . f2) f1
21:53:12 <Lemon> there's got to be a better way
21:53:34 <Lemon> @pl \x -> case f1 x of {Nothing -> f2 x; Just y -> Just y}
21:53:34 <lambdabot> (line 1, column 20):
21:53:35 <lambdabot> unexpected "{"
21:53:35 <lambdabot> expecting variable, "(", operator or end of input
21:55:41 <Lemon> :t ap
21:55:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:55:56 <cl1> :k Data.Monoid.Sum
21:55:57 <lambdabot> * -> *
21:56:05 <cl1> :k Prelude.Functor
21:56:06 <lambdabot>     Class `Functor' used as a type
21:56:06 <lambdabot>     In the type `Functor'
21:56:29 <cl1> :k Prelude.Functor IO
21:56:30 <lambdabot>     Class `Functor' used as a type
21:56:30 <lambdabot>     In the type `Functor IO'
21:56:53 <cl1> how do I write something with Functor to produce something that i can use with :kind?
21:57:14 <shachaf> cl1: Functor has instances of kind (* -> *)
21:57:18 <shachaf> I wonder if a language that just didn't have type classes would be better as an introductory language than Haskell.
21:57:28 <shachaf> Maybe type classes should be considered an "advanced feature".
21:57:29 <kmc> the authors of Helium wondered that too :)
21:57:33 <cl1> so then functor is of kind * -> (* -> *) ?
21:57:44 <shachaf> Perhaps they cause more confusion than they're worth
21:57:44 <kmc> no
21:57:48 <kmc> cl1, it's a type class
21:57:51 <shachaf> cl1: No. Functor doesn't have a kind.
21:57:56 <cl1> okay
21:57:58 <kmc> you can't ask for the kind of a type class in any released version of GHC
21:58:17 <kmc> in GHC 7.4 it will say:   Functor :: (* -> *) -> Constraint
22:03:53 <kmc> if you had «Functor :: (* -> *) -> *» that would imply that «Functor Maybe» is a type and can be used in data structures
22:04:01 <kmc> when really it's a constraint on types, and can only be used to the left of =>
22:05:01 <Lemon> so what IF it were a type?
22:05:13 <Lemon> would that buy us named instances in one go?
22:05:23 <kmc> i think that's something of an open question
22:05:27 <Lemon> some_functor_instance = blah blah blah
22:05:38 <Lemon> some_functor_instance :: Functor SomeType
22:05:48 <dmwit> > 6 * 5 * 4 * 3 * 2
22:05:49 <lambdabot>   720
22:05:52 <rwbarton> You can already define your own "named instances" using records.
22:06:04 <rwbarton> they just don't relate to the type class system
22:06:09 <dmwit> > 8 * 7 * 720
22:06:10 <lambdabot>   40320
22:06:26 <kmc> yeah, in some sense any function of type (a -> b) -> (T a -> T b) is a "named instance" of Functor
22:07:02 <kmc> the meaning I would assign to making it a type is that you could pass evidence of typeclass-membership as a runtime value
22:07:05 <copumpkin> chances are you don't want named instances
22:07:10 <copumpkin> cause I say so
22:07:25 <kmc> which you can do with GADTs even in released GHC
22:07:27 <kmc> and it gets better in GHC 7.4
22:07:41 <kmc> you still cannot make a type like Maybe (Functor Maybe)
22:07:52 <kmc> but you can write a single type like this:
22:07:54 <kmc> data T ctx (a :: * -> *) where T :: ctx a => T ctx a
22:08:13 <kmc> and then you can have something like  Just T :: Maybe (T Functor Maybe)
22:08:37 <kmc> and i think you can even use kind polymorphism to get rid of the requirement for one such T per kind
22:11:02 <copumpkin> you can't ever construct put instances inside your T except via unsafeCoerce
22:11:09 <copumpkin> which is actually vaguely safe
22:11:13 <copumpkin> but really not
22:11:16 <kmc> hmm?
22:11:20 * hackagebot hxournal 0.6.0 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.0 (IanWooKim)
22:11:32 <copumpkin> ugh, how did I write that sentence?
22:11:42 <copumpkin> I meant you can't make multiple distinct values of T without unsafety
22:11:46 <copumpkin> for a given class
22:11:50 <copumpkin> and type
22:12:51 <kmc> also I am really loving arbitrary declarations at the GHCi prompt
22:12:54 <kmc> it even works with -XStandaloneDeriving
22:13:06 <kmc> so if you or someone else forgot to derive Show for some type
22:13:22 <kmc> you just do
22:13:24 <kmc> GHCi> deriving instance Show T
22:13:34 <cl1> so instances of Functor are types with kind * -> *
22:13:40 <kmc> no
22:13:42 <kmc> yes
22:13:43 <kmc> sorry
22:13:48 * kmc :(
22:13:53 <cl1> am I wrong that much?
22:13:54 <cl1> LOL
22:14:04 <MiggyX> When you get "Ambiguous type variable in the constraint"   does that mean that Haskell doesn't know what data to return?
22:14:23 <cl1> kind * -> * is generics in c#
22:14:25 <kmc> technically you might say that something of kind other than * is not a "type" but a "type constructor"
22:14:39 <kmc> however this terminology is not very consistently followed
22:14:58 <cl1> type constructor is what haskell uses for terminology
22:15:21 <cl1> something of kind * is a "concrete" type
22:15:23 <MiggyX> I would be doing much better if I could figure out why I can't get half the things I try to work lol.
22:15:34 <kmc> this gets worse in GHC 7.4 because now Functor is also like a type constructor
22:15:45 <kmc> (if you turn on -XConstraintKinds)
22:16:00 <cl1> something of kind * -> * is a parametric type and unless you supply the parameter it is not a concrete type
22:16:07 <kmc> right
22:16:08 <cl1> amirite?
22:16:12 <kmc> yes :)
22:16:16 <cl1> awesome
22:17:15 <kmc> Haskell allows types and classes to be parametric over type constructors, not just concrete types
22:17:27 <kmc> as you noted, Functor is a class of type constructors
22:18:00 <kmc> anyway this is one of the biggest departures from a type system like C#'s or Java's
22:18:39 <kmc> it's why Haskell can have generic functions that work for all monads, or all functors, or all monad transformers, etc.
22:19:18 <kmc> in most other languages it is easy to write functions which have the proper types to make a monad
22:19:23 <kmc> but hard to generalize over all monads
22:19:34 <MiggyX> I think it's monad's that are giving me my headache lol
22:20:03 <kmc> MiggyX, I think the answer to your question about the error message is "yes"
22:20:07 <kmc> but you could provide more context
22:20:51 <MiggyX> kmc, well I can go back to the original question I had about parseTime.   I tried   parseTime defaultLocale  "%H:%M:%S" "12:30:00"   which gave that error
22:21:03 <MiggyX> after a lot of trial and error, I found that   adding :: LocalTime
22:21:07 <MiggyX> to the end made it work
22:21:11 <MiggyX> but I couldn't use UTCTime
22:21:39 <MiggyX> but I don't really know what I did to make it work - if I could figure that out, I might be able to figure out the other problem too :)
22:22:12 <kmc> where's parseTime from?
22:22:20 * kmc has found more stupid tricks with that T type, like:
22:22:22 <kmc> case Nothing of Just (T :: T Ord (Bool -> Bool)) -> not < id
22:22:47 <MiggyX> Date.Time.Format
22:23:00 <MiggyX> the return type is  Maybe t
22:23:47 <kmc> Maybe t, provided that t is an instance of the ParseTime class
22:23:51 <kmc> which UTCTime is
22:24:07 <kmc> > parseTime defaultLocale  "%H:%M:%S" "12:30:00" :: Maybe UTCTime
22:24:08 <lambdabot>   Not in scope: type constructor or class `UTCTime'Not in scope: `parseTime'N...
22:24:12 <kmc> ^^^^ did you try that?
22:28:17 <MiggyX> kmc: Trying to find and rerun my example
22:28:42 <MiggyX> okay that worked
22:29:23 <kmc> cool :)
22:29:31 <_riba> Getting some sleep, bye and thank you very much for helping!
22:29:45 <MiggyX> kmc: Which is great, but… what did we just do? :)
22:30:30 <kmc> what do you mean?
22:30:48 <kmc> you put a type signature on the expression, resolving the ambiguity
22:31:29 <MiggyX> I guess my concept of functions is still limited by imperative code - but why would there be ambiguity on what data is returned from a function?
22:31:30 <rwbarton> perhaps instead of OverlappingInstances, we can have an extension which provides a value of type Maybe (T cls a) for all classes cls and types a
22:31:44 <rwbarton> which is Just T if a is an instance of cls, and Nothing otherwise
22:31:53 <kmc> MiggyX, it's not about imperative vs. functional
22:31:58 <kmc> MiggyX, it's about polymorphism
22:32:19 <kmc> Haskell supports polymorphism in the return type of a function
22:32:23 <QinGW> Where can I find some materials about execution model of haskell lazy evaluation?
22:32:34 <edwardk> rwbarton: you can, as long as you define those two instances in the same module and don't want to rely on being able to get any other instances to overlap properly
22:32:34 <lambdabot> edwardk: You have 4 new messages. '/msg lambdabot @messages' to read them.
22:32:51 <kmc> MiggyX, usually the ambiguity is resolved by type inference, based on how the return value is subsequently used
22:33:11 <kmc> but sometimes it is not
22:33:26 <kmc> > toEnum 0 :: Char
22:33:27 <lambdabot>   '\NUL'
22:33:28 <rwbarton> edwardk, I mean maybe such an extension could solve some problems without the conceptual nightmare that is OverlappingInstances
22:33:30 <kmc> > toEnum 0 :: Bool
22:33:31 <lambdabot>   False
22:33:37 <kmc> > toEnum 0 + length "abc"
22:33:37 <cl1> MiggyX, think of :: Maybe UTCTime as casting the return value to the proper type
22:33:38 <lambdabot>   3
22:33:55 <kmc> in the first two cases i gave an explicit type annotation
22:34:00 <edwardk> rwbarton: meh, actually overlapping instances and constraint kinds interact very poorly
22:34:10 <kmc> in the third case it inferred Int, based on the fact that I'm using it with 'length', which returns Int
22:34:15 <rwbarton> the idea is to eliminate OverlappingInstances
22:34:20 <geheimdienst> cl1: MiggyX: yeah, well casting is a little bit similar, but also different in important ways :)
22:34:21 <edwardk> rwbarton: since you can use constraint kinds to open the more general instance in the restricted context
22:34:24 <kmc> cl1, MiggyX, no, don't think of it as a cast
22:34:42 <edwardk> rwbarton: so in general any system you derive that would act at all in a similar manner would face similar issues
22:34:46 <kmc> casting changes the meaning of a program
22:34:52 <rwbarton> but to provide this oracle into the type system at the value level
22:34:54 <kmc> the type annotation is just stating a fact which had to already be true
22:35:05 <rwbarton> anyways I haven't thought through it obviously
22:35:31 <kmc> Haskell doesn't have implicit type conversions, nor any special syntax for casting or converting between types
22:35:33 <geheimdienst> MiggyX: parseTime has type ":: (ParseTime t) => ... -> Maybe t". that means the function will give you not one particular type (say Maybe UTCTime), instead it can give you *any* type of typeclass ParseTime
22:35:36 <edwardk> rwbarton: i think the key is just accepting that overlapping instances isn't just a slightly bad idea, but that types with 1-2 overrides like it tends to encourage lead to bad overall behavior for the type system in general
22:35:41 <kmc> if you want to convert A to B then you just pick your favorite function of type A -> B
22:35:55 * cl1 will shut up now
22:36:48 <geheimdienst> ... so you could even have "SomeTypeThatMiggyWrote" take the role of "t", as long as you wrote an instance of typeclass ParseTime for SomeTypeThatMiggyWrote
22:36:50 <kmc> the weird thing here is that information about which type to use is flowing "backwards in time"
22:37:03 <kmc> that is, the behavior of a function and the type it returns can depend on how that value is subsequently used
22:37:15 <MiggyX> kmc: Okay, I mean I'm just printing out the result in ghci, so as I wasn't doing anything explicit with it, it couldn't be sure what I wanted.  But what I don't understand yet, is why it would need me to tell it.  From the function definition, it says it will return a ParseTime… but I need to tell it which "sub type" I actually want?
22:37:19 <geheimdienst> you would then select that instance by saying "parseTime ... :: Maybe SomeTypeThatMiggyWrote", as kmc did above
22:37:22 <kmc> this works out because types are resolved at compile time by type inference, which is a bidirectional process
22:37:56 <kmc> MiggyX, ParseTime isn't a type
22:38:27 <kmc> it's a type class, i.e. a constraint on types
22:38:38 <kmc> when you say:   parseTime :: (ParseTime t) => Whatever -> Maybe t
22:39:19 <kmc> this says "parseTime can return any type, so long as it provides an implementation of the ParseTime functions"
22:39:29 <kmc> it doesn't say which concrete type you get
22:40:07 <MiggyX> okay
22:40:09 <kmc> that's why you can use it as  «parseTime :: Whatever -> Maybe UTCTime»  or  «parseTime :: Whatever -> Maybe LocalTime»
22:40:12 <kmc> but not «parseTime :: Whatever -> Maybe Bool»
22:40:23 <kmc> because Bool is not an instance of the ParseTime typeclass
22:40:41 <MiggyX> so although you said not to think of it as casting ( I promise I won't ! )  it would be roughly like getting a generic result in say Java and then casting it to the specific type.
22:40:59 <MiggyX> I know it doesn't do that and I can see that haskell doesn't actually cast anything
22:41:05 <kmc> sort of, not really
22:41:22 <MiggyX> in fact the Haskell version seems much simpler and safer
22:41:37 <MiggyX> it just says that you're going to get something that looks like X but not which X you will get
22:42:44 <cl1> MiggyX, it looks like casting but you are actually narrowing down the return type used since the compiler can't figure it out. there is a parseTime method that has a return type of Maybe UTCTime, you are saying to use that function
22:42:53 <cl1> so its not like casting, but it "looks" like casting
22:42:57 <kmc> in particular, the function "knows" which type you're going to "cast" to, and can behave differently based on that
22:43:27 <kmc> in Java the function just returns Object and has no idea what the user will cast it to
22:43:33 <MiggyX> so the type that I pass to the function is actually given to the function as t right ?
22:43:40 <kmc> hmm?
22:43:49 <cl1> yes
22:43:53 <nus> kmc, it'd be better to introduce 'coercion' term (-:
22:43:55 <cl1> normally it is inferred
22:44:19 <cl1> from the current context, but in this case it cannot infer the type of t so you have to tell it
22:44:39 <kmc> MiggyX, I think the Java analogy isn't that helpful.  "it's the same except for all the ways it's different."
22:44:52 <geheimdienst> MiggyX: the issue with casts is that they can fail at runtime. the ":: Maybe Foo" selects the right implementation. it's a little how a "toString()" method exists in many java classes, and by saying "someDatabase.toString()" you select the particular toString() method which is defined in the class of someDatabase
22:45:03 <rwbarton> actually the situation in Java is almost exactly the opposite
22:46:02 <cl1> its like generic functions in c#:  public static T SomeFunction<T>(TimeLocale locale, string fmtString, string inputString);
22:46:03 <MiggyX> So… when you provide the type, you are telling the function which type you need.  The compiler can often infer it based on how you use the result - but in some cases (like the error message said duh) the result is ambiguous
22:46:15 <kmc> yes
22:46:18 <kmc> precisely :)
22:46:38 <cl1> if c# had a Maybe<T> you could call it like this Maybe<T> foo = SomeFunction(a,b,c);
22:47:03 <kmc> cl1, really? you don't have to say Maybe<T> foo = SomeFunction<Maybe<T>>(a,b,c);  ?
22:47:05 <cl1> however if you called it like this: var foo = SomeFunction(a,b,c) the compiler would complain because it cannot figure out the type of T
22:47:10 <MiggyX> and so if it can't infer the result, it can't infer which type you want and hence, it can't call the function
22:47:41 <cl1> if you used var: var foo = SomeFunction<Maybe<UTCTime>>(a,b,c);  then it would work
22:47:58 * cl1 thinks he learned quite a bit in the last few hours
22:48:01 <kmc> MiggyX, even something as simple as «print (2+2)» would be ambiguous (is that 2 :: Int or 2 :: Float ?), except that Haskell has an ad-hoc rule for defaulting numeric types
22:48:11 <cl1> MiggyX, exactly
22:49:19 <MiggyX> well
22:49:24 <MiggyX> that's pretty damn cool that is
22:49:37 <MiggyX> the amount of headache that will prevent
22:50:00 <geheimdienst> MiggyX: yeees, feel the anger, feel the power, come to the dark side
22:50:33 <kmc> feel the rhythm, feel the rhyme, get on up, it's bobsled time!
22:50:40 <etpace_> @hoogle EIther a b -> c -> Either a c
22:50:40 <lambdabot> Did you mean: Either a b -> c -> Either a c
22:50:40 <lambdabot> No results found
22:50:50 <etpace_> @hoogle Either a b -> c -> Either a c
22:50:50 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
22:50:50 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
22:50:50 <lambdabot> Data.Graph.Inductive.Monad delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
22:51:12 <geheimdienst> kmc: this doesn't fit all that well with the darth vader or emperor palpatine i was thinking of
22:51:39 <kmc> > map ('x' <$) [Left 3, Right 'y']
22:51:40 <lambdabot>   [Left 3,Right 'x']
22:51:59 <kmc> :t flip (<$) :: Either a b -> c -> Either a c
22:52:00 <lambdabot> forall a b c. Either a b -> c -> Either a c
22:52:28 <kmc> that's pretty cryptic though
22:52:55 <kmc> and won't work for the other side
22:53:04 <kmc> :t \x -> either id (const x)
22:53:04 <lambdabot> forall a b. a -> Either a b -> a
22:53:13 <kmc> ...no :/
22:53:14 <cl1> i can implement Functor in c#
22:53:19 <etpace_> hmm
22:53:20 <geheimdienst> > map (fmap succ) [Left 7, Right 10]
22:53:21 <lambdabot>   [Left 7,Right 11]
22:53:40 <cl1> i can create an interface interface Functor { /* no implementation */ }
22:53:47 <cl1> then inherit that interface
22:53:48 <etpace_> :ty \e x -> fmap (const x) e
22:53:49 <kmc> :t \x -> either (Left . id) (const (Right x))
22:53:49 <lambdabot> forall b a b1. b -> Either a b1 -> Either a b
22:53:59 <cl1> now what I can't do is enforce the following
22:54:01 <etpace_> :t \e x -> fmap (const x) e
22:54:01 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f a1 -> a -> f a
22:54:26 <cl1> I can then on my class that implements the interface create an fmap method that follows the rules of Functor's fmap
22:54:36 <MiggyX> cl1: you're not the only one who has learned a lot today :)
22:55:16 <cl1> and I can use the Functor interface as the type but cast to dynamic to call fmap
22:56:00 <cl1> now using any method that takes Functor and casts to dynamic might be worthless, but I can still implement the concept of functor
22:56:49 <MiggyX> cl1: one day that last sentence might make sense to me :D
22:57:49 <cl1> dynamic makes a variable that works like javascript variables. you can call any method you can imagine so long as it is implemented by the thing stored in the type
22:59:33 <cl1> MiggyX, I just got how type classes work
22:59:53 <MiggyX> cl1: Which is different from type constraints? :)
23:00:02 <cl1> yes
23:01:41 <cl1> i don't think i could explain them proper, but i do understand them
23:02:25 <cl1> variables contain instances of classes (as you know classes), classes can be instances of type clasess. Its like the next level up
23:03:14 <cl1> its like going from 2d to 3d
23:04:06 <Lemon> wait, what
23:06:05 <Sgeo> Are there circumstances in which I can take control of someone else's Haskell package?
23:06:30 <MiggyX> cl1:  I might leave that particular journey of excitement for another day I think :D
23:07:45 <etpace_> Aren't typeclasses just a vtable that hangs around at run-time for each function? When we use our typeclassed (eg: show), we check the type we are calling it on and then call the appropriate function from looking in our vtable
23:09:55 <kmc> that sounds more like a strategy for implementing type classes
23:10:00 <kmc> not like a description of what type classes are
23:10:18 <kmc> it sounds like you're describing the strategy most haskell implementations use
23:10:38 <kmc> which is that each class becomes a record of stuff, called a "dictionary"
23:11:34 <kmc> data OrdDict a = OrdDict { dict_compare :: a -> a -> Ordering, dict_less :: a -> a -> Bool, ... }
23:12:05 <kmc> now every function that had a constraint like «(Ord t) => ...» gets an extra argument like «OrdDict t -> ...»
23:12:42 <kmc> and values for these arguments are passed implicitly
23:13:23 <etpace_> @hoogle m1 (m2 a) -> (a -> m1 (m2 a)) -> m1 (m2 a)
23:13:24 <lambdabot> No results found
23:14:20 <kmc> not possible in general
23:14:25 <kmc> i assume m1, m2 are meant to be Monads?
23:14:25 <etpace_> bah
23:14:29 <etpace_> Yeah
23:14:39 <etpace_> IO and Either, rather not have the clunk of a EitherT or something
23:14:46 <etpace_> guess I'll write a special "deep >>="
23:15:01 <hpaste> aib pasted “hmm” at http://hpaste.org/55444
23:17:07 <kmc> say  f :: Maybe (IO a) -> (a -> Maybe (IO b)) -> Maybe (IO b)
23:17:50 <kmc> then you want:   f  (Just (return 'x'))  (const Nothing)  ≡  Nothing
23:18:16 <kmc> but you had to perform IO effects to determine that
23:18:34 <etpace_> :ty (\val f -> val >>= either (return . Left) f)
23:18:37 <etpace_> :t (\val f -> val >>= either (return . Left) f)
23:18:38 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => m (Either a b1) -> (b1 -> m (Either a b)) -> m (Either a b)
23:18:48 <etpace_> Ideally, my IO actions can also fail, and I want to shortcircuit if I do so
23:19:29 <kmc> yeah, it should be possible for  IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe b)
23:19:41 <c_wraith> which is exactly what MaybeT is
23:19:41 <kmc> i'm just demonstrating why it isn't possible in general
23:20:01 <c_wraith> well, what MaybeT lets you build
23:20:31 <etpace_> aha, thanks
23:21:02 <c_wraith> ...  It's no less clunky than an EitherT would be...
23:21:10 <kmc> <cl1> i don't think i could explain them proper, but i do understand them
23:21:14 <kmc> that's suspicious cl1 ;)
23:21:29 <kmc> usually when i think i understand something and then try to explain it
23:21:35 <kmc> i realize i did not actually understand it
23:22:12 <MiggyX> kmc: I think I managed to explain the Type stuff to a co-worker. Always useful because when you try to explain it, you usually gain a clearer understanding as well :)
23:22:58 <aib> I'm really new to this and I've forgotten most of the tutorials I've read, but at http://hpaste.org/55445 : there are two termination conditions, one of which is success. can someone walk me through wrapping the result in a Maybe so the failure condition causes the whole thing to return a Nothing while the other one a Just result?
23:24:07 <cl1> kmc .. I should have said, I think I understand them, but I'm not sure that I do and I don't want to give bad information
23:27:14 <Makoryu> aib: The success and failure lines should be easy. Success is "Just []" and failure is "Nothing"
23:27:50 <Makoryu> aib: And the fourth branch is a tail call, so you don't have to worry about that
23:28:31 <Makoryu> aib: The only tricky part is the third line, and how you want to do it depends on how much information about a failed test you want to preserve, I think.
23:30:27 <cl1> @quote derive
23:30:27 <lambdabot> Baughn says: Blum Blum Shub, a PRNG derived from poking around R'Lyeh.
23:30:33 <Makoryu> aib: Do you want to return Nothing if any part of it fails?
23:30:57 <cl1> @quote kmc derive
23:30:57 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
23:30:59 <aib> Makoryu: well, yeah. I think just replacing the ":" for now should be fine
23:31:01 <Makoryu> I mean I'm not even really looking at what it does
23:31:21 <cl1> how do you search for quotes based on a particular person with lambdabot?
23:31:54 <Jenna> Hey guys
23:32:21 <cl1> howdy
23:32:39 <Jenna> I'm playing with the tryhaskell site, and have some feedback
23:32:47 <Jenna> where would be the best place to put it? :)
23:33:26 <Makoryu> aib: One approach is to introduce a case expression
23:33:46 <Makoryu> aib: That is, "case costStepLR tail (head tail) end of ..."
23:33:55 <aib> Makoryu: the only part I'm having trouble with is the ":". is there a version that works on Maybe lists? or more generally, what would be the Haskell way of using function f that works on 'a' in such a way that it works on Maybe 'a' ?
23:34:18 <shachaf> aib: fmap (a:) b
23:34:25 <shachaf> > fmap (1:) (Just [2])
23:34:26 <lambdabot>   Just [1,2]
23:34:28 <shachaf> > fmap (1:) Nothing
23:34:29 <lambdabot>   Nothing
23:34:30 <Makoryu> Yeah that'll work
23:34:34 <shachaf> > (1:) <$> Just [2]
23:34:35 <lambdabot>   Just [1,2]
23:35:13 <kmc> Jenna, it's made by http://chrisdone.com/
23:35:41 <Makoryu> aib: ^ These are all syntactically and semantically more compact (and much more polymorphic) ways of pattern matching on a Maybe list
23:35:49 <augur> what is push/enter vis-a-vis eval/apply?
23:36:36 <kmc> augur, read "How to make a fast curry"
23:36:49 <augur> mm i like a curry
23:37:10 <shachaf> aib: Yes, you can also do: case b of Nothing -> Nothing; Just xs -> Just 1:xs
23:37:41 <Makoryu> Gotta write "Just (1 : xs)" instead of "Just 1 : xs"
23:37:59 <shachaf> Er, yes.
23:38:00 <augur> oh man i could so go for a curry, kmc
23:38:02 <augur> i hate you so much
23:38:03 <augur> :(
23:38:08 <kmc> haha
23:38:09 <shachaf> What Makoryu said.
23:38:10 <kmc> how about a currywurst
23:38:14 <Jenna> kmc: Oh cool I can tweet at him!
23:38:25 <shachaf> Tweet. :-(
23:38:29 <kmc> or you could email him
23:39:06 * copumpkin slaps shachaf 
23:39:07 <augur> kmc: currywurst is good but not as good
23:39:08 <aib> I will try them. I remember tutorials mentioning this kind of thing a lot. I have a function that uses lists, I use : to make them. Then I change it into one that uses Maybe lists or TreeOf lists or something, then with a few simple steps, it all works. meh, I'm not making much sense, sorry
23:39:30 <shachaf> copumpkin: What happened to the good old civilized days of email?
23:39:46 <copumpkin> shachaf: people realized they had different requirements
23:39:53 <copumpkin> when email suffices, they use it
23:40:01 <copumpkin> when twitter suffices, they use that instead
23:40:17 <shachaf> copumpkin is like Knuth, I guess.
23:40:31 <shachaf> Email is too distracting. So he sticks to the Twitter.
23:40:57 <augur> i dont use email cause its not immediate enough
23:41:01 <augur> i use it when forced to
23:41:08 <augur> but i prefer instant message and irc
23:41:40 <aib> erm, what do I import for <$>? sorry, it's really hard to google.
23:42:04 <copumpkin> Data.Functor
23:42:14 <aib> roger, thanks
23:42:15 <augur> wouldnt it be data.applicative?
23:42:20 <augur> or does functor just have all of that
23:42:21 <shachaf> It's Control.Applicative.
23:42:22 <danr> Control.Applicative works too
23:42:26 <augur> or that!
23:42:30 <augur> :D
23:42:30 <copumpkin> Control.Applicative re-exports it
23:42:37 <danr> indeed
23:42:38 <shachaf> Kind of weird how Functors are Data but Applicatives are Control.
23:43:22 <copumpkin> Traversable and Foldable are also Data
23:43:46 <etpace_> say I have a module Foo where import Foo.Bar; import Foo.Baz; - how can I make "import Foo" import Foo.bar and Foo.Baz too
23:44:01 <shachaf> etpace_: You can't reëxport qualified module names.
23:44:20 <shachaf> etpace_: If you just want to reëxport their contents, you can module Foo (module Foo.Bar, module Foo.Baz) where ...
23:44:28 <etpace_> tthanks
23:44:34 <kmc> @hoogle (<$>)
23:44:35 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
23:44:35 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:44:36 <kmc> aib, ^^^
23:44:44 <danr> what are the StateR s and StateL s instances of Functor?
23:44:47 <aib> noted!
23:45:25 <shachaf> @instances Functor
23:45:26 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
23:45:27 <shachaf> @hoogle StateR
23:45:27 <lambdabot> package stateref
23:45:56 <danr> Scriptor: thanks
23:46:07 <shachaf> @google what are the "StateR" s and "StateL" s instances of Functor?
23:46:07 <danr> shachaf: thanks :)
23:46:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/src/Data-Traversable.html
23:46:08 <lambdabot> Title: Data/Traversable.hs
23:46:21 <Scriptor> danr: you're welcome! :p
23:46:24 <shachaf> danr: Apparently it's that. :-)
23:46:33 <danr> Scriptor: sorry ;)
23:46:59 <etpace_> Hmm.. I'm having problem with my directory structures/cabal options: I have my modules in src/.. and try to compile the exe of src/Main.hs, but running outside of src says that it cant find the modules, yet if I cd src; ghci Main.hs it works alright -- any ideas?
23:47:42 <shachaf> etpace_: Well, it looks relative to the current directory.
23:47:50 <shachaf> That's not a problem, that's how it works.
23:47:59 <shachaf> You can try runghc -i src/ src/Main.hs
23:49:09 <etpace_> "`src/' is not a module name or a source file"
23:50:22 <shachaf> Oh, maybe it's -isrc/
23:50:38 <shachaf> I don't know. You're as capable as I am of figuring out the exact syntax. :-)
23:50:45 <etpace_> it works, thanks
23:50:57 <etpace_> Now, I'd like cabal to do that when it compiles it seems
23:51:17 <shachaf> Cabal has its own way.
23:57:17 <aib> does this make sense? http://hpaste.org/55446
23:58:22 <ski> cl1 : "think of :: Maybe UTCTime as casting the return value to the proper type" -- except it's not casting (to a potentially different type), it's just constraining (to a type which it already could have been) -- an expression of form `<expr> :: <type>' is known as a type ascription of the subexpression
23:58:24 <aib> it's pseudocode, really, but it expresses the kind of function I want
23:58:27 <ski> nus : "coercion" isn't right, either. that suggests some kind of conversion process (think converting `Int' to `Double')
23:58:31 <kmc> that's pseudocode?
23:58:39 <ski> etpace_ : otoh, applicative functors do compose
23:58:43 <shachaf> @ty liftA2
23:58:44 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
23:58:50 <kmc> oh, because you want it to be more general than Maybe
23:59:13 <shachaf> aib: Applicative functors do what you want, and liftA2 in particular.
23:59:15 <cl1> ski: type ascription of the subexpression, got it
23:59:15 <ski> etpace_ : i.e. if `i0' and `i1' are applicative functors, then `i0 . i1' is one too
23:59:32 <shachaf> @hoogle f a -> (a -> b -> x) -> f b -> f x
23:59:32 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:59:32 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:59:32 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
23:59:44 <shachaf> aib: Hoogle is also smart enough to figure that out, it seems. :-)
