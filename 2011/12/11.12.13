00:01:55 <vjacob> cl1, nice...
00:04:28 <cl1> okay, i'm no longer retainiing what i'm reading, i need to be cut off for the night and go to bed
00:32:20 --- mode: ChanServ set +o mauke
00:32:20 --- mode: mauke set -q *!*@gateway/web/freenode/ip.85.118.226.197
00:34:21 --- mode: mauke set -o mauke
00:48:06 <shachaf> gdb + ghc-generated code does not seem to turn out happily.
00:48:16 <Enigmagic> hmm?
00:49:44 * shachaf is apparently trying to step through a bunch of RTS code.
00:49:52 <shachaf> There's probably an easir way to accomplish whatever I'm trying to accomplish.
00:50:00 <Enigmagic> what are you trying to do
00:51:05 <shachaf> Figure out why some code which is using hs-plugins is segfaulting.
00:51:33 <Enigmagic> if you build with -debug it makes it somewhat easier
00:51:50 <shachaf> I tried that (I think).
00:52:15 <Enigmagic> what does the stack look like when it segfaults
00:52:35 <Enigmagic> is the rts or a *_info symbol on top?
00:53:06 <shachaf> #0  0x0000000000403390 in ?? ()
00:53:36 <Enigmagic> run 'x/100a $rbp' and see if anything looks interesting towards the top
00:54:44 <shachaf> Oh, I didn't know about that.
00:54:52 <shachaf> I was relying on "disas", which wasn't working there.
00:55:23 <shachaf> Wait, never mind.
00:55:32 <shachaf> That's $rbp, not... Ignore what I said.
00:55:32 <guest__> hmmm mm
00:55:44 <Enigmagic> probably isn't working cuz there are no symbols at that address (hence the ??)
00:55:53 <guest__> hmmmmmmmmmmm
00:55:55 <shachaf> 0x7fffefdb93f8:	0x7ffff781f040 <stg_stop_thread_info>	0x7ffff781e350 <stg_BLACKHOLE_info>
00:56:35 <Enigmagic> does 'x/10i $rip' look like x64 assembly?
00:56:42 <guest__> Hey. What goes on here ?
00:56:50 <shachaf> Enigmagic: Not very.
00:57:34 <guest__> Well?
00:58:12 <Enigmagic> shachaf: well i'm not sure about the stop_thread call (its a primop i think) but the blackhole means it's evaluating a thunk
00:58:16 <guest__> ok nevermind
00:58:47 <shachaf> Enigmagic: Yes, that is expected. :-)
00:59:00 <shachaf> I tried using "record" previously, but it apparently is really slow.
01:00:14 <shachaf> => 0x403390:	mov    $0x33,%al
01:00:14 <Enigmagic> is the address in the module you're trying to make a call into?
01:00:38 <shachaf> 00403000-00553000 is non-executable heap.
01:01:01 <Enigmagic> heh yeah that won't work
01:01:25 <Enigmagic> haskell heap?
01:01:28 <shachaf> Is there a way I can get gdb to stop executing it right *before* it jumps there? :-)
01:01:38 <Enigmagic> i wish :P
01:01:46 <shachaf> I don't know; I just see in /proc/pid/maps 00403000-00553000 rw-p 00000000 00:00 0                                  [heap]
01:01:54 <Enigmagic> i think they should add a new STG register for "last $pc before a tailcall"
01:02:53 <Enigmagic> if you're using the single threaded runtime you can say 'print MainCapability' and look for the rCurrentTSO field
01:03:29 <shachaf> I can probably keep doing the vaguely-binary-searchy-through-the-instructions thing that I was doing previously, and eventually track down the culprit.
01:03:34 <Enigmagic> it might have the heap pointer around
01:03:51 <shachaf> It doesn't help that since I'm using hs-plugins, gdb can't actually save any of my breakpoints across runs.
01:04:06 <shachaf> (Because the code only gets loaded in mid-run, which is after gdb tries to insert the breakpoint.)
01:04:25 <Enigmagic> i'd guess there is a closure layout problem if it's jumping to the heap
01:06:02 <shachaf> This is a thing that's only happening if the same thunk is evaluated twice, by the way.
01:06:17 <shachaf> It might have to do with GC or something; I don't know.
01:07:34 <salisbury> urgh... (mapM_ (a -> IO b)) <$> IO [a] gives IO(IO())
01:08:17 <shachaf> salisbury: You probably want >>=, not <$>
01:08:33 <shachaf> Also, people will get really confused when you combine types and values like that.
01:09:05 <shachaf> It's clearer to say something like mapM_ (f :: a -> IO b) <$> (blah :: IO [a]), or something, so people can distinguish them. :-)
01:09:19 <shachaf> What you want is probably blah >>= mapM_ f, with those names.
01:09:43 <salisbury> thanks for the type/val tip
01:10:01 <Enigmagic> shachaf: well the thunk should only be evaluated once
01:10:10 <salisbury> I'll try the other one and see
01:10:18 <Enigmagic> hence the blackhole on the stack
01:10:33 <shachaf> Enigmagic: Yes, I don't mean evaluating the thunk.
01:10:48 <shachaf> This isn't actually my code, so maybe I don't completely understand what it's doing. :-)
01:10:51 <cwl> I write a simple snaplet using Session Snaplet, but..
01:10:53 <cwl> https://gist.github.com/1471406
01:11:13 <cwl> session lost between requests
01:12:03 <Enigmagic> shachaf: :-) well good luck.. there is a branch that emits some debug symbols (filenames/line numbers) but it's buggy and takes up a huge amount of memory
01:12:39 <salisbury> shachaf: that is indeed what I needed, I didn't know you could >>= a single value in that fashion
01:13:21 <salisbury> now that I think of it, a function is only a value
01:13:27 <salisbury> so that was a stupid assumption
01:13:33 <shachaf> salisbury: You could also use join.
01:13:39 <kstt> do typeclasses introduce indirection at runtime ?
01:13:53 <shachaf> salisbury: In fact, one possible definition of >>= in terms of join and fmap is a >>= b = join (b <$> a)
01:14:04 <salisbury> head *explode*
01:14:21 <salisbury> how did I miss join
01:15:28 <salisbury> now I have so much refactoring to do
01:16:09 <ski> kstt : probably, in the general case at least
01:16:21 * shachaf tries to figure out how to examine MainCapability.
01:16:57 <mm_freak_> haskell-cafe keeps rejecting my mails
01:17:03 <mm_freak_> this is starting to get annoying
01:17:05 <ski> kstt : "the general case being if you use either (a) polymorphic recursion; or (b) existential types
01:17:13 <ski> s/case/case"/
01:18:02 <Enigmagic> shachaf: MainCapability is rarely up to date, just be warned
01:18:12 <Enigmagic> well, the STG registers are rarely up to date
01:19:05 <cwl> could anyone help me with that problem https://github.com/snapframework/snap-auth.git
01:19:07 <cwl> sorry
01:19:11 <cwl> wrong url
01:19:17 <cwl> https://gist.github.com/1471406
01:19:33 <cwl> session is not shared between requests
01:19:49 <shachaf> Ugh, debugging instructions with gdb is no fun.
01:20:11 <kstt> thank you ski
01:21:01 <kstt> so typeclass functions should not be used in tight loops, right ? Do you have readings to recommand please ?
01:22:23 <ski> kstt : i think "should" is a too strong word here. profile the performance and see ?
01:25:41 <Enigmagic> kstt: the best thing to do is either profile or look at the core or stg output to see what ghc did. a lot of times (probably the majority) it can resolve the type at compile time... and then it's not different than a regular function call
01:25:54 <kstt> ski, well, if resolution can't be static, then inlining is impossible
01:26:28 <kstt> Enigmagic: I'd like to understand when and why it can't be resolved statically
01:26:55 <Enigmagic> in the case of a function like "showInt :: Int -> String; showInt = show" it will be resolved statically.
01:27:01 * shachaf is so glad that gdb at least disables ASLR.
01:28:04 <ski> kstt : in general, yes
01:28:09 <Enigmagic> but lets say you have a NOINLINE function that looks more like this: "showIntegral :: (Show a, Integral a) => a -> String; showIntegral = show"
01:28:29 <ski> kstt : it can be static in many common cases, though
01:28:53 <Enigmagic> then the call to show will be indirect
01:29:17 <ski> kstt : consider a function like
01:29:58 <ski> @let foo :: Show a => [a] -> [String]; foo [] = []; foo (a:as) = show a : foo (map (:[]) as)
01:30:00 <lambdabot>  Defined.
01:30:05 <ski> > foo "abcd"
01:30:08 <lambdabot>   ["'a'","\"b\"","[\"c\"]","[[\"d\"]]"]
01:30:25 <ski> kstt : this is a (silly example of a) polymorphic-recursive function
01:31:38 <ski> kstt : in this case, you need (a) to start with an instance `Show a'; (b) you need to also *dynamically* compute instances `Show [a]',`Show [[a]]',`Show [[[a]]]',&c. -- how many you need depends on how long the list passed at run-time will be
01:32:41 <ski> so you can't statically resolve all the references to `show', since doing that would entail generating infinitely many instances to compile separatedly into the object code
01:33:17 <kstt> I'm trying to digest this case
01:34:16 <shachaf> Enigmagic: Aha! I managed to step late enough that "record" is usable.
01:34:24 <kstt> pen and paper to the rescue
01:35:08 <Enigmagic> shachaf: sweet, think you'll figure out the problem?
01:35:32 <d34df00d> What'd you suggest for a map from Numerics to some random stuff that'd allow me to lookup the value with the list key effeciently?
01:35:33 <kstt> thank you very much for the detailed examples, I think that's exactly what I need to understand
01:35:35 <shachaf> Well, *eventually*, I'm sure. :-)
01:35:40 <d34df00d> Basically, I need to lookup that often, and modification is extremely rare.
01:35:58 <d34df00d> Or not so rare, if you count the removal of that minimal key.
01:36:42 <Enigmagic> shachaf: :-) the joys of debugging in gdb..
01:36:59 <shachaf> There have got to be better debuggers than this.
01:37:08 <mellum> Is there a standard function that does something like maybeChange f m = case m of Nothing -> Nothing; Just x -> Just (f x)
01:37:35 <d34df00d> mellum: fmap :)
01:38:16 <Enigmagic> shachaf: lldb is promising but not feature complete. i'm writing a bunch of python extensions for it for debugging ghc compiled apps though..
01:38:35 * shachaf admits that "record" is pretty neat.
01:39:04 <Enigmagic> d34df00d: HashMap or Map would be a good place to start
01:39:13 <mellum> d34df00d: cool.
01:39:51 <mellum> d34df00d: I'm not sure I understand why it works, though :-)
01:40:01 <shachaf> mellum: Because it's defined that way.
01:40:15 <shachaf> mellum: fmap is a polymorphic function that has a different implementation for every type.
01:40:32 <shachaf> In the case of Maybe, the definition is literally: fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
01:40:59 <d34df00d> Enigmagic: oh, thanks, but I've suddenly found the heap package.
01:41:05 <d34df00d> Seems like Data.Heap is exactly what I need.
01:41:07 <mellum> I see
01:41:12 <shachaf> Oh, kmc, you joined just as I gave up on debugging hs-plugins-using code in gdb for the night.
01:41:43 * shachaf really ought to go to sleep now.
01:41:46 <kmc> ouch
01:41:49 <Enigmagic> d34df00d: doh, i missed the 'minimal key' part
01:42:36 <geheimdienst> what's hs-plugins, this? http://hackage.haskell.org/package/plugins
01:42:42 <shachaf> Yes, that.
01:42:48 <geheimdienst> thanks
01:43:10 <shachaf> dons's PhD, I think.
01:43:38 <kstt> ski: does the dynamic case come from the Show instance for [a], that is "instance (Show a) => Show [a] where ..." ? It looks like a recursive instance definition.
01:44:36 <ski> kstt : yes, for each time `foo' is called, using a type `a' and input instance `Show a', in the recursive call it will call itself now with `[a]' and an instance `Show [a]' instead
01:45:14 <ski> kstt : so, it has to construct the instance `Show [a]' from the input instance `Show a', for each recursive call -- and it will do this by using that `instance (Show a) => Show [a] where ...' declaration, yes
01:45:46 <kstt> Ok ... I've assumed so far that Haskell binaries did not require types at runtime. That assumption seems to be wrong now.
01:45:53 <ski> kstt : since the number of times it calls itself recursively can't be determined statically / at compile-time, all the references to `show' can't be resolved statically
01:46:16 <ski> kstt : this doesn't require types at all at runtime, it only require *instances* at runtime
01:47:29 <ski> kstt : at run-time, no representation of the type `a' has to be passed to `foo' (because all types (of kind `*', not of kind `#') has the same (direct) size (aka "uniform representation"))
01:48:21 <ski> kstt : however, a representation of the instance `Show a' *does* have to be passed (in general), and this representation will be some kind of record containing the member functions in the instance (plus references to the member functions in parent classes, if any)
01:48:44 <kstt> but, aren't instances partitioned (not sure that's proper term, I think I mean they are resolved) by the type they implement ?
01:50:39 <ski> yes
01:51:12 <ski> (though an instance can be determined by more than one type (see multi-parameter type classes, MPTCs, e.g. `MonadState'))
01:51:36 <kstt> I feel I'm confused here, I need to digest more
01:51:37 <ski> kstt : however, all this resolving of instances through types can be done at compile-time
01:52:06 <ski> in `foo' above, it knows that `a' satisisfies `Show a', because of the constraint `Show a' in the type signature
01:52:29 <ski> it also knows that `Show a => Show [a]', because of the general `instance (Show a) => Show [a] where ...' declaration
01:53:42 <ski> so, it knows that if it takes the instance of `Show a' that it will be passed at run-time (regardless of for *which* type `a' that happens to be), and passes that instance to the code implementing `instance (Show a) => Show [a] where ...', then that code will (at run-time) produce a new instance that it knows is for `Show [a]'
01:53:52 <ski> it still doesn't know what type `a' is, but that doesn't matter
01:54:28 <ski> it knows it's now safe to pass this instance for `Show [a]' to the recursive call, because the type-checking for this that run at compile-time succeeded
01:54:46 <ski> (if there would be a problem, the type-checking wouldn't have succeeded)
01:55:10 <ski> so, at run-time, there is no need for it to know what the type `a' actually is
01:55:25 <d34df00d> Sooo, getting back to my graphs-typeclasses stuff :)
01:55:30 <ski> it just has to be able to pass around instances like `Show a' and `Show [a]', and construct the latter from the former, dynamically
01:55:49 <d34df00d> I've decided to have a simple 'class Graph g where' stuff, with, for example, this function: addEdge :: g w -> WEdge w -> g w
01:57:04 <d34df00d> Then I write the implementation for addEdge and get the following error: http://paste.pocoo.org/show/520173/
01:57:13 <d34df00d> Both are on the link :)
01:57:16 <d34df00d> What I'm doing wrong?
01:57:28 <kstt> ski, I think I'm getting it
01:57:38 <kstt> thank you very much for your clear explanations
01:58:01 <mellum> Let's say I have a fold-like function foldThings, but I only want one arbitrary thing. If I do "case foldThings (:) things [] of [] ->Nothing; x:_ -> Just x", then due to laziness that's O(1), right? Or is there any better way?
01:58:24 <hugi> hi
01:58:39 <ski> kstt : an example of where this kind of thing would be needed, which isn't polymorphic recursion, is the existential example : `data Showable = forall a. Show a => MkShowable a; showShowable :: Showable -> String; showShowable (MkShowable a) = show a'
01:59:27 <ski> note that here you can do things like `map showShowable [MkShowable "abcd",MkShowable 945]' -- i.e. in a sense, you can have a "heterogenous" list
01:59:40 <kstt> well, indeed, list content will be determined at runtime, so implementations will vary with MkShowable content
01:59:51 <kstt> I have easier time to follow that case
02:00:01 <ski> btw, if you prefer, you could write the type definition here using GADT syntax : `data Showable where MkShowable :: Show a => a -> Showable'
02:01:14 <ski> kstt : for a less useless example of polymorphic recursion, consider the type `data BinTree a = Elements a | Double (BinTree (a,a))' of *perfectly balanced* binary trees
02:01:26 <ski> possible values (with types) using this are :
02:01:37 <ski>   Elements 0 :: BinTree Integer
02:01:52 <ski>   Double (Elements (0,1)) :: BinTree Integer
02:02:05 <ski>   Double (Double (Elements ((0,1),(2,3)))) :: BinTree Integer
02:02:20 <ski>   Double (Double (Double (Elements ((0,1),(2,3)),((4,5),(6,7))))) :: BinTree Integer
02:02:29 <ski>   Double (Double (Elements ((0,1),(2,3)),((4,5),(6,7)))) :: BinTree (Integer,Integer)
02:02:44 <ski>   Double (Elements ((0,1),(2,3)),((4,5),(6,7))) :: BinTree ((Integer,Integer),(Integer,Integer))
02:02:59 <ski>   Elements ((0,1),(2,3)),((4,5),(6,7)) :: BinTree (((Integer,Integer),(Integer,Integer)),((Integer,Integer),(Integer,Integer)))
02:03:06 <kstt> lol
02:03:24 <ski> kstt : now, the question is : how to write an instance of `Eq' for this type ?
02:04:10 <danr> ski: Ralf Hinze has written an interesting paper on that named Numerical Representations as Higher-Order Nested Datatypes
02:04:36 <kstt>  Double (Elements (0,1)) :: BinTree Integer  <- is that the right type ?
02:04:53 <shachaf> kstt: Yes.
02:05:11 <kstt> ah, indeed
02:05:13 <shachaf> Wait, wasn't I supposed to be going to sleep?
02:07:01 <kstt> I think I'll have infinite admiration all my life for the folks behind haskell ... Most of us would probably have aborted such a project in the face of such particularities :)
02:09:52 <kstt> ok, so I guess the Eq instance would have to be recursive
02:10:46 <kstt> deconstructing the tree at each stage
02:11:37 <kstt> and 'Eq a' will be required for last stage
02:12:44 <ski> kstt : "such a project" being ?
02:12:53 <ski> kstt : yes
02:13:49 <ski> we have four cases
02:14:25 <ski>   Elements as0 == Elements as1 = ...
02:14:50 <ski>   Double t0    == Double t1    = ...
02:15:04 <ski>   _            == _            = False
02:15:19 <ski> well, that makes it three cases, since i decided to use `_' instead
02:15:40 <ski> so, assuming both inputs here have type `BinTree a' (where we know `Show a')
02:15:53 <ski> in the first case we know `as0 :: a' and `as1 :: a'
02:16:07 <ski> so we can implement that by `as0 == as1', because we know `Show a'
02:16:27 <ski> in the second case, we know `t0 :: BinTree (a,a)' and `t1 :: BinTree (a,a)'
02:16:36 <ski> so, how to write the body there ?
02:16:47 <ski> and what instances will be passed around at run-time ?
02:16:58 <mbuf> from https://gist.github.com/1466063 how can I get only the 'Version' field from the .cabal file and print it?
02:17:54 <sshine> grep?
02:43:43 <mbuf> Enigmagic: from https://gist.github.com/1466063 how can I get only the 'Version' field from the .cabal file and print it, programatically?
02:53:23 * hackagebot iteratee 0.8.7.5 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.7.5 (JohnLato)
02:55:14 <ski> danr : ok, ty
02:57:52 <danr> ski: :)
02:57:56 <ski> danr : i think Chris Okasaki has also written some on numeral-based collection data structures -- e.g. in his book "Purely Functional Data Structures"
02:58:18 <ski> (possibly that incorporates some of that research by Hinze, i don't know)
02:58:39 <danr> ski: aha. I didn't read much of Okasaki's book yet.
02:58:51 <ski> the book is apparently from 1999-06-13
02:59:12 <ski> and that paper seems to be published in 1998, so that could be the case
02:59:57 <ski> btw, general question : does that book has a commonly used abbreviation, like "PFDS" (or maybe "PFD") ?
03:01:32 <opqdonut> I haven't seen one
03:01:44 <opqdonut> hmm, people tend to call it "okasaki"
03:03:06 <quicksilver> yes, people call it okasaki
03:03:16 <quicksilver> in my hearing, at least
03:06:20 <osfameron> quicksilver: do you wonder if they have some saucier name for it that they use the moment your back is turned?
03:07:36 <quicksilver> osfameron: not until today, I didn'
03:09:07 <ski> @where okasaki
03:09:08 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
03:13:25 * hackagebot happstack-static-routing 0.1 - Support for static URL routing with overlap detection for Happstack.  http://hackage.haskell.org/package/happstack-static-routing-0.1 (MagnusCarlsson)
03:33:56 <mm_freak_> does anyone actually read the haskell-cafe-owner mails?
03:34:06 <mm_freak_> i have never received a reply and i'm having problems for years now
03:34:09 <mm_freak_> it's very annoying
03:43:38 <hpaste> mbuf pasted “Print haskell package name” at http://hpaste.org/55211
03:49:50 <joe9> need some help, please? i have a grid size of x-axis = 10, y-axis = 10, and I need to get a list of grid points for that size such as [(0,0),(0,1),(0,2)..]
03:50:08 <joe9> wondering if there is something in haskell that can simplify doing it.
03:50:19 <opqdonut> > range ((0,0),(9,9))
03:50:21 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1...
03:50:25 <joe9> I can just have 2 functions and loop them up as an inner loop.
03:50:33 <opqdonut> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Ix.html
03:50:35 <joe9> opqdonut: that is awesome, thank.
03:50:58 <opqdonut> Ix is the type class for array indices
03:51:02 <opqdonut> it has useful stuff like that
03:52:56 <bashoo> what does !! mean?
03:53:02 <joe9> indexOf
03:53:18 <joe9> > [0..9] !! 1
03:53:19 <lambdabot>   1
03:53:47 <bashoo> [10..15] !! 1
03:53:52 <bashoo> > [10..15] !! 1
03:53:53 <lambdabot>   11
03:54:04 <bashoo> > [10..15] !! 5
03:54:05 <lambdabot>   15
03:54:35 <bashoo> thanks
03:56:18 <bashoo> I'm doing project euler problem 2 so I'm reading about generating fibonacci numbers
03:57:10 <bashoo> is there a knowledgebot in here?
04:00:32 <silver> depends on what kind of knowledge do you seek
04:01:03 <silver> you can search for a fucntion by name or by type (in this channel or in private message to lambdabot)
04:01:10 <silver> @hoogle Int -> Int
04:01:13 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
04:01:14 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
04:01:14 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
04:01:41 <silver> or check source for (only Prelude?) functions
04:01:49 <silver> @src foldr
04:01:49 <lambdabot> foldr f z []     = z
04:01:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:01:57 <MostAwesomeDude> @hoogle [a] -> Bool
04:01:58 <lambdabot> Prelude null :: [a] -> Bool
04:01:58 <lambdabot> Data.List null :: [a] -> Bool
04:01:59 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
04:02:36 <MostAwesomeDude> There's tons of secret stuff in lambdabot too, maybe written down somewhere?
04:02:39 <MostAwesomeDude> @bid AAPL
04:02:39 <lambdabot> AAPL: bid $393.40, ask $393.50
04:02:42 <silver> @help
04:02:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:02:47 <silver> @list
04:02:48 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:03:15 <bashoo> thanks that ist he kind of thing I am looking for but I may need more explanation
04:03:42 <silver> also there's cool web-site called hoogle which does same thing as @hoogle
04:03:44 <silver> @where hoogle
04:03:44 <lambdabot> http://haskell.org/hoogle
04:04:28 <silver> (but generates larger lists of results and links to docs for functions, type etc.)
04:04:32 <bashoo> I'm just starting out with haskell so I don't really get all the syntax
04:05:21 <MostAwesomeDude> The syntax is relatively minimal, but there are lots of operators which look funky.
04:06:00 <bashoo> Yeah that is basically what I meant if syntax does not include operators
04:07:01 <silver> just ask if can't understand something
04:07:11 <silver> do you read some kind of book on haskell?
04:07:53 <bashoo> Right now I'm looking at http://book.realworldhaskell.org/read/getting-started.html but I was looking at the other one earlier
04:08:00 <bashoo> they are very similar so far
04:09:39 <joe9> opqdonut: the Data.Ix worked out very well for me. Just wanted to thank you again for your suggestion.
04:09:46 <silver> RWH is cool
04:09:52 <silver> there's also LYAH
04:09:55 <silver> @where LYAH
04:09:55 <lambdabot> http://www.learnyouahaskell.com/
04:10:26 <clsmith> i really got on well with graham hutton's "programming in haskell"
04:10:28 <silver> you can check it out if you encounter some problems while reading RWH (it's a bit outdated tight now, also there' plans to revise it)
04:11:33 <bashoo> I was using LYAH but was looking for other options maybe I dropped it too soon
04:11:41 <bashoo> thanks clsmith
04:11:43 <silver> you can use both :)
04:12:26 <clsmith> is there an existing function which, given a set of Ord a will give you all possible combinations of orderings, based on those which are EQ? or should i write it myself? :p
04:13:05 <clsmith> alternative question: is there a library for working out (heuristically) the best variable ordering for binary decision diagrams? >.>
04:14:09 <gfreezy> Hi guys. I come up with a problem when reading LYAH. "Writer" is defined as "newtype Writer w a = Writer { runWriter :: (a, w) } " while ghci says as "type Writer w = WriterT w Data.Functor.Identity.Identity". So the example in the book just went wrong.
04:14:11 <clsmith> i suspect the answers are "write it yourself" and "no", respectively.
04:14:44 <gfreezy> so how to do with it? thx
04:16:29 <gfreezy> The example is
04:16:30 <gfreezy> logNumber :: Int -> Writer [String] Int 
04:16:30 <gfreezy> logNumber x = Writer (x, ["Got number: " ++ show x])  
04:17:48 <Saizan> gfreezy: you can use writer as the constructor instead of Writer
04:18:16 <Saizan> gfreezy: and convert any pattern matching against it to uses of runWriter
04:18:33 <Saizan> gfreezy: or you could ignore the Writer from the libs and use your own
04:18:35 <kissyboy> yeah, that got changed in a recent mtl package
04:18:49 <gfreezy> it works
04:18:55 <gfreezy> thanks
04:19:32 <mrakan> init xs forces the traversal of the entire list, right?
04:19:34 <gfreezy> So the LYAH is sort of out of date ?
04:20:01 <Saizan> mrakan: if you force of all it
04:20:08 <Saizan> *all of
04:20:08 <kissyboy> i talked to the author about some of those out of date things, he said he'll fix them
04:20:29 <kissyboy> hope he does
04:20:32 <geheimdienst> > take 3 $ init [1..] -- mrakan: an infinite list. if init would force it, we'd never see the end of it
04:20:33 <lambdabot>   [1,2,3]
04:21:09 <geheimdienst> > last [1..] -- more problematic
04:21:13 <lambdabot>   mueval-core: Time limit exceeded
04:21:39 <mrakan> Saizan, geheimdienst: thanks! A similar question: length (init [1..1000000]) will take almost twice the time to compute than length (tail [1..1000000])?
04:22:04 <mrakan> Since tail only needs to access the second element.
04:22:19 <mrakan> (Or, drop the first one. And it's done.)
04:23:16 <Saizan> yeah, one would think so, unless GHC is fusing the lists away
04:23:19 <mrakan> And if so, can GHC be told to somehow `meld` length with init and make it only traverse the list once in total?
04:23:26 <mrakan> Ah, so it can fuse them?
04:23:59 <Saizan> list fusion is there, but i'm not sure if it handles this case
04:24:13 <mrakan> Great, thanks!
04:24:58 <Saizan> there's more than one technique to do it actually, Data.List uses foldr/build fusion, while there's a package that does stream fusion
04:27:08 <Saizan> mrakan: anyhow you should look at the RULE pragma, you can provide arbitrary rewrite rules to use during optimization with it
04:31:45 <mrakan> Saizan: I didn't know about the RULES pragma, thanks. It might prove useful.
04:39:00 <GordonFreeman> hello
04:39:04 <GordonFreeman> do you like fractals?
04:41:18 <ski> > let flip ' ' = '.'; flip '.' = ' ' in fix (\s -> repeat ' ' /\/ map flip s)
04:41:19 <lambdabot>   " .   . . .   .   .   . . .   . . .   . . .   .   .   . . .   .   .   . . ....
04:44:56 <vrook> For convenience I would like to say "let foo@(_:xs) = blah ..." as a shortcut for calling "tail foo". Why does Haskell care about the irrefutable pattern there, and why should this be a runtime error instead of compile-time error?
04:45:49 <ski> > let xor ' ' c = c; xor '.' ' ' = '.'; xor '.' '.' = ' ' in text . (" \n" ++) . unlines . take 8 $ iterate (\s -> zipWith xor (' ' : s) (s ++ " ")) "."
04:45:51 <lambdabot>  .
04:45:52 <lambdabot>  ..
04:45:52 <lambdabot>  . .
04:45:52 <lambdabot>  ....
04:45:52 <lambdabot>  .   .
04:45:53 <lambdabot> [3 @more lines]
04:45:56 <ski> @more
04:45:56 <lambdabot>  ..  ..
04:45:57 <lambdabot>  . . . .
04:45:59 <lambdabot>  ........
04:47:41 <geheimdienst> vrook: did you mean "let bar foo@(_:xs) = ..." ? you seemed to have no function name in there
04:48:02 <erus`> > unlines (replicate 5 (replicate 20 "FUCK "))
04:48:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:48:03 <lambdabot>         against inferred type...
04:48:16 <ski> > let foo@(_:xs) = [] in const foo ()
04:48:17 <lambdabot>   *Exception: <interactive>:3:4-18: Irrefutable pattern failed for pattern (f...
04:48:25 <ski> that's interesting
04:48:31 <ski> > let foo@(_:xs) = [] in ()
04:48:32 <lambdabot>   ()
04:48:47 <ski> > let foo@ ~(_:xs) = [] in const foo ()
04:48:48 <lambdabot>   []
04:49:07 <vrook> geheimdienst: nope, I mean let foo@(_:xs) = ...
04:49:28 <ski> vrook : i suspect it is a bug that `let foo@(_:xs) = [] in const foo ()' generates an error, while `let foo@(_:xs) = [] in ()' doesn't
04:49:50 <ski> vrook : maybe you could ask about this on the mailing list ?
04:50:02 <ski> vrook : you can avoid the error by using `~' as i showed
04:50:43 <ski> > let f foo@(_:xs) = foo in const (f []) ()
04:50:44 <lambdabot>   *Exception: <interactive>:3:4-21: Non-exhaustive patterns in function f
04:50:49 <ski> > let f foo@(_:xs) = () in const (f []) ()
04:50:50 <lambdabot>   *Exception: <interactive>:3:4-20: Non-exhaustive patterns in function f
04:50:58 <ski> > let f ~(foo@(_:xs)) = () in const (f []) ()
04:50:58 <lambdabot>   ()
04:51:01 <ski> > let f ~(foo@(_:xs)) = foo in const (f []) ()
04:51:02 <lambdabot>   *Exception: <interactive>:3:4-24: Irrefutable pattern failed for pattern ((...
04:51:28 <ski> hm, wait
04:51:48 <ski> i'm stupid, i should use `flip const', not `const' :(
04:52:03 <ski> > let foo@(_:xs) = [] in flip const foo ()
04:52:05 <lambdabot>   ()
04:52:16 <ski> > let f ~(foo@(_:xs)) = foo in flip const (f []) ()
04:52:18 <lambdabot>   ()
04:52:34 <ski> vrook : ok, forget everything i said :)
04:52:48 <ski> > let f foo@(_:xs) = foo in flip const (f []) ()
04:52:50 <lambdabot>   ()
04:52:53 <ski> > let f foo@(_:xs) = () in flip const (f []) ()
04:52:54 <lambdabot>   ()
04:53:02 <ski> > let f ~(foo@(_:xs)) = () in flip const (f []) ()
04:53:03 <lambdabot>   ()
04:53:59 <ski> vrook : anyway, what i suspect is happening in your code is that `foo' gets forced, and that will force the match with the pattern `_:xs' as well
04:54:53 <ski> vrook : if you want to be able to force `foo' without it needing to be a non-empty list, try using `let foo @ ~(_:xs) = blah ...' -- then forcing `foo' will not force the match with `_:xs' -- only forcing `xs' will do that
04:56:00 <vrook> f lst = let foo@(_:xs) = lst in xs -- My problem is that f [] is a runtime error. I can deal with this code being a compile-time error, but I don't understand the runtime error. It seems to go against Haskell philosophy.
04:57:54 <ski> vrook : as long as a pattern is type correct, it's never a compile-time error, in Haskell
04:58:14 <vrook> I suppose I expected (_:xs) = [] to be a non-error, giving xs == [].
04:58:27 <ski> well, that won't happen
04:58:28 <kmc> vrook, always compile with ghc -Wall, it will warn you about incomplete pattern matches
04:58:50 <kmc> vrook, aside from the special syntax, lists are an ordinary algebraic data type:   data List a = Nil | Cons a (List a)
04:59:08 <kmc> vrook, now, if you had «let (Cons _ xs) = Nil», you would not expect that pattern-match to succeed
04:59:11 <kmc> the constructors are different
04:59:16 <ski> vrook : what you *can* do, is to make sure that only forcing `foo' doesn't error out in case it was an empty list (but forcing `xs' will still error out if `foo' is an empty list)
04:59:23 <geheimdienst> > let Just x = Nothing in "vrook: in principle, pattern matches can always fail"
04:59:23 <lambdabot>   "vrook: in principle, pattern matches can always fail"
04:59:37 <geheimdienst> > let Just x = Nothing in x -- oops :)
04:59:38 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern Da...
04:59:41 <vrook> OK I get it, there is not anything ever that can be consed with [] to produce [], so the pattern doesn't make sense for [] on the right.
04:59:49 <kmc> yeah, exactly
04:59:58 <hpc> > []:[]
04:59:58 <lambdabot>   [[]]
05:00:11 <kmc> it's important too, for recursion on lists to work
05:00:19 <kmc> if [] = [] : [], then you'd get infinite loops more often than not
05:00:36 <ski> > fix $ \xs -> amb [] (error "element":xs)
05:00:37 <lambdabot>   Not in scope: `amb'
05:00:41 <kmc> i really appreciate that lists are an ordinary algebraic data type
05:00:44 <hpc> not to mention the types would break
05:00:46 <hpc> :t []
05:00:47 <lambdabot> forall a. [a]
05:00:49 <hpc> :t []:[]
05:00:50 <lambdabot> forall a. [[a]]
05:01:01 <kmc> there's always some complaining that Prelude doesn't include the super optimized types like ByteString and Text and Vector
05:01:11 <kmc> but I think it's good to keep Prelude conceptually simple
05:01:25 <kmc> people can import optimized data types if they want them
05:01:30 * ski agrees
05:01:55 <kmc> it is the opposite of what you'd expect from some other languages, though
05:02:00 <hpc> i like having String as a stream/list type
05:02:30 <ski> (in fact, i wouldn't think it too bad if you had to do `import Prelude' to acces it, as well)
05:02:42 <mm_freak_> sorry for bothering, but who is behind haskell-cafe-owner@haskell.org?
05:03:08 <kmc> @djinn Not (Not (Not p)) -> Not p
05:03:08 <lambdabot> f a b = void (a (\ c -> c b))
05:03:20 <kmc> ^^^ so, I understand this proof mechanically, but is there any nice intuition to it?
05:03:36 <kmc> something about continuation-passing style
05:03:38 <hpc> :t void
05:03:39 <lambdabot> Not in scope: `void'
05:03:47 <kmc> void :: Void -> a
05:03:54 <kmc> aka ex falso quodlibet, aka ⊥-elim
05:04:15 <hpc> kmc: so first i think we should expand the Nots
05:04:20 <kmc> is this f like 'join' for the Cont monad?
05:04:33 <hpc> f :: (Void -> Void -> Void -> p) -> Void -> p
05:04:41 <kmc> er, no
05:04:53 <hpc> did i have that backwards?
05:05:08 <hpc> @src Not
05:05:09 <lambdabot> Source not found. It can only be attributed to human error.
05:05:13 <kmc> f :: (((p -> Void) -> Void) -> Void) -> p -> Void
05:05:19 <hpc> ah, poo, yes
05:05:21 <kmc> type Not a = a -> Void
05:05:59 <hpc> and im gonna rename the parameters to be less confusing to me
05:06:02 <ski> @djinn Cont o (a -> o) -> (a -> o)
05:06:02 <lambdabot> f a b =
05:06:02 <lambdabot>     case a of
05:06:02 <lambdabot>     C c -> c (\ d -> d b)
05:06:09 <ski> @djinn (Cont o a -> o) -> (a -> o)
05:06:09 <lambdabot> f a b = a (C (\ c -> c b))
05:06:18 <hpc> proof f x = void (f (\g -> g x))
05:07:01 <ski> @djinn NotNot (Either (Not a) a)
05:07:01 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
05:07:13 <hpc> f :: ((p -> Void) -> Void) -> Void
05:07:16 <hpc> x :: p
05:07:20 <ski> kmc : at least there's a nice continuation-based explanation for that one
05:07:42 <kmc> hey that's cool, i hadn't seen djinn cough up a proof for LEM (or ¬¬LEM here)
05:07:46 <kmc> i know that proof, it's a fun one
05:08:33 <mjrosenb> kmc: lem == law of excluded middle?
05:08:36 <kmc> yes
05:08:43 <ski> (the outermost `void' in that proof is redundant)
05:08:53 <kmc> yeah, i noticed today that djinn sometimes does that
05:08:59 <kmc> void :: ⊥ → ⊥
05:09:12 <ski> mjrosenb : aka "Principle of Excluded Middle" (PEM) aka "Principle of Omniscience" (PO)
05:09:14 <erus`> @hoogle void
05:09:15 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
05:09:15 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
05:09:15 <lambdabot> package void
05:09:15 <kmc> it sees that it's proved ⊥ and just gets too excited to check whether the goal was also ⊥
05:09:28 <kmc> erus`, a different one
05:09:30 <kmc> @djinn-env
05:09:30 <lambdabot> data () = ()
05:09:30 <lambdabot> data Either a b = Left a | Right b
05:09:30 <lambdabot> data Maybe a = Nothing | Just a
05:09:30 <lambdabot> data Bool = False | True
05:09:30 <lambdabot> data Void
05:09:32 <lambdabot> type Not x = x -> Void
05:09:34 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
05:09:36 <lambdabot> class Eq a where (==) :: a -> a -> Bool
05:09:38 <lambdabot> type NotNot a = Not (Not a)
05:09:40 <lambdabot> data Cont o a = C ((a -> o) -> o)
05:09:41 <kmc> ok maybe that's too spammy, sorry
05:09:44 * ski thinks that FFI `void' ought to be called `unit'
05:09:48 <kmc> ski, did you add Cont just now?
05:09:54 <ski> kmc : yeah
05:09:58 <kmc> cool
05:10:06 <ski> (using `@djinn-add')
05:10:15 <vrook> Implementing Data.List is a great exercise for getting the basics down. I wrote a standard tail-recursive isInfixOf, but the "solution" is simply isInfixOf xs ys = any (isPrefixOf xs) (tails ys).
05:10:28 <hpc> kmc: in any event, the proof can be reduced to proof f x = void (f ($ x))
05:10:56 <ski> kmc : anyway, that proof of `Not (Not (Not p)) -> Not p' was known at least as far as Brouwer
05:11:06 * mjrosenb wonders if djinn can handle the annoying case yet
05:11:23 <ski> which annoying case ?
05:11:24 <mjrosenb> @djinn ((a -> b) -> a) -> a
05:11:24 <lambdabot> -- f cannot be realized.
05:11:31 * kmc wonders if there are situations in practical programming with continuations where you'd use LEM directly
05:11:38 <ski> Peirce's law ?
05:11:39 <hpc> vrook: that's basically the only way to do it
05:11:52 <hpc> vrook: or at least, that way doesn't waste work
05:11:55 <ski> @djinn ((a -> b) -> NotNot a) -> NotNot a
05:11:55 <lambdabot> f a b = void (a (\ c -> void (b c)) b)
05:12:00 <mjrosenb> ski: yeah, knew it had a name
05:12:01 <ski> (note that `NotNot' is a monad)
05:12:15 <mjrosenb> ahh you need to use NotNot :-o
05:12:23 <kmc> NotNot a = Cont ⊥ a
05:12:27 <mjrosenb> is it different from the Identity monad other than in name?
05:12:28 <mjrosenb> oh.
05:12:29 <hpc> ski: isn't it Identity, modulo cont-wobbliness?
05:12:29 <ski> mjrosenb : yeah, otherwise it would have a side-effect :)
05:12:50 <hpc> oh, yay
05:12:52 <ski> hpc : no, you can't extract a value of type `a' out of `NotNot a'
05:13:12 <quicksilver> kmc: well, if you take a totally different view, LEM, is just case-elimnation for Either or Maybe, so we use it quite often
05:13:24 <ski> hpc : you *can* extract a value of type `a' out from `forall o. Cont o a', though (the `forall o. ' bit is important, here)
05:13:29 <kmc> quicksilver, is it?
05:14:31 <ski> hpc : another way to see this, is that if you could extract an `a' out of an `NotNot a', then you could extract an `Either (Not a) a' out of that proof of `NotNot (Either (Not a) a)' above :)
05:14:43 <ski> (and we think that's impossible, as long as we use no side-effects)
05:14:56 <hpc> oh yeah, i see now
05:15:06 <kmc> right, ¬¬a → a  is the essence of classical, non-constructive logic
05:15:07 <ski> (or at least, as long as that value of type `Not a' can be used more than one time, or forgotten)
05:15:07 <hpc> because the type is ((a -> Void) -> Void)
05:15:18 <ski> yeah
05:15:35 <kmc> so constructively, some things hold under double negation which don't hold outside
05:15:45 <hpc> kmc: i think i managed to prove that implication in agda once...
05:15:45 <ski> a type `a' such that `a' is isomorphic to `NotNot a' is called "double-negation stable", or "negative"
05:16:31 <kmc> there's a restricted set of statements p for which  ¬¬p → p  constructively, which corresponds to eliminating the need for continuations by using CPS
05:16:34 <ski> kmc : yes, e.g. iirc `Not foo' is equivalent to `Not ((forall a. Either (Not a) a) -> foo)'
05:16:36 <hpc> oh, no i didn't
05:16:46 <mjrosenb> oh god, all of the three letter nicks :-o
05:16:55 <hpc> :D
05:17:43 <ani> three letter nick party
05:17:51 <ski> @djinn NotNot (((a -> b) -> a) -> a)
05:17:51 <lambdabot> f a =
05:17:51 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
05:18:39 <kmc> those _'s are interesting
05:18:46 <hpc> ski: oh cool, so that's what agda means by "everything must be strictly positive"
05:19:13 <kmc> you get one in the CPS implementation of call/cc, because invoking the captured continuation discards the "normal" continuation which was passed to you
05:19:33 <Saizan> not everything, just types you want to get a fixpoint of :)
05:19:55 <mjrosenb> what is the definition of void?
05:19:58 <mjrosenb> :src void
05:20:04 <hpc> @src void
05:20:04 <lambdabot> Source not found. You untyped fool!
05:20:10 * mjrosenb didn't think that would work
05:20:13 <kmc> void x = case x of {}
05:20:15 <kmc> except... not allowed
05:20:19 <kmc> but that's what it *should* be
05:20:19 <ski> @djinn ((a -> NotNot b) -> NotNot a) -> NotNot a
05:20:19 <lambdabot> f a b = void (a (\ c -> void (b c)) b)
05:20:27 <kmc> since the type of x has 0 constructors
05:20:44 <hpc> void = unsafeCoerce? :D
05:20:50 <kmc> that's assuming you have "data Void" with EmptyDataDecls
05:21:08 <kmc> in H98 you can use the hack "newtype Void = Void Void"
05:21:14 <mjrosenb> kmc: and x needs to be Void?
05:21:15 <kmc> in which case you write "void (Void v) = void v"
05:21:17 <ski> hpc : i think that "strictly positive" isn't directly related (only a little)
05:21:19 <hpc> if you define it as newtype Void = Void Void, you can write void x = fix Void
05:21:24 <kmc> mjrosenb, yeah, void :: Void -> a
05:21:32 <ski> hpc : `void u = case u of {}'
05:21:33 <kmc> it's the eliminator for Void, the way 'maybe' is the eliminator for Maybe
05:21:35 <hpc> er, or the other way
05:22:37 <ski> hpc : in Agda, it's defined as `void ()' (where `()' means a pattern that the type-checker can see there can't be any values which match, and therefore no RHS is needed)
05:23:34 <ski> kmc : you get similar `_'s if you prove `exists x. P x -> forall y. P y' (in classical logic, of course)
05:24:01 <ski> (and yes, that parses as `exists x. (P x -> forall y. P y)')
05:25:22 <kmc> forall P?
05:26:35 <mm_freak_> why is it so difficult to reach ML admins?  i'm seriously considering stopping using the MLs, because there isn't even any useful contact information
05:26:50 <sshine> mm_freak_, ML admins?
05:27:09 <sshine> as in ML languages?
05:27:16 <hpc> sshine: short for "Miranda Lookalikes" ;)
05:27:34 <quicksilver> mailing list.
05:27:39 <mm_freak_> really, haskell-cafe-owner@haskell.org is a totally useless contact address, if nobody seems to actually read the mails…  for years i've been asking for support many times and never received a single response
05:27:41 <hpc> oh
05:28:09 <quicksilver> mm_freak_: give these people a shove : http://www.haskell.org/haskellwiki/Haskell.org_committee
05:28:18 <hpaste> ski pasted “exists x. (P x -> forall y. P y)” at http://hpaste.org/55216
05:28:38 <ski> kmc : yes
05:28:40 <mm_freak_> quicksilver: thanks
05:28:47 <ski> also for all `a'
05:29:04 <ski> kmc : see that proof above ^ in (classical logic) sequent calculus
05:29:31 <ski> kmc : the two uses of `W' (weakening) correspond to `_'s
05:29:44 <kmc> nicely laid out, did you use special software for that?
05:29:53 <ski> `C' (contraction) correspond to using something (here a continuation) twice
05:29:57 * kmc used to typeset these things in LaTeX with bussproofs, like a billion years ago
05:30:03 <ski> nope, handwritten
05:30:11 <kmc> nice
05:30:47 <kmc> is there a common name for «∃ x. P x → ∀ y. P y» ?
05:31:04 <ski> one could add proof terms in there as well (which would muck around with continuation expressions as well as value expressions)
05:31:17 <mm_freak_> sorry for the rant anyway, but this channel seemed to be my last chance to reach anyone
05:31:25 <kmc> is it the principle of omniscience?
05:32:16 <ski> note that, if one would be pedantic, i've proved (expressed in terms of type theory) : `A : * , P : A -> * , a : A |- exists x : A. (P x -> forall y : A. P y)'
05:32:32 <ski> the `a : A' part here is important (i suppose i could have written it `_ : A')
05:32:45 <ski> it expresses that we need to know the domain is inhabited (nonempty)
05:33:47 <kmc> mm, right
05:33:50 <ski> cf. proofs like `forall u : Unicorn. TastesGood u |- exists u : Unicorn. TastesGood u', which also really assumes as well `_ : Unicorn'
05:35:05 <ski> (this is one good reason to not have to assumption in semantics / model theory that the domain has to be non-empty -- but to do that, you need to keep track of free variables in an expression/formula apart from just checking which actually *occurs* freely in it)
05:35:52 <ski> kmc : the principle of omniscience is `not A \/ A'
05:36:30 <ski> kmc : i don't know of a common name for the property i gave a proof for. i just saw someone in ##logic recently trying to prove it
05:37:10 <kmc> it seems bizarre that this would be true, until you think about it for a second
05:37:38 <ski> "this" being `not A \/ A', or `exists x. (P x -> forall y. P y)' ?
05:38:17 <ski> (in case of the latter : yes, which was why i initially thought it to be false, when that person was mentioning it :)
05:38:54 <benmachine> ski: hmm, I remember reading about the latter
05:38:58 <kmc> the latter
05:39:19 <Saizan> "drinker paradox" is a common name for it, fsvo common
05:39:24 <kmc> the former seems totally obvious until you think about it for more than a second
05:39:26 <kmc> ;)
05:39:29 * ski thinks it's interesting that `not (forall a. Not a \/ a)' is provable in two branches of constructive mathematics (intuitionism (Brouwer's school), and recursive mathematics (Markov's russian school))
05:39:36 <benmachine> http://www.cs.toronto.edu/~trebla/personal/weblog/any-all-some.html it's discussed at the bottom of this page
05:39:51 <kmc> what's the story behind "drinker paradox"
05:40:25 <ski> kmc : another example of a maybe similar-feeling "paradox" is `(p -> q) \/ (q -> p)'
05:40:27 <Saizan> P x = x is someone who drinks in the pub
05:40:41 <benmachine> kmc: just phrasing it as "in every nonempty pub there is someone who if they drink everyone drinks"
05:41:21 <kmc> philosophers produce a lot of ideas phrased in terms of eating and drinking
05:41:23 <kmc> just sayin'
05:42:28 * ski recalls seeing lots of examples of sentences like "sue hits john." when parsing (very small) fragments of natural language in a logic programming course
05:42:30 <kmc> ski, hmm, that one also feels weird due to an intuitive bias towards relevance
05:42:54 <kmc> but yeah, it is similar in the other way
05:43:06 <alistra> ./beep
05:43:06 <ski> @djinn NotNot (Either (a -> b) (b -> a))
05:43:06 <lambdabot> f a = void (a (Right (\ b -> void (a (Left (\ _ -> b))))))
05:43:12 <geheimdienst> philosophers also seem to eat with two forks, for whatever reason
05:43:13 <ski> yay !
05:43:45 <kmc> two chopsticks maybe
05:43:49 <hpc> @djinn NotNot (a -> b)
05:43:50 <lambdabot> -- f cannot be realized.
05:43:52 <hpc> aw
05:43:53 <kmc> they should eat dumplings
05:44:01 <kmc> you can eat them with one chopstick
05:44:05 <kmc> (except soup dumplings)
05:44:20 <geheimdienst> kmc, i checked wikipedia before i wrote. it *is* two forks :)
05:44:46 <vrook> Doesn't the paradox boil down to the English language translation of F => T? It makes sense when stated directly -- "If I am Batman, then the Universe is pink" -- but in other variations it sounds paradoxical.
05:45:07 <kmc> vrook, which paradox
05:45:12 <vrook> drinker paradox
05:45:28 <kmc> vrook, only partially
05:45:52 <kmc> it also invokes the law of excluded middle
05:46:21 <ski> (though not surprising : if `Phi' is provable in classical propositional logic, then `not not Phi' is provable in intuitionistic propsitional logic -- Glivenko, 1929)
05:47:00 <kmc> vrook, you break it down into "everyone drinks" or "someone doesn't drink", in the latter case it's what you said (ex falso quodlibet) but in the former case you're already done
05:50:54 <ski> kmc,vrook : comparing with how `P(A|B,Gamma)' is related to `P(B|A,Gamma)' in probability theory might be interesting
05:51:59 <ski> (you could decide that "`A' supprts `B', given background knowledge `Gamma'" should mean that `P(B|A,Gamma) > P(B|Gamma)')
05:52:33 <kmc> on that note i was reading about "intuitionistic bayesianism" the other day: http://brian.weatherson.org/conprob.pdf
05:53:16 * ski has been reading Edwin T. Jaynes' "Probability Theory: The Logic of Science", a bit
05:53:34 <ski> kmc : ty
05:57:18 <ski> kmc : another way is to assume `P x', then when given `y', we use PO on `P y', and either succeed immediately, or jump back and set the `x' in `exists x. P x -> ...' to `y', and since `P y' is false, the implication it vacuous now
05:58:09 <ski> (exercise, are these two proof equivalent ? e.g. try to convert them both to sequent calculus)
06:00:00 <kmc> in that case the initial 'x' is from the proof that P's domain is inhabited?
06:00:16 <ski> yes
06:00:51 <ski> (you need that too, in the "everyone drinks" case in the former proof)
06:08:16 <vrook> I have question about Hempel's ravens. I would say there is an infinity of distinct objects in the universe which can be named, making the confirmation value of any non-black object zero. It seems such an obvious solution, I can't believe how much is written about ravens.
06:11:28 <russellw> vrook, sort of. If there are infinitely many objects, there are infinitely many ravens, so it is still finite...
06:12:15 <russellw> So yes, observation of a red herring is indeed confirmation - but it is extremely weak confirmation, because nonravens vastly outnumber ravens
06:15:19 <ski> vrook : Jaynes' position is "Whether an `instance of a hypothesis' does or does not support the hypothesis depends on the alternatives being considered and on the prior information"
06:16:44 <vrook> russellw: there are infinitely more real numbers than rational numbers. You can't cancel infinities out to make something finite.
06:17:27 <russellw> vrook, I'm not just canceling infinities. By both statistical mechanics and quantum mechanics, any sufficiently large chunk of matter has a finite probability of spontaneously rearranging itself into a Raven
06:18:27 <joe9> what is wrong with this: http://codepad.org/ddCL49Av
06:18:44 <joe9> i think I am missing something simple. Any suggestions, please?
06:19:01 <joe9> just the spaces or the newline works.
06:19:16 <joe9> but putting them together as (spaces >> newline) does not.
06:20:24 <ski> i think possibly `spaces' greedily eats the newline as well (it's a whitespace character)
06:20:48 <ski> (and because `spaces' presumably doesn't use `try' it will refuse to backtrack to find the solution)
06:20:58 <joe9> oh, ok. thanks.
06:21:45 <ski> (imo, this is evidence that Parsecs default of no backtracking unless you explicitly inserts a `try' is bad (i'm not sure what would be better, though))
06:23:06 <ski> @hoogle manyTill
06:23:06 <lambdabot> Text.ParserCombinators.ReadP manyTill :: ReadP a -> ReadP end -> ReadP [a]
06:23:06 <lambdabot> Text.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
06:23:06 <lambdabot> Text.ParserCombinators.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
06:23:13 <ski> joe9 : ^ might be useful
06:23:33 <joe9> ski, thanks a lot. exactly what I need.
06:23:34 * hackagebot yesod-auth 0.7.7.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.7.2 (MichaelSnoyman)
06:23:35 <vrook> russellw: I can construct a diagonal argument to show that spontaneous crows are beaten out by everything else.
06:24:46 <russellw> vrook, or you could construct a diagonal argument to show that spontaneous ravens dominate everything else. But neither of those would correspond to a realistic distribution
06:25:38 <russellw> as ski remarked earlier, Jaynes observes that to figure out exactly how much an observation supports the hypothesis, depends on a number of factors
06:26:33 <russellw> But in general, any observation that has a nonzero chance of yielding a white raven, and fails to do so, supports the hypothesis of the nonexistence of white ravens
06:26:49 <russellw> That much simply follows from Bayes
06:27:49 <vrook> russellw: I would like to see your proof that spontaneous crows dominate.
06:28:20 <ski> yeah, so it depends on the prior probability of "chance of yielding a white raven" (i.e. whether we *think* it's possible)
06:28:37 <vrook> Why isn't the universe filled with crows?
06:28:50 <russellw> Easy. List all objects in the universe in this order, x.xx.xxx.xxxx.xxxxx. etc where x is a spontaneous raven, and . Is something else
06:29:10 <russellw> And the answer is because diagonal arguments don't prove anything about proportions
06:29:18 <benmachine> russellw: is it possible to list all objects in the universe?
06:29:32 <vrook> You are assuming the Universe has a countable number of objects, which I can immediately disprove.
06:29:40 <joe9> ski, I seem to be missing something: parseTest ((manyTill spaces "\n") >> newline) "   \n"
06:29:55 <ski> (of course, to have a prior probability of zero means basically that you claim that no amount of evidence for it can convince you : i.e. you're always convinced that there *must* be something wrong with the experiment or the analysis, regardless of the amount of evidence, and how well-controlled the experiment and how well-done the analysis was)
06:30:11 <russellw> benmachine, if you don't insist on the list being of finite length, and if you assume each object is only measured to finite precision, it may be
06:31:03 <benmachine> russellw: the finiteness of precision seems suspect
06:31:24 <russellw> Complain to vrook, he was the one who brought diagonal arguments into this in the first place :)
06:31:49 <benmachine> russellw: I suspect his diagonal argument is different
06:32:02 <russellw> oh?
06:32:05 <ski> joe9 : i think `manyTill' will eat the final thing as well, so try `manyTill spaces newline' (mayhaps wrapping parts in `Control.Monad.void', to make it type-check)
06:32:14 <joe9> ok, thakns.
06:32:18 <vrook> russellw: I can't believe started out with a countable number of objects in the universe.
06:32:45 <russellw> vrook, what's your argument?
06:32:49 <benmachine> vrook: how do you intend to prove there are a countable number of objects
06:32:54 <benmachine> er
06:32:55 <benmachine> aren't
06:33:34 * hackagebot FailureT 15321.1 - Failure Monad Transformer  http://hackage.haskell.org/package/FailureT-15321.1 (MatthewFarkasDyck)
06:34:10 <shapr> hrm
06:35:18 * ski . o O ( "15321.1" ? )
06:35:36 <cheater> indeed.
06:37:16 <vrook> benmachine: Does QM describe reality, or not? Take the hydrogen atom. We can write down the PDE explictly, and the eigenvalues correspond with experiment.
06:37:29 * fryguybob offers to sell a Banach–Tarski perpetual motion machine.
06:38:34 * hackagebot atl 15321.2 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15321.2 (MatthewFarkasDyck)
06:46:39 <benmachine> vrook: I dunno
06:49:37 <ski> > factor 15321
06:49:39 <lambdabot>   [(3,1),(5107,1)]
06:50:47 <Martty> haskell is not a programming language, its just a nifty calculator
06:50:55 <alistra> > 2^34254
06:50:56 <lambdabot>   303020125698171230332557515210095578138537695728873892639751320620243334048...
06:51:27 <alistra> except it always trims the answer :(
06:51:35 <alistra> i heard that in the professional edition it shows it all
06:51:55 <Martty> get the 30 day trial and compute by parts
06:52:48 <alistra> you can hack it with mod and div
06:52:51 <alistra> ;o!
06:54:51 <cjay> - to read this message get a haskell gold account -
06:58:15 <eikke> what's today the most commonly used enumerator/iteratee package?
06:59:55 <parcs> enumerator probably
07:00:10 <parcs> no one knows for sure!
07:07:34 <ski> @let showTree :: Show a => Tree a -> String; showTree = showsPrecTree showsPrec 0
07:07:34 <lambdabot>  <local>:14:51:
07:07:34 <lambdabot>      Couldn't match expected type `String' against inferred t...
07:07:46 <ski> @let showTree :: Show a => Tree a -> String; showTree t = showsPrecTree showsPrec 0 t ""
07:07:47 <lambdabot>  Defined.
07:07:55 <ski> > showTree (iterateTree (\n -> [0 .. n-1]) 3)
07:07:57 <lambdabot>   "Node 3 [Node 0 [],Node 1 [Node 0 []],Node 2 [Node 0 [],Node 1 [Node 0 []]]]"
07:08:08 <ski> > showTree (iterateTree (\n -> [n-1,n-2 .. 0]) 3)
07:08:09 <lambdabot>   "Node 3 [Node 2 [Node 1 [Node 0 []],Node 0 []],Node 1 [Node 0 []],Node 0 []]"
07:08:34 * hackagebot plugins-auto 0.0.3 - Automatic recompilation and reloading of haskell modules.  http://hackage.haskell.org/package/plugins-auto-0.0.3 (FacundoDominguez)
07:08:46 <ski> > showTree (iterateTree (map (subtract 1 . fst) . factor) 30)
07:08:47 <lambdabot>   "Node 30 [Node 1 [],Node 2 [Node 1 []],Node 4 [Node 1 []]]"
07:28:07 <ski> > (take 6 . map (first (1 +)) . increasingSubseqIndicesBy length . map factor) [1 ..]
07:28:09 <lambdabot>   [(1,[]),(2,[(2,1)]),(6,[(2,1),(3,1)]),(30,[(2,1),(3,1),(5,1)]),(210,[(2,1),...
07:28:19 <ski> > (drop 3 . take 6 . map (first (1 +)) . increasingSubseqIndicesBy length . map factor) [1 ..]
07:28:21 <lambdabot>   [(30,[(2,1),(3,1),(5,1)]),(210,[(2,1),(3,1),(5,1),(7,1)]),(2310,[(2,1),(3,1...
07:28:32 <ski> > (drop 4 . take 6 . map (first (1 +)) . increasingSubseqIndicesBy length . map factor) [1 ..]
07:28:34 * hackagebot happstack-server 6.4.5 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.4.5 (JeremyShaw)
07:28:34 <lambdabot>   [(210,[(2,1),(3,1),(5,1),(7,1)]),(2310,[(2,1),(3,1),(5,1),(7,1),(11,1)])]
07:32:01 <fryguybob> @oeis 1 2 6 30 210
07:32:01 <lambdabot>  Primorial numbers (first definition): product of first n primes. Sometimes w...
07:32:02 <lambdabot>  [1,2,6,30,210,2310,30030,510510,9699690,223092870,6469693230,200560490130,74...
07:35:20 <mjrosenb> is it bad if i remember my so's birthday by multiplying primes until i get something that looks like a date?
07:35:49 <sipa> yes
07:36:00 <snappy> give the composites a chance
07:36:08 <Proge> haha
07:37:23 <Proge> finally i get something in #haskell
07:38:07 <Proge> maths can be funny
07:40:17 <mjrosenb> Proge: oh no! we'll have to increase the esotericity of the channel to make you feel like old times!
07:40:27 <Proge> thats better
07:40:35 <Proge> back to googling words for me
07:42:54 <Proge> and god said let there be wikipedia
07:47:47 <w4llybrz> Hello everyone
07:48:02 <Proge> hello :)
07:48:36 <w4llybrz> Does anybody here could help me with school homework?
07:48:49 <kmc> just ask your question
07:48:59 <dgpratt> w4llybrz: does it involve Haskell?
07:49:03 <w4llybrz> yes
07:49:16 <w4llybrz> It's about natural deduction
07:49:28 <w4llybrz> does anybody see something like this before?
07:50:00 <Proge> i'm seeing it now
07:50:38 <w4llybrz> me too, and I hope I will never see this again
07:51:00 <Proge> i'm affraid you'll see it everywhere
07:51:33 <w4llybrz> But haskell is not my area
07:51:49 <Proge> nor mine
07:51:50 <w4llybrz> I dont like functional programing
07:52:00 <Proge> you're doing it now
07:52:01 <kmc> just ask your question
07:52:07 * jessopher is confused about the context of this conversation
07:52:11 <kmc> put it on hpaste.org if you want
07:52:27 <parcs> w4llybrz: blasphemy!!
07:52:34 <kmc> ugh
07:52:41 <w4llybrz> My question is: Does anybody here have something about natural deduction implemented in haskell?
07:52:52 <w4llybrz> parcs: why?
07:53:04 <Proge> thats two questions now
07:53:11 <Proge> can you multithread?
07:53:15 <parcs> w4llybrz: i am kidding
07:53:22 <w4llybrz> parcs lol
07:53:59 <w4llybrz> Oh my question is just: Does anybody have something about natural deduction implemented in haskell?
07:54:24 <cheater> define "natural deduction"
07:54:48 <Proge> that thing what his teacher said to learn about
07:54:50 <dolio> How would you implement it in Haskell? It's a style for presenting inference rules.
07:55:06 <w4llybrz> In logic and proof theory, natural deduction is a kind of proof calculus in which logical reasoning is expressed by inference rules closely related to the "natural" way of reasoning. This contrasts with the axiomatic systems which instead use axioms as much as possible to express the logical laws of deductive reasoning.
07:55:29 <Proge> wikipedia is awesome
07:55:31 <quicksilver> dolio: something like this perhaps? :) http://www.cs.ox.ac.uk/people/bernard.sufrin/personal/jape.org/
07:55:41 <quicksilver> rather beyond the scope of a single homework methinks.
07:55:44 <w4llybrz> I need to user Parse to regognize if the rules are correct
07:56:15 <w4llybrz> use*
07:57:21 <sinelaw> Peaker, yo!
07:57:25 <Proge> google parse deductive reading
07:57:31 <Proge> then read the pdf
07:57:33 <Proge> and get confused
07:57:37 <w4llybrz> hahahahaha
07:57:46 <Proge> deductive reasoning* :)
07:57:52 <dolio> quicksilver: It's hard to tell from skimming. What is that exactly? A proof editor/checker?
07:58:11 <quicksilver> dolio: yes.
07:58:12 * jessopher applies deductive reading to this irc channel :P
07:58:26 <Proge> haha
07:58:29 <dolio> The checker is probably not beyond the scope of a homework assignment.
07:59:04 <Proge> w4lly just say you forgot your homework
07:59:11 <Proge> but it was awesome!
07:59:18 <daimrod> natural deduction, that sounds like a job for prolog.
08:00:09 <hpaste> Hampster pasted “Natural Deduction” at http://hpaste.org/55221
08:00:40 <wereHamster> a hampster? An imposter!!
08:00:52 <w4llybrz> lol
08:00:56 <ski> O.o
08:01:52 <ski> (usually we tell people they should have pasted code on a paste site, not into the channel -- i believe this is sort of a case of the converse)
08:01:56 <w4llybrz> Prodge I need do to do it
08:02:04 <w4llybrz> otherwise I wont pass
08:02:05 <w4llybrz> =[
08:02:15 <Proge> hey you pronounced my name right!
08:02:51 <wereHamster> ski: you scare people off, then they only communicate through the pastebin
08:03:22 * ski wonders when he scared people off
08:03:27 <parcs__> w4llybrz, when is it due
08:04:13 <w4llybrz> parcs__: on Thursday bro... I'm lost
08:04:19 <w4llybrz> parcs__: hahaha
08:04:35 <Proge> do you know the people in your class yet?
08:04:45 <kmc> w4llybrz, do you know any Haskell?
08:04:50 <kmc> that's a place to start
08:04:51 <w4llybrz> parcs__: My friend sent me to this channel, he said my homework is not human
08:05:14 <w4llybrz> Prodge a friend of mine is helping me... But its hard
08:05:21 <Proge> get in contact with everybody in your class
08:05:29 <Proge> find out who has done their homework
08:05:33 <w4llybrz> kmc: I know a little but I don't know Parsers
08:05:36 <Proge> ask them to explain to you
08:05:45 <kmc> why do you keep capitalizing Parser
08:05:58 <kmc> w4llybrz, maybe read http://book.realworldhaskell.org/read/using-parsec.html
08:06:02 <w4llybrz> kmc: lol... I don't know
08:06:08 <parcs__> maybe he has to use parsec
08:06:14 <w4llybrz> Yes
08:06:15 <Proge> because he things its key to his understanding
08:06:20 <w4llybrz> My teacher said the parsec lib
08:06:24 <Proge> but doesn't understand it
08:06:28 <Proge> thinks*
08:06:29 <kmc> ok well that link is about parsec
08:06:36 <w4llybrz> Ok thanks
08:06:40 <w4llybrz> I will check it out
08:07:19 <Proge> or go see the teacher and tell him you don't understand
08:07:24 <Proge> which ever you find easier :)
08:08:19 <Proge> learn to learn
08:08:25 <Proge> its easier than learning haskell
08:08:32 <kmc> heh
08:08:34 <kmc> not exactly
08:08:38 <kmc> but more useful
08:09:07 <w4llybrz> Prodge: The big deal is that I don't like haskell and my teacher scares the whole class
08:09:23 <Proge> yeah he's made haskell your problem
08:09:31 <Proge> go make it his again
08:09:48 <Proge> teach him to teach
08:09:58 <w4llybrz> hahaha
08:10:44 <Proge> thats called interfaces btw
08:10:49 <Proge> you'll learn that in time ;)
08:10:53 <dolio> Why don't you like Haskell?
08:11:37 <w4llybrz> dolio: I don't know, I think I will never use it
08:11:42 <Ornedan> How does one set a memory limit on the ghc spawned by Haskell mode in Emacs?
08:12:13 <w4llybrz> dolio: I think Software Engineering is more useful
08:12:35 <kmc> Ornedan, make it invoke as  ghc +RTS -M128M
08:12:36 <kmc> or whatever
08:12:38 <kmc> i don't know how to do that
08:12:47 <kmc> w4llybrz, why did you take this class?
08:13:11 <dolio> I definitely get more use out of Haskell than I do out of the stuff that was in my software engineering class.
08:13:25 <dolio> But that may just be me.
08:13:38 <Peaker> sinelaw: hey!!
08:14:20 <w4llybrz> kmc: This class is mandatory in my course
08:14:29 <kmc> what kind of course is that?  college / university?
08:14:52 <VHD> for further studies haskell is very popular (at least in my uni), so it has its uses
08:15:05 <w4llybrz> In Brazil it is University. My course is TI
08:15:14 <kmc> the point of college isn't to teach you some programming language which is popular right now
08:15:18 <kmc> if you want that just buy a book
08:15:41 <w4llybrz> Because we see functional programing
08:15:41 <kmc> the point is to give you exposure to a wide variety of ideas
08:15:47 <w4llybrz> than we use prolog and haskell
08:16:06 <kmc> so that when the next flavor of the month language comes out, you already know the core concepts
08:16:10 <kmc> which change much less quickly
08:16:29 <dolio> Anyhow, I was going to say what kmc just said.
08:16:39 <kmc> but if you just want to know Java, drop out of school and buy a book about Java
08:16:53 <dolio> Same reason I had to take a course on classic literature in college (or something equivalent).
08:16:57 <w4llybrz> kmc: I know what you are talking about
08:16:58 <jessopher> and dont take that advice, even if you think its what you want
08:17:00 <dolio> Despite the fact that it isn't very relevant to my job.
08:17:09 <w4llybrz> The teachers said the same
08:17:09 <VHD> teaching stuff like advanced data structures is easier in Haskell, than say an imperative language.
08:17:22 <kmc> that said i don't think it's our job to make someone like haskell
08:17:31 <kmc> so, having agreed that you do not like it
08:17:38 <w4llybrz> ...
08:17:40 <w4llybrz> Man
08:17:42 <w4llybrz> See
08:17:51 <nimroda> Hi, newbie here. I just compiled a program with "ghc --make -shared -fno-warn-unused-imports -prof -auto-all -osuf .prof.o -caf-all -fforce-recomp 2" (2 is the name of the program), then ran it and got a segmentation fault. Can anyone please help me?
08:17:56 <w4llybrz> My course is about TI, here we called Systems of Information
08:18:10 <kmc> nimroda, can you show us the code?  do you have a minimal example?
08:18:27 <w4llybrz> We supposed to study how the process works in an organization and how to improve them using TI
08:18:44 <w4llybrz> I know that they are not going to teach me Java at college
08:19:22 <w4llybrz> But this class "functional programing" is not a good class for my course
08:19:26 <Patinho`Busy> hi all
08:19:49 <hpaste> Nimrod pasted “program crashing with segfault” at http://hpaste.org/55222
08:20:04 <kmc> w4llybrz, ok, we understand this.  please stop complaining about your university in this channel
08:20:38 <kmc> if you have more questions about haskell, we can help with those
08:21:19 <VHD> I have a question about haskell
08:21:28 <VHD> why do people not like haskell :p
08:21:41 * VHD hides.
08:21:41 <nimroda> kmc, I pasted my own code (which relies on a modified Dwarf library, which works fine without profiling) on http://hpaste.org/55222
08:21:55 <kmc> that's really too much code for me to digest :/
08:22:02 <kmc> did you try using gdb or something to locate the segfault
08:22:24 <dolio> VHD: because it's too hard to hire Haskell programmers, because you have to be too smart and handsome to learn it.
08:22:46 <VHD> :o
08:22:58 * jessopher feels much better about himself now
08:23:21 <nimroda> kmc, there's no backtrace: (gdb) bt
08:23:21 <nimroda> #0  0x00000001 in ?? ()
08:26:05 <kmc> so it jumped through an invalid pointer
08:26:07 <kmc> that's bad
08:27:16 <nimroda> kmc, ok thanks anyway
08:27:28 <kmc> try to make a smaller program which still crashes
08:27:45 <mjrosenb> dolio: itym "devilishly handsome"
08:27:52 <dolio> Of course.
08:27:54 <kmc> also i wonder about that unsafeMMapFile
08:28:07 <wereHamster> oh, you can crash a haskell application?
08:28:07 <kmc> you can run the program under strace to see how mmap is getting called and whether it succeeds
08:28:23 <wereHamster> I thought it was all pure and stuf.. 0.o
08:29:02 <kmc> wereHamster, "ordinary" Haskell code compiled with GHC will not segfault unless there's a GHC bug
08:29:08 <kmc> which has nothing to do with "pure"
08:29:14 <kmc> it's a property of the type system
08:29:32 <kmc> however there's plenty of things you can add to "ordinary Haskell" that make segfaults possible
08:29:35 <wereHamster> so how do I make haskell crash?
08:29:43 <kmc> like the Foreign module, FFI, various GHC primitives, and other "unsafe" libraries
08:29:51 <sshine> I suppose you can exhaust stack space?
08:30:10 <kmc> import Foreign; main = peek nullPtr >>= putChar
08:30:28 * wereHamster tries
08:30:31 <asflierl> whee peek
08:30:33 <kmc> the Foreign module gives you direct access to memory, C pointer arithmetic, etc
08:31:08 <wereHamster> indeed, SIGBUS
08:31:13 <kmc> OS X?
08:31:18 <wereHamster> yes
08:31:20 <kmc> ok
08:31:28 <kmc> for some reason OS X gives SIGBUS on null pointer dereference, and not SIGSEGV
08:32:01 <kmc> (how the hell does Storable Char work anyway?  does it assume ASCII?)
08:32:12 <quicksilver> 8bit truncation, kmc
08:32:17 <quicksilver> so latin-1, effectively
08:32:21 <kmc> *nod*
08:32:31 <kmc> i think it's wrong that Haskell types like Int, Char, etc. have Storable instances
08:32:32 <quicksilver> the way all haskell IO used to work until 7.0 ;)
08:32:33 <benmachine> that sounds sensible and not at all perverse
08:32:40 <kmc> as opposed to CInt, CChar, etc
08:32:42 <quicksilver> s/haskell/GHC/
08:33:01 <benmachine> quicksilver: wasn't it 6.12 that started assuming UTF8?
08:33:14 <kmc> at least, we should separate Storable into two classes, one for "serializable in some arbitrary way" and one for "corresponds exactly to a well-known C type"
08:33:19 <benmachine> huh, sizeOf 'a' is 4
08:33:39 <quicksilver> benmachine: oh. Maybe it's UCS32 then
08:33:46 <kmc> #ifdef __GLASGOW_HASKELL__
08:33:46 <kmc> STORABLE(Char,SIZEOF_INT32,ALIGNMENT_INT32, readWideCharOffPtr,writeWideCharOffPtr)
08:33:53 <quicksilver> or maybe it's platform dependendent
08:33:56 <kmc> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/Foreign-Storable.html
08:35:10 <benmachine> kmc: why do we need the latter?
08:35:24 <benmachine> or hmm
08:35:27 <kmc> for writing C marshalling code in Haskell
08:35:32 <benmachine> I guess the only reason we use Storable is for that
08:35:42 <kmc> no, it's used for serialization in other contexts
08:35:55 <NemesisD> what is the least waste-my-time-messing-around-with-ghc-pkg way to get around hidden package errors. in particular, i can't install cabal-dev with cabal
08:36:09 <kmc> www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
08:36:10 <NemesisD> the package containers-0.2.0.1 is hidden
08:36:14 <benmachine> kmc: isn't that what Binary/Serializable et al are for
08:36:42 <benmachine> NemesisD: that's weird, cabal is supposed to sort out all that stuff itself
08:36:44 <kmc> yeah it would be better to use those when possible
08:37:11 <kmc> Storable gives stronger guarantees, though
08:37:17 <kmc> like fixed size
08:37:36 <NemesisD> benmachine: i wish it would. this seems to happen to me every single time i try to get a sane dev environment going for haskell
08:37:47 <quicksilver> kmc: I think storable was only *intended* to be used to match C ABIs
08:37:54 <quicksilver> not for general serialization
08:37:57 <kmc> then why are there instances for Char, Int, etc
08:38:02 <kmc> which do not correspond to C types
08:38:06 <kmc> deceptive though the names may be
08:38:12 <quicksilver> you ask a fair question :)
08:38:20 <quicksilver> ""convenience"" I imagine
08:38:25 <kmc> it's not convenient at all!
08:38:27 <benmachine> NemesisD: cabal-dev always misbehaved when I used it, so I won't try to answer any more than that
08:38:37 <kmc> to overwrite a 4-byte struct field with 8 bytes because you mistyped Int instead of CInt
08:38:42 <kmc> or worse, had it inferred
08:38:51 <quicksilver> yup
08:38:57 <benmachine> NemesisD: except to say that cabal installation is theoretically supposed to ignore ghc-pkg deciding to hide or show whatever, and tell ghc what packages to use itself
08:39:03 <quicksilver> hence the double dose of scare quotes.
08:39:06 <kmc> this happens especially with CStringLen
08:39:07 <quicksilver> ""really"" scary
08:39:10 <kmc> yeah :)
08:39:36 <benmachine> quicksilver: if that was the original intent I think the name is a bit naff
08:39:41 <benmachine> or more than a bit, even
08:39:49 <benmachine> (no pun intended)
08:40:06 <NemesisD> benmachine: i don't care much to use it. i'd just as soon build the package i'm trying to build with plain cabal except that has its own set of problems, namely base-4.*.*.* was excluded because of the top level dependency base -any
08:40:25 <benmachine> NemesisD: ah, well, if you'd come to us with *that* problem we'd've been able to help
08:40:35 <NemesisD> benmachine: ok lets change my problem to that then ;)
08:40:46 <benmachine> NemesisD: that's a crappy error message that I believe cabal comes up with when it wants to upgrade base
08:40:51 <benmachine> but upgrading base is impossible
08:41:05 <benmachine> it may be that the package you're trying to install requires a different version of GHC from yours
08:41:14 <benmachine> or at least, thinks it does
08:42:00 <NemesisD> evidently that is containers-0.4.0.0
08:42:19 <benmachine> it's a bad idea to upgrade containers, I think
08:42:28 <kmc> oh?
08:42:40 <NemesisD> by upgrade do you mean my package depends on it?
08:42:50 <NemesisD> i
08:42:54 <benmachine> kmc: inasmuch as GHC indirectly depends on containers
08:43:13 <NemesisD> i'm trying to cross-compile for some outdated server we have using ghc 6.10, so it is older than my dev environment
08:43:14 <benmachine> kmc: if cabal builds and installs versions of boot packages that depend on the new containers, you might get irreparable breakage
08:43:19 <benmachine> that's my understanding anyway
08:43:24 <benmachine> actually
08:43:40 <benmachine> that would be fine as long as you install packages locally and not globally (and have GHC installed globally)
08:43:51 <kmc> why would cabal install new boot packages, though
08:44:38 <NemesisD> i'm cding into my package directory and running cabal install --only-dependencies
08:44:39 <benmachine> kmc: if you tried to install a new package that depended on containers-0.4 and a boot package, cabal would need to recompile the boot package against containers-0.4
08:45:06 <benmachine> NemesisD: what's your setup wrt local and global installs?
08:45:41 <Saizan> it'd be nice to see the build-depends for this package too
08:45:48 <mellum> is there something like C's nextafter in Haskell?
08:45:51 <NemesisD> benmachine: im not sure. i just installed ghc from yum, did no further configuration
08:45:53 <Saizan> and maybe a cabal-install --dry-run -v
08:46:18 <benmachine> NemesisD: where'd you get cabal?
08:47:10 <benmachine> mellum: I don't believe there is in the standard libraries, but a package might have it, or possibly you can work something out with encodeFloat and decodeFloat
08:47:23 <benmachine> mellum: or heck, you could foreign import nextafter fairly easily :)
08:47:43 <hpaste> NemesisD pasted “dependency problems” at http://hpaste.org/55223
08:48:09 <NemesisD> benmachine: i downloaded cabal-install from hackage
08:49:30 <mellum> benmachine: ok, thanks
08:52:59 <Saizan> NemesisD: well, you simply can't have containers == 0.4.* on ghc-6.10, you've to relax that constraint
08:54:09 <Saizan> the cabal-dev build error is probably something going wrong with #ifdef's
08:54:26 <NemesisD> Saizan: is there an easy way for me to tell what the highest version i can have is?
08:54:52 <NemesisD> i see the hackage pages show what versions its built on, but i assume thats not a hard dependency?
08:56:13 <Saizan> i'd try to see if it works with containers-0.2.0.1 which seems to be the version you've installed on your 6.10
08:56:41 <Saizan> there's only 0.3 in the middle, so i guess it's not hard to try to see if that builds too
08:56:55 <kmc> mellum, seconding the suggestion to foreign import it, if that's the exact behavior you want
08:57:43 <kmc> though, then you have to convert between Double and CDouble, or else potentially run afoul of the problems I was talking about a second ago
08:58:01 <NemesisD> ok. thanks!
08:59:20 <benmachine> kmc: but Double/CDouble conversion should be fast, right?
08:59:35 <kmc> probably
08:59:47 <kmc> i'm not thinking about 'fast' as the first goal
08:59:53 <kmc> i'm thinking about making the programmer's life easier
08:59:56 <benmachine> heh
09:00:05 <benmachine> sure
09:00:14 <benmachine> but you foreign import c'nextafter
09:00:19 <benmachine> and then define nextAfter as a wrapper
09:00:42 <kmc> right but unless someone has done that, mellum would have to
09:00:49 <kmc> which makes it less nice as a suggestion
09:01:02 <benmachine> you mean it's four lines isntead of one :P
09:01:08 <kmc> 4 times as long!
09:02:55 <kmc> it is not a hard problem to solve, and we know how to solve it, but that is not the same as the problem being solved
09:04:52 <quicksilver> kmc: like haskell's famous formal semantics :)
09:04:57 <kmc> haha
09:05:57 <quicksilver> "I have a proof of this theorem but since it won't fit in the margin of the IRC channel it is left as an exercise to the GSoC student"
09:07:27 <monochrom> apparently, a GSoC solution is none the better than "it won't fit in the margin"
09:08:15 <c_wraith> «newtype C a = C (a -> Integer)» what's the term for this?  Contravariant?
09:08:30 <kmc> C is a contravariant functor, yes
09:08:56 <c_wraith> thank you.  that is what I was going for.  (Inability to make it an instance of Functor)
09:09:04 <kmc> yep
09:09:09 <kmc> you can write (a -> b) -> (C b -> C a)
09:09:29 <c_wraith> Ah, now the name makes sense even.
09:10:22 <kmc> there's a class for them in one of edwardk's libraries, i'll bet
09:10:29 <c_wraith> I'm sure there is.
09:10:42 <hpaste> Patinho`Busy pasted “Problem understanding a small function. Yes, I'm a newbie. :/” at http://hpaste.org/55225
09:10:47 <Patinho`Busy> Can someone help me pls... :)
09:10:57 <c_wraith> So, is that the only way something with the right kind can be impossible to make an instance of Functor?
09:11:40 <kmc> Patinho`Busy, (upd n f xs) is the same list as xs  except at position n
09:11:58 <kmc> if the nth element of xs was x, then the nth element of (upd n f xs) is (f x)
09:12:03 <Peaker> c_wraith: Invariant too (and various GADTs can be a sub-case of that)
09:12:04 <kmc> the rest stay the same
09:12:24 <Patinho`Busy> hum.. thanks kmc. :)
09:12:27 <c_wraith> Peaker: hmm.  I don't know what Invariant means, in this context.
09:12:34 <kmc> data D a = D (a -> Int) (Int -> a)  -- neither covariant nor contravariant
09:12:38 <kmc> therefore "invariant"
09:12:40 <Peaker> c_wraith: if something uses the type arg in both positive and negative positions
09:12:49 <c_wraith> Ah, ok
09:12:55 <kmc> or hmm (a -> a) is a simpler example, isn't it
09:13:11 <kmc> @djinn (a -> b) -> (a -> a) -> (b -> b)
09:13:11 <lambdabot> f _ _ a = a
09:13:33 <Peaker> Data.Set is covariant -- but has restrictions on the type, and GADTs can place restrictions on the type -- that also prevents Functor'ism
09:14:12 <c_wraith> Well, yes.  I was thinking of things that were fully polymorphic, not running afoul of the issues with instances
09:14:29 <c_wraith> Err, issues with constraints, really
09:16:06 <c_wraith> After all..  The data type Set is based on could be made a functor...  It just would violate non-typed properties in how it's used.
09:17:10 <rwbarton> yep
09:17:29 <copumpkin> yeah, we should make it a functor instance with mapMonotonic
09:17:34 <copumpkin> that'd be lots of fun
09:18:22 <c_wraith> So, for invariant types, you would need both a -> b and b -> a to write something that acts like a functor
09:18:34 * hackagebot SVGFonts 1.1 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.1 (TillmannVogt)
09:18:47 <c_wraith> (a -> b) -> (b -> a) -> (f a -> f b)
09:21:27 <Peaker> data Invariant a where Invariant :: Invariant Char
09:21:35 <Peaker> Is this called invariant or something else?
09:22:35 <c_wraith> All of the above?
09:22:46 <ClaudiusMaximus> Default ?
09:23:48 <Peaker> c_wraith: anyway, a GADT like this cannot be made Functor/ContraFunctor/etc
09:24:14 <rwbarton> the term "invariant" has always seemed a little strange to me... not that I have a better one
09:24:15 <hpaste> benmachine pasted “nextAfters” at http://hpaste.org/55227
09:24:24 <benmachine> who was it who was asking about nextafter
09:24:43 <benmachine> mellum: http://hpaste.org/55227 for your perusal
09:27:07 <kmc> nice
09:32:00 <benmachine> kmc: I suspect it would go wrong on weird inputs, but the QC property passes 100 tests
09:32:33 <benmachine> (I do have a really odd guard on that case statement... possibly I shouldn't do that on any code I ever give to anyone)
09:37:03 <mellum> benmachine: interesting, thanks
09:41:38 <copumpkin> :t flip
09:41:39 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:41:46 <FckHaskell> :r
10:08:35 * hackagebot hashtables 1.0.1.2 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.2 (GregoryCollins)
10:18:54 <parcs__> with () (->) (,) Either and Mu can you make any type?
10:21:04 <c_wraith> well.  Not things with magic implementations (IORef, MVar, etc), but that's probably not what you mean.
10:21:41 <benmachine> parcs__: you'd also need some things like Flip and Const, I think
10:23:14 <parcs__> benmachine, hmm yeah
10:23:21 <siracusa> "Mu a" is "μ a.t(a)"?
10:23:44 <parcs__> i don't understand that notation but
10:23:46 <parcs__> @src Mu
10:23:46 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:24:04 <benmachine> Mu is fix on types
10:24:10 <benmachine> so it can do anonymous recursion
10:24:35 <elliottt> if i have a library that uses gmp, and i would like to write a haskell binding to it, but not ever pass Integers to it, will that work?
10:24:50 <benmachine> parcs__: I guess you'd need something SKI-ish for rearranging type variables
10:25:03 <benmachine> or maybe something less powerful, since you're only trying to get up to isomorphism
10:25:06 <c_wraith> elliottt: you define the types for the funuctions you import...
10:25:40 <Saizan> gmp does something fancy wrt gmp's memory allocation
10:25:41 <elliottt> yes, i'm wondering more about the problems that might arise between the interaction of the ghc runtimes use of gmp and the libraries
10:26:02 <c_wraith> so long as they dynamically link to the same gmp, I don't see the problem.
10:26:09 <elliottt> ghc changes the allocation strategy, so i'm wondering if that will be a problem if i'm not trying to move integers between the two
10:26:32 <hpaste> yshavit pasted “trim” at http://hpaste.org/55228
10:27:02 <c_wraith> ah, I see.  I have no idea if ghc's changes will mess with other libs' use of GMP.
10:27:31 <yshavit> hi all, I'm pretty new to haskell.. I wrote some [string, but generic] trim functions, and I was wondering if someone could take a look and basically grade this? Does it look like decent haskell? It works as far as I can tell, more looking for style / pattern feedback
10:28:04 <yshavit> I realize there's probably already trim functions (though actually, I couldn't find them on hoogle). This is more of an exercise
10:28:37 <Ololo> Umm, guys
10:28:43 <Ololo> primitive-0.4.0.1 ... ghc.exe: panic! (the 'impossible' happened
10:29:07 <yshavit> one specific question is on guards vs if-then-else. I use the if-then-else in my code, basically because it seems to be a bit more concise.
10:29:39 <Ololo> (GHC version 7.0.3 for i386-unknown-mingw32):     loadObj "C:\\Users\\\1053\1077 \1047\1086\1103\\AppData\\Roaming\\cabal\
10:29:58 <Ololo> The hell is this.
10:31:07 <parcs__> Ololo, windows
10:31:56 <c_wraith> yshavit: it seems like your trimr will only remove the last trailing matching character.  trimr 'a' "aa" will result in "a", if I'm reading that right.
10:32:55 <Ololo> parcs__: yep. cabal doesn't work for windows? haskell is not designed to be cross-platform? what's the problem?
10:33:02 <yshavit> c_wraith: it seems to work.  (trimr ' ' "foo   ") -> "foo" as expected
10:33:17 <tromp> > init "foo"
10:33:18 <lambdabot>   "fo"
10:33:37 <yshavit> c_wraith: my figuring was that the first pattern (c c' []) will keep matching until the right-trimming is done.
10:34:14 <yshavit> c_wraith: your specific example returns "" (which is what I'd expect)
10:37:18 <c_wraith> oh, I see.  It's strict in its second argument, making the foldr strict.  I'm too used to foldr being used in a non-strict way.
10:38:06 <yshavit> c_wraith: how is foldr strict there?
10:38:26 <yshavit> c_wraith: oops, sorry, gtg -- be back in about 30...
10:38:28 <c_wraith> yshavit: it needs to examine the entire input before it knows what to produce as output
10:40:16 <rwbarton> it would be better to reorder the tests "is c' == c" and "is cs empty"
10:43:39 * hackagebot mmtl-base 15321.1 - MonadBase type-class for mmtl  http://hackage.haskell.org/package/mmtl-base-15321.1 (MatthewFarkasDyck)
10:47:57 <c_wraith> yshavit: you really want «take 5 $ trimr 0 [1..]» to produce output.  trimr' won't, which is another problem with it.  But you can rewrite trimr such that it will, by changing the definition of f slightly.  Though, originally, your question was about style..  And the style is fine, though I'd eta-reduce a few things.  That's no big deal.
10:48:01 <endojelly> looks like I'm in WHNF today
10:49:05 <hpaste> Skola pasted “HTTP-4000 Error” at http://hpaste.org/55229
10:49:26 <Skola> I'm having trouble using HTTP-4000
10:49:45 <Skola> paste @ http://hpaste.org/55229
10:49:46 <c_wraith> Skola: compile with --make
10:50:06 <Skola> works, thx
10:50:06 <endojelly> c_wraith, what would you eta-reduce for example?
10:50:07 <M4X1M_3OO> hi
10:50:12 <M4X1M_3OO> !list
10:50:32 <M4X1M_3OO> CAN IO
10:50:39 <M4X1M_3OO> CAN I HAVE A ...
10:50:41 <c_wraith> endojelly: trimr' and trim, by changing them to function composition
10:50:45 <M4X1M_3OO> !LIST
10:50:56 <c_wraith> @where ops
10:50:56 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
10:50:56 <M4X1M_3OO> !list
10:51:03 --- mode: ChanServ set +o monochrom
10:51:06 <TomMD> M4X1M_300 before you get kicked, just know the command is "/list"
10:51:19 <M4X1M_3OO> thanks you
10:51:39 <monochrom> what are you looking for?
10:51:40 <c_wraith> TomMD: !list is often used by bots in wares channels.  well, was, 10 years ago.  these days, it's mostly trolling.
10:52:00 <endojelly> c_wraith, oh, I wasn't aware that that's eta-reduction, too
10:52:07 <TomMD> c_wraith: Ahhh, wares channels.  That was the decade.
10:52:24 <c_wraith> I can't even spell "warez" anymore.  yay!
10:52:37 <TomMD> It's a good thing.
10:52:43 <c_wraith> I know :)
10:52:59 <TomMD> And no more slapping with trouts!
10:53:55 <endojelly> c_wraith, how exactly is eta-reduction defined in haskell? I only know it from lambda calculus, where it's basically just (\x t) y =eta t[y/x]
10:54:41 <c_wraith> endojelly: f x = g x -> f = g
10:55:36 <c_wraith> endojelly: which is the same thing.
10:55:50 --- mode: monochrom set -o monochrom
10:55:59 <endojelly> c_wraith, makes sense. will keep that in mind, thx
11:02:40 <c_wraith> endojelly: so, I often consider changing «f x = g $ h x» to «f = g . h» to be a form of eta reduction as well.  Even though it isn't, strictly, it's the same basic idea.
11:03:33 <endojelly> c_wraith, I just called it "making it pointfree/pointless" so far (which is true, too), and which I generally like to do if it doesn't obstruct readability
11:04:13 <endojelly> it becomes unreadable if I have to use ap, for example ;)
11:05:17 <c_wraith> the heavy use of flip from @pl can get frightening, too
11:05:35 <endojelly> oh yes. I also like (.) . ...
11:16:20 <sefb1704> hello guys, simple question about foldl. example in the www : foldl (/) 64 [4,2,4] = 2.0. 64 / 4 = 16 and 64 / 2 = 32 and 64 / 4 is 16 again, so why is the result 2 ?
11:18:08 <Botje> sefb1704: you're describing map
11:18:25 <Botje> sefb1704: the 16 is passed back to the computation, so 16/2 = 8 / 4 = 2
11:18:43 <Cale> @src foldl
11:18:44 <lambdabot> foldl f z []     = z
11:18:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:20:18 <Cale> foldl (/) 64 [4,2,4] = foldl (/) (64/4) [2,4] = foldl (/) ((64/4)/2) [4] = foldl (/) (((64/4)/2)/4) [] = ((64/4)/2)/4 = (16/2)/4 = 8/4 = 2
11:20:21 <sefb1704> Botje: oh okey :O thank you
11:21:05 <sefb1704> Cale: thank you too ;)
11:21:23 <yrlnry> @src sum
11:21:23 <lambdabot> sum = foldl (+) 0
11:24:29 <Tom^2> A cool project that I just found: Elm, Haskell inspired type-safe functional language that compiles to HTML, CSS, and JavaScript. http://elm-lang.org/ Check out the interactive demos...
11:27:59 <jessopher> Tom^2: that is definitely cool
11:28:57 <luite> how do I make a pgfplots smaller?
11:29:00 <luite> oops
11:29:05 <luite> wrong window
11:29:12 <luite> and wrong paste et
11:29:13 <luite> c
11:30:37 <Tom^2> jessopher: I hope the author of the language will finish and polish it eventually - or make it an open source project.
11:31:44 <yshavit> c_wraith: sorry, my timing is in 30 minute increments and I had an off-by-one error ;)  I'll take a look at lazifying (is that the verb?) trimr.
11:32:49 <yshavit> c_wraith: though I'm not sure how it could possibly be not lazy, even in theory. How can you trim elements off the right of a list without looking all the way to the right?
11:36:05 <Cale> Tom^2: Yeah, currently it's pretty frustrating to program in since it seems to be missing most of the Prelude :)
11:36:56 <endojelly> if it's so heavily inspired by haskell, shouldn't one be able to port the prelude pretty easily?
11:37:02 <yshavit> c_wraith: taking your example, looking at take 5 $ trimr 0 [1..], seems to me that *should* spin forever, no? otherwise, what would it be?
11:37:41 <endojelly> most functions in the prelude aren't using many type system features, do they?
11:37:48 <Cale> endojelly: Yeah, I'm currently porting trig functions :P
11:38:03 <endojelly> Cale, nice 8)
11:38:11 <endojelly> Cale, oh wait, is that your project?
11:38:16 <Cale> no
11:38:25 <Cale> I'm just playing around with the live demo
11:38:46 <endojelly> oh ok, I was wondering. I'd have thought you're postdoc by now or something.
11:38:59 <Tom^2> Cale: Even more reasons to make the project open source. I think some people might be willing to port Prelude to this platform.
11:39:32 <Cale> endojelly: I just have a BMath
11:39:51 <Cale> endojelly: and I'm working for iPwn Studios on a Haskell game for iPhones and other mobile devices :)
11:41:51 <Tom^2> The Elm compiler seems  to be a web server extension of some kind...
11:42:03 <endojelly> Cale, huh
11:44:24 <endojelly> Cale, when is it released? I really want to try it out
11:45:42 <Cale> endojelly: Don't have a definite date at the moment
11:46:07 <yshavit> ghci just killed my computer :-O
11:46:27 <Cale> yshavit: how?
11:47:11 <sefb1704> okey, new  question. i can apply the "case - pattern matching-thing" to 1 argument. but what if i want to apply it to a whole list? my suggestion would be something of this time : sumFood xs = [ x | x <- xs, case x of] (next line) pattern 1 ->  2. but there is an error because the patterns are not part of the list comprehension :/ how can i solve that?
11:47:47 <c_wraith> yshavit: it's definitely possible to make it lazier.  if you are removing ' ' from the end of the string, and encounter a 'c', you know you can output the c without looking at anything else
11:47:49 <rwbarton> you can't just make up random syntax
11:48:08 <rwbarton> how about [ case x of ... | x <- xs ]
11:48:25 <sefb1704> rwbarton: i know this is wrong, my question is how .. okey but how would the patterns look like then?
11:48:35 <`Zerax`> What are you trying to achieve?
11:48:43 <yshavit> Cale: I was curious if [1..] is just a simple list to infinity, or whether it remembers the identity of "list of 1 to infinity."  So I asked ghci if [1..] == [1..]. I figured if it spins forever, I can just kill the process... but it spun so forever and so fast that I didn't have a chance to ctrl-c it, and after a few seconds it made my external monitor go blank (not just black, but as if it were disconnected) and my lapto
11:48:44 <yshavit> p screen go white
11:49:34 <endojelly> it shouldn't really do that
11:49:36 <Cale> yshavit: Uh, that's odd.
11:49:38 <endojelly> and it doesn't here:
11:49:40 <yshavit> Cale: right?
11:49:42 <endojelly> Prelude> [1..] == [1..]
11:49:42 <endojelly> ^CInterrupted.
11:49:49 <Cale> yshavit: That should use 100% CPU, but not consume much memory at all
11:49:52 <rwbarton> yshavit: your computer has gazed into infinity
11:49:53 <endojelly> yshavit, what does dmesg|tail say?
11:50:12 <endojelly> maybe there's a coincidential hardware problem
11:50:14 <yshavit> c_wraith: but to do that I would have to append c to whatever comes after, which would be nice in the lazy case, but then in the finite cases be a lot less efficient
11:50:31 <c_wraith> yshavit: nah, the finite case is basically the same
11:50:47 <c_wraith> yshavit: all you need to do is reorder the checks in your f function slightly
11:51:07 <sefb1704> `Zerax`: i got a list of my own type and i have to use case ... of and then patterns and the patterns sort my types. my types are things to eat and the patterns add +1 to the left side of a touple if the food is something to drink and add +1 to the right side of the touple if its something to eat
11:51:11 <yshavit> c_wraith: but you've turned an O(N) operation (N cases of c:cs) into N^2 (N cases of [c] :: cs)
11:51:27 <sefb1704> example: sumFood [Cola, Beer, Bread] = (2,1)
11:51:34 <yshavit> endojelly: nothing seems to pop up, but I don't know what I'm looking for (with dmseg)
11:51:49 <c_wraith> yshavit: I think you are misunderstanding laziness
11:52:03 <rwbarton> sefb1704: The part of a list comprehension before the | is just an expression.  You can put a case-expression there, layout and all.
11:52:25 <rwbarton> sefb1704: you might find it easier to use an auxiliary function though.
11:52:27 <yshavit> c_wraith: could be.... I may also be misunderstanding what you mean :)
11:52:50 <rwbarton> yshavit: N cases of [c] :: cs isn't N^2 anything.
11:53:11 <sefb1704> rwbarton: so like this [ case x of pattern1 -> result1 ; pattern 2 -> result2 | x <- xs ] ?
11:53:12 <Cale> yshavit: I don't understand what you're saying about complexity
11:53:13 <rwbarton> Laziness or no
11:53:35 <yshavit> rwbarton: isn't [c] ++ cs O(N)?
11:53:41 <rwbarton> Nope
11:53:41 <Cale> yshavit: my copy of [1..] == [1..] is still happily running away at 100% CPU and ghci has not moved beyond 14 MB of memory
11:53:48 <benmachine> cs ++ [c] is
11:53:49 <yshavit> rwbarton: ah. Thought I'd read somewhere that it was.
11:53:51 <Cale> yshavit: that's O(1)
11:53:55 <rwbarton> a ++ b is O(length a)
11:54:06 <rwbarton> it doesn't touch b at all
11:54:09 <bwright> Look up the implementation of the ++ op.
11:54:14 <Cale> yshavit: also, there's no (++) in your program
11:54:19 <yshavit> rwbarton, Cale : well then, there you go. :)  I must have either misread or misrememebred
11:54:30 <yshavit> Cale: yeah, I thought c_wraith was suggesting I put one in.
11:54:34 <endojelly> yshavit, what are the last 2 lines or so?
11:54:39 <shachaf> yshavit: It's O(N) where N is length [c].
11:54:52 <yshavit> endojelly: of dmseg?
11:54:56 <endojelly> yshavit, yes
11:54:57 <rwbarton> sefb1704: that should work, I think.
11:55:15 <rwbarton> > [ case b of False -> 1; True -> 2 | b <- [False, True] ]
11:55:16 <lambdabot>   [1,2]
11:55:22 <Cale> [] ++ ys = ys; (x:xs) ++ ys = x : (xs ++ ys)
11:55:26 <yshavit> endojelly: wlan stuff for a few lines, then "skiping EDID probe due to cached edid"
11:55:45 <hpaste> c_wraith pasted “another trimr” at http://hpaste.org/55232
11:55:56 <c_wraith> yshavit: check that version
11:55:58 <rwbarton> sefb1704: however your description of the problem you are trying to solve doesn't sound too much like a list comprehension at all
11:56:06 <endojelly> yshavit, hm, okay, that's really unsuspicious
11:56:50 <yshavit> endojelly: ::shrug:: I guess I just won't do that again! :)
11:56:52 <sefb1704> rwbarton: list comprehension was only my idea of how i could go through the whole list without using recursion, because for recursion i think i have to change the type and i am not allowed to do this
11:56:54 <benmachine> Cale: I suppose [1 ..] would very slowly use up more memory over time, as the integers got very large...
11:56:59 <benmachine> but veeeeery slowly :P
11:57:11 <c_wraith> logarithmic!
11:57:12 <Cale> benmachine: yes, logarithmic space in running time
11:57:20 <benmachine> mm
11:57:24 <benmachine> well
11:57:37 <Cale> (pretty close to that, anyway)
11:57:38 <benmachine> possibly a bit more complex than that, given that comparison of integers is probably log time as well
11:57:53 <c_wraith> logs are amazing, though
11:57:58 <ClaudiusMaximus> hmmm...  ghci> [1..] -- memory goes up as numbers spew on terminal; ghci> print [1..] -- memory stays constant; ghci> "foo"; "foo" ; ghci> it; "foo"
11:58:11 <Cale> benmachine: That's if you want an even better bound though
11:58:30 <benmachine> Cale: oh, I suppose so; at most logarithmic, then
11:58:34 <Cale> benmachine: If the program runs a bit more slowly than we estimate, it only improves the memory usage
11:58:41 <yshavit> c_wraith: hm, I need to look at that for a bit. I don't see why it works :)
11:59:03 <sefb1704> rwbarton: oh wait i think im close to the solution.. what i got now is a list of touples, now i only have to add them up .. i think i sould be able to manage that ^^
11:59:25 <rwbarton> ClaudiusMaximus: [1..] has to bind the result to 'it'
11:59:46 <rwbarton> or maybe that's what the rest of your message was trying to say
11:59:59 <ClaudiusMaximus> rwbarton: yep
12:00:15 <yshavit> c_wraith: oh, I see. You're checking the f c' cs pattern twice. The first time, cs *may* be [], but you don't care -- you'll just append c' if it's /= c. Then you check against [] for the base case. Then you check the recursive case again, except this time you know that cs isn't null and c isn't c'.
12:00:33 <benmachine> yshavit: anyway did you ever work out how to write a lazy O(N) trim?
12:00:38 <benmachine> it can be done
12:00:44 <c_wraith> benmachine: I just told him
12:00:45 <Cale> sefb1704: Yeah, try using foldr (or foldl' if you're more performance conscious) to do it :)
12:00:56 <benmachine> oh right
12:00:58 <benmachine> ruining it :P
12:01:09 <yshavit> benmachine: I haven't even figured out what a lazy trimr would even mean...
12:01:22 <sefb1704> rwbarton: if i got a list of touples [(a,b),(a,b)] generated by listcomprension .. is there some trick with let that i can make them like this: [(a,b):xs] ?
12:01:22 <c_wraith> yshavit: the key point is that it doesn't need to force the second argument of f unless it needs to
12:01:34 <yshavit> benmachine: as far as trimming [1...] means.
12:01:35 <benmachine> c_wraith: err did you test that latest one
12:01:37 <rwbarton> sefb1704: I don't understand
12:01:41 <sefb1704> Cale: i would but i am not used to foldl at all :/
12:01:49 <benmachine> yshavit: trimming anything off [1 ..] would get you [1 ..]
12:02:01 <rwbarton> you cannot solve this problem with no recursion and only list comprehensions and no standard library functions.
12:02:13 <c_wraith> benmachine: I did.  it is broken somehow?
12:02:20 <Cale> sefb1704: Here's a diagram which may help: http://cale.yi.org/share/Folds.svg
12:02:27 <sefb1704> rwbarton: my list comprehension returns such a thing: [(a,b),(a,b)] and i want to add all "a"s and all "b"s up to have something like this as a result: (sumofa, sumofb)
12:02:33 <rwbarton> Yep.
12:02:34 <yshavit> c_wraith: wait, that I'm missing. The first line (of f) either does or doesn't force cs, but the second line will always force theh second arg, won't it?
12:02:39 <benmachine> c_wraith: it looked a bit odd to me, but that's just eyeballing it
12:02:45 <Cale> sefb1704: The idea of foldr f z is that it replaces each of the (:)'s in the construction of the list with f, and any [] at the end with z
12:03:00 <sefb1704> rwbarton: for this i have to bring them into this form: [(a,b):xs] and then add every a nd b ..  it hink
12:03:20 <rwbarton> "[(a,b):xs]" probably doesn't mean what you think it means.
12:03:20 <c_wraith> yshavit: yes, the second line will force cs...  But only if the first line didn't match
12:03:35 <sefb1704> its a list of touples
12:03:39 <yshavit> benmachine: that seems wrong to me. Trimming 0 off of (repeat 0), for instance, seems like it should return [] (if anything)
12:03:43 <rwbarton> Nope, it's not.
12:03:50 <rwbarton> That's "(a,b):xs"
12:03:55 <sefb1704> :O
12:03:58 <yshavit> c_wraith: but if the first line did match, it'll force cs anyway.
12:04:04 <benmachine> yshavit: trimming 0 off (repeat 0) will hang forever
12:04:11 <benmachine> yshavit: that's not the question you asked :)
12:04:27 <c_wraith> yshavit: no it won't.  It just applies (:) to it, and (:) doesn't force its args
12:04:38 <rwbarton> "[(a,b):xs]" is a list containing one element, which is itself a list of tuples.
12:04:38 <yshavit> benmachine: that's what I'd think it would. Why would trimming 0 off [1..] be any different?
12:04:48 <benmachine> yshavit: because there are elements of [1 ..] that are not 0
12:04:52 <yshavit> c_wraith: touche
12:05:02 <benmachine> can we be clear about what it means to force a list?
12:05:12 <Cale> sefb1704: So if we have some list of pairs (a1,b1) : ... we want to add a1 to the first part of the sum of the rest of the list, and b1 to the second part, and the sum of [] will be (0,0)
12:05:17 <c_wraith> In this case, I mean to WHNF
12:05:18 <benmachine> forcing [1 ..] just means working out if it is [] or x : xs for some x, xs
12:05:29 <benmachine> it doesn't mean travelling down the whole list
12:05:33 <benmachine> so it's ok to force [1 ..]
12:05:42 <benmachine> just as long as you don't force all of it
12:05:45 <Cale> sefb1704: So  foldr (\(a,b) (x,y) -> (a+x,b+y)) (0,0)
12:05:48 <yshavit> benmachine: I can see that, what I don't see is how that's useful for trimr.
12:05:53 <sefb1704> Cale: y thats what i want to do
12:06:10 <angstrom> nubBy (\a b -> snd a == snd b) -- is there a nicer way to do that?
12:06:18 <benmachine> yshavit: so you don't understand how the trimr I'm proposing would behave?
12:06:24 <sefb1704> Cale: uff .. im a beginner in haskell, this foldr is some hard .. "bread" for me ^^ but okey i will try this, thanks
12:06:34 <c_wraith> angstrom: (==) `on` snd
12:06:41 <rwbarton> :t equating
12:06:43 <lambdabot> Not in scope: `equating'
12:06:47 <c_wraith> @where on
12:06:47 <lambdabot> I know nothing about on.
12:06:49 <Cale> sefb1704: Instead of adding (a,b) to the beginning of the list, to add it to the sum of the rest of the list (x,y), we just give (a+x,b+y)
12:06:50 <c_wraith> @hoogle on
12:06:50 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:06:51 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
12:06:51 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
12:06:54 <dmwit> rwbarton: =)
12:07:01 <c_wraith> you will need to import Data.Function
12:07:02 <dmwit> rwbarton: uhh... that was supposed to be =(
12:07:02 <benmachine> c_wraith: oh, I just got your trimr :P sry, it's not how I'd've done it but it's quite clever
12:07:04 <rwbarton> I didn't make that up, did I?
12:07:11 <dmwit> rwbarton: No, it's been removed. =(
12:07:15 <rwbarton> removed!
12:07:17 <dmwit> !
12:07:22 <angstrom> c_wraith: thanks :-)
12:07:24 <Cale> What
12:07:30 <c_wraith> benmachine: most of the cleverness came from yshavit actually.  I just re-ordered the cases to make it lazy when possible
12:07:31 <Cale> What's been removed?
12:07:43 <benmachine> c_wraith: oh, fair enough
12:07:45 <dmwit> There used to be a function "equating = on (==)".
12:07:58 <c_wraith> dmwit: there's "comparing"...
12:08:12 <dmwit> c_wraith: There was *also* an equating.
12:08:15 <sefb1704> Cale: louds of laughing - this even works! i know the reason but its just .. magic
12:08:30 <dmwit> :t (comparing, on (==)) -- not the same
12:08:31 <lambdabot> forall b a b1 a1. (Ord a, Eq b1) => ((b -> a) -> b -> b -> Ordering, (a1 -> b1) -> a1 -> a1 -> Bool)
12:08:48 <c_wraith> dmwit: yes, I know
12:08:56 <dmwit> Oh, I misread.
12:09:04 <benmachine> :t ((== EQ) .) . comparing
12:09:05 <lambdabot>     Couldn't match expected type `Ordering'
12:09:05 <lambdabot>            against inferred type `b -> Ordering'
12:09:06 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
12:09:08 <benmachine> oh ff
12:09:19 <benmachine> :t fmap fmap fmap (== EQ) . comparing
12:09:20 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Bool
12:09:27 <c_wraith> I was just wondering if you had misremembered comparing as equating.  But you've already assured me you didn't
12:10:02 <sefb1704> Cale: thank you
12:10:08 <Cale> sefb1704: no problem
12:10:09 <sefb1704> rwbarton: thank you
12:11:55 <sefb1704> Cale: in this case there is obviously no difference between using foldl and foldr right?
12:12:21 <dmwit> hum
12:12:40 <dmwit> > (foldl f [x, y, z], foldr f [x, y, z])
12:12:41 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
12:12:41 <lambdabot>    arising fr...
12:12:47 <dmwit> > foldl f [x, y, z]
12:12:48 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
12:12:48 <lambdabot>    arising fr...
12:12:54 <dmwit> derp
12:12:59 <dmwit> > foldl f z [a, b, c]
12:13:00 <lambdabot>   f (f (f z a) b) c
12:13:06 <dmwit> > foldr f z [a, b, c]
12:13:07 <lambdabot>   f a (f b (f c z))
12:13:16 <Cale> sefb1704: well, the combining function you'll use will be the same, yeah
12:14:21 <Cale> http://i.imgur.com/aDSJW.jpg
12:15:34 <benmachine> Cale: excellent.
12:20:20 <dgpratt> Cale: lol, that's pretty much spot on for my interpretation of such diagrams
12:21:03 <danr> Cale: nice one :)
12:21:18 <DukeDave> Ha
12:22:21 <yshavit> benmachine, Cale : Sorry about that, coworker asked me about something! Need to read back the logs, but it occurred to me when a lazy trimr could definitely be useful. take 5 $ trimr 0 [1..] should return [1,2,3,4,5]
12:22:36 <yshavit> whereas with my strict version, it'll return a big ol' cpu spike.
12:22:54 <Cale> What is trimr?
12:22:56 <benmachine> yshavit: right
12:23:05 <benmachine> Cale: drop a tail equal to something
12:23:09 <Cale> okay
12:24:00 <benmachine> yshavit: even if you're not interested in trimming infinite lists, it's often the case that laziness goes hand in hand with high performance
12:24:11 <benmachine> because laziness is about using as little information as you can to produce as much as you can
12:24:46 <yshavit> benmachine: makes sense
12:24:53 <yshavit> Cale: sorry, meant to autocomplete c_wraith !
12:25:30 <yshavit> benmachine: was the cleverness comment meant as an insult or compliment? ;)  I know programmers who use that word for good or bad.
12:26:26 <yshavit> benmachine: the other implementation I had (my original code had two) was simpler: trimr' c cs = reverse $ triml c $ reverse cs. I'll leave it as an exercise to... myself... to see if that's lazy. I'd think not.
12:26:50 <Cale> given that it contains reverse, I'd say no :)
12:26:53 <benmachine> heh
12:27:02 <yshavit> Cale: okay, then my guess was right. Phew.
12:27:06 <Cale> (reversing an infinite list never turns out well)
12:27:30 <benmachine> heh, indeed not
12:27:32 <danr> @type fix (\f g -> g (f g))
12:27:33 <lambdabot> forall t. (t -> t) -> t
12:27:35 <shachaf> Cale: Should the reverse of an infinite list be _|_ or [_|_,_|_,_|_,...?
12:27:36 <yshavit> Cale: I didn't know if there's some magic I hadn't thought of regarding laziness and reversing the reversal. Apologies for the noobness.
12:27:41 <Cale> shachaf: _|_
12:28:16 <c_wraith> someone had an implementation for reverse that would produce [ _|_, _|_, ...
12:28:16 <Cale> > case reverse [1..] of (x:xs) -> 5
12:28:19 <benmachine> yshavit: don't apologise! it would be a whole lot more boring here if only experts ever spoke :P
12:28:20 <lambdabot>   mueval-core: Time limit exceeded
12:28:29 <shachaf> Cale: As you reverse a list, you can start returning :s immediately.
12:28:34 <Cale> yshavit: Laziness isn't magic :)
12:28:42 <benmachine> I wrote an implementation of sort once, such that sort [_|_,_|_] was [_|_,_|_]
12:28:43 <Cale> yshavit: It's just about evaluating things outermost-first
12:28:45 <shachaf> c_wraith: Yes, I did once. :-)
12:28:45 <yshavit> Cale: tell that to a Java programmer...
12:28:53 <yshavit> benmachine: I do appreciate the patience this channel has :)
12:29:12 <shachaf> You can get "extra laziness" but it's probably not a good idea.
12:29:16 <benmachine> yshavit: me too :)
12:29:23 <Cale> yshavit: and making sure that any bound variable which occurs more than once in its scope is computed at most once -- any computation being shared between the copies
12:29:31 <benmachine> (ps. the sort comment I just made was unconnected to anything)
12:29:37 <yshavit> c_wraith: so, in the light of teaching-to-fish... is there any trick to your having seen that my code wasn't lazy, and your having known how to make it lazy? Or is it just experience?
12:30:09 <benmachine> yshavit: the easiest way to detect laziness is just to test in ghci
12:30:15 <angstrom> how'd I go about comparing the fsts of 2-tuples which differ in the types of their snds?
12:30:16 <benmachine> or rather, the way requiring least expertise
12:30:26 <yshavit> benmachine: my take 5 $ trimr 0 [1..] trick
12:30:28 <yshavit> ?
12:30:32 <benmachine> yshavit: things like that, yeah
12:30:34 <Cale> angstrom: apply fst to each of them and compare
12:30:34 <c_wraith> yshavit: well, pattern-matching on constructors always forces some evaluation.  Given that you were matching a constructor in a case where it didn't affect the output, that was my hint
12:30:40 <danr> benmachine: how?
12:30:45 <benmachine> danr: how which
12:30:58 <danr> benmachine: the length-preserving ord of lists with partial elements
12:31:06 <benmachine> yshavit: or using undefined
12:31:06 <danr> uh sort not ord
12:31:21 <yshavit> c_wraith: by which you mean, sometimes [] turned to [] ?
12:31:31 <benmachine> danr: ah, it's actually one of those cases where laziness is probably at the cost of performance, so it's not that interesting, but it's cute :)
12:31:45 <danr> benmachine: can you paste it? I'm very curious :)
12:31:49 <benmachine> danr: I think it was an insertion sort
12:32:10 <benmachine> aha
12:32:11 <benmachine> got it
12:32:17 <danr> benmachine: great!
12:32:47 * benmachine nudges hpaste 
12:32:51 <wieczyk> Hi, it has sense to use parsec (or any other parser combinators) to write big parser? When I use BNF (happy, yacc etc) then tool can tell me about conflicts in my grammar. When I build parser from combinators, which looks like BNF, i don't havy any info about potentials problems.
12:32:52 <benmachine> ... http://hpaste.org/55234
12:32:55 <benmachine> danr: ^
12:33:03 <c_wraith> yshavit: actually, I mean "sometimes you matched [], but then did something that (one branch of) only relied on comparing c and c', and didn't care whether the list was [] or not"
12:33:45 <yshavit> c_wraith: ah! So if I may generalize, "it's bad to match a constructor and then not care what it is" ?
12:34:06 <c_wraith> yshavit: bad for laziness, anyway.  sometimes you don't want laziness. :)
12:34:09 <yshavit> or probably  more specifically, "and then not use it" ?
12:34:09 <rwbarton> it's not always bad
12:34:18 <yshavit> c_wraith: right, I meatn for laziness
12:34:19 <rwbarton> but it is a thing that you should be aware that you are doing
12:34:20 <danr> benmachine: hmm, this doesn't work?
12:34:31 <benmachine> danr: huh, doesn't it? maybe I misremembered
12:34:33 * benmachine tests is
12:34:36 <rwbarton> Actually there is a whole wiki page with examples like this
12:34:45 <danr> sort [undefined,undefined] gives [*** Exception: Prelude.undefined
12:34:58 <benmachine> danr: sure it does
12:35:05 <benmachine> danr: what were you expecting to happen?
12:35:15 <benmachine> danr: try length (sort [undefined,undefined])
12:35:19 <yshavit> c_wraith: aaah. It's slowly sinking into my head, the difference between the constructor and just a plain "cs". And just to clarify, a match on (c:cs) would be strict for c but still lazy on cs, right?
12:35:28 <rwbarton> yshavit: http://www.haskell.org/haskellwiki/Maintaining_laziness#Early_decision
12:35:43 <danr> benmachine: lol! I'm tired, I forgot what I was supposed to test
12:35:50 <danr> benmachine: ok it works :) great
12:36:03 <yshavit> rwbarton: thanks! Ah crap, yet another meeting. Man, today sucks for spending time on haskell instead of my day job ;)
12:36:09 <c_wraith> yshavit: actually, it's not strict in either c or cs.  it just makes sure the list constructor isn't []
12:36:30 <yshavit> c_wraith: even better. Makes sense -- cause the constructor there is : which takes two args.
12:36:30 <angstrom> Cale: ah. my problem seems to be somewhere else. what I'm trying to do is `deleteFirstsBy ((==) `on` fst) [(3,"a"),(2,"b")] [(3,'b')]', which should return [(2,"b")]
12:36:38 <c_wraith> yshavit: exactly
12:36:42 <yshavit> c_wraith: and until I look at either one of them, it's not forced
12:36:44 <benmachine> danr: I think it's O(N^2) though, so it's not really practical
12:36:49 * yshavit feels like Neo. I know kungfu!
12:37:17 <yshavit> crap, gotta go. be back later...
12:38:59 <sefb1704> okey, im back again! \o/ i want to have a data consisting of 3 abilitys, name: String, quantity: Int of course and the price: Float. why is this not working? :/ data Item = Item { name : String, quantity : Int, price : Float } deriving Show
12:39:32 <angstrom> sefb1704: name :: String, not name : String
12:39:42 <sefb1704> ow damn -.- thanks
12:42:05 <angstrom> mapping (\(a, b) -> (a, [b])) over the second argument would work, of course. but it seems rather ugly..
12:43:07 <rwbarton> @type deleteFirstsBy
12:43:10 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
12:43:12 <carpi> if 'do' is a construct, like where, let and case....then is it possible to use do in a pure function to specify a sequence of lines that must be executed in order?
12:43:24 <rwbarton> @hoogle deleteFirstsBy
12:43:25 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
12:43:28 <monochrom> yes
12:43:30 <rwbarton> wild
12:43:36 <rwbarton> oh i see
12:43:56 <rwbarton> why does it have that type?
12:44:08 <sefb1704> omg with the tasks given to me, its just like haskell makes a node in my head, then leaves and laughs at me :/
12:44:09 <monochrom> actually, not entirely yes, but to a large extent yes.
12:45:40 <carpi> but i tried 'do {let a = 3}' in ghci..  says last statement must be expression
12:45:41 <angstrom> rwbarton: the second argument is the set of nodes connected to a given node in a graph, along with the symbol passing it consumes. the first argument is a set of nodes along with symbols consumed so far
12:46:42 <angstrom> rwbarton: or do you mean deleteFirstsBy? :-P
12:46:48 <rwbarton> yeah, that
12:47:00 <angstrom> yeah. it's kinda annoying
12:47:03 <rwbarton> @src deleteFirstsBy
12:47:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:47:24 <rwbarton> @type foldl (flip (deleteBy ?eq))
12:47:25 <lambdabot> forall b. (?eq::b -> b -> Bool) => [b] -> [b] -> [b]
12:47:38 <donri> carpi: let...in is an expression; plain let is not inside do
12:48:50 <rwbarton> angstrom: basically you just want to remove the first element from a list which satisfies a given predicate, right, but there seems to be no function for that
12:49:35 <rwbarton> @type deleteBy (\_ x -> ?p x) undefined xs
12:49:36 <lambdabot> Not in scope: `xs'
12:49:38 <rwbarton> @type deleteBy (\_ x -> ?p x) undefined ?xs
12:49:39 <lambdabot> forall a. (?xs::[a], ?p::a -> Bool) => [a]
12:49:44 <rwbarton> besides something awful like that
12:49:46 <carpi> thnkx
12:50:11 <donri> > do { let a = 3 in a }
12:50:12 <lambdabot>   3
12:50:15 <salisbury> Is there a function Int -> (a -> b) -> () or so
12:50:22 <rwbarton> uh
12:50:23 <donri> > do { let a = 3; a }
12:50:24 <lambdabot>   <no location info>: parse error on input `}'
12:50:37 <salisbury> something that takes a function and executes it x number of times
12:50:48 <rwbarton> "executes"?
12:50:52 <salisbury> runs
12:50:52 <angstrom> rwbarton: basically I want to do set-difference, like (\\), with user-supplied predicate
12:50:59 <donri> @hoogle Int -> (a -> b) -> ()
12:51:00 <lambdabot> Data.Data gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
12:51:00 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:51:00 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:51:00 <proq> is there a haskell-on-javascript implementation that is any good?
12:51:08 <rwbarton> salisbury: you can't "run" a function
12:51:12 <rwbarton> @type replicateM_
12:51:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
12:51:28 <parcs__> why is reverse [1..] 'supposed' to be _|_ not [_|_,...] ?
12:51:33 <salisbury> sorry, I don't know the correct terminology
12:51:42 <rwbarton> it's not really a terminology issue
12:51:56 <rwbarton> Or if it is, the issue is with "function"
12:52:22 <donri> salisbury: functions don't have side-effects, they compute values. what sort of value are you looking for? a list replicated N times? IO action sequenced N times?
12:52:24 <rwbarton> angstrom: yeah I see, only you want the predicate to have arguments of two different types, which actually deleteFirstsBy could
12:52:37 <salisbury> the latter
12:52:55 <donri> then you might be looking for what rwbarton gave you
12:53:37 <rwbarton> angstrom: not that it is helpful but http://hackage.haskell.org/trac/ghc/ticket/3399
12:54:04 <donri> salisbury: import Control.Monad; replicateM_ 3 $ putStrLn "hi"
12:54:17 <angstrom> rwbarton: nice :-)
12:54:26 <salisbury> ahh, yes
12:54:41 <salisbury> I keep looking at IO actions as functions
12:54:55 <salisbury> I suppose I should stop doing that.. putStrLn :: IO ()
12:55:18 <salisbury> .. once a string is provided
12:55:21 <donri> IO actions are values; replicateM_ n x is like x >> x >> x
12:55:34 <donri> which in turn is like do x; x; x
12:56:00 <donri> ...if n==3 that is :P
12:56:06 <danr> parcs__: nontermination is ⊥
12:56:24 <salisbury> thanks folks
12:56:37 <danr> parcs__: and reverse [1..] doesn't ever produce a cons, so its not ⊥:⊥ (or anything else)
12:57:14 <sefb1704> okey one more question. i got a data type looking like this: <name> <variable> and the data type is used like this: function :: <name> <variable> -> String; function (<name> <subvalue1> <subvalue2>) = <subvalue1> so the subvalue1 is returned. but how can i declare this in the type declaration? my idea: data <name> <variable = <name> <variable> { subvalue1 :: String, subvalue 2 :: Int }
12:57:17 <danr> (assuming the standard definition(s))
12:57:22 <parcs__> danr, but you can implement a reverse such that reverse [1..] is [_|_,..]
12:58:26 <danr> then that's what it is :)
12:58:28 <sefb1704> Edit: my idea: data <name> <variable = <name> <variable> { subvalue1 :: String, subvalue 2 :: Int } deriving Show
12:58:39 <rwbarton> parcs__: it is an interesting question, I feel that _|_ is right but I don't know why I feel that way
12:59:28 <danr> the standard definitions i was referring to is appending the singleton, foldling (flip (:)), and with accumulator. all these produce no constructor and hence doesn't terminate on an infinite input list, so their value is ⊥ (because, again, of nontermination)
12:59:33 <rwbarton> sefb1704: remove the second occurrence of <variable>
12:59:41 <rwbarton> sefb1704: also, the first one isn't doing you any good...
12:59:46 <parcs__> danr, but which definition is more correct?
13:00:16 <sefb1704> rwbarton: so both are bad? :/ seems like i dont even get how <variable> is used  or better: how i should declare it
13:00:30 <danr> > let reverse' xs = map snd (zip xs [ xs !! (length xs - n) | n <- [1..] ]) in length $ take 10 $ reverse' [1..]
13:00:30 <lambdabot>   10
13:00:31 <rwbarton> <variable> is for a type variable
13:00:38 <rwbarton> you could use it in the type of a field
13:00:46 <danr> there's a pretty contrived version of returing [undefined,... for an infinite list
13:01:01 <natte> homework question (already have the solution, just wondering if there is a better way also since Haskell is fun :P): http://pastie.org/private/yniqryvz1drd6y8k6mcgg
13:01:46 <natte> and maybe my translation of the task doesn't make much sense, it's doing subtraction between each element of the list, then subtraction between the results, etc etc and returning the results as [[]] :)
13:02:04 <danr> parcs__: well the one I just gave you is O(n^2), same with appending the singleton. And avoiding the accumulator is pretty nice, so I prefer foldling (flip (:)), but again, there's no "correct" here :)
13:02:19 <sefb1704> so i have to do this? data <name> <variable> = <variable> :: <name2>; type <name2> = <subvalue1> :: String, <subvalue2> :: Int
13:02:35 <rwbarton> natte: there are a couple standard library functions you could use
13:02:38 <rwbarton> @type zipWith
13:02:39 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:02:47 <rwbarton> @type iterate
13:02:48 <lambdabot> forall a. (a -> a) -> a -> [a]
13:02:51 <rwbarton> ^ look into those
13:02:52 <no1special> Is there a form of <$> that works with multiple arguments?
13:02:52 <lambdabot> no1special: You have 1 new message. '/msg lambdabot @messages' to read it.
13:03:14 <sefb1704> rwbarton: so i have to do this? data <name> <variable> = <variable> :: <name2>; type <name2> = <subvalue1> :: String, <subvalue2> :: Int
13:03:30 <rwbarton> no no no
13:03:31 <kissyboy> no1special: you can use <*> like so
13:03:48 <rwbarton> what you had before was fine, I think, just get rid of <variable>
13:03:52 <kissyboy> > (+) <$> [1,2,3] <*> [10,20,30]
13:03:55 <lambdabot>   [11,21,31,12,22,32,13,23,33]
13:04:18 <no1special> ah!
13:04:34 <sefb1704> rwbarton: hmkey. but in the contract of one of the function where my data is used it says it has to have something like <variable>
13:04:38 <natte> rwbarton that would make it like bit more readable but the generic concept would stay the same? or actually I'll double check zipWith :D
13:04:39 <kissyboy> if it has three arguments just keep adding <*> in between them
13:04:52 <rwbarton> natte, you can get rid of all the explicit recursion
13:04:58 <rwbarton> and pattern matching
13:05:02 <no1special> kissyboy: fantastic! thank you
13:05:23 <rwbarton> but first, you can try to simplify diffsOne with zipWith
13:05:53 <natte> rwbarton ok I'll give it a try, thanks for the tips :)
13:11:07 <no1special> anyone know the rationale behind the symbols <$> and <*> ?
13:11:56 <parcs__> for <$> think of <> being a container and $ being function application
13:12:04 <parcs__> or <> being a functor
13:12:21 <no1special> gotcha
13:13:00 <rwbarton> and you can think of <*> as a kind of multiplication, combined with function application
13:13:04 <sefb1704> rwbarton: when i delete the <variable> i get the following error: <name> is applied to too many arguments, everywhere i use this data
13:13:20 <rwbarton> sefb1704: paste your code
13:13:39 <rwbarton> or get rid of the argument to <name> elsewhere, why does it exist? maybe i'm missing something
13:14:25 <grant_> hey guys, i think im not understanding handles/lazy IO properly. here's some code: https://github.com/johnfn/ghci-in-a-new-dress/blob/master/test.hs
13:14:43 <grant_> the idea is i run ghci as a process, then i want to put some stuff in and get some stuff out
13:15:37 <grant_> it seems to work fine until i uncomment the line that i commented out (which puts some stuff into the process AFTER i read some stuff out)
13:16:11 <sefb1704> rwbarton: i would prefer solving this in general, caus i dont want you to make my homework, this would be very bad for me. umm so i try to explain further: <name> has a <variable> that consists of two subvalues. they are used in for example this way: what :: <name> a -> [a]; what (<name> _ <subvalue2>) = <subvalue2>
13:16:18 <alistra> i've made my first remote ssh proxy today!
13:16:19 <grant_> once i do that it just freezes up - the impression i get is that the lazy io is taking forever
13:16:29 <ClaudiusMaximus> > let o n = (n + 1) * 4 ^ n ; os = map o [0..] ; m n = 2 * fromIntegral (os !! n) / fromIntegral (os !! 5) ; hours = sum [ m n | n <- [0..11]] / 60 in hours
13:16:31 <lambdabot>   353.9753092447917
13:16:41 <ClaudiusMaximus> mm, i should improve my algorithm
13:17:21 <rwbarton> sefb1704: what is the declaration of <name>
13:17:50 <sefb1704> rwbarton: i have to declare it myself :D date <name> <variable> = empty..
13:17:59 <sefb1704> and what i wrote there seems to be wrong
13:18:00 <rwbarton> oh
13:18:00 <clsmith> ClaudiusMaximus: pfft, it'll be done just in time for you to get back from christmas
13:18:11 <ClaudiusMaximus> clsmith: :)
13:18:33 <rwbarton> sefb1704: well I suggest you read your textbook or LYAH or whatever
13:18:45 <sefb1704> rwbarton: okey, thank you
13:20:30 <no1special> how come function application associates to the left? (i.e. I find myself needing explicit parens or $ a good deal.)
13:21:04 <rwbarton> grant_: probably your problem is related to buffering somehow
13:21:27 <monochrom> because you like to write "(map f) xs"
13:21:44 <grant_> rwbarton: hmm, any way to get around that?
13:21:47 <monochrom> or even "((foldr (+)) 0) xs"
13:21:58 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in length . take 10 $ (g [1..])
13:22:02 <lambdabot>   mueval-core: Time limit exceeded
13:22:09 <rwbarton> grant_: btw I tried something a lot like this once and it was a huge pain
13:22:27 <rwbarton> since ghci likes to write to stdout and stderr in an unsynchronized way
13:22:37 <grant_> uh oh. so i just want to send and receive data with ghci, is there a better way to do that?
13:22:59 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g xs = f xs (reverse xs) in length . take 10 $ (g [1..])
13:23:03 <lambdabot>   mueval-core: Time limit exceeded
13:23:07 <parcs__> what
13:23:07 <rwbarton> if you don't need "interactive" use it's won't be so bad
13:23:17 <grant_> i kinda do :S
13:23:37 <hpc> grant_: the hacky way would be to just unbuffer everything
13:23:52 <hpc> @hoogle hSetBuffering
13:23:53 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
13:23:53 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
13:24:16 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in length (take 10 (g [1..]))
13:24:18 <lambdabot>   10
13:24:21 <grant_> ah... i'll look into that, thanks
13:24:28 <parcs__> looks like either . or $ impose strictness..
13:24:42 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in length (take 10 $ (g [1..]))
13:24:43 <lambdabot>   10
13:24:57 <rwbarton> grant_: here is what I ended up writing earlier, though I don't remember how well it worked: http://hpaste.org/55236
13:25:06 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:25:10 <rwbarton> my recollection is that, at best, it did not fully live up to my expectations. :P
13:25:12 <lambdabot>   mueval: ExitFailure 1
13:25:12 <lambdabot>  mueval: Prelude.undefined
13:25:15 <grant_> haha...
13:25:17 <grant_> ok thanks
13:25:26 <hpc> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:25:31 <lambdabot>   mueval: ExitFailure 1
13:25:31 <lambdabot>  mueval: Prelude.undefined
13:25:34 <hpc> wtf
13:25:39 <parcs__> hax i know..
13:26:13 <hpc> parcs__: might be stream trickery?
13:26:42 <parcs__> maybe, but i thought ghci doesn't do those kinds of optimization
13:26:56 <hpc> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in f [1..5]
13:26:58 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
13:26:58 <lambdabot>    arising from a use ...
13:27:11 <hpc> @type let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in f
13:27:12 <lambdabot> forall t t1. [t] -> [t1] -> [t1]
13:27:15 <parcs__> g not f
13:27:18 <hpc> @type let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in g
13:27:19 <lambdabot> forall t. [t] -> [t]
13:27:29 <hpc> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in g [1..5]
13:27:30 <lambdabot>   [5,4,3,2,1]
13:28:17 <self> > foo
13:28:19 <lambdabot>   Not in scope: `foo'
13:28:23 <parcs__> isn't that awesome? a totally lazy O(n) reverse
13:28:25 <grant_> hpc: the unbuffering hack did it for me, at least for now. thanks :-)
13:28:59 <hpc> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in take 1 (g [undefined, 5])
13:29:00 <lambdabot>   [5]
13:35:45 <benmachine> > take 1 (reverse [undefined,5])
13:35:46 <lambdabot>   [5]
13:35:56 <benmachine> isn't conventional reverse totally lazy and O(n)?
13:36:21 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in length (take 10 (g [1..]))
13:36:23 <lambdabot>   10
13:36:25 <rwbarton> it's not (as) lazy in the spine of the list (as it could be)
13:36:25 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in length (take 10 (reverse [1..]))
13:36:41 <monochrom> not totally lazy, unless I misinterpret totally
13:36:47 <Axman6> benmachine: not totally lazy
13:36:48 <benmachine> rwbarton: oh, I see
13:36:56 <rwbarton> > take 1 (reverse 5 : undefined)
13:37:05 <Axman6> it won't return anything until it reaches the end of the list
13:37:09 <lambdabot>   thread killed
13:37:10 <rwbarton> well not the best example, but you see what i mean
13:37:12 <lambdabot>   mueval-core: Time limit exceeded
13:37:33 <benmachine> Axman6: whereas it should return thunk : thunk as soon as it finds out the first thing is a cons?
13:37:41 <rwbarton> also where are my parentheses
13:38:03 <Axman6> benmachine: possibly... though I'm not sure how you'd do that. i guess by doing it the way hpc defined it
13:38:26 <hpc> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in last (5:undefined)
13:38:29 <lambdabot>   mueval-core: Time limit exceeded
13:38:33 <Peaker> > reverse 5
13:38:37 <lambdabot>   mueval-core: Time limit exceeded
13:38:38 <hpc> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in last (g (5:undefined)) -- derp
13:38:38 <parcs__> benmachine, i don't know if it should, but it definitely can
13:38:39 <rwbarton> > head 5
13:38:41 <lambdabot>   No instance for (GHC.Num.Num [a])
13:38:42 <lambdabot>    arising from a use of `e_15' at <inter...
13:38:42 <lambdabot>   mueval-core: Time limit exceeded
13:38:53 <benmachine> parcs__: mm, yeah
13:39:07 <Peaker> Seems like the time limit is killing it before it can spew an error
13:39:23 <benmachine> @botsnack
13:39:23 <lambdabot> :)
13:40:19 <parcs__> what's strange is that . makes the function more strict:
13:40:28 <parcs__> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:40:33 <lambdabot>   mueval: ExitFailure 1
13:40:33 <lambdabot>  mueval: Prelude.undefined
13:41:06 <parcs__> or rather it makes the expression more strict
13:41:21 <parcs__> or something!
13:43:09 <hpc> it undoes your freaky magic
13:43:50 <rwbarton> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:43:52 <parcs__> :t reverse'
13:43:53 <lambdabot> forall t. [t] -> [t]
13:43:55 <lambdabot>   mueval: ExitFailure 1
13:43:55 <lambdabot>  mueval: Prelude.undefined
13:44:00 <rwbarton> oh
13:44:16 <rwbarton> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length P.. take 10) (g [1..])
13:44:17 <lambdabot>   10
13:44:18 <parcs__> > (length . take 10) (reverse' [1..])
13:44:20 <rwbarton> caleskell'd
13:44:22 <lambdabot>   mueval-core: Time limit exceeded
13:44:24 <rwbarton> sucks to be you!
13:44:34 <parcs__> > length (take 10 (reverse' [1..]))
13:44:39 <lambdabot>   mueval: ExitFailure 1
13:44:39 <lambdabot>  mueval: Prelude.undefined
13:44:42 <parcs__> oh what!
13:44:50 <alistra> wut
13:44:54 <hpc> what
13:44:55 <rwbarton> @type let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:44:56 <lambdabot> Int
13:45:02 <Peaker> given that lambdabot is mainly useful for pedagogical purposes, overriding Prelude is a pretty bad idea
13:45:03 <alistra>  > length (take 10 (reverse' [1..]))
13:45:03 <rwbarton> or something? I dunno
13:45:07 <alistra> > length (take 10 (reverse' [1..]))
13:45:14 <lambdabot>   mueval: ExitFailure 1
13:45:14 <lambdabot>  mueval: Prelude.undefined
13:45:20 <hpc> :t reverse'
13:45:21 <lambdabot> forall t. [t] -> [t]
13:45:29 <rwbarton> maybe it's just random mueval failures
13:45:30 <alistra> > reverse' [1..]
13:45:36 <lambdabot>   mueval: ExitFailure 1
13:45:36 <lambdabot>  mueval: Prelude.undefined
13:45:43 <alistra> > reverse' [1..400]
13:45:47 <rwbarton> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:45:49 <lambdabot>   mueval: ExitFailure 1
13:45:49 <lambdabot>  mueval: Prelude.undefined
13:45:52 <lambdabot>   mueval: ExitFailure 1
13:45:52 <lambdabot>  mueval: Prelude.undefined
13:45:54 <hpc> > reverse' []
13:45:59 <lambdabot>   mueval: ExitFailure 1
13:45:59 <lambdabot>  mueval: Prelude.undefined
13:46:03 <parcs__> @undefine
13:46:05 <hpc> haha
13:46:06 <alistra> well
13:46:14 <alistra> reverse ()
13:46:19 <alistra> > reverse ()
13:46:20 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
13:46:22 <alistra> > reverse' ()
13:46:23 <lambdabot>   Not in scope: `reverse''
13:46:41 <hpc> that doesn't typecheck for either reverse
13:47:35 <alistra> @pl \y x -> off x y
13:47:35 <lambdabot> flip off
13:47:38 <parcs__> @let rh (_:xs) ~(y:ys) = y : rh xs ys; rh [] _ = []
13:47:39 <lambdabot>  Defined.
13:47:44 <parcs__> @let reverse' = rh <*> reverse
13:47:45 <lambdabot>  Defined.
13:47:50 <parcs__> > reverse' [1..10]
13:47:56 <lambdabot>   mueval: ExitFailure 1
13:47:56 <lambdabot>  mueval: Prelude.undefined
13:48:01 <parcs__> :(
13:48:26 <hpc> ...what the hell
13:48:35 <benmachine> > reverse [1 .. 10]
13:48:36 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
13:48:39 <parcs__> this thing is really fragile
13:48:52 <benmachine> > rh [1 .. 10] [10, 9 .. 1]
13:48:57 <lambdabot>   mueval: ExitFailure 1
13:48:58 <lambdabot>  mueval: Prelude.undefined
13:49:09 <benmachine> that output doesn't even make sense
13:49:21 <rwbarton> haha hmm...
13:49:28 <rwbarton> > rh [1 .. 10] [10, 9 .. 1] :: [Int]
13:49:32 <lambdabot>   mueval-core: Time limit exceeded
13:49:35 <parcs__> :t rh
13:49:36 <lambdabot> forall t t1. [t] -> [t1] -> [t1]
13:49:47 <rwbarton> > rh [1 .. 10 :: Int] [10, 9 .. 1] :: [Int]
13:49:51 <lambdabot>   mueval-core: Time limit exceeded
13:49:52 <parcs__> :t rh []
13:49:53 <lambdabot> forall t1. [t1] -> [t1]
13:49:56 <rwbarton> > rh "a" "b"
13:49:56 <parcs__> :t rh [] []
13:49:57 <lambdabot> forall t1. [t1]
13:50:00 <lambdabot>   mueval-core: Time limit exceeded
13:50:05 <benmachine> > rh [] []
13:50:07 <lambdabot>  Terminated
13:50:11 <rwbarton> > rh [()] [()]
13:50:11 <alistra> i don't even
13:50:15 <lambdabot>   mueval-core: Time limit exceeded
13:50:29 <benmachine> > let rh (_:xs) ~(y:ys) = y : rh xs ys; rh [] _ = [] in rh [] []
13:50:30 <lambdabot>   []
13:50:36 <benmachine> seems like @let is being odd
13:50:48 <benmachine> > let rh (_:xs) ~(y:ys) = y : rh xs ys; rh [] _ = [] in rh <*> reverse $ [1 .. 10]
13:50:49 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
13:51:04 * marienz eyes lambdabot
13:51:13 <benmachine> > let rh (_:xs) ~(y:ys) = y : rh xs ys; rh [] _ = [] in length . take 10 . (rh <*> reverse) $ [1 ..]
13:51:15 <lambdabot>   10
13:51:36 <alistra> what is this ~(syntax)
13:52:21 <hpc> alistra: i forget the term, but it basically means "don't match on this pattern until you match on something inside"
13:52:23 <c_wraith> alistra: "irrefutable pattern matches"
13:52:31 <hpc> kind of a "this is a lazy pattern" thing
13:52:38 <hpc> > let Just 5 = Nothing in 5
13:52:39 <lambdabot>   5
13:52:44 <hpc> > let Just x = Nothing in x
13:52:45 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern Da...
13:52:46 <c_wraith> alistra: you are assuring the compiler that you know what the pattern is, and it doesn't need to match it just now
13:53:02 <xxx_man1> for all X\in R if we have MX=Q and for all X\in R we have NX=Q can we write MX=QX
13:53:16 <parcs__> let f (_:xs) ys = head y : f xs (tail ys); f [] _ = []; g = f <*> reverse in length (take 10 (g [1..]))
13:53:22 <rwbarton> specifically here it's like writing "let rh (_:xs) z = head z : rh xs (tail z) ..."
13:53:26 <parcs__> > let f (_:xs) ys = head y : f xs (tail ys); f [] _ = []; g = f <*> reverse in length (take 10 (g [1..]))
13:53:26 <lambdabot>   Couldn't match expected type `[a]'
13:53:27 <lambdabot>         against inferred type `SimpleRef...
13:53:50 <parcs__> > let f (_:xs) ys = head ys : f xs (tail ys); f [] _ = []; g = f <*> reverse in length (take 10 (g [1..]))
13:53:51 <lambdabot>   10
13:54:07 <rwbarton> or more accurately "let rh (_:xs) z = let (y:ys) = z in y : rh xs ys ..."
13:55:01 <benmachine> xxx_man1: that doesn't sound like a haskell question
13:55:58 <shapr> I sure do like Haskell.
13:56:19 <rwbarton> > let f (_:xs) ys = head ys : f xs (tail ys); f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:56:21 <lambdabot>   10
13:56:24 <rwbarton> I fixed it!
13:56:53 <mads-> Hello
13:56:54 <rwbarton> > let f (_:xs) ~(y:ys) = y : f xs ys; f [] _ = []; g = f <*> reverse in (length . take 10) (g [1..])
13:56:56 <lambdabot>   10
13:57:21 <parcs__> rwbarton, how?
13:57:33 <rwbarton> beats me
13:57:41 <rwbarton> (I didn't do anything)
13:58:41 <hpc> maybe λbot just having a bad day?
13:59:07 <alistra> mr fancy utf8 lambda
14:02:08 <carpi> have there been any mainstream initiatives in using haskell for writing games?
14:02:42 <benmachine> carpi: what's a mainstream initiative?
14:02:49 <benmachine> carpi: Cale works for a company that is trying to write one atm
14:04:29 <mads-> I have had an interest in playing around with scheme in order to try a different approach to programming (I normally do perl, C++ and java at school and work). Haskell has pretty much the same "functional programming aspects" as scheme, right? And I hear it is more used "out in the real world". Is this true?
14:04:51 <carpi> benmachine: like games made by a company for example
14:05:04 <monochrom> Haskell encourages functional programming more than Scheme does.
14:05:29 <acowley> GHC's generics are frustratingly inscrutable to me. I have some code that uses them, but I don't trust it at all and struggle to write new things.
14:05:47 <aninhumer> mads-: Haskell and Scheme both use functional programming, but they end up quite different in style
14:05:48 <monochrom> I haven't measured the whole real world. too large. my pocket of the real world uses more haskell, yes.
14:06:07 <mads-> So, even though the answer may be a little biased, I'm better off doing Haskell than scheme if I want to learn functional programming and actually learn something I can use later on in life
14:06:22 <benmachine> mads-: learn both :D
14:06:47 <dreixel> acowley: do you have suggestions on what could be done to improve its understandability?
14:06:54 <monochrom> yes, learn both. Scheme has a macro system quite different from everything else.
14:07:33 <monochrom> also Scheme has call/cc which is a lot of fun.
14:07:37 <acowley> dreixel: I suspect it's mostly examples that I want, but I find the haddock itself quite frustrating because whenever I look at it, I immediately get lost
14:07:46 <acowley> dreixel: I think the haddock just needs some prose at the top
14:08:05 <rwbarton> are you talking about SYB or the -XGenerics thing?
14:08:27 <acowley> dreixel: Also, the type parameters have suggestive names, but no explanation for any naming convention or usage
14:08:29 <dreixel> acowley: have you had a look at http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/generic-programming.html and http://www.haskell.org/haskellwiki/Generics ?
14:08:30 <acowley> rwbarton: Generics
14:08:51 <aninhumer> Probably I'd say learn haskell first, as it forces you to learn functional programming, and the syntax is probably less of a distraction
14:09:07 <mads-> Cool. thanks :)
14:09:10 <xxx_man1> Cale: hi
14:09:21 <mads-> Doing the the tryhaskell intro tutorial right now. Semms like a nice language
14:09:22 <acowley> dreixel: Yes, I used those pages to write the code I have.
14:10:09 <acowley> dreixel: But something that bothered me (still bothers me) is that even in the examples, instances are not given for each representation type (section 7.17.2)
14:10:46 <dreixel> acowley: the paper (http://dreixel.net/research/pdf/gdmh.pdf) contains a more detailed description of everything, but since it's not exactly equal to the implementation in GHC I don't usually recommend it as first source of documentation
14:10:53 <acowley> dreixel: I feel like that kind of partial coverage deserves some explanation
14:11:06 <dreixel> ah, I see.
14:11:10 <dreixel> well, it's because they're not needed.
14:11:15 <dreixel> the paper does explain it
14:11:27 <dreixel> but you're right, it's mentioned nowhere else, I think
14:12:07 <acowley> dreixel: that was the main reason I don't trust the code I did get working: I don't know if it's only working by accident... a very un-Haskelly sensation.
14:12:48 <dreixel> acowley: -XPolyKinds will hopefully help with that :)
14:12:59 <acowley> dreixel: I'm sure I need to read the paper and it will help clarify things, but that's not an ideal situation
14:13:53 <dreixel> the generics mechanism will probably be changed in the near future to make use of datatype promotion
14:13:54 <acowley> dreixel: here's a concrete really simple thing: I want to call datatypeName
14:15:10 <acowley> hm, maybe I shouldn't go so heavy on the generics code yet then. I got a flashback to reflection highs from my youth and probabaly got carried away.
14:15:31 <dreixel> oh, it won't change dramatically
14:15:36 <dreixel> it will improve
14:15:39 <dreixel> with better kinds
14:15:54 <dreixel> because right now it has a considerable amount of type-level programming
14:16:06 <dreixel> which is basically untyped, or unkinded, if you wish
14:16:24 <dreixel> so that's why you don't know if you've given enough instances, for example
14:16:38 <dreixel> because they kinds don't tell you what types are the valid representation types
14:17:10 <dreixel> with -XPolyKinds that is not the case anymore
14:18:05 <dreixel> but first we have to get 7.4.1 out
14:18:16 <dreixel> then we'll look at improving generics (and Typeable) for 7.6
14:18:37 <acowley> yeah I'm very looking forward to that
14:20:13 <dreixel> acowley: but you were saying you can't use datatypeName?
14:20:24 <monochrom> yesterday I found out quite nicely that for function spaces like Bool->Bool, Int->Int, i.e., flat->flat, continuous = strict or constant, so f continuous = (f ⊥ = ⊥) or (f _ = k)
14:20:39 <Axman6> > let f (x:xs) ~(y:ys) = y : f xs ys; g = f <*> reverse in length . take 20 . g $ [1..]
14:20:40 <lambdabot>   20
14:22:52 <yshavit> TIL: fun( bug_triage ) < fun ( haskell_experimentation )
14:37:28 <NemesisD> can anyone take a look at this build output and let me know what may be going on? can't build pcre-light. seems to be a library issue.
14:37:32 <hpaste> NemesisD pasted “pcre build failure” at http://hpaste.org/55242
14:38:24 <ciaranm> i need to represent two algebraic types. the values of one are a strict subset of the values of the other. having two lots of different but similarly named data constructors gets annoying. is there a better way?
14:39:29 <Peaker> ciaranm: GADTs can let you at least make it safe, perhaps
14:39:56 <monochrom> --extra-include-dirs=/usr/lib is strange. wouldn't you rather have --extra-include-dirs=/usr/include ? but I doubt it makes a difference
14:39:59 <Peaker> ciaranm: have a small type with some phantom tag of which constructor it is, and then a bigger type with the same tag, that contains the same cases with extra info
14:40:12 <rwbarton> GADTs are an option, or you can separate the extra constructors into an 'Other a' constructor
14:40:41 <Peaker> GADTs are useful here only if you want to add more fields to the same constructors, perhaps
14:41:04 <NemesisD> monochrom: i might have gotten that wrong. i don't know what i'm doing when it comes to linking to system libraries. same error though when i change include to /usr/include
14:42:09 <NemesisD> happens for older versions of pcre-light too. tried all the way down to 0.2.*
14:42:33 <mateu> > let midTrip n = (n^2-1)/2;  perfectTriples limit = [(n, midTrip n, 1 + midTrip n)  | n <- [3,5..limit]];  perfectTriples 7
14:42:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:43:06 <ciaranm> hrm, this is a mess. maybe i should just use the larger type everywhere and cheat.
14:44:07 <monochrom> "Base.hsc:417: error: ‘PCRE_DUPNAMES’ undeclared (first use in this function)" is a compile-time error. we aren't even linking. some thing is not right with the C header files. but since it doesn't say "blahblah.h not found", I assume the C header files are found, just not with expected content. I would first guess version mismatch.
14:44:37 <NemesisD> *kicks EPEL and RHEL*
14:45:04 <NemesisD> any suggestion? i'm just trying to compile for a production box that can't run GHC newer than 6.100
14:45:07 <NemesisD> 6.10*
14:45:23 <alistra> what's EPEL?
14:45:37 <kmc> extra packages for enterprise linux
14:45:43 <NemesisD> extra packages for enterprise linux
14:45:46 <monochrom> I don't think GHC version matters that much here. I rather think C-side PCRE version matters a lot here.
14:46:00 <NemesisD> yeah. the haskell library doesn't seem to specify what version
14:47:21 <monochrom> it's almost impossible for cabal to enforce C-side lib versions. it's possible to use autoconf for it, but tedious.
14:48:08 * kmc has bad memories of trying to get xmonad to run on RHEL 4
14:48:17 <NemesisD> yeah i was more talking about mentioniing it in the package description or something
14:48:27 <NemesisD> oh and i forget sometimes. i'm actually using centos5.5
14:48:28 <alistra> if you have rhel
14:48:33 <alistra> call the phone support
14:48:41 <alistra> oh
14:48:43 <monochrom> heh
14:48:48 <alistra> @ centos
14:49:12 <alistra> all the bad sides and none of the good sides
14:49:25 <kmc> that's one view
14:49:31 <kmc> the other view is that you get all of red hat's work for free
14:49:41 <kmc> and trust me, they do put in significant work that the other distros don't
14:49:46 <kmc> it may not matter to you, but it matters to some
14:50:02 <NemesisD> im annoyed that i have to do it at all. i hate using a VM with an OS i don't know to compile
14:50:12 <alistra> i never tried it
14:50:17 <alistra> only hear stories
14:50:21 <kmc> debian, ubuntu, fedora don't even keep track of when they've fixed security holes in the kernel
14:50:37 <monochrom> there is always the prospect of compiling and linking on one platform, and deploying the executable on another platform.
14:50:38 <kmc> i mean they try, but they fuck it up a lot more often than red hat does
14:50:39 <alistra> using gentoo :P
14:51:05 <alistra> they had some security advisory thingie
14:51:17 <alistra> glsa it was called
14:51:30 <NemesisD> monochrom: can't do that because it gets a bunch of linker errors when i try to deploy on my machine
14:51:41 <NemesisD> i run a different kernel version
14:51:44 <alistra> http://www.gentoo.org/security/en/glsa/index.xml
14:52:19 <kmc> yeah, all of the distros put these out
14:52:27 <kmc> the difference is that e.g. ubuntu's is full of errors
14:52:28 <donri> oh look gentoo.org still looks like 2003
14:52:34 <kmc> every time
14:52:54 <kmc> (at least on the kernel side)
14:52:57 <alistra> well gentoo has a rolling release so some times you ecounter a crappy package
14:53:36 <kmc> also ubuntu will regularly screw up backporting a kernel patch
14:53:47 <kmc> they take only one of a multi-patch series, or just misunderstand the patch and fail to fix the hole
14:53:49 <NemesisD> i'm going to be very sad if i spent all this time developing this project and can't compile it for use in production
14:53:54 <kmc> red hat does this too, but much less often in my experience
14:54:19 <kmc> my point with all this is not "ubuntu sucks" but just that you do get something different from RHEL / CentOS
14:54:29 <kmc> whether it's valuable to you personally or not
14:54:31 <kmc> and i'm off topic ;P
14:54:41 <acowley> dreixel: sorry I was afk on the phone. I wrote some TH to meet my immediate needs, but I look forward to the improved understandability of the generics mechanism with PolyKinds!
14:57:09 <erider> Hi all
14:58:44 <ericeatsbrains> NemesisD: you could try backporting a newer libpcre (I assume it wouldn't have too many other dependencies so you can probably just rebuild an srpm), or patching pcre-light with something like this: https://fedorahosted.org/pipermail/sssd-devel/2009-September/000331.html
15:00:06 <ciaranm> if i've got data X = Y | Z ; data A = B X | C X , can i write a pattern for an A that will match either a B Y or a C Y?
15:00:28 <monochrom> no, we don't have that
15:00:34 <NemesisD> ericeatsbrains: not sure how to backport the newer libpcre. would that patch take care of the other compile errors, or would pcre-light just eat dirt when it tries to use that constant?
15:01:18 <ericeatsbrains> NemesisD: that patch would only fix the PCRE_DUPNAMES problem; you'd need to do something else to resolve the other failures
15:01:38 <ciaranm> hrm. maybe i can do it via a little helper
15:02:01 <ericeatsbrains> rebuilding an RPM is pretty easy. let me see if libpcre is as self-contained as I suspect it is
15:02:22 <NemesisD> ericeatsbrains: i like your backport idea more. i really appreciate your help on this. i'm out of my element on RPMs, I use arch
15:05:14 <ericeatsbrains> NemesisD: I can't remember if RHEL5 builds out of /usr or $HOME by default. try step 2 here, which should configure it for $HOME: http://www.lamolabs.org/blog/164/centos-rpm-tutorial-1/
15:05:42 <clsmith> is there an existing function which yields the 'paths' through a list of lists? e.g., [[1,2],[3,4],[5,6]] -> [[1,3,5],[1,3,6],[1,4,5],[1,4,5],...] ?
15:06:05 <clsmith> uh, that should be [1,4,6]
15:06:06 <ericeatsbrains> then download http://mirror.centos.org/centos/6/os/SRPMS/pcre-7.8-3.1.el6.src.rpm into ~/rpmbuild/SRPMS and run rpmbuild --rebuild ~/rpmbuild/SRPMS/pcre-7.8-3.1.el6.src.rpm
15:06:16 <rwbarton> sequence
15:06:35 <Axman6> > sequence [[1,2],[3,4],[5,6]]
15:06:36 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
15:06:58 <clsmith> !! awesome. i'd've never have guessed from its type
15:07:00 <clsmith> thanks
15:07:13 <NemesisD> ericeatsbrains: are you sure about that url, i get a 404
15:07:25 <ciaranm> heh. with most other programming languages people search for library functions by description, not type
15:07:41 <ericeatsbrains> bah. pkgs.org has a bad link
15:07:42 <Axman6> clsmith: especially for lists: sequence :: [[a]] -> [[a]]
15:07:50 * ciaranm found intercalate by searching by type
15:08:07 <rwbarton> @hoogle [[a]] -> [[a]]
15:08:08 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
15:08:08 <lambdabot> Prelude concat :: [[a]] -> [a]
15:08:08 <lambdabot> Data.List concat :: [[a]] -> [a]
15:09:10 <ericeatsbrains> NemesisD: this mirror still has it: ftp://ftp.icm.edu.pl/vol/rzm2/linux-fedora/linux/enterprise/6Server/en/os/SRPMS/pcre-7.8-3.1.el6.src.rpm
15:14:17 <NemesisD> ericeatsbrains: i get a MD5 mismatch on pcre-7.3-multilib.patch;4ee7e2c0
15:17:27 <kissyboy> is forall a. a -> Foo equivalent to (exists a. a) -> Foo?
15:18:07 <ericeatsbrains> NemesisD: maybe I should follow along here instead of just throwing these commands out.
15:19:03 <NemesisD> ericeatsbrains: that would be awesome :)
15:21:16 <ericeatsbrains> NemesisD: yet another download URL! http://vault.centos.org/6.0/os/SRPMS/Packages/pcre-7.8-3.1.el6.src.rpm
15:21:37 <ericeatsbrains> I just built it successfully on RHEL6, so I know the package is intact. you may still run into problems on RHEL5: we can hack up the .spec file if so
15:23:25 <NemesisD> ericeatsbrains: i'm using centos 5.5, same md5sum error, except it has a different partial hash at the end of the patch bit
15:23:30 <NemesisD> which is odd...
15:24:04 <NemesisD> ericeatsbrains: whats the md5sum on that rpm for you
15:24:23 <ericeatsbrains> b7c3814852df071f9c1061d666c389ab  pcre-7.8-3.1.el6.src.rpm
15:25:01 <NemesisD> same here :/
15:25:30 <ericeatsbrains> and for the patch: ccc709286d5bec09a2b09fba4a99c91f  ../SOURCES/pcre-7.3-multilib.patch
15:25:47 <ericeatsbrains> (you'll need to rpm -ivh SRPMS/pcre-7.8-3.1.el6.src.rpm to install the patches)
15:25:58 <NemesisD> ericeatsbrains: oh, what patch are you talking about, have i missed a step?
15:26:17 <ericeatsbrains> it should be unpacking things transparently when you do a --rebuild, but if you rpm -ivh it you can inspect them by hand
15:26:21 <NemesisD> im just running rpmbuild --rebuild therpmfile.rpm
15:26:47 <NemesisD> ericeatsbrains: totally don't have that patch in SOURCES
15:27:04 <ericeatsbrains> even after you rpm -ivh SRPMS/pcre-7.8-3.1.el6.src.rpm ?
15:27:14 <ericeatsbrains> don't need to run that as root, btw
15:27:29 <ericeatsbrains> should just unpack the sources into ~/rpmbuild/SOURCES
15:28:26 <NemesisD> error: unpacking of archive failed on file /home/vagrant/rpm/SOURCES/pcre-7.3-multilib.patch;4ee7e62d: cpio: MD5 sum mismatch
15:28:37 <NemesisD> also it says group mockbuild does not exist - using root
15:28:45 <ericeatsbrains> aw, crap... they changed the archival format between 5 and 6. I forgot about that
15:29:37 <ericeatsbrains> let me paste the .spec and .patch files. it's possible to assemble al lthe pieces yourself
15:30:31 <NemesisD> okay
15:34:06 <ericeatsbrains> NemesisD: http://hpaste.org/55246 . first chunk should go into rpmbuild/SPECS/pcre.spec, the second into rpmbuild/SOURCES/pcre-7.3-multilib.patch
15:35:54 <ericeatsbrains> then grab the bz2 from http://sourceforge.net/projects/pcre/files/pcre/7.8/ and put it into SOURCES as well
15:36:08 <ericeatsbrains> finally, cd into the SPECS dir and run: rpmbuild -ba pcre.spec
15:40:00 <NemesisD> building now
15:41:01 <ericeatsbrains> there is no step 38. it couldn't be easier!
15:43:24 <NemesisD> ericeatsbrains: if this works an im able to build my project on this machine, will i hve to go through this on the production box i'm compiling for?
15:44:49 <ericeatsbrains> NemesisD: shouldn't. once you've got it built you can just copy the RPM to the production box and rpm -Uvh it
15:47:26 <NemesisD> ericeatsbrains: so my final rpms are the ones in RPMS/i386 right? and i install those with rpm -i ?
15:47:56 <ericeatsbrains> yep, those are the ones, although you'll need to use rpm -U instead of -i, since this is an upgraded version of an existing package
15:50:50 <salisbury> augur: could you post the link to your paper again? I'd like to show it to someone
15:52:08 <NemesisD> ericeatsbrains: it worked!!! thanks so much
15:52:57 <ericeatsbrains> yay! glad that got it going
15:53:41 * ericeatsbrains appreciates #haskell's indulgence of RPM talk
16:01:07 <NemesisD> same here. thats about as much rpm talk as i can handle in a day
16:04:00 <Patinho`Busy> o/
16:09:46 <NemesisD> *punch punch* ghc 6.10 doesn't support DeriveFunctor which mysql-simple requires
16:10:48 <copumpkin> why are you on 6.10??
16:10:54 <benmachine> NemesisD: you're three major versions behind :P
16:11:08 <hpc> copumpkin: because enterprise - you missed a big discussion about half an hour ago
16:11:10 <copumpkin> NemesisD: I started haskell 3 years ago, right when 6.10 came out
16:11:12 <copumpkin> oh
16:11:16 <copumpkin> well, fuck enterprise
16:11:19 <benmachine> haha
16:11:22 <NemesisD> excuse my french but its this god damn host with their centos5.5
16:11:38 <copumpkin> NemesisD: just install a more recent ghc in your home directory?
16:11:39 <NemesisD> evidently versions beyound 6.10 use a version of libc which breaks everything else in the known universe
16:12:45 <mike-burns> Dude can't you build an RPM of a newer version?
16:12:47 <NemesisD> so heres a question, if i somehow manage to install a modern version of GHC on my centos5.5 VM and compile it, then take the binary over to my host, it will blow up because its linked against a different libc right?
16:12:47 * mike-burns ducks
16:15:07 <Draconx> NemesisD, depends on how different the libcs are.
16:15:37 * benmachine wonders if you could compile object files and then link them on the host
16:16:24 <NemesisD> i'm tempted to just spin up another tiny vps on my host using an image that isn't stuck in the ghc stone age
16:16:46 <NemesisD> they've got debian 5
16:17:11 <parcs__> change hosts
16:17:23 <parcs__> i recommend linode
16:17:56 <NemesisD> can't. this is a small project and i need datacenter access for it to work. my company would just as easily say abandon this couple-weeks-long-for-no-pay project than do that
16:18:06 <Clint> upgrading debian is a piece of cake
16:18:33 <NemesisD> they also have debain 6, didn't see it before
16:19:09 <parcs__> i think debian 6 is still stuck on 6.12
16:19:14 <parcs__> last time i checked
16:19:23 <NemesisD> god i hate all distro repositories
16:19:40 <parcs__> but you can easily upgrade to debian testing from debian 6
16:19:58 <Clint> and somebody was talking about doing a ghc backport
16:20:01 <parcs__> debian testing has ghc 7
16:20:08 <NemesisD> which would be less painful, doing that or compiling ghc 7.x
16:20:13 <parcs__> that
16:20:30 <parcs__> you only have to change a couple of lines in /etc/apt/sources.list
16:20:42 <parcs__> then apt-get update; apt-get dist-upgrade
16:20:48 <hpc> debian-testing++
16:21:06 <NemesisD> ok thats not so bad
16:22:26 <benmachine> compiling ghc has never been a problem for me
16:22:33 <benmachine> it takes a while but it's generally straightforward
16:23:26 <mike-burns> Same with upgrading Debian.
16:26:05 <NemesisD> hmm so i'm thinking i run a VM with debian 6 testing, compile it there then send it to my vanilla debian 6 VPS. is that likely to work?
16:26:51 <hpc> NemesisD: compile ghc7?
16:27:12 <NemesisD> hpc: no, upgrade my VM of debian 6 to testing and then install it from the repos
16:30:56 <parcs__> that should work
16:34:11 <NemesisD> cool. i'll give that a shot
16:46:26 <sal23> is there a way to define a STRef member through closure or another trick when defining an instance of Storable? Since Storable is a class, compiler won't let me define a new member for the instance
16:47:24 <benmachine> sal23: what would that mean? it sounds impure
16:48:12 <rwbarton> you could perhaps cook up a Storable instance that depends on an STRef via the implicit configuration trick, but you still wouldn't be able to read the STRef
16:48:20 <sal23> benmachine: this shouldn't be impure since the purpose of this variable is to keep track of state for that instance
16:49:02 <sal23> benmachine: that way, when a vector instance is created, it can do some book-keeping that a user can query for…the value won't change since the instance is inmutable
16:49:22 <benmachine> sal23: I think we're using "instance" in different ways
16:50:57 <sal23> benmachine: how would you add book-keeping function to an storable instance then? the instance is defined for a new data type like the example here: http://goo.gl/BQ3YC
16:51:37 <rwbarton> The question doesn't make sense to me.  What is "book-keeping function"?
16:52:36 <rwbarton> if you want some other function that operates on your new data type, you can just write it.  no relation to Storable.
16:52:58 <monochrom> I don't think anyone understands the question.
16:53:47 <sal23> rwbarton: in my case, the book-keeping function keeps track of all the data bytes that have been stored in the instance…the instance stores pointers to cchar, and the bookkeeping function at the poke stage, calculates how many bytes are in each ptr cchar, and then increment the total bytes allocated
16:54:19 <rwbarton> @type poke
16:54:19 <lambdabot> Not in scope: `poke'
16:54:23 <rwbarton> @hoogle poke
16:54:23 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
16:54:23 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
16:54:23 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
16:54:50 <sal23> so, if I want to store a vector of (ptr cchar), and then do a bytestring conversion using unsafeCreate, I want to be able to query the vector instance to find out how many bytes I need to allocate for unsafeCreate
16:54:55 <sal23> @type unsafeCreate
16:54:56 <lambdabot> Not in scope: `unsafeCreate'
16:55:04 <sal23> @hoogle unsafeCreate
16:55:04 <lambdabot> No results found
16:55:54 <shachaf> @ty Data.ByteString.Internal.unsafeCreate
16:55:55 <lambdabot> Int -> (GHC.Ptr.Ptr Word8 -> IO ()) -> BSC.ByteString
16:56:08 <rwbarton> er
16:56:08 <monochrom> "a vector of (ptr cchar)" obviously in the C mentality of never storing sizes.
16:56:21 <rwbarton> > Data.ByteString.Internal.unsafeCreate 1 (const $ putStrLn "Hello")
16:56:21 <lambdabot>   Not in scope: `Data.ByteString.Internal.unsafeCreate'
16:56:25 <rwbarton> oh
16:56:33 <shachaf> rwbarton: @ty can access things that > can't.
16:56:48 <mike-burns> @hoogle unsafeCrate
16:56:48 <lambdabot> No results found
16:57:10 <monochrom> to do things properly, you should just not use "a vector of (ptr cchar)". use "a vector of (int, ptr cchar)" or something.
16:57:38 <sal23> monochrom: right, I am just simplifying here by not adding too many details
16:58:13 <rwbarton> I am still very confused but of course you can add an IORef to the data that is your Storable instance...
16:58:15 <hpaste> “Ertugrul Söylemez” pasted “List length guarantees” at http://hpaste.org/55252
16:58:21 <Eduard_Munteanu> unsafeBox
16:58:26 <mm_freak_> http://hpaste.org/55252 ⇐ why doesn't this work?
16:58:31 <mm_freak_> fromList works
16:58:36 <mm_freak_> but catV fails
16:58:52 <monochrom> well, if you have "a vector of (int, ptr cchar)", then writing the Storable instance is straightforward
16:59:13 <mm_freak_> seems like it can't guarantee that "catV (Cons x xs) ys = Cons x (catV xs ys)" really fits the type
16:59:59 <sal23> rwbarton: it is easier to do the bookkeeping while creating the vector instance…I want to do it once, and amortize the cost…otherwise, it goes like: create a vector instance, again peek into it, gather all the lengths, and add them
17:00:06 <rwbarton> mm_freak_: type instance Add (Succ x) y = Add x (Succ y)
17:00:12 <rwbarton> don't you mean...
17:00:26 <rwbarton> type instance Add (Succ x) y = Succ (Add x y)
17:00:55 <mm_freak_> rwbarton: actually yeah, that makes sense…  i was rather thinking of how the regular + is defined inductively
17:01:09 <rwbarton> oh I see
17:01:19 <m3ga> i'm pretty sure that iteratee is the new monad
17:01:23 <rwbarton> I think it is hard for it to see that those are the same though
17:01:27 <mm_freak_> rwbarton: indeed, that works…  thanks!
17:01:38 <rwbarton> it would need to induct on y to see that
17:01:43 <mm_freak_> true
17:02:00 <rwbarton> and as far as it knows in some contexts, maybe y isn't Zero or Succ - at all so...
17:02:32 <mm_freak_> yeah, so i should go for simpler rules, when this happens
17:02:46 <dgpratt> missing C library: sqlite3, any idea where I could get this for Windows?
17:03:06 <mm_freak_> i wonder if there is a way to write fromList without CPS
17:03:07 <_|ur1> hi, does anyone know, who is iamsaint ?
17:03:13 <monochrom> does sqlite3 have a website?
17:03:18 <mm_freak_> RankNTypes is fine, but the CPS can get inconvenient
17:03:30 <_|ur1> he is spamming the hole time over private message
17:03:33 <sal23> monochrom: yes, it is straight forward to write storable instance for (int, ptr cchar), but no way to get total length without again peeking into it…the cost of traversal is really high because there are millions of elements in the vector
17:03:33 <_|ur1> +w
17:03:44 <rwbarton> _|ur1: so not a saint after all then
17:03:45 <dgpratt> monochrom: it does, but I'm not sure what I should be grabbing
17:03:59 <_|ur1> yes rwbarton :D
17:04:28 <_|ur1> that's how it looks like: (03:29:17) iamsaint:
17:04:28 <_|ur1> C  4  3  3  R  J  O  +  u  <  Q  O  B  (  t  b  y  g  (    E  E  \  9  {  F  H  k    ]  u  D  S  ^  @  *  A  T  q  F  b  C  /  u  o  X  S  B  &  R  W  k
17:04:28 <_|ur1> (03:29:30) iamsaint:
17:04:29 <_|ur1> \  ?  *  V  W  [  h  B  F  o    `  i  c  :  G  b  -  %  G  +  t  D  h  V  ^  Z  v  D  +  M  >  Y  g  w  S  {  x  g  M  /  :  Z  K  H  /  C  @  G  /  #  W
17:04:29 <_|ur1> (03:29:35) iamsaint:
17:04:29 <_|ur1> )  g  N  !
17:04:29 <_|ur1> (03:29:36) iamsaint:
17:04:30 <_|ur1> ]  _  D  L
17:04:33 <rwbarton> yikes
17:05:05 <monochrom> I think I saw that before.
17:05:07 --- mode: ChanServ set +o monochrom
17:05:12 --- mode: monochrom set +b *!*@182.7.215.51
17:05:12 --- kick: iamsaint was kicked by monochrom (iamsaint)
17:05:22 --- mode: monochrom set -o monochrom
17:06:58 <hajhouse> has anyone any experience writing php extensions in haskell?
17:07:02 <rwbarton> sal23: whoever is doing the poking should be keeping track of the total
17:07:30 <monochrom> I am also pleased to say that freenode now supports user mode +g, too. it means you block pm and gets one succint notification, i.e., if I pm you a million times in a short period, you get only one line saying that I have pm'ed you, and that line doesn't even include any of my messages
17:08:59 <sal23> rwbarton: where would poke store the total? we are poking (int, ptr cchar) here, and want to store the running total in another variable
17:09:19 <rwbarton> that's why I said "whoever is doing the poking"
17:09:32 <monochrom> since you're the author of the Storable instance, you decide the memory layout and you can store pretty much anything you please.
17:10:42 <sal23> not Storable instance that is used for vector, from what I tried…for Foreign.Storable, yes
17:11:19 <monochrom> then newtype-wrap it
17:11:28 <sal23> you can store sizeOf and alignment, but not anything else…compiler will complain otherwise about it not being a visible member of Storable class
17:12:31 <sal23> monchrom, hmm, let me look up some example to see what you mean
17:14:01 <monochrom> "store sizeOf and alignment"? that doesn't happen.
17:14:13 <rwbarton> what are you really trying to do?
17:16:12 <rwbarton> Storable is for defining memory layouts of things with fixed size.
17:17:31 <sal23> rwbarton: yes, thought so…question is how do you wrap a function within poke within storable definition so that it can refer to a variable outside storable
17:18:09 <rwbarton> while it is technically possible to do this using extremele trickery, the answer is "you don't".
17:18:09 <sal23> closure is what comes to my mind, but I can't think of how to do it with a storable instance definition
17:18:51 * hackagebot zoom-cache 0.9.1.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.9.1.0 (ConradParker)
17:19:38 <monochrom> perhaps use "binary" or "cereal" for variable-size things?
17:19:46 <sal23> not sure if this can be called extreme trickery if all I am doing is storing state
17:20:16 <rwbarton> well think about it
17:20:24 <rwbarton> you have some type which is a newtype wrapper around Ptr CChar or whatever
17:20:26 <sal23> monochrom, too slow for my use case
17:20:29 <rwbarton> and it has a Storable instance
17:20:37 <rwbarton> which has some state?
17:20:40 <rwbarton> Where does that state live?
17:21:15 <sal23> that I don't know yet…otherwise I wouldn't be asking :)
17:21:31 <monochrom> too-slow is still infinitely faster than cannot-be-done or incorrect.
17:22:26 <rwbarton> how do you keep various users of your instance from interfering with each other?
17:22:42 <cl1> i want to take an image (jpg) and chop the left side off and put it on the right side. would that be too ambitous for a newb to haskell (i have 12+ years programming experiance)?
17:22:52 <monochrom> not to mention that how fast "binary" or "cereal" is is really up to its user, you.
17:23:17 <rwbarton> how do you know that the state is even a sensible thing to keep track of? I'd think it was reasonable to assume that "poke p x" is an idempotent operation
17:23:20 <sal23> that is another question I wanted to ask…a state for a vector instance is only for that instance, right?
17:24:09 <monochrom> wth is "a state for a vector instance" supposed to mean?
17:24:10 <rwbarton> so maybe the code you are using pokes the same value to the same location twice, is that going to be okay with your book-keeping?
17:24:30 <rwbarton> If the answer is "I know that won't happen because I am writing the code that calls poke" then why not do the book-keeping in that code?
17:24:34 <sal23> yep, it is going to be responsibility of book-keeping function
17:24:56 <rwbarton> why are you so attached to Storable at all?
17:25:37 <sal23> because I am doing fast FFI on data, and in all my tests I did so far, storable vector is the one that works well
17:25:47 <cgroza> Hello. I am trying to build a parser with Parsec. I wont to remove spaces that may or not may be there. So far, if a space exists, it runs ok, but if it does not, it fails and errors. How do I make it go on with the next parsers? Here is my code : first <- spaces >> (letter <|> symbol)
17:26:05 <sal23> so, fast FFI into storable vector, transformation through vector operations, and then convert to bytestring...
17:26:18 <joe9> cgroza: many (noneOf " ")
17:26:47 <sal23> I am trying to handle millions of byes of data every second, to keep up in real-time without delay
17:26:49 <m3ga> @quote iteratee
17:26:50 <lambdabot> ddarius says: The history of iteratees is making a simple idea complex.
17:27:00 <m3ga> @quote iteratee
17:27:00 <lambdabot> ddarius says: The history of iteratees is making a simple idea complex.
17:27:01 <gwern> > gcd 10 5
17:27:01 <lambdabot>   5
17:27:17 <sal23> this is my proof-of-concept that I can do with haskell what people claim can only be done with C
17:27:26 <m3ga> @remember m3ga says: i'm pretty sure that iteratee is the new monad
17:27:26 <lambdabot> Okay.
17:27:30 <cl1> cgroza: this tutorial uses parsec, i plan on reading it after i'm done with learn you a haskell. It might have some info
17:27:36 <Eduard_Munteanu> cl1: not really, but you probably need to get familiar with stuff like IO and some particular image handling lib
17:27:38 <rwbarton> I suggest you write your code using binary if only so that you can communicate what it is you're doing...
17:27:59 <rwbarton> in fact, apparently you have already written it since binary is too slow
17:28:03 <cl1> Eduard_Munteanu: thanks for the tip
17:28:04 <gwern> > rem 10 5
17:28:05 <lambdabot>   0
17:28:08 <gwern> > rem 10 6
17:28:08 <lambdabot>   4
17:28:24 <sal23> yep, precisely
17:28:34 <cgroza> joe9: still errors. It says : expecting letter"
17:29:18 <gwern> > rem 10 (-6)
17:29:18 <lambdabot>   4
17:29:20 <rwbarton> can you paste the binary-using code?
17:29:25 <gwern> > rem (-10) (6)
17:29:26 <lambdabot>   -4
17:29:37 <rwbarton> and what you're trying to write using storable-vector?
17:29:45 <cl1> i think that might be a good starter project for me then, and I can fix my desktop backgrounds on win 7 in the process :D
17:30:08 <Eduard_Munteanu> "Fix" them? :)
17:30:12 <sal23> rwbarton, my question on stackoverflow here: http://goo.gl/60qo6
17:30:58 <cl1> i, thanks to my awesome wife, now have 3 monitors. I have my task bar on the middle one. The only way to get a background to span (5760x1080) is to tile the image.
17:31:32 <Eduard_Munteanu> Ah.
17:31:41 <cl1> Unfortunately it starts tiling from the monitor that has the taskbar, so my image starts in the middle, draws on the right monitor, and then wraps to the left one
17:32:02 <cgroza> how do I skip characters that may or not be there with parsec?
17:32:38 <Eduard_Munteanu> Surely there must be a decent way to fix that, but I guess that's no fun.
17:32:54 <rwbarton> sal23: so a C function is giving you an array of char *s?
17:33:25 <sal23> rwbarton, yes
17:33:29 <monochrom> "I am trying to write a storable vector instance for CString" so this is Vector CChar. why is Ptr even involved?
17:33:50 <rwbarton> no, he means the elements of the vector are CStrings, I think
17:33:51 * hackagebot scope 0.5.2.0 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-0.5.2.0 (ConradParker)
17:33:55 <sal23> right
17:34:06 <rwbarton> and he is just storing them as pointers
17:34:11 <cl1> not out of the box, if i were using tripleHead2Go or eyefinity i could probably fix it, but i have neither
17:34:19 <sal23> or (Int, Ptr CChar)
17:34:30 <sal23> where Int = length of that string
17:35:04 <rwbarton> and eventually you want to allocate sum(length of all the strings) bytes
17:35:08 <sal23> exactly
17:35:49 <sal23> I will like to avoid traversing the vector twice, once to store, and second time to calculate total length
17:36:14 <rwbarton> isn't the C program what does the storing?
17:36:52 <rwbarton> so you just magically acquire a bunch of (Ptr CChar)s
17:36:52 <sal23> right, I mean the poking operation that stores that pointer in the vector
17:37:09 <rwbarton> again, isn't that "poking" done in C or do I misunderstand
17:37:30 <rwbarton> or you get them one at a time
17:37:30 <rwbarton> ?
17:37:47 <sal23> ahem, poking is done in haskell vector instance
17:38:09 <rwbarton> but...
17:38:19 <rwbarton> you say your vector comes from C
17:38:23 <rwbarton> so, I don't understand
17:38:40 <sal23> yep, so, you know the Ptr address
17:38:52 <sal23> C tells you here is the Ptr address
17:39:04 <sal23> and you store that address in the vector
17:39:09 <rwbarton> ...
17:39:21 <rwbarton> < rwbarton> you say your vector comes from C
17:39:26 <rwbarton> I didn't say string
17:39:28 <rwbarton> did you mean string?
17:39:46 <sal23> let us just assume for simplicity we have a CString
17:40:08 <rwbarton> let's back up
17:40:16 <rwbarton> you are getting some data from a C function
17:40:23 <rwbarton> how do you get that data?
17:40:31 <sal23> through FFI
17:40:36 <rwbarton> well obviously
17:40:47 <rwbarton> you call something once and you get a big array of (char *)s?
17:40:53 <sal23> yep
17:41:01 <rwbarton> okay, so that is your vector
17:41:27 <sal23> yep
17:41:34 <rwbarton> so why would you ever call poke
17:41:49 <rwbarton> poke is for when you want to send data to C
17:42:05 <rwbarton> or do you mean when you're building the ByteString?
17:42:32 <sal23> hmm, Vector Storable is different from Foreign.Storable
17:42:59 <sal23> a poke in Vector Storable is an operation of injecting new vector element
17:44:09 <sal23> a peek is retrieving a vector element
17:44:16 <rwbarton> yes
17:44:27 <rwbarton> can you point me at the documentation for "Vector Storable"?
17:44:38 <sal23> http://www.haskell.org/haskellwiki/Numeric_Haskell%3a_A_Vector_Tutorial#Storing_your_own_types_in_Storable_vectors
17:44:49 <rwbarton> no, I mean the Haddock documentation
17:45:11 <rwbarton> just so I know precisely what package/module/class you are talking about
17:45:18 <sal23> http://hackage.haskell.org/packages/archive/vector/latest/doc/html/Data-Vector-Storable.html
17:45:30 <rwbarton> Okay
17:45:34 <rwbarton> thanks
17:47:24 <rwbarton> that Storable class is just the one from Foreign.Storable reexported, of course
17:47:53 <rwbarton> but never mind
17:48:00 <sal23> yep, that would make sense
17:48:17 <sal23> given the commonality they have
17:49:33 <rwbarton> so I still don't see why you want to ever call poke
17:50:22 <rwbarton> but anyways, if a C function is giving you an array of (char *)s (C strings), and you want to allocate a block equal to their total length in size and copy all the strings into it...
17:50:23 <monochrom> in fact, I don't see why Vector is useful
17:50:35 <rwbarton> surely you need to do two passes over the array to do that
17:50:37 <rwbarton> Haskell or no
17:51:06 <rwbarton> the C function could probably keep track of the total size, and return that as well
17:51:38 <dgpratt> one thing I miss greatly from C#/.Net in Haskell is LINQ, which is very ironic since (I believe) Haskell inspired much of LINQ
17:51:38 <monochrom> or one pass on the input, at the expense of several passes of the output, i.e., keep resizing the output block.
17:52:00 <rwbarton> also, if you are writing these strings over a file descriptor, how about using an iovec-style write system call rather than copying
17:52:02 <dgpratt> is persistent the closest thing we have in Haskell-land?
17:52:07 <sal23> yep, but it could do that, but I prefer not to write in C…the FFI is third-party library…so, I am not writing in C anyway
17:52:34 <rwbarton> if you're using shared memory I guess that doesn't apply
17:52:52 <sal23> well, I had a simple example, but the vector is actually a vector of mixed data types…so, it can have Int, short, cstrings etc, each tagged with the type
17:53:19 <sal23> then I can write a custom conversion function to walk through the vector, and pass it to bytestring unsafeCreate
17:53:46 <parcs__> dgpratt, there's haskelldb and groundhog and other ones
17:54:00 <parcs__> persistent is probably the most popular though, due to yesod
17:57:20 <dgpratt> parcs__: not too familiar with haskelldb, but it does not appear to map stuff automatically to native data structures; groundhog looks interesting, though
17:58:34 <Clint> you can have it generate code from a database
17:58:52 <dgpratt> I really like having the option of formulating a query as though it were over an in-memory native data structure, but it gets translated and execute on the DB
17:59:10 <dgpratt> Clint: oh, I wasn't aware of that
17:59:24 <dgpratt> Clint: which are you referring to, to be clear?
17:59:27 <Clint> haskelldb
17:59:45 <aavogt> haskelldb does return rows as "extensible" records
18:00:00 <dgpratt> Clint: I guess I'll have to investigate further :)
18:00:06 <sal23> rwbarton, monochrom, thanks for help this evening. I am going to go log off
18:00:31 <dgpratt> aavogt: something like hlists?
18:00:31 <Clint> good luck; the documentation is somewhat nonexistent
18:00:46 <parcs__> dgpratt, also check out acid-state
18:00:49 <dgpratt> Clint: thanks :)
18:01:09 <aavogt> yep: I think at one point there was a branch that used HList, but I don't think that's the case for the released version
18:01:10 <dgpratt> parcs__: ok, I'll add that to the list, thanks
18:01:55 <aavogt> which is kind of unfortunate, since manipulating those records is easier when you can depend on all those definitions in HList
18:02:35 <parcs__> acid-state allows you to manipulate any haskell data structure persistently, and even over the network
18:05:53 <dgpratt> parcs__: acid-state looks quite interesting, at a glance; given my background, it would be great if every data storage technology would include a direct comparison between itself and a traditional RDBMS :-)
18:06:51 <Axman6> what's going on! dgpratt you've gone away from the world of babanas, apples and Mistys, and now you're bacvk in the real world? D:
18:07:08 <dgpratt> Axman6: so it seems :)
18:07:41 <kcohn> if anyone is well-versed in the (untyped) lambda calculus, does anyone have any ideas on how to prove there doesn't exact a term, say p, that can distinguish beta-equality between *normal forms*, i.e. p s t = \xy.x if s = t  and p s t = \xy.y if s != t (where s and t are normal forms, and \xy.x is true and \xy.y is false)?
18:07:48 <Axman6> all the haskell I've been doing lately has been all IO real world shit anyway
18:08:26 <dgpratt> Axman6: though I have a copy of TaPL waiting for me to get back to it, so I'll be back in the theoretical world soon enough :-)
18:08:26 <Axman6> I need to comlpetely refactor my library for talking to this power meter some time. not something I look forward to doing in Vim
18:08:37 <cl1> real world as opposed to?
18:10:44 <dgpratt> Axman6: *puzzled* might you look forward to it in a different editor?
18:11:05 <Axman6> yeah, I miss the mouse when I have to move large amounts of code around
18:11:38 <Axman6> I know you can do the same stuff in vim, but i'm less familliar with it, and don't really care to relearn it again
18:11:44 <monochrom> the mouse is the human's best friend
18:12:03 <dgpratt> Axman6: you are bound to using vim, then?
18:12:18 <Axman6> well, over ssh I am
18:12:30 <dgpratt> Axman6: oooh
18:12:34 <Axman6> I can use notepad++ using WinSCP if i want to, which I might end up doing
18:13:00 <cl1> Axman6, y u no connect x windows server over ssh?
18:13:04 <Axman6> personally I'd really just prefer to use TextMate, but I'm not sure I'm allowed to bring my laptop into work and use it to access these supercomputers
18:13:19 <kfish> it might slow them down
18:13:19 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
18:13:20 <dgpratt> Axman6: I mess around with emacs and vim, but np++ is what I reach for when I need to get something done
18:13:24 <Axman6> cl1: notepad++ and WinSCP gave you no hinds? :P
18:13:35 * cl1 does not have supercomputers at work and is sad
18:13:45 <Axman6> o/ kfish
18:13:55 <cl1> oh, i see what you did there
18:14:03 <monochrom> if you have a smart phone, you have a supercomputer of the 1970s.
18:14:04 <rfm47> Axman6, you develop on a supercomputer?
18:14:06 <cl1> i missed that part about notepad++ and such
18:14:59 <Axman6> rfm47: well, currently just a single node that's got a couple of Telsa "GPUs"
18:15:12 <cl1> Axman6, create a vm on your box and run something that will run x windows, and then you can ssh into gui land?
18:15:14 <Axman6> but I've got access to some of Auatralia's top supercomputers too
18:15:19 <hpaste> djanatyn pasted “counting words” at http://hpaste.org/55253
18:15:23 <djanatyn> :D
18:15:35 <m3ga> Axman6: you bloody showoff! :-)
18:15:37 <Axman6> cl1: ha, a VM on this laptop would be amazingly painful sadly. it's only got 1GB, and windows & uses one of them
18:15:40 <djanatyn> read this blog post (http://www.leancrew.com/all-this/2011/12/more-shell-less-egg/) and wrote that
18:15:49 <Axman6> m3ga: =)
18:16:14 <djanatyn> anybody have a more elegant fix that I can learn from?
18:16:53 * cl1 thinks
18:17:17 <djanatyn> I wanted to go through a string, and for each word within the string, create a tuple containing the word and the number of occurrences
18:17:21 <djanatyn> it was fun.
18:18:06 <mauke> :t M.fromListWith
18:18:07 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
18:18:28 <mauke> :t M.fromListWith (+) . map (flip (,) 1) . words
18:18:29 <lambdabot> forall a. (Num a) => String -> M.Map String a
18:18:45 <mauke> > M.fromListWith (+) . map (flip (,) 1) . words $ "yo yo yo what is up my dogs this is the good life"
18:18:47 <lambdabot>   fromList [("dogs",1),("good",1),("is",2),("life",1),("my",1),("the",1),("th...
18:18:52 <Axman6> It's probably no surprise to anyone, but bloody hell GPUs are fast. this molecular dynamics stuff is about 10 times faster using two GPU's (it's a fairly small benchmark, i'd expect larger ones to be faster)
18:19:28 <Axman6> mauke: doesn't handle non-word characters as well as the bash one does
18:19:42 <Axman6> also, that was amazingly mapreduce-y
18:20:11 <Axman6> s/bash/shell i guess
18:20:24 <mauke> what shell one?
18:21:57 <djanatyn> tr -cs A-Za-z '\n' | tr A-Z a-z | sort | uniq -c | sort -rn | sed ${1}q
18:22:06 <Axman6> that one
18:22:18 <djanatyn> mauke: http://www.leancrew.com/all-this/2011/12/more-shell-less-egg/
18:23:46 <Axman6> > fromListWith (+) . map (,1) . words . filter (`elem` (['a'..'z']++['A'++'Z'])) $ "yo yo yo what is up my dogs this is the good life"
18:23:46 <lambdabot>   Not in scope: `fromListWith'Illegal tuple section: use -XTupleSections
18:24:06 <Axman6> > M.fromListWith (+) . map (\x->(x,1)) . words . filter (`elem` (['a'..'z']++['A'++'Z'])) $ "yo yo yo what is up my dogs this is the good life"
18:24:07 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
18:24:07 <lambdabot>    arising from a use o...
18:25:15 <Axman6> > M.fromListWith (+) . map (\x->(x,1)) . words . filter (`elem` (['a'..'z']++['A'++'Z'] ++ " \t\n")) $ "yo yo yo what is up my dogs this is the good life"
18:25:16 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
18:25:16 <lambdabot>    arising from a use o...
18:25:21 <Axman6> hmm
18:25:29 * Axman6 doesn;t enough to figure that out
18:27:01 <mauke> > M.fromListWith (+) . map (flip (,) 1) . words . map (\c -> if c `elem` (['a' .. 'z'] ++ ['A' .. 'Z']) then c else '\n') $ ($ "yo yo yo what is up my dogs this is the good life"
18:27:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:27:12 <mauke> > M.fromListWith (+) . map (flip (,) 1) . words . map (\c -> if c `elem` (['a' .. 'z'] ++ ['A' .. 'Z']) then c else '\n') $ "yo yo yo what is up my dogs this is the good life"
18:27:14 <lambdabot>   fromList [("dogs",1),("good",1),("is",2),("life",1),("my",1),("the",1),("th...
18:31:08 <Sgeo> Can I have data Whatever =
18:31:21 <Sgeo> on one line, then my constructors on each line below it?
18:31:28 <mauke> sure
18:31:32 <Axman6> yes, but you must indent the constructors
18:31:56 <Axman6> :t isAlpha
18:31:56 <lambdabot> Char -> Bool
18:32:01 <benmachine> and you have to work out where to put the |s
18:32:42 <Axman6> I often do: data Foo\n\t= Bar\n\t| Baz\n\t|Quux
18:32:54 <Axman6> > text "\ndata Foo\n\t= Bar\n\t| Baz\n\t|Quux"
18:32:55 <lambdabot>   data Foo
18:32:55 <lambdabot>          = Bar
18:32:55 <lambdabot>          | Baz
18:32:55 <lambdabot>          |Quux
18:33:04 <Axman6> heh, yay
18:33:28 <mauke> my %freq; $freq{$_}++ for $str =~ /[a-zA-Z]+/g; print "$freq{$_} $_\n" for (sort {$freq{$b} <=> $freq{$a}} keys %freq)[1 .. $n];
18:33:41 <Axman6> :|
18:34:00 <mauke> extracting the words is more pleasant in perl, but grouping and counting requires a hash and several statements
18:34:29 * Sgeo downloads emacs
18:34:38 <Axman6> mauke: isAlpha might be useful in the haskell version
18:34:44 <mauke> no, it isn't
18:34:49 <Axman6> > filter isAlpha [minBound..]
18:34:50 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\1...
18:34:57 <Axman6> why not?
18:35:04 <mauke> because it includes all that other crap
18:35:08 <Sgeo> Wait, why does haskell-mode rely on ghc6?
18:35:16 <Sgeo> Is my haskell-mode on emacs not going to be nice?
18:35:36 <rfm47> > map (head &&& length) . groupBy (==) . sort $ words "yo yo yo what is up my dogs this is the good life"
18:35:38 <lambdabot>   [("dogs",1),("good",1),("is",2),("life",1),("my",1),("the",1),("this",1),("...
18:36:03 <Sgeo> :t (&&&)
18:36:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:36:15 <mauke> :t \n -> take n . sortBy (flip $ comparing snd) . M.toList . M.fromListWith (+) . map (flip (,) 1) . words . map (\c -> if c `elem` (['a' .. 'z'] ++ ['A' .. 'Z']) then c else '\n')
18:36:16 <lambdabot> forall b. (Ord b, Num b) => Int -> [Char] -> [(String, b)]
18:36:22 <jessopher> Sgeo: what version of haskell are you using?
18:36:29 <jessopher> errr, ghc
18:36:30 <Sgeo> Ok, don't need to be using non-function arrows for &&& to be useful
18:36:37 <Sgeo> jessopher, some 7, I think
18:36:45 <Sgeo> Whatever was in my distro's haskell-platform
18:36:50 <Sgeo> (Ubuntu 10.10)
18:36:58 <jessopher> well in ubuntu, 7.0.3 is packaged as ghc6
18:37:03 <mauke> :t \n -> take n . sortBy (flip $ comparing snd) . map (head &&& length) . group . sort . words . map (\c -> if c `elem` (['a' .. 'z'] ++ ['A' .. 'Z']) then c else '\n')
18:37:04 <lambdabot> Int -> [Char] -> [(String, Int)]
18:37:10 <Axman6> jessopher: >_____<
18:37:13 <rfm47> Sgeo, nah, it's handy with tuples sometimes
18:37:25 <jessopher> in 11.10 anyhow
18:37:58 <mauke> > (\n -> take n . sortBy (flip $ comparing snd) . map (head &&& length) . group . sort . words . map (\c -> if c `elem` (['a' .. 'z'] ++ ['A' .. 'Z']) then c else '\n')) 3 "a.b.ab.a.cde ab"
18:38:00 <lambdabot>   [("a",2),("ab",2),("b",1)]
18:38:06 <jessopher> Sgeo: i doubt you will have any issues
18:38:43 <jessopher> Axman6: it threw me for a look when i saw the ghc and ghc6 meta packages both pointed to 7.0.3
18:38:50 <Sgeo> Erm, I meant 11.10
18:39:03 <jessopher> s\look\loop
18:39:15 <mauke> nicely evil use of \ there
18:39:21 <Axman6> well at least they're only three versions behind now
18:39:41 <jessopher> my fingers are doing their own thing right now, i should stop typing
18:39:43 <mauke> damn. I don't think perl has anything like group
18:39:54 <Axman6> :t isAscii
18:39:55 <lambdabot> Char -> Bool
18:40:36 <Axman6> :t liftM2 (&&) isAscii isAlpha
18:40:36 <lambdabot> Char -> Bool
18:40:52 <mauke> > (\n -> take n . sortBy (flip $ comparing snd) . map (head &&& length) . group . sort . words . map (\c -> if inRange ('a', 'z') c || inRange ('A', 'Z') c then c else '\n')) 3 "a.b.ab.a.cde ab"
18:40:54 <lambdabot>   [("a",2),("ab",2),("b",1)]
18:40:56 <Axman6> :t (&&)<$>isAscii<*>isAlpha
18:40:57 <lambdabot> Char -> Bool
18:41:17 <Axman6> > filter  ((&&)<$>isAscii<*>isAlpha) [minBound .. ]
18:41:18 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
18:42:02 <Axman6> :t isAcsii `mplus` isAlpha
18:42:03 <lambdabot> Not in scope: `isAcsii'
18:42:10 <Axman6> :t isAscii `mplus` isAlpha
18:42:11 <lambdabot>     No instance for (MonadPlus ((->) Char))
18:42:11 <lambdabot>       arising from a use of `mplus' at <interactive>:1:0-22
18:42:11 <lambdabot>     Possible fix:
18:42:15 <Axman6> :(
18:43:28 <Axman6> @instances Monoid
18:43:29 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:43:42 <Axman6> bah, no Bool
18:43:48 <mauke> Any
18:44:29 <Axman6> All is what I'm after I think. but (&&)<$>isAscii<*>isAlpha is good enough
18:46:40 <dylukes> Does anyone here have much knowledge of the haskell-mode and ghc-mod emacs packages?
18:46:50 <dylukes> They seem to be failing now that I update a bit.
18:47:18 <dylukes> Even ghc-save-buffer triggers an error XD
18:52:19 <Sgeo> I can't do data Whatever = 1Whatever, can I?
18:54:28 <rwbarton> 1Whatever?
18:54:34 <ByronJohnson> Sgeo: "data Whatever = 1" makes no sense, no.  You'd usually write data constructors on the right side
18:54:51 <Sgeo> As in, the constructor name starts with a number
18:54:54 <ByronJohnson> Sgeo: You can write "foo = 1", though
18:55:06 <aavogt> no that's not allowed
18:55:18 <ByronJohnson> Sgeo: Nope
18:57:42 <Sgeo> @hoogle (Enum e) => e -> Int
18:57:43 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
18:57:43 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
18:57:43 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
19:04:23 <parcs__> dylukes, use emacs 23 like a normal person
19:04:28 <dylukes> wut?
19:04:31 <dylukes> wry?
19:04:51 <parcs__> because it works on emacs 23
19:05:09 <dylukes> It worked on 24 too :).
19:05:27 <dylukes> http://cl.ly/Cbji
19:05:59 <dylukes> Maybe I'm just forgetting something.
19:06:09 <parcs__> strange.. paste your .emacs
19:06:11 <dylukes> flymake is built in... ghcmod depends on haskell-mode, flymake...
19:06:28 <dylukes> https://gist.github.com/1475158
19:09:27 <parcs__> here's my barebones .emacs that configures haskell-mode, ghc-mod and agda-mode: http://paste.pocoo.org/show/520567/
19:09:39 <parcs__> you seem to be doing nothing that i'm doing
19:24:20 <m3ga> any idea why the code "map Blaze.fromByteString (LBS.toChunks x)" is less lazy that I would like? Blaze is Blaze.ByteString.Builder, LBS is Data.ByteString.Lazy.Char8.
20:38:09 <copumpkin> gwern: I see you admitted to purchasing things with bitcoin in public :P
20:38:19 <gwern> copumpkin: it's a fair cop
20:40:54 <copumpkin> :)
20:41:30 <TNA-MichaelK> gwern: interesting, are they still being traded?
20:41:38 <gwern> TNA-MichaelK: so I hear
20:41:49 <copumpkin> yeah, they are
20:42:24 <TNA-MichaelK> hmm, I thought it was a fairly isolated economy, I didn't realize there was buying power
20:42:40 <copumpkin> the bubble burst but there's still some decent activity
20:43:17 <TNA-MichaelK> Yeah, it's a volatile coin
20:43:31 <copumpkin> I enjoy playing with it
20:43:40 <gwern> TNA-MichaelK: only if you graph it on a linear axis :)
20:43:47 <copumpkin> feels exciting no matter which way it goes
20:44:08 <copumpkin> there's actually quite a few haskellers who do stuff with it
20:46:09 <TNA-MichaelK> <--- #haskell-bleh
20:47:51 <hpaste> djanatyn annotated “counting words” with “integrals” at http://hpaste.org/55253#a55255
20:55:16 <augur> @tell salisbury http://wellnowwhat.net/linguistics/Some%20Notes%20on%20Derivational%20Economy.pdf
20:55:16 <lambdabot> Consider it noted.
20:58:32 <TNA-MichaelK> @tell augur that's neat
20:58:32 <lambdabot> Consider it noted.
20:59:53 <augur> :|
20:59:53 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
20:59:58 <augur> TNA-MichaelK: what re you doing
21:00:05 <MostAwesomeDude> Heh.
21:00:32 <siracusa> @ask TNA-MichaelK What are you doing?
21:00:33 <lambdabot> Consider it noted.
21:02:53 <TNA-MichaelK> I was testing augur's @ tell, as a new feature to me and commenting on the link.
21:03:04 <augur> aint my tell feature
21:03:07 <augur> :P
21:03:15 <augur> but im glad you like the link!
21:03:31 <Axman6> @quote Axman6
21:03:31 <lambdabot> Axman6 says: {-# PRAGMA ThisShitNeedsMoarFast #-}
21:03:34 <Axman6> @quote Axman6
21:03:34 <lambdabot> Axman6 says: getSex :: Person -> Sex
21:03:41 <Axman6> @quote Axman6
21:03:41 <lambdabot> Axman6 says: <vegai> anyone intimate with HDBC.Sqlite3? <Axman6> only if it buys me a drink
21:03:54 <TNA-MichaelK> Understood. And yes, it's quite curious...
21:03:55 <Axman6> hmm, no good
21:04:18 <TNA-MichaelK> Axman6, what is this insanity?
21:04:44 <Axman6> looking for a favourite quote for a survey. I'd prefer to not leave it blank
21:05:08 <Axman6> ooo, what's the one of knuth's, about proving a piece of code correct...
21:05:30 <shachaf> That one is overplayed.
21:05:40 <Axman6> I'm open to suggestions
21:05:54 <shachaf> Favorite quotation?
21:06:02 <shachaf> Quoting you or just in general?
21:06:10 <Axman6> in general
21:07:16 <TNA-MichaelK> garrison keillor has some neat quotes...
21:07:37 <gwern> Axman6: how about my good news quote?
21:07:39 <Axman6> it'd be a bit narcissistic to quote myself i think
21:07:53 <Axman6> @quote gwern.news
21:07:53 <lambdabot> No quotes match. Just what do you think you're doing Dave?
21:08:07 <gwern> Axman6: I don't think you can search on both author and quote text
21:08:12 <gwern> @quote Futamura
21:08:12 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
21:08:15 <BMeph> How about: "In the immortal words of Socrates, 'I drank WHAT?'" ;)
21:08:18 <Axman6> @quote good.news
21:08:18 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
21:08:29 <Axman6> @quote good.news
21:08:30 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
21:08:32 <Axman6> :(
21:08:44 <gwern> Axman6: randomization is predictably like that
21:09:24 <Axman6> what did Socrates drink anyway?
21:09:32 <gwern> hemlock
21:09:41 <gwern> everyone knows that. mixed in wine, no doubt, it being the greeks
21:09:55 * Axman6 didn't know that
21:10:11 * Axman6 has never studied anything to do with Socrates
21:10:21 <TNA-MichaelK> yeah
21:10:28 <shachaf> gwern: You can.
21:10:30 <shachaf> @quote gwern news
21:10:31 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
21:10:45 <shachaf> gwern: That's the reason people always use . to search exclusively quote text.
21:11:22 <Axman6> i'd forgotten searching treated the author differently
21:11:27 <shachaf> Though apparently people also do it because all the cool people do it. :-)
21:15:07 <Axman6> "Real programmers don't comment their code. If it was hard to write, it should be hard to understand." >_>
21:15:13 <cl1> @quote fluffy.kitten
21:15:13 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
21:15:21 <cl1> lol
21:15:37 <TNA-MichaelK> haha
21:15:48 <cl1> undocumented code sucks, especially if its in a library you didn't write
21:15:59 <TNA-MichaelK> agreed
21:16:19 <TNA-MichaelK> write your own libraries... >.<
21:17:34 <Axman6> "
21:17:36 <Axman6> Weeks of programming can save you hours of planning."
21:17:39 <Axman6> bleh
21:17:41 <mbuf> if I have an int array, say a = [1, 2, 3], how can I concat them to a string like '1.2.3' ?
21:17:56 <Axman6> that is not an array, that is a list
21:18:22 <mbuf> Axman6: sorry, it is an Integer list
21:18:24 <Axman6> > intersperse '.' . map show $ [1,2,3]
21:18:25 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:18:25 <lambdabot>         against inferred type...
21:18:42 <Axman6> > intercalate "." . map show $ [1,2,3]
21:18:43 <lambdabot>   "1.2.3"
21:19:30 <mbuf> Axman6: thanks
21:19:53 <TNA-MichaelK> Axman6: neat. also, cool quotes;  mbuf: thanks for asking.
21:21:04 <cl1> what kind of jobs can you get that do functional programming other than stock market and finance stuff?
21:21:17 <Axman6> > fix ((1:).scanl(+) 1)
21:21:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
21:21:25 <Axman6> > fix ((0:).scanl(+) 1)
21:21:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:22:41 * Axman6 -> home
21:24:22 <cl1> Eq is a typeclass right?
21:24:31 <cl1> where Int is a type
21:25:26 <cl1> so how does just deriving Eq make == work?
21:25:47 <cl1> I don't have to implement anything, i don't get it
21:25:57 <cl1> my brain says no
21:27:10 <applicative> isn't it just: things built up from the same constructors in the same way are equal, anything else different
21:27:42 <Veinor> yeah basically
21:27:53 * cl1 thinks on that a bit
21:28:06 <cl1> i'm guessing that works because things are immutable?
21:28:42 <Veinor> what do you mean?
21:29:45 <cl1> i don't know
21:30:27 <cl1> I got woke up because my wife was screamming. A rat was caught in a trap in the garage but was far from dead. I had to kill it and now I can't sleep. :|
21:30:50 <cl1> so i decided to study some more haskell. This may have not been the best choice
21:31:06 <TNA-MichaelK> read some haskell http://learnyouahaskell.com/  XP
21:31:29 <cl1> i'm on this page right now: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
21:31:34 <cl1> typeclasses 102
21:32:06 <TNA-MichaelK> nice!
21:32:57 <cl1> and when I'm done with that i'm going to write an image manipulation program to fix my desktop background ...
21:33:05 <cl1> after that i'm gonna read http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
21:33:19 <mzero> cl1: deriving Eq just does the "obvious" definition of equality, which is probably what you'd do if you wrote it yourself:  two values of your type are equal if the constructors are the same, and all the data values are equal --- there's really no magic to it
21:33:41 <TNA-MichaelK> cl1: Bookmarked, thanks!
22:01:17 <copumpkin> any enumerator experts know how to catch errors in an enumerator?
22:01:29 <copumpkin> I know it's just basically an iteratee in disguise, but they have this catchError thing
22:01:58 <copumpkin> I really wish it were a newtype and had a meaningful monad instance
22:04:16 * applicative thought copumpkin was a fellow iteratee-enumerator conscientious objector. 
22:04:56 <copumpkin> I do appreciate their existence, but I don't like their implementation(s) :) and I need them, here
22:05:30 <yitz> copumpkin: it's a fundamental problem. that's why snoyberg is proposing to move yesod from enumerators to conduits.
22:05:41 <applicative> conduits?
22:06:13 <applicative> oh i see https://github.com/snoyberg/conduit
22:07:12 <yitz> copumpkin: well one of the reasons
22:07:31 <copumpkin> we have several people in ##iteratees talking about approaches to improving them too, but that looks interesting
22:07:38 <augur> copumpkin!
22:07:43 <copumpkin> hey
22:07:54 <applicative> ##iteratees ? my god.
22:07:54 <augur> hows it goin ;o
22:08:24 * applicative joins ##fingertrees and ##zippers
22:08:26 <copumpkin> augur: http://snapplr.com/mbey
22:08:32 <augur> copumpkin: can i get your opinion of the paper?
22:08:37 <copumpkin> applicative: those are less controversial
22:08:40 <augur> :X
22:08:41 <augur> hahaha
22:08:51 <augur> what sort of project!
22:09:02 <copumpkin> the project that is using these damn enumerators :)
22:09:26 <copumpkin> archiving and analyzing financial data for fun and loss
22:10:05 <augur> horrible
22:11:05 <copumpkin> totally
22:11:32 <yitz> applicative: as a fellow conscientious objector and a co-worker of snoyberg, i can claim a small amount of credit for constantly prodding him to look for an alternative
22:12:04 <copumpkin> so, going back to my enumerator question, all I want is an enumerator that keeps retrying after an error
22:12:35 <copumpkin> it's streaming from a handle, and I want it to reconnect and stream again if the socket dies
22:16:14 <etpace> Where can I learn how to use some simple Foreign. libraries? I have a few haskell functions (which expects types such as Ptr CString) etc and Iw ould like to know how to create values of these types to use them
22:16:38 <etpace> (Cant really find a: a -> IO (Ptr a) or something in Foreign.Ptr)
22:17:03 <copumpkin> that operation doesn't really make sense
22:17:15 <copumpkin> you typically get pointers from foreign calls, or from a call to an allocation function
22:17:26 <copumpkin> (haskell values are allowed to move around on the heap, and often do)
22:17:58 <etpace> I guess for this, I'd like to find the Ptr of my haskell value?
22:18:01 <copumpkin> Foreign.Marshal.Alloc will give you one
22:18:09 <copumpkin> etpace: my point is that it isn't a meaningful or safe operation
22:18:35 <copumpkin> because your haskell value could move between your call to that function and the moment you use the Ptr
22:18:52 <etpace> aha
22:19:00 <copumpkin> what are you trying to do?
22:20:53 <etpace> I have a LLVM bitcode file I'd like to load using the FFI calls in the haskell LLVM library (allowing me to JIT it and call it from haskell)
22:21:11 <etpace> so I'm trying to figure out how to get the values to call "parseBitcode" from http://hackage.haskell.org/packages/archive/llvm/0.9.1.2/doc/html/LLVM-FFI-BitReader.html
22:21:31 <mauke> @hoogle alloca
22:21:31 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
22:21:32 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
22:21:32 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
22:21:58 <etpace> only problem is, I cant figure out how to create a MemoryBufferRef, can only find functions that creat it
22:22:02 <copumpkin> if you want to pass something to a foreign library, call an allocation function (like alloca that mauke just showed you) and then poke values into it (look at the Storable typeclass), then you'll have a pointer
22:22:37 <copumpkin> createMemoryBufferWithContentsOfFile :: CString -> Ptr MemoryBufferRef -> Ptr CString -> IO CInt
22:22:43 <copumpkin> that looks promising?
22:22:58 <copumpkin> not sure why it isn't a Storable instance though
22:23:10 <copumpkin> you're going to have to find out how much memory to allocate for it
22:23:24 <copumpkin> oh wait
22:23:33 <copumpkin> it's a Ptr to a MemoryBufferRef, which is itself a Ptr
22:23:40 <copumpkin> so you don't even need to allocate it yourself
22:23:44 <etpace> yeah indeed
22:23:47 <etpace> data MemoryBuffer Ref (deriving Typeable)
22:23:53 <copumpkin> so all is well
22:24:06 <etpace> How do I get my initial MemoryBufferREf to pass in?
22:24:09 <copumpkin> it's basically int gimmeaMemoryBuffer(memorybuffer **buf)
22:24:39 <copumpkin> etpace: use that alloca function mauke linked to to allocate the space for one pointer, and then peek
22:24:45 <copumpkin> unless there's a convenience function for that
22:25:08 <etpace> does the deriving Typeable allow me to change the type accordingly?
22:25:19 <copumpkin> nope, you shouldn't need that
22:25:48 <ddarius> @hoogle StablePtr
22:25:49 <lambdabot> Foreign.StablePtr module Foreign.StablePtr
22:25:49 <lambdabot> Foreign.StablePtr data StablePtr a
22:25:49 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
22:26:12 <etpace> so uh, what would I give as its second argument?
22:26:19 <etpace> just the pointer, and itll type fine?
22:26:28 <mauke> what is "it" here?
22:26:41 <etpace> createMemoryBufferWithContentsOfFile
22:26:48 <copumpkin> etpace: alloca will give you a pointer to anything you ask it for
22:26:56 <etpace> oh of course
22:26:58 <etpace> doh, thanks
22:32:21 <cl1> I thought I was getting away from pointers with haskell :|
22:32:33 <copumpkin> you mostly are, unless you're interfacing with foreign libraries
22:33:03 <copumpkin> if the foreign library uses pointers, there's not much you can do to avoid using them, but you generally hope that whoever binds you to the library will then insulate you from the ugly details
22:35:04 <cl1> i see what you mean
22:35:24 <cl1> am i correct in thinking that a class in haskell is like an interface in c#?
22:35:46 <mauke> sometimes it is
22:36:03 <cl1> sometimes?
22:36:17 <cl1> so maybe more like a package definition in ada?
22:38:05 <mauke> http://channel9.msdn.com/posts/MDCC-TechTalk-Classes-Jim-but-not-as-we-know-them
22:38:23 <johnfn> is there a way to grab all "local variables and functions" (to be more precise: anything bound with let) in ghci?
22:39:26 <copumpkin> :show bindings?
22:39:43 <johnfn> oh awesome, thank you
22:39:47 <cl1> mauke: thanks for the link
22:39:51 <johnfn> what does the " = _" at the end mean?
22:40:00 <copumpkin> johnfn: it's not been forced yet
22:40:07 <copumpkin> it's pretty detailed
22:40:22 <copumpkin> if you construct an infinite list and force only the first couple of elements of it, it'll display 1 : 2 : _
22:40:23 <johnfn> copumpkin: that's awesome, thanks
22:40:46 <copumpkin> it might even display _ : _ : _
22:41:00 <copumpkin> if you force the spine of the beginning but not the elements :)
22:43:23 <shachaf> copumpkin: GHCi can do that?!
22:43:25 <shachaf> ghci++
22:43:50 <copumpkin> totally
22:50:28 <mzero> woot! I've just declared HP 2011.4.0.0 for Mac OS X   --- DONE!!!
22:50:47 <mzero> and I've blown away my own Haskell installs and installed it afresh mysefl
22:51:05 <cl1> mzero: congrats
22:51:31 <mzero> it'll be a few more days before the web site is updated
22:51:51 <mzero> but if anyone is eager (oooo get that classic GHC 7.0.4!!) I can give 'em a link
22:53:01 <cl1> i run windoze, sorry
22:53:47 <mzero> there's a "release candidate" for windows out: http://projects.haskell.org/pipermail/haskell-platform/2011-December/001710.html
22:54:14 <cl1> can i figure out my version in ghci?
22:54:36 <mzero> without quitting?
22:55:18 <cl1> i dunno, i'm a total newb at haskell
22:55:22 <cl1> i'm about 2 days in now
22:55:45 <mzero> well, in a command line, just type   "ghc --version"
22:56:06 <cl1> 7.0.3
22:56:23 <mzero> if you want to be goofy, you could, from within ghci:      :m +System.Cmd      then    system "ghc --version"
22:56:37 <mzero> oh, welcome to Haskell, cl1 !
22:56:49 <cl1> thanks :)
22:57:43 <cl1> i'll have to remember that trick with System.Cmd
22:58:48 <cl1> would come in handy for: system "git status" and such
22:59:15 <MostAwesomeDude> Isn't there a cleaner subprocessing handler somewhere? system() is not a good thing to use directly.
22:59:59 <cl1> how do i get out of it?
23:00:30 <zxbx|DZ^> black cats games is having their once a year torrent sign up special
23:00:31 <zxbx|DZ^> Get every new game, tv-rip, movie, and more FOR FREE!  simply read the RULES!
23:00:32 <zxbx|DZ^> http://www.blackcats-games.net/signup.php and create an account and use a good torrent client like uTorrent for FREE GAMEZ!
23:01:04 <mzero> well, if you want to use stuff from within code, sure - System.Process has nicer things
23:01:17 <zxbx|DZ^> q  v  O  d  ~  f  R    /  G  )  V  C  o  :  ;  g  7  e    I  e  ^  Y  y  ,  [  W  m  h  V  h  o    e  f  <  :  *  x  i  Z  O  a  "  ,  T  =  U  S  m
23:01:23 <zxbx|DZ^> m  C  !  X  F  e  J  _  ?  R  ^  #  I  t    &  +  p  >  E  v  4  |  z  ]  {  x  J  Z  u  6  g  6  F  a  c  Q  %  U  .  `  2  @  L  d  <  =  .  ;
23:01:24 <zxbx|DZ^> *  x  P  `  f  $  h
23:01:25 <augur> byorgey!
23:01:25 <zxbx|DZ^> ;  }  G  $  .
23:01:27 <zxbx|DZ^> M  O  g  e    Z  G  C  m  3  t  r  .  r  R    &  w  *  r  ~  Z  k  ~  ~  O  l  8  E  e  f  M  ]  H  X  i  a  E  !  =  ~  l  v  i       /  >  w  b  +  +
23:01:28 <zxbx|DZ^> 6  q  T  B
23:01:31 <zxbx|DZ^> A  <  ^  y  )    |  H  s  ]  &  d  r  h  R  h  J  N  T  &  o  d  T  R  "  i  )  }  U  h  F  ;  w  y  T  @  O  z  n  ~  x  ~  )  _  -  O  L  0    E  j  +
23:01:31 <mzero> get out of it? what do you mean? it runs some command - synchronously
23:01:31 <augur> zxbx|DZ^: diaf
23:01:36 <mzero> so exit what you're running
23:03:05 <cl1> oh, it changed my prompt from "*Main>" to "*Main System.Cmd>" i thought i was in some sort of sub shell thingy
23:03:12 <mzero> ah - no
23:03:25 <mzero> ghci changes the prompt to include what modules are in scope
23:03:39 <mzero> it is sort of icky behavior if you ask me
23:03:50 <mzero> and many set the prompt to be something nice and fixed
23:04:34 <augur> anyone know about species like, hardcore like?
23:04:46 <cl1> mzero: many thanks
23:04:54 <cl1> my prompt is now ~{{{{{:>
23:06:24 <mzero> if you put that command in your .ghci file and it will set each time you run
23:06:39 <mzero> info on where that file on Windows is can be found here: http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/users_guide/ghci-dot-files.html
23:10:23 <ajnsit> I need help installing scion-browser on my (Linux) system.. I can't install terminfo (which scion-browser depends on) without setting up libncursesw.so -> /lib/libncursesw.so.5. However once I do that, during scion browser installation I get linking errors such as - undefined reference to `cur_term'
23:12:38 <ajnsit> any help?
23:12:50 <cl1> stupid windows won't let me create a .ghci file
23:12:54 * cl1 opens emacs
23:13:13 <mzero> ajnsit: I don't even know what the scion-browser is!
23:13:43 <ajnsit> mzero, it's something used by Eclipse for haskell code completion
23:13:52 <mzero> ah....
23:14:30 <cl1> mzero: thanks again, worked like a charm
23:14:34 <mzero> no clue then -- I'm sort of surprised term info wasn't already installed on your system
23:15:06 <ajnsit> mzero, is it a part of the haskell platform?
23:15:37 <mzero> you mean a haskell package named terminfo (feels dumb) -- not it is not part of HP
23:16:09 <ajnsit> mzero, yes I'm doing cabal install terminfo
23:16:52 <ajnsit> I was heading to the haskell platform page in hopes of getting terminfo already configured to play nice with my system :(
23:17:32 <hpaste> Charles pasted “chain” at http://hpaste.org/55260
23:17:49 <cl1> oh, who, the internet is so cool
23:18:28 <cl1> when I run maxChain 30000 or maxChain2 30000 its really slow, would there be a more efficent way to implement this?
23:18:45 <cl1> oh, btw, i'm Charles that just pasted that
23:18:58 <cl1> i did not know it would put a message in here
23:19:12 <mzero> well - yeah
23:19:29 <mzero> first off, you're computing    map chain [1..n]   twice
23:19:40 <mzero> just use a where clause
23:19:51 <mzero> you want to find the chain with the longest length?
23:19:57 <cl1> yes
23:20:12 <mzero> 'couse maxChain2 effectively does that
23:20:21 <mauke> is this an euler problem?
23:20:40 <mzero> think so!
23:20:49 <cl1> no, the chain method was in the learnyouahaskell .. i just wanted to see the longest chains myself so i wrote that
23:20:49 <mauke> which one?
23:20:54 <mauke> ah
23:21:20 <cl1> its just REALLY slow for all the chains from 1..30000
23:21:21 <mzero> other small bits - no need to test    odd n    -- just otherwise =
23:21:36 <mzero> well, you are also computing many sub chains again and a gain
23:21:42 <mzero> perhaps what you want is memoization
23:22:12 <cl1> maybe so, i vaugely remember what that is from an f# tutorial
23:22:27 <cl1> i don't think i have the skills to write one in haskell yet
23:22:40 <cl1> i'll add a comment to the code and save that for later
23:31:09 <cl1> i'm thinking typeclasses are like ada generic packages
23:37:06 <mauke> cool
23:37:18 <mauke> 0.1s for print (maxChain 30000) compiled with -O2
23:38:36 <hpaste> mauke pasted “maxChain - brute force memoization” at http://hpaste.org/55261
23:41:51 <mauke> oh, I'm stupid
23:43:02 <mauke> I forget to test without memoization
23:43:39 <mauke> without memoization: 0.33s
23:44:02 <mauke> memoization (array size 0): 0.48s
23:44:21 <mauke> memoization (array size 100): 0.25s
23:44:38 <mauke> memoization (array size 1000): 0.15s
23:44:54 <mauke> memoization (array size 10000): 0.05s
23:45:13 <mauke> memoization (array size 100000): 0.10s
23:45:35 <cl1> wow, much faster than my version
23:46:00 <mauke> ok, I'm going to switch to array size = n / 3
23:46:15 <mauke> that seems to work reasonably well
23:48:25 <mauke> cl1: that's the compiled version. it takes about 2.5 seconds in ghci
23:48:53 <cl1> still much faster than my version, i dunno how slow mine is, maybe 30 secs
23:50:09 <cl1> :info Ix
23:50:31 <cl1> i thought that bot thingy would run ghci stuff
23:50:35 <hpaste> mauke pasted “maxChain - brute force memoization v2” at http://hpaste.org/55262
23:51:25 <mauke> no, lambdabot doesn't use ghci
23:51:53 <cl1> oh, okay
23:52:14 <mauke> do you see how my code works?
23:53:30 <cl1> no, lol
23:54:06 <mauke> ok, what's the first line that's giving you trouble?
23:54:50 <cl1> extend x (n, xs) = ((,) $! succ n) (x : xs)
23:54:58 <mauke> oh yeah
23:55:15 <mauke> extend x (n, xs) = (succ n, x : xs)  -- better?
23:55:38 <cl1> yes
23:55:53 <mauke> the reason I've got $! in there is that I wanted to force succ n
23:56:42 <mauke> that is, the first element in all those tuples is either 1 (first branch of prim) or succ ...
23:57:03 <mauke> and thanks to lazy evaluation I could end up with a long chain of unevaluated succ (succ (succ (succ ...)))
23:57:58 <mauke> f $! x makes sure that whenever f $! x is evaluated, then so is x
23:58:07 <mauke> er, and otherwise it behaves just like a normal function call, f x
23:58:23 <cl1> so it removes the lazyness
23:58:28 <mauke> yeah
23:58:40 <mauke> without $! my code is (,) (succ n) (x : xs)
23:58:50 <mauke> i.e. a call to (,), constructing a pair
23:59:23 <cl1> okay, i get that
23:59:56 <cl1> so ((,) $! succ n) forces succ to be evaluated before being applied to (,)
