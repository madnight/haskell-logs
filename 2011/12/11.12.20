00:01:32 <penelope> (I never realized \ was so special!)
00:02:07 <sipa> \ is not an operator
00:03:41 <penelope> but it could be an anonymous function constructor?
00:04:28 <sipa> it's part of the syntax rule (\[patterns] -> expr) = expr
00:05:55 <penelope> I had just naively assumed it was turtles all the way down.
00:11:17 <augur> penelope: lambda is the turtle!
00:12:06 <shachaf> penelope: \ is the elephant of the lambda calculus.
00:16:19 <frerich> I'm so looking forward to the christmas vacation time. Finally a chance to spend some time on a Haskell project. :-)
00:16:49 * frerich has an existing Python project which he wants to reimlpement in Haskell, so that I'm not so busy with the problem domain but can concentrate on the Haskell-specific considerations.
00:18:00 <Sgeo> Suppose I have a function that takes pure arguments and returns an IO whatever
00:18:03 <Sgeo> f
00:18:12 <Sgeo> And I want to pass it the results of impure arguments
00:18:24 <Sgeo> This should work, but is it idiomatic, or are there better idioms:
00:18:24 <penelope> frerich, I'm doing the same thing: my company uses python for services, but I'm using my vacy to build a skeleton is haskell.
00:18:40 <Sgeo> join$ f <$> impure1 <*> impure2 <*> impure3
00:18:58 <Sgeo> Because if f were pure, than that without the join$ would be idiomatic, as far as I know
00:19:33 <shachaf> Sgeo: What?
00:19:35 <penelope> what about a lift?
00:19:50 <shachaf> Sgeo: Do you have to say "impure" like that?
00:19:51 <geheimdienst> Sgeo: what's the type of f?
00:19:51 <lambdabot> geheimdienst: You have 5 new messages. '/msg lambdabot @messages' to read them.
00:20:26 <Sgeo> geheimdienst, f :: a -> b -> c -> IO d -- Ok, technically speaking, probably no such function, but that illustrates what I'm asking about I think
00:21:51 * hackagebot blaze-html 0.4.3.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.4.3.0 (JasperVanDerJeugt)
00:22:11 <shachaf> Sgeo: You want foo :: (a -> b -> c -> IO d) -> IO a -> IO b -> IO c -> IO d?
00:22:48 <shachaf> If so: No, I don't think that exists in the standard library. You might call it "bind3" or something.
00:22:56 <Sgeo> shachaf, a function like that would work, but I think what I posted is more natural somehow, or are there better idioms?
00:23:19 * shachaf is no longer sure what Sgeo's question is.
00:23:34 <Sgeo> shachaf, the most idiomatic way to get IO d
00:23:46 <penelope> do notation never hurt anyone...
00:23:46 <shachaf> Depends on the context.
00:23:46 <Sgeo> Does join$ f <$> impure1 <*> impure2 <*> impure3 work? Is it idiomatic?
00:23:58 <shachaf> No, it's not idiomatic; there's no space before the "$".
00:24:06 <shachaf> Also, it's not idiomatic to call IO actions "impure".
00:24:22 <Sgeo> Fine, join $ f <$> impure1 <*> impure2 <*> impure 3
00:24:36 <Sgeo> And I'm assuming everyone knows what I meant by "impure"
00:24:43 <Sgeo> I was too lazy to write out the truth
00:30:32 <frerich> I'm considering to talk to a few colleagues who showed interest in Haskell about learning the language together (which is probably more fun). However, I'm afraid that we might eb doing stupid stuff (since none of us really knows the language yet). Does anybody have experience with an approach like this? Like, maybe we should be doing bi-weekly presentations or use some sort of PDF with exercises to work through instead of just rushing ahead?
00:30:48 <frerich> Basically like a Haskell users group excep that we're all still beginners, and colleagues. :)
00:31:51 * hackagebot tls 0.8.4 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.8.4 (VincentHanquez)
00:36:01 <geheimdienst> frerich: so you're looking for a textbook with exercises? iirc rwh has some ...
00:36:04 <geheimdienst> also there's http://www.haskell.org/haskellwiki/99_Haskell_exercises
00:36:08 <penelope> frerich: Perhaps a moderatly modern book as a guide?
00:37:19 <Sgeo> Besides the spacing thing, and the sloppy use of the term "impure", is what I did idiomatic?
00:39:45 <geheimdienst> Sgeo: looks good to me :) but i'm not a style authority
00:40:49 <ski> Sgeo : well, if you define `foo <*>> bar = join (foo <*> bar)', you could write it as `f <$> impure1 <*> impure2 <*>> impure3', i think
00:41:51 * hackagebot tls-extra 0.4.2 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.2 (VincentHanquez)
00:46:31 <nus> frerich, perhaps you could try following the tracks here: https://en.wikibooks.org/wiki/Haskell
00:46:51 * hackagebot cabal-sort 0.0.3 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.3 (HenningThielemann)
00:52:31 <ski> @type let foo <*>> bar = join (foo `ap` bar) in (<*>>)
00:52:32 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> m a -> m a1
00:52:39 <sp3ctum> geheimdienst, awesome link. that'll be useful for me too
00:53:22 <geheimdienst> sp3ctum: you're welcome :) i haven't worked through it myself, i just saw it's available
00:54:30 <sp3ctum> reminds me of http://www.quickmeme.com/meme/CN/
01:18:34 <frerich> geheimdienst: The 99 problems page looks really useful, thanks for pointing that out!
01:18:45 <frerich> It might be fun to compare different solutions.
01:21:40 <Blkt> good morning everyonbe
01:24:03 <jessopher> good morning
01:28:33 <ion> @hoogle (Functor t, F.Foldable t, MonadPlus m) => t a -> m a
01:28:33 <lambdabot> Parse error:
01:28:33 <lambdabot>   (Functor t, F.Foldable t, MonadPlus m) => t a -> m a
01:28:33 <lambdabot>                ^
01:28:39 <ion> @hoogle (Functor t, Foldable t, MonadPlus m) => t a -> m a
01:28:42 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
01:28:42 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
01:28:42 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
01:29:11 <ion> @hoogle MonadPlus m => [a] -> m a
01:29:11 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
01:29:12 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
01:29:12 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
01:29:21 <ion> meh
01:30:19 <quicksilver> there could be a newtype to make Monoids out of mplus
01:30:21 <penelope> in the future, hoogle will derive your function from your type request.
01:30:27 <quicksilver> but there isn't
01:31:11 <quicksilver> so you'll have to make do with foldr mplus mempty . fmap return
01:31:18 <quicksilver> :t foldr mplus mempty . fmap return
01:31:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Monoid (m a)) => [a] -> m a
01:31:29 <quicksilver> :t F.foldr mplus mempty . fmap return
01:31:29 <lambdabot> Couldn't find qualified module.
01:31:34 <quicksilver> :t Foldable.foldr mplus mempty . fmap return
01:31:35 <lambdabot> Couldn't find qualified module.
01:31:39 <quicksilver> !
01:31:43 <ion> I was just wondering if that existed in a module.
01:31:54 <quicksilver> lambdabot: I hate you. How do I find out what modules you have imported as what?
01:31:59 <quicksilver> lambdabot: you're useless.
01:32:01 <ion> (I got rid of the fmap by using F.foldr (mplus . return) mzero, btw.)
01:32:15 <ion> @t Data.Foldable.foldr (mplus . return) mzero
01:32:15 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:32:19 <ion> @type Data.Foldable.foldr (mplus . return) mzero
01:32:19 <lambdabot> forall (m :: * -> *) a (t :: * -> *). (MonadPlus m, Data.Foldable.Foldable t) => t a -> m a
01:35:34 <hpaste> sanjoyd pasted “Example Code” at http://hpaste.org/55489
01:35:42 <hpaste> sanjoyd pasted “Link Error” at http://hpaste.org/55490
01:36:02 <quicksilver> sanjoyd: try with ghc --make
01:36:16 <sanjoyd> quicksilver: your name is justified. :)
01:36:23 <sanjoyd> s/name/nick/
01:36:41 <sanjoyd> Works.  Thanks!\
01:37:49 <quicksilver> always use ghc --make
01:38:01 <quicksilver> although I think it is automatic in GHC version somethiing.newer.than.i.have
01:41:34 <_Mikey> --make saves soo much time
01:42:12 <penelope> when is 7.2 coming to debian?
01:46:36 <quicksilver> penelope: http://packages.debian.org/experimental/ghc
01:47:33 <m3ga> any suggestions for a way to set up a unidirectional pipe between threads?
01:47:41 * jessopher forgot about experimental sources
01:47:57 <quicksilver> m3ga: Chan?
01:48:29 <m3ga> @hoogle Chan
01:48:30 <lambdabot> Control.Concurrent.Chan data Chan a
01:48:30 <lambdabot> Control.Concurrent.Chan module Control.Concurrent.Chan
01:48:30 <lambdabot> package chan-split
01:48:42 <m3ga> oh, ok. thanks quicksilver
01:49:14 <quicksilver> your basic tools are MVar for safely shared variables and Chan for channels
01:49:28 <quicksilver> STM has clever versions if you need 'transactional' semantics.
01:49:45 <m3ga> nope, plain Chan should do it.
01:53:27 <exeter> cbiLine cs = blank >> string cs >> count (120 - length cs) >> eol >> return "wee" -- this line gives me a long long error
01:53:58 <aib> I have a function which generates a Maybe list (Just [1]). What's the Haskell way of calling it multiple times and concatenating the results? I can do, do { x <- call1; y <- call2; ... x ++ y ++ z; } but I'd rather not have to come up with a new temporary variable name for every call
01:54:12 <hpaste> exeter pasted “parsec” at http://hpaste.org/55491
01:54:41 <shachaf> @ty sequence
01:54:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:54:47 <exeter> I'm not sure. Can a  parser take parameters?
01:55:08 <exeter> (or should I add parentheses)?
01:55:52 <quicksilver> exeter: a parser can take parameters, that's fine.
01:56:17 <quicksilver> exeter: is the error something secret? Or would you be prepared to share it with us. You might get more help
01:57:18 <shachaf> quicksilver: Hey, man, that's a bit personal, don't you think?
01:57:27 <quicksilver> :)
01:57:36 <quicksilver> it was slightly sarcastic, for which I apologise.
01:57:52 <quicksilver> exeter: if that 'count' is the Parsec count I think your problem is that count takes two parameters.
01:58:26 <shachaf> I think it's reasonable to expect people to ask questions in such a way that you're able to help them. :-)
01:58:27 <quicksilver> exeter: I think maybe you meant "count (120 - length cs) anyChar"
01:59:20 <aib> shachaf: excellent, thanks
01:59:34 <exeter> quicksilver: I feel such an idiot. Thanks :)
01:59:40 <quicksilver> exeter: :)
02:00:04 <jessopher> if I had a context for types in a type checker, that maps from names to kinds, and allows overloading by kind, would it present any huge issues other than ambiguity? and can anyone think of a good application for 'type overloading'?
02:00:30 <wereHamster> where can I see which functions the Read typeclass expects?
02:01:19 <m3ga> wereHamster: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Read
02:01:50 <m3ga> wereHamster: hoogle is your friend : http://www.haskell.org/hoogle/?hoogle=Read
02:02:06 <wereHamster> is he? I've never met him
02:04:38 <jessopher> ie type X(1) : * -> *; type X(2): * -> * -> *;  and which type is referenced is infered by How it is applied in a type signature. foo :  X a b -> Int; for instance would 'assume' that X(1) is being refered to rather than X(2). (this is not a polymorphic type system)
02:12:02 <Saizan> jessopher: so no higher-kinded polymorphism?
02:12:24 <aib> how does this work? (sequenceA $ replicate 3 [1,2,3]) --list of 3-permutations of 1,2,3
02:13:09 <shachaf> > sequence (replicate 3 [1,2,3])
02:13:10 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
02:13:34 <aib> oh, it's in the definition of seqA that it makes permutations
02:13:56 <Sgeo_> :t sequenceA
02:13:57 <lambdabot> Not in scope: `sequenceA'
02:14:21 <aib> sequenceA :: (Control.Applicative.Applicative f, Traversable t) => t (f a) -> f (t a)
02:14:39 <Botje> aib: there's also replicateM
02:14:53 <Botje> oh wait, nvm
02:15:35 <jessopher> Saizan: not that I am aware, but i am not 100% on how to qualify something as higher kinded. the kind data type for this type system in haskell is data KExpr = K | KExpr :=>: KExpr
02:16:15 <jessopher> so it allows for (K => K) => K etc
02:16:32 <Saizan> and for type variables with those kinds?
02:17:50 <Saizan> i.e. one complication would me if you have types like forall t. t X -> ...; then you'd want to infer the type of t but you'd have to pick a kind for X first
02:18:21 <Saizan> *infer the kind of t
02:18:22 <jessopher> Right now just declared types, and annotation of declared types in signatures (and binding local declared types)
02:18:57 <aib> @hoogle group
02:18:57 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
02:18:57 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
02:18:57 <lambdabot> System.Posix.Types type GroupID = CGid
02:20:12 <aib> @hoogle sort
02:20:12 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
02:20:13 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
02:20:13 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
02:20:24 <Saizan> jessopher: ok, though i guess that's orthogonal, define T : (*->*) -> *; T : * -> *; X : * -> *; X : *; then try to resolve the overloading in T X :)
02:20:56 <Saizan> is that what you meant by ambiguity?
02:21:09 <jessopher> Saizan: yes :)
02:23:02 <jessopher> annotation in type signatures can help weed out the ambiguity, i cant think of a use for it yet, so i imagine it wouldnt be something that happens a lot
02:27:28 <Sgeo_> What negative consequences are there to pervasive currying?
02:27:54 <_Mikey> not sure,
02:28:00 <shachaf> Currying isn't very common in Haskell programs.
02:28:01 <_Mikey> maybe confusing code?
02:28:52 <Sgeo_> shachaf, uhh, all Haskell functions are curried by default, unless I'm misunderstanding something
02:29:02 <penelope> partial application would suffer
02:29:29 <shachaf> Sgeo_: Currying is the transformation of a function from (x,y) -> z to x -> (y -> z)
02:29:35 <Saizan> ?type curry
02:29:36 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:29:42 <shachaf> I.e., what curry does.
02:29:58 <Saizan> yes, but you can say that haskell functions are defined in the curried form already
02:30:15 <aib> is there a shorter name for not . any ?
02:30:40 <penelope> nany = not . any
02:30:47 <shachaf> @ty not . any -- nope
02:30:48 <lambdabot>     Couldn't match expected type `Bool'
02:30:48 <lambdabot>            against inferred type `[a] -> Bool'
02:30:48 <lambdabot>     Probable cause: `any' is applied to too few arguments
02:31:11 <Saizan> ?type all . (not .)
02:31:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:31:17 <Sgeo_> I mean, due to the fact that Haskell functions are curried, are there inconveniences, say, manipulating "multi-argument" functions, like taking a function of multiple arguments and applying a function to each argument before giving it to the function?
02:31:35 <shachaf> Anyway, yes, all . not ~ not . any
02:33:20 <penelope> Not like ruby or python: in general, you can't manipulate an arbitrary argument list
02:33:32 <penelope> It has to be well-typed.
02:33:41 <aib> erm hold up, it's not (not . any). I need to apply not to a partially applied any
02:33:50 <Saizan> even python needs built-in support, it doesn't come out easily from the fact they are uncurried
02:34:28 <shachaf> Sgeo_: What would be simpler if you used an "uncurried form" of functions in Haskell?
02:34:33 <aib> nany = (\l -> not . (any l))
02:35:07 <penelope> nany = any . not
02:35:09 <Sgeo_> shachaf, I guess not much, considering the lack of generalized ways of manipulating tuples anyway
02:35:35 <penelope> lack = plus types
02:35:39 <shachaf> penelope: any .: not?
02:35:45 <shachaf> Er, no.
02:35:49 <Saizan> aib: anyhow, no, there isn't a shorthand for that
02:35:55 <jessopher> Sgeo_: which isnt a big deal really, you can abstract n-ary functions as functions that take lists
02:36:17 <aib> Saizan: haha, thanks; it's all good, though. this is good practice
02:36:34 <penelope> With a fair amount of type glue....
02:36:38 <aib> nany = (\l -> not . (any l)) -- seems to work. but I wonder if I could shorten it.
02:36:56 <shachaf> aib: Are you aware of the existence of @pl?
02:37:00 <penelope> nany = not $ any
02:37:10 <shachaf> /msg lambdabot @pl nany = (\l -> not . (any l))
02:37:19 <aib> shachaf: no. is there an introduction to lambdabot?
02:37:22 <shachaf> penelope: That's not how function application works.
02:37:30 <_Mikey> hey guys
02:37:31 <shachaf> aib: There is only bitter experience.
02:37:32 <penelope> gah
02:37:36 <ion> not $ any = not any
02:37:39 <_Mikey> I have an infinite type error
02:37:49 <_Mikey> I'm trying to get the last element of a list
02:37:56 <aib> shachaf: so far I've learned about @hoogle, @ty (not sure what it does) and @pl
02:37:58 <shachaf> _Mikey: Is the error infinite, or just the type?
02:38:09 <shachaf> aib: @ty is @type; it tells you the type of an expression.
02:38:11 <_Mikey> the type I believe
02:38:18 <aib> like :t ?
02:38:28 <shachaf> Yes, except lambdabot isn't ghci and :t doesn't work in /msg.
02:38:31 <shachaf> /msg lambdabot @help pl
02:38:35 <_Mikey> expecting type [a]
02:38:38 <_Mikey> getting type a
02:38:57 <aib> wow: http://code.haskell.org/lambdabot/COMMANDS
02:39:07 <Sgeo_> Do there exist lambda expressions that do not close on outside values that cannot be expressed as pointfree given a fixed set of combinators for use for pointfree form?
02:39:56 <penelope> intutively, yes
02:40:00 <shachaf> Sgeo_: No, unless you include e.g. things that require pattern-matching.
02:40:29 <penelope> we can't draw an arbitrary graph in 2d form without lines crossing
02:40:59 <shachaf> penelope: Why is that related?
02:41:22 <penelope> lines are arguments
02:41:30 <penelope> and return values
02:41:52 <_Mikey> shachaf, I fixeded it!
02:42:01 <Sgeo_> >fix brokenThing
02:42:07 <Sgeo_> > fix brokenThing
02:42:08 <lambdabot>   Not in scope: `brokenThing'
02:42:11 <Sgeo_> aww
02:42:19 <shachaf> penelope: Any function in the untyped lambda calculus can be expressed using only two combinators.
02:42:19 <_Mikey> last returns a value not a list containing the one value which is what I my code was expecting
02:42:29 <shachaf> penelope: S x y z = x z (y z); K x y = x
02:42:31 * jessopher likes to keep all brokenThing s out of scope
02:42:41 <shachaf> I guess that's addressed more to Sgeo_.
02:42:46 <_Mikey> hacked around it in the most horrific way by throwing [ ]'s around the expression XD
02:43:58 <shachaf> http://en.wikipedia.org/wiki/Combinatory_logic
02:45:01 <penelope> shachaf: yes. you are right. I guess I was thinking about doing it without new binds.
02:45:04 <dibblego> what is a good use-case for demonstrating instance Monoid b => Monoid (a -> b)?
02:45:23 <shachaf> dibblego: Cale's Ord thing?
02:45:30 <dibblego> oh wossit?
02:45:54 <shachaf> > sortBy (comparing length ++ compare) $ words "these are some words to sort first by length and then alphabetically"
02:45:55 <lambdabot>   ["by","to","and","are","some","sort","then","first","these","words","length...
02:46:11 <shachaf> Uses both Ordering and (a -> b)
02:46:44 <dibblego> oh yeah nice thanks
02:47:38 <frerich> Hm, why dose 'comparing length ++ compare' work? 'comparing length' yields an Ordering, adn so does 'compare' - you can use ++ on those?
02:47:45 <frerich> s/why does/what does/
02:47:54 <dibblego> comparing length yields a [t] -> [t] -> Ordering
02:48:03 <shachaf> frerich: lamdabbot's (++) is defined as mappend.
02:48:06 <frerich> Oooh
02:48:09 <dibblego> compare yields a t -> t -> Ordering
02:49:41 <penelope> When will Prelude ++ be mappend?
02:49:52 <shachaf> Not any time in the near future.
02:49:54 <aib> what's going on here? http://hpaste.org/55492
02:50:43 <shachaf> aib: Defaulting?
02:51:01 <exeter> mhhh, another simple doubt. I have something which looks like "cbiLine "61"     >>= \lin ->" . now I desire that "lin" to "reenter" the parsing flow. (i.e. I want to parse that lin using parsec). How to do it?
02:51:03 <quicksilver> dreaded monomorphism restriction
02:51:16 <quicksilver> combined with extended defaulting
02:51:20 <shachaf> aib: :set -XNoMonomorphismRestriction
02:51:52 <aib> was that because I had no type signature for y?
02:51:53 <quicksilver> or name the parameter
02:52:04 <osfameron> is the dreaded monomorphism restriction a hereditary title that gets passed down to a different restriction every generation?
02:52:16 <aib> I have no idea what any of those words mean in Haskell ^^
02:52:23 <quicksilver> it's because y had no syntactic parameters and no type signature.
02:52:24 <Saizan> it's still the same restriction
02:52:37 <quicksilver> osfameron: you keep using htat word, I do not think it means what you think it means.
02:52:42 <osfameron> ;-)
02:54:37 <sanjoyd> Is there some way I can explicitly pass around the RealWorld instance and use it to take inputs and print outputs?   For instance, I want to write a function to input a String, but I don't want its type to be IO String -- instead I want to it be `RealWorld -> (RealWorld, String)` or something similar.
02:55:17 <penelope> Clean?
02:55:31 <shachaf> sanjoyd: Why do you want that?
02:55:37 <shachaf> sanjoyd: Haskell IO isn't based around RealWorld passing.
02:56:05 <sanjoyd> shachaf: no real reason.
02:56:19 <shachaf> That's just (a) a thing they say in (usually bad) IO tutorials; (b) something vaguely similar to what GHC's internal implementation of IO happens to look like.
02:56:39 <geheimdienst> suppose i have a data F = Foo Int (IO ()), and now i do "fmap (\(Foo i _) -> i * 2) (somefunction :: IO Foo)". why does this cause the IO action in the 2nd field of Foo to get executed?
02:56:44 <geheimdienst> ... this might be stupid, and also i don't understand my exact problem yet (other than IO happening earlier than i wanted)
02:56:57 <shachaf> IO, however, is probably best through of as an abstract type with sanjillions of primitives.
02:57:09 <shachaf> geheimdienst: What?
02:57:25 <shachaf> geheimdienst: Can you @paste a sample program?
02:58:01 <opqdonut> geheimdienst: short answer: NO
02:58:09 <shachaf> geheimdienst: It'll cause the IO action that gives you a Foo to be executed.
02:58:18 <shachaf> geheimdienst: (Also, somefunction isn't a function.)
02:58:19 <sanjoyd> shachaf: interesting.  Can you suggest some good place to read up on this?
02:58:40 <shachaf> @google r6.ca io monad
02:58:40 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
02:58:40 <lambdabot> Title: I/O is not a monad
02:59:06 <shachaf> sanjoyd: Contemplate this sort of data type: data IO = Exit | PutChar Char IO | GetChar (Char -> IO)
02:59:16 <geheimdienst> shachaf: hmm it's part of a larger thingy ... i'll work on extracting something small
02:59:27 <sanjoyd> shachaf: thanks!  And I /did/ get the idea of IO <-> RealWorld relation from a tutorial.
02:59:40 <geheimdienst> shachaf: and yes, the IO Foo action gets executed, that much is clear, and expected
02:59:44 <penelope> Start with the maybe monad.
02:59:51 <geheimdienst> opqdonut: how do you mean "no"?
03:00:10 <shachaf> @google introduction to io haskellwiki
03:00:11 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
03:00:11 <lambdabot> Title: Introduction to IO - HaskellWiki
03:00:24 <shachaf> penelope: You don't need to "understand monads" to "understand" IO in Haskell.
03:00:32 <opqdonut> geheimdienst: the only way a IO action gets executed is if it gets combined with >>= into the IO action that is main
03:00:44 <opqdonut> geheimdienst: (the >>= can be hidden in a >> or a mapM_ or whatever)
03:00:51 <shachaf> penelope: Saying "start with the maybe monad" probably only causes confusion if what you want to do has nothing with monads in general. :-)
03:00:59 <opqdonut> geheimdienst: but in that case you are just silently dropping the IO () that was inside Foo
03:01:05 <dibblego> start with no monad
03:01:13 <shachaf> geheimdienst: Prediction: In the process of extracting a simpler example, you'll find out what your bug is.
03:01:37 <penelope> shachaf: but you do! as soon as you need to mix quickcheck or a server monad transformer.
03:01:53 * hackagebot paragon 0.1.6 - Paragon  http://hackage.haskell.org/package/paragon-0.1.6 (NiklasBroberg)
03:01:57 <shachaf> penelope: That comes way later than understanding IO.
03:02:19 <penelope> Well, as soon as you run into the wall.
03:02:36 <geheimdienst> opqdonut: yes, that's was my understanding as well. "i'm not doing >>= on that action, how can it be run?". however with this code i did manage to confuse myself
03:02:48 <shachaf> I'm not saying you'll never need to understand the abstraction "Monad".
03:02:50 <geheimdienst> shachaf: agreed, that's how it usually is
03:03:05 <opqdonut> geheimdienst: IO (IO a) is hard :)
03:03:12 <shachaf> Mu IO
03:03:24 <geheimdienst> > fix ("IO "++)
03:03:30 <lambdabot>   "IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO IO...
03:04:53 <penelope> Not for tutorials, or math, but for real world stuff? auth + persistance + sockets?
03:05:15 <shachaf> What?
03:06:01 <penelope> I mean, you've got to be a bit more advanced to do web stuff with haskell then number processing.
03:06:30 <shachaf> penelope: Even if you're dealing with the real world, the way to learn abstractions like that is probably to learn concrete instances first and then generalize.
03:06:37 <rostayob> is Fix somewhere in base or in the ptform?
03:06:46 <shachaf> rostayob: Fix?
03:06:56 <shachaf> Do you mean "fix" or "Mu"?
03:07:01 <rostayob> shachaf: Fix f = In (f (Fix f))
03:07:04 <rostayob> oh well, Mu
03:07:07 <shachaf> I doubt it.
03:07:20 <shachaf> It's probably somewhere on Hackage, though (but you could just define it yourself).
03:07:28 <rostayob> yeah I guess I'll do it myself
03:08:19 <mbuf> what does "<1000000" mean in "Dependencies:base (<1000000)" at http://hackage.haskell.org/package/acme-dont-1.0
03:08:36 <rostayob> mbuf: it means that you have to have an upper bound to upload to hackage and the mantainer was lazy
03:09:06 <shachaf> mbuf: Probably "smaller than 1000000".
03:09:08 <shachaf> It's a joke package.
03:09:16 <mbuf> shachaf: okay rostayob okay
03:12:03 <penelope> shachaf: Yes. But abstraction is hard work for most people. New depths would be more accessible with more gentle-introductions. Otherwise, well, it begins with a J.
03:12:23 <shachaf> penelope: I think we're agreeing here that the abstraction is harder than the concrete case?
03:12:35 <shachaf> penelope: Hence I say that, when first learning, you shouldn't even think about the word "monad".
03:13:32 <penelope> Hmm
03:14:39 <penelope> I want to say that IO is a complex topic, mixing the concept of monad and sequential action
03:15:25 <penelope> I'm trying to suggest that starting with more fundamental concepts might be easier, even if those are more "abstract"
03:15:29 <shachaf> penelope: IO could be done just fine in Haskell without the "monad" class.
03:15:35 <shachaf> There are many possible ways of doing it.
03:15:37 <Phlogistique> except in my experience, the concrete case makes little sense without the abstraction
03:15:48 <shachaf> You don't tell people "don't use lists until you understand monads"; why do it with IO?
03:16:16 <penelope> I'm suggesting there is a hierarchy of abstraction, just like in math, and that IO in haskell is not at the bottom.
03:16:36 <Phlogistique> because when you do something slightly complex with IO, you won't understand the error messages the compiler will spit at your face
03:16:40 <rostayob> if I have a datatype 'Blah a', and various functions '(a -> b) -> Blah a -> b' or similar, what is the nicest way to make them work with 'Fix Blah' as well?
03:16:56 <shachaf> Sure. You probably want to understand a bunch of things in Haskell before doing any IO.
03:17:29 <shachaf> However, none of them involve the M word. IO was done in Haskell before "monads" were ever thought appropriate for the purpose.
03:18:11 <rostayob> shachaf: well but it was done in a very different way...
03:18:26 <rostayob> now when you do IO you are using a monad
03:18:40 <rostayob> you might not need to know what a monad is but before you weren't using one in the first place
03:18:57 <shachaf> Sure you were.
03:19:07 <shachaf> Every time you use a function you "use a monad", because (r ->) is a monad.
03:19:32 <ben> Every time you use a value you use a monad, because Identity is a monad.
03:20:26 <rostayob> shachaf: right. my point is that it's more useful to know what is a monad now when doing IO
03:20:36 <rostayob> because the whole idea of IO in haskell came out of monads
03:20:38 <Saizan> i think these are strawmans, since (>>=) is central to the API of IO but it isn't for many other datatypes which are also monads
03:20:56 <shachaf> import GHC.Base (bindIO, returnIO)
03:21:08 <Saizan> bindIO still works like (>>=)
03:21:14 <shachaf> Sure.
03:21:24 <rostayob> shachaf: cmon you can't say "since you did IO before and you didn't know what a monad was, then you don't need to know now
03:21:28 <Saizan> while i don't use concatMap all the time when dealing with lists
03:21:28 <shachaf> And (\_ -> ...) works like return.
03:21:51 <quicksilver> Saizan: to be fair, using bindIO does get you better error messages.
03:21:56 <quicksilver> (than >>=)
03:22:03 <quicksilver> reducing overloading helps errors.
03:22:35 <quicksilver> @type putStrLn >> getLine >>= \x -> return x
03:22:36 <lambdabot>     Couldn't match expected type `String -> a'
03:22:36 <lambdabot>            against inferred type `IO String'
03:22:36 <lambdabot>     In the second argument of `(>>)', namely `getLine'
03:23:02 <Saizan> sure, but it's an operator you've to explain one way or another
03:23:09 * quicksilver nods
03:23:22 <shachaf> It's pretty established empirically that people who approach IO in Haskell thinking that there's some mysterious thing called "monad" that they have to understand first end up being confused and ascribing mystical properties to the type class.
03:23:29 <quicksilver> I was really going back to Phlogistique's point that the error messages force you to know what a monad is.
03:23:43 <quicksilver> certainly the error messages when you do something wrong are a real barrier to "naive understanding" of IO
03:23:48 <Saizan> shachaf: i just think you went to the other extreme :)
03:23:54 <geheimdienst> rostayob: i think it's okay if you use "let" without understanding the parallel randomized k-walk generational mark-and-sweep wossname gc algorithm, particularly if you're a beginner. hence, it's okay to do IO without "understanding monads"
03:23:56 <geheimdienst> shachaf++
03:24:22 <shachaf> Saizan: What, "people should understand the concrete type IO before they try to understand that abstract type class Monad"?
03:24:35 <rostayob> geheimdienst: i never said you have to understand monads to do IO in haskell. but these comparisons don't make much sense (the non-monadic io or the gc)
03:24:50 <rostayob> understanding monads in  haskell is very useful, that's all
03:25:04 <rostayob> since monads are idiomatic haskell, they're everywhere
03:26:07 <penelope> haskall '11 is much more everything than '98
03:26:19 * shachaf to sleep.
03:26:26 <shachaf> Good $TIME
03:26:41 <Saizan> shachaf: yeah, the extreme of refusing an explanation of Monad
03:27:04 <shachaf> Saizan: I don't refuse it! I just say "this is more complicated than you need to just understand how IO is done".
03:27:17 <rostayob> shachaf: monads are not that complicated...
03:27:28 <dever> hey all, i'm trying to used Data.Vector.Storable.Mutable, but can't seem to get the new function working
03:27:32 <Saizan> shachaf: yeah, that's you refusing :)
03:27:52 <dever> i want to create a vector of say size 10, with doubles
03:27:58 <Saizan> shachaf: it adds to the mysticism.
03:28:16 <penelope> mutable?
03:28:27 <quicksilver> dever: and what happens when you try?
03:28:28 <rostayob> Saizan++ that's my point, the more we do this the more monads are something misterious and hard
03:28:46 <rostayob> *mysterious
03:28:56 <shachaf> Saizan: Hmm. Maybe I should figure out a way of saying what I'm saying that doesn't seem that way.
03:29:05 <dibblego> I recently ran a FP workshop at the YOW! conference (SPJ was a keynote speaker) and we learned what a monad was at around hour 5, by not appealing to any mysticism
03:29:17 <shachaf>  Anyway, as I said:
03:29:21 * shachaf to sleep.
03:29:27 <dever> quicksilver: new 10 gives an ambiguous type variable error. tbh, i'm not certain how to specify that it should be a double
03:29:27 <rostayob> sleep tight
03:29:37 <dever> *double vector
03:30:33 <penelope> :: Vector Double doesn't work?
03:31:11 <quicksilver> dever: I suspect "MVector RealWorld Double" is the type you want
03:31:15 <quicksilver> if you're working in IO.
03:31:47 <quicksilver> it may be more convenient to annotate the type of something else to get the compiler to work it out on its own.
03:32:00 <aib> is there an alternative to show that would not add quotes for a Char? I don't really want to do [myChar] as it coerces the type to Char
03:32:38 <quicksilver> aib: don't use show.
03:33:17 <penelope> show ~ read :: pickle ~ unpicle
03:33:47 <wereHamster> can I call impure code from pure? Or is only the other way around possible?
03:34:09 <penelope> it depends on the monad
03:34:11 <hvr> wereHamster: by using unsafe* function you could... but you must decide carefully when to do that
03:34:22 <dever> penelope: nope, that doesn't seem to work
03:34:31 <quicksilver> dever: paste code.
03:34:33 <dever> quicksilver: that doesn't work either http://hpaste.org/55494
03:34:39 <penelope> you can runState, but there is no runIO
03:35:08 <quicksilver> dever: well yes, the type of new has IO in it
03:35:16 <quicksilver> dever: so if you're annotating all of the new, it's
03:35:17 <penelope> What's your line of code?
03:35:23 <quicksilver> IO (MVector RealWorld Double)
03:36:20 <dever> quicksilver: ahhh. i see now. the cloud is clearing, thanks very much!
03:36:29 <dever> penelope: thanks too!
03:36:51 <ddarius> I believe shachaf's point was if you need to use lists, you don't need to go buy a data structures book to learn about data structures in general.
03:37:14 <quicksilver> I would like it to be possible to learn IO without learning anything about Monads.
03:37:23 <quicksilver> I don't think it is really sustainable with current error messages
03:37:54 <penelope> It's sustainable, until you need to mix IO with another monad.
03:38:38 <ddarius> quicksilver: All you have to know for that, is that IO is a monad, so that when you see Monad m, it means IO (for those examples.)
03:38:46 <quicksilver> ddarius: I don't think so.
03:38:54 <quicksilver> ddarius: you get weird errors when GHC infers the wrong monad.
03:39:19 <quicksilver> for example, leaving off a parameter can make it infer the (->) monad; or give you an error message suggesting you should write an instance for the (->) monad.
03:39:53 <ddarius> quicksilver: That happens in many, many cases.  That can easily happen with (+) and commonly does with beginner code.
03:40:26 <quicksilver> yes.
03:40:37 <quicksilver> explain Num is easier though I think.
03:40:48 <quicksilver> and the fact that it happens in other cases doesn't invalidate the point :)
03:41:12 <ddarius> quicksilver: But it changes the point to learning to understand error messages and what they are really saying, rather than learning about monads.
03:42:30 <quicksilver> sure
03:42:48 <quicksilver> but learning to understand error messages by ignoring confusing advice abotu Monads
03:42:52 <quicksilver> anyhow I Think we agree :)
03:43:31 <ddarius> quicksilver: My point is that it is the exact same "confusing advice" for Num, Functor, Show, etc.
03:47:53 <penelope> If only there was a class for (+) without needing a (*) and an `abs` and a (-) etc.
03:48:43 <Eduard_Munteanu> penelope: there's Monoid
03:48:55 <penelope> But what about coordinates?
03:49:13 <Eduard_Munteanu> I'm not sure what you mean?
03:49:19 <Eduard_Munteanu> s/?/./
03:49:25 <penelope> I can substract two, and get a "vector", and I can add that vector to a point,
03:49:32 <penelope> to get another point,
03:49:53 <penelope> But you can't do it nicely with the haskell number classes.
03:50:58 <penelope> (I know, numeric plelude, but it's a bit much.)
03:51:23 <Eduard_Munteanu> penelope: it's pretty natural to define all those things for vectors
03:51:45 <Eduard_Munteanu> e.g. (*) = dot product, abs is the 2-norm etc
03:51:57 <ddarius> Eduard_Munteanu: Dot product doesn't work.
03:52:14 <penelope> You can't multiply points
03:52:34 <ddarius> However, you could spurn mere vectors, switch to a geometric algebra, and then have an arbitrary algebra.  Still, this wasn't what penelope was asking about.
03:52:41 <ddarius> penelope wants a Torsor class.
03:52:43 <saati> penelope: you can, you just have to choose between dot product or cross product
03:52:46 <Eduard_Munteanu> Hm? I'm thinking you're using vectors to represent "points"
03:53:07 <ddarius> saati: It makes no sense to multiply points and the difference of two points is not a point.
03:53:16 <penelope> I want R or J in haskell, that's what I want.
03:53:56 <ddarius> I don't recall J making any distinction between "point" and "vector" so I don't see how that it connected to your earlier statements.
03:54:02 <saati> ddarius: isn't a point a vector from O ?
03:54:02 <aib> what's a good, generic alternative to show?
03:54:08 <ddarius> saati: No.
03:54:12 <penelope> J overloads
03:54:14 <merijn> saati: A point is a vector plus an origin
03:54:46 <merijn> saati: If you define all points in your program to have the same origin then you can treat them as vectors, but they're not the same thing
03:55:18 <merijn> aib: What do you mean?
03:55:24 <merijn> aib: What's wrong with show?
03:55:56 <aib> merijn: sorry, I mean for printing stuff out. a) for debugging b) for actual string output
03:56:04 <ddarius> saati: The location of New York city is a point and the location of Washington DC is a point.  What location is the difference of those two points?
03:56:06 <aib> I guess show is good enough for debugging
03:56:16 <Eduard_Munteanu> If you're representing vectors using their endpoints (e.g. ((1, 2), (3, 4))) then it's pretty clear what a point is :/
03:56:23 <penelope> show is a short name for a thing called "QuotablePrintable"
03:56:24 <wereHamster> how di I find all functions [a] -> a ?
03:56:40 <quicksilver> wereHamster: hoogle will give you a decent list
03:56:48 <merijn> wereHamster: Go to hoogle and search for "[a] -> a"
03:56:53 <saati> ddarius: those are not points
03:56:57 <merijn> aib: Show is for converting stuff to strings, print and friends for printing
03:56:59 <ddarius> Sure they are.
03:56:59 <saati> if we are nitpicking
03:56:59 <wereHamster> ah, head is what I looked for
03:57:02 <jonte> Hello! I'm using records and the automatically generated getters (I'm using GHC).. Is there a way to aotomatically create setters as well?
03:57:18 <Botje> you get foo{bar=...}
03:57:22 <Eduard_Munteanu> ddarius: the difference between their corresponding vectors would be a safe choice I think
03:57:27 <merijn> jonte: What would a setter do?
03:57:35 <Eduard_Munteanu> E.g. a vector according to the triangle rule.
03:57:37 <ddarius> Eduard_Munteanu: What are their corresponding vectors?
03:57:38 <Botje> but you cannot use those as standalone functions, if that's what you're asking.
03:58:04 <Eduard_Munteanu> ddarius: from the "origin", pointing to the location of the city.
03:58:12 <ddarius> Eduard_Munteanu: What is the "origin"?
03:58:19 <jonte> merijn, it would do a{b=value}. I can't figure out how to 'programmatically' enter b though.
03:58:21 <merijn> jonte: Keep in mind that data is immutable, so a "set" operation can't exist. You create a copy and update one of the fields, though. Which uses the syntax Botje showed
03:58:38 <wereHamster> do you recommend use of Show to serialize data into an output format? Or should I write my own functions for that?
03:58:53 <Eduard_Munteanu> ddarius: wait, is this about a very generic vector/points implementation, or can we assume numerical coordinates?
03:58:58 <Varan> Can someone point me to a good proof assistant too proof properties of haskell source code?
03:59:06 <Eduard_Munteanu> If it's a 2D plane, then there is a sensible origin.
03:59:07 <merijn> wereHamster: For simple data show should be fine. For more complex things you should probably wrote your own serialisation
03:59:10 <ddarius> Eduard_Munteanu: No, you can't.  What are the coordinates of Washington DC?
03:59:19 <ddarius> Eduard_Munteanu: No, there isn't.
03:59:36 <merijn> Eduard_Munteanu: You can have multiple origins on a plane
03:59:44 <Eduard_Munteanu> Ouch.
03:59:49 <jonte> merijn, I guess what I want is to be able to have b flexible, so I could do a{'b'=value}, where my program could change the string 'b' to 'c', or some other key
03:59:50 <merijn> I'm pretty sure I remember at least that much from vector calculus
04:00:27 <penelope> you can't add points, you can only subtract them, to get an vector, which is not a point.
04:00:32 <merijn> jonte: Can't do that. Why do you want to do this?
04:00:35 <Eduard_Munteanu> Well, you can, but it's a straightforward transformation to get from one to the other. Again, unless we're talking about something really generic.
04:00:39 <penelope> Though you can add a vector to a point.
04:00:45 <saati> but when you choose an implementation for a computer you will have an origin
04:01:21 <Eduard_Munteanu> Also, what sort of coordinates can you use if you're not even allowed to pick an origin?
04:01:25 <merijn> penelope: You can convert points to vectors, add those then convert the vector to a point. But whether that is a sensible operation is debatable
04:01:32 <chtulu> Hi
04:01:50 <chtulu> I'm on Archlinux and have just installed the haskell-platform
04:01:55 <Eduard_Munteanu> chtulu: hi
04:01:59 * hackagebot zipper 0.4 - Generic zipper for families of recursive datatypes  http://hackage.haskell.org/package/zipper-0.4 (AndresLoeh)
04:02:20 <chtulu> I'm trying to install yesod via `cabal update && cabal install yesod`.
04:02:33 <penelope>  merijn: true, in the sense you can convert pointers to integers, and add them.
04:02:39 <ddarius> Eduard_Munteanu: Even if you do assign an origin, the points represented by vectors differ from the "actual" vectors because the "actual" vectors don't change when you later decide to change the origin where as the "point vectors" do.  Also, a point makes sense on its own independent of any linear/affine structure.  Identifying them with vectors adds a lot of unnecessary baggage.
04:02:49 <Eduard_Munteanu> Varan: to prove properties about Haskell code? That's not going to be easy, mind.
04:03:13 <jonte> merijn, I'm using the State monad to store a, and since I'm doing a{key=(value a)+1} I need to do a<-get prior to each update of my state, and it is annoying :) I would like to be able to run the getter "value" on the 'implicit state' of the state monad.. Is this making any sense? Sorry for the mess. :)
04:03:31 <Eduard_Munteanu> Hm, I guess I could be oversimplifying this.
04:03:37 <merijn> Varan: Proving things about haskell is not that easy, I think. But I belief Coq lets you extract haskell code from Coq proofs
04:03:54 <chtulu> when installing the packages, cabal or ghc tells me that it could not find modules: Could not find module `Data.Binary.Put':
04:03:54 <Varan> oke
04:04:05 <Varan> also not for simple things....
04:04:14 <Eduard_Munteanu> Varan: if you're looking for a proof assistant that's similar to Haskell, there's Agda.
04:04:18 <Varan> such as list properties?
04:04:33 <Varan> oke
04:04:41 <merijn> jonte: Oh, you can probably implement a HOF to do that if you ditch the do-notation
04:04:46 <Eduard_Munteanu> (here on Freenode there's #agda)
04:04:56 <Varan> oke
04:04:56 <Varan> Thanks :)
04:05:01 <Eduard_Munteanu> Varan: ah, yes. But it won't be a proof about Haskell code.
04:05:04 <datura> ddarius: nobody identifies instants with durations ;)
04:05:04 <penelope> chtulu: wipe your cabal, and do a fresh install
04:05:16 <quicksilver> jonte: this annoying problem is what data-lens and similar packages look to solve.
04:05:19 <Eduard_Munteanu> It will be a proof in Agda's setting.
04:05:27 <chtulu> penelope: already done. twice.
04:05:40 <penelope> os?
04:05:43 <chtulu> penelope: the same happens in ghci when I load the module.
04:05:45 <merijn> jonte: You're doing "a <- get; foo a{key=bar}" for differing values of key, right?
04:05:55 <chtulu> penelope: Archlinux. Up to date.
04:05:58 <Varan> Eduard_Munteanu, I mean to proof thinks about code i have written in haskell
04:06:25 <chtulu> penelope: also reinstalled the haskell-platform. Maybe something's wrong with the package... Hmm.
04:06:45 <jonte> merijn, Yes, exactly
04:06:51 <Varan> But can you use haskell code in agda?
04:06:59 <jonte> quicksilver, Aha, I should look in to that
04:07:21 <saati> foo a{key=bar} what is this syntax?
04:07:22 <penelope> It's usually a wierd thing between os-package installs and cabal
04:07:33 <quicksilver> saati: record syntax
04:07:49 <Eduard_Munteanu> Varan: you can't really do that rigorously unless you implement something like a Haskell DSL in Agda. But you could use Agda lists and functions and prove a statement about Agda code.
04:07:59 <penelope> I've tended to just give up, and uninstall any package giving cabal trouble.
04:08:01 <penelope> Sad.
04:08:06 <Varan> owke
04:08:26 <Varan> DSL?
04:08:28 <Eduard_Munteanu> Varan: you can call Haskell code from Agda, but that doesn't let you prove stuff about it.
04:08:29 <chtulu> penelope: ok. thanks. I will just look around to see if there's some info on the Archlinux boards. Maybe they broke that package or something.
04:08:42 <Eduard_Munteanu> Varan: I mean interpreting Haskell code
04:08:57 <penelope> avoid sudo cabal install --global
04:09:17 <Varan> yeah but you can define function in agda that are similar to functions in haskell right?
04:09:18 <saati> quicksilver: okay i got that but what does it mean? it updates one field and leaves the rest unchanged?
04:09:24 <quicksilver> yes
04:09:30 <penelope> did you do ghc-pkg check?
04:09:33 <quicksilver> not a real mutation
04:09:34 <jonte> saati, yes, exactly
04:09:41 <quicksilver> creates a copy with one field updated and the others unchanged
04:09:44 <merijn> saati: Rather, it creates a new copy that is the same except for that one field
04:09:51 <Eduard_Munteanu> Varan: yeah, similar yes, depending on the actual case.
04:09:58 <aib> "Pattern syntax in expression context"? can't have a case inside a lambda, or..?
04:10:02 <saati> merijn: okay, i know everything is immutable
04:10:20 <saati> i needed this multiple times and did ugly things instead
04:10:21 <saati> thanks
04:10:33 <Varan> Eduard_Munteanu, Oke thanks... I dont really have an actual case... i was just wondering
04:10:41 <chtulu> penelope: i only run cabal as a normal user.
04:10:48 <Varan> Ill have a look at Agda
04:10:54 <penelope> when you do ghc
04:10:54 <jonte> merijn, So do you think I can do this if I ditch the do?
04:11:12 <penelope> ghc-pkg check, do you get anything in {}?
04:11:17 <chtulu> penelope: but i see that for some reason the binary module is not installed, although i think it should have been.
04:11:47 <chtulu> penelope: loads of output...
04:11:48 <Eduard_Munteanu> Varan: you could take a look here to get an idea: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
04:12:03 <merijn> jonte: I tried some thing, but its more ugly then I thought. Your best bet is probably data-lens as quicksilver suggested
04:12:05 <penelope> only care about the thing in the {}...
04:12:27 <ddarius> Identifying points with vectors and vectors with bivectors are two of the worst things to happen to the understanding of physics.
04:12:30 <Eduard_Munteanu> But yeah, I guess you don't want to formally verify Haskell code.
04:12:36 <penelope> Those are "broken" packeges, they depends on libraries with the wrong version
04:12:50 <jonte> merijn, Oh! Thanks for the effort :) I will look in to data-lens then. Thanks to the both of you!
04:13:09 <penelope> If your can wipe your user-installs out, and then do a ghc-pkg check,
04:13:18 <chtulu> penelope: there are no broken packages but loads of error messages. i think the haskell platform was not properly installed.
04:13:46 <chtulu> i get many lines of output saying something like this:  There are problems in package ...
04:13:53 <penelope> no root, beyond my debian kung fu.
04:14:04 <penelope> oh
04:14:14 <Eduard_Munteanu> chtulu: are you using the distro-provided packageS?
04:14:23 <penelope> Why not install haskell in your user directory?
04:14:27 <chtulu> Eduard_Munteanu: yes, i am.
04:14:37 <chtulu> penelope: i feel that would be a little dirty.
04:14:46 <penelope> Futz with your path, to make it come first.
04:15:29 <penelope> If You wipe out .ghc, and .cabal, and then ghc-pkg check, and get things with {} around them,
04:15:41 <quicksilver> ddarius: I didn't even know what a bivector was and I have a maths degree. *blush*.
04:15:44 <penelope> And you don't have root,
04:15:50 <penelope> there's not much else to do.
04:16:46 <chtulu> penelope: i have root, but it seems that my haskell install is borked even though i removed the packages and reinstalled for a few times.
04:17:07 <chtulu> penelope: maybe there are some residues. no problem, will figure this out tomorrow.
04:17:12 <chtulu> thanks for the pointers.
04:17:17 <wereHamster> I have a function x y = [foo y, bar y, baz y]. Is there a more elegant way to do that, with fmap or something?
04:17:37 <Eduard_Munteanu> (Maybe you want to wipe ~/.ghc and ~/.cabal while you're at it?)
04:17:53 <quicksilver> wereHamster: you can do map ($y) [foo,bar,baz]
04:17:55 <penelope> map' = flip $ map . flip ($)
04:17:56 <chtulu> Eduard_Munteanu: done.
04:18:01 <merijn> wereHamster: map ($y) [foo, bar, baz]
04:18:45 <wereHamster> what is that $y syntax?
04:18:55 <Eduard_Munteanu> :t ($ y)
04:18:56 <lambdabot> forall b. (Expr -> b) -> b
04:18:59 <Eduard_Munteanu> Erm.
04:19:00 <merijn> Just operator slicing for ($)
04:19:02 <merijn> :t ($)
04:19:02 <Eduard_Munteanu> :t ($)
04:19:03 <lambdabot> forall a b. (a -> b) -> a -> b
04:19:03 <lambdabot> forall a b. (a -> b) -> a -> b
04:19:04 <wereHamster> nevermind, I'm just being slow
04:19:58 <penelope> $ is to . as <*> is to <$> ?
04:20:11 <penelope> or
04:20:15 <penelope> inverse.
04:20:30 <merijn> penelope: Don't you mean the reverse of the last two? $ is to . as <$> is to <*>?
04:20:35 <merijn> :t (<*>)
04:20:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:20:56 <penelope> inverse, reverse.
04:21:00 <ddarius> quicksilver: Well consider a clock face.  If we look at one of the hands we can calculate it's angular momentum.  In the typical way we use the cross product and cross the hand arm with the direction the tip is moving which gives us another vector perpendicular to the face.
04:21:02 <penelope> yes.
04:21:07 <merijn> :t (<$>)
04:21:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:21:26 <quicksilver> ddarius: yes, I believe I know roughly what they are now, I did some reading.
04:21:41 <quicksilver> ddarius: I'm amused / suprised that I never came across them before.
04:22:02 <ddarius> quicksilver: I'm not explaining bivectors, I'm explaining the problem that comes with identifying bivectors and vectors.  Do you know where I'm going with the clock face example?
04:22:14 <ddarius> If so, fill it in so I can finish ironing.
04:22:35 <penelope> Cross products only make sense in limited dimensions...
04:22:47 <quicksilver> ddarius: go on then
04:24:33 <penelope> (sorry, please go on)
04:25:55 <ddarius> If you look at that clock face in a mirror, that is reflect it.  That means you will negate all vector components perpendicular to the clock face, i.e. you would negate your angular momentum vector.  But if you were to recalculate that angular momentum, since the hand arm and direction of motion are in the plane of clock face, and thus unaffected by a reflection, you'd get the same angular momentum as before.
04:26:19 <ddarius> The latter one is correct, angular momentum is preserved under reflection.
04:26:58 <ddarius> If you had simply used the outer/wedge product instead of the cross product, you never would have left the plane and so that bivector is preserved by reflection.
04:27:11 <quicksilver> I see.
04:27:44 <quicksilver> makes sense to me.
04:27:49 <quicksilver> stupid university.
04:27:54 <ddarius> What's happening is the duality (in 3 dimensions) between vectors and bivectors relies on the pseudoscalar which encodes the handedness.  Reflection changes the handedness, and thus changes the pseudoscalar, and thus changes the duality transform.
04:28:23 <ddarius> (Another benefit of this is that you don't have to unintuitively leave the plane to talk about rotational phenomena.)
04:31:50 <penelope> Is there a relationship between bivectors and covarients?
04:50:09 <zhulikas> is there a function which takes a Fractional and returns Bool meaning whether it's value after floating point is zero or not?
04:50:20 <zhulikas> like if it can be transformed to Num without losing precision
04:50:21 <zhulikas> so
04:50:25 <zhulikas> 5.0 would be True
04:50:30 <zhulikas> while 1.75 would be False
04:51:17 <quicksilver> that would not be very reliable
04:51:25 <quicksilver> since floating point arithmetic is approximate.
04:51:48 <zhulikas> I only care whether it ends with .0 or not :)
04:51:52 <quicksilver> try using abs (x - fromIntegral (round x)) < 0.00001
04:51:59 <ion> > let f x = x - (fromIntegral . floor) x == 0 in map f [42.0, 42.1]
04:52:01 <quicksilver> where 0.00001 is chosen to match your application.
04:52:01 <lambdabot>   [True,False]
04:52:03 <zhulikas> yeah, that would work
04:52:18 <zhulikas> I was hoping for a built-in function
04:52:20 <quicksilver> ion: 1 demerit to ion, never use == on floating point types.
04:52:56 <Ke> never say never
04:53:28 <ion> My code should answer the exact question about whether it can be converted to an Integer without losing precision.
04:53:49 <ion> If you are willing to lose some information, that’s another case.
04:55:21 <zhulikas> well, == 0 looks more reliable than < 0.00001
04:55:35 <Phlogistique> depends on what you're trying to do
04:55:39 <oleiade> Hi everyone
04:55:40 <Phlogistique> never stop at the looks!
04:55:48 <hpc> you should also do it the other way too; floats can't represent the full range of an int, and doubles can't represent the full range of a long
04:55:57 <quicksilver> ion: not really. It answers a question about how much precision has already been lost, which is not that helpful.
04:56:06 <zhulikas> Pn=n(3n1)/2
04:56:09 <zhulikas> there is a function
04:56:22 <zhulikas> and I need to find out whether some number is a result of this function
04:56:30 <oleiade> I'm coming from C++ and Python, and I'm very enthusiastic about Haskell, though I've gone through learn haskell for great good, I'd really like to practice a bit more...
04:56:33 <zhulikas> P(3) is 12
04:56:40 <quicksilver> zhulikas: you absolutely do not want to use floating point maths for that.
04:56:43 <zhulikas> so I need to revert this function
04:56:45 <oleiade> nay ideas of where to find exercices for begginers?
04:57:04 <quicksilver> > (1.2 - 0.1 - 0.1) == 1.0
04:57:04 <lambdabot>   False
04:57:08 <hpc> oleiade: there's a page on the haskell wiki that teaches you how to write an IRC bot; that's a good page to try
04:57:24 <hpc> oleiade: there's another one where you write a complete scheme interpreter
04:57:33 <oleiade> hpc : oh thanks, I'm gonna try to find that :-)
04:57:42 <hpc> oleiade: you can also go through project euler, though that is more about knowing math than programming
04:57:48 <ClaudiusMaximus> > map (\x -> let (n, f) = properFraction x in if f == 0 then Just (n :: Integer) else Nothing) [-3, -2.5 .. 3 :: Rational]
04:57:48 <lambdabot>   [Just (-3),Nothing,Just (-2),Nothing,Just (-1),Nothing,Just 0,Nothing,Just ...
04:57:53 <oleiade> hpc: sounds a bit tough for a first practice :-)
04:58:44 <mprokos> I am new to haskell too.. This is my second time giving it a go. The first time I got pulled into clojure.. now i'm back =))
04:58:47 <quicksilver> zhulikas: use integer operators like div and mod.
04:58:55 <zhulikas> yeah, now I think about it...
04:58:57 <hpc> oleiade: the irc bot one is a bit tough, as it only really gives you enough to not get disconnected; the scheme one walks you through the entire process
04:59:12 <zhulikas> as I print some values for these functions and those doesn't seem to have anything after floating point
04:59:24 <zhulikas> that means that /2 can be replaced with div
04:59:32 <zhulikas> ok then, I'll risk it
04:59:50 <hpaste> aib pasted “what?” at http://hpaste.org/55497
04:59:52 <oleiade> hpc okay thank you very much I'm gonna try that then, but as I'm struggling with the "classic" 99solutions exercices, don't know if I'm ready for that :-0
05:00:22 <hpc> oleiade: those are good, but i don't think they prepare you for "writing programs" in haskell, so much as "writing functions"
05:00:46 <hpc> oleiade: save them though and go through a couple every so often if you get bored with bigger things
05:01:00 <oleiade> hpc: that's it, I understand the basics of functional programming, but I need to see how a "real program" is written now :-)
05:01:46 <aib> anyone care to go over my first program to point out any style issues etc? http://hpaste.org/55498
05:03:33 <oleiade> hpc: hey another thing I'd really like to know, is there anyway to list functions from a module in ghci?
05:03:48 <aib> it must be a mess; I've never seen production quality Haskell code!
05:04:07 <ClaudiusMaximus> oleiade: :browse
05:04:20 <oleiade> ClaudiusMaximus: awesome, thank you :-)
05:04:59 <exeter> aib: I fail to see the usefulness of curly brackets.
05:05:21 <aib> and the semicolons?
05:05:47 <exeter> http://hpaste.org/55499 <- little "reparse problem" with Parsec. Explanation inside!
05:05:47 <jessopher> the usefulness is obvious, but the neccessity is not
05:05:57 <exeter> what jessopher
05:05:58 <ClaudiusMaximus> aib: shadowing Prelude functions like 'tail' is a bit confusing
05:06:00 <exeter> +said
05:06:14 <quicksilver> aib: whenever you have "case .... Nothing -> Nothing" you could consider using 'fmap' instead
05:06:46 <aib> ClaudiusMaximus: quicksilver: excellent. anything else?
05:06:58 <wereHamster> should I use Data.Time or Data.DateTime?
05:09:04 <exeter> some people also like explicit function importing, aib
05:09:15 <exeter> (but I kind of find it not that useful)
05:09:19 <frerich> aib: I think in costStepLR, I'd use pattern matching instead of guards, since in many guards you don't use all arguments. You could have e.g. 'costStep [x] _ _ = Nothing' instead of "costStep (cur : tail) start end | tail == [] = Nothing'
05:10:00 <quicksilver> didn't spot that. "== []" is code smell too.
05:10:24 <exeter> quicksilver: sorry to bother you again with Parsec, but I feel you prolly are learned enough to know wheter or not I am approaching the problem the correct way http://hpaste.org/55499
05:10:50 <mikeplus64> how would one go about "running"/printing the result of a function given by a user? eg if they entered "foobar" it would run foobar and show the result, like in ghci, except, optimized, and not in ghci
05:12:41 <frerich> >:t (&&&)
05:12:46 <ClaudiusMaximus> :t M.lookup
05:12:47 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
05:12:59 <frerich> :t (&&&)
05:13:00 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:13:14 <mikeplus64> the reason I ask is because I want to be able to select what project euler problem's solution I want to print out, and find writing long case statements boring
05:13:29 <mikeplus64> (all my project euler solutions are dumped into the one .hs)
05:14:37 <ClaudiusMaximus> mikeplus64: IntMap or Map might work well for this (if all the solutions have the same type)
05:14:42 <hpc> aib: http://hpaste.org/55500 -- my comments on your code, plus some changes
05:14:58 <ClaudiusMaximus> mikeplus64: otherwise a list would be fine too assuming there aren't loads
05:15:30 <mikeplus64> ClaudiusMaximus: they are of different types, yeah
05:15:33 <ClaudiusMaximus> mikeplus64: oops, that otherwise is for the hugeness, not the types
05:17:05 <mikeplus64> is this a problem for (*drumroll*) template haskell?
05:17:08 <aib> hpc: excellent, thanks for the suggestions
05:17:08 <frerich> So, in layman's termns, &&& is useful if I have a value and I want to apply to different functions to it (which take the same type of argument but might yield different results), combining the two results in a tu ple?
05:17:10 <ClaudiusMaximus> > 3 `lookup` [(1, show 3), (2, show (Just 'c')), (3, show (Left "my coat")), (4, (Right, "i'm off"))]
05:17:11 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:17:11 <lambdabot>         against inferred ty...
05:17:22 <ClaudiusMaximus> > 3 `lookup` [(1, show 3), (2, show (Just 'c')), (3, show (Left "my coat")), (4, show (Right, "i'm off"))]
05:17:22 <lambdabot>   Overlapping instances for GHC.Show.Show
05:17:23 <lambdabot>                              (b -> ...
05:17:26 <ClaudiusMaximus> aargh
05:17:58 <quicksilver> exeter: well I don't know what cbiLine does but in general, no, there isn't a simple way to grab some parts of a string and resubmit to the main parser.
05:18:15 <quicksilver> exeter: there is generally a way to avoid having to do that; can you give a bit more context?
05:18:25 <jessopher> mike: either that or a hand jammed interface generator. A .hi file would be pretty simple to parse as long as there is some comonality in the type of the functions. Whatever you do its going to have to have some type correctness
05:18:50 <ClaudiusMaximus> anyway, that kind of pattern - using a datastructure to hold all your answers, lazy evaluation would ensure only the answers demanded are calculated
05:19:31 <aib> thanks for all the suggestions, people. I'm half-inclined to set up source control or unit testing before I go implementing all of them :)
05:19:47 <mikeplus64> jessopher: ok, thanks
05:20:15 <mikeplus64> ClaudiusMaximus: also thanks, now to read on TH and Map/IntMap
05:21:57 <Eduard_Munteanu> VCS is a good idea in many cases.
05:22:07 <exeter> quicksilver: sorry, I forgot to explain what cbiLine does. Basically not much, lemme repaste http://hpaste.org/55502 explanation inside
05:23:54 <quicksilver> exeter: you could redesign cbiLine so it takes as a second parameter a parser which it applies after the "cs" bit at the beginning.
05:24:13 <exeter> thanks quicksilver , I'll look into that
05:32:47 <mm_freak> why do so many packages depend on base >= 4.0 && < 4.5?
05:33:07 <mm_freak> did they somehow have a vision that 4.5 will break things?
05:33:42 <merijn> You didn't get the vision?
05:33:56 <mux> he must be using the wrong tea leaves
05:34:02 <merijn> Obviously
05:34:57 <mm_freak> i live in the arrow world…  i don't get visions ;)
05:35:30 <Jaxan> i used to get visions...
05:35:43 <merijn> Anyone else ever find themselves writing code and then thinking they should be stoned to death for said code the second you finish writing it?
05:36:23 <Eduard_Munteanu> The dudes in Arroyo seemed like the kind of people who'd get visions ;)
05:36:30 <mm_freak> merijn: every day when i have to write PHP
05:36:46 <mux> merijn: that happens when I read code I wrote back when I was 15 years old; makes me want to kill myself, pretty much
05:37:35 <merijn> mux: Today's attempt: http://hpaste.org/55501 :p
05:37:45 <merijn> I'm especially proud of line 5, in a morbid sort of way
05:38:08 <Botje> Eduard_Munteanu++ # fallout reference
05:38:22 <mux> merijin: oh wow, that looks very, very close to the code I write when I'm drunk (no offense :D)
05:39:03 <merijn> It even seems to work!
05:39:06 <exeter> mhhh, ok I'm going to ask something blasphemous(sp) in this channel: is there an easy way to echo stuff from a pure function? Just for debug purposes, I'd like a function which outputs stuff to console. Is there something similar^
05:39:08 <exeter> *?
05:39:22 <mux> exeter: Debug.Trace, trace function
05:40:01 <exeter> thanks mux
05:40:09 <mux> you're welcome
05:40:36 * jessopher hasnt debugged haskell in so ooo long
05:40:36 <merijn> mux: None taken, since I have the sneaking suspicion you're a better coder drunk than I am sober :p
05:40:51 <lukish_> Solving 20ex from 20 intermediate haskell exercises. banana f (State v) = State $ \x -> state ( f . snd . v $ x ) x . What does it mean v x here?
05:41:20 <hpc> merijn: line 5 is a work of art
05:41:24 <mux> merijn: I'm not so sure, my drunk coding usually end up in hard-to-debug segfaults (when it's C)
05:41:46 <merijn> hpc: :)
05:41:55 <hpc> merijn: that looks like... merging empty malloc cells?
05:42:13 <merijn> hpc: Pretty similar, yeah
05:42:54 <Botje> lukish_: you apply v to x, then snd to that, then f to that
05:43:55 <lukish_> Botje: http://blog.tmorris.net/20-intermediate-haskell-exercises/
05:44:01 <lukish_> v :: State s a
05:44:11 <lukish_> How can I apply v to x?
05:44:42 <aib> I think I'm getting the hang of this: http://hpaste.org/55503
05:45:56 <aib> I do hope it makes sense in a week's time
05:46:00 <Eduard_Munteanu> lukish_: look what State contains
05:46:18 <Eduard_Munteanu> (you don't apply v to x literally)
05:46:38 <merijn> aib: Personally I'd probably split it up into 2 where clauses to give some sensible names to things. But that might be my own handicap of not being to handy at reading many .'s yes
05:46:54 <Botje> lukish_: note that you pattern matched State { state :: s -> (s,a) } to State v
05:46:59 <Botje> so v :: s -> (s,a)
05:48:13 <lukish_> I can't understand how it matched from (State v) that v :: s -> (s,a)
05:48:27 <lukish_> It should be v :: State s a
05:48:39 <Botje> the State constructor carries one value, a function from s to (s,a)
05:48:42 <sipa> note that State is both a constructor and a type
05:49:26 <sipa> the value-level function State takes something of type (s -> (s,a)), and returns something of type State s a
05:50:13 <sipa> so if you match something of type State s a against State x, x is of type (s -> (s,a))
05:50:20 <aib> merijn: I think I'm with you there. This looks unreadable, but I don't know if it's because I'm very new at reading this stuff or it's simply bad code
05:50:48 <aib> time will tell, hopefully
05:51:11 <hpc> aib: im going with "because it's C++" :P
05:51:44 <hpc> oh, or are we talking about different code now?
05:52:14 <hpaste> merijn annotated “before/after” with “before/after (annotation)” at http://hpaste.org/55503#a55505
05:52:37 <merijn> aib: I would write it like that (replacing usefulName with something semantically meaningful, of course)
05:54:15 <merijn> Stops you from having to parse to many operations in one go
05:54:43 <merijn> I think anything longer than three or four functions probably warrants its own name, unless it's truly trivial
05:55:07 <hpc> merijn: my rule is "if you like it, put a name on it"
05:55:23 <aib> merijn: heh, I'd have done it the other way around. (length &&& reverse.sort.occurences) is simply (total # of things, things grouped into occurences) =)
05:55:51 <merijn> aib: What do you mean by the other way around?
05:56:21 <aib> merijn: flip what you put in the where clause and the function body. map concat (costPath path) is the confusing part for me
05:57:30 <merijn> aib: Well, it doesn't really matter which line goes where. As long as the split makes it easier to parse the separate pieces
05:57:31 <zhulikas> No instance for (Floating Int)
05:57:36 <zhulikas> how can I define as Floating Int ?
05:57:41 <zhulikas> Floating Int a doesn't work
05:57:49 <merijn> zhulikas: You don't, sounds like a job for "fromIntegral"
05:58:00 <mike-burns> If you can name it, do so.
05:58:01 <zhulikas> more like toIntegral
05:58:13 <zhulikas> I take Int and need to return fractional number
05:58:18 <merijn> zhulikas: You want to convert a float to an int?
05:58:20 <zhulikas> though.... not exactly fractional
05:58:31 <zhulikas> fromTriangular n = (-1/2) + sqrt (1/4 + 2* n)
05:58:40 <merijn> zhulikas: No, then you want fromIntegral
05:58:46 <zhulikas> hmm
05:58:57 <zhulikas> ahh, ok
05:58:59 <zhulikas> thanks :D
05:59:21 <merijn> zhulikas: It's complaining you're using Int's in a context where it wants a float. fromIntegral lets your turn said Int into a float
05:59:31 <zhulikas> ok, I see
06:00:09 <merijn> aib: I picked that part because it was nicely self contained and could be easily split of from the rest of the activity.
06:00:38 <merijn> aib: Just a simple matter of splitting operations into self-contained pieces and giving them names. Which you want where is just a matter of personal preference :p
06:02:05 <aib> I see :)
06:08:09 <exeter> what's the fromMaybe for Either?
06:08:28 <hpc> :t either
06:08:29 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:24:13 <wereHamster> how do I convert a int into a oct encoded string? I found showOct, but that doens't sem to work, always complains about No instance for (Show ShowS)
06:24:49 <quicksilver> "I don't know how to use it" is not "It doesn't work"
06:24:53 <quicksilver> :t showOct
06:24:54 <lambdabot> forall a. (Integral a) => a -> String -> String
06:25:03 <quicksilver> > showOct 99 ""
06:25:03 <lambdabot>   "143"
06:25:15 <mux> > printf "%o" 9
06:25:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:25:16 <lambdabot>    `Text.Printf.PrintfType ...
06:25:20 <mux> > printf "%o" 9 :: String
06:25:21 <lambdabot>   "11"
06:25:22 <wereHamster> interesting. I get showOct :: Integral a => a -> ShowS
06:25:28 <quicksilver> ShowS = String -> String
06:25:59 <wereHamster> ah, that might explain my confusion
06:26:45 <quicksilver> :)
06:32:04 * hackagebot pointless-haskell 0.0.7 - Pointless Haskell library  http://hackage.haskell.org/package/pointless-haskell-0.0.7 (HugoPacheco)
06:32:06 * hackagebot pointless-lenses 0.0.8 - Pointless Lenses library  http://hackage.haskell.org/package/pointless-lenses-0.0.8 (HugoPacheco)
06:32:45 * dever is in monadic hell.
06:33:25 <EvanR-work> class MonadHell
06:36:20 <dever> instance Hell Dever where destroy Soul = Nothing
06:36:38 <hpc> i read that as instance Hell Denver
06:40:12 <wereHamster> :t format
06:40:13 <lambdabot> Not in scope: `format'
06:40:18 <kakos> hpc: An accurate description of Denver...
06:42:12 <dever> lol
06:45:18 <wereHamster> if I have 'data Type = Foo', is there a way to introspect the names of the constructors? Like to get "Foo"?
06:45:39 <tsousa> i have a question. how can i return the length and the sum of a list with only one recursive call ?
06:48:22 <Botje> calculate both as you go along.
06:48:27 <Saizan> tuples!
06:48:35 <tsousa> yes i know
06:48:51 <tsousa> but i dont know how to do that
06:49:00 <tsousa> i already did one to calcule the sum of all number
06:49:04 <cheater> tsousa: do you know how to calculate the length of a list recursively?
06:49:13 <tsousa> and the length with that i do not know
06:49:18 <Botje> use a tuple to keep a running count of both the length and the sum
06:49:24 <cheater> how do you calculate the sum? show us the code
06:49:49 <tsousa> n + sumoflist(xs)
06:50:03 <ClaudiusMaximus> @pl mconcat . map (\x -> (Sum 1, Sum x))
06:50:03 <lambdabot> mconcat . map ((,) (Sum 1) . Sum)
06:50:12 <roconnor> tsousa: foldr (\x (l,s) -> (succ l, x+s)) (0,0)
06:50:19 <roconnor> @type foldr (\x (l,s) -> (succ l, x+s)) (0,0)
06:50:20 <lambdabot> forall a t. (Enum t, Num a, Num t) => [a] -> (t, a)
06:50:53 <roconnor> actually I like ClaudiusMaximus's solution
06:51:03 <tibbe> wereHamster: using the Typeable class I think
06:51:27 <tsousa> ClaudiusMaximus, i have to do that without any help function
06:51:28 <ClaudiusMaximus> Data.Data.Data perhaps
06:51:34 <cheater> tsousa: yeah
06:52:00 <cheater> tsousa: now consider if you add "1" instead of "n" for every element of the list, you get the length of the list
06:52:07 <cheater> you've got as many 1's as you have elements
06:52:15 <cheater> add them up, and you have the length.
06:52:36 <frerich> If you want to have the length of a list of numbers and the sum of them, and you used 'length &&& sum' (which is IMHO very descriptive, too!), couldn't the compiler actually use loop fusion if it sees the two iterations?
06:53:02 <tsousa> cheater, yes but then i need to have two recursive call
06:53:06 <tibbe> wereHamster: Data.Data http://haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Data.html
06:53:08 <tsousa> i can only have one
06:53:12 <cheater> frerich: it might do. but i think it's outside of tsousa's focus right now.
06:53:14 <cheater> tsousa: i realize
06:53:26 <cheater> tsousa: but now you know how to get the length recursively
06:53:43 <cheater> tsousa: now think about it this way... you can do both things in a recursive call
06:53:51 <cheater> do you know about do blocks?
06:54:09 <tsousa> yes i do i already knew that. my problem i to join those in in function
06:55:35 <tsousa> cheater, in haskell block only let
06:56:18 <cheater> tsousa: yeah
06:56:27 <cheater> tsousa: just trying to figure out what you know to make it easier for you
06:56:36 <cheater> tsousa: your length function would look like this
06:57:22 <cheater> len x:xs = do rest <- len xs; 1 + rest
06:57:38 <cheater> > let len x:xs = do rest <- len xs; 1 + rest; in len [1, 2]
06:57:39 <lambdabot>   <no location info>: Parse error in pattern
06:57:48 <cheater> hmm, how do you do this on one line?
06:57:55 <hpc> need parens, and also a monad
06:58:23 <cheater> can you fix it?
06:58:37 <tsousa> cheater, 1 + rest(xs)
06:58:52 <cheater> i wanted to show tsousa how to do the "1 + rest" and "x + rest_sum" things together in the body
06:59:03 <statusfailed> alright, I think I understand Monad, someone ask me a question and prove me wrong :D
06:59:04 <cheater> tsousa: nope, rest is the length of xs
06:59:16 <hpc> > let len [] = return 0; len (x:xs) = do r <- len xs; return (1 + r) in runIdentity (len [1..5])
06:59:17 <lambdabot>   5
06:59:43 <hpc> the returns are important
06:59:51 <cheater> there you go.
06:59:56 * cheater 's haskell is a bit rusty
07:00:04 <hpc> or you end up with len :: Monad m, Num (m a) => [b] -> m a
07:00:06 <cheater> now, sum would look like this:
07:00:07 <tsousa> tsousa, my function is length (_:xs) = 1 + length(xs)
07:00:29 <hpc> oh, and Num a
07:00:40 <cheater> > let sum [] = return 0; sum (x:xs) = do r <- sum xs; return (x + r) in runIdentity (sum [1..5])
07:00:41 <lambdabot>   15
07:01:40 <hpc> :t let sum [] = return 0; sum (x:xs) = do r <- sum xs; return (x + r) in sum
07:01:41 <lambdabot> forall b (m :: * -> *). (Monad m, Num b) => [b] -> m b
07:02:17 <tsousa> cheater, i am sorry but i still do not get i can i join it in one
07:03:03 <cheater> to couple those you'd do something like:
07:03:05 <cheater> > let sumlen [] = return (0, 0); sumlen (x:xs) = do r <- sumlen xs; return ((1 + fst z, x + snd z)) in (sumlen [1..5])
07:03:06 <lambdabot>   Couldn't match expected type `(a, b)'
07:03:06 <lambdabot>         against inferred type `Simple...
07:03:13 <cheater> > let sumlen [] = return (0, 0); sumlen (x:xs) = do r <- sumlen xs; return ((1 + fst z, x + snd z)) in runIdentity (sumlen [1..5])
07:03:14 <lambdabot>   Couldn't match expected type `(a, b)'
07:03:14 <lambdabot>         against inferred type `Simple...
07:03:23 <cheater> hmm, why does this work in ghci but not in lambdabot?
07:03:31 <hpc> because you use z instead of r
07:03:44 <cheater> indeed i do
07:03:49 <cheater> > let sumlen [] = return (0, 0); sumlen (x:xs) = do z <- sumlen xs; return ((1 + fst z, x + snd z)) in runIdentity (sumlen [1..5])
07:03:50 <lambdabot>   (5,15)
07:03:56 <cheater> there you go.
07:04:20 <cheater> the two calculations are: 1 + fst z (which calculates the length during each recursive step) and x + snd z (which calculates the sum)
07:04:23 <cheater> thanks a lot hpc
07:05:54 <cheater> i think tsousa didn't like the answer lol
07:15:05 <Guest81618> Hi all, does anyone know where I can find the Haskell interfaces generated from the IDL definitions? (York Haskell Compiler, http://code.haskell.org/yc2js/)
07:16:18 <wereHamster> how do I remove the 'a' from both sides of this equation? objectTypeString a = map toLower $ show a
07:16:43 <Phlogistique> wereHamster: objectTypeString = map toLower . show
07:16:53 <ciaranm> wereHamster: using your backspace key
07:16:59 <Phlogistique> wereHamster: also lambdabot can answer this question; I'm not sure how
07:17:02 <merijn> @pl objectTypeString a = map toLower $ show a
07:17:02 <lambdabot> objectTypeString = map toLower . show
07:17:11 <Phlogistique> thanks merijn
07:17:24 <merijn> (You can also privmsg lambdabot)
07:17:28 <wereHamster> ciaranm: the key here is labelede 'delete' :P
07:17:41 <wereHamster> I'm not that embarrased.. yet :)
07:18:07 <merijn> wereHamster: It's not about embarrassment, it's about keeping the channel spam free from people using pl :p
07:22:04 * hackagebot Catana 0.1 - A monad for complex manipulation of a stream.  http://hackage.haskell.org/package/Catana-0.1 (DustinDeWeese)
07:23:29 <rostayob> Is there any way to have a Show instance for  'Fix f'? I can have something like 'instance Show (f (Fix f))) => Show (Fix f) where' but that doesn't help
07:25:25 * jessopher starts using footnotes for developer documentation
07:27:04 * hackagebot unordered-containers 0.1.4.5 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.4.5 (JohanTibell)
07:28:01 <Phlogistique> how do I include the definitions of join/liftM2 etc. that lambdabot uses?
07:28:42 <Phlogistique> something like ":m +Control.Monad" then "join (+) 4" in ghci yields an error
07:28:42 <Megant> Phlogistique: Control.Monad
07:29:00 <Phlogistique> ...now it doesn't
07:29:06 <ciaranm> Control.Monad.Instances too probably
07:29:43 <Phlogistique> ciaranm: that's it! thanks
07:30:01 <quicksilver> rostayob: it's hard to write and I've forgotten the trick.
07:30:09 <byorgey> rostayob: I think you have to turn on UndecidableInstances
07:30:26 <byorgey> then I think what you have works fine.
07:31:49 <rostayob> quicksilver, byorgey: well I can work the instance that I have described
07:31:53 <rostayob> with UndecidableInstances
07:31:59 <rostayob> *I can write
07:32:05 <rostayob> but it's not that useful
07:32:36 <hpaste> rostayob pasted “Fix and Show” at http://hpaste.org/55507
07:32:38 <roconnor> @tell edwardk I'm worried that (^.) has the wrong associativity. r^.l1^.l2 should be legal and be (r^.l1)^.l2 just like in Pascal.
07:32:38 <lambdabot> Consider it noted.
07:33:10 <rostayob> quicksilver, byorgey: ^^^ see the hpaste
07:33:25 <rostayob> that instance is never "hits the bottom"
07:33:57 <rostayob> and it's should be "show (Roll f)"
07:34:00 <rostayob> but anyways
07:34:29 <Saizan> that instance works quite fine
07:35:17 <Saizan> have you tried it?
07:35:41 <byorgey> *Fix> show  (Roll (Just (Roll (Just (Roll Nothing)))))
07:35:41 <byorgey> "Just Just Nothing"
07:36:02 <byorgey> works fine, although some parens are probably needed
07:36:48 <Saizan> StandaloneDeriving let you make GHC write it for you, btw
07:37:06 <rostayob> oh right, I think I had the reverse before
07:37:07 <Saizan> since you can pick the context
07:37:13 <rostayob> and it didn't work
07:38:42 <byorgey> (although the automatically derived instance is terrible because of the field label)
07:38:56 <byorgey> *Fix> show  (Roll (Just (Roll (Just (Roll Nothing)))))
07:38:56 <byorgey> "Roll {unRoll = Just (Roll {unRoll = Just (Roll {unRoll = Nothing})})}"
07:39:04 <wereHamster> do functions in the 'where' section have access to the original arguments of the function?
07:39:40 <rostayob> ehe
07:39:53 <byorgey> wereHamster: yes, but only the clause to which the 'where' is attached
07:42:22 <rostayob> byorgey: I'm trying to figure out how GHC figures that one out. that Fix f = f (Fix f)
07:42:49 <byorgey> rostayob: how it figures what out?
07:43:09 <rostayob> why that instance works
07:43:50 <rostayob> ah, right
07:43:57 <byorgey> well, to have a Show instance for (Fix Maybe) it needs a Show instance for (Maybe (Fix Maybe))
07:44:15 <rostayob> yeah but
07:44:17 <rostayob> maybe has something like
07:44:18 <byorgey> Maybe t  has a Show instance as long as t has one
07:44:24 <rostayob> instance Show a => Maybe a
07:44:38 <byorgey> exactly
07:44:42 <rostayob> yeah I get it now.
07:44:46 <rostayob> mh
07:44:52 <byorgey> so the Show dictionary that gets generated for Fix Maybe  is actually recursive
07:44:54 <rostayob> type level recursion agaaain
07:44:59 <byorgey> but it works because of laziness.
07:45:12 <quicksilver> the constraint ends up using itself recursively but that's no more problematic than a normal recursive definition
07:45:12 <rostayob> lazyness?
07:45:40 <quicksilver> with a simple type like data Expr = Add Expr Expr; instance Show Expr where show (Add e e) = "Add " ++ show e ++ show e
07:45:43 <rostayob> byorgey: where does lazyness come into play? you mean some lazyness at the type level?
07:45:45 <quicksilver> you are still using recursion.
07:46:03 <hpc> rostayob: the Show dictionary is a map that contains all the functions for a given instance of Show
07:46:08 <rostayob> quicksilver: i guess, but it's more tricky for my brain in this case
07:46:15 <hpc> rostayob: it references itself, because the instance assumes itself
07:46:20 <rostayob> hpc: yeah, so some type level lazyness
07:46:34 <quicksilver> rostayob: it is a bit weird for the brain but I'm just showing it's not *actually* any more weird than ordinary recursive types
07:46:46 <quicksilver> instances on recursive types are always allowed to use themselves recursively.
07:46:51 <quicksilver> No, there is no type-level laziness.
07:47:00 <hpc> rostayob: it ends up looking like that, kind of; the dictionary is actually a runtime value
07:47:06 <hpc> rostayob: lemme find a link that might help
07:47:06 <quicksilver> types are "evaluted" (checked) eagerly.
07:47:31 <quicksilver> I think hpc's intuition is much too based on an implementation detail
07:47:37 <hpc> rostayob: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:47:40 <rostayob> quicksilver: lazyness regarding this imaginary record representing the type clases function
07:47:42 <rostayob> s
07:47:50 <quicksilver> GHC might use dictionaries but dictionaries are not "why recursive instances work"
07:48:01 <rostayob> quicksilver: yeah I agree, that's why i was confused by the "lazyness"
07:48:07 <merijn> quicksilver: They work because of the pixies, right?
07:48:16 <quicksilver> merijn: type-level pixies.
07:48:32 <merijn> The type-level only has gremlins
07:49:16 <quicksilver> never implement kind polymorphism after midnight
07:49:34 <sipa> unless you're called Oleg
07:49:38 <cheater> but every day is after midnight
07:49:46 <cheater> you guys are obviously never gonna get around to it
07:49:48 <hpc> sipa: Oleg doesn't use extensions :P
07:49:55 <hpc> sipa: he would implement it at the type level
07:50:10 <sipa> of course, where else?
07:50:46 <quicksilver> in fact show is just a plain recursive function
07:50:58 <quicksilver> and recursive functions work in most languages, including strict ones
07:51:06 <dolio> Oleg uses all sorts of extensions.
07:51:08 <quicksilver> the fact that the dictionary is lazy is not required.
07:51:09 <dolio> Including all the bad ones.
07:51:32 <quicksilver> he is more careful than most to note which ones he use and why they make a difference, though.
07:53:28 <mellum> @pl f x = let (m, e) = decodeFloat x in encodeFloat m e
07:53:28 <lambdabot> (line 1, column 5):
07:53:28 <lambdabot> unexpected "="
07:53:28 <lambdabot> expecting variable, "(", operator or end of input
07:53:46 <mellum> hmmm, pl doesn't handle pattern matching let?
07:54:10 <xplat> Oleg can win Haskell without extensions, but sometimes he likes to play a more relaxing game of Haskell and allows himself extensions
07:55:10 <sipa> @faq can Haskell be 'played' like a game?
07:55:10 <lambdabot> The answer is: Yes! Haskell can do that.
07:55:15 <rostayob> @pl \x -> (\(m, e) -> encodeFloat m e) (decodeFloat x)
07:55:16 <lambdabot> uncurry encodeFloat . decodeFloat
07:56:05 <mellum> cool, thanks.
07:57:05 * hackagebot network-bitcoin 0.1.5 - Interface with Bitcoin RPC  http://hackage.haskell.org/package/network-bitcoin-0.1.5 (MichaelHendricks)
07:57:44 <xplat> copumpkin: ^
07:57:59 <copumpkin> omg
07:58:09 <copumpkin> but roconnor has a pure haskell implementation of everything else!
07:58:22 <copumpkin> why would I want an RPC interface to the icky c++ client :)
07:58:28 <cheater> but is he self-bootstrapping?
07:58:29 <sipa> hey hey!
07:58:31 <copumpkin> kind of neat though
07:58:38 <copumpkin> sipa: no offense! it's
07:58:41 <copumpkin> (icky c++) client
07:58:45 <copumpkin> not icky (c++ client)
07:58:48 <sipa> oh, carry on
07:58:56 * copumpkin coughs
07:59:31 <xplat> silly english, making those two noun-noun modifications ambiguous
07:59:39 <copumpkin> :)
07:59:51 <copumpkin> omg he has no upper bounds on his versions
07:59:57 <copumpkin> but doesn't work with the latest versions of his dependencies
08:00:19 <quicksilver> copumpkin: curse him for not being able to see the future!
08:00:20 <sipa> we need a way to pronounce parenthesis in english
08:00:27 <copumpkin> certainly!
08:02:22 <wereHamster> I have a Data.ByteString.Lazy.ByteString. How do I add a string to it? THe pack function doesn't work because it can't pack Chars into a Word8 ByteString
08:02:30 <xplat> one is pronounced ihkeeseepluhsspluhss CLIYent, the other is IHKee seeplussPLUHSS Cliyent
08:03:15 <sipa> i suggest increasing voice pitch by 200 cents at every (, and going down at ) again
08:03:23 <xplat> you wouldn't confuse them at all over those headset chat things
08:03:42 <quicksilver> 200 cents = the unit of pitch your voice raises if you put on a pair of $2 trousers
08:03:50 <xplat> even in english
08:04:20 <ClaudiusMaximus> wereHamster: which character encoding do you want your ByteString to be in?  (maybe you'd prefer to use Text)
08:04:21 <xplat> quicksilver: isn't that too much of a pitch change to do twice without professional-quality voice training?
08:04:45 <wereHamster> ClaudiusMaximus: basically, I have a binary data in the ByteString, and need to prepend a ascii header
08:04:47 <sipa> this will become a problem: http://xkcd.com/859/
08:05:45 <hpaste> cpp__ pasted “Dont know what's wrong” at http://hpaste.org/55509
08:06:10 <ClaudiusMaximus> wereHamster: ah, then Char -> Word8 is   fromIntegral . ord   or similar  (you could add bounds checking in between)
08:07:22 <cpp__> Hello everyone!
08:07:39 <cpp__> Is someone willing to help a beginner?
08:07:58 <cheater> hey cpp__ what's the Q?
08:08:06 <cpp__> this: http://hpaste.org/55509
08:08:21 <cpp__> why does it give me a parse error? :s
08:08:27 <saati> cpp__: you need ()
08:08:31 <saati> (x:xs)
08:08:39 <cpp__> oh right
08:08:53 <cpp__> ok sorry for wasting your time
08:09:17 <cheater> haha why would you think that
08:09:18 <cpp__> thanks saati
08:09:28 <saati> cpp__: ghc's parse errors are kinda uninformative
08:09:38 <cpp__> saati: yeah...
08:12:26 <statusfailed> cpp__: syntax highlighting helps though :)
08:12:59 <cpp__> statusfailed: do you know what editor i should use?
08:13:21 <Phlogistique> cpp__: what do you use?
08:13:25 <dschoepe> cpp__: Emacs and vim are the most popular choices around here, I guess.
08:13:38 <cpp__> i suck at them
08:13:46 <hpc> if you're on windows, notepad++ is good
08:13:58 <cpp__> I'm on mac
08:14:15 <statusfailed> cpp__: I use vim, in fact I mentioned that because I did the exact same thing as you yesterday and syntax highlighting made me spot it :)
08:15:12 <dschoepe> there's also EclipseFP if you're into big, monstrous java software.
08:15:26 <statusfailed> Could try Yi? :D
08:15:28 <statusfailed> http://www.haskell.org/haskellwiki/Yi
08:15:37 <Phlogistique> Does anyone use Yi?
08:15:42 <xplat> yi is not for the faint of heart, currently
08:15:44 <statusfailed> no idea
08:15:57 <Phlogistique> I tried some time ago but yeah, it had some... problems I guess
08:15:57 <statusfailed> why is it not for the faint of heart?
08:16:05 <xplat> unless you already use xmonad
08:16:09 <statusfailed> (yep)
08:16:22 <Phlogistique> I don't remember which problems but it didn't work and it was a bug, I think
08:16:54 <xplat> i got a version that worked, basically, but i didn't get enough into it to find out how buggy it might be
08:17:12 <xplat> that was a while ago though
08:17:20 <statusfailed> Why is "Y I" the most recursive acronym?
08:17:57 <hpc> :t fix id
08:17:58 <lambdabot>     Ambiguous occurrence `id'
08:17:58 <lambdabot>     It could refer to either `L.id', defined at <local>:3:0
08:17:59 <lambdabot>                           or `Data.Function.id', imported from Data.Function at State/L.hs:30:0-37
08:17:59 <cpp__> ststusfailed: Isnt vim hard to use?
08:18:04 <hpc> @undefine
08:18:06 <Botje> well, Y is the fixpoint combinator and I is id
08:18:06 <hpc> :t fix id
08:18:07 <lambdabot> forall a. a
08:18:32 <statusfailed> cpp__: I suppose a little at first?
08:18:46 <Phlogistique> cpp__: no, but you have to give it one hour to learn the basics, and then it will take some days getting used to it
08:18:55 <cpp__> ststusfailed: hmmm i'll try it out
08:19:02 <statusfailed> woohoo, a new convert~
08:19:14 <cpp__> ststusfailed: lol
08:19:19 <Phlogistique> cpp__: in vim, first thing you should do is typing :vimtutor
08:19:22 <Botje> it took me ten years to learn vim
08:19:23 <Eduard_Munteanu> If it's anything like xmonad then I guess it could seem difficult to configure for newcomers.
08:19:35 <Botje> off and on, mind you.
08:19:38 <statusfailed> You'll get your "church of vi" robes in the mail~
08:19:39 <hpc> Botje: to learn enough to use it, or to "learn" it?
08:19:46 <hpc> Botje: it took me about 3 days
08:19:51 <cpp__> Phlogistique: Thanks for the advice :)
08:19:53 <hpc> using the former definition
08:20:03 <roconnor> @type maybe
08:20:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:20:10 <Botje> it took me three to realize insert mode isn't all that
08:20:11 <roconnor> @type fromMaybe
08:20:11 <lambdabot> forall a. a -> Maybe a -> a
08:20:30 * Eduard_Munteanu should try Yi sometime, but he heard its vim mode isn't great at all
08:21:35 <Phlogistique> I recently read stuff by Steve Yegge about Emacs and software platforms, and it kinda led me to the conclusion that a good software platform should use a dynamic language rather than a static one
08:21:50 <Phlogistique> but on the other hand I'm really unable to handle Emacs
08:22:15 <Phlogistique> (should use a dynamic language for its configuration and customizations)
08:33:17 <parcs`> who cares what steve yegge thnks
08:33:55 <quicksilver> it's not a question of caring what a particular person thinks; it's a question of reading his actual arguments and seeing if you agree
08:34:22 <quicksilver> I think it's quite difficult to using a static language for a software platform in the emacs sense but I don't think it's impossible.
08:34:34 <quicksilver> it is somewhat untrodden ground.
08:35:04 <carpi> when i use the prelude readFile do i have to explicitly close the file once i finish reading?
08:35:17 <mux> :t readFile
08:35:18 <hpc> :t readFile
08:35:18 <lambdabot> FilePath -> IO String
08:35:19 <lambdabot> FilePath -> IO String
08:35:21 <hpc> no
08:35:25 <mux> what could you close?
08:35:31 <dolio> What's a dynamic language?
08:35:32 <mux> no handle there
08:35:35 <dolio> And a static language?
08:35:40 <krakrjak> ["pi"|x <- [3.01,3.02..4], x == 3.14]
08:36:00 <afarmer> so is it just me or is the newest version of the platform (2011.4.0.0) not linked on the mac osx platform download page?
08:36:20 <carpi> mux: you have  apoint.. should have been obvious to me that checking the type of readFile would give me the answer i seek.. still trying to get myself into that haskel mindset
08:37:12 <cygnus> afarmer: works for me at http://hackage.haskell.org/platform/mac.html
08:38:12 <afarmer> oh weird
08:38:22 <afarmer> cleared my browser cache and it worked
08:38:29 <afarmer> how annoying
08:38:50 <cygnus> :(
08:38:55 <Dodek> hey, do you think it makes sense to use Text.ParserCombinators.Parsec.Expr to parse expressions involving function calls? it seems to be well suited for mathematical expression, but i don't see an easy way to use it to support (c-style) function calls
08:38:57 <afarmer> apparently mashing refresh 10 times wasn't enough
08:39:03 <mux> carpi: beware though, readFile is lazy-I/O, meaning that if you don't read the file to the end, you'd still leave an open file around
08:39:14 <parcs`> quicksilver: i agree. i apologize for my silly comment
08:39:15 <cygnus> afarmer: yeah, apparently you wanted the "really refresh, I mean it this time" key
08:39:22 <hpc> Dodek: i think it follows parsing rules for haskell
08:39:44 <Dodek> hpc: Parsec.Expr lets you use your own operator table
08:40:08 <xplat> sometimes holding down shift while you hit refresh does the 'really refresh, honest' thing
08:40:19 <hpc> or ctrl
08:40:25 <mellum> I want to convert a Word64->Word64->Word64 function to Int->Int->Int. Is there something better than f k1 k2 = fromInteger . toInteger $ f64 (fromInteger (toInteger k1)) (fromInteger (toInteger k2))
08:40:49 <carpi> mux: thanks for the heads up. But if i wanted a non-lazy readFile, do I have any other options? Not that i need something like that right now.. but just curous
08:40:54 <afarmer> cygnus: exactly
08:40:55 <rwbarton> @src fromIntegral
08:40:55 <lambdabot> fromIntegral = fromInteger . toInteger
08:41:00 <rwbarton> mellum: ^
08:41:21 <rwbarton> other than that, not really
08:41:24 <hpc> mux: f k1 k2 = fromIntegral $ blah k1' k2' where k1' = fromIntegral k1; ...
08:41:26 <mux> carpi: you could "strictify" readFile by adding something like "evaluate (length output)"
08:41:43 <mux> carpi: a commonly used trick
08:41:47 <carpi> evaluate?
08:41:50 <carpi> is a function?
08:41:54 <mux> :t evaluate
08:41:55 <lambdabot> Not in scope: `evaluate'
08:41:55 <mellum> okay, thanks
08:41:58 <mux> dang
08:41:58 <hpc> mux: readFile is already strict; it reads the whole file
08:42:07 <hpc> i believe
08:42:18 <mux> hpc: AFAIK it's lazy I/O
08:42:29 <mux> yup, I confirm that
08:42:30 <xplat> isn't that getContents?
08:42:38 <mux> The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents.
08:42:39 <rwbarton> getContents is for stdin
08:42:50 <hpc> oh, that it does
08:42:51 <xplat> ah, brain fart
08:42:51 <mux> (from the Prelude documentation)
08:43:02 <hpc> hGetContents
08:43:26 <xplat> right, that's what i was thinking of, hGetContents
08:43:26 <mux> did I dream that evaluate thingy though?
08:43:32 <mux> I can't seem to find it anymore.
08:43:37 <dolio> hGetContents is for Handles.
08:43:37 <rwbarton> it's in Control.Exception
08:43:47 <mux> ah, thanks
08:43:52 <mux> :t Control.Exception.evaluate
08:43:53 <lambdabot> forall a. a -> IO a
08:44:07 <mux> carpi: so, a commonly used trick is to do it like this:
08:44:14 <mux> output <- readFile path
08:44:18 <mux> evaluate (length output)
08:44:19 <mux> ...
08:45:04 <mux> carpi: does that make sense to you?
08:45:41 <parcs`> @src Category
08:45:41 <lambdabot> Source not found. Take a stress pill and think things over.
08:45:43 <carpi> do we have to import something for 'evaluate'? ghci gives errot when i :t evaluate
08:46:20 <mux> carpi: read what was said just above :-P
08:46:39 <xplat> i want a @src that gets the source from the same place eval gets the functions :(
08:46:47 <carpi> shite.. my apologeis
08:46:50 <xplat> (and other values)
08:47:04 <carpi> i think i was reading too fast and skipping lines
08:47:08 <xplat> i wonder how hard that would be
08:48:09 <carpi> ah.. so its like a return..
08:48:38 <mux> to be honest I avoid lazy I/O like the plague myself
08:48:41 <mux> I really don't like it
08:48:57 <mux> it pretends to be cool but then it comes back to bite you in the ass when you don't expect it
08:49:43 <rwbarton> Just learn to expect when it will bite you in the ass.
08:49:54 <carpi> i really would like to see an example of that.. have seen a few examples of why lazy is cool.. . Gogole shold help
08:50:01 <mux> rwbarton: I like iteratees better
08:50:28 <mux> 100% with Oleg on that one
08:55:46 <hpaste> sal23 pasted “Storable instance for (len,Ptr CChar) doesn't retrieve length correctly” at http://hpaste.org/55510
08:56:38 <sal23> will appreciate help with peek of length in above storable instance
08:57:02 <mux> there is no existing Storable instance for CStringLen ?
08:57:37 <rwbarton> @hoogle plusPtr
08:57:37 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
08:57:48 <rwbarton> sal23: don't you want to plusPtr by 4 on line 22?
08:58:00 <rwbarton> and on line 30
08:58:29 <sal23> rwbarton, let me check again
08:58:46 <mux> also, in theory, Int32 might not be enough to store the length
08:58:47 <rwbarton> the second argument to plusPtr is always in bytes
08:59:16 <sal23> rwbarton, do'h…I should have known that. problem solved
08:59:19 <mux> CSize would have been more appropriate (size_t)
08:59:31 <Gwern-away> > 0.8 * 7
08:59:32 <lambdabot>   5.6000000000000005
08:59:40 <sal23> mux, haskell has size_t thing?
09:00:07 <mux> haskell has CSize, and it already has CStringLen
09:00:12 <mux> which is the same time you're reimplementing
09:00:17 <mux> s/time/type/
09:00:23 <sal23> mux, right
09:00:38 <mux> :t peekCStringLen
09:00:39 <lambdabot> Not in scope: `peekCStringLen'
09:00:53 <mux> :t Foreign.C.String.peekCStringLen
09:00:54 <lambdabot> Foreign.C.String.CStringLen -> IO String
09:01:19 <mux> lots of useful stuff in Foreign.C.String
09:01:34 <sal23> mux, right, but I can calculate the length while copying it from C FFI to Vector storable instance
09:01:50 <sal23> it is very useful in other cases
09:02:40 <ClaudiusMaximus> hmm, doesn't Storable require sizeOf to be constant?
09:03:33 <ClaudiusMaximus> oh wait, ignore me - just saw the code
09:03:36 <sal23> :)
09:05:08 <snetz> exit
09:05:13 <snetz> sry
09:11:06 <tarrasch> Hello, I've been having trouble using the -werror together with installing cabal packages. Cabal tends to create an automatic setup file with exact contents "import Distribution.Simple; main = defaultMain". This is bad, as I get werror since toplevel `main` lacks function signature. I can't be the first encountering this annoyance?
09:17:09 <hpaste> Carpi pasted “First useful App” at http://hpaste.org/55512
09:17:10 <carpi> could the haskell guru's please give me some comments on how I can improve that code ^^? been working on it for the past 3 days. tis my first program in haskell that does soemthing useful. I know some of you could code that in 30 minutes. Its nothing interesting.. i just did it as an exercise to learn how to use haskell practically.. any comments would be useful. Thanks
09:20:53 <carpi> it works.. but its awfully finicky.. no erro checking .. nothing. it will crash if the arguments on the cmd line are not as it expects
09:21:00 <Peaker> carpi: you don't have to apologize about the code or how long it took :)
09:21:23 <mux> I think it took me a loooot longer than 3 days to write my first useful haskell program, if that can make you feel better
09:21:34 <Peaker> carpi: for readability/extensibility, I'd replace   doTheAction :: Mode -> String -> String -> Poptions -> String -> String -> IO ()     with a record arg
09:21:45 <Peaker> carpi: you can use a single large "let" instead of many small ones
09:22:07 <carpi> thanks for the encouragmet. - )
09:22:14 * hackagebot smtLib 1.0.2 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.0.2 (IavorDiatchki)
09:22:14 <carpi> Peaker: you mean with using ';'?
09:22:36 <Peaker> carpi: no, just indent stuff to the same alignment:  let x = 1 \n     y = 2
09:23:01 <Peaker> carpi: the single-letter-named args all over the place sound like they could also be a record with informative names, instead
09:23:15 <Peaker> carpi: i.e: have a record for "m p v d"
09:23:36 <Peaker> bbl
09:23:42 <carpi> a record? by record.. you mean a new data type?
09:25:10 <tarrasch> carpi, it's good to use `error` to begin with, but one should in the long term prefer uncrashable code where possible, that is that it only `Maybe` returns a value.
09:25:35 <tarrasch> carpi, "haskell record syntax" is the keyword
09:26:53 <carpi> im aware of record syntax.. but doesn't that mean having to create a new data type and then creating a potential value for that data type and then populating that value with records.. but i thought for passing parameters.. isn't that a little overkill.. unless i am misunderstanding something..
09:29:19 <jessopher> if the parameters are common amongst many functions, thats exactly when you start making new data types (and when they are many, use records)
09:32:04 <tromp> @hoogle nubBy
09:32:04 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
09:32:29 <carpi> thanks.. illkeep that in mind _ )
09:33:40 <jessopher> combine and conquer!
09:34:26 <tromp> :t on
09:34:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:34:54 <tromp> :t uncurry
09:34:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:35:16 <tromp> @hoogle on
09:35:16 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:35:17 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
09:35:18 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
09:38:28 <jessopher> > on (+) pred 10 15
09:38:29 <lambdabot>   23
09:40:33 <dgpratt> hmm...hlint complains of a syntax error in code that compiles and works fine (no lang extensions)
09:40:57 <dgpratt> it seems to imagine a ";" that isn't there
10:09:50 <islam> nour
10:10:59 <kuznero> Houdy all!
10:13:10 <hpaste> “Yesod Book” pasted “mkYesod "HelloWorld" [parseRoutes|...” at http://hpaste.org/55513
10:13:26 <kuznero> Hope somebody could help.... I'm trying to follow Yesod online book. And get stuck rather fast. Problem is with this code... http://hpaste.org/55513
10:13:43 <kuznero> I didn't know hpaste.org is integrated into the channel :)
10:13:47 <kuznero> Cool
10:14:21 <kuznero> Can anyway explain please how "|" pipe is handled in this case - what is it?
10:14:40 <kuznero> And then line number 8 also drives me crazy... ")
10:14:47 <kuznero> :(
10:15:25 <rwbarton> [foo|...|] is the quasiquoter syntax
10:15:35 <rwbarton> it will expand to some haskell code
10:16:03 <kuznero> I see. so, it's introduce as a function (I guess) in Yesod... somewhere...
10:16:08 <kuznero> But it does not compile
10:16:22 <kuznero> with this: src/Main.hs:9:1: parse error (possibly incorrect indentation)
10:16:29 <rwbarton> "foo" is supposed to be a symbol that is in scope
10:16:30 <rwbarton> oh
10:16:54 <rwbarton> perhaps lines 8 and 9 need to be indented
10:17:05 <kuznero> Tried that already
10:17:10 <maloi> kuznero: there is also #yesod
10:17:13 <kuznero> Then it complains on '/'
10:17:20 <rwbarton> what ghc version?
10:17:23 <kuznero> will go there shortly :)
10:17:27 <kuznero> 7.0.3
10:18:08 <roconnor> are there langauges where assigning to a null pointer does nothing rather than crashing?
10:18:42 <drull95> why would you want to assign to a null pointer?
10:19:26 <monochrom> yesod uses very advanced haskell not covered in usual haskell tutorials. in fact not just advanced, but also not officially standardized (but still de facto)
10:19:29 <roconnor> drull95: cause you don't want to test for null
10:19:43 <hpc> > let Nothing = Nothing in text "roconnor: yes"
10:19:44 <lambdabot>   roconnor: yes
10:20:05 <Botje> roconnor: mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS, -1, 0) ? :)
10:20:12 <kuznero> monochrom, hm... but even though that is the case, it should at least compile, right? :)
10:20:26 * roconnor is developing a partial lens library
10:20:34 <monochrom> in the face of these advanced and not usually taught constructs, your options are learn them properly or copy from recipes
10:21:12 <monochrom> well, if you don't already know how to write the constructs, I see no hope in expectating anything to compile.
10:21:38 <drull95> wouldn't you end up having to check for null at some point anyway to determine nothing was done?
10:21:55 <roconnor> drull95: maybe; or maybe you don't care
10:21:58 <c_wraith> roconnor: doesn't fclabels have support for partial lenses?
10:22:11 <roconnor> c_wraith: I don't know, but soon data-lens will
10:22:18 <rwbarton> roconnor: (maybe you know this already but) objective C treats a method call on null as a no-op
10:22:23 <rwbarton> which is sort of similar
10:22:29 <kuznero> monochrom, nice... I'm not guru in Haskell, but I know basics... That was basically copy-paste from online Yesod book... But anyway - asking #yesod folds...
10:22:31 <rwbarton> Or, so I hear anyways.
10:22:46 <kuznero> folks*
10:23:50 <drull95> heh, i was sitting here thinking "what? asking #yesod folds into what?"
10:24:05 <kuznero> :)
10:24:13 <kuznero> folks
10:24:14 <kuznero> :)
10:24:32 <ziman> :t foldM
10:24:32 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:25:38 <hpc> :t foldr `asTypeOf` foldM
10:25:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
10:25:39 <lambdabot>       Expected type: m a
10:25:39 <lambdabot>       Inferred type: a
10:27:58 <drull95> roconnor, is not checking for null a performance thing, or an api design thing? i'm guessing the latter
10:28:25 <drull95> if it's the later you could probably use some really evil macro stuff to make it happen
10:30:02 <roconnor> drull95: api thing
10:30:26 <rwbarton> Botje: BTW, by default you can't actually map a page at address 0 on most Linux OSes.
10:30:27 <roconnor> drull95: if it make you feel better in my design if you check the return value of the assignment you can tell if it succeed or not.
10:30:44 <roconnor> (~=) :: Monad m => PartialLens a b -> b -> StateT a m (Maybe b)
10:30:53 <roconnor> (%=) :: Monad m => PartialLens a b -> (b -> b) -> StateT a m (Maybe b)
10:31:11 <drull95> yeah i'm starting to think of ways it might be useful. just had to overcome that status quo thinking :)
10:31:20 <roconnor> drull95: me too
10:31:32 <roconnor> drull95: it seems so unusual from the traditional point of view
10:31:41 <roconnor> drull95: but it really feels natural to implement this
10:32:00 <Botje> rwbarton: that's fairly recent.
10:32:18 <rwbarton> yes
10:33:15 <Clint> what abstraction opportunities am i missing here?
10:33:16 <hpaste> Clint pasted “calendar drawing” at http://hpaste.org/55515
10:33:23 <ziman> since the vsplice exploit?
10:33:24 <Peaker> carpi: a few more suggestions, use FilePath when your String is a filename
10:33:55 <Peaker> carpi: instead of a sequence of lets, use a pipeline with (.)'s
10:34:25 <drull95> i'm assuming c here, but expanding id |= assign to id == 0 ? : id = assign; might work. i'll try it out. it'll need a custom preprocessor but it wouldn't be hard to write
10:35:16 <Peaker> carpi: getArg should take a tuple or 4 args, not a list of specific length
10:35:24 <Peaker> carpi: if you compile with -Wall you'll get complaints about many of these things
10:35:35 <Peaker> carpi: so add {-# OPTIONS -Wall #-} on top
10:38:28 <Botje> ziman: exactly
10:39:06 <alistra> and don't add -Wall to the header of alex or happy files
10:39:20 <alistra> it's a war out there
10:39:48 <Botje> Clint: the before ++ renderFoo ++ after construct is a viable target
10:39:58 <Botje> but you don't stand to gain much from that
10:40:04 <frerich_> I'm currently trying to figure out what 'Arrows' really are. I recently started to like the '&&&' function, which is apparently closely related to arrows. But to me, it seems that '&&&' is always only used like '\f g x -> (f x, g x)', i.e. I see that something like '\x -> (head x, sum x)' can be rewritten to 'head &&& sum'. Are there things which are 'arrows', but not functions?
10:40:47 <byorgey> frerich_: yes, but they have more specialized applications.
10:41:00 <Botje> concat (map atString x) can be written as concatMap atString x
10:41:04 <xplat> :t (Kliesli putStrLn &&& Kliesli readFile)
10:41:05 <lambdabot> Not in scope: data constructor `Kliesli'
10:41:05 <lambdabot> Not in scope: data constructor `Kliesli'
10:41:23 <xplat> er.  something like that
10:41:55 <alpounet> @type Kleisli
10:41:56 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
10:42:00 <Botje> Clint: and the other concat (map ...) pair can also be shortened to concatMap
10:42:18 <Botje> Clint: and you could be fancy and use >>=
10:42:21 <byorgey> frerich_: see e.g. http://hackage.haskell.org/package/hxt, or http://hackage.haskell.org/package/netwire
10:42:28 <alpounet> :t Kleisli putStrLn &&& Kleisli readFile
10:42:29 <lambdabot> Kleisli IO String ((), String)
10:43:16 <Botje> chunk 7 [1..(lastday + start)] >>= \x -> beforeChunkHtml ++ renderChunk x ++ afterChunkHtml
10:43:34 <xplat> :t (Kleisli putStrLn &&& Kleisli readFile)
10:43:35 <lambdabot> Kleisli IO String ((), String)
10:43:44 <byorgey> frerich_: you could try reading http://www.soi.city.ac.uk/~ross/papers/fop.html
10:44:05 <Clint> Botje: you mean by passing an output-type value to the before/render/after functions?
10:44:34 <Botje> Clint: something like around before after str = before ++ str ++ after
10:44:41 <xplat> :t runKleisli (Kleisli putStrLn &&& Kleisli readFile)
10:44:42 <lambdabot> String -> IO ((), String)
10:44:58 <frerich_> byorgey: Ah! That second link looks interesting. The first sentence is already making me curious - what could be 'function-like' in that it takes input and produced output, but is not a function. I'll read that :-)
10:45:04 <frerich_> byorgey: Thanks for the pointer!
10:45:11 <Botje> Clint: and then you can write around beforeChunkHtml afterChunkHtml . concatMap atStringHtml
10:46:26 <Botje> Clint: but that's about all I can think of abstracting
10:46:27 <Clint> Botje: ah, hmm
10:46:28 <Clint> thanks
10:51:47 <carpi> Peaker: i made some changes you mentioned.. but.. what do you mean by pipeline?
10:54:05 <Sgeo> Is there an a -> IO () or an a -> IO () -> IO () that I can use to observe garbage collection?
10:54:07 <msieradzki> if I have haskell program that uses let's say Data.HashMap.Strict what do I have to do to see its functions in profiling dump? Is ghc -auto-all -prof enough assuming I have all -prof packages installed?
10:54:27 <Sgeo> Wait, not a -> IO (). a -> IO Bool, I guess
10:58:34 <hpaste> Clint annotated “calendar drawing” with “calendar drawing (annotation)” at http://hpaste.org/55515#a55518
11:03:05 <carpi> wall is awesome.. it shows my mistakes )
11:03:24 <hpc> @quote wall
11:03:24 <lambdabot> emu says: design patterns are what you choose for wallpaper and carpets
11:03:37 <Botje> heh heh
11:03:56 <carpi> i meant the -wall option in ghc - )
11:05:53 <ion> As opposed to -Wall?
11:06:09 <monochrom> your program can't observe garbage collection. it can force garbage collection. System.Mem.performGC
11:06:39 <Goosey_> I'm halfway through LYAH
11:06:51 <monochrom> that is fast
11:07:16 <carpi> oh osorry . i meant -Wall.. not -wall. seems like some options are caps and some not..  i wonder if there is some reason for that
11:08:04 <monochrom> as many reasons as some German words are caps and some not
11:08:14 <saml> https://github.com/mailrank/  what happened to this?
11:08:43 <periodic> saml: It was bought by FB?
11:09:15 <saml> so they got rid of all useful libraries making haskell not useful as before
11:09:52 <monochrom> the page has a link to http://engineering.mailrank.com/ and I follow that and it seems informative
11:10:23 <saml> oh they are moved to bos
11:10:25 <periodic> It's more useful now!  Because now you don't have to get depressed that it was already written.  Now you can implement your own, and obviously superior solution!
11:10:36 <periodic> It gets me so sad that everything cool has already been written. :P
11:10:40 <periodic> cool and easy at least...
11:12:34 <Philonous> periodic:  I think it's the hallmark of an ingenious implementation. Everyone says "Oh, but that's so obvious, I could have come up with that" afterwards
11:15:55 <Goosey_> Lol, LYAH is barely teaching me about map, but I've already implemented it with foldr :D
11:19:35 <Peaker> carpi: something like  f . g . h
11:19:50 <Goosey_> @src filter
11:19:50 <lambdabot> filter _ []     = []
11:19:50 <lambdabot> filter p (x:xs)
11:19:50 <lambdabot>     | p x       = x : filter p xs
11:19:50 <lambdabot>     | otherwise = filter p xs
11:19:58 <Peaker> carpi: is a pipeline, instead of let x = h i ; y = g x ; z = f y ...
11:21:08 <carpi> f.g.h loks like a fucntion composition..
11:21:19 <carpi> how can i do assignments in functions compositiosn/
11:21:30 <Botje> you can't do assignments in haskell anyway
11:22:02 <saml> let a = 1
11:22:02 <byorgey> Goosey_: nice =)
11:22:03 <monochrom> see my http://www.vex.net/~trebla/weblog/pointfree.html for pipeline
11:22:08 <carpi> by assignments .. i meant the 'fake' let constructs
11:22:25 <Peaker> carpi: function composition is a sort of pipeline
11:22:38 <rwbarton> carpi: I suspect if you think about what your question is, you'll realize you don't have one
11:23:32 <Peaker> carpi: you have a bunch of "let" lines one after another that could be much more readable as a big func. composition/pipeline
11:25:11 <carpi> if i have a func. composition.. how can i get the values into the individual names?
11:25:25 <carpi> monochrom: thanks for the link.. )
11:25:30 <monochrom> before how, first why?
11:26:34 <monochrom> for example in my example length . nub . sort . filter (isPrefixOf "X-Spam-Level"), there is no individual name, and there is no need for individual name. so, I don't know how, but I know why not.
11:27:27 <EvanR-work> variables make stuff harder to read
11:27:34 <EvanR-work> sometimes
11:28:07 <carpi> sry.. if i sound terribly ignorant.. but all along.. i've thought of function composition as a way to chain function application..not getting values into names..
11:28:13 <monochrom> you also have the option of writing (\x -> length (nub (sort (filter (isPrefixOf "X-Spam-Level") x)))), of course
11:28:20 <carpi> monochrom: but in your contruct the entire expression returns one value
11:28:27 <carpi> but i need retunred 5
11:28:49 <shachaf> (\x -> (length . nub . sort . filter ("X-Spam-Level" `isPrefixOf`) x)
11:29:51 <carpi> Peaker: either way.. i've managed to remove those ugly lets and replaced them with a succinct 5-tuple like you suggested.. but somehow i feel like its still looks ugly and hackish
11:29:51 <monochrom> the way I see it, length . nub . sort . filter (isPrefixOf "X-Spam-Level") is to eliminate a name so I cannot enjoy worrying about it, and (\x -> length (nub (sort (filter (isPrefixOf "X-Spam-Level") x)))) is to invent a name so I can enjoy worrying about it.
11:32:20 <monochrom> I understand that some people enjoy worrying about more things. it explains why they don't let you write foldr (\x ys -> blah), they make you define g x y = blah first, and after that they let you write foldr g. they want to you create one more name, g, so you can worry about it.
11:33:00 <monochrom> It also explains why they don't like you to write v = x + y*z, they want you to define tmp = y*z first.
11:34:35 <monochrom> except they don't say the last one in such plain sight. they obfuscate its meaning by OO notation. thus, they don't like you to write o.m(b.n()), they want you to define tmp = b.n() first, then they allow you to write o.m(tmp)
11:37:41 <byorgey> carpi: you mean you want to obtain the result from each stage of the pipeline, and also pass along the result to the next stage?
11:38:05 <carpi> byorgey: is that possible?
11:38:26 <byorgey> well, yes, but not using function composition.
11:38:34 <byorgey> carpi: I'm curious, why do you want that?
11:39:06 <carpi> if not function composition..then its possible using >>=? yea?
11:39:39 <byorgey> well... if the intermediate results are all the same type, you could use the Writer monad
11:39:53 <aristid> :t let (.:.) f g x = let y = g x in (y, f y) in (.:.)
11:39:54 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> (t, t1)
11:40:13 <aristid> :t (.)
11:40:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:40:21 <aristid> :t (Prelude..)
11:40:21 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:40:38 <byorgey> aristid: yes, but you can't chain things using .:.
11:40:47 <sefb1704> hi byorgey ;)
11:40:53 <byorgey> hi sefb1704
11:41:00 <ben> fuck, i just said monad instead of nomad in casual conversation
11:41:22 <aristid> byorgey: i guess you can't
11:41:25 <HaskellElephant> ben: happens to me all the time...
11:41:33 <byorgey> ben: hahaha
11:41:48 <byorgey> did they look at you funny? or did they not notice?
11:41:58 <Waldteufel> just like the professors talking about processors ^^
11:42:00 <aristid> i say nomad even rarer in casual conversation, than monad
11:43:35 <sefb1704> import Random, if ((randomRIO(0,10) == 1) then .. error: Ambigous type variable t in the contraints: Random t arising from use of randomRIO
11:43:38 <sefb1704> :(
11:44:44 <rwbarton> randomRIO (0,10) is an IO action
11:45:10 <rwbarton> have you read an introduction to IO?
11:45:33 <sefb1704> y a  short one somewhere in the internet
11:45:51 <Botje> sefb1704: you cannot use IO actions all over the place.
11:45:57 <sefb1704> should i just google or do you want to explain it to me?
11:46:42 <sefb1704> the result type of the function i use it is IO .. should this be ok then? anyway commenting out the type of the function doesnt help
11:47:30 <ricree> sefb1704, it would be best if you read up on it a bit more, but in short, you need to pull the value out of the io action to use it where you'd use a normal number
11:48:07 <ricree> so something like "do {num <- randomIO (0,10); return (num==1)}"
11:48:09 <sefb1704> ah okey, thanks
11:48:25 <ricree> there's other ways to go about it, but that's probably the most intuitive to someone used to imperative languages
11:48:29 <carpi> randomRIO is in an IO context.. any values produced in that context must be safely brought into the 'pure' realm. you simply can't do randomRIO (0,10) == 1. I think thats how it works .. but i could be wrong
11:48:57 <rwbarton> probably that will be more confusing to understand than an IO tutorial.
11:49:36 <shachaf> carpi: randioRIO (0,10) isn't an "impure" number.
11:49:46 <shachaf> carpi: It's not a number at all.
11:49:54 <shachaf> It's completely different from a number.
11:50:08 * shachaf "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
11:50:10 <sefb1704> shachaf: do you know how to use it?
11:50:26 <shachaf> Oh, I thought carpi was the one asking the question.
11:50:29 * shachaf context-free.
11:50:37 <shachaf> sefb1704: Read an introduction to IO in Haskell.
11:50:38 <ricree> yeah, sefb1704 , I would definitely take rwbarton's advice and read over an IO tutorial again.  It makes sense when you get used to it, but it's  a bit different
11:50:44 <acowley> I like RandT from the MonadRandom package for dealing with a computational context that can produce random numbers.
11:51:00 <shachaf> @google introduction to io haskell
11:51:01 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
11:51:01 <lambdabot> Title: Introduction to IO - HaskellWiki
11:51:26 <sefb1704> okey thanks
11:51:39 <rwbarton> acowley: yes but I think it's safe to assume that if someone does not yet know how to use randomRIO, then MonadRandom will not help them.
11:51:55 <ricree> that said, sefb1704, like I said, what you're probably looking to do is to pull the number from the io action, which in do notation looks like "num<- randomRIO (0,10)"
11:52:01 <acowley> rwbarton: you are right
11:52:24 <shachaf> "pull the number from the io action" :-(
11:52:29 <acowley> rwbarton: I was just thinking that we could avoid the IO part of the discussion a bit by dealing with StdGens, but then that gets clumsy and RandT comes in to help
11:52:40 <shachaf> That's like saying "pull the list of files from /bin/ls".
11:52:41 <ricree> shachaf, yeah, sorry.
11:52:58 <acowley> I don't think that wording is *that* bad
11:53:37 <shachaf> acowley: Which, the one about ls?
11:53:54 <Sgeo> @hoogle (Eq a) => [(a,a)] -> [a] -> [a]
11:53:55 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
11:53:55 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
11:53:55 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
11:53:56 <rwbarton> the funny thing is that if you do think of IO a as "an IO-branded a" then almost everything does work and you can write some imperative programs as you do in other languages
11:54:02 <acowley> the "pull the number from the io action" phrasing
11:54:13 <shachaf> rwbarton: Well, sort of.
11:54:33 <shachaf> rwbarton: It makes things like replicateM_ 5 (...) and so on kind of weird.
11:54:38 <rwbarton> it is easy to imagine that an "IO a" really is an a and the monad stuff is there just to mark "impure functions" in the type system
11:54:46 <shachaf> rwbarton: Especially things like IO (IO a), as kmc points out.
11:54:51 <rwbarton> shachaf: yes, that is the sort of thing that doesn't work so well.
11:55:08 <Sgeo> @hoogle IO (IO a)
11:55:08 <lambdabot> System.Exit exitFailure :: IO a
11:55:09 <lambdabot> System.Exit exitSuccess :: IO a
11:55:09 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
11:55:57 <rwbarton> shachaf: but forM_ is fine, sort of, and you can write your programs in terms of that.
11:56:22 <shachaf> rwbarton: It's fine if you don't look at it too closely.
11:56:27 <rwbarton> right.
11:56:37 <shachaf> This is still a terrible way to think about things, though. :-)
11:58:09 <rwbarton> yes, of course.
11:58:19 <drull95> "rekonq does not know how to handle this protocol: http"
11:58:23 <drull95> ummm, ok?
11:58:44 <Saizan> you could say that f : IO a is like f : () -> a in an imperative language, except that instead of g(f()) you have g =<< f, though that's also fragile
11:59:25 <Gwern-away> > 300 * 3.5
11:59:26 <lambdabot>   1050.0
11:59:27 <Saizan> s/g(f())/g(f())()/
11:59:40 <Sgeo> (++".mid") . reverse . drop 4 . reverse . map (\l -> if l == "_" then "." else l) $ f
11:59:46 <Sgeo> There has got to be a better way to write that :/
11:59:52 <hpaste> Carpi pasted “Let has been terminated” at http://hpaste.org/55520
11:59:52 <hpaste> drull95 pasted “hey, roconnor” at http://hpaste.org/55521
11:59:53 <carpi> Peaker: i've removed the lets and it seems okay^^^ but im not sure how to replace the 4 element list with a tuple.. because the getOpt functions returns the arguments as a list.... i don't think i should dwell on this chunk of code anymore unless you have any more sugesstions - ). I think i should work on a sudoku solver for my next step in attaining haskeldom
12:00:21 <shachaf> Saizan: It's somewhat less fragile, though.
12:00:31 <Sgeo> Awesome, didn't even typecheck
12:00:33 * Sgeo is a derp
12:00:42 <drull95> roconnor, it was more work than i expected, and still needs more work to be a complete solution
12:00:43 <carpi> however thanks for the suggesions so far )
12:00:56 <shachaf> Saizan: But it's only straying farther away from enlightenment. :-)
12:01:20 <rwbarton> what's so bad about that analogy?
12:01:27 <rwbarton> it seems like a good starting point at least
12:01:28 <roconnor> drull95: what does this do?
12:01:58 <Saizan> rwbarton: what i don't like much is that it kind of ties execution of side-effects with evaluation
12:02:13 <shachaf> rwbarton: It conflates execution of IO actions with function application/evaluation.
12:03:08 <drull95> if id is a dereference in id := assignment, it replaces it with a check for null, a no-op if it is null, and the assignment if it isn't
12:03:22 <drull95> otherwise it just replaces := with =
12:03:28 <drull95> minimally tested
12:03:34 <roconnor> oh god
12:03:47 <Saizan> maybe one could use another arrow to signify that it's another function space
12:03:50 <drull95> yeah, i just did it for a lark
12:03:55 <roconnor> :)
12:04:03 <shachaf> These are completely different things in Haskell, and trying to tie them together like that seems like a misguided attempt at generalization.
12:04:11 <Saizan> but at the point the script/recipe explanation is simpler, i think
12:04:15 <shachaf> Saizan: Why use an arrow at all, though? getLine doesn't take an argument.
12:04:48 <shachaf> Not only simpler, but also correct. :-)
12:05:09 * shachaf still likes data IO = Exit | PutChar Char IO | GetChar (Char -> IO) as an explanation of IO.
12:05:16 <Saizan> shachaf: because suspended execution is often done through procedures in other languages
12:05:54 <monochrom> also suspended evaluation. which adds to the muddle.
12:05:55 <shachaf> Saizan: OK, so use "IO a" to mean "a procedure that returns an a", and have all procedures take zero arguments.
12:06:06 <shachaf> Then pass arguments to the procedure the normal way. :-)
12:06:45 <dgpratt> so I completed my tiny little "fix encoding" program and it works just fine, but it's not very pretty
12:06:47 <Saizan> () -> a was my way of saying "procedure with zero arguments that returns an a" :P
12:07:13 <dgpratt> I wouldn't mind some suggestions on some incremental improvements
12:07:23 <hpaste> dgpratt pasted “fix-encoding” at http://hpaste.org/55522
12:07:34 <shachaf> An important point, I think, is that people often say "Haskell's type system prevents you from doing IO in a non-IO context", but really it has nothing to do with the type system.
12:07:37 <monochrom> f :: () -> Int in haskell is perfectly legit, good semantics, everything. just silly.
12:07:57 <rwbarton> a foo(void) { ... }
12:08:01 * roconnor likes it too
12:08:10 <shachaf> The same thing could be done in Ruby or whatever other language.
12:08:37 <pdxleif> Wouldn't a "procedure with zero arguments that returns an a" just be the value a?
12:08:49 <rwbarton> not in C
12:08:56 <shachaf> roconnor: Well you wrote that one article on r6.ca, right? :-)
12:08:57 <opqdonut> pdxleif: exactly
12:09:02 <roconnor> shachaf: yep :D
12:09:27 <Saizan> pdxleif, opqdonut: procedure here was meant in the imperative sense
12:09:54 <shachaf> I think a good way to introduce IO to a competent Haskell person who doesn't know how IO works is to say "invent half a dozen ways that one might do IO in Haskell while keeping it a pure language".
12:10:20 <monochrom> I think only 3 can be invented.
12:10:38 <shachaf> For example: main :: String (prints to stdout); main :: [Action], where data Action = Stdout String | Stderr String | Exit | Whatever; main :: String -> String; main :: [Response] -> [Request]; etc.
12:10:54 <monochrom> but yes try-reinventing is a good way to learn
12:10:57 <shachaf> They don't all have to do everything "IO" in actual Haskell does.
12:11:12 <Saizan> the problem is that most of the people trying to understand IO are not competent in haskell and/or FP
12:11:14 <pdxleif> In my Scala these days, putting everythign in a Future[a] (background thread reference that returns immediately), feels like I'm doing all my I/O in IO a, again.
12:11:29 <carpi> is there any reason to use an array from Prelude as opposed to a list?
12:11:33 <shachaf> The point is the concept of a pure value that doesn't do any IO combined with an interpreter that doesthe actual I/O.
12:11:44 <shachaf> carpi: I don't think the Prelude has arrays.
12:12:03 <monochrom> use array for random access. use list for sequential
12:12:03 <carpi> shachaf: but when i do 'import Array' in ghci.. i get arrays
12:12:04 <shachaf> pdxleif: Yes, it's kind of similar in some ways.
12:12:06 <roconnor> carpi: arrays are much better for random access than lists.
12:12:13 <shachaf> pdxleif: In that it requires the same CPS-y conversion of your code.
12:12:20 <shachaf> carpi: Oh, well, that's not the Prelude.
12:12:21 <monochrom> as for reasons, there are reasons to use nothing.
12:12:22 <rwbarton> carpi: "Array" /= "Prelude".
12:12:26 <shachaf> Sometimes there are reasons to use it.
12:12:37 <shachaf> But if you don't know what they are you probably shouldn't yet. :-)
12:13:19 <carpi> ah shite.. my bad.. i mis - assumed that prelude was a collection of modules..when in fact its simply a module like any other..
12:13:23 <shachaf> roconnor: s/Well/Well,/
12:13:32 <carpi> so array is part of haskell platform.. more corect?
12:13:42 <pdxleif> Seems like if I wasn't restricted to using IO a, I'd still want to track where IO happened for performance / side effects reasons
12:13:45 <roconnor> shachaf: understood
12:14:09 <shachaf> roconnor: Yes, that particular lack of punctuation was just bugging me.
12:14:17 <shachaf> carpi: Well, it's defined in the Report.
12:14:20 <shachaf> http://www.haskell.org/onlinereport/array.html
12:14:50 <shachaf> "Haskell provides indexable arrays, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. "
12:17:02 <carpi> isomorphic/?
12:17:16 <shachaf> is-o-morphic
12:18:15 <roconnor> carpi: equivalent
12:18:18 <carpi> i mean.. not the pronounciation.. the meaning.. ? i think it means functions that belong to sets that are similar to subsets of integers..
12:18:21 <mrakan> What are ways to stop the evaluation of a fold at a certain point? The things that come to mind: have fold accumulate a list of results where only part of the results interest us (so laziness takes care of that), and using something like the Maybe monad to short circuit and ignore the rest of the list the fold operates on.
12:18:44 <shachaf> carpi: That was meant to hint at the meaning. :-)
12:19:07 <opqdonut> mrakan: takeWhile and scanl
12:19:07 <roconnor> "Haskell provides indexable arrays, which may be thought of as functions whose domains are equivalent to contiguous subsets of the integers. "
12:19:23 <zhasha> Hi, I can't for the life of me figure out how to return an integer value from main like you would in C. Anyone know?
12:19:28 <carpi> shachaf: same shape  : )
12:19:35 <opqdonut> > takeWhile (<20) $ scanl (+) 0 [1..] -- mrakan
12:19:36 <lambdabot>   [0,1,3,6,10,15]
12:19:40 <shachaf> zhasha: exitWith
12:19:54 <shachaf> exitWith ExitSuccess or exitWith (ExitFailure N)
12:19:55 <roconnor> zhasha: Sytem.Exit.exitWith (ExitFailure n)
12:19:58 <zhasha> shachaf: thank you :)
12:20:07 <mrakan> opqdonut: So, what you're saying is I shouldn't really use any fold* for this?
12:20:30 <shachaf> mrakan: Well, you *can*.
12:20:33 <opqdonut> mrakan: well, yeah. you might be able to use foldM for some suitable M
12:20:40 <opqdonut> but scanl seems easiest
12:20:50 <roconnor> maybe main should have type IO ExitCode instead of IO ()
12:21:02 <Saizan> mrakan: you could just use foldr and explioit laziness
12:21:28 <Saizan> > foldr const 0 [1..]
12:21:29 <lambdabot>   1
12:21:41 <lukish_> Solved ex20 from http://blog.tmorris.net/20-intermediate-haskell-exercises/ and get banana f (State v) = State $ \x -> state ( f . snd . v $ x ) x. But can I get definition of banana?
12:22:03 <shachaf> > fix ((0:) . zipWith (+) [1..])
12:22:05 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
12:22:23 <rwbarton> "definition of banana"? you mean the real definition of the State monad?
12:22:25 <shachaf> > foldr 1 0 [1..]
12:22:26 <lambdabot>   1
12:22:38 <mrakan> opqdonut, shachaf, Saiza: Thanks!
12:30:04 <lukish_> I mean, another definition*
12:30:42 <shachaf> lukish_: There's more than one definition of banana for State, yes.
12:30:48 <shachaf> Some of them are weirder than others.
12:31:27 <lukish_> Can you show some?
12:32:29 <rwbarton> the one you wrote doesn't look very state-like
12:36:31 <shachaf> That is also true.
12:36:35 <shachaf> Does it even type-check?
12:36:47 <lukish_> Yes.
12:37:03 <shachaf> What's "state"?
12:37:20 <basti_> the opposite of "transition", i suppose
12:37:39 <lukish_> shachaf: http://blog.tmorris.net/20-intermediate-haskell-exercises/
12:38:10 <shachaf> Oh, the thing that's normally called runState.
12:38:35 <lukish_> What is State in real life?
12:38:39 <lukish_> IO Monad ?
12:39:24 <Botje> State is implemented exactly as it is shown there.
12:39:31 <Botje> :info State
12:39:37 <Botje> boo.
12:39:39 <Botje> @info State
12:39:39 <lambdabot> State
12:39:48 <Botje> brilliant, that :P
12:40:01 <Botje> newtype State s a = State {runState :: s -> (a, s)}
12:40:05 <Botje>   	-- Defined in Control.Monad.State.Lazy
12:41:27 <Goosey_> @src !!
12:41:27 <lambdabot> xs     !! n | n < 0 = undefined
12:41:27 <lambdabot> []     !! _         = undefined
12:41:27 <lambdabot> (x:_)  !! 0         = x
12:41:27 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:41:34 <Goosey_> Factorial?
12:41:38 <Botje> list index.
12:41:46 <Botje> like list-ref in scheme, if you know that.
12:41:50 <Goosey_> Oh
12:42:04 <Goosey_> > [1..10] !! 5
12:42:04 <lambdabot>   6
12:42:08 <Goosey_> okay
12:42:30 <Goosey_> I've written this function without knowing it xD
12:43:22 <Botje> beginners often spend their time reinventing bits of prelude
12:43:36 <Goosey_> Yeah
12:44:06 <Goosey_> Axman6 gave me a few things challenges too.
12:44:19 <ricree> Learning about Hoogle's existence was wonderful
12:44:55 <Axman6> Goosey_: ill be back to give you more in 45 mins if youre still interested :P
12:45:09 <Goosey_> Axman6: Okay :D I'll look forward to it.
12:45:47 <Goosey_> > map (*) [a..e]
12:45:48 <lambdabot>   Overlapping instances for GHC.Show.Show
12:45:48 <lambdabot>                              (Simpl...
12:45:56 <Goosey_> > map (*) [1..5]
12:45:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:45:57 <lambdabot>    arising from a use of `...
12:46:23 <hpc> > map f [1..5]
12:46:24 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:46:24 <lambdabot>    `SimpleReflect.FromExpr ...
12:46:29 <hpc> > map f [1..5] :: Expr
12:46:30 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
12:46:30 <lambdabot>         against inferred ...
12:46:34 <hpc> > map f [1..5] :: [Expr]
12:46:35 <lambdabot>   [f 1,f 2,f 3,f 4,f 5]
12:46:41 <Goosey_> thanks hpc
12:46:51 <hpc> Expr is a tricky type
12:49:43 <Goosey_> hpc, when partially applying a function, does it have to be returned to another function or can that be a result?
12:50:05 <hpc> it can, but it can't be shown
12:50:13 <hpc> so it doesn't work as a final value for mueval
12:50:18 <Goosey_> Okay
12:50:30 <hpc> well, it can be shown, but it can't be inspected
12:50:39 <hpc> so the best you can get is "show = const somestring"
12:51:07 <Goosey_> > map (2) (map (*) [1..5])
12:51:08 <lambdabot>   [2,2,2,2,2]
12:51:28 <hpc> > map ($ 2) . map (*) $ [1..5]
12:51:29 <lambdabot>   [2,4,6,8,10]
12:51:43 <acowley> :t (2)
12:51:44 <lambdabot> forall t. (Num t) => t
12:51:51 <hpc> > 1 2
12:51:52 <lambdabot>   1
12:51:56 <acowley> !
12:51:57 <hpc> freaky num instances
12:52:26 <acowley> that seems to be a fairly dramatic divergence from Haskell
12:52:35 <byorgey> > snd (1 2)
12:52:35 <Goosey_> > map ($ f) . map (g) $ [1..5] :: [Expr]
12:52:36 <lambdabot>   1
12:52:36 <lambdabot>   can't find file: L.hs
12:52:49 <hpc> :t f g
12:52:50 <lambdabot> forall a t. (SimpleReflect.FromExpr a, SimpleReflect.FromExpr (a -> t)) => t
12:53:01 <hpc> > f g :: Expr
12:53:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:53:02 <lambdabot>    `GHC.Show.Show a'
12:53:02 <lambdabot>      a...
12:53:05 <hpc> pah
12:53:19 <carpi> why do we have 2 modules for Char? Data.Char and Char?
12:53:34 <hpc> carpi: hysterical raisins
12:53:35 <byorgey> acowley: it's not really a divergence. just an extension.
12:53:36 <acowley> hysterical raisins
12:53:39 <acowley> sfdsa
12:53:43 <hpc> :D
12:54:27 <acowley> byorgey: I thought the language spec said something about base Num instances?
12:54:33 <Goosey_> hpc: Why doesn't this work: > map ($ f) . map (g) $ [1..5] :: [Expr] I am giving it a type...
12:54:41 <carpi> i get it that i should use Data.Char regardless )
12:54:45 <byorgey> carpi: back in the Old Days the modules defined by the Report were good enough for everyone, so modules had single word names. Char. List. Maybe. Monad.
12:55:06 <byorgey> carpi: then people had the idea of making more modules and that things would quickly get out of hand without hierarchical names.
12:55:59 <byorgey> carpi: as of the Haskell 2010 standard the old module names like 'Char' are deprecated, and the new hierarchical names like 'Data.Char' are standard.
12:56:58 <carpi> thanks for the clarification.. so its the same with some other modules without hierarchial naming? like Array for example..
12:57:05 <hpc> indeed
12:57:55 <EvanR-work> we should be polluting the top level namespace with Data, Control, etc
12:57:59 <EvanR-work> should NOT be
12:58:16 <EvanR-work> put it all under MyHaskell.
12:58:18 <EvanR-work> lol
12:58:26 <EvanR-work> more elegant
12:58:30 <EvanR-work> also, cleaner
13:00:25 <carpi> the words boxed and unboxed are sprinkled here and there in the haskel library docs..  could someone please tell me what they mean? is it another way of saying lazy and non-laxy?
13:00:37 <carpi> *non-lazy
13:00:43 <ksf_> hmmm I should really be using 7.4 if I'm doing type level stuff.
13:01:08 <acowley> it's not out yet :(
13:01:11 <Botje> a boxed value is a pointer to either a value or a thunk that evaluates to that value
13:01:16 <alistra> carpi: non-strict and strict
13:01:25 <Botje> an unboxed value can only be a value
13:01:36 <hpc> carpi: an unboxed value is just like any value in C
13:01:52 <Botje> but with less sharp corners.
13:01:53 <hpc> carpi: a boxed value has a "box" around it, which is what Botje described
13:01:57 <ksf_> if my memory serves me right ghc never failed to compile, or run, out of vcs for me.
13:02:07 <dgpratt> hmm...HaRe looks nifty, but it doesn't seem to support more recent versions of Haskell :(
13:02:15 <alistra> http://www.haskell.org/haskellwiki/Performance/GHC#Unboxed_types
13:02:40 <ksf_> yep, haskell suffers from abandonment of excellent code.
13:02:54 <ksf_> ...too many ph.d thesis
13:03:23 <alistra> yeah this ^
13:04:51 <alistra> there's like xmonad
13:04:51 <alistra> and
13:04:54 <alistra> uh
13:04:59 <alistra> no other haskell program
13:05:37 <carpi> so generaally unboxed versions of the same types of boxed verysion are usually faster?
13:05:37 <ben> i hope shake catches on
13:05:41 <alistra> yeah
13:05:44 <alistra> ben: it won't
13:05:51 <acowley> I'm not clear on exactly what shake would buy me
13:05:59 <ben> haskell adoption
13:06:00 <alistra> there's make already
13:06:11 <ksf_> there's yi, but it suffers from an absence of any kind of *actually* vi-using contributors.
13:06:17 <ben> but make is worse and shake is better, clearly that means it will catch on
13:06:31 <alistra> not really
13:06:33 <msieradzki> does --enable-library-profiling pass -p or -p -auto(-all)?
13:06:37 <alistra> it's relative
13:07:00 <alistra> also haskell shouldn't rewrite existing systems
13:07:04 <alistra> but build new programs
13:07:05 <alistra> lol
13:07:14 <alistra> it's like
13:07:24 <c_wraith> alistra: there is lots of haskell code out there.  But mostly it's proprietary stuff.
13:07:29 <alistra> let's make a new social site, like facebook but for golfers
13:07:42 <ben> but there's so many existing systems already :(
13:07:42 <alistra> the part 'like facebook' is wrong in the idea
13:07:56 <alistra> c_wraith: lots?
13:08:12 <c_wraith> alistra: yes.  just because you don't see it doesn't mean it doesn't exist
13:08:24 <alistra> there's thoughtleadr, mailrank, galois and silk
13:08:38 <alistra> and google has some vm management gizmo
13:08:49 <alistra> and never heard of anything more
13:08:52 <c_wraith> facebook, janrain
13:09:10 <c_wraith> and these are just ones I know offhand.
13:09:53 <alistra> well it's not exactly java, c, ruby or python
13:10:40 <c_wraith> yeah, so?  python isn't exactly java or c?
13:10:44 <c_wraith> what's your point
13:11:38 <msieradzki> why isn't this default:   ghc-prof-options: -prof -auto-all? (cabal doesn't pass -auto-all when --enable-library-profiling was passed so libraries functions don't show up on graphs by default)
13:11:52 <c_wraith> msieradzki: because it means compiling every library twice.
13:11:53 <msieradzki> some packages have it in .cabal, most don't afaik
13:11:55 <alistra> i mean in the count of places to work
13:11:56 <ksf_> msieradzki, overhead.
13:12:01 <msieradzki> overhead I understand
13:12:02 <msieradzki> but twice?
13:12:04 <c_wraith> oh, you just mean the -auto-all thing
13:12:06 <msieradzki> how is compiling twice related
13:12:19 <ksf_> that's profiling in general.
13:12:40 <alistra> and noone that doesn't know haskell won't use shake
13:12:40 <alistra> lol
13:13:11 <ksf_> and according to the ghc guys compiling twice doesn't incure any significant amount of avoidable overhead, as profiling code is injected before the optimiser passes
13:13:32 <c_wraith> Yeah, I can't justify -auto-all not being the default.  the results are so bad without it.
13:13:58 <msieradzki> I meant default when using cabal and --enable-library-profiling is on, not ghc default
13:14:06 <ksf_> -auto-all litters the profile with useless bunk.
13:14:13 <alistra> nobody will exactly want to care about typing his makefile besides haskell programmers
13:14:36 <ksf_> and if there are manual points defined, you definitely don't want -auto-all
13:14:58 <ksf_> alistra, make is *painful* when you do anying more advanced.
13:15:02 <c_wraith> ksf_: in my experience, profiling results are often completely useless without -auto-all.  Like, for instance, HDBC-postgresql
13:15:10 <alistra> ksf_: i know
13:15:18 <alistra> but looking at shake's syntax
13:15:22 <ksf_> c_wraith, well, add more manual points.
13:15:30 <sefb1704> umm okey i read through the tutorial aboutt IO but there is nothing about how to extract the number out of an IO thing
13:15:31 <alistra> i'm sure nobody not related to haskell will use it
13:15:33 <ksf_> I'm not talking about syntax, but semantics.
13:15:35 <c_wraith> ksf_: since it doesn't use -auto-all, all profiling results from it credit all time in the library as coming from createConnection
13:15:46 <c_wraith> ksf_: which is entirely useless
13:15:53 <ksf_> the ease with which you can screw up builds with make is astonishing.
13:16:46 <Axman6> sefb1704: there is no number 'in' an IO thing
13:16:47 <ksf_> and it's *not* a good feature of a build system if the standard way to fix stuff is "make clean". or, even worse, check out anew because make clean decides to build the stuff it wants to delete, first
13:17:08 <Axman6> sefb1704: just like there is no string in ls, it's an action you run to obtain a string, in the IO monad
13:17:11 <ksf_> (seriously, I once saw that happening. I won't disclose the project's name)
13:17:20 <sefb1704> ok then .. can i tell randomRIO to return an int?
13:17:38 <sefb1704> Int => randomRIO ... or something?
13:17:38 <Axman6> no
13:17:49 <Axman6> you can get an int from randomRIO in the IO monad though
13:18:06 <Axman6> do ... x <- randomRIO (a,b)... x will be an int
13:18:16 <alistra> this sefb1704 ^
13:18:34 <Axman6> or you can use the pure random interface: let x = randomR (a,b) (mkStdGen 2390)
13:18:50 <Peaker> carpi: If you want, I can give more indepth review now, have a bit more time
13:18:52 <Axman6> but! that will always return the same x
13:18:55 <Axman6> :t randomR
13:18:56 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:19:08 <acowley> I've used "check out anew" to solve both git and darcs problems :(
13:19:17 <sefb1704> hmkey so i can just write let x = randomR  (0,10); if (x == 1) then ..
13:19:28 <alistra> or equivalently randomRIO (a,b) >>= \x -> print x (or anything else than print that has an IO type)
13:19:28 <Axman6> sefb1704: no
13:20:04 <sefb1704> hm.
13:20:25 <Axman6> sefb1704: do you understand the distinction between pure and nonpure functions?
13:20:43 <sefb1704> y we just learned this today at university :)
13:21:28 <ricree> sefb1704 check out the type signature of randomR.  in the code you posted, x would be a tuple, not a number
13:21:39 <Axman6> ok, well then you should know why it's impossibe to get a random number in IO code, without at least having some kind of changing argument. f x will always return the same number if x is the same.
13:22:01 <alistra> sefb1704: what university:?
13:22:18 <sefb1704> okey so let (x,y) = randomRio (0,10); if (x == 1) then ..
13:22:24 <sefb1704> TUHH
13:22:43 <Axman6> sefb1704: no :\
13:23:00 <Axman6> remember, you can't run randomRIO in a pure function
13:23:23 <sefb1704> hm okey. and what if i got a function that interacts with the user?
13:23:35 <sefb1704> like .. an adventure-game?
13:23:40 <Axman6> then it will be in the IO monad
13:23:51 <alistra> all will be in the io monad
13:24:12 <Axman6> alistra: that sounds like a passage from a biblical text :P
13:24:14 <alistra> you can run pure and impure things from the inside of IO
13:24:26 <sefb1704> okey. so only because the resulttype of my function is IO this will work?
13:24:35 <alistra> and thou shalt not leave the io monad?
13:24:49 <alistra> sefb1704: main :: IO () in haskell
13:25:05 <alistra> or IO a
13:25:18 <sefb1704> umm in my case its .... function :: blabla takes alot of arguments -> IO()
13:25:19 <ksf_> arguably should be IO Int
13:25:28 <alistra> so everythinh eventually goes into IO, even if you don't see it
13:25:30 <ksf_> or, well, the rts should return the int if it happens to be io int.
13:25:46 <Axman6> alistra: ah, in that case, you can use x <- randomRIO (a,b) inside the do block
13:26:12 <alistra> Axman6: i know that i can, sefb1704 doesn't
13:26:18 <Axman6> uh, sefb1704 even
13:26:28 <sefb1704> ah so x <- randomRIO (a,b) ; if (x ==1) then ..
13:26:30 <sefb1704> is right?
13:26:36 <Axman6> yep
13:26:42 <sefb1704> awesome :O :)
13:26:54 <sefb1704> okey i will test this
13:26:55 <Axman6> sefb1704: feel free to paste all of your code for us to look at too
13:26:59 <Axman6> on hpaste
13:27:01 <alistra> sefb1704: there's a game i've written for school, it has 2 users and interaction, but no random http://dpaste.com/675926/
13:27:03 <Axman6> @hpaste
13:27:03 <lambdabot> Haskell pastebin: http://hpaste.org/
13:27:11 <sefb1704> ahah :D do you really want this?
13:27:15 <alistra> but you can do x <- randomRIO (a,b) in the main do block
13:29:49 <hpaste> sefb1704 pasted “myhaskelladventure v0.6” at http://hpaste.org/55524
13:30:10 <sefb1704> if u want to play it, load it and enter "start"
13:30:20 <sefb1704> you can actually collect some items and fight the bear
13:30:35 <alistra> with my bear hands
13:30:52 <Axman6> argh! german, heh
13:30:54 <ksf_> ugh
13:30:56 <alistra> the code comments
13:31:01 * Axman6 has bear arms
13:31:10 <alistra> are in an unreadable dialect
13:31:16 <Goosey_> How do you hold your ax with bear arms?
13:31:19 <Goosey_> axe*
13:31:30 <alistra> why would you comment and english code in german
13:31:34 <sefb1704> alistra, its german sry
13:31:37 <Goosey_> xD
13:31:40 <Axman6> it's not too hard, but you have to worry about getting the sap in your fur
13:31:51 <sefb1704> i dont know, my haskell lessons are in english but i think in german
13:31:54 <sefb1704> maybe thats why
13:32:05 <Axman6> sefb1704: that's as good a reason as any :)
13:32:06 <ksf_> sefb1704, first off, don't use strings as ad-hoc data types. use data types. then, make the whole thing data-driven.
13:32:13 <Axman6> that beat is awesome by the way
13:32:19 <Axman6> RRRAAAWWWRRRR
13:32:21 <Axman6> beat*
13:32:31 <Goosey_> ...
13:32:45 <sefb1704> ksf,  ad hoc? ..
13:33:07 <Axman6> "The wild bear has totally eaten you now, you are dead. Game Over." :(
13:33:23 <sefb1704> did you really play it until that point? ^^
13:33:31 <sefb1704> yes you have to collect the knife on the clearance
13:33:42 <sefb1704> then you can fight him, get meat and then grill the meat
13:34:03 <Goosey_> pikhq: Are you on xkcd?
13:34:07 <ksf_> sefb1704, "clearance", "jungle" etc. vs. data Location = Clearance | Jungle | ...
13:34:12 <sefb1704> the final goal is to trade the meat with some warriors for a map of the gold thing and then finding the gold thing ..
13:34:26 <ksf_> openbag (knife:wood:meat:xs)
13:34:27 <Axman6> sefb1704: haskell has real, extremely powerful data types, you shou;dn't be using strings when you can define something that can only have the values you expect. data Item = Axe | Gem | Sword etc
13:34:33 <ksf_> that's not how lists are supposed to be used...
13:34:39 <sefb1704> hm okey we have already been introduced to data.
13:35:21 <Axman6> heh, i love how sometimes in hlint, redundant brackets are a warning, and others an error
13:35:30 <sefb1704> ksf_, come on, i was so proud of me, like this i can edit single items and sometimes just give the whole list to the next function
13:35:30 <ksf_> data Item = Knife | Wood | Meat, openbag :: Item -> ... -> ...
13:35:37 <alistra>       superprint "Jesus, Holy Christ, Mama mia, What the freaking hell, Oh my god.. (ENTER)"
13:35:41 <ksf_> er [Item]
13:35:50 <alistra> Jesus H. Christ
13:36:04 <ksf_> when (Knife `elem` items) $ print "tadaa!"
13:36:22 <sefb1704> oh thats smart .. i think i will add this to my todo-list
13:36:26 <Axman6> sefb1704: just because it's a text adventure game doesn't mean you have to use text for everything :P
13:36:40 <sefb1704> ;)
13:36:56 <alistra> yeah, and probably those data constructors like Knife will take a lot less space
13:37:01 <alistra> than "Knife"
13:37:02 <alistra> :P
13:37:14 <Axman6> you save two characters too!
13:37:15 <alistra> if you were to sometime write an optimized cod
13:37:15 <alistra> e
13:37:49 <ksf_> actually, right now the inventory is [Integer]. positional indexing and comparison to 0, 1.
13:37:54 * acowley optimizes his cod
13:38:13 <Axman6> acowley: do you keep it in your codpiece?
13:38:16 <pikhq> Goosey: Si
13:38:26 <pikhq> Goosey: If you mean #xkcd, that is.
13:38:28 <Goosey> pikhq: Okay, I thought your name was familiar :P
13:38:30 <acowley> Axman6: obviously
13:38:37 <ksf_> that inventory thing of course begs for a state monad.
13:38:41 <Axman6> acowley: also, i believe you replied to a bug of mine on github for OpenCL?
13:39:05 <acowley> Axman6: yes, I saw the pull request on my dashboard. I addressed the include files differently in my fork
13:39:22 <acowley> Axman6: I'm not sure if one approach is necessarily better, but I thought I'd raise the issue
13:39:52 <Axman6> acowley: yeah, i'm glad to see that. it would be much better to build against any system headers... though there are issues because there are three OpenCL implementations for non OS X machines
13:40:05 <ksf_> damn, git clone can be unnervingly slow.
13:40:10 <sefb1704> ksf_, when i create this data Item, can i still have multiple items?
13:40:20 <ksf_> sefb1704, of course.
13:40:24 <acowley> Axman6: perhaps we can at least remove OS X from that mix
13:40:24 <sefb1704> ah i see
13:40:25 <Axman6> [Item]
13:40:27 <sefb1704> [Item]
13:40:48 <ksf_> though technically that propbably shouldn't be a list, but a set.
13:40:52 <ksf_> or, rather, bag.
13:41:00 <sefb1704> oO a bag? ^^
13:41:00 <Axman6> acowley: yeah, luckily OS X just has the OpenCL framework, anf it works on all supported GPUs and CPUs
13:41:16 <ksf_> sefb1704, a set where elements can occur multiple times.
13:41:21 <ksf_> like a list, but without ordering.
13:41:36 <sefb1704> okey. but you cant have a knife twice
13:41:45 <ksf_> well, then a set.
13:41:48 <Axman6> is there anything you can have more than one of?
13:41:52 <ksf_> but lists are going to be fine for starters.
13:42:04 <sefb1704> when you already have the knife, you cant find no more knifes
13:42:21 <ksf_> but you may want to scatter more than one knife at some time.
13:42:49 <Axman6> actually, a Set would be perfect even if there are, because you can have data data Item ... | Knife | ... | Bread Int | ... to signify how many bread loafs you have
13:43:04 <Axman6> loafs? hmm, doesn't look right
13:43:19 <acowley> type Loaves = [Loaf]
13:43:31 <sefb1704> hehe thats funny
13:43:52 <sefb1704> so a set .. how do i make a set out of data Items?
13:44:16 <jix> Axman6: then you can put Bread 2 and Bread 3 into the set at the same time
13:44:17 <ksf_> there are specialised data types for that, but for now, just use the set operations from Data.List.
13:44:18 <acowley> Set Item
13:44:21 <ksf_> like elem.
13:44:23 <ksf_> or union.
13:44:29 <acowley> yes, listen to ksf_
13:45:40 <Axman6> jix: not if you implement your equality in a different way to the default
13:45:48 <ksf_> uhm... why does ghc git identify itself as 7.5.20111219 ? shouldn't that be 7.3?
13:46:09 <Axman6> s/equality/ordering i guess
13:46:12 <acowley> Axman6: do you have any sense for how responsive zhensydow is with OpenCL?
13:46:24 <acowley> ksf_: 7.4 was already branched
13:46:31 <Axman6> acowley: well, i haven't got a response... so so far, not very :P
13:46:41 <sefb1704> ah okey. so i dont have to change data Item after i have created it, and i noted that 'elem' thing :) from that on google will help me i guess. okey i tested this x <- randomRIO (0,10); if (x == 1) then and it still doesnt work
13:47:00 <acowley> Axman6: I hope he wakes up. There's a reasonable amount of activity now and we need a rallying point for it.
13:47:32 <acowley> Although the holidays may work against that
13:47:37 <sefb1704> btw, do you get money for being here?
13:47:40 <Axman6> acowley: indeed. I really want to make OpenCL easily usable from Haskell, and I don't really care which code base does it, just as long as it happens
13:47:52 <Axman6> sefb1704: only if you send us some =)
13:47:58 <acowley> Axman6: I think it's already pretty good, actually
13:47:58 <sefb1704> aah ^^
13:48:22 <Axman6> acowley: well, it's ok, but just as verbose as the C itself, which is not ideal
13:48:35 <acowley> Axman6: and I'm really wary of full EDSL embeddings as they sometimes restrict you and make existing references less useful
13:48:52 <sefb1704> okey i tested this x <- randomRIO (0,10); if (x == 1) then and it still doesnt work. its actually the same thing i posted in hpaste only with a different name
13:49:17 <acowley> I actually think it's a slight improvement on C. I've been doing some OpenCL work, and started using the Haskell bindings just because they were marginally prettier
13:49:22 <ksf_> 7.4.0.20111219 looks way better.
13:50:03 <ksf_> Axman6, gpipe?
13:50:17 <Axman6> we need things like: withVector :: (Storable a, OpenCLType a) => IOVector a -> (CLMem -> IO ()), which would allow the inner computation to use the data from the vector on the device, and write back to it, and copy the data back from the device to the IOVector, for instance
13:50:21 <ksf_> it's got the right idea, but is in need of a proper reimplementation.
13:50:33 <Axman6> ksf_: i haven't looked closely at it, mayeb i should
13:50:48 <ksf_> it's doing basically what you said.
13:50:55 <acowley> Axman6: well, writing back to the input vector isn't very functional
13:50:58 <ksf_> ...distinguishing between CPU and GPU types et al.
13:51:23 <ksf_> alex: compiler/parser/Lexer.x: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
13:51:29 <ksf_> that's a thing I didn't want to see.
13:51:34 <Axman6> acowley: no, but it's fairly OpenCL like i guess. i guess it would be better to maybe use Vector a and return a new vector
13:51:41 <acowley> ksf_: that's an example of what I'm wary of :/ I think gpipe is fantastic, and hope it can become a real force, but it's very ambitious
13:51:53 <acowley> Axman6: the latter is what I currently have
13:52:33 <Axman6> i tried writing a simple Vector thing like that the other day, but failed :\
13:53:09 <ksf_> acowley, the thing it misses is properly dealing with textures.
13:53:22 <ksf_> that is, construct texture maps, allow them to be indexed at run-time.
13:53:29 <acowley> Axman6: It's entirely possible what I'm using is not what you want. I'm not trying to do anything too magical regarding Haskell interop yet.
13:54:14 <Axman6> acowley: got code anywhere i can see?
13:54:19 <acowley> ksf_: I think, at the end of the day, I didn't feel like it was gaining me so much over just writing GLSL that I was willing to give up all the know-how scattered around the web.
13:54:20 <ksf_> why, btw, does hGetContents choke on utf8?
13:54:30 <ksf_> isn't anybody else but me using a POSIX locale?
13:54:31 <acowley> Axman6: I'll try to post something tomorrow
13:54:37 <Axman6> that's be great :)
13:54:55 <Axman6> acowley: ping me if you want me to take a look, i may not be around
13:54:59 <ksf_> Axman6, also, don't forget dph.
13:55:09 <acowley> Axman6: ping here or elsewhere?
13:55:15 <Axman6> here's fine
13:55:19 <acowley> will do
13:56:00 <Axman6> ksf_: i think integrating dph with OpenCL would be a hell of a lot of effort. something i'd like to see one day, but not something I'm particularly keen to do byself
13:56:14 <ksf_> well, it's running on top of cuda already.
13:56:19 <ksf_> can't be that different.
13:56:32 <Axman6> since when?
13:56:38 <Axman6> Accelerate is, but not dph afaik
13:56:41 <ksf_> since forever, iirc.
13:56:56 <acowley> I thought the same as Axman6
13:57:00 <Axman6> i'm pretty sure you're wrong about this :\
13:57:14 <Axman6> DPH has always been about making things run in parallel on the CPU
13:57:19 <ksf_> Axman6, anyhow, making use of the dph types could prove sensible.
13:57:34 <Axman6> i think Repa actually fits much better
13:57:45 <ksf_> repa isn't nested, is it?
13:57:47 <Axman6> since it actually matches a lot of what you'd do on the GPU
13:57:48 <acowley> The thing about OpenCL is that it presents wildly different tradeoffs when compared to CPU-based parallelism
13:57:56 <Axman6> no, but that's ok
13:58:14 <Axman6> (plus it's a lot easier to get Repa like stuff to run efficiently on a GPU)
13:58:20 <ksf_> also, I don't know if one can really access all the gpu oomph via opencl, what about those tesselators etc?
13:58:26 <acowley> think of copying from global memory into local memory shared by a group of threads
13:58:49 <ksf_> Axman6, *after flattening* dph is non-nested, too.
13:58:53 <acowley> that kind of thing is important for OpenCL, but rather awkward to express in Haskell land
13:59:04 <ksf_> though the code for each node probably gets quite complex.
13:59:38 <Axman6> this is why i think Repa is a better target. we know that the arrays are going to have a shape we can wotk with nicely on a GPU
14:00:27 <Axman6> we can restrict it to working with 1, 2 and 3 dimensional arrays, and it will map exactly onto what the GPU wants, in both OpenCL and CUDA
14:00:38 <sefb1704> okey i tested this x <- randomRIO (0,10); if (x == 1) then and it still doesnt work
14:00:54 <Axman6> "doesn't work?"?
14:00:59 <dmwit> sefb1704: You forgot the rest of the bit after "then". =)
14:01:14 <dmwit> also "do" and half a dozen other boilerplate bits
14:01:27 <sefb1704> :(
14:01:33 <dmwit> So... maybe you'd better post a complete file, say what you do, what you expect to happen, and what happens instead.
14:01:50 <sefb1704> ambigous type variable t in the constraints random t
14:01:56 <ksf_> also, you need to add more dwarves slaying elves.
14:02:11 <ksf_> preferrably while felling a tree they hug.
14:02:18 <dmwit> sefb1704: Annotate one of 0, 10, or 1, to tie down the type a bit.
14:02:27 <dmwit> e.g. x <- randomRIO (0 :: Int, 10); etc.
14:02:27 <Axman6> in that case, you haven't said what type you want x to be, and randomRIO can return heaps of different types
14:03:04 <sefb1704> okey :O when i tested randomRIO it always returned integers just like that so i thought this would be fine
14:03:23 <Axman6> that's because of defaulting i think
14:03:39 <sefb1704> this works :O omg finally!  :)
14:03:44 <rwbarton> ghci extended defaulting, probably
14:08:38 <Gwern-away> > 0.5 * .75
14:08:38 <lambdabot>   <no location info>: parse error on input `.'
14:08:40 <Gwern-away> > 0.5 * 0.75
14:08:41 <lambdabot>   0.375
14:09:25 <ksf_> we should exorcise that abomination called unary minus.
14:09:44 <ksf_> "0-" is a perfectly fine thing to write.
14:10:27 <mastermaker> slaves
14:10:46 <ksf_> /usr/lib/gcc/x86_64-pc-linux-gnu/4.5.3/../../../../x86_64-pc-linux-gnu/bin/ld: utils/hsc2hs/dist-install/build/Main.o: relocation R_X86_64_32S against `stg_CAF_BLACKHOLE_info' can not be used when making a shared object; recompile with -fPIC
14:10:57 <ksf_> I don't think I've seen one of those in like eight years.
14:11:39 <sefb1704> umm okey one last question. error message says that a pattern is overlapping. i cant find this overlapping. can i tell haskell to show me the lines of these patterns that overlap, and not only 1 ?
14:12:05 <mastermaker> slaves
14:12:08 <sefb1704> i can find the pattern but i dont think that it overlapps
14:12:52 * hackagebot force-layout 0.1.0.0 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.1.0.0 (BrentYorgey)
14:13:48 <acowley> sefb1704: the compiler is probably right
14:13:57 <Botje> sefb1704: put it on hpaste
14:14:03 <sefb1704> okey, now you are making fun out of me ..
14:14:03 <Axman6> s/probably/almost certainly
14:14:08 <mastermaker> slaves
14:14:16 <Axman6> @where ops
14:14:16 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:14:22 <ksf_> sefb1704, dunno if it's it, but (0:0:xs) should be before (knife:0:xs)
14:14:23 <mastermaker> slaves
14:14:26 <Axman6> ops: mastermaker
14:14:28 <ksf_> the latter also matches the former.
14:14:40 <ksf_> and pattern matches are first-come first-serve.
14:14:45 <mastermaker> slaves
14:15:10 <ksf_> oh, wait, there's another parameter there.
14:15:16 <mastermaker> slaves
14:15:18 <byorgey> > permutations "slaves"
14:15:19 <lambdabot>   ["slaves","lsaves","alsves","lasves","aslves","salves","valses","avlses","a...
14:15:42 <Axman6> /exec - -o yes slaves
14:15:47 <silver> @type permutations
14:15:48 <lambdabot> forall a. [a] -> [[a]]
14:15:51 <sefb1704> botje, its this code: http://hpaste.org/55524
14:15:51 <mastermaker> slaves
14:16:00 --- mode: ChanServ set +o Saizan
14:16:05 <ksf_> hmmm. I fixed that -fPIC error by turning off -j5
14:16:11 --- mode: Saizan set +b *!*mastermak@*.hsi6.kabel-badenwuerttemberg.de
14:16:12 --- kick: mastermaker was kicked by Saizan (mastermaker)
14:16:17 --- mode: Saizan set -o Saizan
14:16:37 <Axman6> why do i no longer have ops. shapr showed me some love :(
14:16:44 <sefb1704> error message in line 132, pattern matches are overlapped in the definition of decision : decision (0  : wood :xs) "itemdecision-clearance" next = ..
14:16:52 <acowley> he's lost that loving feeling
14:17:14 <ksf_> sefb1704, I think this is a wonderful opportunity to reorganise your code towards maintainability.
14:17:33 <acowley> every day is a wonderful opportunity for that
14:17:35 <alistra> ksf_: still the game?
14:17:38 <sefb1704> you mean to implement data Item?
14:17:41 <alistra> how can you bear this
14:17:44 <ksf_> not only that.
14:17:58 <ksf_> decision is *way* too long a function.
14:17:59 * alistra made a pun
14:18:00 <acowley> but certainly including that
14:18:02 <sefb1704> alistra, hehe, you said "bear" and actually, there is a bear in the game ..
14:18:05 <ksf_> function, too.
14:18:12 <Botje> sefb1704: you have the same pattern match in lines 142 and 167
14:18:17 <alistra> sefb1704: you've noticed :3
14:18:31 <alistra> bearly nobody else noticed
14:18:36 <sefb1704> pf
14:18:37 <sefb1704> :D
14:19:15 <sefb1704> botje, you are right, omg :O
14:19:37 <sefb1704> i thought i knew my code ..
14:19:39 <Axman6> sefb1704: this is a sign that your functiona are way too big...
14:20:02 <sefb1704> ya first i only had one function. i pasted it here and you guys got really angry
14:20:08 <sefb1704> so i made alot of pattern matches
14:20:46 <Axman6> that's still one huge function though
14:22:35 <ksf_> sefb1704, decisions items "clearance"  input next = case input of ...
14:23:08 <ksf_> then make a datatype for all those locations, and for the items
14:23:20 <alistra> it's a bearden to have such a function
14:23:33 <sefb1704> it compiles :) thanks botje and ksf alistra and axman6
14:23:34 <ksf_> yeah, especially 'cos the whole thing is just one big automaton.
14:23:51 <sefb1704> :)
14:24:04 <ksf_> anyhow, moving to a data-driven model right away would probably too big a refactor right now.
14:24:26 <alistra> a real man would do it
14:24:28 <ksf_> first, at the very least, tuck the items away into a state monad.
14:24:42 <byorgey> alistra: your puns are bearen of any humor.
14:24:55 <byorgey> ;)
14:24:55 <ksf_> then we can go ahead and pull the IO out of the whole thing.
14:24:56 <sefb1704> state monad?
14:25:05 <ksf_> sefb1704, don't worry, do your data types.
14:25:12 <sefb1704> i think what i can do in the next days is trying out this data items
14:25:15 <sefb1704> data Items
14:25:15 <sefb1704> okey
14:25:20 <Axman6> sefb1704: we'll teach you about the state monad later ;)
14:25:23 <alistra> byorgey: i didn't get that one :|
14:25:39 <byorgey> alistra: bearen = barren
14:25:42 <alistra> it's hard to pun not in your native language
14:25:47 <byorgey> alistra: ah, sorry =)
14:25:52 <sefb1704> what? you will steal my IO? but i like IO ..
14:25:57 <peddie> ~.
14:25:59 <ksf_> ...that decision passing could use some CPS. no need to work with numbers, there.
14:26:00 <Axman6> no!
14:26:01 <sefb1704> its simple .. and big
14:26:03 <Axman6> IO is evil!
14:26:07 <ksf_> (or, at least, mention them in code)
14:26:27 <alistra> Saizan: you can use a transformer and have both
14:26:29 <byorgey> @wn barren
14:26:30 <lambdabot> *** "barren" wn "WordNet (r) 3.0 (2006)"
14:26:30 <lambdabot> barren
14:26:30 <lambdabot>     adj 1: providing no shelter or sustenance; "bare rocky hills";
14:26:30 <lambdabot>            "barren lands"; "the bleak treeless regions of the high
14:26:30 <lambdabot>            Andes"; "the desolate surface of the moon"; "a stark
14:26:30 <Axman6> there's an extremely good reason why we separate IO form the code that actually does the work in your program
14:26:32 <lambdabot> [12 @more lines]
14:26:32 <sefb1704> y i know i could use bool but .. writing true takes more letters then 1 :P
14:26:43 <alistra> 1. barren, waste, wasteland -- (an uninhabited wilderness that is worthless for cultivation; "the barrens of central Africa"; "the trackless wastes of the desert")
14:26:56 <alistra> wn barren -def
14:26:57 <Axman6> sefb1704: no!!!!!
14:26:59 <Axman6> argh!
14:27:03 * Axman6 cries a little
14:27:09 <acowley> sefb1704: do you understand what you're doing to us?
14:27:20 <acowley> look at Axman6!
14:27:24 <Axman6> :'(
14:27:31 <sefb1704> arg i think i have just passed the right moment to leave this irc ;D sry guys
14:27:34 <Axman6> :_(
14:27:45 <byorgey> sefb1704: no, it's OK, please stay =)
14:28:02 <acowley> sefb1704: good code thrills #haskell, it's up to you to turn those frowns upsidedown!
14:28:04 <byorgey> but promise never to use an Int when you really want a Bool ever again.
14:28:09 <alistra> sefb1704: you know what type-safety is?
14:28:22 <acowley> alistra: Yes. Everything is an int.
14:28:48 * ksf_ considers joining #agda and talking about preferring formalism because "exists" is so much shorter than "forall"
14:28:53 <alistra> acowley: i'm writing a C analyzer now, don't even get me started
14:29:01 <sefb1704> no. but i know that it is very late and i think (hehe acowley is right!) and that i have to wake up at 6:00 tomorrow .. or should i write today
14:29:04 <acowley> sefb1704: The benefits of a Bool being only True or False outweight the verbosity almost immediately.
14:29:35 <sefb1704> okey. but does making thoughts about such things make sense in a textadventure game?
14:29:35 <acowley> alistra: You need to let everything go. Be free. It is an int.
14:29:35 <byorgey> making choices based on the amount of typing is like deciding which house to buy based on what color the door is painted
14:30:01 <sefb1704> i mean if you open the file you can cheat easily, this problem seems to be even more important to me
14:30:01 <alistra> acowley: be an Int
14:30:01 <NihilistDandy> most important detail, obviously
14:30:05 <alistra> what would baby Int do?
14:30:33 <Makoryu> byorgey: I dunno. If the door is painted with frog poison or some shit like that then even if you move in there the house still needs a new door
14:30:45 <acowley> byorgey: yeah, you gotta think about your frogs
14:30:50 <dolio> ksf_: What do you mean? exists only has one skinny letter, and forall has two.
14:31:17 <byorgey> sefb1704: in that case you just distribute a binary.  it doesn't mean you write confusing code on purpose.
14:31:26 <Makoryu> （　≖‿≖）
14:31:33 <sefb1704> but come on, my game is a closed system, its so save in there. there my only be 1 or 0 as values
14:31:37 * Makoryu knocks ksf_'s and dolio's heads together
14:31:40 <sefb1704> *may
14:31:57 <alistra> as long as you don't make a typo
14:32:04 <byorgey> sefb1704: you are underestimating your capacity to make mistakes.
14:32:26 <sefb1704> byorgey: i see :/
14:32:29 <byorgey> sefb1704: if you use a Bool then the *compiler* guarantees that it can only be True or False.  If you use Int then *you* have to guarantee it is only 0 or 1.
14:32:50 <byorgey> it means you have more to worry about, and more opportunities for bugs.
14:32:52 <Guest42290> sefb1704, I agree with you, I have always believed bool = bit = 0 or 1. However, I'm from an assembly and C background. You aren't going to convince the Haskell crowd of this :)
14:32:57 <alistra> sefb1704: and looking for typo errors without types is teddyious
14:33:09 <shachaf> If only compiler guaranteed that it could only be True or False and not _|_. :-(
14:33:20 <Axman6> Gwern-away: it is a habit you should ween yourself from
14:33:29 <byorgey> Guest65944: yes, Bool = bit.  but we are not talking about bits, we are talking about 4-byte integers.
14:33:29 <dolio> Let's waste 31-63 bits storing our booleans.
14:33:33 <Axman6> uh, russellw even. damn nick changes >_<
14:33:41 <Makoryu> sefb1704: If it makes you feel better, you can implement a Num instance for Bool where 0 evaluates to False and 1 evaluates to True
14:33:42 <Gwern-away> Axman6: ne'er ne'er shall a gwernman be a slave!
14:33:45 <alistra> shachaf: _|_ isn't really a value
14:34:00 <byorgey> Makoryu: ...and what would 2 evaluate to?
14:34:01 <sefb1704> :D okey. typo errrors? i dont know what this is but i guess its something i dont need for my game. i dont need test cases, i only need some encouraged friends that test this game when its finished to find all the errors :P
14:34:07 <alistra> it's like saying atheism is a religion
14:34:08 <russellw> yeah. mirc logs me back on when connection hiccups, but doesn't deal with the nick properly :)
14:34:16 <Makoryu> byorgey: Stack overflow
14:34:49 <acowley> byorgey: Trulse
14:35:10 <shachaf> russellw: Why is Bool = Bit? Because there are only two of both of them?
14:35:11 <Makoryu> I mean it doesn't even make as much sense as Num instances for natural number types but, y'know, that's what we've got as far as syntactic sugar
14:35:24 <alistra> typo is an error when you mistakenly swithc tow lettesr or pit a different onr
14:35:26 <ksf_> actually, I think Integers take up a couple more bits than intptr_t
14:35:45 <russellw> sefb1704, though if you are going to program in Haskell, it is better to program in Haskell; if you want to program in C, you should use a C compiler. In other words, as long as you are using Haskell, it's probably better to use the boolean type the language provides
14:36:02 <shachaf> I don't think the argument to use Bool in Haskell is about efficiency.
14:36:07 <Makoryu> http://echo.rsmw.net/n00bfaq.html <- Hey do you guys remember this at all I think it's due for an update after what like two years
14:36:09 <ksf_> if anything, use Bool because that's what if uses.
14:36:18 <sefb1704> okey looks like im done here, special thanks to ksf_ for giving me some good hints how to improve my code, to byorgey for looking at my code in a better way than i did and to axman6 and acowley for being funny and helpfull
14:36:20 <shachaf> russellw: If Haskell had no Bool type, I would probably define one myself.
14:36:20 <Makoryu> Thinking about maybe cleaning up some of the drool
14:36:46 <Makoryu> Just noticed the other day that I still get hits for it so
14:36:52 <russellw> shachaf, consider digital logic, machine code and chip design. But like I said, I'm not expecting to convince you :-)
14:37:19 <shachaf> russellw: Plenty of people in this channel know C. If I was using C I would use an integer type to represent booleans.
14:37:44 <russellw> Fair enough, then we agree that one should work with the language one is using
14:37:48 <acowley> I use a Double# with an unsafe peek and poke at the 42nd bit for boolean values.
14:38:03 <shachaf> russellw: That's due to a shortcoming of the C type system, of course. :-)
14:38:46 * russellw likes the way the C type system mostly stays out of my way when I want it to stay out of my way :)
14:39:34 <Makoryu> The C type system is only there to facilitate compiler-blessed operator overloading and occasionally warn you if the building is on fire
14:40:34 <Peaker> Makoryu: using some techniques, the C type system can be extremely helpful
14:41:05 <Peaker> Makoryu: (e.g: wrapping ints in a struct as sort of a "newtype" helps it make sure you don't use the wrong kind of number)
14:41:06 <alistra> (void *) ftw
14:41:16 <alistra> fuck typesystems, anarchy
14:41:19 <NihilistDandy> @remember <Makoryu> The C type system is only there to facilitate compiler-blessed operator overloading and occasionally warn you if the building is on fire
14:41:19 <lambdabot> Good to know.
14:41:36 <Peaker> The C type system is less braindead about type coercions when it comes to callbacks
14:41:45 <Peaker> so callbacks are pretty well guarded against type errors
14:42:04 <NihilistDandy> alistra: I read that as a headline
14:42:10 <NihilistDandy> "Fuck typesystems, anarchy"
14:42:27 <alistra> yeah should be in the /topic
14:43:08 <russellw> There are Lisp programmers who like having no type system because it lets them store all data in lists until they need to optimize. I think that comes pretty close :)
14:43:38 <alistra> or you can use python with runtime types
14:43:59 <alistra> it's like C has a runtime null pointer dereference protection
14:44:40 <acowley> isn't that the fire alarm Makoryu was referring to?
14:45:11 <alistra> he said that compiler does that
14:45:18 <alistra> OS does segfaults
14:45:33 <acowley> ah yes, the outsourced fire alarm
14:45:38 <acowley> (now *that* is a pun)
14:45:43 <Axman6> :t sortBy
14:45:44 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:46:20 <alistra> didn't know that os is an acrocym
14:48:16 <Axman6> :t comparing
14:48:16 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:48:36 <alistra> :t on
14:48:37 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:48:43 <alistra> on is for real men
14:50:56 <Patinho`Busy> hi all o/
14:51:12 <acowley> \o
14:53:52 <acowley> Compiling the statistics package always makes my laptop weep, anyone know what the main compiling issues are with it?
14:53:52 <Makoryu> Man why did dons even bother posting links to this article that one time
14:53:52 <drull95> a lazy laptop?
14:53:52 <Makoryu> It was clearly an awful piece of shit
14:53:55 <drull95> what time?
14:54:06 <Makoryu> drull95: http://echo.rsmw.net/n00bfaq.html
14:55:03 <Makoryu> drull95: I linked this in here when I was writing it and asked for feedback, and instead of feedback I got traffic from reddit :p
14:55:49 <alistra> well it's crappy :P
14:56:12 <Makoryu> Yes it is
14:58:57 <Makoryu> But like is it worth updating and cleaning up
14:58:57 <alistra> srsly the only thing haskell has more than way to write fibonacci series are the crappy tutorials
14:58:57 <Makoryu> Or should I remove it from the internet altogether and burn every trace of it that was ever there
14:58:57 <Makoryu> Yeah
14:58:57 <Makoryu> It wasn't really supposed to be a tutorial
14:58:59 <Makoryu> Just sort of like a companion to the tutorials
14:59:40 <alistra> yeah delete it
14:59:41 <alistra> :D
14:59:46 <Makoryu> When I hung out here a lot people in their first couple weeks of learning it would always ask the same questions so this was basically just a collection of the answers I kept giving in slightly more depth
14:59:47 <alistra> and write a cool program instead
14:59:53 <alistra> do a xmonad killer
14:59:58 <Makoryu> I don't write cool programs I only write bad ones
15:00:00 <alistra> do an xmonad killer
15:00:16 <Makoryu> I'll write a program that literally stops execution of Xmonad
15:00:20 <Makoryu> How's that
15:00:32 <alistra> bleh, some of the contrib modules do it for me
15:00:36 <Makoryu> (I'll just farm out calls to "killall xmonad" or whatever)
15:00:42 <Makoryu> Heh
15:02:00 <alistra> but don't do a vi/emacs/make replacement in haskell
15:02:13 <Makoryu> Sure I'll make Textmate
15:02:19 <Makoryu> (...in Haskell)
15:02:23 <alistra> HextMate
15:02:26 <alistra> TextHate
15:02:33 <Makoryu> I like both of those
15:02:44 <drull95> Makoryu: it's not that bad. it could use some work
15:02:45 <ricree> if anything, we could probably use more articles along the lines of "Write yourself a Scheme in 48 Hours".  easily one of my favorite Haskell tutorials
15:02:46 <wereHamster> how do I skip the first two elements of a list?
15:02:47 <alistra> well nobody else will
15:02:55 <NihilistDandy> Yi's looking better, lately
15:02:58 <Makoryu> drull95: It needs a lot of work before it's actually presentable
15:03:06 <alistra> nobody will use them, because they have more popular alternatives
15:03:39 <ricree> wereHamster, the drop function
15:03:39 <alistra> wereHamster: tail . tail list
15:03:43 <Makoryu> drull95: And by posting links to it everywhere dons kind of turned me off of doing that work and then I didn't touch it for two years and lost the last version of the markdown file....
15:03:46 <Axman6> no!
15:03:51 <ksf_> if ghc builds successfully now, with -j5 disabled, I really feel like dropping everything and moving the build system over to shake.
15:03:57 <alistra> inb4 partial functions rant
15:04:01 * Axman6 smacks alistra 
15:04:27 <drull95> You can think of it as an informal post. Nothing wrong with that.
15:04:29 <alistra> Makoryu: convert it with pandoc
15:04:33 <alistra> from html to markdown
15:04:33 <ksf_> builds that don't make the cpu fan whine just aren't the same thing.
15:04:43 <Makoryu> alistra: BRILLIANT
16:06:47 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]'
16:06:47 --- topic: set by copumpkin!~pumpkin@unaffiliated/pumpkingod on [Sat Dec 17 14:06:48 2011]
16:06:47 -pratchett(freenode.net)- [freenode-info] channel flooding and no channel staff around to help? Please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
16:08:01 <shapr> acowley: report it!
16:08:14 <acowley> shapr: it's so complicated to reproduce :(
16:08:36 <acowley> shapr: I'll have to spend some time trying to reduce it before I can file anything
16:08:46 <acowley> shapr: also, maybe 7.4 will be fixed
16:08:55 <shapr> acowley: Still would be handy for regression testing.
16:08:57 <alistra> maybe it didn't segfault all along
16:09:01 <shapr> ?
16:09:14 <alistra> maybe he was dead in the freezer
16:09:41 <shapr> alistra: Do you have GHC 7.4 on your system?
16:09:48 <shapr> You could test it!
16:09:54 <acowley> I thought the cook was dead in the freezer
16:09:55 <alistra> 7.0.4 :|
16:10:05 <alistra> acowley: it was a dexter reference
16:10:13 <alistra> the tv show
16:10:16 <acowley> alistra: mine was a clue reference
16:10:18 <acowley> the movie
16:10:23 <acowley> :P
16:10:31 <alistra> i assume more was the more recent one
16:10:45 <alistra> i don't want to have ghc 7.4
16:10:49 <shapr> Why not?
16:10:50 <alistra> it'll break everything
16:10:58 <alistra> like a million cabal packages
16:11:00 <acowley> actually, I'm on 7.2.1
16:11:12 <alistra> there should be something like rvm
16:11:17 <alistra> for ghcs
16:11:17 <shapr> alistra: You'd have the chance to fix them!
16:11:28 <alistra> yeah fix cabal
16:11:33 <alistra> :/
16:11:40 <alistra> it makes me cry sometimes
16:11:42 <shapr> Hey, cabal is way better than what came before!
16:12:04 <alistra> yeah, but still it isn't a haskell package manager
16:12:13 <shapr> alistra: You could fix it?
16:12:24 <alistra> fix what?
16:12:38 <shapr> If you want cabal to be a Haskell package manager, you could add that functionality?
16:12:43 <alistra> i don't know how cabal works, i don't know why it randomly crashes
16:12:56 <alistra> i don't know if it's desired
16:12:58 <shapr> So, this is an opportunity to learn lots of stuff?
16:13:06 <shapr> alistra: If you desire it, then it is desired?
16:13:18 <alistra> meh, i don't really want to write cabal
16:13:24 <alistra> i have other things to write first
16:13:28 <alistra> that need cabal
16:13:30 <alistra> to be working
16:13:31 <shapr> Oh. What are you working on now?
16:13:51 <alistra> http://github.com/alistra/data-structure-inferrer
16:14:03 <alistra> not sure if the descriptions tells enought about it
16:14:12 <alistra> but i never was good at describing stuff
16:14:27 <shapr> Sounds nifty, but I don't understand how it works.
16:14:58 <alistra> well it chooses the fastest data structure for you based on what operations you've used
16:15:00 <alistra> in the source code
16:15:13 <alistra> the less you use, the more the chance for a faster structure
16:15:16 <shapr> Oh, I see! you tell it which standard data structure operations are used, perhaps with what frequency, and it recommends a data structure.
16:15:24 <alistra> yeah
16:15:28 <shapr> That's nifty.
16:15:30 <alistra> exactly that
16:15:45 <alistra> so you don't have to go to the algorithms course
16:15:46 <luite> how does it determine which is the fasted?
16:15:48 <shapr> alistra: Neat, is it on hackage?
16:15:52 <luite> fastest
16:16:04 <acowley> luite: const IntMap
16:16:15 <alistra> luite: complexity wise
16:16:24 <alistra> i have a file with complexities filled in :P
16:16:41 <alistra> shapr: not yet, but it has a cabal file :P
16:16:54 <acowley> That's actually very cool, alistra. But is it entirely amenable to static analysis?
16:17:10 <alistra> it's kinda work in progress, works for some toy language, now working on the C parser
16:17:32 <acowley> that is, doesn't the size and distribution of data at runtime have a bearing on this decision
16:17:34 <alistra> i don't know what amenable means
16:17:41 <luite> acowley: uh I don't really understand... does it check how often you use each operation?
16:17:51 <alistra> acowley: yes it has, it's the main problem :P
16:18:00 <alistra> you can probably add pragmas or use gprof
16:18:06 <alistra> or something like that to help
16:18:08 <shapr> If you had a profiled run saved, and the source code, that would work.
16:18:12 <acowley> yeah
16:18:25 <shapr> Then you'd say "inserted X times, deleted Y times" and that sort of thing.
16:18:29 <alistra> or it can transform the structure
16:18:32 <alistra> in runtime
16:19:01 <alistra> for example if you have n = 30 elements and you already done like 30 operations that would indicate that other structure would be handy
16:19:02 <shapr> The combination of which calls are used and with what frequency is a good way to figure out what data structure would likely be best.
16:19:09 <shapr> alistra: Can it suggest fingertrees?
16:19:17 <alistra> than you transform it (ski rental problem)
16:19:35 <acowley> I can rent ski?
16:19:43 <alistra> shapr: i thought of some dummy functions like load(real_call(ds, 5), 0.4)
16:19:52 <acowley> so this is like -fdons
16:19:57 <shapr> acowley: Er, that's short hand for "when is it cheaper to buy the ski rental company instead of renting more skis?"
16:19:57 <alistra> so you can put a multiplier by yourself
16:20:17 <alistra> shapr: i don't know how fingertrees work, i assume their more used in functional languages?
16:20:28 <alistra> acowley: -fdons?
16:20:30 <acowley> darn, I thought it was farming out data transformation decisions to ski
16:20:41 <alistra> http://en.wikipedia.org/wiki/Ski_rental_problem ski rental
16:20:42 <shapr> ski is quite good at Haskell.
16:20:45 <alistra> on-line costs
16:21:19 <alistra> you rent skis till sum of the rental >= cost of the skis
16:21:23 <alistra> then you buy the skis
16:21:34 <alistra> so the worst case factor of 2 :P
16:22:09 <alistra> it's more of a theoretical thing, i don't think it would be a good idea to transform based on that, it needs some heurisitcs
16:22:27 <alistra> what's a ski that acowley and shapr are talking about?
16:22:31 <luite> "Assume that renting skis costs $1 per day and buying skis costs $10" ugh I wish ;)
16:22:50 <alistra> i usually heard the version with 100$ :D
16:22:57 <acowley> ski is a #haskell regular
16:23:09 <alistra> ah, a person
16:23:23 <luite> still rather cheap ski's, I'd say more like $500-$1000 for a pair of good ones
16:23:45 <NihilistDandy> SKI is free
16:24:01 <alistra> well, the problem probably was invented in times when inflation was lower
16:25:11 <alistra> and that's basically what i need cabal for
16:26:21 <acowley> combating inflation
16:26:51 <alistra> yeah, i miss those times, when people cared about each other
16:26:56 <alistra> not that rat race
16:27:05 <shapr> Is there a Haskell library for working with SVG?
16:27:06 <alistra> <hippie bullshit here>
16:27:09 <shapr> @hackage SVG
16:27:09 <lambdabot> http://hackage.haskell.org/package/SVG
16:27:11 <shapr> hrm
16:27:16 <acowley> cunningly hidden
16:27:52 <NihilistDandy> The opaqueness of Haskell even extends to its package naming scheme~
16:27:55 <shapr> Aha, SVGPath parses the path command of SVG
16:28:17 * shapr tries
16:28:55 <alistra> you have to have FirstnameLastname login on hackage?
16:29:02 <alistra> that's homosexual
16:29:06 <shapr> Er, what?
16:29:17 <shapr> alistra: That's not a nice thing to say.
16:29:24 <shapr> alistra: Perhaps you could request a wiki login?
16:29:45 <alistra> what's a wiki login
16:29:53 <c_wraith> further more, it's factually wrong.
16:30:02 <dday> alistra: there are people without the FirstnameLastname format on hackage
16:30:02 <ddarius> Pah!  Facts.
16:30:03 <c_wraith> There are many hackage accounts that aren't firstnamelastname
16:30:07 <dday> you just have to look more carefully
16:30:23 <alistra> Getting a Hackage username
16:30:24 <alistra> If you need a username, please send mail to ross@soi.city.ac.uk. Your username will be your name in CamelCase (e.g. "JosephBloggs", those already registered). Any real person with a Cabal package to upload is welcome.
16:30:26 <dday> there are no actual restrictions on it, other than what the guy you e-mail wants to give out
16:30:29 <alistra> http://hackage.haskell.org/cgi-bin/hackage-scripts/list-users
16:30:42 <shapr> alistra: Do try to be nice, that's the recipe for success in the #haskell community.
16:30:43 <dday> alistra: yes, scan carefully through list-users
16:31:49 <dday> actually, don't do that, it's terribly boring.
16:31:57 <dday> but just send an email with your desired camelcase username
16:32:06 <alistra> dday: they all look like names to me
16:33:19 <dday> alistra: I think it encourages responsibility for your packages.
16:34:20 <alistra> real names?
16:34:55 <alistra> more like artificially introduces seriousness
16:35:06 <NihilistDandy> Is your name embarrassing or something?
16:35:13 <dday> well, I can understand the desire for privacy
16:35:33 <dday> then again, there's no reason you need to distribute your package with hackage (you can use github, darcsden, ___, ... )
16:36:08 <alistra> no, but i like my nickname
16:36:19 <shapr> So, request that?
16:36:49 <alistra> that just seems arbitrary
16:36:58 <alistra> unnecesary step that a person has to do
16:36:59 <dday> alistra: as I said above
16:37:15 <shapr> The reason for the FirstLast is that logins for the Haskell wikiwiki were used when cabal started.
16:37:31 <dday> these aren't hard and fast rules. It really is as simple as, what the guy who maintains hackage will agree to assign you.
16:37:34 <dday> Same goes with package names
16:37:37 <shapr> And wikis originally used CamelCase to make a link from plain text markup.
16:38:32 * shapr learns about SVG
16:39:08 <mm_freak> isn't it possible to backport the PolyKinds and ConstraintKinds extensions to GHC 7.0?  those extensions are so extremely useful, but going to 7.4 breaks too many things =/
16:39:43 <dday> mm_freak: does going to 7.2.1 break those things?
16:40:24 <gienah> mm_freak: some stuff seems to compile with ghc 7.4 ss after some tweaks (snap, hoogle, hlint)
16:40:30 <mm_freak> not sure…  if 7.2.1 still has base 4.4 and Num depending on Eq and Show, then that shouldn't break anything i'm using
16:40:32 <NihilistDandy> 7.2.1's been nice. Not nearly as much dep massaging required to build things
16:40:48 * ddarius is always amused at the people who are like "I can't -live- without this latest, not-yet-released extension"
16:40:58 <mm_freak> gienah: yes, i've done that actually, but it was an hour of work for all the stuff i'm using
16:41:14 <mm_freak> and i didn't even bother to try installing yesod
16:41:16 <dday> mm_freak: I think, though, there was some internal work that comes out with 7.4 about kinds
16:41:24 <dday> maybe it's totally seperate -- the constraint solver?
16:41:29 * ddarius would much, much, much rather the GHC team spend more time developing features people can't live without than backporting these features to old versions of GHC.
16:41:39 * dday is fuzzy on the 7.4 release notes
16:41:39 <gienah> mm_freak: for both happs and persistent get a type error in ghc 7.4 ss that I don't really get
16:41:40 <mm_freak> ddarius: seriously my application would really benefit from those, because i'm doing a lot of type level stuff
16:42:29 <gienah> mm_freak: I think it would be a cool idea to patch yesod, happs and other stuff to build with ghc 7.4 ss
16:42:31 <mm_freak> gienah: complaining about Eq or Show?
16:42:40 <shapr> I am sad to announce that Haskell is now considered successful :-(
16:42:44 <ddarius> mm_freak: Presumably many applications would benefit from most extensions hence them being developed.  Still, GHC has existed for twenty years without these extensions.
16:42:47 <gienah> mm_freak: no that error is easy to patch
16:42:57 <mm_freak> gienah: that's why i'm asking =)
16:42:57 <Philippa> ddarius: yeah. It's annoying me that I can't have ConstraintKinds in the Platform yet, but...
16:43:05 <Philippa> (...amongst other things, you know why I'm waiting for them)
16:43:06 <Axman6> shapr: :'(
16:43:10 <Philippa> shachaf: who by?
16:43:16 <Philippa> shapr, even?
16:43:30 <shapr> When people feel that updating existing code will be more effort than backporting features to earlier versions of GHC, Haskell is now considered successful.
16:43:49 <NihilistDandy> lol
16:44:10 <Philippa> heh
16:44:11 <BMeph> shapr: I.e., a failure? ;þ
16:44:12 <mm_freak> ddarius: i get your point, but still i've tasted GHC 7.4 yesterday and it was amazing how my code collapsed to only 30% of the current one with the extensions
16:44:33 <ddarius> shapr: Yes, but it's one thing when it's -me- who has to update code, it's another when it's me simply telling -someone else- to backport some code.
16:44:49 <mm_freak> i'd be happy to have only ConstraintKinds…  PolyKinds would be nice, too, but it didn't make much of a difference
16:44:51 <ddarius> mm_freak: So in 6 months you can do that refactoring.
16:45:18 <NihilistDandy> Or spend all that time waiting updating other people's code
16:46:09 <hpaste> gienah pasted “persistent happs ghc 7.4 errors” at http://hpaste.org/55529
16:46:23 <mm_freak> well, i could also try mailing hundreds of authors/maintainers to update their dependencies and make the code adjustments, but that's probably a waste of time =)
16:46:25 <alistra> what's so cool about ghc 7.4?
16:46:30 <ddarius> NihilistDandy: Yes, but that's 1) generally useful, 2) probably a -whole- lot less work that backporting these features, 3) has -you- do the work rather than Simon who doesn't have an incentive, and 4) moves the entire ecology forward rather than backward
16:46:40 <mm_freak> alistra: ConstraintKinds and PolyKinds
16:46:42 <Philippa> ddarius: I should probably start agitating for the necessary improvements to the libraries somewhere, though
16:47:07 <NihilistDandy> ddarius: Oh, man. I WILL NOT STAND FOR THAT
16:47:09 <Philippa> ConstraintKinds gives you things like associated classes
16:47:17 <gienah> mm_freak: I pasted the persistent and happstack-server errors in case anyone has any ideas on how to patch them :-)
16:47:29 <NihilistDandy> alistra: It's shiny and pretty and new and OMG~
16:47:53 <shapr> Associated classes are really awesome!
16:48:06 <Philippa> the biggest use by far I have for associated classes is letting you have functors that target a subcategory rather than everything
16:48:08 <shapr> You have class synonyms, sort of.
16:48:45 <Philippa> that entails... definitely the biggest shift since applicative functors, and possibly the biggest since we had a decent library of monad transformers
16:49:23 <mm_freak> gienah: the happstack-server error is because Num is not a subclass of Eq anymore…  it's easy to solve by adding an Eq constraint to the type
16:49:33 <mm_freak> gienah: for the other one i'd need to see the code
16:49:51 <alistra> mm_freak: yeah i don't know if I'll use those extenstions by glancing at them
16:50:00 <alistra> NihilistDandy sure has a better reason
16:50:15 <mm_freak> Philippa: my main use for ConstraintKinds was an Exists type
16:50:53 <Philippa> how big's the annotation burden in practice?
16:51:04 <Philippa> (I guess including instance writing)
16:51:56 <gienah> mm_freak: thanks, looking at the happstack-server error I see its much the same as errors on other pkgs I patched, the persistent error is more tricky
16:52:13 <mm_freak> well, currently i have to define many existential types to get around using CPS
16:52:23 <mm_freak> with ConstraintKinds i'd need only one
16:53:28 <mm_freak> taking modular arithmetic with type level moduli as an example i have "data ModP = forall n. Modulus n => ModP n" and "reifyModulus :: Integral a => a -> ModP"
16:53:48 <gienah> mm_freak: the persistent code is here: https://github.com/yesodweb/persistent/blob/master/persistent/Database/Persist/Base.hs
16:54:13 <mm_freak> with this proxy type i get around using CPS, hence rescuing MonadFix and ArrowLoop
16:54:58 <NihilistDandy> What's wrong with CPS?
16:55:31 <mm_freak> NihilistDandy: nothing, until you use mfix and loop
16:56:22 <mm_freak> gienah: ok, that one is more involved…  i'll leave fixing that to snoyman =P
16:56:55 <Siva> hi
16:57:00 <gienah> mm_freak: ok, thanks, will try asking in #yesod
16:57:02 <mm_freak> hello there Siva
16:58:31 <Siva> Good. This is the first time I'm hearing about haskell
16:58:52 <NihilistDandy> Oh, no, we really are successful~
16:58:52 <shapr> Did you hear good things so far?
16:58:53 <gienah> mm_freak: most of the tweaks for ghc 7.4 are fairly simple, they are in the recent history on: https://github.com/gentoo-haskell/gentoo-haskell/commits/master/
16:59:28 <mm_freak> gienah: yeah, i could fix all packages to build on my system, but it was too much work
16:59:39 <shapr> Siva: What do you think so far? Good stuff? Interesting?
16:59:56 <gienah> mm_freak: of those vector-algorithms required some experimentation, and hint required porting it to ghc 7.4 ss (working on upstreaming the hint patch)
17:00:02 <Siva> intersting, but not sure how to use in real world applications though..
17:00:18 <shapr> Siva: Do you have any particular real world applications in mind?
17:00:29 <shapr> Siva: I'm learning to build web applications with the Yesod framework right now.
17:00:40 <Siva> wow..I was about to say that
17:01:04 <acowley> @faq Can mastering Haskell let you read the minds of others?
17:01:04 <lambdabot> The answer is: Yes! Haskell can do that.
17:01:20 <Siva> Im just wondering there new things coming like Scala...
17:01:31 <gienah> mm_freak: another idea then is gentoo prefix (or linux chroot) with the gentoo haskell overlay: http://www.gentoo.org/proj/en/gentoo-alt/prefix/
17:01:32 <shapr> I've built webapps with Python, C# and Java, but I enjoy writing Haskell more...
17:01:42 <Siva> oh is it
17:02:01 <mm_freak> gienah: dunno…  my main problems were pandoc and hakyll…  after fixing those most things compiled cleanly
17:02:14 <shapr> Siva: There's a great tutorial for the Yesod framework if you want to build dynamic webapps.
17:02:17 <Siva> do you foresee it as a next big thing...
17:02:24 <Siva> Can you share the link of yesod
17:02:27 <NihilistDandy> God, I hope not
17:02:33 <Siva> will have a try at it
17:02:37 <shapr> Siva: If you're looking for a jekyll clone, then there's hakyll, which I use for my blog: http://www.scannedinavian.com/
17:02:43 <mm_freak> Siva: haskell is a big thing for years now…  everybody is talking about it, but nobody is actually learning it =)
17:02:44 <Philippa> I suspect Haskell's more likely to be an ongoing middling thing than a big thing - certainly not Java-scale
17:02:55 <shapr> Siva: Here's the link to Yesod: http://www.yesodweb.com/
17:03:02 <gienah> mm_freak: app-text/pandoc-1.8.2.1 builds with ghc 7.4 snapshot
17:03:06 <shapr> mm_freak: Ah, I disagree, *lots* of people are learning it from my viewpoint!
17:03:12 <NihilistDandy> mm_freak: Where as Java's the other way
17:03:15 <NihilistDandy> *whereas
17:03:15 <mm_freak> gienah: i don't have gentoo
17:03:49 <Philippa> shapr: it's certainly growing rather, isn't it?
17:03:49 <mm_freak> shapr: of course, lots of people learn the basics and are done =)
17:03:51 <Makoryu> shapr: Hmm, does Hakyll have a lightweight server/autoregeneration feature like Jekyll does?
17:04:10 <mm_freak> Makoryu: yes
17:04:17 <Makoryu> Handy
17:04:20 <gienah> mm_freak: gentoo prefix might work linux, macosx, solaris, etc, however I don't have access to any of these other systems to test with, so it might require tweaks
17:04:30 <mm_freak> Makoryu: optionally it can start a (snap-based) preview server for you
17:04:35 <shapr> Makoryu: Hakyll generates static pages, and only regenerates when files are changed, or if you explicitly request a full regen.
17:05:10 <mm_freak> gienah: i'm considering (for a few months now) moving to NixOS, where i could easily have multiple versions of GHC installed side by side
17:05:20 <Siva> wow.
17:05:22 <mm_freak> NixOS seems to be very promising as a development platform
17:05:30 <NihilistDandy> mm_freak: Can't you do that now?
17:05:33 <Siva> I came to know about this from the book on Functional Programming
17:05:45 <shapr> Makoryu: I stole my website from beastaugh, and his website repo is here: https://github.com/beastaugh/extralogical.net so you can see exactly what is required.
17:05:50 <mm_freak> NihilistDandy: not through the package manager…  and it wouldn't be as easy to switch between versions
17:05:57 <NihilistDandy> Ah, I see
17:05:57 <shapr> Siva: Oh, which book on FP?
17:06:03 <gienah> mm_freak: nixos does look really cool, peter seems to be doing lots of haskell stuff with it
17:06:21 <NihilistDandy> I'm on OS X, so I just have the last few versions all playing next to each other :D
17:06:29 <mm_freak> NihilistDandy: with NixOS i can install multiple versions of all packages, not only GHC…  the package manager keeps the dependencies consistent
17:06:31 <Makoryu> shapr: I actually looked at it before but couldn't get it working on my website and wound up just going with Jekyll... Might have another look
17:06:31 <Siva> FP on C# by Oliver strum
17:06:47 <shapr> Oh, C# supports FP surprisingly well.
17:07:04 <shapr> gienah: Peter Thiemann?
17:07:08 <shapr> Which Peter?
17:07:13 <shapr> Peter Simons?
17:07:23 <Siva> Actually I was thinking there too many tech around so wondering Haskell would be limited to certain areas of application?
17:07:26 <mm_freak> gienah: yes, but i'm still hesitating…  i'm not sure if it's ready for production
17:07:53 <gienah> shapr: yes Peter Simons
17:08:01 <shapr> Siva: Yes, Haskell is not a good choice for hard real-time applications on embedded systems. But you can generate hard real-time code from Haskell.
17:08:22 <mm_freak> it's also funny how the project's website talks about all those good things about the declarative, purely functional package management, but then the package manager is written in C++ instead of haskell =)
17:08:59 <Siva> so most of the features of any programming language would be available in Haskel, right ?
17:09:10 <NihilistDandy> Siva: Theoretically, all of them are
17:09:14 <shapr> Siva: So, I wouldn't use a pure Haskell program to run an airplane, but I could use Haskell to generate code to run an airplane. The newly generated code would not use the Haskell runtime though.
17:09:31 <mm_freak> Siva: you can write all kinds of programs in haskell, but you don't get all kinds of language features
17:09:43 <Siva> ok
17:09:49 <mm_freak> haskell (intentionally!) lacks:  OOP, (language level) dynamic typing, etc.
17:09:52 <Siva> what about the IDE
17:09:58 <NihilistDandy> Siva: emacs
17:10:03 <Siva> ok
17:10:14 <NihilistDandy> Though really anything works
17:10:20 <NihilistDandy> There's Leksah and vi, too
17:10:21 <mm_freak> Siva: most haskellers use emacs or vim, but it's possible to use Eclipse, textmate, etc.
17:10:26 <shapr> Eclipse has Haskell support, but most people I've seen use emacs or vim.
17:10:36 <Siva> ok
17:10:38 <Philippa> jedit does a pretty good IDE impression for the most part too
17:11:11 <gienah> mm_freak: it is radical how nixos can handle different versions of packages. on gentoo we try to bump dependencies to keep a consistent set, but sometimes this is too difficult (recently monad-control-0.3* and gitannex)
17:11:40 <Siva> ok
17:11:46 <Siva> I have started downloading Haskell
17:11:50 <Makoryu> mm_freak: Man, I wouldn't recommend Textmate.... Maybe for reading code, but not writing it
17:12:00 <shapr> Siva: Also, for simple experiments lambdabot supports code execution.
17:12:07 <shapr> > map (+1) [1,2,3]
17:12:08 <lambdabot>   [2,3,4]
17:12:14 <Axman6> i don't have any problem using textmate for haskell
17:12:14 <Siva> how about Np++ do they have plugin for Haskell
17:12:25 <NihilistDandy> The plugin's outdated, but TextMate's not too bad. Still go with with emacs, any day
17:12:27 <Axman6> Siva: there's syntax highlighting
17:12:30 <shapr> I haven't heard of Np++, what's thata?
17:12:32 <mm_freak> gienah: yes, but that's not gentoo's fault…  nixos has an entirely different directory structure and deals with hashed derivations…  so unless the hash function is broken, you are guaranteed to get a consistent system, no matter what you install
17:12:35 <Siva> notepad++
17:12:37 <NihilistDandy> Though yi is approaching usability
17:12:53 <Siva> how haskell is licenced?
17:13:11 <mm_freak> Makoryu: i've seen someone working with textmate with syntax highlighting, that's why i mention it
17:13:27 <mm_freak> Siva: the haskell /implementations/ are mostly BSD-licensed
17:13:29 <shapr> Siva: Haskell is BSD licensed, so you can use it for free, and you can use it for a commercial product with no obligations.
17:13:41 <NihilistDandy> And you can license your code however you like
17:13:41 <Siva> ok good.
17:14:03 <shapr> Also, the Haskell community is friendly and helpful!
17:14:10 <Siva> I could see it :)
17:14:13 <Axman6> Siva: the language itself has a license?
17:14:24 <mm_freak> (i've often seen the BSD license as one of the major selling points to get haskell into commercial products)
17:14:42 <Makoryu> Axman6: In many (most?) jurisdictions, programming languages cannot be copyrighted
17:14:45 <mm_freak> (even though it doesn't really matter)
17:15:02 <NihilistDandy> Makoryu: I think that was Ax's point~
17:15:18 <Siva> Axman: No wondering if we have any implications.
17:15:19 <Makoryu> Oh yeah
17:15:34 <mm_freak> Siva: i suggest getting the haskell platform and start learning =)
17:16:18 <Siva> yeah. I'm installing couldnt wait more to see how we can leash it. But Im more looking at perspective of this being adopted widely in development.
17:16:55 <mm_freak> Siva: well, haskell is a great language, but it has a steep learning curve…  don't expect to learn it in a day or even a week
17:16:59 <NihilistDandy> Though text-0.11.1.9 is being awfully unfriendly to my memory :/
17:17:07 <Makoryu> Siva: It'll never be the next Java, if that's what you're asking
17:17:08 <mm_freak> i'm using haskell productively for years now, and still i'm learning haskell every day
17:17:33 <Siva> yeah
17:17:52 <Siva> Got it.
17:18:07 <Siva> Any books out there..
17:18:08 <Siva> ?
17:18:10 <Makoryu> Maybe the next Python though :p
17:18:12 <Makoryu> Yep
17:18:18 <Makoryu> A couple good ones
17:18:27 <mm_freak> that's also related to the fact that haskell is actually a language that evolves fast…  new language extensions, new libraries, new ideas, new design patterns, etc.
17:18:39 <Makoryu> Learn You A Haskell (LYAH) and Real World Haskell (RWH)
17:18:49 <Siva> thanks Makoryu.
17:18:51 <NihilistDandy> And Craft of Functional Programming
17:18:57 <shapr> Siva: I'd suggest http://learnyouahaskell.com/ and http://book.realworldhaskell.org/
17:19:22 <mm_freak> originally i've learned haskell with Yet Another Haskell Tutorial and The Haskell Road to Logic
17:19:30 <NihilistDandy> ^^
17:19:36 <mm_freak> the first one is good, the second one is also good, but very dry
17:19:48 <shapr> I learned Haskell by starting the #haskell channel and inviting people to show up who already knew how to write Haskell code.
17:19:52 <NihilistDandy> Or the (rather humorously named) Gentle Introduction to Haskell
17:20:21 <Philippa> it's amusing mostly because it's anachronistic, though
17:20:44 <mm_freak> the author should have named it like the latex book:  The (Not So) Gentle Introduction to Haskell
17:20:47 <Philippa> if you don't know a typed FPL already, you're not in the original target audience
17:20:48 <mm_freak> =)
17:21:05 <shapr> @quote brickbat
17:21:05 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
17:21:34 <ddarius> "Gentle Introduction" gentlest introduction since 1998.
17:21:56 <Philippa> it mostly worked for me to relearn it a year and a bit after I did Graham Hutton's module back in 2001
17:22:17 <hpc> i remember the gentle intro to monads being just haddock with a different table layout
17:22:20 <Philippa> but it's somewhat outdated on a number of fronts - it doesn't cover most of the Platform, for example
17:23:12 <mm_freak> in any case, nowadays i'd recommend LYAH…  i think it makes a good tradeoff between speed and precision
17:23:31 <mm_freak> i was surprised that LYAH actually made it into the german book stores (in english though)
17:23:38 <hpc> mm_freak: and just being generally easy to read
17:25:01 * ddarius wonders if people actually read what the Gentle Introduction purports to be.
17:25:33 <AfC> Emails from 12 hours ago on haskell-cafe are already in Google's search results. That's impressive.
17:26:17 <ddarius> AfC: I expect Google detects how often content changes and adjusts indexing frequency accordingly.
17:26:31 <mm_freak> yes, that's what google does
17:30:06 <Siva> Thank you all.Will have a try and see how much I can progress..Thanks again
17:35:22 <Axman6> :t splitAt
17:35:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:35:27 <Axman6> :t break
17:35:28 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:35:43 <Axman6> > break isDigit "hello7world"
17:35:44 <lambdabot>   ("hello","7world")
17:36:20 <drdo> Hmm, haskell-mode seems to break when using → in lambda with UnicodeSyntax
17:36:44 <Makoryu> Okay I never understood why someone would do that in real code
17:37:12 <drdo> Makoryu: Is that for me?
17:37:20 <Makoryu> ....Yes :(
17:37:30 <drdo> Why not? It's easier to type and nicer to read
17:37:32 <shapr> Makoryu: Pretty lambda stuff in emacs looks nice!
17:37:48 <Makoryu> drdo: How do you type it
17:37:58 <drdo> AltGr+o
17:37:58 <ddarius> drdo has a → button?
17:38:10 <Makoryu> drdo: ø
17:38:13 <drdo> I have all sorts of buttons ∀∃⇒⇒⇑⇓⇒⇑⇐⇐λαβ
17:38:32 <Makoryu> Well if you set up a custom keyboard layout for Haskell...
17:38:48 <drdo> Makoryu: It's not custom for haskell, i just have it like that everywhere
17:39:24 <AfC> If you're on Linux, you can assign a key as the Compose key, and then [Compose] + [-] + [>] gives you → for example
17:39:37 <drdo> Yes, but that's harder to type
17:39:57 <AfC> drdo: sure. But it's a big keyspace.
17:39:59 <drdo> Most default AltGr modified bindings are useless
17:40:08 <AfC> drdo: exactly
17:40:09 <drdo> Might as well make them useful
17:40:17 <AfC> drdo: oh, true, yes
17:40:24 <MiggyX> does anyone here use zeromq with Haskell?
17:40:25 <AfC> it would be lovely if keymap editors were easy to use
17:40:34 <drdo> AfC: I just use xmodmap
17:40:36 <drdo> not that bad
17:40:39 <shapr> AfC: xkeycaps is straightforward
17:40:48 <AfC> drdo: ok, just saying that you disqualified yourself from "easy"
17:40:50 <AfC> :)
17:40:55 <ddarius> I like asking questions whose responses provide less than a bit of information.
17:41:28 <Makoryu> ddarius: Or do you
17:41:36 <drdo> AfC: Eh, you just google what you want and put the code there
17:41:57 <shapr> Hm, I want a "gentle" guide to SVG. All these tutorials are way too slow.
17:42:07 <shapr> I mostly want to know what I need to do to manipulate SVG in Haskell.
17:42:25 * ddarius has only manipulated SVG with vim macros.
17:42:32 <monochrom> you could just treat SVG as XML
17:42:49 <shapr> monochrom: Yah, but I want slightly higher level operations than that.
17:43:19 <Makoryu> Hakyll sure has a lot of dependencies
17:44:07 <shapr> On the good side, the server side has zero dependencies!
17:44:41 * jessopher thinks of asciidoc and all its 2 gigs of dependencies
17:45:00 <Peaker> doh! Data.Elf fails to parse a real-world Elf's symtable
17:45:09 <Peaker> Gotta fallback to parsing readelf's output, I guess
17:45:22 <ddarius> Or fix Data.Elf.
17:45:28 <Axman6> Peaker: and report a bug
17:45:46 <Peaker> Yeah, I don't have time to dive in there and learn all about Elf's encoding :(
17:45:52 <monochrom> Data.Elf should be busy making Haskell toys for Santa at this time of the year :)
17:46:50 <shapr> monochrom: ha!
17:46:52 <AfC> heh
17:47:05 <AfC> That should make HWN
17:47:10 <shapr> totally
17:47:10 * ddarius finds monochrom's statement ambiguous.
17:48:12 <mm_freak> Makoryu: since hakyll produces static sites you could live without the preview server:  cabal install -f-previewServer hakyll
17:48:38 <Makoryu> mm_freak: Too late, it's installed
17:58:03 <Peaker> System.Process uses Strings for everything. Is there an equivalent with Bytestrings?
17:59:03 <Peaker> I see there's Unixutils.. but the only portable solution uses Strings? Echs
18:00:12 <ddarius> I don't recall what all is in System.Process, but from what I do recall, Strings make the most sense.
18:00:12 <drull95> if Data.Elf is lazy won't it start making presents on christmas day?
18:00:18 <ddarius> Why can't you just use pack?
18:00:25 <ddarius> unpack
18:00:31 <tromp> :t pack
18:00:32 <lambdabot> forall o n. (Newtype n o) => o -> n
18:00:47 <tromp> :t unpack
18:00:48 <lambdabot> forall n o. (Newtype n o) => n -> o
18:00:54 <Peaker> ddarius: would it fuse away the (:) cells?
18:01:59 <ddarius> Peaker: What exactly are you worried about?
18:02:58 <Peaker> ddarius: performance
18:03:16 <ddarius> What exact function are you worried about that has Strings instead of ByteStrings?
18:03:30 <Peaker> readProcessWithExitCode
18:04:10 <MiggyX> What's the best way to convert between ByteString and LazyByteString?  one function requires the Lazy version but the function that provides the input for it returns a ByteString
18:04:40 <mm_freak> MiggyX: the Lazy module provides fromChunks and toChunks
18:05:05 <mm_freak> a lazy bytestring is just a list of strict bytestrings, so you would use BL.fromChunks/BL.toChunks with B.concat
18:05:16 <ddarius> Peaker: Use createProcess.
18:05:43 <ddarius> Or runProcess.
18:05:53 <ddarius> Or runInteractiveCommand.
18:05:56 <MiggyX> mm_freak: thanks :)
18:06:05 <ddarius> Or runInteractiveProcess.
18:06:14 <sal23> MiggyX: this might help: http://goo.gl/7nfiS
18:07:42 <Peaker> ddarius: anything with a Handle, yeah :) Thanks
18:09:36 <sal23> is it possible to enforce basic length constraints in data constructor? I want to define a data constructor that has two vector members, and want to make sure that both members are of same length at the construction time
18:10:01 <gwern> hm.... so I want a function which will apply X to a list repeatedly, storing the result from each invocation, until the target list stops changing
18:10:06 <hpaste> sal23 pasted “A simple example” at http://hpaste.org/55530
18:10:40 <Peaker> ddarius: it's a bit annoying to create the pipe on my own
18:10:40 <gwern> @hoogle ([a] -> [a] -> [a]) -> [a] -> [[a]]
18:10:42 <lambdabot> No results found
18:11:29 <gwern> this function doesn't sound terribly easy to write. I wonder if it's related to the scanrs
18:11:42 <gwern> @hoogle scanr
18:11:43 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
18:11:43 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
18:11:43 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
18:11:54 <ddarius> Peaker: Just copy and paste the source code of readProcessWithExitCode and replace the String functions with ByteString functions.
18:13:34 <gwern> oh, maybe I can get away with iterate
18:13:41 <gwern> finally, I have a use for it
18:14:36 <drdo> Is there a bytestring function to get substring from a given index with a given length?
18:15:27 <ddarius> drdo: take len . drop index
18:16:57 <drdo> Won't that do 2 copies?
18:17:29 <ddarius> drdo: It will do a little bit of arithmetic.
18:17:58 <gwern> bwa ha ha: map (take 5) $ takeWhile (not . null) $ iterate (addedExtract . tail) $ parseTags src
18:18:11 <Peaker> if I want to parse some hex numbers from my bytestring, what's a simple good way, without unpacking to String?
18:18:43 <gwern> but seriously, is there a better way to get the effect of 'tail' here? it's the only way I thought of to 'shrink' the String that addedExtract is being invoked on each time
18:19:43 <gwern> Peaker: http://hackage.haskell.org/packages/archive/bytestring-nums/0.3.1/doc/html/Data-ByteString-Nums-Careless-Hex.html ?
18:24:47 <cl1> what text editor do y'all use for haskell?
18:25:07 * jessopher uses kate & emacs
18:25:21 * byorgey uses emacs + haskell-mode + ghc-mod
18:25:22 <shapr> I use emacs
18:25:27 <drdo> emacs
18:25:29 <shapr> byorgey: ghc-mod ?!
18:25:32 * shapr asks google
18:25:46 <byorgey> shapr: don't ask google, ask Hackage
18:25:49 <mm_freak> drdo: ByteString never copies strings unless you tell it to or it absolutely has to
18:25:52 * luite uses emacs + haskell-mode
18:26:01 <mm_freak> ⇐ emacs + haskell-mode
18:26:18 <jessopher> i would use leksah, but the only versions i can compile with my current set up are old and crusty
18:26:32 <luite> I've tried ghc-mod but couldn't get it to work properly
18:26:49 <mm_freak> ghc-mod in a nutshell?
18:27:07 <luite> it does completion and typechecking of your code
18:27:08 <luite> using ghc
18:27:15 <drdo> mm_freak: Hmm, how? Where do you keep the length?
18:27:16 <shapr> Certainly sounds awesome.
18:27:18 <cl1> ghc-mod in a nutshell: http://www.mew.org/~kazu/proj/ghc-mod/en/
18:27:39 <mm_freak> drdo: ByteString saves the length explicitly
18:27:52 <cl1> i am having difficulty adjusting to emacs
18:28:00 <drdo> mm_freak: What do you mean?
18:28:18 <cl1> and when I go to work and do C-x C-s i wipe out the current line ans save :|
18:28:20 <drdo> Ah, nevermind
18:28:26 <mm_freak> drdo: there are actual bytestrings in memory and then there are ByteString values, which are just references into slices of those strings
18:28:27 <cl1> I spend all day in visual studio at work
18:28:38 <drdo> mm_freak: yes of course i just realised that
18:29:02 <shapr> cl1: Visual Studio has emacs themed bindings.
18:29:13 <drdo> cl1: use emacs at work too!
18:29:17 <shapr> cl1: Visual Studio claims to be a rebindable editor in the style of emacs as well, but it's not really true.
18:29:25 <shapr> At least, it wasn't true of Visual Studio 2010
18:29:48 <mm_freak> emacs worked for me under windows
18:29:53 <mm_freak> but it's a long time ago
18:30:23 <shapr> I used emacs4win or whatever it's called for editing, then I would compile with Visual Studio.
18:30:25 <cl1> emacs works under windows, i'm just having trouble becuase all of the hotkeys i'm used to are not there
18:30:32 <shapr> But you can actually call the VS compiler from the command line, and go emacs all the way.
18:30:59 <cl1> does emacs have intellisense?
18:31:25 <drdo> what's intellisense'
18:31:26 <drdo> ?
18:31:44 <brisbin> MS function completion?
18:31:48 <mm_freak> context-sensitive completion, basically
18:31:49 <cl1> when i press . and type it gives me a list of possible things i can type
18:32:17 <brisbin> haskellmode can provide that
18:32:33 <mm_freak> emacs doesn't have something like that AFAIK, but i never really missed it in haskell
18:32:34 <cl1> i have haskellmode
18:32:50 <drdo> I'm trying to imagine why one would want that
18:32:59 <cl1> its faster to type
18:33:09 <shapr> only if you've adapted to intellisense
18:33:13 <mm_freak> intellisense is microsoft's solution to a problem they introduced themselves =)
18:33:15 <Sgeo> It makes it easier to discover what functions can be used?
18:33:18 <shapr> It's very much in the way if you already know what you want to type :-)
18:33:20 <brisbin> haskellmode-vim provides context completions so i assumed the emacs precursor would have it
18:33:21 <Sgeo> Discoverability
18:33:23 <drdo> What's wrong with regular completion?
18:33:41 <brisbin> define regular?
18:33:53 <drdo> no context
18:33:54 <shapr> Also, microsoft's languages have adapted to intellisense, which disturbs me a bit.
18:33:55 <cl1> Sgeo, that too
18:34:10 <cl1> plus it gives you the documentation for a method if you pause on it
18:34:12 <jessopher> drdo: it will suggest a lot more things you dont want
18:34:13 <shapr> That is, LINQ in C# puts the sql FROM part of the clause first so intellisense will work.
18:34:27 <mm_freak> cl1: would you agree that if you have to correct the third letter of an eight-letter word and you cursor is at the end, it's faster to just retype the whole word?
18:34:43 <shapr> I'm a big fan of hippie-expand in emacs.
18:35:08 <mm_freak> cl1: if not, then i can see why you /believe/ that typing is faster with intellisense ;)
18:35:37 <drdo> btw, how do you guys handle Haskell's horrible convention of camelCase?
18:35:37 <mm_freak> it actually makes you slower, and i used to disable it when i used C#/F#
18:35:50 <mm_freak> drdo: well, we handle it by not finding it horrible =)
18:35:59 <drdo> word movement doesn't work
18:36:03 <shapr> cl1: Anyway, if you like intellisense, there are some tricks such as eldoc
18:36:11 <Sgeo> shapr, isn't HaskellDB ordered similarly to LINQ, so why mightn't it come from there?
18:36:16 <shapr> But that just shows the type of a function when your cursor is on the function name.
18:36:21 <brisbin> drdo: i have the same problem with ruby_methods
18:36:21 <mm_freak> drdo: it does, if you have emacs and the capitalized-words-mode on
18:36:27 <shapr> Sgeo: I don't remember :-(
18:36:42 <cl1> mm_freak, i would retype that word
18:36:50 <drdo> everyone knows - is the second best separator after space :P
18:37:04 <cl1> ctrl+shift leftarrow and start typing
18:37:05 <shapr> drdo: I thought it was the period?
18:37:14 <drdo> nah, it's totally -
18:37:27 <mm_freak> drdo: actually i agree there, but i wouldn't trade "-"-containing operators for it
18:37:32 <shapr> foo.bar or foo-bar?
18:37:43 * jessopher thinks ~ is a suitable substitution
18:37:49 <shapr> foo~bar?
18:37:52 <jessopher> yeah!
18:37:53 <shapr> hm
18:37:59 <mm_freak> cl1: in emacs you would just type ^W, but nevermind…  you really don't need context-sensitive completion in haskell
18:38:03 <NihilistDandy> fuuu~
18:38:04 <drdo> ~ is too hard to type
18:38:07 <drdo> two keys
18:38:24 <mm_freak> cl1: for one thing you don't get objects with an overwhelming number of complicated methods
18:38:25 <NihilistDandy> drdo: Remap your keyboard
18:38:31 * jessopher falls back to the letter x as a separator
18:38:37 <shapr> cl1: So anyway, there are some emacs haskell-mode tools that will show you the type of a function during/after typing the function name. Would that fit into what you want?
18:38:47 <shapr> jessopher: I like ix as a separator.
18:39:02 <drdo> NihilistDandy: Get a none dead version too?
18:39:20 <cl1> shapr, maybe
18:39:37 <cl1> i can see how intellisense wouldn't fit in with haskell, i was just curious if emacs could do that
18:39:39 <shapr> cl1: What other functionality would you want?
18:40:07 <mm_freak> cl1: haskell has this nice property that function names and their types tell you how to use that function most of the time
18:40:12 <shapr> Now I've forgotten, does ghc core use xi or ix to replace . ?
18:40:25 <shapr> DataixInt ?
18:40:32 <ddarius> Neither.
18:40:39 <ddarius> preflex: zenc Data.Int
18:40:39 <preflex>  DataziInt
18:40:39 <NihilistDandy> shapr: zi
18:40:45 <mm_freak> cl1: you will get used to having a browser with your local haddock documentation, and if you know how to use your browser efficiently, then you are ready to go =)
18:40:47 <shapr> Oh right, thanks!
18:40:53 <cl1> debugging, go to definition, go back from definition to where you were, i guess list members that implement an interface doesn't apply here (lol)
18:41:20 <shapr> cl1: Oh! In that case etags and M-. and M-* will work fine.
18:41:28 <NihilistDandy> Had to give a big presentation on functional compilers the other day, and I translated some ExCore for one of the slides
18:41:41 <shapr> cl1: That's go to definition in emacs, and it works for any language that supports etags or ctags
18:41:43 <NihilistDandy> Made me very familiar with Z-enc :D
18:41:44 <mm_freak> cl1: well, note that most of your debugging is moved from run-time to compile-time
18:42:11 <shapr> But, it's a bit of pain in that tags tables are not updated at every compile, only when you explicitly reload them.
18:42:23 <shapr> So VS is actually nicer in that case :-/
18:42:29 <mm_freak> never used tags…  i use dabbrev-mode
18:42:34 <mm_freak> uhm
18:42:36 <mm_freak> not -mode
18:42:38 <mm_freak> dabbrev =)
18:42:46 <cl1> mm_freak, i like that, one of the reasons i liked ada so much
18:43:16 <shapr> mm_freak: hippie-expand does way more than dabbrev, and I could show you my customizations that make it a superset of dabbrev functionality.
18:43:16 <cl1> the debug at compile time thing that is
18:43:33 <mm_freak> shapr: didn't know that one…  i'll have a look into it
18:43:34 <shapr> emacs can jump to compile time errors with C-x `
18:43:35 <NihilistDandy> I've been liking yasnippet, as well
18:43:56 <mm_freak> cl1: http://www.haskell.org/haskellwiki/Why_Haskell_just_works
18:44:16 <cl1> i guess having to know the hot-keys up front instead of having a menu for everything is what is difficult
18:44:39 <NihilistDandy> M-`
18:44:57 <mm_freak> cl1: emacs has a menu, if you prefer
18:45:10 <mm_freak> but yes, i suggest you get used to the shortcuts
18:45:47 <cl1> i will get used to them, i just can't remember everything in one go
18:45:56 <mm_freak> all shortcuts invoke editor commands with reasonable names, which you can look up…  if you invoke an editor command with M-x, then emacs will even tell you what the shortcut is
18:46:13 <NihilistDandy> Love emacs
18:46:15 <mm_freak> and you can go both directions with C-h
18:46:26 <mm_freak> you can look up the command for a shortcut and vice versa
18:47:02 <mm_freak> and all haskell-related commands start with "haskell-"
18:47:07 <mm_freak> so just use completion =)
18:47:07 <NihilistDandy> shapr: Care to share your h-e settings?
18:50:14 <shapr> NihilistDandy: (setq hippie-expand-try-functions-list '(try-expand-dabbrev-visible try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-lisp-symbol-partially try-complete-lisp-symbol))
18:50:34 * jessopher uses emacs for single document editing only, because he has spaghetti fingers
18:50:36 <shapr> hippie-expand is actually a meta-expand, it uses dabbrev as one of its expand strategies.
18:50:53 <NihilistDandy> Yeah, I've been reading about it. Looks like fun
18:51:03 <mm_freak> jessopher: know your tools:  C-x b RET
18:51:10 <shapr> One reason I changed the default hippie-expand settins is that I often want to complete a word that's already visible on my screen in another buffer.
18:51:13 <NihilistDandy> My .emacs is a damn mess
18:52:12 <MaskRay> Which package does the module `GHC' belongs to?
18:52:16 <shapr> I've broken my .emacs up into files, that's the only way I could handle ~1700 lines of elisp.
18:53:23 <shapr> cl1: So anyway, if you want to do wizardly emacs stuff for Haskell, we can hook you up :-)
18:54:31 <cl1> shapr, good to know
18:54:42 <cl1> maybe i can get to where i do my c# in it too
18:54:51 <drull95> everyone should just use ed. it uses memory more efficiently and doesn't have all this bloat
18:54:54 <cl1> would be nice to have one editor for all my code
18:55:02 <cl1> drull95, lol
18:55:10 <cl1> i have used ed before it sucks ass
18:55:12 <cl1> through a straw
18:55:48 <drull95> but you could probably implement it in ten lines of haskell. how's that for an easy to learn yet powerful editor
18:56:07 <MaskRay> could someone instruct me on building ghc-mod?
18:56:16 <shapr> cabal install ghc-mod  ?
18:56:26 <MaskRay> cabal: cannot configure ghc-mod-1.0.4. It requires ghc -any
18:57:18 <cl1> drull95, touche
18:57:26 <MaskRay> shapr: There are some sources including `import GHC' while I don't know which package provides this module.
18:57:37 <shapr> MaskRay: Are you using cabal?
18:57:56 <shapr> MaskRay: Are you using hugs or something?
18:58:05 <cl1> for now i should just stick to learning the basics
18:58:09 <cl1> eldoc seems nice
18:58:22 <monochrom> ed? are you kidding? why do you even need ed? just cat > file.hs or copy con: file.hs
18:58:25 <MaskRay> shapr: ghc-7.0.4, cabal-1.10.2.0
18:58:53 <NihilistDandy> monochrom: cat? Are you kidding? All you need's a magnet and a steady hand.
18:59:23 <cl1> lol
18:59:31 <shapr> MaskRay: That says you have package ghc-7.0.4, which should fulfill ghc -any
18:59:45 <monochrom> because it's a remote ssh into a cloud server
19:00:23 <MaskRay> shapr: There are modules prefixed by `GHC', e.g. GHC.IO, GHC.Num.
19:00:28 <NihilistDandy> STEADIER
19:00:35 <monochrom> and if you mean the home computer, perhaps because the disk is an SSD
19:00:37 <MaskRay> shapr: But module `GHC' doesn't exist.
19:01:25 <MiggyX> hi guys, I'm trying to create a data type for some JSON but one of the field names is "type". I can't change the JSON, but type is a reserved word…  is there a work around for this?
19:01:34 <shapr> MaskRay: I'm confused :-(
19:01:36 <monochrom> but you're right, if it's an SSD at home, what you should do is switch off the computer, take out the SSD, now walk around to gain static on your body, then touch the right pins on the SSD
19:01:45 <shapr> MaskRay: What flavor of Linux are you using?
19:02:21 <NihilistDandy> monochrom: Now you're gettin' it :D
19:02:21 <MaskRay> shapr: Gentoo. I'm using the gentoo-haskell overlay.
19:02:34 <Axman6> i would guess there's no real GHC module, and it's part of the compiler...
19:02:52 <shapr> ManateeLazyCat: Whoa, we haven't seen you in months!
19:02:52 <gienah> MaskRay: you could ask us in #gentoo-haskell then
19:03:03 <shapr> MaskRay: Yes, #gentoo-haskell may be able to help?
19:03:16 <ManateeLazyCat> shapr: Hi
19:03:21 <shapr> howdy ManateeLazyCat !
19:03:22 <gienah> shapr: yes hopefully :-)
19:03:22 <ManateeLazyCat> shapr: I'm busy on Linux Deepin project, sorry.
19:03:26 <MaskRay> ManateeLazyCat: hi
19:03:32 <ManateeLazyCat> MaskRay: Hi.
19:03:49 <Axman6> ManateeLazyCat's alive :O
19:03:52 <ManateeLazyCat> hi all.
19:04:15 <monochrom> oh w00t it's a ManateeLazyCat!
19:04:17 <MaskRay> ManateeLazyCat: Can you point out the way to build `ghc-mod'?
19:04:39 <NihilistDandy> MaskRay: cabal install -v ghc-mod
19:04:45 <NihilistDandy> Then post the log on hpaste
19:04:51 <gienah> ManateeLazyCat: hi, I notice that there were 2 major api changes to dbus that break manatee, I emailed you a patch for the first set, but that is broken by the second dbus major api change and can not see how to patch manatee for that
19:04:53 <cl1> these are things i'm not quite ready for, but would like to know if emacs has them: sorce stepping while debugging, viewing the values of parameters in the stack while source stepping, attaching to multiple running processes while debugging?
19:05:02 <ManateeLazyCat> I'm busy on Linux Deepin, some Python code (Deepin Software Center), some JavaScript code (Deepin Gnome Shell), detail look: http://www.linuxdeepin.com/news/12-issue-news/35-linux-deepin-1112-beta2-release-out
19:05:29 <ManateeLazyCat> gienah: Yes, i got that mail, sorry, i'm sorry.
19:05:30 <monochrom> you're deep in linux deepin :)
19:05:38 <drull95> MiggyX, if you're spitting it out at some point you could create an identifier jsonType that will spit out as just "type"
19:05:39 <MaskRay> ManateeLazyCat: I am just fascinated by its assertion: providing completions for emacs.
19:05:50 <gienah> ManateeLazyCat: yes I undertand, its ok, dbus api changes seem difficult
19:05:58 <NihilistDandy> cl1: Source-stepping doesn't work quite the same way in functional languages, I imagine
19:06:31 <ManateeLazyCat> gienah: http://planet.linuxdeepin.com/wp-content/uploads/2011/12/%E6%B7%B1%E5%BA%A6%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%BF%83_001-300x212.png is the project i busy on recently.
19:06:31 <monochrom> ghci can do some kind of source stepping
19:06:51 <gienah> ManateeLazyCat: neat :-)
19:07:04 <MiggyX> drull95: thanks
19:07:10 <ManateeLazyCat> It will provide English version in 2.0
19:07:56 <ManateeLazyCat> Sorry, guys, i really miss you, i want write Haskell code everyday in company, but i can't since i'm lead to develop an generic OS, i can't use Haskell, i just can use Python and JavaScript or C
19:08:00 * hackagebot fast-logger 0.0.0 - A fast logging system  http://hackage.haskell.org/package/fast-logger-0.0.0 (KazuYamamoto)
19:08:23 <Axman6> ManateeLazyCat: you poor thing :(
19:08:49 <MaskRay> ManateeLazyCat: It complains 'Could not find module `GHC':
19:08:51 <gienah> ManateeLazyCat: yes I understand its useful to program stuff that puts food on the table :-)
19:09:24 <teurastaja> im a schemer seeking monadic insight
19:09:47 <ManateeLazyCat> MaskRay: gienah: Sorry, i know Manatee haven't update long long time, i will back to Haskell, but i'm not sure when.
19:09:54 <Axman6> look out guys, he's planning something!
19:10:04 <drull95> teurastaja, it's function composition with plumbing
19:10:06 <Axman6> teurastaja: what insight do you seek?
19:10:30 <ManateeLazyCat> I plan use Gobject-Inspection re-implement gtk2hs for better APIs update.
19:10:36 <ManateeLazyCat> But i can't promise when.
19:11:26 <gienah> ManateeLazyCat: ok, neat. it seems dbus-client has been merged into dbus, and it seems that some stuff that manatee was using was removed last time I looked
19:12:22 <monochrom> @quote nlogax array
19:12:23 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
19:12:37 <ManateeLazyCat> At now very like first time i said "Goodbye" to emacs community, i haven't write Haskell code some months, i don't know when time i login IRC next time, i don't know when time i can continue write Manatee project, i just can say "Sorry, guys!"
19:12:39 <teurastaja> monads are possible in scheme but they arent well explained except with haskell code
19:12:39 <cl1> monads are not like a burrito
19:12:45 <monochrom> IOW you're asking "I'm seeking array insight"
19:13:00 * hackagebot wai-logger 0.1.0 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.1.0 (KazuYamamoto)
19:13:02 * hackagebot partial-lens 0.0.1 - Haskell 98 Partial Lenses  http://hackage.haskell.org/package/partial-lens-0.0.1 (RussellOConnor)
19:13:18 <Axman6> cl1: except the burrito monad
19:13:18 <NihilistDandy> cl1: Except when they are
19:13:23 <Axman6> XD
19:13:26 <cl1> lol
19:13:39 * Axman6 would argu that monad transformers are kinda like a burrito
19:13:42 <Axman6> argue*
19:13:46 <teurastaja> i know how to use continuations but can i make monads with them?
19:13:51 <cl1> teurastaja, do you know what parametric polymorphism is?
19:14:05 <Axman6> teurastaja: you sure can, we have the Cont monad for just that purpose
19:14:07 <teurastaja> i can guess
19:14:21 <Axman6> @unmtl Cont r a
19:14:21 <lambdabot> (a -> r) -> r
19:14:39 <Axman6> @src Cont (>>=)
19:14:39 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
19:14:59 <NihilistDandy> http://blog.plover.com/prog/burritos.html
19:15:09 <teurastaja> problem is i cant read haskell for now
19:15:19 <Axman6> i think that basically translates into: m >>= k = \c -> m (\a -> k a c)
19:15:29 <cl1> i thought the whole do notation was specifically to make the continuations easier to deal with
19:15:40 <Axman6> teurastaja: time to learn you some haskell then!
19:15:42 <MaskRay> ManateeLazyCat: that's all right. thank you for so many goodies on emacs and haskell. don't consider maintainance as burdens or duties.
19:15:43 <Axman6> @where lyah
19:15:43 <lambdabot> http://www.learnyouahaskell.com/
19:16:37 <teurastaja> by the time it is there some explanation possible not in haskell?
19:16:38 <cl1> teurastaja, are you familiar with haskell at all?
19:17:08 <teurastaja> functional programming (impure) but not haskel
19:17:13 <teurastaja> *haskell
19:17:14 <monochrom> there are explanations in scala and clojure
19:17:28 <teurastaja> dont know those
19:17:31 <teurastaja> im a schemer
19:17:41 <cl1> i would read the learnyouahaskell
19:17:49 <NihilistDandy> http://okmij.org/ftp/Scheme/monad-in-Scheme.html
19:17:55 <NihilistDandy> If Oleg can't do it...
19:17:58 <Axman6> oleg!
19:18:00 <NihilistDandy> Explain, that is
19:18:04 * hackagebot wai-logger-prefork 0.1.0 - A logging system for preforked WAI apps  http://hackage.haskell.org/package/wai-logger-prefork-0.1.0 (KazuYamamoto)
19:18:06 * hackagebot wai-app-file-cgi 0.4.3 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.4.3 (KazuYamamoto)
19:18:06 <monochrom> that does it
19:18:08 * hackagebot mighttpd2 2.4.1 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.4.1 (KazuYamamoto)
19:18:28 <teurastaja> oleg: the author of many srfis
19:19:04 <cl1> teurastaja, if you think you can grok the haskell syntax, this goes straight into monads: http://www.haskell.org/haskellwiki/Typeclassopedia
19:21:23 <teurastaja> holy fuck i dont remember continuations being so cryptic
19:21:58 <Axman6> you might only be used to quite simple uses of continuations
19:22:05 <ManateeLazyCat> I will back to Haskell, i don't know when, but promise i will back.
19:23:14 <teurastaja> what might i not know about applications of continuations
19:23:15 <teurastaja> ?
19:23:46 <gienah> ManateeLazyCat: neat, undertand you are busy with other stuff
19:24:50 <cl1> does anyone have an opinion on the quality of this tutorial? http://book.realworldhaskell.org/read
19:25:00 <teurastaja> there arent so much you can do with them...
19:25:09 <byorgey> cl1: yes, it's quite good
19:25:13 <cl1> i found the lack of exercises in lyah to my detriment
19:25:22 <byorgey> I don't think RWH has exercises either
19:25:27 <Axman6> teurastaja: they're the mother of all monads.. you can implement most other monads in terms of the cont monad i believe
19:25:38 <Axman6> @google mother of all monads
19:25:40 <lambdabot> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
19:25:46 * monochrom imagines "a serially murdering monad"
19:26:02 <cl1> byorgey, the first few sections have had exercises
19:26:15 <Axman6> cl1: it's great. not as good for beginners as LYAH, but it helps you do a lot of advanced stuff quite easily
19:26:36 <byorgey> cl1: oh, ok, good
19:28:23 <Axman6> cl1: one of the nice things about RWH is that most chapters are easy to code along with
19:29:36 <Axman6> @hackage partial-lens
19:29:36 <lambdabot> http://hackage.haskell.org/package/partial-lens
19:31:07 <cl1> good, i learn better with practice than reading
19:31:16 <cl1> at least reading that much in one go
19:36:27 <cl1> my ghci prompt from now on: ~{{{{:>
19:36:32 <jessopher> does anyone know of something that uses ReadPrec in a basic way, that I might look over.
19:36:48 <cl1> possum prompt is what i call it
19:37:16 <Axman6> that looks like one of thos fake, american possums
19:37:18 <jessopher> cl1: looks kind of like an armadillo
19:37:43 <Axman6> armadillo would be closer, agreed
19:38:34 * jessopher thinks he should use readprec but doesnt know how
19:39:23 <NihilistDandy> I used to use λ> but the haskell-mode prompt hated it
19:39:33 <NihilistDandy> Or emacs hated it
19:39:35 <NihilistDandy> Or something
19:41:51 <teurastaja> you should work your debugging skills
19:41:57 <cl1> it was originally: roadkill ascii art
19:42:39 <NihilistDandy> teurastaja: Didn't care enough. I get zero joy from my prompt
19:42:54 <cl1> since haskell makes copies of everything, doesn't it use alot of memory?
19:43:17 <NihilistDandy> cl1: If you write your code too lazily, or too strictly, or...
19:43:18 <NihilistDandy> yes
19:43:24 <NihilistDandy> But it can also save a lot of space
19:43:33 <Axman6> cl1: it copies a lot less than you'd thing, and we have garbage collection for a reason
19:43:54 <NihilistDandy> Luckily, the copies are just the new data and a reference to the old unchanged data
19:43:55 <drdo> I never understood why people say lazyness improves effeciency in some cases
19:43:56 <Axman6> cl1: there are times when you can use a lot less memory than another language, thanks to laziness
19:44:07 <Axman6> drdo: because it can
19:44:12 <drdo> No it can't
19:44:24 <ski> teurastaja : re making monads with continuations, check out Andrzej Filinski's paper "Representing Monads" in 1994-01 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RM.ps.gz>
19:44:30 <cl1> i'm not lazy! i'm efficient!
19:44:33 <roconnor> who says haskell makes lots of copies?
19:44:44 <teurastaja> ski arent you a schemer?
19:44:53 <cl1> roconnor, i did
19:44:54 <roconnor> haskell copies very little since everything is immutable
19:45:05 <roconnor> no need to copy anything cause nothing changes
19:45:06 <drdo> People write different code in strict languages if doing the same as one would do with lazy eval would consume more memory
19:45:08 <Axman6> go look at the binary-trees benchmark on the language shootout. you'll see they had to change the rules because the Haskell entry was beating the pants of all the other languages, because GHc could asee it never needed to actually allocate the tree at all
19:45:27 <cl1> lol
19:45:31 <Axman6> drdo: we can write non-ugly code that does the same thing though
19:45:31 <jessopher> drdo: the same is true in reverse
19:45:55 <ski> teurastaja : i'm a haskeller (and a prologer) who has for a long time tried to better understand the scheme way. so i suppose in a sense i'm a schemer
19:46:00 <jessopher> if i tried to write infinite lists in a strict language, it would be horribly inefficient
19:46:16 <drdo> jessopher: Why?
19:46:19 <NihilistDandy> http://uai.sis.pitt.edu/displayArticleDetails.jsp?mmnu=2&smnu=2&author_id=84&article_id=190
19:46:20 <Axman6> jessopher: and also impossible
19:46:31 <drdo> Axman6: Possible and trivial
19:46:36 <cl1> Axman6, not true
19:46:58 <jessopher> axman: well the construction, in a lazy way
19:46:59 <Siva> is it possible do like min (2 2)?
19:47:02 <Axman6> how would you do it in C then?
19:47:03 <cl1> i can do it in c# and only return enough items to satisfy the requested amout
19:47:09 <Axman6> Siva: min 2 2
19:47:23 <jessopher> just add elements to an array in an infinite loop
19:47:27 <drdo> Axman6: You just do the obvious thing, keep a thunk
19:47:31 <mm_freak> Siva: "min (2 2)" applies min to the result of applying the number 2 to the function 2
19:47:35 <teurastaja> (circular-list 1 2 3) => 1 2 3 1 2 3 1 2 3 1 2 3 ....
19:47:39 <Siva> ok
19:47:56 <Axman6> drdo: but now it's not really a list, it's a structure that points to a thunk, which can produce the next element. that's not the same thing
19:47:57 <ski> teurastaja : to clarify what i (partly) mean by that, i'm mainly a "static typer", but precisely because of that i'm trying to understand the "dynamic typing" side of the fence. also i think continuations and macros (especially hygienic ones) are very cool and interesting :)
19:48:03 <mm_freak> Siva: not that it doesn't make sense, but it's likely not what you want =)
19:48:03 <Siva> but how succ ( 10 *  8) is handled
19:48:04 <drdo> Axman6:
19:48:07 <cl1> actually i can use the yield keyword implemented in an IEnumerator
19:48:16 <drdo> Meet Abstraction
19:48:22 <mm_freak> Siva: succ (10 * 8) = succ 80 = 81
19:48:29 <cl1> which is how you enumerate a list
19:48:34 <Siva> oh got it
19:48:35 <teurastaja> why hygenic ones more?
19:49:17 <cl1> i was jiust curious about memory, all these tutorials say they give you a copy.
19:49:24 <cl1> not that memory is expensive
19:49:42 <cl1> i believe that windows 7 pro will hold 192GB of memory now
19:49:51 <Axman6> cl1: they'll give you a copy, that points to a much of the old structure as possible
19:50:05 <jessopher> drdo: well the initial premise was that you were doing things with strict idioms in a lazy language, and this lead to inefficiency. If i infinitely constructed a linked list (a lazy idiom), in a strict language. it would block forever and allocate memory until it exploded
19:50:27 <ski> teurastaja : now try to make the idiom used in `circular-list' more composable -- i think you need a concept of "location" (or possibly "dataflow/logic variable" as in Prolog and Oz)
19:50:35 <Axman6> cl1: this is only safe in a language like haskell where data is immutable
19:50:44 <drdo> jessopher: not sure if serious
19:50:53 <ski> teurastaja : i know Racket has `shared', but that only partially solves the problem
19:51:00 <cl1> Axman6, that makes sense
19:51:09 <teurastaja> assignment is the easy way
19:51:27 <ski> teurastaja : yeah, which is why you would need locatives here
19:51:37 <ski> but assignment comes with a lot of problems
19:51:55 <Axman6> cl1: the simpleat example to see how this works is to implement a binary search tree, and then see that inserting elements into a tree gives you a new tree, but only log n nodes are new, and n - log n nodes are shared from the previous tree
19:52:25 <cl1> so the pointers are at different spots in the tree, so to speak
19:52:26 <ski> teurastaja : btw, `circular-list' doesn't handle the case of non-circular infinite lists (and yes, i know about SRFI 45)
19:52:42 <teurastaja> its srfi-1
19:52:57 <ski> teurastaja : "why hygenic ones more" -- because lexical scoping is the sane default
19:53:01 <Axman6> drdo: laziness isn;t just about program efficienct, it's also about programmer efficiency. we don't have to worry about things like implementi9ng our own thunks like you suggested is perfectly acceptable
19:53:24 <ski> teurastaja : that was re (possibly) infinite streams, not re `circular-list'
19:53:42 <teurastaja> what about using macros for circular lists?
19:53:45 <ehuber_> i have a very silly question .. the ghc docs for Data.Bytestring seem to imply that 'a' is a perfectly good Word8 literal (it isn't, and i understand why), so how can i use a Word8 literal?
19:54:00 <mm_freak> cl1: actually in a naively define data structure even the pointers aren't there until you ask for them…  that's what allows you to have infinite lists
19:54:05 <mm_freak> cl1: ones = 1 : ones
19:54:29 <mm_freak> the "ones" is completely opaque until you open it, at which point it expands to one more element
19:54:45 <ski> teurastaja : that helps, but doesn't solve the composability problem in general
19:55:13 <mm_freak> cl1: you can even print such a list, which will print an infinite sequence of ones in constant memory
19:55:17 <teurastaja> just using plain lambdas
19:55:21 <jessopher> strictness isnt 'about' program efficiency either.
19:56:03 <mm_freak> ehuber_: Word8 is a numeric type, so you would have to write numeric literals
19:56:15 <teurastaja> the lambdas delay the computation
19:56:17 <ehuber_> bummer. thanks
19:56:19 <mm_freak> ehuber_: you can convert Char literals using Data.Char.chr or you can just use the Char8 interface
19:56:36 <mm_freak> ehuber_: see Data.ByteString.Char8
19:56:43 <ski> teurastaja : then point is that we'd like to compose arbitrary third-party procedures which build list arguments into larger list results. then we'd like to tie a knot over these at some point, feeding back the result into the calls, as arguments
19:57:03 <mm_freak> ehuber_: additional note:  the ByteString types from both interfaces are the same, so you can use both interfaces at the same time
19:57:19 <ski> teurastaja : if we have locatives, we could have a procedure return a locative instead of taking a (not-yet-constructed) list as argument, then we could patch of that afterwards
19:57:26 <dolio> Why not use a non-strict language?
19:57:29 <dolio> They work great.
19:57:58 <cl1> i am not a fan of dynamic languages
19:58:07 <teurastaja> you could also plug the output port on the input port
19:58:09 <cl1> they make code that is difficult to maintain
19:58:25 <mm_freak> cl1: strictness is not related to types
19:58:47 <mm_freak> cl1: haskell is nonstrict and uses a static, strong type system
19:59:05 <dolio> A.K.A. a type system.
19:59:11 <mm_freak> ;)
19:59:16 <ski> teurastaja : yes, you can implement call-by-name and call-by-need in a strict language (which is what SRFI 45 does). but that's not what `circular-list' and `shared' is attempting to do
19:59:30 * cl1 misread strict for static
19:59:32 <cl1> dunno why
19:59:59 <mm_freak> i wonder if it's correct to say that haskell is nonstrict
20:00:07 <dolio> It is.
20:00:33 <mm_freak> it doesn't force strictness, but "haskell is nonstrict" would imply that there are no strict functions in a certain sense
20:00:35 <drdo> it's trivially correct
20:00:41 <cl1> isn't non-strictness how lazy evaluation works?
20:01:01 <mm_freak> cl1: nonstrictness is just semantics:  a function is strict on its argument, when f ⊥ = ⊥
20:01:12 <drdo> mm_freak: No, it just means it's not strict
20:01:22 <dolio> Being a non-strict language doesn't imply that no strict functions exist.
20:01:30 <dolio> If that were the case, it would be impossible to have a non-strict language.
20:01:41 <ehuber_> mm_freak: heh, just importing Data.ByteString.Char8 instead of just Data.ByteString solved that one problem while not causing any others. thanks :) i will look into why
20:02:09 <mm_freak> ehuber_: it just provides you a Char interface instead of a Word8 interface…  that's it =)
20:02:14 <cl1> I should stay out of this chat room. It's totally killing my productivity at learning haskell
20:02:20 <jessopher> dolio: thats a good point. at some granularity there is going to be strictness
20:03:11 <cl1> here is a real world question about haskell
20:03:22 <mm_freak> dolio: that's not really a justification…  a language is strict, when all functions are strict…  then there are two ways to interpret "nonstrict language"
20:03:49 <ehuber_> how about nonstrict and antistrict? :)
20:03:54 <mm_freak> 1. strictness is voluntary, 2. strictness is impossible
20:04:02 <mm_freak> ehuber_: sounds good =)
20:04:06 <ehuber_> nonstrict -> not all functions are strict, antistrict -> all functions are not strict
20:04:11 <ehuber_> hahaa
20:04:13 <drdo> I don't even know what it means for strictness to be impossible
20:04:26 <jessopher> yeah i dont get that either
20:04:37 <ski> teurastaja : anyway, that Filinski paper explains how you can turn any monadic effect into a *side*-effect, using (delimited) continuations
20:04:37 <dolio> The identity function is strict.
20:04:38 <tgeeky> drdo: computation that can be constructed but not executed?
20:04:41 <mm_freak> drdo: it means that you can't write strict functions, so you get no eager pattern matching and no seq =)
20:04:55 <drdo> tgeeky: That's missing the "computation" part isn't it? :P
20:04:56 <cl1> i have the need to create an object that is backed by an xml document. when that document is modified via properties on the object it also adds attributes to the xml that indicate the element was modified. what would be the haskell way to handle this?
20:05:03 <siva> Notepad++ seems to support Haskell. FYI.
20:05:08 <tgeeky> drdo: hey, I didn't say it made sense
20:05:12 <tgeeky> drdo: but I think that's what it means
20:05:20 * cl1 goes and checks out notepad++
20:05:34 <mm_freak> cl1: view both "object" and the XML as representations of some value
20:05:42 <dolio> So your second definition of a non-strict language must rule out the identity function.
20:05:49 <tgeeky> roconnor: what is this gem you bring me? partial lenses?
20:05:52 <tgeeky> roconnor: paper?
20:06:12 <mm_freak> dolio: correct…  i'm not saying that an "antistrict" language would be useful
20:06:23 <mm_freak> i'm really just playing with language
20:06:51 <ehuber_> that's why we're all here instead of #python or #ruby :D
20:06:56 <ski> teurastaja : so, e.g., if you define a parser monad, you can then "reflect" it, so that you can write `(let* ((term (parse-term)) (_ (parse-plus)) (expression (parse-expression))) (make-addition term expression))', including any implicit backtracking needed, when a branch in the parser turned out to be wrong
20:07:11 <drdo> I'm now going to start using the term "anti-useful"
20:08:12 <drdo> Hmm, what does "anti-useless" mean? Does it still mean "useless" ?
20:08:34 <mm_freak> cl1: data Document = Doc { docTitle :: Text, docContent :: Text, docModified :: Bool }
20:08:47 * jessopher thinks exclusionary language is 'anti-useful'
20:09:42 <ddarius> drdo: No.
20:09:46 <mm_freak> cl1: in haskell it's customary to represent values abstractly and go to more concrete representations like XML on the fly
20:10:07 <cl1> mm_freak: more like: data Person = Person { firstName :: Text, lastName :: Text, Age :: Int }
20:10:16 <cl1> how would i make that be backed by an xml document?
20:10:31 <mm_freak> cl1: does that XML document contain more information?
20:10:35 <drdo> ddarius: I think of it like this: anti-useful (< 0), useless (0), useful (> 0)
20:10:38 <cl1> it may
20:10:59 <mm_freak> cl1: is this information part of the person or can it be fed from outside?
20:11:08 <cl1> like when you set firstName, not only would it update the coresponding xml element, but also add an attribute stating that the element had been updated
20:12:01 <ddarius> drdo: Now all you have to do is go back and reread what you wrote.
20:12:05 <mm_freak> cl1: an ugly way to do it is:  data Person = Person { firstName :: Text, firstNameModified :: Bool, … }
20:12:27 <drdo> ddarius: I did, no changes
20:12:28 <mm_freak> cl1: a nicer way is:  data Proxy a = Proxy { pxValue :: a, pxModified :: Bool }
20:12:42 <cl1> this xml is the transport data mechanism in the distributed application,
20:12:51 <jessopher> drdo: anti does not mean less than lol
20:13:06 <mm_freak> cl1: XML is just a concrete representation…  as said, you would output XML on demand
20:13:09 <drdo> jessopher: I never said it did
20:13:11 <mm_freak> personXml :: Person -> Xml
20:13:18 <cl1> the concept is what we call a projection, it has more pieces, but basically a person can create an object and not care about the xml representation, or the data that is in the document that they don't need
20:13:45 <cl1> however if they send that xml to a different service than the one they got it from, the whole xml is sent
20:14:24 <cl1> so no information is lost yet the app does not have to deal with the data it does not care about
20:14:52 <mm_freak> cl1: well, tagging values with modification indicators should do the trick…  now just adjust the XML generator
20:14:54 <cl1> so i can't simply translate it into an object and translate it back, because some information would be lost
20:15:08 <mm_freak> personXml :: DocPart -> Person -> Xml
20:15:14 <mm_freak> data DocPart = Full | OnlyModified
20:15:57 <mm_freak> or even encode the source machine in the type, then the XML generator can decide based on target machine what kind of XML to generate
20:18:04 <jessopher> drdo: i never said you said it did. <-- anti-useful
20:19:31 <drdo> jessopher: :D
20:19:35 <jessopher> :P
20:21:51 <cl1> here is an example, we have a system that queries for all patients that are a certain step in some medical process, it knows to look for patients and it knows about the medical process. it sends those patients to a mailer program ...
20:22:10 <cl1> the mailer program knows that there are doctors associated with the patient and mails letters to them as well
20:22:51 <cl1> that last feature was built AFTER the one doing the original query, and the one doing the original query has not been modified since we added the functionality to mail letters to the doctors as well
20:22:55 <cl1> it still works
20:23:10 <cl1> becuase it doesn't touch the xml that it doesn't know about, but it is still there
20:23:28 <cl1> the mailer never queries for data, it is fed data from the other process
20:23:45 <cl1> so we are basically able to update parts of the system without having to change other parts
20:24:09 <cl1> its really cool
20:24:36 <cl1> its also a bitch to maintain
20:24:59 <cl1> i'm learning haskell to learn parsers from compiler theory so I can maintain this thing
20:25:41 <cl1> we have a backend that parses it from the mongodb (which i'm not to happy with mongodb) into the xml
20:26:23 <cl1> so when it hits the system its in the xml format that everyone agrees upon, but older systems only have to change if we alter the existing xml format. nothing happens when we add new stuff
20:26:41 <cl1> it appears I have shut up the whole room >_>
20:26:44 <cl1> <_<
20:26:48 <cl1> *crickets*
20:28:44 <Lucas_> what, exactly, are Haskell's paradigms?
20:29:32 <NihilistDandy> Functional and imperative, I suppose
20:29:42 <cl1> parametric polymorphism and functional programming
20:29:50 <Lucas_> hmm, thanks
20:29:51 <shachaf> The Fibonacci Paradigm.
20:29:51 <byorgey> cl1: perhaps you are interested in http://www.seas.upenn.edu/~harmony/ ?
20:29:53 <mm_freak> cl1: you can explain the current system as well as you want…  without sitting in front of it, you will hear lots of suggestions only a small subset of which is useful
20:30:06 <shachaf> Lucas_: The answers aren't going to tell you much.
20:30:21 <Lucas_> nah, I know how these work
20:30:23 <mm_freak> cl1: in other words:  you should go ahead and do an implementation, then ask how one could improve it
20:30:40 <Lucas_> just getting a preview
20:30:41 <MiggyX> cl1: don't like mongodb? :)
20:30:48 <cl1> so it is that complex, not a magic bullet in haskell to solve the problem
20:31:00 <rwbarton> Our two paradigms are functional, imperative, and type-level programming!
20:31:17 <mm_freak> cl1: haskell is a great language to implement solutions…  it doesn't do the thinking for you =)
20:31:33 <cl1> MiggyX, it has performance issues, buggy on things it shouldn't be buggy about
20:31:44 <mm_freak> cl1: solutions can be quite different depending on the problem…  it's not like in java where the solution to every problem is a class
20:31:47 <cl1> i'm wondering if couchDB would be better
20:32:28 <MiggyX> cl1: I'd be interested in hearing about performance issues. CouchDB is a very different approach to MDB though. Also if you're storing XML in MDB, you're missing out on a lot of benefits you would get from using JSON
20:32:34 <cl1> mm_freak, funny you say that, this whole implementation is to avoid the issues with classes as contracts
20:32:35 <mm_freak> CouchDB is ok, if you really want a schemaless database, but a schema is to databases what a type system is to a programming language
20:33:01 * hackagebot base16-bytestring 0.1.1.4 - Fast base16 (hex) encoding and decoding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.1.4 (BryanOSullivan)
20:33:18 <cl1> we are not storing xml in mongo, xml is the transport medium between distributed processes
20:33:21 <mm_freak> cl1: haskell goes for solutions, which are close to the problem being solved, so you basically get a domain-specific language for your problem and then solve it in that language
20:33:38 <drull95> rwbarton, your statement doesn't typecheck: two paradigms takes two arguments, given three
20:33:54 <cl1> mm_freak, that sounds promising
20:34:24 <cl1> schemas are old school, they don't scale well
20:34:38 <MiggyX> cl1: I'd still be interested in your performance issues. I use it to store around 21 million objects a day and even without indexes querying is pretty damn quick.
20:35:19 <mm_freak> cl1: if you know your RDBMS they scale very well
20:35:41 <cl1> MiggyX, maybe its a problem with the guys who built our framework then, LOL
20:35:50 <byorgey> drull95: there are two types of people in the world: those who can count, those who can't, and those who can count at the type level
20:35:53 <NihilistDandy> MongoDB is Web Scale
20:35:56 <ski> drull95 : it might be a finite presentation
20:36:23 <cl1> i know RDBMS, they do not scale like what i'm talking about without TONS of maintence
20:36:25 <mm_freak> cl1: problem with relational databases is that it's easy to get them wrong…  most users don't even know how to write proper SQL, much less how to write proper schemata
20:37:10 <cl1> mm_freak, i know databases fairly well
20:37:34 <mm_freak> cl1: then you shouldn't run into performance issues (or you're using mysql)
20:37:41 <NihilistDandy> +1 for use of "schemata"
20:38:09 <Axman6> i got a high distinction in my databases course, and i wouldn't pretend for a minute that i know much at all about how to use RDBMSs properly
20:38:14 <NihilistDandy> http://www.youtube.com/watch?v=b2F-DItXtZs
20:38:18 <rwbarton> drull95: It was supposed to be a Monty Python reference, but I didn't really follow through.
20:38:26 <NihilistDandy> Axman6: Same
20:38:28 <mm_freak> cl1: note:  my queries usually look like:  SELECT ml_add('my mailing list name');
20:38:31 <mm_freak> ;)
20:39:01 <drull95> it's alright, i was just making a joke, trying to sound like ghc
20:39:11 <Lucas_> uh, a question: I see that I can use a function in a body using the 'let' and 'in' keywords, but can I define a "permanent" function for all my code, some way?
20:39:13 <NihilistDandy> rwbarton: The Knights Who Can't Say Nil?
20:39:13 <hirc> does anybody know a hackage workaround for the problem reported in: http://hackage.haskell.org/trac/hackage/ticket/656
20:39:26 <drull95> ski: i looked that up and i almost understand it. now i have some reading, thanks :)
20:39:30 <mm_freak> Lucas_: sure, define it at the top level
20:39:33 <NihilistDandy> ^^
20:39:38 <mm_freak> i.e. non-indented
20:39:52 <Lucas_> in that case, what will be the body?
20:39:58 <Axman6> huh?
20:40:09 <ski> drull95 : hehe, it was meant as a (serious) joke
20:40:11 <mm_freak> Lucas_: whatever is on the right hand side of your =
20:40:37 <NihilistDandy> Lucas_: f x = x + 2
20:40:42 <rwbarton> NihilistDandy: That would be a great title for a blog post about... something.
20:40:44 <NihilistDandy> If you're in ghci
20:40:49 <NihilistDandy> let f x = x+2
20:40:49 <Lucas_> ah, that simple? :/
20:40:52 <NihilistDandy> Yp
20:40:54 <NihilistDandy> *Yup
20:40:58 <ski> drull95 : the point being that when you enumerate a bunch of things, you're not always claiming that all of them are necessarily different
20:41:02 <Lucas_> thanks a lot to all of you
20:41:35 <NihilistDandy> rwbarton: I think ekmett and byorgey already took all the good blog posting names
20:41:36 <drdo> hmm, i'm getting an "ambiguous occurence" error, but it's between something in Prelude and a module that is imported qualified
20:41:41 <drull95> i see, so functional paradigm and type-level paradigm could be the same
20:41:50 <mm_freak> Lucas_: notice the "where" in your module declaration?  "the top level" is the module scope =)
20:41:59 <NihilistDandy> drdo: What's the occurrence?
20:42:40 <Lucas_> oh, I'm actually using the "Try Haskell" :P
20:42:50 <mm_freak> ah, ok, then forget it ;)
20:43:33 <Axman6> Lucas_: that's fun to get a very small taste of haskell, but will very quickly become unusable for anything but the most simple expressions. go get the haskell platform and start playing in ghci =)
20:43:42 <ski> drull95 : no, "functional paradigm" and "type-level paradigm" isn't really the same
20:44:29 <drdo> NihilistDandy: Actually i don't think i understand how the module system works, when i import the same name from different modules, is there some priority or is it always an error?
20:44:37 <byorgey> 'type-level' is not really a paradigm.
20:44:38 <Lucas_> Axman6: ah, thanks for the tip, I just wanted to try it out before downloading and stuff
20:44:48 <mm_freak> tryhaskell probably doesn't cover one of the nicest language features:  IO =)
20:44:56 <rwbarton> I know, I just needed three "paradigms" for the line.
20:44:57 <Lucas_> lol
20:45:01 <cl1> mm_freak, the best rmdb setup i've seen was while working at match.com, but they couldn't do ajax stuff woth a horses ass with it
20:45:01 <ski> drull95 : i was just joking about your implicit assumption that all the three terms has to be different by assumption. in this case i think they are different (but overlapping, to some extent)
20:45:03 <NihilistDandy> drdo: Post your import segment to http://hpaste.org/
20:45:11 <Axman6> drdo: it's always an error. you use qualified imports: import qualified Data.Map as M ... foo :: M.Map k v -> ...
20:45:15 <cl1> because it had lag between reads and writes
20:45:20 <drdo> import Data.Vector as V
20:45:32 <drdo> sequence conflicts with Prelude
20:45:33 <cl1> i mean the other way around
20:45:45 <NihilistDandy> drdo: You should say import qualified
20:45:48 <drdo> I thought when i used it unqualified it always meant the Prelude one
20:45:57 <ski> no
20:46:02 <mm_freak> cl1: the key to good database performance is to let the database perform the hard work…  something you can do easily with postgresql
20:46:22 <byorgey> however, Oleg IS a paradigm.
20:46:44 <cl1> mm_freak, and what would the hard work be?
20:46:57 <everyonemines> is there a LLVM channel?
20:47:00 <mm_freak> cl1: if your schema is good and your queries are reasonable, then the last bottleneck is the database configuration and the round-trip between database and application
20:47:12 <drdo> everyonemines: oftc i think
20:47:20 <cl1> mm_freak, what about conncurent requests
20:47:33 <NihilistDandy> Oleg's code is an arrow Oleg -> Hask
20:47:38 <drull95> ski, has anyone done monads in types yet?
20:47:51 <drull95> on the type-level, i mean
20:48:01 <ski> drull95 : i'm not sure what you mean. a monad *is* a type (plus two operations, and three laws)
20:48:26 * scshunt dies a little inside every time he hears "monad laws"
20:48:27 <mgsloan> however, Oleg IS a paragon.
20:48:30 <ski> drull95 : maybe you mean having a monad at the kind level, with two type functions `Return' and `Bind' ?
20:48:36 <shachaf> scshunt: Why?
20:48:40 <everyonemines> drdo: Yep, got it.
20:48:48 <mm_freak> cl1: one very hard thing for relational databases is this:  select the next 50 emails from 50 different providers and assign them the next 50 free servers…  a server becomes free after a timeout, and never use a server more than twice concurrently
20:49:00 <mm_freak> cl1: doing that on the application level will kill your performance completely
20:49:03 <drull95> we have type-level numbers and apparently, with extensions, the type system can be turing complete
20:49:15 <mm_freak> however, doing that as a stored procedure almost isn't noticable
20:49:30 <drull95> so i'm joking that somebody must have done monads
20:49:37 <drull95> nevermind, i'm not very funny
20:49:47 <scshunt> shachaf: Because it's the popularization of a bad term which, I presume, was initially used in an explanation of monads that simplified the wrong things
20:50:05 <shachaf> scshunt: Why is it a bad term?
20:50:15 <mm_freak> cl1: one of my applications does exactly that and it's even a bit more complicated…  it does it using PL/PgSQL inside the database
20:50:33 <ski> drull95 : ok. i think you can do that in Agda2
20:50:40 <mm_freak> in my application i just write:  SELECT ma_get_next(50);
20:50:50 <drull95> you know what would be a nice irc feature? highlighting threads when you hover over a statement in one, heuristics acceptable
20:50:55 <scshunt> shachaf: Because it's not axiom
20:50:56 <ski> (and btw, i think comonads at the type level might be useful)
20:51:04 <drull95> ski: i'm slowly learning the art of coq
20:51:08 <shachaf> scshunt: In what sense?
20:51:17 <scshunt> shachaf: they're axioms
20:51:31 <shachaf> scshunt: Oh, because it's "law" instead of "axiom"?
20:51:43 <mm_freak> cl1: and yes, it used to handle billions of records with that logic =)
20:51:43 <scshunt> yes
20:51:46 <shachaf> That seems like a silly distinction to me.
20:51:56 <shachaf> "law" is reasonably common in Haskell with that meaning.
20:51:57 <scshunt> I didn't say it was especially sensible
20:52:00 <scshunt> I know
20:52:02 <scshunt> it irks me
20:52:08 <drull95> i'm reading proofs and types right now actually, where by reading i mean i have it in a pile of books near me
20:52:18 <scshunt> drull95: the best kind of readin
20:52:26 <jessopher> reading by proximity
20:52:32 <ski> drull95 : "Coq'Art: The Calculus of Inductive Constructions" by Yves Bertot,Pierre Castran in 2004 at <http://www.labri.fr/perso/casteran/CoqArt/> ?
20:53:00 <drull95> yeppers, <hipster/> i own all the cool books
20:53:01 <Axman6> calling them laws makes a lot of sense really... laws can be broken, but axioms cannot (or they're not axioms right?)
20:53:01 * hackagebot text-format 0.3.0.7 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.0.7 (BryanOSullivan)
20:53:04 <drdo> "where" doesn't shadow?
20:53:10 <drull95> well, ok, not all
20:53:14 <drull95> but ltos
20:53:24 <ski> Axman6 : if they're broken, then you've failed to provide a model of them :)
20:53:44 <ski> drdo : it does
20:53:44 <drdo> nevermind
20:53:59 <shachaf> Axman6: They're axioms that you use to reason about some arbitrary monad.
20:54:11 <drull95> my personal library beats the local university library in particular topics
20:54:53 <scshunt> If my personal library were to beat the university library on any topic, it would be only by reason of me having checked out all relevant books
20:54:54 <drull95> the only thing i lack is access to journals, but i'm figuring a way around that, shhhh ;P
20:55:00 <cl1> mm_freak, but that work is done inside the database, i'm talking about concurrent reqeuests for updates and queries
20:55:10 <NihilistDandy> My personal library beat my school's library with regard to functional programming
20:55:14 <NihilistDandy> And I own three books
20:55:41 <drull95> yeah, my public library doesn't even own a copy of k&r c :(
20:56:11 * Axman6 finally figured out how to print out trees as text in a nice visual representation :D
20:56:17 <scshunt> My university has quite the collection of math books, so it's all good :)
20:56:35 <NihilistDandy> scshunt: That's all that keeps me sane
20:56:47 <drull95> yeah, i'm still getting into that. need to learn to focus, that's my biggest holdback
20:57:00 <scshunt> drull95: Yeah, me too
20:57:01 <drull95> if i don't have ten things going on i can't sit still
20:57:16 <cl1> mm_freak, you can do it, but it requires great skill and careful management of the code. with the NoSql (stupid name) you don't have that overhead. locks aren't an issue and you can horizontally partition across servers quite easily
20:57:16 <scshunt> the exercise I've developed is to, when reading articles online, read the entire thing through at once
20:57:44 <cl1> if you were doing, say analytics, then rmdbs are your friend
20:58:33 <NihilistDandy> Has anyone seen Granström's Treatise on intuitionistic type theory?
20:58:41 <mm_freak> cl1: my point is that given the proper knowledge and skillful management you will get better performance with an RDBMS
20:58:55 * ski thought it was "RDBMS"
20:59:16 <mm_freak> cl1: the RDBMS has some knowledge of your data structure, which it uses for optimization
20:59:37 <everyonemines> Why not a hierarchical distributed hashtable then?
20:59:48 <everyonemines> Seems better than a RDBMS in every way.
20:59:55 <ski> NihilistDandy : link ?
21:00:14 <cl1> mm_freak, i know, i've worked with some large databases
21:00:20 <Axman6> http://hpaste.org/55532 :D
21:00:26 <NihilistDandy> ski: http://www.springer.com/philosophy/book/978-94-007-1735-0
21:00:40 <NihilistDandy> It's the only book on type theory currently out of my school library
21:00:48 <NihilistDandy> I'm interested in meeting the person responsible :D
21:01:16 <NihilistDandy> Axman6: Nice
21:01:33 <ski> everyonemines : aaui, often with a hierarchical DB, if you want to change how the data is stored, you have to also change how it is accessed, so then you must change all the applications querying and updating (the relevant part) of the DB
21:01:43 <NihilistDandy> Axman6: Though I imagine the code is more interesting :D
21:02:18 <cl1> everyonemines, isn't that how distributed file systems work?
21:02:22 <everyonemines> ski: Depends on the level. You can have multiple pointers to the same data, packed in different combinations.
21:03:01 <everyonemines> It comes out as good or better as a RDBMS at least.
21:03:01 * hackagebot double-conversion 0.2.0.4 - Fast conversion between double precision floating point and text  http://hackage.haskell.org/package/double-conversion-0.2.0.4 (BryanOSullivan)
21:03:03 * hackagebot blaze-textual 0.2.0.6 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.0.6 (BryanOSullivan)
21:03:05 * hackagebot text 0.11.1.10 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.10 (BryanOSullivan)
21:03:11 <Axman6> NihilistDandy: well, it was an absolute pain in the arse to write, because i started doing everything by using string lengths and replicate.. then i realised i knew where everytyhing needed to go because each deeper line in the tree has a digit where i need to put things like the / and \
21:04:12 <Peaker> Either has no MonadPlus instance anywhere?
21:04:33 <ski> NihilistDandy : hm. you might be interested in "Intuitionistic Type Theory" by Per Martin-Lf in 1984 at <http://intuitionistic.files.wordpress.com/2010/07/martin-lof-tt.pdf>, and "Programming in Martin-Lf's Type Theory - An Introduction" by Bengt Nordstrm,Kent Petersson,Jan M. Smith in 2001 at <http://intuitionistic.files.wordpress.com/2010/07/nordstrom-et-al-type-theory.pdf>
21:04:35 <Peaker> oh, in Control.Monad.Error
21:04:58 <Peaker> Doh, that's mtl, I want transformers
21:05:14 <cl1> dammit, i had an hour to study some haskell and ended up talking about emacs and databases, LOL
21:05:32 <cl1> oh well, there is always tomorrow
21:06:10 <NihilistDandy> ski: Skimmed Nordström, et al. at work. Haven't found time for Martin-Löf's book, yet, but I'm on break so I've no excuse not to :D
21:07:50 <ddarius> RDBMSes have a huge amount of research, money, and effort thrown at them and have for the last 40 or so years.  It's unlikely that one can do much better than them for most data-oriented tasks for very long.  History has shown that RDBMSes have been able to readily fold in extensions and optimizations for "atypical" queries.
21:08:01 * hackagebot arx 0.1.0 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.1.0 (JasonDusek)
21:08:16 <drdo> I was very hyped about type theory for a while until i decided it wasn't that nice for everyday programming
21:08:22 * ski . o O ( bokra, bokra .. )
21:08:40 <ddarius> They also have a proven track record of actually getting things done.
21:09:18 <NihilistDandy> drdo: Not especially interested in everyday programming, most of the time. I like to think of weird things, model them, then save the code away somewhere and think about other weird things
21:09:23 <cl1> ddarius, so has object-oriented programming :P
21:10:19 <ddarius> cl1: Not 40 years, nor does it have the same track record, nor has it as readily folded in "revolutionary" ideas.
21:10:35 <drdo> NihilistDandy: It's lots of fun to write proofs and all, but sometimes i really want to just get stuff done
21:10:59 <Enigmagic> i dunno, c++ even has lambdas now .. they're adapting, just not quite as fast as a boxed product or service can
21:11:05 <everyonemines> Distributed hash tables are already used on a larger scale than haskell...
21:11:09 <NihilistDandy> Ouch. My education just took blow to its pride~
21:11:18 <ddarius> everyonemines: So?
21:13:47 <monochrom> I define "program" to describe (or prescribe, whatever) computer behaviour, and "programming" accordingly. type theory then does not fulfill my "programming" — all of "programming", not just everyday "programming"
21:15:12 <NihilistDandy> Bu… bu… but… CHI T_T
21:15:18 <monochrom> if you're interest in mathematical proofs of existential statements, and you have no intention to convert that to computer behaviour, and you still have a conscience to call that "programming", sure.
21:16:45 <monochrom> I call that "drink the curry-howard koolaid wholesale". yes, in the very same sense and calibre as kmc's calling some things "drink the C++ koolaid wholesale"
21:17:06 <dolio> I guess my interpreter for type theory doesn't exist.
21:18:02 * hackagebot math-functions 0.1.0.0 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.0.0 (BryanOSullivan)
21:18:25 <mm_freak> ddarius: i think the hype for "NoSQL" databases was mainly caused by facebook using them
21:18:25 <NihilistDandy> monochrom: I wouldn't dare drink Kool-Aid that hard. I'm just also not a programmer first.
21:18:27 <monochrom> if you already have an interpreter on a computer, and you have actually run it, you need to re-read what I said
21:19:41 <NihilistDandy> *the Kool-Aid
21:20:26 <drdo> NihilistDandy: It's all about having fun, masturbate furiously using type theory if that's your thing!
21:20:31 <NihilistDandy> I'm working on a MIPS interpreter right now, probably because I hate myself
21:21:28 <monochrom> well, I guess I was also wrong. if you have an interpreter for type theory, then type theory can be used for programming. but now the question is who use it for programming and who don't.
21:21:50 <NihilistDandy> s/interpreter/simulator/, realistically
21:22:05 <NihilistDandy> I hate the MIPS simulator options currently available enough that I want to try my hand at it
21:22:25 <monochrom> I certainly don't. I find it incovenient for the purpose of computer behaviour.
21:22:45 <NihilistDandy> What? MIPS?
21:22:56 <NihilistDandy> Oh, interpreting type theory
21:23:09 <monochrom> There are other people who don't; they just want the mathematical content, not the computer behaviour.
21:23:46 <cl1> RDBMSs don't horizontally partition well
21:23:59 <drdo> Hmm, I want something like this: MonadPlus m ⇒ (a → m b) → (a → m b) → a → m b
21:24:13 <cl1> that's not to say they won't in the future, but right now they aren't good at it
21:24:35 <cl1> looks like i'm going to be up for at least another hour :D
21:24:44 <dmwit> :t mplus
21:24:44 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
21:24:48 <NihilistDandy> monochrom: I find the mathematical content interesting, but I'm (usually) ultimately looking to actually do something computationally
21:24:49 <dmwit> :t liftM2 mplus
21:24:49 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (MonadPlus m, Monad m1) => m1 (m a) -> m1 (m a) -> m1 (m a)
21:24:59 <dmwit> drdo: There you go.
21:25:16 <dmwit> :t liftM2 mplus :: MonadPlus m => (a -> m b) -> (a -> m b) -> (a -> m b)
21:25:17 <lambdabot> forall a (m :: * -> *) b. (MonadPlus m) => (a -> m b) -> (a -> m b) -> a -> m b
21:25:39 <mm_freak> cl1: well, it's because of the schema that RDBMSes don't scale horizontally…  you get easy replication, but not easy distribution
21:25:42 <NihilistDandy> I'm also a math major, though, so I occasionally get lost in abstract pointlessness
21:25:56 <NihilistDandy> And love every minute :D
21:25:57 <drdo> oh yes, thanks
21:26:08 <eyebloom> Anyone on here familiar with Isabelle?
21:26:21 * Axman6 -> home
21:26:36 <monochrom> try also #isabelle
21:26:37 <mm_freak> cl1: on the other hand only few people need distributed databases…  nowadays the threshold for when more RAM becomes more expensive than more machines is very high
21:26:44 <eyebloom> thanks
21:27:01 <mm_freak> cl1: you need to be google, ebay, amazon or facebook to need that
21:27:36 <mm_freak> for most of my projects i just use acid-state…  for the larger projects postgresql
21:27:42 <Enigmagic> mm_freak: most of ebay is served off of 900 oracle boxes
21:28:50 <cl1> ebay actually had a highly distributed model and realized that they were underutilizing the computing capacity they had
21:29:43 <Enigmagic> cl1: hmm?
21:30:07 <mm_freak> part of the problem is also that most companies feel (!) bound to certain technologies
21:30:30 <cl1> Enigmagic, yeah, they decided to do something different, and actually lowered costs. I don't remember what they did, but it was not as distributed.
21:31:23 <cl1> mm_freak, those aren't the only companies that need that
21:31:46 <mm_freak> sure, but you get the idea
21:31:54 <cl1> yes, i fully understand
21:31:58 <Enigmagic> cl1: their version of distributed is having 3 datacenters a few hours apart for redudancy, and serving all worldwide search traffic out of las vegas and salt lake city
21:32:35 <cl1> probably only 0.1% of the companies out there actually need distriubted databases
21:34:41 <drdo> Everyone needs distributed databases, because it's fun and cool
21:34:57 <drdo> And those are the most important attributes to maximize
21:35:57 <Enigmagic> well, there are advantages... offloads some of the server selection and failover to a smaller number of (hopefully) qualified engineering teams
21:36:09 <monochrom> I agree. I took a course on distributed algorithms. much craved.
21:38:14 <cl1> as more people come online, more companies will have to deal with this issue. Eventually it will be the norm ...
21:38:20 <cl1> shortly before skynet takes over
21:39:33 <cl1> i think languages like haskell will also become more important, i've never seen such terse expresivness in a language. code like that must be a breeze to maintain
21:40:42 <Enigmagic> i dunno about you but i would not like to maintain a large number of the packages on hackage
21:40:50 <Enigmagic> terse does not mean maintainable
21:41:12 <cl1> Enigmagic, do tell
21:41:14 <Enigmagic> i write production code sometimes that i can't even figure out what it is supposed to do six months after the fact.
21:41:28 <cl1> that's why you document it
21:41:31 <cl1> next
21:41:46 <Enigmagic> really.. i haven't thought about doing that before
21:42:01 <cl1> it works wonders :P
21:42:10 <Enigmagic> all this time...
21:43:45 <NihilistDandy> I hope Skynet's coded in Haskell
21:43:57 <Enigmagic> i think unit tests and quickcheck are the two things that help maintenance
21:45:05 <Enigmagic> comments inadvertently become out of date
21:47:06 <cl1> i didn't say comments I said document it
21:48:02 * hackagebot GLFW-b 0.1.0.1 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.1.0.1 (BrianLewis)
21:50:57 <mm_freak> HAH!  40 ms for 4096 bit modular exponentiation with type level moduli =)
21:51:02 <mm_freak> that's almost worth a library
21:52:41 <mm_freak> nice example of how to use the type level for checking and the value level for the actual calculation
21:53:10 <Enigmagic> cl1: what's the difference? most documentation i've seen (haskell or otherwise) is even more out of date than the comments
21:54:04 <Enigmagic> i could be missing something though
21:54:19 <hpaste> “Ertugrul Söylemez” pasted “Fast modular arithmetic (experimental)” at http://hpaste.org/55533
21:54:24 <cl1> Enigmagic, I agree that alot of developers don't give a crap about documentation. I have worked at places where they do, it is a world of difference when maintaining code
21:54:36 <Sgeo> Could unsafeInterleaveIO be defined as unsafeInterleaveIO = return . unsafePerformIO ?
21:54:56 <mm_freak> Sgeo: yes
21:55:04 <Sgeo> Because unsafeInterleaveIO makes me think of an unsafePerformIO'd value that's been placed in the IO monad.
21:55:17 <mm_freak> Sgeo: IIRC that's how it's defined actually
21:55:24 <Enigmagic> cl1: i've had the opposite experience. with good (and fast) test coverage it's a breeze to maintain large codebases
21:55:43 <MiggyX> hmm… one function provides a ByteString to a function that needs a lazy ByteString which needs to be passed to another function that requires String.  Is there any easy way to do this or do I have to keep converting between them?
21:55:58 <Sgeo> I think I'm gaining some understanding of why lazy IO is so bad
21:56:01 <mm_freak> MiggyX: you'll need conversion
21:56:16 <mm_freak> Sgeo: it's not "bad", it's just unfortunate
21:56:39 <MiggyX> mm_freak: hmm… that sucks - gonna slow things down a fair bit if I keep moving stuff around - not to mention making it less easy to read :/
21:56:55 <drdo> MiggyX: Oh boy, i'm hating the same atm
21:57:02 <mm_freak> for some applications it's fine, as long as you can narrow the scope of possible exceptions…  the only problem is that it makes reasoning about exactly that more difficult
21:57:07 <drdo> converting between lazy and strict bytestrings
21:57:08 <MiggyX> drdo: well at least it's not just me lol
21:57:27 * ski idly wonders who'd want to rent him, and for what purpose ..
21:57:44 <mm_freak> MiggyX: conversion between lazy and strict bytestrings isn't that expensive, but the String might make a bottleneck
21:58:00 <Enigmagic> cl1: i've also seen the opposite happen on a ~400 person project... where all check-ins were gated through a "CI" guantlet... and it totally destroyed productivity around milestones
21:58:07 <Enigmagic> so there is a balance :-)
21:58:13 <drdo> 400 person project?
21:58:20 <Enigmagic> not a haskell project
21:58:21 <drdo> the fuck was it?
21:58:25 <Enigmagic> exchange server
21:58:32 <drdo> 400? really?
21:58:40 <Enigmagic> devs/test probably about that
21:58:50 <cl1> it took 400 people to screw that up that bad? LOL
21:58:52 <drdo> What's that? 10 guys working and 390 sipping coffee and talking?
21:59:08 <Enigmagic> heh i didn't work in the team, i just provided stuff to them
21:59:15 <cl1> Enigmagic, howo long ago was that?
21:59:18 <Enigmagic> they rewrote everything a few years ago in c#
21:59:20 <drdo> I honestly can't imagine how you get 400 people working on a software project
21:59:35 <cl1> Enigmagic, you still work at microsoft?
21:59:41 <Sgeo> Is there a way to observe garbage collection?
21:59:53 <Enigmagic> cl1: 2005-ish, that product became exchange 2008
22:00:06 <drdo> Sgeo: Yes, i'm observing it right now from my window, trash guys always come at night
22:00:23 <Enigmagic> i run a company doing haskell stuff, quit my job at MS about 4 years ago
22:00:49 <cl1> Rob Howard, Josh Ledger, Stacy Randolf, any of those names ring a bell?
22:01:14 <Sgeo> performGC :: IO () is not, in fact, what I'm looking for
22:01:19 <MiggyX> so, converting from a lazy ByteString to a [Char]   - it looks like I might have to convert it to something else first?
22:01:27 <Enigmagic> cl1: not immediately no
22:01:31 <cl1> they used to work at MS back then
22:01:36 <drdo> MiggyX: Data.ByteString.Lazy.UTF8
22:01:42 <drdo> If you want UTF8 that is
22:02:56 <Sgeo> Oh, so there is an stToIO, and I wouldn't have to use unsafeSTtoIO
22:03:02 <Sgeo> Erm
22:03:05 <Sgeo> unsafeSTToIO
22:03:31 <cl1> Enigmagic, so is haskell any easier to maintain?
22:03:47 <cl1> or write tests for?
22:04:09 <Enigmagic> cl1: i'd say yes
22:04:31 <Enigmagic> though modern-ish c++ isn't that bad either imo
22:04:44 <MiggyX> drdo: It's currently just Data.ByteString.Lazy atm
22:05:07 <Enigmagic> debugging production haskell apps is way worse if there is a bug that isn't caught by unit tests :|
22:05:20 <cl1> how so?
22:05:44 <Enigmagic> lack of good native debugger integration
22:06:25 <Enigmagic> ghci isn't super userful if a compiled/optimized app crashes after running for 8 hours
22:06:26 <cl1> that would be a problem
22:07:42 <drdo> Is there some mega strict magic version of unsafePerformIO so i can printf debug in peace?
22:07:43 <Enigmagic> there are projects working on solving some of my complaints though
22:07:53 <Enigmagic> and i'm working on a few myself
22:08:57 <MiggyX> drdo: probably not :)
22:09:44 <Sgeo> drdo, Debug.Trace.trace
22:09:44 <c_wraith> drdo: Debug.Trace?
22:09:49 <Sgeo> :t Debug.Trace.trace
22:09:50 <lambdabot> forall a. String -> a -> a
22:09:51 <cl1> interesting
22:10:07 <Sgeo> It uses unsafePerformIO underneath, I think
22:10:19 <Sgeo> Yet the application itself will never feel the effects
22:10:37 <c_wraith> unless printing to stdout generates an IO exception, somehow
22:10:44 <NihilistDandy> @src trace
22:10:44 <lambdabot> trace string expr = unsafePerformIO $ do
22:10:44 <lambdabot>     hPutStrLn stderr string
22:10:44 <lambdabot>     return expr
22:10:52 <c_wraith> ok stderr
22:11:32 <NihilistDandy> My favorite thing in the world is writing Haskell code while smoking a pipe. I feel like the classiest person on the planet
22:11:50 <NihilistDandy> ~
22:12:33 <drdo> trace is nice, thanks
22:12:37 <Sgeo> yw
22:13:37 <cl1> Enigmagic, i'm very fond of visual studio specifically because of its debugging features
22:13:59 <MiggyX> so… how do you convert ByteString.Lazy to ByteString.Lazy.UTF8  ?
22:14:03 <cl1> i'm getting a copy of ultimate soon so I will have intellitrace, which allows you to replay debugging sessions
22:16:03 <Enigmagic> cl1: yeah for most applications visual studio is awesome. for lower level managed (and almost all c++) i'd use windbg with some extensions
22:16:10 <NihilistDandy> Intellitrace sounds like a lazy man's Etch-a-Sketch from the early 90s
22:16:30 <Enigmagic> cl1: they have tools like intellitrace that work for native code too but it's not in VS
22:16:47 <Enigmagic> now i'm stuck with gdb and lldb
22:16:50 <drdo> MiggyX: ByteString.Lazy.UTF8 isn't a new type of ByteString
22:17:13 <drdo> It has a toString function though, ByteString → String
22:17:31 <cl1> i'm suprised no one has made them better
22:18:52 <Eduard_Munteanu> You might be happier with a gdb frontend, like insight or ddd.
22:19:24 <Enigmagic> Eduard_Munteanu: nah i just use lldb with a bunch of python scripts for working with the rts
22:19:33 <Enigmagic> most of the time at least
22:19:33 <MiggyX> drdo: ah got it! Thanks! :)
22:24:37 <drdo> Is Data.Vector.sum strict? (i.e. foldl')
22:30:43 <ehamberg> drdo: looks like it, yes: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/src/Data-Vector-Generic.html#sum
22:32:44 <ski> Sgeo : `stToIO' and `unsafeSTToIO' have different types
22:41:58 <MiggyX> *sigh* every single valid JSON message I pass to decode blows up with invalid json *cries*. It's been one of those days….
22:42:46 <dmwit> MiggyX: Maybe you're not being careful about encodings or something annoying like that.
22:44:26 <MiggyX> dmwit: I've printed the string out and it looks fine
22:44:56 <aib> Something Annoying Like That is the single worst programming error, ever.
22:44:58 <cl1> wtf is a non-pathological function?
22:44:58 <dmwit> That sentence does nothing to reassure me that you've been careful about encodings.
22:45:12 <dmwit> cl1: depends on context
22:45:34 <cl1> "There is a deep mathematical sense in which any non-pathological function of type (a,b) -> a must do exactly what fst does."
22:46:20 <mustelo>  /query lambdabot @help
22:46:21 <dmwit> non-pathological here probably means "doesn't use undefined, unsafeCoerce, unsafePerformIO, etc.".
22:47:02 <drdo> cl1: Try to come up with a function that has type (a,b) → a and isn't fst
22:48:34 <cl1> drdo, i see what you mean
22:50:16 <NihilistDandy> Anyone get the -fllvm flag to work on Lion?
22:50:18 <cl1> non-pathological == well behaved? http://en.wikipedia.org/wiki/Pathological_(mathematics)
22:51:00 <aib> I think it means one should disregard e.g. addOneToFirstValueAndDiscardTheSecond
22:52:06 <drdo> The point is that you can't do anything with the value except return it, because you don't know anything about it, it could be any type
22:52:24 <MiggyX> dmwit: Well I've tried sending it as UTF8 and ASCII  and I've tried decoding it in various ways in the haskell app as well.
22:52:30 * BMeph is curious what "adding one" to "square" gives...
22:52:44 <drdo> And since you must return a value of that type and you don't know anything about it, you also don't know how to make up a value of that type
22:52:46 <aib> I thought it was somewhat more along the lines of "such loss of a whole type of information can only be excused in the case of a slicing/indexing(?) function such as fst"
22:53:18 <cl1> drdo, i got the point, just curious about the non-pathological part
22:53:57 <Sgeo> cl1, because unsafeCoerce or unsafePerformIO etc. could be used there to make a pathological function
22:54:24 <Sgeo> That does... something, and has that type
22:54:37 <Sgeo> Also, _|_ fits into that type
22:55:47 <cl1> so non-pathological does mean well behaved
22:57:04 <Sgeo> Yes
22:57:30 <dmwit> Sgeo: You're ten minutes late. =)
22:57:52 <cl1> Sgeo, thanks
22:59:16 <Sgeo> You're welcome. dmwit >.> I kind of looked at what you said and just elaborated
22:59:21 <Sgeo> Or, well, not really elaborated
22:59:22 <Sgeo> <,<
22:59:34 <NihilistDandy> Though pathological is a bit subjective
22:59:45 <Sgeo> Most functions are pathological?
22:59:54 <drdo> Almost Everything(TM) is subjective
23:00:05 <NihilistDandy> For certain definitions of well-behaved, certainly
23:07:50 <ski> dmwit : ...,`error',`seq'
23:08:05 <Lucas_> oh god, I fell in love with list comprehensions :)
23:08:11 <ski> heh
23:08:25 <Lucas_> they are so similar to what you do in math
23:08:31 <dmwit> seq can't break typing, can it?
23:08:42 <ski> it can't
23:08:53 <ski> (but it can break the monad laws for `IO')
23:09:09 <dmwit> Oh, but you could give a "different" implementation of the type (a,b) -> a by giving one with different strictness properties.
23:09:12 <dmwit> Okay, that's true.
23:16:30 <drdo> Do i need to type the "else" part of an if in do notation?
23:19:36 <ski> drdo : there is no special support for `if' in `do'-notation -- i.e. it's just an ordinary `if'-*expression*
23:19:39 <ski> (so, yes)
23:19:44 <ski> @type when
23:19:44 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:19:46 <ski> @type unless
23:19:47 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:20:07 <ski>   when blah $ do
23:20:10 <ski>     bleh
23:20:12 <ski>     ...
23:21:04 <drdo> yep, that's what i want
23:21:06 <drdo> thanks
23:23:00 <cl1> @quote notepad++
23:23:00 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
23:23:14 <cl1> @quote Notepad++
23:23:14 <lambdabot> No quotes match. Take a stress pill and think things over.
23:23:28 <cakoose> Trying to write a function to transform an Enumerator of one type to an Enumerator of another type...
23:23:42 <NihilistDandy> @quote emacs
23:23:42 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
23:23:47 <cakoose> i.e. :: Enumerator a m r -> Enumerator b m r
23:23:49 <cl1> how does this quotes thing work?
23:23:53 <NihilistDandy> @quote vi
23:23:53 <lambdabot> mmorrow says: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
23:23:59 <cl1> i thought it listed stuff that people in here said
23:24:04 <NihilistDandy> It does
23:24:13 <NihilistDandy> But you have to tell lambdabot to remember it, first
23:24:22 <cl1> oh
23:24:33 <NihilistDandy> @quote NihilistDandy
23:24:33 <lambdabot> NihilistDandy says: The best part of Haskell is that 80% of module names can be turned into clever blog titles.
23:24:39 <cl1> someone mentioned notepad++ i wanted to thank them
23:25:15 <mm_freak> can i subscribe to the haskell-cafe without actually receiving the e-mails?
23:25:22 <mm_freak> because i'm using gmane
23:25:22 <cl1> so thank you who ever you are
23:25:25 <NihilistDandy> Siva and hpc have mentioned it, according to the logs
23:25:45 <NihilistDandy> Siva's the one you reacted to, earlier
23:26:33 * ski hugs `lastlog'
23:26:58 <cl1> Siva: thanks for mentioning notepad++
23:27:49 <cakoose> Anyone familiar with Enumeratees and Iteratees?
23:28:01 <cl1> @type take
23:28:02 <lambdabot> forall a. Int -> [a] -> [a]
23:28:13 <cl1> now the book says that -> is right associative
23:28:30 <ski> yes, so that is `Int -> ([a] -> [a])'
23:28:39 <cl1> does that mean take 6 [1,2,3,4,5,6,7] is right associative with its operators as well?
23:28:41 <ski> @type take 3
23:28:42 <lambdabot> forall a. [a] -> [a]
23:28:59 <ski> cl1 : no, application is left associative, so that is `(take 6) [1,2,3,4,5,6,7]'
23:29:04 <cl1> okay
23:29:33 <ski> so, `take 6' here is a function of type `[a] -> [a]', and that function is given `[1,2,3,4,5,6,7]' as input, there
23:30:23 <cl1> so i would have to do take 6 (map (+1) [1,2,3,4,5,6,7])
23:30:32 <ski> yes
23:30:35 <cl1> got it
23:30:46 <ski> > (take 6 . map (+ 1)) [1,2,3,4,5,6,7]  -- also works
23:30:48 <lambdabot>   [2,3,4,5,6,7]
23:31:03 <ski> > take 6 . map (+ 1) $ [1,2,3,4,5,6,7]  -- some people write it like this
23:31:04 <lambdabot>   [2,3,4,5,6,7]
23:31:16 <cl1> i started over with the realworld haskell tutorial, i'm retaining a bit more this time
23:31:27 <NihilistDandy> > take 6 $ map (+1) [1..7]
23:31:28 <lambdabot>   [2,3,4,5,6,7]
23:31:50 <aib> > take 6 [2..8]
23:31:51 <lambdabot>   [2,3,4,5,6,7]
23:32:12 <ski> NihilistDandy : yeah, but imo, that usually feels ugly
23:32:38 <cl1> why does that feel ugly?
23:32:51 <cl1> >take 6 $ map (+1) [1..7]
23:33:00 <cl1> looks more readable to me
23:33:14 <cl1> > take 6 $ map (+1) [1..7]
23:33:14 <lambdabot>   [2,3,4,5,6,7]
23:33:17 <NihilistDandy> ski's form keeps all the functions on one side
23:33:31 <NihilistDandy> Well… not all, since a list is a function
23:33:31 <cl1> ah
23:33:33 <NihilistDandy> But still
23:33:41 <ski> a list is not a function
23:34:12 <cl1> a list is a type constructor
23:34:15 <cl1> correct?
23:34:19 <ski> no
23:34:27 <ski> `[0,1,2]' is a list
23:34:32 <cl1> @type []
23:34:33 <lambdabot> forall a. [a]
23:34:48 <ski> the `[a]' here is not a list, it's the type of lists with elements of type `a'
23:34:51 <NihilistDandy> Sorry, I should say that cons is a function, and a list is a list
23:35:14 <cl1> @type [1]
23:35:14 <lambdabot> forall t. (Num t) => [t]
23:35:31 <ski> cl1 : imho, `$' is more visually distracting than using brackets
23:35:39 <ski> but in the case above, it's not so bad
23:35:57 <cl1> ski: fair enough
23:36:07 <ski> it's more bad if you write `foo x $ bar y z $ baz x a $ blah'
23:36:24 <Sgeo> ski, I've been told to replace most of those $ with .
23:36:34 <ski> better is to write `foo x . bar y z . baz x a $ blah', or `(foo x . bar y z . baz x a) blah'
23:36:38 <aib> I used to do that. Then I took a point-free arrow in the knee
23:37:01 <ski> or even `foo x (bar y z (baz x a (blah)))' is ok, imo
23:37:11 <NihilistDandy> aib: lol
23:38:05 <ski> saying `blah x $ \y -> ...' is ok (but it would be better if the `$' wasn't needed here, cf. Agda2, lambdaProlog)
23:38:47 <ski> (similarly saying `blah x $ do ...' or `blah x $ case .. of ...', &c. is also ok)
23:40:55 <Sgeo> If . meant $, would that make it ok to use more?
23:41:00 <Sgeo> If it had never meant composition?
23:41:13 <Sgeo> (e.g. is the main objection to $ visual?)
23:45:53 <c_wraith> Sgeo: no, in that case, it's a quirk of haskell's syntax.
23:46:49 <c_wraith> Sgeo: lambdas, do blocks, case statements, etc...  All are allowed after operator characters, but they aren't allowed in the place of an argument to a function
23:47:32 <c_wraith> Sgeo: there's very little (if anything?) that would be ambiguous if they were allowed as function arguments, so...  It's not clear why that restriction exists.
23:48:25 <c_wraith> oh, but in the case of not using multiple $ in one a composition pipeline, that's about decomposition
23:48:54 <Tuna-Fish> I am totally stumped by a  weird problem. The compiler complains of a type error, but when I isolate the offending expression into the repl, it has the correct type.
23:49:01 <Tuna-Fish> the function is:
23:49:16 <Tuna-Fish> splitRTJono :: TJono String -> Int -> [TJono String]
23:49:17 <Tuna-Fish> splitRTJono jono count = do
23:49:17 <Tuna-Fish>         jonot <- map (\ _ -> (atomically newTJono)) [1..count]
23:49:17 <Tuna-Fish>         forkIO $ multiplex jono jonot
23:49:17 <Tuna-Fish>         return jonot
23:49:20 <opqdonut> please paste a complete code example into hpaste
23:49:24 <opqdonut> not here
23:49:28 <Tuna-Fish> ok, will do
23:50:46 <hpaste> tuna pasted “weird type error” at http://hpaste.org/55534
23:51:31 <Tuna-Fish> TJono is essentially the same as TChan
23:51:49 <opqdonut> Tuna-Fish: [IO (TJono a)] is not an IO value, therefore you cannot extract it with <-
23:52:03 <opqdonut> Tuna-Fish: turn it into "IO [TJono a]" with sequence
23:52:08 <opqdonut> (or use mapM)
23:52:21 <opqdonut> boom
23:52:27 <Tuna-Fish> opqdonut: thanks
23:53:18 <Tuna-Fish> opqdonut: can you give me a keyword/name of concept that I can google to understand why it works that way?
23:54:04 <opqdonut> when you're doing monadic things, you need to handle things of type YourMonad Something
23:54:08 <opqdonut> that's all there is to it
23:54:14 <Tuna-Fish> ... ok
23:54:39 <opqdonut> a [IO (TJono a)] is a list of operations that produce TJonos
23:54:58 <opqdonut> you can turn that into one operation that returns a list of TJonos by simply running all of the operations sequentially
23:55:06 <opqdonut> this is what sequence does
23:55:08 <opqdonut> :t sequence
23:55:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:55:12 <opqdonut> @src sequence
23:55:12 <lambdabot> sequence []     = return []
23:55:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:55:13 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
23:56:38 <opqdonut> the combination of sequence and map is so common that it has its own name:
23:56:40 <opqdonut> :t mapM
23:56:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:57:07 <Tuna-Fish> um. With sequence, it infers the type as [[Tjono a]]
23:57:42 <opqdonut> "jonot <- sequence $ map (\ _ -> (atomically newTJono)) [1..count]" ?
23:57:50 <ski> Sgeo : not only, no. i don't think a few nested bracketed expressions are hard to read -- imho, `$' in those cases make something simple needlessly complicated
23:58:24 <opqdonut> (also, you might be interested in replicateM)
23:58:27 <opqdonut> :t replicateM
23:58:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
23:59:07 <ski> Sgeo : `$' is appropriate to use if you would otherwise have a closing bracket several lines of code down
23:59:41 <Sgeo> :/ In what code I've written, I've used it a bit more often than that
23:59:57 <Tuna-Fish> opqdonut: Couldn't match expected type `IO [TJono a]'
23:59:57 <Tuna-Fish>            against inferred type `[[TJono a]]'
23:59:57 <Tuna-Fish>     In a stmt of a 'do' expression:
23:59:57 <Tuna-Fish>         jonot <- sequence $ map (\ _ -> (atomically newTJono)) [1 .. count]
