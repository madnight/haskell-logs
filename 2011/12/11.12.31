00:06:02 <mm_freak> ddarius: yes, that's the basic idea, but it's not that simple
00:06:11 <mm_freak> you have to deal with upgrading, multiple sites, etc.
00:09:46 <ionit> hello again!
00:10:13 <ionit> is there some nice way to slim down the haskell platform
00:10:20 <ionit> its taking 817MB!!
00:10:28 <ionit> no don't suggest uninstall it
00:11:36 <russellw> How much hard disk space have you got?
00:11:48 <ionit> ??
00:12:18 <srhb> Point being: Why?
00:12:39 <ionit> I have my whole drive as 38GB
00:12:45 <ionit> 6 drives with 6 GB each
00:12:50 <mm_freak> ionit: i sense you have a slow internet connection?
00:12:55 <ionit> I mean 5,one is for windows itself
00:13:10 <srhb> ionit: Wow, that's tiny. Perhaps you should ditch the haskell platform and go for ghc and cabal-install
00:13:11 <russellw> oh, well then get a bigger hard disk
00:13:27 <ionit> can't get a bigger hdd
00:13:34 <russellw> Seriously, a bigger hard disk costs a fraction of the value of the time you'd spend messing around trying to slim things down
00:13:36 <ionit> they don't sell ancient types anymore here
00:13:46 <mm_freak> since "get a bigger hard disk" is not an option for everyone, you can very well just download GHC (which is quite large itself) and cabal-install
00:13:53 <mm_freak> then you can install the packages you want yourself
00:13:56 <rwbarton> this confirms my "time traveler" theory
00:14:12 <ionit> ghc large?
00:14:13 <russellw> Yeah but if your machine has a USB port, you can easily get a fast external drive
00:14:14 <ionit> how large
00:14:20 <ionit> I have unlimited data
00:14:23 <russellw> If your machine doesn't have a USB port, get a new machine ;)
00:14:34 <mm_freak> ionit: still well over 100 MB the last time i checked
00:14:34 <morolin> ionit: rent a server with a reasonable amount of HD space and then SSH into it. =P
00:14:39 <ionit> new machine >= $800
00:14:47 <mm_freak> but that's still better than 800 MB
00:15:08 <ionit> yep 800MB <= $800
00:15:14 <ionit> no seriously lets get serious
00:15:14 <srhb> ionit: Definitely go for ghc + cabal-install, it's a tenth of the size of the whole platform or so.
00:15:20 <ionit> can I download ghc seperately
00:15:21 <rwbarton> 800GB <= $800
00:15:24 <srhb> ionit: You already got the answer.
00:15:48 <mm_freak> ionit: http://www.haskell.org/ghc/download
00:15:49 <ionit> this -> ghc + cabal-install, it's a tenth of the size of the whole platform or so.
00:16:03 <plat0> Is the accepted style to put a space between \ and the variable name?
00:16:06 <mm_freak> this is just GHC and the base library
00:16:12 <srhb> plat0: I believe not.
00:16:20 <srhb> plat0: I see \a -> ... everywhere
00:16:21 <applicative> won't he end up having to rebuild half the platform if he wants to install much of anything?
00:16:36 <srhb> Pretty much, but it's really the only viable option for slimming down.
00:16:40 <srhb> And it will be slimMER.
00:16:45 <mm_freak> plat0: the common style is to write the variables right after the lambda, which reflects the mathematical lambda abstraction
00:16:58 <plat0> OK thanks both.
00:17:31 <mm_freak> applicative: yes, but you can save a few MB for example by not installing haddock docs
00:17:44 <mm_freak> also there are some libraries in the platform that aren't commonly used
00:17:51 <srhb> Quite a few.
00:18:19 <mm_freak> with GHC + cabal-install you can be quite sure to get only what you really need
00:18:37 <applicative> ah yes, the docs
00:19:01 <mm_freak> also i think the platform installs profiling versions of every library
00:19:16 <mm_freak> cabal-install doesn't do that automatically
00:19:21 <applicative> i was going to advise avoiding profiling
00:19:28 <ionit> okay am freaked out
00:19:31 <ionit> installing the platform
00:19:37 <ionit> ....
00:19:45 <ionit> done!!
00:19:53 <mm_freak> hehe
00:20:25 <mm_freak> ionit: keep an eye on your .cabal library in your home directory (in windows you'll have to find out what that is)
00:20:43 <mm_freak> it can get quite large, when using cabal-install a lot
00:20:47 <ionit> windows?
00:20:58 <mm_freak> you mentioned windows earlier
00:20:58 <ionit> I mean am in windows
00:21:19 <mm_freak> uhm
00:21:26 <mm_freak> i meant .cabal directory, not library
00:21:30 <srhb> ionit: On Unix systems (except mac) cabal install libraries to /home/user/.cabal - you will have to find out what the directory is on Windows
00:21:52 * srhb spakes gud English
00:21:57 <srhb> More coffee.
00:22:01 <ionit> I don't think I can have a directory with a period in front of its name
00:22:12 <Sgeo_> What's the difference between ResourceT and RegionT?
00:22:17 <mm_freak> ionit: even windows can do that =)
00:22:24 <ionit> how how?
00:22:32 <srhb> ionit: Our point is that it is probably NOT .cabal in Windows.
00:22:40 <srhb> ionit: But we don't know what it is, so go Google it.
00:22:40 <ionit> oh
00:22:48 <ionit> so what is that ugly directory named?
00:22:49 <mm_freak> Sgeo_: i think a ResourceT still exposes resource handling functionality, while a RegionT identifies resources by type variable scope
00:22:53 <srhb> :-)
00:22:55 <ionit> the large cabal counterpart?
00:23:23 <mm_freak> Sgeo_: in that regard RegionT kinda works like runST
00:23:54 <mm_freak> srhb: many unix programs put the dot in front of the directory name, even under windows
00:24:23 <ionit> hmm the lib directory is largest 542MB
00:24:25 <ionit> followed by
00:24:27 <srhb> mm_freak: Many don't. And cabal does not.
00:24:32 <ionit> doc
00:24:33 <ionit> 119
00:24:34 <mm_freak> ok
00:24:44 <ionit> where is my  cabal?
00:24:45 <applicative> ionit, to find you cabal directory, open ghci,  type import System.Directory, and then type getAppUserDataDirectory "cabal"
00:24:51 <srhb> ionit: Google: cabal directory windows
00:24:55 <mm_freak> dunno, my last windows experience is from 2001 or 2002
00:25:06 <srhb> Same here..
00:25:07 <applicative> ghci can tell him
00:25:18 <srhb> Really?
00:25:29 <srhb> I'd like to know that trick.
00:25:44 <srhb> Well, now that you say it, it seems obvious - but how? :)
00:26:33 <ionit> hmm
00:26:37 <mm_freak> srhb: i guess that's just what cabal does =)
00:26:40 <ionit> it says its in application data
00:26:43 <ionit> but can't seem to see it
00:26:49 <mm_freak> ionit: run "cabal update"
00:27:30 <mm_freak> ionit: if you see an interesting package on hackage, you can install it by running "cabal install PACKAGENAME"
00:27:36 <ionit> says not in scope
00:27:51 <srhb> ionit: In your terminal, not in ghci.
00:27:59 <ionit> oh
00:28:17 <ionit> omg!!
00:28:18 <mm_freak> it's not such a bad idea to add a cabal interface to GHCi
00:28:22 <ionit> its trying to download something
00:28:26 <ionit> how big is that?
00:28:30 <mm_freak> ionit: 2-3 MB
00:28:42 <ionit> oh
00:28:44 <ionit> fine
00:28:45 <srhb> Also, :m System.Directory, getAppUserDataDirectory "cabal" lies on OS X
00:28:53 <mm_freak> 3.4 MB currently
00:29:06 <mm_freak> ionit: unpacked it's 50 MB =)
00:29:10 <ionit> thinking of getting a new lappy at the end of Jan'12
00:29:15 <srhb> Excellent idea.
00:29:24 <ionit> samsung maybe
00:29:43 <mm_freak> you may also want to get an operating system =P
00:29:54 <ionit> huh?
00:30:02 <ionit> why? they have win 7 preinstalled
00:30:33 <mm_freak> i rest my case =)
00:30:36 <mm_freak> no, just joking
00:31:01 <ionit> and heard rumors that linux don't play well with lappy hardwares
00:31:07 <applicative> srhb oh does it?
00:31:11 <applicative> ah well
00:31:17 <ionit> so win 7 will suffice
00:31:27 <mm_freak> ionit: in any case, haskell development really needs a lot of HD space…  you should allocate at least 2 GiB to it
00:31:44 <mm_freak> for serious development that is
00:31:44 <ionit> will be getting a 540GB
00:31:48 <applicative> hm :m System.Directory; getAppUserDataDirectory "cabal"  is working for me.
00:31:58 <mm_freak> ionit: i'm sitting in front of a laptop right now
00:32:03 <ionit> besides I am freespace freak,I have 24GB still left free in my 38GB
00:32:07 <mm_freak> the EasyNote LX by PB performs quite well with linux
00:32:57 <ionit> no I have other issues too,I own an iPad which only like itunes for application installation and then I have my ISP whose modem doesn't support linux
00:33:00 <applicative> ionit, well, at least the individual executables you make won't be as gigantic as they used to be
00:33:06 <ionit> so if I use linux then am out of internet as well
00:33:15 <srhb> applicative: I believe it does. I think it's ~/Library/Application Support/cabal, but it says ~/.cabal
00:33:27 <srhb> applicative: But apparently it does keep config files there, so now I'm confused.
00:33:39 <ionit> very confusing
00:34:01 <applicative> oh, yeah, we're not on the same page. I was thinking of .cabal/config, which he should make sure isn't adding profiling libraries
00:34:16 <srhb> applicative: Aha, indeed, was thinking of the packages themselves.
00:34:18 <mm_freak> ionit: nothing wrong with that, but for haskell development you probably still want some unixy commands and a unixy editor
00:34:35 <mm_freak> most haskellers use emacs or vim, but there is also EclipseFP
00:34:46 <ionit> I do have a shell account for unixy stuff
00:34:49 <mm_freak> apparently you can even get a haskell mode for VS 2005
00:34:52 <applicative> oh try getting eclipse on your machine too srhb!
00:35:00 <srhb> applicative: Why? :S
00:35:10 <mm_freak> ionit: not unix stuff, but unixy stuff…  i'm talking about development, which you probably want to do locally
00:35:12 <applicative> i was just kidding, i think it's gigantic
00:35:20 <srhb> Gods.. That wasn't even funny. :P
00:35:37 <ionit> I believe I'll duel boot then?
00:35:49 <mm_freak> ionit: no need to
00:35:53 <ionit> besides I don't need an active internet during development,do I ?
00:35:55 <srhb> ionit: That's the usual way until your conversion is complete. :-)
00:35:59 <mm_freak> (dual-booting is a PITA)
00:35:59 <srhb> No.
00:36:27 <mm_freak> ionit: if you get a decent laptop, you could also just run a real linux in an emulator
00:36:29 <ionit> my isp supplies modems that doesn't work in linux
00:36:34 <mm_freak> but all you need is also available for windows
00:36:42 <ionit> emulator sounds good
00:36:45 <mm_freak> there is emacs for windows and vim for windows
00:36:51 <srhb> ionit: Are you absolutely sure it doesn't? Just because they don't say it's supported doesn't mean it doesnt work.
00:37:00 <applicative> i was thinking we were accepting srhb's hardware as it is, and advising the slimmest haskell setup
00:37:12 <srhb> applicative: You're confusing me and ionit :-)
00:37:28 <applicative> right i just now was yes
00:37:28 <ionit> I am absolutely because without a certain app the modem is just a plain usb drive
00:37:36 <srhb> applicative: (I have 128GB!)
00:37:48 <applicative> i'm not worried about you!
00:37:54 <ionit> me?
00:37:55 <srhb> ionit: Out of curiousity, what's the modem?
00:37:59 <mm_freak> ionit: what's that application's name?
00:38:20 <srhb> I bet it's a huawei..
00:38:31 <ionit> usb-dongle thingy
00:38:34 <ionit> no not huawei
00:38:37 <ionit> its wimax
00:38:37 <srhb> Yes, but the name?
00:38:48 <ionit> no name,branded with my ISP logo
00:39:01 <srhb> It has a name, even if it's branded.
00:39:03 <ionit> its not those 3g stuff
00:39:09 <ionit> well
00:39:13 <ionit> it doesn't say anything
00:39:22 <ionit> just a mac,and brand logo
00:39:29 <mm_freak> ionit: can't you connect using a home router?  i'd be very surprised if you can't
00:39:41 <ionit> well then I gotta buy a gigaset
00:39:41 <srhb> Nah, I realize that. of course you'd have to dig out the name from somewhere, but chances are it works in Linux.
00:39:51 <ionit> it does?
00:39:58 <ionit> wait lemme show you a pic
00:39:59 <mm_freak> it might
00:40:21 <srhb> I doubt I can identify it from a picture :-)
00:40:35 <ionit> no you can see what it is
00:40:41 <mm_freak> ionit: you might want to show us the homepage of the device
00:40:51 <srhb> Usually, those kind of dongles just need usb_modeswitch and they work fine.
00:40:51 <ionit> ??
00:40:53 <ionit> wait
00:40:57 <mm_freak> (even if they specifically claim that it
00:41:02 <mm_freak> linux is not supported)
00:41:27 <ionit> http://ollo.com.bd/devices/dongle
00:41:36 <ionit> here is a brief description
00:41:37 <mm_freak> they say that because they don't want to provide support for linux problems
00:42:10 <ionit> it says it supports mac
00:42:20 <ionit> so there COULD BE a way to make it work in nux
00:42:32 <mm_freak> that doesn't help
00:42:46 <ionit> what?
00:43:27 <ionit> well most of the non-cable isps distribute these,tuned to their own allocated frequency
00:43:28 <mm_freak> there is reason to believe that /software/ compiling under mac compiles under linux as well, but for hardware that's a different story
00:43:47 <srhb> I believe that's a Beceem BCS250 chip, it works in Linux.
00:43:50 <ionit> cable isps are pretty much dead
00:43:58 <ionit> wow!!
00:44:21 <ionit> how so?
00:44:49 <srhb> Requires some fiddling - do you speak Russian?
00:45:01 <ionit> these kiddies are manufactured by ZTE corp
00:45:08 <ionit> no,no speak russian
00:45:19 <ionit> only spaks english
00:45:25 <srhb> Shame, neither do I, and there's a solution on a Russian forum.
00:45:27 <eyebloom> Has anyone else had the experience that breakpoints in Ghci seem to trigger only sporadically?
00:45:42 <ionit> google translate maybe?
00:45:58 <srhb> But I guess we've veered too far off-topic now, and you should have a google if you want to pursue the issue. I'll give you the link and you can try on your own or on a Linux channel.
00:46:12 <srhb> ionit: http://vyteniss.wordpress.com/2011/11/12/gidas-ubuntu-11-10-mezon-ir-zte-ax326/
00:46:31 <ionit> well first let me get my lappy,then decide on a distro and then...
00:46:45 <srhb> ionit: Save the link for now. And good luck with it.
00:47:03 <ionit> I doubt that my isp will like it
00:47:30 <ionit> they could overcharge me
00:47:54 <applicative> eyebloom, i'm not sure who among the regulars here is skilled with the ghci debugger
00:49:00 <eyebloom> Seems I need to reload before it will trigger again.
00:49:19 <eyebloom> perhaps thats normal.
00:51:06 <jdavis> Reading further in LYAH: "One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list." Can someone please explain in a little more detail?
00:51:21 <jdavis> http://learnyouahaskell.com/higher-order-functions
00:51:47 <ionit> what are the 'comments' in RWH?
00:52:33 <srhb> ionit: People (like you) commenting on sections, usually wordings.
00:52:41 <ionit> oh
00:52:48 <ionit> say how do I clean up the ghci?
00:52:53 <ionit> clear doesnt work
00:53:58 <applicative> type :? for help
00:54:16 <srhb> ionit: It depends what you mean by "clean up"
00:54:22 <ionit> parse error on input '?'
00:54:33 <ionit> I mean the clear screen thingy
00:54:37 <srhb> colon ?
00:54:38 <srhb> not just ?
00:54:41 <srhb> :?
00:54:45 <ionit> like we do clear in nux and cls in dows
00:55:02 <ionit> I see a yellow bubble with ? in it
00:55:04 <srhb> :!cls or :!clear should work, I think
00:55:31 <ionit> cls
00:55:32 <ionit> works
00:55:33 <srhb> ionit: read what I'm writing - it is a colon character ":" followed directly by a question mark "?"
00:55:44 <applicative> oh yes :clear
00:56:07 <ionit> yep,done it,first didn't see it like that,using chatzilla so your :? is transformed into emo ?
00:56:31 <applicative> ha
00:56:48 <applicative> to clear screen type :)
00:56:50 <srhb> ionit: If you have smileys on you're going to have hell once you start asking about operators in #haskell
00:57:07 <shachaf> jdavis: Right folds are much more "fundamental" than left folds.
00:57:10 <shachaf> (On lists.)
00:57:11 <ionit> hah
00:57:16 <applicative> it can be very funny
00:57:18 <ionit> :)
00:57:20 <srhb> true.
00:57:24 <ionit> lol
00:57:37 <srhb> "So I'm using the sadface operator on lists, but it isn't working..."
00:57:46 <ionit> rolf
00:57:54 <ionit> okay now am bad in spelling
00:58:13 <ionit> there's a sad face operator?
00:58:24 <ionit> oh
00:58:26 <ionit> :_)
00:58:35 <shachaf> jdavis: That explanation is a bit confusing, perhaps. Are you still around?
00:59:01 <applicative> that wouldn't be valid.  (:[]) is
00:59:12 <jdavis> shachaf: here
00:59:30 <jdavis> shachaf: trying to figure out exactly what you mean.
00:59:35 <ddarius> shachaf: That explanation is worse than "a bit confusing."
01:00:09 <shachaf> ddarius: Which one? My sentence wasn't intended as an explanation but as the beginning of one.
01:00:22 <shachaf> However you're probably better off ignoring that sentence, come to think of it.
01:00:23 <jdavis> The specific thing I was originally confused about in LYAH is: how do you do a right fold on an infinite list -- there is no right "end".
01:00:31 <applicative> ionit, but anyway, you managed to fit the haskell platform on your machine it sounds like, congratulations
01:00:33 <shachaf> > foldr f z [a,b,c,d]
01:00:34 <lambdabot>   f a (f b (f c (f d z)))
01:00:36 <shachaf> > foldl f z [a,b,c,d]
01:00:41 <ddarius> shachaf: The one you were referring to.
01:00:41 <ionit> heh
01:00:42 <lambdabot>   mueval: ExitFailure 1
01:00:42 <lambdabot>  mueval: Prelude.undefined
01:00:53 <shachaf> > foldl f z [a,b,c,d]
01:00:55 <lambdabot>   f (f (f (f z a) b) c) d
01:01:02 <ionit> 12 + "haskell"
01:01:15 <ionit> > 12+"haskell"
01:01:16 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
01:01:16 <lambdabot>    arising from the literal ...
01:01:22 <ddarius> shachaf: Your complete lack of an explanation at that point is less confusing.
01:01:22 <ionit> nice
01:01:22 <applicative> > show 12 + "haskell"
01:01:23 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
01:01:23 <lambdabot>    arising from a use of `GHC...
01:01:35 <ionit> > :?
01:01:35 <lambdabot>   <no location info>: parse error on input `:?'
01:01:37 <applicative> > show 12 ++ "haskell"
01:01:38 <lambdabot>   "12haskell"
01:01:44 <ionit> ++?
01:01:51 <ionit> it adds num to string?
01:01:52 <applicative> damn these types, why doesn't it just understand me??
01:01:59 <srhb> ionit: It concatenates lists.
01:02:04 <ionit> 12 ++ "applicative"
01:02:05 <ddarius> :t (++(
01:02:06 <lambdabot> parse error (possibly incorrect indentation)
01:02:07 <applicative> ionit, no way!
01:02:09 <ddarius> :t (++)
01:02:10 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:02:13 <jdavis> so a right fold on an infinite list isn't any better than a left fold, it just turns into: f (f (f (f (f...
01:02:14 <srhb> ionit: You forgot > in front
01:02:25 <srhb> ionit: But it's also a type error since 12 is not a list
01:02:27 <ionit> > 12 ++ "aplicative"
01:02:28 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
01:02:28 <lambdabot>    arising from the literal ...
01:02:31 <srhb> See
01:02:35 <shachaf> jdavis: A right fold *is* better, because f can be lazy in its second argument.
01:02:43 <ionit> > damn
01:02:44 <lambdabot>   Not in scope: `damn'
01:02:49 <srhb> > "12" ++ applicative
01:02:50 <lambdabot>   Not in scope: `applicative'
01:02:52 <srhb> Duh
01:02:57 <srhb> > "12" ++ "applicative"
01:02:58 <lambdabot>   "12applicative"
01:03:01 <ionit> > show 12 ++ "applicative"
01:03:02 <lambdabot>   "12applicative"
01:03:07 <ionit> wow!
01:03:08 <shachaf> jdavis: In the case of the left fold, foldl needs to recurse all the way to the end of the list before it actually has any arguments to call f with.
01:03:12 <applicative> > 12 + length "applicative"
01:03:12 <lambdabot>   23
01:03:18 <shachaf> Whereas with foldr it can call f straight away.
01:03:20 <srhb> Yeah here show 12 is getting the string representation of 12
01:03:21 <ionit> 23?
01:03:37 <applicative> > length "applicative"
01:03:38 <lambdabot>   11
01:03:38 <ionit> oh length + 12
01:03:39 <shachaf> Which means that, if f is sufficiently lazy, it can return something straight away.
01:03:39 <jdavis> shachaf: Oh! That makes sense.
01:03:58 <ddarius> > getSum (Sum 12 ++ Sum (length "applicative"))
01:03:59 <lambdabot>   23
01:04:01 <shachaf> jdavis: You can think of foldr as replacing each (:) with an "f" and the (possible) [] with a "z".
01:04:21 <shachaf> So foldr (\x xs -> x : xs) [] is just id.
01:04:25 <srhb> Speaking of which, can I make ghci show the evaluation of folds like lambdabot?
01:04:36 <shachaf> srhb: Install some package.
01:04:37 <applicative> is ++ used for monoid in lambdabot?
01:04:41 <shachaf> Look at lambdabot's source to figure out which one.
01:04:43 <ddarius> srhb: lambdabot is just using a library
01:04:52 <srhb> shachaf, ddarius: Thanks.
01:04:56 <ddarius> @hoogle SimpleReflect
01:04:56 <lambdabot> No results found
01:05:08 <ddarius> @google site:hackage.haskell.org SimpleReflect
01:05:09 <lambdabot> http://hackage.haskell.org/package/simple-reflect
01:05:10 <lambdabot> Title: HackageDB: simple-reflect-0.2
01:05:24 <ionit> > max 100 100
01:05:25 <lambdabot>   100
01:05:40 <shachaf> jdavis: The foldr of a list (e.g., [1,2,3] --> (\f z -> foldr f z [1,2,3]) ) is exactly equivalent to the list.
01:05:42 <ionit> > min 1 (-1)
01:05:43 <lambdabot>   -1
01:06:15 <shachaf> jdavis: That is, you can go from the list to the foldr of it (by using foldr), and from the foldr of it to the list (by calling it with (:) and []).
01:07:10 <jdavis> shachaf, ok, so you mean it's more fundamental because 1:2:3:[] is essentially just foldr.
01:07:56 <ddarius> There is an interesting connection between left and right folds via limits and colimits of the loop diagram.
01:08:03 <ionit> > 1:2:3:a:[]
01:08:04 <lambdabot>   [1,2,3,a]
01:08:06 <shachaf> jdavis: It's not "essentially just foldr", but if you have the function (\f z -> foldr f z (1:2:3:[])), you can easily get [1,2,3] from it.
01:08:07 <ionit> wow!!
01:08:18 <ionit> >lst [1,2,3,b]
01:08:25 <ionit> ?
01:08:44 <jdavis> ok
01:08:45 <shachaf> ionit: If you want to experiment with lambdabot, you can also do it in /msg. :-)
01:08:52 <ionit> I see
01:09:02 <ionit> sorry for bothering you
01:09:29 <shachaf> jdavis: foldr f z (1 : 2 : 3 : []) === 1 `f` 2 `f` 3 `f` z
01:09:31 <ionit> I have this huge .NET FRAMEWORK installation going so most of the stuff are not responding
01:09:45 <applicative> it's okay, ionit  you can go back and forth so we can explain what's going wrong
01:09:57 <srhb> ionit: But you can just write lambdabot directly, no reason to stop entirely. :)
01:10:12 <ionit> :)
01:10:45 <srhb> If something stumps you, feel free to take it to public so we can see it.
01:10:46 <applicative> ionit, I always have a conversation going with lambdabot when i'm on here, if only because my typing is too dreadful to get things right the first time
01:10:47 <ddarius> shachaf: The default fixity is infixl.
01:10:49 <ionit> > a:b:c:":)":[]
01:10:50 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
01:10:50 <lambdabot>         against inferred ...
01:11:03 <ionit> so how do I put the smiley in the list?
01:11:18 <srhb> ionit: Strings are actually lists of characters.
01:11:20 <shachaf> ddarius: I considered adding parentheses and decided to err on the side of clarity.
01:11:45 <srhb> ionit: a character is something like 'a' and a string "a" is 'a':[]
01:11:56 <ionit> so
01:11:58 <ddarius> shachaf: I don't see how choosing an ambiguous (to someone unaware of the default fixity, incorrect for someone aware) is clearer.
01:12:00 <applicative> ionit, the simple reflect module with its 'a' and 'b' and so on is rather strange haskell.
01:12:09 <ddarius> +syntax
01:12:16 <shachaf> ddarius: Fair enough.
01:12:34 <applicative> ionit, its in lambdabot for just the reason ddarius and shachaf are using it
01:12:38 <srhb> ionit: 'a':'b':':':')':[]
01:12:39 <shachaf> jdavis: foldr f z (1 : (2 : (3 : []))) === 1 `f` (2 `f` (3 `f` z))
01:12:45 <srhb> > 'a':'b':':':')':[]
01:12:46 <lambdabot>   "ab:)"
01:13:13 <ionit> hmm
01:13:13 <srhb> Or simply "ab:)". That is a list with the characters a, b, : and )
01:13:25 <ionit> but the lambdabots :) isn't being shown as the smiley
01:13:46 <srhb> ionit: That's just your irc client. I told you to turn off smileys. ;)
01:13:55 <ionit> how?
01:13:58 <ddarius> > [a,b,c,smiley]
01:13:59 <ionit> oh
01:13:59 <lambdabot>   Not in scope: `smiley'
01:14:00 <srhb> God knows.
01:14:15 <jdavis> shachaf: what I am seeing now, is that if I define a function using foldr properly, it can handle infinite lists. For instance: let mapA f list = foldr ((:) . f) [] list
01:14:28 <jdavis> take 10 (mapA (+2) [1..])
01:14:46 <ddarius> > foldr const undefined [0..]
01:14:47 <lambdabot>   0
01:15:01 <shachaf> jdavis: It's not just about infinite lists (although that's a clear demonstration), but about laziness in general.
01:15:22 <ddarius> > foldr const undefined (0:undefined)
01:15:23 <lambdabot>   0
01:15:30 <jdavis> Ok. I think I'm getting it.
01:15:37 <jdavis> Thank you very much.
01:15:51 <shachaf> jdavis: Keep in mind that foldl is almost never the function you want to use.
01:16:01 <shachaf> It's usually either foldr or foldl'.
01:16:01 <ionit> :)
01:16:45 <applicative> foldl' rules
01:16:51 <jdavis> shachaf, I see, a non-strict foldl basically has no advantage.
01:17:11 <ddarius> jdavis: I doubt you see.
01:17:15 <shachaf> jdavis: It's not about "having an advantage". It gives you the worst of both worlds.
01:17:31 <jdavis> ddarius: ?
01:17:41 <applicative> where is a good account of this?
01:18:24 * shachaf tries to get a foldl stack overflow, is foiled by ghc's automatic stack growing.
01:18:32 <ionit> > let doub x = x + x in map doub [5,10,9,6]
01:18:33 <lambdabot>   [10,20,18,12]
01:19:30 <shachaf> @ty and . (zipWith (<=) <*> tail)
01:19:31 <lambdabot> forall a. (Ord a) => [a] -> Bool
01:20:06 <ddarius> applicative: The fold pages on the wiki as well as the Stack overflow page on the wiki.
01:20:19 <jdavis> shachaf: I guess I'm having trouble figuring out how foldl could not be strict. If it has to compute the entire thing before returning anything, isn't that similar to being strict?
01:20:26 <ddarius> Really, if you just evaluate by hand a bit, which is better when in pretty easy to see.
01:20:42 <ddarius> Both foldl and foldr are strict.
01:21:12 <ddarius> (To be precise, the function they produce when applied to two arguments is strict.)
01:21:20 <applicative> yeah i was looking for an especially lucid one.  http://www.slideshare.net/tibbe/highperformance-haskell 8 - 30 makes good points leading up to foldl' but isn't ideal
01:21:36 <shachaf> > foldl undefined `seq` 1 -- Aw.
01:21:37 <lambdabot>   1
01:21:46 <srhb> applicative: There was a question about this the other day on Stackoverflow, let me find the link
01:22:29 <srhb> applicative: http://stackoverflow.com/questions/8669595/tail-recursion-recognition look at the link I posted in the comments to the question, too.
01:22:31 <applicative> its a point that can be expressed perfectly in skilled hands
01:22:56 <ddarius> applicative: I think the explanation on http://www.haskell.org/haskellwiki/Stack_overflow is pretty lucid.
01:23:10 <ionit> strange,lambdabot isn't responding to me
01:23:10 <ddarius> Admittedly, I was the person who made the original version of that page.
01:23:15 <ionit> it doesn't reply back in pvt
01:23:26 <srhb> ionit: Remember the >
01:23:34 <ionit> yep I did it
01:23:45 <jdavis> OK, thank you. I'll read up on those.
01:23:58 <srhb> ionit: /msg lambdabot > 2 + 2
01:24:48 <ionit> nope
01:24:48 <shachaf> ddarius: "If you are not writing your code tail-recursively, then that is why you are getting stack overflows."
01:24:50 <ionit> not working
01:25:03 <srhb> ionit: Yes it does, maybe your irc client is playing tricks on you again.
01:25:05 <shachaf> That would seem to be the opposite of correct in many cases.
01:25:15 <ionit> okay
01:25:30 <ionit> ghci is responding again
01:25:33 <ionit> lemme try there
01:26:16 <ddarius> shachaf: As is explained, but there's also a huge amount of confusion in the stack overflow responses srhb referred to.
01:27:17 <ddarius> shachaf: Also, I wrote the original of that page almost a decade ago and others have added and changed.  Those words are mine though, and I do think the wording should be changed.
01:27:39 <ddarius> shachaf: That said, there's a lot of confusion within the Haskell community about the necessity of tail call optimization.
01:27:51 <Phlogistique> I want to write a parser for a language in Haskell; I don't know much about parsing at all (I superficially know what a parser and a lexer are). I'm planning to use Parsec, but another combinator library would be alright. However, I don't really know where to start; is there a good tutorial?
01:27:59 <srhb> ddarius: You're right, I was mostly talking about the link to that mailing list I posted in the comments.
01:28:14 <ddarius> Phlogistique: Read a little about parsing theory first.
01:28:46 <shachaf> "As a C/C++ programmer, I am rather dismayed to see that even in this simple case the compiler cannot do proper tail optimization."
01:28:58 <srhb> shachaf: Don't worry about the question, it's nonsense.
01:29:08 <ddarius> srhb: Indeed.
01:29:28 <ddarius> I don't have a problem with the blatant trolling question, but the responses are horrible.
01:30:39 <srhb> Really, is it that bad?
01:30:39 * ddarius should start using the term "tail call pessimization" to refer to languages that don't "optimize" tail calls.
01:30:43 <ddarius> srhb: Yes.
01:31:02 <srhb> I found the first answer to be reasonable, but perhaps only because I'm too dumb to miss the glaring mistakes. :-)
01:31:19 <srhb> First being top.
01:32:00 <ddarius> srhb: Even the first sentence of the first "answer" is bad.  Also, I don't know if the OP edited the question, but people are apparently not reading the question to which they are responding.
01:32:30 <srhb> I agree about the optimizations, that was clarified in comments that seem to have gone missing.
01:33:00 <srhb> ddarius: I think you haven't read the answer fully though, it does answer the question.
01:33:18 <srhb> Just not in a very direct matter, granted. But nevermind. :)
01:34:59 <ddarius> srhb: I can accurately answer a question and also spread a lot of misinformation.
01:37:05 <Phlogistique> ddarius: thanks. Any advice?
01:37:22 <Phlogistique> (about a parsing theory tutorial)
01:37:53 <applicative> the response of nponeccop to the stackoverflow question seemed not bad :)
01:37:57 <ddarius> Phlogistique: Parsing theory is well understood.  You should be relatively safe with just about any not-some-random-person's-blog-post introduction.
01:38:35 <Phlogistique> I'll try Wikipedia then
01:38:42 <shachaf> ddarius: There exist sources of information that are "not-some-random-person's-blog-post"?
01:39:01 <shachaf> Going by IRC, you wouldn't know it.
01:39:03 <applicative> Phlogistique: the Parsec tutorial is pretty good, but it is unfortunately a little out of date due to changes in the library
01:40:19 <ddarius>  pplicative: How did it seem not bad?  Left folds are not a "perversion."  The OP's code is not not idiomatic Haskell.  While foldl is something to avoid foldl' is not.  foldr is not "backwards iteration."
01:40:55 <ddarius> applicative: The Parsec tutorial assumes you already know parsing theory, or at least it provides no direction on it.
01:41:04 <applicative> calling foldl a perversion is going too far yes
01:41:05 <Phlogistique> (Also, I read the "Write a scheme in 48 hours" tutorial; which was pretty interesting, but also more of a portfolio than a real tutorial for Parsec)
01:41:35 <applicative> i don't know i read it without knowing much
01:41:44 <ddarius> I would recommend reading the Parsec letter at some point, but you are going to have a lot of troubles using any parsing library without the basics of parsing theory.
01:41:54 <applicative> i guess i was learing about parsing from other things at the same time
01:41:55 <Rodayo> Does anyone see something obviously incorrect with this: "map (chr . (- 3) . ord) "khoor"" I don't feel like copying the error message =P
01:42:04 <Rodayo> (+ 3) works without a hitch
01:42:14 <srhb> Rodayo: -3 is unary minus 3
01:42:29 <srhb> Rodayo: Try (subtract 3) or using flip
01:42:36 <ddarius> (+(-3))
01:42:58 <shachaf> > (-3+) 5
01:42:59 <lambdabot>   2
01:43:06 <Rodayo> srhb: hmm strange. If I try to use it like: "let a = 4 - 2" it treats it as the binary operator
01:43:08 <applicative> Rodayo: it's a familiar glitch in the syntax
01:43:15 <srhb> Rodayo: Because it has both arguments.
01:43:20 <shachaf> Rodayo: It's a special case for "-".
01:43:28 <srhb> shachaf, ddarius: Awesome unreadable solutions. ;)
01:43:36 <Rodayo> fair enough, i'll make a note of it
01:44:02 <applicative> Rodayo: the section syntax is sugar and it breaks down for -, it had to be the unary -
01:44:40 <Rodayo> +(-3) will suffice for me since it's just a small exercise.
01:44:47 <srhb> Rodayo: It's pretty much the reason why subtract is there.
01:44:58 <srhb> Rodayo: (subtract 3) 5 is fairly readable
01:45:35 <applicative> Phlogistique: Real World Haskell has a section on the use of Parsec http://book.realworldhaskell.org/read/using-parsec.html
01:45:37 <Rodayo> I suppose, but programmers with a bit of OCD might find it tempting to make a symetric "add" function
01:45:43 <Rodayo> unless that's already there?
01:45:53 <srhb> Rodayo: It's not
01:46:16 <shachaf> Rodayo: If unary + existed in the langauge, and if (+) wasn't commutative, it would make sense.
01:46:17 <ddarius> @src otherwise
01:46:17 <lambdabot> otherwise = True
01:46:26 <shachaf> @let notherwise = False
01:46:27 <lambdabot>  Defined.
02:00:27 <ddarius> @undefine
02:00:34 <ddarius> @let n'otherwise = False
02:00:35 <lambdabot>  Defined.
02:09:51 <applicative> has an opinion of the wise yet emerged about 'conduits'?
02:13:32 * hackagebot data-accessor 0.2.2.1 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.2.1 (HenningThielemann)
02:13:35 <wingie> if a function is using a library code will it be considered unpure?
02:14:37 <wingie> let's say it's using a library function to do something
02:15:04 <miden> hello there!
02:15:40 <miden> Does anyone know how can i express for example this data type : data Program =	Program [Rule] 				deriving (Eq,Show)     in happy rule?
02:16:44 <applicative> wingie why would a function be any more or less impure if it was imported from a library?
02:17:21 <wingie> applicative: i mean a function that is using another library function
02:17:52 <applicative> wingie the answer must be no, what puzzles me is what makes you think it might be otherwise
02:18:05 <wingie> applicative: since im new =)
02:18:51 <wingie> applicative: but that depends on the function that is used i guess
02:19:02 <applicative> wingie, in Haskell when you import something from another module it isn't all that different from just copying the definition into your module.  There are plenty of further subtleties of course
02:19:25 <wingie> yeah
02:19:49 <wingie> if the library function is impure then the function itself is impure, vice versa
02:20:07 <wingie> copying code is a good explanation
02:21:16 <applicative> wingie but why are you worrying about 'purity' and 'impurity'
02:21:38 <wingie> applicative: thought that was an important thing to be aware of in haskell
02:21:56 <wingie> (and since im using JavaScript for doing functional programming)
02:22:56 <applicative> if you think of the things in IO types and the like as 'impure' then the type system will tell you soon enough if you are doing things wrong
02:23:16 <wingie> yeah
02:23:20 <shachaf> applicative: It has little to do with the type system.
02:23:37 <shachaf> Or, well, not in the sense you seem to be implying.
02:23:45 <applicative> shachaf: what does, i am still trying to penetrate wingie's worry
02:23:47 <shachaf> If the type system didn't stop you, a runtime error would.
02:24:02 <shachaf> Anyway, yes, I see the context.
02:25:45 <applicative> I was just thinking, sometimes there's difficulty grasping the difference between say Int and IO Int and so on, but module imports don't pose any further impediment to undesstanding
02:26:36 <applicative> wingie, have you found a good tutorial?
02:30:46 <Jonno_FTW> @seen pastorn
02:30:47 <lambdabot> Unknown command, try @list
02:30:56 <Jonno_FTW> is there a bot here that does that?
02:31:31 <Jonno_FTW> @list
02:31:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:32:08 <shachaf> preflex: seen pastorn
02:32:09 <preflex>  pastorn was last seen on #haskell 194 days, 14 hours, 11 minutes and 20 seconds ago, saying: gwern: ^^^
02:32:27 <Jonno_FTW> I guess I won't be able to find him then
02:33:09 <applicative> famous last words, gwern: ^^^
02:33:39 <shachaf> preflex: xseen pastorn
02:33:39 <preflex>  pastorn was last seen on freenode/#haskell 194 days, 14 hours, 12 minutes and 50 seconds ago, saying: gwern: ^^^
02:34:01 <Jonno_FTW> I think I have his email somewhere, I'll try that
02:35:20 <applicative> it's on his github site
02:35:45 <applicative> his last blogpost says "I'm tasked to rewrite the haskell package OpenGL this summer. .."
02:35:50 <applicative> maybe it killed him.
02:36:09 <Jonno_FTW> yeah, that was the last thing he said in the channel I talked to him in
03:11:27 <ksf> is camp dead?
03:13:19 <danr> Jonno_FTW: I met pastorn irl after this summer, alive, and saying that his OpenGL project didn't go so well, but not leaving any details
03:27:24 <Veinor> @pl \a b -> a + b / a
03:27:25 <lambdabot> liftM2 (.) (+) (flip (/))
03:27:51 <Veinor> @pl \a b -> a + a / b
03:27:52 <lambdabot> liftM2 (.) (+) (/)
03:29:31 <KorriX> How to use 'multiple' functions inside of comprehensed lists ex. test x = [y | y <- [2..ceiling $ sqrt x] - doesn't compile
03:29:32 <KorriX> ?
03:30:39 <mauke> > let test x = [y | y <- [2..ceiling $ sqrt x] in "ok"
03:30:40 <lambdabot>   <no location info>: parse error on input `in'
03:30:48 <mauke> > let test x = [y | y <- [2..ceiling $ sqrt x]] in "ok"
03:30:49 <lambdabot>   "ok"
03:30:53 <mauke> KorriX: compiles fine
03:31:20 <KorriX> sorry :)
03:31:28 <KorriX> i forgotten about one bracket
03:34:21 <KorriX> > let primes = [x | x <- 2:[3,5..], [y | y <- [2..ceiling $ sqrt x], mod x y == 0] == []] in "ok"
03:34:22 <lambdabot>   "ok"
03:34:40 <KorriX> in my ghc doesn't work
03:34:57 <mauke> how does it fail?
03:35:26 <mauke> oh, ambiguous type
03:35:43 <KorriX> how to make it working ?
03:35:53 <mauke> :t let primes = [x | x <- 2:[3,5..], [y | y <- [2..ceiling $ sqrt x], mod x y == 0] == []] in primes
03:35:54 <lambdabot> forall b. (RealFrac b, Integral b, Floating b) => [b]
03:36:10 <mauke> don't try to apply sqrt to an integer
03:37:20 <KorriX> > [x | x <- [2..ceiling $ sqrt 17]]
03:37:21 <lambdabot>   [2,3,4,5]
03:37:24 <mauke> in fact, I wouldn't write this as a list comprehension at all
03:37:47 <Veinor> @type liftM2
03:37:48 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:38:01 <mauke> KorriX: 17 is a number, not an integer
03:38:06 <mauke> > sqrt (length "hi")
03:38:07 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
03:38:08 <lambdabot>    arising from a use of...
03:39:43 <renze> Could I pattern match on [_], indicating no matter what's in there, as long as the list is one long?
03:40:00 <KorriX> how to cast types in haskell ?
03:40:51 <MostAwesomeDude> renze: I think you can match on _:[]
03:41:27 <ksion> renze: You usually match on (_:[]) for list of length exactly one, and (_:_) for at least one.
03:41:39 <sshine> KorriX, you don't make casts. you make conversions.
03:41:43 <mauke> > filter (\x -> (all (\y -> x `mod` y /= 0) (takeWhile (\y -> y * y <= x) [2 ..]))) (2 : [3, 5 ..])
03:41:44 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:41:58 <mauke> renze: yes
03:42:52 <KorriX> mauke: thanks :D
03:48:14 <Veinor> > let primes = (2:) $ \primes -> (\x -> all (\y -> x `mod` y /= 0) (takeWhile (\y -> y * y <= x) primes)) [3,5..]
03:48:15 <lambdabot>   not an expression: `let primes = (2:) $ \primes -> (\x -> all (\y -> x `mod...
03:48:19 <Veinor> > let primes = (2:) $ \primes -> (\x -> all (\y -> x `mod` y /= 0) (takeWhile (\y -> y * y <= x) primes)) [3,5..] in primes
03:48:20 <lambdabot>   The lambda expression `\ primes -> (\ x -> ...) ...'
03:48:20 <lambdabot>  has one argument,
03:48:20 <lambdabot>  bu...
03:48:34 <Veinor> oh right
03:48:41 <Veinor> > let primes = (2:) $ filter (\x -> all (\y -> x `mod` y /= 0) (takeWhile (\y -> y * y <= x) primes)) [3,5..] in primes
03:48:42 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
04:09:53 <alistra> @quote _pizza_
04:09:53 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
04:38:35 <statusfailed> How could I make a Data/Typeable instance for ClockTime?
04:39:01 <statusfailed> or can I convert it to something else somehow
04:57:57 <tsousa> i want to make an agenda. but in never did any sqlite db programming, can you guys recommend me a tutorial?
05:00:25 <merijn> tsousa: Just look for general SQL tutorials to get the basic idea. Then the you can use the SQLite docs to make sense of any differences
05:00:42 <merijn> The SQLite docs were pretty readable and comprehensive last time I checked
05:01:48 <tsousa> ok another recommendation. i will buy another book in programming. another book in Haskell or K&R?
05:02:12 <ciaranm> k&r is of purely historical interest
05:02:21 <Martty> for C?
05:02:33 <Martty> its a good book o-o
05:02:34 <hpc> tsousa: get the dragon book
05:02:41 <ciaranm> c is of purely historical interest
05:02:49 <ciaranm> proof: _Generic
05:02:57 <tsousa> lool
05:03:07 <tsousa> hpc, i dont even know C properly
05:03:08 <tsousa> lol
05:03:29 <hpc> tsousa: do you know java?
05:03:37 <tsousa> hpc, no
05:03:46 <tsousa> just Python and now a bit of Haskell
05:03:52 <hpc> ah
05:04:25 <alistra> for C read the C99
05:04:26 <alistra> i did
05:04:30 <hpc> https://en.wikipedia.org/wiki/Pointer_%28computer_programming%29 -- congladurations, you now know C
05:04:46 <alistra> but you probably have to read it twice, because of the forward references
05:04:55 <hpc> a pointer is essentially an index into a giant magic array called "memory"
05:05:03 <hpc> and it's really all you need to know to use C well :P
05:05:13 <hpc> the rest is libraries
05:05:19 <tsousa> hpc, yesi know the basics but i am not experienced
05:05:28 <mcstar> hi guys, is it possible to load function definitions from a file, wo changin the context in ghci?
05:05:42 <ksion> hpc: It would come handy to know something this thing called "memory management". Like, why do you ever need to free().
05:05:45 <alistra> :l file?
05:05:57 <hpc> mcstar: or import
05:05:59 <mauke> hpc: no, a pointer is an (array, index) pair
05:06:06 <mauke> i.e. it refers to a specific array only
05:06:08 <mcstar> alistra: but that wipes my let variable = bindings
05:06:26 <alistra> mauke: are there more arrays than a big one?
05:06:29 <hpc> mauke: the array is always "everything" though
05:06:33 <mauke> alistra: yes
05:06:35 <alistra> called virtual memory?
05:06:35 <mauke> hpc: no
05:06:40 <tsousa> ksion, to release the information of some variable
05:06:46 <mauke> alistra: every object is its own memory segment
05:06:47 <tsousa> release the memory space
05:07:14 <alistra> mauke: what do you mean by that
05:07:18 <mcstar> so i should set up a module?
05:07:21 <Philonous> Wirklich eigenartig
05:07:25 <ksion> mauke: Pointer is address of memory cell, not necessarily belonging to any array. And an array is just a continuous slab of memory anyway.
05:07:27 <Philonous> oops, wrong window
05:07:34 <mauke> ksion: wrong
05:07:42 <mauke> ksion: well, not quite
05:07:48 <alistra> each array syntax is just a rewrite to *(arrayptr+index)
05:07:53 <mauke> ksion: in my simplified model every object is an array
05:07:54 <merijn> tsousa: Get K&R, it's short, concise and tells you most stuff you need to know about C
05:07:54 <alistra> each array access
05:08:03 <alistra> there are some type size and allocation differences
05:08:04 <hpc> mauke: what you are describing is not something i would consider a pointer
05:08:08 <merijn> One of the best programming books I read
05:08:52 <mauke> alistra: a pointer is an [array, index] pair. [array, index] + n == [array, index + n].
05:09:01 <mauke> alistra: *[array, index] == array[index]
05:09:11 <mauke> damn, I need better syntax
05:09:12 <ksion> alistra: It's fun when you usr the analogy and write index[arrayptr] ;)
05:09:25 <alistra> and [array, index] == *(array + index)
05:09:36 <mauke> alistra: no
05:09:39 <merijn> This talk of arrays reminds me of one of my most impressive lines of C
05:09:52 * merijn goes to see if he can find it again
05:09:58 <mauke> hpc: then you don't understand C as I do
05:09:58 <alistra> are we arguing about the abstract machine syntax or the semantics?
05:10:15 <mauke> alistra: semantics, because ptr != *ptr
05:10:24 <ksion> mauke: I can pass arrayptr+index to a function and it will be a pointer there, with no knowledge of where the original arrayptr were exactly.
05:10:36 <mauke> ksion: what is your point?
05:10:52 <alistra> that array is a syntactic sugar
05:10:56 <ksion> mauke: That a pointer does not have a "base array" attached to it.
05:10:57 <alistra> for whole-memory pointers
05:11:00 <merijn> alistra: No
05:11:11 <merijn> There is such a thing as an array type in the language
05:11:13 <mauke> ksion: that is no proof
05:11:25 <merijn> You can't really use it all that much as programmer, but it is there
05:11:30 <merijn> And it different from a pointer
05:11:42 <alistra> type differs
05:11:48 <alistra> but after compilation, there's no difference
05:11:59 <merijn> After compilation it's all bytes
05:12:04 <alistra> with pointers you have to compute some sizeofs differently
05:12:06 <mauke> ok, I think I'm going with «array, pointer» for pairs. reasonably simple and doesn't clash with C syntax
05:12:07 <alistra> but it's the same
05:12:07 <merijn> What's you're point?
05:12:21 <mauke> blargh
05:12:28 <mauke> pointer == «array, index»
05:12:36 <alistra> no it's not
05:12:47 <alistra> int *p = 534555;
05:12:51 <mauke> alistra: type error
05:13:11 <chemistree>  
05:13:13 <alistra> 1.c: In function ‘main’:
05:13:13 <alistra> 1.c:3:10: warning: initialization makes pointer from integer without a cast
05:13:19 <mauke> told you so
05:13:21 <alistra> type warning :3 integer promotions
05:13:33 <mauke> C doesn't distinguish between warnings and errors
05:13:35 <ksion> mauke: I wonder where did you get this strange view on pointers. You are the first person I see erring this way.
05:13:38 <mauke> it only has diagnostics
05:13:38 <alistra>         int *p = (int *) 534555;
05:13:43 <alistra> where's your array now
05:13:44 <mauke> ksion: I'm not erring
05:14:00 <mauke> alistra: that operation has implementation dependent results
05:14:06 <mauke> I'm not sure if it's UB
05:14:11 <alistra> no it doesnt
05:14:14 <alistra> UB?
05:14:19 <mauke> undefined behavior
05:14:29 <mauke> hmm, it pretty much has to
05:14:34 <alistra> not really
05:14:36 <hpc> type casts are well-defined
05:14:38 <mauke> yes
05:14:42 <mauke> hpc: no
05:14:47 <alistra> it makes a pointer
05:14:52 <mauke> alistra: prove it
05:14:56 <ksion> It might be a segfalt but that's not because of C defines it to be so.
05:14:58 <alistra> that points to a 534555th int cell
05:15:00 <alistra> in the memory
05:15:04 <mauke> alistra: wrong
05:15:14 <alistra> virtual memory
05:15:21 <mauke> C has no virtual memory
05:15:27 <alistra> OS has
05:15:30 <mauke> C has no OS
05:15:39 * mike-burns watches
05:15:41 <alistra> C program is run in an OS
05:15:44 <mauke> alistra: wrong
05:15:56 <alistra> so any memory for that matter
05:16:01 <alistra> if you don't want an OS
05:16:14 <mauke> what
05:16:36 <alistra> if you have a machine that has some memory and and you load only your C program on it
05:16:39 <alistra> without an os
05:16:48 <alistra> C program into a boot sector or whatever
05:16:53 <mauke> C has no boot sector
05:16:58 <alistra> that pointer will point to the exact place in the array
05:17:02 <alistra> what
05:17:03 <mauke> what array?
05:17:08 <dMazz> teh OS has C
05:17:11 <alistra> memory*
05:17:18 <mauke> what memory?
05:17:29 <mauke> memory locations aren't integers
05:17:29 <alistra> of the machine you are running the C program on
05:17:34 <hpc> C has no semantics! computers never work!
05:17:42 <mauke> I'm not running C on a computer
05:18:00 <alistra> so the program isn't really working is it?
05:18:06 <hpc> can't tell if trolling or abstract nonsense
05:18:11 <mauke> alistra: what, yours?
05:18:23 <mike-burns> This is like watching Zeno talk about software.
05:18:33 <alistra> so the program isn't really working,* is it?
05:18:35 <mauke> hpc: fairly concrete nonsense. the «array, index» model is correct and simple as far as I know
05:18:36 <alistra> what mine?
05:18:43 <mauke> alistra: program
05:18:46 <ksion> hpc: It's almost as if postmodernism invaded computer science :)
05:19:06 <mauke> no, it's almost as if no one understood C
05:19:08 <hpc> mauke: only if you totally ignore that this is C we are talking about
05:19:13 * alistra opens c99 standard
05:19:25 <mauke> hpc: no, you simply don't understand how C works
05:19:59 <chemistree_> Just did a system restore to a date before Haskell 2010 package was installed. Haskell files (16.GB) are still on my hardrive, only inactive(along with GHC). How should i go about re-installing Haskell/GHC?
05:20:02 <hpc> if pointers are tuples in C, i think i would rather be wrong
05:20:11 <chemistree_> Remove all files then re-install for Haskell.org?
05:20:21 <mauke> too bad
05:21:01 <mauke> hpc: let's say you want to compile C down to Lisp. why wouldn't you want to make pointers tuples?
05:21:37 <hpc> mauke: because you don't need to? pointers only ever point into your program's memory, so you just store the index
05:22:00 <mauke> hpc: so you'd reserve a single huge array at the beginning and use that to store all variables?
05:22:04 <hpc> and if they ever point somewhere else, that's going to be an EXPLICIT dereference and it translates in the obvious way
05:22:16 <mauke> hpc: including your "heap"?
05:22:18 <hpc> mauke: sure; that's how C does it
05:22:22 <mauke> no, it isn't
05:23:02 <hiptobecubic> What's stopping cabal from being to build more than .hs at a time, a-la make -jX ?
05:23:25 <hpc> hiptobecubic: same thing stopping ghc
05:23:35 <hpc> (what's stoping ghc? not sure)
05:23:36 <chemistree_> nvm about the huge file size...
05:24:54 <mauke> here's a fun detail: instance Eq (Ptr a) where «a1, i1» == «a2, i2» = a1 == a2 && i1 == i2
05:25:15 <byorgey> hiptobecubic: there has been wome work on getting cabal to build more than one *package* at a time.
05:25:16 <mauke> instance Ord (Ptr a) where «_, i1» <= «_, i2» = i1 <= i2
05:25:24 <mauke> (pseudo C implementation)
05:25:50 <mauke> what I'm trying to say is that inequality checks only compare the index, not the array
05:26:00 <mauke> (because there's no ordering on arrays in general)
05:26:16 <byorgey> hiptobecubic: as for building more than one .hs at a time, cabal has no control over that, but I think getting ghc to do this has been discussed (not sure of the status).
05:26:22 <alistra> -- A pointer type may be derived from a function type, an object type, or an incomplete
05:26:22 <alistra>    type, called the referenced type. A pointer type describes an object whose value
05:26:22 <alistra>    provides a reference to an entity of the referenced type. A pointer type derived from
05:26:22 <alistra>    the referenced type T is sometimes called ``pointer to T ''. The construction of a
05:26:22 <alistra>    pointer type from a referenced type is called ``pointer type derivation''.
05:26:45 <mauke> alistra: and?
05:26:53 <alistra> wait
05:26:58 <alistra> is it the correct one
05:27:02 <alistra> oh
05:27:08 <alistra> you can do a function pointe
05:27:09 <alistra> r
05:27:12 <alistra> there's no array there
05:27:21 <mauke> that's true
05:27:21 <alistra> mr. i know c better than everyone else
05:27:26 <mauke> what I said only applies to object pointers
05:27:33 <mauke> function pointers are completely different beasts
05:27:40 <mauke> for example, they don't support pointer arithmetic
05:27:56 <mauke> and you can't convert between function pointers and object pointers
05:27:57 <hiptobecubic> byorgey, oh. i suppose i meant 'ghc' and not cabal, then.
05:28:10 <alistra> you say don't and can't
05:28:20 <alistra> but what kind of can't do you mean
05:28:23 <mauke> yeah
05:28:32 <mauke> I mean in the context of pure standard C
05:28:37 <dMazz> interesting
05:28:41 <byorgey> hiptobecubic: in that case I'm pretty sure the answer is "not much", just requires someone to do the necessary work.
05:28:42 <hiptobecubic> has Text.Regex.Posix change? [String] is no longer a valid context?
05:29:11 <byorgey> hiptobecubic: although it's quite possibly one of those things that turns out to be more tricky than you think.
05:29:12 <hiptobecubic> byorgey, seems odd to me. I would think it would be in high demand.
05:29:35 <alistra> 2 A pointer to a function may be cast to a pointer to an object or to void, allowing a
05:29:35 <alistra>   function to be inspected or modified (for example, by a debugger) (6.5.4).
05:29:47 <byorgey> sure, but there are tons of things in high demand, and only a few people really working on ghc.
05:29:57 <alistra> J.5.7.2 C99
05:31:07 <mauke> alistra: "J.5 Common extensions"
05:31:11 <mauke> alistra: seriously?
05:31:19 <ehuber_> hello all -- so i have been working on a linux shared library written in haskell for a while now, and it basically does what i want it to do. the problem is that ive been relying on Makefiles right now, and i suppose i should be using cabal.. i did some naive searches on google for info about building shared libraries through cabal but didnt get any good resources.. does anyone know where i should be looking?
05:31:46 <alistra> oh
05:31:48 <alistra> sry
05:31:48 <ehuber_> or am i better off just leaving it as a Makefile :)
05:32:05 <alistra> now reading the pointer arithmetic section
05:32:09 <hiptobecubic> RWH even *recommends* using [String] context instead of String, but that functionality is apparently no longer present?
05:32:16 <alistra> there's no explicit 'we can't do that'
05:33:01 <mauke> alistra: all that's required is a missing 'we can do that'
05:33:37 <mauke> alistra: also, 6.5.6/2
05:34:06 <mauke> alistra: "For addition, either both operands shall have arithmetic type, or one operand shall be a pointer to an object type and the other shall have integer type."
05:34:06 <alistra> and?
05:34:14 <mauke> that rules out function pointers
05:34:23 <alistra> oh
05:34:39 <hpaste> “^^thief^^” pasted “Attempting to print an array of items retrieved from my StateT monad” at http://hpaste.org/55919
05:34:40 <alistra> well you were right then
05:35:11 <alistra> it doesn't mean that i didn't compile and invoke a (insert + 1) function in my time
05:35:27 <nitronous> I've got a list of pixels (coordinates), and I want to turn that into an image; what's a good way to do that?
05:35:42 <merijn> alistra: Oh sure, but GCC allows all sorts of vile and wrong things
05:35:51 <^^thief^^> ^ my State monad returns type "StateT AppData IO [Record]" - how can I pattern match for that so I can access the individual Record items?
05:36:09 <mauke> alistra: that seems unlikely
05:36:12 <mauke> since functions don't have a size
05:36:26 <merijn> alistra: There is a reason why clang has the flag "-fheinous-gnu-extensions" flag
05:36:55 <byorgey> ^^thief^^: what is the type of printRecords?
05:37:30 <^^thief^^> byorgey: it can be anything - I'm just trying to print it for debugging purposes for the moment
05:37:46 <mike-burns> nitronous: That's a BMP file in essense, as I understand it. That said, I don't know more than that.
05:37:48 <^^thief^^> right now I just have "printRecords (x:xs) = …"
05:38:34 <byorgey> ^^thief^^: well, then perhaps you want something like  getRecords >>= (liftIO . printRecords)
05:38:45 <byorgey> if printRecords has type  [Record] -> IO ()
05:39:05 <^^thief^^> byorgey: thanks I will try that
05:40:38 <alistra> http://dpaste.com/679677/ mauke
05:41:28 <^^thief^^> byorgey: that did the trick - thanks a million
05:41:32 <mcstar> lets say, i have a file MyModule.hs in the current directory, contents: module MyModule where <function definitions>, i cant load this module in ghci, what am i doing wrong?
05:41:37 <merijn> alistra: :(
05:41:47 <alistra> haters gonna hate
05:41:48 <merijn> alistra: That ruined the end of this year...
05:42:32 <mauke> alistra: gcc doesn't even claim to be a C compiler by default. you need -ansi -pedantic
05:42:38 <nitronous> mike-burns: ok, thanks. the problem is that I'd like to not have to keep the whole list in memory as I go along, and I don't see how I'd use it to make a bitmap other than to start by sorting the list
05:42:59 <nitronous> (or writing a blank BMP file and then modifying it for each element in the list, which I'm sure is a horrible idea)
05:43:36 <merijn> mauke: And even then it allows wrong things
05:43:44 <mauke> merijn: of course
05:43:48 <alistra> 1.c:12:15: warning: pointer to a function used in arithmetic
05:43:53 <merijn> mauke: Using icc and the solaris compiler on my code was an eye opener
05:43:55 <alistra> 1.c:12:15: warning: arithmetic on a pointer to the function type 'int (int)' is a GNU extension [-pedantic,-Wpointer-arith]
05:44:00 <mauke> there we go, that's your diagnostic
05:44:22 <alistra> why std=c99 doesn't suffice?
05:44:31 <alistra> ah
05:44:36 <alistra> it's c89
05:44:38 <alistra> ansi
05:44:56 <alistra> in c99 it's okay apparently
05:44:57 <mcstar> pls guys enlighten me
05:45:15 <mauke> alistra: you always need -pedantic
05:45:48 <mauke> "-pedantic  Issue all the warnings demanded by strict ISO C and ISO C++"
05:46:00 <mauke> in other words, gcc will silently ignore some errors by default
05:46:28 <amkh8581> hi
05:46:53 <amkh8581> is there anyone who can help me with type checking stuffs?
05:47:04 <alistra> clang man doesn't even explain what pedantic does
05:47:14 <byorgey> mcstar: what error do you get?
05:47:30 <merijn> alistra: Do you know what pedantic means? The flag seems fairly self-explanatory
05:47:38 <byorgey> amkh8581: just ask your question, and if someone can help you they will.
05:47:45 <alistra> merijn: no it doesn't
05:47:54 <alistra> i know what the word means
05:47:55 <byorgey> mauke, alistra, merijn: can we take the discussion of C somewhere else please?
05:47:56 <mauke> merijn: gcc -pedantic is more like gcc -basic-sanity
05:48:13 <mauke> ok, I'll shut up here. follow ups in #haskell-blah
05:48:33 <amkh8581> I am trying to develop a type checker for some pi calculus based syntax
05:48:52 <mcstar> byorgey: when i try import MyModule: module is not loaded
05:49:07 <amkh8581> and the question is that how to type check a term inside a output agent
05:49:35 <mcstar> with :m + MyModule : Could not find module
05:50:16 <amkh8581> the agent is like this: term*term*pi
05:50:18 <byorgey> mcstar: import/ :m +  is only for modules that have been installed in the ghc package DB
05:50:28 <byorgey> mcstar: use :load for stuff in the current directory
05:50:57 <amkh8581> and the type rule is : e |- m: t , e |- n : t , e
05:51:04 <amkh8581> e |- p
05:51:14 <amkh8581> the n the agent output is well typed
05:51:31 <amkh8581> i dont know how to call type checker for those m and n
05:51:34 <mcstar> byorgey: http://learnyouahaskell.com/modules#making-our-own-modules uses import on user-modules
05:51:35 <amkh8581> terms
05:52:01 <hiptobecubic> :t =~
05:52:02 <lambdabot> parse error on input `=~'
05:53:30 <byorgey> mcstar: that is actually referring to using your module in another module, by putting 'import MyModule' at the top of the file, not the ghci prompt
05:53:44 <byorgey> mcstar: but it is not explained well
05:53:55 <mcstar> byorgey: so i should use 2 files?
05:54:00 <byorgey> mcstar: no, you don't have to
05:54:13 <byorgey> mcstar: just use  :load MyModule.hs  at the ghci prompt
05:54:21 <mcstar> i just want to conviniently load functions definitions wo changing prelude context
05:54:39 <byorgey> if you *want* to refer to MyModule from another .hs file in the same directory, you may do so by putting 'import MyModule' at the top
05:55:07 <byorgey> mcstar: what do you mean "without changing prelude context" ?
05:55:21 <mcstar> lets say, i have some bindings already
05:55:26 <mcstar> let something = [1,2,3]
05:55:32 <mcstar> if i say :l MyModule
05:55:40 <mcstar> then i lose that binding
05:56:08 <byorgey> right.  unfortunately there's no way around that.
05:56:33 <mcstar> ok, thanks for clarifying that
05:58:11 <mcstar> im used to the common lisp repl :(
06:02:31 <hiptobecubic> How does one get all the matches from a regex now? using [Type] contexts doesn't seem to work anymore
06:03:43 <hiptobecubic> "a b c" =~ "(a|b|c)" :: [String]  should return ["a", "b", "c"] but it won't compile because there's no RegexContext for [String]
06:12:12 <Philonous> byorgey:  Do you know whether there exist example solutions to the exercises in "software foundations" ?
06:28:34 <scooty-puff> does anyone here know a bit about hoopl?
06:29:12 <scooty-puff> i was wondering if it could be used to insert explicit "return" statements into a list of instructions
06:29:48 <scooty-puff> i plan on using it for type checking - any basic block that doesn't is a terminal with no successors should have a "return void;" added - which is used in type checking
06:34:30 <scooty-puff> *basic block with no successors
06:35:36 <nitronous> sorry for asking again but - I've got a list of pixels (coordinates), what's a good way to write that to an image file, without having the whole list in memory at any time?
06:40:13 <renze> nitronous: I don't know what's faster, but you could use ByteString.writeFile once ore ByteString.appendFile after every pixel/every line
06:40:29 <irene-knapp> @hoogl unfold
06:40:29 <lambdabot> Maybe you meant: hoogle hoogle+
06:40:33 <irene-knapp> @hoogle unfold
06:40:33 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:40:33 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
06:40:33 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
06:40:40 <nitronous> renze: but my list of pixels is not in order
06:41:09 <renze> File handling with ByteString is fast, I went from +- 30 seconds to 3-6 with reading a file
06:41:27 <irene-knapp> > unfoldr (\n -> if n > 0 then Just (2 * n, n - 1) else Nothing) 5
06:41:28 <renze> nitronous: ah, that's a problem. Then I don't know
06:41:28 <lambdabot>   [10,8,6,4,2]
06:41:31 <irene-knapp> hmm
06:41:32 <irene-knapp> okay
06:41:54 <nitronous> renze: ok, thanks
06:44:17 <renze> nitronous: maybe you can write the results of every pixel to an IntMap and then read everything in order? IntMap gives you sorting in O(n) in that case
06:45:38 <nitronous> renze: but that's going to require having the whole thing in memory, to do the sorting, no?
06:45:44 <Saizan> it does
06:46:05 <Saizan> nitronous: maybe it can be solved by mmap
06:46:10 <renze> yes, not gonna help either thus
06:49:11 <chemistree> I have a question about how I should Install Haskell package
06:49:20 <chemistree> I just did a system restore
06:49:30 <chemistree> to a date before haskel package was installe
06:49:37 <chemistree> ^d
06:49:49 <nitronous> would creating an SVG file with loads of points and their colours be awful? (ie essentially using SVG as a raster format)
06:50:01 <chemistree> there seems to be folders with all the libraries of haskell and GHC and all that
06:50:24 <chemistree> But it seems to be just idle... not really installed
06:50:53 <chemistree> Should I just delete all these files and re-install? or is there a better/safer way?
06:59:11 <nitronous> ok well I'll try the SVG approach, and tell you how it goes
07:07:25 <Kanisterschleife> hi. suppose I have a type constructor Test with one free type variable. How can I describe the type: "For all types a: Test a"? If I wanted to describe "For all types in a in typeclass Bla: Test a" this would by (Bla a) => Test a, but how can I say "for all types, no restriction"? Is there a type class of all types?
07:08:23 <Kanisterschleife> sorry for my typos.. I meant "for all types a in Bla: Test a" this would be (Bla a) => Test a
07:08:44 <Philonous> Kanisterschleife:  Just "Test a"
07:08:54 <ksion> Don't include the => clause at all.
07:09:19 <Philonous> Kanisterschleife:  Or more explicitly: "forall a. Test a".
07:09:54 <Kanisterschleife> Philonous: But ":type (Test a)" gives an error, namely "Not in scope: type variable 'a'"
07:10:46 <Kanisterschleife> this is somehow confusing, because if I have data Test a = C and x = C, then :type x indeed gives "Test a", but :kind (Test a) gives an error.
07:11:28 <ksion> "Test a" is itself a type, not type constructor.
07:11:41 <Philonous> @kind forall a. Maybe a
07:11:42 <lambdabot> *
07:12:11 <byorgey> Kanisterschleife: what error does :kind (Test a) give?
07:12:15 <Kanisterschleife> ksion: Yes, that's clear.
07:12:25 <Philonous> @kind Maybe a
07:12:26 <lambdabot> Not in scope: type variable `a'
07:12:30 <byorgey> perhaps it complains about 'a' not being in scope?
07:12:31 <byorgey> yeah
07:12:37 <Kanisterschleife> byorgey: yes.
07:12:42 <Philonous> I guess you have to bind the type variable explicitly when asking about its kind
07:12:48 <byorgey> Kanisterschleife: the type 'Test a' implicitly means 'forall a. Test a'
07:13:21 <byorgey> Kanisterschleife: apparently you have to ask for the kind of 'forall a. Test a' rather than just 'Test a'
07:13:24 <Kanisterschleife> But ":kind (forall a. Test a)" still fails
07:13:25 <byorgey> Kanisterschleife: although I agree this is silly.
07:13:42 <Kanisterschleife> byorgey: yes, it's silly, I just want to understand, not to use this somewhere
07:14:02 <byorgey> hmm, well you have to turn on an extension to allow the explicit 'forall a.' syntax
07:14:32 <Kanisterschleife> byorgey: it confuses me that I use a new syntax for the "typeclass of all types", and not the familiar one (class a) => ...
07:14:45 <byorgey> Kanisterschleife: does it work after you enter  :set -XRankNTypes  at the ghci prompt?
07:14:51 <Philonous> {-# LANGUAGE ExplicitForall #-}
07:14:52 <byorgey> Kanisterschleife: there is no "typeclass of all types".
07:15:20 <byorgey> Kanisterschleife: it is not a new syntax. it is the same syntax, without the optional  (class a) =>  ...  part.
07:15:30 <byorgey> Kanisterschleife: oh, you're referring to the 'forall a.' bit?
07:15:45 <byorgey> Kanisterschleife: (class a) => T   is also shorthand for  forall a. (class a) => T
07:16:18 <Kanisterschleife> byorgey: ah, great! this would resolve all confusion.
07:16:26 <byorgey> Philonous: ah, that's the one I was trying to remember.
07:17:13 <Kanisterschleife> byorgey: I didn't know that (class a) => itself is a shortcut, and wondered why I should use a special syntax when I wanted to address all types
07:17:26 <Kanisterschleife> with the :set -XRankNTypes everythings fine
07:17:41 <Kanisterschleife> thank you :-)
07:17:44 <byorgey> Kanisterschleife: sure
07:18:03 <Philonous> byorgey:  Uh *cough*, btw. do you happen to know whether there are solutions to the exercises in "software foundations"?
07:18:10 <byorgey> Kanisterschleife: also, as Philonious pointed out,  ExplicitForall is a better extensions to use than RankNTypes if you just want to write the 'forall a.' syntax
07:18:19 <byorgey> Kanisterschleife: RankNTypes turns on additional stuff
07:18:28 <byorgey> Philonous: there are.
07:18:34 <Kanisterschleife> byorgey: what do I have to do to use ExplicitForall?
07:18:36 <Philonous> byorgey:  OTOH why would he want to without rank n types?
07:18:58 <byorgey> Philonous: the stuff we've been discussing does not require rank N types.
07:19:23 <Philonous> Kanisterschleife:  Add {-# LANGUAGE ExplicitForall #-} to the top of you haskell file or write ":set -XExplicitForall" at the ghci prompt
07:19:31 <byorgey> Kanisterschleife: either  :set -XExplicitForall  at the ghci prompt, or  {-# LANGUAGE ExplicitForall #-} at the top of your .hs file
07:19:39 <Kanisterschleife> Philonous, byorgey:  ok thank you! :)
07:20:08 <byorgey> Philonous: they are purposely not publicly available, but if you promise not to distribute them I could send you a copy.
07:20:37 <Kanisterschleife> I have another more theoretical question... ;) If I understand it correctly, if I have a parametrized data type like Tree, then Tree (*not* Tree a for some type a) is considered a type in Haskell. There a no values for the type Tree, are there?
07:20:57 <byorgey> Kanisterschleife: correct.
07:21:06 <Kanisterschleife> (of course Tree a is also a type for types a, but I want to consider Tree without some parameter)
07:21:11 <byorgey> Kanisterschleife: sometimes the term 'type constructor' is preferred.
07:21:31 <byorgey> when you want to distinguish between types of kind * and type constructors of other kinds
07:21:50 <Philonous> Kanisterschleife:  Whether or not a type constructor is a type is disputed. The Haskell report refers to them as types. Personally I don't think that makes a lot of sense.
07:22:00 <byorgey> it's just terminology.
07:22:06 <Kanisterschleife> byorgey: ok, fine... thought about the possibility of a vaule of type Tree, but couldn't make sense of it
07:22:26 <byorgey> Kanisterschleife: right, there are no values of any type with a kind other than * .
07:23:01 <Kanisterschleife> Philonous: I guessed that it should be considered a type because the typeclass definition accepts both "ordinary" types as well as type constructors (as in the typeclass "functor" or "monad")
07:23:35 <byorgey> if by 'type' you mean 'things that classify values' then Tree a is a type and Tree is not (it is a type constructor).
07:23:48 <byorgey> on the other hand if by 'type' you mean 'things that have a kind' then Tree a and Tree are both types.
07:24:12 <byorgey> there is not agreement in the Haskell community which way we want to use the word 'type', but I think most people probably lean towards the first.
07:24:46 <Kanisterschleife> I imagined that it would be more elegant if both ordinary types and type constructors would be considered as "types" so that there was only one definition of the "class" construction for types, not many for ordinary types and type constructors
07:24:58 <byorgey> but the second has a long history in the type theory literature.
07:25:03 <byorgey> Kanisterschleife: indeed.
07:25:51 <Kanisterschleife> byorgey: okay, great :-) glad to here that it is not only me that is puzzled by the question "what is a type" in haskell :)
07:27:30 <Philonous> Kanisterschleife:  In the end it is just labels. As long as you are clear about what you mean it doesn't really matter that much.
07:28:08 <byorgey> and as long as you are willing to ignore people sometimes shouting at you for using the terms "wrong" ;)
07:28:28 <Kanisterschleife> That's ok for me :)
07:28:33 <Philonous> That's hardly avoidable either way.
07:28:40 <byorgey> true.
07:29:41 <Kanisterschleife> Maybe one last question: I saw the definition g :: Integer -> Integer, g 0 = 0, g(x+1) = blabla in some Haskell book... this is not valid, is it? Or how should Haskell be able to recognize that +1 is injective so that defining g for the image of some value under +1 in terms of its preimage is indeed well-defined?
07:30:12 <Kanisterschleife> or are there situations where haskell can indeed understand such definitions?
07:30:19 <Philonous> Kanisterschleife:  That's called an n+k pattern and is treated "magicly" by the compiler.
07:30:41 <Kanisterschleife> Philonous: ah, ok...
07:30:50 <Kanisterschleife> Philonous: clever compiler :)
07:31:15 <Philonous> I think it's ugly and an unnecessary special case
07:31:28 <Philonous> Btw. It only works with (+)
07:32:00 <Kanisterschleife> it's maybe a bit unelegant, because it need separate treatment
07:32:46 <Kanisterschleife> Ok, anyway, thank you very much for your help!
07:32:48 <chemistree> is "a b c" syntactic sugar for 'a':' ':'b':' ':'c'
07:33:00 <chemistree> : []
07:33:01 <Jeanne-Kamikaze> : []
07:33:04 <Jeanne-Kamikaze> yes
07:33:05 <Philonous> Yes
07:33:06 <zmv> yes
07:33:16 <chemistree> triple yes, nice
07:34:02 <byorgey> @quote stereo
07:34:03 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
07:34:09 <byorgey> wat
07:34:53 <zmv> hahaha
07:35:40 <Philonous> byorgey:  And yes, I do promise not to distribute the solutions and would appreciate a copy. There are a few exercises that I did solve, but I think I am missing something.
07:39:07 <byorgey> Philonous: ok. pm me with the email address I should send them to.
07:40:15 <renze> Is there another class like Enum which starts at the minbound if the maxbound is exceeded?
07:40:56 <renze> f.e.: toEnum ((fromEnum Friday) + 3) == Monday
07:41:24 <byorgey> renze: no, you'll have to make your own 'succ'-like function which wraps around
07:41:57 <renze> byorgey: Thanks, already thaught I should
07:42:00 <renze> thought*
07:43:39 <chemistree> (+1) 2
07:43:46 * hackagebot incremental-parser 0.2 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2 (MarioBlazevic)
07:44:45 <monochrom> the haskell reports have "the IO type" and "the Maybe type"
07:46:17 <monochrom> the haskell reports surprise most of the haskell community in many aspects, not just this, and not just syntax
07:51:09 <renze> Is an Enum always Bounded, the other way around or neither?
07:51:48 <monochrom> neither
07:51:57 <sipa> the type classes enfore neither
08:04:29 <Fuco> any idea why cabal return error cabal: c2hs version >=0.15 is required but it could not be found. but when I do cabal install c2hs it works? Seems like dependency resolution is broken or something
08:05:47 <kosmikus> Fuco: is the c2hs binary in your path?
08:06:01 <Fuco> well now it is after I've installed it
08:06:13 <Fuco> doesn't cabal do recursive dependency downloads, sort of?
08:06:44 <Fuco> or do I have to use some switch for it to discover and download all the stuff?
08:07:04 <Fuco> I guess I should RTFM ;D
08:07:06 <irene-knapp> it does that, yes, with "cabal install foo"
08:07:18 <irene-knapp> but it doesn't do that for executables
08:07:20 <irene-knapp> only for libraries
08:07:32 <Fuco> I see
08:13:36 <byorgey> Fuco: the problem is that currently packages only specify "I require an executable named XYZ", and there is no information to tell cabal whether some package provides executable XYZ
08:13:55 <Fuco> yea that makes sense
08:14:05 <Fuco> I had to do the same thing with happy
08:14:10 <byorgey> yep
08:14:15 <Fuco> strangely enough it wasn't installed with haskell platform
08:14:49 <byorgey> hmm, it should
08:15:09 <Fuco> maybe my paths were broken, dunno
08:15:20 <Fuco> it's a school lab server, so god knows who installed it and how
08:15:36 <Fuco> so I put it in my ~ and it works ;D
08:16:17 <byorgey> hehe
08:16:52 <etpace> Does anyone know how haskell (or more general, how to) compiles recursive let statements? something like: compile (Let x e body) = do e' <- compile e; withMapping (x,e') (compile body); but what to do if x occurs in e?
08:21:40 <chemistree> "Exercise!  Try to get the 'a' value from this value using pattern matching:  (10,"abc")  "
08:21:48 <chemistree>  I did...
08:22:12 <chemistree> > let (10, a:_) = (10, "abc") in a
08:22:13 <lambdabot>   'a'
08:22:34 <renze> you can also write (_, a:_)
08:22:36 <chemistree> it works, but why is this not right?
08:22:57 <renze> It doesn't compile?
08:22:57 <chemistree> (I am doing the "tryhaskell" tutorial, step 22
08:23:04 <chemistree> It does compile,
08:23:15 <chemistree> only it doesnt proceed me to the next step,
08:23:28 <chemistree> therefore I did it a way the tutorial was not intending
08:23:50 <renze> Ah, let me try it
08:23:57 <byorgey> chemistree: perhaps it wants you to ignore the 10 using _  ?
08:24:16 <renze> I thinks so, yes
08:24:18 <renze> -s
08:24:32 <chemistree> hmm
08:25:03 <byorgey> chemistree: well, your solution is correct anyway.  Isn't there a command you can type to force it to go to the next step?
08:25:08 <chemistree> that makes sense, I guess 10 isn't really doing any thing in : "let (10, a:_)  ..."
08:25:15 <chemistree> yeah
08:25:22 <chemistree> I can force next page
08:25:45 <byorgey> chemistree: the difference is whether you require a value of 10 or not
08:25:53 <byorgey> > let (_, a:_) = (5, "abc") in a
08:25:54 <lambdabot>   'a'
08:25:59 <byorgey> > let (10, a:_) = (5, "abc") in a
08:26:00 <lambdabot>   *Exception: <interactive>:3:4-25: Irrefutable pattern failed for pattern (1...
08:26:29 <chemistree> Its just I put a fair amount of energy into it and was hoping for the tutorial to praise me. :)
08:26:35 <byorgey> hahaha
08:27:07 <byorgey> fantastic work chemistree!
08:27:11 <byorgey> you are the coolest!
08:27:17 <byorgey> you may now proceed to the next step!
08:27:27 <chemistree> HAHA
08:27:39 <chemistree> well your suggestion still didnt satisfy the tutorial
08:27:44 <byorgey> oh =(
08:27:52 <chemistree> (let me know if you need praise too)
08:29:13 <byorgey> chemistree: it seems it only works if you DON'T put a space in the middle of (10,"abc")
08:29:27 <byorgey> I know, lame
08:29:59 <byorgey> you also can't put a space in the pattern
08:30:05 <chemistree> yeah I see now
08:30:08 <byorgey> lame, lame, lame!
08:30:08 <chemistree> lame
08:30:24 <humasect> !logs
08:30:38 <chemistree> thanks byorgey
08:31:13 <chemistree> by the way, are you notified when I type byorgey in the middle of my comment?
08:31:22 <byorgey> yes
08:31:35 <byorgey> @where logs
08:31:35 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
08:31:38 <byorgey> humasect: ^^^
08:31:50 <humasect> ah thank you!
08:33:48 * hackagebot aeson-pretty 0.5.0 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.5.0 (FalkoPeters)
08:34:41 <monochrom> the topic line also has the log url and many other urls
08:48:47 <teneen> Why does the strictness analyser not detect this case, f x = f $ x+1 ?
08:48:53 <teneen> when compiling with -O2
08:48:57 <teneen> the memory blows up
08:49:08 <teneen> but when it is f x = f $! x+1
08:49:20 <teneen> the memory performance is good
08:49:44 <teneen> it's such a simple case, it should be detected by the strictness analyser
08:50:25 <monochrom> $! is explicit strictness, no analysis necessary
08:50:44 <shachaf> teneen: Is the function polymorphic?
08:51:12 <monochrom> I don't know the power of the strictness analyser
08:51:16 <teneen> shachaf: even if the type declaration is Int
08:51:22 <teneen> shachaf: same problem
08:51:56 <jmcarthur> maybe the strictness analyzer gets confused by the nontermination
08:52:12 <jmcarthur> don't know how it works
08:52:45 <shachaf> Oh, I read that as "g $ x+1".
08:52:50 <jmcarthur> in fact, the argument is never forced
08:52:56 <jmcarthur> so i think this is not unreasonable behavior
08:53:03 <shachaf> That's a pretty weird function.
08:53:25 <jmcarthur> if there was some base case where the argument is actually used then it might work
08:53:33 <teneen> jmcarthur: But when I specify explicit strictness it runs well
08:53:36 <jmcarthur> right
08:53:39 <jmcarthur> because you're forcing it
08:54:16 <teneen> jmcarthur: I don't think this explains the behaviour of the strictness analyser
08:54:18 <jmcarthur> but it's not really clear whether your function is strict or non-strict otherwise
08:54:41 <jmcarthur> what clue is it supposed to use to know that you want it to be strict?
08:54:45 <teneen> jmacarthur: what makes a function "clear" to the analyser?
08:54:52 <monochrom> with 99% probability, the strictness analyser honours your $! hint
08:54:58 <jmcarthur> it's not even clear to *me*, let alone the strictness analyzer
08:55:19 <teneen> jmcarthur: this is an infinite loop
08:55:34 <jmcarthur> right
08:55:34 <teneen> jmcarthur: Why would anyone want an infinite loop to blow up memory?
08:55:42 <jmcarthur> why would anyone want an infinite loop at all?
08:55:50 <shachaf> Of course this function is strict, because it returns _|_. :-)
08:56:24 <monochrom> the compiler is free to implement an infinite loop by whatever other infinite loop it sees fit
08:56:25 <teneen> jmcarthur: nice question
08:56:57 <teneen> jmcarthur: But what's the difference between the previous function and this  f x = f x ?!
08:57:20 <jmcarthur> teneen: the difference is that you aren't allocating any memory in that one
08:57:30 <monochrom> there is much internal contradiction between "the optimizer should be clever" and "the code generator should do exactly what I say"
08:57:37 <rwbarton> Informally, I'd say that the strictness analyser is in the business of figuring out whether your function uses its argument.  Figuring out whether it enters a loop for all possible input is not among its goals.
08:57:51 <jmcarthur> rwbarton: well said
08:58:17 <monochrom> the strictness analyser is not the only player
08:59:00 <rwbarton> given that the strictness analyser does nothing here, are you still asking about the difference between f x = f $ x+1 and f x = f $! x+1 ?
08:59:06 <monochrom> actually even within the strictness analyser algorithm there may be a part that accidentally discovers some infinite loops
09:00:11 <shachaf> teneen: What program are you actually using to get this behaviour?
09:00:21 <teneen> GHC 7.2.1
09:00:37 <monochrom> and shachaf hits the nail
09:00:56 <monochrom> "context analysis for strictness analysis" pun!
09:01:26 <teneen> rwbarton: no, I was thinking this might be a problem with the strictness analyser
09:18:18 <nh2> does http://www.haskell.org/haskellwiki really transfer passwords unencrypted??
09:18:41 <monochrom> I think so
09:19:29 <nh2> oh man, how are we presenting ourselves to the world ...
09:19:36 <nh2> can somebody fix it? I want to register :P
09:20:19 <nh2> do we have an SSL certificate at all?
09:20:27 <monochrom> no
09:21:19 <nh2> can I donate one?
09:22:33 <irene-knapp> my understanding is that receiving donations is legally problematic at the moment but that we are working on fixing that
09:22:45 <irene-knapp> anyway you would want to talk to dons about it, I think?
09:24:02 <nh2> irene-knapp: how is haskell.org organised in general? Who runs the services? Do we have an organisation?
09:24:11 <irene-knapp> we do have a committee, yes
09:24:15 <irene-knapp> of volunteers
09:24:20 <irene-knapp> there was some traffic on the mailing list recently
09:24:32 <vhd> How do you prove that your program is correct? I am looking at "Countdown problem" paper by Graham Hutton, but all I see is he uses one program to say the second matches and hence is true. Does that not just mean you have to prove the first one too?
09:24:41 <irene-knapp> apparently there is an organization that handles the tax implications of receiving donations on behalf of open-source communities
09:24:42 <vhd> http://www.cs.nott.ac.uk/~gmh/countdown.pdf
09:24:45 <irene-knapp> and we were thinking of joining them
09:24:47 <vhd> ^ paper
09:24:55 <irene-knapp> or have decided to join them, in fact
09:25:00 <irene-knapp> this was on haskell-cafe
09:25:31 <irene-knapp> note that some of the people ostensibly in charge are AWOL :( I wanted my wiki account renamed and found that nobody who had been heard from in years was able to do that :(
09:25:48 <irene-knapp> but by and large things get done
09:26:36 <monochrom> how to prove a program correct: first define "correct". it comes down to receiving a given specification, after which you can relate the program with the specification, then "correct" means a good relation between them.
09:27:17 <vhd> when you say specification is this another program or something else?
09:27:20 <monochrom> the specification is sometimes written in the same programming language, sometimes written in a different language.
09:27:23 <nh2> irene-knapp: if receiving donations is currently problematic, could I create the certificate and directly give it to the committee or the person(s) administering the servers?
09:27:41 <snappy> having flashbacks to EWD's anal retentiveness over correctness
09:27:54 <snappy> at least in his memos
09:27:55 <monochrom> eh? EWD is my hero
09:28:07 <Omer_> In Haskell, is it required to put a function's type signature before defining it?
09:28:24 <geekosaur> sometimes
09:28:26 <aninhumer> Omer_: No, but it's advised generally speaking
09:28:43 <Omer_> In what cases should I?
09:29:05 <saati> Omer_: when you run into an ambiguity the compiler can't resolve
09:29:07 <geekosaur> often it can be inferred, if no higher order types are involved; but putting it (a) helps detect type errors (b) oftem helps the programmer verify what they're doing
09:29:12 <irene-knapp> nh2: probably yes?  I believe you want dons, as I say
09:29:20 <irene-knapp> since it's not a monetary thing, I think that's okay
09:29:22 <Omer_> Okay, thank you
09:29:24 <irene-knapp> but I don't really know
09:29:53 <irene-knapp> I'm not myself in charge of anything, I just read the mailing lists and therefore know slightly more than you :)
09:29:57 <nh2> Omer_: or in all cases you're not to lazy to do it. Generally, if you want somebody else to use the function, it's good to put it
09:30:41 <Omer_> Thank you all, goodbye now
09:30:54 <monochrom> the moral and techniques I learned from EWD is that I don't have to be very creative or clever
09:31:32 <nh2> irene-knapp: exactly :) Is dons around here at times or shall I write a mail?
09:31:39 <irene-knapp> @seen dons
09:31:39 <lambdabot> Unknown command, try @list
09:31:44 <irene-knapp> preflex: seen dons
09:31:44 <preflex>  dons was last seen on #xmonad 7 days, 1 hour and 12 minutes ago, saying: aavogt has owner perms as well
09:31:55 <irene-knapp> he's sometimes here, I guess, but a mail would be better
09:36:25 <irene-knapp> :t unfoldr
09:36:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:38:48 * hackagebot imapget 0.0.1 - Downloads email from imap SSL servers.  http://hackage.haskell.org/package/imapget-0.0.1 (FacundoDominguez)
09:43:48 * hackagebot imapget 0.0.2 - Downloads email from imap SSL servers.  http://hackage.haskell.org/package/imapget-0.0.2 (FacundoDominguez)
09:56:55 <john_r_watson> Does anyone know if there's an HTML parser in Haskell w/ a querySelector(All) implementation?
10:02:14 <HugoDaniel> john_r_watson: i dont think there is
10:03:02 <Fuco> I assume that by the type of bracket it only works for IO, is there something similar for any Monad?
10:04:02 <nh2> I'm playing with hinotify and wonder what IO () to put into main to just let the program idle until Strg-C. hinotify's examples use getLine, but that's too much
10:05:08 <rwbarton> forever $ threadDelay 1000000
10:06:20 <renze> It is slow if I compile something on my 32-bit and use it on my 64-bit? I assume compiling is different for every machine?
10:08:46 <drull95> wow, how often do timeouts like this happen?
10:09:14 <cmccann> drull95, it's new to me
10:09:23 <drull95> whee
10:10:08 <tech2> seen a fair few of them in the last few days
10:13:40 <monochrom> oh, there has not been a Haskell Weekly News
10:13:53 <nh2> rwbarton: hmm, ok, though a bound for something unbounded has this slightly strange taste
10:15:29 <nh2> renze: usually not, except the code uses things 64-bit machines are especially good at, e.g. specialised instructions or numbers with more than 32 bit precision
10:15:59 <renze> nh2: thanks, I don't use those
10:18:37 <nh2> irene-knapp: what is dons email address? I tried one with @galois.com but I got an "Undelivered Mail Returned to Sender" and his website http://www.cse.unsw.edu.au/~dons/ shows HTTP errors, so I'm not sure if I @cse.unsw.edu.au is a good idea
10:19:25 <irene-knapp> hmmm
10:19:33 <cmccann> nh2, could try messaging him on reddit or something
10:19:50 <irene-knapp> I don't have it, but he's on Google+ as Don Stewart?  the one with many pictures of to-me-identical Manhattan sunsets?
10:20:09 <irene-knapp> you could also use lambdabot's @tell facility I guess
10:20:12 <irene-knapp> but that's best for short messages
10:20:30 <mauke> dons00 (at) gmail.com possibly
10:20:45 <mauke> @donsbot on twitter
10:20:46 <lambdabot> Unknown command, try @list
10:21:06 <byorgey> nh2: dons now works at Standard Chartered
10:21:41 <nh2> I'll try the G+
10:22:12 <byorgey> that's the email listed on his web page
10:22:40 <byorgey> http://donsbot.wordpress.com/about/
10:23:11 <nh2> byorgey: ah, I see, I'll try that first
10:24:44 <nh2> it is interesting: one view into the "people in common" place already reveals if that Don Stewart is the one I'm looking for :D
10:25:08 * irene-knapp nods
10:28:06 <monochrom> the people you know are exactly those known by all who know all whom you know
10:28:27 <ben> Are Conduits just Enumeratees with more user-friendly/less in-jokey names?
10:28:36 <parcs`> no
10:29:03 <renze> Why is not equal to defined as /= and not !=?
10:29:22 <monochrom> because /= looks more like ≠
10:29:40 <cmccann> we should just use ≠ instead
10:30:12 <renze> yeah, but like every other language uses !=
10:30:23 <monochrom> actually, no. the right question is: why is not equal to defined as != and not /= (to be asked in ##c). answer: because /= is already taken
10:30:25 <renze> Most of the times I write != instead of /=
10:30:34 <ksion> Except Pascal that uses <>.
10:30:38 <renze> Taken?
10:30:52 <monochrom> "x/=y" means "x = x / y" remember?
10:30:54 <ben> ((≠), (=/=), (!=), ...) = ((/=), (/=), (/=), ...)
10:30:55 <cmccann> I've also seen ><
10:31:10 <renze> Ah, right.
10:31:34 <cmccann> also, != is based on using ! for not, which Haskell doesn't
10:31:39 <monochrom> anyway yeah, algol, pascal, basic, everyone used <> before c became popular. the blame is on c, not on anyone else
10:32:01 <monochrom> or at least, the question should be asked on c
10:32:10 <cmccann> internal consistency is better than partially imitating other languages
10:32:16 <rwbarton> .NE.
10:32:26 <ben> monochrom: well the real underlying question is "why are you guys breaking cognitive compatibility with C"
10:32:42 <cmccann> because C has ugly syntax
10:32:46 <ben> and then we can start arguing about what C is worth
10:33:05 <renze> cmccann: well, / is also not the Haskell character for not, so I could say the same thing for /=
10:33:05 <monochrom> c is worth a niche
10:33:51 <monochrom> when I was in school, pascal was still more popular than c
10:33:52 <cmccann> renze, no, but a line through an equal sign is the standard symbol for "not equal to", so if you'd rather use unicode then that's fine
10:33:57 <ben> I wonder whether we can up with a meaningful *= in haskell by some analogy
10:33:59 <tech2> monochrom: codger :)
10:34:21 <monochrom> and probably PL/I was more popular than pascal
10:34:22 <cmccann> monochrom, when I was in school pascal was more popular than c, but everyone just wrote their pascal in C++
10:34:24 <tech2> erk
10:34:36 <tech2> monochrom: PL/I scares me.
10:34:36 <renze> monochrom: when I was in school, it was 2011 (or 2012) :)
10:35:04 <monochrom> today C++ takes the place of PL/I the way I see it. humongous industrial languages.
10:35:14 <renze> cmccann: that's true. I don't really care in which symbol I use, I just always need to rewrite my != to /= on the first day back in Haskell, that's all
10:35:51 <cmccann> I rarely find /= useful in Haskell, to be honest
10:36:00 <cmccann> compared to other languages
10:36:42 <Clint> what's the easiest way for me to split a string into space-continued "paragraphs"?
10:37:09 <ksion> ben: a *= xs = any (\x -> a == x) xs -- maybe.
10:37:43 <renze> cmccann: I sometimes use it with filter, as filter is defined in the opposite way for my needs most of the times, but apart from that: you're right
10:38:07 <monochrom> I have long developed an extra layer of abstraction in my mind for these things. think of it as device drivers. say I want to edit a file; that's a core activity independent of emacs vs vim vs vi vs nano. I load the emacs device driver if the editor happens to be emacs, etc
10:38:48 <monochrom> so similarly I load the C device driver when I'm writing C, and the device driver outputs !=. the Haskell device driver outputs /=.
10:39:09 <cmccann> renze, yeah, and even there I find I usually want a more complicated predicate than just [in]equality
10:39:10 <nh2> Clint: example?
10:39:58 <Clint> nh2: like an rfc822 header
10:40:33 <ksion> monochrom: That's a very neat metaphor; I think many polyglot programmers work this way.
10:43:14 * cmccann agrees with monochrom's metaphor
10:43:21 <cmccann> though I think it's more literally accurate in my case
10:43:35 <cmccann> because I always make mistakes when switching, which reflects the typical quality of actual device drivers
10:45:00 <nh2> Clint: hmm, not sure, do you mean "FIELD: VALUE" as "paragraph"?
10:45:44 <Clint> nh2: yeah, except it's an org-mode file, so it's not field: value
10:46:32 <Clint> and splitRegex doesn't have negative lookahead
10:46:59 <nh2> Clint: hmm, if your use case follows the rfc's grammar closely, maybe you should parse it with grammar tools (like parsec)
10:47:17 <cmccann> yeah, that sounds like a situation where a quick and dirty parsec parser might be the easiest thing
10:47:39 <Clint> hmm, seemed like overkill, but okay
10:48:17 <monochrom> parsec is seldom overkill. regex is usually overkill
10:50:40 <nitronous> what do I write if I want a function that does nothing in IO()?
10:51:06 <monochrom> return ()
10:52:16 <nitronous> thanks.
10:54:30 <nitronous> ok, to the people helping me earlier; after attempting both SVG and PS export, it turns out that using a standard PNG library, and using setPixel, works great
10:54:43 <nitronous> ie I have my list of pixels and I just go through and set the pixel to that colour in the corresponding image, it's very fast
10:54:55 <cmccann> nitronous, what're you drawing? :]
10:55:20 <nitronous> cmccann: well, I'm writing a paper about roots of polynomials and their relations to iterated function systems
10:55:32 <nitronous> cmccann: so sets of roots of polynomials and also iterated function systems
10:55:50 <cmccann> nitronous, ah, neat
10:58:30 <cmccann> nitronous, gonna explain how plots like this work? http://i.imgur.com/ppNTS.jpg
10:58:49 * hackagebot fgl-visualize 0.1 - Convert FGL graphs to dot (graphviz) files  http://hackage.haskell.org/package/fgl-visualize-0.1 (ThomasDuBuisson)
10:59:29 <nitronous> cmccann: yeah, that sort of images, except so far I'm just looking at roots of polynomials with coefficients in {-1,1} or {-1,0,1}
10:59:51 <nitronous> do you know what polynomials made that image?
11:00:25 <cmccann> don't remember what I used, sorry
11:00:51 <Guest38122> How do I export an algebraic data type in a module?
11:00:58 <cmccann> nitronous, cf. http://www.reddit.com/r/mathpics/comments/i1ri0/patterns_from_plotting_polynomial_roots_in_the/
11:01:52 <nitronous> haha yeah
11:02:05 <nitronous> I'm writing with John Baez about this stuff
11:02:05 <chemistree> (beginner?) Question: let (words "There's jam in my pants!") = (_, _, _, _, a) in a
11:02:06 <cmccann> you may find this version more interesting: http://i.imgur.com/TS0ZD.jpg
11:02:34 <cmccann> since you're looking at the IFS aspect
11:02:46 <chemistree> I am trying use "words" to split up "theres jam in my pants" into strings
11:02:49 <Guest38122> I have a type "data Plot = Plot Double", and when I load the module in ghci and use it, it says "Not in scope: data constructor `Plot'"
11:03:22 <chemistree> then pattern match it and output just "pants!"
11:03:49 * hackagebot monad-parallel 0.7.1 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.7.1 (MarioBlazevic)
11:03:51 * hackagebot monad-coroutine 0.7.1 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.7.1 (MarioBlazevic)
11:03:53 * hackagebot coroutine-enumerator 0.1.1 - Bridge between the monad-coroutine and enumerator packages.  http://hackage.haskell.org/package/coroutine-enumerator-0.1.1 (MarioBlazevic)
11:03:55 * hackagebot coroutine-iteratee 0.1.1 - Bridge between the monad-coroutine and iteratee packages.  http://hackage.haskell.org/package/coroutine-iteratee-0.1.1 (MarioBlazevic)
11:04:00 <rwbarton> chemistree: Switch the two sides of =
11:04:18 <Guest38122> chemistree: words doesn't return a tuple
11:04:21 <rwbarton> let <pattern> = <expression>
11:04:28 <rwbarton> oh yeah, that too
11:04:39 <rwbarton> You can use a list, [_, _, _, _, a]
11:05:08 <Philonous> > let [_ , _ , yum] = words "apples oranges cucumbers" in yum
11:05:09 <lambdabot>   "cucumbers"
11:05:23 <Guest38122> but to pattern-match you'd have to say (_:_:_:_:a)
11:07:20 <Philonous> > let [_, _, yum] = "apples oranges cucumbers rhubarb" in yum -- oops
11:07:21 <lambdabot>   *Exception: <interactive>:3:4-51: Irrefutable pattern failed for pattern [_...
11:08:51 <chemistree> let [_:_:_:_:e] = ["There's jam in my pants!"] in e
11:08:57 * hackagebot scc 0.7.1 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.7.1 (MarioBlazevic)
11:09:33 <chemistree> this outputs:  "e's jam in my pants!"
11:10:05 <chemistree> that is why I want to use "words" to split each string into a string
11:10:07 <Philonous> chemistree:  Jap. You are stripping away the first 4 characters of your string and return the rest
11:10:10 <Guest38122> bye
11:10:26 <Philonous> chemistree:  A String is merely a list of characters
11:13:22 <chemistree> Got it!
11:13:23 <chemistree> let (_:_:_:_:e) = words "There's jam in my pants!" in e
11:13:47 <rwbarton> You still want [_,_,_,_,e] though, unless you want e to be the list ["pants!"]
11:13:58 <chemistree> yup
11:14:09 <chemistree> I just wanted to out put the last string
11:14:18 <chemistree> ... or is that a list?
11:14:19 <Philonous> > let (_:_:_:_:e) = words "There's marmelade in my garment! And I don't like it" in e
11:14:20 <lambdabot>   ["garment!","And","I","don't","like","it"]
11:14:25 <ion> > (last . words) "foo bar baz quux"
11:14:26 <Philonous> Is that really what you wanted?
11:14:26 <lambdabot>   "quux"
11:15:42 <chemistree> yeah, I am just seeing how "words" works
11:16:34 <Philonous> > let (_:_:_:_:e:rest) = words "There's marmelade in my garment! Huzza!" in e
11:16:35 <lambdabot>   "garment!"
11:17:05 <chemistree> let (_,_,_,_,e) = words "There's jam in my pants!" in e
11:17:19 <chemistree> why doesnt lamdabot respond to me?
11:17:27 <humasect> >
11:18:42 <chemistree> > let (_:_:_:_:e) = words "huzza, jam with my marmelade..." in e
11:18:43 <lambdabot>   ["marmelade..."]
11:18:50 <chemistree> word
11:20:27 <Sgeo> > let all@(a,b,c,d,e) = words "There's jam in my pants!" in all
11:20:28 <lambdabot>   Couldn't match expected type `(t, t1, t2, t3, t4)'
11:20:28 <lambdabot>         against inferred...
11:20:36 <Sgeo> erp
11:20:45 <Sgeo> > let all@(a:b:c:d:e) = words "There's jam in my pants!" in all
11:20:46 <lambdabot>   ["There's","jam","in","my","pants!"]
11:21:09 <Sgeo> Not what I want to illustrate
11:21:18 <Sgeo> > let (a:b:c:d:e) = words "There's jam in my pants!" in (a,b,c,d,e)
11:21:19 <lambdabot>   ("There's","jam","in","my",["pants!"])
11:21:23 <hpc> Sgeo: the status of your pants, perhaps? :P
11:22:27 <renze> > let statusOfPantsOfSgeo = words "There's jam in my pants" in statusOfPantsOfSgeo
11:22:28 <lambdabot>   ["There's","jam","in","my","pants"]
11:22:31 <renze> :)
11:22:51 <Sgeo> chemistree did it first
11:22:54 * Sgeo pouts
11:23:02 * chemistree has no jam in his pants
11:23:51 <hpc> @let integerToPantsStatus = (["Vacant", "Jammed", "Fancy"] !!)
11:23:52 <lambdabot>  Defined.
11:23:53 <chemistree> besides, I dont see why "pants" was in [] for your example
11:24:11 <chemistree> nothing, that I can tell, is special about 'e'
11:24:35 <renze> It is the last part of the pattern in a list pattern matching
11:24:42 <Philonous> @type (:)
11:24:42 <lambdabot> forall a. a -> [a] -> [a]
11:24:44 <renze> that'll always return a list, instead of an item of the list
11:25:14 <chemistree> hmm
11:25:35 <Sgeo> a:b:c is really a:(b:c). : takes an item and a list
11:25:47 <Sgeo> So in a:(b:c) b:c is a list, and c is a list.
11:25:51 <Sgeo> And a is an item
11:25:57 <Sgeo> and b is an item.
11:26:00 <Philonous> chemistree:  (a : b : c) === (a : (b : c)). So your e is the only variable that occurs (on it's own) on the right side of (:), that's why it is a list rather than a string
11:26:00 <chemistree> > let (a:b:c:d:e) = words "anthing but my pants status!" in (_,_,_,_,e)
11:26:01 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
11:26:09 <trinithis> How can I operate on Word32#? I see API's for Word#, but not Word32#
11:26:28 <chemistree> > let (a:b:c:d:e) = words "anthing but my pants status!" in (_:_:_:_:e)
11:26:29 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
11:26:39 <Sgeo> chemistree, _ makes no sense there
11:26:53 <Philonous> chemistree:  That won't. ghc can throw stuff away but not make it up out of thin air
11:26:58 <Philonous> work*
11:27:18 <chemistree> > let (a:b:c:d:e) = words "anthing but my pants status!" in (_:e)
11:27:18 <lambdabot>   Pattern syntax in expression context: _
11:27:24 <chemistree> arg
11:27:46 <Sgeo> chemistree, what do you mean by the resulting value being (_:e)?
11:27:52 <Sgeo> _ is not a thing.
11:27:53 <Sgeo> > _
11:27:54 <lambdabot>   Pattern syntax in expression context: _
11:27:56 <Sgeo> ^^ nonsense
11:28:11 <Sgeo> It can be used to ignore stuff, but not as a value in itself.
11:28:33 <chemistree> I want it to ignore outputing (a..d)
11:28:44 <chemistree> just give me "status"
11:28:50 <Sgeo> Then use in e
11:29:01 <chemistree> ah
11:29:09 <chemistree> > let (a:b:c:d:e) = words "anthing but my pants status!" in e
11:29:10 <lambdabot>   ["status!"]
11:29:26 * chemistree thanks sgeo
11:29:29 <Sgeo> You're welcome
11:38:59 <Philonous> > let (a:b:c:d:e:_) = words "anthing but my pants status!" in e -- Maybe you meant that?
11:39:00 <lambdabot>   "status!"
11:41:21 <Sgeo> chemistree,
11:41:47 <Sgeo> > let (a:b:c:d:e:_) = words "anything but my pants status! Anything!" in (a,b,c,d,e)
11:41:48 <lambdabot>   ("anything","but","my","pants","status!")
11:41:58 <scooty-puff> i am trying to use hoopl to figure out when an explicit return statement needs to be inserted in a method (of an imperative language)
11:41:59 <Sgeo> > let [a,b,c,d,e] = words "anything but my pants status! Anything!" in (a,b,c,d,e)
11:42:00 <lambdabot>   ("*Exception: <interactive>:3:4-64: Irrefutable pattern failed for pattern ...
11:42:13 <chemistree>  
11:42:18 <scooty-puff> but hoopl seems to required a closed graph - i can only give a closed/<...> graph
11:42:37 <scooty-puff> but i wanted to use hoopl to do the liveness analysis for if a return statement should be inserted..
11:42:55 <scooty-puff> so i am uncertain what to do..
11:42:57 <chemistree> oh
11:43:19 <chemistree> let (_:e) = words "anthing but my pants status!" in e
11:43:24 <chemistree> > let (_:e) = words "anthing but my pants status!" in e
11:43:25 <lambdabot>   ["but","my","pants","status!"]
11:43:58 <chemistree> > let (_:_:_:_:e) = words "anthing but my pants status!" in e
11:43:59 <lambdabot>   ["status!"]
11:44:17 <chemistree> ^^^
11:44:40 <chemistree> this is along the lines I was thinking with the whole "(_:e)" idea
11:44:58 <chemistree> ^^^ "in (_:e)"
11:45:39 <chemistree> but my logic was all mixed up... more so my understanding of Haskells understanding...
11:46:47 <Fuco> so I wrote a little module and when I try to import it ghci complains it can't find it. It's in the same directory as the file that imports it
11:46:51 <Fuco> what gives:O
11:47:08 <Fuco> when I run ghc --make on the main module it links just fine
11:47:21 <chemistree> is it .hs
11:47:25 <Fuco> yes
11:47:28 <monochrom> depends on the exact command you gave
11:47:47 <Fuco> well I have a file Main.hs and in it is "module Main where (newline) import Utils ..."
11:47:48 <monochrom> exact verbatim
11:47:56 <Fuco> the other file is called Utils.hs
11:48:07 <Fuco> when I do :load .../Main.hs in ghci
11:48:12 <Fuco> it complais about Utils
11:48:28 <Fuco> Could not find module `Utils':
11:48:36 <Fuco> is the error verbatim
11:48:50 <monochrom> why "../"? do everything in the directory that contains Main.hs and Util.hs
11:49:07 <Fuco> oh sorry that's just a shorthand, I used full path there
11:49:22 <Fuco> /home/blabla/.../Main.hs
11:49:29 <dmwit> It will look in pwd for Utils.hs, not in the same directory as Main.hs
11:49:37 <monochrom> full path is same difference. makes everything too complicated. cd to the directory.
11:49:42 <dmwit> You may change this behavior by adding directories to the search path.
11:49:51 <Fuco> dmwit: oh I see
11:50:09 <Fuco> I run emacs from different directory, so that's probably where it starts ghci as well
11:50:12 <Fuco> cheers ;P
11:50:46 <monochrom> use :cd
11:50:53 <Fuco> yep, works fine, thanks
11:51:54 <monochrom> under suitable circumstances, the emacs haskell mode runs ghci in the correct directory. e.g., when the active buffer is Main.hs, start ghci
12:03:08 <scooty-puff> ok, so i may have a solution to the problem i mentioned earlier - basically, i want this: if { ... return true; ... } else { ... } have a return void; added (because else does not return), and result in a type error during inference, but it looks i can just add (blindly) a return void; to the end of all methods, and if it turns out to be dead, remove it, otherwise, leave it, and everything works out
12:04:58 <scooty-puff> though this may be a bad practice - type inference may fail if liveness analysis and dead code elimination does not run..
12:08:55 <chemistree> > so if something is in brackets, it is a list? such as []
12:08:56 <lambdabot>   <no location info>: parse error on input `if'
12:09:07 <chemistree> ^^ empty list
12:09:19 <monochrom> [] is an empty list.
12:09:29 <byorgey> chemistree: if an expression is in brackets, it is a list.
12:09:31 <chemistree> but if it is in parenthases, it is a tuple?
12:09:33 <monochrom> I wouldn't generalize to all brackets
12:09:40 <hpc> or all parens
12:09:45 <monochrom> I wouldn't generalize.
12:09:55 <ion> :-D
12:10:31 <byorgey> chemistree: not necessarily.
12:10:43 <monochrom> with extensions, there is [d| blahblah|] not a list.
12:10:44 <chemistree> I am still thinking about the "pants!" example
12:10:44 <byorgey> (3 + 4) is not a tuple.  the parens are just used for grouping.
12:10:53 <chemistree> > let (_:_:_:_:e) = words "anthing but my pants status!" in e
12:10:54 <lambdabot>   ["status!"]
12:10:59 <chemistree> ^^
12:11:04 <byorgey> true, and there is also [:  ... :]
12:11:11 <chemistree> turns a tuple into a list. right?
12:11:30 <monochrom> there is no tuple in that expression
12:11:37 <__bitbucket> No, that's not a tuple, the parens in your example are for grouping the pattern together
12:11:43 <chemistree> > [: ... :]
12:11:44 <lambdabot>   <no location info>: parse error on input `...'
12:12:00 <byorgey> [: ... :] is for data-parallel arrays
12:12:17 <byorgey> it also requires an extension
12:12:24 <monochrom> if you feel like overgeneralizing everything, just remember that every plain text file is potential Haskell code
12:12:47 <__bitbucket> (,) is the tuple operator, so (foo, bar) is a tuple of foo and bar, but (foo) is just foo in parentheses
12:13:23 <ion> [ … | … ] may be a monad comprehension with the appropriate extension.
12:13:28 <monochrom> and f(a+b) = f a + f b
12:15:12 <chemistree> monocrhom: thats why I use notepad
12:15:15 <chemistree> :P
12:15:27 <chemistree> i like to generalize
12:15:33 <monochrom> I use notepad++ when in windows
12:15:44 * chemistree is in windows
12:16:35 * chemistree did system restore. now uses "tryhaskell.org" to compile code....
12:16:58 <mietek> Is there a paper on type families?
12:17:13 <c_wraith> mietek: yes.  fun with type functions, or the like
12:17:26 <mietek> Maybe, implementing type inference in the presence of the abovementioned?
12:17:44 <c_wraith> Oh.  In that case, maybe look at SPJ's papers on outside-in?
12:17:52 <mietek> c_wraith: thanks
12:17:54 <Fuco> I have a State monad with a record that has row :: Int in it. I use: get >>= (\x -> put x { row = (row x) - 1 }) to update its value, I wonder if there's some nicer way to do it. The get, lambda, put etc seems like a lot of boilerplate
12:18:17 <hpc> Fuco: lenses might be what you want
12:18:23 <mietek> c_wraith: sorry, what's outside-in?
12:18:46 <c_wraith> mietek: it's the name of the type inference algorithm ghc has used since version 7
12:18:47 <renze> I compiled some modules with ghc -O2 --make main, but apparently I can't press Main.exe without having the .hs files in the same folder, how can I do that?
12:18:47 <Fuco> I'll check it out, thanks
12:18:49 <mietek> Aha!
12:19:12 <mietek> c_wraith: that's brilliant; thanks!
12:19:40 <monochrom> "modify (\x -> put x { row = (row x) - 1 })". lens will improve the rest
12:20:23 <solrize> @pl (\p f -> (\a b -> p (f a) (f b)))
12:20:23 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:20:28 <monochrom> "press" Main.exe? but anyway Main.exe works independently. works here.
12:20:50 <monochrom> or it's called "main.exe"
12:21:04 <renze> never mind.
12:21:12 <renze> Need to copy the input files as well. duh
12:21:26 <funktronic> anyone know of a mirror for haskell platform? the main site ds way too slow
12:22:03 <monochrom> maybe http://hackage.haskell.org.nyud.net/platform/ works for you
12:22:42 <funktronic> monochrom: still downloads at like 5 kb/s
12:25:03 <funktronic> meh i could just leave it downloading and have myself a nice new year's present when i come back
12:26:04 <rwbarton> downloaded in a few seconds for me (1MB/s)
12:26:47 <funktronic> hm.. not my connection. just ran a speed test and getting the advertised ~20 mbit/s
12:28:41 <hpc> it would be nice to have some syntactic sugar
12:29:00 <hpc> {foo = ...} <=> \x -> x {foo = ...}
12:29:50 <ion> I’d rather have built-in lenses.
12:30:36 <Fuco> Is that derived from "lens" as in the thing in telescopes and stuff? Kind of weird name for a library, or am I missing something? :P
12:31:54 <c_wraith> Fuco: it helps you focus on one small part of a data structur
12:31:55 <c_wraith> e
12:32:10 <Fuco> heh, clever
12:33:50 * hackagebot textPlot 0.1 - Graphs functions as lines of text  http://hackage.haskell.org/package/textPlot-0.1 (WilliamMurphy)
12:36:35 <drull95> proposed: putStrLn :: LiftIO m => m String -> IO ()
12:37:01 <drull95> general idea being reduce use of binding by making all monadic actions take monadic args
12:37:09 <ion> Why?
12:37:51 <drull95> so i can write putStrLn prev5Lines instead of do ls <- prev5Lines; putStrLn ls
12:38:08 <ion> putStrLn =<< prev5Lines
12:38:16 <hpc> drull95: and would it execute prev5Lines twice?
12:38:18 <hpc> drull95: or once?
12:38:26 <drull95> ion, oh
12:38:28 <hpc> remember, prev5Lines is an IO action, NOT a string
12:38:34 <hpc> also what ion said
12:38:43 <drull95> hpc, intended to just be once
12:39:05 <drull95> heh heh, always learning
12:39:26 <ion> @undo do ls <- prev5Lines; putStrLn ls
12:39:26 <lambdabot> prev5Lines >>= \ ls -> putStrLn ls
12:39:31 <ion> @@ @pl @undo do ls <- prev5Lines; putStrLn ls
12:39:31 <lambdabot>  putStrLn =<< prev5Lines
12:39:54 <hpc> there's also liftM2/liftA2
12:40:02 <hpc> and (<$>)/(<*>)
12:40:25 <hpc> plenty of functions to write pointless code with :P
12:40:40 <Sgeo> join $ putStrLn <$> prev5Lines comes to my mind quicker than bind :/
12:41:19 <hpc> it's unfortunate that Monad can't be defined in terms of join
12:41:57 <ion> Indeed. But as a workaround, m >>= f = join' (fmap f m) where { join' = … } isn’t *too* bad.
12:42:29 <iorivur> Is there any method to remove a package which was installed by cabal
12:42:48 <drull95> i'm generally irritated when i have to name something for no reason, so it's good there's ways to not have to bind things
12:42:50 <ion> ghc-pkg unregister blah IIRC.
12:42:55 <irene-knapp> @tell cmccann I gave that thing a try, but I'm probably not going to work on it any further, since I got frustrated at the incomplete specification of the algorithms.
12:42:55 <lambdabot> Consider it noted.
12:43:05 <renze> is appendFile slow for large files? Files like ~10-50mb
12:43:15 <renze> I only write one string at a time
12:43:21 <cmccann> irene-knapp, aw
12:43:21 <lambdabot> cmccann: You have 1 new message. '/msg lambdabot @messages' to read it.
12:43:22 <renze> Uhm, one line.
12:43:25 <irene-knapp> oh hi :)
12:43:27 <irene-knapp> yeah, I know
12:43:35 <cmccann> yeah, semi-idling and need to run AFK in a moment
12:43:39 <irene-knapp> it's a really neat concept and I hope I'll have time for it at some point though!
12:43:44 <iorivur> ghc-pkg unregister ? I'll try
12:44:07 <ion> renze: Profile your code and find out.
12:44:36 <renze> While, I don't want to. I use it for outputting some meta information to check tomorrow, so I can run the program now and lose it out of sight.
12:44:38 <ion> The bottleneck in your program *probably* won’t be appendFile.
12:45:07 <renze> But I don't want it to last too long, because tomorrow morning is working time again (and not tomorrow around bedtime when the programs are ready)
12:45:09 <hpc> it has to open and seek for every line
12:45:32 <hpc> over lots of individual writes, it could add up to a lot of time
12:46:43 <renze> Thanks, I'll lower my parameters just to be sure
12:47:03 <hpc> it shouldn't be too hard to carry around a handle for the file
12:47:05 <renze> Happy new year all, for who it isn't already 2012 (at least here it isn't)
12:47:06 <ion> Again, better to profile the code and get actual numbers.
12:47:11 <hpc> @hoogle hOpen
12:47:11 <lambdabot> package HOpenCV
12:47:12 <lambdabot> package hopenssl
12:47:24 <hpc> pah
12:49:24 <iorivur> Thanks it work
12:58:09 <dolio> Are all monads functions if I reinterpret every type to be functions?
12:58:55 <cmccann> dolio, just interpret everything as functions and be done with it
12:58:56 <c_wraith> what is "a monad" in that question?  The data type?  In that case yes, trivially
12:59:09 <cmccann> type synonym declarations? functions. compiler pragmas? functions.
12:59:35 <cmccann> see how much simpler that makes everything?
12:59:40 <dolio> Totally.
13:00:32 <cmccann> now you just have to distinguish between different sorts of functions that aren't related in any way, instead of dealing with different things in general that are unrelated
13:01:41 <iorivur> Is the server of haskell project is down now?
13:02:38 <iorivur> I'm downloading a ghc tar ball and the speed is only 13kB/s
13:05:55 <iorivur> Is there any mirror ?
13:06:08 <iorivur> Or should I have to wait?
13:07:27 <kosmikus> iorivur: download speed looks ok to me
13:08:16 <iorivur> I tried curl and browser - firefox downloader,,, and same..
13:09:13 <iorivur> Sorry, it works, short down of my side or so, probably....
13:20:59 <tehgeekmeister> do things with lower or higher fixity bind tighter?
13:22:10 <dolio> Higher.
13:22:31 <hpc> fixity (*) > fixity (+) -- how i remember it
13:44:15 <iorivur> I'm compiling cabal, and I got this error. do you know something about this?
13:44:19 <iorivur> Setup: At least the following dependencies are missing:
13:44:19 <iorivur> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
13:45:43 <c_wraith> iorivur: usually that means you have mixed global and local package installs
13:46:11 <iorivur> http://pastebin.com/vaqzpetz
13:46:15 <mauke> The paste vaqzpetz has been copied to http://hpaste.org/55930
13:46:29 <iorivur> Well, I changed --user for global
13:47:01 <c_wraith> iorivur: in particular, it means you have different versions of the same package installed globally and locally
13:47:11 <c_wraith> iorivur: which basically breaks everything
13:47:57 <iorivur> Thanks. And I will use 7.0 which my distribution contain, but also I want to use 7.2
13:48:51 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml describes what kind of hilarity you get for having too many packages
13:48:58 <iorivur> c_wraith: how to install at on place?
13:49:08 <iorivur> on/one
13:49:11 <c_wraith> iorivur: look at monochrom's link.
13:49:22 <c_wraith> I was actually looking for that link, but couldn't remember the name of it.
13:49:28 <c_wraith> It explains everything pretty well
13:49:39 <iorivur> Thanks. I'll read them
13:49:44 <iorivur> m/n
13:50:15 <Saizan> it's just a free puzzles generator
13:51:46 <monochrom> haha
13:56:11 <yitz> @remember Saizan cabal - it's just a free puzzles generator
13:56:11 <lambdabot> Done.
13:59:32 <Saizan> now i feel bad for mocking cabal
13:59:44 <monochrom> @quote monochrom cabal
13:59:45 <lambdabot> monochrom says: "on the 4th day of christmas my true love sent to me, 4 cabal failures, 3 cabal failures, 2 cabal failures, and a cabal failure"
13:59:54 <monochrom> you are not the worst :)
14:01:15 <Saizan> heh
14:02:17 <hpc> on the 12th day of christmas, my true love gave to me, linux-486-12.11.10..8.7.6.5.4.3.2.1-rc1
14:02:39 <hpc> argh, the '9' key on this keyboard is worn out
14:02:43 * hpc curses at lisp
14:03:57 <irene-knapp> haha
14:04:00 <irene-knapp> poor Lisp
14:11:36 <nus> monochrom, have you poked at the modular solver?
14:12:58 <monochrom> no. what is the modular solver?
14:13:19 <nus> err, pardon, ex cabal-ms branch
14:13:32 <nus> it's merged into the head atm
14:13:36 <monochrom> I haven't poked into cabal's solver
14:14:54 <nus> looks like kosmikus has the defaults set back to plain solver 'for now'
14:25:19 <chemistree> @quote chemistree doodle
14:25:19 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
14:25:25 <chemistree> ...
14:25:36 <jsc> does anyone know of any Haskell bindings to GNU's GMP (or some other bignum library)? I'm trying to generate very large primes and the Haskell modules I've tried are too slow for my purposes. Any other ways to do it are welcome too
14:26:10 * chemistree has never called self 'Rocket Scientist'
14:26:28 <darrint> Is there a better way to express this? getLine >>= return . words
14:26:36 <jmcarthur> jsc: interestingly, ghc's built-in Integer type relies on GMP. however, it's not a fully exposed binding or anything
14:26:54 <dolio> fmap words getLine
14:27:07 <monochrom> words `fmap` getLine, words <$> getLine, words `liftM` getLine
14:27:08 <darrint> ah.
14:27:21 <chemistree> @remember - test
14:27:21 <lambdabot> Done.
14:27:41 <chemistree> @quote
14:27:41 <lambdabot> avdi says: I'm not sure if that's what I wanted, but... wow!  Maybe that's what I want now!
14:27:46 <chemistree> @quote chemistree
14:27:46 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
14:27:51 <chemistree> @quote chemistree -
14:27:51 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
14:27:53 <chemistree> @quote chemistree -test
14:27:53 <lambdabot> No quotes for this person. :(
14:27:56 <chemistree> @quote chemistree - test
14:27:56 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
14:27:56 <jmcarthur> @quote -
14:27:56 <lambdabot> - says: test
14:28:14 <jsc> jmcarthur: oh neat! Didn't know that
14:28:25 <jmcarthur> chemistree: the first argument to @remember is the person you are attributing the quote to
14:28:51 <chemistree> OOPS, I was scrolled up in the dialog and did not see I was actually posting... my bad
14:28:59 <jmcarthur> heh
14:29:18 <monochrom> please don't pollute the quote database. I'm removing this one.
14:29:22 <monochrom> @forget - test
14:29:22 <lambdabot> Done.
14:29:45 <chemistree> monochrom: please do, thanks
14:30:02 <dmwit> ?quote -
14:30:02 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
14:30:03 <dmwit> =(
14:32:46 <yitz> Saizan: it's not mocking cabal. solving dependencies really *is* a source of puzzles. hopefully, cabal will soon be better at solving them, but in the meantime, it's a great quote imho.
14:33:12 <chemistree> @quote cabal
14:33:13 <lambdabot> lispy says: my conclusion: cabal is weird.
14:33:54 <chemistree> are quote databases local to channels?
14:33:58 <hpaste> drunK pasted “Builder for applying list of arguments to a function” at http://hpaste.org/55935
14:34:07 <drunK> Regarding the paste: can this be somehow improved in terms of resolving types? Because currently it needs to know full signature of passed function and returned value (returned value is not really a hassle though, I'm concerned mostly about passed function)
14:34:25 <chemistree> are quote databases local to the channel it was created in?
14:35:07 <drunK> I mented with fundeps, but that doesn't improve it
14:35:17 <drunK> *experimented
14:37:42 <yitz> drunK: I don't think this does what you want it to. and if it does, the effect is pushing off one aspect of type checking from compile time to run time, which is the opposite of what we usually want.
14:41:23 <ski> chemistree : i suspect not
14:42:40 <drunK> yitz: the situation is like this: I'm reading rows from database that I get in form of [SqlValue]. I want to convert them to desired values and pass them one by one to a function that does something with them. there is no way to check it statically, I suppose.
14:44:30 <yitz> drunK: You can pull off the number of values you need from the list using pattern matching, then use other equations to define what happens if the pattern you really wanted didn't match.
14:45:10 <chemistree> 2012
14:45:28 <chemistree> shaBAM
14:45:45 * chemistree waves bye, for now
14:46:03 <yitz> @slap 2011
14:46:03 * lambdabot secretly deletes 2011's source code
14:46:24 <drunK> yitz: the problem is type solving, not the fact that I used really primitive error reporting. this is minimal version of what I'll actually use
14:47:36 <yitz> drunK: i don't see any obvious way that you can gain anything here by using type classes
14:48:03 <jargonjustin> Is it possible to place an existential constraint on an associated type family?
14:48:16 <yitz> drunK: the type [SqlValue] does not specify at compile time how many values it will supply. there is no way to force it to do so.
14:49:24 <jargonjustin> Something equivalent to `class A b => B a b | a -> b` but where b is defined by an associated type family instead of a multi parameter type class with functional dependencies.
14:50:41 * ski doesn't understand how this has anything to do with existentials
14:51:09 <ddarius> drunK: You can recover the type information and then work in a (more) statically typed context from that point on, but that recover could fail.
14:51:22 <jargonjustin> ski, I'm probably phrasing it incorrectly. I want to constrain instances of my type class such that the associated type family always has a particular type class defined for it
14:51:29 <drunK> yitz: it will supply as many as I'll specify in sql query. but then I might change this query and forget to change decoding function and I want to get sensible error message. and typeclass is because I'd rather have to pass a function f :: String -> Int -> Bool -> SomeObject instead of taking a list, matching it against a list that has three parameters and decoding them by hand
14:53:06 <ddarius> Unless you use TH or use some abstract type for the SQL queries, there's no way to get a compile-time check that the string you passed to the database has the number of parameters and types that you expect.
14:53:37 <ddarius> I believe HaskellDB essentially implements the latter suggestion.
14:54:26 <ski> jargonjustin : i would try `class A (B a) => B a where type B a; ...'
14:55:11 <yitz> ski: that looks very confusing
14:55:21 <ski> or i suppose `class A (F a) => B a where type F a; ...', to make it not clash
14:55:34 * yitz nods
14:56:03 <jargonjustin> ski, the latter looks like what I'm trying to do, will see if GHC accepts it
14:56:05 * ski didn't first realize the two `B's were named the same
14:58:15 <jargonjustin> ski, this works nicely, thanks!
14:58:43 <ski> yw
15:13:51 * hackagebot texmath 0.5.0.4 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.5.0.4 (JohnMacFarlane)
15:23:29 <jargonjustin> Is there a convention for use of four-number package versions with the package versioning policy?
15:30:21 <mzero> are you looking for a reference to the version policy page? or something that isn't covered there?
15:31:16 <yitz> @google haskell pvp
15:31:17 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
15:31:18 <lambdabot> Title: Package versioning policy - HaskellWiki
15:31:36 <yitz> if the former
15:33:00 <mzero> personally, I dislike it when the major version number starts somewhere north of 1000
15:34:25 <jargonjustin> Thanks yitz, my question is that the PVP talks about versions as A.B.C where A.B is the major version and C is the minor, but I frequently see packages in the form A.B.C.D. I was wondering if there was some convention for distinguishing changes to the minor version.
15:34:27 <c_wraith> do packages other than HTTP do that?
15:34:53 <c_wraith> jargonjustin: D is the patch number, mostly for bug-fixes.
15:34:56 <yitz> c_wraith: haskell platform (yitz winks at mzero)
15:35:17 <c_wraith> (or any other changes that don't change the api, but that's mostly bug-fixes)
15:35:25 <mzero> heh - well, okay - there is at least a rational for that -- but html 3000?
15:35:36 <jargonjustin> c_wraith, thanks. So API additions would bump C but implementation changes would just bump D?
15:35:42 <c_wraith> jargonjustin: yes
15:35:50 <jargonjustin> c_wraith, excellent, thanks.
15:36:50 <yitz> c_wraith: D can be for any functionality changes that don't affect the API.
15:36:53 <Silvah> If I ever gonna have a package on hackage, I'll start with version number 2^32-1.
15:37:05 <c_wraith> yitz: yes, but those are almost always bug fixes.
15:37:13 <mzero> or, bug fixes!
15:37:19 <mzero> d'oh - what he said
15:38:03 <Silvah> What type does Cabal use to store version numbers?
15:39:17 <c_wraith> I think it's a [Int]
15:40:18 <yitz> it could be (Enum a, Ord a) => [a]
15:40:28 <yitz> but probably it's what c_wraith said
15:40:58 <yitz> ah, Show and Read too, i guess
15:42:00 <yitz> we also need to constrain it to types whose Show instance never produces '.'. Hmm, this is starting to get complicated.
15:42:48 <c_wraith> also, it can't be polymorphic, because it needs to be globally comparable
15:43:01 <c_wraith> so the only real options are [String], [Int], and [Integer]
15:43:25 <c_wraith> except Strings don't collate properly
15:43:37 <c_wraith> "12" < "3"
15:44:12 <Silvah> This could be easily amended.
15:44:49 <yitz> c_wraith: [Natural] (cf. the semigroups package)
15:44:55 <jargonjustin> Silvah, http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Distribution-Version.html#t:Version
15:45:58 <c_wraith> heh.  an actual answer
15:46:11 <c_wraith> looks like it's [Int] after all
15:46:49 <yitz> c_wraith: no it's ([Int],[String])
15:47:03 <c_wraith> except the [String] isn't part of the Ord
15:47:07 <c_wraith> instance
15:47:17 <Nereid> it isn't?
15:47:25 <c_wraith> it is part of the Eq instance, order-independent
15:48:04 <c_wraith> Nereid: that's what the docs say in the discussion of the Ord instance
15:48:15 <yitz> grr Contents obscures the Source link for Version in the haddocks
15:48:29 <c_wraith> heh, so it does
15:48:30 <Nereid> aren't there instances Ord Char and Ord a => Ord [a]?
15:49:06 <c_wraith> Nereid: if it was actually (,), yes.  But it's a new data type, independent of (,)
15:49:32 <Nereid> I clearly missed some of the discussion.
15:49:37 <Nereid> I'll be quiet then.
15:51:41 <mzero> @hoogle Version
15:51:41 <lambdabot> Data.Version module Data.Version
15:51:42 <lambdabot> Data.Version Version :: [Int] -> [String] -> Version
15:51:42 <lambdabot> Data.Version data Version
15:51:53 <c_wraith> yitz: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Version.html#Version
15:51:58 <mzero> that's what Cabal uses
15:52:55 <c_wraith> interesting that its Eq and Ord instances aren't consistent.
15:53:12 <c_wraith> Ord will return EQ in some cases that (==) will return False
15:53:59 <c_wraith> I really don't think that's a good idea.  On the other hand, tags are almost never used, so it rarely causes problems.
15:54:21 <Silvah> Just wait until it does.
15:54:37 <c_wraith> I suspect Cabal never actually uses the tags.
16:18:04 <tibbe> Is there a way to get the current wall-clock time, but in a monotonically increasing fashion (e.g. skipping leap seconds)?
16:18:05 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
16:19:58 <yitz> tibbe: you mean POSIX time that is monotonically increasing?
16:20:11 <tibbe> yitz: I think that's what I mean
16:20:27 <tibbe> yitz: I want to compute time series using something close to wall clock time
16:20:43 <tibbe> but leap seconds will screw up the graphs
16:20:59 <tibbe> on the other hand perhaps that doesn't matter and wall clock time is enough
16:21:16 <tibbe> in the end I need to pass a milliseconds since epoch timestamp to javascript
16:21:37 * ski ignorantly would look to get a second count since whenever
16:22:08 <zmv> what's the freenode new-year channel?
16:22:17 <jargonjustin> tibbe: You can get an accurate time, or a monotonically increasing time, but not both
16:22:45 <yitz> tibbe: NominalDiffTime ignores leap seconds. UTCTime includes them.
16:22:57 <jargonjustin> tibbe: if you're okay with inaccuracies, get an accurate time and a monotonic time at some point t0 and then approximate it by the delta in the monotonic clock
16:23:02 <tibbe> I guess I need to decide what I want
16:24:45 <yitz> tibbe: so to do what jargonjustin says, use getCurrentTime once, then go from there with NominalDiffTime.
16:25:21 <yitz> tibbe: quoting the Data.Time docs: "If you don't care about leap seconds, use UTCTime and NominalDiffTime for your clock calculations, and you'll be fine."
16:25:44 <tibbe> so getPOSIXTime gives me a NominalDiffTime
16:25:50 <yitz> yes
16:25:54 <tibbe> how do I convert that to an Integer for sending over the network
16:26:06 <yitz> use the usual numeric conversion functions
16:27:01 <yitz> NominalDiffTime is finer grained than seconds, so you need to round it or truncate it to get an integral type
16:27:09 <jargonjustin> I don't think a NominalDiffTime is guaranteed to be monotonic…
16:27:31 <ski> zmv : #freenode-newyears
16:27:38 <jargonjustin> getPOSIXTime will certainly not be.
16:27:42 <yitz> jargonjustin: you mean that if there is a negative leap second it might go down? possibly.
16:28:15 <jargonjustin> Consider if the user changes the time while your program is running.
16:28:42 <nus> tibbe, do you control the js on the other end?
16:28:42 <jargonjustin> NTP will mostly just skew or slew the clock, but there are other ways for the clock to jump
16:28:49 <tibbe> nus: yes
16:28:56 <yitz> jargonjustin: that's rare nowadays, the system time is set by ntp or something similar
16:29:03 <zmv> ski: :D
16:29:20 <zmv> ski: also, /nick skskk :P
16:29:50 <yitz> jargonjustin: unless tibbe wants to be an ntp client, i think he's going to have to rely on the monotonicity of the system clock.
16:30:00 <tibbe> Here's the context: the keg library graphs counters, polled from a server (Haskell program), and needs to create (time, value) pairs for the graph.
16:30:08 <rwbarton> @type ap const id
16:30:09 <lambdabot> forall b. b -> b
16:30:17 <ski> zmv : nah :)
16:30:17 <tibbe> The time should be the sample time at the server. For display purposes it needs to be a wall clock time
16:30:20 <rwbarton> aha! your identity is revealed!
16:30:58 <tibbe> There's an example graph here: http://blog.johantibell.com/2011/12/remotely-monitor-any-haskell.html
16:31:33 <ski> @. pl . djinn type ap const id
16:31:34 <lambdabot> f = id
16:31:48 <mauke> :t fmap fix return
16:31:49 <lambdabot> forall a. a -> a
16:31:51 <yitz> tibbe: so why not just use getCurrentTime at the server and send that on over to the client?
16:32:46 <tibbe> yitz: That might indeed be the right solution. I'm trying to figure that out.
16:33:56 <tibbe> now I need to figure out how to get that to a NDT, relative from epoch
16:34:00 <yitz> tibbe: you write "over the last 60 sec.". so just diff the UTCTime values. it will do the right thing for leap seconds.
16:34:21 <tibbe> yitz: but I would have to store some offset as well
16:34:25 <tibbe> or what do you suggest I do
16:34:40 <tibbe> on each HTTP request for stats I receive I need to compute some current time
16:34:41 * ddarius feels that tibbe is thinking about this too much.
16:34:49 <tibbe> ddarius: perhaps :)
16:34:51 <yitz> tibbe: when the server takes a sample, it gives you a UTCTime at that moment.
16:35:05 <mzero> tibbe - why on earth are you worrying about leap seconds?
16:35:07 <tibbe> yitz: ok, how do I convert that to a relative from epoch timestamp?
16:35:17 <tibbe> mzero: I'm thinking about it, not worrying.
16:35:31 <tibbe> mzero: EKG can now graph arbitrary user counters and gauges
16:35:42 <yitz> tibbe: diff it from the epoch. hmm, you're worrying about tiny bits of overhead though. not sure about that.
16:35:42 <mzero> so I read - nice
16:35:42 <tibbe> mzero: you click on the little graph-me button in the UI
16:36:09 <tibbe> yitz: do we have a constant for epoch or should I make one?
16:36:38 <yitz> mzero: i don't think the leap seconds themselves are the issue here. the point is probably just to get time readings as close to the metal as possible to avoid introducing artifacts.
16:37:00 <yitz> tibbe: it's 0.
16:37:01 <tibbe> yitz: getPOSIXTime since to be exactly that
16:37:12 <yitz> tibbe: yes you're right
16:37:13 <mzero> well - there is a tension in the interface - it represents events in terms of "real world times" that the user can correlate to the world
16:37:26 <yitz> mzero: right
16:37:33 <mzero> but those time labels are, as we know, NOT a monotonically increasing set of labels at a constant rate
16:37:54 <tibbe> mzero: right, I want users to be able to correlate the graph to behaviors in their program, without introducing artifact in the graphs
16:37:56 <mzero> if you work in UTC, you get monotonicity, but not constant rate
16:38:29 * nus feels someone is reinventing NTP
16:38:31 <mzero> so behaviors, especially w.r.t. logs are going to be correlated with human time labels
16:38:34 <tibbe> also, in the end I need to give javascript a floating point value that represents seconds since epoch
16:38:48 <mzero> is JS's epoch fixed (I think it is)
16:39:03 <tibbe> more than anything I don't want to think about this more cause it hurts my brain :)
16:39:37 <tibbe> mzero: at least the graphing library (flot) that I use. It has a concept of graphs with times on the x-axis
16:39:45 <yitz> the instrumentation should calculate on intervals that are as nearly 60 secs. as possible without the heisenberg effect. the labels can be approximate, one sec. off should be ok
16:40:20 <tibbe> so here what I think I should do: getPOSIXTimes
16:40:25 <tibbe> send that to JS
16:40:39 <yitz> tibbe: your labels will be off by about an hour if the user is unlucky enough to take a sample within less than a minute of a seasonal clock change. that's probably also acceptable.
16:41:05 <tibbe> unless someone has a strong understanding of a better way to do things this is what I'll do
16:41:59 <mzero> so long as you are doing everything in UTC, then seasonal clock time is not an issue
16:42:07 <yitz> tibbe: sounds good to me. only thing to consider is if Data.Time is introducing calculations that affect your readings, in which case you need to go to lower level platform-specific stuff.
16:42:30 <yitz> calculations whose time to calculate affect things, i mean.
16:42:50 <tibbe> I don't think so
16:42:54 <yitz> ok then
16:43:07 * mzero goes back to reverse engineering the grammar for the POSIX shell....
16:43:52 <yitz> mzero: if you reverse engineer POSIX time zone expressions and come up with a parser for them, please let me know.
16:44:43 <mzero> I have been through the hell that is the ISO & RFC & POSIX rules for time and time zones..... once in a lifetime was enough
16:44:59 <tibbe> it calls gettimeofday
16:45:16 <mzero> what does?
16:45:20 <tibbe> mzero: what are you doing
16:45:24 <tibbe> mzero: getPOSIXTIME
16:45:52 <yitz> tibbe: yeah that's fine. i don't think any care was taken in strictifying and unpacking fields, inlining, etc.
16:46:03 <yitz> tibbe: but if you don't do this too often that's fine.
16:46:04 <mzero> oh ... a sneaky project .... it's a replacement command shell....
16:46:04 <tibbe> yitz: true
16:46:12 <tibbe> mzero: oh?
16:46:25 <tibbe> yitz: I will go through the end-to-end performance of this lib soon
16:46:42 <tibbe> yitz: to make sure that monitoring doesn't introduce and noticeable overhead on the app being monitored
16:46:54 <mzero> ... that has a, umm, more modern interface where we can present a lot of context info.... as you type
16:46:57 <yitz> tibbe: another outcome of that could be actually improving those things in Data.Time :)
16:47:10 <mzero> *cough*webbrowser*cough*
16:47:25 <tibbe> yitz: now remind me, which of all the realToFrackingSomething functions do I need to use to get an integer from NDT?
16:47:39 <tibbe> yitz: I most likely will fix the lib yes
16:47:44 <yitz> tibbe:  choose one of round, floor, or ceiling
16:47:53 <tibbe> :/
16:47:57 <tibbe> there's nothing to round!
16:48:03 <yitz> tibbe: to get round seconds. multiply first if you need something finer.
16:48:42 <yitz> tibbe: POSIX allows platforms to give fractional seconds for the system time, that's why.
16:49:02 <tibbe> yitz: I mean, NDT is stored as picoseconds internally
16:49:04 <yitz> don't know which actually do that, if any.
16:49:40 <jmcarthur> picoseconds sounds like fractions of a second to me
16:49:45 <yitz> tibbe: yes, but it is presented as a fractional amount of seconds
16:49:51 <tibbe> right
16:49:53 <yitz> in the API
16:49:59 <tibbe> hence my exclamation!
16:50:11 <jmcarthur> it's just a fixed point representation instead of a floating point representation
16:50:18 <jmcarthur> but it's still fractional
16:50:28 <tibbe> jmcarthur: I mean I should have to go through a floating point time to get the time in picoseconds (as an integer)
16:50:38 <tibbe> sure
16:50:39 <jmcarthur> you don't have to
16:50:43 <tibbe> but it's potentially lossy
16:50:46 <jmcarthur> just multiply it by the right number and then round
16:51:34 <yitz> tibbe will probably truncate instead of using the haskell baker's rounding
16:51:34 <tibbe> I guess there are enough bits in the mantissa
16:51:47 <jmcarthur> round $ ndt * 1000000000000   -- or whatever
16:51:49 <yitz> tibbe: it's not an IEEE float
16:51:54 <jmcarthur> it's probably an Integer
16:52:00 <yitz> it is
16:52:45 <mzero> Date.Time.UTCTime -- last time I looked at all this - that was THE type to use
16:52:46 <jmcarthur> tibbe: why do you need to get an integer out of it anyway?
16:53:03 <tibbe> jmcarthur: I want to know if it's possible.
16:53:20 <tibbe> jmcarthur: I have yet to decide what's the most useful thing to return from the monitoring service
16:53:31 <jmcarthur> tibbe: why not just return a ndt?
16:53:33 <tibbe> jmcarthur: presumably something that doesn't lose precision
16:53:40 <tibbe> jmcarthur: encoded how
16:53:42 <tibbe> ?
16:53:42 <yitz> @faq can you get an integer out of a POSIXTime?
16:53:42 <lambdabot> The answer is: Yes! Haskell can do that.
16:53:51 <jmcarthur> encoded?
16:54:04 <tibbe> jmcarthur: it needs to be sent over the network from the server somewhere
16:54:14 <jmcarthur> how do you encode everything else?
16:54:16 <yitz> tibbe: it's an Integer of picoseconds, but the API treats it as fractional seconds.
16:54:20 <mzero> tibbe - you want the integer value to pass to the front-end from a UTCTime?
16:54:24 <tibbe> jmcarthur: depending what it is. JSON
16:54:37 <tibbe> mzero: I think so
16:54:49 <jmcarthur> couldn't you just use the Show instance or whatever?
16:54:57 <tibbe> probably want: { "server_time_pico": 121232131243124231421 }
16:55:02 <tibbe> jmcarthur: if it's fast :)
16:55:29 <yitz> tibbe: if you want, you can go to the internals and just unwrap the constructor to get the picoseconds as an Integer.
16:55:36 <tibbe> I have less than a millisecond or so to do all my computations
16:55:40 <mzero> then pass them in JSON as this      realToFrac . utcTimeToPOSIXSeconds
16:55:41 <jmcarthur> i see
16:55:48 <mzero> that is what you want
16:55:55 <jmcarthur> realToFrac  :(
16:56:10 <mzero> indeed, sad but there it is
16:56:17 <yitz> no that goes via Rational
16:56:57 <jmcarthur> i think if speed is of utmost importance then yitz's suggestion to unwrap it yourself sounds best
16:57:06 <mzero> actually, POSIXTime is a fine type too -- it is still UTC, but POSIX biased (in that the epoch is fixed by std.  )
16:57:17 <tibbe> mzero: why not realToFrac `fmap` getPOSIXTime?
16:57:21 <yitz> mzero: it's a NominalDiffTime
16:57:26 <tibbe> jmcarthur: the constructor is hidden
16:57:37 <jmcarthur> tibbe: there is no .Internal module?
16:57:42 <mzero> that's fine, tibbe
16:57:43 <tibbe> jmcarthur: no :(
16:57:45 <mzero> same thing, actually
16:57:49 <jmcarthur> aw
16:58:43 <mzero> I just stored things internally as UTCTime.....
16:59:50 <tibbe> (round . (* 1000000000000)) `fmap` getPOSIXTime
16:59:56 <tibbe> picoseconds since epoch
17:00:07 <tibbe> this is what I'm going to go with unless someone knows something better/faster
17:00:36 * mzero wonders if the JavaScript engines will handle that
17:00:47 <tibbe> mzero: too large?
17:00:57 <tibbe> they use doubles everywhere, no?
17:01:22 <mzero> > 1000000000000 * 345678 + 1
17:01:23 <lambdabot>   345678000000000001
17:01:30 <mzero> in JS you get 345678000000000000
17:01:36 <mzero> at least on Chrome - so yeah, doubles
17:01:38 <tibbe> oh?
17:01:43 <tibbe> :(
17:01:45 <jmcarthur> > 1000000000000 * 345678 + 1 :: Double
17:01:46 <lambdabot>   3.45678e17
17:01:46 <tibbe> @#$@#%@
17:01:46 <lambdabot> Unknown command, try @list
17:02:01 <mzero> so I'm guessing that picoseconds is well beyond the reach of JS's dates
17:02:20 <mzero> so - do you expect users to plot graphs of duration less than 1 second?
17:02:24 <tibbe> they use milliseconds for their timestamps I think
17:02:27 <tibbe> sucky
17:02:28 <jmcarthur> i think i would just use ndt's Show instance until i found that it was a bottleneck
17:02:42 <mzero> are you supporting drill down?
17:02:54 <tibbe> mzero: I was hoping that the server provided API could have high precision and lose precision on the JS side
17:03:12 <tibbe> mzero: not now, probably not any time soon
17:04:16 <tibbe> mzero: so you're saying that my json should e.g. contain a milliseconds since epoch (as a double) timestamps or things will be bad?
17:04:24 <mzero> then milliseconds are just fine
17:04:46 <tibbe> so JSON itself doesn't seem to have limited precision
17:04:55 <mzero> well, I'd pass seconds since epoch as a double value
17:04:57 <hpc> JSON itself is a text format
17:04:57 <mzero> and leave it at that
17:05:10 <tibbe> hpc: right, my point exactly
17:05:10 <hpc> it's just convenient that it can be parsed by a js eval
17:05:15 <yitz> tibbe: without hacking Data.Time, i think the best way to get the full precision out of NominalDiffTime with the least overhead is properFraction
17:05:15 <HugoDaniel> haskell should run on the browser!
17:05:15 <hpc> yeah
17:05:16 <mzero> and not really get worried over the precision of a millisecond
17:05:32 <HugoDaniel> lets kcick the arse of the mozilla guys and make 2012 the year tha t haskell runs on the browsee1!
17:05:42 <yitz> NominalDiffTime is a Pico, from Data.Fixed
17:05:48 <tibbe> HugoDaniel: we should target the chrome native thing
17:05:57 <mzero> (in this context - if I stretch a 1 second graph the width of my giant Apple monitor -- 1 pixel = 0.4 millisecond)
17:05:58 <HugoDaniel> dom haskell final boss 2012
17:06:01 <hpc> HugoDaniel: haskell in the browser will happen in the same year as linux on the desktop, then? :P
17:06:12 <HugoDaniel> :D
17:06:22 <mzero> HugoDaniel: help in the GHC -> NaCl project, and we'll have it running in the browser (at least Chrome)
17:06:35 <HugoDaniel> mzero: great!
17:06:40 <mzero> all we need to do is pare-down the RTS and we're there (I got the compilation bit working last Spring)
17:06:43 <hpc> mzero: we just need to tell dons that it's not possible to run fast haskell code in a web browser
17:06:50 <hpc> he'll have an implementation within the week
17:06:53 <tibbe> hoc: heh
17:06:56 <tibbe> hpc*
17:07:16 <mzero> that said - I think there is plenty of good that could come out of a simple Haskell -> JS compiler
17:07:30 <HugoDaniel> the approach to make haakssle run o the browser
17:07:32 <HugoDaniel> should be like
17:07:42 <mzero> even if it did a brain-dead kind of conversion -- after all, one doesn't run THAT much code in the front end - and there are cycles to burn there
17:07:48 <tibbe> yitz: to get seconds since epoch as a double?
17:07:51 <hpc> mzero: for about a month i worked on a JS monad
17:08:02 <hpc> the results were abysmal, but still pretty neat
17:08:03 <yitz> tibbe: why convert it to ieee? what do you gain?
17:08:06 <HugoDaniel> 1st create an ISA that is simple and turing complite, mayb e something like risc or llvm
17:08:11 <mzero> dinner time - laters....
17:08:13 <yitz> tibbe: it's a Data.Fixed
17:08:40 <tibbe> yitz: I need to return the result as JSON and as mzero said using a precision higher than milliseconds is no use in JS
17:08:50 <HugoDaniel> 2nd make a small haskell compiler that runs a subset of haskell, like "haskell--" or "dumb haskell" that runs on it
17:08:53 <HugoDaniel> 3rd world domination
17:09:14 <tgeeky> I want full power Haskell in the background, I just want a ghci in the web browser
17:09:30 <HugoDaniel> im freaking tired of coding in JS
17:09:32 <tgeeky> I don't think that means having a haskell -> JS
17:09:40 <tgeeky> HugoDaniel: yeah, that's what you want haskell -> js for
17:09:41 <HugoDaniel> im coding JS to earn big bucks
17:09:49 <tibbe> I think ClojureScript takes the right route
17:10:01 <hpc> JS isn't so bad
17:10:13 <HugoDaniel> tibbe: i really enjoy your blog
17:10:22 <hpc> (except for the parts that are; the browserbits are ugly but the core language is mostly nice)
17:10:23 <yitz> tibbe: ah drat. properFraction also goes via Rational in Data.Fixed. Phooey!
17:10:28 <tibbe> HugoDaniel: thanks
17:10:38 <hpc> ((albeit, underdeveloped))
17:10:58 <tibbe> yitz: realToFrac . (* 1000)) `fmap` getPOSIXTime  -- milliseconds since epoch as floating point
17:11:16 <HugoDaniel> specially the work in monitoring haskell remotely :) amazing stuff
17:11:18 <yitz> tibbe: i'm trying to avoid piping your cast via Rational
17:11:31 <yitz> that's slow
17:12:05 <tibbe> yitz: yeah
17:12:07 <HugoDaniel> im sorry, im too much drunk to be writing in irc
17:12:11 <tibbe> yitz: we should add some rewrite rules
17:12:19 <tibbe> yitz: I'll go with that for now and then try to optimize
17:13:08 <tibbe> thanks everyone for the help
17:15:00 <tibbe> happy new year I guess :)
17:15:36 <yitz> tibbe: so the problem is actually not Data.Time. Data.Fixed hides its constructor, has no Internal module, and insists on going via Rational for absolutely everything.
17:16:02 <yitz> tibbe: so we need to fix Data.Fixed in base to allow lower level access
17:16:17 <HugoDaniel> 2012 is going to be The Year :D
17:16:25 <tibbe> yitz: I agree
17:16:34 <tibbe> yitz: and area of haskell i haven't had time to look into yet
17:17:25 <yitz> tibbe: oh it's trivial, Data.Fixed is small and simple. any one of those 3 could be relaxed to fix the problem.
17:18:16 <yitz> tibbe: easiest is probably just move the type itself to Internal and expose the constructor there
17:18:49 <HugoDaniel> yesod vs snap vs happs which do you guys prefer ?
17:19:54 <yitz> HugoDaniel: they're all good
17:19:55 <tibbe> HugoDaniel: I only have experience with Snap, which is straightforward. Heard good things about Yesod as well.
17:20:12 <m3ga> I thought Happs was unmaintained
17:20:42 <HugoDaniel> m3ga: no, happs is being maintained by two great haskell hackers, stepcut and lemmih
17:20:45 <yitz> HugoDaniel: they share their best parts with each other, and compare their research on various techniques
17:21:30 <yitz> HugoDaniel: subscribe to web-devel, it's a good list
17:23:02 <HugoDaniel> thanks :)
17:23:09 <m3ga> HugoDaniel: must have been another haskell web framework i was thinking of
17:23:30 <ehuber_> q: i have a type problem where haskell is assuming a different type for a value based on a piece of code other than the one im currently looking at. can i get ghc to tell me where that is?
17:23:49 <HugoDaniel> happs changed the name to happstack, but the irc # mantained the #happs name
17:24:03 <tibbe> I really really wish someone ported Clojure's ring framework to Haskell
17:24:30 <HugoDaniel> ehuber_: paste the code to hpaste.org so we can look at it (even under the effect of alchool)
17:25:22 <HugoDaniel> tibbe: what is the special power of the clojure ring framework ? what is great about it ?
17:25:30 <ehuber_> haha, no it's embarassing, but thanks for the offer
17:26:48 <tibbe> HugoDaniel: it's simple, compositional, and functional
17:26:57 <tibbe> HugoDaniel: I feel that the Haskell frameworks are a bit to OO
17:27:01 <c_wraith> ehuber_: then the best you can do is annotate the types you expect in subexpressions, trying to get ghc to narrow down where the difference between what you think and what it thinks
17:27:12 <tibbe> making them somewhat monolitical
17:28:01 <yitz> m3ga: happstack is a fork of happs that is under active development.
17:28:37 <ehuber_> c_wraith: thank you :) i know that, however that thing i mentioned keeps bugging me so i figured that surely ghc could be convinced to tell me
17:29:00 <m3ga> yitz: just remembered, i was thinking of wash
17:29:27 <yitz> m3ga: ah yes. that was a great idea. wish someone would work on something like that.
17:29:33 <HugoDaniel> i have some rules of programming
17:29:35 <HugoDaniel> that i abide to
17:29:51 <HugoDaniel> simple stuff that my little experience has taught me
17:29:55 <HugoDaniel> 1st is
17:30:04 <HugoDaniel> do NOT rewrite from scratch
17:30:15 <HugoDaniel> 2nd is
17:30:38 <HugoDaniel> do DNOT absttract a DSL
17:30:56 <HugoDaniel> like sql or whatever you might have that is specific to whatever arch ytou might be targeting
17:31:03 <HugoDaniel> meh
17:31:09 <HugoDaniel> ill stop, im too much drunk sorry
17:33:18 <NihilistDandy> brb, restarting
17:36:25 <HugoDaniel> do you guys have programming rules ? or is it just like "programming motherfucker, do you speak it ?"
17:38:20 <FUZ> HugoDaniel: Well, I don't know what you try to ask
17:38:38 <HugoDaniel> sorry
17:38:45 <hughfdjackson> HugoDaniel: do you mean.. style guides?
17:38:47 <hughfdjackson> best practices?
17:39:19 <HugoDaniel> yeah, like things that experience has taught you
17:39:41 <HugoDaniel> and that now help you to be more productive
17:39:55 <FUZ> Don't mess with your monads
17:39:56 <HugoDaniel> special design tricks, thats where my aquiles eel is
17:40:18 <hughfdjackson> well, haskell is definitely isn't my language, so .. i'll let others answer :)
17:40:24 <HugoDaniel> i fail hard at doing the perfect code design or at estimating developing times
17:40:46 <hughfdjackson> oh i have a general rule
17:40:51 <HugoDaniel> my boss doesnt seem to care much, which is ok for me
17:41:03 <HugoDaniel> hughfdjackson: which one ?
17:41:15 <hughfdjackson> break down the requirements into smaller parts (logical iterations), and daydream about how long it might take you to get it done
17:41:16 <hughfdjackson> then double that
17:41:17 <hughfdjackson> at least
17:41:17 <FUZ> HugoDaniel: When I code Haskell, I usually think long and code short
17:41:26 <hughfdjackson> both of them help you estimate conservatively
17:41:55 <HugoDaniel> good tips
17:53:43 <Omer_Bot> Test
17:54:54 <alistra> hi
17:55:15 <alistra> nobody uses haskell in usa
17:55:24 <alistra> so the channel is empty now :|
17:55:29 <Axman6> nope, no one at all
17:56:05 <zmv> indeed
17:56:18 <alistra> lol i couldn't drive through the streets because of the used up fireworks laying around :/
17:56:19 <alistra> unsafe
17:57:23 <ion> How about driving without laughing out loud? :-)
17:57:27 <sshine> that reminds me of a carnival I went to this year. there was so much broken glass on the streets from alcoholic beverages that all taxis went on strike for two days until it got cleaned.
17:57:34 <ion> hah
17:57:44 <alistra> lol
17:57:52 <alistra> i was on the townsquare like 2 years ago
17:58:26 <alistra> it was literally 5cm of broken glass/ice/frozen cheep alcohol/and fireworks laying everywhere
17:59:00 <alistra> it's about a half of mile for those who don't know the metric system
17:59:23 <zmv> LOL
17:59:34 <sshine> hehe
17:59:54 <zmv> troll'em metric
18:02:06 <Bot_222435> o
18:02:22 <Bot_222435> o
18:02:58 <alistra> o
18:02:59 <alistra> o
18:06:59 <hughfdjackson> im here
18:07:08 <hughfdjackson> :P in response to the comment before
18:07:12 <Axman6> whoever is testing their bot in the channel, please use a more appropriate channel, like #test (i think)
18:07:12 <hughfdjackson> but i'm fairly useless :D
18:14:30 <ksf> is there a successor to gmap?
18:15:40 <c_wraith> hmap?
18:15:58 <c_wraith> (bad joke, not answer)
18:16:32 <ksf> I want a map from string to list of int to an adt
18:16:46 <ksf> ...supporting lookup by either string or sting and list of int
18:17:23 <ksf> is it unreasonable to expect there to be a haskell library that lets me compose maps and operations on them like that?
18:19:25 <c_wraith> Huh.
18:20:14 <c_wraith> Map types could be made into some sort of Arrow, to encourage composition in that way
18:20:25 <c_wraith> It'd still require new combinators
18:20:54 <mkscrg> question about enumerator: why doesn't it export a composition function?
18:21:10 <mkscrg> i've asked that on both -cafe and stackoverflow with no response so far
18:21:10 <ksf> because it's already an instance of monad
18:21:38 <mkscrg> ksf: sorry, i should be more specific: why doesn't it export an enumeratee composition function?
18:21:47 <c_wraith> because the author didn't do it.
18:22:40 <ksf> also, there's all kind of operators involving <,>, and =
18:24:05 <mkscrg> c_wraith: fair enough, i guess. isn't enumeratee composition one of those killer features? the other iteratee packages advertise it that way, at least
18:24:13 <mkscrg> ksf: i don't understand
18:24:35 <ksf> (>==>) :: Monad m => Enumerator a m b -> (Step a m b -> Iteratee a' m b') -> Step a m b -> Iteratee a' m b'
18:24:47 <ksf> takes two enumerators, returns an enumerator.
18:25:55 <mkscrg> ksf: i'm looking for enumeratee composition.
18:26:08 <ksf> oh.
18:26:57 <rwbarton> that function sure doesn't look like it takes "two anything".
18:27:08 <beefcube> I'm reading: http://www.haskell.org/haskellwiki/Monad_laws "Right identity: m >>= return  ≡  m" How does  a function with this signature: "(>>=) :: m a -> (a -> m b) -> m b" satisfy that? i'm new to haskell and i'm having trouble following it
18:27:10 <ksf> well, there's joinI
18:27:13 <mkscrg> i'm asking because (i think) there's a simple implementation of enumeratee composition, but john didn't include it in the library
18:27:43 <ksf> rwbarton, Enumerator is an alias for the type of the second parameter with a = a' and b = b'
18:28:03 <rwbarton> oh, ew
18:28:17 <rwbarton> Anyways, what I said is still more or less true
18:28:41 <mkscrg> this looks like something i should ask john directly
18:29:37 <ksf> oleg's original code uses joinI all over the place IIRC
18:29:56 <c_wraith> the Conduit package is looking more and more appealing...
18:32:40 <ksf> beefcube, it satisfies it by obeying it
18:33:42 <ksf> http://ro-che.info/ccc/05.html
18:35:35 <beefcube> ksf: i don't understand, the first law was easy to follow, the second i'm guessing this is what is occuring : (a -> m a) >>= return but I don't see how that works given the functions signature
18:36:30 <ksf> nah, m is forall a. Monad m -> m a
18:36:42 <ddarius> =>
18:36:47 <ksf> (where the forall is captures the whole law)
18:36:59 <ksf> (and ddarius fixes my typo)
18:37:24 <ddarius> beefcube: I wouldn't worry about the monad laws until you have a better grasp of the type system.
18:37:36 <ksf> e.g. (m :: IO a) >>= (return :: a -> IO a) == (m :: IO a)
18:38:30 <ksf> imagine you have a burrito. you unwrap it and then wrap it. what you then have is the original burrito
18:38:38 <ksf> (because tortillas are indistinguishable)
18:40:41 <hughfdjackson> ksf: this is how all programming should be explained
18:45:19 <ksf> well, instance Monad Bag probably isn't the worst example of a monad.
18:46:04 <ksf> it's just the right mix between actual container and theoretical thingy.
18:51:08 <O_22> /MSG a
18:55:01 <beefcube> ksf: ah! thanks
18:59:06 <beefcube> i wonder if they will ban my account if i tweak the laws on the wiki a little bit to show that it is a concrete type..
20:08:15 <The_Journey> I'm confused on LYAH on the zipper data structure, if I use zipper with a binary tree, would updating/modifying nodes from the root node be creating entirely new tree?
20:10:08 <mzero> well, yes and no
20:10:09 <Axman6> The_Journey: can you clarify a bit? I'm not sure what this has to do with zippers
20:10:23 <Axman6> pretty sure the answer is 'sort of' though
20:10:42 <snhmib> as far as i remember/understand, everything you zip "up" is gonna be new, now?
20:11:00 <snhmib> now=no
20:11:01 <mzero> when you use a zipper - you essentially create a new tree - but it is done by making a sort splice of the new stuff, and it shares much of the original tree
20:11:01 <Bob_Bot_666> Nerp
20:11:09 <The_Journey> Axman6: well I'm talking about this http://learnyouahaskell.com/zippers , I don't understand how the zipper data structure would be efficient if I pass the binary tree using the root node
20:11:31 <Axman6> "pass the binary tree using the root node"?
20:11:45 <Axman6> i do wish that whoever is testing their bot in here wouldn't
20:11:58 <mzero> if you hang on to the original tree, and the  updated one - you can still explore both, independently - but they will be sharing much memory (though you can't really observe that directly)
20:12:04 <Bob_Bot_666> :r
20:12:05 <Bob_Bot_666> :r
20:12:17 <The_Journey> Axman6: how else would it be normally passed?
20:12:29 <The_Journey> to like a function
20:12:29 <Axman6> The_Journey: what do you mean by passed?
20:12:35 <The_Journey> as an argument
20:12:50 <Axman6> how else could you give the whole tree to a function?
20:13:00 <Axman6> i really don't understand what you're asking
20:14:18 <The_Journey> Axman6: the zipper data structure is supposed to be more efficient for modifying data structures right? I don't understand how it will be more efficient if I pass a binary tree using the root node to a function as an argument
20:14:44 <Axman6> The_Journey: it's more efficient if you're performing many modifications at the same time
20:15:23 <Axman6> you can navigate through the tree to modify the pieces you need to access, without having to traverse the whole depoth of the tree to where you need to modify it
20:15:40 <mzero> normal tree modification requires rebuilding from the root to the place of the modification ---
20:16:02 <mzero> zipper modification requires only rebuilding around the zipper - including any motion involved
20:17:07 <The_Journey> how can a binary search tree be efficient in Haskell then, an update to the tree would be really expensive?
20:17:31 <Axman6> not really, it only takes log(n) new nodes
20:17:46 <Axman6> at most
20:18:08 <blackdog> The_Journey: it is the reason that hash tables aren't terribly popular in haskell
20:18:12 <Axman6> which means, that if you have 2^20 elements in your tree, you only need 20 new nodes
20:18:21 <The_Journey> Axman6: so I still have to create new nodes from the root node? what is the zipper's purpose then?
20:18:33 <mzero> The_Journey: only the first time
20:19:00 <mzero> if you're going to use a zipper to head into the tree, and then make a change, and then another change to a nearby node, then the zipper is more efficent
20:19:02 <mzero> t
20:19:08 <Axman6> a zipper lets you navigate around a structure. importantly, it lets you move 'up' in a tree, which you cannot do normally
20:19:10 <mzero> because you aren't doing it from the top again
20:19:25 <The_Journey> ah ok, I see
20:19:39 <Axman6> the file system traversal example should have made this clear
20:19:49 <mzero> but really, zippers are deeply about efficiency - they are about flexible access - when you need to move around inside a data structure in an ad hoc way -
20:20:00 <Test_123_666> abc
20:20:11 <mzero> er s/are deeply/aren't mostly/
20:20:35 <Axman6> @where ops
20:20:36 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:20:50 <mzero> alphabet trolls?
20:21:11 <Axman6> ops: any chance of a ban on *!*@71-81-151-26.dhcp.stls.mo.charter.com? this is not the place for people to be testing out their bots
20:21:30 <The_Journey> if I were to have a graph that updates the nodes in iterations, what possible way can I make it efficient since the zipper data structure seems to be more about flexibility than efficiency
20:21:51 <mzero> Happy New Year's US East Coast
20:22:09 <mauke> Omer_: hi
20:22:13 <blackdog> mzero: man, you USians are so slow :)
20:22:17 <mzero> The_Journey: don't be so sure it won't be efficient enough
20:22:30 <Axman6> i went to sleep 12 hours ago, and that was at 4AM!
20:22:58 <blackdog> Axman6: yeah me too :) in canberra?
20:23:12 <Axman6> yup
20:23:18 <The_Journey> mzero: won't each iterations be creating a new node everytime? If I were to run the iterations for a large amount, like 10,000+, would I run into trouble?
20:23:25 <Axman6> we were doing SES stuff, looking after the drunks in the city
20:24:15 <mzero> The_Journey: hard to say - were you running this before, in say Python? then no, still will out-perform
20:24:31 <mzero> if it is something you had to hand tweak in C++ to get fast enough
20:24:39 <mzero> then you can expect to have to do the same in Haskell
20:24:55 <mzero> and like learning how to memory and time optomize C++, you'll have to learn different techniques for Haskell
20:25:13 <mzero> the same data structures will not have the same performance characteristics when translated into a functional programming context
20:25:41 <blackdog> The_Journey: also, by using non-ephemeral data structures, you're likely to find it much, much easier to parallelise
20:26:29 <blackdog> it's not about two or three big oxen any more - you've got to learn how to harness a cloud of mosquitoes
20:26:32 <mzero> 10k iterations * 20 new nodes per is still only 200k memory allocations -
20:26:47 <mzero> you're web browser does that just displaying one page of facebook
20:27:29 <The_Journey> ok, thank you
20:28:22 <hughfdjackson> blackdog: that was deep xD
20:28:52 <blackdog> hughfdjackson: *grin* i liked the image
20:29:27 <hughfdjackson> ^_^ me too
20:30:35 <The_Journey> is there a mature neural network library of some sort in Haskell?
20:40:01 <blackdog> The_Journey: checked hackage?
20:40:24 <blackdog> there's hfann - binding to FANN
21:52:22 <Omer_> S
21:52:36 <Omer_2> l
21:52:51 <mauke> Omer_: hi
21:53:55 <Omer_2> :r
21:53:56 <Omer_2> :r
21:54:26 <Sgeo> What's with enumerator/conduit hard to remember $= and =$ ?
21:54:35 <Sgeo> The = faces away from the $$?
21:54:37 <mauke> Omer_: stop ignoring me
21:54:45 <Omer_> Yes?
21:54:54 <mauke> Omer_: don't test your bots here
21:55:04 <Sgeo> No, I think = faces towards
21:55:14 <Sgeo> @hoogle ($=)
21:55:15 <lambdabot> No results found
21:55:43 <mauke> in exchange: http://i.imgur.com/5mvX6.jpg
21:56:09 <Sgeo> Why does = face towards the $$ rather than away?
21:56:17 <Sgeo> Is there some mnemonic that I'm missing?
22:02:27 <cmccann> Sgeo, it's reaching toward the dollar signs to show that the code wants to be profitable
22:03:03 <mauke> > cycle "$"  -- make $$$$ fast!
22:03:04 <lambdabot>   "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$...
22:05:46 <Omer_> > putStrLn "wat"
22:05:46 <lambdabot>   <IO ()>
22:05:52 <Omer_> Cool
22:06:07 <Corwinoid> can someone explain the transformation (f .) (g x) y z to ((f .) . g) x y z, for me?
22:14:19 <byorgey> Corwinoid: sure
22:14:39 <byorgey> = ((f .) (g x)) y z
22:14:55 <byorgey> = (((f .) . g) x) y z
22:15:29 <byorgey> = ((f .) . g) x y z
22:15:42 <byorgey> is there a particular step you don't understand?
22:16:02 <mauke> lemme break it down TO THE EXTREME
22:16:13 <byorgey> check it!
22:16:14 <mauke> y z are outside and don't participate. drop 'em
22:16:21 <Corwinoid> lol mauke...
22:16:31 <mauke> (f .) is atomic. replace by h
22:16:39 <mauke> end up with h (g x)
22:16:49 <mauke> transforms to (h . g) x
22:16:59 <mauke> look at definition of (.), done
22:17:06 <byorgey> record scratch!
22:19:13 * cmccann complains about the lack of rhyme and meter
22:19:28 <mauke> it rhymes in the original latin
22:19:34 <cmccann> haha
22:20:42 * cmccann should start writing comments in verse
22:21:05 <cmccann> would probably make them more interesting to read
22:21:27 <byorgey> at the very least it would make the internet that much awesomer.
22:21:48 <cmccann> at least keeping a meter, rhymes might be too hard to work around
22:21:56 <mauke> cmccann: https://metacpan.org/module/Coy
22:22:33 <cmccann> meh, haiku are overdone
22:23:09 <mauke> yeah, but it autohaikus all error messages
22:23:43 <cmccann> true, that is inarguably awesome
22:23:55 <cmccann> I'd rather break new ground myself, is all
22:25:16 <byorgey> Corwinoid: so do you understand it now? or is there anything you're still confused about?
22:26:34 <cmccann> byorgey, so how much would you be entertained if I rewrote the haddocks for diagrams-core in poetic meter or something like that?
22:26:35 <Corwinoid> better than before, I think my haskell is just too rusty to jump straight into point-free
22:29:11 <byorgey> cmccann: haha, quite entertained =)
22:30:40 <cmccann> heh. entertained enough to actually upload the poetic version to hackage?
22:36:25 <byorgey> cmccann: well... I don't think I would upload a version with poetry *replacing* existing documentation.  But I would certainly upload a version with added poetic documentation.
22:36:46 <cmccann> aww
22:37:17 <cmccann> not even if it's basically saying the same thing? :P
22:37:37 <byorgey> although it depends on the quality (both artistically and pedagogically) of the poetry I suppose =)
22:38:41 <byorgey> I must admit that "scooping the loop snooper" is much better than any prose explanation I've ever read.
22:38:42 <cmccann> pretty sure I could fit the existing documentation to meter and maybe even some sort of rhyme scheme without changing the content much
22:40:05 * byorgey is unsure whether cmccann is serious
22:40:49 * cmccann is entirely serious, he has a decent ear for meter and a good vocabulary.
22:43:13 <byorgey> well in that case, please send me a sample poetic translation of some module or part of a module and I will seriously consider it =)
22:56:56 * ddarius reads some papers from the beginning of his current backlog which seems to have started in January 2008.
22:57:36 <cmccann> byorgey, hm, looks like the biggest obstacle is the uneven length of the different bits
22:58:17 <cmccann> they're all short enough that it'll sound lame unless I maintain some meter between them, but the short ones are only 5-6 syllables sometimes
22:59:42 <cmccann> and because of words like "invertible" floating around a disyllable foot is probably not gonna fly
23:00:30 <cmccann> otherwise most of these can be worked into shape without too much trouble
23:02:05 <cmccann> also rhymes may not be a good idea, because lots of short lines made of amphibrachs + rhymes = sounds like Dr. Seuss
23:03:05 <cmccann> anyway, I'll give it a proper go tomorrow, see how well it works
23:03:09 <cmccann> if only to prove that I can :P
23:40:44 <hoqhuuep> Hi folks, I'm wondering if any of you could reccomend a good series of online tutorials for getting started with Haskell, targeted at people with a competent knowledge of programming (C#, C++, Java, Perl, Python) but very little functional programming experience. I'm looking for something which introduces the concepts and builds them up to an intermediate level of Haskell programming. Also preferably without too much misinformatio
23:41:29 <PatrickRobotham> hoqhuuep: Learn you a haskell for great good.
23:42:16 <sylecn> @wiki books
23:42:16 <lambdabot> http://www.haskell.org/haskellwiki/books
23:43:12 <azaq23> @where lyah
23:43:12 <lambdabot> http://www.learnyouahaskell.com/
23:43:26 <Corwinoid> Programming in Haskell, concurrently with LYAH.  Oddly, the former puts some fairly trivial concepts fairly late in the book (comprehensions), but is a rather good primer
23:45:53 <hoqhuuep> Very briefly skimming though LYAH it looks like just the right sort of thing. Thank you all for the recommendation :-)
23:49:39 <ddarius> Corwinoid: Maybethe "trivial" concepts are placed later because they are not important.  Alternatively, perhaps a connection to a less trivial concept motivated their placement.
23:51:35 <Corwinoid> ddarius: I think the motivation is to make the reader think functionally, rather than necessarily showing the simplest solutions to problems.   LCs are candy anyway, but form a rather natural way of doing things....alternatively, perhaps the author is a lambda purist who doesn't believe set notation really deserves its place
23:51:41 <Corwinoid> It's a mystery!
23:54:34 <ddarius> List comprehensions are not set notation.
23:54:40 <ddarius> Though they are inspired by the notation.
