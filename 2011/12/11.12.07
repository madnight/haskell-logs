00:06:30 <hvr> hrm...  weird 'cabal-dev configure' doesn't pass thru most configure flags :-/
00:07:43 <Lajla> "A monad is a construction that, given an underlying type system, embeds a corresponding type system (called the monadic type system) into it (that is, each monadic type acts as the underlying type). This monadic type system preserves all significant aspects of the underlying type system, while adding features particular to the monad."
00:07:47 <Lajla> does that seriously mean anything?
00:08:34 <Lajla> What does that mean
00:08:38 <Lajla> What is it trying to say
00:08:49 <Lajla> when archaeoligists 700 years from now find that, they will be puzzled.
00:09:19 <luite> hvr: --cabal-install-arg=-original-argument
00:13:54 <etpace> Hi, for some reason my ghc isnt picking up my xmonad-contrib package (even though its shown in my second package.conf.d in ghc-pkg list), any ideas what could be wrong?
00:14:48 <etpace> and note, it can load other modules in that package.conf.d fine..
00:14:51 <ddarius> It means a monad is a functor.
00:15:13 <etpace> (and the .hi files are definitely present in ~/.cabal/lib/xmonad-contrib-0.10/)
00:20:31 <hvr> luite: ah ok, that helps too... I had a prob with a simple 'cabal-dev configure -f-bar -O2'
00:21:06 <hvr> luite: I used the long options, and those were passed thru... it's just confusing, as I expected cabal-dev to be a drop-in replacement :-)
00:22:08 <carpi> is there a difference between monadic functions and monadic values?
00:22:43 <shachaf> That depends on what you mean by those words.
00:23:15 <shachaf> The common meaning of "monadic value" is a value of type m a, where m is a Monad.
00:23:46 <shachaf> The common meaning of "monadic function" is a function that returns a "monadic value", probably (for sufficiently broad meanings of "returns").
00:23:48 <carpi> and monadic function is one which returns a monadic value
00:23:59 <shachaf> Note that every function is a monadic value, by this definition. :-)
00:25:02 <carpi> how?
00:26:52 <carpi> how can purre functions be monadic? im not sure if thats even the right question to ask..
00:27:21 <Jafet> All monads are impure!
00:27:25 <Jafet> @instances Monad
00:27:26 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
00:28:02 <DanBurton> well define "pure"/"impure"
00:28:38 <carpi> side efffect free?
00:28:44 <DanBurton> if you define it as "no side effects", then...well...define "side effect"
00:28:56 <shachaf> carpi: Every function is pure.
00:29:11 <DanBurton> because >>= implies that the "side effects" are conveyed from one function to the next...sort of
00:29:34 <carpi> even functions that evaluate to monadic values?
00:29:38 <Lajla> Yeah
00:29:44 <Lajla> Like, you need to see it like this
00:29:53 <DanBurton> the "monadic value" includes the "side effect" inside of it
00:29:54 <shachaf> Monads are impure because they introduce foreign subtances into our precious bodily fluids, not because they "have side effects".
00:30:09 <Lajla> Say you get putStrLn, this takes in a string, and returns a datum which is basically a command which says 'print this string on a line'
00:30:25 <Lajla> But the function itself doesn't print it, and you can use it like a function like you want
00:30:29 * shachaf "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
00:30:49 <Lajla> Say for instance (map putStrLn ["a string", "another string", "a third string"])
00:30:57 <Lajla> You then have a list of three monads, you get?
00:31:07 <DanBurton> a list of three monadic actions
00:31:26 <DanBurton> or monadic values
00:31:30 <Lajla> True
00:31:38 <Lajla> But whatever, it's besides the point
00:31:48 <Lajla> the point is that using the putStrLn function itself had no side effect
00:31:49 <DanBurton> a "monad" in Haskell is a particular *type*
00:31:59 <shachaf> DanBurton: No, it's a type constructor. :-)
00:32:21 <Jafet> It's both!
00:32:22 <Lajla> Now this is the part where people stop helping each other because they're arguing definitions
00:32:35 <shachaf> But calling that "a list of three monads" just causes confusion.
00:32:46 <carpi> but someone has to define what putStrLn does..then what is that body of code called?
00:32:49 <DanBurton> shachaf: well, a type of kind * -> *, I suppose you can call that a type constructor
00:33:04 <Lajla> carpi, that is called a function I guess...
00:33:31 <DanBurton> carpi: it's called...the body of code?
00:33:50 <shachaf> carpi: I would recommend focusing either on "IO" -- in which case you ignore the word "monad" -- or on "monads" -- in which case you ignore IO.
00:33:55 <shachaf> Don't do both at the same time. :-)
00:34:10 <Lajla> putChar is a primitive I assume?
00:34:15 <carpi> but i thought IO is a monad?
00:34:29 <shachaf> carpi: Yes, but it's a very atypical one in many ways.
00:34:43 <DanBurton> carpi: IO is a monad. But you can use IO at a basic level without understanding monads.
00:34:44 <Lajla> carpi, well, a monadic value is basically a datum which is a description of a command to be executed in this case
00:35:00 <Jafet> In either case, you can ignore Lajla.
00:35:14 <Lajla> w/e I'm out
00:35:27 <DanBurton> Lajla: erm yes I think it is implemented as a primitive
00:35:45 <shachaf> Jafet: I don't think I was saying that. :-)
00:36:11 <Jafet> Indeed; I think I was.
00:36:54 <shachaf> carpi: Every individual monad, in addition to implementing the Monad API, also has a set of primitives that are specific to it.
00:37:20 <shachaf> In the case of State, for example, you have get and put (and also runState and a few others).
00:37:44 <carpi> when you say API, you mean monads are more like an extension of the language than the language itself?
00:37:45 <shachaf> Without these primitives it would be useless. The monad API on its own is not useful.
00:38:06 <shachaf> carpi: "Monad" is just a type class. It's a library.
00:39:25 <carpi> in that case, i think the best way to understand monads is to treat them like any other type class that you may encounter.
00:39:53 <shachaf> Well, kind of.
00:40:27 <shachaf> The best way to "understand monads" is probably to stop trying to "understand monads".
00:41:34 <carpi> haha..makes sense. the least painful way to learn something is to be unaware that you're learning it while having fun at the same time :D
00:41:37 <mux> if I ever write a monad tutorial, its title would be "How I Learned to Stop Worrying and Love Monads"
00:41:47 <DanBurton> lol
00:42:16 <carpi> mine would be monadgasm D
00:42:19 <shachaf> mux: I anticipated this above, as you can see.
00:42:39 <mux> shachaf: you did? I must be missing some context
00:42:42 <DanBurton> It seems like monad tutorials are a rite of passage or something
00:42:46 <shachaf> <shachaf> Monads are impure because they introduce foreign subtances into our precious bodily fluids, not because they "have side effects".
00:43:07 <mux> but monads aren't impure :-)
00:43:59 <shachaf> mux: I see. You're with the Commies.
00:44:17 <mux> lol
00:44:30 <DanBurton> the monad flows through all of us. it is what makes the stars move and the planets spin
00:44:36 <shachaf> OK, enough monad jokes.
00:45:13 <mux> DanBurton: then there must be dark monads to explain galaxies' spin that cannot be fully accounted by observable monads ;-)
00:45:25 <DanBurton> comonads? :)
00:50:59 <mbuf> are there any tools/libraries to read and parse a .cabal file without using Haskell?
00:51:14 <ddarius> ...
01:09:09 * hackagebot iff 0.0.2 - Constructing and dissecting IFF files  http://hackage.haskell.org/package/iff-0.0.2 (HenningThielemann)
01:09:24 <VHD> anyone in windows know how how to get past the "*Missing C librararies: gobject-2.0, glib-2.0, intl" when trying to install glade (gtk2hs)?
01:09:32 <VHD> on*
01:09:43 <fff> hello
01:11:53 <luite> VHD: download the gtk bundle for windows, add its bin directory (containing pkgconfig.exe) to your %PATH%
01:17:41 <VHD> luite, I downloaded Glade with gtk+, installer. I take it the gtk+ installed by that is wrong or the reason this is not working?
01:18:56 <luite> hmm, I'm not sure what htat installs, but you do need the development libraries and pkg-config inyour path
01:19:14 <VHD> ok, will give the bundle a shot now.
01:20:32 <luite> you can check whether it's installed correctly by running pkg-config on the command line, I forgot the exact command, something like pkg-config --cflags glib-2.0
01:21:47 <VHD> well that command is pointing to the files stored by the installer I mentioned, so it looks like it is installed.
01:22:46 <luite> maybe you tried cabal installing it from a command prompt that was already open (and doesn't know about the updated PATH)?
01:23:47 <VHD> I dont think that is the problem, as I have tried multiple times. I even pointed to the libraries but still same error.
01:24:00 <VHD> using extra lib dirs
01:24:30 <luite> hmm, don't know then, sorry
01:27:34 <Phyx-> Why does everyone fear monads? I must be missing something...
01:27:50 <koala_man> it's the name
01:28:00 <VHD> I dont fear them, I just dont get them. :)
01:29:02 <Phyx-> that's a start :)
01:29:24 <VHD> though I came across mnavier's YAMT and that helped lots
01:29:50 <Phyx-> what's the link?
01:30:02 <VHD> http://mvanier.livejournal.com/3917.html
01:30:27 * Phyx- looks
01:37:18 <VHD> ok... well everything is pointing at gtk+ installed and working. gtk-demo works too.
01:37:33 <VHD> :|
01:39:07 <VHD> "Could not find module 'Graphics.UI.Gtk.Glade"
01:48:07 <Phyx-> does ghc-pkg show gtk installed?
01:48:52 <VHD> yup, seems to be there.
01:49:09 * hackagebot global-variables 1.0.1.0 - Namespaced, global, and top-level mutable variables without  unsafePerformIO.  http://hackage.haskell.org/package/global-variables-1.0.1.0 (JeanMarieGaillourdet)
01:50:17 <Phyx-> weird
01:50:36 <Phyx-> VHD: if you do ghc-pkg describe gtk do you find the module under exposed modules?
01:50:54 <Phyx-> don't remember if glade is it's own package
01:51:17 <VHD> this person had the same issue and has resolved, currently going through it. The fix seems to be hidden in the discussion.
01:51:18 <VHD> http://groups.google.com/group/haskell-cafe/browse_thread/thread/f2ff2ee7f1fb12d7
01:51:58 <Phyx-> ok
01:52:16 <VHD> ah Phyx- your command returns cannot find package gtk
01:54:02 <Phyx-> VHD: substitute gtk by the actual package name in ghc-pkg list, i'm not sure what it's called, but you said it's there
02:09:00 * Phyx- is starting to get used to wearing a suit
02:31:35 <fcul> Hi! Good morning =)
02:32:12 <fcul> Noob question (been looking allover, haven't found, probably impossible to do): can you "cast" a float to an int?
02:32:32 <MostAwesomeDude> @hoogle Float -> Int
02:32:33 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
02:32:33 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
02:32:33 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
02:32:37 <kamatsu> fcul: "cast" as in memory cast, or convert a number
02:32:48 <kamatsu> ?
02:32:57 <kamatsu> wow, how unhelpful lambdabot
02:33:16 <MostAwesomeDude> TBF, "int" and "float" might be a bit nebulous in this case.
02:33:17 <opqdonut> :t floor
02:33:19 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:33:31 <hpaste> Haskell_newbie pasted “Cabal install error” at http://hpaste.org/54953
02:33:37 <MostAwesomeDude> Float isn't a RealFrac, is it?
02:33:51 <opqdonut> :t floor :: Float->Int
02:33:52 <lambdabot> Float -> Int
02:33:52 <fcul> kamatsu: convert float to int
02:34:05 <opqdonut> MostAwesomeDude: it surely is
02:34:12 <haskell_newbie> I am not able to install cabal.
02:34:28 <haskell_newbie> First i installed ghc-7.0.3 and then trying to install cabal
02:34:34 <haskell_newbie> but getting error
02:34:52 <haskell_newbie> http://hpaste.org/54953
02:36:34 <kamatsu> fcr, use floor
02:36:40 <kamatsu> :t floor
02:36:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:36:42 <kamatsu> :t ceil
02:36:43 <lambdabot> Not in scope: `ceil'
02:36:45 <kamatsu> er
02:36:47 <kamatsu> :t ceiling
02:36:48 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:36:57 <kamatsu> floor rounds down, ceiling rounds up
02:36:58 <carpi> im going thru a haskell guide and in it the author mentions the use of Text.ParserCombinators.Parsec..but i don't find the Parsec module in GHC?
02:37:03 <haskell_newbie> any one please
02:37:11 <carpi> the Text.ParserCombinators is available though
02:37:24 <kamatsu> which guide?
02:37:44 <kamatsu> that is an old binding
02:37:50 <kamatsu> er, API
02:37:54 <carpi> hitch hikers guide to haskell )
02:38:25 <kamatsu> never heard of it, but that import is old
02:38:54 <kamatsu> this is the latest parsec
02:38:56 <kamatsu> http://hackage.haskell.org/package/parsec-3.1.2
02:38:59 <Saizan> carpi: parsec doesn't come with ghc, you've to install it separately
02:39:11 <kamatsu> it used to come with GHC, afair
02:39:17 <kamatsu> but GHC has been slimmed down lately
02:40:15 <Saizan> it used to a lot of major versions ago :)
02:40:35 <fcul> kamatsu: I've tried floor, but probably not very well
02:40:38 <fcul> aux :: Float -> Int
02:40:51 <fcul> aux a b = floor(a*50,b)
02:41:08 <kamatsu> type signatures are wrong
02:41:12 <kamatsu> aux takes two arguments
02:41:20 <fcul> aux :: Float->float->Int ?
02:41:21 <kamatsu> but type signature just says Float -> Int
02:41:26 <kamatsu> oh
02:41:32 <kamatsu> well, the way you call floor is incorrect
02:41:37 <kamatsu> floor :: Float -> Int
02:41:47 <kamatsu> you're calling it as though it's (Float, Float) -> Int
02:41:58 <kamatsu> are you following any Haskell tutorials? There are many we can suggest
02:42:18 <fcul> then i should use: floor (a,b) ?
02:42:25 <carpi> kamatsu: suggestions please? )
02:42:28 <MostAwesomeDude> fcul: Well, what do you expect your function to do?
02:42:32 <kamatsu> floor doesn't take a tuple
02:42:39 <kamatsu> floor takes a single number
02:42:50 <MostAwesomeDude> fcul: What are a and b, and what do you want the function to do with them?
02:42:56 <kamatsu> carpl, depends -- do you have experience with imperative programming?
02:42:59 <luite>  maybe you want min?
02:43:26 <carpi> kamatsu: a little bit yes
02:43:43 <fcul> MostAwesomeDude: Given float a, I need to multiply by 50 (a*50) and get the integer value
02:43:53 <MostAwesomeDude> fcul: Then you don't really need b, do you?
02:43:54 <kamatsu> Real World Haskell is a good book (available for free reading online) which assumes knowledge of imperative programming
02:44:12 <MostAwesomeDude> fcul: aux a = floor (a * 50)
02:44:15 <kamatsu> fcul this is not like prolog where results are passed in as arguments to function
02:44:29 <carpi> any resources that walk through building a usable application?
02:44:45 <kamatsu> Real World Haskell is probably your best bet then
02:44:48 <fcul> MostAwesomeDude && kamatsu: Thank you =)
02:44:49 <dschoepe> carpi: RWH has many real-world examples and case-studies
02:45:07 <MostAwesomeDude> fcul: Sure.
02:45:13 <kamatsu> there's a lambdabot command to give a RWH link
02:45:15 <kamatsu> i forgot it
02:45:33 <kamatsu> er... maybe
02:45:35 <dschoepe> @where rwh
02:45:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:45:44 <kamatsu> just about to type that ><
02:45:57 <jessopher> are there any resources that try to simulate real world situations, in which a haskell programmer might find themselves?
02:46:13 <VHD> real world haskell?
02:46:20 * jessopher smacks head
02:48:03 <fcul> MostAwesomeDude && kamatsu: Thank you =)
02:48:18 <MostAwesomeDude> Sure.
02:48:26 <fcul> MostAwesomeDude && kamatsu: Thank you =)
02:49:16 <kamatsu> Yup, no probs
02:49:18 <kamatsu> :/
02:51:24 <carpi> okay.. somone here on #haskell mentioned all functions are pure.. even ones that evaluate to values of type "IO a"..
02:51:55 <carpi> "If a function has side effects, we can tell by reading its type signature: the type of the function's result will begin with IO" <- From RWH
02:52:12 <shachaf> carpi: RWH is being vague there.
02:52:28 <shachaf> A function returns a value of type IO foo; that value contains side effects.
02:52:50 <shachaf> Evaluating the function won't cause those effects to "happen"; only executing the value will.
02:54:19 <carpi> hmm.. makes sense.. but still its a very very fine line.. )
02:55:38 <jessopher> its a matter of context. In one context it makes sense to be vague, like RWH is, and in this context... explaining function purity, it does not
02:55:57 <shachaf> carpi: It's a significant difference, but the language used can sometimes be vague.
03:03:58 <Renze> Hi!
03:04:37 <Axman6> 'lo
03:04:52 <Renze> How can I profile per function from other libraries? I now only see how long my own defined functions take, but I want to see how long the other functions take.
03:05:27 <fcul> One Question: I have [Char] and need to change the N'th element of the said list to 'O', then Outputting to IO()
03:05:56 <Saizan> also remember that at the time of RWH you still had IO often explained as State RealWorld
03:07:32 <ahax> Renze: you have to install them with profiling option
03:07:40 <danr> Saizan: and what is the current practice of explaining it?
03:07:40 <Renze> I did
03:07:52 <ahax> don't know then :/
03:08:27 <opqdonut> Renze: you're using -prof -auto-all?
03:08:36 <Renze> opqdonut: yes
03:08:44 <Saizan> you've to compile the lib with -auto-all too
03:08:46 <opqdonut> hmm, works for me
03:09:07 <opqdonut> Saizan: he said he has profiling libs installed
03:09:33 <Saizan> opqdonut: --enable-library-profiling only uses -prof, not -auto-all
03:09:42 <Renze> The profiling options in my cabal config file are both on True
03:09:58 <Renze> library-profiling and executable-profiling
03:10:01 <Renze> Is that not enough?
03:10:41 <Saizan> danr: with IO a being a recipe/script describing the side-effects which gets run by the runtime system
03:11:03 <danr> Saizan: aha
03:11:05 <danr> thanks
03:11:06 <YuleAthas> When compiling my program (via cabal), I am told that some module cannot be found.   The problem seems to be that the module is define in a .hsc file, not a .hs file.  How can I fix this?
03:11:17 <Saizan> Renze: nope, if you want cost centres in the libs you've to compile them with -auto-all (or add them manually)
03:11:34 <Renze> Saizan: waht do you mean with add them manually?
03:12:05 <Saizan> Renze: there's a pragma you can put in the code which adds cost centres
03:12:38 <Saizan> well, it adds a cost centre for that particular expression where the pragma appears
03:12:51 <Saizan> but you most likely want -auto-all
03:12:53 <Renze> Ok, thanks, I'll recompile them with auto-all then, now going to eat!
03:14:19 <Saizan> danr: *with something of type IO a being ..., i meant
03:15:09 <carpi> how can i write a 3 line function in ghci? i keep getting the (possibly incorrect indentation) error even though i've indented properly
03:17:14 <ahax> carpi: you can spilt it into subfunctions
03:17:57 <carpi> ah got it.. theres a doc at haskell.org)
03:23:43 <Saizan> you've to use let and ;
03:25:59 <kissyboy> you can also use :{ and :} i guess
03:45:30 <free__> I need help brothers How I convert a given position in a list by a character
03:46:53 <osfameron> free__: what are you trying to do exactly?  how far have you got?  (try pasting your code to the hpaste url in the /topic ?)
03:48:54 <free__> I'tryng to do this... I have a List of Characters: .................... and I want change for example the position 10 by a 'O'
03:49:45 <Botje> free__: look at the splitAt function then
03:50:15 <free__> ok I'll see that then
03:53:22 <osfameron> oddly, the prelude doesn't have an updateAt for lists defined
03:55:40 <shachaf> osfameron: Well, you're not really supposed to do indexing on lists.
03:57:13 <osfameron> shachaf: that was my guess yeah - presumably for text you're supposed to use bytestrings the moment you need to do any kind of manipulation?
03:57:30 <shachaf> Not that ByteStrings are going to be great for that sort of operation either.
04:04:14 * hackagebot http-proxy 0.0 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0 (ErikDeCastroLopo)
04:04:40 <Saizan> Text doesn't have it either
04:04:43 <relation> hi guys, i'm using the fgl graph library.. i have a problem with with LNode (labeled node), is it somehow possible for LNode to have more than just one type? like graph with Int and Double nodes.. or some kind of workaround? thanks
04:05:16 <Saizan> use Either Int Double
04:06:00 <relation> and in general, if it should have more types? is there any less "manual" solution?
04:06:53 <relation> but thanks for idea
04:11:42 <Saizan> you can scale data T = I Int | D Double | ... to arbitrary many types
04:15:26 <relation> Saizan: ok, thanks, i'll think about it
04:22:02 <k0ral> I can't see the panel library from hscurses; did I miss something ?
04:22:33 <k0ral> hscurses is said to be a complete binding for ncurses, I'm quite surprised it wouldn't include the panel library
04:24:51 <keep_learning> Hello all
04:25:24 <keep_learning> could some one suggest me some literature and paper for parallel programming in haskell.
04:26:19 <fryguybob> http://www.haskell.org/haskellwiki/Parallel  could be a starting point.
04:26:21 <dblhelix> keep_learning: "A Tutorial on Parallel and Concurrent Programming in Haskell" http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf
04:27:14 <keep_learning> dblhelix: thank you
04:27:22 <dblhelix> keep_learning: yw
04:31:15 <keep_learning> fryguybob: Thank you for the link. I was looking for parallel strategy.
04:34:27 <mreh> how could I simulate a terminal history with haskell IO?
04:34:59 <Botje> keep a list?
04:35:22 <Botje> in eg. an IORef
04:35:43 <mreh> Botje: of course, i was thinking more of how do I rewrite the current line, and filter out special characters, like up and down
04:35:51 <mreh> from stdin
04:36:23 <Botje> ah
04:36:25 <fryguybob> @hackage haskeline
04:36:26 <lambdabot> http://hackage.haskell.org/package/haskeline
04:36:38 <Botje> I would use readline or a BSD equivalent for that
04:41:17 <mreh> in haskeline, he's got two different instances of MonadReader for his InputT, wouldn't the compiler bleat at that?
04:42:20 <mreh> because the fundeps don't allow it
04:43:06 <rostayob> mreh: he's got UndecidableInstances on?
04:43:16 <rostayob> or something like that
04:43:31 <rostayob> or OverlappingInstances
04:43:37 <fryguybob> mreh: The cabal file shows many *Instances on.
04:43:46 <rostayob> or both probably
04:43:48 <rostayob> ehe
04:44:24 * fryguybob does not know which one does what, just does what GHC tells him.
04:46:29 <mreh> oh, i didn't realise you could specify them in the cabal file
04:46:49 <mreh> i wouldn't if I were him
04:47:08 <adamCS> hey guys... what's the shortest way to generate the list of fibonacci  numbers? [O(n)]
04:47:52 <adamCS> I want to see is my lecturers version the shortest you can do
04:47:59 <Botje> probably one of the fix (scanl ...) variants.
04:48:03 <mreh> this sounds like homework...
04:48:05 <Botje> although the plain recursive version is also nice and short.
04:48:36 <Botje> fib a b = (b+a) : fib b (a+b)
04:49:56 <huangyi> I think this is O(n) too:  fibs = 1 : 2 : zipWith (+) fibs (tail fibs)
04:50:12 <adamCS> his version was: fibo = 0:1:zipWith (+) fibo (tail fibo)
04:50:14 <kissyboy> fibs = 0:scanl (+) 1 fibs
04:50:19 <adamCS> huangyi: exactly
04:50:24 <shachaf> > fix((1:).scanl(+)1)
04:50:26 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:50:30 <adamCS> oh and WITHOUT a helper function
04:50:38 <shachaf> @quote fibonacci
04:50:39 <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
04:50:41 <shachaf> @quote fibonacci
04:50:42 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
04:50:44 <shachaf> @quote fibonacci
04:50:45 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
04:50:46 <shachaf> @quote fibonacci
04:50:46 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
04:51:02 <shachaf> preflex: zdec Safe_zdffibonaccizuhszuaM1_closure
04:51:02 <preflex>  Safe_$ffibonacci_hs_aM1_closure
04:51:15 <jamil_1> hi all, last 4-5 links on this link are broken: http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
04:51:39 <fryguybob> > extendSequence[1,1]
04:51:43 <lambdabot>   mueval-core: Time limit exceeded
04:51:58 <shachaf> @oeis 1,1
04:52:12 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
04:52:12 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:53:59 <mreh> suspects shachaf of being a warlock
05:03:04 <huangyi> I want to hack base package, is it possible to reinstall base package on an exist GHC installation?
05:12:18 <benmachine> @oeis 1,2
05:12:34 <lambdabot> Plugin `oeis' failed with: thread killed
05:12:40 <benmachine> @botsnack
05:12:41 <lambdabot> :)
05:12:45 <benmachine> hm
05:13:02 <shachaf> benmachine: You're training lambdabot to fail more often by doing that. :-(
05:13:23 <benmachine> @botsnack
05:13:24 <lambdabot> :)
05:13:25 * benmachine is reckless
05:19:15 * hackagebot sindre 0.1 - A programming language for simple GUIs  http://hackage.haskell.org/package/sindre-0.1 (TroelsHenriksen)
05:22:05 <lukish> @oeis 1,2,5
05:22:17 <lambdabot>  Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called...
05:22:17 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,3...
06:01:37 <robV5> My code loads/compiles without error, but when I run it I get a " *** Exception: user error (Pattern match failure in do expression at [filepath]\main.hs:8:3-10 ". I copied the hello world code from this tutorial http://projects.haskell.org/gtk2hs/docs/tutorial/glade/
06:02:13 <robV5> [filepath] is just the path to main.hs
06:02:25 <_oz> robV5: the call to xmlNew returns Nothing
06:02:40 <robV5> why would the tutorial do that then?
06:02:47 <robV5> :/
06:03:17 <_oz> sorry, I don't know
06:03:29 <_oz> what's "hellogtk2hs.glade" supposed to be/
06:03:30 <Botje> robV5: did you also download that .glade file?
06:03:31 <_oz> ?
06:03:40 <_oz> maybe it can't find that file?
06:03:48 <Botje> I can imagine xmlNew returns Nothing if it can't find the file.
06:03:53 <robV5> Botje, no, I followed the tutorial to make it, to the T.
06:04:11 <robV5> actually it is throwing a warning that the file cannot be found.
06:04:19 <Botje> well, that's probably it.
06:04:24 <Botje> make sure you typed the name of the file correctly
06:04:36 <robV5> hmm ok, but even with the full path it still gives me this error
06:04:47 <robV5> and the filename is correct for sure.
06:04:49 <Botje> that it can't be found?
06:04:57 <robV5> yeah
06:05:01 <Botje> robV5: can you open ghci?
06:05:03 <Botje> and enter something like
06:05:15 <robV5> yes gchi is open
06:05:19 <Botje> readFile "hellogtk2hs.glade"
06:05:20 <robV5> ghci*
06:06:09 <robV5> No such file or directory. Main.hs is in the same folder as the .glade file btw.
06:06:18 <robV5> main.hs*
06:06:33 <erus`> im on windows, they are the same file
06:07:11 <Botje> robV5: did you start ghci from there as well?
06:07:35 <robV5> no, I start ghci from shortcut and then :l file in
06:07:35 <Botje> by default haskell will look in the current directory, which might not be the same as where the .hs file is
06:07:41 <robV5> ah ok
06:07:50 <Botje> robV5: but giving the full path should work.
06:07:54 <robV5> :/
06:07:59 <Botje> robV5: can you readFile with the full path?
06:08:11 <Botje> and please also paste the command you gave to ghci
06:09:41 <robV5> Botje, with the full path name used with readFile, I think it has found it. Complained about lexical error though.
06:09:55 <Botje> robV5: can you copypaste the exact command you gave?
06:10:24 <Botje> I think you're confusing GHCi with backslashes where it expects slashes
06:10:29 <benmachine> yeah
06:10:34 <robV5> readFile "D:\Project\GladePractice\hellogtk2hs\hellogtk2hs.glade"
06:10:38 <Botje> yeah.
06:10:47 <Botje> either change that to D:/Project/GladePractice/...
06:10:50 <benmachine> robV5: in a string, \x means a special character
06:10:51 <Botje> or use double backslashes
06:10:54 <benmachine> e.g. \n is newline
06:11:16 <robV5> oh yeah in ghci that is what I used it worked.
06:11:28 <robV5> I have tried double slash in the main.hs though
06:11:59 <robV5> I will try again just to make sure incase I made an error before.
06:12:19 <Botje> robV5: you could also import the relevant modules and try the xmlNew command yourself.
06:12:27 <Botje> maybe there is an error in the .glade file somehow
06:13:04 <jessopher> when using liftIO with CGIT from Network.CGI, where does data written to stdout go?
06:13:24 <benmachine> jessopher: to stdout, presumably
06:13:35 <benmachine> jessopher: for a CGI app, this means it ends up in the content of your page
06:13:48 <mreh> preflex: seen lemmih
06:13:49 <preflex>  lemmih was last seen on #haskell 18 hours, 4 minutes and 11 seconds ago, saying: keep_learning: I keep running it, nothing bad happens.
06:14:23 <jessopher> benmachine: thats what i would expect, but that doesnt seem to be happening, possibly an issue with the server and not network.CGI
06:16:19 <jessopher> @hoogle IO a -> IO String
06:16:20 <lambdabot> System.IO hGetContents :: Handle -> IO String
06:16:20 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
06:16:20 <lambdabot> System.IO hGetLine :: Handle -> IO String
06:18:16 <_oz> jessopher: tell me a "a -> String" and I'll give you a "IO a -> IO String" :)
06:18:42 <robV5> seems to work fine when I load it with winGhci, so I think its a problem with relative path as you talked about earlier.
06:18:57 <robV5> still giving me an error, but its a different error now.
06:19:21 <jessopher> _oz: well im looking for something that would 'run' the IO computation, discard its result, and return what was written to stdout
06:19:35 <_oz> hmm, i see.
06:20:07 <jessopher> or something similar... discarding the result isnt mandatory
06:20:10 <quicksilver> jessopher: I don't think so, no, although that would be nice
06:20:21 <quicksilver> jessopher: we don't have a proper way to create "virtual handles"
06:20:29 * jessopher nods
06:20:43 <quicksilver> a hack using dup to preserve stdout and then opening it to a temp file might be doable
06:20:51 <quicksilver> but a proper way to create non-file-backed Handles would be much nicer.
06:21:10 <shachaf> I think there's something on Hackage which does this.
06:21:14 <shachaf> I can't recall its name, though.
06:21:24 <jessopher> yeah, i think there is a simpler solution, i just cant see the forest for the trees right now
06:22:00 <mreh> can I have two separate processes (i.e. do not share memory) synced to the same acid-state database
06:22:01 <applicative> http://hackage.haskell.org/package/io-capture ?
06:22:52 <jessopher> applicative: that looks promising, thanks
06:24:20 <quicksilver> it does roughly what I suggested
06:24:25 <applicative> oh wait, maybe this is the one shachaf and I were thinking of? http://hackage.haskell.org/package/silently
06:24:32 <quicksilver> but it uses pipes instead of a temp file (duh)
06:24:47 <wereHamster> mreh: use the db as the sync mechanism
06:24:50 <quicksilver> however, be aware that forkProcess isn't strictly safe with -threaded before ghc 7.4
06:24:52 <applicative> right
06:25:06 <mreh> answered my own question
06:25:06 <quicksilver> although I think it's one of those things which works quite often if you're lucky :)
06:25:08 <mreh> wereHamster: oh
06:25:16 * shachaf notes that the latest version of GHC is 7.3.2011*. :-)
06:25:34 <mreh> "Using Data.Acid.Remote you can create a UnixSocket and one process can communicate with another though a ‘file’ on the file system. Check out examples/Proxy.hs in the darcs source for acid-state"
06:25:52 <quicksilver> silently doesn't fork
06:26:41 <applicative> a little hackish as you said
06:26:42 <jessopher> this touches on another requirement... it cant blow up my server
06:27:04 <jessopher> but i may beable to ignore that for a while
06:27:08 <quicksilver> jessopher: silently is exception-safe
06:27:15 <quicksilver> but for other kinds of breakage
06:27:18 <quicksilver> like memory exhaustion
06:27:26 <quicksilver> you need to look at a separate process solution like mueval
06:27:40 <mreh> i just had an acid-state data corruption :X
06:27:41 <quicksilver> GHC's RTS isn't clever enough to sandbox individual actions/threads
06:27:54 <mreh> i think lemmih will be ineterested in this, but I just blew away the corrupted data
06:28:14 <mreh> "Failed reading: Internal error: unexpected end of input"
06:28:21 <mreh> cleaning out my state dir fixed this
06:29:04 <mreh> doesn't rule out OS errors
06:29:52 <jessopher> yeah, im trying to implement a 'safe' cgi interface for my interpreter, but i might have to worry about satisfying 'safe' after i satisfy 'cgi interface'
06:31:33 <quicksilver> jessopher: currently for save you will need to fork a separate process and use rlimits.
06:31:45 <quicksilver> memory exhaustion is the killer, really.
06:31:53 <quicksilver> s/save/safe/;
06:31:58 <cwl> unsupported extension DriveGeneric haskell
06:32:12 <quicksilver> maybe monday the GHC RTS will be able to complete jail a thread/action
06:33:34 <quicksilver> the safe/trusted haskell stuff is clever but as far as I know doesn't cover resource limits.
06:34:18 <luite> and it's not useful if you allow arbitrary IO
06:34:22 <cwl> 22:56 < quicksilver> s/save/safe/;
06:34:30 <luite> dunno if you want to do that :)
06:35:37 <jessopher> the language doesnt really have a broad concept of IO anyhow at the moment, and the subset exposed to the CGI interface is even more narrow, so its not completely arbitrary
06:35:47 <quicksilver> luite: well, safe/trusted haskell *does* give you a way to limit the IO with the type system.
06:36:08 <quicksilver> luite: if you require the script has type MyMonad (), and safe tells you there can't be any IO backdoors
06:36:11 <quicksilver> that's rather the point of safe, isn't it?
06:36:21 <quicksilver> it allows you to trust the type.
06:36:44 <luite> yeah that's true, but if your script has MyMonadT IO (), then trust isn't that useful anymore :)
06:37:02 <quicksilver> right
06:37:39 * applicative give today's 'now any moron can write superfast Haskell' award to  'unordered-containers'
06:38:13 <luite> I personally don't use safe haskell and just use operating system limits
06:39:34 <jessopher> i just cross my fingers and close my eyes
06:39:57 <luite> something like that :)
06:40:12 <dmwit> psh, lightweights
06:40:53 <dmwit> I implement an interpreter + runtime analysis at the type level, then any code that passes the type-checker will stay within resource bounds.
06:41:28 <sipa> your name is oleg?
06:41:28 <Eduard_Munteanu> Types... runtime... types... runtime... something's odd :P
06:41:42 <dmwit> running-time, if you prefer
06:41:52 <carpi> what is the differnece between a normal data type and an algebric data type?
06:42:12 <dmwit> Moreover, by the time the thing typechecks, it has the answer in O(1) time by looking at the class dictionary it constructed during type inference. ;-)
06:42:22 <quicksilver> "algebraic" is used for sum+product types like data Foo = Bar Int String | Baz Double Double
06:42:27 <quicksilver> ^^ carpi
06:42:37 <lcf> hey peeps. I have a question regarding orphanRemoval=true. It works if I unset an element in a collection. Would it work if I reset the whole collection to an empty one (to remove ALL entities in the collection)
06:42:43 <dmwit> carpi: In Haskell, normal data types are all algebraic.
06:42:50 <lcf> ok sorry wrong channel
06:42:54 <Eduard_Munteanu> quicksilver: isn't 'data' algebraic in any case?
06:43:00 <Eduard_Munteanu> Data declarations I mean.
06:43:20 <Eduard_Munteanu> And yeah, what dmwit says.
06:43:38 <carpi> but what does it mean for a type to be algebric?
06:43:53 <carpi> does it have some special features?
06:44:04 <carpi> ..say compared to data types that you might find in other languages?
06:44:06 <Eduard_Munteanu> carpi: you can write the datatype using some algebraic notation
06:44:14 <quicksilver> well I'd say that (->) is not algebraic
06:44:23 <dmwit> An "algebra" is a term language; it has some constants, and each constant has an arity.
06:44:32 <quicksilver> but I'm not sure the terminology is used consistently.
06:44:41 <dmwit> A term in the language saturates each constant.
06:44:41 <Eduard_Munteanu> quicksilver: a -> b  ~   b^a  ?
06:44:44 <Sgeo|web> I'm in a C# class right now, going over threading, and we're having a tricky time passing in parameters to a thread
06:44:54 <Sgeo|web> I can't help but think how ... trivial it is in Haskell
06:45:12 <dmwit> You can enrich the idea slightly by giving each constant a sort as well as an arity, and type-checking that each term is well-sorted.
06:45:15 <dmwit> This is what Haskell does.
06:45:23 <quicksilver> Eduard_Munteanu: indeed, but it's still not an algebraic type in the sense I use the phrase.
06:45:25 <carpi> arity?
06:45:27 <quicksilver> Eduard_Munteanu: it's possible I'm wrong.
06:45:34 <dmwit> carpi: "number of arguments"
06:45:43 <quicksilver> Eduard_Munteanu: random googling brings up other people who agree with me but they could all be wrong too :)
06:45:49 <Eduard_Munteanu> carpi: consider    data List a = Nil | Cons a (List a). You can say 'List a' is 1 + a * List a
06:46:03 <Eduard_Munteanu> Heh.
06:46:41 <dmwit> carpi: For example, here's an algebra: "a", "b", and "c" are constants; "a" and "b" have arity 0, and "c" has arity 1. Then terms look like "c c c c c c a" or "c c c b" -- a string of "c"s followed by either an "a" or a "b".
06:46:43 <carpi> ah.. so in essence algebric data types allow you to specify relationships between the values in that type?.. or something similar?
06:46:48 <Eduard_Munteanu> carpi: this sort of stuff can be useful in various context, for example obtaining zippers by differentiation.
06:47:12 <dmwit> carpi: A more interesting algebra is this one: "node" and "leaf" are constants; "node" has arity 2 and "leaf" has arity 0. Guess what terms look like? =)
06:47:56 <quicksilver> Eduard_Munteanu: foldoc is with me, for example : http://foldoc.org/algebraic+data+type
06:48:00 <carpi> could you please tell me what you mean "by terms"?
06:48:01 <dmwit> Usually, an algebra also provides for "variables" -- terms with arity 0 which are not constants (and which can be substituted by different terms later, if you like).
06:48:19 <carpi> ah okay.. the individual fields i suppose
06:48:23 <Eduard_Munteanu> carpi: it's more of a convention... A + B means that thing is either an A or a B, similar to logic notation
06:48:28 <dmwit> carpi: Yes. term ::= constant | variable | term term
06:48:49 <simon> carpi, they're algebraic because you can define an algebra for them.
06:49:03 * dmwit feels as though he is making a hash of it
06:49:12 <dmwit> Maybe we should just point you at the wikipedia page for "algebra". =P
06:49:20 <Eduard_Munteanu> quicksilver: oh, I see what you mean.... I was thinking of   data Foo = A (Bar -> Baz) | B Bar
06:49:36 <simon> even better: http://en.wikipedia.org/wiki/Algebraic_data_type#Explanation
06:50:03 <quicksilver> I don't think algebraic data types are general algebras.
06:50:07 <Eduard_Munteanu> Sure, I don't mean you can have something else besides '|' and ' ' (sum and product)
06:50:17 <quicksilver> I think that, by convention, they're the specific simple algebra of sum + product
06:50:25 <quicksilver> and, sometimes, with recursion, depending who you ask.
06:50:45 <carpi> thnks for link. going thru it right now )
06:51:42 <simon> carpi, I think it might not be a completely sufficient explanation.
06:52:33 <copumpkin> algebra is the most overloaded term ever
06:53:07 <copumpkin> but I thought algebraic in ADTs meant that you get roughly a semiring of types (with isomorphism)
06:53:23 <jessopher> my personal understanding of algebra is 'something with a formal language'
06:53:35 <jessopher> or that formal language
06:54:00 <jessopher> or some vague thing related to it
06:54:22 <copumpkin> haven't heard of that one :)
06:54:44 <simon> carpi, you can take the mathematical definition of an algebra and somewhat fit it onto algebraic datatypes where all possible values within a type belongs to a set...
06:55:05 <copumpkin> jessopher: people often use calculus that way though
06:55:20 <copumpkin> simon: there are half a dozen definitions of algebra in math
06:55:58 <copumpkin> another view of them could be that they're (often assumed to be) data, so initial algebras in category theory
06:56:05 <simon> copumpkin, yes. I was thinking of the one with a vector space and multiplication and some properties.
06:56:16 <copumpkin> simon: where would the vector space arise from?
06:56:21 <copumpkin> the best I can see on there is a semiring
06:56:43 <simon> copumpkin, yeah, I can't really defend it. =)
06:57:23 <copumpkin> :)
06:57:53 <copumpkin> anyway, gonna go to work
06:57:54 <copumpkin> bbiab
06:58:11 * Sgeo|web ignores what his professor is doing and makes a lambda with no arguments
06:59:18 <carpi> it seems like one of the reasons haskell is very good for writing other languages and manipulating syntax trees is because of these algebric data types..
06:59:35 <simon> Sgeo|web, a lambda with no arguments? why not a lambda with one argument that is thrown away?
06:59:42 <simon> Sgeo|web, how will you apply a function with no arguments?
06:59:55 <simon> Sgeo|web, I mean, notationally.
07:00:03 <Sgeo|web> simon: I'm in C#, not Haskell
07:00:13 <kallisti> Sgeo|web: a lambdabot with no arguments is an expression.
07:00:16 <simon> Sgeo|web, I'm in #haskell, not C#. ;-)
07:00:27 <kallisti> Sgeo|web: oh
07:00:35 <robV5> wow, finnaly got it to work. The gtk2hs hello gtk2hs is a very bad tutorial. :(
07:00:40 <simon> Sgeo|web, can C# support lambdas with no arguments? I thought the syntax was x => ...
07:00:51 <FUZxxl> kallisti: s/lambdabot/lambda
07:01:00 <simon> Sgeo|web, can you do (=>42)()?
07:01:09 <Sgeo|web> simon: () => whatever
07:01:23 <kallisti> FUZxxl: oh... yes. today is going to be a good day.
07:01:50 <simon> Sgeo|web, exactly what is () in C#; a zero-tuple?
07:01:57 <relation> hi, if i have data A = A; data B = B; is it possible to have some kind of traversable container which is full of As and Bs? thanks
07:02:09 <shachaf> simon: No, it's an empty argument list (I assume).
07:02:18 <simon> relation, no, you need a union.
07:02:27 <shachaf> relation: There are a few ways to do it. You can use Either A B, for example.
07:02:44 <shachaf> relation: You can also use existential types and a bunch of other things, but it depends on what you actually want to do.
07:02:52 <shachaf> relation: What do you actually want to do?
07:04:02 <relation> shachaf: i've defined type class of algorithm, and the algorithm can vary in specific but bounded constraints, i've implemented it's internal data using associated data type
07:05:38 <syri> Is (read . show) supposed to be equal to id?
07:05:58 <relation> shachaf: but now i want to run these algorithms in parallel and the function which actually runs them uses the associated data type to see what instance to run
07:06:11 <Clint> certainly not if the instances aren't there
07:06:57 <syri> Is it true for some instances and false for others?
07:07:20 <relation> shachaf: and if i want to run more of them, i need some kind of creation of different such data types to pass it into the function, which will run it
07:07:31 <kallisti> > read . show $ x + x
07:07:33 <lambdabot>   *Exception: Prelude.read: no parse
07:08:09 <byorgey> syri: it is intended to be, yes.
07:09:59 <shachaf> kallisti: There's no instance Read Expr.
07:10:02 <syri> I found that it is not for ByteString.
07:11:17 <jessopher> capri: what you were saying about adt's and language implementation, i think thats pretty accurate. HOFs also make parse implementation a lot easier too
07:11:43 <jessopher> s/parse/parser/
07:13:19 <kallisti> > read . show $ x + x :: Expr
07:13:20 <lambdabot>   No instance for (GHC.Read.Read SimpleReflect.Expr)
07:13:20 <lambdabot>    arising from a use of...
07:13:25 <kallisti> shachaf: indeed not
07:13:43 <dmwit> syri: For example?
07:14:16 * hackagebot happstack-server 6.4.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.4.3 (JeremyShaw)
07:14:26 <kallisti> > read . show $ dVar 5  :: Dif Int
07:14:28 <lambdabot>   *Exception: Prelude.read: no parse
07:15:37 <syri>  (read . show . B.pack $ "1")::Int
07:16:16 <syri> *** Exception: Prelude.read: no parse
07:16:21 <dmwit> (read . show) :: ByteString -> Int can't be the identity.
07:16:27 <dmwit> It doesn't even have the right type to be the identity.
07:16:36 <dmwit> But (read . show) :: ByteString -> ByteString is the identity.
07:17:04 <dmwit> Honestly, if a and b are not equal, (read . show) :: a -> b most probably is not going to succeed.
07:17:04 <syri> No, but it fails to parse into int the string "1" which ByteString show is supposed to produce
07:17:19 <dmwit> No, the ByteString produces the string "\"1\"".
07:17:47 <syri> So show . pack "1" is not equal to "1"
07:17:55 <dmwit> Correct.
07:18:10 <dmwit> show (pack "1") is equal to show "1", however. =)
07:18:19 <syri> I think, pack is equal to ByteString read
07:18:25 <dmwit> No, it is not.
07:18:30 <syri> Aaaa
07:19:06 <syri> I thought it produced the ByteString equvelent of a String
07:19:35 <dmwit> Both convert Strings to ByteStrings, but not in the same way.
07:19:51 <dmwit> pack drops all but the bottom few bits of every character; read actually does some parsing
07:21:08 <syri> I tried (read "1")::ByteString ing ghci but fails with an exception
07:21:30 <dmwit> Yes, "1" is not the result of show (pack "1"), as I've said at least three times now.
07:21:45 <kallisti> > read "\"1\""
07:21:46 <lambdabot>   *Exception: Prelude.read: no parse
07:21:48 <kallisti> > read "1"
07:21:48 <dmwit> "\"1\"" is the result of show (pack "1").
07:21:50 <lambdabot>   *Exception: Prelude.read: no parse
07:21:56 <dmwit> > read "\"1\"" :: ByteString
07:21:57 <lambdabot>   Not in scope: type constructor or class `ByteString'
07:22:14 <kallisti> dmwit: ah forgot the type. :P
07:22:44 <kallisti> :t BS.pack
07:22:46 <lambdabot> [Word8] -> BSC.ByteString
07:23:10 <dmwit> syri: The result of showing a ByteString is the String whose first character is a quote mark, then some things representing the contents of the ByteString, and whose last character is also a quote mark.
07:23:34 <dmwit> syri: The constant "1" in a Haskell source program represents a String whose first character is a '1', not a quote mark@!
07:24:25 <kallisti> syri: in other words show is not id for strings. When you show a string of any kind it includes quotations within the resultant string.
07:24:50 <syri> Thanks for the clarification
07:24:53 <dmwit> > read "\"1\"" :: BSC.ByteString
07:24:54 <lambdabot>   "1"
07:26:13 <dmwit> > map show "1"
07:26:14 <lambdabot>   ["'1'"]
07:27:20 <alistra> > shamwow "1"
07:27:22 <lambdabot>   can't find file: L.hs
07:27:28 <byorgey> with most other types (e.g. Int, Char) it is easy to get by conflating their *values* with their *concrete textual representations* as literals in Haskell source.
07:27:39 <alistra> > shamwow "1"
07:27:41 <lambdabot>   Not in scope: `shamwow'
07:27:48 <alistra> weird
07:27:58 <shachaf> > map show . show . map show $ "1"
07:28:00 <lambdabot>   ["'['","'\"'","'\\''","'1'","'\\''","'\"'","']'"]
07:28:03 <byorgey> but with String, such conflation is devastating.
07:28:21 <tromp> > fix show
07:28:23 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
07:28:25 <shachaf> Map show, eh? Cartographers conspiring again?
07:28:38 <dmwit> > fix (map show)
07:28:42 <lambdabot>   mueval-core: Time limit exceeded
07:28:50 <byorgey> > show map
07:28:50 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
07:28:51 <lambdabot>    arising...
07:28:58 <byorgey> awww
07:29:04 <dmwit> > look map
07:29:05 <lambdabot>   Not in scope: `look'
07:29:11 <alistra> @src map
07:29:12 <dmwit> It is very dark. You are likely to be eaten by a grue.
07:29:12 <lambdabot> map _ []     = []
07:29:12 <lambdabot> map f (x:xs) = f x : map f xs
07:29:22 <byorgey> It is a dusty old map with a large red X in one spot.
07:29:46 <shachaf> dmwit: I've probably mentioned something about Zork Zero in your presence before?
07:29:57 * dmwit shrugs uncertainly
07:30:13 <shachaf> "dmwit Flathead" and all that.
07:30:34 <dmwit> Holy crap, there are *nine* Zork games?
07:31:57 <tromp> > [i|(c,i)<-zip (fix show) [0..],c=='"']
07:32:02 <lambdabot>   mueval-core: Time limit exceeded
07:34:14 <shachaf> > [i|('"',i)<-zip (fix show) [0..]]
07:34:18 <lambdabot>   mueval-core: Time limit exceeded
07:35:36 <byorgey> @. oeis run take 10 [i|('"',i)<-zip (fix show) [0..]]
07:35:37 <lambdabot>  Sequence not found.
07:35:51 <dmwit> > take 10 [i|('"',i)<-zip (fix show) [0..]]
07:35:52 <lambdabot>   [0,2,6,14,30,62,126,254,510,1022]
07:35:59 <dmwit> ?oeis 0 2 6 14 30 62 126 254 510 1022
07:36:00 <lambdabot>  2^n - 2.
07:36:00 <lambdabot>  [1,0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,2...
07:36:11 <byorgey> guess it didn't like the brackets.
07:36:15 <dmwit> prolly
07:36:37 <byorgey> who writes things like that, anyway.
07:37:21 <shachaf> Shouldn't that be a -1?
07:38:15 <byorgey> shachaf: there's something about the main OEIS sequence data containing the absolute values of the terms.
07:38:18 <dmwit> It's a -1 on the website.
07:39:05 <byorgey> hmmm.... not sure.
07:47:33 <salisbury> does anyone have with Foreign.Ptr ?
07:47:45 <salisbury> experience with, rather
07:48:08 <shachaf> salisbury: I expect that the answer to that question is yes.
07:48:43 <shachaf> So you might as well ask your real question. :-)
07:49:34 <salisbury> shachaf: I'm trying to figure out how to get a blank pointer to say, Word32, but I can't find any resources on how to do so. Docs only go into usage once you have one
07:50:04 <shachaf> salisbury: mallocForeignPtr?
07:51:04 <salisbury> shachaf: hmm, I'm getting a 404 when I Hoogle for the docs.
07:51:29 <salisbury> shachaf: for mallocForeignPtr
07:51:34 <shachaf> @google mallocForeignPtr documentation
07:51:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/haskell2010-1.1.0.0/src/Foreign-ForeignPtr.html
07:51:35 <lambdabot> Title: Foreign/ForeignPtr.hs
07:52:06 <salisbury> well then
07:52:30 <salisbury> that lambdabot is a bag of surprises
07:52:36 <quicksilver> http://haskell.org/ghc/docs/7.2.1/html/libraries/base-4.4.0.0/Foreign-ForeignPtr-Safe.html
07:52:44 <quicksilver> is probably a better reference than the source.
07:53:04 <salisbury> nice, thanks
07:53:05 <shachaf> quicksilver: I usually find the source to be a better reference than the Haddock HTML.
07:53:10 <salisbury> both will come in handy I'm sure
07:53:13 <quicksilver> also other stuff beginning 'Foreign' at http://haskell.org/ghc/docs/7.2.1/html/libraries/base-4.4.0.0/index.html
07:53:22 <shachaf> quicksilver: It contains all the same documentation, and also implementations if you want to look at them.
07:53:29 <quicksilver> shachaf: we will have to differ on that point.
07:53:46 <shachaf> I wish there was, at least, some sort of hybrid.
07:53:53 <salisbury> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr.html
07:54:00 <salisbury> is that a 404 for anyone else?
07:54:02 <shachaf> For example, if the Haddock source highlighted HTML contains cross-references.
07:54:27 <shachaf> salisbury: Web servers don't usually discriminate by IP. :-)
07:54:38 <quicksilver> salisbury: yes, the URLs have changed recently.
07:54:45 <quicksilver> salisbury: the URLs I pasted work.
07:54:48 <shachaf> salisbury: Try http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr-Safe.html
07:54:53 <shachaf> Oh, quicksilver already pasted that.
07:55:47 <salisbury> as an aside, does anyone know of a Haskell community in the Ottawa/Toronto Canada area?
07:58:26 <shachaf> salisbury: Surely. There exist several people at UToronto and UWaterloo.
08:00:12 <salisbury> shachaf: I'll have to investigate next I'm there
08:00:40 <salisbury> shachaf: I'll enquire around the Unis in Ottawa as well
08:03:48 <saml> hey, how can I compile dataflow to efficient code?
08:10:24 <salisbury> saml: dataflow?
08:10:42 <saml> www.ece.umd.edu/DSPCAD/papers/bhat1994x3.pdf
08:11:08 <saml> this one.. it looks like dataflow is purely functional, massively parallel.... not sure why it isn't so popular
08:12:36 <salisbury> saml: I;m not entirely sure what I'm reading. I have no background in elec. eng
08:14:19 <salisbury> saml: or signals processing. It does look like something I was conceptualizing though
08:14:32 <salisbury> saml: this might prove to be very interesting, thanks for the link
08:15:01 <saml> no prob. there are some haskell projects that compile to FPGA. might be related
08:16:09 <Phantom_Hoover> I note that lambdabot has become a little more... presidential of late.
08:16:59 <morolin> saml: most dataflow-based systems make it somewhat difficult to work with anything approaching a complex data structure.
08:17:07 <Phantom_Hoover> @vixen I can't help but note a similarity to a certain former president of the US.
08:17:08 <lambdabot> I can take it. The tougher it gets, the cooler I get.
08:17:23 <carpi> when someone says "isomorphic" what are they referring to?
08:18:03 <Phantom_Hoover> carpi, isomorphism, duh.
08:18:05 <erus`> rubbish rpgs
08:18:06 <cheater> isomorphism.
08:18:09 <Clint> zing
08:18:15 <cheater> Phantom_Hoover: FIRST.
08:18:25 <saml> morolin, do you have proof of that? i'm interested.
08:18:35 <morolin> carpi: there exists a bijective map such that both it and its inverse are homomorphisms.
08:18:39 <Phantom_Hoover> saml, 'proof'.
08:18:46 <saml> i mean.. examples
08:18:53 <carpi> but what is isomorphism? the property of 2 data types to be functionally similar yet structurally different?
08:19:00 <Phantom_Hoover> morolin, what does homomorphism mean?
08:19:02 <morolin> saml: Not really proof, but experience.
08:19:10 <Phantom_Hoover> Oh, or were you talking about something specific.
08:19:21 <saml> isomorphism in type theory?
08:19:51 <morolin> Phantom_Hoover: homomorphism means that the mapping preserves structure
08:20:06 <saml> i think isomorphism is bijection?
08:20:49 <sipa> bijection only refers to the elements
08:20:52 <Phantom_Hoover> saml, doubtful.
08:20:59 <Eduard_Munteanu> carpi: if two things are isomorphic, in this context it means you can turn one into the other and back without loss of information.
08:21:02 <sipa> isomorphism also requires operations to remain consistent
08:21:12 <syri> I try to load a file in the interpreter from within emacs. The file depends on other modules that reside in the same directory. However, the interpreter fails to load the other modules. Is there an option in haskell-mode for this?
08:21:30 <Phantom_Hoover> You can biject nats and pairs of nats, but they shouldn't be isomorphic.
08:21:51 <dolio> Isomorphic in what category?
08:22:01 <dolio> They're isomorphic sets.
08:22:24 <Phantom_Hoover> I'm just talking about what you'd expect a notion of isomorphism of types to be like.
08:22:42 <carpi> Eduard_Munteanu: thanks.. that made sense.. In RWH, the author mentioned the haskell [] type and the user defined 'List' type as isomorphic.. and it left me wondering )
08:23:00 <saml> taht means they are "equivalent"
08:23:05 <saml> have 1-to-1 mapping
08:23:12 <Phantom_Hoover> That's just "you can rename type constructors".
08:23:28 <Eduard_Munteanu> And data constructors.
08:23:34 <Phantom_Hoover> Erm, right.
08:23:38 <quicksilver> in this context, types are normally considered as just sets
08:23:43 <saml> [1]  to   Cons 1 Empty
08:23:47 <quicksilver> so an isomorphism is just a bijection
08:23:47 <dolio> Types are rather like sets. There's not much structure to preserve.
08:24:11 <quicksilver> so I might say that Nat is isomorphic to [()]
08:24:18 <carpi> sometimes.. i really wonder why it is necessary to be purposefully cryptic. I mean.. the RWH author could have simply said "equivalent" and then mentioned 'equivalent' in terms of what?.. but instead he chose to say "isomorphic". Maybe in this context it was the right word to use. !
08:24:29 <dolio> Might want to say a pair of inverse functions.
08:24:37 <Phantom_Hoover> quicksilver, or indeed that Nat is isomorphic to [Nat].
08:24:48 <quicksilver> I don't think it's deliberately cryptic. It's just the word he is familiar with.
08:24:55 <Eduard_Munteanu> carpi: I presume the idea was to use established notations and jargon.
08:25:10 <dolio> Depending on how constructive you are, I don't think bijection is sufficient to provide for a pair of inverses.
08:25:15 <saml> carpi, it's not about being cryptic. to functional programmers, languages of OOP are so foreign.
08:25:21 <Eduard_Munteanu> "Equivalence" can be less specific.
08:25:30 <dolio> Maybe I'm wrong, though.
08:25:49 <dolio> Or, how computable you want to be.
08:26:41 <saml> don't get hang up on a word. keep reading/learning. and you will adapt
08:26:43 <Eduard_Munteanu> Constructive surjectiveness is kinda too strong.
08:27:19 <carpi> okay..so in this context isomorphic > eqivalent... ah fish.. nvm. isomorphic is isomorphic. Period
08:27:37 <carpi> i donno why im making a big deal out of this. shite
08:27:47 <saml> menopause.
08:28:45 <dolio> Actually, maybe it is okay.
08:29:18 <dolio> Probably depends on your definitions of bijections and whatnot.
08:31:31 <Eduard_Munteanu> I wonder if there's any way to prove surjection constructively without needing a (pseudo)-inverse.
08:38:20 <roconnor> Eduard_Munteanu: isn't the definition of surjection having a pseudo inverse?
08:39:17 * hackagebot cabal-debian 1.6 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.6 (DavidFox)
08:43:19 <Eduard_Munteanu> roconnor: yeah, but you don't need it explicitely.
08:43:34 <roconnor> Eduard_Munteanu: don't need it for what?
08:44:30 <Eduard_Munteanu> roconnor: I mean proving ∀ y, ∃ x such that f(x) = y  is different in the classical vs. constructive case
08:44:59 * roconnor reads back to try to get some context
08:45:19 <Eduard_Munteanu> Not much to read through, I wondered because I've previously heard others complain about that.
08:49:13 <Clint> is there a library that will produce equivalent output to `cal`?
08:49:22 <roconnor> Sure, you sould use the weak existential and get a weak notion of surjective I guess.
08:49:53 <roconnor> I don't know any applications of this, but it wouldn't suprise me too much if there are.
08:50:49 <Eduard_Munteanu> roconnor: hm, is there a definition for these weak existentials? I wonder if it's not equivalent to LEM or something like that.
08:54:28 <roconnor> Eduard_Munteanu: it is defined to be the double negation of a regular existential
08:54:41 <roconnor> ie the double negation translation of the classical existential
08:55:31 <xplat> > fix$(1:).scanl(+)1
08:55:34 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:56:01 <dolio> Okay, proved them equivalent.
08:56:20 <roconnor> xplat: fib starts with 0
08:56:28 <dolio> http://code.haskell.org/~dolio/agda-share/html/BijectiveIso.html
08:57:54 <roconnor> dolio: good
08:58:40 <Eduard_Munteanu> roconnor: ah so basically it results in a classical proof
09:00:17 <dolio> Not sure why I thought bijective was weaker. Maybe I'm thinking of category theory.
09:00:27 <dolio> Epi + mono /= iso.
09:01:06 <harrisonpartch> is bijection heterojection+homojection?
09:01:28 <mux> it's injection + surjection
09:01:39 <roconnor> Eduard_Munteanu: yes; after all, constructive logic is an extension of classical math.
09:01:53 <mkscrg> harrisonpartch: what are heterojection and homojection?
09:02:11 <harrisonpartch> it was a pun. perhaps you are familiar with that concept?
09:02:35 <mux> oh, d'oh
09:02:37 <harrisonpartch> if not please do not take offense or be alarmed
09:04:24 <Eduard_Munteanu> dolio: but iso -> epi+mono no?
09:04:40 <dolio> Yeah.
09:05:32 <dolio> Because you can just compose on the appropriate side with the inverse to cancel.
09:06:57 <dolio> Or, isomorphisms are both sections and retractions, and each of those implies one of epi and mono (can't recall which without working out the equations).
09:07:44 <mercury^> sections are monomorphisms, because they have a left inverse
09:08:06 * Eduard_Munteanu can't remember which of section and retraction are on the left :)
09:08:19 <mercury^> Epic sections are isomorphisms, also.
09:08:58 <Eduard_Munteanu> Hm, does that assume all epis split?
09:09:23 <mercury^> No.
09:18:55 <carpi> is it necessary that import statements must always be at the top? because when i place them at the point where im using functions from a module.. i get parse error
09:19:54 <byorgey> carpi: yes, it is.
09:23:04 <roconnor> carpi: I think the author is using "isomorphism" in this case because not only is there a bijection between [a] and (List a), but also the fmap operations for the two are the same.  You are lucky he didn't say "naturally isomorphic" meaning that the isomorphisms can be implemented with polymorphic functions. (And, in fact [a] and (List a) are naturally isomorphic).
09:23:46 <carpi> roconnor: bijection?
09:23:56 <carpi> you mean common features?
09:24:00 <keep_learning> :t foldl'
09:24:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:24:04 <keep_learning> :t foldl
09:24:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:24:10 <ski> carpi : you could qualify the use with the module name, if you want
09:24:18 <keep_learning> :t foldr'
09:24:19 <lambdabot> Not in scope: `foldr''
09:24:23 <keep_learning> :t foldr
09:24:23 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:25:30 <hpaste> Carpi pasted “Lambda Guards” at http://hpaste.org/54958
09:25:32 <carpi> is this even valid ^^^? GHCi spits a nice big fat error on my face..
09:25:34 <ski> dolio : from `r . s = id' it's easy to recall that `r' is the epi and `s' the mono
09:26:01 <roconnor> carpi: oh oops; I think I have confused you more than helped.
09:26:02 <ski> (assuming you have `r . s = id' memorized :)
09:26:04 <roconnor> plz ignore me.
09:27:28 <carpi> ski: you mean i could import modules in the middle if i qualify them?
09:31:40 <carpi> my bad.. seems like guards and lambdas don't play nice together
09:53:48 * jessopher wonders how much less expressive haskell would be if lambda expressions syntax just ceased to exist
09:54:46 <byorgey> jessopher: it depends what you mean by 'expressive'.
09:55:04 <byorgey> you would still be able to write exactly the same problems, just slightly less conveniently.
09:55:13 <byorgey> since you'd have to give every function a name.
09:55:25 <jessopher> well I rarely use them, so it probably shouldnt depend on my definition
09:55:25 <byorgey> s/problems/programs/
09:59:09 <Waldteufel> jessopher: since haskell has currying, i think most functions you would use lambda for deserve a name
10:00:39 <jessopher> Waldteufel: thats what I was thinking
10:02:43 <jessopher> i see a very small use case, where the specification is so simple that the where/let and the name double the amount of typing needed to express the function, but in most of those cases, that function is in the prelude anyhow :P
10:13:24 <eacameron> Looking at Real World Haskell, I see some code that looks like it could be easily refactored if type constructors could be passed around as first-order arguments. But I can't seem to find a way to do this. The code is here: http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html#library.jvalue    Look the code block after "A few more accessor functions,"
10:14:31 <ski> carpi : no, i mean you can qualify your uses, so you see more easily from which module an identifier comes from
10:15:21 <ski> Waldteufel : i don't see what currying has to do with it
10:15:34 <ski> Waldteufel : btw, consider code like
10:15:46 <ski>   forM_ xss $ \xs -> do
10:15:56 <ski>     forM_ xs $ \x -> do
10:15:59 <ski>     ..x..
10:16:04 <ski>     ...
10:16:44 <ski> Waldteufel : it would be irritating to have to name those lambdas -- when programming in common imperative languages, do you always label your loops ?
10:17:43 <YuleAthas> eacameron: I SYP (the Scrap Your Boilerplate thing) would be useful there.
10:17:47 <YuleAthas> Or maybe Template Haskell.
10:19:29 <eacameron> YuleAthas: Hmm...I've never used SYP. Isn't that a language extension?
10:19:49 <ski> Eduard_Munteanu : btw, one can imagine existentials intermediate between the double-negation one, and the usual constructive one
10:20:52 <YuleAthas> eacameron: yes.
10:20:56 <Eduard_Munteanu> ski: hrm, how?
10:20:58 <ski> Eduard_Munteanu : e.g. you can imagine an existential such that a proof of `exists x : A. P x' doesn't contain the witness `x', only the proof of `P x' (from which one in some cases may be able to recover `x', though)
10:22:05 <ski> Eduard_Munteanu : otoh, if you instead imagine an existential where a proof of `exists x : A. P x' *does* contain the witness `x', but doesn't contain the proof of `P x', then this is usually written like `{x : A | P x}' :)
10:22:33 <Eduard_Munteanu> ski: I see.. would this actually be the Haskell existential?
10:22:44 <byorgey> eacameron: you can pass data constructors as first-order arguments.  But you cannot use such passed constructors for pattern-matching.
10:23:22 <Eduard_Munteanu> ski: I wonder because I've seen "weak sums" thrown around, but I'm not sure exactly what they are.
10:23:25 <ski> Eduard_Munteanu : well, the existential quantifying a *type* `x', is in Haskell commonly implemented as the former, yes
10:23:26 <byorgey> eacameron: one way to automate those accessor functions is to use a library like fclabels.
10:24:21 <ski> Eduard_Munteanu : but types are a bit special in that you can't inspect them (like you can with inductive data types, e.g.)
10:24:34 <Eduard_Munteanu> Is there actually a weak sigma?
10:24:56 <shachaf> eacameron: Think about what the type of the function you want is.
10:25:36 <Eduard_Munteanu> ski: yeah, though I think I've heard dolio say something about Set eliminators being possible in some type theories
10:26:20 <ski> Eduard_Munteanu : anyway, another variant is to have the proof of `exists x : A. P x' actually contain `x', but you're not allowed to actually depend on *which* `x' is there, i.e. : assuming you unpack it with `k : (x : A) -> (p : P x) -> Q x p', then you have to prove that `k x0 = k x1' for all `x0,x1'
10:26:26 * Eduard_Munteanu isn't even sure they're problematic in usual TTs
10:27:48 <xplat> Eduard_Munteanu: well, they generally mean you've got a 'closed world' where all types are generated from a specific set of base types and type constructors
10:27:56 <ski> Eduard_Munteanu : i'm not very familiar with how "weak sums" exactly differ from other sums
10:27:58 <Eduard_Munteanu> ski: hrm... that sounds like 'unique exists', why?
10:28:13 <xplat> if that's okay, then a Set eliminator is okay
10:28:14 <ski> Eduard_Munteanu : no, it's now `exists unique'
10:28:19 <ski> s/now/not/
10:28:23 <Eduard_Munteanu> xplat: can't you just pattern-match on some set values and require a default match?
10:28:39 <Eduard_Munteanu> xplat: say   f Nat = ...   f _ = ...
10:28:46 <ski> Eduard_Munteanu : have you heard about Markov's Principle ?
10:29:10 <xplat> Eduard_Munteanu: perhaps you could, but that is not the sort of Set elimination that is typical in classical type theory
10:29:11 <Eduard_Munteanu> ski: uh, sounds vaguely familiar but I don't remember what it's about.
10:29:18 * hackagebot digestive-functors-happstack 0.1.1.2 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.1.2 (JasperVanDerJeugt)
10:29:30 * Eduard_Munteanu looks
10:29:52 <ski> Eduard_Munteanu : it's a dogma in Markov's Russian school of constructivism, based on primitive recursive functions
10:30:27 <harrisonpartch> why can't we question fido, pa?
10:30:29 <ski> Eduard_Munteanu : it states that `not (not (exists n : |N. a n = True)) -> exists n : |N. a n = True'
10:30:36 <harrisonpartch> cause he's a dog, ma!
10:30:52 <ski> Eduard_Munteanu : `a' being a stream of boolean, i.e. of type `|N -> Bool'
10:31:17 <Eduard_Munteanu> Ah, it basically follows from LEM.
10:31:38 <Eduard_Munteanu> (but presumably weaker than it)
10:32:04 <ski> Eduard_Munteanu : the (pseudo-)algorithm that Markovists use to implement this is : try each natural number until you find one that maps to `True', you're bound to find one eventually, since it's impossible not to find one
10:32:36 <ski> the problem is that in general there's no bound on how long we have to search
10:32:48 <Eduard_Munteanu> I see.
10:33:11 <ski> other constructivists regard this as an example of an omniscience principle
10:33:24 <ski> the most common omniscience principles are :
10:34:16 <ski> PO/[LP]EM (Principle of Omnicience / Law/Principle of Excluded Middle) : `forall A : Prop. A \/ not A'
10:34:22 <xplat> who is the world's most famous complexity theory blogger?
10:34:47 <xplat> right, scott aaronson
10:35:04 <xplat> anyway, he seems to believe in Markov's Principle
10:35:12 <ski> LPO (Limited Principle of Omnicience) : `forall a : |N -> Bool. (exists n : |N. a n = True) \/ (forall n : |N. a n = False)'
10:35:44 <nexion> what would be the Haskell equivalent of a system where users of a resource check out handles that allow them to access the resource (in my case, write to a TChan) and have some way to guarantee that no user exits/crashes without returning its handle?
10:35:45 <Eduard_Munteanu> ski: hm... the last one is the LEM form of the Markov principle?
10:36:01 <xplat> as evidenced by statements along the lines of 'what question could have a more definite answer than whether a given Turing machine does, or does not, halt?'
10:36:09 <nexion> or if this doesn't currently exist, is such a guarantee possible?
10:36:33 <ski> WLPO (Weak Limited Principle of Omnicience) : `forall a : |N -> Bool. not (not (exists n : |N. a n = True)) \/ (forall n : |N. a n = False)'
10:37:21 <xplat> actually you could go as far as to say he believes in LPO
10:38:29 <ski> LLPO (Lesser Limited Principle of Omnicience) : `forall a0,a1 : |N -> Bool. (unique n : |N. (a0 /\/ a1) n = True) -> (forall n : |N. a0 n = False) \/ (forall n : |N. a1 n = False)'
10:39:12 <ski> Eduard_Munteanu : yes, you could say so
10:39:30 <ski> (`a0 /\/ a1' is the interleaving of the two streams)
10:39:35 <dolio> What makes weak sums weak is a little debatable.
10:39:57 <dolio> It's either that the first component can't be (usefully) projected out, or that it only has the weak (non-dependent) elimination principle.
10:40:12 <ski> Eduard_Munteanu : anyway, the purpose of the omniscience principles is to know when to give up proving something, constructively :)
10:40:33 <dolio> Sometimes those coincide.
10:41:03 <ski> Eduard_Munteanu : if we can prove that a proposition implies an omniscience principle, then we don't believe that it's provable constructively
10:41:28 <ski> Eduard_Munteanu : anyway, i'm getting side-tracked from my point here :)
10:41:38 <Eduard_Munteanu> dolio: so I guess it doesn't just arise from a type theory like sigma (straightforwardly) does?
10:41:57 <Eduard_Munteanu> ski: hm, I see.
10:42:14 <ski> Eduard_Munteanu : consider the following variant of `(oblivious_exists n : |N. a n = True) -> (exists n : |N. a n = True)'
10:42:34 <dolio> You can make weak versions of any inductive type in the second sense.
10:42:47 <ski> Eduard_Munteanu : where `oblivious_exists x : A. P x' is the variant which i mentioned above where the proof doesn't contain the `x' witness
10:42:59 <dolio> And you can encode them all in the calculus of constructions.
10:43:12 <Eduard_Munteanu> dolio: since you end up with plain non-dependent pairs, you mean?
10:43:27 <dolio> No, I mean the elimination principle is non-dependent.
10:43:51 <dolio> forall R. ((x : A) -> B x -> R) -> Weak A B -> R
10:43:51 <ski> Eduard_Munteanu : my idea with this is that `oblivious_exists x : A. P x' should only have been provably if it was in fact possible to construct the `x', it's just that we're lazy and didn't do it (also that we want the remainder of the argument not to depend on which `x' was constructed)
10:44:10 <dolio> Instead of R : Weak A B -> Type or something.
10:45:07 <Eduard_Munteanu> ski: hm, but how do I interpret  `k x0 = k x1' for all `x0,x1'  ?
10:45:08 <dolio> The projection version of sums is strong, too, though.
10:45:12 <ski> Eduard_Munteanu : so, since it was in principle possible to construct the `n' such that `a n = True', we should be able to do induction on this (actually non-existent) `n', thereby bounding the search for the *least* `n' satisfying `a n = True'
10:46:21 <Eduard_Munteanu> dolio: but essentially the eliminator has to be built into the language, no?
10:46:37 <Eduard_Munteanu> Unlike Agda sigmas which can be defined inductively.
10:46:39 <dolio> It always does.
10:46:54 <dolio> In Agda, pattern matching takes the place of the eliminator.
10:47:08 <Eduard_Munteanu> Yeah.
10:47:09 <dolio> Martin-loef type theory is presented in terms of eliminators, though.
10:47:38 <Eduard_Munteanu> dolio: any idea what it'd take to make weak sums possible in Agda?
10:47:53 <ski> Eduard_Munteanu : well, that `k x0 = k x1' was for the other variant i mentioned. where we basically want to take a quotient on the usual `exists x : A. P x'
10:48:18 <dolio> If they extended their irrelevance stuff, it'd make weak sums possible.
10:48:26 <Eduard_Munteanu> ski: oh...  xs for which P is true and xs for which it's false?
10:49:05 <dolio> Because the eliminator would be: (.(x : A) -> (y : B x) -> P (x, y)) -> (p : Weak A B) -> P p
10:49:14 <ski> Eduard_Munteanu : namely, each element of this quotient type is represented by a value `(x,p)' where `x : A' and `p : P x', but to eliminate, we have to prove that we don't care which `x' we get (but we can still inspect it, if it's a value in an inductive type, say)
10:49:53 <dolio> However, P : Weak A B -> Set is isomorphic to P : .(x : A) -> B x -> Set, which is constrained to not look at its first argument.
10:50:10 <dolio> And the same with the function passed to the eliminator.
10:50:35 <dolio> So the first component of the pair is kind of hidden.
10:51:11 <Eduard_Munteanu> I guess I have to play a bit with the irrelevance stuff, I'm not yet sure what you can do with it.
10:51:34 <ski> Eduard_Munteanu : however, note that the variants i'm talking about is just ideas of my own (inspired by various things i've heard of), i don't know if there's any theory developed for them (well, maybe the "oblivious" one)
10:51:51 <dolio> In theory I guess that's still stronger, but only if you can do analysis on elements of B x without knowing what x is.
10:52:36 <Eduard_Munteanu> ski: I see, sounds reasonable though. BTW, do you blog about this sort of stuff? :)
10:52:40 <ski> Eduard_Munteanu : another thing to consider is e.g. the circle of complex numbers with absolute value one, let's call this `C'
10:53:30 <ski> Eduard_Munteanu : then we want `f : C -> C' defined by `f x = x^2' (which folds the circle over itself) to be surjective, in some sense
10:54:10 <ski> Eduard_Munteanu : the problem is that we *can* choose a square root for each element in `C', but we want do it *continuously* for the whole of `C'
10:55:02 * maltem sees people talk type theory, and listens carefully
10:55:18 <ski> Eduard_Munteanu : Paul Taylor, in his book "Practical Foundations of Mathematics" (available online) talks some of this
10:55:22 <Eduard_Munteanu> ski: +/- you mean?
10:55:29 <ski> sorry ?
10:55:37 <ski> ah, yes
10:55:46 <Eduard_Munteanu> I see.
10:56:38 <Eduard_Munteanu> ski: that's per quadrant, right?
10:57:01 <ski> he has an interpretation of `forall y : B. exists x : A. y = f(x)' in terms of an internal language, that *externally* means that `f' is only epi, not surjective -- but i don't claim to understand this really
10:57:10 * Eduard_Munteanu isn't sure
10:57:32 <ski> Eduard_Munteanu : well, you can't decide in which quadrant an element of `C' lies
10:57:49 <rwbarton> well, locally on the target, you can find a one-sided inverse
10:58:05 <ski> yeah, which of often almost as good
10:58:20 <Eduard_Munteanu> ski: doesn't sgn(Re(z)) and sgn(Im(z)) tell you?
10:58:23 <rwbarton> that's probably what the "internal" mumbo-jumbo amounts to, when interpreted in the appropriate topos :)
10:59:12 <ski> Eduard_Munteanu : you can't define `sgn' on all real numbers, only for the subset `{x : |R | x = 0 \/ x =/= 0}'
10:59:49 <ski> (rwbarton : i wouldn't be surprised :)
10:59:51 * Eduard_Munteanu is confused :)
11:00:12 <ski> the basic problem is that equality on reals isn't decidable
11:00:17 <Eduard_Munteanu> Do you mean   sgn : |R \ {0} -> {-1, 1}   ?
11:00:26 <Eduard_Munteanu> Ah.
11:00:28 <ski> so `forall x : |R. x = 0 \/ x =/= 0' isn't provable
11:01:15 <ski> Eduard_Munteanu : i assumed you wanted to define `sgn(0) = 0', but if you prefer, we can skip that, in which case the subset becomes `|R \ {0}' yes (which isn't a detachable subset of `|R')
11:01:58 <Eduard_Munteanu> And since it's not decidable you're saying the surjection can't be constructively defined/proven?
11:02:06 <ski> (that `S' is a detachable subset of `A' means that `forall x : A. x \in S \/ x \notin S')
11:02:31 <Eduard_Munteanu> (if it's to invoke sgn)
11:02:42 <ski> Eduard_Munteanu : yeah
11:03:12 <rwbarton> actually I guess the proof will look something like this: pick two open intervals A and B of C which cover C, then you can "prove constructively" (whatever that means) that x in C => x in A \/ x in B
11:03:22 <rwbarton> and over A and B, you can write down an inverse to f
11:04:53 <ski> yeah, but how to pick in the overlap ?
11:05:01 <rwbarton> you don't have to pick
11:05:25 <ski> how would it be proved, then ?
11:05:30 <rwbarton> x in A => exists z st. x = f(z) and also x in B => exists z st. x => f(z)
11:05:44 <ski> i.e. the `x in C => x in A \/ x in B' part, i mean
11:05:49 <rwbarton> oh
11:05:54 <dolio> Eduard_Munteanu: All continuous functions from the real numbers to a discrete type are constant.
11:06:01 <rwbarton> well let's prove that x in |R => x < 1 or x > -1
11:06:05 <rwbarton> that is the same idea, right
11:06:19 <Eduard_Munteanu> Ouch... that's some weird parametricity right there :)
11:06:35 <rwbarton> we can do that by obtaining a rational number r such that |x - r| < 1/2 or whatever, and checking the sign of r
11:06:35 <Eduard_Munteanu> But yeah, I guess I can see why.
11:08:22 <ski> rwbarton : ok, but then the resulting function is not extensional, i think
11:08:28 <rwbarton> it's not a function
11:08:39 <ski> (so it's not a function, it's an "operation", in the Bishop terminonogy)
11:09:21 <rwbarton> obviously you can't write down a section of (-infty, 1) |_| (-1, infty) -> |R, yes
11:10:02 <rwbarton> but surely "obtaining a rational number r such that |x - r| < 1/2 or whatever, and checking the sign of r" is sufficiently constructive for anybody?
11:10:13 * rwbarton doesn't understand this constructive mumbo-jumbo
11:10:42 <copumpkin> rwbarton: learn it!
11:10:44 <ski> some people, by a proof of `forall x : A. exists y : B. R x y', only assume the existence of an operation (not necessarily extensional) `f' such that `forall x : A. R x (f x)'
11:10:50 <rwbarton> but I already know "it" (topos theory)
11:10:58 <copumpkin> rwbarton: learn a more applied form of it :P
11:11:16 <dmwit> Wait, you can decide "x > 0" on |R \ {0}, but you can't decide "x = 0"?
11:11:29 <rwbarton> i'd rather not play a game where everyone has a different definition of each symbol every day
11:11:30 * ski has a preference to interpreting that as there existing a *function* `f'
11:11:40 <dmwit> (From the claim that the domain of sgn is |R \ {0} when we don't demand that sgn(0)=0.)
11:11:44 <rwbarton> and just write down what I mean in terms of topos theory
11:11:46 <copumpkin> rwbarton: sounds like you're in the wrong field ;)
11:11:52 <rwbarton> or continuous maps or whatever
11:12:52 <ski> consider e.g. the statement `forall x : |R. exists n : |Z. x < n'
11:13:08 <ski> i'm inclined to consider this not provable
11:13:30 <dmwit> (Where by "decide P" I mean construct a value of type "forall x. P x \/ not (P x)".)
11:13:31 <rwbarton> it seems like your notion of a real number is something about which you know nothing
11:13:51 <harrisonpartch> what could be more real than ignorance?
11:14:00 <rwbarton> if I have a constructible real number, I can compute an integer larger than it
11:14:04 <copumpkin> the reals are unicorns anyway
11:14:19 <ski> if we consider this provable, and assume the axiom-of-choice, then we can construct a function `f : |R -> |Z' which would have to be noncontinuous
11:14:55 <dmwit> I'd rather have this statement than the axiom of choice.
11:15:08 <ski> and since we don't think noncontinuous functions can actually be constructed, either we discard (the full version of) the axiom of choice, or we have to consider `forall x : |R. exists n : |Z. x < n' nonprovable
11:15:18 <dolio> You don't know nothing.
11:15:26 <dolio> You know any finite approximation you desire.
11:15:33 <rwbarton> that's what I thought.
11:15:41 <rwbarton> But then, surely I can prove `forall x : |R. exists n : |Z. x < n'
11:16:05 <ski> imo `forall x : |R. exists n : |Z. x < n' shouldn't be provable, but `forall x : |R. oblivious_exists n : |Z. x < n' should be
11:16:09 <dolio> But you also have to make sure that if you have two finite approximations that get arbitrarily close in the right way, you have to yield the same integer.
11:16:24 <rwbarton> right, this is the sort of game I don't like.
11:16:38 <dolio> So if one is approaching 2 from below, and one is approaching 2 from above, you're not allowed to yield 2 for the first, and 3 for the second.
11:16:41 <ski> i.e. as long as you can't actually *depend* on the `n' computed, it's fine
11:17:20 <ski> (but i suspect one could possibly express `oblivious_exists' in terms of `exists', and something else)
11:17:21 <rwbarton> if you'd just defined your two exists quantifiers in some formal setting, we could agree that they are distinct and verified which statements were true and which false.
11:17:21 <dolio> You don't like the game of using functions that you actually have a chance of computing in reality?
11:17:38 <dmwit> So, here's my function, tell me what's wrong with it. Approximate R to within 1/2, then round to the nearest integer, then add one.
11:17:42 <xplat> hm, yes, if you're allowed to rip open the 'real number' you're given and look at the converging sequence, you can find an integer upper bound
11:17:56 <dmwit> Surely the result of this function is an integer with R < n.
11:18:16 <xplat> but there's no way to compute one that is the same for every sequence representing that number
11:18:39 <xplat> basically, your function violates data abstraction, unless you conspire to hide which number it is
11:18:46 <xplat> er, which integer
11:19:40 <ski> dmwit : you can decide `x > 0' on `|R \ {0}', yes
11:20:55 <rwbarton> dolio: What I don't like is removing the axioms that make two classical statements equivalent, then picking one of the resulting non-classical notions, using the classical notation for it and arguing with people who assume that you intended the other non-classical notion.
11:21:23 <xplat> ski: you can decide it on `{r \in |R | r is apart from 0}`, but that's different from `|R \ {0}`, isn't it?
11:21:58 <dmwit> ski: Ah, I see, so you're saying it's not necessarily the case that x <= 0 and -x <= 0 implies x = 0. Is that right?
11:24:39 <ski> xplat : well, i consider `A \ S', with `S' a subset of `A' to mean `{x : A | x \notin S}' where `x \notin S' means `forall a : S. x \apart a'
11:25:27 <ski> (blame Richman,et al. for wanting to use the symbol `\notin' for the more useful concept, constructively)
11:25:37 <dolio> dmwit: Unless I'm mistaken, the real value 1.5 can have an approximation that when you say, "approximate to within 1/2" could be anywhere between 1 and 2.
11:25:42 <dolio> You already can't round.
11:26:12 <dolio> Except maybe rounding to a real number.
11:26:25 <maltem> How can *anyone* use the symbol \notin not to mean not in
11:26:37 <dmwit> dolio: Aha, perfect rebuttal. Thanks.
11:26:56 * ski is talking about the symbol `\in', with a slash over it
11:27:38 <ski> maltem : then also use the traditional inqueality symbol for apartness (and pronounce it as "inequal to") -- others use `#' instead
11:28:12 <maltem> They don't get my sympathy then :p
11:28:23 <ski> dmwit : anyway, the problem with your procedure is that it's not extensional : if you use different representations of the same real number, you might get different whole numbers as output
11:28:27 <keep_learning> :t (++)
11:28:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
11:28:34 <keep_learning> @src (++)
11:28:34 <lambdabot> []     ++ ys = ys
11:28:35 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:28:35 <lambdabot> -- OR
11:28:35 <lambdabot> xs ++ ys = foldr (:) ys xs
11:29:07 <darkf> so, I seem to understand monads
11:29:09 <darkf> yay
11:29:44 <ski> Eduard_Munteanu : anyway, there's #constructive-math as well (though it's usually pretty quiet)
11:30:06 <darkf> ski: I understand themmmmmm and you guys said it couldn't be done! hahahaha
11:30:27 <copumpkin> darkf: explain them then :)
11:31:01 <darkf> well I'm going to suck at it
11:31:11 <ski> (darkf : hehe, i don't recall me saying that :)
11:31:14 <rwbarton> ski: what do you think about "forall x in |R. x < 1 \/ x > -1", then
11:31:17 <lpsmith> darkf, hurray!
11:31:47 <dmwit> As proof you understand them, implement the function "runMonad :: Monad m => m a -> a".
11:31:57 <copumpkin> yeah, good idea
11:32:04 <darkf> the point is, I fully understood this article http://ertes.de/articles/monads.html
11:32:06 <darkf> and it was awesome
11:32:08 <Eduard_Munteanu> ski: hm, nice to know
11:32:18 <copumpkin> darkf: that's mm_freak_ :)
11:32:25 <darkf> mm_freak_: you are awesome, sir
11:32:34 <Eduard_Munteanu> Though a bunch of this stuff is discussed all over #haskell(-blah) and #agda
11:33:06 <rwbarton> is this supposed to be true only for some "oblivious_\/"?
11:33:38 <Eduard_Munteanu> Is there anything like a "sparingly classical mathematician"?
11:33:49 * Eduard_Munteanu wondered
11:33:55 <rwbarton> sparingly?
11:34:06 <rwbarton> in what sense?
11:34:21 <Eduard_Munteanu> rwbarton: yeah... accept non-constructive results (proofs) only if that's the only option
11:34:29 <dolio> rwbarton: Probably. Maybe the double negation encoded \/.
11:35:04 <Eduard_Munteanu> A lot of mathematics is needlessly non-constructive it seems.
11:35:05 <ski> rwbarton : eventually, the approximations for `x' will get small enough bounds so that you can exclude one possibility, so true
11:35:57 <ski> rwbarton : generally, the strict ordering on the real numbers is cotransitive : `forall a,b,c : |R. a < c => a < b \/ b < c'
11:36:49 <rwbarton> well earlier you told me it was false, with a different notion of \/ though I guess.
11:36:51 <maltem> Eduard_Munteanu, I had a logic course last year where every proof started with "otherwise" :)
11:37:15 <maltem> And sometimes otherwises were nested
11:37:22 <Eduard_Munteanu> Heh.
11:37:31 <shachaf> Eduard_Munteanu: Why would you construct things when you can not construct them?
11:38:37 <Eduard_Munteanu> shachaf: I'm just saying you'd construct what you can.
11:39:05 <dolio> Sometimes it's harder to prove things constructively.
11:39:20 * hackagebot aeson-qq 0.4.1 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/aeson-qq-0.4.1 (OscarFinnsson)
11:41:06 <ski> it's interesting to consider how some classical reasoning can be implemented in terms of continuations
11:41:11 <lpsmith> out of curiousity, does profiling measure clock time or CPU time?
11:41:30 <lpsmith> I'm pretty sure it's CPU time,  and I'm wondering if there is a way to measure clock time instead.
11:41:37 <ski> of course, there's no guarantee that the "functions" constructed that way are actually functions
11:42:22 <dolio> You mean, they might be continuations in disguise, effectively?
11:42:29 <lpsmith> well, s/pretty sure/my hypothesis is/
11:42:52 <dolio> Since we typically type continuations as functions even though they aren't.
11:43:13 <lpsmith> SML has a separate type for continuations
11:43:20 <dolio> Yeah.
11:43:34 <dolio> You can still get a function out with throw, though.
11:43:51 <dolio> Which isn't exactly a function in this sense.
11:43:55 <lpsmith> true
11:44:09 <ski> darkf : in case you want a few more, i happen to think <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> is nice, though a bit old -- also i hear <http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html> is good
11:44:22 <darkf> ski: thanks :3
11:44:45 <rwbarton> is there an elimination rule for this "oblivious_\/"?
11:44:59 <rwbarton> what do I have to do to prove "A oblivious_\/ B => C"?
11:47:07 <ski> dolio : i mean e.g.  val twiceCC : 'a * 'a cont -> 'a * 'a cont  which is such that if you call it, then later invoke the continuation returned, it will jump back and return the value you passed to the continuation, together with the initial continuation you passed, so that when/if it jumps the next time, it will jump to another place
11:47:44 <rwbarton> it seems that the difference between \/ and oblivious_\/ only appears in the presence of quantifiers
11:47:44 <ski> dolio : this is basically just a very convoluted way to do  val twice : ('a -> 'a) -> ('a -> 'a)  btw :)
11:49:43 <ski> rwbarton : if the latter is `not not (A \/ B)', i.e. `not (not A /\ not B)', then difference is that with `A \/ B' you get a bit of information (together with a proof of `A' or `B'), but with the other, you can't extract any information bits at all, you can only use it to prove that you're in an impossible situation (so computationally, the code/proof will never actually be executed)
11:50:35 <ski> the fun thing with using continuations, otoh, is that then you can indeed execute into an impossible situation, and escape out of it, when/if you discover the inconsistency :)
11:51:55 <ski> in SML/NJ, there's basically an operation `callCC :: (Not a -> a) -> a' (Peice's law, more or less, a variant on double-negation elimination)
11:52:17 <ski> using this, you can prove `lem :: () -> Either (Not a) a'
11:52:55 <rwbarton> I guess I just need to stop thinking of "constructive logic" as a kind of logic at all.
11:53:19 <ski> computationally, this will always return `Left k' for a new `k :: Not a'. later, if you discover you can actually construct `x :: a', you can use `throwCont :: Not a -> a -> b' as `throwCont k x' to escape from the situation
11:53:34 <ski> at which the computation restarts from the `lem' call, this time returning `Right x'
11:54:05 <ski> rwbarton : well, there's "intuitionistic logic" which is well-studied
11:54:30 <ski> rwbarton : then there's also variants of type theory, which is both a constructive logic, and a programming language
11:56:11 <rwbarton> I just mean, in the categorization of things into my head, it does not fit into the "logic" category.
11:56:12 <ski> (per the Curry-Howard(-Lambbek) correspondence : proofs are programs (functions are elements of exponentials in a CCC) and formulae are types (function types, i.e. implicational formulae, are exponential objects))
11:56:40 <rwbarton> right, it's just a goofy notation for writing down things on the right hand side of that correspondence
11:57:03 <ski> it's type theory which insists of types&programs and formulae&proofs really being the same thing
11:57:08 <dolio> It's not logic without A ∨ ¬A?
11:57:37 <rwbarton> Well, honestly, I care very little about logic
11:57:46 <ski> if you want a more traditional flavour, you can do intuitionistic logic, which is just like classical logic, only with some rules/axioms elided
11:57:49 <rwbarton> as far as the symbol-pushing aspect of it is concerned
11:58:00 <ski> (so there, sets are not identified with formulae)
11:58:01 <rwbarton> I'm a lot more interested in the models
11:59:15 * ski thinks the ZF set theory people is to a large part responsible for the bad reputation of logic and foundations
11:59:51 <rwbarton> I mean, yes, obviously there is a ton of value in having some setting where |R and { x | x /= 0 \/ x = 0 } are two different objects.
12:00:15 <ski> (really, logic and foundations isn't really meant to be as painful as possible, to actually *use*)
12:01:49 <tomprince> I think the biggest thing with zf is tahat it isn't how people do math .... not everything is a set of sets with no other structure.
12:01:52 <rwbarton> But to me, trying to make sense of "with `A \/ B' you get a bit of information (together with a proof of `A' or `B')" is far more difficult then just writing down the model (embedded in some classical logic).
12:02:02 <ski> tomprince : *nod*
12:02:47 <ski> rwbarton : thinking in terms of a program, `A \/ B' is `Either A B' in Haskell
12:03:01 <dolio> That you get that is the (one) meaning for the logic being constructive.
12:03:02 <tomprince> That is why I like type theory. It seems to match how people actually do math (ignoring constructive vs. classical dsitinctions.
12:03:03 <rwbarton> that's why I say that \/ is not a *logical* notion
12:03:17 <ski> so, if you get a proof of `A \/ B', you can check it to be either of the form `Left x' for `x' a proof of `A', or `Right y' for `y' a proof of `B'
12:03:41 <dolio> If A \/ B is provable, then it is due to either A being provable or B being provable, and a rule exploiting that ability.
12:03:51 <ski> well, this is the BHK (Brouwer-Heyting-Kolmogorov) interpretation of the logical connectives
12:04:04 <Miden> can anyone tell me what is IORef and how can i use it?
12:04:12 <rwbarton> well, I would say it is just a funny notation for the coproduct.
12:04:26 <ski> i.e. a proof of `exists x : A. P x' should actually give a procedure with which one may compute an `x' in `A', such that `P x'
12:04:34 <tomprince> rwbarton: It is.
12:04:46 <Eduard_Munteanu> @hoogle newIORef
12:04:47 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
12:04:48 <tomprince> Well, not funny, but one in the appropriate category.
12:04:57 <ski> (as opposed to that `x' only existing in some ideal platonic world which isn't necessarily accessible by mere mortals)
12:05:06 <dolio> Some people work on logics by trying to add classical sounding principles that preserve this characteristic of the logic.
12:05:13 <Eduard_Munteanu> Miden: it's a mutable cell
12:05:17 <dolio> Like, limited search principles.
12:05:26 <dolio> Or quantifier shifting.
12:05:27 <Miden> yeah i already searched @ hoogle
12:05:47 <Miden> but i cannot understand the meaning of that module
12:05:55 <ski> rwbarton : yes, disjunction is just a funny notation for the coproduct (and vice versa) :)
12:05:56 <Eduard_Munteanu> Miden: you create one with newIORef, then you can access it using readIORef, writeIORef, modifyIORef
12:06:14 <rwbarton> ski: yes, we went over this earlier with your C -> C example.
12:06:38 <Eduard_Munteanu> Miden: obviously you can only use it in the IO monad
12:07:10 <Eduard_Munteanu> What is it you don't understand?
12:07:41 <Miden> xmm...
12:07:58 <maltem> ski, I find it funny that I have never experienced foundations to have a bad reputation, I only read that in texts about foundations
12:08:04 <ski> rwbarton : i only wanted to say here that this BHK interpretation of the connectives isn't anything new
12:08:18 <rwbarton> of course not
12:08:33 <rwbarton> it is just not logic, as I understand it, having to do with the study of propositions
12:08:40 <Eduard_Munteanu> CT already did it? :P
12:08:59 <ski> i think much of mathematics, pre Cantor and Dedekind, implicitly assumed more or less BHK
12:09:00 <dolio> You mean booleans.
12:09:05 <rwbarton> Sure.
12:09:21 <rwbarton> Well, if you are going to redefine "proposition" then I am free to redefine "logic".
12:09:38 <ncs> what does it mean to force a list?
12:09:47 <darkf> strict evaluate it
12:09:49 <darkf> idk
12:09:56 <maltem> rwbarton, how do you define "proposition" in a way that does not suit BHK?
12:10:17 <ski> logic is the study of propositions and arguments, yes
12:10:20 <dolio> Are you sure you're not redefining both?
12:10:32 <ski> per CH, we can think of propositions and sets as the same thing
12:10:37 <rwbarton> well you cannot tell me that constructivists do not redefine terms.
12:10:39 <Eduard_Munteanu> ncs: making evaluation proceed in a certain way. Are you familiar with 'seq'?
12:10:40 <rwbarton> They are forced to!
12:10:49 <ski> a more nuanced viewpoints is that propositions are sets that have at most one proof
12:11:02 <ncs> not really
12:11:38 <dolio> You mean, like when using ZF we're forced to redefine sets to not admit choice?
12:11:41 <Eduard_Munteanu> ncs: ok. You know what lazyness is, right?
12:11:57 <Eduard_Munteanu> Or non-strict semantics, as far as a language is concerned.
12:12:01 <ncs> yes
12:12:04 <rwbarton> Anyways, this whole discussion is silly.
12:13:21 <Eduard_Munteanu> ncs: a `seq` b   (or   seq a b) means "when you evaluate 'b', also have a look at 'a'"
12:13:25 <ski> arguably, the intuitionistic/classical split occured when attempting to specify closer what we mean by a proposition, and holding a proposition to be true
12:13:59 <copumpkin> YOU'RE AN IDIOT
12:14:00 <Eduard_Munteanu> ncs: this can be used to "add" strictness when needed, or in other words "force" stuff to be evaluated.
12:14:25 <ski> so i think it's more like both sides were "redefining" a previous vague idea of "proposition" in different ways
12:14:30 <Eduard_Munteanu> copumpkin: and pours two pints? :P
12:15:03 <rwbarton> What I meant by that comment is, classically one often has multiple definitions that diverge in another setting.
12:15:09 <Eduard_Munteanu> -- lame reference to a math joke
12:15:19 <ncs> i have tried using this in some simple examples in ghci and it looks like it does the opposite of const, i.e. it kind of ignores a and it returns b
12:15:50 <rwbarton> So of course the constructivist cannot write "We say that ___ is ___ if the following equivalent conditions hold: ..."
12:15:55 <Eduard_Munteanu> ncs: yes, if you ignore the operational aspects of evaluation, that's what it does
12:16:07 <darkf> 5 <=> 5
12:16:28 <rwbarton> Anyways, yes, to me logic is about propositions, and a proposition is something that is true or false.
12:16:59 <rwbarton> I might be tempted to abandon this view if it wasn't so extraordinarily convenient to build classical category-theoretic models of constructive logic.
12:17:09 <ncs> can you give me an example that seq forces stuff to be evaluated?
12:17:18 <ski> ncs : try `seq (error "foo !") 42'
12:17:32 <ski> > seq (error "foo !") 42
12:17:34 <lambdabot>   *Exception: foo !
12:17:39 <ski> > flip const (error "foo !") 42
12:17:41 <lambdabot>   42
12:17:59 <Eduard_Munteanu> ncs: in any of those examples you tried. But merely evaluating (forcing) something doesn't mean you get any visible results.
12:18:23 <dolio> rwbarton: By the way, Ed says you should register for hac beans if you haven't.
12:18:26 <dolio> And you aren't on his list.
12:18:30 <rwbarton> beans?
12:18:41 <dolio> Hac boston.
12:18:42 <rwbarton> Is that Hac Boston? I registered for that, I think...
12:18:46 <rwbarton> Hmm.
12:18:54 <dolio> Never mind, Ed is blind.
12:19:04 <ncs> ok, i can see what seq does now! thanks
12:19:08 <rwbarton> Heh, ok :)
12:19:08 <dolio> You're at the top of his top page.
12:19:32 <ncs> so, what does it mean to force a list?
12:19:44 <copumpkin> just one level
12:19:58 <tsousa> hey
12:19:59 <Eduard_Munteanu> ncs: it normally means forcing the evaluation of all its elements
12:20:15 <tsousa> i am looking for some fun exercises to do in Haskell, can you guys recommend me something?
12:20:31 <ncs> is it like applying seq to a list and something else, "evaluating" the list and then returning that something else?
12:20:57 <Eduard_Munteanu> ncs: yeah, that's one way.
12:21:34 <ncs> ok! thanks!
12:22:15 <dolio> In any case, you should all join me in calling it hac beans.
12:22:33 <mm_freak_> darkf: i'm not =)
12:22:53 <mm_freak_> darkf: if you were to ask me today, i would probably say that my monad tutorial isn't that great
12:23:14 <darkf> mm_freak_: but it is :)
12:23:18 <mm_freak_> reason:  it builds up Monad directly instead of going through Functor and Applicative
12:24:13 <mm_freak_> darkf: people seem to like it, but i'm a perfectionist =)
12:24:20 * hackagebot IORefCAS 0.0.1 - Atomic compare and swap for IORefs and CASRefs.  http://hackage.haskell.org/package/IORefCAS-0.0.1 (RyanNewton)
12:24:36 <Eduard_Munteanu> ncs: actually now that I re-read what you said, it's probably not what you want. You probably want to fold the list with 'seq', not merely apply 'seq' to the list.
12:24:42 <tsousa> lyah is down?
12:25:07 <Eduard_Munteanu> ncs: since 'seq' evaluates only to the outermost constructor, it doesn't go deep.
12:25:15 <mm_freak_> btw, LYAH has made it into the german book stores
12:25:18 <mm_freak_> i saw it on saturday
12:25:51 <mm_freak_> if anyone cares, i found it in the wittwer book store in stuttgart
12:25:51 * ski . o O ( "How Dedekind Screwed Up a Hundred Years of Mathematics" <http://r6.ca/blog/20051210T202900Z.html> )
12:26:12 <Eduard_Munteanu> There's deepSeq for forcing stuff as much as possible.
12:26:19 <mm_freak_> Eduard_Munteanu: deepseq
12:26:47 <Eduard_Munteanu> Ah. I haven't actually used it much.
12:26:49 <Eduard_Munteanu> :)
12:26:49 <mm_freak_> Eduard_Munteanu: also 'seq' can potentially evaluate deeper, if the constructor has strict fields
12:27:04 <ski> tsou.. bah
12:27:12 <Eduard_Munteanu> Yeah.
12:28:40 <jll> how can I turn a function into point-free style where the argument appears multiple times in the body (in other function calls even)?
12:29:15 <donri> @pl \x -> (x,x)
12:29:16 <lambdabot> join (,)
12:29:21 * hackagebot IORefCAS 0.0.1.1 - Atomic compare and swap for IORefs and CASRefs.  http://hackage.haskell.org/package/IORefCAS-0.0.1.1 (RyanNewton)
12:29:26 <Eduard_Munteanu> ski: hrm, interesting. Though I find it hard to believe constructivism was applied hundreds of years ago... much less formal stuff would get through as valid reasoning. So I imagine providing constructive solutions wasn't a concern.
12:29:40 <donri> jll: probably involving composition
12:30:11 <Eduard_Munteanu> @pl \x -> f _ x
12:30:12 <lambdabot> (line 1, column 9):
12:30:12 <lambdabot> unexpected "_"
12:30:13 <lambdabot> expecting variable, "(", operator or end of input
12:30:19 <Eduard_Munteanu> @pl \x -> f a x
12:30:20 <lambdabot> f a
12:30:26 <Eduard_Munteanu> @pl \x -> f a x b
12:30:27 <lambdabot> flip (f a) b
12:30:35 <shachaf> jll: http://en.wikipedia.org/wiki/Combinatory_logic
12:30:37 <jll> donri, yes, e.g. I want to shorten this (it's ML though): (fn x => foldl Int.max (length x) x)
12:30:51 <ski> Eduard_Munteanu : i think it's more that the arguments were mostly done constructively. consider e.g. the vehemence with which Kronecker attacked Cantor
12:30:53 <shachaf> @pl \x -> foldl max (length x) x
12:30:54 <lambdabot> foldl max =<< length
12:31:02 <shachaf> jll: You probably don't want to do that, though.
12:31:09 <xivix> =<< doesn't look happy
12:31:12 <Axman6> jll: you take advantage of the ((->) a) monad
12:31:23 <donri> xivix: damn you can't unsee
12:31:31 <jll> Axman6, and in ML, where no monads exist?
12:32:25 <ski> jll : you'd need to define your own `join'
12:32:28 <dolio> ski: Doesn't abstract stone duality give constructive meaning to Dedekind-like definitions?
12:32:33 <Axman6> firstly, they do exist, they're just probably not called monads. and secondly, I have no idea about ML =)
12:33:02 <ski> jll : btw, you can do monads in the MLs as well (e.g. the LWT (Light-Weight Threads) library in O'Caml is inspired (a bit) by monads)
12:33:33 <jll> yeah, the concept is the same, but it wouldn't be shorter
12:33:35 <ski> dolio : Taylor claims that, yes. i don't understand how it works, though
12:33:42 <dolio> Me neither.
12:34:21 * hackagebot IORefCAS 0.0.1.2 - Atomic compare and swap for IORefs and STRefs.  http://hackage.haskell.org/package/IORefCAS-0.0.1.2 (RyanNewton)
12:34:46 <shachaf> What good is atomic CAS for STRefs?
12:35:18 <Eduard_Munteanu> shachaf: presumably if you convert ST to IO?
12:35:40 <ezyang> shachaf: I'm... not even sure what that means.
12:35:58 <Eduard_Munteanu> But yeah, I guess it's a corner case.
12:36:29 <ski> LWT <http://ocsigen.org/lwt/manual/>
12:37:55 <ski> see specifically
12:37:59 <ski>   val Lwt.return : 'a -> 'a Lwt.t
12:38:02 <shachaf> ezyang: AI was just trying to figure out what hackagebot said. :-)
12:38:05 <ski>   val Lwt.bind : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
12:39:01 <shachaf> ski: Those are "monadic" but not in an abstract way.
12:39:17 <shachaf> One might say the same thing about const.
12:39:24 <shachaf> (What *is* const? We just don't know.)
12:39:26 <ski> *nod*
12:40:17 <copumpkin> you can't explain that.
12:40:27 <copumpkin> tides, man
12:41:54 <ski> you can define an interface :
12:42:00 <ski>   module type MONAD = sig
12:42:04 <ski>     type 'a t
12:42:08 <ski>     val return : 'a -> 'a t
12:42:15 <ski>     val bind : 'a t -> ('a -> 'b t) -> 'b t
12:42:17 <ski>   end
12:43:17 <ski> however, it's a little bit cumbersome to write code polymorphic in a monad, you have to use a module functor (which you have to manually instantiate)
12:44:32 <ski> also, since there's no higher-kinded types, you can't define monad transformers, or other types parameterized on a monad, except by using a module functor
12:45:31 <hpaste> keep_learning pasted “Haskell program profiling” at http://hpaste.org/54965
12:45:43 <keep_learning> hello all
12:46:03 <ezyang> keep_learning: cabal install --reinstall deepseq
12:46:31 <Eduard_Munteanu> And -p
12:46:39 <ezyang> also recommend setting library-profiling = True in .cabal/config
12:46:47 <ezyang> (if it isn't already)
12:47:02 <keep_learning> ezyang, the problem is it will install deepseq-1.2 which will not work with this ghc-7.0.3
12:47:19 <keep_learning> as  suggested by c_wraith
12:47:20 <ezyang> Specify an explicit version number then?
12:47:37 <keep_learning> ezyang, thank you
12:48:08 <brozow> is there a way I can put a #!/usr/bin/runghc at the top of a .hs script?
12:48:40 <ezyang> brozow: Yes.
12:48:56 <hpaste> ezyang pasted “runghc shebang” at http://hpaste.org/54967
12:49:00 <ezyang> http://hpaste.org/54967
12:49:42 <hugsssss> Hi ppl
12:49:47 <hugsssss> I have a question
12:49:59 <hugsssss> How I read a Float???
12:50:03 <kniu> Don't ask to ask. Just ask.
12:50:03 <brozow> hmm... guess i'm dong something wrong here...
12:50:05 * brozow goes to look
12:50:08 <keep_learning> ezyang, Should i remove -- from -- library-profiling: True ?
12:50:09 <ezyang> hugsssss: From where?
12:50:10 <benmachine> hugsssss: what have you tried already?
12:50:15 <ski> (which means that defining a monad transformer `StateT' really is comparable to `data StateTOps s m = forall n. SOps {monadOps :: MonadOps n; get :: n s; ...; lift :: forall a. m a -> n a}' together with `mkStateTOps :: MonadOps m -> StateTOps s m' ..)
12:50:17 <kniu> hugsssss, what do you mean by "read"?
12:50:34 <ezyang> keep_learning: yeah, although I think that means they changed the default?
12:50:39 <ski> > read "0.25" :: Float
12:50:41 <lambdabot>   0.25
12:50:48 <ski> > read "pie" :: Float
12:50:49 <lambdabot>   *Exception: Prelude.read: no parse
12:51:12 <keep_learning> ezyang, no it was False earlier
12:51:21 <keep_learning> i changed it to True
12:51:22 <ezyang> Oh, OK. Uncomment it then.
12:51:32 <hugsssss> I want the user insert a float and read this
12:51:36 <ezyang> Note that you will probably have LARGENUM packages that will need tto be recompiled.
12:51:51 <EvanR-work> liftM read getLine
12:53:06 <hugsssss> l have this ----- mainB = do putStrLn "A Float"
12:53:11 <hugsssss> b <- getLine
12:53:20 <ezyang> :t getLine
12:53:22 <lambdabot> IO String
12:53:36 <brozow> ezyang: couldn't quite get that to work on a mac for some reason.. had to uses #!/usr/bin/env runghc
12:53:40 <hugsssss> but I want read a float
12:53:51 <ezyang> brozow: Maybe GHC was installed to a different path :-)
12:54:04 <ezyang> /usr/bin/env is in general a good idea.
12:54:06 <brozow> uzbekistan:ch01 brozow$ type runghc
12:54:07 <brozow> runghc is hashed (/usr/bin/runghc)
12:54:29 <brozow> it doesn't matter.. got it working
12:54:36 <brozow> thanks for the help
12:54:54 <EvanR-work> hugsssss: let d = read b :: Float
12:55:08 <EvanR-work> print d
12:55:38 <hpaste> keep_learning annotated “Haskell program profiling” with “Haskell program profiling (annotation)” at http://hpaste.org/54965#a54968
12:56:13 <keep_learning> Now its say it can't find the module from src folder.
12:56:34 <ezyang> keep_learning: I think your cwd is wrong
12:56:47 <brozow> what editors to people use for haskell.. a good emacs mode somewhere?
12:56:54 <EvanR-work> haskellmode
12:56:56 <ezyang> Snowfall.Spatial ==> Snowfall/Spatial.hs, but where is the Sim directory?
12:58:02 <keep_learning> ezyang, /home/user/Haskell/project/usnowfall/snowfall-chart/test/Snowfall/Spatial/Sim
12:58:15 <ezyang> "well, there's your problem"
12:59:03 <ezyang> I suggest making a Cabal file at this point, or perhaps using the -i flag
12:59:43 <keep_learning> ezyang, so how to let the compiler know that Snowfall.Spatial from src/Snowfall/Spatial
13:00:09 <ezyang> Sentence?
13:00:29 <ski> hugsssss : instead of `getLine' together with `read', you can also use `readIO'
13:00:33 <ski>   d <- readIO
13:02:15 <keep_learning> ezyang, i am in test/Snowfall/Spatial/Sim directory and i am importing files from src/Snowfall/Spatial and src/Snowfall
13:02:31 <keep_learning> test and src at same level
13:02:33 <ezyang> Right, so add the src/ directory to -i
13:02:58 <ezyang> Or, setup Cabal and it will handle all this for you 8)
13:02:59 <keep_learning> ezyang, ghc -i src -prof -auto-all -o Measuretime Measuretime.hs
13:03:09 <ncs> if i want to force evaluation of a list is it ok to use a let and assign this list to a new variable?
13:03:28 <ezyang> but I'm pretty sure src is not in your cwd..
13:03:35 <ezyang> ncs: No, that would force evaluation.
13:03:46 <ezyang> Can you explain more context?
13:03:51 <ezyang> *won't
13:04:13 <EvanR-work> ncs: that wont force evaluation
13:04:15 <ncs> i want to force evaluation of a list and then return something else
13:04:18 <EvanR-work> that wont do anything !
13:04:27 <ncs> something like seq, without using seq
13:04:34 <ezyang> ncs: So, when the "something else" is evaluated, you want the list to be evaluated?
13:04:43 <ezyang> ncs: I'm pretty sure you want seq.
13:04:54 <ezyang> ncs: Do you want to force the elements of the list, or just the spine?
13:05:31 <ncs> it's an exercise and i have to force a list without using seq
13:05:40 <ezyang> oh I see
13:05:45 <ncs> so i have to create a function f:: [a] -> b -> b
13:06:07 <copumpkin> it won't be a very interesting function
13:06:15 <EvanR-work> print myList
13:06:16 <EvanR-work> ;)
13:06:16 <copumpkin> oh, eww, seq
13:06:34 <ezyang> ncs: OK, here's the way to refram e it.
13:06:37 <copumpkin> ncs: force the spine or the entire list?
13:06:50 <ezyang> copumpkin: he can't do the entire list because it's polymorphic on a
13:06:52 <ncs> the entire list
13:07:03 <copumpkin> ezyang: sure he can, since seq doesn't care
13:07:07 <ncs> i thought of saying f a b = do {let x = a; b}
13:07:09 <ezyang> But he said he can't use seq.
13:07:11 <copumpkin> oh
13:07:21 <copumpkin> then he can only do the spine, you're right :)
13:07:40 <ezyang> ncs: So, here's the key observation: you need your function to obey these equations:
13:07:44 <ezyang> f undefined b = undefined
13:07:54 <EvanR-work> ncs: so x would just be eliminated by the compiler ;)
13:07:55 <ezyang> f (0:undefined) b = undefined
13:08:03 <ezyang> f (0:0:undefined) b = undefined
13:08:05 <ezyang> ...
13:08:12 <copumpkin> ezyang: I don't see the pattern
13:08:14 <ezyang> "so how would you make tha thappen"
13:08:16 <copumpkin> can you give me a few more examples?
13:08:34 <ezyang> f (0:0:0:[]) b = b
13:08:42 <copumpkin> :)
13:08:55 <rwbarton> f "stop asking questions" Okay = Okay
13:09:06 * copumpkin runs away sobbing
13:09:15 <ezyang> This implies you have to do something to 'a'.
13:09:21 * hackagebot vector-space-opengl 0.1 - Instances of vector-space classes for OpenGL types  http://hackage.haskell.org/package/vector-space-opengl-0.1 (AdamFoltzer)
13:09:39 <ncs> i have to evaluate it. other than that, i don't use it anywhere
13:09:52 <copumpkin> ncs: easiest way would be to use something like length :)
13:09:54 <ezyang> ncs: What is meant by 'evaluate'?
13:10:12 <ezyang> copumpkin: But he can't use length, because he can't use seq :-)
13:10:17 <copumpkin> why not?
13:10:59 <ezyang> well, maybe case (length x) of 0 -> b | 1 -> b
13:11:00 <ncs> so a solution would be    f a b = do {x = length a ; b} ?
13:11:08 <ezyang> but it's not obvious to me that GHC wouldn't compile that away.
13:11:13 <copumpkin> yeah, except with 0 -> b; _ -> b
13:11:20 <keep_learning> ezyang, when ghc -i src/Snowfall/Spatial -prof -auto-all -o Measuretime Measuretime.hs  i am getting target `src/Snowfall/Spatial' is not a module name or a source file
13:11:51 <copumpkin> ezyang: you can do anything you want with it, really
13:11:55 <ezyang> keep_learning: No spaces.
13:12:01 <Jafet> Yeah, you don't need seq! Use pseq.
13:12:03 <copumpkin> ezyang: f xs a = if length xs >= 0 then a else a
13:12:08 <ezyang> also you probably want -isrc
13:12:15 <copumpkin> ezyang: case should force evaluation
13:12:34 <copumpkin> it may compile it using the Eq on Int but it'll still force the number
13:13:08 <ezyang> I don't think Haskell case is that strict...
13:13:21 <ezyang> but I have to check...
13:13:21 <copumpkin> ?
13:13:34 <copumpkin> how else can you evaluate a case statement?
13:13:44 <copumpkin> you need to decide which branch to follow
13:13:57 <jessopher> time travel
13:13:59 <copumpkin> are you saying it'll fuse the branches because they have equal output?
13:14:07 <copumpkin> and then make the case irrelevant?
13:14:17 <copumpkin> that'd kind of preclude ever writing Seq as a typeclass
13:14:44 <copumpkin> > case undefined of _ -> 5
13:14:45 <lambdabot>   5
13:14:52 <copumpkin> > case undefined of 0 -> 5; _ -> 5
13:14:53 <ezyang> Yeah.
13:14:54 <lambdabot>   *Exception: Prelude.undefined
13:15:01 <ezyang> So, in Core, the former also forces undefined.
13:15:09 <copumpkin> yeah, I'd expect it to
13:15:16 <copumpkin> > case undefined of !_ -> 5
13:15:17 <lambdabot>   *Exception: Prelude.undefined
13:15:21 <ezyang> "but that's cheating"
13:15:30 <copumpkin> yeah, I wasn't advocating a bang :)
13:15:41 <keep_learning> ezyang, why we to reinstall every time for profiling ?
13:15:51 <copumpkin> but as soon as I provide a "Constructor" in a pattern, it should force evaluation
13:15:55 <ezyang> keep_learning: It's a one time cost. Afterwards you won't need to.
13:15:57 <copumpkin> even if the constructor is fake like a number literal
13:16:01 <ezyang> copumpkin: Fair enough.
13:16:38 <Varakh> hi. im seeking a triple (x,y,z)  in a list [(a, Integer, a)] where x or y is a desired value i choose and y is minimal. any ideas?
13:16:56 <Varakh> need a list comprehension for that problem
13:16:58 <EvanR-work> filter min
13:17:09 <EvanR-work> uhg why
13:17:24 <EvanR-work> is list comprehensions only design purpose to create homework problems
13:17:29 <Varakh> no
13:17:42 <copumpkin> I like using list comps
13:17:49 <EvanR-work> you would
13:17:57 <donri> I like monad comps
13:18:05 <Varakh> copumpkin: so tell me how to solve this :p
13:18:06 <donri> and list monads
13:18:07 <shachaf> copumpkin: Are list comps like LISP machines?
13:18:09 <copumpkin> > let justs xs = [x | Just x <- xs] in justs [Nothing, Just 5, Nothing]
13:18:10 <lambdabot>   [5]
13:18:33 <benmachine> Varakh: first filter the list to get a list of all the (x,y,z) such that x or z is the value you choose
13:18:41 <benmachine> Varakh: then use minimumBy
13:18:47 <copumpkin> Varakh: I demand a type for your function
13:18:57 <benmachine> Varakh: and beware the empty list
13:19:04 <Eduard_Munteanu> ncs: if the type of the elements isn't polymorphic then you could combine those elements in some way.
13:19:19 <Eduard_Munteanu> Say, using 'sum' on the list.
13:21:52 <Varakh> id like to to it with one list comprehension :X
13:22:24 <ncs> length can be used for polymorphic, right?
13:22:29 <ncs> and it evaluates the whole list
13:22:29 <ezyang> ncs: Yes.
13:22:38 <ezyang> Only if its result is evaluated.
13:22:44 <ezyang> And only the spine of the list
13:22:45 <benmachine> ncs: depends what you mean by evaluating the whole list - the elements are still unevaluated
13:22:49 <ezyang> > [undefined, undefined]
13:22:50 <lambdabot>   [*Exception: Prelude.undefined
13:22:54 <ncs> oh, yes
13:22:58 <benmachine> > length [undefined, undefined]
13:22:59 <ezyang> > length [undefined, undefined]
13:22:59 <lambdabot>   2
13:23:00 <lambdabot>   2
13:23:05 <EvanR-work> also
13:23:10 <EvanR-work> > length [undefined, undefined]
13:23:11 <lambdabot>   2
13:23:20 <shachaf> > length [defined, undefined]
13:23:22 <lambdabot>   2
13:23:31 <EvanR-work> lol
13:23:32 <benmachine> :t defined
13:23:33 <Axman6> > defined
13:23:34 <lambdabot> ()
13:23:35 <lambdabot>   ()
13:23:38 <applicative> > > length [defined, error "undefined"]
13:23:39 <lambdabot>   <no location info>: parse error on input `>'
13:23:39 <benmachine> heh
13:23:40 <jessopher> haha
13:23:44 <applicative> >  length [defined, error "undefined"]
13:23:46 <lambdabot>   2
13:24:03 <shachaf> > length [undefined, length]
13:24:04 <lambdabot>   2
13:24:11 <jessopher> > length $ defined:undefined
13:24:13 <lambdabot>   *Exception: Prelude.undefined
13:24:30 <ncs> the functions `or` and `and` are lazy functions right?
13:24:33 <benmachine> ncs: I don't know if anyone ever pointed out to you that 'let' never evaluates anything
13:24:44 <EvanR-work> everything is lazy in haskell!
13:24:47 <benmachine> ncs: er, depends what you mean by lazy
13:24:53 <EvanR-work> benmachine: i tried to
13:25:03 <benmachine> ncs: 'or' and 'and' don't evaluate any more than they need to
13:25:08 <Axman6> > or [True,undefined, undefined]
13:25:10 <lambdabot>   True
13:25:15 <Axman6> > or [False,undefined, undefined]
13:25:16 <lambdabot>   *Exception: Prelude.undefined
13:25:21 <applicative> > or [True, undefined]
13:25:22 <benmachine> but they are strict in the sense that they need to look at the first element of the list to produce an answer
13:25:22 <lambdabot>   True
13:25:27 <benmachine> > or undefined
13:25:28 <lambdabot>   *Exception: Prelude.undefined
13:25:36 <copumpkin> benmachine: you might say that they do
13:25:38 <benmachine> (at /least/ the first element, of course)
13:25:54 <benmachine> copumpkin: you might do, but I'm not gonna, so there
13:25:56 <copumpkin> benmachine: a nicer definition of or and and might be symmetric
13:25:57 <copumpkin> lol
13:25:58 <copumpkin> :P
13:26:03 <Miden> :t foldr (||) False
13:26:04 <lambdabot> [Bool] -> Bool
13:26:22 <benmachine> copumpkin: foldr por?
13:27:30 <cgroza> As I have read, in haskell, multiple argument functions are just functions that take one argument and return another function that takes and argument and so on. Does this translate into multiple function calls at runtime.
13:27:34 <cgroza> ?
13:27:46 <ezyang> cgroza: GHC tries to optimize it away
13:27:48 <Botje> no
13:28:00 <ezyang> But function application is cheap. Don't fear it.
13:28:03 <Axman6> ghc doesn't even use call instructions does it? just jumps?
13:28:14 <ezyang> All jumps :-)
13:28:22 <Axman6> boing!
13:28:34 <cgroza> Ok. Thanks for the clarification.
13:28:48 <benmachine> plus, ghc sometimes compiles functions as if they take multiple arguments, I believe
13:28:53 <benmachine> even if conceptually they don't
13:29:34 <Eduard_Munteanu> ncs: length evaluates the whole *spine* only
13:29:38 <cgroza> If it uses jumps, how does a function return then? Is the call ret combination emulated in another way?
13:29:54 <ezyang> cgroza: Haskell code is compiled into CPS style.
13:29:58 <Clint> http://hackage.haskell.org/packages/archive/time/1.2.0.3/doc/html/Data-Time-Clock.html
13:30:11 <Clint> why does that list a Show UTCTime instance when none is defined?
13:30:25 <ezyang> So a return is really a jump to the next continuation on the stack
13:30:35 <copumpkin> @tell kfish I'm currently thinking I want a nice disk-based (i.e., I can query it without reconstructing it in memory first) b-tree at for every "keyframe" :)
13:30:36 <lambdabot> Consider it noted.
13:30:38 <Varakh> head (sortBy order (filter (\v (x,y,z) -> snd == v || trd == v) e)), is it okay? i defined trd btw. order is also okay
13:31:02 <ezyang> Varakh: I don't think that works
13:31:11 <Eduard_Munteanu> cgroza: Haskell code doesn't really follow any ABI remotely-similar to the stuff you'd be used with from C.
13:31:11 <Axman6> Varakh: snd is a function
13:31:21 <Axman6> > snd (1,2)
13:31:22 <lambdabot>   2
13:31:28 <Varakh> i defined it for triples
13:31:37 <cgroza> Thanks. I will take a closer look at the CPS style :D .
13:31:51 <benmachine> Clint: there is one, but it might not be in that module
13:31:52 <Botje> cgroza: there's a great book on 'compiling with continuations' by Andrew Appel
13:31:57 <benmachine> Clint: try importing Data.Time directly
13:32:19 <Clint> benmachine: ah, thanks
13:32:23 <copumpkin> @tell kfish I realize that's probably an unrealistic request for your library, so I'll probably just punt on it for now :P
13:32:24 <lambdabot> Consider it noted.
13:32:29 <cgroza> Botje: thank you for your suggestion.
13:32:39 * jessopher feels like such a compiler noob
13:32:47 <Axman6> Varakh: also, snd only works on 2-tuples, not three-tuples
13:33:07 <Varakh> look at what ive said
13:33:09 <Varakh> -.-'
13:33:13 <Varakh> (22:56:26) Varakh: i defined it for triples
13:33:28 <benmachine> Clint: if the library was better-written this wouldn't happen (or maybe there's a good reason for it to be like that, I don't know)
13:33:43 <Varakh> three-TUpels ? :p
13:33:56 <benmachine> Varakh: your filter predicate is the wrong type
13:33:57 <Axman6> Varakh: That doesn't meant you're still not wrong. I think I'll stop helping you
13:34:04 <applicative> Varakh:  why  not just ... filter (\v (x,y,z) -> x == v || y == v) e ... anyway?
13:34:21 <Axman6> :t filter
13:34:22 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:34:23 <Axman6> that's why
13:34:28 <applicative> wrong type indeed
13:34:29 <benmachine> applicative: I was going to suggest that but then I realised the first argument to filter really shouldn't have two parameters
13:34:51 <applicative> no, Varakh is playing with our minds
13:34:56 <Varakh> :>
13:35:12 <benmachine> Varakh: probably you want something more like filter (\ (x,_,z) -> x == v || z == v)
13:35:18 <benmachine> with v defined in some outer context
13:35:32 <Varakh> ye
13:35:48 <Varakh> thanks
13:36:11 <Varakh> func e v = head (sortBy order (filter (\(x,_,z) -> x == v || y == v) e))?
13:36:44 <Axman6> you tell us
13:36:48 <applicative> what is order?
13:36:52 <Varakh> i think its okay
13:36:55 <Varakh> its just my order
13:37:09 <Varakh> to sort (x,y,z) by y
13:37:10 <applicative> the list you are taking the head of, what is its type?
13:37:14 <Varakh> this works anyway :D
13:37:23 <Varakh> [(a, Integer, a)]
13:37:34 <Varakh> func :: [(a, Integer, a)] -> a -> (a, Integer, a)
13:40:05 <Varakh> applicative: ?? ;> good to know, isnt it? :D
13:41:34 <jessopher> that type couldnt possibly be correct (but i can imagine the correct one)
13:41:47 <Varakh> ?
13:42:00 <jessopher> you are missing a constraint on 'a'
13:42:07 <Varakh> ?
13:42:11 <Varakh> its v ?
13:42:17 <jessopher> Eq a => ...
13:42:18 <Axman6> >_<
13:42:21 <Varakh> ye
13:42:23 <applicative> you are using ==
13:42:30 * Axman6 looks away until the pain stops
13:42:47 * applicative is not feeling any pain, somehow
13:42:48 <Varakh> its defined in a class WHERE (Ord a, Eq) is defined jessopher, thanks
13:43:00 <EvanR-work> i eat missing constraints for breakfast
13:43:12 <Varakh> ;>
13:43:16 <jessopher> tricky
13:43:37 <Varakh> how do i do it correctly without using == ?
13:44:17 <jessopher> i don't think you could, unless you had some other alien means of constraining a
13:44:32 <Varakh> k
13:44:43 <EvanR-work> use Ord
13:44:54 <EvanR-work> ah, Eq is a subclass of Ord ;)
13:45:04 * jessopher slaps head again
13:45:11 <applicative> ?
13:45:12 <applicative> missed breakfast
13:46:11 <EvanR-work> myEq = new Eq(3);
13:46:18 <applicative> Varakh: do you have reason to avoid Eq, other than that booleans are kind of icky?
13:46:44 <Botje> don't put all your Eqs in one basket
13:48:25 <Axman6> how do you all pronounce Eq anyway? I've always said ee-queue
13:48:39 <jessopher> equalable, lol
13:48:50 <aavogt> eek
13:48:52 <EvanR-work> wtf, everyone says 'ek' ;)
13:48:54 <applicative> data Basket where Basket :: Eq a => a -> Basket
13:49:10 <waern> I say ee-queue too
13:49:24 <aavogt> is the basket useful at all?
13:49:31 * jessopher follows the first rule of fight club usually
13:49:39 <aavogt> since yu can't compare two baskets, right?
13:50:10 <applicative> aavogt: no, Botje has already advised against it. I guess its no worse than ()
13:50:26 <applicative> wait, i guess it is worse
13:50:41 <Axman6> i just read this whole thing, and I want my money back http://whalliburton.github.com/academy/ the title on hacker news was "Can your REPL do this?". Yes
13:51:07 <shurikas> The Reader monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment.
13:51:12 <shurikas> what is a shared environment?
13:51:30 <applicative> what does the magic repl do?
13:52:14 <applicative> shurikas: suppose it reads a config file before running
13:52:22 <Axman6> shurikas: think of it as a a variable that can be read at any time in the computation,. but not set. it's useful for if you've leaded up some settings for your app, that you then want to pass around without having to pass it explicitly
13:52:48 <shurikas> so in other words - it's a global variable?
13:52:57 <applicative> shurikas: in a State monad, you have the same thing, but you keep resetting the state
13:53:04 <shurikas> I am trying to understand latest solution: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
13:53:12 <shurikas> "asks socket" just returns a Handle
13:53:13 <applicative> shurikas: well, the idea is that you don't mutate it, so to say.
13:53:17 <rwbarton> a global variable except it's not really global or a variable
13:53:28 <shurikas> so how can I "set" that variable?
13:53:39 <EvanR-work> by running the reader
13:53:40 <rwbarton> @hoogle runReader
13:53:41 <lambdabot> Control.Monad.Trans.Reader runReader :: Reader r a -> r -> a
13:53:41 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
13:53:41 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r a -> r -> m a
13:53:44 <shurikas> runReader, ok
13:53:49 <hpaste> keep_learning annotated “Haskell program profiling” with “Haskell program profiling (annotation) (annotation)” at http://hpaste.org/54965#a54970
13:54:02 <keep_learning> hello all
13:54:05 <shurikas> ok, thanks
13:54:43 <keep_learning> finally i have re installed all the required library but getting some new error
13:55:01 <keep_learning> any one please http://hpaste.org/54965
13:55:10 <Axman6> shurikas: Reader is basically the State monad, without being able to modify the state
13:55:26 <shurikas> and without passing the state
13:55:33 <applicative> @unmtl ReaderT Bot IO ()
13:55:33 <lambdabot> Bot -> IO ()
13:55:42 <shurikas> just reading it
13:55:52 <Axman6> eh? the state gets passed around in exactly the same way as in State
13:56:04 <shurikas> hmm
13:56:12 <shurikas> then I need to read about state monads again
13:56:12 <Axman6> @src (>>=) Reader
13:56:13 <lambdabot> Source not found. You speak an infinite deal of nothing
13:56:15 <Axman6> @src (>>=) ReaderT
13:56:15 <lambdabot> Source not found. My mind is going. I can feel it.
13:56:18 <Axman6> :(
13:56:34 <applicative> keep_learning: does your cabal file instruct cabal install to use profiling?
13:56:58 <Axman6> the Reader monad is the same as the ((->) r) monad right?
13:57:09 <Saizan> yep
13:57:10 <applicative> keep_learning: I mean mean your ~/.cabal/config file, if thats what its called
13:57:53 <mm_freak_> shurikas: State resembles:  s -> (a, s)
13:57:58 <mm_freak_> Reader resembles:  s -> a
13:57:59 <keep_learning> applicative, yes
13:58:10 <keep_learning>  i changed to trur
13:58:14 <keep_learning> true
13:58:18 <mm_freak_> you get passed an implicit state value…  in State you can return a new one
13:58:22 <Axman6> yeah, I forgot about the fact that Reader doesn't pass on the state like that
13:58:48 <keep_learning> applicative, library-profiling: True
13:59:12 <keep_learning> applicative, however -- executable-dynamic: False
13:59:16 <applicative> Oh i see you are talking about the missing Snowfall... file
13:59:17 <mm_freak_> shurikas: open a source file and type:  newtype State s a = State (s -> (a, s))
13:59:27 <mm_freak_> shurikas: then define Functor and Monad instances (and perhaps Applicative)
13:59:34 <mm_freak_> if you succeed, you have understood state monads
14:00:02 <shurikas> hm, ok, sounds like a good exercise
14:00:07 <keep_learning> applicative, Now i am at the parent of src and test and doing compilation
14:00:33 <mm_freak_> shurikas: or rather not "if", but /when/ =)
14:00:52 <applicative> right, i see i was looking at the first paste, but it looks like you should be a directory back, ghc is looking for a directory Snowfall, and doesn'tknow it's in one?
14:00:57 <benmachine> mm_freak_: that's not /entirely/ true. I could define a Cont monad long before I understood what it did
14:01:20 <benmachine> (still don't /completely/ understand tbh >_>)
14:01:21 <mm_freak_> benmachine: yes, but state monads are really not as crazy as cont monads
14:01:46 <applicative> keep_learning: maybe that's not right, it always takes me three times to get this right :)
14:01:55 <keep_learning> applicative, no problem :)
14:02:01 <benmachine> mm_freak_: well, sure, just pointing out that there may be extra work in understanding the thing
14:02:12 <keep_learning> applicative, i am still waiting for right answer :)
14:02:16 <benmachine> although what you said is definitely a valuable exercise regardless
14:03:18 <mm_freak_> benmachine: for me the enlightenment came mostly by implementing things myself…  types are usually very descriptive in haskell
14:04:44 <mm_freak_> benmachine: including cont monads btw =)
14:04:57 <benmachine> mm_freak_: lucky you? :P
14:05:26 <mm_freak_> benmachine: in fact, after understanding a new concept, i tend to turn it into a complicated, powerful library =)
14:05:30 <mm_freak_> see contstuff =)
14:06:07 <shurikas> no way I can define instances for a state monad... :(
14:06:20 <mm_freak_> shurikas: start with Functor and read the type signature
14:06:21 <shurikas> I should try doing it for an easier monad
14:06:37 <shurikas> I read it, probably that wasn't enough
14:06:39 <mm_freak_> but yes, start with this instead:  newtype Reader e a = Reader (e -> a)
14:06:50 <shurikas> I'll start with functors
14:06:53 <shurikas> then applicative functors
14:07:05 <shurikas> all the way up :|
14:07:47 <mm_freak_> just think simple
14:08:06 <mm_freak_> fmap gets a regular function and a function wrapped in the Reader constructor
14:08:06 <applicative> keep_learning: hm, i don't have experience with this
14:08:16 <mm_freak_> fmap f (Reader g) = ...
14:08:23 <keep_learning> applicative, thank you for you time
14:08:30 <mm_freak_> now f mapped over g is really just f applied to the result of g
14:08:38 <mm_freak_> try it
14:09:00 <keep_learning> Some one please tell me how to solve this issue http://hpaste.org/54965
14:09:08 <shurikas> well, so far it does not make me much sense :D
14:09:21 <shurikas> I mean why and how monads can solve problems
14:09:27 <shurikas> but I will get there
14:09:46 <mm_freak_> don't think about the generic term "monad"
14:09:58 <mm_freak_> really concentrate on specific instances
14:10:25 <mm_freak_> many monads are based on functions, but perhaps you should just start with simpler monads:  monads based on values
14:10:40 <mm_freak_> newtype Option a = Some a | None
14:10:48 <shurikas> monads seems just like some kind of 'templates' of function processing
14:10:57 <mm_freak_> equivalent to the predefined Maybe, but gives you the opportunity to define your own instances =)
14:10:58 <shurikas> don't know how else to describe it
14:11:23 <salisbury> for me, monads really clicked when I stopped trying to force myself to understand
14:11:25 <hpaste> RoaldFre pasted “ST s and STUArray s” at http://hpaste.org/54971
14:11:25 <mm_freak_> well, it's close…  monads generalize a composition pattern, but really, don't think about it that way now
14:11:37 <roaldfre> Ugh, I can't get my head around the ST monad and STUArrays
14:11:43 <salisbury> turns out you will use them intuitively when you need to
14:11:58 <shurikas> and most of the monads I've seen in a book are almost the same
14:12:09 <danr> when you do runST you s is lost
14:12:12 <shurikas> so can't figure out how they are so powerful (As described)
14:12:55 <salisbury> checkout the co-routine here:
14:12:57 <shurikas> well, maybe I should just write a program in a bad way and when I will be comfortable enough with Haskell itself, will go to monads
14:12:57 <salisbury> http://random.axman6.com/blog/?p=231
14:13:15 <Axman6> :o
14:13:23 <salisbury> that shows a bit more monad-power than most books
14:13:29 <roaldfre> danr: so should I store the new array within an ST s wrapper?
14:13:30 * Axman6 didn't write that
14:13:41 <mm_freak_> shurikas: consider this:  most data/control structures you use in haskell are defined in terms of library functions, including exceptions, goto, nondeterminism, null, continuations, state, etc.
14:13:50 <mm_freak_> shurikas: in other languages those are built into the language
14:13:54 <salisbury> Axman6: you didn't?
14:14:03 <Axman6> no, guest author
14:14:05 <xplat> sequence ["abc", "123"]
14:14:10 <xplat> > sequence ["abc", "123"]
14:14:11 <salisbury> Axman6: d'oh
14:14:11 <lambdabot>   ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
14:14:20 <Axman6> > replicateM 5 "01"
14:14:21 <lambdabot>   ["00000","00001","00010","00011","00100","00101","00110","00111","01000","0...
14:14:39 <xplat> > sequence [Just 1, Just 2]
14:14:40 <lambdabot>   Just [1,2]
14:14:40 <mm_freak_> shurikas: it turns out that most of those are really based on the same composition pattern, which is encoded mainly by the (>>=) function
14:14:52 <shurikas> well, I understand >>=
14:14:54 <Axman6> > replicateM 2 (['0'..'9']++['A'..'F'])
14:14:54 <hpaste> danr annotated “ST s and STUArray s” with “ST s and STUArray s (annotation)” at http://hpaste.org/54971#a54972
14:14:56 <lambdabot>   ["00","01","02","03","04","05","06","07","08","09","0A","0B","0C","0D","0E"...
14:15:03 <danr> roaldfre: I annotated your paste
14:15:25 <shurikas> m a -> (a -> m b) -> m b
14:15:27 <shurikas> I think...
14:15:34 <danr> roaldfre: but what do you want to do?
14:15:40 <shurikas> @hoogle (>>=)
14:15:40 <mm_freak_> shurikas: and if you understand "return" in addition, then you have understood monads…  the concept of monads is really just this composition pattern, nothing more, nothing less
14:15:41 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:15:41 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:15:41 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:15:58 <shurikas> mm_freak_, just a value inside a context
14:16:08 <xplat> > flip runState x $ sequence [ modify (+1) , modify (*2) ]
14:16:10 <shurikas> and these functions are just a way to extract a value from a monad
14:16:11 <lambdabot>   ([(),()],(x + 1) * 2)
14:16:13 <roaldfre> danr: Thanks! I'm writing a rasterizer and I need to store the rasterized image and zbuffer somewhere in the state of my rasterizer
14:16:24 <shurikas> and writing instance of monad means just to support abstract monad syntax. Right?
14:16:33 <mm_freak_> shurikas: that's one way to look at it, but it can break down…  my personal intuition is:  a monadic value is an effectful value
14:17:01 <mm_freak_> shurikas: extracting the value may cause effects (not /side/ effects, just effects)
14:17:05 <danr> ok, remember you can turn your ST s (STUArray s Int Dobule) to an immutable unboxed array with runSTUArray
14:17:20 <mm_freak_> shurikas: the effect of extracting the value out of Maybe is that there may not be a value
14:17:21 <danr> (or do whatever you feel like with runST)
14:17:40 <xplat> > flip map x $ sequence [(+1), (*2)]
14:17:42 <lambdabot>   Couldn't match expected type `[a]'
14:17:42 <lambdabot>         against inferred type `SimpleRef...
14:17:46 <mm_freak_> shurikas: but that's just the intuition that works best for me…  it may not work for you at all
14:18:07 <shurikas> it's like supporting failures
14:18:08 <danr> roaldfre: but you cannot save an STUArray (as such) if you do runST on it
14:18:10 <xplat> > flip map ($x) $ sequence [(+1), (*2)]
14:18:11 <lambdabot>   The section `GHC.Base.$ SimpleReflect.x' takes one argument,
14:18:11 <lambdabot>  but its type ...
14:18:28 <shurikas> in a way that haskell is pure and function always returns the same results, monads introduce failures and their handling
14:18:28 <mm_freak_> shurikas: and it's much too general, because there are many other abstractions that encode effectful values…  monads are just a particularly powerful one
14:18:39 <roaldfre> danr: I see, you could only make it into a strict (immutable) one, that way, right?
14:19:03 <mm_freak_> shurikas: no, just effects…  the effects may be anything
14:19:18 <Axman6> shurikas: I'd disagree with that, monads are far more general than that. they don't really have anything to do with failure (though certain instances do)
14:19:20 <salisbury> Axman6: you should push out some more articles. I like that blog
14:19:32 <mm_freak_> shurikas: an effect of Cont is taking a shortcut in the computation…  an effect of [] is that you may actually get multiple values
14:19:34 <roaldfre> So I should keep the ST wrapper on in the internals of my code, and use runST to read/write data from/to the array
14:19:35 <mm_freak_> etc.
14:19:56 <xplat> > sequence [(+1), (*2)] x
14:19:57 <lambdabot>   [x + 1,x * 2]
14:20:03 <shurikas> well, [] implementation of >>= is a map
14:20:03 <keep_learning> some one please help me
14:20:10 <keep_learning> i am not able to compile the code
14:20:14 <mm_freak_> shurikas: concatMap to be exact
14:20:18 <keep_learning> for profiling
14:20:43 <Axman6> salisbury: yeah, I'm considering doing one soon, if I'm allowed to release this work i'm doing that's reading power usage of a power meter using Haskell
14:20:53 <copumpkin> > flip [(+1), (*2)] x
14:20:55 <lambdabot>   [x + 1,x * 2]
14:20:57 <Axman6> it was surprisingly easy
14:21:14 <xplat> > runWriter $ sequence [tell "hello", tell "world"]
14:21:15 <lambdabot>   ([(),()],"helloworld")
14:21:21 <shurikas> does monads make a way to pass variables around transparently?
14:21:24 <danr> roaldfre: yes, but you can write functions in the ST monad, and manipulate your arrays.
14:21:39 <Axman6> shurikas: they can be used for that
14:21:47 <mm_freak_> shurikas: no…  the point of the Monad type class is to allow you to create and compose effectful values
14:21:50 <shurikas> and that would be state monad
14:21:53 <copumpkin> shurikas: monads don't really give you anything
14:22:02 <copumpkin> shurikas: monads are a pattern that a bunch of different things fit into
14:22:28 <roaldfre> danr: OK, I think I'm beginning to understand it. And I'll need to keep the 's' in my State data type (will be wrapped in state monad)..
14:22:31 <copumpkin> shurikas: they don't give you the ability to do anything you couldn't do without them, except to write functions that work on all of them
14:22:32 <salisbury> Axman6: That sounds interesting, hopefully you'll get the go-ahead.
14:22:51 <xplat> shurikas: like the 'sequence' function i've been demonstrating
14:23:04 <mm_freak_> shurikas: i really recommend to try to implement some monads
14:23:10 <copumpkin> shurikas: monads are just a common interface that different types might (or might not) satisfy
14:23:35 <salisbury> Axman6: Other than irc, haskell has a pretty low profile and very few communities (at least around Ontario). It's good to have a good article
14:23:53 <shurikas> so what's the difference in my code if I don't use monads? it's messy and I write much more? or it's not that effective?
14:24:13 <shurikas> I see it only as a way of abstraction
14:24:14 <mm_freak_> shurikas: it depends on what you are doing
14:24:14 <copumpkin> shurikas: it might be a little more verbose and you might reinvent the wheel, but otherwise nothing
14:24:32 <Axman6> shurikas: if you're using the Maybe monad, it's much clearer than having top use explicit case statements everywhere
14:24:49 <mm_freak_> shurikas: beginners often make the mistake to assume that State is something great giving you (back) the power to deal with state
14:24:50 <shurikas> ok then, I'll reinvent it. Hell, I should reinvent the whole Haskell library just for the sake of learning :)
14:25:03 <mm_freak_> shurikas: i as a haskell user for many years never use a state monad =)
14:25:25 <mm_freak_> sometimes i use StateT as part of a larger abstraction, but never State
14:25:40 <shurikas> well I see a way not to use a state monad in my program
14:25:44 <mm_freak_> shurikas: yes, do it…  i've done that, too =)
14:25:54 <shurikas> hehe :)
14:26:02 <mm_freak_> a way not to use a state monad is easy:  just pass the state explicitly
14:26:07 <shurikas> yeah...
14:26:20 <xplat> mm_freak_: yeah, but then you might as well use it
14:26:30 <shurikas> It just seems somehow wrong then I already have three functions with same declaration :)
14:26:39 <mm_freak_> since 'newtype State s a = State (s -> (a, s))', a value of type 'State s a' is really just a function of type 's -> (a, s)'
14:26:47 <shurikas> Handle -> IO ()
14:27:06 <mm_freak_> xplat: i find explicit passing more convenient in haskell
14:27:23 <hpaste> RoaldFre annotated “ST s and STUArray s” with “ST s and STUArray s (annotation) (annotation)” at http://hpaste.org/54971#a54973
14:27:28 <Cale> shurikas: Well, that's a pretty general type. :)
14:27:42 <Cale> shurikas: There are a *lot* of functions of type Handle -> IO ()
14:28:02 <mm_freak_> void (hGetContents h)
14:28:03 <mm_freak_> =P
14:28:39 <xplat> Cale: i'm particularly fond of my 'write the Gettysburg Address, or Monty Python's parrot sketch if it's a new moon' Handle -> IO () function
14:28:43 <roaldfre> danr: I gave some more info on what I'm trying to do -- Lots of thanks for the help thus far, I'll be back again if I have more questions! :-)
14:29:17 <shurikas> ok, thanks for opinions, guys
14:29:52 <shurikas> somebody mentioned community a few minutes ago...
14:30:03 <salisbury> indeedio
14:30:04 <shurikas> now I wonder about an estimate of how much people actually use haskell
14:30:14 <mm_freak_> shurikas: you may try to define instances for the simplest monad possible:  data Unit a = Unit
14:30:28 <mm_freak_> yes, it's a proper monad =)
14:30:34 <salisbury> at least 849, it would appear from IRC
14:30:35 <shurikas> doesn't seem so
14:30:55 <danr> roaldfre: i annotated your paste again with some (silly) examples: http://hpaste.org/54971
14:31:01 <mm_freak_> shurikas: the effect of this monad is that there is never a value
14:31:10 <danr> roaldfre: oh I see you did too :)
14:31:10 <shurikas> then why give it a type?
14:31:11 <xplat> Cale: does lambdabot have a newtype for the (Integer, (+), 0) monoid?
14:31:23 <mm_freak_> shurikas: it's an exercise
14:31:52 <xplat> shurikas: it's like the Maybe monad, but without Just
14:32:18 <xplat> so instead of 'either succeed or fail', you get 'always fail'
14:32:22 <shurikas> :))
14:32:27 <danr> roaldfre: i don't really think you need to have stateImage and stateZbuf in ST, i think stateImage :: Image s and stateZbuf :: Zbuffer s would be enough
14:32:28 <mm_freak_> shurikas: obviously it's quite a useless monad (except for theoretical purposes), but it's a useful exercise to define Functor/Applicative/Monad instances for it
14:32:56 <Cale> xplat: lambdabot doesn't, but Data.Monoid does
14:33:01 <applicative> data UnitT m a = Unit
14:33:18 <Cale> > getSum (mconcat [Sum 1, Sum 2, Sum 3])
14:33:20 <lambdabot>   6
14:33:34 <Cale> ;)
14:34:15 <Axman6> :t ala
14:34:16 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
14:34:41 * applicative was going to recommend Data.Newtype but was getting lost 
14:34:50 <hpc> @src Newtype
14:34:50 <lambdabot> Source not found. I am sorry.
14:34:59 * Axman6 can't remember how to use ala
14:35:06 <Axman6> :t ala Sum
14:35:08 <lambdabot>     Ambiguous occurrence `Sum'
14:35:08 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
14:35:08 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
14:35:14 <keep_learning> applicative, looks like currently no one in mood  to help me :(
14:35:14 <hpc> ala Foo foldMap ...
14:35:15 <Axman6> -_-
14:35:37 <Axman6> :t ala Control.Monad.RWS.Sum
14:35:38 <lambdabot> forall o b n' o'. (Newtype n' o') => ((o -> Control.Monad.RWS.Sum o) -> b -> n') -> b -> o'
14:35:47 <xplat> are there any functions you can use with ala other than foldMap?
14:35:47 <mm_freak_> shurikas: also the Unit monad is not entirely useless in practice…  many control structures let you choose a custom functor for a particular purpose…  Unit then kind of acts like the "ignore this library feature" monad
14:36:33 <hpaste> shurikas pasted “Unit” at http://hpaste.org/54975
14:36:36 <Saizan> ?type \f -> ala f traverse
14:36:38 <lambdabot> Not in scope: `traverse'
14:37:25 <mm_freak_> shurikas: don't write 'fail', but otherwise your definition is correct (disregarding (>>=)'s strictness on its first argument)
14:37:28 <ncs> :q
14:37:39 <shurikas> ahh, ok
14:37:45 <shurikas> it should ignore everything
14:38:04 <hpaste> applicative annotated “Unit” with “Unit (annotation)” at http://hpaste.org/54975#a54976
14:38:20 <mm_freak_> shurikas: most monads are only proper monads, if you assume that 'seq' doesn't exist
14:38:22 <shurikas> damn copycat!
14:38:23 <mm_freak_> so it's fine
14:38:58 <mm_freak_> shurikas: now do the same for:  newtype Identity a = Identity a
14:39:01 <hpaste> applicative annotated “Unit” with “Unit (annotation) (annotation)” at http://hpaste.org/54975#a54977
14:39:09 <hpc> mm_freak_: a lot of theory explodes in the presence of seq
14:39:16 <shurikas> and each time make it a bit more difficult :)
14:39:18 <shurikas> ok...
14:39:42 <mm_freak_> applicative: i don't think you're helping…  no offense
14:40:05 <xplat> hpc: a lot of theory explodes in the presence of _|_, seq just sets off secondary explosions
14:41:06 <shurikas> ok guys, thanks. I'll go to do some planking for approx. 7.5 hours in bed now...
14:41:19 <copumpkin> planking doesn't sound like a very comfortable way to sleep
14:41:22 <copumpkin> what do you plank on?
14:41:26 <applicative> planking?
14:41:44 <copumpkin> http://www.holytaco.com/wp-content/uploads/2011/05/123929-planking1.jpg
14:42:22 <applicative> isn't the question, what do you plank between?
14:42:29 <copumpkin> applicative: not necessarily
14:42:42 <copumpkin> http://planking.mobi/wp-content/uploads/2011/05/planking-heineken-mini-keg.jpg
14:43:14 <copumpkin> omg it's a kfish
14:43:20 <copumpkin> kfish: you were kidding about the semigroupoid, right?
14:43:57 * applicative is not convinced planking merits a name at all
14:44:08 <copumpkin> applicative: it even has a wikipedia page
14:44:15 <copumpkin> ergo it is notable
14:44:16 <mike-burns> Is this planking discussing the beginning of our "2011 in review" retrospective?
14:44:23 <copumpkin> mike-burns: yep
14:45:28 <xplat> if planking doesn't deserve a name, what about dogging?  snorkeling?  parkour?
14:45:29 <DanBurton> @remember xplat a lot of theory explodes in the presence of _|_, seq just sets off secondary explosions
14:45:30 <lambdabot> I will never forget.
14:45:43 * applicative considers whether monads are kind of like planking
14:45:55 <hpc> xplat: uniconing definitely deserves the name
14:46:10 <roaldfre> danr: That's what I thought initially, and what I was trying to do -- but then I don't know how to create, use and store them within my Render monad [I annotated with some more skeleton]
14:47:25 <xplat> hpc: thank you, i hadn't heard about that :)
14:49:31 * applicative refuses to read the 34 comments on the type variable naming controversy
14:50:02 <xplat> there's a controversy now?
14:50:25 <xplat> aren't they just all called a?
14:50:56 <hpc> xplat: some of them are called m
14:51:37 * applicative concedes that he does oppose camel case type variables
14:51:59 <mm_freak_> =λ> being colazy with class
14:52:21 <mm_freak_> =λ> Ntrolling Coreclaim
14:53:04 <mercury^> Is the monad (M a) with (M a) b = (b -> a) -> a ever used?
14:53:21 <mm_freak_> mercury^: sounds like Cont and yes
14:53:38 <xplat> yes, Cont, also known as parameterized double negation
14:54:08 <shachaf> It's used when you can't make up your mind about what monad you want.
14:54:10 <mercury^> That monad is a complete mindfuck.
14:54:12 <xplat> (normal intuitionistic double negation is Cont Void)
14:54:17 <shachaf> It's the "all of the above" option.
14:54:34 <fcul> hi
14:54:42 <Eduard_Munteanu> fcul: hi
14:54:47 <mm_freak_> mercury^: it's not that complicated, if you boil it down to:  a value that is passed to a function given to it
14:55:00 <copumpkin> how about this monad? has anyone here used it? :P
14:55:01 <copumpkin> newtype J r a = J {unJ :: ((a -> r) -> a)}
14:55:39 <mercury^> mm_freak_: I don't understand that description.
14:55:45 <xplat> somebody has used it, and i think you know who
14:55:58 <mm_freak_> mercury^: return x = Cont (\k -> k x)
14:56:05 <Philonous> copumpkin:  Wasn't that thing called search?
14:56:17 <copumpkin> Philonous: with r instantiated to Bool
14:56:25 <mm_freak_> mercury^: if you only define the Monad instance and have no special functions, then it acts like Identity
14:56:47 <xplat> mercury^: a ‘Cont r a’ is a way to, given a function to turn an a into an r, get an r
14:56:49 <mm_freak_> mercury^: the only difference is that you pass it a continuation, and it doesn't return its result directly, but passes it to the continuation it receives
14:57:13 <mm_freak_> mercury^: runCont (return 3) id = 3
14:57:24 <xplat> the most obvious thing it can do is to make an a, and pass it to the given function to get an r, and return that
14:57:30 <mm_freak_> because return 3 = Cont (\k -> k 3), now k = id
14:57:51 <copumpkin> I love how sneaky it can be though
14:57:57 <xplat> but it can also just make its own r and return it
14:58:00 <Eduard_Munteanu> copumpkin: what's that? Is it related in any way to the type theory J?
14:58:04 <copumpkin> no
14:58:09 <mm_freak_> mercury^: the big difference is that for regular functions "the future" of the result value depends on where the function is used
14:58:09 <fcul> Quick question (or not...): I have Data State = Initial Float   and  floatToState :: Float -> State   I need to "instantiate" a State Initial (as in using a "constructor" - Java analogy) from a float using floatToState
14:58:23 <copumpkin> Eduard_Munteanu: search for J monad andrej :)
14:58:25 <mm_freak_> mercury^: with Cont, you get access to the future of the result in terms of 'k'
14:58:27 <xplat> or make several a's, use them to make r's, and combine the r's into one r to return
14:58:30 <Eduard_Munteanu> Ah, thanks.
14:58:38 <mm_freak_> copumpkin: i don't understand your monad
14:58:39 <mm_freak_> what is it?
14:59:02 <copumpkin> mm_freak_: have you read the seemingly impossible functional programs blog post?
14:59:04 <xplat> or just use the function once, and do something to the r before returning it
14:59:17 <mm_freak_> copumpkin: nope, where do i find it?
14:59:29 <fcul> Quick question (or not...): I have Data State = Initial Float   and  floatToState :: Float -> State   I need to "instantiate" a State Initial (as in using a "constructor" - Java analogy) from a float using floatToState
14:59:29 <Eduard_Munteanu> @google "j monad" andrej
14:59:31 <lambdabot> http://www.reddit.com/r/haskell/comments/9clsr/wanted_applications_of_the_j_monad/
14:59:31 <lambdabot> Title: Wanted: Applications of the J monad : haskell
14:59:32 <copumpkin> mm_freak_: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
14:59:36 <applicative> mm_freak_: oh you haven't lived
14:59:36 <Eduard_Munteanu> Looks like a starting point.
14:59:54 <benmachine> fcul: ...what's the problem?
15:00:09 <benmachine> fcul: I'm not sure what instantiate means in this context
15:00:35 <mm_freak_> applicative: i thought that Auto over Kleisli (ContT r (LogicT m)) is mindblowing enough =)
15:01:51 <fcul> benmachine: I need to do something like    (State)Init a = floatToState()
15:02:41 <MostAwesomeDude> Ugh, curious. Can cereal do signed/unsigned types or just Words?
15:02:42 <Eduard_Munteanu> fcul: data State = Initial Float ? If so, then you already have a State.
15:02:53 <applicative> fcul, Initial already has the type Float -> State
15:03:01 <benmachine> fcul: hm. I don't know Java well enough to know much about what that is. I suspect you won't find much success in looking for analogies
15:03:02 <MostAwesomeDude> Is there such a type as, say, "signed big-endian 16-bit integer" somewhere?
15:03:06 <benmachine> and should just learn how to do stuff :P
15:03:21 <MostAwesomeDude> Heck, I'll even go for combining "big-endian 16-bit" and "signed integer"
15:03:33 <Saizan> fcul: you might have misunderstood data declarations, judging by your questions
15:03:40 <rwbarton> signed 16-bit integer exists
15:03:43 <rwbarton> @hoogle Int16
15:03:44 <lambdabot> Data.Int data Int16
15:04:07 <Eduard_Munteanu> Not specifically big endian though.
15:04:11 <rwbarton> specifying endianness in the type doesn't make a lot of sense but there is...
15:04:22 * hackagebot cmdlib 0.3.5 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3.5 (PetrRockai)
15:04:23 <rwbarton> something like putInt16be
15:04:37 <letrec> I was wondering what compiling a pattern or doing a match (using stuff from Text.Regex.Posix.String for instance) returns an IO (...) ? There is no IO side-effect as far as I can see?
15:04:48 <Eduard_Munteanu> For 16bit values you can just swap the bytes, though.
15:04:54 <mercury^> I guess the really confusing thing is the join :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
15:04:57 <letrec> s/what/why
15:05:11 <rwbarton> or apparently there are only putters in the binary package for Word, not Int, hmm
15:05:48 <mercury^> (did I type that correctly?)
15:05:53 <applicative> fcul, Initial 22.2 and floatToState 34.44 are values in the type State. But you need more?
15:07:09 <fcul> I "need" something like:   Initial a = floatToState 2.1
15:08:15 <rwbarton> well you can actually write that in certain contexts but i doubt it does what you want
15:08:17 <Saizan> fcul: that works, a will be of type Float then
15:08:23 <rwbarton> how about just   a = floatToState 2.1
15:08:26 <hiptobecubic> Do you all find yourself scripting daily tasks in haskell or do you still lean on sh/perl/python/whatever for those things?
15:08:32 <applicative> fcul: that is an elaborate way of ... what rwbarton said
15:09:09 <rwbarton> what is the definition of floatToState, by the way?
15:09:44 <MostAwesomeDude> Hm. Data.Int doesn't have unsigned ints.
15:09:56 <applicative> Data.Word ?
15:09:57 <rwbarton> they're called Word16 etc.
15:10:02 <MostAwesomeDude> So if I want to handle both unsigned and signed ints, do I need to use Word and Int together?
15:10:04 <rwbarton> oh yeah, and they are in Data.Word :)
15:10:05 <MostAwesomeDude> Alright.
15:10:14 <mercury^> join f x = f (\g -> g x), right?
15:10:46 <shachaf> @djinn ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
15:10:47 <lambdabot> f a b = a (\ c -> c b)
15:11:00 <applicative> amazing
15:11:46 <mercury^> So what does that equation tell someone who has intuition about Cont?
15:13:17 <hpc> mercury^: if you erase all the "Cont" stuff in your head, "return x" is basically "($ x)"
15:13:41 <hpc> mercury^: so join x b = x (return b), i think
15:13:55 <xplat> @pl f a b = a (\ c -> c b)
15:13:56 <lambdabot> f = (. flip id)
15:14:19 <Saizan> mercury^: imo, (>>=) makes more immediately sense
15:15:02 <xplat> @pl join a b = a ($ b)
15:15:03 <lambdabot> join = (. flip id)
15:15:39 <xplat> @src join
15:15:40 <lambdabot> join x =  x >>= id
15:18:37 <mercury^> :t callCC
15:18:38 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:19:30 <hpc> heh, i have a blog post i want to write where i explain the definition of callCC
15:19:41 <Axman6> gogogo!
15:19:49 <mercury^> So that's ((a -> ((b -> r) -> r)) -> (a -> r) -> r) -> (a -> r) -> r
15:19:53 <hpc> i can't figure out where to start
15:20:01 <shachaf> hpc: Start by talking about the law of excluded middle.
15:20:24 <hpc> shachaf: im doing it from a more operational perspective
15:20:26 <hpc> @src callCC
15:20:27 <lambdabot> Source not found. :(
15:20:43 * shachaf has been meaning to write a thing about Cont for a while, actually.
15:20:55 <hpc> or at least, from a more "this is how you should read this part, this is how to read this part, they fit together like this" kind of thing
15:21:17 <hpc> so callCC is less of a wizardly black box that could only ever be produced by djinn
15:21:40 <shachaf> But first I need to understand the entire topic completely, including good intuition for Kan extensions and other edwardkish things. Naturally.
15:21:48 <shachaf> hpc: Make sure you explain the _ in the definition of callCC!
15:22:16 <shachaf> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
15:22:17 <lambdabot> f a b = a (\ c _ -> b c) b
15:22:20 <hpc> shachaf: i wrote this and i think it came out well: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11
15:22:22 <kissyboy> why is _ in there anyway
15:23:05 <hpc> kissyboy: say you wrote "callCC $ \f -> ..."
15:23:14 <hpc> kissyboy: that '_' is the "what comes after "f"
15:23:36 <hpc> kissyboy: kind of; basically you ignore it and do what comes after the whole "callCC"
15:23:36 <shachaf> kissyboy: I discards one continuation in favor of another.
15:23:46 <kissyboy> aha i see
15:23:57 <hpc> kissyboy: it's the magic behind 'f' being a "breakpoint" of sorts
15:24:35 <benmachine> hpc: oh goodness, your HTML in your haskell is not escaped properly
15:24:44 <hpc> benmachine: yeah, im lazy
15:24:44 <benmachine> I mean, escaped properly for display in a blog post
15:25:53 <hpc> eh?
15:26:06 <hpc> oh shit, the syntax highlighter was doing magic
15:26:11 * hpc fixes
15:27:27 <MostAwesomeDude> Agh. Agrfl. Cereal is not a pleasant way to invert attoparsec or parsec operations. Is there a reasonable inverse to attoparsec?
15:27:32 <hpc> it's fixed now
15:28:15 <hpc> at some point im gonna redo my website in a nicer way, and fix all that up at the same time
15:29:38 <hpc> hopefully that point will be "right after finals"
15:29:56 <mm_freak_> copumpkin: i can't make sense of the definition you gave, but a commenter defines a similar type:  newtype S r a = S ((a -> r) -> r -> a)
15:30:00 <mm_freak_> that one makes more sense to me
15:35:08 <DanBurton> any ideas? http://stackoverflow.com/questions/8423502/simple-exercises-to-learn-netwire
15:36:33 <Guest49932> I have two expressions to evaluate... What operator I use to evaluate the expressions the same time
15:37:01 <Cale> Guest49932: par
15:37:24 <Guest49932> Like a: xx par xx1???
15:37:53 <Cale> par x y will put x in a queue of things to be evaluated on some processor if there's time available before it's needed, and it'll result in y (which will mean that y is getting evaluated)
15:38:16 <Cale> (But is this really what you're asking about?)
15:38:42 <Cale> Could you be a bit clearer about what you're trying to do?
15:38:43 <mercury^> Since you can define the continuation monad in any closed category: do you know of any applications outside of Haskell?
15:39:26 <Cale> @unmtl Cont r a
15:39:26 <lambdabot> (a -> r) -> r
15:41:39 <mm_freak_> i think i got it, but i wouldn't know where to use that monad
15:41:40 <mads-> I have lately become interested in programming styles like scheme and was told that Haskell is somewhat the same and is more used "out in the real world". Is this true? :)
15:42:02 <Guest49932> for example I have this expression: pi*r and this r*r... and I need evaluate the first expression and next evalute the second expression
15:42:10 <mercury^> Would be cool to see callCC used in a proof in representation theory. :)
15:42:20 <Guest49932> I tried this pi*r $ r*r
15:42:20 <mm_freak_> DanBurton: first write a working program =)
15:43:12 <mm_freak_> DanBurton: once you have that you should try to understand the general idea:  a wire is a time-varying function, and you can make data dependencies between those
15:44:10 <mm_freak_> one easy exercise is to write a little physics simulation using Control.Wire.Prefab.Calculus.integral
15:44:54 <mm_freak_> particle :: Double -> Wire e (>~) Double Double
15:45:17 <mm_freak_> where the argument is the starting point and the input signal is the acceleration (not the velocity)
15:45:52 <kfish> copumpkin, i never kid about semigroupoids
15:45:52 <lambdabot> kfish: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:45:53 <mercury^> Hmm, is this Wire thing what came out of FRP?
15:46:06 <copumpkin> kfish: lol
15:46:10 <mm_freak_> mercury^: it's an AFRP library similar to yampa
15:46:20 <mercury^> What does the A stand for?
15:46:24 <mm_freak_> arrowized
15:46:31 <mm_freak_> it uses an arrow
15:46:42 <mercury^> How does it compare to yampa?
15:46:52 <Cale> Guest49932: why do you need to evaluate them both?
15:47:18 <mm_freak_> it generalizes yampa to include signal inhibition and an arbitrary underlying arrow (yampa only allows (->))
15:47:27 <Cale> Guest49932: What are you going to do with the results?
15:47:37 <mm_freak_> yampa:  newtype SF a b = SF (a -> (b, SF a b))
15:47:54 <mm_freak_> netwire:  newtype Wire e (>~) a b = Wire (a >~ (Either e b, Wire e (>~) a b))
15:48:14 <hpaste> Varakh pasted “MST” at http://hpaste.org/54980
15:48:15 <Guest49932> Cale: I have the evaluate the first expression and next the second expression
15:48:20 <kfish> copumpkin, an on-disk btree for keyframe offsets isn't so far-fetched ... git uses an on-disk linear seek table, which you can mmap and trivially binary search over; linear grows more easily than btree at least
15:49:02 <Cale> Guest49932: and then what? If that was all that your program did, it would just make the user's CPU a little warmer, and wouldn't have any visible effect.
15:49:19 <copumpkin> kfish: yeah, I guess I could just use a linear table too, since I don't really need to ever change it after making it
15:49:26 <mm_freak_> mercury^: it's also faster, doesn't need switching combinators and comes with a larger set of predefined signal functions ("wires")
15:49:39 <Varakh> any idea why i'm getting a non-ending loop in my MST ? http://hpaste.org/54980
15:49:44 <Guest49932> Cale: Like this: function r = pi*r operator r*r ---- I need a operator
15:49:46 <copumpkin> kfish: in fact, that's quite nice
15:49:52 <Varakh> ignore redundant brackets etc, its not final :>
15:50:01 <Cale> Guest49932: is that a recursive definition of r?
15:50:16 <kfish> copumpkin, https://github.com/kfish/ght/blob/master/Git/PackIndex.hs
15:50:28 <Cale> If r = pi*r, say, then r = pi*r = pi*pi*r = pi*pi*pi*r = ...
15:50:31 <copumpkin> kfish: I was just thinking about that cross-sectional view I was talking about yesterday. This would give me a view of cumulative depth against time in O(window length * log(depth size))
15:50:53 <Cale> which, aside from causing an infinite loop, doesn't have a solution (I guess as a Float, you could say it converges to Infinity)
15:51:27 <mm_freak_> copumpkin: care to tell me how your J monad works?  i couldn't find it
15:51:39 <Guest49932> Cale: I have fixed my function :)
15:51:47 <Guest49932> Cale: thanks a lot
15:51:51 <Cale> um... okay
15:51:53 <Cale> :)
15:51:59 <copumpkin> mm_freak_: that google query you wrote is where I got it from, along with escardo :)
15:52:16 <mm_freak_> copumpkin: i wrote a google query?  hmm…
15:52:40 <copumpkin> oh it was Eduard_Munteanu
15:52:40 <copumpkin> [06:24:34 PM] <Eduard_Munteanu> @google "j monad" andrej
15:52:41 <copumpkin> [06:24:36 PM] <lambdabot> http://www.reddit.com/r/haskell/comments/9clsr/wanted_applications_of_the_j_monad/
15:52:41 <copumpkin> [0
15:54:22 * hackagebot fixhs 0.1.2 - FIX (co)parser  http://hackage.haskell.org/package/fixhs-0.1.2 (ArvinMoezzi)
15:54:41 <mm_freak_> i wonder if there is a fromCont for J
15:54:46 <mm_freak_> if yes, i don't need it =P
15:54:59 <copumpkin> kfish: ah yeah
15:55:16 <copumpkin> kfish: yeah, that's where I found the woot :)
15:56:01 <mm_freak_> just yesterday i found that these two types are equivalent, which is very interesting:  ( data SF a b = forall s. SF ((a, s) -> (b, s)) ) and ( newtype Auto a b = Auto (a -> (b, Auto a b)) )
15:56:04 <arw> i've got some server that receives data, stores it and on request sends out some digest of that data. of course it should be multithreaded. i've thought of using TVar (Map String HostInfo) to store the data.
15:56:46 <arw> now the question: is that a good idea? would multiple concurrent reads to that data structure be possible or does the TVar just lock everything?
15:57:00 <copumpkin> mm_freak_: I think you'll find that Auto is more commonly called Mealy :)
15:57:19 <mm_freak_> copumpkin: it's called Auto in the arrows package =)
15:57:26 <copumpkin> tsk tsk
15:57:30 <mm_freak_> though there AutoT would be a more appropriate name =)
15:57:35 <benmachine> arw: I believe TVars don't lock
15:57:42 <benmachine> they are optimistic
15:57:43 <copumpkin> someone didn't know his moore and mealy machines
15:58:18 <arw> benmachine: so a read where some write occurs in between would just retry?
15:59:19 <copumpkin> mm_freak_: anyway, makes sense :)
15:59:46 <benmachine> arw: that's my understanding; not an expert though
15:59:47 <copumpkin> in one cases you have an explicitly reified state you pass around (stream fusion does this) and in the other state is hidden in a function closure
15:59:52 <mm_freak_> arw: conceptually a read on a TVar never retries…  it might wait though, so you in practice your idea is fine, as long as you have a low write/read ratio
16:00:31 <mm_freak_> copumpkin: the most interesting thing about it is that with the new ConstraintKinds extension, the SF variant may actually be more powerful
16:00:42 <mm_freak_> copumpkin: for the first time you could get persistable AFRP state =)
16:01:07 <mm_freak_> that would be very interesting for games…  savegames for free =)
16:01:14 <copumpkin> mm_freak_: you mean because you'd be able to specify a constraint on the existential?
16:01:20 <mm_freak_> yeah
16:01:21 <copumpkin> mm_freak_: you could do that before, but not generally
16:01:30 <copumpkin> but yeah, it's nice
16:01:31 <letrec> :t isInfixOf
16:01:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:01:37 <mm_freak_> yes, you could do that, but not in a generic library
16:01:43 <letrec> :t Data.Text.Lazy.isInfixOf
16:01:44 <lambdabot> Data.Text.Lazy.Internal.Text -> Data.Text.Lazy.Internal.Text -> Bool
16:01:45 <arw> benmachine, mm_freak_: thank you.
16:01:58 <mm_freak_> ConstraintKinds allows you to do very useful things with the existential
16:02:16 <mm_freak_> (btw, i wonder why they changed it to plural, as there is only one constraint kind)
16:02:45 <parcs> mm_freak_: to be consistent with other language extension names
16:04:06 <parcs> however as you mentioned it doesn't really make sense
16:04:19 <parcs> but that was the reasoning behind the changu
16:04:25 <mm_freak_> i'd be happy with ConstraintKind
16:05:34 <mm_freak_> the singular variant makes you feel how a single kind-level thing can increase the power of the language considerably
16:06:24 <benmachine> maybe * -> Constraint is a constraint kind
16:06:38 <hpc> maybe Constraint -> * is a constraint kind
16:07:00 <parcs> https://github.com/ghc/ghc/commit/0bdafd5c357cba726347f56ebc940842e2d4fb59 :P
16:07:34 <Cale> Whatever the reason, it's deliberate :)
16:08:35 <benmachine> I guess it's the same reason that it's ViewPatterns and not ViewPattern
16:49:30 <copumpkin> what's the best way to get a bytestring from a handle up until I get a particular byte value out of it?
16:49:37 <copumpkin> is there a nicer way than asking for one byte at a time?
16:50:53 <salisbury> copumpkin: hGetBuf
16:51:18 <copumpkin> but I don't know how many bytes I want to read
16:51:21 <copumpkin> it's a delimited field
16:51:41 * applicative concedes that he does oppose camel case type variables
16:51:51 <copumpkin> you mean camelCase?
16:52:06 <parcs> copumpkin: using cereal maybe?
16:52:19 <salisbury> copumpkin: hmm, sounds like a takeWhile should fit in there
16:52:29 <copumpkin> parcs: how would that help? I basically want Handle -> Word8 -> IO ByteString
16:52:39 <copumpkin> and it will eat up until it sees the Word8 I provided
16:52:50 <salisbury> maybe do (takeWhile (something) ) . getChar
16:53:00 <salisbury> then convert from char
16:53:00 <copumpkin> I have that already, but that's string and ugly
16:53:07 <copumpkin> it's more of a replicateUntilM
16:53:17 <copumpkin> replicateUntilM :: Monad m => (a -> Bool) -> m a -> m [a]
16:53:20 <parcs> copumpkin: good point, it wouldn't :P
16:54:07 <parcs> what about using iteratees
16:54:44 <copumpkin> I suppose I could, but it would make me a bit sad :)
16:55:21 <kfish> copumpkin, iteratees ftw!
16:55:29 <copumpkin> yeah, I guess
16:55:31 * copumpkin sighs
16:55:44 <parcs> iteratees were designed for this kind of stuff
16:56:16 <fcul> hi...
16:56:52 <parcs> fcul: hi
16:56:58 <fcul> I've spend the last 2 & half hours banging my head on the wall with this :
16:57:17 <copumpkin> okay okay, I'll use an iteratee
16:57:20 <fcul> if (x < o) then doThis() AND this()
16:57:24 <EvanR> unsafeBangHeadOn Wall
16:57:34 <BMeph_> I think I can say with confidence, fcul, that..."UR DOIN IT RONG!" ;)
16:57:39 <fcul> how do I make haskell to do BOTH instructions
16:57:50 <fcul> BMeph_: I believe you
16:57:59 <parcs> fcul: do doThis() and this() involve IO
16:58:15 <parcs> (that was a question)
16:58:20 <EvanR> when (x < 0) (doThis >> andThat)
16:58:23 <BMeph_> fcul: By "instructions", do you mean actions? (I.e., is this monadic stuff?)
16:58:26 <fcul> parcs: yes
16:58:42 <fcul> BMeph_:  not sure
16:59:09 <BMeph_> fcul_: Never mind, you told parcs that it does IO, which is a "yes". :)
16:59:11 <kfish> copumpkin: dropWhile p >> stream2stream
16:59:37 <parcs> fcul: you can sequence IO actions with >>
16:59:48 <fcul> 0.o
16:59:52 <fcul> 2secs
16:59:55 <EvanR> see what i said ;)
16:59:57 <parcs> :t (>>)
16:59:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
17:00:16 <BMeph_> fcul: Hop on kfish's coattails, here: try "(doThis() >> this())", as it applies to your prog.
17:00:40 <EvanR> i said that, but without the C notation o_O
17:00:51 <BMeph_> fcul_: ...or, yeah, what EvanR said. :)
17:01:13 <parcs> if x < o then doThis >> this else return ()
17:01:23 <EvanR> thats when
17:01:38 <parcs> so what
17:01:44 <EvanR> return () is annoying
17:02:11 <EvanR> :t void
17:02:12 <lambdabot> Not in scope: `void'
17:02:19 * kfish is listening to coattailrider
17:02:22 <EvanR> IO a -> IO ()
17:02:43 <parcs> :t (() <$)
17:02:45 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
17:03:33 <EvanR> far out
17:03:40 <fcul> EvanR: IO a -> IO() look like the error Hugs keeps banging
17:04:42 <parcs> fcul: are you familiar with do notation?
17:04:50 <fcul> +\-.... =S
17:05:00 <EvanR> no, thats not do notation ;)
17:05:22 <fcul> cicloMain :: Float -> State -> Int -> State    cicloMain b (Initial a) n_max = if(n_max > 0) then (cicloMain  b (itera b (Initial a)) (n_max -1) >> plotState (Initial a) )  else return()
17:05:36 <fcul> (Initial a) is a State
17:05:43 <parcs> fcul: then you can forget about (>>) for now. just write (do actionA; actionB)
17:06:00 <EvanR> State?
17:06:03 <EvanR> * -> * ?
17:06:22 <fcul> EvanR: data State = Initial Float | Iter_1 Float Float | AnyIter Float Float Float
17:06:45 <EvanR> conventionally State s a is a standard type
17:07:11 <EvanR> * -> * -> * ;)
17:08:50 <DanBurton> > end
17:08:51 <lambdabot>   Not in scope: `end'
17:08:57 <DanBurton> @let end = return ()
17:08:58 <lambdabot>  Defined.
17:09:09 <DanBurton> ta-da. no more ugly return ()
17:09:14 <fcul> EvanR: Even if I call it XYZ... same thing =(
17:09:25 <EvanR> you can call it the same thing
17:09:29 <EvanR> just saying people might get confused
17:09:39 <fcul> kk
17:11:33 <fcul> In this :  cicloMain :: Float -> State -> Int -> State    cicloMain b (Initial a) n_max = if(n_max > 0) then (cicloMain  b (itera b (Initial a)) (n_max -1) >> plotState (Initial a))  else return()
17:12:02 <fcul> plotState :: State  -> IO()
17:13:27 <fcul> Guys! Forget it!!!
17:13:48 <fcul> I Forgot to change the signature of the method when trying with this >> that
17:16:43 <EvanR> fcul: do notation and >> >>= notation dont change type signatures
17:16:48 <EvanR> interchangable
17:18:28 <fcul> EvanR: I know. the last "mistrie" before coming here  i changed the signature
17:18:36 <fcul> forgot to change it back to it's original state =\
17:18:47 <fcul> I know.. .dumb noob programmer :P
17:31:21 <no1special> @undo do { whiteSpace; x <- p; eof; return x }
17:31:21 <lambdabot> whiteSpace >> p >>= \ x -> eof >> return x
17:32:11 <parcs> whitespace *> f <* eof
17:32:29 <parcs> oops, p not f
17:32:46 <parcs> :t ((*>), (<*))
17:32:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) a1 b1. (Applicative f, Applicative f1) => (f a -> f b -> f b, f1 a1 -> f1 b1 -> f1 a1)
17:33:12 <no1special> cool!
17:36:19 <no1special> thanks, parcs.
17:36:53 <no1special> related question: how come there's <$ but not $> ?
17:37:08 <hpc> @src (<$>)
17:37:09 <lambdabot> f <$> a = fmap f a
17:37:16 <hpc> @src (<$)
17:37:16 <lambdabot> (<$) = (<$>) . const
17:37:18 <hpc> derp
17:37:23 <hpc> :t (<$)
17:37:25 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
17:37:46 <hpc> no1special: because ($>) = flip const?
17:38:11 <hpc> @djinn b -> f a -> f a
17:38:12 <lambdabot> f _ a = a
17:38:24 <no1special> ah
17:39:38 <parcs> you mean defined as ($>) = flip (<$)?
17:40:03 <shachaf> parcs: But (*>) =/= flip (<*)
17:40:47 <nexion> hey guys.. I'm considering having refcounted handles to a resource passed around to make sure the consumer loop of a TChan does not exit until all handles have been returned (and thus no more writes to the TChan are possible); is this a common pattern in Haskell or am I on the wrong track?
17:41:11 <no1special> yeah, I meant *> as flip <*. Didn't realize there was another definition
17:41:12 <hpc> parcs: the difference between (*>) and (<*) is that the "values" get flipped but the "effects" stay in the same order
17:43:14 <no1special> wait wait, sorry, got confused. I meant $> as flip <$
17:44:56 <parcs> because it wouldn't be very useful
17:45:15 <parcs> or rather, it wouldn't be any more useful than <$
17:46:03 <EvanR> nexion: i dont know but sounds like you should avoid it at all costs ;)
17:46:26 <no1special> yeah, it's purely stylistic
17:47:06 <no1special> something like  'symbol "true" $> Bool True' reads somewhat more naturally to me than the reverse
17:47:29 <nexion> that I have been told, but it's the only way I see to avoid these race conditions given the design with multiple threads looping on readTChan while supporting request-response
17:48:30 <nexion> since if one of those threads is set to terminate, it needs to make sure nobody is in the middle of a request that will deadlock if not responded to
17:49:37 <EvanR> why do you want to terminate threads in the middle of request
17:51:06 <nexion> if the particular thread represents an IRC channel, it's possible that someone has just looked up the TChan for it and is about to join while the last user in the channel leaves
17:51:24 <nexion> and upon the last user leaving, the channel should be destroyed
17:51:50 <nexion> a simple workaround my friend proposed is to wait some number of seconds before terminating, but it's not clean
17:52:13 <EvanR> yeah
17:52:15 * EvanR thinks
17:52:41 <EvanR> the action of 'enter' or 'leave' should be regulated by a single mvar (or similar thing)
17:52:49 <EvanR> so you cant be doing both at once
17:53:13 <EvanR> or two enters at once, at so on
17:53:46 <nexion> interesting idea
17:54:52 <jgreene> what ghc versions should I be using?  I'm having trouble compiling the template-haskell package and it looks like it can only use ghc 7.2, I'm worried that upgrading will break other packages though
17:55:11 <parcs> probably 7.0.4
17:55:25 <jgreene> parcs: that's what I'm using
17:58:05 <parcs> ghc 7.0.4 comes with template-haskell 2.5
17:58:17 <parcs> why do you want the latest version (i.e 2.6)?
17:58:20 <darkf> how do you formally verify a haskell program?
18:00:35 <jgreene> parcs: the hssqlppp package is basically requiring a template-haskell package and won't seem to select the proper one
18:01:11 <Axman6> darkf: there are various methods. proof by induction is fairly common (prove the pase case is true, for for n = 0 for list = []) and then prove that if some smaller case is true then a bigger one will also be true (so if foo xs is correct, then if you prove that foo (x:xs), then you've proved that foo is correct for all lists (sort of))
18:01:40 <darkf> Axman6: any tool to do that?
18:01:54 <arw> http://pbot.rmdir.de/30236573f682252792af8d575014ca00
18:02:11 <arw> i really can't have two different records with overlapping field names?
18:02:21 <arw> (in the same package that is)
18:02:36 <shachaf> arw: Not in scope at once. A field name defines a function.
18:02:37 <Axman6> there are languages like Agda, Coq and Isabelle that will assisst you in doing that. there's nothing that i know of that's explicitly for use with haskell. it's usually done by hand. (as are most proofs)
18:03:14 <arw> shachaf: yes, but shouldn't those functions have different parameter types so that they are distinguishable for the compiler?
18:03:34 <shachaf> arw: No -- just like you can't define two functions f and f with different types.
18:03:43 <shachaf> (With the exception of type classes, which are a very different sort of thing.)
18:05:02 <no1special> is there a better way to say \x -> return [x] ?
18:05:08 <monochrom> which means, if you are desperate, you write a type class method for the common field name.
18:05:16 <Axman6> return . return =)
18:05:38 <Axman6> > return . return $ 1 :: Maybe [Int]
18:05:39 <lambdabot>   Just [1]
18:05:47 <shachaf> pure
18:05:57 <Axman6> you can also use the angry monkey operator: return . (:[])
18:06:01 <shachaf> "pure" is such a terrible name. Worse than "return".
18:06:25 <Axman6> agreed
18:06:26 <shachaf> no1special has not specified a utility function.
18:06:34 <monochrom> we need angry monkey soft toys just like there are angry bird soft toys :)
18:06:40 <arw> monochrom: hm, yes, but that would be really ugly. i guess one more package won't hurt...
18:06:46 <Axman6> i'm not sure what would be better though. inject possibly, but i'm sure there's a thousand reasons it's also no good
18:07:07 <monochrom> I wouldn't say ugly. I would agree boring handwritten code.
18:07:26 <parcs> jgreene: try passing --constraint 'template-haskell==2.5.0.0' to cabal
18:07:29 <shachaf> Axman6: Not "inject". :-(
18:07:43 <monochrom> in fact it can look quite beautiful after suitable indentation, colouring, fonting :)
18:07:44 <no1special> so why doesn't return . [] work?
18:07:57 <Axman6> :t []
18:07:58 <lambdabot> forall a. [a]
18:08:02 <shachaf> no1special: [] isn't a function.
18:08:03 <Axman6> [] isn't a function
18:08:13 <Axman6> it's like saying Nothing 3
18:08:26 <no1special> ah
18:08:59 <donri> > (:[]) 1
18:09:00 <lambdabot>   [1]
18:09:08 <no1special> oh, i see how the angry monkey breaks down now
18:09:23 <shachaf> no1special: "Cookiemonster combinator", please.
18:09:28 <Axman6> it's the same as (\x -> x:[])
18:09:35 <monochrom> the rise of the planet of the angry monkeys
18:09:35 <shachaf> @quote eat.a.comment
18:09:36 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
18:09:45 <Axman6> which is the angry female monkey
18:09:46 <no1special> right, the missing left arg was throwing me off
18:10:42 <no1special> that's hilarious, shachaf :)
18:23:49 <Axman6> if you want to make a newtype wrapper, and have it inherit all the classes the wrapped type implements, what extension do you use?
18:24:46 <conal> Axman6: GeneralizedNewtypeDeriving
18:25:14 <Axman6> and you don't have to mention which classes you want to inherit?
18:26:22 <shachaf> Axman6: No such extension to GHC, so far as I know.
18:26:41 <Axman6> :(
18:26:57 <arw> http://pbot.rmdir.de/9d26174202de19dd8eb47594f2faac6e
18:27:14 <arw> obviously it demands a type signature. but i'm unable to find one that fits...
18:27:19 <jgreene> parcs: I ended up downloading the source to the packages that were causing the conflicts and changing their dependencies.  I wish people would get dependencies right when uploading to hackage.
18:27:24 <jmcarthur> Axman6: you make a type alias instead of a newtype
18:27:38 <shachaf> jmcarthur: No, type aliases are evil.
18:27:38 <Axman6> jmcarthur: that throws away the type safety we're after
18:28:28 <jmcarthur> that was a tongue-in-cheek suggestion
18:29:04 <parcs> arw: use the Parser type synonym instead of the Parsec type
18:29:09 * Axman6 proposes a retype extension, that works like type, but retype Foo=  Bar does not mean that Foo and Bar are just names for the same thing, but different types, that happen to have the same implementation
18:29:23 <parcs> parseText :: Parser [Char]
18:29:56 <jmcarthur> Axman6: that sounds like newtype... you probably left out some crucial detail
18:30:19 <no1special> i just wanted to state for the record that *> and <* are awesome. thanks parcs!
18:30:24 <Axman6> well it's newtype without the wrapper, so syntactically it's the same as using the wrapped type
18:31:14 * conal high-fives both *> and <*
18:31:29 <shachaf> <⁵>
18:31:33 <vrook> Here is the parser from "Programming in Haskell" https://gist.github.com/1445903 . I made a change, though -- he was using [] to indicate no result and [(a, String)] to indicate a result. I added the ParserOut type which captures both. Is there a reason why Hutton was using ad hoc type signatures, which seems like a programming-noob thing?
18:31:50 <jmcarthur> different type aliases for the same representation in ocaml don't unify unless their representations are known in the current scope. is that kind of what you mean?
18:32:02 <shachaf> vrook: Probably for pedagogical reasons.
18:32:20 <arw> parcs: oh, thanks. that was easy :) (imagine me plucking out the few of my leftover hairs...)
18:32:28 <vrook> But that's my question -- what's the pedagogy?
18:32:29 <shachaf> vrook: As I remember it's pretty early in the book.
18:32:46 <vrook> not really, chapter 8
18:32:48 <shachaf> vrook: Also, [] allows for ambiguous parses, though I don't know that he actually uses that.
18:33:02 * shachaf would probably vaguely prefer Maybe over a special-purpose type like that, in this particular case.
18:34:33 <vrook> I also have some observations on this parser code. It contains a lot of boilerplate, which many functions having a similar structure. What is the next step in abstracting it more?
18:34:40 <vrook> *with many
18:35:12 <shachaf> Well, it contains a lot of utility functions.
18:35:29 <shachaf> You can probably use Applicative/Maybe combinators to shorten things a bit.
18:38:41 <vrook> During matching, is there such a thing as otherwise -> theThingThatOtherwiseMatched
18:39:02 <vrook> Oh maybe that can't be checked
18:39:09 <mike-burns> x -> x
18:39:37 <vrook> ah right, thanks
18:39:55 <hpaste> tsanhwa pasted “unicode file name” at http://hpaste.org/54981
18:40:09 <vrook> Actually what I want is SomeThing a b c d e -> theThingThatSomethingMatched
18:40:32 <vrook> a synonym for the left side of the match
18:40:43 <vrook> ... only accessible on the right
18:40:44 <mike-burns> There are at matches or at patterns or something like that.
18:40:53 <mike-burns> I forget the name which means I can't remember what to search.
18:41:05 <vrook> ah yes now I remember @
18:41:33 <tsanhwa> hi, how can I create file of unicode filename. my test code is posted in http://hpaste.org/54981.
18:41:53 <tsanhwa> file create as such is named "/tmp/?"
18:41:59 <tsanhwa> by ghc
18:51:47 <vrook> More thoughts about the parser https://gist.github.com/1445903 -- My inclination is to keep generalizing it while removing boilerplate, which ultimately means writing out the helper functions corresponding the types. The end product would be a grammar specification which generates haskell code.
18:53:17 <vrook> If C is a 3 on the abstraction scale then Java is maybe a 4 and Haskell is around 10. But wherever one is on the abstraction scale, you always want to go higher.
18:53:59 <vrook> Even if Haskell is 100, we eventually want 101.
18:54:16 <Cale> vrook: Your next task is to use Applicative notation to write the parsers.
18:54:29 <Cale> (where possible)
18:55:44 <vrook> Cale: you mean replacing some do blocks with operators?
18:55:56 <vrook> .. from Applicative?
18:56:02 <Cale> With <$> and <*> etc, yeah
18:56:25 <vrook> OK that will be shorter, but then what?
18:56:32 <vrook> There is still boilerplate.
18:57:24 <Cale> What boilerplate in particular?
18:58:19 <kniu> anywhere here know how to use the Heist templating system?
18:58:27 <kniu> I tried asking in #snapframework
18:58:57 <kniu> but nobody's responding
18:59:17 <vrook> Cale: For starters, we want to generate digit, lower, upper, letter, alphanum which all follow the same pattern.
18:59:57 <vrook> That repetition almost reminds me of Java code.
19:00:35 <vrook> I guess the answer will be Template Haskell.
19:04:09 <no1special> is there any way to make 'p `sepBy` eol' work with a lexer created using makeTokenParser ?
19:04:52 * mreh never did roll his own lexer
19:05:45 <no1special> i think the lexer is eating the newlines (!), and I'm not sure how to prevent that
19:06:18 <mreh> no1special: can you be specific than 'eating'?
19:06:38 <tgeeky> mreh: like what you did with the word 'more' in that sentence
19:06:54 <Axman6> heh
19:07:05 <no1special> being skipped due to being considered whiteSpace ?
19:07:09 <mreh> i eated it
19:07:17 <mreh> oh right
19:08:09 <mreh> i take it whitespace is significant in your language
19:08:59 <no1special> minimally. which is to say declarations must each go on separate lines
19:09:01 <mreh> does anyone here use Data.Acid.Remote
19:09:20 <mreh> no1special: why? :)
19:09:31 <mreh> if it's not ambiguous, why worry
19:10:47 <copumpkin> kfish: iteratees working :) (no it didn't take me this long :P)
19:11:23 <no1special> heh. well, it'd look confusing as hell without that property. and it likely will be ambiguous.
19:11:35 <no1special> there's just gotta be a way to delimit by newline
19:11:45 <mreh> c programs are confusing as hell when written all on one line
19:11:56 <mreh> sorry for not being helpful
19:12:13 <no1special> yes, exactly. and, no worries :)
19:12:43 <mreh> i'm not sure what point i tried to make
19:13:04 <mreh> the end of the IOCCC?
19:13:23 <no1special> that'd be tragic
19:15:12 <mreh> no1special: can you not override the lexical parsers?
19:15:22 <mreh> the one that produces whitespace in particular?
19:15:36 <DanBurton> Haskell programs make perfect sense when written on one line ;)
19:15:54 <mreh> DanBurton: that's why we have the irc
19:16:00 <mreh> practice
19:16:06 <DanBurton> exactly. only 1 line needed
19:16:13 <mreh> parse your eofs as symbols
19:16:26 <Cale> vrook: Except that those are already pretty much minimal. You could merge their type signatures into one, or remove them altogether.
19:16:28 <no1special> i'm not sure. like this? lexer' = lexer { T.whiteSpace = ... } ?
19:16:50 <mreh> Parsec version?
19:17:00 <no1special> yeah, it's parsec
19:17:15 <Cale> vrook: I mean, you can't really define digit much more simply than you already are
19:17:31 <Cale> But you could write:
19:17:43 <Cale> digit, lower, upper, letter, alphanum :: Parser Char
19:17:50 <Cale> digit = sat isDigit
19:17:52 <Cale> ...
19:18:13 <copumpkin> will 0xff ever show up in a utf-8-encoded string?
19:18:35 <Cale> copumpkin: no
19:18:40 <copumpkin> thanks!
19:19:05 <mreh> no1special: whatever your output from makeTokenParser is
19:19:23 <mreh> it could have disaterous consequences though
19:19:33 <mreh> the alternative is to hand roll your own lexer
19:19:42 <no1special> right, that's what lexer is. it just doesn't affect it internally
19:19:45 <no1special> meh
19:20:03 <no1special> anyway, it's late, and my brain is fried. good night and thanks, all
19:20:08 <mreh> i'm not sure how easy it would be to decople this one from the existing implementation
19:20:53 <Cale> copumpkin: The first byte of every UTF8 character starts with one of the prefixes { 0, 110, 1110, 11110, 111110, 1111110 }, in the first case it's one-byte, in the others, the number of bytes is the number of 1's. Each subsequent byte starts with 10, which is an impossible prefix for the first byte.
19:21:55 <kfish> copumpkin, :)
19:28:12 <copumpkin> Cale: thanks :)
19:28:15 <mreh> @tell no1special look at the implementation of makeTokenParser, whitespace is defined as skipMany1 (satisfy isSpace) (not including comments)
19:28:15 <lambdabot> Consider it noted.
19:29:54 <mreh> do iteratees only read?
19:30:14 <mreh> given than they can be safely interleved
19:40:22 <copumpkin> <3 view patterns
19:40:24 <copumpkin>   message '4' i e (parse json -> Done _ o) = Just $ RawMessage (JSON o) (MessageId 0) (Endpoint e)
19:41:36 <Cale> copumpkin: <3 pattern guards too
19:41:45 <copumpkin> yep, I love both!
19:42:35 <Cale>        PairT -- Eliminate "Pair . Split"
19:42:35 <Cale>          | (Sink (Just (r' :@ l')), Sink (Just (r'' :@ l''))) <- (pairFst s, pairSnd s)
19:42:35 <Cale>          , SplitT <- nodeType r'
19:42:35 <Cale>          , SplitT <- nodeType r''
19:42:35 <Cale>          , Just T1Eq <- refEq r' r''
19:42:36 <Cale>          , (SplitFst, SplitSnd) <- (l',l'')
19:42:53 <Cale> That's all GADT stuff, and it works :)
19:43:34 <Cale> (the pattern guards correctly discharge various type equality requirements)
19:44:21 <Cale> Used to be a ridiculous bunch of nested cases
19:44:50 <copumpkin> yeah
19:44:55 <copumpkin> I use it a lot with GADTs
19:44:56 <copumpkin> both of them
19:44:58 <copumpkin> I really love it
19:45:01 <copumpkin> makes me feel like I'm in agda
19:49:44 <dmwit> "I think X is the best language because when I'm writing it it feels like Y!"
19:50:07 <copumpkin> damn right
19:55:08 <snappy> I like when my Xs feel like Ys.
19:57:49 * DanBurton is going to invent a language called X so that everyone will accidentally say it is the best/worst
19:57:56 <darkf> cool
19:57:59 <darkf> do that
19:57:59 <irene-knapp> hah, nice
19:58:09 <irene-knapp> problem: there is already a large software system called X
19:58:10 <darkf> my language isn't pure functional. how many of you are mad?
19:58:19 <DanBurton> pure functional or gtfo
19:58:22 <dmwit> i mad bro
19:58:23 <irene-knapp> also, your language could be extremely popular and still not be findable in Google
19:58:26 <Axman6> irene-knapp: needs to be replaced anyway :P
19:58:30 <irene-knapp> fair
19:58:47 * BMeph_ is quite mad, but can't blame it on anyone... ;þ
20:03:20 <darkf> haha
20:03:34 <darkf> I just can't get into the pure functional mind without going crazy
20:04:30 <copumpkin> maybe you were already crazy
20:04:33 <Cale> darkf: That's not crazy that you're going.
20:04:34 <copumpkin> and pure functional is making you sane
20:04:38 <Sakako> Yes, being crazy is the main barrier one has to pass before mastering functional programmings
20:04:39 <Cale> exactly
20:05:11 <progmonk> craziness and functional programming is the shiz
20:05:21 <darkf> haha
20:05:26 <darkf> I'm already crazy so I'm sure I'll fit
20:05:30 <vrook> Is the empty language pure functional since it doesn't have side effects?
20:05:41 <vrook> {}
20:05:46 <darkf> does a set of all sets contain itself?
20:05:46 <Sakako> oh man, vrook
20:05:50 <Sakako> that's the best program ever
20:05:55 <darkf> yeah its true
20:05:59 <darkf> almost as good as nop
20:06:09 <Cale> darkf: Usually not. Usually it's not a set.
20:06:16 <Sakako> yeah, it had better be a category
20:06:18 <darkf> Cale: oh really?
20:06:22 <Sakako> or else you get Russell's paradox
20:06:26 <Cale> Well, it's a proper class.
20:06:38 <Cale> (which is the same thing as a predicate on sets)
20:06:54 <Cale> but ZFC doesn't have a set of all sets, at least
20:07:09 <Sakako> Prove it.
20:07:23 <conal> vrook: purely functional *and* purely imperative
20:07:39 <Cale> Sure... the set of all sets, if it were a set, would contain itself, which would violate the axiom of foundation.
20:07:58 <Sakako> Oh yeah, that axiom.
20:08:03 * Sakako smacks himself upside the head
20:08:06 <darkf> agh
20:08:09 <Sakako> I need to do more set theory stuff
20:08:26 <progmonk> we both do Sakako
20:14:23 <Cale> But the better question is whether a set of all sets which don't contain themselves contains itself.
20:14:46 <Cale> (this "set" also isn't a set)
20:15:00 <Sakako> oh
20:15:07 <Sakako> /that/ is Russell's paradox
20:15:14 <Sakako> derp
20:17:29 <vrook> Godel's undecidable propositions more or less translate to the Church-Turing thesis. What is the Axiom of Choice like in compsci?
20:18:24 <Sakako> AC is obviously fals
20:18:44 <Sakako> that's what it's like
20:18:51 <russellw> Sakako, how so?
20:19:00 <Sakako> We use Zorn's Lemma instead. ;p
20:19:05 <Cale> lol
20:19:09 <mzero> am I correct in thinking that in a 64-bit build of GHC, Int is 64 bits?
20:19:24 <Cale> mzero: If you want to know, use  maxBound :: Int
20:19:30 <Cale> mzero: and see what you get
20:20:11 <mzero> actually, what I'm wondering is, inside GHC, is it compiled so that C's int is 32 or 64 bits
20:20:22 <mzero> and, similarly, if pointers are 32 or 64 bits
20:20:33 <Cale> vrook: As far as I know, the axiom of choice in its full generality doesn't seem to come up much in CS.
20:20:44 <Cale> vrook: You might end up with some uses for countable choice.
20:20:53 <Sakako> Yeah, I've not really encountered it very much
20:21:04 * Sakako is a CS student
20:21:38 <russellw> Seems to me the axiom of choice is obviously true but uncontroversial with finite sets, it only starts getting interesting with higher order infinities
20:21:52 <russellw> And since computer science doesn't deal much with higher order infinities, it doesn't really arise
20:21:58 <kniu> @hoogle handle
20:21:59 <lambdabot> System.IO data Handle
20:21:59 <lambdabot> GHC.IO.Handle data Handle
20:21:59 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
20:22:22 <BMeph> @hoogle something
20:22:23 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
20:25:29 <Cale> The axiom of choice is obviously true on account of being an axiom ;)
20:25:54 <Sakako> My favourite axiom is K
20:26:12 <vrook> I think I know the answer. Take a lazy infinit tree, which is a partially ordered set. We can easily specify that chains are totally ordered. The Axiom of Choice says that the tree has a root.
20:26:19 <Cale> Sakako: Are you aware of how S and K arise in Applicative?
20:26:24 <Sakako> that is, [](p -> q) -> ([]p -> []q)
20:26:34 <Sakako> Not the combinator, the modal logic axiom :p
20:26:45 <Sakako> But no, I am not.
20:27:09 <Cale> Well, the S and K combinators started out as axioms of logic.
20:27:15 <mbetter> hello
20:27:18 <Cale> K :: a -> (b -> a)
20:27:34 <Sakako> Wahey, I know that one.
20:27:43 <progmonk> pretty
20:28:31 <Cale> S :: (a -> (b -> c)) -> ((a -> b) -> (a -> c))
20:28:54 <Cale> Those two are a basis for an intuitionistic fragment of propositional calculus
20:28:59 <Cale> Now...
20:29:00 <Sakako> Yep
20:29:12 <Cale> class Applicative f where
20:29:17 <Cale>   pure :: a -> f a
20:29:38 <Cale>   (<*>) :: f (b -> c) -> f b -> f c
20:29:54 <Cale> Now take f = (e ->)
20:30:06 <Cale> and you get:  pure :: a -> (e -> a)
20:30:16 <Sakako> oh wow
20:30:18 <Cale> and  (<*>) :: (e -> (b -> c)) -> (e -> b) -> (e -> c)
20:30:25 <Cale> it's K and S :)
20:30:35 <Sakako> <3 you are my hero
20:31:12 <Sakako> My favourite combinator is Y_{k}
20:31:13 <mbetter> is there a simple way to do this? ::  a -> Maybe b -> Maybe (a,b)
20:31:21 <progmonk> I must admit that was pretty cool
20:32:05 <Sakako> You could try currying the a and Maybe be
20:32:06 <Sakako> b*
20:32:11 <mbetter> i've got it with lambdas now and it looks like something that would be a general pattern
20:32:17 <Axman6> @hoogle numCapabilities
20:32:18 <lambdabot> GHC.Conc.Sync numCapabilities :: Int
20:32:18 <lambdabot> GHC.Conc numCapabilities :: Int
20:32:39 <Axman6> @hoogle evaluate
20:32:39 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
20:32:40 <lambdabot> Control.Exception evaluate :: a -> IO a
20:32:40 <lambdabot> Control.OldException evaluate :: a -> IO a
20:33:21 <Cale> mbetter: \x -> fmap ((,) x) -->  fmap . (,)
20:33:48 <Cale> :t fmap . (,)
20:33:49 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
20:34:06 <Cale> :t fmap . (,) :: a -> Maybe b -> Maybe (a,b)
20:34:08 <lambdabot> forall a b. a -> Maybe b -> Maybe (a, b)
20:34:46 <mbetter> aaaaah
20:34:53 <Sakako> well done sir
20:34:57 <mbetter> sweet, thanks a lot!
20:35:32 <Sakako> By the way, Cale, do you know about Y_{k}?
20:36:04 <Cale> the "this is a fixpoint combinator" thing? :)
20:36:10 <Sakako> yeah
20:36:11 <Sakako> :)
20:36:13 <Sakako> it's amazing
20:36:49 <Axman6> Cale knows a good many things
20:37:15 <Sakako> :)
20:38:16 <Cale> I wonder how that one was arrived at
20:38:23 <Cale> I'll have to look at the paper sometime
20:39:27 <Sakako> Yeah, it would be really interesting
20:39:48 <Sakako> especially seeing as the higher order combinator is (L L L L L L L L L L L L L L L L L L L L L L L L L L)
20:41:10 <Sakako> (that's 26 L's by the way.)
20:41:18 <Sakako> I'm sure that's not a coincidence
20:41:31 <Sakako> as the lambda term bounds precisely 26 variables
20:42:44 <copumpkin> :t maybe
20:42:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:46:02 <Sakako> :t Maybe a
20:46:03 <lambdabot> Not in scope: data constructor `Maybe'
20:46:09 <Sakako> :()
20:46:16 <Sakako> :( even.
20:46:23 <Sakako> :t maybe a
20:46:25 <lambdabot> forall a. (a -> Expr) -> Maybe a -> Expr
20:55:39 <vrook> Are per-package hackage download counts available somewhere?
20:56:45 <Axman6> only when dons compiles them from the apache web logs
20:57:20 <vrook> yeah I found Jun 2010 report.
21:05:20 <rezoe> what's an arch?
21:05:37 <Sakako> In terms of what?
21:05:46 <Axman6> an architecture usually, like x86, or ARM
21:05:54 <rezoe> topic says  (all archs not just mac(
21:06:04 <Sakako> yeah, architecture
21:06:10 <rezoe> ooo
21:06:15 <Sakako> x86, amd64, powerpc, etc.
21:06:21 <progmonk> sparc
21:06:26 <progmonk> I like sparc
21:06:30 <Axman6> me too
21:06:35 <rezoe> wut's spark?
21:06:50 <Axman6> SPARC is a cpu architecture
21:06:52 <Sakako> sparc is another architecture
21:07:03 <progmonk> http://en.wikipedia.org/wiki/SPARC
21:07:04 <Sakako> Scalable Processor ARChitecture
21:07:19 <rezoe> you're all so informative
21:07:20 <Axman6> it's also the architecture used in the most powerful supercomputer on earth at the moment
21:07:23 <rezoe> lol
21:07:46 <Axman6> rezoe: do you have any questions about Haskell?
21:07:48 <rezoe> ax - the human brain?
21:08:04 <rezoe> sure axman6 - what is it?
21:08:13 <Axman6> @google haskell
21:08:20 <Axman6> lambdabot!
21:08:28 <lambdabot> Plugin `search' failed with: thread killed
21:08:32 <Axman6> @google haskell
21:08:34 <Sakako> ... xD
21:08:39 <Sakako> well done, \bot
21:08:48 <lambdabot> Plugin `search' failed with: thread killed
21:08:57 <Axman6> urgh
21:09:04 <dmwit> rezoe: Haskell is a programming language. The official website (haskell.org) is a wiki with lots of information, including tutorials.
21:09:20 <rezoe> ah very interesting
21:09:32 <dmwit> rezoe: If there's something you wish your computer did, but doesn't, you can fix that problem with Haskell. =)
21:09:42 <rezoe> haha neato
21:09:44 <Sakako> Haha
21:09:51 <dmwit> Let us know what it is, and we can even give you suggestions for libraries that would help you make it happen.
21:09:57 <Sakako> Haskell is just that powerful.
21:10:11 <dmwit> Lots of ping timeouts -- was there a split or something?
21:10:17 <Sakako> dat split
21:10:18 <geekosaur> seems like
21:10:20 <rezoe> i want my computer to teleport me to my own world where im all by myself and with a female who is everything i want and more
21:10:41 <dmwit> rezoe: I think there are bindings to Linden, the programming language for second life. =)
21:10:45 <rezoe> can haskell do this for me?
21:10:55 <Sakako> Ah, SL
21:11:21 <rezoe> bindings to Linden? Is Linden what we call earth?
21:11:28 <dmwit> http://hackage.haskell.org/package/mvclient
21:11:34 <vrook> rezoe: You should read "No Exit" by Sartre. It's something like what you describe, except that it's hell, not heaven.
21:11:44 <rezoe> oh my
21:11:45 <Sakako> Ahh, Sartre
21:11:59 <rezoe> to get to heaven gotta go through hell first
21:12:35 <progmonk> that would be dante's divine comedy
21:12:38 <DanBurton> so...did lambdabot die again?
21:12:41 <rezoe> indeed
21:12:45 <DanBurton> :(
21:12:52 <dmwit> ?botsnack
21:12:52 <lambdabot> :)
21:12:54 <rezoe> i think lambdabot dies everytime
21:12:56 <dmwit> DanBurton: No?
21:13:03 <DanBurton> @google haskell
21:13:04 <lambdabot> http://haskell.org/
21:13:05 <Bynbo7> > fix error
21:13:06 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:13:13 <rezoe> lol
21:13:23 <rezoe> at this rate at least
21:13:32 <copumpkin> > fix show
21:13:34 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:13:36 <copumpkin> > fix fail
21:13:37 <lambdabot>   ""
21:13:53 <dmwit> Oh, "fix error" is very deceptive.
21:13:53 <Bynbo7> :t fix fix
21:13:54 <rezoe> @lambdabot hi
21:13:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
21:13:54 <lambdabot>     Probable cause: `fix' is applied to too many arguments
21:13:54 <lambdabot>     In the first argument of `fix', namely `fix'
21:13:55 <lambdabot> Unknown command, try @list
21:14:07 <rezoe> @list
21:14:08 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:14:15 <dmwit> It looks like it's printing a String that contains the text *Exception: over and over, but it's actually throwing an exception in the exception handler, every time.
21:14:18 <dmwit> Wacky.
21:14:21 <Sakako> Weird.
21:14:27 <rezoe> @lambdabot karma
21:14:28 <lambdabot> Unknown command, try @list
21:14:28 <Bynbo7> > length $ fix error
21:14:31 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
21:14:32 <rezoe> @karma
21:14:33 <lambdabot> You have a karma of 0
21:14:37 <rezoe> D:
21:14:47 <rezoe> what is this nonsense!
21:14:51 <dmwit> rezoe--
21:14:54 <dmwit> ?karma rezoe
21:14:55 <lambdabot> rezoe has a karma of -1
21:15:05 <Bynbo7> @karma
21:15:06 <lambdabot> You have a karma of 0
21:15:06 * rezoe dies
21:15:14 <Axman6> @karma
21:15:15 <lambdabot> You have a karma of 0
21:15:18 <Axman6> D:
21:15:21 <rezoe> +karma dmwit
21:15:23 <Axman6> I used to have karma :(
21:15:23 <dmwit> rezoe: You are reincarnated as a slightly less fortunate human.
21:15:30 <rezoe> oh noes
21:15:38 <rezoe> i dont think my life can get any more unfortunate
21:15:39 <rezoe> lol
21:15:46 <rezoe> hopefully the tides turn tho
21:16:13 <vrook> tide goes in, tide goes out
21:16:18 <vrook> never a miscommunication
21:16:26 <dmwit> Axman6: karma was recently (within the last year or so) reset
21:16:44 <Axman6> -_-
21:16:47 <rezoe> ahh- is that what happened?
21:16:54 <Axman6> i used to have like 9!
21:17:02 <Axman6> 9 I tell you!
21:17:07 <rezoe> i probly had like -234
21:17:16 <rezoe> so good thing that happened :P
21:17:37 <Axman6> karma should be like energy, it cannot be created or destroyed
21:17:44 <rezoe> it is
21:17:50 <rezoe> it's only trANSFERRED
21:18:33 <rezoe> u know when u do something good for someone
21:18:40 <rezoe> and they dont even thank u or anything?
21:18:50 <rezoe> bad juju
21:19:08 <rezoe> actually let's think about this...
21:19:27 <rezoe> yes
21:19:45 <rezoe> hmmm
21:19:51 <rezoe> so many parametewrs to think about
21:20:01 <dmwit> karma should be like energy, it decays if you don't actively recharge your battery
21:20:24 <rezoe> that's horriblew
21:22:23 <rezoe> what happens if ur karma battery dies then?
21:22:31 <rezoe> bad things start happening?
21:22:33 <rezoe> lol
21:23:10 <rezoe> :|
21:24:02 <progmonk> oh something like that
21:32:16 <turiya> hi..did anyone use gnuplot in haskell before?
21:32:35 <maurer> turiya: Yes, you are better off either doing it via command line or using the chart package
21:33:35 <turiya> maurer: did u mean using the gnuplot command line?
21:34:14 <maurer> turiya: Yeah, if you want to use gnuplot, it's going to be easier to just send commands and data to the gnuplot binary than to work with the lib
21:34:42 <maurer> The chart package does gtk based rendering stuff, and has a pretty nice native interface if you aren't specifically looking for the power of gnuplot
21:35:18 <turiya> maurer: thanks, i wanted to tweak the font size of the legend but somehow i am unable to do so using the lib
21:35:32 <turiya> i will try the chart package
21:37:10 <fullofcars> would you like some java codes today?
21:38:07 <mzero> just published some results of testing 32-bit GHC vs. 64-bit GHC
21:38:08 <mzero> http://mtnviewmark.wordpress.com/2011/12/07/32-bits-less-is-more/
22:01:28 <copumpkin> > realToFrac 2.913 :: Fixed E9
22:01:30 <lambdabot>   2.912999999
22:01:30 <DanBurton> anyone familiar with netwire? This SO question has remained eerily silent... http://stackoverflow.com/questions/8423502/simple-exercises-to-learn-netwire
22:01:33 * copumpkin coughs
22:02:50 <DanBurton> *tumbleweed blows by*
22:04:18 <yitz> > realToFrac (2913 % 1000) :: Fixed E9
22:04:20 <lambdabot>   2.913000000
22:04:26 <copumpkin> yep
22:05:10 <yitz> > realToFrac (2.913 :: Rational) :: Fixed E9 -- or even this
22:05:11 <lambdabot>   2.913000000
22:05:41 <copumpkin> @instances RealFloat
22:05:42 <lambdabot> Double, Float
22:05:45 <copumpkin> rational :: RealFloat a => Reader a
22:05:55 <Sakako> Well, I'm off
22:05:57 <Sakako> see you later~
22:05:58 <copumpkin> bos: that seems odd :)
22:06:26 <yitz> mzero: thanks so much for your great work on the mac!
22:06:38 <mzero> you're welcome!
22:07:43 <ion> > fromRational 2.913 :: Fixed E9
22:07:45 <lambdabot>   2.913000000
22:12:16 <copumpkin> the confusion came from Data.Text.Read.rational returning a value in a typeclass that doesn't even include Rational :)
22:12:28 <copumpkin> and me expecting it to be monomorphic
22:12:39 <copumpkin> but instead it defaulted to Double
22:20:41 <Axman6> mzero: I'd also like to thanks you for your work, it's needed someone with motivation for a while. It's good feeling like OS X isn't a second class system any more
22:21:08 <mzero> yay!
22:21:39 <mzero> I'm looking forward to the 2012 HP release w/GHC 7.4 -- I think that one's gonna rock on Mac OS X
22:22:08 <yitz> mzero: hope so, if linker issues don't bite us
22:25:09 <mzero> eh - we can deal with those - its just going to take some careful poking at the Xcode tools
22:28:18 <mzero> yitz - it wasn't a little bit more - average 27% slower on 64-bit!  And surely anything I write in Haskell today will get recompiled sometime in the next three years - so why is going with 32-bit GHC the wrong choice? -- 99.999% of all the Haskell I write is agnostic to the 32/64 distinction
22:28:52 <mzero> I like my programs taking less memory and running faster!
22:29:45 <maurer> mzero: May not be an issue for the code you're running, but if you want > 4G heap you will need 64bit
22:30:18 <mzero> of course - but I can't think of anything I'm writing these days in Haskell that needs that ....
22:30:19 <yitz> let fromRadix = foldl1.((+).(*)); groupsOf n = map (take n) . takeWhile (not.null) . iterate (drop n) in map (toEnum . fromRadix 2) . groupsOf 8 . map (subtract 48 . fromEnum) $ "0101001101010100010000010101010001000101" :: String
22:30:25 <yitz> > let fromRadix = foldl1.((+).(*)); groupsOf n = map (take n) . takeWhile (not.null) . iterate (drop n) in map (toEnum . fromRadix 2) . groupsOf 8 . map (subtract 48 . fromEnum) $ "0101001101010100010000010101010001000101" :: String
22:30:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
22:30:53 <ddarius> > map digitToInt ['0'..'9']
22:30:54 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
22:31:56 <yitz> > let fromRadix = foldl1.((+).(*)); groupsOf n = map (take n) . takeWhile (not.null) . iterate (drop n) in map (toEnum . fromRadix 2) . groupsOf 8 . map digitToInt $ "0101001101010100010000010101010001000101" :: String
22:31:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
22:32:01 <Axman6> mzero: I'd love it if 64 bit 7.4 worked with the LLVM backend on OS X.
22:32:09 <robV5> I am trying to display an image using gtk2hs so that when you click on it the image changes. How can I achieve this? I read somewhere to use an eventbox but I cant find any documentation for the signals that you can use with eventbox.
22:32:16 <ddarius> :t (+) . (*)
22:32:18 <lambdabot> forall a. (Num a) => a -> (a -> a) -> a -> a
22:32:52 <mzero> Seems like a good way to go, but is that what GHC central is thinking? Stop trying to do the last stages of code generation and just let LLVM do it?
22:33:18 <ddarius> I'm pretty sure the NCG isn't going anywhere for a while.
22:33:37 <yitz> mzero: otoh i can't think of anything i'm writing these days where 27% will make a difference either. i process gigabytes of enterprise data with no significant delay.
22:34:31 <yitz> mzero: i think it won't make a difference for most people either way. still, it needs to be fixed.
22:34:55 <mzero> really, there's no way to generalize, no single answer --- if you're running a data center with 1000s of machines, and trying to eek out every cycle --- well, these things will matter
22:35:19 <yitz> mzero: true. so then, use the 32-bit ghc for now.
22:35:26 <mzero> on the other hand, most of us have personal machines that have more power than whole data centers did 20 years ago, and we mostly.... chat on IRC with them - so what the hell, memory and CPU to spare
22:35:38 <yitz> mzero: right!
22:36:28 <vrook> What's the deal with turn-on-haskell-indent vs turn-on-haskell-indentation. The latter one gives messed up indentation. Why is there even a choice?
22:36:41 <yitz> mzero: in college our campus mainframe took an entire building. ibm flew in a team of internation experts when the municiple water main running through the cpu ruptured. it had the approximate power of a 386.
22:37:18 <mzero> I have coded on machines like that!
22:37:28 <Axman6> old fogies
22:37:37 <vrook> 386? So you could play DOOM on it?
22:37:54 <yitz> mzero: not really fair though, the bus was huge, it was massively parallel.
22:38:01 <fullofcars> someone write doom in haskell now
22:38:23 <vrook> fullofcars: there's quake in haskell
22:38:29 <mzero> I used to have to compile my code by hand... and disassemble it to get it back out too.... in 0 degree weather... on punch cards.... with only 4k of RAM.....
22:38:36 <fullofcars> rly?
22:38:38 <fullofcars> hot damn
22:39:08 <yitz> Axman6: did you know that a horse-drawn wagon loaded with reels of mag tape has higher bandwidth than your cable modem?
22:39:29 <russellw> That depends very much on the distance
22:39:30 <maurer> yitz: Latency's shit though.
22:39:38 <yitz> maurer: literally
22:41:09 <yitz> vrook: we played adventure, and startrek.
22:41:42 <mzero> we sent e-mail by hand specifying the routing!
22:41:50 <Jafet> Did you know that your cable modem has one less horsepower than a horse-drawn wagon?
22:47:25 <dmwit> I wonder if !-style email addresses still work.
22:51:29 <mzero> decvax!cornell!harvard!mark
22:52:17 <yitz> > let fromRadix = foldl1.(\b -> (+).(b*)); groupsOf n = map (take n) . takeWhile (not.null) . iterate (drop n) in map (toEnum . fromRadix 2) . groupsOf 8 . map digitToInt $ "0101001101010100010000010101010001000101" :: String
22:52:19 <lambdabot>   "STATE"
22:52:51 <robV5> I am trying to display an image using gtk2hs so that when you click on it the image changes. How can I achieve this? I read somewhere to use an eventbox but I cant find any documentation for the signals that you can use with eventbox.
22:53:00 <robV5> this is what I am trying to do and the error I get.
22:53:01 <robV5> http://pastebin.com/WujStMBF
22:53:04 <mauke> The paste WujStMBF has been copied to http://hpaste.org/54983
22:53:04 <Axman6> yitz: so does a 747 full of hard drives
22:53:39 <yitz> Axman6: yes. it used to have better latency, too, but the TSA ruined that.
22:54:14 <dmwit> robV5: Try "on eb1 buttonReleaseEvent . liftIO $ changeImage img1" instead.
22:54:22 <dmwit> err
22:54:34 <dmwit> robV5: Also, return a boolean at the end of changeImage telling whether to bubble the event to other handlers.
22:54:48 <dmwit> robV5: e.g. add a line like "return False" to the end of it
22:55:19 <dmwit> Or maybe return True. Read the docs to see which means which.
22:56:41 <robV5> dmwit, do you know any good docs/tutorials for gtk2hs?
22:57:30 <dmwit> yes
22:57:33 <dmwit> moment, please
22:57:37 <GordonFreeman> hellooooo
22:58:20 <dmwit> Excellent tutorial: http://www.muitovar.com/gtk2hs/index.html (dunno if it's kept up with the most recent changes)
22:58:31 <dmwit> Excellent reference documentation: http://projects.haskell.org/gtk2hs/documentation/
22:59:13 <robV5> ah, I have been using both.
23:00:45 <yitz> hi GordonFreeman
23:00:50 * mzero wonders if GordonFreeman is waiting for a hello back
23:00:55 <vrook> I understand how <$> substitutes for liftM, but I don't see how the rest fits. For instance is there an applicative form of do { v <- p ; vs <- many p ; return (v:vs) }
23:00:56 <mzero> heh
23:01:00 <yitz> not anymore
23:01:13 <GordonFreeman> :)
23:01:14 <dmwit> liftA2 p (many p)
23:01:16 <dmwit> err
23:01:18 <ddarius> liftA2 (:) p (many p)
23:01:19 <dmwit> liftA2 (:) p (many p)
23:01:33 <ddarius> Alternatively, (:) <$> p <*> many p
23:01:35 <GordonFreeman> sure, from everybody around the globe
23:01:38 <dmwit> The only thing you can't do is case.
23:01:53 <dmwit> e.g. do { v <- p; case v of { True -> p'; False -> p'' } }
23:02:53 <ddarius> case is irrelevant, the only problem there is that the second computation depends on the result of the first.
23:02:57 <yitz> dmwit: you put the case in an auxilliary function in the where clause and then <$> it.
23:03:09 <ddarius> You can't do: do v <- p; f v either.
23:03:26 <dmwit> yitz: Show me.
23:04:02 <ddarius> You can certainly do, do v <- p; return (case v of ...)
23:04:28 <dmwit> ddarius: do { v <- p; f v } is just hiding the case in the definition of f.
23:04:49 <ddarius> dmwit: 1) I said you can't do that, 2) I meant an arbitrary f.
23:05:14 <dmwit> ddarius: You misunderstood my reply. You say case is irrelevant; I disagree.
23:05:30 <ddarius> dmwit: I don't really know what you were responding to there.
23:05:55 <dmwit> For example, you can certainly translate let f = return in do { v <- p; f v }.
23:06:13 <dmwit> The reason you can't do it for arbitrary f is because arbitrary f may do a case on its argument.
23:06:52 <ddarius> dmwit: I can write a f which does no cases directly or indirectly, and still could be rewritten to use applicative.
23:07:01 <yitz> dmwit: well you can't do >>= of course, but in real life you almost always know what p' and p'' are, and what f is
23:07:22 <ddarius> s/could/could not/
23:07:29 <dmwit> ddarius: Okay; can you do it without if/then/else or guards (which can be desugared to case statements)?
23:07:34 * mzero is somewhat confused
23:07:36 <ddarius> dmwit: Yes.
23:07:44 <dmwit> Wow! How?
23:08:06 <mzero> what are you saying can't be done with case ?
23:08:11 <ddarius> dmwit: How's 'bout f = id for the most obvious case.
23:08:27 <yitz> mzero: change a monadic expression into an applicative one
23:10:07 <dmwit> ddarius: Seems pretty damning. I concede.
23:10:14 <ddarius> Also, do v <- p; case v of True -> return 1; False -> return 2 can be rewritten to use applicative.
23:12:15 <MostAwesomeDude> Last check before I write my own: Is there a Construct for Haskell? A single declarative parser and builder?
23:12:39 <dmwit> What's a builder?
23:12:51 <ddarius> Philippa has discussed an "applicative do."  The restriction there would be that the last statement must be a return and all bound variables could only be used in the final statement.
23:13:11 <MostAwesomeDude> Opposite of a parser. A parser turns binary data into a data structure. A builder turns that structure (back) into packed data.
23:13:15 <mzero> MostAwesomeDude: yes, I think so
23:13:39 * mzero ...finding the reference
23:13:50 <dmwit> http://lambda-the-ultimate.org/node/4191
23:13:52 * MostAwesomeDude is patient but excited
23:13:54 <ddarius> MostAwesomeDude: You may not want to assume people immediately know what you are referencing.
23:14:20 <dmwit> I think "pretty-printer" is a more common term than "builder" in the Haskell community.
23:14:22 <ddarius> MostAwesomeDude: Presumably you are referring to this: http://construct.wikispaces.com/
23:14:27 <ddarius> dmwit: That's not even the issue.
23:14:29 <dmwit> Probably other communities, too, though I'm not as confident of that.
23:14:30 <MostAwesomeDude> ddarius: Yes.
23:14:32 <mzero> Tillmann Rendel and Klaus Ostermann . Invertible syntax descriptions: Unifying parsing and pretty printing
23:14:48 <dmwit> mzero: Definitely don't click my ltu link. ;-)
23:15:02 <MostAwesomeDude> pretty-printing is really not the term I'm after; this is for packing and unpacking binary data, not merely prettifying it.
23:15:04 <mzero> http://www.informatik.uni-marburg.de/~rendel/unparse/
23:15:16 <dmwit> ?hackage invertible-syntax
23:15:16 <lambdabot> http://hackage.haskell.org/package/invertible-syntax
23:15:21 <dmwit> The accompanying hackage package.
23:15:34 <dmwit> ?hackage boomerang too
23:15:35 <lambdabot> http://hackage.haskell.org/package/boomerang too
23:15:38 <mzero> tada  - ask and ye shall receive on #haskell!!!
23:15:45 <ddarius> MostAwesomeDude: Binary does this.
23:15:45 <MostAwesomeDude> Hm. Interesting. Thanks.
23:16:06 <dmwit> Yes, then there's binary, aeson and other json libraries, etc.
23:16:07 <MostAwesomeDude> ddarius: Binary wasn't quite suiting my needs. Maybe I need to modify my desires.
23:17:36 <mzero> and don't forget cereal
23:18:03 <copumpkin> bos: around?
23:18:07 <MostAwesomeDude> Cereal *definitely* is not satisfactory; I've already tried it. The amount of new things I needed to add was disheatening.
23:18:20 <tmhz> Does anyone know why HLint would recommend I use `Data.Monoid.mappend` instead of (++) ?
23:18:35 <MostAwesomeDude> I don't mind straight-up porting Construct, but I'd rather not, since I'm sure that this wheel's been ground to dust already.
23:18:38 <mzero> it's wordier?
23:18:56 <ddarius> MostAwesomeDude: I'd expect porting Construct would be really easy.
23:19:08 <MostAwesomeDude> ddarius: Yeah, me too, especially since I know the guts so well.
23:19:20 <MostAwesomeDude> But again, NIH isn't a good thing.
23:19:45 <dmwit> tmhz: Generalizing can be nice sometimes.
23:20:02 <dmwit> tmhz: If (++) is the only thing restricting you to lists, why not use mappend and work for other monoids, too?
23:20:17 <tmhz> ahh ok cool thanks
23:21:16 <ROROX> hello. Just checking out tryhaskell.org
23:21:50 <mzero> fun, yes?
23:21:51 <ROROX> to brush up on what I learned last year while reading "Learn you a haskell"
23:21:58 <ROROX> I like it
23:23:55 <ROROX> for some reason when I was learning it last year I did it according to the book LYAH, today I downloaded it onto a different computer that I have now and it's different
23:24:05 <ROROX> the interface is different
23:24:26 <mzero> downloaded "it" ?   GHC?
23:24:30 <mzero> Haskell Platform?
23:24:38 <ROROX> last time it was a small window interface with black background and white & colored text
23:24:54 <ROROX> yes. GHCi
23:25:13 <mzero> if it looks different, it is just your terminal app
23:25:22 <ROROX> this time it's a full screen window with white background
23:25:25 <mzero> ghci is a command line program
23:25:29 <mzero> Windows?
23:25:35 <ROROX> yus
23:25:47 <mzero> ah - that's just whatever defaults you've got
23:26:02 <mzero> for terminal / console apps
23:26:15 <ROROX> I don't quite follow
23:26:23 <dmwit> ROROX: Are you now using WinGHCi or Hugs?
23:26:26 <mzero> if you don't want it full screen - just open a command shell any way you like
23:26:26 <mzero> and type ghci in there
23:26:43 <ROROX> WinGHCi
23:26:51 <mzero> actually - someone more familiar with the Windows port should chime in
23:27:10 <ROROX> I'm opening it up not to investigate
23:27:22 <dmwit> ROROX: Right, so last time you used it, you probably used ghci; ghci is developed to be OS-independent.
23:27:30 <dmwit> So here's the deal.
23:27:43 <ROROX> that too happened. The tutorial said "type ghci" and it did not return what the book claimed
23:27:49 <dmwit> There's a program called "terminal" which provides a very rudimentary text-based interface.
23:27:57 <dmwit> ghci is built on top of this; WinGHCi is not.
23:28:04 <dmwit> That's the difference in a nutshell.
23:28:21 <ROROX> I see
23:28:27 <dmwit> It may look different, but the behavior should be basically identical.
23:28:58 * DanBurton uses ghci on his windows computer from the command line
23:29:05 <dmwit> I think Windows calls its terminal "command prompt" or something like that. But what's in a name? =)
23:29:46 <ROROX> hmm
23:29:52 <DanBurton> Windows button -> type "cmd" -> hit enter. Command prompt...tada!
23:30:19 <DanBurton> of course you need a path variable set up, which it probably is
23:30:43 <dmwit> ...these distinctions aren't really that important to a beginner, I think.
23:30:56 <ROROX> I've accessed the command prompt on this pc
23:31:06 <ddarius> MostAwesomeDude: If I wanted to read/write UDP packets with checksums, does Construct support that?
23:31:07 <dmwit> They're interesting in a historical kind of way, but sort of incidental to doing Haskell programming.
23:31:24 <ROROX> ya
23:31:55 <ROROX> I just would like to write in the terminal like I used to before. It was easier on the eyes
23:32:11 <ROROX> but regardless, I'll use whatever works
23:32:27 <dmwit> ROROX: If you prefer the white-on-black, follow DanBurton's instructions.
23:32:41 <dmwit> win+r, type "cmd" and hit enter, type "ghci" and hit enter
23:32:52 <dmwit> possibly also win+r, type "ghci" and hit enter
23:32:56 <dmwit> Not as confident of the latter one, though.
23:34:29 <ROROX> ?! I typed ghci into command prompt and it's displaying what WinGHCi does "Prelude>"
23:34:30 <lambdabot> Maybe you meant: . ? @ v
23:34:49 <dmwit> Yes, "Prelude> " is the ghci prompt.
23:34:52 <dmwit> What were you expecting?
23:35:09 <ROROX> I didn't expect it to be so easy s'all
23:35:20 <dmwit> =)
23:35:33 <ROROX> and it's opperating nicely
23:35:48 <ROROX> now to catch back up to whee I was last winter
23:36:22 <DanBurton> or you can always install virtualbox, put your favorite linux distro on it, and use ghci from there :)
23:36:30 <copumpkin> @ask bos it seems strange for Data.Text.Read.rational to have type RealFloat a => Reader a when Rational doesn't even fit into that typeclass. It seems like it could work with any Fractional?
23:36:31 <lambdabot> Consider it noted.
23:38:06 <ROROX> thanks for all the help +)
23:38:20 <ROROX> =)
23:40:03 <dmwit> I can't wait for the day when ghc depends on text.
23:40:08 <dmwit> It's only a matter of time, right?
23:42:09 <ROROX> Also why I wanted to use GHCi in the interface is because WinGHCi returned things really slowly
23:42:30 <dmwit> That's odd.
23:42:47 <dmwit> Evaluation speed shouldn't really differ between the two.
23:44:05 <ROROX> like I entered some numbers like 5+111+30*44 in both of them. From the interface it returned instantaneously
23:44:33 <ROROX> but from winGHCi I could see each digit appear one by one
23:44:50 <dmwit> Wow. If you can reliably make that happen, you should definitely report it as a bug.
23:45:35 <ROROX> when would I report to?
23:45:40 <ROROX> where*
23:46:00 <dmwit> http://code.google.com/p/winghci/issues/list maybe?
23:46:06 <dmwit> (Just google'd winghci.)
23:47:49 <ROROX> I may report it sometime
23:48:21 <ROROX> I need to get going
23:48:38 <dmwit> g'luck
23:48:46 <ROROX> thanks again, night all.
23:49:38 <Peaker> MostAwesomeDude: Got disc'd. The "Construrct" library is harder to implement type-safely. Me and the author of Construct (who I am converting to a Haskeller :-) ) are going to work together to make a construct for Haskell, hopefully soon
23:55:45 <Peaker> MostAwesomeDude: Constrct is also not compilable to lower-level code -- we want the Haskell implementation to be declarative enough to derive C code or such from it
23:56:00 <Peaker> which is a bit difficult, it means we can't use any Haskell lambdas (if we don't want to write a Haskell compiler)
23:58:25 <hpaste> shurikas pasted “instances” at http://hpaste.org/54984
23:58:40 <shurikas> can anybody tell me why fmap switches parameters?
23:58:43 <luite> Peaker: what is this? the python library?
23:58:44 <shurikas> Yes a <*> f = fmap a f
23:59:18 <shurikas> where fmap's first parameter should be (a -> m b)
23:59:26 <dmwit> :t (<*>)
23:59:26 <shurikas> and not (m a)
23:59:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:59:39 <dmwit> shurikas: fmap's first parameter is not (a -> m b).
23:59:48 <shurikas> @hoogle fmap
23:59:49 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
23:59:49 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
23:59:49 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
23:59:56 <shurikas> ok, my bad
