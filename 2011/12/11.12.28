00:01:58 * hackagebot sbv 0.9.24 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-0.9.24 (LeventErkok)
00:02:14 <hpaste> sopvop pasted “how to instance show for this?” at http://hpaste.org/55794
00:02:49 <Sgeo> I don't see how the analogy holds. The instance says if you have a way to convert a function from having as to having bs, you have a way to convert from having bs to having as
00:03:02 <Sgeo> Wait, hmm
00:03:20 <sopvop> So, how do I? instance (Show a) => (Show a b) -- complains what a has different kind, it is * and not * -> *
00:03:26 <Sgeo> Yeah, I don't think the compiler could figure that out on its own?
00:03:41 <shachaf> sopvop: What does "Show a b" mean?
00:03:58 <sopvop> should be Show (Ast a b)
00:04:05 <shachaf> Oh.
00:04:17 <shachaf> Well, "a" is apparently of kind * -> *.
00:04:28 <shachaf> That is, the first argument to Ast is of that kind.
00:04:42 <shachaf> At least, that's a blind guess based on the limited information you've provided. :-)
00:04:59 <sopvop> yup, but how do I make instance of show for Ast for all a which have Show instance?
00:06:07 <ski>   instance Show a => Show (Ast a b)  -- ?
00:07:20 <sopvop> nope, that gives : The first argument of `Ast' should have kind `* -> *',
00:07:20 <sopvop>     but `a' has kind `*'
00:07:20 <sopvop>     In the instance declaration for `Show (Ast a b)'
00:07:38 <copumpkin> is djinn complete?
00:08:44 <shachaf> copumpkin: Complete?
00:09:22 <scshunt> sopvop: you would want something like instance (Show (ann a)) => Show (Ast ann a) or the like
00:09:23 <copumpkin> if a proof exists for a h98 type (ignoring unsound logic like fix and bottom and so on), will it find it?
00:09:38 <scshunt> sopvop: ann itself can't have an instance of show
00:09:43 <scshunt> what if ann were Maybe?
00:11:25 <copumpkin> I think so
00:11:46 <shachaf> copumpkin: I once heard that it was in this channel.
00:11:59 <shachaf> This rumour is now n+1-hand.
00:12:18 <sopvop> scshunt works thanks! but requires FlexibleContexts. Is this dangerous?
00:14:33 <scshunt> sopvop: see http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts
00:16:42 <sopvop> Already did, looks innocent enough. Now I'll have to add (Show ann Blah) to every Ast constructor!
00:17:28 <ski> sopvop : hm, ok
00:17:37 <ski> sopvop : do you know the definition of `Ast' ?
00:17:39 <scshunt> sopvop: huh, why?
00:17:59 <scshunt> sopvop: normally you would put that on the instance declaration (although this will likely result in UndecideableInstances)
00:18:07 <sopvop> Because Ast is GADT
00:18:16 <ski> sopvop : i suspect you want `instance (forall c. Show c => Show (a c)) => Show (Ast a b)' (or something like that)
00:18:17 <scshunt> putting Show on the constructor means that the Ast can only contain Show-able types
00:18:19 <ski> hm
00:18:27 <scshunt> ski probably has it better than me
00:19:16 <ski> well, if it's a GADT, it might be different
00:19:22 <sopvop> I don't actually want do show c anywhere.
00:19:25 * ski can't really tell without seeing `Ast'
00:19:28 <sopvop> want to
00:19:44 * ski notices sopvop pastes something
00:20:07 <sopvop> http://hpaste.org/55794
00:20:26 <ski> hm, should
00:20:28 <ski>   Add :: Ast a Expr -> Ast ann Expr -> Ast ann Expr
00:20:29 <ski> really be
00:20:33 <ski>   Add :: Ast ann Expr -> Ast ann Expr -> Ast ann Expr
00:20:33 <ski> ?
00:20:49 <sopvop> c is kind of phantom type, or should I call it type instance?
00:21:00 <sopvop> Oh, yeah. It should.
00:21:07 <sopvop> damn
00:21:14 <sopvop> not type instance, type witness
00:21:18 <ski> is `Location' in `Show' ?
00:21:32 <ski> what is an example of a type you'd use for `ann' ?
00:21:42 <sopvop> No, it's not. And I don't want to show it. Location is just empty data Location
00:21:48 <ski> ok
00:22:43 <sopvop> The idea is to annotate different domains of ast with different types, ann would be a GADT with constructors for Statements, Exprs, Location and the like.
00:22:59 <ski> `instance Show (ann loc) => Show (Ast ann t)' might work, i'm not sure
00:23:15 <ski> btw, have you tried deriving `Show' for `Ast' ?
00:24:25 <ski> in your definition `t' can only be `Expr' -- i assume that will change when you add more stuff
00:25:13 <scshunt> fun: what does Ast Show t do? :P
00:25:49 * ski doesn't understans scshunt's question
00:25:59 <scshunt> ski: I know, I'm trolling
00:26:04 <scshunt> or tired
00:26:07 <scshunt> sometimes I can't tell the difference
00:36:27 <ski> sopvop : i'm not sure how much it helps in your case, but i think <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>,<http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite> is somewhat relevant
00:37:16 <sopvop> In the end, I've added (Show ann Location) contraint to Var constructor in Ast. No big deal for me.
00:38:28 <sopvop> ski, I've seen that. Pretty cool, but I could not figure out how to make decoration polymorphic with GADT type
00:39:01 <sopvop> They have only Expr, but I have Expr, Stmt, Body, Program and whatnot
00:39:35 <sopvop> So, I decided to cram everything into GADT.
01:10:38 <sopvop> looks promising http://www.haskell.org/ghc/dist/stable/docs/html/users_guide/kind-polymorphism-and-promotion.html
01:15:44 <The_Journey> is there a standard function that randomizes the content of a list?
01:22:30 <sopvop> Wow, It is possible to define empty class! Now that will shorten code.
01:36:16 <vodik> The_Journey: http://hackage.haskell.org/packages/archive/random-extras/0.17/doc/html/Data-Random-Extras.html
01:36:46 <The_Journey> vodik: thanks
01:47:36 <hpaste> ski pasted “ast attempt” at http://hpaste.org/55797
01:47:45 <ski> sopvop ^
01:49:47 <ski> (sopvop : obviously one can define an empty class -- anything else would be strange)
02:12:00 * hackagebot dropbox-sdk 0.1.0 - A library to access the Dropbox HTTP API.  http://hackage.haskell.org/package/dropbox-sdk-0.1.0 (KannanGoundan)
02:24:13 <dermusicus> u
03:13:34 <nexion> http://hpaste.org/55798 <- What could be causing it to expect a 'Maybe' as a return type of that 'atomically'? I'm even discarding the return value
03:15:32 <alistra> still the discarded value
03:15:39 <alistra> has to type
03:15:41 <alistra> it's like
03:15:50 <alistra> atomically ... >> return Nothing
03:15:56 <alistra> :t (>>)
03:15:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
03:16:00 <alistra> same m
03:16:03 <ivanm> alistra: it shouldn't
03:16:13 <ivanm> alistra: it _should_ be a Maybe
03:16:18 <ivanm> but atomically returns an IO
03:16:34 <ivanm> @type atomically
03:16:35 <lambdabot> Not in scope: `atomically'
03:16:37 <ivanm> @hoogle atomically
03:16:37 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
03:16:37 <lambdabot> GHC.Conc atomically :: STM a -> IO a
03:16:37 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
03:16:41 <ivanm> ^^
03:16:42 <nexion> yeah, IO a
03:16:57 <alistra> @hoogle IO a -> Maybe a
03:17:00 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
03:17:01 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:17:01 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:17:03 <ivanm> alistra: so your type sig should be "IO (Maybe a)" if you want to return Nothing at the end
03:17:15 <ivanm> alistra: even your "return Nothing":
03:17:16 <alistra> ivanm: it's not mine
03:17:17 <alistra> :/
03:17:18 <ivanm> @type return Nothing
03:17:19 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a)
03:17:29 <ivanm> alistra: well, you gave the code here :p
03:17:44 <alistra> nexion did
03:18:03 <nexion> ohh
03:18:05 <nexion> oops
03:18:16 <ivanm> alistra: oh, my mistake
03:18:17 <ivanm> sorry :s
03:18:27 <ivanm> nexion: ^^ so all that is for you then :p
03:18:39 <ivanm> xchat coloured both your nicks in green :s
03:18:40 <nexion> that totally makes sense, just the error message confused me
03:18:40 <alistra> nexion: why is it Maybe a
03:18:47 <alistra> can't it be like ()
03:18:56 <alistra> you only return nothing anyway
03:18:57 <ivanm> nexion: the error message is because you *said* it was Maybe, so it expected it to be Maybe
03:18:57 <nexion> that function is stripped down for simplicity so it won't make any sense
03:19:02 <ivanm> but it found something that *wasn't* Maybe
03:19:59 <alistra> IO (Maybe a)?
03:20:29 <nexion> yup
03:20:34 <nexion> that's what I should have wrote
03:22:45 <alistra> unsafePerformIO!
03:23:02 <nexion> who what?
03:23:19 <alistra> :t unsafePerformIO
03:23:20 <lambdabot> Not in scope: `unsafePerformIO'
03:23:25 <alistra> @hoogle unsafePerformIO
03:23:26 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:23:26 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:23:37 <nexion> no way :P
03:24:29 <alistra> it's alright, the function is in my van parked in that alley
03:24:52 <nexion> is it an unmarked van with covered windows?
03:25:07 <alistra> and it's black
03:28:39 <bobry> Hello, can somebody please help me with this error: https://gist.github.com/b2e275fb224eeaebed88 ?
03:29:20 <bobry> what am I doing wrong?
03:29:47 <povman> :t forever
03:29:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
03:29:49 <povman> :t handle
03:29:49 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
03:30:14 <povman> what the heck
03:30:21 <bobry> er :)
03:30:30 <povman> i no longer understand the types of functions.
03:30:53 <bobry> neither do I, hah
03:31:13 <povman> it's because you're using handle, which has IO types
03:31:26 <povman> but you've set the type of forever_ as the general type 'm'
03:31:49 <povman> change m to IO
03:31:56 <bobry> oh, I see, thanks!
03:31:58 <Sgeo> Uh
03:32:05 <Sgeo> Oh, I see
03:32:23 <Sgeo> All IO are (Monad m), but not all Monads m are IO
03:32:52 <bobry> exactly :)
03:33:40 <povman> has anyone used factor?
03:33:44 <povman> the programming language
03:37:33 <xbayrockx> why is there so many people in here?
03:38:13 <povman> xbayrockx: if you hang around long enough you'll find out :)
03:38:32 <povman> (that's what they are all thinking)
03:41:06 <Cale> xbayrockx: because Haskell is awesome, and there are lots of friendly people who want to help beginners learn it :)
03:41:40 <Sgeo> povman, toyed with it a little, not much to really learn anything, if that counts for anything
03:44:50 <povman> Sgeo: I'm intrigued by it, particularly how it came into such a well-developed state without me hearing about it before now. I seriously enjoy decrypting the entire standard library through the help browser.
03:47:18 <naromainos> I have a question about Random: why is ":t mkStdGen" "Int -> StdGen" and ":t getStdGen" "IO StdGen": why is the second one with an "IO"-monad and the first one without any "IO"?
03:48:42 <Sgeo> getStdGen will seed the random number generator from the system somehow and give that. Since it gets a value from the outside world and depends on it, it needs to be done in IO. mkStdGen takes an Int as a seed. Give it the same Int, you'll get the same StdGen
03:48:53 <Sgeo> (Sorry if that's a misleading picture of IO)
03:49:41 <naromainos> sgeo: if I try to run getStdGen a few times, it always give the same numbers. Is this just a coincidence?
03:50:50 <Sgeo> Hmm, maybe it initializes an RNG once?
03:51:09 <bobry> Is it possible to extract any info from the exception? f. ex. function name / line number?
03:51:23 <Sgeo> Restarting ghci and doing it again gave me different numbers.
03:51:33 <naromainos> sgeo: indeed, you're right :)
03:51:35 <naromainos> thx
03:52:21 <Sgeo> Note that some things can update the RNG
03:52:59 <Sgeo> "There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad. It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator. To get deterministic behaviour, use setStdGen.
03:53:00 <Sgeo> "
03:53:32 <naromainos> thank you!
03:54:13 <Sgeo> You're welcome
03:54:17 <Sgeo> http://hackage.haskell.org/packages/archive/random/latest/doc/html/System-Random.html
04:15:24 <wingie> jezz ... 770 users in here
04:17:55 <ksf> there's a talk about dos security at http://28c3.fem-net.de/ (saal 1) starting in seven minutes if any of you web guys is interested
04:18:07 <ksf> http://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html
04:21:25 <asda8> I'm using the ConfigFile module, but have a problem with error handling: using the ErrorT monad structure I get nice errors for most of the parse failures, but in some cases read throws an exception (Prelude.read: no parse). I want to catch this exception, but have no idea how to do it inside ErrorT.
04:23:24 <asda8> any ideas?
04:41:07 <asda8> shouldn't ErrorT catch all exceptions anyway?
04:42:07 * hackagebot yackage 0.3.0 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.3.0 (MichaelSnoyman)
04:43:01 <Cale> asda8: not that kind. Use reads instead of read if you want to deal with parse failure (you'll get an empty list)
04:43:53 <Cale> asda8: ErrorT is totally non-magical, you can only catch exceptions thrown from ErrorT in ErrorT.
04:46:29 <Cale> asda8: So you could write something like   case reads someString of (v,[]) -> do ... use parsed value v ...; _ -> throwError ...
04:54:39 <asda8> Cale: I don't use it, it's called by ConfigFile
04:54:55 <Cale> asda8: Then you can consider that a bug in ConfigFile :P
04:55:25 <asda8> Cale: ok then, thanks :)
05:18:58 <Cale> http://blog.johantibell.com/2011/12/remotely-monitor-any-haskell.html -- nice!
05:21:34 <rostayob> http://channel9.msdn.com/Blogs/Charles/YOW-2011-Simon-Peyton-Jones-and-John-Hughes-Its-Raining-Haskell
05:27:06 <Cale> rostayob: I saw that... I wonder if the video of the keynote they were talking about is online.
05:28:51 <Cale> I searched a bit for it, but only came up with a bunch of replicas of the details of when and where it was going to be.
05:31:01 <rostayob> Cale: spj is entertaining :)
05:31:50 <Cale> http://gotocon.com/dl/SPJ-%20keynote.pdf -- I found the slides for that keynote...
05:33:29 <rostayob> Cale: cool
05:33:57 <dixie> Which package is ultimate source for State monad ? Is it mtl ?
05:34:14 <ksf> Data.Hashable is wide open to attacks. Having salt support is a nice addition, but ultimately quite useless because the hash function is *way too easily* invertible.
05:34:51 <mm_freak> dixie: the 'transformers' package defines the state monad transformer and most libraries including mtl build upon that
05:35:54 <Cale> ksf: I don't think it's claiming to be a cryptographically secure hash though.
05:36:51 <ksf> well, but being at least half-way resistant to collision-based dos attacks would be nice.
05:37:05 <ksf> you need to build a hashtable first to get to that point, of course.
05:37:17 <Cale> I've used it and just assigned hashes to things incrementally :P
05:38:16 <Cale> (i.e. just used 0,1,2,3,4,... for the constructors of my type, and hashed tuples containing those and the hashes of the fields)
05:38:17 <Botje> heh heh
05:38:18 <ksf> feeding the function a supply of random numbers would be an easy way to fix attackability without going cryptographic.
05:38:25 <Botje> launchMissiles (impure; international side effects)
05:38:30 <Botje> SPJ++
05:39:00 <dixie> mm_freak: thanks. I thought that "transformers" are some extension upon Monads...
05:39:03 <mm_freak> ksf: it's not that simple
05:39:08 <ksf> Cale, that's hash . fromEnum ...
05:39:18 <mm_freak> ksf: being collision-resistant basically means using a cryptographic hash function
05:39:36 <ksf> it suffices if the attacker has no idea on what salts you're using.
05:40:03 <ksf> ...and has no decent way to guess.
05:40:44 <mm_freak> dixie: they generalize particular monads…  where you have newtype State s a = State { runState :: s -> (a, s) }, the transformer version is newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }
05:40:52 <ksf> the rng should be cryptographic, of course.
05:41:06 <mm_freak> dixie: then type State s = StateT s Identity
05:41:38 <ksf> the point in using both is that one can use a fast hash for most data, and only occasionally use a cryptographically secure number to harden it
05:42:30 <mm_freak> ksf: you can't harden a weak hash function that way…  a determined attacker will easily break your scheme
05:42:46 <ksf> for that, he has to break the rng.
05:42:52 <mm_freak> no
05:43:08 <ksf> yeah, you're right.
05:44:05 <Cale> ksf: yeah, assuming an instance of Enum
05:44:28 <Cale> ksf: It's rather like writing coarbitrary instances
05:44:46 <Cale> oddly enough
05:44:54 <Cale> (or perhaps not so oddly)
05:45:14 <Cale> http://gotocon.com/dl/jaoo-melbourne-2011/slides/Parallel-Haskell-Yow.pdf -- oh, moar slides
05:45:25 <Cale> http://yowaustralia.com.au/YOW2011/general/details.html?speakerId=2208 <-- from here
05:49:34 <alistra> > 5 `(`mod`)` 2
05:49:35 <lambdabot>   <no location info>: parse error on input `('
05:49:46 <alistra> > 5 ` ( `mod` ) ` 2
05:49:47 <lambdabot>   <no location info>: parse error on input `('
05:49:54 <alistra> > 5 `mod` 2
05:49:55 <lambdabot>   1
05:50:05 <alistra> > (`mod`) 5  2
05:50:06 <lambdabot>   <no location info>: parse error on input `)'
05:50:12 <alistra> > (+) 5  2
05:50:13 <lambdabot>   7
05:50:23 <alistra> > 5 `(+)`  2
05:50:24 <lambdabot>   <no location info>: parse error on input `('
05:51:43 <alistra> :|
06:04:25 <lukish_> How can I produce that lazy list? [0, 1, -1, 2, -2, 3, -3, ...]
06:05:38 <parcs`> > [0,-1,..]
06:05:39 <lambdabot>   <no location info>: parse error on input `..'
06:05:44 <parcs`> > [0,-1..]
06:05:45 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
06:06:02 <mux> > 0 : [1..] >>= \x -> [x, -x]
06:06:03 <lambdabot>   [0,0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-...
06:06:04 <Cale> > 0 : [1..] >>= (\x -> [x,-x])
06:06:05 <lambdabot>   [0,0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-...
06:06:08 <Cale> hehe
06:06:13 <mux> heh
06:06:25 <parcs`> oops :P
06:06:26 <Cale> er, hang on
06:06:35 <mux> > 0 : ([1..] >>= \x -> [x, -x])
06:06:35 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
06:06:40 <Cale> ah, haha
06:06:55 <Cale> Or just:
06:07:05 <Cale> > 0 : concatMap (\x -> [x,-x]) [1..]
06:07:06 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
06:07:16 <Cale> if you don't want to be monadic about it :)
06:07:44 <parcs`> > 0 : ([1..] >>= (:) <*> pure . negate
06:07:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:07:47 <parcs`> > 0 : ([1..] >>= (:) <*> pure . negate)
06:07:49 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
06:08:53 <mux> > 0 : ([1..] >>= \x -> map ($x) [id, negate])
06:08:54 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
06:09:41 <mux> parcs`: oh, that's nice
06:10:15 <Cale> > let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs) in [0,-1..] /\/ [1..]
06:10:16 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
06:10:42 <mux> heh, that was going to be my next try
06:10:55 <mux> I'm always surprised that there isn't a Data.List.merge function
06:11:37 <parcs`> tail . concat . transpose $ ((:) <*> pure . map negate) [0..]
06:11:38 <Cale> Well, that'd probably be an ordered merge, but there should be a "perfect shuffle" too.
06:11:40 <parcs`> > tail . concat . transpose $ ((:) <*> pure . map negate) [0..]
06:11:42 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
06:11:59 <Cale> (I really want an ordered merge in there as well)
06:12:39 <Cale> Also, things like  select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
06:12:53 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1..5]
06:12:54 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
06:13:01 <dylukes> Haskell is back to its old tricks.
06:13:09 <dylukes> doing somewhat useless one liner shit with lists :3
06:13:27 <parcs`> > tail . concat . transpose . ((:) =<< negate .: join) . pure $ [0..]
06:13:28 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
06:13:33 <dylukes> We're better at this than Lisp.
06:13:36 <Cale> dylukes: Hey, don't diss the one-liner shit with lists, it comes in handy. :)
06:13:49 <dylukes> Cale: true, for anything vaguely geometry/mathy
06:14:13 <Cale> Well... even if not, though I'm not sure there's any program which isn't vaguely mathematics.
06:14:20 <dylukes> In Haskell, yeah ;P.
06:14:30 <Cale> In any language :P
06:14:48 <dylukes> My ruby program that prints out a marquee of a penis using escape codes begs to differ.
06:14:52 <Cale> fsvo vaguely
06:15:02 <Cale> lol
06:15:15 <dylukes> It's also the only actual use of carriage return I've ever found.
06:15:35 * mux hopes we didn't scare lukish_ away
06:15:42 <Cale> Figure out what theorem that program is proving, and submit a research paper, lol.
06:15:48 <dylukes> pff
06:15:53 <mux> dylukes: what about console-based progress bars? :-)
06:16:04 <dylukes> mux: D:
06:16:05 <mux> \r comes in handy there
06:16:10 <dylukes> Shit, my penis is actually a progress bar.
06:16:16 <dylukes> It's measuring how little of a life I have left.
06:16:40 * dylukes didn't actually make this mind you, it marqueed arbitrary text.
06:17:08 <Cale> btw, I posted this link above, but it seems like a different set of people are online now, so: http://blog.johantibell.com/2011/12/remotely-monitor-any-haskell.html
06:17:19 <exlevan> @type (.:)
06:17:20 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
06:18:07 <mux> Cale: that's pretty cool! I saw that link on reddit but hadn't clicked on it yet
06:19:41 <dylukes> obtw
06:19:47 <dylukes> Cale: this is the program: a=$*[0].split'';loop{print"\033[G|#{a*''}|";a.rotate!}
06:20:02 <dylukes> >.>
06:20:09 <parcs`> does that require applications to be built with -prof?
06:20:14 <mux> ruby looking like perl? something's gone wrong
06:20:26 <dylukes> Note, the '' after split is two single quotes
06:20:31 <dylukes> not a double quote
06:20:38 <incomprehensibly> can anyone explain to me how Maybe a somehow encodes actions like IO a does, and not just values?
06:20:59 <incomprehensibly> because this is a really confusing assertion that I've read on the Haskell wiki, etc., that makes absolutely no sense upon any serious consideration.
06:21:07 <Cale> incomprehensibly: You can think of them as extremely simple actions which either produce a value or fail.
06:21:15 <dylukes> Cale: ^
06:21:28 <dylukes> they're pure actions though.
06:21:29 <dylukes> :)
06:21:33 <Cale> yeah
06:21:42 <alistra> @hoogle 'Eq a => a -> [a] -> ([a], [a])'
06:21:43 <lambdabot> Parse error:
06:21:43 <lambdabot>   'Eq a => a -> [a] -> ([a], [a])'
06:21:43 <lambdabot>   ^
06:21:44 <incomprehensibly> Just 3 seems to be a value, that could possibly be the result of some already performed computation
06:21:46 <alistra> @hoogle Eq a => a -> [a] -> ([a], [a])
06:21:47 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
06:21:47 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
06:21:47 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
06:21:47 <incomprehensibly> just like 3 is
06:21:54 <Cale> incomprehensibly: all actions are values :)
06:22:00 <Cale> incomprehensibly: IO actions included
06:22:08 <dylukes> parcs`: Here try this
06:22:09 <dylukes> a=$*[0].split'';loop{print"\033[G|#{a*''}|";sleep 0.1;a.rotate!}
06:22:18 <dylukes> Invoke it like
06:22:35 <dylukes> ruby marquee.rb "This is going to be marqueed obnoxiously! "
06:22:49 <incomprehensibly> Cale: Maybe a is just the type a, extended with Nothing
06:22:59 <parcs`> what is an action?
06:23:05 <alistra> > break (=='--') ["lol.c", "--", "-Wall"]
06:23:07 <lambdabot>   <no location info>:
06:23:08 <lambdabot>      lexical error in string/character literal at chara...
06:23:33 <alistra> > break (=="--") ["lol.c", "--", "-Wall"]
06:23:34 <lambdabot>   (["lol.c"],["--","-Wall"])
06:23:50 <alistra> > span (=="--") ["lol.c", "--", "-Wall"]
06:23:51 <lambdabot>   ([],["lol.c","--","-Wall"])
06:24:13 <incomprehensibly> Cale: what I don't understand is how Just 3 is an action when 3 is not
06:24:20 <incomprehensibly> Cale: or is 3 an action?
06:24:32 <mux> that's conventional if you ask me; an action is just a monadic function
06:24:54 <Cale> incomprehensibly: Well... 3 is polymorphic.  3 :: Integer  isn't an action because its type doesn't have the right form
06:25:37 <Cale> An "action" is just a word we're using for something of type  m t  where m is some monad, and t is any type
06:25:40 <Phantom_Hoover> Cale, Identity 3 is an action, though.
06:25:46 <Cale> Right
06:26:05 <Cale> incomprehensibly: Now, why is this a good analogy?
06:26:09 <byorgey> incomprehensibly: 'action' is a common name for values of type   m a   where m is an instance of Monad.  As a metaphor, I agree it doesn't work very well for Maybe.
06:26:15 <Cale> (to the usual English sense of action)
06:27:11 <dylukes> The metaphor I usually use is that "a monad provides some context to a value"
06:27:12 <Cale> Well, using the operations of the maybe monad, you can perform a sequence of these Maybe-typed actions, and if any one of them fails (that is, is equal to Nothing), the entire action fails.
06:27:19 <dylukes> since, that actually matches the type of Monad.
06:27:21 <dylukes> kind*
06:27:34 <Cale> > do x <- Just 1; y <- Just 2; z <- Just 3; return (x,y,z)
06:27:35 <lambdabot>   Just (1,2,3)
06:27:41 <dylukes> Mind you, I'm including nondeterminance and existence in "context"
06:27:41 <Cale> > do x <- Just 1; y <- Nothing; z <- Just 3; return (x,y,z)
06:27:42 <lambdabot>   Nothing
06:28:00 <incomprehensibly> what I'm disputing here is that action is an apt name for values of type Monad m => m a
06:28:17 <dylukes> Cale: You know, I wish for that a lot in other languages :P
06:28:17 <Cale> Computing y here had the "effect" of terminating the computation with failure.
06:28:18 <mux> I'm not even entering that discussion :-P
06:28:29 <incomprehensibly> it seems to me that since IO is a very prominent use of monads, people confuse it with all monads
06:28:39 <dylukes> IO is a terrible example of a monad.
06:28:43 <incomprehensibly> this is evident in other misunderstandings, such as thinking that monads are impure, or a feature of Haskell the language, etc.
06:28:47 <incomprehensibly> dylukes: of course
06:28:48 <dylukes> Actually, my recommendation is,
06:28:48 <mux> it's always hotly debated whether some analogy is pertinent enough, and 99% of the time, it just isn't
06:28:51 <Cale> IO is an okay example of a monad, but not the simplest one
06:28:53 <dylukes> don't treat IO a a monad.
06:28:57 <Phantom_Hoover> dylukes, it's just State RealWorld!
06:28:59 <dylukes> Treat it as something special.
06:29:03 <dylukes> Phantom_Hoover: ........
06:29:07 <Phantom_Hoover> Joking?
06:29:09 <dylukes> If only. ;)
06:29:12 <Cale> Phantom_Hoover: I also *hate* that analogy for the IO monad
06:29:45 <Cale> Because there is no RealWorld type which could possibly work there.
06:30:07 <incomprehensibly> yeah, I hate it too
06:30:09 <byorgey> yes there is!
06:30:10 <Cale> (and model concurrency and all the other stuff)
06:30:10 <byorgey> @package acme-realworld
06:30:11 <lambdabot> http://hackage.haskell.org/package/acme-realworld
06:30:13 <Phantom_Hoover> Cale, String, duh.
06:30:34 <Phantom_Hoover> I mean, we're always being told that the world is made of strings.
06:30:44 <dylukes> byorgey: Oh my god
06:30:47 <Cale> GHC's implementation of the IO monad is misleading because it puts effects into the functions (->)
06:30:47 <dylukes> this is such a bad idea XD
06:31:02 <dylukes> Cale: ?
06:31:45 <Cale> dylukes: GHC internally uses something which looks like a State monad to implement IO, but it's a State monad on a state type that's zero bits wide
06:31:55 <dylukes> Yeah :).
06:32:12 <Cale> and all the effects are encoded impurely
06:32:45 <aadrake> I am doing some experimentation with the mongodb library and I'm curious what kinds of operations I can do on the queries that are returned.  They are lists of Field type but I don't know how I can operate on these.  Does anyone know?
06:32:46 <Cale> Which is not a very enlightening description of the IO monad, given that there're perfectly good ones using (generalised) algebraic datatypes
06:33:09 <Cale> Well, pretty good anyway -- FFI would be a little hairy
06:33:25 <Phantom_Hoover> Link?
06:33:30 <aadrake> http://hackage.haskell.org/packages/archive/bson/0.1.6/doc/html/Data-Bson.html#t:Field is the type
06:34:43 <aadrake> So for example, if I wanted to concatenate all fields into a string or something, I'm not sure what functions I can use because I'm confused by the types.
06:34:44 <Cale> aadrake: The Haddock shows that the one dataconstructor of that type is exposed, so you can just pattern match on it
06:34:54 <Cale> (at least)
06:35:49 <Cale> Whoa, what the heck is this weird CompactString thing?
06:35:52 <aadrake> Cale: This is my second week with Haskell, can you give me an example of what you mean?
06:36:08 <Cale> oh, so like...
06:36:34 <dylukes> CompactString is deprecate.
06:36:39 <Cale> case myField of label := value -> ... use label and value here ...
06:36:42 <dylukes> Now it's Data.Text
06:37:22 <dylukes> Data.Text is kind of like Bytestring, but optimized for unicode text, and with stream fusion built in.
06:37:22 <aadrake> Cale: Let's say I have a list of Fields.  Is there an easy way to just jam all the values together?
06:37:24 <dylukes> And some other stuff.
06:37:34 <aadrake> Cale: I know I can't use concat on these
06:37:47 <Cale> aadrake: I don't understand what you mean by jamming them all together...
06:37:49 <Cale> well...
06:37:52 <Cale> okay
06:37:57 <Cale> you can discard the labels
06:38:09 <mux> you are about to be disappointed by haskell's records
06:38:12 * mux grins
06:38:16 <Cale> map (\(l := v) -> v) fields
06:38:37 <litb> hello all
06:38:49 <aadrake> mux: Me?
06:38:56 <litb> Cale: is this valid haskell syntax?
06:39:03 <litb> what does  ":=" mean
06:39:05 <Cale> litb: yes
06:39:09 <Cale> := is a data constructor
06:39:13 <litb> oh
06:39:54 <Cale> defined by the bson library
06:40:11 <mux> aadrake: yeah I meant you, but actually the Data.Bson thingie you're using isn't using real records, so just forget that comment :-)
06:40:22 <litb> ah i see
06:40:37 <Cale> mux: Yeah, I was going to say that Data.Bson kind of *is* a record system of sorts
06:41:15 * mux nods
06:41:23 <Cale> (it's not as fancy a record system as most people talk about when they mention adding extensible records to Haskell, or even as fancy as some of the other libraries for that...)
06:42:19 <aadrake> Cale: I'm evaluating Haskell for personal interest and because I'm considering it for data science work.  The mongodb integration is pretty important so hopefully it works well and I can encourage adoption :)
06:43:13 <aadrake> Cale: Fancy isn't that important, as long as it works fast and safely
06:43:57 <Cale> this bson implementation isn't so good, by the looks of it, but it might do
06:45:02 <aadrake> Cale: Are there any other options?
06:45:31 <Cale> I don't know, I've never even really looked at MongoDB :P
06:45:46 <mux> TIL that there are other software using BSON than BitTorrent
06:46:07 <Cale> oh, is this bson the same as that one?
06:46:14 <mux> I think so
06:46:27 <Cale> hmmm
06:46:41 <aadrake> mux: Really?
06:46:56 <aadrake> mux: That's interesting.
06:47:05 <aadrake> mux: It's a storage format for mongodb databases :)
06:47:15 <aadrake> mux: In addition to any other uses
06:47:19 <mux> aadrake: just open a .torrent file :-)
06:47:32 <Cale> The "BCode" encoding used in combinatorrent only has 4 constructors
06:47:36 <Cale> It's a similar concept
06:48:13 <Cale> But it doesn't have, e.g. a special constructor for Javascript :P
06:48:41 <aadrake> Cale: That map example works but could I modify it to also handle nested data?  For example, the case where you have a label and the value is another list of labels and values?
06:49:02 <mux> ah, wait, I was mistaken
06:49:19 <mux> BitTorrent's thing is Bencode, not BSON, my bad
06:50:04 <Cale> aadrake: what do you want to do in that case?
06:50:16 <Cale> What function of the fields are you trying to compute?
06:50:37 <aadrake> Cale: I'd like to take all the values and concatenate them
06:51:11 <Yrogirg> is there a function to turn [IO ()] to IO () ? .i.e will allow to treat list of IO () as a single IO () ?
06:51:16 <Cale> They're not all strings though... you mean, just in the case of Array values, flatten those out?
06:51:29 <Cale> Yrogirg: sequence_
06:51:53 <aadrake> Cale: I mean I want to concatenate them all into one string.
06:51:58 <Cale> Yrogirg: sequence :: [IO a] -> IO [a], and  sequence_ :: [IO a] -> IO ()
06:52:05 <aadrake> Cale: Regardless of their type.
06:52:26 <Cale> aadrake: Do you just want a 'show' of the whole thing?
06:53:03 <Yrogirg> ty Cale
06:53:31 <aadrake> Cale: I'd prefer not to use show because I'll be using this on a semi-large dataset and I think I read that show can slow things down.
06:53:58 <aadrake> Cale: Basically I'm getting back a list of Fields, I want to concatenate all the values together and md5 that
06:54:37 <aadrake> Cale: So it would be something like (md5 . concatFields) document
06:56:23 <Cale> aadrake: I bet it'd be easier to just encode the document with  runPut (putDocument myBsonThingy), and then md5 that.
06:57:00 <aadrake> Cale: You would know better than I.
06:57:06 <Cale> Chances are your md5 implementation works on ByteStrings of some sort too, so that'll likely be convenient.
06:57:58 <aadrake> Cale: It does, I'm using Data.Digest.Pure.MD5
06:59:24 <aadrake> Cale: So I use runPut which constructs the ByteString from the result of putDocument theBsonThing, which gets passed to the md5 function?
06:59:50 <Cale> yeah
06:59:56 <aadrake> Cale: and I need to construct putDocument
07:00:04 <Cale> putDocument is a library function
07:00:20 <Cale> http://hackage.haskell.org/packages/archive/bson/0.1.6/doc/html/Data-Bson-Binary.html
07:00:25 <aadrake> Cale: From Data.Binary.Put?
07:00:27 <aadrake> Ah
07:00:39 <aadrake> Cale: I thought it was in a different library
07:00:45 <Cale> Note that Document is another way of writing [Field]
07:01:31 <Cale> (It's a kind of silly type synonym, but I guess they use it enough...)
07:02:07 <Cale> Also note for the case of extracting values that you can pretend that Data.Bson.lookup :: (Val v) => Label -> Document -> Maybe v
07:02:35 <Cale> they're abusing the Monad class there for a purpose it should not really be used for
07:03:08 <aadrake> Cale: So I need to write myBsonThing which will take documents, pull out the values from the documents, and concatenate them, and then the rest is library functions.
07:03:10 <Cale> Oh, you could also use Either String v though
07:03:11 <aadrake> Is that correct?
07:03:17 <Cale> no
07:03:22 <Cale> You don't do any of that stuff
07:03:27 <Cale> You take your list of fields
07:03:33 <Cale> and that's myBsonDocument
07:03:53 <Cale> It's all library functions ;)
07:05:08 <kamyzi`e> hello, I'm trying to understand the state monad, how can I improve this code? http://hpaste.org/55799
07:05:34 <Cale> because the idea of converting each of the fields in your document somehow into a String in an ad-hoc way and then concatenating them and converting the result into a ByteString, just to MD5 the result, is really silly when the library is explicitly designed to do a binary encoding of the entire document into a ByteString in the first place
07:06:15 <aadrake> Cale: I don't see any myBsonDocument function anyhere
07:06:27 <aadrake> Cale: I agree, as long as I can hash the values only and not the labels as well
07:06:28 <Cale> That was just my name for your bson document
07:06:45 <Cale> oh, you want to be independent of the label names?
07:07:03 <Cale> What are you really trying to do :P
07:07:30 <aadrake> Cale: I want to take all the values, concatenate them, and md5 that, remember? :)
07:07:36 <parcs`> kamyzi`e: rewrite pop/push to use get/put/modify
07:07:55 <Cale> kamyzi`e: what parcs` just said ;)
07:08:57 <Cale> pop = do (Stack s (v:vs)) <- get; put (Stack (s - 1) vs); return v
07:09:05 <bytter> > (last . takeWhile (< 10)) [1, 2, 3, 4, 5, 11]
07:09:06 <lambdabot>   5
07:09:09 <Cale> oh, errr...
07:09:16 <Cale> no, that's okay :)
07:09:17 <bytter> is there a more primitive operation than last . takeWhile ?
07:09:28 <Cale> I was confused by your use of Int values :)
07:10:25 <rostayob> aadrake: I haven't followed the discussion, but a while ago I build a library to make it easier to work with bson documents: http://hackage.haskell.org/package/bson-mapping
07:10:53 <Cale> bytter: I believe that at one point the Gofer prelude had a function called takeUntil which would have turned that into  head . takeUntil (...)
07:11:00 <Cale> er
07:11:06 <Cale> I mean dropUntil, sorry
07:11:20 <Cale> (getting a bit punchy, been up a long time :)
07:11:41 <Cale> dropWhile will of course drop the element you're looking for, which is inconvenient
07:11:47 <bytter> Cale: exactly
07:12:03 <aadrake> rostayob: Cool, thank you.  Also, thank you for including an example in your documentation.
07:12:21 <bytter> Cale: so, nothing obvisouly primitive, right?
07:12:25 <Cale> right
07:12:41 <Cale> Well, you can still do better...
07:12:44 <rostayob> aadrake: let me know if it's useful :)
07:14:23 <aadrake> rostayob: I wish there were an easy way to automatically scan a file, database, etc., and build the data structure with all the possible labels instead of specifying it in the code.
07:14:39 <aadrake> rostayob: It's not so fun to write a large data structure definition for 50 or more labels
07:14:52 <rostayob> aadrake: it's possible to write something like that
07:14:52 <aadrake> rostayob: Especially when not all documents contain all labels
07:15:00 <aadrake> rostayob: But I think it would be slow
07:15:06 <rostayob> you just have to write a long enough TH function
07:15:11 <Cale> > let xs = [1,2,3,4,5,11] in head [x | (x,y) <- zip xs (tail xs), y > 10]
07:15:12 <lambdabot>   5
07:15:15 <rostayob> that generates the datatype given a sample document
07:15:46 <aadrake> rostayob: Yes, but the entire data set would have to be scanned first.  I guess it's not a big deal because it need only be done once.
07:16:16 <rostayob> aadrake: the entire data set would need to be scanned first? so documents are inconsistent with each other?
07:16:27 <rostayob> e.g. different labels, different types for the labels, etc?
07:16:30 <Cale> I don't know if that's really better or not, but at least it doesn't involve last
07:16:34 <rostayob> because than the problem is harier
07:16:37 <aadrake> rostayob: Correct.  Not all documents may have all labels
07:16:50 <aadrake> rostayob: Each document will have a subset of the total set of possible labels.
07:17:00 <rostayob> well then you need just one document
07:17:06 <rostayob> and all fields are 'Maybe a'
07:17:08 <Cale> bytter: ^^
07:17:09 <rostayob> well
07:17:11 <rostayob> 'Maybe Value'
07:17:24 <aadrake> rostayob: Yes, but you have to know which fields exist in the dataset.
07:17:26 <rostayob> and you provide the set of possible labels
07:17:36 <rostayob> aadrake: well if you built the database you probably know that don't you :P?
07:18:07 <aadrake> rostayob: I don't always build the datasets.  I do the research and data science on them.  :)
07:18:23 <rostayob> ah. well then yes, you might want to scan the database
07:18:28 <kamyzi`e> Cale: thanks
07:18:33 <rostayob> i can understand the annoyance
07:19:55 <aadrake> rostayob: It basically reduces to a parsing problem wherein the whole dataset has to be scanned and a structure built.  It would be slow but also would only need to be done once per dataset.
07:20:07 <rostayob> aadrake: yes.
07:20:15 <aadrake> rostayob: That may be a fun project
07:20:34 <rostayob> then you might even do more sophisticated analysis, like multiple types for the same labels that result in a final sum type in Haskell
07:20:56 <rostayob> aadrake: it's not that hard to do, but it'd be quicker if you already have a lot of data sets to play with, and I don't :P
07:22:31 <aadrake> rostayob: You can get quite a few datasets online just by querying sites that are capable of returning JSON.
07:22:51 <rostayob> aadrake: i guess. maybe sometime if i have time
07:23:48 <rostayob> but you can do it as well, you just need a meta-representation of the kind of datatype that holds a BSON document and then a function that creates a TH declaration
07:24:48 <aadrake> rostayob: I'm two weeks in with Haskell, so that project may have to wait until after I solve the immediate work-related problems :)
07:24:56 <rostayob> aadrake:  ok :)
07:25:19 <Cale> MongoDB looks like a step in the opposite direction from where I'd like database queries to go :P
07:25:20 <aadrake> rostayob: It would be a useful tool for data science stuff though, so I'll have a go at it when I'm more productive with the language.
07:25:27 <rostayob> Cale: I agree
07:26:07 <rostayob> but that's the point of NoSQL databases I guess...
07:26:36 <aadrake> cale: It has its good points and bad points.  There are place where MongoDB is a sensible choice but I think too many people flock to it because it's the flavor of the month.
07:26:39 <mike-burns> Hah, NoSQL is all about having a crappy query language.
07:27:03 <rostayob> mike-burns: well, no transactions, no sophisticated aggregate operators, etc....
07:27:13 <rostayob> it's part of making everything really fast
07:27:16 <mike-burns> rostayob: Oh sure, I suppose it's about those too.
07:27:18 <Cale> SQL *does* suck, but only being able to query key/value pairs sucks way more.
07:27:34 <rostayob> it's the price to pay to be really fast
07:27:46 <mike-burns> Have we said the phrase "Web scale" yet?
07:27:58 <rostayob> yeah so we'll be buzzwords-compliant
07:28:12 <aadrake> mike-burns: MongoDB is web scale and cloud compatible
07:28:16 <mike-burns> Thank you.
07:28:19 <Cale> rostayob: so you can get the wrong answer really really quickly?
07:28:40 <rostayob> Cale: well, more like the right answer to simple questions really quickly
07:28:49 <mike-burns> Unless it didn't save it.
07:28:57 <Cale> and the wrong answer to anything more complicated than a simple question
07:29:09 <rostayob> well, it's "right" in the domain of "no ACID watsoever"!
07:29:15 <Enigmagic> mike-burns: or if mr programmer didn't use the 'save to disk' option, yea
07:29:29 <rostayob> Cale: you can't even ask a complicated question
07:29:42 <rostayob> and you have no isolation on aggregate operators usually
07:29:44 <rostayob> but that's understood
07:30:01 <Enigmagic> inline javascript can answer all questions
07:30:27 <mike-burns> MongoDB makes sense in some contexts. The "NoSQL" name makes people compare it to e.g. Postgres, which leads to people hating Mongo for not doing what Postgres does.
07:30:34 <Cale> rostayob: well, you can, you just have to do it by asking more than one simple question separately, at which point you don't know whether the results of previous queries you made have changed by the end of it, but you can cross your fingers and hope
07:30:49 <rostayob> Cale: well but you should know what you're doing...
07:31:12 <rostayob> mongo doesn't even suggest that it can do or aid in doing isolated transaction, which is what you want
07:31:37 <aadrake> mike-burns: When you need to write a lot of data really quickly for some kind of non-critical logging then MongoDB is pretty useful
07:32:02 <rostayob> that said i prefer by miles a sql database if it's fast enough
07:32:15 <mike-burns> aadrake: Yup. That's about all I've been able to come up with, too.
07:32:28 <mike-burns> Though a local startup did get up and running quickly by using Mongo for everything.
07:32:37 <mike-burns> And now they're porting more over to SQL.
07:32:51 <rostayob> aadrake: well not only logging. a lot of times isolations when doing aggregate operations doesn't really matter, which is why MapReduce worked so well for google & co.
07:32:52 <Enigmagic> i've found it useful as a pre-sql step, for sure.
07:32:59 <aadrake> mike-burns: That's a normal cycle.  Company uses a NoSQL DB for the wrong reasons and then ends up on Postgres or something later
07:33:38 <Enigmagic> aadrake: or because it's faster to iterate on before the product is locked down
07:33:46 <Enigmagic> for us at least
07:34:14 <aadrake> Enigmagic: In development, sure, because you don't have to bother with schema changes
07:34:41 <Enigmagic> yep
07:34:45 <aadrake> Enigmagic: I'm not saying it's horrible or anything, I'm just saying it gets misused and a lot of people have the wrong expectations from it
07:34:56 <Enigmagic> aadrake: sql gets misused too
07:35:06 <aadrake> Enigmagic: So does MS Excel :)
07:35:07 <Enigmagic> turns out software development is hard
07:35:57 <Cale> But if you're just in development and don't have that much data yet and you don't have to worry about what form your data is in, you might as well be using datastructures which are just native to whatever language you're using, and super-simple serialisation, I'd think.
07:36:00 <rostayob> aadrake: well, some companies run on Excel. Excel can do remarkable things lol
07:36:17 <rostayob> Cale: or better, data structures and safe-copy (and maybe acid-state).
07:36:21 <srhb`> rostayob: Remarkable as in "Holy shit, what are you doing..." :-)
07:36:49 <rostayob> srhb`: :)
07:36:57 <Enigmagic> Cale: certainly could be an option, and there isn't a right answer
07:37:24 <Enigmagic> i'm lazy and don't like managing files and indexes
07:37:56 <aadrake> rostayob: Excel is especially abused in data science and financial mathematics applications.  The financial people love Excel and try to use it for every possible analysis task where they should definitely be using some kind of databse.
07:38:22 <Enigmagic> but you can program excel with VBA
07:38:32 <rostayob> aadrake: I know I know, loads of VB
07:38:54 <rostayob> but for being a spreadsheet application, it is really powerful
07:39:36 <Cale> aadrake: Better than the marketing people who are using powerpoint for spreadsheets ;)
07:39:36 <aadrake> rostayob: It is useful and convenient for small problems, but in that arena you may as well use R
07:39:53 <rostayob> Cale: ahah. how do you do that?
07:40:03 <aadrake> Cale: Inserting tables into slides?
07:40:10 <Enigmagic> yep
07:40:25 <Enigmagic> you can also mix in a photo slideshow between spreadsheets
07:40:44 <Cale> aadrake: http://www.thewebsiteisdown.com/ :D
07:41:12 <Cale> (see episode 2 :)
07:41:20 <Enigmagic> and also excel art http://bp0.blogger.com/_kQmcDGJ6WuI/R3EO4W48mQI/AAAAAAAAAIU/p7C6tty6DKU/s1600-h/Pig+Plugged.bmp
07:41:23 <aadrake> Cale: I've seen them.
07:41:32 <n00b_> hi
07:41:36 <n00b_> i am a n00b
07:41:45 <Cale> hi
07:41:48 <dylukes> hi
07:41:58 <aadrake> cale: Have you ever looked at the Bastard Operator from Hell (BoFH)?
07:42:15 <dylukes> aadrake I guess you saw my part message?
07:42:34 <aadrake> dylukes: No, I didn't
07:42:44 <dylukes> It was a reference to BOFH.
07:42:52 <aadrake> dylukes: Ah
07:42:53 <yitz> aadrake: you drawn a line-art grid on your slide, and put numbers between the lines. use the calculator on your phone to figure out the numbers, then copy them in by hand digit by digit. it's really hitech.
07:42:56 <n00b_> So which book do you guys recommend for haskell?
07:42:59 <dylukes> "Pipes are broken. Sending packets via Fedex."
07:43:02 <aadrake> dylukes: I didn't get any message
07:43:14 <aadrake> dylukes: It's good to know that somebody remembers that from the old days :)
07:43:16 <Cale> aadrake: yes :)
07:43:17 <n00b_> I mainly wish to solve problems on spoj using haskell
07:43:26 <n00b_> anyone?
07:43:31 <Cale> n00b_: Start with lyah
07:43:38 <aadrake> yitz: That's obscene
07:43:39 <Cale> http://learnyouahaskell.com/
07:44:02 <yitz> @where lyah
07:44:03 <lambdabot> http://www.learnyouahaskell.com/
07:44:03 <n00b_> thank you
07:44:12 <dylukes> n00b_: beware though, "fast" haskell and "elegant" haskell are not always one and the same.
07:44:21 <aadrake> dylukes: Truth
07:44:23 <dylukes> You'll hit a dead end with spoj problems if you try to use lazy input for instance.
07:44:42 <rostayob> Cale: that is pretty funny
07:44:47 <Cale> Though, I've found it frequently the case that I can speed up a Haskell program by making it shorter
07:45:07 <dylukes> Cale: very true
07:45:11 <n00b_> so i think i ll get started
07:45:23 <dylukes> because at least in haskell you can almost always optimize by factoring
07:45:25 <dylukes> :P
07:45:27 <yitz> i've heard that the haskell compiler available on spoj is usually pretty old. is that still true?
07:45:29 <Cale> But understanding performance of Haskell code isn't exactly a beginner topic
07:45:30 <n00b_> anything else i should keep in mind?
07:46:00 <Cale> You need to learn to write programs that work before you can get a feel for how to write programs which run quickly.
07:46:01 <dylukes> n00b_: Well you see, monads are like metaphors...
07:46:08 <dylukes> Ignore me.
07:46:11 <dylukes> Cale has the right idea.
07:46:46 <Cale> n00b_: Are you already familiar with some other language(s)?
07:46:47 <q0tw4> Haskell + supercompiller even better than C
07:46:59 <n00b_> yes c,c++ ,python
07:47:01 <yitz> n00b_: following Cale, perhaps try project euler before spoj
07:47:12 <n00b_> scheme i haven't programmed much in scheme though
07:47:39 <Cale> n00b_: Okay, so one little mantra to keep in mind is that lists are our loops
07:48:21 <Cale> n00b_: A loop either never occurs, or it consists of a single iteration followed by another loop. A list is either empty, or it consists of a single element followed by another list.
07:48:24 <n00b_> yes, i am familiar with functional programming, although to a very small extent
07:48:40 <Cale> This connection is made much truer with lazy lists.
07:48:41 <n00b_> recursion with loops basically right?
07:49:11 <Cale> You're actually eventually not going to want to do recursion directly so much.
07:49:12 <yitz> n00b_: recursion is important in haskell, but less so than in some other functional languages
07:49:22 <Cale> You want to be using higher order functions
07:49:47 <Cale> But everything can be implemented in terms of recursion, so it's a decent place to begin.
07:50:03 <n00b_> ok and thank you
07:50:35 <Cale> and it's a good place to go back to if you don't know what you're doing, because you can usually hammer out a recursive solution even if exactly how to put together higher order functions to do something isn't immediately clear
07:51:03 <dylukes> yitz: Once you master fix and Cont recursion is no more fun anymore.
07:51:25 <dylukes> It's way more fun to fix a block of code passing in a continuation to clean up resources and escape :3.
07:51:26 <n00b_> have any of you used functional programming for real projects or in your jobs?
07:51:36 <Cale> n00b_: I'm using Haskell for my job
07:51:41 * dylukes points at kmc, copumpkin, dolio, Cale, ...
07:51:57 <n00b_> can you tell me how exactly you use it?
07:51:58 <rostayob> kmc is working?
07:52:00 <rostayob> :)
07:52:01 <Cale> n00b_: I'm working for a startup on an action RPG in Haskell for iPhones and other mobile devices.
07:52:05 <dylukes> rostayob: oh whoops, forgot ;P
07:52:12 <dylukes> Cale: :0
07:52:14 <saati> Cale: is it out?
07:52:19 <Cale> saati: nope
07:52:24 <dylukes> Is it going to be NOT shitty. I would love a good action RPG on my phone.
07:52:26 <dylukes> er, my ipod.
07:52:29 <aadrake> n00b_: I'm learning Haskell for my job right now
07:52:40 <Cale> dylukes: I hope so :)
07:52:53 <dylukes> ^^
07:53:00 <dylukes> Any inspirations you can name?
07:53:05 <saati> Cale: doesn't the iphone sdk license forbid that? i mean using other languages than objc(++)
07:53:14 <dylukes> I always loved me some Secret of Mana, even though it was really turn based in disguise ;P.
07:53:15 <n00b_> to the guys who use functional programming: is there something which necessitates the use of functional programming in your work?
07:53:35 <Cale> saati: no, that rule no longer exists, and only ever really applied to Adobe
07:53:41 <dylukes> n00b_: Very rarely does something necesitate a certain style.
07:53:47 <dylukes> Except complying with your workplace.
07:54:00 <dylukes> You use whatever gives you the best productivity for the task at hand.
07:54:04 <saati> dylukes: all games are turn based, "real-time" games just use very short turn
07:54:06 <saati> s
07:54:36 <dylukes> saati: Not exactly. That's a simplistic view.
07:54:37 <Silvah> saati: is real life turn-based, too?
07:54:42 <aadrake> n00b_: For me the benefits are speed and non-strictness.  It makes a lot of things easier in the data science arena.
07:54:56 <danols_work> omg someone take me away from python and give me a real job :(
07:54:58 <saati> dylukes: do you have a counter example?
07:54:59 <Cale> dylukes: It's sort of Diablo-ish in a way. You run around with a giant hammer smashing monsters and doing magic with the blood :)
07:55:04 <pigdude> danols_work, ...
07:55:12 <dylukes> Cale: :P. Sounds like an interesting premise.
07:55:17 <danols_work> no response is needed just needed to went that one liner
07:55:24 <dylukes> saati: Well no, because computers are finite.
07:55:24 <pigdude> danols_work, ^^
07:55:26 <dylukes> Anyways
07:55:42 <dylukes> Cale: How hard/easy is it to use Haskell on iOS?
07:55:43 <Cale> dylukes: There's a whole story written up and everything, but I haven't really read it
07:55:52 <pigdude> danols_work, at least you aren't coding php all day and what not
07:56:01 <dylukes> Are you crosscompiling and using HOC or something? Or just the Haskell->C FFI...?
07:56:05 <danols_work> i'm just getting furious that I got duped into python I picked it cause I wanted to leave php
07:56:08 <EvanR-hardlabor> pigdude: :(
07:56:16 <dylukes> danols_work: Python isn't that bad.
07:56:22 <danols_work> it's not strong typed
07:56:26 <dylukes> Python3 finally clears up the object model.
07:56:26 <pigdude> danols_work, no, it isn't
07:56:29 <EvanR-hardlabor> 'not that bad' == bad
07:56:35 <danols_work> the more I use it the more I find the gatchas
07:56:42 <pigdude> danols_work, such as
07:56:48 <n00b_> So is Hugs a decent interpreter for a beginner?
07:57:02 <Cale> dylukes: Well, we're making it possible... where by "we" I mean Stephen Blackheath. We're using native ARM codegen in GHC, and there's going to be a new crosscompiling mode which we're contributing back to GHC (won't be in for 7.4, but probably 7.6 or whatever is after)
07:57:03 <pigdude> n00b_, i think ghci is fine
07:57:06 <danols_work> pigdude: when I was reading on it it was the selling point --- strong typed --- not it's not so bold stating that :P
07:57:19 <dylukes> Cale: Awesome!
07:57:29 <danols_work> anywho sorry guys --- just venting
07:57:30 <danols_work> i'm done
07:57:32 <danols_work> now back to work
07:57:32 <dylukes> I've been hoping for a cross compiling module. You building off the LLVM codegen?
07:57:35 <pigdude> danols_work, good luck :^)
07:57:40 <Cale> yeah, now we are
07:57:42 <EvanR-hardlabor> n00b_: about function programming at work, functional is necessary like a matress and blankets are necessary to sleep
07:57:57 <dylukes> the LLVM codegen should be able to produce ARM code regardless, but the question is if the runtime can be crosscompiled and linked.
07:57:58 <dylukes> :\
07:58:00 <Cale> Before we were using straight ARM code generation which GHC actually does have :)
07:58:14 <dylukes> Neat :).
07:58:17 <n00b_> Can you please elaborate @Evar-hardlabor
07:58:29 <EvanR-hardlabor> tab complete
07:58:31 <dylukes> they're not essential, but they make it much more pleasant.
07:58:41 <EvanR-hardlabor> they make it tolerable
07:58:43 <EvanR-hardlabor> is what i would say
07:59:01 <Cale> I'm not the best person to ask about this sort of thing though, you should catch blackh when he's on IRC at some point if you're really interested in this stuff.
07:59:18 <dylukes> Cale: Well the reason I ask is,
07:59:21 <Cale> (I just use it, and know what I've heard from the daily meetings)
07:59:24 <dylukes> I've been wanting to use Haskell on my Android :P
07:59:33 <Cale> Right, we hope to eventually make that work too
07:59:46 <dylukes> I have a cortex-A9 based TI-OMAP on my gnex.
07:59:53 <dylukes> So, standard ARMv7
08:00:03 <dylukes> plus NEON I believe.
08:00:27 <dylukes> neat :).
08:00:34 <dylukes> Haskell on ALL the embedded devices.
08:00:59 <Cale> Well, all the embedded devices with large enough memories to contain the RTS and a Haskell program :P
08:01:08 <dylukes> How much mem does the RTS need?
08:01:12 <dylukes> I have 1GB on my phone >.>
08:01:16 <dylukes> I doubt I'm lacking.
08:01:19 <Cale> yeah, that's fine
08:01:30 <dylukes> Isn't the RT like in the vicinity of under a hundred mbs?
08:01:36 <Cale> When you get down to microcontrollers with a handful of kilobytes of memory...
08:01:43 <Cale> hehe
08:01:45 <dylukes> Well... yeah that's not happening ^^;
08:02:01 <dylukes> you know, it would be a neat trick to take systems like that with limited IO
08:02:05 <dylukes> reduce them to FSM's
08:02:09 <dylukes> and unroll the runtime entirely.
08:02:14 <flux> dylukes, how much memory do you have in your ADSL or Wifi routers or microwave oven?-)
08:02:17 <dylukes> Then optimize away all the dead code :D
08:02:21 <dylukes> flux: >.>
08:02:53 <saati> flux: routers can have a lot of memory
08:02:59 <flux> saati, yes, but home routers do not
08:03:16 <aadrake> Cale: The types are driving me nuts with this MongoDB interface.  It forces me to research every function to figure out the type signature, which is good for learning I guess, but it sure does dampen productivity :)
08:04:08 <saati> flux: it seems mine has 16M, that should be able to hold the rts
08:04:40 <humasect> hey guys! i've got map ((++) ".end") [] which gives me [".endstring"..] but i want it ["string.end"..],and i have had too much coffeee to wrap my head on this
08:04:44 <flux> saati, well, it's doing what it's doing now with 16M, I wonder how much of it you could use for RTS and have it still do its job?
08:05:11 <dylukes> humasect: flip ++
08:05:17 <EvanR-hardlabor> aadrake: if you didnt get the types right, how productive would you be when the finished product collapses in on itself inexplicably ;)
08:05:18 <humasect> ohh!! thank you =)
08:05:28 <dylukes> uh, let me check
08:05:31 <dylukes> I have a piece of code that does this
08:05:45 <Saizan> (++ ".end")
08:05:51 <dylukes> yeah or that
08:06:00 <humasect> are those different.
08:06:01 <dylukes> > (++ ".end") "foo"
08:06:02 <humasect> ..*
08:06:03 <lambdabot>   "foo.end"
08:06:13 <aadrake> EvanR-hardlabor: I'm saying that it seems the steep learning curve of Haskell is just a matter of committing all kinds of type signatures to memory.
08:06:16 <dylukes> map (++ ".end") ["foo", "bar", "baz"]
08:06:19 <humasect> ohh i wasnt aware that (++ ...) could be correct syntax
08:06:21 <dylukes> > map (++ ".end") ["foo", "bar", "baz"]
08:06:22 <lambdabot>   ["foo.end","bar.end","baz.end"]
08:06:23 <mux> (++ ".end") would be much more idiomatic
08:06:28 <dylukes> humasect: that syntax is called a "section"
08:06:32 <humasect> nice. thats perfect!
08:06:33 <EvanR-hardlabor> aadrake: ive heard that before, people complaining that they cant program because they cant remember stuff
08:06:33 <dylukes> > (+1) 1
08:06:34 <humasect> a section?
08:06:34 <lambdabot>   2
08:06:34 <ion> > ("foo" ++) . (++ "baz") $ "bar"
08:06:36 <lambdabot>   "foobarbaz"
08:06:36 <dylukes> > (1+) 1
08:06:37 <lambdabot>   2
08:06:40 <dylukes> > (+) 1 1
08:06:40 <lambdabot>   2
08:06:50 <EvanR-hardlabor> aadrake: thats why we have references and documentation
08:06:53 <dylukes> for infix operators in parentheses you can supply one/both arguments.
08:06:55 <humasect> ohh ohh interesting!
08:07:03 <dylukes> More relevant:
08:07:07 <dylukes> > (-5) 10
08:07:08 <lambdabot>   -5
08:07:11 <ion> > 1 1
08:07:12 <lambdabot>   1
08:07:13 <dylukes> > (5-) 10
08:07:14 <lambdabot>   -5
08:07:16 <EvanR-hardlabor> programming isnt an exercise in vast memorization
08:07:25 <dylukes> > ((-)5) 10
08:07:26 <lambdabot>   -5
08:07:26 <Cale> aadrake: The type signatures are most of the documentation that you need though.
08:07:30 <humasect> haha awesome. love you guys
08:07:41 <ion> > (5 `subtract`) 10
08:07:42 <lambdabot>   5
08:07:42 <dylukes> gah
08:07:45 <aadrake> EvanR-hardlabor: Agreed, but it sure it annoying when learning because when using libraries there are non-standard datatypes and I'm not always sure which functions I can use on which types.  Hoogle.  I know.  :)
08:07:45 <dylukes> ion: there we go
08:07:46 <dylukes> yeah
08:07:49 <dylukes> (-) is a special case.
08:07:53 <dylukes> Because of the syntax for negatives.
08:07:55 <dylukes> It's obnoxious.
08:08:07 <dylukes> > (-5) 10
08:08:08 <lambdabot>   -5
08:08:08 <humasect> ion: i was thinking that, but wasnt sure if syntax was correct. i should be more adventurous
08:08:13 <EvanR-hardlabor> aadrake: i can almost be sure that mongoDB bindings are a terrible way to 'learn the language'
08:08:13 <Silvah> > (subtract 5) 10
08:08:14 <lambdabot>   5
08:08:16 <dylukes> you'd expect positive 5...
08:08:22 <aadrake> Cale: That is convenient
08:08:34 <Cale> dylukes: well, you're using the Num instance for functions there...
08:08:39 <ion> {-# LANGUAGE NoSpecialMinus #-}
08:08:42 <humasect> heh
08:08:47 <saati> why didn't haskell keep the ML ~?
08:08:48 <dylukes> ion: is that real?
08:09:00 <Cale> To be perfectly honest, I love Haskell's compromise on the syntax of numbers.
08:09:29 <Cale> and unary negation
08:09:31 <aadrake> EvanR-hardlabor: You may be right, but that's what I need to do to get work done.  Interfacing R and MongoDB wasn't bad, but wasn't easy.  Doing it in Haskell is orders of magnitude more difficult.
08:09:32 <dylukes> It's not bad.
08:09:44 <Cale> At least it gets the precedence right
08:09:50 <dylukes> :P
08:09:50 <Cale> > -5^2
08:09:51 <lambdabot>   -25
08:10:06 <EvanR-hardlabor> aadrake: yes im questioning your sanity for throwing R, haskell, and mongoDB into a stew ;)
08:10:26 <ion> dylukes: Nope :-\
08:10:28 <pigdude> oh god mongo
08:10:33 <aadrake> EvanR-hardlabor: It's a hearty stew.
08:10:41 <pigdude> mongodb is never the answer
08:10:47 <srhb`> Coming from ML, I've been using foldl because of tail recursion issues, but in Haskell I'm supposed to use foldr because of laziness, except, and this is my question, if my function will always traverse the entire list?
08:11:07 <dylukes> It will only traverse as much as you use...
08:11:12 <dylukes> It's lazy ;).
08:11:14 <Cale> @src foldr
08:11:14 <lambdabot> foldr f z []     = z
08:11:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:11:26 <Cale> foldr immediately passes control to f in the recursive case
08:11:35 <aadrake> pigdude: I don't always get to choose where the data lives, but I do have to analyze it.  :)
08:11:44 <Cale> and continues only if f examines its second argument
08:11:49 <Cale> @src foldl
08:11:49 <lambdabot> foldl f z []     = z
08:11:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:11:52 <srhb`> So the answer is "always use foldr"
08:11:57 <dylukes> how do you do lambdas with multiple cases?
08:11:57 <Cale> nope ;)
08:12:01 <Cale> foldr or foldl'
08:12:01 <dylukes> srhb`: there are times for both :)
08:12:06 <Cale> foldl' is a strictified foldl
08:12:17 <srhb`> Ah yes.
08:12:20 <EvanR-hardlabor> whats the problem with foldl
08:12:29 <aadrake> EvanR-hardlabor: It can be really slow
08:12:33 <dylukes> > map (\0 -> undefined; _ -> 1) [1,2,3,4,5,0]
08:12:34 <lambdabot>   <no location info>: parse error on input `;'
08:12:34 <aadrake> EvanR-hardlabor: That's all I know :)
08:12:40 <dylukes> > map (\0 -> undefined; \_ -> 1) [1,2,3,4,5,0]
08:12:40 <lambdabot>   <no location info>: parse error on input `;'
08:12:41 <Cale> the problem with plain foldl is that it builds up large expressions and then evaluates them only at the end
08:12:46 <EvanR-hardlabor> sleep is usually not a problem
08:12:54 <EvanR-hardlabor> speed*
08:13:01 <srhb`> Cale: So that is actually a side effect of laziness?
08:13:11 <dylukes> srhb`: http://book.realworldhaskell.org/read/profiling-and-optimization.html
08:13:16 <EvanR-hardlabor> so foldl might use a lot of memory?
08:13:17 <Cale> foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) ((0+1)+2) [3] -> foldl (+) (((0+1)+2)+3) [] -> ((0+1)+2)+3
08:13:18 <aadrake> srhb`: Side effect may not be the best choice of words
08:13:18 <dylukes> this is actually pretty relevant.
08:13:30 <srhb`> aadrake: In the common sense, I mean.
08:13:31 <dylukes> Basically you're building up a big thunk.
08:13:33 <Cale> srhb`: that's how the evaluation looks for foldl
08:13:41 <dylukes> Whereas the strictified foldl' does not.
08:13:44 <Cale> s/thunk/expression/ if you prefer
08:13:45 <Silvah> EvanR-hardlabor: sleep is quite often a problem, actually.
08:13:49 <dylukes> (it forces evaluation as you go)
08:14:01 <srhb`> Thank you all. :)
08:14:11 <aadrake> srhb`: Have a nice day.
08:14:12 <Cale> I honestly don't like using the word thunk, it makes me think of code pointers and such.
08:14:12 <asda8> hm, I would need my database connection burried deep in a module: I don't want to add the connection as an argument to every function in order to make it available, I also don't want to use the reader monad, because i'm already in IO and liftIO would also clutter my code. Are there any alternatives?
08:14:33 <Cale> and thunks are just runtime representations of expressions anyway
08:14:42 <parcs`> > foldl (+) [1..1000000]
08:14:43 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
08:14:43 <lambdabot>    arising from a us...
08:14:45 <EvanR-hardlabor> asda8: no
08:14:47 <parcs`> > foldl (+) 0 [1..1000000]
08:14:48 <lambdabot>   *Exception: stack overflow
08:14:48 <ion> If your HOF is lazy on the accumulator parameter and you want the fold to work on infinite lists, use foldr. If your HOF is strict on the accumulator parameter (for instance, you want to calculate a sum of integers) and you’re okay with getting a result out after traversing the entire list, use foldl'.
08:14:52 <parcs`> > foldl' (+) 0 [1..1000000]
08:14:52 <dylukes> asda8: If every function in the module is parameterized by the connection,
08:14:53 <lambdabot>   500000500000
08:14:55 <dylukes> then you'll probably need to.
08:15:00 <dylukes> It makes sense that you would.
08:15:19 <Cale> srhb`: the important thing to realise when/if you see "stack overflow" is that the stack isn't a call stack
08:15:24 <Cale> (there is no call stack)
08:15:26 <dylukes> Remember, iwhat n other languages is global and implicit state has to be explicit.
08:15:36 <srhb`> Cale: But an "expression stack"..
08:15:48 <Cale> The stack consists of pattern matches which are waiting for their scrutinee to be sufficiently evaluated to pattern match
08:16:02 <EvanR-hardlabor> asda8: perhaps you shouldnt be doing database stuff 'deep' in a module
08:16:04 <Cale> In this case, they're all the pattern matches done by (+)
08:16:11 <srhb`> Ah yes.
08:16:15 <srhb`> I see it. :)
08:16:25 <srhb`> I forget to think of operators like that.
08:16:28 <yitz> asda8: you can group together operations that don't need the db into functions of type IO, then invoke the entire group with a single function call
08:16:50 <dylukes> srhb`: http://blog.ezyang.com/2011/04/the-haskell-heap/
08:17:01 <Cale> foldl happily builds a big expression looking like ((...((0+1)+...)+999999)+1000000
08:17:05 <dylukes> E. Zyang wrote this blog post on the topic. It has fun illustrations.
08:17:08 <Cale> and then the outermost (+)
08:17:13 <Cale> (...) + 1000000
08:17:14 <yitz> asda8: if things that need and don't need the db are densely interspersed, then using liftIO to identify clearly those that don't isn't clutter.
08:17:22 <Cale> needs to know what its left parameter is
08:17:44 <Cale> and that's where the stack starts building up
08:17:54 <Cale> (at least in GHC)
08:18:23 <asda8> EvanR-hardlabor: I think it's fairly good code, I'm mostly passing prepared statements around and it's quite readable this way. The problem is that in some rare cases 1/10000 I need to make a special query, it's an exception. Passing it around as a statement would be bad too in my opinion
08:18:33 <Cale> It does, internally, something like  case x of I# v -> ...
08:18:51 <EvanR-hardlabor> asda8: prepared statements are pointless
08:19:12 <asda8> EvanR-hardlabor: really, why?
08:19:13 <aadrake> Cale: Did you say that [Value] is the same as Document?
08:19:14 <Cale> Or maybe that should be S# or J# for the Integer type ;)
08:19:17 <dylukes> EvanR-hardlabor: Why?
08:19:24 <Cale> aadrake: no, [Field] is the same as Document
08:19:30 <dylukes> asda8: You could do Either PreparedStatement CustomQuery
08:19:32 <dylukes> and pattern match.
08:20:02 <aadrake> Cale: ah, got it.  I'm battling with (print . md5 . runPut . putDocument . docConcat . exclude ["_id"]) and everybody wants a different type
08:20:10 <asda8> dylukes: I need both and most of the time only one
08:20:13 <EvanR-hardlabor> in mysql they are pointless because they do harm and no good, or they do harm and do good that you could be doing another way
08:20:25 <asda8> EvanR-hardlabor: I'm using SQL Server
08:20:27 <EvanR-hardlabor> usually the former
08:20:34 <EvanR-hardlabor> sorry to hear that
08:20:42 <Cale> aadrake: You need to make a document for putDocument to work, so if you want to discard the field labels, I dunno, maybe try replacing them all with the empty string?
08:20:51 <asda8> EvanR-hardlabor: yeah, but it's still better than mysql
08:21:02 <Cale> aadrake: I mean, you're just going to md5 the whole bunch of gibberish in the end anyway
08:21:05 <aadrake> Cale: There is a document that gets passed into that bunch of functions
08:21:15 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml explains foldl (+)
08:21:20 <Cale> yeah, I figured you'd just work on that
08:21:34 <Cale> (apply putDocument directly, and don't discard the field names)
08:21:36 <EvanR-hardlabor> asda8: if prepared statements are necessary in SQL server, then in this case no
08:21:40 <parcs`> prepared statements automatically serialize their input parameters
08:21:49 <Cale> Unless you have a really good reason why they need to be discarded
08:21:54 <EvanR-hardlabor> parcs`: better ways to do that in haskell
08:22:07 <EvanR-hardlabor> its a silly giant subsystem to use to safety construct queries
08:22:09 <parcs`> er, i meant escape, not serialize
08:22:18 <EvanR-hardlabor> what i say stands
08:22:30 <aadrake> Cale: I have to exclude the id because then every single document will have a unique md5 and I won't be able to detect duplicates
08:23:01 <asda8> EvanR-hardlabor: they're faster aren't they?
08:23:11 <EvanR-hardlabor> faster than what
08:23:13 <parcs`> asda8: when executed multiple times
08:23:30 <asda8> EvanR-hardlabor: like running the same query over and over again as a raw string
08:23:38 <EvanR-hardlabor> if you are trying to insert a large amount of data into a database, then you need to use LOAD DATA IN FILE
08:23:46 <EvanR-hardlabor> in mysql
08:24:31 <asda8> EvanR-hardlabor: hm, didn't know about it. but i'm not using mysql anyway
08:24:42 <EvanR-hardlabor> asda8: if its a query, you probably arent running it 'over and over'
08:25:02 <EvanR-hardlabor> in a loop
08:25:32 <EvanR-hardlabor> if its large data insertion, then the network protocol is a really bad move
08:25:50 <asda8> EvanR-hardlabor: I need to get a lot, I mean a LOT of rows out of the database. It only works with a certain amount of rows at a time
08:26:05 <asda8> EvanR-hardlabor: so I'm running the query repeately in a loop
08:26:09 <Cale> aadrake: what does one of these records look like?
08:26:10 * EvanR-hardlabor scratches head
08:26:36 <dylukes> http://cl.ly/CvUL
08:26:36 <dylukes> :D
08:26:39 <dylukes> look, look, look
08:26:42 <dylukes> it WORKS
08:26:56 <dylukes> Fuck I need to scale 0 to 1...
08:26:59 <EvanR-hardlabor> asda8: get your data out, then process it
08:27:12 <EvanR-hardlabor> DBMS suck at complex processing
08:27:18 <aadrake> Cale: I can't post any of them, but it's basically {label1 : {labels and values}, label2 : {labels and values}, label3 : "whatever"} etc.
08:27:55 <aadrake> Cale: The return from the query and the map function you gave me gets rid of that first level of labels but not subsequent levels.
08:28:02 <Cale> aadrake: yeah... I'm just thinking it's weird to want to discard the field names, which ought to be pretty uniform across records that you'd be comparing anyway
08:28:04 <asda8> EvanR-hardlabor: I'm doing that, but it's still slow as hell
08:28:18 <Cale> rather than discarding some of the fields entirely
08:28:22 <EvanR-hardlabor> asda8: just getting the data out should be fast
08:28:24 <asda8> EvanR-hardlabor: if the dbms wouldn't suck, i wouldn't need this shit
08:28:43 <EvanR-hardlabor> rawish data
08:29:03 <asda8> EvanR-hardlabor: I don't really know how I could get my data out besides select
08:29:10 <EvanR-hardlabor> smack
08:29:13 <aadrake> Cale: Some fields are not present in some documents, and all I care about is the information content of each document.  The field names aren't important or uniform in this case.
08:29:52 <EvanR-hardlabor> asda8: are you able to fold over the result set
08:30:00 <EvanR-hardlabor> that will save you time and memory
08:30:43 <asda8> EvanR-hardlabor: i'm already using an iteratee to process the data, memory usage is not an issue, it's more about speed
08:31:21 <EvanR-hardlabor> asda8: obviously you would use select, the question is how monstrous is it. is it joining stuff without an index, doing functions, procedures, etc
08:31:58 <humasect> hmm TH can't do import decl?
08:32:11 <asda8> EvanR-hardlabor: it's two simple joins, but the amount of data still makes mysql unusable without limiting the result set
08:32:36 <EvanR-hardlabor> asda8: ill assume the joins were using an index ;)
08:32:44 <asda8> EvanR-hardlabor: yes :)
08:33:01 <EvanR-hardlabor> how much data, webscale? ;0
08:33:21 <aadrake> Cale: It's after 6 here so I'm heading home, but I'll be back on in about 45 minutes.  Thank you again for your help.
08:33:47 <Cale> aadrake: I'm probably going to get some sleep
08:49:21 <ben> Is there a place dedicated to complaining about gtk2hs?
09:06:06 <mike-burns> Argh, cabal.
09:07:02 <monochrom> @quote monochrom cabal
09:07:03 <lambdabot> monochrom says: "on the 4th day of christmas my true love sent to me, 4 cabal failures, 3 cabal failures, 2 cabal failures, and a cabal failure"
09:07:04 <monochrom> :)
09:08:41 <davean> my, that really does sound like cabal
09:09:15 <mike-burns> I LOLed then but now: argh.
09:09:28 <mike-burns> http://hpaste.org/55803 - do I just unregister everything and start over?
09:10:31 <Saizan> mike-burns: cabal configure alone won't try to make your packages consistent by installing new versions
09:10:38 <Saizan> mike-burns: if that's what's confusing you.
09:11:11 <monochrom> I don't know whether starting over will help this one. there is some chance the packages you want are really in conflict, i.e., X wants W-1 and Y wants W-2 and P wants X and Y.
09:11:54 <Saizan> mike-burns: by "requires" here it means that the installed versions of those packages are built against those versions
09:12:17 <Saizan> mike-burns: since "cabal configure" doesn't see what's on hackage
09:12:26 <mike-burns> Saizan: That's what I figured, which is why I suggested that unregistering then re-installing will fix it.
09:12:40 <monochrom> worth a try though.
09:12:55 <Saizan> just "cabal install" could fix it too
09:12:58 <mike-burns> From eyeballing it, they can all use the latest version of attoparsec.
09:13:09 <monochrom> make a backup of .ghc and .cabal if you feel necessary
09:13:44 <davean> one way around this can be to ask tto install all the packages at once, alternatively you can add constraits - depending on the specific issue
09:13:58 <mike-burns> davean: Ah, I'll try all the packages at once.
09:16:18 <mike-burns> All packages at once solved it.
09:16:22 <mike-burns> I wonder what that broke.
09:17:14 <davean> mike-burns: ask! it'll tell you
09:17:42 <mike-burns> Oh yeah
09:19:53 <drdo> Hmm, why isn't Enumerator just Iteratee a m b → Iteratee a m b in the enumerator package? We could just use regular operators instead of all those specific ones
09:20:21 <davean> but yes, learning to deal with cabals agreeable, yet incessant, idioticism is one of those milestones in learning haskell :/
09:20:48 <davean> drdo: guarrenties of working?
09:21:00 <drdo> davean: what?
09:21:31 <davean> drdo: if you losen the type like that you have a lot more error cases
09:21:48 <drdo> How?
09:22:22 <davean> compair the two types
09:22:52 <drdo> I did
09:23:10 <monochrom> "cabal install" feels free to re-build existing packages. "cabal configure" doesn't.
09:24:05 <mike-burns> I can't believe this but I actually miss Ruby's Bundler.
09:24:14 <mekeor> here, by the way, you can find the probably latest interview with simon peyton-jones and john hughes: http://channel9.msdn.com/Blogs/Charles/YOW-2011-Simon-Peyton-Jones-and-John-Hughes-Its-Raining-Haskell
09:26:07 <monochrom> ruby being interpreted helps eliminate version constraints, FSVO eliminate
09:29:33 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml#hash explains why GHC packages are so brittle in dependencies
09:29:33 <MostAwesomeDude> Hey, I've got this delightful error: "ghc: mmap 61440 bytes at (nil): Operation not permitted" while cabal-installing syb. Is there any cure for this? DDG shows naught but a couple pastebins from other people with this issue.
09:32:55 <MostAwesomeDude> FWIW, I *do* have the spare RAM for that allocation. I don't know why it wouldn't succeed, or why GHC wants to do it.
09:34:09 <rostayob> MostAwesomeDude: that is a peculiar error message.
09:34:12 <rostayob> you could strace it
09:35:10 <rostayob> oh, http://stackoverflow.com/questions/8213671/mmap-operation-not-permitted
09:35:39 <MostAwesomeDude> rostayob: Ah, nice find.
09:37:00 <rostayob> still, what on earth is it trying to mmap?
09:37:10 <MostAwesomeDude> Hm. So there's no way to tell cabal that my sysadmin was paranoid and restricted mmap() locations?
09:37:29 <rostayob> patch the binary! ehehe
09:37:30 <MostAwesomeDude> Well, it's probably trying to make an anonymous mmap. It's just an arena for RAM.
09:37:44 <rostayob> oh. right
09:37:46 <rostayob> could be
09:39:05 <rostayob> MostAwesomeDude: strace it and see where it does that
09:42:11 <MostAwesomeDude> Okay, I found one other thread, but it was related to /tmp being mounted noexec, which is not the case here.
09:44:55 <monochrom> wait, what, VB has lambda too?!
09:45:17 <rostayob> monochrom: what?
09:45:20 <rostayob> really?
09:45:30 <rostayob> http://msdn.microsoft.com/en-us/magazine/cc163362.aspx really.
09:45:32 <Philippa> it wouldn't surprised me if the latest VB.net does
09:45:38 <monochrom> in the interview with SPJ and John Hughes
09:46:40 <earthy> VB.net does, and has since LINQ
09:46:52 <earthy> LINQ is basically monads for .net
09:47:09 <rostayob> really? isn't it some database query DSL?
09:47:21 <earthy> with some sugar for expression parsing
09:47:29 <earthy> really
09:48:46 <earthy> the sugar actually allows both C# and VB.Net to introspect the parse tree for a lambda if the lambda is provided as an Expression of T argument
09:50:15 <earthy> this is then used to construct e.g. a SQL query
09:51:00 <earthy> this shouldn't be terribly surprising though, as Eric Meijer is one of the main drivers behind LINQ
09:51:13 <rostayob> yeah
09:52:13 <earthy> http://research.microsoft.com/en-us/um/people/emeijer/Papers/es012-meijer.pdf
09:56:02 <MostAwesomeDude> Aha, somehow .cabal got chmod'd u-w.
09:56:07 <MostAwesomeDude> Weird.
09:57:23 * hackagebot github 0.1.2 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.1.2 (MikeBurns)
10:01:09 <sanjoyd> What does this mean: "Monads having fixed points with a 'knot-tying' semantics."?
10:05:20 <monochrom> it means http://www.haskell.org/haskellwiki/MonadFix
10:14:33 <lukish_> I have list [100,99,98,95,93,88,85,78,74,65,60,49,43,30,23,8,0] :: [Integer] and some f :: Integer -> Integer. How can I get f 100 + f 99 - f 98 - f 95 + f 93 + f 88 - f ... ?
10:14:51 <lukish_> + + - -
10:16:42 <monochrom> sum (zipWith ($) (cycle [id, id, negate, negate]) list). there are other ways
10:16:54 <tromp> > cycle [(+) (+) (-) (-)]
10:16:55 <lambdabot>   Overlapping instances for GHC.Show.Show
10:16:55 <lambdabot>                              ((a ->...
10:17:30 <lukish_> monochrom: what about f?
10:17:39 <monochrom> I forgot f. sum (zipWith ($) (cycle [f, f, negate . f, negate . f]) list)
10:17:52 <krakrjak> lukish_: this seems a lot like foldl....
10:18:48 <rostayob> or just 'sum (zipWidth ($) (cycle [id, id, negate]) (map f list))
10:18:53 <rostayob> '
10:19:13 <monochrom> I fused the map and the zipWith
10:19:29 <ryuk58> how can i put something like this <5 as an argument?
10:19:39 <rostayob> ryuk58: (< 5)
10:19:41 <rostayob> :t (< 5)
10:19:42 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
10:19:50 <rostayob> monochrom: yeah I like the separate map more
10:22:51 <ryuk58> i meant an equantion like that, as an argument, i may want >5 instead of <5
10:23:35 <rostayob> ryuk58: I don't get what you are asking, can you give an example of what you'd like to do?
10:23:43 <monochrom> you can write (> 5), too. but I don't know what you mean, and what context.
10:23:56 <bss03> ryuk58: You mean like filter (<5) [1,9,2,8,3,7,4,6,5]
10:24:13 <srhb`> ryuk58: foo x f = f x, foo 2 (<3)
10:24:21 <bss03> > filter (<5) [1,9,2,8,3,7,4,6,5]
10:24:22 <lambdabot>   [1,2,3,4]
10:24:28 <bss03> > filter (>5) [1,9,2,8,3,7,4,6,5]
10:24:28 <lambdabot>   [9,8,7,6]
10:25:01 <ryuk58> i have this filter (\(x,y) -> y f) ((x,y):rs), and the f changes has needed
10:25:23 <srhb`> ryuk58: But you apply y to f in that lambda
10:25:26 <krakrjak> or like list comprehension
10:25:26 <srhb`> ryuk58: Not f to y
10:25:29 <krakrjak> >[x|x <- [1..9], x < 5]
10:25:35 <krakrjak> > [x|x <- [1..9], x < 5]
10:25:36 <lambdabot>   [1,2,3,4]
10:25:42 <krakrjak> [x|x <- [1..9], x > 5]
10:25:47 <krakrjak> > [x|x <- [1..9], x > 5]
10:25:48 <lambdabot>   [6,7,8,9]
10:26:06 <srhb`> ryuk58: If you swap f and y then (<5) and (>5) are both valid arguments as f
10:27:18 * tessier dreams of the day when he, too, can write an xmonad tutorial
10:27:25 <tessier> er...monad tutorial
10:27:29 <tessier> xmonad is something else.
10:27:34 <rostayob> tessier: yeah we badly need it
10:27:50 <tessier> But yes, we do need an xmonad tutorial too. :)
10:27:54 <rwbarton> xmonad is like an xburrito?
10:27:59 <monochrom> there is no flying burrito monster
10:28:07 <tessier> xmonad: The window manager for astronauts eating nuclear-waste filled burritos...
10:30:01 <hpaste> lukish pasted “help with memoization” at http://hpaste.org/55807
10:30:03 <lukish_> Need some help with memoization. Evaluation of partition function have a lot of repetitions. How can I avoid them using memoization?
10:30:28 <sanjoyd> Data.Memo has a memo function, I think.
10:30:58 <sanjoyd> Sorry, Data.MemoTrie
10:34:40 <byorgey> lukish_: one easy thing you can do short of proper memoization is to make  partition :: [Integer]
10:34:51 <byorgey> lukish_: then instead of  partition n  you have  partition !! n
10:35:21 <lukish_> Well, sounds interesting
10:35:30 <byorgey> that is still not as efficient as possible -- since looking up partition n takes O(n) time to scan through the list -- but at least it will avoid recomputing
10:36:18 <lukish_> byorgey: what should I do with partition 0 = 0 and 1 = 1?
10:36:29 <lukish_> How can I define them properly?
10:36:55 <byorgey> lukish_: well, it will be something like  partition = 0 : 1 : ...
10:37:14 <byorgey> partition = 0 : 1 : map (\n -> ...) [2..]
10:38:08 <byorgey> another way to do it would be to create an immutable array (import Data.Array) defined in terms of itself
10:38:29 <byorgey> that means you have to commit up front to the number of partition numbers you want to compute, but it will be more efficient
10:40:18 <lukish_> "commit up front to the number you want to compute" <-- don't get it
10:40:22 <roconnor> wow, ekg looks insanely good
10:40:26 <roconnor> http://blog.johantibell.com/2011/12/remotely-monitor-any-haskell.html
10:41:19 <sanjoyd> lukish_: fixed size array ...
10:42:02 <rwbarton> you don't necessarily have to compute all the elements of your array, but you still have to pay some cost for storage
10:42:22 <conal> roconnor: yeah -- wow!
10:42:46 <roconnor> I hope it doesn't open remote explotes though :D
10:43:12 <sanjoyd> Remove exploits won't typecheck. :P
10:43:17 <sanjoyd> s/Remove/Remote/
10:43:19 <roconnor> :D
10:44:07 <lpsmith> well, it might well make sense to say,  listen only on a localhost and then require people to tunnel in via ssh to access the webserver
10:44:32 <lukish_> sanjoyd: weel, let me try first variant firstly
10:46:03 <snappy> win 43
10:46:37 <parcs`> ekg requires a nonexistent base version :(
10:46:56 <lpsmith> ekg requires GHC-7.4
10:49:09 <parcs`> is that an intrinsic requirement?
10:49:33 <lpsmith> yeah, according to tibbe
10:49:43 <lpsmith> I think it has something to do with the stats gathering
10:49:56 <lpsmith> (But I haven't investigated ekg closely
10:51:23 <parcs`> does  it require -prof?
10:53:40 <parcs`> doesnt look like it, otherwise ti would be noted
10:56:15 <lukish_> sanjoyd: well, I fix it http://hpaste.org/55807
10:56:28 <lukish_> But partition !! 10000 takes a lot of time
10:57:45 <lukish_> partition !! 100 works fast
10:57:50 <lukish_> And 1000
10:57:53 <byorgey> lukish_: yes, that looks better
10:58:06 <byorgey> lukish_: I'm sure partition !! 10000 is still way faster than it was with your first version!
10:58:28 <lukish_> Sure
10:58:38 <byorgey> lukish_: now you should try changing what you have to use an array instead of a list
10:58:43 <byorgey> (!!) becomes (!)
10:59:10 <lukish_> What should be an array actually?
10:59:12 <byorgey> and you can just use the 'listArray' function to produce the elements of the array from the list you have
10:59:30 <byorgey> lukish_: I don't understand your question
11:00:00 <lukish_> partition :: Array Integer ?
11:00:08 <byorgey> lukish_: see http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array.html
11:00:20 <mekeor> how can i import this module? http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html -- i tried `import Data.String.Utils' but it doesnt work, despite i've installed the "MissingH"-package with cabal.
11:00:21 <byorgey> Array takes two arguments, the type of the indices and the type of the elements
11:00:27 <byorgey> so something like  Array Int Integer
11:01:26 <byorgey> mekeor: well, for one thing, you seem to be looking at the documentation for version 1.0.0 which is rather old
11:01:47 <mekeor> byorgey: aha, okay... but that's google's fault…… :P
11:02:04 <byorgey> mekeor: yeah, don't search for Haskell documentation with Google.  use hoogle or hayoo.
11:02:27 <mekeor> yep. okay.
11:02:37 <mekeor> anyway. how to import that, byorgey?
11:02:53 <mekeor> btw, here's the better link: http://hackage.haskell.org/packages/archive/MissingH/1.1.1.0/doc/html/Data-String-Utils.html
11:02:53 <byorgey> or at least, be aware that google is likely to take you to an old version, and just click through to the latest version once you find something
11:03:02 <byorgey> mekeor: what error do you get?
11:03:23 <mekeor> byorgey: Could not find module `Data.String.Utils':
11:03:51 <byorgey> mekeor: and what is the output of 'ghc-pkg list MissingH' ?
11:03:57 <parcs`> are you using ghci?
11:04:09 <mekeor> ghc and runhaskell
11:04:29 <mekeor> byorgey: http://paste.pocoo.org/show/527025/
11:05:44 <mekeor> oh: "ghc-pkg check" says that i have lots of broken packages… oO
11:05:53 <mekeor> and missingH is among them…
11:06:26 <lukish_> byorgey: http://hpaste.org/55807
11:06:49 <lukish_> partition ! 10000 return the answer
11:06:59 <mekeor> byorgey: when typing "ghc-pkg check", it says "The following packages are broken, either because they have a problem listed above, or because they depend on a broken package." and afterwards it enumerats lots of packages……
11:06:59 <mekeor>  
11:07:09 <lukish_> Any ways to increasing velocity?
11:07:25 <byorgey> lukish_: nice!
11:07:51 <byorgey> lukish_: I don't see any obvious ways to make it faster
11:08:09 <lukish_> Thanks, anyway
11:08:24 <byorgey> any additional speedup would come either from low-level fiddling or from mathematical insights
11:08:53 <mekeor> is #ghc the better channel to discuss my issue?
11:09:20 <parcs`> no
11:09:23 <byorgey> mekeor: well, that would explain it.  You can either try reinstalling the broken packages, or just delete your package database (in ~/.ghc/) and start over
11:09:25 <mekeor> parcs`: no?
11:09:42 <byorgey> mekeor: no, this is the right channel.  I doubt #ghc would be better.
11:09:57 <mekeor> okay. :)
11:09:58 <parcs`> cabal is not ghc :P
11:10:06 <mekeor> ok. right...
11:10:22 * mekeor re-installs the "missingh"-package…
11:10:58 <mekeor> byorgey: still doesnt work. so, now, i can/should remove ~/.ghc ?
11:11:39 <byorgey> mekeor: unfortunately that is often the easiest way forward when your package db becomes seriously messed up
11:11:45 <byorgey> mekeor: no need to delete all of ~/.ghc
11:11:53 <parcs`> mekeor: what other libs are you using with missingh
11:11:58 <byorgey> just delete the subdirectory corresponding to your current version of GHC
11:12:27 <mekeor> parcs`: the source code which i am currently writing just uses prelude and data.string.utils from missingh.
11:13:11 <mekeor> byorgey: did it.
11:13:30 <mekeor> and now, just install missingh once more? okay.. doing it…
11:14:48 <mekeor> byorgey: TYVM! worx!
11:14:56 <byorgey> =D
11:14:57 <humasect> how do i have Enum a => on a record..?
11:15:10 <humasect> or type NavLinks = Enum a => [(a, String)]
11:16:02 <lukish_> byorgey: filter (\x -> x `mod` 1000000 == 0) $ elems partition , and I get some value. But how can I get an index?
11:17:08 <ion> zip [0..]
11:18:52 <bss03> humasect, you'll have to use parameteric polymorphism.
11:19:24 <byorgey> lukish_: instead of 'elems' use 'assocs' to get a list of (index, value) pairs
11:19:50 <bss03> type Enum a => NavLinks a = [(a, String)], or something like that, I think.
11:22:03 <mee> can't you do something like: data NavLinks = forall a. (Enum a) => NavLinks [(a, String)]
11:22:25 <mee> with -XExistentialQuantification
11:22:56 <byorgey> you can. But that is unlikely to be what humasect wants.
11:23:05 <byorgey> also, humasect seems to have left.
11:23:54 <mee> ah, oops. I have part messages filtered.
11:28:51 <chemistree> Question: why is it ":type" is not listed under ":?"
11:29:10 <ion> It is here.
11:29:29 <aristid> preflex: seen chrisdone
11:29:29 <preflex>  chrisdone was last seen on #haskell 2 days, 17 hours, 34 minutes and 46 seconds ago, saying: oh, that's c's way of returning a tuple
11:30:06 <byorgey> chemistree: ah, in my version of ghci there is no newline printed after the text for :script
11:30:24 <byorgey> chemistree: so the description of :type ends up on the right side of the window
11:30:38 <byorgey> that ought to be fixed
11:31:19 <chemistree> thnx byorgey
11:31:24 <chemistree> kinda odd
11:31:45 <cedric> Hi haskellers, I would like to know what is the best way to convert from Char to Word8 (with possibly loss of information), but without relying on dirty things as Unsafe.Coerce.unsafeCoerce
11:31:48 <chemistree> that was bothering me
11:32:21 <ion> fromIntegral . fromEnum
11:32:48 <MostAwesomeDude> :t fromIntegral . fromEnum :: Char -> Word8
11:32:48 <lambdabot> Char -> Word8
11:33:08 <cedric> ok, I was hoping something better, but thanks
11:33:17 <ion> Data.ByteString.Internal.c2w (with the obvious disclaimer)
11:33:26 <MostAwesomeDude> cedric: Well, maybe with a bit more context, we could know what you're doing.
11:33:54 <MostAwesomeDude> You generally would map String -> [Word8] when starting your mathy operations, and then map the other way when displaying or whatever.
11:34:00 <MostAwesomeDude> (Is there a Show instance for [Word8]?)
11:34:25 <ion> Mathy operations on strings?
11:34:32 <cedric> I was only playing at trying to program the Sand Machine of the ICFP 2006 contest
11:34:32 <eyebloom> Is there a map library that allows multiple elements with the same key, i.e. match :: key -> Structure a -> [a]
11:34:56 <ion> Yes, Data.Map :-P
11:35:03 <cedric> and so I had to read inputs as ascii characters
11:35:06 <aristid> eyebloom: you can use Data.Map with a list as the value type
11:35:31 <aristid> admittedly not the nicest API, but it gets the job done
11:35:39 <eyebloom> I see. So I would just take out the list insert an item, and put it back in the map.
11:35:48 <eyebloom> Thanks.
11:36:21 <joshuajcheek> Hi, going through http://www.haskell.org/tutorial/haskell-98-tutorial.pdf and on page 5 they say you can write `data Bool = True | False`. That gives me "parse error on input `data'" This SO article (http://stackoverflow.com/questions/3126591/why-cant-i-define-a-new-type-in-ghci) says you need to put it in it's own file and :load it in. So I put that line in a file called types.hs in CWD, ran ghci, then `:load types.hs` it interpret
11:36:21 <joshuajcheek> but when I type `Bool` it says `Not in scope: data constructor `Bool'`
11:36:21 <ion> Your thin wrapper that does the work doesn’t have a nice API?
11:36:23 <aristid> eyebloom: there is insertWith
11:36:29 <aristid> @hoogle insertWith
11:36:29 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
11:36:29 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
11:36:29 <lambdabot> Data.IntMap insertWith' :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
11:36:55 <ion> joshuajcheek: Bool is a type, you’re trying to use it as a value. They’re in completely different namespaces.
11:37:16 <MostAwesomeDude> joshuajcheek: Bool is the type, True and False are its constructors.
11:37:48 <aristid> you can type :info Bool
11:37:48 <eyebloom> Thanks.
11:37:53 <aristid> and ghci shows you info about it.
11:38:09 <aristid> but obviously as it isn't a value, you can't evaluate it
11:39:17 <joshuajcheek> ion / MostAwesomeDude: Based on your answers, it sounds like I should be able to do something like `Bool b = True` (this is what it would look like in C, anyway) but that gives me "parse error on input `='"
11:39:42 <ion> I’m afraid you can’t just invent syntax and assume it works in any given language. :-)
11:39:52 <MostAwesomeDude> joshuajcheek: Oh man, you're super-new to functional programming.
11:40:01 <MostAwesomeDude> Not a bad thing, but maybe you want a friendlier tutorial?
11:40:09 <ion> @where LYAH
11:40:09 <lambdabot> http://www.learnyouahaskell.com/
11:40:10 <joshuajcheek> MostAwesomeDude: As stated, I'm on page 5 of http://www.haskell.org/tutorial/haskell-98-tutorial.pdf
11:40:43 <joshuajcheek> I think I would benefit most from an example of how I would use my new data type that I defined.
11:41:13 <MostAwesomeDude> joshuajcheek: "Our goal is to provide a gentle introduction to Haskell for someone who has experience with at least one other language, preferably a functional language." You might be a lot more comfy with LYAH.
11:41:30 <MostAwesomeDude> Anyway, try: "let b = False"
11:41:34 <MostAwesomeDude> And then ":t b"
11:42:56 <joshuajcheek> So I do `let b = Prelude.False`, but `:t b` gives `Prelude.False`. What would I need to do to get `:t b` to return `Bool` (the type I have defined)
11:43:19 <joshuajcheek> Is there a default namespace that it is defined in?
11:43:53 <joshuajcheek> You know, I'll just go read the tutorial some more. Sorry for wasting time, figured it would be a 2 second answer.
11:43:58 <MostAwesomeDude> No worries.
11:44:20 <MostAwesomeDude> It's kinda complex to do things from ghci, especially first steps. Haskell's meant to be module-at-a-time, and that makes some interactive things tricky.
11:44:22 <Eduard_Munteanu> joshuajcheek: data types can't share constructors, if that's what you want.
11:44:30 <cedric> joshuacheek: Also look at http://tryhaskell.org that can help at the start for the syntax
11:44:43 <MostAwesomeDude> I *really* do recommend reading LYAH; it was the best for me when I learned Haskell.
11:46:10 <nuttycom> Hi, all. I'm looking for suggestions on how to approach the following problem: Here's the basic scenario: I have two Enumerators where the values have a total ordering and are returned in order. I want to pair up the equal values. In an imperative world, this would be achieved by a parallel walk.
11:46:40 <nuttycom> I'm actually implementing this in Scala, using a formulation of iteratees very similar to the one that yesod uses.
11:47:45 <joshuajcheek> MostAwesomeDude: It looks a lot like whytheluckystiff's works, which are more entertaining than educational. (e.g. http://mislav.uniqpath.com/poignant-guide/, http://cloud.github.com/downloads/shoes/shoes/nks.pdf), but I will give it two chapters to see.
11:49:15 <MostAwesomeDude> joshuajcheek: I *liked* why_'s stuff. Maybe that's a problem. There's also RWH, which is drier and more, well, real-world, and is also a fantastic read.
11:49:19 <MostAwesomeDude> @where RWH
11:49:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:55:58 <alistra> haskell totally has 'too many tutorials' syndrome
11:56:22 <monochrom> pretty sure we have reduced that to 3 or 2 recently
11:56:39 <alistra> monochrom: @ me
11:56:41 <alistra> ?
11:56:46 <monochrom> yes
11:57:16 <alistra> i mean also blogposts
11:57:25 <alistra> 'why i know monads better than you'
11:57:32 <alistra> 'what you should know about monads'
11:57:34 <Philippa> you know what haskell has worse than that?
11:57:43 <Philippa> too many people telling other people to stop writing
11:57:48 <alistra> lol
11:58:07 <mike-burns> And too many people talking about it.
11:58:16 <alistra> Philippa: there's a supply and demand for haskell tutorials
11:58:19 <Saizan> Philippa: write!
11:58:32 <monochrom> I think there are more java blog posts, etc
11:58:47 <mike-burns> There's less variety in Haskell blog posts.
11:58:53 <alistra> this ^
11:58:59 <kalven> write code, don't blog.
11:59:04 <alistra> and this ^
11:59:05 <Philippa> there's a need for quality. Quality is achieved in part through the exchange of ideas so that good ones can be collected. That doesn't happen if people stop writing
11:59:44 <alistra> Philippa: and they're not exactly new if everybody tells in his blogpost about how he thinks monads are like
12:00:13 <Eduard_Munteanu> Dunno, I'm pretty sure there's a lot of variety when it comes to some blogs about Haskell-related stuff.
12:00:25 <Saizan> code has become a mythical entity these days
12:01:21 <mike-burns> Yeah, I'm gonna go back to writing software.
12:01:22 <Philippa> Eduard_Munteanu: there's certainly a chunk that's much wider-spread than anything you can quickly find about Java or Ruby
12:01:58 <Eduard_Munteanu> Maybe if only because, besides mundane coding tutorials, you might stumble upon various stuff that's more far-reaching (CT, CS, math etc.).
12:02:04 <Philippa> alistra: you know what /really sucks/ about the monad situation? We're on the cusp of an overhaul in how people use them. So we're going to /need/ more writing
12:02:19 <MostAwesomeDude> We are? What's going to change?
12:02:21 <Eduard_Munteanu> Ah.
12:02:27 <Philippa> Eduard_Munteanu: yeah. But then, there're reasons Haskell attracts CT stuff and maths-heavy programming in general
12:02:34 <MostAwesomeDude> Are we finally gonna fix the Functor-Applicative-Monad situation?
12:02:59 <Eduard_Munteanu> I guess you're right about all those monad analogy blog posts.
12:03:01 <Philippa> MostAwesomeDude: ConstraintKinds mean that we're going to see a lot more monads that aren't Monads (but are some other class)
12:03:12 <Philippa> yeah. Not every post about monads is a monad analogy post, though
12:04:15 <alistra> Philippa: the problems is not in lack of blogposts
12:04:20 <alistra> but most of any code is crap
12:04:30 <alistra> most of java/c/php/ruby is total shit
12:04:51 <Philippa> yeah yeah, Sturgeon was an optimist and all that
12:05:39 <alistra> sturgeon?
12:05:49 <alistra> is it a kind of surgeon?
12:05:50 <Philippa> you don't know Sturgeon's Law?
12:05:50 <mekeor> hey guys, how would you prefix a string to a text-file? i mean, appending is easy because of the AppendMode, but what about prefix? how can i do that efficiently?
12:06:17 <Philippa> mekeor: Not that I'm aware of. That's more an OS-level issue, unfortunately
12:06:55 <Philippa> Sturgeon's Law is that nine tenths of everything is crap
12:06:57 <alistra> Philippa: http://en.wikipedia.org/wiki/Pareto_principle i like this one more
12:07:07 <parcs`> sturgeon's law is crap
12:07:14 <mekeor> Philippa: as i said: i wanna prefix a string to a text-file. how can i do that most efficiently?
12:07:40 <alistra> mekeor: using a C binding?
12:07:55 <mekeor> alistra: -.-
12:07:59 <Philippa> mekeor: I imagine Data.Text and "the long way"
12:08:05 <parcs`> mekeor: the most ebvious way
12:08:19 <alistra> treat a file like an array
12:08:21 <Philippa> you're not going to get a more efficient answer than concatenating and writing it back out, AFAIK
12:08:29 <alistra> and push all the elements strlen elements forward
12:08:32 <alistra> probably my memcpy
12:08:34 <mekeor> Philippa: ok.
12:08:54 <mekeor> thanks folks =)
12:09:07 <alistra> memmove*
12:09:09 <alistra> :D
12:09:14 <alistra>  The memory areas must not overlap.  Use
12:09:14 <alistra>        memmove(3) if the memory areas do overlap.
12:10:31 <Philippa> Saizan: the writing's progressing bit by bit, btw. Not having the most productive time for anything lately, so all things considered that's pretty good going
12:12:00 <joshuajcheek> I think I figured out what my confusion was, True and Bool both look like types, but True is not a type, it is a value. That was the real problem, but ghci's inability to define/load data types masked this.
12:12:44 <alistra> Philippa: have you written a blogpost recently?
12:12:53 <mike-burns> :i in ghci will give useful, different descriptions about True and Bool , joshuajcheek .
12:13:37 <Philippa> the last haskell-related one to go up was a couple of months ago. I've got one that IIRC is mostly ready, but it's the first half of a two-parter and I'm finishing up the second half in case I run into something that causes a pile of changes
12:14:09 <Saizan> Philippa: good thing that posts are finite, so one eventually gets there if there's progress
12:14:43 <Philippa> Saizan: indeed. Helps if you manage to preserve the logic and intent as well, of course
12:15:28 <eyebloom> I'd like to store edges::(key,key) in a map and efficiently search for tuples by either beginning or ending key. Aside from storing a forward and backward version of the edge, is there an efficient way to do this?
12:15:29 <alistra> @help
12:15:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:15:33 <alistra> @list
12:15:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:16:36 <Philippa> eyebloom: do you definitely want a map? IIRC there are graph packages around
12:17:09 <eyebloom> Currently working with fgl. Decided I want to write my own GraphRep.
12:17:30 <Philippa> it might be worth checking if there's an invertible map on hackage, too. Don't know a good way to do it with Data.Map
12:18:35 <eyebloom> I can just store two versions of the edge and keep track of direction.
12:19:12 <Philippa> point. That's probably better than two maps, yes
12:19:28 <eyebloom> But that makes each operation X 2 at least.
12:19:30 <hpaste> BMeph pasted “Is this a recap from yesterday?” at http://hpaste.org/55816
12:19:34 <eyebloom> Plus storage.
12:19:38 <alistra> Philippa: you're like a person that encourages ugly girls on /r/gonewild @ haskell blog posts
12:20:11 <BMeph> Anyone in the conversation about existentials yesterday, care to take a swing at this?
12:20:17 <Philippa> alistra: sexism not appreciated in here, thanks
12:20:39 <alistra> ugly girls and guys*
12:20:45 <alistra> there ftfy
12:21:43 <Eduard_Munteanu> BMeph: you can't use the 2nd variant
12:23:42 <ddarius> BMeph: That's nothing to do with existentials.  It's that GHC's type system is not impredicative.
12:23:52 <dolio> GHC's type inference algorithm isn't robust with respect to eta expansion.
12:24:28 <Saizan> GHC's type system is impredicative when it likes to
12:24:32 <dolio> Actually, \x -> (runST . whatever) x probably wouldn't work, either.
12:24:36 <ddarius> dolio: It's not just eta expansion that is happening there.  Also, eta expansion can change the type anyway.
12:25:02 <ddarius> Saizan: They added a hacky implementation of an impredicativity extension.  I'm not sure what the current status of it is.
12:25:23 <dolio> I think runST $ ... was working again recently.
12:25:28 <Eduard_Munteanu> ImpredicativeTypes? That doesn't cut it IIRC.
12:25:35 <ddarius> dolio: For that, they added a horrible, horrible hack.
12:25:36 <Eduard_Munteanu> Yeah.
12:25:55 <dolio> ddarius: Yeah. When I investigated it, I seem to recall finding that it was specific to $, as an identifier.
12:26:02 <ddarius> Yes.
12:26:04 <dolio> Maybe I'm wrong about that, though.
12:26:11 <dolio> That is pretty bad.
12:26:31 <BMeph> Nope, everything you guys said flew.
12:27:12 <monad> Has anyone read chapter 22 of real world haskell? I have a compilation problem concerning the linking process
12:27:30 <Saizan> BMeph: higher-rank types and combinators like (.) make type inference go mad
12:27:42 <monad> the following message is reported: /usr/bin/ld: cannot find -lHSparsec-2.1.0.1
12:28:26 <ddarius> The problem is simply that you can't instantiate a polymorphic type to a polymorphic type.
12:29:02 <monad> Hmmm, problem solved: Without the package directives it works properly :-)
12:29:34 <Saizan> ?type id :: (forall a. a) -> (forall a. a)
12:29:35 <lambdabot> forall a. (forall a1. a1) -> a
12:29:41 <Saizan> it seems you can
12:30:10 <Eduard_Munteanu> ?type const :: (forall a. a) -> (forall a. a)
12:30:11 <lambdabot>     Couldn't match expected type `a'
12:30:11 <lambdabot>            against inferred type `b -> forall a1. a1'
12:30:11 <lambdabot>       `a' is a rigid type variable bound by
12:30:18 <Eduard_Munteanu> Just checking.
12:30:20 <dolio> How old is the version of ghc lambdabot is running?
12:30:32 <Saizan> @version
12:30:33 <lambdabot> lambdabot 4.2.2.1
12:30:33 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:30:43 <Saizan> it used to say
12:30:44 <parcs`> > runST (id (return ()))
12:30:45 <lambdabot>   ()
12:30:48 <Eduard_Munteanu> Wait, did that ever work?
12:31:06 <parcs`> > runST (id $ return ())
12:31:07 <lambdabot>   ()
12:31:11 <dolio> Because that annotation on id doesn't work in 7.2 for me.
12:31:48 <dolio> Hasn't worked since the rewrite in 7.
12:32:58 <Saizan> yeah, though the error is weird
12:33:02 <parcs`> > id runST (return ())
12:33:03 <lambdabot>   Couldn't match expected type `m ()'
12:33:03 <lambdabot>         against inferred type `forall s...
12:33:47 <Saizan> dolio: it doesn't seem to complain about impredicativity, since the argument types match
12:34:41 <parcs`> > (id :: (t ~ forall s. ST s a) => t -> t) runST (return ())
12:34:41 <Omer> JOIN
12:34:42 <lambdabot>   <no location info>: parse error on input `forall'
12:34:59 <dolio> It isn't something that's going to generate a complaint about impredicativity. But it's something that will fail because the inference/checker doesn't _do_ impredicative instantiation in the right way.
12:35:17 <parcs`> > (id :: (forall s. ST s a) -> (forall s. ST s a)) runST (return ())
12:35:18 <lambdabot>   Couldn't match expected type `t1 -> t'
12:35:18 <lambdabot>         against inferred type `GHC.S...
12:35:32 <Saizan> right
12:35:41 <Saizan> which was my point
12:35:48 <dolio> Compared to something like HMF.
12:35:54 <dolio> Or the old GHC type checker.
12:35:57 <benokit> from the premise: haskell is slow comparing to XY : is it that in haskell you can not reason about performance as in XY or something else e.g. bad compiler ?
12:36:22 <dolio> Which did impredicative instantiation as long as only foralls and arrows were involved.
12:36:29 <parcs`> benokit: both, mostly the first though
12:36:52 <Saizan> in 7 they seem to have introduced a subtle distinction between types with a quantifier and type schemas
12:39:31 <ddarius> You compare programs (paired with implementations) for speed, not languages.
12:40:15 <Saizan> hah, const () :: (forall a,
12:40:28 <Saizan> hah, const () :: (forall a. a) -> () works in 7.2
12:43:41 <MostAwesomeDude> Hey, what does ~ do? I encountered it, but it's kinda hard to google for.
12:45:03 <ehamberg> google “haskell tilde” ;)
12:45:27 <Saizan> MostAwesomeDude: it's type equality
12:45:46 <Andrew__C> Use hoogle instead of google for Haskell http://www.haskell.org/hoogle/?hoogle=~
12:46:13 <Philonous> MostAwesomeDude:  Or lazy pattern matching
12:46:48 <ddarius> Both the Report and the Gentle Introduction comprehensively go over all standard Haskell syntax elements.
12:47:15 <MostAwesomeDude> Hm. The wiki says "F a ~ b => a -> b" requires F a and b to be the same type.
12:47:20 <MostAwesomeDude> Interesting. Thanks.
12:48:48 <nuttycom> Nobody has any idea how to zip enumerators? :(
12:52:54 <parcs`> nuttycom: (enum1 $$ consume) `EL.zip` (enum2 $$ consume)?
12:54:56 <ben> How do I get profiling libraries with cabal-install?
12:55:14 <luite> the best way is to enable profiling in your cabal config
12:55:32 <luite> since you need to reinstall all deps with profiling if you want to build something with profiling
12:55:52 <nuttycom> parcs`: Thanks. :) Hopefully that will be enough to get me a start… my case is somewhat more involved than a simple zip, but this may be the missing piece.
12:56:03 <ben> luite: cheers
12:56:16 <luite> ben: in ~/.cabal/config, set the line library-profiling: True
12:56:24 <ben> Yeah, found it
12:56:39 <luite> then nuke your package database (remove ~/.ghc for example) and reinstall everything you need
12:57:46 <monochrom> "this installs everything. again"
12:58:25 <luite> cabal install world might work
12:59:08 <monochrom> that will install everything you have once tried out but forgotten
12:59:18 <parcs`> nuttycom: actually that won't work. try liftM2 zip (enum1 $$ consume) (enum2 $$ consume).that should give you an iteratee of result type [(a, b)]. is that the type you are looking for?
13:00:44 <luite> monochrom: I'm already quite used to installing everhting again, especially with yesod projects and cabal-dev. at least my laptop gets some exercise :)
13:00:55 <parcs`> nuttycom: or are you looking for an Enumerator a ... -> Enumerator b ... -> Enumerator (a, b) ... ?
13:01:07 <nuttycom> parcs`: will that work incrementally? from the docs on consume it says "Consume all input until http://hackage.haskell.org/packages/archive/enumerator/0.4.4/doc/html/Data-Enumerator.html#v:EOF, then return consumed input as a list."
13:02:10 <nuttycom> parcs`: Yes; Enumerator a -> Enumerator b -> Enumerator (a, b) is what I'm trying to build.
13:02:25 * hackagebot HaskellNet 0.3 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.3 (JonathanDaugherty)
13:03:48 <nuttycom> or, actually, Ord a => Enumerator a -> Enumerator a -> Enumerator (a, a)
13:04:21 <nuttycom> where the first and second enumerators traverse in order, and the resulting tuples are those where elements are equal
13:04:34 <nuttycom> In an imperative impl it'd be a parallel walk
13:04:49 <nuttycom> That's what I'm trying to build, anyway.
13:07:16 <Saizan> you've to do a sort of weaving, where the iteratee you feed to one enumerator calls the other etc.
13:09:51 <nuttycom> Saizan: Yeah, that's kind of my impression. Getting the types right is a challenge though :/ Guess there's nothing to do but grind through it.
13:10:24 <Saizan> nuttycom: http://okmij.org/ftp/Streams.html#2enum1iter
13:11:14 <ben> okay cabal is fucking around
13:11:17 <Saizan> the Merge.hs seems pretty relevant
13:11:21 <ben> didn't want to profile those libraries anyway
13:12:04 <hpaste> Andrew__C pasted “Why doesn't it deduce Char instead of item0 for the fourth type class parameter?” at http://hpaste.org/55817
13:12:20 <ben>     Cabal-1.10.2.0-9afc7e537c5b9d4a8d869ed5e36482b2 is shadowed by package Cabal-1.10.2.0-143cfad0f74ad2a2da58663c6199e0aa
13:12:24 <ben>     Cabal-1.10.2.0-143cfad0f74ad2a2da58663c6199e0aa is unusable due to missing or recursive dependencies:
13:12:27 <ben>       directory-1.1.0.0-ad335e2e43cb2572c60f331cc18d4c5c process-1.0.1.5-3da7ca8c88f60759fdb35983ab12fae0
13:12:31 <ben> what is this
13:13:08 <nuttycom> Saizan: Yup, I started working from Merge.hs, but there it's doing interleaving rather than tupling.
13:13:26 <nuttycom> And so the type of the resulting enumerator is the same as the type of the two inputs, which makes it simpler.
13:14:22 <Saizan> Andrew__C: nothing says that's the only possible instance, you want functional dependencies for that
13:14:27 <Saizan> Andrew__C: or type families
13:14:55 <Andrew__C> Saizan: which is easier?
13:15:04 <Andrew__C> (thx)
13:15:39 <Zamarok> I have a list of functions and a list of things that I need to apply the function to.. is there a library function that does this already?
13:16:09 <Zamarok> Pseudocode: for f in functions, i in numbers: apply f to i
13:16:10 <ben> zipWith ($)?
13:16:10 <Saizan> Andrew__C: maybe type families, unless you're familiar with fundeps from relational database theory
13:16:30 <Zamarok> Oh, let me try that
13:16:51 <Saizan> Andrew__C: also, libs like data-lens might be a less typeclass hacky solution to your problem
13:17:09 <ion> > zipWith ($) [pred, id, succ] [100, 200, 300]
13:17:10 <lambdabot>   [99,200,301]
13:17:15 <ion> > [pred, id, succ] <*> [100, 200, 300]
13:17:16 <lambdabot>   [99,199,299,100,200,300,101,201,301]
13:17:16 <Andrew__C> Saizan: I'm happy with the concept of functional dependency. I'll have a lookl: thanks.
13:17:44 <Andrew__C> Saizan: thanks for the data-lens hint too.
13:17:58 * Andrew__C heads off to do some learnin'
13:18:30 <ion> Ah, i missed the pseudocode. <*> matches that behavior.
13:19:00 <ion> @type (<*>)
13:19:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:19:21 <ion> @type (<*>) `asAppliedTo` (undefined :: [a -> b])
13:19:22 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
13:20:10 <Zamarok> Wait, which library is '<*>
13:20:17 <Zamarok> which library is it in?*
13:20:33 <ion> Ah #2, i misread the pseudocode as “for f in functions: for i in numbers: apply f to i”. I’m not sure whether you want <*> or zipWith ($) after all. :-)
13:20:33 <Sgeo> Control.Applicative
13:20:51 <ion> @hoogle (<*>)
13:20:51 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:20:56 <Zamarok> Oh I see
13:21:08 <Zamarok> Yes either will do, I think.. thanks :)
13:21:21 <Sgeo> They do different things though
13:21:32 <Sgeo> :t asAppliedTo
13:21:33 <lambdabot> forall t b. (t -> b) -> t -> t -> b
13:22:35 <Sgeo> > [(+1),(+2),(+3)] <*> [4,5,6]
13:22:36 <lambdabot>   [5,6,7,6,7,8,7,8,9]
13:22:40 <ben> Why's the process package on hackage broken? "* Missing (or bad) header file: runProcess.h"
13:22:50 <Sgeo> > zipWith ($) [(+1),(+2),(+3)] [4,5,6]
13:22:50 <bss03> > zipWith ($) [(+1), (subtract 1)] [3,-3]
13:22:51 <lambdabot>   [5,7,9]
13:22:51 <lambdabot>   [4,-4]
13:23:03 <bss03> > [(+1), (subtract 1)] <*> [3,-3]
13:23:04 <lambdabot>   [4,-2,2,-4]
13:23:10 <tsousa> hey i read maybe 12 chapters from LYAH and i want to start doing some coding
13:23:16 <mike-burns> Great!
13:23:19 <tsousa> is there any exercices?
13:23:45 <Zamarok> it works perfectly.. zipWith ($) myfunctions myelements
13:23:59 <krakrjak> tsousa: do what I did...  Look for something you know how to write in another language and start from scratch.
13:24:14 <mike-burns> tsousa: Write some packages for Hackage. Something that talks with a Web API or an existing C library would be nice.
13:24:17 <mike-burns> Thanks!
13:24:41 * Sgeo has plans to write something that talks with an existing C library
13:24:42 <dmwit> I think I concur with krakrjak and mike-burns; skip the exercises and go straight to writing something real.
13:24:46 <tsousa> mike-burns, that is a bit over my head
13:24:48 <tsousa> lol
13:24:56 <mike-burns> It's just function calls.
13:24:58 <Sgeo> But the library is much more ... testable on Windows, and I'm stuck on Linux at the moment
13:25:07 <krakrjak> tsousa: My first full haskell program is here https://gitorious.org/linux-parallel-port-io maybe it will spark an idea?
13:25:41 <ion> tsousa: I’d suggest writing a pure Haskell microkernel that runs on MOS 6501.
13:25:47 <ion> 6502, that is.
13:25:47 <dmwit> Write a Tetris clone in SDL or Gtk.
13:25:51 <EvanR-hardlabor> parallel port combinators monad reactive arrow
13:26:12 <mike-burns> I think EvanR-hardlabor wins.
13:26:13 <dmwit> Cook up a filter for dmesg that only shows you the messages you know aren't boring.
13:26:24 <tsousa> ion, yeh that is more easy
13:26:48 <dmwit> Implement a heuristic for the traveling salesman problem.
13:26:49 <dmwit> etc.
13:27:13 <cedric> make a function which will tell if the code of another one will halt
13:27:30 <dmwit> =P
13:27:38 <EvanR-hardlabor> isFinite :: [a] -> Bool
13:27:43 <ion> runOtherCode >> putStrLn "It halted."
13:27:46 <dmwit> ?faq Can Haskell make a function which will tell if the code of another one will halt?
13:27:46 <lambdabot> The answer is: Yes! Haskell can do that.
13:28:37 <cedric> lambdabot is really a strong guy!
13:28:44 <EvanR-hardlabor> i think scientists are CERN have reported a function that can just barely tell if other functsion will terminate
13:28:51 <ion> @vixen Are you a guy?
13:28:51 <EvanR-hardlabor> they are looking into possible equipment errors
13:28:51 <lambdabot> In a flat choice between smoke and jobs, we're for jobs...But just keep me out of trouble on environmental issues.
13:28:52 <krakrjak> tsousa: if you just want to get your hands dirty try your hand at querying a toy database...
13:29:52 <mike-burns> tsousa: I still vote that you write a library that goes on Hackage. It doesn't have to talk Web or C API if you don't want to. It can be very small, trivial, and useful.
13:29:55 <tsousa> krakrjak, i am kinda of a newbie.i know some programming language but i never did any real world app. some agenas and and app to manage some phones numbers and stuff like that
13:30:13 <Sgeo> I can use Template Haskell to write FFI calls, right?
13:30:28 <Sgeo> erm, to write FFI declarations
13:30:41 <krakrjak> tsousa: don't let that discourage you.  Actually that's not a bad idea there.  I know you've done it before, but a little contact manager application would be a good starting point.
13:31:48 <krakrjak> tsousa: just reading/writing to any data store (file?) and searching will show you some of the Haskell power pretty quickly.  One word of advice... learn to grok moon language.
13:32:04 <ion> tsousa: Yeah, a contact manager sounds just fine.
13:32:09 <EvanR-hardlabor> moon language?
13:32:19 <dmwit> moon language.
13:32:28 <krakrjak> the output ghc gives me the first time I type make after a change :)
13:32:42 <EvanR-hardlabor> not as bad as g++
13:32:45 <mike-burns> Oh, like that 207-line long error message I just had?
13:32:45 <tsousa> krakrjak, ion with GUI or without?
13:32:47 <dmwit> But GHC's error messages are excellent!
13:33:01 <krakrjak> I think I heard PJ call it that once.  I like it.
13:33:09 <krakrjak> tsousa: start with the terminal
13:33:11 <ion> tsousa: Try without GUI first.
13:33:13 <zachk> whats moon language?
13:33:16 <tsousa> ok
13:33:29 <tsousa> and some geometry module to hackage? it would be usefull?
13:33:31 <dmwit> zachk: GHC-error-speak, apparently
13:33:47 <krakrjak> tsousa: if it gets useful then see about using a GUI toolkit to promote it to a full fledged GUI app if you want.
13:33:48 <zachk> ahhh, thank you
13:33:52 <dmwit> Probably! What would a geometry module do?
13:34:01 <tsousa> ok
13:34:03 <ion> tsousa: Perhaps start without a UI of any kind, just functions that do contact list management when called from ghci.
13:35:10 <ben> is process designed not to build from cabal install?
13:36:13 <krakrjak> tsousa: I agree with ion.  Save the putStrLns and other I/O stuff for later.  Let ghci do the heavy lifting and keep the functions as pure as possible.
13:36:22 <danlei> I've been reading about existential types, and I'm having problems to grasp why e.g. in [∀ a. a] the ∀ means intersection. given "usual" lists, how would ∀ a. [a] be an intersection?
13:36:57 <tsousa> krakrjak, ok thanks. and wwhat do you think about a new geometry module to hackage?
13:37:59 <krakrjak> tsousa: like dmwit said what kind of geometry module?
13:38:38 <tsousa> krakrjak, like check if the vector are paralel and stuff like that if that 3 vector forms a plane
13:38:42 <tsousa> stuff like that
13:39:24 <krakrjak> tsousa: sounds handy to me.
13:40:11 <tsousa> yeh
13:41:29 <dmwit> ?hackage vector-space -- tsousa
13:41:29 <lambdabot> http://hackage.haskell.org/package/vector-space -- tsousa
13:48:02 <Philippa> danlei: forall x.[x] is "give me an x, I give you a [x]", right? So it's the "intersection" of all possible x
13:50:06 <danlei> Philippa: I'm not sure. I guess this is really trivial, but I just don't get it. I read ∀ a. [a] as: for every possible type a, I am a list of as. so where would intersection of all possible types come into play here?
13:50:35 <Philippa> "I am [Int] and [Bool] and [Char] and..."
13:50:38 <Zamarok> Is there a more concise way of performing this code? I feel like there's probably a library function for it:
13:50:39 <Zamarok> f n = otherF n : f (n+1)
13:50:53 <Philippa> that "and" is the intersection
13:51:10 <danlei> hm ...
13:51:12 <Silvah> :t iterate
13:51:13 <lambdabot> forall a. (a -> a) -> a -> [a]
13:51:47 <Silvah> Nah, that's wrong.
13:52:19 <Zamarok> Silvah: yea I want to increase n by one per iteration
13:52:30 <Saizan> f n = map otherF [n ..]
13:52:32 <Philippa> map otherF [1..]
13:52:40 <Silvah> > iterate (+2)
13:52:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
13:52:41 <lambdabot>    arising from a use of...
13:52:41 <Philippa> or [n..], yeah
13:52:49 <Silvah> > iterate (+2) 0
13:52:50 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
13:53:13 <Silvah> > map (+2) [0..]
13:53:14 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
13:54:48 <Zamarok> oh yea, map does that just fine >_> can't believe I missed that one
13:54:56 <danlei> Philippa: So it's like: in ∀ a. [a] we say: I'm a list of Ints, Bools, Chars, ..., but only one of them, and in [∀ a. a] like: I'm a list of Ints, Bools, Chars, ..., and each of my elements is all of these types at once?
13:55:52 <Sgeo> Does it make sense for me to write my own Foreign.Storable instance?
13:56:00 <Silvah> In fact, map *and* enumFromTo.
13:56:20 <Philippa> I'm a list of (I'm an Int^Bool^Char^takeyourpick)
13:56:39 <Philippa> the list is completely monomorphic
13:56:42 <Philippa> it's the contents that're polymorphic
13:59:34 <Philippa> danlei: it might help to consider what forall a.a is
13:59:51 <danlei> Ok, I got that so far. But I'll have to think about the "I am a list of X and Y, and ..." as an intersection, because intuitively, it sounds like a union
13:59:54 <Philippa> then you know what a list of them looks like
14:00:43 <Philippa> every forall is implicitly a "function" (that can be formalised if you really want) that takes a type and gives you whatever's on the inside of the forall. The explicit equivalent has type lambdas and type applications, even
14:00:50 <danlei> I.e. you could read it as: I am a list of X or Y or Z ...
14:01:15 <Saizan> with the or it'd be quite differnt
14:01:25 <danlei> hm
14:02:09 <dixie> What is more efficient data structure for holding large list of records instead of [SomeRecord] ?
14:02:14 <Saizan> with the "and" it's the user of the list which can choose which type to use, with the or the user wouldn't be able to
14:02:29 * hackagebot trajectory 0.1.0.0 - Tools and a library for working with Trajectory.  http://hackage.haskell.org/package/trajectory-0.1.0.0 (MikeBurns)
14:02:34 <danlei> forall a. a would mean: I am of /any/ type, I guess
14:02:41 <danlei> so that's _|_
14:03:00 <Philippa> all types rather than any (that's an existential), but yes. Any type you give me, I can become
14:03:08 <ivanm> mike-burns: what's trajectory?
14:03:23 <Silvah> dixie: define efficiency
14:03:24 <ivanm> oh, wait, you actually say so in the description
14:03:26 <danlei> Philippa: ah, yes, that's what I meant (non native speaker)
14:04:00 <Philippa> *nod* - I can imagine that's not helping if you can't get materials in your native language, yeah
14:04:25 <Sgeo> If you always want to access SomeRecords in order, and don't often append (but prepend), [SomeRecord] should be efficient
14:04:54 <mike-burns> ivanm: It's a project management tool that I use (and helped write).
14:05:00 <mike-burns> Oh yeah, I have docs.
14:05:12 <danlei> OK, so in forall a. a, It's value is an element of every haskell type, thus an intersection. I think that's clear now.
14:05:56 <danlei> (a value of that type, that is)
14:06:30 <dixie> Silvah: I want to have list like access (iterate over) but with as small as possible memory costs. Something like C array vs. Double Linked List - array is more efficient from this POV
14:06:54 <ben> > do let x = 42; print x
14:06:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:06:59 <ben> > do { let x = 42; print x }
14:07:00 <lambdabot>   <no location info>: parse error on input `}'
14:07:32 <Silvah> dixie: an array, then?
14:07:47 <ben> What's the deal
14:08:13 <Silvah> Data.Array?
14:08:19 <rwbarton> > do { let { x = 42 }; print x }
14:08:20 <lambdabot>   <IO ()>
14:08:41 <dixie> Silvah: Does Data.Array take less memory than [] for the same count of the items ?
14:08:45 <ben> thanks
14:08:46 <rwbarton> "do { let x = 42; print x }" looks like you are defining a function print x and then suddenly }
14:08:54 <cedric> > do { let x = 42 in print x }
14:08:55 <lambdabot>   <IO ()>
14:09:33 <Silvah> dixie: not sure, but it should. If you're in doubt, check it.
14:09:45 <dixie> ok, thanks
14:09:53 <Sgeo> > putStrLn "<IO ()>"
14:09:54 <lambdabot>   <IO ()>
14:10:13 <cedric> > import Prelude hiding cycle
14:10:14 <lambdabot>   <no location info>: parse error on input `import'
14:10:21 <alistra> @hoogle IO a
14:10:26 <lambdabot> Did you mean: :: IO a
14:10:26 <lambdabot> Data.Graph.Inductive.Monad.IOArray module Data.Graph.Inductive.Monad.IOArray
14:10:26 <lambdabot> Data.Array.IO data IOArray i e :: * -> * -> *
14:10:36 <Sgeo> @hoogle :: IO a
14:10:36 <lambdabot> System.Exit exitFailure :: IO a
14:10:37 <lambdabot> System.Exit exitSuccess :: IO a
14:10:37 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
14:11:12 <Silvah> :t undefined :: IO a
14:11:13 <lambdabot> forall a. IO a
14:11:34 <cedric> I would like to have "cycle" from "Prelude" not loaded, but "import Prelude hiding cycle" does not work what is the correct syntax?
14:11:58 <MostAwesomeDude> I thought you needed something like "import Prelude hiding (cycle)"
14:12:18 <alistra> > undefined :: IO Int
14:12:19 <lambdabot>   <IO Int>
14:12:24 <alistra> winning
14:12:30 <Silvah> Parentheses around "cycle"?
14:12:40 <cedric> thanks, it works
14:13:04 <alistra> > undefined :: a -> IO (IO (IO a))) $ undefined :: IO (IO Int)
14:13:05 <lambdabot>   <no location info>: parse error on input `)'
14:13:14 <alistra> > undefined :: a -> IO (IO (IO a)) $ undefined :: IO (IO Int)
14:13:15 <lambdabot>   <no location info>: parse error on input `::'
14:13:16 <cedric> I was reading the "Gentle introduction for Haskell" but there was no parenthesis
14:13:22 <Silvah> :t unsafeCoerce
14:13:23 <lambdabot> Not in scope: `unsafeCoerce'
14:13:25 <alistra> > undefined :: (a -> IO (IO (IO a))) $ undefined :: IO (IO Int)
14:13:26 <lambdabot>   <no location info>: parse error on input `::'
14:14:28 <Silvah> @let unsafeCoerce x = unsafeCoerce [x]
14:14:33 <lambdabot>  <local>:6:17:
14:14:33 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]...
14:15:02 <Sgeo> > (undefined::(a->IO (IO (IO a)))) $ (undefined:: (IO (IO Int))
14:15:03 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:15:07 <Silvah> @let unsafeCoerce x = unsafeCoerce x
14:15:08 <lambdabot>  Defined.
14:15:10 <Sgeo> > (undefined::(a->IO (IO (IO a)))) $ (undefined:: (IO (IO Int)))
14:15:11 <lambdabot>   <IO (IO (IO (IO (IO Int))))>
14:15:19 <Silvah> :t unsafeCoerce
14:15:20 <lambdabot> forall t1 t. t1 -> t
14:16:30 <ben> Is forM_ [0..w] $ \x -> forM [0..h] $ \y -> the equivalent to two nested for-loops I'd want for my fancy urgent inner loop?
14:16:38 <Silvah> > unsafeCoerce 5 :: Maybe (IO (Maybe (Either (IO Int) (Maybe (IO Char))))))
14:16:39 <lambdabot>   <no location info>: parse error on input `)'
14:16:56 <Silvah> > unsafeCoerce 5 :: Maybe (IO (Maybe (Either (IO Int) (Maybe (IO Char)))))
14:17:00 <lambdabot>   mueval-core: Time limit exceeded
14:18:23 <dixie> > length [ undefined, error "hello" ]
14:18:24 <lambdabot>   2
14:18:57 <hpc> > length cake
14:18:59 <lambdabot>   42
14:19:03 <hpc> :D :D :D
14:19:11 <Silvah> :D
14:19:15 <dixie> > seq [ undefined, error "fooo"] [ undefined, error "hello" ]
14:19:16 <lambdabot>   [*Exception: Prelude.undefined
14:19:25 <Silvah> @src cake
14:19:25 <lambdabot> Source not found. Maybe you made a typo?
14:19:32 <Silvah> :t cake
14:19:33 <lambdabot> [[Char]]
14:19:36 <dixie> > cake * 2
14:19:37 <lambdabot>   No instance for (GHC.Num.Num [[GHC.Types.Char]])
14:19:37 <lambdabot>    arising from the litera...
14:19:41 <Silvah> > cake
14:19:43 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:19:56 <Silvah> Oh :D
14:19:57 <hpc> http://hpaste.org/55819
14:20:01 <dixie> :)
14:20:09 <rwbarton> that's not a cake, it's a recipe for cake!
14:20:23 <rwbarton> > unsafePerformRecipe cake
14:20:24 <lambdabot>   Not in scope: `unsafePerformRecipe'
14:20:33 <rwbarton> how do I get the cake out?
14:21:28 <Silvah> @let unsafePerformRecipe = unsafeCoerce
14:21:29 <lambdabot>  Defined.
14:21:32 <donri> use liftM and you can eat the cake and keep the cake
14:21:32 <ksion> > data Cake = Lie
14:21:33 <lambdabot>   <no location info>: parse error on input `data'
14:21:49 <Silvah> > unsafePerformRecipe cake
14:21:53 <lambdabot>   mueval-core: Time limit exceeded
14:22:10 <Silvah> No wonder that time limit exceeded.
14:22:13 <MostAwesomeDude> It is, apparently, *not* a piece of cake to bake a pretty cake.
14:22:53 <Silvah> was exceeded*
14:25:57 <Silvah> @let unsafePerformRecipe = error "invalid recipe"
14:25:58 <lambdabot>  <local>:8:0:
14:25:58 <lambdabot>      Multiple declarations of `L.unsafePerformRecipe'
14:25:58 <lambdabot>      Decl...
14:26:19 <Silvah> @unlet unsafePerformRecipe
14:26:20 <lambdabot>   TemplateHaskell is not enabled
14:26:31 <Silvah> Anyone?
14:28:27 <Zamarok> Is there a method to parallel zipWith?
14:32:13 <danlei> Philippa: So, to recapitulate, forall a. [a] says "I am a list of X and Y and ..." (intersection), and [forall a. a] says "I am a list of (I am X and Y ... (intersection))". and that "I am X and Y ..." can only be bottom. Now, that "I am a list of X and Y and ..." becomes "I am a list of X" at some time, i.e. it isn't an intersection anymore and can hold all values of that type X. It's just that in the second case the X itself is an
14:32:13 <danlei> intersection, and never stops being one, so the only possible value is _|_. Is this correct so far? (Sorry if those are stupid questions)
14:36:50 <Ke> how do I get strlen for CString?
14:37:10 <Ke> CString -> IO Int finds nothing on hoogle
14:38:10 <ben> you could foreign import strlen :))
14:38:44 <Ke> withCStringLen is the best thing apparently
14:38:46 <ddarius> danlei: That seems like a convoluted way of thinking about it.
14:38:51 <danlei> :)
14:39:19 <danlei> yes, sometimes I take detours :)
14:39:38 <ddarius> Classically, forall a. can be viewed as an infinite intersection.
14:39:57 <danlei> ok, just one last question then
14:40:59 <Ke> does withCString work with UTF-8?
14:41:07 <danlei> [a] can become a conrete type, for example [Int]. why wouldn't that work for a in this case? intuitively I'd say because it isn't a "X of Y", but that's rather vague
14:42:15 <ddarius> The way I typically recommend thinking about these things is to take a game theoretic perspective.  "forall a. [a]" says, "if you pick an a I'll give you a list of a's", whereas "[forall a. a]" says "I'll give you a list of games where if you pick an a I'll give you an a"
14:42:40 <danlei> ok
14:42:42 <JoeyA> @hoogle lengthArray0
14:42:42 <lambdabot> Foreign.Marshal.Array lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
14:42:47 <danlei> I understand that
14:43:32 <JoeyA> (I'm guessing lengthArray0 is much slower than strlen, as it does not appear to be SPECIALIZEd)
14:43:50 <danlei> Now, because those forall a. a would have to be of every type, there are no such values
14:43:54 <dmwit> Ke: No.
14:43:54 <danlei> except _|
14:44:15 <dmwit> Ke: CString's are C strings -- essentially an array of bytes, despite the name.
14:44:15 <danlei> at least I think I understand that :)
14:45:08 <dmwit> ?free value :: a
14:45:08 <lambdabot> f value = value
14:45:35 <Ke> dmwit: I mean if I have non ascii chars in String and I use withCString, what happens
14:46:07 <ddarius> From the intersection perspective, there are types that are disjoint therefore the intersection of all types must be empty (excluding bottom, otherwise bottom is the only element in all types, and thus is the intersection.)
14:46:28 <ddarius> From the game theoretic perspective, forall a. a corresponds to an unwinnable game because I can ask for something impossible.
14:46:38 <JoeyA> Ke: Assuming it's in UTF-8 (or another ASCII-compatible encoding), it'll be fine.
14:46:45 <rwbarton> Ke: "The marshalling converts each Haskell character, representing a Unicode code point, to one or more bytes in a manner that, by default, is determined by the current locale."
14:46:48 <JoeyA> err, nvm
14:46:58 <JoeyA> right, and that just does byte-by-byte conversion.
14:47:06 <JoeyA> @hackage utf8-string
14:47:06 <lambdabot> http://hackage.haskell.org/package/utf8-string
14:47:10 <ddarius> Or I should say a losable game.
14:47:16 <dmwit> Ke: withCString seems to use foreignEncoding, which uses a locale-specific encoding and ignores encoding failures.
14:47:30 <rwbarton> I would assume it uses UTF-8 if your locale is UTF-8.
14:47:50 <dmwit> rwbarton: yes
14:47:58 <JoeyA> rwbarton: Although it should, I'm not sure it's actually implemented that way yet...
14:48:11 <danlei> ddarius: interesting
14:48:14 <rwbarton> It does seem to carefully stop short of saying that. :P
14:48:15 <dmwit> JoeyA: It seems to be implemented that way to me.
14:48:19 <MostAwesomeDude> Hm. Annoying. There's no instance of Random a for Enum a.
14:48:49 <MostAwesomeDude> Guess I should send in a pathc.
14:48:52 <MostAwesomeDude> *patch, even.
14:49:06 <dmwit> JoeyA: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Foreign-C-String.html#withCString + http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Encoding.html
14:49:06 <rwbarton> "Enum a" isn't a type
14:49:30 <dmwit> MostAwesomeDude: Enum makes no guarantees about coverage.
14:49:34 <JoeyA> I guess it's implemented that way now :-)
14:49:36 <rwbarton> nor do you want an instance like Random a => Enum a
14:49:40 <dmwit> MostAwesomeDude: So... please don't send in a patch. =)
14:49:59 <MostAwesomeDude> dmwit: Oh. Is there any typeclass for enumerable, contiguous types?
14:50:03 <rwbarton> because (a) you couldn't implement a correct one, (b) it would overlap with everything
14:50:17 <dmwit> MostAwesomeDude: No, I typically write a "class Universe a where universe :: [a]" when I need that kind of thing.
14:50:20 <dmwit> Annoying.
14:50:24 <MostAwesomeDude> Becuase I'm noticing Random has *no* typeclasses supported.
14:50:33 <mux> there is Bounded a, Enum a but that still doesn't guarantee that the distribution isn't sparse, I think
14:50:33 <rwbarton> that's not how type classes work.
14:51:00 <rwbarton> you will still run into problem (b)
14:51:56 <MostAwesomeDude> Well, perhaps I should go back to the X problem here. I have a handful of types, I want to pick randomly from all of them. They're all Enum, and I wanted to just select from them with Random. Do I need to build instances for all of them?
14:52:08 <mux> hmm, that being said, if it's both Bounded and an Enum, it would be weird at best that toEnum x would diverse for x inside minBound, maxBound
14:52:11 <rwbarton> you don't need to write instances for any of them
14:52:21 <mux> diverge*
14:52:30 <rwbarton> you can just write a function :: (Bounded a, Enum a, RandomGen g) => g -> (g, a) or whatever
14:52:30 <Sgeo> Hmm
14:52:39 <Sgeo> Suppose I want to implement Storable
14:52:49 <dmwit> mux: Yes, it would be weird. But I still wouldn't expect any coverage guarantee.
14:52:53 <Sgeo> But my sizeOf does, in fact, rely on the argument to determine the size
14:52:56 <dmwit> > minBound :: Double
14:52:57 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
14:52:57 <lambdabot>    arising from a use o...
14:52:57 <Sgeo> Would stuff break?
14:52:58 <mux> dmwit: *nods*
14:53:06 <MostAwesomeDude> Hm. Alrighty.
14:53:14 <Sgeo> Should I not implement Storable in that case?
14:53:26 <rwbarton> if you like you can then use that function as the implementation for a Random instance for each one
14:53:43 <dmwit> Sgeo: That's not how Storable works. Storable is for things that can fit in a statically-sized chunk of memory.
14:53:56 <Sgeo> Ah, ok
14:53:59 <dmwit> Sgeo: So return the maximum size in sizeOf.
14:54:08 <Sgeo> ..:/
14:54:16 <rwbarton> or, just don't use Storeable
14:57:00 <Sgeo> "A value of type FunPtr a is a pointer to a function callable from foreign code. The type a will normally be a foreign type, a function type with zero or more arguments where"
14:57:07 <Sgeo> Is this statically checked?
14:57:18 <Sgeo> Or do I have to be careful?
15:01:01 <MostAwesomeDude> dmwit, rwbarton : Thanks for the insight; just reusing a boundedEnumRandomR when needed is a way better idea.
15:02:02 <ben> is something like memcpy() bound anywhere in Foreign.* or elsewhere?
15:08:06 <ben> Is it cheating if I make my code run faster by unsafeCoerce'ing a pointer out of someone's opaque data type and then using ffi-imported memcpy instead of 1000 calls to arrayRead
15:09:07 <JoeyA> It's dangerous, needless to say.
15:09:10 <zachk> it might break. it might break if someone changes something in the opaque data type, or it might break in some other places as well
15:09:40 <shriphani> hello everyone. I have a question about the type keyword and I am not sure what to google. What is the best way to do type foo = [a]  (i.e. I want to leave a free).
15:10:04 <mike-burns> shriphani: What's an example (what are you using that for)?
15:10:07 <JoeyA> You might need to touchForeignPtr or something to keep the source object from being garbage collected too soon.
15:10:11 <JoeyA> @hoogle touchForeignPtr
15:10:11 <lambdabot> Foreign.ForeignPtr touchForeignPtr :: ForeignPtr a -> IO ()
15:10:27 <JoeyA> type Foo a = [a]
15:10:35 <shriphani> mike-burns: say I want to replace [a] in "length :: [a] -> Int
15:10:37 <ben> I saw they touch a foreignptr on every read, so I do a no-op read after I'm done
15:10:50 <ddarius> It might just break out of capriciousness.
15:10:51 <mike-burns> Ah, I see. What JoeyA said.
15:10:55 <ben> Yeah. :(
15:11:15 <JoeyA> shriphani: You'll still need to mention the type variable [a].
15:11:26 <JoeyA> err, a
15:12:51 <ben> http://hpaste.org/55823 is this how i write a fast loop, or do i need to add more exclamation marks
15:13:38 <dmwit> Fewer !'s is probably fine.
15:13:48 <dmwit> (>) is already strict for Int
15:13:48 <mike-burns> What's the benchmarking say?
15:14:24 <dmwit> But really, loop i max body = mapM_ body [i .. max] is probably already about as fast as you can get.
15:15:25 <ben> it's probably slower because it does one iteration more!
15:16:09 <zachk> !!! ben: what is the difference between bigO(n) and bigO(n+1) ?
15:16:44 <ben> zachk: The number of iterations is a constant in my program so it's all O(1) anyway.
15:17:56 <hpc> zachk: there is no difference
15:18:16 <zachk> ben: how many iterations do you have?
15:18:33 <ben> 2073600
15:18:52 <ben> though I'm letting memcpy do most of them now, because haskell is too slow.
15:26:33 <int80_h> I have a [Either Foo Bar]. Is there a function that will partition into two lists, based on the first Left Foo matched? Or do I have to do that by hand?
15:27:31 <mike-burns> @hoogle [Either a b] -> ([Either a b], [Either a b])
15:27:31 <lambdabot> No results found
15:27:33 <mike-burns> Like that?
15:28:20 <sipa> @hoogle [Either a b] -> (a, b)
15:28:21 <lambdabot> Data.Graph.Inductive.Graph nodeRange :: Graph gr => gr a b -> (Node, Node)
15:28:21 <lambdabot> Data.Array.IArray assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
15:28:21 <lambdabot> Data.Graph.Inductive.Graph lpre :: Graph gr => gr a b -> Node -> [(Node, b)]
15:28:21 <mike-burns> Anyway I got nothin'.
15:28:26 <Enigmagic> hoogle "[Either Foo Bar] -> ([Foo], [Bar])"
15:28:31 <dmwit> ?hoogle [Either a b] -> ([a], [b])
15:28:31 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
15:28:56 <dmwit> int80_h: "Based on the first Left Foo matched"?
15:29:00 <dmwit> int80_h: Do you want this?
15:29:07 <dmwit> ?hoogle (a -> Bool) -> [a] -> ([a], [a])
15:29:07 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
15:29:08 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
15:29:08 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
15:29:21 <dmwit> :t Either a b -> Bool
15:29:21 <lambdabot> parse error on input `->'
15:29:27 <dmwit> ?hoogle Either a b -> Bool
15:29:27 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
15:29:27 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
15:29:27 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
15:30:16 <hpc> @djinn [Either a b] -> ([a], [b])
15:30:17 <lambdabot> Error: Undefined type []
15:30:21 <hpc> pah
15:30:50 <int80_h> If I have a [Left Foo, Left Foo, Right Bar], I want a ([Left Foo],[Left Foo, Right Bar])
15:31:20 <int80_h> But I don't want to reinvent the wheel, I have a feeling this may already be handled by a already-written function.
15:31:25 <hpc> :t head &&& tail
15:31:26 <lambdabot> forall c. [c] -> (c, [c])
15:31:40 <hpc> :t (head . return) &&& tail -- use this
15:31:41 <Sgeo> What is lambda.haskell.org ?
15:31:41 <mux> :t partitionBy isLeft
15:31:41 <lambdabot> forall a. [a] -> ([a], [a])
15:31:42 <lambdabot> Not in scope: `partitionBy'
15:31:42 <lambdabot> Not in scope: `isLeft'
15:31:47 <mux> hmm, epic fail.
15:32:12 <hpc> er, (return . head)
15:32:24 <int80_h> return?
15:32:40 <hpc> for lists, return = (:[])
15:32:49 <hpc> or, return x = [x]
15:33:01 <mux> :tlet foo (Left _) = True; foo _ = False in partition foo
15:33:03 <mux> dang
15:33:07 <mux> :t let foo (Left _) = True; foo _ = False in partition foo
15:33:07 <lambdabot> forall t t1. [Either t t1] -> ([Either t t1], [Either t t1])
15:33:42 <mux> it's still inconvenient as this doesn't strip the Left/Right data constructors
15:33:58 <int80_h> okay, that was a specific example. If I have [Right Bar, Right Bar, Left Foo, Right Foo] it should give back ([Right Bar, Right Bar], [Left Foo, Right Foo])
15:33:58 <mux> oh, lol
15:34:01 <mux> :t partitionEithers
15:34:01 <lambdabot> forall a b. [Either a b] -> ([a], [b])
15:34:06 <mux> here you go.
15:34:12 <dmwit> mux: No.
15:34:18 <Sgeo> Does it make sense to make an instance of Bounded and Enum without Ord?
15:34:19 <dmwit> int80_h: You want span or break.
15:34:22 <Sgeo> Can that be done?
15:34:23 <dmwit> int80_h: Together with isLeft.
15:34:30 <int80_h> dmwit: thanks
15:34:36 <mux> dmwit: care to be a bit less terse?
15:34:48 <int80_h> that was sufficient
15:35:08 <mike-burns> mux: Keep the Either constructor in.
15:35:24 <mux> well my first example did just that then
15:35:45 <mux> I don't see the point in keeping it though
15:35:57 * mike-burns shrugs. Ask int80_h .
15:36:05 <dmwit> mux: It doesn't even have the right type for what he asked for.
15:36:40 <mux> dmwit: which version doesn't?
15:38:15 <mux> oh, span
15:39:14 <mux> I see what he wanted now.
15:39:21 <danlei> Ok, I found a great explanation on SO that made me understand this much better. ∀a. a must be Λa. ⊥, because we know nothing at all about a, ∀a. [a] could be Λa. [], Λa. ⊥, Λa. [⊥, ...], and [∀a. a] either Λa. ⊥, Λa. [] or [Λa. ⊥, Λa. ⊥, ...]. A producer of ∀a. a would have be able to provide a value of any type a consumer asked for, so the only choice is ⊥. Together with your explanations, that helped a lot. Thanks ddarius 
15:41:47 * monochrom likes two-person games for forall and exists, too
15:44:26 <cmccann> am I the only one who finds the hash table DoS attack thing pretty funny in light of all the people who act like it's the end of the world that Haskell doesn't encourage using hash tables everywhere?
15:45:13 <hpc> cmccann: what's funnier is how easy the fix is
15:45:41 <monochrom> what is the hash table DoS attack? probably Data.Map is just as vulnerable too
15:45:41 <hpc> create a random salt at RTS initialization and add that to every key before hashing
15:45:57 <mikeplus64> is WxHaskell dead?
15:46:27 <cmccann> monochrom, taking user-provided data and populating a hash table carelessly
15:46:27 <hpc> monochrom: pass a POST to a website with lots of foo=z&bar=z&quux=z&...
15:46:36 <cmccann> such that constructed values create only collisions
15:46:42 <hpc> monochrom: and those foo, bar, baz, quux, etc are specially crafted to cause hash collisions
15:46:57 <cmccann> so no, search trees aren't vulnerable
15:47:45 <cmccann> it's not that hard to fix, but apparently all kinds of existing web frameworks are vulnerable, which is frankly pathetic
15:48:00 <monochrom> ah, I heard that one at school. if you know the hashing function, you can do it. well, at school again, I heard randomized hashing to solve that, too. and I heard that compilers actually use it for symbol tables
15:48:15 <hpc> cmccann: it's the implementations of hash tables that come with various language runtimes
15:48:19 <cmccann> this is exactly why using more complicated data structures you don't understand because they're "faster" is dumb
15:48:40 <mike-burns> I didn't think anyone in Ruby/Perl/Python/Smalltalk/etc. used them because they're faster.
15:49:07 <cmccann> hpc, which is also a very ill-considered choice, but anyone building a web framework should be thinking about this sort of thing as well
15:49:32 <mike-burns> It took until nearly 2012 for anyone to notice and exploit it. Seems fine to me.
15:49:36 <monochrom> it's a combination of "it is said that they're faster" and "they're available and has good syntax"
15:50:14 <hpc> monochrom: which basically is the same as "it's faster after counting programmer time"
15:52:04 <cmccann> in this case I certainly don't blame the programmers who now have to worry about their web apps being vulnerable
15:52:29 <MostAwesomeDude> I bet Tim Peters will fix CPython relatively soon. It's kind of annoying how they listed vulnerable *frameworks* instead of *language runtimes* though.
15:52:36 <mike-burns> It looks like fixes have already been released or are being released.
15:52:47 <hpc> perl was fixed in 2004
15:52:55 * hpc had to research that today at work
15:53:03 <cmccann> yeah, perl at least had their shit together, apparently
15:53:18 <hpc> php should have a fix soon, i believe
15:53:30 <MostAwesomeDude> Also, doesn't work on 64-bit CPython.
15:54:03 <MostAwesomeDude> Doesn't work on CRuby 1.9. I'd be more worried about those of us with Java apps.
15:54:24 <MostAwesomeDude> "As node.js does not limit the POST size by default (we assume this would typically be the job
15:54:28 <MostAwesomeDude> of a framework), no effectiveness/efficiency measurements were performed.
15:54:33 <MostAwesomeDude> Really? Really, node?
15:55:54 <ddarius> cmccann: The solution is to use even more complicated data structure that you understand even less.
15:56:19 <cmccann> ddarius, obviously
15:56:49 <mike-burns> And JRuby has the same issue that MRI 1.8 has.
15:56:49 <cmccann> I'm sure everyone fixing this issue understands crypto well enough to not leave a slightly-less-obvious vulnerability in some popular framework
15:57:01 <mike-burns> Hah.
15:57:35 <MostAwesomeDude> cmccann: Well, for Python and Ruby, which are backed by native hashtable types, I would imagine that the fix is permanent and covers the entire runtime.
15:58:32 <MostAwesomeDude> It occurs to me that this only works when you know for sure that the hash table is actually hashing things; small dicts in PyPy and CPython tend to be optimized to arrays.
15:58:43 <cmccann> I'd like to imagine that, but the point is that understanding the performance of a hashtable is actually really complicated and when you're storing user-provided data, that's not comforting
15:59:53 <mike-burns> So what this means for a Web app is that one of the threads will hang?
15:59:57 <cmccann> the fact that this issue was so widespread in the first place doesn't exactly fill me with confidence that anyone "fixing" it knows what they're doing
16:00:11 <hpc> mike-burns: and munch up a whole CPU
16:00:16 <mike-burns> That seems simple enough: spin up another thread/cloud/VPS/dyno/whatever.
16:00:27 <cmccann> mike-burns, and will do so based on a single carefully-crafted POST
16:00:33 <cmccann> that's an incredibly easy DoS attack
16:00:41 <hpc> mike-burns: at least, by 2003 standards; in any event, all you have to do is make the server do more work than you
16:00:56 <hpc> then you can just match the resources of their server and keep it down with ease
16:01:04 <MostAwesomeDude> cmccann: The people behind CPython and Rubinius are, to put it mildly, well aware of what they're doing.
16:01:52 <cmccann> MostAwesomeDude, which is why perl thought of this ahead of time and avoided the issue, and they didn't, right?
16:02:42 <cmccann> though really, the fact that stuff like ASP.NET are also vulnerable is just pathetic
16:02:44 <mike-burns> Perl did a lot of things. It seems odd to say "I told ya so", in retrospect, on belahf of Perl.
16:02:47 <MostAwesomeDude> cmccann: Perl came first. It existed first, it matured first, it was on the Web first, by many years.
16:02:58 <brixen> cmccann: you don't have a problem with a framework converting arbitrary data to a language's objects?
16:03:15 <MostAwesomeDude> Now, *PHP* having this problem, that could be blamed on inept programmers.
16:03:19 <brixen> cmccann: I'm pretty firmly of the camp that this is a framework problem, not a language problem
16:03:34 <brixen> there are infinite ways to create long running computations
16:04:02 <cmccann> brixen, it's definitely the framework at fault for not avoiding it to begin with
16:04:07 <ddarius> MostAwesomeDude: Why did no one learn from Perl?
16:04:10 <Sgeo> Why would any framework index things by user-input values?
16:04:28 <mike-burns> Because hashes are easy to use in Perl.
16:04:28 <Sgeo> Instead of just indexing by what the programmer specifies e's looking for?
16:04:39 <MostAwesomeDude> brixen: This particular one, in Python, is about controlling the amount of CPU time required to execute lambda *elts: dict(*elts)
16:04:39 <Sgeo> And discarding the rest
16:04:56 <mike-burns> Sgeo: That would require some code analysis, no?
16:05:06 <cmccann> Sgeo, this is about parsing parameters in an HTTP query, so the key is the parameter name
16:05:30 <MostAwesomeDude> ddarius: Apparently nobody ever brought it to anybody's attention. I've never heard of this before, and apparently neither has anybody else.
16:05:45 <brixen> I'd really like to see eg JSON libs that lazily convert a blob to a language's value
16:05:53 <ddarius> I thought this was a well-known issue.  I'd certainly heard about such problems years ago.
16:06:21 <cmccann> hash tables being vulnerable to malicious keys is well-known, yes
16:06:33 <mike-burns> Well-known where? Among whom?
16:06:51 <ddarius> It's one of the common issues with hash tables.
16:07:04 <cmccann> anyone who knows anything about security and/or hash tables?
16:07:04 <ddarius> But I guess web programmers are data structure folk.
16:07:12 <cmccann> this is standard CS fare we're talking about
16:07:48 <MostAwesomeDude> cmccann: American-educated CS folk are not required to take any training in security.
16:07:52 <cmccann> I don't necessarily expect every web developer to know things like this, but language and framework authors really should
16:07:53 <brixen> understanding of algorithmic complexity is not common among many web devs
16:07:58 <MostAwesomeDude> Maybe it's different elsewhere.
16:08:06 <brixen> but I don't think we should be insulting them because of that
16:08:11 <mike-burns> Well I do agree that it's odd that no CS nerd looked over the hash table implementations.
16:08:20 <ddarius> MostAwesomeDude: Which just proves cmccann's point.
16:08:38 <cmccann> anyone who knows CS should understand hash tables well enough to realize this
16:08:43 <mike-burns> Though, no; Ruby's hashtable implementation was written a whole bunch of years back and likely seldom changed since then.
16:08:55 <cmccann> anyone writing code that accepts user input should know security well enough to realize this
16:09:12 <hpc> my classes spent far too much time on hash tables, imo
16:09:14 <brixen> cmccann: what's your favorite text on security?
16:09:14 <ddarius> Especially web facing user input.
16:09:23 <hpc> and not nearly enough on recursive data structures
16:11:05 <MostAwesomeDude> http://hg.python.org/cpython/file/e3ba7e1dd406/Objects/dictobject.c#l33
16:11:31 <brixen> actually, that question is for anyone, what's the best text on security?
16:11:44 <cmccann> brixen, I have a terrible memory for titles, sorry. it's been a while, and honestly my background in security is relatively weak
16:11:50 <cmccann> asking around is a better plan :]
16:11:54 <brixen> heh
16:11:55 <brixen> ok
16:12:25 <brixen> it's definitely an weak area for the majority of devs I've encountered
16:13:15 <cmccann> as the DoS vulnerability in question demonstrates, haha
16:13:41 <brixen> perimeter security thinking is the problem IMO
16:13:54 <brixen> biological systems have multiple defenses
16:14:07 <brixen> most software is still created with perimeter defenses, if any
16:14:09 <MostAwesomeDude> Huh, interesting.
16:14:45 <brixen> sanitize at the boundaries is the equivalent of saran-wrapping your body
16:15:01 <MostAwesomeDude> Okay, so in Python, dicts (hash tables) are pretty intelligent about things. However, every object knows how to hash itself, and the string hashing was contributed by, well, let's say a less-than-exemplary programmer. :3
16:15:21 <hpc> heh
16:16:29 <cmccann> anyway, the main point I still take from all this is the importance of avoiding needless complexity and tricky worst cases
16:17:16 <cmccann> using a simpler data structure with more predictable performance would have completely avoided the entire issue
16:17:20 <mike-burns> From what I can read, few if anyone has been affected by this, and the language implementations reacted quickly.
16:19:12 <cmccann> mike-burns, it's not that this issue itself is severe, it's the fact that better habits would have avoided it entirely
16:19:40 <cmccann> but everyone is going to focus on fixing the immediate issue, rather than asking how to avoid similar problems in the future
16:20:39 <mike-burns> Nah; both will happen, but the next generation of devs won't get all the knowledge and this will repeat in another 20 years.
16:20:54 <eyebloom> Is it every going to be possible to simulate a stack trace with parameter values in GHCi?
16:20:55 <ddarius> www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003.pdf
16:21:04 <eyebloom> *ever
16:21:08 <ddarius> For people's reference (and also why Perl fixed the issue in 2004.)
16:21:29 <brixen> ddarius: thanks
16:21:29 <cmccann> but apparently people would rather fix problems as they occur, rather than not writing broken code in the first place
16:21:31 <cmccann> for some reason
16:21:42 <ddarius> eyebloom: You can do that today by explicitly maintaining a stack.
16:21:50 <ddarius> I believe there is even a library or two for this on hackage.
16:21:54 <mike-burns> There are problems that didn't occur, because they fixed them in the first place.
16:22:03 <eyebloom> Does it require direct modification of code?
16:22:09 <ddarius> Yes.
16:22:15 <ddarius> That would be why it is explicit.
16:23:36 <eyebloom> I'm imagining it's a tremendous amount of work.
16:24:57 <eyebloom> You would need to put a stack onto the front of every function call?
16:32:30 <zeta-> I find old-time-1.0.0.7 gives an error: Not in scope: type constructor or class `CSUSeconds' Can I fix this -- or tell cabal to stick with 1.0.0.6 (world file?)?
16:33:37 <mux> cabal install 'old-time == 1.0.0.6' should do the trick, if i remember the syntax correctly
16:34:15 <mux> if it comes from the installation of another package, you can use --constraint='old-time == 1.0.0.6'
16:34:26 <zeta-> mux: Thanks, on cmd line?
16:34:33 <mux> yep
16:35:07 <zeta-> mux:  Thanks a lot, I'll try that now
16:35:14 <mux> sure
16:37:50 <hpaste> int80_h pasted “What do I need to do to sort my complicated type?” at http://hpaste.org/55827
16:50:54 <JoeyA> What's a good configuration file library for Haskell?
16:51:20 <JoeyA> (preferably something simple and INI-like; I don't need to parse a particular format)
16:51:34 <hpc> JoeyA: if you are going for REALLY simple, use show and read
16:51:46 <cygnus> http://hackage.haskell.org/package/hsini
16:52:43 <JoeyA> Looks sort of like what I want.  I also saw http://hackage.haskell.org/package/tconfig-0.5.1
16:53:47 <JoeyA> The problem with both packages is they're somewhat lacking in documentation.  It'd be nice to see what the configuration files are going to look like (I know, I'm lazy).
16:53:58 <mike-burns> I've been using JSON for my config files.
16:54:02 <mike-burns> With Aeson.
16:54:23 <cygnus> hsini parses INI-style config files, so you probably already know what those look like.  The other one, well, I'd be wary of anything so "simple" it doesn't even use Parsec (i.e., just string munging)
16:54:23 <JoeyA> I thought about JSON, but it isn't really a winner in terms of human-authorability
16:54:23 <Eduard_Munteanu> JoeyA: you could do what xmonad does, which is basically asking you to call the app entrypoint from Haskell and supply the configuration
16:54:33 <JoeyA> The killer being that JSON doesn't support comments.
16:55:02 <mike-burns> Oh yeah, that's a good point.
16:55:23 <cygnus> I've used hsini in production.  The API is a tad unwieldy, but it works well.
16:55:38 <JoeyA> Eduard_Munteanu: Preferably something a user without a Haskell compiler can edit ;-)
16:55:41 <int80_h> :q
16:55:43 <int80_h> \q
16:55:52 <int80_h> :quit
16:55:59 <JoeyA> lol
16:56:12 <JoeyA> Looks like someone's been using vim a little too much
16:56:23 <cmccann> or ghci
16:56:33 <JoeyA> Ah, didn't know that
16:56:35 <smop> lolol
16:57:02 <cmccann> if lambdabot had ops I'd suggest having it respond to :quit by kicking whoever said it
16:57:07 <JoeyA> But I can't judge.  Sometimes I use Ctrl+W to delete words, which doesn't work very well in XChat.
16:57:16 <JoeyA> :-)
16:57:23 <hpc> cmccann: i would have it respond with something like
16:57:31 <hpc> [sudo] password for cmccann:
16:57:41 <JoeyA> hunter2
16:57:48 <hpc> :D
16:58:03 <cmccann> haha
17:00:14 <mike-burns> Hah.
17:09:08 <chrisdone> hey
17:10:13 <JoeyA> Pfft, Data.Ini.Reader.parse <$> readFile "/etc/php5/apache2/php.ini"  produces Right (fromList [])
17:10:45 <mike-burns> At least it was successful.
17:10:50 <cygnus> Heh
17:11:28 <chrisdone> @quote boring
17:11:28 <lambdabot> monochrom says: recursive directory search is an alpha-beta with boring values of alpha and beta.
17:11:50 <Eduard_Munteanu> chrisdone: hi
17:11:57 <hpc> haha
17:12:27 <JoeyA> @context boring
17:12:27 <lambdabot> Unknown command, try @list
17:14:31 <JoeyA> That was in 2006.
17:15:08 <JoeyA> I didn't think they even had computers back then.
17:15:15 * chrisdone can't sleep, needs boring input
17:31:05 <ems> Hi, I've been having trouble getting code I wrote for GHC 6.12 to work in 7.0 and wondered if someone would be able to help me find a clean solution to the problem:
17:31:47 <ems> I think it has something to do with impredicative types (but I don't have a clear idea what that is)
17:32:17 <ems> the module that isn't compiling boils down to this:
17:32:29 <ems> type T = forall a. a -> a
17:32:33 <ems> x :: T
17:32:36 <ems> x a = a
17:32:40 <ems> y :: IO T
17:32:43 <ems> y = return x
17:32:52 <hpc> ems: hpaste it
17:32:54 <hpc> @where hpaste
17:32:54 <lambdabot> http://hpaste.org/
17:32:58 <ems> thanks
17:33:36 <tsuraan__> I'm confused about why ByteString.Internal has a toForeignPtr rather than just a toPtr; ForeignPtrs are for things that wouldn't normally be tracked by the garbage collector, aren't they?
17:33:39 * chrisdone doesn't know what kind of type type T = forall a. a -> a is
17:33:43 <hpaste> ems pasted “ghc 6.12 -> 7.0 impredactive types” at http://hpaste.org/55830
17:33:43 <mjrosenb> at least #haskell doesn't have autokick on spamming
17:34:02 <ems> I included the compiler error message in the paste
17:35:27 <ems> I think I can work around it by changing "type T = forall a. a -> a" to "data T = MkT (forall a. a -> a)"
17:36:02 <tsuraan__> I would think that doing unsafeForeignPtrToPtr on the ForeignPtr retrieved from toForeignPtr would alway be safe, but the docs make it sound like the invalidation of the the ForeignPtr will cause the Ptr to be invalidated, which would invalidate the ByteString, so that just doesn't make sense.  I just can't see how getting a ForeignPtr from a ByteString is sane at all
17:36:03 <BMeph> tsuraan__: Isn't that the point? ;)
17:36:10 <ems> but then I have to wrap / unwrap the constructor everywhere I use it, and I was hoping to make my changes as minimal as possible
17:36:28 <chrisdone> ems: i thought 7 wouldn't have impredicatives … what's the implementatino for 7?
17:37:14 <ems> I read somewhere that impredicatives were deprecated, but I don't know what that means for me
17:37:28 <tsuraan__> BMeph: but if I have a ByteString already, it's being tracked by the garbage collector, so what is the point of having a ForeignPtr that can somehow invalidate the Ptr on its own?  Or is a ForeignPtr just another reference to the Ptr, so as long as I keep my ByteString around, I'm safe to "unsafely" use the Ptr directly?
17:38:39 <tsuraan__> the whole finalizer being attached to the ForeignPtr makes me nervous.  It sounds like calling toForeignPtr on a ByteString and then losing the ForeignPtr will cause the RAM to be freed out from under the ByteString that I am still using.
17:38:49 <tsuraan__> which I guess would be insane
17:38:54 <ems> in any case, I don't understand why the compiler gives an error for the definition for 'y', given that it accepts 'x'
17:38:57 <chrisdone> ems: interesting. it might be to do with rank n types implementation http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg18919.html
17:41:18 <ems> hmm
17:44:25 <ems> So it seems like changing "type" to "data" is the way to do it? Too bad.
17:45:14 <ems> (I had found a related post here, with the same end result: http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html )
17:45:24 <ems> Ok, thanks for the pointer
17:46:53 <chrisdone> oh yeah, i've seen that post before. yeah that kind of sucks
17:47:33 <chemistree> is there a way to list all open channels?
17:48:05 <Sgeo> /list should work, but there may be a nicer way
17:48:11 <chemistree> sure
17:48:25 <chrisdone> ems: XNoMonoLocalBinds might help http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7 ?
17:48:34 <chrisdone> (as a temporary fix)
17:49:14 <Sgeo> chemistree, the only way I see to do it from webchat is list. Note that the list goes into Status
17:50:32 <ems> chrisdone: I tried turning on NoMonoLocalBinds, but it didn't make any difference
17:51:02 <chrisdone> :(
17:51:05 <ems> I put the language pragmas I was using in the hpaste; not sure if they're all necessary
18:00:24 <ems> chrisdone: it turned out the changes I needed to make were really minimal
18:00:37 <ems> the program now compiles and runs, seems to work the same
18:02:25 <tgeeky> ems: you missed him
18:02:54 <ems> ah, oops -.-
18:13:09 <zeta-> mux: Everything compiles now, thanks!
18:13:11 <zeta-> problem line is http://hackage.haskell.org/packages/archive/old-time/1.0.0.7/doc/html/src/System-Time.html#line-249 -- was CTime in 1.0.0.6
18:18:23 <dagnachewa> hi all
18:18:30 <dagnachewa> anyone here using xmobar ?
18:32:20 <mm_freak> given a function type with local state:  data State a = forall s. State s (s -> (a, s))
18:32:43 <mm_freak> can i somehow make sure that this function never returns the state unused?
18:33:31 <mm_freak> a simple solution would be to wrap up the state in a newtype:  data State s = forall s. State s (s -> (a, StateProxy s))
18:33:37 <mm_freak> but perhaps there is a nicer solution
18:35:08 <mm_freak> background:  when writing instances for this type i'd like to ensure statically that i don't mix up the state values
18:35:58 <mm_freak> in other words:  i'd like to prevent myself from storing the old state value, when the function has actually returned a new one
18:40:24 <mm_freak> one idea was this:  data State a = forall s' s. State s' (s' -> (a, s))
18:40:32 <mm_freak> but this doesn't work as well as i expected
18:43:59 <mm_freak> i think i'm basically asking how to emulate linear/uniqueness types in haskell
18:44:08 <chemistree> is there a way to join other channels without simply guessing their names?
18:44:22 <Sgeo> /list
18:44:25 <Sgeo> Then check Status
18:44:37 <chemistree> I am specifically looking for a discrete mathematics channel
18:44:48 <Sgeo> Ask in ##math (I'm guessing that name)
18:44:55 <chemistree> I did /list, but it froze my client and I had to restart...
18:44:57 <Sgeo> I guessed wrong.
18:45:04 <Sgeo> Ask in #math
18:45:06 <mm_freak> chemistree: ##crypto is probably the best channel for that, but people from ##math will surely answer, too
18:45:14 <mm_freak> or #math
18:45:14 <chemistree> k thnks
18:51:05 <mm_freak> ok, just for clarification:  i've got a function that gets a value of type 's' and returns a value of type 's'…  it has access to a function that has the same signature
18:51:52 <mm_freak> making sure that /if/ i use this other function, i /have to/ return its result instead of the orignal value…  is that linear types or uniqueness types?
18:51:56 <mm_freak> i'd guess the latter
18:59:23 <mm_freak> i think i've found a solution, but it feels dirty and can be cheated
18:59:32 <mm_freak> data State a = forall s' s. State s' (s -> s') (s' -> (a, s))
19:00:05 <mm_freak> runState (State s' rev f) = let (x, s) = f s' in (x, State (rev s) rev f)
19:00:40 <Sgeo> Are there any solutions that aren't cheatable?
19:00:56 <mm_freak> i'd think linear types can't be cheated
19:01:10 <mm_freak> but haskell doesn't have them…  you need to emulate them
19:01:29 <rwbarton> since you can write \x -> (x,x) at any type it will be hard to emulate them
19:02:48 <dagnachewa> anyone here using xmobar ?
19:02:51 <mm_freak> rwbarton: i think linear types would make sure that (,) can't return two different values
19:03:06 <mm_freak> so (x, x) would be allowed, but (sin x, cos x) wouldn't be
19:03:40 <rwbarton> in a linear type system, if x has a linear type, you can't write \x -> (x, x)
19:04:02 <rwbarton> since of course you need to be able to write things like \(f, g) (x, y) -> (f x, g y)...
19:04:14 <drdo> Is there something to parse ip4 and ip6 addresses in normal dotted format?
19:06:29 <mm_freak> rwbarton: you're right…  you're applying x to two functions there
19:07:04 <mm_freak> (x, x) = ((,) x) x
19:08:01 <mm_freak> i wonder if there is a particular reason not to have linear types in haskell…  occasionally they would be very useful
19:08:32 <mm_freak> they would be a perfect fit for my current problem
19:09:42 <dolio> Why not have first class existentials, and unions and intersections and refinement types?
19:10:08 <dolio> It's a lot of work to put them all in.
19:11:18 <mm_freak> dolio: how would they solve my problem?
19:11:41 <dolio> They wouldn't, but they'd solve other problems.
19:12:00 <mm_freak> i'd think linear types (only their rules, not necessarily the possible optimizations) would be easy to implement in haskell
19:12:05 <dolio> But the answer is the same for any given, "why isn't <type system feature> in Haskell?"
19:13:19 <dolio> Well, people are finding out that programming with linear types for the optimizations isn't really sufficient anyway.
19:13:43 <dolio> It's too restrictive to have linearity on every value you want collected.
19:13:56 <mm_freak> haskell code is fast enough, so i'm not asking for more speed…  in this case i'm really asking for the static guarantees they provide
19:14:30 <dolio> For optimizations you apparently want some kind of linear region tracking.
19:14:39 <dolio> But I don't know all the details.
19:14:55 <dagnachewa> please help xmobar http://pastie.org/3088261
19:14:58 <mm_freak> regions are no problem…  there are ready-made libraries for them
19:15:47 <dolio> That's fine if you want to program in a crappy EDSL.
19:16:04 <mm_freak> why crappy?
19:16:53 <dolio> Because it's going to be an ST-like language with explicit references associated with regions and whatnot, no?
19:17:10 <mm_freak> dagnachewa: i'd recommend asking on the mailing list
19:17:24 <dolio> I'm talking about where ordinary values are associated with a region and the regions are linear for collection.
19:17:35 <mm_freak> dolio: not necessarily, although in the existing implementations that's true
19:18:05 <mm_freak> dolio: but you can have a region abstraction in the style of implicit configurations
19:18:49 <mm_freak> that's how i do modular arithmetic without passing moduli around
19:18:59 <dolio> Yes.
19:20:08 <rwbarton> linear types are a strange fit for classical computation
19:20:48 <rwbarton> it's not that I *can't* duplicate that array of a million elements, I just don't want to.
19:21:12 <mm_freak> rwbarton: my application (simplified) is a value with local state…  a self-mutating value if you will
19:21:23 <mm_freak> data State a = forall s. State s (s -> (a, s))
19:21:25 <rwbarton> To me introducing linear types would be a much larger shift than any of the other stuff dolio mentioned.
19:21:35 <rwbarton> Yeah, I think I understand what you are trying to do
19:21:37 <mm_freak> the runState function has the signature:  State a -> (a, State a)
19:21:53 <rwbarton> like if you generalize the State monad to a parameterized monad, then the >>= has a unique implementation
19:22:05 <mm_freak> it's not even a monad
19:22:12 <rwbarton> the State monad is a monad
19:22:29 <mm_freak> yeah, sure…  but the state monad has global state…  it's not very composable
19:22:41 <rwbarton> I'm just saying you want to do something similar somehow with your unfortunately-named type.
19:22:53 <dolio> His State up there isn't, I think.
19:23:00 <rwbarton> right
19:23:01 <dolio> You can't be sure the existentials match up.
19:23:06 <rwbarton> wait
19:23:14 <mm_freak> my real type isn't named State anyway…  it's more complicated, so i simplified it to the essential problem
19:23:15 <rwbarton> you mean the State a he just wrote?
19:23:22 <dolio> Right.
19:23:29 <rwbarton> I mean, it is isomorphic to [a], no?
19:23:36 <mm_freak> rwbarton: to Stream a
19:23:38 <rwbarton> so, it happens to be a monad in an irrelevant way
19:23:40 <rwbarton> oh, yes
19:23:46 <dolio> Oh, yeah.
19:23:55 <rwbarton> That's not what I meant though, I just meant the normal mtl State monad.
19:24:09 <dagnachewa> anyone here using xmobar ?
19:24:18 <mm_freak> the normal mtl state monad can't have a linear state type anyway
19:24:32 <mm_freak> unless you restrict the possible operations to 'modify'
19:24:36 <mm_freak> and 'put'
19:24:40 <rwbarton> you can make it a parameterized monad, though, and then you get something like what you want, perhaps
19:24:45 <dolio> Nah, put is bad, too.
19:24:49 <dolio> Because it forgets things.
19:24:52 <rwbarton> You can't accidentally implement (>>=) wrong then
19:25:01 <rwbarton> so, it seems you have gained some kind of guarantee
19:25:05 <mm_freak> dolio: huh?  linear types don't allow that?
19:25:10 <dolio> Nope.
19:25:18 <dolio> \x -> () is non-linear.
19:25:25 <mm_freak> hmm, ok
19:25:25 <dolio> In x.
19:25:29 <mm_freak> but that's fine in my case
19:25:33 <rwbarton> (just like f : R -> R; f x = 1 is nonlinear)
19:25:45 <dolio> You want affine or something.
19:25:47 <mm_freak> ah, i see
19:26:21 <mm_freak> ok, 'put' would be unique, but not linear
19:26:24 <dolio> Or maybe you want uniqueness.
19:26:37 <mm_freak> well, in my case a linear type would be fine
19:26:55 <mm_freak> or well, not necessarily…  it depends on the computation
19:34:33 <Guest39809> i don't recall the exact name, other than that it started with a "c", but isn't there a pretty good tool for profiling haskell (other than ghc)?
19:35:57 <Clint> does it rhyme with riterion?
19:36:25 <Guest39809> ah
19:36:27 <Guest39809> duh
19:36:27 <Guest39809> thanks
19:37:46 <dagnachewa> please anyone here using xmobart ?
19:37:50 <dagnachewa> xmoba
19:37:56 <dagnachewa> xmobar sorry
19:38:21 <Clint> i am
19:38:52 <dagnachewa> Clint, here is the error I am getting http://pastie.org/3088261
19:39:06 <dagnachewa> Clint, it was fine until I added Disk
19:39:11 <tgeeky> dagnachewa: try #xmonad
19:39:19 <tgeeky> if #haskell doesn't help
19:39:37 <dagnachewa> tgeeky, thank you I forgot :)
19:40:00 <periodic> Anyone have any luck linking to some Haskell DLLs from a C# project in Visual Studio?
19:44:22 <periodic> Wondering if I should fall back to C++...
19:44:39 <tgeeky> at least crouch behind some well-placed barricades
19:45:26 <periodic> I'm so battered and beaten at this point that I'm just slogging on.
19:46:00 <tgeeky> periodic: I know that there is an unfortunately (because I can't remember it) named hackage package that has to do with windows DLLs
19:46:45 <periodic> Well, making a DLL doesn't seem to be a problem.
19:46:57 <periodic> At least following the instructions in the GHC docs yields a DLL.
19:47:05 <periodic> integrating it into a VisualStudio project though...
19:52:51 <periodic> I can get the C++ imports working from the command line.  hmmm...
19:59:02 <confab> @hoogle (.)
19:59:02 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
19:59:03 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
19:59:03 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
20:07:02 <cl1> aww .. too bad periodic left. i coulda helped them out
20:11:04 <cl1> irc is quiet this evening
20:11:51 <hughfdjackson> too quiet
20:12:14 <hughfdjackson> :P let me liven things up v. slightly
20:12:30 <hughfdjackson> i want an excuse to take haskell for spin (been wanting to for a while, even popped in here a couple of times)
20:12:34 <cl1> sounds good to me
20:13:00 <cl1> an excuse or a project
20:13:16 <cl1> type classes. need I say more?
20:13:23 <cl1> that's ur excuse
20:13:25 <hughfdjackson> hehe
20:13:35 <hughfdjackson> well, excuse to me is 'this is useful to me / i can spare the time'
20:13:50 <cl1> type clasess are worth your time
20:13:55 <hughfdjackson> it's really just out of curiousity over different programming paradigms and how the same problems are solved elsewhere, etcetc
20:14:02 <cl1> what languages do you currently use to write code?
20:14:09 <hughfdjackson> mostly javascript ^^
20:14:29 <hughfdjackson> so, a semi functional, if imperative language
20:14:42 <hughfdjackson> hopefully that puts me in a fairly decent stead here :P
20:14:55 <cl1> javascript doesn't have currying
20:15:10 <hughfdjackson> or TCO
20:15:39 <hughfdjackson> and you can curry in js
20:15:41 <hughfdjackson> if you want to
20:15:56 <hughfdjackson> it's not commonly done
20:16:20 <cl1> what would be the syntax for that?
20:16:21 <mikeplus64> @type (0,(,,,),0)
20:16:22 <lambdabot> forall t a b c d t1. (Num t, Num t1) => (t, a -> b -> c -> d -> (a, b, c, d), t1)
20:16:25 <hughfdjackson> (at least, as i understand it - my functional skills are probably not gonna be up to scratch for a good long time)
20:16:31 <mikeplus64> you don't have sea monsters in javascript
20:16:42 <hughfdjackson> ahaha
20:16:46 <hughfdjackson> that's nice
20:16:46 <JoeyA> Currying is easy to explain in JavaScript: f(a)(b) instead of f(a, b)
20:16:55 <hughfdjackson> yea, what JoeyA said
20:17:05 <JoeyA> function f(a) { return function(b) { ... }; }
20:17:14 <kallisti> is _|_ bottom important when discussing whether or not two types are isomorphic?
20:17:44 <cl1> bleh @ f(a)(b)
20:17:56 <parcs`> kallisti: i think so
20:17:57 <cl1> however I have been tempted to do that a time or two in c# >_>
20:18:24 <hughfdjackson> s/\(|\)/ /g :p
20:18:33 <hughfdjackson> isn't it just f a b in haskell?
20:18:51 <Sgeo> data D = D MyType is not the same as newtype D = D MyType
20:18:53 <cl1> yes @ hughfdjackson
20:18:56 <kallisti> for example. Is a 1-tuple of a isomorphic to a even though (_|_) has no equivalent? And is [a] isomorphic to List = Maybe (a, List a) even though there is no equivalent to Just _|_, Just (a, Just _|_), ... etc.
20:19:03 <cl1> @type map
20:19:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:19:37 <hughfdjackson> cl1: i'm not entirely sure you can write a curry/uncurry though
20:20:12 <hughfdjackson> i hadn't thought about it yet (one generally doesn't, since the uglyness of the syntax and the possibility for partial application through .bind
20:20:13 <hughfdjackson> )
20:20:52 <hughfdjackson> :| hughfdjackson goes to other rooms
20:20:55 <hughfdjackson> talks about javascript
20:21:20 <hughfdjackson> :P sorry, it's a force of habit - gives me a v. familiar reference to frame other things with
20:21:42 <hughfdjackson> :D shall try to curb it
20:21:49 <rwbarton> kallisti: both taking _|_ into account and ignoring _|_ can be useful to think about
20:22:35 <rwbarton> but by default I guess I would say that your example pairs are not isomorphic types
20:23:04 <cl1> public Func<IEnumerable<T>,IEnumerable<U>> Map<T,U>(Func<T,U> f) { return xs => from x in xs select f(x); }
20:23:10 <cl1> that would be map in c#
20:23:39 <cl1> that is all
20:24:28 <kallisti> rwbarton: is there any particular reason that _|_ can be ignored in such a way?
20:25:02 <dolio> People typically don't care about where _|_ goes.
20:25:29 <rwbarton> it might make sense to ignore it for whatever application of "isomorphic" you have in mind
20:25:40 <kallisti> it makes sense to ignore it when discussing type theory, perhaps. And it would make sense to consider it when talking about Haskell semantics.
20:25:49 <dolio> It's only an incidental concern inasmuch as it affects behavior on infinite values and such.
20:26:21 <rwbarton> e.g. you might want to say that data Stream a = Cons a (Stream a) is "isomorphic" to Nat -> a
20:26:24 <dolio> Which is what people typically care about.
20:26:36 <rwbarton> so that now you know the former is a monad, because the latter is the Reader Nat monad
20:26:48 <rwbarton> but of course they have different partial values
20:26:49 <kallisti> ah okay.
20:27:57 <kallisti> how is Stream s isomorphic to Nat -> a there?
20:28:54 <rwbarton> well the stream Cons a0 (Cons a1 (Cons a2 ...)) corresponds to f 0 = a0; f 1 = a1; f 2 = a2; ...
20:29:20 <kallisti> and then undefined values are _|_?
20:29:42 <rwbarton> each ai could be _|_, that works fine
20:29:52 <rwbarton> but on the Stream side, you also have things like Cons a0 (Cons a1 _|_)
20:31:11 <rwbarton> while on the Nat -> a side, you just have one extra value _|_
20:32:46 <cl1> which do you think is easier to read: break isLineTerminator cs ... or ... isLineTerminator `break` cs ?
20:33:11 <ivanm> cl1: I think the former
20:33:42 <rwbarton> in theory it could depend on context but I can't imagine one where the latter was better
20:33:42 <kallisti> cl1: it's not a huge difference to me, but I would say the former, yes.
20:34:04 <cl1> anyone else?
20:34:41 <kallisti> rwbarton: I would only use the infix form when partially applying break as an operator section, instead of using flip.
20:35:13 <cl1> i'm just trying to get a feel for the most common usage scenarios. I see `elem` alot, but nothing else
20:35:42 <cl1> s/alot/a lot/
20:36:35 <rwbarton> I do use `fmap` infix sometimes, that's the closest thing I can think of
20:36:38 <kallisti> rwbarton: oh, an unrelated question: when is Stream a useful? It seems that in most situations you would want to be able to catch [] and do something consequently.
20:36:44 <kallisti> rwbarton: for stream-like data.
20:37:31 <rwbarton> kallisti: maybe Stream doesn't have the right connotations, but anywhere you have a list you know is infinite
20:39:33 <mm_freak> kallisti: the applicative interface of Stream is useful, but in general a more useful type is the automaton type:  newtype Auto a b = Auto (a -> (b, Auto a b))
20:40:22 <mm_freak> you can use it for functional reactive programming, for example…  in some cases, when your reactive objects don't communicate with each other, Stream with the Applicative interface is sufficient
20:40:34 <mm_freak> liftA2 (+) (countFrom 0) (countFrom 10)
20:41:20 <rwbarton> ZipList has an applicative instance too, so I wouldn't call that too compelling
20:42:12 <mm_freak> ZipList is a generalization of Stream, but i've never really found it useful
20:42:36 <rwbarton> it's a generalization to []!
20:42:51 <mm_freak> the infinity of Stream is a useful property
20:43:05 <mm_freak> rwbarton: huh?  ZipList is isomorphic to []
20:43:16 <rwbarton> yes that's what I said
20:43:27 <rwbarton> you are generalizing the Stream applicative instance to []
20:43:48 <mm_freak> you generalize it to ZipList
20:44:11 <mm_freak> [] has a very different Applicative instance
20:44:29 <mm_freak> you could write the same for Stream, but it wouldn't be useful
20:44:29 <rwbarton> it seems like you're just trying to be difficult :P
20:44:48 <mm_freak> i am difficult =)
20:44:52 <rwbarton> okay then
20:44:55 <mm_freak> but really, i don't understand
20:44:57 <kallisti> perhaps you have two different meanings for "generalize" here?
20:45:03 <mm_freak> probably
20:45:15 <rwbarton> just imagine the applicative instance for [] is the ZipList one
20:45:32 <mm_freak> then [] is just ZipList
20:45:37 <rwbarton> yes
20:45:50 <rwbarton> [] contains more values than Stream
20:46:01 <dolio> Why would I use Bool when I have Int?
20:46:02 <rwbarton> and the Stream applicative instance is just the restriction of the [] one
20:46:35 <mm_freak> i see what you're saying, but why are you renaming ZipList to []?
20:46:45 <mm_freak> [] is not ZipList
20:46:51 <rwbarton> because you seem to be getting confused otherwise
20:47:00 <mm_freak> in what way?
20:47:02 <rwbarton> although it doesn't seem to be helping
20:47:19 <rwbarton> anyways if you know your list is infinite, you should consider using Stream rather than []
20:47:25 <rwbarton> that's what I said originally
20:47:40 <mm_freak> i think, i've stated the same with different words =)
20:47:49 <rwbarton> but the Stream applicative instance isn't something you gain by doing this
20:47:57 <rwbarton> you already had it back at [], via ZipList
20:47:57 <tgeeky> rwbarton: mm_freak: is there more structure here, though? If you look at streams which come n-at-a-time (each iteration of a stream yields 3 values)
20:48:19 <mm_freak> tgeeky: not really
20:48:39 <rwbarton> whereas e.g. the fact that this applicative instance can be extended to a monad *is* something that you gain (for whatever it's worth)
20:48:52 <mm_freak> tgeeky: toTriples :: Stream a -> Stream (a, a, a)
20:49:02 <tgeeky> mm_freak: no
20:49:03 <mm_freak> fromTriples :: Stream (a, a, a) -> Stream a
20:49:08 <mm_freak> so they're the same
20:49:48 <mm_freak> rwbarton: ZipList and Stream don't have a useful Monad instance…  you can define one, but it's not going to be useful
20:49:48 <tgeeky> Stream (a, (Stream (a, a, a), a) -> (same thing)
20:49:52 <tgeeky> something like that?
20:50:09 <rwbarton> (a) ZipList doesn't have one (b) people use the Reader monad
20:50:28 <tgeeky> mm_freak: what does it mean for it no to be useful?
20:50:35 <tgeeky> i actually don't understand
20:50:38 <tgeeky> not trying to be cute
20:50:45 <mm_freak> tgeeky: depends on the semantics of that, but there is no function to turn a generic Stream in any useful way into the stream type you showed
20:51:02 <mm_freak> tgeeky: the problem is the second argument to (>>=)
20:51:05 <mm_freak> it's a function
20:51:16 <mm_freak> try to write a Monad instance for Stream and you will see what's the problem
20:51:41 <kallisti> rwbarton: there actually is a Monad instance for ZipList
20:51:47 <kallisti> er well, not defined
20:51:53 <mm_freak> tgeeky: a better way to see this is to try to write 'join'
20:51:55 <kallisti> I mean, it's possible to write one.
20:51:58 <mm_freak> Stream (Stream a) -> Stream a
20:52:07 <rwbarton> not one that satisfies the monad laws, and restricts to the "zip" applicative instance.
20:52:09 <dolio> There's nothing wrong with the Stream monad.
20:52:09 <ski> mm_freak : diagonal
20:52:10 <mm_freak> do you return the first stream or the head element of all streams?
20:52:38 <ski> this is basically `Reader Nat'
20:52:44 <mm_freak> ski: that destroys your Applicative instance
20:52:51 <rwbarton> no it doesn't
20:53:26 <rwbarton> if you convert the Reader Nat Applicative instance back into the Stream language, it's the "zip" instance
20:53:28 <mm_freak> even if it doesn't, it will take O(n) memory
20:53:29 * tgeeky is going to get confused
20:54:29 <mm_freak> rwbarton: diagonalization will destroy your Applicative…  i've tried the same with the automaton arrow
20:54:39 <mm_freak> and it's not going to be very useful anyway
20:54:41 <rwbarton> ...
20:54:49 <ski> kallisti : what should `join ((ZipList . map ZipList) [[0],[1],[2,3,4,5]])' give there ?
20:55:12 <mm_freak> rwbarton: implement diagonalization and then compare the resulting 'ap' to <*>
20:55:24 <kallisti> ski: uh I actually don't remember what the instance is supposed to look like. I just know that it's possible.
20:56:08 <rwbarton> I actually don't know that the ZipList Applicative instance doesn't extend to a Monad. I just know the obvious thing to try doesn't work
20:56:10 <kallisti> ski: I can try to find it though.
20:56:25 <rwbarton> but it seems to be general wisdom that the first statement is also true.
20:57:09 <kallisti> I'll try to find it in some IRC logs...
20:57:27 <mm_freak> that was my conclusion…  <*> is more exhaustive than >>= for ZipList, because >>= receives a whole family of streams
20:57:35 <mm_freak> uhm
20:57:40 <mm_freak> ziplists
20:57:56 <mm_freak> but yeah, i actually tried it with Stream, not with ZipList
20:58:00 <cl1> is there a try/catch mechanism in haskell?
20:58:02 <ski> @let diagonal :: [[a]] -> [a]; diagonal [] = []; diagonal ((a:_):ass) = a : diagonal (map tail (takeWhile (not . null) ass))
20:58:03 <lambdabot>  Defined.
20:58:07 <mm_freak> cl1: sure
20:58:07 <ski> @hoogle catch
20:58:08 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
20:58:08 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
20:58:08 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
20:58:13 <mm_freak> cl1: see Control.Exception
20:58:16 <ski> @hoogle+
20:58:16 <lambdabot> Control.Exception.Base catch :: Exception e => IO a -> (e -> IO a) -> IO a
20:58:16 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
20:58:16 <lambdabot> Control.OldException catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
20:58:19 <rwbarton> there is no try though. only do.
20:58:32 <dolio> There is also do not.
20:58:39 <mm_freak> don't
20:58:51 <cl1> so haskell is yoda in disguise! O_O
20:58:58 <ski> kallisti : well, i doubt you can make a monad out of `ZipList' :)
20:59:00 <rwbarton> @type don't
20:59:01 <lambdabot> Not in scope: `don't'
20:59:08 <mm_freak> rwbarton: acme-dont package =)
20:59:09 <cl1> @info do not
20:59:10 <lambdabot> not
20:59:24 <tgeeky> can one of you conduct a thought experiment: what advantages or disadvantages by erasing and re-writing Prelude with the kinds (promotion, constraints) in 7.4?
20:59:29 <cl1> @type do or do not there is no try
20:59:29 <tgeeky> anything interesting?
20:59:30 <lambdabot> parse error on input `do'
20:59:37 <cl1> lol
20:59:51 <dolio> I don't think anyone's conclusively proved that there is no monad, but people have tried a lot without success, so that tends to push one way.
20:59:59 <mm_freak> tgeeky: tuples might get nicer
21:00:58 <rwbarton> type errors will probably become harder to understand
21:01:03 <rwbarton> or disappear entirely
21:01:20 <tgeeky> rwbarton: presumably the bad kind of disappear?
21:01:31 <rwbarton> mostly, yes
21:02:25 <ski> @type let ma >>= amb = diagonal (map amb ma); mab `ap` ma = mab >>= \ab -> map ab ma in ap
21:02:26 <lambdabot> forall a a1. [a -> a1] -> [a] -> [a1]
21:02:58 <mm_freak> particularly i've tried very hard to come up with a useful Monad instance for Stream, because it would allow turning AFRP into MFRP, which would be great
21:03:09 <dylukes> I have a new little quote for when people pastedump.
21:03:23 <dylukes> @remember dylukes Get this man to a paste host, post haste!
21:03:23 <lambdabot> Done.
21:03:32 <tgeeky> lol
21:04:14 <tgeeky> mm_freak: acronym dumps for those?
21:04:25 <rwbarton> > let ma >>= amb = diagonal (map amb ma); mab `ap` ma = mab >>= \ab -> map ab ma in ap [(*10), (*100)] [2, 3]
21:04:27 <ski> > let ma >>= amb = diagonal (map amb ma); mab `ap` ma = mab >>= \ab -> map ab ma in zip (zipWith ($) (map (*) [2 ..]) [1 ..]) (map (*) [2 ..] `ap` [1 ..])
21:04:27 <lambdabot>   [20,300]
21:04:28 <lambdabot>   [(2,2),(6,6),(12,12),(20,20),(30,30),(42,42),(56,56),(72,72),(90,90),(110,1...
21:04:30 <rwbarton> heh
21:04:43 <mm_freak> tgeeky: arrowized FRP, monadic FRP
21:04:54 <mm_freak> FRP = functional reactive programming
21:05:00 <tgeeky> mm_freak: i guessed that part
21:05:20 <tgeeky> mm_freak: pm?
21:05:28 <mm_freak> AFRP is based on the automaton arrow, which is basically a parameterized stream
21:06:33 <kallisti> <oerjan> > let infixl 1 >>+; ZipList l >>+ f = ZipList . diag . scanl1 (zipWith (const id)) $ map (getZipList . f) l where diag ((x:xs):xss) = x:diag (map (drop 1) xss); diag _ = [] in getZipList $ ZipList [3,2,1] >>+ ZipList . flip take "abcd"
21:06:39 <kallisti> >>+ is bind here.
21:06:44 <dolio> I think you're using some different criteria.
21:06:47 <dolio> Stream is a monad.
21:06:56 <dolio> "useful" doesn't enter into the definition of a monad.
21:07:23 <dolio> And the 'ap' you get from Stream's monad is the same as the applicative you'd write.
21:07:40 <kallisti> I can't really explain how it works, but if anyone is curious contact oerjan next time he's on freenode.
21:07:45 <dolio> At least as far as results for a given input are concerned.
21:08:13 <mm_freak> dolio: sure, the obvious Applicative-compatible instance is certainly possible, though i haven't verified the laws for it
21:08:14 <dolio> Unless perhaps there is some weirdness lurking on partially defined values.
21:08:33 <dolio> But I don't much care about those.
21:08:48 <kallisti> ski: here's >>= for ZipList  ^^^
21:09:05 <rwbarton> @type scanl1 (zipWith (const id))
21:09:06 <lambdabot> forall a. [[a]] -> [[a]]
21:09:18 <dolio> You can't get back the Applicative instance from the obvious ZipList Monad in the same way.
21:09:21 <rwbarton> oh
21:09:24 <kallisti> > let infixl 1 >>+; ZipList l >>+ f = ZipList . diag  . scanl1 (zipWith (const id)) $ map (getZipList . f) l where  diag ((x:xs):xss) = x:diag (map (drop 1) xss); diag _ = [] in  getZipList $ ZipList [3,2,1] >>+ ZipList . flip take "abcd"
21:09:26 <lambdabot>   "ab"
21:09:43 <dolio> Er.
21:09:49 <dolio> That's wrong.
21:09:52 <dolio> It's just not a monad.
21:10:20 <rwbarton> so I guess scanl1 (zipWith (const id)) takes a list and truncates each list to the length of the previous one
21:10:25 <rwbarton> *a list of lists
21:10:35 <kallisti> rwbarton: yes it changes the length.
21:11:16 <rwbarton> I think after 'diag', though, that is the same as the usual failed Monad (>>=), no?
21:11:55 <kallisti> rwbarton: I don't know what the usual failed >>= is.
21:12:15 <rwbarton> it's the same as what you wrote, minus " . scanl1 (zipWith (const id))".
21:12:31 <kallisti> 02:50:30: <oerjan> if you take the diagonal naively, there is sometimes something wrong with the third monad law
21:12:34 <kallisti> probably.
21:12:47 <ski> yes there is
21:13:14 <rwbarton> oh hmm
21:13:17 <rwbarton> this is different
21:13:43 <rwbarton> on input like ["a", "bc", "def"]
21:14:03 <rwbarton> it produces "a" rather than "acf"
21:14:18 * ski supposes he should have had a `diagonal ([]:_) = []' case as well -- was mostly thinking to write one for `Stream'
21:15:11 <rwbarton> this sounds sort of plausible actually... if I want to form an n-fold join [[...[a]...]] -> [a] then the length of the result is the largest l such that the "n-cube" of size l fits inside the nested lists
21:15:13 <ski> @let infixl 1 >>+; ZipList l >>+ f = ZipList . diag  . scanl1 (zipWith (const id)) $ map (getZipList . f) l where  diag ((x:xs):xss) = x:diag (map (drop 1) xss); diag _ = []
21:15:14 <lambdabot>  Defined.
21:15:33 <ski> > let join mma = mma >>+ id in join ["a", "bc", "def"]
21:15:33 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
21:15:33 <lambdabot>                  ...
21:15:58 <mm_freak> if you could write an O(1) memory and O(1) time indexed lookup for Stream, then a useful Applicative-compatible Monad instance wouldn't actually be that difficult
21:16:00 <ski> > let join mma = mma >>+ id in (map getZipList . join . ZipList . map ZipList) ["a", "bc", "def"]
21:16:00 <lambdabot>   Couldn't match expected type `[Control.Applicative.ZipList a]'
21:16:01 <lambdabot>         agai...
21:16:04 <mm_freak> but i can't imagine such a stream type
21:16:46 <ski> > let join mma = mma >>+ id in (getZipList . join . ZipList . map ZipList) ["a", "bc", "def"]
21:16:47 <lambdabot>   "a"
21:17:12 <mm_freak> hmm, wait
21:17:15 <mm_freak> i've got an idea
21:17:38 <mm_freak> perhaps a good Monad instance can be written for a Stream-like type
21:17:45 <ski> rwbarton : i don't think a whole cube is needed
21:17:56 <kallisti> ski: anyway oerjan can probably explain it better than me. Send a PM to him next time he's around (I don't think he frequents #haskell but he's on freenode)
21:18:16 <kallisti> ski: oh also he's in a channel with lambdabot so @tell would work as well.
21:18:18 <rwbarton> well, it's true for n=2. :)
21:18:21 <rwbarton> let me think about it some more
21:18:29 <ski> preflex: xseen oerjan
21:18:29 <preflex>  oerjan was last seen on freenode/#esoteric 119 days, 3 hours, 25 minutes and 30 seconds ago, saying: !haskell map Unsafe.Coerce.unsafeCoerce [[1,2],[3,4,5],[6,7,8,9]] :: [Maybe Integer]
21:18:45 <rwbarton> what
21:18:48 <kallisti> erm, that information is outdated.
21:18:55 <kallisti> he was on #esoteric today, in fact.
21:19:07 <ski> interesting
21:19:28 <ski> rwbarton : are you talking about oerjan's `join' or the other one ?
21:19:32 <rwbarton> oerjan's
21:19:38 <ski> ok, then it might be true
21:20:02 * ski was talking about the one he defined
21:20:17 <ski> (where the associative law fails, for finite lists)
21:20:21 <rwbarton> right, that one doesn't work
21:20:50 * ski still suspects oerjan's also breaks a monad law
21:21:02 <rwbarton> it seems correct to me
21:21:10 <notsmack2> I'm getting:  cabal: error while loading shared libraries: libffi.so.5: cannot open shared object file: No such file or directory
21:22:12 <kallisti> 02:52:46: <oerjan> it works to define the Applicative from it.  even without the scanl1 part.
21:22:15 <kallisti> 02:53:46: <oerjan> this is because the list of lists which arises from applicative use is always rectangular, so the scanl1 part has no effect
21:22:55 <notsmack2> (the cabal ubuntu provides works, this is .cabal/bin/cabal)
21:23:15 <ski> kallisti : hm, ok -- i now think it more plausible that this actually works
21:23:16 <rwbarton> hmm, what's the computational way to think about this
21:25:05 <shapr> kallisti: Is your last name Erisson?
21:26:00 <ski> hello shae
21:26:15 <shapr> hej Stefan
21:26:19 <kallisti> shapr: no.
21:26:23 <kallisti> ?
21:26:29 <shapr> kallisti: ha. MY last name is Erisson!
21:26:39 <kallisti> I see.
21:26:56 <kallisti> rwbarton: I don't know if there necessarily is one.
21:27:05 <shapr> kallisti: I claim that I have now turkey cursed you.
21:27:19 <kallisti> rwbarton: as far as I can tell it's just brute forcing the monadic laws to be correct.
21:27:21 <rwbarton> Sorry, necessarily is a what?
21:27:24 <rwbarton> oh
21:27:38 <ski> rwbarton : well, in case of `Stream' ~= `Reader Nat', you can think of a signal carrying a time-changing value, with discrete time
21:27:39 <rwbarton> well you can describe the n-fold join
21:27:47 <ski> for `ZipList', time can end
21:28:05 <rwbarton> which is essentially how you want to verify associativity
21:28:58 <rwbarton> so in f >>= g, the "end time" is maximal such that ...
21:29:23 <rwbarton> now the way to finish that sentence looks really odd
21:29:43 <kallisti> the ends will be here, eventually. maybe.
21:29:47 <kallisti> s/ends/end times/
21:29:47 <rwbarton> since it involves evaluating f and g at different times
21:30:00 * ski . o O ( coends )
21:30:32 <shapr> kallisti: Er, which edition of the Principia Discordia is your favorite?
21:31:01 <kallisti> shapr: the ONe True Edition. obviously.
21:31:29 <shapr> So, what's your One True Edition?
21:31:45 <kallisti> first edition, no doubt.
21:32:00 <shapr> I thought the mimeographs had faded long ago?
21:32:26 <kallisti> unpossible.
21:33:01 <kallisti> it's the edition I consult every day.
21:33:10 <kallisti> (in my pineal gland, obviously)
21:33:25 <shapr> Ah, I was hoping you had one of the original mimeographs of the Pricipia from the late 1960s.
21:34:47 <kallisti> shapr: I stole the first edition copy from the National Archives. but don't tell anyone.
21:35:23 <shapr> Did yours have LSD on the square?
21:35:56 <kallisti> I doubt it. though now everything makes way more sense if that were true...
21:36:32 <rwbarton> it's interesting how often the way to prove that (x * y) * z = x * (y * z) is to write down x * y * z independently and verify that both sides are equal to it
21:37:12 <rwbarton> and usually that last bit is fairly mechanical
21:37:52 <rwbarton> for example, if you want to prove products in a category are associative
21:38:47 <cl1> mm_freak, Control.Exception is only for the IO monad, correct?
21:39:10 <mm_freak> cl1: correct
21:39:29 <cl1> so I cannot catch errors thrown by the error function?
21:39:34 <mm_freak> cl1: for a generalized exception interface, where IO is at the base, see the monad-control and lifted-base packages
21:39:43 <mm_freak> if you just want a type class for error monads, see mtl
21:39:52 <mm_freak> yes, you can
21:39:59 <mm_freak> 'error' just calls 'throw'
21:40:08 <cl1> mm_freak, that's good enough for me
21:40:28 <cl1> it would be bad if there was no way to prevent a program crash
21:40:37 <Cale> rwbarton: Yeah, often the way that you show two things are equal is showing that they're both equal to a third thing.
21:41:08 <rwbarton> true
21:41:43 <mm_freak> cl1: well, you may want to use Maybe or Either String instead of 'error'
21:42:02 <mm_freak> then you can catch errors without IO
21:45:21 <blackdog> what's the invocation to stop cabal-compiled code complaining about the RTS not supporting multiple OS threads? I've included "-threaded" in ghc-options, to no particular effect
21:45:54 <blackdog> ... and i didn't cabal clean. idiot. sorry.
21:51:15 <cl1> mm_freak, i don't plan on using error, but functions like head do. I need to be able to catch those and recover from them in some way
21:51:37 <blarchen> Why is ghc spitting out a bunch of "match_co baling out" when I compile my program?
21:51:50 <kallisti> cl1: are you sure you can't avoid using functions like head?
21:51:51 <blarchen> It happened after I added a trace statement
21:52:31 <cl1> a robust system is fault tolerant. to err is human, and the system needs to account for that
21:52:52 <kallisti> cl1: I mean typically if you're using head in a situation where the list can be empty, you shouldn't be using head
21:53:02 <kallisti> and instead use a pattern match, or other function.
21:53:08 <mm_freak> cl1: a robust system in a language like haskell is statically fault-tolerant, which is easy to do by using pattern matching instead of 'head'
21:53:31 <mm_freak> and in this context with "fault-tolerant" i mean:  fault's can't happen
21:54:49 <mrcarrot> does anyone have a good suggestion of a library for making CLI gui. something like curses...
21:54:55 <kallisti> cl1: it's rare that I've seen Haskell code attempt to catch an error from a partial function such as head. I think I could safely that it's bad practice to do so.
21:55:08 <mrcarrot> s/gui/ui/
21:55:27 <kallisti> s/safely/safely say/
21:55:48 <cl1> kallisti, I have seen lots of jr programmers do things that are bad practice
21:56:52 <cl1> i need to protect the system from those bad programmers. It needs to expect there to be stuff like that in it, and have a method of recovery.
21:58:36 <kallisti> jr programmers?
21:58:57 * ski read it as "jre programmers"
21:59:03 <cl1> junior programmers, as opposed to senior programmers
21:59:15 <cl1> n00bs
21:59:17 <kallisti> cl1: are you writing a system that executes arbitrary Haskell code?
21:59:24 <kallisti> or are you aware of every library in use?
21:59:31 <kallisti> at runtime.
21:59:41 <kallisti> er at compile-time rather
22:00:50 <cl1> at compile time, yes. also I would need to handle bad input from some outside source. I believe that Control.Exception or something simiiar would work for those cases, in case a data check was forgotten
22:01:11 <kallisti> yes bad inputs can be handled with exceptions.
22:01:25 <kallisti> but, unless you're executing arbitrary haskell code at runtime, I see no reason to catch an error from a call to head.
22:01:50 <cl1> kallisti, i'm asking about exception handling because I write large distributed systems. I'm going off of previous knowledge unrelated to haskell
22:02:30 <mm_freak> mrcarrot: try vty-ui
22:02:48 <cl1> simply stated, programmers make mistakes and the system needs to be able to recover from those, be it an incorrect use of head or someone forgetting to check external data from outside the system
22:03:21 <kallisti> cl1: just be aware that try-catch style exception handling is not as common in Haskell programs as it is in other languages, and that other exception/error handling techniques are used.
22:03:26 <mm_freak> cl1: in haskell you can write your programs in such a way that you cover the mistakes which you would cover at runtime at compile time
22:03:42 <cl1> kallisti, i would expect so
22:03:54 <mm_freak> cl1: hence if you still get an error, your specification was wrong, and you wouldn't have catched that error at run-time either
22:04:23 <blackdog> cl1: i think this is one of the motivations behind the SafeHaskell project
22:04:29 <blackdog> http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell
22:04:41 <mm_freak> cl1: try/catch is for errors, which are run-time- and usually system-specific
22:04:53 <kallisti> mm_freak: not true.
22:05:03 <kallisti> try/catch is used for exceptions as well as errors.
22:05:18 <mm_freak> kallisti: yes, but they are run-time exceptions/errors
22:05:21 <mm_freak> that's the point
22:05:41 <mm_freak> as long as you can make static guarantees (with reasonable effort), you should
22:05:55 <blarchen> overlapping instances doesn't work if your class has a type function?
22:11:21 <augur_> does anyone know of a way of handling "possibly-false preconditions" or something like that?
22:11:43 <blarchen> augur_: Maybe?
22:12:03 <mm_freak> augur: example?
22:12:51 <augur> mm_freak: well, i dont have anything in particular in mind, im just thinking about situations where you want to do something roughly like hoare logic, but where the preconditions might be false
22:14:18 <mm_freak> augur: sounds like you want functions with a rank-2 type
22:14:48 <mm_freak> augur: but since you're an agda user you would probably have guessed that yourself, so i'm still asking for an example =)
22:15:30 <blarchen> why does ghc keep saying "match_co baling out"
22:15:35 <blarchen> shouldn't it be bailing?
22:15:40 <blarchen> and what's it even mean?
22:16:37 <hughfdjackson> yay, one installation of ghc 6.8 later, and i finally compiled a hello world prog :|
22:16:49 <mm_freak> hughfdjackson: debian?
22:16:51 <hughfdjackson> serves me right for not upgrading
22:16:59 <hughfdjackson> osx 10.5
22:17:04 <mm_freak> ok =)
22:17:12 <mm_freak> because GHC 6.8 is very outdated
22:17:38 <hughfdjackson> i'd guessed =/
22:17:44 <hughfdjackson> am i missing language features?
22:18:07 <hughfdjackson> that is.. any that i'm likely to use with the first month or so of haskelling
22:18:09 <augur> mm_freak: to be honest, i have no example i can give you since my primary ones are from natural language semantics not PLT
22:18:10 <augur> but
22:18:13 <mm_freak> hughfdjackson: probably, but you're also missing base library features…  on OSX i'd suggest getting the haskell platform
22:18:41 <hughfdjackson> :| i seriously did not know about that
22:19:07 <hughfdjackson> when was 6.8 released?
22:19:23 <hughfdjackson> the latest 10.5 supporting platform release was july of 2010
22:19:34 <hughfdjackson> so i might be as current as it currently
22:20:07 <mm_freak> not sure about OSX
22:20:30 <hughfdjackson> ^^ okay
22:20:35 * hughfdjackson googles
22:21:00 <hughfdjackson> oh, 2007
22:21:07 <mm_freak> augur: suppose you have a statically length-checked list type…  would "if the list is non-empty, return just the first element, otherwise return nothing" be a good example, where the list comes from IO?
22:21:41 <augur> mm_freak: honestly im not even sure what a good computational example would be. thats partly why i was asking
22:21:57 <cl1> hughfdjackson, did you get it from here? http://hackage.haskell.org/platform/
22:22:30 <hughfdjackson> cl1: i got what i currently have installed from here: http://www.haskell.org/ghc/download_ghc_682#macosxintel
22:22:53 <hughfdjackson> it's compiling, so at least i can get on with the tutorial :D
22:23:08 <mm_freak> augur: as far as i understand hoare logic, "non-empty list" is the precondition and "Just the first element" is the postcondition
22:23:45 <mm_freak> and i understand "state" in this case as the result of getting the first element from a list
22:24:29 <cl1> hughfdjackson, go there, click on the mac icon and download HP 2010.2.0.0. It says that Xcode should be installed. Its all there on the site what to do
22:24:47 <augur> mm_freak: the best sort of example i can think of is things like... you might have some word in english that presupposes some proposition P to be true, and its use then brings that proposition into the truth condition of the statement, but P might be false, and if P is false, P is not brought into the statements truth conditions
22:24:58 <hughfdjackson> cl1: if i have a functioning installation of 6.8, is there any benefit in doing so?
22:25:04 * hughfdjackson feels like he's missing a trick here :P
22:25:22 <augur> but its not known prior to evaluation-of-truth whether or not P is true
22:25:38 <mm_freak> augur: not a NLP expert here, so i'm trying to port this to a problem i understand better
22:26:04 <augur> yeah :)
22:26:09 <mm_freak> yeah, in this case you have a statically length-checked list, but the length will not be known before run-time
22:26:10 <cl1> hughfdjackson, i dunno. but it is recommended to get the compiler and ghci from that site by the compiler writers
22:26:21 <ddarius> My favorite is when people start trying to translate concepts they don't understand into other concepts they don't understand.
22:26:28 <hughfdjackson> okay :)
22:26:32 <hughfdjackson> i'll sort that out in a bit
22:26:33 <hughfdjackson> cheers
22:26:36 <blackdog> ddarius: my monads, let me tell you about them
22:26:50 <ddarius> blackdog: Monad -> continuations is a common version of this.
22:26:58 <blarchen> ddarius: but my chinese room is so comfy
22:27:00 <cl1> :P
22:27:14 <augur> ddarius: hey, stop revealing my methods
22:28:00 <blarchen> Besides, that's basically what math is for at least 90% of undergrads
22:30:14 <mm_freak> augur: to get back to your question, doesn't this involve expressing what "state" means in the first place?
22:30:58 <augur> mm_freak: honestly im not sure. i dont know how to translate this into computational terms, hence why i was asking :)
22:31:31 <mm_freak> well, you could pick the traditional approach to state, a state monad =)
22:31:44 <augur> i imagine it could be modeled in terms of some sort of partial ordering of some sort..
22:32:03 <augur> where the elements at the top are "more true"
22:32:24 <augur> and presupposition failure just removes the elements where the proposition is false
22:33:23 <blarchen> 0_o now my ghc failed with "undefined symbols" after I made some minor changes to a file. I am not using any FFI libraries
22:33:36 <mm_freak> blarchen: are you using cabal?
22:33:39 <blarchen> yes
22:33:46 <mm_freak> have you mentioned all modules?
22:33:54 <blarchen> mentioned?
22:34:18 <mm_freak> in Other-modules (executable) or Exposed-modules/Other-modules (library)
22:34:27 <blarchen> I haven't used those
22:34:33 <byorgey> blarchen: what exact error did you get?
22:35:05 <mm_freak> blarchen: at least with a library, when you fail to tell cabal about all your modules, you will get linker errors
22:35:20 <mm_freak> executables usually work, though
22:35:55 <xbayrockx> why are there so many users in here? i thought haskell wasnt very popular
22:36:15 <hughfdjackson> xbayrockx: :p
22:36:39 <byorgey> xbayrockx: it isn't.
22:36:57 <blarchen> longVersionOfMyFunctionName1_closure referenced from _Main_main1_srt in Main.o, longVersionOfMyFunctionName1_info referenced from _s4dT_info in Main.o
22:37:06 <xbayrockx> then why are there so many users in here
22:37:21 <byorgey> xbayrockx: they are all trolls.
22:37:44 <hughfdjackson> btw, who is using haskell commercially
22:37:44 <blarchen> it says those are the undefined symbols, where longVersionOfMyFunctionName is a bunch of gibberish constructed from a module, class, and function name
22:37:45 <hughfdjackson> ?
22:37:46 <mm_freak> blarchen: yes, sounds like you failed to mention some of your modules
22:37:54 <hughfdjackson> just out of interest
22:38:04 <mm_freak> hughfdjackson: i use it commercially
22:38:08 <blarchen> mm_freak: I have never done that before and my code was compiling just fine until I changed the code of that function
22:38:14 <hughfdjackson> ^^ goodo!
22:38:18 <byorgey> blarchen: are you making a cabal package?
22:38:29 <blarchen> an executable
22:38:31 <hughfdjackson> i was more thinking of public facing projects than people
22:38:35 <augur> byorgey!
22:38:35 <hughfdjackson>  or companies
22:38:36 <augur> :D
22:38:53 <byorgey> blarchen: I mean do you have a .cabal file?
22:38:58 <hughfdjackson> i mean.. google uses python java and c++ (i think that's their main stack)
22:39:13 <blarchen> byorgey: yeah
22:39:18 <hughfdjackson> :P i'm just rambling now
22:39:23 <blarchen> wow... I can fix it by changing a line of pure haskell code
22:39:34 <blarchen> a very minor change at that
22:39:42 <blarchen> I think this is a compiler bug
22:39:42 <byorgey> hi augur
22:39:54 <mm_freak> blarchen: list all of your executable's modules in "Other-modules" for it
22:40:07 <mm_freak> Other-modules:  MyApp.Module1 MyApp.Module2
22:41:35 <mm_freak> a good indicator of when this is the cause is when your program compiles with ghc --make, but not with cabal build
22:41:54 <blarchen> mm_freak: done, didn't help
22:42:03 <blarchen> mm_freak: I even used unix find to make sure I got them all
22:42:16 <mm_freak> strange
22:42:24 <blarchen> I can fix it by changing a single line of pure haskell code in my file
22:42:43 <mm_freak> what was the difference?
22:43:15 <byorgey> blarchen: also, what version of GHC do you have?
22:43:42 <blarchen> "prettyShowWrap = prettyShowImpl (ShowState True Nothing)" => "prettyShowWrap = prettyShow"
22:43:52 <mm_freak> and finally:  have you cabal-installed a library from local source code?
22:44:06 <blarchen> mm_freak: I don't think so
22:44:18 <blarchen> byorgey: 7.2.1
22:45:13 <blarchen> why don't I see if I can extract this code from my project and make it simpler while preserving the bug
22:46:43 <mm_freak> blarchen: have you tried with ghc --make?
22:49:27 <mm_freak> if it compiles with ghc $flags_from_cabal_file --make, then it may be a cabal bug or your failure to write a correct .cabal file
22:52:20 <blarchen> uh that fails because it says Control.Monad.State was found in mtl and monads-tf
22:52:45 <mm_freak> augur: i have thought about your question again, and i think it boils down to expressing the conditions themselves…  if conditions are simple enough to be expressed by contexts, then you can at least express the precondition and in some cases also the postcondition
22:53:44 <mm_freak> i can even see a concrete way to do it for particular examples, but i see no mechanic way to translate hoare logic in general
22:54:20 <augur> mm_freak: its not just, tho, right, because if the preconditions are false, it should be fine
22:54:30 <augur> i mean, this is in the domain of a truth theory not a computational theory so..
22:54:38 <blarchen> ugh this bug goes away if I change minor things in almost any file
22:54:38 <mm_freak> blarchen: use ghc -hide-package
22:55:01 <augur> but in the truth theory, the failure of a presupposition doesnt yield falsity, just a different satisfaction condition
22:56:24 <mm_freak> augur: well, let's take {x' = n} x <- x' + 1 {x = n + 1}
22:56:38 <mm_freak> i guess you could do that with a numeric type, which encodes the number both on value and type level
22:57:05 <augur> again, im not sure i can translate this into actual computtional terms
22:57:35 <mm_freak> i'll try
22:58:20 <augur> a better example is more like   { P, male(x) } him { Q }   or something like that, where the use of "him" presupposes that the referent is male
22:58:47 <augur> but if it turns out that the reference is female (and so "him" was the wrong word to use), no worries, just adjust your model of the world accordingly
23:02:13 <augur> mm_freak: or things like   { P, exists a unique x. whatever } the { Q }   where using the word "the" presupposes the existences of a unique satisfier
23:02:45 <augur> but it doesnt simply lead to falsity if there are multiple satisfiers, it leads to weirdness
23:02:57 <augur> so "the dog is barking" isnt false if there are five dogs
23:03:04 <augur> it just leads to the question "which dog?"
23:03:44 <blarchen> mm_freak: Well I deleted my dist directory and the bug went away
23:03:48 <blarchen> thanks
23:04:05 <blarchen> I'm pretty sure it's a bug but I don't know if it's ghc's fault or cabal's fault
23:04:11 <augur> you know? so its not an entailment, its not part of the meaning of the sentence that there is a unique dog, its part of the preconditions for the sentence being true-or-false in the first place
23:04:21 <augur> and if it fails as a precondition, thats ok
23:04:23 <blarchen> now I just wish I knew what "match_co baling out" meant
23:04:43 <blarchen> I'll try to remember to cabal clean next time I encounter this sort of thing
23:05:13 <ski> (talking about presuppositions ?)
23:06:12 <augur> ski: yes :)
23:06:48 <rwbarton> huh, it's "bale out" in British English?
23:07:26 <augur> ski: i was curious if theres any existing type widgetry that makes sense for presupposition-like things
23:07:43 * ski . o O ( `Gamma |- A : Prop' and `Gamma , A true |- B : Prop' implies `Gamma |- A /\ B : Prop' )
23:08:00 * ski . o O ( `Gamma |- A : Prop' and `Gamma , A true |- B : Prop' implies `Gamma |- A -> B : Prop' )
23:08:06 <blarchen> rwbarton: I don't think so. bale is a different word.
23:08:12 <blarchen> rwbarton: I think that's just a typo
23:08:20 <augur> ski: im not entirely sure thats quite right, but
23:08:26 <mm_freak> augur: is it correct to assume that the program state is the set of true statements gained by context?
23:08:26 <blarchen> rwbarton: what I'm wondering is why ghc is spitting it out 20 times
23:08:37 <rwbarton> blarchen: I assumed it was a typo at first also but the internet tells me it might not be.
23:08:38 <augur> mm_freak: im not sure what you mean
23:08:56 <blarchen> rwbarton: oh
23:09:32 <mm_freak> augur: i'm currently trying to translate hoare logic to haskell, and for your particular example it seems to me like the program state is a set of established truths
23:09:54 <mm_freak> {} it's raining {weather = "raining"}
23:10:33 <ski> augur : the point is to be able to express things like `forall x : |R. (x =/= 0 => Foo(1/x))', where `1/x' presupposes that `x' is not zero
23:11:20 * ski . o O ( `Gamma |- A : Prop' and `Gamma , A false |- B : Prop' implies `Gamma |- A \/ B : Prop' )
23:12:08 <ski> in the `A /\ B' case above, this corresponds nicely to tests like `x /= 0 && foo (div y x)'
23:12:23 <augur> ski: right, but presuppositions in natural language are even looser than that -- they can be false and the meaning of the rest shifts to accomodate
23:13:22 <rwbarton> ski: GADT pattern matching type refinement has a similar sort of flavor
23:13:58 <rwbarton> once I match on some data, then it becomes well-formed to talk about something else
23:14:06 <blarchen> the "baling" things went away after I removed my trace statement. Maybe the impurity is breaking something
23:14:36 <rwbarton> that's analogous to the `Gamma , A true |- B : Prop' part, I suppose
23:16:15 <ski> rwbarton : hm, there might be an analogue here, yes -- i'm not seeing this clearly, though
23:20:14 <augur> ok im off for a bit
23:20:14 <augur> ciao
23:21:00 <ski> augur : my incomplete understanding of presuppositions is that they are required to be true for the term/proposition to be meaningful
23:21:37 <ski> if they are false, the term/proposition is neither true nor false, it's simply not meaningful (not well-formed, in a strict sense)
23:22:29 <augur> ski: not quite. basically theyre required to be true for the proposition to be easily meaningful, but presupposition failure often just means that more information is required for the thing to be fully meaningful
23:22:33 <augur> the "the" example, for instance
23:22:40 <ski> however, if there's no explicit thing which makes the presupposition true (in the context of the term/proposition), then one usually infers such an introducer, in some way
23:22:55 <augur> where the uniqueness presupposition fails, but the expression still is meaningful modulo the uniqueness part
23:23:06 <augur> anyway, im off :P
23:23:43 <ski> "presupposition failure often just means that more information is required for the thing to be fully meaningful" isn't incompatible with "if they are false, the term/proposition is neither true nor false, it's simply not meaningful (not well-formed, in a strict sense)", imo :)
23:24:14 <ski> (cf. with a scientific theory which has been refuted. usually one tries to patch it up a bit, rather than starting over from scratch)
23:25:48 <blarchen> So it's kind of like logic? if an interpretation is contradictory, that doesn't mean the formula is unsatisfiable?
23:27:23 <ski> blarchen : well, consider a formula `/\ /\ not A'
23:27:43 <ski> this is not a well-formed formula, so there is no interpretation of this, in a given model
23:28:32 <ski> above i meant that `1/x' would in a somewhat similar (but more complicated) way not be well-formed, unless we already know (in the given context) that `x' is not zero
23:29:43 <ski> of course, from some view-point, it's strange to interleave the concept of truth (or provability) into the concept of being well-formed
