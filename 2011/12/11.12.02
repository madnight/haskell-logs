00:11:36 * hackagebot regex-genex 0.3.2 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.3.2 (AudreyTang)
00:41:54 <erus`> interdasting
00:45:16 <mlb-> I've read through learnyouahaskell and played around with some simple programs - is there any good set of educational examples/idioms/programs to look through?
00:46:00 <Jafet> @quote autodidact
00:46:00 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized they have to learn it for themselves.
00:46:56 <mlb-> well, besides the good old head-to-brick-wall style of learning :P
00:52:22 <byorgey> mlb-: that's a common question, but not really. My best suggestion would be to find some interesting packages on Hackage and read their source code.
00:52:41 <byorgey> mlb-: if you tell me what sort of things you might be interested I might be able to recommend some packages to look at.
00:57:09 <mlb-> byorgey: hmm, what are the most notable strengths of Haskell? Or common idioms that reveal something interesting about the language?
00:58:55 <Axman6> mlb-: monads are pretty sweet. basically a programmable semicolon
00:59:21 <applicative> mlb- what sort of thing are you interested in?
00:59:34 <mlb-> semicolon in what sense?
01:00:50 <byorgey> mlb-: higher-order/first-class functions, laziness, type classes
01:00:51 <applicative> the semicolon metaphor is excellent, but a little opaque
01:02:31 <applicative> '>>=' is a semicolon in a space suit.
01:03:18 <Axman6> mlb-: well, the same imperative looking syntax can do very different things, depending on what monad you're using
01:03:48 <mlb-> applicative: haha, that's beginning to sound a little abstract there,
01:04:11 <mlb-> Axman6: that almost sounds like lisp-style macros
01:04:11 <engla_> I wonder if "programmable magic between the lines" is anyless helpful
01:04:17 <Axman6> the way the IO monad works is very different from how the list monad works, but you can use the same syntax for both
01:04:18 <applicative> mlb-: I was just being silly, alluding to other less rational monad analogies that are abroad
01:04:24 <Jafet> What about Applicative? Applicative is awesome.
01:04:46 <Axman6> Applicative gives you some awesome stuff too
01:05:59 <Axman6> mlb-: so, what are you interested in? you can do pretty much anything in haskell, and we can better show you cool stuff if we know what you like and want to write
01:06:46 <mlb-> I've got an idea of what these things are (functors, monads, lazy eval), but it hasn't quite hit me with what the consequences are
01:08:31 <byorgey> mlb-: yeah, that takes a while, no worries
01:09:46 <applicative> mlb-: they are just means of expression, not particular programming devices like say regular expressions or arrays or something, so the question 'whats the good of them' will get an unpleasantly abstract answer
01:09:59 <Axman6> mlb-: head on over to project euler and try and code some things up. feel free to then come here and ask how we'd improve your code
01:15:08 <Jafet> Ignore project euler and write code which actually does something relevant
01:15:14 <mlb-> hmm, that's a good idea, I'll be back in a while then. I've forgotten about PE
01:16:03 <quicksilver> project euler is interesting *if* you are interested in mathematics and number theory
01:16:13 <quicksilver> it might even teach you somethign about number theory
01:16:28 <quicksilver> in my opinion it won't teach you very much program
01:16:30 <quicksilver> ming.
01:18:09 <mlb-> any alternative suggestions for punching bags then?
01:18:23 <Cale> If you're interested in mathematics and number theory, but not programming, then you'll find Project Euler to be boring though.
01:18:34 <Cale> (probably)
01:18:45 * applicative hadn't thought of counting the number of '0's in the decimal expansion of square numbers as especially number-theoretic
01:19:01 <Cale> Yeah, it's mostly recreational math stuff
01:19:32 <quicksilver> OK, it's not interesting to anyone then :)
01:19:45 <quicksilver> it's not interesting to programmers *or* number theory types. What a waste of bytes it is.
01:20:07 <Jafet> It's a great site if you're hiring computational number theorists and you need interview questions
01:20:21 <Jafet> If you're not, it's just taking Euler's name in vain
01:20:25 <Cale> I think it has somewhat interesting programming problems.
01:20:37 <Cale> I'm not sure why you think it doesn't :P
01:20:48 <Axman6> quicksilver: taught me plenty of new algorithms, and optimisations for haskell
01:21:17 <Axman6> mlb-: PE is fine, ignore the maths elitists :P
01:21:37 * hackagebot bson-mapping 0.1.3 - Mapping between BSON and algebraic data types.  http://hackage.haskell.org/package/bson-mapping-0.1.3 (FrancescoMazzoli)
01:21:55 <mlb-> As long as I don't have to go dig out my number theory text from college, I don't think it could hurt any
01:21:57 <Cale> But they're not really interesting mathematically. I mean, the answer to every one of them is just a number, which doesn't say much at all. You don't necessarily prove anything apart from the proof which is encoded by the program you'll have pretty much had to write to get it.
01:22:12 <quicksilver> Cale: well, I think that the key part of the soluations involve devising mathematical approaches to solve the problem efficiently
01:22:35 <quicksilver> Cale: the actual programming part is trivial and I didn't find it exercised my haskell knowledge at all
01:22:39 <mlb-> Because I poorly recall the Chinese Remainder Theorem, let alone RSA encryption
01:22:41 <quicksilver> maybe it got interesting after I got bored
01:22:42 <applicative> Euler is the nick of the guy who started it, I don't see why that wasn't a reasonable nick for him
01:28:43 <mlb-> hmmm, would the >> operator in a do context be often used for side effects?
01:28:58 <Jafet> What's a side effect?
01:29:15 <Cale> mlb-: >> itself doesn't have any side effects. It takes two actions and glues them together in a particular way.
01:29:34 <applicative> it doesn't requre a do context, but with IO , a >> b means, do a, then do b
01:29:59 <mlb-> oh wait, it wouldn't be in a do context, it'd be just on its own line?
01:30:06 <mlb-> Jafet: say, IO?
01:30:18 <Jafet> do-notation isn't limited to IO.
01:30:37 <mlb-> I assume this as the return value isn't being bound to anything
01:30:56 <applicative> > [1,2,3] >> "hello"
01:30:57 <lambdabot>   "hellohellohello"
01:31:11 <mlb-> huh
01:31:38 * hackagebot monad-control 0.3 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3 (BasVanDijk)
01:31:40 * hackagebot lifted-base 0.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.1 (BasVanDijk)
01:31:42 <mlb-> > replicate 3 3 >> "hello?"
01:31:43 <lambdabot>   "hello?hello?hello?"
01:31:57 <Axman6> > "abc" >> "xyz"
01:31:59 <lambdabot>   "xyzxyzxyz"
01:32:01 <applicative> > [1,2,3] >>= \n -> take n "hello"
01:32:03 <lambdabot>   "hhehel"
01:32:20 <Axman6> > "abc" >>= \x -> "xyz" >> [x]
01:32:22 <lambdabot>   "aaabbbccc"
01:32:26 <Cale> > Nothing >> Just 6
01:32:28 <lambdabot>   Nothing
01:32:32 <Cale> > Just 1 >> Just 6
01:32:34 <lambdabot>   Just 6
01:32:49 <Cale> (not a common usage of >>, but a valid one nonetheless)
01:33:04 <Cale> Actually, it's not *that* uncommon with guard specifically.
01:33:10 <Axman6> yeah
01:35:35 <Cale> > map (\x -> guard (even x) >> Just (x `div` 2)) [1..10]
01:35:37 <lambdabot>   [Nothing,Just 1,Nothing,Just 2,Nothing,Just 3,Nothing,Just 4,Nothing,Just 5]
01:35:47 <mlb-> Axman6: would you mind explaining that last example?
01:36:11 <mlb-> oh, wait, I got it
01:36:36 <Axman6> mlb-: it basically says: for each letter in "abc", bind it to x, and then for each letter in "xyz", return a list with x in it.
01:37:23 <mlb-> yeah, "xyz" could be any array of length 3?
01:38:26 <applicative> >   "abc" >>= \x -> [1,2,3] >> [x]
01:38:27 <lambdabot>   "aaabbbccc"
01:38:28 <Axman6> mlb-: the list monad is sometimes refered to the non-determinism monad. it represents computations that don't return a single answer, but many. so if we chain a bunch of those computations together, by feeding all the results from a computation into the next, getting all its results, and flattening it, we end up with a computation that gives you all possible reaults
01:38:55 <mlb-> that sounds like list comprehension to me
01:38:56 * Axman6 waits for Cale to correct him, so he can head off, knowing Cale will take over with a more correct definition
01:39:08 <applicative> >> forgets what triggered its use, so to speak; unlike `>>=`
01:39:15 <Axman6> mlb-: well, there's a reason list comprehension syntax is very similar to do notation
01:39:20 <Jafet> @src (>>)
01:39:20 <lambdabot> m >> k      = m >>= \_ -> k
01:39:35 <Axman6> > [x | x <- "abc", _ <- "xyz"]
01:39:37 <lambdabot>   "aaabbbccc"
01:39:56 * Axman6 -> out
01:42:44 <mlb-> huh, I wouldn't've thought to use a _ in a list comprehension like that
01:43:38 <Jafet> > let _ a = a in ()
01:43:40 <lambdabot>   <no location info>: Parse error in pattern
01:44:27 <applicative> > [x | x <- "abc", arthur <- "xyz"]
01:44:28 <lambdabot>   "aaabbbccc"
01:44:39 <c_wraith> > let _f a = a in ()
01:44:39 <lambdabot>   ()
01:44:43 <c_wraith> hmm.
01:45:45 <Jafet> > let __ __ = __ in ()
01:45:46 <lambdabot>   ()
01:46:03 <Jafet> This looks like something out of a game show
01:55:34 <vrook> What is the best way to do this? map2 f xs ys = map (\p -> let (x, y) = p in f x y) (zip xs ys)
01:56:05 <vrook> is there a haskell version of (mapcar f xs ys) ?
01:56:52 <vrook> and what about (mapcar f xs ys zs) etc?
01:58:18 <Jafet> :t uncurry
01:58:19 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
01:58:55 <Jafet> \(x,y) -> f x y is uncurry f
01:59:14 <Jafet> :t zipWith3
01:59:15 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
01:59:28 <Jafet> :t zipWith6
01:59:30 <lambdabot> forall a b c d e f g. (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
01:59:43 <Jafet> How deep is this burrow
01:59:49 <Jafet> :t zipWith7
01:59:50 <lambdabot> forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
01:59:56 <Jafet> :t zipWith10
01:59:57 <lambdabot> Not in scope: `zipWith10'
02:00:35 <vrook> I was afraid of that. How do people do zipWithN ?
02:00:53 <Jafet> They use Applicative
02:01:38 <vrook> k thanks
02:04:50 <wereHamster> does an underscore have a special meaning (\_ <- etc)?
02:05:11 <quicksilver> yes, it means we are ignoring that parameter
02:05:22 <quicksilver> it's not very different from giving it a name and just not using that name
02:05:28 <quicksilver> but it doesn't waste a name and avoids a warning
02:06:14 <wereHamster> > [x ++ _ | x <- "abc", _ <- "xyz"]
02:06:15 <lambdabot>   Pattern syntax in expression context: _
02:06:31 <quicksilver> it menas you are ignoring it.
02:06:34 <quicksilver> you can't use it.
02:07:39 <wereHamster> it wouldn't have worked anyway even if I gave it a proper name :)
02:08:31 <quicksilver> that's also true :)
02:15:30 <wereHamster> > concat [x:y:[] | x <- "abc", y <- "xyz"] -- a better way to do that?
02:15:33 <lambdabot>   "axayazbxbybzcxcycz"
02:16:30 <quicksilver> > [w | x <- "abc", y <- "xyz", w <- [x,y]]
02:16:31 <lambdabot>   "axayazbxbybzcxcycz"
02:16:46 <quicksilver> not sure that's better :)
02:17:19 <alistra> > [ w | x <- [w | x <- "abc", y <- "xyz", w <- [x,y]]
02:17:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:17:46 <alistra> > [ w | x <- [w | x <- "abc", y <- "xyz", w <- [x,y]], y <-  concat [x:y:[] | x <- "abc", y <- "xyz"], w <- [x,y]]
02:17:48 <lambdabot>   "aaaxaaayaaazabaxabayabazacaxacayacazxaxxxaxyxaxzxbxxxbxyxbxzxcxxxcxyxcxzaa...
02:17:53 <wereHamster> hm, why doesn't yours need a concat and mine does?
02:19:29 <quicksilver> wereHamster: well, because list comps do concats automatically
02:19:36 <alistra> it's concatMap
02:19:47 <alistra>  = (>>=)
02:22:49 <wereHamster> I mean, I don't see the difference between [[x,y] | x <- [1], y <- [2]] and [w | x <- [1], y <- [2], w <- [x,y]].
02:23:15 <wereHamster> both times I'm creating a [x,y] list ..
02:23:52 <wereHamster> but once I use it directly and once I give it an alias (w)
02:25:44 <dweep> hello there, i am newbie and wanted to learn haskell.
02:26:05 <rostayob> @where LYAH
02:26:05 <lambdabot> http://www.learnyouahaskell.com/
02:26:32 <dweep> from where i can get the free study material
02:26:38 * hackagebot tls 0.8.3.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.8.3.1 (VincentHanquez)
02:27:00 <rostayob> dweep: that book i linked is nice
02:27:26 <dweep> thanks, i will download it.
02:27:26 <vrook> here is my generalized zip: superZip xs = foldr (zipWith (:)) empties xs where empties = []:empties
02:29:39 <vrook> superZip [[1,2,3],[4,5,6],[7,8,9]]  => [[1,4,7],[2,5,8],[3,6,9]]
02:30:22 <vrook> plus, superZip is fun to say
02:30:51 <dweep> i am unable to understand this.am i supposed to execute those expressions?
02:34:15 <dweep> from where i can download haskell pdf books
02:34:28 <rostayob> html is not good enough?
02:35:03 <rostayob> two of the best books about haskell are free, learn you a haskell and
02:35:06 <rostayob> @where RWH
02:35:06 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:35:26 <rostayob> dweep: you have to download GHC first, http://hackage.haskell.org/platform/
02:36:25 <dweep> i am not always connected to internet, and i wanted to read the book in my mobile phone
02:37:04 <Jafet> So download them to your mobile phone.
02:37:06 <vrook> ugh, I thought LYAH was awful. The "gentle introduction" was great. www.haskell.org/tutorial/
02:37:39 <Jafet> Some people don't find the gentle introduction gentle.
02:37:43 <rostayob> vrook: i disagree with you, and i think that most people here do
02:37:52 <rostayob> (regarding LYAH being awful)
02:37:54 <Jafet> As I recall, it didn't involve any animals
02:38:35 <wereHamster> I found LYAH better than realworldhaskell
02:38:46 <vrook> that's ok. I just find it frustrating having stuff analogized instead of explained. Like monads being boxes with feet, or something. I want to really know.
02:39:01 <vrook> gentle introduction actually tells you
02:39:21 <mm_freak> what's the preferred way to show an Int/Integer to a ByteString?
02:39:43 <mm_freak> currently i'm using pack . show, which feels ugly
02:40:34 <quicksilver> bytestring-show is probably faster, mm_freak
02:40:53 <rostayob> vrook: examples work well with humans
02:41:51 <quicksilver> people are different.
02:41:59 <quicksilver> different teaching style suit different people.
02:42:03 <vrook> rostayob: examples should be supplemental, not a substitute for the explanation.
02:42:14 <quicksilver> vrook is no less human for preferring a non-example-centric exposition
02:42:22 <rostayob> vrook: well but sometimes examples first are better. but to each one his own
02:42:33 <rostayob> i personally read haskell with "programming in haskell", so...
02:42:37 <rostayob> which is a great book imho
02:42:46 <vrook> It depends on your background, maybe. I am used to reading math books, which is maybe why I found LYAH intolerable.
02:42:59 <vrook> I keep saying "JUST TELL ME WHAT IT IS"
02:43:06 <vrook> *kept
02:43:13 <rostayob> mah, ok. most people love it. i like it a lot as well
02:43:54 <rostayob> *leartn haskell with
02:44:00 <vrook> rostayob: did you first learn haskell with LYAH?
02:44:03 <rostayob> no
02:44:17 <rostayob> as I said, I had "programming in haskell"
02:44:50 <rostayob> you'd probably like that better
02:44:57 <vrook> Well imagine you didn't know what a monad was, and you are told that it's a box with feet. You're just given "do" examples, but you are never told what's happening. I found it frustrating.
02:45:11 <rostayob> but it's for beginners not only in haskell, but in programming
02:45:31 <rostayob> vrook: actually programming in haskell makes you write a parser combinator library, and then tells you "this is a monad"
02:45:46 <vrook> that sounds excellent
02:45:49 <rostayob> and i think graham hutton has been teaching haskell for a while, so in that case he chose to go by example
02:46:22 <rostayob> well but you said you like to be told what something is formally from the beginning
02:46:31 <rostayob> anyway i have to go
02:47:02 <vrook> the gentle introduction starts by showing you the do-to-<<= translation, which was just a tremendous sigh of relief for me.
02:47:38 <rostayob> mah, i don't think that's that useful as a start to help you understand monads, but it's too late, i know what monads are now. i need to run
02:49:10 <danr> is there something similar to Haskell as MPI for C++ (and other languages)
02:49:30 <danr> ah found it on the wiki
02:58:48 <edwardk> danr: we have MPI bindings, not that they get used much
03:04:36 <danr> edwardk: yeah, I found one, I'll try fiddle around with them this weekend
03:04:49 <dever> aye, and you've got the likes of accelerate and dph too
03:30:31 <alexluya> hello,how to use scion-class-browser within eclipse
03:56:45 * hackagebot wai-extra 0.4.5.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.5.2 (MichaelSnoyman)
03:56:47 * hackagebot clash 0.1.3.11 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.3.11 (ChristiaanBaaij)
03:58:08 <fff> hi
04:04:58 <thoughtpolice> ohmygod criterion is so much more awesome now. bos is da man
04:05:07 <thoughtpolice> i was already using blaze-html to output my own little webpage, but no more!
04:05:48 <cheater> thoughtpolice: can you show some example criterion code?
04:06:22 <thoughtpolice> cheater: just a sec
04:06:29 <cheater> thanks geheimdienst
04:07:01 <thoughtpolice> https://github.com/thoughtpolice/salt/blob/master/bench/Bench.hs <- example of code
04:07:11 <thoughtpolice> what my output looks like with my crappy blaze-html script: http://thoughtpolice.github.com/salt/bench/results.html
04:07:20 <thoughtpolice> what criterion now looks like: http://bos.github.com/criterion/
04:08:27 <quicksilver> bos is da boss.
04:08:40 <cheater> like a bos
04:08:41 <thoughtpolice> yep
04:09:29 <cheater> thoughtpolice: blaze html is a html dsl..
04:09:37 <cheater> i don't see any sort of html dsl in that link you posted.
04:10:04 <quicksilver> cheater: thoughtpolice's is point is that, previously, he generated pretty HTML reports for his criterion benchmarks by hand, using blaze
04:10:19 <quicksilver> now he doesn't have to, as bos has integrated shiny html reports.
04:10:32 <cheater> oh nice
04:10:32 <cheater> ok
04:10:34 <cheater> gotcha
04:10:39 <cheater> that sounds pretty good actually.
04:13:10 <Jafet> Using ShinyScript, naturally
04:27:28 <nullzzz> Hi, I'm working on automatic tests for my Snap-based RESTful service. There seems to be a problem running the tests using cabal test (exitcode-stdio-1.0): the tests simply hang. The tester (based on curl library) never gets responses from the Snap server I've forked in the start of the test.
04:27:33 <nullzzz> Any idea on this?
04:28:01 <nullzzz> The tests work just fine with runhaskell
04:28:24 <dcoutts__> nullzzz: are you sure it's hanging? note that you do not get results printed interactively while the program runs
04:28:28 <dcoutts__> it all goes to a log file
04:28:37 <nullzzz> yeah I know that
04:28:50 <nullzzz> when running "cabal test", it never exists
04:29:07 <nullzzz> in the log files I can see that snap was started
04:29:21 <nullzzz> two log files are created each time I start it
04:29:39 <dcoutts__> so you do get some output in the log
04:29:47 <dcoutts__> not just empty log files?
04:30:05 <nullzzz> File 1 looks like this:
04:30:06 <dcoutts__> and some output from your program, not just header info from cabal?
04:30:06 <nullzzz> Test suite tests: RUNNING...
04:30:07 <nullzzz> ^MCases: 2  Tried: 0  Errors: 0  Failures: 0forked
04:30:07 <nullzzz> starting
04:30:07 <nullzzz> Listening on http://0.0.0.0:8001/
04:30:07 <nullzzz> waited, running test
04:30:07 <nullzzz> sending request
04:30:39 <nullzzz> most of the lines above are stuff I print to stderr myself to get a feeling on what happens
04:31:11 <nullzzz> after "sending request" it sends a request using curl, then it should pring "got reply.."
04:31:17 <dcoutts__> nullzzz: have you tried running the complied test program directly
04:31:21 <dcoutts__> not runhaskell
04:31:35 <nullzzz> the "main" program yes, it works
04:32:08 <dcoutts__> well, the test program that is compiled by cabal for that testsuite
04:32:37 <dcoutts__> cabal test just runs that compiled program, redirecting output to the log
04:32:58 <nullzzz> hmm.. what would the "test program" be called..
04:33:09 <dcoutts__> same as the test suite is called
04:33:25 <dcoutts__> you can see when you run cabal build, it says what it is linking
04:34:29 <nullzzz> ok, it seems to hang in a similar way, yes
04:34:37 <nullzzz> "sending request" is the last line I see
04:34:42 <dcoutts__> ok, so my first guess is handle buffering
04:34:51 <dcoutts__> line vs block
04:35:06 <dcoutts__> but you'll have to investigate
04:35:27 <nullzzz> I guess so. I'm a bit clueless at the moment though ;(
04:36:26 <dcoutts__> nullzzz: also, try linking with -threaded
04:36:34 <dcoutts__> your test prog I mean
04:36:45 <dcoutts__> that's another difference vs ghci/runhaskell
04:36:48 * hackagebot transformers-abort 0.4 - A better error monad transformer  http://hackage.haskell.org/package/transformers-abort-0.4 (MikhailVorozhtsov)
04:37:55 <nullzzz> WOW!
04:38:04 <nullzzz> dcoutts__ thanks!
04:38:12 <nullzzz> I owe you a beer.
04:38:39 <nullzzz> Without threaded it probably has only single thread?
04:38:50 <nullzzz> while snap requires multithreading to work
04:39:28 <nullzzz> I wish there were sensible defaults :)
04:39:38 <dcoutts__> nullzzz: are you using create process and waitForProcess in your test?
04:39:56 <nullzzz> not directly, just forkIO and killThread
04:40:10 <nullzzz> I start a Snap server to be run on the background using forkIO
04:40:30 <nullzzz> then after my test, I shut it down using killThread (that was the recommendation in Snap docs)
04:40:40 <quicksilver> withouth -threaded there are still threads
04:40:44 <dcoutts__> hmm, I don't know what's not working then. You could ask the snap developers
04:40:49 <quicksilver> but they are purely GHC-managed software threads
04:41:02 <nullzzz> anyway, -threaded made it work
04:41:03 <quicksilver> maybe snap relies on threaded FFI or something
04:41:18 <nullzzz> I'm planning to make a blog posting on this
04:41:24 <dcoutts__> nullzzz: yeah, it's not that lack of -threaded means no threads, but without -threaded certain FFI operations block all Haskell threads
04:41:36 <dcoutts__> perhaps that's what's happening with calling the curl library
04:41:46 <nullzzz> I feel that test-driven Snap development is pretty much uncovered in the nets
04:42:33 <nullzzz> It didn't get stuck when I experimented directing the curl calls to another instance of my server running in a different process in a different port
04:42:54 <dcoutts__> nullzzz: no, in that case they're in different processes
04:43:54 <dcoutts__> nullzzz: but suppose in one thread you make a call to curl to wait for a response from the snap server, but then the snap server cannot make progress if the curl call blocked all haskell threads in the process.
04:44:10 <xplat> when curl goes out to the network it will block all haskell threads unless you use -threaded or go through some extreme contortions
04:44:18 <nullzzz> dcoutts__ : Yeah, that seems to make sense.
04:45:08 <xplat> because it will normally do its own read or select at the C/syscall level instead of going through the IO manager
04:45:36 <nullzzz> I'm working on "snap-skeleton", that' s a kinda "starter kit" for building RESTful web services in Haskell, using Snap. One of the must-haves for me is a working test suite. The stuffs available at https://github.com/raimohanska/snap-skeleton
04:46:09 <nullzzz> I'll soon include the required modifications for making "cabal test" work.
04:46:36 <xplat> so either use -threaded (can still block if there are too many curls) or do some hacks to get libcurl to cooperate with the runtime or use http-enumerators instead
04:46:44 <shadyp\> odn.se
04:46:48 * hackagebot timeplot 0.3.13 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.13 (EugeneKirpichov)
04:46:51 <nullzzz> I'll go for -threaded
04:47:15 <xplat> okay, so the easiest, but least reliable solution
04:47:27 <nullzzz> why not reliable?
04:47:49 <xplat> because it can still block the whole server if too many curls are going at once
04:48:04 <nullzzz> the curl thing is only used in the test suite
04:48:07 <dcoutts__> nullzzz: if you can, try using the HTTP package
04:48:17 <xplat> each curl blocks an os thread, and the server has only so many threads
04:48:18 <dcoutts__> it's pure Haskell, rather than using curl
04:48:59 <xplat> ah, if it's only used for tests i suppose you can avoid that case easily enough
04:49:09 <quicksilver> xplat: I don't think that's true.
04:49:22 <nullzzz> Pure haskell sounds good to me. I'll definitely check HTTP out
04:49:31 <quicksilver> xplat: GHC will launch as many FFI threads as required
04:50:28 <xplat> quicksilver: oh, even if you don't use forkIO?
04:51:48 * hackagebot monad-abort-fd 0.4 - A better error monad transformer  http://hackage.haskell.org/package/monad-abort-fd-0.4 (MikhailVorozhtsov)
04:52:41 <nullzzz> dcoutts__ et al: thanks a lot for the help! I'm really excited about Haskell the language but a bit set back by the steep learning curve of the available tools.
04:53:04 <quicksilver> xplat: which fork you use isn't relevant.
04:53:45 <dcoutts__> nullzzz: the blocking and threading is a bit subtle
04:54:07 <nullzzz> Yeah, and that's not the only thing :)
04:54:21 <dcoutts__> though with -threaded it's a bit simpler
04:56:47 <nullzzz> I wish there was something for haskell that made it even closely as easy as Scala or Clojure to use for web service development
04:57:02 <nullzzz> that's why I'm building my snap-skeleton...
05:00:58 <hpc> i found a bug in ghc-pkg, which may have already been fixed
05:01:38 <hpc> one of the authors of quickcheck has an umlaut in his name, which causes hGetContents to break when it reads that file
05:01:43 <hpc> which means i can't install anything
05:02:26 <hpc> right now my fix is to replace it with a regular 'o'
05:03:57 <hpc> im using a fairly old ubuntu install, so it could be a known issue and i should just update
05:04:01 <hpc> just letting you all know
05:31:48 * hackagebot bson-mapping 0.1.4 - Mapping between BSON and algebraic data types.  http://hackage.haskell.org/package/bson-mapping-0.1.4 (FrancescoMazzoli)
05:37:42 <nexion> is it expected that hClose on a network socket blocks until the peer does a write or close on his end?
05:37:55 <kallikanzarid> hi all
05:38:04 <kallikanzarid> are there coproducts in Hask?
05:40:30 <hpc> nexion: i think so, yes
05:40:51 <hiptobecubic> Is Data.Binary not the preferred way to handle binary io now?
05:41:49 <nexion> hpc, do you know if there are details on why it's doing this? I haven't seen this behavior anywhere else as it would be fatal in most other languages
05:42:12 <nexion> for a server of course
05:42:20 <hpc> right
05:42:32 <hpc> suppose you tried closing a handle that had timed out
05:42:52 <nexion> it's a live netcat connection
05:43:08 <nexion> then I just have:
05:43:10 <nexion>       putStrLn "Calling hClose..."
05:43:10 <hpc> when you close a handle you stil have to indicate to the other side that you are disconnected
05:43:10 <nexion>       hClose clientSocketHandle
05:43:10 <nexion>       putStrLn "Closed"
05:43:18 <hpc> so closing it would throw an error
05:44:02 <hpc> nexion: if you don't care about errors and whatnot, you can just forkIO $ hClose clientHandle
05:44:30 <nexion> this is my learning project, so I'd like to understand the correct way
05:44:57 <hpc> nexion: this is actually the first time ive ever really thought about what closing a handle entails :P
05:45:13 <nexion> haskell programmers are so lazy
05:45:22 <nexion> the language makes everything too easy
05:45:29 <nexion> this is the only bad thing about it
05:46:30 <nexion> I just realized that hGetLine is being called at the same time as hClose
05:46:35 <nexion> that might be blocking hClose
05:46:36 <sopvop> Haskell programmers just declare what program is already written, and since no-one is using it - it never gets evaluated.
05:46:49 <hpc> heh
05:47:14 <sopvop> that is called declarative lazy programming.
05:48:11 <hpc> nexion: what do you have that requires a non-blocking hClose?
05:48:45 <nullzzz> Hi, is there a workaround to the issue that your main module must be named Main in cabal?
05:49:10 <dcoutts__> nullzzz: make another file foo.hs with its own main = ...
05:49:14 <nexion> it's not so much that blocking is a problem, but that this behavior affects what the client sees
05:49:19 <dcoutts__> nullzzz: Main modules do not need to be called Main.hs
05:49:31 <nullzzz> I know that..
05:49:46 <nullzzz> But, I'd like to be able to import my "executable" Main in my "test" Main
05:49:51 <nullzzz> to be able to run it
05:49:59 <nexion> if they are waiting for data to finish arriving from the server and the socket to be closed to indicate completion, the client needs to see the close
05:50:35 <nullzzz> I could of course make my "main main" a simple delegate to another module that I could import in the "test main" but that's one extra file
05:50:48 <nexion> currently, it waits until data arrives from the client (or possibly the client closing the socket) causing hGetLine to fail
05:51:26 <nexion> I suspect the active call to hGetLine is what's causing the problem, but I can't think of a way to avoid it
05:51:40 <hpc> nexion: you want to check for EOF
05:51:47 <nexion> since there's a thread dedicated to looping on hGetLine
05:51:58 <hpc> once a handle closes, hIsEOF returns True
05:52:00 <nexion> I check for EOF as well as any other error in hGetLine
05:52:18 <nexion> Calling hClose...
05:52:18 <nexion> Closed
05:52:18 <nexion> Main.hs: <socket: 9>: hGetLine: illegal operation (handle is closed)
05:52:35 <nexion> but the issue is between Calling hClose... and Closed
05:52:44 <nexion> it waits for the client to act
05:52:57 <hpc> aha!
05:52:58 <hpc> http://haskell.org/hoogle/?hoogle=hIsOpen
05:52:58 <lars__> @hoogle delay
05:53:00 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
05:53:00 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
05:53:01 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
05:53:24 <hpc> http://haskell.org/hoogle/?hoogle=hWaitForInput -- also might be interesting
05:53:32 <lars__> @hoogle loop
05:53:33 <lambdabot> System.Event loop :: EventManager -> IO ()
05:53:33 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
05:53:33 <lambdabot> package loop-while
05:54:20 <mm_freak> lars__: are you looking for the "arrows" library?
05:54:29 <lars__> can anyone show me how to generate [1,2,3..] using arrows?
05:54:35 <mm_freak> it's not part of the base library and provides the ArrowCircuit class with the "delay" function
05:54:59 <mm_freak> lars__: what kind of an arrow?
05:55:23 <lars__> mm_freak: ArrowLoop i guess?
05:55:44 <mm_freak> lars__: doesn't make much sense to me
05:55:49 <mm_freak> ArrowLoop is a class, not an arrow
05:57:06 <mm_freak> rewriting your question to, "how can i generate the sequence 1, 2, 3 using an arrow?", using an automaton arrow you would write:  countFrom n = Auto $ \x -> (n, countFrom (succ n))
06:00:27 <lars__> mm_freak: thanks, arrows look interesting to me, but i never found a use case for it
06:02:38 <mm_freak> lars__: look at AFRP
06:02:47 <mzero> i just wrote my first Arrow last week (after two + years of Haskell programming!)
06:03:11 <mzero> I used it to create a 'find' (posix command) like combinator
06:04:33 <lars__> mzero: why find is a combinator? the -exec part?
06:04:57 <mzero> Haskell uninstaller about line 130. -- https://bitbucket.org/mtnviewmark/haskell-playground/src/77b8ada5104f/systools/Uninstall.hs
06:05:53 <lars__> mm_freak: i read some articles about afrp and gui programming, but didn't see its advantage...
06:06:00 <mzero> because each step in the depth search takes in a (a,FilePath) and returns [(b,FilePath)]  --- so Find a b   is the type that extends a find by some search operation, transforming the information about each FilePath from a to b
06:06:05 <mm_freak> mzero: looks like LogicT (StateT FilePath IO) to me
06:06:08 <mm_freak> i.e. a monad
06:06:19 <mm_freak> find out whether you can write an ArrowApply instance for it
06:06:28 <mm_freak> if yes, you've got a monad, so no need for arrows =)
06:06:45 <mzero> Well, mm_freak what can I see, felt much more like Arrow than Monad
06:06:55 <mm_freak> lars__: the main advantage of AFRP is local state and high composability
06:07:01 <mzero> and Arrow instance was certainly easy to write!
06:07:12 <mzero> s/see/say/
06:07:50 <lars__> mm_freak: so can it make gui programming easier?
06:09:16 <lars__> i did several thousand lines of ocaml code in a ncurses project, the gui part is really a pain.
06:10:03 <Jafet> What did n turn out to be?
06:10:07 <benmachine> mzero: I'd agree with mm_freak that it looks a tiiiny bit monady to me :)
06:11:26 <mzero> well, true, in fact I was thinking of re-writing that code two more ways: as a custom monad, and as a monad stack -- mostly as a way to see which code ended up more clear (both the implementation and for the user of Find)
06:11:50 <mzero> so yes, my choice to use Arrow was a bit of an experiment
06:12:04 <mzero> but I have to say, I was surprised that the code came out nice clear
06:12:40 <mzero> on the first try -- so wasn't tempted the double re-write before releasing (that code is part of the Haskell uninstaller)
06:13:36 <benmachine> hmm
06:13:59 <benmachine> do you actually use the Arrow instance, or just the Category one?
06:15:02 <mzero> ah - I think, at this point in the code I'm not using Arrow utilities any more!
06:15:11 <benmachine> :)
06:15:19 <mzero> I was before, though &&& and |||
06:15:27 <benmachine> mm
06:15:30 <benmachine> fair enough
06:16:12 <harlekin> I think you can seg-fault the X server when using xftDrawString with a very large string. Where should I report this?
06:16:34 <mzero> those are what made me think of Arrow in the first place
06:16:49 * hackagebot scan 0.1.0.7 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.7 (ChristianMaeder)
06:16:52 <benmachine> harlekin: is this using the X11 library?
06:16:54 <mzero> BTW why doesn't ArrowZero have the equivalent of msum?
06:17:05 <mzero> er, ArrowPlus
06:17:15 <harlekin> benmachine: yes. but the particular function is from x11-xft.
06:17:17 <lars__> > let x = (x = x) in x
06:17:19 <lambdabot>   <no location info>: parse error on input `='
06:17:21 <Jafet> I can segfault the X server by doing nothing
06:17:24 <benmachine> harlekin: ah
06:17:32 <lars__> > let x = (x == x) in x
06:17:36 <lambdabot>   mueval-core: Time limit exceeded
06:17:42 <Dolly_> hello
06:18:37 <benmachine> harlekin: the easiest way would be to report it to the maintainer of x11-xft and let them worry about it
06:19:09 <benmachine> details here: http://hackage.haskell.org/package/X11-xft
06:19:41 <benmachine> if you were feeling enterprising you could try to work out whether it is because of the haskell binding or the library itself
06:19:42 <mzero> hi, Dolly_  what's up?
06:20:17 <Dolly_> is this better then prolog?
06:20:22 <nexion> can forever be aborted?
06:20:38 <Dolly_> I am pro life
06:20:38 <nexion> other than by killing the program
06:20:47 <nexion> :)
06:20:51 <Dolly_> no please don't kill it
06:20:56 <benmachine> nexion: yes
06:21:05 <benmachine> nexion: how depends on the monad you use
06:21:13 <mzero> Dolly_: we try not to make absolutist value judgements of other programming languages here....
06:21:24 <mzero> ... but yes, it is. :-)
06:21:32 <benmachine> nexion: e.g. if you are using Maybe, you can just return Nothing
06:21:34 <Dolly_> that's great news
06:21:37 <benmachine> but that's not very interesting
06:21:53 <nexion> what about IO?
06:21:57 <benmachine> oh
06:22:01 <benmachine> you can throw an exception?
06:22:08 <benmachine> I guess?
06:22:09 <mzero> why is it great news?
06:22:23 <benmachine> I'm pro-death btw
06:22:28 <Guest38041> hi list!
06:22:46 <harlekin> benmachine: thanks.
06:23:29 <Dolly_> i am currently learning prolog and i hate it.  From next month i will be learning haskell
06:23:54 <benmachine> harlekin: if you look at the source, xftDrawString seems to allocate an array for the UTF8 encoded string (or at least, that's what I guess this function does)
06:24:14 <benmachine> harlekin: maybe something you could try is using the same technique to allocate your own array, but don't do anything with it
06:24:20 <mzero> really, Dolly, hate for programming languages should be reserved for PHP.
06:24:25 <benmachine> if you find that it still segfaults, that suggests the haskell binding is at fault
06:24:33 <benmachine> mzero: hey, there's enough terrible languages to go around
06:24:52 <benmachine> someone the other day told me about how in their degree they learnt fortran77
06:25:13 <mzero> why do you hate Prolog, Dolly_ ?
06:25:20 <Dolly_> have you ever programmed using dylan.NET?
06:25:30 <Dolly_> it's a great programming language
06:25:46 <benmachine> harlekin: http://hackage.haskell.org/packages/archive/X11-xft/0.3.1/doc/html/src/Graphics-X11-Xft.html#xftDrawString
06:26:22 <mzero> I've never programmed in it, but I have a rough of idea of Dylan .... but that doesn't tell me what you find objectionable about Prolog - hence what you may or may not want to be prepared for when learning Haskell
06:26:26 <benmachine> harlekin: well, probably just contacting the maintainer is the best option, but if you're impatient there are things you can try, and I'm sure they'd be grateful for any information you found
06:32:37 <hiptobecubic> Where is "liftIO" now? I get complaints that everything is hidden
06:36:03 <hiptobecubic> Oh, Control.Monad.Trans now
06:36:23 <mm_freak> lars__: i'm a user and implementor of AFRP, but i'm mainly using it for network-related stuff
06:36:28 <benmachine> it's in a fair few places
06:36:35 <benmachine> e.g. Control.Monad.IO.Class
06:36:39 <mm_freak> but a ready-made AFRP GUI library would definitely make your life easier
06:37:47 <dmos> Talking about AFRP: Does anyone have any pointers on how one would persist the state of an AFRP/Arrows program across restarts?
06:38:30 <mm_freak> dmos: in general you can't
06:38:59 <mm_freak> my solution is to have a loader/saver inside of the AFRP network, which persists certain things
06:39:39 <mm_freak> dmos: rec { x' <- persist -< x; … define x somewhere … }
06:39:41 <mm_freak> that's the basic idea
06:40:32 <mm_freak> dmos: you can save only at regular intervals by transforming 'saver':  x' <- (| sample (persist -< x) |) 10
06:40:38 <mm_freak> saves only every 10 seconds
06:41:01 <dmos> mm_freak: ah, interesting. so essentially you persist individual values, and embed the functionality whereever it makes sense
06:41:23 <mm_freak> yes
06:41:42 <mm_freak> i tried hard to find a more general solution, but i came to the conclusion that it's impossible
06:41:48 <dmos> mm_freak: btw, you mentioned that you've written an AFRP implementation yourself? Is it available on Hackage?
06:41:58 <mm_freak> dmos: netwire
06:42:04 <dmos> mm_freak: yeah, I'm running into the same roadblock.
06:42:23 <mm_freak> dmos: i have started with a wiki introduction, but it's not finished yet
06:42:23 <dmos> mm_freak: ah interesting, actually just downloaded and built your newest version yesterday.
06:42:30 <mm_freak> however, it teaches you the basics: http://haskell.org/haskellwiki/Netwire
06:42:38 <mm_freak> hehe ok
06:43:20 <dmos> mm_freak: as a note: it builds on 7.2.2 if you enable DoRec and fix the forkable monad to compile with a base higher than 4.4
06:44:14 <dmos> mm_freak: I've meant to ask you whether you have some examples online somewhere, as it looks like netwire is fairly close in spirit to my usecase.
06:45:27 <mm_freak> dmos: i'm developing on GHC 7.0.3 right now…  i'm surprised that DoRec is not enabled already
06:45:43 <mm_freak> GHC 7.0.3 doesn't require DoRec for the rec construct for some reason
06:46:15 <mm_freak> you can look into the history of the wiki page…  it covers older versions, but has some useful examples, which you can use in the new version
06:46:22 <mm_freak> mostly only the type signatures change
06:47:29 <dmos> mm_freak: GHC complained, so I put it in, and it worked. Not sure whether it's required or not. But I think the movement is to state what default-language you want (ie. Haskell98 or Haskell2010). But not sure if this is true, I'm still fairly green when it comes to Haskell.
06:48:12 <dmos> mm_freak: ok, will look at wiki history. I actually went through it in the middle of you updating it to the new version, so a page refresh did wonders :)
06:49:59 <mm_freak> dmos: alright…  i'm glad about any feedback =)
06:51:27 <dmos> mm_freak: One other question (mainly because I haven't read enough of netwires source code yet): Are common arrows eliminated, ie. if I have two arrows which amount to the same arrow composition up to a certain point, are the duplicate code paths executed twice (no sharing), or once?
06:51:56 <mm_freak> dmos: this depends
06:52:09 <mm_freak> in general they are executed twice
06:52:22 <mm_freak> for example:  countFrom 10 &&& countFrom 10
06:52:40 <mm_freak> however, i have discovered some weird CSE effects with GHC, which caused space leaks there
06:53:06 <mm_freak> so tend to disable CSE (-fno-cse) in my programs
06:53:30 <mm_freak> whether GHC tries to optimize mainly depends on the kind of wire
06:53:40 <dmos> mm_freak: ok. The reason for asking was essentially this post here: http://apfelmus.nfshost.com/blog/2011/04/24-frp-push-driven-sharing.html
06:54:11 <mm_freak> if it's a pure wire (WmPure/mkPure/mkPureFix), then you may have CSE eliminate the duplicates (which is actually bad)
06:55:00 <dmos> bad, because you know can't separate identities anymore, and you might want to alter one path but not the other?
06:55:12 <dmos> *know -> now
06:55:13 <mm_freak> no, that's not the problem
06:55:32 <mm_freak> the problem is that the sharing causes space leaks
06:55:49 <mm_freak> the garbage collector won't let go of old instants anymore for some reason
06:57:58 <dmos> ah. ok. Well unfortunately I'm not yet at the point where I have enough working code to run into these kinds of problems, but if I'm really able to use netwire for my use case then I will let you know how it goes.
06:58:34 <mm_freak> well, you are completely safe with effectful wires (WmGen)
06:59:06 <mm_freak> but when using pure wires and getting a space leak, before trying anything else, try -fno-cse
06:59:39 <dmos> Will do.
06:59:55 <carpi> while pattern matchig is there a difference between doing "(x:_:[]) = x" and "(x:(_:[])) = x"?
07:00:08 <mm_freak> dmos: just uploaded 3.0.1 with the DoRec issue fixed
07:00:23 <Jafet> (:) happens to be right-associative, so no.
07:00:24 <dmos> mm_freak: prompt support :) thanks.
07:00:26 <mm_freak> hackagebot should report soon
07:00:31 <Jafet> Or is it left-associative.
07:00:56 <Jafet> I don't think I've ever seen a left-associative infix constructor
07:01:06 <mm_freak> dmos: you're welcome…  if you encounter any other problems, just let me know
07:01:49 * hackagebot netwire 3.0.1 - Fast generic automaton arrow transformer for AFRP  http://hackage.haskell.org/package/netwire-3.0.1 (ErtugrulSoeylemez)
07:01:57 <dmos> there we go.
07:02:57 <dmos> mm_freak: I'll let you know. Do you have any particular recommendations about which papers (or in which sequence) get you the fastest up to speed on netwire? I'm currently working through the Yampa page as you have referred to Yampa on the wiki.
07:03:19 <aristid> mm_freak: it seems like FRP is the main application for Arrows :D
07:03:19 <hpaste> Gavri pasted “cabal install --extra-include-dirs=/usr/include/postgresql postgresql ” at http://hpaste.org/54785
07:03:38 <mm_freak> aristid: static data is another one
07:03:48 <mm_freak> aristid: look into arrow-based parser combinators
07:03:52 <dmos> mm_freak: I did read a couple of conals papers and blog posts as well, but find myself sometimes going back to read again because understanding increased in the meantime.
07:04:02 <gavri> anybody know why I get that error while installing cabal postgresql?
07:04:22 <mm_freak> aristid: for example a state abstraction which can tell you whether it has the potential to change the state is an arrow, but not a monad
07:04:46 <Peaker> I think arrows should be deprecated :)
07:05:02 <mm_freak> dmos: the speed of netwire is really due to a lot of experimentation by me
07:05:25 <mm_freak> Peaker: why?
07:05:46 <dmos> mm_freak: :) I was talking about the speed of my understanding, not the speed of netwire (which is great, btw, although I don't have many other reference points).
07:05:59 <mm_freak> dmos: oh
07:06:10 <mm_freak> dmos: well, in fact it was a hint by Cale
07:06:16 <Peaker> mm_freak: because it is redundant to Category/Applicative.. The extra laws don't need the whole new library/etc
07:06:21 <mm_freak> AFRP is really just the automaton arrow
07:06:31 <dcoutts__> gavri: looks like the code is totally borked
07:06:31 <mm_freak> Peaker: no, it's not
07:06:39 <Peaker> mm_freak: It is not good to have artificial library fragmentation -- makes code less re-usable, and there's more to learn for no gain
07:06:45 <mm_freak> Peaker: don't forget ArrowChoice, ArrowLoop and the arrow notation
07:06:53 <Peaker> I do miss ArrowLoop in the Category/Applicative world, though: Need class ApplicativeFix f where afix :: (f a -> f a) -> f a
07:06:58 <Peaker> mm_freak: arrow notation isn't very good, imo
07:07:11 <mm_freak> Peaker: depends on your application
07:07:18 <mm_freak> for AFRP it's almost essential
07:07:22 <Peaker> Arrow notation feels like having @pl as part of my compilation process...
07:07:32 <Peaker> Why? Have better points-free combinators...
07:07:37 <mm_freak> try to express a complicated computation with many side channels and many ArrowChoice branches using the combinators
07:07:40 <mm_freak> then you know what i mean ;)
07:08:33 <Peaker> It would be better to implement a notation for Category/Applicative, instead
07:08:38 <gavri> dcoutts__: it's from a standard cabal install working with the haskell-platform package. any idea how I could get around this?
07:08:38 <aristid> doesn't arrow notation desugar to a lot of arr (\...) calls?
07:08:40 <Peaker> (though I would still avoid it :-) )
07:08:57 <carpi> is it possible to tell any of the fold variants to stop after traversing a certain number of elements?
07:09:29 <mm_freak> Peaker: one advantage of Arrow over Applicative is that it's friendly to high performance stuff
07:09:52 <mm_freak> Peaker: an Applicative-based interface would be much harder to optimize, especially with a special notation
07:10:14 <mm_freak> Peaker: in fact i'd rather get rid of monads and applicatives and have only arrows instead ;)
07:10:20 <dcoutts__> gavri: it's not a matter of getting around it, the code is broken. You can go fix the code.
07:10:29 <copumpkin> why is arrow easier to optimize than applicative?
07:10:30 <dcoutts__> gavri: or use another package, or complain to the maintainer
07:10:37 <mm_freak> aristid: yes, it does
07:10:56 <aristid> mm_freak: that bothers me :(
07:11:00 <mm_freak> copumpkin: because you can write specialized functions for 'first' and 'second'
07:11:14 <copumpkin> and?
07:11:14 <mm_freak> aristid: it's not as bad…  if your arrow is prepared for that, it's fine
07:11:17 <dcoutts__> gavri: you could try adding MultiParamTypeClasses, but it's pretty likely there are other bugs in that package
07:11:39 <dcoutts__> gavri: I'd recommend the HDBC packages, and the HDBC postgres backend
07:11:47 <mm_freak> copumpkin: i wouldn't know how to optimize Applicative
07:12:04 <mm_freak> wouldn't even know where to start, because there is no information at all about the computations
07:12:07 <copumpkin> Applicative doesn't even involve intermediate pairs
07:12:21 <mm_freak> but it involves opaque functions everywhere
07:12:51 <copumpkin> it does?
07:13:02 <mm_freak> copumpkin: first argument of (<*>)
07:13:06 <copumpkin> that's not a function
07:13:14 <copumpkin> it's an f of a function
07:13:16 <mm_freak> it results in a function
07:13:23 <copumpkin> which is just a value, which could be a constructor in an ADT
07:13:40 <copumpkin> applicatives don't "result" in anything
07:13:45 <mm_freak> copumpkin: yeah, now thing of a specialized notation for Applicative
07:13:52 <mm_freak> thing → think
07:13:53 <copumpkin> (| |)
07:13:55 <copumpkin> :P
07:13:58 <mm_freak> lol
07:14:05 <copumpkin> idiom brackets
07:14:10 <copumpkin> I love them, use them in SHE all the time :D
07:14:56 <gavri> dcoutts__: how do I pass compiler options to cabal?
07:15:44 <dcoutts__> gavri: it's typically not necessary, you can pass extra lib and include locations, what do you need to do?
07:16:40 <gavri> dcoutts__: I thought -XMultiParamTypeClasses was an option that had to be passed to the compiler
07:17:21 <Peaker> mm_freak: Only having arrows? How do you represent the Maybe/List monads?
07:17:33 <Peaker> mm_freak: Always compose with pure (->) just to satisfy the kind?
07:18:11 <dcoutts__> gavri: no, you'd fix that by changing the code, by adding {-# LANGUAGE  MultiParamTypeClasses #-} to the file
07:18:23 <dcoutts__> gavri: I'd just avoid that package if I were you
07:18:29 <dcoutts__> pick another db lib
07:18:36 <mm_freak> copumpkin: actually now that i think about it, (| |) would be quite nice
07:18:46 <copumpkin> yeah, I'd love idiom brackets in GHC
07:19:07 <copumpkin> ideally ones that don't use pure
07:19:12 <mm_freak> if you throw in some equivalent for ArrowChoice, ArrowPlus and ArrowLoop, it could be fine
07:19:26 <mm_freak> Peaker: ArrowApply
07:19:39 <mm_freak> Peaker: every arrow with an ArrowApply instance gives rise to a monad
07:19:46 <Peaker> mm_freak: I know -- but the kind is *->*->*
07:19:49 <Philonous> > let foldrn n f x = foldr (\ a (b,m) -> if m >= n then (b,m) else (f a b, m+1)) (x,0) in foldrn 3 (+) 0 [1..10] -- carpi
07:19:50 <lambdabot>   (27,3)
07:19:53 <copumpkin> I thought arrows already had idiom brackets
07:20:02 <Peaker> mm_freak: how do you make arrows of all the *->* applicatives/monads?
07:20:03 <mm_freak> Peaker: see the ArrowMonad type
07:20:14 <mm_freak> copumpkin: they are different
07:20:17 <copumpkin> ah
07:21:13 <Peaker> mm_freak: ArrowMonad is for converting arrows to monads, it seems?  I'm asking if you get rid of the Applicative/Monad class, how do you make an instance of Arrow for Maybe/[] ?
07:21:43 <Philonous> Peaker:  Kleisli
07:21:55 <Philonous> :i Kleisli
07:22:16 <mike-burns> @info Kleisli
07:22:16 <lambdabot> Kleisli
07:22:17 <Peaker> Philonous: That's pretty ugly... To get Applicative/Monad functionality, you have to compose with (->) artificially --> less modular code
07:22:47 <mm_freak> Peaker: data Maybe a b = Nothing | Just (a -> b)
07:22:50 <carpi> is it mandatory that in an "if" clause the then part and else part return values that are the same type?
07:23:08 <quicksilver> yes
07:23:16 <Philonous> carpi:  Yes, otherwise what would the type of the whole expression be?
07:23:17 <quicksilver> that is what makes sense to the type system
07:23:18 <Peaker> mm_freak: YUCK :)
07:23:58 <copumpkin> data Perhaps a = Preposterous | OneMightConceive a
07:23:58 <Peaker> mm_freak: instead of having nice little units of functionality -- you are now forcing everyone to glue together unrelated functionalities, just to artificially satisfy the kind
07:24:42 <mm_freak> Peaker: copumpkin convinced me that an Applicative-based solution could work, too
07:24:52 <mokus> join (OneMightConceive Preposterous) = Preposterous!
07:24:59 <mm_freak> but for automaton-based FRP you really want special notation for that
07:25:08 <carpi> Philonous: the come this works "if length lst == 2 then head lst else lstBut''' $tail lst"?
07:25:28 <Peaker> mm_freak: I love points-free :)
07:25:31 <mm_freak> Peaker: so a haskell with idiom brackets for Applicative would satisfy me
07:25:31 <carpi> in the above case... the then part return an "a" and the else part returns an [a]
07:25:49 <mm_freak> Peaker: i like it, but i don't love it…  i use it where it's appropriate
07:26:08 <carpi> but lstBut1''' is a recursive call
07:26:50 * hackagebot HTab 1.6.0 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/HTab-1.6.0 (GuillaumeHoffmann)
07:28:00 <geheimdienst> carpi: both then and else have to give a, or they both have to give [a]. it must match. if it's recursive or not shouldn't matter
07:29:15 <Philonous> carpi:  Well, apparently you recursive call returns a value of the right type
07:32:14 <Philonous> carpi:  Btw. I'd rather write that as: case lst of (x:_:[]) -> x; (_:xs) -> lsBut''' tail lst
07:32:24 <carpi> the function is actually "lstBut1''' lst = if length lst == 2 then head lst else lstBut1''' $tail lst
07:32:32 <carpi> is it still valid now?
07:33:49 <Philonous> carpi:  Is this dollar sign there intentional?
07:33:57 <quicksilver> yes, it is
07:33:59 <carpi> yup
07:34:02 <carpi> otherwise it don't work
07:34:04 <Philonous> My bad
07:34:04 <quicksilver> but it's a funny way to write it
07:34:24 <carpi> quicksilver: could you please tell how would you write it? i mean the convetional way?
07:34:29 <Philonous> I parsed it as part of the "tail" name
07:34:31 <quicksilver> anyhow, if something then x else recursivecall
07:34:35 <quicksilver> carpi: with a space on each side
07:34:55 <quicksilver> anyhow, "f = if something then x else f" will always type check
07:35:01 <quicksilver> if one branch is a bare recursion
07:35:02 <carpi> i think i should do the same .. after $ is also a function
07:35:11 <quicksilver> then it obviously matches the type of the other branch
07:35:16 <Philonous> carpi:  And yes, lsBut1''' hast type [a] -> a, so both cases of the if have type a, no problem there
07:35:37 <quicksilver> however function defintion by cases is much easier to read
07:35:49 <carpi> Philonous: ah yes.. that makes more sense..
07:35:52 <quicksilver> lstBut1''' (x:_:[]) = x
07:35:56 <carpi> so it always boils down to the types
07:36:01 <quicksilver> lstBut1''' _ = lstBut1 (tail lst)
07:36:06 <carpi> if the types are correct then you're good to go
07:36:20 <quicksilver> note your function crashes on 1-element lists.
07:36:30 <quicksilver> and empty lists
07:36:48 <Philonous> carpi:  Btw. avoid length and head, length because it does too much work (has to look at the whole list, even it is a million elements long), tail because it is partial.
07:37:34 <carpi> quicksilver: yes .. its true. its one of the problems from 99 questions exercises. And i've written the same function in 4 different ways. and that is one of them. trying to practice for familiarity than for correctness at the moment.
07:38:12 <carpi> Philonous: you meantioned tail being partial.. could you please tel me what you mean?
07:38:13 <quicksilver> :)
07:38:13 <Philonous> carpi:  err, length, head and tail
07:38:14 <quicksilver> fair enough
07:38:25 <Philonous> > tail []
07:38:26 <lambdabot>   *Exception: Prelude.tail: empty list
07:38:29 <quicksilver> he means it crashs on some values
07:38:54 <osfameron> if a function is impartial, would that mean it returns the same value whatever argument you give it?
07:39:07 <carpi> ah okay... because.. the word partial seems to have many different meanings especially in the context of haskell . xD
07:39:07 <Philonous> carpi:  You are reimplementing pattern-matching in a clumsy and error-prone way. ;)
07:39:28 <carpi> osfameron: i believe an impartial function takes care of all the cases..but i might be wrong
07:39:39 <Philonous> carpi:  A total function
07:39:51 <Saizan> "impartial" is not an established terminology in this context
07:39:54 <osfameron> I was just making a bad joke ;-)  I guess I'm thinking of const tho'
07:40:26 <quicksilver> carpi: really? This is the main thing partial means; what were you thinking of?
07:40:58 <carpi> quicksilver: partial functions, partial applicatin..
07:41:42 <geheimdienst> carpi: partial functions and partial application seems unrelated to me. it's a little unfortunate they used the same word for it.
07:42:19 <nilu> Hello!!!
07:42:37 <geheimdienst> carpi: normally, people say "a partial function" or "a total function"
07:42:50 <geheimdienst> hi nilu
07:43:12 <quicksilver> oh, that use
07:43:15 <quicksilver> fair enough.
07:43:17 <carpi> geheimdienst: as synonyms ?
07:43:19 <quicksilver> :)
07:43:25 <quicksilver> no, as antonyms.
07:43:26 <nilu> Can anyone tell me three main features of haskell?
07:43:36 <carpi> ah yes.. thats what i thought : )
07:43:59 <quicksilver> nilu: no. It's a programming language, not a dishwasher. It doesn't have three main features :P
07:44:10 <geheimdienst> carpi: no, as opposites. head or tail are partial functions. listToMaybe, which is basically the same as a safe "head", is a total function (= works for any input)
07:44:13 <nilu> i know it has more
07:44:17 <carpi> nilu: sex toy for the mind : )
07:44:37 <russellw> I think it's fair question. I'd say the three main features are pure functional, lazy, type inference
07:44:39 <geheimdienst> > listToMaybe []
07:44:40 <lambdabot>   Nothing
07:44:44 <geheimdienst> > head []
07:44:45 <lambdabot>   *Exception: Prelude.head: empty list
07:44:56 <Jafet> 1. It is named after Haskell Curry. 2. It is a programming language. 3. It has a very nice IRC channel who will gladly help even the most obvious of trolls.
07:45:18 <carpi> > tail []
07:45:19 <russellw> Though of course one could come up with alternative lists like that one :)
07:45:19 <lambdabot>   *Exception: Prelude.tail: empty list
07:46:14 <nilu> russellw: what is type interference?
07:46:30 <nilu> *inference
07:46:45 <russellw> nilu, let me answer that with another question: what are the three main features of Google? :)
07:47:04 <nilu> sure
07:47:16 <geheimdienst> nilu, what i find most attractive about haskell is that the compiler (named ghc) is so helpful. it's pretty hard to get anything to compile, but once it does, it rarely has many bugs anymore. you have to hunt bugs in any language, but in haskell, the compiler helps you a lot. the bug-hunting happens before you run the program the first time
07:47:17 <Philonous> I think higher-kinded polymorphism is a much more interesting "feature" than laziness. Almost all languages have one way another to create thunks
07:47:41 <koeien> but in haskell they're pervasive
07:48:11 <russellw> Philonous, interesting. I'm tempted to ask what higher-kinded polymorphism is, but then you would be entitled to give me the same answer I just gave nilu :)
07:49:18 <Philonous> russellw:  THe idea is that you can abstract over the "Maybe" in "Maybe Int". So you get something like "forall m. Functor m => m Int"
07:49:39 <Philonous> russellw:  ML can't do that
07:49:51 <quicksilver> it's theoreticall interesting but very very seldom used
07:49:59 <quicksilver> I'm not sure it deserves a place in a list of main features
07:50:31 <quicksilver> well, it's used in the Functor m => m a case of course
07:50:33 <quicksilver> hmms
07:50:39 <quicksilver> OK it is very very often used :)
07:50:46 <Philonous> :)
07:51:04 <nilu> thanks guys
07:51:11 <russellw> hmm. I don't understand that explanation unfortunately - when would you want to abstract over the maybe? To write a function that can deal with both Int and Maybe Int?
07:51:13 <geheimdienst> jafet: could you please not accuse people of trolling who merely asked the first most basic question about haskell
07:51:37 <koeien> russellw: no, to write a function that can deal with all functor types "containing" an int
07:51:51 <Philonous> russellw:  No, A function that can deal with Maybe Int, [Int], Either String Int and (String -> Int)
07:52:04 <russellw> ah! Okay that makes sense
07:52:40 <mm_freak> copumpkin: does SHE have an equivalent for ArrowChoice and ArrowLoop?
07:53:15 <russellw> I'm trying to think of what other languages you could do that in. Dynamically typed ones of course but then you don't get type checking. I think you could do it in C++ but not Java or C#, right? (At least not anywhere near as directly)
07:53:43 <copumpkin> mm_freak: nope
07:54:31 <carpi> is it possible to maintain state in a single expression?
07:54:43 <carpi> like in a list comprehension for example?
07:54:49 <koeien> carpi: i'm not sure what you mean, but probably not
07:55:10 <koeien> carpi: what would you like to accomplish?
07:55:19 <mm_freak> copumpkin: that's unfortunate…  but i guess with the applicative instance i could simply define some combinators
07:56:14 <carpi> koeien: a simple "fetching the last but one element". i can do it recursively but im wondering if i can do it without using recursion
07:58:09 <koeien> you mean f (x:_:[]) = x; f (_:xs) = f xs  ?
07:58:37 <carpi> koeien: yes..thats what i did..
07:58:45 <koeien> you could write (!! 1) . reverse
07:58:51 <benmachine> it's possible to do it as a fold
07:58:54 <carpi> yup.. i did that one too
07:59:13 <carpi> benmachine: fold.. ? could you please tell me how?
07:59:26 <carpi> a hint perhaps
07:59:27 <benmachine> @botsnack
07:59:28 <lambdabot> :)
07:59:57 <Philonous> > last . init $ [1..10]
07:59:59 <lambdabot>   9
08:00:02 <benmachine> > foldr (\x (y,_) -> (x,y)) (1,2) [3,4,5,6]
08:00:04 <lambdabot>   (3,4)
08:00:07 <benmachine> hmm
08:00:14 <benmachine> that's not what I was aiming for at all
08:00:19 <benmachine> or is it
08:00:24 <benmachine> I'm not sure :P
08:00:53 <carpi> benmachine: is okay.. atleast now i have a hint at an approach
08:01:00 <Philonous> benmachine:  Sure you don't mean foldl?
08:01:04 <benmachine> Philonous: nope :)
08:01:12 <benmachine> I mean, I'm not sure
08:01:24 <benmachine> but if I were maintaining state in a fold, tuples often help
08:01:33 <koeien> > foldl (\(y,_) x -> (x,y)) (1,2) [3,4,5,6]
08:01:34 <lambdabot>   (6,5)
08:01:44 <koeien> > foldl (\(y,_) x -> (x,y)) (undefined,undefined) [3,4,5,6]
08:01:45 <lambdabot>   (6,5)
08:01:49 <benmachine> koeien: that sounds more like what I wanted yes
08:02:01 <quicksilver> just put a 'snd' on the front
08:05:51 <Philonous> > foldr (\x b -> case b of Nothing -> Just (Nothing); Just Nothing -> Just $ Just x; _ -> b) Nothing [1..10]
08:05:52 <lambdabot>   Just (Just 9)
08:06:06 <koeien> and then join the result.
08:06:38 <koeien> > join (Just (Just 9))
08:06:38 <quicksilver> nice
08:06:39 <lambdabot>   Just 9
08:06:41 <quicksilver> that one wins :)
08:06:58 <rwbarton> poor "f (x:_:[]) = x; f (_:xs) = f xs"
08:08:53 <rwbarton> For nth-from-last element you can use the fancy zipWith const `ap` drop n trick
08:12:33 <mm_freak> copumpkin: one problem i see is that SHE kills arrow notation
08:12:34 <rwbarton> I actually can't think of another way off-hand that has the right time and space complexity
08:12:40 <mm_freak> because arrow notation has its own (| |) syntax
08:12:48 <koeien> rwbarton: (!!n).reverse ?
08:13:32 <rwbarton> doesn't that take O(length xs) space?
08:14:00 <copumpkin> last . iterate init
08:14:04 <copumpkin> or you know what I mean
08:14:19 * copumpkin feels dirty
08:14:27 <rwbarton> I do but now I think you are doing n * length xs work
08:14:34 <rwbarton> but I'm not really sure about either of these
08:14:47 <rwbarton> actually I am sure about yours
08:14:51 <copumpkin> yeah
08:14:59 <copumpkin> I like efficient solutions ;)
08:15:32 <rwbarton> zipWith const `ap` drop n is magically both O(n) space and O(length xs) time, that's what's so cool about it
08:15:50 <copumpkin> yeah
08:15:56 <copumpkin> I like that family of solutions
08:16:35 <_oz> so, what was wrong with (last . init) ?
08:16:41 <saati> :t zipWith const `ap` drop n
08:16:43 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
08:16:43 <lambdabot>     In the first argument of `drop', namely `n'
08:16:43 <lambdabot>     In the second argument of `ap', namely `drop n'
08:16:54 <saati> :t zipWith const `ap` drop 1
08:16:55 <lambdabot> forall b. [b] -> [b]
08:17:21 <rwbarton> _oz: nothing
08:17:31 <_oz> rwbarton: oh ok.
08:17:40 <_oz> just code golfing then :)
08:17:43 <copumpkin> _oz: except you don't really want to iterate it
08:17:44 <rwbarton> it just doesn't generalize as well
08:18:11 <_oz> and you want it to generalise to?
08:18:30 <Philonous> _oz:  Anything that's Foldable
08:19:12 <_oz> i see.
08:19:24 <rwbarton> I meant to taking the nth last element for n > 1
08:26:27 <copumpkin> mm_freak: ah yeah, I don't think conor's pseudoparser can deal with it
08:30:44 <mm_freak> copumpkin: for some reason i have an aversion against preprocessors
08:30:55 <mm_freak> it somehow feels dirty
08:31:25 <copumpkin> it is
08:31:29 <copumpkin> but it's a playground
08:38:05 <vrook> Given that there is no natural number type, is there an idiom instead? Like foo x | x > 0 = bar $ baz x ? Is it bad form to have a non-exhaustive pattern?
08:41:20 <hpc> vrook: data N = Z | S Z
08:41:33 <hpc> vrook: then provide an instance for Num
08:42:04 <hpc> there are also some natural number modules
08:42:24 <koeien> if you can live with finiteness, Data.Word is an option
08:42:55 <benmachine> vrook: the difficulty is mostly how to define subtraction
08:42:55 <edwardk> ezyang got us more space, we can now host 80 people for hac boston, so if anyone had held off registering, feel free ;)
08:42:56 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
08:42:59 <vrook> My question is about common usage, though. Is it really normal to define data N = Z | S Z or to use a hackage module? I'm guessing people don't bother.
08:43:23 <benmachine> vrook: most people will either return something vaguely sensible, e.g.
08:43:29 <benmachine> > take (-1) [1,2 ..]
08:43:30 <lambdabot>   []
08:43:35 <benmachine> vrook: or just call error
08:43:39 <benmachine> > 7 ^ (-3)
08:43:41 <lambdabot>   *Exception: Negative exponent
08:43:50 <ion> > x ^^ (-3)
08:43:51 <lambdabot>   recip (x * x * x)
08:43:55 <ion> > x ^^ (-30)
08:43:56 <lambdabot>   recip (x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x...
08:44:15 <hpc> heh
08:48:36 <vrook> Is it bad form to let the pattern matcher produce the error? Redundant | otherwise = error "..." would be, um, redundant
08:49:04 <benmachine> vrook: it's not exactly bad form but the message it produces isn't always the most intuitive
08:49:20 <benmachine> vrook: plus it makes clear that you are aware your pattern match is non-exhaustive, and this is intentional
08:49:46 <vrook> Yeah, I guess non-exhaustive pattern matches suggest an error on the part of the programmer, not the user.
08:50:00 <Eduard_Munteanu> vrook: if that case should be impossible to reach, or otherwise a fatal error, then it's ok I guess. Otherwise consider providing proper error handling.
08:50:25 <vrook> Is there an analogue of condition handling?
08:50:51 <Eduard_Munteanu> Condition handling?
08:51:02 <hpc> as in if-else-if?
08:51:06 <vrook> Lisp condition handling.
08:51:14 <vrook> handlers and restarts.
08:52:06 <quicksilver> handlers are easy
08:52:09 <quicksilver> restarts much less so
08:52:14 <quicksilver> verging on the impossible
08:52:25 <hpc> what is a restart?
08:52:36 <quicksilver> I assume it's a "resume from the point the exception was thrown"
08:52:43 <hpc> i assume condition is an exception
08:52:58 <hpc> a restart is doable with continuations
08:53:00 <vrook> No, restart is resume from a predetermined spot.
08:53:17 <vrook> it might be close to where a condition is raised, but might not.
08:53:19 <quicksilver> ok that's easier
08:53:35 <quicksilver> but it's fairly uncommon in haskell code that I've seen
08:53:40 <quicksilver> might just be cultural
08:53:45 <quicksilver> not many peopl use the continuation monads.
08:54:12 <hpc> Cont tends to look like wizardry, i think is why
08:54:24 <benmachine> I only used ContT once and that was only because ErrorT is so ew
08:54:35 <benmachine> so it wasn't really using the "full power" of continuations
08:54:36 <hpc> or at least, the only resources on Cont are written by said wizards
08:55:41 <Eduard_Munteanu> I frequently wished for some form of goto / breaking from current scope in monadic code.
08:56:10 <geheimdienst> i guess guard is slightly like that
08:56:52 <vrook> The nice thing about Lisp conditions is that an error is just a type of condition. You can have non-error conditions which are signaled and optionally ignored.
08:57:15 <vrook> It's a way to communicate between top-level and low-level code.
09:00:02 <Philonous> hpc:  I think its strange, though, because we are already programming in a style that is close to CPS
09:00:04 <ckingc> Quick question, since I'm entirely new to programming, is there a way of making miniature graphics applets that let me make sure snips of code are working? I'm interested in using Haskell for game design.
09:00:54 <hpc> ckingcole: what kind of graphics?
09:00:56 <quicksilver> vrook: yes, that part haskell supports fine
09:01:03 <quicksilver> vrook: exceptions as non-local signalling
09:01:20 <quicksilver> either using the low-level IO exceptions, or using a type like Either for exceptions
09:01:31 <quicksilver> sophisticated subtype hierarchies of exceptions are a bit of a pain though
09:01:40 <quicksilver> (but you're probably not expecting those if you're thinking lisp)
09:01:50 <rwbarton> @hackage gloss
09:01:51 <lambdabot> http://hackage.haskell.org/package/gloss
09:02:03 <rwbarton> ckingcole: you might find that useful
09:02:08 <ckingcole> cheers
09:03:59 <hpc> quicksilver: nobody expects the sum type?
09:07:12 <geheimdienst> you know, maybe some tool would be handy that could show a package's functions, typeclasses, and instances as some sort of diagram, possibly a graph
09:08:16 <geheimdienst> ... case in point: so getCurrentTime gives you an UTCTime, but then what? if this was an OO language, you could look at the class's documentation, which lists the methods and properties, giving you an impression of some things you can do with that
09:08:46 <geheimdienst> in haskell, it's more difficult to figure out from the haddocks how to do stuff with that UTCTime thingy, say, getting the minutes of the day out of it
09:09:18 <stroan> hoogle helps a lot there
09:09:25 <quicksilver> I'm not sure that's true in general, I think ther is a very *specific* problem, geheimdienst
09:09:45 <quicksilver> which is that it's hard to recognise when core functionality is, in fact, supported by a standard typeclass
09:09:52 <geheimdienst> stroan: yeah, you can hoogle for functions that take an UTCTime ... that helps somewhat
09:10:13 <quicksilver> such as DiffTime (or whatever its called) delegating core conversions to various classes in the Num hierarchy
09:10:19 <quicksilver> but that's not very discoverable.
09:10:36 <quicksilver> "realToFrac" is one of the most FAA in this channel, for this and similar reasons.
09:11:18 <geheimdienst> quicksilver: that's absolutely true. the thing that would help there, of course, is sample code. which unfortunately you rarely see in haddocks, if ever
09:12:57 <quicksilver> geheimdienst: well or just some words explaining "if you want to convert this to a number of seconds as an integer, use "round" from the standard typeclass...."
09:13:13 <quicksilver> geheimdienst: however, it would be nicer if there was a more structured way but it's not obvoius to me
09:13:22 <quicksilver> hoogle could be smarter
09:13:49 <quicksilver> given a search for "Foo -> Bar" it could look for typeclass polymorphic versions restricted to classes that Foo is actually a member of
09:13:51 <nexion> can a single Control.Exception.catch block throw multiple exceptions at once?
09:14:20 <quicksilver> (rather than typeclass polymorphic versions for *any* typeclass which I think it does now)
09:19:50 <shapr> YAY CODE
09:20:17 <shapr> quicksilver: So, fix hoogle?
09:20:22 <ckingcole> Okay, what I'd like to do is make mini-games where I can test things out, like firing a ball out of a cannon or whatever. I suppose I'd just write a very simple game in FunGEN for that?
09:27:04 <ckingcole> Well, if I have to ask!
09:27:15 <ckingcole> Cheers.
09:27:26 <saml> ask
09:30:26 <Mirx> Bonus: Hello
09:31:07 <Mirx> BONUS: Hello
09:31:25 <Mirx> Has anyone read the Haskell material yet
09:34:10 <ckingcole> @saml: I meant in the sense of, "If you have to ask, you probably already know the answer". Or is that not what that expression is meant to mean?
09:34:10 <lambdabot> Unknown command, try @list
09:35:15 <saml> ckingcole, you want to write a game?
09:35:31 <saml> why not use HTML5 with haskell backend
09:36:19 <ckingcole> Why not? Because I didn't think of that, haha. I'll read around.
09:39:39 <mike-burns> This isn't twitter; don't use @ to address people.
09:39:46 * mike-burns polices the IRC.
09:40:45 <elliott> There's no way to get GHC to output .hi and .o files in separate invocations, right?
09:59:22 <hiptobecubic> I have a list of floats and I want to write them as raw binary to stdout, is this best done with ByteString or..?
10:00:07 <copumpkin> meaning the native IEEE representation of the floats?
10:00:21 <copumpkin> cause the Data.Binary representation is massive
10:01:35 <hiptobecubic> copumpkin, yes
10:01:59 <hiptobecubic> as in directly write a single precision floating point number as binary data to a file
10:02:16 <copumpkin> there's probably a library for that, but I don't know what it'd be
10:02:30 <copumpkin> it bothers me that we can't write Float/Double efficiently using binary
10:05:20 <hiptobecubic> There's really no way to handle it? That can't be right..
10:07:25 <elliott> hiptobecubic: cereal can do that
10:07:27 <elliott> natively
10:07:31 <elliott> switch to cereal :-)
10:09:16 <hiptobecubic> i can't switch. i haven't started using anything yet
10:10:13 <vrook> Will the successor to cereal be named cereal-killer?
10:12:32 <donri> vrook: are you super cereal?
10:13:45 <hiptobecubic> I don't really understand how to use cereal
10:13:46 <monochrom> meta-cereal
10:14:09 <donri> hiptobecubic: what you don't cerealize is that ...
10:14:35 <hiptobecubic> donri, cerealsly?
10:14:35 <mrakan> A hundred students have submitted their homework: a single Haskell module filled with functions of predefined names and types. I have correct function definitions in a module of my own: Correct.hs. What would be the best way to automatically verify how correct the students' homeworks are?
10:15:15 <hiptobecubic> mrakan, quickcheck that their functions == your functions?
10:15:20 <monochrom> yeah
10:15:31 <hiptobecubic> Be advised, I don't know shit about anything.
10:15:45 <hiptobecubic> Just seemed reasonable.
10:15:50 <monochrom> hunit also works, does not require your correct solution, but requires hand-crafted test cases
10:16:13 <hiptobecubic> if you already know your edge cases then that's probably better i guess
10:17:06 <mike-burns> Review each homework line-by-line, offering feedback on what they did wrong, what they did right, and what was technically correct but could lead to problems.
10:17:18 <mrakan> Thanks for the thoughts. Quickcheck seems okay to me.
10:17:26 <hiptobecubic> Mechanical Turk
10:18:00 <mrakan> mike-burns: Yes, that's the plan. It takes a lot of time, however, so I'm now planning to automate the first part of the process: verifying that the solutions are correct in the first place.
10:18:37 <mrakan> Can quickcheck deal with functions that throw exceptions my design?
10:18:45 <mrakan> *by design
10:19:30 <geheimdienst> mrakan: run them all through ghc with Wall, and then through hlint
10:19:40 <vrook> mrakan: I would recommend making real tests. You need to verify that YOUR solutions are correct.
10:20:24 <copumpkin> eww, functions that throw exceptions by design
10:20:26 <vrook> but that's just me
10:20:53 <copumpkin> vrook: you in the boston area, by the way?
10:21:33 <vrook> yep
10:22:18 <mrakan> geheimdienst: Good idea, thanks! vrook: The functions involved are rather simple. If my solution happens to be incorrect, I'll probably know it when most of the students fail to emulate its behaviour.
10:22:51 <copumpkin> vrook: you should come to bostonhaskell :) and maybe the boston haskell hackathon
10:23:03 <mrakan> copumpkin: We haven't yet gone through using Maybe, Either and the similar stuff. So we just use error. :)
10:23:03 <kurtosis> ?
10:23:11 <kurtosis> mt
10:23:13 <mokus> copumpkin: when's the next one?
10:23:15 <mike-burns> When is the next Boston Haskell meeting?
10:23:26 <vrook> copumpkin: but I'm a smug lisp weenie, though.
10:23:29 <copumpkin> mokus: not sure when the next bostonhaskell is, but the hackathon is jan 20-22 and is free to attend
10:23:39 <mike-burns> I like that `error' is easier than Maybe.
10:23:52 <copumpkin> vrook: we'll have you expounding the virtues of strong static types by the end of it
10:24:09 <copumpkin> I think edwardk got lots more space
10:24:14 <copumpkin> so it's gonna be big and fun
10:24:17 <copumpkin> (somewhere at MIT)
10:25:52 <vrook> There are too many quirks in Haskell, indicative of a lack of metaprogramming. Like little ad hoc extensions here and there to compensate. A "real langugage" (notice smug) can do those things in the language itself.
10:26:25 <russellw> vrook, for example?
10:26:44 <rwbarton> Smug people don't need to give examples.
10:27:40 <vrook> russellw: wherever you see {-# LANGUAGE .. }
10:28:01 <hpc> vrook: the other side of the coin is "there's too many limitations in lisp, that they have to resort to metaprogramming, like little macros here and there to compensate"
10:28:22 <russellw> vrook, ah, I'm not familiar with that end of things
10:28:58 <hpc> vrook: there are a lot of hacky extensions, but there are also some fantastic haven't-been-standardized extensions like GADTs
10:29:02 <vrook> hpc: that's a lame dodge. There's no reason Haskell can't program itself.
10:29:06 <hpc> which are basically language features in all but name
10:29:35 <copumpkin> vrook: you at NEU or something? :P
10:29:53 <hpc> vrook: it could, but it doesn't; first-class functions are generally as expressive as any macro could be
10:29:55 <vrook> I'd like to see a Haskell which doesn't need # LANGUAGE, that's all. There's no reason it can't be done.
10:30:04 <copumpkin> vrook: it's called agda :P
10:30:10 <hpc> vrook: there is; it's called haskell ;)
10:30:18 * hpc never uses extensions
10:30:24 <hiptobecubic> srsly guys, binary data. How do i write byte?
10:30:26 <copumpkin> LANGUAGE is just an indication of an active research community
10:30:36 <copumpkin> people experimenting with new ideas in the language
10:30:39 <hiptobecubic> i tried eating cereal
10:30:47 <hpc> vrook: i'd like to see a lisp without macros ;)
10:30:48 <rwbarton> copumpkin: blah blah macros blah langauge
10:30:51 <hiptobecubic> but my ghc just sat there
10:31:04 <copumpkin> rwbarton: damn, excellent point. I concede!
10:31:41 <vrook> LANGUAGE is an indication that whatever state a language is in, you always want to abstract more.
10:31:43 <hpc> it is my suspicion that lisp without macros is not turing-complete, while haskell without extensions is just haskell8
10:31:47 <hpc> *98
10:31:58 <Mirx> Has most of the people read the Haskell material?
10:32:02 <hpc> (or 2010, or whatever older standard you pick)
10:32:10 <copumpkin> Mirx: what haskell material?
10:32:14 <xplat> does anyone know a library that implements an EDSL based on a substructural type theory?
10:33:00 <KirinDave> man every time I pull up the docs for cmdargs…implicit I cringe.
10:33:13 <vrook> hpc: that's a really strange thing to say. The first lisps didn't have macros, which were obviously turing complete.
10:33:13 <copumpkin> :)
10:33:22 <Mirx> copumpkin: http://learnyouahaskell.com/
10:33:29 <KirinDave> It really seems to me like type families and maybe some template haskell could make a much better system that doesn't have such… weird properties.
10:33:30 <copumpkin> Mirx: I haven't
10:33:41 <geheimdienst> KirinDave: it gives me the willies too. apparently there's cmdlib now, which is somewhat less cowboy
10:34:14 <vrook> The use of template haskell in yesod makes my point.
10:34:24 <vrook> Or I should say, also makes my point.
10:34:25 <bos> it's hardly a defense, but cmdargs is relatively concise.
10:34:27 <copumpkin> it does?
10:34:54 <rwbarton> yesod uses template haskell => Haskell lacks metaprogramming
10:35:00 <Mirx> I am interested in learning a programming language with pretty much no experience except a lil html I've learned in a college course 6 yrs ago.  Any suggestions?
10:35:02 <hpc> i thought TH was always considered an ugly alternative to just writing higher order functions
10:35:22 <vrook> well read yesod's blogs on that
10:36:01 <copumpkin> rwbarton: haven't you heard of the new axiom for promoting existentials to universals?
10:36:02 <geheimdienst> ... in cmdargs' defense, he said on his blog that he hopes a future version will be pure, possibly through use of TH
10:36:04 <hpc> vrook: http://blog.ezyang.com/2010/09/data-is-code/ -- you might be interested in this
10:36:07 <copumpkin> rwbarton: it's all the rage these days
10:36:35 <KirinDave> bos: I don't dispute that
10:36:42 <KirinDave> bos: I'm just saying that it has some weird rules.
10:37:01 <mrakan> Mirx: I suggest Python.
10:37:17 <bos> KirinDave: it's in a horrible state of sin, to be more accurate.
10:37:18 <vrook> Mirx: My suggestion is to learn Haskell, Lisp, and C. Anything else is just variations on that.
10:37:23 <vrook> more or less
10:37:29 <hpc> summary: in lisp, code can be coerced into listy structures so it can be used in macros; in haskell, the way various language features comes together means that data is code; instead of having a loop that increments something forever, you make an infinite list
10:37:31 <KirinDave> bos: Actually I really only have one big complaint: the sub-commands system is not extensible; you need to define your data instance uniquely and in one place.
10:37:33 <copumpkin> vrook: prolog?
10:37:37 <vrook> yes, prolog
10:37:39 <KirinDave> bos: Given that we'd really like sub-commands to be modular
10:37:45 <KirinDave> bos: That's just awful. :D
10:37:49 <vrook> Haskell, Lisp, Prolog, C ... and finish off with Shen.
10:37:58 <hpc> copumpkin: with extensions, haskell's type system is almost prolog, i think
10:38:04 <Mirx> vrook, any good reliabel resouces on those languages you could direct me to?
10:38:05 <Philonous> vrook:  Isn't shen now colled Qi?
10:38:09 <Philonous> called*
10:38:16 <ddarius> hpc: Not really.  It's a logic language, but not one that's like Prolog.
10:38:17 <copumpkin> hpc: it's some sort of logic-like language, but it's not really the same
10:38:18 <vrook> Philonous: vice versa
10:38:23 <vrook> Qi is now Shen
10:38:27 <Philonous> Oh, ok
10:38:29 <geheimdienst> KirinDave: what's subcommands, the "install" in "cabal install"?
10:38:38 <koeien> that name is hard to google :/
10:38:50 <Philonous> vrook:  Also, include a dependently typed language
10:38:51 <KirinDave> geheimdienst: Yeah. They're called "modes" I guess.
10:39:53 <KirinDave> It's _extremely_ nice to have a facility for those, but it'd be much much better if such a facility does not reqiure a single data decl as its basis.
10:39:53 <hiptobecubic> Mirx, if you are going to be "a programmer" then I think vrook is right. If you're a tinkerer that needs to program now and then, i think python is probably going to be the most immediately useful
10:40:30 <Mirx> hiptobecubic:  I hear a lot about Python
10:40:52 <hiptobecubic> although, this is coming from a tinkerer that can't do any haskell/lisp voodoo
10:42:30 <Philonous> I think SICP is a great book for learning what programming is all about
10:42:45 <hiptobecubic> Mirx, it's very friendly and very general and has a huge set of libraries. I wouldn't say it does anything 'the best' (except maybe 'being a general tool') though.
10:42:55 <Mirx> Philonous, SICP?
10:42:57 <MostAwesomeDude> Is there a library which builds packed binary data from structures? A reverse of parsec/attoparsec?
10:43:14 <Philonous> Mirx:  The "WIzard book" http://mitpress.mit.edu/sicp/
10:43:51 <hiptobecubic> That book is in lisp though, no? The old one at least. They switched to python for their intro course i thought
10:43:51 <Mirx> Philonous:  Cool
10:44:04 <geheimdienst> KirinDave: i dunno. i wouldn't say "extremely nice" :) modes complicate everything. i've sometimes wondered if it wouldn't be clearer to just have "cabal-info" and whatnot, all symlinked to the same executable. this would work as long as you have only 10-20 (it gets ridiculous if you have 100 subcommands). it would simplify cmdargs and similar libraries, and also simplify things with shells' completion facilities
10:44:14 <Philonous> Mirx:  But the medium is Scheme and it's written on a very high level
10:44:16 <KirinDave> geheimdienst: Well I like modes
10:44:28 <KirinDave> geheimdienst: I like the way—say—git works.
10:44:55 <geheimdienst> KirinDave: i guess git is an exception because it's so messy. it has >250 subcommands iirc
10:45:05 <Mirx> Phionous:  You saying it's difficult to follow?
10:45:07 <MostAwesomeDude> Hm. Maybe I want boomerang.
10:45:29 <Mirx> Philonous:  You saying it's difficult to follow?
10:45:46 <Philonous> hiptobecubic:  MIT switched to Python as their teaching language. A bad choice IMO. The reason they gave boiled down to "our students are too dumb for SICP"
10:46:18 <hiptobecubic> Mirx, if you want to learn the art of computer programming for its inherent fun and beauty, then go for it. If you want to learn to program so you can get your arduino to blink or because you want to automate your repetitive tasks then it might not be the easiest way to reach that goal.
10:46:44 <vrook> Norvig's explanation of the switch to python, http://news.ycombinator.com/item?id=1803815
10:47:21 <Mirx> hiptobecubic:  Definitely wanna go the route to learn the art of computer programming for it's inherent fun and beauty.  : )
10:48:19 <hiptobecubic> Mirx, then i would say specifically to avoid python and perl and php and java. Learn vrooks' three, preferably with C last so you can appreciate how annoying it is
10:48:50 <hiptobecubic> also if you learn those, you can learn python if and when you need it without much work
10:49:35 <MostAwesomeDude> PHP is in its own category, really. Don't lump it in with other languages, please.
10:49:46 <vrook> I prefer ruby to python. Ruby blocks are a substantial improvement.
10:49:58 <Philonous> vrook:  Also, roby has call/cc
10:49:59 <vrook> Things are chainable in Ruby, too.
10:50:01 <KirinDave> geheimdienst: In any event, it really seems like  typefamilies would be _exactly_ what the doctor ordered for that sort of "let your config data also dispatch to your code" sort of thing.
10:50:02 <Philonous> ruby*
10:50:42 <vrook> Philonous: not really. It's always had problems. The current call/cc can't handle unwind-protect clauses.
10:50:56 <vrook> er, I mean rescue clauses
10:51:29 <vrook> But no call/cc has ever really handled those well. Scheme gave up on unwind-protect, I think.
10:52:48 <vrook> (Ruby implementers say that call/cc is a "joke" feature.)
10:54:00 <Philonous> Ah, I'm not a rubyist. But that's silly. Why implement it at all if you are not supposed to use it?
10:54:49 <MostAwesomeDude> Cruft, maybe? Python and Perl carry around a handful of unused features too.
10:55:11 <hpc> perl wears them proudly; it was designed by a linguist after all ;)
10:55:16 <vrook> Well you can use it, you just need to be careful about rescue/ensure clauses. When you think about what a continuation does, there's no good way to handle those.
10:56:04 <augur> hpc: linguist schminguist
10:56:58 <augur> sure he was studying linguistics, but he was going into field work
10:57:04 <vrook> It's was a pretty good design decision for Lisp to provide a solid unwind-protect, thereby sacrificing call/cc.
10:57:10 <vrook> (IMO)
10:58:43 <Mirx> Philonous:  Another thing, I have a tight schedule with school and work and was wondering how much time a day is sufficient enough to spend on learning a or more than one language?
10:58:47 <MostAwesomeDude> Okay, I can't find anything; is there a binary builder which works with enumerators? Perhaps a builder/parser combination?
10:58:55 <cwb> Mirx: Are you taking programming up as a hobby or something you want to earn money with in the forseeable future?
10:59:36 <Mirx> cwb:  Hobby at first than maybe something I could take as profession
11:00:22 <hpc> Mirx: nice thing about programming is you can do it in as tiny an increment of time as you feel like
11:00:31 <Mirx> cwb:  I wouldn't mind getting into developing mobile applications
11:00:42 <hpc> for learning programming, the amount of time it takes per sit-down varies from concept to concept
11:00:58 <vrook> copumpkin: Are there extensions to compile new functions at runtime and use them as if they were defined as normal functions?
11:01:12 <cwb> Mirx: Ah, for mobile applications you tend to have more restricted choice of languages. Unless you do mobile web-apps.
11:01:39 <Mirx> cwb:  especially with apple I see. Lol
11:01:43 <copumpkin> vrook: not that I know of. Types don't really like that kind of thing
11:01:49 <hpc> vrook: haskell does not have "eval", if that's your question
11:01:57 <ddarius> Eval is just a function.
11:01:59 <vrook> well I do see some Eval extensions
11:01:59 <cwb> vrooks suggestions are still good if you want to do things the proper way; but it'll be some time before you can get that first iPhone app up.
11:02:01 <hpc> it has lambdas though, which is enough to define "new functions"
11:02:20 <ddarius> There are libraries that let you do that.  They don't require any extensions.
11:02:26 <copumpkin> in a dependent language, you might be able to have eval : (s : String) -> typeOfExpression s
11:02:36 <Mirx> cwb:  I definitely wanna get into know some of the proper ways so there is no rush.
11:02:42 <vrook> copumpkin: so you are back to greenspunning. You have one class of citizens and another class of citizens. I want equal opportunity.
11:03:22 <copumpkin> vrook: type systems explicitly prevent you from doing certain things. I accept the limitations in exchange for the added guarantees
11:03:37 <copumpkin> vrook: but as ddarius said, you can do it, just not safely
11:04:18 <ddarius> Eval is just a function in Lisp.  It has nothing to do with "language features."  It is more about having an interface to the implementation, though even that isn't necessary.
11:04:25 <vrook> So if you're doing genetic programming, you are not using Haskell itself but some other funny funcalling mechanism. I want to write Haskell in Haskell (or Lisp in Lisp).
11:04:46 <copumpkin> why do you want to?
11:04:55 <Philonous> vrook:  You can interpret strings as haskell code and execute that on the fly
11:05:05 <Philonous> http://hackage.haskell.org/package/hint
11:05:09 <Mirx> bbl
11:05:38 <cwb> Mirx: Ok, well, then as vrook suggested: learn C for the lower level programming (Kernighan & Ritchie), Haskell for the state-of-the-art-but-still-practical (start with Learn You a Haskell), Lisp for the process theory (SICP) and Prolog for, well, logic (which I don't know much about).
11:05:51 <cwb> Mirx: how patient a student are you?
11:05:56 <ddarius> cwb: "process theory"?
11:05:58 * mightybyte thinks metaprogramming is more useful in lisp than it is in Haskell
11:06:01 <hpc> how often does anyone ever need to interpret a string of text as code at runtime, instead of just coding in functional style?
11:06:17 <cwb> ddarius: Uhm, yeah, computational theory?
11:06:20 <hpc> (the only time i can think of is restart-less code updating)
11:06:29 <Mirx> I'm can be pretty patient
11:06:34 <vrook> copumpkin: why would I want to use Haskell syntax when programming in Haskell?
11:06:34 <Blackheart> Lisp has nothing to do with concurrent processes.
11:06:35 <ddarius> cwb: That makes slightly more sense, but still very little sense.
11:06:42 <vrook> not sure what the question is
11:06:44 <copumpkin> vrook: why would you want to write haskell in haskell?
11:06:53 <copumpkin> vrook: meaning, why do you want metaprogramming?
11:07:10 <hpc> vrook: better question, why do you /need/ metaprogramming?
11:07:23 <vrook> copumpkin: I was being metaphorical. Just because a function is read a runtime, I don't want to use a non-Haskelly syntax just for using the function.
11:07:25 <ddarius> Best question, why do people care?
11:07:28 <znutar> because sometimes your manager measures productivity in LOC
11:07:30 <vrook> *at runtime
11:07:44 <cwb> ddarius: haha, fair enough. For understanding the constructs and patterns that emerge from the running of programs?
11:07:45 <copumpkin> vrook: who the hell reads functions in at runtime in good code?
11:07:55 <vrook> copumpkin: genetic programmers
11:08:21 * copumpkin stops feeding the troll
11:08:31 <vrook> copumpkin: Actually, I'm talking about read-time hooks, which is just before run-time.
11:08:52 <ddarius> cwb: SICP is a good introduction to how programming languages work and it happens to use Scheme.  Lisps are not particularly fundamental.
11:09:21 <vrook> copumpkin: well, you asked. Sometimes functions are data.
11:09:23 <cwb> Mirx: Ok, good. Personally I would start with C; it's pretty easy to get going and if you don't need fancy graphics for excitement, fairly gratifying. I would add Petzold's CODE as bed-time reading.
11:09:44 <cwb> ddarius: Wasn't trying to imply that.
11:10:18 <ddarius> cwb: My point is that there while there are reasons to suggest learning Lisp, the one you gave is not one of them.
11:10:21 <russellw> vrook, I sympathize with where you're coming from - I'm currently working on a scripting language, vaguely similar to Haskell, for machine learning workloads vaguely similar to genetic programming
11:10:27 <vrook> copumpkin: I don't ever think I've been called a troll.
11:10:43 <russellw> But I don't think Haskell itself is designed for that use case
11:11:21 <hpc> vrook: ...have you never heard of first-class functions?
11:11:40 <ddarius> My impression is that one usually wants a language much more constrained than Haskell as a target for genetic programming.
11:12:21 <vrook> russellw: Yes, as I said yesterday, Lisp is "open world" and Haskell is "closed world".
11:12:23 <russellw> ddarius, yes, roughly speaking that's because genetic programming is a very weak method, i.e. it doesn't know much about the space of possible programs
11:12:33 <cwb> ddarius: Ah, you're absolutely right, my bad. Should have said that SICP is the point, not lisp.
11:12:43 <Philonous> I like the REPL-style interaction with programs, as emacs has it. I don't see why it is such a bad Idea to define e.g. a monad for that and expose it via hint
11:12:43 <russellw> That's why I described what I'm aiming for as vaguely similar to genetic programming, rather than actually being genetic programming :)
11:13:36 <ybit> > let x :: (Num a) => a -> a -> a; let x a a = a + a
11:13:37 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:13:54 <ybit> > let add :: (Num a) => a -> a -> a; let add a a = a + a
11:13:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:14:01 <vrook> hpc: huh?
11:14:35 <vrook> you seem to be agreeing with me?
11:14:42 <hpc> vrook: (defun dynamic-runtime-function-lol (x) (lambda (y) (+ x y)))
11:14:48 <hpc> oh look, i made a function at runtime lolol
11:14:53 <hpc> :t map (f . g)
11:14:54 <lambdabot>     Ambiguous type variable `a' in the constraints:
11:14:55 <lambdabot>       `Show a' arising from a use of `f' at <interactive>:1:5
11:14:55 <lambdabot>       `SimpleReflect.FromExpr a'
11:15:07 <hpc> :t map (succ . (+ 5))
11:15:09 <lambdabot> forall a. (Enum a, Num a) => [a] -> [a]
11:15:14 <hpc> oh look i made a function!
11:15:19 <hiptobecubic> What's going on with all this 'putting' and 'getting' in Data.Serialize? Putters and getters and builder monoids....
11:15:34 <int-e> hpc: oh no and who's going to clean up after you?
11:15:57 <hpc> vrook: no 'eval' there, and no "compiling a new function at runtime"
11:16:04 <hpc> vrook: just first-class functions
11:16:07 <hiptobecubic> Where is like, "Float -> blob" that i can pass to "blob -> IO ()"
11:17:26 <vrook> hpc: I think you misunderstand. Suppose you have a description of a function. You need to build the Haskell AST to a string, compile it, and then link it in. It probably can be done, but it's not "natural" in Haskell.
11:17:39 <ybit> what's the problem with my add function?
11:17:59 <ybit> i'll give someone .0000000000001BTC for the answer
11:18:02 <hpc> vrook: sure, but your example was "genetic programming", which is dead-easy to do with first-class functions
11:18:04 <monochrom> "x a a = ..." is invalide
11:18:54 <ybit> ty
11:19:14 <hpc> why would you want to take source code from a string and run it? it's not "natural" in haskell but it also isn't "natural" in software design
11:19:40 <vrook> hpc: The stuff you're typing into ghci is generated from data. The AST has to be built and then converted to a string. You are just bypassing the hard work by saying "look, use ghci!"
11:19:47 <monochrom> genetic programming is an antithesis to software design
11:19:51 <Blackheart> ybit: Patterns must not mention the same variable more than once.
11:20:01 <hpc> vrook: sure, but ghci isn't where you write programs
11:20:03 <mightybyte> Metaprogramming is inversely proportional to code readability.
11:20:26 <ybit> > let add :: (Num a) => a -> b -> c; let add a b = a + b
11:20:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:20:33 <vrook> hpc: how does that matter regarding what I said?
11:20:48 <ybit> > let add :: (Num x) => a -> b -> c; let add a b = a + b
11:20:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:20:53 <monochrom> your type "(Num a) => a -> a -> a" is fine
11:20:56 <ybit> > let add :: (Num a, b, c) => a -> b -> c; let add a b = a + b
11:20:56 <lambdabot>   <no location info>: malformed class assertion
11:21:16 <ybit> > let add :: (Num a) (Num b) (Num c) => a -> b -> c; let add a b = a + b
11:21:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:21:26 <rwbarton> (Num a, Num b, Num c)
11:21:27 <monochrom> no
11:21:44 <ybit> > let add :: (Num a, Num b, Num c) => a -> b -> c; let add a b = a + b
11:21:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:21:45 <hpc> vrook: because "ghci does it" isn't a reason for it to be "i need this program to do it too"
11:21:46 <rwbarton> and no second "let"
11:21:53 <Blackheart> > :type \a b -> a + b
11:21:53 <lambdabot>   <no location info>: parse error on input `:'
11:21:54 <ybit> > let add :: (Num a, Num b, Num c) => a -> b -> c; add a b = a + b
11:21:55 <lambdabot>   not an expression: `let add :: (Num a, Num b, Num c) => a -> b -> c; add a ...
11:22:03 <Blackheart> > \a b -> a + b
11:22:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
11:22:04 <lambdabot>    arising from a use...
11:22:08 <monochrom> I don't understand why you think that different parameters must be of different types
11:22:09 <rwbarton> now you have various other problems of course :P
11:22:12 <Blackheart> bah
11:22:13 <DanBurton> :t \ab -> a + b
11:22:14 <lambdabot> forall t. t -> Expr
11:22:18 <DanBurton> -.-
11:22:23 <DanBurton> oh whoops
11:22:24 <vrook> hpc: I have no idea what that means.
11:22:27 <DanBurton> :t \a b -> a + b
11:22:29 <lambdabot> forall a. (Num a) => a -> a -> a
11:22:43 <DanBurton> there we go
11:22:54 <ybit> that looks very similar to my original type declaration
11:23:01 <Philonous> vrook:  I'm not sure whether you saw that earlier. http://hackage.haskell.org/package/hint gives you (basically) interpret :: String -> IO a where a can, of course, be a function.
11:23:03 <hpc> vrook: give a use-case where you need to take in haskell code as a string; a SPECIFIC use case where you can't do it any other way
11:23:22 <ybit> > let add :: (Num a) => a -> a -> a; let add a b = a + b
11:23:23 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:23:36 <hpc> vrook: and then i will say "use hint"
11:23:39 <Philonous> hpc:  That's just silly, you can alswas write your own haskell interpreter inside haskell
11:23:45 <Philonous> always*
11:23:46 <DanBurton>  > let add :: (Num a) => a -> a -> a; add a b = a + b in add 2 3
11:23:54 <DanBurton> > let add :: (Num a) => a -> a -> a; add a b = a + b in add 2 3
11:23:55 <lambdabot>   5
11:23:57 <DanBurton> whitespace :P
11:24:05 <hpc> vrook: or i will say "your program shouldn't be doing that"
11:24:23 <ybit> > let add :: (Num a) => a -> a -> a; let add a b = a + b in add
11:24:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:24:32 <ybit> this works
11:24:35 <DanBurton> ybit: you don't need the second let
11:24:43 <monochrom> lose the 2nd let
11:24:49 <vrook> hpc: I think you're still missing the point about needing to build the AST according to some rules, and then converting that AST to a string. That's messy stuff.
11:24:51 <Blackheart>  > let { add :: (Num a) => a -> a -> a; add a b = a + b } in add 1 2
11:25:01 <DanBurton> space
11:25:07 <ybit> let add :: (Num a) => a -> a -> a; add a b = a + b
11:25:14 <ybit> okay that's what i was needing :)
11:25:24 <ybit> now to do this in lisp
11:25:24 <Gothmog_> hpc: tryhaskell.org :P
11:25:52 <DanBurton> do what in lisp? (define (add a b) (+ a b)) ;; racket
11:26:11 <vrook> hint looks like an interpreter, whereas I've been talking about compiling.
11:26:11 <Blackheart> add = (+)
11:26:50 <DanBurton> vrook: if you need to compile Haskell code...use a compiler?
11:27:03 <hpc> vrook: i am not missing the point, because you never need to do that stuff
11:27:18 <shachaf> DanBurton: (define ((add a) b) (+ a b))
11:27:19 <hpc> vrook: having to write a program that reads in another program is a stupid design
11:27:31 <hpc> vrook: much better would be to run that fucking program in the first place
11:27:35 <DanBurton> shachaf: well if u want it curried :P
11:27:39 <Blackheart> Unless you are writing a compiler...
11:28:16 <vrook> hpc: you still misunderstand. The instructions to build the function are not known until later.
11:28:16 <Blackheart> Of course, every command-line application is a mini-compiler.
11:28:27 * DanBurton would just steal GHC code if he had to write a Haskell compiler...
11:29:00 <vrook> hpc: If they could be defined, you would just type them in.
11:29:17 <mightybyte> vrook: That's rarely strictly necessary and always makes it harder to understand the code later.
11:29:39 <rwbarton> yeah it is really too bad that haskell does not include a lisp compiler
11:29:42 <DanBurton> Blackheart: so you're saying command line applications compile their arguments into a customized program? Interesting.
11:30:08 <DanBurton> @google write scheme 48 hours haskell
11:30:08 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
11:30:08 <lambdabot> Title: Write Yourself a Scheme in 48 Hours - Wikibooks, open books for an open world
11:30:22 <DanBurton> I think that's an interpreter though
11:30:46 <vrook> mightybyte: Is it? Say you want to distribute computations. Why not send them over the wire and compile them on remote machines?
11:30:53 <Blackheart> A language is a set of strings with a semantic model. Unix command-line arguments are a simple example.
11:31:19 <DanBurton> true point. Like a really weird dsl.
11:31:55 <Blackheart> It's just a language minus some common features like variables.
11:31:57 * hackagebot logic-classes 0.47 - Support for propositional and first order logic, normal forms, and a resolution theorem prover.  http://hackage.haskell.org/package/logic-classes-0.47 (DavidFox)
11:31:58 <mightybyte> vrook: Distributed computation doesn't have to be done at the source code level.
11:32:15 <Blackheart> Config files are another simple example.
11:32:31 <vrook> mightybyte: Right, you can greenspun something.
11:32:37 <Blackheart> If you add a notion of variables, you get makefiles.
11:32:57 <mightybyte> vrook: No, I'm saying you can distribute binary instead of source.
11:33:46 <vrook> mightybyte: Where did the original binary come from? You had to compile it, right?
11:34:15 <mightybyte> I don't get your point.
11:34:31 <Blackheart> XML is basically a language of datatype values.
11:34:47 <Blackheart> HTML adds display semantics.
11:35:10 * roconnor doesn't think that is what XML was designed for
11:35:17 <Blackheart> .ini files are a list of bindings for base datatypes.
11:36:04 <Blackheart> Unix-style arguments are a syntax for booleans and association lists.
11:38:10 <hpaste> hiptobecubic pasted “Write some floats damnit” at http://hpaste.org/54792
11:38:15 <hiptobecubic> I would ask for a toy example of how the hell 'Data.Serialize' is supposed to be used, but this program IS a toy example.
11:38:46 <Philonous> vrook:  I think you could compile to a DLL and dynamically load that. But eww!
11:40:09 <Saizan> hiptobecubic: you don't seem to be using anything from Data.Serialize there?
11:40:50 <hiptobecubic> Saizan, right. because I don't see how it works. What with the putting and whatnots
11:41:18 <Saizan> hiptobecubic: you could read the definitions
11:41:29 <Saizan> Putter t = t -> Put
11:42:00 <Saizan> but you don't even need that for just a Float
11:42:10 <Saizan> encode :: Serialize t => t -> ByteString
11:42:27 <Saizan> then you use Data.ByteString.putStrLn to print that ByteString
11:42:30 <hiptobecubic> I have of course. But I don't understand how it fits together. Where are things being 'put' ?
11:43:45 <Saizan> into a ByteString, but indirectly, put builds PutM actions, which can be composed with the usual monadic operators
11:43:58 <Saizan> then you can use runPut to extract the ByteString
11:44:03 <hiptobecubic> hm
11:44:07 <TheLemonMan> yo, this code http://hpaste.org/54793 has made my shitty haskell skills go nuts
11:44:24 <TheLemonMan> it bitches about the x2:xs part
11:44:42 <TheLemonMan> that should be correct as x2 is an Int and xs an [Int]
11:45:31 <Saizan> put bubblesort $ .. in parens
11:45:59 <TheLemonMan> (don't note how wrong the alghoritm is, my recursion skills are weaker than the haskell ones)
11:46:44 <alistra> sequence $ [print a | a <- bubblesort $ [10,9..1]]
11:46:49 <alistra> what is this supposed to do?
11:47:13 <ddarius> The same thing as mapM_ print $ bubblesort [10,9..1]
11:47:22 <ddarius> TheLemonMan: Stop using ($) until you understand it.
11:48:16 <alistra> it's not really a bubble sort
11:48:24 <alistra> or maybe it is
11:48:47 <alistra> nope it's not
11:49:12 <TheLemonMan> ddarius, i keep adding useless $ to make code clearer to me
11:49:19 <TheLemonMan> nope, its a wannabe bubblesort
11:49:29 <alistra> first i assume you run it on x2:xs, so it can catch pairs (1,2) (2,3) (3,4) instead of (1,2) (3,4)
11:49:47 <alistra> but you should use x2 or x1 there depending on the sort order in the if :P earlier
11:49:52 <ddarius> TheLemonMan: Stop using ($) until you understand it.
11:50:25 <alistra> also you should run this what you have length xs times
11:50:30 <alistra> or until you reach a fixpoint
11:50:43 <alistra> then it will bubblesort it
11:51:16 <alistra> now assuming you have [5,4,3,2,1] after the first run you will have [4,3,2,1,5]
11:52:27 <wyfrn> are there any special ghc options required to use preprocessor makros like the MIN_VERSION_* ?
11:53:02 <geheimdienst> TheLemonMan: what ddarius is (ineptly) trying to say is: ($) helps you cut down on the number parens sometimes. replace the "(" with "$" and then you can leave out the ")". writing "bubblesort $ [...]" is the same as "bubblesort ([...])", and those parens are unnecessary
11:53:19 <ddarius> geheimdienst: That's not what I'm trying to say.
11:53:52 <alistra> also geheimdienst: if you will explain how $ works, do it properly
11:53:59 <ddarius> geheimdienst: I'm saying that TheLemonMan should simply not use ($) at all, until such point that he understands it.  Your "explanation" is probably how he got into this situation.
11:54:15 <alistra> because people will sometimes have problems with $ not working as they want :P
11:56:57 * hackagebot generic-tree 15310.80 - Generic Tree data type  http://hackage.haskell.org/package/generic-tree-15310.80 (MatthewFarkasDyck)
11:57:15 <alistra> geheimdienst: because for example bubblesort $ [1..10] == [1..10] isn't the same as bubblesort ([1..10]) == [1..10] :P
11:57:26 <alistra> or whatever
11:57:34 <alistra> <put appropriate example here>
11:57:48 * alistra is installing llvm 3.0
11:58:03 <TheLemonMan> function composition is still a mistery to me
11:59:10 <geheimdienst> ddarius: you should try explaining ($) to him, particularly if you're unhappy with what i said. so far you've only said to him "you're doing it wrong, and i know more about haskell than you". i don't think that's much of a contribution to the conversation. he knew all of that before he came in here
11:59:18 <sully> is anybody here particularly familiar with Language.C?
11:59:33 <ddarius> geheimdienst: I'm giving him advice, use parentheses, worry about ($) later.
11:59:34 <alistra> sully: i'm trying to write an analyzer basing on it
11:59:36 <geheimdienst> ddarius: if you can't be bothered to explain ($) yourself, it'd be helpful if you provided a pointer
12:00:00 <ddarius> geheimdienst: I don't think it is worthwhile for him to even bother learning about it right now, so why would I facilitate that?
12:00:06 <alistra> sully: if you need a basic question i can answer, if a more complicated, not rly
12:00:24 <alistra> oh god
12:00:29 <mlb-> I thought a good explanation of $ was a really big open paren
12:00:33 <alistra> TheLemonMan: are you familiar with operator priorities?
12:00:53 <TheLemonMan> sure
12:00:56 <sully> I'm trying to generate code with it, and want to insert some toplevel invocations of preprocessor macros
12:01:14 <sully> ddarius: as it turns out, you can't really avoid it, since if you try to read any code written in haskell, it probably uses $
12:01:33 <alistra> TheLemonMan: the trick is that f $ x is the same as f x, but the $ has the lowest priority possible
12:01:33 <ddarius> sully: In those cases, you can usually get away with just pretending it does what you expect.
12:01:56 <ddarius> alistra: The key to ($) is that it's an infix operator.  The precedence is secondary.
12:02:02 <alistra> so in effect it takes more than just a single arguement, but the whole expression with operators with higher priority
12:02:10 <ddarius> In particular, it is an infix operator like any other.
12:02:21 <geheimdienst> ddarius: using parens for now is of course reasonable advice. however, i don't think you expressed that notion earlier in a way that anyone is likely to understand
12:02:38 <ddarius> geheimdienst: "Stop using ($)" seems pretty clear.
12:02:41 <TheLemonMan> and whats the difference with the (.) operator
12:03:37 <monochrom> ($) is for "function $ parameter". (.) is for "function . function".
12:03:41 <alistra> sully: not sure about the preprocessing, sorry, i know it has an option to run a preprocessor, and there's a gcc preprocessor in .Something.GCC  module :D
12:03:44 <Philonous> TheLemonMan:  ($) applies the left hand side to the right hand side ($) f x = f x, (.) composes two functions (.) f g x = f (g x)
12:04:26 <TheLemonMan> got it
12:05:08 <monochrom> (reverse . reverse) xs = reverse (reverse xs) = reverse $ (reverse $ xs)
12:05:26 <alistra> reverse $ reverse $ xs
12:05:30 <alistra> is what you wanted to say
12:05:38 <alistra> and
12:05:41 <geheimdienst> ddarius: no, i don't think it was clear. "prefer parens and don't use $" would have been clear. i don't think a beginner can be expected to know what to use in place of ($). you have to spell that out.
12:05:44 <alistra> reverse . reverse $ xs
12:06:04 <copumpkin> of course, reverse . reverse = id, and id xs = xs, so reverse . reverse $ xs = xs
12:06:06 <copumpkin> QED
12:06:12 <monochrom> quite the opposite. "reverse $ reverse $ xs" to a beginner is why they confuse ($) with (.)
12:06:12 * copumpkin applies reverse . reverse to [1..]
12:06:37 <monochrom> add back explicit parentheses to show the parse tree, and the confusion suddenly disappears.
12:06:48 <ddarius> geheimdienst: If you don't even know what ($) is supposed to be doing even at the level of your "explanation" then you -really- shouldn't be using it.  So to generalize my earlier statement, I don't recommend blithely using anything you don't understand.
12:07:09 * copumpkin hands everyone a lolcat
12:07:11 <alistra> @src (.)
12:07:11 <lambdabot> (f . g) x = f (g x)
12:07:12 <lambdabot> NB: In lambdabot,  (.) = fmap
12:07:16 <alistra> @src ($)
12:07:16 <lambdabot> f $ x = f x
12:08:05 <Philonous> TheLemonMan:  f $ g $ x = f $ ( g $ x) wheil f . g $ x = (f . g) $ x . The first case first applies g to x, then f to the result of that, the second case composes the functions first, than applies the composite function.
12:08:13 <Philonous> while*
12:08:42 <alistra> TheLemonMan: now, let's explain monads
12:08:54 <monochrom> very few beginners have memorized the precedence table. you throw around "reverse . reverse $ xs" and "reverse $ reverse $ xs", and they think it is just substituting (.) for ($) and vice versa.
12:09:22 <monochrom> add back the explicit parentheses for the parse tree, and they see it is not that kind of substitution.
12:09:30 <TheLemonMan> oh, now composition is clearer to me, i still have to get used to that
12:10:02 <alistra> TheLemonMan: you can ask lambdabot to do it for you :D
12:10:15 <alistra> @pl \xs -> length ( reverse  xs)
12:10:16 <lambdabot> length . reverse
12:10:19 <monochrom> and so, I absolutely do not want to say "reverse $ reverse $ xs". I absolutely want to say "reverse $ (reverse $ xs)", no concession.
12:10:44 <monochrom> not even one stroke or one point is to be omitted.
12:10:50 <alistra> @hlint reverse $ (reverse $ xs)
12:10:51 <lambdabot> No module "reverse $ (reverse $ xs)" loaded
12:11:11 <alistra> @hlint \xs -> reverse $ (reverse $ xs)
12:11:12 <lambdabot> No module "\xs -> reverse $ (reverse $ xs)" loaded
12:11:27 <monochrom> @hlint System.IO
12:11:27 <lambdabot> No module "System.IO" loaded
12:11:43 <monochrom> @hlint Prelude 1
12:11:43 <lambdabot> No module "Prelude 1" loaded
12:11:45 <alistra> @hlint Prelude
12:11:47 <lambdabot> No module "Prelude" loaded
12:12:03 <alistra> @hlint help
12:12:03 <lambdabot> help provides: help
12:12:09 <alistra> @help hlint
12:12:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:12:34 <alistra> well i'm lost
12:13:15 <wereHamster> @help pl
12:13:15 <lambdabot> pointless <expr>. Play with pointfree code.
12:13:46 <hpaste> alistra pasted “for you monochrome” at http://hpaste.org/54794
12:14:15 <monochrom> yes? what's your point?
12:14:21 <alistra> warnings from hlint :D
12:14:39 <monochrom> well, screw hlint.
12:14:45 <alistra> hey
12:14:51 <alistra> mr blasphemy
12:15:05 <monochrom> the context is explaining to beginners, not code golfing.
12:20:00 <TheLemonMan> i find extremely difficult in haskell putting debug statements here and there
12:20:14 <monochrom> you can use Debug.Trace.trace
12:20:21 <alistra> yes this ^
12:20:44 <monochrom> f x = trace "f f f" (f (x + 1))
12:21:01 <alistra> monochrom: @code golfing, i once trolled a vimgolf site
12:21:13 <monochrom> and be surprised at the order of the outcome
12:21:17 <TheLemonMan> err, whats different from putStrLn
12:21:35 <monochrom> putStrLn gives you type nightmare
12:21:42 <alistra> it was based on number of strokes to do a task, and it wasn't sandboxed, so you could write a program that does the thing and do %!program :D
12:21:56 <alistra> TheLemonMan: putStrLn returns IO type
12:22:08 <alistra> so you have to unwrap the value, if you want to use it
12:22:13 <alistra> so >>= or do notation
12:22:20 <shachaf> alistra; There's no value to unwrap.
12:22:25 <alistra> aka type nigthmare
12:22:27 <mbetter> ok if you're working in an IO capable monad i think
12:22:30 <alistra> shachaf: another one
12:22:38 <alistra> with the space suits and boxes
12:22:46 <shachaf> alistra: What?
12:22:48 <geheimdienst> TheLemonMan: you can put trace in pure functions. you can use putStrLn only in functions that are in IO
12:22:50 <monochrom> also putStrLn goes to stdout not stderr
12:22:51 <TheLemonMan> ooh, nice, dont want to mess with monads unless is really necessary
12:23:16 <shachaf> TheLemonMan: You don't want to use functions?
12:23:22 <Philonous> TheLemonMan:  The moral is: use trace for debugging, but NOT for anything else, i.e. don't use it for normal input/output
12:23:22 <Cale> When it comes to IO, don't say "unwrap", say "execute"
12:23:23 <mbetter> monads are awesome
12:23:32 <monochrom> no, say "perform"
12:23:33 <Cale> IO actions aren't unwrapped, they're executed.
12:23:38 <Cale> or performed, sure
12:23:41 <monochrom> example: unsafePerformIO :)
12:23:52 <Philonous> Naughty
12:24:12 <shachaf> safePerformIO :: IO a -> IO a; doubleSafePerformIO :: IO a -> IO (IO a)
12:24:12 <monochrom> or say "unsafe perform" if you like :)
12:24:22 <mbetter> so i've got a really big module and i decide to split it into mutiple modules for ease of working with it
12:24:25 <alistra> i meant unwrap the a type from the IO a type constructor
12:24:37 <monochrom> doublePlusUnsafePerformIO :: IO (IO a) -> a
12:25:01 <copumpkin> lol
12:25:06 <Cale> Or any number of other words which indicate accomplishing something arbitrary. "Unwrapped" makes it sound like the IO structure is trivial and that a value of type IO t actually contains within it somewhere a value of type t, and the rest is being discarded.
12:25:20 <bl4ckcomb> is there a way to compare anything? I'm trying to set up a frequency table from a list in which the elements can by of any type. I've tried compare, but it says my there's no instance for Ord with the parameter
12:25:33 <mbetter> so i split it into a bunch of modules which works fine as long as they are in a flat structure, but if i want to arrange my modules in a heirarchal structure i have file / module name clashes
12:25:33 <alistra> cale, yeah, i can unwrap it with a <- someIo
12:25:35 <monochrom> unwrapping amazon wraps is not trivial :)
12:25:39 <alistra> haters gonna hate
12:25:44 <copumpkin> alistra: ugh
12:25:54 <Cale> alistra: v <- x means "execute the action x, and call its result v"
12:26:09 <Philonous> bl4ckcomb:  No, that can not possibly work. how would you compare two functions?
12:26:20 * shachaf "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
12:26:20 <ddarius> @quote /ls
12:26:21 <lambdabot> No quotes match. Just try something else.
12:26:32 <ddarius> @quote \/ls
12:26:33 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
12:26:36 <alistra> Philonous: extensionally
12:26:37 <monochrom> you can compare Ord stuff. that's the way to compare. don't say there isn't a way.
12:26:55 <alistra> or co-recursively enumerable
12:27:12 <monochrom> also "can be of any type" is a premature overgeneralization
12:27:16 <Cale> bl4ckcomb: yeah, the solution to your problem is typeclasses. While you can't write  sort :: [a] -> [a], you can write  sort :: (Ord a) => [a] -> [a]
12:27:40 <alistra> shachaf: list of file names
12:28:05 <bl4ckcomb> oh I see
12:28:20 <monochrom> even Java refuses to compare "can be of any type"
12:28:29 <bl4ckcomb> Cale, with (Ord a) => [a] you're saying that a has Ord defined for it?
12:28:34 <bl4ckcomb> *demanding
12:28:45 <mbetter> an instance of Ord
12:29:06 <mbetter> which means that the compare function(s) are defined
12:29:11 <alistra> Philonous: compare functions f, g: foreach arg in domain: if f(arg) != g(arg) return false; return true
12:29:13 <Cale> bl4ckcomb: yes
12:29:13 <bl4ckcomb> ok
12:29:16 <bl4ckcomb> thank you very much
12:29:35 <Philonous> alistra:  And solve the halting problem en passant
12:29:49 <alistra> hey
12:30:04 <alistra> computers have limited states
12:30:13 <alistra> so lol, you can solve the halting proble
12:30:15 <alistra> m
12:30:20 <mbetter> is there any way to use directory relative module imports?
12:30:22 <alistra> turing machine'd
12:30:30 <Blackheart> bl4ckcomb, every function that builds your table and sorts it needs to constrain the type variable a with (Ord a) =>
12:30:35 <Philonous> alistra:  Exactly! You can't even enumerate all the possible values
12:30:52 <alistra> computers have limited states
12:31:07 <Philonous> alistra:  That's procing MY point, not yours
12:31:11 <Philonous> proving*
12:31:14 <Cale> It's worth pointing out perhaps that the constraint that 'a' be an ordered type and that both occurrences of 'a' are the same type are both being expressed there, which is one thing that's nice about what typeclasses can do.
12:31:16 <bl4ckcomb> Blackheart, yes I understand that. thank you
12:31:19 <alistra> excuse me, mr my-computer-has-infinite-memory
12:31:44 <alistra> my doesn't
12:32:07 <copumpkin> you can have nonterminating programs in finite memory
12:32:27 <mauke> hay guise
12:32:29 <alistra> yeah, but you can trivially add a counter, that counts to 2^memory size
12:32:30 <mbetter> while (1)
12:32:30 <Cale> In some languages, there are interfaces, which are kind of like typeclasses, except that they are used as if they are types.  Ord -> Ord  wouldn't express the constraint that both ordered types are the same type though.
12:32:51 <alistra> and if it overflows it means that you're looping, compuational complexity 101
12:33:04 <copumpkin> alistra: quit being an asshole
12:33:07 <alistra> :D
12:33:11 <alistra> <trollface>
12:33:20 <mauke> bonus track: my hardware grows as the program runs
12:33:21 <copumpkin> <trollface> = +q
12:33:37 <Blackheart> Cale, you make a good point. That's one of the problems with subtyping.
12:33:37 <mauke> I'm on the internet
12:33:38 <shachaf> Cale: Well, you could do it Mirana-style: Ord -> Ord means Ord a => a -> a, Ord -> OrdOrd means Ord a => Ord b => a -> b
12:33:47 <Blackheart> You need to be able to bracket types.
12:34:07 * shachaf isn't sure what the point of his previous sentence is, now that he thinks about it.
12:34:08 <copumpkin> shachaf: ick
12:34:33 <byorgey> @tell geheimdienst Have you taken a look at SourceGraph?
12:34:33 <lambdabot> Consider it noted.
12:34:39 <Cale> shachaf: heh, that's an interesting convention :P
12:35:00 <Cale> shachaf: as a generalisation of what they did with *'s, I guess
12:35:05 <alistra> it's overly long after some time lol
12:35:31 <shachaf> Cale: Exactly.
12:35:31 <alistra> new clang/llvm!
12:35:40 <shachaf> It would even kind of work with multiple type class constraints for a type.
12:35:42 <monochrom> ApplicativeApplicative !!
12:35:52 <shachaf> Not sure about MPTCs, though.
12:36:05 <monochrom> probably doesn't scale to MPTC
12:36:08 <Enigmagic> alistra: yeah every six months or so
12:36:24 <Enigmagic> just happens to be called 3.x instead of 2.10 :-)
12:39:45 <flu_> I'm trying to get cabal up and running on a debian system and having some issues building the cabal-install package. Specifically: http://pastebin.com/ZShd308F
12:39:46 <mauke> The paste ZShd308F has been copied to http://hpaste.org/54797
12:40:59 <flu_> Being new to the haskell ecosystem, I'm not really sure how to proceed :)
12:41:44 <hpc> flu_: you might want to start over with the platform, instead
12:41:51 <hpc> sudo apt-get install haskell-platform
12:42:15 * hpc assumes debian testing; not sure how recent stable's platform is
12:42:23 <mauke> flu_: are you using ghc-6.8?
12:42:41 <Clint>  haskell-platform | 2010.1.0.0.1     | squeeze | source, all
12:42:41 <Clint>  haskell-platform | 2011.2.0.1.3     | wheezy  | source, all
12:42:41 <Clint>  haskell-platform | 2011.3.0.0~pre.5 | sid     | source, all
12:42:43 <flu_> 6.8.2
12:42:48 <mbetter> you could grab a ghc binary and build the platform from source
12:42:52 <mauke> flu_: yeah, you're three major versions behind
12:43:14 <flu_> I'll try that
12:43:20 <flu_> ghc binary and platform from source, that is
12:43:21 <mbetter> easy to keep your versions in sync that way
12:44:11 <mbetter> i have to do that because i use old ubuntu VMs for development
12:44:41 <hpc> mbetter: high five! i am also a member of the masochist club :P
12:44:45 <Cale> flu_: Or even skip the platform and grab cabal-install, because it'll install whatever parts of the platform are relevant pretty easily anyway
12:44:49 <flu_> mbetter: My debian release is probably pretty old too. I'm using a cloud hosted image, and I'm pretty sure their debian image isn't exactly cutting edge
12:45:11 <flu_> Cale: The problem with that was the error I pasted. cabal-install doesn't build successfully
12:45:24 <Cale> flu_: But yeah, get a newer ghc binary, since 6.8 is rather old.
12:45:32 <Clint> 6.8 is older than debian stable
12:45:49 <hpc> heh, you know it's old when debian stable is newer
12:46:00 <mbetter> lol
12:46:26 <flu_> true story. haha
12:46:48 <flu_> uname -a
12:47:06 <mauke> yep, exitSuccess was added in the 6.10.* branch
12:47:07 <Cale> The generic linux binary of 7.0.4 ought to work rather well, or if you want to be a little more cutting edge, you can go with 7.2.1
12:47:52 <Cale> (or if you want to be conservative, 7.0.3 was blessed by having a Haskell platform built around it)
12:48:03 <Cale> (but 7.0.4 is just bugfixes on top of that)
12:49:32 <flu_> I do love these fat datacenter pipes. 104MB in 14s
13:08:47 <DanBurton> @hoogle (a -> a -> b) -> [a] -> [b
13:08:48 <lambdabot> Parse error:
13:08:48 <lambdabot>   (a -> a -> b) -> [a] -> [b
13:08:48 <lambdabot>                           ^
13:08:49 <DanBurton> doh
13:08:51 <DanBurton> @hoogle (a -> a -> b) -> [a] -> [b]
13:08:53 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
13:08:53 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
13:08:53 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
13:11:39 <DanBurton> Does this exist?
13:12:01 <DanBurton> @let jagMap f (x:y:xs) = f x y : jagMap f (y:xs); jagMap _ _ = []
13:12:02 <lambdabot>  Defined.
13:12:07 <DanBurton> jagMap (+) [1,2,3,4,5]
13:12:12 <DanBurton> > jagMap (+) [1,2,3,4,5]
13:12:14 <lambdabot>   [3,5,7,9]
13:12:27 <alistra> @src map2
13:12:27 <lambdabot> Source not found. stty: unknown mode: doofus
13:12:44 <DanBurton> > map2 (+) [1,2,3,4,5]
13:12:45 <lambdabot>   Not in scope: `map2'
13:13:20 <DanBurton> I guess an alternate definition could be in terms of zipWith and tail
13:13:34 <geheimdienst> > zipWith (+) <*> tail $ [1..5] -- DanBurton: something like this?
13:13:35 <lambdabot>   [3,5,7,9]
13:13:48 <DanBurton> yeah something like that
13:14:37 <DanBurton> > zipWith (+) <*> drop 1 $ []
13:14:38 <lambdabot>   []
13:14:40 <DanBurton> safe :)
13:14:49 <geheimdienst> right, good thinking :)
13:15:45 <geheimdienst> DanBurton: (this works because <*> applies the right function (drop 1) to the list, then gives drop's result *and* the original list into the left function (zipWith (+)))
13:15:53 <DanBurton> > zipWith ((++) `on` show) <*> drop 1 $ [1,2,3,4,5]
13:15:55 <lambdabot>   ["12","23","34","45"]
13:17:42 * DanBurton needs to get more comfortable with the (a ->) instance for Applicative
13:22:22 <DanBurton> :t (<*>) `asAppliedTo` const
13:22:23 <lambdabot> forall a b. (b -> a -> b) -> (b -> a) -> b -> b
13:22:52 <DanBurton> @let dumbFunc :: a -> b -> c; dumbFunc = undefined
13:22:53 <lambdabot>  Defined.
13:22:58 <DanBurton> :t (<*>) `asAppliedTo` dumbFunc
13:22:59 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
13:24:26 <DanBurton> @undefine
13:36:59 * hackagebot atl 15310.92 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15310.92 (MatthewFarkasDyck)
13:57:01 <copumpkin> that's an interesting version number
14:00:28 <geheimdienst> copumpkin: it's just the release date. september 2nd 1531
14:02:58 <alistra> hey
14:03:11 <alistra> sys-apps/less
14:03:12 <alistra>      Available versions:  436 441 ~443 444 ~445 ~445-r1
14:03:26 <alistra> and less doesn't seem overly complicate :D
14:03:29 <alistra> d*
14:06:43 <_Mikey> @google
14:06:43 <lambdabot> Empty search.
14:06:52 <_Mikey> @google how to be super awesome
14:06:55 <lambdabot> http://superawesomeguy.com/
14:06:55 <lambdabot> Title: Super Awesome Guy - the place for all things super awesome
14:06:59 <alistra> @google Empty search.
14:07:01 <lambdabot> http://www.ixda.org/node/17236
14:07:02 <lambdabot> Title: Empty search query: what result? | IxDA
14:07:07 <alistra> @google itle: Empty search query: what result? | IxDA
14:07:08 <lambdabot> http://msdn.microsoft.com/en-us/library/ms584121(v=office.12).aspx
14:07:09 <lambdabot> Title: Search Core Results XSLT Transformation
14:07:16 <alistra> @fix @google
14:07:16 <lambdabot> Maybe you meant: bid faq ft id thx
14:07:21 <alistra> meh
14:07:42 <_Mikey> lol
14:07:52 <_Mikey> how are you alistra
14:08:06 <alistra> good, you?
14:08:20 <_Mikey> I'm ok in the bigger picture I guess
14:08:26 <_Mikey> but worried about my school work
14:08:37 <mbetter> is there a safe maximum function?
14:08:54 <alistra> @hoogle maximum
14:08:54 <lambdabot> Prelude maximum :: Ord a => [a] -> a
14:08:55 <lambdabot> Data.List maximum :: Ord a => [a] -> a
14:08:55 <lambdabot> Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
14:08:57 <rwbarton> maximum (default : whatever)
14:09:27 <mbetter> how does default work?
14:09:33 <rwbarton> default is your default value
14:09:39 <rwbarton> whatever is your possibly empty list
14:09:49 <rwbarton> or maybe I don't understand what you mean "safe maximum"
14:09:51 <rwbarton> *mean by
14:09:54 <geheimdienst> > maximum (42 : [1..5])
14:09:55 <lambdabot>   42
14:09:57 <alistra> maximumDef :: Ord a => a -> [a] -> aSource
14:09:57 <alistra> maximumMay :: Ord a => [a] -> Maybe aSource
14:09:59 <alistra> maximumNote :: Ord a => String -> [a] -> a
14:10:06 <_Mikey> :)
14:10:12 <alistra> import Safe
14:10:38 <alistra> rwbarton: nice troll
14:10:43 <alistra> rwbarton++
14:10:43 <rwbarton> lol
14:10:44 <mbetter> rwbarton: like that
14:10:45 <mbetter> thanks
14:11:02 <mbetter> :)
14:11:11 <alistra> http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/Safe.html
14:11:13 <alistra> :3
14:11:39 <alistra> _Mikey: you're at an uni?
14:11:43 <alistra> or high school?
14:11:46 <_Mikey> Uni
14:11:53 <rwbarton> and note if 'default' is bigger than the maximum of 'whatever' then 'default' will be returned, but in my experience this is probably what you want anyways
14:11:54 <_Mikey> final yea \o/
14:11:59 <_Mikey> @hoogle random
14:12:00 <lambdabot> System.Random class Random a
14:12:01 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
14:12:01 <lambdabot> package random
14:12:30 <_Mikey> @hoogle Int->Int
14:12:31 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
14:12:32 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
14:12:32 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
14:12:48 <_Mikey> @hoogle rand
14:12:49 <lambdabot> package randfile
14:12:49 <lambdabot> System.Random class Random a
14:12:49 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
14:12:57 <mbetter> is there any way to add stuff like Safe to hoogle results?
14:13:01 <aavogt> > let safeMaximum d x = foldr (\ _ _ -> maximum x) d x in sameMaximum 42 [1..5]
14:13:02 <lambdabot>   Not in scope: `sameMaximum'
14:13:08 <alistra> rwbarton: i would use Bounded in that case, but not sure if it's a good idea
14:13:08 <aavogt> > let safeMaximum d x = foldr (\ _ _ -> maximum x) d x in safeMaximum 42 [1..5]
14:13:10 <lambdabot>   5
14:13:12 <alistra> @src Bounded
14:13:12 <lambdabot> class  Bounded a  where
14:13:13 <lambdabot>     minBound, maxBound :: a
14:13:16 <aavogt> > let safeMaximum d x = foldr (\ _ _ -> maximum x) d x in safeMaximum 42 []
14:13:17 <lambdabot>   42
14:13:18 <rwbarton> that is an instance of what I wrote
14:13:20 <alistra> minBound
14:13:25 <_Mikey> alistra, are you still in education?
14:13:25 <rwbarton> but yes it would often be appropriate
14:13:40 <alistra> _Mikey: yes, wroclaw's university :D
14:13:44 <alistra> poland
14:13:48 <ddarius> :t sortBy
14:13:48 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:14:03 <_Mikey> ahh no way
14:14:11 <_Mikey> mowi¢ po polsku
14:14:17 <alistra> lol
14:14:19 <_Mikey> sz*
14:14:27 <_Mikey> I am learning
14:14:32 <_Mikey> just for the hack
14:14:32 <alistra> tak, but what for
14:14:36 <alistra> lol
14:14:43 <ddarius> > let safeMaximum = listToMaybe . sortBy (flip comparing) in (safeMaximum [], safeMaximum [2,1,3])
14:14:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
14:14:54 <alistra> ddarius: there's a module for that :D
14:14:59 <_Mikey> what year are you in?
14:15:01 <ClaudiusMaximus> > let smax = maximum . (Nothing :) . map Just in [smax [], smax [1,2,3]]
14:15:03 <lambdabot>   [Nothing,Just 3]
14:15:03 <alistra> don't reinvent the wheel
14:15:13 <alistra> _Mikey: 4th and last at the same time :D
14:15:26 <_Mikey> same my last is my 4th too
14:15:39 <alistra> doing masters in 4 years! :D
14:15:39 <_Mikey> are you doing anything haskell oriented?
14:15:53 <alistra> well my masters thesis will be this:
14:16:09 <alistra> http://github.com/alistra/data-structure-inferrer
14:16:14 <alistra> it's not finished yet :D
14:16:26 <ddarius> > let safeMaximum = listToMaybe . sortBy (flip compare) in (safeMaximum [], safeMaximum [2,1,3])
14:16:27 <lambdabot>   (Nothing,Just 3)
14:16:49 <alistra> :t maximum
14:16:50 <lambdabot> forall a. (Ord a) => [a] -> a
14:17:13 <alistra> i would do a Monoid m, Ord m => [m] -> m
14:17:16 <_Mikey> alistra, that, is very cool.
14:17:20 <alistra> maximum [] = mempty
14:17:47 <ddarius> alistra: That would be a bad choice.
14:18:03 <alistra> @instances monoid
14:18:03 <lambdabot> Couldn't find class `monoid'. Try @instances-importing
14:18:07 <alistra> @instances Monoid
14:18:07 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:18:39 <alistra> no Int or whatever?
14:18:48 <alistra> ddarius: why?
14:19:14 <mbetter> couldn't int be a couple different monoids?
14:19:17 <ddarius> Because maximum [] = 0, for example, would very much not be what most people want.
14:19:26 <alistra> yeah
14:19:33 <alistra> that's why minBound idea
14:19:36 <alistra> from earlier
14:19:40 <alistra> and Bounded
14:19:53 <mbetter> ooh, i get where you're going
14:20:06 <ddarius> Yes, using Bounded works except that Integers, for example, are not Bounded.
14:20:16 <alistra> well :D
14:20:26 <alistra> import Safe
14:20:41 <alistra> i've even written the Safe.Foldable part
14:20:41 <mbetter> yeah, import Safe solved my immediate problem :)
14:20:44 <alistra> so go use it lol
14:20:55 <mbetter> is there a way for me to find that on my own?
14:21:07 <mbetter> like, get hoogle to search more packages?
14:21:46 <alistra> i don't know, mine doesn't search the safe module
14:22:28 <alistra> _Mikey: you from?
14:25:09 <MostAwesomeDude> If I'm building a state machine which eats an indefinite list of data packets and replies with an indefinite list of data packets, what's the right way to design that machine? Cont?
14:25:38 <shachaf> If Cont is the answer, you're probably asking too general a question.
14:25:41 <MostAwesomeDude> (The data packets are hooked up to an iteratee structure on a socket. That part appears to all work.)
14:26:04 <alistra> Cont is the continuation monad?
14:26:06 <alistra> @src Cont
14:26:07 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
14:26:44 <alistra> MostAwesomeDude: can't it just be a function
14:26:44 <shachaf> Well, it's a CPS type which happens to be a monad. :-)
14:26:50 <alistra> that lazily converts the packets?
14:27:11 <MostAwesomeDude> Well, I don't think in Haskell yet. I'm thinking in Scheme still, and set!
14:27:35 <MostAwesomeDude> The idea is that the packets are modifying state, and the packets which are returned are representing that state.
14:27:37 <alistra> so try like lazy function
14:27:39 <shachaf> MostAwesomeDude: You can use State, possibly. You haven't given enough information for people to give a good answer.
14:28:02 <mbetter> so there's something else going on besides the packets
14:28:13 <alistra> is it always one in packet - one out packet?
14:28:21 <MostAwesomeDude> shachaf: I'm building a network server. I have a couple little things I've built which latch onto a Socket and (eventually) want to repeatedly call something :: Packet -> [Packet]
14:28:30 <MostAwesomeDude> It's one packet in, zero or more packets out.
14:28:39 <MostAwesomeDude> Until one side decides to end the connection.
14:28:57 <alistra> so do like a concatMap on the infinite list
14:28:58 <alistra> or something
14:29:08 <shachaf> MostAwesomeDude: And there's also some state, so it's something like Packet -> Foo -> ([Packet],Foo)?
14:29:11 <alistra> concatMap something packetlist
14:29:25 <MostAwesomeDude> My question is: My packet handler needs to store state somehow, based on packets it's seen before; how do I do that effectively?
14:29:26 <alistra> concatMapM something packetlist? not sure :D
14:29:33 <shachaf> Or is something actually a function :: Packet -> [Packet]?
14:29:38 <MostAwesomeDude> shachaf: Right.
14:29:49 <shachaf> MostAwesomeDude: Well, that's what State is.
14:29:51 <mbetter> sounds like State
14:30:02 <shachaf> @unmtl State Foo [Packet]
14:30:02 <lambdabot> Foo -> ([Packet], Foo)
14:30:02 <alistra> @hoogle concatMapM
14:30:02 <lambdabot> No results found
14:30:27 <_Mikey> @hoogle MonadIO
14:30:28 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
14:30:28 <lambdabot> package monadIO
14:30:33 <shachaf> alistra: I think MostAwesomeDude is looking for general ideas on how to write this thing, more than one particular function which will do it in 1 line instead of 3.
14:30:44 <shachaf> Will do one small component of it, rather.
14:31:04 <MostAwesomeDude> Yeah, I am. I'm still trying to get my head around what the fundamental unit of networking is, in Haskell.
14:31:20 <alistra> yeah, do State as they say :D
14:31:26 <MostAwesomeDude> In most languages, it's sockets. (Ugh.) In some nice libraries, it's protocols. I gather that in Haskell it's some kind of special monad.
14:31:37 <alistra> it's a sugar coating of passing the stuff around
14:32:02 <shachaf> MostAwesomeDude: Sockets and protocols exist in Haskell.
14:32:18 <MostAwesomeDude> shachaf: There are protocols? I didn't know this. Could you point me at the docs?
14:32:20 <shachaf> I'm not sure what your question is. A "monad" is just a particular API for a type of library.
14:32:33 <shachaf> MostAwesomeDude: Er, well, I'm not sure what you mean by "protocol".
14:32:56 <MostAwesomeDude> A protocol's an object that stores its own state, is fed a stream of bytes, and replies with a stream of bytes.
14:33:33 <alistra> hackage is full of funky stuff
14:33:38 <alistra> :p try your luck
14:33:52 <MostAwesomeDude> Haven't found anything yet, read through the entire Network category.
14:34:09 <geheimdienst> MostAwesomeDude: maybe you're looking for this http://hackage.haskell.org/package/network-2.3.0.2 there's also higher-level stuff, like an HTTP package
14:34:11 <shachaf> MostAwesomeDude: Oh. Well, you can use State for that. Or a function (a,s) -> (a,s). Or whatever else.
14:34:15 <_Mikey> newb question..
14:34:16 <alistra> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/Acme-Time-Now.html <- lol those
14:34:40 <_Mikey> does Control.MonadIO come with ghc
14:34:48 <MostAwesomeDude> geheimdienst: Already found that, there's nothing in there specifically at this level. Thanks though. (I'm not doing HTTP.)
14:35:11 <alistra> _Mikey: not in my ghc apparently
14:35:11 <mbetter> are you talking about parsing?
14:35:22 <_Mikey> mine either
14:35:23 <_Mikey> oh wells
14:35:59 <mbetter> have you looked at Data.Attoparsec?
14:36:04 <alistra> cabal isntall monadIO
14:36:42 <MostAwesomeDude> mbetter: Already built an Attoparsec parser, hooked it up to iterIO iteratees and enumerators, and have a successful pipeline which transforms bytes into Packets, and then back into bytes.
14:37:48 <_Mikey> ahh  thanks. there was me apt-cache searching for a package :p
14:47:51 <alistra> time is what turns kittens into cats
14:56:47 <MostAwesomeDude> Hm. So if I understand correctly, a function which returns a list, and internally uses the State monad, can incrementally build up that list and return single values from it, right? Like a generator in other languages?
14:57:06 <shachaf> MostAwesomeDude: What does "internally uses the State monad" mean?
14:57:58 <MostAwesomeDude> shachaf: Well, thinking about my problem, I'm imagining the data as [Packet] -> [Packet]. A stream of packets comes in, a stream of packets goes out. However, I want to return quite a few packets "early"; that is, as soon as possible.
14:58:12 <MostAwesomeDude> *And*, the computation going on internally is stateful.
14:58:44 <shachaf> MostAwesomeDude: Maybe something like mapAccumL will be sufficient for you. :-)
14:59:58 <MostAwesomeDude> That...is a very elegant way of thinking about the problem.
15:00:21 <ddarius> :t let interactPacket f = foldr (\packet state -> (f packet state ++)) in interactPacket
15:00:21 <lambdabot> forall a m. (Monoid m) => (a -> (m -> m) -> m) -> (m -> m) -> [a] -> m -> m
15:00:56 <shachaf> Or what ddarius said.
15:00:59 <ddarius> Not quite what I wanted.
15:01:06 <shachaf> Well, something along those lines.
15:02:26 <ddarius> :t let interactPacket f = foldr (\packet ~(state,rest) -> fmap (++rest) (f packet state) in interactPacket
15:02:26 <lambdabot> parse error on input `in'
15:02:34 <ddarius> :t let interactPacket f = foldr (\packet ~(state,rest) -> fmap (++rest) (f packet state)) in interactPacket
15:02:34 <lambdabot> forall a t m. (Monoid m) => (a -> t -> (t, m)) -> (t, m) -> [a] -> (t, m)
15:02:50 <ddarius> :t let interactPacket f = foldr (\packet ~(state,rest) -> fmap (Prelude.++rest) (f packet state)) in interactPacket
15:02:51 <lambdabot> forall a t a1. (a -> t -> (t, [a1])) -> (t, [a1]) -> [a] -> (t, [a1])
15:02:57 <MostAwesomeDude> I'd need a foldl, wouldn't I?
15:03:21 <ddarius> :t let interactPacket f = snd . foldr (\packet ~(state,rest) -> fmap (Prelude.++rest) (f packet state)) . (,[]) in interactPacket
15:03:21 <lambdabot> Illegal tuple section: use -XTupleSections
15:03:35 <ddarius> :t let interactPacket f = snd . foldr (\packet ~(state,rest) -> fmap (Prelude.++rest) (f packet state)) . flip (,) [] in interactPacket
15:03:36 <lambdabot>     Couldn't match expected type `(a, b)'
15:03:36 <lambdabot>            against inferred type `[a1] -> (t, [a2])'
15:03:36 <lambdabot>     In the first argument of `(.)', namely
15:04:40 <shachaf> MostAwesomeDude: It's unlikely that you want a foldl.
15:04:48 <Axman6> lambdabot: U NO TUPLESECTIONS?!?!?
15:04:56 <MostAwesomeDude> But don't I want to start with the first packet that comes in?
15:05:00 <ddarius> :t let interactPacket f = snd .: foldr (\packet ~(state,rest) -> fmap (Prelude.++rest) (f packet state)) . flip (,) [] in interactPacket
15:05:00 <Axman6> :t mapAccumL
15:05:00 <lambdabot> forall a a1 a2. (a -> a1 -> (a1, [a2])) -> a1 -> [a] -> [a2]
15:05:02 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:05:13 <Axman6> :t mapAccumR
15:05:14 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:07:04 <shachaf> @ty \f z -> concat . snd . mapAccumL f z
15:07:05 <lambdabot> forall a a1 x. (a1 -> x -> (a1, [a])) -> a1 -> [x] -> [a]
15:07:29 <ddarius> > mapAccumL (\acc x -> (f acc x, g acc x)) a [x,y,z]
15:07:29 <lambdabot>   Ambiguous type variable `y' in the constraints:
15:07:29 <lambdabot>    `GHC.Show.Show y'
15:07:30 <lambdabot>      a...
15:07:37 <ddarius> > mapAccumL (\acc x -> (f acc x, g acc x)) a [x,y,z] :: Expr
15:07:37 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:07:38 <lambdabot>         against inferred ...
15:07:44 <ddarius> > mapAccumL (\acc x -> (f acc x, g acc x)) a [x,y,z] :: (Expr, [Expr])
15:07:46 <lambdabot>   (f (f (f a x) y) z,[g a x,g (f a x) y,g (f (f a x) y) z])
15:07:54 <ddarius> > mapAccumR (\acc x -> (f acc x, g acc x)) a [x,y,z] :: (Expr, [Expr])
15:07:54 <lambdabot>   (f (f (f a z) y) x,[g (f (f a z) y) x,g (f a z) y,g a z])
15:08:01 <MostAwesomeDude> Hm. So mapAccumL would let me map the input packets to the output packets, bundling state, but it wouldn't let me output more packets than I take in.
15:08:23 <shachaf> MostAwesomeDude: That's what the concat is for.
15:08:24 <ddarius> MostAwesomeDude: You just "output" a list of packets. y /= x necessarily.
15:08:54 <ddarius> And yes, you'd follow with concat of the list of packets and discarding the "final" state.
15:09:17 <MostAwesomeDude> Oh! Because "y" in the type of mapAccumL would be [Packet], not Packet.
15:10:04 <MostAwesomeDude> This...is actually a way cooler idea than the previous plan.
15:10:56 <ddarius> > let interactPacket f init = go init where go _ [] = []; go s (p:ps) = ps' ++ go s' ps where (ps', s') = f (p, s) in interactPacket
15:10:56 <lambdabot>   Overlapping instances for GHC.Show.Show
15:10:57 <lambdabot>                              (((t, ...
15:11:06 <ddarius> :t let interactPacket f init = go init where go _ [] = []; go s (p:ps) = ps' ++ go s' ps where (ps', s') = f (p, s) in interactPacket
15:11:07 <lambdabot> forall t t1 a. ((t, t1) -> ([a], t1)) -> t1 -> [t] -> [a]
15:12:41 <MostAwesomeDude> And then if I want to signal that I'm done... I could use Maybe? And that'd let me signal early that I'm done with the client and wish to disconnect them.
15:13:08 <MostAwesomeDude> But that's getting ahead of myself. I'm gonna see if I can get all this stuff put together. You guys rock.
15:16:40 <sealrasegan> hi
15:16:42 <shadyp\> are rewrite rules the right way to go? why isn't it possible to find the optimal asm-level description based on high level code?
15:17:26 <Axman6> because that's almost certainly an NP hard problem?
15:17:55 <sealrasegan> I need help to resolve a problem
15:18:12 <Axman6> sealrasegan: we can't help unless you tell us what the problem is
15:18:45 <shadyp\> Axman6: are you aware of any research in the field of that kind of stuff?
15:18:55 <sealrasegan> I'm portuguese so sorry for my english :s
15:19:02 <shadyp\> it just feels so dumb to make rewrite rules for everything
15:19:26 <Axman6> there should't be much need to write rewrite rules everywhere
15:19:36 <Axman6> look into supercompilation
15:20:45 <sealrasegan> I have to make a State type an instance of show class. this instance only print a actual position
15:21:06 <shadyp\> if it's in NP, then why aren't heuristics used?
15:21:13 <sealrasegan> I have created a type of State
15:21:14 <Botje> sealrasegan: you probably want to runState with some given state instead
15:21:56 <sealrasegan> data State = Initial Float | Iter_1 Float Float | AnyIter Float Float Float
15:21:58 <Axman6> shadyp\: you try implementing it and find out =)
15:22:01 <sealrasegan> I created this
15:22:05 <Botje> oh
15:22:12 <Botje> it's not the built-in state
15:22:15 <Botje> okay, carry on.
15:22:18 <Axman6> you could just ass deriving Show to the end of that line
15:22:20 <monochrom> data State = Initial Float | Iter_1 Float Float | AnyIter Float Float Float deriving Show
15:22:21 <Axman6> add*
15:22:42 <sealrasegan> no I can't
15:22:54 <monochrom> why?
15:23:23 <sealrasegan> because I can only print the initial position
15:23:34 <Axman6> instance Show State where show (Initial a) = show a; show (Iter_1 a b) = show a ++ ", " ++ show b ...
15:23:34 <monochrom> I am not convinced.
15:23:41 <mbetter> ?
15:24:27 <sealrasegan> what means ++ in show a ++
15:24:45 <Axman6> > [1,2,3] ++ [4,5,6]
15:24:47 <lambdabot>   [1,2,3,4,5,6]
15:24:52 <sealrasegan> ahh ok
15:24:56 <Axman6> > "hello " ++ "world!"
15:24:58 <lambdabot>   "hello world!"
15:25:18 <sealrasegan> ok
15:28:06 <sealrasegan> Asman6: thanks for the help I resolced my problem
15:28:14 <sealrasegan> *resolved
15:39:33 <MostAwesomeDude> ddarius, shachaf : Success! Things appear to work. That insight about mapAccumL fitting the pattern I needed was really awesome.
15:39:50 <acowley> I have a little module that provides a scosche of help for working Storables. I use it in a lot of projects, but don't know where to put the darn thing.
15:51:27 <sealrasegan> I have this function ƒb(x) = bx(1-x) to define, and made this -- functionL a b = a*b(1-b) --, this is correct???
15:51:53 <MostAwesomeDude> Homework?
15:52:24 <sealrasegan> no project
15:53:53 <JoeyA> When specifying flags to GHC, is it possible to start with -Wall and disable select warnings?
15:54:11 <aavogt> just put those -fno-warn flags after
15:54:20 <JoeyA> e.g. -Wall -fno-warn-name-shadowing
15:55:04 <JoeyA> Ah, it does work.
15:55:26 <JoeyA> I recall a -fno flag not working in some other context.
15:58:11 <Axman6> sealrasegan: you forgot the second *: a*b*(1-b)
16:11:26 <lars__> what emacs mode do you use for haskell?
16:11:55 <homie> ,mm ?
16:13:01 <lars__> haskell-mode is pretty broken, i have to switch back to vim now...
16:17:52 <Axman6> i've seen quite a few uploads of haskell-mod to hackage lately
16:22:05 <acowley> What's wrong with haskell-mode?
16:22:06 <zmv> emehcs
16:22:49 <acowley> Am I in a zombie state wherein one fateful day I will update haskell-mode and all my computers will stop working?
16:23:16 <zmv> GNUH Emehcs
16:23:18 <zmv> :D
16:23:46 <LazyBurr> Feels odd asking this, but where's Haskell implemented nowadays?
16:23:57 <LazyBurr> I've heard it's an older language, and isn't used as often as Ruby.
16:24:26 <mauke> heh
16:24:30 <zmv> reminds me of...
16:24:31 <mauke> guys, haskell is old now
16:24:35 <zmv> @protontorpedo
16:24:35 <lambdabot> is there an oo db in haskell?
16:24:38 <zmv> :D
16:24:38 <Saizan> i don't see the connection between the two statements
16:24:52 <zmv> @protontorpedo
16:24:52 <lambdabot> I hear from an essay by E raymod that perl is shitty for large projects
16:24:58 <LazyBurr> When asking around about it I've been given the vibe that it's not used any more.
16:24:58 * monochrom does not understand the "is it homework?" question. what difference does it make? it is not like you have no life and you seek to do other people's work be it homework, job work, toy work, or rule the world work anyway.
16:25:06 <acowley> LadyBurr: Haskell is the language, most people use the GHC compiler which is implemented all over the world, but whose core developers are at MSR UK.
16:25:24 <Veinor> i think haskell's 'mindshare' has actually been going up lately
16:25:26 <LazyBurr> Thanks, was just curious.
16:25:57 <zmv> @protontorpedo
16:25:57 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
16:25:58 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
16:26:10 <zmv> lol, that was a pretty long one.
16:26:25 <Veinor> what's @protontorpedo
16:26:35 <zmv> dumb questions, it seems
16:26:36 <Axman6> LazyBurr: it's populartiy has been growing a lot in recent years
16:26:50 <mauke> Veinor: quotes from a particular troll
16:27:01 <Veinor> ah
16:27:16 <acowley> to be fair, that's fairly inspired trolling
16:27:30 <LazyBurr> Is it similar to Perl?
16:27:52 <mauke> yes, both languages use $ signs
16:27:56 <Axman6> heh
16:28:00 <Draconx> acowley, the good trolls usually are.
16:28:03 <LazyBurr> I'm not even in university yet, I'm still a high schooler, but I figured I should at least begin to get a grasp on multiple languages before going into that field.
16:28:07 <LazyBurr> :P
16:28:09 <ddarius> Perl was implemented in Haskell and Haskell was implemented in Perl.
16:28:19 <monochrom> they're both ascii files. actually I lie. haskell can be unicode files.
16:28:21 <LazyBurr> So they're similar in style?
16:28:28 <zmv> LazyBurr: yeah.
16:28:32 <ddarius> monochrom: Haskell source is Unicode.
16:28:34 <mauke> Perl was never implemented in Haskell
16:28:36 <Veinor> they're similar in that they consist of human-readable text
16:28:41 <Axman6> ddarius: at first I laughed, and then i was a little sad when i realised it was true
16:28:41 <mauke> I don't know about the Haskell in Perl part
16:28:47 <Axman6> Pugs?
16:28:52 <russellw> LazyBurr, people are taking the piss because they think you're a troll
16:28:53 <mauke> pugs was perl6, not perl
16:28:58 <zmv> Veinor: human and compiler/interpreter-readable
16:28:58 <LazyBurr> I'm not, even.
16:29:01 <LazyBurr> ;_;
16:29:07 <mauke> Perl source is unicode as well!
16:29:08 <russellw> Actually Haskell and Perl are more or less at opposite ends of the language spectrum
16:29:17 <LazyBurr> Ah.
16:29:18 <Axman6> LazyBurr: Perl and Haskell are very different languages
16:29:23 <LazyBurr> Thanks!
16:29:27 <russellw> Haskell is all about correctness and mathematical elegance, Perl is all about quick and dirty duct tape
16:29:36 <mauke> russellw: I disagree
16:29:47 <LazyBurr> But Haskell is not as strict as other languages, I've been told.
16:29:52 <mauke> hahaha
16:30:00 <russellw> As for people not using Haskell anymore, that's fairly bizarre statement, its star is still rising. Are you sure they didn't think you were talking about Pascal?
16:30:02 <zmv> Perl is not quick and dirty duct tape. It's dirty duct tape.
16:30:08 <Rotaerk> LazyBurr, strict/lazy have technical meanings
16:30:11 <Axman6> russellw: i disagree too, it's all about using duct tape, but using as little, in as confusing a way as possible
16:30:11 <Veinor> LazyBurr: this is true but not in the way that you interpret 'strict'
16:30:23 <LazyBurr> How should I interpret "strict," then?
16:30:34 <zmv> LazyBurr: you probably were informed about laziness OR implicit typing then
16:30:36 <Rotaerk> LazyBurr, it refers to the kind of evaluation it uses
16:30:44 <mauke> LazyBurr: a function f is strict in its argument if f ⊥ == ⊥
16:31:16 <LazyBurr> Ah.
16:31:34 <LazyBurr> I had just assumed it was syntax related.
16:31:38 <Rotaerk> LazyBurr, when an expression is lazy, it's evaluation outside-in; if it's strict it's evaluated inside out
16:31:48 <russellw> LazyBurr, whereas in the ordinary English meaning of the word strict, Haskell is among the strictest of all programming languages
16:31:58 <LazyBurr> Fun stuff.
16:32:11 <LazyBurr> What does the term "functional" mean, in programming context, then?
16:32:11 <Axman6> LazyBurr: laziness (which is what your questions is really about) means that haskell programs don't compute anything that's not necessary to the answer, even if you happen to write that it can do more than it needs
16:32:11 <russellw> It tries to get you to make your code mathematically correct to a greater extent than other programming languages, that is
16:32:14 <zmv> LazyBurr: and that's why we like Common Lisp/Scheme...
16:32:20 <acowley> LazyBurr: you may find a properly written tutorial helpful as a companion piece to the scattered slogans heard here
16:32:22 <zmv> oh, wrong channel *trollface*
16:32:39 <Axman6> this means we can do things like make an infinite list of prime numbers, in a very elegant way, but we only compute as many prime numbers as we need
16:32:51 <LazyBurr> Heh.
16:32:58 <LazyBurr> It's nice to get answers from humans, though
16:33:11 <Axman6> > 1 + 1 -- Look, Haskell!
16:33:13 <lambdabot>   2
16:33:18 <acowley> LazyBurr: try working through http://learnyouahaskell.com/ to get a concrete feel for the language, and ask questions here
16:33:27 <Axman6> > map toUpper "LazyBurr"
16:33:28 <lambdabot>   "LAZYBURR"
16:33:33 <mauke> LazyBurr: I don't think you'll understand much about the answers if you don't learn a bit of haskell
16:33:33 <monochrom> "functional" means we are not afraid of functions.
16:33:39 <LazyBurr> I'm going through the tryhaskell.org stuff.
16:33:52 <LazyBurr> Will do, thanks for bothering yourselves for my questions, though.
16:34:16 <monochrom> for example COBOL is afraid of functions, that's why it is not functional.
16:34:16 <Rotaerk> LazyBurr, if it's lazy 1+(2+(3+4)) will first try to evaluate the leftmost + operation on 1 and the expression (2+(3+4)), then it'll find that it needs to evaluate that, so it will try to evaluate the next + on 1 and (3+4)
16:34:20 <Axman6> that's what we're here for LazyBurr
16:34:23 <zmv> > ':' : ')'
16:34:24 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:34:24 <lambdabot>         against inferred ty...
16:34:39 <Rotaerk> LazyBurr, if it's strict it won't even call the outermost + until the (2+(3+4)) expression is resolved
16:34:47 <zmv> lambdabot: stfu
16:34:54 <acowley> I actually came for the buffet
16:35:06 <Rotaerk> LazyBurr, the distinction is not as important in that expression I guess, but it is in other cases...
16:35:21 <zmv> monochrom: COBOL has functions? :P
16:35:36 <monochrom> probably not. very afraid.
16:35:47 <LazyBurr> That one actually made more sense than the others, Rotaerk.
16:35:53 <LazyBurr> Again, thanks.
16:36:09 <zmv> Rotaerk: meh, I have (+ 1 2 3 4) :D
16:36:14 <Rotaerk> :P
16:36:26 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1000
16:36:27 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
16:36:35 <Axman6> zmv: how ugly
16:36:37 <mauke> > take 10 [1 ..]
16:36:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:36:40 <LazyBurr> I do know that that was a Fibonacci sequence, yes?
16:36:48 <Axman6> yep
16:36:52 <mauke> > take 10 (filter even [1 ..])
16:36:53 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:36:54 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
16:36:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:36:57 <zmv> Axman6: NO U :P
16:37:14 <Axman6> how gly?
16:37:23 <Axman6> =)
16:37:24 <LazyBurr> Does lambdabot do it with generator functions?
16:37:27 <Rotaerk> heh I find it amusing how fibonacci is so often used to relate the concept of recursion, when it can be implemented without recursion
16:37:45 <Rotaerk> and there are probably more intuitive ways to relate the concept
16:37:48 <MostAwesomeDude> LazyBurr: Are you thinking of Python generators?
16:37:52 <ddarius> Rotaerk: Everything can be implemented without recursion.
16:37:57 <LazyBurr> Yes?
16:38:08 <Rotaerk> ddarius, really?
16:38:10 <Axman6> python generators are a crappy way of doing what Haskell does naturally, thanks to lazy evaluation
16:38:10 <zmv> seriously, though, Haskell is the hottest non-Lisp programming language
16:38:31 <mauke> LazyBurr: lambdabot just uses normal haskell lists
16:38:36 <MostAwesomeDude> LazyBurr: Ah. Imagine that everything in Python is a generator by default.
16:38:38 <Veinor> Rotaerk: sure
16:38:41 <MostAwesomeDude> That's kinda like Haskell.
16:38:41 <LazyBurr> OK.
16:38:47 <zmv> Axman6: s/generators are/is/
16:38:53 <monochrom> Haskell lazy list supersedes generators.
16:39:14 <mauke> four corner harmonious earth rotation
16:39:14 <zmv> Axman6: WIN
16:39:18 <Axman6> zmv: touché
16:39:49 <MostAwesomeDude> mauke: Simultaneous time intersections rotating around a four-sided planet.
16:39:59 <Rotaerk> ddarius / Veinor: how?
16:40:02 <monochrom> the following makes an infinite list (repeat 'x') and then asks for just the first 5 items (take 5). it does not take infinite time:
16:40:07 <monochrom> > take 5 (repeat 'x')
16:40:09 <lambdabot>   "xxxxx"
16:40:11 <Axman6> LazyBurr: you might hear a lot of people saying you need to be quite good at maths to be good at haskell. Don't listen to them, any maths you'll need to use you'll learn while learning haskell, and not even know it
16:40:21 <Veinor> Rotaerk: while loop
16:40:24 <Veinor> s
16:40:45 <Rotaerk> loops are just a referentially opaque way to express recursion
16:40:48 <LazyBurr> I'm taking AP Calculus BA right now.
16:41:03 <zmv> there's no such thing as "quite good at maths".
16:41:13 <zmv> you can know math, or you can not now it.
16:41:13 <LazyBurr> I'm not bad at math.
16:41:14 <Veinor> which are both referentially opaque ways to express a jump/branch
16:41:31 <zmv> s/ n/ kn/
16:41:38 <Rotaerk> Veinor, recursion isn't referentially opaque...
16:41:42 <acowley> If I can't now math, can I later it?
16:41:44 <Veinor> zmv: or you can knot now it
16:41:47 <zmv> seriously, if you know any math, you know all math.
16:42:00 <LazyBurr> I don't think so.
16:42:11 <Rotaerk> and a jump/branch is an implementation detail
16:42:18 <Veinor> Rotaerk: my point is that calling while loops an instance of recursion is silly
16:42:24 <LazyBurr> I didn't know what 7i meant until I took algebra.
16:42:32 <zmv> just not consciously :P
16:42:39 <Rotaerk> Veinor, it's not an instance, it's a way of expressing it, referentially opaquely
16:42:40 <LazyBurr> So I did not know all math when I knew how to add 2 and 2.
16:42:43 <acowley> I think the more I learn the more I understand I don't know. I've never met anyone who knows "all math."
16:42:45 <Axman6> LazyBurr: it could mean many different things actually =)
16:42:51 <LazyBurr> This is true.
16:42:51 * monochrom is quite good at maths
16:43:05 <LazyBurr> I know that i = imaginary number
16:43:08 <acowley> monochrom: don't me modest, you know ALL MATH!
16:43:14 <LazyBurr> Different from real and regular numbers.
16:43:23 <monochrom> no, I still don't know about exact sequences
16:43:29 <LazyBurr> But that's about all I care about i.
16:43:34 <Rotaerk> Veinor, alternatively, recursion is a referentially transparent way of expressing loops
16:43:41 <Veinor> sure!
16:43:44 <acowley> this definition if ALL is inexact, so you're safe
16:43:47 <acowley> s/if/of
16:43:57 <Veinor> i'm just saying there's no justification for saying one is primitive and the other isn't aside form taste
16:44:22 <Axman6> LazyBurr: complex numbers turn out to be super useful in many different areas, anywhere you're wokring with sinusiods (so, all AC electronics for example)
16:44:26 <monochrom> denotational semantics maps loops to recursions.
16:44:30 <Lemmih> Does it make sense to say "all math" given Godel's incompleteness theorem?
16:44:35 <monochrom> operational semantics maps recursions to loops.
16:44:40 <Rotaerk> Veinor, they're equivalent concepts, in terms of power, I think
16:44:51 <Veinor> yeah.
16:44:57 <LazyBurr> Why would I be working with blood vessels..?
16:45:08 <Veinor> i guess it's like the difference between a turing machine and some other turing-equivalent computation model
16:45:11 <LazyBurr> Computer programming =/= biology
16:45:15 <Rotaerk> my point was just that saying "you can do it in terms of loops" is a snide way to answer my question of how to do "everything" without recursion
16:45:46 <Rotaerk> that's like saying "how can you do this without tomatos?" "you can use tomAHtos instead!"
16:45:47 <acowley> Phlebotomist is between Functor and Applicative.
16:45:48 <Veinor> it depends on whether you're talking from a programmer point of view or a CS point of view
16:46:02 * monochrom uses potahtoes
16:46:35 <ddarius> Rotaerk: Implement arbitrary precision fibonacci without loops or recursion.
16:46:47 <zmv>  /me used to use potatoes, but now uses Kartoffeln :D
16:46:58 <zmv> damn you space bar
16:46:59 <zmv> ):
16:47:13 * monochrom suggests Rotaerk to use fixed points.
16:49:29 <Rotaerk> ddarius, what do you mean by "precision"? they're all integers
16:50:08 <monochrom> arbitrary precision means you choose an arbitrary precision, for example you can choose "just 1 bit". :)
16:51:08 <ddarius> Rotaerk: Implement a fibonacci function that accurately returns all fibonacci numbers for all non-negative integer inputs without loops or recursion.
16:51:49 <MostAwesomeDude> Isn't there a closed form for Fibs?
16:52:10 <Ke> yes
16:52:13 <ddarius> MostAwesomeDude: Yes, but square rooting and/or exponentiating use loops.
16:52:38 <Veinor> ddarius: infinitely large lookup table!
16:52:49 <ddarius> Veinor: We call those functions.
16:52:53 <Rotaerk> ddarius, but that's just an implementation detail of those functions
16:53:04 <Rotaerk> they aren't loops as far as the sequence is concerned
16:53:45 <Rotaerk> and their complexity is O(1) relative to the index in the sequence
16:53:46 <ddarius> For all f, make a function g = f, then say g is just an implementation detail of f and f does not use recursion.
16:53:47 <hpc> ddarius: fib = (fibs !!) -- :D
16:54:35 <int80_h> in the course of building out my project, I have found that a tuple I use as an intermediate data type has grown to four values (a,b,c,d). Is this a code smell?
16:55:04 <Rotaerk> ddarius, the point is just that the complexity of the square rooting and exponentiating is independent of N where N is the sequence index
16:55:05 <hpc> int80_h: yes
16:55:10 <hpc> int80_h: use a record
16:55:11 <monochrom> you are better off dictating a fully specified computational model than just saying "don't use xxx or yyy".
16:55:32 <ddarius> Rotaerk: I'm awaiting your implementation.
16:55:53 <hpc> int80_h: in general, once you move past tuples, you should be using a record
16:55:57 <int80_h> hpc: thanks!
16:56:24 <Rotaerk> I take it, by the fact that you've presented it as a challenge, that floating point error becomes a problem, since the expression depends on some irrational constants?
16:56:26 <hpc> exceptions for stuff like some monad with aspects of (State (a, b))
16:56:46 <hpc> where you can feel free to use a triple to keep yourself from going insane, but other than that.. :P
16:56:47 <int80_h> hpc: I've seen three value tuples used in hackage libraries, so I didn't think anything of that. But now I need to track another value, four seemed wrong.
16:57:02 <ddarius> Rotaerk: I want it to be correct.  That is what "accurate" means.  If you only want to correctly support a finite number, then you can do that with a look-up table in constant-time.
16:57:05 <hpc> @unmtl State (a, b) c
16:57:06 <lambdabot> a -> b -> (c, a, b)
16:57:13 <ddarius> And quite definitely without loops or recursion.
16:57:19 <hpc> ^ the only kosher triple i can think of offhand
16:57:40 <Rotaerk> ddarius, ah
16:57:53 <int80_h> hpc: the calendar library uses triples
16:57:56 <acowley> I think triples are almost legit, but the lack of standard projections casts a shade of shame.
16:58:06 <hpc> int80_h: ah, that makes sense too
16:58:13 <int80_h> Data.Time.Calendar
16:58:15 <int80_h> ya
16:58:15 <hpc> (Day, Month, Year) is a fine type
16:58:39 <int80_h> that's where I got the idea, but I htink I've pushed the bounds of good sense. Wasn't sure so I came here. Thanks for the input :).
16:58:48 <hpc> oh, fun game:
16:59:01 <hpc> instead of using '_' to represent patterns you don't care about, use 'undef'
16:59:11 <hpc> see how long it takes for another haskell programmer to punch you in the nose
16:59:14 <int80_h> undef is new to me
16:59:33 <int80_h> :t undef
16:59:34 <lambdabot> Not in scope: `undef'
16:59:35 <Rotaerk> ddarius, yea if you were to calculate the irrational constants to a precision that would result in it being accurate at high indices, then I suppose the calculation of the constants themselves would take on a complexity > O(1)
16:59:38 <ddarius> hpc: The compiler will before a Haskeller gets to you.
16:59:39 <hpc> int80_h: in perl, it's how you signify "i don't care" in a pattern match
16:59:40 <monochrom> for example "f _ _ [] = []" -> "f undef undef [] = []"?
16:59:56 <hpc> undef ~~ null
16:59:58 <Rotaerk> since high N means high precision for the constants
17:00:58 <int80_h> what's the advantage of undef over conventional pattern-matching techniques?
17:01:19 <int80_h> better clarity?
17:01:42 <hpc> int80_h: there is none
17:01:54 <hpc> int80_h: it's one of those "write X in any language" things
17:01:58 <monochrom> you get a punch. not sure if it's an advantage
17:02:22 <hpc> int80_h: it's like the newbies who write all their code as f(foo, bar)
17:02:32 <hpc> (haskell newbies, rather)
17:02:34 <roconnor> what you do get is a bunch of warning about unused bound variables
17:02:36 <int80_h> After some consideration, I've come to the conclusion that being punched is not desirable.
17:02:52 <XexonixXexillion> At what level of optimisation does GHC use tail call optimisation?
17:03:00 <roconnor> and other errors for binding the same variable twice
17:03:02 <Draconx> > let f undef undef [] = [] in f () () []
17:03:03 <lambdabot>   Conflicting definitions for `undef'
17:03:04 <lambdabot>  Bound at: <interactive>:1:6-10
17:03:04 <lambdabot>        ...
17:03:08 <roconnor> and a punch
17:03:27 <shachaf> @ty let f _x _x = () in f
17:03:28 <lambdabot>     Conflicting definitions for `_x'
17:03:28 <lambdabot>     Bound at: <interactive>:1:6-7
17:03:29 <lambdabot>               <interactive>:1:9-10
17:03:31 <Draconx> > let f _ _ [] = [] in f () () []
17:03:32 <lambdabot>   []
17:03:36 <shachaf> @ty let f _x = _x in f
17:03:37 <lambdabot> forall t. t -> t
17:03:52 <ddarius> XexonixXexillion: Tail call optimization is misnamed.  It's not an optimization, it's just not implementing functions stupidly.  GHC always "optimizes" tail calls.
17:04:33 <monochrom> you could say that about almost all optimizations
17:04:38 <shachaf> ddarius: In some languages/contexts I'd consider it an optimization.
17:04:45 <Draconx> ddarius, well, in some popular languages it requires proving that the function does not do certain things.
17:05:01 <MostAwesomeDude> And in some languages, that proof is not possible.
17:05:05 <hpc> ddarius: i thought lazy evaluation made tail recursion unperformant
17:05:12 <ddarius> hpc: You thought wrong.
17:05:15 <roconnor> I don't even know what TCO means in haskell. Calling a function doesn't push a stack frame, so what is there to optimize?
17:05:32 <ddarius> roconnor: Calling a function in C doesn't push a stack frame either.
17:05:49 <roconnor> ddarius: where do the local variables go?
17:06:03 <ddarius> roconnor: I'm pretty sure the C specification doesn't say.
17:06:08 <hpc> roconnor: over there --> ;)
17:06:08 <Draconx> ddarius, a function in C can store a pointer to a local variable and then perform a tail call.
17:06:12 <MostAwesomeDude> It is a mystery~
17:06:35 <shachaf> The C specification doesn't mention anything about a stack, does it?
17:06:38 <Rotaerk> ddarius, your point is just that the concept of a "stack frame" is not inherent to the language so much as the implementation
17:06:47 <ddarius> shachaf: I haven't checked, but I'd be willing to be that it does not.
17:06:53 <Rotaerk> and thus that tail call optimization is basically just the implementation not being stupid about it
17:06:55 <roconnor> okay fair
17:07:14 <roconnor> but the analogous thing to a function call in C is a pattern match in Haskell.
17:07:18 <mauke> longjmp() *might* talk about stack unwinding
17:07:34 <roconnor> so it should be some sort of tail pattern match optimization
17:07:48 <Draconx> mauke, nope.  A longjmp that leaves the scope of a variable length array has undefined behaviour.
17:08:00 <mauke> Draconx: what
17:08:11 <hpc> o.O
17:08:36 <roconnor> and certainly the semantics of function calls in Haskell is totally different than in strict languages.
17:08:57 <roconnor> making TCO kinda meaningless
17:09:05 <Rotaerk> it's not a function so much as a parameterized expression
17:09:13 <roconnor> except for primitive functions
17:09:25 <roconnor> which often have strict C-like semantics
17:09:33 <Rotaerk> what's a primitive function in haskell?
17:09:42 <roconnor> + on Int  for example
17:09:55 <Draconx> mauke, oh, whoops, my bad.  It's just that the the storage associated with VLAs is not necessarily released.
17:09:57 <hpc> Rotaerk: anything where you have to just say "fuck it, GHC does that"
17:10:01 <int80_h> I am constructing a [CalandarDay] by passing a [(Day,Foo,Bar)] through various filters. The origional idea was to gather what I needed with the intermediate data type represented by the tuple, then construct the [CalendarDay] at the end. But now the tuple is too big, and I can either (1) pass it along in a record, then construct the [CalendarDay] at the end, or 2) dispense with the intermediate type and construct the [CalendarDay] as I go
17:10:04 <ddarius> roconnor: Application is strict in the first argument.
17:10:53 <roconnor> ddarius: what about in C?
17:11:13 <hpc> @hoogle CalendarDay
17:11:14 <lambdabot> No results found
17:11:14 <jaredj> licensing question. i'm making a command (not a library). is it gauche to gplv3 it?
17:11:26 <int80_h> hpc: It's a type I made up
17:11:41 <Rotaerk> hpc, that's something I'm unclear on... the IO type represents any kind of IO that can be done, yet IO possibilities are extensible/arbitrary...
17:11:51 <Axman6> jaredj: BSD is usually preferred in my experience
17:11:52 <Rotaerk> so how are those implemented exactly...
17:11:52 <hpc> jaredj: the ideal license for haskell code is BSD
17:11:55 <ddarius> roconnor: It's strict in C too, in the cases where it applies.
17:12:01 <hpc> jaredj: not sure how compatable v3 is with that
17:12:04 <Rotaerk> does extension of IO require another language, like C
17:12:09 <Rotaerk> or what
17:12:24 <hpc> Rotaerk: there's a lot of IO actions implemented in terms of simpler ones
17:12:25 <roconnor> ddarius: is strictness in the first arugment of application relevent to TCO?
17:12:25 <Axman6> Rotaerk: we do have an FFI
17:12:29 <ddarius> I would think you'd agree that you have to know -what- the function is before executing it no matter what the evaluation semantics of the language are.
17:12:40 <hpc> like getContents is written in terms of getLine and unsafePerformIO
17:12:51 <hpc> or possibly unsafeInterleaveIO
17:12:55 <Axman6> s/Perform/Interleve/
17:12:57 <Axman6> yeah
17:13:16 <ddarius> roconnor: Do you consider function application a "primitive function" in Haskell?
17:13:17 <hpc> and bracket is written in terms of open, close, and some wizardly catch functions
17:13:45 <Rotaerk> function application isn't a function
17:14:16 <roconnor> ddarius: usually, but I think in Epigram 2 a function of type A -> () might not be evaluated ... not that it is allowed to be undefined anyways.
17:14:22 <Rotaerk> in spite of the fact that you can write an apply function which applies a function to an argument, once you have application as a mechanism
17:14:53 <roconnor> ddarius: probably not.  I was thinking about + on Int and other such things that use a special stack on the G-machine.
17:17:59 <Rotaerk> then again you can implement a programming language compiler in terms of the programming language itself...
17:18:16 <Rotaerk> so maybe I should consider function application a function...
17:18:54 <roconnor> Rotaerk: you don't necessarily get well-founded semantics that way. :)
17:39:28 <u_> so i'm reading http://www.nt.ntnu.no/users/haugwarb/Programming/OHaskell/o_haskell_tutorial.html and the guy claims that f v@(Left _) = v ; f (Right 0)  = Right False ; f (Right _)  = Right True "is not typeable under Haskell's type regime"
17:39:49 <u_> but it works fine for me
17:39:58 <u_> did something change or is it just a mistake?
17:41:19 <Jafet> :t let f v@(Left _) = v; f (Right 0) = Right False; f (Right _) = Right True; in f
17:41:20 <lambdabot>     No instance for (Num Bool)
17:41:20 <lambdabot>       arising from the literal `0' at <interactive>:1:31
17:41:20 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
17:41:47 <u_> i got f :: (Num t1) => Either t t1 -> Either t Bool
17:41:50 <Axman6> I can't see what would be wrong with it. it's obvious the first equation takes Either a b and returns Either a c, the second takes Num b => Either a b and returns Either c Bool, so if you unify those, you get Num b => Either a b -> Either a Bool. i think
17:42:35 <ski> Axman6 : well, it takes `Either a b' and gives `Either a b'
17:42:45 <Jafet> People who call anything a "regime" is probably trying to sell you something.
17:42:55 <u_> :t let f (Left x) = Left x ; f (Right 0) = Right False ; f (Right _) = Right True in f
17:42:57 <lambdabot> forall t t1. (Num t1) => Either t t1 -> Either t Bool
17:43:05 <u_> that's what i actually typed
17:43:07 <ski> u_ : that's not the same thing :)
17:43:11 <u_> really?
17:43:37 <u_> the Left _ part?
17:43:43 <ski> the `Left x' in the definiendum there has type `forall b. Either a b'
17:43:55 <Jafet> :t (\v@(Left _) -> v, \(Left x) -> Left x)
17:43:55 <lambdabot> forall t t1 t2 b t3. (Either t t1 -> Either t t1, Either t2 t3 -> Either t2 b)
17:43:58 <Axman6> ski: ah yes, it does have to be Either a b -> Either a b in the first case doesn't it
17:44:45 <ski> (Axman6 : i'm not sure what you're asking)
17:45:08 <Axman6> i was agreeing with you
17:45:17 <Axman6> and making sure I understood what you said
17:45:53 <monochrom> let me use a character like 'x' instead of 0 to get rid of the Num noise.
17:46:06 <ski> the problem with the pattern `v@(Left _)' matching an input of type `Either a b', is that `v' will get the type `Either a b', instead of `forall b. Either a b', which one'd prefer here
17:46:24 <monochrom> f v@(Left _) = v; f (Right 'x') = Right False
17:46:47 <u_> why would anyone use f v@(Left _) = v instead of Left x = Left x ?
17:46:47 <monochrom> the return value Right False forces the return type to be Either ? Bool
17:47:06 <monochrom> the parameter Right 'x' forces the parameter type to be Either ? Char
17:47:26 <ski> u_ : one reason could be to not type as much. another could be to hint to the implementation that we want more sharing
17:48:05 <monochrom> now, v can only be one of Either ? Bool or Either ? Char. can't be both. but you use v both as parameter and as return value. contradiction.
17:48:06 <ddarius> data Foo a = A a | B | C | D | E | F; f (Foo 0) = Foo True; f foo = foo
17:48:14 <ddarius> u_: Same problem.
17:48:36 <ski> @src Either (>>=)
17:48:37 <lambdabot> Left  l >>= _ = Left l
17:48:37 <lambdabot> Right r >>= k = k r
17:49:05 <ddarius> Well, I guess I should add a f (Foo _) = Foo False case as well.
17:49:24 <ddarius> There's also having lots of arguments to the constructors etc.
17:49:34 <ski> one could conceivably make sure `v' in `v@(Left _)' gets type `forall b. Either a b' instead .. but i'm not sure how pretty this would be
17:50:10 <ski> (another solution is to use subtyping, as in O'Haskell)
17:50:25 <u_> that's what the page was about
17:50:30 <u_> this makes my head hurt :(
17:50:35 <ski> (that's why i was mentioning it :)
17:52:11 <ski> (ddarius : i suppose s/A/Foo/ (or vice versa))
17:52:52 <fryguybob> @type (\v@(Just _) -> v) :: (Ord a, Eq b) => Maybe a -> Maybe b
17:52:54 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
17:52:54 <lambdabot>       `b' is a rigid type variable bound by
17:52:54 <lambdabot>           an expression type signature at <interactive>:1:33
17:53:11 <monochrom> in most implementations, machine representation of Left x :: Either a Bool and Left x :: Either a Char are the same, so it's understandable to desire a way to reuse the parameter rather than build a new one.
17:54:34 <ddarius> Yes, monochrom hits the nail on the head.  You can't assume that parametric types are represented uniformly.  And supporting what ski suggests in the face of a non-uniform representation would destroy sharing if done naively.
17:54:40 <monochrom> indeed it motivates http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg20712.html
17:55:10 <monochrom> in short, if the syntax "v{}" were allowed, then you can share the value while changing the type harmlessly
17:55:32 <monochrom> (syntax for record update with nothing to update)
18:06:24 <russellw> Is there a reason Haskell's type system (or that of the ML family languages in general) doesn't consider boolean a subtype of integer?
18:07:08 <ski> neither Haskell's type system, or the ones of the MLs have subtyping
18:07:09 <MostAwesomeDude> Bools as ints is an artifact of C which isn't necessarily required in a type system, IIUC.
18:07:17 <roconnor> because there is no ring homomorphism from Bool to Integer?
18:07:38 <MostAwesomeDude> ...My answer is weak.
18:07:55 <russellw> MostAwesomeDude, well it's an artifact of languages oriented around systems programming, digital logic and hardware design in general - I didn't say it was necessarily required, just wondering if there's any downside I'm missing
18:08:02 <monochrom> there is no subtype.
18:08:08 <russellw> But if it doesn't have the notion of subtypes all, I guess that's an answer :)
18:09:06 <russellw> Are there any languages oriented towards the mathematics/lambda calculus/type theory end of the spectrum, that do have the notion of subtypes?
18:09:22 <monochrom> ocaml
18:09:28 <monochrom> pvs
18:10:00 <russellw> right, I know of ocaml, it doesn't regard boolean as a subtype of integer, does it?
18:10:07 <monochrom> no
18:10:22 <shachaf> Why would boolean be a subtype of integer?
18:10:26 <ski> russellw : O'Haskell
18:11:30 <russellw> So then my question is, of those languages that do have subtypes, why don't they regard it as a subtype of integer? The answer why it should be is, for those of us from a systems programming background, it lets us easily and naturally deal with the implementation of integers as vectors of bits
18:11:41 <ski> (maybe a better question would be : why would `Int16' be a subtype of `Int32' ?)
18:12:13 <russellw> Of course one could say that if you're not doing things where you care about the implementation of integers, then this is not a significant advantage, which is fair enough - but what I'm really wondering is whether there's anything I'm missing in the other direction
18:12:17 <shachaf> russellw: That's an implementation detail.
18:12:38 <tr__> how do i resolve the problem with double-conversion and libstdc++ on windows ?
18:12:59 <MostAwesomeDude> ski: (There are languages without sized integers.)
18:13:10 <russellw> In other words, if I make boolean be a subtype of integer, are there any nasty problems I'm going to run into with the associated proof calculi, that a mathematician would know about in advance?
18:13:10 <tr__> i'm completely stuck
18:13:21 <shachaf> ski: (Presumably ski was not referring to those languages. :-) )
18:13:28 <shachaf> s/ski/MostAwesomeDude/
18:13:40 <ski> russellw : treating an integer as a bitstring (or vice versa) is different from treating a boolean as an integer
18:14:23 <MostAwesomeDude> Presumably.
18:14:32 <russellw> ski, how do you reckon? In C, they follow naturally from each other, and I'm given to understand that in various hardware design languages, the same is true
18:14:41 <shachaf> russellw: Well, there's the problem of it just not being the same thing.
18:15:00 <ski> russellw : a boolean presumably would correspond to a single-bit (sized) integer
18:15:01 <shachaf> I would consider Bool a different type from "Bit", too, depending on the context.
18:15:27 <russellw> shachaf, well that's philosophical position. I happen to take the opposite philosophical position, but what I'm wondering about is whether there are any practical problems
18:15:39 <ski> russellw : whereas a sized integer would generally correspond to `n' bits, for `n' greater than one
18:16:10 <russellw> ski, exactly
18:16:29 <shachaf> "that's a philosophical position" is the best way to disregard what someone is saying. :-)
18:16:39 <ddarius> monochrom: NuPRL
18:16:51 <russellw> shachaf, okay, if you prefer: you're wrong, they are the same thing. Better? :)
18:16:53 <monochrom> yeah, that too
18:17:19 <monochrom> nuprl is somewhat an ancestor of pvs, is it not?
18:17:23 <ski> russellw : so, if you're asking why you can't convert between `Bool' and `Int1', then i suppose that's a valid question
18:17:30 <shachaf> russellw: is data Color = Black | White also the same thing?
18:17:38 <ski> russellw : but if you're talking about booleans, then i think roconnor's answer is good : let's say `b0' and `b1' are booleans, and `x' is an `int' cell, then what does `x = b0 + b1' do ?
18:17:58 <monochrom> at least as in much overlap in the creators
18:18:00 <ski> russellw : one interpretation is that both `b0' and `b1' are first promoted to `int', then added
18:18:27 <ski> russellw : another is that they are first added (using xor, which is the addition in the field with two elements), then promoted to `int'
18:18:46 <russellw> ski, oh that's a very good question. Suppose the boolean values were both true. On the one hand, the answer could be taken as 2, on the other hand it could be taken as 0
18:19:08 <MostAwesomeDude> In Boolean algebra, wouldn't it be 1?
18:19:16 <ski> russellw : the problem here is that these two variants can give different answers -- "<roconnor> because there is no ring homomorphism from Bool to Integer"
18:19:27 <ddarius> monochrom: I don't know about overlap, but my understanding is both are still active projects.  I don't know too much about PVS (and not all that much about NuPRL either really.)
18:19:43 <russellw> The same question arises with other subtype relations though, doesn't it? Integer is a subtype of rational. Suppose we have the expression 1/2. Is the answer 0.5 or 0?
18:19:51 <ski> MostAwesomeDude : well, that wouldn't make it into a field, or even a ring
18:20:13 <roconnor> 1 / 2 is a type error for Integers 1 and 2
18:20:13 <ski> MostAwesomeDude : the various sized integer types here are rings
18:20:38 * ski probably shouldn't have mentioned fields here at all, only rings
18:20:40 <MostAwesomeDude> ski: Oh, I see, I was looking at it from the wrong angle.
18:20:41 <roconnor> 1 `div` 2 is (probably)  type error for rationals 1 and 2
18:20:55 <ski> > 1 `div` 2 :: Rational
18:20:56 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
18:20:56 <lambdabot>    arising from a use...
18:21:12 <roconnor> you could define div for Rational, but it would be stupid
18:21:14 <ski> russellw : exactly
18:21:19 <russellw> roconnor, that is certainly a consistent answer. On the other hand, in mathematics, we usually expect to be able to write 1/2 without further ado, don't we?
18:21:31 <monochrom> mathematics uses subtypes
18:21:45 <russellw> Perhaps this is part of the general question about whether types should be considered to be predicates
18:21:49 <ski> russellw : btw, that we get a consistent answer regardless of how the implicit conversions are inserted is known as "coherence"
18:21:57 <roconnor> russellw: yes, but subtyping / coercions would be reasonable here since there is one typable interpretation
18:22:34 <russellw> ski, exactly - above all else whatever system one does end up with, needs to be coherent
18:22:44 * roconnor doesn't like record subtyping because it slices things.
18:22:53 <ddarius> If / was defined only for rationals, and 1,2 meant integer literals, it would be perfectly reasonably for 1/2 to upcast 1 and 2 to rational and divide (producing a rational.)
18:22:59 <roconnor> or least it concerns me
18:23:18 <ski> russellw : yes, or in cases where it can't promise to be, it needs to error out (statically), instead of just picking one
18:23:24 * ski glares at C++
18:23:46 <ddarius> We've had this discussion before.  data AB = A | B; type Pair a = AB -> a
18:23:50 <russellw> Okay, suppose we take the same attitude regarding boolean and integer. Then we could say + is only defined on integers, and b0+b1 gives the integer result. If you want xor, that's another operator with a different spelling
18:24:12 <russellw> In just the same way, if you want integer division, we can spell that 'div' instead of '/'
18:24:12 <MaskRay> can ghc compile programs to portable c source which can be compiled by gcc afterwards?
18:24:18 <russellw> That would be consistent, wouldn't it?
18:24:23 <ddarius> russellw: Yes.
18:25:09 <MaskRay> i know i can do this with jhc, however, its limited features do not meet my demand.
18:25:49 <russellw> I think I'll go with that approach, then. Okay, thanks for the feedback!
18:26:52 <ddarius> russellw: Be aware that adding subtyping to a polymorphic language adds a lot of complexity.
18:26:55 <sal23> anyone knows which library shiftr_w32 is defined in? hoogle shows nothing…I see calls to that function in source codes of some binary parsing libraries but don't see any explicit definition or module import for it
18:27:05 <ddarius> russellw: Though you may want to look at HM(X).
18:28:08 <russellw> ddarius, true, but I don't think I can really avoid it as long as I take the position that types are predicates. - ah, hadn't come across that one before, thanks!
18:28:37 <Eduard_Munteanu> Why?
18:29:19 <ddarius> russellw: If you are taking the position that types are predicates you may want to look at NuPRL and Ontic(?).
18:29:31 * Eduard_Munteanu knows Agda has a (limited) notion of subtyping, but not really what's actually meant by subtyping.
18:29:41 <russellw> Eduard_Munteanu, if that was to me, then surely it follows that once you can write an arbitrary predicate for a type, you can write two predicates, one of which implies the other?
18:29:50 <russellw> ddarius, thanks, will do!
18:30:56 <Eduard_Munteanu> russellw: I'm not sure I follow...
18:32:03 <russellw> Eduard_Munteanu, suppose we don't have subtypes. Then we can't say integer is a subtype of real. Okay, say we are prepared to bite that bullet. We also can't say natural is a subtype of integer. but...
18:32:05 <Eduard_Munteanu> I assume by predicate you mean something that takes a type and return another type.
18:32:23 <russellw> ah! No, I mean something that takes a value and returns a boolean
18:32:37 <russellw> let natural x:integer = x>=0
18:32:39 <Eduard_Munteanu> Yeah, you can't do that in some provers, like Agda.
18:32:46 <russellw> le voila, natural is a subtype of integer
18:32:49 <monochrom> "predicate subtype"
18:33:19 <russellw> Right, that's impossible in most programming languages and many provers - for one thing it makes type checking undecidable in the general case
18:33:31 <russellw> My gut feeling is that I'm going to need it anyway
18:33:49 <Eduard_Munteanu> russellw: however you can pair Int with a proof that the respective integer is >= 0
18:34:21 <russellw> Yeah. Basically the design I have in mind is somewhat different from agda
18:34:33 <russellw> Otherwise I'd just fork agda :)
18:34:35 <Eduard_Munteanu> russellw: why do you need it? You could e.g. go through conversions.
18:34:54 <monochrom> I certainly say "screw decidable type-checking"
18:35:23 <Eduard_Munteanu> I wouldn't dismiss monochrom's suggestion, even out of curiosity.
18:35:33 <russellw> One way to approach the question is to say, I want to make a fully automated theorem prover that learns heuristics to guide proof search
18:35:45 <russellw> Because that's the only way to get a really high-performance automated theorem prover
18:35:55 <russellw> Heuristics in the general case will have to consist of general code
18:36:02 <russellw> So the system will have to deal with General code anyway
18:36:35 <Eduard_Munteanu> That's not really fully automated :)
18:36:47 <russellw> Why do you say that?
18:37:29 <Eduard_Munteanu> Ok, it is, but it could easily fail.
18:37:55 <russellw> sure. So could human mathematicians. Theorem proving is undecidable in the general case
18:38:04 <Eduard_Munteanu> I'm not sure what "fully automated" means.
18:38:37 <russellw> It's a contrast with existing higher-order proof systems, that typically require a highly skilled human operator to figure out what steps to take at each stage
18:38:57 <Eduard_Munteanu> For example, Agda's auto can fill some holes easily, in some it needs hints and in others you might as well do it yourself.
18:39:01 <russellw> A fully automated theorem prover is one that you can hand a conjecture, and leave it running overnight, and hopefully in the morning it might have found the proof
18:39:32 <Eduard_Munteanu> Ah, I see.
18:39:33 <monochrom> acl2 goes further than "types are predicates". it eliminates the type layer altogether, retaining just predicates. you write like integer? x ∧ integer? y ∧ x/=0 ⇒ integer? (x/y)
18:40:01 <monochrom> of course, acl2 uses lisp-like syntax and semantics, so image that statement in s-expr instead
18:40:13 <monochrom> and y/=0 instead of x/=0
18:40:30 <monochrom> and I completely goofed the statement.
18:40:45 <monochrom> integer? x ∧ x/=0 ⇒ integer? (x/x)
18:40:58 * Eduard_Munteanu finds Metamath interesting...
18:41:16 <Eduard_Munteanu> Quite surprising dumb symbolic substitution :)
18:41:37 <russellw> monochrom, yeah, acl2 comes from Lisp rather than ML. On the other hand, I do want some conventional type checking among other things for this reason:
18:41:52 <russellw> Machine learning of general code is a very hard problem, partly because the search space is so huge
18:42:06 <russellw> Being able to filter out code fragments that don't pass type checking, would help cut down the search space somewhat
18:42:41 <russellw> Eduard_Munteanu, I took a look at metamath a while ago and thought it looked interesting but didn't really understand it well enough to get any further than that :)
18:43:27 <Eduard_Munteanu> I was wondering earlier how difficult it'd be to compile Coq or Agda proofs to Metamath.
18:43:34 <mm_freak> any reasons not to use the "numbers" package?
18:43:45 <mm_freak> its last release is from 2009
18:44:06 <roconnor> Agda could be done but Coq is likely stronger than ZFC maybe
18:44:23 <monochrom> if it builds fine for you and gives you answers you like, you should use it.
18:44:33 <Eduard_Munteanu> roconnor: oh, does Metamath force ZF(C) on you?
18:44:41 <monochrom> last release date 2009 means it's so bugless it needs no change :)
18:44:47 <roconnor> Eduard_Munteanu: er sorry I was thinking about proofpower
18:44:53 <roconnor> I forget what metamath is
18:45:00 <ddarius> monochrom: What if it kills kittens too?
18:45:08 <roconnor> do I need to update my colours package so people think it is suported?
18:45:21 <ddarius> roconnor: Probably.
18:45:29 <monochrom> I don't think hackage has kitten-killing code yet.
18:45:50 <Eduard_Munteanu> Well, Metamath Proof Explorer says "constructs mathematics from scratch, starting from ZFC set theory axioms.", but presumably that's just one of their categories.
18:46:15 <Eduard_Munteanu> AFAICT Metamath gives you a clean slate, unlike say Coq.
18:46:44 <Eduard_Munteanu> (Is that how Isabelle works too?)
18:47:46 <roconnor> Some systems are logical frameworks, such as Twelf
18:48:32 <roconnor> The logical framework sales pitch is nice, but I've never seen serious math done in one though perhaps I'm ignorant.
18:49:43 <Eduard_Munteanu> IIRC, Isabelle/HOL has seen quite a bit of serious work.
18:49:48 <Eduard_Munteanu> (maybe not math per se)
18:51:12 <Eduard_Munteanu> The idea of doing simple, mindless substitution seems interesting though, perhaps as a low-level language you can check proofs in.
18:51:44 <Eduard_Munteanu> (and perhaps a common denominator for other systems)
18:52:30 <ddarius> That is the idea behind LF, which was the target of Necula's proof carrying code.
18:52:33 <roconnor> oh right Isabelle is an LF
18:53:04 <roconnor> in that case LF seems to have not even realized it's sales pitch
18:53:30 <Eduard_Munteanu> PCC had that in mind? Hm.
18:55:17 <Eduard_Munteanu> In any case, I wonder if LF works better than type-theoretic provers for stuff that's based on a different logic.
18:55:40 <Eduard_Munteanu> (Did anyone do ZF in e.g. Coq?)
18:55:57 <Eduard_Munteanu> (or maybe some stuff isn't really possible at all)
18:56:00 <ddarius> Eduard_Munteanu: It depends on what you mean by "do."
18:56:21 <ddarius> Eduard_Munteanu: You can postulate whatever you want in Coq, and so you can postulate all the axioms of ZFC.
18:56:46 <Eduard_Munteanu> Yeah, but you can't be sure you don't get \bot.
18:57:08 <Eduard_Munteanu> (since Coq's stuff is already there)
18:57:23 <ddarius> You'd have to be a bit careful, but I'm pretty sure it has been done.
18:57:45 <ddarius> http://coq.inria.fr/V8.2pl1/contribs/ZFC.html
18:57:59 <ddarius> (Just the first hit of googling "coq zfc")(
18:58:21 <Eduard_Munteanu> Hm, I see.
18:58:48 <Eduard_Munteanu> Oh, I wasn't talking about that in particular.
18:59:34 <Eduard_Munteanu> For example, classical logic works in Coq/Agda, I know that. But I wonder if there's stuff that can't be encoded in these systems safely.
19:00:41 <Eduard_Munteanu> (and a consistency proof would require stepping outside that system anyway)
19:01:33 <ddarius> Worst-case scenario, you can do what Metamath and LF systems do, and take a formalist perspective and simply encode the symbol manipulation.
19:02:39 <Eduard_Munteanu> Would there be an underlying theory for that sort of stuff (substitutions etc.)?
19:03:13 <Eduard_Munteanu> E.g. like the calculus of constructions for type-theoretic provers.
19:03:29 <ddarius> The lambda calculus if you want HOAS.
19:04:12 <Eduard_Munteanu> Hm... that doesn't sound bad. I mean... it probably still feels computational if LC is involved.
19:06:16 <russellw> It was said earlier that polymorphism and subtyping are hard to combine. Is that related to the way in ocaml the floating-point arithmetic operators are spelled differently to the integer arithmetic operators?
19:06:48 <russellw> I.e. were they trying to avoid the complexity of making arithmetic polymorphic in the presence of subtyping?
19:07:26 <mauke> I don't think so
19:07:27 * Eduard_Munteanu isn't sure subtyping between integers and FP works either way
19:07:36 <ddarius> russellw: No.
19:07:47 <mauke> integers and floats aren't subtypes of each others, and + isn't fully polymorphic
19:07:51 <mauke> it needs constraints
19:08:18 <russellw> Yeah, I'm thinking integer isn't a subtype of float per se... Integer is a subtype of real, and float is an approximation to real
19:09:07 <russellw> Not entirely sure yet how to handle that, in a sense once you bring in float, you break the property that e.g. a+b-b=a
19:09:13 * Eduard_Munteanu wonders if there's anything like arbitrary precision FP that includes the integers
19:09:27 <Eduard_Munteanu> Erm, probably not.
19:09:27 <russellw> There is arbitrary precision rational numbers, but they aren't actually all that useful
19:10:04 <Draconx> Eduard_Munteanu, arbitrary precision FP would, by definition, include the integers.
19:10:21 <Draconx> Eduard_Munteanu, er, I guess you'd need arbitrary range, too.
19:10:36 <Eduard_Munteanu> Really? Now that I think about it it's like arbitrary precision arithmethic would include infinities
19:10:52 <russellw> Strictly speaking no
19:11:16 <russellw> But if you try to actually carry out calculations using arbitrary precision rational numbers, you can't do all that much calculation before running out of memory
19:11:26 <russellw> Actual calculation uses floating point for good reason
19:11:41 <Eduard_Munteanu> You mean fixed-point stuff, right?
19:11:59 <russellw> How do you reckon?
19:12:24 <russellw> Fixed point is basically what you use when you need to do numbercrunching on a CPU that doesn't have a floating-point unit
19:12:37 <Eduard_Munteanu> Not exactly.
19:13:05 <Eduard_Munteanu> Another use is when you don't want floating point quirkiness getting in the way, e.g. precision-wise.
19:13:30 <Draconx> Eduard_Munteanu, fixed point has worse characteristics precision-wise than floating point.
19:13:49 <russellw> well true, I'd consider it if I was writing a distributed game that needed determinism above all else in the physics engine
19:13:50 <Eduard_Munteanu> Draconx: perhaps you mean range-wise
19:13:52 <Draconx> Eduard_Munteanu, in fixed point, the available precision depends on the magnitude of the numbers involved.
19:14:11 <Draconx> Eduard_Munteanu, no, precision-wise.
19:14:24 <russellw> But it does have worse characteristics precision wise if you need to set aside more bits for the range, which is likely
19:14:34 <Eduard_Munteanu> Draconx: yes, and it's more easy to predict than floating point
19:14:47 <russellw> Still, while it does give you determinism, it doesn't give you accuracy
19:14:57 <russellw> You can know what result you will get, but that result still isn't the true mathematical result
19:15:20 <russellw> Thinking about it a bit more, on the one hand in a formal sense you can't really say anything whatsoever about the result of a floating-point calculation
19:15:36 <russellw> On the other hand, the whole purpose of floating point is to pretend you can and hope you get away with it
19:15:55 <Eduard_Munteanu> You can pretty much restrict yourself to a subset of those particular fixed-point numbers so you get exact arithmetic, no?
19:15:58 <russellw> So you really have to consider floating-point operators to be real number operators
19:16:16 <russellw> erm, no, the fixed point exactness breaks the instant you perform either multiplication or division
19:16:42 <Eduard_Munteanu> Um, yeah, you're right :)
19:17:22 <Eduard_Munteanu> I guess it's just the deterministic appeal of it.
19:17:49 <russellw> yeah. Like I said, if I were writing a distributed game that needed determinism above all else, I would at least seriously consider using fixed point
19:30:01 <vrook> :t randomR
19:30:02 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
19:30:14 <vrook> > randomR (1, 6) (mkStdGen 100)
19:30:16 <lambdabot>   (6,4041414 40692)
19:30:41 <vrook> So Integer is a subclass of Random?
19:30:45 <vrook> (or Int)
19:32:15 <vrook> > 3 :: Random Int
19:32:16 <lambdabot>   Class `System.Random.Random' used as a type
19:32:32 <vrook> I am puzzled.
19:34:05 <roconnor> vrook: Int is an instance of Random
19:36:36 <vrook> wouldn't it make more sense of the signature of randomR was (Num a, Random b, RandomGen g) => (a, a) -> g -> (b, g) ?
19:36:57 <vrook> It confuses me that the input is random, which it's not.
19:37:29 <vrook> Should probably be Ord a
19:39:58 <roconnor> vrook: I sort of see your point
19:40:09 <roconnor> though I think Ix would be more appropriate than Ord
19:42:46 <vrook> why does this fail: 3 :: Random Int ? Isn't that inferred from the randomR call?
19:43:14 <mauke> what randomR call?
19:43:21 <vrook> randomR (1, 6) (mkStdGen 100)
19:43:22 <roconnor> Random isn't a type constructor
19:43:32 <roconnor> Random is a typeclass
19:43:36 <mauke> that doesn't contain 3 :: Random Int
19:43:40 <vrook> Ah right, ok
19:44:26 * roconnor wonders if someone should file a missing Ix superclass for Random as a bug
19:44:42 <roconnor> hmm
19:44:45 <vrook> Could Random have been designed such that Int is not an instance of Random?
19:44:49 <vrook> that seems weird
19:44:59 <roconnor> I guess for random Floats and reals, Ix isn't right
19:45:02 <roconnor> maybe Ord is better
19:45:03 <mauke> :t randomIO
19:45:05 <lambdabot> forall a. (Random a) => IO a
19:45:12 <mauke> Int is an instance
19:45:39 <roconnor> @instances Random
19:45:40 <lambdabot> Couldn't find class `Random'. Try @instances-importing
19:46:07 <mauke> @help instances-importing
19:46:08 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
19:46:18 <mauke> @instances-importing System.Random Random
19:46:19 <lambdabot> Bool, Char, Double, Float, Int, Integer
19:46:54 <vrook> How can I see all the typeclasses of Int?
19:46:59 <platzhirsch> I have n lists of a binary represented numbers and I want to calculate all possibilities in which an OR invocation to all of them always results in [1,1,1..1] any ideas?
19:47:34 <vrook> @ instances Int
19:47:55 <mauke> vrook: :i Int in ghci
19:48:11 <vrook> mauke: neat, thanks
19:49:02 <roconnor> platzhirsch: [(x,y) | x <- lists, y <- lists, and (zipWith (||) x y)
19:49:08 <roconnor> ]
20:14:31 <irene-knapp> hmmmmmm
20:14:41 <irene-knapp> is there a kind which includes both * and * -> *?
20:14:51 <irene-knapp> what I want to do is have, like
20:19:40 <irene-knapp> {-# LANGUAGE TypeFamilies #-} class Named referent where { data Name referent ; name :: referent -> Name referent } ; data Module foundStatus = Module { moduleName :: Name Module, moduleStuff :: Stuff, ... } ; instance Named Module where { data Name Module = ModuleName [String] ; name = moduleName } ; data BibliographyItem = BibliographyItem { bibliographyItemCitationKey :: Name BibliographyItem, bibliographyItemStuff :: Stuff, ... } ; instance Named Bibliog
20:19:48 <irene-knapp> er
20:19:50 <irene-knapp> let me hpaste that :D
20:23:55 <hpaste> irene-knapp pasted “Kind polymorphism?” at http://hpaste.org/54803
20:25:52 <ddarius> irene-knapp: You screwed up anyway.  You can't write the instance for Module because then you'd get: name :: Module -> Name Module which isn't well-kinded.
20:26:35 <irene-knapp> ddarius: hmmmm, it isn't?
20:26:55 <irene-knapp> oh, I see, yes
20:27:10 <irene-knapp> name would have to have the type Module foundStatus -> Name Module, for module
20:27:16 <m3ga> anyone know how to embed the -XOverloadedStrings directive in a literate haskell file so that ghci does the right thing?
20:27:39 <irene-knapp> but BibliographyItem -> Name BibliographyItem, which isn't analogous
20:27:40 <irene-knapp> hmmmm
20:27:52 <irene-knapp> same issue, really, just different face of it
20:28:01 <irene-knapp> okay, so hmmmmm, how to handle this ><
20:28:35 <irene-knapp> okay, hmmm, I know :)
20:28:49 <irene-knapp> I just have to put a phantom type on BibliographyItem, heh
20:29:45 <ddarius> m3ga: Use a LANGUAGE pragma as useal.
20:30:00 <irene-knapp> I guess he's asking if it's
20:30:07 <irene-knapp> LANGUAGE OverloadedStrings
20:30:13 <irene-knapp> {-# LANGUAGE OverloadedStrings #-}
20:30:22 <irene-knapp> > {-# LANGUAGE OverloadedStrings #-}
20:30:23 <lambdabot>   not an expression: `{-# LANGUAGE OverloadedStrings #-}'
20:30:24 <irene-knapp> etc
20:30:30 <irene-knapp> yes, thank you lambdabot, that wasn't for you
20:30:44 <irene-knapp> and I'm not actually sure what the syntax is :)
20:30:54 <ddarius> irene-knapp: I'm assuming you just want to associate some meta data for various types of various kinds?
20:31:15 <ddarius> Or to put it another way, you don't actually care what's passed in for referent, you only care about it's type.
20:31:27 <m3ga> i've tried adding '> {-# LANGUAGE OverloadedStrings #-}' but ghci still doesn't do the right thing
20:31:42 <ddarius> m3ga: Use :set -XOverloadedStrings.
20:31:44 <irene-knapp> ddarius: no, I /do/ care about referent.  "name" is a field accessor.
20:32:12 <m3ga> ddarius: works fine on the command line, but iwas hoping I could embed the directive in the file
20:32:34 <ddarius> m3ga: If you are loading a file, you just use the pragma.
20:33:26 <irene-knapp> the reason referent sometimes takes a kind parameter is that some of the possible references can refer to other specific types belonging to Named, and the type parameter says whether those references are by name, or by value
20:33:34 <m3ga> yes, i can do that but i want to pass the file onto beginners and have it "DoTheRightThing(tm)" straight up. hence i'd like to embed the directive.
20:33:55 <irene-knapp> s/sometimes takes a kind parameter/sometimes takes a type parameter/
20:35:10 <ddarius> Putting '> {-# LANGUAGE OverloadedStrings #-}' at the top of the file should work.
20:35:17 <ddarius> It works for me on GHC 7.2.2.
20:35:36 <ddarius> And I'm pretty sure it has always worked for as long as the LANGUAGE pragma has existed.
20:36:58 <ddarius> irene-knapp: And BibliographyItem can't refer to other things, so it doesn't come up?
20:37:12 <irene-knapp> ddarius: precisely
20:37:26 <ddarius> Okay, then a phantom parameter is appropriate.
20:37:35 <irene-knapp> okay, cool :)
20:47:33 <ddarius> Eduard_Munteanu: As far as I can tell, everything in Metamath can be embedded into LF in a trivial manner except the distinct variable assertions.  Those could be encoded but aren't directly representable.  You could easily imagine an LF+distinct variables much like LLF is LF with linear contexts.  This would simplify the Metamath approach since you would only need distinct variables.  The equivalent of $d v φ $. woul
20:47:33 <ddarius> d be distinct v x y z \ φ x y z
20:48:02 <ddarius> The need for distinct variables, though, would be much less.
20:48:09 <Eduard_Munteanu> I see.
20:49:08 <ddarius> Going from LF to Metamath though, would typically involve a large amount of encoding.  Roughly similar to going from HOAS to first-order syntax, and also a step from a higher-order language to a first-order one.  It would certainly be doable, you'd just have to do a lot more stuff explicitly and manually.
20:49:36 <ddarius> Proof checking in both is completely automated, though simpler in Metamath.
20:49:42 <Eduard_Munteanu> I was thinking more like from Agda/Coq to Metamath... perhaps as a way to double check those.
20:50:02 <ddarius> LF is much simpler than Agda or Coq.
20:50:04 <Eduard_Munteanu> (the other way around would be the more difficult task I presume)
20:50:34 <ddarius> Eduard_Munteanu: You mean taking a proof in Agda/Coq and reformulating it in Metamath?
20:50:42 <ddarius> Er, what do you mean?
20:51:12 <Eduard_Munteanu> ddarius: yes, but automated.
20:51:42 <ddarius> Part of Necula's motivation for using LF as a target for the proofs in PCC, was LF proofs tend to be compact and, though slightly more difficult than Metamath, checking them is still stupid simple.
20:53:05 <ddarius> Taking a proof in Metamath and producing an Agda program that verifies it would be trivial, except for dealing with distinct variable annotations, and even that wouldn't be that difficult to deal with.
20:53:21 <ddarius> Going the other way means essentially implementing Agda in Metamath.
20:55:45 <Eduard_Munteanu> ddarius: as a lambda, the former? Uh, I guess I was thinking about using Agda-specific constructs. But anyway, for the latter, you'd only need to describe the type system no?
20:55:54 <ddarius> In fact, as an execise, figure out what additions would be needed to be added to LF to support distinct variables, i.e. syntax, type rules, and judgements.
20:57:01 <ddarius> Eduard_Munteanu: Since values can occur in types in Agda and are subject to evaluation, what would be left after you've described the type system?
20:57:16 <Eduard_Munteanu> That should be interesting, I'll have to look more into LF to do that.
20:57:34 <ddarius> LF is basically λP.
20:58:57 <Eduard_Munteanu> ddarius: I expected, for translating such a proof, you'd need (1) the typing rules and definitions (2) invoking them to normalize terms
20:59:41 <Eduard_Munteanu> (by terms I also mean types)
21:00:08 <ddarius> What aspects of Agda does that leave?
21:01:36 <Eduard_Munteanu> Oh. You'd only work with internal syntax I guess (not abstract or the thing you parse from the user), but now that I think of metavariables and all that it could be quite a bit of work.
21:02:10 <Eduard_Munteanu> I see your point.
21:04:37 <Eduard_Munteanu> Damn, that kinda makes theorem provers sound complicated even conceptually. :)
21:05:34 <Eduard_Munteanu> (or the underlying theory, anyhow)
21:07:23 <Eduard_Munteanu> Coq / Gallina did acheive a similar separation or split though, since Gallina is supposed to be formally verified IIRC.
21:08:10 <Eduard_Munteanu> (so if you'd do the same for Coq you'd only have to implement (much of) Gallina in Metamath, I think)
21:09:00 <Eduard_Munteanu> Anyway, thanks for the pointers.
21:24:50 <Zarathu> I have a very small test program: http://pastie.org/2958412
21:25:07 <Zarathu> Can someone help me understand the error message? I'm trying to get it to run.
21:25:53 <mzero> Zarathu:
21:26:15 <mzero> line 22 is a "pure" result - that is I just computes a a String
21:26:33 <mzero> but main is an IO () --- that is, an IO action
21:26:57 <Zarathu> I guess the question is, how do I convert a Maybe String to a [Char]? That way, I can feed it to putStrLn
21:27:01 <mzero> what do you expect the program to do with that String?
21:27:20 <mzero> first   String is just [Char]
21:27:26 <Zarathu> Yes.
21:27:39 <mzero> second, if the value of the Maybe String is Nothing, what do you expect to have happen?
21:27:53 <Zarathu> putStrLn ""
21:28:00 <Zarathu> (ideally)
21:28:04 <mzero> then what  you want is the function maybe
21:28:06 <mzero> :t maybe
21:28:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:28:34 <mzero> something like:   putStrLn $ maybe "" id $ Map.lookup .....
21:28:41 <mzero> :t fromMaybe
21:28:42 <lambdabot> forall a. a -> Maybe a -> a
21:28:47 <Zarathu> ah!
21:28:52 <mzero> or fromMaybe
21:29:06 <mzero>   putStrLn $ fromMaybe "" $ Map.lookup ...
21:29:23 <Zarathu> Wow, that worked.
21:29:50 <mzero> maybe is always my go-to function... but sometimes fromMaybe is useful (though I think you need to import Data.Maybe to get it)
21:30:28 <mzero> is it clear how it is doing it?
21:30:32 <Zarathu> mzero: Does the last line of every main have to -> IO () ?
21:30:37 <Zarathu> Yes, thank you.
21:30:53 <mzero> well, main must be :: IO ()
21:31:00 <ddarius> IO a
21:31:10 <mzero> really? huh - who knew
21:31:21 <mzero> well, usually, if main :: IO (),
21:31:43 <mzero> and you write main = do .... then, yes, the last expression of the do block must have type IO ()
21:31:51 <flu_> yay, building the platform from source is a success
21:34:35 <mzero> Zarathu: in short, yes
21:34:48 <Zarathu> :)
21:49:01 <dmwit> main = flip runState "hello, world" $ do { putStrLn; putStrLn; putStrLn } -- "always" is such a strong word
21:50:31 <mzero> > flip runState "hello, world" $ do { putStrLn; putStrLn; putStrLn }
21:50:32 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
21:50:32 <lambdabot>        ...
21:50:37 <mzero> didn't work in my ghci either
21:51:10 <dmwit> :t runState
21:51:11 <lambdabot> forall s a. State s a -> s -> (a, s)
21:51:16 <dmwit> :t runReader
21:51:17 <lambdabot> forall r a. Reader r a -> r -> a
21:51:30 <dmwit> I meant that one. You probably need some Reader constructors, too.
21:51:47 <dmwit> :t runReaderT
21:51:48 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
21:52:04 * hackagebot transformers-base 0.4.0.1 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.4.0.1 (MikhailVorozhtsov)
21:52:12 <dmwit> :t flip runReaderT "hello, world" $ do { ReaderT putStrLn; ReaderT putStrLn; ReaderT putStrLn }
21:52:13 <lambdabot> IO ()
21:52:18 <dmwit> mzero: better?
21:52:46 <mzero> well, looks to me that the type of main is still..... IO () !
21:52:49 <mzero> :-)
21:53:00 <dmwit> Yes, but the last expression of the do block does not have type IO ().
21:53:26 <mzero> ah, but I said given    main = do ...        and here, main = flip runReaderT ....
21:53:49 * dmwit nods
21:54:01 <mzero> none the less, clearly we lead dull lives if we're noodling such silliness on a Friday night!
21:54:11 <dmwit> The subtleties of your wording did not escape me.
21:54:21 <dmwit> But the subtleties of Zarathu's wording did not escape me, either. =)
21:55:23 <mzero> on other topics - who has ever customized a .cabal/config file?
22:08:35 <wavewave> hi
22:10:55 <JoeyA> Consider two ways a thread can alert another thread of events: 1) By sending messages on a channel provided by the receiver, and 2) Invoking handler actions provided by the receiver.  Which one is usually better?
22:12:11 <jessopher> well using a handler... is generally not gonna do anything in thread A, unless the handler passes messages
22:12:12 <mauke> they're interconvertible
22:12:16 <JoeyA> I suppose (2) can almost be thought of as a manually fused version of (1), but I haven't proved that.
22:12:58 <mzero> In general (generalizing beyond Haskell), 1 makes it easier for code to be defensively safe
22:13:23 <mzero> that is, the thread is not exposed to interference from the thing it is alerting
22:14:05 <JoeyA> One problem with a channel is: if I want to receive messages from multiple types of workers, and they each have their own message type, I have to listen to multiple channels simultaneously (readTChan ... `orElse` ...).
22:14:12 <JoeyA> Seems kinda messy.
22:14:41 <jessopher> or you can use an data type with a constructor for each message type
22:14:42 <mzero> separate listener thread for each type of worker?
22:14:45 <dmwit> :t (***)
22:14:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:14:53 <JoeyA> jessopher: That's (1)
22:15:17 <jessopher> i dont understand the numbering scheme
22:15:20 <jessopher> lol
22:15:37 <JoeyA> Instead of the caller passing a TChan, they could pass a (Message -> STM ()) that lets the receiver do what it wants with the message.
22:17:09 <JoeyA> Something I'm not sure I like about (1) (and perhaps (2) as well) is that it doesn't really "compose".  I just get a longer and longer "handle event" function.
22:18:52 <ddarius> Why?
22:21:54 <JoeyA> ddarius: My thinking is sort of vague here, but I get the feeling that, if I'm "doing it right", I should be able to construct a worker thread out of individually-usable pieces.
22:22:08 <JoeyA> Sort of like IO, where you can construct complex actions out of simpler ones.
22:23:18 <jessopher> but if there is a fundamental difference in the 'type' of the workers (the message type), that might not make any sense
22:23:33 <ddarius> Why do you think you wouldn't be able to do that?  And why would the "handle event" function get longer?  What is the independent variable there?
22:23:35 <JoeyA> Pattern-matching on a data constructor with a lot of alternatives isn't something that can be assembled piecemeal.
22:23:59 <ddarius> JoeyA: Sure it can, though you can avoid that.
22:24:03 <jessopher> JoeyA, you dont have to do the pattern matching in the body of the worker anyhow
22:24:06 <JoeyA> The "data constructor with a lot of alternatives" would be messages produced by my thread.
22:24:32 <ddarius> JoeyA: You can have multiple channels for the receiver for different types of events.
22:25:28 <wavewave> JoeyA: you can use composite data types for avoiding too lengthy alternatives
22:25:53 <JoeyA> ddarius: But it gets messy quick.  When a receiver listens to a bunch of different things, I end up with a lot of state in one place.
22:26:11 <JoeyA> wavewave: That's sort of what I'm thinking
22:26:14 <ddarius> Isn't that better than a lot of state spread around?
22:26:32 <ddarius> Also the receiver doesn't necessarily have to be one process.
22:27:14 <wavewave> JoeyA: http://jaspervdj.be/posts/2011-10-16-type-safe-events.html
22:27:31 <wavewave> JoeyA: probably, this may be helpful post for you.
22:27:57 <JoeyA> Interesting, thanks
22:28:42 <JoeyA> Right now, I'm reading the CloudHaskell thesis ( http://www.cl.cam.ac.uk/~jee36/thesis.pdf ).
22:28:52 <jessopher> oh no, more clouds
22:29:38 * jessopher reads silently
22:29:55 <JoeyA> I'm more interested in the concurrent aspect (talking to multiple clients on a network).  I'm not doing anything computationally intensive.
22:32:50 <jessopher> wavewave: what did you mean by composite data types?
22:33:41 <wavewave> jessopher : as it is described in type-safe event blog article.
22:33:49 <jessopher> oh
22:34:32 <wavewave> such complexity problem is just a matter of taxonomical problem in some sense
22:35:01 <wavewave> how you classify your event  hierarchically well.
22:35:41 <wavewave> local concerns is local, global concern is global
22:36:57 <mzero> local cat is local, global cat is napping
22:37:24 <wavewave> I now also have a similar problem as  JoeyA and try to refactor my program.
22:39:51 <wavewave> Does anyone know about the current status of ghcjs?
22:44:24 <jessopher> i looked it about a month ago and it wasnt in a state that was suitable for my uses... I dont remember specifically what that means now though
22:45:19 <jessopher> '/it/into it/
22:46:04 <wavewave> jessopher: ghcjs = 'it'?
22:46:20 <jessopher> wavewave: yeah
22:46:41 <wavewave> jessopher: what was a problem you encounter for your use of ghcjs?
22:51:52 <wavewave> ahh. I hope that I can make web app like I do in normal haskell programming.
22:52:47 <jessopher> yeah, I am not sure what the issue was, but the repository hasn't been touched since august and its still alpha. I think it was something to do with libraries that werent available to ghcjs code
22:54:17 <wavewave> I am assuming that haskell's intensive use of continuation may cause some performance problem in naive javascript implementation..
22:54:39 <JuanDaugherty> is anything besides yesod claiming to be a CMS?
22:54:51 <wavewave> gitit?
22:54:59 <luite> Yesod doesn't claim to be a CMS :)
22:55:12 <jessopher> thats not what yesod told me :P
22:55:57 <wavewave> JuanDaugherty: what is your concern?
22:56:02 <JoeyA> wavewave: I don't know if ghcjs uses it or not, but one workaround to the tail recursion problem is to have a function return its continuation, and have a simple "interpreter": while (cont) { cont = cont(); }
22:56:10 <luite> although there is a yesodcms repository on michaels github
22:56:16 <JuanDaugherty> wavewave, due diligence on haskell CMS
22:56:17 <luite> don't know if he's still working on it
22:56:27 <JoeyA> wavewave: I think this is what GHC did at one point, and is mentioned in the STG paper if I recall correctly.
22:57:00 <JuanDaugherty> luite, michael snoyman?
22:57:01 <wavewave> JoeyA: I see. thanks for the info.
22:57:05 <luite> JuanDaugherty: yes
22:57:39 <wavewave> JoeyA: I am now wondering if trampoline style ghcjs RTS can elegantly solve the problem.
22:58:06 <wavewave> but javascript generator is not standard yet, though.
23:02:38 <JuanDaugherty> FTR, there's no yesodcms at snoyberg github, and this: is where he makes the claim: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/92171
23:03:16 <wavewave> JuanDaugherty: hmm ? I found yesodcms from his github page.
23:03:34 <JuanDaugherty> essentially the claim is that there's enough pieces parts of RESTful CMS for it (yesod) to be one
23:03:34 <wavewave> https://github.com/snoyberg/yesodcms
23:04:58 <JuanDaugherty> oops
23:05:10 <JuanDaugherty> i hate unordered lists like that
23:05:38 <JuanDaugherty> *a RESTful CMS
23:05:55 <wavewave> last commit is on Oct 04, so it seems still active
23:06:50 <JuanDaugherty> and by "like that" I mean where it's not clear if it's ordered or not at first glance but it oughta be in the first place
23:07:24 <jessopher> i see RESTful all over the hackage web section, but I dunno if any of those things are categorically CMSs
23:07:34 <JuanDaugherty> but it's more that it isn't yesod-cms I suppose
23:09:54 <wavewave> in fact, CMS is not a very well-defined concept from my point of view.
23:10:15 <jessopher> i consider the filesystem on my hard-drive a CMS
23:11:03 <wavewave> jessopher: definitely. especially if you export a directory of your hard disk as a webdav directory.
23:11:11 <jessopher> hehe
23:11:31 <wavewave> that's how I manage my content now.
23:11:57 <JuanDaugherty> yes, but that's besides the point, a common and ubiquitous condition of the real world, natural language
23:11:58 <wavewave> lighttpd (webdav) + darcs
23:12:46 <wavewave> JuanDaugherty: haskell CMS is not as mature as drupal at all right now..
23:13:20 <wavewave> yesodcms is also for some special purpose of Michael, I guess.
23:14:08 <JuanDaugherty> wavewave, acknowledged
23:14:45 <wavewave> but I suppose that the libraries needed for CMS are filled rapidly, so sooner or later, it will be done.
23:15:08 <JuanDaugherty> wavewave, come again?
23:15:25 <JuanDaugherty> you mean haskell app servers?
23:16:15 <wavewave> JuanDaugherty: I don't know... somebody will fill the gap soon, that's my hope. ;-P
23:16:24 <JuanDaugherty> wavewave, acknowledged
23:17:02 <wavewave> For my side, I am now trying to make a FFI for webdav.
23:17:06 <jessopher> mighthttpd2 is about to be my cms, routing and cgi is about all the management my content can handle
23:17:21 <wavewave> FFI for neon library.
23:17:43 <wavewave> webdav is quite useful for CMS file transaction.
23:19:02 <wavewave> my hneon library hehe : https://github.com/wavewave/hneon
23:21:05 <wavewave> jessopher: one important thing of cms is version control.
23:21:32 <jessopher> well i can always just put my content in a git repository
23:21:58 <jessopher> but i understand a lot of people would not
23:22:15 <wavewave> jessopher: so you are authoring contents not via web and only view contents through web?
23:23:05 <wavewave> or your web app invokes git internally?
23:23:53 <jessopher> the former, my content is mostly static, and not blog-like or wiki-like
23:24:23 <wavewave> i see.
23:24:36 <wavewave> jessopher: probably, you may also be interested in hakyll
23:25:02 <wavewave> static web site cms in a sense.
23:25:56 <jessopher> right, but I would also like a few simple webapps in the mix, without the headache of reverse proxying or multiple webserver
23:26:39 <wavewave> jessopher: yeah. for me, fastcgi does the job well.
23:27:02 <proge> this intro to haskell is terrible
23:27:41 <wavewave> proge: ?
23:27:55 <proge> its just noise
23:28:03 <jessopher> it?
23:28:08 <jessopher> which?
23:28:14 <wavewave> what are you reading?
23:28:17 <proge> tryhaskell.org
23:28:23 <proge> thats how i'm in this chat
23:29:19 <jessopher> seems pretty straight forward to me
23:29:37 <proge> mmm you prob already know haskell right?
23:29:52 <wavewave> what does this tryhaskell use in the backend btw? looks impressive
23:30:13 <proge> yeah the interface is lovely
23:30:37 <wavewave> proge: you had better read some free other material.
23:30:54 <proge> can you recommend any?
23:31:02 <proge> i'm a good coder
23:31:08 <wavewave> learnyouahaskell.com
23:31:21 <proge> just trying to wrap my head around why i should learn haskell
23:31:29 <proge> i read a bit of that
23:31:41 <proge> and started spotting patterns in the english language
23:31:52 <proge> yeah maybe back to there i go :)
23:32:33 <wavewave> if you are a good coder, you can try somewhat more advanced like real world haskell.
23:32:46 <proge> i'm wanting practical
23:32:54 <proge> all seems too academic
23:33:00 <jessopher> i am wondering why you are even bothering if you dont even know why you are bothering. not to be too abrassive or anything. I just do think 'looking for a reason to learn haskell' is going to be satisfied by introductory tutorials.
23:33:10 <jessopher> don't
23:33:20 <wavewave> 'real world haskell' is quite practical.
23:33:38 <proge> i love coding jes
23:33:42 <wavewave> book.realworldhaskell.org
23:33:55 <jessopher> well then thats a good reason to learn haskell in and of itself
23:35:30 <proge> wavewave my saviour tehee
23:36:14 <proge> this is more my style thanks
23:36:36 <wavewave> you're welcome.  RWH is one of the must-have book for haskeller.
23:38:11 <proge> yes it starts by answering my questions :)
23:38:16 <proge> why? lol
23:38:27 <jessopher> i dont remember at all why I started learning haskell. I think it was to justify my caffiene habit
23:38:57 <wavewave> I strongly feel that we need the next revision of RWH!!!!
23:39:55 <wavewave> all of my concern on Functional Programming started  from mathematica.
23:40:18 <proge> as in maths?
23:40:47 <proge> i think i need to go back and learn some math
23:40:51 * wobsite at least plays with every langauge he hears of
23:40:54 <wavewave> I had to use mathematica quite extensively for my project.
23:40:56 <proge> kinda skipped ahead
23:41:19 <wavewave> I mean Wolfram's Mathematica
23:41:45 <wavewave> I got to know FP and started to learn scheme
23:41:47 <jessopher> proge: haskell will teach you some tricky math without you even noticing it happening
23:42:31 <wavewave> I tried to write a scheme program but found that it was very hard to program without type system.
23:43:11 <wavewave> debugging in FP without type system was very hard.
23:43:44 <wavewave> so tried to find other language and found haskell.
23:44:00 <proge> wavewave i'm not completely sure i understand you but you're def on my wave length
23:44:47 <proge> i'm still trying to figure out why fp is mind blowing
23:44:54 <proge> i feel like it is
23:44:55 <jessopher> yeah, i started getting into the functional aspects of some oop languages, and decided I liked them more than the oop parts, so I went stumbling around in the FP forest until i bumped into haskell
23:44:59 <proge> but don't know why
23:45:16 <wavewave> My first book on haskell was "The Haskell Road to Logic, Maths and Programming"
23:45:19 <JuanDaugherty> so far as I knew the only thing haskell and mathematica have in common is mathematics
23:45:25 <JuanDaugherty> is that wrong?
23:45:47 <wavewave> which is seldom recommended here, but i think it is a great book for someone who has some math interest.
23:45:57 <russellw> proge, http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
23:46:01 <wavewave> http://homepages.cwi.nl/~jve/HR
23:46:55 <wavewave> John Hughes' article is great!
23:47:08 <JuanDaugherty> why stop at "maths" I think we slide right into "mafs"
23:47:16 <jessopher> which lead me to having no capacity to even frame an idea on OOP anymore. FP kind of damaged my employability
23:47:33 <JuanDaugherty> *we should
23:48:20 <wavewave> Real World Haskell is my second book.
23:48:41 <wavewave> I am kind of lucky so that I found the right book at the right moment.
23:48:44 <proge> ahhh multi threads tehee
23:50:38 <proge> rus that link didn't work got a forbidden
23:50:46 <proge> but its here i think http://www.cs.utexas.edu/~shmat/courses/cs345/whyfp.pdf
23:51:52 <russellw> right, there are copies in a few places. I think it's a good answer to your question
23:52:01 <wavewave> if you want to 'not-gentle' introduction to haskell, see 'a gentle introduction to haskell'
23:52:06 <proge> yep i started reading that
23:52:15 <wavewave> http://www.haskell.org/tutorial
23:52:17 <proge> thats what brought me here
23:52:24 <proge> from reddit i think
23:52:31 <jessopher> if you read why FP you should also read http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
23:52:38 <proge> but when it starts getting heavy its a bit too much maths
23:53:21 <wavewave> proge: anyway, I think Real World Haskell may be the best for you.. and also read Learn You a Haskell in parallel if you cannot catch some idea in RWH.
23:53:43 <wavewave> proge: sometimes, RWH is a little too fast in explanation.
23:55:07 <wavewave> haskell is a very addictive language.. be careful. ;-P
23:55:48 <wavewave> you cannot speak other language after haskell. ;-P
23:55:59 <jessopher> i cant, hehe
23:56:00 <proge> thats kinda what i'm realising
23:56:05 <proge> i already speak it
23:56:11 <proge> now i want to learn it
23:56:12 <proge> lol
23:56:15 <jessopher> haha
23:57:35 <wavewave> The real benefit as a programmer from haskell for me was indep of functional programming or all fanciness .
23:57:36 <proge> thanks i've closed the maths pages and got my RWH and Learn Me Haskell :)
23:57:43 <proge> ahhhhhh
23:57:46 <proge> now i can relax
23:58:19 <wavewave> haskell got rid of my hesitant mind of refactoring. that's the best.
23:58:40 <proge> i'm coming from c#
23:58:49 <wavewave> s/of/against
23:59:14 <proge> ive got a handle on architecting txts
23:59:24 <proge> but feel like this is the way forward
23:59:31 <wavewave> no matter how complex the program is, I can start refactoring from changing a type..
