00:00:36 <simony> mauke: weird, it looks fine to me?
00:00:47 <mauke> ooh
00:00:54 <liste> :t (fmap . fmap) `asAppliedTo` [Just (True, [True])]
00:00:54 <dmj> koz_: can you paste classifier and testingSet too
00:00:56 <mauke> yes, my bad
00:00:57 <lambdabot>     Couldn't match expected type â€˜a -> bâ€™
00:00:57 <lambdabot>                 with actual type â€˜[Maybe (Bool, [Bool])]â€™
00:00:57 <lambdabot>     In the second argument of â€˜asAppliedToâ€™, namely
00:01:04 <mauke> I misread, sorry :-(
00:01:19 <mauke> koz_: map (fmap snd) results
00:01:53 <koz_> mauke: Thanks - forgot about fmap.
00:02:51 <simony> koz_: another option is using `maybe`, but fmap is more concise/appropriate here
00:04:01 <koz_> :t maybe
00:04:02 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:06:21 <koz_> Seriously, I sometimes wonder if I'll *ever* get Maybes...
00:06:32 <zoku> Just
00:06:34 <zoku> Nothing
00:06:35 <koz_> I can never seem to figure out how to use them properly whenever I run up against them.
00:06:35 <zoku> Just Nothing
00:07:20 <jle`> koz_: when in doubt, just pattern match :)
00:07:39 * hackagebot pandoc-crossref 0.1.6.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.6.0 (lierdakil)
00:07:39 * hackagebot stm-firehose 0.3.0.2 - Conduits and STM operations for fire hoses.  https://hackage.haskell.org/package/stm-firehose-0.3.0.2 (SimonMarechal)
00:08:02 <jle`> koz_: you'll start noticing a lot of common pattern matches you do are also provided by hof's
00:08:20 <jle`> but i think this can be seen by just doing a lot of pattern matching until you get sick of it...
00:08:36 <zoku> hofs?
00:08:40 <jle`> for example, you might find yourself doing a lot of (case x of Just y -> Just (f y); Nothing -> Nothing)
00:08:45 <jle`> zoku: higher order functions
00:08:49 <zoku> ah
00:08:56 <jle`> this common pattern matching case is just `fmap f`
00:09:06 <jle`> but there's no need to use fmap at first...just pattern matching is fine
00:12:55 * hackagebot sourcemap 0.1.5 - Implementation of source maps as proposed by Google and Mozilla.  https://hackage.haskell.org/package/sourcemap-0.1.5 (ChrisDone)
00:12:57 * hackagebot bytestring-tree-builder 0.2.2 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.2 (NikitaVolkov)
00:14:00 <koz_> jle`: I think this is not helped by the fact that the first thing I'm coding in Haskell is a custom data structure for my PhD work...
00:14:22 <jle`> welcome to the club of people using haskell for phd work ~
00:14:36 <jud> koz_, at least you're not using R
00:15:40 <koz_> jud: I may have to later - though not for this.
00:15:46 <koz_> (my PhD is in machine learning)
00:15:50 <dent> Can my computer compile fast http://postimg.org/image/5xcjjqkhz/
00:16:00 <zoku> > fmap (+1) $ Just 3
00:16:02 <lambdabot>  Just 4
00:16:22 <koz_> dent: Not with your OS eating most of your resources. :P
00:16:24 <jud> dent, not without a pen or touch input
00:16:29 <hobo> nice ram
00:16:48 <koz_> Yeah, dat RAM. What is this, a virtualization server?
00:17:00 <jud> i7? where's your dual xeon
00:17:10 <jle`> man. that is some nice ram.
00:17:11 <dent> I use it for rendering
00:17:43 <hobo> good for crunching mongodb right? XD
00:18:26 <jle`> and for /dev/null throughput
00:18:37 <jud> are you running 128gb ddr4 with that haswell?
00:18:45 <dent> yeah
00:18:52 <jud> that must've cost a bit
00:18:59 <dent> Not that much
00:19:01 <dent> only 800
00:19:11 <koz_> dent: Souls?
00:20:15 <jud> last i checked ddr4 didn't quite make sense so im waiting until that plays out before backing up a dumpster full of money to newegg's back door
00:20:49 <dent> You can buy 3600mhz dd4
00:24:20 <jud> hobo, i had a joke for you but it accidentally got deleted :/
00:24:27 <hobo> :(
00:27:39 <dent> What did the murderer say to his victim? I Haskelled you
00:31:02 <koz_> dent: ...
00:31:04 <koz_> Wow.
00:32:51 <hobo> ok that's enough for me, im going to sleep
00:40:00 <xacktm> dent: tweak it to a lolcat theme and it may pass ;)
00:44:12 <dent> I herd they where filling hard drives with helium I wonder what the floating point is
00:59:51 <ggVGc> is there a library that would let me turn a list of file paths into a tree?
01:04:13 <frerich> ggVGc: I'm not aware of anything, but if you could define something like 'insert :: FilePath -> Tree FilePath -> Tree FilePath' (to insert a given filepath into a given tree) then you could use that  to fold a [FilePath] list
01:05:46 <ggVGc> yeah, that's the function I didn't want to write :)
01:06:58 <jle`> man parametric polymorphism is invaluable now for me when i do matrix arithmetic and heavy linear algebra
01:07:17 <jle`> vectors and matricies with types that encode their length should be standard fare
01:07:21 <ggVGc> looking at this now, https://hackage.haskell.org/package/filesystem-trees-0.0/docs/
01:07:26 <ggVGc> seems like maybe what I want
01:17:52 <ReinH> jle`: their category does :D
01:18:33 <ReinH> jle`: actually CT just helped me recenty figure out which order to apply some transformation matrices in
01:19:14 <jle`> with polykinds i guess we can make a category of matricies...
01:19:48 <jle`> as in, a Category instance
01:19:57 <ggVGc> isn't this possible in some standard way? https://gist.github.com/9637f8814217bbdf3057
01:20:06 <jle`> ReinH: how did that work out? :)
01:20:10 <ggVGc> it seems like a problem that would have been solved many times
01:20:19 <ReinH> jle`: perfectly! I wrote a bunch of code and then it compiled and worked.
01:20:32 <jle`> i mean, how did CT aid you
01:20:53 <ReinH> jle`: Oh, well matrix multiplication is composition
01:21:16 <jle`> yeah, but what else besides (f . g) . h = f . (g . h) did you use?
01:21:18 <ReinH> so if I want to Translate, Rotate, and Skew, in that order, then it's SRTv for some column vector v
01:22:09 <ReinH> or, in linear terms, \v -> s !*! r !*! t !* v, or maybe !* v I can never remember.
01:22:09 <jle`> yeah
01:22:23 <jle`> ! goes on the side of the matrix i think
01:22:29 <ReinH> that makes sense
01:22:34 <jle`> and ^ is for vectors
01:22:39 <ReinH> mnemonics!
01:22:54 <jle`> the philosophy has a very lensy flaire
01:23:00 <ReinH> I also said !* twice *shrug*
01:23:08 <ReinH> jle`: well, it is a kmett joint
01:23:16 <jle`> mhm
01:23:36 <jle`> are there any actual matrix based libraries with matrices with dimensions in their types
01:23:46 <ReinH> Sure, linear :p
01:23:49 <jle`> linear is great but V i (V o a) isn't doing the best for performance
01:23:55 <jle`> i'm talking about actual matrix multiplcation, heh
01:24:01 <jle`> hmatrix style ~
01:24:08 <ReinH> ah
01:24:16 <jle`> but V i (V o a) has been good enough for my neural networks for now.
01:25:30 <ReinH> jle`: meanwhile, I can draw my hex map for my game
01:26:27 <ReinH> jle`: btw have you seen http://graphicallinearalgebra.net ?
01:26:32 <jle`> parametric polymorphism continues to yield more benefits in surprising ways that nobody ever told me about
01:27:12 <ReinH> yeah it's pretty sweet
01:27:12 <jle`> i havent, but it looks interesting
01:27:30 <jle`> ghc is like, "don't multiply those matrices" and i'm like, "ok"
01:28:55 <jle`> writing traversals is also fun because making things polymorphic just forbids a huge class of incorrect implementations
01:28:58 <ReinH> jle`: It's basically a pretty slow introduction to a CT interpretation of linear algebra based on PROP categories
01:29:04 <ReinH> worth skimming though
01:29:23 <ReinH> seeing the relationship between linear algebra and string diagrams is really interesting
01:29:32 <jle`> thanks for the link :)
01:29:34 <koz_> Parametric polymorphism is sexy.
01:30:17 <koz_> Also, I need some advice - I have two Map Int Int, and I wanna make a new Map Int Int, which has the intersection of the keys of both maps, and the values are the ratio of the corresponding values.
01:30:41 <koz_> So if we had 1 -> 2 and 1 -> 4, then the new map should have 1 -> 2/4.
01:30:48 <koz_> Wait, should be Map Int Double probably then.
01:31:00 <koz_> I'm not sure what the most sensible way to write this is.
01:31:00 <ReinH> intersectionWith?
01:31:11 <koz_> ReinH: Go figure someone wrote this already, lol.
01:31:17 * koz_ goes to check.
01:31:39 <ReinH> intersectionWith (%)
01:31:43 <ReinH> done
01:31:59 <ReinH> Wait, is % for ratios or complex numbers
01:32:00 <ReinH> dangit
01:32:16 <ReinH> yes it's %
01:33:07 <ReinH> :t M.intersectionWith (%)
01:33:09 <lambdabot> (Integral a, Ord k) => M.Map k a -> M.Map k a -> M.Map k (Ratio a)
01:33:18 <jle`> :t (:+)
01:33:21 <lambdabot> a -> a -> Complex a
01:33:30 <ReinH> and if you have a Map Int Int, use an IntMap Int instead
01:33:42 <ReinH> :t IM.intersectionWith (%)
01:33:44 <lambdabot> Integral a => IM.IntMap a -> IM.IntMap a -> IM.IntMap (Ratio a)
01:34:44 <ReinH> Oh, it's ratios because it looks like mod which has nothing to do with ratios.
01:35:01 <ReinH> obviously
01:36:22 * koz_ eagerly awaits his experimental results.
01:52:26 <simon> well, *something*, right?
01:52:28 <simon> :P
01:53:51 <jle`> ReinH: i think it's like, holes.  (%) is like, something goes int he first circle, and something else goes int he second circle :3
01:53:57 <jle`> like mixfix _ / _ => o / o
01:55:28 <FireFly> I just think of it as a tilted Ã·
01:56:32 <ReinH> or that
01:58:20 <lyxia> Is there a Foldable which is not a Functor?
01:59:46 <quicksilver> yes
01:59:50 <quicksilver> Data.Set is one example
02:00:50 <quicksilver> data Weird a = Weird a (a -> a) is another
02:00:57 <quicksilver> ( http://stackoverflow.com/questions/8359115/haskell-an-example-of-a-foldable-which-is-not-a-functor-or-not-traversable )
02:02:09 <lyxia> ah. Alright.
02:02:17 <lyxia> quicksilver: Thanks.
02:02:58 * hackagebot omnifmt 0.1.0.1 - A pretty-printer wrapper to faciliate ease of formatting during development.  https://hackage.haskell.org/package/omnifmt-0.1.0.1 (hjwylde)
02:06:44 <quicksilver> lyxia: I found this answer particularly illuminating, about the point of 'CoYoneda' - http://stackoverflow.com/a/12896512/2239956
02:07:58 * hackagebot omnifmt 0.2.0.1 - A pretty-printer wrapper to faciliate ease of formatting during development.  https://hackage.haskell.org/package/omnifmt-0.2.0.1 (hjwylde)
02:12:58 * hackagebot omnifmt 0.2.1.1 - A pretty-printer wrapper to faciliate ease of formatting during development.  https://hackage.haskell.org/package/omnifmt-0.2.1.1 (hjwylde)
02:15:09 <lyxia> Oh yes. That's fascinating.
02:17:17 <tero-> "ghc: panic! (the 'impossible' happened)" :(
02:17:40 <tero-> maybe I should buy a lottery ticket
02:23:34 <tero-> http://lpaste.net/146782
02:23:45 <tero-> am I doing it wrong?
02:25:59 <CindyLinz> tero-: Did you used "type" as a record field name? @@"
02:27:55 <tero-> CindyLinz: the JSON object contains a value with key name "type". I'd like to deserialize that in the field "type_" in Haskell record
02:29:07 <Xandaros> Maybe it has issues with the indentation of the 2nd case?
02:29:22 <Xandaros> I hate ghc panics...
02:30:23 <tero-> Xandaros: amazing. that's it. thanks :)
02:31:00 <Xandaros> Probably want to report it, if it hasn't been already
02:31:25 <tero-> ok
02:31:42 <quicksilver> looks like a case of 'unable to report error from inside TH"
02:31:44 <CindyLinz> wow..
02:31:50 <quicksilver> definitely worth reporting
02:32:59 * hackagebot git-fmt 0.2.0.2 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.0.2 (hjwylde)
02:37:59 * hackagebot git-fmt 0.2.1.2 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.1.2 (hjwylde)
02:40:00 <tero-> quicksilver: is there an existing ticket for it? I have hard time finding it
02:42:59 * hackagebot git-fmt 0.2.2.1 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.2.2.1 (hjwylde)
02:48:26 * hackagebot git-fmt 0.3.0.5 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.0.5 (hjwylde)
02:48:28 * hackagebot git-fmt 0.3.1.2 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.1.2 (hjwylde)
02:51:32 <Xandaros> tero-: in that case just assume there is none. If there is, someone will tell you.
02:51:48 <Xandaros> A duplicate ticket is better than no ticket
03:04:36 <tero-> Xandaros: ok
03:08:27 * hackagebot git-fmt 0.4.0.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.4.0.0 (hjwylde)
03:22:23 <tero-> there it is https://ghc.haskell.org/trac/ghc/ticket/11184
03:24:08 <quicksilver> \o/
03:25:01 <quicksilver> quick googling doesn't find another report of that bug
03:33:15 <tero-> I suddenly feel very useful 
03:38:44 <anohigisavay> hi. I wrote a small library and when i use it in a minimal program i got this error:
03:38:55 <anohigisavay> Failed to load interface for â€˜Jason.Parseâ€™
03:39:00 <anohigisavay> Perhaps you haven't installed the "dyn" libraries for package â€˜jason-0.1.0.0â€™?
04:10:14 <amatecha> whoa cool I was the 1500th non-op to join
04:15:55 <pavonia> Yeah, that channel is getting bigger and bigger :)
04:22:51 <quicksilver> but not actually noisier
04:22:54 <quicksilver> in fact it's getting quieter
04:22:57 <quicksilver> just more people saying less
04:24:56 <exio4> quicksilver: that's backwards
04:26:12 <quicksilver> in what respect?
04:29:31 <yellow_apple> @pl map (read . unpack) (split (=='x') x)
04:29:31 <lambdabot> map (read . unpack) (split ('x' ==) x)
04:31:13 <yellow_apple> @pl \x -> map (read . unpack) (split (=='x') x)
04:31:13 <lambdabot> map (read . unpack) . split ('x' ==)
04:31:44 <yellow_apple> @pl \x -> map (read . unpack) (split (=='y') x)
04:31:45 <lambdabot> map (read . unpack) . split ('y' ==)
04:32:17 <M2tias> wait, let me try
04:32:22 <M2tias> @pl \x -> map (read . unpack) (split (=='y') x)
04:32:22 <lambdabot> map (read . unpack) . split ('y' ==)
04:33:10 <yellow_apple> @pl \x -> product (f x) + ((*2) . sum . init . sort $ f x)
04:33:10 <lambdabot> ap ((+) . product . f) ((2 *) . sum . init . sort . f)
04:33:40 <quicksilver> if you are not aksing as part of a discussion or a request for help, you can use lambdabot in private message
04:34:02 <yellow_apple> ok
04:40:33 <guest23> I am getting a segmentation fault error even though I am not using any mutable data. The program does perform heavy numerical calculations and I get the segmentation fault with certain values.
04:42:53 <guest23> How do these faults occur? 
04:43:04 <guest23> how can i diagnose the problem?
04:45:55 <phadej> guest23: there might be some unsafePerformIO hidden under Ã„pure looking" abstractions
04:46:24 <tdammers> that, or FFI gone rogue
04:46:39 <phadej> but I'd like to hear tips about the diagnosing problem
04:47:02 <aweinstock> gdb? (might require learning about the GHC runtime innards though)
04:47:07 <phadej> (one of our services dies periodically, luckily it's stateless so I don't care that much)
04:47:11 <guest23> phadej: but I have used very standard functions like map and o FFI and no unsafePerformIO 
04:47:26 <phadej> guest23: i.e. no 3rd party library?
04:47:27 <guest23> I mean the code uses very simple things to build pure functions
04:48:00 <guest23> the only library I am using is System.Environment 
04:48:09 <guest23> that too just to get the arguments from the commandline
04:48:22 <phadej> interesting
04:48:27 <guest23> I was using Bytestring earlier and thought that could have been the problem
04:48:29 <guest23> so I removed that 
04:48:42 <phadej> can you share the code?
04:48:44 <guest23> and used String instead
04:49:55 <quicksilver> segmentation fault can be from exceeding permitted memory under an rlimit
04:49:57 <quicksilver> I believe.
04:50:43 <guest23> When I use values that do work, it runs in constant space
04:50:54 <aweinstock> guest23: can you lpaste the code?
04:51:01 <guest23> by the way, I am using fllvm backend
04:51:22 <guest23> Oh that does seem to be the problem
04:51:32 <guest23> when I remove -fllvm it seems to work fine
04:52:21 <guest23> Any reason why that could be the case?
04:52:52 <aweinstock> guest23: sounds like a potential llvm bug
04:52:55 <quicksilver> that would suggest a bug in the llvm backend
04:54:17 <guest23> I see
04:55:15 <guest23> Anyway, at least it is working without that and I dont think the llvm backend is improving the performance anyway...thanks for your help :)
04:57:41 <srhb> Is there an alternative to tables, now that it's deprecated?
04:58:01 <Taneb> srhb: there's ixset, I guess
04:58:13 <Taneb> I'm working (slowly) on getting tables undeprecated
04:58:24 <srhb> Taneb: Nice! :)
04:58:25 <Taneb> You could also use, like, an actual database
04:58:28 <srhb> Yeah :P
04:58:43 <srhb> Where's the fun in that, though...
05:06:55 <pavonia> Are there any sets of Haskell exercises for type-level programming (type families and such), ideally with increasing difficulty? I've already played with some type-level extentions, but I'd like to understand them in more detail by solving exercises related to them
05:07:56 <zomg> I don't recall if it had exercises, but I liked the Haskell For All post on type families
05:08:13 <zomg> in fact I like most of the things posted there :P
05:08:47 <quicksilver> the type-level landscape has changed so much in the last 3 years than any set of increasing difficulty exercises would be obsolete by the time you'd reached page two
05:09:04 <pavonia> :D
05:09:27 <pavonia> *a set of constantly updated exercises
05:10:23 <pavonia> zomg: Do you have a link?
05:13:15 <zomg> hm now that I tried to look for it I can't quite find it :) I'm fairly sure it was on that site...
05:13:30 * hackagebot getopt-generics 0.13 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.13 (SoenkeHahn)
05:20:54 <pavonia> Aren't these topics taught at university courses somewhere? Maybe such material includes exercises too
05:26:54 <hc> hi, say I'm having a list a=['A','B','C'] and I wish to check if all elements are part of a defined set, like this:
05:26:54 <hc> check :: [a] -> [a] -> Bool
05:27:06 <hc> so ['A','B','C'] `check` ['A','B','C','D','E']   would evaulate to True
05:27:11 <hc> and ['A','B','F'] `check` ['A','B','C','D','E']   would evaulate to False
05:27:31 <hc> any standard function available to use for that?
05:28:01 <KaneTW> > all (`elem` "ABF") "ABCDE"
05:28:03 <lambdabot>  False
05:28:03 <Jonsky> foldr elem ?
05:28:10 <KaneTW> > all (`elem` "ABF") "ABCD"
05:28:14 <lambdabot>  False
05:28:14 <hc> thanks! :)
05:28:14 <Jonsky> oh yes
05:28:16 <KaneTW> oh
05:28:18 <frerich> hc: Well you could just write 'all (`elem`... yeah, what KaneTW wrote
05:28:21 <KaneTW> not quite what you want
05:28:28 <hc> > all (`elem` "ABC") "ABCDE"
05:28:28 <KaneTW> oh nmd
05:28:29 <lambdabot>  False
05:28:30 <KaneTW> exactly it
05:28:34 <KaneTW> huh
05:28:39 <KaneTW> yeah that
05:28:45 <KaneTW> might have to inverse it
05:28:48 <FireFly> I think you mean ("ABC" `elem`)
05:28:56 <FireFly> or er
05:28:57 <hc> > all ("ABC" `elem`) "ABCDE"
05:28:58 <KaneTW> no, that doesn't work
05:28:59 <lambdabot>      Couldn't match type â€˜Charâ€™ with â€˜t0 [Char]â€™
05:28:59 <lambdabot>      Expected type: [t0 [Char]]
05:28:59 <lambdabot>        Actual type: [Char]
05:29:16 <FireFly> right, flip the literals
05:29:18 <KaneTW> > all (`elem` "ABCDE") "ABC"
05:29:20 <lambdabot>  True
05:29:21 <KaneTW> > all (`elem` "ABCDE") "ABF"
05:29:22 <lambdabot>  False
05:29:25 <hc> great, thanks!
05:29:52 <FireFly> that runs in quadratic time though, should be possible to implement it in linear time
05:30:06 <FireFly> well... if the lists are sorted
05:30:13 <exio4> linear time? based on what? 
05:30:34 <FireFly> well, O(n*m) vs. O(n+m) where n and m are the lengths of the two lists
05:30:38 <exio4> > let f xs ys = not (null (xs `intersect` ys)) in f "ABC" "ABCDE"
05:30:42 <lambdabot>  mueval-core: Time limit exceeded
05:30:47 <exio4> > let f xs ys = not (null (xs `intersect` ys)) in f "ABC" "ABCDE"
05:30:50 <lambdabot>  True
05:30:51 <hc> it's just a few elements, like 10 at max
05:30:55 <FireFly> oh, no issue then
05:30:59 <hc> so runtime is negligible imho
05:31:03 <FireFly> Yeah
05:31:33 <Jonsky> nice
05:32:52 <frerich> hc: You could also always use a set
05:33:17 <frerich> > let haystack = S.fromList "ABCDE" in all (`S.member` haystack) "ABC"
05:33:19 <lambdabot>  True
05:33:46 <frerich> (in case the quadratic part would scare you, which it shouldn't for lists this short :)
05:56:51 <lonokhov> is there Pretty working with Text?
06:05:51 <abbe> hi, is there a built-in GHC way of getting memory usage stats for a Haskell program ?
06:06:44 <pavonia> @hackage wl-pprint-text -- lonokhov 
06:06:45 <lambdabot> http://hackage.haskell.org/package/wl-pprint-text -- lonokhov
06:07:02 <lonokhov> neat, thanks pavonia
06:08:49 <Taneb> abbe: I'd give https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html a read
06:09:03 <Taneb> tl;dr is compile with -prof -auto-all and run with +RTS -p
06:09:16 <abbe> thanks Taneb
06:09:45 <Taneb> It gives time and memory usage for (sort of) every function you define
06:10:00 <abbe> cool, reading.
06:14:04 <abbe> the context of my question is https://pastebin.com/60sQRAL6, I'm wondering if "putHT" being in ST monad, actually operating on same list, or creating a new list for every prepend operation ("updateValue" function).
06:15:19 <Taneb> abbe: that'd make a new list, but they'd share a common tail, so it wouldn't copy anything
06:16:01 <abbe> cool
06:20:40 <abbe> Taneb: I guess it's same thing, as if I captured output of: foldl (flip (:)) [] list
06:21:22 <Taneb> abbe: I'm afraid I can't work out what that should be in my head
06:22:00 <abbe> sure, no worries, thanks for all your help.
06:22:08 <anohigisavay> hi
06:22:19 <abbe> Hi
06:22:55 <anohigisavay> i wrote a library that i can load succesfully in `cabal repl`
06:23:05 <chattered> Does it make sense to define an Alternative instance for ContT r m?
06:23:39 <anohigisavay> but when used in a minimal executable i got this error:
06:24:04 <anohigisavay> Perhaps you haven't installed the "dyn" libraries for package â€˜jason-0.0.1.0â€™?
06:32:55 <joneshf-laptop> I'm GETing some json with `aeson` and `wreq`. It turns out one of the values is a `JSON.stringify`d json object. Is there a way I can convert this to an aeson `Object` that's fairly simple?
06:35:12 <joneshf-laptop> to put it more concretely, I get back an object similar to this: `{id: 1234, data: "{\"foo\": [1,2,3], \"bar\": \"wat\"}"}`
06:35:29 <joneshf-laptop> and I want to convert `data` into something that isn't a string.
06:37:19 <KaneTW> joneshf-laptop: just parse it again
06:42:01 <tekkkz> hello
06:42:12 <tekkkz> how to convert an string to an double?
06:43:23 <joneshf-laptop> KaneTW, sure, so I'd need to convert from `Text` to `ByteString` for that, which is fine. I'm wondering if I'm missing something though.
06:43:34 <pavonia> > read "123.456" :: Double
06:43:38 <lambdabot>  123.456
06:43:44 <KaneTW> don't use read, it's partial
06:43:49 <tekkkz> pavonia, is it also working in a code-file?
06:43:50 <KaneTW> > reads "123.456"
06:43:52 <lambdabot>  []
06:43:57 <KaneTW> well rip
06:43:59 <joneshf-laptop> :t readMaybe
06:44:07 <joneshf-laptop> beh
06:44:09 <lambdabot> Not in scope: â€˜readMaybeâ€™
06:44:09 <KaneTW> > reads "123.456" :: Double
06:44:09 <tekkkz> > reads "12.34" :: Double
06:44:10 <pavonia> tekkkz: Note that read will fail if the string doesn't parse
06:44:11 <lambdabot>      Couldn't match expected type â€˜Doubleâ€™
06:44:11 <lambdabot>                  with actual type â€˜[(a0, String)]â€™
06:44:11 <lambdabot>      In the expression: reads "123.456" :: Double
06:44:12 <lambdabot>      Couldn't match expected type â€˜Doubleâ€™
06:44:12 <lambdabot>                  with actual type â€˜[(a0, String)]â€™
06:44:13 <lambdabot>      In the expression: reads "12.34" :: Double
06:44:20 <KaneTW> > reads "123.456" :: [(Double,String)]
06:44:22 <frerich> tekkkz: The 'Text.Read' package has a 'readMaybe' function which might be good enough for your purpose.
06:44:22 <lambdabot>  [(123.456,"")]
06:44:31 <tekkkz> > read "12.34" :: Double
06:44:31 <KaneTW> > reads "123.45.6" :: [(Double,String)]
06:44:33 <lambdabot>  12.34
06:44:33 <lambdabot>  [(123.45,".6")]
06:44:42 <joneshf-laptop> :t Text.Read.readMaybe
06:44:45 <lambdabot> Read a => String -> Maybe a
06:44:58 <frerich> tekkkz: In general though it's a hairy problem (not all supposed floating point values are representable with Double, and the decimal separator may be locale-dependant)
06:45:23 <tekkkz> ok
07:01:29 <tekkkz> this is in a do block working:
07:01:30 <tekkkz> r <- post "http://www.geocodeip.com" ["IP" := ("79.212.82.103" :: ByteString)]
07:01:30 <tekkkz>   let html = r ^. responseBody
07:01:53 <tekkkz> but how could i do a function out of this? not like this:
07:02:09 <tekkkz> http://ix.io/mIK
07:02:18 <tekkkz> any ideas what i ddi wrong? wanna see the error?
07:06:31 <lyxia> getHTML ip = fmap (view responseBody) (post ...)
07:07:26 <lyxia> tekkkz: you should apply (^. responseBody) to the result (r) of the request, not the action (post ...) which makes the request.
07:09:30 <lyxia> tekkkz: And the result type of getHTML should be IO (something)
07:09:45 <tekkkz> hm okay
07:11:39 <tekkkz> lyxia, thanks. but which type does it have? something with IO, but what?
07:12:01 <lyxia> put "IO _" as a type and the compiler will tell you
07:12:31 <tekkkz>   To use the inferred type, enable PartialTypeSignatures
07:12:33 <tekkkz> ?
07:12:42 <obadz> anyone got ideas on how to make this function simpler/more robust: https://gist.github.com/obadz/87c3dbeae71f0429eb37 (bisection search over a sorted Vector)
07:13:22 <lyxia> tekkkz: oh it doesn't seem to infer it otherwise, try to turn it on then
07:13:52 <lyxia> tekkkz: oh wait, doesn't it tell you "found hole _ with type ..."
07:13:53 <Lisa__> hi how can i remove older haskell versions?
07:14:19 <lyxia> tekkkz: in the first line?
07:15:58 <tekkkz> ahh
07:15:59 <tekkkz>  Found hole ‘_’ with type: ByteString
07:16:00 <tekkkz> ^^
07:16:06 <tekkkz> so which type has the function?
07:16:47 <kadoban> tekkkz: Then IO _ === IO ByteString
07:17:25 <FPtje> So when I Â¨cabal install cabalÂ¨, and see a message saying itÂ´s installing Cabal-1.22.5.0. When I then run cabal --version, should I find that itÂ´s cabal-install version 1.22.6.0 using version 1.22.4.0 of the Cabal library?
07:18:05 <exio4> Cabal and cabal-install are different things, one is a library, the other one is the cabal command-line tool 
07:18:24 <exio4> the former is a library, ... * :P 
07:18:24 <FPtje> Sure, but neither of them are 1.22.5.0
07:18:36 <FPtje> One is 1.22.4.0, the other 1.22.6.0
07:18:51 <exio4> have you reinstalled cabal-install? 
07:18:53 <kadoban> FPtje: The package name for the executable is cabal-install
07:19:01 <FPtje> let me try to install cabal-install
07:19:16 <kadoban> FPtje: Also, have you tried 'stack'? I like it far better than cabal-install
07:19:18 <exio4> and if you did, where is it? your PATH might have your old binary before the new one 
07:19:48 <FPtje> does stack work with cabal projects?
07:20:00 <FPtje> Installed cabal-install-1.22.6.0
07:20:01 <tekkkz> kadoban, lyxia but it needs to be ByteString instead of IO ByteString ?
07:20:15 <kadoban> FPtje: Yes
07:20:20 <FPtje> ah, the cabal library suddenly bumped to 1.22.5.0 after installing cabal-install. Thanks!
07:20:51 <kadoban> tekkkz: I'm not really clear on what you're doing/trying to do.
07:21:05 <tekkkz> okay wait a minute
07:23:07 <tekkkz> kadoban, have a look here: https://bpaste.net/show/28071afdc84a
07:23:13 <lyxia> tekkkz: what do you mean? The compiler is saying you should put ByteString instead of _. So if you wrote IO _, it becomes IO ByteString
07:23:32 <tekkkz> yeah
07:23:39 <tekkkz> but i need the type ByteString without IO
07:23:41 <tekkkz> se https://bpaste.net/show/28071afdc84a
07:23:45 <tekkkz> *see
07:24:36 <kadoban> tekkkz: How far along are you in your haskell learning? Is this basically the first thing you're doing, or have you learned the basics yet?
07:24:53 <kadoban> tekkkz: Also â€¦ why are you doing Prelude.blah everywhere?
07:25:04 <tekkkz> cause i need to do it
07:25:13 <tekkkz> cause the functions are aölso in other libs i imported
07:25:20 <tekkkz> like bytestring.lazy
07:25:46 <kadoban> tekkkz: You shouldn't need to do it, unless you did something else wrong. You should import those modules qualified.   import qualified ByteString.Lazy as BSL
07:25:47 <exio4> modules like those are meant to be imported qualified
07:26:01 <kadoban> Then you say BSL.head if you need it.
07:26:09 <tekkkz> what is qualified doing?
07:26:54 <tekkkz> kadoban, but this doesnt matter atm. please help me with my question
07:27:05 <kadoban> tekkkz: Answer mine first, also I still don't understand your question.
07:27:34 <kadoban> tekkkz: How far along are you in your haskell learning? Is this basically the first thing you're doing, or have you learned the basics yet?
07:27:42 <tekkkz> i want to split the do-blocj into several functions, like instead the first 2 lines i wanna have a getHTML function and so on
07:28:46 <tekkkz> kadoban, im learning basics by doing my ideas
07:28:46 <tekkkz> i did some learning lessons but this is not productive for me
07:30:27 <tekkkz> kadoban, ?
07:31:17 <geppettodivacin> tekkkz: The qualified keyword specifies that you must have a namespace before calls to that library's functions. This leaves Prelude functions untouched.
07:31:20 <lyxia> tekkkz: Can you paste the exact error?
07:31:33 <tekkkz> sure, wait a minute
07:32:54 <tekkkz> so i have changed my second line of the working do-block to: let html = getHTML "79.212.82.103" (my getHTML function) and then there is this error: http://ix.io/mIS
07:33:27 <kadoban> tekkkz: I'm not terribly sure how to answer that helpfully. If you started learning haskell but got bored of the lessons before you learned much, try other lessons. Learning haskell by doing a project is not a good idea, IMO. Doing projects is a part of learning haskell â€¦ after you've already done quite a bit of other stuff.
07:34:05 <tekkkz> kadoban, so please give me lessons which are good and helpful if you think that this is the right way
07:34:43 <kadoban> tekkkz: http://haskellbook.com/ would be the way I'd recommend.
07:35:15 <tekkkz> okay, but for the moment, could you please help me with this little project. i think for you its nothing difficult to solve, hm?
07:35:31 <lyxia> tekkkz: To bind the result of the getHTML action, instead of binding the action itself, use "html <- getHTML ..."
07:35:40 <kadoban> Someone else will probably be interested in that, I'm afraid that I'm not.
07:35:48 <tekkkz> ahh yeah
07:35:59 <lyxia> tekkkz: That's the same as when you used the arrow with post.
07:36:12 <tekkkz> thanks
07:36:37 <tekkkz> man, i have read yesterday about this arrow - could YOU eplain me again please? i think i didnt understand it right
07:38:09 <FPtje> the <- arrow takes a value from a monad operation and puts it in the variable on the left.
07:38:39 <geppettodivacin> IO is a monad which runs IO actions. So, in the case of IO, the arrow runs the action and then gives you the result.
07:38:50 <FPtje> yes
07:39:26 <tekkkz> ahh yah. so what is a monad? at this point i have quitted the lessons ..
07:39:40 <obadz> tekkkz: lessons is where it's at :)
07:39:55 <tekkkz> hö?
07:39:55 <obadz> tekkkz: http://learnyouahaskell.com/a-fistful-of-monads
07:39:56 <tekkkz> what?
07:40:35 <kadoban> LYAH is â€¦ not great. If you really need something free https://github.com/bitemyapp/learnhaskell is a better way to go.
07:40:45 <FPtje> tekkkz, in functional programming, unlike imperative programming, you donÂ´t say Â¨first do this, then do that, then do suchÂ¨
07:40:59 <FPtje> tekkkz, With monads, you can do exactly that, though
07:41:41 <tekkkz> exactly what? not this then this?
07:42:00 <FPtje> with monads you can tell haskell to do a sequence of things
07:42:10 <tekkkz> ahh okay
07:42:16 <FPtje> e.g. with the monad you could say Â¨First read a file, then write a file, then read from stdin, then write to stdoutÂ¨
07:42:36 <FPtje> thereÂ´s an order in the action there. Reading the file is the first thing it should do, and writing to stdout the last thing
07:42:56 <FPtje> thatÂ´s what the monad allows you to do
07:43:12 <geppettodivacin> tekkkz: Even though lessons may be boring, you might want to do your projects *and* do lessons at the same time so that you can learn while you write.
07:43:29 <FPtje> tekkkz, monads are typically THE most difficult thing to understand
07:43:32 <geppettodivacin> There's a lot of new syntax to learn when moving from something like Java to Haskell.
07:43:40 <FPtje> geppettodivacin, DEFINITELY
07:43:51 <tekkkz> yeah. i hate java. im coming from c
07:43:59 <geppettodivacin> I did, too, actually.
07:45:00 <geppettodivacin> I worked through about half of Learn You a Haskell before starting to work on my own projects, but I didn't stop reading once I started writing.
07:45:29 <tekkkz> i wnat to have this book kadoban linked
07:45:33 <tekkkz> but i have no money ;(
07:45:55 <geppettodivacin> Christmas is a mere 16 days away!
07:46:01 <tekkkz> yeah
07:46:09 <Ankhers> not close enough. I'm still working...
07:46:29 <tekkkz> and all my money i got for is spend for a new display
08:06:08 <Guest55326> Hello all, Bit of a beginner question if you don't mind.. Is it possible to do arithmetic with MonadRandom Int's and if so how?
08:06:16 <dzhus> Is there any module that defines constants like 'minutes' and 'hours' for use with 'threadDelay $ 50 * minutes'?
08:08:35 * hackagebot wai-middleware-caching-lru 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/wai-middleware-caching-lru-0.1.0.0 (yogsototh)
08:08:37 * hackagebot wai-middleware-caching 0.1.0.0 - WAI Middleware to cache things  https://hackage.haskell.org/package/wai-middleware-caching-0.1.0.0 (yogsototh)
08:09:19 <breadmonster> Interesting question re #ocaml
08:09:35 <breadmonster> Does the FFI place any limitations on where you call Haskell from?
08:09:59 <breadmonster> C is obvious, but what about say, JS or OCaml or Ruby?
08:13:36 * hackagebot wai-middleware-caching 0.1.0.1 - WAI Middleware to cache things  https://hackage.haskell.org/package/wai-middleware-caching-0.1.0.1 (yogsototh)
08:13:37 * hackagebot wai-middleware-caching-redis 0.1.0.0 - Cache Wai Middleware using Redis backend  https://hackage.haskell.org/package/wai-middleware-caching-redis-0.1.0.0 (yogsototh)
08:13:41 <osa1> does anyone know a function with type like Monad m => (a, b) -> (a -> m c) -> m (c, b)
08:13:47 <osa1> ideally in base
08:15:14 <ggVGc> wouldn't hoogle tell you that?
08:16:27 <osa1> :t first
08:16:29 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
08:16:39 <osa1> :t Data.Bifunctor.first
08:16:41 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
08:17:14 <osa1> I need something like this except the function will be monadic
08:18:05 <kadoban> :t runKleisli . first . Kleisli
08:18:06 <lambdabot> Monad m => (b -> m c) -> (b, d) -> m (c, d)
08:18:29 <kadoban> Though that's probably not as nice as you were hoping.
08:18:44 * hackagebot cereal-plus 0.4.1 - An extended serialization library on top of "cereal"  https://hackage.haskell.org/package/cereal-plus-0.4.1 (NikitaVolkov)
08:19:15 <Guest55326> Is it possible to do arithmetic with MonadRandom Int's?
08:20:20 <kadoban> ggVGc: Hoogle will â€¦ sometimes tell you.
08:21:03 <kadoban> osa1: ^ look at the above type, in case you missed it. Forgot to mention your name.
08:27:48 <pavonia> Can anyone give me an example how to use hMap from the HList package to apply a function to each element in a list?
08:30:00 <osa1> kadoban: hey thanks. yeah it's not as nice as I was hoping...
08:30:15 <osa1> kadoban: maybe I should add that to my "Utils" module with a better name :p
08:30:16 <Ankhers> Guest55326: Isn't MonadRandom about randomly generating specifically monads, and not about randomly generating arbitrary types?
08:30:37 <Ankhers> or am I completely off base?
08:31:06 <kadoban> osa1: Possibly :) I think it can be done better if you do it on the second element of the tuple instead of the first, I believe. If that somehow helps (probably not much nicer though â€¦ just shouldn't require Arrow then)
08:31:23 <Ankhers> nevermind.
08:31:52 <osa1> kadoban: with bifunctor there shouldn't be any difference I think. (first element vs. second element)
08:33:38 <Ankhers> (+) <$> getRandom <*> getRandom
08:33:43 <osa1> I don't know anything about Kleisli though
08:33:48 <Ankhers> Guest55326 ^^
08:34:08 <kadoban> Well, mine isn't Bifunctor, that's the 'first' from Arrow. But I just mean you should be able to do it without Bifunctor or Arrow if it's the second one, but I'd have to work out the type puzzle how.
08:35:46 <kadoban> Or maybe I'm wrong about that part regardless, probably ignore.
08:37:17 <osa1> :t runKleisli . Data.Bifunctor.first . Kleisli
08:37:18 <lambdabot>     Couldn't match type â€˜p0 a0 c0 -> p0 b0 c0â€™ with â€˜Kleisli m a bâ€™
08:37:19 <lambdabot>     Expected type: (a0 -> b0) -> Kleisli m a b
08:37:19 <lambdabot>       Actual type: (a0 -> b0) -> p0 a0 c0 -> p0 b0 c0
08:46:03 <obadz> so hmmm.. noone feels like helping me improve my little function?
08:46:17 <obadz> https://gist.github.com/obadz/87c3dbeae71f0429eb37 (bisection search over a sorted Vector)
08:47:12 <opqdonut> obadz: looks good, but I'd use guards instead of the if else if else :)
08:48:10 <opqdonut> also, I'd have named y vm and y' vu or something like that
08:49:05 <c_wraith> obadz, as an esoteric note, binary search on very large arrays is actually a pathological case for most caches. 
08:49:23 <obadz> c_wraith: what's the alternative?
08:49:56 <c_wraith> using a split anywhere other than exactly the middle. 
08:50:18 <obadz> c_wraith: that's better for the cache?
08:51:43 <c_wraith> it won't fall into the worst case, and as long as the split point isn't a constant away from one end, it'll keep the same asymptotics
08:52:46 <obadz> opqdonut: thanks, I've updated it
08:53:00 <obadz> I still don't like that much
08:53:23 <obadz> c_wraith: I don't understand why
08:54:22 <obadz> (gist updated)
08:54:51 <c_wraith> obadz: http://www.pvk.ca/Blog/2012/07/30/binary-search-is-a-pathological-case-for-caches/
08:55:38 <obadz> c_wraith: thanks, will read
09:03:45 * hackagebot half 0.2.2.2 - Half-precision floating-point  https://hackage.haskell.org/package/half-0.2.2.2 (EdwardKmett)
09:16:50 <_Vi> Does QuickCheck generate uniformly distributed characters for Strings?
09:23:01 <kadoban> _Vi: I doubt it. I'm also not entirely sure that that has an unambiguous definition.
09:24:49 <_Vi> kadoban, In Rust's QuickCheck it's a string from uniformly distributed Unicode codepoints, leading to strings like "ñ—Ž°ò€‡¦ò¹–»ñš‚«óš¾ª" without even spaces.
09:25:09 <_Vi> Before fixing it, it can be useful to ask how Haskell's QuickCheck deals with the problem.
09:25:29 <Xandaros> Is there a library for something like a hierarchical map? What I mean by that is, you have a map where you can look up values from keys, as normal. If you don't find any, you go up a level and check in that map, and so on. Until there are no more levels.
09:25:46 <Xandaros> It doesn't seem too specific, so I thought maybe something like that exists already. On the other hand, it is pretty specific :D
09:26:33 <moooblleee> Is 'Monad' a 'type constructor' ?
09:26:50 <Xandaros> Monad is a typeclass
09:26:51 <_Vi> moooblleee, It's a class (think "trait").
09:27:24 <_Vi> moooblleee, Other types (like Maybe) implement Monad.
09:27:34 <moooblleee> Ah Yes, I see... 'Maybe' is a type constructor
09:27:41 <Xandaros> yup
09:28:10 <exio4> well, it constructs a type of kind Constraint... :p 
09:28:35 <kadoban> _Vi: http://haddock.stackage.org/lts-3.17/QuickCheck-2.8.1/src/Test-QuickCheck-Arbitrary.html#line-471 is what it does â€¦ which doesn't look amazing to me, but not sure.
09:30:24 <kadoban> _Vi: So it basically only ever picks characters between 0 and 255, and it's biased towards 0 to 128
09:30:50 <f-a> how to uninstall ghc 7.10.2 before installing 7.10.3? make uninstall doesn't work (no rule to make target)
09:30:58 <moooblleee> exio4: 'Constraint' is a kind?
09:30:59 <_Vi> kadoban, No high plane Unicode fun?
09:31:16 <kadoban> _Vi: Doesn't appear so. It might have a newtype wrapper somewhere that does something "better", I'm not sure.
09:31:16 <exio4> moooblleee: with enough extensions.. (ConstraintKinds) ]
09:31:22 <exio4> :k Monad 
09:31:24 <lambdabot> (* -> *) -> Constraint
09:31:25 <Hijiri> f-a: I usually just install in my home directory as prefix, and then when I install a new version I just install it on top of that
09:31:32 <Denommus> anyone here made a game in FRP?
09:31:33 <_Vi> kadoban, Does it work with Text BTW?
09:31:37 <Denommus> which FRP library was used?
09:31:46 <f-a> thanks Hijiri 
09:31:47 <Hijiri> with the understanding that if things break I can start nuking stuff without breaking the whole system
09:31:57 <Xandaros> Denommus: I have. I used FRPNow, but I wouldn't recommend it. You might want to ask in #haskell-game ;)
09:32:05 <Hijiri> it hasn't broken for me yet, though
09:32:14 <Denommus> Xandaros: I didn't know about #haskell-game
09:32:23 <Hijiri> I'm writing a game using FRP
09:32:25 <moooblleee> exio4: What other kinds are there other than *, * -> *, and Constraint?
09:32:26 <Xandaros> People seem to be fond of reactive-banana and netwire at the moment
09:32:29 <Hijiri> but I'm only really planning to use it for menus
09:32:36 <Hijiri> because the actual game logic is simple
09:33:06 <geekosaur> :k StateT
09:33:06 <Hijiri> using reflex
09:33:07 <lambdabot> * -> (* -> *) -> * -> *
09:33:10 <kadoban> _Vi: Not sure if there's an Arbitrary instance for Text or not
09:33:14 <exio4> moooblleee: with DataKinds, you can lift quite a lot of datatypes to the kind system 
09:33:25 <moooblleee> ohhh
09:33:26 <Denommus> Hijiri: which library?
09:33:30 <Ankhers> kadoban, _Vi: Could write your own.
09:33:47 <moooblleee> exio4: but Constraint is a builtin it seems... at least it works in my ghci by default
09:33:48 <Hijiri> Denommus: reflex
09:33:51 <exio4> moooblleee: in GHC 8.0, the kind system and the type system will get merged, too, and it'll bring quite a few benefits, like being able to lift GADTs to the kind-level 
09:34:03 <c_wraith> exio4: I hear that in GHC 8, it'll be all of the type system. 
09:34:09 <_Vi> Can Haskell's QuickCheck be viewed as the exemplar QuickCheck that other implementations should follow?
09:34:16 <geekosaur> also there is # which is the kind of unlifted values (raw machine-level values, more or less)
09:34:20 <kadoban> _Vi: I don't think there is, since text doesn't rely on QuickCheck, and QuickCheck doesn't seem to provide one. You'd probably just 'fmap pack' if you had to.
09:34:21 <exio4> moooblleee: ConstraintKinds lets you work with 
09:34:29 <exio4> c_wraith: yeah \o/
09:34:42 <exio4> geekosaur: you can't be polymorphic on #, though, so it's a boring kind? :P
09:34:49 <moooblleee> exio4: if types and kinds will be merged does that means the separation of kinds/types goes away?
09:34:49 <geekosaur> yeh
09:34:52 <kadoban> _Vi: In most ways I'd say probably yes, though I wouldn't assume every part is perfect. In this instance, I suspect there's /something/ better you could do.
09:34:53 <Hijiri> Denommus: I'm still pretty close to the beginning, but this branch has the most recent stuff I have done: https://github.com/raymoo/mesu/tree/appy/mania
09:35:15 <exio4> moooblleee: types will have types
09:35:17 <_Vi> kadoban, Maybe testing Unicode tricks is one of them...
09:35:21 <Denommus> Hijiri: why did you choose reflex?
09:35:23 <exio4> instead of kinds! 
09:35:27 <Shockk> this sounds very interesting
09:35:31 <Hijiri> It's new and shiny, and also supposed to be performant
09:35:35 <exio4> it adds a `simple` axiom 
09:35:39 <Hijiri> with a principled interface
09:35:55 <Ankhers> _Vi: You can test unicode with QuickCheck.
09:36:00 <Hijiri> the actual standard implementation (Spider/SpiderHost) is not pure, though
09:36:11 <Hijiri> it is checked against a reference pure implementation
09:36:23 <Denommus> Hijiri: what do you mean by principled?
09:36:30 <kadoban> Ankhers: Kind of. The Arbitrary instance for Char only seems to generate a really small and kind of odd subset of possible values.
09:36:38 <Denommus> I wish some FRP library actually followed FRP's denotational semantics
09:36:48 <moooblleee> exio4: does that mean that types have types, have types  ad infinitum?
09:36:50 <Ankhers> kadoban: But you can always write your own instance.
09:37:02 <Xandaros> moooblleee: will have - yes
09:37:13 <moooblleee> oh
09:37:15 <Hijiri> well, there's nothing in the interface for getting the changes in a behavior
09:37:15 <moooblleee> interesting
09:37:16 <_Vi> Ankhers, Where is the implementation (or descriptions)? In the linked Test-QuickCheck-Arbitrary.html I don't see unicode or related things and chars are small.
09:37:40 <Hijiri> I can't think of a lot of things off the top of my head
09:37:42 <exio4> moooblleee: it will be an unsound dependently-typed programming language, pretty much
09:37:43 <Ankhers> _Vi: You can write an instance of Arbitrary for any type you want.
09:37:52 <_Vi> Ankhers, I mean out of the box.
09:38:00 <f-a> Hijiri: which directory do you use, btw?
09:38:00 <Ankhers> submit a PR?
09:38:06 <kadoban> _Vi: If it were me I'd probably start with some interesting visible characters, and maybe some of the "trick"ier ones, sure.
09:38:06 <moooblleee> exio4: will it have types-dependant-on-values like idris?
09:38:11 <Hijiri> f-a: I just use my home directory as a prefix
09:38:15 <Ankhers> There may be some reason the author didn't include it. I'm not really sure.
09:38:17 <Hijiri> I don't know if this is good practice or what other people do
09:38:26 <exio4> moooblleee: I am talking about the type system! not the value language 
09:38:28 <Hijiri> but then ~/bin contains the executables I make install
09:38:41 <exio4> moooblleee: Haskell is still not a dependently-typed programming language :P 
09:38:46 <Freddie> Could I ask for a hand with a code snippet or should I go elsewhere?
09:38:51 <f-a> ok
09:39:02 <Freddie> http://lpaste.net/146804
09:39:07 <Shockk> is it more like dependent kinds or something?
09:39:11 <moooblleee> oh okay, exio4 I have heard rumours that haskell is moving towards being dependently-typed in the near future
09:39:14 <_Vi> kadoban, That's what I am proposing (and maybe contribute) to Rusts's QuickCheck. It shall generate less "random" codepoints and more whitespace/zerowidth/BOM/left-to-right/control/special and other tricky things.
09:39:56 <exio4> Shockk: yes, I joked on other channel that we have a dependently-typed type system now :P 
09:40:05 <Shockk> is interesting
09:40:17 <kadoban> _Vi: I'd think you'd want both â€¦ some weird characters, but mostly just plain visible ones.
09:40:53 <exio4> moooblleee: it's slowly moving towards that, and getting true dependent types would be cool, the current type hackery is really nasty (both syntax-wise and semantic-wise) 
09:40:54 <_Vi> kadoban, Yes. The same set, but biased (with tricky rules) distribution instead of uniform.
09:40:57 <Hijiri> Freddie: since you are using <- syntax, the result of fully applying "f" has to be a monadic thing
09:41:04 <Hijiri> in your otherwise branch of f, you return p
09:41:10 <exio4> moooblleee: I don't believe we will have true dependent types in quite a long time though
09:41:12 <Hijiri> therefore p needs to be a monadic thing
09:41:23 <kadoban> _Vi: Make sure whatever you do generate, that it's actually â€¦ valid, I'd guess.
09:41:25 <moooblleee> exio4: ah okay, thanks for the info
09:41:30 <Hijiri> maybe you want "pure p" or "return p" instead of just "p", in your otherwise gurad
09:41:33 <Hijiri> guard
09:41:41 <kadoban> _Vi: Or maybe not, I dunno.
09:41:58 <_Vi> kadoban, In Rust (unless you write "unsafe" keyword) it should not be possible to generate invalid Unicode string.
09:42:05 <Freddie> Oh ok, Thank you.. Still getting my head around monads
09:47:12 <anohigisavay> hi
09:47:14 <anohigisavay> http://lpaste.net/146806
09:47:45 <anohigisavay> i wonder if my main function is doing any 'real computations'
09:48:09 <geekosaur> there's a decent chance that it does it once. if you were after timing it, take a look at
09:48:12 <geekosaur> @hackage criterion
09:48:12 <lambdabot> http://hackage.haskell.org/package/criterion
09:48:14 <geekosaur> ^
09:49:26 <anohigisavay> geekosaur: thanks :)
10:14:05 <glguy> anohigisavay: seq q q is the same as q
10:23:48 * hackagebot repl-toolkit 1.0.0.0 - Toolkit for quickly whipping up config files and command-line interfaces.  https://hackage.haskell.org/package/repl-toolkit-1.0.0.0 (jtapolczai2)
10:27:52 <dfeuer_> GRRRRRRR
10:28:52 <phadej> dfeuer: can we help you?
10:30:20 <dfeuer> phadej, you can get me a new computer that doesn't occasionally decide to turn itself off right when I'm in the middle of composing a GHC ticket!
10:33:48 * hackagebot repl-toolkit 1.0.0.1 - Toolkit for quickly whipping up config files and command-line interfaces.  https://hackage.haskell.org/package/repl-toolkit-1.0.0.1 (jtapolczai2)
10:39:18 <noruegs> Hey :) can someone help me here? It's a "Non-exhaustive pattern" error http://lpaste.net/146808
10:40:19 <benzrf> noruegs: well, your patterns *are* non-exhaustive
10:40:31 <benzrf> noruegs: ghc isn't smart enough to figure out that all of the call sites for aux supply something that matches at least one
10:40:51 <benzrf> oh wait, that's not even true
10:41:06 <benzrf> noruegs: sorry, i thought you meant that ghc complained about non-exhaustive patterns at compile time, as a warning
10:41:16 <benzrf> noruegs: what's confusing you exactly?
10:41:44 <noruegs> I want to separate the string "Circle 20.0" into two strings
10:42:06 <noruegs> and i think something's missing there
10:42:11 <Cale> noruegs: What happens if aux is supplied with a nonempty list as its first argument, and something other than a pair of empty lists as its second?
10:42:50 <noruegs> you mean aux ([],tail) ([],[])?
10:43:04 <benzrf> noruegs: that'd be a type error
10:43:07 <benzrf> you may have typo'd
10:43:14 <noruegs> :*
10:43:25 <Cale> aux "x" ("a","b")
10:43:30 <Cale> ^^ what happens in this case?
10:43:55 <Cale> Or to be more explicit,  aux ('x':[]) ('a':[],'b':[])
10:44:02 <noruegs> I think it should give ("x",[])
10:44:07 <geekosaur> that looks to me like it generates for "Circle 20.0" a call to: aux "ircle 20.0" ('C':[],[])
10:44:09 <noruegs> wait
10:44:10 <Cale> why would it do that?
10:44:19 <Cale> None of the patterns match
10:44:29 <noruegs> ("xa",[])
10:44:33 <noruegs> ("xa",b)
10:44:42 <Cale> That's not what your program says :)
10:44:51 <Abhi_> how to start contributing to haskell??
10:44:55 <noruegs> :/
10:45:09 <noruegs> so should I scratch that?
10:45:28 <Cale> noruegs: I mean, you should finish the definition of aux, it's incomplete
10:45:39 <noruegs> what's missing? I don't know
10:45:56 <Cale> Well, why would aux give that result for the example I asked about?
10:45:56 <noruegs> I'll try to edit the fikle and ask later ok? 
10:46:00 <Cale> Wait
10:46:06 <noruegs> ok
10:46:10 <Cale> If you think that the existing code is complete
10:46:17 <Cale> then you misunderstand something about what it means
10:46:23 <noruegs> I'm pretty new
10:46:26 <Cale> I want to find out what that is :)
10:46:43 <Cale> So, let's try evaluating aux ('x':[]) ('a':[],'b':[]) using the definition
10:46:54 <Cale> Does the pattern  aux [] result  match?
10:47:07 <Abhi_> where can i get the source code of ghc?
10:47:17 <benzrf> Abhi_: https://github.com/ghc/ghc
10:47:23 <benzrf> Abhi_: it's the first result for 'ghc source code' :)
10:47:26 <Cale> Abhi_: https://www.haskell.org/ghc/download_ghc_7_10_3#sources
10:47:27 <Abhi_> ty :)
10:47:46 <Abhi_> any bugs that i can solve?
10:48:21 <noruegs> I'll try to write what went through my head: "I will write a function that will place all Chars into the first String of the pair (String,String) and after it finds a space it will put the rest of the Chars into the second 
10:48:49 <Cale> Abhi_: You might want to ask in #ghc about that -- the same people are in here but they might be too busy to notice
10:49:18 <benzrf> it's ok, noruegs
10:49:24 <Abhi_> okay 
10:49:30 <Cale> noruegs: Well, does the expression aux ('x':[]) ('a':[],'b':[]) match the pattern aux [] result? No, right?
10:49:37 <benzrf> noruegs: at this point it'd be more useful to look at what's currently wrong than to explain how it turned out that way
10:49:37 <Abhi_> <Cale >thanks for info
10:51:26 <geekosaur> I'm not sure what Cale's example proves since as far as I can tell aux will never be called with the tuple having anything but [] in its second cell? the first cell is the problem
10:51:38 <geekosaur> that looks to me like it generates for "Circle 20.0" a call to: aux "ircle 20.0" ('C':[],[])
10:52:30 <Cale> geekosaur: The problem is just that the pattern matches are incomplete. I picked a random witness to that fact.
10:52:50 <geekosaur> yes, but that pattern can't occur (in fact there is no point to the second element in the tuple)
10:53:02 <noruegs> geekosaur that's what I thought too
10:53:31 <geekosaur> noruegs, so I showed you the call that happens for your "Circle 20.0" example. try seeing what pattern it matches
10:54:15 <noruegs> geekosaur aux xs ('C':[],[]) ?
10:54:48 <noruegs> oh I've found another problem here, it's reverse the word circle
10:54:54 <noruegs> but that's an easy fix
10:54:56 <geekosaur> you do not have that pattern
10:55:16 <geekosaur> you have: aux [] result      and    aux (x:xs) ([],[])
10:55:45 <geekosaur> which of those patterns does     "ircle 20.0" ('C':[],[])    match?
10:56:04 <noruegs> none
10:56:36 <geekosaur> so what were you expecting it to do?
10:56:58 <noruegs> with the 'i' letter or the end result?
10:57:47 <geekosaur> ???
10:58:27 <noruegs> geekosaur, with the 'i' letter or the end result? With the 'i' letter: aux "rcle 20.0" ('C':'i':[],[]) end result: ["Circle","20.0"]
10:58:37 <geekosaur> your call to sepShowPick "Circle 20.0" makes a call to aux "ircle 20.0" ('C':[],[]). What do you believe happens next?
10:58:50 <geekosaur> it does not match any pattern for the function aux
11:01:09 <noruegs> I think I'm going to ditch that code
11:01:41 <Cale> noruegs: Ditching the code is fine, as long as you understand the error. It's pretty important that you get it :)
11:01:46 <geekosaur> I'm still trying to understand what you were thinking
11:01:58 <noruegs> Cale I got it 100%, i think I have a better idea of how to do iy
11:02:00 <geekosaur> because I suspect you will end up making the same error
11:02:03 <noruegs> Cale I got it 100%, i think I have a better idea of how to do it*
11:02:52 <noruegs> geekosaur thanks for your help, but it's getting way too complicated and I feel like there's an easier way.
11:04:54 <monochrom> w00t new Haskell Platform
11:05:18 <zawefawef> hi, anyone ever had issues with 'stack ghci', reporting 'gcc: fatal error: cannot specify -o with -c, -S or -E with multiple files'. anyone knows straight what im doing wrong or is more info needed?
11:07:53 <noruegs> geekosaur I think the function words works just fine :D
11:08:45 <tekkkz> Hi
11:08:50 <tekkkz> Whyis this not working? http://ix.io/mJ3
11:11:33 <tromp__> hard to say without seeing sections definition
11:12:24 <verement> tekkkz: why does the type signature for getTR have IO for both argument and return type?
11:13:35 <OverCoder> Guys, why would this be invalid? If I replace the TypeClass Num with Floating, it compiles and works fine http://p.samuraimanpurse.com/egj3lmZI.txt
11:13:57 <tekkkz> cause input is IO
11:14:10 <newsham> zipWith f (drop 1 xs) xs    seems to come up often enough.. why isnt that a std lib func?
11:14:15 <c_wraith> OverCoder, / isn't part of Num
11:14:16 <koala_man> OverCoder: / is not defined for integers
11:14:32 <mnoonan> tekkkz: you will almost always only have IO on the return type
11:14:37 <OverCoder> Oh, so what is the alternative in this case?
11:14:45 <c_wraith> :t div
11:14:49 <lambdabot> Integral a => a -> a -> a
11:14:49 <noruegs> OverCoder div
11:14:58 * OverCoder has to learn more
11:15:04 <mnoonan> IO on the input type means you're going to do something with an actual input action, but you almost certainly are just trying to do something with the *result computed by* an input action
11:15:05 <OverCoder> Ok thanks
11:15:10 <c_wraith> except that doesn't work for all Num instances either. 
11:15:18 <tekkkz> no input is IO as well!!
11:15:34 <c_wraith> Num doesn't support any general concept of division 
11:15:54 <tekkkz> the return of this : getTags :: IO ByteString -> IO [Tag ByteString]       -- should be the input
11:16:08 <c_wraith> tekkkz, I believe you are misunderstanding what the IO type is
11:16:15 <tekkkz> no
11:16:20 <tekkkz> or
11:16:24 <Cale> tekkkz: A value of type (IO t) is nothing at all like a value of type t
11:16:25 <tekkkz> what did i missunderstood?
11:16:28 <SrPx> The type of `Î» (t : *) -> Î» (a : t) -> a` is `âˆ€ (t : *) -> âˆ€ (a : t) -> t`. Why "a" becomes "t", but the second "t" doesn't become "*"?
11:16:50 <monochrom> I'm pretty sure ByteString -> IO [Tag ByteString] is much better
11:16:56 <tekkkz> tr <- getTR $ getTags $ getHTML "79.212.82.103"
11:16:57 <Cale> tekkkz: Instead, it's like a program which if it were executed, would result in a value of type t if it finished executing normally.
11:17:02 <tekkkz> getHTML :: String -> IO ByteString
11:17:08 <tekkkz> getTags :: IO ByteString -> IO [Tag ByteString]
11:17:17 <monochrom> that is an XY problem
11:17:18 <Fuco> so there's a lot of "xml" parsers for haskell, but I can't find much for HTML.  I would like a stream parser for HTML ("sax").  Is there anything like that or should I just use xml and hope for the best? :D
11:17:22 <c_wraith> tekkkz, IO is a type whose values represent performing a sequence of IO operations. 
11:17:47 <tekkkz> monochrom,     Couldn't match expected type ‘ByteString’
11:17:47 <tekkkz>                 with actual type ‘IO [Tag ByteString]’
11:18:01 <tekkkz> you see?
11:18:08 <Cale> tekkkz: The difference between a value of type IO ByteString and a ByteString is much like the difference between /bin/ls and a list of files.
11:18:15 <tekkkz> yeah
11:18:16 <tekkkz> i know
11:18:21 <tekkkz> but i have IO as input
11:18:28 <c_wraith> tekkkz, no, you don't. 
11:18:30 <monochrom> read my http://www.vex.net/~trebla/haskell/IO.xhtml for how to do it right
11:18:31 <Cale> So here you're saying that getTR accepts such a program as its input
11:18:44 <tekkkz>     Couldn't match expected type ‘ByteString’
11:18:45 <tekkkz>                 with actual type ‘IO [Tag ByteString]’
11:18:45 <Cale> tags is not a list
11:18:48 <mnoonan> SrPx: because if I have a T and a value x : T, then your lambda gives me x, a value of type T?
11:18:54 <monochrom> your current approach is an XY problem due to your ignorance
11:18:56 <Cale> It's a program which if you were to run it, would produce a list each time
11:19:16 <tekkkz> no
11:19:23 <Cale> tekkkz: no?
11:19:33 <c_wraith> tekkkz, please stop protesting and listen to the people trying to help you. 
11:19:38 <tekkkz> ok sorry
11:19:44 <tekkkz> so please just 1 guy talking with me
11:19:55 <tekkkz> so tell me what did i misunderstood? sorry
11:20:04 <Cale> tekkkz: It's probably true that you don't want tags to be an IO action
11:20:20 <tekkkz> ya
11:20:29 <tekkkz> Cale, 
11:20:31 <tekkkz> wait a minute
11:20:47 <Cale> tekkkz: The reason you probably thought to give it that type in the first place is because there's some other IO action which you forgot to run while trying to apply getTR
11:21:10 <Cale> (but we can't see the part of your program where getTR is used)
11:21:15 <tekkkz> wait a moment. before you explain, let ME exxplain again, ok?
11:21:22 <Cale> sure
11:21:23 <tekkkz> so here is my code:
11:21:23 <lpaste> biglama pasted â€œInheritanceâ€ at http://lpaste.net/146810
11:21:29 <biglama> hi guys
11:21:29 <tekkkz> http://ix.io/mJ5
11:21:46 <biglama> i have two data types, with a minor differences
11:21:47 <tekkkz> at the main function, everything is working (and i mean the commented stuff is working, not the other one)
11:21:57 <biglama> what is the "right way" to code them into haskell ?
11:22:02 <tekkkz> i want to make sub functions out of this working lines, but at getTR im failing
11:22:04 <biglama> 1) 2 separate datatypes
11:22:09 <tekkkz> now, you can take place.
11:22:14 <biglama> 2) 1 generic datatype and the 2 derives from it
11:22:25 <biglama> 3) a common datatype with the union of all types
11:23:13 <monochrom> biglama, there is no "the", all of the above are right ways and wrong ways depending on how you will use them.
11:23:38 <tekkkz> anyone an idea now?
11:23:39 <Cale> tekkkz: It looks like you wanted to write  let tr = getTR tags
11:23:46 <tekkkz> yup
11:24:12 <monochrom> and to make things worse, you can also use 2 separate types but a common class
11:24:23 <monochrom> perhaps s/but/plus/
11:24:31 <biglama> monochrom: i'm using cassava to parse some data from a CSV 
11:24:35 <tekkkz> Cale, what you want to explain?
11:24:48 <biglama> i've read that OO-approach like inheritance are frowned upon in haskell
11:24:52 <monochrom> that doesn't nail it
11:25:11 <Cale> biglama: Haskell doesn't have inheritance.
11:25:31 <Cale> biglama: But you can do at least what I'd consider an OO approach just fine
11:25:38 <monochrom> yeah, inheritance is frown upon because you can't even do it :)
11:26:35 <Cale> biglama: i.e. if you can determine which methods your data all have in common, you can make a record of functions
11:27:10 <biglama> i meant using a common class as monochrom said (the intersection of attributes) and add the remaining attributes for each data type
11:27:20 <monochrom> but that is not OO
11:27:23 <Cale> biglama: (and then instead of "subclasses", you just have functions which produce different records of functions with the same fields.)
11:27:47 <zawefawef> hi, my 'stack ghci', is reporting 'gcc: fatal error: cannot specify -o with -c, -S or -E with multiple files'. anyone can tell me what im doing wrong?
11:27:48 <Ankhers> tekkkz: In Haskell, you generally want to write "pure" functions. You can then "lift" a function into IO. Which means you do not need to write the same function multiple times. One for being pure, another for needing to interact with IO.
11:28:26 <tekkkz> Ankhers, but how should i change my first function to non-IO ?
11:28:36 <Ankhers> tekkkz: Take simple addition as an example. We can use the (+) operator, even when dealing with IO.
11:29:15 <tekkkz> okay
11:29:21 <Ankhers> tekkkz: Do you understand what the `<-' operator is doing?
11:29:22 <luigy> zawefawef haven't seen that before... can you post an lpaste of `stack -v ghci` and I can take a look
11:29:25 <tekkkz> yes
11:29:34 <Ankhers> tekkkz: Can you explain it?
11:30:07 <monochrom> . o O ( writing an explanation has never been an objective or productive measure of understanding )
11:30:22 <tekkkz> Ankhers, i need to be afk for little time, can we resume this in ca 20 minutes please? is it ok for you?
11:30:34 <Ankhers> tekkkz: I should be around.
11:30:43 <tekkkz> thx, cu then
11:31:00 <biglama> Cale: do you have a small example ? it would be clearer for me
11:31:17 <biglama> as a side note, this SO questions points towards lenses : http://stackoverflow.com/questions/7454161/haskell-polymorphic-functions-with-records-and-class-types
11:31:36 <monochrom> yes, lenses is one more way
11:32:01 <Ankhers> monochrom: While true, it may point at a flaw in their understanding of how something is working.
11:33:47 <Cale> biglama: Like, the OO approach would be to determine what you were going to do with these things like comics and movies, and design the type around those things rather than things like these bits of text. I don't know what you're doing with these data, so it's hard to write the example.
11:34:09 <SrPx> mnoonan Sorry I do not get it. Here: (Î» (t : *) -> Î» (a : t) -> a). We know that (a : t) because we said so, so, the return type is "t". Okay. But we also know that (t : *), because we also said so. We annotated "t" giving it the type *. Why can't we say that the type of that term is (âˆ€ (t : *) -> (a : *) -> *) ?
11:34:27 <monochrom> ok, I can agree to "writing a refutable hypothesis", since then the scientific method is applicable.
11:35:20 <Cale> biglama: But to more directly answer your question, in this case, factoring out the Entry type is probably not a bad idea, and then you can make Comics have an Entry field and a series field
11:35:58 <SrPx> mnoonan the typechecker eventually will try to find the type of the second "t". It will see that on the environment, "(t : *)". So why isn't (a : t) substituted by (a : *)? If (t : *), and (a : t), then (a : *)...
11:36:01 <biglama> Cale: yeah and using lenses, getting the fields should not be too horrible
11:36:05 <Cale> biglama: OO is all about designing your values around the way they will be used
11:36:06 <biglama> thanks a bunch, I'll try that
11:36:16 <Cale> biglama: Rather than the way they'll be built up
11:36:41 <mnoonan> SrPx: Well, your expression produces a value, not a type.
11:38:06 <Cale> biglama: So, perhaps your program needs to display these entries in a GUI somehow, so you might have some kind of field representing the way in which to draw the entry on the screen.
11:38:13 <mnoonan> SrPx: More like a : (t : *), is maybe one way to look at it?
11:38:45 <mnoonan> I mean, what you're saying is like you expect : to be transitive somehow, but why?
11:38:58 <Cale> biglama: maybe not the best example in this case, because you'll also probably end up needing most of the fields you already have just to be able to e.g. sort things
11:41:49 <Xandaros> One of my students just sent me a message that the template I made doesn't compile for them due to a "UTF-8 decoding error". What's that?
11:42:35 <osfameron> Xandaros: sounds like an insufficiently detailed bug-report ;-)
11:43:25 <Xandaros> Well, I wrote the template. It IS encoded in utf-8 and they can't use it. They are using windows, though, so that might have something to do with it
11:44:09 <glguy> Xandaros: It's possible their editor or web browser changed the encoding
11:44:29 <glguy> Does the file actually have any non-ascii characters in it
11:45:02 <Xandaros> It has some umlauts in comments
11:45:13 <Xandaros> Don't think there's anything else
11:46:03 <t7> whats the most polished GUI framework to use from haskell?
11:47:09 <t7> maybe haskell isnt the best choice 
11:47:22 <t7> for gui
11:47:42 <mnoonan> t7: I got off the ground with wxHaskell pretty easily.
11:48:06 <Ankhers> t7: I've made a toy project using the gtk bindings.
11:48:48 <Xandaros> glguy: Well, I told them to remove umlauts from the comments and try again. If that doesn't work, they are supposed to make sure the encoding is correct, though I have my doubts they are able to do that :P Let's see what happens...
11:49:07 <t7> audacity is wx? :O
11:50:22 <ARM9> what's a fast parser combinator if I don't care about parsing anything but ascii?
11:51:02 <t7> atto ?
11:51:38 <jle`> ARM9: parsec and trifecta are pretty good for parsing human-written/human-readable formats
11:51:44 <geekosaur> atto is fast. not much for error reporting though
11:52:06 <ReinH> they're all fast
11:52:07 <geekosaur> usually looking for speed in parsing is premature optimization 
11:52:11 <ReinH> some are just faster than others
11:52:13 <ARM9> jle` cheers, trifecta was the one I was looking for, I couldn't remember the name at all
11:52:43 <jle`> yeah, attoparsec is mostly for machine-generated formats or binary i think
11:53:28 <jle`> *mostly used for/fills the niche for
11:54:17 <Xandaros> My only issue with attoparsec is that it can't parse nibbles or individual bits
11:54:36 <Xandaros> I wanted to parse a binary format, so I thought - hey, let's use attoparsec! Yeah, well...
11:55:06 <ReinH> Xandaros: use binary
11:55:10 <ReinH> it's designed for that
11:55:14 <SrPx> mnoonan not that I expect it to be transitive, but to find the type of the last "a", you substituted it for "t", because "a : t". Yet, to find the type of the second "t", you didn't substitute it for "*", even though "t : *". I don't understand, looks like the same syntax, the same case, yet different rules.
11:55:18 <ReinH> or cereal
11:55:19 <Xandaros> ReinH: I am using binary :P
11:55:26 <Xandaros> ...I think
11:55:34 <geekosaur> binary or cereal
11:55:41 <Xandaros> I'm using binary and binary-bits
11:56:17 <SrPx> just look at it... (Î» (t : *) -> Î» (a : t) -> a)... "a" is substituted for "t", but "t" isn't substituted for "*". Why? It is the same thing, just different names.
11:56:17 <ReinH> geekosaur: I still like bytes
11:57:03 <mnoonan> SrPx: No, it's not the same thing at all. You're taking a value and doing one level of abstraction to get a type. Another level would get you a kind (*).
11:57:43 <mnoonan> a : t isn't a substitution, it's a statement about how a can be abstracted (once)
11:57:43 <ReinH> Maybe the confusion stems from the notation using : to mean both "is of type" and "is of kind"?
11:58:03 <mnoonan> yeah, it might be clearer with (a :1 t) and (t :2 *), maybe?
11:58:41 <monochrom> Xandaros: Windows command prompt defaults to a national non-Unicode codepage. to get UTF-8, use codepage 65001 (chcp 65001). alternatively, to eliminate this manual chore, write your Haskell program to explicitly select UTF-8
11:58:44 <SrPx> mnoonan but when the checker reaches `typeOf (Var "t")`, how does it know it shouldn't substitute it, but when it reaches `typeOf (Var "a")`, it knows it should substitute it by "t"?
11:59:01 * hackagebot gnss-converters 0.1.0 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.0 (markfine)
11:59:15 <ReinH> SrPx: But that isn't substitution.
11:59:24 <ReinH> If anything, it's evaluation.
11:59:31 <Xandaros> monochrom: So, how would I write it to explicitly select UTF-8?
11:59:35 <mnoonan> SrPx: when does it reach typeOf (Var "t")?  Wouldn't it go typeOf(Var "a") => t?
11:59:43 <SrPx> But the checker has a case like: "typeCheck env (Var x) = env !! x". 
11:59:48 <monochrom> look for hSetEncoding in System.IO
11:59:50 <Xandaros> And is there a way of testing it without setting up a windows VM?
12:00:23 <mnoonan> Sure, that's like what I just said. Look up the typeOf "a" in the environment. Nothing about looking up the type of *that* result!
12:00:26 <monochrom> no, apart from physical Windows
12:00:28 <tekkkz> Hey Ankhers , have a look at private message pls
12:00:31 <SrPx> mnoonan hmm eventually you're going to call "typeCheck" on the type of a binder, no? So it would recurse inside it, until it reaches `Var "t"`
12:00:36 <james_rth> has anybody ever had trouble with exporting Control.Lens.Wrapped types?
12:00:53 <james_rth> They're working fine in a lib - just not when I pull that lib into another package...
12:00:54 <SrPx> mnoonan yes, but when typeCheck is called against `Var "t"`...?
12:01:07 <monochrom> because Linux defaults are so different from Windows defaults that you can't test this on Linux and extrapolate to Windows
12:01:12 <Xandaros> monochrom: Well, the problem occurs when loading an assignment template (a library where most things are just holes) into ghci...
12:01:16 <mnoonan> it isn't, at least not there :)
12:01:52 <monochrom> otoh I think ghci already explicitly selects UTF-8 when :load'ing
12:02:21 <SrPx> mnoonan typeCheck isn't called against `Var "t"`? Ever? Why? It doesn't go inside `TYPE` in both (Î» VAR : TYPE -> BODY) and (âˆ€ VAR : TYPE -> BODY) ?
12:02:32 <Xandaros> They should juse use an OS with sane defaults -_-
12:03:24 <monochrom> I wouldn't blame it on OSes. the cause is more deeply-rooted than that.
12:03:40 <Xandaros> Okay, they told me it was their editor. If they download it fresh, it works
12:03:46 <Xandaros> So... editor's fault
12:04:20 <monochrom> the cause is human's tendency to be nationalistic and forget that the world has other nations, and moreover some people actually want to use more than one national languages
12:05:24 <monochrom> commercial OSes just try to sell to popular opinion
12:05:26 <_Vi> National Haskell dialects?
12:06:20 <mnoonan> if you want to check (Î» a : t -> X) : t', you just check that in a context with (v : t) then X[a := v] : t', right? You don't need to dig into the kind of t' here.
12:07:00 <monochrom> in this backdrop, Apple went Unicode early, only because Steve Jobs said so. Microsoft eventually went Unicode, only because the lucrative market of China set a deadline.
12:07:55 <OverCoder> Apple went Unicode? so as Microsoft? What does that even mean?
12:08:08 <OverCoder> Isn't Unicode is just a type format/system thing for text?
12:08:11 <monochrom> it means native support in OSes
12:08:23 <OverCoder> ._.
12:08:35 <OverCoder> Doesn't Windows already support that?
12:08:44 <monochrom> not before year 2000
12:08:48 <OverCoder> I mean we can see Unicode characters through editors
12:08:48 <geekosaur> _Vi, might need that anyway. Haskell is case sensitive (and must be, as recognizing constructors is designed), which means it has issues with identifiers using CJK ideographs, Arabic, Hebrew, etc. where case is not a thing
12:08:53 <OverCoder> and charmap exists
12:09:07 <geekosaur> OverCoder, you couldn't for a long time., it only did code pages
12:09:09 <OverCoder> Ah so you're mentioning such a very old shit?
12:09:23 <geekosaur> it matters because the underpinnings are still based on that
12:09:25 <OverCoder> Hm
12:09:36 <geekosaur> which is why you have to change code page in CMD.EXE for Unicode stuff to work
12:09:47 <koz_> Losedow$ defaults to UTF-16, while the rest of the world defaults to UTF-8.
12:09:52 <koz_> Because Micro$atan can't standards.
12:09:59 <koz_> Formal or informal.
12:10:00 <geekosaur> the programmer APIs were upgraded, the I/O system wasn't for the most part
12:10:20 <monochrom> OverCoder, the problem is that because garbage such as iso-8859-1 and windows-1251 existed in the 1990's, today in the year 2015 there are still a lot of people stubbornly holding on to them
12:10:21 <geekosaur> no, UTF16 was a bone thrown to CJK
12:10:53 <geekosaur> ...which becme a liability when Unicode expanded past U+FFFF
12:11:01 <zomg> lol, losedow$ and micro$atan.. what is this, 1999 l44t h3xx0rs?
12:11:03 <OverCoder> Hm
12:11:03 <OverCoder> geekosaur, Alright so treat me dumb, CMD.EXE doesn't really support Unicode? neither PowerShell?
12:11:16 <OverCoder> Ooh man my lag is 14 seconds :|
12:11:24 <geekosaur> it's the I/O subsystem that doesn't support it properly
12:11:26 <koz_> zomg: Why not? I don't see why they deserve non-derisive names.
12:11:33 <koz_> Since they still suck just as hard.
12:11:39 <geekosaur> so, since CMD.EXE creates a terminal window, that is constrained by code pages
12:11:41 <OverCoder> I think UTF-8 should be the standard of today
12:11:48 <koz_> OverCoder: It is, for almost everything.
12:11:50 <geekosaur> it tries to hide it, but you can't hide it completely
12:12:00 <OverCoder> Mhm, got it
12:12:05 * OverCoder slaps cmd
12:12:37 <geekosaur> CMD.EXE would likely instantly work more sanely if the I/O subsystem were made more natively Unicode --- but that would break too much stuff
12:12:50 <geekosaur> that assumes that I/O is constrained by code pages
12:13:23 <geekosaur> (keep in mind that Microsoft has been trying, withincreasing amounts of desperation, to jettison the backward compatibility stuff for years)
12:13:37 <geekosaur> (it's their enterprise customers that hold things back for the most part)
12:13:48 <OverCoder> Seriously saying, when did UTF-8 exist? I mean they should've made changes long time ago
12:13:51 <SrPx> mnoonan hmm that is true... hmm... okay... thanks
12:14:30 <OverCoder> Ah got it
12:14:32 <geekosaur> please consider that there are government and fortune 50 places that still have a lot of OS/2 deployed. you think they're going to move to UTF8 or even UTF16 just on Microsoft's say-so?
12:14:50 <OverCoder> Yes?
12:14:55 <geekosaur> ...
12:14:55 <OverCoder> Why not? :P
12:15:04 <geekosaur> oy
12:15:16 <geekosaur> do yourself a favor and never try to work for one of those places.
12:15:22 <Xandaros> monochrom: You surprised me there. From your previous statements I thought you were one of those people :D
12:15:31 <geekosaur> THEY call the shots. their vendors must comply
12:15:47 <geekosaur> so Microsoft is stuck with a lot of legacy crap that even they hate, but can't get rid of
12:15:59 <OverCoder> Wooh :enlarging_eyes:
12:16:22 <OverCoder> Hm, I really didn't know that
12:21:12 <geekosaur> they did manage to get rid of a big chunk of it; win7 and later have much cleaner insides because they got to make a bunch of legacy stuff go away. but they couldn't get rid of all of it.
12:22:40 <pilne> how "intrusive" is the gc in haskell for soft and hard realtime applications?
12:24:16 <the_2nd> how can I alter a data object with a function
12:24:38 <the_2nd> to only change a certain value , without having to type newA = oldA etc.
12:24:43 * OverCoder gives up on Higher order functions
12:24:45 <OverCoder> Crap!
12:24:54 <the_2nd> I have e.g. 10 vales and only want to change the position
12:25:15 <OverCoder> Functions that return functions whose returns functions to a functions aaaaaaaah! I don't/won't get it ._.
12:25:49 <the_2nd> is this possible or not?
12:26:15 <byorgey> OverCoder: don't give up!  just put it down and come back to it later
12:26:29 <byorgey> OverCoder: if you are confused that means you are learning something
12:26:39 <pilne> once higher order functions "click" you will loathe any language that does not have them >.<
12:26:50 <jle`> the_2nd: you can use `map`, maybe
12:26:54 <OverCoder> Hm, I am not really sure if I could really continue the tutorial without it :|
12:26:54 <jle`> can you give a specific example?
12:26:56 <OverCoder> But fine
12:27:04 <jle`> the_2nd: of an implementation you have that works, and we can try to simplify it
12:27:24 <byorgey> OverCoder: I don't mean to go on in the tutorial, I mean, like, go take a walk or something =)
12:28:58 <pilne> in haskell declaring x = 5, is creating a function "x" that only returns 5 is what made it really click for me
12:29:56 <the_2nd> jle`, something like this : http://pastebin.com/Lmy5pasT   (untested currently)
12:30:14 <the_2nd> since I only have to change the current position, all the other lines are kinda useless
12:30:41 <the_2nd> applytime t s = ... ofc
12:30:49 <johnw> pilne: careful that you don't confuse a value with the function "const 5", which really does fit your description of something that only returns 5
12:30:57 <jle`> the_2nd: you can use record updating syntax
12:31:01 <pilne> fair enough
12:31:10 <OverCoder> byorgey, Ooh, haha, yeah I am confused, I am just doing sort of a re-wash, doing all the examples on my own :P
12:31:30 <jle`> the_2nd: x { foo = ... } will return x with only `foo` modified
12:31:32 <OverCoder> I seem to be good for a while, it's just the tutorial making it hard
12:31:38 <jle`> the_2nd: and everything else unchanged
12:31:41 <jle`> *the foo field
12:31:54 <jle`> the_2nd: so you can do applyTime s i = s { shotNow = ... }
12:32:06 <jle`> and the result will be s, with every field the same except for shotNow
12:36:05 <the_2nd> jle`, looking good
12:36:13 <the_2nd> other question about files etc.
12:36:46 <the_2nd> put data definitions in one file, class definitions in another, instances in one or many and import instance file(s) from main?
12:37:11 <the_2nd> currently I have a class file which imports the data file, and once I import both in Main I have a problem
12:37:35 <jle`> hm, what's the issue?  i usually have my classes and types in the same file
12:37:48 <the_2nd> ambigous imports
12:37:58 <jle`> what is ambiguous?
12:37:59 <the_2nd> Data.Shot or Dynamic.Shot
12:38:02 <jle`> oh
12:38:16 <jle`> are they both data types?
12:38:35 <the_2nd> In Data I have data = definitions for all my datas
12:38:52 <the_2nd> In Dynamic I have class dynamic and instances of datas and dynamic
12:39:23 <the_2nd> In Main I have to import Data and Dynamic, since not all datas in Data are of class Dynamic
12:39:42 <the_2nd> Datas / Classes / Instances each one file?
12:39:57 <jle`> you probably shouldn't give your classes the same names as your types
12:40:12 <the_2nd> didnt
12:40:29 <the_2nd> nm wait
12:40:31 <jle`> if Data.Shot and Dynamic.Shot refer to the same data type, then there shouldn't be an ambiguous import problem?
12:40:56 <jle`> the only thing would be if you had two data types both named Shot, or one type and one typeclass both sharing the same name
12:40:58 <the_2nd> jle`, my bad
12:41:05 <the_2nd> I screwed up my source code
12:41:22 <jle`> sall good
12:52:10 <Fuco> I have two packages, one depends on process-1.1.0.2 and another on process-1.4.1.0, ghci complains "GHCi runtime linker: fatal error: I found a duplicate definition for symbol runInteractiveProcess" ... anything I can do?
12:54:03 <Fuco> hm, when I ghc --make it it works, so I guess I don't care that much 
12:54:39 <hopla> Hello, I am compiling standalone executables and DLLs using GHC on Windows. Unfortunately, they depend on the system msvcrt.dll. Microsoft strongly advises not doing it for compatibility reasons. Is there anyway to not depend on it at all?
12:56:05 <spuz> Hi, why do I get this compile error? https://gist.github.com/anonymous/2a99180f2bd4b6da2b4d
12:56:30 <spuz> I am trying to count the number of Strings in the given Map of Maps
12:58:47 <spuz> slightly more accurate version: https://gist.github.com/anonymous/a9670874d0cb7defaa08
13:03:31 <aweinstock> spuz: either (\x -> \y -> f x y) or (\x y -> f x y) work, you have (\x -> y -> f x y)
13:04:05 <spuz> aweinstock, thanks
13:18:49 <pilne> how "intrusive" is the gc in haskell for soft and hard realtime applications?
13:19:15 <nyon> Is there any situation in which defining (>>=) in terms of join can result in worse performance or something equally undesirable?
13:20:38 <latro`a> @nyon I think that depends on whether you can do fusion or not
13:20:38 <lambdabot> Maybe you meant: yow nixon
13:20:47 <nyon> Ah.
13:21:01 <latro`a> for instance, concat . map f, if unfused, traverses twice
13:21:07 <latro`a> whereas concatMap f traverses once
13:21:53 <edwardk> @remember shapr I used to use #haskell as my own channel, but that's why #haskell-blah was created... after CosmicRay trained a markov bot on ten years of #haskell logs, and it kept trying to talk to me about unicycling :-(
13:21:54 <lambdabot> Nice!
13:22:13 <luite> hehe
13:22:23 <nyon> latro`a: However, since Haskell is lazy, the worst that could happen is that the unfused version creates more thunks, right?
13:22:53 <latro`a> if it's a finite list and you fully evaluate it, then you do two full traversals
13:23:10 <nyon> latro`a: That is, the time complexity of `join . map f` is the same as `(>>= f)`, right?
13:23:11 <latro`a> maybe not at once, but at the end of the day
13:23:23 <latro`a> the asymptotic complexity will be the same absolutely
13:23:57 <latro`a> but it could happen that join . map f does two comparably difficult loops
13:24:08 <latro`a> to the one done by (>>= f)
13:24:18 <latro`a> in which case the constant factor would be larger for join . map f
13:24:29 <nyon> Mmm.
13:27:09 <nyon> It's just that I kinda dislike how (>>=) merges two separate concerns. It'd be much nicer if (>>=) were a convenience function defined in terms of join and map. Ditto extend and duplicate, although the Comonad class fortunately gives you the ability to choose.
13:32:08 <benzrf> nyon: SAME
13:32:24 <benzrf> nyon: i swear ive said almost literally that exact line like 5 times
13:33:05 <dolio> Unfortunately for you, the difficult question is if you can come up with any substantive examples where defining (>>=) in terms of join is _not_ inefficient.
13:35:34 <Cale> nyon: Often in the cases we're interested in for programming, (>>=) is the more fundamental operation, and join is a funny and seldom-used consequence. You can look at it either way.
13:35:42 <edwardk> nyon: the current issue is that join/duplicate screw up generalized newtype deriving under the new system
13:36:14 <edwardk> we planned on bringing join into Monad in 7.10 as part of the AMP.
13:36:21 <edwardk> but it didn't happen because of type roles
13:36:36 <nyon> Ah, I've seen these things called "type roles" in GHCi. I just don't understand them.
13:37:29 <edwardk> nyon: before it was possible to derive unsafeCoerce with GeneralizedNewtypeDeriving -- which could lead to things like real segfaults, etc.
13:37:36 <edwardk> so they came up with a pretty wonky fix
13:37:41 <edwardk> which closed the gap
13:37:52 <edwardk> but ruled out many good uses of GND too
13:37:55 <nyon> :-O
13:38:06 <shapr> edwardk: ha
13:38:26 <nuberino> hi guys, i'm trying to compile windows binaries on a linux host. im stuck trying to build a cross-compiling ghc because of https://ghc.haskell.org/trac/ghc/ticket/10070
13:38:40 <nuberino> are there other ways to do what i want?
13:38:48 <nuberino> also i have no idea what im doing whee
13:39:28 * nuberino slaps a4j around a bit with a large fishbot
13:39:38 <Cale> nuberino: I would probably look into running a virtual machine or something.
13:39:47 <monochrom> please don't slap anyone or anything
13:40:01 <Cale> nuberino: I'd expect that to be *way* simpler than trying to get cross compilation to work.
13:40:12 <nuberino> :(
13:40:17 <nuberino> that's unfortunate
13:40:31 <monochrom> ghc doesn't have a practical story for cross-compiling. not for linux->windows. use a virtual machine. or rent one.
13:40:44 <edwardk> class Is a b | a -> b, b -> a where is :: f a -> f b; instance Is a a where is = id;   you could use GeneralizedNewtypeDeriving to subvert the functional dependency w/ something like newtype Age = Age Int deriving (Is Int)    -- but when f is a GADT this could be eeeevil.
13:41:08 <monochrom> it has a practical story for haskell-js. it probably also has an ok story for linux-x86 -> linux->arm.
13:42:17 <nyon> edwardk: Isn't this more of a problem with GADTs, though?
13:42:32 <Cale> It's hard to blame GADTs for anything
13:42:44 <monochrom> to a large extent I think linux->windows is just a matter of "but a linux installation lacks windows libraries"
13:42:46 <edwardk> Well it doesn't need GADTs just 'anything that depends on instances for the type', since if for instance Age was sorted in the reverse order instance Ord Age where Age a `compare` Age b = compare b a then using 'is' to coerce 'Set Int' into 'Set Age' would break the Set.
13:42:59 <nyon> Cale: Except for the fact you can now make distinctions between isomorphic types? (Even if only at the type level.)
13:43:41 <Cale> nyon: You always could make distinctions between isomorphic types.
13:43:49 <edwardk> so now we have three 'roles' for a type. phantom, in which case it doesn't appear anywhere in the type and you can safely coerce f a -> f b, 'representational' saying if you can coerce a into b, you can coerce (f a) into (f b). and nominal which says even if you can coerce a into b  you don't get the power to coerce (f a) into (f b) for free.
13:44:03 <monochrom> and to an even larger extent, the economics of ghc work is such that academic papers is the currency, so adding a new type system extension is more profitable than adding a cross compilation.
13:44:12 <nyon> Cale: How, other than using IORef/STRef/etc.?
13:44:14 <Cale> nyon: At least, as long as type classes have been around.
13:44:21 <nyon> Ah, sure.
13:44:23 <nuberino> there are mingw packages for debian
13:44:26 <edwardk> nyon: instances
13:44:27 <Cale> The fact that types are isomorphic doesn't mean a whole lot
13:44:59 <edwardk> nyon: we often build data types like Set, Heap, Map, etc. that rely on the coherence of instance resolution to always get the same instance at each use-site
13:45:46 <edwardk> otherwise there is a big difference between a data type that carries around an instance it was given when it was made and one that moves the passing of the instances to where they are actually used.
13:46:29 <edwardk> nyon: in https://www.youtube.com/watch?v=hIZxTQP1ifo I talk a lot about the coherence issues
13:46:32 <nyon> edwardk: Yeah, I've seen in your... errr... list of complaints against Scala, how coherence is a big deal.
13:46:39 <nyon> And I actually agree.
13:47:28 <edwardk> hah. i wrote that as a sort of off the cuff response to tekmo saying something about how scala gets away with stuff so it isn't that bad -- and it sort of went viral
14:06:46 <varaindemian> what is the section of www.learnyouhaskell.com where I can learn more about Parsers?
14:07:13 <varaindemian> http://learnyouahaskell.com/
14:07:47 <varaindemian> Are Functors and Parseers the same?
14:13:13 <c_wraith> varaindemian, that question is very difficult to answer beyond "no". what led you to ask it? 
14:14:51 <varaindemian> c_wraith: I can not find anything related to Parsers on http://learnyouahaskell.com/
14:15:31 <c_wraith> why would there be? They're not part of haskell. 
14:15:56 <c_wraith> except in the sense that all compilers must have parsers. 
14:16:01 <varaindemian> in the course I am taking they start talking about Parsers right after Higher-Order Functions and a lot of the notions there are totally strange for me
14:16:21 <c_wraith> (even php, bizarre as its parser used to be) 
14:17:25 <varaindemian> c_wraith: do I need to understand things like Functors, Applicative Functors and Monoids before going into Parsers?
14:18:01 <frerich> varaindemian: LYAH does not discuss parsers, but Real World Haskell does ( see http://book.realworldhaskell.org/read/using-parsec.html ). However, for a *very* nice introduction to parsers, I would recommend Graham Huttons 'Programming in Haskell', because that's really the essence of it.
14:18:02 <c_wraith> varaindemian, I feel like you may be misunderstanding. Parser is not the name of an abstraction. 
14:18:43 <c_wraith> varaindemian, a parser is a program (or portion of one) that recognizes input that matches a grammar. 
14:20:49 <c_wraith> varaindemian, for instance, regular expressions parse regular grammars. 
14:20:51 <monochrom> the best accidental joke of all time: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg25453.html
14:21:53 <c_wraith> fix linking to itself sounds like what you find googling for recursion. 
14:22:05 <monochrom> yeah!
14:22:39 <akegalj> my cabal file has library section, and 5 exacutable sections. Can I selectively tell stack to build only one of this sections (not all). ie `stack build :name-of-exe` ?
14:23:32 <frerich> monochrom: Teehee - I briefly hoped it was intentional, but now I see that all the hyperlinks on the release notes point to the same page
14:25:10 <MarcelineVQ> What is the default fixity and precidence of prefix function in infix notation? `ap` for example
14:25:35 <c_wraith> I believe the default is always infixl 9
14:26:10 <c_wraith> but you can always set the fixity explicitly, even for prefix functions in backticks 
14:26:29 <MarcelineVQ> Yes I had to do that just now which lead to me wondering about the defaults :D
14:26:41 <monochrom> yeah, infixl 9
14:26:52 <akegalj> I got an answer on #haskell-stack. thnx though
14:27:08 <MarcelineVQ> c_wraith, monochrom: thank you
14:41:36 <shirt> how can i print a Double value without scientific notation?
14:42:23 <Cale> showFFloat will do it
14:42:28 <Cale> from Numeric
14:42:36 <Cale> > showFFloat (Just 2) pi ""
14:42:38 <lambdabot>  "3.14"
14:42:46 <Cale> > showFFloat Nothing pi ""
14:42:48 <lambdabot>  "3.141592653589793"
14:43:19 <monochrom> > showFFloat (Just 10) (0.000000123) ""
14:43:21 <lambdabot>  "0.0000001230"
14:43:51 <monochrom> whereas normal show will give you scientific notation for that small number
14:44:23 <Cale> yeah, probably a good idea to actually demonstrate that :)
14:45:36 <shirt> thanks
14:46:07 <monochrom> otoh I am not fond of the very idea of "round to N decimal places". it is a poor measure of error bounds. number of significant figures, which implies scientific notation, is the right measure.
14:47:27 <Cale> shirt: In case the idiom is unfamiliar, the final String parameter is a string to add the result to the beginning of. The idea is that you can construct a bunch of String -> String functions and then compose them together to produce a long string rather than repeatedly concatenating (which can be more efficient in the case of repeatedly adding to the end, because xs ++ ys takes O(length xs) steps to evaluate, while f .
14:47:27 <Cale>  g only ever takes one, so you can get a reduction from quadratic to linear time)
14:48:22 <shirt> Cale: cool, like shows right?
14:48:27 <monochrom> yes
14:48:29 <Cale> yes, exactly
14:48:40 <monochrom> use showFFloat etc like you use shows
14:49:29 <shirt> can the optimizer convert "show a ++ show b ++ show c" into a chain of shows calls?
14:51:00 <monochrom> I'll put it this way: "show a ++ show b ++ show c" and "(shows a . shows b . shows c) """ are going to end in pretty much the same machine code. because that's too easy. the real deal is when you have recursion
14:51:53 <glguy> shirt: No, it can't. 
14:52:00 <glguy> It'll leave the calls to ++ in there
14:52:54 <glguy> shirt: In general those might not even be equivalent. A user might have done something evil when implementing the class
14:52:59 <exio4> well, if you implemented shows as (show x ++) ... :p 
15:00:13 <SrPx> What is the best resource to learn HoTT right now, for someone with no mathematical background, which happens to be me?
15:01:00 <frerich> Aaaah... I never knew why 'ShowS' has this crazy type, now I get it...
15:03:14 <jle`> it's like diff lists in base :o
15:03:47 <jle`> here are also parser combinators in base too.  a lot of cool libs actually have "minimal" implementations in base just for doing base-y stuff
15:04:21 <jle`> who needs parser combinator libraries when you have Text.Read :)
15:05:49 <icen> SrPx: no maths background might be a little tricky; I found the book okay (but I have a maths background, and I don't claim to really understand the subject, I could just do the exercises of the bits that I read!) you might have some luck if you followed with a good algebra text close by, though
15:06:19 <SrPx> icen just an algebra book?
15:07:21 <frerich> Cale: Hm, but - (++) is right-associative. So 'show a ++ show b ++ show c' is 'show a ++ (show b ++ show c)' - so the string being built is never the first argument, the expression just prepends strings. Isn't the overall complexity thus O(n)?
15:07:37 * frerich looks at the clock and suspects this msut be a nightly brain fault of his somewhere...
15:07:41 <Cale> frerich: If associated that way, yes.
15:07:54 <Cale> frerich: But if you're building up a long string recursively, you may not have the option
15:08:12 <SrPx> is there any simple superfitial a/j math
15:08:44 <SrPx> that is me noticing I'm making a math question on #haskell and failing miserably in joining #math
15:09:08 <monochrom> "f x = f (g x) ++ show x" and "f x = show x ++ f (g x)" are very different. the former is quadratic-time
15:09:08 * hackagebot bond 0.4.0.1 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.4.0.1 (sapek)
15:09:51 <Cale> SrPx: I wouldn't have understood what your question meant even if you asked it in ##math
15:10:10 <icen> SrPx: at least, the problems I had with definitions/etc came from algebra, that might just be me
15:10:10 <monochrom> but sometimes you really want the same answer as "f x = f (g x) ++ show x". here is an efficient way to get the same answer: f x = f (g x) . shows x
15:10:12 <SrPx> Cale it is not complete ...
15:10:34 <Cale> oh, "What is the best resource to learn HoTT"?
15:10:41 <monochrom> this is why ++ vs diff-list-compose does not matter until you have recursion.
15:10:42 <icen> (I'm interpreting 'learn HoTT' as 'have the slightest clue what's going on')
15:10:45 <Cale> "a/j math"?
15:11:21 <SrPx> "a" <- attempt to select all the text on the input field, "/j math" <- command to join the #math channel
15:11:43 <SrPx> icen that is kinda my intention, yes
15:12:32 <SrPx> I wish it could be different, though. Why are those things so complex? God didn't make a good job in simplifying The Source Code
15:13:10 <frerich> monochrom: Ah, I get it now. Yeah - in particular, until you have recursion on the first argument of (++)
15:13:22 <icen> SrPx: wrt theology, have you compared actual source with decompiled source? We're hardly going to get the *best* impression
15:13:28 * frerich suspects "recursion on" is not the right way to phrase...
15:13:50 <monochrom> I think it's a right wording
15:14:09 <SrPx> icen (: that's a nice way to put it. one day, eventually?
15:18:40 <frerich> monochrom: Would it be totally crazy to say something like (++) being O(1) with respect to the second argument (i.e., the runtime is independant of the length of the second argument for some given first argument)? If so, maybe one can say that for anything function 'f x y' you can use this composition trick to get the complexity down to the 'better' of the two arguments?
15:19:04 <arahael> frerich: You mean, by possibly flip'ing it?
15:19:04 <frerich> s/anything function/any function/
15:20:01 <frerich> arahael: Yes, but more importantly - if you have a function 'f x y' which is O(log n) with respect to 'x' and O(n) with respect to 'y' (does that statement even make sense??) then you can use this composition trick to get recursive applications of 'f' to be O(log n)
15:20:36 <SrPx> Okay two questions, 1. how would one implement equality (the "a = b" type) on CoC? It is hardcoded in Idris, so I can't study how it works from there. 2. where do I learn that kind of stuff about using dependent types?
15:21:07 <kadoban> frerich: You'll probably want to use separate variables to mean the lengths of each list, or whatever you're measuring. Or use a combined variable to mean the length of both combined, whichever makes sense.
15:21:21 <arahael> frerich: You'd need a very, very low overhead for determining which application you need - _and_ you'd need to know the relative overhead of the two algorithms, otherwise you might just do the O(log n) algorithm every time.
15:21:36 <kadoban> frerich: So you'd be able to say sometihng like it's O(n + lg m), where n is the length of the first list, m is the length of the second (whatever, just an example)
15:23:09 <arahael> frerich: Alternatively, if N is known to be possibly very large, and it is a fundamental part of the application, you could just fork two threads, and return which ever one returns sooner.
15:27:05 <LeanderK> hey, i started learning haskell....and as you might have guessed my code does not compile. This is the code: http://lpaste.net/146827
15:27:33 <LeanderK> i hope i understood foldMap right. This is comparable to flatmap in other languages, am i right?
15:28:44 <joehillen> LeanderK: record field assessors go on the left, they are regular functions. so it should be "upLeft (area x)"
15:28:52 <monochrom> @type foldMap
15:28:54 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:29:28 <chpatrick> LeanderK: flatMap is more like >>= from Monad
15:29:33 <nuberino> hi guys, I'm testing wxHaskell on windows. I ran `cabal run` in my app root fine (it said running) but no window showed up, and the shell seemed to insta-terminate the process
15:29:39 <LeanderK> ah, thanks!
15:29:46 <nuberino> also, when i run wxAsteroids, nothing happens
15:30:07 <chpatrick> LeanderK: are you just using x in the wrong order?
15:30:42 <chpatrick> should be upLeft (area x) right?
15:31:06 <chpatrick> foldMap is like concatMap for lists though yeah
15:31:38 <joehillen> I think he just wants concatMap
15:31:54 <chpatrick> foldMap isn't wrong though
15:33:02 <LeanderK> my mind is still very object oriented...and records look like classes :D 
15:33:13 <pilne> how "intrusive" is the gc in haskell for soft and hard realtime applications?
15:33:36 <chpatrick> pilne: pretty bad afaik
15:33:47 <chpatrick> it's not parallelizable either
15:34:01 <chpatrick> even if you have pools of unrelated things
15:34:07 <chpatrick> so if you have a big server the whole process stops
15:34:12 <pilne> hrm
15:34:56 <chpatrick> LeanderK: the record fields have plain old functions to access them
15:35:05 <chpatrick> area :: Window -> Rectangle
15:36:37 <cjay> pilne: I once read that in can be tuned to have max 1ms pauses for major collections. so for some â€žvery softâ€œ realtime it might be ok.
15:36:45 <cjay> no idea if that's accurate though
15:37:50 <pilne> ty for the inputs, i was quite inspired recently by John Carmak's talk at quakecon 2013, he seemed to think quite highly of haskell, i'm now wondering if he ran into issues with the gc when dabbling with it
15:39:22 <dolio> There's no reason you couldn't write a GC that worked fine for real time stuff, but GHC is not optimized for that.
15:39:32 <cjay> pilne: was he talking about the engine, or game programming in general?
15:39:55 <jle`> i think he  ways talking about the idea with functional programming
15:40:00 <jle`> s.of/with
15:40:11 <pilne> in general, he mentioned that he ported most if not all of wolfenstein to haskell, but, wolfenstine isn't quite as demanding as a decent modern day game.
15:40:17 <pilne> and i think so too jle
15:40:21 <dolio> And most garbage collectors aren't optimized for it, either.
15:41:03 <cjay> dolio: do you know any GC that is realtime capable? 
15:41:10 <arahael> pilne: I think a classic way to allow GC for hard realtime systems is to temporarily disable it at critical points, or to have a very specialised GC that possibly operates in a separate thread instead.
15:41:25 <arahael> cjay: There's _extensive_ research if you look for papers.
15:41:39 <dolio> cjay: Yes, but I'm not sure I can remember the names involved.
15:41:41 <arahael> cjay: Many for Java, curiously enough.
15:41:43 <Denommus> it also depends on what kind of realtime you're talking about
15:41:46 <pilne> he was mentioning that if you "do it right" the things that actually need to be gc'd can be kept to a minimum
15:42:35 <arahael> I'd be more worried about space leaks and unintentional laziness.
15:42:39 <dolio> cjay: Look at Azul Systems, I think.
15:42:48 <pilne> some googling mentions the ST monad (i'm not quite... there yet in haskell) can make memory operations "pretty explicit"
15:42:49 <cjay> arahael: yeah I've heard of the research, but I wonder if there is something useable
15:43:16 <cjay> hmm
15:43:31 <dolio> cjay: I think they sell JVMs that require extremely low latency.
15:43:39 <cjay> interesting
15:43:40 <dolio> Or, for applications that ....
15:44:04 <arahael> Still, "gc" for *hard realtime* systems is difficult.
15:44:13 <arahael> Hard realtime systems often can't use malloc functions either.
15:44:34 <arahael> dolio: "extremely low latency" is soft-realtime.
15:45:10 <arahael> "this function completes in exactly 17 clock cycles" is hard-realtime.
15:45:46 <pilne> where would a game engine like idTech 4-6 fall in terms of hard or soft realtime for proper/optimal performance?
15:46:04 <dolio> Game engines are not hard real time.
15:46:45 <arahael> pilne: I'd be surprised if they're even soft realtime.  A better description of game engines are usuallly what I might say: "marketing-realtime".
15:47:06 <arahael> Ie, they must not have a *perceptual* pause, though it's not an emergency if one occurs.
15:47:14 <pilne> fair enough
15:47:30 <cjay> in games, low jitter is equally important as low latency
15:47:42 <dolio> You could probably say that about lots of soft real time applications.
15:47:59 <icen> And it depends on your game; an fps is going to be tougher on the jitter than a strategy game
15:48:08 <cjay> true
15:48:22 <arahael> Even so, fps jitter isn't such a big deal once your frame rate is high enough.
15:48:25 <monochrom> so it seems to me that statements about soft real-time tend to be irrefutable
15:48:33 <pilne> i've just yet to find a language that i've taken to so easily (working through the haskell book) as haskell, and I'd like to (try) to stick with it for anything. I have no near-term plans to dethrone idTech engines, they are just a source of inspiration
15:49:05 <arahael> pilne: Which is "the haskell book"?
15:49:21 <pilne> http://haskellbook.com/
15:49:31 <arahael> Cool. :)
15:49:33 <icen> One of my favourite things about haskell is how it has been exported to other languages
15:50:28 <dolio> I'm not sure that Azul Systems' stuff isn't suitable for hard real time, either.
15:50:59 <arahael> pilne: Other languages without lazy evaluation or the like may be better for hard-realtime systems.  But I don't see why even a common GC would prevent it from being used by game engines.
15:51:16 <dolio> Since their 'low latency' stuff, as I've heard it, is things like, 'over a time span of n milli/microseconds, k% of that time is spent in garbage collection.'
15:51:24 <pilne> maybe i should go tell my c/c++ friends to go choke on a textbook then (:
15:51:25 <arahael> pilne: Especially if you decouple the game components so that they don't cause the FPS to be impacted.
15:52:17 <dolio> So if your source of concern is just the garbage collector (which it probably isn't, really), you could probably arrange for your hard limits to be satisfied given those guarantees.
15:52:19 <arahael> pilne: C++ is more difficult to use in hard-realtime systems, as you basically have to ban the STL and reimplement operator new and delete, if you're lucky.
15:52:42 <arahael> Possibly ban exceptions, too.
15:52:44 <pilne> yeah, i think they also got me a bit confused on hard/soft realtime as well
15:53:03 <pilne> they are strong with the cult kool-aide
15:53:07 <arahael> pilne: And C++ doesn't even *have* GC! (Though it's possible to add it)
15:53:29 <pilne> that's why they say it is always going to be superior to a language like haskell, the manual memory management
15:53:44 <kadoban> Hard realtime is pretty esoteric stuff, almost no standard tools are all that useful in that niche.
15:53:46 <arahael> pilne: C++ doesnt' require manual memory management.  Though it allows it.
15:54:22 <arahael> pilne: You're supposed to lean on automatic resource management with modern C++.
15:55:24 <pilne> yes, my brain kinda leaned towards the fact that since we're moving towards multi-core/concurrent/etc. that those technologies could be leveraged to make gc "less" of a problem for game programming
15:55:38 <arahael> pilne: Oh, definitely.
15:55:43 <pilne> i can see how it was... bad back in the one-core hundred-mhz days
15:56:27 <arahael> pilne: Some GC's work with that design, actually - they use a core for the sweep, then stop-the-world for a defined period while they mutate everything, up to a maximum time delay.
15:56:51 <eikke> edwardk: in rounded's Setup.hs you use some hack to add object files into generated object archives. Did you ever manage to do that somewhat cleaner (in some other project or so)?
15:57:25 <arahael> pilne: But hard-realtime in the classic definition is becoming increasonly difficult.  As you have variation from cache hits/misses, branch prediction, and so on.
15:59:33 <pilne> man
15:59:35 <pilne> you guys are awesome
15:59:53 <pilne> thank you for an intelligent answer about a question that has been buggin me
15:59:58 <pilne> (and gals)
16:00:34 <dolio> What do you even do these days? Assume that every operation has worst case performance?
16:01:10 <dolio> So, assume caches don't exist and whatnot?
16:01:26 <cjay> test and hope :/
16:01:54 <dolio> I would think that that wouldn't be a great idea in many hard real time applications.
16:01:57 <kadoban> The only people I ever worked with doing hard realtime â€¦ didn't even use consumer hardware. I don't know if that's changed.
16:02:15 <dolio> Yeah, I guess that's the other option.
16:03:12 <dolio> I guess it's even worse than caches.
16:03:34 <dolio> Some really new stuff has out-of-band hardware that can interrupt the OS and whatnot.
16:03:42 <dolio> Without it even being aware.
16:04:09 <arahael> dolio: I'd imagine that if you genuinly have a critical, hard-realtime requirement, you'd use a specialised CPU for that.  Even if it's just an 8086.
16:04:55 <arahael> kadoban: Yeah, the hard-realtime systems I've worked on were custom hardware.
16:05:09 <arahael> But it's not expensive to make such hardware.
16:06:16 <pilne> and with how freakishly awesome haskell is at parsing things, it would be rather trivial to create a scripting language for a game engine instead of relying on bringing in python or lua (like my c/c++ friends use in those situations)
16:06:38 <kadoban> arahael: Ya, it seemed like everything top-to-bottom was totally custom for hard realtime. So I suspect "haskell doesn't do hard realtime" is kind of a bizarre talking point and not much else, because /nothing/ does hard realtime, unless you use tools specifically for that.
16:06:57 <arahael> kadoban: Indeed.
16:07:15 <lamefun> How bad String really is?
16:07:20 <arahael> kadoban: *especially* if 'completing too soon' is just as bad as 'completing too late'.
16:07:20 <dolio> You could, but you probably don't want to be in the business of writing your own programming language.
16:07:21 <exio4> pilne: the bonus of using a known scripting language is that you get a lot of documentation and tutorials "for free" 
16:07:37 <kadoban> arahael: Ugh, yeah :-/
16:07:43 <Majiir> Is it possible to give the GC a hint to run a collection? Would that help in e.g. a game engine?
16:07:51 <lamefun> Are Strings stored as arrays internally, or a s linked lists?
16:07:53 <pilne> yes, but (i haven't looked much) i'm not sure how well haskell natively interacts with (preferably for me) python (or lua)
16:07:55 <arahael> pilne: Also, my scripts written in bash are *faster* than the same scripts written in haskell #!/usr/bin/env runghc
16:07:58 <exio4> lamefun: linked lists 
16:08:08 <Majiir> (i.e. hint a GC after every 100 framerenders)
16:08:13 <kadoban> lamefun: Pretty bad for performance, if you're processing a ton of data. They're linked lists.
16:08:18 <exio4> arahael: because of the compiler ovehead? :P 
16:08:21 <pilne> well, i'm not sure how well bash could be used as a game scripting language
16:08:25 <arahael> exio4: Indeed. ;)
16:08:39 <mcbees> Not well I would think
16:09:07 <mcbees> I would be interested in seeing the result
16:09:11 <arahael> As slow as parsing a string is, parsing just a dozen strings is faster than, eg, compiling pascal code, because you can *execute* that first line while parsing the second.
16:09:27 <kadoban> lamefun: When I was doing programming cometition type problems, I had to start using Text at least instead of String, or for some of them it was just impossible to even match the time limits.
16:11:16 <lamefun> No special-case optimizations for [Char],
16:11:23 <lamefun> (in GHC)?
16:11:57 <cjay> lamefun: you can use Text and overloaded Strings
16:12:39 <arahael> lamefun: How would you optimise [Char]?
16:13:38 <mniip> there's unboxed strings
16:13:45 <mniip> but you don't want to go there
16:16:54 <lamefun> arahael, somehow? Microsoft, Mozilla and Apple manage to optimize even JavaScript somehow after all.
16:17:24 <arahael> lamefun: Strings there aren't a linked list of utf-32 codepoints.
16:17:49 <hpc> arahael: they aren't utf-32 in haskell either
16:17:59 <hpc> (necessarily)
16:18:09 <lamefun> But data structures are string -> * maps.
16:18:13 <arahael> The key point, is that they're a linked list.
16:18:57 <arahael> lamefun: So, how would javascript express "e:(unevaluated_thunk)"?
16:19:17 <arahael> lamefun: Would it evaluate the entire string even though only the first character is ever evaluated?
16:19:30 <arahael> Is ever *needed*, that is.
16:20:07 <mniip> > take 3 $ show (1, undefined)
16:20:09 <lambdabot>  "(1,"
16:24:44 <arahael> Exactly.
16:30:03 <dgpratt> the ghc dynamic flag is used for...dynamic linking?
16:34:10 <lamefun> So it's beyond the capabilities of even Microsoft and Apple to optimize Haskell [Char]?
16:34:35 <mniip> lamefun, what you're looking for is called Text
16:36:54 <varaindemian> h g f = (f . g) $ f
16:36:55 <varaindemian> fix = h fix
16:37:03 <varaindemian> is fix a higher order function?
16:37:16 <varaindemian> polymorphic, overloaded and recursive?
16:42:20 <lyxia> it's not overloaded, is it?
16:49:14 <lpaste> varaindemian pasted â€œNo titleâ€ at http://lpaste.net/146835
16:49:51 <varaindemian> http://lpaste.net/146835
16:52:56 <varaindemian> Well the answer is overloaded and polymorphic, but hwy?
16:57:40 <broma0> Can someone help me out with a question I have regarding conduits?
16:58:35 <chpatrick> broma0: shoot
17:01:54 <broma0> chpatrick. I have a (Source Bytestring) and i need to write a (Conduit ByteString IO (Maybe Request)) where Request is some type i have an attoparsec parser for. Ideally, the conduit will parse the requests as the bytes come in,    yielding a Nothing when a parser fails. There should never be two Nothing's in a row (The conduit should skip over fai
17:01:55 <broma0> ling bytes)
17:02:09 <broma0> I hope that's clear enough :/
17:02:41 <broma0> give me a moment to formulate the punch-line question
17:02:56 <broma0> (I have most of it working )
17:06:17 <broma0> chpatrick: ive writteen the conduit like so: http://lpaste.net/146836, but i keep getting infinite loops!
17:06:42 <chpatrick> broma0: is it going to be something like conduitParser (Just <$> myParser <|> Nothing <$ word8)?
17:07:31 <chpatrick> would that work?
17:07:42 <broma0> chpatrick: you mean to tell me i dont have to do this all manually?! :D. I ttried using the conduit.attoparsec module but the conduit would close whenever i hit a Left ParseError while using conduitParserEither
17:08:16 <chpatrick> I guess because it fails
17:08:20 <chpatrick> and it stops consuming
17:08:33 <chpatrick> with the thing I posted it should eat a byte, return Nothing and try again
17:09:48 <broma0> you sir, are awesome! thank you. should i not be using conduitParserEither though?
17:10:03 <chpatrick> try it first, I don't know if it works :)
17:10:16 <broma0> wise. trying now
17:12:22 <chpatrick> should be anyWord8
17:14:36 <chpatrick> broma0: I think it works
17:18:01 <broma0> chpatrick: it's looking okay so far.. i need to to eat more bytes on fail though... the 'Nothing' case should skip until the next Just
17:18:17 <broma0> ill try 'some anyWord8'
17:18:28 <chpatrick> it will eat them though
17:18:38 <chpatrick> conduitParser will already try to match on the next byte
17:18:44 <chpatrick> you'll just get a lot of Nothins
17:19:02 <chpatrick> some anyWord8 will just eat your whole stream
17:19:07 <broma0> yup
17:19:10 <broma0> found that one out just now
17:20:39 <chpatrick> broma0: if you don't want the Nothings
17:20:41 <chpatrick> you could do
17:20:56 <chpatrick> ((:[]) <$> myParser <|> [] <$ anyWord8)
17:21:27 <chpatrick> and then $= CL.concatMap id
17:22:12 <lethjakman-l> I'm a bit confused. Isn't everything in haskell inherently memoized because of the purity?
17:22:20 <geekosaur> no
17:22:34 <lethjakman-l> But each function can only return the same results for the same input right?
17:22:39 <broma0> chpatrick, i want the nothings, so that my OTHER conduit can turn the Nothings into failure responses, and the Justs into success responses
17:22:39 <lethjakman-l> So it has to be cached?
17:22:42 <chpatrick> but it's not obvious when to do it
17:22:44 <lethjakman-l> Or is that a compile time thing?
17:22:45 <geekosaur> most computations don't need to be memoized at all, so why would you?
17:23:05 <chpatrick> broma0: but you only want one Nothing per failure right?
17:23:11 <geekosaur> now, if you arrange to share a computation (let/where is most common for this) then you get memoization
17:23:26 <broma0> chpatrick: yes, but the Nothing case should eat bytes until a \r\n
17:23:35 <broma0> i just need to change anyWord8 to manyTill or whatever it is
17:23:36 <geekosaur> one thing to consider is whether the memory cost of memoization is higher than the time cost of recomputation
17:23:40 <lethjakman-l> geekosaur: What do you mean "share a computation"?
17:23:58 <lethjakman-l> That makes perfect sense. 
17:24:04 <broma0> chpatrick: what do you think?
17:24:06 <lethjakman-l> That actually makes haskell make more sense to me. 
17:24:12 <geekosaur> if you give a computation a name with let or where, then it will be shared when possible
17:24:19 <lethjakman-l> But if you use the memoizable typeclass it's just auto memoized right?
17:24:20 <chpatrick> well if it works for what you're parsing then sure
17:24:30 <lethjakman-l> Makes sense. 
17:24:46 <broma0> it's a '\r\n' delimited stream of JSON objects
17:26:02 <lethjakman-l> geekosaur: Thank you for your help!
17:26:07 <lethjakman-l> That makes sense
17:26:13 <hydraz> Try
17:26:31 <hydraz> -.- wrong channel. Sowweh
17:26:52 <chpatrick> broma0: sorry I gotta go sleep
17:26:54 <chpatrick> good luck!
17:30:07 <broma0> chpatrick: thank you and good night!
17:34:17 <tommd> Is there a library that will expand shellisms (~, *, etc) in file paths in Haskell?
17:34:43 <tommd> I'd like to add a feature that will handle paths such as "~/cabal 1.*/*.config"
17:35:13 <mauke> will you allow $HOME too?
17:35:26 <tommd> mauke: I'd like to, yes.
17:35:33 <mauke> and $(foo)?
17:35:40 <tommd> mauke: Basically any normal *sh use.
17:35:49 <mauke> ... I think that's called a shell
17:35:52 <tommd> I'm not so keen on every variable, but the obvious ones.
17:36:03 <tommd> mauke: Yeah, I don't want to depend on shell in cryptol
17:36:21 <mauke> then you get to reimplement your own
17:36:37 <tommd> Yes, I just thought a package on Hackage might have already done exactly this.
17:36:56 <tommd> To support ~ means lots of platform specific cases I don't entirely appreciate also, so there's that.
17:37:32 <mauke> my platform has wordexp(3) and it's a huge can of worms
17:38:02 <mauke> shell expansions can run arbitrary commands, set environment variables, eat all your memory, etc
17:38:48 <tommd> Yes, hence the "I'm not so keen on every variable, but the obvious ones."  Basically, ~ / $HOME, and * expansion along with handling quoted/whitespace paths.
17:39:10 <tommd> Shouldn't be bad if I can figure out what home means on every platform.
17:39:53 <mniip> so not $() then
17:40:03 <tommd> Right.
17:40:18 <mniip> and probably not ${foo/a/b} or ${foo-bar}
17:40:21 <mniip> or whatever
17:40:32 <tommd> No, but if I want to support ~/ then I probably should support ~bob/
17:40:52 <mauke> and \ ' "
17:41:11 <tommd> The list grows, hence me looking to reuse.
17:45:59 <arahael> tommd: Define a custom shell expansion format, which happens to be a subset of posix sh.
17:47:21 <arahael> tommd: But I'd suggest deciding upfront if you support windows.
17:47:31 <arahael> tommd: UNC paths, long paths, etcetera.
17:49:21 <arahael> tommd: I'd probably additionally  ensure that the result is _not_ lazy, and define how hidden files are catered for.
17:52:03 <jcude>  
17:52:16 <jcude> can anyone help me 
17:52:50 <zoku> jcude: it depends on your issue
17:53:48 <jcude> im a noob i am trying to edit an html theme script and i think that there is some code in there that is reading code from a different web site 
17:53:56 <jcude> is that common?
17:54:33 <jcude> omg i didnt know haskell was a programming language 
17:54:35 <jcude> sorry 
17:58:06 <Enigmagic> :)
18:01:03 <broma0> anyone know if there's a way to limit the amount of bytes consumed in an attoparsec parser?
18:10:39 <kadoban> broma0: Not terribly sure what you mean.
18:11:11 <broma0> kadoban, are you familiar with the 'json' parser fomr attoparsec?
18:11:20 <broma0> aeson*
18:12:12 <kadoban> broma0: I'm passingly familiar with aeson. I wasn't aware it had anything to do with attoparsec
18:12:48 <kadoban> Oh apparently it uses attoparsec internally. Okay, sure.
18:12:55 <lamefun> kadoban, I think he means a function like atMostBytes :: ByteCount -> Parser a -> Parser a
18:13:30 <broma0> aeson uses attoparsec under the hood. im using the 'json' parser in the aeson library to repeatedly parse json objects out of a stream of bytes. i need to make the parser fail after trying to parse 25mb for a single object
18:13:49 <broma0> kadoban, see my goal here?
18:13:57 <kadoban> Yes, that makes sense.
18:14:01 <broma0> lamefun, nailed it.
18:14:07 <broma0> something like that exist?
18:16:46 <levi> You might be able to limit the amount using a library like pipes or conduit in front of the attoparsec parser.
18:16:57 <kadoban> Not sure personally. I think something in conduit? Not seeing it immediately, but I think it's here somewhere.
18:17:43 <broma0> im actually using conduit haha
18:17:49 <broma0> conduitParser to be exact
18:18:17 <broma0> ill take a look around as well. thank you for reminding me!
18:19:34 <realitychemist> Hey, anyone here have a moment to help a slightly confused beginner?
18:19:59 <broma0> realitychemist: yes
18:20:28 <broma0> realitychemist: im not even close to an expert.. i hope the questions arent THAT complex
18:20:53 <realitychemist> broma0: Thanks, and don't worry, this is the first project I'm doing in Haskell
18:21:57 <broma0> in that case, shoot away! btw, lpaste.net is a great place to post code snippets that you can link in this room. just dont paste all 9812312 lines of your code and ask us to debug
18:22:34 <realitychemist> Ahh, thanks for the suggestion, I'll do that
18:23:51 <realitychemist> So, I've got a function: http://lpaste.net/146842
18:24:18 <realitychemist> The intent is to generate a new random world at the start of play, but it doesn't compile
18:24:38 <realitychemist> GHC tells me: Could not deduce (RandomGen (IO StdGen)) arising from a use of `randomRs'
18:25:19 <realitychemist> But "Could not deduce" is an error I haven't seen before.  Can you help me understand that?
18:25:49 <kadoban> realitychemist: Have you gone through a book or haskell class or anything, or you're just starting with a project?
18:25:54 <petercommand> realitychemist: it means that IO StdGen is not an instance of RandomGen
18:26:32 <broma0> realitychemist: my network just exploaded. last message i saw was 'thanks, its my first project or something'
18:27:16 <petercommand> realitychemist: I think you want something like RandomGen StdGen
18:27:24 <levi> You wanted a StdGen from getStdGen, but instead you got an IO StdGen. This is a 'computation' that will produce a StdGen when run, but you can't use it directly as you have.
18:27:31 <realitychemist> kadoban: I've gone through about 1/3 to 1/2 each of LYAH and RWH, but I learn better if I've got something to work on
18:27:51 <emmanuel_erc> hey, can the on function (from Data.Function) be made to work nonmonomorphically?
18:28:03 <emmanuel_erc> I can provide an example if that sounds confusing?
18:28:14 <pavonia> Yes, please
18:28:40 <pavonia> :t on
18:28:41 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:28:54 <emmanuel_erc> ok, I am going to paste an example very shortly
18:30:16 <realitychemist> levi: Ok, I think I see what you're saying...  Is IO StdGen an action?
18:30:21 <levi> realitychemist: To resolve this, you could either make your function an IO action itself, or you can pass it a StdGen as a parameter or in its environment.
18:30:39 <kadoban> realitychemist: LYAH in particular is pretty poor in that it lacks exercises completely. RWH I like better but it still goes really fast. I'd recommend you do a different class or book that is more focused on you doing small exercises to actually prepare yourself for a project like this. http://haskellbook.com/ sounds nice, or https://github.com/bitemyapp/learnhaskell has some good advice (specifically cis194)
18:30:39 <lpaste> emmanuel_erc pasted â€œon (nonmonomorphic?)â€ at http://lpaste.net/146843
18:30:57 <broma0> any idea how one would write the function 'limitBytes :: Int -> Parser a -> Parser a' for attoparsec? trying to limit my parser to 25mb
18:31:36 <realitychemist> kadoban: I'll check out those resources, thanks!
18:32:57 <emmanuel_erc> sorry, I should have included this in my example. GP is Data.Graph.Inductive.PatriciaTree, S is Data.Vector.Storable and Vector is a constructor from Numeric.LinearAlgebra
18:33:48 <levi> realitychemist: Since the main function is an IO action, you can use 'getStdGen' in a 'do' block to extract the StdGen; e.g.: gen <- getStdGen
18:36:59 <orb> (Of course, main is not a function. ;)
18:41:09 <realitychemist> Ah ha!  Think I got it!
18:41:23 <levi> Cool. :)
18:41:59 <realitychemist> GHC accepts it at least.  Hopefully it works the way I expect
18:42:01 <realitychemist> Thanks for the help
18:42:30 <levi> No problem; good luck and have fun!
18:42:44 <emmanuel_erc> pavonia: Might I have to write my own "on" function?
18:43:32 <pavonia> emmanuel_erc: I'm sorry, I don't understand your example
18:43:42 <emmanuel_erc> ok
19:12:10 <broma0> is there an extension to allow overlapping record labels yet?
19:12:14 <broma0> im on 7.10
19:20:10 <geekosaur> not in 7.10
19:20:11 <bergey`> No, parts of that are coming with 8.0 https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
19:32:03 <pavolzetor> how would you memoize a list?
19:32:15 <pavolzetor> In C I would use something like a bitmask
19:32:40 <pavolzetor> I want to memoize value for each permutation of N values
19:33:06 <pavolzetor> I just don't know how that can be done in haskell
19:35:31 <pavolzetor> would you just simulate the bits and use list?
19:36:08 <pavolzetor> i.e. convert permutation to integer -> list offset?
19:38:33 <pavonia> pavolzetor: Not sure what you mean, do you have an example?
19:38:49 <pavolzetor> well, it is the advent of code problem (TSP)
19:39:06 <pavolzetor> and I want to have normal implementation using DP
19:39:11 <pavolzetor> (Held-Karp)
19:39:29 <pavolzetor> so you have a set of cities and you want to store distances for permutations
19:39:32 <pavonia> For today?
19:39:42 <pavolzetor> yes
19:40:13 <glguy> It's called advent-day-9
19:40:25 <pavolzetor> I have started DP, but got stuck on this memoization, so switched to brute-force and now I have bit of time to hack bit it
19:40:40 <pavolzetor> (and I did not want to use my beloved C ;) )
19:41:27 <pavolzetor> actually it is not TSP, but can be trivially reduced
19:43:08 <nitrix> Hi, where are Monoids located in regards to the Functors/Applicatives/Monad hierarchy?
19:43:49 <glguy> no
19:43:51 <kadoban> nitrix: They're not.
19:44:12 <nitrix> Oh. So it's just common that types share both monad and monoid instances?
19:44:35 <nitrix> Because I'm looking at the definition for monoid and it indeed has nothing like the other 3.
19:45:03 <nitrix> Maybe if I understood semigroups better :/
19:46:01 <pavolzetor> pavonia: any thoughts?
19:46:17 <pavonia> nitrix: Monad and Monoid don't have the same kind
19:46:39 <pavonia> pavolzetor: I have no idea what you are asking, sorry
19:47:02 <kadoban> nitrix: Monoid is a common typeclass and so are F/A/M, that's about the only connection as far as haskell goes, yeah.
19:47:18 <pavolzetor> pavonia: the idea is suppose you have a set {0,1,2,3,4,5,6} which are your cities
19:47:25 <pavolzetor> and you have some subset
19:47:28 <pavolzetor> 0,1,2,3
19:47:39 <pavolzetor> I want to memoize a value for that subset
19:47:44 <pavolzetor> so if it was binary
19:47:45 <nitrix> kadoban: I think I realised this earlier but just needed to reinforce the learning.
19:47:57 <kadoban> Yeah, that happens.
19:48:09 <pavolzetor> you would have 1111000 for the sequence
19:48:19 <pavolzetor> which you just use as an index to an array
19:48:21 <geekosaur> nitrix, you could say that Monoid and F/A/M are different mathematical generalizations. many types indeed can fit into both, but there is not necessarily a relationship at this level.
19:48:29 <pavolzetor> I want to know how I can do it in haskell
19:48:42 <pavolzetor> current idea is do something like
19:48:47 <geekosaur> (monoids *are* involved in the mathematical formalization fo monoids, but at a different level that is not visible in e.g. Haskell)
19:48:55 <geekosaur> er, of monads
19:49:26 <pavolzetor> [1,1,1,1,0,0] -> compute number (interpret list as bits) -> index to list (or use memoize from Data.Function.Memoize)
19:49:36 <pavolzetor> but this is very crude
19:49:56 <nitrix> pavolzetor: Nice that you're finally getting active on github.
19:50:01 <nitrix> :)
19:51:04 <pavolzetor> nitrix: Timo?
19:52:16 <pavolzetor> nitrix: most of my work is private
19:52:23 <nitrix> Oh.
19:52:27 <pavolzetor> nitrix: but I try to push the code out after publication
19:52:49 <pavolzetor> nitrix: i.e. https://github.com/pavolzetor/fiber_surface
19:52:50 <dmwit> nitrix: Monads are typed monoids.
19:52:55 <dmwit> uh
19:52:58 <dmwit> dmwit--
19:53:12 <dmwit> nitrix: Categories are typed monoids, and therefore this statement is completely unrelated to the question you actually asked. =P
19:53:36 <kadoban> dmwit: Was wondering how long that was going to take.
19:55:03 <dmwit> nitrix: On the other hand, through a convoluted series of entailments, this *does* mean that the laws (written without types) look suspiciously similar:
19:55:22 <dmwit> mempty <> x = x <> mempty = x vs. return >=> f = f >=> return = f
19:55:42 <dmwit> and x <> (y <> z) = (x <> y) <> z vs. f >=> (g >=> h) = (f >=> g) >=> h
19:56:04 <nitrix> Not there yet.
19:56:11 <nitrix> Almost though.
19:56:44 <dmwit> I can help you get there if you want.
19:56:52 <nitrix> A few more dedicated synapses to connect the dots and I'll be golden.
19:57:51 <dmwit> There are other fun relationships, too.
19:58:25 <pavolzetor> one thing, suppose I have an list, how can I fold it using different power of two for each element?
19:58:29 <dmwit> For example, you could write an `instance (Applicative f, Monoid m) => Monoid (f m)` if you ignored how Haskell's class resolution mechanisms worked.
19:58:31 <pavolzetor> let f xs = sum . zipWith (*) (iterate (*2) 1) $ xs
19:58:36 <pavolzetor> I have this currently
19:58:49 <dmwit> pavolzetor: That looks pretty good to me. What don't you like about it?
19:58:50 <pavolzetor> which I find ugly
19:59:11 <pavolzetor> it seems cluttered
19:59:16 <dmwit> :t foldr (\x y -> 2*x+y) 0
19:59:17 <lambdabot> (Num b, Foldable t) => t b -> b
19:59:24 <dmwit> > foldr (\x y -> 2*x+y) 0 [x,y,z]
19:59:26 <lambdabot>  2 * x + (2 * y + (2 * z + 0))
19:59:31 <KaneTW> [C192wait
19:59:38 <KaneTW> since when can lambdabot do that
19:59:46 <KaneTW> that's really cool
19:59:58 <pavolzetor> dmwit: it gives incorrect result
20:00:00 <dmwit> > foldr (\x y -> x+2*y) 0 [x,y,z]
20:00:02 <lambdabot>  x + 2 * (y + 2 * (z + 2 * 0))
20:00:04 <pavolzetor> is there some built in function?
20:00:08 <KaneTW> > foldr (:) [x,y,z]
20:00:10 <lambdabot>      No instance for (Typeable t0)
20:00:10 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
20:00:10 <lambdabot>        arising from a use of â€˜show_M270321685449374219421510â€™
20:00:18 <dmwit> > foldr (:) [] [x,y,z]
20:00:20 <lambdabot>  [x,y,z]
20:00:23 <KaneTW> oh right
20:00:31 <pavolzetor> oh I see, that second version works
20:00:51 <pavolzetor> neat ;)
20:00:53 <pavolzetor> thanks
20:01:38 <dmwit> There is no built-in function, and it's annoying that there isn't.
20:01:38 <pavolzetor> so this is same as doing a shift
20:01:56 <pavolzetor> finally use for foldr
20:01:59 <dmwit> I've wanted a variation on `readInt` that could handle other list types than `String` many times.
20:02:02 <dmwit> :t readInt
20:02:04 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
20:02:38 <dmwit> It could easily have been given a more polymorphic type.
20:03:20 <stephen_> For curiosity's sake, does anyone have thoughts on this? http://nostalgebraist.tumblr.com/post/132151512474/a-thing-that-i-was-intending-to-do-for-a-long-time
20:03:44 <stephen_> (it's seems really compelling)
20:03:50 <stephen_> *it
20:04:55 <dmwit> The obvious way to get "seamless" and "minute-by-minute" is to return to I at every minute boundary. But this would make for a kind of boring song.
20:05:52 <dmwit> But I guess it's easy to fix that: just pick a progression for the boundaries that's independent of the statistics.
20:06:04 <dmwit> I dunno. Could be kind of neat, and sounds like a fun project.
20:06:08 <dmwit> Did you have any specific questions about it?
20:06:48 <pavolzetor> dmwit: how do you use that readInt?
20:07:29 <dmwit> > readInt 3 (\x -> x `elem` "012") digitToInt "120201" :: Integer
20:07:31 <lambdabot>      Couldn't match expected type â€˜Integerâ€™
20:07:31 <lambdabot>                  with actual type â€˜[(Integer, String)]â€™
20:07:31 <lambdabot>      In the expression:
20:07:37 <dmwit> > readInt 3 (\x -> x `elem` "012") digitToInt "120201" :: [(Integer, String)]
20:07:39 <lambdabot>  [(424,"")]
20:07:50 <dmwit> :t showIntAtBase
20:07:51 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
20:08:04 <dmwit> > showIntAtBase 3 intToDigit 424 ""
20:08:06 <lambdabot>  "120201"
20:09:17 * hackagebot SDL-gfx 0.6.0.2 - Binding to libSDL_gfx  https://hackage.haskell.org/package/SDL-gfx-0.6.0.2 (fffaaa)
20:09:28 <pavolzetor> thanks, I forgot the base
20:09:30 <pavolzetor> btw, https://www.reddit.com/r/adventofcode/comments/3w352x/day_9_haskell_memoization_making_function_slower/
20:09:45 <Pamelloes> dmwit: The progression wouldn't even need to be independent of the statistics, it just needs to be able to get from a starting chord to an ending chordâ€”and then the program will calculate the chord at the start of each minute and the last minute.
20:12:05 <dmwit> Pamelloes: I think we're in violent agreement. You have to pick the progression *for the boundaries* independent of the statistics.
20:12:09 <pavonia> stephen_: I like the idea, though I would base that minute of music on a month or even a whole year, because I don't think you will hardly find any data series that would give you a lot of change within a minute back somewhen back in the Middle Ages
20:12:23 <dmwit> Pamelloes: Of course inside the boundaries you can use the stats to do whatever you want.
20:12:58 <stephen_> dmwit: not really, I just found it. Bringing it up here because it's a nice problems, and lazy evaluation of infinite streams fits nicely with the problem
20:13:02 <pavolzetor> he/she stores the first set, but that one mutates so it will recompute all the staff over with no memoization
20:13:32 <boj> is there a proper way to fold over (a -> Either b a) and properly handle the Left case?
20:13:33 <Pamelloes> dmwit: I'm saying you could even use the stats for the boundariesâ€”if your stats are consistent, then the boundary could be calculated deterministically taking the stats into consideration.
20:13:53 <dmwit> Ah, right. Sure!
20:14:00 <kadoban> boj: What do you mean?
20:14:17 * hackagebot SDL-ttf 0.6.2.2 - Binding to libSDL_ttf  https://hackage.haskell.org/package/SDL-ttf-0.6.2.2 (fffaaa)
20:14:18 <dmwit> :t either
20:14:20 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:14:24 <pavolzetor> I have to run, thanks for all help; I will have a shot at DP solution tomorrow evening, night
20:14:45 <boj> kadoban: i want to stop folding if the next step is a Left, otherwise keep folding and get the final Right back
20:15:43 <kadoban> boj: What does folding mean here?
20:16:17 <dmwit> :t \f init -> head [x | Left x <- iterate (>>= f) (return init)]
20:16:19 <lambdabot> (a1 -> Either a a1) -> a1 -> a
20:16:42 <stephen_> pavonia: In the middle ages?
20:16:44 <dmwit> :t unfoldr
20:16:46 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:16:55 <lamefun> Is there a generalization of fromJust to Either, etc.?
20:17:05 <dmwit> lamefun: Yes.
20:17:31 <lamefun> which one?
20:17:34 <ggVGc> For an interactive application, user actions could be modelled either as functions or as ADT's. when is which prefereable? I.e if I have an action playSong, it could either be playSong :: PlayerState->SongInfo->PLayerState, or a type constructor PlaySong(SingInfo) with a function executeAction :: PlayerState->Action->PLayerState
20:18:19 <pavonia> stephen_: "June 12, 1647 A.D., 3:44 PM to 3:45 PM" <-- Maybe that's already the Renaissance, but you get the idea :p
20:18:54 <dmwit> ggVGc: Functions are preferable when the only thing you will want to do is `executeAction`; however, you will often want at least one other function like `show` or similar for debugging, in which case the ADT is preferable.
20:19:14 <dmwit> ggVGc: Eliminating the ADT is known as deforestation, by the way.
20:19:19 <boj> kadoban: something like - foldl f a [a], where f :: a -> Either b a ?
20:19:24 <ggVGc> mkay
20:20:00 <ggVGc> to me an ADT seems more useful, but at the same time a partially applied function can act pretty much like an ADT instance in my view
20:20:05 <dmwit> ggVGc: The reason functions are preferable when you know how you want to consume them is that it allows you to skip the "produce a value of the ADT, then consume a value of the ADT" step, thus producing less garbage and generally also doing less work.
20:20:29 <ggVGc> yep I get that
20:20:33 <athan> glguy: Hey, I just realized the `.stack-work/logs` folder ._.
20:20:34 <dmwit> ggVGc: So often an ADT is a nice thing to have even when you only have one consumer, but performance is not a concern.
20:20:50 <stephen_> pavonia: ahh, right, the data series itself. I mean you're golden if you choose a natural phenomenon like the position of the moon
20:21:13 <dmwit> boj: You don't like my answer? =)
20:21:24 <boj> dmwit: you spurred some ideas, thanks
20:21:42 <ggVGc> dmwit: I also feel like the executeAction function might grow huge, and in the end will be split up into many smaller ones like executeSongPlay etc. and then you have practically have the playSong function anyway
20:21:48 <dmwit> boj: I'm not sure there's anything prebuilt/standard.
20:21:49 <ggVGc> except also with an ADT instance
20:22:17 <dmwit> ggVGc: It can be nice to have that separation of concerns.
20:23:40 <pavonia> stephen_: Yeah, but that's pretty regular data. It would be most interesting to have data that changes irregularly, like the population of a country or so (because of wars). But such data doesn't change much within a minute
20:24:14 <lamefun> dmwit, which function? I see I can do (foldr const (error "!!!") (Just 1)), but that's silly.
20:26:54 <stephen_> pavonia: you could base it on the superposition of a periodic natural signal (moon, planets, etc), and something more anthropological. If you stick to the middle east, you should have decent population statistics for a few millennia
20:26:54 <dmwit> lamefun: Did you try hoogling "Either a b -> a"?
20:28:02 <lamefun> Yes, but I meant something like: class FallibleResult r where sure :: r a -> a
20:29:47 <dmwit> I think wishing for `fromRight` is a mistake; for `FallibleResult`, a sin.
20:30:01 <dmwit> But the direct answer to your question is that I don't know of such a class.
20:34:58 <dmwit> :t \f -> fix (\g -> either id g . f)
20:34:59 <lambdabot> (b -> Either c b) -> b -> c
20:35:15 <dmwit> boj: That's perhaps a less terrible version.
20:36:11 <dmwit> (It doesn't use any partial functions or patterns.)
20:38:21 <dmwit> Oh, I know!
20:41:26 <dmwit> I can't figure out how to make `ArrowLoop` do what I want. =P
20:42:02 <boj> i suppose another way to go about what i want is change the function signature to (a -> Writer (Maybe a)) and tell what was once a Left?
20:42:44 <dmwit> How does that help?
20:43:13 <dmwit> ?unmtl Cont b a
20:43:13 <lambdabot> (a -> b) -> b
20:43:45 <boj> i can stop execution on Nothing, and read the "error"?
20:44:15 <dmwit> You can do that even with the original function signature.
20:44:27 <boj> using fold?
20:44:49 <dmwit> Either manual recursion, or with either of my two posted solutions.
20:44:59 <boj> i see.  ok
20:45:23 <boj> i think i was hung up on using a builtin function
20:45:53 <dmwit> :t callCC
20:45:55 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
20:48:14 <dmwit> ?unmtl EitherT e Cont a
20:48:15 <lambdabot> EitherT e Cont a
20:48:22 <dmwit> ?unmtl ErrorT e Cont a
20:48:23 <lambdabot> Plugin `unmtl' failed with: `Cont (Either e a)' is not applied to enough arguments, giving `/\A. (A -> Either e a) -> Either e a'
20:48:34 <dmwit> ?unmtl ErrorT e (Cont c) a
20:48:34 <lambdabot> (Either e a -> c) -> c
20:48:46 <dmwit> ?unmtl ContT c (Error e) a
20:48:46 <lambdabot> (a -> Error e c) -> Error e c
20:55:03 <dmwit> This is probably one call using the recursion-schemes package, if you can figure out which one call to make. =P
20:55:37 <boj> dmwit: much appreciated, you've got me on the right track
21:55:44 <zoku> What if I want to fork something that's not necessarily IO ?
21:56:00 <zoku> can I lift my StatefulIRC into IO ?
21:56:14 <jle`> zoku: can you show a concrete example?
21:57:03 <zoku> http://lpaste.net/4266487569723686912
21:57:28 <zoku> this errors like so: http://lpaste.net/4447358838810607616
21:58:55 <jle`> you can get an IO a from a ReaderT r IO a by giving it the r, and then liftIO-ingthe forked IO
21:59:01 <jle`> but there is a library that abstracts this nicely for you
22:00:16 <zoku> Ah yes, that's the type of StatefulIRC :]
22:00:19 <zoku> which library?
22:00:23 <jle`> the monad-control library offers the plumbing to be able to use ReaderT and friends with forkIO and stuff like that
22:00:39 <jle`> and the easiest way to use it is to use the "lifted" forkIO in http://hackage.haskell.org/package/lifted-base-0.2.3.6/docs/Control-Concurrent-Lifted.html
22:00:50 <jle`> i guess they call it `fork` there
22:00:53 <jle`> fittingly
22:01:25 <jle`> importing Control.Concurrent.Lifted instead of Control.Concurrent should do the trick
22:02:12 <jle`> the problem is that `ReaderT r IO a` isn't IO, so it can't be used with forkIO...but "io-forking" a ReaderT r IO a makes perfect sense.  monad-control defines a typeclass that abstracts away the manual unwrapping/wrapping for you
22:02:32 <jle`> and lifted-base gives base IO functions in a way that takes advantage of this :)
22:06:11 <zoku> that gives me this
22:06:12 <zoku> http://lpaste.net/4447358838810607616
22:07:26 <jle`> can you post the modified code?
22:08:06 <zoku> http://lpaste.net/4266487569723686912
22:08:36 <Cale> It seems a little bit frivolous and silly to me that this library is using ReaderT instead of just plain IO
22:08:45 <jle`> oh
22:08:49 <jle`> yeah, you're not doing anything in ReaderT...
22:08:53 <jle`> why is there even ReaderT...
22:09:07 <jle`> i had thought that you wanted to fork a ReaderT in the middle of a ReaderT do block
22:09:09 <zoku> that's part of the irc-client library
22:09:21 <jle`> but really it's just in the middle of an IO do block
22:09:25 <Cale> But also, why are your type signatures commented out?
22:09:40 <jle`> zoku: you can use runReaderT :: ReaderT r IO a -> r -> IO a
22:09:51 <Cale> Removing type signatures will generally make your type errors harder to understand
22:09:51 <jle`> so get an `IO a` from your ReaderT r IO a, by providing an r
22:09:55 <jle`> and then forkIO that
22:10:10 <Cale> (and dually, putting more top level type signatures in will help the compiler produce better error messages for you)
22:10:30 <zoku> because I was having issues Cale :X
22:10:40 <zoku> and to be quite honest i dunno what i am doing
22:10:51 <jle`> you have an issue, and you removed type signatures.  now, you have two issues ;_
22:10:54 <jle`> ;)
22:10:56 <zoku> hehe
22:11:06 <Cale> zoku: I think sendIRC :: String -> IRC ()
22:11:10 <Cale> not IO
22:11:15 <jle`> but yeah, if you're in the middle of an IO do block, you can just use the normal `forkIO`
22:11:17 <Cale> because it's using sendBS
22:11:36 <jle`> but you need to get an IO out of your ReaderT r IO a.  which you can do by giving it an r -- runReaderT :: ReaderT r IO a -> r -> IO a
22:11:56 <jle`> monad-control is for when you want to fork a ReaderT in the middle of a ReaderT do block
22:11:58 <Cale> But also, main :: IO ()
22:12:06 <Cale> so yeah, you just use forkIO there
22:12:08 <Cale> not fork
22:12:51 <Cale> handleSource :: ... -> IRC ()
22:13:10 <Cale> ah, must be  IRC (Maybe String) -> IRC ()
22:14:43 <zoku> this is where I get totally lost in haskell
22:15:01 <zoku> i feel like I kinda understand the types, until the monad transformations
22:15:34 <Cale> zoku: Yeah, it would even be better if they'd hidden the fact that they used ReaderT from you
22:15:43 <Cale> and just had things of type IRC t
22:16:26 <Cale> But honestly, they really don't get a whole lot of mileage out of ReaderT, and it's a major inconvenience just to save passing around an extra parameter here and there
22:16:31 <jle`> zoku: you can kind of don't worry about the monad transformers, knowing how they work isn't too insightful 
22:16:41 <jle`> zoku: what you really wanted was a way to turn StatefuIRC -> IO ()
22:16:44 <jle`> so you can use it with forkIO
22:16:49 <jle`> and the library would have given you such a function
22:17:14 <Cale> Maybe I should quickly refactor this library to not use the monad transformers :P
22:17:21 <zoku> right, fork didn't work though
22:18:24 <Cale> Yeah, fork is for if you wanted to run a StatefulIRC action as a new thread inside a StatefulIRC action.
22:18:35 <zoku> ah
22:20:07 <Cale> But honestly, don't even touch MonadBaseControl
22:20:37 <Cale> It's largely a convoluted solution to problems caused by stubbornly using monad transformers when one shouldn't.
22:21:00 <zoku> I think i'm too hungry for all this
22:21:01 <zoku> >_<
22:21:23 <Cale> It's also definitely not the right solution to any beginner problem
22:21:40 <zoku> yea, this is my first real attempt at writing something :X
22:21:46 <Cale> Probably all you want to do is runReaderT
22:21:54 <Cale> and supply the environment
22:22:09 <Cale> let me just look at this IRC library you're using
22:22:10 <zoku> runReaderT (handleSource (recvMUD mudcon)) ?
22:24:57 <Cale> Oh I see
22:25:16 <Cale> You're actually never meant to run StatefulIRC s actions directly by the looks of it
22:25:26 <Cale> You set them as event handlers in the InstanceConfig
22:25:38 <Cale> and 'start' runs them for you
22:27:38 <zoku> since I'm trying to bind this to another socket, I want it to update without triggers from any handler
22:28:23 <zoku> is that not possible given this setup?
22:28:40 <Cale> Could you explain that a little more?
22:29:38 <zoku> I'm reading from another socket and piping it into irc
22:29:51 <zoku> So I want to trigger that anytime there's new data on that socket
22:30:02 <zoku> rather than waiting for IRC events to trigger a read of that socket
22:31:08 <Cale> okay, let me have a look
22:43:56 <Cale> zoku: Actually I'm uncertain of how you're expected to even use this library to write an ordinary interactive IRC client for a user to use.
22:44:19 <zoku> haha, ok
22:44:20 <zoku> thanks
22:44:31 <zoku> I'm glad to know it isn't just me who is confused by this library
22:44:34 <Cale> zoku: Unless that's what ENothing is for
22:45:08 <Cale> But no, I think ENothing means what it sounds like -- it'll never occur
22:45:27 <zoku> the way I have it seems to work
22:45:32 <zoku> for accepting messages from uesrs
22:47:06 <Cale> oh
22:47:09 <Cale> hey, maybe I know
22:47:31 <Cale> So, inside the ConnectionConfig that you get from connect/connectWithTLS
22:47:34 <Cale> there is a field
22:47:40 <Cale> _sendqueue :: TBMChan IrcMessage
22:48:22 <Cale> You can write to that channel using  atomically (writeTBMChan (_sendqueue conn) msg)
22:48:31 <Cale> :: IO ()
22:49:35 <Cale> So what you probably want to do is after initialising your IRC connection, pass the function  (\msg -> atomically (writeTBMChan (_sendqueue conn) msg))  along to an IO action constructing function which you forkIO to read from your other socket
22:50:20 <iwmrby> Hey guys, noob here trying to learn monads at school. Unfortunately, the teacher isn't here so I need some help.
22:51:14 <Cale> zoku: i.e. something along the lines of  forkIO $ handleSocketMessages (\msg -> atomically (writeTBMChan (_sendqueue conn) msg))
22:51:20 <Cale> zoku: and then you write
22:53:21 <Cale> handleSocketMessages write = forever $ do incoming <- getSomethingFromYourSocket; let { msg = Privmsg ... }; write msg
22:53:26 <Cale> something like that
22:53:56 <Cale> iwmrby: Feel free to ask any questions you might have
22:54:02 <iwmrby> If any of you has the time and the will to help, we are working on this .pdf https://www.dropbox.com/s/qztb4aixko0th03/lab8.pdf?dl=1 and we're trying to understand the definition of bind which in the source code we were provided is bind :: (a -> Audit b) -> (Audit a -> Audit b), having type Audit a = (a, String).
22:54:59 <Cale> tsk, of course they would have the arguments backward :)
22:55:09 <Cale> (Not that it really matters)
22:55:16 <iwmrby> Now, I absolutely fail to understand even the definition of bind. As in I get that 'a' is a type and a -> Audit b means that we are applying a function and Audit b is the result of f applied to a and the debug string.
22:55:32 <Cale> Okay, let's unfold the types
22:55:41 <Cale> Well, before that
22:57:02 <iwmrby> Bear in mind, we never worked with functions that had other functions as arguments. We did do map and fold and stuff, but only applied to numbers and now we've been thrown into the deep and and we're sinking.
22:57:11 <Cale> The idea is that we're thinking of a value of type Audit t as being something which performs a bit of computation in order to produce a result of type t, and along the way, it's going to produce a String as well.
22:57:36 <Cale> i.e. even though it's really just a pair of a value of type t, and a String
22:58:03 <iwmrby> oh, so the function is part of Audit, kind of.
22:58:41 <Cale> So, let me first swap the arguments to bind around, because they're in the opposite order from how I want to explain them
22:58:46 <iwmrby> but Audit it `a` and `String`.  
22:58:49 <iwmrby> Oh, ok.
22:59:07 <iwmrby> First of all, thanks a lot for your patience and help
22:59:33 <Cale> So, we get an Audit a, which is like a program which when we run it is going to produce a result of type a (along with a String) and a function (a -> Audit b), which is something that will accept the result of our first program
22:59:40 <Cale> and produce another program for us to run afterward
23:00:23 <Cale> and we want to combine these into a program of type Audit b, which does the obvious suggested thing, of running the first program and then applying the function to determine what to do next, and then running the second program
23:00:40 <Cale> Along the way, we will produce a couple of extra Strings which I suppose we're to think of as a "log"
23:01:01 <Cale> and we will have the resulting program produce the concatenation of these logs
23:01:06 <iwmrby> yep it's some kind of log
23:01:42 <Cale> Now, okay, we'll go back to the bind that you're trying to write
23:01:44 <Cale> So we have
23:02:10 <Cale> bind f (result, log1) = ...
23:02:21 <Cale> Here,  f :: a -> Audit b
23:02:25 <Cale> result :: a
23:02:29 <Cale> and log1 :: String
23:02:43 <iwmrby> ok...
23:02:48 <Cale> There's no work at all involved in actually "running" the computations in this monad, because they are just pairs
23:03:15 <Cale> But in general for other monads, we might not just pattern match, but instead, do something more interesting to execute the first computation
23:03:46 <asampal> anyone around who can give me a few details about stack with existing msys2, on Windows?
23:03:52 <Cale> Actually, let's use 'let'... we don't have to, but I think you may thank me later :)
23:04:21 <Cale> bind f x = let (result, log1) = x; ...
23:04:22 * hackagebot friday-juicypixels 0.1.1 - Converts between the Friday and JuicyPixels image types  https://hackage.haskell.org/package/friday-juicypixels-0.1.1 (ThomasDuBuisson)
23:04:58 <Cale> So, again, in this case, we're not doing anything extra to 'run' x, but in many other cases we would
23:05:16 <Cale> and now, we want to "run"  f result
23:05:43 <Cale> bind f x = let (result, log1) = x; (result2, log2) = f result ...
23:05:54 <Cale> f result :: Audit b
23:06:02 <Cale> So, result2 :: b
23:06:06 <Cale> and log2 :: String
23:06:28 <Cale> and now we want to produce a result of type b (which we already have, it's just result2)
23:06:31 <Cale> and a combined log
23:06:38 <Cale> which we'll produce by concatenating
23:06:50 <Cale> bind f x = let (result, log1) = x; (result2, log2) = f result in (result2, log1 ++ log2)
23:07:24 <Cale> Does that make sense?
23:07:41 <Cale> There's a much less highbrow way of understanding this program
23:07:52 <Cale> It's really just manipulating some pairs
23:07:56 <Cale> and strings
23:08:32 <iwmrby> give me a minute to process this...
23:09:02 <Cale> But in general, there will be this pattern with bind:  bind f x  will produce the "computation which first runs x, then applies f to its result, and runs the computation which f produces, giving its result as the result of the combined computation"
23:09:23 <Cale> In other contexts in Haskell, that'd be written x >>= f
23:10:05 <Cale> What "then" means, and what a "computation" is, will depend on the actual monad in question
23:10:29 <Cale> But there are a lot of things which are vaguely like this across many of the libraries we write, so we've decided to give a name to this pattern
23:10:47 <Cale> As you see more of the libraries, the pattern will become more familiar
23:13:48 <iwmrby> Ok, let's take this step by step.  bind f x = let (result, log1) = x; <- in this f is the function and x is the argument of the function as in f(x). And by doing bind of f and x we're returning a pair of result and log?
23:14:48 <iwmrby> or is x is function?
23:21:35 <iwmrby> Hold on. I think I got it. In let (result, log1) = x, the pair (result, log1) is the result of "running" x with whatever arguments x has.
23:23:34 <iwmrby> Yes. And bind now does what it should. As in it runs the second function as in runs x, caches the result, runs f result and caches that result. It then returns the final result and the full log.
23:30:59 <Cale> iwmrby: yep :)
23:31:38 <Cale> iwmrby: well, the 'caching' part isn't really part of it
23:32:08 <iwmrby> Well, now it seems so simple :))
23:32:24 <Cale> iwmrby: When we say (result, log1) = x, we're giving names to the parts of the value that x evaluates to, but the compiler is free not to store them separately or anything
23:32:45 <Cale> But yeah
23:33:05 <iwmrby> Cale: Thanks a lot! You just helped a class of 11 people finally understand.
23:33:18 <Cale> In another setting, x might be a Parser a, which eats some initial part of an input string and results in a parsed value of type a
23:33:53 <Cale> and f might be a function (a -> Parser b) which takes some value of type a, the result of the first parser, and decides which parser to run next on the remainder of the input
23:33:58 <nilg> > let mm = (fromList [(1, 2), (1, 3), (2, 4), (3, 10)] ) :: MultiMap Integer Integer 
23:33:59 <lambdabot>  <no location info>:
23:33:59 <lambdabot>      not an expression: â€˜let mm = (fromList [(1, 2), (1, 3), (2, 4), (3, 10)]...
23:34:17 <nilg> sorry, I'm trying the interpreter...
23:34:23 <nilg> let mm = (fromList [(1, 2), (1, 3), (2, 4), (3, 10)] ) :: MultiMap Integer Integer 
23:35:05 <Cale> iwmrby: and this might even be nondeterministic with backtracking, so the first parser might produce many possible parses and corresponding values of type a, and then the following parsers which run might succeed or might fail, and we'd collect up all the ways of succeeding
23:35:50 <Cale> iwmrby: That's maybe a little too quick a description :)
23:36:01 <Cale> iwmrby: But I just want to give some idea of where this pattern can go
23:37:22 <nilg> Honestly, MultiMap mapKeys is erasing elements!!! WTF!!! This is a MultiMap, not a Map it can do better! http://lpaste.net/146852
23:38:36 <asampal> so no Windows users that could answer a couple of Stack questions?
23:38:57 <kadoban> asampal: Asking to ask is a waste of time.
23:39:05 <Ephemerality> hmm someone should update this page https://wiki.haskell.org/IRC_channel "Up to 1046 concurrent users"
23:39:32 <mgsloan> asampal: I'm a non-windows user who could potentially answer a stack question or two
23:40:40 <asampal> k, then: I'm wondering if I set up stack using "stack --skip-msys setup" should there still be a mingw installed under the ghc install dir?
23:40:47 <Cale> Ephemerality: hah
23:40:56 <Cale> Ephemerality: I think there are some newer stats somewhere...
23:41:23 <asampal> I've got an already installed msys2/mingw on my system
23:41:44 <asampal> and I'd like to not have redundant files around
23:41:58 <echo-area> How many users are now?
23:43:28 <mgsloan> asampal: Yes, that's correct.  Here's where it skips installing msys if that flag is provided: https://github.com/commercialhaskell/stack/blob/d0abf6ca1552e79836597679153b89b81c629866/src/Stack/Setup.hs#L383
23:44:23 <asampal> mgsloan: sorry, when you say that's correct you mean it should still install a mingw directory under the ghc one?
23:44:31 <varaindemian> The parser char 'a' +++ return 'b' always succeeds with the result value 'a'?
23:45:05 <asampal> I ran without that flag and what resulted is an msys/mingw folder in parallel with the ghc directory
23:45:13 <mgsloan> asampal: It shouldn't install one, but if there's already one there, it'll leave it there
23:45:33 <asampal> with the flag, that one wasn't installed, but I still see mingw under the ghc directory
23:45:53 <nilg> I cannot believe my eye, MultiMap mapKeys is buggy!!! the size of the obtained MultiMap is inconsistent
23:46:14 <asampal> seems like there are two mingw installations that can result from doing a stack setup
23:46:35 <nilg> mapKeys should be fixed to append the lists corresponding to the resulting identical keys
23:46:38 <asampal> is one tied to ghc because of wanting to pin a specific version of the tools to ghc?
23:46:56 <nilg> where should I go to report a bug?
23:48:13 <nilg> I guess I should send an email to the maintainer of MultiMap, any better way?
23:48:22 <varaindemian> anyone?
23:50:04 <mgsloan> asampal: Likely so, I'd certainly recommend using the installed msys
23:50:09 <bartavelle> varaindemian, not at all
23:50:12 <mauke`0> nilg: probably not. I don't see a bug tracker at the source repo
23:50:15 <mgsloan> Otherwise you'll always be asking "hmm, maybe it's my custom msys'
23:50:31 <bartavelle> varaindemian, why would "char 'a'" always succeed ?
23:50:47 <asampal> looking at recent closed issues, it seems that one should be able to use an already installed msys2
23:51:27 <asampal> in any case, msys2 wasn't installed again, but only the mingw tools (under ghc)
23:52:09 <asampal> and doing some basic stuff (I'm a total noob) on the command-line, with stack, seems to work OK
23:52:52 <asampal> but I do get a message about msys2 missing: "Continuing despite missing tool: msys2"
23:52:54 <Hijiri> nilg: what happens, does it just choose one of the lists?
23:53:14 <bartavelle> varaindemian, also you should make it clear where your question is from, I suspect not many people here understand that +++ is FP101x version of <|>
23:53:30 <bartavelle> or perhaps that's how this operator was called previously ...
23:55:53 <MasseR> bartavelle: seriously?
23:57:56 <geekosaur> (+++) is <|> for ReadP, the minimalist Haskell98 parser
23:58:26 <boj> dmwit: i figured out how to do what i wanted. foldl (>>=) (a :: Either b a) [a -> Either b a]
23:58:45 <geekosaur> and as I understand it, it produces all possible results, so it should in some sense be producing *both*
23:59:26 <bartavelle> geekosaur, I stand corrected ! That's what I get from just skimming though things :/
23:59:40 <geekosaur> "A parser for a type @a@, represented as a function that takes a 'String' and returns a list of possible parses as @(a,'String')@ pairs."
