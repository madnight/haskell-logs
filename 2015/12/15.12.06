01:33:44 <concept3d> Hello, I was wondering about the uses of (->) data constructor
01:33:56 <concept3d> I know it's a functor
01:34:21 <concept3d> and a monad etc. but I can't figure out a valid use for it
01:35:06 <concept3d> other than type Func = Int -> Int
01:36:21 <concept3d> also to define function types inside a data
01:36:24 <concept3d> any other uses ?
01:54:12 <jle`> concept3d: you're not asking about the uses of the Functor, Monad instance, right?
01:54:37 <jle`> *instances
02:14:50 <ReinH> (->) is a type constructor, not a data constructor
02:15:04 <ReinH> it is used to construct function types
02:15:11 <ReinH> there  isn't much else to say about it
02:19:22 <ReinH> it is right-associative, so a -> b -> c ~ a -> (b -> c)
02:24:05 <ReinH> To be precise, (->) is not a Functor or a Monad: it has the wrong kind. ((->) r), however, is both.
02:37:55 <concept3d> ReinH I know it's a type constructor sorry that was a typo.
02:50:27 * hackagebot dates 0.2.2.1 - Small library for parsing different dates formats.  https://hackage.haskell.org/package/dates-0.2.2.1 (IlyaPortnov)
03:00:27 * hackagebot yesod-bin 1.4.16 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.16 (MichaelSnoyman)
03:35:28 * hackagebot yesod-bin 1.4.16.1 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.16.1 (MichaelSnoyman)
03:53:05 <ideuler> Can anybody give me an example of foldr working on an infinite list? I don't understand how it would even begin to calculate, considering it being calculating in the last element of an infinite list. 
03:53:49 <mauke> foldr goes from left to right, not right to left
03:54:08 <mauke> > foldr (\x z -> x) 42 [1 ..]
03:54:10 <lambdabot>  1
03:55:14 <mmercer> > foldr ((:) . (2^)) [] [0..]
03:55:16 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
03:55:18 <mauke> > foldr (\x z -> x) "mushroom" (repeat "badger")
03:55:21 <lambdabot>  "badger"
03:56:35 <Hafydd> > error "Snaaaake!"
03:56:37 <lambdabot>  *Exception: Snaaaake!
03:58:31 <mmercer> @src foldr
03:58:32 <lambdabot> foldr f z []     = z
03:58:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:01:13 <ideuler> I see. I got confused by the constructed expression for instance foldr (+) 0 [1..3]  ->  (1+(2+(3+0)))  . But it builds the expression from left to right, and calculates from right to left. Thanks mmercer mauke! 
04:01:16 <mmercer> pay attention to "f x ( foldr f z xs)". if the function we supply (named f there) is lazy in the second argument, we delay the recursion until it is needed. so the second argument supplied function accepts (usually called acc), is not really an accumulated value, it is the recursive call to foldr
04:02:45 <mmercer> foldr (+) 0 [1..] will never end because (+) is  not lazy in the second argument
04:02:57 <mmercer> > foldr (+) 0 [1..]
04:02:58 <lambdabot>  *Exception: stack overflow
04:03:23 <mmercer> (well, it will never end assuming infinitely large RAM :) )
04:05:23 <ideuler> mmercer I see it now. Is there any situation where foldl would be prefered? Instead of its strict foldl' or foldr? 
04:06:52 <mmercer> I am not aware of any situation where foldl would be prefered
04:11:55 <mauke> @src reverse
04:11:55 <lambdabot> reverse = foldl (flip (:)) []
04:13:30 <cow_2001> gotta learn haskell profiling :|
04:23:00 <cow_2001> what does `stack build --executable-profiling` actually do?
04:23:06 <bolmar> isnt foldl more efficient?
04:23:47 <Darwin226> What's the easiest way to produce linux binaries on windows?
04:23:52 <mmercer> mauke is that an example of foldl being a better choice?
04:24:35 <arw_> Darwin226: install a linux vm, compile there.
04:25:11 <Darwin226> arw_: Alright. Is there a quick an painless way to do that? Maybe some of that docker magic I've been hearing about?
04:25:27 <arw_> Darwin226: nope. windows-docker is incompatible to "normal" docker.
04:25:51 <arw_> Darwin226: just get vmware or virtualbox and an ubuntu install image. 
04:26:40 <Darwin226> arw_: Ok. One more thing. I'm not really familiar with how this works with respect to distributions. If I build on ubuntu will it be runable on all the distros?
04:27:44 <arw_> Darwin226: generally speaking, nope. for haskell, there is a better chance since stuff is usually statically linked. 
04:28:11 <Darwin226> arw_: Ok. I'll give it a shot. Thanks!
04:47:26 <SrPx_> Would it make sense to add a "don't bother" type to a type system, that always typecheck? That is, a sort of weakening of the type system, allowing someone to use a specific subset of the language as an untyped calculi, if for some reason he needs so?
04:47:31 <SrPx_> Or is there a better way to do that?
04:47:56 <SrPx_> Something like: "foo : ?; foo x y = x;" <- applications of "foo" will pass the type checking because it is tagged as "foo : ?".
04:49:15 <SrPx_> But if you change to "foo : ∀ a b . a b -> a" it will still work, presumably. 
04:49:44 <SrPx_> ∀ a b . a -> b -> a *
04:50:09 <arw_> Data.Variant?
04:51:37 <SrPx_> arw_: wow that is dangerously similar to javascript, interesting, thanks
04:51:53 <SrPx_> (but I mean as an extension of a type system such as coc)
04:53:29 <ideuler> @src scanl
04:53:30 <lambdabot> scanl f q ls = q : case ls of
04:53:30 <lambdabot>     []   -> []
04:53:30 <lambdabot>     x:xs -> scanl f (f q x) xs
04:56:06 <arw_> SrPx_: the similarity to javascript (and basic, perl, python, ...) is intentional, I think.
04:56:43 <SrPx> Uh huh, I know arw_ 
04:56:58 <arw_> SrPx_: how would your proposal then deal with type errors? because in other languages, the compiler would have to insert a cast in the appropriate places.
04:58:12 <SrPx> I don't know if it would work, that's why I asked. But the idea is that I could use it to make easier the process of translating a lot of code on the untyped lambda calculus, and giving them types on demand. (Instead of having to start from scratch and not being able to use terms I didn't justify with types.)
05:00:59 <nicow> Is there anything fundamental that prevents one from turning an STM TMQueue to a lazy IO list?
05:03:45 <nicow> Following needs the queue to be closed before it returns it seems : http://pastebin.com/gsAy1aGH
05:12:02 <wedens> are there any disadvantages of having language extensions enabled via ghc options instead of per-module directives?
05:13:11 <pdkr> wedens: you might not need to enable them globally
05:13:26 <pdkr> but for individual .hs files, it's the same thing
05:14:21 <pdkr> wedens: i guess the disadvantage is that if someone else wants to compile your file, they'll might try it without any ghc options, see a failing compilation, and now they have to lookup what they did wrong. with per-module directives, they don't need to do anything as it's automatic
05:17:11 <wedens> ah, so ghci won't load this modules?
05:17:16 <wedens> pdkr: ^
05:17:33 <pdkr> wedens: well you can pass options to ghci as well
05:17:46 <pdkr> iirc you can even enable language extensions at runtime
05:17:53 <wedens> yeah
05:18:13 <wedens> I see. thanks
05:18:39 <pdkr> wedens: so the answer is: if you're writing a self-contained module, you'll probably want to use directives
05:25:31 * hackagebot Hoed 0.3.2 - Lightweight algorithmic debugging.  https://hackage.haskell.org/package/Hoed-0.3.2 (faddegon)
05:30:47 <spuz> hi, i'm trying to convert a string to an integer. Why does the following give an error in ghci: read "0"
05:31:13 <hpc> what error?
05:31:32 <spuz> No instance for (Read a0) arising from a use of `read'
05:31:44 <spuz> The type variable `a0' is ambiguous
05:32:21 <spuz> ah is it because it doesn't know what type to convert it to?
05:32:26 <hpc> so, it doesn't know what type you're reading the string to
05:32:28 <hpc> yeah
05:32:36 <hpc> > read "0" :: Int
05:32:38 <lambdabot>  0
05:32:50 <spuz> hpc, thanks
05:33:25 <spuz> it's been something like 5 years since i last did haskell. i seem to remember having this exact problem before
05:36:08 <lingxiao> hello?
05:55:31 * hackagebot sext 0.1.0.2 - Lists, Texts and ByteStrings with type-encoded length  https://hackage.haskell.org/package/sext-0.1.0.2 (DmitryDzhus)
05:58:29 <linduxed> hey guys
05:58:32 <linduxed> i've got this code https://gist.github.com/linduxed/d2f131dedcdae12afa64
05:58:40 <linduxed> for some reason, i'm getting this error:
05:59:18 <linduxed> http://dpaste.com/0PXV76G
05:59:36 <linduxed> i completely don't understand why it thinks xs is [[Char]]
05:59:58 <linduxed> the signature declares that you get in a String, which is the same as [Char]
06:00:10 <linduxed> how could it possibly get [[Char]] in there?
06:01:39 <sbrg> linduxed: if you want to pattern match on a single character, use ''
06:01:47 <sbrg> it not "
06:01:51 <sbrg> so change '(' to "("
06:02:08 <sbrg> linduxed: adventofcode eh?
06:02:11 <linduxed> aaah yes
06:02:15 <sbrg> seems like everyone is solving it lol
06:02:17 <linduxed> forgot this detail
06:02:30 <linduxed> been doing other languages than haskell for a while now
06:02:31 <linduxed> haha
06:02:34 <linduxed> sbrg: yeah!
06:02:49 <linduxed> thought it would be an excellent way to brush up my haskell skills
06:05:28 <spuz> linduxed, i'm doing the advent of code thing as well :)
06:07:14 <linduxed> :-)
06:07:42 <spuz> currently on part 2 of day 2
06:24:44 <pavonia> When you have OverloadedStrings enabled in GHCi, is it supposed to make that enabled in the module you load, too?
06:29:03 <introom> what's the doc for the operator like the "/=" in "5 /= 5" ?
06:29:29 <mmercer> @hoogle /=
06:29:30 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
06:29:31 <lambdabot> Data.Eq (/=) :: Eq a => a -> a -> Bool
06:29:43 <pavonia> introom: The Eq class
06:29:49 <mmercer> no links?
06:30:06 <introom> new to haskell today. I'd expect some form of language specification or so.
06:30:12 <introom> does this sorta doc exist ?
06:31:56 <introom> well. /= is ==.  Problem partially solved.
06:32:18 <pavonia> No, it's not, it's the opposite of (==)
06:32:21 <mmercer> google for haskell language report if you want language specs. if you want an easy way to look up functions by their name (or type signature) see https://www.haskell.org/hoogle/
06:32:23 <introom> pavonia: yes.
06:33:03 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/ perhaps?
06:33:35 <introom> yes. that should be the spec.
06:33:42 <jgt> hey folks, how would I md5 a string in a Yesod widget?
06:34:05 <introom> btw, just found out dash.app has haskell docset. cool.
06:49:03 <linduxed> i fucking love this language
06:49:26 <linduxed> when the thing compiles and it just does exactly what you want in a notably small amount of lines
06:49:28 <linduxed> lovely
06:55:17 <linduxed> can i pattern match against a string that looks like this?
06:55:27 <linduxed> "12-12-12"?
06:55:45 <linduxed> I would like to get the three numbers, omitting the dashes
06:58:01 <lyxia> > wordsBy (== '-') "12-12-12" -- linduxed?
06:58:03 <lambdabot>  ["12","12","12"]
06:58:31 <linduxed> lyxia: that'll definitely do!
06:58:42 <lyxia> great!
06:58:48 <linduxed> hmmm
06:58:52 <linduxed> on the other hand
06:58:54 <linduxed> well
06:59:02 <linduxed> i wanted to name the elements
06:59:07 <linduxed> but i can turn that into a tuple
06:59:19 <linduxed> then i could name the three values
06:59:22 <linduxed> i think that's a way
07:00:12 <lyxia> > let f (wordsBy (== '-') -> [a,b,c]) = (a, b, c) ; f _ = error "oops" in f "12-12-12"
07:00:14 <lambdabot>  ("12","12","12")
07:05:07 <linduxed> so in that code
07:05:18 <linduxed> you're utilizing a lambda, are you not?
07:05:35 <linduxed> except you haven't named anything on the left hand side of the ->
07:05:45 <linduxed> is this correct, lyxia?
07:06:48 <geekosaur> it's an operator section
07:07:06 <linduxed> geekosaur: i'm confused now
07:07:08 <geekosaur> oh, actually no, that;s a view pattern
07:07:19 <lyxia> Yes, view pattern.
07:07:32 <geekosaur> I missed the updated version
07:08:55 <lyxia> linduxed: (function -> pattern) is a pattern, which matches on the result of the function applied to the argument.
07:09:15 <linduxed> yes, i'm reading about it here right now https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
07:09:21 <linduxed> that's pretty cool!
07:11:13 <linduxed> what package do you get wordsBy from?
07:11:30 <linduxed> oh wait, found it https://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html
07:12:15 <linduxed> hmmm, weird, i found it through google, but neither hackage, hoogle or hayoo found "wordsby
07:12:16 <linduxed> "
07:12:46 <geekosaur> hayoo found it for me
07:12:46 <geekosaur> http://hayoo.fh-wedel.de/?query=wordsBy
07:15:47 <linduxed> haha, turns out i wrote "wordBy"
07:15:52 <linduxed> dropped an s
07:21:31 <geekosaur> hm, I'm surprised, hayoo is normally pretty good at handling that
07:22:24 <concept3d> suppose I have data Users { _users :: Map Id User }    and User { _items :: Map String Item } modifying anything inside users becomes ugly, how can I solve this using lenses
07:22:31 <StoneToad> linduxed: heh, that's the sort of thing that got me started down the road to haskell and strongly typed languages
07:22:53 <linduxed> StoneToad: i can see that
07:23:07 <linduxed> StoneToad: man i've been away from haskell for too long
07:23:08 <StoneToad> one of my early memories programing is spending what felt like *ages* trying to find a bug, turned out it was a typo in a 20 char long variable in my BASIC program
07:23:19 <StoneToad> so it was using 0 in one of the math calcs....
07:24:31 <hc> Hi, I've got a question about wai's continuation style passing... 
07:24:59 <hc> I've written a function that checks for an XSRF token and if none is found it uses the continuation to bail out... however, it seems to continue execution
07:25:02 <hc> here's the code:
07:25:03 <lpaste> hc pasted “requirePostXSRF” at http://lpaste.net/146584
07:25:11 <hc> if someone could have a look... :-)
07:28:04 <mpickering> concept3d: Is there something speecifically you want to do?
07:28:22 <mpickering> you can first start by defining lenses for `Users` and `User`. 
07:28:40 <mpickering> Then you can use indexed lenses to do things with the maps inside 
07:30:04 <concept3d> mpickering: I want to modify the user state which inside a map inside another map.. how can I solve using lenses
07:31:07 <concept3d> mpickering: so indexed lenses is the answer 
07:31:14 <concept3d> OK, i'll look into that
07:31:54 <mpickering> yep, look for the function "at"
07:32:37 <mpickering> then you would type something like s ^. users ^.at "myUser" ^. items ^.at "myItem" to get to an item
07:32:42 <mpickering> I think without trying it
07:38:56 <concept3d> mpickering: Thanks
07:39:59 <keko-2> only the first operator is "^.", right?
07:40:11 <keko-2> and the rest just .
07:40:53 <keko-2> (and you can also put ^? to get a Maybe)
07:41:06 <pdkr> i'm slightly confused about datakinds. do they allow me to write dependent functions?
07:46:40 <pdkr> because it seems that the kind is completely separate from the type. so what does this really give me?
07:47:18 <pdkr> e.g. in the common Vector example, can one write a function that gives the n-dimensional zero vector?
07:47:22 <dzhus```> pdkr: ability to write type-level functions constrained to types of specific kinds
07:49:19 <luite> introom: /win 49
07:49:25 <luite> uh...
08:18:43 <haskell082> i have a data type: data Layer = LZero | LOne | One deriving (Show, Enum) -- how do i store it in an IOArray?
08:19:04 <haskell082> not allowed to do e.g.  arr <- newArray (1,10) One :: IO (IOArray Layer Layer)
08:19:18 <haskell082> i thought enumerated types automatically work with arrays?
08:20:03 <aweinstock> :t Data.IOArray.newArray
08:20:27 <lambdabot> Not in scope: ‘Data.IOArray.newArray’
08:21:04 <aweinstock> :t Data.Array.IO.newArray
08:21:08 <lambdabot> (Ix i, Data.Array.Base.MArray a e m) => (i, i) -> e -> m (a i e)
08:21:13 <c_wraith> haskell082: it needs Ix, not Enum
08:21:58 <aweinstock> haskell082: try :: IO (IOArray Int Layer)
08:22:13 <aweinstock> the first parameter to IOArray needs to be the type of 1 and 10
08:22:32 <c_wraith> Oh, I missed that you were trying to use numbers as indices.
08:22:52 <haskell082> works, thanks aweinstock!
08:25:12 <wedens1> is there some wai middlewire that works with file-embed?
08:35:37 * hackagebot manifolds 0.1.6.2 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.1.6.2 (leftaroundabout)
08:44:14 <beekeeper> is there a way to filter out 'Nothing's from a list of [Maybe a] without having it as an instance of Eq? I'm doing "filter (/= Nothing) xs"
08:45:53 <aweinstock> :t catMaybes
08:45:54 <glguy> isNothing
08:45:54 <lambdabot> [Maybe a] -> [a]
08:46:05 <beekeeper> ah sweet. thanks
08:46:24 <aweinstock> :t map fromJust . filter isJust
08:46:25 <Tehnix> :t map fromJust . filter isJust
08:46:26 <lambdabot> [Maybe a] -> [a]
08:46:26 <lambdabot> [Maybe a] -> [a]
08:46:57 <aweinstock> beekeeper: you probably want to use catMaybes
08:46:58 <glguy> You can detect a Nothing without an Eq instance with isNothing. catMaybes is a better way to actually filter
08:47:24 <aweinstock> :t (\Nothing -> True; _ -> False)
08:47:25 <lambdabot> parse error on input ‘;’
08:47:39 <geekosaur> \case?
08:47:42 <aweinstock> :t (\x -> case x of Nothing -> True; _ -> False)
08:47:43 <lambdabot> Maybe t -> Bool
08:48:02 <aweinstock> :t (\case Nothing -> True; _ -> False)
08:48:13 <lambdabot> parse error: naked lambda expression ''
08:48:19 <bergmark> :t \l -> [x | Just x <- l]
08:48:20 <lambdabot> [Maybe t] -> [t]
08:48:29 <aweinstock> geekosaur: looks like lambdabot doesn't have LambdaCase
08:48:31 <geekosaur> ...except lb doesn;t have lambdacase :/
08:49:26 <geekosaur> .oO { lame da bot :/ }
08:49:52 <beekeeper> :110
08:49:53 <aweinstock> :t let maybeToList (Just x) = [x]; maybeToLost Nothing = [] in (>>= maybeToList)
08:49:54 <lambdabot> [Maybe b] -> [b]
08:51:51 <geekosaur> pity it doesn't catch typoes
08:52:24 <cow_2001> what do i see here? http://kaka.farm/~weechat/studentim-csv.ps
08:53:41 <arindam> solve x = sum $ map ( \n -> (x^n )/(fac n) ) [0..9] - can anyone explain this noinstance error ?
08:53:54 <arindam> fac n is the factorial function
08:54:07 <geekosaur> :t (^)
08:54:21 <geekosaur> :t (/)
08:54:23 <lambdabot> Fractional a => a -> a -> a
08:54:23 <lambdabot> (Integral b, Num a) => a -> b -> a
08:54:38 <geekosaur> there is no type that is both Fractional and Integral
08:54:57 <arindam> so, how do i proceed ?
08:54:59 <maerwald> :t fromIntegral
08:55:38 <lambdabot> (Integral a, Num b) => a -> b
08:57:23 <c_wraith> arindam: use div instead of /
08:57:26 <c_wraith> :t div
08:57:39 <lambdabot> Integral a => a -> a -> a
08:57:50 <arindam> @c_wraith, i need fractional values
08:57:50 <lambdabot> Unknown command, try @list
08:58:23 <c_wraith> arindam: what type is x?
08:58:33 <arindam> x is double
08:59:10 <c_wraith> arindam: oh.  change (fac n) to (fac (fromIntegral n))
08:59:12 <c_wraith> err.
08:59:16 <c_wraith> fromIntegral (fac n)
09:00:11 <arindam> ok, that worked, can you explain ?
09:00:15 <c_wraith> arindam: Haskell makes you be explicit about where you're converting between numeric types.  No accidental conversions between types making your logic wrong.
09:00:42 <c_wraith> arindam: fromIntegral is a generic conversion function between integer-like types and any numeric type.
09:01:57 <c_wraith> :t fromIntegral
09:01:59 <lambdabot> (Integral a, Num b) => a -> b
09:02:11 <arindam> is Num part of fractional ?
09:02:18 <c_wraith> @src Fractional
09:02:19 <lambdabot> class (Num a) => Fractional a where
09:02:20 <lambdabot>     (/)          :: a -> a -> a
09:02:20 <lambdabot>     recip        :: a -> a
09:02:20 <lambdabot>     fromRational :: Rational -> a
09:02:24 <Tehnix>     fromRational :: Rational -> a
09:02:45 <c_wraith> So all Fractional instances are required to be Num instances as well
09:03:04 <m4tt3> exit
09:03:40 <arindam> so, when needing fractional values, is it recommended to have everything in Num ?
09:04:40 <arindam> like all integers converted to num
09:04:45 <pdkr> arindam: if you define a function acting on Fractional, then you can implicitly use its Num instance
09:06:34 <arindam> i need to study typeclasses - could you guys suggest some resource ?
09:07:34 <pdkr> arindam: if you just want to write your "solve" function, do what c_wraith suggested and use fromIntegral
09:07:53 <arindam> pkdr: ok
09:08:43 <Hi-Angel> Have anybody use «Stack»? What could be the reason that «stack install» is sure that a library is installed, but «cabal install» inside a project directory is still trying to compile it instead?
09:09:50 <pdkr> Hi-Angel: "installed" is not an absolutely defined term. stack and cabal might be looking in different places
09:11:54 <Hi-Angel> pdkr, well, «stack install» compiled the library which is needed to compile another project. So, I launch the «cabal install» to continue compiling project (it stopped on failed compilation), and it trying to compile the library again, from the same file where it stopped before. But «stack install <library>» doesn't try to install it again, so it is installed…
09:12:28 <pdkr> Hi-Angel: i'm not sure you can mix cabal and stack like that
09:12:31 <Hi-Angel> I just thought another thing — perhaps am I supposed to compile a project with «stack install» too?
09:13:05 <Hi-Angel> No, it didn't work ☹
09:13:46 <Hi-Angel> But didn't stack supposed to solve all those dependencies, so that it would be possible to just compile a project?
09:18:01 <geekosaur> stack keeps its own separate package database, something installed with it won't be visible to cabal-install
09:18:13 <bergey> Hi-Angel: The standard workflow is to run `stack build` in the project directory to compile a project.  `stack install` only if the project produces an executable that you want to have on your path.  I don't know any reason to run `stack install` on a library.
09:18:50 <SrPx> Is there any performance difference in "foo == bar" vs "bar == foo"? 
09:20:09 <Hi-Angel> SrPx, I don't think so, because both arguments have to be evaluated in either case.
09:20:52 <Hi-Angel> bergey, ah, thank you. Hm… `stack build` just silently exit — does it mean that I can only use `cabal install`?
09:22:52 <bergey> `stack build` silently exits if there's nothing to do - if the project has already been built and nothing has changed since.
09:23:33 <Hi-Angel> Hm, interesting…
09:26:48 <Hi-Angel> Hm, no, it seems that the project still didn't built. I just tried to run some example, and it shows me the same error, as if'd run `cabal install
09:29:33 <Hi-Angel> And if I run `cabal install`, it tries to compile a library, and fails for some reason. Dunno, perhaps in Hackage is unstable `caffegraph`…
09:29:49 <bergey> How are you "running some example"?  Stack builds everything in a sandbox, so by design everything built is only visible to stack / programs run by stack in the sandbox.
09:30:02 <SiIky> is there a pre defined function that looks for something in a list and gives a tuple with the thing i want and the list without that thing? something like func :: a -> [a] -> (a,[a])
09:30:18 <SiIky> im pretty sure it exists, but i dont remember the name :|
09:30:52 <glguy> silkysFunction x xs = (x, delete x xs)
09:31:45 <bergey> :t partition . (==)
09:31:46 <lambdabot> Eq a => a -> [a] -> ([a], [a])
09:32:42 <Hi-Angel> bergey, I ran an example of the project like `runhaskell NN/Examples/GoogLeNet.hs --help`. It fails with an error «Ambigious occurence» in some file. In fact, it is the same file and the error as if I'd run just `cabal install`, so I guess it is trying to continue compilation of a library.
09:34:04 <SiIky> glguy: thanks
09:35:36 <Hi-Angel> Oh, just fine, now, perhaps after the `stack`, I could even reproduce it with raw `cabal install caffegraph` — it fails with unresolved dependencies which haven't there before…
09:35:55 <Hi-Angel> Ok, nevermind, 
09:37:38 <bergey> Hi-Angel: How about `stack runghc NN/Examples/GoogLeNet.hs --help` ?
09:38:44 <Hi-Angel> Wow!
09:38:49 <Hi-Angel> bergey, that's cool
09:39:08 <Hi-Angel> I mean, the «help» actually didn't work — stack though it is the argument to them
09:39:22 <Hi-Angel> But without «--help» it indeed executed!
09:39:33 <Hi-Angel> Thank you, I hope it would work…
09:39:42 <bergey> Oh, I forgot.  Try `stack runghc NN/Examples/GoogLeNet.hs -- --help` -- note the added -- before --help
09:40:25 <Hi-Angel> Yay, cool!
10:02:41 <RaceCondition> what to do if ghc-mod is not being able to import stuff that is in build-depends, claiming it's in hidden packages?
10:03:14 <RaceCondition> the exact same code and .cabal file works on my machine but not on my friend's one -- I'm suspecting ghc-mod might be using some stale/broken state, but we have no idea how to clear it out
10:05:02 <RaceCondition> ahh... stack clean did the job.
10:20:53 * hackagebot diagrams-builder 0.7.2.1 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.7.2.1 (bergey)
10:21:16 <rxv1> hi
10:27:56 <AleXoundOS> hi
10:33:44 <rxv1> hi alexoundos
10:36:23 * hackagebot diagrams-haddock 0.3.0.10 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.3.0.10 (bergey)
10:36:25 * hackagebot morte 1.4.1 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.4.1 (GabrielGonzalez)
10:37:17 <haskell082> i have an integer det, and when i call 1.0 / (fromIntegral det), I get `No instance for (Fractional Int) arising from a use of ‘/’` --> why ?
10:38:55 <glguy> haskell082: You're probably trying to use the result of that division as an Int
10:44:28 <linduxed> this advent thing is quite fun
10:44:36 <pikajude> yep
10:46:07 <ox100xxx0> hi! 
10:47:03 <jgt> howdy
10:47:35 <ox100xxx0> its sunday i think, been drunk all week end with mental patients (i am one too) very illogical i dad works with cobol and i was wondering should i learn haskel
10:47:59 <ox100xxx0> im very much not intellegent
10:48:39 <ox100xxx0> and i know nothing in maths however i have an illeness that makes me very logic 
10:48:43 <ox100xxx0> (for me....)
10:49:42 <ox100xxx0> i dont work and what really says something i like to do websites 
10:49:50 <ox100xxx0> hs can do that
10:50:15 <magneticduck1> please don't do Haskell under the influence
10:50:36 * magneticduck1 assuming you're still somewhat drunk
10:50:38 <c_wraith> Why not?  My most popular library on hackage was written mostly under the influence. :)
10:50:43 <magneticduck1> well
10:50:50 <c_wraith> I only sobered up enough to write the tests. :)
10:50:59 <magneticduck1> https://xkcd.com/323/
10:51:10 <ox100xxx0> i normally write code under the influence
10:51:11 <jgt> could someone help me with my Esquelito query? I'm new to Haskell, and also not amazing with SQL
10:51:12 <jgt> http://pastebin.com/rdksK4ww
10:51:46 <jgt> currently I'm getting every StatusUpdate and its User; I'd like to only get one StatusUpdate per User
10:52:30 <ox100xxx0> One thing i can'rt really understand you compile it before?
10:52:31 <magneticduck1> c_wraith ox100xxx0 I thought you were supposed to use adderall, not alcohol :S
10:52:33 <magneticduck1> color me suprised
10:52:39 <ox100xxx0> its not a cripting language non?
10:52:44 <pikajude> adderall also works very well for haskell!
10:52:59 <magneticduck1> I thought alcohol was for javascript and PHP
10:52:59 <c_wraith> magneticduck1: the fun thing about haskell is that alcohol doesn't make the compiler accept any extra programs.
10:53:09 <ox100xxx0> i hate php 
10:53:09 <magneticduck1> while C goes well with brandy
10:53:13 <magneticduck1> COBOL is vodka
10:53:14 <ox100xxx0> i prefer ruby
10:53:39 <ox100xxx0> then is just colors and tasts
10:53:46 <magneticduck1> rofl
10:54:51 <ox100xxx0> once drunk i said to myself i will breed dogs 
10:55:15 <ox100xxx0> next morning i quit my job and... breed dogs
10:55:20 <jgt> no? No one knows Esquelito here?
10:55:24 <ox100xxx0> so i can lean
10:55:28 <jgt> I guess my problem can't be solved.
10:55:51 <ox100xxx0> http://oliver-james-stocks.fr/ thats me
10:56:05 <ox100xxx0> i can't even remember coding that
10:57:03 <magneticduck1> u_u
10:57:25 <ox100xxx0> so my question still holds should i start to learn this or go to youporn
10:57:41 <ox100xxx0> the 2 should .... nice
10:57:58 <magneticduck1> I didn't sign up to give this sort of advice
11:01:25 <chokboy> it was mentioned on hacker news that if i wanted to learn more about haskell i could get the logs of this channel and grep for > to get experienced haskeller insight. how do i go about getting them logs?
11:02:23 <rcyr> I'd probably look at the topic of the channel :)
11:02:47 <magneticduck1> chokboy: ahahah
11:03:18 <ox100xxx0> in fact best irc channel is the 1 in google for google
11:03:18 <magneticduck1> >(ap (++) show)"(ap (++) show)"
11:03:28 <chokboy> ooooh. haha thanks :)
11:04:11 <ox100xxx0> come up https://news.ycombinator.com/item?id=7161236
11:04:21 <ox100xxx0> What are the best IRC channels for developers, security, networks, programming, general tech discussion, data science, etc. Just looking for some recco's.
11:04:39 <ox100xxx0> i think google knows me better than it should
11:05:47 <jgt> https://stackoverflow.com/questions/34121399/unique-post-author-from-esqueleto
11:05:54 <jgt> if anyone has any ideas…
11:06:34 <ox100xxx0> jgt: drink more...
11:07:30 <jgt> that guy was weird
11:08:01 <moop> indeed
11:09:08 <ut_> Does anyone have advice for running cabal update on a debian vm with 512 megs of ram?
11:09:28 <moop> ut_: create a huge swap file
11:10:03 <moop> like, the hugest
11:10:05 <moop> it'll be slow
11:10:07 <moop> but should work
11:10:45 <ut_> huh. any chance I could run it elsewhere and then rsync the cache or something? 
11:10:54 <ut_> or will that be a recurring problem? 
11:11:48 <moop> no idea
11:11:57 <moop> experiment, come back with an answer
11:42:12 <s00pcan> save
11:42:15 <s00pcan> hah sorry.
11:44:22 <happyfeet> i am trying to develop a brute force solver I have 4 chars: 'a','b','c','d' , I am trying to write a funcition that starts from length == 1 and then goes to length 2 in this second case we would have AA, AB, AC, AD, BA, BB ... and so on , basically a function to do that, any suggestions?
11:46:25 * hackagebot propellor 2.15.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.15.0 (JoeyHess)
11:49:11 <int-e> > [0..] >>= flip replicateM "ab"
11:49:12 <lambdabot>  ["","a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","b...
11:49:47 <happyfeet> > [0..] >>= flip replicateM "abcd"
11:49:50 <lambdabot>  ["","a","b","c","d","aa","ab","ac","ad","ba","bb","bc","bd","ca","cb","cc","...
11:50:05 <happyfeet> @int-e thank you so much :)
11:50:05 <lambdabot> Unknown command, try @list
11:52:14 <int-e> > sequence ["bcf","a","nr"]
11:52:16 <lambdabot>  ["ban","bar","can","car","fan","far"]
11:53:23 <llew_> exit
11:53:27 <llew_> quit
11:53:29 <int-e> happyfeet: it's an often useful fact that `sequence` in the list monad computes cartesian products of lists; and replicateM n m = sequence (replicate n m)
12:01:23 <d34df00d> Hi there!
12:01:31 <d34df00d> I'm trying to do some plotting with the gnuplot package.
12:01:45 <d34df00d> The sample command `plot cons $ list Graphics.Gnuplot.Graph.TwoDimensional.lines (take 30 (let fibs0 = 0 : fibs1; fibs1 = 1 : zipWith (+) fibs0 fibs1 in zip fibs0 fibs1))` works in ghci.
12:01:59 <d34df00d> But when I try to do `p = plot cons $ list Graphics.Gnuplot.Graph.TwoDimensional.lines (take 30 (let fibs0 = 0 : fibs1; fibs1 = 1 : zipWith (+) fibs0 fibs1 in zip fibs0 fibs1))` in my .hs file and load it into ghci, I get a bunch of type errors:
12:02:14 <d34df00d> https://bpaste.net/show/7733f1996782
12:02:19 <d34df00d> Why is this the case?
12:06:45 <Hijiri> d34df00d: the numbers in ghci are defaulting to Integer, but that doesn't happen in normal haskell source files under usual settings
12:07:06 <Hijiri> you probably want to annotate one of the numbers as an Integer
12:07:29 <Hijiri> like change fibs0 = 0 to fibs0 = (0 :: Integer), or maybe Int, if you want
12:07:48 <Hijiri> otherwise the compiler doesn't know what kind of number you want
12:07:50 <d34df00d> Oh, indeed that works, thanks!
12:08:03 <d34df00d> I was to scared by the error message to grasp it :(
12:08:39 <Hijiri> I didn't really get it until I saw the third error
12:09:10 <d34df00d> Having much C++ background I'm schooled to look at the first error first.
12:10:40 <Hijiri> a nice thing in haskell I think, is that if you give all your top-level definitions type signatures, the type errors are usually local to a definition
12:12:52 <OverCoder> Guys, what is the let thing? how can it be different than where?
12:13:31 <OverCoder> I mean I can't see any real difference
12:14:13 <Hijiri> it's syntactically different
12:15:12 * OverCoder googles again
12:15:18 <Hijiri> also with where, the definition is in scope for the whole thing it's under
12:17:53 <exio4> OverCoder: where works with definitions, let with expressions
12:18:16 <exio4> OverCoder: you can't use where with arbitrary expressions "x + x where x = 2" isn't valid, "let x = 2 in x + x" is 
12:21:36 <traf> hello
12:21:53 <OverCoder> exio4, Hm, ah alright then
12:21:56 <Sonolin> is there a best practice for using <$> vs fmap?
12:22:16 <Sonolin> I tend to just use "<$>" instead of fmap
12:22:26 <traf> how come I can'tdo  map . (+1) $ [1, 2, 3]
12:22:54 <Sonolin> traf: remove the dot?
12:23:05 <traf> i know that will work
12:23:09 <traf> but why can't i use the dot
12:23:13 <traf> isn't (+1) 
12:23:15 <Hijiri> that's equivalent to map ((+1) [1, 2, 3])
12:23:17 <traf> going to be partially applied?
12:23:23 <Hijiri> and you can't add 1 to a list
12:23:23 <verement> :t map . (+1)
12:23:41 <Sonolin> (+1) takes 1 argument
12:23:42 <lambdabot> Num (a -> b) => (a -> b) -> [a] -> [b]
12:24:08 <Sonolin> :t (+1)
12:24:10 <lambdabot> Num a => a -> a
12:24:16 <Hijiri> a list is one argument
12:24:19 <Sonolin> so map (+1) takes a list
12:24:28 <traf> :t map . (+1)
12:24:30 <lambdabot> Num (a -> b) => (a -> b) -> [a] -> [b]
12:25:12 <traf> so what would work with map . (+1)
12:25:12 <exio4> Sonolin: both are good, you use them depending which one looks more obvious, cleaner, etc :P 
12:25:56 <Hijiri> traf: nothing, unless you had an instance for Num (a -> b)
12:25:58 <exio4> Sonolin: "Abc <$> x <*> y", "fmap fn <$> x", "fmap something" 
12:26:03 <Hijiri> which there isn't and you probably shouldn't define
12:26:30 <traf> what would be an instance of Num (a->b)
12:26:41 <traf> isn't (+) a->b
12:26:43 <traf> :t (+)
12:26:49 <lambdabot> Num a => a -> a -> a
12:26:58 <traf> :t (+1)
12:27:00 <lambdabot> Num a => a -> a
12:27:25 <Hijiri> there, a is Num, but map . (+1) would require (a -> b) to be Num
12:27:29 <jgt> can anyone help me with this?
12:27:34 <jgt> https://stackoverflow.com/questions/34121399/unique-post-author-from-esqueleto
12:27:36 <Hijiri> be Num meaning having an instance of Num, I mean
12:28:36 <traf> why doesn;t this work (map . (+1)) (+1) [1,2,3]
12:28:37 <traf> then
12:28:50 <traf> and why can't (a->b) be Num?
12:29:16 <geekosaur> (a->b) pretty much can't be, period
12:29:49 <verement> :t (+1) (+1)
12:29:55 <geekosaur> (only inhabited by bottom / undefined; "a function from one random type to another random type" is kinda meaningless)
12:29:57 <lambdabot> (Num a, Num (a -> a)) => a -> a
12:30:23 <geekosaur> as for why a function can't have a Num instance, actually it can but no such instance is defined by default
12:30:24 <verement> traf: what does it mean to add 1 to a function?
12:30:41 <geekosaur> because what that *usually* means is that you forgot a parameter somewhere
12:30:53 <traf> to add 1 to a function
12:30:56 <traf> errm
12:31:07 <traf> well accept a tpye of num as input
12:31:11 <traf> and produce a type of num as output?
12:31:17 <traf> a-> a
12:31:18 <geekosaur> Num is not a type
12:31:25 <traf> typeclass*
12:31:54 <traf> verement: was that the answer ou were looking for?
12:32:23 <geekosaur> if you mean "why doesn't it just autoconvert whenever it needs to", it's because that's a good way to get surprising results
12:32:35 <geekosaur> so Haskell wants you to be explicit about conversion
12:32:46 <geekosaur> (with a specific exception for numeric literals)
12:33:30 <pdkr> can ghc be smart enough to compile away data constructors - as if they're newtypes? because i need existentials which apparently don't work with newtype
12:33:45 <verement> traf: I asked because I don't know the answer, but you seem to want to do it so you must know?
12:33:57 <traf> geekosaur: i think my real issue is with point free
12:33:58 <traf> for example
12:34:41 <traf> actually
12:34:45 <traf> i think i just figured it out
12:34:47 <traf> thanks
12:34:48 <traf> :)
12:36:39 <OverCoder> http://p.samuraimanpurse.com/XQ3c4JBD.txt error is: parse error in let binding: missing requires 'in'
12:36:47 <OverCoder> How stupid? I have already defined in
12:37:13 <glguy> You're not that stupid, you just have tabs set up incorrectly in your editor
12:37:26 <glguy> tab stops need to be set to 8
12:37:38 <OverCoder> Wow, 8? that's too much
12:37:40 <OverCoder> I have it 4
12:37:40 <glguy> however it's preferred to just not use them at all
12:37:51 <OverCoder> Hm, alright I will switch to spaces
12:38:44 <uli> 2
12:38:46 <traf> trying to run sum . map (read::String->Int) $ ["1"] inside a do block
12:39:01 <traf> getting compile error
12:39:02 <traf>  Couldn't match expected type `IO a0' with actual type `Int'
12:39:05 <OverCoder> Same thing, I have switched to indenting with spaces and nothing changed
12:39:13 <Cale> OverCoder: Pretty much all decent editors have a feature you can turn on to insert an appropriate number of spaces when the tab key is pressed
12:39:43 <glguy> OverCoder: OK, paste the fixed code so we can see what's wrong
12:39:43 <Cale> Do smallerVals and biggerVals start in the same column?
12:39:46 <I> Hi, How do I pass CFLAGS to gcc when using cabal?
12:39:54 <Cale> The s and b should line up vertically
12:39:59 <OverCoder> Cale, I use Sublime Text 3, I have been using it through my 6 languages (Ofcourse I use and IDE for real work)
12:40:03 <OverCoder> Ah
12:40:18 <OverCoder> Why would even the interpreter be that sensitive
12:40:23 <Guest61525> Hi, How do I pass CFLAGS to gcc when using cabal?
12:40:26 <glguy> I: https://www.haskell.org/cabal/users-guide/developing-packages.html
12:40:36 <glguy> I: "Command-line arguments to be passed to the C compiler."
12:40:50 <OverCoder> Thanks, it works now
12:41:00 <Cale> OverCoder: The rule is that the first non-whitespace character following 'let', 'do', 'of', or 'where' sets the indentation level for the block
12:41:18 <glguy> OverCoder: It needs to be able to tell that you've finished one definition and started another
12:41:28 <Cale> OverCoder: Lines which start in that column continue the block. Lines which are deeper are continuations of the previous line, and lines which are shallower close the block
12:41:47 <OverCoder> Ah, got it
12:42:14 <OverCoder> idk I just tend to love those languages that use things like {} for blocks and stuff
12:42:17 <Guest61525> http://pastebin.com/vKsCCmg8 I want to replace the -x c with -x c++
12:42:19 <OverCoder> It makes life easier
12:42:44 <uli> traf: May you post the code? If you want to reuse the sum result in the do block you could do let res = sum [...]
12:43:07 <glguy> traf: You probably wrote   something <- sum . map ....
12:43:29 <glguy> traf: if so, change it to: let something = sum . map ...
12:43:53 <glguy> In the case of IO, the <- means "execute this and name its result"
12:43:59 <glguy> while let just names a value
12:44:11 <traf> glguyL yeah i just missed out a let
12:45:27 <Ankhers> If I have a data type I have already defined, am I still somehow able to use persistents functions to automatically create the database from it?
12:45:27 <Guest61525> Ah I'm an idiot, I should just have called my c file cpp instead.
12:46:59 <Guest61525> Oh dear. vtable problems. I used to know what that meant. http://pastebin.com/FuqhrQX2 
12:47:25 <uli> Guest61525: You want to call into C++ code via Haskell?
12:47:56 <Guest61525> uli, yes is that unadvisable?
12:48:07 <Guest61525> It's compiled okay, but it's not linking
12:48:22 <uli> Guest61525: I suggest going Haskell -> C -> C++ (i.e. building a C-bridge)
12:49:05 <Guest61525> Well if my C code needs to import a C++ something.h, which itself uses classes... don't I need my shim to be in C++
12:49:05 <Guest61525> ?
12:49:45 <Guest61525> Unless you suggest I wrap it very carefully to remove any reference to C++ in the include files for my C code?
12:50:07 <glguy> https://isocpp.org/wiki/faq/mixing-c-and-cpp#c-calls-cpp
12:50:50 <Guest61525> Aha, glguy, this should help, I'll have a go tomorrow :-)
12:50:52 <Guest61525> thanks
12:51:31 <uli> Guest61525: That is the standard approach, yes: you would have a something.h that has "#ifdef __cplusplus" stuff inside
12:52:37 <uli> Guest61525: Then you test you C -> CPP bridge (with the help of this header) and then if that works you call with Haskell into the C
12:53:39 <nicow> Does anybody know what the thread "TimerManager" is in haskell, and why is it making so many foreign calls? Does it have anything to do with GHC.Event.TimeManager ?
12:54:12 <nicow> GHC.Event.TimerManager, my bad
13:01:27 * hackagebot tellbot 0.6.0.10 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.10 (DimitriSabadie)
13:07:27 <tekkkz> Hello! My code: http://ix.io/mFp --> something is not working. I mean there is following error at compiling: http://ix.io/mFq
13:07:37 <tekkkz> Can someone give me help please?
13:08:56 <c_wraith> tekkkz: you're attempting to use res, which has type Response ByteString as if it had type IO ByteString
13:09:17 <tekkkz> ahh i also need responseBody right?
13:09:19 <c_wraith> tekkkz: you should probably just pattern-match on res
13:09:28 <vektor> Hey! Does anyone here know a library that will let me typecheck a expression in a pure function?
13:09:37 <c_wraith> tekkkz: and decide what to do based on what pattern it was built with
13:09:50 <tekkkz> nono
13:09:55 <tekkkz> look at the answer here: http://stackoverflow.com/questions/3078288/http-post-contents-in-haskell
13:10:02 <tekkkz> im trying to use this snippet
13:10:13 <tekkkz> but i want to apply tagsoup now on it
13:10:49 <c_wraith> tekkkz: you can use getResponseBody, I guess.  But it's kind of dangerous to ignore the response code when doing so
13:11:15 <tekkkz> c_wraith, how to use it?
13:12:13 <c_wraith> tekkkz: I suppose you should probably just get the response body for now.  Worry about response codes when you're making a piece of reliable software.
13:14:09 <tekkkz> okay. so what must i apss to the tags <- ... line?
13:14:09 <tekkkz> *pass
13:14:27 <tekkkz> c_wraith, i had a disconnect (timeout) did you answered already?
13:16:27 * hackagebot rtcm 0.1.2 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.1.2 (markfine)
13:16:49 <tekkkz> c_wraith, hello?
13:21:03 <pdkr> how do i deprecate my package on hackage?
13:22:31 <bergmark> pdkr: http://hackage.haskell.org/package/foo/deprecated/edit
13:23:20 <pdkr> bergmark: did i miss a link to it somewhere? how could i have known this?
13:24:04 <bergmark> pdkr: "edit package information" from the package page
13:26:21 <pdkr> bergmark: right. thanks!
14:06:16 <Guest49418> ciao
14:13:43 <Darwin226> Hey. In the pipes library. Is there an easy way to convert a function (a -> b) into a Pipe a b m r?
14:14:25 <Darwin226> Or, more concretely, if I have a Producer that's making `a`s, and a function a -> b, how do I make a Producer that makes `b`s
14:20:05 <Darwin226> Oh.. The function is literally called map...
14:20:09 <Darwin226> Damn
14:27:53 <vektor> https://www.reddit.com/r/haskell/comments/3vponq/pure_typechecking_function/ - plugging my own post. I'd love to hear your thoughts.
14:28:41 <mtesseract> Hi
14:29:46 <ReinH> vektor: I can't give any thoughts on it since it was removed.
14:29:56 <mtesseract> I would like to define the datatype "Number (Rational or Double, I don't care) in the interval [0,1]". How can I define this type, that is: an interval constraint, in Haskell? 
14:31:06 <vektor> ReinH: That is really odd.
14:31:09 <mtesseract> (Without e.g. mapping the range of an Int to a discrete subset of the interval]
14:32:07 <Hijiri> you could wrap it with a newtype and only expose a constructor that checks if it's in [0,1] and returns a Maybe ThingInZeroOne
14:32:09 <vektor> ReinH: I can reproduce that only when I'm not logged in...
14:32:13 <Darwin226> mtesseract: Probably just a newtype over a Double and making sure you only construct it when the value is int he correct range
14:32:26 <Darwin226> yeah, what he said
14:33:12 <Hijiri> but then you wouldn't be able to provide arbitrary addition, without doing something like clamping the result
14:36:40 <vektor> ReinH: Looks like the spam filter caught it. I'll be back.
14:39:43 <orzo_> Can I get some feedback on a tiny library I'm considering uploading to hackage?  http://jerkface.net/~joe/volatile/Data-Volatile.html
14:39:54 <orzo_> Particularly if you are familiar with the regions package
14:42:16 <mtesseract> Darwin226, Hijiri: Thanks for your input.
14:43:14 <orzo_> source-links fixed (they were broken when i first shared the URL)
14:43:15 <mtesseract> Sounds like a solution. By the way, what I am trying to do is to define some kind of 'weight' to be used alongside some values.
14:45:09 <orzo_> it's just 3 functions, but i'm not sure if there is not already a better solution on hackage for what i'm doing.  Anyone?
14:46:24 <orzo_> the code is originally for use with a memory-mapped file (actually lmdb database)
14:48:37 <d34df00d> Let's say I have a function `process :: (GT.C t) => t -> String -> IO ()`
14:48:53 <ReinH> vektor: message the mods
14:49:01 <vektor> ReinH: I did.
14:49:03 <ReinH> kk
14:49:10 <d34df00d> And let's say I want to make a function like this:
14:49:19 <d34df00d> mkTerm "x11" = GTX.cons
14:49:19 <d34df00d> mkTerm "eps" = GTP.cons "out"
14:49:51 <d34df00d> Where GTX.cons and GTP.cons "foo" have different types, but both implement the GT.C typeclass.
14:50:05 <d34df00d> And I want to pass the result of that function to `process`.
14:50:19 <ReinH> mtesseract: you can't define subtypes in Haskell in this way
14:50:28 <d34df00d> What's the best way to do this? I cannot think of anything but playing around with a forall'd wrapper type.
14:51:09 <orzo_> Are you trying to acomplish something like Text.Printf.printf ?
14:51:22 <DarwinElf> pikajude, if you said something to me a day or two ago, maybe you should message me (it scrolled off my screen)
14:51:26 <orzo_> a variadic function
14:51:39 <d34df00d> orzo_: you mean, me?
14:51:44 <orzo_> yes, d34df00d 
14:52:02 <d34df00d> Nope, not exactly.
14:52:23 <d34df00d> I'm trying to do some plotting with the gnuplot package in haskell, and one of the parameters of the plotting function is the terminal type (X11/eps/png/etc).
14:52:56 <d34df00d> I want to separate the creation of the terminal type from the plotting itself, and as such I'd like to make a function that'll create a right terminal based on command line argument (hence mkTerm).
14:53:16 <d34df00d> The problem is that different terminals have, well, different types, but satisfy the same "Terminal" type class.
14:53:36 <d34df00d> So I'm not sure how I could have them all in a single function without a type erasure-based wrapper type.
14:53:43 <d34df00d> Which I'm too lazy to do so I wonder if there are better ways.
14:53:47 <dmwit> d34df00d: mkTerm "x11" = process GTX.cons; mkTerm "eps" = process (GTP.cons "out")
14:55:29 <d34df00d> dmwit: hmm, let me try this...
14:58:45 <koz_> OK, I have the following bit of code: http://paste.rel4tion.org/156 , and the compiler complains that no instance of Show a arises.
14:58:59 <koz_> I get the issue - I have no idea what I need to write to resolve it though.
14:59:14 <glguy> 03instance Show a 07=> Show (Classifier a)
14:59:20 <koshmar> is there any shortcut for the last expresion in ghci (e.g. ">2+2<Enter>4 \n>sqrt %<Enter> 4")
14:59:23 <koz_> Ah.
14:59:49 <geekosaur> koshmar, "it"
15:00:01 <koshmar> thx
15:00:28 <koz_> glguy: That complains about show not being visible in the class Classifier, which I don't get either.
15:00:35 <glguy> koz_: It's generally bad practice to customize your Show instance like that rather than deriving it and defining other functions for custom views on the data
15:01:02 <glguy> koz_: Then you might not have typed the second occurrence of "Show" in
15:01:13 <koz_> Oh, derp. Thanks.
15:01:19 <koz_> glguy: I know - this is mostly for debugging purposes.
15:03:28 <d34df00d> dmwit: ok, I realized that I'd really need to do the reverse: invoke `mkTerm` inside `process` whenever I need a terminal.
15:03:29 <varaindemian> map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
15:03:37 <d34df00d> So how could I do that?
15:03:44 <varaindemian> I do not understand the" @" part
15:04:03 <geekosaur> it's an as-pattern
15:04:10 <geekosaur> name@(another pattern here)
15:04:12 <rcyr> varaindemian: the variable at the left of it is a reference to the full list
15:04:18 <d34df00d> I was about to do something like `data Term = forall t. GT.C t => Term t` and then implement GT.C for this Term type, but turns out that GT.C is a private typeclass (or something like that), and I can't do that, getting:
15:04:32 <d34df00d> https://bpaste.net/show/df5ddea69a36
15:04:40 <d34df00d> (`canonical` is the only function of the typeclass).
15:04:40 <varaindemian> rcyr: where can I find more details about it?
15:04:57 <glguy> d34df00d: Then it's not "visible"
15:05:24 <d34df00d> Ok, so this means I can't do the trick similar to https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
15:06:28 <varaindemian> rcyr: ?
15:06:30 * hackagebot hsexif 0.6.0.7 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.0.7 (EmmanuelTouzery)
15:06:59 <geekosaur> varaindemian, https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17 ?
15:08:00 <glguy> d34df00d: That's correct, you're a victim of both the author's naming convention (C and T) and also of the class being unimplementable
15:09:51 <jgt> could someone please help me with my Esqueleto syntax? It's a little complicated: http://pastebin.com/qBqcF7BB
15:10:41 <jgt> here's what GHC says: http://pastebin.com/Hw2XtMz3
15:11:11 <d34df00d> glguy: are there any workarounds? I remember ghc being able to auto-derive typeclass implementations for simple cases.
15:11:32 <glguy> Template Haskell can defeat module boundaries
15:12:08 <hodapp> wha?
15:12:51 <d34df00d> Meh, I'm not sure I want to take that route.
15:13:20 <geekosaur> arguably a bug but a hard one to fix
15:14:09 <Pamelloes> It's a useful one, though. It's nice to have a backdoor around module boundaries.
15:18:00 <NemesisD> hey guys, I noticed the "derive" package provides TH for deriving QuickCheck's arbitrary. Does anyone know if it should be possible to implement the same thing using Generic? Was thinking about doing it
15:18:27 <NemesisD> generally TH seems pretty inflexible. Doesn't really adapt well to qualified imports. very scope-dependent
15:19:06 <koz_> Is there a function that's equivalent to (>>= return) ?
15:19:17 <glguy> id
15:19:21 <NemesisD> hehe
15:19:35 <koz_> glguy: Really?
15:19:55 <NemesisD> koz_: from the monad laws: m >>= return  =  m
15:21:28 <koz_> The more I think I understand monads, the less it seems I actually know...
15:23:05 <geekosaur> did you mean (>>=) . return? because that would be fmap
15:23:32 <geekosaur> (unless I did tht werong whoch is possible since I'm scrambled right now :/ )
15:24:10 <koz_> geekosaur: I think I did.
15:26:17 <Hijiri> :t (>>=) . retur
15:26:20 <Hijiri> :t (>>=) . return
15:26:23 <lambdabot>     Not in scope: ‘retur’
15:26:23 <lambdabot>     Perhaps you meant ‘return’ (imported from Control.Monad.Writer)
15:26:25 <lambdabot> Monad m => a -> (a -> m b) -> m b
15:27:01 <Hijiri> flip ($) ?
15:27:11 <Hijiri> or flip id
15:27:14 <verement> :t (>>= return)
15:27:16 <lambdabot> Monad m => m b -> m b
15:27:53 <varaindemian>     search needle haystack =   
15:27:53 <varaindemian>         let nlen = length needle  
15:27:53 <varaindemian>         in  foldl (\acc x -> if take nlen x == needle then True else acc) False (tails haystack)  
15:28:02 <lpaste> glguy pasted “template haskell hacking” at http://lpaste.net/146602
15:28:03 <varaindemian> what is that x referring to?
15:28:09 <dmwit> :t \f x -> x >>= return . f -- this is fmap
15:28:11 <lambdabot> Monad m => (a -> b) -> m a -> m b
15:28:15 <glguy> d34df00d: that's what it'd look like ,at least :)
15:28:47 <dmwit> varaindemian: `\acc x -> ...` is an anonymous function which takes two arguments, binds them to `acc` and `x`, then evaluates to `...`.
15:29:34 <dmwit> d34df00d: At this point it is probably worth asking why you need to call `mkTerm` from inside `process`.
15:29:54 <varaindemian> dmwit: so x would be one of the "tails of tails"
15:30:15 <d34df00d> dmwit: `process` plots several different graphs, and a terminal is needed for each of them.
15:30:41 <varaindemian> dmwit: right?
15:30:42 <d34df00d> So that looks like `mapM_ (\(p', n) -> (mkTerm term (fname ++ "_parameter" ++ n ++ ".txt") (\t -> GA.plot t $ gfxPrim runs p'))) [(p1, "p1"), (p2, "p2"), (p3, "p3")]`
15:31:03 <dmwit> :t foldl
15:31:05 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
15:31:27 <d34df00d> (I'm currently trying to make mkTerm like `mkTerm "x11" _     cont = cont $ GTX.cons; mkTerm "eps" fname cont = cont $ GTP.eps $ GTP.cons fname`, but this gives me errors:
15:31:30 <dmwit> varaindemian: I guess it would just be one of the tails.
15:31:36 <d34df00d> https://bpaste.net/show/8e34c677d1d9
15:31:48 <varaindemian> I see
15:33:08 <glguy> d34df00d: You don't need the instance of the class to be able to use the wrapper type
15:33:16 <glguy> It just makes it more convenient to use
15:33:39 <dmwit> d34df00d: My head is swimming with types and and names, some of which I suspect are from old versions of your code. Can you give the types of things you have, and what you want to do, in a self-contained paste?
15:33:56 <d34df00d> glguy: and how can I do that?
15:34:02 <d34df00d> dmwit: oh, sure, sorry, my bad. Will do.
15:34:34 <glguy> process' 07:: SomeTerminal 07-> (); process' (SomeTerminal t) 07= process t
15:34:53 <glguy> You can write a new "process" function that only works on your SomeTerminal type and always use that
15:35:54 <glguy> 03data SomeTerminal 07= forall t07. C t 07=> SomeTerminal t
15:43:37 <d34df00d> glguy: well, even a separate wrapper type is not needed this way.
15:43:47 <d34df00d> `mkTerm :: String -> String -> (forall t. GT.C t => t -> a) -> a` works just fine!
15:45:26 <glguy> sure, but the wrapper type version is cleaner than having to use rank2 types and CPS
15:47:07 <dmwit> Assuming you know which plot* function you're planning to pass as the continuation, just partially applying that is still the solution I would recommend.
15:47:49 <dmwit> s/plot\*//
15:49:16 <d34df00d> dmwit: yeah, but I'll still need to pass it as a continuation, right?
15:49:30 <d34df00d> glguy: hm, but why rank2 is considered "unclean"?
15:49:45 <dmwit> d34df00d: In my proposal, no.
15:50:24 <dmwit> d34df00d: If your continuation is of type `(forall t. GT.C t => t -> X)`, then in my proposal you would have `mkTerm :: String -> String -> X` rather than the one you proposed.
15:50:33 <dmwit> No extensions of any kind would be needed.
15:51:19 <d34df00d> dmwit: well, I guess I'm not sure I'll be able to produce a minimal and clean enough sample of the code that'll illustrate the thing I want to do.
15:52:21 <dmwit> d34df00d: The proposal I'm making is a specialization of the one described here, by the way: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
15:52:25 <d34df00d> In case you'd like to take a look of ~30 lines of my current code, that's
15:52:28 <d34df00d> https://bpaste.net/show/b1817dedfa6b
15:53:06 <d34df00d> dmwit: thanks for the link, will take a look!
15:53:50 <dmwit> d34df00d: My proposal is essentially `mkTerm "x11" fn = GA.plot GTX.cons; mkTerm "eps" fn = GA.plot (GTP.eps (GTP.cons fn))`.
15:54:15 <glguy_> The anti pattern response is more suited to the author of the original library, not the user
15:54:29 <dmwit> d34df00d: And then `mapM_ (\(p', n) -> mkTerm term (fname ++ ...) (gfxPrim runs p')) [...]`.
15:54:49 <d34df00d> dmwit: oh, I see.
15:54:56 <glguy_> Having to restructure your program awkwardly as a user of the library isn't worth the zero extension badge
15:54:56 <d34df00d> That's clean and pretty, thanks!
15:55:19 <dmwit> glguy_: I don't think it is a particularly awkward restructuring, in this particular case.
15:55:25 <linduxed> is there some good word that describes the action of preparing some data for usage in some process?
15:55:53 <glguy_> I think there's value in being able to split the program up into its logical parts and name the steps
15:55:59 <linduxed> an example would be to lowercase a word because you always lowercase all words prior to sorting
15:56:03 <d34df00d> lindenk: I always used "preprocess".
15:56:07 <d34df00d> Sorry.
15:56:12 <d34df00d> linduxed: that was for you.
15:56:14 <linduxed> preprocess is pretty good
15:56:21 <linduxed> what about "normalize"?
15:56:37 <d34df00d> I'd expect that to be a step in "preprocess", like stemming etc.
15:57:09 <linduxed> yeah preprocess is better than normalize
15:59:12 <jgt1> can anyone see the issue here? https://stackoverflow.com/questions/34121399/unique-post-author-from-esqueleto
15:59:45 <dmwit> While we're doing naming, I have a `class Finite a where universeF :: [a]`, and I'd like to add something like `size :: proxy a -> Integer`. I don't like the name `size`, though, because it's oft-used in other packages; any suggestions for alternatives?
16:00:22 <dmwit> My current front-runner is `diameter`, and I've also thought of `width`. They're not great, though.
16:01:05 <glguy> cadinality? :)
16:01:11 <d34df00d> Cardinality?
16:01:15 <d34df00d> Haha.
16:01:20 <dmwit> Oh, I like that a lot.
16:01:26 <d34df00d> What's a proxy btw?
16:01:27 <glguy> I suggesting going with d34df00d's spelling
16:01:31 <glguy> it's a type variable
16:01:52 <dmwit> d34df00d: This is a standard trick for taking a "type" argument rather than a "value" argument.
16:02:21 <dmwit> d34df00d: The problem with `class Foo a where foo :: Integer` is that the compiler can never know which instance to use when you call `foo`.
16:02:46 <dmwit> d34df00d: You could fix this by writing `class Foo a where foo :: a -> Integer` and calling it like `foo (undefined :: Bar)`, but `undefined` is ugly.
16:03:13 <dmwit> d34df00d: So the modern alternative is `class Foo a where foo :: proxy a -> Integer`, together with `data Proxy a = Proxy`, and then calling it like `foo (Proxy :: Proxy Bar)`.
16:03:29 <d34df00d> Oh, I see, it's like a type tag.
16:03:45 <dmwit> d34df00d: The reason for giving the method type `proxy a -> Integer` rather than `Proxy a -> Integer` is to guarantee that the method never inspects the `Proxy`.
16:03:55 <d34df00d> But why not call like (foo :: Bar -> Integer)?
16:04:07 <dmwit> d34df00d: And of course, it's also a bit more flexible, as if you have a value of type `a` lying around you can call, e.g. `foo [x]` without any type annotations.
16:04:40 <dmwit> d34df00d: I think I covered that one, right? `undefined` is ugly, and giving the method the type `a -> Integer` doesn't guarantee that the method never inspects its first argument.
16:04:50 <d34df00d> I missed that inspection point.
16:04:57 <d34df00d> Makes sense, yes.
16:05:03 <glguy> If you want to guarantee that it's not even 'seq'd you can use Tagged
16:05:04 <d34df00d> Cool, thanks for the explanation!
16:06:12 <glguy> and then recover the proxy behavior later with: proxy :: Tagged s a -> proxy s -> a
16:06:47 <glguy> and then you don't have to rely on the compiler to optimize away the function, either
16:06:57 <dmwit> Aha, that's cute.
16:07:07 <koz_> OK, my code is being *very* weirdly-behaved.
16:07:13 <dmwit> Should I give the method type `cardinality :: Tagged a Integer`, then?
16:07:14 <koz_> And I have absolutely no clue why.
16:07:26 <koz_> Because it seems that if I run it in GHCi, it's well-behaved.
16:07:54 <glguy> dmwit: It's certainly an option. I think that the downside is that you lose the complete lack of external dependency that the proxy version has
16:08:01 <dmwit> right
16:08:23 <dmwit> It also makes my class law harder to state. =P
16:11:02 <beekeepe1> supposing you have a lot of functions with arguments and returns containing a lot of state-ish stuff, how can you still map and zip and filter (etc) the interesting results of these functions, with all the state-ish junk being returned too?
16:11:16 <dmwit> :t mapM
16:11:18 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:11:22 <dmwit> :t zipWithM
16:11:23 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
16:11:26 <dmwit> :t filterM
16:11:28 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
16:11:41 <beekeepe1> ah no! I need to learn more :-)
16:12:32 <RaceCondition> what's the best resource to read on going from types back to values, i.e. type reification? 
16:13:40 <dmwit> beekeepe1: Well, I guess if you want the monomorphic version of these, there's at least
16:13:43 <dmwit> :t mapAccumR
16:13:44 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
16:14:06 <dmwit> Hah, still not monomorphic. But at least includes the `State a` part of `mapM`. =)
16:16:35 <jmcarthur> RaceCondition: you mean like inferring the value from the type?
16:17:12 <RaceCondition> no, I mean "downloading" type information from the type level to the value level, so that the program could self-reflect at runtime
16:17:25 <RaceCondition> like, reuse static information at the dynamic level
16:18:46 <jmcarthur> there are many ways you could intend that
16:19:07 <jmcarthur> type classes are kind of what you just said. another related thing might be singleton types.
16:19:46 <jmcarthur> there's also typeable, but i have a feeling that's not what you mean
16:23:24 <Sindriava> Is Monoid defined for functions?
16:23:55 <dmwit> Yes, pointwise.
16:24:02 <dmwit> (f <> g) x = f x <> g x
16:24:10 <dmwit> mempty x = mempty
16:24:21 <Sindriava> oh, interesting
16:24:58 <Sindriava> I was expecting it to be defined using (.)
16:25:04 <koz_> Would someone be willing to help me over PM? It's a very involved bit of code, and I don't wanna clutter up the chan.
16:25:11 <Sindriava> but that would only work for (a → a), I guess
16:25:42 <dmwit> There's one for that as well, newtype Endo a = Endo {appEndo :: a -> a}.
16:26:03 <Sindriava> Ooooh, yeah, I've worked with that one, but completely forgot!
16:26:06 <dmwit> ?paste online if you have long code, koz_
16:26:06 <lambdabot> Haskell pastebin: http://lpaste.net/
16:26:08 <Sindriava> dmwit: Thanks ^^
16:26:19 <koz_> dmwit: It's a *lot* of code.
16:26:23 <koz_> But OK, sure.
16:26:30 <dmwit> (not in-channel!)
16:26:47 <koz_> dmwit: I don't paste snippets longer than 1 line.
16:27:08 <dmwit> Thanks. =)
16:27:23 <Sindriava> @karma+ dmwit
16:27:23 <lambdabot> dmwit's karma raised to 65.
16:28:06 <geekosaur> someone had a terminal oops in another channel that pasted their entire scrollback buffer, twice. channel was unusable for like an hour
16:28:08 <geekosaur> x.x
16:28:13 <koz_> I have this code: http://paste.rel4tion.org/157 , with these tests: http://paste.rel4tion.org/158 . The comments in the tests show what goes wrong. However, when I load the tests into GHCi, and try to run classifyRec directly on loadedC, it works correctly.
16:28:19 <koz_> What am I missing or doing wrong?
16:28:31 <Sindriava> geekosaur: How come the server doesn't prevent this? O.o
16:28:42 <geekosaur> clients rate limit themselves
16:28:53 <Sindriava> 😐🌴
16:28:54 <geekosaur> which actually made it worse in this case because it was 1 line every 3-5 seconds
16:28:56 <dmwit> Sindriava: It does. Unfortunately, some clients *also* prevent this by slowing down long pastes, resulting in the server not noticing.
16:29:09 <Sindriava> Yeah, that sounds horrible
16:29:17 <geekosaur> so what might have been a big glob over quickly steetched out foreeeeeeeever
16:31:08 <geekosaur> koz_, often when it works in ghci but not ghc, you are relying on ExtendedDefaultRules
16:31:33 <geekosaur> which you can enable in ghc,if you really need to
16:31:35 <koz_> geekosaur: You misunderstand. I called classifyRec directly, not via classify, in GHCi.
16:31:51 <pdkr> does anyone have any examples/tutorials on singletons?
16:32:08 <pdkr> especially when coupled with existential types
16:33:04 <dmwit> pdkr: Possibly the "Dependently typed programming with singletons" paper.
16:33:26 <dmwit> http://www.seas.upenn.edu/~sweirich/papers/haskell12.pdf
16:34:05 <pdkr> dmwit: yeah, i've seen that. i think i need to see more.
16:35:33 <dmwit> koz_: Is it possible that ghci is using a different version of your code than the tests are?
16:36:01 <dmwit> e.g. perhaps the tests are linked against a package taken from your package database, but ghci is looking directly at the code in the directory you're in.
16:36:29 <koz_> dmwit: No and no. Would it help to show what I tried in GHCi?
16:38:33 <dmwit> koz_: Classify.Trees -- ?
16:39:21 <koz_> dmwit: http://paste.rel4tion.org/159
16:39:31 <koz_> Although the tests on that module are well-behaved so far.
16:39:40 <koz_> I'll give you a dump of my GHCi session.
16:39:42 <koz_> As well.
16:40:32 <koz_> dmwit: http://paste.rel4tion.org/160 <-- GHCi session
16:42:38 <dmwit> I don't get it. ```loadedC >>= (`classify` sample1)``` gives me `Nothing` in ghci, just like the test claims it does.
16:42:47 <dmwit> So where is the difference between what the tests say and what ghci says?
16:47:18 <dmwit> ?hoogle (a -> b) -> proxy b -> Proxy a
16:47:19 <lambdabot> Did you mean: (a -> b) -> Proxy -> Proxy
16:47:19 <lambdabot> Data.ByteString.Builder.Prim (>$<) :: Contravariant f => (b -> a) -> f a -> f b
16:47:19 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
16:48:00 <koz_> dmwit: If you look at the later stuff, I try to call classifyRec directly, as classify is meant to.
16:48:05 <koz_> And it actually gives different answers.
16:48:27 <koz_> That's what I was getting at - I can't see what I'm doing in GHCi that's different from what classify is doing on its own.
16:48:36 <dmwit> Which call is intended to mimic ```loadedC >>= (`classify` sample1)```?
16:51:24 <koz_> dmwit: (loadedC>>= root) >>= return.(`classifyRec` [True, True, True])
16:51:30 <dmwit> Perhaps you intended to write `i - 1 == genericLength sample` in the definition of `sample`.
16:51:59 <koz_> How is that different to what's there now?
16:52:44 <dmwit> You wrote `i == genericLength sample - 1`, which is the same equation as `i - 1 == genericLength sample - 2`.
16:53:29 <koz_> OH....
16:53:34 * koz_ feels intelligent.
16:54:25 <koz_> Thanks, that solves *one* of the weird cases.
16:54:35 <koz_> I now have another one, but I need to investigate it first.
16:54:38 <koz_> Thanks!
16:56:54 <koz_> dmwit: I don't quite understand how 'i == genericLength sample - 1' is the same as 'i - 1 == genericLength sample - 2'. COuld you please enlighten me?
16:57:18 <dpwright> I'm using cabal-install to build and install a project, and making use of the automatically generated _Paths module to get at data files bundled with my project, which is fine
16:57:37 <dmwit> koz_: Just subtract one from both sides of the equation...?
16:57:43 <dpwright> in this case, installing on freebsd gives me a directory in /usr/local/share somewhere, which is what I want/expect
16:58:02 <dpwright> is there a standard way to get the equivalent /usr/local/etc path?
16:58:47 <dpwright> I'd rather read my configuration from there than have the user modify a file in /usr/local/share (which may get overwritten when the project is updated...)
16:59:21 <lasericus> Curious if anyone would be willing to help me understand some Control.Monad.Free code that I'm working with (http://lpaste.net/146614#line21). I'm trying to figure out how I might represent a function of type `IO a -> IO (Double, a)` as a constructor of my ActionF type.
16:59:41 <dmwit> dpwright: xdg-basedir ?
16:59:44 <koz_> dmwit: I guess what I'm asking is why does 'i - 1 == genericLength sample' not do the same thing as 'i == genericLength sample - 1'.
16:59:44 <dmwit> ?hackage xdg-basedir
16:59:44 <lambdabot> http://hackage.haskell.org/package/xdg-basedir
17:00:18 <dmwit> koz_: If you believe that `i == genericLength sample - 1` does the same thing as `i - 1 == genericLength sample - 2`, then it should be easy to believe that this is not the same as `i - 1 == genericLength sample`.
17:01:00 <dmwit> I honestly don't know a more basic fact to appeal to when explaining this than how subtraction works.
17:01:07 <ReinH> koz_: because of the basic rules of arithmetic
17:01:20 <koz_> OK, never mind, I think I'm phrasing my question wrong.
17:01:35 <dmwit> koz_: Perhaps a different way to get at your question: why *should* `i - 1 == x` and `i == x - 1` do the samething?
17:01:45 <ReinH> a = b - 1 => (add 1 to both sides) a + 1 = b
17:01:53 <koz_> Ah, ok.
17:01:58 <koz_> Dunno what's wrong with me today.
17:02:04 * koz_ apparently has a Master's degree...
17:02:07 <ReinH> koz_: <3
17:02:10 <koz_> Clearly not one of my better days, lol.
17:02:10 <lasericus> I've spent some time hacking apart the examples from Gabriel Gonzalez's excellent "Purify code using free monads" post - and managed to get myself stuck.
17:02:18 <dpwright> dmwit thanks! looks like that's worth a shot
17:02:25 <ReinH> koz_: happens to me, and probably most people, all the time
17:02:43 <koz_> ReinH: Yeah - we use computers for a reason. *They* don't have these issues.
17:03:52 <koz_> I guess I should have seen it coming when I replaced breakfast with Haskell hacking. :P
17:03:57 <MarcelineVQ> Is there a way to have a line in my code like `testValue = "blah "blah" bloo "bleh" "` and have it taken literally so I don't have to escape every " ?
17:04:40 <dmwit> MarcelineVQ: testValue = readFile "fileWithBlahBlahBlooBlehInIt" ;-)
17:04:45 <MarcelineVQ> :>
17:05:01 <glguy> MarcelineVQ: The only alternative that somes to mind is using a quasiquoter for string literals
17:05:15 <glguy> then instead you'll have to avoid |] in your string literal
17:05:52 <dmwit> MarcelineVQ: You could write `testValue = read "\"blah \\\"blah\\\" bloo \\\"bleh\\\" \""` so that you get to take advantage of Haskell's fine double-escaping mechanic.
17:05:53 <MarcelineVQ> Oh that's right I've seen that once before hmm
17:06:20 <dmwit> But yeah, QQ is probably about the best. I think there's a here-doc QQ on Hackage already.
17:06:44 <dmwit> http://hackage.haskell.org/package/heredoc-0.2.0.0/docs/Text-Heredoc.html
17:06:59 <MarcelineVQ> ah interesting
17:12:57 <mgsloan> If you want a really direct "everything in the quasiquote is in the string", something like (QuasiQuoter (return . LitE . StringL) undefined undefined undefined) works
17:14:20 <dmwit> mgsloan: `here` is essentially that, but with better error messages than what `undefined` would give you.
17:15:20 <dmwit> mgsloan: It also handles a subtlety that might escape you: it adds `toUnix` at the end of the composition chain...
17:16:12 <mgsloan> dmwit: Ah gotcha, cool
17:16:37 <mgsloan> That is indeed a subtlety that I'd not considered as I rarely use windows
17:17:02 <mgsloan> One issue with string quasiquoters is that you need to be able to escape |]
17:19:03 <jle`> had a bug i was trying to hunt down yesterday where the problem was that i put (x - 1) instead of (x + 1)
17:19:23 <jle`> should have added more type safety ;_;
17:19:54 <jle`> my initial reaction was, "why have you forsaken me, type system? :(", but i realized that the problem was only with my own self
17:20:00 <jle`> it is i that have betrayed it.
17:22:40 <joe9> need some advice, please? I have xmonad-contrib installed from the repo :  http://codepad.org/tG4cBnj2 , When I try to install my package which is dependent on that xmonad-contrib:  http://codepad.org/qoGtowoy . I do not understand why cabal is trying to use the 0.11.3 version of xmonad-contrib. My package .cabal file is:  https://gist.github.com/9ef8634ee0657da16956 .
17:24:01 <dmwit> joe9: You can ask it why with `cabal install --constraint xmonad-contrib==0.12`.
17:25:23 <dmwit> There is also an #xmonad, by the way, though your question so far is perfectly on-topic here.
17:29:24 <joe9> dmwit: ok, Thanks.
18:01:23 <castlelore> which is better, ghc or hugs
18:02:34 <mniip> ghc is more widely used
18:03:53 <geekosaur> hugs has been more or less unmaintained since 2006 (someone occasionally patches it just enough that it still compiles)
18:04:34 <lamefun> Can I somehow make functions that are both type-level and value-level?
18:04:37 <glguy> It's smaller than GHC and has better support for functional dependencies, but that's about it
18:05:23 <castlelore> ty
18:07:07 <rxv1> arg writing python is painful now...
18:08:37 <glguy> Do you have a splinter in your finger??
18:19:25 <dmwit> `Enum` is disgusting.
18:20:13 <dmwit> lamefun: Not with the same source text representing both functions, no.
18:20:43 <dmwit> But perhaps in the not-too-distant-future DataKinds will do something like this.
18:25:27 <mac10688> I thought stack template simple came with test folder too
18:25:30 <mac10688> did that change?
18:26:23 <mgsloan> Still the case for the default template
18:27:20 <mac10688> ah ok, stack new new-template
18:27:20 <lamefun> Is there a scripting language for Haskell like Lua, but one that's itself Haskell-like (pure, statically typed, etc.)?
18:27:22 <mac10688> weird name
18:27:36 <mgsloan> Howso?
18:28:05 <mac10688> Does this count?
18:28:06 <mac10688> https://hackage.haskell.org/package/turtle
18:28:33 <dmwit> lamefun: Well, there's Haskell.
18:28:51 <lingxiao> heyall
18:28:52 <zomg> There's also PureScript and Elm which are somewhat Haskell-like but they compile to JavaScript :)
18:28:54 <dmwit> See e.g. dyre in one direction or hint/mueval in another.
18:29:00 <lingxiao> is there a MonadRVar defined
18:29:03 <julianleviston> I’m trying to write an instance of Aeson’s FromJSON for Map Integer Node but not having much success. Can anyone give me some pointers?
18:29:04 <julianleviston> I *think* I’ve worked out an instance of ToJSON (not entirely sure though it seems to compile fine): toJSON kvs = Aeson.toJSON $ M.mapKeys show kvs
18:29:05 <lingxiao> ala MonadState s m
18:30:19 <Axman6> julianleviston: you almost certainly don't want an instance for Map Integer Node, but probably a newtype which wraps that type.
18:32:21 <julianleviston> lamefun: isn’t “scripting language” semi-orthoganal to “compiled” ?
18:32:21 <julianleviston> Axman6: ah I was hoping that wouldn’t be the case… but… my actual code uses a Map Integer Node… so do I have to change all my code then? or do I just need to write a shim?
18:32:30 <julianleviston> Axman6: I actually don’t know what “a shim” would be. hm
18:32:35 <julianleviston> Axman6:  that’s a bit crappy.
18:32:39 <lamefun> julianleviston, why can't scripting language be compiled?
18:33:05 <julianleviston> lamefun: It depends what you mean by scripting language, but usually they’re interpreted because it’s faster to run.
18:34:20 <lamefun> julianleviston, by scripting language I mean a language that can be embedded into the host program (ideally sandboxed) and then used by users to add features, etc.
18:35:24 <lamefun> "interpreted faster to run"?
18:35:30 <julianleviston> lamefun: though I think I’m wrong, so YMMV
18:35:30 <julianleviston> Axman6: what does a newtype offer me that the standard instance doesn’t? I don’t really understand Aeson terribly well.
18:35:30 <julianleviston> Axman6:  “standard instance” = “direct”, sorry.
18:36:00 <julianleviston> lamefun: a compiler usually has to compile everything before it starts (that’s the definition of compiler, usually), so it’s slower to start up…
18:37:31 <lamefun> Even Lua compiles to byte code...
18:38:06 <mgsloan> For programs which don't do much heavy lifting, "ghci" tends to be much faster than compiling + running
18:38:27 <julianleviston> lamefun: an interpreter, on the other hand, can start right away, but (usually) doesn’t check for errors until it encounters them (because it can’t… it’s doing it piece by piece), and so it can have some pretty catastrophic errors that compilation can check for in advance.
18:38:28 <julianleviston> lamefun: there have been some attempts at using Haskell for scripting, but the start up time is one of the prohibitive factors.
18:38:28 <julianleviston> lamefun: (usually) with scripting, start time is more important than ongoing speed.
18:38:30 <julianleviston> lamefun: which is why I was wondering (a little) what *you* meant by scripting.
18:39:33 <Axman6> julianleviston: if you make an instance for Map Integer Node then no one else can make an instance for  (ToJSON a, ToJSON b) => Map a b without there being overlaps
18:40:51 <lamefun> Most Haskell compilation time comes from type checking, not from optimizations?
18:41:49 <julianleviston> lamefun: yeah, I was very careful to say “mostly” and “often” a lot, you might have noticed… and… YMMV. There are many counter-cases, but these are the generalities.
18:41:49 <julianleviston> Axman6: ah. Excellent explanation.
18:41:49 <julianleviston> Axman6:  thanks. I didn’t not know that.
18:43:14 <mgsloan> One nice thing about using GHCi for scripting is that you'll used the compiled dependencies, so you only pay the performance hit of interpretation for your own code
18:44:40 <beekeeper> I'm a bit confused by "learn you a haskell" when it talks about non-deterministic functions and values. they are just lists and stuff. what's non-deterministic about it :-,
18:44:41 <julianleviston> Axman6:  ok… but the other part of the problem is that I am assuming the Map Integer Node will end up being a JS array with objects in it? How do I do k, v pairs within that? or am I better off doing it in the same way tuples are handled? I just don’t really know how to approach that. Anyway for now, I’ll refactor to use a newtype (I already use a type alias anyway, so I probably should have done that from the 
18:44:41 <julianleviston> beginning). 
18:44:41 <julianleviston> Axman6:  I’ve read the tutorial and the aeson docs, but I don’t really understand the examples about tuples very well.
18:44:41 <julianleviston> Axman6:  this tutorial BTW: http://artyom.me/aeson#fromjson-instances-for-other-types
18:45:44 <mgsloan> Code generation + optimization definitely heavily outweigh parsing + typechecking.  For me, a project that takes minutes to compile can load up into ghci in ten or twenty seconds
18:47:49 <julianleviston> beekeeper:  a list is non-determinstic
18:47:49 <julianleviston> beekeeper: it means code can’t know in advance how big it is / what shape it is
18:47:49 <julianleviston> beekeeper:  contrast to a tuple, which can only be a certain size.
18:47:49 <julianleviston> beekeeper: and in fact, it’s possible to have an infinite list, as you probably already know.
18:48:35 <beekeeper> oh I see :-,
18:50:44 <Axman6> beekeeper: it's the fact that lists don't represent a single answer, but 0 or more potential answers
18:51:10 <julianleviston> beekeeper: assuming I understand determinism properly, a *particular* list might be deterministic, but “any list” might not.
18:51:35 <julianleviston> beekeeper: therefore (because it “might not”) it can’t be deterministic.
18:51:41 <beekeeper> yeah I usually thing of the particular data as being deterministic or not, rather than the data structure
18:52:03 <Axman6> so we could have sqrt :: Floating a => a -> [a] which would return [] is the value is negative, or for example, [-2,2] when given 4
18:53:48 <ElMoloko> how do i import a function directly from c? say i wanted to import printf from <stdio.h>, would i do import foreign ccall "printf" c_printf :: CString -> IO ()?  what would I need to do when building?
18:53:51 <julianleviston> beekeeper:  but you can have a function that pattern matches on a certain list size, and it will work out deterministically just fine.
18:53:51 <julianleviston> beekeeper: cool… so [1,2] could be determined easily, but [1..] could not. Right?
18:53:51 <julianleviston> beekeeper: therefore, the shape of lists is such that they are non-deterministic (taken as an entirity). Please don’t take my word for this, though, but rather investigate the truth for yourself. I am no doubt incorrect in many cases.
18:54:17 <codehero> does find work on infinite lists?
18:54:18 <julianleviston> ElMoloko: https://wiki.haskell.org/FFI_Introduction
18:54:22 <codehero> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#find
18:54:36 <julianleviston> codehero: you can try this.
18:54:48 <ElMoloko> I've read that :P i'm having trouble with importing a c function without importing it from a file in the same directory
18:54:52 <codehero> oh. right
18:54:59 <codehero> i just need to test it
18:55:18 <codehero> oh. it works
18:55:19 <codehero> thanks
19:01:36 <acertain> ollef, why doesn't optional a in Earley return [Just a, Nothing]?
19:02:16 <submain> Hello, on http://lpaste.net/7088094995147653120, what is the type of inputId? I thought it was Prism' Graph (Maybe Input), but ghc doesn't like that.
19:02:26 <submain> sorry, type of inputById
19:03:15 <Axman6> Prism' Graph Input?
19:04:01 <submain> hmm, ghc doesn't like that either
19:04:16 <Axman6> the type suggests it's a Traversal really
19:04:51 <submain> wow, that worked. Traversal' Graph Input
19:05:13 <submain> Thanks! Why is that though? The "at" makes it a traversal?
19:19:22 <lingxiao> hey all
19:19:27 <julianleviston> hi
19:19:34 <lingxiao> I'm looking at Data.Random
19:19:53 <lingxiao> and I noticed there is no way to run an RVar so that we get a pure value
19:20:09 <lingxiao> ie :t runState
19:20:23 <lingxiao> is it because to get randomness we're doing some IO?
19:20:33 <lingxiao> :t runState
19:20:35 <lambdabot> State s a -> s -> (a, s)
19:20:42 <koz_> Is this an OK way to write this function, or is there a nicer/more Haskelly one? http://paste.rel4tion.org/161
19:20:45 <julianleviston> lingxiao: something like that.
19:21:44 * hackagebot sbv 5.6 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.6 (LeventErkok)
19:23:46 <lingxiao> ok thanks
19:25:40 <julianleviston> lingxiao: this is a not bad starter: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/randoms
19:25:55 <lingxiao> thanks!
19:26:00 <lingxiao> funny enough I'm reading that right now
19:26:02 <lingxiao> :)
19:26:52 <julianleviston> lingxiao: :) good. There are a number of good resources explaining what random actually means around. Most good Haskell books do so, such as www.haskellbook.com
19:27:14 <julianleviston> oh wait I actually think that one doesn't.
19:27:45 <lingxiao> haha all good fp looks good so far!
19:27:53 <julianleviston> thought it did. Oh well… RWH does
19:27:56 <julianleviston> sweet.
19:29:54 <lingxiao> what confuses me is this:
19:35:43 <lingxiao> http://lpaste.net/146617
19:36:02 <lingxiao> why do I need to runRVar in foo if I've already runRVar in tos'
19:36:16 <lingxiao> where does the StdRandom in testFoo get used?
19:37:04 <lingxiao> It makes sense from a type signature perspective, both foo and bar have the same signature
19:41:45 * hackagebot sbvPlugin 0.1 - Analyze Haskell expressions using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.1 (LeventErkok)
19:42:21 <hodapp> analyzing Haskell expressions using SBV? Hmm....
19:43:01 <hodapp> that looks pretty slick.
19:44:23 <julianleviston> hodapp: what’s SBV?
19:45:15 <Adeon> I think it's just SMT-Based Verification
19:45:40 <Adeon> I googled the site and that actually does look pretty nifty if it can be relatively seamless and compiled away when you don't want to verify
19:45:48 <hodapp> julianleviston: just click the dependency 'sbv' in that hackage page the bot just linked; their docs do a better job with it than I could
19:45:48 <Adeon> https://leventerkok.github.io/sbv/
19:46:23 <julianleviston> cool
19:46:43 <hodapp> I would like to learn SBV when I get a chance to, because for one thing their docs always seem top-notch
19:46:46 <broma0> how can i get rid of the annoying left recursion in this parser (its REALLY simple) : http://lpaste.net/146619
19:48:34 <lingxiao> does someone know a bit about System.Random care to look at this bit of code?
19:48:40 <lingxiao> http://lpaste.net/146617
19:54:46 <verement> broma0: use chainl1?
19:55:54 <broma0> verement: hmmm.. trying to figure out how
19:56:04 <julianleviston> If I have this: Schema.ContentMap $ M.union (Schema.getContentMap contentMap2) (Schema.getContentMap contentMap)
19:56:08 <julianleviston> then isn’t this equivalent? Applic.liftA2 M.union $ contentMap2 contentMap
19:56:13 <julianleviston> GHC says no.
19:57:02 <broma0> verement: im using attoparsec, is that a parsec thing?
19:57:16 <Clint> it's like parsec but better
19:57:58 <broma0> Clint: i was asking about chainl1, can't find it in atto
19:58:49 <verement> broma0: hmm, I suppose it is
19:59:28 <broma0> verement: theres some term/factor thing i can use to get my parser to work.. but i can't figure out how it works! gah
19:59:28 <julianleviston> ohhhh my newtype would need a functor instance. guh. ok
19:59:34 <julianleviston> sorry an applicative instance.
20:04:24 <verement> broma0: the chainl1 documentation (and source code) may still help you
20:04:39 <verement> from parsec, that is
20:05:24 <verement> it's under Text.Parsec.Combinator
20:08:09 <julianleviston> Is there a way to lift a function of two arguments to take two newtype-wrapped arguments instead?
20:08:52 <julianleviston> I keep thinking it’s liftA2, but it doesn’t work because the newtypes are not applicative instances… hm… 
20:09:07 <verement> julianleviston: func `on` unwrap ?
20:09:24 <julianleviston> `on` from…. lens?
20:09:30 <verement> from Data.Function
20:09:32 <MarcelineVQ> from data.function
20:09:35 <KaneTW> :t on
20:09:37 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:09:39 <julianleviston> hmm
20:09:47 <julianleviston> :t unwrap
20:09:55 <julianleviston> what is func?
20:09:56 <lambdabot> Not in scope: ‘unwrap’
20:10:01 <julianleviston> is that the function I’m talking about?
20:10:17 <verement> func is the function that takes unwrapped arguments
20:10:26 <KaneTW> func is your function, unwrap is the function that unwraps  then newtype
20:10:30 <verement> unwrap is the accessor to unwrap your newtype
20:10:35 <julianleviston> but I’d have to unwrap both newtypes
20:10:42 <julianleviston> I was already doing that manually. 
20:10:44 <julianleviston> Which was fine.
20:11:06 <julianleviston> I just thought there might be a function that wrapped another function’s arguments as the newtype.
20:11:27 <julianleviston> to make it read a little cleaner. Doesn’t sound like there is.
20:11:30 <verement> julianleviston: you asked if there was a way to lift a function to take newtype-wrapped arguments
20:11:41 <verement> I offered a solution that does just that
20:11:44 <julianleviston> verement: yeah but that doesn’t do that. Does it? It does the opporite.
20:11:46 <KaneTW> ?let pplus f = f `on` getProduct
20:11:47 <julianleviston> opposite*
20:11:49 <lambdabot>  Defined.
20:11:56 <KaneTW> eh
20:11:59 <KaneTW> ?undef
20:11:59 <lambdabot> Undefined.
20:12:02 <julianleviston> ohhh
20:12:06 <KaneTW> ?let pplus = (+) `on` getProduct
20:12:08 <lambdabot>  Defined.
20:12:22 <julianleviston> verement: sorry, I didn’t understand what you said *at all*.
20:12:26 <KaneTW> > (Product 5) `pplus` (Product 3)
20:12:28 <lambdabot>  8
20:12:33 <verement> julianleviston: sorry I was unclear
20:12:37 <julianleviston> KaneTW: Thank you so much!
20:12:47 <KaneTW> :t pplus
20:12:48 <lambdabot> Num c => Product c -> Product c -> c
20:12:48 <julianleviston> verement: thanks for being correct.
20:13:06 <KaneTW> note that with on, both your newtypes have to be the same type
20:13:18 <KaneTW> if you want different types
20:13:21 <KaneTW> :t liftA2
20:13:22 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:13:24 <julianleviston> KaneTW: they are. Exactly what I was after, I just didn’t understand verement 
20:13:28 <KaneTW> ah ok
20:13:58 <julianleviston> Data.Function here we come. Thanks :)
20:20:41 <julianleviston> :t pplus
20:20:43 <lambdabot> Num c => Product c -> Product c -> c
20:20:51 <julianleviston> ah… 
20:21:07 <julianleviston> I want to keep the answer wrapped though
20:21:47 <julianleviston> I really do just want to lift a function to work inside a structure.
20:21:54 <julianleviston> :t wrap
20:21:56 <lambdabot> Not in scope: ‘wrap’
20:23:05 <julianleviston> I thought that was just called lifting
20:24:17 <julianleviston> liftA requires applicative though
20:24:24 <julianleviston> so does liftA2
20:24:53 <julianleviston> stuff it this is too much trouble
20:25:37 <KaneTW> nah liftA2 won't work anyway
20:26:23 <julianleviston> I just ended up with this: Schema.ContentMap $ (Func.on M.union Schema.getContentMap) contentMap2 contentMap
20:26:26 <julianleviston> lol
20:31:28 <MarcelineVQ> a tough read, consider somethimes just importing the functions you want instead of full qualification: `import Data.Function (on)` for example
20:34:31 <julianleviston> MarcelineVQ: I have considered that. I don’t like it.
20:35:10 <julianleviston> The reason is when I come to move a piece of code, qualification makes it easy to see what addidional imports I need in that new place.
20:35:43 <KaneTW> haskell emacs modes (and probably vim, too) do a lot of that automatically
20:35:50 <julianleviston> The length of qualification names is directly proportionate to how much I use that name in the module.
20:36:05 <julianleviston> I’m not using an editor to write this code.
20:36:13 <verement> inversely proportional, I hope
20:36:30 <lingxiao> hey all
20:36:35 <lingxiao> I posted the qeustion on SO
20:36:35 <lingxiao> http://stackoverflow.com/questions/34126505/usage-of-runrvar
20:36:38 <julianleviston> verement: yes. 
20:36:40 <MarcelineVQ> Whatever works for you, just wanted to mention the option and let you know that it not great for readability
20:36:41 <lingxiao> please take a look if possible :D
20:36:53 <julianleviston> MarcelineVQ: thanks :) I’m really aware of it.
20:37:39 <julianleviston> MarcelineVQ: I actually don’t think that matters in that context. Having Schema. and M. and Func. three times is a small amount of noise for the win.
20:40:37 <julianleviston> How can I refactor this (possibly) to point-free? contentMapUnion x y = Schema.ContentMap ((Func.on M.union Schema.getContentMap) x y)
20:41:24 <julianleviston> I can’t rememeber the lovely point-free lambdabot thang.
20:41:40 <MarcelineVQ> ​@pl and @unpl
20:42:02 <julianleviston> @pl (+)
20:42:02 <lambdabot> (+)
20:42:24 <nitrix> That's already point free :P
20:42:53 <julianleviston> tis
20:42:54 <julianleviston> contentMapUnion = (Schema.ContentMap .) . Func.on M.union Schema.getContentMap
20:42:55 <julianleviston> ok
20:42:58 <julianleviston> dang. :)
20:43:06 <nitrix> @pl \x y -> x y
20:43:06 <lambdabot> id
20:55:16 <julianleviston> So how would I go about writing instances for Aeson ToJSON and FromJSON for my newtype (which wraps a Map Integer Node)
20:55:33 <julianleviston> (Assuming Node’s FromJSON and ToJSON are defined, which they are).
20:55:54 <julianleviston> It’s the map that’s bogging me down. I don’t really understand how to write an instance for it.
20:56:51 <julianleviston> I could serialise it as a list of “pairs” I suppose (objects with “a” and “b” keys)
20:57:07 <julianleviston> but I have no idea about how to do the list either. lol
20:59:07 <nitrix> The function Map.toList takes care of most of the work.
20:59:19 <opqdonut> and fromList for the other direction :)
20:59:34 <julianleviston> yeah, but my map has Integer keys, which haven’t got an instance defined.
21:00:02 <julianleviston> otherwise it’d be simple.
21:00:57 <julianleviston> meaning Aeson has no default instance for Map a b where a is anything other than String or Text
21:00:58 <nitrix> You can show an integer.
21:01:04 <julianleviston> yeah
21:01:20 <julianleviston> This is my current ToJSON instance: toJSON (ContentMap kvs) = Aeson.toJSON $ M.mapKeys show kvs
21:01:30 <julianleviston> But going the other way around I have no idea how to do that.
21:01:45 <julianleviston> I got this far… parseJSON = withObject "content-map" $ \o -> do
21:02:05 <julianleviston> but I don’t really know what context that block is in.
21:02:09 <julianleviston> that do block
21:02:36 <julianleviston> is that liable to be an array context, or the object context? I’m guessing object because I’m using withObject
21:02:39 <nitrix> ContentMap is your newtype?
21:02:46 <julianleviston> but then how do I get to an array context
21:02:49 <julianleviston> yeah :)
21:02:59 <julianleviston> newtype ContentMap = ContentMap { getContentMap :: M.Map Integer Node }
21:03:04 <nitrix> :t Aeson.toJSON
21:03:05 <lambdabot> Not in scope: ‘Aeson.toJSON’
21:03:09 <nitrix> :t toJSON
21:03:11 <lambdabot> Not in scope: ‘toJSON’
21:03:25 <julianleviston> Aeson.toJSON :: Aeson.ToJSON a => a -> Aeson.Value
21:03:30 <julianleviston> If that helps.
21:04:12 <nitrix> I see. You're supposed to contruct the structure.
21:04:36 <julianleviston> yeah.
21:05:02 <julianleviston> I should probably wrap that in object [] actually
21:05:26 <nitrix> I suggest you do not try to do anything fancy. Just encode it as an Object.
21:05:28 <julianleviston> to make sure it encodes the object properly.
21:05:43 <nitrix> type Object = Map Text Value
21:05:45 <julianleviston> nitrix: I don’t know what that means, or how to do anything fancy
21:05:51 <nitrix> So, you'd have to turn the Integer into a Text.
21:05:52 <julianleviston> nitrix: that’s a bad idea
21:06:26 <julianleviston> I already had a discussion with someone before about how NOT having a newtype means you subsube the entire map type for future, which is *bad*
21:06:33 <julianleviston> subsume*
21:06:36 <nitrix> And the Node into a Value... which is up to you. What's the best way to represent a Node? String?
21:06:55 <julianleviston> Node is alerady handled. 
21:07:07 <julianleviston> I can just toJSON on it.
21:07:12 <julianleviston> I think.
21:07:19 <julianleviston> The problem is I don’t know how to do anything
21:08:50 <nitrix> Do you know about type holes?
21:08:53 <nitrix> typed holes*
21:09:09 <julianleviston> Yeah, I’m familiar, but I’m not in a GHCi context.
21:09:59 <MarcelineVQ> compiling will tell you the holes too, it's really nice when you have something like ghc-mod tell you them while coding though
21:10:19 <MarcelineVQ> have a look here if you haven't already http://artyom.me/aeson
21:10:23 <julianleviston> I’m not actually in an editor context
21:10:29 <julianleviston> MarcelineVQ: that’s what I’m working off
21:11:05 <julianleviston> I think I could *get* into a GHCi / editor context without *too* much trouble.
21:12:33 <julianleviston> The piece I’m missing, I think, is how to encode / decode a list, because while I can probably pretty easily encode Integer as string, decoding it I have no idea about.
21:13:08 <julianleviston> Like… do I do parseJSON = withObject or withArray ?
21:13:45 <julianleviston> what if I want to do a withObject to get the named object context out and then a withArray to get each kv out? then how do I put it back into a ContentMap or even just a straight up map?
21:13:47 <julianleviston> I’m really lost
21:14:28 <julianleviston> also I don’t *really* know what FromJSON and ToJSON *do*… so I’m pretty much just writing my code as from that tutorial - just a great big copy-pasta sandwich. Yay.
21:14:59 <julianleviston> using all the magic functions without understanding how they work. I suppose I should do a deep dive into Aeson’s internals to try to work out what it’s expecting.
21:15:06 <julianleviston> Which will probably take at least a few days.
21:18:06 <julianleviston> anyway I’ll give some version of the parseArray example a shot.
21:20:38 <AfC> julianleviston: ToJSON and FromJSON are typeclasses. That means they have methods (sic) which must be implemented by any type for which there is an instance of that typeclass. So if the type you're trying to decode JSON to / encode to JSON from  from has instances for those two typeclasses, it means, that you can use Aeson to get you objects of your type if you feed in JSON, and vice-versa
21:20:57 <julianleviston> AfC: Yes. I know.
21:21:33 <KaneTW> more specifically, the FromJSON methods have a default implementation requiring a Generic instance
21:21:57 <julianleviston> I’m not sure what that means, or how that helps me, but thanks. 
21:22:31 <KaneTW> it's some of the magic behind it
21:26:34 <Axman6> julianleviston: Why are you using a Map Integer Node anyway? at the very least I would've though an IntMap Node would be better?
21:26:59 <julianleviston> Axman6: I’m not sure how.
21:27:19 <julianleviston> Axman6:  I’m using it because I wanted a map of Integer values to Nodes.
21:27:39 <Axman6> that's what IntMap is designed to do. Are you sure you need to use Integers and not Ints?
21:27:51 <julianleviston> Axman6: I don’t mind either way.
21:28:01 <julianleviston> Axman6: all my things are already typed as Integer
21:28:07 <julianleviston> Axman6:  can you give me a good reason to change?
21:28:28 <arkeet> what's wrong with Map Integer?
21:29:46 <julianleviston> I’m assuming he’s wanting me to use Int because it’s smaller.
21:29:46 <Axman6> it just feels odd, particularly since julianleviston seemed to imply that it could be turned into a JSON array, meaning that it has all numbers 0-n as keys
21:30:12 <julianleviston> Axman6: IntMap doesn’t have an Aeson instance either, does it?
21:30:34 <Axman6> not sure
21:30:50 <julianleviston> Axman6: the main problem is that Map k v where k isn’t Text or String hasn’t got an instance, so I’d have to write it myself, which I don’t know how to do.
21:31:33 <Axman6> right. shouldn't be too hard though. are you guaranteed to have the values 0-n as keys? what sorts of properties does the map have here?
21:31:46 <julianleviston> I don’t know how to answer that
21:31:54 <Axman6> what does this map do
21:31:57 <Axman6> what is it for
21:31:57 <julianleviston> In which context? The JSON context or the data context?
21:32:01 <julianleviston> what does that mean?
21:32:03 <Axman6> the data context
21:32:04 <julianleviston> It’s a Map.
21:32:14 <julianleviston> It doesn’t DO anything does it?
21:32:16 <Axman6> and what are you using it for
21:32:19 <julianleviston> Sorry I’m a little confused
21:32:27 <Axman6> what does it represent
21:32:28 <julianleviston> To hold Node data associated to Integers
21:32:30 <julianleviston> Nodes
21:32:37 <Axman6> and what are Nodes
21:32:40 <julianleviston> Why?
21:32:54 <julianleviston> i’ll tell you but it’s irrelevant
21:32:59 <Axman6> so I have a better idea of what you're actually trying to do...
21:33:14 <julianleviston> Node is a sum type of IntegerNode, StringNode, ParamNode, TemplateNode, BoundTemplateNode, ListNode
21:33:40 <julianleviston> their instances are taken care of, tohugh.
21:33:41 <julianleviston> though*
21:33:46 <Axman6> the obvious implementation is to turn the Integers into strings using show, and build a json map with the integer-as-strings as keys
21:33:55 <julianleviston> yes, I agree
21:34:10 <julianleviston> however, I don’t know how to do that
21:34:33 <julianleviston> and also, I don’t think that’s a good idea to do WITHOUT a newtype, because it will subsume all map types in the future (which I don’t want to do)
21:34:49 <julianleviston> due to the way Aeson generics are handled, I’m told
21:35:03 <Axman6> object $ map (\(k,v) -> (show k .= show v)) . toList $ mymap
21:35:15 <Axman6> yes, agreed
21:35:40 <julianleviston> as I’ve said a number of times, to toJSON isn’t hard and I can do that.
21:35:41 <Axman6> so, you'd have" toJSON (MyMap mymap) = object . map (\(k,v) -> (show k .= show v)) . toList $ mymap
21:35:43 <julianleviston> it’s the fromJSON that is the problem
21:35:49 <Axman6> ah right
21:35:55 <Axman6> sorry, haven't been following along
21:35:58 <julianleviston> yeah I used fmap show instead, but bsically
21:36:52 <julianleviston> and I don’t really want to do it like that because it will subsume all future uses of map
21:37:07 <julianleviston> so I’d like to encode it within an object, I think.
21:37:10 <Axman6> no it won't, the MyMap above was the newtype
21:37:22 <julianleviston> yeah but you’re shucking the structure and not encoding it, right...
21:37:23 <Axman6> data MyMap = MyMAp (Map Integer Node)
21:37:32 <julianleviston> yep.
21:37:44 <Axman6> ok, so the decode becomes:
21:37:49 <julianleviston> hang on tho
21:38:14 <julianleviston> if you don’t encode a (js) object wrapping that, it will be synonymous with all other map types in the future, no?
21:39:59 <julianleviston> which brings me back full circle.
21:40:18 <julianleviston> I don’t know what object does. I don’t know how to encode an object wrappering a list. 
21:40:27 <Axman6> sure, but I don't really see that as a problem. you can wrap it in an object which tells you you've got a MyMap if you like, but I don't see that as being completely necessary
21:41:02 <julianleviston> Well, if I have a sum type in the future that has one of two possible of these newtype-wrapped map types, it’ll be a problem because it won’t know which is which.
21:41:18 <julianleviston> (when parsing)
21:41:44 <julianleviston> Thanks for helping me so much by the way.
21:41:55 <Axman6> you can definitely do: toJSON (MyMap mymap) = object ["MyMap: .= (object . map (\(k,v) -> (show k .= show v)) . toList $ mymap) if you want
21:42:08 <julianleviston> oh. ok :)
21:42:18 <julianleviston> It’s so simple when you know everything to do.
21:42:20 <Axman6> there's a ] there too :P
21:42:20 <julianleviston> (as always)
21:42:28 <julianleviston> yeah, I can figure syntax.
21:42:31 <Axman6> let me write out some stuff, give me a min or two
21:42:37 <julianleviston> It was mostly not knowing that I could embed object within object
21:42:39 <julianleviston> ok
21:43:04 <julianleviston> show v is a bad idea in my context. I think toJSON v is better.
21:43:07 <julianleviston> but all good
21:43:44 <Axman6> sure, we can do that too
21:47:58 <julianleviston> So I think this would be it…. toJSON (ContentMap contentMap) = object [(T.pack "content-map") .= (object . map (\(k,v) -> (show k .= Aeson.toJSON v)) . toList $ contentMap)]
21:48:20 <Walpurgisnacht> What you doing Julian?
21:48:22 <Axman6> yep
21:48:23 <julianleviston> I don’t know if I would have ever got there by myself
21:48:30 <julianleviston> Axman6:  thank you
21:48:57 <julianleviston> Walpurgisnacht: writing a toJSON and fromJSON instance for a newtype that wraps a Map Integer Node (where node is a sumtype)
21:49:17 <Walpurgisnacht> Ah 
21:49:20 <Walpurgisnacht> sounds neat
21:49:28 <julianleviston> Walpurgisnacht: it’s a pain in the butt :)
21:49:44 <Walpurgisnacht> What was your trouble?
21:50:06 <julianleviston> Walpurgisnacht: is this curiosity, or are you a massive legend at Aeson?
21:50:26 <julianleviston> Walpurgisnacht: because Axman6  is helping me at the moment…
21:51:13 <julianleviston> Walpurgisnacht: but, to sum up, I don’t understand Aeson encode/decode enough to undertand how to encode and decode a Map Integer type within a newtype, specifically the fromJSON side.
21:51:21 <Walpurgisnacht> Curiosity
21:51:44 <Walpurgisnacht> yeah its always been a pain for me as well
21:52:46 <julianleviston> I know Aeson enough to do most vanilla stuff no worries. Even some slightly complicated things (like sum types), but this Map thing I got really lost on because of not knowing that you can embed object, or how to parse array wrapped objects.
21:53:57 <Axman6> julianleviston: http://lpaste.net/146623 I _think_ that will work
21:54:06 <Axman6> uh, needs a T.pack on the key
21:56:16 <Axman6> toList comes from Data.HashMap.(Lazy|Strict)
21:56:28 <Axman6> oh, uh, other problems
21:57:03 <julianleviston> Axman6:  haha I can do these things it’s cool
21:57:10 <julianleviston> Axman6:  ok so I got to toJSON instance working
21:57:32 <Axman6> yeah... need to turn it into fromJSON = ..., not fromJSON (Object v) = ...
21:57:39 <julianleviston> Axman6:  excuse my convoluted qualified imports (you’ll hate it):  toJSON (ContentMap contentMap) = Aeson.object [(T.pack "content-map") Aeson..= (Aeson.object . map (\(k,v) -> ((T.pack $ show k) Aeson..= Aeson.toJSON v)) . M.toList $ contentMap)]
21:57:44 <Axman6> changed my mind half way through writing it =)
21:58:04 <Axman6> yep, looks good
21:58:11 <julianleviston> it compiled :) I was very happy
21:58:15 * julianleviston hugs Axman6 
21:58:25 <julianleviston> Ok now I’ll look at your pastie. Thanks
21:59:40 <julianleviston> what is empty? shouldn’t it be fail?
21:59:56 <julianleviston> or are they equivalent?
22:00:09 <Axman6> "prpbably"
22:00:12 <Axman6> probably*
22:00:13 <julianleviston> haha ok.
22:00:19 <julianleviston> :t empty
22:00:21 <lambdabot> Alternative f => f a
22:00:22 <julianleviston> where is empty from?
22:00:23 <julianleviston> ah
22:00:29 <MarcelineVQ> :t mzero
22:00:29 <Axman6> fail would be better
22:00:31 <julianleviston> Control.Monad ?
22:00:35 <lambdabot> MonadPlus m => m a
22:00:56 <julianleviston> :t fail
22:00:58 <lambdabot> Monad m => String -> m a
22:01:22 <julianleviston> :t reads
22:01:23 <lambdabot> Read a => ReadS a
22:01:35 <Axman6> @info Reads
22:01:36 <lambdabot> Reads
22:01:42 <Axman6> @src ReadS
22:01:43 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:01:45 <Axman6> bleh
22:01:57 <julianleviston> all goog. I’ll hoogle it again later. I’m familiar, but not overly.
22:02:25 <Axman6> new version, which is more likely to work: http://lpaste.net/146623
22:04:18 <julianleviston> Axman6:  how does this match work? [(n,"")]
22:05:34 <julianleviston> Axman6:  like… the bit case reads kstr of [(n, “”)] ?
22:06:11 <julianleviston> Ohhh it’s the type of reads
22:06:12 <julianleviston> :t reads
22:06:13 <lambdabot> Read a => ReadS a
22:06:13 <julianleviston> right.
22:06:30 <julianleviston> it reads a portion and returns a list of tuples of read tokens?
22:06:33 <julianleviston> and remainders?
22:06:40 <julianleviston> nice. ok.
22:06:56 <MarcelineVQ> > reads "12345dfsfsd123" :: [(Int, String)]
22:06:59 <lambdabot>  [(12345,"dfsfsd123")]
22:07:22 <MarcelineVQ> > reads "dfsfsd123" :: [(Int, String)]
22:07:24 <lambdabot>  []
22:10:22 <julianleviston> Axman6: Mmmm the parseJSON isn’t compiling
22:11:19 <julianleviston> Couldn't match expected type \8216aeson-0.8.0.2:Data.Aeson.Types.Internal.Parser ContentMap with actual type Aeson.Value  -> aeson-0.8.0.2:Data.Aeson.Types.Internal.Parser [(t0, t1)]    In the expression:   Aeson.withObject \"content-map\"
22:12:53 <julianleviston> Axman6:  is that because the Aeson.parseJSON v is lacking a return?
22:13:09 <julianleviston> Axman6:  oh, no… nvm
22:22:23 <lamefun> Is there a file system abstraction for Haskell (like GIO)?
22:42:09 <julianleviston> Axman6: I’m getting this error: Expected type: M.Map String Aeson.Value\n      Actual type: Aeson.Object\n    In the first argument of \8216M.toList\8217,
22:44:10 <julianleviston> Hm. I was using Data.Map instead of Data.HashMap.Strict. Will try latter.
22:49:38 <lpaste> JulianLeviston pasted “fromJSON not working” at http://lpaste.net/146626
22:50:05 <julianleviston> Axman6: still doesn’t work. Not sure what I’ve done… 
22:51:12 <lpaste> JulianLeviston revised “fromJSON not working”: “No title” at http://lpaste.net/146626
22:56:31 <julianleviston> sigh
22:57:11 <EvanR> julianleviston: IntMap ftw
22:57:18 <julianleviston> Huh?
22:57:24 <julianleviston> That wouldn’t change anything would it?
22:57:45 <EvanR> i only read you were talking about Data.Map vs HashMap
22:57:56 <julianleviston> Aeson uses HashMap
23:23:18 <Axman6> julianleviston: oops, forgot the last thing: http://lpaste.net/146623 
23:23:48 <julianleviston> oh haha that makes more senes!
23:24:02 <julianleviston> I was just looking at it trying to figure out what it meant
23:24:06 <julianleviston> I’ll try that now
23:24:35 <julianleviston> by the way it’s parseJSON not fromJSON
23:24:36 <julianleviston> I think
23:24:45 <Axman6> sure, whatevs :P
23:24:55 <Axman6> Like I said, haven't compiled this
23:27:17 <julianleviston> Axman6:  and were missing a do … but guess what yay it worked. woo :)
23:29:03 <julianleviston> Axman6: annotated with my working one. Thanks heaps! http://lpaste.net/146623
23:29:56 <julianleviston> I really wish I understood it more.
23:30:04 <Axman6> sweet =)
23:30:06 <Axman6> ha
23:30:18 <Axman6> spend some time looking at the types of all the functions
23:32:06 <julianleviston> I understand why yours works… the other non-working one was doing my head in… but yeah, should look up withObject a bit more, I guess… Aeson.Object is a synonym for HashMap String Value so I got that… so forM does a monadic iteration over the whole hashmap, and pulls out pairs that the block builds…so yeah, I see how it works.
23:32:27 <Axman6> it's just a convenience function, check out the docs
23:32:47 <Axman6> Object just a HashMap Text Value
23:32:49 <julianleviston> yep… I’ve looked it up. To wrapper a failable thing
23:32:51 <julianleviston> yep.
23:33:42 <julianleviston> tho I don’t know what monad the whole lot is within (the obj -> do part)
23:34:18 <julianleviston> and I don’t know why you need a return
23:34:32 <Axman6> hmmm, I'm not sure I have used withObject correctly now
23:34:41 <julianleviston> hehe :)
23:34:48 <Axman6> because a Parser is a monad
23:34:56 <julianleviston> yep
23:35:06 <Axman6> yeah I've used withObject wrong and the code won't work :P
23:35:10 <julianleviston> LOL
23:35:14 <julianleviston> aw :(
23:35:19 <julianleviston> so I should just NOT have a return?
23:35:24 <julianleviston> That should work then I’m pretty sure
23:35:44 <julianleviston> tho it confuses me as to why it actually worked at all.
23:35:51 <Axman6> nah you need the return 
23:36:02 <julianleviston> hm 
23:36:13 <Axman6> return is not return from other languages
23:36:16 <julianleviston> why don’t any of my other uses of withObject need return in their do blocks
23:36:24 <julianleviston> yeah I know what return does
23:38:21 <julianleviston> Axman6:  but I’ve wrtten a few of these parseJSON implementations before and I’ve never used return on the last value.
23:38:54 <Axman6> what have you usef? applicative functions like <$> and <*>?
23:39:00 <jg> hi all. I sometimes see equational proofs for haskell code. Is there some good resource that'd help me learn how to write those?
23:39:42 <julianleviston> Axman6: tho its type would suggest it’s within a Parser monad… so… yeah
23:39:43 <jg> from what i gather in such proofs i can substitute code and use some special induction
23:39:45 <julianleviston> Axman6:  Aeson.parseJSON :: Aeson.FromJSON a => Aeson.Value -> aeson-0.8.0.2:Data.Aeson.Types.Internal.Parser a
23:40:18 * bitemyapp ears perk up at Parser
23:40:22 <bitemyapp> oh Aeson
23:40:29 * bitemyapp rapidly loses interest and goes back into hibernation
23:40:49 <julianleviston> Axman6:  an example is: StringNode <$> o .: (T.pack “integer-node”)
23:40:57 <julianleviston> bitemyapp: lol soz :)
23:41:03 <julianleviston> Axman6:  so yeah… applicative style.
23:41:24 <julianleviston> Axman6:  I guess .: must do something magical… tho I’m not sure how that is wrapped in the Parser then
23:41:27 <Axman6> yeah you can't do that as easily in this situation where you don't know what the keys will be
23:42:02 <julianleviston> Axman6: ah, ok. So the case is just that I don’t really understand .: or what the applicative is doing there, rather than “not using a Parser” ok :)
23:42:14 <julianleviston> coz one is in Applicative, the other in Monad, I guess?
23:42:43 <bitemyapp> julianleviston: ¯\_(ツ)_/¯
23:43:02 <julianleviston> bitemyapp: I don’t know what that means.
23:43:12 <julianleviston> Axman6:  sweet… so then in that case, I don’t understand why the code you gave me is incorrect?
23:43:22 <bitemyapp> julianleviston: ┐(‘～`;)┌
23:43:43 <julianleviston> bitemyapp: you newfangled kids with your newfangled internets. 
23:43:47 <julianleviston> bitemyapp: :)
23:44:15 <julianleviston> bitemyapp: back in my day we only had ONE smiley.
23:47:17 <Axman6> julianleviston: it doesn't handle the wrapping object properly, the one with the "MyMap" key
23:47:44 <julianleviston> Axman6: um… Ohhh coz I wrapped it in its own object. 
23:47:46 <julianleviston> riiight
23:47:58 <julianleviston> so I should unwrap that first 
23:48:04 <Axman6> yeah, working on it
23:48:23 <julianleviston> oh wow you’re nice
23:49:00 <Axman6> http://lpaste.net/146623 the last snippet is an actually working implementation
23:50:12 <Axman6> (just updated it with a slightly better error message)
23:51:14 <julianleviston> that makes a lot of sense
23:51:47 <julianleviston> what does mp stand for?
23:51:57 <julianleviston> map-parse?
23:51:59 <Axman6> map
23:52:05 <julianleviston> oh ok
23:52:13 <Axman6> but that's already used everywhere :)
23:52:31 <Axman6> withObject would've been awkward to use there
23:56:01 <Axman6> and home time
23:57:12 <julianleviston> Axman6:  thanks! :)
23:57:37 <julianleviston> Axman6:  <3
