00:00:05 <jle`> then, zoom _1 :: State s a -> State (s, t) a
00:00:13 <jle`> zoom _2 :: State t a -> State (s, t) a
00:00:28 <jle`> basically, it lets you use State s a's inside State (s, t) a's, and State t a's inside State (s, t) a's
00:00:45 <jle`> so, if your function only "cares" about the `s` state, you can write a State s a and never care about the t
00:01:03 <jle`> and also provide a static guaruntee that a State s a won't "modify" the t
00:01:16 <jle`> this isn't a "lens" thing; it's sort of a thing about disciplined usage of the State type
00:01:58 <Guest27795> so zoom _1 would essentially transform (in my case), the "State StdGen" -> "StateT Game (State StdGen)" (or similar)?
00:02:11 <jle`> yes, if you decided to go with State StdGen
00:02:23 <jle`> um wait, no
00:02:23 <Guest27795> and then I'd create another for "DungeonState" to transform random into that
00:02:34 <jle`> it'd be State StdGen -> State (StdGen, GameState)
00:02:36 <julianleviston> :t zoom
00:02:37 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
00:02:40 <Guest27795> ah right
00:02:40 <jle`> State StdGen a -> State (StdGen, GameState) a
00:02:52 <jle`> zoom _2 :: State GameState a -> State (StdGen, GameState) a
00:03:01 <jle`> so you could write a State GameState a without ever worrying about randomness/StdGen
00:03:12 <Guest27795> ah nice!
00:03:13 <jle`> and then use zoom _2 at the end to let you >>/sequence it with things that do have randomness
00:03:21 <jle`> but, for this specific case in particular, i'd recommend RandT, heh
00:03:34 <Guest27795> yea I'll use RandT but its useful to know at least :)
00:03:46 <jle`> mhm.  but in real life, you probably wouldn't use tuples
00:03:57 <jle`> you'd use lenses to data types that contain different parts of your state
00:04:24 <jle`> like, if i had data MegaState = MegaState { _playerState :: PlayerState, _monsterStates :: MonstersState }
00:04:31 <jle`> and generated lenses automatically for them
00:04:41 <jle`> zoom playerState :: State PlayerState a -> State MegaState a
00:05:04 <Guest27795> ooh nice
00:05:08 <Guest27795> yea that sounds very useful
00:05:50 <jle`> yeah...in my mind this is the only disciplined way to work with monolithic states w/ State, heh
00:06:07 <jle`> because if you wrote your whole game as State MegaState a, then you have no guaruntees about what functions can change what parts of your state
00:06:24 <jle`> and you're basically writing an imperative program with *global mutable state*
00:06:26 <Guest27795> yea that's kind of what I'm running into
00:06:34 <jle`> which is...literally the worst ever
00:06:39 <Guest27795> so I'm trying to seperate these things out, so starting with Dungeon generation
00:10:31 <Guest27795> thanks jle`, I'm going to get some sleep
00:10:34 <Guest27795> g'night all
00:12:09 <julianleviston> :t (:.)
00:12:10 <lambdabot>     Not in scope: data constructor ‚Äò:.‚Äô
00:12:10 <lambdabot>     Perhaps you meant one of these:
00:12:11 <lambdabot>       ‚Äò:+‚Äô (imported from Data.Complex),
00:19:09 <julianleviston> In this‚Ä¶ (data List t = Nil | t :. List t deriving (Eq, Ord)) is ‚Äú:.‚Äù a data constructor? Is this an example of an operator as data constructor, like list‚Äôs (:) operator?
00:20:45 <bitemyapp> julianleviston: it's an infix data constructor like (:)
00:22:13 <julianleviston> bitemyapp: Cool. Thanks.
00:22:37 <julianleviston> Took me a while to figure out even though I saw one the other day...
00:22:57 <julianleviston> SO much to learn.
00:25:30 <julianleviston> How come I get different errors for these?
00:25:35 <julianleviston> :t (:.)
00:25:36 <lambdabot>     Not in scope: data constructor ‚Äò:.‚Äô
00:25:36 <lambdabot>     Perhaps you meant one of these:
00:25:36 <lambdabot>       ‚Äò:+‚Äô (imported from Data.Complex),
00:25:37 <julianleviston> :t (+.)
00:25:38 <lambdabot>     Not in scope: ‚Äò+.‚Äô
00:25:39 <lambdabot>     Perhaps you meant one of these:
00:25:39 <lambdabot>       ‚Äò++‚Äô (imported from Data.List), ‚Äò.‚Äô (imported from Data.Function),
00:25:58 <julianleviston> Is it because : is ‚Äúspecial‚Äù ?
00:26:46 <pavonia> What do you mean?
00:27:02 <julianleviston> pavonia: I was wondering why the error messages are different.
00:27:24 <julianleviston> pavonia: (one says ‚Äúnot in scope data contsructor‚Äù the other says ‚Äúnot in scope‚Äù
00:27:49 <pavonia> Ah, operators starting with ':' are data constructors
00:28:20 <pavonia> > let (:+) = (+) in 1 :+ 2
00:28:21 <lambdabot>      Constructor ‚Äò:+‚Äô should have 2 arguments, but has been given none
00:28:21 <lambdabot>      In the pattern: (:+)
00:28:21 <lambdabot>      In a pattern binding: (:+) = (+)
00:28:44 <julianleviston> pavonia: ok. How does a data constructor differ from a regular operator or function?
00:28:47 <pavonia> > let (+:) = (+) in 1 +: 2
00:28:49 <lambdabot>  3
00:29:29 <pavonia> julianleviston: Data constructors are values of new types and can be used in pattern matching
00:29:30 <julianleviston> pavonia: isn‚Äôt that just the fixity it has?
00:29:58 <julianleviston> pavonia: ok. so symbol-based data constructors *have* to start with ‚Äú:‚Äù ?
00:30:46 <pavonia> I think so, not sure if that has changes in earlier compiler versions, though
00:30:54 <julianleviston> interesting!
00:30:56 <julianleviston> pavonia: thanks!
00:31:12 <pavonia> No problem
00:31:38 <pavonia> @let data Foo a = a .+. a
00:31:38 <lambdabot>  Parse failed: Illegal data/newtype declaration
00:32:36 <julianleviston> Now I understand why :+: and :*: were chosen for GHC.Generics
00:32:47 <julianleviston> (besides being pretty) :)
00:32:51 <pavonia> @let data a .+. b = a :+. b
00:32:52 <lambdabot>  Defined.
00:33:22 <julianleviston> :t 5 :+. 7
00:33:24 <lambdabot> (Num a, Num b) => a .+. b
00:33:26 <pavonia> So yeah, seems they have to start with a colon
00:33:30 <julianleviston> haha cute.
00:34:58 <julianleviston> I *do* wish there was some way we could do away with the excessive tagging that is necessary everywhere. It‚Äôd make it so much more pleasant to use, and understand, but I guess we‚Äôll get there eventually.
00:35:33 <pavonia> What tagging do you mean?
00:35:49 <julianleviston> pavonia: Just 5
00:36:29 <julianleviston> pavonia: putting a bunch of operations into a Maybe monad‚Äôs do block gets rid of it
00:37:41 <pavonia> I don't follow
00:38:08 <julianleviston> pavonia: ‚ÄúJust 5‚Äù is one single value, but it has two tokens to represent it.
00:39:15 <julianleviston> pavonia: it‚Äôs an algebraic data type value‚Ä¶ right? So we have to tag the 5 with Just, so GHC/Haskell knows it‚Äôs a Maybe value we want to represent.
00:39:42 <pavonia> Sure
00:40:00 <julianleviston> pavonia: there‚Äôs obviously no problem when it‚Äôs just one level. When it gets to 2,3, or 4, though, it becomes tedious pretty fast.
00:42:49 <julianleviston> pavonia: it‚Äôs mostly only a problem when dealing with textual representation of code, though, obviously.
00:44:28 <pavonia> julianleviston: You could write a quasiquoter for your data types
00:47:11 <julianleviston> pavonia: yeah, or stop using text to express my values! :)
02:09:35 <aljoshka> Hi. How are G(S)List arguments and return values implement in Gtk2Hs?
02:12:50 <aljoshka> Is there an implicit conversion between Haskell lists and G(S)Lists at the function call or is there a separate type to represent these in Haskell?
02:13:30 <aljoshka> (ie, requiring explicit conversion between SML/C)
03:23:16 <tekkkz> Hello!
03:27:05 <tekkkz> I wanted to install the OpenCV library ªcabal install cv´ but at building is brings up an error: http://ix.io/mTl   why is this error there? how to fix it?
04:12:46 <duairc> Does anybody know if there is a type like this defined in any popular packages?
04:12:47 <duairc> newtype Uncurry f (p :: (k, l)) = Uncurry (forall a b. p ~ '(,) a b => f a b)
04:17:55 <manju> I get this error could not find module 'Common'
04:18:01 <manju> Is there a fix
04:24:09 <manju> I get this error could not find module 'Common', does anyone know what I need to install ?
04:24:59 <ptcek> manju: is it your own module?
04:25:16 <manju> No I found the code on the internet
04:25:33 <manju> ptcek, http://hackage.haskell.org/package/git-annex-5.20140613/src/doc/design/assistant/blog/day_24__airport_digressions.mdwn
04:25:50 <ptcek> manju: try to paste the whole error to lpaste
04:27:01 <manju> http://lpaste.net/4388729296814866432
04:31:00 * hackagebot sourcemap 0.1.6 - Implementation of source maps as proposed by Google and Mozilla.  https://hackage.haskell.org/package/sourcemap-0.1.6 (ChrisDone)
04:31:49 <steve2> Hello :)
04:40:03 <JagaJaga> Hello, guys! What's the best article to read to understand comonads? I can't get what are they :(
05:00:37 <raindev> Hi folks! Am I reeding the announcement[1] correctly: Haskell just got dependent types? [1]: https://www.reddit.com/r/haskell/comments/3wfzqk/kind_equalities_are_now_in_ghc_head/
05:03:30 <raindev> What it will make possible comparing to the options available earlier? And how the dependent types in Haskell will differ from Idris?
05:07:04 <raindev> I'm pretty new this stuff, just want to know what is that the people are so excited about :) I'll be thanful for any dependent-types-beginner friendly resources discussing the changes going on in Haskell
05:16:02 * hackagebot transformers 0.5.0.0 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.0.0 (RossPaterson)
05:20:48 <icbm> `foo x y = ... where data S = S { ... }` looks like it isn't valid Haskell. Should I just declare type S outside foo, even though it's only used internally by foo?
05:21:24 <julianleviston> icbm: yeah i think data type declarations have to be top level
05:21:34 <julianleviston> icbm: (from what I rememeber)
05:21:42 <julianleviston> icbm: try it - GHC will tell you.
05:21:48 <Jinxit> icbm: just don't export it in your module
05:21:59 <icbm> julianleviston: Thanks. GHC already told me, I was just hoping I made a mistake.
05:22:05 <icbm> Thanks, Jinxit.
05:22:20 <julianleviston> icbm: yeah, smaller functions, more modules :)
05:22:52 <julianleviston> Is there a Monad whose type would mean that I could write a do block that would implicitly chain each line with (>>=) rather than (>>) ? I‚Äôm not sure if this makes sense.
05:23:43 <JagaJaga> julianleviston: no. Do is just a syntax sugar
05:23:45 <Purry> Well, you could always replace (>>) with (>>=), so that could be true for any monad.
05:23:56 <JagaJaga> julianleviston: if you need >>= that write it explicitly
05:24:10 <julianleviston> So do this? doStuff list account = foldr (=<<) (return account) list
05:24:16 <julianleviston> and then use a list ? :)
05:24:21 <julianleviston> doStuff :: (Num a, Ord a) => [a -> Maybe a] -> a -> Maybe a
05:28:08 <julianleviston> actually I think it‚Äôs a state monad.
05:29:03 <SrPx> What are the state of art libs to create dynamic web frontends using ghcjs?
05:29:06 <julianleviston> the context of a state monad is state, which is what I‚Äôd be passing through each (>>=), so that would work.
05:30:32 <julianleviston> SrPx: ryan trinkle has a cool library cooled Reflex
05:30:46 <julianleviston> SrPx: https://github.com/ryantrinkle/try-reflex
05:30:59 <julianleviston> It‚Äôs pretty boss.
05:31:03 * hackagebot atto-lisp 0.2.2.2 - Efficient parsing and serialisation of S-Expressions.  https://hackage.haskell.org/package/atto-lisp-0.2.2.2 (ThomasSchilling)
05:31:09 <julianleviston> SrPx: there‚Äôs an intro video and stuff somewhere. 
05:31:56 <julianleviston> SrPx: https://www.youtube.com/watch?v=mYvkcskJbc4
05:32:04 <julianleviston> SrPx: he builds a twitter client in it.
05:32:23 <SrPx> Oh, thank you. That's awesome. Just before you someone linked me a 1hr long video about something called "blaze-react". That will take some time, so, while I watch both videos, could you tell me what is the main difference? (:
05:33:32 <julianleviston> SrPx: I‚Äôve never used either, but I *have* used a couple of clojure libraries built on top of React‚Ä¶ it sounds like blaze-react is just a wrapper for react? If that‚Äôs the case, it‚Äôd be at least somewhat limited in scope to React‚Äôs constraints (which there are quite a few of).
05:34:22 <julianleviston> SrPx: React does a full shadow render on every update. It‚Äôs quite fast, but Ryan‚Äôs has a different approach - he uses FRP to keep everything up to date naturally.
05:34:49 <SrPx> I don't know much about react other than virtualdom, which I have some considerable experience. So, you could say both are entirely different approaches? 
05:38:42 <julianleviston> SrPx: It depends which pieces of react blaze-react uses. React stipulates a kind of one way data flow through your application, but it doesn‚Äôt help you with state management‚Ä¶ other than to have component local state, and to manage your state propagation and rendering through components‚Ä¶ but you still have to wire all that stuff up together somewhat manually. Ryan‚Äôs is built more from an FRP idea out‚Ä¶ so you bui
05:38:43 <julianleviston> components which specify their dependencies by a network as you build them. Updates naturally propigate where they need to go, and when they hit the DOM they‚Äôre efficient and don‚Äôt need shadow DOM or a render manager or anything else at all. They‚Äôre the two ‚Äúbest‚Äù main ways to approach current browser Apps, I think. 
05:39:07 <julianleviston> React‚Äôs approach can have performance issues if you do too much between render cycles‚Ä¶ 
05:41:03 * hackagebot vrpn 0.2.1.0 - Bindings to VRPN.  https://hackage.haskell.org/package/vrpn-0.2.1.0 (BrianBush)
05:41:17 <SrPx> julianleviston that was very insightful, thank you! I see you suggest FRP is generally considered a better approach, correct? So I'm watching the Reflex video first.
05:42:53 <julianleviston> SrPx: I don‚Äôt know much about FRP, other than it‚Äôs a bit of a hornet‚Äôs nest‚Ä¶ (there are many variations of it, and many definitions). Theoretically they‚Äôre *both* FRP (react *is* called react after all) - but they‚Äôre different definitions of what that means. If you want clarification of this, there‚Äôs a pretty good talk by Evan of Elm fame (he wrote Elm).
05:43:10 <julianleviston> https://www.youtube.com/watch?v=Agu6jipKfYw
05:43:37 <julianleviston> He runs through the main different kinds of FRP, and explains what he thinks is best (spoiler alert, it‚Äôs the way Elm does it)
05:44:10 <julianleviston> SrPx: having said all that, my bias is towards Ryan Trinkle‚Äôs stuff.
05:44:45 <SrPx> I see. Let me just ask one last question, then. I've been using Haskell for long enough already, but for any kind of real world programming I still use JS for the front end. I want to settle in a FP language for it, now. I think Elm/PureScript are good, but I find it a shame that I can't share code between then, and what I do in Haskell. Do you think GHCJS is already mature enough for me to build my web apps on Haskell itself?
05:45:03 <julianleviston> SrPx: yeah.
05:45:35 <SrPx> Any kind of real world problem I should be aware of?
05:45:44 <tpsinnem> hey, are there special benefits to opening an editor from 'ghci' via ':edit'?
05:45:47 <julianleviston> SrPx: This is a theoretical answer (because I haven‚Äôt used it yet), but I‚Äôm going to use it when it comes to building the front end part of my app.
05:46:02 <tpsinnem> ^ vs just opening an editor normally, outside ghci
05:46:17 <SrPx> Ah I see. So will I, then, I think. If there is an issue we'll figure out simultaneously (: 
05:48:14 <SrPx> (On the video, Ryan claims Reflex works with iOS/Android, I'm not sure I understand what he means - through webviews, that is?)
05:48:20 <julianleviston> SrPx: people are using GHCJS, and it‚Äôs fast becoming better all the time. Last time I looked it took a long time to compile...
05:48:31 <julianleviston> SrPx: probably.
05:48:38 <SrPx> oh okay
05:48:45 <julianleviston> SrPx: React works on iOS, too (React Native)
05:48:54 <julianleviston> SrPx: That‚Äôs *not* webviews tho.
05:48:57 <SrPx> julianleviston wow
05:49:15 <julianleviston> SrPx: He might be talking about a similar shim for GHCJS to Android and IOS‚Ä¶ 
05:49:57 <julianleviston> SrPx: I know he put a lot of effort into building it in two separate layers‚Ä¶ one is Reflex-DOM, the other is Reflex (a more abstract model)
05:50:34 * SrPx can't read the code... :( wishes the video was uploaded with >480p
05:50:37 <julianleviston> SrPx: FWIW, the way react does it is they keep a separate thread running and use JS to control the native code‚Ä¶ 
05:50:59 <julianleviston> SrPx: pretty sure there is a github repo of it somewhere
05:51:41 <julianleviston> SrPx: couldn‚Äôt see it, but this is his github: ryan trinkle harvard
05:51:56 <julianleviston> SrPx: (oops) https://github.com/ryantrinkle
05:52:04 <SrPx> Okayy thanks
05:53:03 <SrPx> Kinda hard to follow the talk without code, I'll jump to the docs now
05:55:25 <breadmonster> Hello everyone.
05:56:17 <SrPx> Hi
06:10:26 <mtesseract> Hi
06:11:52 <petercommand> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
06:12:10 <petercommand> how to get the c-- code in example1?
06:13:34 <petercommand> I know about -ddump-cmm, but I can't find similar code segment in the produced file
06:14:09 <mtesseract> As I understand it, the MaybeT monad transformer allows me to equip the IO monad with the characteristics of the Maybe monad, that is, with computations that might fail. When working in the Maybe monad, I can produce failures simply by producing Nothings. When I am working in the MaybeT monad, how would I produce a failure there? I have seen an introductory text on this using "guard". But that seems like a
06:14:12 <mtesseract> highlevel convenience function to me. I am wondering what the underlaying mechanism is.
06:15:13 <nshepperd_> mtesseract: mzero
06:15:38 <nshepperd_> mzero is the method of the MonadZero typeclass, that produces "lifted Nothings"
06:16:37 <mtesseract> nshepperd_: I see, so for "lifted failures" I generally need the MonadZero typeclass.
06:16:53 <julianleviston> :t mzero
06:16:54 <lambdabot> MonadPlus m => m a
06:17:10 <maerwald> what is the MonadZero typeclass?
06:18:43 <quchen> maerwald: MonadPlus without mplus
06:19:16 <nshepperd_> for MaybeT, mzero is just (MaybeT Nothing), so you can make one manually like that I guess
06:25:47 <maerwald> johnw: is that you who wrote pipes-files?
06:27:40 <quchen> maerwald: Yes, that's johnw
06:27:44 <rvxi> hey
06:29:14 <icbm> How would I avoid allocating intermediate chunks when using ByteString Builder.  Always make sure I'm doing `alreadyDone <> newThing` ?
06:29:40 <icbm> Don't do `alreadyDone <> ( newA <> newB )` ?
06:30:05 <quchen> maerwald: That's a strange package you've mentioned, I think he uplaoded the wrong thing :-D
06:30:15 <maerwald> ...
06:30:52 <quchen> Uuuuuh. His "CondT" type is pipes-based.
06:31:13 <quchen> Not the wrong thing then, but very strange naming scheme, since CondT sounds like Conduit Transformer
06:31:15 <maerwald> yes, I wonder why he doesn't use conduits
06:32:03 <quchen> Why?
06:32:18 <maerwald> they are cooler?
06:33:21 <rvxi> what's happening with cloud haskell? seems like it's been pretty quiet
06:33:25 <maerwald> currently looking at Data.Conduit.Filesystem and wonder what I will use
06:33:39 <rvxi> is it a dying project?
06:34:19 <julianleviston> rvxi:  is it useful?
06:34:37 <julianleviston> rvxi: I wonder if the unix command ‚Äúls‚Äù is considered a dying project
06:34:57 <rvxi> julianleviston not the same
06:35:08 <maerwald> julianleviston: nah, verynice is the undefeated champion I think
06:35:28 <maerwald> no release for ~12 years or so, still used everywhere
06:35:42 <rvxi> julianleviston seems like it's in the process of evolving. sounds like it still has performance issues by hpc standards
06:37:25 <rvxi> julianleviston you could make that argument for some libs that are small, self contained, and mature. but i don't think distributed computing solutions in haskell fall into that category yet.
06:37:28 <julianleviston> rvxi: fair enough :)
06:37:46 <julianleviston> rvxi: I thought the concurrency stuff was part of cloud haskell?
06:37:57 <julianleviston> from memory it‚Äôs a BIG project comprised of many others isn‚Äôt it?
06:38:23 <julianleviston> rvxi: I‚Äôm not sure. :) it‚Äôs interesting tho.
06:38:54 <maerwald> quchen: what would you use for representing a filesystem "tree"? I'v tried directory-tree with lazy IO, but that didn't work out well, so now I am looking at conduit stuff
06:39:07 <rvxi> julianleviston think of cloud haskell as distributed-process although technically i guess that's an implementation of it
06:39:50 <quchen> maerwald: Uh, I've never written anything like that, I'd just use the OS file system
06:39:57 <rvxi> all the videos and info on it seem to be like 2-3 years old though, which isn't so encouraging :(
06:40:32 <julianleviston> rvxi: according to this it‚Äôs had activity‚Ä¶ http://haskell-distributed.github.io
06:40:56 <maerwald> quchen: lol :D I'm writing a filemanager, so I sort of need representation of it... unless I want everything to be FilePath (as in String) based
06:40:56 <julianleviston> rvxi: assuming < 6 months is somewhat recent
06:40:58 <maerwald> which is sort of ugly
06:41:39 <maerwald> it feels like I'm wrapping C code
06:42:51 <rvxi> julianleviston yeah, there's some activity. would be nice to see more promotion / use cases though... the only people i've heard of using it are the tweag guys
06:43:10 <rvxi> all other youtube vids of it are like frrom 2012 ish
06:45:04 <maerwald> pipes-files looks more like it's written for fast find operations
06:45:27 <julianleviston> rvxi: maybe you should get involved? there was activity 18 days ago on the github repo of https://github.com/haskell-distributed/distributed-process
06:46:00 <rvxi> julianleviston maybe, i'm still relatively new to haskell though
06:46:17 <julianleviston> rvxi: me too.
06:46:32 <rvxi> heading  out for a run, bbl...
06:47:01 <tekkkz> http://stackoverflow.com/questions/34380719/build-opencv-binding-in-haskell-for-opencv-2-4
06:59:52 <fatlazycat> hi, trying to get a stack build going on travis - get the following error 'Could not resolve file /tmp/ghc2525_0/ghc_6.s' any pointers into what's the likely area to look at ?
07:03:08 <l3dx> what kind of data structure would you use to represent a 2d array, and what function(s) would you use to manipulate arbitrary x,y cells?
07:04:17 <JagaJaga> l3dx: list zipper of list zippers :)
07:05:39 <maerwald> l3dx: Data.Map with the key being a tuple?
07:08:30 <julianleviston> why wouldn‚Äôt you use an Array?
07:08:34 <maerwald> > Data.Map.singleton (1, 2) "abc"
07:08:35 <lambdabot>  Not in scope: ‚ÄòData.Map.singleton‚Äô
07:09:38 <JagaJaga> julianleviston: 2d zipper is better I think. Easier to manipulate etc
07:09:55 <julianleviston> I guess it depends what the constrains / requirements ae
07:09:56 <julianleviston> are*
07:10:02 <JagaJaga> julianleviston: sure
07:13:10 <l3dx> I'm just fooling around trying to learn haskell better. Using the exercises of adventofcode.com to practice :) This in particular is day 6
07:13:18 <l3dx> I'll look into zippers
07:13:41 <JagaJaga> icbm: there is a nice tutorial at wikibooks
07:16:20 <icbm> JagaJaga: URL? My google fu fails.
07:16:35 <JagaJaga> icbm: https://en.wikibooks.org/wiki/Haskell/Zippers
07:16:46 <JagaJaga> icbm: and read http://blog.emillon.org/posts/2012-10-18-comonadic-life.html after
07:17:25 <icbm> JagaJaga: Thanks. I've seen the word "comonad" before and should probably learn what that is.
07:21:07 * hackagebot pontarius-xmpp 0.5.0 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.0 (PhilippBalzarek)
07:22:11 <julianleviston> comonads FTW :)
07:22:41 <rvxi> back..
07:23:05 <julianleviston> ‚ÄúMonads with the arrows reversed‚Äù
07:26:07 * hackagebot hspec-setup 0.1.1.0 - Add an hspec test-suite in one command  https://hackage.haskell.org/package/hspec-setup-0.1.1.0 (yamadapc)
07:28:37 <rvxi> finally getting acclimated to spacemacs after a week of carpel-tunnel-ishness
07:28:58 <monochrom> heh
07:31:49 <rvxi> anyone tried haskell csound or supercollider bindings?
08:11:32 <lamefun> is stack's extra-deps hash/signature checked?
08:14:32 <sonolin> hi, so I'm trying to use the Rand monad within my hs game
08:14:32 <sonolin> https://hackage.haskell.org/package/MonadRandom-0.4.1/docs/Control-Monad-Random.html
08:14:53 <sonolin> I'm just wondering, this is great but I still have to store the generator in some sort of state right?
08:15:13 <sonolin> (assuming I don't want to use IO)
08:15:28 <monochrom> Rand is already some sort of state monad
08:15:52 <sonolin> ah ok
08:16:10 <sonolin> so maybe just wrap my "runGame" in "runRand" 
08:16:17 <kristian_> exit
08:16:37 <sonolin> ok I think I got it :) I'll play with that
08:20:08 <rvxi> sonolin what kind of game are you making?
08:21:11 * hackagebot containers 0.5.7.1 - Assorted concrete container types  https://hackage.haskell.org/package/containers-0.5.7.1 (MilanStraka)
08:24:49 <sonolin> rvxi its a haskell roguelike
08:24:56 <sonolin> just really basic right now, still working out dungeon generation
08:28:15 <rvxi> what are you using for graphics? frp?
08:28:36 <rvxi> (2 questions sorry if that's unclear)
08:32:26 <sonolin> rvxi no frp (yet) just using the "vty" package
08:32:48 <sonolin> any suggestions on frp libraries? Just using ascii graphics for now
08:35:43 <icbm> Is there a type class like Monoid but where the append operation works on the inner type (m a -> a -> m a) ?
08:35:53 <rvxi> sonolin people site reactive banana a lot, apparently reflex has better performance though
08:36:44 <roelof> is Haskell-stack always a quit channel ? 
08:38:13 <rvxi> roelof quit channel?
08:38:58 <dutchie> probably "quiet"
08:39:36 <roelof> Yes, I mean that  quiet , Sorry for the confusion 
08:40:43 <rvxi> roelof probably too small of a niche . might as well chat here
08:41:22 <rvxi> i think i'm doing stack wrong, because i'm getting more depency failures than with cabal install
08:42:20 <roelof> its a stack problem. I try to make a coverage report but see a error message. See https://github.com/commercialhaskell/stack/issues/1541
08:43:59 <rvxi> i tried it on  a few projects and for now i'm going back to cabal install with a shared sandbox (i know that's evil...)
08:45:24 <roelof> IM also thinking about trying cabal but I know yesod uses stack. 
08:46:23 <roelof> or I can take a look at something like servant for my website 
08:48:45 <rvxi> roleof: yesod works just fine with cabal
08:48:49 <tortal> what's a nicer way to write: concat [ a:" " | a<-(map chr $ [0..127])]
08:48:50 <rvxi> at least for me
08:49:14 <roelof> rvxi:  Does code coverage of a library work well on cabal 
08:49:41 <rvxi> roleof not sure what you mean by code coverage of a library
08:49:58 <roelof> Check if the tests test al the code
08:50:39 <rvxi> what do you mean like hspec? i don't see what that has to do with cabal or a build system
08:51:34 <ChristianS> tortal: intersperse ' ' (map chr $ [0..127])
08:53:19 <tortal> ChristianS: much thanks
08:55:45 <roelof> no I mean this the output of these commands : cabal configure --enable-tests --enable-library-coverage  cabal test 
09:01:18 <ChristianS> tortal: the $ is superfluous, incidentally
09:03:30 <sonolin> :r
09:03:33 <sonolin> ops
09:04:27 <roelof> luigy:  are you here. Could it been that ghc 4.8 is too blame. See my last remarks on the bug report 
09:05:21 <monochrom> 4.8?
09:05:31 <maerwald> haha, I wrote "map" via Conduit http://lpaste.net/147520
09:05:31 <monochrom> base 4.8?
09:06:15 <Athas> Convention is to sometimes prefix classes with Monad (like MonadState, MonadReader); is there a similar convention for (applicative) Functors?
09:06:36 <monochrom> no
09:14:16 <tnecniv> so i have a type class, and i want to make a list of things that implement that type class. i've read that this isnt very haskell. what is the typical way to do this?
09:15:30 <keko-2> why do you want to do that?
09:15:49 <keko-2> do you mean a list you can access in haskell, or a list to be included in some documentation?
09:16:11 <tnecniv> the former
09:16:23 <tnecniv> like i have a square and a cube
09:16:32 <tnecniv> both can be rendered
09:16:55 <tnecniv> i want to be able to past a list of renderable things to a function
09:17:01 <tnecniv> and have it render all of them
09:17:15 <Athas> tnecniv: construct a list of actions that perform a rendering.
09:18:33 <tnecniv> well the thing is rendering one thing requires knowledge of all other elements in the scene
09:18:37 <tnecniv> for lighting and such
09:18:38 <Athas> Let us assume you have a class: 'class Renderable a :: a -> Canvas -> IO ().  Now, instead of creating a list '[Renderable a => a]', you construct a list '[Canvas -> IO ()]'.
09:19:25 <Athas> Heterogenous lists are possible, but very nasty to work with.  Try to fiddle with the design so you get homogenous lists instead.
09:19:40 <Athas> Maybe instead of storing the renderable elements, you just store the functions/actions that you can perform on them?
09:21:13 * hackagebot pipes-cacophony 0.1.3 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.1.3 (jgalt)
09:21:56 <tnecniv> interesting
09:22:23 <tnecniv> hmm
09:28:03 <tnecniv> Athas the thing is, i am writing a ray tracer. instead of calling render on each element of the scene, it performs some computation for each pixel that determines what what color to set the pixel to. However, since i dont know what scene elements are necessary for each pixel ahead of time, i need to be able to access all them
09:29:49 <roelof> monochrom:  I do not know either. Im just a beginner try to learn something 
09:30:07 <Athas> tnecniv: then pass them in.
09:30:24 <Athas> Create a list [AllObjects -> Canvas -> IO ()]
09:33:43 <spuz> hello, is there any way to do IO as part of an hspec test?
09:33:56 <spuz> specifically i want to load some input data to test against from a local file
09:36:06 <tnecniv> Athas then isnt AllObjects a heterogenous list?
09:36:38 <tnecniv> although in my case i think i might be able to get away with currying, i still want to learn the right way to do this in general
09:36:46 <Athas> tnecniv: depends on how you do it.  What do you need to query these values for?
09:36:58 <Athas> Most likely there is a general (monomorphic) interface.
09:37:25 <Athas> Instead of thinking of an object in your scene as a bunch of properties, think of them as a set of query functions.
09:37:35 <tnecniv> mainly i need to calculate intersection points of different geometric objects and a ray
09:38:08 <Athas> So isn't an object just defined by a function 'Ray -> Maybe Point'?
09:38:23 <tnecniv> yeah
09:38:31 <tnecniv> that was my realization about currying above
09:38:36 <Athas> If you really want heterogenous lists, look at GADTs.  It's perfectly possible, but it's heavy machinery type-wise.
09:38:52 <tnecniv> it also seems like a compiler extension
09:39:01 <Athas> Yes, it's not standard Haskell 2010.
09:39:09 <tnecniv> and i want to learn the haskell way to do things before i move into extensions
09:39:38 <monochrom> at present you probably just need a list of rendering actions
09:45:38 <roelof> monochrom:  I hope the stack people find my bug report and can take care that it goig to be solved. 
10:01:15 * hackagebot fake-type 0.1.0.0 - A crossplatform library to simulate keyboard input  https://hackage.haskell.org/package/fake-type-0.1.0.0 (Artyom)
10:04:13 <oisdk_> tnecniv could you make a sum-type for all of your renderable things?
10:04:25 <tnecniv> sum type?
10:05:09 <oisdk_> data SceneObject = Cube CubeObject | Square SquareObject
10:05:29 <oisdk_> then you can have your list as [SceneObject]
10:05:51 <roelof> how can I downgrade the base package on a stack project. Sorry to ask two times , browser did not work well 
10:06:22 <oisdk_> You'd need to add a new case to SceneObject for every new shape, but if the number is low that's probably the most painless solution
10:07:07 <oisdk_> Or, if you had a type that represented a general polygon, you could have the SceneObject be something like this:
10:07:20 <oisdk_> data SceneObject = Cube CubeObject | Square SquareObject | Poly PolyType
10:08:25 <Athas> oisdk_: that doesn't scale very well, unless you can have some compound (non-polygonal) object.
10:08:35 <Athas> I don't know enough about raytracing to say whether that is common.
10:08:50 <Athas> Maybe everything can just be a high-resolution polygon!
10:11:42 <oisdk_> Athas yeah, you're probably right. It sounds like tnecniv might only have very few basic shapes, though (cube, square) so in that case it would work well.
10:13:59 <tnecniv> Athas the idea is you shoot a ray for each pixel from the camera origin, and set that pixel to the color of what it hits, taking lighting into account
10:14:19 <Athas> tnecniv: sure, I know the theory, but I don't know how many primitives you'd typically have in a raytracer.
10:14:52 <tnecniv> i'm just going to do cubes and spheres
10:15:13 <Athas> Oh, yeah, then just use an algebraic data type.
10:15:15 <Athas> Way easier.
10:15:35 <Athas> My piece of Haskell advice: keep things as concrete as possible.
10:17:56 <johnw> maerwald: hi, yes
10:19:12 <maerwald> johnw: I was looking for some way to represent the filesystem tree "lazily", so I ended up looking at conduit and stuff
10:19:46 <johnw> maerwald: yep, that's what pipes-files is made for, built on top of "hierarchy" to abstract the problem of predicated hieriarchical traversals
10:19:48 <maerwald> still not sure if that gives any real benefit since most operations are rather atomic
10:19:50 <johnw> (lazily computed)
10:20:06 <johnw> you said you already had a working version based on lazy I/O?
10:20:20 <maerwald> currently I just have a data structure for "the current dir" and then read directories as I go
10:20:29 <maerwald> yes, but I ditched it, too much trouble with state
10:20:40 <johnw> right, so that just what these abstractions manage for you
10:20:48 <johnw> because internally, that's what pipes-files has too
10:21:02 <johnw> the idea of the pipe or conduit is to just surface data extraction to you, and not all the stateful bits
10:21:50 <maerwald> the problem is I need "update" the view of a directory very often (e.g. via a watcher), so I can't just build a tree once lazily and then operate on it
10:22:17 <maerwald> I have a feeling it's easier if I stay low-level here
10:22:22 <johnw> maybe
10:22:29 <johnw> it sounds like you have unstated requirements
10:23:01 <maerwald> it's for a file manager
10:23:27 <johnw> I see
10:23:30 <maerwald> it's sort of important to carry as little state around as possible, so that my program-internal information doesn't get too out of sync with the actual filesystem
10:24:21 <johnw> a pipe or a conduit *streams* the hierarchy into a series of fetched elements; they aren't good at operating on/within a large virtual structure.  For that, I imagine you'd want some kind of stateful zipper...
10:24:42 <johnw> that is, if you need abstraction at all
10:25:54 <maerwald> yeah, I had a zipper that operates on the lazily read filesystem tree, but then I got those state problems and ended up re-creating the zipper so often that it became a moot point (although that's very cheap anyway)
10:28:05 <maerwald> maybe I'm just looking for abstraction where none is needed, I don't know
10:28:30 <johnw> that does happen
10:36:32 <vandenoever> in an expression,   "a <- someFunction b", how can I add a type annotation to 'a'?
10:36:58 <johnw> (a :: Type) <- ...
10:37:03 <johnw> after enabled ScopedTypeVariables
10:37:25 <vandenoever> johnw: ah, thanks!
10:46:17 * hackagebot hzulip 1.1.1.2 - A haskell wrapper for the Zulip API.  https://hackage.haskell.org/package/hzulip-1.1.1.2 (yamadapc)
10:46:20 * hackagebot drawille 0.1.0.6 - A port of asciimoo's drawille to haskell  https://hackage.haskell.org/package/drawille-0.1.0.6 (yamadapc)
10:46:30 <tnecniv> what does ! in front of a type mean?
10:47:46 <monochrom> you mean in "data X = MkX !Int"?
10:49:24 <tnecniv> monochrom yeah
10:49:44 <monochrom> it makes that field strict
10:50:08 <roelof> no one who uses code-coverage on cabal or stack ? 
10:50:19 <JonReed> tnecniv: http://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration
10:50:35 <JonReed> tnecniv: Also there are BangPatterns which do similar thing
10:50:37 <monochrom> for example "data Y = MkY Int"  case (MkY (an infinite loop here)) of MkY _ -> ...  this is not an infinite loop
10:50:58 <monochrom> but case (MkX (an infinite loop here)) of MkX _ -> ...  this will be an infinite loop
10:52:07 <JonReed> Does anybody know how to convert stack.yaml to ".nix" or ".cabal" (which can be converted to .nix through cabal2nix).
10:52:13 <JonReed> I'm new to stack
10:54:23 <JonReed> E.g., how to convert this "https://github.com/reinh/reflex-dom-stack-demo/blob/master/stack.yaml" to .cabal file (or .nix). I just want to end up with a nix derivation which I can use in nix.
10:59:32 <JonReed> Nevermind, found this "http://stack.readthedocs.org/en/stable/nix_integration.html"
11:02:08 <kqr> how do I interpret the following? http://lpaste.net/5537695561743859712 ? should it not know which GHC to use?
11:03:49 <kqr> should not "stack setup" install the correct version for the resolver?
11:07:34 <bergmark> kqr: latest version of stack? There was a bug in older versions where stack setup would get the wrong minor version
11:07:42 <tnecniv> also, why cant i say let foo = infinity
11:07:47 <tnecniv> but i can do let foo = 1/0
11:09:12 <kqr> bergmark, just realised that might be a problem ‚Äì upgrading stack as we speak
11:09:26 <kqr> tnecniv, define `infinity = 1/0`
11:09:40 <tnecniv> well yeah
11:10:02 <tnecniv> i was just curious as to why that restriction
11:10:20 <kqr> it's not really a restriction so much that nobody have bothered to define an "infinity" variable in the standard library
11:10:31 <kqr> but if you're willing to use third party libraries, there's http://haddock.stackage.org/lts-3.18/ieee754-0.7.6/Numeric-IEEE.html#v:infinity
11:10:38 <kqr> which contains lots of useful goodie for IEEE floats, it seems
11:20:06 <roelof> someone a idea for this problem : https://github.com/commercialhaskell/stack/issues/1541
11:25:12 <sLite> hmm
11:25:18 <sLite> cabal install pointful fails for me
11:25:27 <sLite> can anyone confirm?
11:26:52 <sLite> http://pastebin.com/4emYWZtm
11:31:15 <bergmark> sLite: looks like it needs an older version of haskell-src-exts
11:31:21 * hackagebot haphviz 0.1.1.5 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.1.5 (Norfair)
11:32:34 <hexagoxel> sLite: yes, i noticed that a few days back as well. pointfree worked though, for some reason
11:32:36 <sLite> hmm, i installed ghc+caball from opensuse repos
11:32:47 <sLite> yea, pointfree is fine for me aswell
11:34:43 <bergmark> pointfree works because it has haskell-src-exts==1.16.* as a dependency instead of any version
11:35:21 <bergmark> you can try: cabal install pointful --constraint='haskell-src-exts==1.16.*'
11:40:06 <arnoblalam> Hi all
11:40:08 <sLite> bergmark: works
11:40:28 <bergmark> cool
11:40:59 <sLite> bergmark: thx, so this is a problem in the dependency definitions of pointful not with my installation, right?
11:42:28 <pilne> IIRC installing from distro repos is often not "best practices"
11:42:40 <arnoblalam> I have a question regarding "tree contraction"/"graph contraction" in Haskell.  I am not a CS person, so this might be a solved problem.  If so, I would appreciate being referred to the right literature
11:43:48 <AleXoundOS> pilne, and what is the "best practice" ?
11:43:58 <arnoblalam> I have a tree.  Each node in the tree has a weight, and a list of children.  I am trying to contract a tree with n nodes to m nodes
11:44:50 <pilne> i'm still trying to figure that out for myself! lol
11:45:00 <AleXoundOS> :)
11:45:04 <pilne> but haskell-platform isn't often up-to-date on most repos
11:45:16 <pilne> for linux distros that is
11:45:28 <arnoblalam> contracting the tree means combining means adding the weights of two nodes and then having the children from each node of the tree be children of the new node
11:46:11 <AleXoundOS> pilne, haskell-platform is not suggested at all: https://www.stackage.org/install#why-not-haskell-platform
11:46:37 <pilne> isn't that what you get when you install from debian/ubuntu/suse/fedora/etc. though?
11:47:20 <arnoblalam> of course there are many possible aggregations going from n nodes to m nodes (or even from n nodes to n-1 nodes).  I want to have an efficient algorithm for generating all these possible aggregations
11:47:27 <arnoblalam> any suggestions?
11:47:45 <JonReed> It's generally quite easy to use up-to-date packages with nix. Even if the package version, you can easily make it so with cabal2nix. And by using environments you can install conflicting packages and multiple versions without problems.
11:48:07 <JonReed> Even if the package version on the channel is outdated*
11:48:31 <martinvlk> Hi, when trying multi-threaded code in ghci, will it by default run as threaded or do I need to activate threads explicitly?
11:49:19 <pilne> hmmm
11:58:33 <k0ral> Hello
11:58:50 <hexagoxel> sLite: yes; my setup was fully sandboxed and yet i had the problem, pretty sure it is the package.
11:59:44 <k0ral> > runStateT (try $ put 2 >> throwM (AssertionFailed "ERROR")) 1 :: IO (Either AssertionFailed (), Int)
11:59:46 <lambdabot>      Not in scope: ‚ÄòthrowM‚Äô
11:59:46 <lambdabot>      Perhaps you meant one of these:
11:59:46 <lambdabot>        ‚Äòthrow‚Äô (imported from Control.Exception),
12:00:01 <k0ral> > runStateT (try $ put 2 >> throw (AssertionFailed "ERROR")) 1 :: IO (Either AssertionFailed (), Int)
12:00:02 <lambdabot>      Couldn't match expected type ‚ÄòStateT
12:00:02 <lambdabot>                                      Int IO (Either AssertionFailed ())‚Äô
12:00:02 <lambdabot>                  with actual type ‚ÄòIO (Either e0 a0)‚Äô
12:00:34 <tekkkz> > (\x->x*x) 2
12:00:36 <lambdabot>  4
12:01:18 <tekkkz> > (\xy->x+y) 5 5
12:01:21 <lambdabot>      Couldn't match expected type ‚ÄòInteger -> t‚Äô with actual type ‚ÄòExpr‚Äô
12:01:21 <lambdabot>      The function ‚Äò\ xy -> x + y‚Äô is applied to two arguments,
12:01:21 <lambdabot>      but its type ‚ÄòInteger -> Expr‚Äô has only one
12:01:32 <tekkkz> > (\xy->x+y) (5 5)
12:01:34 <lambdabot>      No instance for (Num (a0 -> r0))
12:01:34 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
12:01:34 <lambdabot>        arising from the literal ‚Äò5‚Äô
12:02:09 <k0ral> anyone could help me understand why the following code returns "1" instead of "2": runStateT (Control.Monad.Catch.try $ put 2 >> throwM (AssertionFailed "ERROR")) 1 :: IO (Either AssertionFailed (), Int) ?
12:02:49 <k0ral> the state seems to be lost because of throwM
12:05:22 <k0ral> > runStateT (try $ put 2 >> (lift $ throw (AssertionFailed "ERROR"))) 1 :: IO (Either AssertionFailed (), Int)
12:05:25 <lambdabot>      Couldn't match expected type ‚ÄòStateT
12:05:25 <lambdabot>                                      Int IO (Either AssertionFailed ())‚Äô
12:05:25 <lambdabot>                  with actual type ‚ÄòIO (Either e0 a0)‚Äô
12:05:44 <tekkkz> > (\xy->x+y) (5) (5)
12:05:46 <lambdabot>      Couldn't match expected type ‚ÄòInteger -> t‚Äô with actual type ‚ÄòExpr‚Äô
12:05:46 <lambdabot>      The function ‚Äò\ xy -> x + y‚Äô is applied to two arguments,
12:05:46 <lambdabot>      but its type ‚ÄòInteger -> Expr‚Äô has only one
12:05:53 <tekkkz> > (\xy->x+y) ((5) (5))
12:05:55 <lambdabot>      No instance for (Num (a0 -> r0))
12:05:55 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
12:05:55 <lambdabot>        arising from the literal ‚Äò5‚Äô
12:06:15 <k0ral> > (\x y->x+y) 5 (5 :: Int)
12:06:17 <lambdabot>  10
12:06:32 <tekkkz> thx ^^
12:06:44 <tekkkz> > (\xy->x+y) 5 (5)
12:06:46 <lambdabot>      Couldn't match expected type ‚ÄòInteger -> t‚Äô with actual type ‚ÄòExpr‚Äô
12:06:46 <lambdabot>      The function ‚Äò\ xy -> x + y‚Äô is applied to two arguments,
12:06:46 <lambdabot>      but its type ‚ÄòInteger -> Expr‚Äô has only one
12:06:50 <tekkkz> > (\xy->x+y) 5 (5 :: Int)
12:06:52 <lambdabot>      Couldn't match expected type ‚ÄòInt -> t‚Äô with actual type ‚ÄòExpr‚Äô
12:06:52 <lambdabot>      The function ‚Äò\ xy -> x + y‚Äô is applied to two arguments,
12:06:52 <lambdabot>      but its type ‚ÄòInteger -> Expr‚Äô has only one
12:07:03 <tekkkz> > (\x y->x+y) 5 (5 :: Int)
12:07:05 <lambdabot>  10
12:07:14 <tekkkz> > (\x y->x+y) 5 5
12:07:15 <lambdabot>  10
12:07:20 <k0ral> > (+) 5 5 :: Int
12:07:22 <lambdabot>  10
12:07:30 <mniip> consider doing this in a PM with lambdabot
12:07:36 <tekkkz> ahh yeah thanks
12:07:40 <tekkkz> ddint thought about it
12:12:41 <tekkkz> > (\y -> 2 ^ y) 10000000
12:12:44 <lambdabot>  9049817306360800301396402667708707356248762388018002675910921592053343748725...
12:13:17 <roelof> Anyone knows how to solve this : cabal configure --enable-tests --enable-coverage    cabal: unrecognized option `--enable-coverage'
12:14:22 <Cale> roelof: If you do cabal configure --help  does it list that flag?
12:14:28 <Cale> Which version of cabal install are you using?
12:16:42 <roelof> Cale : how can I check this ? 
12:16:47 <Cale> cabal --version
12:17:10 <arnoblalam> I have a question regarding "tree contraction"/"graph contraction" in Haskell.  I am not a CS person, so this might be a solved problem.  If so, I would appreciate being referred to the right literature. I have a tree.  Each node in the tree has a weight, and a list of children.  I am trying to contract a tree with n nodes to m nodes.  Contracting the tree means combining means adding the weights of two nodes and then having the 
12:17:45 <Cale> "Contracting the tree means combining means adding the weights of two nodes and then having the" -- your message was cut off here by the line length limit
12:17:55 <arnoblalam> e children of the new node. of course there are many possible aggregations going from n nodes to m nodes (or even from n nodes to n-1 nodes).  I want to have an efficient algorithm for generating all these possible aggregations. Any suggestions?
12:18:15 <roelof> Cale:  This version : cabal-install version 1.16.0.2 
12:18:49 <Cale> roelof: and my first question? If you cabal install --help, do you see --enable-coverage listed in the help?
12:19:02 <Cale> I think you might be using too old a version of cabal-install to have that option
12:19:54 <roelof> no, but I see enable-library-coverage listed 
12:20:19 <Cale> 1.16.0.2 is from 2012
12:20:38 <Cale> I'm almost kind of surprised that it works at all :)
12:20:55 <monochrom> 1.18 is still also "--enable-library-coverage" and not "--enable-coverage". (to be honest, I don't know their relation.)
12:21:53 <Cale> Where did you install cabal-install from?
12:22:53 <roelof> oke, I used the versions from the website of bitemyapp That one stated this :  sudo apt-get install cabal-install-1.22 ghc-7.8.4 happy-1.19.5 alex-3.1.4
12:23:16 <roelof> wierd, the wrong one is in my answer 
12:23:23 <Cale> right :)
12:23:58 <DANtheBEASTman> trying to use stack to build ghc 7.10.2, i get this error running `stack setup` http://sprunge.us/MXRI did I miss something orr..
12:24:02 <roelof> pfff, now I have to figure out why this happens 
12:24:11 <monochrom> if 22=16, someone was using a non-decimal base. (but it's still base 10)
12:24:14 <Cale> roelof: maybe try "which cabal"
12:24:29 <Phyx-> use stack to build ghc?
12:25:25 <monochrom> is it "build" or is it simply "install"?
12:25:27 <DANtheBEASTman> Phyx-: isn't that what `stack setup` does?
12:25:32 <DANtheBEASTman> install probablly, sorry
12:25:42 <Cale> DANtheBEASTman: "resource exhausted" hmm
12:25:50 <roelof> I think I now the problem.  I had to change the path and I could not find the place 
12:26:10 <monochrom> I see "resource exhausted"
12:26:33 <DANtheBEASTman> oh is it telling me i'm out of disk space?
12:27:07 <DANtheBEASTman> d'oh. sure am.
12:29:03 <mtesseract> Could anyone help me with this: I don't really understand the advantage of using the Reader monad. What is the advantage of using "Reader a b" compared with using functions of the form "a -> b"? I mean, one has to provide the same data in both cases (the environment).
12:29:50 <roelof> oke, I have now cabal 1.22 
12:31:12 <kosmikus> mtesseract: Reader hides the passing of the argument.
12:31:30 <kosmikus> mtesseract: it's an advantage if you have lots of functions with the "a -> ..." calling each other, and the argument hardly ever changes
12:32:04 <kosmikus> mtesseract: if the argument does change all the time, then explicit passing is most likely clearer
12:32:23 <roelof> Cale:  and now installing things like tasty and tasty-quickcheck again :( 
12:34:07 <mtesseract> kosmikus: Ah! Right, so, when first entering the Reader monad by calling runReader, there is no practical advantage, as I have to pass the environment to runReader, but the situation becomes simpler if that function would have to pass that environment around further.
12:34:57 <kosmikus> mtesseract: yes, exactly
12:35:00 <mtesseract> kosmikus: Thanks.
12:35:09 <kosmikus> mtesseract: you're welcome
12:36:07 <mauke> well ... you could use monadic functions with (a ->) directly
12:36:31 <hsk3> Has any of you used CReal or BigFloat in a real program? https://hackage.haskell.org/package/numbers
12:36:37 <hsk3> (instead of Double)
12:37:10 <roelof> I have this cabal file (http://lpaste.net/147531) but now I see this error message : http://lpaste.net/147531
12:37:23 <roelof> can I better make a clean cabal project ? 
12:38:19 <hexagoxel> roelof: both are the same link
12:38:26 <mtesseract> mauke: I guess that was directed at me. So far I have never knowingly used the (a ->) monad, so I am not entirely sure how that works.
12:38:38 <roelof> hexagoxel:  what do you mean ? 
12:39:02 <hexagoxel> roelof: you pasted the same link twice
12:39:28 <roelof> I see : I mean this error message : cabal: No 'main-is' field found for executable test
12:39:48 <martinvlk> Hi, trying to build my project with the "-eventlog" ghc option, passing it on the command line or in the .cabal file, and it seems to be passing that param to GHC, yet when I cabal run it with -l, it complains that I haven't built the executable with -eventlog
12:40:10 <martinvlk> (using cabal build I should say)
12:40:16 <haskell738> why does mapM id [[1,2],[2,3]] give all the 4 results?
12:40:23 <martinvlk> any idea what might be wrng?
12:40:29 <MarcelineVQ> roelof: uncomment main-is?
12:40:43 <haskell738> ie why doesn't mapM id [[1,2],[2,3]] equal  [[1,2],[2,3]]
12:40:46 <erisco> anyone done something cool with Gloss?
12:40:48 <roelof> I did that but no luck, MarcelineVQ 
12:41:03 <MarcelineVQ> Did you point it to a file that exists?
12:41:47 <mauke> @src mapM
12:41:47 <lambdabot> mapM f as = sequence (map f as)
12:42:00 <roelof> yes, the file exist in src/main.hs 
12:42:09 <mauke> > map id [[1,2],[2,3]]
12:42:11 <lambdabot>  [[1,2],[2,3]]
12:42:13 <mauke> > sequence [[1,2],[2,3]]
12:42:15 <lambdabot>  [[1,2],[1,3],[2,2],[2,3]]
12:43:08 <MarcelineVQ> roelof: then you'll need to add the field "hs-source-dirs: src" so it knows to look in src folder
12:44:47 <MarcelineVQ> Alternatively you can just put main-is: src/main.hs
12:45:00 <erisco> hackage y u no
12:45:10 <roelof> pfff , I have changed it to this  :  hs-source-dirs:      src  but now I see this error message :  Plain fields are not allowed in between stanzas: F 20
12:45:13 <haskell738> mauke: why does sequence evaluate to that?
12:45:22 <haskell738> @src sequence
12:45:22 <lambdabot> sequence []     = return []
12:45:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:45:22 <lambdabot> --OR
12:45:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:45:24 <erisco> do they accept donations to spin up more cores for that site?
12:45:57 <NemesisD> i've got a newtype over Foo -> m (). there's a clear empty case of const (return ()), and an append which would sequence. how bad of an idea would it be for me to put this in a monoid?
12:46:24 * hackagebot OpenGL 2.13.2.0 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-2.13.2.0 (SvenPanne)
12:47:00 <NemesisD> or maybe i want Category
12:47:55 <erisco> NemesisD, the question doesn't make much sense, I don't think, because either it is a monoid or it isn't
12:48:39 <MarcelineVQ> roelof: what that means is you've put "  hs-source-dirs:" in between sections, it belong inside "executable test" just like main-is and build-depends
12:49:01 <erisco> NemesisD, if we're talking about the Monoid type class, the problem is if there are multiple monoids, because type classes are designed to have one instance per type
12:49:31 <MarcelineVQ> roelof: That way it's telling `executable test` where to find hs files
12:49:42 <erisco> NemesisD, that hasn't stopped the Prelude from making arbitrary decisions though, such as the list Monoid instance
12:49:45 <NemesisD> erisco: right. this is a newtype so my library would be choosing the monoid to implement
12:50:37 <erisco> alternatively you can stuff the empty-element and append into a data type and pass that around
12:50:40 <roelof> MarcelineVQ:  thanks 
12:51:02 <erisco> this works well when there are multiple possible monoids, but at the cost of concision
12:51:47 <NemesisD> i guess what i'm driving at is my library has a type like newtype Hook m = Hook (Foo -> m ()). there will be use cases where you want a noop and cases where you want to combine multiple hooks. from an API design perspective monoids seem attractive, but there are multiple potential ways to do the mappend
12:52:26 <NemesisD> i.e. in some cases it may be a good idea to run them in parallel, others to run them seqeuentially. so maybe i should steer clear of typeclasses and provide explicit functions for combining them
12:52:46 <erisco> if there are multiple monoids, especially if there are multiple practical monoids, you do not want to use type classes
12:53:23 <erisco> or another option, if you really need the convenience of type classes, is to write more newtype wrappers for each instance
12:53:43 <NemesisD> hmm, i think that's probably reaching the point of inconvenience
12:53:54 <erisco> but this can cost you as well, as you may need to wrap and unwrap frequently
12:53:59 <NemesisD> i can also just drop the newtype if i'm not using a typeclass and have type Hook m = Foo -> m ()
12:54:29 <erisco> it is not unreasonable to just name each empty-element and append operation uniquely and never provide Monoid instances
12:55:01 <erisco> or provide newtype wrapper instances for them, just in case someone really wants to use a Monoid-based algorithm
12:55:09 <roelof> Last question: how do I import a main.hs which I want to test where the test is in /test/test.hs ? 
12:55:21 <erisco> which is better than letting users make orphan instances
12:56:13 <erisco> I think ML-style modules have a better solution for this‚Ä¶
13:03:38 <roelof> no one who can tell me how to import the file /src/main.hs into a test which is in /tests/test.hs
13:06:01 <suppi> roelof, did you set up a cabal file?
13:06:18 <roelof> yes, I did 
13:07:11 <roelof> suppi:  here you see the cabal file : http://lpaste.net/147532
13:07:24 <suppi> did you declare the src/Main.hs file as part of a library and added setup a test-suite which has build-depends for the library?
13:08:00 <suppi> roelof, for example: https://github.com/soupi/chip-8/blob/master/chip8.cabal#L29
13:08:15 <suppi> and this: https://github.com/soupi/chip-8/blob/master/chip8.cabal#L106
13:08:18 <roelof> no, I declared main.hs as a part of a executable 
13:09:59 <suppi> I'm not entirely sure how to solve your specific problem, but maybe turn this into a library, expose the modules, and then add to build-depends for your test-suite?
13:11:15 <roelof> When I add test to the build depends I see this message : cannot satisfy -package-id test-0.1.0.0-inplace
13:11:54 <roelof> I think I stick with Stack instead of cabal.  cabal costs me now almost 2 hours to get working 
13:12:19 <suppi> ok.
13:13:20 <suppi> I don't think you can put test on build-depends unless it's a library
13:16:26 * hackagebot bytestring-arbitrary 0.1.0 - Arbitrary instances for ByteStrings  https://hackage.haskell.org/package/bytestring-arbitrary-0.1.0 (tsuraan)
13:25:22 <obiwahn> http://paste.debian.net/352465/
13:25:52 <obiwahn> how do i fix this? is it possible to make 0 an integer literal 
13:26:25 <ClaudiusMaximus> obiwahn: first two arguments to foldl are flipped
13:27:35 <ClaudiusMaximus> :t foldl
13:27:36 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:31:26 * hackagebot list-prompt 0.1.1.0 - A simple list prompt UI for the terminal.  https://hackage.haskell.org/package/list-prompt-0.1.1.0 (yamadapc)
13:34:15 <killerstorm> hi. I have a noob question about type classes. http://lpaste.net/147534 I hope it's clear what I'm trying to do and why doesn't work from the code... 
13:36:09 <mauke> what's the point of using a class for this?
13:38:49 <ClaudiusMaximus> your class says it must work for all a ; instance with String is much too specific
13:39:46 <obiwahn> ClaudiusMaximus: thank you:)
13:40:19 <killerstorm> Well my understanding (probably flawed) is that type class is sort of like an interface, I'd like to define Record as "something which has an id" without rigidly specifying the type of such id. That is, type of id might be different for different instances.
13:40:52 <mauke> how is that useful?
13:42:06 <killerstorm> I'd like to call get_id polymorphically on different types of records. Type classes can be used for polymorphism, right?
13:42:31 <killerstorm> So I can add a function constraint like (Record a) and then call get_id on record.
13:45:12 <mauke> but how are you going to use the result if you don't know what type it is?
13:49:34 <killerstorm> Well I assumed that it could figure out the types via type inference... 
13:49:45 <killerstorm> I'm curious, is it possible to define instances of this class?
14:01:28 * hackagebot binary 0.8.0.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.0.0 (LennartKolmodin)
14:08:18 <spuz> is there a guide on how to introduce IO to a pure function?
14:10:15 <jmcarthur> spuz: That seems to be a vague enough goal that I don't know what such a guide might say. Do you have a more specific description of the problem?
14:10:50 <jmcarthur> spuz: e.g. I can "introduce IO" by just using return somewhere
14:11:03 <Majiir> "Hey IO, meet id"
14:11:11 <spuz> jmcarthur, i have a function that returns a Spec, and I want it to return an IO Spec (I think)
14:11:27 <jmcarthur> spuz: Why do you want it to return an IO Spec?
14:11:29 <spuz> or in general, a function that returns a and I want it to return IO a
14:11:45 <jmcarthur> spuz: Is it just because you need to pass the result to something that expects an IO Spec?
14:11:50 <spuz> jmcarthur, so that I can do IO from within that function
14:13:01 <jmcarthur> spuz: When you are using IO you will see IO in the types naturally. So I take it your question is not how to merely tag the result with IO but how to use such a thing?
14:13:41 <spuz> I think so
14:14:04 <lingxiao> hey all 
14:14:05 <spuz> I'm not sure what the right approach is so that's why I was asking for a guide
14:14:14 <lingxiao> anyone here familiar with conduit?
14:15:11 <jmcarthur> spuz: I don't know of great guides, but do notation may be good enough to start with. Do you know anything about do notation?
14:16:04 <jmcarthur> spuz: There's a whole type discipline you will eventually learn, but I think it's okay to take mental shortcuts (just using do notation) at first. (I used to not think this way, and perhaps expect some flak for saying this.)
14:18:20 <jmcarthur> spuz: I just remembered this, which seems to follow the approach I just advocated. http://www.haskellforall.com/2013/01/introduction-to-haskell-io.html
14:19:44 <spuz> jmcarthur, i'm not sure what approach you are talking about
14:20:17 <jmcarthur> spuz: I'm talking about the approach to learning how to use IO by learning how to use do notation first instead of leaning about monads.
14:20:21 <jmcarthur> *learning
14:20:39 <spuz> ok
14:20:46 <spuz> yeah I see what you mean
14:20:48 <jmcarthur> spuz: do notation is just more likely to feel familiar
14:20:58 <spuz> i understand both to some degree though
14:22:39 <spuz> jmcarthur, I think return is what I'm looking for
14:23:02 <jmcarthur> > return 5 :: IO Int
14:23:04 <lambdabot>  <IO Int>
14:24:06 <jmcarthur> jcreekmore: I know you!
14:26:38 <hpc> https://www.youtube.com/watch?v=uEFrE6cgVNY -- interesting video on language design guided by user studies
14:44:43 <rcat>  meta
14:46:18 <lingxiao> hey all
14:46:26 <lingxiao> I would like to descriete a monadstate stack
14:46:31 <lingxiao> could someone help me here?
14:47:07 <lingxiao> It's a gernic form of StateT a (StateT b m) () 
14:47:11 <lingxiao> for MonadRandom m
14:47:37 <lingxiao> I'd like to say something like ...      (MonadState a m, MonadState b m, MonadRandom m) => m ()
14:47:39 <johnw> lingxiao: I don't really understand your question
14:47:41 <lingxiao> but that makes no sense
14:47:55 <johnw> that not only makes no sense, it would be an error
14:48:09 <lingxiao> yeah so what's the approripate way to descirebe it
14:48:19 <johnw> I don't know yet what you're trying to do
14:48:31 <lingxiao> the point is I dont want to say ahead which is on the "inisde", StateT a m () or StateT b m ()
14:48:42 <lingxiao> basically a concrete instance ves not .. .for example
14:48:57 <lingxiao> I could have A  =  StateT Int (Reader String) ()
14:49:10 <lingxiao> or B = (MonadState Int m, MonadReader String m) => m ()
14:49:35 <lingxiao> A is an explicity stack, where state is on top ... and B is saying some generic monad m equipped with state and reader fnctions
14:49:49 <lingxiao> But now I'm trying to do it with   StateT Int (State String) ()
14:50:00 <lingxiao> johnw does that make more sense?
14:50:06 <lingxiao> "do it " as in generalize
14:50:31 <johnw> I think there's more context I don't know, before I could make a decent recommendation
14:50:54 <johnw> is this for an app or a library; is it for code that others will use, or yourself; can you not use StateT (a, b) m (); etc.
14:50:54 <lingxiao> for exmaple?
14:51:16 <lingxiao> no actually both and b here are tuples of stuff already
14:51:22 <lingxiao> and conceptually they're different things
14:51:29 <johnw> also, I don't even know if nested state is the right answer to your problem, since I don't know the problem
14:51:33 <lingxiao> so suppose I want to gneralize StateT a (State b) ()
14:51:44 <lingxiao> so suppose it's right, how would i describe it?
14:52:04 <lingxiao> or forget right ...  just suppose we had to describe it 
14:52:04 <johnw> so, you want a stack which has both 'a' and 'b' components, and that's all you want to know?
14:52:13 <lingxiao> yeah
14:52:25 <lingxiao> presumably i can do :   a <- get    and b <- get
14:52:36 <lingxiao> but i dont think that will teyp check ... so it's more like:   a <- get     b <- lift get
14:52:50 <lingxiao> but that is saying State b () is "on the bottom"
14:53:08 <johnw> one sec
14:53:27 <lingxiao> ok thanks!
14:54:08 <lingxiao> and not sure if it matters, but I'd really like MonadRandom m => StateT a (StateT b m) ()
14:54:17 <lingxiao> so this monad m has randomness as well
14:55:05 <nomeata> Hmm. Hard to test compatibility with time-1.6, even in a cabal sandbox, as time is a boot library.
14:55:25 <nomeata> I guess I‚Äôll have to ignore http://packdeps.haskellers.com/feed/Joachim%20Breitner for a while
14:57:11 <lingxiao> while johnw is helpig me, does anyone know there's a way to transform a monad in the sense that at step 1
14:57:30 <lingxiao> we have a state monad, and from steps 2 onforth, we transformed it into a reader monad?
14:58:04 <lingxiao> so the setting here is computing some parameter value at somepoint during the computation and only reading that from "now" on?
14:58:23 <johnw> lingxiao: no, I don't really have an aswer
14:58:52 <Cale> lingxiao: You can run your state action, and use the final state as the environment of a reader action.
14:59:08 <lingxiao> johnw : for my first question?
14:59:15 <lingxiao> ahh that makes sense thanks
15:01:45 <spuz> jmcarthur, I actually have something that works: https://gist.github.com/alexspurling/32c808d22a8046f13c99
15:01:56 <spuz> can it be made simpler though?
15:02:26 <lingxiao> Cale could you answer my first question?
15:02:35 <spuz> I am using two dos to unpack two different monad types. Maybe there is a shortcut to this?
15:02:47 <lingxiao> which is how do i generalise    MonadRandom m => StateT a (StateT b m) ()
15:02:58 <Cale> You don't use more than one StateT usually
15:03:00 <lingxiao> into something like (MonadRandom m, MonadRandom a m, MonadRandom b m) => m ()
15:03:08 <lingxiao> which makes no sense ---^
15:03:10 <lingxiao> Cale ah how come
15:09:23 <jmcarthur> spuz: Yay!
15:10:03 <jmcarthur> spuz: It could be made more terse by using fancy combinators instead of do notation, and I could show you how, but I don't think it's the most productive use of a beginner's time.
15:10:23 <jmcarthur> spuz: It's not bad as is, really.
15:10:24 <spuz> heh thanks
15:10:45 <spuz> I wish someone had told me this two days ago when i started down this path
15:10:47 <spuz> :p
15:15:16 <Cale> lingxiao: Because one is enough -- you can always combine the state types
15:16:04 <Cale> lingxiao: and using explicit lifting is bad anyway -- you want to quickly get to the point where you've hidden the fact that StateT is in use
15:16:30 <lingxiao> ok i'm not sure what to do then
15:16:46 <Cale> lingxiao: So usually, just one StateT whose state type is a record of all the things you're manipulating at once will do nicely
15:16:48 <lingxiao> because the a and b in StateT a (StateT b m) ()  are tuples themselves
15:17:50 <Cale> (This is assuming that StateT is even a good idea at all... I see a lot of pretty questionable uses of it)
15:18:35 <lingxiao> could you take look at this?
15:18:35 <lingxiao> http://lpaste.net/147542
15:18:41 <lingxiao> I'm not sure what to do then
15:18:46 <lingxiao> really i want a reader and state
15:19:23 <lingxiao> it's kind of long. ... i had to paste  bunch of stuff form different files into one big file
15:19:58 <Cale> That's all right, it's much better than getting vague abstracted stuff that doesn't necessarily characterise your application :)
15:21:12 <rvxi> hpc that is an interesting video
15:21:19 <Cale> Okay, so the first thing I would think about doing to this perhaps is to focus on this "Some m" constraint, and figure out what operations are really important. Maybe just start out by defining that as its own type class, with operations separate from MonadReader and MonadState etc.
15:21:53 <Cale> They should look more application-specific than "put" and "ask"
15:22:13 <vektor> Hey guys! I'm looking for a way to find out the names and signatures of all Functions in scope within a file. If it's in a reasonable haskell data format, then all the better. Ideas?
15:23:42 <lingxiao> uhh but it's literally putting and asking though?
15:23:59 <lingxiao> there's nothing fancy goig on here ... i need to compute some parametsrs and look it up 
15:23:59 <Cale> lingxiao: That's okay, but you could have the operations say *what* you're putting and asking for
15:24:31 <Cale> and that lets you have separate operations for getting/putting various parts of the data which are available
15:25:16 <hpc> rvxi: unfortunately the parts i was most interested in are the parts they didn't have data for
15:25:33 <vektor> I'm aware of ghci's :browse Command btw, and that's probably the route I would chose. Import all the stuff that's supposed to be in scope into ghci, :browse it and parse the result. Seems tedious though.
15:25:34 <lingxiao> so youre saying   putFoo  and putBar?
15:25:38 <Cale> yep
15:25:46 <hpc> for loops being found unreadable was surprising, but logical in retrospect
15:25:52 <Cale> At the same time, this gives you an opportunity to control how state gets updated -- maybe you just want the user to set it freely, but sometimes not every state is really valid and you'd like to make sure they build it up in a sane way.
15:25:53 <lingxiao> so I'd have some big nested record Record a b = R a b
15:26:02 <lingxiao> and putFoo and putBar operate on it?
15:26:03 <Cale> It can be nested or flat
15:26:17 <lingxiao> or but the poin is to declare such a thing?
15:26:19 <lingxiao> point*
15:26:36 <Cale> Well, yeah, that'll be in the instance of your new type class.
15:26:54 <Cale> For the monad type you construct (possibly using StateT)
15:26:55 <rvxi> hpc programming languages and software development is one of the few fields where people seem determined to leave things to subjectivity
15:26:55 <geekosaur> vektor, it might be less tedious than the other way, which requires deling into ghc-api
15:27:00 <geekosaur> *delving
15:27:04 <lingxiao> im hesitant to declare new typeclass because it seems like "overdesing"
15:27:18 <Cale> Well, this is sort of an intermediate step
15:27:24 <lingxiao> wait you're saying declare a new type class  right?
15:27:29 <Cale> yes
15:27:47 <Cale> But you're right, it's questionable whether having that type class in itself is a bit much
15:27:50 <lingxiao> see another issue here is that once i compute the parameters ... they really should be read only
15:28:00 <rvxi> hpc maybe because there's such a high cost to learning, there's an inherent conflict of interest
15:28:18 <lingxiao> yeah my attitude w/ typeclasses is that if I can't find it in a paper somewhere it's prob not worth it :D
15:28:33 <shirt> data IntList = IntListNull | IntList Int IntList
15:28:33 <hpc> or a blindness from having invested enough time that it becomes easy
15:28:39 <shirt> How can i make IntList an instance of Traversable?
15:28:40 <rvxi> hpc the other day, i was talking to someone who couldn't understand how matlab could be a bad language when "you get so much done"
15:28:42 <lingxiao> but I dont know how to do what you had initally suggeested ... everyting will be lifted into conduitM
15:29:03 <Cale> lingxiao: So, you can do things at the type level to try to ensure client code can't even *try* to set something more than once, but that takes you out of the realm of ordinary monads into something like indexed monads.
15:29:04 <lingxiao> so i wnt something like     source ~> initPram ~> initStore ~> update
15:29:21 <lingxiao> indexed monads heh maybe another day
15:29:29 <Cale> However, as an intermediate level of safety, defining this type class of operations will let you do runtime checks
15:29:50 <vektor> geekosaur: I know :D Then again, there's easy to use tools like haskell-src-exts. I've already thought, maybe the output of ghci is in a format that Language.Haskell.Exts.Parser can parse. 
15:29:52 <hpc> rvxi: i have had a similar revelation about spreadsheets (which makes me want to retry learning frp but that's another story)
15:29:53 <Cale> Because you get to define the setters to check whether the thing is already set, and perhaps throw an exception or something.
15:30:11 <hpc> rvxi: where vlookups and pivot tables and google docs' embedded queries are pretty objectively awful
15:30:21 <hpc> but you can do an amazing amount of computation and representation of data
15:30:46 <hpc> and it's not hard when you're good at it, but there's many pitfalls
15:31:17 <Cale> But yeah, then the next step is to decide whether you really need the type class, or whether you might be better off just using a record data type with fields for each of the operations of what would have been your class.
15:31:59 <rvxi> hpc you can have a short OODA loop you can get with repl/spreadsheet workflows. haskell should have  a better R Shiny  type of solution to bury that type of competition.
15:32:15 <hpc> yeah
15:32:21 * hpc is also a fan of R
15:32:27 <rvxi> hpc like http://david-peter.de/articles/flare/
15:32:28 <hpc> (but still hates matlab)
15:32:35 <Cale> This can be cool if you're ultimately just going to implement the thing over IO, because you can just implement the getters and setters in terms of IORef or something then
15:32:52 <Cale> But you still get the nice abstraction where you have types like:
15:33:16 <Cale> update :: Some m -> Streaming Event m ()   -- where Some is now a record type rather than a class.
15:33:30 <Cale> Maybe it should be:
15:33:41 <Cale> update :: (Monad m) => Some m -> Streaming Event m ()
15:33:51 <Cale> but yeah, hopefully it makes sense what I'm saying :)
15:33:52 <rvxi> hpc R is still >> matlab (although this person thought matlab was superior due to performance). i'm starting to get weary of the dynamic programming bugs in R code. R can seem much worse than it is because it attracts really bad programmers.
15:34:18 <hpc> rvxi: i would be more generous, it attracts non-programmers
15:34:19 <Cale> So, you'd have something like  data Some m = Some { getFoo :: m Foo, setFoo :: Foo -> m (), ... }
15:34:35 <hpc> rvxi: statisticians are the target audience for R in the same way secretaries are the target audience for excel
15:34:54 <rvxi> hpc i'd like to swap in haskell for R, but the lack of numerics and scientific computing ecoystem holds me back
15:35:16 <hpc> yeah
15:35:32 <hpc> ive been converting a spreadsheet to sql and using it as an excuse to finally use views and procedures
15:35:36 <Cale> and then you can write an IO action which builds a Some IO record by making some IORefs, or you can write a more pure one which uses StateT
15:35:49 <hpc> i have bumped into a lot of limitations but i still don't want to use haskell either
15:36:00 <Cale> Anyway, just something to think about
15:36:32 <rvxi> hpc i have to say shiny is ridiculously productive for what it does. like data dashboard/webapp in 20 mins. what would you rather use? i think if haskell had the ecosystem for scientific computing and numerics i'd be pretty content.
15:36:36 <Cale> lingxiao: Does that roughly make sense?
15:36:47 <lingxiao> Cale yup staring at my code right now!
15:36:50 <lingxiao> thanks for the tip
15:36:54 <hpc> will check it out
15:37:02 <lingxiao> yea it's looking pretty ugly the way it stantds
15:37:37 <rvxi> hpc have you tried haskellR?
15:37:51 <hpc> no
15:38:31 <rvxi> i've used it superficially, inline-R is still a bit finicky / underdocumented. but hopefully it'll mature.
15:41:18 <hpc> i found out that (mysql at least) has variables you can define mid-query, and there's some nuts stuff you can do with it
15:41:22 <hpc> and i have been exploring it
15:41:49 * hackagebot yesod-content-pdf 0.2.0.2 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.2.0.2 (alexkyllo)
15:42:40 <hpc> basically a state machine that runs over the query results inline
15:45:43 <killerstorm> mauke: It turned out that the problem can be solved using multi-param type classes and functional dependencies
15:48:36 <lingxiao> Cale oh boy a lot of wisdom just went my way ... I have to copy and paste this and think about it :D
15:48:37 <AbelianGrape> Are there any serialization formats a la json or msgpack, except that all serialize values are statically typed? (That is, the structure of the serialized value is known at compile time)
15:48:57 <Cale> lingxiao: :D
15:50:49 <ClaudiusMaximus> AbelianGrape: xml has schemas and/or dtd, there's a dtd to haskell datatype conversion tool too (think it's part of haxml maybe?)
15:56:05 <Cale> You could make a wrapper around Aeson's Value type with a phantom type parameter, I suppose.
15:56:11 <Cale> I don't know if anyone's done it.
15:56:13 <Majiir> AbelianGrape, I think YAML can do types?
15:56:50 * hackagebot riak 0.9.1.0 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-0.9.1.0 (lambda_foo)
16:07:20 * hackagebot lambdatex 0.1.0.0 - Type-Safe LaTeX EDSL  https://hackage.haskell.org/package/lambdatex-0.1.0.0 (Norfair)
16:30:55 <c_my_nick> i have a particular library that i like to use and i find myself copy/pasting the same helper functions over and over and would like to put them into a separate library
16:30:56 <c_my_nick> i dont expect others to want to use them, but i could imagine others writing a similar lib (and maybe i would like to use theirs), so is there a way i should be naming my package to avoid conflicts?
16:33:30 <jmcarthur> c_my_nick: Maybe you could make a pull request to try to get the function into the library itself?
16:33:55 <jmcarthur> Assuming it's open source, and using whatever variation of "pull request" makes sense for the VCS and hosting of the project.
16:37:22 * hackagebot sync-mht 0.3.8.4 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.8.4 (emink)
16:37:23 <c_my_nick> jmcarthur: they arent really generic enough to go there (at least i dont think so).  the library i am depending on is snap
16:38:18 <jmcarthur> Well, I think the way you name the package depends on how likely it is that anybody wants to use it.
16:38:51 <jmcarthur> If you think think you are virtually the only person who wants to use it, it could be called snap-c_my_nick-helpers.
16:39:26 <jmcarthur> If you think most users of snap might want to use it, something generic makes sense.
16:40:16 <c_my_nick> is that a common convention?  putting your name in the package name?
17:07:39 <jmcarthur> c_my_nick: I don't know about common. I've seen it before. I think it's a good idea if you think the package is very specific to you. It shows others how you really intend it to be used.
17:08:08 <jmcarthur> c_my_nick: Basically "I use this. You can use it, too. It's mostly just for me, though."
17:08:24 <c_my_nick> alright, thanks
17:10:14 <Hi-Angel> Could anybody tell, why is the strange type mismatch in this little function http://lpaste.net/147552 ? I tracked down an error to this little example, but I still don't understand, what's wrong ‚Äî basically, both ¬´a¬ª and¬†¬´b¬ª types are have the same constraints‚Ä¶
17:12:24 * hackagebot typelits-witnesses 0.1.0.0 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.1.0.0 (jle)
17:13:06 <jle`> Hi-Angel: your type signature for y is Num b => b
17:13:15 <jle`> which means that y can be *any* Num instance you desire
17:13:22 <jle`> that is, the caller desires
17:13:35 <jle`> so i could do (y :: Int), (y :: Double), (y :: Float), etc., and it'd work
17:13:59 <jle`> but the way you implemented it, it can only be one specific Num instance --- the `a` in your original type signature
17:14:32 <jle`> so, I couldn't use (y :: Double), because y can only be exactly the same Num instance that `f` contains
17:14:46 <jle`> so if `f :: Foo Int`, then y must necessarily be :: Int
17:15:25 <jle`> easiest solution here would be to just get rid of the type signature
17:15:42 <jle`> this is similar to saying something like: foo :: Int; foo = "hello"
17:15:54 <jle`> er, or maybe, foo :: Num a => a; foo = True
17:16:09 <jle`> ah, the better example would be foo :: Num a => a; foo = (1 :: Double)
17:16:26 <jle`> the type signature for `foo` promises that you can ask for foo as any Num instance you want.  but the implementation only provides a Double
17:16:55 <Hi-Angel> Ah‚Ä¶ Okay, thank you!
17:18:56 <jle`> Hi-Angel: you really wanted y :: a as your type signature for `y`, because it only is the exact same `a` that's in `f :: Foo a`.  but you need to enable ScopedTypeVariables to let that work, because by default in normal haskell, the 'a' in your top level type signature isn't assumed to be the same 'a' in the helper's type signature by GHC, heh
17:19:37 <jle`> so the simplest thing would probably just to not have the type signature.  else, enable the extension and write func :: forall a. Num a => Foo a -> a, and then y :: a should work
17:21:06 <Hi-Angel> Ah, interesting, now I know for what are these ¬´forall¬ª's ‚ò∫ Thank you!
17:21:37 <Hi-Angel> I mean, I have read, but never yet understand. Now I see ‚ò∫
17:24:02 <jle`> Hi-Angel: actually, this is sort of a different 'forall' than how they're often used...it's a bit unfortunate that they just share the same syntax as other extensions/sorts of ideas
17:24:37 <jle`> in this case their sole purpose is to define a scope for `a`, saying that "this `a` is in scope for the entire body of this declaration, for all type signatures inside it to use"
17:27:25 * hackagebot typelits-witnesses 0.1.0.1 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.1.0.1 (jle)
17:30:17 <khole> writing an irc trivia bot that uses STM for some shared game state. I opted to return IO actions from my STM code, with a helper function applySTMIO t = do {a <- atomically t; a}. But I've had a trouble writing clean code this way, any tips?
17:37:27 <exio4> khole: what are you currently doing? there might be a simpler approach
17:37:58 <exio4> khole: (or an easy way to wrap everything and make it nicer...)
18:03:09 <mccartyio> I'm working on solving a problem for an online judge (in haskell, of course) , and would like some guidance on improving the speed of my program, would this be the correct channel to ask for help in?
18:07:11 <jle`> mccartyio: sure :)
18:08:35 <mccartyio> https://github.com/nmccarty/kattis/blob/master/src/ExcellentEngineers.hs This is the code for the problem I am working on
18:08:45 <mccartyio> I am working on uploading the test data set im using
18:09:46 <khole> exio4: here's a snippet to give you an idea http://lpaste.net/8419063909448679424
18:10:10 <khole> the "applySTMIO $ updateQuestions" is the important bit
18:11:44 <mccartyio> test data: https://www.mccarty.io/sample.txt
18:12:06 <hexlord> Is haskell faster than python
18:13:00 <mccartyio> hexlord: short answer: yes, long answer made short: it depends
18:16:45 <pilne> python is a scripting language that has been extended into some aspects of systems programming, haskell is a systems language that has some scripting tools available.
18:16:57 <bitemyapp> hexlord: most of the time unless you do something really silly.
18:20:59 <jle`> nshepperd: packaged up your combinators into a package on hackage, if you were still interested :) http://hackage.haskell.org/package/typelits-witnesses
18:24:51 <nshepperd> jle`: neat!
18:31:16 <lingxiao> hey all
18:31:21 <lingxiao> how do you profile space complexity of some haskell function?
18:32:17 <mccartyio> speaking of quite silly things, i did something quite silly myself 
18:33:02 <mccartyio> again code: https://github.com/nmccarty/kattis/blob/master/src/ExcellentEngineers.hs test data: https://mccarty.io/sample.txt
18:33:08 <mccartyio> if anyone would mind taking a look
18:33:27 <jle`> mccartyio: did you profile?
18:33:35 <mccartyio> I did some profiling and it seems to be bound up in the getEngineer function, and I don't really see a way to improve it
18:33:37 <jle`> do you know if there's a bottleneck in particular?
18:33:58 <jle`> hm
18:34:09 <jle`> tuples are lazy by default, so making your own Engineer type with strict fields might help
18:34:27 <jle`> also, switching from String to Text is a sort of low-hanging-fruit kinda thing
18:34:46 <mccartyio> Ill give the string to text thing a go and see what happens
18:35:02 <jle`> but yeah, the $! you have on line 64 is essentially useless
18:35:21 <jle`> because you're just evaluating the tuple to WHNF, which evaluates the (_,_,_), but nothing inside
18:35:57 <jle`> and you're doing a lot of plumbing to work with Engineers with pseudo-record-accessors (communication, programming, algorithms)...why not just make it a real data type with record accessors and strict fields?
18:38:55 <mccartyio> jle`: pardon me if the answer is obvious, but how do strict fields work on records
18:40:10 <jle`> if you had Engineer !Int !Int !Int, then whenever the constructor is resolved, the fields are resolved, as well
18:40:43 <jle`> in contrast to (_,_,_), where the constructor (the 3tuple-ness) can be resolved, but the fields themselves can still be unevaluated
18:41:16 <jle`> for situations like this, it doesn't really make sense to have an Engineer with individual Int's potentially unevaluated
18:42:53 <jle`> the Engineer itself is still "lazy" -- length [Engineer undefined undefined undefined] will still be 1
18:43:37 <jle`> but, evaluating an Engineer will be all-or-nothing
18:53:51 <mccartyio> jle`: I can say that making Engineer strict has made the program about 40% faster for large inputs, thanks for the reccomendation
18:54:06 <mpickering> Say I have [BigThing] and I want to ensure that only one BigThing is loaded into memory at once, is there a way to guarantee this with minimal dependencies?
18:54:22 <mccartyio> unfortunatly I dont think this problem judge allows using Text, so lets see if that alone is enough to pass the tests
18:54:30 <mpickering> I know the way to do this is to use a coroutines library 
18:54:42 <mpickering> but is there some folklore method which I can use if I can't depend on them?
19:00:03 <wedens> mpickering: sounds like some pool
19:00:35 <jle`> mpickering: well, the core of pipes is only a few lines
19:00:45 <jle`> so you could probably just hack your own pipes
19:00:49 <jle`> and use that
19:00:59 <mpickering> sure, I was actually thinking it wouldn't be too bad to reimplement 
19:01:09 <mpickering> thanks for the push 
19:01:28 <jle`> np, gluck!
19:01:42 <mpickering> especially as I only need data flowing in one direction 
19:02:32 <jle`> i think Tekmo keeps a gist somewhere of like, the 100-line core of one-directional pipes
19:06:07 <mccartyio> jle`: Thanks for the help so far, turns out this judge rightly considers Text a part of the haskell standard library, and using it instead halved the run time
19:06:16 <jle`> hooray
19:06:25 <mccartyio> still not quite there, but ill see what progress i can make on my own 
19:11:04 <lamefun> is there a GUI alternative to putStrLn?
19:11:18 <lamefun> i.e. console, but not console.
19:18:28 <mpickering> I think the easiest is to depend on pipes in dev and then inline the relevant stuff 
19:21:13 <Cale> lamefun: I'm not sure what that means.
19:21:22 <Cale> lamefun: Which GUI?
19:21:28 <lamefun> Cale, wait
19:21:38 <mccartyio> jle`: I didn't entirely switch to text last time, now i did and the runtime is about 15 times less than the original program
19:21:50 <jle`> haha, nice
19:22:30 * hackagebot typelits-witnesses 0.1.1.0 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.1.1.0 (jle)
19:25:07 <lamefun> Cale, Something like http://lpaste.net/6033092190769512448 --> http://i.solidfiles.net/12981c25cd.png 
19:26:18 <Cale> I dunno, but I could implement something quite similar using Reflex
19:26:35 <Cale> (and reflex-dom)
19:27:36 <Majiir> I'm having a problem getting lambdabot to work, and my search through #haskell logs has found other people with the same problem--and no solutions :-(
19:27:51 <Cale> lamefun: Is that a mockup, or what?
19:28:02 <Cale> I mean, if it's not a mockup, why did you ask? :)
19:28:10 <Majiir> so I guess I'll repeat the ritual of asking here: What's the deal with this when doing a simple eval like 2+2? mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
19:28:24 <lamefun> Cale, it's just some toy code I wrote (it works though).
19:29:52 <lamefun> is Reflex DOM GHCJS?
19:30:01 <Cale> It's both GHC and GHCJS
19:30:09 <Cale> You can compile in GHC and get a Webkit application.
19:30:31 <Cale> Or compile in GHCJS and get something using Javascript that'll run in a web browser
19:38:03 <hodapp> oooh. This is the first I've heard of Reflex
19:45:08 <Majiir> For reference for anyone reading the logs and having my issue! ...you need to copy Pristine.hs from the source dir to ~/.lambdabot/State/
19:46:20 <Cale> Majiir: aha. I would've known that Pristine.hs was supposed to be in ~/.lambdabot/State/ but I wouldn't have known it would be missing :)
19:46:46 <Majiir> Cale: It's there, but it's created empty, and it wasn't immediately obvious to me that the contents were important
19:46:53 <Majiir> I figured blank was pretty pristine!
19:46:54 <Cale> oh, that's interesting
19:47:27 <Cale> Yeah, the way it works is that lambdabot loads L.hs, and every time someone does a @undefine then Pristine.hs is copied over L.hs
20:50:19 <jle`> i wonder what votes are supposed to be for on hackage
20:52:24 <geekosaur> supposedly for a community rating system for packages
20:53:04 <jle`> so, vote on the ones you like?
20:53:14 <jle`> does a non-vote count as a vote against?
20:54:02 <geekosaur> I don't think anyone worked it out that far, and since the community seems to have voted against hackage itself I'm not sure it matters
20:54:29 <jle`> mk. i'll just keep on voting things that i like
20:54:47 <jle`> if non-votes don't count as votes against, then a vote literally has 0 bits of information
21:00:11 <lingxiao> hey all
21:00:32 <lingxiao> has anyone tried to quickcheck some computation that is a monadRandom m?
21:00:55 <lingxiao> and knows how
21:01:59 <lingxiao> ping geekosaur jle` any thoughts?
21:02:28 <jle`> well you can test it on Rand StdGen, perhaps
21:02:43 <jle`> but it depends on what sorts of properties you'd want to be testing
21:03:05 <bitemyapp> lingxiao: http://blog.functorial.com/posts/2012-08-04-Testing-Random-Properties-With-Type-Classes.html
21:04:09 <bitemyapp> lingxiao: but yeah what jle` said. Pick a concretion, make it go.
21:04:36 <lingxiao> I'm testing that a randomized algorithm is reasonably close to a determinstic algorithm
21:05:27 <lingxiao> but first i need to get a list by     take 100 <$> getRandomRs (0,n :: Int)
21:05:41 <lingxiao> so I'm using quickcheck to give me that n for some positive n
21:05:55 <dramforever> More on my code that got much slower optimized: I have code like do {... let ct = slow function call; replicateM_ cnt (use value ct) }, and ct was somehow moved into the call to (use value ct) after optimization, which made the program much slower. I just found out that changing to "let !ct = ..." fixed this
21:05:57 <lingxiao> then generating a list ... and running the randomized algorithm against the determinstic one
21:06:34 <dramforever> here's Main.hs http://lpaste.net/147428, and just in case it really matters, ChairTree.hs http://lpaste.net/147427
21:07:45 <dramforever> Has anyone seen this before? Should I report a bug or is there a duplicate? (I don't really know how to explain my problem to the search box, sorry)
21:09:06 <dramforever> Well I guess I'm facing the problem of explaining the algorithm...
21:13:13 <dramforever> ok I'm fed up. going to reddit
21:42:40 * hackagebot warp 3.1.11 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.11 (KazuYamamoto)
21:42:42 * hackagebot warp-tls 3.1.5 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.1.5 (KazuYamamoto)
22:07:07 <dramforever> More investigation done, ticket filed, there you go https://ghc.haskell.org/trac/ghc/ticket/11271
23:28:20 <TheUndead> exit
23:55:38 <roelof> hello, anyone who uses Haskell on koding.com or c9.io ? 
23:57:55 <xxmissingnoxx> noob question: When install packages via cabal install, what the recommended location to which packages should be installed? I ask because ghci doesn't seem to be able to find packages after install. I believe my current cabal install-users config flag looks like /Users/haskelllovingperson/Library/Haskell/$compiler/lib/$pkgid.
23:59:33 <ReinH> xxmissingnoxx: use cabal repl
23:59:49 <ReinH> don't worry about where cabal installs things
