00:01:01 <geekosaur> (That's ReadS which is the user exposed part; ReadP is the underlying parser type)
00:06:28 <geekosaur> anyway ReadP/ReadS predates Applicative/Alternative considerably (this is after all part of Haskell98). current implementation *uses* Applicative/Alternative, (+++) is implemented with (<|>)
00:08:06 <varaindemian> bartavelle: oh, so you follow fp101x
00:09:10 <varaindemian> bartavelle: well I did not understand too much from section 7 Parsers and Monads
00:10:02 <varaindemian> there are new keywords they introduced and and they barelly talked about that
00:11:37 <varaindemian> bartavelle: where can I find more info about parsing?
00:24:08 <tdammers> hmm, is there a way to cross-compile a Haskell project for OS X from Linux?
00:24:29 <dmj> llvm maybe
00:30:02 <phadej> docker
00:30:03 <geekosaur> afaik there's no (legal) way to get system libraries for a cross-compile toolchain on linux
00:30:35 <phadej> which wouldn't classify as cross-compile though :)
00:30:51 <bartavelle> varaindemian, I am not really following it, just glanced at the material
00:31:02 <bartavelle> (and was wrong in my interpretation of what +++ was !)
00:31:33 <bartavelle> varaindemian, I *think* that for learning about parsing a good exercise is to start with a Parser type and write some combinators and the functor/applicative/alternative/monad instances
00:31:38 <geekosaur> my first guess was the one from Arrow, esp. since Arrow partially inspired Applicative/Alternative, but hayoo put me straight
00:32:12 <geekosaur> I had forgotten that (+++) was part of the Haskell98 ReadP stuff
00:35:23 <bartavelle> that's what is funny about this FP101x course, it is hugs based ...
00:39:59 <Hi-Angel> Have anybody worked with «State» monad? I'm wondering — after one does «oldstate <- get», next executes «put something» — does now the bound «oldstate» still holds the old state? Or is it updated now?
00:40:22 <bartavelle> Hi-Angel, it is immutable, so it is not updated
00:40:28 <Hi-Angel> Thank you!
00:43:08 <mauke`0> getPut newstate = do { oldstate <- get; put newstate; return oldstate }  -- perfectly fine code; returns old state
00:43:33 <mauke`0> (for bonus points, rewrite without do using Applicative)
00:43:59 <Hi-Angel> Hm… Then I am very puzzled. I stumbled upon this little 3 lines function http://pastebin.com/rNg7aqt3 It is actually just the «State» monad. So, it seems that this is buggy, right? Because with disregard whatever it does in the body, it always returns the old state?
00:44:25 * hackagebot wai-middleware-caching-redis 0.2.0.0 - Cache Wai Middleware using Redis backend  https://hackage.haskell.org/package/wai-middleware-caching-redis-0.2.0.0 (yogsototh)
00:44:29 <liste> Hi-Angel it returns the old gid
00:44:33 <liste> but modifies state
00:45:01 <Hi-Angel> And the state returned with this gid?
00:45:11 <liste> no state is returned, just modified
00:45:26 <liste> (I think the old gid is the id of the thing inserted)
00:45:39 <Hi-Angel> But wait, Haskell have no mutable state, aren't it?
00:45:56 <Hi-Angel> So whatever wasn't returned have to be lost o.o
00:46:16 <bartavelle> Hi-Angel, you can have reference to mutable stuff (like MVar), but this will happen in the IO monad
00:46:28 <mauke`0> bartavelle: ?
00:46:31 <liste> Hi-Angel the state threading is implicit
00:46:59 <bartavelle> mauke`0, that was probably not very exact nor very informative :)
00:47:13 <mauke`0> bartavelle: mainly non sequitur. this has nothing to do with State
00:47:32 <bartavelle> mauke`0 this was in response to "Haskell have no mutable state"
00:47:46 <mauke`0> bartavelle: context is http://pastebin.com/rNg7aqt3
00:48:22 <Hi-Angel> How then that state threading is implemented?
00:48:40 <liste> @src State
00:48:40 <lambdabot> Source not found. Where did you learn to type?
00:49:03 <mauke`0> Hi-Angel: 'State s a' is sugar around 's -> (a, s)'
00:49:16 <Hi-Angel> @src Control.Monad.Trans.State.Strict.State
00:49:16 <lambdabot> Source not found. You type like i drive.
00:49:20 <mauke`0> i.e. a "state action" is a function that takes an old state and returns both a result and a new state
00:50:06 <Hi-Angel> Ah, so gid is actually returns the new state too
00:50:06 <mauke`0> get = \s -> (s, s)
00:50:16 <mauke`0> put x = \s -> ((), x)
00:51:17 <Hi-Angel> Ah, okay, I think I get it, So, «return gid» is actually returns not just gid, but also (implicitly) the new state!
00:51:19 <Hi-Angel> Thank you!
00:51:24 <liste> Hi-Angel exactly
00:52:05 <mauke`0> it might be a good idea to implement runState/get/put/Functor/Applicative/Monad for your own 'newtype MyState s a = MyState (s -> (a, s))'
00:52:14 <mauke`0> it's a good exercise
00:52:27 <Hi-Angel> Thank you!
00:54:25 * hackagebot git-fmt 0.4.1.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.4.1.0 (hjwylde)
01:23:26 <FPtje> So I have elm-compiler and the elm-make cabal packages. I want to change things in elm-compiler and see how it affects elm-make. What I try to do is cabal install --force-reinstalls after I change elm-compiler, but then when I try to build elm-make, it says it can´t satisfy dependency elm-compiler-0.16-2d6df4ca434841361ad4b372e90b40a6. Surely I´m doing something wrong, but what?
01:24:10 <mauke`0> https://wiki.haskell.org/Cabal/Survival#Issue_.233_--_using_.27--force-reinstalls.27
01:25:33 <FPtje> ok, so force reinstalls will break things. How would I then work on a package and install changes?
01:31:26 <FPtje> Removing the package through ghc-unregister, then cabal configuring all packages and reinstalling everything works, but surely this isn´t the ideal workflow?
01:34:40 * hackagebot HDBC-odbc 2.5.0.0 - ODBC driver for HDBC  https://hackage.haskell.org/package/HDBC-odbc-2.5.0.0 (anton_dessiatov)
01:35:06 <Hi-Angel> FPtje, I am not sure, but I think you could try «Stack» — it seems to handle things better than cabal.
01:35:39 <FPtje> Hi-Angel, I heard that yesterday too, is there so much hate towards cabal?
01:36:14 <MarcelineVQ> So negative :> You could think of it as love towards stack
01:37:07 <FPtje> Well to be fair, cabal is stressed not to be a package manager, but it still tries to do half the things of a package manager
01:37:32 <FPtje> when its package manager features don´t work as one would want, people quickly point out that it really isn´t a package manager
01:38:21 <brabella> I still like cabal for when I want it as a system...
01:38:35 <brabella> like pandoc or xmonad
01:39:01 <FPtje> want it as a system?
01:39:40 * hackagebot statsd-client 0.1.0.0 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.1.0.0 (keith_duncan)
01:39:42 * hackagebot logplex-parse 0.1.0.0 - Parse Heroku application/logplex documents  https://hackage.haskell.org/package/logplex-parse-0.1.0.0 (keith_duncan)
01:39:54 <FPtje> I´m not sure what you mean
01:40:43 <tdammers> FPtje: cabal isn't a package manager any more than npm, gem, composer, etc., are, but at least people are a bit more honest about this fact
01:41:21 <brabella> i meant like not sandbox and paths and enviroments that make it hard for me
01:41:33 <brabella> but I just began using stack, so no idea
01:42:38 <FPtje> tdammers, sure, but does that mean the annoyances of its features should be left like they are?
01:42:51 <FPtje> Would reinstalling a package in npm break things?
01:45:00 <brabella> I thing it does, at least my coworkers had many problems with different compiler versions...
02:00:37 <frerich> Is Ben Gamari here?
02:02:06 <phadej> frerich: bgamari
02:03:57 <bgamari> frerich, at your service...
02:04:39 <frerich> bgamari: Ah, hello there :-)
02:04:41 <frerich> phadej: Thanks!
02:04:52 <bgamari> frerich, hello!
02:05:58 <frerich> bgamari: I saw your recent mail to haskell-cafe about the DocBook -> RST transition and forwarded it to a colleague of mine who's tasked with doing something very much like that: converting a 800+ pages DocBook-based user guide to "something better". He was toying with using Sphinx and your decision to go with RST really resonated. I wonder,
02:06:18 <bgamari> frerich, ahh
02:06:25 <bgamari> What other options have you been considering?
02:06:34 <frerich> bgamari: do you maybe have some other mails or blog or something like that sharing how you approached the conversion, other than https://ghc.haskell.org/trac/ghc/wiki/UsersGuide/MoveFromDocBook ? My understanding is that you did the initial conversion with pandoc and then did manual tweaking?
02:06:49 <bgamari> right
02:06:55 <bgamari> I didn't write too much about the process itself
02:07:18 <bgamari> for what it's worth my pandoc branch can be found here, https://github.com/bgamari/pandoc/tree/ghc-users-guide
02:07:25 <frerich> bgamari: AsciiDoc and some Markdown flavor were other candidates. It was clear that we want something whih a) can generate HTML + PDF b) has simpler tooling and c) is convenient to modify with plain text editor (think vim/emacs)
02:07:31 <bgamari> but it's really not for general consumption
02:07:47 <bgamari> frerich, it may be that markdown is fine for you in the case
02:07:49 <frerich> The XSLT-based DocBook toolchain is a bit of a pain, let alone the entire LaTeX stuff you need for PDF...
02:08:03 <bgamari> it really depends upon how rich you want your markup to be
02:08:19 <bgamari> Markdown is nice in that it has a wide range of tools
02:08:27 <zoku> Cale: Sorry I had to leave work. Thanks much for the advice
02:08:30 <bgamari> unfortunately it was just too limiting for us
02:08:53 <bgamari> the conversion would have been just too lossy
02:08:54 <frerich> bgamari: The tiny bit you quoted from the GHC UG (the one with <replaceable>) looked very much like what we use. I'm currently skimming https://github.com/ghc/ghc/tree/ghc-7.10/docs/users_guide to learn more - in general, we use a *lot* of semantic output (we even use <acronym> or <guilabel> or so)
02:09:06 <bgamari> ahh
02:09:20 <bgamari> yes, you sadly may need to decide how much this is worth to you
02:09:27 <bgamari> I wish the ReST had a better story here
02:09:46 <zoku> > 140/3.0
02:09:47 <lambdabot>  46.666666666666664
02:09:52 <zoku> > 140/30.0
02:09:54 <lambdabot>  4.666666666666667
02:09:56 <bgamari> One of the things that does bother my about ReST is how stale the docutils project itself is
02:09:59 <tdammers> so how does one instruct ghc to build OSX binaries through llvm?
02:10:13 <frerich> bgamari: Well, quite frankly - not much. We pushed for keeping as much semantic information as possible to at least have it in case we can make good use of it somehow. We never really did anything with it (e.g. we considered generating a glossary out of all the <acronym> elements, but never actually did that)
02:10:13 <bgamari> there has been nearly no effort to move the syntax forward
02:10:24 <frerich> bgamari: Maybe it's "done"? :-)
02:10:29 <bgamari> and the ReST documentation itself looks like it was produced in 1992
02:10:54 <bgamari> frerich, I would like to see some way to nest inlines
02:11:01 <bgamari> but I can live without it
02:11:05 <bgamari> and roles
02:11:37 <bgamari> this is the problem of using the same character (`) as both an opening and closing delimiter
02:11:49 <bgamari> frerich, in that case you may want to consider ReST
02:12:00 <bgamari> frerich, you should probably also look at asciidoc
02:12:12 <bgamari> although frankly I wouldn't be surprised if you came to the same conclusion that I did
02:12:31 <bgamari> asciidoc's tools aren't very well documented
02:12:37 <frerich> bgamari: rest and asciidoc were our two most promising candidates if I understood my colleague correctly. IIRC RST was somewhat favorable because he is a Python guy at heart :-}
02:12:37 <bgamari> especially if you wish to extend them
02:12:56 <bgamari> sounds like you are pretty close to a conclusion in that case
02:13:37 <frerich> bgamari: Yeah, the thing is - it's a big task and so far we tip-toed around making a decision. The status quo is bad, but it works. Kinda. And I think there's also some sort of "protecting prior investment" thing in the air ("throwing good money after bad...")
02:13:52 <bgamari> the best thing you could do at this point is just to dive in to converting a subset
02:13:55 <frerich> bgamari: but now that I see your project, it sounds like it's a very comparable case with similiar requirements. So that kind of pushes us :-}
02:14:17 <bgamari> Just throw pandoc at a chapter and see what pops out
02:14:35 <frerich> Yeah, we did. In fact, I contributed some patches to Pandoc to improve the DocBook reader :-}
02:14:37 <bgamari> If you know Haskell it's pretty easy to bend pandoc to your will if necessary
02:14:43 <bgamari> ahh, good
02:14:46 * frerich nods
02:15:04 <bgamari> just don't forget that it's a one-time process
02:15:29 * bgamari took the move fast and break things approach to hacking pandoc
02:15:57 <bgamari> very little of the work is even remotely acceptable for upstream
02:15:59 <frerich> I liked the excuse of working on haskell during my work time ;-)
02:16:04 <bgamari> but that's okay, it just needed to work once
02:16:17 <bgamari> and it was quick
02:16:48 <bgamari> I tried to do as much as I could with Pandoc
02:16:57 <bgamari> try to minimize the amount of tweaking necessary
02:17:16 <frerich> bgamari: Was your DocBook valid? I *think* we have a whole bunch of cases where the elements are not nested correctly.
02:17:37 <bgamari> frerich, there were numerous instances of invalid docbook
02:17:44 <bgamari> I fixed those before converting
02:18:01 <bgamari> it was easier to fix the docbook than to make the conversion process robust enough to handle them
02:18:11 * frerich nods
02:19:04 <bgamari> moreover this wouldn't have been wasted effort if the ReST effort had failed
02:20:21 <frerich> bgamari: How did you verify the result - did you hack pandoc so that it inserts some grep'able marker for elements it does not know (or doe sit warn about that? I cannot remember...) and then did a couple of manual visual inspections of random pages?
02:20:22 <obiwahn> Could not find module `Data.Text.IO' - how do i fix this?
02:20:43 <bgamari> but yeah, I think it's quite difficult for humans to reliably write conformant DocBook so you'll find bad markup in nearly any docbook
02:20:52 <bgamari> obiwahn, cabal install text
02:21:11 <bgamari> frerich, primarily random inspection
02:21:41 <obiwahn> bgamari: can i search cabal for files?
02:21:52 <bgamari> obiwahn, hoogle?
02:21:59 <bgamari> obiwahn, or hayoo
02:23:08 <obiwahn> @hoogle Control.Monad.State
02:23:10 <lambdabot> Control.Monad.State module Control.Monad.State
02:23:10 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
02:23:10 <lambdabot> Control.Monad.Trans.State.Lazy type State s = StateT s Identity
02:23:30 <obiwahn> @hayoo Control.Monad.State
02:23:30 <lambdabot> Unknown command, try @list
02:24:16 <obiwahn> mh i am still not sure how to find the corresponding cabal package
02:24:26 <bgamari> http://hayoo.fh-wedel.de/?query=
02:24:28 <jle`> go to the actual website :)
02:24:39 <jle`> lambdabot admittedly isn't the best way to search cabal
02:24:43 <jle`> er, hackage
02:24:50 <bgamari> http://hayoo.fh-wedel.de/?query=Control.Monad.State
02:25:01 <bgamari> https://www.haskell.org/hoogle/?hoogle=Control.Monad.State
02:25:36 <obiwahn> oh cool
02:25:39 <obiwahn> thank you
02:32:22 <tdammers> ah, too bad... System.Directory doesn't seem to work on GHCJS
02:45:12 * hackagebot http-api-data 0.2.2 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.2.2 (NickolayKudasov)
02:45:14 * hackagebot protocol-buffers 2.1.10 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.10 (k_bx)
02:45:16 * hackagebot protocol-buffers-descriptor 2.1.10 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.10 (k_bx)
02:50:12 * hackagebot polysoup 0.6.1 - Online XML parsing with polyparse and tagsoup  https://hackage.haskell.org/package/polysoup-0.6.1 (JakubWaszczuk)
03:00:12 * hackagebot polysoup 0.6.2 - Online XML parsing with polyparse and tagsoup  https://hackage.haskell.org/package/polysoup-0.6.2 (JakubWaszczuk)
03:12:46 <Gurkenglas> Can lambdabot generate random numbers for its > computations?
03:14:21 <mauke`0> > randoms (read "some seed" :: StdGen)
03:14:23 <lambdabot>  *Exception: Prelude.read: no parse
03:14:59 <mauke`0> wtf
03:16:18 <mauke`0> oh, I see
03:16:54 <mauke`0> > randoms ((fst . head . reads) "some seed" :: StdGen) :: [Int]
03:16:56 <lambdabot>  [8265633368550172087,-36360648976625409,5354966689821024238,-270240354630333...
03:20:31 <liste> :t randoms
03:20:33 <lambdabot> (RandomGen g, Random a) => g -> [a]
03:21:24 <varaindemian> main = do   
03:21:24 <varaindemian>     line <- getLine  
03:21:24 <varaindemian>     if null line  
03:21:24 <varaindemian>         then return ()  
03:21:26 <varaindemian>         else do  
03:21:29 <varaindemian>             putStrLn $ reverseWords line  
03:21:31 <varaindemian>             main  
03:21:39 <mauke`0> varaindemian: Paste code/errors: http://lpaste.net/new/haskell
03:21:48 <varaindemian> sorry :(
03:22:34 <varaindemian> why is it used return in the "then" statement?
03:22:54 <mauke`0> well, what else would you use?
03:23:01 <Gurkenglas> "return ()" is the "do nothing" action
03:23:53 <varaindemian> I see
03:24:21 <Gurkenglas> :t unless -- Consider this.
03:24:23 <lambdabot> Applicative f => Bool -> f () -> f ()
03:24:43 <Gurkenglas> :t forever -- Also this
03:24:44 <lambdabot> Monad m => m a -> m b
03:24:52 <Gurkenglas> :t interact -- Or even more specifically this
03:24:53 <lambdabot> (String -> String) -> IO ()
03:25:33 <Gurkenglas> Oh wait, the last two don't work as it only recurses if it's not null
03:25:55 <mauke`0> interact (unlines . map reverseWords . takeWhile (not . null) . lines)
03:26:38 <Gurkenglas> Ohh, I misunderstood interact.
03:27:10 <mauke`0> main = interact (const "Hello, world!\n")
03:55:11 <bernalex> I find return () to rarely be useful. sometimes it's a nice indication of YDIW though.
03:55:25 <bernalex> void is merited once in a while.
03:56:08 <bernalex> if-then-else is also a rather clear sign of YDIW.
05:25:17 * hackagebot language-vhdl 0.1.2.0 - VHDL AST and pretty printer in Haskell.  https://hackage.haskell.org/package/language-vhdl-0.1.2.0 (mararon)
05:28:47 <dgpratt> in the course of investigating something, I came across the statement that "...we can't get the GHC package to fit into a DLL" (https://ghc.haskell.org/trac/ghc/wiki/DynamicLinkingDebate)
05:29:10 <dgpratt> does anyone know what the limitation is that is being exceeded?
05:30:09 <dgpratt> the only limit I can find vague reference to is that there seems to be a limit of 64K export entries
05:30:42 <dgpratt> is it possible the GHC package could have 64K+ symbols it needs to export?
05:34:46 <KaneTW> dgpratt: yes, i think that's the reason
05:36:06 <dgpratt> ok, thanks KaneTW -- wow, that's a lot of symbols
07:45:11 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
07:45:11 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
07:45:11 -hitchcock(freenode.net)- [freenode-info] channel flooding and no channel staff around to help? Please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
07:45:21 * hackagebot tld 0.3.0.0 - This project separates subdomains, domains, and top-level-domains from URLs.  https://hackage.haskell.org/package/tld-0.3.0.0 (jp_rider)
07:53:21 <Ryth> when taking a function as an argument in another function, can I somehow check what function it is? Such as: if f == someFunction then...
07:53:34 <liste> Ryth no
07:54:09 <kadoban> Ryth: Function equality testing is a … hard problem. No you can't do that sanely.
07:54:11 <liste> it's not possible to check the equality the functions in general case
07:55:43 <liste> you can test if two functions produce the same output for all inputs, if the functions have bounded inputs, but usually that's not what you want
07:56:12 <liste> Ryth what's your use case? there could be a better way to solve your problem
07:56:38 <liste> s/bounded/finite/
07:57:47 <Ryth> Yeah that seems tricky, I´m probably approaching this the wrong way.. It´s for a school assignment so Ill mess it with myself and see if I can figure something else out
07:59:42 <pdkr> liste: (in case you're interested) there are infinite cases for which this problem is decidable
08:00:43 <liste> pdkr but that needs to be proven outside Haskell, right?
08:00:56 <pdkr> liste: there are cases where this is decidable within haskell
08:01:18 <liste> I see
08:03:04 <pdkr> liste: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
08:03:39 <petercommand> why is -fext-core deprecated?
08:03:51 <liste> cool!
08:08:45 <geekosaur> it doesn't work and noboy's cared enough to do anything about it? (they only discovered it was broken by accident, and have no idea how long it was broken)
08:09:04 <geekosaur> (iirc)\
08:09:18 <kadoban> XD
08:09:26 <kadoban> That sounds like a good reason.
08:09:28 <geekosaur> and it complicates the pipeline
08:10:22 * hackagebot hops 0.2.0 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.2.0 (AndersClaesson)
08:10:23 <geekosaur> note that there is at least one proposal out there that would allow you to embed Core (https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/Introspective)
08:11:20 <geekosaur> also worht noting that ext-core was *not* the same thing as ghc's normal core language
08:12:17 <geekosaur> which is part of why nobody used it
08:13:55 <pavolzetor> next = concatMap (\x -> (show . length $ x) ++ take 1 x) . group
08:14:11 <pavolzetor> is there some way to make this neater?
08:14:32 <pavolzetor> especially using functions from prelude/packages
08:16:46 <kadoban> :t map (length &&& head) . group -- pavolzetor: that looks pretty similar to this, which I've used before
08:16:48 <lambdabot> Eq a => [a] -> [(Int, a)]
08:17:46 <mpickering> How can I turn on flags for hackage packages when using stack?
08:18:05 <mpickering> (ie what is the equivalent to "cabal install <package> -fflag")
08:18:29 <kadoban> mpickering: stack install --flag thepackage:theflag
08:19:16 <mpickering> how do I refer to the package in the current directory?
08:19:26 <kadoban> pavolzetor: You can avoid &&& as well if you want, with a lambda. I'd still use a tuple though.
08:19:41 <kadoban> mpickering: I think you can do "*":theflag or something like that
08:19:54 <kadoban> Or maybe it works without the *, probably depends on shell.
08:19:58 <mpickering> seems to have worked.. 
08:20:12 <mpickering> I still don't really get stack it seems
08:20:22 <pavolzetor> kadoban: I am trying to figure out what that does
08:20:33 <pavolzetor> is it like doing (map map and zip?)
08:20:43 <kadoban> :t map (\x -> (length x, head x)) . group
08:20:45 <lambdabot> Eq t => [t] -> [(Int, t)]
08:20:54 <kadoban> That's the more readable version ^
08:21:02 <pavolzetor> I see
08:21:36 <kadoban> pavolzetor: So it's changing each element of the 'group'ed list into a tuple of its length and the first element
08:21:59 <pavolzetor> makes sense, but than you need to convert the tuples into strings and do concat right?
08:22:45 <pavolzetor> http://adventofcode.com/day/10
08:22:48 <pavolzetor> it is this problem
08:22:52 <kadoban> pavolzetor: Well it depends what you're using it for … do you really want exactly the result you had? That seemed weird so I kind of ignored the details.
08:23:00 <pavolzetor> yes
08:23:53 <Hi-Angel> I remember I asked here for an LSTM or RNN project advice. Nobody knew, so I stick with «dnngraph». I'm going to leave it just in case anybody would ask again, or find this log from Google: don't ever use «dnngraph». It is one of the worst network projects, I think it collected just every possible architecture error.
08:23:56 <pavolzetor> I am trying to find the neatest solution
08:24:10 <kadoban> pavolzetor: Then yours seems fine enough. I don't know that I'd really try to golf it more
08:25:37 <pavolzetor> kadoban: okay, anyhow at least I learned about Control.Arrow a bit
08:25:40 <pavolzetor> thanks for that
08:26:42 <kadoban> pavolzetor: It's super useful for lame tuple tricks and isn't much used otherwise
08:28:59 <pavolzetor> kadoban: still seems useful, going to read documentation
08:29:04 <ttt_fff> is there a nice way in ahskell, to mv an entire directory, then have "all the module names fix themselves" ?
08:29:27 <Rizy> hi 
08:29:27 <Rizy> i want to ask is there any reference of creating Stack/Queue in haskell?
08:29:30 <ttt_fff> suppose I move Foo/Apple to Foo/Fruit/Apple ... then I want all Foo.Apple.* to become Foo.Fruit.Apple.*
08:29:51 <Rizy> or can i just make some function that using tails/heads?
08:29:51 <Rizy> or I just using tails and heads?
08:29:53 <ttt_fff> Rizy: stack is easy, see [a]; Queue is a bit hard
08:30:23 * hackagebot ghc-vis 0.7.2.8 - Live visualization of data structures in GHCi  https://hackage.haskell.org/package/ghc-vis-0.7.2.8 (DennisFelsing)
08:30:53 <Rizy> i tried to change the infix notation to postfix by using the stack
08:31:18 <Rizy> because my friend have homework to do that in java, i think i will tried in haskell
08:31:53 <Rizy> ttt_fff, just see[a]?
08:32:38 <Fuco> I start a process from haskell program using spawnProcess, the haskell program then dies and the original program continues to run (it is a GUI), however it keeps printing crap to the terminal.  How can I redirect the output of stderr to /dev/null for the spawned process?
08:32:46 <Ankhers> Rizy: I believe ttt_fff is saying that you can use a list to create a stack.
08:33:02 <kojo> Hi! I have a question regarding a function I need to use to parse a string, readsP defined in http://lpaste.net/3979428010246799360 . I'm not really sure how to write a correct expression using "parse readsP ..." to parse something. Could someone maybe give me a pointer or two?
08:33:21 <Rizy> i see
08:33:52 <ttt_fff> push is called cons; top is called head; pop is called tail;
08:34:40 <keko-2> Fuco: looks like there is a more complex function, createProcess, that allows you to give more parameters
08:34:53 <keko-2> and one of them is called "std_err"
08:34:55 <geekosaur> Fuco, you'll have to use createProcess instead. open a Handle on /dev/null (unix) or NUL: (windows) and UseHandle it
08:35:05 <geekosaur> on std_err
08:35:21 <Fuco> right, I'll check that out, thanks
08:35:46 <bennofs> geekosaur, Fuco: would using NoStream be possible as well?
08:35:49 <geekosaur> no
08:36:08 <keko-2> what would it do?
08:36:10 <geekosaur> https://github.com/haskell/process/issues/50
08:36:31 <bennofs> geekosaur: thank you
08:37:18 <Kasavage> Hey all! Would anyone happen to know why I keep getting this error when trying to install hindent using cabal on windows? The error is: src/HIndent/Pretty.hs:924:7: Not in scope: data constructor `VarA'?
08:38:20 <Rizy> ah that what i thought ttt_fff thanks
08:39:08 <geekosaur> Rizy, I think you can use Data.Sequence to create a stack, but it won't be efficient. there may be better ones on hackage
09:13:05 <quicksilver> why would Data.Sequence not be an efficient stack?
09:13:16 <quicksilver> amortized O(1) push and pop...
09:14:11 <kadoban> quicksilver: Well, it's probably slower than just a list, which is all you need. At least I'd imagine.
09:15:39 <lingxiao> hey all
09:16:12 <lingxiao> does anyone know how to sample t items from a list uniformly?
09:18:00 <quicksilver> kadoban: it is indeed slower than a list but it's still pretty fast.
09:18:11 <kadoban> Yeah, probably.
09:18:49 <quicksilver> and it works for queue and has good persistence/sharing behaviour
09:20:11 <benzrf> lingxiao: i think i've seen that before
09:20:26 <benzrf> @hoogle [a] -> m a
09:20:27 <lambdabot> Test.QuickCheck.Gen elements :: [a] -> Gen a
09:20:28 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
09:20:28 <lambdabot> Test.QuickCheck.Gen growingElements :: [a] -> Gen a
09:20:58 <benzrf> lingxiao: well, if you wanted it for quickcheck, there you go, but otherwise...
09:22:18 <benzrf> lingxiao: found this too https://hackage.haskell.org/package/MonadRandom-0.4.1/docs/Control-Monad-Random.html#v:uniform
09:28:11 <marchelzo> is showChar just (:)?
09:28:27 * Clint squints.
09:28:33 <quchen> "No."
09:28:44 <glguy> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Show.html#showChar
09:28:47 <happy0> :type showCar
09:28:50 <happy0> :type showChar
09:28:53 <happy0> woops :P
09:28:57 <quchen> "Yes." :-D
09:29:10 <glguy> marchelzo: Yes, you can see that by looking at the source link next to its type in the documentation
09:29:49 <marchelzo> glguy: what a coincidence. I noticed it while looking at your solution to today's adventofcode.
09:30:15 <glguy> hah
09:41:49 <Zenol> Hi. Question : wich library should I use for algebra with sparse matrices. Kmett's Sparse.Matrix or sparse-lin-alg ?
09:55:49 * hackagebot shelly 1.6.5 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.5 (GregWeber)
09:58:51 <Sonolin> I'm creating a RL game, and currently have a GameState monad, which is a StateT over the Game (mobs, map, items) and Renderer
09:59:11 <Sonolin> should I avoid putting the Renderer inside the main GameState ?
09:59:59 <Sonolin> I feel like most of the game loop doesn't actually deal with the renderer (i.e. AI, player moves, etc. can mostly be done without a renderer, then the main gameloop could render everything from the state)
10:01:03 <geekosaur> sounds like you want to look at free monad-based stuff?
10:01:23 <Sonolin> kinda lol 
10:01:46 <Sonolin> idk if that's just a flaw in my thought process, or I just need more primitive functions (likely both)
10:02:56 <Sonolin> and mostly I'm just trying to build this with as little dependencies since I'll probably move to LambdaHack some day
10:03:15 <pdkr> Sonolin: reconstructing the entire render state for every frame sounds inefficient
10:03:51 <pdkr> Sonolin: dunno if it'll solve any of your problems, but there's the luminance project nowadays
10:03:52 <maerwald> how do you make this overview thingy with cabal/haddock that you can find on the right side in documentation on hackage
10:03:56 <Sonolin> pdkr: true, I haven't really thought of efficiency (since its a term based game)
10:04:11 <pdkr> ah ok
10:04:12 <maerwald> "Synopsis"
10:04:32 <Sonolin> luminance sounds interesting though
10:04:40 <Sonolin> kind of what I'm going for (with less 3d of course :P)
10:04:56 <Sonolin> but maybe something like that is just overkill for this
10:05:02 <pdkr> Sonolin: then i suppose rendering is just an output thing, that should simply be a function (literally) of your current state
10:06:13 <Sonolin> ok yea that sounds like what I was thinking
10:06:33 <Sonolin> so maybe seperating is the best way to go
10:07:02 <pdkr> Sonolin: typically, in haskell, if you can separate two things, you probably should
10:07:37 <Sonolin> pdkr: ok cool
10:07:54 <Sonolin> just was making sure I wasn't going to far with this, but it sounds logical
10:08:21 <Sonolin> now to just get it working again :P
10:12:03 <haskell099> hello
10:12:25 <haskell099> I am a haskell newbie 
10:12:44 <haskell099> I just want to ask about the functor typeclass
10:12:59 <johnw> ask away
10:13:12 <haskell099> say for example you want to create a map function for all the Integral types
10:13:32 <haskell099> you for example map by base
10:13:39 <haskell099> let's call the function mapbase 
10:14:21 <haskell099> after thinking that I thought hmm can't I get this to be an instance of the functor type class?
10:14:36 <haskell099> with fmap being mapbybase 10 by default 
10:14:59 <johnw> it would require newtype wrappers to achieve what you're thinking of
10:15:02 <haskell099> but the functor type class needs a Type that's of kind * -> * 
10:15:05 <johnw> Base10 Base16, etc.
10:15:05 <haskell099> not *
10:15:28 <johnw> for example, Base10 a = Integral a => Base10 a
10:15:35 <johnw> there is a much better approach, though
10:15:40 <johnw> this is something a lens would excel at
10:15:52 <johnw> base10 :: Integral a => Lens a a
10:16:03 <haskell099> Oh haven't learned about lenses yet
10:16:04 <johnw> where the base10 lens views the integral as a base 10 integer
10:16:07 <haskell099> okay will look it up
10:16:09 <haskell099> thank you
10:16:12 <johnw> sure
10:16:30 <johnw> however, I'm not sure why "base 10ness" isn't implicit within the number always
10:16:44 <johnw> so why not just have a function call mapbase base number?
10:16:58 <geekosaur> ?
10:16:58 <johnw> sorry, mapbase base function number
10:17:06 <geekosaur> base10ness is not inherent
10:17:10 <geekosaur> if any base is inherent, it's base 2
10:17:11 <haskell099> that's what i thought
10:17:25 <johnw> geekosaur: for example, what would the base10 lens "do"?
10:17:26 <geekosaur> base10 is presentation
10:17:35 <johnw> so should it be Integral a => Base a String?
10:17:38 <johnw> s/Base/Lens
10:18:10 <haskell099> but when you print an integral
10:18:16 <haskell099> it prints as base10
10:18:21 <geekosaur> by default
10:18:32 <haskell099> and usually if you want to map on it you want to map throught the digits no?
10:18:48 <geekosaur> because most people think in base 10, because 10 fingers. this does not mean base 10-ness is an attribute of a given number
10:18:57 <haskell099> yes you're right
10:19:12 <johnw> geekosaur: that's what I meant about it being implicit
10:19:21 <haskell099> but that's why defaulting at base 10 seems like the right thing to do?
10:19:22 <johnw> any number is all bases, the presentation is what differentiates them
10:19:31 <haskell099> but what is wrong in making it a functor?
10:19:40 <geekosaur> it doesn't seem to belong with the *number* though
10:20:05 <geekosaur> haskell099, where would that information go?
10:20:43 <haskell099> what do you mean?
10:20:53 <haskell099> the information about the base?
10:21:00 <geekosaur> yes
10:21:02 <lpaste> tr_istan pasted “composing two monadic functions” at http://lpaste.net/146870
10:21:20 <geekosaur> I am not sure what your map-base would do
10:21:20 <haskell099> it's implicit that it's base 10 i guess
10:21:24 <geekosaur> what point it would have
10:21:25 <haskell099> oh
10:21:32 <geekosaur> numbers do not carry formatting information with them
10:21:45 <haskell099> ok here's a use case
10:21:46 <geekosaur> it's the same bit pattern, what matters is how you input and output it
10:21:56 <johnw> geekosaur: yes, that
10:22:06 <haskell099> let's say you want to set the digits of a number to 1s
10:22:10 <geekosaur> this almost sounds like you're thinking in OO where your number has methods attached to it
10:22:25 <haskell099> so you could mapbase 10 (const 1) 1234
10:22:31 <haskell099> which would return 1111
10:22:36 <johnw> ah, I see what you mean
10:22:47 <johnw> it's like you want a traversal over decimal positions
10:22:48 <haskell099> i usually turn it into a list of integers
10:22:52 <haskell099> yes
10:23:03 <johnw> so that 1234 ^.. traverse.dec10 would = [1, 2, 3, 4]
10:23:18 <johnw> this could be done with a lens Traversal for any base, sure
10:23:19 <c_wraith> jih
10:23:26 <c_wraith> err, sorry. 
10:23:35 <haskell099> so a lens would be the right thing to do?
10:23:40 <haskell099> does it already exist?
10:23:46 <c_wraith> Traversal, not lens. 
10:23:52 <johnw> for this?  I don't think so
10:23:57 <c_wraith> and I don't think it does. 
10:24:03 <johnw> when I say "lens Traversal", I mean a Traversal has defined by the 'lens' package
10:24:08 <johnw> s/has/as
10:24:17 <c_wraith> I don't think it can be lawful as a Traversal 
10:24:24 <haskell099> alright
10:24:30 <c_wraith> though it could be a lawful fold
10:24:41 <johnw> c_wraith: why not a lawful Traversal?
10:24:48 <haskell099> foldbase?
10:25:28 <haskell099> you could have a updateAtbase too
10:25:38 <johnw> one sec, I'll try writing it
10:25:54 <c_wraith> 100 & base 10 +~ 11
10:26:27 <glguy> That's trying to do: "100" + 11
10:26:33 <pdkr> can everyone stop recommending a self-proclaimed haskell newbie with a simple question about Functor to learn Traversable, Lens, and everything?
10:26:50 <c_wraith> ie, you can insert values via it that you can't do with it. 
10:26:55 <pdkr> of course haskell099 wants to learn about all of that. but it's not necessary to know all about haskell before you can program haskell
10:26:56 <haskell099> I know about traversable
10:26:58 <haskell099> just not lens
10:27:04 <c_wraith> err, can't recover with it. 
10:27:34 <nolraiU> pdkr: Its that what he wants to do is slightly odd.
10:28:01 <c_wraith> pdkr, should we just ignore that lens often provides the best tools for data manipulation? 
10:28:21 <mniip> c_wraith, he does make a point
10:28:29 <haskell099> I just wanted to see if an integral type would be a good instance of functor
10:28:33 <haskell099> apparently not though
10:28:33 <glguy> > read (map (const '1') (show 1234)) :: Int -- is this what we're doing?
10:28:35 <lambdabot>  1111
10:29:02 <haskell099> yes but that's inefficient 
10:29:22 <haskell099> i can also convert to a list of digits map and then join
10:29:30 <glguy> haskell099: To be an instance of Functor a type needs to have kind * -> *, that is it needs a type parameter. Integral is a constraint, so isn't going to satisfy that, Integer doesn't take a parameter
10:29:50 <c_wraith> glguy, not really. the goal is performing some operation over the digits of number in some base. 
10:30:02 <c_wraith> glguy, not over a string 
10:30:51 <pdkr> nolraiU: so the only way to solve that is to open up your box of arcane tools and throw Lens at it?
10:30:52 <haskell099> i wrote this function splitByBase b n = n & iterate (`div` b) & takeWhile (>0) & fmap (`mod` b)
10:31:01 <glguy> > map digitToInt (show 1234)
10:31:02 <lambdabot>  [1,2,3,4]
10:31:06 <pdkr> surely we can do a better job at explaning this
10:31:12 <glguy> We don't have to do anything complicated
10:31:19 <nolraiU> pdkr: Yeah, I sort of agree.
10:31:24 <haskell099> this will give me a list of Ints with a specific base
10:31:30 <c_wraith> glguy, now at *any* base
10:31:31 <haskell099> oh and you have to reverse it in the end
10:31:35 <glguy> and different bases can be achieved with showIntAtBase
10:31:53 <c_wraith> glguy, not if you want base 37
10:32:00 <nolraiU> haskell099: That looks right to me.
10:32:18 <haskell099> and then you can map and such
10:32:23 <haskell099> then you could
10:32:32 <c_wraith> glguy, or even base 2^64
10:32:43 <glguy> c_wraith: OK, then just introducing quotRem is enough
10:32:49 <haskell099> fromBase n l = zipWith (*) (iterate (*n) 1 ) l & sum
10:33:07 <c_wraith> glguy, mostly, I wanted you to stop using strings. :) 
10:33:20 <glguy> great
10:33:34 <johnw> haskell099: https://gist.github.com/2c25b0551f3708a04f65
10:33:38 <johnw> that does what you wan
10:33:39 <johnw> t
10:33:45 <johnw> 1234 & base 10 +~ 1 = 2345
10:34:28 <c_wraith> johnw, I think it might be argued that traverses backwards 
10:34:49 <glguy> johnw: type error?
10:34:50 <Cale> pdkr: What was the original question?
10:34:57 <johnw> 1234 ^.. base 10 = [1, 2, 3, 4]
10:35:06 <johnw> glguy: which type error?
10:35:44 <glguy> 1234 & base 10 +~ 1 is a type error
10:35:55 <johnw> really? it works here
10:35:56 <c_wraith> johnw, well, OK. I misread. but little-endian people will still call it backwards. 
10:35:57 <Cale> Oh, I see
10:36:15 <glguy> johnw: it requires a Num String
10:36:30 <haskell099> the original question was how do i make an integral type an instance of the Functor typeclass
10:36:32 <c_wraith> glguy, only if you change the types to make it an error. 
10:36:33 <lpaste> tr_istan revised “composing two monadic functions”: “composing two monadic functions” at http://lpaste.net/146870
10:36:34 <glguy> unless you're actually not using "base" from lens
10:36:43 <mniip> haskell099, you can't
10:36:43 <johnw> I'm using the "base" I just pasted
10:36:48 <haskell099> but this is not appropriate i guess
10:37:03 <mniip> haskell099, a functor is a type-constructor
10:37:07 <glguy> oh, I didn't realize you were using half of lens in that line
10:37:09 <Cale> tr_istan: here?
10:37:11 <mniip> a structure parametrised over an arbitrary type
10:37:12 <haskell099> yes
10:37:24 <tr_istan> Cale: yes
10:37:40 <glguy> c_wraith: I didn't have to change the types, base is already defined, it was changed to make it not an error
10:37:48 <haskell099> Yes so i thought fmaping over an integer would make sense
10:37:56 <pdkr> it's funny how half the people here are trying to solve a problem using Lens that the other half claims is impossible
10:38:00 <mniip> list-of-?, ?-or-nothing, ?-or-something-else
10:38:17 <mniip> those are functors ([], Maybe and Either e, respectively)
10:38:17 <Cale> tr_istan:  oldFn a0 b = do (a,x,z) <- newOne a0; newTwo (a,x,z) b
10:38:18 <johnw> haskell099: I think you're asking more of functors than what they offer
10:38:33 <haskell099> you're right but an integer is a list of integers if you split by base
10:38:37 <Cale> tr_istan: There are obviously some choices about what to do with the multiple values of type a :)
10:38:41 <johnw> haskell099: however, it *could* be done with type wrappers, if you insisted on using Functor
10:38:49 <mniip> if you say "a number is a sequence of numbers", then the contained type is not arbitrary
10:38:52 <johnw> such as the Base10 I suggested at the beginning
10:38:54 <haskell099> but it has the kind of *
10:39:02 <mniip> er digits*
10:39:03 <Cale> tr_istan: you could also just not pattern match, given that you've made the types line up
10:39:04 <johnw> but yeah, mniip is right; at best it would have to be a restricted Functor
10:39:07 <haskell099> yes I saw that
10:39:16 <haskell099> and it makes sense
10:39:25 <Cale> i.e.  oldFn a b = do t <- newOne a; newTwo t b
10:39:28 <johnw> lenses (and traversals) provided a better "toolbox" for this sort of thinking
10:39:54 <haskell099> Thank you
10:40:06 <pdkr> tr_istan: if you want a oneliner: newOne a0 >>= flip newTwo b0
10:40:15 <Cale> tr_istan: The key is that you want to execute the action constructed by newOne to get its result which you can then apply newTwo to.
10:40:46 <Cale> tr_istan: and in a do-block, v <- x means "run the action x, and name its result v"
10:40:58 <tr_istan> trying it out (the oneliner)
10:41:00 <Cale> So when x :: IO t, then v :: t
10:41:29 <Cale> to be fair, these are all one-liners ;)
10:42:05 <pdkr> oneliner *that doesn't use ";"
10:42:28 <pdkr> or "do" notation
10:43:45 <haskell099> <johnw> Base10 wrapper works
10:43:58 <johnw> actually, it doesn't
10:44:01 <tr_istan> I probably did not make the example right, i'm going to reference real code
10:44:09 <johnw> I forgot about it not being a restricted Functor
10:44:09 <tr_istan> the oldFn is this https://github.com/begriffs/postgrest/blob/master/test/SpecHelper.hs#L53
10:44:10 <haskell099> but i was hoping for like a const 
10:44:14 <haskell099> a const type
10:44:19 <haskell099> or something
10:44:36 <haskell099> which allows me to generally do fmap (+1) 1234
10:44:43 <tr_istan> it is used like so https://github.com/begriffs/postgrest/blob/master/test/Feature/AuthSpec.hs#L13
10:44:46 <johnw> if it's a const type, it will ignore your (+1)
10:44:55 <johnw> if you mean Const by "const type"
10:45:10 <haskell099> no not Const
10:45:37 <tr_istan> i need to take this code out of that functions https://github.com/begriffs/postgrest/blob/master/test/SpecHelper.hs#L54-L59
10:45:59 <tr_istan> (it does a expensive db request for each test)
10:46:02 <tr_istan> thank you
10:46:26 <haskell099> I mean a type that would allow me to do fmap (+1) 1234
10:46:55 <johnw> haskell099: well, there is a thing called MonoFunctor, which is a lot less principled than Functor, by which you could "fix" the "members" of Base10 to be Int's
10:46:59 <johnw> but then, why bother going down that road?
10:47:11 <johnw> the traversal approach, or the custom function (mapbase) are both better in my opinion
10:47:23 <haskell099> okay
10:49:00 <haskell099> what I am really asking here is if you needed to take a type of the kind * -> * and you only had the kind *
10:49:05 <haskell099> what should you do?
10:49:14 <haskell099> i am doing this to learn haskell better basically
10:49:17 <haskell099> that's just it
10:49:19 <johnw> there's not much you can do
10:49:28 <icen> newtype Foo a = Foo YourType?
10:49:31 <johnw> a Functor is a type former, of kind * -> *.  A type of kind * isn't.
10:49:54 <johnw> you could use Const, as icen just did, but then fmap is pretty useless
10:51:22 <haskell099> u're right
10:51:26 <haskell099> fmap wouldn't do anything
10:54:02 <haskell099> i'll look more deeply into the Base10 module you made
10:54:08 <haskell099> thank you for all your help
11:06:00 * hackagebot fixed-length 0.1.0.1 - Lists with statically known length based on non-empty package.  https://hackage.haskell.org/package/fixed-length-0.1.0.1 (HenningThielemann)
11:11:24 <broma0> anyone familiar with the details of database connections/protocols? specifically how request/response messages are modeled using TCP connections? (X-post on #archlinux)
11:13:14 <johnw> broma0: is this a Haskell question?
11:18:30 <kadoban> Apparently not, heh.
11:18:32 <maerwald> anyone knows how hackage generated the Synopsis pop-left
11:21:46 <geekosaur> maerwald, might try in #hackage?
11:22:31 <geekosaur> actually that's not just hackage, it's haddock
11:23:53 <ocramz> hi all
11:25:12 <monochrom> haddock builds the pop-left index and provides the javascript code
11:26:07 <ocramz> does anyone have experience with stack? would you know why does `stack build` chokes with "Error parsing targets: No local directories found as children of ... ", whereas the children directory with the dependencies are indeed in place and properly set up?
11:28:21 <kadoban> ocramz: lpaste the full error and the stack.yaml and anything else you think is relevent maybe?
11:28:43 <johnw> ocramz: there's #haskell-stack, btw
11:30:06 <kadoban> (it's pretty small though)
11:30:53 <mniip> http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Double
11:30:59 <mniip> I don't see an instance Num Double in there...
11:31:05 <ocramz> kadoban: Travis log https://travis-ci.org/ocramz/petsc-hs/jobs/96102051
11:32:51 <dolio> mniip: Looks like it's missing several classes.
11:33:15 <dolio> RealFrac, Show, ...
11:33:16 <kadoban> ocramz: That's a bit too much extra stuff I'd have to figure out to reproduce the error or figure out what's going on :-/
11:34:42 <dolio> Thank goodness it retained PrintfArg, though.
11:35:42 <geekosaur> we've been seeing haddocks dropping information oflate :(
11:37:11 <ocramz> kadoban: yes, you're right; thanks anyway. 
11:38:07 <ocramz> kadoban: however, what the travis log shows is simply that those folders where stack looks for dynlibs are not empty and this error simply should occur
11:38:16 <ocramz> which bugs me supremely
11:41:23 <ocramz> kadoban: I mean, the error should *not* occur :/
11:41:52 <kadoban> Yeah I don't really know travis well or what it's doing, or how to query much about what it's done or not … and I'm not really clear on what's wrong either.
11:44:40 <Zenol> edwardk: Hi. I'm using your sparse matrix implementation, but I just realised that, since they don't have fixed size, they aren't instance of functor :/
11:46:01 * hackagebot sbp 0.52.1 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.52.1 (markfine)
11:47:19 <ocramz> kadoban: and I realize it's not a terribly interesting topic either, I was just eager to show an end-to-end reproducible build even with large FFI 
11:47:23 <ocramz> dependencies
11:48:09 <kadoban> Well, it's pretty interesting to me actually, because I'm broken. But I just don't have time at the moment to figure out what's going on :(
11:49:06 <the_2nd> I have a function a -> Int -> a and want to later use it to map onto [a]
11:49:27 <the_2nd> would a definition Int -> a -> a have a nicer syntax?
11:49:36 <the_2nd> dont want to have flip etc all over the place later on
11:50:08 <Rembane> Yes, Int -> a -> a is better.
11:50:12 <Rembane> It fits better into map.
11:50:14 <the_2nd> thanks
11:50:21 <Rembane> np
11:51:29 <ocramz> the_2nd : "nicer syntax" her means that partially applying your `Int -> a -> a` on a number gives you an `a -> a` function that can be supplied to `map`
11:52:24 <the_2nd> ocramz, yeah. I wrote some mini library before and ended up with flips and lambdas all over the place. Dont want that to happen again
11:56:02 * hackagebot plist-buddy 0.1.0.0 - Remote monad for editing plists  https://hackage.haskell.org/package/plist-buddy-0.1.0.0 (AndyGill)
11:56:12 <jle`> the_2nd: some people also like to use sectioning syntax
11:56:28 <jle`> map (`f` 10) xs, for instance
11:56:55 <johnw> I like map (f ?? 10) xs for that... (ala 'lens')
11:57:31 <jle`> :t ala lens
11:57:32 <lambdabot> (Functor f, Rewrapped t ((s -> b -> t1) -> (a -> f b) -> s -> f t1), Rewrapped ((s -> b -> t1) -> (a -> f b) -> s -> f t1) t, Unwrapped ((s -> b -> t1) -> (a -> f b) -> s -> f t1) ~ (s -> a)) => ((Unwrapped t -> t) -> e -> (s -> b -> t1) -> (a -> f b) -> s -> f t1) -> e -> Unwrapped ((s -> b -> t1) -> (a -> f b) -> s -> f t1)
12:00:00 <dmj> :t ala lens . ala lens
12:00:02 <lambdabot> (Functor f, Functor f1, Rewrapped t ((s -> b -> t1) -> (a -> f b) -> s -> f t1), Rewrapped t2 ((s1 -> b1 -> t3) -> (a1 -> f1 b1) -> s1 -> f1 t3), Rewrapped ((s -> b -> t1) -> (a -> f b) -> s -> f t1) t, Rewrapped ((s1 -> b1 -> t3) -> (a1 -> f1 b1) -> s1 -> f1 t3) t2, Unwrapped ((s -> b -> t1) -> (a -> f b) -> s -> f t1) ~ (s -> a), Unwrapped ((s1
12:00:02 <lambdabot> -> b1 -> t3) -> (a1 -> f1 b1) -> s1 -> f1 t3) ~ (e -> (s -> b -> t1) -> (a -> f b) -> s -> f t1), Unwrapped ((s1 -> b1 -> t3) -> (a1 -> f1 b1) -> s1 -> f1 t3) ~ (s1 -> a1)) => ((Unwrapped t2 -> t2) -> (Unwrapped t -> t) -> (s1 -> b1 -> t3) -> (a1 -> f1 b1) -> s1 -> f1 t3) -> e -> Unwrapped ((s -> b -> t1) -> (a -> f b) -> s -> f t1)
12:00:32 <lostman> I am getting a strange error with stack > 0.1.6.0. I tried 0.1.8.0 and 0.1.10.0 with ghc 7.10.2 and 7.10.3. the error is: `Could not resolve file /home/ben/bin-dist-7.10.3/ghc-7.10.3/rts/Linker.c`. Any idea what could be going on?
12:01:22 <kadoban> lostman: Under what circumstances are you getting that error?
12:01:34 <lostman> stack test on travis
12:02:02 <Zenol> talking about lens, have you an idea of how I can get a getter from a Key in Sparse.Matrix?
12:03:19 <lostman> stack build finishes correctly and then things go bad when getting to tests
12:04:40 <the_2nd> if I derive show, can I still define the exact instance? Or how would I go about it? e.g. custom printing
12:05:16 <kadoban> the_2nd: Show isn't for pretty-printing. But no you can't. You can manually make it an instance of Show though, it's quite easy.
12:05:28 <varaindemian> evaluating putStrLn "hehe" in GHCI just prints out hehe (because the contained result in putStrLn "hehe" is ()). But when we do getLine in GHCI, the result of that I/O action is printed out, because getLine has a type of IO String.
12:06:00 <varaindemian> why the contained result in putStrLn "hehe" is () and () is not printed?
12:06:14 <the_2nd> kadoban, but then read wont work for serialize and deserialize, right?
12:06:46 <kadoban> the_2nd: You can manually make a Read instance as well. But you should probably just make a pretty :: Whatever -> String instead
12:06:58 <the_2nd> kadoban, what I thought
12:07:00 <the_2nd> thanks
12:07:38 <varaindemian> > sequence (map print [1,2,3,4,5])
12:07:41 <lambdabot>  <IO [()]>
12:09:11 <kadoban> varaindemian: Because GHCi is kind of conceptually one big "do" block, almost. And when you give it an IO action, it just … executes it.
12:09:32 <hexagoxel> varaindemian: probably just ignoring (). compare `putStrLn "abc" >> return ()` to `putStrLn "abc" >> return 13`
12:10:02 <hexagoxel> (i.e. a special-case for ())
12:11:25 <aweinstock> :t (sequence .) . map
12:11:27 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
12:11:31 <aweinstock> :t mapM
12:11:33 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:12:15 <aweinstock> :t (sequence .) . fmap `asTypeOf` mapM
12:12:17 <lambdabot>     Precedence parsing error
12:12:17 <lambdabot>         cannot mix ‘.’ [infixr 9] and ‘asTypeOf’ [infixl 9] in the same infix expression
12:12:27 <aweinstock> :t ((sequence .) . fmap) `asTypeOf` mapM
12:12:29 <lambdabot> (Monad m, Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
12:13:23 <aweinstock> varaindemian: (mapM f xs) is a shorter way to say (sequence (map f xs))
12:15:55 <varaindemian> haven't learned about Monad
12:17:49 <the_2nd> I have data Some = S1 | S2 | S2
12:18:06 <the_2nd> and functio DO :: Some -> String
12:18:29 <the_2nd> how can I make this depend on S1 or S2 etc.? I tried guards with | in == S1 = "s1"
12:18:33 <the_2nd> but no success
12:18:52 <maerwald> the_2nd: deriving Show?
12:18:56 <maerwald> :t show
12:18:58 <lambdabot> Show a => a -> String
12:19:04 <mauke> the_2nd: case ... of
12:19:08 <aweinstock> @let data Something = S1 | S2 | S3
12:19:10 <lambdabot>  Defined.
12:19:34 <aweinstock> >let f S1 = "foo"; f S2 = "bar" f S3 = "baz" in map f [S1, S3, S2]
12:19:43 <aweinstock> > let f S1 = "foo"; f S2 = "bar" f S3 = "baz" in map f [S1, S3, S2]
12:19:45 <lambdabot>  <hint>:1:37: parse error on input ‘=’
12:19:55 <aweinstock> > let f S1 = "foo"; f S2 = "bar"; f S3 = "baz" in map f [S1, S3, S2]
12:19:58 <lambdabot>  ["foo","baz","bar"]
12:20:12 <maerwald> just derive Show, you get it for free
12:20:12 <tommd> the_2nd: You need to derive (or manually define) an Eq instance to use `==`.
12:20:50 <aweinstock> maerwald: it sounded like they were asking about pattern matching in general, not Show specifically
12:20:52 <the_2nd> so DO S1 = "s1" DO S2 = "s2" etc seems to be the easiest?
12:21:02 <mauke> the_2nd: no, DO is not a valid name
12:21:08 <aweinstock> @let deriving instance Show Something
12:21:10 <lambdabot>  Defined.
12:21:19 <the_2nd> aweinstock, not show solely
12:21:20 <aweinstock> map show [S1,S2,S3]
12:21:26 <aweinstock> > map show [S1,S2,S3]
12:21:31 <lambdabot>  ["S1","S2","S3"]
12:21:51 <tommd> > map (map toLower . show) [S1, S2, S3]
12:21:54 <lambdabot>  ["s1","s2","s3"]
12:21:55 <the_2nd> this will always print the name as in the code, right? Not what I need in my case, but thanks anyway
12:22:16 <the_2nd> the "sx" was just an example, not exactly what I need, but thanks
12:22:27 <the_2nd> data Tile = Grass | Stone | ...
12:22:33 <tommd> Then a pattern-maching you will go, I suppose.
12:22:48 <tommd> the_2nd: and what do you want out?
12:22:51 <aweinstock> the_2nd: (let f S1 = "foo"; f S2 = "bar"; f S3 = "baz" in f) is the same as (let {f S1 = "foo"; f S2 = "bar"; f S3 = "baz"} in f), and semicolons-and-braces can be replaced with newlines/whitespace
12:22:57 <the_2nd> Stone might be "O" while Grass might be "i"
12:23:10 <the_2nd> to draw a map in text form
12:23:25 <tommd> Yes, so jus pattern match 'render Stone = "O"'  'render Grass = "i"' etc.
12:23:25 <mauke> func x = case x of Stone -> "O"; Grass -> "i"; ...
12:23:25 <aweinstock> @let data Tile = Grass | Stone
12:23:28 <lambdabot>  Defined.
12:23:50 <aweinstock> @let renderTile Grass = "i"; renderTile Stone = "O"
12:23:51 <lambdabot>  Defined.
12:24:06 <the_2nd> aweinstock, yeah that seems fine
12:24:25 <maerwald> pattern matching is pretty basic stuff, are you doing a tutorial?
12:24:32 <aweinstock> the_2nd: the general name for that feature is pattern matching/case analysis
12:24:42 <the_2nd> I just forgot when to use | and when not
12:24:53 <the_2nd> aweinstock, had a 2 month haskell break
12:24:59 <the_2nd> but will ease back into it :)
12:26:03 * hackagebot wai-session-postgresql 0.1.0.2 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.1.0.2 (hc)
12:26:15 <OverCoder> Guys, I can't understand the basic concept of 'Function composition'
12:26:37 <OverCoder> What is it even?
12:26:41 <tommd>  (f . g) x  === f ( g ( x ) )
12:26:43 <aweinstock> the_2nd: | as you were using it is called "pattern guards" (I think), and is used when you're checking more complicated properties
12:27:04 <mauke> OverCoder: piping the result of one function into another function
12:27:05 <kadoban> OverCoder: Combining two (or more) functions in a useful way to create a new function. That's it.
12:27:07 <OverCoder> tommd, That example was given, I didn't understand it, what is the .
12:27:14 <OverCoder> ah
12:27:16 <mauke> OverCoder: function composition
12:27:18 <OverCoder> Ah alright
12:27:24 <mauke> well, it's the operator being defined
12:27:37 <OverCoder> hm,
12:27:49 <kadoban> > show . sum $ [1,2,3]
12:27:51 <lambdabot>  "6"
12:27:55 <johnw> anyone who has ever played with legos intuitively knows what function composition is :)
12:27:56 <kadoban> It's that (.) ^
12:27:58 <OverCoder> Alright then, now I got the concept, the tutorial explains it using some Math I haven't took yet
12:28:16 <kadoban> OverCoder: Sounds a bit ugh. What tutorial is it?
12:28:30 <mauke> math: not even once.
12:28:30 <OverCoder> kadoban, http://learnyouahaskell.com/higher-order-functions
12:28:53 <OverCoder> Alright I am more than thankful to you guys, thanks
12:29:00 <kadoban> OverCoder: Oh. LYAH is bad, though I don't particularly remember it being too heavy on math.
12:29:17 <maerwald> here's function composition in a picture: https://www.seas.upenn.edu/~cis194/spring13/images/function-machine.png
12:29:26 <OverCoder> No it's not heavy on Math, and I like it, it was just that part being not understandable to me
12:29:44 <mauke> OverCoder: there's no math in there
12:30:23 <OverCoder> The handwritten expression, and it's description
12:30:25 <kadoban> OverCoder: If you actually want to be able to code in haskell eventually, http://haskellbook.com/ is a good way to go, or https://github.com/bitemyapp/learnhaskell . LYAH doesn't have any exercises and doesn't really ask you to do anything, it's more like light reading that features haskell.
12:30:28 <OverCoder> meh I just wasn't able to get it
12:31:07 <FireFly> johnw: reminds me of this talk: http://www.jsoftware.com/papers/FP/comb0.htm
12:31:14 * hackagebot wai-session-postgresql 0.1.1.0 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.1.1.0 (hc)
12:31:20 <OverCoder> kadoban, nah I quite like LYAH, and because I know 6 langauges, I know best practices to stick all the stuff in my mind :)
12:31:26 <FireFly> (though that's not about Haskell, so not super relevant)
12:31:49 <OverCoder> maerwald, The visualization is awesome, it just took while to open on my connection, I really like it
12:32:16 <johnw> FireFly: haha
12:34:38 <FireFly> perhaps this slide is better to link to: http://www.jsoftware.com/papers/FP/comb_summary.htm
12:34:58 <ReinH> kadoban: to be fair, the only math there is (f . g)(x) = f(g(x))
12:36:31 <OverCoder> ReinH, the description is even worse, composing two functions produces a new function that, when called with a parameter, say, x is the equivalent of calling g with the parameter x and then calling the f with that result., what does that even mean
12:36:46 <OverCoder> But meh I just skipped that and I am okay now :P
12:36:48 <ReinH> It... means what it says. Which parts are you having trouble with?
12:36:58 <OverCoder> * part of it
12:39:27 <graycoder> OverCoder: f(x) = x + 1 ; g(x) = x - 3 ; f . g (x) = effectively = (x - 3) + 1
12:40:24 <graycoder> does that make sense?
12:40:51 <OverCoder> graycoder, Yeah I got it, and yeah that makes sense more than the whole section the author of the tutorial wrote
12:41:16 <graycoder> sometimes words make things harder to understand haha
12:42:21 <the_2nd> I need to call something like concat, but whilst adding a seperator on lists
12:42:37 <geekosaur> :t intercalate
12:42:39 <lambdabot> [a] -> [[a]] -> [a]
12:42:44 <geekosaur> :t intersperse
12:42:45 <lambdabot> a -> [a] -> [a]
12:42:52 <geekosaur> pick your poison
12:43:44 <the_2nd> [["1,"2","3"], ["a","b","c"] => ["1", "2", "3", "SOMETHING", "a", "b", "c"]              ]
12:45:08 <geekosaur> > intercalate ["SOMETHING"] [["1","2","3"],["a","b","c"]]
12:45:10 <lambdabot>  ["1","2","3","SOMETHING","a","b","c"]
12:45:23 <geekosaur> > intersperse "SOMETHING" [["1","2","3"],["a","b","c"]]
12:45:25 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
12:45:25 <lambdabot>      In the expression: "1"
12:45:25 <lambdabot>      In the expression: ["1", "2", "3"]
12:45:28 <geekosaur> whoops
12:45:44 <geekosaur> right, no
12:48:35 <the_2nd> got it
12:50:54 <the_2nd> geekosaur, prettyPrint :: World -> String
12:51:03 <the_2nd> prettyPrint w = concat $ intersperse "\n" $ map printTiles $ chunksOf (rowSize w) (tileData w)
12:51:22 <ReinH> the_2nd: unlines
12:51:32 <ReinH> instead of intersperse "\n"
12:52:12 <ReinH> > unlines ["foo", "bar"]
12:52:14 <lambdabot>  "foo\nbar\n"
12:52:14 <ryantrinkle> is there a type-level representation for a Haskell top-level name?
12:52:19 <the_2nd> ReinH, thanks
12:52:52 <ryantrinkle> (i know Symbol can be used to represent strings, but i'm wondering about representing an exact name, e.g. with package hash, etc., a la Template Haskell's Name type)
12:55:20 <ReinH> ryantrinkle: what are you up to now? :p
12:56:13 <ryantrinkle> ReinH: haha; well, i'm kind of interested in having a typeclass that's indexed by my top level values
12:57:15 <ryantrinkle> i don't have a concrete plan yet, but i'm trying to learn some more about metaprogramming stuff
13:14:22 <fr33domlover> Hello. Is this is the right way to parse a JSON string literal: http://paste.rel4tion.org/166
13:14:37 <fr33domlover> (ignore the mzero which should be typeMismatch instead)
13:16:10 <fr33domlover> It just uses 'pure', almost looks too simple to be correct :P
13:18:21 <bergmark> fr33domlover: looks fine to me. you could also use withText, or other ways
13:18:36 <pikajude> i'm totally confused by xml-conduit's Cursor
13:18:48 <jle`> fr33domlover: yeah, looks good.  you can also move the pure to outside the if statement, if you want
13:18:54 <pikajude> it doesn't seem to be at all composable since everything associates right
13:19:54 <fr33domlover> bergmark, jle`: thanks
13:20:02 <fr33domlover> pikajude, ?
13:20:19 <fr33domlover> oh i see, unrelated :P
13:20:44 <pikajude> `foo $/ bar &/ baz` is `foo $/ (bar &/ baz)`, so you can't add any selectors onto the end of it
13:21:29 <bergmark> fr33domlover: i'd probably write it as parseJSON = (\t -> if t == "und" [...]) <$> parseJSON
13:21:32 <OverCoder> night guys
13:22:09 * OverCoder feels so mad, and has to go to sleep before he makes huge mistakes in his life and his social
13:24:18 <fr33domlover> bergmark, so you get the typeMismatch "for free"? if Text's parseJSON uses it, which I assume it does
13:29:38 <SrPx> What is the meaning of the type of "It" on the second line of this image? http://imgur.com/oLAuwes As I've learned, ∀ and Pi are the same things. Yet, that type seems to use them differently, and for some reason "x" isn't used. What is going on?
13:31:40 <bergmark> fr33domlover: right, no need to have a custom error if you allow all strings
13:34:15 <ogRefl> SrPx: "As I've learned, ∀ and Pi are the same things" - Are you sure?
13:34:43 <SrPx> Oh I think I get it. Is "∀ x -> y" here used to mean "Pi (x : *) -> y" ?
13:35:27 <SrPx> ogRefl Yes :( I've read a few papers on the calculus of constructions and it has Pi, claiming "forall" is just "pi"... Morte has pi and no forall, for example. And morte uses ∀ as an alias for Pi. I thought they were the same.
13:36:35 <pdkr_> SrPx: pi is *interpreted* as forall
13:36:36 <nilg> Is there "set comprehension" in Haskell?
13:36:42 <SrPx> "It : ∀X.Πx : Nat.(X → X) → X → X" would thus translate to "It : ∀ (X : *) -> ∀ (x : Nat) -> (X -> X) -> X -> X" in morte... does that look right? That also looks like just the identity on church numbers
13:38:28 <jewels> Hi there. I'm looking for a well done Haskell's book from which I can refresh the basic concepts (I studied Haskell some years ago) and dive into more interesting features. Anyone can suggest to me something?
13:39:51 <kadoban> So … how does deriving Binary work? I don't really understand what this https://github.com/kadoban/stack/blob/unicode-handling/src/Stack/Types/PackageName.hs#L63 deriving is doing or how it works. Where is it getting an instance of Binary for Text? or does it not need one somehow? I ask because it's not working in old GHC, 7.8.4 or whatever and trying to figure out what to do about it.
13:40:14 <nilg> jewels: http://learnyouahaskell.com/
13:40:49 <Fuco> So I'm thinking of doing 2 or 3 workshops on FP/Haskell for my colleagues.  Should I just pick LYAH and follow that or are there some better courses when accompanied by a "teacher"?  If anyone knows of some nice resource let me know.  The depth should be so much as to make them realize why FP is the true way :D (!)  We deal with PHP mostly, so they aren't mostly at all familiar with FP
13:40:58 <SrPx> OH I was wrong, below there the paper writes Ind:∀P :Nat→∗.Πx:Nat.(Πy:Nat.(Py→P(Sy)))→P  ̄0→P x
13:40:58 <kadoban> jewels: https://github.com/bitemyapp/learnhaskell or http://haskellbook.com/ (personally wouldn't recommend LYAH)
13:41:09 <SrPx> I can't understand that at all, what is the difference between ∀ and Π
13:41:09 <Fuco> but the mess of the untestable code we produce is just killing me inside :/ so I feel like I need to take the action
13:41:29 <FelixNemis> jewels: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ also what kadoban linked
13:41:31 <Denommus> do arrows compose like applicatives do?
13:41:37 <Denommus> or is there something equivalent to "arrow transformers"?
13:42:01 <kadoban> Denommus: If they do, call it Quiver :)
13:42:25 <jewels> What should be the first? 
13:42:32 <jewels> Thank you to all for your help!
13:42:54 <Denommus> kadoban: heh
13:43:26 <kojo> Hi! I was hoping someone could help me a bit with this function I need to write. I have the following definition: "data Parser a = P (String -> Maybe (a,String))" and the function "readsP :: Read a => Parser a"... I'd like to write a function "num :: Parser Double", but I'm not quite sure how to do that. Any pointers?
13:44:09 <ogRefl> I'm probably thinking about a different context, where Pi is conjunction and Sigma is disjunction...
13:47:33 <pdkr_> SrPx: they might be quantifying over a different universe
13:48:23 <pavonia> kojo: Double is an instance of Num, so readsP should already do the right thing
13:49:11 <Fuco> the pi comes from CT/TT as a 'product', where it somehow relates to quantification
13:49:32 <Fuco> I forgot the details and I only remember how adjunction works in that context, but I'm sure there's some product construction too :D
13:54:14 <aweinstock> kojo: there's already a Read instance for Double (I'd expect), so just say (num = readsP) (if you feel like it, you can just use readsP directly if you want)
13:54:21 <pdkr_> Fuco: not sure what you mean by "i'm sure there's some product construction too". it /is/ a product construction.
13:54:21 <aweinstock> :t read
13:54:22 <lambdabot> Read a => String -> a
13:54:36 <aweinstock> :t read "5.042"
13:54:38 <lambdabot> Read a => a
13:54:42 <aweinstock> :t read "5.042" :: Double
13:54:44 <lambdabot> Double
13:54:48 <aweinstock> > read "5.042" :: Double
13:54:50 <lambdabot>  5.042
13:54:56 <kojo> Thank you pavonia and aweinstock!
13:55:29 <Fuco> pdkr_: it's not obvious how product relates to quantification.  There is some way to reconcile it, I call that a construction
13:56:23 <pdkr_> Fuco: the "construction" is that the index of the product is the variable of the quantification
13:57:07 <Cale> SrPx: Various logics have distinctions between Pi and forall, you have to be careful about the definitions being used in context.
13:57:21 <Cale> SrPx: Sometimes they are identified, sometimes not.
13:57:34 <SrPx> The paper just says it is the CC, it doesn't define anything, yet it is different from the CC I've read :( weird
13:58:24 <pdkr_> CC?
14:00:22 <SrPx> calculus of constructions
14:00:22 <chrisdotcode> hi all
14:00:52 <kadoban> So … how does deriving Binary work? I don't really understand what this https://github.com/kadoban/stack/blob/unicode-handling/src/Stack/Types/PackageName.hs#L63 deriving is doing or how it works. Where is it getting an instance of Binary for Text? or does it not need one somehow? I ask because it's not working in old GHC, 7.8.4 or whatever and trying to figure out what to do about it.
14:01:57 <hexagoxel> kadoban: that instance is GeneralizedNewtypeDeriving at work
14:02:45 <kadoban> hexagoxel: Oh … haha, right thanks. Oh but then … is Text actually an instance of Binary? I don't see it anywhere.
14:04:18 <aweinstock> kadoban: I see a Binary instance here: https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text.html#t:Text
14:04:39 <hexagoxel> the code is in: http://hackage.haskell.org/package/text-1.2.1.3/docs/src/Data-Text.html
14:05:12 <kadoban> Hmm, thanks. That's weird it's not on the docs I was looking at.
14:05:13 <ReinH> SrPx: which paper?
14:06:34 <kadoban> Alrighty, that makes much more sense. Now to figure out what to do about that …
14:08:18 <chrisdotcode>  row polymorphism is pretty crazy, guys
14:08:36 <hexagoxel> text-1.2.1.0 seems to be first with the instance
14:08:38 <emmanuel_erc> Hello there! I have a question about the (&&&) operator? If I use it in an operation like -> map ((+1) &&& (+2)) [1..1000000]. Does the operation compute (+1) and (+2) in lockstep? 
14:09:24 <Peaker> emmanuel_erc: map applies the function to each element. &&& feeds the input into the two functions, generating a tuple of 2 results
14:10:32 <hexagoxel> the evaluation happens, as usual, lazily. probably not "lockstep".
14:10:46 <pavonia> emmanuel_erc: ((+1) &&& (+2)) is equivalent to (\x -> (x + 1, x + 2))
14:12:18 <kadoban> hexagoxel: Yeah, apparently this project wants to be able to be built with 1.2.0.6, bleh.
14:18:55 <hexagoxel> kadoban: https://hackage.haskell.org/package/text-binary
14:20:31 <kadoban> hexagoxel: Wow, you rock, that looks like it could help.
14:21:25 * hackagebot webcrank-dispatch 0.2 - A simple request dispatcher.  https://hackage.haskell.org/package/webcrank-dispatch-0.2 (purefn)
14:23:11 <hexagoxel> kadoban: and the source of the package shows how this could be solved manually if there was no compat/orphan package yet
14:23:40 <Ryth_> What do you guys recon would be the ¨cleanest¨ way to count tabs (\t) at the start of a string? such as: ¨\t\t\tThis is a string¨
14:24:06 <aweinstock> :t length . takeWhile (== '\t')
14:24:10 <lambdabot> [Char] -> Int
14:24:24 <aweinstock> > length . takeWhile (== '\t') $ ¨\t\t\tThis is a string¨
14:24:26 <lambdabot>  <hint>:1:32: parse error on input ‘¨\’
14:24:44 <kadoban> hexagoxel: Right, it's just a lot easier to get them to accept the pull request if it doesn't require a ton of extra boilerplate (plus the tediousness of actually doing the boilerplate).
14:24:44 <aweinstock> > length . takeWhile (== '\t') $ "\t\t\tThis is a string"
14:24:46 <lambdabot>  3
14:24:50 <Ryth_> oh you can actually match for multiple chars in takeWhile? didn´t know that
14:25:02 <geekosaur> ?
14:25:19 <geekosaur> > text "\t\t\tstring"
14:25:21 <lambdabot>                          string
14:25:30 <aweinstock> takeWhile just applies the same function to each element of the list as long as it returns true
14:25:40 <aweinstock> :t takeWhileM
14:25:40 <hexagoxel> kadoban: sure; and making an explicit package is the proper way if one has to resort to adding orphans.
14:25:41 <lambdabot>     Not in scope: ‘takeWhileM’
14:25:41 <lambdabot>     Perhaps you meant one of these:
14:25:41 <lambdabot>       ‘takeWhile’ (imported from Data.List),
14:26:08 <aweinstock> I don't know if there's a stateful variant, but it should be simple to write if you need it
14:26:19 <Ryth_> Yeah, but I thought \t´would could as two elements from a list of chars
14:26:23 <geekosaur> no
14:26:28 <kadoban> Hmm, good point too.
14:26:33 <geekosaur> it's just a way to input a tab
14:26:40 <aweinstock> > ord '\t'
14:26:42 <lambdabot>  9
14:26:42 <geekosaur> it's not *stored* as those two chars
14:27:01 <Ryth_> right, makes sense.. thanks guys
14:27:21 <aweinstock> > read "\\t" :: String
14:27:23 <lambdabot>  "*Exception: Prelude.read: no parse
14:27:31 <aweinstock> > read "\"\\t\"" :: String
14:27:32 <lambdabot>  "\t"
14:30:16 <haskell748> hello
14:30:30 <haskell748> haskell newbie here
14:31:03 <haskell748> let's say for example we have  type instance Element Int = Int
14:31:15 <haskell748> as an instance from Data.MonoTraversable
14:31:41 <haskell748> my and I have an instance MonoFunctor Int
14:31:49 <haskell748> but I want to make it more generic
14:31:59 <haskell748> as in for all integral types
14:32:28 <Lokathor> network-socket-options isn't in stackage is seems :/
14:32:34 <haskell748> so i want to do something like type instance (Integral a => Element a) = a
14:32:38 <haskell748> but that doesn't work
14:32:44 <mpickering> no you can't do that
14:32:54 <haskell748> so what can i do?
14:32:58 <haskell748> is it even possible?
14:33:18 <mpickering> not as far as I know
14:33:45 <haskell748> alright thanks anyways
14:42:36 <pdkr_> with DataKinds, are the new kinds that are introduced somehow part of another kind that i can quantify over?
14:43:30 <Cale> pdkr_: as far as I know, there is only one sort, and all kinds belong to it
14:43:42 <Cale> iirc, it was called something like BOX
14:43:50 <pdkr_> Cale: ah, so it's elements :: types :: kinds :: sorts ?
14:44:05 <Cale> yeah
14:44:24 <pdkr_> awesome
14:44:40 <Guest33> From a scale of "mildly weird" to "freaking insane", how would you qualify this instance "instance (MonadIO m) => FromNamedRecord (m MyRecord)". It's from Cassava btw
14:45:43 <zoku> Cale: haha, I just opened my logs to look up what you told me last night
14:45:56 <zoku> the first entries are from a couple years ago with you answering my question straight away
14:46:02 <Cale> yeah
14:46:04 <zoku> Cale deserves irc helper of the year
14:46:50 <Hijiri> juanpablo__: is the instance from Cassava or is it one you are writing?
14:47:07 <Cale> I've been hanging around in here and helping out where I could for ~14 years or so
14:47:11 <juanpablo__> Hijiri: one I considered for a few minutes. But my gut tells me it's a horrible idea haha
14:47:25 <Hijiri> what do you need to do in IO?
14:47:25 <pdkr_> Cale: i don't think you want to know what i was doing 14 years ago
14:47:29 <Cale> Well, maybe not that whole time...
14:47:40 <Cale> I forget when the IRC channel started up exactly
14:47:46 <juanpablo__> Hijiri: validate uniqueness was the idea
14:47:49 <Cale> But at least a decade
14:48:00 <Hijiri> juanpablo__: uniqueness of what?
14:48:12 <Hijiri> the record entries?
14:48:21 <juanpablo__> Hijiri: uniqueness of one of the record entries in a database
14:48:47 <Hijiri> you probably want to do that somewhere else in your code
14:48:54 <Hijiri> not in the parsing
14:49:11 <Hijiri> and probably without using IO
14:49:17 <Hijiri> oh, is it a separate database?
14:49:40 <Hijiri> I would do that separately still though, but I guess that would require IO
14:50:04 <pavonia> Will Haskell have an infinite type hierarchy eventually?
14:50:21 <Hijiri> I think the GHC 8 feature list includes collapsing types and kinds
14:50:23 <Hijiri> I'm not sure though
14:50:41 <pdkr_> pavonia: probably not in any strong sense, because it'll make type inference uncomputable
14:50:58 <pdkr_> Hijiri: that sounds unsafe
14:51:04 <Hijiri> maybe I misread
14:51:13 <mpickering> D808 is the magic ticket 
14:51:28 <geekosaur> collapsing them together does not imply type inference across them
14:51:29 <mpickering> It is very close to being merged
14:51:53 <pavonia> pdkr_: I recall a language similar to Haskell that already had that, I don'tknow the name though
14:52:08 <geekosaur> Tim Sheard's Omega
14:52:20 <pavonia> Ah yes
14:52:44 <exio4> complete type inference is already undecidable
14:54:03 <pdkr_> exio4: what does "complete type inference" mean here?
14:54:17 <athan> Would anyone like to review this mutable container I stapled together? Any tips you can give me? https://github.com/athanclark/timemap
14:54:47 <exio4> pdkr_: that you can infer the type of any expression in your language
14:55:15 <pdkr_> exio4: and haskell does not have this?
14:55:15 <Hijiri> does it have to be a maximally-generic type?
14:55:31 <exio4> pdkr_: polymorphic recursion in vanilla haskell, and with extensions.. RankNTypes ..., GADTs, Type Families,..
14:55:36 <Hijiri> :t (show . read)
14:55:37 <lambdabot> String -> String
14:55:41 <Hijiri> oh
14:55:44 <pdkr_> exio4: interesting. thanks.
14:55:45 <Hijiri> it's defaulting to () or something
14:56:07 <spuz_> is it possible to build more than one executable in a stack project?
14:56:08 <Hijiri> > (show . read) "()"
14:56:10 <lambdabot>  "()"
14:57:19 <ga2arch> athan: it is extremly similar to something i have built a week ago, would have been useful 
14:57:23 <athan> > (show <$>) . readMaybe $ "()"
14:57:25 <lambdabot>  Not in scope: ‘readMaybe’
14:57:28 <athan> :(
14:57:38 <athan> ga2arch: !!! crimeny
14:57:49 <athan> it seems to be O.K. so far, I'm going to ask on reddit now though
14:57:58 <athan> see if I can have some flaws pointed out
14:59:38 <ga2arch> athan: i didn't build a library like you but a timecache, with a rest interface and a hook for when item expires, and persistence through an append only log, the base structure it just like yours tho 
15:01:09 <ga2arch> athan: except i'm using a mutable hashtable from the hastables library
15:02:18 <ga2arch> athan: ah whoops you're using it too 
15:03:44 <athan> ha!
15:04:01 <athan> That's interesting that you gave it a hook for cleanup
15:11:26 * hackagebot tz 0.1.0.0 - Efficient time zone handling  https://hackage.haskell.org/package/tz-0.1.0.0 (MihalyBarasz)
15:21:31 <hackriledge> my monad has a mini is instance when it has a type parameter supplied, is this common, does it have a name and is there anything special about such objects that we can determine from these observations
15:21:52 <hackriledge> Monoid, not mini is, sorry
15:22:13 <athan> hackriledge: well look at [] - instance Monoid [a] where...
15:22:19 <athan> is that what you're talking about?
15:22:22 <pdkr_> hackriledge: you mean it's like Either: Either is not a monad, but "Either a" is?
15:23:50 <pdkr_> hackriledge: if athan referred to the right thing: then if i'm not doing something wrong, "monads applied to a type" and "monoids" are exactly the same thing
15:24:28 <hackriledge> What is going on with that empty list!? In my mind the a should be absent from that definition as monks instances should have kind *->*
15:24:48 <pdkr_> [] :: [a]
15:24:56 <hackriledge> Oh
15:25:04 <icen> hackriledge: You can desugar [a] as [] a, and [] is also a type constructor
15:25:17 <pdkr_> :t []
15:25:18 <icen> It's just a bit weird, like seeing (->) a b for the first time
15:25:19 <lambdabot> [t]
15:25:55 <johnw> pdkr_: (->) r, applied to a type, is not a monoid unless the type it's applied to is
15:26:03 <hackriledge> Yeah I never saw the bracketed arrow before but it makes more sense as it's infix
15:26:06 <johnw> so what you said is not generally true either of all monads, or monoids
15:26:48 <icen> johnw: (->) r r is also a monoid, though, right?
15:26:52 <hackriledge> So the most general assertion is that monads of monoids are monitors?
15:27:00 <icen> (Without any assumption on r)
15:27:07 <johnw> icen: only if it's wrapped in the Endo type wrapper
15:27:08 <hackriledge> Obviously without that typo
15:27:33 <hexagoxel> athan: have you thought about using a concurrent map?
15:27:54 <hexagoxel> i.e. https://hackage.haskell.org/package/stm-containers-0.2.9/docs/STMContainers-Map.html
15:28:24 <hackriledge> Um, what can we say about Free Monad Monoid? Anything more general that, it's a monad for free?
15:28:41 <pdkr_> johnw: thanks
15:28:43 <johnw> "Free Monad Monoid"?
15:29:57 <hackriledge> Icen, I know about using empty list as infix type constructor. But it's applied to a in the instance definition I was struggling with
15:30:52 <hackriledge> Johnw, yes, Free takes two types as arguments right?
15:31:25 <johnw> two types, but not two constraints
15:31:36 <hackriledge> Pardon me
15:31:38 <johnw> and the first type must be of kind * -> *
15:31:53 <hackriledge> Monad is
15:32:04 <johnw> forall (f :: * -> *) (a :: *). Functor f => Free f a
15:32:16 <johnw> Monad isn't of kind * -> *
15:32:32 <hackriledge> (Monad a, Monoid b) =>Free a b
15:32:40 <johnw> it has kind (* -> *) -> Constraint
15:33:22 <johnw> ah, I see
15:33:25 <hackriledge> Um if I'm still saying it wrong can you tell me how to say it?
15:33:39 <johnw> ok, I see your Free a b.  What is the question now?
15:33:53 <hackriledge> It's a monoid?
15:34:09 <johnw> no
15:34:17 <hackriledge> Or Free is not behaving hope I think it should
15:34:19 <johnw> there is no Monoid instance for Free
15:34:40 <johnw> or for Free a b, for any choice of a or b
15:35:23 <hackriledge> So it's infinitely many monads all nested or it's a monoid, it's not a monad of monads of a monoid all nested?
15:35:45 <johnw> are you trying to build an intuition for what Free f a means?
15:35:49 <hackriledge> |
15:36:30 <geekosaur> hackriledge, Monoid and Monad are not related at the level of Haskell. I don't know where you got that idea
15:36:45 <hackriledge> No I thought it was how to express infinitely many kind two type operators with a kind * nearly at the end
15:37:09 <geekosaur> perhaps you heard the category theory story about monads... that's operating at a level "above" Haskell
15:37:12 <geekosaur> no
15:37:38 <johnw> Imagine the series: f a, f (f a), f (f (f a)), f (f (f (f a))), f (... (f a)).  Now imagine you have a type whose inhabitants are all members of such a series.  This is Free f a.
15:38:27 <hackriledge> A monad of a monoid Is a monoid, so wrapping it in infinitely many monads should also be a monoid by induction, I thought this gave a monoid instance for Free but I misunderstood
15:38:35 <johnw> it allows for an infinite nesting of functoral "contexts", determined not at compile time, but at run-time through use of the Free data constructor
15:39:15 <hackriledge> Again
15:39:36 <johnw> there *is* a connection to the "free monoid in the category of endofunctors"
15:39:42 <hackriledge> Contexts, not sure, that's the kind two thing?
15:39:57 <johnw> when I say "context", i just mean the 'f' applied to 'a' to make 'f a'
15:40:03 <Hijiri> I think hackriledge means the potential instance (Applicative f, Monoid a) => Monoid (f a)
15:40:06 <johnw> the functoral... what, embedding? mapping? there's no good word for it
15:40:20 <shachaf> That's not Free f a.
15:40:21 <Hijiri> and by monad of a monoid, a Monad applied to a type that is a Monoid
15:40:42 <shachaf> That's data Froo f a = L a | Froo f (f a)
15:40:46 <hackriledge> Context is fine, but it implies types I think
15:40:47 <shachaf> Er.
15:40:55 <johnw> I'm getting confused now by all these uses of monad and monoid
15:41:04 <shachaf> data Froo f a = L a | B (Froo f (f a)))
15:41:10 <geekosaur> hackriledge, regardless of whether f or a in Free f a is a Monoid, *Free* has to have a Monoid instance. it doesn't, because it can apply to things that do not have Monoid instances and it does not rely on a Monoid instance
15:41:17 <shachaf> (Assuming an extra a value.)
15:41:46 <johnw> shachaf: is that comment to me, or to Hijiri?
15:42:15 <Hijiri> it didn't feel like a response to me
15:42:19 <shachaf> (exists (n : Nat). (f^n) a) isn't Free f a
15:43:35 <hackriledge> Can you write in Haskell; instance (Monad a,Monad b) => Monad a ( a ( ... (a b))))) with a synonym for that construction as a data type?
15:43:35 <johnw> shachaf: ah, I see it now, thank you.  Pure has no 'f'
15:43:56 <johnw> wait, isn't Pure (f^0) a?
15:44:07 <Hijiri> hackriledge: do you mean Monoid b?
15:44:20 <shachaf> Compare Free Pair and Froo Pair.
15:44:24 <johnw> ok, doing so now
15:44:39 <hackriledge> Snapchat, oh I just saw your Froo, that should work right?
15:45:01 <hackriledge> shachaf
15:46:08 <hackriledge> Ok, needs a better name but, there is a monoid instance for Froo, discuss...
15:46:41 <athan> hexagoxel: Woah!! Thank you!
15:47:08 <hackriledge> Where had toss been seen before, what is it called and hour else is it cool? I mean, what is determinable about it...
15:47:16 <Hijiri> hackriledge: it's possible to write the instance (Applicative t, Monoid a) => Monoid (t a), with mempty = pure mempty and mappend = liftA2 mappend
15:48:56 <athan> hexagoxel: Do you mean instead of a hashtable?
15:49:18 <athan> I need the Ord-style Data.Map for `split` :\
15:49:34 <hackriledge> Same for monad... Is it more in fashion to talk about applicatives? I know both are general enough to express all computations in apparently...
15:49:54 <Hijiri> you can do more things with Monad
15:50:03 <Hijiri> Applicative is sufficient for the Monoid instance
15:50:25 <hackriledge> And visa versa? Are they isomorphic?
15:50:36 <Hijiri> no
15:50:41 <Hijiri> applicative doesn't give you join
15:50:45 <Hijiri> (or >>=)
15:50:53 <hackriledge> No
15:51:04 <hackriledge> You have just contradicted yourself
15:51:11 <Hijiri> what did I contradict with
15:51:25 <hackriledge> It cannot be sufficient for a monad instance and fail to provide that functionality
15:51:34 <Hijiri> I said it's sufficient for a Monoid instance
15:51:35 <Hijiri> not Monad
15:51:41 <geekosaur> you still conflate Monoid and Monad.
15:52:00 <Clint> someone has to
15:52:10 <hackriledge> Oooops
15:52:26 <hackriledge> Right
15:54:00 <hackriledge> No comments on instance (Monad a, Monoid b) => Monoid (Froo a b)
15:54:04 <hackriledge> ?
15:54:30 <hackriledge> Or it's name?
15:54:35 <Hijiri> it's a special case of the instance for Applicative I mentioned
15:54:37 <athan> hackriledge: wait wat
15:54:47 <hackriledge> (shachaf) That's data Froo f a = L a | Froo f (f a)
15:55:06 <athan> so (a :: * -> *)?
15:55:25 <hackriledge> Ffs, sorry again
15:55:45 <hackriledge> No no, now your confusing monad and Monoid
15:55:47 <Hijiri> you can write instance Functor f => Applicative (Froo f), I am somewhat sure
15:56:05 <Hijiri> similar to the Free instance
15:57:24 <hackriledge> Why do you have to use applicative to say a monad of a Monoid is a Monoid?
15:58:13 <hackriledge> :t Monoid
15:58:14 <lambdabot> Not in scope: data constructor ‘Monoid’
15:58:27 <Hijiri> you don't have to
15:58:30 <Hijiri> it's just more general
15:59:03 <hackriledge> Yes ok
15:59:07 <hackriledge> Thanks
15:59:51 <hackriledge> Any more about Froo, is that it's real name?
16:01:08 <hackriledge> I want to use it to represent operations on a hylomorphosm
16:02:57 <hexagoxel> athan: ah, i see. yeah i guess you can't have both. depends on how many concurrent read/writes you have vs time-filters.
16:03:37 <tongcx> hi guys, how to put a do block for Maybe monad inside a do block for IO monad?
16:03:42 <hackriledge> And no that's not even what I want sorry, there should be infinitely many fs in Froo, not 2
16:04:05 <Cale> tongcx: you... just do it? Make sure that it's indented more deeply and that things line up
16:04:40 <hackriledge> tongcx, not use >>= and friends?
16:04:58 <Cale> There's no reason to avoid do-notation
16:05:27 <tongcx> I get it to work, the idention there is a bit confusing for me
16:05:36 <hackriledge> Yay
16:07:59 <hackriledge> Data ? f a = ? (f ((? f) a)
16:08:08 <hackriledge> Or I'd that a trashy bad idea?
16:08:15 <hackriledge> Really
16:09:10 <hackriledge> Can't I use something like Cata?
16:10:56 <pavonia> Is there any performance difference between "liftIO $ do { x; y; z }" and "do { liftIO x; liftIO y; liftIO z }"?
16:11:33 <hpc> pavonia: no
16:11:48 <hpc> (assuming laws are obeyed)
16:11:53 <glguy> It completely depends on the particular implementation of liftIO
16:12:03 <glguy> the laws don't say anything about performance
16:12:21 <hpc> oh, performance difference
16:12:48 <athan> hexagoxel: Actually I'm tinkering, please stand by
16:13:22 <pavonia> I guess if there's one, it's minimal, so just curious
16:14:09 <pdkr_> pavonia: it's not always negligible. some people waste their time optimizing certain IO-related constructions
16:14:25 <pdkr_> pavonia: see e.g. http://neilmitchell.blogspot.co.uk/2015/09/making-sequencemapm-for-io-take-o1-stack.html
16:20:42 <pavonia> Interesting
16:44:14 <fvh> hi everyone! How can I properly escape values in postgresql-simple? running smth like x <- execute conn query vals, with vals containing ' , brings escaping error
16:49:57 <pavonia> fvh: It should be escapted automatically. Could you paste your actual statement?
16:58:36 <athan> hexagoxel: Made it about 1.5 times faster :)
17:00:27 <johnw> shachaf: ping
17:00:38 <shachaf> ?
17:00:44 <johnw> about Froo
17:00:46 <hackriledge> Pong
17:00:59 <johnw> I can see that they're fairly different structures, but I don't see where the "extra a" was that you mentioned
17:01:06 <johnw> shachaf: https://gist.github.com/b90f2dba6ab99b1f1eaa
17:01:50 <johnw> B (B (B (L x))) has an x that is f (f (f a)), so the B constructors are basically a depth count.  Whereas Free lets us unwrap one layer at a time: f (Free (f (Free (f (Pure a)))))
17:02:15 <johnw> they are not equivalent, unless I get to know more about the internal structure of f
17:02:37 <johnw> but I'm curious if this was the different you were pointing at or not
17:02:58 <johnw> difference*
17:05:49 <hackriledge> nice code
17:08:13 <Welkin> is that the programmer equivalent of "nice rack"?
17:10:34 <johnw> shachaf: any comment?
17:13:47 <pavonia> Heh, the today's Advent of Code puzzle is a one-liner in Haskell
17:14:46 <shachaf> Not right now.
17:15:06 <pdkr_> pavonia: aren't all of them?
17:15:48 <pavonia> No
17:16:17 <pavonia> Well, technically you can put the all in one line of code, I guess
17:16:24 <pavonia> *them
17:28:12 <ij> Has someone written LOWESS for haskell?
17:36:09 <ezyang> Is there any tools for looking at ghc --make -j and figuring out where bottlenecks/slow compiling files are? 
17:36:44 <Welkin> biohazard-cafe?
17:36:54 <ezyang> MIT thing :) 
17:36:59 <Welkin> Resident Evil?
17:37:57 <ezyang> I suppose so. Hmm, I guess the dialups don't have a consistent naming scheme. 
17:38:24 <ezyang> Oh, the naming scheme is MIT hacks 
17:41:31 * hackagebot gnss-converters 0.1.1 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.1 (markfine)
17:55:11 <hackriledge> Froo monoid
18:05:33 <crossroads1112> test
18:07:13 <crossroads1112> Hello #haskell, I'm trying to write a simple program to find the recursion limit but I'm pretty new to haskell
18:07:26 <Welkin> there is no recusrion limit
18:07:29 <Welkin> recursion*
18:07:36 <Welkin> it is limited only by your system memory
18:08:03 <Welkin> well, all calls are tail calls too
18:08:03 <crossroads1112> Welkin: I realize
18:08:08 <Cale> and in many cases it'll just be infinite
18:08:08 <Welkin> so I doubt you could reach it anyway
18:08:21 <crossroads1112> How would it be infinite?
18:08:33 <Welkin> crossroads1112: tail call optimization
18:08:37 <Cale> Because recursing doesn't necessarily require any resources
18:08:56 <crossroads1112> Ahh gotcha
18:08:58 <Cale> Well, "tail call optimisation" is more of a suitable explanation if the evaluator were strict
18:09:28 <Cale> Functions are evaluated outermost first anyway
18:09:29 <monochrom> some recursion doesn't use memory, some other does.
18:09:42 <Cale> and there's no call stack
18:10:09 <monochrom> all recursion uses time. you can appeal to "I'm not going to wait 10 years" to ban infinite recursion
18:10:10 <Cale> There's a stack which basically consists of pattern matches which are waiting for their scrutinee to be evaluated enough to match a pattern
18:11:09 <lambda-11235> Not to mention TCMC and other recursion optimizations besides tail calls.
18:12:34 <Cale> It's hard to talk about tail call optimisation when there is no call stack to begin with
18:13:07 <Cale> There's some corresponding optimisation of that other stack, but it doesn't apply to tail calls
18:13:21 <Cale> Or what would look like tail calls in the Haskell source code anyway
18:13:33 <Cale> (they'd be tail calls in the compiled code...)
18:24:09 <lpsmith> fvh, values are indeed automatically escaped.  You'll need to paste your statement...
18:31:32 * hackagebot tickle 0.0.5 - A port of @Data.Binary@  https://hackage.haskell.org/package/tickle-0.0.5 (TonyMorris)
18:38:49 <lingxiao> hey everyone
18:40:20 <lingxiao> right now I am keeping some list :: [[Int]]
18:41:12 <lingxiao> the typical use case is such that size list ~ 160,000
18:41:28 <lingxiao> and I'm fmap-ing some function onto it
18:41:35 <lingxiao> n times, for some large n
18:41:56 <geekosaur> ugh. better data type strongly advised
18:41:57 <lingxiao> what is a better data structure for list other than List Int ?
18:42:05 <lingxiao> geekosaur yes please advise!
18:42:08 <geekosaur> a list is exactly that: a singly linked list
18:42:12 <geekosaur> it is NOT a vector
18:42:44 <lingxiao> so I should look at Data.Vector
18:42:48 <geekosaur> yes
18:42:53 <lingxiao> I see there's mutable and immutable
18:42:57 <lingxiao> I'm assuming mutable is advised?
18:43:08 <geekosaur> depends on what you are doing. there are tradeoffs
18:43:41 <lingxiao> what are they? I've never used vectors before
18:44:13 <geekosaur> IIRC the mutable implementation is somewhat expensive if you are changing scattered items throughout the vector, vs. changing many consecutive ones --- although I may well be misremembering
18:44:14 <Cale> Well, wait a minute
18:44:23 <Cale> Are you iterating over the elements of the list in order?
18:44:26 <geekosaur> or thinking of Data.Array which is an older implementation
18:44:34 <Cale> If so, then maybe a list is actually pretty close to ideal?
18:44:54 <Cale> Oh, he's just doing a bunch of fmap
18:44:57 <nshepperd> you don't usually want to use mutable vectors
18:45:02 <Welkin> fmap fmap fmap
18:45:12 <nshepperd> anyway, fmapping on a list is fine...
18:45:22 <Cale> I guess it might be good to use unboxed data structures to compact how much memory is required
18:45:48 <geekosaur> if all you're doing is fmaps, then yes, linked list might well be appropriate
18:46:09 <lingxiao> this is exactly what I'm doing
18:46:31 <lingxiao> incrs' = sequence . fmap incr  :: [Int] -> RVar [Int]
18:46:54 <lingxiao> or I should say: incrs' xs = (sequence . fmap incr $ xs)  :: [Int] -> RVar [Int]
18:47:00 <lingxiao> where length xs ~ 160,000
18:47:09 <geekosaur> baically, if you find yourself using (!!) more than once or twice on large lists, linked lists are a really bad idea
18:47:24 <lingxiao> yeah there is none of that (!!)
18:48:11 <lingxiao> so wait Cale and geekosaur just to confirm a list is fine ... since I'm always doing in order traversal
18:48:21 <geekosaur> yes, for this it looks fine
18:48:38 <geekosaur> I just get worried when I see people slinging large lists around (you mentiond 160,000 items)
18:49:04 <Cale> lists can even be reasonably infinite ;)
18:49:17 <geekosaur> if you're doing pretty much anything other than (f)map then that's asking for sloooooooooooooow
18:49:35 <lingxiao> yeah btw how come fmap is really fast?
18:49:56 <lingxiao> err it sounds liek a dumb question
18:49:56 <nshepperd> you can golf that down to 'traverse incr' by the way
18:50:26 <lingxiao> nshepperd aahh I knew there was something liek that thanks!
18:51:04 <geekosaur> well, it's pretty much *the* intended use case for lists; depending on what you are doing, it might even fuse away
18:51:23 <lingxiao> what's fuse away? you mean list fusion? but there's only one list?
18:51:36 <geekosaur> maps and folds are pretty heavily optimized
18:52:00 <geekosaur> other operations not so much, and (!!) is pretty much anti-optimization
18:52:59 <lingxiao> ahh ok so when do I use array vs vectors?
18:53:07 <geekosaur> list fusion means that "only one list" can, if conditions are right, become *no* list; it just pipelines the whole thing and never creates the actual list (unless as a final result)
18:53:49 <geekosaur> Data.Array is older and not often used in modern software; Vector was designed with experience from Array and is generally faster
18:56:00 <lingxiao> geekosaur ahh thanks for the tip on Data.Array. 
18:56:32 <lingxiao> with fusion what does pipelining the whole list mean? like the list item is call by need only?
18:56:58 <lingxiao> that reduces the space for large lists right? but time as well?
18:57:22 <geekosaur> it means that instead of allocating the whole input list and passing cells from it around, something generates values as needed and the memory for each "cell" is reused
18:57:42 <geekosaur> and there is neer an actual "list" in memory
18:57:48 <jmcarthur> Data.Array has some features that Data.Vector does not, though.
18:58:17 <jmcarthur> And is still reasonably fast and convenient, especially for algorithms that really demand mutation.
18:58:18 <lingxiao> jmcarthur could you elaborate?
18:58:44 <jmcarthur> lingxiao: Data.Array allows you to use non-Int types for indexing and works with the Ix type class for sensible n-dimensional arrays
18:58:48 <lingxiao> not super relevant to me but there's no risk of it not being supported anymore actively?
18:59:23 <geekosaur> there is enough stuff out there that uses Array that it is in no danger of going away
18:59:24 <jmcarthur> lingxiao: to be fair, nothing prevents a Vector wrapper from doing the same thing, but it's built right into Data.Array, which can be convenient
18:59:27 <geekosaur> or breaking
18:59:49 <jmcarthur> lingxiao: Data.Array overall has a really impoverished API compared to Data.Vector, though
19:00:01 <jmcarthur> lingxiao: at least for purely functional code
19:00:07 <lingxiao> geekosaur ahh that's preetty cool
19:00:11 <jmcarthur> for imperative code it just doesn't matter much
19:00:14 <geekosaur> it's being maintained, it's just not being enhanced
19:00:24 <lingxiao> jmcarthur ok thanks I'll keep all those in mind
19:00:47 <lingxiao> geekosaur ok great!
19:00:55 <lingxiao> thanks for all this great info man
19:01:00 <lingxiao> man(s)
19:03:51 <lingxiao> unrelated question but if I want to take a list [a] and make it into a list of lists [[a]], each sublist of length t
19:03:57 <lingxiao> is there a function that does that?
19:04:02 <geekosaur> :t chunksOf
19:04:03 <lambdabot> Int -> [e] -> [[e]]
19:04:03 <lingxiao> hoogling Int -> [a] -> [[a]] gets me no results
19:04:31 <jmcarthur> > chunksOf 3 [1..]
19:04:33 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
19:04:49 <geekosaur> which hoogle? the default one only indexes the libraries that come with ghc; fpcomplete's indexes all of Stackage; I think there's a beta hoogle hiding on haskell.org somewhere that indexes more
19:04:58 <jmcarthur> @hoogle chunksOf
19:04:59 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
19:04:59 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
19:05:05 <jmcarthur> not quite what I was looking for
19:05:58 <geekosaur> (actually I think the default one has indexes for other things but you have to point it to those indexes yourself, which makes it less than useful)
19:06:09 <geekosaur> (because you already have to know where something is)
19:06:22 <MarcelineVQ> If hoogle can't find something try it in http://hayoo.fh-wedel.de/ or https://www.stackage.org/lts-3.17/hoogle?q= as well
19:06:49 <lingxiao> thanks!
19:07:14 <lingxiao> MarcelineVQ: ahh that's cool never seen hayoo before
19:07:19 <geekosaur> https://fpcomplete.com/hoogle
19:07:28 <lingxiao> what a strange reversal of names and their real life counterparts
19:08:08 <geekosaur> (I think there's a haltavista out there somewhere too... :p)
19:08:14 <lingxiao> hahaha
19:08:34 <lingxiao> https://media.giphy.com/media/VMgcrwq9imGHu/giphy-facebook_s.jpg
19:08:41 <geekosaur> no hing that I'm aware of though
19:08:53 <MarcelineVQ> hask heeves
19:09:01 <geekosaur> hogpile?
19:10:42 <jmcarthur> :t (fmap . takeWhile) (not . null) . unfoldr . fmap Just . splitAt
19:10:44 <lambdabot> Int -> [a] -> [[a]]
19:11:02 <jmcarthur> just being cute/clever. it's not a serious answer.
19:11:09 <lingxiao> jmcarthur head exploded
19:11:36 <lingxiao> :)
19:14:09 <jmcarthur> Though there are many reasons I think Haskell is great as a real language, I have to admit that one of the things that makes haskell kind of fun is all the cute and totally impractical things you can do.
19:16:06 <lingxiao> jmcarthur yeah the language is like putty in that it's so flexible
19:16:19 <lingxiao> but very hard once it "sets", and not brittle I imagine
19:16:29 <lingxiao> so .. hard but not brittle
19:19:03 <sm> coming from very dynamic languages, I always thought of haskell as more like marble (or at the very least, steel)
19:20:31 <shadowdao> Haskell is like a pastry.
19:20:51 <Welkin> haskell is like a vagina
19:21:21 <jmcarthur> I think Haskell is most like wood.
19:28:56 <Adeon> haskell is isopropyl alcohol
19:29:03 <Adeon> it rubs away all the impurity
19:29:07 <Adeon> without damaging electronics
19:43:06 <nshepperd> haskell is like cornflour mixed with water
19:44:02 <nshepperd> you can pour it into different shapes, but it stays right where it is if you punch it
19:44:23 <nshepperd> also, people are kind of surprised when they find out it exists
20:14:13 <anohigisavay> hi. why do i need to enable RankNTypes for such a simple type synonym: type X a = (Show a) => a
20:17:55 <Cale> anohigisavay: Consider what happens when you make such a substitution directly into a type
20:19:42 <geekosaur> ...
20:26:36 * hackagebot timemap 0.0.1 - A mutable hashmap, implicitly indexed by UTCTime.  https://hackage.haskell.org/package/timemap-0.0.1 (athanclark)
20:31:36 * hackagebot statsd-client 0.1.0.1 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.1.0.1 (keith_duncan)
20:57:35 <Phillammon> Quick query from a fool- What are the possible causes of "unexpected } possibly due to bad layout" outside of mismatched parens? I'm out of ideas on what's wrong with this thing
20:58:12 <kadoban> Phillammon: Bad layout possibly? Are you using tabs? You shouldn't.
20:58:31 <Phillammon> ...sod. Right, what the error literally says on it. That would do it.
20:58:39 <Phillammon> Wait, no, vim's set up to tabspace. Huh.
20:58:58 <kadoban> Well it's still possible to have bad layout … but it should stick out in that case.
21:00:17 <Phillammon> Hm. Okay, all whitespace eliminated with extreme prejudice, same issue persists.
21:01:17 <Phillammon> The weird thing is I have two... wait a sec, the topic has something for this
21:01:45 <lpaste> Phillammon pasted “Declaration function” at http://lpaste.net/146896
21:02:15 <Phillammon> It's flagging up the error on the latter line, but not the former, which is... strange, to me.
21:03:11 <kadoban> Phillammon: I'd think the 'd' in declaration needs to be more indented than the 'if', at least. I'm not so sure about some of the other parts either
21:04:00 <Phillammon> The "all whitespace eliminated" thing was me just concatenating it all into a single line, though. This said, will give it a shot
21:07:14 <pavonia> Is the "else" at the same level as the "if" allowed?
21:07:37 <Phillammon> Possibly not. I've had it work before, but only with oneliners
21:07:40 <geekosaur> outside of do/let/case, yes
21:07:41 <kadoban> I should really learn the layout rules in-depth at some point.
21:07:58 <Phillammon> Apparently then and else need to align, so trying that out
21:08:20 <Phillammon> Nope, same issue still. Hrmph.
21:08:32 <Phillammon> Although it's now throwing the error... after the last line?
21:09:15 <geekosaur> maybe pastebin the whole thing instead of just that function?
21:09:34 <mauke> missing 'else'
21:09:42 <geekosaur> oh right
21:10:09 <Phillammon> ...else is required, right
21:10:11 <geekosaur> Phillammon, if-then-else is an expression, you can't omit an "else"
21:10:22 <Phillammon> Sincere apologies, that's me being clueless again
21:10:27 <Phillammon> Thank you so much.
21:11:08 <Phillammon> I suppose while I'm at it I should ask
21:11:11 * geekosaur has spent too much time tonight having his brain turned to mush by c++ :/
21:12:06 <Phillammon> is there a better way to check the value of ((program state) !! (counter state)) than repeated if-then-elses? Haskell switches appear to only work for functions, but the thing I need to output based on the check *is* a function (as in, a choice of n functions)
21:12:35 <mauke> define "check"
21:13:05 <geekosaur> MultiWayIf extension, or case () of () | ...
21:13:07 <mauke> also, avoid !! in loops because inefficient
21:13:29 <Phillammon> Is there a better way that I could... I could have been heading all this time...
21:13:54 <Phillammon> I just realized how many things I've done wrong with this. Counter serves no purpose, for starters.
21:14:30 <Phillammon> By check I mean there are 4 different possible values of an element in program, and each corresponds to a function to follow
21:15:00 <mauke> still too vague for me to tell whether case/of could be used
21:16:05 <geekosaur> also function application is higher precedence than any operator, so that is: program state !! counter state
21:16:08 <Phillammon> I think I have a handle on it if I rejig it to fit my newest realization anyway, but sorry. I'll try to think about how to be more specific
21:16:39 <Phillammon> geekosaur: I believe I can kill the !! altogether, which should help things, but again, thanks!
21:22:28 <Phillammon> Sorry about that. Thanks, again, seems to be working now. Ta!
21:31:51 <Xe> I'm getting an error when trying to use wreq and lens to extract data from json: https://gist.github.com/Xe/3990c6baf5e3c030cf3a
21:39:44 <c_wraith> Xe: Looks to me like you never parsed the response body
21:40:05 <Phillammon> Note to self- when you stop trying to use Haskell as an imperative language and actually do things functionally, suddenly the code is easier to work with
21:40:06 <c_wraith> Xe: the error message is telling you "Hey, this Text isn't an aeson Value"
21:40:21 <Xe> c_wraith: what am I missing there?
21:40:31 <c_wraith> Xe: whoops, I'm totally wrong. :)
21:41:19 <c_wraith> Xe: When you use _String as a traversal, it returns the text value of the string.
21:41:36 <c_wraith> Xe: Not an Aeson value
21:41:51 <Xe> c_wraith: how do I get it out then?
21:42:03 <c_wraith> Xe: you already did.  That's what _String does
21:42:17 <c_wraith> Xe: though you might want to use ^? instead of ^.
21:42:31 <c_wraith> Xe: because then you can check whether the traversal succeeded or not
21:43:01 <Xe> c_wraith: hmm
21:43:08 <Xe> i'm now getting terrifying linker errors
21:43:15 <Hi-Angel> Phillammon, I am using twitter for that ☺
21:43:18 <Xe> /home/xena/code/matrix/morpheus/morpheus/.stack-work/dist/x86_64-linux/Cabal-1.22.4.0/build/libHSmorpheus-0.1.0.0-2ewj66nnXGgBojMAHY8Fa3.a(Matrix.o):(.text+0xa28): undefined reference to `morphzu2ewj66nnXGgBojMAHY8Fa3_NetworkziMatrixziTypesziLogin_zdwzdctoJSON_info'
21:43:21 <Xe> /home/xena/code/matrix/morpheus/morpheus/.stack-work/dist/x86_64-linux/Cabal-1.22.4.0/build/libHSmorpheus-0.1.0.0-2ewj66nnXGgBojMAHY8Fa3.a(Matrix.o):(.data+0x2b8): undefined reference to `morphzu2ewj66nnXGgBojMAHY8Fa3_NetworkziMatrixziTypesziLogin_zdwzdctoJSON_closure'
21:43:36 <c_wraith> Xe: uh.  I have no idea what stack broke. :)
21:44:17 <c_wraith> Xe: Just do "stack clean" or whatever its command is to clean build artifacts and build from scratch
21:45:11 <Xe> yeah did that
21:45:16 <Xe> still linker errors
21:46:09 <c_wraith> I thought stack was supposed to prevent compilation weirdness, not invent new compilation weirdness.
21:47:26 <Hi-Angel> I'd try to temporarily backup that `.stack-work` dir, and to try to install just the problem package to see if it works
21:47:36 <Hi-Angel> libHSmorpheus, right?
21:47:47 <Phillammon> c_wraith: The road to horrible spaghetti bugs is paved with good intentions?
21:48:27 <glguy> Xe: Are you making a new library and executable at the same time?
21:48:29 <MarcelineVQ> missing references usually means modules weren't expored in cabal
21:48:46 <glguy> and Network.Matrix.Types.Login is in your library?
21:48:48 <MarcelineVQ> *.cabal
21:48:51 <Xe> glguy: yeah, is that a bad thing?
21:49:03 <glguy> No, but you forgot to add that module to "other-modules:" probably
21:49:51 <Phillammon> Oh boy. Anyone have any experience with HUGS specifically?
21:50:00 <Xe> ah I see
21:54:11 <Cale> Phillammon: I have experience with it, but nobody should be using it at this point.
21:54:49 <Phillammon> Cale: Required by the professor. I've been avoiding it wherever possible, but that's what it's being marked on.
21:55:10 <Phillammon> It's giving me some... strange idiosyncracies, shall we say
21:56:51 <lispy> Phillammon: do you know why your professor is requiring hugs?
21:58:14 <Phillammon> lispy: They're more familiar with it and updating documentation requires effort, as far as I can tell. No actual reasoning ahs been given, just an ominous "You'll get zeroed if it doesn't work on my hugs install"
21:58:38 <MarcelineVQ> :t length
21:58:40 <lambdabot> Foldable t => t a -> Int
21:58:43 <lispy> Phillammon: Is Erik Meijer your professor?
21:58:46 <Phillammon> It's not like the uni computers don't have ghci installed, so it's not effort or anything
21:58:47 <MarcelineVQ> It's probably because of that f
21:58:51 <MarcelineVQ> *t
21:59:07 <Phillammon> lispy, no, but I have a feeling that we're talking about the same kind of person here
21:59:28 <Phillammon> One Steve Matthews, if that means anything (University of Warwick, Coventry, England)
22:00:04 <Phillammon> ...I will admit that there is a startling resemblence, however
22:01:39 * hackagebot timelike 0.1.0 - Type classes for types representing time  https://hackage.haskell.org/package/timelike-0.1.0 (esz)
22:02:25 <orb> Is there a nice way to intersect a Data.Set with a Data.Map?
22:02:51 <glguy> orb: Turn the (Set k) into a (Map k ()) and intersectWith those
22:02:54 <orb>  I have a combination of: mapify = DMS.fromList . map (,()) . Set.toList and DMS.intersection.
22:02:59 <orb> (Where DMS is Data.Map.Strict.)
22:03:02 <glguy> There's a function for turning a set into a map efficiently
22:03:33 <glguy> fromSet 07:: (k 07-> a) 07-> Set k 07-> Map k a
22:03:39 <orb> fromSet, found it.
22:03:40 <orb> Thanks!
22:05:29 <Phillammon> Okay. I'm hoping I've misunderstood something here, but it looks like HUGS is trying to Head and tail lists in order to show them until it hits 0, at which point it throws a pattern match failure. Is this known behavious, or am I doing something wrong at my end?
22:06:08 <MarcelineVQ> what's the line look like you're evaluating?
22:06:18 <glguy> ?lpaste
22:06:19 <lambdabot> Haskell pastebin: http://lpaste.net/
22:06:47 <Phillammon> I'll just chuck the whole thing in for simplicity
22:08:19 <Phillammon> http://lpaste.net/146897
22:08:49 <Phillammon> I'm confused as to how it's failing *during* the show operation
22:09:14 <MarcelineVQ> good news, it's not hugs
22:09:20 <glguy> Phillammon: With lazy evaluation things aren't evaluated until they're needed
22:09:20 <Phillammon> Bad news, its the derive?
22:09:30 <glguy> and they're needed in this case when you try to  show them
22:09:34 <Phillammon> Oh, right
22:09:37 <Phillammon> that makes sense
22:10:13 <Phillammon> It's just printing one more comma than I'd expect, even with that caveat
22:11:08 <glguy> It's generally much better to use pattern matching on lists than to use head
22:11:17 <glguy> (because of exactly the kind of problem you're running into right now)
22:11:35 <glguy> runline (041, _) state 07= declaration (snd (head (program state))) state
22:11:44 <glguy> That's the offending line, at least
22:12:15 <Phillammon> Hm. So an empty program is making it to that line.
22:14:03 <Phillammon> Oh!
22:14:18 <Phillammon> I see now, thank you very much. Need to change where I do the tail if I do things like that
22:14:22 <Phillammon> Many thanks
22:14:32 <haskell582> hello
22:15:25 <haskell582> can i somehow have a generic type instance which is an instance of a type class?
22:15:42 <haskell582> so for example if you have type instance Element Integer = Integer
22:16:11 <haskell582> can you also have something like type intance Element (Integral a => a) = a?
22:16:15 <haskell582> but this doesn't work
22:16:21 <haskell582> is it even possible?
22:17:16 <Phillammon> glguy, MarcelineVQ: Many thanks, again. I can't believe I missed that
22:17:22 <Phillammon> Fixed
22:20:50 <nkaretnikov`> is there a way to quote something like Maybe Int like so ''Maybe Int, without defining a type alias?
22:20:53 <Phillammon> (Side note: That feel when closing 20 odd tabs of stack overflow)
22:21:36 <kadoban> nkaretnikov`: ? For what purpose?
22:22:39 <nkaretnikov`> kadoban: i don't understand how your question is relevant to what i'm asking about
22:23:49 <nkaretnikov`> i know that :t ''Maybe Int doesn't typecheck in ghci
22:23:59 <nkaretnikov`> i want it to typecheck, that's it
22:24:29 <nkaretnikov`> ''(Maybe Int) doesn't work, of course
22:24:56 <nkaretnikov`> type MaybeInt = Maybe Int; :t ''MaybeInt works, but that's ugly
22:25:21 <MarcelineVQ> well, Maybe Int is a type, asking for its types doesn't make sense you see, that's why :t doesn't work
22:25:47 <nkaretnikov`> MarcelineVQ: wat
22:25:53 <MarcelineVQ> Oh you're askinging about using '
22:26:02 <MarcelineVQ> Are you using DataKinds or is this unrelated to that?
22:26:11 <nkaretnikov`> totally unrelated
22:31:59 <nkaretnikov`> fwiw, mkName "Maybe Int" works
22:35:49 <Phillammon> Okay, more stupidity on my part follows. I have a type declaration but ideally want it to be completely generic. Is this something that is possible?
22:36:46 <Phillammon> in the sense of "type Statement = (Int, SOMETHING)" in which SOMETHING is known to exist, but its type is not known
22:42:52 <Cale> Phillammon: SOMETHING has to itself be a type
22:43:09 <Cale> Phillammon: a value certainly can't go there.
22:43:16 <Phillammon> Right. That's what I'm meaning
22:43:30 <Phillammon> the type is unknown, or rather, selected from a list of 4 possible types.
22:43:36 <Phillammon> How would I go about representing this?
22:43:48 <Cale> Perhaps  type Statement a = (Int, a)  ?
22:43:57 <Phillammon> I ask because if I try to put in a pipe, the interprerter throws a fit.
22:43:58 <Phillammon> oh
22:43:59 <Phillammon> hm
22:44:37 <Cale> Yeah, the pipe symbol is not part of the syntax of types
22:45:30 <Cale> It's used in data declarations as punctuation to separate the constructors, and a few other places in the syntax (guards, list comprehensions)
22:45:56 <Phillammon> Ah, I see. Right, this makes sense.
22:46:10 <Phillammon> That appears to have worked, but introduced a whole new error which...
22:46:20 <Phillammon> Huh. "Arities". That is not a word I have come across before
23:45:12 <kojo> Hi! I'm having some big problems with a function I need to construct. I have a parser defined as "data Parser a = P (String -> Maybe (a,String))", an expression defined as "data Expr = Num Double | ..." and a function "readsP :: Read a => Parser a". I need to construct a function "num :: Parser Expr". Any ideas of how to accomplish this?
