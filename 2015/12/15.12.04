00:00:01 <magneticduck> I doubt there's a general form, because there's no certainty that it 'makes sense'
00:00:15 <magneticduck> 1) not all enums have a finite value space
00:00:35 <gamegoblin> enum in the C sense
00:00:43 <gamegoblin> e.g. data Foo = Bar | Baz | Bang
00:00:43 <magneticduck> and some of them don't even have a way of iterating through that value space (say, an infinite precision integer)
00:01:04 <gamegoblin> you can derive Bounded and do [minBound..maxBound]
00:01:08 <gamegoblin> to get [Bar, Baz, Bang]
00:01:19 <gamegoblin> was wondering if there was a better way
00:02:00 <magneticduck> hayoo doesn't think so
00:03:23 <gamegoblin> oh well
00:03:29 <cocreature> hoogle found https://hackage.haskell.org/package/lattices-1.4.1/docs/Algebra-Enumerable.html#v:universeBounded
00:04:05 <gamegoblin> Not worth pulling in a dependency for
00:04:09 <cocreature> yeah
00:05:36 <Bez_> :t (False:)
00:05:37 <lambdabot> [Bool] -> [Bool]
00:08:14 <jle`> gamegoblin: i'd do [Bar ..], myself, in that case
00:08:34 <gamegoblin> jle`: didn’t think of that, seems obvious, nice
00:08:45 <jle`> or [minBound..] if you want to be needlessly generic :)
00:09:39 <opqdonut> the syntax should obviously be [..] :)
00:10:13 <gamegoblin> opqdonut: good idea ;D
00:10:32 <gamegoblin> jle`: minBound might be better if I decide to reorder the constructors for whatever reason
00:11:05 <jle`> mhm
00:13:30 <ReinH> enumFrom minBound if you're allergic to punctuation
00:19:51 <Bez_> let p xs = xs !! 3 && xs !! 5
00:19:57 <Bez_> :t p
00:19:59 <lambdabot> Expr
00:21:34 <liste> Bez_ lambdabot didn't understand your let
00:21:36 <liste> try @let
00:21:50 <liste> also, /query lambdabot
00:29:24 <ReinH> or just
00:29:36 <ReinH> :t \xs -> xs !! 3 && xs !! 5
00:29:37 <lambdabot> [Bool] -> Bool
00:29:47 <ReinH> no need to polute the global namespace
00:30:52 <Bez_> Thx
00:39:48 <quicksilver> :t let p xs = xs !! 3 && xs !! 5 in p
00:39:49 <lambdabot> [Bool] -> Bool
00:39:50 <quicksilver> is another way
00:42:28 <jle`> unsafeCoercing Dicts is so weird
00:44:06 <jle`> at first i thought it was a way to get an instance of anything for free inferred...but now i see it's more like "stealing" a different type's instance for your type
01:02:17 <bollu> is Pipes the standard library for streaming in Haskell?
01:02:22 <bollu> what about conduit?
01:03:40 <liste> bollu both are popular
01:04:29 <bollu> liste: if I had like, 3 hours to learn one of them, which one would you pick?
01:04:37 <liste> I'd pick pipes
01:04:43 <liste> it's easier to learn imo
01:04:51 <bollu> cool, ty :)
01:04:54 <liste> esp. with Gonzales' blog posts
01:04:55 <bollu> any good tutorials?
01:05:38 <liste> bollu https://hackage.haskell.org/package/pipes-4.0.0/docs/Pipes-Tutorial.html
01:06:19 <bollu> thank you!
01:29:26 <Hiro`> Hey folks, I've installed a package in a cabal sandbox, but now when I try to run it (from the sandbox), I get command not found errors. Do I need to specify the relative path to the binary whenever I want to use a sandboxed package?
01:30:11 <KaneTW> when you install something in a sandbox it's installed in <sandbox-dir>/.cabal-sandbox 
01:31:01 <liste> you can add <sandbox-dir>/.cabal-sandbox/bin to your path temporarily
01:31:33 <danza> Hiro`, `cabal run <command>` will build in the sandbox and use it
01:31:36 <Hiro`> KaneTW: Right, it's not hard to work out the path, it's just tedious to type.
01:34:56 <Hiro`> danza: Thanks. When I call `cabal run hakyll-init my-app` I get a message about the package not being configured, then it complains about not finding a .cabal file, then it fails.
01:35:23 <danza> yes, `cabal run` will try to build your package
01:35:47 <danza> first off, i need to mention that many Haskellers recommend to use Stack instead of directly Cabal, nowadays
01:36:14 <danza> second: all those cabal commands that use the sandbox, like `cabal repl`, will try to build your package
01:36:25 <danza> they assume that you have a package in that same directory
01:36:38 <danza> you can build your cabal file easily with `cabal init`
01:36:51 <danza> and then run `cabal configure` to configure
01:36:56 <danza> errors should guide you
01:39:56 <Hiro`> danza: So in general, you would have to create a .cabal file in order to use `cabal run`? I noticed that if I run the hakyll-init binary directly it just builds the app.
01:41:58 <danza> yes, you need a `.cabal` file in order to use `cabal run`. the goal is usually to test or use a script that you are building yourself. i am not sure about the most convenient way to use a script developed by others. i usually install those globally
01:42:54 <Hiro`> Hmm
01:43:31 <danza> Hiro`, i have a Hakyll blog. I just let `cabal init` generate a `.cabal` file for me, then i build my site using `cabal run site build`
01:52:50 <Hiro`> cabal run seems to be expecting to find source code to run to generate the app rather than letting hakyll-init do it.
01:53:24 <merijn> Hiro`: Why would cabal know about hakyll-init?
01:55:25 <catsup> does anyone have emacs/spacemacs flycheck set up to automatically apply hlint suggestions?
01:57:05 <catsup> apparently this does it: http://community.haskell.org/~ndm/darcs/hlint/data/hs-lint.el  ...  but that's its own mode, not a flycheck-based setup
01:57:56 <danza> Hiro`, i am not using `hakyll-init`, i use `site build` as explained here http://jaspervdj.be/hakyll/, so maybe my approach is not very helpful to you
01:59:48 <danza> Hiro`, now i see that `hakyll-init` is the first step, necessary to have a site to build ... sorry, i did this a lot of time ago and i forgot! i guess that the first time i just installed it globally
02:01:10 <danza> Hiro`, if you hate the idea of having things installed globally in your system, i can recommend you to have a look at Nix ... it is a bit hard to get started with, but very powerful
02:01:34 <catsup> oh nice https://github.com/mpickering/hlint-refactor-mode
02:04:05 <Hiro`> danza: it's not that I hate the idea of having stuff globally installed, it's just that I experienced the usual dependency warnings when I tried to install hakyll, so decided to try using a sandbox.
02:04:35 <Hiro`> Trying to avoid cabal hell.
02:05:15 <danza> Hiro`, have a look at Stack, it is supposed to be the new golden bullet for this kind of problems
02:05:30 <danza> or silver bullet, whatever :)
02:09:40 <Hiro`> danza: cool, I will do, Stack sounds interesting. Meantime, I will just use the path to the hakyll-init binary. I'm following the tutorials so it's all just noodling at the mo.
02:10:11 <danza> yeah, it makes sense to use the path, you will run that command probably just once :)
02:10:17 * hackagebot IntervalMap 0.4.1.1 - Maps from Intervals to values, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.4.1.1 (ChristophBreitkopf)
02:12:13 <Hiro`> danza: thanks for your help :)
02:12:20 <danza> sure :)
02:23:41 <kdk> Is anyone aware of a HTTP/2 client library implementation? (something like wreq or http-conduit)
02:24:14 <hsk3> join #haskell-beginners
02:24:24 <hsk3> sorry forgot /
02:26:47 <fakedrake> hello
02:27:33 <fakedrake> What would be a good package for parsing html?
02:28:14 <merijn> fakedrake: html-conduit works well and plugs easily into http-conduit, in my experience
02:29:47 <Axman6> @hoogle tagsoup
02:29:49 <lambdabot> package tagsoup
02:29:49 <lambdabot> package tagsoup-ht
02:29:49 <lambdabot> package tagsoup-parsec
02:30:37 <Axman6> fakedrake: tagsoup is oretty easy to use
02:31:51 <fakedrake> both seem pretty cool thanks!
02:34:44 <Axman6> really depends on what you want to do
02:35:13 <mgsloan> kdk: Good question.  I know that warp now supports HTTP/2, but that's used for servers - http://www.yesodweb.com/blog/2015/07/http2
02:35:18 * hackagebot libgraph 1.8 - Store and manipulate data in a graph.  https://hackage.haskell.org/package/libgraph-1.8 (faddegon)
02:36:49 <kdk> Right, seems to be a bit of an asymmetrical situation for the moment: having a good server implementation (Warp), but no way of interacting with it from within Haskell
03:23:45 <sidoaight> Is there a place that will explain to you /why/ things are named so?  For example, 'init' returns everything but the last element.  Okay fine, but why was it named 'init'?
03:24:01 <quicksilver> no.
03:24:11 <sidoaight> T_T
03:24:12 <julianleviston> init is short for initial
03:24:16 <quicksilver> I can only guess: it's short for initial segment, and they liked the symettry
03:24:21 <quicksilver> head/tail/last/init
03:24:25 <quicksilver> all four characters long
03:24:30 <quicksilver> kind of a stupid reason but still :)
03:25:35 * sidoaight is mildly speechless
03:25:39 <sidoaight> Thank you. :)
03:25:42 <hpc> there have been much stupider reasons for much more terrible names
03:25:48 <hpc> and then there's php
03:26:19 <quicksilver> interestingly standard ML's list module doesn't appear to have 'init' at all
03:26:27 <quicksilver> and it uses hd and tl for head and tail
03:27:07 <opqdonut> nothing beats car and cdr
03:27:10 <opqdonut> and caddadr
03:27:21 <sidoaight> Is there a way to ask GHCI if two functions are the same?
03:27:40 <opqdonut> sidoaight: no, and in general it's undecideable
03:28:07 <quicksilver> miranda had 'last' and 'init'
03:28:12 <quicksilver> but still had 'hd' and 'tl'
03:28:20 <sidoaight> Oh?  That is interesting.  You can't look at the program structure and see if it overlaps perfectly?
03:28:57 <julianleviston> sidoaight: if you translate code to its AST, you could compare that.
03:28:58 <catsup> it depends on the definition of 'the same'...
03:29:03 <julianleviston> sidoaight: sounds like overkill to me tho.
03:29:23 <julianleviston> won’t tell you if they’re equivalent, only identical.
03:29:55 <catsup> well it could tell whether two non-identical functions compiled to identical output
03:30:20 <julianleviston> catsup: how?
03:30:47 <julianleviston> catsup: oh you mean if the code (as data) is identical? That’s pretty much the AST thing.
03:31:30 <quicksilver> but ghci doesn't only work with compiled functions
03:31:41 <catsup> i _meant_ it could be done in theory.  in practice it can also be done, with ghc -ddump flags, but you would have to deal with variable names differing
03:31:53 <catsup> julianleviston: no it's not the same as that
03:32:34 <julianleviston> catsup: good luck, I guess :)
03:32:52 <catsup> good luck with what
03:33:05 <julianleviston> catsup: all the things.
03:33:32 <sidoaight> I'm new to programming... so what I meant by 'the same' was, if you had two functions with the same definitions, if there was a way to ask the computer if they indeed had identical definitions. so, hypothetically, `+` == `+`  might return True.
03:33:49 <julianleviston> sidoaight: yeah, we understand your question. 
03:34:04 <sidoaight> Ah, okay.  Thanks.
03:34:13 <julianleviston> sidoaight: Haskell doesn’t let you do that.
03:34:23 <sidoaight> Good to know.
03:36:04 <hpc> you could maybe do some kind of gross pointer equality thing
03:36:05 <julianleviston> sidoaight: types often give you all the practical power you would want from such a question
03:36:24 <sidoaight> Oh! That makes sense. Should have thought of that. :P
03:36:25 <hpc> which would really only get you "is this thing on the right the exact same specific particular value as the thing on the left"
03:36:26 <julianleviston> sidoaight: it might be better to find the use-case first, then work out how to do the thing. 
03:36:50 <hpc> which would not be really what you want, and the result of that wouldn't really guarantee two functions are different
03:36:50 <danza> i am curious. is there any language allowing this?
03:37:15 <julianleviston> danza: It’s not possible, depending on the definition of “function” :)
03:37:15 <sidoaight> Scheme?
03:37:19 <catsup> danza: you can compare functions for pointer equality in lisp
03:37:36 <danza> catsup, but that is a completely different thing
03:37:44 <julianleviston> catsup: it’s arguable whether scheme has functions. I think they’re called procedures…
03:37:45 <hpc> even C can do pointer equality on functions
03:37:53 <catsup> danza: oh, i thought that is what you meant by 'this'
03:38:08 <hpc> a language that's restricted enough for you to have extensional equality on functions
03:38:21 <hpc> would usually not also be expressive enough to represent that in-language
03:38:43 <hpc> though you may want to look at dependently typed proof languages like agda and coq
03:39:14 <hpc> warning: those are a whole other rabbit hole if you're just learning haskell
03:39:57 <danza> catsup, not sure ... this is how i interpret sidoaight's question ... i thought that he wanted to know whether two functions have the same definition, so that `\ x -> x == \ y -> y` would yield `True`
03:40:05 <danza> but maybe he was just referring to pointers
03:40:42 <catsup> danza: i thought you were replying to hpc for whatever reason
03:41:39 <liste> @check \input::Int -> let { f x = x + x; g x = 2 * x } in f input === g input
03:41:40 <lambdabot>  <unknown>.hs: 1: 7:Parse error: ::
03:41:44 <quicksilver> the original question was about doing it in GHCi, not doing it "within haskell"
03:41:59 <quicksilver> it would not be absurd for GHCi to provide such a thing
03:42:08 <quicksilver> but it might be confusing, and probably wouldn't be that useful in practice.
03:42:21 <liste> @check \input -> let { f x = x + x; g x = 2 * x } in f input === g input -- sidoaight you can check if functions have the same output for random inputs, for testing
03:42:23 <lambdabot>  <hint>:1:180:
03:42:23 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
03:42:27 <quicksilver> having it within haskell *would* be absurd, because it would be non-referentially transparent.
03:42:28 <sidoaight> Ohhh, Now I see the distiction you guys are making between pointer equality and structure equality
03:42:50 <danza> :)
03:43:58 <danza> i believe that in Haskell, equality is performed always on values, thus comparing functions would compare their structure
03:44:36 <danza> i wonder in which other language you could do such a thing
03:44:44 <sidoaight> Can you compare types?
03:44:50 <catsup> equality is defined specifically for each type
03:44:51 * sidoaight just tried this in racket: http://i.imgur.com/lEcHO3Y.png
03:45:12 <liste> sidoaight kinda, on the type level, with ̃~
03:45:15 <catsup> sidoaight: you can kind of compare types in the context where it makes sense with ~
03:46:11 <liste> @let anInt :: a ~ Int => a; anInt = 5
03:46:13 <lambdabot>  Defined.
03:46:21 <catsup> danza: you can define your own Eq instance that does not even compare anything but just uses unsafePerformIO to generate a random bool
03:46:46 <danza> :)
03:46:58 <danza> that would be rather nasty :D
03:48:00 <quicksilver> danza: in haskell functions have no structure.
03:48:08 <catsup> only on types that don't have that instance already though
04:09:30 <cow_2001> guise guise! i wanna use HaskellNet and HaskellNet-SSL to fetch the latest email's attachment off some gmail account's directory, but i don't understand how IMAP works :|
04:10:11 <cow_2001> (apparently "guise" is a word in aspell)
04:10:22 <cow_2001> (ah, that word)
04:10:59 <magneticduck1> a guise, a guise! he's trying to get us to help him with a mundane task!
04:11:20 <cow_2001> ;_;
04:12:12 <cow_2001> who else should i ask?
04:12:23 <cow_2001> i've tried reading the example code
04:12:34 <magneticduck1> wikipedia understands how IMAP works
04:12:43 <magneticduck1> we understand how haskell works
04:12:53 <cow_2001> oh
04:12:56 <magneticduck1> maybe if you're lucky somebody will understand both of them at the same time
04:13:36 <cow_2001> woah it's sorta plaintext
04:15:20 <cow_2001> magneticduck1: you're funny! you're my new favourite #haskell-er!
04:15:48 <magneticduck1> is this another guise
04:16:35 <cow_2001> magneticduck1: i'll use gus next time
04:17:22 <cow_2001> I'd have succeeded if not for you meddling magnetic ducks! D:<
04:18:19 <magneticduck1> learning C++ is twisting me
04:19:21 <magneticduck1> I have half a mind to write my game in Haskell
04:19:28 <magneticduck1> writing games in haskell... I don't know what to think
04:19:40 <magneticduck1> it's fast, and it's the best language I know
04:19:48 <magneticduck1> and it's been done
04:19:49 <merijn> magneticduck1: I don't see why not. I wouldn't recommend it for a twitch FPS
04:20:02 <bollu> GC :(
04:20:05 <merijn> But for slower paced games (i.e. RTS, turn-based, RPG, etc.) I think it'd be fine
04:20:09 <merijn> bollu: Like that matters...
04:20:16 <magneticduck1> my game will be fairly .. twitchy
04:20:20 <magneticduck1> needs to be very responsive
04:20:42 <magneticduck1> it's a bit of a nightmare trying to find the best development platform
04:20:43 <bollu> merijn: it sorta does..?
04:20:45 <dramforever> magneticduck1: not exactly C++ fast, I would say, you gotta take care
04:20:49 <merijn> responsive as in latency or as in jitter
04:20:53 <magneticduck1> I've already have a taste of JavaScript and Haxe
04:20:58 <magneticduck1> s/have/have had
04:21:04 <merijn> latency should be fine with haskell, it's jitter that you'd have to worry about
04:21:17 <magneticduck1> I'm having GC issues with Haxe, and, well, *javascript issues* with JavaScript
04:21:47 <magneticduck1> and C++ looks fast and tested, libGDX looks promising and also tested, but now Haskell's beckoning me
04:21:50 <kingket> what do you use haskell for?
04:22:13 <magneticduck1> I haven't used it for reactive interfaces in the past
04:22:42 <magneticduck1> last job I had in haskell was writing a data mining system of sorts
04:22:50 <magneticduck1> I'm a bit of a stranger to making haskell go fast
04:22:54 <aweinstock> magneticduck1: Rust is kinda halfway between C++ and Haskell
04:23:13 <merijn> kingket: Basically almost everything I write (even quick scripting for shell stuff) except my current GPU benchmarking :p
04:23:27 <magneticduck1> kingket: oh, is this a question aside?
04:23:38 <magneticduck1> or were you following up my line of thought?
04:23:50 <kingket> magneticduck1: yeah, i realized it was confusing
04:23:56 * magneticduck1 still confused
04:24:17 <aweinstock> (i.e. you at least have ADTs / patternmatching / typeclasses (as traits) in Rust, unlike in C++)
04:24:30 <kingket> i'm interested in reactive stuff as well
04:24:45 <magneticduck1> FRP is pretty.. interesting
04:24:48 <magneticduck1> but it's a complex problem
04:26:51 * magneticduck1 has also considered writing the game in Clojure using libGDX
04:27:03 <magneticduck1> I can write Clojure and have it compiled to JavaScript and Java bytecode apparently
04:27:13 <magneticduck1> that's a bit frightening
04:27:30 <aweinstock> can't you also compile haskell to JS with GHCJS?
04:27:38 <magneticduck1> yeah you can
04:27:39 <merijn> aweinstock: Yes
04:27:46 <merijn> Also UHC compiles to JS, afaik
04:27:59 <aweinstock> (and also, if JS is a viable backend, doesn't that mean that haskell's GC overhead is acceptable for your purpose?)
04:28:29 <magneticduck1> I thought C++ would be a refreshing bit of pedal-to-the-metal efficency and down-to-earth connection with the way things are really done on a computer
04:28:34 <magneticduck1> but it's just making me sad :<
04:28:42 <magneticduck1> I'll look at Rust
04:28:53 <aweinstock> and you can always use Data.Vector.Unboxed.Mutable if you need speed in haskell
04:30:21 <bjz_> magneticduck1: Rust aint as pretty as haskell, but it's a nice language to work for stuff that needs to be low-overhead and predictable
04:31:26 <magneticduck1> and what's the tradeoff with C++?
04:32:02 <aweinstock> only LLVM backend, not GCC (might be a drawback if you need obscure embedded systems)
04:32:47 <magneticduck1> I don't need that
04:33:21 <aweinstock> anything you can do with C++, you can do with Rust (in some cases by fiddling with raw pointers with "unsafe"), and for the most part it's just a more ML-ish/less warty C++
04:34:04 <magneticduck1> sounds good
04:34:34 <bjz_> magneticduck1: none really - except buy-in to the C++ ecosystem (there is a C ffi though), and more up-front friction from getting things past the borrow checker
04:34:35 <aweinstock> It doesn't have built-in OOP like C++ does, but that's arguably a feature, and you can probably fake it with structs of functions if you really need it
04:34:49 <julianleviston> Is it possible to have an (Either String a) monad?
04:35:01 <KaneTW> yes, but you'd have to newtype it
04:35:04 <julianleviston> where the type changes?
04:35:05 <aweinstock> bjz_: so much less segfaults though, once it compiles
04:35:14 <bjz_> aweinstock: indeed!
04:35:15 <julianleviston> I want the type to change each action tho
04:35:20 <julianleviston> probably not, I’m guessing
04:35:46 <bjz_> aweinstock: much more, 'if it compiles, it probably works!'
04:35:51 <KaneTW> wait, Either String a :: *
04:35:51 <aweinstock> julianleviston: newtype EitherString a = { unES :: Either String a}; instance Monad EitherString where ...
04:36:05 <KaneTW> you can only make a monad Either String :: * -> *
04:36:15 <KaneTW> ^
04:36:28 <julianleviston> I don’t understand
04:36:57 <julianleviston> I seem to be able to do this with Maybe, just fine.
04:37:09 <KaneTW> i think we have a communications problem
04:37:18 <julianleviston> not maybe, IO, sorry.
04:37:33 <pdkr> julianleviston: are you asking: can I make "Either String a" into a monad in a sensible way? then the answer is yes and well-known
04:37:50 <julianleviston> pdkr: I’m asking a different question that may be the same question.
04:37:52 <pdkr> it is one of the common ways to do error handling
04:38:00 <julianleviston> Yeah, that’s what I’m asking then.
04:38:12 <julianleviston> pdkr: but I also want it to be in IO at the same time.
04:38:19 <julianleviston> pdkr: because one of my actions is in IO.
04:38:21 <KaneTW> then you need an EitherT
04:38:25 <pdkr> julianleviston: then you are also asking about monad transformers :)
04:38:27 <aweinstock> pdkr: "Either String a" isn't a Monad, it's a monadic action, "Either String" is a Monad
04:38:48 <aweinstock> s/a monadic action/the type of \0/
04:39:01 <KaneTW> ExceptT, sorry. usage of EitherT is discouraged iic
04:39:03 <KaneTW> iirc/
04:39:14 <julianleviston> KaneTW:  ah… yeah, ExceptT right?
04:39:23 <julianleviston> KaneTW:  even though it’s not exceptions? 
04:39:34 <pdkr> julianleviston: "exception" can mean different things :)
04:39:47 <julianleviston> pdkr: if you say so
04:39:52 <KaneTW> ExceptT is isomorphic to EitherT 
04:40:00 <julianleviston> KaneTW:  what does that mean?
04:40:07 <KaneTW> same semantics
04:40:08 <julianleviston> KaneTW:  do you mean “the same as”?
04:40:18 <julianleviston> KaneTW:  and what does “same semantics” mean?
04:40:20 <merijn> julianleviston: isomorphic == losslessly convertible
04:40:20 <pdkr> (docs for ExceptT https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html )
04:40:25 <julianleviston> merijn: thanks :)
04:41:01 <julianleviston> Hm.
04:41:11 <julianleviston> So what should I use ?
04:41:12 <pdkr> julianleviston: well it's not quiet "the same as" in the sense that you would need to do an unsafeCoerce
04:41:49 <julianleviston> This seems terribly complex
04:41:50 <pdkr> julianleviston: so from a theoretical POV, they are not the same type so they are not the same period. so that's why KaneTW is careful with his/her choice of words. but yes, you can think "the same"
04:42:03 <pdkr> s/same period/same, period/
04:42:08 <julianleviston> So right now, which should I use?
04:42:12 <pdkr> exceptt
04:42:21 <KaneTW> yup
04:42:50 <merijn> julianleviston: i.e. you can convert any EitherT into ExceptT and back and any operation on EitherT can be translated to an operation on ExceptT such that if A and B are EitherT and f is an operation on EitherT there's a conversion function T "A -f-> B" means that "T(A) -T(f)-> T(B)" and there exists a conversion S such that "S(T(A)) = A", "S(T(B)) = B" and "S(T(f)) = f"
04:42:56 <pdkr> julianleviston: in your case, ExceptT String: because you want your errors to consist of strings
04:43:12 <julianleviston> I actually want bytestring, but yeah, ok cool
04:43:15 <pdkr> (the first argument of ExceptT is the type of your error values. the second is your monad)
04:43:20 <pdkr> (so in fact ExceptT String IO )
04:43:21 <julianleviston> yep
04:43:27 <julianleviston> erm
04:43:56 <pdkr> do you know about monad transformers?
04:44:01 <julianleviston> A bit.
04:44:08 <julianleviston> enough that I’ve used them quite a few times.
04:44:22 <julianleviston> But I’m loathe to say I know anything when it comes to this channel
04:44:41 <julianleviston> The monad I want to be in is Either.
04:44:49 <julianleviston> I think.
04:45:12 <julianleviston> because I want to be able to talk about “right values” of different types
04:45:31 <julianleviston> and have any of them “fail” to a bytestring.
04:45:41 <julianleviston> otherwise, it should all “succed” to a bytestrting.
04:45:44 <julianleviston> succeed*
04:45:52 <julianleviston> (these bytestrings are Left BS and Right BS
04:46:16 <julianleviston> But one of my actions is in IO.
04:46:30 <julianleviston> I’ve spent an hour or two on it trying to work it out, but I haven’t managed.
04:46:33 <julianleviston> hence my questions.
04:47:46 <julianleviston> So it might be that I actually want to have an Either ByteString monadic context, but MonadIO… is that correct?
04:48:03 <pdkr> julianleviston: i'm not quite sure what you're concerned about
04:48:06 <julianleviston> I’m not really sure.
04:48:15 <julianleviston> pdkr: I have 3 actions.
04:48:20 <pdkr> julianleviston: the "ExceptT ByteString IO" /monad/ allows you to pass values of any type *within that monad*
04:48:38 <pdkr> note that ExceptT ByteString IO is not a type but a type constructor
04:48:45 <pdkr> ie it has kind * -> *
04:49:00 <julianleviston> pdkr: but that’s not what I want, is it?
04:49:18 <pdkr> so ExceptT ByteString IO Int could be your input value, and ExceptT ByteString IO String could be your output value
04:49:20 <julianleviston> pdkr: I’m not too sure what that type will give me at the end. I need an IO ByteString.
04:49:42 <pdkr> are you concerned with how to "unpack" the data you eventualyl get?
04:49:54 <julianleviston> pdkr: no, but I don’t understand that type.
04:49:58 <julianleviston> pdkr: but probably yes.
04:50:35 <julianleviston> pdkr: both e and o need to be in IO ByteString, not IO String or ByteString.
04:50:35 <pdkr> ExceptT .... is the same as Either Bytestring, except that it also allows you to, instead of making pure computations on the Right value, access IO
04:50:39 <julianleviston> Unless I don’t understand it.
04:50:51 * hackagebot yesod-core 1.4.17 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.17 (MichaelSnoyman)
04:50:53 * hackagebot haskell-gi-base 0.10.1 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.10.1 (inaki)
04:51:16 <pdkr> pdkr: "ExceptT ByteString IO" is a monad that allows you to give error values of type ByteString that you obtain from IO
04:51:16 <julianleviston> pdkr: yeah, that’s what I thought.
04:51:26 <julianleviston> pdkr: I don’t want that.
04:51:31 <pdkr> well you don't need to do it
04:51:40 <julianleviston> pdkr: I want the “errors” to be obtained from the non-IO portions.
04:51:58 <pdkr> but whether you get an error or not might already depend on IO, no?
04:52:04 <julianleviston> pdkr: no.
04:52:12 <julianleviston> pdkr: the error is based on map lookup.
04:52:25 <julianleviston> pdkr: it’s not “error” in the traditional sense, it’s just whether something is missing.
04:52:50 <julianleviston> pdkr: if it can’t find the data, it throws up its hands and says “stopping here, with this problem”
04:53:07 <pdkr> julianleviston: okay, if you want to be restrictive, I guess you could use ExceptT ByteString Identity. and then give the value as an IO Whatever
04:53:27 <julianleviston> pdkr: restrictive?
04:53:44 <pdkr> in the sense that you do not even want to *allow* error values to depend, directly or indirectly, on IO
04:53:55 <julianleviston> pdkr: but it needs to “run” the IO action to determine a piece of data for the 3rd action.
04:54:13 <julianleviston> pdkr: no it’s just a matter of that the errors have nothing to do with the IO.
04:54:15 <pdkr> right. but only if the map lookup suceceded
04:54:37 <pdkr> so you only need to run IO stuff if the map lookup succeded. right?
04:54:42 <latk> Is there a way to wrap an xml conduit cursor in a top level tag?
04:54:42 <pdkr> succeeded*
04:55:18 <julianleviston> pdkr: in sequence: lookup map, run IO action… convert to ByteString, pass to 3rd action (looks up another map), if successful, run the function it found on data from IO action, if not, pass data back.
04:55:29 <julianleviston> pdkr: yeah
04:55:41 <pdkr> julianleviston: ah. but the second lookup depends on the IO action then
04:55:50 <julianleviston> pdkr: no
04:55:52 <pdkr> because the thing that it has to lookup depends on IO
04:55:56 <julianleviston> pdkr: no
04:55:57 <latk> I'm trying to extract all the content from an xml-conduit cursor, but it misses off stuff at the top level. e.g. This is missed <p>all this is included</p>
04:56:25 <julianleviston> pdkr: the IO returns a Maybe ByteString which I then convert (with a case) to a ByteString (Nothing -> “”)
04:56:28 <pdkr> julianleviston: okay, so one might as well reorder it as follows: lookup map, lookup another map, run IO, convert to ByteString
04:57:07 <pdkr> right?
04:57:14 <pdkr> not saying you have to, just monad wise
04:58:05 <julianleviston> pdkr: I think that’s right.
04:58:39 <pdkr> then you can also use the "Except ByteString" monad
04:58:52 <pdkr> (which just plugs in the Identity monad in ExceptT)
04:58:54 <julianleviston> pdkr: sure, but what about the IO?
04:59:03 <pdkr> you'd output that as an IO value
04:59:22 <pdkr> so your final function would look like e.g. Except ByteString (IO MyData)
04:59:22 <julianleviston> pdkr: I’m a bit confused.
04:59:42 <julianleviston> pdkr: but don’t BOTH bytestrings have to be in IO?
05:00:04 <pdkr> julianleviston: why would they be? the error value is just based on the map lookups
05:00:16 <pdkr> which are pure
05:00:28 <julianleviston> pdkr: because the whole function (that this happens in) is in IO ByteString
05:00:43 <julianleviston> I guess I can just return it.
05:00:44 <julianleviston> ok
05:00:48 <pdkr> that sentence doesn't make any sense without context / example code
05:00:52 * hackagebot haskell-gi 0.10.2 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.10.2 (inaki)
05:00:53 <julianleviston> NOw I have to work out how to do this.
05:01:35 <pdkr> julianleviston: so you want to write a function (Except Bytestring (IO ByteString)) -> IO Bytestring  ?
05:01:52 <julianleviston> pdkr: not especially.
05:02:01 <julianleviston> pdkr: I have a function Integer -> IO ByteString
05:02:04 <pdkr> well not specifically, but this is what you'd need
05:02:18 <pdkr> put another way: would that solve your problem?
05:02:21 <julianleviston> pdkr: and I want to make it use an Either monad
05:02:44 <julianleviston> pdkr: Um… I don’t know.
05:02:53 <pdkr> yeah well if you want to use an either monad, use an either monad. i cannot respond to this.
05:03:15 <julianleviston> pdkr: No, I don’t have to use an Either monad. Don’t get crappy at me! :)
05:03:26 <KaneTW> what's our use case
05:03:27 <julianleviston> pdkr: I just meant that I thought that was the way to go..
05:03:32 <KaneTW> your/
05:03:49 <julianleviston> KaneTW: It’s a function that takes an integer and returns an IO ByteString
05:04:03 <julianleviston> KaneTW: and I don’t want to write 4 deep case statements
05:04:10 <pdkr> julianleviston: okay, that's fine. but we can't tell you the way to go. we can only show you the tools.
05:04:17 <julianleviston> KaneTW:  and I’d like to “exit early” with an error message
05:04:19 <pdkr> the path, i suppose
05:04:26 <julianleviston> pdkr: yeah, I appreciate that
05:05:55 <julianleviston> pdkr: is there anywhere I can see some example code for ExceptT?
05:06:02 <pdkr> julianleviston: you can use ExceptT e IO  to write functions that exit early with error value IO e
05:06:10 <julianleviston> pdkr: or even more ideally, ExceptT String as a monad with a do block?
05:06:39 <kqr> is there some sort of construct in Haskell to express "Just x if p else Nothing"? other than [ x | p ] with MonadComprehensions
05:06:45 <julianleviston> pdkr: and could I put that within my Interer -> IO ByteString function?
05:07:49 <pdkr> kqr: bool p (Just x) Nothing
05:07:52 <pdkr> if that counts
05:08:10 <kqr> a bit too explicit to count
05:08:11 <quchen> kqr: x <$ guard p
05:08:25 <kqr> ah yes, I recall having seen that before
05:08:33 <kqr> I guess that's a relatively literal translation of the monad comprehension?
05:08:44 <KaneTW> :t (<$)
05:08:45 <lambdabot> Functor f => a -> f b -> f a
05:08:46 <pdkr> julianleviston: sure. you'll just have to find a way to deal with either value you end up with: error or success value
05:08:59 <quchen> No, it's not really. <$ is functorial, MonadComp doesn't use that.
05:09:05 <julianleviston> pdkr: I can just use a case can’t I?
05:09:11 <pdkr> sure
05:09:28 <julianleviston> pdkr: tho I don’t really know how to do all this at all
05:09:44 <kqr> wait, let me generalise my question
05:09:57 <kqr> equivalent to "if p x then Just x else Nothing"
05:10:04 <julianleviston> maybe I should just do it the stupid way
05:10:06 <pdkr> output <- runMyLookupConversionFunc bla; case output of; Left err -> ...; Right val -> ...;
05:10:06 <kqr> i guess it'd be something monadplussy or whatever it is but eh
05:10:36 <KaneTW> julianleviston: so you have an IO action where depending on the result of said action, a computation can fail?
05:11:40 <pdkr> julianleviston: having said all this, here's a piece of moral advice. if you're doing two pure lookups before any IO, you might want to think about the composability of the function that you're writing. shouldn't you break it apart so that you can reuse the chunks later?
05:12:15 <pdkr> shouldn't the types involved in the lookup be specialized so that you can distinguish different kinds of data?
05:12:38 <pdkr> newtype wrappers are free (at runtime)
05:12:49 <julianleviston> KaneTW: No, I have a function Integer -> IO ByteString in which I want to look up a value with the Integer in a map, then if it fails at that, returns a certain bytestring… if it succeeds, then run an IO action which returns an IO (Maybe ByteString), which it then converts to a ByteString (called data) which it then passes to a second lookup where it finds a function or doesn’t. If it doesn’t, error message as #1, 
05:12:49 <julianleviston> it does, run the function on “data” and pass that back.
05:13:13 <SrPx_> Is there any virtualdom-like library on Haskell? Elm, for example, has "Html", which I believe is compiled to virtualdom under the hoods, enabling efficient diff/patch updates of web apps rendered functionally. I'm not looking for a fully featured FPR library but just the view part
05:13:23 <pdkr> julianleviston: okay, so the second lookup *is* dependent on IO!
05:13:38 <julianleviston> pdkr: no.
05:14:02 <pdkr> yes. the lookup /function/ is not, but the key for the lookup is obtained from that IO (Maybe ByteString)
05:14:04 <julianleviston> pdkr: if the IO “works” then it returns that data (out of the Maybe), is it doesn’t, then it returns an empty ByteString
05:14:09 <julianleviston> No
05:14:20 <julianleviston> the key comes from the first lookup (it finds something which has 3 pieces of data in it)
05:14:41 <pdkr> but you said it passes "data" to a second lookup
05:14:49 <julianleviston> pdkr: it does
05:14:56 <julianleviston> pdkr: but it’s not the key
05:15:09 <julianleviston> pdkr: it’s one of the arguments sent to the function that gets found or not.
05:15:14 <pdkr> ah
05:15:30 <julianleviston> sorry!
05:15:39 <pdkr> no that's okay :)
05:15:51 <julianleviston> I really wish I could show you example code, but at the moment it’s in a mess, and it doesn’t do what I want the final one to do, so it wouldn’t help much
05:16:09 <julianleviston> I *could* show you what I want it to work like
05:16:17 <pdkr> again though: think about if you can break up your big function into smaller pieces with types that are easier to understand
05:16:24 <pdkr> (but at least as accurate)
05:16:27 <julianleviston> that’s great advice.
05:16:30 <julianleviston> maybe I’ll do that
05:16:44 <julianleviston> give me a minute or two and I’ll try to do that
05:18:00 <absence> :t \x -> case x of Right b | b -> Right (); _ -> Left "something"
05:18:01 <lambdabot> Either t Bool -> Either [Char] ()
05:18:07 <absence> is there a more clever way to do that?
05:18:38 <latk> What is the easiest way to remove all html tags from a string ?
05:19:11 <KaneTW> parse it and extract cdata
05:19:28 <KaneTW> use an actual parser, not regex
05:20:53 <latk> Yeah, I tried with xml conduit, but it misses stuff.
05:21:03 <latk> I think because the xml is malformed
05:22:13 <KaneTW> html-conduit maybe? i don't know the go-to packages for html parsing
05:22:13 <pdkr> absence: this is a partial function
05:22:17 <merijn> Have you tried html-conduit?
05:22:27 <merijn> pdkr: It is not
05:22:39 <pdkr> so what does it do on a Left t input?
05:22:47 <merijn> absence: That looks like ">>= guard" to me?
05:22:56 <KaneTW> monad won't work
05:22:58 <merijn> pdkr: Return 'Left "something"'
05:23:01 <pdkr> or ahh, a Right False
05:23:34 <KaneTW> monad can only do Either t Bool -> Either t (), but not Either t Bool -> Either [Char] ()
05:23:38 <merijn> KaneTW: Oh, because you lose the error message in left?
05:24:09 <KaneTW> you gain it with that function, ignoring the previous left
05:24:42 <pdkr> merijn: what is Right False of this function?
05:24:43 <latk> merijn, KaneTW: yeah, I was actually using html content to get the cursor. The input text didn't have an enclosing tag, looking at it, so I guess that is why it missed the beginning.
05:25:30 <KaneTW> :t \x -> guard >>= either (const "something") (const ()) x 
05:25:31 <lambdabot>     Couldn't match expected type ‘f0 () -> Bool -> b’
05:25:31 <lambdabot>                 with actual type ‘[Char]’
05:25:31 <lambdabot>     In the first argument of ‘const’, namely ‘"something"’
05:26:15 <KaneTW> :t \x -> either (const "something") (const ()) (guard x)
05:26:17 <lambdabot>     Couldn't match expected type ‘[Char]’ with actual type ‘()’
05:26:17 <lambdabot>     In the first argument of ‘const’, namely ‘()’
05:26:17 <lambdabot>     In the second argument of ‘either’, namely ‘(const ())’
05:26:20 <KaneTW> nope
05:26:28 * OverCoder taps on himself
05:26:30 <merijn> pdkr: False through to the _ case
05:26:38 <pdkr> huh
05:26:41 <merijn> pdkr: Failing guards fall through to the next case match
05:26:46 <pdkr> wow seriously?
05:26:50 <KaneTW> yeah
05:26:52 <merijn> s/False/Falls
05:26:54 <merijn> pdkr: Yes
05:26:59 <pdkr> ok good to know :P
05:27:11 <absence> merijn: good pun though ;)
05:27:19 <pdkr> sorry about that, merijn :)
05:27:57 <julianleviston> what’s the thing you can write in a do block that will only run an action if a predicate is true?
05:28:07 <julianleviston> when?
05:28:22 <KaneTW> :t when
05:28:23 <lambdabot> Applicative f => Bool -> f () -> f ()
05:28:28 <julianleviston> ah sorry
05:28:29 <julianleviston> thanks
05:28:45 <julianleviston> I have no idea if that fits my case lol
05:29:04 <julianleviston> Do I need to import applicative?
05:29:13 <merijn> pdkr: Basically a failing guard is equivalent to a failing pattern, which can be useful in destructuring complex inputs :)
05:29:56 <KaneTW> julianleviston: when is in Control.Monad
05:30:02 <julianleviston> ah ok
05:30:03 <julianleviston> thanks
05:30:06 <SX> Hi guys! I want to isolate some pure code from IO. It's a network client-server, actual communication is IO of course, but packet generation/encryption is not. The problem is, I need to use (and modify) some ST during encryption (like seed) and make it persistent (and thread safe). How to design such a thing?
05:30:47 <julianleviston> :t isLeft
05:30:49 <lambdabot> Either a b -> Bool
05:31:48 <SrPx> Sorry, lost connection, in case anyone answered. 
05:35:38 <absence> KaneTW: so there's no trick to simplify that bool-in-either thing?
05:36:00 <KaneTW> not that i know of
05:38:51 <absence> KaneTW: if the problem looked slightly different, would it be easier?
05:42:40 <KaneTW> if you don't need to modify the left type
05:42:52 <KaneTW> :t (>>= guard)
05:42:53 <lambdabot> (Monad m, Alternative m) => m Bool -> m ()
05:43:23 <KaneTW> > Right True >>= guard
05:43:25 <lambdabot>      No instance for (Show a0)
05:43:25 <lambdabot>        arising from a use of ‘show_M618260949298838756631394’
05:43:25 <lambdabot>      The type variable ‘a0’ is ambiguous
05:43:32 <KaneTW> no alternative instance i guess
05:49:16 <absence> > (Right True :: Either String Bool) >>= guard
05:49:18 <lambdabot>  Right ()
05:49:38 <absence> > (Right False :: Either String Bool) >>= guard
05:49:40 <lambdabot>  Left ""
05:51:35 <julianleviston> KaneTW:  ok I think I’ve built an ugly ugly thing that perhaps does what I want.
05:51:48 <julianleviston> KaneTW:  it compiles, at least, and seems to be right
05:52:11 <KaneTW> well that's a start
05:52:22 <lpaste> JulianLeviston pasted “Can I make this prettier / better?” at http://lpaste.net/146476
05:52:43 <julianleviston> pdkr: also ^ :)
05:53:10 <julianleviston> pdkr: thanks for suggesting to split it up. That helped me think about it a lot. Honestly, can’t believe I didn’t think of doing that myself :) 
05:53:31 <julianleviston> pdkr:  god knows I recommend people do that all the time enough. You’d think I’d take my own medecine :)
05:53:49 <absence> KaneTW: where's the instance defined though? o_O can't find it in the docs, is there a way to ask lambdabot?
05:54:59 <absence> KaneTW: i mean, how does it know to make an empty string?
05:55:31 <KaneTW> i'm confused, too
05:55:37 <KaneTW> i can't find an Alternative instance
05:55:55 <julianleviston> KaneTW:  so I’m not completely insane, right? the code in runDesign’ *should* be able to be refactored into a monad, yeah? I mean… so many cases and returns…
05:55:56 <KaneTW> and lambdabot doesn't support :i
05:56:41 <absence> > (Right False :: Either Int Bool) >>= guard
05:56:43 <lambdabot>      No instance for (Control.Monad.Trans.Error.Error Int)
05:56:43 <lambdabot>        arising from a use of ‘guard’
05:56:43 <lambdabot>      In the second argument of ‘(>>=)’, namely ‘guard’
05:57:03 <absence> :s
05:57:04 <KaneTW> wha
05:57:21 <pdkr> julianleviston: believe me, even if you've programmed haskell for years, this advise is still helpful
05:58:13 <julianleviston> pdkr: yeah :) just usually I manage to take my own advice. Any thoughts about my code?
05:59:18 <KaneTW> julianleviston: ExceptT seems like you want to use
05:59:36 <julianleviston> KaneTW:  sweet… 
06:00:17 <KaneTW> julianleviston: something like do { (dataId, dataName, designType) <- lookupDesign identifier; f <- getTheDesignTypeFn designType; d <- lift $ getTheBlockData dataId dataName; return (f d) }
06:00:37 <KaneTW> alternatively
06:01:04 <julianleviston> That’s exactly what I want.
06:01:21 <julianleviston> well it reads like it is. I don’t know what types to make things tho, and do I need to use runExceptT or whatever?
06:01:36 <julianleviston> I guess I could just give it a burl.
06:08:21 <pdkr> julianleviston: at some point in haskell you reach a point where you start caring more about the types than the code, and these kinds of decisions follow more naturally. so in any case don't worry about not seeing this yet.
06:08:50 <julianleviston> pdkr: uhhhh
06:09:04 <julianleviston> pdkr: I care about types.
06:09:21 <julianleviston> pdkr: but if the code is a 5 layer case statement, something is wrong.
06:09:22 <pdkr> okay, let me rephrase that. you start thinking in terms of types more than in terms of fitting the code in your types
06:09:43 <julianleviston> pdkr: huh?
06:09:54 <pdkr> ie you think of types as doing something in themselves, rather than merely satisfying the type checker
06:10:02 <pdkr> ... was my experience, anyway
06:11:43 <julianleviston> pdkr: yeah, I do think of that (AFAIK)
06:12:08 <pdkr> okay, nevermind this then :)
06:12:24 <julianleviston> pdkr: if you’re thinking that Tuple is weird, that’s a work in progress… it will eventually be a sum type.
06:12:31 <julianleviston> pdkr: sorry, product type…
06:13:07 <julianleviston> pdkr: I honestly didn’t think this do block would take all day. oh well :)
06:15:19 <absence> :t join $ guard <$> Right False
06:15:21 <lambdabot> Control.Monad.Trans.Error.Error a => Either a ()
06:15:28 <absence> i'm very curious about what's going on here :)
06:16:57 <geekosaur> @instances-importing Control.Monad.Trans.Eror Error
06:16:57 <geekosaur> er
06:16:57 <geekosaur> @instances-importing Control.Monad.Trans.Error Error
06:16:58 <lambdabot> Couldn't find class `Error'. Try @instances-importing
06:17:01 <lambdabot> IOException, [a]
06:18:38 <absence> geekosaur: so...
06:18:56 <geekosaur> @instances-importing Control.Monad.Trans.Error Control.Applicative Error
06:18:58 <lambdabot> IOException, [a]
06:19:01 <geekosaur> hm
06:22:33 <geekosaur> :t guard
06:22:35 <lambdabot> Alternative f => Bool -> f ()
06:23:03 <julianleviston> Ah I love this language so much.
06:23:24 <hrnz> I love you too, honey ♥
06:23:29 <julianleviston> lol
06:23:48 <julianleviston> sorry, I’m just feeling all warm and gooey because it’s so cool :)
06:24:42 <hrnz> ☺
06:25:54 * hackagebot prelude-edsl 0.2 - An EDSL-motivated subset of the Prelude  https://hackage.haskell.org/package/prelude-edsl-0.2 (EmilAxelsson)
06:35:17 * OverCoder starts to panic
06:35:27 <OverCoder> C'mon Haskell, where are Variable? or even while/for loops?
06:35:37 <OverCoder> variables*
06:35:43 <linduxed> we kind of misplaced them
06:35:48 <linduxed> then we never found them again
06:35:52 <linduxed> :-/
06:36:06 <pdkr> OverCoder: does IOVar count?
06:36:46 <julianleviston> hang on, we have loops… don’t we? 
06:36:52 <OverCoder> I haven't learned about IOVars, but as far as I have seen (also after Googling), all these don't exist
06:36:54 <c_wraith> OverCoder: strange thing is, after a short while, you don't even miss them.
06:36:58 <julianleviston> there’s a while loop in monad isn’t there?
06:37:00 <OverCoder> julianleviston, Recursion
06:37:09 <julianleviston> OverCoder: no, there’s a loop.
06:37:12 <c_wraith> OverCoder: it really makes you question why you thought they were important in the first place.
06:37:47 <OverCoder> julianleviston, from the tut: That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion
06:37:50 <julianleviston> https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
06:38:09 <OverCoder> c_wraith, They are necessary for everything
06:38:09 <c_wraith> OverCoder: you can write a while function if you want.  There's nothing hard about it.
06:38:16 <OverCoder> Also recursion isn't as efficient as loops
06:38:23 <pdkr> haha
06:38:28 <c_wraith> OverCoder: wow.  Way to make unfounded assumptions
06:38:43 <c_wraith> OverCoder: any decent compiler (and GHC is a decent compiler) doesn't have that issue.
06:39:14 <tdammers> so clojure is only semi-decent? :D
06:39:19 <tdammers> sounds about right :D
06:39:23 <c_wraith> Well, it's stuck with the JVM
06:39:26 <c_wraith> So, yeah
06:39:33 <pdkr> garbage in, garbage out
06:39:39 <julianleviston> OverCoder: let’s try from the other angle… what on EARTH would you use a LOOP for?!?!
06:39:39 <OverCoder> AFAIK, comping from imperative langs, when a function is called, registers are replaced, stack is filled more with data, frames, and other stuff
06:39:52 <pdkr> OverCoder: yes. this is not the case in haskell.
06:39:54 <geekosaur> you're already in trouble
06:39:55 <c_wraith> OverCoder: what makes you think any of that applies to compiling haskell?
06:40:25 <julianleviston> OverCoder:  “How can you print the numbers 1 to 100 without a loop?”
06:40:38 <OverCoder> c_wraith, One thing, one thing that I am unsure of, I read somewhere that Haskell requires C in it's backend
06:40:48 <aweinstock> julianleviston: mapM_ print [1..100]
06:40:57 <c_wraith> OverCoder: only if you're targetting a new architecture.
06:41:03 <pdkr> OverCoder: even if that's true, that doesn't imply that haskel functions are compiled to C functions
06:41:06 <aweinstock> mapM_ is arguably a "for-each" loop (kinda)
06:41:24 <OverCoder> julianleviston, [1..100]
06:41:43 <julianleviston> OverCoder: “How could you possibly add up a set of numbers without loops?"
06:41:48 <OverCoder> Alright then, so you're trying to tell me that: While/For loops aren't useful
06:41:55 <OverCoder> How about I/O?
06:41:57 <pdkr> no. they're just not necessary
06:41:58 <aweinstock> foldr (+) 0
06:41:59 <julianleviston> OverCoder: No, just that they’re not the only way.
06:42:09 <c_wraith> OverCoder: looping is important.  The exact expression doesn't matter so much.
06:42:11 <aweinstock> they're occasionally useful, but they're low-level
06:42:13 <OverCoder> julianleviston, sum [1..100]
06:42:27 <julianleviston> These are rhetorical questions by the way.
06:42:31 <c_wraith> OverCoder: haskell does IO amazingly well.
06:42:33 <julianleviston> I know how to do these things :)
06:42:44 <pdkr> OverCoder: why would you want to program in the same set of concepts as the processor understands? why wouldn't you want to move to a higher-order view of the world?
06:43:04 <c_wraith> OverCoder: all IO is reified as values conceptually, while still using a representation that's efficient at runtime.
06:43:18 <c_wraith> OverCoder: that's an approach lots of other languages could learn from.
06:43:23 * OverCoder reorganizes his thinking
06:43:26 <aweinstock> Haskell's pretty good at imperative-style scripting: https://github.com/aweinstock314/sheedb_weinsa_crypto2015_project/blob/master/redteam/MitmProxy.hs
06:43:28 <pdkr> i mean you might as well program in terms of voltages. or the location in 3D space of individual electrons
06:43:44 <aweinstock> (that's something I'm working on now for a crypto class)
06:43:45 <pdkr> (though I'm sure there's an emacs command to do that)
06:43:54 <osa1> how to I make GHCi to show kinds of type variables?
06:44:00 <aweinstock> pdkr: 3D? I thought stringtheory was 11D?
06:44:06 <bollu> osa1 :k?
06:44:17 <pdkr> aweinstock: well then you should start saying "world lines" rather than "location" :)
06:44:35 <uuidgen> Question: How to transform a FileOffset (result of reading a file size) into Scientific ?
06:44:35 <pdkr> also, with quantum stuff, "world cloud" in some as-yet undefined way
06:44:49 <osa1> bollu: no, I mean kinds of types in a term
06:44:59 <aweinstock> uuidgen: if Scientific is Num, probably fromIntegral
06:45:24 <osa1> so it should take a term as argument
06:45:30 <osa1> :k is for types
06:45:31 <lambdabot>     Not in scope: type variable ‘is’
06:45:31 <lambdabot>     Perhaps you meant type constructor or class ‘As’ (imported from Control.Lens)
06:45:31 <lambdabot> Not in scope: type variable ‘for’
06:46:42 <julianleviston> “the sound of water”
06:47:05 <uuidgen> aweinstock: perfect! Thanks!!
06:50:55 * hackagebot prelude-edsl 0.3 - An EDSL-motivated subset of the Prelude  https://hackage.haskell.org/package/prelude-edsl-0.3 (EmilAxelsson)
07:18:39 <deni> how do i get the list of keys from a map?
07:20:08 <byorgey> @type Data.Map.keys
07:20:10 <lambdabot> M.Map k a -> [k]
07:20:12 <byorgey> deni: ^^^
07:21:35 <deni> hmmm I have no idea why the hackage docs don't list that function
07:21:47 <deni> perhaps my google search linked me to an older version
07:22:07 <geekosaur> something's up with haddock :(
07:22:30 <deni> I was looking at this: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map.html
07:22:31 <geekosaur> I keep running into docs missing various things or even truncated
07:22:58 <deni> well that's embarassing i should have tried keys because it's the obvious choice..but then again I've had this issue with the docs quite a few times already sign
07:23:00 <deni> *sigh
07:23:26 <byorgey> deni: that's the latest version
07:23:45 <byorgey> deni: you just have to realize that that module re-exports Data.Map.Lazy, so you have to look there for most of the map functions
07:24:16 <byorgey> the keys function is here: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#v:keys
07:25:16 <mrd> has anyone ever successfully made use of the label-decoding mode of the Happy GLR parser-generator?
07:27:59 <merijn> How the hell do I debug getting no output on stdout of a child process when using System.Process?
07:32:51 <aweinstock> c_wraith: regarding "all IO is reified as values conceptually, while still using a representation that's efficient at runtime", do you have a paper to link on how IO actions are compiled in GHC? I remember seeing stuff involving (State# RealWorld) when poking around GHC.Prim, but havn't read anything in-depth yet
07:33:10 <merijn> aweinstock: Lookup the "Lazy Functional State Threads" paper
07:33:34 <merijn> aweinstock: IO and ST are both cases of the more fundamental State# monad, which is covered in that paper
07:34:21 <merijn> gah, I can't get System.Process to produce anything on stdout :(
07:34:28 <merijn> Screw it...I'll look into this later
07:35:45 <aweinstock> :t System.Process.CreatePipe
07:35:47 <lambdabot> System.Process.Internals.StdStream
07:36:11 <deni> byorgey: thank you!
07:36:31 <merijn> aweinstock: I have this: http://lpaste.net/4199648167676870656
07:36:42 <merijn> If I replace "prun" with "echo" I see the output printed
07:36:59 <merijn> But if I use prun the result of "hGetContents hnd" is just ""
07:37:17 <merijn> However, running the same command in the shell seems to return output just fine
07:37:30 <aweinstock> try hGet or hGetSome instead? (i.e. maybe it's a lazy IO issue?)
07:37:36 <byorgey> deni: sure!
07:38:57 <merijn> aweinstock: Shouldn't be possible, I think?
07:39:08 <merijn> aweinstock: nope, hGetSome also returns empty
07:40:18 <Sindriava> ♫ We're up all night to hGetSome ♫
07:40:24 <aweinstock> strace -f HaskellProgram ?
07:40:40 <aweinstock> (-f follows fork/thread)
07:40:43 <quicksilver> merijn: prun is failing and producing something on stderr you can't see
07:40:48 <geekosaur> are you running it from the shell the same way? (...I don't see NoStream defined)
07:41:00 <merijn> geekosaur: NoStream is the newest process
07:41:02 <quicksilver> like it can't find ./evolve because it's in the wrong directory
07:41:16 <merijn> process should use current working dir, no?
07:41:28 <geekosaur> but I expect that's a redirect to /dev/null; shell would be </dev/null 2>/dev/null
07:41:54 <quicksilver> I dunno but why don't you capture stderr and check :P
07:41:57 <quicksilver> also check the exit code?
07:42:01 <geekosaur> (if it means "closed" then, uh, someone needs to think about that one; violating process expectations re standard handles is Bad)
07:42:55 <quicksilver> set stderr and stdin to Inherit
07:43:02 <quicksilver> at least for testing purposes
07:43:05 <quicksilver> so you can see what happens
07:43:09 <merijn> I did that
07:43:18 <merijn> (Well stderr)
07:44:59 <merijn> Apparently something in C++ iostreams breaks if there's no stdin, even if you don't use it... >.>
07:45:33 <geekosaur> see my comment about "closed"
07:46:34 <merijn> Oh well, it sounds like weekend to me
07:57:04 <geekosaur> rrrgh, no, NoStream is evil
07:57:29 * geekosaur considers a bug report; should open on /dev/null / NUL: instead of closing
07:58:24 <quicksilver> geekosaur: yes
07:58:44 <quicksilver> geekosaur: I couldn't find the c source to runInteractiveProcess in browsable form
07:58:49 <quicksilver> geekosaur: so I stopped digging
07:58:53 <quicksilver> haskell passes "-2"
07:59:18 <quicksilver> I'm not sure what the C shim does with -2
07:59:27 <geekosaur> yeh, had to wait or daily standup to end and then did cabal update / cabal get to verify
07:59:38 <sssilver> What's the point of Haskell in a world that already has C++?
07:59:58 <quicksilver> to give trolls something to talk about
08:00:28 <geekosaur> it's doing close()
08:00:28 <sssilver> quicksilver fine >.<
08:00:30 <frerich> :-)
08:15:58 * hackagebot fn 0.2.0.1 - A functional web framework.  https://hackage.haskell.org/package/fn-0.2.0.1 (DanielPatterson)
08:22:54 <lingxiao> hey all
08:24:33 <QJgoieqn> pl \x y -> x y
08:26:52 <quicksilver> QJgoieqn: ($)
08:27:11 <QJgoieqn> thanks @quicksilver :)
08:27:44 <quicksilver> :)
08:29:31 <geekosaur> it's @pl, for the record
08:30:12 <QJgoieqn> Are there any tools like @pl that I can use offline?
08:30:22 <QJgoieqn> without installing lambdabot?
08:30:43 <KaneTW> pl isn't that useful
08:31:49 <aweinstock> :t [id, ($), \x y -> x y]
08:31:51 <lambdabot> [(a -> b) -> a -> b]
08:32:06 <aweinstock> @pl x `id` y
08:32:07 <lambdabot> x y
08:33:19 <indiagreen> QJgoieqn: http://hackage.haskell.org/package/pointfree
08:33:38 <michaelochurch> Hi all. I have two questions, one basic and one meta.
08:33:42 <Hiro`> Been trying to use stack to set up a hakyll app. I've run hakyll-init and successfully created the initial directory. When I try to run `ghc --make  site.hs` I get an error telling me that it can't include the Hakyll module. I've checked in the cabal file and hakyll is listed as a dependency. Can anyone tell me what I'm doing wrong?
08:33:53 <QJgoieqn> @indiagreen nice! Thanks.
08:33:54 <lambdabot> Unknown command, try @list
08:34:00 <KaneTW> don't ask to ask, just ask
08:34:12 <michaelochurch> The basic question: does anyone recognize this error? https://github.com/haskell/primitive/issues/37
08:34:14 <KaneTW> Hiro`: did you install it using sandbox?
08:35:14 <Hiro`> KaneTW: No I initially tried to use cabal sandbox, but couldn't make that work so am trying stack instead.
08:35:23 <michaelochurch> It's a clang error that I get on OS X 10.11 when trying to install primitive.
08:35:33 <Hiro`> I have hakyll installed globally now I think.
08:35:46 <michaelochurch> (I'm trying to prove a point about performance so virtualization is not an option... although the meta question is... should I just dump OS X?)
08:36:14 <michaelochurch> OS X seems to be a source of major pain when working at the bleeding edge of Haskell...
08:36:40 <michaelochurch> Apple: duping a bunch of hipsters into thinking they weren't using the new Windows since 2007.
08:37:30 <michaelochurch> But yeah... does anyone have any idea what to do about that ExitFailure 254 that I get when installing primitive?
08:37:58 <michaelochurch> ... and is my intuition right that I should dump OS X for serious Haskell development?
08:38:10 <KaneTW> Hiro`: try building it via stack; hakyll should've generated a .cabal file
08:38:32 <danza> michaelochurch, i wouldn't say that OS X is a blocker for developing with Haskell. I achieved good portability on both Linux and Mac using Nix
08:39:14 <Hiro`> KaneTW: So `stack build site.hs` ?
08:40:04 <michaelochurch> danza: OK. I'm completely new to Nix. Do you mean the package manager or the OS?
08:40:18 <Hiro`> Nevermind, `stack build` seems to have done the job.
08:40:23 <michaelochurch> danza: And do you have any idea what's going on with that nightmare "ExitFailure 254" error?
08:40:36 <danza> michaelochurch the package manager, that you can use on both Linux and Mac
08:40:56 <danza> i was focusing on the meta question, since you mention C
08:41:16 <danza> Nix is a good way to install dependencies like C libraries and tools
08:41:21 <sm> michaelochurch: I would agree that haskell on mac is usually fine, and I don't think nix is required. FWIW have primitive-0.6.1.0 installed on osx 10.11
08:41:28 <sm> (I have)
08:41:46 <michaelochurch> sm: Any idea what's behind my problem then?
08:42:12 <michaelochurch> sm: I am finding the current state of things (use stack vs. don't use it, Haskell Platform vs. no) to be pretty damn confusing.
08:42:24 <sm> it's simple: use stack
08:42:29 <sm> I wonder what's your clang version
08:42:47 <michaelochurch> sm: Apple clang version 3.1
08:42:53 <michaelochurch> sm: use stack and don't use HP?
08:43:06 <maerwald> stack can quadruple your problems if you are unlucky (e.g. some libs don't exist there yet and cause conflicts with the stack bundle)
08:43:30 <sm> my clang --version says Apple LLVM version 7.0.0 (clang-700.1.76)
08:43:40 <sm> sm: yes
08:43:42 <michaelochurch> maerwald: Yeah. I like the ideas behind Stack but it seems a bit immature still.
08:44:00 <maerwald> I find the whole concept to be wrong, but that's just my opinion... 
08:44:02 <michaelochurch> sm: Ah, so my clang is way behind. Let me see if that changes things...
08:44:11 <michaelochurch> maerwald: What do you find to be wrong?
08:44:26 <maerwald> dependencies should not get MORE tight... they should get less tight
08:44:31 <maerwald> but that's an ecosystem problem
08:44:52 <maerwald> and people are trying to fix it with more confusing technology
08:45:45 <michaelochurch> maerwald: Yes. I would rather the setup/admin part of Haskell get easier over time. It seems to be going the other way. 
08:45:58 <Hiro`> KaneTW: Is there a way to get the site executable without having to specify the full path the the .stack-work folder?
08:46:07 <julianleviston> It seems easier than plain cabal to me.
08:46:18 <michaelochurch> maerwald: I would argue that it's the best high-level language by far, but when cabal or stack breaks it's a fucking nightmare.
08:46:19 <maerwald> in fact, those tools make it worse for the ecosystem, because people are now like "hey, stack already handles it for me, so I don't need to care about API breakage of my library"
08:47:23 <michaelochurch> sm: How would you recommend upgrading LLVM and Clang? (I'm afraid to do so by hand because they were setup by XCode and I'm afraid of breaking shit.)
08:48:04 <michaelochurch> sm: Is it just `brew install clang`, or is that going to have other effects?
08:49:19 <sm> michaelochurch, maerwald: it seems to me neither of you has used stack
08:49:26 <maerwald> I have
08:49:37 <sm> ok, have you used cabal ?
08:49:39 <maerwald> it made it impossible to build my project in fat ;)
08:49:53 <maerwald> *fact
08:49:54 <geekosaur> you should lnow better than to question or doubt the holy stack and the ultimately evil cabal\
08:50:27 <sm> heh
08:50:30 <maerwald> I am using cabal sandboxes on a daily basis. They still s*ck, but...
08:50:30 <geekosaur> it is no longer permitted to consider stack anything but god and cabal anything but satan
08:50:38 <michaelochurch> sm: I have, but I don't know it well.
08:50:41 <julianleviston> maerwald: maybe you should fix them?
08:50:49 <sm> :) pardon me maerwald, I didn't mean that in a snarky way, I am just surprised that you see things as getting worse
08:51:05 <sm> if you've had experience using both
08:51:09 <michaelochurch> sm: ... and I'll admit that. As often as cabal pissed me off, I had a workflow that basically worked (using sandboxes).
08:51:18 <glguy> problems with stack? try stack
08:51:19 <michaelochurch> sm: I think it's probably coming out of a local maximum.
08:51:22 <maerwald> julianleviston: again, it's not a technology problem
08:51:49 <sm> michaelochurch: re upgrading clang, sorry but no idea. I would have thought it's an apple thing
08:51:59 <michaelochurch> sm: I am so over OS X... :(
08:52:02 <julianleviston> maerwald: you can’t fix non-technology problems?
08:52:07 <sm> and I'm surprised you have an old one if you're on osx 10.11
08:52:20 <sm> seems like a problem with your install
08:52:22 <julianleviston> michaelochurch: why do you use it if you hate it??
08:52:24 <maerwald> julianleviston: no, you cannot fix ecosystem problems by yourself, unless you take over all the projects that exist
08:52:24 <michaelochurch> sm: Yeah. Upgrading to OS X 10.11 was one of the worst things I've ever done.
08:52:35 * sm seeks breakfast
08:52:46 <julianleviston> maerwald: ok, I’m sorry.
08:53:13 <michaelochurch> julianleviston: It's a decent all-purpose machine and it's far better than Windows. Getting a reliable Linux laptop, the last time I looked, was non-trivial. 
08:53:37 <julianleviston> michaelochurch: ok, I’m sorry.
08:54:44 <thoughtpolice> michaelochurch: It looks like a bug in their copy of Clang's lexer, FWIW. If you can try 'brew install clang' or whatnot, that should put a clang on your $PATH, which GHC will then use. If this bug persists upstream, it needs to be submitted to them as a bug to be fixed.
08:55:16 <thoughtpolice> (They're normally very quick about fixing obvious crashes in the parser, or at least tracking them down). If this isn't a bug with upstream, it's something that needs to go to Apple's bugtracker (Radar)
08:55:23 <michaelochurch> julianlevison: unfortunately I'm at the point in my life where I'm 50% manager and spend too much time in meetings and don't get unbroken time to, e.g., figure out that New Tool That Fixes Everything
08:55:37 <michaelochurch> thoughtpolice: OK. Thanks!
08:55:42 <michaelochurch> thoughtpolice: I will try that.
08:56:41 <KaneTW> Hiro`: try stack exec
08:57:35 <michaelochurch> thoughtpolice: I am having *two* problems with homebrew now.
08:57:59 <michaelochurch> 1: brew update gives me this shit about Library/blahblah ... and I don't know where that Library is because it doesn't match /Library
08:58:15 <michaelochurch> 2: brew install clang... it says there is no formula for clang
08:59:01 <thoughtpolice> Oh, you probably need something like
08:59:07 <thoughtpolice> 'brew install llvm --enable-clang'
08:59:08 <thoughtpolice> Based on https://github.com/Homebrew/homebrew/blob/master/Library/Formula/llvm.rb
08:59:50 <michaelochurch> thoughtpolice: Great. Any idea where Homebrew is actually installed on my machine?
08:59:55 <michaelochurch> or how I find that out?
09:00:25 <thoughtpolice> Probably /usr/local, but when it says Library/ it normally means it caches the source under your ~, IIRC
09:00:31 <thoughtpolice> Like, under ~/Library maybe?
09:00:37 <thoughtpolice> (I am actually not using OS X at the moment)
09:00:45 <sm> this is off topic, but.. my clang is in /usr/bin. It came from apple, not homebrew
09:01:03 <thoughtpolice> Like whenever homebrew builds, it puts the source etc and does a build with whatever temporary files under ~/Library, then installs them under /usr/locla
09:01:22 <thoughtpolice> */usr/local
09:02:16 <Hiro`> KaneTW: thanks!
09:02:46 <michaelochurch> thoughtpolice: Thanks! Yeah, it turns out that /usr/local/Library is exactly what I needed to change to fix it.
09:02:57 <thoughtpolice> Ah, cool.
09:03:06 <michaelochurch> ... so now I'll try installing llvm and clang because the Apple-installed versions seem to be ancient.
09:03:43 <julianleviston> I don’t think /usr/local is writeable anymore is it?
09:04:08 <julianleviston> maybe I’m confused with one of the bin folders.
09:05:48 <thoughtpolice> I'd guess /usr/local is still writeable. /usr and other sibling folders are not, probably.
09:06:16 <thoughtpolice> (In particular it's the place you're 'supposed' to manually install your own out-of-band software to, so I'd hope it still works)
09:08:20 <michaelochurch> thoughtpolice: OK. So brew install llvm --enable-clang doesn't update clang version. Isn't there some brew command you use to install things that you don't naturally have?
09:09:01 <thoughtpolice> Hrm, what do you mean doesn't update the version? It does nothing, or you already had the latest version installed?
09:10:00 <michaelochurch> It doesn't update clang version. I might have to use "--with-clang" based on my searching.
09:10:10 <thoughtpolice> Ah, yeah, sorry.
09:10:19 <geekosaur> hash -r
09:10:19 <thoughtpolice> I can't really remember the flags very well TBH. It might be --with-clang
09:13:06 <michaelochurch> thoughtpolice: a new, different error.
09:13:07 <michaelochurch> "=> cmake -G Unix Makefiles /private/tmp/llvm20151204-71816-fts4nh/llvm-3.6.2.src -DCMAKE_C_FLAGS_RELEASE= -DCMAKE_CXX_FLAGS_RELEASE= -DCMAKE_INSTALL_PREFI
09:13:07 <michaelochurch> Last 15 lines from /Users/michaelchurch/Library/Logs/Homebrew/llvm/01.cmake:
09:13:10 <michaelochurch>   make: *** [cmTC_67819/fast] Error 2
09:13:37 <michaelochurch> thoughtpolice: my next machine will not be a Mac. This is fucking infuriating.
09:14:37 <sm> michaelochurch: please take it easy, this is #haskell
09:16:47 <michaelochurch> sm: Oh, I have nothing but good things to say about Haskell the language. :)
09:17:04 <maerwald> michaelochurch: we try to keep a "clean" language here, though
09:17:23 <michaelochurch> thoughtpolice: It looks like the culprit is an out-of-date XCode.
09:17:43 <michaelochurch> maerwald: goto longjmp VisitorFactory
09:18:37 <maerwald> I've only worked on a mac once for developing an iOS application... XCode was really the worst. I don't understand how people can use it for actual development. Installing clang on a linux system is a piece of cake.
09:18:56 <sm> michaelochurch: that sounds more like the right fix.
09:20:49 <ga2arch> maerwald: Well, i used xcode for c++, looked fine to me, not the best but not the worst either.
09:20:50 <michaelochurch> maerwald: Yeah. It's awful. I don't use the GUI.
09:21:13 <maerwald> the lexer regularly crashed while the rest of the app still "worked" somehow
09:24:06 <michaelochurch> maerwald: do you use Linux for your own machine?
09:24:10 <ironChicken> if i have some type for which i'd like to implement arithmetic, and i already know how to represent values of my type as Int, what's the easiest way to get a Num instance?
09:24:17 <maerwald> michaelochurch: yes
09:24:39 <michaelochurch> maerwald: The last time I got a Linux laptop was 2009. I got seduced by Apple back when I was not as technical and thought Apple was an acceptable Unix.
09:25:09 <michaelochurch> maerwald: Who do you buy from? Do you hand-install Linux or does it ship as a working Linux machine?
09:25:24 <maerwald> I think we are drifting OT though
09:26:55 <lyxia> ironChicken: Do you mean that the Num operations you are thinking of coincide with those of Int?
09:27:03 <ironChicken> lyxia: yes
09:28:52 <ironChicken> i can easily write a function :: Foo -> Int
09:29:16 <ironChicken> and i'd like to be able to do (+) Foo Foo, etc. whenever i need it
09:29:25 <lyxia> ironChicken: I'd suggest either (a type synonym for) Int or using GeneralisedNewtypeDeriving if Foo is a newtype
09:29:54 <ironChicken> lyxia: Foo is a data, rather than newtype
09:30:04 <lyxia> ah :(
09:31:05 <ironChicken> i mean, i guess the long way round is just a full implementation of instance Num Foo
09:31:27 <ironChicken> just wondering if there were any short-cuts, given that I can do Foo -> Int
09:32:35 <lyxia> also Int -> Foo
09:33:59 <lyxia> What is your datatype actually?
09:35:09 <ironChicken> data Foo = Foo { a :: Int, b :: Int, c :: Int }
09:35:29 <ironChicken> then i can effectively summarise the three Ints into one Int
09:38:35 <Rryy> Hello.  In template haskell, is there an easy way to get the Kind of a Type?  i.e.:  arity :: Type -> Int
09:39:51 <Rryy> e.g.: arity [t| Int |] == 0,  arity [t| Maybe |] == 1
09:40:38 <Rryy> I searched the docs and fiddled around with TH but could not figure it out.
09:49:24 <Cale> Rryy: You can use reify
09:50:10 <Cale> ah, right
09:52:18 <Rryy> ummm, I'm trying that now: pattern matching on TyConI then "parsing" the declaration
09:58:21 <Rryy> Cale: kinda got it,  I just need some constructor counting!
09:58:25 <Rryy> Cale: thanks!
10:01:00 * hackagebot setgame 1.1 - A console interface to the game of Set  https://hackage.haskell.org/package/setgame-1.1 (EricMertens)
10:21:31 * hackagebot stack 0.1.10.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.10.0 (borsboom)
10:38:40 <pikajude> DarwinElf: the removal of tls-extra is a problem
10:38:55 <pikajude> DarwinElf: but the biggest problem is that deviantART switched to oauth for authentication, so the auth page scraping no longer works
10:39:26 <pikajude> and i currently don't have time to port kevin to use oauth
10:51:59 <liaod> is there a compose function like (.) but partially applies all of its functions
10:54:21 <pikajude> liaod: you mean something like (f ? g) a = f a . g a?
10:54:45 <pikajude> apologies for the two separate usages of the question mark
10:55:17 <lifter> what does the question mark mean?
10:55:28 <liaod> possibly! is there a haskage page for it?
10:55:28 <pikajude> lifter: that's a placeholder for the operator liaod wants
10:55:36 <lifter> oh
10:55:40 <pikajude> liaod: it's not in the standard library, just define it yourself
10:55:57 <glguy> liaod: No, it was a proposed operator because your question was unclear
10:56:07 <glguy> it might be worth providing an example of what you're trying to do
10:57:06 <liaod> well right now i'm trying to achieve basically this
10:57:07 <liaod> (a -> b -> b) -> (a -> b -> b) -> a -> b -> b
10:57:24 <liaod> so i defined my operator (?) as "(?) f g cn p = g cn (f cn p)"
11:01:04 <monochrom> @type \f g cn p -> g cn (f cn p)
11:01:05 <lambdabot> (r2 -> r3 -> r1) -> (r2 -> r1 -> r) -> r2 -> r3 -> r
11:01:18 <liaod> pikajude, thanks!
11:01:25 <monochrom> should work
11:01:47 <pikajude> @pl dot f g cn = f cn . g cn
11:01:47 <lambdabot> dot = liftM2 (.)
11:01:51 <pikajude> you can also use that
11:02:58 <OverCoder> Why http://p.samuraimanpurse.com/Z3WTTUvR.txt isn't a valid function?
11:03:13 <OverCoder> I am really unable to understand what exactly the interpreter is saying at me :|
11:03:40 <monochrom> what does the interpreter say? complete verbatim unabridged
11:03:43 <glguy> What's the interpreter saying?
11:04:08 <pikajude> yes, what is the interpreter saying?
11:04:12 <OverCoder> Could not deduce (Eq n) arising from the literal '0' from the context (Num n)...
11:04:17 <OverCoder> I can paste the whole thing if you like to
11:04:42 <pikajude> OverCoder: that just means that the Num n constraint requires that n also has an Eq instance
11:04:56 <monochrom> take' :: (Eq n, Num n) => n -> [x] -> [x]
11:04:56 <pikajude> the simplest solution would be to change your type signature to take' :: (Eq n, Num n) => n -> [x] -> [x]
11:05:00 <geekosaur> well, not exactly
11:05:07 <monochrom> because pattern matching against 0 requires Eq
11:05:09 <pikajude> uh-oh
11:05:14 <OverCoder> Alright I got it but why even?
11:05:17 <pikajude> ooh, my mistake
11:05:19 <OverCoder> Ah!
11:05:21 <geekosaur> pattern match on a number requires an Eq constraint
11:05:22 <geekosaur> yes
11:05:24 <OverCoder> Got it got it, thanks guys
11:05:30 <pikajude> please ignore what i say!
11:05:31 <geekosaur> it's a bit of a hack, really
11:06:09 <geekosaur> because you "can't" really pattern match on a number. but the language lets you and rewrites it as a check using (==), which means you need to declare an Eq constraint
11:06:32 <OverCoder> Mhm, got it
11:06:56 <geekosaur> (unles syou declare a type known to have one; Int would have worked, (Num n) => n isn't sufficient)
11:07:18 <monochrom> in the long distant past, Num implied Eq. not today anymore.
11:08:34 <monochrom> but pattern-matching against 0 has always been desugared to ==
11:10:31 <nitrix> Is there a nicer way to write: 
11:10:33 <nitrix> crawlUrl url = extractIps <$> (getResponseBody =<< (simpleHTTP $ getRequest url))
11:11:03 <nitrix> Is this one of those cases where liftA is nicer?
11:14:09 <glguy> 07do resp 07<- simpleHTTP (getRequest url); body 07<- getResponseBody resp; return (extractIps body)
11:21:07 <mightybyte> Hello all, Compose Conference 2016 registration is now open.  https://www.eventbrite.com/e/cmpse-conference-2016-tickets-19647973618
11:21:48 <mightybyte> I've also posted the link to Hacker News and appropriate language-specific subreddits.
11:22:51 <mightybyte> We sold out very quickly last year, so get your ticket before they're gone.
11:24:11 <lingxiao> he all 
11:24:27 <lingxiao> i have a question about haskell's System.random
11:24:31 <Cale> mightybyte: you might want to render the "C◦mp◦se :: Conference" SVG you're using as a header on http://www.composeconference.org/ as a PNG to ensure it renders correctly -- it looks a bit cut off to me.
11:25:39 <mightybyte> Cale: Thanks for the feedback.  Can you email me a screen shot?
11:27:05 <lingxiao> http://lpaste.net/146489
11:27:14 <Cale> mightybyte: http://cale.yi.org/logo.png
11:27:20 <lingxiao> test == True in the code above right
11:27:46 <Cale> lingxiao: yes
11:27:58 <mightybyte> Cale: Great, thank you.
11:28:20 <geekosaur> lingxiao, you're starting from the same seed in both cases, so that is expected
11:28:26 <geekosaur> that is why you get a new seed back when you use it
11:29:08 <mightybyte> Cale: What browser / screen size are you using?
11:29:35 <lingxiao> Cale geekosaur thanks, so in other words for each seed there is a unique stream of seeds under randomR?
11:29:39 <Cale> Google Chrome on Linux Mint, 1920x1080
11:29:52 <Cale> lingxiao: yeah
11:29:57 <Cale> lingxiao: randomR is a function
11:29:58 <geekosaur> lingxiao, it's a PRNG, if you use the same seed then you get the same sequence
11:30:11 <Cale> It must produce the same result when given the same argument
11:30:14 <geekosaur> sometimes you want this, e.g. for testing a game under controlled conditions or rerunning a Monte Carlo simulation
11:30:15 <Cale> every time
11:30:36 <Cale> Just like any other ordinary function :)
11:30:43 <lingxiao> so if I'm writing a randomized algorithm I would want this as well right?
11:30:47 <mightybyte> Cale: Interesting.  That looks very different from what I'm seeing in Chrome on Mac.
11:31:05 <lingxiao> btw how do I test these things? do they have to be in IO?
11:31:33 <geekosaur> lingxiao, you would either save the new state (you'll note that the result is well arranged for use with a State monad) or you can use monad-random to handle it for you
11:31:38 <geekosaur> (package)
11:31:59 <Cale> mightybyte: I think the reason is that the SVG isn't made up of curves, it's a text element, and so it becomes subject to the whims of font rendering on each system.
11:32:02 <geekosaur> you only need to be in IO to get the initial seed
11:32:17 <mightybyte> Ahh, that makes sense.
11:32:23 <geekosaur> after that, you just need to track the new seeds returned and use them in later calls
11:32:24 <lingxiao> geekosaur: ahh true
11:32:45 <lingxiao> but geekosaur can you expand on what you mean here: you would either save the new state  ... or use monad-random
11:33:12 <lingxiao> so in the lpaste i have I threaded the new state through repeated calls of randomR
11:33:18 <lingxiao> is this what you mean?
11:33:47 <breadmonster> geekosaur: Is it safe to use unsafePerformIO to seed a random number generator?
11:34:51 <geekosaur> breadmonster, I would not say so, but it could be argued; it depends on whether you are being strict about all externally-sourced state being in IO even if it can't change during your program run.
11:35:37 <geekosaur> even ghc is not always careful about that (see https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/base-4.8.1.0/System-Info.html)
11:35:41 <breadmonster> geekosaur: Can you give me an example of this breaking?
11:35:46 <breadmonster> I can't think of how it would be affected.
11:35:59 <zoku> barrucadu: do you have any sample code using irc-conduit?
11:36:02 <geekosaur> well, that's kinda the point I was trying to make
11:36:26 <OverCoder> guys, um 1:[2,3] appends 1 to [2,3], but how can I append something like [1,2]:3 ?
11:36:31 <OverCoder> It throws an error this way
11:36:32 <geekosaur> I can't think of a way either, but pedantically it "should" be in IO because it changes between program runs
11:36:49 <breadmonster> OverCoder: [1,2] ++ return 3
11:36:58 <breadmonster> > [1,2] ++ return 3
11:37:00 <lambdabot>  [1,2,3]
11:37:25 <OverCoder> Ah, thanks
11:37:52 <geekosaur> or if you're being less tricky and more obvious, [1,2] ++ [3]
11:38:07 <breadmonster> geekosaur: sure, but that's the point of random number generation yeah?
11:38:15 <OverCoder> geekosaur, Well, when he used ++, I remembered that, so I just used it
11:38:35 <geekosaur> breadmonster: not always. I gave two cases where you want to reuse a seed
11:38:57 <breadmonster> sorry, I lost that in the middle of the connection noise..
11:38:57 <breadmonster> What are they?
11:39:24 <geekosaur> [04 19:29] <geekosaur> sometimes you want this, e.g. for testing a game under controlled conditions or rerunning a Monte Carlo simulation
11:39:47 <geekosaur> lingxiao, you are theading it in each set but reusing the initial seed in the second set
11:40:14 <geekosaur> in a normal program you'd thread it through all of them
11:41:01 <geekosaur> and sorry I got pulled into the other discussion, I was looking for this for you: http://hackage.haskell.org/package/MonadRandom/docs/Control-Monad-Random.html
11:41:06 <breadmonster> geekosaur: Oh right, that was before I asked the question.
11:41:06 <breadmonster> I wasn't on #haskell.
11:41:17 <breadmonster> Right, sure.
11:41:48 <geekosaur> breadmonster, anyway I think it's more a philosophical than a practical issue. I *think*. I haven't tried to work through all the possible ramifications
11:42:40 <geekosaur> (I suppose in theory if the compiler thought it was constant when it wasn't, it might try to wire the result of the PRNG in at compile time... not that I would expect ghc to do so. gcc might!)
11:45:08 <Cale> You generally have to be quite careful to tell GHC not to inline definitions containing unsafePerformIO too
11:45:22 <liaod> @type liftM2 (.)
11:45:24 <lambdabot> Monad m => m (b -> c) -> m (a -> b) -> m (a -> c)
11:46:24 <liaod> @pl (?) f g t = g t . f t
11:46:24 <lambdabot> (line 1, column 12):
11:46:25 <lambdabot> unexpected " "
11:46:25 <lambdabot> expecting operator
11:46:36 <slipspin> Hi! Is there an easy library for haskell CGI sessions? cgi-utils seems dead
11:47:11 <lingxiao> geekosaur ahh yes thanks
11:48:34 <ProofTechnique> @hackage clientsession
11:48:35 <lambdabot> http://hackage.haskell.org/package/clientsession
11:48:39 <ProofTechnique> slipspin: Something like that?
11:48:46 <Cale> slipspin: That library isn't really enough code to be considered alive or dead, I think :D
11:49:07 <geekosaur> schrödinger's cgi?
11:49:32 <Cale> ProofTechnique: That's something crypto related, while cgi-utils isn't...
11:49:42 <ProofTechnique> Ah, okay.
11:50:37 <lingxiao> does haskell have a datatype that's on the closed interval between (0,1)?
11:50:53 <ReinH> slipspin: any particular reason for wanting CGI sessions?
11:51:08 <Cale> slipspin: I don't think most people developing web applications with Haskell really use CGI much, or if they do at all, it's via one of the modules which converts a Happstack/Snap/Yesod application into something which talks via CGI
11:51:30 <ProofTechnique> @hackage data-interval
11:51:31 <lambdabot> http://hackage.haskell.org/package/data-interval
11:51:36 <ReinH> CGI is mostly dead technology, so I imagine libraries for it are also mostly dead.
11:51:38 <ProofTechnique> lingxiao: Maybe?
11:52:08 <lingxiao> ProofTechnique huh?
11:52:12 <Welkin> does anyone actually use happstack?
11:52:16 <Welkin> I have never met anyone
11:52:18 <Cale> I hope so!
11:52:20 <Welkin> I only know a few who use snap
11:52:23 <Welkin> mostly yesod though
11:52:30 <geekosaur> lingxiao, not really, haskell doesn't in general handle subset types like that.
11:52:33 <Cale> We use Snap at Obsidian
11:52:37 <ProofTechnique> I like Happstack, though I'm fervently waiting for Happstack 8
11:52:57 <slipspin> Uh because I have some code written in cgi?
11:52:57 <geekosaur> sometimes you can fake it with type level trickery or "smart constructors"
11:53:08 <lingxiao> geeksosaur so I'm writing a quickcheck property for a function that does something if its input is on (0,1) and trivial otherwise
11:53:18 <ProofTechnique> Yeah, smart constructors are how it's done in data-interval
11:53:34 <lingxiao> the problem is that a lot of values generated will be not on (0,1), so what's a good work around?
11:53:39 <Cale> slipspin: Is cgi-utils actually broken?
11:53:53 <lingxiao> ProofTechnique sorry are you talking to me?
11:53:58 <ReinH> lingxiao: use a newtype wrapper to constrain the values your arbitrary instance takes on, like https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Modifiers.html
11:54:16 <slipspin> Cale: it refuses to build
11:54:27 <Cale> lingxiao: Apply a function which forces the random value generated into that range?
11:54:29 <ProofTechnique> lingxiao: Yes. The library linked above can construct representations of closed and open intervals over the reals
11:54:31 <ReinH> perhaps Small would be small enough. If not, you can make ExtraSmall
11:54:40 <lingxiao> ProofTechnique great tahnks!
11:54:52 <slipspin> It wants flexible instances
11:55:37 <slipspin> I mean I could rebuild everything in Yesod
11:55:43 <lingxiao> Cale you mean like for each n > 1, do something like (n-1)/n ?? and similarly for n < 0 
11:55:52 <slipspin> But I have a lot of it already built in just raw CGI, except the login
11:55:53 <ProofTechnique> It hasn't been updated in a year, but I don't think math changes that much in a year :)
11:56:24 <lingxiao> problem there is that most of the values would be clustered around 1
11:57:22 <geekosaur> I thouight WSGI was how that stuff was supposed to be done these days
11:57:26 <mightybyte> Welkin: We use Snap at Soostone.
11:57:40 <geekosaur> CGI puts a lot of load on a web serer
11:57:53 <Welkin> use WAI 
11:57:56 <Cale> lingxiao: I meant applying something like arctan and some scaling, but yeah, the distribution might not be ideal
11:58:10 <Cale> lingxiao: You can specify a generator with QuickCheck
11:58:22 <Cale> let me remind myself how to do that :)
11:58:28 <slipspin> The side isn't... large
11:58:30 <lingxiao> Cale ah thanks please do!
11:58:36 <slipspin> It's a little dice roller thing that does some logging
11:58:43 <ReinH> The obvious thing would be to generate an arbitrary Bool and use that to generate either an arbitrary number or an arbitrary number within the range.
11:58:43 <slipspin> The CGI work is pretty minimal
11:58:48 <ReinH> That's what you can use the newtype wrapper to enforce
11:58:50 <slipspin> abut it's important that the dice rolling is done server-side
11:59:00 <Cale> forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
11:59:30 <Cale> So you could write
11:59:39 <Welkin> @roll 2d8
11:59:39 <ReinH> slipspin: no one is talking about doing the dice rolling anywhere but server-side
11:59:40 <lambdabot> Welkin: 1+4 => 5
11:59:53 <slipspin> Hey look I'm all about hearing how to do this better :D
11:59:54 <Cale> quickCheck (forAll (choose (0,1)) (\x -> ...))
12:00:04 <slipspin> Should I investigate WSGI?
12:00:11 <ReinH> slipspin: you should investigate WAI
12:00:25 <geekosaur> ^ WSGI is a general thing, WAI is the Haskell implementation
12:00:59 <geekosaur> (I think it originated in the Python community but quickly spread everywhere because it was so much more sensible than CGI)
12:01:29 <mightybyte> geekosaur: Is wai actually an implementation of WSGI?
12:02:12 <geekosaur> not certain actually. I have not done web in a while
12:02:29 <geekosaur> should just back out of this probably. feh
12:03:22 <ReinH> The WSGI specification is implementaiton-specific to python. WAI is a similar implementation of a similar specification for HAskell.
12:04:32 <ReinH> Or maybe the WAI implementation is the specification. w/e
12:05:03 <slipspin> Ah so this won't stick to like nginx?
12:05:11 <geekosaur> it's not supposed to
12:05:35 <slipspin> Yes obviously
12:05:40 * geekosaur can never remember the general one's proper name... been too long since webby stuf
12:05:43 <slipspin> but this creates an interesting situation for my server
12:07:14 <Welkin> what is nginx for?
12:07:18 <Welkin> just use warp + wai
12:07:23 <slipspin> hosting other websites on my server
12:07:31 <slipspin> that aren't exclusively warp
12:07:38 <Welkin> then reverse proxy to the warp + wai application
12:07:52 <slipspin> yes that is what I will have to do
12:08:42 <zoku> omg all the types >_<
12:08:44 <slipspin> I think it may be easier to just mess with sessions for this
12:08:50 <zoku> these conduits are breaking my brain
12:08:58 <Welkin> zoku: I prefer pipes
12:09:01 <Welkin> it is simpler
12:09:07 <slipspin> I need very little session support compared to messing with server service spin-up and rewriting the application in wai or yesod
12:09:08 <Welkin> it is similar
12:09:11 <zoku> Welkin: these irc libraries are already written for conduits
12:09:30 <Welkin> zoku: then write your own
12:09:48 <ga2arch> zoku: on what are you having trouble ?
12:09:58 <Welkin> sometimes it is better to write your own
12:10:01 <zoku> I'm trying to build an irc bot using irc-conduit
12:11:19 <zoku> hmm yeah, i was writing it with raw strings just using the irc library
12:11:26 <zoku> maybe I'll just try that approach again
12:12:29 <Welkin> I often find that many (specific) libraries are overly complicated and unnecessary because they have been written for a generalized (but specific) purpose that may not fit your needs
12:12:52 <Welkin> it's also a good learning exercise to write your own
12:13:05 <Welkin> this is true with 99% of javascript libraries
12:13:10 <Welkin> less so with haskell
12:15:27 <ga2arch> Welkin: the irc-conduit library does look pretty simple, and generalize the usual pattern to handle irc messages with events & co, it is based on bytestrings. so maybe it is worth the time to figure it out. 
12:17:49 <lingxiao> hey all
12:17:55 <zoku> yea ga2arch, i feel like if I knew how to use this, it would give me a lot of functionality for free
12:18:04 <lingxiao> so I'm playing with quickckeck modifieres and i want to write this:
12:18:14 <lingxiao> prop1 :: NonNegative Int -> Bool
12:18:14 <lingxiao> prop1 n = n >= 0
12:18:26 <lingxiao> but Im getting:   No instance for (Num (NonNegative Int)) 
12:18:30 <zoku> I'm reading https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview
12:18:37 <zoku> but i have a thick skull
12:18:54 <lingxiao> ditto if i change the signature to prop1 ::  (Num (NonNegative Int)) => NonNegative Int -> Bool
12:19:09 <lingxiao> now is Num NonNegative Int something I have to dfine myseelf
12:19:36 <Cale> lingxiao: You should match the constructor
12:20:01 <lingxiao> Cale sorry what do you mean?
12:20:07 <Welkin> zoku: yeah, it took me a while to learn how to use conduit, but then I ultimately switched to pipes and found it much easier to reason about and use
12:20:08 <Cale> prop1 (NonNegative n) = ...
12:20:19 <lingxiao> like say getNonNegative n >= 0?
12:20:24 <Cale> You could do that too
12:20:25 <Welkin> zoku: the pipes tutorial is amazingly well written too
12:20:40 <Cale> But usually I just pattern match
12:20:56 <lingxiao> Cale oh meant pattern match 
12:21:34 * hackagebot kansas-comet 0.4 - A JavaScript push mechanism based on the comet idiom  https://hackage.haskell.org/package/kansas-comet-0.4 (AndyGill)
12:21:35 <slipspin> So just so I'm clear, the recommended answer to "How do I sessions with CGI" is "Install warp, rebuild the site in yesod, change server configs" ?
12:21:36 <slipspin> :(
12:23:02 <lingxiao> ProofTechnique could you explain how " The library linked above can construct representations of closed and open intervals over the reals"
12:23:23 <lingxiao> I see NonNegative which is a great start
12:23:35 <ga2arch> slipspin: if you want something easier than yesod, checkout Spock/Scotty 
12:24:17 <EvanR> slipspin: you can do sessions however you want with cgi
12:24:19 <lingxiao> or Cale if you'd like to trya s well :)
12:24:40 <Cale> lingxiao: what are you trying to do?
12:24:45 <ProofTechnique> lingxiao: From the documentation, it looks like something like "interval (Finite 0, False) (Finite 1, False)" should leave you with the open interval (0,1)
12:24:49 <lingxiao> geneerate from closed interval (0,1)
12:24:58 <Cale> lingxiao: Did you try the code I gave you for that, using forAll?
12:25:05 <Cale> quickCheck (forAll (choose (0,1)) (\x -> ...))
12:25:15 <lingxiao> sorry I dont think I saw that ..
12:25:16 <EvanR> slipspin: a nice way is to encode the (small) session into a JWT and store that in the clients cookies
12:25:17 <monochrom> if I understand "session" correctly, CGI doesn't do anything special to ease sessions. you make your own cookies or session-helping urls
12:25:18 <lingxiao> ah ok i see this
12:25:30 <ProofTechnique> If it's just for testing with QuickCheck, Cale's solution is almost certainly better
12:26:06 <Welkin> slipspin: no, you don't need yesod
12:26:09 <lingxiao> ProofTechnique interval from Data-Interval right?
12:26:12 <Welkin> slipspin: you can use warp + wai by itself
12:26:23 <ProofTechnique> lingxiao: Right
12:26:26 <Welkin> but that is pretty low-level
12:26:50 <slipspin> Yeah I don't want to rebuild it all to run on warp though
12:26:55 <slipspin> just because I need like 2 session variables
12:26:59 <slipspin> That's a pretty big hammer to solve the problem
12:27:03 <lingxiao> ahh thanks Cale and ProofTechnique!
12:27:07 <EvanR> slipspin: you can just use 2 cookies
12:27:30 <EvanR> or a JWT if it needs to be tamper proof
12:28:01 <lingxiao> any reason StdGen is not defined for arbitrary?
12:28:09 <lingxiao> like is there some pitfalls?
12:28:14 <lingxiao> are there*
12:28:19 <monochrom> back when CGI was the only thing around, there were a lot of papers on how to use continuations over CGI to get sessions
12:29:16 <EvanR> monochrom: now a days, secret urls tend to be indexed by google
12:29:21 <EvanR> for GETs
12:29:31 <monochrom> one of them went as far as to, using Scheme, serialize the whole continuation into a URL
12:30:27 <monochrom> the whole bloody continuation. not just a random ID that refers to a continuation in your own database.
12:30:45 <EvanR> length of a url gets wonky around 2000 i think
12:31:10 <EvanR> some browsers on some OSs decide to ignore it past a point
12:31:24 * geekosaur remembers an old web app that did that and caused early firefox to drop core
12:45:04 <carmethene> I have a newbie question...
12:45:20 <carmethene> uh hold on, irssi being stupid
12:45:56 <Rembane> carmethene: Shoot!
12:45:58 <carmethene> I'm doing this advent of code thing to learn Haskell, I have this solution
12:45:59 <carmethene> https://github.com/carmethene/adventofcode/blob/master/4/main.hs
12:46:03 <carmethene> it's really slow
12:46:21 <carmethene> https://gist.github.com/368b377bc632a4b9a04e
12:46:27 <carmethene> am I doing something stupid?
12:46:31 <carmethene> why 14billion allocs?
12:46:41 <carmethene> I guess that's my question
12:47:21 <carmethene> oh that's bytes, duh
12:47:43 <carmethene> ok better question: am I reading this right that all of the slowness is in the MD5 code?
12:47:52 <carmethene> and if so, there's not much I can do about the performance?
12:48:17 <carmethene> I saw there are some other MD5 libs that use ByteStrings, maybe those are faster?
12:48:28 <Welkin> well
12:48:34 <Welkin> String is [Char]
12:48:38 <Welkin> so you are operating on lists
12:48:53 <Welkin> text and ByteString are certainly faster
12:48:54 <monochrom> do an experiment to find out
12:48:56 <Welkin> Text*
12:49:34 <carmethene> oh, so the alloc overhead is coming from dealing with the individual chars in the input and hashes?
12:49:48 <carmethene> monochrom: that would be my next port of call, I'm on a lunch break though so it'll have to wait
12:49:59 <carmethene> 10mins left until I have to go do real work :P
12:50:41 <carmethene> alright then, I'll give it a try with ByteString, thanks guys
13:03:32 <Tehnix`> carmethene: You might be interested in this short series on optimizing - https://hbtvl.wordpress.com/2015/11/19/efficient-parsing-of-large-text-files-part-1/ - he first presents the problem, then goes through some common ways to optimize, until finally arriving at a super optimized solution.
13:04:35 <pie_> you guys ever hear about any malware written in haskell?
13:05:07 <shersh> Hello everyone! I have question abou Lens. `view` can be seen as function `view :: Lens' s a -> s -> a`. So I can extract field value from data type. But how can I create online sucn lens which will construct type by one field with all others by known values?
13:06:36 * hackagebot vinyl-vectors 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/vinyl-vectors-0.1.0.0 (andrewthad)
13:06:48 <carmethene> Tehnix`: thank you, I will bookmark it
13:06:56 <carmethene> I'm not really at that point yet, it was just a curiosity
13:07:23 <sssilver> from #javascript: [15:06:22] Sorella:	sssilver: you can't actually write programs that do things in Haskell. Haskell is a useless language, and it's pointless to try and use it for anything.
13:07:28 <sssilver> just saying ^.^
13:07:58 <Rembane> Lovely.
13:08:00 * Sorella still thinks her pointfree joke could've been better
13:08:08 <sssilver> damit Sorella 
13:08:19 <Rembane> Sorella: What joke?
13:08:36 <Sorella> Rembane: about pointless uses of things.
13:08:37 <pie_> sssilver: oh jeez lol
13:08:42 <Rembane> Sorella: ^^
13:08:54 <shersh> I'm looking for neat and concise way to create lens from value. So if I has `data Point = P { _x :: Int, _y :: Int }`, and I want to do smth like this: `(P 10 5) ^. x . zeroY` which will create P 10 0. Of course this example is simple.
13:08:57 <monochrom> if you deleted "you can't actually write programs that do things in Haskell. Haskell is a useless language, and", it would be a joke on pointfree
13:09:44 <Sorella> monochrom: the first was more of a statement about Safe Haskell. The second was a quote from SPJ
13:10:20 <monochrom> and both are not jokes on pointfree. you prove my point.
13:11:03 <lingxiao> hey all
13:11:14 <lingxiao> My quickChecker is really slow for some reason
13:11:19 <lingxiao> http://lpaste.net/146491
13:11:22 <Welkin> it is a slowchecker
13:11:32 <lingxiao> and I'm wondering if someone could tell me why, read main
13:11:38 <Welkin> just change the name and you'll be fine
13:11:39 <lingxiao> Welkin dum dum cheee
13:11:41 <lingxiao> LOL
13:12:06 <lingxiao> also if any know how to define an arbitrary instance of StdGen that'd be great :D
13:13:44 <lingxiao> it seems like haskell is gnereating some really large numbers for prop_sameSeed
13:21:27 <lingxiao> also could someone tell me why this is incorrect?
13:21:39 <lingxiao> instance Arbitrary StdGen where
13:21:39 <lingxiao>   arbitrary = coin <$> (choose (0,1) :: Gen Prob)
13:24:21 <lingxiao> hello?
13:24:27 <albeit> When heap profiling by type (-hy), what does "*" mean? It uses approximately the same as "[]" in my program
13:26:36 * hackagebot vinyl-vectors 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/vinyl-vectors-0.1.0.1 (andrewthad)
13:31:36 * hackagebot vinyl-vectors 0.1.0.2 - Vectors for vinyl vectors  https://hackage.haskell.org/package/vinyl-vectors-0.1.0.2 (andrewthad)
13:31:38 * hackagebot vinyl-vectors 0.1.0.3 - Vectors for vinyl vectors  https://hackage.haskell.org/package/vinyl-vectors-0.1.0.3 (andrewthad)
13:36:18 <ReinH> shersh: If you want to update a value then you need to use a setter:
13:36:25 <ReinH> > (1,2) & _2 .~ 0
13:36:27 <lambdabot>  (1,0)
13:36:40 <ReinH> view is for getters and can't update anything
13:37:26 <ReinH> (to be clear, you are ofc not updating old value in place, you are creating a new value)
13:37:32 <ReinH> s/old/the old
13:38:36 <lingxiao> hey all:
13:38:36 <lingxiao> http://stackoverflow.com/questions/34097869/arbitrary-instance-for-stdgen
13:38:42 <lingxiao> could someone take a look at the question?
13:41:36 * hackagebot typography-geometry 1.0.0.1 - Drawings for printed text documents  https://hackage.haskell.org/package/typography-geometry-1.0.0.1 (JeanPhilippeBernardy)
13:52:55 <koz_> Is there a reason why Data.Tree.drawTree only draws trees of Strings?
13:53:03 <koz_> I have a tree of Bools I wanna draw using that method.
13:54:17 <ChristianS> koz_: convert them to whatever string representation you want to use?
13:55:01 <koz_> ChristianS: I just want the Bools to be represented as "True" and "False" then.
13:56:56 <ReinH> koz_: drawTree . fmap show
13:57:08 <koz_> ReinH: Thanks!
14:01:47 <AjaxCrixum> have any of you read "SICP"?
14:02:14 <koz_> AjaxCrixum: I have.
14:03:07 <koz_> Hmm, print seems to render newlines as \n for me.
14:03:12 <koz_> Am I using the wrong function?
14:03:30 <AjaxCrixum> did you like it? was it worth it? what did you gain from it?
14:03:46 <AjaxCrixum> i'm trying to read it and it seems dry and overrated so far (though i'm only in chapter 1)
14:04:03 <ga2arch> koz_: putStrLn "hello" or putStr "hello\n"
14:04:03 <koz_> AjaxCrixum: If you've never programmed in a functional way before, it's pretty mind-blowing.
14:04:11 <koz_> ga2arch: Thanks.
14:04:28 <koz_> Seeing as you're on #haskell ... yeah, none of this will be a major revelation to you.
14:04:44 <koz_> I like it as an introduction to programming because it doesn't shy away from the mathematical side of it or pretend like it isn't necessary.
14:06:29 <AjaxCrixum> koz_: true that. i am having trouble with the "Orders of Growth" section; it's new to me and makes no sense. were you able to understand that section initially? it seems so out of the blue, imo.
14:06:58 <koz_> AjaxCrixum: It *is* out of the blue, but I can explain it to you if you want.
14:07:12 <koz_> My Master's was in a similar area, and I see students get confused by this *all the time*.
14:08:24 <AjaxCrixum> koz_: that would be quite wonderful. is it ok if we stay in the main channel or should we take this to pm?
14:09:07 <koz_> AjaxCrixum: I'd rather take this to PM if you don't mind.
14:09:11 <ga2arch> i really don't like this piece of code http://lpaste.net/146494, any suggestions on how to refactor it ? 
14:09:20 <AjaxCrixum> koz_: alrighty
14:09:23 <koz_> ga2arch: Has it been through hlint?
14:11:20 <ga2arch> koz_: yup, i don't like the nested if :/
14:12:50 <koz_> AjaxCrixum: PMed you, in case you didn't notice. :P
14:15:13 <athan> Hi everyone. Does anyone here know if hackage is also an OAuth or OpenID authority? I'd like to make a small web app that extends some of Hackage, where it would be useful to tell if someone logged into /my/ website is the user they say they are on Hackage's data.
14:15:54 <monochrom> neither
14:17:14 <athan> darn
14:28:45 <DarwinElf> someone mentioned me? pikajude maybe? you can msg me
14:31:38 * hackagebot blank-canvas 0.6 - HTML5 Canvas Graphics Library  https://hackage.haskell.org/package/blank-canvas-0.6 (AndyGill)
14:32:41 <danilo2> Hello guys! :) Is there any way in Haskell to concatenate type-level Symbols? (For those who dont know, symbol is just a type-level String literal)
14:38:12 <geekosaur> not in 7.10; I think that's being looked at but don't know offhand if it'll be in 8.0.1
14:49:49 <pie_> hi guys, im new, how can i install lambda-ccc with stack? (https://github.com/conal/lambda-ccc) a .cabal is provided along with install instructions on the github page but idk how to work that or how to get these deps satisfied: http://pastebin.com/sY7PhggQ
14:51:26 <pie_> could someone give a hand?
14:55:17 <tommd> pie_: There is no stack.yaml so tha answer is: don't use stack.  Use  cabal.
14:55:24 <tommd> pie_: 'cabal install'
14:55:36 <tommd> pie_: And if you don't have cabal, 'stack install cabal-install'
14:55:46 <pie_> but doesnt that do some kind of messing up global stuff or something?
14:56:03 <tommd> pie_: Not global, but user pacakge database.
14:56:18 <pie_> ok, that then.
14:56:19 <tommd> pie_: cabal sandbox init && cabal install && cp .cabal-sandbox/bin/* ~/.local/bin
14:56:54 <pie_> i dont have a lot of space in my home folder, is there a way to tell it to do its stuff somewhere else?
14:57:04 <tommd> I always have viewed my user's .cabal and .ghc directories as just a shared sandbox and been happy to delete them in cases of conflict.
14:57:17 <tommd> pie_ Probably.  cabal sandbox --help
14:57:35 <pie_> thanks, hopefully ill have some luck with this
14:57:36 <tommd> pie_: --sandbox=DIR
14:58:43 <danilo2> geekosaur: oh nice, thats very good information! thank you! :)
14:59:13 <pie_> hm init initializes sandbox in current dir
14:59:19 <geekosaur> actually I am vaguely remembering email from spj saying "we haven't really seen a use case for this yet, if you need it then talk to us"
14:59:50 <geekosaur> at the moment there's very little you can do with things of kind Symbol
15:00:03 <pie_> tommd: cabal: The program 'ghc' version >=6.4 is required but it could not be found.
15:00:15 <pie_> do i need to install ghc separately from stack for this?
15:01:30 <geekosaur> you can compare them, you can reflect them into value space (and limitedly reflect them from value to type space; I am not sure these can be reflected to *existing* Symbol types though!)
15:01:51 <geekosaur> pie_, I'd expect so
15:01:59 * hackagebot dawdle 0.1.0.0 - Generates DDL suggestions based on a CSV file  https://hackage.haskell.org/package/dawdle-0.1.0.0 (arnon)
15:02:13 <pie_> :/
15:02:19 <pie_> le sigh
15:02:52 <geekosaur> you might be able to ceat by setting up a dummy stack project and using stack exec -- cabal-install ...
15:02:54 <geekosaur> *cheat
15:03:10 <geekosaur> does seem like rather a horrid hack though
15:03:29 <geekosaur> the other alternatie is figure out how to write a stack.yaml for it
15:03:58 <tommd> pie_: YOu can point cabal to stack's ghc if you desire.
15:04:05 <tommd> Or you can generate your own stack.yaml
15:04:08 <tommd> stack init --solver
15:05:19 <pie_> tommd: if it works that would be nice, how can i point it to stacks ghc?
15:05:44 <Voltz> Hey, are there any reputable benchmarks for Haskell?
15:06:45 <tommd> many
15:07:05 <Voltz> Can I get one?
15:08:05 <pie_> what do i do after running stack init?
15:08:27 <tommd> Would a benchmark for crypto make you happy?
15:08:37 <pie_> i get the feeling that i should be able to use "location:" in the stack.yaml files to point to dependencies i can manually satisfy?
15:08:41 <tommd> pie_: stack install
15:08:59 <pie_> thanks
15:09:09 <tommd> pie_: Yes, see the stackage documentation for the yaml format.  You can point to git repos and commits.
15:09:39 <pie_> " base version 4.8.1.0 found   - netlist-to-verilog requires ==3.*"
15:09:41 <pie_> >.>
15:09:43 * pie_ cries
15:09:57 <tommd> Wow, that is a very old version of base.
15:10:15 <tommd> pie_: I'd cry too - it's funner than getting such an old GHC going.
15:10:37 <pie_> oddly enough, circat has recent commits
15:12:45 <pie_> tommd: so how can i point cabal to stack's ghc?
15:13:53 <danilo2> geekosaur: thats interesting (sorry for my lag now) - I would use them heavely to intorduce compile time errors that look nice - You know what I mean? Right now you can just leave not matched type class which names tells what has happened - with type level strings that owuld be MUCH nicer and thats a finally good way to introduce user-based compile time errors in haskell (finally)
15:14:13 <geekosaur> I think ghc8 has solutions for that?
15:17:00 <pie_> tommd: there is the following in the .cabal file, so with any luck no need to install old base: "  if flag(base4)     build-depends:   base == 4.*"
15:17:10 <danilo2> geekosaur: I cannot wait for ghc 8.* ... seriosuly, that would be a release!
15:17:57 <danilo2> geekosaur: another very usefull thing is sorting datatypes on type level by their names. Now you can compre symbols (thats ok, but concatenation or their modifications would be lifesver in some situations)
15:18:33 <geekosaur> pretty sure you need to talk to the devs about that last
15:18:41 <danilo2> (to create for example type-level sets of datatypes based on their names with qualified paths - I'm doing something like that at them oment but thats a bit ugly right now
15:19:01 <danilo2> geekosaur: what is the best way to contact them? via mail ?
15:20:22 <geekosaur> http://mail.haskell.org/cgi-bin/mailman/listinfo/ghc-devs
15:44:12 <drw> how can I call 'length' on IO [FilePath]
15:44:44 <Clint> you want the length of the list returned by that IO action?
15:45:35 <drw> @Clint yes, I'm calling find, getting an IO [FilePath], and would like to count it, wrap it in a Snap handler and display the result
15:45:35 <lambdabot> No module "yes, I'm calling find, getting an IO [FilePath], and would like to count it, wrap it in a Snap handler and display the result" loaded
15:46:02 <glguy> drw: @ is for bot commands
15:46:04 <EvanR> drw: no twitter plz
15:46:05 <zachk> fmap length 
15:46:20 <danilo2> geekosaur: thank you very much! :)))
15:46:34 <glguy> drw: keep in mind that a value with type 'IO [FilePath]' doesn't have a length, it's not a list of anything, it's an action that when executed returns a list
15:46:35 <geekosaur> more generally, you want to learn about do notation, and beyond that the (>>=) operator
15:46:57 <glguy> once you execute it you'll be able to compute the length of its result
15:47:13 <geekosaur> danilo2, to be honest I'm a little surprised you're not already on there, with all the type level hackery you've been doing
15:48:25 <drw> EvanR: sorry
15:59:18 <lynnard> how can I change my .cabal to a custom location?
15:59:20 <koz_> AjaxCrixum: Replied. SOrry for suddenly vanishing.
15:59:32 <barrucadu> zoku: There's the source for irc-client, which uses it: https://github.com/barrucadu/irc-client
15:59:47 <geekosaur> lynnard, afaik .cabal/config must stay where it is, but you can change all the other paths via that file
16:00:10 <lynnard> does ghc use that file?
16:00:13 <zoku> right barrucadu, after some futsing i have a basic client working
16:02:01 <geekosaur> no
16:02:24 <geekosaur> ghc uses ~/.ghc which you also can't rationally move (I noticed a feature request for it in ghc trac)
16:05:59 <icen> Can you just symlink from somewhere else?
16:06:35 <geekosaur> usually the desire is to put all the .foo stuff somewhere else where it doesn't clutter ~; a symlink defeats the point
16:07:00 <lynnard> okay; I've figured it out :)
16:07:21 <lynnard> export GHC_PACKAGE_PATH=<somewhere you like>; this fixes ghc
16:07:28 <geekosaur> (I'd be happier about it if the people providing patches for this would do it *correctly*, but every patch I've seen is halfarsed)
16:07:52 <lynnard> env -u GHC_PACKAGE_PATH cabal --config-file=<somewhere you like> ...
16:08:18 <drw> glguy: I think understand that...I can make this work in a stand-alone main function because I can change the function from, IO [FilePath] to IO Int.  But I'm lost inside the Snap App
16:08:32 <lynnard> it's kinda nasty because I have to delete the environment variable for cabal (put it into package-db under the config file instead)
16:09:50 <lynnard> for years I'm actually a bit shocked at these obscure 'defaults'; they are not implemented in a correct way that provides the supposed flexibility
16:10:12 <lynnard> I suppose it's not hard to fix; but people don't bother
16:10:24 <Welkin> skynard?
16:10:33 <koz_> Welkin: My thoughts exactly.
16:11:22 <lynnard> lol I don't sing songs
16:12:02 * hackagebot haskell-src-exts 1.17.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.17.1 (mpickering)
16:14:02 <pie_> I have verilog 0.2 installed so why could i be getting this?: http://pastebin.com/H1dmPGMc
16:15:09 <tommd> pie_: Is verilog installed in the sandbox under consideration?
16:15:16 <tommd> stack exec ghc-pkg list verilog
16:15:31 <pie_> ive been making some progress using stack (i think)
16:15:38 <pie_> oh *thats* how i list packages
16:15:54 <Welkin> stack exec -- <command>
16:17:11 <pie_> ohhhhh
16:17:19 <pie_> these are all directory-local (for some reason?)
16:17:47 <pie_> no clue how i compiled that other thing then though...
16:17:47 <Welkin> yes
16:17:49 <Welkin> of course
16:17:55 <Welkin> like a cabal sandbox
16:17:58 <pie_> maybe it didnt compile
16:18:34 <pie_> but it did..
16:19:49 <Welkin> pie_: here is your problem (conflict: netlist-to-verilog => verilog==0.2)
16:19:54 <pie_> yeah
16:20:08 <Welkin> which stackage snapshot are you using?
16:20:10 <pie_> ifound that now, but i have no clue how there could be a conflixt
16:20:43 <pie_> im using whatever came with the default setup that one does to get stack and ghc >.>
16:21:06 <Welkin> perhaps try netlist-to-verilog is your conflict
16:21:12 <Welkin> er
16:21:16 <Welkin> netlist-to-verilog is your conflict
16:21:24 <Welkin> I don't see it on hackage
16:21:48 <Welkin> but from the error it looks like it specifies verilog version 0.2, which does not exist
16:21:54 <Welkin> so it cannot resolve
16:22:07 <pie_> its here https://github.com/ku-fpg/netlist
16:22:46 <pie_> i ran stack init --solver in verilog and stack install as well and it compiled fine (afaict)
16:22:50 <Welkin> oh
16:22:54 <Welkin> that is not the one on hackage
16:22:57 <Welkin> that is the problem
16:23:01 <Welkin> add that to your stack.yaml
16:23:14 <pie_> trying to get it to generate my stack.yaml xD
16:23:23 <Welkin> under extra-deps: 
16:23:24 <pie_> oh wait, well i guess i succeeded in getting it to do that
16:23:36 <pie_> Welkin: yes?
16:23:39 <Welkin> actually, not, that isn't right
16:23:53 <Welkin> under local packages
16:24:07 <Welkin> extra-deps is only for packages that are on hackage which are not in the stackage snapshot
16:24:10 <pie_> with a relative path?
16:24:13 <Welkin> yes
16:24:36 <pie_> i dont have a generated stack.yaml yet to modify so ihave to DIY >.>
16:24:47 <pie_> unless theres an easy way to do the same with the .cabal
16:25:32 <Welkin> stack init
16:25:57 <pie_> but then it complains about deps
16:26:09 <pie_> or rather, thats exactly what complains
16:26:26 <pie_> "build plan did not match your requirements"
16:26:36 <Welkin> actually no
16:26:40 <Welkin> I always forget the stack command
16:26:44 <Welkin> thing is too complex
16:27:31 <Welkin> oh yeah
16:27:46 <Welkin> actually, just start with a fresh copy of the project from github
16:27:54 <Welkin> then create a new stack project with it
16:28:13 <mgsloan> You can skip the build requirements step by specifying a "--resolver" flag
16:28:17 <pie_> thats pretty much what im doing...i think?
16:28:20 <pie_> ook
16:28:31 <mgsloan> The reaon it fails is that it's trying to find a resolver that satisfies all the requirements, and none do
16:28:59 <pie_> but what resolver would there be that satisfies it?
16:29:39 <mgsloan> You might try "stack init --solver"
16:29:48 <Welkin> mgsloan: no, we solved the problem
16:29:49 <mgsloan> Oh wait I see you already tried that, hmm
16:30:02 <Welkin> local package with the same name as a hackage package
16:30:12 <mgsloan> That should work
16:30:13 <Welkin> added to local package list
16:30:20 <Welkin> you need to create a stack.yaml though
16:30:26 <Welkin> I usually have one generated using a tmeplate
16:30:34 <mgsloan> Oh, does init not work if the local package aliases a hackage package?
16:30:35 <Welkin> you could just make a minimal one
16:30:37 <mgsloan> That would be a bug
16:30:51 <pie_> yeah Welkin: i guess ill have to do that
16:30:59 <Welkin> mgsloan: well, it is not a local package really
16:31:08 <Welkin> it is a subdirectory in the project that contains the package
16:31:35 <mgsloan> Sure, if it's in your packages list it's considered a local package
16:31:38 <Welkin> so, it is not an installed package, just the source for it
16:31:52 <Welkin> mgsloan: it wasn't in the package list, which was the problem
16:31:58 <Welkin> because the project was not set up for stack
16:32:50 <Welkin> still I have no idea how to make a stack.yaml though
16:32:57 <Welkin> there must be a command for a template for that
16:33:34 <mgsloan> AFAIK the only template is the one generated by "stack init"
16:33:37 <Welkin> oh
16:33:38 <pie_> well i think i hacked something together, lets see if it works
16:33:41 <Welkin> you *Can* use stack init
16:33:50 <Welkin> http://docs.haskellstack.org/en/stable/GUIDE.html#existing-projects
16:33:53 <pie_> there are some kind of *project* templates
16:33:54 <Welkin> stack is too complicated
16:34:07 <Welkin> try stack init
16:35:00 <pie_> "Finds all of the .cabal files in your current directory and subdirectories (unless you use --ignore-subdirs) and determines the packages and versions they require"
16:35:09 <pie_> maybe i could just try stack init in the root of all 4...
16:35:18 <pie_> heh i may have simply overcomplicated this for myself
16:35:21 <Welkin> no
16:35:24 <Welkin> only in the root
16:35:31 <pie_> i mean
16:35:39 <pie_> i mean what you meant, ive been doing it wrong.
16:35:44 <mgsloan> Welkin: I'm confused, what specifically is complicated?
16:35:48 <Welkin> or just copy the basic stack.yaml form that page
16:35:50 <Welkin> and modify it
16:36:09 <Welkin> mgsloan: too many commands and options
16:37:19 <mgsloan> That's what tends to happens when you add many of the features people want / need.  I think it's a documentation problem more than anything.  The --help output could really use better organization: https://github.com/commercialhaskell/stack/issues/1333
16:39:05 <mgsloan> It probably is good to learn how to write stack.yaml files directly, though.
16:39:41 <mgsloan> Often I just write a stack.yaml file with just the line "resolver: lts-3.16" (or whichever), for single package projects
16:40:17 <Mike1000> I need to compile with profiling, and one of my install libraries (Text.XML.Light) isn't built for profiling. How do I do that?
16:41:07 <mgsloan> Welkin: Also, after one last feature (better support for custom snapshots + unifying custom snapshots with extra-deps), we're probably going to enter a phase of stack stabilization, cleanup, and simplification
16:43:25 <pie_> Welkin: i feel pretty dumb now
16:43:25 <mgsloan> Not that new features will stop, but the list of things we need that stack doesn't handle is dwindling / near non-existent
16:43:37 <pie_> stack init and install at the root of the 4 packages worked
16:43:47 <pie_> as in a b c d are subdirs of "root"
16:43:52 <mgsloan> Glad it worked out :D
16:43:53 <pie_> and running it in "root" worked
16:44:15 <pie_> so this was actually an intermediary step
16:44:56 <pie_> this was a dependency for something, so should i move dependencies into a subdir of what i *actually* want to compile and run stack init like that?
16:46:00 <pie_> hm. that seems to be the way to go
16:46:35 <mgsloan> It definitely takes some time to learn how stack does things.  I recommend reading / skimming the user guide and stack.yaml config http://docs.haskellstack.org/en/stable/GUIDE.html http://docs.haskellstack.org/en/stable/yaml_configuration.html
16:46:44 <mgsloan> And yeah, that's the way to go
16:46:46 <pie_> yeah i really need to sit down and read docs :/
16:46:59 <Mike1000> I'm on windows and I've only ever used cabal to install libraries. Now I need to do some debugging and I need to compile one library I use (xml) with profiling enabled. How do I do that? 
16:47:04 <zoku> barrucadu: but the lack of ping handlers and such makes me think I should use the irc-client
16:50:36 <mgsloan> Mike1000: Unfortunately, you need to install all libraries with profiling.  Stack lets you just pass "--library-profiling" and it'll install the profiling versions of all the stuff you need.
16:51:18 <mgsloan> I think with cabal you can either blow away your ~/.cabal or use sandboxes, and set the "executable-profiling: True" in your cabal.config - http://stackoverflow.com/a/12212445/1164871
16:52:06 <pie_> this is going to take a long time to compile..
16:52:42 <Mike1000> msgloan: thanks, I'll read your links and study this
16:53:38 <mgsloan> I'd recommend using stack, this is one of those spots that cabal is really tricky. (not that stack has it fully nailed)
16:53:49 <mgsloan> I'm biased, though, as someone who works on it and uses it a lot
16:54:16 <Mike1000> mgsloan: this is the first I've heard of "stack" -- does it come with the Haskell Platform? that's how I origiallly installed things
16:54:20 <moop> is stack only for servers or do you use it in development too mgsloan 
16:54:49 <mgsloan> moop: stack is a build tool, so it's used in development
16:55:02 <mgsloan> Mike1000: The next version of the haskell platform will come with it
16:55:22 <moop> oh i thought it was more of a deployment tool
16:55:45 <moop> i see
16:55:47 <moop> i should check it out
16:56:07 <mgsloan> Mike1000: It's a build tool that also sets up the rest of your haskell tools (ghc, ghcjs, mingw, etc)
16:59:02 <Tehnix> stack is basically a replacement for cabal
16:59:11 <Tehnix> works really well
17:00:21 <Tehnix> moop: You can read a bit about stack here http://docs.haskellstack.org/en/stable/GUIDE.html
17:00:51 <Tehnix> or this one http://seanhess.github.io/2015/08/04/practical-haskell-getting-started.html, probably better
17:01:10 <pie_> mgsloan: what can I do about "The program 'alex' version >=3.1.3 is required but it could not be found."? I see that it's on hackage...
17:01:31 <mgsloan> pie_: "stack build alex"
17:01:37 <pie_> tyvm
17:01:49 <pie_> why didnt stack init --solver handle it?
17:01:52 <mgsloan> I think that means that someone forgot to list alex in their "build-tools:", but not sure
17:01:56 <pie_> ah.
17:02:12 <mgsloan> As stack does automatically install alex, happy, etc
17:02:13 <Welkin> I never encountered that
17:02:17 <pie_> that sounds logical.
17:02:26 <Welkin> although I installed alex and happy on their own and put them on my path
17:02:37 <Welkin> not through stack
17:03:39 <moop> so will stack replace cabal eventually?
17:03:44 <pie_> it seems hermit-1.0.0.0 is whats complainig
17:05:06 <mgsloan> moop: Who knows.  It's only a replacement for the cabal-install executable.  It makes heavy use of Cabal-the-library
17:05:31 <mgsloan> But a darn good replacement :) it pretty much means that if your project builds for you, it's going to build for others
17:05:52 <pie_> oh crap...
17:05:57 <pie_> http://pastebin.com/hD2eT0Yu version mismatch or something?
17:06:30 <mgsloan> Yes, that's a change in the GHC API
17:07:23 <pie_> >.<
17:07:59 <pie_> with any luck its a specific version of hermit that i need, lambda-ccc lists a specific commit
17:08:06 <mgsloan> Based on the cabal metadata, it claims to support ghc-7.10
17:10:16 <pie_> mgsloan: will a local "hermit" directory override the globally installed hermit-1.0.0.0?
17:11:02 <mgsloan> Yep
17:11:20 <ProofTechnique> @type (.) . (.)
17:11:21 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:11:26 <ProofTechnique> That's better
17:14:21 <pie_> conflict: base==4.8.1.0/installed-4f7...,hermit-second => base>=4.7 && <4.8
17:14:23 <pdkr> how can I utf8-decode a ByteString?
17:14:44 <exio4> using Data.Text.Encoding.decodeUtf8 ? 
17:15:22 <ProofTechnique> @hoogle ByteString -> Text
17:15:22 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
17:15:22 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
17:15:22 <lambdabot> Data.Text.Encoding decodeLatin1 :: ByteString -> Text
17:15:24 <pie_> mgsloan: it seems like this may be an unimportant part of the dependency (just example code) so I could a) change the .cabal to allow the base version, b) leave out the code
17:15:46 <pdkr> but what if i want a String?
17:15:55 <ProofTechnique> :t unpack
17:15:57 <lambdabot>     Not in scope: ‘unpack’
17:15:57 <lambdabot>     Perhaps you meant one of these:
17:15:57 <lambdabot>       ‘BS.unpack’ (imported from Data.ByteString),
17:16:02 <pdkr> or is that the Wrong Thing To Do (tm) ?
17:16:06 <ProofTechnique> :t Text.unpack
17:16:08 <lambdabot> Not in scope: ‘Text.unpack’
17:16:15 <ProofTechnique> Oh. blah
17:16:17 <ProofTechnique> @hoogle unpack
17:16:17 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
17:16:18 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
17:16:18 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
17:16:39 <ProofTechnique> :t Data.Text.Lazy.unpack
17:16:41 <pdkr> because i'd really like to find a constant map String -> Builder -> ByteString -> String
17:16:41 <lambdabot> Data.Text.Internal.Lazy.Text -> String
17:16:48 <pdkr> uh, constant composition* of maps
17:16:55 <ProofTechnique> Why String?
17:17:06 <exio4> @type Data.Text.unpack . Data.Text.Encoding.decodeUtf8 
17:17:07 <lambdabot> BSC.ByteString -> String
17:17:15 <pdkr> well I guess I can do Text as well. but i don't think there's a Builder for Text
17:17:24 <pdkr> (though i didn't check tbh)
17:17:58 <ProofTechnique> There definitely is
17:18:14 <pdkr> i mean i need to encode and decode bytestrings representing C strings. and i'm pretty sure the C strings are utf8 encoded.
17:18:38 <cite-reader> The character set of C strings is pretty much unspecified.
17:18:49 <cite-reader> You need application-specific knowledge.
17:18:52 <pdkr> okay but i'm pretty sure in this case it's utf8
17:19:03 <cite-reader> Fair.
17:19:06 <ProofTechnique> Then why not use Text and skip the ByteString phase?
17:19:20 <pdkr> ProofTechnique: because i'm dealing with binary input data
17:19:30 <pdkr> which i'm parsing with attoparsec
17:19:34 <ProofTechnique> Aha
17:19:38 <pdkr> (although i'm willing to change that)
17:20:06 <ProofTechnique> The choice of text representation is really down to what you're doing. Where's the input coming from?
17:20:25 <ProofTechnique> And how do you want to be able to manipulate it once you have it?
17:20:41 <pdkr> they are small strings that tend to be from a constant set
17:21:19 <pdkr> and tbh i don't even expect any utf8 strings, but i'd like to be prepared
17:21:43 <cite-reader> ... do you perhaps mean "non-ASCII"?
17:21:57 <pdkr> well again, i must check, but i'm pretty sure it's utf8
17:22:05 <pdkr> and either way i'd like to know
17:22:06 <ProofTechnique> Are you reading files, pulling off the wire? Once you have these strings, do you want to treat them like text, or like bytes?
17:22:09 <pie_> well crap  src/HERMIT/GHC/Typechecker.hs:25:19:
17:22:09 <pie_>         Module TcType does not export noUntouchables
17:22:13 <pie_> and thats core  code afaict
17:22:42 <pdkr> ProofTechnique: i guess you could say "off the wire"
17:23:01 <pdkr> ProofTechnique: primarily i want to deal with them with the lowest packing/unpacking latency
17:23:21 <ProofTechnique> All right, well, ByteString's a fair representation, then
17:23:27 <pdkr> that makes me wary of Text, but maybe that's unjustified
17:24:25 <pdkr> specifically, i'm interfacing an IPC that sometimes contains strings referring to certain interfaces it provides
17:25:02 <pdkr> (and i'd like to be able to do both directions)
17:25:47 <pdkr> so if I should do everything in Text, that's fine. but ByteString doesn't take it for outputting, so i'd have to go via String or something anyway
17:26:25 <cite-reader> You lost me at "ByteString doesn't take it for outputting".
17:26:48 <pdkr> cite-reader: where is Text -> Builder ?
17:26:54 <pdkr> (Builder as in Data.ByteString.Builder)
17:27:03 <pdkr> ah. i am an idiot
17:27:13 <cite-reader> Data.Text.Encoding.encodeUtf8Builder
17:27:17 <pdkr> bytString . encodeUtf8
17:27:24 <pdkr> cite-reader: no, that's Data.Text.Builder
17:27:43 <cite-reader> The link takes me to Builder in the ByteString docs.
17:27:43 <ProofTechnique> :t Data.Text.Encoding.encodeUtf8Builder
17:27:45 <lambdabot> Data.Text.Internal.Text -> Data.ByteString.Builder.Internal.Builder
17:28:43 <ProofTechnique> Though if you're really reading bytes, you'd likely be better off with hGet, since you skip packing it into a ByteString
17:28:45 <pdkr> cite-reader: you are right
17:29:48 <pdkr> ProofTechnique: hmm
17:29:48 <ProofTechnique> Though that assumes ISO-8859-1, apparently
17:29:58 <ProofTechnique> Though, for your purposes, that may be just fine
17:30:58 <pdkr> ProofTechnique: wait, how does hGet care about encoding?
17:32:14 <jonaqua> Hello everyone
17:32:32 <ProofTechnique> Couldn't say, it's just what the docs say
17:32:46 <cite-reader> ProofTechnique: I don't see it. Which docs are you looking at?
17:32:49 <pdkr> ProofTechnique: where?
17:32:51 <cite-reader> jonaqua: Hi!
17:32:51 <ProofTechnique> It's implemented in terms of System.IO.hGetBuf
17:33:22 <ProofTechnique> http://hackage.haskell.org/package/bytestring-0.9.2.1/docs/Data-ByteString.html#g:29
17:33:35 <pdkr> ProofTechnique: "hGetBuf ignores the prevailing TextEncoding and NewlineMode on the Handle, and reads bytes directly."
17:33:48 <ProofTechnique> In the description of hGetContents, it says "As with hGet, the string representation in the file is assumed to be ISO-8859-1"
17:34:31 <pdkr> ProofTechnique: where?
17:34:41 <ProofTechnique> "In the description of hGetContents"
17:34:49 <ProofTechnique> On the hackage page that I linked
17:34:59 <ProofTechnique> Line 3 of the description
17:35:17 <pdkr> ProofTechnique: ah. i was looking at the System.IO one
17:35:47 <ProofTechnique> Yeah. I assume by "ignores the prevailing TextEncoding" it means "ignores in favor of ISO-8859-1"
17:35:51 <cite-reader> That doesn't even make _sense_.
17:35:53 <pdkr> haha
17:36:05 <pdkr> cite-reader: i agree. it outputs bytes. so where's the encoding?
17:36:29 <ProofTechnique> I am merely the messenger :D
17:36:53 <pdkr> yeah np
17:36:54 <ProofTechnique> In any case, hGet is your best bet if you want to avoid any kind of packing overhead
17:36:56 <pdkr> but i can't verify this message
17:37:00 <pdkr> hmm
17:37:21 <pdkr> well on the one hand, i guess i do. on the other hand, i was also hoping to make a nice and composable library. so this kills that a little bit.
17:37:36 <ProofTechnique> Why so?
17:38:00 <ProofTechnique> You can wrap up all the gross low-level stuff in a high-level API, I'd think
17:38:04 <cite-reader> I don't see anything in this implementation that assumes an encoding; I think that doc is wrong; and indeed that note is gone in the most recent version.
17:38:17 <ProofTechnique> Oh, that's what I get for following a link from Hoogle :D
17:38:42 <pdkr> or maybe i'm just complaining here...
17:39:07 <pdkr> okay, so using this hGet, i can keep using attoparsec. i can keep using ByteString builders.
17:39:09 <pdkr> so nothing really changes
17:39:49 <ProofTechnique> You could go the exact opposite direction and use pipes for the interaction part, then just write the parse and thread it through pipes-parse :D
17:39:50 <pdkr> okay then i guess i don't understand the following
17:39:51 <pdkr> <ProofTechnique> Though if you're really reading bytes, you'd likely be better off with hGet, since you skip packing it into a ByteString
17:40:15 <pdkr> because hGet outputs a ByteString
17:40:32 <ProofTechnique> That is, instead of reading a String, then packing it into a ByteString, you just read bytes directly into a ByteString
17:41:01 <pdkr> ProofTechnique: ah. i guess i understand your point.
17:41:18 <pdkr> hmm
17:42:09 <pdkr> ProofTechnique: btw, i was looking at pipes (and also conduit). definitely want to make both of those possible, but stay generic as well. any tips/tricks?
17:42:52 <ProofTechnique> Write your parser without respect for the IO part, basically. I've been half working on an XML parser (oh, joy) for that exact reason
17:43:35 <pdkr> ah, XML parsers. i'm currently using xml-light, and it almost gets the job done, but my main problem is that there is no useful error reporting
17:44:37 <ProofTechnique> I'm trying to write it in attoparsec, but XML is an honest-to-Church nightmare
17:45:10 <ProofTechnique> Someday I'll finish and then no one will have to write one ever again :D
17:45:35 <cite-reader> How many of the insane features are you implementing?
17:45:46 <ProofTechnique> Attempting all of them :|
17:46:04 <cite-reader> Oh boy.
17:46:38 <ProofTechnique> Trying to support both versions, if possible
17:46:48 <cite-reader> I have literally never encountered an XML 1.1 document.
17:47:14 <ProofTechnique> Nor I, but if I'm going to drive myself insane, I might as well finish the job
17:47:26 <pdkr> ProofTechnique: what about HXT?
17:49:27 <ProofTechnique> HXT is a bunch of *stuff*. I just want a dead-simple (whatever that means to XML) validating parser, no bells and whistles.
17:50:05 <cite-reader> Validating parsers can do network IO, so... your quest may be doomed.
17:51:00 <ProofTechnique> I started writing it because I wanted to stream API data from a game I don't even play anymore, and I wanted to do it with pipes and pipes-parse, and the simplest idea was to just write an attoparsec parser. Then I stopped playing the game and the parser became the project :D
17:51:03 <pdkr> hmm, i'm getting more convinced that I should just be passing ByteStrings around rather than Strings, because utf8 decoding might fail
17:51:39 <cite-reader> You almost never actually want Strings, so good call.
17:51:45 <pdkr> and i don't want to pass around errors
17:52:04 <pdkr> cite-reader: are they really that bad? is Text better in every case?
17:52:25 <ProofTechnique> cite-reader: This is true, but I feel like I can keep the parser itself nice and clean, and wrap that ugliness up in a box where I won't have to look at it
17:52:42 <cite-reader> String is [Char], which is really really wasteful. Text is almost always bad.
17:52:46 <cite-reader> Er, better.
17:52:47 <numberten> is there a function of type [(k,v)] -> Map k [v] that I'm just missing?
17:52:47 <cite-reader> I'm tired.
17:53:01 <numberten> I know it's a simple fold, but it seems like something that would be common enough to be on hoogle
17:53:07 <ProofTechnique> @hoogle [(k,v)] -> Map k [v]
17:53:08 <lambdabot> No results found
17:53:32 <ProofTechnique> numberten: Why [v]?
17:53:34 <pdkr> cite-reader: okay, i'll keep it in mind. i might choose to do something with "real" text later, so i guess i'll pick Text then
17:53:56 <numberten> so you create a list of all the values associated with a given key
17:54:04 <numberten> instead of replacing them with the last one
17:54:26 <ProofTechnique> Oh, I see what you're doing. Okay
17:55:41 <exio4> @type Data.Map.fromList . map (fmap return) 
17:55:43 <lambdabot> (Monad m, Ord k) => [(k, a)] -> M.Map k (m a)
17:56:03 <ackthet> whats the haskell offtopic chan?
17:56:03 <numberten> yeah like if your key value list was the domain and codomain of a non-injective function
17:56:09 <cite-reader> ackthet: haskell-blah
17:56:16 <numberten> and you wanted to collapse repeated values
17:56:35 <exio4> @type Data.Map.fromListWith mplus . map (fmap return) 
17:56:36 <lambdabot> (Ord k, MonadPlus m) => [(k, a)] -> M.Map k (m a)
17:56:42 <exio4> there, that would work
17:57:06 <exio4> > (Data.Map.fromListWith mplus . map (fmap return)) [("abc", 1), ("def", 2), ("abc", 42)]
17:57:08 <lambdabot>  Not in scope: ‘Data.Map.fromListWith’
17:57:57 <ProofTechnique> > (Data.Map.fromList . map (fmap pure)) [("abc", 1), ("def", 2), ("abc", 42)]
17:57:58 <lambdabot>  Not in scope: ‘Data.Map.fromList’
17:58:06 <ProofTechnique> Rude
17:58:48 <exio4> ProofTechnique: fromList won't do what we want it to do
17:58:55 <exio4> > If the list contains more than one value for the same key, the last value for the key is retained.
17:58:57 <lambdabot>  <hint>:1:58: parse error on input ‘,’
17:59:00 <ProofTechnique> Aha
18:00:20 <pie_> anyone by any chance have a quick and easy fix for this?: https://github.com/conal/hermit-extras/issues/1
18:01:40 <hackrilege> Is there a way to order all Haskell programmes?
18:02:17 <numberten> exio4: thanks.. definitely didn't see that
18:02:47 <ProofTechnique> hackrilege: Order how?
18:02:53 <pdkr> hackrilege: do you mean "list"/
18:02:56 <hackrilege> That was the question
18:03:17 <hackrilege> No I meant order, as you would want to generate then in order
18:03:44 <hackrilege> So you need to know how you ate ordering then to generate them
18:03:49 <hackrilege> Are
18:03:54 <pdkr> hackrilege: ah. well for a subset of Haskell, it is decidable if it is valid, so one can list all programs of that subset
18:04:01 <pdkr> but e.g. TH makes that impossible
18:04:08 <hackrilege> Th?
18:04:12 <pdkr> template haskell
18:04:33 <hackrilege> Could you explain that a bit more?
18:04:40 <pdkr> hackrilege: still not quite sure what you're getting at here
18:04:51 <pdkr> can you be more concrete?
18:05:14 <hackrilege> Syntax, I guess id is simplest
18:05:28 <ProofTechnique> pie_: I don't see anything called TcType.noUntouchables in HEAD
18:05:46 <pdkr> hackrilege: are we talking "order" as in "total order" as used in mathematics?
18:06:02 <hackrilege> Then maybe there ate a bunch of things isomorphic to a single element repeated a bunch of times
18:06:07 <pie_> ProofTechnique: :(
18:06:10 <flyingbutter> can someone help me with my syntax here. http://pastebin.com/9ucU8ubj
18:06:14 <hackrilege> As in Ord
18:06:25 <ProofTechnique> pie_: I actually don't see anything called that in the whole source tree
18:06:34 <ProofTechnique> Where'd you find it?
18:06:43 <pdkr> flyingbutter: i hope that link is unintentional
18:06:46 <pie_> its a compilation error i get
18:06:54 <flyingbutter> pdkr, what do you mean
18:06:57 <flyingbutter> no pastebin?
18:07:04 <pie_> i guess i was lucky enough for it to be reproducible apparently :P
18:07:13 <pdkr> flyingbutter: it doesn't show code here
18:07:17 <flyingbutter> oh
18:07:20 <flyingbutter> what does it show
18:07:24 <cite-reader> Abuse.
18:07:26 <ProofTechnique> pie_: I'd have to see your GHC.TypeChecker, I suppose. It's not on your github
18:07:40 <hackrilege> Why ask about it? Kick
18:07:52 <flyingbutter> sorry
18:07:58 <hackrilege> !?
18:07:59 <flyingbutter> it was joak
18:08:02 <flyingbutter> i kid
18:08:02 <pie_> ProofTechnique: its not my github, i just want to use this
18:08:05 <flyingbutter> i thought i was funny
18:08:08 <ProofTechnique> Oh.
18:08:10 <cite-reader> None of us are laughing.
18:08:14 <flyingbutter> i am
18:08:16 <flyingbutter> a little bit
18:08:26 <hackrilege> Kick asap
18:08:42 <pdkr> hackrilege: every time you say that it's less likely it'll happen
18:08:42 <flyingbutter> no
18:08:44 <flyingbutter> i will leave
18:08:49 <flyingbutter> i was joking
18:08:51 <ProofTechnique> pie_: Oh, now I see.
18:08:53 <Welkin> this channel is for learning haskell
18:08:55 <flyingbutter> but i am interested in haskell
18:08:57 <Welkin> what would you like to learn
18:09:01 <flyingbutter> is this a functional language
18:09:06 <hackrilege> !?
18:09:06 <flyingbutter> or is it more imperitave
18:09:09 <hackrilege> Kick
18:09:11 <Welkin> @where learnhaskell -- flyingbutter 
18:09:11 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:09:12 <Welkin> start there
18:09:24 <flyingbutter> Welkin, thank you
18:09:28 <pie_> ProofTechnique: https://github.com/ku-fpg/hermit/blob/5557609f18d83b9acd1aafddaa1cfb3eb64f7c55/src/HERMIT/GHC/Typechecker.hs
18:09:32 <Welkin> the cis194 course is good
18:09:43 <Welkin> learn you a haskell is a fun book to read
18:09:47 <ProofTechnique> pie_: Aha. What version of GHC are you compiling with?
18:09:47 <Welkin> but not the best to really learn
18:09:50 <Welkin> I used it to start
18:09:57 <pie_> ProofTechnique: latest afaik
18:10:32 <flyingbutter> hackrilege, why are you so mad
18:10:46 <ProofTechnique> pie_: Well, there's your answer. See the latest version of that file: https://github.com/ku-fpg/hermit/blob/master/src/HERMIT/GHC/Typechecker.hs
18:11:07 <pie_> i tried with the latest repo version and then i got a different compile error i think
18:11:19 <pie_> but im unsure so i guess ill try again
18:11:39 <flyingbutter> anyway i am done wasting your time. i will come back when i learn more
18:11:43 <flyingbutter> stay salty hackrilege 
18:12:06 <hackrilege> Where is our mod?
18:12:17 <ProofTechnique> pie_: I don't know if you'll get it to work without hacking around it in hermit-extras to update the dependencies for 7.10
18:12:44 <pie_> hm
18:12:49 <pie_> im way too much of a noob for that
18:15:20 <hackrilege> How can I write an Ord instance for the list of all Haskell programmes?
18:15:46 <pdkr> hackrilege: you cannot list all haskell programs
18:16:02 <hackrilege> Why not?
18:16:06 <ProofTechnique> pie_: If you search hermit-extras on the actual HERMIT repo, they have some guidance that might get it compiling, though some of it is "wait for 7.10.3"
18:16:17 <pdkr> hackrilege: because TH makes it undecidable if a program is valid haskell
18:16:19 <Welkin> hackrilege: how do i monad?
18:16:31 <pdkr> so in particular, if you can list all haskell programs, you can solve the halting problem
18:16:34 <hackrilege> If I could determine their order it would be easy
18:16:46 <pie_> ProofTechnique: hm. thanks. i appreciate the help!
18:16:52 <ProofTechnique> hackrilege: It's very easy, you just order them alphabetically
18:16:53 <hackrilege> Welkin, could you rephrase that?
18:17:12 <geekosaur> ...
18:17:19 <ProofTechnique> I guess lexically, if you want to allow for Unicode identifiers
18:17:25 <Welkin> hackrilege: i has a lamduh
18:17:26 <Welkin> :P
18:17:31 <hackrilege> Stop
18:17:52 <Welkin> hackrilege: sensitive today
18:17:58 <Welkin> I thought your comment above was a joke
18:18:04 <Welkin> about the list of all Haskell programmes
18:18:08 <roconnor> ah, I remember now.   The worker-wrapper transformation is a example of a Pattern used in FP.
18:18:56 <ProofTechnique> hackrilege: Strictly speaking, [1..] is an ordering of all Haskell programs. Figuring out the mapping of Gödel number to actual program is left as an exercise
18:19:36 <hackrilege> Alphabetical is not sufficient
18:19:51 <hackrilege> It should be in terms of simplicity
18:20:08 <ProofTechnique> Nothing simpler than the naturals, then. You're all set with [1..]
18:20:18 <ProofTechnique> > take 10 [1..]
18:20:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
18:20:24 <ProofTechnique> There's the first 10 to get you started
18:20:46 <hackrilege> I'm going to generate all functions and plug then in add arguments to each other until they become conscious
18:21:01 <hackrilege> Sorry for the typos
18:21:15 <rom1504> did you think about buying a monkey to type these programs ?
18:21:33 <hackrilege> I'd start with point free operators
18:21:52 <hackrilege> These can rearrange the arguments in all ways easily
18:22:13 <hackrilege> Then all the various recursion schemes in order
18:22:15 <ProofTechnique> I feel like an AI composed of all Haskell programs would just thing about the Fibonacci sequence a lot
18:22:20 <ProofTechnique> *think
18:22:28 <hackrilege> Lol
18:24:02 <hackrilege> The great thing is the type checker means we can easily supply arguments of the correct type
18:24:17 <hackrilege> It seems th had some explaining to do
18:25:05 <hackrilege> Maybe I can omit it for this?
18:25:21 <hackrilege> Haskell 98 pure is without th?
18:26:27 <hackrilege> What tools are available to the Haskell community for automatically generating Haskell code?
18:26:57 <ProofTechnique> Template Haskell
18:27:29 <ProofTechnique> You have fallen into our trap, Mr. Bond
18:27:42 <lingxiao> I'd like to round a value to 2 decimal places .. ie 0.123 ~ 0.12
18:28:38 <hackrilege> It seems more out less trivial to observe by inspection a catalogue of the majority of common design patterns
18:28:43 <sm> lingxiao: the Decimal lib is a good way
18:29:06 <pdkr_> lingxiao: a dirty solution is: \x -> (round (x*100)) / 100
18:29:11 <pdkr_> or whatever "round" is called
18:29:18 <lingxiao> pdkr_ yeah I was going to say something other than that
18:29:27 <mniip> that's not a dirty solution
18:29:32 <hackrilege> Floor
18:29:34 <mniip> that's the proper solution
18:29:37 <lingxiao> but haha I'll check out what sm said and may yet just go with the "dirty"
18:29:43 <ReinH> it is both proper and dirty
18:29:44 <lingxiao> mniip why is it proper?
18:29:51 <lingxiao> or was it /s
18:29:57 <mniip> that's how a lot of things do it
18:29:59 <Welkin> prim and proper little miss hopper
18:30:03 <ReinH> but if you're using floating point numbers then it is no dirtier than anything else
18:30:04 <Cale> Another solution would be to use the Centi fixed point type from Data.Fixed
18:30:12 <hackrilege> Id tweak the exponent of a float no?
18:30:19 <pdkr_> mniip: why would you need to change base to clear the bits after the decimal point?
18:30:23 <Cale> However, that will result in different arithmetical results.
18:30:30 <lingxiao> wait so is everyone in agreement here that if you saw \x -> (round (x*100)) / 100 in code
18:30:36 <mniip> pdkr_, we don't change the base
18:30:36 <lingxiao> you wouldn't shake your head?
18:30:38 <ReinH> it's reasonable
18:30:42 <Cale> lingxiao: It's fine
18:30:48 <pdkr_> mniip: *100 is a base change
18:30:48 <hackrilege> Ok then you want a quotient
18:30:52 <ReinH> I'm sure that method has been used thousands of times
18:30:55 <mniip> pdkr_, no it isn't?
18:30:56 <pdkr_> base, uh, not base
18:30:59 <lingxiao> ok it doesnt look wrong and also not kosher, hence my reservation
18:31:04 <pdkr_> we move the decimal point
18:31:09 <mniip> right, so?
18:31:09 <pdkr_> for no reason whatsoever
18:31:19 <mniip> lingxiao, I would instantly understand what you're doing
18:31:21 <pdkr_> all we want to do is clear a few bits in memory. that should not require such algebra.
18:31:24 <ReinH> of course we're arguing about this, it's #haskell
18:31:26 <mniip> pdkr_, no?
18:31:30 <Cale> You can't typically multiply or divide by 100 by changing the exponent of a Float because floating point values are usually stored in binary and not decimal.
18:31:52 <Cale> You can multiply or divide by some power of 2 like that
18:31:52 <mniip> pdkr_, floating point numbers aren't decimal
18:31:53 <pdkr_> Cale: true
18:32:02 <lingxiao> mniip haha not always the number one criteria for good code in haskell 
18:32:07 <hackrilege> read . take n . show
18:32:12 <Cale> > decodeFloat pi
18:32:14 <lambdabot>  (7074237752028440,-51)
18:32:18 <ReinH> lingxiao: don't mind us, just use round (x * 100) / 100
18:32:21 <lingxiao> but yes good enough for me
18:32:25 <mniip> I was about to
18:32:25 <lingxiao> ok great I'll do that
18:32:29 <mniip> > decodeFloat 1.2345
18:32:30 <lambdabot>  (5559693739988877,-52)
18:32:31 <mniip> > decodeFloat 1.23
18:32:33 <lambdabot>  (5539427541665710,-52)
18:32:40 <mniip> there's not an obvious relation between these numbers
18:32:57 <pdkr_> mniip: that doesn't mean there isn't one
18:33:00 <hackrilege> The read show way is closest to what you really want from it's motivation
18:33:03 <mniip> sure there is
18:33:03 <ReinH> :t (**)
18:33:05 <lambdabot> Floating a => a -> a -> a
18:33:22 <mniip> but its easiest description is "round (x * 100) / 100"
18:33:30 <pdkr_> anyway, i think everyone here already understands all the pluses and minuses of *100 /100
18:33:31 <sm> import Data.Decimal.. let x' = realFracToDecimal 2 x
18:33:39 <mniip> the other one involves knowing what 0.01 looks like in binary
18:33:49 <pdkr_> mniip: i agree with both those statements
18:34:01 <pdkr_> but "easiest description" is not always right
18:34:02 <hackrilege> Lots of nested of greater than ...5 e.t.c.
18:34:04 <ReinH> because bikeshedding is what we do: roundTo exp n = round (n * 10 ** exp) / 10 ** exp
18:34:26 <mniip> pdkr_, in haskell we tend to prefer simple stuff
18:34:28 <pdkr_> you wouldn't add a list of floats using a fold
18:34:36 <mniip> over manual bittwiddling
18:34:40 <pdkr_> sure, it's easy to read, but it's not right
18:34:52 <mniip> > sum [1, 2.1, 3.5]
18:34:53 <lambdabot>  6.6
18:34:54 <ReinH> what are we even arguing about?
18:35:03 <pdkr_> mniip: yeah, now try that for a thousand small numbers
18:35:27 <ReinH> something irrelevant about floating point error, I take it?
18:35:38 <pdkr_> floating point errors are not irrelevant
18:35:38 <mniip> I assume
18:35:45 <Hijiri> > 7074237752028440 / 2^51
18:35:46 <ReinH> they often are
18:35:47 <lambdabot>  3.141592653589793
18:36:14 <pdkr_> ReinH: often, yes. but not always
18:36:15 <hackrilege> head $ dropWhile <x [0,0.01..
18:36:17 <mniip> how are floating point errors related to a simple rounding
18:36:33 <pdkr_> so even if this is probably the right solution for this rounding question, it is worth at least mentioning the point that they are not ideal
18:36:39 <pdkr_> in this sense
18:36:43 <ReinH> mniip: multiplying and dividing by 100.0 introduces floating point error
18:36:49 * ReinH shrugs
18:36:54 <mniip> you're rounding inbetween
18:37:21 <hackrilege> You could take the floor and count up in increments until greater than the desired number
18:37:25 <ReinH> mniip: you aren't listening... someone is using floating points and so someone else *must* add a caveat about floating point error. Did you not read the terms of service?
18:37:31 <mniip> the worst error you will get is 1) it will round in the wrong direction if you're 2^-52 from 0.5
18:37:40 <mniip> 2) your result will be off by 2^-52
18:37:45 <ReinH> It clearly states: if someone uses floating point arithmetic, you are honor bound to mention that they are doing it wrong
18:37:59 <pdkr_> ReinH: yes, that is my point exactly. because these kinds of bugs are the reason that floating point is dangerous and should be treated with care.
18:38:10 <zachk> but yea if your result is only off 2^(-52) it coudl now be off almost 0.5 
18:38:44 <pdkr_> if someone asks "what is the right way to round a float", and they specifically mention for a better solution than *100 /100, then you should mention this fact
18:38:46 <mniip> zachk, I meant 0.4999999999999999999999999 might be rounded upwards
18:38:47 <ReinH> I mean, let's ignore that they are already throwing away more information than can possibly be contained in the floating point error
18:38:50 <ReinH> and so it is literally irrelevant
18:39:18 <ReinH> I realize that you are just doing your job by mentioning it anyway
18:39:19 <hackrilege> Find the fractional representation, choose smaller numbers that are close to the same but will divide one another correctly to get the correct significant figures
18:39:28 <mniip> zachk, there is not an error on the scale of 0.5 because 0.500000000000000000000000000000 would be rounded upwards and that's just 2^-52 away
18:39:29 <pdkr_> ReinH: no, it is still not irrelevant. this "simple" rounding might produce something that *is not rounded*!
18:39:49 <pdkr_> and yes there are people who care about this
18:40:01 <mniip> pdkr_, 2.8 can never be rounded
18:40:03 <pdkr_> so it is worth discussing, especially given the fact that lingxiao asked for a better method
18:40:18 <mniip> pdkr_, in the given context there is no better method
18:40:20 <pdkr_> mniip: no it can't. but this method might introduce more error than you need to.
18:40:25 <pdkr_> the context wasn't given!
18:40:33 <mniip> not any more than 2^-52
18:40:41 <mniip> which is literally the smallest error there is
18:40:42 <ReinH> Can we all agree that (1) everyone is wrong (2) this is boring now and move on?
18:41:08 <pdkr_> ReinH: since, you asked, no, i do not agree with (2). (1) might be right.
18:41:08 <lingxiao> :O
18:41:14 <ReinH> pdkr_: :)
18:41:32 <ReinH> pdkr_: (1) is always right as a first approximation ;)
18:41:37 <pdkr_> :)
18:41:53 <zachk> has anyone ever had any luck using Data.Vinyl, I can't even get the basics working, the (:::) doesn't seem to be in scope in the newest version of the module
18:42:10 <ReinH> zachk: that seems...  unlikely... can you show us code?
18:42:37 <hackrilege> One over the smallest division add the denominator
18:42:56 <hackrilege> As
18:43:07 <hackrilege> Boom
18:43:17 <zachk> codesoup: in ghci: let r = fixRecord $ (Field :: "x" ::: a) =: (3::Double) <+> (Field :: "y" ::: a) =: (2::Int) 
18:43:22 <pdkr_> lingxiao: i suppose the better *pure* method (not so much "fastest") would be to use decodeFloat, round the integer in the left component, and then encode the float again
18:43:25 <zachk> oops meant code not codesoup
18:43:52 <zachk> or just anything, is there an up to date simple tutorial for Data.Vinyl?
18:43:56 <lingxiao> pdkr_ also found this bit, not too clean either:
18:43:56 <lingxiao> truncate' x n = (fromIntegral (floor (x * t))) / t where t = 10^n
18:44:01 <pdkr_> lingxiao: (though your rounding of the left component will depend on the exponent in the right component)
18:44:12 <lingxiao> pkdr_ ok I'll take a look at that
18:44:12 <ReinH> pdkr_: clearly the best method is to show it, split on ".", truncate the snd member, join, and read ;)
18:44:30 <pdkr_> ReinH: ah but that only gives you decimal roundings :)
18:44:33 <hackrilege> I think it's more or less arithmetic on the fractional representation
18:44:51 <lingxiao> truncate' looks morally similar to the other "dirty" way
18:45:07 <ReinH> truncate is the dirty way
18:45:09 <pdkr_> it is the same thing
18:45:14 <ReinH> and it's still almost certainly fine
18:45:15 <lingxiao> ReinH hahha I saw that on SO too
18:45:41 <lingxiao> could someone explain to me the difference between an integral and a num?
18:45:47 <lingxiao> :t fromIntegral
18:45:48 <lambdabot> (Integral a, Num b) => a -> b
18:45:56 <pdkr_> lingxiao: for a fast and correct method, i think you'll want to play with the bits directly. ask the #c guys what they do.
18:46:01 <ReinH> Integral is a typeclass representing things that are integral, Num is a typeclass representing things that are numbers
18:46:06 <ReinH> not all numbers are integral
18:46:14 <lingxiao> ReinH could you expand?
18:46:18 <sm> realFracToDecimal 2, people!
18:46:22 <lingxiao> or err i could jus look it up
18:46:35 <pdkr_> lingxiao: Float and Double are not integral
18:46:39 <ReinH> instances of Integral are things like Int, Integer
18:46:42 <zachk> whole number types 
18:46:47 <ReinH> instances of Num are things like Int, Integer, but also Float, Double
18:46:54 <mniip> pdkr_, there is no method more correct than the suggested one
18:47:00 <zachk> Num could be whole numbers, floats, doubles, decimals, complex, rationals etc...
18:47:24 <ReinH> :t 1
18:47:26 <lambdabot> Num a => a
18:47:27 <ReinH> :t 1.0
18:47:28 <pdkr_> mniip: i don't know how you can say that, but it also seems i am not able to convince you otherwise, so let's agree to disagree
18:47:28 <lambdabot> Fractional a => a
18:47:45 <ReinH> numeric literals in Haskell are polymorphic, which is both very useful and often confusing
18:47:57 <mniip> pdkr_, I believe in evidence :)
18:48:12 <zachk> you can do stuff like (5::Float) to force it though 
18:48:18 <pdkr_> mniip: well i appreciate that but i won't waste my time constructing particular numbers for which you can see the difference
18:48:24 <ReinH> pdkr_: I wonder how much time could be saved by offering to agree to disagree at the start of most such arguments ;)
18:48:25 <pdkr_> you'd have to pay me for that
18:48:42 <pdkr_> ReinH: well we could save a lot of time by closing this channel
18:48:52 <ReinH> well that is extremely true
18:48:55 <pdkr_> but i convinced at least some of you that floats are dangerous, and such simple solutions are not always ideal
18:49:06 <pdkr_> and on top of that i gave lingxiao a pointer that he/she might be able to use
18:49:10 <pdkr_> so i don't consider this wasted effort
18:49:10 <ReinH> I would wager that some of us already know that floats are dangerous :)
18:49:14 <lingxiao> he*
18:49:18 <pdkr_> he :)
18:49:32 <pdkr_> ReinH: well mniip and i still seem to disagree :)
18:49:44 <ReinH> not, I think, about the dangerousness of floats
18:49:50 <ReinH> but I don't want to prolong this
18:49:55 <pdkr_> no i agree with that
18:50:02 <mniip> floats are dangerous sure
18:50:08 <ReinH> ok we all agree great
18:50:10 <ReinH> :D
18:50:21 <ReinH> consensus achieved
18:50:23 <mniip> none of this is related to the original question though
18:50:35 <ReinH> mniip: hahaha you must be new here if you think that's surprising... ;)
18:50:38 <mniip> again I don't see why was this even started
18:50:55 <ReinH> (ofc I know you're not new here, but this is #haskell's way)
18:50:56 <lingxiao> thanks everyone for participating though :D
18:51:02 <lingxiao> I learned a lot in a short time
18:51:03 <drbean> Using 'cabal sandbox' I am warned: "cabal: The following packages are likely to be broken by the reinstalls:", and lists system packages installed by my dist
18:51:05 <drbean> Can I go ahead and force the install?
18:51:11 <ReinH> pdkr_: mission accomplished :)
18:51:26 <ReinH> drbean: only if you want to be sad
18:51:56 <drbean> Can't I reinstall them using the distribution package manager?
18:52:05 <ReinH> my suggestions, in decreasing order of goodness, are: (1) use stack (2) use a cabal sandbox (3) force the reinstalls and break everything
18:52:22 <drbean> I am using a cabal sandbox.
18:52:30 <ReinH> drbean: I would definitely not suggest using your linux distribution's package manager to manage haskell packages
18:52:35 <ReinH> unles that linux is nixos
18:52:38 <ReinH> *unless
18:52:49 <Cale> If you go with (3), I recommend asking Cabal to install as many of the packages in a single commandline as possible
18:52:51 <drbean> Fedora's dnf
18:53:17 <ReinH> Yeah, don't mix and match package managers
18:54:13 <Cale> Yeah, I never use any of my distribution's packages for Haskell stuff, they're usually way out of date, and even when they're not, it tends to be awkward.
18:54:22 <ReinH> drbean: here's the official ubuntu docs quoting me about a similar situation https://help.ubuntu.com/community/RubyOnRails#Intro_Ubuntu_8.04 :)
18:54:40 <Cale> Like, Debian splits the standard GHC distribution into a million tiny packages
18:54:54 <Cale> and doesn't really say which ones those are
18:55:03 <ReinH> Cale: they often patch things too
18:55:25 <Clint> Cale: what do you mean?
18:55:36 <Cale> All the libghc-* packages
18:55:36 <ReinH> drbean: I would recommend switching to Stack. It pretty much makes cabal hell obsolete.
18:55:59 <Clint> Cale: what's in the standard ghc distribution but split out?
18:57:06 <Cale> Clint: I don't remember which packages it was, but at least last time I tried it, several of the libraries which usually come with ghc when you install it from the generic linux binary package were split off into libghc-foo packages
18:57:54 <Cale> Admittedly, it's possible that things have changed since I last had a close look at it
18:58:01 <Clint> Cale: i'm curious as to which those are
18:58:18 <drbean> OK. I leapfrog over sandboxes and learn stack.
18:59:17 <hackrilege> So I fell into a tap earlier, I asked about comparing computations which is inhibited by template Haskell, but that it's also the way we generate code automatically, can someone elaborate on these points?
19:00:15 <ReinH> drbean: "learn stack" most likely means stack init && stack build, for starters
19:00:36 <hackrilege> How can we generate code with template Haskell and how does it inhibit program ordering?
19:01:10 <pdkr_> hackrilege: you are asking for a basic course in theoretical computer science
19:01:11 <drbean> Some time ago, monochrom recommended: "Designate two points of time A,B such that: before A, obtain from the distro exclusively; between A and B, cabal install --global exclusively; after B, cabal install --user exclusively. Never interleave the three."
19:01:44 <ReinH> drbean: I say ignore the distro entirely unless it can install Stack
19:01:54 <ReinH> then let Stack manage your GHC binaries and your projects
19:01:57 <ReinH> and, indeed, itself
19:02:11 <hackrilege> pdkr_ no I'm ok at Haskell just not familiar with template Haskell
19:02:12 <ReinH> the distro package manager will almost certainly not be useful
19:02:53 <ReinH> drbean: Stack will install GHC for you with stack setup, and this way you can use multiple GHCs easily as well
19:03:09 <pdkr_> hackrilege: no i was wrong actually. programs can be ordered, alright
19:03:19 <pdkr_> hackrilege: e.g. lexically as was suggested before
19:03:24 <pdkr_> just not listed
19:03:28 <hackrilege> Oh, but why suspect they couldn't?
19:03:32 <drbean> Fedira does not appear to have packageed stack.
19:03:36 <hackrilege> And why not listed?
19:04:24 <pdkr_> hackrilege: you can't list all haskell programs because of halting problem reasons
19:04:49 <hackrilege> What is this halting problem reasons?
19:05:03 <pdkr_> see. you're asking for a basic course in theoretical computer science.
19:05:12 <hackrilege> Anyone?
19:05:26 <bitemyapp> hackrilege: ?
19:05:44 <hackrilege> Template Haskell removes program termination proofs, how?
19:05:51 <pdkr_> now, haskell without language extensions, that might be possible
19:05:59 <pdkr_> i'm not sure, but it might be possible
19:06:02 <ReinH> hackrilege: where are you getting this from?
19:06:08 <hackrilege> No no no
19:06:12 <mgsloan> Sure you can list all haskell programs
19:06:34 <mgsloan> (but the list is infinite)
19:06:41 <pdkr_> mgsloan: not using an algorithm
19:06:49 <ReinH> sure you can
19:06:54 <pdkr_> TH?
19:07:01 <ReinH> enumerate all possible files
19:07:06 <ReinH> some of them will be haskell programs
19:07:15 <pdkr_> ReinH: yes. but now you need to check if they compile
19:07:23 <ReinH> yes, an algorithm can do that
19:07:25 <geekosaur> you can enumerate all Haskell programs. you cannot enumerate all Haskell programs *that provably terminate*.
19:07:25 <pdkr_> which is undecidable if you allow language extensions, in particular TH
19:07:28 <hackrilege> (pdkr) hackrilege: because TH makes it undecidable if a program is valid haskell
19:07:36 <ReinH> pdkr_: no, it isn't
19:07:40 <ReinH> if it compiles, it is a haskell program
19:07:41 <mgsloan> Ok, well, TH's limitations doesn't have much to do with the halting problem or decidability
19:07:49 <pdkr_> ReinH: but "if it compiles" is semidecidable
19:07:52 <zachk> but you can enumerate a subset of those that terminate, correct? 
19:07:57 <pdkr_> i can write TH that loops forever
19:08:14 <ReinH> pdkr_: Ok, I see your point
19:08:35 <ReinH> zachk: how do you know if it terminates?
19:08:43 <ReinH> it could just be taking a very long time
19:08:46 <hackrilege> Infinite loops are cool, but that we can't detect then makes me suspect they may not be easy to order...
19:08:55 <zachk> only use functions that provably terminate 
19:08:56 <ReinH> hackrilege: what are you actually asking about?
19:08:59 <ReinH> I suspect it is not turing machines
19:09:17 * zachk might be totally wrong here, agda can do a subset of terminating programs though, provably 
19:09:24 <ReinH> zachk: that doesn't enumerate all haskell programs
19:09:35 <pdkr_> zachk: agda is not turing complete
19:09:44 <mgsloan> Ah yeah, that's fair.  Pragmatically you can just throw on the caveat "haskell programs which compile within a day"
19:09:46 <pdkr_> or without extensions, anyway. not sure what fancy stuff they have
19:09:58 <pdkr_> mgsloan: but that will miss a few
19:09:59 <hackrilege> Order all Haskell programmes using an ordered list of all point free operators and an ordered list of all recursion schemes
19:10:00 <mgsloan> (or likely a shorter amount of time)
19:10:08 <pdkr_> mgsloan: don't ask me to restructure my code, restructure your own code!
19:10:12 <ReinH> hackrilege: what are you talking about?
19:10:19 <ReinH> what is your actual question?
19:10:29 * mgsloan is pretty confused by this conversation
19:10:38 * mgsloan back to code
19:10:51 <bitemyapp> hackrilege: tf r u tlking abt
19:11:03 <bitemyapp> hackrilege: have you been hittin the sauce? Get some sleep mate :P
19:11:33 <hackrilege> Hey if they don't compile in a day they ate not close to the start of the list. We need to order then and generate then in ascending complexity, they should either terminate or be simple infinite loops
19:12:28 <hackrilege> Sauce!? How dare you, this is a professional account. Please
19:12:29 <ReinH> hackrilege: take a step back and explain what you are talking about please
19:12:43 <ReinH> if what compiles? What list? What order?
19:13:13 <hackrilege> (mgsloan) Ah yeah, that's fair.  Pragmatically you can just throw on the caveat "haskell programs which compile within a day"
19:13:53 <hackrilege> The order is to be determined, out is some measure of simplicity
19:14:03 <ReinH> ...
19:14:08 <ReinH> I have no idea what you are talking about
19:14:20 <ReinH> well, I have some idea, but not enough to engage in a coversation
19:14:23 <ReinH> what are you trying to find out?
19:14:27 <hackrilege> It, not out, sorry, I get bad typos if I rush
19:14:55 <hackrilege> (hackrilege) Order all Haskell programmes using an ordered list of all point free operators and an ordered list of all recursion schemes
19:15:16 <ReinH> why do you believe that this would be sufficient to enumerate all haskell programs?
19:15:18 <hackrilege> Order in terms of simplicity
19:15:27 <ReinH> It seems like it wouldn't on its face
19:15:44 <ReinH> There are haskell programs that use expressions other than point free operators and recursion schemes?
19:16:13 <hackrilege> Actually applying all functions to all other functions should suffice with the list of point free operations
19:16:18 <ReinH> ...
19:16:34 <ReinH> "should"? do you have any reason to believe this?
19:16:49 <hackrilege> Yes, it really should, think about it
19:16:55 <hackrilege> It's just syntax
19:17:01 <pdkr_> i'm pretty sure ReinH thought about it
19:17:02 <hackrilege> And combinations
19:17:09 <ReinH> I'm asking you to think about it
19:17:12 <hackrilege> Combinatorix
19:17:29 <hackrilege> What would you like to know?
19:17:31 <ReinH> "It really should" is not a convincing argument
19:17:41 <hackrilege> Oh that
19:17:51 <ReinH> Well, I have no idea why we're talking about enumerating haskell programs at all
19:18:06 <ReinH> since it's a thing that you can't do, either theoretically or practically
19:18:25 <ReinH> is this some sort of thought experiment? To what end?
19:19:12 <hackrilege> Basically my list of point free operators is such that applying them to each other should create all of them (group closed under composition) and represents all computations
19:19:23 <ReinH> ...
19:19:27 <ReinH> source?
19:19:37 <ReinH> or is "it really should, think about it" all I'm going to get?
19:19:59 <hackrilege> Anyway why can't th be queried for termination?
19:20:12 <pdkr_> hackrilege: ReinH is asking very reasonable questions
19:20:21 <ReinH> Are you actually asking why you can't determine whether a program terminates?
19:20:24 <pdkr_> this discussion, whatever you want it to lead to, doesn't make any sense without their answer
19:20:58 <hackrilege> All combinations of all syntax equates to all point free expressions, is this wrong?
19:21:50 <pdkr_> hackrilege: well what is "all syntax" and "all point-free expressions"?
19:22:18 <pdkr_> for some subsets of haskell, i suppose it could be right, for the same reason that the K and S combinators generate all lambda calculus, or something like that
19:22:19 <hackrilege> And yes I would also like an answer about why you can't tell if a th program terminates
19:22:37 <pdkr_> hackrilege: we can't for the same reason we can't tell if any program terminates
19:22:45 <hackrilege> Namely?
19:22:49 <pdkr_> halting problem
19:22:54 <hackrilege> Kk
19:22:54 * zachk guesses Template Haskell is Turing Complete 
19:22:59 <hackrilege> I'll Google it
19:23:14 <hackrilege> Sorry I forgot I already had its name
19:23:48 <hackrilege> So the whole template Haskell thing was a misnomer?
19:23:52 <pdkr_> no?
19:25:07 <hackrilege> Th termination is no different, uniformly unpredictable. I'm not sure why you brought template Haskell into it, which was kind of my question
19:25:44 <pdkr_> okay i'm done with this
19:25:45 <hackrilege> Bit it was also supposedly a means to automatic code generation so I wanted to hear about it
19:26:06 <hackrilege> Sorry
19:28:28 <hackrilege> (Welkin) hackrilege: how do i monad?
19:28:44 <hackrilege> I'm really confused about the responses I'm getting
19:30:01 <hackrilege> I thought automatic code generation with template Haskell sounded really cool, I am concerned about the halting problem
19:30:19 <ReinH> You are "concerned" about the halting problem?
19:30:20 <ReinH> why?
19:30:43 <geekosaur> Haskell is Turing complete. as such, so is Template Haskell. Both are therefore subject to the Halting Problem.
19:30:54 <bitemyapp> totality uber alles
19:31:07 <ReinH> automatic code generation with template haskell is pretty cool
19:31:16 <ReinH> it is no less cool for being subject to the halting problem
19:31:27 <ReinH> on some level, if it weren't subject to the halting problem, it might be less cool
19:31:39 <ReinH> because its capabilities would be restricted
19:32:07 <hackrilege> I'm concerned because of we can't even detect infinitely large programs, which I'm assuming those which don't halt are, then I suspect I may struggle to equate or order programmes
19:32:12 <geekosaur> Standard Haskell has totality restrictions on *typechecking* because the type language is itself evaluated at compile time. GHC relaxes those with extensions, so that the typechecker is *also* at least potentially Turing complete
19:32:37 * ReinH sighs
19:32:44 <ReinH> You shouldn't assume things
19:32:48 <ReinH> You should learn what the halting problem is
19:32:54 <ackthet> it will halt when the universe runs out of entropy :P
19:33:16 <pdkr_> relevant https://xkcd.com/1266/
19:33:26 <hackrilege> It's not that we can't tell if a program will terminate?
19:33:46 <geekosaur> termination is more complex than you seem to think
19:33:59 <geekosaur> an infinite loop is nonterminating and can be quite short
19:34:22 <hackrilege> Yeah and I can trek it won't terminate too
19:34:26 <hackrilege> Tell
19:34:44 <geekosaur> a program that takes input may potentially be nonterminating, if its input is nonterminating
19:35:12 <geekosaur> (web servers, for one example, but "main = interact id" also)
19:36:26 <hackrilege> Sure
19:36:42 <hackrilege> I don't get why I'm being told this though
19:36:58 <geekosaur> (there is at least one standard web server attack that takes advantage of that: "slowloris" opens a large number of nonterminating connections to try to run a web server out of resources)
19:37:02 <hackrilege> So, non terminating programmes..
19:38:20 <hackrilege> So I actually totally fail to see the relevance of the halting problem here
19:38:45 <geekosaur> those were simple examples. where it gets nasty is the complex examples. it turns out you cannot reliably 100% prove that a random program either will or will not terminate
19:38:58 <lpaste> geppettodivacin pasted “Profiling Compile Problems” at http://lpaste.net/146504
19:39:05 <geekosaur> many programs, uyes, but there will always be programs for which you cannot determine one way or the other
19:39:20 <geppettodivacin> I'm trying to run profiling on some code, but it's complaining that I don't have the profiling libraries for mtl.
19:39:31 <geekosaur> some examples of those are actually useful, cf. web servers
19:40:09 <ReinH> hackrilege: well, you're the one who seems to think it has some relevance to TH
19:40:14 <geppettodivacin> I installed ghc-7.10.3-prof from the Ubuntu hvr/ghc repo. Does that not have mtl?
19:40:16 <geekosaur> geppettodivacin, where did you install ghc from? the profiling libraries are often separate
19:40:22 <geekosaur> ah
19:40:30 <hackrilege> I was misinformed apparently
19:40:49 <hackrilege> But anyway it seems pretty relevant
19:40:53 <geekosaur> geppettodivacin, that looks like it is not ghc 7.10.3?
19:41:05 <hackrilege> How do we use th to generate code?
19:41:25 <geekosaur> ah, nemmind, i would be a prerelease
19:41:35 <geekosaur> it is possible that not all prof libs are being built for that
19:41:41 <ReinH> Why do you think it is relevant?
19:41:55 <ReinH> Specifically, why do you think it is more relevant to TH than to Haskell per se?
19:42:03 <hackrilege> Because I need a systematic code generator to populate my lists
19:42:26 <ReinH> what lists?
19:42:28 <geppettodivacin> geekosaur: That makes sense. Somehow I didn't realize 7.10.3 wasn't the current stable release.
19:42:51 <hackrilege> List of all Haskell programmes in order of simplicity
19:42:56 <ReinH> You can't do that
19:43:01 <hackrilege> ...
19:43:13 <hackrilege> Just because some may not terminate?
19:43:59 <pdkr_> it's not the programs that might not terminate
19:44:09 <hackrilege> I get to write my Ord instance, I can profile the hell out of them
19:44:12 <pdkr_> it's the compilation /of/ those programs that might not terminate
19:44:20 <hackrilege> Oh!
19:44:21 <pdkr_> iow you cannot check if a given file is a valid haskell program
19:44:33 <pdkr_> because you might end up waiting an eternity, even for very short files
19:45:02 <hackrilege> It's not compiling means it's not valid in my mind, and like I say they are too late in the list to care about probably
19:45:40 <hackrilege> Not simple, order by simplicity, detect, move on
19:46:16 <geekosaur> you hope
19:46:18 <ReinH> "detect"?
19:46:43 <hackrilege> Compile for time, abandon slow compiling files
19:46:45 <pdkr_> hackrilege: everything you claim to be able to do is actually provably impossible to do
19:46:51 <ReinH> Then you are not listing all haskell programs
19:47:01 <ReinH> No one is arguing that you can't list "some subset of haskell programs"
19:47:07 <ReinH>  I can: the empty list.
19:47:13 <hackrilege> They ate in order of simplicity, I'm just not ordering them yet
19:47:36 <hackrilege> Your motivating tinge to compile as a metric of simplicity
19:47:41 <hackrilege> Time
19:47:43 <Welkin> I wonder how many people are eating popcorn and enjoying this riveting drama unfold
19:47:58 <ReinH> You would be easier to understand if you spoke in complete sentences and didn't misspell so many words
19:48:10 <hackrilege> Sorry
19:48:20 <hackrilege> Bad infrastructure
19:48:21 <ReinH> I am not motivating any metric of complexity
19:48:31 <ReinH> I am just explaining that the task you have given yourself is impossible
19:49:15 <geekosaur> geppettodivacin, for what it's worth, I don't see mtl in the prof libraries package
19:49:24 <hackrilege> !? You're not doing a good job, it's seeming more clear infact
19:49:25 <geekosaur> you would have to ask hvr, I think
19:49:39 <ReinH> hackrilege: "make a list of all haskell programs" is impossible
19:49:43 <ReinH> regardless of how they are ordered
19:50:13 <hackrilege> Make a list of all Haskell programs ordered by compilation time is not impossible
19:50:23 <hackrilege> Though it is non terminating
19:50:25 <ReinH> I didn't say that some other problem is impossible
19:50:31 <ReinH> I said that the problem that is impossible is impossible
19:50:53 <hackrilege> +1
19:50:53 <ReinH> And no, that is impossible to
19:50:55 <pdkr_> ReinH: i see you are a supporter of linear logic
19:51:07 <hackrilege> nooo
19:51:21 <hackrilege> It's just slow
19:51:48 <hackrilege> Anyway I'm going to use it to make ai
19:52:04 <pdkr_> gl hf
19:52:32 <ReinH> While this foray into "what is the halting problem even" has been enjoyable, I don't really understand how it's relevant to anything
19:52:52 <hackrilege> Yeah I'm with you on that
19:53:08 <hackrilege> Sorry
19:53:28 <ReinH> You can certainly make a list of *some* haskell programs, and if you can define a metric for simplicity, you can make a list of some haskell programs by simplicity
19:53:31 <hackrilege> I prefer to try and keep it Haskell based
19:54:21 <ReinH> You seem to be under the misapprehension that because TH is turing complete, it is somehow dangerous or less useful
19:54:30 <hackrilege> I though template Haskell interfered with program rationalisation or something it sounded like people were saying, but I'm lost
19:54:39 <ReinH> I don't know what to say to that, other than that Haskell is also Turing complete, and it seems pretty useful to me despite this
19:54:50 <geppettodivacin> geekosaur: I checked back to 7.10.1 and haven't found the mtl prof package, either.
19:54:54 <pdkr_> hmm, i must say i'm starting to believe that this dovetailing of compiling all possible .hs files might indeed produce a list of all valid haskell programs...
19:55:10 <pdkr_> but it will definitely not follow any sensible order of simplicity
19:55:23 <ReinH> pdkr_: I think you just need a superturing machine :)
19:55:47 <pdkr_> well obviously none of this is practical. but theoretically?
19:56:30 <pdkr_> it is not decidable if a program is valid haskell. but we don't need that. we only need that the set of valid haskell programs is *semi*decidable
19:56:30 <hackrilege> There is a few easy simplicity metrics, length in characters of smallest equivalent, number of lambdas lifted a.t.c.
19:57:22 <pdkr_> but obviously that does not allow you to arbitrarily reorder this list
19:57:37 <hackrilege> So e.g. Can template Haskell help me truncate my code to canonical syntax?
19:57:39 <pdkr_> so hackrilege's magic solution to AI will still not work as planned
19:58:58 <hackrilege> Yeah it's fine quit the beef
20:00:00 <pdkr_> ok
21:10:35 <tippenei1> n
21:10:48 <tippenei1> stack runghc command stalls
21:13:17 <mgsloan> tippenein: That is because you didn't give it a haskell file, so it's expecting it on standard input
21:13:39 <mgsloan> Type in `main = print "hi"`, and then Ctrl + D
21:13:54 <mgsloan> Well, lowercase ctrl + d
21:16:28 <tippeneinn> Ah, I was getting some weird build errors, was thinking it was related
21:17:34 <lpaste> tippenein pasted “stack build error” at http://lpaste.net/146505
21:21:32 <tippeneinn> exit
21:26:18 <mgsloan> tippenein: Have you been deleting things from .stack/snapshots?
21:32:17 <Welkin> have you been stealing cookies from the cookie jar?
21:36:55 <tippenein> mgsloan: nope. I actually just changed the ghc version specified in stack.yaml and rebuilt
21:37:03 <tippenein> then it worked
21:37:12 <tippenein> stack clean didn't seem to do anything
21:37:30 <mgsloan> Yeah, "stack clean" doesn't affect the snapshot packages
21:37:59 <mgsloan> So if things get corrupted there somehow (really shouldn't happen, likely Cabal or ghc bugs..)
21:38:25 <mgsloan> Then they've gotta be cleared out.
21:39:11 <mgsloan> One gotcha is that the "copying precompiled package" thing means adding a reference from one snapshot's package DB to a package in a different snapshot (since all the deps line up)
21:39:48 <mgsloan> So you can't really reliably prune subfolders of ~/.stack/snapshots/ without breaking things
21:57:14 * hackagebot yesod-auth-oauth2 0.1.5 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.5 (PatrickBrisbin)
22:08:45 <tippenein> I think it has something to do with El Capitan, because there isn't much on this system which wasn't broken by it
22:08:49 <Reshi> Hi, I want to parse a haskell source module to collect type declarations, would using Language.Haskell.Parser suffice? It says it will parse a Haskell98 module, and the modules which already compile in Haskell2010 are throwing parse errors
22:09:47 <glguy> Reshi: https://hackage.haskell.org/package/haskell-src-exts is the normal go-to package for parsing Haskell
22:10:09 <glguy> Reshi: If your file has CPP, you'll need to process that away
22:10:37 <Reshi> glguy: I want to parse Haskell files, basically collect all data declarations
22:12:01 <Reshi> glguy: I am trying 'haskell-src' package, and it is throwing syntax errors parsing haskell files which I already successfully compile for other projects
22:13:17 <glguy> That's fine, the package I link to is a different package
22:13:26 <Reshi> glguy: 'haskell-src' says it parses haskell98 modules, is this the problem since I think I am using haskell2010?
22:14:18 <glguy> Could be
22:15:18 <arahael> tippenein: I'm using El Capitan, and while my haskell use is extremely minimal (think: "Hello World"), I've had absolutely zero issues using haskell, though I did install it using 'brew install haskell-stack'.
22:18:23 <mgsloan> tippenein: Likely has something to do with this https://github.com/commercialhaskell/stack/blob/042398098ef6d2d67ba9637c3141a3c1fd2f2c57/doc/faq.md#why-is-dyld_library_path-ignored
22:31:02 <Reshi> glguy: 'haskell-src-exts' can parse haskell2010! Thanks!
22:48:59 <lindenk> Hey, noob question: I'm trying to do a foldr with a Int -> Char -> Int on a [Char] starting with 0. The compiler is telling me it's expecting an Int -> Int -> Int instead. I'm not sure what I'm doing wrong
22:49:32 <jle`> lindenk: care to post the code?
22:49:40 <jle`> :)
22:50:18 <lindenk> http://lpaste.net/146506
22:50:57 <lindenk> sorry, I'm a bit new to haskell
22:51:14 <jle`> :t foldr
22:51:16 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:51:39 <jle`> i think you might have mixed the order of arguments up
22:51:56 <jle`> and thought it was a -> b -> a ?
22:52:03 <lindenk> ah, that makes sense
22:52:10 <lindenk> yeah, that's what I was thinking
22:52:21 <jle`> you probably want a Char -> Int -> Int
22:54:19 <lindenk> oh, also. can I specify a type that can only be '(' or ')'? `data Paren = '(' | ')'` doesn't seem to be the right syntax
22:56:21 <jle`> yeah, you can only use certain names for constructors
22:56:25 <glguy> You can't make a type out of existing data constructors
22:56:45 <jle`> data Paren = LeftParen | RightParen might work :)
22:58:12 <jle`> remember that ad
22:58:20 <lindenk> hmm, so would I need to create constructors for it too then, like  Paran '(' = LeftParen
22:58:27 <jle`> 'data' defines new types and type constructors
22:58:54 <glguy> LeftParan and RightParen are the new data constructors in jle`'s example
22:59:04 <jle`> yeah, or paren :: Char -> Maybe Paren
22:59:17 <jle`> in case someone tries to be a wisebutt and gives it a non paren
22:59:33 <jle`> we often call these "smart constructors"
22:59:48 <lindenk> ah, that makes sense. Thanks!
22:59:53 <glguy> "Paren '(' = LeftParen" wouldn't quite work because "Paren" is capitalized there
23:00:50 <lindenk> oh, I don't really know the standards for naming. so i should make type contructors lowercase?
23:01:31 <jle`> you are defining a normal 'function', and names of normal functions on data have to start with lowercase letters
23:01:34 <jle`> (or be operators)
23:01:36 <glguy> Constructors are upper-cased, but when you write "paren ')' = RightParen" you aren't defining a new constructor
23:01:48 <glguy> You're defining a new function named "paren"
23:01:55 <jle`> identifiers that begin with capital letters are reserved for constructors and types :)
23:02:07 <dmj> type constructors have to be upper case afaik
23:02:19 <c_wraith> jle`: and classes, if you don't count those as types...
23:02:55 <lindenk> oh, ok so the type contructor Paren should be upercase and the function to convert from char to it should be lowercase?
23:04:04 <dmj> lindenk: functions (not counting data constructors) have to start with a lower cased letter
23:04:19 <dmj> lowercase*
23:30:17 <testname> does anyone know how i would call C dll functions from my haskell program?
23:32:33 <dmj> @package inline-c
23:32:34 <lambdabot> http://hackage.haskell.org/package/inline-c
23:33:41 <lindenk> ok, one more question. how do I convert a [Maybe a] to Maybe [a]?
23:35:06 <pavonia> :t sequence
23:35:07 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
23:37:02 <lindenk> ah, perfect. thanks
23:37:46 <glguy> testname: You want to read about the Haskell FFI
23:38:09 <glguy> The inline-c package is cute but there are more direct ways to go
23:39:07 <dmj> glguy: c2hs?
23:39:37 <testname> glguy: ya, i was reading up about the FFI, but it seems to go over more about using c code given that you have the header and source code
23:39:37 <dmj> glguy: I like cute though
23:40:17 <glguy> testname: You don't have to have the source code, having headers helps if you want to import a library's structs
23:40:36 <glguy> but you don't need headers at all if the C functions you're importing only use primitive C types
23:45:26 <testname> glguy: so, for example, if i had foo.dll in the same folder as my bar.hs file, i would type "ghc --make bar.hs -lfoo.dll"?
23:49:46 <ProofTechnique> So I have a list [a -> Bool], and I want to get the result of applying each to the same a in a [Bool]. I know there's an obvious way to do this, and I can almost picture it, but ultimately I'm drawing a blank. Ideas?
23:50:28 <lpaste> glguy pasted “for testname” at http://lpaste.net/146508
23:50:44 <glguy> testname: There's a tiny example that might help
23:51:25 <glguy> It should be similar on Windows. I don't use Windows for anything other than Steam, though.
23:51:28 <dmj> :t \xs ys -> zipWith ($) (xs :: [a -> Bool]) (ys :: [Bool])
23:51:30 <lambdabot>     Couldn't match expected type ‘[a -> Bool]’ with actual type ‘r’
23:51:30 <lambdabot>       because type variable ‘a’ would escape its scope
23:51:30 <lambdabot>     This (rigid, skolem) type variable is bound by
23:51:45 <glguy> Bool -> a
23:52:35 <ProofTechnique> Ultimately, I guess what I'm after is something of the general shape of [a -> Bool] -> a -> [Bool], and for some reason it's just not occurring to me
23:52:47 <glguy> testname: I think that example counts for your using a library without headers or source because I didn't give the source to ghc
23:52:54 <mniip> I know at least 2 functions of that shape
23:52:58 <mniip> union and intersection
23:53:01 <testname> glguy: thanks, i'll check it out
23:53:03 <mniip> oh wiat
23:53:05 <mniip> that's a map
23:53:54 <dmj> :t \xs x -> map (x :: a) (xs :: [a -> Bool])
23:53:55 <lambdabot>     Couldn't match expected type ‘a’ with actual type ‘r1’
23:53:56 <lambdabot>       because type variable ‘a’ would escape its scope
23:53:56 <lambdabot>     This (rigid, skolem) type variable is bound by
23:54:02 <mniip> ProofTechnique, so you have a list and you want to do something with every element
23:54:06 <mniip> who do you call? map
23:57:46 <ProofTechnique> Aha. map with a $ section. I hadn't tried that, yet
23:58:03 <MarcelineVQ> :>
23:58:11 <jle`> ProofTechnique: map ($x) is what people usually do :)
23:58:23 <dmj> :t \(x :: a) (ys :: [a -> Bool]) -> map (const x) ys
23:58:25 <lambdabot> a -> [a -> Bool] -> [a]
23:58:29 <dmj> derp
23:58:32 <ProofTechnique> I knew there was something obvious staring me in the face :|
23:58:41 <jle`> you can also <*> pure x
23:58:56 <jle`> > [even, odd, (> 0)] <*> pure 2
23:58:58 <lambdabot>  [True,False,True]
23:59:05 <ProofTechnique> Oh, that's much nicer!
23:59:06 <jle`> people might look at you funny though
23:59:18 <ProofTechnique> I can't believe I didn't think of that
23:59:21 <jle`> > map ($ 2) [even, odd, (> 0)]
23:59:24 <lambdabot>  [True,False,True]
23:59:35 <jle`> i'd say that the map version is the more instantly readable one.  just an opinion though :)
23:59:38 <ProofTechnique> It's late. 🙈 Hahaha
