00:02:45 * hackagebot open-typerep 0.5 - Open type representations and dynamic types  https://hackage.haskell.org/package/open-typerep-0.5 (EmilAxelsson)
00:07:41 * hackagebot farmhash 0.1.0.4 - Fast hash functions.  https://hackage.haskell.org/package/farmhash-0.1.0.4 (abhinav)
00:07:41 * hackagebot open-typerep 0.5 - Open type representations and dynamic types  https://hackage.haskell.org/package/open-typerep-0.5 (EmilAxelsson)
00:12:36 * hackagebot pinch 0.1.0.2 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.1.0.2 (abhinav)
00:18:17 <shanemikel> Hey everybody. happy holidays.. I've just read https://wiki.haskell.org/Show_instance_for_functions, however it hasn't answered one question, is there a [implemented] way to instantiante Show for functions (Printing their types only, not that bit about expression representation)
00:18:30 <shanemikel> ( .. or names)
00:18:56 <shanemikel> an SO answer mentions Typeable..
00:19:38 <jle`> yeah, lambdabot has one
00:20:30 <shanemikel> how would I use that? 
00:20:45 <jle`> you can write a show for functions like: showFunc :: forall a b. (Typeable a, Typeable b) => (a -> b) -> String where showFunc _ = show (typeOf (undefined :: a)) ++ " -> " ++ show (typeOf (undefined :: b))
00:22:04 <jle`> oh
00:22:09 <jle`> huh wait there's an easier way
00:22:15 <wedens> or just `show . typeOf $ f
00:22:17 <wedens> `
00:22:25 <jle`> showFunc f = show (typeOf f)
00:22:27 <jle`> yeah, heh
00:22:58 <jle`> instance (Typeable a, Typeable b) => Show (a -> b) where show f = show (typeOf f)
00:23:02 <wedens> > show . typeOf $ (\(x :: String) -> 1 :: Int)
00:23:02 <jle`> plus whatever decorations you want
00:23:04 <lambdabot>  "[Char] -> Int"
00:23:13 <jle`> lambdabot's instance wraps things in <>
00:23:29 <jle`> > (\(x::String) -> 1 :: Int)
00:23:31 <lambdabot>  <[Char] -> Int>
00:27:37 <shanemikel> sweet
00:27:47 <shanemikel> that's a cool trick you used with bottom though
00:29:23 <jle`> it's a bit of a hack, heh; it's how you're supposed to use typeOf if you don't have a value
00:29:44 <jle`> if Typeable was implemented in modern times it'd take a `p a` instead, like typeOf (Proxy :: Proxy a)
00:29:55 <pikajude> is there any sensible way to pair a datatype with a ?loc :: CallStack so that whenever you use one of the constructors, you also get the CallStack?
00:30:18 <wedens> yeah, I was about to ask isn't it possible with Proxy ;)
00:30:49 <jle`> yeah, those were the days...
00:31:01 <jle`> i hear in GHC 8.0 we're getting a nice new syntax to reference types at the value level
00:31:14 <jle`> so we can use @Int instead of (Proxy :: Proxy Int) or something
00:31:22 <wedens> that'd be nice
00:31:46 <jle`> s/use/ask for
00:32:56 <shanemikel> that's interesting, `show . typeOf` in ghci is specializing the Num methods to their defaults.. I'm guessing this won't play friendly with unconstrained types
00:33:14 <jle`> you guess correctly
00:33:22 <jle`> > read
00:33:24 <lambdabot>      No instance for (Typeable a0)
00:33:26 <lambdabot>        arising from a use of ‘show_M522918983895273021820394’
00:33:28 <lambdabot>      In the expression:
00:33:51 <jle`> ? od
00:33:52 <shanemikel> I'd really like to get the behavior of the :t command the repl's got
00:33:53 <jle`> > id
00:33:55 <lambdabot>      No instance for (Typeable a0)
00:33:55 <lambdabot>        arising from a use of ‘show_M185421015606390809420427’
00:33:56 <lambdabot>      In the expression:
00:34:17 <shanemikel> and the compiler, where it makes up type variables as needed
00:34:44 <jle`> it's because when you do something like show id, you're not showing a (a -> a)
00:35:00 <jle`> it has to be specialized to a specific type
00:35:46 <jle`> when you write `show id`, you aren't showing the (forall a. a -> a), you're showing a specific instantiation of (a -> a)
00:35:52 <jle`> but ghci/ghc can't figure otu which one you want
00:36:01 <jle`> note that the error above is different from:
00:36:05 <jle`> > show (id :: forall a. a -> a)
00:36:07 <lambdabot>      No instance for (Typeable a0) arising from a use of ‘show’
00:36:07 <lambdabot>      In the expression: show (id :: forall a. a -> a)
00:36:40 <jle`> hm i guess they're the same error, nvm v.v
00:37:29 <nshepperd> > show ((id :: forall a. a -> a) :: Int -> Int)
00:37:31 <lambdabot>  "<Int -> Int>"
00:37:35 <shanemikel> by instantiation are you getting into object territory, or are you still talking about typeclasses?
00:38:12 <jle`> i'm talking about specializing the type signature
00:38:28 <jle`> you don't pass (id :: forall a. a -> a) into show when you do `show id`, you pass id with a specific choice of `a`
00:38:39 <jle`> show (id :: Int -> Int), or show (id :: Bool -> Bool)
00:38:43 <nshepperd> show can't accept a polymorphic input value, so something has to be plugged into each forall'd variable in the input
00:39:14 <jle`> so, without specifying what you want to specialize `a` to be, haskell can't handle
00:39:47 <shanemikel> is there a way to get the behavior of `:t`, perhaps not using Typeable, but whatever ghci is using to implement that function?
00:39:56 <jle`> i guess the word i should be using is "monomorphic"
00:40:11 <jle`> you pass show a monomorphic value, so it doesn't know what monomorphic instantiation of (a -> a) to use
00:40:17 <pikajude> shanemikel: you'll have to use the GHC API for that
00:40:25 <jle`> i believe that you can't implement `:t` in Haskell
00:40:35 <nshepperd> shanemikel: you'd have to use template haskell, I think
00:41:08 <shanemikel> jle`: you should add some of that to the wiki page
00:41:17 <pikajude> jle`: you can with hint!
00:41:24 <pikajude> or with the "ghc" library!
00:41:33 <jle`> :O
00:41:50 <nshepperd> $(pshow expr) for some appropriate definition of pshow, probably...
00:43:28 <tpsinnem> with the recent dependently-typed developments in GHC, can type membership judgmengs involve computation of indices appearing in a type?
00:43:50 <tpsinnem> s/judgmengs/judgments
00:46:53 <shanemikel> so I can follow the answers to this fascinating question, you mean like enumeration qualification? i.e. 'a'-'z' char member of letter
00:47:05 <shanemikel> ord whatever - whatever
00:47:37 * hackagebot regex-applicative 0.3.3 - Regex-based parsing with applicative interface  https://hackage.haskell.org/package/regex-applicative-0.3.3 (RomanCheplyaka)
00:47:45 <pikajude> i guess i don't understand implicit params very well. changing my type signatures changes how many stack frames I get
00:47:51 <pikajude> not a fan of that feature
00:52:08 * nshepperd wouldn't use implicit params
00:56:28 <pikajude> it's, in my opinion, better than using qLocation via template haskell
01:07:35 <drewbert> Say I have an (a -> m b) and a (b -> m c) and I want an (a -> b -> m c)
01:08:51 <bollu> guys, I'm using Turtle to write a command line tool
01:08:56 <bollu> I need to parse command line options
01:09:12 <bollu> to I go full blown haskell-parser or is there a nice library to deal with this for me?
01:09:49 <jle`> i'm not sure if turtle has built in command line option handlers or not, i feel like it might
01:09:54 <jle`> but if not, you can use optparse-applicative
01:10:11 <jle`> which is the standard command line options parser used around these parts
01:10:17 <bollu> jle`: nope, it didn't. Cool, optparse-applicative looks nice :
01:10:30 <jle`> yeah, it also auto-generates documentation too with --help and stuff
01:10:35 <jle`> there should be some good examples floating around
01:11:24 <wedens> bollu: https://hackage.haskell.org/package/turtle-1.2.4/docs/Turtle-Options.html
01:11:50 <wedens> (it uses optparse-applicative)
01:14:01 <shanemikel> \f g -> \x -> f x >>= g
01:14:03 <shanemikel> ?
01:14:41 <shanemikel> if I'm right about that I'll be really happy
01:14:49 <jle`> drewbert: did you have a question about that?
01:16:14 <jle`> shanemikel: close; \x _ -> f x >>= g would type check, but i'm not sure what the original intent is
01:17:06 <shanemikel> <=<
01:17:14 <shanemikel> actually is the operator for monad composition
01:17:32 <jle`> monad composition would get you (a -> m c), but an (a -> b -> m c) is desired, for some reason?
01:20:45 <shanemikel> oh yeah, that doesn't make sense.. I caught that finally
01:20:55 <shanemikel> thanks again jle`
01:22:08 <shanemikel> what are you doing with the result of (a -> mb) ?
01:23:00 <jle`> i don't even know, it's unclear what is desired, heh
01:37:02 <Skuzzzy> Its fortunate that no real companies use haskell because I dont understand it
01:37:23 <jle`> if you don't count facebook as a real company, then sure :)
01:39:11 <drewbert> Okay, so I have f1 of type (a -> b -> m c) and f2 of type (c -> d -> m e), an (a -> b -> c -> d -> m e) is desired.  I could do (\a b d -> f1 a b >>= (\c -> f2 c d)). Is there a more elegant way to represent that?
01:40:15 <mniip> @pl \a b d -> f1 a b >>= (\c -> f2 c d)
01:40:15 <lambdabot> flip flip (flip f2) . (((.) . (>>=)) .) . f1
01:40:20 <mniip> probably not
01:40:33 <jle`> you can do \x y z a -> g z a =<< f x y
01:40:36 <drewbert> lol mniip, that's some insanity
01:40:42 <jle`> oh wait, misread
01:40:53 <jle`> the nicest way to do this would probably be with do notation
01:41:13 <jle`> flip f2 d =<< f1 a b, maybe
01:41:14 <drewbert> yeah, was thinking it's going to have to be a multi-liner
01:41:56 <jle`> flip f2 d =<< f1 a b or (`f2` d) =<< f1 a b might not be too bad
01:42:35 <jle`> but do notation might be the cleanest way
01:43:11 <phadej> http://hackage.haskell.org/package/composition-extra-2.0.0/docs/Control-Monad-Syntax-Two.html :P
01:43:55 <jle`> a good way to make anyone reading your code take a good 2 minutes longer to understand it :p
01:44:32 <shanemikel> drewbert: are you sure you're not looking for an \a b d -> m e ?
01:45:08 <drewbert> shanemikel: you are correct, that's what I'm looking for
01:45:38 <jle`> drewbert: also, it's probably unlikely that you are asking about writing these questions polymorphically, using specific types for `m`, etc. might yield nicer ways of putting things :)
01:46:35 <shanemikel> Skuzzzy: microsoft also has been a frontrunner in recent haskell research, also
01:46:36 <jle`> if the monadic approach is indeed the best, it'll come up anyways
01:47:57 <Skuzzzy> I was shitposting
01:48:11 <Skuzzzy> but also, haskell isnt popular enough where I have to learn in
01:48:13 <Skuzzzy> it*
01:48:24 <Skuzzzy> there are a lot of other tech that has priority over it for me
01:48:26 <shanemikel> yeah, it does sound like trolling
01:48:51 <shanemikel> though I hate to be reduced to using that internet forum lingo
01:49:11 <jle`> Skuzzzy: sure, that's definitely fair
01:49:23 <Skuzzzy> Its cool, and I will def eventually pick it up though
01:49:33 <Skuzzzy> So much fun compiler work references haskell, so I kinda need to
01:49:35 <drewbert> Okay, so I have a Store.  I have a function which yields a store in a monad (String -> EitherT String IO Store).  I have a set of functions which take a variable number of parameters, the first of which is always a store. e.g. (Store -> String -> EitherT String IO [String]) (String -> Maybe String -> String -> EitherT String IO Int) etc... I want a way to get that store and pass it off to those many functions.
01:49:50 <jle`> yeah, compilers is definitely a haskell "killer app"
01:50:00 <Skuzzzy> Unfortunately I can't find anyone to pay me to do compiler stuff
01:50:08 <Skuzzzy> So I gotta sell my soul
01:50:18 <jle`> real world ;_;
01:51:14 <shanemikel> if you change the first fortunate to unfortunate Skuzzzy, it really changes the tone of your conversation
01:51:36 <jle`> drewbert: do you mean you want to partially apply all those functions with the `Store` you got?
01:51:40 <jle`> to get a bunch of partially applied functions?
01:51:54 <drewbert> yes
01:52:11 <jle`> and what are you going to do with those bunches of partially applied functions?
01:53:12 <jle`> i feel like, when you eventually do intend to use/fully apply them, you can always just use the store that you bound...
01:53:16 <drewbert> they get composed into some magic I don't quite understand yet.  They get unioned with the (:<|>) of servant
01:53:56 <jle`> any reason why you can't just bind theStore <- f theStr
01:54:06 <jle`> and then use `f theStore`, `g theStore`, etc., when you eventually use f, g, etc.?
01:55:12 <jle`> if you rearrange your functions a but, you can also apply them all to something using sequence, sequence [f stuff stuff, g stuff stuff, h stuff stuff] store
01:55:18 <jle`> but it does depend on what you eventually want to do with the stores
01:55:25 <jle`> er, the functions
01:56:13 <shanemikel> working on a plugin of sorts?
01:57:00 <shanemikel> or 'config' 
01:57:07 <jle`> you can also use ReaderT if you want to abstract over passing `theStore` as a parameter to all your functions...but whether or not it's useful will depend on the bigger picture
01:59:34 <drewbert> The store is specified at the request level.  The logic for getting the store is always the same.  I need the store many times.  I'd like the code around it to be minimal.
02:01:56 <shanemikel> could 'the store' be a data store? if so, what kind? data endpoint/api, db, brick and mortar?
02:02:51 <shanemikel> http?
02:03:31 <drewbert> A hash table from a string to an abstraction over a database connection.
02:04:21 <drewbert> For all intents and purposes, we could say the string is the table name. 
02:04:35 <drewbert> each string selects a different table
02:05:06 <shanemikel> proprietary or hackage?
02:05:09 <drewbert> It's always the first query parameter.
02:05:22 <drewbert> Very proprietary.
02:05:49 <shanemikel> so it looks like you're trying to get comfortable with monad composition
02:06:39 <jle`> drewbert: it's still a bit too abstract for me to try to get a hold on what you're doing/why you need things a certain way
02:06:54 <jle`> do you already have a way implemented of writing it in long-form?
02:07:44 <shanemikel> you should check out if there's a way to get ahold of example usage of the lib from your employer / driver provider
02:08:12 <shanemikel> totally reasonable request
02:08:29 <drewbert> Correct. If the functions all had 1 parameter, I could handle this, but the poly(morphism|varadism) is killing me.
02:08:59 <drewbert> jle`: I don't have a generalized long form way. I can craft a way for each funciton.
02:09:21 <jle`> that's what i meant
02:09:28 <jle`> do you have a longform way with specific functions?
02:09:46 <drewbert> yeah
02:10:02 <drewbert> for each funciton type signature, I have a way.
02:10:13 <drewbert> shanemikel: Most of our code is scala.  The haskell is a pioneering effor.
02:10:27 <drewbert> effort*
02:10:52 <shanemikel> now it's starting to make sense
02:10:55 <jle`> if you are willing to rearrange your functions so that the Store is the final parameter, you can use ReaderT, or even just sequence
02:11:20 <jle`> but it's hard for me to understand why you need access to the partially applied functions, when you can just apply them fully when you have all of the parameters you need
02:11:25 <drewbert> Before I had the table name specified via the command line using optparse-applicative, and each instance could only ever connect to one table.
02:11:48 <drewbert> I'm trying to modify the system to dynamically connect to tables based on the query string.
02:12:07 <jle`> yeah, and the way you'd do that in haskell is by passing the table as a function argument, normally
02:12:24 <drewbert> jle`: I will rearrange all of the functions.  That sounds like the most reasonable option at this point.
02:12:57 <jle`> ReaderT is usually of minimal help and it just saves you manually passing in the store as an explicit argument
02:13:00 <shanemikel> flip is your friend
02:13:01 <jle`> it becomes an implicit argument of sorts
02:13:54 <shanemikel> why don't you talk with whomever wrote the interface?
02:14:18 <shanemikel> or hack it yourself
02:14:22 <jle`> if you convert your Store -> String -> m [String] to a String -> ReaderT Store m [String], then your function is now a function that takes a String and returns a [String] that has a Store accessbile in its environment
02:15:10 <drewbert> I wrote most of it.  A coworker wrote most of the back end.  I can rearrange whatever I want.  I was just hoping there was an elegant way that didn't involve changing the type signature of every function in the library after I already changed 'em all once.
02:15:16 <jle`> they're the same thing, but they have a convenient Functor/Applicative/Monad instance
02:15:36 <jle`> yeah, one way of making this more feasable/real-world is to quit using EitherT, ReaderT, etc.
02:15:43 <jle`> and write polymorphic functions instead
02:16:20 <jle`> it's closer to your intent...you don't really want to specify an EitherT String IO Store, you want to specify a computation that can do IO to return a Store, or possibly fail with a String
02:16:28 <nshepperd> MonadReader r m
02:16:46 <jle`> so you can write (MonadError String m, MonadReader Store m) => String -> m [String], or something
02:17:05 <jle`> your constraints tell you what sort of effects you want `m` to have
02:17:34 <jle`> in this case, `m` is supposed to be able to throw errors of type String, and also to always have a Store in its environment for read-only access
02:17:53 <jle`> and you can throw in MonadIO m if you want m to also be able to execute arbitrary IO actions
02:18:09 <jle`> describe the effects you want your computation to have
02:18:31 <jle`> instead of explicitly using ExceptT, ReaderT, etc., which are implementation details, not high-level concepts
02:20:19 <shanemikel> and an idiomatic interface goes a long way
02:21:38 <shanemikel> don't be afraid to push some deadlines to get the foundation right
02:32:03 <dirk103> oh hai
02:36:00 <bollu> I love applicative parsing! Why do we focus so much on monadic parsers?
02:36:00 <bollu> it's so neat and clean
02:36:14 <bollu> I'm guessing monadic parsers = context sensitive
02:36:16 <bollu> right?
02:36:21 <bitemyapp> parsnip: probably.
02:36:26 <bitemyapp> parsnip: send us the thing you mentioned.
02:38:11 <bitemyapp> @tell hiptobecubic that is nuts! Thank you for telling us, but we probably can't do much about PDF.js being janky. I'll add a warning to the website. Thank you!
02:38:11 <lambdabot> Consider it noted.
03:19:56 <patrol02> Hi Guys, if I have the following classes hierarchy: instance Foo a => Foo (Bar a), and `a` is a phantom type, how do I implement Foo (Bar a) members in terms of (Foo a) members?
03:22:08 <Cale> I don't understand the question
03:22:32 <Cale> Wouldn't we need to know how the class is defined in order to say how to implement its methods?
03:25:46 <patrol02> Cale: instance Accept Json where contentType = "text/json". instance Accept a => Accept (Compressed a) where contentType = ???
03:26:41 <patrol02> note that `contentType` doesn't take or return `a`. The type parameter in Accept is phantom and is only used as a type marker.
03:26:52 <Cale> Yeah, that's a problem
03:27:07 <Cale> You might want to make contentType take a proxy argument
03:27:21 <Cale> Because there will be no way to ever use it
03:27:52 <Cale> any usage of contentType will be inherently ambiguous
03:28:46 <patrol02> Cale: I cannot change the `Accept` definition because it is a library thing :( 
03:29:04 <patrol02> Cale: no luck for me then, thanks for a quick answer
03:29:11 <Cale> Uh, which library?
03:29:23 <patrol02> Servant
03:29:27 <Cale> Maybe there's something we're missing
03:30:15 <Cale> Servant's Accept class already takes the advice I had
03:30:27 <Cale> class Accept ctype where
03:30:27 <Cale>     contentType   :: Proxy ctype -> M.MediaType
03:30:33 <tpsinnem> has anyone here used the CTRex package? recently?
03:30:50 <Cale> It takes a Proxy argument so that you can say which instance you want.
03:31:19 <tpsinnem> i read reports of it having big compile-time performance issues on large records, but I wonder if that's still the case?
03:32:01 <Cale> When were the reports written?
03:32:18 <Cale> The latest version of that package was uploaded Nov 13, 2014
03:32:53 <tpsinnem> this is from july 2014: http://code.haskell.org/~aavogt/HList-benchmark/a.html
03:33:34 <tpsinnem> i wonder if, for example, compiler developments might have made things better
03:33:45 <patrol02> Cale: I'm trying it now...
03:51:24 <linduxed> so this code won't work, but i think you guys will figure out what i mean
03:51:32 <linduxed> i want to do the following:
03:51:57 <linduxed> any (a && b) someList
03:53:07 <linduxed> where someList :: [x], a :: x -> Bool, b :: x -> Bool
03:53:22 <lamefun> any (\x -> a x && b x) list ?
03:53:28 <linduxed> aaah, yes
03:53:31 <linduxed> thank you
03:53:35 <linduxed> lambdas to the rescue!
03:53:44 <linduxed> :-)
04:01:39 <lamefun> Is there a pure functional programming language with an influential king/queen?
04:03:55 <MarcelineVQ> "a monadarchy"
04:09:37 <xacktm> lol
04:11:09 * hackagebot wxdirect 0.92.2.0 - helper tool for building wxHaskell  https://hackage.haskell.org/package/wxdirect-0.92.2.0 (HenkJanVanTuyl)
04:11:09 * hackagebot wxc 0.92.2.0 - wxHaskell C++ wrapper  https://hackage.haskell.org/package/wxc-0.92.2.0 (HenkJanVanTuyl)
04:11:12 <xacktm> lamefun: what is "king/queen" in this context?
04:12:22 <lamefun> xacktm, someone who would oversee, bless and condemn.
04:12:49 <lamefun> And ensure adherence to ONEism, ideally.
04:15:04 <lamefun> For ONEism is the path to the truth while diversitivism is a sweet, sweet lie.
04:15:33 <lamefun> Apple's cult status? Thanks to ONEism!
04:16:45 <xacktm> something like a design by (maybe benevolent) dictator rather than design by committee, aye?
04:17:19 <lamefun> yes
04:17:27 <lamefun> also holistic development vs fragmentation
04:45:20 <linduxed> guys, what is *** in this link? https://www.reddit.com/r/adventofcode/comments/3viazx/day_5_solutions/cxntg7w
04:46:15 <mniip> :t (***)
04:46:16 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
04:46:40 <mniip> in this case it's using the Arrow (->) instance, which is just
04:46:55 <mniip> f *** g = \(a, b) -> (f a, g b)
04:47:50 <mniip> > ('1':) *** ('2':) $ ("foo", "bar")
04:47:52 <lambdabot>  ("1foo","2bar")
04:52:39 <cattleofra> can someone help me to understand how to evaluate the following lambda calculus expression? (\n. * n 2) (+ 7 3)
04:53:16 <mniip> which part are you having problems with
04:57:39 <cattleofra> well I defined a haskell function like: let double n = n * 2 and passed 7+3 as a param. I was expecting 20 as output but got 17 instead, so decided to convert the expression to lambda calculus to see if i could figure out
04:58:16 <cattleofra> is it something to do with lazy evaluation?
04:58:20 <ahihi> it sounds like you computed double 7 + 3, which parses as (double 7) + 3
04:58:23 <jle`> > let double n = n * 2 in double (7 + 3)
04:58:25 <lambdabot>  20
04:58:28 <Zoetrope> You did double 7 + 3 I think
04:58:42 <jle`> > let double n = n * 2 in (double 7) + 3
04:58:44 <lambdabot>  17
04:59:03 <cattleofra> oh that makes a lot more sense now :)
04:59:07 <cattleofra> thank you sir :)
04:59:19 <mniip> just my 2 cents: lazy evaluation is not magical enough to turn 20 into 17
04:59:43 <silver> you could do "double $ 7 + 3"
05:00:00 <arw> and lambda calculus is also not helpful with precedence issues :)
05:00:32 <jle`> mniip: maybe it was too lazy to get all the way to 20, so stopped at 17
05:00:39 <mauke> > let double n = (*) n 2 in double ((+) 7 3)
05:00:41 <lambdabot>  20
05:01:37 <mniip> > (\n -> (*) n 2) ((+) 7 3)
05:01:39 <lambdabot>  20
05:02:46 <cattleofra> i was just having problems understanding what was going on underneath. I wasn't quite certain why it wasn't evaluating 7+3
05:04:11 <cattleofra> thank you all for the help :)
05:06:40 * hackagebot wai-accept-language 0.1.0.0 - Rewrite based on Accept-Language header  https://hackage.haskell.org/package/wai-accept-language-0.1.0.0 (tkmsm)
05:09:43 <cabal-confusee> Hi.  Newbie trying to start out using cabal sandbox.  Ubuntu, apt-get install haskell-platform, then followed this: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
05:10:52 <cabal-confusee> I get to: cabal-install --only-dependencies, and I get:
05:10:56 <cabal-confusee> cabal: Error reading local package.
05:11:08 <cabal-confusee> Couldn't find .cabal file in: .
05:11:29 <cabal-confusee> what am I doing wrong?
05:11:40 <suppi> cabal-confusee, read this :) http://howistart.org/posts/haskell/1
05:13:46 <cabal-confusee> suppi: thanks -- I don't see anything about sandboxes there, though?  To be clear, I've dabbled in haskell before, but this time I am particularly keen to start off using cabal sandboxes
05:14:22 <cabal-confusee> though to be honest I'm not 100% sure I understand what they are ;-)
05:15:14 <suppi> cabal-confusee, it will show you how to use cabal with the least resistance path. including sandboxes
05:15:22 <pavonia> mniip: "lazy evaluation is not magical enough to turn 20 into 17" -- Depends :p  http://lpaste.net/147900
05:15:53 <cabal-confusee> suppi: so it does.  Somehow I missed the word 'sandbox' there.  Thanks again
05:15:59 <mniip> it's unsafeInterleaveIO that is magical here :)
05:16:13 <hexagoxel> cabal-confusee: you are asking cabal to install the dependencies of the package in the current directory. but there is not package in the current directory. what did you want "cabal install --only-dependencies" to accomplish?
05:16:22 <suppi> cabal-confusee, no problem. if you ever feel that's too much work, try using stack instead :)
05:17:02 <cabal-confusee> hexagoxel: I have no idea what I'm doing at this stage, just following the steps on the link I posted above
05:48:14 <tomus> is Haskell really good at parsing things? I dropped RWH book at http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html because parsing was horrible there
05:49:50 <bitemyapp> tomus: I've really enjoyed writing parsers in Haskell
05:50:10 <bitemyapp> tomus: it's a shame you didn't like that chapter, I thought it was one of RWH's better ones. Would you be willing to tell me what you didn't like?
05:53:51 <tomus> level of abstraction poorly motivated, cluttered and noisy code, unnecessarily complicated
05:54:26 <ggVGc> tomus: what's a better example?
05:54:33 <ggVGc> using another language/library
05:54:41 <tomus> if Haskell is about solving simple problems with complicated solutions then I am out (this is what I thought at the time)
05:54:48 <ggVGc> I#ve mostly written parsers using LPEG, which I really enjy
05:56:42 * hackagebot wai-accept-language 0.1.0.1 - Rewrite based on Accept-Language header  https://hackage.haskell.org/package/wai-accept-language-0.1.0.1 (tkmsm)
05:56:50 <bitemyapp> tomus: well, the book I've been working on's next release will cover parsers
05:57:13 <bitemyapp> tomus: and I think it'll be a bit less deus ex machina than what you've just tried out, but the material isn't public yet.
05:57:48 <bitemyapp> tomus: thank you for sharing your thoughts, that's helpful.
05:58:37 <tomus> I like haskell and I code in it (simple things mostly) but this idea "it's great for parsing" keeps coming up and I have flashbacks to that chapter
05:58:54 <tomus> is there a better resource to learning how to parse using haskell
05:59:58 <ggVGc> I personally think it's more "functional programming with ADTs is great for parsing" than "haskell is great for parsing"
06:00:05 <ggVGc> but I haven't actually written a parser in haskell
06:04:28 <suppi> tomus, I only ever written a parser for something lisp-like, but I felt it was pretty easy to express parsers as values in haskell and compose them using combinators
06:04:45 <suppi> here is a stupid little example of that: https://gist.github.com/soupi/6e242049d90c40bb6ce5#file-calccompiler-hs-L158
06:05:22 <ggVGc> I just read through piececs of that chapter. I think that implementation is pretty clean
06:05:44 <ggVGc> it's a pretty straight forward parser using combinators
06:05:55 <ggVGc> tomus: you don't like parser combinators in general?
06:09:09 <tomus> :t <|>
06:09:11 <lambdabot> parse error on input ‘<|>’
06:09:18 <tomus> :t (<|>)
06:09:20 <lambdabot> Alternative f => f a -> f a -> f a
06:09:45 <silver> greenStuff <|> redStuff
06:27:50 <maerwald> how do I figure out the type of an Exception that is thrown? The documentation doesn't say anything and the message is "rename: unsupported operation (Invalid cross-device link)"
06:36:19 <geekosaur> sounds like what it says; rename only works in the same filesystem
06:36:47 <geekosaur> if you're moving from (say) /tmp to your home directory, and /tmp is a tmpfs or a different filesystem, you'd get that
06:37:30 <maerwald> I'm aware of that
06:37:47 <maerwald> that wasn't the question though
06:37:51 <geekosaur> aside from that, exceptions are Typeable so typeOf should work
06:40:14 <maerwald> that doesn't help that much since I have to match (SomeException e) to let it through the typechecker at which point it is SomeException ;)
06:40:32 <maerwald> I figured out that it's IOException, but I still wonder how you can do this
06:41:27 <geekosaur> also see fromException (to unwrap the Some Exception)
06:41:31 <geekosaur> er SomeException
06:42:01 <geekosaur> ...although I'm uncertain how that gets typed...
06:42:38 <pavonia> Doesn't that result in the same problem as show . read?
06:43:10 <geekosaur> that would be the point of my last comment,yes
06:43:27 <geekosaur> I think you end up using Control.Exception.catches and typed patterns
06:43:37 <geekosaur> or something like that
06:44:58 <maerwald> somewhat awkward
06:45:02 <geekosaur> yes
06:46:18 <geekosaur> but for exceptions to be extensible, you need existential wrappers :/
06:46:50 * hackagebot reedsolomon 0.0.3.0 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.3.0 (NicolasTrangez)
06:46:59 <geekosaur> because static typing is somewhat incompatible with arbitrarily extensible "types"
07:01:50 * hackagebot syntactic 3.4 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.4 (EmilAxelsson)
07:11:42 <cabal-confusee> I just installed https://github.com/jfeltz/emamux-ghci and followed the setup steps, but I'm not sure how to actually start ghci using it.  Anybody?
07:15:40 <cabal-confusee> or to attach to existing ghci in tmux, which I guess is actually the intent.  I just want a ghci prompt in emacs, really
08:03:32 <Jello_Raptor> it amuses me how the Applicative instance for this type is an order of magnitude harder to write than the Monad instance :P 
08:05:41 <exio4> Jello_Raptor: I normally go with ap if it's not "trivial" to implement :P 
08:06:15 <Jello_Raptor> exio4: I'm not sure what you mean? :o
08:07:48 <exio4> @type ap 
08:07:49 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:08:04 <exio4> it's in Control.Monad, implemented using (>>=) and return
08:08:10 <Jello_Raptor> ahh
08:18:56 <Jello_Raptor> exio4: huh, I dismissed doing that because it wouldn't cache a number of intermediate values, but in retrospect it probably means I'm doing my monad instance sub-optimally or breaking a property somewhere 
08:20:18 <exio4> Jello_Raptor: heh
08:33:36 <maerwald> mh, gtk question: treeSelectionGetSelectedRows always returns only one row, although multiple are selected. I almost feel it's a gtk2hs bug
08:35:39 <Athas> Does GHC.Conc.numCapabilities default to 1?  Why?
08:35:51 <Athas> (I know I can change it in various ways, but that seems like a very strange default.)
08:37:50 <c_wraith> Athas: if you're not using the threaded runtime, it'll always be 1
08:38:06 <c_wraith> Athas: if you are using the threaded runtime, it still defaults to 1 unless you start the RTS with more threads
08:38:19 <Athas> c_wraith: I am using the threaded runtime, I think.  Isn't that the default these days?
08:38:25 <c_wraith> Athas: no.
08:38:41 <Athas> Hm.  I see that GHC.Conc does not allow me to query the number of cores.  How annoying.
08:39:14 <c_wraith> Athas: if you build with the threaded runtime and run with +RTS -N, it starts with the number of capabilities equal to the number of cores available
08:39:36 <Athas> I'm writing a Haskell program that forks off a bunch of (non-Haskell) processes to do its work, and I want it to spawn a number proportional with the number of CPU cores.  Seems like that is not as obvious a number to find as I thought.
08:39:54 <Athas> c_wraith: thanks, I guess that may be the nicest way to do this.  Time to modify the .cabal file!
08:41:45 <MarcelineVQ> Athas: getNumProcessors should get you a core count, and getNumCapabilities gets you the current value of -N
08:45:56 <Athas> MarcelineVQ: hm, yes, I thought getNumProcessors would return the number of processors, not cores, but I may have tested on a non-threaded runtime (because I got 1).
08:46:54 <Athas> Anyway, this is sweet.  Now my test runner can finally exploit those beefy 16-core Xeons without murdering my poor laptop.
08:59:07 <Jello_Raptor> exio4: ok yeah, I was right. There's a huge performance degradation to simply using `ap` since I keep recalculating values in the underlying monad. (I'm making a monad transformer that acts sorta like `List` but works over (potentially infinite) anamorphisms in the underlying monad while guaranteeing progress in every input anamorphism even if one of them is infinite.) 
09:01:53 <Jello_Raptor> (its version of `(,) <$> [0..] <*> [0..]` would return (1,1) a finite distance into the output, in fact, any pair with finite values would be returned a finite distance into the output) 
09:30:10 <linduxed> so it seems like let-statements are a strictly one-line construct
09:30:23 <linduxed> if i don't fit everything on one line, things seem to break
09:30:38 <linduxed> this is most immediately evident in ghci, but i have some other things that break
09:30:44 <linduxed> basically when i'm in a do-block
09:30:49 <linduxed> is there a way around this?
09:30:56 <MarcelineVQ> proper indentation :>
09:31:04 <linduxed> huh?
09:31:15 <wedens> yeah, and also you can use where (which is sugar for let)
09:31:47 <linduxed> well, in this case i can't use where
09:31:49 <linduxed> https://gist.github.com/linduxed/556675d9199be2af13c1
09:31:51 <linduxed> that thing
09:32:04 <linduxed> in the first test, i used where, but then the second test block broken
09:32:06 <linduxed> *broke
09:32:07 <friendly_anarchi> <bold> hello
09:32:14 <friendly_anarchi> what is going on 
09:32:20 <linduxed> it didn't understand the "context" function
09:32:25 <linduxed> so i opted to go with let
09:32:28 <linduxed> this is not a problem
09:32:31 <friendly_anarchi> good choice
09:32:34 <geekosaur> linduxed, I think you need to indent lines 12-17 at least one more space
09:32:40 <friendly_anarchi> yep i agree
09:32:43 <geekosaur> so they don't line up with the declaration
09:32:56 <linduxed> wtf it worked
09:33:08 <linduxed> oooooh
09:33:09 <geekosaur> and if you want to combine those "let"s, just replace the second "let" with spaces
09:33:23 <linduxed> because the first letter of the cornerTurnedOnMat needs to be first?
09:33:38 <geekosaur> because it must align with falseMat
09:33:40 <linduxed> s/needs to be first/needs to be to the left of/
09:34:50 <exio4> there's also {;} 
09:34:53 <friendly_anarchi> where should i go to learn haskell?
09:35:10 <exio4> > let { x :: Int ; x = 42 ; f y = x+y ; z = f x } in z
09:35:12 <lambdabot>  84
09:35:20 <linduxed> friendly_anarchi: i think that Learn You A Haskell is a great book to read
09:35:54 <exio4> @where learnhaskell
09:35:54 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:36:13 <friendly_anarchi> do any of you guys know how to code in LOLCAT
09:37:10 <friendly_anarchi> oh sorry i meant LOLCODE
09:37:13 <exio4> friendly_anarchi: CAN I HAZ STDIO? KTHXBYE 
09:42:17 <linduxed> geekosaur: i changed it to this instead https://gist.github.com/linduxed/556675d9199be2af13c1
09:42:22 <linduxed> geekosaur: looks good, works fine
10:33:57 <maerwald> No instance for (Show UTCTime) arising from a use of ‘show’
10:33:59 <maerwald> wat?
10:36:42 <kadoban> maerwald: You're likely supposed to use one of the formatTime functions or whatever they are.
10:36:49 <maerwald> I already do
10:36:56 <maerwald> and UTCTime has a show instance
10:37:24 <kadoban> Not in my docs, but that's not necessarily definitive.
10:37:36 <maerwald> https://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Clock.html
10:38:04 <kadoban> Ah, damn stackage docs missing stuff again … wonder if anyone is working on that. I forget every time.
10:40:12 <geekosaur> I think it's only in recent versions
10:40:23 <geekosaur> that may not include stackage lts
10:41:16 <maerwald> seems almost like cabal sandbox is breaking something really hard
10:41:38 <kadoban> Hmm. Well the one on stackage appears to be 1.5.0.1 that I'm looking at, and the hackage one is 1.4.2. Not sure if it would have been removed in the meantime though. I'm not seeing it in the source, it must be coming from an import.
10:44:19 <geekosaur> instance Show UTCTime
10:44:19 <geekosaur>   -- Defined in `time-1.4.0.1:Data.Time.LocalTime.LocalTime'
10:44:25 <geekosaur> (after "import Data.Time)
10:44:48 <geekosaur> ...and I gues sit can't be that new if it's in a ghci from debian >.>
10:46:56 <maerwald> it gets more interesting... if I import System.Directory (qualified), then the error is gone
10:47:43 <mrt2> nyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
10:48:29 <wedens> maerwald: use import Data.Time
10:48:41 <kadoban> geekosaur: Thanks. Still doesn't make complete sense to me, especially why it shows in hackage and not stackage. I'll peek around more though.
10:49:15 <maerwald> wedens: interesting, so it doesn't work with "import Data.Time.Clock"
10:49:19 <maerwald> that's really misleading
10:51:07 <wedens> maerwald: https://github.com/haskell/time/issues/7 https://github.com/haskell/time/pull/21
11:01:11 <pavolzetor> I would like to write simple 32bit float openexr
11:01:20 <pavolzetor> is there any libary that can do that?
11:04:55 <pavolzetor> if I were to write one, how does manipulate bits easily?
11:06:37 <geekosaur> @hackage binary
11:06:37 <lambdabot> http://hackage.haskell.org/package/binary
11:06:42 <geekosaur> @hackage cereal
11:06:42 <lambdabot> http://hackage.haskell.org/package/cereal
11:08:47 <pavolzetor> there is this one https://github.com/ekmett/openexr
11:10:38 <pavolzetor> but seems to support only 16 bit colours
11:12:02 <kadabra> Hey, I'm trying to understand the function signature of foldl:
11:12:05 <kadabra> foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
11:13:21 <breadmonster> kadabra: Just assume Foldable is a list.
11:13:35 <kadabra> I understand that this means it takes a function, an initial acc value and a list to apply the function to. But how is this specified in the signature? What use is the `t`?
11:13:39 <kadabra> okay
11:13:59 <breadmonster> kadabra: Well, t is the type of the container.
11:14:21 <breadmonster> t could be anything with a Foldable instance, like for instance [].
11:14:37 <breadmonster> If memory serves, Data.Map is also foldable for instance.
11:15:03 <kadabra> ahh okay, but why does the signature end with `t a -> b` and not simply `t`?
11:15:28 <breadmonster> kadabra: Because foldl collapses data structures; you get one value out of a data structure.
11:16:01 <kadabra> wouldn't `t -> b` specify this?
11:16:06 <breadmonster> kadabra: Also, t alone is meaningless, because it has kind * -> *.
11:16:31 <kadabra> oh cool, okay now makes sense
11:16:49 <kadabra> breadmonster: many thanks!
11:22:55 <breadmonster> kadabra: No problem.
11:26:35 <SrPx> I find this pattern very common: "import qualified Data.Stuff as Stuff; import Stuff(Stuff, Stuff(Stuff))" ... is there a briefer way to express it?
11:27:40 <pavolzetor> why does haskell not have separate libraries for png, gif, jpeg, but everything is crammed  in JuicyPixels?
11:35:07 <cocreature> is there something broken when showing a record type with :i in ghci? it doesn’t seem to show the names http://lpaste.net/147912
11:35:13 <cocreature> or is this expected behavior
11:35:18 <cocreature> I don’t see why it has to do this
11:39:28 <mpickering> which version of GHC is that with?
11:40:07 <cocreature> when posting I tried with 7.10.3 but I can reproduce it with my two week or so ghc build (right after TypeInType has landed)
11:41:29 <mpickering> I just looked at all the issues on the issue tracker mentioning the word :`info` and couldn't find a ticket for it
11:41:52 <cocreature> alright, I’ll file a report/try to fix it
11:41:54 <cocreature> thanks
11:41:58 <mpickering> Part of the reason might be that they are represented very similarly 
11:42:23 <mpickering> I think the only difference between the two is that records have a non-empty list of field labels 
11:42:46 <cocreature> it’s not about record type vs non record type
11:42:54 <cocreature> it’s about existential record type vs non existential record type
11:43:01 <mpickering> oh right, I see
11:43:28 <mpickering> that's interesting, make a ticket for it
11:43:50 <mpickering> there are lots of funny things about records in GHC
11:44:33 <mpickering> I think if I were to start again I wouldn't include them in such a heavyweight way and provide some support for defining and using profunctor lenses instead
11:44:56 <cocreature> I still need to take some time and figure out profunctor lenses
11:45:43 <mpickering> it is the subject of my thesis so hopefully bring all the whispers into one place
11:45:58 <cocreature> oh nice, is there already a draft or something like that online?
11:46:21 <cocreature> I was recently searching for a writeup on the topic and was sad to not find one apart from some gist
11:46:25 <mpickering> no, it doesn't need to be finished until the summer so I haven't written much yet, should really get started 
11:46:31 <cocreature> hehe
11:47:58 <mpickering> if you look again, make sure to remember that van Laarhoven lenses are a specialisation of profunctor lenses where you choose p to be the right thing
11:48:09 <mpickering> that makes a lot of the definitions easier to understand as it is quite mechanical
11:48:33 <cocreature> will do, thanks for the hint
11:53:17 <Xe> how would I build a cross-compiler for my linux amd64 machine so I can build netbsd haskell binaries?
11:54:44 <mniip> there was some relation between "impossible" and "cross-compiling haskell" but I can't quite remember what it was
11:56:29 <mniip> Xe, have you seen https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
11:57:41 <magneticduck> Xe: compile to JS and run with V8
11:57:44 <magneticduck> I'm only half joking
11:58:08 <Xe> magneticduck: i'm trying to get haskell to run on the rumprun unikernel
11:58:57 <magneticduck> my joke suggestion is still applicable
12:00:36 <Xe> yeah
12:00:42 <Xe> i can also nail a spoon to a tree
12:01:01 <c_wraith> trees need minerals too
12:04:07 <geekosaur> cross-compiling between dissimilar OSes is close to impossible. cross-compiling to a similar OS on a different hardware platform is easiest when going via LLVM
12:04:30 <cocreature> mpickering: turns out that it’s fixed in ghc head, I just rebuilt so even better :)
12:04:34 <lynn> Hiya. I'm dealing with some old code that has "import Char", "import Maybe"... instead of the "Data."-prefixed versions
12:04:43 <geekosaur> cross-compiling to a dissimilar OS on a different hardware platform, or where LLVM isn't an option, means making an unregisterised ghc build and using -fvia-C with that
12:05:08 <lynn> Is this really old Haskell? What's going on? Can I still compile it with modern GHC?
12:05:12 <nshepperd> I thought cross compiling worked these days, except for template Haskell
12:05:14 <geekosaur> (and capturing te C source)
12:05:36 <geekosaur> nshepperd, the cross-compiling that doesn't work is compiling on Linux a program targeting Windows or vice versa
12:05:39 <geekosaur> mopre or less
12:05:59 <geekosaur> lynn, you can still build those but you need to force the compiler into legacy haskell 98 mode (-XHaskell98)
12:06:16 <geekosaur> and may need to specify -package haskell98
12:08:12 <mpickering> Xe: You can ask these kinds of questions in the ghc channel, cross compilation is sometimes not easy!
12:08:50 <mpickering> cocreature: ah great, I should have checked for you :)
12:09:43 <geekosaur> [27 20:05] <geekosaur> lynn-, you can still build those but you need to force the compiler into legacy haskell 98 mode (-XHaskell98)
12:09:47 <geekosaur> [27 20:05] <geekosaur> and may need to specify -package haskell98
12:09:59 <geekosaur> and yes, that's fairly old code considering how fast the language is moving
12:10:03 <geekosaur> agh
12:10:14 <magneticduck> you were.. too late
12:11:46 * geekosaur wonders how much of his response got seen
12:13:25 <hexagoxel> can someone think of a nice implementation of `(a -> (a1 -> r) -> r) -> ([a1] -> r) -> [a] -> r` ? i have written it using foldr, but some Cont stuff might be prettier.
12:14:27 <geekosaur> lynn, you can still build those but you need to force the compiler into legacy haskell 98 mode (-XHaskell98)
12:14:34 <geekosaur> and may need to specify -package haskell98
12:14:38 <geekosaur> and yes, that's fairly old code considering how fast the language is moving
12:14:46 <lynn> geekosaur: Eek, I'm sorry, something is up with the connection here!
12:14:46 <hexagoxel> (\f cont xs -> foldr (\x c r -> foo x (\y -> c (y:r))) cont xs [])
12:14:49 <geekosaur> (are you stably here yet?)
12:15:15 <geekosaur> oh, I know how that goes. I am hiding behind a znc because my local network connection is seriously messed up :/
12:15:16 <lynn> geekosaur: (no idea if I've spammed the channel twice with this line now or not...) <lynn> Oh nooo: "cannot satisfy -package haskell98".
12:15:28 <geekosaur> huh
12:15:38 <geekosaur> what ghc version? and how was it installed?
12:16:10 <lynn> Version 7.10.1, and I'm on Windows 10, if that matters. I just downloaded a binary
12:16:37 <geekosaur> hm. that should have had it. (on debian and derivatives you may need to install another package)
12:17:10 <geekosaur> o, hm, actually I htink they may have decided 7.10 had diverged so far that haskell98 mode was no longer maintainable
12:17:21 <geekosaur> there's an open bug about it
12:17:48 <geekosaur> so you may need an older ghc version (one of the 7.6 or 7.8 series)
12:17:50 <c_wraith> It was that the AMP required compiler support.
12:18:11 <c_wraith> And that compiler support wasn't compatible with Haskell98 base
12:18:54 <breadmonster> geekosaur: What do you znc into?
12:19:05 <geekosaur> a host run by a friend
12:19:26 <breadmonster> c_wraith: why did it require compiler support?
12:19:27 <geekosaur> well, the znc is on there, I just connect to it over an ssh tunnel
12:19:47 <c_wraith> No idea
12:19:52 <breadmonster> Yeah.
12:20:05 <breadmonster> I don't see anything that required it.
12:21:15 <geekosaur> was it AMP, or FTP? I could see the GHC.OldList mumblefuggery causing issues maybe
12:21:33 <breadmonster> geekosaur: What is FTP?
12:21:39 <geekosaur> foldable/traversable
12:21:44 <breadmonster> Ah right.
12:22:17 <breadmonster> geekosaur: I just checked, it's FTP.
12:23:00 <breadmonster> I wish they had aliased map to fmap. 
12:23:11 <geekosaur> (also known as bridge-burning proposal, and here we see why <.< )
12:23:39 <breadmonster> It's really easy.
12:23:54 <stevejb> hello, I am trying to use pandoc as a library to make a pdf. As an exercise, I am trying to modify MacFarlane's fuel.hs demo: http://johnmacfarlane.net/BayHac2014/fuel.hs.html
12:23:58 <breadmonster> And now they can't say that they're being friendly to beginners.
12:24:09 <breadmonster> :t filter
12:24:10 <lambdabot> (a -> Bool) -> [a] -> [a]
12:24:15 <breadmonster> o.O
12:24:17 <breadmonster> :t foldl
12:24:18 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:24:18 <stevejb> my attempt here: http://ix.io/n0z
12:25:21 <`Guest00000> breadmonster: "I wish they had aliased map to map". why?
12:25:31 <`Guest00000> fmap *
12:25:53 <kadoban> Well, it does seem a bit arbitrary which functions they generalized and which they didn't.
12:26:01 <breadmonster> `Guest00000: it makes the language consistent.
12:26:06 <kadoban> Although I assume there was some reasoning behind it.
12:26:19 <breadmonster> edwardk: your experience is required.
12:27:16 * hackagebot diagrams-svg 1.3.1.10 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.3.1.10 (jeffreyrosenbluth)
12:28:20 <breadmonster> kadoban: They ought to have changed the whole fmap/map fiasco.
12:28:39 <breadmonster> And also generalized filter and concatMap
12:28:57 <breadmonster> Of course, the question arises: are we moving towards classy-prelude?
12:29:00 <`Guest00000> breadmonster: can you elaborate?
12:29:11 <breadmonster> `Guest00000: How familiar with Haskell are you?
12:29:16 <kadoban> It is a bit odd, though I can't say I have strong enough feelings on it to … care at all really :-/
12:29:36 <breadmonster> kadoban: Yeah me neither, I use (<$>) anyway.
12:30:23 <kadoban> Ya
12:30:25 <breadmonster> `Guest00000: map used to be fmap, then they changed it for pedagogical purposes.
12:30:32 <nshepperd> Filter isn't part of foldable/traversable
12:30:37 <breadmonster> Except now that's not the case, given the whole increase in generality.
12:30:43 <breadmonster> nshepperd: Sure, but shouldn't it be?
12:31:07 <nshepperd> No, it requires a separate type class
12:31:15 <nshepperd> If you want to generalise it
12:31:16 <breadmonster> nshepperd: really?
12:31:27 <breadmonster> It requires a monoid dependency if I recall correctly.
12:31:30 <mpickering> breadmonster: Have you never run into a bug where you use `length` on the wrong Foldable?
12:31:47 <breadmonster> mpickering: Yes, but it wasn't that hard to trace down.
12:32:14 <nshepperd> breadmonster: traversable can't change the number of elements
12:32:19 <breadmonster> cow_2001: there are places in the world where you will be killed for that.
12:32:30 <`Guest00000> breadmonster: "map used to be fmap" can you give a link please?
12:32:33 <breadmonster> nshepperd: Oh yeah, so what does it look like?
12:32:47 <breadmonster> `Guest00000: It was well before I used Haskell. I don't know where to find it.
12:32:51 <cow_2001> breadmonster: lol
12:32:51 <breadmonster> perhaps geekosaur could help?
12:33:05 <cow_2001> breadmonster: bring it on
12:33:05 <geekosaur> I think you want to look at the haskell 1.4 report?
12:33:16 <breadmonster> `Guest00000: ^
12:33:19 <geekosaur> it's one of the things ranted about as a bad change in haskell98
12:33:21 <mpickering> breadmonster: I don't like foldable for that reason, why would you ever want to write "length (x,y)" instead of 1, it's just a bug in your program
12:33:26 <nshepperd> Well, the witherable type class from some package generalises filter and mapmaybe supposedly
12:33:39 <breadmonster> nshepperd: "witherable"
12:33:55 <mpickering> fmap = map isn't as bad as you have to provide two pieces of information which must agree with each other (a -> b) and an f a
12:34:21 <mpickering> Traversable is very natural as well
12:34:33 <breadmonster> mpickering: The real problem with this comes from the fact that Haskell uses a lot of short vars with limited scope.
12:34:36 <geekosaur> "Witherable" because you can remove elements
12:34:43 <breadmonster> So British xD
12:34:48 <geekosaur> http://hackage.haskell.org/package/witherable-0.1.3.2/docs/Data-Witherable.html
12:34:50 <mpickering> I don't see how that follows
12:35:09 <breadmonster> Yesterday I learned that top secret documents are classified as "Most Secret" in the UK.
12:35:17 <breadmonster> mpickering: I don't know, it's just a stereotype.
12:35:57 <breadmonster> mpickering: I'd have called it erasable or something.
12:36:03 <geekosaur> aaaand Chipped
12:36:24 <geekosaur> (which is Witherable for Traversable (Maybe a)
12:36:32 <geekosaur> silly
12:36:49 <breadmonster> LOL
12:37:19 <mpickering> breadmonster: If people used longer names then what would it change?
12:37:25 <breadmonster> mpickering: Oh right, yeah.
12:37:49 <mpickering> stevejb: What is your problem?
12:38:01 <breadmonster> Basically, because I'm assuming that tuples and lists lend themselves to very different names.
12:38:14 <stevejb> mpickering: I just wrote it up here: 
12:38:16 <stevejb> http://stackoverflow.com/questions/34484570/using-pandoc-as-a-library-to-make-a-pdf
12:38:47 <stevejb> trying to figure out how to use Pandoc with xelatex to make a PDF
12:39:24 <mpickering> are there any artifacts left behind?
12:39:35 <mpickering> that is hard to debug because the error is coming from the system call
12:40:05 <stevejb> my /tmp directory does not have any files of type .log or .tex
12:40:29 <mpickering> breadmonster: right, this bug has caught me when I am doing refactoring changing [a] to ([a], b)
12:40:49 <mpickering> stevejb: First thing, if you just use "writeLaTeX" does it look sensible?
12:40:58 <mpickering> not that that's related to your problem but best to make sure first
12:41:28 <stevejb> mpickering: giving that a try
12:41:41 <breadmonster> geekosaur: I completely agree. Also we really need some AmateurPrelude or something.
12:42:03 <breadmonster> Where `map :: (a -> b) -> [a] -> [b]`
12:42:08 <breadmonster> Or something like that.
12:42:22 <nshepperd> Heh, with witherable we can filter an Either
12:42:30 <MarcelineVQ> oh lordy
12:42:31 <nshepperd> Handy dandy
12:42:39 <breadmonster> nshepperd: lol
12:42:42 <breadmonster> http://osdir.com/ml/libraries@haskell.org/2013-05/msg00280.html
12:43:08 <breadmonster> Can someone tell me what SPJ means by the whole "replace Enum" thing?
12:43:36 <breadmonster> merijn: Hi.
12:44:03 <stevejb> mpickering: ack, havin the writerStandalone option = True for some reason outputs an empty file. Removing that optoin, I get sensible LaTeX
12:44:14 <mauke> breadmonster: that doesn't seem to be SPJ
12:44:25 <breadmonster> mauke: oh sorry. But the question remains.
12:44:43 <mauke> breadmonster: do you know what a partial function is?
12:44:58 <breadmonster> mauke: Uhh, a specialized function?
12:45:08 <breadmonster> I'm unsure what you mean...
12:45:31 <mauke> I'm asking what exactly you're asking
12:45:51 <mauke> the "replace enum" paragraph talks about partial functions, so I'm wondering if that's what's unclear
12:45:57 <breadmonster> mauke: Okay, tell me what a partial function is.
12:46:06 <mpickering> breadmonster: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Enum.html#Enum
12:46:07 <mauke> a function that is not defined on all inputs
12:46:17 <mauke> e.g. head is partial because head [] = _|_
12:46:21 <breadmonster> Aaaaaah.
12:46:29 <breadmonster> Okay, right, as opposed to total functions.
12:46:47 <mauke> yeah, and toEnum maxBound is _|_ for most enums
12:46:56 <mpickering> ok stevejb, so if you remove writeStandalone = True from the call to writePDF in export, what happens?
12:47:54 <stevejb> mpickering: it gives me an error that the document isn't fully there. Which makes sense, as there is no \begin{document} command
12:48:12 <breadmonster> :t toEnum
12:48:13 <mpickering> ok great, we're getting somewhere, I'm glad the error isn't in the call to writePDF :)
12:48:13 <lambdabot> Enum a => Int -> a
12:48:22 <stevejb> mpickering: :)
12:48:26 <breadmonster> mauke: interesting. What's the solution?
12:48:32 <mauke> breadmonster: no idea :-)
12:48:32 <breadmonster> Or proposed solution?
12:48:49 <mpickering> stevejb: maybe try explicitly setting the path to the template as well in WriterOptions?
12:48:53 <mauke> your link is the first I've heard of it
12:49:23 <stevejb> mpickering: I don't have a template at the moment. 
12:49:43 <breadmonster> Interesting.
12:49:46 <mpickering> you can generate one with pandoc on the command line with "pandoc -D latex > template.tex"
12:49:52 <breadmonster> mauke: Do you know wren? I'd like to ask him.
12:49:55 <mpickering> which should get you the default template
12:50:27 <mpickering> breadmonster: I don't think people care too much because the enum typeclass isn't used that much beside simple applications
12:51:14 <stevejb> mpickering: ok, is the writerTemplate option a path to a template or the template itself?
12:51:58 <`Guest00000> i feel indifferent to map/fmap
12:52:07 <`Guest00000> but i'm curious
12:52:07 <mpickering> stevejb: I assume it's the path
12:52:40 <mpickering> which version of pandoc are you using btw?
12:53:17 <`Guest00000> is fmap just an ugly name, or what?
12:53:31 <breadmonster> `Guest00000: Yes. Also map is what it's called in the literature.
12:53:39 <`Guest00000> hm
12:53:49 <Cale> Which literature?
12:53:49 <stevejb> mpickering: 1.15.0.6
12:54:44 <geekosaur> hm, I never did go looking for the Enum proposal to see how it compared to mine from years ago
12:55:01 <mpickering> stevejb: actually looking at the source I don't think that will do anything
12:55:11 <Cale> Usually functor application in the literature is written just by using the functor's name.
12:55:37 <mpickering> if you try compiling what is produced by "writeLaTeX" does it work fine?
12:55:45 <Cale> e.g. if you have a functor T, and some arrow f: X -> Y then you'll see Tf: TX -> TY
12:56:01 <stevejb> mpickering: I realize I posted that in a somewhat bad state. I wanted to see what pdfbytes was. I haven't gotten the template to work yet. I think that I need to actually read the file into a string
12:56:03 <Cale> (where Tf is what we'd write as fmap f)
12:56:05 <shachaf> Cale: Oh, now I know what the canonical choice to use for objects in a category is: The identities on those objects.
12:56:16 <shachaf> Then FA is unambiguous.
12:56:23 <shachaf> (FA vs. Ff)
12:56:30 <mpickering> stevejb: Don't worry about the template, I've looked at the code now and I don't think it's that
12:56:39 <`Guest00000> omg
12:56:43 <`Guest00000> that looks awesome
12:57:09 <xplat> is there some version of a Map with an applicative unionWithKey, or a way to make one from standard primitives?
12:57:14 <`Guest00000> but then [] can't be used as a type name
12:57:23 <`Guest00000> [] (+ 5)
12:57:34 <Cale> right
12:57:36 <`Guest00000> OR as a nil constructor
12:57:59 <Cale> It would have to be List (+5) or something, and we'd have to merge the type and value namespaces which would cause all sorts of other problems
12:58:33 <Cale> also, fmap is nicely polymorphic and lets you not mention which functor you're applying
12:58:41 <Cale> which in some cases is vital
12:58:54 <geekosaur> the problem with trying to hew too closely to math notation is that math notation is not restricted by little things like the compiler knowing what you're on about
12:59:07 <Cale> Right, that too
12:59:18 <xplat> but in other cases it's vital to mention which functor you're applying, and then the only way to do it is by supplying type signatures
12:59:22 <Cale> Though in this case, the mathematical notation is oddly *more* explicit
12:59:26 <ReinH> geekosaur: And also we aren't working in an arbitrary category, we're working in Hask and we should take advantage of its nice properties (morally speaking)
12:59:54 <ReinH> e.g., the existence of parametric polymorphism (id, fmap, etc)
13:00:07 <ReinH> so we *don't* need to specify id_List everywhere or w/e
13:00:10 <stevejb> mpickering: http://ix.io/n0C
13:00:10 <Cale> When you're applying a component of a natural transformation in mathematics, you usually specify the object at which you're taking the component
13:00:20 <Cale> yeah
13:00:29 <stevejb> using writeLaTeX with the writerStandalone option = True still produces an empty string
13:00:34 <xplat> shachaf: any idea about my map thing?  you seem like a person who might know
13:00:34 <`Guest00000> i wonder, will haskell have dependent types in future
13:01:00 <ReinH> xplat: what would it mean to have an applicative unionWithKey? Types are applicative, not values.
13:01:01 <geekosaur> the language is moving in that direction, yes
13:01:04 <Cale> `Guest00000: ...and if so, will it still be Haskell? :)
13:01:13 <xplat> Cale: actually that varies a lot, sometimes you'll just use an NT as its component without saying anything about where, especially in a diagram
13:01:45 <`Guest00000> if it does, how would that interact with typeclasses
13:01:56 <Cale> xplat: I haven't seen a lot of that... there are diagrams where the objects are functors of course...
13:03:28 <breadmonster> geekosaur: lol
13:03:59 <Cale> `Guest00000: Well, instance resolution would have to evaluate the type enough to determine a constructor to match, I guess.
13:04:06 <breadmonster> `Guest00000: I've been saying that for ages now. eir is my hero.
13:04:15 <breadmonster> goldfire: ^
13:04:21 <xplat> ReinH: i'd like to be able to pick an effect when i have two values at a key, and get pure when i just have one
13:04:33 <breadmonster> Cale: Do you know much about dependent types?
13:04:39 <hsk3> What editor or IDE do you guys use for Haskell coding?
13:04:44 <breadmonster> How are they planning to add them to Haskell?
13:04:52 <breadmonster> hsk3: vim + tmux or emacs.
13:04:52 <xplat> ReinH: and then i could sequenceA to apply the effects
13:05:03 <Cale> breadmonster: I've written a bunch of Coq and a bit of Agda and Idris code.
13:05:04 <shachaf> xplat: Not sure.
13:05:34 <breadmonster> Cale: I'm wondering how much we'll have to sacrifice, iirc real dependent types may result in semidecidable type inference.
13:05:37 <stevejb> mpickering: ok, I htink I am not understanding the writerStandalone option. Using writeOrg also produces an empty string when using that option.
13:05:42 <ReinH> xplat: what is the type of the function you want?
13:06:10 <mpickering> stevejb: if you use pandoc on the command line with the `-s` flag then do you get an empty document?
13:06:17 <breadmonster> Cale: Because you want Turing completeness at all costs.
13:06:18 <mpickering> stevejb: what does `pandoc -D latex` say?
13:06:20 <`Guest00000> breadmonster: i'm sorry..... what is eir?
13:06:33 <Cale> breadmonster: hm? Turing completeness might be the wrong term.
13:06:34 <ReinH> hsk3: you can use any basic text editor. Syntax highlighting is nice. Everything else can be had by opening up ghci in a split window / pane / etc.
13:06:49 <ReinH> hsk3: There's good Haskell support in vim and emacs, and probably other editors like sublime text and atom.
13:06:55 <hsk3> ReinH: What about auto completion?
13:07:05 <xplat> ReinH: ultimately something like (k -> a -> a -> f a) -> Map k a -> Map k a -> f (Map k a)
13:07:06 <Cale> breadmonster: Coq and Agda tend to drop Turing completeness in favour of totality.
13:07:10 <ReinH> hsk3: vim or emacs can provide that. Probably others as well.
13:07:21 <xplat> i guess maybe i could map with pure first
13:07:34 <stevejb> mpickering: pandoc -D latex gives a template
13:07:36 <ReinH> breadmonster: you often *don't* want to be TC.
13:07:38 <hsk3> ReinH: Do they have auto completion across files? If you make a function in one file, will it show up in another file's autocomplete? Stuff like that.
13:08:20 <ReinH> hsk3: Yes, they interact with GHC's API to pull in identifiers based on what is available when cabal, Stack, or GHC compiles your file / project.
13:08:27 <mpickering> stevejb: Can you try the template idea I suggested earlier pleae?
13:08:30 <breadmonster> Cale: No, I think Turing completeness is the right term.
13:08:38 <ReinH> I think ghc-mod is the most commonly used provider?
13:09:06 <Cale> Obviously Haskell would want to be Turing complete still. But the hope is that we can hang on to some fragment of the language with plain enough types that inference goes through without problems, just like with all the other extensions.
13:09:08 <ReinH> hsk3: for vim, see https://github.com/begriffs/haskell-vim-now. For emacs, see https://github.com/haskell/haskell-mode
13:09:12 <mpickering> ReinH: In GHC 8.0 GHCi will have better support for these kind of queries as hvr made some changes to merge in some of ghci-ng
13:09:25 <ReinH> hsk3: For a bit of both, see spacemacs's haskell layer.
13:09:28 <hsk3> ReinH: Ah ok, so if I import another module, it will use ghc-mod to grab stuff from that module to autocomplete it
13:09:32 <ReinH> mpickering: Excellent. I like ghci-ng.
13:09:37 <stevejb> mpickering: yeah will do that now. Also, if I save the Pandoc string as fuel.native and then run pandoc --from=native --to=latex fuel.native -o fuel.pdf, that works
13:09:38 <ReinH> hsk3: yes
13:09:41 <hsk3> Nice!
13:09:55 <hsk3> Atom seems to be the New Thing these days.
13:09:59 <ReinH> mpickering: my only wish is that Chris had called it ghci++ ;)
13:09:59 <xplat> wait, there's an even *more* awesome version of ghci?
13:10:14 <ReinH> hsk3: I'm not a fan, but people seem to use it.
13:10:15 <mpickering> stevejb: ok, I think that you might be using two different versions of pandoc here, one which stack has sandboxed and the other which is in your path somewhere
13:10:19 <mpickering> but I'm not sure
13:10:27 <mpickering> hence why I think you should try explicitly setting a template
13:10:37 <xplat> ReinH: not ghci3000?
13:10:42 <stevejb> mpickering: the template worked!
13:10:45 <hsk3> ReinH: what's your editor?
13:10:50 <ReinH> hsk3: spacemacs
13:10:57 <ReinH> although I have a lot of vim experience
13:11:10 <stevejb> mpickering: I had to read the template.tex file into a string, and then pass that in.
13:11:46 <mpickering> stevejb: ok! great! I never understood how the default template files are found. I think my explanation from just above is right
13:11:52 <stevejb> mpickering: I think you are right about that. I think initially before I started using stack I had a version of pandoc in ~/.cabal/bin
13:11:56 <xplat> basically i want to create in the end a nice function that will union two maps in a validation monad and emit an error if the values don't match
13:12:02 <mpickering> now you can answer your own question on stack overflow as well :)
13:12:11 <stevejb> mpickering: :)
13:12:25 <hsk3> ReinH: I've always wanted to ask a vim, or no-mouse editor, guy. Do you never find yourself just wanting to grab the mouse to immediately get to a location you see right in front of you on the screen?
13:12:45 <ReinH> No, because I don't need a mouse to do that.
13:12:47 <stevejb> okay, so I think I will  get rid of the older pandoc. When I was originally trying to do this, it was in a stack sandboxed project
13:13:06 <stevejb> mpickering: now that I have stack, can I rm -rf ~/.cabal ?
13:13:14 <ReinH> And typically faster than it would take to move my hand to the mouse and back.
13:13:41 <hsk3> ok
13:14:17 <stevejb> mpickering: thank you for all the help!
13:14:18 <ReinH> hsk3: forward/reverse searching is usually sufficient. There are also cool tools like https://github.com/abo-abo/avy
13:14:18 <mpickering> stevejb: maybe just ~/.cabal/bin/ if you want to remove the executables, I don't know what else is in there tbh
13:14:34 <hsk3> heh ok
13:15:13 <stevejb> mpickering: I just got rid of the pandoc in there, and revised my $PATH so that ~/.local/bin comes before ~/.cabal/bin
13:15:43 <`Guest00000> ReinH: even if the desired position is in different line AND column?
13:16:00 <ReinH> `Guest00000: why would that matter?
13:16:19 <ReinH> There are navigation commands other than hjkl
13:16:32 <`Guest00000> you have to look up line distance, then type a number of line-navigating commands
13:16:33 <ReinH> typically I just use search
13:16:37 <ReinH> No, you don't.
13:17:05 <ReinH> / and ? are pretty useful
13:17:13 <`Guest00000> or fX repeatedly
13:17:36 <ReinH> Not usually.
13:17:48 <ReinH> Again. Searching with / or ? is usually sufficient to get it in a few keypresses.
13:17:56 <ReinH> whatever and wherever it is.
13:18:22 <ReinH> When it isn't, there are other tools like avy and its vim version
13:18:25 <hsk3> i'll just try atom..
13:18:33 <hsk3> i'm too much of a mouse guy
13:18:33 <ReinH> anyway, this isn't really on topic
13:18:35 <Cale> hsk3: I use vim, but I use the mouse a lot
13:18:46 <ReinH> Cale: shun! shun the unbeliever!
13:18:58 <Cale> hsk3: also I use the arrow keys rather than hjkl, because they always mean what they mean
13:19:04 <ReinH> mouse works fine in vim though
13:19:04 <Cale> Regardless of which mode I'm un
13:19:05 <Cale> in*
13:19:13 <ReinH> if that's your thing
13:19:16 <`Guest00000> ok, i will try / ? for this
13:19:20 <ReinH> both gui and terminal versions
13:20:39 <Cale> But yeah, I don't even really know why I use vim, apart from the fact that it loads quickly. I suppose stuff like being able to press dd to delete a line is something I'm used to. I really use almost none of vim's features.
13:21:04 <Cale> It's approximately isomorphic to gedit for me
13:21:31 <KaneTW> i still use nano for simple editing
13:21:38 <ReinH> Cale: I know a few people like that. edwardk is pretty similar. One of the best programmers at one of my old jobs was a pretty old dude who didn't enable syntax highlighting or any form of indentation and mostly typed with one hand.
13:21:42 <mpickering> same for me.. I just have a few commands I use along with tags files
13:21:44 <KaneTW> emacs for code and rst and stuff
13:21:51 <ReinH> he was awesome
13:22:20 <ReinH> People who fetishize their editors spend a lot more time tweaking them than they do being productive.
13:22:22 * ReinH shrugs
13:22:28 <ReinH> I'm certainly guilty of this to some extent...
13:22:29 <KaneTW> yeah
13:22:39 <breadmonster> ReinH: That's true :P
13:22:42 <KaneTW> i set up my editor once and i rarely hae to touch it agaain
13:22:53 <ReinH> I am at this exact moment trying to fix an annoyance I have with spacemacs's haskell layer, actually.
13:24:18 <Cale> KaneTW: I've set up my editor with fancy features a couple of times, and each time I did it, it was cool for like a few hours, and then I proceeded to never get enough benefit from those features to justify the time spent thinking about them
13:24:59 <stevejb> mpickering: okay, the whole thing is working now!
13:25:58 <f-a> mhhh I am making a small game in haskell and I find myself recompiling every time I have to ship a beta, so I wondered:
13:26:54 <f-a> is there a way to have a seldom changing compiled and a set of plain text haskell files which get 'interpreted' (runhaskell like)?
13:27:09 <f-a> I would say: no, but I found it to be an interesting question so I am here
13:27:18 * hackagebot microlens 0.3.5.0 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.3.5.0 (Artyom)
13:27:20 * hackagebot microlens-th 0.2.2.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.2.2.0 (Artyom)
13:27:22 * hackagebot microlens-ghc 0.3.1.0 - microlens + all features depending on packages coming with GHC (array, bytestring, containers)  https://hackage.haskell.org/package/microlens-ghc-0.3.1.0 (Artyom)
13:27:24 * hackagebot microlens-platform 0.1.7.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.7.0 (Artyom)
13:27:51 <Cale> f-a: If you have .hi and .o files sitting around, ghci will load them
13:28:08 <f-a> interesting, Cale 
13:28:15 <ReinH> f-a: For practical purposes, the answer is no.
13:28:29 <ReinH> It's pretty easy to set up continuous builds though
13:28:48 <ReinH> f-a: btw what are you using for your game?
13:28:56 <f-a> sdl2 bindings
13:29:19 <ReinH> cool
13:29:27 <f-a> they are nice
13:30:31 <mpickering> stevejb: Just write a short answer on stack overflow as well so someone doesn't spend some time trying to work it out
13:30:58 <SrPx> Runghc doesn't understand the "-i" param that GHC has. How can I add an include directory to runghc?
13:32:02 <stevejb> mpickering: doing that now! Thanks
13:32:39 <geekosaur> SrPx, runghc is a little weird
13:32:58 <geekosaur> runghc [runghc options] [-- ghc options] program [args]
13:33:55 <SrPx> Uhm I can't parse that. Would that be a double -- with stack? So, "runghc myfile.hs -- -- -i/Users/srpx/Haskell" ?
13:34:11 <SrPx> "stack runghc myfile.hs -- -- -i/Users/sprx/Haskell" *
13:34:40 <geekosaur> stack runghc -- runghc flags here -- ghc flags here 
13:34:42 <geekosaur> I think
13:34:53 <geekosaur> stack runghc -- runghc flags here -- ghc flags here myfile.hs
13:35:27 <geekosaur> although stack may insert its own ghc flags in which case you may have to ask them to be more clever in parameter parsing
13:35:53 <xplat> stack runghc -- runghc flags here -- ghc flags here -- myfile.hs myfile flags here -- file args starting with - here -- comments nowhere
13:36:09 <geekosaur> well the -- is a POSIXish thing not a haskell comment
13:36:21 <xplat> yeah just making a pun
13:36:32 <geekosaur> it does get pretty weird though
13:37:57 <xplat> and actually wasn't -- originally FSF or something not POSIX?
13:38:21 <ReinH> f-a: I'm giving reflex-dom a try. So far it's pretty neat but a bit hard to learn.
13:38:54 <xplat> i thought pre gnutools bsd/sysv/posix used the first nonswitch as the delimiter
13:39:18 <f-a> ReinH: anything you want to show? :P
13:40:33 <ReinH> f-a: well, I can do path finding on a hex grid. That's about it so far.
13:44:33 <f-a> ReinH: I must admit I never had much success with my encounters with frp.  Good luck with your game1
13:44:36 <f-a> *!
13:52:18 * hackagebot Cabal 1.22.6.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.22.6.0 (ryant)
13:57:00 <ReinH> f-a: you too!
13:57:19 * hackagebot visibility 0.1.0.0 - Simple computation of visibility polygons.  https://hackage.haskell.org/package/visibility-0.1.0.0 (darwin226)
13:58:38 <suppi> ReinH, I would love to hear your thoughts about reflex, I'm interested in it but have a bit of a hard time getting started with something that doesn't have a tutorial
14:08:44 <physixer> why are the discussions on foldl and foldr always lacking in mentioning "infold" and "outfold"? by infold I mean [ "a", "b", "c", "d" ] => "a|b|c|d" and outfold: [ "a", "b", "c", "d" ] => "|a|b|c|d|"
14:09:23 <mauke> what
14:10:31 <monochrom> because of irrelevancy.
14:10:34 <physixer> or one of foldl1, foldl1' etc are actually similar to infold/outfold?
14:10:49 <mauke> what are you talking about?
14:11:09 <monochrom> no, both foldl and foldr can be used to implement infold, and both foldl and foldr can be used to implement outfold
14:11:46 <`Guest00000> physixer: intersperse
14:12:19 * hackagebot eventstore 0.10.0.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.10.0.0 (YorickLaupa)
14:12:38 <physixer> `Guest00000: ok, so intersperse is infold. But still no outfold.
14:13:28 <`Guest00000> physixer: \x -> (x:) <*> intersperse x <*> (++ [x])
14:13:41 <`Guest00000> oh
14:13:44 <`Guest00000> that's an error
14:14:04 <monochrom> is that intersperse? or is that intercalate?
14:14:05 <`Guest00000> \x -> ((x:) . (++ [x])) <*> intersperse x
14:14:34 <hpc> :t intercalate
14:14:34 <nocturne777> when using the lens library, is it a ridiculous idea to define Getters instead of Lenses to enforce that set OPs should not be executed on the data structure ?
14:14:35 <lambdabot> [a] -> [[a]] -> [a]
14:14:47 <hpc> :t intersperse
14:14:48 <lambdabot> a -> [a] -> [a]
14:15:42 <physixer> so did I just suggest an addition to haskell standard library? outersperse?
14:16:02 <monochrom> you suggested two. outersperse and outercalate.
14:16:12 <physixer> nice
14:16:14 <pavolzetor> I am trying to make an instance of Binary
14:16:17 <`Guest00000> wait...
14:16:20 <monochrom> and yet all four are pretty irrelevant to the topic of foldl and foldr
14:16:21 <`Guest00000> still en error :/
14:16:36 <pavolzetor> http://lpaste.net/147921
14:16:38 <`Guest00000> oh hey
14:16:44 <pavolzetor> but it gives me error
14:16:50 <`Guest00000> i can't do this with infix operators: (`++` x)
14:16:57 <pavolzetor> OpenEXR.hs:29:10:     No instance for (GHC.Generics.Generic CompressionData)       arising from a use of ‘binary-0.7.6.1:Data.Binary.Class.$gdmget’     In the expression: binary-0.7.6.1:Data.Binary.Class.$gdmget     In an equation for ‘get’:         get = binary-0.7.6.1:Data.Binary.Class.$gdmget     In the instance declaration for ‘Binary CompressionData’ Failed, modules loaded: none.
14:17:00 <`Guest00000> omg
14:17:03 <ReinH> physixer: (they are irrelevant because infold and outfold are not folds)
14:17:04 <`Guest00000> what di d i just write
14:17:18 <`Guest00000> please ignore that garbage 
14:17:20 <monochrom> makes me wonder whether your point was really what you said at the beginning.
14:17:33 <aistis> mkExpr' = (pprint =<<) . runQ
14:17:44 <monochrom> which makes me wonder why people don't just say what they mean, instead say something way bigger
14:18:14 <`Guest00000> monochrom: they want to isolate their problem?
14:18:39 <monochrom> that doesn't look like isolating their problem or question
14:19:19 <ReinH> isolating makes things smaller, not bigger
14:19:27 <monochrom> instead it looks like inflation
14:20:37 <monochrom> if a person goes to a math channel to get help with "solving x^2 - 2x + 1 = 0", they won't say that. they say "how to do GENERAL ALGEBRA questions?", complete with the caps.
14:21:06 <monochrom> I saw that all the time in math channels, and some of the time here.
14:21:18 <`Guest00000> 'isolation' in the "giving less amount of information" sense
14:21:18 <monochrom> people do have the tendency to make their questions sound bigger
14:21:38 <nomeata> Hi. Is there something like Control.Applicative.Error in base?
14:21:57 <monochrom> that is not isolation. that is distortion.
14:21:57 <nomeata> I.e. an applicative functor that either succeeds or collects all errors?
14:22:29 <ReinH> nomeata: No. That's why it's in applicative-extras.
14:24:14 <nomeata> Weird. It fixes the type of the error to String.
14:31:13 <physixer> Well laa dee daa, https://wiki.haskell.org/Fold mentions what I call infold extensively (in fact it starts with infold and then mentions foldl and foldr), hence providing it's relevant to foldl and foldr
14:31:38 <physixer> but at the same time it completely ignores outfold hence proving my point that such discussions are lacking
14:32:28 <MarcelineVQ> What is an outfold?
14:32:45 <MarcelineVQ> rather, what would that look like
14:33:00 <physixer> I gave an example above, outfold: [  "a", "b", "c", "d" ] => "|a|b|c|d|"
14:33:00 <mauke> physixer: still no idea what you're talking about
14:33:04 <MarcelineVQ> You had an example earlier but I don't understand it
14:33:09 <mauke> physixer: that example makes no sense
14:33:43 <MarcelineVQ> I'd like to know more about what you mean though
14:33:59 <physixer> outfold, the operation has to applied before and after as well, not just in-between and left, or in-between and right
14:34:13 <mauke> what operation?
14:34:39 <monochrom> you are basically saying, why doesn't an article on foldl and foldr include your favourite example.
14:35:00 <monochrom> and the answer is, because it is not everyone else's favourite example.
14:35:10 <physixer> in my example, operation is, surrounding with pipe character '|'
14:35:22 <mauke> physixer: what does that have to do with folds?
14:35:42 <MarcelineVQ> I see the pipe is literal
14:35:44 <physixer> it turns a "list" of strings, into a string!
14:35:47 <MarcelineVQ> I understand now.
14:35:47 <mauke> because clearly "a|b|c|d" is not a fold there
14:35:48 <monochrom> an article must be of finite length and therefore must miss out infinitely many people's favourite examples.
14:36:28 <physixer> string append is just an example, I need to think of a good example for list of integers, etc
14:36:31 <mauke> current diagnosis: you don't know what a fold is
14:46:15 <frerich> physixer: It seems to me that for an 'outfold', the given function is applied one more time than there are elements in the list - and it's a binary function. That begs the question what arguments to apply the function to for empty lists?
14:47:03 <mauke> neither "infolds" nor "outfolds" are folds
14:47:16 <frerich> physixer: Maybe your distinction is more like foldr (your "outfold")  vs. foldr1 (your "infold")?
14:59:40 <ahhh> https://doyle.ninja/limechat-crash.gif
15:05:47 <ontop> Can anyone help me with this problem? I'm trying to read through this Haskell book and they don't provide answers for like 90% of the things you want answers to.
15:05:53 <ontop> Pastebin inc
15:06:43 <ontop> http://kopy.io/fZc5N
15:07:37 <Bor0> anyone able to help me for SICP exercise 1.19? I was able to compute T_pq twice, but how do I calculate p' and q' out of the new given equations?
15:07:47 <Bruuuuno> what have you tried ontop?
15:07:56 <monochrom> ontop: do you have some existing code that does part of it?
15:08:21 <ontop> http://kopy.io/bcDhw
15:08:24 <ontop> I have this solution that works fine?
15:08:42 <ontop> But I can't use my brain to come up with a solution using that syntax they want.
15:09:48 <ontop> It seems like you'd need a sub-function (the "go" functions as the book names them)
15:09:49 <Bruuuuno> mmm
15:09:54 <ontop> But then you can't pattern match properly in those
15:10:04 <ontop> Because the first thing you -have- to do it seems is break the list into words
15:10:14 <ontop> ANd then once you have that, why would you care what the original list was?
15:11:03 <ontop> And even if I try to do it character-by-character, it seems really hard and then I just want to use a foldr to do it all for me lol.
15:11:06 <monochrom> is there any reason why kopy.io forbids me from copy-and-paste?
15:11:27 <ontop> monochrom: Should work fine, if you're trying to edit just click the fork on the top-right.
15:11:28 <Bruuuuno> for the tuple thing you could do
15:11:58 <monochrom> your current solution outputs [("hello", "HELLO"), ("world", "WORLD")] rather than [("hello", "Hello"), ("world", "World")]
15:12:08 <ontop> O_o
15:12:10 <Bruuuuno> toTuple all@(x:xs) = (all, toUpper x : xs)
15:12:13 <ontop> Did I read the question wrong? :D
15:12:20 <ontop> Oh my.
15:12:21 * hackagebot cabal-install 1.22.7.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-1.22.7.0 (ryant)
15:12:26 <ontop> I think I read the question wrong ahha.
15:12:53 <ontop> I like that Bruuuuno :D
15:13:13 <ontop> Then you just use words in conjuction
15:13:17 <ontop> And TADA?
15:13:22 <Bruuuuno> ya
15:13:33 * ontop goes to editor
15:14:22 <pavolzetor> I am writing instances of binary but if I do (put "test") it has offset of 8 bytes
15:14:27 <pavolzetor> why is that?
15:14:37 <pavolzetor> I do not want that leading offset
15:14:43 <pavolzetor> since the EXR needs tight packing
15:15:01 <Bruuuuno> you can even put it in your lambda
15:15:13 <Bruuuuno> map (\all@(x:xs) -> (all, toUpper x:xs)) .  words 
15:15:39 <ontop> I did it!
15:15:47 <ontop> Oh, my solution was just like yours except I didn't use .
15:16:00 <ontop> caps str = map (\a@(x:xs) -> (a, toUpper x : xs)) (words str)
15:16:20 <ontop> monochrom: Thank you for reading the question for me.
15:16:30 <ontop> Bruuuuno: Thanks for the suggestion for the tupplerizing.
15:16:32 <ontop> :D
15:17:05 <ontop> Where's the author of this book.
15:17:13 <ontop> He was in here once.
15:17:17 <pavolzetor> you can see in ghci
15:17:24 <pavolzetor> runPut . put $ "test"
15:17:36 <pavolzetor> is null null null .... test"
15:17:49 <Bruuuuno> what is the book?
15:17:59 <ontop> Bruuuuno: "The Haskell Programming Language"
15:18:04 <ontop> I think it's by julienXX or something.
15:18:16 <ontop> Er sorry
15:18:25 <ontop> Title is "Haskell Programming - from first principles"
15:18:32 <ontop> My PDF was titled wrong.
15:18:39 <MarcelineVQ> interestin
15:19:16 <MarcelineVQ> that's by julie and bitemyapp, whom you'll find here
15:19:32 <MarcelineVQ> there's a channel for it called #haskell-beginners
15:19:40 <ontop> Oh, nice. I'll go complain in there :D
15:19:42 <ontop> Thanks.
15:20:28 <MarcelineVQ> That's a pretty straightforward problem, but they love feedback so dont' hesistate to bring it up. With the caveat that it's better to email them about it from the support link on the book's website
15:21:02 <ontop> The feedback is more along the lines that there are a LOT of missing answers.
15:21:16 <MarcelineVQ> I remember giving similar feedback
15:21:26 <MarcelineVQ> it's important to keep in mind though that if you could just look at answers you would
15:21:38 <MarcelineVQ> You would every time, and then no one learns anything, they just think they did
15:21:46 <ontop> Yeah, but I haven't gotten stuck on anything until that.
15:21:50 <ontop> In the entire book.
15:21:52 <ontop> :(
15:21:59 <ontop> And it would have helped me move along.
15:24:14 <mpickering> has anyone used stack's --nix option?
15:24:35 <mpickering> I was wondering about the limits of it, I assume it doesn't construct nix expressions for packages which aren't already in nixpkgs?
15:25:31 <mpickering> Is there a stack irc channel?
15:25:58 <MarcelineVQ> #haskell-stack
15:33:51 <ontop> MarcelineVQ: Did you learn from the same book?
15:34:41 <MarcelineVQ> I learned a bit before but the book was a huge help
15:35:05 <ontop> MarcelineVQ: Which part did it help with?
15:35:14 <MarcelineVQ> Oh every part :>
15:35:22 <ontop> I've read like 50% of it, and so far haven't come away with much more than learnyouahaskell.com
15:35:41 <ontop> I know some lambda calculus, and weird ways of looking at the types (product, sum etc).
15:37:39 <MarcelineVQ> I can't predict how useful it will be for you but I enjoyed my time with it, and it's being worked on so there's more to come.
15:37:46 <ontop> True.
15:37:56 <ontop> I bought it for julie and bitemyapp's Christmas gift.
15:38:12 <ontop> I was hoping for a bigger deep dive on some libraries etc.
15:38:21 <ontop> Still 500 pages, maybe something will happen :D
15:38:25 <MarcelineVQ> I took the time to write a review of the book while working through it which was useful because it forced me to slow down and think about things more.
15:41:33 <ChameleonSix> Hello
15:41:53 <indiagreen> MarcelineVQ: can you give a link to the review?
15:42:56 <MarcelineVQ> It was email feedback so I'd have to consolidate my note files to do that, it contains quite a bit of book content too so I'm not sure I should do that for that reason :o
15:43:03 <indiagreen> ah, 'kay
16:02:04 <naudiz> I'd like to try out test driven development. Which testing framework do you recommend for that purpose?
16:02:22 <SrPx> If I create a brand new project with cabal/stack and use stack build, will it build with -O2, or do I have to configure it (how?)
16:04:13 <MarcelineVQ> SrPx: set the options you want in the .cabal file in your project folder under ghc-options:
16:04:29 <pavonia> naudiz: Not sure what test-driven development is, but quickcheck and HUnit are quite popular for testing
16:04:51 <SrPx> Oh, okay. What is the default optimization level?
16:04:55 <MarcelineVQ> none
16:05:38 <naudiz> pavonia: TDD is: write type-definitions for your API, write tests, implement
16:06:02 <naudiz> pavonia: what's the big difference between HUnit and HSpec?
16:06:18 <pavonia> I don't know about HSpec
16:06:42 <naudiz> okay, thanks for your recommendations
16:06:57 <SrPx> MarcelineVQ: really? But I'm looking at Wai's source code, it doesn't have -O2 on the ghc-options... why would that be?
16:08:21 <MarcelineVQ> wai's a library so I'm guessing it builds to the optomization level of your binary, but I don't actually know
16:09:19 <SrPx> interesting
16:09:50 <MarcelineVQ> some related reading here wiki.haskell.org/Performance/GHC
16:11:44 <SrPx> Thanks! Is GHCJS affected by ghc-options: -O2?
16:11:51 <MarcelineVQ> dunno :>
16:13:13 <dmj`> SrPx: potentially, I think ghcjs converts haskell to js at STG, and -O2 happens a few compilation steps before, optimizing core passes
16:17:23 * hackagebot sloane 4.2.0 - A command line interface to Sloane's OEIS.  https://hackage.haskell.org/package/sloane-4.2.0 (AndersClaesson)
16:30:09 <kadabra> Doing `max [1,10,3,4,5] [-1,5,6,7,8]` returns [1,10,3,4,5], but when I look at the type definition of `max` I see that it does not accept lists as arguments: `max :: Ord a => a -> a -> a`. So why does my expression not throw a type error?
16:30:32 <geekosaur> ?
16:30:41 <geekosaur> it takes anything that has an Ord instance
16:30:54 <geekosaur> > [1] < [2]
16:30:56 <lambdabot>  True
16:31:03 <geekosaur> looks like it has an Ord instance to me...
16:31:20 <kadabra> Oh, so a list is a member of Ord?
16:32:18 <geekosaur> go into ghci, type ":info Ord"
16:32:33 <geekosaur> (that will produce a fair amount of spam due to all the tuple instances)
16:32:47 <geekosaur> instance Ord a => Ord [a] -- Defined in `GHC.Classes'
16:33:39 <pavolzetor> why when I use "stack exec ghci", then do :l file I am getting version problems with binary?
16:34:00 <pavolzetor> http://lpaste.net/147927
16:34:11 <pavolzetor> I run stack upgrade
16:34:16 <pavolzetor> but it still persists
16:35:23 <kadabra> so `instance Ord a => Ord [a]` means that a list of elements of type a is a member of Ord if a itself is a member of Ord?
16:35:34 <pavolzetor> shouldn't it just take the one it installed?
16:36:37 <geekosaur> kadabra, yes. if the type of iitems in a list has an Ord instance then an Ord instane can be derived for that list
16:37:05 <geekosaur> pavolzetor, shouldn't you be using "stack repl"?
16:37:34 <geekosaur> possibly ghci is not getting some package database changes
16:37:37 * hackagebot hops 0.4.0 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.4.0 (AndersClaesson)
16:37:39 * hackagebot pinch 0.2.0.0 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.2.0.0 (abhinav)
16:38:20 <lynn-> kadabra: it sorts the lists in "dictionary order", like so:
16:38:20 <pavolzetor> geekosaur: how? "stack repl" gives me invalid argument
16:38:48 <lynn-> > "Haksell" > "C++"   -- because 'H' > 'C'
16:38:50 <lambdabot>  True
16:39:15 <kadabra> geekosaur: Cool, thanks for the help. Just started learning Haskell, I like that typeclasses allow you to be so expressive
16:39:40 <geekosaur> oh, sorry, stack ghci
16:39:50 <geekosaur> (vs. cabal repl. consistency who needs it)
16:39:56 <MarcelineVQ> actually stack repl is a thing too, maybe your stack is old
16:39:57 <lynn-> or in your example: the heads of the lists are compared, and 1 is bigger, so it's the max
16:40:21 <pavolzetor> 0.1.6 version
16:40:29 <pavolzetor> is that old?
16:40:33 <geekosaur> kadabra, there's actually a bit of a warning hidden in there. the typechecker will try any typeclass it can make fit, to make something typecheck.
16:40:37 <ga2arch> pavolzetor: the current one is 1.0
16:40:51 <MarcelineVQ> fairly, git is 1.11
16:40:57 <geekosaur> this is why we don't normally have Num instances for lists or functions, etc. --- it's an open invitation for surprising things to happen
16:41:16 <pavolzetor> okay, 2 months old
16:41:18 <geekosaur> because the typechecker might find some unexpected way to interpret what otherwise would be a type error
16:41:33 <pavolzetor> how do I upgrade to newer stack?
16:41:43 <pavolzetor> I just run "stack upgrade" and still 0.1.6
16:41:55 <ga2arch> pavolzetor: https://github.com/commercialhaskell/stack/releases
16:42:09 <pavolzetor> I see, I had a path issue :/
16:44:31 <geekosaur> even if you have ~/.local/bin in $PATH, you may need "hash -r" to make your shell notice something was added there
16:45:37 <pavolzetor> I did source
16:45:55 <pavolzetor> let me test it, just unmerging the system stack installation 
16:48:13 <pavolzetor> works, thanks; do I run stack upgrade every now and then?
16:48:34 <kadabra> lynn: thanks!
16:48:52 <MarcelineVQ> dunno, I've never used stack upgrade
16:49:15 <kadabra> geekosaur: do you think you could give an example of the type checker going wrong?
16:49:29 <pavolzetor> I see, I prefer to have packages from stack now, instead of gentoo overlay (since that is often broken)
16:50:26 <geekosaur> hm. not easily. the main thing to watch out for is to not try to get too clever with typeclasses
16:50:54 <kadabra> haha, I think I'll have to make that mistake a few times and then learn from that :P
16:50:57 <geekosaur> someone could, for example, think it's a good idea to make an instance Num [Char] where ...
16:51:17 <geekosaur> and then you get random strings treated as numbers when you might not intend them to be
16:51:52 <c_wraith> @hackage acme-php
16:51:52 <lambdabot> http://hackage.haskell.org/package/acme-php
16:51:53 <geekosaur> because the typechecker noticed it can use a Num instance somewhere, but you weren't expecting it
16:51:57 <c_wraith> like..  that. :)
16:52:33 <pavolzetor> what data type would you recommend to represent images?
16:54:17 <kadabra> thanks geekosaur
16:54:21 <geekosaur> (I'm not sure there are "good" examples anyway; the ones that bite tend to be the ones that *look* like they shouldn't cause a problem, but some instance somewhere else means they do. most fun when importing a new module introduces instances you didn't think about --- instances are global and always imported)
16:55:22 <geekosaur> you kinda need to know all the instances that could be in play anywhere in your program, which can change by adding an import just to one module but suddenly you have new instances *everywhere*
16:55:39 <kadabra> yeah I can imagine this can bite in more complex code where something isn't *obviously* wrong
16:56:22 <geekosaur> (but, local instance imports have their own problems. I could locally introduce a "reversed" Ord instance and then hide stuff in a Map that can only be accessed via my local instance, for example)
16:59:40 <geekosaur> I think mostly I mention this because
16:59:44 <geekosaur> :t siin + cos
16:59:45 <geekosaur> er
16:59:45 <lambdabot>     Not in scope: ‘siin’
16:59:45 <lambdabot>     Perhaps you meant ‘sin’ (imported from Prelude)
16:59:48 <geekosaur> :t sin + cos
16:59:49 <lambdabot> (Floating a, Num (a -> a)) => a -> a
17:00:14 <geekosaur> "wait, you can do that?!" "yes, but if you thought *that* was weird, wait til you see what you get if it can find that instance!"
17:01:06 <geekosaur> (you're more likely to see that come up as a type mismatch error in a program, if you dropped a parameter by accident)
17:02:32 <kadabra> I see
17:03:23 * bitemyapp throws a pokeball at kadabra
17:03:49 <Jinxit> he'll just teleport away, you know
17:04:07 <bitemyapp> fucking abras.
17:04:43 <MarcelineVQ> you can't use a pokeball on another trainer's guy :O
17:04:55 <Jinxit> say that to mewtwo
17:04:58 <nolrai2> so if I run 'stack exec ghc-mod' i get 'While parsing "/home/chris/.stack/programs/x86_64-linux/ghc-7.10.3/lib/ghc-7.10.3/package.conf.d/package.cache": Prelude.chr: bad argument: 3593467' any idea whats going on?
17:05:59 <geekosaur> was ghc-mod built in that stack sandbox? with that version of ghc?
17:06:32 <nolrai2> Thanks!
17:06:36 <geekosaur> it has ghc-as-a-library linked into it, but stack exec is forcing it to look at stack's package repo
17:06:53 <geekosaur> which may be for an incompatible ghc version, and then reading the package db will likely fail
17:07:47 <nolrai2> Been dealing with different versions of things all evening, as the lts I was using was too old.
17:18:09 <ontop> Oh, bitemyapp is here.
17:18:36 <ontop> Sorry I didn't follow the feedback process.
17:18:38 <ontop> :D
17:20:00 <bitemyapp> ontop: it's fine. Next time, right? :)
17:20:03 <ontop> Right.
17:20:07 <ontop> Argh, stuck on stupid DaPhone.
17:20:19 <ontop> I have no idea how to write a data structure that represents that dialpad
17:20:22 * ontop frustrates.
17:22:02 <dmj`> ontop: what is dialpad?
17:22:57 * hackagebot clarifai 0.1.0.0 - API Client for the Clarifai API.  https://hackage.haskell.org/package/clarifai-0.1.0.0 (jcanero)
17:23:22 <ontop> dmj`: It's from bitemyapp's book, it's the 2 (abc), 3 (def) kind of old school texting mechanisms that we used to use.
17:23:28 <ontop> Not only for texting, but for call services.
17:24:27 <dmj`> ah cool
17:25:47 <ontop> Sort of cool.
17:25:49 <ontop> -_-
17:26:45 <dmj`> ontop: sort of?
17:27:06 <ReinH> Cale: I really need to explore the connections between cofree comonads and various types of state machine more
17:27:15 <ReinH> they keep showing up
17:27:18 <ReinH> bitemyapp: o/
17:27:54 <ontop> dmj`: Cool in the sense that it's an interesting problem for me. Uncool in the sense that I'm stuck :D
17:28:15 <dmj`> ontop: why are you stuck
17:28:32 <ontop> I don't know how to properly model that in a Haskell data structure.
17:28:54 <ontop> It says: data DaPhone = Sommat
17:29:08 <ontop> Not sure what Sommat means, but I think they want me to replace "Sommat" with something that represents that Dial pad.
17:29:08 <dmj`> ontop: So you need to associate a number to a few letters?
17:29:24 <ontop> Well, yeah. And the tricky bit is '*' makes a letter uppercase.
17:29:30 <ontop> I can easily code this in a functin
17:29:32 <ontop> function
17:29:42 <ontop> But I don't know what I'd do to put it in a data constructor?
17:29:55 <ontop> Or why you wouldn't just put it in a function to begin with?
17:31:01 <dmj`> ontop: so if I'm understanding correctly, it sounds like '*111' would be 'C'
17:31:21 <ontop> Yep.
17:31:23 <ontop> Sounds that way.
17:31:35 <ontop> So I should be able to take C and make '*111'
17:31:45 <ontop> Which is easy.
17:31:50 <csd_> how do i cast a function name from string (user provided) -> function ?
17:31:58 <ontop> The hard part is how do you put that in data DaPhone = Sommat
17:32:00 <ontop> O_o
17:34:23 <dmj`> ontop: you could probably do it just with types
17:34:28 <csd_> or do i need to instead use a case statement?
17:34:32 <pavonia> csd_: Write a case branch that returns the function depending on the input string. It's a bit trickier if your functions have different types, though
17:34:46 <csd_> ok thanks
17:36:01 <ReinH> csd_: in general, don't expect to be able to turn strings into identifiers or similar. Haskell isn't designed that way.
17:36:22 <ReinH> you have to provide the mapping yourself
17:38:13 <august90> Heyy
17:38:48 <csd_> ok and if i'm using multiple `let`s in a do block, is there a way to combine them into one, instead of repeatedly using let?
17:39:15 <geekosaur> indent each definition to the same column as the first
17:39:48 <csd_> ah thank you
17:45:55 <dmj`> does anyone use clay here?
17:45:58 <dmj`> @package clay
17:45:58 <lambdabot> http://hackage.haskell.org/package/clay
17:46:40 <broma0> Anyone know how to fix 'cabal run' failing with something like 'can't load .so/.DLL for: .....'? The message also includes some info about 'undefined reference to blahblahblahblahblah_closure ....'
17:54:15 <geekosaur> broma0, does it also fail outside of a cabal sandbox?
17:54:32 <geekosaur> that error usually means you forgot to put some module in extra-modules: in a library
17:54:55 <geekosaur> so it didn't get added to the library and internal references to it fail when you later use the library
18:02:43 <lambda-11235> Is there a way to clear the screen in UI.NCurses? Besides copying a blank to every space?
18:03:26 <dmwit> I'm confident the answer is yes, never having even looked at UI.NCurses.
18:03:47 <dmwit> What package is this from?
18:03:57 <geekosaur> ncurses
18:04:01 <dmwit> ?hackage ncurses
18:04:01 <lambdabot> http://hackage.haskell.org/package/ncurses
18:04:04 <geekosaur> (not nanocurses or hscurses)
18:04:11 <geekosaur> but no built docs :(
18:04:35 <dmwit> 0.2.11 seems to have docs
18:07:13 <Bruuuuno> I have a list build with the do notation, I was wondering how to filter some data like in the list comprehention. http://lpaste.net/147929
18:08:17 <geekosaur> wtf. looks like most of the library routines are still missing in action :(
18:09:32 <dmwit> I mean, without ncurses it's nominally as easy as printing a few carefully chosen bytes. But that won't touch ncurses internal state.
18:09:43 <dmwit> I find it hard to believe ncurses doesn't have a "clear window" function built in.
18:09:45 <geekosaur> werase
18:09:54 <geekosaur> or wclear to force a screen clear
18:10:08 <geekosaur> but that, and about 75% of most ncurses functions, is missing
18:10:25 <dmwit> https://john-millikin.com/software/haskell-ncurses/reference/haskell-ncurses/latest/ has the docs for 0.2.14
18:11:11 <dmwit> and `clear` is an `Update ()` action in 0.2.14 at least
18:12:30 <mauke> what's the point of Update?
18:12:58 <dmwit> lambda-11235: So yeah, `mapM_ (flip updateWindow clear) windows >> render` seems like it would do what you want
18:13:02 <geekosaur> it's using the wnoutrefresh/doupdate paradigm to batch screen updates
18:13:32 <dmwit> Bruuuuno: `guard (a /= b)`
18:13:35 <geekosaur> otherwise if you make changes in multiple windows it will redraw for each window instead of doing the whole thing in a batch
18:13:42 <Bruuuuno> thx dmwit
18:16:30 <mauke> wait, this is still inefficient as it wraps wclear, not werase
18:18:22 <lambda-11235> dmwit, geekosaur: Thanks, it appears I have to update my version of ncurses.
18:19:09 <geekosaur> let's face it, it's wrapping (n)curses, it's gonna suck anyway >.>
18:22:25 <lambda-11235> Actually, I think the 
18:23:14 <lambda-11235> API for haskell NCurses is quite nice, if lacking in functionality.
18:23:36 <teurastaja> haskell for 8051?
18:24:06 <dmwit> Have you looked at brick? It seems quite nice for terminal UI. (For transparency: I work with the author, so I may be a bit biased. ;-)
18:25:02 <dmwit> teurastaja: I like your jokes, you should tell more...
18:25:31 <teurastaja> dmwit: at least some sort of lambda calculus
18:27:59 * hackagebot clarifai 0.1.0.1 - API Client for the Clarifai API.  https://hackage.haskell.org/package/clarifai-0.1.0.1 (jcanero)
18:37:04 <Gurkenglas> I want to mine a number of web pages for paragraphs like the ones in code font here https://forum.questionablequesting.com/threads/polyhistor-academy-original-setting-survival-quest.614/page-257#post-481825 , group them by types, extract data, etc. Can you recommend libraries?
18:40:47 <Cale> Gurkenglas: I can't see that (need an account on that forum), but tagsoup?
18:41:13 <Cale> Gurkenglas: and then, provided it's Haskell code, maybe something like haskell-src-exts to parse it
18:41:59 <Gurkenglas> Not haskell code, just numerical information that OP/the DM has tried to keep stuctured consistently
18:45:05 <tgeeky> any /r/haskell mods in here, please check out the post by guedo9834: https://www.reddit.com/r/haskell/
18:45:15 <tgeeky> it looks like a virus/phishing site.
18:45:58 <bitemyapp> tgeeky: you can report the post using the tools on Reddit as well
18:46:03 <tgeeky> bitemyapp: doing that now
18:46:05 <bitemyapp> tgeeky: it'll mail the mods on Reddit if you do
18:47:11 <tgeeky> bitemyapp: done. thanks.
18:48:04 <Gurkenglas> Where do I get "http :: String -> IO String"?
18:49:22 <Gurkenglas> (Yes, I could just use something that google spits out, but I might not end up with the best option...)
18:49:38 <maerwald> http "1+1" should yield what?
18:50:25 <Gurkenglas> An Error that that url could not be resolved, I guess.
18:50:45 <bitemyapp> tgeeky: cheers
18:52:22 <maerwald> openURIString :: String -> IO (Either String String)
18:52:25 <maerwald> from download-curl
18:56:45 <pikajude> hmm
18:57:06 <pikajude> how do I use Test.QuickCheck.Gen.elements to produce `Maybe` a member of the resulting list?
19:00:51 <broma0> Anyone ever run into problem during the linking phase of compilation? I'm getting 'undefined reference to XXX' printing out a ton with ExitFailure 1 as a result
19:01:14 <dmj`> broma0: did you specify all the modules in your project in the cabal file
19:02:39 <broma0> now i did :D
19:02:39 <broma0> thanks
19:04:53 <wolever> Is there any way to read from a Chan with a timeout?
19:05:31 <Gurkenglas> Does stack ignore any cabal hell problems that may already have been caused on a machine?
19:06:11 <dmj`> Gurkenglas: stack uses its own package repo located at ~/.stack I believe, so most likely yes (if you weren't using stack before)
19:07:07 <Gurkenglas> So I guess download-curl and tagsoup just cant be installed together
19:07:24 <maerwald> haha
19:08:00 <dmj`> Gurkenglas: stack should use stackage lts, so if those pkgs are on stackage then they should have compatible versions of those pkgs
19:08:04 <Gurkenglas> You'd think doing a get request would be in the prelude
19:09:22 <Gurkenglas> Too bad this vm is like 12 GB big or I could just send you the image :D
19:09:40 <ibrahim> Hi , im new to haskell
19:10:17 <Bruuuuno> hi new to haskell, I'm Bruno, nice to meet you
19:10:18 <mgsloan> Gurkenglas: The initial spec about GET requests came after the initial spec of Haskell, which included the Prelude
19:10:44 <mgsloan> Agreed, though, having stuff like that in base would be cool
19:11:02 <maerwald> it's a little bit too high level for my taste
19:12:05 <ibrahim> Has anyone here contributed to the Google Summer of code for Haskell ? , i wanted to apply for GSoC by contributing to haskell
19:12:14 <dmj`> Gurkenglas: that would require network to be folded into base
19:13:07 <ibrahim> ahh ! sorry forgot to introduce 
19:13:29 <ibrahim> i am ibrahim and i am from india :)
19:20:01 <Gurkenglas> blaaaaaargh I could've seen coming that wreq (which cabal-installs!) would have the same problem in opening that link that Cale did
19:20:34 <Gurkenglas> Can I have it... pretend... to be my browser, or something? ._.
19:22:18 <Gurkenglas> Maybe I could just manually save those ~300 pages...
19:24:33 <pavonia> Set the user agent of your browser and/or proper cookie for that website when sending the request
19:24:33 <geekosaur> Gurkenglas, you'd need to dig your credentials out of your browser. Or figure out how to automate your browse, which is a completely different problem
19:24:41 <geekosaur> (Browser credential stores are encrypted on disk)
19:25:20 <geekosaur> (cookies may not be, but then you have to be able to find your browser's cookie storage and hope it's a format something can read)
19:27:42 <geekosaur> Gurkenglas, http://hackage.haskell.org/package/webdriver
19:28:19 <geekosaur> (selenium webdriver bindings, if you want to try to automate your browser using your creds to scrape)
19:28:51 <Gurkenglas> Ah, that last one looks good, thanks
19:39:18 <Gurkenglas> The example links on http://hackage.haskell.org/package/webdriver (Ctrl-F example) don't seem to lead anywhere
19:43:12 <dmwit> ibrahim: If you have targeted questions, you may just want to ask them.
19:43:30 <dmwit> ibrahim: They're on-topic here, and if somebody knows the answer I'm sure they'll talk to you about it.
19:59:24 <sclv> talks now announced for composeconf, only a few days left on earlybird tickets :-) https://www.reddit.com/r/haskell/comments/3yh9so/compose_conference_talks_now_announced_only_a_few/
20:01:25 <Bruuuuno> is there a ghci command that can show haddock's documentation? Something like :i but with comments and examples
20:03:01 <Clint> sclv: the website seems moderately broken
20:04:16 <sclv> Clint: it probably is (work in progress) -- which part of the brokenness is tripping you?
20:05:18 <Bruuuuno> sclv It's kinda too far for me, do you think they will put video of the talks online?
20:05:19 <Clint> sclv: several of the navigation links don't seem to work, several of the pages don't have such links
20:05:35 <sclv> hah, yep
20:05:44 <sclv> we redid the architecture from last year and it got sorta busted
20:06:01 <sclv> i'm still in "holidays" mode but if nobody else has fixed it by tues I imagine I'll take a wack
20:07:10 <sclv> we also moved from all handcoded to some weird gh-pages jekyll template thing which didn't help
20:08:48 <sclv> Bruuuuno: yeah we'll put up video online -- the ones from last year are up http://www.composeconference.org/2015/summary/
20:09:12 <Bruuuuno> thanks, it look amazing :)
20:09:57 <bitemyapp> sclv: considered Hakyll?
20:10:23 <Clint> sclv: and as long as i'm complaining, lots of 2015 dates
20:10:44 <sclv> Clint: where are the 2015 dates, those are worth fixing!
20:11:02 <Clint> sclv: http://www.composeconference.org/jobs/
20:11:05 <Clint> i thought i saw more
20:11:11 <sclv> i don't "own" the website, just chip-in, otherwise I wouldn't have used either jekyll or hekyll :-)
20:11:56 <ReinH> sclv: o/
20:12:14 <Clint> hakyll was more fun when it was all about arrows
20:15:47 <bitemyapp> Clint: just a tool for me, don't really want "interesting" in an SSG.
20:16:41 <Clint> fair
20:22:27 <dmwit> Bruuuuno: There is haskell-docs but it is... a bit limited.
20:22:29 <dmwit> Could use some TLC.
20:22:32 <wolever> How can I unwrap an IO monad as part of a record creation? Ex, so I can include a Chan in a record: `let foo = Foo { fooChan=newChan }`
20:22:38 <Bruuuuno> tlc?
20:22:40 <sclv> ok, website slightly tweaked
20:22:51 <sclv> still sorta rough, but i'll let the main ppl running it sort it out
20:23:00 <sclv> tlc = "tender loving care"
20:23:20 <dmj`> wolever: sure why not
20:23:21 <dmwit> wolever: can't
20:23:31 <Gurkenglas> How should I write a Data.Text Text into a file? Just via converting to String first?
20:23:41 <jay6981> what is idiomatic haskell way to say: find (\x -> length x == 3) xs
20:23:43 <dmwit> wolever: But you can teach the consumers of your pure thing to consume an IO thing instead.
20:23:47 <dmwit> :t fmap
20:23:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:23:49 <dmwit> :t (=<<)
20:23:51 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:23:58 <dmj`> Foo <$> newChan <*> pure 3, where Foo { chan :: Chan, num :: Int }
20:24:04 <wolever> dmwit: so only option is `c <- newChan; let foo = Foo { … }`?
20:24:21 <dmwit> Gurkenglas: The text package offers a writeFile, I would expect.
20:24:29 <dmwit> Gurkenglas: ...and an hPutStr, too.
20:24:35 <wolever> dmwit: mmm that’s true.
20:24:35 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/text-0.11.3.1/doc/html/Data-Text-IO.html#v:writeFile
20:24:36 <dmwit> wolever: Essentially, yes.
20:24:42 <pdxleif> jay6981: That seems idiomatic to me; were you hoping to shorten it or something?
20:25:00 <Gurkenglas> Oh, it's in a different doc page, okay thanks
20:25:38 <pdxleif> @pl (\x -> length x == 3)
20:25:38 <lambdabot> (3 ==) . length
20:25:56 <dmwit> Whoa, ?pl knows about commutativity of (==)?
20:26:02 <dmwit> That's... kind of sophisticated.
20:26:37 <jay6981> pdxleif:  i always feel if i had to use the lambda notation i failed
20:26:45 <jay6981> maybe it's silly
20:26:46 <shachaf> @pl also knows about associativity of (+)
20:27:53 <wolever> dmwit: could you give an example of how fmap could be used here? (I’ve seen it referenced in this context, but I haven’t figured that out yet)
20:28:14 <dmwit> fmap (\chan -> Foo { fooChan = chan }) newChan
20:28:37 <wolever> Ah! okay
20:28:41 <wolever> Thanks dmwit 
20:28:47 <pdxleif> jay6981: I wouldn't worry about it too much. Sometimes maybe you can think of a good name for the intermediate variable that can help clarify things.
20:29:18 <jay6981> pdxleif:  good advice
20:29:24 <pdxleif> You could write that lambda point-free. You could make it a stand-alone function (or at least a let-binding). You could use other forms to filter the list, like do-notation or a list comprehension.
20:30:21 <pdxleif> > [x | x <- words "foo bar baz hello goodbye list", length x == 3]
20:30:22 <lambdabot>  ["foo","bar","baz"]
20:30:45 <jay6981> ah yes, i always forget about that syntax.
20:30:50 <dmwit> > [x | x@[_,_,_] <- words "foo bar baz hello goodbye list"]
20:30:51 <lambdabot>  ["foo","bar","baz"]
20:31:52 <dmwit> > ([x | x@[_,_,_] <- ["foo", repeat 'a']], [x | x <- ["foo", repeat 'a'], length x == 3])
20:31:57 <lambdabot>  mueval: ExitFailure 1
20:32:30 <dmwit> > [x | x@[_,_,_] <- ["foo", repeat 'a']]
20:32:32 <lambdabot>  ["foo"]
20:32:41 <dmwit> > [x | x <- ["foo", repeat 'a'], length x == 3]
20:32:46 <lambdabot>  mueval: ExitFailure 1
20:34:46 <pdxleif> I guess you could use dependent types or liquid haskell or something and track the length of the lists at compile time?
20:35:33 <dmwit> Sure. Or track it at runtime pretty easily with a newtype.
20:35:51 <dmwit> I've used `newtype LengthList a = (Sum Integer, [a])` to good effect before.
20:36:25 <dmwit> `singleton x = (1, [x])` gives you a pretty complete API just from existing class instances.
20:37:41 <dmwit> uh
20:37:45 <dmwit> s/newtype/type/ lol
20:53:04 * hackagebot bighugethesaurus 0.1.0.0 - API wrapper for Big Huge Thesaurus  https://hackage.haskell.org/package/bighugethesaurus-0.1.0.0 (TheKing)
20:55:52 <Gurkenglas> How do I tell http://hackage.haskell.org/package/webdriver-0.6.3.1 to use the firefox config I get when I open firefox myself? "defaultConfig { wdCapabilities = defaultCaps { browser = firefox } }" doesn't allow it to be automatically logged in into sizes
20:55:54 <Gurkenglas> *sites
21:08:31 <Gurkenglas> Woo the downthemall firefox addon allowed me to remove the HTTP part of the problem
21:18:05 * hackagebot clarifai 0.1.1.0 - API Client for the Clarifai API.  https://hackage.haskell.org/package/clarifai-0.1.1.0 (jcanero)
21:19:55 <qmm> i started this ghci session using stack: http://lpaste.net/147935
21:27:04 <qmm> after importing Prelude, i get a different error
21:27:05 <qmm> http://lpaste.net/147936
21:28:46 <qmm> no show for IO.String
21:29:15 <nkaretnikov`> thoughtpolice: looking forward to watching your compose conf talk on cryptol. please make sure that it's recorded :)
21:32:05 <thoughtpolice> nkaretnikov`: thanks! :) They were all recorded last year when I was there and went online within 1 week, so I think a recording will pop up quickly
21:43:08 <qmm> i'll return later
22:23:34 * hackagebot wai-app-file-cgi 3.0.9 - File/CGI/Rev Proxy App of WAI  https://hackage.haskell.org/package/wai-app-file-cgi-3.0.9 (KazuYamamoto)
22:28:34 * hackagebot mighttpd2 3.2.10 - High performance web server on WAI/warp  https://hackage.haskell.org/package/mighttpd2-3.2.10 (KazuYamamoto)
22:48:59 <Dupree> s
22:49:22 <mauke> k
22:53:46 <Dtgr> i
22:58:17 <sgronblo> How would I convert a Word8 to a String of hex chars?
23:09:13 <Parapsych> Yep
23:09:19 <Parapsych> Im here
23:09:23 <Parapsych> Don't fear
23:10:55 <benzrf> :?
23:27:44 <sgronblo> Do I have to explicitly import Text.Show to use a show :: a -> String?
23:28:18 <sgronblo> I seem to be getting an a -> [Word8] currently
23:33:09 <Cale> sgronblo: The show in the Prelude should give you a String
23:33:11 <sgronblo> Also. Sometimes I find some function on hackage, install the module, then try to import the module as shown on hackage and get an error that the module doesn't exist.
23:33:30 <sgronblo> For example Text.Show.ByteString
23:34:25 <sgronblo> Cale: Yeah I was under some other mistaken assumptions that made me think the show was working weirdly
23:35:48 <sgronblo> Hmm, or is it because runhaskell doesn't care about my Cabal sandbox?
23:36:15 <Cale> runhaskell certainly doesn't care about your sandbox
23:36:34 <sgronblo> Hmm, does Cabal have something like runhaskell?
23:37:55 <Cale> cabal exec runghc Foo.hs
23:38:59 <wangs> hi hello
23:40:37 <sgronblo> Cale: Thanks! It seems to work.
23:44:14 <sgronblo> Is it common that you feel confused about which methods use lazy and which use strict bytestrings or am I just a noob?
23:49:09 * hackagebot hasql 0.15.1 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.15.1 (NikitaVolkov)
23:49:14 <srhb> sgronblo: It's perfectly normal.
23:49:45 <srhb> sgronblo: It helps to just import one of them, and always qualified.
23:57:01 <sgronblo> srhb: but what about when you use some other library that has a function that returns a lazy one, then if you imported strict bs you have to start converting, right?
23:57:20 <srhb> sgronblo: Yes, if there's no alternative strict function.
