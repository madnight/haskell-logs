00:06:29 <jle`> int-e: can we get an instance of lambdabot on #haskell.vn? :)
00:07:41 * hackagebot statsd-client 0.1.0.1 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.1.0.1 (keith_duncan)
00:07:41 * hackagebot timelike 0.1.0 - Type classes for types representing time  https://hackage.haskell.org/package/timelike-0.1.0 (esz)
00:32:35 * hackagebot haphviz 0.1.0.0 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.0.0 (Norfair)
00:40:09 <ReinH> q
00:52:39 * hackagebot protocol-buffers 2.1.11 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.11 (k_bx)
00:52:41 * hackagebot protocol-buffers-descriptor 2.1.11 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.11 (k_bx)
00:58:13 * hackagebot hprotoc 2.1.11 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.11 (k_bx)
00:58:15 * hackagebot protocol-buffers 2.1.12 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.12 (k_bx)
00:58:17 * hackagebot protocol-buffers-descriptor 2.1.12 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.12 (k_bx)
00:58:19 * hackagebot hprotoc 2.1.12 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.12 (k_bx)
00:58:21 * hackagebot haphviz 0.1.0.1 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.0.1 (Norfair)
01:03:13 * hackagebot language-vhdl 0.1.2.2 - VHDL AST and pretty printer in Haskell.  https://hackage.haskell.org/package/language-vhdl-0.1.2.2 (mararon)
01:13:13 * hackagebot language-vhdl 0.1.2.3 - VHDL AST and pretty printer in Haskell.  https://hackage.haskell.org/package/language-vhdl-0.1.2.3 (mararon)
01:33:22 <apankiv> hello everyone
01:46:21 <fr33domlover> Hello! I'm trying to get the URI <acct:fr33domlover@microca.st> get parsed such that microca.st is detected as the hostname, which i  need to extract, but both network-uri and uri-bytestring think it is part of the path :-/
01:46:25 <fr33domlover> Why is that?
01:46:50 <fr33domlover> I'm implementing WebFinger and it seems other implementations successfuly extract microca.st from that URI
01:47:03 <fr33domlover> (i mean, in other languages)
01:47:13 <fr33domlover> e.g. node.js
01:52:13 <fr33domlover> I just tried an online URI parser, same result
01:52:35 <fr33domlover> Weird... how should one then extract the host from there without wheel reinvention...
01:52:43 * fr33domlover goes to URI specs
02:08:15 * hackagebot aeson-parsec-picky 0.1.0.1 - Alternative JSON parser based on Parsec and Aeson  https://hackage.haskell.org/package/aeson-parsec-picky-0.1.0.1 (MatejKollar)
02:25:40 <ironChicken> any suggestions how i might be able to progress with <https://mail.haskell.org/pipermail/haskell-cafe/2015-December/122438.html>?
02:26:05 <ironChicken> e.g. a better way of asking the question? or a debugging tip?
02:38:40 * hackagebot statsd-client 0.1.0.2 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.1.0.2 (keith_duncan)
02:40:58 <mmai> hi, beginner question here
02:41:31 <mmai> why do [1.0 ^ n / n | n <- [1]] raise a ambiguous type variable error
02:41:49 <mmai> but  not "let n = 1 in 1.0 ^ n / n 
02:41:51 <mmai>  ?
02:45:46 <verement> > [1.0 ^ n / n | n <- [1]]
02:45:49 <lambdabot>      No instance for (Show t0)
02:45:49 <lambdabot>        arising from a use of ‘show_M719826018903505346318526’
02:45:49 <lambdabot>      The type variable ‘t0’ is ambiguous
02:46:11 <verement> > let n = 1 in 1.0 ^ n / n
02:46:15 <lambdabot>  1.0
02:47:42 <verement> :t [n | n <- [1]]
02:47:44 <lambdabot> Num t => [t]
02:48:00 <verement> :t let n = 1 in n
02:48:02 <lambdabot> Num a => a
02:51:34 <verement> mmai: I suspect it has to do with Haskell's defaulting mechanism
02:51:42 <ARM9> > do n <- [1]; return $ 1.0 ^ n / n
02:51:43 <lambdabot>      No instance for (Show r0)
02:51:44 <lambdabot>        arising from a use of ‘show_M686693177459331662918648’
02:51:44 <lambdabot>      The type variable ‘r0’ is ambiguous
02:51:56 <ARM9> something something list monad implementation
02:52:16 <ARM9> although I suspect it's goes deeper than that
02:52:27 <ARM9> s/'s//
02:52:29 <arkeet> :t let n = 1 in 1.0 ^ n / n
02:52:31 <lambdabot> Fractional a => a
02:53:18 <verement> ironChicken: maybe share the output from a debugging session?
02:53:25 <arkeet> n is being used at 2 different types there.
02:53:26 <arkeet> :t (^)
02:53:28 <lambdabot> (Integral b, Num a) => a -> b -> a
02:53:37 <arkeet> :t (/)
02:53:38 <lambdabot> Fractional a => a -> a -> a
02:53:40 * hackagebot http-client 0.4.25 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.25 (MichaelSnoyman)
02:54:48 <arkeet> like
02:54:52 <arkeet> n is polymorphic in the let binding
02:54:57 <arkeet> but not in the list comprehension
02:56:23 <arkeet> hm, why is that.
02:56:45 <arkeet> :t let n = 1 in (1.0 ^ n / n, n)
02:56:48 <lambdabot> (Fractional t, Num t1) => (t, t1)
02:56:53 <arkeet> yeah.
02:57:05 <arkeet> :t let [n] = [1] in 1.0 ^ n / n
02:57:07 <lambdabot> Fractional a => a
02:57:12 <arkeet> hm.
02:58:34 <mmai> @arkeet thank you, I see where I must do type conversions 
02:58:35 <lambdabot> Unknown command, try @list
03:09:56 <MarcelineVQ> arkeet: it's because [1] defaults to integer, possibly due to enumeration sugar (e.g. [1,2,3]), not sure, so the comprehension tries to match Integral and Fractional
03:12:12 <mmai> arkeet & MarcelineVQ : thank you!
03:19:53 <MarcelineVQ> funny
03:20:29 <MarcelineVQ> > let g = 1 in 1.0 ^ g/g
03:20:31 <lambdabot>  1.0
03:20:34 <MarcelineVQ> > let g = 1 in 1.0 ^ (g/g)
03:20:36 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
03:20:36 <lambdabot>      from the context (Fractional a)
03:20:36 <lambdabot>        bound by the inferred type of it :: Fractional a => a
03:21:31 <quicksilver> MarcelineVQ: defaulting like that would give a "no instance Fractional Integer" error
03:21:49 <quicksilver> so that's not what is happening.
03:22:03 <quicksilver> the error is "ambiguous type variable"
03:22:50 <quicksilver> the error arising because the defaulting mechanism is *trying* to default the whole expression
03:22:53 <quicksilver> but it can't
03:23:01 <quicksilver> @type [1.0 ^ n / n | n <- [1]]
03:23:02 <lambdabot> (Fractional t, Integral t) => [t]
03:23:11 <quicksilver> because nothing on the defaults list satisfies both of those.
03:28:26 <MarcelineVQ> thank you :>
03:58:42 * hackagebot hindent 4.6.0 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.6.0 (ChrisDone)
04:03:57 <ironChicken> verement: good idea: <http://pastebin.com/HMKN2baj>
04:08:49 * hackagebot statsd-client 0.1.0.3 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.1.0.3 (keith_duncan)
04:38:06 <frerich> Is there a common idiom (or a library maybe) for defining APIs in Haskell which deal with stateful things (say: a turn-based game or a network connection) such that calling the wrong functions in the wrong state is impossible (e.g. invalid turns in a game are compile errors or connecting a connected socket is a compile error)? So far, I always did some 'ad-hoc' solution in which operations which cause a state transition yielded a new typ
04:38:06 <frerich> e of 'value' (now that I think about it, maybe phantom types would be useful here)
04:39:20 <zomg> Maybe you could define the states and available functions as data types in some fashion
04:39:42 <zomg> Ie. data GameState = Foo { blah :: a -> b } | ...
04:40:05 <zomg> well, I'm not entirely sure if that would work, but something like that :p
04:41:50 <frerich> Well yeah, I could have something like 'data Game = Game { state :: GameState }' with 'data GameState = TileMoved | CardDrawn'. Applying a move could then be 'apply :: Game -> Move -> Either InvalidTurn Game' or so. That's more of a "value-level" solution.
04:42:20 <Profpatsch> Hm, where is the difference between a Concurrent.Chan and Pipes.Concurrent?
04:42:28 <frerich> I guess I could try a phantom type such that I have 'data TileMoved' and 'data CardDrawn' and 'data GameState a = Game' such that the state of the game is encoded in its type...
04:42:42 <Profpatsch> Pipes seem to be more powerful.
04:42:55 <Profpatsch> They remind me of golang’s channels a lot.
04:43:35 <Profpatsch> With their combination and work distribution abilities.
04:53:15 <quicksilver> frerich: someone wrote a PhD these on doing it things like the socket example
04:53:47 <quicksilver> frerich: the type signatures are beautiful. Please sit down before reading https://hackage.haskell.org/package/sessions-2008.7.18/docs/Control-Concurrent-Session.html
05:11:32 <frerich> quicksilver: Ah, thanks. Now it's all clear.
05:12:05 <hexagoxel> frerich: indexed monads
05:12:20 <frerich> I seem to recall this 'state-based interface' idea (IIRC it was about IPC systems at that point) was called 'protocols' or something like that, at least in the Haskell world.
05:12:35 <frerich> Maybe it was also one typeclass per state or so.
05:13:58 * hackagebot bytestring-tree-builder 0.2.2.1 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.2.1 (NikitaVolkov)
05:32:24 <lamefun> Are there dynamic capability-based values in Haskell?
05:32:56 <haskell267> hello, I want to ask about a specific situation i am in. I am fairly new to haskell but I am hoping someone could help me with this
05:33:08 <haskell267> I have a type instance Element Integer = Integer
05:33:32 <haskell267> but I want to do something like type instance Element (Integral a => a) = a
05:33:44 <haskell267> does anyone have a solution for this?
05:35:03 <lyxia> I did not understand what you are asking about haskell267 
05:35:26 <haskell267> in the Data.MonoTraversable module
05:35:41 <haskell267> there's an Element type family
05:35:48 <haskell267> for which i want to make an instance
05:36:08 <haskell267> I already have the instance : type instance Element Integer = Integer
05:36:11 <lyxia> Okay
05:36:14 <haskell267> but i want to make it generic
05:36:21 <haskell267> for all integral types
05:36:37 <lyxia> that's an odd thing to want
05:36:39 <haskell267> is it possible?
05:38:13 <haskell267> it is kind of odd
05:38:20 <haskell267> but I am trying to see if I could do this
05:40:52 <haskell267> you can do that while making typeclass instances
05:41:02 <haskell267> but you can't while making type family instances?
05:41:46 <liste> why are you doing that?
05:42:24 <haskell267> because i want to try to treat integral types as a vector of digits
05:42:43 <haskell267> i can do it for int and integer etc seperately
05:42:53 <haskell267> i can make all my functions generic to integral types
05:43:12 <haskell267> but i can't make a type instance that's generic this way
05:43:41 <haskell267> so if i want it to be part of the MonoFoldable and MonoFunctor typeclasses for example
05:43:44 <mudri> Quick question: is there any way to have a terminal application that overwrites (or appears to overwrite) its output? I'm thinking of what curl does.
05:44:23 <liste> haskell267 how about instance Integral a => Element a ?
05:44:57 <haskell267> parse error
05:45:05 <ARM9> mudri ansi escape codes, ncurses, etc.
05:45:05 <lyxia> haskell267: don't define it over integers but over a newtype then
05:45:25 <hexagoxel> haskell267: haskell582 asked the same thing ~7 hours ago, and haskell748 ~15 hours ago. may i ask what kind of social experiment this is?
05:45:35 <ARM9> note that ansi escape codes are not portable (windows cmd and powershell don't support them by default)
05:46:18 <liste> @hackage vty -- mudri for haskell, you can use this
05:46:18 <lambdabot> http://hackage.haskell.org/package/vty -- mudri for haskell, you can use this
05:46:45 <mudri> Thanks, you two.
05:46:58 <haskell267> <lyxia> Ok what do you mean?
05:47:13 <liste> though for windows, it's cygwin only
05:51:24 <quicksilver> mudri: tere is a package for exactly that
05:51:32 <lyxia> haskell267: "newtype DigitsOf a = DigitsOf a" "type instance Element (DigitsOf a) = a". Add the constraint in the Mono(Functor|Foldable|etc) instance definitions.
05:51:41 <quicksilver> mudri: https://joeyh.name/code/concurrent-output/
05:51:45 <linduxed> hey guys
05:52:06 <linduxed> i wrote a super simple "hello world" file
05:52:08 <cow_2001> ? joeyh ?
05:52:11 <cow_2001> err
05:52:23 <linduxed> main = do\nputStrLn "Hello World!"
05:52:25 <linduxed> basically
05:52:31 <linduxed> with the main = IO () at the start
05:52:38 <linduxed> i want to dump the intermediate code
05:52:45 <linduxed> but when i do something like this:
05:52:45 <ARM9> that should probably be main :: IO ()
05:52:53 <linduxed> yeah
05:52:54 <raichoo> ghc -ddump-simpl --make test.hs
05:52:55 <linduxed> got that
05:52:57 <linduxed> ooooh
05:53:01 <linduxed> so the --make is necessary?>
05:53:07 <linduxed> right now it doesn't output anything
05:53:31 <linduxed> hmmm
05:53:36 <linduxed> still no output
05:53:42 <raichoo> -fforce-recomp
05:54:05 <linduxed> aaaah
05:54:07 <linduxed> yes
05:54:10 <linduxed> when i removed the files it worked
05:54:29 <raichoo> linduxed: just use -fforce-recomp
05:54:34 <raichoo> That does the trick
05:54:54 <warbo> is there a way to write a generic function with typeclass-specific overrides?
05:55:08 <warbo> extQ from SYB lets us provide type-specific overrides
05:55:27 <warbo> but I'd like a function which uses a default implementation, unless the argument is in some typeclass
05:55:38 <lyxia> warbo: playing around with overlapping instances allow that
05:55:49 <linduxed> raichoo: yes, that workes!
05:55:52 <linduxed> *works
05:56:13 <raichoo> lyxia: You mean something like this? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#class-default-signatures
05:58:13 <warbo> lyxia: are you sure? I've tried similar things in the past, but the context wasn't used for choosing the instance
05:58:54 <warbo> for example, if I have "instance Foo a where..." for the default, and "instance (Bar a) => Foo a where..." for the override, the "Bar" constraint wouldn't affect the choice of instance
05:59:46 <lyxia> ah, right. The way I was thinking involved manually defining instances for the types you want
05:59:55 <lyxia> instances of Foo
06:02:05 <lyxia> There is something that allows the dispatch you are thinking of... I can't remember what it's called
06:02:09 <warbo> unfortunately the only thing I can rely on is a Typeable constraint
06:02:27 <quicksilver> there is no safe way to do what you want
06:02:34 <quicksilver> as you say, it simpy isn't how contexts work
06:02:39 <warbo> quicksilver: is there an unsafe way, though?
06:02:42 <quicksilver> yes
06:03:11 <warbo> essentially, I have a bunch of values which are getting wrapped up into a "Sig" type, then elsewhere they're extracted from that Sig
06:03:58 <warbo> even though I know what types they are, the only information I have when they come out is that they're Typeable
06:04:00 * hackagebot hspec-wai 0.6.4 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.6.4 (SimonHengel)
06:04:07 <warbo> (the Sig stuff is not my code, so I can't alter it)
06:04:19 <Sofiaraj> m}
06:04:52 <zcourts> Why is the "where" decls in main = do print hello where hello="Hello world" valid? I'm looking at https://www.haskell.org/onlinereport/haskell2010/haskellch10.html and can't see how a where is valid
06:04:57 <lyxia> https://github.com/mikeizbicki/ifcxt#ifcxt warbo 
06:05:34 <cow_2001> why can't we have like a mini haskell compiler written in c used to implement all haskell compilers? i am not a cs. i've just recently learned about trusting trust and that it is possible to mitigate using compiler pluralism, or somesuch.
06:05:58 <warbo> lyxia: aha, that looks exactly what I'm after :)
06:06:47 <quicksilver> zcourts: because that 'main' thing is a 'decl'
06:07:17 <quicksilver> zcourts: and decls have 'rhs' and 'rhs' has a where clause
06:07:24 <lyxia> warbo: I think it does what I'm thinking of, automatically.
06:08:07 <cow_2001> https://mail-index.netbsd.org/tech-pkg/2013/12/06/msg012317.html
06:08:12 <zcourts> ahhhhhh, yeah I see. Thanks quicksilver
06:08:59 <quicksilver> cow_2001: unfortunately GHC isn't written in haskell.
06:09:55 <cow_2001> :|
06:10:10 <ocramz> hi all
06:12:51 <ocramz> can someone explain MonadIO in simple terms? I can appreciate the operational consequences of not having to write as many `lift`s as you have layers, but I still don't understand the difference with regular IO
06:13:11 <mauke> what difference?
06:13:30 <ocramz> you mean there is none?
06:13:32 <lyxia> ocramz: it doesn't have to be a monad transformer stack.
06:15:00 <lyxia> ocramz: it allows to embed IO actions while hiding the implementation.
06:15:05 <mauke> if you mean between MonadIO and IO, MonadIO is a class, IO is a type
06:16:39 <ocramz> mauke: sure, that I understand. I don't understand the implications yet
06:17:06 <ocramz> and lyxia's comment, while intriguing, is still rather cryptic
06:17:47 <quicksilver> you could sensibly give a MonadIO instance to any monad you build yourself using IO as a core component
06:17:49 <mauke> MonadIO provides a general interface to embed arbitrary IO actions into anything that wraps IO
06:18:00 <quicksilver> it wouldn't have to be a monad transformer in general.
06:18:06 <quicksilver> I think that's all lyxia was saying.
06:19:10 <quicksilver> although there is certainly a *sense* in which it would be a monad transformer; because liftIO obeys the transformer laws even if you don't have a transformer in your type.
06:19:24 <quicksilver> s/obeys/is expected to obey/;
06:21:18 <jackhill> Hi, can any suggest how to use mysql-simple to substitute in field names into queries? I'm tring query conn "select ? from pur_ap_recur_pmt_typ_t;" (Only "RECUR_PMT_TYP_CD")
06:21:19 <ocramz> but.. what is a "home-made monad that uses IO as core component", that doesn't have to be an MT? I thought the very definition of MTs was this "overlaying" of characteristic operations
06:21:39 <jackhill> which yealds this query: select 'RECUR_PMT_TYP_CD' from pur_ap_recur_pmt_typ_t; instead of the expected select `RECUR_PMT_TYP_CD` from pur_ap_recur_pmt_typ_t;
06:21:56 <quicksilver> the definition of a Monad Transformer is that it's a type constructor, ocramz 
06:22:07 <quicksilver> "t m" s.t. when 'm' is a Monad, 't m' is a Monad.
06:22:19 <jackhill> This is for a quick hack with tructed data, so an unsafe way of doing it would probably be okay.
06:22:32 <quicksilver> (in some cases we weaken that to "for at least some Monads m")
06:23:00 <mauke> ocramz: newtype MyType a = MyType (Integer -> IO (Set String, a)  -- I can define Monad and MonadIO instances for this
06:23:04 <mauke> )
06:23:55 <ocramz> mauke: this I would call a continuation, right? like State and so on
06:24:21 <quicksilver> exactly and the point is mauke's type doesn't take the form "t m"
06:24:37 <quicksilver> I would personally find it strange to call State "a continuation"
06:24:47 <quicksilver> unless you think all functions are continuations.
06:25:02 <ocramz> hmm
06:25:11 <mauke> how is this a continuation?
06:26:52 <ocramz> no, sloppy me. Thanks for correcting quicksilver and mauke
06:27:06 <ocramz> anyway, the point about MonadIO
06:29:01 <ocramz> being it a typeclass, we can derive instances of it for newtypes. I'll re-start by reading the haddocks, doing reverse searches on github and so forth
06:30:37 <mauke> bah, I did it wrong
06:30:48 <mauke> I meant to type (Set String, IO a)
06:31:58 <ocramz> mauke: so, now there's an IO action inside the tuple. When will it be run?
06:33:56 <mauke> when it becomes part of main
06:34:18 <aweinstock> or if you call unsafePerformIO on it
06:36:02 <ocramz> sure; ok my question was imprecise. mauke, what does that type change imply, what did you mean with it?
06:37:41 <mauke> ?
06:37:47 <aweinstock> return x = const (Set.empty, return x) :: Integer -> (Set String, IO a)
06:37:50 <warbo> lyxia: thanks, I've got it to type-check now; although I may have to fiddle with imports, etc. to make sure it can find the instances :)
06:38:36 <aweinstock> return x = const (return (Set.empty, x) :: a -> (Integer -> IO (Set String, a))
06:38:56 <aweinstock> (I made a mistake, a missing "a ->" in the first one)
06:39:42 <aweinstock> @unmtl ContT
06:39:42 <lambdabot> Plugin `unmtl' failed with: `ContT' is not applied to enough arguments, giving `/\A B C. (C -> B A) -> B A'
06:40:02 <aweinstock> @unmtl ContT IO
06:40:02 <lambdabot> Plugin `unmtl' failed with: `ContT IO' is not applied to enough arguments, giving `/\A B. (B -> A IO) -> A IO'
06:41:33 <aweinstock> :t StateT
06:41:35 <lambdabot> (s -> m (a, s)) -> StateT s m a
06:42:06 <aweinstock> ocramz: the first one is kind of closer to StateT (not sure if that's relevant though)
06:42:22 <mauke> @unmtl ContT r IO a
06:42:23 <lambdabot> (a -> IO r) -> IO r
06:42:58 <mauke> @unmtl ReaderT Int (WriterT (Set String) IO) a
06:42:58 <lambdabot> Int -> IO (a, Set String)
06:43:54 <aweinstock> mauke: can (Int -> (IO a, Set String)) be expressed as an mtl stack?
06:44:04 <aweinstock> (and was that the point, if it's not?)
06:45:14 <mauke> at this point I'm not sure what I'm thinking
06:45:15 <ocramz> aweinstock, mauke: wow, didn't know this `unmtl` 
06:45:56 <mauke> it's probably better if you ignore me and play around with it yourself :-)
06:50:40 <pavonia> jackhill: It indeed seems to do a non-standard escaping here, I can't find any reference to escape using backticks in the sources. What you can do is to add a newtype wrapper for your column names, write a Param instance that doesn't do any escaping other than adding the backticks, and use that wrapper for the query values
06:54:03 <pavonia> jackhill: On the other hand, I think parameter substitution not supposed to be used for table or column names, only for values
07:03:18 <jackhill> pavonia: cool, thanks, I'll look into doing that.
07:04:53 <jackhill> pavonia: yes, I expect that what I am doing is not typical. What I am really trying to do: I have a whole bunch of csv files that correspond to different tables, and I want to see what records (by matching on primary key) are already in the database
07:07:24 <nemesit|znc> are there any large haskell projects?
07:07:35 <OverCoder> What kind of projects
07:07:44 <nemesit|znc> is haskell fast? I really like what I've seen till now
07:07:49 <nemesit|znc> OverCoder: dunno anything
07:08:18 <OverCoder> Ofcourse there is (I mean probably but never searched for), and yeah Haskell is fast
07:08:37 <OverCoder> If you want to compare it to others, well, C/C++ performs faster, Haskell performs like.. Java
07:08:56 <nemesit|znc> that would be okish performance
07:09:03 * hackagebot type-combinators 0.2.0.0 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.0.0 (KyleCarter)
07:09:08 <OverCoder> Similar performance with Java, and ofcourse depends on what is being done, that's of course from the benchmarks I've seen online
07:09:22 <nemesit|znc> cool
07:09:47 <maerwald> :t treeViewGetModel
07:09:48 <lambdabot> Not in scope: ‘treeViewGetModel’
07:10:08 <OverCoder> If you have an android phone, then you are already seeing how Java performs (except with 6.0 due to ART)
07:10:29 <nemesit|znc> OverCoder: is it possible to integrate well with c libraries or others?
07:11:03 <maerwald> depends
07:11:05 <OverCoder> I don't know at all, because I've been learning Haskell and hasn't started making real use of it, so I don't know, someone might answer you here
07:11:20 <OverCoder> haven't*
07:11:22 <nemesit|znc> k just started by accident too xD
07:11:29 <maerwald> it's relatively easy to USE C in haskell, but that doesn't mean it INTEGRATES well
07:11:57 <OverCoder> maerwald, Can I pass asm code strightforward?
07:12:02 <nemesit|znc> just wonder whether I could write gui apps with it
07:12:02 <maerwald> it often integrates horribly which can be seen with library bindings like gtk+
07:12:18 <maerwald> that will be a pain
07:12:23 <ARM9> haskell is not very good with guis due to libraries being lackluster, ime
07:12:48 <OverCoder> Alright so why can't one come up and make some Haskell library for that
07:12:57 <Cathal> My own experience with calling Haskell from C was pretty good
07:13:00 <ARM9> because it's a niche nobody cares about
07:13:05 <nemesit|znc> if it integrated well with swift that would be neat
07:13:11 <nemesit|znc> dunno if thats possible
07:13:13 <OverCoder> Ah alright but so it's doable huh?
07:13:16 <maerwald> people are dabbling with FRP wrt guis, but I don't even think that's the right way to go
07:13:20 <OverCoder> Alright I'll do it :D
07:13:25 <ARM9> have fun
07:15:09 <nemesit|znc> what are you guys using haskell for?
07:15:32 <maerwald> example: http://lpaste.net/146907 <- mapping haskell typesystem over weakly typed gtk+ library results in such mistakes. The setter method uses a class, the get method a specific instance, which is wrong (at least if you look at the C functions). Now you are screwed
07:16:14 <nemesit|znc> yeah but swift is typed
07:16:22 <nemesit|znc> and translating haskell to swift works
07:16:37 <nemesit|znc> I'm not sure how to connect the two though
07:16:46 <maerwald> I don't know what you mean with Swift, the language?
07:16:50 <nemesit|znc> yeah
07:17:33 <maerwald> I doubt that's reasonably possible, but I could be wrong
07:18:04 <nemesit|znc> I know that haskell for mac does work with some apple libraries (probably rewritten for haskell, dunno how they did it)
07:18:04 <maerwald> and swift is so alpha that you end up with obj-c types anyway
07:18:12 <nemesit|znc> too lazy too reverse the app xD
07:19:02 * hackagebot type-combinators-quote 0.1.0.0 - Quasiquoters for the 'type-combinators' package.  https://hackage.haskell.org/package/type-combinators-quote-0.1.0.0 (KyleCarter)
07:19:41 <dfeuer> @quote athan Monotonicity, that's an order.
07:19:41 <lambdabot> No quotes for this person. Whoa.
07:19:51 <dfeuer> @remember athan Monotonicity, that's an order.
07:19:51 <lambdabot> It is stored.
07:39:18 <mmachenry> Anyone interested in having an STM performance tuning discussion? I have a n STMContainers.Map.Map of my own data type that contains a TArray of Int and Control.STM.TBQueue. When reading through them for the first one that can produce a value, it takes a longer than acceptable.
07:39:18 * hackagebot clash-prelude 0.10.4 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.4 (ChristiaanBaaij)
07:39:24 <mmachenry> I am doing a lot of reads of the TArray and it hurts performance. 
07:40:41 <mmachenry> I am considering rewriting the Map such that any updates to the TQueues puts them into a bucket wherein they are either readable or have nothing to read.
07:41:29 <mmachenry> But maintaining that data structure might be a bit of a pain as well. 
07:41:59 <mmachenry> I could go into details more but I feel like I'm flooding the channel with no one listening so perhaps if anyone wants more details let me know.
07:44:18 * hackagebot clash-lib 0.6.6 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.6 (ChristiaanBaaij)
07:44:20 * hackagebot clash-ghc 0.6.6 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.6 (ChristiaanBaaij)
07:44:44 <phaazon> ocharles__: that Some type you told me about on reddit is totally awesome!
07:44:59 <phaazon> data Some :: (k -> *) -> * where { Some :: f a -> Some f }
07:50:10 <OverCoder> Guys, does sort function in Data.List sorts lists using quicksort?
07:50:28 <quicksilver> doubt it
07:50:38 <quicksilver> quicksort isn't great for list
07:50:44 <OverCoder> Why
07:50:49 <zenzike> OverCoder: it's a variation on mergesort
07:51:01 <OverCoder> And if it was, is sort really the best way to sort stuff?
07:51:17 <pavonia> Define "best"
07:51:28 <Xe> does aeson depend on the order of the things in the json string?
07:51:44 <quicksilver> quicksort isn't great for List because the cleverness of the quicksort algorithm is about doing it in-place with a mutable array
07:51:54 <quicksilver> since List isn't a mutable array, that advantage doesn't really apply.
07:52:03 <phaazon> I thought it was a merge sort
07:52:08 <quicksilver> it is a merge sort, yes.
07:52:16 <phaazon> :)
07:52:24 <OverCoder> Hm, but how did I make a quicksort function earlier? but I used to call it with literals
07:52:26 <quicksilver> an optimised one which detects already monotonic sequences
07:52:45 <quicksilver> you can make a function in haskell which resembles the description of quick sort, yes
07:52:53 <quicksilver> it's quite famous because it's easy to write
07:53:08 <phaazon> maybe there’s a way to do it in place with ST?
07:53:13 <maerwald> yes
07:53:17 <quicksilver> but it doesn't have the same running time behaviour as the classic quick sort
07:53:23 <OverCoder> Yeah and? that means I should use it rather than Data.List's sort?
07:53:27 <quicksilver> because the main reason that is so fast is to do with the way it swaps things in place.
07:53:35 <maerwald> http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html
07:53:38 <quicksilver> no, as I have said twice now, you shouldn't use it because it's not fast.
07:53:52 <quicksilver> Data.List sort is good
07:53:56 <OverCoder> Uh ok
07:53:57 <quicksilver> it might be the best around for the list data structure.
07:54:15 <quicksilver> phaazon: of course you can, yes (write quicksort using a mutable data structure in haskell)
07:54:23 <quicksilver> it would be weird if you couldn't, wouldn't it?
07:54:23 <quicksilver> :)
07:54:28 <quicksilver> but List isn't that structure.
07:54:34 <maerwald> see the link above
07:54:52 <quicksilver> you could pack your list into an array of some kind, quick sort, and stream it back out, but I doubt that would be quicker in the typical case.
07:56:23 <trevorb> Hey guys, is it possible to use haskell98 libraries with haskell2010?
07:56:33 <trevorb> My google-fu seems to be failing me...
07:57:39 <Xe> https://gist.github.com/Xe/c2555314947f04c432f8
07:57:43 <OverCoder> trevorb, my google-fu is working >.>
07:58:15 <trevorb> OverCoder: would you mind sharing your search terms?
07:58:56 <OverCoder> trevorb, are haskell98 libs compatible with haskell2010
07:59:13 <OverCoder> trevorb, haskell98 libs comaptibility
07:59:19 <Xe> what am I doing wrong in that gist?
07:59:28 <lingxiao> is there a datatype that i can use to express fixed length lists?
07:59:40 <lingxiao> doens't have to be a list, just some generic storage concept
07:59:45 <diphtherial> hey, i'm attempting to compute the area of some triangles as a personal exercise, but i'm running into a problem with my understanding of the type system: https://dpaste.de/8sAH
08:00:01 <fryguybob> mmachenry: How are you making the values in your Map hashable?
08:00:21 <diphtherial> effectively, tris is of type [(Integer,Integer,Integer)], which means i can't perform map heron tris for some reason (apparently heron is expecting a tuple of Floating values)
08:00:22 <trevorb> OverCoder: lol I realized I was using duckduckgo.
08:00:50 <OverCoder> trevorb, that's, /s/u/i/
08:00:54 <diphtherial> i feel like it should be possible to make heron take Integers, but when i try to explicitly define that i get some errors...i could post those as well if it helps
08:00:58 <OverCoder> I mean, s/u/i
08:01:02 <trevorb> ?
08:01:12 <jackhill> pavonia: indeed, that does the trick, thanks again
08:01:15 <OverCoder> Nothing nevermind, you'll never understand it until you learn regex
08:01:25 <diphtherial> also, i'm not sure why the Integer tuples can't be used as Floating values in any case; it works if i just do heron (1,5,5)
08:01:33 <OverCoder> (Even though it only uses the sed syntax, it doesn't contain any regex)
08:01:34 <trevorb> I understand regex, I just don't know what you're applying to...
08:01:36 <pavonia> jackhill: No problem
08:01:37 <mmachenry> fryguybob: It's a custom data type. I'll show you.
08:01:53 <geekosaur> diphtherial, numeric literals (and *only* literals) are polymorphic
08:02:33 <geekosaur> as for your problem here, you need to gie "trie" a type
08:02:38 <OverCoder> trevorb, s/a/b -- Where a is the regex to find the content, and b is the replacement, that's a syntax of the famous program, sed
08:03:09 <OverCoder> trevorb, you can put an extra / followed by stuff like i for case insensitive and stuff
08:03:09 <geekosaur> because it does not take parameters, so the monomorphism restriction is being applied and its type is defaulted to [(Integer,Integer,Integer)] as a result
08:03:14 <trevorb> OverCoder: I know that.
08:03:26 <trevorb> OverCoder: but what text are you using it on?
08:03:31 <mmachenry> fryguybob: http://lpaste.net/146909
08:03:35 <OverCoder> trevorb, duckduckgo :D
08:03:40 <trevorb> :D
08:04:13 <geekosaur> @where DMR
08:04:13 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:04:32 <diphtherial> geekosaur: i see, thanks for the thorough explanation. i'm still attempting to learn haskell (obviously)
08:05:11 <mmachenry> fryguybob: To give context… actually I'll add context to that lpaste
08:05:32 <fryguybob> mmachenry: :D
08:06:41 <diphtherial> geekosaur: mind if i ask what the syntax is for assigning a type to the result of a list comprehension?
08:06:58 <geekosaur> just put a line above the definition of trie
08:07:23 <geekosaur> trie :: [(Double,Double,Double)] -- or whatever type you want it to have
08:08:01 <geekosaur> you could also put type annotations on the numeric literals but that's more annoying to dealw ith usually
08:08:44 <geekosaur> especially if you wan the type to be e.g. a consistent instance of Floating, you'd have to give the constraint 3 times if you annotated the literals but only once if you give "trie" the signature
08:10:16 <mmachenry> fryguybob: It's updated http://lpaste.net/146909
08:10:17 <quicksilver> geekosaur: annotating any one of those 10s would be sufficient
08:10:28 <quicksilver> geekosaur: but annotating tris looks nicer and symmetrical.
08:11:13 <quicksilver> or indeed annotating any one of a, b or c where it occurs in an expression would also suffice :)
08:12:45 <fryguybob> mmachenry: Does the map change often or is it mostly the same with changes happening in the values?
08:14:32 <mmachenry> fryguybob: It changes a lot. So much so that this is being written in Haskell because Oracle can't handle it. :)
08:15:15 <mmachenry> Turns out its so fast that even my naive data structure is a bit of a problem as well. It's great for the rest of the application but this one bit is a little too much CPU work
08:16:31 <diphtherial> i ended up with this type for tris, not sure it makes sense: tris :: (Floating a, Ord a, Enum a) => [(a,a,a)]
08:16:49 <diphtherial> i'm surrpised that Floating wouldn't somehow include Ord and Enum on its own
08:17:07 <diphtherial> it does work, though, and i'm able to invoke map heron tris with the expected results
08:17:07 <fryguybob> mmachenry: Given that the Map changes a lot, traversing it in STM sounds disastrous.
08:17:41 <mmachenry> fryguybob: Well, sorry, the map itself does not change. The values in the ThrottledQueue changes a ton
08:17:48 <geekosaur> @instances-importing Data.Complex Floating
08:17:52 <lambdabot> CReal, Complex a, Double, Expr, Float, Sym a
08:17:53 <mmachenry> The number of throttle groups that exist changes not very often.
08:17:57 <fryguybob> mmachenry: Ah, that's what I was asking. ok
08:18:03 <geekosaur> so Floating cannot imply Ord
08:18:32 <geekosaur> (complex numbers are not Ord)
08:19:02 <mmachenry> fryguybob: Furthermore, my traversal of that Map is embarrassing. The type of the existing provided fold does not match what I need so I wrote my own fold. 
08:19:06 <geekosaur> (or Enum for that matter; both require a 1-dimensional value space but Complex is 2-dimensional)
08:19:08 <mmachenry> I'll add that to the paste.
08:19:46 <diphtherial> geekosaur: ah, good point
08:19:57 <diphtherial> hadn't considered that floating included complex values
08:20:41 <diphtherial> other languages i've used have a special type for complex numbers, whereas in this case it seems they're considered by default and then excluded by not being able to conform to ord or enum
08:20:50 <diphtherial> which is neat, but surprising
08:21:06 <quicksilver> there is a special type for complex numbers, diphtherial 
08:21:09 <quicksilver> (Complex)
08:21:17 <quicksilver> Floating is a type-class, not a type.
08:21:50 <pavolzetor> hi, is there some way filter (\x -> all ($ x) [straight, letter, different])  to make this similar to Compare monoid?
08:21:56 <pavolzetor> I would like to have
08:21:58 <diphtherial> type-class, apologies
08:22:06 <pavolzetor> straight <> letter <> different
08:22:19 <mmachenry> fryguybob: There's the fold http://lpaste.net/146909
08:23:15 <pavolzetor> so it would combine the functions and then take AND on them
08:23:48 <fryguybob> mmachenry: You might see better performance if you avoid retry and orElse (sadly, I'm working on improving that).
08:24:48 <mmachenry> fryguybob: So using tryReadQueue or something like that?
08:24:56 <fryguybob> mmachenry: Right
08:25:19 <mmachenry> I would still be using alternatives for the maybe though. Would that still be better?
08:25:25 <fryguybob> So the final retry at the end is fine, but avoiding building a chain of orElse with likely retry in the first branch.
08:25:45 <mmachenry> tryReadQueue q1 <|> tryReadQueue q2 etc
08:26:31 <mmachenry> fryguybob: Oh that's good information. So that's inefficient? Interesting. I would figure that if the first retries that it's just tossed out if it has an alternate. 
08:26:38 <mmachenry> That builds up?
08:27:17 <fryguybob> mmachenry: Some of the meta data builds up, but that isn't the problem.  It has to do with some synchronization inefficiency.
08:27:51 <mmachenry> Hm...
08:27:53 <fryguybob> mmachenry: The idea is to allow recovery from an inconsistency found in the first branch by just retrying the first branch (or second branch).
08:28:36 <fryguybob> mmachenry: You could come up with a situation where this would be beneficial, but I think it is quite rare and not in the normal way STM gets used.
08:28:41 <mmachenry> fryguybob: I can go ahead and rewrite this using maybe instead of retry. 
08:29:09 <fryguybob> mmachenry: I'm a little out of it today, but I think yes :D.
08:29:33 <mmachenry> That will only take me a few minutes I think. I'll post with results asap. 
08:29:40 <mmachenry> Thanks so much for your help. 
08:29:42 <fryguybob> mmachenry: Great :D
08:29:49 <mmachenry> Do you work on GHC internals? 
08:30:44 <fryguybob> mmachenry: I'm working on my Ph.D working with hardware transactional memory in GHC.
08:32:07 <quicksilver> pavolzetor: you should find the composition "All . straight <> All . letter <> All . different" does what you asked.
08:32:29 <quicksilver> pavolzetor: All is just a newtype of Bool which has the monoid instance you need.
08:32:36 <quicksilver> and functions automatically have the monoid instance you need.
08:33:05 <quicksilver> you might want to unwrap the 'All' at the end - depends what you're trying to do.
08:33:40 <mmachenry> fryguybob: Awesome. Good luck on that.
08:33:48 <fryguybob> mmachenry: Thanks :D
08:37:23 <diphtherial> geekosaur, quicksilver: thanks again for your help; i was able to not only compute the triangles' areas, but group triangles by their areas and print them out in a kind of neat way
08:37:48 <diphtherial> i realize that's trivial, but it's the first thing of (personal) consequence i've written in haskell after conspiring to learn how to use it for years
08:37:55 <quicksilver> :)
08:39:30 <frontendloader> diphtherial: well done! I've been looking for a project like that for years now where I can actually utilize HS
08:41:26 <diphtherial> heh, well, hopefully i'll graduate to something more exciting soon, but it was the first thing i've done that didn't involve repeating a tutorial verbatim. thanks in any case :)
08:42:20 <phaazon> oh, weird
08:42:33 <phaazon> we can’t make recursive type declarations?
08:42:42 <phaazon> @let type Stepper = Float -> Maybe Stepper
08:42:43 <lambdabot>  .L.hs:150:1:
08:42:43 <lambdabot>      Cycle in type synonym declarations:
08:42:43 <lambdabot>        .L.hs:150:1-37: type Stepper = Float -> Maybe Stepper
08:42:57 <phaazon> @let type Stepper = Float -> IO (Maybe Stepper)
08:42:59 <lambdabot>  .L.hs:150:1:
08:42:59 <lambdabot>      Cycle in type synonym declarations:
08:42:59 <lambdabot>        .L.hs:150:1-42: type Stepper = Float -> IO (Maybe Stepper)
08:43:07 <quicksilver> not recursive synonyms, no
08:43:18 <quicksilver> that would make an infinite type
08:43:19 <phaazon> ok, I’ll make a newtype then :)
08:43:32 <quicksilver> you have to put a name in to give the type inference a handle to hold on to
08:44:56 <phaazon> yeah
08:45:15 <phaazon> @let newtype Stepper = Stepper { runStepper :: Double -> IO (Maybe Stepper) }
08:45:17 <lambdabot>  Defined.
08:45:19 <phaazon> \o
08:45:36 <phaazon> that starts to look like AFRP :)))
08:45:44 <phaazon> without the arrow stuff
08:46:00 <phaazon> at least it looks like Auto a bit
08:46:03 <phaazon> in the idea behind it
08:49:06 <prsteele> Working with Control.Concurrent, and I'm getting a memory explosion. I have one thread continually tryTakeMVar'ing then putMVar'ing an MVar, and another thread continually tryTakeMVar'ing that variable. If I do this, I get no output and memory use goes to 100%. If I add `threadDelay (10^3)` in either thread, everything behaves as expected. Any thoughts?
08:53:39 <Cale> prsteele: Well, that doesn't sound like a recipe for good performance in the first place... is there a way you could avoid using tryTakeMVar in at least one of those places?
08:53:43 <pdkr> prsteele: maybe trace where exactly the threads hange using Debug.Trace?
08:53:58 <MasseR> Oh man. Here I thought I'd just quickly build a cross-compiling ghc and test a simple hello world on a raspberry pi. I'm soon on the fourth hour of compiling
08:54:00 <Cale> prsteele: You want the thread to block when the operation fails if you're just going to try again immediately after
08:54:11 <pdkr> prsteele: also, maybe try an STM TChan ?
08:54:20 <lingxiao> hey all
08:54:21 <Cale> prsteele: So maybe replace at least the second tryTakeMVar with takeMVar
08:54:31 <lingxiao> so I did import qualified Test.QuickCheck as T
08:54:49 <lingxiao> and when i write `instance T.Arbitrary (Reservoir a) where` I get message Qualified name in binding position: T.arbitrary
08:54:55 <Cale> prsteele: That way, your thread will get woken up again when the MVar is filled, and not before that
08:55:09 <lingxiao>     Not in scope: type constructor or class ‘Arbitrary’
08:55:09 <lingxiao>     Perhaps you meant one of these:
08:55:09 <lingxiao>       ‘T.Arbitrary’ (imported from Test.QuickCheck),
08:55:13 <lingxiao> but when I don't add the T. i get that --^
08:55:27 <CoffeeTimer> Dear haskellers, a types question for you: the hedis package has a sorted set function that takes a Double, which the Haskell read function makes into scientific notation.  However, redis doesn't understand the scientific notation...
08:55:49 <CoffeeTimer> :t zadd
08:55:51 <Cale> CoffeeTimer: You mean show?
08:55:52 <lambdabot> Not in scope: ‘zadd’
08:56:04 <pdkr> lingxiao: is it an error on the "instance" line or on its implementation?
08:56:05 <CoffeeTimer> :t Database.Redis.zadd
08:56:07 <lambdabot> Not in scope: ‘Database.Redis.zadd’
08:56:18 <lingxiao> instance line
08:56:20 <lingxiao> pdkr
08:56:34 <Cale> lingxiao: Watch the capitalisation
08:56:37 <lingxiao> wait nvm!
08:56:41 <lingxiao> it's not in the instance line
08:56:41 <Cale> "Qualified name in binding position: T.arbitrary"
08:56:48 <Cale> sounds like you wrote a lowercase a
08:56:54 <pdkr> lingxiao: in the implementation you don't need to use T.
08:57:09 <lingxiao> cale yeah pdkr that's what i did, forgot i was in scope of instance T.arb...
08:57:10 <lingxiao> thanks
08:57:10 <lingxiao> !
08:57:16 <pdkr> :)
08:57:28 <CoffeeTimer> Has anyone run into that issue before?  Why would the read function convert a numeric value into a string with "e" and so on?  Seems like a bizarre implementation...
08:57:44 <pavolzetor> does haskell have something like rust windows
08:57:46 <pavolzetor> ?
08:57:51 <Cale> Oh, and yeah, the names of things which are being bound, even the methods in an instance declaration may never be qualified
08:58:10 <pdkr> pavolzetor: what are rust windows?
08:58:21 <Cale> CoffeeTimer: The read function generally does not go in that direction
08:58:35 <Cale> CoffeeTimer: It turns Strings into other types of data
08:58:53 <lingxiao> Cale ahh good rule to remember
08:58:53 <Cale> > read "438.21789e6" :: Double
08:58:54 <lambdabot>  4.3821789e8
08:59:14 <prsteele> side note, is there an easy way to install profiling libraries with cabal? Right now I'm forced to cabal install --reinstall -p some-lib --enable-library-profiling for each of (many) libraries
08:59:20 <Cale> CoffeeTimer: Perhaps you're thinking of show?
08:59:28 <Cale> > show 4.3821789e8
08:59:30 <lambdabot>  "4.3821789e8"
08:59:37 <johnw> CoffeeTimer: if you can show us the code, and the input and output...
08:59:51 <Cale> > show (438217890 :: Double)
08:59:53 <lambdabot>  "4.3821789e8"
09:00:09 <dcoutts> prsteele: at the moment that is indeed a right pita. I realise it doesn't help you immediately, but an upcomming cabal release will fix that (and much more)
09:00:31 <Cale> dcoutts: nice!
09:00:32 <pdkr> dcoutts: what are you referring to here?
09:00:33 <dcoutts> prsteele: in case you like alpha-testing, it's in the cabal repo, branch nix-local-build
09:00:45 <pdkr> (and will this also affect stack?)
09:00:52 <CoffeeTimer> lastChanged <- r $ hget k "lastChanged" >>= return . fromRight Nothing >>= return . fromMaybe "1"
09:00:53 <prsteele> dcoutts: thanks!
09:00:54 <dcoutts> pdkr: this is unrelated to stack
09:00:55 <pdkr> (not sure what the stack situation is)
09:01:00 <pdkr> okay
09:01:18 <CoffeeTimer> r $ zadd "latestUpdatedz" [((read (B.unpack lastChanged)) :: Double, k)]
09:01:32 <Cale> CoffeeTimer: first of all, x >>= return . f can be rewritten as  fmap f x  or  f <$> x  which are usually more readable
09:02:01 <CoffeeTimer> The zadd function tries to insert a "1.444e9" into Redis, which baffles Redis
09:02:06 <dcoutts> pdkr: the nix-local-build branch of cabal-install tracks everything much like nix does, using hashes. Profiling affects the hash, so everything gets built as required.
09:02:18 <Cale> CoffeeTimer: That's zadd's fault, not read's
09:02:19 <geekosaur> that would be the fault of zadd then
09:02:36 <dcoutts> Cale: you're welcome to alpha-test too if you like :-)
09:02:39 <Cale> CoffeeTimer: read is producing a Double, which isn't in any particular notation, it's just some bits in memory
09:02:40 <CoffeeTimer> Cale: indeded
09:02:42 <prsteele> dcoutts: I'll look into (re)building cabal from that. For now rm -r dist .cabal-sandbox && <reinstall> works
09:02:44 <CoffeeTimer> geekosaur: indeed
09:02:49 <pdkr> dcoutts: sweet. so basically this specific issue is also solved by the general cabal improvements? :)
09:02:53 <dcoutts> prsteele: right
09:03:09 <dcoutts> pdkr: yes it falls out naturally from following nix principles
09:03:13 <pdkr> awesome.
09:03:19 <geekosaur> presumably there is a show in its implementation that needs to be replaced by showFFloat
09:03:43 <CoffeeTimer> Interesting, so I should probably change the show instance of zadd in the Redis library?
09:03:54 <dcoutts> pdkr: as do several other things, like full caching (not just specific sets like stackage), building specific libs with special profiling cost centres. HPC coverage. All sorts of things.
09:03:58 <prsteele> Cale: et al, more general MVar question then: how should I implement a thread that wants to write to an MVar to maintain a 'current best' solution, but can also update that value (even if it hasn't been taken by another thread yet)? is this a solved problem?
09:03:59 <Cale> dcoutts: Are we any closer to replacing nix itself with a Haskell library perhaps? :D
09:04:19 <dcoutts> Cale: no, this is "just" stealing nix ideas and implementing them in cabal-install
09:04:30 <Cale> dcoutts: Fair enough :)
09:05:10 <pdkr> dcoutts: exciting!
09:05:19 <Cale> prsteele: That sounds like a SampleVar
09:05:23 <Cale> https://hackage.haskell.org/package/SafeSemaphore-0.10.1/docs/Control-Concurrent-MSampleVar.html
09:05:30 <Cale> ^^ see if that sounds right
09:05:40 <pdkr> cabal has not been enough of a PITA for me to justify switching to stack. seems like I won't have to.
09:06:28 <prsteele> Cale: that is *exactly* what I want. I was trying `tryTakeMVar x; putMVar x foo` and eventually ran into the problem I mentioned...
09:06:38 <dcoutts> pdkr, Cale: hopefully, there'll be a "tech preview" in the next cabal-install release. It's not quite complete enough to cover all the various cabal commands, but can at least build.
09:06:56 <geekosaur> CoffeeTimer, it's a function, it doesn;t have a Show instance. it is *using* the "show" function somewhere along the line
09:07:04 <CoffeeTimer> instance RedisArg Double where encode = pack . show
09:07:19 <Cale> CoffeeTimer: There you go
09:07:42 <Cale> CoffeeTimer: you'll probably want to use something like  encode x = pack (showFFloat Nothing x "")
09:08:33 <Cale> (Though really, what kind of implementation of a floating point number parser doesn't bother with scientific notation?)
09:08:34 * geekosaur was looking for that but is not familiar with hedis. and yes, that's the likely fix
09:09:03 <pavolzetor> quicksilver: is there a way to make it shorter, preferably apply All to x <> y <> z?
09:09:15 <CoffeeTimer> Cale: interesting! that looks like it might do the trick
09:09:28 <CoffeeTimer> geekosaur: you're right!  sorry for my confused explanation
09:09:28 <prsteele> dcoutts: any idea why cabal install won't install necessary executables? E.g. cabal install gtk2hs-buildtools fails ( I believe) until I cabal install alex.
09:09:56 <pdkr> prsteele: cabal does not support build-time dependencies
09:09:57 <pavolzetor> pdkr: it gives you a sublist
09:09:57 <dcoutts> prsteele: it's because exes are not yet tracked in the solver and other general infrastructure.
09:10:17 <prsteele> thanks!
09:10:32 <CoffeeTimer> thanks guys!  you all are always super helpful
09:10:43 <CoffeeTimer> (or girls)
09:10:43 <pavolzetor> pdkr: https://github.com/pavolzetor/advent_of_code/blob/master/day5.hs, the nples function
09:11:01 <dcoutts> prsteele: .cabal files can specify build-tools, but currently the solver etc does not take that into account. I expect that'll float to the top of the priority list once the nix stuff is done since it's needed for building large sets of things.
09:11:06 <pdkr> pavolzetor: this is RE: what?
09:11:25 <quicksilver> pavolzetor: just redefine x to include the All
09:11:28 <CoffeeTimer> back to coding now!! :)
09:11:41 <quicksilver> pavolzetor: <> requires a Monoid instance so you're going to have to choose x,y,z which have Monoid instances...
09:11:42 <dcoutts> pdkr: it sort-of does, but too late. Not up front in the solver.
09:11:43 <pavolzetor> pdkr: windows in rust
09:11:51 <quicksilver> there are certainly ways to make it concise.
09:13:31 <pdkr> pavolzetor: ah well. it doesn't look like something that's in the standard library. but i'm sure someone in here has a smart way to do with with Lens and 3 applications of flip
09:14:11 <pavolzetor> quicksilver: thanks, I need to think about this, new to monoids 
09:14:20 * hackagebot extract-dependencies 0.2.0.0 - Given a hackage package outputs the list of its dependencies.  https://hackage.haskell.org/package/extract-dependencies-0.2.0.0 (yamadapc)
09:14:52 <pavolzetor> pdkr: thanks, now I have to read about lenses
09:15:05 <pavolzetor> down the rabbit hole
09:15:42 <pdkr> pavolzetor: "Lens" here has a symbolic value. it's not so much that Lens is the tool for the job here, but for all of these nifty functions, inevitably someone knows just the right combination of standard functions that does it
09:15:56 <pdkr> (for some notion of "standard")
09:19:20 * hackagebot stack-run-auto 0.1.1.0 - Initial project template from stack  https://hackage.haskell.org/package/stack-run-auto-0.1.1.0 (yamadapc)
09:21:26 <pavolzetor> pdkr: okay, if you know about any send me a link please
09:22:10 <pavolzetor> I still have to finish the Held-Karp memoization
09:50:07 <diphtherial> ran into some interesting unanticipated difficulties when attempting to write an infinite version of my triangle list comprehension
09:51:08 <diphtherial> no triangle exists for 1,1,x where x > 1, but the comprehension doesn't know that so it never returns
09:51:39 <diphtherial> i need to find a way to generate triangles instead of just generating all triples and filtering out those that don't obey the triangle inequality...that'll be an interesting puzzle
09:52:31 <prsteele> diphtherial: you can probably still generate all triples, just do so in a way that guarantees any given triple (a, b, c) is generated in finite time
09:53:15 <prsteele> suggestions on tracking down a memory explosion? +RTS -p -h shows me what function it is, but I'm not sure why it is using O(n) memory instead of O(1)
09:53:32 <mmachenry> fryguybob: Your solution gave me an order of magnitude speed boost. 
09:54:16 <prsteele> diphtherial: e.g. generate triples (a, b, c) with a <= b <= c, and increment c first
09:54:26 <mmachenry> fryguybob: Thanks so much. If you want me to package up this code into something you can read as a test case for your research or example really found in industry or something I'm happy to do that.
09:54:37 <mmachenry> fryguybob: Though maybe you have plenty of examples of the issue. 
09:55:08 <diphtherial> prsteele: hrm, that makes sense; i'll give that a try
09:55:18 <diphtherial> i suspected it had to be something like that, but your example helps
09:55:49 <Cale> Oh yeah, dcoutts, how well does that new cabal stuff work with parallel builds? I seem to recall nix having problems with them due to nondeterministic hashes. Perhaps this is getting sorted out? :)
09:56:21 <dcoutts> Cale: safety of concurrent builds relies on locking
09:56:52 <dcoutts> Cale: have to lock the store entry so that we never overwrite an existing entry
09:57:19 <dcoutts> so for two independent builds, one will wait and use the result of the other
09:58:05 <dcoutts> Cale: that bit isn't actually implemented yet, but that's the design.
09:58:30 <foobarbaz123imad> foldl (+) 0 [1..10] :: Expr
09:58:31 <Cale> cool
09:58:44 <Cale> > foldl (+) 0 [1..10] :: Expr
09:58:46 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
09:59:10 <dcoutts> Cale: so for the same reason as with ghc & nix, this makes it hard to share a cache between team members or more widely
09:59:24 <foobarbaz123imad> foldr (+) 0 [1..10] :: Expr
10:01:02 <prsteele> okay, maybe I'm trying to track down the wrong problem. New question. I want to (lazily) consume an infinite list embedded inside a monad; is this automatically going to be O(n) memory? in my case I'm doing something like `forM_ (evalRand (sequence (repeat rollADie)) (mkStdGen 0)) (\r -> putStrLn (show r))`
10:01:07 <sm> what's a good easy way to chop out a particular div from some HTML ?
10:01:25 <Cale> sm: Sounds like maybe a job for tagsoup
10:01:34 <foobarbaz123imad> is it just me or is lambdabot really slow^
10:01:36 <foobarbaz123imad> ?
10:01:45 <monochrom> it is just you
10:01:47 <Cale> foobarbaz123imad: you're not asking lambdabot to evaluate that expression
10:01:49 <sm> Cale: thanks, I'm just checking that out
10:02:11 <Cale> foobarbaz123imad: Your message needs to start with "> " in order to lambdabot to regard it as something you want it to evaluate.
10:02:15 <foobarbaz123imad> > foldr (+) 0 [1..10] :: Expr
10:02:18 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
10:02:24 <foobarbaz123imad> sorry, I'm drunk 
10:02:34 <foobarbaz123imad> trying to convert some guy to haskell
10:02:49 <monochrom> both are bad ideas
10:02:53 <tommd> foobarbaz123imad: you can talk to lambdabot in private messages too, which might suit you better in this case.
10:03:38 <Doug___> Hello, could I ask for another set of eyes to spot a problem?
10:03:42 <foobarbaz123imad> i tried. thanks anyway!
10:03:57 <Doug___> http://lpaste.net/146912
10:08:43 <Pozzuh> Hi, small question, I have a list with the following setup ["a", "b", <more random things>, "::", "last"] is it possible to pattern match the first part of random things? Something like [ [] : "::", last ] ?
10:10:41 <prsteele> Pozzuh: you want to pattern match against an unknown number of items before encountering "::" ?
10:11:44 <Pozzuh> Yes, prsteele 
10:12:01 <prsteele> Pozzuh: I do not believe you can.
10:12:13 <prsteele> Pozzuh: I suggest dropWhile (/= "::")
10:13:14 <Doug___> I have a recursive call inside a do ... block, however it's not actually recursing as I think it should be.. Can you make recursive calls in do blocks?
10:13:18 <Pozzuh> I actually need the unknown number of elements for something though. I already have the code working with a case statement in a case statement
10:13:25 <Pozzuh> I just thought it was really ugly (still new to haskell)
10:14:05 <prsteele> > break (== "::") ["a", "b", "::", "last"]
10:14:07 <lambdabot>  (["a","b"],["::","last"])
10:14:43 * hackagebot tz 0.1.0.1 - Efficient time zone handling  https://hackage.haskell.org/package/tz-0.1.0.1 (MihalyBarasz)
10:15:05 <Pozzuh> Thanks, it looks like break might do the job
10:18:15 <sm> hmm, I don't think tagsoup is the right lib for chopping a named div out of some html without disturbing the rest
10:21:23 <sm> probably I should use sed/awk
10:29:26 <breadmonster> I remember when I was first learning Haskell, there was some polymorphic typing thing involving (.) and flip that blew my mind.
10:29:40 <breadmonster> And someone told me to try unifying the types with a pen and paper.
10:29:43 * hackagebot timelike-time 0.1.0 - Timelike interface for the time library  https://hackage.haskell.org/package/timelike-time-0.1.0 (esz)
10:33:00 <ski> .. and ?
10:38:26 <OverCoder> Guys, the tutorial is trying to describe associative lists vs. Maps to me, I understand both of these from my imperative languages, but, I bet the example has something wrong, what does this even mean: http://p.samuraimanpurse.com/287FWvSd.txt
10:38:48 <OverCoder> It says The fromList function takes an association list (in the form of a list) and returns a map with the same associations., then where's the difference in this case
10:39:22 <StoneToad> OverCoder: in the types
10:39:22 <ski> a list has linear access time
10:39:29 <ski> a map doesn't
10:39:38 <Clint> OverCoder: your map type can't have duplicate keys
10:39:51 <Cale> OverCoder: The Map is stored quite differently, and if you look at the second example there, you'll see that the (3,4) and (3,2) in the input list have collided, and only (3,2) ends up in the Map
10:39:58 <OverCoder> Ah so, the string representation is the same huh?
10:40:20 <Cale> OverCoder: Well, the show function will generally try to produce something like Haskell code for constructing the value
10:40:41 <Cale> OverCoder: so as to make it easy when you're playing around in GHCi to copy/paste values
10:40:47 <ski> `Map k v' is an abstract data type. it is not going to show you how it internally has decided to store your map value (which may differ for map values that are conceptually equal)
10:40:54 <Cale> So in this case, it produces an application of fromList
10:41:03 <Cale> Right
10:41:12 <OverCoder> Hm
10:41:20 <Cale> Internally, the Map is a binary balanced tree
10:41:21 <OverCoder> Got it got t
10:41:21 <ski> so `show' on a map value is just displaying a `fromList' call on an association list, that if evaluated would yield an equivalent map value
10:42:02 <OverCoder> Alright people, you're being so great with me as always, thanks
10:42:16 <ski> ynp
10:42:30 <ski> (er, s/ynp/np/)
10:46:55 <Luke> is there a common [atto]parsec pattern for skipping arbitrary amount of data before finding a pattern (not just a character) to parse?
10:47:03 <Luke> i'm not sure of a nice/clean way to write that
10:47:35 <Luke> at least with attoparsec, you can skip data until you find the _character_ you're looking for in order to start parsing but not pattern or Parser
10:47:45 <Luke> it doesn't need to be super performant btw
10:48:21 <lpaste> echo-area pasted “coroutine” at http://lpaste.net/146915
10:48:39 <echo-area> Could someone please review this coroutine implementation?  Thanks
10:59:03 <rpfun> are mutable vectors in Haskell like C++ vectors in that append is only O(n) in the worst case? basically, does vector allocate exactly how much you ask, or choose how to grow on its own?
10:59:17 <aweinstock> echo-area: producer consumer = mapM (flip yield consumer) [0..9] >> return "done" -- I think this should be equivalent?
11:00:07 <aweinstock> also, in the declaration "yield v cons", it looks like "cons" is short for "consumer", expand that out to "consumer", since "cons" is how (:) is pronounced
11:01:21 <echo-area> aweinstock: Those are very helpful.  I am modifying, thank you
11:02:43 <please_help> How usable is the AD package when deriving with regard to hundreds of thousands of variables?
11:03:26 <aweinstock> echo-area: also, changing the argument order on yield (to make the consumer first) would avoid the flip, and in general make it more useful to partially-apply yield to a consumer (to yield a bunch of things to the same consumer)
11:06:00 <pavolzetor> I have implemented TSP using memoization (with bitmask) and it seems slow
11:06:00 <echo-area> aweinstock: I see, I will reverse them
11:06:52 <pavolzetor> http://lpaste.net/146918
11:06:57 <pavolzetor> why would it still be slow?
11:07:13 <pavolzetor> non-memoized version taks 20 ms
11:07:16 <pavolzetor> takes
11:08:25 <pavolzetor> and without bitmask it takes 35 ms (probably not worth even using it as it makes code ugly)
11:09:35 <fryguybob> mmachenry: If you could package that it that would be *very* helpful to me.  I'm always looking for realworld uses where the implmentation has a practical effect.
11:09:45 <fryguybob> mmachenry: I'm glad that the change worked for you :D
11:10:40 <ski> please_help : you should ask edwardk
11:11:03 <pavolzetor> it is 2^n space, but would the memoization be slow? does it uses constant access data structure?
11:11:42 <mmachenry> fryguybob: send me your email address in a private chat and I will send you as small of a program as I can.
11:15:30 <pavolzetor> http://lpaste.net/146922
11:15:33 <pavolzetor> this is with an array
11:15:35 <pavolzetor> still slow
11:15:50 <pavolzetor> (I mean not faster than without memoization)
11:17:11 <pavolzetor> am I doing the memoization right?
11:18:07 <please_help> ski: any idea around when he's available?
11:21:10 <ski> please_help : i don't
11:21:13 <ski> please_help : you could try highlighting him, or send him a private message, or use `/msg MemoServ send ...', or perhaps mail
11:21:35 <ski> (though i'd be curious to know the answer to your question, and perhaps others in this channel as well)
11:21:37 <prsteele> any hints on tracking down a space leak?
11:22:02 <prsteele> in particular, is there a way to make +RTS -p -h go into more detail than it does currently?
11:22:32 <ski> echo-area : if `consumer' doesn't `resume producer' explicitly, that is done implicitly at then end ?
11:23:08 <sm> urgh.. feeling stupid. I want to implement, as a pure function, "awk '/BEGIN/{del=1;next}; /END/{del=0}; !del'" - ie, delete all lines from BEGIN up to and excluding END. The obvious solution seems to be "use State". But after reviewing mtl's and transformers' State docs, I'm just confused.
11:23:39 <shock_one> Hello. How would I do something like Prelude find, but concurrently? If you're interested in the problem, I have a list of GitHub pull request IDs, and I need to find the pull request for a particular branch.
11:23:55 <prsteele> nevermind, just added `seq` until thunks went away
11:24:08 <sm> what would be the skeleton of a pure statefully-processing loop over a list ?
11:24:48 * hackagebot distributed-closure 0.1.0.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.1.0.0 (MathieuBoespflug)
11:25:12 <monochrom> sm: do you mean your lines are already in a list, one line one item?
11:25:32 <prsteele> sm: foldl (\(state, result) el -> yourfunc) init els :: (state, result) ?
11:25:36 <ski> echo-area : btw, on one hand your use of `ContT' (namely the two-level continuations `ContT () (ContT () IO)') reminds me of backtracking list/stream processing
11:25:47 <sm> monochrom: they're actually in a lazy bytestring, but yes I'm getting lines from that
11:26:32 <sm> prsteele: hmm that seems enough, so why would I need a monad at all
11:27:04 <monochrom> then I find the following obvious (and "use State" wtf): f [] = []; f (x:xs) | x=="BEGIN" = g xs | otherwise = x : f xs;
11:27:08 <ski> echo-area : otoh, i'd like to remove all the `ContT' cruft, at least temporarily, to more clearly see the essence of what you're trying to express, perhaps along the lines of <http://lpaste.net/47814>
11:27:29 <monochrom> g [] = []; g (x:xs) | x=="END" = x:xs | otherwise = g xs
11:27:37 <prsteele> sm: it makes it prettier. ST could make it faster.
11:27:41 <echo-area> ski: Yes, resuming implicitly was my intention.  Is it good or bad practice?
11:27:44 <ski> (ftr, that being "`zipWith' using `foldr'")
11:27:56 <prsteele> sm: it lets you not explicitly juggle the state
11:28:00 <monochrom> err
11:28:06 <monochrom> g [] = []; g (x:xs) | x=="END" = x: g xs | otherwise = g xs
11:28:08 <ski> echo-area : i don't know. i didn't know your intent
11:28:31 <echo-area> Okay
11:28:31 <prsteele> sm: I basically just described the state monad specialized to a list
11:29:01 <prsteele> sm: https://wiki.haskell.org/State_Monad#Implementation
11:29:31 <ski> echo-area : my immediate reaction (perhaps unsuitable in your case) would be that i would prefer not being able to "fall off at the end". iow you must be explicit about what you want (maybe abort the producer, instead of resuming it ?). but i don't know if that's the kind of thing you'd like to express
11:29:48 <sm> yes.. monochrom, prsteele: thank you both, that helps. I'm still confused about how to set up a State loop but as you say this problem doesn't need it
11:29:48 * hackagebot paypal-adaptive-hoops 0.13.1.0 - Client for a limited part of PayPal's Adaptive Payments API  https://hackage.haskell.org/package/paypal-adaptive-hoops-0.13.1.0 (fanjam)
11:31:19 <monochrom> err, my correction is wrong. original version of g was right.
11:31:22 <shock_one> sm, I haven't tested it, but it should work. https://gist.github.com/shockone/5d18722147b297623426
11:31:45 <echo-area> ski: Oh, I think explicitness is good.  I will try and feel that one later
11:32:34 <sm> shock_one: thank you
11:32:39 <varaindemian>  pack :: [Word8] -> ByteString  You can think of it as taking a list, which is lazy, and making it less lazy, so that it's lazy only at 64K intervals.
11:33:02 <varaindemian> For me [Word8] and ByteString seem the same thing..
11:33:33 <varaindemian> they said the type signatures have ByteString instead of [a] and Word8 instead of a in them. The functions with the same names mostly act the same as the ones that work on lists. Because the names are the 
11:33:43 <shock_one> sm, it's called flip-flop and you can even abstract it. http://stackoverflow.com/a/6463494/1149074
11:34:20 <sm> oh, nice
11:34:33 <varaindemian> Can someone can explain me the diffecrence between [Word8] and ByteString?
11:35:51 <sm> varaindemian: ByteString groups the bytes in chunks, which makes it more efficient in some cases
11:36:23 <sm> (internally)
11:37:08 <tpsinnem> is there a way to convert a stack.yaml to an equivalent .cabal file?
11:37:14 <monochrom> yeah, most of the difference is in implementation and efficiency
11:37:38 <monochrom> the only denotational difference is that [Word8] can be infinite, ByteString cannot
11:37:49 <varaindemian> sm: so ByteString groups Word8 in chunks?
11:38:00 <shock_one> Nobody knows how to do concurrent find? I thought there must be a popular function for that. :(
11:38:02 <varaindemian> Word8's
11:39:14 <sm> varaindemian: check the docs to be sure
11:39:40 <sm> https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html
11:41:01 <sm> actually https://hackage.haskell.org/package/bytestring-0.10.6.0 is better, and more correct
11:41:07 <sm> (than what I said)
11:43:36 <tpsinnem> does enabling nix in stack.yaml as in http://docs.haskellstack.org/en/stable/nix_integration.html make the stack project unbuildable on systems without nix, or does it do nothing if nix isn't installed?
11:55:40 <ReinH> varaindemian: a lazy bytestring is a list of chunks, a strict bytestring is a single chunk.
11:56:15 <shirt> how can i run "cabal install --only-dependencies" but also list on the command line the name of one of the dependencies that should be excluded?
11:58:00 <ReinH> shock_one: map concurrently, then find as usual
11:58:19 <ReinH> The only thing you can make concurrent in find you can just make concurrent in map instead
11:58:48 <shock_one> ReinH: I'd like to stop as soon as there is a result.
11:59:00 <ReinH> shock_one: then how can you do it concurrently at all?
11:59:46 <shock_one> ReinH: If there are some running threads but I already have my result, I'd like not to wait till they finish.
12:00:19 <ReinH> I imagine you could do something with async
12:00:28 <shock_one> ReinH: how would I map concurrently, but the way?
12:01:34 <ReinH> With async.
12:01:39 <ReinH> @hoogle async
12:01:42 <lambdabot> package async
12:01:42 <lambdabot> Control.OldException asyncExceptions :: Exception -> Maybe AsyncException
12:01:42 <lambdabot> package async-extras
12:01:46 <ReinH> woops
12:01:48 <ReinH> @hackage async
12:01:48 <lambdabot> http://hackage.haskell.org/package/async
12:02:15 <ReinH> e.g., mapConcurrently
12:02:15 <shock_one> Thank you, ReinH.
12:02:45 <ReinH> shock_one: for what you want to do, you may set up something similar to race that cancels unneeded tasks
12:03:11 <ReinH> I'm not sure if an abstraction for this already exists
12:03:23 <ReinH> but async is a great tool for building such abstractions
12:06:13 <rydgel> shirt: I don't think you can do that, since the dependency is needed to compile your package. There is maybe another way, why would you want to do that in the first place?
12:08:16 <shirt> rydgel: the dependency is another local package, that i want to use from cabal sandbox add-source
12:08:53 <ReinH> shirt: if you specified an add-source, it will be used
12:09:02 <ReinH> you can cabal install --dependencies-only as usual
12:09:57 <rydgel> shirt: oh well, I did that once. If you do the add-source before it should be used by cabal automatically
12:10:02 <rydgel> Like ReinH said
12:10:19 <shirt> yeah, but i'm installing this in a strange vm setup where i want the hackage dependencies only... but now i realize this won't work anyway
12:10:46 <ReinH> if you have a strange setup, you might try Stack. It is easier to configure for strange setups.
12:11:17 <rydgel> shirt: You can have both local and hackage package in your app, just don't forge the add-source in your sandbox and you should be good
12:11:17 <shirt> ReinH: doesn't stack only support using the latest version of a library? i'm using some old versions
12:11:27 <ReinH> No, it supports uing any version
12:11:33 <ReinH> *using
12:11:36 <ReinH> on hackage or git or locally
12:11:37 <shirt> cool thanks
12:11:43 <rydgel> Stack also support local package
12:11:51 <shirt> i'll look into stack
12:13:24 <rydgel> shirt: you can look into my toy project for an example of a stack/cabal configuration and local packages https://github.com/Rydgel/flappy-haskell
12:15:36 <ReinH> such flappy
12:15:55 <rydgel> ReinH: WIP don't judge too hard
12:16:00 <rydgel> also haskell noob
12:16:00 <Cale> Yampa! :D
12:16:04 <ReinH> :D
12:16:19 <ReinH> I'm not judging, I just like saying "flappy"
12:16:43 <dmwit_> :t fmod
12:16:46 <lambdabot>     Not in scope: ‘fmod’
12:16:46 <lambdabot>     Perhaps you meant ‘mod’ (imported from Prelude)
12:17:07 <rydgel> Cale: Yeah Yampa's cool. I'm still trying to figure out a neat way to trigger sound based on event or something
12:17:33 <dmwit> :t realToFrac
12:17:43 <lambdabot> (Fractional b, Real a) => a -> b
12:17:57 <dmwit> > realToFrac (3 :: Int) :: Double
12:18:00 <lambdabot>  3.0
12:19:07 <monochrom> one might say: Dumbo is flappy
12:19:50 <dmwit> I could swear there used to be an fmod in a standardish library, but Hoogle points me at ridiculous packages for it.
12:19:53 <dmwit> :t mod'
12:19:56 <lambdabot> Real a => a -> a -> a
12:20:00 <dmwit> Ah, there we go.
12:21:45 <monochrom> it's in Data.Fixed
12:22:06 <dmwit> monochrom: thanks
12:22:34 <spion> hmm. there was a way to encode an Either-like type using lambda calculus but I can't seem to find it with google
12:22:46 <spion> does someone have a reference to something like that?
12:23:13 <dmwit> Google for "Church encoding" or "Scott encoding".
12:23:19 <dmwit> There are other encodings, too.
12:23:33 <spion> dmwit: thanks!
12:23:49 <monochrom> "Left 5" can be modelled by "\f g -> f 5". "Right False" can be modelled by "\f g -> g False"
12:24:25 <spion> monochrom: thats it!
12:24:27 <spion> :)
12:24:35 <spion> thanks!
12:38:13 <circ-user-DNB5o> xtodev
13:15:16 <spuz_> if I use readFile with a relative file path, how is the current working directory calculated?
13:15:31 <spuz_> is it at compile time or run time?
13:16:40 <kadoban> spuz_: It's always runtime, regardless of language or whatever.
13:17:17 <spuz_> kadoban, how is the cwd evaluated?
13:18:11 <kadoban> spuz_: Not sure what you mean exactly. It's a property of the environment in which the program is run. For example if you're in a shell and you run a program, the cwd is … whatever directory you're in.
13:18:28 <dmwit> On *nix's, CWD is inherited from the parent process, and can be modified once the program starts with function calls.
13:18:43 <kadoban> That sounds like a better answer.
13:18:57 <spuz_> dmwit, that would make sense
13:19:28 <spuz_> that would explain why my program cannot find a local file after switching to stack exec
13:19:58 <dmwit> A bit of poking online confirms that the functions eventually terminate at a syscall. (I wanted to say that in my first message, but I wasn't 100% sure.)
13:21:25 <dmwit> You can use System.Directory.getCurrentDirectory to check what your CWD is at the moment (and setCurrentDirectory to set it).
13:23:23 <ReinH> spuz_: if your program needs to use data files, use the built-in ghc support for that
13:23:29 <ReinH> don't depend on PWD
13:23:55 <dmwit> Are you sure it's GHC-specific? I think it's cabal-specific.
13:24:01 <spuz_> ReinH, can you point me towards the docs for that?
13:24:03 <ReinH> oh yeah, cabal-'s support
13:24:05 <dmwit> Then again of course there's
13:24:10 <dmwit> ?hackage xdg-basedir
13:24:10 <lambdabot> http://hackage.haskell.org/package/xdg-basedir
13:24:17 <dmwit> which is neither specific to GHC nor cabal.
13:24:18 <ReinH> spuz_: cabal online data files
13:24:21 <ReinH> uh
13:24:24 <ReinH> thanks clipboard
13:24:29 <ReinH> cabal online data files
13:24:30 <ReinH> wtf
13:24:32 <ReinH> sorry
13:24:38 <ReinH> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
13:24:48 <ReinH> I die of embarrassment.
13:24:52 <spuz_> heh thanks
13:33:15 <l3dx> how would you parse the string "12x34x56" (a dimension) into (12, 34, 56)?
13:34:36 <dmwit> (,,) <$> number <* char 'x' *> number <* char 'x' *> number
13:34:42 <dmwit> Given a suitable definition of `number` and `char`.
13:34:59 <dmwit> ?hackage parsec
13:35:00 <lambdabot> http://hackage.haskell.org/package/parsec
13:35:12 <alkabetz> That’s … kind of cool
13:35:18 <mniip> :t (,,) <$> ?number <* ?char 'x' *> ?number <* ?char 'x' *> ?number
13:35:19 <lambdabot> (Applicative f, ?char::Char -> f b1, ?number::f b) => f b
13:35:27 <alkabetz> I probably would have gone with ?hackage split
13:35:30 <mniip> seems wrong
13:35:38 <dmwit> mniip: why?
13:35:41 <lispy> You could also use reads
13:35:43 <lispy> > reads "12x34x56" :: [(Int, String)]
13:35:45 <lambdabot>  [(12,"x34x56")]
13:35:55 <mniip> dmwit, should be f (b, b, b)
13:35:59 <dmwit> mniip: Oh, yeah, it kind of does. Huh.
13:37:21 <dmwit> aha
13:37:49 <dmwit> :t (,,) <$> ?number <* ?char 'x' <*> ?number <* ?char 'x' <*> ?number
13:37:51 <lambdabot> (Applicative f, ?char::Char -> f b, ?number::f a) => f (a, a, a)
13:38:01 <fizruk> hey guys! is there an append-only state-like monad defined anywhere?
13:38:12 <lispy> Writer?
13:38:12 <dmwit> ?hackage regex-applicative is also nice for simple parsing tasks
13:38:13 <lambdabot> http://hackage.haskell.org/package/regex-applicative is also nice for simple parsing tasks
13:38:27 <fizruk> lispy: I can't read state with writer
13:38:40 <monochrom> but you said append-only
13:38:50 <dmwit> :t listen
13:38:52 <lambdabot> MonadWriter w m => m a -> m (a, w)
13:38:57 <dmwit> Also you are incorrect.
13:39:04 <fizruk> monochrom: correct
13:39:21 <dmwit> Sort of.
13:39:43 <fizruk> dmwit: I know about that one, it'd not what I want
13:40:00 <fizruk> just let me paste some code I have
13:40:20 <l3dx> thanks a lot! I have to study your suggestions for a while :)
13:40:21 <dmwit> :t puts . (<>)
13:40:23 <lambdabot>     Not in scope: ‘puts’
13:40:23 <lambdabot>     Perhaps you meant ‘put’ (imported from Control.Monad.State)
13:40:33 <dmwit> :t modify . (<>)
13:40:35 <lambdabot> (Monoid s, MonadState s m) => s -> m ()
13:40:51 <dmwit> New library proposal: rename `modify` to `puts`.
13:40:56 <dmwit> 110% serious
13:41:22 <fizruk> lispy: monochrom: dmwit: http://lpaste.net/146925
13:41:28 <monochrom> could you explain why "puts" is a better name?
13:42:04 <fizruk> symmetry with gets I suppose (I don't find puts a better name)
13:42:07 <monochrom> this is pretty long code. what should I focus on?
13:42:07 <dmwit> monochrom: it parallels the `get` -> `gets` transition
13:42:24 <monochrom> @type gets
13:42:25 <lambdabot> MonadState s m => (s -> a) -> m a
13:42:57 <fizruk> monochrom: Monad/Applicative instance, compare with StateT
13:42:57 <dmwit> fizruk: `newtype DeclareT d m a = DeclareT { runDeclareT :: StateT d m a }`; `declare = DeclareT . modify . (<>)`
13:43:08 <monochrom> no, I don't think modify is a parallel
13:43:15 <Croissant_> Hello.
13:43:46 <dmwit> :t state
13:43:48 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
13:44:00 <monochrom> gets is a projection upon reading. modify is not a projection upon writing. modify is full unprojected writing.
13:44:15 <fizruk> dmwit: right, except not
13:44:46 <dmwit> fizruk: It's right. Your `declare` is broken.
13:44:53 <dmwit> fizruk: (And can be recovered from mine using `First`.)
13:45:01 <fizruk> dmwit: why?
13:45:15 <Croissant_> I've been searching up and down for an IRC channel to regular.
13:45:36 <arkeet> imo puts f = put . f
13:46:14 <fizruk> dmwit: monad/applicative seem to obey the laws, modify is not defined here because it is not a MonadState
13:46:23 <arkeet> just as gets f = f <$> gets
13:46:28 <arkeet> er, f <$> get
13:46:30 <dmwit> fizruk: I don't ask `modify` to be defined; my `modify` call is at type `StateT`.
13:46:36 <cocreature> Hey, I have a shake buildsystem and for some reason I am now getting "fd:4: hGetLine: invalid argument (invalid byte sequence)" when I run it. I didn’t get this before, but I can’t figure out which change caused it. searching around it looks like the locale can be a problem but my locale is set to "en_US.utf8" so that should hopefully be fine, what else can cause this error?
13:47:35 <fizruk> dmwit: oh, I see. did you take a look at applicative/monad instances?
13:47:58 <fizruk> dmwit: your declare is broken, because your definition is not the intended behavior
13:48:21 <monochrom> fizruk, your Applicative instance code and Monad instance code both look like doing WriterT to me. is this true?
13:49:03 <dmwit> monochrom: I guess not, since the later action can read the updated written value.
13:49:06 <fizruk> monochrom: it is similar, but not the same, since you can read all the previous logs and your computations can depend on it
13:49:38 <monochrom> I see
13:49:41 <fizruk> the idea is that Monoid d represents a list of declarations so far
13:49:47 <lispy> cocreature: that is indeed an encoding-related error message, but hGetLine is also a little suspect because it's lazy.
13:49:52 <fizruk> at least that's my use case
13:50:02 <lispy> cocreature: Do you read a lot of files?
13:50:07 <monochrom> ok, I have never heard of MonadDeclare. what are its laws?
13:50:09 <fizruk> so you can add a new declaration, can't remove it
13:50:26 <lispy> cocreature: actually, I need to get going
13:50:39 <cocreature> lispy: np, yeah I read quite a few files
13:50:44 <lispy> cocreature: I would trying changing the locale and also checking the encoding of the input
13:50:46 <fizruk> monochrom: I have just created this, that's why I asked whether this already exists :)
13:51:02 <lispy> cocreature: if you read a lot of files with hGetContents you might be running out of file handles
13:51:14 <lispy> cocreature: it depends on a lot of factors, but I gotta run
13:51:24 <cocreature> sure, thanks for the help
13:51:38 <monochrom> alright, I haven't seen this elsewhere, but I have never looked far, I am a poor data point.
13:52:35 <fizruk> monochrom: I guess I can write down some laws based on what Reader/Writer/State laws are
13:52:50 <dmwit> ==monochrom
13:53:48 <monochrom> the idea "(put . f) and (f <$> get) are dual" has two problems. first is (.) ≠ (<$>), although that can be mitigated by a stretch. second is types. (s -> s) is not dual to (s -> a)
13:54:27 <monochrom> @type put <$> f
13:54:29 <lambdabot> (Functor f, MonadState s m, FromExpr (f s)) => f (m ())
13:54:31 <monochrom> err
13:54:35 <monochrom> @type \f -> put <$> f
13:54:37 <lambdabot> (Functor f, MonadState s m) => f s -> f (m ())
13:55:22 * hackagebot hjsonschema 0.8.0.1 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.8.0.1 (seagreen)
13:55:33 <fizruk> nice, mtl does not have laws for MonadState/MonadReader/MonadWriter in the docs :(
13:55:53 <monochrom> there is an academic paper with MonadState laws
13:56:43 <monochrom> apart from that, people essentially have wetware laws in their heads (aka "expectation" "principle of least surprise") and never bothered to write down
13:57:15 <fizruk> yeah, I now
13:57:42 <fizruk> it just frustrates me, but not enough to send a PR
13:57:44 <monochrom> also, the paper is postmortem, i.e., after MonadState has been around for years. i.e., the point of the paper is try to bring the wetware expectation to concrete mathematics
14:00:22 * hackagebot texmath 0.8.4.1 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.4.1 (JohnMacFarlane)
14:08:29 <guillaum2> How can I parse lazyly something using attoparsec (or any other parser). I have a parser such as (double `sepBy` string "\n") which returns a list of double on which I'm doing a reduction. But as far as I know, attoparsec must parse the full document before returning its results, hence it builds a very huge list in memory instead of doing the reduction in O(1) space.
14:09:14 <dmwit> guillaum2: I believe uu-parsinglib has a lazy parsing story.
14:09:18 <geekosaur> ? attoparsec is often used with network streams in which the "full document" would be at stream close time, which would make it kinda useless...
14:09:21 <dmwit> Most parser combinator libraries do not.
14:09:47 <guillaum2> geekosaur: so I missed something...
14:09:56 <guillaum2> dmwit: I'll have a look, thank you.
14:10:23 * hackagebot dicom 0.3.0.0 - A library for reading and writing DICOM files in the Explicit VR Little Endian transfer syntax.  https://hackage.haskell.org/package/dicom-0.3.0.0 (PhilFreeman)
14:10:34 <geekosaur> well, your deifnition of "document" may be limited
14:12:48 <dmwit> geekosaur: I think attoparsec offers incremental input consumption, but not incremental output production.
14:13:27 <fizruk> monochrom: can you check out these laws? http://lpaste.net/146928
14:13:40 <kadoban> dmwit: I don't think that'd make much sense. So it never produces output until you close the network connection, or whatever you're parsing?
14:13:53 <guillaum2> geekosaur: my "document" is a 200 Gb file opened with Data.ByteString.Lazy.readFile
14:14:22 <dmwit> kadoban: Right. After all, it must decide whether the value to return should be a `Fail` or a `Done`.
14:15:09 <guillaum2> and I'm doing something such as (fromMaybe (maybeResult (parse (double `sepBy` (string "\n")) myContent))
14:16:03 <guillaum2> dmwit: it is what I thought. I wonder if I may be able to do the reduction inside the parser and let the parser returns the reduction result, it may works
14:16:20 <dmwit> guillaum2: attoparsec ought to be able to handle that parser. But I suspect the parser you're trying to use is `many {- that thing -}`.
14:16:43 <dmwit> guillaum2: You could consider omitting the `many` and handling the iteration yourself, which attoparsec should be able to support in an "incremental" way.
14:18:03 <guillaum2> dmwit: by handling the iteration myself, you mean, splitting on the "\n" (using lines) and running one parser per line ?
14:18:29 <ga2arch> guillaum2: pipes-attoparsec would probably be the perfect tool for the task 
14:18:30 <dmwit> I think the parser itself can still handle the newline.
14:18:45 <guillaum2> (what difference you are doing between (bla `sepBy` blo) and (many (bla <* bla)), except for the trailing blo ?
14:19:01 <dmwit> Once you've fed an attoparsec parser enough input to reach a newline, the one-line parser will indicate that it is `Done` and return the unparsed part of the file.
14:19:02 <guillaum2> (I was meaning (many (bla <* blo))
14:19:38 <guillaum2> ga2arch: I'll have a look, thank you.
14:19:43 <dmwit> guillaum2: Oh, right, the `sepBy` is what I was missing. That is the piece you should replace (not the `many` that you aren't using).
14:20:38 <dmwit> guillaum2: So your one-line parser would be something like `((Just <$> double) <|> (Nothing <$ noneOf "\n")) <* string "\n"`.
14:21:13 <athan> Can {-# INLINEABLE #-} be used with function instances? Or am I thinking nonsense?
14:21:22 <dmwit> What is a function instance?
14:21:56 <athan> sorry dmwit, I was talking about term instances for typeclasses
14:22:12 <athan> actually nevermind ><
14:23:06 <dmwit> Okay. I believe I understand your question.
14:23:27 <dmwit> I don't really know why I asked for clarification, though, since I know I don't know the answer no matter what it was you were attaching INLINEABLE to. =P
14:23:32 <guillaum2> dmwit: did I get that one right? the Nothing part is here to skip broken lines?
14:23:43 <dmwit> guillaum2: yes
14:24:55 <dmwit> guillaum2: I guess you could reasonably use `double <* string "\n"`, but then you would have to write parser-like code to skip to the end of the line yourself. =P
14:25:21 <dmwit> Or report an error in another way or something. I dunno. You get the idea.
14:35:24 * hackagebot foldl-transduce 0.4.6.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.6.0 (DanielDiazCarrete)
14:35:26 * hackagebot rose-trees 0.0.2.1 - A collection of rose tree structures.  https://hackage.haskell.org/package/rose-trees-0.0.2.1 (athanclark)
14:45:36 <guillaum2> dmwit: (Actually I tested before going to sleep, I was able to get line out one by one using a parser which parse a single line and calling it many times. It works on O(1), but it is still ten times slower than the stupid solution with read ;)
14:46:56 <lpaste> monochrom annotated “No title” with “No title (annotation)” at http://lpaste.net/146928#a146929
14:47:14 <monochrom> fizruk: http://lpaste.net/146928#a146929 shows a problem
14:48:25 <monochrom> oh bother, "declare y" is unnecessary. "declare x >> look >> look" would show the same problem, shorter and fewer steps :)
14:49:05 <fizruk> monochrom: right, should be like this then: declare x >> look == fmap (<> x) look >>= \xs -> declare x >> return xs
14:49:15 <fizruk> should be possible to do shorter
14:52:41 <l3dx> in order to run the parsec example from its homepage (github) I have to run ghci with the flag -XFlexibleContexts
14:52:43 <fizruk> probably: declare x >> look == fmap (<> x) look <* declare x
14:52:44 <l3dx> is that normal?
14:53:29 <fizruk> monochrom: what bothers me is that these laws do not account for >>=
14:53:51 <pavonia> l3dx: Could you paste the link?
14:55:42 <l3dx> pavonia: https://github.com/aslatter/parsec
14:56:29 <pavonia> l3dx: Do you mean the GHCi session there?
14:56:35 <l3dx> yes
14:58:54 <geekosaur> l3dx, it would not surprise me, ghc was recently changed so it is much more pedantic about that
14:59:16 <geekosaur> it used to silently apply FlexibleContexts when using types that were defined when that was in effect
14:59:21 <geekosaur> now it requires you to also enable it yourself
15:01:23 <l3dx> geekosaur: ok, thanks
15:05:08 <niez> template haskell question: how can I add type annotation to function generated with TH? here is my code: http://lpaste.net/146930 
15:05:25 * hackagebot drifter 0.2.1 - Simple schema management for arbitrary databases.  https://hackage.haskell.org/package/drifter-0.2.1 (MichaelXavier)
15:10:52 <pavonia> niez: There's sigD for type signatures
15:15:55 <Skull_Kid> Hi, I am new to using IRC any good security channels I can go check out? 
15:16:56 <pavonia> Skull_Kid: Try ##security
15:17:39 <niez> pavonia, thanks
15:20:45 <Jinxit> Skull_Kid: ##crypto
15:22:35 <Skull_Kid> Thanks guys! Any other channel that you learned a lot from? doesn't need to be security.
15:25:43 <mniip> every other channel
15:26:29 <Majiir> Huh. It seems 'flip (<**>)' and <*> are not always equivalent, although it seems as if they should be.
15:27:18 <johnw> Majiir: care to elaborate?
15:27:55 <Majiir> johnw: I'm working Day 10 of AoC, and arrived at this solution after some fiddling: aoc10 xs iters = length $ iterate ((flip (<**>) [length, head]) . group) xs !! iters
15:28:45 <mniip> Majiir, different ordering of effects
15:28:47 <Majiir> I wanted a cartesian application (?) of length and head, such that [[1],[3,3]] maps to [[1,1],[2,3]]
15:29:04 <mniip> > (+) <$> [1, 2] <*> [10, 20]
15:29:05 <lambdabot>  [11,21,12,22]
15:29:11 <mniip> > (+) <$> [10, 20] <**> [1, 2]
15:29:12 <lambdabot>      Could not deduce (Num a0)
15:29:13 <lambdabot>      from the context (Num a, Num ((a -> a) -> b))
15:29:13 <lambdabot>        bound by the inferred type for ‘e_1102012’:
15:29:32 <mniip> > [1, 2] <**> ((+) <$> [10, 20])
15:29:34 <lambdabot>  [11,21,12,22]
15:29:38 <mniip> oh wait
15:29:40 <Majiir> mniip, it seems so, and I'm trying to wrap my head around exactly where that happens. Is it an implementation detail of lists?
15:30:14 <mniip> oh yeah no, <**> is <*>
15:30:22 <mniip> (<**>) = liftA2 (flip ($))
15:30:43 <Majiir> Ahh, so it's not defined in terms of <*>
15:31:14 <mniip> what I was thinking of is that flip . liftA2 . flip /= liftA2
15:31:38 <Majiir> That would explain it!
15:34:30 <Majiir> So is the idea that the ordering of effects is changed as part of flipping the arguments, so that I can re-flip the arguments without flipping the effects? And would there be a cleaner way of flipping the effects than I've done above?
15:36:49 <brotknust> Hey #haskell
15:36:57 <Pamelloes> Hi!
15:36:58 <brotknust> I've written this function:
15:36:59 <brotknust> iterateM :: (Monad m) => (a -> m a) -> a -> m [a]
15:37:02 <brotknust> iterateM f x = f x >>= \y -> (x:) <$> iterateM f y
15:37:18 <brotknust> But I is not lazy, which I don't understand
15:37:24 <brotknust> *it
15:37:32 <jle`> it depends on the monad you're talking about
15:37:54 <jle`> it all comes down to how `m` behaves and how it defines (>>=)
15:38:12 <jle`> @let iterateM f x = f x >>= \y -> (x:) <$> iterateM f y
15:38:12 <brotknust> I've tried it inside IO with `iterateM (const . return $ ()) ()`
15:38:13 <lambdabot>  Defined.
15:38:31 <jle`> > iteraetM (const Nothing) 0
15:38:33 <lambdabot>      Not in scope: ‘iteraetM’
15:38:33 <lambdabot>      Perhaps you meant one of these:
15:38:33 <lambdabot>        ‘iterateM’ (line 158), ‘iterate’ (imported from Data.List),
15:38:36 <jle`> > iterateM (const Nothing) 0
15:38:38 <lambdabot>  Nothing
15:38:58 <jle`> brotknust: what did you expect to happen?
15:39:14 <brotknust> A lazy IO [(), (), (), .....]
15:39:54 <jle`> the latter part of your function goes (x:) <$> iterateM f y
15:40:09 <jle`> that means that it has to execute iterateM f y, and then fmap (x:) to result
15:40:26 * hackagebot tries 0.0.3 - Various trie implementations in Haskell  https://hackage.haskell.org/package/tries-0.0.3 (athanclark)
15:40:43 <brotknust> Oh, that's bad
15:40:45 <jle`> depending on the monad, this may or may not be the behavior you want
15:41:06 <jle`> for Maybe, it works, because Nothing means it never has to bind anything else
15:41:16 <jle`> for something like State s, it's catastrophically bad
15:41:18 <brotknust> I want the list to be lazy and iterateM won't ever terminate
15:41:35 <brotknust> Is there a way to do this lazily?
15:41:35 <jle`> becuase a `State s` action has to "return" the "final state" before it can move on
15:42:11 <jle`> so using iterateM with State s, if you bind it to another action, the next action will be waiting for the final state from an infinite chain of actions
15:42:24 <jle`> brotknust: well, what do you want to do with the list in the end?
15:42:26 <Pamelloes> Maybe you should build the list in the opposite order?
15:42:56 <jle`> some people write iterateM with an Int parameter that tells "how many times" to iterate
15:42:59 <brotknust> jle`: I want to run takeWhile on it
15:43:08 <jle`> then you can write iterateWhile
15:43:22 <jle`> iterateWhile :: (a -> Bool) -> (a -> m a) -> a -> m [a]
15:43:27 <brotknust> I guess that would be a possibility
15:43:31 <exio4> isn't there one in monad-loops?
15:43:35 <lispy> cocreature: I'm back. Any luck?
15:44:56 <brotknust> exio4: Theres an `iterateM_ :: Monad m => (a -> m a) -> a -> m b
15:45:02 <jle`> brotknust: think of the possibility that after iterating your (a -> IO a) enough times, you'll get an IO error.  so, the result m [a] should also be an IO error.  but it can't know that it's *not* an IO error until finishing the entire list
15:46:13 <brotknust> jle`: I thought laziness would take care of that
15:46:29 <jle`> laziness defers evaluation, not execution
15:46:30 <brotknust> Only execute the monadic action as often as I need its result
15:46:44 <jle`> generating the [a] requires executing an infinite amount of actions
15:46:54 <jle`> and resolving the result of an infinite amount of actions
15:47:07 <hackeiledge> is there an instance (Monad f) => Monoid (f a) -- ?
15:47:10 <jle`> laziness only defers evaluation, not execution :)
15:47:35 <exio4> hackeiledge: what'd be (<>)? and mempty?
15:48:02 <jle`> hackeiledge: there isn't, but a lot of Monads have an effective instance with Alternative
15:48:04 <jle`> and MonadPlus
15:48:16 <brotknust> Is there a difference between evaluation and execution in haskell?
15:48:17 <hackeiledge> liftA2 and pure
15:48:19 <jle`> the reason why is that the instance head is too big, so it'll cause a lot of chaos witho the type checker
15:48:24 <jle`> brotknust: yes, that's kind of the whole point :)
15:48:28 <kadoban> brotknust: Yes
15:48:38 <jle`> that's like...the "big deal" about Haskell, heh
15:48:41 <brotknust> Is there some good article to read about that?
15:49:21 <hackeiledge> exio4^?
15:50:42 <jle`> brotknust: consider a simpler example, iterateM Just 1
15:50:51 <jle`> > take 10 <$> iterateM Just 1
15:50:54 <lambdabot>  *Exception: stack overflow
15:51:02 <hackeiledge> ok sorry pure has the wrong type...
15:51:15 <jle`> in order for <$> to work, it has to know if iterateM Just 1 is a Just or a Nothing
15:51:31 <jle`> but how will it know, without iterating forever?
15:51:37 <jle`> what if the 10000th item is Nothing ?
15:51:47 <jle`> what if the one millionth trillionth result is Nothing?
15:52:23 <brotknust> Wouldn't it still know that iterateM returns a list and could therefore lazily create a cons?
15:52:34 <jle`> try expanding out the definition
15:52:45 <jle`> fmap (take 10) (iterateM Just 1)
15:52:50 <jle`> Maybe is nice because you can do it manually
15:53:05 <hackeiledge> lots of containers have empty and are monads, so while I cannot define the instance above, I can make a monoid instance for many monad instanes, those who, like Map, Graph, or List, have an empty function defined.
15:53:41 <jle`> brotknust: you'll see that you can never tell that the result is Just or Nothing
15:53:51 <jle`> so you won't know how `fmap` will behave
15:54:02 <jle`> remember that fmap has to *know* if it's Just or Nothing, before it can even start
15:54:08 <brotknust> Oh right
15:54:10 <hackeiledge> I thought the problem was in the brackets, can I say; instance Monoid (Data.Map a) where?
15:54:18 <brotknust> Now I get it
15:54:32 <jle`> the same goes for IO
15:54:45 <johnw> hackeiledge: not every monad, applied to a type, gives a monoid
15:54:54 <brotknust> I thought about it as iterateM :: (a -> m a) -> a -> [m a]
15:54:57 <brotknust> But it's m [a]
15:54:59 <johnw> hackeiledge: can you elaborate on what your intent is?
15:55:13 <exio4> well, (Applicative f, Monoid m) => Monoid (f a) is a thing if you really want to
15:55:14 <jle`> brotknust: yeah :)
15:55:24 <brotknust> jle`: Thank you very much
15:55:44 <jle`> np
15:55:50 <hackeiledge> I have a monad, my Graph data structure, and I would like to write a Monoid instance for a particular parametrisation, say (Graph Int)
15:55:53 <jle`> i do wish i had resources available to talk about execution vs evaluation in haskell
15:56:04 <jle`> there are a lot out there
15:56:08 <bitemyapp> jle`: you went to school right?
15:56:08 <jle`> it's worth looking into
15:56:09 <johnw> exio4: did you mean Monoid a?
15:56:15 <bitemyapp> jle`: if so, mind if I ask where?
15:56:17 <jle`> i still go to school bitemyapp 
15:56:38 <bitemyapp> jle`: right right, the class.
15:56:41 <jle`> i did my undergrad at UCSD and am doing my grad at Chapman U
15:56:53 <jle`> oh yeah, the class is at Chapman
15:56:54 <bitemyapp> jle`: sorry, I didn't know if you were a visiting teacher or not
15:57:01 <hackeiledge> my Graph has an Applicative instance
15:57:05 <exio4> johnw: newtype W f a = W (f a) ; instance (Applicative f, Monoid m) => Monoid (W f m) where mempty = pure empty; (<>) = liftA2 (<>) 
15:57:13 <bitemyapp> jle`: may I query you?
15:57:15 <jle`> hackeiledge: no reason why you can't write the instance directly, right?
15:57:19 <jle`> bitemyapp: sure thing
15:57:38 <johnw> exio4: ah, W f m, ok
15:57:44 <hackeiledge> so, I can obtain the desired functionality by writing the (Applicative f,Monoid a) Monoid (f a) instance
15:57:56 <hackeiledge> but i thought there was a problem with that syntax...
15:58:02 <jle`> you can, but it's a catastrophically bad way of achieving what you want
15:58:10 <jle`> just write the instance for Graph Int :)
15:58:22 <hackeiledge> no way!! it seems much more good
15:58:37 <hackeiledge> as general as that and you want to throw it away?
15:58:40 <hackeiledge> I dont get that
15:59:04 <hackeiledge> what motivates that choice for you?
15:59:11 <jle`> what if you wanted to write a Monoid instance for Monoid a => [a] ?
15:59:18 <jle`> i mean, for [a] ?
15:59:26 <hackeiledge> id have one already
15:59:32 <jle`> [a]'s monoid instance is probably best left as mappend = (++) and mempty = []
15:59:37 <hackeiledge> as it has an Applicative instane
15:59:46 <jle`> but now, how will GHC know what to choose if you wanted to use the Monoid instance for [String] ?
15:59:53 <jle`> would it use the sensible one with (++) and []
16:00:09 <jle`> or the general one with const [] and liftA2 (<>) ?
16:00:21 <jle`> both instances exist
16:00:26 <jle`> so, there's no way to reasonably decide
16:00:29 <hackeiledge> with mine it would go via applicative, with yours via the default
16:00:43 <jle`> yes, but what if i did ["hello"] <> ["world"]
16:00:46 <jle`> what would the result be?
16:00:55 <jle`> ["hello","world"], or ["helloworld"] ?
16:01:06 <hackeiledge> aha, so ghc will disallow this beause of overlapping instances from within the prelude?
16:01:12 <lindenk> Hey, so let's say I have a list of values (ex, (1-50)), and I would like to generate an ordered list of these values (ex, (1, 1, 1, 1), (1, 1, 1, 2)...). How can i represent this new list?
16:01:31 <hackeiledge> the later
16:01:33 <hackeiledge> doh
16:01:38 <hackeiledge> ok, so.
16:01:41 <hackeiledge> ???
16:02:13 <nshepperd> Monoid (f a) overlaps with the monoid instance for every other one-parameter type
16:02:27 <jle`> yeah, writing a general instance is a bad idea because now nobody would able to write a monoid instance that makes more sense for their `f a`
16:02:37 <hackeiledge> so no instance (Applicative f, Monoid a) Monoid (f a)
16:02:39 <jle`> disallowing a wide range of great instances
16:02:56 <hackeiledge> okok
16:02:57 <verement> lindenk: list comprehension
16:03:01 <kadoban> > take 5 $ replicateM 4 [1..5] -- lindenk
16:03:02 <hackeiledge> cool
16:03:03 <lambdabot>  [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,1,5]]
16:03:17 <hackeiledge> kinda kills all the joy but hey
16:03:46 <johnw> it also kills 'f a' that could be Monoids even when 'a' is not
16:04:07 <exio4> johnw: you can avoid the newtype wrapper but that's not vanilla Haskell 
16:04:32 <hackeiledge> so very not general instances please, ok
16:05:27 * hackagebot rose-trees 0.0.3 - A collection of rose tree structures.  https://hackage.haskell.org/package/rose-trees-0.0.3 (athanclark)
16:05:38 <jle`> instances in general are not very fun to work with, so a general instance actually sounds like something you should be scared of, heh
16:06:11 <hackeiledge> what about instance (Applicative f, Monoid a) Monoid (Free f a)?
16:06:23 <johnw> still not good for the same reason
16:06:32 <hackeiledge> brarg
16:06:39 <hackeiledge> possible though?
16:06:55 <johnw> try it
16:07:31 <hackeiledge> many error im sure, thats why im asking here and not the compiler because I always understand what it describes but never why it enforces that
16:08:03 <hackeiledge> if I remember its going to say no parenthesis please
16:08:08 <johnw> the best way to explore is by asking the compiler
16:08:16 <johnw> then you learn to speak its language, and to understand its responses
16:08:31 <hackeiledge> and then log on here to ask why its doing that
16:09:21 <hackeiledge> im good at errors, loads of experience, but I think this is a new one for me because of all this new instances and stuff, ill have never been allowed before, but I have never wanted to more
16:09:57 <lindenk> kadoban: Ah, ok cool. now what if I want it to start at a specific value?
16:10:32 <hackeiledge> when i hit really brutal limmitations of haskell the explanation for why they cannot be resolved is normally highly informative and helps me understand more what I was incorect in thinking
16:10:58 <athan> wtf, stack isn't printing out the test suite for one of my packages
16:11:26 <athan> er the results of the test suite
16:12:16 <hackeiledge> and if im wrong and ill be able to get it to compile fine I guess now would be the time to say... which is why I asked, can I do that
16:13:15 <hackeiledge> (hackeiledge) what about instance (Applicative f, Monoid a) Monoid (Free f a)?
16:15:26 <hackeiledge> or even; instance Monoid a => Monoid (Graph a)
16:15:41 <johnw> yes, but at a certain point, we have our own interesting problems to pursue; you'll need to explore this further yourself if you want to find an answer
16:15:42 <hackeiledge> or even; instance Monoid a => Monoid (Free Graph a)
16:16:46 <hackeiledge> argh, yeh ok I guess its too intense, ill try and leave off
16:17:40 <hackeiledge> sry, im super hurgry for input on this, I feel against a conceptual wall, ill go massage my brain or something
16:18:25 <ReinH> hackeiledge: have you tried to write those instances?
16:20:32 <hackeiledge> iv just been thinking about it I have no compiler atm, lambdabot does no instanes, or if it does I dont know how. I didnt think id get such reaction for not having the error to hand, I guess I am being told off for trying to use the channel as a compiler and I get that, ill wait till I can compile it
16:20:44 <ReinH> ...
16:21:46 <hackeiledge> instances*
16:23:18 <hackeiledge> and yes, mempty = emptyGraph, mappend = liftA2, mconcat = foldl mappend mempty
16:23:55 <ReinH> Does it satisfy the laws?
16:23:57 <hackeiledge> (my graph is Foldable and Applicative)
16:24:47 <hackeiledge> im going to guess yes, no laws were violated here
16:24:59 <ReinH> Wait, how do you expect mappend = liftA2 to work?
16:25:10 <ReinH> Did you try it?
16:25:27 * hackagebot aig 0.2.4 - And-inverter graphs in Haskell.  https://hackage.haskell.org/package/aig-0.2.4 (RobertDockins)
16:25:29 <hackeiledge> yeah i just realised it was shown that would not work above
16:25:29 * hackagebot abcBridge 0.15 - Bindings for ABC, A System for Sequential  Synthesis and Verification  https://hackage.haskell.org/package/abcBridge-0.15 (RobertDockins)
16:25:48 <hackeiledge> anyway I have union
16:25:51 <ReinH> Well, the types can't even unify
16:25:54 <hackeiledge> for my graph, that would do
16:26:08 <ReinH> How do you know that union is associative?
16:26:39 <hackeiledge> hmm, my graph is indexed like a stack
16:27:07 <hackeiledge> so its not symetric, but id expect it to behave ok
16:27:42 <hackeiledge> yeah, its just a wrapper for Data.Map really, so I guess that makes sure it behaves same under flip
16:28:02 <hackeiledge> sound ok?
16:29:05 <hackeiledge> does it sound like a well behaved graph would not be associative under construction?
16:29:17 <hackeiledge> ah, the overlapping allements thing
16:29:22 <hackeiledge> ellements...
16:29:42 <hackeiledge> its associative so long as the function in unionWith is
16:30:00 <hackeiledge> which in union it is not, being const
16:30:15 <hackeiledge> thanks!
16:30:44 <hackeiledge> so yeah its well behaved now?
16:35:02 <hackeiledge> k ill come back again some time with a paste...
16:35:14 <hackeiledge> thanks guys
16:38:58 <varaindemian> ReinH: thank you
17:03:45 <tkovs> "Programming in Haskell" by Graham Hutton. I get it today. This is as good as it sounds?
17:06:14 <shachaf> It's not very long -- and it's probably a bit out of date at this point -- but it's a pretty good introduction.
17:07:30 <echo-area> Succinct and inspiring
17:14:37 <tkovs> 2007
17:17:25 <c_wraith> 2007 is very old in haskell land.  That's about the same time I started learning the language.  Much has changed since then.
17:22:59 <talzs> Any suggestions for a 3d graphics library? I tried out OpenGL, and was looking at GPipe, but I'm still a bit undecided.
17:23:49 <Hijiri> gl is another OpenGL bindings
17:24:22 <Hijiri> you might find it nicer
17:25:47 <Hijiri> there is FWGL also
17:25:57 <talzs> Awesome, I'll take a look at it. Anything on the higher level side? Was hoping there might be some stuff out there for rendering spheres
17:26:20 <Hijiri> FWGL is higher-level, no idea if it has inbuilt sphere support though
17:26:31 <Hijiri> I haven't really done much with it, but I was looking at it at one point
17:27:05 <Hijiri> it doesn't look like it comes with spheres
17:27:30 <talzs> hmm FWGL looks pretty good otherwise though
17:27:48 <talzs> I suppose cubes wouldnt hurt heh
17:29:05 <nh4clo4> hey everyone! I'm a haskell newbie, trying to write a solution for one of the current Euler projects (the one about 10-substrings), but GHCi's been giving me some cryptic error messages
17:29:15 <nh4clo4> Here's my code: https://gist.github.com/anonymous/a1230cfa5cd2d767f152
17:30:15 <nh4clo4> and here's the link to the relevant project euler page if anyone wants to have a look (though I'm mostly looking for help with the error message)
17:30:15 <nh4clo4> https://projecteuler.net/problem=529
17:30:32 <geekosaur> and the error message(s)?
17:30:49 <geekosaur> however I see one thing immediately
17:31:09 <geekosaur> you're using (/) on something you declared as Integral a => a
17:31:16 <athan> Is attoparsec a "pure" parser? Or really, are the results memoized for the same input?
17:31:23 <nh4clo4> when I load it into ghci: "euler.hs:19:1: Parse error in pattern: substring' "
17:31:36 <athan> Or is there some `unsafeCoerce` borking things (with Data.Attoparsec.Text I mean)
17:31:46 <geekosaur> that's missing parentheses
17:31:47 <nh4clo4> I thought integrals allowed that? as in they just did integer division
17:31:58 <geekosaur> substring' (x:xs) =...
17:31:58 <Hijiri> athan: I think there is some unsafe stuff including in the API
17:32:06 <geekosaur> :t (/)
17:32:07 <lambdabot> Fractional a => a -> a -> a
17:32:10 <Hijiri> if you have an unfinished parse, you're not supposed to use the continuation more than once
17:32:15 <geekosaur> you may have been looking for
17:32:20 <geekosaur> :t div
17:32:21 <lambdabot> Integral a => a -> a -> a
17:32:58 <geekosaur> you have the same parentheses issue on line 23
17:33:02 <Hijiri> actually I'm not sure anymore, since I can't find the text that says that
17:33:13 <Hijiri> oh nevermind, I found it
17:33:20 <Hijiri> https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html#v:Partial
17:33:32 <Hijiri> "Note: if you get a Partial result, do not call its continuation more than once."
17:33:46 <geekosaur> patterns are parsed exactly the same way as expressions, so ``` substring'' xs y:ys ''' looks like: (substring'' xs y) : ys
17:33:52 <geekosaur> which is nonsense, so it complains
17:34:10 <nh4clo4> ohhhh, I see
17:34:33 <nh4clo4> so I could fix that with ``` substring'' xs (y:ys) ```?
17:34:36 <geekosaur> yes
17:35:06 <koz_> Is there a Haskell package for the Cantor pairing function?
17:35:10 <koz_> Or am I rolling that one myself?
17:35:47 <pavonia> There is one
17:35:58 <koz_> pavonia: Can you recall the name?
17:36:10 <pavonia> Unfortunately, no :(
17:36:20 <koz_> Sadface.
17:37:03 <athan> Hijiri: Ahh okay, I see. So I would need to manually build my own caching?
17:37:43 <Hijiri> probably
17:38:08 <koz_> Well, I can roll my own, it's OK.
17:38:14 <koz_> I need it specifically for four-tuples.
17:39:09 <athan> Would it be smart to use STM inside unsafeCoerce? :)
17:39:25 <Hijiri> koz_: there is https://hackage.haskell.org/package/enumerable-0.0.3/docs/Data-Enumerable.html
17:39:34 <pavonia> koz_: There's "universe", which isn't the one I remember, but it has such an instance
17:39:48 <athan> Oh crap, how would I cache existential data? :(
17:39:59 <athan> maybe a `coerce` to make GHC use it?
17:40:17 <koz_> Hijiri: Thanks!
17:40:57 <Hijiri> athan: are the inputs existential or the outputs?
17:41:49 <Hijiri> oh, I guess it would have to be the outputs, if you're parsing Text
17:42:31 <koz_> Hijiri: I might just be stupid or ignorant, but how can I implement Cantor pairing with Data.Enumerable?
17:42:46 <Hijiri> koz_: actually sorry, I don't know if it uses Cantor pairing in particular
17:42:55 <Hijiri> but there is an Enumerable instance for (a, b, c, d)
17:43:05 <Hijiri> where a, b, c, d are themselves Enumerable
17:43:45 <koz_> Hijiri: Is Numeric.Natural enumerable?
17:44:04 <koz_> My goal is to have a way of having a bijective N x N x N x N -> N function for encoding 4-tuples as a single number.
17:44:09 <koz_> (reversibly, obv)
17:44:29 <Hijiri> this might not be the right library then
17:44:31 <koz_> I figured Cantor pairing was a way to go, but if you can think of a better way, I'd love to know.
17:44:40 <Tritlo> Hey, is there any way for me to catch a singular error ? I.e. when I use a element n lens and element n does not exist?
17:44:54 <Hijiri> the Enumerable typeclass just gives a way to get a list of all the elements
17:44:59 <Tritlo> or even a lens operator that returns a maybe?
17:45:05 <Hijiri> so it would be inefficient to use it that way
17:45:07 <athan> Hijiri: Yeah, it's the outputs :\
17:45:30 * hackagebot statsd-client 0.2.0.0 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.2.0.0 (keith_duncan)
17:45:46 <athan> I have a weird lookup table that uses this existential predicate (which attoparsec might embody), and the result of the lookup needs to be a function preceeded by that very type
17:46:00 <athan> so if I embed an attoparsec `Double` parser, the result must be `Double -> x`
17:46:11 <athan> it works fine in the pure scenario, but there's no caching :\
17:46:16 <Hijiri> athan: have you looked at DMap?
17:46:29 <Hijiri> https://hackage.haskell.org/package/dependent-map
17:46:41 <Hijiri> you can have the type of the values depend on the key
17:46:48 <athan> It's usually 500ns per parse :(
17:47:00 <athan> oh woah
17:47:11 <Hijiri> maybe you can have the predicate be decided by the key
17:47:50 <mniip> athan, you can, uh, switch a context in that much time!
17:48:33 <athan> Hijiri: Hmm, this seems interesting
17:48:58 <athan> mniip: But....
17:48:59 <athan> metal :|
17:53:54 <pavolzetor> hi, suppose I have a tree and each branch can have Maybe Int
17:54:07 <pavolzetor> how do I get the smallest from the two children (binary tree)?
17:55:49 <pavolzetor> sort of call min if both are just
17:55:56 <koz_> :t foldM
17:55:58 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
17:56:05 <koz_> No, not quite what you see.
17:56:07 <koz_> seek*
17:57:56 <pavolzetor> I don't understand how I would use that
17:58:04 <pavolzetor> I wanted to use monoid
17:58:14 <pavolzetor> but without making an instance
17:59:11 <pavolzetor> and liftM2 does not handle nothing correctly
17:59:16 <nh4clo4> geekosaur: that worked wonderfully! Ironed out a few bugs and `substring` is working fine now. Thanks for the help!
17:59:20 <pavolzetor> (the way I want)
18:02:21 <pavolzetor> http://stackoverflow.com/questions/25769820/minimum-of-two-maybes
18:02:25 <pavolzetor> this helped
18:04:38 <rpfun> is there a good way to fold over a list, but stop and return if some condition is met?
18:05:11 <rpfun> the function would not be hard to write myself, i am looking for something built-in
18:05:42 <dmj> rpfun: return what?
18:06:35 <rpfun> dmj: the accumulator
18:07:01 <rpfun> concrete example: i have a list of integers, and I want to take the sum of elements from left to right until the result is greater than some value
18:08:03 <rpfun> one could write this in that example: head . dropWhile (< max) . scanl (+) 0
18:08:11 <rpfun> but I worry about the efficiency of such a function
18:08:40 <rpfun> i'm not sure something like that will even fuse away
18:09:12 <pavolzetor> hmm, did not help, I also want to pass the result of first function to second
18:09:43 <pavolzetor> similarly to binary tree traversal, where branches needs to be cut as soon as possible
18:09:56 <pavolzetor> i.e. intersect left >> intersect right
18:10:12 <pavolzetor> where left will pass t parameter
18:10:19 <pavolzetor> to the right
18:10:31 * hackagebot pred-trie 0.4.0 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.4.0 (athanclark)
18:10:34 <pavolzetor> so right traversal can be terminated early
18:11:06 <pavolzetor> (currently recursive bilinear patch)
18:12:09 <ski> rpfun : s/head/last/ ?
18:12:26 <pavolzetor> also, would you use vector to store the traversal stack?
18:12:32 <pavolzetor> (I am worried about speed)
18:12:33 <rpfun> ski: i don't think so...
18:13:02 <rpfun> ski: that's dropWhile, not takeWhile (maybe your confusion)
18:13:17 <ski> oh. yes, indeed
18:13:37 <rpfun> that said, any suggestions on performance improvements? :)
18:13:49 <rpfun> *potential performance improvements
18:15:01 <ski> rpfun : i suppose you could try using `foldM' with an exception (or continuation) monad ..
18:15:37 <rpfun> and that doesn't seem like an excessive amount of machinery? I could just write a recursive loop at that point...
18:16:20 <pavolzetor> is there a way force stack automatically rebuild ?
18:16:31 <pavolzetor> stack exec (if changes -> rebuild)
18:18:15 <mgsloan> "stack build --file-watch"
18:19:04 <ski> > let max = 20 in (head . dropWhile (< max) . scanl (+) 0) [0 ..]
18:19:05 <lambdabot>  21
18:19:29 <ski> > let max = 20 in (foldr (\n k s -> if s >= max then s else k (s + n)) (\s -> s) `flip` 0) [0 ..]
18:19:30 <lambdabot>  21
18:19:41 <ski> rpfun : .. not sure whether you like that ^
18:27:46 <rpfun> ski: might that actually be faster? also is the idea basically continuations there?
18:28:18 <athan> HashMap is generally the fastest pure map for lookups, isn't it?
18:28:50 <ski> you could think of it in terms of continuations
18:29:34 <ski> it's the "leaned so far right they came back left" trick
18:33:04 <rpfun> ski: it's a very cool trick. would you say it's practical though?
18:36:32 <koz_> :t read :: Int
18:36:34 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘String -> a0’
18:36:34 <lambdabot>     Probable cause: ‘read’ is applied to too few arguments
18:36:34 <lambdabot>     In the expression: read :: Int
18:36:42 <ReinH> rpfun: I don't see any reason to believe that the scanl version wouldn't be performant
18:36:43 <koz_> Whoops, my bad.
18:37:07 <ReinH> or perhaps scanl'
18:37:29 <rpfun> can I trust haskell to fuse away the extra allocations though?
18:39:52 <koz_> :t print
18:39:54 <lambdabot> Show a => a -> IO ()
18:40:32 * hackagebot machinecell 3.0.0 - Arrow based stream transducers  https://hackage.haskell.org/package/machinecell-3.0.0 (HidenoriAzuma)
18:42:13 <bob> Hey
18:42:16 <bob> Anyone here?:)
18:42:22 <Nomenclatura> nope
18:42:25 <bob> :(
18:42:32 <Nomenclatura> just 1496 bots
18:42:34 <dmj> bob: yes
18:43:10 <Guest79497> Can anyone help out a noob with an optimisation issue? :)
18:44:00 <tjs000> pair of noobs...
18:44:43 <talzs> What should I be doing when stack solver fails to find a build plan?
18:45:04 <Nomenclatura> tjs000: that makes them (.)(.) ;)
18:45:04 <maerwald> ditch it
18:45:24 <mgsloan> talzs: That means that cabal-install failed to solve the constraints
18:45:26 <tjs000> if only...
18:45:31 <Nomenclatura> lol
18:46:06 <mgsloan> talzs: I would pick the latest lts or nightly resolver and then see which constraints aren't working out 
18:46:42 <Guest79497> Anyone know a fair bit about game tree optimisation? 
18:46:49 <talzs> Alrighty thanks :D
18:47:37 <maerwald> Guest79497: if you keep asking for people instead of answers, you'll probably not get them
18:47:50 <EvanR> :t (.)(.)
18:47:51 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
18:48:01 <EvanR> :t (.) . (.)
18:48:03 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:51:42 <Guest79497> Am I going about this correct? I have a game that can be only won or lost, no drawing and the game tree can take some time to make: http://pastebin.com/Uc6Nkttn
18:53:23 <Guest79497> I end up having an Int list of either 1s or -1s, 1s being winning positions if the computer takes that path
18:53:36 <Guest79497> It works, just really slow
18:56:27 <ReinH> Guest79497: one obvious issue is that recursively adding to the end of a list is extremely slow
18:56:53 <Guest79497> Ok thats fair enough, is using : faster then ++ ?
18:57:02 <ReinH> oh, wait, you are adding to the beginning
18:57:35 <julianleviston> Guest79497: yes.
18:57:44 <Guest79497> Yeah, the position of a winning branch 
18:57:51 <ReinH> x : xs and [x] ++ xs are equivalent
18:57:54 <Guest79497> I could add to the end then reverse it
18:58:04 <julianleviston> That’s even slower, I think.
18:58:49 <pavonia> Guest79497: If your only values are -1 and 1, you can write specialized versions of minimum and maximum that stop on the first occurence of -1 and 1, respectively
18:59:11 <ReinH> or you can not use -1 and 1
18:59:15 <ReinH> and use your own data type isntead
18:59:17 <ReinH> instead
18:59:21 <ReinH> or even True and False
18:59:22 <Guest79497> Would bools be faster?
18:59:39 <ReinH> I don't know why it's slow. Have you done any profiling?
18:59:43 <Guest79497> Ok thanks, Ill try using bools
18:59:49 <ReinH> Actual profiling will always be better than asking random people to guess.
19:00:20 <Guest79497> Ive only been studying Haskell for a few months
19:00:21 <tjs000> ok so me and Guest79497 are trying to do this together
19:00:23 <tjs000> i was just trying to do profiling...
19:00:27 <pavonia> > minimum $ False : replicate 1000000 True
19:00:31 <lambdabot>  *Exception: stack overflow
19:00:32 <maerwald> I'd rather do: data Winner = P1 | P2 ... bools are just awkward
19:00:37 <julianleviston> ReinH: Scientific method FTW.
19:00:51 <tjs000> BUT, i can't run a haskel program i just compiled with -prof, i don't know how :/
19:00:56 <ReinH> pavonia: min and max are strict in their second argument, but || and &&, which are otherwise equivalent, are not
19:00:58 <tjs000> haskell*
19:01:03 <ReinH> or && and ||, respectively
19:01:21 <ReinH> > all (repeat False)
19:01:24 <lambdabot>      Couldn't match expected type ‘a -> Bool’ with actual type ‘[Bool]’
19:01:24 <lambdabot>      Possible cause: ‘repeat’ is applied to too many arguments
19:01:24 <lambdabot>      In the first argument of ‘all’, namely ‘(repeat False)’
19:01:26 <ReinH> woops
19:01:31 <ReinH> > and (repeat False)
19:01:34 <lambdabot>  False
19:01:37 <Guest79497> So I should stop using max and min and write my own? Would maximum work on bool lists?
19:01:42 <ReinH> Guest79497: I don't know.
19:01:42 <julianleviston> :t repeat
19:01:44 <lambdabot> a -> [a]
19:01:48 <ReinH> I don't know what is slow, so I can't tell you how to make it fast
19:01:49 <maerwald> ReinH: and is foldr, right?
19:01:57 <ReinH> I have no reason to assume that the integers are slow.
19:02:00 <ReinH> integers tend to be pretty fast.
19:02:14 <ReinH> @src and
19:02:14 <lambdabot> and  = foldr (&&) True
19:02:18 <tjs000> if i have a .hi and a .o file... how doe i run either of them?
19:02:18 <maerwald> yep
19:02:29 <ReinH> tjs000: you don't, you compile a binary.
19:02:37 <Guest79497> I was thinking to stop serach a particular branch if its finds one of both true and false
19:02:42 <tjs000> i compiled trhe .hs
19:02:45 <ReinH> you can use ghc for that, but it's easier to use cabal or stack.
19:02:50 <Guest79497> Because any values after are redundant
19:03:27 <ReinH> Guest79497: yes, you can use e.g. alpha-beta pruning
19:03:44 <julianleviston> hang on, isn’t foldr (&&) True lazy?
19:03:54 <ReinH> julianleviston: Yes, I just showed that it is.
19:03:59 <julianleviston> that’s what I thought
19:04:06 <julianleviston> Guest didn’t seem to realise this.
19:04:20 <ReinH> Guest79497: but if your program is inefficient in its use of stack or heap or w/e, you should work on making it efficient first
19:04:41 <Guest79497> Well, this function is the bulk of the slowness
19:05:10 <ReinH> how do you know?
19:05:48 <Hijiri> Revelation, Reason, Experience, Authority, Madness
19:06:10 <Guest79497> Hmmm good point
19:06:18 <julianleviston> Hijiri: sounds straight from Tao te Ching ;-)
19:06:32 <Guest79497> Running the function in ghci you can see it takes a while haha
19:06:43 <maerwald> uhm, there's a call stack :)
19:06:51 <ReinH> hhttps://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
19:07:05 <ReinH> Don't guess.
19:07:25 <tjs000> i tried to do that
19:07:47 <tjs000> and couldn't do the 'run step' :p
19:09:51 <ReinH> Well, what happened when you tried?
19:10:23 <julianleviston> he said he doesn’t know how to run a haskell program with -prof
19:10:30 <julianleviston> s/he*
19:11:13 <Guest79497> Changing to bools did nothing, going to try to prune now :P
19:11:33 <tnks> it would be nice if there were some static analysis to know which arguments of a function are strictly evaluated, so it could be reported by something like :info
19:11:46 <tnks> I don't know if there's a proof that that's not possible for some reason.
19:11:47 <geekosaur> you can look at te Core
19:12:05 <geekosaur> @hackage ghc-core
19:12:05 <lambdabot> http://hackage.haskell.org/package/ghc-core
19:12:43 <geekosaur> said analysis is done and if you dump the generated core it shows what strictness analysis has determined for parameters
19:14:10 <bitemyapp> tnks: it's known statically which will be evaluated and at what time in the Core.
19:14:20 <bitemyapp> tnks: trick is learning how to clean up the core and read it.
19:14:44 <bitemyapp> tnks: http://www.haskellforall.com/2012/10/hello-core.html is an intro that uses ghc-core.
19:15:42 <bitemyapp> tnks: also see: http://dev.stephendiehl.com/hask/#core
19:16:11 <bitemyapp> tnks: note the implementation of seq in Core.
19:17:10 <bitemyapp> tnks: and this answer by Marlow: http://stackoverflow.com/a/7492727
19:17:17 <bitemyapp> tnks: how familiar are you with the C Std?
19:24:30 <tjs000> ok, pretty stupid question coming up... can i map || over a list of Bools?
19:24:49 <julianleviston> tjs000: yes
19:24:57 <julianleviston> tjs000:  but you might not end up with what you’re expecting
19:25:12 <tjs000> it doesn't return a Bool?
19:25:16 <julianleviston> :t map (||)
19:25:17 <lambdabot> [Bool] -> [Bool -> Bool]
19:25:28 <geekosaur> you may be thinking of a fold
19:25:34 <ReinH> @src or
19:25:34 <lambdabot> or = foldr (||) False
19:25:41 <julianleviston> tjs000: that reads…. map (||) gives a function that takes a list of Bools, and returns a list of sections of Bool to Bool.
19:25:58 <tjs000> that'll be why i'm confused then...
19:26:08 <julianleviston> tjs000: so map (||) will give you a list of partially applied functions.
19:26:37 <julianleviston> tjs000: but you can do map (|| True) or something if you want a list of bools...
19:27:11 <tjs000> so how do i write something that's [Bool] -> Bool using the 'function' || ?
19:27:18 <tnks> bitemyapp: ah, good to know about Core (yeah, not as user-friendly as what I was suggesting, but maybe some day)
19:27:21 <tjs000> is that a fold?
19:27:51 <tnks> bitemyapp: also, I wouldn't say I know the C standard that well; it's been a while since I did any real C, so what I know is topical.
19:28:10 <tnks> We'll assume you're comfortable with a text editor, have the Python
19:28:10 <tnks> interpretter installed, and can run Python programs from a terminal.
19:28:13 <bitemyapp> tnks: the analogy probably won't help too much
19:28:18 <Guest79497> Ok Ive added a pruner: http://pastebin.com/hYjTGMQC           It uses an accumlator to store values and if it find a -1 and 1 in the same acc it terminates that branch 
19:28:19 <bitemyapp> tnks: but in C there's a notion of sequence points.
19:28:22 <julianleviston> tjs000: well, foldr (||) is such a function.
19:28:22 <ReinH> tnks: you would write it like or
19:28:27 <bitemyapp> tnks: between which the compiler is free to reorder instructions
19:28:36 <Guest79497> Doesnt seem to be giving the right result thought, anything silly that ive done? :P
19:28:38 <tnks> (scratch those last two lines). . . bad paste.
19:28:47 <ReinH> er
19:28:49 <bitemyapp> tnks: strictness points are a similar sort of idea, but for letting you know where something _must_ be forced whether it's the first time or not.
19:28:50 <julianleviston> tjs000: sorry, foldr1 (||)
19:28:59 <ReinH> there's no need for foldr1
19:29:09 <ReinH> you have a monoid so you have an empty element
19:29:16 <ReinH> @src or
19:29:16 <lambdabot> or = foldr (||) False
19:29:33 <bitemyapp> tnks: in Core, case is always strict, that's why seq's definition is what it is.
19:29:35 <julianleviston> ReinH: what’s wrong with foldr1 ?
19:29:39 <julianleviston> ReinH: is it bad?
19:29:43 <ReinH> > foldr (||) []
19:29:44 <Hijiri> it's partial
19:29:45 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[t0]’
19:29:45 <lambdabot>      In the second argument of ‘foldr’, namely ‘[]’
19:29:45 <lambdabot>      In the expression: foldr (||) []
19:29:53 <ReinH> > foldr1 (||) []
19:29:54 <lambdabot>  *Exception: Prelude.foldr1: empty list
19:29:56 <tnks> bitemyapp: makes sense.
19:29:57 <bitemyapp> tnks: of course, here "strict" always means WHNF. NF requires NFData and a bunch of hop-skip-jumping around.
19:30:17 <bitemyapp> you'll see a "case" for each layer of the datatype if you use nf on a value in the Core.
19:30:20 <ReinH> there's no need for foldr1 when you have a canonical replacement for the empty list
19:30:25 <julianleviston> Fair enough.
19:30:29 <bitemyapp> there's no need for foldr1 at all, I'm pretty sure.
19:30:45 <bitemyapp> make them write the 'error' themselves, if they're going to perpetuate evil.
19:30:46 <julianleviston> sometimes things can be useful :)
19:30:49 <ReinH> bitemyapp: sure
19:30:54 <bitemyapp> julianleviston: not in this case.
19:30:58 <bitemyapp> I don't like abstracting out bottoms.
19:31:04 <bitemyapp> I'd rather make people declare the evil they're getting up to.
19:31:12 <bitemyapp> rather than blithely using bad-functions from Prelude.
19:31:20 <bitemyapp> still pissed about safe.
19:31:27 <julianleviston> bitemyapp: sounds a bit absolutist for my liking, but as always, you’re free to state your preferences.
19:32:00 <bitemyapp> julianleviston: thinking you need a partial function for something like 'foldr1' is a sympton, not a reason.
19:32:20 <bitemyapp> There are cases where you legit need a bottom. They are very rare.
19:32:24 <julianleviston> bitemyapp: again. I understand and appreciate your perspective. You don’t need to convince me of anything.
19:32:40 <bitemyapp> even the Applicative for Data.Sequence eventually had the bottoms squashed and that was some gnarly code.
19:32:49 <bitemyapp> per Feuer's work.
19:33:37 <c_wraith> Data.Sequence is a gnarly data structure, though.  So it's not surprising.
19:34:08 <tjs000> ok so if foldr1 does what i want it to do... will it do so lazily, ie if the first element of my foldr1 (||) [Bool] is True will it immediately return True?
19:34:11 <bitemyapp> c_wraith: right. it was one of those, "well this is clearly impossible but I can't prove it to the compiler with this design" dark holes.
19:34:26 <bitemyapp> even then, you're writing explicit bottoms rather than having incomplete pattern matches.
19:34:30 <elpetrero> gnarly means remarkable or unpleasant?
19:34:33 <julianleviston> tjs000: no, they are right, don’t use foldr1 because it won’t work with lists of length 1 or 0.
19:34:36 <ReinH> tjs000: don't use foldr1
19:34:39 <bitemyapp> I eventually convinced Feuer to refactor the code to make the bottoms unnecessary.
19:34:47 <ReinH> tjs000: As I've said 4 times now, look at or
19:34:50 <bitemyapp> and it turns out, doing so sped up the code slightly as a perk.
19:34:51 <julianleviston> bitemyapp: you can make a very persuasive argument.
19:34:52 <c_wraith> elpetrero: more literal, in this case.  Twisted up.  Gnarled.
19:34:55 <ReinH> @src or
19:34:55 <lambdabot> or = foldr (||) False
19:34:59 <ReinH> tjs000: ^^^^^^^^^^^^^^
19:35:19 <elpetrero> Oh OK (where is my webster... )
19:35:29 <bitemyapp> julianleviston: I just got back from running with my dog so I'm in a red haze.
19:35:31 <tjs000> i'm sorry someone wrote folr1 and i went away to try... or? i'll try that :) thanks
19:35:41 <julianleviston> bitemyapp: what on earth is a red haze?!
19:35:44 <bitemyapp> tjs000: just don't use partial functions.
19:35:49 <bitemyapp> julianleviston: ever play Doom?
19:36:02 <julianleviston> tjs000: it’s my fault. I wrote it. Apologies. 
19:36:05 <julianleviston> bitemyapp: yeah
19:36:42 <bitemyapp> julianleviston: ever get the berserker powerup?
19:36:53 <julianleviston> bitemyapp: It’s been a long time. :)
19:37:00 <bitemyapp> do you know what a berserker is?
19:37:08 <julianleviston> bitemyapp: I believe so.
19:37:10 <bitemyapp> And thanks for reminding me to bring this up with Stephanie -- will do so next week.
19:37:13 <bitemyapp> woops
19:37:17 <bitemyapp> mispaste
19:37:21 <bitemyapp> https://en.wikipedia.org/wiki/Berserker
19:37:27 <bitemyapp> julianleviston: right so, red haze.
19:37:34 <bitemyapp> julianleviston: running makes me miserable, tired, grumpy.
19:40:46 <tjs000> OMG guys you're genii
19:40:57 <tjs000> the speed is unreal... :D
19:40:57 <Guest79497> ^^^
19:40:59 <Guest79497> We are happy :D
19:41:02 <Guest79497> Ok that worked
19:41:10 <Guest79497> Thanks a lot :P
19:41:22 <julianleviston> Happy can be good! :)
19:41:28 <tjs000> forget +/- 1... <3 Bools :D
19:41:32 <julianleviston> Unless it leads to sadness.
20:00:24 <ReinH> it has nothing to do with bools
20:00:35 * hackagebot sdl2-compositor 1.2.0.3 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.2.0.3 (seppeljordan)
20:00:35 <ReinH> you could achieve the same with +/- 1
20:33:22 <lindenk> hey, so I see that Data.List has isSubsequence, and subsequencies. But it also has isInfix but not infixes. Is there a builtin that creates a list off all infixes of a list?
20:33:53 <julianleviston> lindenk: how would it differ from subsequences?
20:34:45 <lindenk> "abc" -> ["", "a", "ab", "abc", "bc", "c"]. subsequences would also give "ac"
20:37:34 <gfixler> lindenk: how would it also give "ac"? They're not adjacent
20:37:35 <julianleviston> lindenk: so you want successive subsequences?
20:37:50 <lindenk> julianleviston: yea, exactly
20:37:51 <julianleviston> gfixler: his point is subsequences gives non-adjacent ones.
20:37:59 <gfixler> julianleviston: ah, weird
20:38:17 <julianleviston> gfixler: yeah, I thought so too! 
20:38:21 <gfixler> that doesn't sound like subsequences
20:38:27 <gfixler> more like combinations or somesuch
20:38:43 <gfixler> they're not in sequence :)
20:38:50 <gfixler> subNonSequences
20:39:09 <julianleviston> kind of… permutations does something like what you’re talking about… sort of. There’s a difference
20:39:37 <gfixler> ah, so it's not every ordering, though
20:40:02 <gfixler> so it's like every possible removal
20:40:02 <julianleviston> gfixler:  right.
20:40:15 <julianleviston> gfixler: permutations is “keeping the items, arrange them in every possible combination"
20:40:16 <gfixler> useful, but I'd like a better name
20:40:34 <lindenk> combinations should make more sense
20:40:36 <MarcelineVQ> > (++) <$> inits <*> drop 1 . tails $ "abc"
20:40:36 * hackagebot webfinger-client 0.1.0.0 - WebFinger client library  https://hackage.haskell.org/package/webfinger-client-0.1.0.0 (akrasner)
20:40:37 <julianleviston> gfixler: obviously the name chosen is someone else’s “better name”… 
20:40:38 <lambdabot>  ["","a","ab","abc","bc","c",""]
20:41:03 <lindenk> 0.o yeah that works. Thanks
20:41:05 <julianleviston> MarcelineVQ: :)
20:41:14 <gfixler> julianleviston: you say this after I just had a programmer on my team say "Whatever - we'll make a better name later."
20:41:34 <julianleviston> gfixler: For him, that was a better name for his existing constraints.
20:41:39 <julianleviston> gfixler:  ;-)
20:41:46 <julianleviston> gfixler: there’s always a better name.
20:41:56 <gfixler> and always a truer statement, modulo some qualifiers
20:42:13 <lindenk> I'm still kind of a newbie. <$> and <*> are still kinda foreign to me
20:42:14 <julianleviston> gfixler: um.
20:42:22 <julianleviston> lindenk: theyr’e from applicative
20:42:36 <gfixler> I've been thinking that as an industry, we should fund some screenwriters
20:42:41 <julianleviston> lindenk: you could write that function yourself using simple recursion. It’s probably a good exercise if you’re new.
20:42:48 <gfixler> and have them start using new words for things like "groupings of stuff"
20:43:00 <gfixler> get them into the zeitgeist
20:43:00 <julianleviston> gfixler: language is imperfect. 
20:43:02 <gfixler> then we can use them
20:43:29 <gfixler> iow, I want to speed up language evolution artificially, so we have more succinct names to choose from
20:43:36 <julianleviston> gfixler: language is, unfortunately, the analogue to digital converter of semantics for computation.
20:43:55 <julianleviston> gfixler: I think that might perhaps be falsely predicated.
20:44:42 <julianleviston> gfixler: speeding up evolution of things often ends up in skipping steps, and we end up with “buildings built with sloppy techniques”
20:44:58 <MarcelineVQ> lindenk: if you wanted it in a plainer form, inits "abc" ++ (drop 1 . tails) "abc" is the same thing, I just put it that way to only have to supply "abc" once
20:45:11 <gfixler> julianleviston: we're just talking about squeaks made by pushing air through meat here, though
20:49:03 <gfixler> (++) <$> inits <*> drop 1 . tails $ "abc"
20:49:15 <gfixler> (++) <$> inits == fmap (++) inits
20:49:21 <gfixler> fmap over functions is composition
20:49:46 <julianleviston> gfixler: his/her problem was that they didn’t understand applicative… they’re a (self-confessed) noob… 
20:49:54 <gfixler> julianleviston: I read that
20:50:05 <julianleviston> gfixler: ok. sorry wasn’t sure who you were writing that for.
20:50:11 <gfixler> julianleviston: all the world
20:50:55 <gfixler> fmap allows us to apply an f to an x when the x is in some context
20:51:07 <gfixler> in this understanding, a list is still just an x - a single value
20:51:13 <gfixler> but it exists in superposition
20:51:24 <gfixler> it can not exist, or have 1 value, or many values
20:51:31 <gfixler> and fmap needs to still just apply an f to it
20:51:39 <gfixler> which it does by applying f to any and all values inside the list
20:51:45 <gfixler> creating a superposition of results
20:51:57 <gfixler> and it's still just f of x, but in the many-worlds context
20:52:32 <gfixler> so fmap (++) inits turns some inits into [(init1++),(init2++),...] for all inits
20:54:38 <fr33domlover> Hello! I'd like to write a program that takes a CSV file of known format and generates some Haskell code from it. I picked cassava for the CSV, but what do I use to generate indented nice Haskell values? I can use plain strings, but perhaps there's some package for that?
20:54:41 <lindenk> well so it's like map, but rather than over a list, it's over a function, and the result takes a list of a instead of an a?
20:54:56 <gfixler> lindenk: no, more general than that, I'm afraid
20:55:03 <gfixler> and hard to explain :)
20:55:11 <gfixler> lindenk: do you know fmap yet?
20:55:33 <geekosaur> plenty of prettyprinting packages, plus there may be some code formatting stuff in haskell-src-exts
20:55:37 <lindenk> i read most of 'learn haskell for great good' but that was a bit ago
20:56:00 <lindenk> i might reread it to understand it better
20:56:09 <fr33domlover> geekosaur, thanks
20:56:14 <gfixler> lindenk: it's not generally recommended in here anymore
20:56:15 <julianleviston> lindenk: have you done algebraic data types?
20:56:21 <julianleviston> gfixler: poppycock.
20:56:25 <gfixler> julianleviston: oh?
20:56:31 <gfixler> julianleviston: I only ever see people berating it
20:56:35 <julianleviston> gfixler: it’s fine as a reference.
20:56:37 <geekosaur> (actually I know there is code formatting in there but it may require you feed it an AST)
20:56:40 <julianleviston> gfixler: and a lot of people love it.
20:56:45 <gfixler> julianleviston: I also read it cover to cover, and still couldn't write any haskell
20:56:50 <julianleviston> gfixler: I don’t happend to be one, but oh well.
20:57:11 <geekosaur> LYAH has its place. It's good for learning how to read Haskell code. It's not so good for learning how to write it
20:57:26 <julianleviston> geekosaur: well put!
20:57:27 <gfixler> geekosaur: I liked it to get a sense of the kinds of things Haskell could do
20:57:27 <geekosaur> btu if you can supplement it with exercises from somewhere, you can get past that
20:57:32 <gfixler> it got me thinking about a lot
20:57:48 <lindenk> er, im not sure. do you guys recommend something else?
20:57:53 <Hijiri> @where learnhaskell
20:57:53 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:57:57 <gfixler> but then I found this place, and couldn't answer even simple questions
20:58:06 <Hijiri> @where haskellbook
20:58:06 <lambdabot> I know nothing about haskellbook.
20:58:10 <Hijiri> oh
20:58:18 <julianleviston> lindenk: basically, fmap is “map” for ANY type of container, not just lists.
20:58:24 <julianleviston> Hijiri: haskellbook.com
20:58:30 <gfixler> julianleviston: not just containers, though!
20:58:40 <kadoban> But that assumes that exercises can be disconnected from the content and still be useful. In practice they're going to exercise things you haven't learned, not exercise things you have, etc.
20:58:43 <julianleviston> gfixler: please.
20:58:46 <Hijiri> lindenk: yeah, what julianleviston said, it's in development but you would have to pay to read it
20:58:49 <julianleviston> Hijiri: I think it’s mentioned on the learnhaskell link
20:58:49 <gfixler> julianleviston: though I can see it, if I stretch my mind a bit
20:59:07 <julianleviston> gfixler: let’s not muddy the water too much here :) a function can be viewed as a container.
20:59:09 <Hijiri> julianleviston: I don't think it is
20:59:14 <gfixler> julianleviston: yep
20:59:22 <julianleviston> Hijiri: ah, bitemyapp said he might put it on. Ok.
20:59:37 <gfixler> it's just haskellbook.com
21:00:17 <gfixler> ah, time for tonight's www.adventofcode.com
21:00:25 <julianleviston> I wonder...
21:00:44 <julianleviston> you can fmap over any construction, is there a way to replace the construction? a kind of unfmap so to speak?
21:01:01 <lindenk> (btw I'm actually doing yesterday's advent and using it as an excuse to learn more haskell)
21:01:20 <MarcelineVQ> julianleviston: like traverse?
21:01:35 <julianleviston> MarcelineVQ: is that what traverse does?
21:01:48 <julianleviston> MarcelineVQ: I didn’t realise… I thought it was something else.
21:02:01 <julianleviston> MarcelineVQ: maybe I need to brush up on my traverse!
21:05:09 <julianleviston> MarcelineVQ: no, that’s not what I meant, really… at least, I don’t think so.
21:06:02 <julianleviston> MarcelineVQ: what I mean is, say you have two structures with the same “shape” (in terms of their Algebra)… fmap requires only that they have a structure… but this other function would require that their contents were in an identical shape, such that you could then replace one outer structure with the other...
21:06:18 <julianleviston> MarcelineVQ: it’s just a theoretical idea.
21:06:30 <julianleviston> MarcelineVQ: but I *have* had to write such functions several times before.
21:07:01 <MarcelineVQ> are you describing natural transformation?
21:08:15 <julianleviston> MarcelineVQ: I’ve never heard of it. I’ll look it up.
21:08:29 <julianleviston> reading now https://wiki.haskell.org/Category_theory/Natural_transformation
21:09:06 <julianleviston> Yes, I suppose I am… 
21:16:31 <jle`> julianleviston: do you mean like an (f a -> f b) -> a -> b ?
21:17:44 <julianleviston> jle`: I mean as fmap is to fmap f (Just x) = Just (f x) would be unfmap S (Just x) = S x
21:18:10 <julianleviston> where S is some data type with identical structure
21:18:34 <KaneTW> sounds like you want a natural transformation to Identity
21:18:43 <julianleviston> sure
21:18:47 <julianleviston> the Yoneda Lemma?!
21:18:56 <julianleviston> http://blog.sigfpe.com/2006/11/yoneda-lemma.html
21:19:19 <julianleviston> but note that I don’t need this or want it. I’m just curious about it because I haven’t seen it in Haskell and I *have* wanted such a thing in the past.
21:19:21 <jle`> it also sounds a lot like a catamorphism
21:19:35 <jle`> a catamorphism would be a way to "replace" all constructors with something else
21:19:45 <julianleviston> sure
21:19:52 <julianleviston> but I’m talking in general, not specifically.
21:20:05 <jle`> for example, a catamorphism on list would be, give me an (a -> b -> b) to replace all the (:), and give me a b to replace all the []
21:20:16 <jle`> so you go in and replace all the (:)'s with your new constructor
21:20:20 <jle`> and all the []'s with another new constructor
21:20:24 <jle`> and that's a catamorphism
21:20:45 <julianleviston> but you’d still have to write the “combining function” yourself, right?
21:20:49 <jle`> so a catamorphism on Maybe would be, "give me something to replace all the Just's with, and give me something to replace all the Nothing's with"
21:21:04 <jle`> and it goes into a Maybe a and replaces all the Just's with your thing, and all the Nothing's with the other thing
21:21:24 <jle`> the catamorphism for Maybe is actually in Prelude
21:21:32 <julianleviston> yeah I know
21:21:37 <julianleviston> I’m talking generally.
21:21:41 <julianleviston> though.
21:21:47 <julianleviston> just like fmap is map generally.
21:21:51 <jle`> i think catamorphism would be a general name for this sort of idea?  'replace all the constructors'?
21:21:57 <jle`> oh, do you mean, a typeclass?
21:22:08 <julianleviston> jle`: yes, but haskell only has fold* as a catamorphism, doesn’t it?
21:22:24 <jle`> you can write a catamorphism for a bunch of data types
21:22:24 <julianleviston> jle`: which is missing the thing that does the work in this case.
21:22:52 <jle`> you're asking about something "replace the constructors", so to speak, and the idea of a catamorphism is exactly this
21:23:06 <julianleviston> jle`: I’m not disagreeing with you
21:23:18 <jle`> `maybe d f` will replace all of the Just's with `f`, and all the Nothing's with `d`
21:23:23 <julianleviston> jle`: but the idea of catamorphism isn’t generally available in haskell in a function like fmap is available as a morphism.
21:23:38 <jle`> do you mean, there's no polymorphic function that's a part of a typeclass?
21:23:48 <julianleviston> I suppose that’s one way of putting it, yeah!
21:24:11 <julianleviston> “Functor” is morphism ?
21:24:14 <julianleviston> I’m unsure.
21:24:33 <jle`> are you referring to the fact that `fmap` is overloaded and polymorphic over all instances of the Functor typeclass, so you can refer to the "mapping" function by the same four-letter identifier?
21:24:37 <jle`> (for every instance)
21:25:02 <julianleviston> um… yes.
21:25:04 <julianleviston> I think so
21:25:46 <julianleviston> I’m also referring to the fact that we can’t pattern-match on inner-structure, only outer.
21:25:48 <jle`> so you're looking for a polymorphic function that acts as a catamorphism for a bunch of different types that are instances of the typeclass
21:26:00 <julianleviston> jle`: I suppose so.
21:26:12 <julianleviston> jle`: assuming I understand you correctly.
21:26:34 <julianleviston> It’s not really a problem at all.
21:26:50 <julianleviston> Coz I can just write my own ad-hoc function in each (rare) case I find that this is required. 
21:26:55 <jle`> there's this -- http://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html
21:27:06 <jle`> it's actually not a rare case actually, catamorphisms appear everywhere in every-day code :)
21:27:28 <jle`> most people are happy with it each one having its own name.  but the Foldable typeclass from recursion-scheme lets you call them all by the same name
21:27:32 <julianleviston> jle`: the case I’m talking about is rarer than function application. 
21:28:02 <julianleviston> jle`: Usually the problem is with types *i’ve* made, though… 
21:29:23 <julianleviston> is an anamorphism an unfold? Am I rememebering that correctly?
21:30:01 <Cale> yes
21:31:40 <julianleviston> actually I think I could write this generalisation pretty easily if I needed it by just using foldable’s fold. It’d typecheck because the types would match. Probably way too much busywork for the payoff though.
21:32:16 <julianleviston> hylos are so weird. :)
21:34:15 <julianleviston> I just fell off my chair because I read “Zygohistomorphic prepromorphisms”
21:35:35 <julianleviston> is scan a paramorphism?
21:36:34 <julianleviston> ok seems to be. 
21:36:39 <julianleviston> Alright I’m good now I think :) haha
21:37:12 <julianleviston> jle`: thanks for Data.Functor.Foldable - very cool!
21:38:14 <jle`> np!
22:59:57 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
22:59:57 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
22:59:57 --- names: list (clog Helvekta centrinia DavidDudson sbyl takuan khumba fengshaun justin_smith nyazdani rvktsf infinity0 shangxia1 Swizec darkbolt skeuomor1 doomlord tristero saulzar HoloIRCUser3 hololeap utkarsh5 funfunctor Bez_ nshepperd Ephemerality neoncontrails darkf yfeldblum zipper jack_rabbit proteusguy_ xaimus martin-t chatsiri_ Goplat emanuelz djcoin goodboy vlatkoB otto_s_ koinkers obadz eazar001 Wamanuz junmin gfixler Grey_H Zekka wallyduchamp tomku capisce)
22:59:57 --- names: list (triliyn tripped horlicks_ hucksy_ dfranke tabemann Sucks xahry_ Sorella phileas Catalectic nhandler1 bjz crazydiamond PatrickRobotham dsantiago lritter talzs cyphase_ zugzwanged theorbtwo ryan_vw_ predator317 predator117 jstimpfle rotaerk Nahra``` thimoteus johnw nakal Shockk SenpaiSilver amiller zomg Excureo TheSpectre castlelore plutoniix ttuegel dented42 hamishmack brotknust FelixNemis dan_f shirt vektorweg1 firstdayonthejob qnikst aloiscochard)
22:59:57 --- names: list (Coldblackice Black-Wolf canta codesoup maerwald cody` nomicflux l3dx abra0 fmauro djapo kadoban vmesons pavonia Church_ cleamoon donwilliam Jesin zariuq Wizek steamboat yamad MoALTz ishikawa_rei heurist dtulig SgtStroopwafel please_help Kruppe WindAndRain lodin- godel zariel badon lambda-11235 gaustin cpup djellemah NeverDie Soft akegalj_ caumeslasal greeny whaletechno pompolic grouzen svp wraithm Tehnix thunderrd diphtherial echo-area a3Dman Majiir Lokathor)
22:59:57 --- names: list (kolko Intensity boj rul perspectival MindlessDrone Sornaensis DanielDiaz MelodyKH3 _ashbreeze_ mpereira techiewickie jedws dcoutts vqrs benmos bernalex Ralith SoupEvil pranz erikd andjjj23 araujo lotharn Freundlich hackagebot ashleyis hexagoxel lspitzner exferenceBot yrdz`` KeelOfSteel dqd byorgey CARAM__ cleichner sephiap zpconn__________ harmchop vikaton Heero dseitz hbar Xe Moto-chan _Vi MrWoohoo2 MrWoohoo bgamari martingale LnL fayong Uakh Jinxit juhp)
22:59:57 --- names: list (xinming cmccann dmwit ij kipras ph88^ stiell Baughn dgpratt kjanosz noexcept condy alunduil AntiSpamMeta tongcx abrar Lord_of_Life Ewout MarcelineVQ icbm pgiarrusso buMPnet captain-adequate __main__ zv mountaingoat wookiehangover marmalod1 pikhq Tene Enigmagic ByronJohnson emmanuel_erc niteria alarmmm Maerten KennosiS Polarina amiri DrCode pfoetchen sz0 jokleinn chattered justanotheruser WizJin graycoder besenwesen adlan delYsid`` Nik05 josephle Kasavage)
22:59:57 --- names: list (moei Fuco nikola slick aaronm04 benzrf jgertm tnks sa1 fiddlerwoaroof JohnMaximilian zaquest wedens Sgeo luis Atlanis nurupo seliopou mbrcknl eddsteel superfatkappa lancetw chriswk wyvern sbauman n1ftyn8_ fuziontech ikke milessabin catsup icen yogsototh itsmonktastic solidus-river spion zxtx iross mjrosenb codebje_ shwouchk_ fugyk hooptw CoconutCrab PotatoGim FreeFull flounders hvr tg Kaini Chobbes rossberg stasku_ rikkus spicydonuts tv nrk- aristid Scorchin)
22:59:57 --- names: list (shans_ akahn folsen tharper verement rdl Ravana callumacrae THE_BOULDER magthe betawaffle leino cynick chaptastic derekbrown Ashy mudfog koz_ phaskell neurogeek monochrom keix statusbot PlasmaStar sleblanc kyren denimuser posco kseo_ jmcarthur m00nlight Pamelloes orb gws bgyss doppioslash emmanueloga tazjin zph nkpart trig-ger_ Heart__ sublimate lambdahands bergey` teeteewhy lostman Eagle_Erwin zopsi worch fboyer Money_Pro padre_angolano dmoon1221 bigs zoku)
22:59:57 --- names: list (vikram_____ bitonic nbouscal kjnilsson incomprehensibly si14 arnihermann thorsten` etrepum TimWolla max-m sword_smith isocliff gienah andyo kungp rntz avdi sykora sw1nn sbauer322 phaazon ahammel guampa kvieta nont_ tobiasBora Velpoman OverCoder pi__ hydraz extropic-engine MasseR Flonk the193rd oyvinrob OutlawStar opios rcsgns_ Didac orzo Matajon amatecha Xack armyriad friden jle` HylianSavior regicidal eyck platz ggVGc Khruu augur bob_twinkles venk Sindriava)
22:59:57 --- names: list (tpsinnem CosmicRay mechairoi saurik troydm zxq9 mrowe_away Nash_ Cale demize code_crimes tomus dlundy M-Quora M-radix M-mistake M-david M-Illandan M-davidar nemesit|znc bdamos phadej tkr dexterph LordDeath hive-mind myfreeweb Philonous cswords spaceships descender zso agumonkey Nickeeh Plastefuchs Jaxan andreas303 aandy jnoah [swift] c-rog itscaleb ReinH hiredman spindas evi_ cursork m1dnight_ kaishin Rembane dibblego SegFaultAX joehillen gridaphobe dilinger)
22:59:57 --- names: list (dreamdust drewdavis davidthomas mikeplus64 acfoltzer sm Jellydog technomad iliastsi tridactyla FireFly hc solution ww tortal Azel trix boxfire parsnip rieper zhulikas kidnapped_robot Reiser ethercrow ahungry JamesJRH yminsky NemesisD OliPicard linduxed etabot mitchty phy1729 bam365 glguy Sonderblade karls teclo- hobo StoneToad imalsogreg_ johtso_ luzie DenSchub rstone puzza007 amingoia TDJACR ChucklesTheBeard vodik ibid SaidinWoT Khisanth felixsch joeyh)
22:59:57 --- names: list (newsham Fylwind sevcsik dxld jcurbo martintrojer luluapple fyolnish tristanp nesqi finninde cojy edwardk gnusosa mietek cbaines flux razi1 runeks caasih felixn robtaylor frelux Reyu jgornick Ov3rload ivan\ arkeet hyPiRion AlainODea pchiusano defanor RaceCondition Internet13 zymurgy magicman magbo drbean lukky513 tusj geekosaur GGMethos dpn` fredcy Vbitz darkstalker ido mbwe jcreekmore chishiki torpig pmade irishsultan joshc simon mankyKitty jvarg rjeli)
22:59:57 --- names: list (lacrosse [BNC]Shoggoth gpampara yvm dolio psmolen Cetusx Ferdirand joneshf-laptop xmad Tritlo lokulin mtesseract przembot julmae ephemeron KaneTW wunki themasterchef Biohazard ut_ chokboy mno2 ploopkazoo gsingh93 bogdanteleaga syntacticNaCl davesilva aatxe Tesseraction Factionwars haBuu_ phuu hiratara Oxyd burp andreypopp shennyg bydo dlandau Boreeas carc Guest24695 obiwahn S11001001 mbrock` xnyhps killerpty Ulrar sea-gull huonw bjornars1 ocharles__ jonrh)
22:59:57 --- names: list (davean geppettodivacin visi0n klarrt rom1504 carter_cloud tobiasgw dkua pootler_ sclv lambdabot timloh dstockwell kyagrd rslima_ jroesch _klm rbocquet jmct haasn valdyn KorriX Liskni_si fnordbert bartavelle spwhitt irclogger_com divVerent otterdam martinbjeldbak fall_ R0b0t1 Erebe jang kmicu monty metaf5 deni zimp1 krgn coius noddy2OOO Guest41262 tuv japesinator brassel guios Mandus Forkk jasonmay aleator ben chu l3france ppnkk ParahSailin amharc_ arw)
22:59:57 --- names: list (perrier___ wto jstolare1 bd_ malglim RazorX- Xorlev leather Pucilowski_ staffehn_ esssing marko______ utdemir`` mw koomi ernst spill1 spacebug M-ou-se cdidd introom ps-auxw lb5tr AustinMatherne drdo greymalkin albel727 mceier Deadhandd dixie mniip crough tom39291 sokoll joedevivo Athas seanparsons bencryption jonathanj__ kier whoops arcanine dejanr alpounet geal selckin tumdedum gargawel sunnymilk keko-2 kloeri dmiles_afk scared EvanR zyoung ahihi lindenk)
22:59:57 --- names: list (Boney cscorley vin-ivar sleepynate Hijiri aaron7 jvd dredozubov yamadapc idupree thoughtpolice mokus tomjaguarpaw timemage prkc ironChicken bind k1io _flow_ cbm80 Natch Sigyn joco42 koray skrio Tinchos gbarboza serutsubi osfameron ChongLi u-ou susmus cgfbee eyenx pwned yoho unknownln kav arahael abh dutchie tswett cj_howe anunakki killtheliterate alanz Xandaros jinblack bsermons tdammers mach siloxid kaictl ELLIOTTCABLE IanMalcolm glowcoil_ pdxleif tommd)
22:59:57 --- names: list (aphprentice oneb robogoat alang tolt brisbin Fluent_ benonsoftware quicksilver mephx tippenein tzaeru alem0lars skarn unsymbol fedorafan tjbp dsop sekrit saep inr gseitz RayNbow`TU kaol Diabolik Blkt zeroskillor cfloare mirsal Twey ahf LeaChim tekacs kqr myme statusfailed barrucadu Ornedan cogrendel lexi-lambda codehero relrod mpickering TheCrafter sewilton reem {AS} alexlord nrw jorendorff kipd RevJohnnyHealey jfokkan__ tjpeden alphonse23_ jessicah`)
22:59:57 --- names: list (wizonesolutions tarcwynne_ kirjs___________ mvr_ petems cstrahan zrl mindos_cloud____ brt1 ggherdov lohkey orcus TabAtkins jlyndon Raynos bkolera xxpor DoYouKnow nisstyre edofic jtobin chris2 sivoais biscarch ChristianS martinhath stephe shelling__ roo grandy att arianvp moop jbalint quaestor1 stux|RC-only notdan honkfestival larion acro pieter Brando753 so Speed @ChanServ Eliel Guest30177 mads- julienXX eagleflo lulf thorkilnaur thomas jrib Clint glckr)
22:59:57 --- names: list (Watcher7 mathu sdboyer moredhel comboy micro_ nitrix shahn fall` agjohnst_ DylanJ PHO alynn levi iDavid PinealGlandOptic low-profile Dodek ch3mical isomorph1smes soija ski cow-orker joeytwiddle supki tsani pyrtsa richi235 mrd jaaket surtn- kriztw petercommand pfeyz_ poucet Lemmih absence ft Belgarion0 fryguybob rphillips zyla_prati ephess_ fold3 earthy dhrosa_ __rlp Iceland_jack dschoepe lassulus_ zudov bjobjo Phillemann lokydor_ nille tokik brolin_empey)
22:59:57 --- names: list (fionnan_ hanDerPeder hsyl20 thebnq lstrano_ numberten exio4 rjbs iElectric kala dino-_ pontus DDR nathanic ArcticMonkey Voldenet obcode_ Ezku_ xou_ mak` Purry c_wraith cryon e4x_ elgot Bigcheese Zemyla gdsx gratimax Chousuke TheAuGingembre schoppenhauer jre2 andrewsw stomp vodkaInferno Jaak Kavec `0660 Cerise lf94 jamiis ziman tismith rdema Fubar^ Vq jotrk DustyDingo anachrome liyang Unhammer cmn rubber sdx23 epta sujeet agrif Maxdamantus sarlalian jokester)
22:59:57 --- names: list (happy0 anders^^ jlewis cnr rofer a4j ngrud majjoha_ kaste tlevine zenzike xplat plhk_ rrrrob Razz noctux Niamkik Ptival opqdonut knyppeldynan gcollins Jonno_FTW ion aweinstock benley yeltzooo tych0 fmapE jrslepak tedkornish Hafydd _6a68 bolmar sgronblo ninegrid kosmikus sternenseemann xiaolin vishesh certainty Ring0` siddhu fractalcat Profpatsch wayne Guest50975 tinydata bcoppens JPohlmann lenstr bitemyapp cYmen solarus brtk RlyDontKnow flori KitC lispy)
22:59:57 --- names: list (Solarion SwashBuckla saiam cjay mjo APic lvh ozzloy Drezil amontez mmaruseacph2 SHODAN brennie froztbyte tgeeky cjh` Ke WarzoneCommand cods AWhetter stvc eikke RouxTheDay Bane^ ThePhoeron abbe tessier Tehnix` d-snp owa luigibozzo nyuszika7h Walther Hesfin cin_ reynir fergusnoble DANtheBEASTman chrzyki ruurd dario` lpaste ircbrowse usr impure_hate raid prefork_ jameseb SLi solatis Taneb Elsi Tiktalik codebam LoganG integral bananagram gothos borkdude)
22:59:57 --- names: list (SuperTux88 takeey squisher Saimeidae woffy gabiruh YP-Cloud wtw ninzine mero 5EXAAAWDW shapr Komplanar Kneiva simony vpm hrnz sbrg Dykam buoto anders0 amx z16 grol Lutin` lol_ heath Adios dh nuuit hpc BillyIII jlouis davl Starfire CindyLinz Laney ongy Deewiant majoh __jim__` michaelpj_ capybara Myrl-saki shachaf cheater rossimo_ heyj_ca Cathy apo_ aparent _ari dustinm chirpsalot asm89 cyberlard td123 fikusz chaker koala_man ortmage hodapp PierreM bshelden)
22:59:57 --- names: list (mendez noplamodo pikajude Adeon lieven jaj lauren taksuyu TallerGhostWalt trampi bsmt Moyst anoe gniourf meretrix seagreen zyla stass ackthet BrianHV arkarth jojotus pleiosaur ndeine Yaiyan mt SolarAquarion tailgate xaotuk hongminhee Madars luigy GaveUp cross oberstein narendraj9 Frankablu yusukesuzuki FledRebel kwantam jgrocho carmethene mrshoe DigitalKiwi carter keemyb RageD rootnode dan64 pm5 swhalen nekomune s_e kriwil rowanblush lhynes dunj3 mnoonan)
22:59:57 --- names: list (andreass sleezd Simson-san mikeizbicki wjm ljhms dju eL_Bart0 Phyx- themagician MK_FG urdh paf31 niklasb mimi_vx stelleg Xnuk sku1d jzl naudiz cocreature hausdorff Bashmetim __name__ zemm waamaral ]OLI[ avn dbeacham Klumben xacktm Guest31976 eamelink theDon octo_ vikraman lyddonb wrengr_away tmssgn kristjansson cjwelborn wolf_mozart brixen darthdeus igniting averell Al-Vaca- alevy frontendloader Cr8 ixian Geekingfrog sajith jackhill srhb d3lxa ricardo82 Sagi)
22:59:57 --- names: list (hegge tomaw monokqr marienz tromp__ diginet lachenmayer solirc XMunkki Shandy o`connor timothyh Willis w5isp 32NAAD58U atomi ninedotnine sellout shadowdao Akii asjo wamaral fingerzam1 mgaare sivs grada da-x shutdown_-h_now tumdum avocado arcetera nwf Jello_Raptor wting Desoxy tero- Draggor sLite Dtgr liste navilan- yarou indiffernet Nimatek qz M2tias lattenwald tomboy64 peddie dicioccio niluje Gothmog_ icedev FUZxxl nopf DistantStar deavidsedice uwap)
22:59:57 --- names: list ([edwtjo] Saizan cic dzack klugez optocoup1er lamilami ThreeOfEight Ankhers hemite lyxia Phlogistique monsieurp otulp niko luite reactormonk int-e hpd yorick scpike_ jrp6 Guest3764 henrytill bergmark pharaun topi_ jix lpsmith s4msung_ karshan zerokarmaleft jayne nathyong Axman6 funrep ElderFain taruti_ qguv psacrifice minad Tazca fabianvf yaknyasn pkogan ajmccluskey zmanian_ dogonthehorizon)
23:06:19 * hackagebot logplex-parse 0.1.0.1 - Parse Heroku application/logplex documents  https://hackage.haskell.org/package/logplex-parse-0.1.0.1 (keith_duncan)
