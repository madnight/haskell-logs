00:00:07 <lol__> Are the parens around the + necessary?
00:00:11 <zoku> yes
00:00:16 <zoku> otherwise it's an infix function
00:00:31 <lol__> > map (1 +) [1...10]
00:00:35 <lambdabot>      Could not deduce (Num (Over p f c0 c0 a b))
00:00:35 <lambdabot>      from the context (Num (Over p f s t a b),
00:00:35 <lambdabot>                        Num (Over p f c c a b),
00:00:46 <liste> lol__ that's called a section
00:00:51 <liste> the (1+) part
00:01:02 <lol__> What do you mean?
00:01:02 <quchen_> (...) is something other than the .. in between numbers in list notation.
00:01:11 <liste> lol use two dots
00:01:22 <liste> > map (1 +) [1..10]
00:01:24 <lol__> map (1 +) [1..10]
00:01:24 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
00:01:38 <lol__> Oh.
00:01:48 <zoku> > print ":QUIT"
00:01:49 <lambdabot>  <IO ()>
00:01:57 <zoku> > print ":QUIT\r\n"
00:01:59 <lambdabot>  <IO ()>
00:02:06 <zoku> > ":QUIT\r\n"
00:02:08 <lambdabot>  ":QUIT\r\n"
00:03:36 <lol__> Well, thanks for the short intro!
00:03:39 <lol__> Heading off to bed
00:03:45 <liste> good night lol__ (:
00:05:25 <pavonia> > text ":QUIT\r\n"
00:05:28 <lambdabot>  :QUIT
00:09:29 <frerich> zoku: You can also play with lambdabot in a /query such that the 1450+ people in this channel don't have to watch you :-}
00:13:06 * hackagebot git-fmt 0.3.1.0 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.1.0 (hjwylde)
00:13:08 * hackagebot conduit 1.2.6 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.6 (MichaelSnoyman)
00:13:10 * hackagebot hackage-mirror 0.1.1.1 - Simple mirroring utility for Hackage  https://hackage.haskell.org/package/hackage-mirror-0.1.1.1 (MichaelSnoyman)
00:13:12 * hackagebot protocol-buffers 2.1.8 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.8 (k_bx)
00:13:14 * hackagebot protocol-buffers-descriptor 2.1.8 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.8 (k_bx)
00:18:16 * hackagebot hprotoc 2.1.8 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.8 (k_bx)
00:18:18 * hackagebot publicsuffix 0.20151129 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20151129 (wereHamster)
00:18:20 * hackagebot OpenGLRaw 2.6.1.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-2.6.1.0 (SvenPanne)
00:18:22 * hackagebot yaml 0.8.15.2 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.15.2 (MichaelSnoyman)
00:18:24 * hackagebot resourcet 1.1.7 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.7 (MichaelSnoyman)
00:23:26 * hackagebot persistent 2.2.3 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.2.3 (GregWeber)
00:23:28 * hackagebot c2hs 0.27.1 - C->Haskell FFI tool that gives some cross-language type safety  https://hackage.haskell.org/package/c2hs-0.27.1 (IanRoss)
00:23:30 * hackagebot JuicyPixels 3.2.6.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.6.3 (VincentBerthoux)
00:23:32 * hackagebot OpenGL 2.13.1.1 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-2.13.1.1 (SvenPanne)
00:23:35 * hackagebot morte 1.4.0 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.4.0 (GabrielGonzalez)
00:28:37 * hackagebot relational-query 0.6.4.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.6.4.0 (KeiHibino)
00:28:39 * hackagebot yesod-auth 1.4.11 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.11 (GregWeber)
00:28:41 * hackagebot foscam-directory 0.0.5 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.5 (TonyMorris)
00:28:43 * hackagebot streaming-wai 0.1.0 - Streaming Wai utilities  https://hackage.haskell.org/package/streaming-wai-0.1.0 (WilliamCasarin)
00:28:45 * hackagebot foscam-directory 0.0.6 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.6 (TonyMorris)
00:33:47 * hackagebot opencog-atomspace 0.1.0.0 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.0 (romanT)
00:33:49 * hackagebot stable-marriage 0.1.0.0 - algorithms around stable marriage  https://hackage.haskell.org/package/stable-marriage-0.1.0.0 (KatsutoshiItoh)
00:33:51 * hackagebot success 0.2.1 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.1 (NikitaVolkov)
00:33:53 * hackagebot streaming-wai 0.1.1 - Streaming Wai utilities  https://hackage.haskell.org/package/streaming-wai-0.1.1 (WilliamCasarin)
00:33:55 * hackagebot success 0.2.1.1 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.1.1 (NikitaVolkov)
00:34:47 <frerich> 'The types and functions are trivial and self-descriptive, hence this sentence is the sole documentation you get on them.' :-) (but it's true)
00:38:36 <jle`> but it's not true, though :'(
00:38:57 * hackagebot SWMMoutGetMB 0.1.1.0 - A parser for SWMM 5 binary .OUT files  https://hackage.haskell.org/package/SWMMoutGetMB-0.1.1.0 (siddhanathan)
00:38:59 * hackagebot cereal-conduit 0.7.2.4 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  https://hackage.haskell.org/package/cereal-conduit-0.7.2.4 (MichaelSnoyman)
00:39:01 * hackagebot conduit-extra 1.1.9.2 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.9.2 (MichaelSnoyman)
00:39:03 * hackagebot SWMMoutGetMB 0.1.1.1 - A parser for SWMM 5 binary .OUT files  https://hackage.haskell.org/package/SWMMoutGetMB-0.1.1.1 (siddhanathan)
00:39:05 * hackagebot binary-parser 0.5.0.1 - A highly-efficient but limited parser API specialised for bytestrings  https://hackage.haskell.org/package/binary-parser-0.5.0.1 (NikitaVolkov)
00:44:07 * hackagebot HTTP 4000.2.22 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.2.22 (GaneshSittampalam)
00:44:09 * hackagebot friday-scale-dct 1.0.0.0 - Scale Friday images with DCT  https://hackage.haskell.org/package/friday-scale-dct-1.0.0.0 (AlexMason)
00:44:11 * hackagebot friday-scale-dct 1.0.0.1 - Scale Friday images with DCT  https://hackage.haskell.org/package/friday-scale-dct-1.0.0.1 (AlexMason)
00:44:13 * hackagebot alex 3.1.6 - Alex is a tool for generating lexical analysers in Haskell  https://hackage.haskell.org/package/alex-3.1.6 (SimonMarlow)
00:44:15 * hackagebot cereal-conduit 0.7.2.5 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  https://hackage.haskell.org/package/cereal-conduit-0.7.2.5 (MichaelSnoyman)
00:49:17 * hackagebot dixi 0.6.0.2 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.0.2 (LiamOConnorDavis)
00:49:19 * hackagebot tripLL 0.1.0.0 - A very simple triple store  https://hackage.haskell.org/package/tripLL-0.1.0.0 (apho)
00:49:21 * hackagebot names-th 0.2.0.1 - Manipulate name strings for TH  https://hackage.haskell.org/package/names-th-0.2.0.1 (KeiHibino)
00:49:23 * hackagebot cayley-dickson 0.3.0.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.3.0.0 (lmj)
00:49:25 * hackagebot packman 0.3.0 - Serialization library for GHC  https://hackage.haskell.org/package/packman-0.3.0 (JostBerthold)
00:54:27 * hackagebot syntactic 3.1 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.1 (EmilAxelsson)
00:54:29 * hackagebot elm-init 1.0.1.1 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.1.1 (justus)
00:54:31 * hackagebot cayley-dickson 0.3.1.0 - Complex numbers, quaternions, octonions, sedenions, etc.  https://hackage.haskell.org/package/cayley-dickson-0.3.1.0 (lmj)
00:54:33 * hackagebot userid 0.1.2.2 - A library which provides the UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.2 (JeremyShaw)
00:54:35 * hackagebot clckwrks 0.23.12 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.12 (JeremyShaw)
00:59:37 * hackagebot cuda 0.7.0.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.7.0.0 (TrevorMcDonell)
00:59:39 * hackagebot list-zip-def 0.1.0.0 - Provides zips where the combining doesn't stop premature, but instead uses default elements.  https://hackage.haskell.org/package/list-zip-def-0.1.0.0 (muesli4)
00:59:41 * hackagebot bbi 0.1.0 - Tools for reading Big Binary Indexed files, e.g., bigBed, bigWig  https://hackage.haskell.org/package/bbi-0.1.0 (kaizhang)
00:59:43 * hackagebot bioinformatics-toolkit 0.1.0 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.1.0 (kaizhang)
00:59:45 * hackagebot wai-middleware-verbs 0.1.0 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.1.0 (athanclark)
01:04:47 * hackagebot wai-middleware-content-type 0.1.0 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.1.0 (athanclark)
01:04:49 * hackagebot vault 0.3.0.5 - a persistent store for values of arbitrary types  https://hackage.haskell.org/package/vault-0.3.0.5 (HeinrichApfelmus)
01:04:51 * hackagebot postgresql-binary 0.7.4.1 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.4.1 (NikitaVolkov)
01:04:53 * hackagebot Cabal 1.22.5.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.22.5.0 (ryant)
01:04:55 * hackagebot bytes 0.15.1 - Sharing code for serialization between binary and cereal  https://hackage.haskell.org/package/bytes-0.15.1 (EdwardKmett)
01:09:57 * hackagebot log-domain 0.10.3.1 - Log-domain arithmetic  https://hackage.haskell.org/package/log-domain-0.10.3.1 (EdwardKmett)
01:09:59 * hackagebot wai-transformers 0.0.4 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.4 (athanclark)
01:10:01 * hackagebot approximate 0.2.2.3 - Approximate discrete values and numbers  https://hackage.haskell.org/package/approximate-0.2.2.3 (EdwardKmett)
01:10:03 * hackagebot hyperloglog 0.4.0.4 - An approximate streaming (constant space) unique object counter  https://hackage.haskell.org/package/hyperloglog-0.4.0.4 (EdwardKmett)
01:10:05 * hackagebot happstack-authenticate 2.3.1 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.1 (JeremyShaw)
01:11:11 <wedens> where is the balance between fine grained and coarse grained error types? I can have different error type for each function that will contain only errors this function can produce. or I can have error type that contains errors for all functions in application. 
01:15:07 * hackagebot happstack-hsp 7.3.7 - Support for using HSP templates in Happstack  https://hackage.haskell.org/package/happstack-hsp-7.3.7 (JeremyShaw)
01:15:09 * hackagebot happstack-foundation 0.5.9 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  https://hackage.haskell.org/package/happstack-foundation-0.5.9 (JeremyShaw)
01:15:11 * hackagebot happstack-jmacro 7.0.11 - Support for using JMacro with Happstack  https://hackage.haskell.org/package/happstack-jmacro-7.0.11 (JeremyShaw)
01:15:13 * hackagebot pinboard 0.9.2 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.2 (jonschoning)
01:15:15 * hackagebot list-zip-def 0.1.0.1 - Provides zips where the combining doesn't stop premature, but instead uses default values.  https://hackage.haskell.org/package/list-zip-def-0.1.0.1 (muesli4)
01:20:17 * hackagebot happstack-clientsession 7.3.1 - client-side session data  https://hackage.haskell.org/package/happstack-clientsession-7.3.1 (JeremyShaw)
01:20:19 * hackagebot clckwrks-cli 0.2.16 - a command-line interface for adminstrating some aspects of clckwrks  https://hackage.haskell.org/package/clckwrks-cli-0.2.16 (JeremyShaw)
01:20:21 * hackagebot wai-middleware-content-type 0.1.0.1 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.1.0.1 (athanclark)
01:20:23 * hackagebot webapp 0.0.1 - Haskell web scaffolding using Scotty, WAI, and Warp  https://hackage.haskell.org/package/webapp-0.0.1 (natesymer)
01:20:25 * hackagebot webapp 0.0.2 - Haskell web scaffolding using Scotty, WAI, and Warp  https://hackage.haskell.org/package/webapp-0.0.2 (natesymer)
01:25:27 * hackagebot haskell-tor 0.1.2 - A Haskell Tor Node  https://hackage.haskell.org/package/haskell-tor-0.1.2 (AdamWick)
01:25:29 * hackagebot opencog-atomspace 0.1.0.1 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.1 (romanT)
01:25:31 * hackagebot dejafu 0.2.0.0 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.2.0.0 (barrucadu)
01:25:33 * hackagebot hunit-dejafu 0.2.0.0 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.2.0.0 (barrucadu)
01:25:35 * hackagebot tasty-dejafu 0.2.0.0 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.2.0.0 (barrucadu)
01:26:33 <jle`> wedens: i'm not sure if there are any real guidelines
01:30:37 * hackagebot async-dejafu 0.1.0.0 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.0.0 (barrucadu)
01:30:39 * hackagebot pgdl 8.4 - simply download a video (or a file) from a webpage and xdg-open it.  https://hackage.haskell.org/package/pgdl-8.4 (sifmelcara)
01:30:41 * hackagebot snap-language 0.1.0.0 - Language handling for Snap  https://hackage.haskell.org/package/snap-language-0.1.0.0 (petterb)
01:30:43 * hackagebot sdr 0.1.0.5 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.5 (adamwalker)
01:30:45 * hackagebot swagger2 0.4.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-0.4.1 (NickolayKudasov)
01:31:29 <wedens> jle`: I don't want "guidelines" :) I'd like to hear about experience of dealing with functions that may generate (sometimes) intersecting set of errors
01:35:47 * hackagebot despair 0.0.6 - Despair  https://hackage.haskell.org/package/despair-0.0.6 (Heather)
01:45:11 <pharaun> oh wow seems like midnight-1am is the ideal time for uploading new packages :D
01:48:15 <jle`> i don't even know what happened :o
02:56:55 <yogsototh> Hi, I have a strange problem writing a Wai middleware. Priting some value block my IO process. Does someone could give me some pointer on how to debug such runtime problem?
02:57:34 <liste> @paste -- yogsototh paste here what you've got and the errors you see
02:57:34 <lambdabot> Haskell pastebin: http://lpaste.net/
03:00:05 <yogsototh> http://lpaste.net/146270
03:00:48 <yogsototh> When I send a post request with the print and the value isn't cached it blocks
03:01:04 <yogsototh> If I remove the print action my curl client receive the body
03:02:08 <liste> where's keyFromReq ?
03:02:31 <yogsototh> I'll paste everything, sorry
03:03:14 <yogsototh> I've updated the code http://lpaste.net/146270
03:08:18 * hackagebot persistable-record 0.2.0.0 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.2.0.0 (KeiHibino)
03:09:29 <frerich> yogsototh: I'd try using strictRequestBody instead of lazyRequestBody. Lazy I/O is notoriously tricky.
03:12:28 <yogsototh> frerich: I tried to add a lot of strictness without any success. strictRequestBody didn't worked thought. Thanks nonetheless!
03:13:38 <frerich> yogsototh: So *any* print statement work, e.g. 'print (replicate 1000 'x')'? Maybe it's not the value being printed (== forced) but rather the fact that you write to stdout at all.
03:13:43 <frerich> s/So/Does/
03:14:18 * frerich remembers he has this little 'times = replicate' alias :-)
03:15:49 <yogsototh> frerich: thanks for your help! I have to leave.
03:33:19 * hackagebot relational-query 0.7.0.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.7.0.0 (KeiHibino)
03:39:34 * hackagebot relational-schemas 0.1.2.1 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.2.1 (KeiHibino)
03:43:19 * hackagebot relational-query 0.7.0.1 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.7.0.1 (KeiHibino)
03:46:23 <mwawrzos> hello! I'm going to import some module without source file, just the *.o and *.hi, but ghc cant do this
03:46:30 <mwawrzos> what is wrong?
03:46:32 <frerich> Hm, is there a common term (maybe in the statistics vocabulary?) for a set of samples of some value over some time? I currently have a lot of 3-tuples like (Int, Int, Int) around which represent some value (e.g. # of downloads) in the past 6 months, past 12 months and 'all time'. I'd like to introduce a dedicated type with nicer accessors, but I can't think of a good name for that type.
03:46:50 <frerich> 'Histogram' would be wrong, I guess?
03:47:40 <frerich> I always have the same three bins.
03:48:20 * hackagebot relational-query-HDBC 0.4.0.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.4.0.0 (KeiHibino)
03:48:42 <pavonia> mwawrzos: Was that module build with the same GHC?
03:48:46 <pavonia> *built
03:49:21 <merijn> Same GHC, same dependencies, same OS :p
03:50:08 <mwawrzos> pavonia: yes, I compiled module B, moved his source, and tried to build module A with imports B
03:50:22 <mwawrzos> pavonia: and ghc sais `Could not find'
03:53:05 <pavonia> mwawrzos: Sorry, I don't know how you're supposed to import such modules
03:57:55 <mjburgess> is there a book i could buy (etc.) specifically on understanding the various c-theoretic abstractions haskell (etc.) uses: eg., functors, monads, applicatives, etc.
03:58:27 <mjburgess> i take myself to have a reasonable understand at the moment, but i'd appreciate something well-informed
03:58:51 <merijn> mjburgess: Depends, is the goal to learn category theory or to become a better haskell programmer?
03:59:06 <mjburgess> "yes", merijn
03:59:51 <merijn> That's not a particularly helpful answer :) Because imo the value of learning category theoyr in order to become a better haskell programmer is marginal at best (i.e. there are things to look into with a better time/impact ratio)
03:59:53 <mjburgess> haskell *itself* is a secondary goal, as much as category theory
04:00:23 <merijn> Whereas if you wanna learn category theory most books are mostly math and not much useful for (haskell) programmers
04:01:19 <ReinH> richard bird's Algebra of Programming is excellent but hard to find
04:01:27 <mjburgess> i dont intend to do very much with haskell, to be honest. I always have gch installed but have never in several years written more than a few lines
04:02:09 <merijn> mjburgess: I'm just trying to point out the "I need CT to do haskell" trap :)
04:02:18 <merijn> mjburgess: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ is a good blog series
04:02:23 <mjburgess> the goal is for me, i suppose, to understand "abstraction" as far as possible, but not going much further than the kinds expressable in haskell
04:02:39 <merijn> mjburgess: Other than that probably Category Theory by Awodey
04:02:58 <merijn> mjburgess: See, but then I would probably recommend you learn type theory/lambda calculus over category theory
04:03:10 <ReinH> Pierce's book might be a decent choice
04:03:24 <ReinH> (his CT book)
04:03:37 <merijn> I wasn't overly impressed by it
04:06:22 <mjburgess> there really ought to be a book which goes from lambda calculus to category theory
04:06:22 <merijn> mjburgess: Why? The two are almost entirely unrelated
04:06:22 <merijn> Going from one to the other is not really a natural step
04:06:22 <mjburgess> well something like, "a theoretical background for typed functional programming"
04:06:22 <merijn> mjburgess: Right, that'd be type theory and constructive logic
04:06:22 <ReinH> which wouldn't cover either of those topics very much...
04:06:22 <merijn> mjburgess: Once you know that you can then look into how category theory abstracts/generalises the logics
04:06:22 <merijn> But you are better of studying logics and type theory then category theory if you wanna learn something useful for haskell
04:06:44 <ReinH> software foundations and TaPL are good choices
04:06:59 <merijn> This is exactly the category theory trap I was referring too. I dunno where this "meme" of CT being a good starting point/being the basis of haskell comes from
04:07:12 <merijn> I second both SF and TaPL as books
04:07:33 <mjburgess> well I'm not taking CT as being a starting point for Haskell
04:07:48 <mjburgess> i've had years of observing or reading about haskell and i'm comfortable enough with typical usage
04:08:02 <merijn> mjburgess: No, but everything you mentions screams wanting to learn type theory and logic, not CT :)
04:08:15 <mjburgess> yes, i agree, and that's what i'll do
04:08:15 <merijn> mjburgess: Actually, there's an excellent talk by wadler on r/haskell atm
04:08:20 * hackagebot relational-record-examples 0.2.0.3 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.2.0.3 (KeiHibino)
04:08:31 <merijn> mjburgess: https://www.youtube.com/watch?v=IOiZatlZtGU
04:09:13 <merijn> mjburgess: If any of that is what you're interested in, you'll want to pick up Pierce's "Types and Programming Languages" and "Software Foundations" (the latter is online for free and includes exercises)
04:10:20 <ReinH> *consists almost entirely of exercises :)
04:10:30 <mjburgess> suppose then i have read all that and i have a reasonable grasp of both lambda calculus and type theory
04:10:41 <mjburgess> (incidentally i'd say i'm not very far way from that)
04:10:47 <mjburgess> now where would I go next?
04:11:30 <merijn> mjburgess: Depends on interest, I'd say Calculus of Constructions (i.e. dependent types) and then start dabbling in CT to generalise what you know so far
04:11:44 <mjburgess> right
04:12:15 <mjburgess> here's my issue (I think): I have too much knowledge of programming languages incapable of haskell-like abstractions
04:12:50 <mjburgess> and therefore I think i slip into thinking of  certain things (eg., even functors) to concretely
04:13:17 <merijn> mjburgess: Solution, program more haskell! ;)
04:13:28 <mjburgess> yes, i feared as muhc
04:14:31 <mjburgess> OK, well ill read up on those things 
04:15:21 <mjburgess> i think it might be an idea to get myself into a position where I can design something like haskell's type system (etc.) myself - ie. understand what a PLng requires  in order to express CT abstractions
04:15:48 <merijn> mjburgess: TaPL covers the design of type systems and goes far beyond haskell's
04:16:13 <merijn> mjburgess: IMO implementing Haskell2010 should be fairly straightforward after finishing TaPL
04:16:20 <mjburgess> yes, it looks very good
04:16:29 <mjburgess> great, I think that's exactly what i need to clairfy things
04:16:51 <merijn> It also covers things like existential quantification, objects, inheritance, subtyping, etc.
04:16:58 <mjburgess> I think I only every really understand something when im capable of generating it ab init. my self
04:23:21 * hackagebot psc-ide 0.5.0 - Language support for the PureScript programming language  https://hackage.haskell.org/package/psc-ide-0.5.0 (kritzcreek)
04:24:01 <bollu> > let powerset = fliterm (const [True, False]) in powerset [1, 2, 3]
04:24:03 <lambdabot>      Not in scope: ‘fliterm’
04:24:03 <lambdabot>      Perhaps you meant one of these:
04:24:03 <lambdabot>        ‘filter’ (imported from Data.List),
04:24:45 <bollu> guys, how do you powerset? I always forget the exact version
04:24:49 <bollu> is it mapm?
04:27:40 <ReinH> filterM
04:28:01 <bollu> ReinH: ty :)
04:28:14 <ReinH> > filterM (const [True,False]) [1,2,3]
04:28:15 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
04:28:21 <bollu> > let powerset = fliterM (const [True, False]) in powerset [1, 2, 3]
04:28:23 <lambdabot>      Not in scope: ‘fliterM’
04:28:23 <lambdabot>      Perhaps you meant one of these:
04:28:23 <lambdabot>        ‘filterM’ (imported from Control.Monad.Writer),
05:09:06 <cheater> hello
05:09:21 <cheater> is it possible to use a socks proxy with wreq? if not, are there other web request libraries that i might use?
05:13:22 * hackagebot huckleberry 0.9.0.2 - IchigoJam BASIC expressed in Haskell.  https://hackage.haskell.org/package/huckleberry-0.9.0.2 (tkmsm)
05:14:36 <liste> at least there's http proxy
05:25:24 <cheater> i cannot use an http proxy, i can only use socks
05:26:29 <hc> try tsocks?
05:26:48 <cheater> wreq seems to only support http.
05:27:10 <hc> http://tsocks.sourceforge.net/
05:27:16 <hc> read it, try it ;)
05:27:41 <hc> (it changes some libraries so all requests use socks, even if the tool you're using uses plain tcp sockets or http)
05:27:52 <cheater> oh tsocks
05:28:47 <hc> btw, you're in #haskell; you should probably ask such questions in ##linux or some related channel instead ;-)
05:28:57 <cheater> why?
05:29:04 <cheater> i was asking about wreq
05:29:35 <hc> ah, didn't see that
05:30:03 <cheater> i will try out tsocks, thank you
05:32:13 <Peaker> Hey, what's the purpose of the bidirectionality of pipes? Does anything use it?
05:32:40 <cheater> backchannel?
05:32:52 <cheater> say, control
05:33:11 <cheater> or: passing around a token. say you pass a token for a resource over a pipe, and you'd like it back later.
05:36:32 <Peaker> cheater: but the token isn't guaranteed to return (the pipe can prematurely terminate, no?)
05:38:37 <cheater> depends what kind of pipe you're talking about. do you mean like a TPipe?
05:58:24 * hackagebot reedsolomon 0.0.1.0 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.1.0 (NicolasTrangez)
06:13:25 * hackagebot shelly 1.6.4.1 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.4.1 (GregWeber)
06:16:41 <Ankhers> I'm trying to use csv-conduit to convert Haskell types to and from CSV files. I do not understand how to use the library. Would someone mind taking a look at http://lpaste.net/146275 and tell me how I would be able to do this?
06:20:31 <dutchie> Ankhers: looking at https://hackage.haskell.org/package/csv-conduit-0.6.6/docs/Data-CSV-Conduit.html, something like `readCSVFile defCSVSettings "data.csv"` should give you an IO (Vector ByteString)
06:20:42 <dutchie> (although the type doesn't constrain you to ByteStrings)
06:21:07 <dutchie> er actually ignore me 
06:21:12 <dutchie> you want a Vector Person
06:29:47 <greymalkin> Lifting feels awkward.
06:31:52 <lpaste> dutchie pasted “for Ankhers” at http://lpaste.net/146276
06:35:18 <dutchie> Ankhers: that paste works. you will probably want to fmap getNamed across the resulting Vector though
06:36:33 <Ankhers> dutchie: Thank you so much! I guess I didn't understand the `Named' part.
06:36:57 <dutchie> Ankhers: it can be hard to read those highly general type signatures
06:49:44 <yoyo-ma> yeah
06:49:51 <yoyo-ma> how can I loop in haskell?
06:50:32 <arw_> generally, you don't. the usual constructs to replace loops are map and fold.
06:50:51 <CindyLinz> forM_ [1..9] $ \i -> forM_ [1..9] $ \j -> putStrLn $ show i ++ " * " ++ show j ++ " = " ++ show (i * j)
06:51:02 <CindyLinz> yoyo-ma: ↑
06:54:14 <arw_> > map (+ 3) [1, 2, 3]
06:54:16 <lambdabot>  [4,5,6]
06:56:16 <mniip> > foldr1 (+) [1, 20, 300]
06:56:18 <lambdabot>  321
06:56:20 <padre_angolano> if I use finally and catch, do I do  A `catch` B `finally` C  or  A `finally` B `catch` C ?
06:56:56 <mniip> padre_angolano, depends on what sequence you want them in
06:57:18 <mniip> both are valid
06:57:47 <padre_angolano> mniip: I don't know if either of them is better
06:58:46 <mniip> what's better, 1 + 2 or 2 + 1
06:59:05 <padre_angolano> mniip: it doesn't matter :-)
06:59:23 <mniip> see
06:59:52 <exio4> padre_angolano: btw, did you A `catch` B `finally` C vs A `finally` C `catch` B? 
07:00:01 <exio4> did you mean*
07:00:07 <padre_angolano> exio4: right
07:00:44 <exio4> padre_angolano: in such case, do you need B to happen before C, C before B? does it matter at all? 
07:00:56 <mauke`a> what's better, 1 + 2 or 1 + 3?
07:01:32 <padre_angolano> hmm, if I do finally before catch, then catch will also catch exceptions in the finally part. So probably  ... `catch` ... `finally ... is more sound
07:01:49 <Taneb> mauke`a: 1 + 3, of course
07:01:51 <Taneb> Bigger number
07:02:00 <exio4> the bigger the better, they say
07:02:02 <padre_angolano> :-)
07:03:08 <padre_angolano> exio4: I think it doesn't matter. E. g. finally does hclose or killThread
07:03:08 <mniip> what's better 2 kilograms of uranium or 10 kilograms of uranium
07:03:47 <KaneTW> 20 kilogram
07:03:54 <arw_> depends on the density and distribution...
07:03:58 <mniip> no wait, yeah
07:04:03 <mniip> make that plutonium
07:04:09 <mniip> uranium has a critical mass of ~15
07:04:38 <KaneTW> ~15 apples?
07:04:40 <KaneTW> :v
07:05:05 <mniip> 15 square persons per megabyte to the fourth
07:25:31 <gganley> is ocharles doing another 24 days of haskell?
07:26:28 <gganley> s/haskell/hackage
07:27:54 <quchen_> gganley: I don't think so, at least he said he's not doing that sort of format this year when I talked to him at the Haskell Exchange. He mentioned a couple ideas he's had though, not sure what the status on those is.
07:31:25 <gganley> quchen_: thank you, ever since I started going to uni this year I havent been using haskell that much but I've always loved that series
07:31:29 <zennist> hey guys, recently I've run into some debate about monads with my coworkers - my idea is that monads are pure constructs that allows us to manipulate side effects in 'safe' ways - but if this is really pure (in the sense that the same input should always split out the same output); how do you test these functions like other pure functions?
07:32:14 <zennist> in particular, regarding this question I'm having trouble imagining testing a function like a -> IO a
07:32:35 <zennist> people can still say this is pure but the reality seems to suggest that you can still pretty much do anything inside there
07:34:23 <zennist> so just to be clear: is monad itself really pure? if not, is it only a way for programmers to use more proper pure functions inside their code? if it's pure, please suggest some ways to test it
07:35:14 <quchen_> ocharles__: ping
07:35:15 <Cale> zennist: The monad itself is a type constructor. It doesn't exist at runtime.
07:35:22 <ocharles__> quchen_: aloha
07:35:34 <quchen_> Any Christmas plans? :-)
07:35:38 <quchen_> gganley just asked
07:35:45 <Cale> zennist: (Well, it's a type constructor along with some functions, specifically return and (>>=) -- those functions are around at runtime...)
07:35:47 <quchen_> Is your minisieries still a thing?
07:36:35 <ocharles__> quchen_, gganley: https://twitter.com/acid2/status/669882628695281669
07:36:36 <ocharles__> sorry!
07:36:38 <Peaker> ghc-mod is atrociously slow. ghci-ng was deprecated(?) by ide-backend?  Is ide-backend support for atom available?
07:36:44 <zennist> Cale: it's a semantic construct that hides away control/side-effect logic; that part I do understand. what I don't understand is in what sense can monad be pure
07:36:48 <Xeironis_> I think I just read a post a few days ago on haskellforall explaining that the haskell program is pure because it just constructs a plan of IO actions, and the impure runtime then executes them, but I can't find it right now
07:36:59 <ocharles__> however... https://twitter.com/franklinchen/status/671113473405935616
07:37:37 <zennist> I've heard that you can view monads as a recipe - but how do you like at an 'IO a' and know what steps are inside this recipe? there is still no proper way to test it reliably
07:37:44 <quchen_> ocharles__: Neat!
07:39:03 <Cale> zennist: If we have f :: A -> IO B, say, and x :: A, then evaluation of the expression f x is pure in the sense that it will always produce the same result of type IO B, no matter how many times it's carried out, and has no visible effects otherwise.
07:39:12 <Cale> zennist: Execution of the resulting IO action is not pure.
07:39:15 <Xeironis_> zennist: a function a -> IO a will always construct the same sequence of IO actions - just the results of executing these actions may be different. So if you want to test the pure part, you can test whether the resulting actions are correct. This pretty much goes in that direction: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
07:39:31 <zennist> Cale: or it can die trying and give you bottom
07:39:39 <Cale> zennist: Yes, fair enough.
07:40:03 <Cale> bottom is considered a value much like any other in the semantics
07:40:11 <zennist> Xeironis_: okay will look at link thx
07:40:44 <Cale> zennist: Because IO is an abstract data type in Haskell, you're not allowed to inspect the steps which will be carried out
07:40:54 <Cale> zennist: But that needn't have been the case
07:40:58 <zennist> Cale: so monad is good in the way that it helps us capture control logic as values - but, there is not much point in looking at this value as a value, say, integer; in the sense that you can know clearly what's nside this value
07:41:00 <Niddy> Has anyone ever tried to set up a DBMS that preserved the Haskell Types?
07:41:05 <frerich> Given that Cale a) knows his stuff b) seems to enjoy explaining even very basic things and c) actually does so very well I think it's obvious that he should d) write some sort of blog or book or so about it.
07:41:05 <Cale> (Well, maybe to be practical it kind of has to be usually)
07:41:28 <Cale> zennist: btw, we're talking about IO actions specifically here, and not monads in general
07:41:32 <quchen_> Niddy: Well, there's binary-typed for typed serialization, which preserves types
07:41:41 <Cale> zennist: The fact that IO happens to be a monad doesn't really tell us much.
07:42:01 <Cale> zennist: and it is fairly atypical as far as monads go
07:42:07 <Niddy> quchen_: And would that work with SQL-like DBMS's?
07:42:26 <zennist> Cale: I do want to think about monads in general though, or monads that capture controls, really; e.g., that includes monads that contain a function e.g., state monad, reader
07:42:53 <zennist> the functions are value here too but again like what I said it's not so obvious as to how to inspect these values
07:42:57 <quchen_> Niddy: Sure, I mean the idea is to write (typeRep, value) tuples into the DB. That breaks atomicity though, so it's not exactly a clean DB workflow.
07:43:29 <hackrilege> Why cant i write ; instance (A f a) => B (f a) where
07:43:56 <quchen_> If you externalize the types into a separate table you could split it up and work something out … I haven't given this much thought. But in some way you have to tell the SQL server how to store your stuff, and how to add the type to it.
07:44:08 <quchen_> And vanilla SQL certainly can't deal with Haskell types.
07:44:26 <Cale> zennist: Functions are somewhat like black-boxes indeed, but it's possible to reason about which result they will produce for any given argument.
07:44:32 <Niddy> quchen_: I found Persistent in Hackage, which is made by the Yesod guys. Looks pretty easy to use, but they only show examples that use Sqlite, and I'm wondering how it would be implemented in MySQL or PostgreSQL
07:44:40 <mniip> hackrilege, sure you can
07:44:46 <hackrilege> The translate the haskell types to c or js
07:44:47 <mniip> oh wait
07:44:50 <mniip> I see
07:44:52 <zennist> Cale: using equivalence reasoning I guess :)
07:44:53 <Niddy> http://www.yesodweb.com/book/persistent
07:44:54 <Cale> zennist: Two functions f and g are equal when f x = g x for any x.
07:44:57 <Cale> yeah
07:45:23 <zennist> would hope for a better 'recipe testing' procedure but guess this is as far as what we can do
07:45:29 <Cale> For IO actions, it's a little harder to define what it means for them to be equivalent or equal.
07:45:30 <quchen_> Niddy: "
07:45:30 <quchen_> Database-agnostic. There is first class support for PostgreSQL, SQLite, MySQL and MongoDB, with experimental Redis support.
07:45:30 <quchen_> "
07:46:04 <hackrilege> mniip im guessing its pretty deep
07:46:10 <Niddy> quchen_: I'm a bit new with Haskell still, and can't really see how the connection would work, if you didn't use runSqlite
07:46:42 <mniip> yes, there's a deep reason for this but I can't quite remember it
07:46:43 <hackrilege> instance (A f a) => B (f a) where
07:46:45 <Cale> zennist: Which is a serious criticism I suppose, but we'd have a better shot at it if IO weren't an abstract type (and it's possible to imagine it not being abstract)
07:47:14 <hackrilege> I bet Cale knows
07:47:34 <Cale> hackrilege: hm?
07:47:44 <hackrilege> (hackrilege) Why cant i write ; instance (A f a) => B (f a) where
07:48:40 <Cale> hackrilege: Well, I think you can write that, but it'll overlap with a lot of other things
07:49:00 <hackrilege> Its an error
07:49:11 <Cale> Which error?
07:49:17 <mniip> well actually
07:49:20 <mniip> you can do that
07:49:22 <mniip> yes
07:49:23 <Cale> You might have to turn on some extensions to make that work
07:49:29 <mniip> UndecidableInstances
07:49:41 <hackrilege> Nope
07:49:51 <Cale> hackrilege: It's important to remember that during the process of selecting which instance applies, the class constraints on instances are *ignored*. Only after deciding on an instance are they checked.
07:50:11 <geekosaur> maybe provide compileable example and the full error message?
07:50:12 <hackrilege> Unexpected type (f a)
07:50:13 <geekosaur> @paste
07:50:13 <lambdabot> Haskell pastebin: http://lpaste.net/
07:50:47 <hackrilege> Ok
07:50:52 <Cale> hackrilege: This is because instances can always appear in future modules, and so you can't rely on the information that an instance is *not* present.
07:51:45 <hackrilege> !?
07:51:52 <Cale> hackrilege: If the instance selector skipped over an instance because the class constraint wasn't satisfied, compiled the module, and then that instance was defined in a later (or sibling) module, it would be confusing
07:52:06 <Cale> Because it would look like the instance should be used, but it wouldn't be
07:52:36 <Cale> Since that sucks, instance selection is designed to avoid that problem, by simply disregarding class constraints on instances until a definite instance is selected.
07:52:42 <happyfeet> how can I make a system process exit at the same time i close my program?
07:52:50 <Cale> (and complaining if it can't be)
07:52:57 <hackrilege> Like partially implementing the class?
07:53:04 <Cale> huh?
07:53:19 <hackrilege> Nvm
07:53:28 <hc> happyfeet: how do you close your program? CTRL+C?
07:53:29 <hackrilege> Ill write a paste brb
07:53:38 <hackrilege> Yes hc
07:53:44 <happyfeet> i click 'esc'
07:53:48 <happyfeet> hc
07:54:38 <hc> happyfeet: not sure if it works in this case, but i'd give "finally" a try: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception.html#v:finally
07:55:16 <hc> to terminate a process: https://hackage.haskell.org/package/process-1.4.1.0/docs/System-Process.html#v:terminateProcess
07:56:20 <happyfeet> thanks hc
07:56:51 <hc> i've just checked it: finally is called when you press CTRL+C, but it isn't called when you send SIGTERM
08:04:00 <funfunctor> hi
08:04:41 <funfunctor> Has anyone written something around some ioctl() for a particular device model before? Just looking to get some ideas on something
08:05:34 <hackrilege2> Cale, mniip, geekosaur, http://lpaste.net/146290
08:06:34 <geekosaur> I don't see B defined in there, nor the full error
08:07:11 <funfunctor> I'm thinking I may wind up with some kind of pipes interface but thats down the road a little
08:07:15 <mniip> B is defined
08:07:24 <mniip> as a "subclass" of A
08:07:34 <mniip> geekosaur, it says class not instance
08:16:32 <hackrilege> Im still here!
08:16:55 <hackrilege> Unexpected type (f a)
08:18:08 <mniip> hackrilege, you can't declare classes like that
08:18:22 <mniip> a class declaration is always 'ClassName a b c...'
08:18:29 <mniip> optionally with constraints on a, b, c
08:18:47 <mniip> I'm guessing you could say (A f a, r ~ f a) => B r
08:18:48 <hackrilege> Yeh
08:18:52 <mniip> but that might be even more undecidable
08:19:10 <hackrilege> What is that tilde!?
08:21:52 <mniip> :k (~)
08:21:54 <lambdabot> k -> k -> Constraint
08:21:55 <hackrilege> Also, what you surgested does not compile
08:22:36 <hackrilege> It destroys something, it throws loads of not in scope f a errors for all mentions of f and a
08:23:11 <mniip> paste code and error
08:25:08 <hackrilege2> http://lpaste.net/146291
08:27:06 <hackrilege> mniip^
08:31:25 <hackrilege> anyone?
08:34:04 <Cale> hackrilege: f and a aren't in scope
08:34:25 <Cale> hackrilege: What is that supposed to mean?
08:35:31 <Cale> hackrilege: do you want it to search through all possible choices of f and a hoping to find pairs such that f a ~ r and then check to see if there's an instance A f a?
08:35:54 <Cale> hackrilege: What class are you actually trying to write?
08:36:09 <Cale> (It's hard to figure out what you're trying to do given names like A and B)
08:40:50 <hackrilege> Ok, so that last paste was an attempt to implement something mniip said above
08:40:59 <hackrilege> Im not sure how it should work
08:41:21 <Cale> hackrilege: What program are you actually trying to write though?
08:41:27 <Cale> What does the real type class look like?
08:41:42 <Cale> Maybe it will make more sense what you're trying to accomplish if there's a bit more context
08:42:22 <hackrilege> A f a in reality is Modifiable f a. B (f a) is actually Growable (Graph Double
08:42:26 <hackrilege> )
08:42:50 <Cale> What are the methods of these classes?
08:43:06 <hackrilege> Modifiable has insert and retrieve, Growable has grow
08:43:28 <Cale> ... and their types?
08:43:39 <hackrilege> ...
08:43:47 <hackrilege> I should paste my actual source?\
08:43:52 <Cale> yes
08:43:54 <hackrilege> Kk
08:44:48 <hackrilege2> http://lpaste.net/146292
08:44:51 <hackrilege2> Cale^
08:46:41 <Cale> Okay, I don't really understand e.g. the type of insert
08:48:16 <hackrilege> Insert takes an ellemnt and an indexed functor and returns an indexed functor and an Index
08:48:36 <Cale> okay
08:48:41 <hackrilege> Put this thing in that thing and tell me how i can access it
08:48:55 <Cale> Are you sure you don't want  class Indexed f a => Growable f a  ?
08:49:05 <hackrilege> No
08:49:10 <Cale> You didn't give any methods for that class
08:49:21 <hackrilege> The type paramenter of Growable should be kind *
08:49:32 <Cale> why?
08:49:50 <hackrilege> Other code later would like that
08:50:03 <Cale> Okay, so we need more context
08:50:04 <aleator_> I made a tool for making haskell type grokking exercises: looks like this: http://codepen.io/anon/pen/WrebRE. (The dashed lines are commands supplied by user). What do you think?
08:50:29 <hackrilege> I have graphs full of stuff. They are Indegexed Graph Double for example. Graph Double is of kind * as desired
08:50:47 <Cale> hackrilege: What are the methods of Growable?
08:50:56 <Cale> You mentioned grow, but you didn't provide a type signature
08:51:12 <Cale> I don't really understand why Growable couldn't just have two type arguments
08:51:23 <hackrilege> The methods of Grrowable should be in terms of the type parameter (f a) e.g. they should act on Graphs of Doubles if an instance is provided
08:51:43 <hackrilege> They should not act on kind * -> * Graphs
08:51:48 <Cale> huh?
08:52:01 <Cale> There are no values of types which have kind * -> *
08:52:24 <hackrilege> Functor f +. F
08:52:25 <hackrilege> Oops
08:52:29 <Cale> Ordinary boxed values always belong to a type of kind *
08:52:31 <hackrilege> Functor f => f
08:52:39 <Cale> Yeah, that's a kind error.
08:52:46 <hackrilege> Kk
08:52:51 <hackrilege> So
08:52:52 <Cale> You can't have  x :: Functor f => f
08:53:09 <hackrilege> Yeh but i could have Class Functor f => A f
08:53:14 <Cale> sure
08:53:22 <hackrilege> Thats what i meant
08:53:30 <Cale> I still don't understand
08:53:41 <Cale> Can you *please* give the type signature for grow
08:53:56 <hackrilege> Ok
08:54:19 <Cale> If you write it, then we can actually try something. :)
08:56:17 <hackrilege> Let (f a b) = (Indexed Graph Double) in grow:: b -> (f b) -> (f b,Int)
08:57:15 <Cale> hackrilege: uh what was that first bit?
08:57:16 <hackrilege> Put the Double in the Graph, give me that back and tell me how i can access it
08:57:38 <Cale> Isn't Indexed a class?
08:58:00 <hackrilege> Graph has an indexed instance
08:58:16 <hackrilege> Yes its a class, sorry my syntax above is pseudohaskell
08:58:19 <Cale> So for example, you want to be able to have  grow :: Double -> Graph Double -> (Graph Double, Int)
08:58:29 <Cale> So why not:
08:58:45 <hackrilege> Grow should act on all indexed f a
08:59:05 <Cale> class Indexed f a => Growable f a where grow :: a -> f a -> (f a, Index)
08:59:06 <hackrilege> Other things than Graphs of Doubles have Indexed instances
08:59:34 <hackrilege> Ok, so thats no good because then Growable things are of kind * -> *
08:59:43 <Cale> huh?
08:59:44 <hackrilege> E.g. Graphs are growable
08:59:52 <hackrilege> But i want Graphs of Doubles to be growable
09:00:00 <Cale> I don't understand
09:00:23 <Cale> Can you just try this and tell me how it works out?
09:00:31 <Cale> Where do you get stuck?
09:00:32 <hackrilege> No!
09:00:39 <hackrilege> sorry
09:00:50 <Cale> I'm like 99.8% sure it'll work just fine if you try it
09:01:05 <hackrilege> I can try to tell you where i get stuck with that approach, but it is unfinished code
09:01:23 <hackrilege> So its hard, i should try to overcome this stubeling block before i can move on
09:01:35 <Cale> Sure, just give it a shot, and when you get stuck let me know and we'll figure *that* bit out
09:01:42 <Cale> because I'm pretty sure this is the class definition you want
09:01:55 <Cale> So if there's a problem, it's probably something else.
09:02:58 <hackrilege> Ok, so i had a class Z f a but its method empty required proxy types, instead i try Z z, but now class Indexed f a => Z f a wont work so i want instead, Growable z => Z z
09:03:13 <hackrilege> Makes sense?
09:03:46 <c_wraith> hackrilege: I suspect you don't want a class at all. What happens when you do this without a class? 
09:04:05 <hackrilege> Without a class i cant use the default modify
09:05:14 <hackrilege> And maybe even more horrible things
09:05:14 <c_wraith> All I can say is that the problems you are describing are the ones you get when using a class for something that should be done without. 
09:05:26 <hackrilege> It cant be done without though
09:05:32 <Cale> Yeah, it's quite possible that these should be data declarations rather than class declarations
09:05:49 <hackrilege> This was raised before i tried that approach it didnt work im trying this one
09:05:51 <Cale> You can *always* do things with data instead of class
09:06:02 <Cale> If you can't do it with data, you can't do it with class.
09:06:11 <hackrilege> I cant quite remember why it didnt work with a class, i think i made a paste about it a few days ago...
09:06:36 <Cale> (It might be slightly more awkward, and less implicit, but you should be able to write the program)
09:06:39 <hackrilege> You can do inheritance of default methods with a class but not a datatype
09:07:00 <Cale> You can still write a function which fills in those fields of a data type for you
09:07:13 <hackrilege> Its against legibility
09:07:29 <hackrilege> Asume the default method provided is infnitly verbose
09:07:33 <hackrilege> Just for ease
09:07:39 <Zekka|Sigfig> hackrilege: You can do it with a record pretty easily, actually
09:08:06 <Cale> mkFoo x y = Foo x y (defaultMethod x y)
09:08:10 <Zekka|Sigfig> record update gives you a nice extension operation, although for everything to work automatically you will need to pass a record ref to each function in the record
09:08:33 <Zekka|Sigfig> (this is not significantly different from how typeclasses are implemented under the hood afaik - a vtable where the methods take a vtable pointer)
09:09:56 <hackrilege> Ok guys great stuff
09:10:05 <Cale> hackrilege: The only thing that class really gives you is that the compiler will figure out which instance to supply based on the type, rather than requiring you to supply another argument explicitly
09:10:21 <hackrilege> Yeh
09:10:27 <hackrilege> So thats what im doing
09:10:30 <Cale> hackrilege: But if you're having trouble getting the compiler to know which thing to supply... then maybe you're better off not having that be implicit
09:10:42 <hackrilege> And maybe not
09:11:02 <hackrilege> I find both ways impossible and at least this one has most of what i want
09:11:26 <Cale> What instances of these classes are you going to write?
09:11:38 <hackrilege> Graph and Tree should be sufficient
09:11:48 <hackrilege> Just for benchmarking
09:11:55 <hackrilege> I have a fast datatype
09:12:10 <hackrilege> Pottentially
09:13:08 <Cale> If it's just for benchmarking, are you sure it's really worth trying to figure out how to abstract over both types, rather than just modifying your benchmark to use one vs. the other?
09:13:11 <hackrilege> So, Indexed is a type of collection. Growable should be a populated collection. It has already been provided the type of its contents
09:13:41 <Cale> Sometimes you're better off just editing the code :P
09:14:10 <hackrilege> Its the major part of my thesis due for significant presentation on the 18th. Its almost working and this bug has taken me a week
09:14:47 <hackrilege> Just in that, its not just for benchmarking
09:14:54 <Cale> okay
09:15:03 <Cale> But yeah, note that with my Growable class
09:15:10 <Cale> class Indexed f a => Growable f a where grow :: a -> f a -> (f a, Index)
09:15:34 <Cale> The grow function might have its type specialised to  Double -> Graph Double -> (Graph Double, Index)
09:16:04 <hackrilege> Your giving me proxy types again
09:16:12 <Cale> I don't see the proxy type
09:16:12 <hackrilege> Remember its subclass has a method empty
09:16:20 <Cale> What's the type of empty?
09:17:25 <hackrilege> Class Growable z => Z z where empty::z
09:17:33 <Cale> So why not:
09:17:49 <Cale> class Growable f a => Z f a where empty :: f a
09:19:12 <Cale> You want e.g.  empty :: Graph Double, right?
09:20:00 <hackrilege> I see what you are saying
09:20:17 <hackrilege> And yes i wish i could remember why that way posed problems
09:20:30 <hackrilege> Ill have to try it that way again
09:22:15 <hackrilege> Ok, i have data D = D (Graph double, instance Growable D, instance Z D
09:22:55 <hackrilege> D can have othre attributes to give it reason to exist
09:23:25 <Cale> uh, that's not valid syntax, btw
09:23:47 <hackrilege> Alts maybe data T = T (Tree Double)
09:23:49 <hackrilege> Also*
09:23:57 <Cale> You probably want  instance Growable D Double
09:24:03 <hackrilege> Yeh i dropped a )
09:24:04 <Cale> and instance Z D Double
09:24:22 <Cale> D will need a type parameter
09:24:27 <dfeuer> Why isn't Ord a superclass of Enum?
09:24:27 <hackrilege> No data Growable z => Z z
09:24:45 <dfeuer> [Aside from the general rule that Enum makes no f***ing sense]
09:24:50 <Cale> hackrilege: btw, that class context is stupid and you should basically never use it
09:25:00 <hackrilege> Thats the point. D is not kind * -> *
09:25:04 <hackrilege> Now you have my problem
09:25:06 <hackrilege> Horay!!
09:25:16 <dfeuer> D'you know, Cale?
09:25:19 <Cale> hackrilege: Well, you designed these classes for parametric data types
09:25:30 <hackrilege> But then i applied them
09:25:33 <Cale> hackrilege: So you need to use them with parametric data types, there's no way around that
09:25:49 <hackrilege> I cant keep that open type paramenter. At some point it is filled
09:25:52 * dfeuer throws fish at hackrilege.
09:26:04 <Cale> dfeuer: I tend to think of Enum as just a definition for what the list sequence syntaxes do
09:26:09 <hackrilege> Youd think Ord would be a superclass of Enum though
09:26:21 <dfeuer> Seeing as how it has pred and succ.....
09:26:28 <Cale> I don't think succ and pred belong there
09:26:37 <hackrilege> Maybe it allows you to make custom ordering?
09:26:44 <Cale> Similarly toEnum/fromEnum are bad
09:26:52 <dfeuer> No, and probably not toEnum and fromEnum either, which should be in an IntLike class or something.
09:26:57 <Cale> yeah
09:27:10 <hackrilege> Flying fish...
09:27:44 <dfeuer> hackrilege, I missed the beginning of this convo, but can you restrict things with a GADT?
09:27:58 <Cale> Like, you could give a reasonable definition for [a,b..c] when a and b are complex numbers. There'd be some arbitrary convention involved in defining [a..], but that's not so bad
09:28:15 <hackrilege> Hey cale, id love to get all this up on hackage so you can take a look at the whole thing... ill get this bug dead and then the context will be much more apparent. Ill try to put it in words
09:28:27 <dfeuer> Cale, I am not convinced you could give a reasonable definition for that.
09:28:33 <ttt_fff> is there any haskell linear algebra library that owrks with ghcjs?
09:28:37 <Cale> dfeuer: hm?
09:28:51 <ttt_fff> I need linear algebra in ghcjs, and I'd prefer something that works with ghcjs rather than "try to wrap this via javascript ffi again"
09:29:03 <Cale> dfeuer: Well, yeah, it might be a bit weird :)
09:30:13 <cxdf> Hi, I'm just learning haskell, and I'm trying to create a function signature that returns a structure like [[1], [[1]], [1]], howerver, I can't figure out the return type.
09:30:16 <hackrilege> Indexed collections serve as a superclass with convinient growth methods to be used be a generall growth method later. I have Graphs of Monomers which are Polymers. Polymers do not take a ny type parameters, yet they should be instances of Growable so the general growth method Z can be instantiated
09:30:22 <Cale> dfeuer: You'd have to do something like [a,b..c] = takeWhile (\x -> magnitude (x - a) <= magnitude (c - a)) (iterate (+(b-a)) a)
09:30:30 <cxdf> I get errors if I try anything like Int->((Num t, Num [t])=>[[t]])
09:30:39 <cxdf> Any ideas?
09:30:46 <Cale> dfeuer: But maybe that's not an ideal analogy to what it does in other cases
09:31:03 <hackrilege> Also, the question was, why is this not allowed, not, how else can i do this
09:31:09 <dfeuer> Cale, I'd *personally* prefer to have a multiparameter typeclass for those.  class Enum (f :: * -> *) (n :: *) where enumFromThenTo :: n -> n -> n -> f n
09:31:15 <Cale> (it's weird when c lies in some direction which isn't along the ray from a through b)
09:31:44 <Cale> hackrilege: Well, it's not allowed because it makes no sense :)
09:31:51 <dfeuer> But then there's also the big question of whether enumFromThenTo, or enumFromSkipTo, or enumFromSkipCount...
09:32:04 <hackrilege> Righto
09:32:05 <Cale> hackrilege: Well, at least, some of the things you were trying didn't make any sense
09:32:32 <Cale> hackrilege: You really need to know what f and a are here separately in order to use these classes.
09:32:56 <Cale> hackrilege: Because the methods of the classes separate the two from each other
09:33:00 <mnoonan> cxdf: your constraint has to come first, like "(Num t, Num [t]) => Int -> [[t]]".  But this probably isn't what you really want (there is no Num instance for [t], for example)
09:33:01 <dfeuer> Cale, yeah, probably better to make that parametrization explicit.
09:33:03 <hackrilege> You would think a partially applied kind would be a kind of one less *
09:33:20 <hackrilege> I mean why cant i write (f a)
09:33:24 <hackrilege> Its of kind *
09:33:43 <hackrilege> If f is *->* and a is *
09:33:52 <cxdf> mnoonan: What is t in this context? I'm still trying to figure out how things are denoted in ghci
09:34:20 <monochrom> cxdf: I advise against trying to have [[1], [[1]]] to begin with.
09:34:40 <mnoonan> cxdf: can you explain what function you want to write?
09:35:00 <mnoonan> or give some input/output examples, at least
09:35:14 <hackrilege2> sorry dropped connection
09:36:25 <hackrilege2> yeh, when you say it makes no sense, thats not right. it makes sense to me, i want to knoow why it makes no sense to the compiler. i think the syntax i am using has clear meaning
09:36:43 <cxdf> mnoonan: I'm trying to create a list or sequence of nested lists. For a neural network. For the different layers. Is there some other sequence or type that I should be using? Completely new to this language. 
09:37:16 <monochrom> cxdf, then you should define your own data type for such nesting, rather than hijacking the standard list type
09:37:40 <monochrom> the standard list type is simply not defined for nesting
09:38:20 <monochrom> at least, not for varying levels of nesting
09:38:33 <hackrilege2> id be satisfied to understand |
09:38:35 <hackrilege2> ~
09:38:42 <hackrilege2> as then at least id have learned something
09:38:57 <hackrilege2> :t (~)
09:38:59 <lambdabot> parse error on input ‘)’
09:39:07 <hackrilege2> awesome
09:39:17 <monochrom> or maybe you can use the tree type in Data.Tree, if you wonder if someone already did this
09:39:27 <Cale> hackrilege2: ~ is type level equality
09:39:50 <cxdf> monochrom: Thanks. I'll look into it.
09:39:52 <Cale> hackrilege2: u ~ v is a constraint which means that the types u and v must be equal
09:40:22 <tailgate> with Data.Map, how can I merge two Maps of the same type together?
09:40:33 <Cale> :t Map.union
09:40:34 <lambdabot>     Not in scope: ‘Map.union’
09:40:34 <lambdabot>     Perhaps you meant ‘M.union’ (imported from Data.Map)
09:40:37 <Cale> :t M.union
09:40:38 <lambdabot> Ord k => M.Map k a -> M.Map k a -> M.Map k a
09:40:41 <dfeuer> I really don't know why the GHC people decided to use ~ instead of just =.
09:40:50 <Cale> dfeuer: I know, it's weird.
09:40:57 <Cale> dfeuer: Probably ambiguity
09:41:00 <Cale> in the parser
09:41:04 <hackrilege2> how could i use that
09:41:06 <hackrilege2> ?
09:41:12 <dfeuer> Although I guess it would be even nicer to have = for  :~:
09:41:14 <hackrilege2> r ~ f a
09:41:17 <dfeuer> Ah, good point, Cale.
09:41:27 <dfeuer> Or ... for both, even.
09:41:31 <dfeuer> = = = = = = =
09:41:33 <dfeuer> :P
09:42:00 <hackrilege2> ...
09:42:27 <Cale> Well, that means that whichever types r, f, and a are, that f a must be the same type as r
09:42:30 <dfeuer> Aha! I just figured out a sort of "erasure" for my LT....
09:42:40 <Cale> However, all three of those things need to be in scope for the constraint to make sense
09:42:56 <dfeuer> I think.
10:02:29 <Luke> bergmark: does bumper bump build-depenency versions or just package versions?
10:17:36 <Ankhers> I want to use slightly different datatypes before and after I place the values into a database. Do I need to create two different datatypes or is there a better solution? Example: http://lpaste.net/146294
10:21:56 <justin_smith> Ankhers: what about making bazs and bazFooID each be options?
10:22:28 <justin_smith> I guess that adds the complexity of handling each option in your code of course
10:23:12 <Ankhers> justin_smith: The input is coming from a library that is parsing a CSV file. I would prefer to not add the database knowledge into the library that is parsing the CSV.
10:25:10 <justin_smith> Ankhers: what about replacing your second Foo with DbFoo {foo :: Foo, bazs :: [Baz]}
10:25:19 <justin_smith> so it contains both a foo and bazs
10:25:44 <Ankhers> That might make sense.
10:26:00 <justin_smith> that doesn't fix the second Baz definition of course (reverse problem, removing rather than adding)
10:26:58 <Ankhers> Does anyone know if I call a linked attribute like that in persistent / esqueleto if it always grabs that data, or only when calling the attribute?
10:28:13 <ideuler> So need to check if a string is all in upper case. Thought about this: foldl (&&) True (map isUpper "OLa") . How to make it cleaner?
10:30:08 <geekosaur> :t all Data.Char.isUpper
10:30:09 <lambdabot> Foldable t => t Char -> Bool
10:31:15 <ideuler> geekosaur cheers!
10:36:13 <Xandaros> Hmm, I added a second layer to my transformer stack and now I can derive MonadTrans anymore. The underlying type still has that instance, why can't I derive it with GeneralizedNewtypeDeriving? :(
10:38:14 <glguy> It'd probably help if you pasted the newtype and the error message :(
10:38:37 <Gustavo6046> lambdabot didn't respond when I pmed her "https://www.youtube.com/watch?v=IdtKbq3Omkw" :(
10:38:53 <Gustavo6046> everyone is finishing phrases with :(
10:39:31 <glguy> Gustavo6046: That would have been even better if it was "everyone is finishing phrases with :( :("
10:39:43 <Gustavo6046> lol
10:39:45 <glguy> :(
10:40:00 <Gustavo6046> hey guy stop it >:( (thats different) :(
10:40:03 <Xandaros> glguy: http://hastebin.com/emilovobok.hs
10:40:39 <glguy> Xandaros: the lift that "EitherT" provides is not the one you wanted
10:40:46 <glguy> You now need a (lift.lift)
10:41:02 <glguy> EitherT's lift would lift a StateT to EitherT..
10:41:21 <glguy> You need one from m a -> EitherT _ (StateT _ m) a
10:41:31 <Xandaros> oh, I see
10:41:44 <Gustavo6046> Gustavo6046> lambdabot didn't respond when I pmed her "https://www.youtube.com/watch?v=IdtKbq3Omkw" :(
10:42:07 <cabbibo> Hey All. I know I've been asking a bunch of really dumb questions the past few days, but I got another one for yall :)
10:42:08 <cabbibo> :(
10:42:28 <cabbibo> I'm really new to using monads, and I keep on getting a type error of
10:42:35 <cabbibo> Couldn't match type ‘m’ with ‘IO’
10:42:46 <cabbibo> the code is up here: http://lpaste.net/146296
10:42:58 <shinka> I couldn't find any equivalent of "any" and "all" for maps in the Data.Map module so I wrote my own (anyKey p = Map.foldrWithKey (\key _ acc -> acc || p key) False)... but I'm very surprised there is no such function in Data.Map. Is it in a different module?
10:43:03 <Gustavo6046> no one is using lambdabot
10:43:21 <cabbibo> and there are def a bunch of modules that I'm using, that make it pretty convoluted, but I was wondering if there is some easy error that I am missing just in the first chunk of code
10:43:22 <glguy> cabbibo: You wrote a type signature for your function that it works in all types 'm' constrainted by Monad
10:43:31 <glguy> cabbibo: but then you used an operation that only worked in 'IO'
10:43:35 * hackagebot reedsolomon 0.0.1.1 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.1.1 (NicolasTrangez)
10:43:37 <Xandaros> cabbibo: looks like you need a liftIO there somewhere
10:43:49 <cabbibo> glguy: so the <- only works with IO ?
10:44:08 <glguy> no, it works for any Monad instance
10:44:58 <cabbibo> ahh, so it must be in the 'readArray' function...
10:45:01 <glguy> yeah
10:45:05 <cabbibo> cool
10:45:11 <cabbibo> thank you very much for clearing that up
10:45:17 <cabbibo> super supe helpful :) :( 
10:46:22 <cabbibo> glguy : so if I am in a module, is there anyway to still use that function? like using liftIO or something ( sorry if thats another silly question )
10:46:40 <cabbibo> sorry sorry monad not module ...
10:46:46 <cabbibo> haven't had enough coffee today :(
10:46:48 <cabbibo> :)
10:47:02 <glguy> cabbibo: yeah, liftIO :: MonadIO m => IO a -> m a
10:47:16 <glguy> so it'd allow you to use that IO restricted action in your generalized context
10:47:22 <cabbibo> rad!
10:47:26 <cabbibo> thanks!
10:47:48 <cabbibo> so thats why putStrLn needs a liftIO as well ?
10:49:12 <Cale> cabbibo: Yeah, generally, liftIO turns an IO action into an action of some other monad (which typically has to be built in terms of IO somehow to make this operation implementable)
10:50:29 <Cale> cabbibo: In this case, you're writing a function which is supposed to be polymorphic in the choice of monad, according to its type signature, but you're assuming that there's an instance of MonadIO, i.e. you're assuming that liftIO is defined for this monad.
10:51:20 <akegalj> I have one shared variable. 1000 threads need to read that variable, and only one thread is only writting to the variable. I have implement this problem with TVar and it works ok, but I am thinking maybe TVar is an overkill. Because I don't need transactions. Is this good use case for MVar ?
10:51:53 <cabbibo> right right, so the monadState World, is one type of monad, but than have defined the MonadIO to still be able to use io actions 
10:52:10 <cabbibo> Cale : thanks for the explanation. Its starting to make a bit more sense :)
10:52:47 <Cale> Yeah, MonadState World m means that the operations get :: m World and put :: World -> m () are defined
10:53:05 <Cale> cabbibo: and of course, they just end up using StateT to make that happen.
10:53:14 <Cale> Personally, I would almost never take this approach
10:53:21 <cabbibo> right right
10:53:27 <cabbibo> Cale : why not ?
10:54:33 <Cale> Well there are a few reasons, depending on what aspects of this approach are important to you, it's almost always more convenient to use one of a few other things
10:55:24 <Cale> So, IO already has IORefs
10:55:29 <cabbibo> I *think* that the most important part of it is being able to keep all the state away from the rest of the code
10:55:56 <cabbibo> ok. I don't really know anything about those :)
10:56:06 <cabbibo> but im reading about them right now!
10:56:13 <Cale> Demanding MonadIO m is just as bad with respect to what the code is allowed to do as simply using IO
10:56:29 <Cale> It means "this code can do everything that an IO action can, and possibly some additional things"
10:57:02 <cabbibo> right right
10:58:28 <Cale> cabbibo: and using StateT, well, while it might initially seem attractive because you don't have to explicitly pass your state parameter along, the syntactic cost in terms of needing to liftIO everywhere usually more than makes up for that, and of course it doesn't make your types any shorter
10:58:36 * hackagebot hspec-discover 2.2.1 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.2.1 (SoenkeHahn)
10:58:38 * hackagebot hspec-core 2.2.1 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.2.1 (SoenkeHahn)
10:58:57 <cabbibo> Cale : Makes sense!
10:59:02 <Cale> cabbibo: There are some cases where you can write a bunch of code which has a type like  (MonadState World m) => ... -> m Result
10:59:22 <Cale> i.e. where you avoid needing IO, and the type then explains that you don't need general IO
11:00:03 <cabbibo> right right, so maybe MonadState World m should be used when you don't need IO, but than if you do need IO, why not just use IORef ?
11:00:12 <Cale> However, there are a bunch of other options which could be considered in those cases too, and usually I find one of them wins
11:00:25 <Cale> One is to abstract over the state operations another way:
11:00:31 <Cale> e.g.
11:01:09 <Cale> data WorldOps m = WO { getWorld :: m World; putWorld :: World -> m () } -- usually you'd have more refined operations than these even
11:01:13 <Cale> and then you can write:
11:01:29 <Cale> (Monad m) => WorldOps m -> ... -> m Result
11:01:54 <Cale> and it's possible to make a WorldOps IO by constructing an IORef or whatever
11:01:58 <cabbibo> right right
11:02:16 <Cale> and that again is able to prove that you don't need anything other than those state manipulation operations
11:02:33 <cabbibo> ok  i see what you are saying
11:02:48 <Cale> (and usually after a bit more customization to your application, ends up being nicer than using "get" and "put")
11:02:56 <cabbibo> right right
11:03:29 <cabbibo> so basically instead of monolithically passing in the entire state, you more specifically pull them in when you need them ?
11:03:36 * hackagebot hspec 2.2.1 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.2.1 (SoenkeHahn)
11:04:07 <Cale> You pass in actions (or functions producing actions) which will manipulate the state in various ways.
11:04:11 <cabbibo> is that misunderstanding what you are saying with the WorldOps
11:04:15 <cabbibo> ok ok ok 
11:04:19 <cabbibo> I dig it now
11:04:36 <Cale> This is basically like OOP, except I've added one more layer of abstraction to it
11:04:45 <Cale> We could actually get rid of that
11:05:03 <Cale> data WorldOps = WO { getWorld :: IO World, putWorld :: World -> IO () }
11:05:53 <Cale> So a value of this type is basically an object with methods to get and put a value of type World
11:06:19 <cabbibo> ok. I see that!
11:06:21 <Cale> Specific ones might store the World in a file, or use an IORef... you might add logging
11:06:39 <cabbibo> thanks so much for the deep explanation. Its making me understand so much more about haskell / programming in general :)
11:06:46 <Cale> By abstracting IO to an arbitrary monad m
11:07:02 <Cale> We can restrict the operations which are available to *just* these things (and whatever else we provide)
11:07:29 <Cale> So, maybe some function is *only* supposed to manipulate the World state somehow, and not do other network communication or something.
11:07:57 <cabbibo> right right right
11:08:17 <Cale> This is sort of one of the advantages of that (MonadState World m) => ... m Result  type
11:08:32 <Cale> (once you throw in MonadIO m, you've given up that advantage though)
11:08:36 * hackagebot typedquery 0.1.0.3 - Parser for SQL augmented with types  https://hackage.haskell.org/package/typedquery-0.1.0.3 (tolysz)
11:09:15 <Cale> But yeah, there's more than one way to abstract over the choice of monad -- sometimes using a record like this provides more potential to implement the operations in interesting ways.
11:09:39 <cabbibo> ok. 
11:09:39 <Cale> and usually even if you were going to use a type class, something more specific would be better than MonadState
11:09:49 <Cale> (at least in my experience)
11:09:53 <cabbibo> ya.
11:10:13 <cabbibo> Def saving this convo so I can reread it a bunch of times and try to understand it more :)
11:10:13 <Cale> MonadState is good because it's already there for a bunch of monads, but it's usually not really ideal
11:11:17 <Cale> Usually you want to pay more attention to the API you're providing and do something a little nicer than just reading/writing a single monolithic state variable.
11:12:13 <Cale> Moving from a type class to a data structure gives you the option to construct an IORef (somewhere near the top level of your application), define the operations in terms of that, and then pass the record of operations down.
11:12:41 <Cale> If you try to use a type class, then it's harder to get an instance for plain IO
11:13:03 <cabbibo> right
11:13:23 <Cale> The other thing you give up the moment that you start using monad transformers is convenience when it comes to higher order things that IO provides, like forkIO for starting a thread, or catch to catch exceptions.
11:13:47 <bollu> how do I use stack without the library (as in, I just want an executable)
11:14:36 <Cale> So usually I'll try to avoid it until I have a really good idea of all the operations that I'll need, and then maybe think about designing some custom monad with carefully selected operations, and an implementation that's hidden by a module boundary
11:15:02 <cabbibo> right
11:15:11 <cabbibo> that def seems like a better construction
11:15:13 <cabbibo> cool.
11:17:42 <cabbibo> Cale : thanks again! I actually gotta go grab some lunch, but your help is so so so appreciated :) :) :)
11:18:18 <Cale> cabbibo: no problem!
11:24:45 <sm> bollu: just download a stack binary ?
11:25:13 <bollu> sm: ah, I'm an idiot :)
11:40:11 <sm> happens to all of us :)
11:46:47 <jle`> nshepperd: do you know if your %+/%* functions are in a library somewhere?
11:47:14 <jle`> a quick cursory search appears that nothing like them are in any hackage utility library but i'm not totally sure how to search
11:47:33 <jle`> if not, then I am thinking of making my own util library with combinators like these :)
11:49:07 * hackagebot clckwrks-plugin-media 0.6.15 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.15 (JeremyShaw)
11:49:09 * hackagebot clckwrks-plugin-page 0.4.2 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.2 (JeremyShaw)
11:49:51 <jle`> um, i wonder if anyone in the channel now would know
11:50:39 <jle`> it's functions like Dict (KnownNat m) -> Dict (KnownNat n) -> Dict (KnownNat (n + m))
11:51:20 <jle`> or in continuation style, (KnownNat m, KnownNat n) => Proxy m -> Proxy n -> (KnownNat (n + m) => r) -> r
12:05:24 <albeit> If I have a map like {1: {"ABC":5, "DEF":6}, 2: {"ABC":13, "DEF":38}}, is "ABC" (ByteString) stored twice, or will it be stored once and just 'pointers' used in the map?
12:07:11 <ReinH> albeit: that depends on how it is constructed, but without some guarantee of sharing (i.e. via the sharing guarantees of laziness) there is no reason to assume that they are shared.
12:08:13 <albeit> ReinH: Thanks. How can I construct it so that sharing is guaranteed?
12:08:34 <ReinH> let abc = ("ABC" :: ByteString) in ...
12:09:55 <albeit> Ah so if I'm parsing a file with lines line "ABC,1,5\nABC,2,13" and adding it to the map line by line, I'm out of luck?
12:09:58 <albeit> *lines like
12:10:16 <ReinH> probably
12:10:39 <albeit> Is there a non-Map but Map-like structure that would work for nested maps that share keys?
12:11:02 <Peaker> You can use "interning" to recover sharing
12:11:02 <ReinH> How do you kow that non-sharing of keys is a problem?
12:11:42 <Peaker> As usual, kmett already did it! http://hackage.haskell.org/package/intern :)
12:12:14 <ReinH> Peaker: of course
12:13:40 <albeit> ReinH: Well, I'm loading two files into maps, and deepseqing them, and the program is using far more memory than I would expect based off rough calcs of the data that is being stored.
12:13:48 <albeit> Peaker: Cool! I'll take a look
12:13:59 <ReinH> deepseqing them seems like a bad idea, but I don't know what you're doing
12:14:37 <albeit> ReinH: Oh, it is, I'm just curious how much space they were taking fully evaluated. It's was just to quick and dirty way to see space usage
12:14:38 <ReinH> But I wouldn't assume that the bytestrings are the problems
12:14:45 <ReinH> have you done any heap profiling?
12:14:54 <albeit> Next step ;)
12:15:09 <ReinH> Ah, shoot first aim second, excellent strategy :D
12:15:15 <Peaker> albeit: how are you measuring memory use?
12:15:52 <albeit> system monitor memory usage! i know i know bad bad
12:16:09 <ReinH> ghc has tools for this
12:16:11 <ReinH> you should use them
12:24:08 * hackagebot syntactic 3.2 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.2 (EmilAxelsson)
12:34:43 <HasUniBerlin> Hello there Haskell friends. I am new to Haskell and i would like to ask you  how  [length [x..y]| x <-"buchstaben", y <- "berg" , x < y] gives this output  [4,17,6,3,16,5,11,2,5,18,7,4,17,6,14,3,5]
12:35:11 <HasUniBerlin> I am little confused i am sorry if this question be little boring for you guys . thank you 
12:35:44 <Rembane> HasUniBerlin: Lets see what a simpler version gives:
12:35:49 <Rembane> > [[x..y]| x <-"buchstaben", y <- "berg" , x < y]
12:35:51 <lambdabot>  ["bcde","bcdefghijklmnopqr","bcdefg","cde","cdefghijklmnopqr","cdefg","hijkl...
12:36:03 <Rembane> > [(x,y)| x <-"buchstaben", y <- "berg" , x < y]
12:36:04 <lambdabot>  [('b','e'),('b','r'),('b','g'),('c','e'),('c','r'),('c','g'),('h','r'),('a',...
12:37:04 <Rembane> HasUniBerlin: The [... | x <- xs, y <- ys] list comprehension will generate all possible variants of xs and ys. Like a for-loop in a for-loop.
12:38:04 <Rembane> HasUniBerlin: Does this make it clearer?
12:38:54 <HasUniBerlin> I am sorry my internet went off
12:39:00 <HasUniBerlin> yes it makes things little clearer
12:40:23 <HasUniBerlin> :) 
12:40:24 <HasUniBerlin> and lamdabot
12:40:24 <HasUniBerlin> yes now i get it thank you very much rembane
12:40:26 <Tehnix> yes now i get it thank you very much rembane
12:40:47 <Rembane> HasUniBerlin, Tehnix: No worries. Good luck! :)
12:41:46 <jamesfordummies> can anyone tell me how to do a non-blocking recv from a Socket? I’d rather avoid forkIO if possible
12:43:19 <albeit> jamesfordummies: For a busy read, which you probably don't want, but might, you'll have to modify some of the Network library yourself.
12:43:42 <Peaker> jamesfordummies: why avoid forkIO? That's how you do a "non-blocking" receive (under the hood)
12:45:10 <jamesfordummies> concurrency tends to disrupt the accuracy of timestamp diff calculations Peaker 
12:45:45 <jamesfordummies> but it’s not a huge issue. previously I have just forked it off, write it to a Chan, and try to read from the chan if possible
12:46:00 <ReinH> jamesfordummies: what sort of timestamp diff calculations are you doing, and for what purpose?
12:46:02 <dmj> jamesfordummies: how does concurrency affect the accuracy of a timestamp diff
12:46:32 <ReinH> Any time anyone says anything involving calculations with clocks, a red flag goes off
12:46:48 <jamesfordummies> it’s for latency testing
12:47:43 <jamesfordummies> correct me if I’m wrong - but if I am timing the RTT of a packet, I don’t want a context switch to occur and make that calculation inaccurate
12:47:44 <jamesfordummies> no?
12:48:47 <albeit> jamesfordummies: What precision do you need the RTT?
12:49:14 <jamesfordummies> order of milliseconds
12:49:22 <albeit> jamesfordummies: I believe a context-switch, such as to get back to a blocking recv, is about 20 microseconds
12:49:36 <jamesfordummies> ok awesome thanks
12:49:42 <jamesfordummies> wasn’t sure how careful i had to be
12:52:58 <Peaker> albeit: a kernel context switch? 20 micros is quite expensive!
12:52:59 <niez> anyone wants to help beginner with snap, postgresql-simple and digestive-functors? :)
12:53:26 <pikajude> shore
12:53:42 <albeit> Peaker: I meant for the Haskell scheduler "context" switch to a waiting thread
12:54:23 <Peaker> albeit: 20 microseconds for a user-land context switch? That's even worse!  The number of cache miss latencies that fit in 20 microseconds is quite a lot!
12:57:02 <Peaker> ~80ns per cache miss, ~250 random serial memory accesses -- that's a lot
12:57:06 <pikajude> niez: what's your question?
12:57:32 <niez> pikajude, here is my data definition: http://lpaste.net/146321
12:58:01 <pikajude> uh huh
12:58:43 <niez> pikajude, and my form should look like this: http://lpaste.net/146322
12:59:31 <niez> pikajude, the problem I have: fields in my data type and my form dont match
13:00:10 <pikajude> so you either need a field for every datatype, or you need to do something like fmap (\ arg1 arg2 arg3 -> PosArea ...) myForm
13:00:10 <niez> pikajude, _id should be generated by db, I wanto _deleted to be always False
13:00:27 <pikajude> iirc ids are generally separate from the actual datatype
13:00:33 <pikajude> what DB layer are you using?
13:00:40 <niez> postgresql-simple
13:00:44 <pikajude> ok
13:01:08 <pikajude> you familiar with the `monadic' function
13:01:15 <pikajude> that's part of digestive-functors
13:01:27 <niez> no, one moment...
13:02:38 <niez> ok, I see it, I have no idea what it is for
13:03:09 <pikajude> it turns m (Form v m a) into Form v m a, and `m' here is your handler context
13:03:48 <pikajude> so you can use monadic to wrap a monadic action that does database access and turn it into a regular Form
13:04:01 <niez> pikajude, my first idea was: add second data contructor to PosArea, something like data PosArea =  PosAreaSaved { } | PosAreaUnsaved { }
13:04:33 <niez> and use PosAreaUnsaved in create form and PosAreaSaved in update form
13:04:38 <pikajude> you could also use digestive-functor's validateM
13:04:48 <pikajude> where you try to insert your record, and return an error if it doesn't work
13:05:03 <pikajude> or checkM
13:07:42 <niez> pikajude, why are you talking about db access in context of forms (and monadic)? 'wrap monadic action that does database access'? I want to insert into db only id my form is valid, before that I don't need db access, do I?
13:08:00 <Black0range> Hey! Using haskells OpenGL Package https://hackage.haskell.org/package/OpenGL how do i make a vertex buffer object?
13:08:03 <pikajude> doesn't your datatype contain an id?
13:08:32 <niez> yes, please wait second...
13:09:14 <niez> pikajude, http://lpaste.net/146324
13:09:26 <pikajude> ok
13:09:31 <pikajude> so where are you going to get that?
13:09:45 <donut2d> I'm trying to install mysql-simple with `stack build`, but it gives me this error while building "pcre-light-0.4.0.4": parsing output of pkg-config --modversion failed
13:09:45 <pikajude> or will you write a form that returns a tuple of all the fields except id, rather than an instance of that datatype?
13:09:49 <niez> pikajude, I have one to one mapping from my db table to data type
13:10:03 <pikajude> so if you're creating a new record, where does the id come from?
13:10:41 <tippenein_> > head ["✓"]
13:10:43 <lambdabot>  "\10003"
13:10:56 <donut2d>     Configuring pcre-light-0.4.0.4...
13:10:56 <donut2d>     setup-Simple-Cabal-1.22.4.0-x86_64-osx-ghc-7.10.2: parsing output of
13:10:56 <donut2d>     pkg-config --modversion failed
13:11:22 <tippenein_> How can I deal with an array of unicode text without mangling it
13:11:39 <niez> pikajude, good question... it type checks form now, I have these functions: http://lpaste.net/146325
13:11:57 <pikajude> ok
13:12:13 <geekosaur> tippenein, don't use show (as lambdabot did there)?
13:12:30 <kadoban> tippenein_: Well, that's a list but it's not mangled. It's just 'show'n in a not very friendly way.
13:13:16 <geekosaur> > text $ head ["✓"]
13:13:16 <tippenein_> kadoban: ah, makes sense. I'm using putStrLn or something to print it in the program
13:13:17 <lambdabot>  ✓
13:13:25 <tippenein_> thanks geekosaur 
13:14:14 <geekosaur> putStrLn shouldn't change it. print (which is putStrLn . show) would
13:14:31 <geekosaur> it may also be relevant what data type you're using (String, Text, ByteString, ???)
13:15:14 <tippenein_> I just changed it to Text, from String
13:16:23 <tippenein_> so, do u recommend importing Data.Text.Internal (text) ?
13:16:46 <pikajude> no, that's from one of the pprint libraries
13:17:34 <geekosaur> right, that "text" is not related to Data.Text, it's from a prettyprinter combinator library
13:17:47 <Welkin> pikajude: is your named based on an orthodox jewish pikachu?
13:17:56 <pikajude> Welkin: you could say that
13:18:05 <pikajude> tippenein_: you could use the `pretty' library
13:18:10 <pikajude> or `ansi-wl-pprint'
13:18:12 <pikajude> there are lots
13:18:46 <Cale> You probably don't want to abuse the fact that pretty has a bad show instance :P
13:19:24 <Cale> It's just something we do with lambdabot because we can't execute IO actions
13:19:31 <pikajude> yeah i usually see people use ansi-wl-pprint
13:19:34 <Cale> If you have putStrLn, you don't need to do that :P
13:19:56 <derekv2> suppose I want to map over a [String], do some I/O, and then get a [(String,String)]... 
13:20:07 <Cale> Ordinarily, you want a Show instance to give you valid Haskell code for the data structure.
13:20:08 <Welkin> derekv2: mapM
13:20:36 <derekv2> trying to do something like mapM (\i -> do; r<-someIoThing i; (i,r)) things
13:20:51 <derekv2> I don't have the syntax quite right or something.
13:21:16 <Cale> derekv2: mapM (\i -> do r <- someIoThing i; return (i,r)) things
13:21:35 <Cale> derekv2: Or   forM things $ \i -> do r <- someIoThing i; return (i,r)
13:22:04 <frontendloader> does a combinator have some sort of relationship with an operator?
13:22:15 <derekv2> Cale: got it! ok works for my simple example, will try it on the real code now
13:22:30 <jle`> frontendloader: both words have informal meanings
13:22:35 <Cale> frontendloader: Which sense of those words do you mean?
13:22:53 <Cale> There are multiple formal usages of the word "operator", and at least one formal and one informal usage of "combinator"
13:22:56 <jle`> operators in haskell are a syntactic construct, i believe
13:23:03 <Welkin> jle`: that is just a theory!
13:23:25 <Welkin> operators are just infix functions
13:23:27 <Cale> frontendloader: But roughly no?
13:23:33 <frontendloader> ok
13:24:20 <jle`> that's like asking if sets are related to basketball
13:24:31 <Cale> heh
13:24:46 <jle`> i mean...under one interpretation of basketball (the finals season), and oen interpretation of sets (a series of 7 games), then yes
13:24:48 <frontendloader> I guess I don't really know what a combinator is then
13:25:02 <jle`> in finals season basketball matches are played in 7-game sets
13:25:09 <Welkin> frontendloader: it's just jargon :D
13:25:19 <Welkin> I just call them all functions
13:25:33 <geekosaur> in noral usage it's just something designed to be combined with other things to build larger components
13:25:35 <dmj> frontendloader: it's a function that takes n functions and returns a new function :) 
13:25:41 <geekosaur> *normal
13:25:52 <Cale> geekosaur: Or a means of combining those things which were meant to be so combined :)
13:25:53 <geekosaur> or which combines other thing (i.e. functions)
13:26:06 <dmj> compose is a simple example of a combinator
13:26:07 <dmj> :t (.)
13:26:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:26:09 <jle`> it does have a formal meaning in the context of 'combinator calculus'
13:26:24 <Cale> dmj: That's the other, more technical sense of combinator :)
13:26:25 <jle`> just like functions have a formal meaning in the context of lambda calculus
13:26:46 <jle`> but the meaning of functions in lambda calculus is pretty different than their meaning in normal english usage
13:26:50 <Cale> In lambda calculus, a combinator is a lambda term with no free variables
13:27:01 <dmj> Cale: yea, the informal use
13:27:14 <Cale> The informal use doesn't have that restriction
13:27:45 <Cale> It would be easier to give an impression of what is meant by a combinator library than to say what a combinator is on its own in that sense
13:29:14 <jle`> one meaning of operator is a vector space homomorphism
13:29:37 <jle`> and functions R -> R are a vector space...so an exmaple of an operator is an (R -> R) -> (R -> R)
13:29:37 <Cale> There's a general approach we like to take in functional programming, of rather than solving one specific problem, instead define a language of problems consisting of simple primitive problems, and means of combining simple problems into more complex ones, in such a way that the solutions to the combined problems are combinations of the solutions to the simple ones.
13:29:56 <jle`> which can be interpreted as "a function from one function to another function"...which sorta matches with some general meaning of 'combinator'
13:30:00 <Cale> Those "means of combining problems" are what we refer to as "combinators" in that setting
13:30:31 <Cale> e.g. We might want to represent languages in such a way that we can then construct parsers from them.
13:31:09 <Cale> and define a library of combinators for constructing parsers -- like Parsec does
13:31:59 <niez> pikajude, here is my table: http://lpaste.net/146326, I want to have all fields in my data type, so I included id also: http://lpaste.net/146321, I have FromRow instance like this: http://lpaste.net/146327, and I can get data with this function: http://lpaste.net/146328
13:32:14 <dmj> parser combinators really are powerful
13:32:25 <Cale> One advantage of such an approach is often that we can produce multiple "solutions" from the same "problem description", or multiple "interpreters" or "compilers" for the same "language"
13:32:46 <Cale> It might not make perfect sense to do so for parser combinators
13:33:40 <niez> pikajude, now I just want to create and insert some data into db using form
13:34:27 <Cale> But e.g. we might have some library for describing cooking recipes, which might have primitive recipes which consist of a single ingredient, and then various operations which can be performed on them, like mixing together, chopping, stirring, etc. and then we might do things like recursively construct a description of how to carry out the recipe in English, or a description of the nutritional content, or an estimate of
13:34:27 <Cale>  the number of people served, and so on.
13:38:44 <dmj> Cale: be wary though, it's easy to stray into burrito analogies with cooking monads
13:38:53 <Cale> heh
13:39:44 <dmj> topping accumulators etc. 
13:40:16 <Cale> Or as another example, we might have a language consisting of primitive geometric objects, and ways of combining and juxtaposing them, and then means of turning those descriptions into an SVG, or drawing them using OpenGL, or Javascript's canvas, etc.
13:40:29 <Cale> (like what the diagrams library does)
13:50:51 <niez> pikajude, anyway, what I insert into db doesn't match with what I get out, I need different data type, additional data constructor (one for insert and one for select) would be good approach?
13:51:09 <happyfeet> i have a string like this: "foo "foo" foo"
13:51:23 <happyfeet> what is the "trick to convert the " to chars?
13:51:44 <jle`> do you want to escape it? like \" ?
13:51:45 <kadoban> > "blah \" blah" -- this ?
13:51:46 <lambdabot>  "blah \" blah"
13:52:01 <jle`> > text "hello \"world\"!"
13:52:03 <lambdabot>  hello "world"!
13:52:11 <Denommus> :t text
13:52:12 <lambdabot> String -> Doc
13:52:35 <happyfeet> thank you all :)
13:52:52 <happyfeet> i was using this /
13:52:55 <happyfeet> not this \
13:53:02 <happyfeet> close :p
13:54:46 <jle`> so close :O
13:55:38 <mwawrzos> Hi! In this guide: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html, section 4.7.2, it is said, that interface file is used in compilation
13:56:23 <mwawrzos> is it possible to compile module A that imports module B when we only have B.o and B.hi files?
14:02:21 <OverCoder> ghci> 5 /= 4  
14:02:32 <OverCoder> What does that even mean? what does the /= operator do?
14:02:41 <Rembane> OverCoder: It's the opposite to ==
14:02:44 <OverCoder> I mean I used it for initialization, not comparison
14:02:44 <Rembane> OverCoder: So, not equal
14:02:49 <cite-reader> It's like != in C derived languages.
14:02:51 <OverCoder> Ah, so it's same as !=
14:03:00 <OverCoder> Ok thanks
14:03:18 <Arahael> I'm contaminated by python, so given that /= is possible, I assume it means x /= y is equivalent to x = x / y
14:04:02 <cite-reader> Haskell doesn't have assignment in that way, of course.
14:06:02 <t7> mutable variables, gross
14:06:10 <jle`> i wonder why it's called "ConstraintKinds"
14:06:54 <mniip> :k (~)
14:06:56 <lambdabot> k -> k -> Constraint
14:06:57 <mniip> jle`, ^
14:07:30 <t7> :k * ~ *
14:07:31 <jle`> yes but why Kinds with an s
14:07:32 <lambdabot> parse error on input ‘*’
14:07:38 <jle`> doesn't it just introduce one Kind?
14:07:48 <t7> :k (~) (*) (*)
14:07:49 <lambdabot> Not in scope: type constructor or class ‘*’
14:07:49 <lambdabot> Not in scope: type constructor or class ‘*’
14:07:57 <jle`> that is, Constraint?
14:07:57 <t7> :k (~) (->)
14:07:59 <lambdabot> (* -> * -> *) -> Constraint
14:12:20 <albeit> I'm populating a Map Timestamp (Map ByteString Int64), where Timestamp ~:: (Int, Int, Int). Doing a calc of memory usage of all the components, it should be about 46MB. The heap profiler is showing it using almost 300MB (with -hy, in Map, ByteString, and Int64 all exploding). The map is deepseq'd. Why is my heap usage so much? 
14:21:07 <geekosaur> are you accounting for constructors and boxing? I think that (Int,Int,Int) works out to, hm, 32+3*16=80 bytes
14:21:31 <HasUniBerlin> On the examination which i gave recently there was a question where i had to find the type of the following : let g x y z = foldr (+) x [length s | s <- y , head s < length z] i made a mistake because of course in the exam i couldnot give :t function . Is there any good read on types ? because i cannot find the best and easy explanation to haskell types
14:22:14 <mauke> types are Intuitively Obvious™
14:22:39 <HasUniBerlin> hello mauke .. thank you for answering ..i am really confused in finding the types
14:22:53 <HasUniBerlin> for example i still dont know the answer to the function i gave earlier
14:23:03 <mauke> step 1 is looking at all the known types
14:23:11 <HasUniBerlin> and i didnot want to use :t to understand it first
14:23:14 <HasUniBerlin> okay 
14:23:38 <Denommus> does lambdabot have a "seen" command or something?
14:23:40 <mauke> for example, foldr :: (a -> b -> b) -> b -> [a] -> b
14:23:47 <mauke> length :: [a] -> Int
14:23:51 <Denommus> I want to know when a user was online
14:23:52 <mauke> head :: [a] -> a
14:23:57 <HasUniBerlin> yes 
14:24:02 <mauke> (+) :: (Num a) => a -> a -> a
14:24:39 <mauke> then you have to know that 'let g x y z = ...' is syntactic sugar for 'let g = \x y z -> ...'
14:24:54 <HasUniBerlin> yes 
14:24:55 <mauke> so the type of g has to be something of the form a -> b -> c -> d
14:25:17 <mauke> oh, I forgot about (<) :: (Ord a) => a -> a -> Bool
14:25:20 <jle`> hi all
14:25:27 <jle`> why would I want to use Proxy over Proxy# ?
14:25:43 <mauke> finally, for list comprehensions, ... hmm
14:25:50 <HasUniBerlin> yes mauke i am following you
14:25:56 <HasUniBerlin> thank you so much for this
14:26:10 <mauke> if x :: a, then [ x | ... ] :: [a]
14:26:30 <albeit> geekosaur: It's actually :: Timestamp Integer !Int !Int. I have -02 and -funbox-strict-fields. What do you mean by constructors?
14:26:40 <mauke> for each generator expression x <- y on the right hand side, y :: [a] and x :: a
14:26:48 <albeit> geekosaur: Should deepseq be fully evaluation everything, so there are no thunks?
14:26:51 <mauke> that is, y must be a list and x a list element
14:27:05 <mauke> and the other expressions must be all boolean
14:27:17 <HasUniBerlin> yes
14:27:36 <mauke> wow, that's a lot of type variables. my next step would be renaming them to make sure they're all unique and I don't get confused
14:27:47 <HasUniBerlin> yes 
14:27:58 <HasUniBerlin> it is quite confusing yes
14:28:05 * mauke opens a text editor
14:29:27 <geekosaur> albeit, every algebraic type includes a constructor tag. for a simple type like Int it will always be 0. for tuples, I think it corresponds to the size of the tuple? for Either it will be 0 for Left and 1 for Right
14:31:38 <mauke> HasUniBerlin: http://lpaste.net/146331 I think that's all the rules I've mentioned so far, with unique type variables
14:32:44 <mauke> oh, I forgot an important (meta) rule: if you have f x, then f :: a -> b, x :: a, f x :: b (for some types a, b, c)
14:32:49 <geekosaur> which is where I got the 32+3*16: tuple constructor tag + 3 pointers, each pointing to a constructor tag plus an Int64#. yes, if you have unboxed then this will be smaller
14:32:52 <HasUniBerlin> omg :O
14:32:59 <HasUniBerlin> haha i am getting confused 
14:33:06 <HasUniBerlin> thanking you so much !
14:33:33 <mauke> HasUniBerlin: confused where? my paste or what I just said?
14:33:46 <geekosaur> there will likely be similar metadata "wastage" in the ways a Map is built
14:33:52 <HasUniBerlin> the one you said 
14:34:02 <HasUniBerlin> f x, then f :: a -> b, x :: a, f x :: b (for some types a, b, c)
14:34:12 <mauke> well, f x is function application
14:34:18 <mauke> the function f is applied to an argument x
14:34:23 <HasUniBerlin> yes  i understand that
14:34:29 <HasUniBerlin> oh i am sorry
14:34:30 <mauke> in that case f must have a function type (a -> b)
14:34:31 <HasUniBerlin> now i get it
14:34:34 <HasUniBerlin> thank you :)
14:34:45 <mauke> :-)
14:35:33 <albeit> geekosaur: I was expecting some "wastage", but 5x the size of the actual data seems extreme
14:36:19 <geekosaur> I am not in a position to explain that as I don't off the top of my head know how either Data.Map or ByteString deals with allocation
14:36:38 <geekosaur> and boxing
14:45:14 <Denommus> how to use lambdabot's @unmtl?
14:46:38 <geekosaur> @unmtl StateT Int (ReaderT String IO) a
14:46:38 <lambdabot> Int -> String -> IO (a, Int)
14:48:40 <geekosaur> basically you feed it an mtl monad stack type and it tells you the type of the equivalent non-mtl function
14:49:49 <geekosaur> (exposing that ReaderT is just a way to supply a parameter automatically to a function, and that StateT does the same but also captures a possibly new value for it from the output tuple
14:50:23 <mauke> HasUniBerlin: I've updated http://lpaste.net/146331 again
14:50:39 <mauke> I realized that I needed two copies of 'length' to be a good type checker
14:50:58 <HasUniBerlin> You made my day sir ! Thank you so much
14:51:10 <HasUniBerlin> i have been reading what you've wrote earlier
14:51:17 <mauke> lines 20ff are basically conclusions which types must be the same from the expressions they appear in
14:51:30 <HasUniBerlin> this one is a jewel thank you
14:54:03 <mauke> well, I hope it helps. it's a bit unstructured
14:55:17 <mauke> but I believe that's essentially what the type checker does: it has built in rules for deriving types for all kinds of expressions that can appear in a program. it applies those to get a huge list of equations
14:55:25 <magbo> Hey, I'm really want to use GHCi to show "slides"
14:55:33 <mauke> and then it just solves them, figuring out which types must be equal to each other
14:56:00 <magbo> So the question is, is there a way to insert control commands such as load into code that is executed in the REPL somehow?
14:56:26 <magbo> I want to inject ^L and :load, but I think that it's theoretically impossible without patching ghci :(
14:57:58 <magbo> In pseudocode, I want to do this:
14:58:00 <magbo> let nextSlide = \x -> do { printSlide x ; ghciMagicalLoader "Slide" ++ (show x) ++ ".hs" ; ghciControlL ; return (x + 1) }
14:58:04 <magbo> and then call it as
14:58:13 <magbo> let x = 1
14:58:21 <magbo> x <- nextSlide x
15:00:29 <geekosaur> you can't call it that way, certainly
15:01:02 <magbo> geekosaur: I wonder if https://hackage.haskell.org/package/plugins-1.5.5.0/docs/System-Plugins-Load.html can help me here somehow 
15:01:22 <magbo> I thought that it's only for GHC plugins, but it mentions Module type...
15:01:25 <geekosaur> you might look at :def butyou wouldn't be able to use it "inline" like that, it would be a :-command
15:01:57 <geekosaur> no, it can't help you, ghci is not based on plugins
15:02:03 <magbo> geekosaur: thank you.
15:02:13 <magbo> Oh, right, :def should be powerful enough
15:02:31 <magbo> I didn't even know we had macros in GHCi, thanks <3
15:03:44 <magbo> Oh no, it wants expr to be a Haskell expression :(
15:03:45 <HasUniBerlin_> @mauke . Thank you very much for explaining it thoroughly . It helped alot !
15:03:45 <lambdabot> Unknown command, try @list
15:04:15 <magbo> Oh no, it feeds IO String back to ghci.
15:04:35 <geekosaur> right, you're basically creating a new command that gets fed to ghci as if it had been typed
15:04:50 <geekosaur> like most macro systems
15:04:54 <magbo> Yep.
15:05:17 <magbo> I won't be able to send ^L though. I couldn't find anything alike in ghci commands.
15:05:18 <geekosaur> and it's in IO so you can do IO things as you build the new command
15:06:24 <magbo> :!clear
15:06:43 <geekosaur> :!clear, or System.Cmd.system "clear", etc
15:06:45 <magbo> Ha! TIL
15:07:05 <geekosaur> if you want to make assumptions, putStr "\033[H\033[J"
15:07:27 <mauke> does that actually work?
15:07:30 <mauke> > "\033"
15:07:33 <lambdabot>  "!"
15:07:37 <mauke> thought so
15:07:38 <geekosaur> sorry, no
15:07:46 <mauke> putStr "\ESC[H\ESC[J"
15:07:48 <geekosaur> that'd be right from the shell or C >.>
15:07:53 <geekosaur> \ESC or \27
15:08:21 <geekosaur> ut (note the nick) I tend to default to octal where Haskell escapes use decimal
15:09:08 <mauke> there's only one place I ever use octal meaningfully and that's chmod
15:09:51 <glguy> > '\o33' -- if you really wanted octal
15:09:52 <lambdabot>  '\ESC'
15:10:10 <mauke> I never want octal (outside of chmod) :-(
15:11:24 <hpc> yeah, how does 0o(octal) get to be a thing and 0b(binary) doesn't
15:12:53 <geekosaur> hysterical raisins?
15:12:56 <glguy> outside of string literals you can use that with :set -XBinaryLiterals 
15:13:21 <glguy> 0b1011 -- 11
15:14:13 <hpc> > 0b1001
15:14:15 <lambdabot>  Not in scope: ‘b1001’
15:14:24 <hpc> oh, extension
15:14:28 <geekosaur> admittedly the main reason unix likes its octal is the predominance of DEC hardware during its development; IBM's use of hex fits modern processors better...
15:23:36 <uli> Hello Haskell Hive mind, I've a question regarding stack and sdl2.
15:24:56 <uli> I'm comfortable with sdl2 in C and Haskell in general, but not with stack. So I think, it should not be hard, so maybe you could help me ...
15:25:21 <t7> what is stack?
15:25:34 <Cale> Stack is a tool similar in nature to cabal install.
15:25:57 <uli> So I did the following: $ stack new sdl2-test && cd sdl2-test && stack build # so far everything is OK
15:27:37 <t7> stack looks awesome
15:27:46 <t7> does it use a shared cache of sorts?
15:28:46 <uli> then i add an "import SDL" to app/Main.hs, and stack build complains ...
15:29:18 <uli> I'll add "sdl2" to sdl2-test.cabal, but the problem remains
15:29:28 <shahn> t7: stack by default sticks to package sets from stackage. As long as you stick to those it caches compiled files in ~/.stack .
15:29:58 <shahn> You can easily add other dependencies that are not in any of the snapshots from stackage, but then you loose caching.
15:30:03 <uli> Shouldn't that be straightforward, as sdl2 seems to be available on stackage? (https://www.stackage.org/package/sdl2)
15:30:15 <kadoban> uli: You haven't actually specified what goes wrong.
15:30:54 <Axman6> uli: do you have the SDL C library installed on your system?
15:30:57 <derekv2> I want to basically search a file for some patterns and replace a sub pattern ... normally I'd use regex's for this.  first time doing this in haskell, suggestions?
15:31:23 <derekv2> I notice there are a large number of regex libraries..
15:31:34 <uli> Yeah, I've installed libsdl2 systemwide (a hello world sdl2 C program works).
15:33:20 <uli> stack build error: http://pastebin.com/qhzau1P2
15:34:04 <Axman6> have you added sdl2 to your .cabal file?
15:34:05 <kadoban> uli: sdl2 package doesn't provide a SDL module. It has a Graphics.UI.SDL module?
15:34:27 <uli> yes, to both the library and executable section
15:34:27 <Axman6> that is probably much more likely to be the problem =)
15:34:57 <Cale> uh, according to the doc on Stackage though, it does provide an SDL module
15:35:31 <geekosaur> not the one I just loaded for sdl2-1.3.1 in LTS
15:35:41 <kadoban> Err, I'm looking at the docs on stackage: http://haddock.stackage.org/lts-3.16/sdl2-1.3.1/index.html
15:35:46 <geekosaur> which iirc is what stack would be using by default
15:36:11 <Axman6> which lts version are you using?
15:37:41 <geekosaur> hm, this is confusing. https://www.stackage.org/lts-3.16/package/sdl2-1.3.1 shows Graphics.UI.SDL but the readme references SDL and SDL.Raw namespaces
15:38:26 <kadoban> That does sound confusing.
15:38:33 <uli> lts-3.15
15:38:38 <uli> sorry
15:38:40 <uli> lts-3.16
15:40:39 <geekosaur> ahhhh
15:40:54 <geekosaur> the SDL namespace is in sdl2-2.x
15:41:02 <geekosaur> which is not in stackage LTS
15:41:32 <kadoban> O.o so the docs are for a totally different version?
15:41:43 <geekosaur> possibly from stackage nightly
15:42:12 * geekosaur looks
15:42:27 <geekosaur> (sadly stuff is loading slowly here... crappy local network)
15:42:32 <kadoban> Well nightly does have 2.1.0
15:42:55 <geekosaur> yep
15:43:14 <kadoban> But that's still odd. The docs for that are different. I wonder if the maintainer just copied and pasted the docs from the new version and didn't notice they don't match?
15:43:15 <geekosaur> so it's showing the readme from 2.1.0 from stackage nightly, but the haddock is correct for stackage lts
15:44:04 <kadoban> Or maybe it's a stackage thing, that seems weird though. Not really sure how to tell where the screwup lies.
15:44:09 <geekosaur> yeh
15:44:12 <uli> Ok, so import Graphics.UI.SDL works :)
15:44:33 * hackagebot wolf 0.2.1 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.1 (markfine)
15:44:59 <geekosaur> you could also change the resolver in stack.yml to point to nightly to get the later version
15:45:14 <geekosaur> or whatever the filename is, whoops
15:45:22 <geekosaur> stack.yaml?
15:46:46 <uli> yeah, thanks it worked with "Graphics.UI.SDL"
15:55:35 <athan> How should SSL-enabled WAI applications allow normal HTTP when the `warp-tls` package doesn't expose it's configuration record syntax? https://hackage.haskell.org/package/warp-tls-3.1.4/docs/Network-Wai-Handler-WarpTLS.html#v:onInsecure
15:58:10 <rmcgibbo> Does anyone have opinions on what are the most popular unit testing frameworks? I'm just getting started with haskell.
15:58:28 <Rembane> rmcgibbo: Have you had a look at Quickcheck?
15:58:51 <Axman6> I'm probably a terrible person,. but I haven't written any tests for haskell code for several years
15:59:19 <geekosaur> athan, aren't they listed under Accessors?
15:59:21 <rmcgibbo> Not quite -- I started using haskeleton to make a project template, and it gives my HSpec
15:59:28 <geekosaur> i.e. not in the usual haddock format but split out
15:59:40 <rmcgibbo> But lit looks like hspec uses QuickCheck somehow, because I see it as a dependency.
15:59:42 <geekosaur> as I read the docs, they're just normal field labels
15:59:58 <geekosaur> "Default TLSSettings. Use this to create TLSSettings with the field record name (aka accessors)."
16:00:24 <dmwit> I have something that is roughly an `IntMap (IntMap a)`. I'd like to set the value at index `(i, j)` to value `v`. What's the lens-y way to do this? I'm looking at C.Lens.At, which has `at :: Int -> Lens' (IntMap a) (Maybe a)`, but my eyes are starting to glaze over trying to work out which operators to use with it.
16:00:57 <athan> geekosaur: agh man I'm sorry about this. I wish it were easy to distinguish a function that's also an accessor
16:01:04 <athan> the type signature always throws me off
16:01:17 <geekosaur> rmcgibbo, hspec is a test framework. QuickCheck is just one of the test types it can handle
16:01:48 <nshepperd> jle`: I haven't heard of these operators existing before
16:01:52 * athan get smacked by Welkin's mackerel before he threw it
16:01:56 <nshepperd> jle`: maybe you should make your library!
16:03:46 <rmcgibbo> okay, looking at quickcheck now
16:06:34 <uli> yeah, it worked out, I got a window :] ... I was just confused by the documentation
16:06:50 <uli> \help
16:07:34 <uli> fasd
16:08:25 <uli> bla
16:08:51 <cite-reader> uli: You okay over there?
16:10:39 <JamesJRH> Hi.
16:11:37 <uli2> Wow, my weechat froze. Anyway thanks for your help, Graphics.UI.SDL solved my problems and I have a window now. :]
16:12:20 <uli2> \help
16:12:45 <JamesJRH> How do I do dynamic software updating in Haskell?
16:12:48 <JamesJRH> https://en.wikipedia.org/wiki/Dynamic_software_updating
16:12:54 <pikajude> DarwinElf: working on kevin
16:13:19 <DarwinElf> ok
16:13:25 <pikajude> finally got some time
16:13:32 <JamesJRH> Surely dynamic software updating should be easier due to being a declarative language, right?
16:13:48 <dmwit> JamesJRH: Possibly use dyre or similar.
16:13:50 <dmwit> ?hackage dyre
16:13:50 <lambdabot> http://hackage.haskell.org/package/dyre
16:14:37 <JamesJRH> Aah, interesting!
16:14:43 <JamesJRH> dmwit: Thanks.
16:14:47 <dmwit> I've only had to write custom state update code once or twice when modifying xmonad; in most cases it was correctly upgraded for me. (And xmonad uses essentially the same strategy as dyre for passing along state.)
16:16:19 <nshepperd> jle`: the Dict method is nice at least since you can do '(a %* b) %+ c' and get a dict for a complex formula like that
16:16:57 <JamesJRH> dmwit: Yes, I use XMonad and I do notice that its <Mod>+q restart feature doesn't seem to lose state.
16:22:13 <Profpatsch> Hm, concerning Coercible:
16:22:16 <Profpatsch> newtype Kilobytes = Kilobytes Integer deriving Eq
16:23:30 <Profpatsch> If I use a Kilobyte in a where clause it throws an „is untouchable“ error.
16:24:05 <Axman6> eh?
16:24:10 <dmwit> Profpatsch: lpaste enough code that we can reproduce it
16:24:14 <dmwit> ?lpaste
16:24:14 <lambdabot> Haskell pastebin: http://lpaste.net/
16:24:43 * hackagebot reedsolomon 0.0.1.2 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.1.2 (NicolasTrangez)
16:25:43 <Profpatsch> dmwit: On it.
16:27:22 <Profpatsch> Hm, now I get a different error. My code might have shadowed that.
16:27:31 <Profpatsch> http://lpaste.net/146335
16:27:47 <Profpatsch> I’m probably using it wrong.
16:28:17 <uli2> btw. I find it slightly confusing that one edites <project>.cabal to add dependencies for a stack package instead of to stack.yaml
16:28:40 <dmwit> Profpatsch: Without testing: `show (coerce f :: Integer)`.
16:29:01 <Profpatsch> dmwit: you are right.
16:29:46 <dmwit> Profpatsch: For the same reason that `show (read "3")` does not work.
16:30:21 <Profpatsch> dmwit: That explains the error I get.
16:30:29 <Profpatsch> If I modify the code like so:
16:30:49 <Profpatsch> http://lpaste.net/146336
16:31:01 <Profpatsch> I get the same “is untouchable” eror.
16:31:04 <Profpatsch> *error
16:31:07 <Profpatsch> Whatever that means.
16:31:40 <Profpatsch> In the line of the where definition.
16:32:18 <Profpatsch> The message is:
16:32:21 <Profpatsch>    Couldn't match representation of type ‘a0’ with that of ‘Integer’
16:32:23 <Profpatsch>       ‘a0’ is untouchable
16:32:30 <Profpatsch> So it does know that it should be an Integer.
16:32:42 <dmwit> Specifically: it knows that Foobar should be an Integer.
16:33:11 <dmwit> It does not know that the result of the call to `coerce` should be Integer (since it could be any other thing that also has `Integer` as a representation).
16:33:13 <Profpatsch> But it’s not smart enough to know that it can convert to the Integer to resolve the type in show.
16:33:54 <dmwit> It knows it *can* convert to `Integer`. It does not know it *should* convert to `Integer` (and I can't imagine a reason for it to be able to know that).
16:33:59 * geekosaur wonders what happens if you instead use a function with a fixed type
16:34:01 <dmwit> The only reason I know it is because you told me so in English.
16:34:20 <Profpatsch> dmwit: Would there be any other sensible conversions?
16:34:20 <dmwit> geekosaur: Then it works; Profpatsch said so above when I suggested the same. =)
16:34:21 <geekosaur> (show :: Integer -> String)
16:34:31 <dmwit> Profpatsch: Yes, any other newtype that wraps `Integer` would work.
16:34:52 <geekosaur> Profpatsch, I don't think typeclass resolution can "reason" about stuff like that
16:34:54 <dmwit> Profpatsch: How should it know that you want `Integer`'s `show` instead of, say, `Dmwit'sGrandNewtype`'s `show`?
16:35:16 <Profpatsch> dmwit: That’s true!
16:36:00 <Profpatsch> So I can use coerce to create some kind of cascade of instances.
16:36:24 <Profpatsch> e.g. MyType, MyTypeShort, MyTypeVerbose
16:37:08 <Profpatsch> instance Show MyType where show = show …
16:37:11 <dmwit> I guess part of the point of `coerce` is that there's no cascade.
16:37:24 <dmwit> Just one conversion step, but it can go between any two types with the same representation.
16:37:55 <dmwit> ?quote type.*system.*imagination
16:37:55 <lambdabot> No quotes match. Abort, Retry, Panic?
16:39:01 <dmwit> coerce is the witness that newtypes are a figment of the type system's imagination.
16:39:03 <Profpatsch> instance Show MyTypeVerbose where show m = (show $ coerce m :: MyType) ++ " I’m verbose"
16:39:46 <dmwit> That type ascription probably doesn't bind the way you want it to. But yes.
16:40:05 <Profpatsch> dmwit: I still haven’t understood the binding rules for inline ::, yes.
16:40:12 <Profpatsch> It’s kind of black magic.
16:40:21 <Profpatsch> I just try parens until it works. :)
16:40:40 <geekosaur> it extends as far as it can
16:40:42 <dmwit> Roughly: it has lower precedence than any part of the term language.
16:40:58 <Profpatsch> Because it’s syntactic it isn’t influenced by $?
16:41:13 <dmwit> That's not the reason, but the conclusion is correct.
16:41:23 <Profpatsch> What’s the reason?
16:41:37 <dmwit> Because it's specified that way. No deep reason.
16:42:34 <dmwit> You could write a Haskell' that had term-language operators with lower precedence than `::`. But I don't see a big reason to want that, either.
16:43:13 <Profpatsch> So the one above binds around show, too.
16:43:27 <dmwit> yup
16:43:49 <Profpatsch> And if I put it at the top of the line it would be the same as annotating the whole function?
16:44:00 <Profpatsch> *end of the line
16:44:42 <dmwit> yep, as long as "the whole function" means "the whole right-hand side of the equation" (which is... not a function)
16:45:08 <dmwit> sorry
16:45:17 <dmwit> I can't help all the pedantry, it's in my blood.
16:45:26 <dmwit> You should hear conversations at holidays.
16:46:35 * geekosaur all too often resembles that....
16:46:54 <sm> lol
16:47:31 <uli2> ... then you found the perfect language
16:48:00 <cite-reader> Agda?
16:48:48 <jle`> nshepperd: yes, that's what I've been using it for
16:49:20 <jle`> nshepperd: you can even drop the parentheses cause associativity :3
16:50:21 <jle`> okay, i'm making it.  but i'm wondering if there is any nicer way i can state it using (:-)
16:50:48 <dmwit> :t \i j v -> at i %~ (Just . (at j %~ const (Just v)) . fromMaybe def)
16:50:49 <lambdabot> (At t, At (IxValue t), Default (IxValue t)) => Index t -> Index (IxValue t) -> IxValue (IxValue t) -> t -> t
16:51:39 <dmwit> It is... not that much prettier than without lenses.
16:53:41 <Profpatsch> dmwit: Thanks for the explanations.
16:54:33 <Profpatsch> dmwit: Why is the right side of the equation not a function?
16:55:43 <rmcgibbo> Has anyone got travis-ci's caching working correctly with cabal?
16:55:52 <dmwit> Profpatsch: Because it's a `String` instead. =)
16:56:37 <Profpatsch> dmwit: Isn’t a Value just a function with no input?
16:57:00 <uli2> couldn't one say, it's a function (with no arg), aka "constant"
16:58:36 <dmwit> Profpatsch: You can make the phrase "a function with no inputs" make sense, I think. But the default interpretation of "function" is "function", not "exists n. function that takes n inputs".
16:58:43 <Profpatsch> and: ℕ \ {0} == ℕ ?
16:59:40 <Profpatsch> dmwit: I think in Haskell it makes sense to call everything a function that can be constructed by (->)
16:59:57 <dmwit> Profpatsch: Please point to the `(->)` in `String`. =)
17:00:16 <Profpatsch> dmwit: Yes, that was a way to say you’re right. :)
17:00:29 <Profpatsch> At least everything is a value.
17:00:53 <Profpatsch> Man, 2am already.
17:05:00 <uli2> Profpatsch: what about your natural numbers statement?
17:05:21 <hackrilege> I'm not sure if your online or check the logs Cale, but I wanted to thank you for your help earlier today. The discussion we had was the exact dialogue within me but with the correct answer firmly identified. So it was perfect! It's hard to remember why each wrong approach fails, I'm much happier now
17:05:35 <Cale> hackrilege: good to hear
17:07:19 <bitemyapp> hackrilege: what was this?
17:07:23 <hackrilege> It's got an interactive visualizer so I hope it's fun enough to run!
17:09:21 <Profpatsch> uli2: The solution is to annotate the coercion.
17:10:24 <hackrilege> bitemyapp helishness in inheritance. Basically I was grumbling about first encountering proxy types and refusing to bite the bullet and change the type of the methods my class provides. Unfortunately, it's the only viable option, but knowing that is exactly what I need to move forward, and I'd basically thought so much about having to accept that approach that I knew hope I'd have to do it
17:10:48 <hackrilege> How, not hope
17:13:26 <hackrilege> And I was kind of frustrated do I think I was hard to help because I was presenting all these crazy unviable things
17:13:35 <hackrilege> So thanks
17:14:20 <glguy> > (\i j -> set (at i . non def . at j . non def)) 10 20 30 M.empty :: M.Map Int (M.Map Int Int)
17:14:22 <lambdabot>  fromList [(10,fromList [(20,30)])]
17:16:18 <hackrilege> What is that glguy?
17:16:54 <glguy> example lens code that does something similar to what dmwit pasted above
17:18:02 <hackrilege> Oh I didn't see that. I don't quite get how it is taking the third argument to the lambda expression
17:18:23 <uli2> Profpatsch: I was not sure what you meant, but yeah, I consider 0 ∈ ℕ ...
17:18:51 <Profpatsch> uli2: Some people disagree. :)
17:19:12 <Profpatsch> Like whether a constant is a function.
17:19:17 <cite-reader>  0
17:19:19 <hackrilege> It is, they call the positive numbers without 0 N+
17:19:59 <uli2> I also heard there are people who prefer to start counting at 1 ... I can not imagine that.
17:20:39 <Profpatsch> If I remember correctly, my maths prof called ℕ+ ℕ and the ℕ w/ 0 ℕ*
17:21:15 <hackrilege> Ah sorry, that's probably it yeah
17:21:33 <hackrilege> Oh I see the disagreement, lol
17:22:01 <hackrilege> Why does it matter?
17:22:37 <Profpatsch> hackrilege: It doesn’t really. It’s like syntax bikeshedding but with semantics.
17:22:38 <bitemyapp> wait what
17:22:48 <Profpatsch> *except with
17:22:56 <hackrilege> :t def
17:22:57 <lambdabot> Default a => a
17:22:58 <bitemyapp> Profpatsch: the disagreement is whether (0 :: Int) is a function or not?
17:23:24 <Profpatsch> bitemyapp: Yeah, or any value.
17:23:32 <bitemyapp> they are not functions
17:23:33 <zoku> :browse
17:23:41 <bitemyapp> all functions (in Haskell) are values, not all values are functions.
17:23:48 <hackrilege> Lol zoku
17:23:59 <hackrilege> :t non
17:24:00 <lambdabot> (Eq a, Functor f, Profunctor p) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
17:24:11 <Profpatsch> bitemyapp: As I said, I’d call anything constructed by (->) a function.
17:24:17 <bitemyapp> You need, at minimum, a (->) in the type to call it a function. => is arguable but I lean towards no given that we're writing Haskell and not Core.
17:24:28 <bitemyapp> Profpatsch: I'm not sure what that sentence is supposed to mean.
17:24:36 <bitemyapp> Profpatsch: it's either a value or it's not.
17:24:46 <Profpatsch> But it’s still bikeshedding imho. :)
17:24:51 <bitemyapp> it's really not
17:24:54 <bitemyapp> it's a pretty clear issue.
17:25:05 <Profpatsch> Well, (->) is the function constructor after all.
17:25:19 <bitemyapp> yes, and things that have it in their type are functions.
17:25:26 <bitemyapp> (1 :: Int) is not a function.
17:25:35 <Profpatsch> But is it defined anywhere that we have to call stuff constructed by (->) a function?
17:25:45 <bitemyapp> (1 + 1) :: Int is also not a function if we're talking about the whole thing.
17:25:56 <bitemyapp> (+) is a function, the result of applying both of its arguments is not a function.
17:26:05 <Profpatsch> bitemyapp: Why not?
17:26:07 <bitemyapp> if you could never get a value out of applying a function, we wouldn't have any values
17:26:19 <bitemyapp> we'd just have infinite regressions of useless (->)'s
17:26:26 <hackrilege> (\ _ -> 1)
17:26:29 <bitemyapp> that is itself, a type error. You've probably gotten it before.
17:26:32 <uli2> It just depends on the definition of "function".
17:26:33 <Profpatsch> Isn’t (\x -> x + 1) a value?
17:26:38 <bitemyapp> I already explained this
17:26:45 <bitemyapp> all functions are values, not all values are functions.
17:27:09 <bitemyapp> uli2: there's no debate on what "function" means
17:27:09 <Profpatsch> you just said “if you could never get a value out of applying a function, we wouldn't have any values” :)
17:27:32 <Profpatsch> Since functions are values, you can always get a value out of a function. :P
17:27:41 <hackrilege> Functions can take any number of arguments
17:27:48 <bitemyapp> finitely so.
17:28:00 <hackrilege> No they take only one
17:28:04 <uli2> probably specific to Haskell, but in Math you could argue that you have special functions with arity 0 that we call constants/values
17:28:06 <Profpatsch> hehe
17:28:10 <bitemyapp> hackrilege: they do, but that's not my point.
17:28:21 <bitemyapp> hackrilege: my point is that the series of (->) curried together has to be finite.
17:28:34 <Profpatsch> Hm, does it?
17:28:44 <bitemyapp> yes, I already said that was a type error you've gotten before
17:29:19 <hackrilege> A function is not a value unless it's arguments are provided
17:29:39 <Profpatsch> meh x = x x
17:29:55 <geekosaur> mm? (1+) is a perfectly valid value, one you might pass to, say, map
17:30:02 <bitemyapp> geekosaur: please don't
17:30:10 <bitemyapp> geekosaur: that's already been explained
17:30:11 <hackrilege> ?
17:30:17 <bitemyapp> geekosaur: the point is that not everything is a function
17:30:19 <Profpatsch> :t \x -> x x
17:30:21 <lambdabot>     Occurs check: cannot construct the infinite type: r1 ~ r1 -> r
17:30:21 <lambdabot>     Relevant bindings include x :: r1 -> r (bound at <interactive>:1:2)
17:30:21 <lambdabot>     In the first argument of ‘x’, namely ‘x’
17:30:26 <bitemyapp> geekosaur: check the backlog to see what I mean
17:30:50 <Profpatsch> Functions are only special for evaluation me thinks.
17:31:00 <geekosaur> then it doesn't seem to have been effective...
17:31:05 <hackrilege> That certainly makes no sense
17:31:08 <Profpatsch> In a math-y universe, the infinite type should be no problem.
17:31:29 <bitemyapp> geekosaur: intransigence is stronger than any one individual's explanatory abilities and IRC makes everything harder.
17:31:33 <Profpatsch> Oh, what wonderful bikeshedding I have induced.
17:31:37 <hackrilege> It's computer not math
17:31:42 <bitemyapp> but hey, this is a great reminder to go back to doing something productive
17:31:44 <bitemyapp> like writing the book
17:31:51 <Profpatsch> bitemyapp: +1
17:32:08 <bitemyapp> one or two confused persons is not bikeshedding
17:32:27 <Profpatsch> bitemyapp: I agree with you, of course, concerning Haskell nomenclature.
17:32:43 <Profpatsch> Since you have to treat -> special in computing.
17:33:06 <Profpatsch> As demonstrated by
17:33:11 <Profpatsch> :t \x -> x x
17:33:12 <lambdabot>     Occurs check: cannot construct the infinite type: r1 ~ r1 -> r
17:33:12 <lambdabot>     Relevant bindings include x :: r1 -> r (bound at <interactive>:1:2)
17:33:12 <lambdabot>     In the first argument of ‘x’, namely ‘x’
17:33:40 <hackrilege> Why would you want an infinite type?
17:33:55 <hackrilege> That's like the most broken thing ever
17:34:21 <hackrilege> What's Fix?
17:34:41 <Profpatsch> hackrilege: Well, it’s simply an infinite type consisting of (->)s chained together.
17:35:12 <hackrilege> Oh dear now I'm confused
17:35:34 <hackrilege> (bitemyapp) hackrilege: my point is that the series of (->) curried together has to be finite.
17:36:01 <hackrilege> I am genuinely distressed
17:36:04 <Profpatsch> Yep, that’s why ghc doesn’t accept the thing above, me thinks.
17:36:33 <hackrilege> I must understand Fix post haste
17:36:34 <Profpatsch> Although it would make sense in a mathematical thought experiment.
17:37:02 <hackrilege> It's just trying to spot a big for you
17:37:07 <hackrilege> Bug
17:37:41 <Profpatsch> hackrilege: Nah, I wouldn’t try to use that … I think.
17:37:45 <hackrilege> It would break everything everywhere all the time if it was allowed
17:38:03 <hackrilege> So I guess you use Fix
17:38:23 <hackrilege> Which I would like to do, can I see it in use?
17:38:55 <Profpatsch> hackrilege: Ah, I’m sorry, I was thinking about something else.
17:39:03 <Profpatsch> You mean Control.Monad.Fix?
17:39:28 <hackrilege> Yeah, isn't that the same as what you meant?
17:39:35 <Profpatsch> I have barely understood the function fix, so I’m not the right person to ask. :)
17:39:51 <Profpatsch> hackrilege: Nah, my mumbling was still about the function vs value thing.
17:39:59 <hackrilege> Hmm, but I think it might be what you are after with your infinite types
17:40:46 <hackrilege> And it's personally something I need to learn about so I thought it might have been relevant
17:40:47 <Profpatsch> hackrilege: Hm, but a fixpoint should converge to be of user.
17:40:49 <Profpatsch> *use
17:41:05 <Profpatsch> If it does not terminate, it’s not very useful. :)
17:41:08 <hackrilege> And your infinite type shouldn't!?
17:42:10 <hackrilege> Can't we use fix to get your infinite recursion through the compiler?
17:42:31 <hackrilege> Oh, no it had no fix point
17:43:06 <hackrilege> Yeah, what you want I'd of no use even in maths
17:43:09 <hackrilege> Is
17:43:44 <hackrilege> Except for breaking programming languages
17:46:11 <hackrilege> Dangerously pointless, I'm sorry I got involved
17:47:09 <hackrilege> Can anyone show me Fix in use?
17:47:52 <bitemyapp> hackrilege: I think the Haskell dialect/derivative at dons/augustss' bank has recursion only via fix
17:48:00 <bitemyapp> hackrilege: to prevent traders doing something dumb, supposedly.
17:48:40 <hackrilege> That's almost what I meant, using lambdabot
17:49:16 <hackrilege> Cool though
17:49:23 <bitemyapp> hackrilege: it's kinda neat to think about though
17:49:32 <bitemyapp> hackrilege: it means all uses of recursion are now trivially greppable.
17:49:33 <hackrilege> Limits recursion heavily....
17:49:38 <derekv2> applyForeach myFun inputsToUse = (foldr (\x f-> (f . x) ) id $ myFun <$> inputsToUse) 
17:49:39 <bitemyapp> hackrilege: Cf. Explicit Codata in Agda
17:49:47 <derekv2> I'm having fun.
17:50:47 <hackrilege> There are many recursion relations not best expressed using fix
17:51:04 <hackrilege> They should be ordered
17:51:56 <hackrilege> Fix would be the most simple
17:52:00 <hackrilege> No?
17:52:54 <hackrilege> Maybe I don't know what trivially grepable means
17:53:07 <hackrilege> Nvm
17:53:26 <hackrilege> I'd still like to see Fix in use...
17:56:35 <derekv2> :t foldr (flip (.)) id 
17:56:37 <lambdabot> Foldable t => t (c -> c) -> c -> c
17:59:01 <derekv2> I feel like this is a useful construct.  But there is nothing in hoogle matching it.  So I wonder if there must be some more general way to accomplish it.
17:59:35 <hackrilege> :t sequence
17:59:36 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
17:59:44 <hackrilege> Oops
17:59:55 <derekv2> hackrilege: actually I found that, its similar but gives a different output
18:00:17 <hackrilege> Yeah
18:00:56 <hackrilege> :t foldrM_
18:00:57 <lambdabot>     Not in scope: ‘foldrM_’
18:00:57 <lambdabot>     Perhaps you meant one of these:
18:00:57 <lambdabot>       ‘foldM_’ (imported from Control.Monad.Writer),
18:01:28 <hackrilege> :t foldM
18:01:29 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
18:01:57 <hackrilege> :t traverse
18:01:58 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:02:08 <hackrilege> I have no idea
18:04:27 <Hijiri> :t fold
18:04:28 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:04:38 <Hijiri> with (Endo c) as the Monoid
18:04:40 <Hijiri> derekv2: ^
18:04:51 <Hijiri> you will have to do some wrapping/unwrapping though
18:04:56 <hackrilege> I guess it's redundant syntax?
18:05:02 <uli2> :t foldr
18:05:04 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:05:47 <hackrilege> Hi Hijiri, could you show me?
18:06:03 <hackrilege> I'd love to see that
18:06:13 <derekv2> I don't know Endo yet.
18:06:21 <Hijiri> Endo a is a wrapper around (a -> a)
18:06:32 <derekv2> It is impossible for me, I don't get Endo untill level 4
18:06:35 <Hijiri> it has a monoid instance where you compose them
18:06:35 <derekv2> =P
18:07:14 <Hijiri> > appEndo (foldMap Endo [(+1), (*2)]) 2
18:07:16 <lambdabot>  5
18:07:23 <Hijiri> :t foldMap Endo
18:07:24 <lambdabot> Foldable t => t (a -> a) -> Endo a
18:07:37 <hackrilege> Nice screenshot taken
18:07:59 <hackrilege> Thanks
18:09:00 <hackrilege> Can you do it with foldM or traverse?
18:10:26 <derekv2> Hijiri: hackrilege: it works 
18:10:42 <hackrilege> Yeah!
18:11:50 <derekv2> I mean, what he did, worked for my case... appEndo (foldMap Endo (patternReplacer <$> nameValues)) "test string"
18:14:25 <derekv2> love it, not sure if its any more readable though.
18:14:39 <uli>   
18:14:48 * hackagebot foscam-sort 0.0.1 - Foscam File format  https://hackage.haskell.org/package/foscam-sort-0.0.1 (TonyMorris)
18:14:52 <hackrilege> Yours is the most readable, the others are it in use elsewhere
18:15:23 <hackrilege> What do you call it?
18:15:47 <derekv2> me?
18:15:57 <hackrilege> Fold flip dot id?
18:16:14 <hackrilege> Yes, if it had no synonym
18:16:21 <derekv2> applyForEach maybe?
18:16:30 <derekv2> nah... 
18:16:46 <derekv2> chain something
18:18:04 <hackrilege> I can't believe it's not in applicative
18:18:46 <dmwit> :t ala Endo foldMap
18:18:48 <lambdabot> Foldable t => t (a -> a) -> a -> a
18:19:04 <hackrilege> Yes!!!!!!
18:19:20 <derekv2> chain f xs = foldr (flip .) id $ f <$> xs   -- chain successive applications of f across xs 
18:19:28 <hackrilege> It even sounds informative
18:20:11 <hackrilege> Yeah with the fmap you're totally foldMaping
18:20:56 <jle`> derekv2: btw, foldr (.) id makes a bit more sense than foldr (flip (.)) id in a haskell context
18:21:22 <hackrilege> :t ala
18:21:23 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
18:21:28 <jle`> derekv2: if chain = foldr (.) id, then chain [f,g,h] x = f (g (h x))
18:21:28 <hackrilege> Nooooo
18:21:41 <hackrilege> Why!? Curses
18:21:44 <jle`> foldr (.) id [f,g,h] = f . g . h
18:21:58 <jle`> nice and sweet :)
18:22:10 <hackrilege> Who broke types?
18:22:15 <derekv2> jle`: see my definition 
18:22:39 <hackrilege> What is ala?
18:22:45 <Profpatsch> Is there a good library to print byte/kB values in a human readable format?
18:22:56 <dmwit> :t \f -> ala Endo (foldMap . (.f))
18:22:58 <lambdabot> Foldable t => (a1 -> a -> a) -> t a1 -> a -> a
18:23:07 <jle`> derekv2: yeah; i'm saying that foldr (.) id makes more sense to have as a generally useful function than foldr (flip (.)) id
18:23:27 <derekv2> jle`: gotchya, let me see if I can get rid of the flip
18:23:37 <dmwit> hackrilege: Nothing broken, that's the actual type of `ala`.
18:23:45 <dmwit> ?hackage newtype
18:23:45 <lambdabot> http://hackage.haskell.org/package/newtype
18:23:48 <hackrilege> It's wrong
18:23:56 <dmwit> Why do you say it's wrong?
18:24:10 <hackrilege> Because I don't like it
18:24:15 <dmwit> heh
18:24:29 <jle`> > foldr (.) id [(*3), (+4), (^2)] 5
18:24:31 <lambdabot>  87
18:24:46 <jle`> > foldr (flip (.)) id [(^2), (+4), (*3)] 5
18:24:48 <lambdabot>  87
18:24:54 <hackrilege> Jle your ordering is more natural I agree
18:25:04 <jle`> derekv2: ^ they just apply the list in reverse order
18:25:16 <jle`> oh i can use the simple reflect...
18:25:22 <jle`> > foldr (.) id [f,g,h] x
18:25:23 <lambdabot>      Ambiguous occurrence ‘x’
18:25:23 <lambdabot>      It could refer to either ‘L.x’,
18:25:23 <lambdabot>                               defined at /tmp/mueval221558440270744729.hs:160:1
18:25:47 <dmwit> I wonder how terrible the world would be if ?let just disappeared.
18:25:57 <jle`> > foldr (.) id [f,g,h] 0 :: Expr
18:25:59 <lambdabot>  f (g (h 0))
18:26:11 <jle`> > foldr (flip (.)) id [f,g,h] 0 :: Expr
18:26:12 <koz_> Is there a way I can refer to a whole record when pattern-matching it? So, for example, if I match on something like Foo {bar = baz} , how can I refer to the whole Foo-type argument?
18:26:13 <lambdabot>  h (g (f 0))
18:26:15 <dmwit> > L.x
18:26:17 <lambdabot>  10
18:26:23 <hackrilege> What is ala doing
18:26:25 <dmwit> ?undefine
18:26:25 <lambdabot> Undefined.
18:26:27 <jle`> thank you, person who defined L.x
18:26:35 <dmwit> > foldr (.) id [f, g, h] x
18:26:36 <lambdabot>  f (g (h x))
18:26:53 <dmwit> koz_: wholeRecord@(Foo {bar = baz})
18:27:09 <uli> Profpatsch: on Linux there's numfmt (for the end user)
18:27:10 <dmwit> koz_: You might even get away without the parentheses, I'm not sure.
18:27:14 <hackrilege> koz try  f@(Foo bar)
18:27:37 <dmwit> hackrilege: ala applies foldMap under a newtype.
18:27:56 <hackrilege> What!? That sucks
18:28:01 <hackrilege> Why!?
18:28:02 <koz_> dmwit: Cool, thanks!
18:28:30 <dmwit> hackrilege: To make a more beautiful spelling of `foldr (.) id`. ;-)
18:29:01 <hackrilege> Huh? You applied foldmap, no I mean generally
18:29:18 <jle`> hackrilege: it uses a typeclass to store newtype wrapper-unwrapper pairs
18:29:32 <jle`> so it basically just automates wrapping-unwrapping
18:29:44 <hackrilege> AHA
18:29:54 <jle`> typeclasses and fancy type families
18:30:19 <dmwit> jle` is telling you the pie-in-the-sky answer. I don't think I've ever succesfully applied `ala` to anything but `foldMap`.
18:30:21 <derekv2> jre2: I'm not immediately able to build my "chain" without the flip.
18:30:26 <hackrilege> That's all lens does!? Makes loss of crazy types that eliminate type constructors and assessors
18:30:42 <geekosaur> I've seen it used with Endo and Sum
18:30:47 <dmwit> `ala` is not from `lens`.
18:31:15 <hackrilege> Who else does these things!?
18:31:17 <Profpatsch> uli: Heh, I could fork a numfmt child and pipe it all the numbers I have for conversion.
18:31:46 <Profpatsch> Since my program is a linux cli utility anyway, that could just work.
18:31:48 <dmwit> ?hackage newtype (which I linked to before, as well)
18:31:48 <lambdabot> http://hackage.haskell.org/package/newtype (which I linked to before, as well)
18:31:51 <Profpatsch> Nice, thanks.
18:32:18 <jle`> derekv2: oh, you wanted foldr (flip .), i see
18:33:51 <jle`> derekv2: hey wait, did you want foo f [x,y,z] = f x (f y (f z)) ?
18:34:11 <jle`> perhaps, foo f k [x,y,z] = f x (f y (f z k)) ?
18:34:18 <hackrilege> Any instance of this class just needs to let packequal to the newtype's constructor, and let unpackdestruct the newtype with pattern matching.
18:34:50 * hackagebot bytestring-arbitrary 0.0.4 - Arbitrary instances for ByteStrings  https://hackage.haskell.org/package/bytestring-arbitrary-0.0.4 (tsuraan)
18:34:55 <jle`> :t \f xs -> foldr (flip .) id $ f <$> xs
18:34:57 <lambdabot> (Functor t, Foldable t) => (a1 -> ((a -> c) -> a -> c) -> a -> (a -> c) -> c) -> t a1 -> (a -> c) -> a -> c
18:35:09 <jle`> (that's what you put earlier, but i don't that's what you want)
18:35:29 <jle`> derekv2: if you want to turn foo f k [x,y,z] into f x (f y (f z k)), then, that's just foldr :)
18:35:48 <jle`> > foldr f 0 [x,y,z] :: Expr
18:35:50 <lambdabot>  f x (f y (f z 0))
18:36:27 <derekv2> did I just implement foldr with foldr?
18:38:10 <uli> Profpatsch: If it's not performance critical I would do it in Haskell with a simple function, calling an external program seems like a headache for that.
18:38:18 <jle`> possibly :)
18:39:47 <hackrilege> Anyone show me Fix in use to handle an infinite type? In an example
18:41:48 <hackrilege> Is that really hard or has no one encountered it before?
18:42:47 <derekv2> :t \f xs -> foldr (flip (.)) id $ f <$> xs
18:42:49 <lambdabot> (Functor t, Foldable t) => (a -> c -> c) -> t a -> c -> c
18:43:12 <derekv2> I forgot the parens around the . earlier
18:43:21 <dmwit> `Fix ((->) a)` is the solution to the infinite type equation `t ~ a -> t`.
18:43:49 <dmwit> Generally, if the you are trying to solve the equation `t ~ f t`, then `Fix f` is a solution.
18:44:28 <geekosaur> hackrilege, in practice (i.e. when not trying to demonstrate lambda calculus) it tends to be used to refer to a function without having to name it, e.g. to make a recursive lambda. which isn't very common and is really something of an advanced usage
18:44:44 <dmwit> Sometimes `f` is not a transformation that fits as an argument to `Fix`; in which case you can usually appease the type system by making it into a newtype.
18:45:08 <bitemyapp> equirecursion vs. isorecursion
18:45:25 <hackrilege> How Is it unlike monad join
18:45:42 <hackrilege> That seems infinite nested type
18:45:56 <nilg> Is there a library for polynomial regression?
18:46:15 <dmwit> Why does it seem like an infinite nested type?
18:46:17 <hackrilege> Regression?
18:46:21 <nilg> (I can't seem to find any in Hackage, outch)
18:46:32 <derekv2> > (\f xs -> foldr (flip (.)) id $ f <$> xs) f [x y z] w :: Expr
18:46:34 <lambdabot>      Couldn't match expected type ‘Expr -> Expr -> ()’
18:46:34 <lambdabot>                  with actual type ‘Expr’
18:46:34 <lambdabot>      The function ‘x’ is applied to two arguments,
18:46:37 <hackrilege> What is regression?
18:46:41 <dmwit> nilg: I think `statistics` does linear regression, which you can populate with polynomial terms.
18:46:46 <derekv2> > (\f xs -> foldr (flip (.)) id $ f <$> xs) f [x, y, z] w :: Expr
18:46:48 <lambdabot>  f z (f y (f x w))
18:46:59 <nilg> hackrilege: yes, given a data set find the fittest polynomial
18:47:14 <dmwit> nilg: By which I mean you can populate the "predictors" matrix with the result of evaluating some polynomial on your actual predictor.
18:47:22 <hackrilege> Try linear algebra packages
18:47:29 <derekv2> jle`: weird, its very close to foldr but it's not =]
18:47:43 <hackrilege> It sounds like minimization would be a better term to use
18:47:44 <dmwit> nilg: http://hackage.haskell.org/package/statistics-0.13.2.3/docs/Statistics-Regression.html
18:47:52 <nilg> dmwit: thanks!
18:47:53 <dmwit> hackrilege: regression is a standard term
18:47:59 <hackrilege> You might look into the calculus of variations
18:48:07 <hackrilege> It's a narrow term
18:48:12 <jle`> > foldl f w [x,y,z]
18:48:14 <lambdabot>  f (f (f w x) y) z
18:48:31 <hackrilege> You can do it in many ways, there are suitable packages you will not find under that name
18:48:42 <jle`> derekv2: you just have foldr, but your list is reversed :)
18:48:54 <jle`> derekv2: or you have foldr, but your function is flipped
18:48:56 <jle`> *foldl
18:49:03 <lpaste> dmwit pasted “polynomial regression” at http://lpaste.net/146343
18:49:18 <dmwit> nilg: An example application I threw together for some experiments here is above.
18:49:24 <dmwit> nilg: Mostly undocumented, but ask me whatever.
18:49:29 <hackrilege> How is Monte Carlo not regression?
18:49:35 <koz_> Is there a Haskell library for arrays (or lists - sequential structures basically) that have types parametrized on their length?
18:50:17 <dmwit> nilg: For example, `./Main --xfun 3 --xfun 2 --xfun 1 foo.txt` should produce a best-fit cubic for the data in foo.txt.
18:50:41 <hackrilege> I have only seen the term regression used by people not used to minimising all manner of things. My preferred way is conjugate gradient which is firmly linear algebra
18:51:10 <jle`> koz_: there are a bunch of them on hackage
18:51:11 <dmwit> koz_: HList, sort of
18:51:33 <jle`> koz_: the one i use is V from the linear library, which wraps a vector from the vector library
18:51:35 <jle`> it's served me pretty well
18:51:42 <hackrilege> Bounded?
18:52:00 <zoku> hmm, i'm having a little trouble with ByteStrings and Network.IRC
18:52:11 <koz_> dmwit: I'll check out HList. jle` : It's just called 'V'?
18:52:13 <jle`> there are also others that implement length-indexed "lists" (analogous to [], too)
18:52:17 <zoku> Channel is defined as
18:52:19 <zoku> type Channel = ByteString
18:52:30 <jle`> koz_: it's in the linear library; in the module Linear.V
18:52:30 <zoku> :t joinChan
18:52:30 <zoku> joinChan :: Channel -> Message
18:52:31 <lambdabot> Not in scope: ‘joinChan’
18:52:44 <jle`> koz_: for example, a `V 10 Double` is a vector of 10 Double's
18:53:04 <jle`> fmap :: (a -> b) -> V n a -> V n b      -- fmap comes with a proof that the length is unchanged
18:53:10 <hackrilege> Am I incorrect to think that conjugate gradient has use in regression?
18:53:25 <zoku> whoops sorry, nevermind
18:53:29 <zoku> i sorted it
18:53:32 <jle`> small caveat is that linear depends on lens, which not everyone is willing to pull the entirety of into their project
18:53:56 <koz_> jle`: I searched Linear.V on Hoogle, but it doesn't come up with anything relevant.
18:54:24 <hackrilege> It's there more to lens than fmap?
18:54:35 <geekosaur> hoogle doesn't index everything
18:54:44 <jle`> look up the package "linear"
18:54:48 <geekosaur> (at the moment "everything" is too big for it)
18:54:49 <jle`> @hackage linear
18:54:49 <lambdabot> http://hackage.haskell.org/package/linear
18:55:00 <koz_> Ah, thanks.
18:55:08 <geekosaur> hayoo is better for that
18:55:59 * koz_ will use Hayoo then.
18:57:14 <derekv2> jle`: confirmed.  I'm lost in my own house.
19:05:15 <derekv2>   so the trick is that I was stuck thinking that I should use foldr like, foldr f someBaseValue dataToProcess... but in this case I wanted foldr f dataToProcess inputsToF
19:06:34 <derekv2> afk food time
19:08:02 <koz_> Is there a more elegant way I can rewrite this? http://paste.rel4tion.org/150 (assume admitRec is defined later).
19:11:01 <uli> :t (\a b c -> a c b) . foldr
19:11:02 <lambdabot> Foldable t => (a -> b -> b) -> t a -> b -> b
19:11:49 <kadoban> koz_: You could remove the 'if' part and move that to a guard on the case pattern match there.
19:13:31 <koz_> kadoban: What would that look like, sorry?
19:19:13 <kadoban> koz_: http://paste.rel4tion.org/150 soemthing like that, the annotation (didn't test)
19:21:53 <koz_> kadoban: I had no idea you could write cases like that. Awesome, thanks!
19:23:42 <kadoban> 'welcome
19:33:49 <laudiacay> hey how could i decompile an ELF LSB 32-bit executable that I know was compiled from haskell by GHC?
19:35:54 <uli> $ objdump -d <binary> # however, that is not Haskell specific
19:37:00 <laudiacay> okay
19:37:26 <ttt_fff> head $ flip filter [0 ..] $ \x -> ghc x == given_binary ## lazy man's haskell decompiler
19:37:40 <laudiacay> wait, what?
19:38:10 <ttt_fff> [0 ..] enumerates all possible program source strings
19:38:18 <ttt_fff> ghc x compiles it and checks if it's == to given_binary
19:38:32 <ttt_fff> the filter lines only outputs x s.t. ghc x == given_binary
19:38:37 <ttt_fff> and the head takes the first such program
19:38:37 <laudiacay> wouldnt that be hella slow
19:38:49 <laudiacay> literally brute forcing the code
19:39:13 <ttt_fff> I think it's exponential time.
19:39:18 <laudiacay> oh wait lol
19:39:24 <laudiacay> thats gotta be a joke nm
19:39:31 <ttt_fff> yeah, it's a joke :-)
19:40:36 <uli> what's your use case? do have to reverse-engineer a 32-bit application?
19:40:43 <laudiacay> uli: yeah :(
19:41:12 <hackrilege> Ffi
19:41:17 <uli> is it stripped?
19:41:29 <laudiacay> i have no clue yet
19:41:31 <laudiacay> brb
19:41:58 <uli> $ file /path/to/exe # will list "stripped", if it's stripped
19:42:07 <laudiacay> oh ok
19:42:10 <laudiacay> lemme try something
19:42:11 <uli> which would be bad for you ;)
19:42:34 <laudiacay> not stripped
19:42:44 <laudiacay> ELF 32-bit LSB executable
19:42:48 <uli> that's good
19:42:53 <laudiacay> it will not freaking run
19:43:06 <uli> what's the error
19:43:17 <laudiacay> well like im in the directory right
19:43:21 <laudiacay> ./filename
19:43:28 <laudiacay> bash permission denied
19:43:35 <uli> chmod u+x filename
19:43:39 <laudiacay> huh
19:43:42 <laudiacay> i suck at computer
19:44:02 <laudiacay> oh hello
19:45:56 <laudiacay> uli: so running it just
19:46:03 <laudiacay> not helpful
19:46:09 <laudiacay> but how would i get the source
19:47:19 <uli> getting the exact source that produced the executable is impossible from the executable alone
19:48:10 <uli> what problem do you want to solve?
19:48:59 <laudiacay> uli: i wanna know what it does i guess
19:49:07 <hackrilege> What is the Haskell specific content of this?
19:49:32 <jle`> yeah, if you want to know what a program does, decompiling it might be the least helpful way of figuring it out, heh
19:49:41 <jle`> well, there are probably less helpful ways still
19:49:56 <laudiacay> its haskell apparently
19:50:06 <hackrilege> Sorry?
19:50:19 <laudiacay> im going to hand this one off to a friend then come back when i know what this binary is doing
19:50:31 <jle`> you're not going to be able to go from executable to the original source code...or anything remotely resembling it.  even if there was a way, you're going to be staring at something difficult to piece together if you don't even know what the program does in the first place
19:50:38 <uli> laudiacay: no that is not Haskell specific
19:51:13 <jle`> laudiacay: any sort of viable decompiling wouldn't help you figure out what it's doing, probably :(
19:51:28 <laudiacay> uli: apparently figuring out this bnary has something to do with the way GHC works but
19:51:37 <laudiacay> i have no idea what im doing with this binary
19:51:44 * laudiacay hands it to more capable friends
19:51:45 <uli> laudiacay: anyway, although not Haskell specific and I'm nor sure what you are trying to achieve, I found the following useful:
19:52:01 <jle`> laudiacay: if that's the case, like i said, decompiling it will probably not help at all ;)
19:52:04 <uli> $ ltrace /path/to/exe # trace all shared library calls
19:52:13 <laudiacay> okay
19:52:15 <uli> $ strace /path/to/exe # trace all syscalls
19:52:17 <laudiacay> ill take a look
19:52:22 <laudiacay> thank you all
19:52:24 <jle`> :'(
19:52:25 <uli> $ strings /path/to/exe # print all strings
19:53:38 <aweinstock> laudiacay: are you familiar with assembly/reverse engineering in the context of memory corruption exploitation?
19:53:42 <hackrilege> Run it on a emulated chip
19:53:44 <laudiacay> aweinstock: nope
19:54:33 <laudiacay> my understanding of CS topics is very good on the mathematical/algorithmic side of things
19:54:43 <laudiacay> and i can't operate linux the other half of the time
19:54:49 <lambdafan> read s = either error id (readEither s)
19:54:53 <laudiacay> this problem is probably not the one for be to be solving
19:55:12 <lambdafan> is it safe to say read is not referentially transparent because of it's use of error?
19:55:24 <jle`> on what way is it not referentially transparent?
19:55:36 <jle`> it's definitely partial, though, if that's what you mean
19:55:39 <aweinstock> laudiacay: tools like objdump and r2 show you assembly equivalent of the machine code (and r2 gives a command-line environment for poking at the executables further)
19:55:51 <laudiacay> aweinstock: oh jesus machine code
19:55:53 <lambdafan> ah, I knew something was wrong wit it, I was looking for the words
19:55:58 <lambdafan> it's partial
19:56:02 <laudiacay> this makes me physically uncomfortable
19:56:17 <aweinstock> it still takes a bit of experience with those to recognize the assembly produced by C compilers as C constructs
19:56:24 <jle`> laudiacay: mhm, read is one of the infamously partial functions in Prelude
19:56:47 <jle`> i also still don't really understand why they're in there
19:56:58 <aweinstock> I've actually tried poking at deliberately vulnerable haskell programs, and I think understanding the RTS/STG are needed
19:57:04 <hackrilege> How's it worse than decompiled Haskell?
19:57:07 <lambdafan> what can I used instead of read, that does the same thing and isn't gross?
19:57:15 <jle`> readMaybe
19:57:18 <jle`> :t readMaybe
19:57:19 <lambdabot> Not in scope: ‘readMaybe’
19:57:21 <lambdafan> ah, much thanks
19:57:25 <jle`> @let import Text.Read
19:57:26 <lambdabot>  Defined.
19:57:28 <jle`> :t readMaybe
19:57:29 <lambdabot> Read a => String -> Maybe a
19:57:32 <aweinstock> laudiacay: http://lpaste.net/146230
19:58:09 <uli> or a parser combinator library
19:58:17 <laudiacay> i dont know what a buffer overflow is
19:58:57 <aweinstock> laudiacay: the classic paper on it: http://insecure.org/stf/smashstack.html
19:59:09 <laudiacay> oooh
20:00:47 <hackrilege> It stops the ram exploding
20:03:24 <hackrilege> So once we have the assembly we can look for interaction chains by halting execution per clock cycle
20:04:13 <hackrilege> And examining memory, building Haskell source to reproduce it by hand
20:04:39 <hackrilege> Learn how we did this, and write a decompiler
20:05:34 <hackrilege> But until someone does that in Haskell, it's off topic, until you have a partial implementation we can help with
20:08:04 <rashub> ?wiki monad
20:08:04 <lambdabot> http://www.haskell.org/haskellwiki/monad
20:09:46 <rashub> @type map
20:09:48 <lambdabot> (a -> b) -> [a] -> [b]
20:10:25 <hackrilege> I guess a nice starting point would be to get together what tools we can forge towards this task so at least it's on topic, any contributions, I know nothing about decompiling in Haskell, is that a thing?
20:11:48 <emmanuel_erc> hello there, does anyone here have experience with the repa package?
20:12:02 <rashub> > putStrLn "ru lambdabot?"
20:12:03 <lambdabot>  <IO ()>
20:12:43 <hackrilege> :t foldl
20:12:44 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
20:13:36 <glguy_> Rashub: you can play with lambda bot in private message
20:14:36 <aweinstock> hackrilege: probably relevant: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
20:14:49 <rashub> oh, i see, i thought it is private. sorry for bothering.
20:15:38 <aweinstock> hackrilege: (I think that the STG-machine described in that paper is the design that GHC is based on)
20:15:52 <emmanuel_erc> hi.
20:16:01 <hackrilege> So cool
20:17:14 <liaod> what's a good library for doing sockets in haskell?
20:17:25 <liaod> i'm mainly using it to communicate between a serverside and clientside of a game
20:17:25 <uli> Network
20:17:55 <lambdafan> https://hackage.haskell.org/package/network-conduit
20:23:15 <hackrilege> Does anyone know anything about jobs in Haskell? Do we really all just have to convince our bosses that we are better in Haskell than they are in c?
20:24:24 <Sonarpulse> is there a seq class?
20:24:30 <uli> Try to find a position in a domain specific field like some kind of engineering where they care about results and not the choice of programming language and you can smuggle Haskell in.
20:24:33 <Adeon> I write some haskell professionally but it didn't say anything about haskell in job description
20:24:51 <Sonarpulse> subclasses traversable and maybe (forall a. monoid (s a) too? 
20:25:16 <Adeon> it just happens haskell works well for some problems and because my coworkers are open minded they find it interesting that someone writes haskell in there
20:25:26 <Adeon> it also lets me say I write haskell professionally
20:25:28 <Sonarpulse> has like head/tail end/init
20:25:33 <Sonarpulse> cons snoc
20:25:38 <hackrilege> uli you describe the only viable scenario perfectly, I was asking if there was a recruitment agency or something, like, a known trusted resource of some kind
20:28:42 <uli> hackrilege: Not that I know of, but you find some resources if you search for "haskell in industry". Another niche is the verification industry, where they often use Haskell/OCamls and Co. to build e.g. termination provers, model checkers, etc.
20:28:56 <hackrilege> The it recruitment firms are all just looking for systems administration web front-end or insane c back-end
20:31:02 <hackrilege> Termination provers!
20:34:59 * hackagebot foscam-directory 0.0.7 - Foscam File format  https://hackage.haskell.org/package/foscam-directory-0.0.7 (TonyMorris)
20:39:10 <athan> Has anyone here used warp-tls to get a server running?
20:39:20 <athan> It's telling me SSL is obsoleted, which has me worried
20:39:48 <athan> Should I still provide SSL certificates? Or is there something else I need to establish?
20:40:22 <kadoban> athan: SSL is obsolete. TLS is the new and improved. Many people use SSL to mean TLS though, sometimes.
20:41:05 <athan> kadoban: Oh okay, so the `openssl` command I gave actually created a _tls_ cert?
20:41:12 <bitemyapp> athan: probably.
20:41:38 <glguy> It probably made an x509 cert
20:41:39 <athan> I'm just wondering if this cert, after having my request signed, is what I should provide to warp-tls
20:41:50 <athan> glguy: I think you're right
20:42:09 <Clint> "ssl cert" or "tls cert" doesn't mean anything specific
20:42:55 <athan> thanks guys v.v
20:43:24 <athan> can someone figure out why nestedroutes.com:443 isn't responding then? :v
20:43:56 <athan> hah, just saw someone ping it
20:44:21 <kadoban> athan: Probably not from the outside, it doesn't appear to give any information about what's wrong.
20:45:09 <uli> it looks like nobody is listening there
20:45:22 <athan> hmm
20:46:22 <monochrom> I don't think we speak of "ssl cert vs tls cert". there is x509 cert and you use it for ssl or you use it for tls
20:46:46 <athan> thank you monochrom, I'm pretty uneducated in this realm
20:46:58 <Clint> right, because you could use a different type of cert for ssl/tls
20:57:47 <athan> I was trying to serve it from port 80, and not 443 ><
20:58:09 <bitemyapp> athan: :)
21:08:11 <athan> bitemyapp: WAI-HTTP2 is my next target
21:09:54 <bitemyapp> athan: bleeding edge af
21:11:11 <athan> B|
21:11:22 * athan gets a can of beans b/c high-tech
21:16:47 <luigy> ping Sonarpulse 
21:24:30 <nocturne777> Is it a better practice to use Maybe and return Just to express the problem instead of having a return type like Either SomeError () ?
21:24:44 <athan> nocturne777: Both!
21:24:45 <athan> :)
21:25:05 <athan> I usually only signal an error when there are many that can happen, and they're unavoidable and not akin to what I want
21:25:09 <athan> and should be thrown
21:25:29 <athan> otherwise, then it's just part of the natural control flow, and I should handle the Maybe as either a monoid or a monad
21:26:03 <athan> For instance, sometimes I encode an optional argument as a Maybe, then get the `First` one as a monoid
21:26:36 <athan> or I have to continue some other computations in addition to that entity in the Maybe, therefore I would need to capture those additional computations in _its_ context as a monad / applicative
21:26:44 <athan> (but that applies for Either too)
21:27:30 <nocturne777> hmm, to me Either looks a bit weird when it does not return anything useful for success
21:27:40 <nocturne777> just like in the example I gave
21:31:30 <Cale> nocturne777: Either String ()  is actually a pretty useful type :)
21:33:50 <athan> nocturne777: Think about it like this:
21:34:00 <athan> (+) <$> Right 1 <*> Right 2
21:34:07 <athan> > (+) <$> Right 1 <*> Right 2
21:34:10 <lambdabot>  Right 3
21:34:18 <athan> > (+) <$> Left "uh oh some error!" <*> Right 2
21:34:20 <lambdabot>  Left "uh oh some error!"
21:34:29 <athan> > (+) <$> Right 1 <*> Left "some unrelated error?!"
21:34:30 <lambdabot>  Left "some unrelated error?!"
21:35:13 <kadoban> athan: Yeah, but that's not `Either a ()`
21:35:25 <nocturne777> yeah, I get that part
21:36:25 <nocturne777> Validation is good too when it comes to accumulating errors
21:52:44 <hussybitch> howdy 
21:53:22 <nocturne777> is there any way to alias a function's signature and use it in multiple places ?
21:55:04 <athan> nocturne777: That's what `type` is for!
21:55:17 <athan> hussybitch: hi there
21:55:44 <nocturne777> athan: it did not work GADT
21:56:06 <athan> nocturne777: can you show me code?
21:56:21 <athan> both what worked before, and what you're trying?
22:00:22 <lpaste> nocturne777 pasted “signature” at http://lpaste.net/146345
22:00:33 <nocturne777> athan: that Sig does not work
22:00:51 <nocturne777>   Data constructor UnInitNewAccount returns type Sig
22:00:51 <nocturne777>       instead of an instance of its parent type Account4 $a
22:10:03 * hackagebot profunctors 5.1.2 - Profunctors  https://hackage.haskell.org/package/profunctors-5.1.2 (EdwardKmett)
22:10:05 * hackagebot folds 0.7 - Beautiful Folding  https://hackage.haskell.org/package/folds-0.7 (EdwardKmett)
22:10:16 <athan> nocturne777: GATDs are different, not exactly just a type signature
22:10:34 <athan> in a GADT, you're declaring what type the data constructor should result in
22:10:51 <athan> it's a bit backwards
22:11:10 <athan> a `type` alias would work in most other scenarios, though
22:15:03 * hackagebot LibClang 3.4.0 - Haskell bindings for libclang (a C++ parsing library)  https://hackage.haskell.org/package/LibClang-3.4.0 (ChetanTaralekar)
22:17:29 <nocturne777> athan: I see
22:18:41 <ogRefl> hi nocturne777 and athan. just looked at the lpaste snippet.
22:18:52 <ogRefl> care for my 'insight'?
22:19:32 <nocturne777> ogRefl: athan just explained it
22:20:56 <ogRefl> nocturne777: oh ok
22:30:03 * hackagebot omnifmt 0.1.0.0 - A pretty-printer wrapper to faciliate ease of formatting during development.  https://hackage.haskell.org/package/omnifmt-0.1.0.0 (hjwylde)
22:50:17 * hackagebot git-fmt 0.3.0.4 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.0.4 (hjwylde)
22:50:19 * hackagebot git-fmt 0.3.1.1 - Custom git command for formatting code.  https://hackage.haskell.org/package/git-fmt-0.3.1.1 (hjwylde)
22:54:24 <kingket> Is it possible to productively write server side rest apis with mysql support?
22:54:41 <kingket> Like with php
22:55:17 <Axman6> what do you mean?
22:57:38 <kingket> Writing a haskell program to supply clients the relevant data (parsing in json, mysql db connection)
22:57:52 <kingket> Handling logins, etc
22:59:17 <pavonia> Sure, there are a lot of web server packages available
22:59:28 <Axman6> do you mean a web server which talks to mysql and produces data based on it? that's trivial in several frameworks
23:01:11 <kingket> You mean haskell frameworks? I want to dive into haskell with starting a project that I would normally write in an object oriented language
23:02:26 <pavonia> Well, in my experience "trivial" is not the proper word when MySQL is involved on certain systems
23:04:10 <kadoban> kingket: Diving into haskell with a project seems like a mistake, unless you already know quite a bit of haskell fundamentals.
23:04:20 <bitemyapp> kingket: tend to agree with kadoban.
23:05:17 * hackagebot foscam-sort 0.0.2 - Foscam File format  https://hackage.haskell.org/package/foscam-sort-0.0.2 (TonyMorris)
23:05:22 <kingket> I usually motivate myself by creating something useful
23:05:54 <bitemyapp> kingket: that's fair enough, but your approach has a high failure/burn-out rate.
23:06:15 <bitemyapp> kingket: taught a lot of people Haskell, writing a book, etc. Take it as you like, but it rarely works or teaches much.
23:06:19 <kadoban> kingket: Well, once you get to a certain level that's probably a good way to go, I just wouldn't start there. Haskell is vastly different in semantics and syntax than most languages people come in knowing.
23:06:27 <bitemyapp> kingket: Haskell is too different from what you already know.
23:09:00 <kingket> Where should I start? Any tutorials for somewhat experienced folks? 
23:11:10 <kadoban> kingket: https://github.com/bitemyapp/learnhaskell has some good advice, and http://haskellbook.com/ sounds very good (though I haven't read it yet)
23:11:25 <kadoban> I'd prefer the second if you're serious.
23:16:28 <osfameron> I'm not at all a fan of PHP, but it's interesting that just diving straight into writing a web-app in it *is* something that people dive into doing (whereas that wouldn't really work with Haskell)
23:18:50 <pdxleif> The default PHP runtime setup on most shared hosting means you can drop a .php file on there that just renders some html (php is itself also an html templating language)
23:19:14 <osfameron> yeah.
23:19:49 <osfameron> that's not to say Haskell should become more like PHP, just a (mildly) interesting distinction
23:20:03 <kadoban> osfameron: I suspect that if you mean an actual web-app, and not just HTML with some copy-and-pasted code in it, that also doesn't work well /at all/. Though that's PHP's one design goal, as far as I know, to support that.
23:20:06 <pdxleif> I run my own server, though. And setting things up from scratch, I think it's easier for me to run a Haskell webapp that just answers requests itself, than figure out how to setup apache + mod_php and all that...
23:20:29 <ent> kingket: I've read the the first 1/3 of the haskellbook.com book and it's quite good
23:20:59 <osfameron> kadoban: sure, but you start with a page, it works.  You add a variable, it works (eventually) and you hack bit by bit till you have something.  I expect it's quite motivating.
23:22:10 <ent> osfameron: yeah, it is. until you need to do something with someone else's code
23:22:11 <pdxleif> Having a web server find .php files on the filesystem and run them in response to web requests to certain paths that match that; I was actually working on an FP "web framework / cms" kinda thing that does something like that, i.e. templates are rendered according to their layout on the filesystem.
23:25:28 <pdxleif> We could make some kinda do-dad that gives the PHP experience, I'd think. Pick some HTML templating mechanism in Haskell you like. And then have a Haskell web server take requests and look at a filesystem tree for matching paths and run any files of that templating language in there that match?
23:25:48 <osfameron> HHP!
23:26:21 <kingket> I'll give haskellbook a try.
23:26:22 <pdxleif> And then convince dreamhost to offer it as a module on their shared hosting...
23:26:33 <osfameron> LHP?  Lambda Home Pages
23:26:57 <osfameron> I think chasing low-end hosting is a lost cause :-)
23:28:04 <osfameron> & work
23:29:45 <ent> pdxleif: the great thing with php is that you don't need that php web server, you can just use apache
23:31:08 <pdxleif> ent: It seems like a lot of work to set up apache + php. Personally, I'd rather just run one server, and not have so many moving parts / config files to coordinate.
23:31:21 <ReinH> pdxleif: o/
23:31:30 <pdxleif> ReinH: Hiya!
23:31:32 <ent> the thing is, apache + php is often already set up
23:32:16 <pdxleif> ent: I guess if you're already using php to serve stuff, maybe adding php to that isn't too bad. You can always have apache reverse proxy to something else like Haskell, though. That's what we did at my old job.
23:32:17 <kingket> Security comes to my mind as a concern. Mysql injection defense string parsers / limited access to the filesystem, etc. By the way a html parser seems unnecessary. Json from the haskell script + static html with javascript / ajax
23:32:46 <ent> pdxleif: yeah, that's what I did on a shared host too
23:33:27 <ReinH> Your concern is that haskell would be *less* secure than php?
23:33:40 <pdxleif> ent: Someone has to set that up and maintain it. These days I run my own servers. If I was deploying to dreamhost or school servers deploying php seems easy enough.
23:34:24 <pdxleif> If I'm setting stuff up, the fewer moving parts I have to configure and run and monitor, the better.
23:34:40 <pdxleif> I usually skip apache / nginx on my own stuff for that reason.
23:35:37 <ent> yeah, in that case it doesn't really add value
23:36:09 <kingket> In php there are built in functions for various web stuff. I don't know about haskell
23:36:35 <ReinH> No, we can do things with libraries.
23:36:44 <ReinH> Haskell has very few built in things for this reason
23:36:53 <ReinH> but there are lots of libraries
23:38:13 <pdxleif> php has a pretty notorious reputation in terms of security. Regardless, the type system in Haskell prevents most classes of injection attacks; things in dynamic languages like php or ruby are full of all kinds of injection vulnerabilities from people forgetting to escape strings - since everything is usually just a bunch of string concatenation in those frameworks - they don't bother with data types.
23:38:36 <Hijiri> I wouldn't say the type system prevents them, just that it makes it easier to prevent them
23:39:32 <Hijiri> if you really wanted to you could always do sqlleft ++ userInput ++ sqlrightk
23:39:32 <pdxleif> I can execute arbitrary JS on a number of websites by making my username Le'+alert("hello")+'if
23:40:41 <pdxleif> Hijiri: Right; the type system just gives better tools for that kind of thing. Seems more of an ecosystem / culture thing.
23:41:35 <liste> Hijiri postgresql-simple even makes that hard with its Query type
23:41:44 <pdxleif> Like doing everything as just string concatenation seemed awfully prevalent in the ruby and js stuff I saw. Even though they *could* do something better...
23:41:45 <kingket> A few days ago I found several <script> injections in user description data (directly via the tumblr api)
23:42:26 <pdxleif> Wheras the Haskell libs did not allow me to construct invalid / injected structures
23:42:28 <ReinH> pdxleif: Even more fun is javascript://foobar%0Aalert(1), which bypasses PHP's built-in filter_var, or at least did the last time I checked.
23:42:44 <ReinH> /foobar is a comment and %0A is an encoded newline!
23:42:56 <ReinH> er, //foobar is a comment
23:44:01 <kingket> Which libraries should I check?
23:44:29 <pdxleif> kingket: What kind of stuff do you want?
23:45:34 <pdxleif> You can browse them on https://hackage.haskell.org/, but there's tons.
23:47:07 <liste> kingket check out 24 days of hackage, its outdated in some places but generally a good resource: https://ocharles.org.uk/blog/pages/2012-12-01-24-days-of-hackage.html
23:47:21 <liste> it's December after all (:
23:47:35 <liste> also a 2013 version: https://ocharles.org.uk/blog/pages/2013-12-01-24-days-of-hackage.html
23:47:52 <bitemyapp> kingket: best quick example for avoiding string injection / template-mishandling in Haskell is the phantom types thing
23:48:23 <bitemyapp> kingket: https://github.com/bitemyapp/learnhaskell#supplementary-course-after-cis194-and-the-nicta-course the supplementary course I mention in my guide has a lecture on phantom types and uses that sort of thing as an example
23:48:44 <bitemyapp> kingket: but I'd still recommend doing a comprehensive course for learning Haskell, and being biased, I think that should be the haskell book.
23:59:18 <AbuDhar> :D
23:59:20 <AbuDhar> hello guys.
23:59:23 <kingket> Thanks
23:59:38 <AbuDhar> I heard you feed trolls :D
