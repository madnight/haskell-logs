00:07:40 * hackagebot sbv 5.6 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.6 (LeventErkok)
00:07:40 * hackagebot sbvPlugin 0.1 - Analyze Haskell expressions using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.1 (LeventErkok)
00:58:46 <mroman> Are there yet packages with size-typed tuples or similar?
00:59:38 <mroman> I'm basically looking at being able to type functions in a way that you can define an operator $> where the left side is a tuple of size N and the right side is a function that accepts a tuple of size N
01:01:00 <mroman> hm. probably sized-vector.
01:03:59 <mroman>     Data constructor ‚ÄòOS‚Äô comes from an un-promotable type ‚ÄòOrdinal‚Äô
01:04:01 <mroman> :(
01:09:50 <mroman> uhm
01:09:53 <mroman> Min n n is the same as n
01:10:06 <mroman> or at least it should be
01:12:36 * hackagebot wai 3.0.5.0 - Web Application Interface.  https://hackage.haskell.org/package/wai-3.0.5.0 (MichaelSnoyman)
01:21:35 <jle`> mroman: there are a bunch of libraries with vectors (all the same type) and tuples (all different types) with their lengths in their type
01:22:26 <jle`> searching for 'sized vectors' and things like that will get you a lot of hits on hackage :)  i personally use `linear`'s V type for my sized vector needs
01:22:50 <jle`> as for heterogeneous lists, type-combinators has a nice 'standardized' one, although you'll find a lot of hits for HList too
01:26:08 <mroman> jle`: Thanks.
01:58:18 <absence> what's the monad transformer for Either called, i keep forgetting. ExceptT?
01:59:19 <jle`> absence: the most current one is ExceptT from transformers/mtl
01:59:44 <jle`> which has taken over the now deprecated `either` package
01:59:48 <jle`> (which had EitherT)
02:00:36 <absence> jle`: right, i remembered the name was something else than EitherT :) thanks
02:00:44 <jle`> np!
02:07:46 <absence> is there some lens stuff for running a computation "inside" a monad transformer? e.g. ExceptT . fmap f . runExceptT, MaybeT . fmap f . runMaybeT, etc
02:11:03 <jle`> absence: looks like that should just be fmap f
02:11:13 <jle`> that's sort of the point of the transformer in the first place, heh
02:11:19 <jle`> oh wait, i see what you mean
02:11:42 <simon> does a zipper's cursor not have a short lifespan, and are they generally GC'ed efficiently?
02:12:28 <jle`> absence: each individual transformer usually gives something for this, like mapMaybeT and mapExceptT
02:13:33 <absence> :t mapExceptT
02:13:34 <lambdabot> (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b
02:13:40 <absence> :t \f -> ExceptT . fmap f . runExceptT
02:13:42 <lambdabot> Functor m => (Either e1 a1 -> Either e a) -> ExceptT e1 m a1 -> ExceptT e m a
02:13:52 <absence> jle`: not quite the same
02:13:58 <jle`> yours would be mapExceptT (fmap f)
02:14:03 <jle`> :t \f -> mapExceptT (fmap f)
02:14:05 <lambdabot> Functor n => (Either e a -> Either e' b) -> ExceptT e n a -> ExceptT e' n b
02:14:10 <absence> ah, of course
02:14:29 <absence> but yes, i guess there no general way to do this for all transformers now that i think of it
02:14:48 <jle`> mapExceptT and mapMaybeT are just unwrapping and wrapping the newtype wrappers
02:15:09 <jle`> ExceptT . f . runExceptT, MaybeT . f . runMaybeT, etc.
02:15:39 <jle`> the lens library does have a typeclass to abstract over this general pattern -- http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Wrapped.html
02:18:03 <absence> jle`: nice, thanks again
02:22:12 <jle`> absence: in particular, mapMaybeT = over _Wrapped, mapExceptT = over _Wrapped, I think
02:43:04 <Flonk> I overheard someone talking about the derivative of an algebraic data type. What does that even mean?
02:46:09 <Cale> Flonk: Are you familiar with sums and products as they apply to types?
02:47:02 <Flonk> Cale: only in the sense that + means Either, * means Pair, but not a whole lot more in-depth I'm afraid
02:48:15 <Flonk> And 1 means Unit, and X means singleton :)
02:48:21 <Cale> right
02:48:22 <Maxdamantus> |a| + |b| = |Either a b|
02:48:55 <Cale> So consider something like  List a = 1 + a * List a
02:49:54 <Flonk> okay
02:50:17 <Cale> We're going to "differentiate with respect to a"
02:50:31 <Cale> The derivative of 1 (or any constant type) will be 0, the derivative of a will be 1, the derivative of a sum will be the sum of the derivatives
02:50:45 <Cale> and the derivative of a product will follow the product rule from Calculus
02:51:16 <Cale> i.e. D(f*g) = D(f)*g + f*D(g)
02:51:31 <Flonk> Okay, so regular old differentiation
02:51:56 <Cale> So, List' a = 0 + (1 * List a + a * List' a)
02:52:05 <Cale> = List a + a * List' a
02:52:45 <Flonk> Okay, so far I'm with you :P
02:53:24 <Cale> Now, how to interpret this? Well, suppose we took a list and just deleted one of its elements (of type a), while leaving the rest of the structure intact
02:54:12 <Cale> Either we'd have deleted the first element, in which case we'd be left with the knowledge that this is what was deleted, and a simple list of the remaining elements
02:54:39 <Cale> Or we keep the first element, and what is left is a list which has one of its elements deleted
02:54:57 <Cale> This is an interpretation for what List' is
02:55:20 <Cale> i.e. it's a type for ways to have a list with an element removed from it somewhere
02:55:50 <Flonk> Hmm
02:56:34 <Flonk> It's a little unintuitive, but the type fits your description I guess
02:56:49 <Flonk> I don't see how differentiation would do that though
02:57:09 <Cale> Well, what happens when you differentiate x^3 = x * x * x ?
02:57:17 <Flonk> 3x¬≤
02:57:23 <Cale> You get the sum over all the ways of deleting an x :)
02:57:41 <Flonk> mind = blown
02:57:46 <Cale> 1 * x * x + x * 1 * x + x * x * 1
02:57:54 <Cale> = 3 * x^2
02:59:01 <Flonk> I guess I need to let that sink in a little. Thanks for the explanation! :)
02:59:02 <pavonia> Why is it legal to make the assumption that the derivative is the remaining structure if one element is removed? I see that it "coincidentally" leads to that, but I don't understand why it does that
02:59:42 <Cale> pavonia: Well, you check that this is a valid interpretation for each of the ways you have for building up types
03:00:38 <Cale> pavonia: Or you start from that as the definition and work the other way
03:00:41 <breadmonster> I think there's a significant problem in the way we teach monads.
03:01:00 <icen> breadmonster: burritos make you hungry?
03:01:12 <breadmonster> This whole "programmable semicolons" this was impenetrable until I figured out that monads are just another typeclass.
03:01:23 <pavonia> Cale: Yes, I can check afterwards. But is there some logical explanation why one gives you the other?
03:01:36 <Cale> pavonia: Well, the key thing is the product rule
03:01:47 <Cale> If F a = G a * H a
03:01:53 <tdammers> OK, so tell me again why I haven't been using stack so far
03:02:24 <Cale> then "deleting an a in an F a" means either deleting an a from the G a part, or deleting an a from the H a part
03:03:00 <Cale> i.e. F' a = (G' a * H a) + (G a * H' a) -- we get to choose which part to delete from
03:03:14 <Cale> and then the fact that we're sending a to 1 does the actual deletion
03:03:50 <Cale> It's just that the algebraic structure of the thing we're doing happens to look exactly like a derivative with respect to the equational properties it has
03:04:20 <Cale> It doesn't easily have anything to do with the limit definition from Calculus.
03:05:49 <icen> Cale: are we only ever differentiating polynomials, or are there more exotic things?
03:06:06 <Cale> icen: Well, we can also differentiate the solutions to polynomial functional equations
03:06:13 <Cale> like we did with lists above
03:06:53 <Cale> and it's possible to work out what we'd like the derivatives of more exotic things to be using the combinatorial interpretation
03:06:56 <LangeOortjes> breadmonster, heh that got me thinking. Wondering what someone could mean by "programmable semicolons" as I never came across the term while reading Haskell literature. But I guess, if you take the semicolon as representing the bind operator >>= then it makes a bit of sense, but it's still a poor term
03:07:09 <Cale> breadmonster: what are you reading?
03:07:26 <Cale> breadmonster: have you read https://wiki.haskell.org/Monads_as_computation ?
03:07:28 <breadmonster> Cale: Monad tutorials on the internet ><
03:08:01 <Cale> Most of the monad tutorials on the internet are terrible because they were written by people who just started to understand monads the day before
03:08:13 <breadmonster> Cale: Teek hai.
03:08:36 <breadmonster> But like I mean, I'd start out explaining that monads are a type class.
03:08:46 <Cale> yes, that's a good approach
03:09:01 <breadmonster> ie. nothing any more different from Eq or Ord.
03:09:05 <icen> The best one I've come across was "you could have invented monads" or something similar
03:09:13 <Cale> Monad is just an ordinary type class, and it captures a pattern which shows up in a bunch of our libraries
03:09:22 <breadmonster> Cale: Exactly!
03:09:39 <Cale> Read my post there for more :D
03:09:40 <breadmonster> icen: I like that one, but the idea is that it embeds monads as semicolons into your head.
03:09:52 <breadmonster> ie. monads are used to sequence stateful operations.
03:10:01 <breadmonster> Which is a horrible half truth.
03:10:07 <Cale> Well, "stateful" is not entirely true
03:10:24 <Cale> But "sequence operations" is always possible to interpret in some way
03:11:14 <breadmonster> Cale: If your definitions of "sequence" and "operations" are incredibly elastic, sure.
03:11:23 <Cale> Though you have to be a bit careful. It's possible that e.g.  do u <- x; v <- y; return (u,v)  is the same as do v <- y; u <- x; return (u,v) in some monads.
03:12:36 <Cale> (In particular, this is true for Reader r, and for Writer w if w is a monoid for which a <> b = b <> a for any a and b (a commutative monoid)
03:12:44 <Cale> )
03:12:57 <jle`> i think a lot of the issues with "iffy descriptions" of monads is that people try to talk about what monads *are*, an intuition for monads in general
03:13:16 <jle`> but all of these are perfectly fine if you rephrase "monads are..." with "monads are a pattern that is useful for..."
03:13:21 <jle`> or, "monads can be used to describe..."
03:13:39 <Cale> I don't know if that helps any
03:14:05 <Cale> In that it won't make the statements any more or less correct, I think.
03:14:13 <jle`> "monads are computations" means that monads are inherently computations...but 'monads can be used to describe computations' means that that's just one possible use case
03:14:16 <Cale> Because they were already analogies
03:14:29 <Cale> Monads aren't computations
03:14:38 <icen> It's just hard to make watertight analogies to algebraic definitions
03:14:38 <Cale> They're type constructors which construct types of computations
03:14:58 <jle`> yeah, there's no need to make analogies to describe the actual algebraic concept
03:15:02 <LangeOortjes> jle`, to be fair the title reads "Monads as computations", not "are"
03:15:05 <breadmonster> icen: So you shouldn't, it's confusing.
03:15:14 <jle`> what people are looking for is a way to see specific use cases
03:15:27 <Cale> Yeah, I probably shouldn't have even used "as" in the title
03:15:30 <jle`> LangeOortjes: yeah, but you also see "monads are semicolons", "functors are containers"
03:16:00 <Cale> Or it should have been "Monads as types of computations"
03:16:03 <Cale> but eh
03:16:04 <jle`> "monads are [some analogy]" is a common trope
03:16:28 <jle`> but the implication is that that analogy describes what a monad *is*...but it really should just be talking about specific applications of the monad pattern
03:16:29 <icen> breadmonster: but we also don't really want to have a perception of "this is haskell, you need to have done a course in graduate algebra first"
03:16:29 <Cale> Thinking of the values of a monad as being computations of some sort will always work.
03:16:38 <Cale> At least so long as we stick to Haskell
03:16:47 <jle`> yes, but only if you twist your definition of computation to match exactly the things that will work :p
03:17:03 <breadmonster> Cale: jle` took the words out of my mouth.
03:17:08 <Cale> Well, no, there are types of computations which don't form monads
03:17:41 <Cale> But all monads can be interpreted as a type of computations, with little slack. There are a handful of cases where it gets a bit trivial.
03:18:00 <Cale> But it doesn't require very much imagination.
03:18:20 <Cale> I should be clear: all monads in Haskell.
03:18:32 <Cale> If you go elsewhere in mathematics, that starts to fall apart.
03:19:48 <breadmonster> Cale: Do we have weak monads in Haskell?
03:20:10 <Cale> breadmonster: what 2-category?
03:20:15 <breadmonster> Yeah?
03:20:35 <Cale> I'm trying to figure out what you mean by "weak"
03:20:54 <Cale> Usually it's a technical term which only starts showing up once you have higher dimensional categories
03:21:10 <Cale> Haskell's types are usually only regarded as an ordinary category
03:21:35 <Hi-Angel> Monads are definitely burritos
03:22:21 <Cale> A weak 2-monad would be defined in a similar way to an ordinary monad, except in a category which had arrows between its arrows (e.g. like Cat has natural transformations between its functors)
03:22:43 <Cale> and the equational laws would be replaced by required existence of higher arrows
03:22:54 <Cale> (which would be required to be isomorphisms)
03:23:14 <Cale> (and then you'd also probably want to impose some coherence conditions on them too...)
03:24:14 <Cale> I've never seen anyone using weak 2-monads in Haskell, but it's not even exactly clear what it would mean
03:26:30 <Cale> Maybe it's possible to somehow turn Haskell into a 2-category, where the 2-arrows are somehow encoding equivalences between one function and another (i.e. by beta/eta expansion/contraction), and then our ordinary monads would indeed have to be weak 2-monads more likely than not, because we depend on evaluation to check the monad laws.
03:27:04 <Cale> (It would be a weak 2-category also then, because composition wouldn't be associative, only associative up to evaluation equivalence)
03:27:43 <Cale> But I don't know if any of this is making any sense, and it's pretty far out there :)
03:27:47 <quicksilver> then arrows would be terms of function-type
03:27:50 <quicksilver> rather than functions
03:27:56 <Cale> yes
03:28:11 <quicksilver> sounds plausible. Dunno if it sounds useful :)
03:33:12 * hackagebot Kriens 0.1.0.1 - Category for Continuation Passing Style  https://hackage.haskell.org/package/Kriens-0.1.0.1 (matteo_provenzano)
04:03:12 <jerv> Is there an idiomatic way to build a string as the concatenation of a list of strings without using fold* functions?
04:03:36 <Cale> concat
04:03:46 <Cale> ?
04:05:09 <MasseR> > concat ["foo", "bar"]
04:05:18 <lambdabot>  "foobar"
04:07:27 <mroman> > let c (x:xs) = x ++ c xs; c [] = [] in c ["foo","bar"]
04:07:29 <lambdabot>  "foobar"
04:08:54 <aweinstock> is concat potentially less efficient than using dlists? O(n^2) vs O(n)
04:09:37 <aweinstock> :t alaf foldMap Endo (\x -> (x++))
04:09:39 <lambdabot>     Couldn't match type ‚ÄòEndo [a0]‚Äô with ‚Äòe -> t a -> m‚Äô
04:09:39 <lambdabot>     Expected type: ([a0] -> [a0]) -> e -> t a -> m
04:09:39 <lambdabot>       Actual type: ([a0] -> [a0]) -> Endo [a0]
04:10:39 <exio4> how is concat O(n^2)? 
04:11:06 <vektor> Plugging my own post here: https://www.reddit.com/r/haskell/comments/3vponq/pure_typechecking_function/
04:11:15 <poucet> concat is O(N) and something similar for ldists is O(1)
04:11:47 <aweinstock> > flip (alaf Endo foldMap (++)) [] ["foo", "bar", "baz"]
04:11:49 <lambdabot>  "foobarbaz"
04:12:56 <aweinstock> exio4: foldr (++) [] -- if each substring is length n, and there are m strings, this is O(nm), I think
04:13:25 <Cale> aweinstock: concat isn't O(n^2)
04:13:48 <Cale> oh, well, sure, it's O(n) in the length of the *resulting* list of course
04:14:31 <aweinstock> I'm probably confused, but I'm not sure what I'm confusing it with
04:14:35 <exio4> foldr (++) [] ["abc", "def"] => "abc" ++ foldr (++) [] ["def"] => a : "bc" ++ foldr (++) [] ["def"] 
04:14:42 <Cale> But nothing can get around that, you have to take that much time to build the list you're building.
04:14:56 <jerv> I have my own append function that takes two Text and next to appending also does stuff like take the md5 etc. Then I want to apply that to a list of Text without using fold*.
04:15:20 <aweinstock> jerv: why not use fold?
04:16:22 <jerv> aweinstock: can't get into but the repo doesn't allow it basically
04:17:28 <mroman> hu? @length of result list?
04:17:40 <mroman> Then it's not using linked list like structures?
04:18:14 * hackagebot hasql-th 0.1 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.1 (NikitaVolkov)
04:18:14 <jerv> so if I just wanted to do concatentation I could do concat, but I want to apply other functions to the intermediate result
04:18:17 <mroman> (that'd get you O(n) where n is the lingth of the list of lists)
04:19:07 <mroman> (at least if the lists are not shared)
04:21:15 <mroman> ok. wiki says "ordinary single-linked lists"
04:22:27 <mroman> a ++ b depends on the size of a.
04:22:51 <mroman> so a ++ b is O(a), (a ++ b) ++ c would be O(a + O(a + b))
04:22:56 <mroman> if you pardon my sucky notation.
04:23:49 <mroman> every next ++ will take longer.
04:24:19 <lyxia> but we all write a ++ (b ++ c)
04:25:04 <mroman> @src concat
04:25:12 <mroman> hm
04:25:18 <mroman> @source concat
04:25:19 <lambdabot> concat = foldr (++) []
04:25:20 <lambdabot> Unknown command, try @list
04:25:27 <mroman> right.
04:27:27 <mroman> if we are already talking about listts
04:27:38 <mroman> are there benchmarks around for various list like structures?
04:27:44 <mroman> like Data.Vector and such
04:27:59 <mroman> or other array packages
04:32:02 <mroman> the ones I can find through stackoverflow seem to indicate that Data.List at least for sorting seems to be best
04:32:21 <mroman> but I suspect for when you need lots of random access that won't hold.
04:32:56 <KaneTW> if you want sort data once and access it in sorted order after, [] is fine
04:33:54 <KaneTW> if you want to keep adding new items, Data.Map or a similar tree implementation has good time complexity
04:34:13 <KaneTW> and also good time complexity for random access, but not as good as a sorted vectors
04:40:20 <basicProblem> hi 
04:40:23 <basicProblem> sumDigits :: [Integer] -> Integer
04:40:31 <basicProblem> sumDigits xs = sum(map  sumofdigitTolist xs)
04:40:37 <basicProblem>   where sumofdigitTolist y = sum(map digitToInt (show y))
04:41:22 <basicProblem> here .. I get an type variable error when I load this snippet 
04:42:29 <basicProblem> I change to and it works "sumDigits ::  [Integer] -> Int"
04:43:02 <basicProblem> Is there some function which can do that without me changing type variable
04:43:50 <quicksilver> basicProblem: fromIntegral
04:43:50 <liste> :t sum
04:43:51 <lambdabot> (Num a, Foldable t) => t a -> a
04:44:27 <quicksilver> you could, forexample, define digitToInteger as fromIntegral . digitToInt
04:47:51 <basicProblem> quicksilver: so replace digitToInt with "fromIntegral . digitToInt" should do?
04:47:56 <quicksilver> yup
04:48:04 <quicksilver> well you'll need ()
04:48:45 <basicProblem> with parens.. yes! okay. thanks quicksilver  :)
04:49:16 <quicksilver> :)
05:17:29 <varaindemian> how does this work? phoneBookToMap xs = Map.fromListWith (\number1 number2 -> number1 ++ ", " ++ number2) xs
05:17:32 <varaindemian> ?
05:17:44 <varaindemian> phoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String 
05:18:32 <frerich> :t M.fromListWith
05:18:34 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
05:19:38 <quicksilver> varaindemian: the function tells it what to do if it has two numbers for the same name
05:19:42 <quicksilver> i.e. how to handle duplicates
05:20:55 <nilg> How to build a rational? Things like (123 :: Rational) works, but (123 % 1) doesn't...
05:21:24 <mauke`1> nilg: how does it fail?
05:21:44 <pavonia> >  123 % 1 :: Rational
05:21:45 <varaindemian> quicksilver: how does she know they are duplicate?
05:21:46 <lambdabot>  123 % 1
05:22:04 <quicksilver> varaindemian: if they have the same 'k'
05:22:06 <varaindemian> quicksilver: is it something internal?
05:22:21 <quicksilver> well it just uses the comparison given by the 'Ord' instance there
05:22:44 <quicksilver> > (123 / 1) :: Rational
05:22:46 <lambdabot>  123 % 1
05:22:52 <quicksilver> ^^ if % isn't in scope you can just use /
05:23:16 <pavonia> Is there a way to get for a record data type value the list of accessor names together with their corresponding values (as String)? I guess Data.Data can do that, but not sure what functions to look at
05:25:25 <quicksilver> in fact I don't think Data.Data does expose field names (?). You can do it with TH. 
05:25:33 <quicksilver> it's often a bad idea.
05:26:37 <quicksilver> oh I was wrong, it does
05:26:45 <quicksilver> constrFields :: Constr -> [String]
05:26:46 <varaindemian> > 2 + 2
05:26:48 <lambdabot>  4
05:26:51 <mauke`1> > constrFields (dataTypeConstrs (dataTypeOf (Node 42 [])) !! 0)
05:27:00 <lambdabot>  ["rootLabel","subForest"]
05:27:29 <varaindemian> quicksilver: contrFields are the thing called overloading?
05:27:43 <quicksilver> not exactly, varaindemian 
05:28:05 <quicksilver> but "dataTypeOf" is ad-hoc polymorphism
05:28:10 <pavonia> And how to get the list of the corresponding values?
05:28:12 <quicksilver> which is sometimes called overloading.
05:29:49 <quicksilver> pavonia: what type would that list have?
05:30:01 <pavonia> [String]
05:30:18 <quicksilver> then I don't know what you meant by 'corresponding values'
05:30:28 <quicksilver> you mean the type of the field?
05:31:01 <pavonia> e.g. Foo { foo = 123; bar = False } would yield [("foo", "123"), ("bar", "False")]
05:31:26 <quicksilver> what if the field didn't have a Show instance?
05:32:12 <varaindemian> Map.fromList :: (Ord k) => [(k, v)] -> Map.Map k v  What is "Map.Map k v"?
05:32:39 <mauke`1> varaindemian: the type of maps with keys k and values v
05:32:55 <varaindemian> why isn't just like Map k v?
05:33:14 <mauke`1> varaindemian: where did you get that line from?
05:33:26 <varaindemian> learnyouhaskell.com
05:33:38 <mauke`1> doesn't exist
05:33:46 <pavonia> quicksilver: Doesn't a constraint Data mean it can represent the values in any case in some showable format?
05:33:54 <quicksilver> pavonia: no
05:34:05 <pavonia> Meh
05:34:17 <quicksilver> I don't think so anyway
05:34:28 <quicksilver> I think you're XY-ing
05:34:32 <quicksilver> what are you actually trying to do?
05:35:02 <varaindemian> mauke`1: it still doesn't make sense for me
05:35:26 <mroman> system.path, system.filepath, Filesystem.path
05:35:28 <mroman> uhm...
05:35:37 <mauke`1> varaindemian: where did you get that line from?
05:35:54 <cocreature> varaindemian: not sure if that helps but in Map.Map the first Map represents the module probably from some import statement such as "import Data.Map as Map" while the second Map represents the actual type (constructor)
05:35:56 <varaindemian> mauke`1: http://learnyouahaskell.com/modules
05:36:18 <varaindemian> cocreature: yes
05:36:41 <varaindemian> the second Map is the think I don;t understand
05:36:46 <varaindemian> thing**
05:36:49 <quicksilver> it's a type
05:36:49 <pavonia> quicksilver: I have a lot of types Map FooID FooInfo, where FooID is some integer value and FooInfo is a record, representing SQL tables. I want to write a general debug function tat prints the whole table, no matter what exact FooInfo values are in the map
05:37:35 <quicksilver> pavonia: easy enough to write such a function polymorphically with some Show constraints
05:38:04 <pavonia> By showing the value and re-parsing it?
05:38:12 <mauke`1> varaindemian: "Because Data.Map exports functions that clash with the Prelude and Data.List ones, we'll do a qualified import.  > import qualified Data.Map as Map"
05:38:20 <mauke`1> qualified imports are explained at the top of the chapter
05:38:57 <mauke`1> i.e. Map.Map is the type "Map" in the module "Map" (which is just an alias for "Data.Map", as declared by "import qualified Data.Map as Map")
05:39:20 <quicksilver> pavonia: nope. Just show it. Nothing to parse.
05:39:54 <pavonia> I want a tabular listing of all the values
05:39:57 <quicksilver> debugMyMap :: Show k, Show v =>  Map k v -> String
05:40:06 <mauke`1> EPARENS
05:40:14 <quicksilver> yes, missing parens.
05:40:40 <quicksilver> I imagine that type can be improved if you explain a bit more about what your FooInfo types look like.
05:40:49 <pavonia> I could probably have a new class an hard-code the data for each tye, but well ...
05:41:01 <quicksilver> it may amount to making FooInfo a member of some new ShowableTable type
05:41:05 <quicksilver> but that might not be necessary
05:41:56 <pavonia> They all are record types of the form { f_n :: T_n }
05:42:19 <pavonia> newtype Foo = Foo { ... }
05:43:40 <mroman> canonicalizePath fails when the file does not exist
05:44:22 <mauke`1> I'd hope so
05:45:17 <quicksilver> pavonia: hmm. OK thank you because now I understand your earlier questions better in context.
05:46:06 <quicksilver> I think I'd start with at typeclass "class ShowableTable t where { col_names :: [String]; col_values :: t -> [String] }
05:46:40 <mroman> and makeAbsolute doesn't really resolve ..
05:47:33 <pavonia> quicksilver: Yeah, that's the easiest solution, it's a lot of boilerplate though
05:47:56 <quicksilver> so given a concrete one like "data TableA = TableA { intField :: Int; boolField :: Bool }" it would be instance ShowableTable TableA where col_names = ["IntField","BoolField"]; col_values t = [show (intField t),show (boolField t)]
05:48:14 <quicksilver> pavonia: but then you can automate that boilerplate.
05:48:29 <mauke`1> can we ... scrap it?
05:48:35 <quicksilver> we sure can.
05:48:45 <pavonia> You mean with TH?
05:48:50 <quicksilver> although unfortunately I can never remember which of the many generic programming tools supports what.
05:49:04 <quicksilver> TH or Data.Data or one of the other tools built on them.
05:52:53 <mauke`1> > gfoldl (\z x -> Const (getConst z ++ " " ++ gshow x)) (\_ -> Const "???") (Node 42 [])
05:52:55 <lambdabot>  Const "??? (42) ([])"
06:02:13 <pavonia> Hhm, gshow looks promising
06:02:31 <mauke`1> > gshow (Node 42 [])
06:02:39 <lambdabot>  "(Node (42) ([]))"
06:04:58 <pavonia> Why the parentheses?
06:48:17 * hackagebot warp 3.1.10 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.10 (MichaelSnoyman)
06:48:43 <mauke`1> pavonia: something to play around with: https://www.fpcomplete.com/project/148573/sQfHaB8J5H
06:53:17 * hackagebot dynamic-plot 0.1.1.2 - Interactive diagram windows  https://hackage.haskell.org/package/dynamic-plot-0.1.1.2 (leftaroundabout)
06:57:53 <nilg> anyone knows a good codepad for Haskell?
06:58:11 <nilg> cause, honestly... http://codepad.org/oKGtnLdz
07:02:08 <pavonia> mauke`1: Cool, thank you!
07:16:31 <Big_G> What is a function that operates on every two elements in a list but isn't foldr because there is no accumulation? The result would be a list of booleans
07:17:09 <bergmark> Big_G: isn't the resulting list the accumulation?
07:17:26 <doomlord> does this channel have a hoogle bot
07:17:59 <Big_G> bergmark, Let me state the question. I want to see if there are any two adjacent elements that are the same
07:18:03 <doomlord> folding pairs ?
07:18:29 <doomlord> ah, is that a zip with the second argument starting one up
07:18:37 <mnoonan> Big_G: what bergmark said, or \xs -> if xs == [] then [] else zipWith f xs (tail xs)
07:18:55 <mnoonan> er, I guess you need to handle the [x] case too
07:18:58 <c_wraith> nilg: the one in the subject is pretty good. ( http://lpaste.net/ )
07:39:09 <lingxiao> hey is anyone familiar with conduit?
07:39:36 <johnw> lingxiao: what is your question?
07:41:39 <lingxiao> suppose I want to connect a source to n conduits
07:41:53 <lingxiao> so source $= cond1 $= ... $= condn $= sink
07:42:13 <johnw> the last has to be $$, not $=
07:42:27 <lingxiao> oops sorry yeah $$
07:43:12 <lingxiao> so I suppose I can just do somethig like foldr ($=) mempty (cond <$>  [1 ... n])
07:43:20 <lingxiao> really Im asking if there's a combinator defined that does just that
07:43:38 <johnw> you mean, binds a source to a list of conduits, so that it can be any number of them?
07:44:06 <johnw> foldl' ($=) source myConduits
07:44:11 <quicksilver> if they're not all the same type, that's hard for the haskell type system, tho
07:44:24 <johnw> yeah, they'd all have to be conduits from some type A to A
07:44:42 <johnw> otherwise, you're looking at a type-aligned list, which is not trivial by default in Hasklel
07:44:53 <yogle> why is Data.Binary.Get.remaining deprecated?
07:45:40 <lingxiao> johnw no it's all of form Conduit a m a
07:47:06 <johnw> lingxiao: then the foldl' I gave should do it
07:47:17 <lingxiao> that's just foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b
07:47:22 <lingxiao> right, from prelude
07:47:55 <johnw> it left-associates to get the right type for $=, and uses strictness because there's no need to lazily compose
07:48:24 <johnw> if you were using =$, it would be: foldr (=$) sink myConduits $ source
07:48:36 <johnw> but in the other direction it's foldl' ($=) source myConduits $ sink
07:50:08 <lingxiao> ah thanks did not make note of the difference
07:50:26 <lingxiao> btw when I do `runRVar StdRandom m`
07:50:36 <lingxiao> what exactly is this StdRandom .. it's not the seed right
07:50:44 <lingxiao> just something to sat the typechecker?
07:51:45 <geekosaur> it tells it to use the seed that is stashed in an IOVar internal to System.Random?
07:52:33 <geekosaur> cf. getStdRandom
07:53:10 <mauke`1> http://hackage.haskell.org/package/random-source-0.3.0.6/docs/Data-Random-Source-Std.html#t:StdRandom
07:54:10 <lingxiao> mauke`1 yeah I was reading that but didn't quite understand what it meant
07:54:44 <mauke`1> well, it also links to the source: data StdRandom = StdRandom
07:57:45 <tekkkz> Hello! Why "GPS.hs:15:1: parse error in let binding: missing required 'in'" at http://ix.io/mGh
07:58:07 <mauke`1> because you have a bogus "let"
07:58:18 <tekkkz> what is a bogus "let" ?
07:58:40 <mauke`1> bogus hei√üt soviel wie "falsch"
07:58:49 <tekkkz> und was ist daran falsch?
07:58:57 <mauke`1> you don't use 'let' at the top level, only in expressions
07:59:08 <mauke`1> for top level bindings you simply write 'url = ...'
07:59:14 <tekkkz> ahh ok thanks
07:59:47 <mauke`1> this is because the whole module is part of a 'where' block
08:00:18 <tekkkz> ok
08:00:20 <tekkkz> thanks
08:01:22 <tekkkz> hm
08:01:24 <tekkkz> mauke, 
08:01:37 <tekkkz> still an error, but caused by the returned tyoe
08:01:39 <tekkkz> *type
08:01:51 <tekkkz> :t H.parseUrl "http://www.geocodeip.com/"
08:01:51 <tekkkz> H.parseUrl "http://www.geocodeip.com/"
08:01:51 <tekkkz>   :: Control.Monad.Catch.MonadThrow m => m Request
08:01:52 <lambdabot> Not in scope: ‚ÄòH.parseUrl‚Äô
08:02:23 <mauke`1> does it complain about an ambiguous type, possibly called m0?
08:02:28 <tekkkz> yeah
08:02:36 <mauke`1> sounds like the monomorphism restriction
08:02:42 <tekkkz> ??
08:03:35 <mauke`1> the monomorphism restriction can be defeated by adding an explicit type signature, or by turning it off completely
08:04:27 <tekkkz> how to turn it off? could you tell me this please
08:04:43 <mauke`1> hmm, https://wiki.haskell.org/Monomorphism_restriction isn't as clear as it could be
08:05:00 <mauke`1> {-# LANGUAGE NoMonomorphismRestriction #-}
08:06:10 <tekkkz> but now htere is the problem that:
08:06:10 <tekkkz> Couldn't match expected type ëRequestí
08:06:11 <tekkkz>                 with actual type ëm0 Requestí
08:06:19 <tekkkz> at req ip = (flip H.urlEncodedBody) url $ [("IP", C.pack ip)]
08:08:41 <tekkkz> mauke`1, any idea?
08:18:34 <tekkkz> mauke`1, mauke, "Couldn't match expected type ëRequest' with actual type ëm0 Requestí " how to fix this type-problem now?
08:20:26 <tekkkz> here are 1500 people and noone wants to help me??
08:20:59 <mauke`1> see http://hackage.haskell.org/package/http-conduit-2.1.8/docs/Network-HTTP-Conduit.html
08:21:10 <mauke`1> parseUrl returns an action that constructs a request
08:21:31 <mauke`1> you're supposed to do request <- H.parseUrl "http://www.geocodeip.com/"
08:22:32 <tekkkz> wie meinst du das?
08:23:09 <tekkkz> also wo sollte ich das <- nutzen?
08:23:46 <Zekka|Sigfig> (not sure how much German knowledge is in this channel ‚Äùhow do you mean that?‚Äù and ‚Äúhow am I supposed to use that?‚Äù)
08:23:53 <Zekka|Sigfig> channel: *
08:24:05 <tekkkz> Zekka|Sigfig, come on ... ;)
08:24:48 <yogle> it's an international channel, so english is the preferred language
08:24:49 <Zekka|Sigfig> tekkkz: I‚Äôd help you out butI don‚Äôt really know the library you‚Äôre using that well and I‚Äôd feel bad getting on a really big tangent like that while I‚Äôm at work
08:25:12 <Zekka|Sigfig> I don‚Äôt really mind the German but I figured I‚Äôd translate it just in case it was really hard for anyone to understand
08:25:27 <tekkkz> yeah ok thanks my friend
08:26:47 <tekkkz> Zekka|Sigfig, so you would help me? nice, at least 2 people ;) what is a tangent?
08:27:55 <mauke`1> probably something like: req :: String -> IO (); req ip = do r <- H.parseUrl "http://www.geocodeip.com/"; return (H.urlEncodedBody [("IP", C8.pack ip)] r)
08:27:58 <Zekka|Sigfig> tekkkz: Going off on a tangent ‚Äî in English, if you want to do one thing and you start doing a second thing to help get there ‚Äî but the second thing takes longer than you expect
08:28:21 <geekosaur> see also: yak shaving
08:28:23 <geekosaur> >.>
08:28:27 <mauke`1> tekkkz: https://de.wikipedia.org/wiki/Tangente
08:28:44 <mauke`1> Zekka|Sigfig: a tangent is worse, it just goes off to somewhere completely unrelated
08:28:45 <Zekka|Sigfig> My guess is that mauke‚Äôs pretty close to right, but I don‚Äôt know the library you‚Äôre using. Looks like you got an ‚ÄúI got a monadic value when I wanted a normal one‚Äù error
08:28:56 <Zekka|Sigfig> mauke`1: Yeah, I guess that‚Äôs where the metaphor comes in
08:29:06 <Zekka|Sigfig> A tangent in geometry is a line that touches your figure at just one point, right?
08:29:32 <hodapp> I think that definition works okay
08:31:29 <hodapp> Actually, said line has to lie right along the derivative *at that point*. If it touches the figure at other points, that doesn't matter.
08:32:23 <Zekka|Sigfig> Oh, got it ‚Äî so it touches the figure and has the slope of the figure at one point?
08:33:24 <hodapp> Zekka|Sigfig: It's always tangent *at a point*, and it has the figure's slope at that point.
08:33:31 <hodapp> and touches it there, yes.
08:37:29 <TimoMeijer> Can I create a lens to focus on, for example, the 5th through 8th elements of a list?
08:38:01 <Zekka|Sigfig> TimoMeijer: Pretty sure you can, although it‚Äôd be a Traversal if it has to work for lists that don‚Äôt have eight elements
08:38:41 <tekkkz> you have sent me this link: http://hackage.haskell.org/package/http-conduit-2.1.8/docs/Network-HTTP-Conduit.html and i wanted to make, like at the cookie, my request (url-variable) by my own fixed in my code using http://ix.io/mGl but this is not working correctly when i just do url = http://ix.io/mGl so what did i wrong?
08:38:46 <Zekka|Sigfig> it‚Äôll look something like this:
08:39:44 <Zekka|Sigfig> hm, actually, this is more awkward than I thought to write inline
08:39:48 <Zekka|Sigfig> Let me try it for just two elements
08:40:36 <TimoMeijer> Zekka|Sigfig: Any pointers to where I should look for how to focus one several elements of a list would be wonderful
08:40:54 <Zekka|Sigfig> Pretty sure you can handle it close to how you would handle another data type: traverseSecond f (a:b:rest) = liftA3 (list3) (pure a) (f b) (pure rest) where list3 x y z = x:y:z
08:41:22 <Zekka|Sigfig> traverseSecond _ xs = pure xs
08:41:31 <Zekka|Sigfig> Don‚Äôt trust me though, I haven‚Äôt used Lens for a while
08:42:42 <Zekka|Sigfig> TimoMeijer: The gist of it is that a Traversal is a lot like a version of your constructor applied to Applicatives, which will quietly apply the function to at least one element of your structure during reconstruction
08:43:02 <Zekka|Sigfig> (or, well, to none. It can apply the function to as many elements as it wants)
08:43:21 * hackagebot success 0.2.2 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.2 (NikitaVolkov)
08:44:22 <Zekka|Sigfig> You can treat ‚Äòlist of five to eight elements‚Äô as being like a constructor too, although doing it neatly will require a helper function like I used above
08:44:44 <Zekka|Sigfig> er, list of eight elements, of which we care about four*
08:45:27 <TimoMeijer> Zekka|Sigfig: That looks like a step in the right direction, I·∏ø going to fiddle with it myself some more
08:45:53 <Zekka|Sigfig> TimoMeijer: Sure. Let me see if I can write a definition that works for eight
08:48:21 * hackagebot uri-bytestring 0.1.9.2 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.1.9.2 (MichaelXavier)
08:48:25 <ziman> hi, somehow I cannot come up with a solution for: (Traversable t, Applicative f) => Maybe (t (f a)) -> f (Maybe (t a))
08:48:48 <ziman> I can do it by pattern-matching on the Maybe but I'd prefer something more abstract
08:48:51 <ziman> any hints, please?
08:49:05 <Zekka|Sigfig> TimoMeijer: Untested, but I bet this is pretty close: http://lpaste.net/9146745160254619648
08:49:36 <Zekka|Sigfig> It assumes your function takes a tuple of the four elements (exactly four) that it cares about
08:49:49 <Zekka|Sigfig> you could also write a version that takes a list of up to four elements but doing it that way the code would probably be longer
08:49:57 <jamesfordummies> I am decoding JSON  (using aeson) in both GHC and GHCi and getting different results. (http://lpaste.net/3472678129095409664) in the first case, using GHC, it prints mmess: [Nothing, Nothing], whereas in the GHCi case, when I do it manually, it parses correctly. does anyone know why this would happen? if you need more info/code let me know
08:51:06 <ziman> oh, it's just (sequenceA . fmap sequenceA)
08:51:26 <NemesisD> about how long does it take the hackage package index to pick up a new package?
08:51:49 <TimoMeijer> Zekka|Sigfig: Thanks, that's still quite clunky, but much more in the direction of what I want than what I could come up with
08:52:15 <Zekka|Sigfig> TimoMeijer: I don‚Äôt have a good way to make it unclunky right offhand but there might be one
08:53:13 <TimoMeijer> Zekka|Sigfig: There's quite a lot of stuff hidden in the lens library
08:53:21 * hackagebot hasql-pool 0.1 - A pool of connections for Hasql  https://hackage.haskell.org/package/hasql-pool-0.1 (NikitaVolkov)
08:53:53 <Zekka|Sigfig> I wouldn‚Äôt be surprised. In my current situation I don‚Äôt really know the lens library that well but I know roughly how lenses work
08:55:01 <hobo> is the recommended setup for a windows machine to run it on a vagrant box?
09:12:05 <mniip> is there a nicer way to say 'fmap f . sequenceA'
09:12:45 <tekkkz> Hello! It's me again :D One question: how can i convert ªm0 Request´ to ªRequest´ ?
09:13:01 <mniip> you can't
09:13:15 <mniip> not with an arbitrary m0
09:13:45 <TimoMeijer> Zekka|Sigfig: I found the proper way to do it: [1,2,3,4,5,6,7,8] ^.. elements (`elem` [3..7])
09:14:20 <Zekka|Sigfig> TimoMeijer: Oh yeah, and that works? I don‚Äôt know offhand how but if it does then congrats
09:14:29 <Zekka|Sigfig> :t elements (`elem` [3..7])
09:14:31 <lambdabot>     Couldn't match expected type ‚Äò[a]‚Äô
09:14:31 <lambdabot>                 with actual type ‚ÄòInteger -> Bool‚Äô
09:14:31 <lambdabot>     In the first argument of ‚Äòelements‚Äô, namely ‚Äò(`elem` [3 .. 7])‚Äô
09:14:44 <Zekka|Sigfig> going to assume the wrong `elem` is in scope
09:15:04 <Zekka|Sigfig> :t elements (`Control.Lens.elem` [3..7])
09:15:06 <lambdabot>     Not in scope: ‚ÄòControl.Lens.elem‚Äô
09:15:06 <lambdabot>     Perhaps you meant one of these:
09:15:06 <lambdabot>       ‚ÄòControl.Lens.elemOf‚Äô (imported from Control.Lens),
09:15:20 <Zekka|Sigfig> a pox on your household
09:15:33 <tekkkz> mniip, how else can I solve my problem then?
09:15:35 <TimoMeijer> elem is simply from Data.List, isn't it?
09:15:48 <mniip> tekkkz, you never mentioned what is your problem
09:15:55 <tekkkz> okay wait a minute
09:15:56 <Zekka|Sigfig> TimoMeijer: It is? Odd, it didn‚Äôt appear to typecheck above
09:16:09 <Zekka|Sigfig> Maybe the issue is that the wrong ‚Äòelements‚Äô is in scope
09:16:17 <Zekka|Sigfig> :t Control.Lens.elements (`elem` [3..7])
09:16:19 <lambdabot> (Applicative f, Traversable t, Indexable Int p) => p a (f a) -> t a -> f (t a)
09:16:27 <TimoMeijer> Tada!
09:16:33 <Zekka|Sigfig> That looks likely to do what you want, sure
09:16:58 <Zekka|Sigfig> and just for you it‚Äôs generalized to *all* traversables
09:17:06 <glguy> TimoMeijer: You can use:   indices (\x -> 3 <= x && x <= 7)
09:17:17 <Zekka|Sigfig> I bet mine is slightly faster but I don‚Äôt really care
09:17:32 <glguy> TimoMeijer: but keep in mind that that's going to traverse the whole list checking indexes
09:17:40 <Zekka|Sigfig> (reason being that mine doesn‚Äôt have to do membership checks or anything fancy ‚Äî it just pattern-matches over a bunch of constructors)
09:17:57 <Zekka|Sigfig> Mine will probably also be constant-time even for huge collections, while I bet yours will be linear-time
09:18:02 <tekkkz> I want to make a program in some functions instead of one "do" block (where it is working) i want ot do this, instead of the do block you can see there: http://ix.io/mGq
09:18:05 <Zekka|Sigfig> (because it has no insight about whether it‚Äôs already found everything)
09:19:35 <TimoMeijer> Zekka|Sigfig: True, if you always want a specific part, your way is better, however, elements can be used to select which parts you want more arbitrarily
09:19:39 <tekkkz> mniip, you know what i mean?
09:20:01 <Zekka|Sigfig> I bet there‚Äôs still a faster way to select a known *range* than elements
09:20:10 <Zekka|Sigfig> that is, a range in the sense of (start, stop) or (start, stop, step)
09:20:17 <Zekka|Sigfig> Or even a known list, since you can tell when the list is empty
09:20:33 <TimoMeijer> glguy: Good point, but I don't think there's an easy way to prevent the whole traversal, but that check is definitely better
09:20:53 <Zekka|Sigfig> (and if the list is known to be ascending, even faster too!)
09:21:12 <TimoMeijer> Zekka|Sigfig: I hope so, but haven't found it yet
09:21:15 <Zekka|Sigfig> What I‚Äôm saying is that I bet you could write a version similar to mine that cynically exploits slices for good performance
09:21:18 <mniip> tekkkz, I don't even understand the question
09:21:44 <Zekka|Sigfig> er, not slices. Ranges? I don‚Äôt actually remember what Haskell calls them
09:22:07 <Zekka|Sigfig> You know, enumFromTo business.
09:22:18 <wedens> is there something like getOrElse for MaybeT? m a -> MaybeT m a -> m a or a -> MaybeT m a -> m a
09:22:32 <mniip> Zekka|Sigfig, ranges are just lists
09:22:44 <mniip> enumFromTo :: ... [a]
09:23:03 <Zekka|Sigfig> mniip: Yeah, although in this case I‚Äôm requiring the lists to be strictly ascending
09:23:59 <Zekka|Sigfig> and talking preferentially about lists that use the .. notation.
09:26:22 <lpaste> glguy pasted ‚Äúlist slicing‚Äù at http://lpaste.net/146658
09:27:55 <TimoMeijer> glguy: You≈ïe my hero
09:27:57 <Zekka|Sigfig> glguy: Implementation looks good!
09:28:01 <glguy> slicing probably isn't the right word for that
09:28:09 <glguy> but I think that's what you're trying to do
09:28:35 <Zekka|Sigfig> That looks pretty close to what I was coyly hinting at and I think performance should be OK
09:28:47 <Zekka|Sigfig> (that is, constant-time if start and end are constants)
09:30:03 <Zekka|Sigfig> It *is* elementwise over the middle range instead of ‚Äúwhole collection‚Äù-wise over it, but you can get around that by replacing ‚Äòtraverse f middle‚Äô with something else
09:30:12 <SavinaRoja> http://lpaste.net/146657
09:30:19 <Zekka|Sigfig> pretty sure ‚Äúf middle‚Äù would work just fine, but untested
09:31:15 <SavinaRoja> oops, meant to do more than just paste the url... I was wondering if anyone might offer a little feedback on my little script there
09:32:27 <Rembane> SavinaRoja: A map over a list of characters would remove a lot of code on rows 36-39
09:33:01 <TimoMeijer> Zekka|Sigfig: That would work if you want to do somethign with the collection, but if youw ant acces to the individual elements, it would have to traverse that bit
09:33:10 <SavinaRoja> Rembane: I can see that being a good idea
09:33:19 <Zekka|Sigfig> TimoMeijer: Yeah, that‚Äôs all I‚Äôm getting at
09:33:42 <Rembane> SavinaRoja: Good. Otherwise I think it looks good. I would remove the counts alias on row 31, but I'm notorious about removing as many names as possible.
09:33:48 * hackagebot hasql-th 0.1.0.1 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.1.0.1 (NikitaVolkov)
09:34:28 <SavinaRoja> Rembane: I think my rationale there was to avoid multiple accessions of the file
09:35:18 <glguy> SavinaRoja: Naming counts is just fine. I'd avoid trying to make lookupHelper be point-free, though
09:35:24 <SavinaRoja> Rembane: as a newb here, perhaps my notions of whether that matters is off
09:35:47 <Rembane> SavinaRoja: That's a good rationale.
09:36:27 <glguy> lookupHelper f 07= show (M.findWithDefault 040 f counts)
09:36:30 <glguy> is just fine
09:37:07 <SavinaRoja> glguy: that makes sense, I will give that a try
09:37:42 <glguy> f is probably the wrong variable though, I'm just used to find being the one that takes a predicate
09:41:34 <SavinaRoja> glguy: ammended with your suggestion, looks much less arcane
09:42:21 <slaterr> i have manual flash, using full manual mode on my camera. changing exposure time expectedly does not increase flash power, changing the ISO does. but changing the aperture seems to have very little effect. why??
09:42:29 <slaterr> uhm wrong ch
09:45:40 <SavinaRoja> would there be a better way to define the special bytes, a more self-documenting way?
09:47:07 <pikajude> glguy, do you have an IRC client plugin that highlights code for you?
09:47:24 <TimoMeijer> glguy: Why does fmap on a tuple only affect the second one in the tuple?
09:48:01 <TimoMeijer> Trying to wrap my head around that list slicing lens example you wrote, but that part boggles me
09:48:28 <tekkkz> if someone is interested: here line 13 works: http://ix.io/mGt here (line 22) doesnt: http://ix.io/mGu    -> why is it not working? error: http://ix.io/mGv how to fix it?
09:49:43 <mniip> :t C.head
09:49:45 <lambdabot>     Not in scope: ‚ÄòC.head‚Äô
09:49:45 <lambdabot>     Perhaps you meant one of these:
09:49:45 <lambdabot>       ‚ÄòBSC.head‚Äô (imported from Data.ByteString.Char8),
09:49:57 <mniip> anyway, there's your problem
09:54:40 <tommd> pikajude: glguy uses his own irc client (irc-core aka glirc) and it doesn't have plugin support.
09:54:57 <pikajude> oh, cool!
09:55:06 <tommd> TimoMeijer: Just see the definition of Functor (,).
09:55:13 <pikajude> so presumably that's either built-in or there's a command-line tool that does it
09:55:57 <pikajude> ah, the /hs command
09:56:12 <tommd> TimoMeijer: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-625
09:56:48 <c_wraith> TimoMeijer, it's the only thing it can do. it's required by the types. 
10:02:09 <pikajude> TimoMeijer: the two sides of (,) are not necessarily the same type
10:11:14 <tommd> All that said, it is somewhat arbitrary (though keeping with some conventions) to pick one side of a tuple vs the other vs both
10:11:29 <pikajude> it isn't
10:11:55 <tommd> Care to venture beyond unproductive contradiction?
10:12:08 <pikajude> sorry, i am struggling with my lack of a technical vocabulary
10:12:30 <pikajude> in Functor f, f must be kind * -> *, meaning ((,) a) is the only candidate instance
10:12:43 <pikajude> and in ((,) a), a is the first element in the tuple, not the second
10:13:15 <tommd> That limitation is purely syntactic.   (,a) is conceptually equivalent.
10:13:32 <pikajude> you'd need type-level flip for that
10:13:50 <pikajude> or you'd need your tuple to be defined as data (a,b) = (b,a)
10:14:01 <pikajude> both of which are more complicated than they need to be
10:14:43 <tommd> Agreed
10:15:11 <pikajude> i'm sure there's a good reason you can't write type operators as partially applied in that way, but i'm not familiar enough with the type system
10:16:18 <happyfeet> any idea on how to make gloss respond to press and hold key, so that i do not have to press the key repetedly
10:16:34 <infandum> Using getContents with HaskellR, I noticed huge memory usage. Like, 60 gigs for a 1 gig file, just loading it. Loading it directly from R instead ([r| read.csv(file) |] instead of [r| read.csv(text=contents) |] made the memory usage sane again. Is this due to the coding of H.io or whatnot in HaskellR? If not, is this due to the strictness of the R monad forcing all of the contents from getContents into
10:16:36 <infandum> memory? If so, why would that use up 64 gigs when the file is just 1 gig?
10:16:57 <pikajude> what is HaskellR?
10:17:06 <pikajude> oh
10:17:15 <infandum> pikajude: An amazing project to make all of R's libraries available in haskell
10:17:19 <pikajude> wow
10:17:24 <infandum> it's pretty amazing
10:17:30 <hodapp> infandum: are you liking it a lot so far?
10:17:35 <infandum> I love R's libraries but I don't like the R language
10:17:44 <hodapp> I've been wanting to learn... well, R in general, but also HaskellR
10:17:49 <infandum> hodapp: It's pretty great, except for the memory usage
10:18:03 <infandum> but it's probably my fault, not haskellr's
10:18:10 <pikajude> i know nothing about R, but would `contents` in your paste be represented by a String?
10:18:16 <infandum> yeah
10:18:26 <pikajude> that might be it. String is a linked-list, so you have one node per char
10:18:37 <pikajude> which means a billion or so nodes
10:18:41 <infandum> so I wanted to load the contents in haskell and then parse it to a csv with read.csv
10:18:46 <pikajude> sure
10:18:54 <pikajude> does read.csv require String? or can it take Text or ByteString?
10:18:57 <infandum> it all works fine on the other projects, but this one has a huge file
10:19:18 <pikajude> Text and ByteString iirc both use contiguous sections of memory instead of linked lists
10:19:21 <infandum> HaskellR is a very immature project, so it only comes with a few types converted between haskell and r
10:19:29 <infandum> I don't think text or bytestrings are available yet
10:19:32 <pikajude> okay
10:19:36 <pikajude> that would be my first suggestion
10:19:41 <infandum> I could write my own conversion but i think it's a bit over my head
10:19:53 <pikajude> i haven't any idea what kind of serialization machinery is involved in converting a Haskell String to an R string
10:20:09 <infandum> yeah, I like to stay high level haha
10:20:16 <pikajude> i shudder to think
10:20:30 <pikajude> you could always use -ddump-splices to see what code gets generated!
10:21:25 <infandum> they have a tutorial i think
10:21:46 <infandum> for writing your own type conversions
10:28:23 <koshmar> I am interested in the state of subhask project. have any one tried it? how solid it is? and if anyone aware of future devolopment of this project? any prediction when it will be solid?
10:33:21 <varaindemian> Consider the following simple language of expressions that are
10:33:21 <varaindemian> built up from integer values using a division operator:
10:33:22 <varaindemian> data Expr = Val Int | Div Expr Expr
10:33:43 <varaindemian> can someone explain me?
10:33:50 <varaindemian> http://www.cs.nott.ac.uk/~pszgmh/monads
10:33:51 <tommd> happyfeet: gloss gives you 'up' and 'down' information on key presses.
10:34:29 <happyfeet> tommd: i currently have it moving according to one key press
10:34:37 <Ankhers> varaindemian: What part do you not understand?
10:35:07 <tommd> happyfeet: Regardless of how you're using it, Gloss gives you sufficent information that you don't need repeated key presses.
10:35:32 <happyfeet> how's so?? tomd
10:36:07 <tommd> happyfeet: The event type (http://hackage.haskell.org/package/gloss-1.9.4.1/docs/Graphics-Gloss-Interface-Pure-Game.html#t:Event)
10:36:23 <tommd> happyfeet: Has a key state http://hackage.haskell.org/package/gloss-1.9.4.1/docs/Graphics-Gloss-Interface-Pure-Game.html#t:KeyState
10:37:01 <tommd> happyfeet: So you can start moving on 'Down' and stop moving on 'Up'.  Keep the boolean of being in motion (or not) in your state.
10:38:04 <happyfeet> tommd i think i am starting to understand what you mean
10:42:25 <varaindemian> A
10:42:27 <varaindemian> Ankhers: data Expr = Val Int | Div Expr Expr
10:42:35 <varaindemian> this whole thing
10:43:29 <Ankhers> varaindemian: Alright. Do you understand the haskell `data' keyword?
10:44:19 <varaindemian> Ankhers: no
10:44:48 <ARM9> it's an algebraic datatype that can either be a Val (just a name for the data constructor) that contains an Int OR a Div (again, data constructor) that contains two Expr (notice that the definition is recursive)
10:45:23 <varaindemian> Ankhers: I am following this: https://courses.edx.org/courses/course-v1:DelftX+FP101x+3T2015/info
10:45:39 <Ankhers> varaindemian: did what ARM9 say make sense?
10:46:09 <ARM9> Val 5 would construct an Expr, Val being the Constructor, Expr being the Type
10:46:20 <ARM9> the resulting Expr would contain the integer 5
10:51:38 <lingxiao> hey all
10:51:40 <lingxiao> I'm seeing this in a student's code
10:51:42 <lingxiao> data Treap a = Treap {seed :: Int, tree :: State StdGen (T.Tree a)} 
10:51:51 <lingxiao> are they shooting themselves in the foot with this?
10:52:09 <varaindemian> Ankhers: well now I think I need to understand the "contructor" concept
10:57:45 <tommd> lingxiao: Hard to say without knowing the broader context.  Why do you think to ask?  Is something inherently bad here?  Is it that the 'seed' and 'StdGen' are related thus only necessitating one of the two?
10:59:07 <lingxiao> They're explicitly keeping StdGen in State
10:59:27 <lingxiao> I believe RVar is better since we don't have to keep track of StdGen?
11:00:18 <tommd> @hoogle RVar
11:00:21 <lambdabot> package rvar
11:00:21 <lambdabot> Network.HTTP.Headers HdrVary :: HeaderName
11:00:21 <lambdabot> Language.Haskell.TH.Ppr pprVarStrictType :: (Name, Strict, Type) -> Doc
11:00:41 <dmj> lingxiao: what are the assignment requirements? Keeping StdGen in a state is fine, you can call 'next' to mutate it, this obviates the 'seed' field though afaik.
11:00:41 <tommd> lingxiao: Can you translate to Haskell2010 for those of us without your context?
11:01:23 <dmj> by mutate I mean modify $ \stdgen -> let (_, newgen) = next stdgen in newgen
11:01:29 <tommd> Also, keeping a stdgen in a state monad is fairly common.  For example, see MonadRandom and MonadCryptoRandom.
11:02:45 <lingxiao> dmj no requirements, just make something cool using using concepts taught in class, so functor monad monad transfromers
11:02:52 <lingxiao> and a "certain world view" if that makes sense
11:03:11 <lingxiao> tommd : sorry which one did you want me to translate?
11:11:58 <emmanuel_erc> hello!
11:16:27 <tekkkz> I want to use Network.Curl for a Post request. curlPost url [options]  works fine, bu returns IO () ... curlGetString returns a String, but there is no curlPostString .. why not? how to get it?
11:21:53 <Ankhers> tekkkz: That library seems a little out dated (last updated in Nov 2012). Maybe you would like to take a look at https://hackage.haskell.org/package/wreq ? I have not used it myself, but I have heard good things.
11:22:16 <Ankhers> tekkkz: Or is there some requirement to use the curl package?
11:24:04 <tekkkz> Ankhers, no, i just want to perform a post request and use tagsoup on the returning website
11:24:49 <Ankhers> tekkkz: What is the purpose of using a post request instead of a get?
11:25:06 <tekkkz> Ankhers, the site returns information based on data from post
11:25:31 <Ankhers> I guess that is some sort of form submission?
11:25:37 <tekkkz> yeah
11:27:37 <tekkkz> Ankhers, ill have a look at wreq, they also explain a post request
11:27:40 <Ankhers> tekkkz: https://hackage.haskell.org/package/wreq-0.4.0.0/docs/Network-Wreq.html#g:4
11:27:46 <Ankhers> Indeed they do.
11:27:52 <Zemyla> Ankhers: GET requests have to be idempotent, and generally it's a super bad idea to make changes based on a GET request.
11:28:18 <Zemyla> Like, you don't want posting or deleting things to be a GET request.
11:28:34 <Ankhers> Zemyla: I understand that. I just wasn't sure if it the post query was absolutely necessary.
11:31:09 <varaindemian> Ankhers: where can I find something well explained about haskell's keyword data?
11:32:10 <Ankhers> varaindemian: https://wiki.haskell.org/Type#Data_declarations may be a decent start.
11:32:31 <dmj> varaindemian: it's like struct in C
11:33:09 <varaindemian> dmj: sorry? :D
11:33:17 <Ankhers> dmj: Is it though?
11:37:47 <exio4> C structs + boost::variant :P
11:38:02 <TimoMeijer> I'm getting an error when trying to build my code, does anyone know how to fix this? http://lpaste.net/146661
11:39:55 <lpaste> SavinaRoja revised ‚Äúbytecounter.hs‚Äù: ‚Äúbytecounter.hs‚Äù at http://lpaste.net/146657
11:40:52 <glguy> SavinaRoja: You shouldn't mix hGetContents and withFile
11:41:18 <glguy> hGetContents uses lazy IO and takes ownership of the Handle
11:42:05 <SavinaRoja> glguy: hmm, looks like I need to some more reading up
11:42:17 <glguy> BL.readFile is the short-version of what you're doing there without that prblem
11:42:19 <geekosaur> TimoMeijer, looks like your parse module is missing from a library cabal stanza (should be in souces or extra-sources, if it's in neither it may get coimpiled due to local references but not installed)
11:45:18 <SavinaRoja> ran into an issue that I thought was due to early handle closure
11:45:35 <glguy> SavinaRoja: If you use "qualified" imports on Data.Map.Strict and Data.ByteString.Lazy you won't need to use qualified names on things like map and putStr
11:46:47 <SavinaRoja> hah, that's what I do in ghci, don't know why I haven't in this code
11:47:17 <tekkkz> Ankhers, i dont get it how to make a post request with wreq
11:47:24 <tekkkz> Ankhers, could you help pls?
11:48:04 <glguy> SavinaRoja: You usually don't want to import GHC modules unless you're doing something particularly low-level. Word8 comes from Data.Word
11:49:01 <SavinaRoja> glguy: that was another thing that I thought I was doing a bit wrong, hadn't located Data.Word yet thanks
11:49:10 <glguy> SavinaRoja: You don't need to annotate more than one of the elements in a list, they all have to have the same type
11:49:28 <glguy> in this case you don't need to annotate the types of any of them. Those types are fixed because of your countMap function
11:49:43 <Ankhers> tekkkz: There is a section that shows how to use it. What part do you not understand? What error are you getting?
11:50:29 <tekkkz> ªr <- post "www.geocodeip.com" ["IP" := "79.212.82.103"]´ is not working. I want to make a post request to this url with data: IP=... how to do this?
11:53:23 <glguy> countMap 07= BL.foldl' (07\acc x 07-> M.insertWith (07+) x 041 acc) M.empty
11:53:32 <glguy> You can avoid making the intermediate list
11:54:42 <tekkkz> Ankhers, any idea?
11:55:36 <Ankhers> tekkkz: You need to include "http://" in the URL.
11:57:50 <tekkkz> still error. i send it to you at PM
11:57:58 <Ankhers> tekkkz: What is the error you are getting?
11:58:02 <tekkkz> se PM
11:58:05 <tekkkz> *see
11:58:12 <Ankhers> :set -XOverloadedStrings
11:58:17 <Ankhers> (if you are in ghci)
11:58:35 <tekkkz> worked
11:58:36 <tekkkz> thx
11:58:37 <Ankhers> Or set the OverloadedStrings language pragma at the top of your file.
11:58:44 <Ankhers> No problem/
12:00:48 <tekkkz> Ankhers, btw, what is := ?
12:01:12 <Ankhers> tekkkz: It is an operator defined by the wreq package.
12:01:24 <tekkkz> what is he doing?
12:01:26 <Ankhers> You should be able to find documentation for it on hackage.
12:01:52 <tekkkz> okay
12:02:40 <emmanuel_erc> (Sorry if this is a silly question) So, I was just profiliing my code, and I got that it runs in constant space, but it apparently is not being very productive (32.1%). What could that be about?
12:02:42 <Ankhers> tekkkz: It creates a FormParam.
12:03:41 <Ankhers> emmanuel_erc: without knowing anything about what you are doing. My top two could be inefficient algorithm or data structure.
12:03:53 <tekkkz> yeah Ankhers i found it already thx
12:03:57 <emmanuel_erc> I see.
12:07:06 <emmanuel_erc> Ankhers: Have you ever used fgl before? Within the library, there is "fast" implementation for graphs using the IntMap data structure. I've looked at some of the source code and it doesn'  explicitly use the Lazy or Strict version. Is there some way to only use the Strict version of IntMap?
12:07:21 <emmanuel_erc> without having to rewrite everything?
12:12:08 <Ankhers> emmanuel_erc: I have not used it.
12:13:52 * hackagebot haskellscrabble 1.2 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-1.2 (happy0)
12:20:18 <Guest5175> Hi, I'm playing with Haskell->C->C++. I have got some C code working using the C "extern" binding to the C++ code. But my Haskell program gives garbage.
12:20:19 <Guest5175> http://pastebin.com/5jy02T9x
12:20:31 <Guest5175> Hello from Haskell!
12:20:31 <Guest5175> 1807766880
12:20:31 <Guest5175> Bye from Haskell!
12:21:26 <tekkkz> Ankhers, are you still here?
12:21:38 <mauke> __MYLIB__ is technically a reserved identifier
12:21:42 <Ankhers> tekkkz: mhm
12:21:45 <Guest5175> bleh
12:21:51 <Guest5175> I'll go call it something else.
12:22:29 <mauke> do you know what identifiers are reserved?
12:22:34 <tekkkz> Ankhers, it works in ghci: ª  r <- post "http://www.geocodeip.com" ["IP" := "79.212.82.103"]
12:22:35 <tekkkz>   let html = r ^. responseBody ´ but not in my code, wanna have a look?
12:22:53 <Ankhers> tekkkz: What is the error?
12:23:50 <mauke> Guest5175: your import's fucked
12:24:02 <mauke> Guest5175: foreign import ccall unsafe "mylib.h create_rect" c_get_area
12:24:06 <mauke> spot the inconsistency
12:25:11 <Guest5175> mauke, genious :P
12:25:17 <tekkkz> Ankhers, http://ix.io/mGE
12:25:20 <Guest5175> mauke, fixed, it works as expected now
12:25:24 <Guest5175> thanks!
12:26:29 <mauke> yay
12:28:04 <Ankhers> tekkkz: Do you have the OverloadedStrings language pragma at the top of your file?
12:28:52 * hackagebot hgrev 0.1.5 - Compile Mercurial (hg) version info into Haskell code  https://hackage.haskell.org/package/hgrev-0.1.5 (LukeHoersten)
12:29:21 <tekkkz> {-# LANGUAGE OverloadedStrings #-}
12:29:22 <tekkkz> ?
12:29:25 <Ankhers> mhm
12:29:29 <monochrom> pretty sure OverloadedStrings is the cause, not the solution, of a "No instance for (Data.String.IsString v0)" "The type variable ‚Äòv0‚Äô is ambiguous" problem
12:30:44 <Ankhers> Does GHC not know it is supposed to be a bytestring?
12:31:10 <Ankhers> oh
12:31:12 <tekkkz> i have no plan, it is working in ghci ... so what do you mean with your last question Ankhers ?
12:31:28 <Ankhers> I didn't realize the type signature of (:=)
12:31:49 <Ankhers> (:=) :: FormValue v => ByteString -> v -> ForParam
12:32:36 <Ankhers> tekkkz: GHC doesn't really know what to do with the "79.212.82.103". I believe ghci is a little more aggressive with defaulting types.
12:32:46 <ChristianS> Ankhers: you have to annotate the type manually, if ghc cannot figure it out, e.g. ("literal" :: ByteString)
12:32:55 <Ankhers> tekkkz: You should be able to do something along the lines of of ChristianS just said.
12:33:31 <Ankhers> ("79.212.82.103" :: String) should be fine. 
12:33:40 <Ankhers> or any other String-like type.
12:33:55 <Ankhers> ByteString may be the most efficient.
12:34:06 <Ankhers> I have no basis for that though.
12:43:55 <cheecheeo> is there a reason that http://hackage.haskell.org/package/set-monad-0.2.0.0/docs/Data-Set-Monad.html can't be `Traversable`?
12:47:42 <pdkr> cheecheeo: mathematicians think of sets as being unordered. traversable would give it an order
12:48:20 <pdkr> not sure if that's The Reason, but it might be one
12:48:29 <cheecheeo> because the effects would have a certain order?
12:48:47 <pdkr> cheecheeo: effects?
12:50:14 <cheecheeo> the first argument to traverse, the effecting computation
12:50:34 <pdkr> aren't we talking about why there isn't an instance Traversable Set ?
12:50:42 <cheecheeo> yes
12:51:06 <pdkr> okay, so my claim is that there isn't one, because this would assign an ordering to the elements of that set
12:51:13 <pdkr> which we don't want - for whatever reason
12:51:25 <pdkr> (again, not sure if this is the reason)
12:51:26 <Zekka|Sigfig> Well, there‚Äôs another reason. Sets aren‚Äôt functors, assuming you believe in the existence of information below the level of Eq/Ord
12:51:41 <mauke> this set is
12:51:46 <cheecheeo> Set is a Functor in `set-monad`
12:51:50 <pdkr> Zekka|Sigfig: they are functors?
12:52:04 <Zekka|Sigfig> Oh wait!
12:52:06 <pdkr> they're monads even
12:52:11 <Zekka|Sigfig> You‚Äôre not talking about factory Set
12:52:23 <Zekka|Sigfig> OK, never mind me. I don‚Äôt know anything about what that package provides
12:52:56 <pdkr> Zekka|Sigfig: ah, good spotting :)
12:53:46 <Zekka|Sigfig> pdkr: I‚Äôll maintain that what I‚Äôm saying should be true of other set implementations, but it‚Äôs just fine to say ‚Äúmy sets are Functors and Eq/Ord/whatever my set type uses to distinguish elements is the end-all be-all of same vs difference‚Äù
12:54:00 <Zekka|Sigfig> and if you say that I‚Äôm pretty sure you can lawfully make Set a functor
12:54:32 <pdkr> in practice, we could implement Traversable for all of these "Set"s
12:55:23 <monochrom> I'm pretty sure it's just "I haven't got around to do it"
12:55:45 <pdkr> monochrom: well it wouldn't be difficult at all, so i'm not willing to buy that argument
12:56:09 <monochrom> what will you buy?
12:56:21 <pdkr> a good argument
12:56:37 <monochrom> good luck with that
12:56:54 <pdkr> guess i'll go to the argument clinic
12:57:27 <monochrom> GHC is the greatest example, in the real world, of how difficult things get done all the time and easy things get procrastinated ad infinitum
12:57:44 <johnw> easy things don't generate theses. Qed.
12:57:54 <monochrom> yes
12:58:03 <ReinH> pdkr: this isn't an argument
12:58:19 <pdkr> yes it is
12:58:22 <ReinH> no it isn't
12:58:56 <johnw> ;)
12:59:41 <monochrom> it is delusional to believe that humans make decisions and do work based on good arguments.
12:59:45 * geekosaur *eyeroll*
12:59:52 <ReinH> We'll be here all week.
13:00:00 <johnw> anyway... -blah -blah -blah
13:00:22 <monochrom> humans rationalize their behaviour by some kind of hopefully good argument, to be sure. rationalize only.
13:00:32 <geekosaur> the hard stuff is usually welcomed with open arms; the simple stuff gets bikeshedded to death and never happens >.>
13:01:28 <tekkkz> thanks Ankhers 
13:02:01 <pdkr> speaking of hard stuff: if i'd want dependent sums, would it be reasonable to use existentials and the singletons package, or is dependent-sum the preferred option nowadays? or "it depends"? (for production code)
13:02:42 <monochrom> how does dependent-sum do it?
13:02:54 <ReinH> geekosaur: I believe that bikeshedding is generated to complete a minimum-disagreement-required quota.
13:03:20 <ReinH> We don't trust a too-easily-achieved consensus
13:04:11 <pdkr> monochrom: data DSum tag f = forall a. !(tag a) :=> f a
13:04:37 <pdkr> which i suppose is an existential
13:04:45 <albeit> When I derive Storable for a simple sum type, compiling throws a warning "No explicit implementation for sizeOf, alignment". Is that okay? Can I disable that warning?
13:04:53 <pdkr> but the singletons are not necessary because they are just the constructors of tag
13:04:57 <monochrom> yeah. it probably just doesn't use singleton
13:05:38 <monochrom> I don't know either approach, apart from "I guess existential quantification helps"
13:06:56 <pdkr> now suppose i have an SMyType :: MyType -> *, and the existentials "A = forall t. HaskellType1 t" "B = forall t. HaskellType2 t" where HaskellType{1,2} generate some other type out of t, and a map HaskellType1 t -> HaskellType2 t, how would i make that into a map A -> B ?
13:07:35 <pdkr> (t :: MyType here)
13:08:38 <pdkr> i mean it seems like I should instead make the existentials be a pair of SMyType t and HaskellType{1,2} t, to be able to extract a singleton. but this does not make sense because the existential quantifier should already track runtime information about t
13:08:58 <pdkr> so why can't i do without?
13:09:03 <tekkkz> How to convert bytestring to IO str0 ?
13:09:56 <albeit> tekkkz: Do you mean ByteString -> String?
13:10:42 <albeit> Are Haskell sum types stored internally as the same kind as Integer? So for 64-bit systems, each value/constructor of a sum type is a Int64?
13:11:00 <lostman> how does stack decide which versions are valid for `compiler` setting? I'd really like to use ghc-7.10.3 but it complains that "No information found for ghc-7.10.3". and it also refuses to accept any of rc versions
13:11:29 <pdkr> albeit: (Integer and Int64 are not the same thing)
13:11:47 <albeit> pdkr: Sorry, I think I meant Int
13:12:02 <pdkr> albeit: (i would also be interested in this)
13:12:19 <johnw> albeit: do you mean, enums?
13:12:25 <albeit> johnw: Yes
13:12:41 <albeit> Wasn't sure what the best term was... something like data Foo = Bar | Baz | Lorem
13:12:54 <johnw> I'd bet that's just an offset to the constructor position
13:14:10 <albeit> johnw: Is there a simple way to dervice Storable for enum types?
13:14:33 <johnw> yes, I'm pretty sure GHC.Generics can do that
13:15:04 <johnw> now, to find out how...
13:15:15 <johnw> http://hackage.haskell.org/package/generic-storable
13:18:07 <albeit> johnw: How would I use that? I have the package installed (just copied source, stack didn't like dependencies), but not sure how to actually dervive Storable from it
13:18:19 <albeit> I am already deriving Generic for my enum type
13:21:12 <johnw> just peekDefault
13:21:30 <johnw> it'll infer how to decode your enum value from the pointer
13:21:46 <johnw> note, not having tried this, there is a bit of guessing happening
13:22:17 <glguy> Since you're going to have to specify the method implementations anyway you're probably better off just writing them out manually, none of them would be complicated
13:22:19 <albeit> Ah beauty, that worked great. Thanks!
13:22:24 <glguy> poke p x = poke p (fromEnum x)
13:23:24 <glguy> and then it would also be clear what the instance was actually doing
13:24:11 <glguy> you only have to implement peek,poke,sizeOf, and alignment
13:24:31 <johnw> why is that better than Generics, especially if you have lots of enums?
13:24:49 <glguy> Because it's the same amount of code with a predictable mapping form the enums to C representation
13:25:01 <johnw> isn't it like 4x as many lines of code?
13:25:04 <glguy> no
13:25:06 <glguy> same lines
13:25:08 <johnw> deriving Generic is all you need
13:25:23 <johnw> oh, I see what yo umean
13:25:24 <glguy> you still have to write out the whole instance with the Generics method
13:25:32 <johnw> wait, what?
13:25:44 <johnw> why would you have to write out any instances with Generics?
13:25:55 <glguy> instance Storable MyEnum where peek = genericsPeek; poke = genericsPoke; sizeOf = genericsSizeOf, etc
13:26:07 <glguy> Isn't the question about writing Storable instances?
13:26:17 <johnw> you can just use peekDefault
13:26:52 <glguy> you can write: peekDefault :: Enum a => Ptr a -> IO a; peekDefault p = fmap toEnum (peek p)
13:27:03 <johnw> yeah, true
13:27:04 <glguy> and use that in all your instances, no generics, predictable behavior same code
13:27:12 <johnw> fair enough
13:27:27 <johnw> if Enums are the only things we're talking about
13:28:25 <glguy> isn't that what we're doing?
13:28:49 <johnw> that was the question asked, yes
13:29:21 <tekkkz> albeit, yeah, bytestring to string
13:30:02 <albeit> tekkkz: Data.ByteString.unpack
13:31:54 <Boreeas> Hm, which package provides Data.Text? I was under the assumption that it was part of the std lib, but ghc can't find it
13:32:01 <glguy> text
13:32:58 <ReinH> @hoogle Data.Text
13:33:00 <lambdabot> Data.Generics.Text module Data.Generics.Text
13:33:00 <lambdabot> Data.Text module Data.Text
13:33:00 <lambdabot> Data.Text.Internal Text ::    Array ->    Int ->    Int -> Text
13:34:01 <ReinH> Oh, this one doesn't include the package name. The web one does: https://www.haskell.org/hoogle/?hoogle=Data.Text
13:37:35 <tekkkz> hm, albeit , still an error: Couldn't match expected type ëByteStringí
13:37:35 <tekkkz>                 with actual type ëData.ByteString.Lazy.Internal.ByteStringí
13:37:40 <pdkr> tekkkz: careful with ByteString -> String. you might be doing a unicode encode/decode here, which *can* fail.
13:37:57 <pdkr> (or a different character encoding)
13:38:05 <albeit> tekkkz: If you're using Data.ByteString.Lazy you'll need to use Data.ByteString.Lazy.unpack
13:38:09 <geekosaur> tekkkz, that usually means you are mixing strict and lazy Bytestrings
13:39:00 <tekkkz> thanks, but there is a second error:  Couldn't match type ë[]í with ëIOí
13:39:00 <tekkkz>     Expected type: IO [Tag GHC.Word.Word8]
13:39:00 <tekkkz>       Actual type: [[Tag GHC.Word.Word8]]
13:39:06 <tekkkz> at different point i think
13:39:11 <tekkkz> but an error in my code
13:41:20 <tekkkz> geekosaur, pdkr, albeit here: http://ix.io/mGL
13:41:23 <tekkkz> please help me
13:41:54 <glguy> let tags =, not tags <-
13:44:23 <tekkkz> glguy, nope: http://ix.io/mGM
13:44:53 <glguy> tekkkz: That just means you had more than one bug
13:45:33 <glguy> I'll help if you show the type of parseTags
13:45:46 <bam365> tekkkz: you need Data.ByteString.Lazy.Char8.unpack, I think?
13:45:59 <pdkr> tekkkz: (i don't want to be mean, but #haskell is not a debugging service)
13:46:11 <tekkkz> parseTags :: Text.StringLike.StringLike str => str -> [Tag str]
13:46:22 <tekkkz> @ glguy 
13:46:37 <glguy> then you probably want: let tags = parseTags html
13:46:37 <pdkr> (as in, post a compile error, expect a code fix)
13:47:36 <pdkr> (though of course i have no problems at all if you ask "*why* do i get this error")
13:47:51 <tekkkz> glguy, best guy ever <3
13:48:19 <tekkkz> sure, first i want a fix, now im asking why let and not <- and why without fmap ?
13:49:04 <dmj> tekkkz: (<-) would assume you're in the list monad
13:49:07 <glguy> let names a value, in the case of IO  <- executes an action and names the result
13:49:07 <ARM9> <- is syntactic sugar for binding monads in do notation
13:49:30 <tekkkz> hm .. im new to haskell. what ae monads?
13:49:39 <albeit> Oh boy :)
13:49:42 <tekkkz> ^
13:49:43 <ARM9> haha
13:49:44 <tekkkz> ^^
13:49:47 <johnw> tekkkz: that's not really a useful question if you're new to haskell
13:49:52 <ARM9> isn't that the million dollar question
13:49:59 <johnw> that's like saying "I'm new to math; what are lie groups?"
13:50:00 <tekkkz> man
13:50:00 <glguy> There's existing written material online for learning the basics of Haskell
13:50:05 <tekkkz> sure
13:50:24 <tekkkz> but im not at monads yet
13:50:31 <tekkkz> ill get to know it later i think
13:50:38 <johnw> eventually you will, yes
13:50:55 <dmj> tekkkz: are you familiar with typeclasses yet
13:51:05 <tekkkz> ya
13:51:29 <ARM9> https://wiki.haskell.org/All_About_Monads this helped me grasp the basics
13:51:49 <ARM9> then I got to the applicative chapter in learn you a haskell and it all became clear
13:52:06 <pdkr> tekkkz: "<-" and "let" are different in the sense that you obtain the right-hand side in a different way. for example, if you're in the IO monad, then <- means you are e.g. expecting some kind of input or OS-provided value, whereas "let" just says "this variable is a synonym for this expression"
13:52:28 <tekkkz> ok
13:52:32 <tekkkz> thx
13:53:01 <pdkr> tekkkz: in your case, your right-hand side was some list of lists. that has nothing to do with IO, so you use let
13:53:48 <geekosaur> let's take a simpler example, using Maybe.    let x = Just 6 -- x will be Just 6.     x <- Just 6 -- x will be 6.    but most often you are using it with IO or something that has IO at its base, and you can't just make the IO go away; you must use <- (or >>=)
13:53:55 <pdkr> hope that helps. many people think they can explain monads best, and i'm one of them
13:54:45 <tekkkz> yeah your explanations are very nice, thx guys
13:55:04 <geekosaur> monads can't really be explained, they have to be experienced >.>
13:55:13 <pdkr> geekosaur: amen to that
13:55:20 <pdkr> monads are a way of life
13:55:25 <geekosaur> the explanations never make sense until you have come to understand them experientially
13:55:44 <tekkkz> and i got my next error .. man, without a post request i have everything working, but with post every step need a reprogramming ..
13:55:47 <geekosaur> (or if you do understand an explanation, then it's likely wrong) 
13:57:13 <tekkkz> guys
13:57:17 <zoku> girls
13:57:19 <tekkkz> could you help me one mor etime pls?
13:57:22 <ReinH> tekkkz: "but with post every step need a reprogramming" seems unlikely, as it's what do notation was created to avoid. Can you show us your code?
13:58:19 <pdkr> geekosaur: is it fair to say one understands monads when he/she can point out what's wrong with every individual explanation of what they are? P
13:58:21 <pdkr> *:P
13:59:03 <geekosaur> probably not
13:59:10 <tekkkz> working: http://ix.io/mGN ---  not workng: http://ix.io/mGP
13:59:34 <c_wraith> pdkr: I'd say one understands monads when they quit thinking they're magical or even all that important in the big picture. :) 
13:59:41 <pdkr> :)
14:00:31 <t7> you understand monads when you see the burrito  
14:00:49 <geekosaur> the burrito is a lie
14:01:05 <pdkr> i believe in the flying burrito monster
14:01:13 <t7> its burritos all the way down 
14:01:27 <Rembane> I stare at the types of monads and only see pancakes. That makes me happy.
14:01:29 <tekkkz> ahh
14:01:29 <c_wraith> burritos are just a monad in the category of F√úD, what's the problem? 
14:01:34 <tekkkz> i forgot the error:
14:02:06 <pdkr> c_wraith: i do suspect this category is cartesian
14:02:16 <t7> you have a problem so you decide to solve it with a burrito, now you have 2 problems!  
14:02:16 <pdkr> exponential, even
14:02:25 <tekkkz> http://ix.io/mGR
14:02:47 <c_wraith> pdkr: it's not exponential. the morphisms aren't in the category. 
14:03:16 <hobo> anybody have recommendations for website crawling/scraping?
14:03:24 <hobo> (also very new to haskell)
14:03:36 <ReinH> c_wraith: I did enjoy that paper
14:03:37 <monochrom> I agree with "understand = not magical"
14:03:58 <monochrom> in fact, understand = it's quite dull actually
14:04:13 <pdkr> the value of boring is underappreciated
14:04:24 <ReinH> I dunno, I appreciate boring a lot
14:04:30 <pdkr> uh. that's a stylistic error i suppose.
14:04:37 <ReinH> especially as an ops person ;)
14:04:47 <monochrom> I appreciate boring and dull, too
14:04:58 <pdkr> well i'm not blaming haskell programmers
14:05:57 <shachaf> @quote shachaf magic
14:05:57 <lambdabot> shachaf says: "magic" is just another word for "primitive"
14:06:10 <koz_> I need some advice on how to code this. I'd like to separate a big list of things into one-third and two-thirds (or as close as possible) of itself, by picking elements randomly. Is there a good way to do this?
14:06:31 <monochrom> is that some Cantor set thing?
14:07:22 <jle`> koz_: you can zip it with a random list of one of 1, 2, or 3
14:07:29 <jle`> and then filter on which category it is
14:07:37 <monochrom> good plan
14:08:03 <koz_> jle`: Nice! How would I generate such a list? Should I just make a list of 1s, then 2s, then 3s, then (for leftovers) 4s, and shuffle it?
14:08:03 <jle`> > randomRs (0,2) (mkStdGen 10) :: [Int]
14:08:05 <lambdabot>  [2,0,2,0,1,1,2,1,2,0,1,1,1,1,1,2,0,0,1,1,1,2,2,1,0,1,0,0,2,0,2,0,0,1,2,0,0,2...
14:08:40 <jle`> > map (< 2) (randomRs (0,2) (mkStdGen 10) :: [Int])
14:08:43 <lambdabot>  [False,True,False,True,True,True,False,True,False,True,True,True,True,True,T...
14:08:59 <koz_> jle`: I need fixed numbers in each category.
14:09:15 <koz_> One-third of the list should be 1s, two-thirds 2s, according to this scheme.
14:09:31 <jle`> this is already a list where one third is True and two thirds is False
14:09:46 <jle`> er, i got that backwards
14:09:58 <jle`> (one third is False and the other two thirds is True)
14:10:02 <shachaf> monochrom: It may be a good plan, but is it cunning?
14:10:02 <koz_> Ah, I see.
14:10:04 <koz_> Makes sense.
14:10:11 <koz_> Thanks!
14:10:43 <jle`> np!  zip and filter snd and map snd i guess
14:10:45 <monochrom> it is not cunning until it is so clearly doomed that it's funny :)
14:11:02 <geekosaur> cunning plans in programming tend to lead to debugging sessions, wailing, and gnashing of teeth...
14:11:11 <koz_> geekosaur: Yup, agreed.
14:17:00 <koz_> What does it mean for something to be 'right-lazy'?
14:18:01 <hpc> sounds like it's referring to things like (&&)
14:18:06 <hpc> @src (&&)
14:18:06 <lambdabot> True  && x = x
14:18:06 <lambdabot> False && _ = False
14:18:15 <hpc> (False &&) being right-lazy
14:18:22 <hpc> or something
14:19:16 <jle`> maybe it means it's lazy on the second argument, yeah.  which means that x && _|_ is not necessarily _|_.  Or, if you evaluate the final result, the second argument is not necessarily evaluated
14:20:21 <hpc> i think they're taking lazy to mean "not strict"
14:20:32 <hpc> strict meaning (x && _|_) = _|_
14:20:50 <hpc> so non-strict being (x && _|_) `notNecessarilyEquals` _|_
14:24:15 <koz_> OK, I'm confused again. I have this: http://paste.rel4tion.org/162 , but I have no clue what the error's about.
14:26:55 <mauke> did you mean fmap?
14:27:10 <koz_> I wanna zip the two together.
14:27:17 <mauke> cool story
14:27:19 <koz_> Wait, ordering...
14:27:38 <pavonia> zip returns a list, not a Maybe
14:28:43 <koz_> I guess I'm just confused a bit here. I have a [Bool] and a Maybe [[Bool]] which I wanna zip together.
14:28:50 <koz_> SO I'm not even sure what type I'm aiming for here...
14:29:43 <monochrom> how do you "zip together" [] and Nothing?
14:30:31 <koz_> monochrom: I know that's impossible, but you *can* zip together [] and a Just.
14:30:56 <koz_> s/Just/Just [Something]
14:31:17 <mauke> how?
14:31:36 <koz_> OK, let me rephrase.
14:31:48 <koz_> Actually, never mind, I can do this without Maybe.
14:31:59 <pavonia> You want to lift the first list into the Maybe monad and zip from there perhaps
14:33:23 <pavonia> :t \xs ys -> do { x <- Just xs; y <- ys; return $ zip x y }
14:33:25 <lambdabot> [a] -> Maybe [b] -> Maybe [(a, b)]
14:34:00 <koz_> It's fine - I just did it without Maybe. Realized it wasn't necessary there.
14:43:50 <haskel-learner> hello anyone here?
14:43:57 <Rembane> YEs
14:44:35 <haskel-learner> are code questions allowed? or only discussion?
14:44:39 <monochrom> am I here?
14:44:52 <Lokathor> it seems weird to me that if there's an executable and a library in the same .cabal file then you need to include the modules from the library in the executable's "other modules" section
14:44:55 <Lokathor> even if it depends on the library
14:45:06 <Rembane> haskel-learner: Code questions are encouraged.
14:45:20 <Rembane> monochrom: You indeed are.
14:45:56 <happyfeet> can I select the font i want to use in text in gloss??
14:46:10 <tommd> happyfeet: You can't.
14:46:23 <tommd> Fonts are basically ugly broken things that you don't want to you (in gloss).
14:46:34 <happyfeet> tommd: any way around that??
14:46:58 <happyfeet> or is it preferable that i use premade bitmaps??
14:47:07 <tommd> Patch Gloss.  If you understand GLFW or OpenGL (the backends to gloss) and how fonts work with those systems then add the needed support and plumbing to Gloss.
14:48:00 <monochrom> premade bitmaps is what many web designers do :)
14:48:18 <tommd> happyfeet: You can use bitmaps to render characters but that will 1) be slower 2) not be so valuable to the community unless you package it separately.
14:48:30 <tommd> With a patch to Gloss everyone wins.
14:48:42 <tommd> (Yes, I'm being greedy, I too want pretty fonts in gloss)
14:50:27 <happyfeet> tommd: i am really just starting in haskell i do not have the knowledges to do that.. xb
14:51:01 <happyfeet> but if any1 where did it... it would be greatly appreciated ;)
14:51:06 <happyfeet> *here
14:53:09 <haskel-learner> ah okay, so haskell provides Data.Map so maps are implemented by lists or search trees, however i want to implement one using characteristic functions, i've written a new type data myMap k v = M(k -> Maybe v),how do i implement a insert so for example (|->) :: Eq k -> k -> v -> MyMap k v, unfortunately (|->) k v = M (\k -> Just v) doesnt work
14:54:21 <tommd> haskel-learner: (|->) k v = M (\k -> Just v)  -- the two 'k' variables are different, with the second over shadowing the first
14:54:35 <mauke> also, that's singleton, not insert
14:54:45 <tommd> haskel-learner: Instead, consider \k2 -> if k2 == k then Just v else Nothing
14:54:46 <haskel-learner> oh right meant singleton
14:55:41 <monochrom> (\k -> Just v) is not even singleton.
14:56:28 <tommd> Let's just make an every-ton: M (const (Just v))
14:56:31 <monochrom> at any rate if you so much as include "Eq" you may as well try to sneak in == somewhere
14:56:39 <statusfailed> join #electronics
14:56:43 <statusfailed> whoops :3
14:56:49 <monochrom> almost banned you
14:57:11 <statusfailed> who me? 
14:57:16 <monochrom> yeah :)
14:57:19 <statusfailed> D:
14:58:27 <Lokathor> http://lpaste.net/146669 the site says i should use "unless" for the if statement, but the obvious translation here doesn't compile for me. What would the unless version of that if look like?
14:58:56 <haskel-learner> thanks guys 
14:58:59 <monochrom> "Haizod" is a cool name
15:00:12 <mauke> unless foldable retry
15:00:18 <monochrom> unless (null foldable) retry
15:00:21 <mauke> er
15:00:24 <monochrom> :)
15:00:45 <monochrom> unless you're saying my version has a type error too
15:00:58 <monochrom> @type unless
15:01:00 <lambdabot> Applicative f => Bool -> f () -> f ()
15:01:09 <monochrom> @type retry
15:01:11 <lambdabot> Not in scope: ‚Äòretry‚Äô
15:01:19 <monochrom> I wonder if the () part hurts
15:01:31 <Lokathor> unless (null foldable) retry
15:01:32 <Lokathor> that works
15:01:49 <Lokathor> monochrom, i liked the sound of "Heimdall", but i made the vowels more japanese/esperanto and then changed the end a bit
15:01:52 <monochrom> \‚à©/
15:02:52 <Lokathor> i had attempted to write "unless (null foldable) retry (return ())"
15:02:54 <Lokathor> :P
15:03:09 <monochrom> that is just a case of writing too much :)
15:05:10 <koz_> If I have two [a]s, and wanna get a [Bool] by comparing their elements for equality, what's the most Haskelly way to write it?
15:05:26 <koz_> (assuming a is an instance of Eq, obv)
15:05:38 <Lokathor> :t zipWith
15:05:40 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
15:05:45 <shachaf> What happens when they're not the same length?
15:05:53 <Lokathor> :t zipWith (==)
15:05:55 <lambdabot> Eq a => [a] -> [a] -> [Bool]
15:06:04 <koz_> Thanks Lokathor!
15:06:18 <koz_> Also, interesting to see you in this chan.
15:06:34 <Lokathor> zipWith will stop when either list stops though, so if one list is shorter that could be a problem
15:06:59 <Lokathor> I wasn't aware that folks followed what channels i'm in >_>
15:07:35 <koz_> Lokathor: I know you from TGD.
15:07:41 <pavonia> koz_: Do you want to compare each two elements with the same index in the list, or all possible combinations?
15:07:48 <koz_> pavonia: Same index.
15:08:09 <ElMoloko> how come in ghci you can say let 1 = 2 or the like
15:08:14 <pavonia> Okay
15:08:26 <ElMoloko> it doesn't have any effect obviously, but it doesn't complain
15:08:44 <ElMoloko> it is just because the types line up...?
15:08:45 <rom1504> let false
15:08:51 <ElMoloko> ...oh
15:08:53 <rom1504> ah no
15:08:57 <rom1504> idk
15:09:01 <ElMoloko> wait yeah
15:09:30 <pavonia> ElMoloko: It's a binding that matches the expression 2 to the pattern 1
15:09:56 <pavonia> But 2 is never evaluated, so the pattern match doesn't fail
15:10:29 <mauke> > let True = False in ()
15:10:30 <ElMoloko> huh
15:10:31 <lambdabot>  ()
15:10:44 <mauke> > let !True = False in ()
15:10:47 <lambdabot>  *Exception: <interactive>:3:5-17: Non-exhaustive patterns in pattern binding
15:11:10 <pavonia> > let (x, 1) = (2, 2) in x
15:11:11 <ElMoloko> that's cool and ridiculous.  do you don't need to bind it to anything
15:11:12 <lambdabot>  *Exception: <interactive>:3:5-19: Irrefutable pattern failed for pattern (x, 1)
15:14:36 <Lokathor> i wish that haskell imports could be anywhere in the file like other declarations can
15:14:44 <Lokathor> so that you could put an import right next to the funciton that uses it
15:15:18 <ElMoloko> just write the import as a comment?
15:19:29 <Cale> Lokathor: I kind of agree, but then determining what all the imports are becomes annoying, so it's kind of a tough call
15:20:03 <Lokathor> well if only haskell had a proper IDE :P
15:20:05 <Lokathor> ah well
15:20:07 <Lokathor> some day
15:21:04 <pikajude> > let ~(x, 1) = (2, 2) in x
15:21:06 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern (x, 1)
15:21:09 <pikajude> wot
15:21:15 <monochrom> use Norman Ramsey's noweb so you can write code in any order you want. https://www.cs.tufts.edu/~nr/noweb/
15:22:35 <mauke> "This site is a member of the Literate Programming Web Ring"
15:23:10 <Lokathor> monochrom, i think i'll survive with my imports at the top
15:23:15 <monochrom> :)
15:24:34 <monochrom> "let" already implies an outermost ~
15:25:05 <monochrom> therefore the surprise is with how much an outermost ~ does and doesn't
15:25:56 <pikajude> ~(~x, ~(1))
15:26:26 <monochrom> in fact the most precise placement is (x, ~1)
15:29:32 <monochrom> it is a good exercise to read up the Haskell 2010 Report for real, and use "3.17.3 Formal Semantics of Pattern Matching" to work out things. (not folklore, not intuition, not any informal warm-fuzzy essay)
15:31:19 <happyfeet> a command to close the window in gloss? (something that reproduces what the 'esc' key does)
15:55:05 <koz_> What's a good way of getting the most common element from a list?
15:56:16 <dmj> koz_: put it into a Map Key (Frequency :: Int)
15:57:46 <koz_> dmj: Thought so. Thanks.
15:58:29 <dmj> :t \val map' -> Data.Map.insertWith (+) val 1 map'
15:58:31 <lambdabot> (Num a, Ord k) => k -> M.Map k a -> M.Map k a
16:05:18 <tommd> happyfeet: Just handle the ESC key down event with exitSuccess (from System.Exit)
16:05:31 <tommd> See mellow for an example.
16:06:02 <happyfeet> thanks tommd :)
16:06:29 <tommd> Here's what I do in mellow: defaultEventHandler _ (EventKey (SpecialKey KeyEsc) _ _ _) _ = exitSuccess
16:08:24 <happyfeet> tommd it worked :)
16:09:18 <tommd> Hurray!  Happy hacking!
16:13:58 * hackagebot aeson-casing 0.1.0.3 - Tools to change the formatting of field names in Aeson  instances.  https://hackage.haskell.org/package/aeson-casing-0.1.0.3 (andrewrademacher)
16:18:59 * hackagebot aeson-casing 0.1.0.4 - Tools to change the formatting of field names in Aeson  instances.  https://hackage.haskell.org/package/aeson-casing-0.1.0.4 (andrewrademacher)
16:55:15 <carmethene> I have a newbie functional question, will try to be as concise as possible...
16:55:35 <carmethene> one of the exercises I have is to implement a parser for a simple language along the lines of
16:55:46 <carmethene> a = b OP c, or a = <val>
16:56:16 <carmethene> so you have a bunch of these statements in a file, and the question is "what is the value of x?" and you just walk the graph and figure out the answer
16:56:44 <carmethene> so I've solved it with a Data.Map var code and all is great
16:56:51 <carmethene> + memoize to make it not suck
16:57:29 <carmethene> but here's the bit I'm wondering: Haskell itself is basically doing this work
16:57:45 <carmethene> my program is a tree, and the program I'm parsing is a tree
16:58:02 <carmethene> and I can't help but feel like implementing a parser and an evaluator for something so simple is in some way duplicating work
16:58:23 <carmethene> like my solution should really be to load the source file directly into Haskell itself and evaluate it
16:58:42 <carmethene> don't know if that makes sense?  Is that a thing that can be done?
16:59:21 <geekosaur> I imagine the point is to see if you can implement a parser properly, not to be efficient.
16:59:38 <carmethene> oh it's this advent of code thing, it's not a school assignment
16:59:43 <carmethene> just online puzzles
17:00:37 <carmethene> I'm learning Haskell of my own volition here
17:00:45 <carmethene> I guess I'm wondering if there's some deeper insight into parsers that I'm missing
17:00:53 * carmethene hasn't touched this stuff since university really
17:00:54 <geekosaur> That said, you'd still need to do parsing on some level to load it, and the difference between reading a human-somewhat-friendly format and the most efficient external format that could be turned into an AST in memory is not likely to be very large
17:01:18 <carmethene> well what about something like the read command?
17:01:39 <geekosaur> C can --- sometimes --- get away with dumping and loading memory images. historically a number of programs have done so. It's not portable and is prone to breakage when you change the wrong thing in the program
17:01:46 <geekosaur> read is actually very inefficient
17:01:53 <carmethene> i.e. if I implemented my parser as read, I could load the AST straight into Haskell code
17:02:11 <carmethene> ok, I think I see what you're saying
17:02:29 <geekosaur> about the only thing it has going for it is it works with standard Haskell. a custom parser will almost always beat it
17:02:53 <carmethene> so I'm right to stick with my own definition of the AST format and to implement a lexer, etc
17:03:03 <carmethene> and not try to do something clever by loading directly into Haskell itself
17:03:11 <carmethene> here's an example:
17:03:22 <carmethene> if one line of my AST is "a = b OP c"
17:03:30 <carmethene> and I need to find the value of b
17:03:51 <carmethene> with my solution as-is, I have to do some lookup of my own on b (Data.Map + memoize right now)
17:04:12 <carmethene> but if b was an actual bound name in the Haskell code, I wouldn't have to do anything
17:04:42 <carmethene> but from what you said, that's not actually a smart approach
17:04:59 <carmethene> I can't get things into the language that deeply without penalties
17:05:02 <carmethene> did I understand correctly?
17:05:57 <carmethene> geekosaur: thank you btw
17:06:40 <geekosaur> well, read / show is extremely inefficient. there are other ways but they have their own tradeoffs
17:07:02 <geekosaur> but something to remember with things like this is: you generally want a format that is friendlier for humans
17:07:19 <carmethene> yes, I guess that's a good point
17:07:31 <geekosaur> you could make something faster than a text parser using binary or cereal, but good luck debugging a problem with the data
17:07:32 <carmethene> for any practical purposes, that kind of hackery would hurt
17:07:50 <carmethene> geekosaur: ok then
17:08:12 <carmethene> as I said, I was wondering if I was missing some deeper insight into the language, but it sounds like I'm on the right track
17:08:16 <carmethene> again, thank you
17:09:52 <geekosaur> right, the key here is less the language than recognizing that we use computers to make things easier for us
17:10:10 <geekosaur> don't optimize for the computer or for the language. optimize for *making your life easier*
17:10:14 <carmethene> yes, that is a good lesson
17:11:28 <carmethene> btw I certainly wasn't looking for an answer like "hey, if you get this pointer you can inject stuff into the parser!"
17:11:40 <carmethene> more if there were some clever language constructs or such
17:11:56 <geekosaur> well, the closest thing we have to that is quasiquoters
17:12:10 <geekosaur> *but* you still need to write something to read it... which means a parser. so, no win
17:12:20 <carmethene> well that's something new for me to read :)
17:12:24 <geekosaur> and while show/read look like Haskell, they are not Haskell
17:12:33 <carmethene> this language is a chasm of learning
17:12:49 <carmethene> I feel like if I keep going, at some point I'm going to get a degree-level math education
17:12:54 <carmethene> just from the syntax
17:13:10 <geekosaur> at least, not reliably so. and they don't handle things like circular references (they'll be flattened/duplicated)
17:13:23 <carmethene> ah yes, very good point
17:13:41 <geekosaur> they're really an idiot mode thing, barely good enouh for debugging and that's about it
17:13:46 <hodapp> show/read look like Haskell but are not Haskell? Wha?
17:13:59 <hodapp> oh, their outputs particularly?
17:14:11 <carmethene> ok, I saw something in one of the stack overflow questions that said using read/show for actual code purposes is basically an abuse
17:14:18 <carmethene> much like you said, debugging only
17:14:19 <geekosaur> they don't try very hard, they're slow, the built in instances generally produce something you could cu and paste into Haskell but library-provided instances could do anything they want
17:14:50 <carmethene> show is fine for Integer -> String, though right?
17:14:57 <carmethene> we're just talking about more complex uses?
17:15:24 <geekosaur> well, how complex do you want to get?
17:15:34 <carmethene> fair enough
17:15:36 <geekosaur> just for starters, you are building a Map --- this will serialize as a list
17:15:48 <geekosaur> which is already pretty slow
17:15:51 <carmethene> I'm still at the beginner stage, so...
17:16:25 <carmethene> ok hometime
17:16:33 <carmethene> thank you very much for your time :)
17:16:40 <geekosaur> (Map hides its internals so it can safely use an ordered fingertree representation. if you could get at the internals, you could build a Map with inaccessible entries)
17:19:22 <hodapp> map with inaccessible entries? sounds mysterious.
17:20:09 <geekosaur> actually you can do that now, just use Double as the key type and store NaNs >.>
17:20:31 <geekosaur> floating point breaks Ord
17:43:26 <zoku> barrucadu: irc-client is built on types from the irc package, no? I can't seem to use `encode . _message` to get the raw message contents
17:52:58 <zoku> barrucadu: sorry I got it, `show . _message`
17:53:09 <lyxia> zoku: the Message type that's exposed by irc-conduit is not the same as the one exported by irc
18:00:36 <zoku> ah, thanks lyxia 
18:00:42 <zoku> sorry I am fairly new
18:00:59 <zoku> gah, looks like I can't IO.hPutStr from an EventHandler
18:01:11 <zoku> since this is expecting IRC (), not IO ()
18:01:39 <pavonia> liftIO?
18:07:18 <Lokathor> mild confusion, forever :: Monad m => m a -> m b
18:07:21 <Lokathor> where is the b coming from?
18:08:48 <pavonia> It never returns a value, so that's the most general type
18:09:24 <Lokathor> huh
18:09:31 <Lokathor> figured it would have had to be m a -> m a
18:11:03 <pavonia> If it runs the action over and over again, it will never return a result, so the return type can't contain 'a'
18:11:12 <pavonia> @src forever
18:11:13 <lambdabot> Source not found.
18:11:35 <pavonia> :t let forever m = m >> forever m in forever
18:11:37 <lambdabot> Monad m => m a -> m b
18:11:38 <dramforever> I hope this is not off-topic here: Does anyone know of an intuitive proof of the strong normalizing property of the STLC?
18:11:46 <zoku> yay! that did it pavonia 
18:11:47 <zoku> thank you
18:11:56 <pavonia> np
18:12:13 <zoku> just for clarity, that is a transformer, that transofrms the IO monad into something else?
18:12:15 <dramforever> Just like, you know, why the STLC "should" terminate
18:12:52 <pavonia> zoku: It a function that lifts any IO action into the MonadIO monad
18:13:14 <dramforever> :t System.Exit.exitSuccess -- Lokathor: It's similar over here
18:13:16 <lambdabot> IO a
18:13:39 <Lokathor> i'm not sure why never returning a result means that the result can't be some particular type i guess
18:14:01 <Lokathor> clearly, b could also be a anyway
18:14:28 <dramforever> Lokathor: well, IIUC it's exactly the opposite. It can be *any* particular type
18:14:54 <Lokathor> suppose
18:15:37 <pavonia> You could specialize the type to return m a, but that's not the most general type
18:18:34 <pavonia> :t (>>)
18:18:36 <lambdabot> Monad m => m a -> m b -> m b
19:09:03 * hackagebot vinyl-vectors 0.2.0 - Vectors for vinyl vectors  https://hackage.haskell.org/package/vinyl-vectors-0.2.0 (andrewthad)
19:22:12 <roconnor> This paper has an interesting definition of what denotational semantics is:  semantics that is inductive on the langauge syntax.
19:25:45 <koz_> Could someone help me figure out the right way to phrase the call here? http://paste.rel4tion.org/163
19:26:18 <koz_> NClassifier is {arity :: Natural, root :: Maybe (Tree a)}
19:28:14 <koz_> I basically need to find a way to call classifyRec (which expects [Tree a]) by 'unpacking' a Maybe (Tree a), and I'm not sure how to do that.
19:28:24 <koz_> liftM only goes Maybe (Tree a) -> Tree a.
19:28:42 <roconnor> koz_: >>= maybe
19:29:26 <roconnor> I should look at your paste bin
19:29:32 <koz_> roconnor >>= would give it a Tree a if it were Just Tree a. I need to give it [Tree a].
19:30:41 <verement> koz_: Data.Maybe.maybeToList ?
19:31:10 <roconnor> or Data.Foldable.toList
19:31:51 <koz_> verement: I'll check that out - it *sounds* like what I'm seeking.
19:33:33 <koz_> verement: Yup, that's what I wanted - thanks!
19:37:18 <koz_> THe Haskell Wikibook gave me the idea of using lists for nondeterminism.
19:39:04 * hackagebot SDL-image 0.6.1.2 - Binding to libSDL_image  https://hackage.haskell.org/package/SDL-image-0.6.1.2 (fffaaa)
19:39:24 <koz_> Also, what framework do you folks recommend for 2D graphics?
19:39:36 <koz_> Like, if I wanna draw stuff on the screen.
19:44:58 <lispy> koz_: gloss is probably the easiest one to get going with
19:45:19 <lispy> http://gloss.ouroborus.net/
19:55:08 <lingxiao> hey all
19:56:02 <lingxiao> does any one know how to make a conduit pipeline `pipe = source $= Conduit a (StateT Int m) a  $= Conduit a (StateT Int m) a $$ sink` 
19:56:36 <lingxiao> so that running the pipe gives me two states
19:56:48 <lingxiao> as it stands the two states are combined into one somehow
20:08:28 <albeit> When I use Double with Storable, values of 0 are being read back in as extremely small values (like 5.0e-324). Why is that?
20:10:53 <verement> does it also happen with CDouble?
20:17:24 <codebje> well, I was going to do a 12-part blog series on the 12 abstractions of christmas, but three abstractions in I realised I was just rewriting the typeclassopedia, badly
20:17:38 <codebje> so perhaps I should just write a monad tutorial and call it a day
20:20:44 <Lokathor> if a transaction deadlocks, will its thread be killed?
20:21:02 <Lokathor> if an STM transaction* that is
20:21:30 <solrize> deadlock isn't supposed to happen, i thought
20:22:01 <Lokathor> well it won't if things are reading and writing properly, but if one thread is writing to a TChan and one is reading from the TChan
20:22:05 <Lokathor> and the writer dies
20:22:14 <Lokathor> will the reader be killed automatically after some period of time?
20:22:19 <solrize> hmm
20:22:26 <solrize> i do semi-remember something like that
20:22:30 <solrize> look in RWH
20:22:45 <Lokathor> i'm sure it's in the big book
20:23:14 <verement> albeit: I can't reproduce what you're seeing. Care to post your code?
20:23:40 <geekosaur> it should catch an exception
20:24:14 <Lokathor> geekosaur, was that to me?
20:24:19 <geekosaur> yes
20:24:37 <geekosaur> blockedindefinitely exception iirc
20:25:04 <Lokathor> the reading thread would catch an exception? Well.. hmm. I guess that's fine. I just want it to go away, and it wouldn't be holding any special resources in this situation
20:25:15 <Lokathor> well, it wouldn't exclusively hold any at least
20:27:32 <haknick> Hey
20:30:48 <verement> albeit: one thought is that you might be reading/writing a misaligned address
20:33:41 <mjrosenb> has anyone migrated code from the reactive-banana-0.9 to reactive-banana-1?  I'm having some issues with the new monadized interface
20:39:43 <albeit> verement: Thanks, turns out I had mixed up the order of a tuple in a function's return, and was just auto-deriving the type, so I didnt catch it
20:39:59 <albeit> Twas reading Int64's as Double's
20:40:22 <verement> aha
21:16:00 <jle`> hi all, i was trying to profile my library by profiling a project that uses it
21:16:19 <jle`> but, no dice.  the library functions seem to be opaque from the profiling output
21:16:41 <jle`> is there a way to see the cost centers/how much time is spent within the library's methods themselves?
21:16:47 <jle`> or is the only way to actually profile the lib?
21:16:59 <jle`> (the cabal project containing the actual library)
21:23:28 <yuan> Does anyone know how can I run several system processes in turn? That is, wait for process A finish before running process B.
21:24:41 <Axman6> https://hackage.haskell.org/package/process-1.4.1.0/docs/System-Process.html would be the best place to start yuan 
21:39:07 * hackagebot ihaskell 0.8.3.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.8.3.0 (gibiansky)
21:39:09 * hackagebot ipython-kernel 0.8.3.0 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.8.3.0 (gibiansky)
21:46:18 <ReinH> yuan: I would suggest the async package
21:52:57 <athan> Anyone here use the vcache package? Thinking about trying it out for a quasi-persistent session cache
22:16:11 <nilg> I'm looking for something like zip but that builds all the combinations instead.
22:17:17 <MarcelineVQ> > (,) <$> [1..3] <*> [4..6] -- like this?
22:17:19 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:18:02 <nilg> MarcelineVQ: I looks great (except I don't understand it)
22:18:09 <nilg> I->That
22:19:06 <MarcelineVQ> Have you seen a list comprehension before?
22:19:36 <nilg> Yes
22:19:48 <MarcelineVQ> I ask because if you do understand those you can do the same thing with one
22:19:53 <MarcelineVQ> > [ (x,y) | x <- [1..3], y <- [4..6]]
22:19:56 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:19:59 <MarcelineVQ> And it might be clearer
22:20:30 <nilg> > :t <$>
22:20:31 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
22:20:37 <MarcelineVQ> :t (<$>)
22:20:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:20:42 <nilg> > :t <*>
22:20:44 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
22:20:49 <nilg> ah, OK, thanks
22:21:43 <codebje> nlilg, <$> is just fmap
22:21:56 <codebje> nilg, sorry for typo :-)
22:24:08 * hackagebot sbp 0.52.0 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.52.0 (markfine)
22:24:42 <codebje> :t (<*>)
22:24:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:25:04 <codebje> and the tie operator applies some function in a context to some value in a context - it's fmap where the function is also in the "functor"
22:29:39 <jle`> nilg: you can also try liftA2, which you can think of as a "do this to all combinations" operator for lists
22:29:40 <jamesfordummies> I am using Network.Socket like so: http://lpaste.net/943236734450139136
22:29:46 <jle`> > liftA2 (,) [1..3] [4..6]
22:29:49 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:29:54 <jamesfordummies> and when I use `send` on that socket, it splits the data up. why?
22:30:12 <jle`> nilg: liftA2 (,) xs ys means "do (,) to all possible pairs of xs and ys"
22:30:45 <glguy> jamesfordummies: stream sockets don't try to preserve read/write boundaries
22:31:08 <jamesfordummies> glguy: :/ dammit
22:31:46 <glguy> If you want to send packetized information on a stream socket you'll need to add some explicit message framing
22:32:05 <jamesfordummies> glguy: and then reconstruct later on‚Ä¶ unfortunately I have no control over the receiver
22:33:08 <jamesfordummies> glguy: anything I can do to reduce the number of splits?
22:57:41 <carmethene> tonight's maybe stupid question, if I'm defining a function that operates as a transform, let's say a datastructure insert
22:57:56 <carmethene> myFunc :: Structure -> Value -> Structure
22:58:07 <carmethene> vs myFunc :: Value -> Structure -> Structure
22:58:18 <carmethene> is there some reason or convention for doing one vs the other?
22:58:32 <carmethene> I understand the implications for, say foldl vs foldr
22:58:59 <carmethene> but in most of the literature I've seen, the value is the first arg
22:59:24 <carmethene> and it just kinda feels like a partial application of the datastructure would be more useful
23:01:05 <jamesfordummies> does anyone know why a Stream Socket would split up data?
23:01:26 <jamesfordummies> i was under the impression the point of Stream was that it doesn‚Äôt do this
23:03:45 <jle`> carmethene: in these cases it usually comes down to which one you see yourself partially applying more often
23:04:17 <carmethene> so there isn't an accepted convention?
23:05:10 <jle`> some forms work better with certain higher order functions...so if you use those functions, matching them up would be nice.  but no, this is a bit too broad of a thing to be able to give a meaningful broad enough answer, heh.
23:05:24 <carmethene> no that's great, thanks
23:05:45 <carmethene> I don't have sufficient perspective to understand that it's too broad a question
23:05:45 <jle`> but, if you change something and return a value in the process, then a -> s -> (b, s) is more common than s -> a -> (b, s)
23:06:02 <carmethene> ok that helps too
23:06:03 <jle`> this is because `s -> (b, s)` is a very common pattern
23:06:16 <jle`> so a -> (s -> (b, s)) makes it useful for combinators like State
23:06:34 <carmethene> understood
23:06:52 <jle`> State is basically a newtype to be able to manipulate/combine functions of the form s -> (b, s), so that's convenient...but...it's not a hard and fast rule, either
23:07:25 <jle`> i actually had to decide between an a -> s -> (b, s) vs. s -> a -> (b, s) the other day and i opted for the second one, because the argument order made more sense and it made more sense to partially apply that way
23:07:56 <jle`> and, if anyone did want to use it with State/other combinators that like s -> (b, s)'s, they can always use a lambda or something
23:08:12 <carmethene> the background is that basically I'm very new to functional, but I have a lot of experience with imperative
23:08:22 <carmethene> so I'm learning lots of new concepts and I'm trying to develop good habits early on
23:08:31 <jle`> yeah, so my best answer would probably be, whatever makes the most sense to partially apply
23:08:37 <carmethene> these things are too subtle to be covered by the literature, sadly
23:08:44 <carmethene> yep, that's really good advice, thank you :)
23:09:13 <jle`> there are a lot of combinators that do expect functions in certain forms, but you can always use lambdas/flips to make them work for that :)
23:09:36 <carmethene> ooh, I need to learn what a flip is now
23:09:54 <carmethene> ah literally just flipping the order, neat
23:09:58 <jle`> it's just shorthand for a common lambda, heh
23:10:04 <jle`> so instead of writing \x y -> f y x, you can just write flip f
23:10:14 <carmethene> that's so useful
23:10:21 <carmethene> C++ has ruined me I think :)
23:10:43 <jle`> yeah, sometimes i take easy higher order functions for granted :)
23:11:06 <bitemyapp> carmethene: learning things can't ruin you :)
23:11:43 <jle`> the more haskell you do the more combinators/hof's you run into that you'll recognize like certain patterns of function arguments over others, so that might subtly influence what you do on a day to day basis.  but it really isn't that big of a deal in the end...there are more important things to worry about, heh
23:12:07 <carmethene> bitemyapp: oh I don't know, you start learning enterprise and the next thing you know it's proxy factory beans all the way down
23:12:35 <carmethene> jle`: that really does make sense 
23:12:51 <carmethene> I'm having trouble reconciling my intuition against my fear that I'm missing insight
23:13:16 <carmethene> I guess the wonderful thing about code is that it's generally cheap to rewrite
23:13:22 <carmethene> at least at the scale of a personal project
23:14:57 <jle`> easy/safe rewrites are actually one of my favorite parts about haskell :)
23:15:04 <carmethene> oh yeah
23:15:18 <jle`> the difference becomes much more noticeable even for large projects, heh
23:15:36 <dmj> it's true, swapping out web frameworks is no problem
23:15:46 <carmethene> part of the impetus for re-learning functional was to get better habits re not holding state and not using side effects
23:16:41 <carmethene> I work on game engine type stuff, which can easily become spaghettified quickly in the name of efficiency
23:16:44 <carmethene> :S
23:18:30 <jle`> :S
23:18:54 <jle`> state is nice, but it's easy to have it grow beyond being able to reason about, and easy to use it as a crutch where it's not even necessary
23:19:06 <carmethene> the latter is my point exactly
23:19:40 * hackagebot stm-conduit 2.7.0 - Introduces conduits to channels, and promotes using conduits concurrently.  https://hackage.haskell.org/package/stm-conduit-2.7.0 (ClarkGaebel)
23:39:15 <haskell-learner> hello, if i have a data type of data Map k v = M (k -> Maybe v) and want to join them i.e joinMaps :: Eq k => Map k v -> Map k v -> Map k v, how do i get the keys to check if they're in both maps to even insert or update?
23:42:37 <kadoban> haskell-learner: You don't have to "get" the keys. Your result is a (wrapped-in-M) function that /given/ a k, gives a Maybe v.
23:42:38 <liste> haskell-learner just combine the two "k -> Maybe v" functions into a new one
23:43:26 <haskell-learner> thanks i'll try
23:44:41 * hackagebot rtcm 0.1.3 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.1.3 (markfine)
