00:07:39 * hackagebot opencog-atomspace 0.1.0.2 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.2 (romanT)
00:07:39 * hackagebot sscgi 0.3.1 - Simple SCGI Library  https://hackage.haskell.org/package/sscgi-0.3.1 (ChrisForno)
00:35:21 <Unhammer> how can I pass -threaded to a cabal repl?
00:35:37 <Unhammer> (and how can I verify from within gchi(-ng) that -threaded is set?)
00:37:18 <shachaf> -threaded is a link-time flag. It doesn't affect ghci.
00:41:09 <Unhammer> so things like runInBoundThread wont work in ghci?
00:42:35 * hackagebot conduit-iconv 0.1.1.1 - Conduit for character encoding conversion.  https://hackage.haskell.org/package/conduit-iconv-0.1.1.1 (slomo)
00:50:38 <pavonia> Unhammer: -threaded is implicitly set in GHCi
00:52:42 * hackagebot templatepg 0.2.7 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/templatepg-0.2.7 (ChrisForno)
00:57:32 <xecycle> is there a `[m [a]] -> m [a]` that concats lists inside?
00:59:27 <xecycle> ah got it, foldl1 (liftM2 (++))
01:00:28 <xecycle> but have to say I have no idea what this means when later reading it
01:03:03 <jle`> xecycle: you can sequence and concat :)
01:03:09 <jle`> probably better than the partial foldl1
01:03:27 <jle`> :t \xs -> concat <$> sequence xs
01:03:29 <lambdabot> (Monad f, Traversable t) => t (f [a]) -> f [a]
01:03:52 <xecycle> jle`: thank you :)
01:03:54 <jle`> xecycle: sequence :: [m [a]] -> m [[a]]
01:05:40 * frerich wonders how you can come up with 'foldl1 (liftM2 (++))' without thinking of concat, fmap and sequence first. :-]
01:08:39 <xecycle> well, because the input is a list and outputs a single value, so fold comes up; then it becomes m [a] -> m [a] -> m [a], which is obvious.
01:10:50 <frerich> xecycle: Interesting trail of thought, that wouldn't have occurred to me. I first saw '[m x] -> m [x]' and thought of sequence. And then I noticed that 'x ~ [a]', so that got me to fmap'ing concat :-]
01:25:11 <hsk3> Is someone here reading Haskell Programming?
01:25:16 <hsk3> http://haskellprogramming.com
01:25:31 <hsk3> Err, sorry
01:25:37 <hsk3> http://haskellbook.com
01:27:48 <Black-Wolf> hsk3, noup
01:29:32 <merijn> hsk3: Given that there's 1400 or so people, presumably some of them are ;)
01:35:37 <hsk3> bitemyapp is the author
01:35:45 <hsk3> so i'll just ask him, and hope someone else will chime in
01:35:55 <hsk3> (if he's not here now)
01:38:45 <pavonia> hsk3: Why not just ask your question and see if anyone can answer?
01:40:49 <hsk3> bitemyapp: I'm reading your sample PDF. I like it, but I'm puzzled because I feel like the only reason I understand it because I already know some Haskell (through LYAH).
01:40:50 <hsk3> For instance, in chapter 1 in "conventions for variables", you're describing conventions for type variables. I can understand this because I know what type variables are from earlier knowledge, not from earlier in your book.
01:40:51 <hsk3> So I'm wondering about the claim that this is a book suitable for beginners in Haskell (let alone as a book that teaches you your first programming language!).
01:40:51 <hsk3> Your thoughts?
01:41:20 <hsk3> s/what type variables are/what type signatures are
01:49:20 <Unhammer> I'm following https://wiki.haskell.org/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code but it only works from ghci, with runhaskell or compiled programs the program hangs whenever the callback should be called – why would this be? (my callback just does "return 0")
01:49:42 <Unhammer> (with runhaskell, I even have to C-z and kill %% )
01:50:12 <basicProblem> case: sum digits of each integer in a list of integers. 
01:50:21 <basicProblem> with "sumDigits :: [Integer] -> Integer"
01:50:33 <basicProblem> how do i go about solving this?
01:50:45 <Cale> basicProblem: Try doing it for one integer first
01:51:15 <Cale> and note that
01:51:21 <Cale> > divMod 12345 10
01:51:23 <lambdabot>  (1234,5)
01:51:26 <basicProblem> i did. using `mod` and `div`
01:51:29 <Cale> yeah
01:51:46 <Cale> okay, so you presumably want to apply your function to each element of the list
01:51:49 <Cale> and then sum the list
01:52:23 <basicProblem> yes
01:53:33 <basicProblem> i find difficulty in understanding that this can be done without type conversion.
01:54:11 <basicProblem> or creating a new list of digits for an integer with more than one decimal places
01:55:25 <basicProblem> all this in one function.
01:55:39 <liste> basicProblem one function can consist of multiple, smaller functions
01:56:22 <basicProblem> @liste with "sumDigits :: [Integer] -> Integer"
01:56:22 <lambdabot> No module "with "sumDigits :: [Integer] -> Integer"" loaded
01:56:45 <basicProblem> yup
01:58:10 <frerich> basicProblem: Can you define 'crosssum :: Integer -> Integer' which yields the sum of all digits of a given number, e.g. 'crosssum 123 == 6'?
01:58:45 <basicProblem> @frerich im afraid not 
01:58:45 <lambdabot> Unknown command, try @list
01:58:58 <liste> basicProblem why not?
01:59:11 <liste> is it explicitly forbidden in your assignment?
01:59:14 <Cale> basicProblem: btw, if you prefix your messages with @, the bot will try to interpret them, so don't do that ;)
01:59:26 <basicProblem> well this is a lab problem for a haskell mooc
01:59:47 <basicProblem> thanks Cale, noted 
01:59:57 <frerich> basicProblem: As a prerequisite - can you define 'digits :: Integer -> [Integer]' which yields all digits for some number, e.g. 'digits 123 = [1,2,3]'? I'd suggest to split this problem into smaller parts: getting the digits of some mnumber, summing the digits - and then applying that logic to all elements of a list and then summing the sums.
02:01:12 <liste> basicProblem did the mooc already teach anything about let or where?
02:01:48 <basicProblem> frerich i understand breaking up into smaller parts. i'd like to know the solution without doing in such a manner
02:02:51 <basicProblem> liste yes
02:03:33 <basicProblem> liste we had types and classe, defining functions, list comprehension in the previous weeks
02:04:21 <basicProblem> and this lab is in recursivefunctions
02:05:34 <ChristianS> basicProblem: breaking problems into smaller problems is essential for *any kind* of problem solving, it's not something to want to do without
02:05:40 <liste> basicProblem then you can use let or where to define functions that solve parts of that problem
02:05:53 <liste> without defining any extra top-level functions
02:06:13 <basicProblem> liste can you please guide me how i can do that
02:06:59 <basicProblem> ChristianS i guess haskell is totally about breaking down problems. yes, I love it! :)
02:08:02 * frerich thinks something somewhere went wrong if the course went for weeks and now recursion poses problems
02:08:43 <basicProblem> also if anyone want to look at the github repo of the mooc -> https://github.com/fptudelft/FP101x-Content-2015
02:09:08 <liste> @let doubleAndIncrement x = increment (double x) where { increment x = x + 1; double x = 2 * x } -- basicProblem
02:09:10 <lambdabot>  Defined.
02:09:13 <basicProblem> or maybe frerich i am a bad student 
02:09:17 <liste> > doubleAndIncrement 5
02:09:19 <lambdabot>  11
02:10:14 <liste> basicProblem the "@let" part is just instructions to lambdabot to define a top-level function, just like you'd write it in a file
02:10:27 <basicProblem> hmm
02:11:00 <liste> and braces and semicolons can be replaced with correct indentation and line breaks
02:11:25 <Cale> basicProblem: Can you express (in English) the sum of the digits of a positive number, in terms of its quotient and remainder after division by 10, and perhaps using the sum of the digits of a smaller number?
02:11:25 <basicProblem> holy moly! lambdabot is awesome!
02:15:43 <basicProblem> Cale: Well, I would add remainder of the integer to recursive of "the quotient of the integer when divided with 10 and so on..."
02:17:14 <basicProblem> this is for a single integer
02:17:57 <basicProblem> all of this would go into "let" from what liste 's example
02:18:25 <basicProblem> >
02:18:28 <basicProblem> * ?
02:20:01 <liste> basicProblem maybe start with the `digits' function frerich talked about earlier
02:20:29 <Unhammer> to answer my own question, my callback was called from an import I had termed "unsafe", it has to be "safe"; compiling my test binary without -threaded gave me a hint about it
02:20:53 <merijn> Unhammer: Yeah, don't use "unsafe" unless you know what you're doing (in fact, even then don't ;))
02:21:20 <merijn> Unhammer: It's a bit confusing, but "foreign import unsafe" means "import in an unsafe way", not "import something unsafe" :p
02:23:38 <Unhammer> yeah … I blame RWH ("for efficiency we mostly use "unsafe" calls
02:23:40 <Unhammer> )
02:24:03 <basicProblem> liste thanks! will check `digits` function docs like frerich suggested 
02:24:07 <merijn> Unhammer: Basically, safe calls happen in a separate thread, ensuring you don't block haskell code/GC/etc.
02:24:14 <Unhammer> (well, really I should blame myself for early optimising =P)
02:24:19 <liste> basicProblem there isn't such a function
02:24:24 <liste> you need to define it yourself
02:24:26 <Unhammer> aha
02:24:31 <merijn> Unhammer: unsafe is the same as inline calling a C function. i.e. until the C function returns haskell code can't run on that thread, GC can't run, etc.
02:24:34 <liste> inside the where (or let, if you so prefer)
02:24:53 <basicProblem> oh yea. <facepalm>
02:25:07 <merijn> Unhammer: So it's cheaper if you wanna call like very small C functions (i.e. I want call something like sin/log/some other fast math function without overhead
02:25:21 <merijn> Unhammer: But if you call long running/blocking functions things will break fast
02:25:36 <basicProblem> thanks guys! liste, Cale and frerich. Cheers!
02:26:12 <Unhammer> hm ok
02:27:22 <liste> basicProblem you're welcome (: come back if you have further questions
02:35:17 <remdezx> Hi! How do I enable ghc as a library using runhaskell?
04:26:30 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
04:26:30 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
04:26:30 --- names: list (clog razi1 fujimura luluapple simukis__ zarnet quicksilver cereal_killer_ xfbs sepp2k Yuras perspectival peterhil_ hellertime abrar RaceCondition hzjd NingaLeaf mizu_no_oto nkhodyunya amurru petermw native_killer takle philipd_ Roargh TheArtist carlosgaldino tg ttt_fff opencard merijn Mon_Ouie rodlogic jleitgeb sdothum edwinvdgraaf CoderPuppy kam270 pacak akegalj johtso edon silver ddere beekeeper mephx tippenei1 othll0 aivuk_ Sornaensis weiwen mceier)
04:26:30 --- names: list (oscar_toro rrbm238 kwisatz francesquini Itkovian Sorella ryan_vw nilg slomo lkba funfunctor albertus1 kamatsu bjz healthire oish elSamu Jackneill zeroed Cyberg justanotheruser Perkol tzaeru RegEchse nani___ javjarfer dadaro inhortte hsk3 marr sigma914 shangxia1 SoupE jesusgollonet howdoi _ingo Rutger` hamishmack donwilliam Ziltrum eklavya andjjj23 homam morolin_ pytmand alem0lars skarn svlada micmus SegFaultAX dedgrant Stratege raichoo castlelore araujo)
04:26:30 --- names: list (boxfire frerich unsymbol dmag_ skiold hackagebot forgottenone Guest53187 fedorafan cow_2001 svp__ predator117 takuan edsko Sindriava quchen joneshf-laptop paaavo MrWoohoo2 MrWoohoo xahry free_beard grizwako wvdhaute skore_de plucas_ erikd _ashbreeze_ Nikotiini danvet ThomasLocke Wizek tjbp dsop myfreeweb vTurbine sekrit crazydiamond jhrcek vlatkoB xecycle CoconutCrab darkf sbyl hilquias` Bez_ PatrickRobotham shafox noraesae isenmann mgomezch_ vili dseitz)
04:26:30 --- names: list (otto_s_ zv mauke pavonia mjrosenb glguy_ doomlord badon gfixler JammyHammy nolraiU thunderrd saep _sjs s00pcan kingket dented42 m1dnight_ hucksy_ bb010g simplyianm Arahael DanielDiaz junmin Regulator9 juhp saulzar inr albertid_ zugzwanged mach SgtStroopwafel gseitz lspitzner hexagoxel exferenceBot Zekka Argue Tesseraction predator417 RayNbow`TU tortal kaol veltas Diabolik plutoniix Blkt zeroskillor arzig cfloare mirsal sea-gull otterdam Twey ahf LeaChim)
04:26:30 --- names: list (cbaines tekacs kqr demize myme statusfailed barrucadu Ornedan bjornars1 Guest88143 ttuegel adlan dmoon1221 jackp cogrendel teclo- vmeson ivan\ cognominal fibbel lexi-lambda codehero Factionwars fengshaun relrod reuben364 mystor aarvar Hijiri mechairoi mpickering thoughtpolice kjanosz vikram_____ sbauman Biohazard wenzowski Tritlo adamCS_ nurupo bitonic spicydonuts obihann shans_ joco42 rul TheCrafter sewilton harmchop kyagrd reem Heart__ milessabin dstockwell)
04:26:30 --- names: list (mbrock` {AS} alexlord bigs nrw dkua mankyKitty mbrcknl jorendorff jroesch kipd edwardk lambdahands RevJohnnyHealey jfokkan__ benjamingr_ S11001001 tjpeden AntiSpamMeta jo__ alphonse23__ jessicah` wizonesolutions mno2 cleichner nyandoge tarcwynne_ wyvern vqrs carter_cloud kirjs___________ zph mvr_ petems cstrahan zrl seanparsons andreypopp ocharles__ runeks mindos_cloud____ brt1 Church- tobiasgw zpconn__________ CARAM__ posco ggherdov rslima_ frelux tom39291)
04:26:30 --- names: list (lohkey caasih orcus chriswk TabAtkins jlyndon AlainODea fuziontech jonathanj__ n1ftyn8_ favetelinguis phuu Raynos Ewout bkolera arcanine si14 jonrh akahn tharper arnihermann aristid shennyg cojy etrepum hellschreiber_ glowcoil puzza007 strmpnk avdi_ joedevivo kjnilsson rstone xxpor Scorchin wunki lokulin folsen pchiusano yrdz`` DoYouKnow nisstyre OliPicard sublimate edofic jtobin haBuu^ doppioslash Coldblackice yminsky chris2 stasku_ _Vi sivoais nbouscal)
04:26:30 --- names: list (skulls Heero sclv biscarch _klm tazjin lancetw NemesisD emmanueloga lacrosse ChristianS martinhath sephiap stephe shelling__ roo bgyss trig-ger timloh ikke grandy att arianvp a3Dman kaictl agjacome moop martintrojer pdxleif jbalint quaestor1 fkurkowski noam dredozubov albeit catsup stux|RC-only notdan PlasmaStar Nik05 ahihi honkfestival larion acro dmwit pieter Brando753 ph88 so DarwinElf mitchty felixn Speed @ChanServ Eliel Guest30177 mads- julienXX bind)
04:26:30 --- names: list (eagleflo lulf thorkilnaur thomas jrib Clint gargawel_ glckr Watcher7 mathu sdboyer dexterph moredhel comboy micro_ nitrix shahn fall` agjohnst_ DylanJ Xandaros PHO alynn tomjagua1paw MarcelineVQ levi iDavid PinealGlandOptic low-profile Dodek alpounet andyo susmus GHCI ch3mical capisce isomorph1smes pi__ soija ski tkr cow-orker joeytwiddle supki tsani cdidd eyck gbarboza pyrtsa richi235 tdammers mrd jaaket surtn- zyoung_ kriztw petercommand pfeyz_ poucet Lemmih)
04:26:30 --- names: list (absence ft Belgarion0 fryguybob rphillips zyla_prati ephess_ fold3 JamesJRH earthy dhrosa_ __rlp Iceland_jack dschoepe Natch lassulus_ torpig zudov bjobjo Phillemann lokydor_ nille tokik brolin_empey fionnan_ rcsgns_ hanDerPeder hsyl20 kier thebnq EvanR lstrano numberten exio4 rjbs chaoxu1 ec\_ iElectric ethercrow kala dino-_ pontus jmcarthur Chobbes djellemah Ralith DDR geal nathanic ArcticMonkey Voldenet padre_angolano obcode_ coddinkn Ezku_ xou_ mak` opios)
04:26:30 --- names: list (Purry c_wraith cryon __main__ e4x_ Jellydog dcoutts elgot Bigcheese cnooner Zemyla gdsx hive-mind flounders gratimax Chousuke dmiles_afk greeny TheAuGingembre dixie_ schoppenhauer jre2 andrewsw stomp vodkaInferno Jaak Kavec wailord `0660 dutchie Cerise tusj lf94 joeyh jamiis ziman jvarg tismith imalsogreg__ rdema Fubar^ Vq tumdedum tsou rieper jotrk DustyDingo itsmonktastic oldmanmike magicman nomicflux anachrome serutsubi sword_smith KaneTW dolio koz_ ollef)
04:26:30 --- names: list (lonokhov przembot Tene liyang tpsinnem Unhammer cmn Guest79936 djanatyn rubberduck93 Cale sdx23 proteusguy nrolland epta chattered nrk- gpampara cinik bernalex robogoat sujeet amiller agrif tv zso tolt ploopkazoo tristero friden greymalkin Maxdamantus sarlalian jokester mikeplus64 happy0 anders^^ aandy byorgey demolithion denimuser gthorslund Flonk vin-ivar bob_twinkles Shockk jlewis cnr rofer a4j ngrud majjoha_ kaste tlevine cmccann horlicks zenzike xplat)
04:26:30 --- names: list (plhk_ spaceships rrrrob selckin magbo Razz noctux Niamkik Ptival opqdonut knyppeldynan solution gcollins Jonno_FTW sykora ion linduxed aweinstock benley yeltzooo tych0 fmapE Khruu jrslepak tedkornish Hafydd _6a68 bolmar sgronblo ninegrid kosmikus sternenseemann stiell xiaolin vishesh certainty mountaingoat Ring0` siddhu Th0mas fractalcat async_prince Profpatsch wayne Guest50975 tinydata bcoppens JPohlmann tnks sleepynate Paks lenstr bitemyapp cYmen solarus)
04:26:30 --- names: list (brtk RlyDontKnow flori KitC lispy Guest28969 SwashBuckla saiam osfameron cjay OutlawStar mjo APic mrowe_away lvh ozzloy Philonous ormaaj thorsten` Drezil superfatkappa amontez mmaruseacph2 ahungry SHODAN brennie froztbyte tgeeky cjh` Ke WarzoneCommand cods AWhetter ww stvc eikke RouxTheDay Bane^ ThePhoeron abbe Sigyn tessier kragniz Tehnix_ d-snp tetheno owa qnikst_ luigibozzo nyuszika7h Walther Hesfin cin_ reynir canta cold_sauce fergusnoble DANtheBEASTman)
04:26:30 --- names: list (chrzyki ruurd dario` Vbitz lpaste cschneid ircbrows- YuleAthas usr impure_hate Jaxan raid prefork_ jameseb SLi nchambers jgornick solatis sohum Taneb kungp Elsi Tiktalik Didac dpn` jcreekmore codebam LoganG integral pikhq bananagram gothos zopsi fredcy Fluent geekosaur rom1504 xnyhps borkdude SuperTux88 sevcsik drdo takeey alang mietek fyolnish squisher defanor finninde nesqi aloiscochard ibid Pamelloes PotatoGim josephle Saimeidae gws woffy gabiruh hyPiRion)
04:26:30 --- names: list (YP-Cloud rjeli GGMethos wtw ninzine mero 5EXAAAWDW LordDeath shapr Komplanar wagle troydm Johannes13 Kneiva simony vpm hrnz sbrg Dykam yamadapc buoto sleblanc joshc ousado_ karls besenwesen anders0 amx kyren z16 radix M-david M-mistake Deadhandd M-davidar hvr grol jcurbo Lutin` lol_ heath Adios etabot dh nuuit hpc benmos BillyIII jlouis davl Starfire CindyLinz martingale Laney ongy Deewiant majoh rausch jokleinn Xack abra0 Fylwind dreamdust Reyu monochrom)
04:26:30 --- names: list (newsham cscorley hydraz Nickeeh dogonthehorizon keko-2 zmanian_ ajmccluskey pkogan yaknyasn fabianvf Tazca noexcept minad psacrifice qguv taruti_ ElderFain funrep zxtx Nash_ Axman6 nathyong elementalest jayne cgfbee hooptw zerokarmaleft karshan mtesseract s4msung_ lpsmith jix aaronm04 topi_ pharaun bergmark phadej henrytill Guest3764 jrp6 sokoll rntz scpike_ yorick bbee hpd Rembane int-e reactormonk MalcolmReynolds luite magicflakes niko otulp monsieurp)
04:26:30 --- names: list (Phlogistique lyxia ByronJohnson buMPnet hemite Ankhers ThreeOfEight lamilami TimWolla niteria_ TheRealPygo optocoup1er klugez Matajon dzack cic Saizan [edwtjo] uwap CosmicRay deavidsedice DistantStar MasseR nopf tswett FUZxxl pwned platz cdk_ ggVGc Ravana icedev Gothmog_ nikola1 niluje zomg enetsee sbauer322_ dicioccio MitchW peddie tomboy64 syk0mantis lattenwald M2tias qz Nimatek indiffernet yarou navilan- yoho liste Dtgr sLite Draggor unknownln tero-)
04:26:31 --- names: list (rejerson69_ Desoxy wting maerwald Jello_Raptor nwf arcetera avocado iturri vieira Sgeo vodik tumdum shutdown_-h_now eyenx jcp guampa da-x grada dilinger sivs mgaare luzie marmalod1 drewdavis fingerzam1 wamaral bydo asjo Akii shadowdao rossberg sellout ninedotnine aaron7 clahey_ segmond atomi mniip derekv2 w5isp Kruppe Willis shelf o`connor c-rog regicidal Shandy 32NAAD58U XMunkki solirc lachenmayer diginet aatxe marienz killtheliterate brezel alanz jinblack)
04:26:31 --- names: list (staffehn geppettodivacin fnordbert divVerent KorriX_ noddy zimp1 obiwahn dejanr sm monokqr coeus_ davean flux leather ernst pootler aleator_ Kaini_ Igloo ppnkk glowcoil1 malglim_ ParahSailin_ spacebug_ luis japesinator_ m4lvin_ _guios klarrt spwhitt lambdabot martinbjeldbak tuv haasn R0b0t1 Erebe wedens jang irclogger_com M-Illandan Eagle_Erwin wto orzo Black-Wolf zhulikas metaf5 m00nlight__ Ulrar M-Quora killerpty monty hc rbocquet kmicu whoops bartavelle)
04:26:31 --- names: list (dlandau huonw Ferdirand valdyn fall_ jmct Xorlev augur M-ou-se sunnymilk Nahra`` koomi rikkus visi0n ess_sing RazorX nemesit|znc mw utdemir` Liskni_si perrier__ Forkk_ justin_smith Pucilowski jasonmay bd___ ben l3france Mandus spill marko_____ Wamanuz2 chu pranzor arw_ TheSpect1e neurogee1 tridacty1a pfoetche1 jstolarek burp_ Guest27898 krgn deni tomaw amharc jnoah Moto-chan phy1729 Tehnix Ov3rload robtaylor tromp__ slick hegge Sagi ricardo82 _flow__ seliopou)
04:26:31 --- names: list (sanitypassing Oxyd d3lxa srhb benzrf jackhill sajith Geekingfrog solidus-river ixian Cr8 acfoltzer frontendloader alevy mokus SenpaiSilver ChucklesTheBeard benonsoftware codebje Spaceghost averell hbar igniting darthdeus brixen spion Uptime wolf_mozart cjwelborn kristjansson tmssgn wrengr_away Reiser iross lyddonb tommd vikraman yvm octo_ theDon HylianSavior eamelink Guest31976 itscaleb jgertm whiteline xacktm iliastsi Guest48356 Klumben tromp_ MoALTz)
04:26:31 --- names: list (martianboy dbeacham avn rotcpy sw1nn ]OLI[ davesilva waamaral zemm fugyk dxld judwhite spindas __name__ shwouchk Atlanis condy ixti Bashmetim hausdorff wookiehangover FireFly statusbot ido Khisanth alarmmm MindlessDrone m0rphism liaod nindwen chishiki cocreature Cetusx kosorith Sonderblade Currier chaptastic __jim__` mudfog michaelpj_ capybara saurik_ davidtho1as leino_ Ashy_ cynick Myrl-saki shachaf derekbro1n cheater darkstalker rossimo_ heyj_ca Cathy)
04:26:31 --- names: list (gnusosa StoneToad pmade tnebel betawaffle pqmodn apo_ aparent _ari dustinm chirpsalot prkc asm89 lb5tr cyberlard td123 fikusz zymurgy chaker zaquest koala_man lukky513 AustinMatherne ortmage hodapp PierreM bshelden 17SAD5YK1 mendez noplamodo pikajude SaidInABox the193rd Adeon callumacrae lieven jaj bear` jvd lahwran taksuyu drbean TallerGhostWalt trampi dibblego Internet13 bsmt joehillen bgamari tmax6 Moyst YP-QMUL-W phaazon OverCoder tomku|two anoe gniourf)
04:26:31 --- names: list (meretrix oawji seagreen CurryWurst zyla albel727 stass gsingh93 dfrey Boney ackthet BrianHV dfranke pompolic arkarth jojotus idupree phileas venk pleiosaur ahammel ndeine Yaiyan eazar001 mt glguy dlundy SolarAquarion afc bogdanteleaga tailgate icen xaotuk johnw xinming_ ephemeron ReinH hongminhee Jinxit Madars keix technomad luigy xeno emmanuel_erc GaveUp Baughn ps-auxw cross oberstein narendraj9 hiredman Frankablu acomminos yusukesuzuki FledRebel kwantam)
04:26:31 --- names: list (TDJACR jgrocho ChongLi tstc carmethene mrshoe xaimus syntacticNaCl DigitalKiwi mindphaze gridaphobe gwo carter jle` mpereira keemyb bencryption RageD rootnode [swift] dan64 dsantiago pm5 swhalen nekomune s_e abh kvieta kriwil eddsteel rowanblush saml gaustin lhynes Boreeas dunj3 mnoonan andreass sleezd Simson-san mikeizbicki wjm ljhms dju magthe tobiasBora nkpart meditans eL_Bart0 Phyx- themagician MK_FG urdh paf31 niklasb mimi_vx stelleg max-m Xnuk hiratara)
04:26:31 --- names: list (sku1d kav themasterchef carc jzl naudiz nosceteipsum)
04:34:48 <cocreature> and the nice thing about the exercises is that coq checks if your solution is correct
05:17:00 <kamatsu> i've got a lump of code that is somehow throwing a floating point exception
05:17:26 <kamatsu> what's the easiest way to figure out where this is coming from? I'm never dividing by any non-constant number, so this isn't a division by zero
05:18:09 * hackagebot luminance 0.7.2 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.7.2 (DimitriSabadie)
05:23:49 <kamatsu> oh, i happened upon a solution
05:23:51 <kamatsu> oh well
05:33:09 * hackagebot rethinkdb 2.2.0.0 - A driver for RethinkDB 2.1  https://hackage.haskell.org/package/rethinkdb-2.2.0.0 (EtienneLaurin)
05:52:15 <RaceCondition> is it possible to install a package that is not on Hackage, such as diagrams-ghcjs, into a Stack project?
06:05:58 <Xnuk> @hoogle [m a] -> m [a]
06:06:01 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:06:01 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:06:01 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
06:07:49 <liste> RaceCondition https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
06:24:20 <averell> I have a setup for having lambdabot in my ghci via GOA for :pl, :src and such. Is that still a recommended setup? And also, how can I selectively disable the necessary .ghci setup so it works with tools like stack ghci in projects?
06:46:13 <padre_angolano> if I set a custom print function in ghci as ':set -interactive-print myprint', it's forgotten every time I do :load or :reload. Is there away to make it persistent?
06:46:51 <Voltz> I think I'm understanding category theory..
06:47:32 <frerich> Voltz: When you think you finally grokked category theory: http://3.bp.blogspot.com/-TsDt67JnMro/UAa4bLXCjhI/AAAAAAAABE8/Qh8BNLPM0-8/s1600/delim.jpg
06:48:23 * hackagebot dimensional-codata 2014.0.0.0 - CODATA Recommended Physical Constants with Dimensional Types  https://hackage.haskell.org/package/dimensional-codata-2014.0.0.0 (dmcclean)
06:49:23 <Voltz> It just looks like Type theory with some different rules and classifications.
06:50:11 <ski> padre_angolano : have you tried placing it in a `.ghci' file ?
06:51:48 <ski> Voltz : objects feel similar to types, yes. and instead of a binary relation `t : tau' between a term `t' and a type `tau', there is a ternary relation `f : A >---> B' between a morphism/arrow `f' and two objects `A',`B'
06:51:53 <padre_angolano> ski: yes. it works when ghci starts, then it's forgotten after first :load
06:52:06 <ski> oh. then i don't know :/
06:52:16 <ski> perhaps you could try asking #ghc
06:52:30 <padre_angolano> ski: thanks, will try there
06:53:07 <Voltz> Why we call them functors makes sense now.
07:09:21 <RaceCondition> liste: thank you!
07:09:46 <RaceCondition> can it also install stuff straight from, say, a git repo?
07:25:41 <flavi0> hi there folks. how would you go about integrating haskell inside c++ app/lib? is there some canonical way of doing it, and where can i read up on it?
07:32:10 <Denommus> flavi0: what have you researched about it?
07:32:26 <flavi0> Denommus: just reading http://stackoverflow.com/questions/3540932/mixing-haskell-and-c
07:32:55 <flavi0> FFI it seems to be?
07:33:24 * hackagebot arghwxhaskell 0.8.1.0 - An interpreter for the Argh! programming language in wxHaskell.  https://hackage.haskell.org/package/arghwxhaskell-0.8.1.0 (HenkJanVanTuyl)
07:33:52 <Denommus> flavi0: have you looked into this, too? http://stackoverflow.com/questions/3859340/calling-haskell-from-c-code
07:34:52 <flavi0> Denommus: ah that seems to have all i need. thank you sir!
07:35:16 <Denommus> flavi0: you're welcome
07:53:10 <Profpatsch> Will the handles returned by System.Process.createProcess be closed automatically when they are no longer in scope?
07:53:55 <Profpatsch> e.g. at the end of the corresponding `do`-block? Is there even a notion of an end of a do-block with lazyness?
07:54:06 <Profpatsch> Or better: With lazy IO?
07:54:36 <exio4> Profpatsch: yes, where "automatically" means when the GC finds out they are not longer in scope, iow, it is not-deterministic
07:55:11 <Profpatsch> exio4: Does that work out in practice?
07:55:31 <Profpatsch> For simple „put some lines in, get some lines out“ examples?
07:59:12 <exio4> Profpatsch: it should work for simple examples, but a `finally` do { hFlush h; hClose h; } wouldn't hurt
08:00:43 <pavolzetor> ((* (Sum 7)) <> (* (Sum 5))) 1
08:00:56 <pavolzetor> I still dont understand how it works
08:01:12 <pavolzetor> I would expect it to require two arguments not one
08:01:33 <pavolzetor> can anybody explain please
08:01:53 <nolraiU> :t (<>)
08:01:54 <lambdabot> Monoid m => m -> m -> m
08:02:45 <pavolzetor> yes, but how a pair of function taking possibly different argument becomes a function taking one argument?
08:03:11 <a5an0> :t (<*>)
08:03:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:03:26 <nolraiU> Because thats what Monoid on (r->) is defined to do?
08:03:36 <pavolzetor> oh
08:03:43 <pavolzetor> thanks :)
08:07:31 <anohigisavay> hi. i'm trying to compile a haskell module to a .so file for C code to call
08:07:47 <anohigisavay> ghc -O2 --make -no-hs-main -optl '-shared' -o HelloWorld.so HelloWorld.hs
08:08:17 <anohigisavay> i got this error: -r and -shared may not be used together
08:10:16 <anohigisavay> sorry i was disconnected
08:10:26 <anohigisavay> anyone got an answer?
08:32:28 <mm_> Can I use KindedSignatures with TypeFamilies? can I kind the star I get from a type-level function?
08:32:32 <OverCoder> Hm, learning Haskell doesn't seem that hard
08:32:48 <shersh> Hello everyone! I have such definition of function: `showAll :: [forall a . Show a => a] -> [String]; showAll = map show`. My question: why this don't work even with ImpredicativeTypes? Explanation from Haskell WIkiBook says it should be list of bottoms but explanation is confusing :(
08:32:58 <OverCoder> I am in chapter 4 out of 13, even though I believe chapters from 10 to 13 are some sort of an extra
08:33:13 <sm> OverCoder: it's not. Press on! :)
08:33:21 <bergmark> that's the spirit
08:33:26 * hackagebot persistent-postgresql 2.2.1.2 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.2.1.2 (MichaelSnoyman)
08:33:27 * OverCoder presses on
08:33:34 <OverCoder> Ah alright then
08:33:34 <sm> just keep your safety belt fastened
08:34:00 <OverCoder> No matter how hard is Haskell, I'll get myself to learn it in a way or another
08:34:12 <OverCoder> When I plan about something, I never give up haha :D
08:34:14 <OverCoder> Including learning my first programming lang.
08:35:34 <OverCoder> Guys how does comparison work in Strings? I mean those <, >, <=, >=? I mean when it returns True and when it return false?
08:36:15 <OverCoder> Like "abc" > "a", why would it be True, and why not, the tutorial barely describes that
08:36:57 <FireFly> It performs a lexical ordering--it compares the first character of each string, if those are equal it continues with the next, and so on
08:37:09 <FireFly> and no character is "smaller" than any character
08:37:14 <Cale> and the empty string is considered less than any other string
08:37:54 <Cale> Due to English being silly, "no character is smaller than any character" sounds very strange :)
08:38:19 <OverCoder> Ah, but if no character is smaller than another, how it's > or <? oh wait, it just compares lengthes?
08:38:23 <OverCoder> lengths*
08:38:47 <Cale> OverCoder: No, see, you misunderstood what FireFly was trying to say in exactly the way that I thought you might :)
08:39:10 <Cale> OverCoder: He meant what I said, that the empty string is considered smaller than a nonempty one
08:40:08 <OverCoder> Sorry for being somewhat dumb, but what does that even mean? I mean there are other ways to check if a String is empty or not
08:40:20 <Cale> > "" < "a"
08:40:22 <lambdabot>  True
08:40:24 <Cale> > "" < "x"
08:40:27 <lambdabot>  True
08:40:43 <OverCoder> > "abc" > "Abc"
08:40:45 <lambdabot>  True
08:40:57 <OverCoder> > "Abc" > "abc"
08:40:59 <lambdabot>  False
08:41:03 <OverCoder> Why is that ^?
08:41:16 <Cale> > 'A' < 'a'
08:41:17 <lambdabot>  True
08:41:25 <geekosaur> > ord 'a'
08:41:28 <lambdabot>  97
08:41:31 <geekosaur> > ord 'A'
08:41:33 <lambdabot>  65
08:41:49 <Cale> Because uppercase characters come before lowercase ones in Unicode
08:42:02 <OverCoder> Ah, so it compares the integeral representation of a characters?
08:42:06 <Cale> (and ASCII)
08:42:07 <OverCoder> Ah, now I got it
08:42:07 <OverCoder> Thanks
08:42:58 <Cale> So let's write down the general algorithm, because it's really an instance of Ord for lists, combined with an instance of Ord for characters
08:43:29 <sm> I was going to say.. https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Ord which is the typeclass that provides this feature for all types. Because it's implemented for [a] and for Char (see the Instances list), it works for Strings (which are [Char]). 
08:43:29 <Cale> Actually, let's do this the good way, which needs slightly more setup
08:43:59 * sm listens
08:44:03 <Cale> There is a type:   data Ordering = LT | EQ | GT   which represents the results of an order comparison
08:44:19 <OverCoder> Yeah I learned that before, continue
08:44:58 <Cale> Additionally, there's an instance of the Monoid class for this type. If you don't know what Monoid is yet, well, you can just look at what the operation does in this case:
08:45:06 <Cale> LT <> y = LT
08:45:11 <Cale> GT <> y = GT
08:45:16 <Cale> EQ <> y = y
08:45:55 <OverCoder> Hm,
08:46:24 <Cale> So, if the left hand comparison result is LT or GT, that's the result, and if it's EQ, then we do the right hand comparison, i.e. the right hand argument is a "way to break ties"
08:47:28 <Cale> So, in order to write an instance of the Ord type class, we can provide a definition for the operation  compare :: Ord a => a -> a -> Ordering
08:47:39 <Cale> Let's write the instance for lists:
08:48:08 <Cale> instance Ord a => Ord [a] where -- here, we're going to use the ordering on the type of elements, so we demand that type be ordered as well
08:48:45 <Cale>   compare [] [] = EQ -- let's start by handling all the cases with empty lists
08:49:09 <Cale>   compare [] (y:ys) = LT -- as we said before, we want the empty list to be less than any nonempty one
08:49:20 <OverCoder> Wait wait wait
08:49:32 <OverCoder> Calm down
08:49:38 <Cale> all right
08:49:43 <OverCoder> I was understanding stuff with the help of Google, but the last three lines, meh, I think I need to learn more Haskell before that
08:50:07 <Cale> Okay, so I guess maybe you haven't seen type classes or instances before?
08:50:16 <Cale> (I probably should have asked)
08:50:23 <OverCoder> Nope, I think that's my problem, I have just seen Typeclasses
08:50:24 <namonivi> hi 
08:51:05 <OverCoder> Honestly, your help is more than appreciated, bunch of thanks
08:51:06 <Cale> Ah, okay, so you've seen things like Ord a => ... showing up in types
08:51:15 <OverCoder> I have seen them like:
08:51:29 <OverCoder> FunctionName (Ord a) => a
08:51:39 <Cale> sort :: Ord a => [a] -> [a]
08:51:41 <pdkr> is there a nice tutorial on ways to not shoot yourself in the foot when using mfix (on Maybe)?
08:52:07 <OverCoder> Yeah that's familiar to me
08:52:23 <pdkr> (because my foot hurts)
08:53:28 <Cale> OverCoder: Okay, so a type class basically is like a predicate on types (something which might be true or false of any given type), and when it is true, we know that certain functionality is available with respect to that type
08:53:51 <Cale> and in order to make the predicate true, we have to implement whatever the class says needs to be there
08:54:06 <Cale> and we do that by writing an instance declaration
08:54:32 <OverCoder> Alright, move on
08:54:50 <Cale> pdkr: I don't know of any kind of easy tutorial for that, it's basically "don't write infinite loops"
08:55:11 <pdkr> yeah well I didn't think i did, but apparently i did
08:55:30 <Cale> OverCoder: So, all right, the definition of the Ord class looks like:
08:56:11 <Cale> class Eq a => Ord a where  -- the Eq a here says that we're required to eventually provide an instance of Eq if we want to provide an instance of Ord for a type
08:56:23 <Cale>   compare :: a -> a -> Ordering
08:56:47 <Cale>   (<), (>), (<=), (>=) :: a -> a -> Bool
08:57:40 <Cale> and then it provides some default implementations of these things in such a way that defining compare or defining (<=) is enough to define all the others
08:57:42 <OverCoder> I am all good with that
08:57:46 <Cale> Okay
08:57:56 <Cale> So, now we want to make lists an instance
08:58:21 <Cale> So we're actually going to say what compare does when we apply it to a pair of lists
08:59:23 <Cale> instance Ord a => Ord [a] where  -- here, we demand that the element type a already be an instance of Ord, and we're making an instance for lists of values of type a
08:59:55 <OverCoder> Perfect
09:00:04 <Cale>   compare = ... -- so now we have to define compare somehow (we can skip the other operations, and let it use the default implementations which apply compare)
09:00:21 <Cale> So we'll do it by pattern matching on the lists
09:00:43 <Cale>   compare [] [] = EQ -- obviously two empty lists are equal
09:01:07 <Cale>   compare [] (y:ys) = LT -- an empty list is supposed to be less than a nonempty one
09:01:26 <OverCoder> Alright but what is y and what is ys?
09:01:31 <Cale> anything
09:01:37 <OverCoder> Ah, alright then
09:01:43 <Cale> Those are variables which get bound by the pattern
09:02:03 <OverCoder> Got it
09:02:04 <Cale> I didn't need them, I could have written blanks like (_:_)
09:02:21 <Cale>   compare (x:xs) [] = GT -- a nonempty list is greater than an empty one
09:02:33 <Cale> so now the interesting case
09:02:41 <Cale>   compare (x:xs) (y:ys) = ...
09:03:10 <Cale> So to compare two nonempty lists, the first of which starts with x (and whose tail is xs), and the second of which starts with y (and whose tail is ys)
09:03:37 <OverCoder> Ah good
09:03:38 <Cale> we want to first compare x and y, and only if there's a tie, we compare the remainders of the lists
09:03:58 <Cale>   compare (x:xs) (y:ys) = compare x y <> compare xs ys
09:04:13 <OverCoder> What is <>?
09:04:23 <Cale> It's that operation I introduced a while ago
09:04:30 <OverCoder> Ah, Ah ok I got it
09:04:33 <OverCoder> Move on
09:04:43 <Cale> Well, that's the whole definition
09:04:59 <Cale> So, now whenever some type a is an instance of Ord, then so is [a]
09:05:16 <Cale> This actually gets us infinitely many instances of Ord
09:05:27 <OverCoder> Ooooh, now I perfectly got it
09:05:48 <Cale> > [[[1,2,3],[4]],[[5]]] < [[[1,2,3],[4]],[[4,3],[8]]]
09:05:50 <lambdabot>  False
09:05:52 <dutchie> Cale: well, assuming we have an instance of ord to begin with
09:05:53 <OverCoder> So this way Char has Ord, so as [Char], huh?
09:05:58 <dutchie> </pedantic>
09:05:58 <Cale> yeah
09:06:19 <Cale> dutchie: right, and we have instances for many basic types of course :)
09:06:50 <Cale> > sort "abracadabra"
09:06:52 <lambdabot>  "aaaaabbcdrr"
09:07:02 <OverCoder> Ah alright, very great explanation, a list of thanks :P
09:07:16 <Cale> > sort ["here","is","a","bunch","of","words"]
09:07:18 <lambdabot>  ["a","bunch","here","is","of","words"]
09:08:06 * OverCoder hugs Cale
09:08:11 <Cale> > sort [["here","are"],["some","lists"],["of","lists"],["of","lists"]]
09:08:13 <lambdabot>  [["here","are"],["of","lists"],["of","lists"],["some","lists"]]
09:13:26 * hackagebot streaming 0.1.3.0 - an elementary streaming prelude and a general monad transformer for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.3.0 (MichaelThompson)
09:18:23 <pdkr> > sort (1,2)
09:18:25 <lambdabot>      Couldn't match expected type ‘[a]’
09:18:25 <lambdabot>                  with actual type ‘(Integer, Integer)’
09:18:25 <lambdabot>      In the first argument of ‘sort’, namely ‘(1, 2)’
09:19:49 <hypermania> sort [1,2]
09:20:06 <ARM7> prelude sort works on lists not tuples
09:21:41 <hypermania> take 5 [1..]
09:22:55 <hypermania> :q
09:23:27 * hackagebot streaming 0.1.3.1 - an elementary streaming prelude and a general stream type.  https://hackage.haskell.org/package/streaming-0.1.3.1 (MichaelThompson)
09:23:29 * hackagebot hledger-ui 0.27.1 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-0.27.1 (SimonMichael)
09:24:10 <albeit> If I have "newtype Foo = Foo Int64", what's the simplest way to dervice Unbox for it?
09:27:27 <kadoban> albeit: Does GeneralizedNewtypeDeriving extension work? I would think it would. Unsure if that 't' is supposed to be capitalized.
09:28:46 <albeit> kadoban: I've have that extension enabled, and I've tried deriving Vector Vector and MVector MVector along with Unbox, as sugested in a SO answer, but still gives many errors ocmpiling
09:29:02 <kadoban> albeit: Did you say deriving (Unbox) ?
09:29:26 <kadoban> Oh you said you did. I don't know then.
09:29:55 <Cale> What error are you getting?
09:30:19 <albeit> First error is this: http://lpaste.net/146425
09:30:29 <albeit> (Foo is actually Price)
09:30:29 <Cale> Because if you derived Unbox for the type, either it should give you an error saying that it couldn't derive it, or else it derives the class, and that's not your problem.
09:30:53 <albeit> And my deriving line is "newtype Price = Price Int64 deriving (Num,Eq,Ord,Real,Enum,Integral,Vector U.Vector, MVector U.MVector, U.Unbox, Generic)"
09:31:11 <Cale> Ah, okay
09:31:46 <albeit> There are about 15 other errors too
09:32:00 <albeit> All related to the deriving
09:32:05 <monochrom> I do not understand the part about Vector U.Vector, MVector U.MVector
09:32:27 <Cale> So yeah, this isn't a problem with deriving Unbox
09:33:05 <albeit> It was from this SO answer http://stackoverflow.com/questions/10866676/how-do-i-write-a-data-vector-unboxed-instance-in-haskell
09:33:53 <breadmonster> does anyone here use something other than vim?
09:34:30 <mindphaze> emacs
09:34:33 <albeit> Cale: So it's deriving the Vector U.Vector then? How can I derive that with a newtype?
09:35:10 <breadmonster> mindphaze: Yeah, sorry, I meant something other than those two.
09:35:59 <Cale> breadmonster: Occasionally I'll use gobby (though the lack of undo is annoying if I'm programming on my own)
09:36:24 <Cale> breadmonster: gedit would also be fine, tbh
09:36:44 <mindphaze> no leksah users?
09:36:53 <breadmonster> Cale: I was wondering if anyone has a cool Atom work flow.
09:37:29 <Cale> I don't understand how people manage to care so much about text editors
09:38:06 <breadmonster> Cale: It's kinda like the thing you use to write code.
09:38:11 <monochrom> they also care about fonts down to the subpixel level, too. I am not surprised.
09:38:27 * hackagebot streaming 0.1.3.2 - an elementary streaming prelude and a general stream type.  https://hackage.haskell.org/package/streaming-0.1.3.2 (MichaelThompson)
09:39:02 <Cale> breadmonster: Basically, anything which will automatically convert tabs to spaces for you, and which will maintain the indentation level of the previous line you were on should be mostly fine.
09:39:15 <Cale> You might also want some syntax colouring or something :P
09:39:36 <breadmonster> Cale: Automatic indentation is okay, but there's some other stuff that would be nice. Though I want smart indentation.
09:39:51 <breadmonster> I should be manually aligning all my do statements.
09:39:55 <breadmonster> Or guards.
09:40:14 <breadmonster> monochrom: Not that crazy yet, though if you have any nice fixed width fonts, do share.
09:40:45 <Cale> If the amount of time you spend entering code into the editor is anything close to the majority of the time that you're spending programming, I find that surprising.
09:41:19 <monochrom> my nice fixed width font is whatever comes with ubuntu out of the box
09:41:21 <breadmonster> Cale: No, but it is related to the amount of time I look at the editor, yeah?
09:41:27 <breadmonster> monochrom: Ubuntu :(
09:41:28 <Cale> Most of the time spent programming for me is either spent reading code or documentation, or trying things out in ghci, or just thinking.
09:41:52 <Cale> Trying to optimise the remainder of the time further doesn't really do anything much.
09:42:00 <breadmonster> Cale: Reading code is a huge thing and like I like a clean editor. Vim is nice, but it won't auto indent goddammit
09:42:13 <Cale> You shouldn't have to auto-indent to read code
09:42:25 <Cale> If you do, you have bigger problems :P
09:42:32 <breadmonster> lol
09:43:24 <Cale> Also, in Haskell, just about any auto-indentation is going to end up with a much worse result than a human would get.
09:43:58 <geekosaur> ye, the editor would really need to understand not just syntax but semantics
09:43:58 <Cale> There's one thing which I would very much like to have, but which no editor does as far as I'm aware
09:44:17 <Cale> which is just syntactically understanding the layout keywords
09:45:10 <albeit> Aha, got the Unbox! Used Data.Vector.Unboxed.Deriving and this http://lpaste.net/146426
09:45:11 <Cale> any edit which causes the first non-whitespace character following a layout keyword ('let', 'do', 'mdo', 'of', or 'where') to move, should cause the entire block to move identically
09:47:03 <MarcelineVQ> I don't know how it compares to others, but atoms indentation behaviors with it's haskell plugins is pretty good
09:47:37 <MarcelineVQ> Also it can duplicate the cursor easily so if you need to move a block uniformly you can extend your cursor and hit space for all the lines
09:48:02 <Cale> There've been some attempts at allowing that kind of thing, but as far as I know, nothing actually does that exactly. Yi had something which would reindent blocks, but it was flaky.
09:48:30 <monochrom> chrisdone's structured-haskell-mode does that
09:48:36 * hackagebot io-streams 1.3.3.1 - Simple, composable, and easy-to-use stream I/O  https://hackage.haskell.org/package/io-streams-1.3.3.1 (GregoryCollins)
09:48:46 <Cale> Well, it does that only insofar as it doesn't let you touch the layout of the code
09:48:54 <monochrom> haha
09:50:38 <dolio> I have some half baked auto indenting for vim, but it gets confused sometimes and I haven't felt like working on it in a while.
09:53:25 <Cale> I suppose there's a bit of a problem even with that, in that e.g. if as part of trying to get a block moved to the end of the previous line, you just start backspacing, you'll eventually extend the block as it crashes into its parent
09:54:11 <dolio> It will do things like snapping 'where' to the right column, and letting you switch between appropriate columns, though, when it's not confused.
09:54:35 <Cale> So like, what you'd really want is for some sort of selection to take place just before the effect of the first edit which causes the block to move
09:55:17 <Cale> and then subsequent edits would remember that block up until... some reasonable condition :)
09:56:09 <user9872180> Hi, probably a silly question but I'm curious to know if there is a way to treat ADTs of kind * as a set, such that I am able to generate new ADTs from the old
09:56:18 <user9872180> for example
09:56:25 <user9872180> data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
09:56:35 <dolio> All you need for that is something to identify the block as a bunch of lines, though.
09:56:52 <user9872180> and then say I wanted
09:56:55 <user9872180> data AwesomeDays = difference Day (fromList [Monday])
09:57:04 <albeit> Should an unboxed vector of Int64 of length 1000 use pretty close to 1000*8 = 8000 bytes of memory?
09:57:06 <user9872180> (obviously incorrect)
09:57:12 <user9872180> data AwesomeDays = Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
09:57:19 <Cale> user9872180: no
09:58:08 <dolio> albeit: Pretty close.
09:58:43 <albeit> dolio: Okay, so theres no overhead per element, but there is for the vector as a whole?
09:58:52 <dolio> Right.
09:59:14 <albeit> Thanks
10:00:47 <user9872180> Right. Well, how about a way of creating an ADT of kind * from a Set?
10:02:04 <Cale> user9872180: Types don't exist at runtime, you can't make new ones from values which won't exist until the program is run. However, using Template Haskell, you could run a program at compile time to determine what constructors to declare.
10:02:16 <albeit> Does Data.Array.Repa.fromListUnboxed lazily / stream-fusion-y consume the list provided list, or is the list evaluated in full first?
10:03:17 <user9872180> Cale: Ah, I see, okay thanks for your help!
10:03:37 * hackagebot streaming 0.1.3.3 - an elementary streaming prelude and a general stream type.  https://hackage.haskell.org/package/streaming-0.1.3.3 (MichaelThompson)
10:05:06 <monochrom> new feature from emacs haskell-mode: http://www.vex.net/~trebla/tmp/Screenshot%20from%202015-12-03%2013-03-29.png
10:06:59 <mm_> STM shouldn't really have bad performance impacts with large data types, right?
10:08:41 * hackagebot streaming-bytestring 0.1.3.0 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.3.0 (MichaelThompson)
10:15:46 <albeit> Does "concat [[1,2,3], [4,5,6]]" full evaluate the list, or is it subject to stream fusion?
10:17:24 <kadoban> > take 10 $ concat [[1,2,3], [5..], undefined]
10:17:26 <lambdabot>  [1,2,3,5,6,7,8,9,10,11]
10:17:38 <albeit> Ah okay, cool test
10:19:03 <Cale> albeit: It evaluates exactly as much of the list as you'd expect it to
10:19:09 <Cale> :)
10:19:14 <Cale> @src concat
10:19:15 <lambdabot> concat = foldr (++) []
10:19:21 <Cale> @src foldr
10:19:21 <lambdabot> foldr f z []     = z
10:19:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:19:38 <Cale> foldr does evaluate its list argument (it pattern matches)
10:20:43 <Cale> So when we evaluate:  concat [[1,2,3], [4,5,6]] -> foldr (++) [] [[1,2,3], [4,5,6]] -> (++) [1,2,3] (foldr (++) [] [[4,5,6]])
10:20:51 <Cale> and then we need to look at the definition of (++)
10:20:54 <Cale> @src (++)
10:20:54 <lambdabot> []     ++ ys = ys
10:20:54 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:20:55 <lambdabot> -- OR
10:20:55 <lambdabot> xs ++ ys = foldr (:) ys xs
10:21:37 <Cale> So we get   (++) [1,2,3] (foldr (++) [] [[4,5,6]]) -> 1 : ([2,3] ++ foldr (++) [] [[4,5,6]])
10:22:06 <Cale> at this point, evaluation is complete -- and we could e.g. match this against a pattern (u:us)
10:22:54 <Cale> If we evaluate the tail of the list, the (++) will go a bit further
10:33:43 * hackagebot streaming-utils 0.1.3.0 - http, attoparsec, pipes and conduit utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.1.3.0 (MichaelThompson)
10:43:43 * hackagebot yesod-core 1.4.16 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.16 (MichaelSnoyman)
10:59:02 * hackagebot yesod-form 1.4.6 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.4.6 (MichaelSnoyman)
11:16:56 <mniip> Objects in the heap, both unevaluated suspensions and head normal forms, have a uniform representation with a code pointer in their first field. Many implementations examine tag fields on heap objects to decide how to treat them. With our representation we never do this; instead, a jump is made to the code pointed to by the object. This is why we call the machine "tagless".
11:17:03 <mniip> doesn't that make GHC tagful?
11:17:19 <mniip> every closure has a tag that describes how it is supposed to be entered
11:17:33 <aweinstock> the tag is a code pointer though
11:17:46 <aweinstock> so there's not a switch on the tag, just an indirect jump
11:18:08 <mniip> huh
11:18:17 <mniip> pretty sure there's a discrete tag
11:18:23 <mniip> that describes how to jump
11:18:30 <mniip> what to put on the stack, etc
11:19:01 <aweinstock> that's all handled unconditionally inside the code that's pointed to
11:19:12 <Cale> uh
11:20:42 <Cale> The low order bits of the code pointers are sometimes used as a tag of sorts though.
11:22:11 <Cale> Since code pointers are aligned to multiples of 8 or 16, the lowest 2 or 3 bits of the pointer which would normally be 0 get used to provide some extra information about the thing being pointed to
11:23:36 <Cale> If it's a constructor of a datatype with few enough constructors, the tag gets used to say which constructor (i.e. so it doesn't have to go look at the constructor's info table)
11:23:36 <mniip>  An AP_STACK is a special kind of object:
11:23:36 <mniip> It represents computation of a thunk that was suspended midway through evaluation. In order to continue the computation, copy the payload onto the stack (the payload was originally the stack of the suspended computation), and enter the closure. 
11:24:59 <monochrom> mniip, heap objects are tagless. but a subroutine responsible for creating that heap object and putting its address into a register for passing the address to another piece of code, it can add a number between 1 and 7 to the address for tagging (because heap addresses are all 8-byte-aligned).
11:25:58 <mniip> hmm
11:28:14 <mniip> I'm thinking of writing a functional language hopefully one looking similar to haskell
11:28:24 <mauke> why not write haskell?
11:28:34 <monochrom> @quote monochrom downloaded.GHC
11:28:35 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
11:29:26 <mniip> I don't think I have the knowledge required to implement a fullblown haskell typechecker
11:29:35 <mniip> maybe I could borrow GHC's core though
11:31:19 <monochrom> anyway, "GHC is tagless" and "GHC is tagful" are both false.
11:31:50 <monochrom> GHC heap objects are tagless. GHC addresses put in registers are usually tagful.
11:32:41 <monochrom> false dichotomies blind people to more options.
11:33:13 <monochrom> another great false dichotomy of the day: "Does "concat [[1,2,3], [4,5,6]]" full evaluate the list, or is it subject to stream fusion?"
11:33:16 <c_wraith> STG is tagless.  It says so right in the name.
11:33:22 <monochrom> correct answer is "both are false"
11:33:39 <mniip> c_wraith, is GHC STG
11:33:50 <c_wraith> Not anymore
11:33:52 <monochrom> GHC has since gradually deviated, improvised, and digressed from STG
11:34:06 <mniip> right
11:34:11 <c_wraith> though it still names a phase STG, it's no longer what the paper described
11:34:13 <Cale> STG is still a good starting point
11:34:26 <mniip> I'm thinking of abandoning taglessness
11:34:42 <monochrom> actually "is GHC STG?" is yet another false dichotomy
11:35:05 <monochrom> 3 great false dichotomies in one day, and the day is barely half-past
11:35:06 <mniip> how is that a false dichotomy
11:35:20 <c_wraith> that something is STG or is not
11:35:22 <Cale> If you're just interested in learning, you might just use a representation with an "evaluated" flag.
11:35:30 <mniip> Cale, yeah
11:35:34 <monochrom> "STG" at the same time consists of a functional language and an abstract machine.
11:35:34 <mniip> that's what I'm thinking about
11:36:17 <monochrom> the question "is GHC STG?" has to first of all disambiguate itself as to "do you mean the language? do you mean the machine?"
11:36:41 <monochrom> and then there is also the part about translating the abstract machine to x86
11:37:03 <beekeeper> I'm a new FP human. I'm wondering about this way of passing a thing to a function, and returning a modified version, as a way of 'mutating' things. don't you end up with functions all having lots of arguments and returning loads of stuff? I'm writing a pathtracer and I am passing an infinite list of random floats back and fourth everywhere.
11:37:44 <Cale> beekeeper: Of course, you can package many things into a data structure.
11:38:12 <mniip> Cale, I'm thinking of something like this https://bpaste.net/show/d8fd53add68b
11:38:15 <beekeeper> a state blob tuple
11:38:44 <breadmonster> Cale: Can you print bytestrings as hex characters?
11:38:52 <Cale> beekeeper: But generally, you want to write things to take the data that they actually depend on, and produce the results actually computes.
11:38:55 <Cale> computed*
11:39:15 <mniip> hmm
11:39:20 <mniip> this doesn't add up
11:39:36 <Cale> breadmonster: showHex from Numeric might be useful
11:40:15 <monochrom> I guess you have to unpack then showHex
11:40:22 <Cale> beekeeper: but it's hard to say anything too general
11:40:56 <monochrom> "FP human" is a novel idea :)
11:42:48 <Cale> beekeeper: You can of course do what I'd consider to be OO, and make records consisting of the operations you need on the data, (many of which will either produce new such records in the pure case, or else something like IO actions which do effectful updates)
11:43:30 <monochrom> Cale, yesterday or something, someone asked "does Haskell have 00?" [sic]
11:43:42 <Cale> heh 00
11:44:15 <monochrom> at first I ignored the typo and answered "yes Haskell has OO", as you would agree.
11:44:51 <sssilver> OO as in "Oo it's such an amazing language"
11:44:52 <monochrom> then someone spotted that it's literally zero-zero. so I thought up an even better answer:
11:44:57 <monochrom> @type 00
11:44:58 <lambdabot> Num a => a
11:45:06 <monochrom> "haskell has polymorphic 00"
11:45:49 <bitemyapp> hahahahahah
11:47:38 <Cale> More seriously, it also has an interesting kind of polymorphic OO: object types which are parameterised over a choice of monad.
11:47:55 <bitemyapp> Cale: sorry, object type?
11:48:32 <bitemyapp> I usually think of our "OO" being final encodings / interface-oriented typeclasses.
11:48:32 <Cale> I just mean like a record type whose fields are mostly functions (producing actions in this monad in the case I'm talking about)
11:48:37 <bitemyapp> oh right
11:48:42 <bitemyapp> yeah you could simulate 'this' with that.
11:48:46 <Cale> There's no need to use type classes
11:48:52 <Cale> Well, 'this' is a bit funny
11:48:54 <bitemyapp> for what you're talking about yes
11:48:59 <bitemyapp> I was talking about something different.
11:51:21 <Cale> But yeah, usually when I think about translating OO to Haskell, I'll have a data type roughly corresponding to an "abstract base class" or an "interface", and then functions which construct values of that type to make objects. The parameters to the functions (and things which show up in their where clause) are like the "private" part of the object.
11:52:30 <Cale> You don't have subtyping, but if you can make objects with as many different implementations of the methods as you need, you don't really need subtyping all that much.
11:52:50 <bitemyapp> you can fake subtyping
11:53:02 <bitemyapp> well, depends on what part.
11:53:15 <bitemyapp> superclassing doesn't let you override
11:53:38 <breadmonster> Umm, what is subtyping?
11:53:46 <Cale> The main reason that subtyping exists in typed OO languages is just because they've tied the implementations of methods to the types of the objects (which class they belong to). So you need to define subtypes in order to define different behaviours that an object can have.
11:54:53 <Cale> breadmonster: Roughly, a type T is a subtype of the type S when values of type T can be treated as values of type S. (and parameters of type S can be substituted for arguments of type T)
11:55:07 <breadmonster> Cale: So typeclasses.
11:55:23 <monochrom> I think row polymorphism is better than subtyping for the purpose of OO anyway.
11:55:57 <bitemyapp> probably so
11:57:40 <dolio> Seems nicer for inference in my experience.
11:58:32 <dolio> Although that could just be poor implementations.
12:01:13 <suppi> monochrom, agree as well!
12:04:00 <beekeeper> there isn't much dogma about indentation as far as I can tell. python is very prescriptive, with pep8 and all that
12:04:16 * beekeeper is scared when order is not imposed from outside
12:04:53 <beekeeper> if you don't stick spaces around your operators pep8 gets angry. in haskell I can practically do ascii art with my code and nobody cares
12:08:16 <monochrom> you can follow https://github.com/tibbe/haskell-style-guide if you like
12:09:10 <monochrom> you can also agree with most of it and disagree with just a few points
12:10:38 <monochrom> for example I don't follow its "make all your data strict by default". but I follow its "indent by 4 spaces by default, so that your 'where' just needs 2 spaces"
12:11:56 <MarcelineVQ> it's kinda neat how it lines up the where stuff with the rest due to that
12:12:02 <monochrom> I relax line length from 80 to 90. This is Year 2015.
12:12:35 <monochrom> yes. it also reminds you, when you have a do-block, that your 'where' is not supposed to see through the do-block
12:12:46 <monochrom> (which is the very example shown there)
12:13:36 <MarcelineVQ> What does that mean?
12:14:01 <int-e> monochrom: but then it will no longer fit nicely into a default xterm.
12:14:30 <monochrom> "m = do { x <- getLine; return y } where { y = x ++ x }"  this is wrong because x is not in scope by the time you hit the 'where'
12:15:52 <monochrom> I set my emacs to default to 100 columns
12:16:06 <monochrom> no, 90 columns
12:16:19 <monochrom> I don't use an xterm.
12:16:45 <monochrom> but it's also a trivial clause in .Xdefaults to tell xterm to go 90 columns
12:17:15 <monochrom> It's Year 2015. 90 is already pretty conservative. I am not advocating 132 yet.
12:18:39 <monochrom> and don't forget that there are die hard console users who use the linux non-graphical console which has hundreds of columns, approaching 1000 now.
12:18:56 <beekeeper> they don't exist :/
12:20:14 <koala_man> you know what I'd do with 1000 columns? 12 80 column files side by side.
12:20:51 <gfixler> koala_man++
12:20:53 <geekosaur> 80's a holdover from punched cards
12:21:04 <monochrom> I have a friend, who graduated from Waterloo, was on Waterloo's ACM programming team, is working for a quant company, who refuse to use X Window. so he uses the text console when on linux. (he is fine with Windows windows.)
12:21:36 <monochrom> (int-e knows him too, from an invite-only IRC channel all 3 of us are on)
12:21:59 <ReinH> I mean, I ssh into headless servers all the time
12:22:07 <koala_man> I would much rather use X with a single fullscreen xterm than fbcon any day
12:22:23 <ReinH> but I'm not sure if I'd want to live in one
12:22:38 <monochrom> he rejects X on the ground that X has the wrong architecture
12:22:52 <ReinH> Of course it does. It, like everything else, is terrible.
12:23:10 <geekosaur> I'm not exactly convinced Weston has the right one
12:23:53 <monochrom> I disagree with appealing to that reason. (what do I care what architecture X uses?) but I mention him to tell you that linux console people exist.
12:24:06 <gfixler> I can't do any of the cool things I want to do, so I'll never be happy, regardless of architecture
12:24:18 <monochrom> and not just a random guy on the street. some very accomplished, highly valued programmer.
12:24:24 * gfixler is in a linux console right now, as usual
12:24:43 <koala_man> X is so terrible but works so well, just like mplayer and bash
12:24:51 <gfixler> it makes me laugh when people talk about Vim as being good for sshing into a terminal and fixing a value
12:25:34 <FireFly> Something something #-blah
12:25:41 <kazagistar> sounds like people are doing some ghetto sysadmining
12:27:56 <kazagistar> by "ssh in to fix a value", you mean modify the automation scripts, right?
12:28:46 <geekosaur> ghetto sysadmin is all the rage in pseudodevops
12:29:07 * pharaun recommends some people to learn about ansible
12:30:30 <monochrom> "Ansible Tower" is tower because stack is no longer enough :)
12:31:30 <Welkin> what
12:32:46 <kazagistar> I thought NixOps would be the obvious choice in this channel :P
12:32:54 <Welkin> it should be
12:33:03 <moop> why ansible and not salt or puppet or whatever
12:33:32 <dmj> kazagistar: nix 4 lyfe
12:33:38 <kazagistar> Nix lets you do ops the purely functional, declarative way, and is nice and esoteric to boot
12:33:38 <Welkin> I use keter as my deployment system
12:33:47 <Welkin> for anything else I would choose nix
12:33:52 <Welkin> but I haven't learned how to use it yet
12:34:02 <pharaun> monochrom: leaning tower of ansible ;P
12:34:46 <pharaun> moop: i just picked one, work uses puppet, and i've heard of salt, but well i needed something, so ansible it was.
12:34:46 <sm> heh
12:35:05 * sm thought propellow would be the choice here
12:35:13 <sm> Propellor.
12:35:27 <moop> my only vote for ansible or salt is that they don't require a running client on the slaves
12:35:33 * monochrom supports random choice when time is not available to gather information
12:35:34 <moop> but which one tho
12:35:36 <Welkin> sm: prpellarly you mean?
12:35:38 <moop> salt or ansible
12:35:55 <pharaun> sm: i've eyeballed propellor (or whatever its name is)
12:35:56 <kazagistar> At my place of work we use an awkward mix of puppet, shell scripts, vim-modified config files, and a custom irc bot for deploying docker containers. Keeps things interesting.
12:36:03 <Welkin> all those silicon valley names
12:36:27 <Welkin> I wonder why no one has used "deploy" yet
12:36:31 <monochrom> Glsglow Hskell Cmpiler
12:36:37 <moop> kazagistar: that sounds ugly
12:36:39 <pharaun> +1
12:36:49 <pharaun> when in doubt, lope off the vowels
12:37:05 <moop> don't you mean, vowls?
12:37:18 <pharaun> I've eyeballed keter for a few haskell projects, but last time i checked it was still mostly only for postgres iirc
12:37:25 <Welkin> kazagistar: you use sock puppets to conduct meetings and soup cans with strings to communicate across the office
12:37:29 <monochrom> oh, you will hear "how do I deploy a project I wrote in Haskell?" in this channel within 2 weeks
12:37:38 <magneticduck> kazagistar: IRC is the piece de resistance for hacked-together systems
12:38:03 <monochrom> of which the answer is "Haskell libs are statically linked into your exe, so just copy the exe"
12:38:03 <pharaun> tbh (regarding haskell projects) these days i just put em into docker container and have them obey the "company contract"
12:38:05 <kazagistar> glaskell.compi.lr
12:38:06 <pharaun> and call it good enough
12:38:39 <Ankhers> pharaun: Would you mind expanding on that approach a little bit?
12:39:10 <pharaun> Ankhers: sure. Basically my workplace uses Apache Mesos for cluster stuff, so they wrote a wrapper on top that runs docker containers
12:39:33 <pharaun> and there is a few requirement like 1) must reply on port X, and must have a /healthcheck endpoint for ex
12:39:59 <pharaun> then you can load up whatever you want inside the container, then give it to the cluster and say, i need x nodes of this container
12:40:07 <pharaun> and it'll go and deploy and keep X nodes of it running
12:40:19 <Ankhers> pharaun: How do you deal with updates to the application?
12:40:22 <pharaun> and it will make sure its healthy via pinging the healthcheck endpoint
12:40:24 <Welkin> schroedinger's container
12:40:32 <pharaun> Ankhers: what was it called... i think green+blue
12:40:51 <pharaun> you need a new version, it deploys a new cluster then switch the haproxy to point to the new instance
12:41:06 <pharaun> or you can alt do rolling update where you down/up a new container one by one
12:41:21 <kazagistar> pharaun: how does mesos work in terms of service discovery from haskell?
12:41:41 <Ankhers> I guess this is more of a Docker question, but I just don't understand how to properly update an application running inside Docker. It seems strange to me because I wouldn't want to git pull + compile every time a new version is created.
12:41:47 <pharaun> we externalize it, use a thing called nerve/snyapse
12:41:52 <pharaun> in which you give each service a name
12:41:58 <pharaun> and it'll track the ip/dnsetc
12:42:03 <Ankhers> I've used docker to some extent for things like postgres, or other long running services.
12:42:12 <pharaun> and you query it, "I need a ip+port to x service, do you have one for me?"
12:42:14 <Ankhers> Rather, seldom updated services.
12:42:32 <pharaun> Ankhers: you would want to launch a new container and take down the old one
12:42:37 <pharaun> you don't update inside the container
12:42:42 <pharaun> you build a new one, tag it and launch it
12:43:01 <kazagistar> Ankhers: you have a CI server build your container as an artifact, and then you just spin up the new version and kill the old version
12:43:07 <pharaun> yup
12:43:14 <pharaun> that's how we do it too, we use jenkins
12:43:32 <pharaun> it builds new one, then once it passes a large suite of tests, it tags it and send it on over to mesos/marathon/paasta/whatever
12:43:33 <Ankhers> But do you always start from a "blank" container. Pull all the code, compile, and tag?
12:43:36 <pharaun> yes
12:44:01 <pharaun> docker can cache lower layers but we start from blank because we roll out a new version of our base-container daily to keep up to date on security fixes to base libraries
12:44:27 <Ankhers> I feel like that would eventually take a long time on large code bases. I guess I have been worrying about something that does not matter...
12:44:31 <pharaun> depends
12:44:43 <pharaun> well let me walk through the timing here on my thing
12:44:51 <kazagistar> Ankhers: you can just copy compiled binaries into a very lightweight container
12:44:51 <albeit> With Repa arrays, is it possible to use non-integral or custom datatypes for the indicies?
12:45:04 <pharaun> basically in my jenkins job, i use stack to build it, and docker will *cache* my "builder docker"
12:45:21 <Ankhers> kazagistar: That still requires a full git pull/clone, doesn't it?
12:45:30 <pharaun> which will then be slow when we update the base image (ie first time each day, it takes 10 min to build) then all of the rest of the build for the rest of the day is <1-2 min
12:45:52 <pharaun> so in my jenkins job, i use this container to build my app, then dump the binary out, and i load the binary into a "running" container, load in the config, and tag that
12:46:06 <kazagistar> Ankhers: Once per version. What is the alternate? If you make your build servers clever you can cache intermediates if you want.
12:46:43 <pharaun> the (initial dependency build) takes ~10-20 minute, but the app build is usually 1m, if its not the first build of the day its ~5 min total to push out a new version, if its the first build its ~20+ min
12:46:44 <Ankhers> I was just thinking about a continuous deployment scenario where you may deploy N times per day.
12:46:52 <pharaun> Ankhers: see my numbering ^
12:46:53 <Ankhers> I wouldn't want a full clone / pull every time.
12:47:02 <pharaun> you don't need to
12:47:06 <pharaun> esp with jenkins workdir
12:47:37 <pharaun> it can preserve old workdir and do a partal pull then push the code into the builder container and build and pull out the binary
12:47:52 <Ankhers> That makes a lot of sense.
12:48:08 <pharaun> albeit: i unfortunately don't know the answer to that one, doesthe type indicate that it can take non integer indicies?
12:48:30 <Ankhers> pharaun: Does stack do all of that for you, or do you have some additional scripts inside Jenkins?
12:48:45 <pharaun> Ankhers: yeah additional scripts/jenkins job.
12:48:52 <pharaun> ie jenkins can take care of the git clone./checkout/etc
12:49:01 <Ankhers> Fair enough.
12:49:30 <pharaun> then i have a really small bash script that invokes stack to build, then another small script to invoke docker build . to take the binary and put it into the runtime container
12:49:31 <Ankhers> I'm going to have to try that out once my app is working.
12:49:45 <Welkin> that sounds like a lot of extra work
12:49:47 <pharaun> at work its all automated/provided for you
12:50:03 <pharaun> we have bunch of tooling around this workflow and to set it up its usually just 1-2 commands, done
12:50:21 <pharaun> but its doable without the automation, just more manual (in the initial config)
12:50:27 <pharaun> Welkin: it is
12:50:33 <Ankhers> Welkin: If you don't mind my asking, what is your approach to CI/deployment?
12:50:33 <kazagistar> my suggestion is to start with building from scratch each time since it is the easiest to setup, and then add caching as needed
12:50:39 <pharaun> it really is, but it also allow ops to *force* rolling updates
12:50:44 <Welkin> I don't use any kind of CI
12:50:47 <pharaun> ie if we find a security issue in our base libraries
12:51:01 <pharaun> ops can just invoke something and trigger the *entire* cluster of all sort of app to force them to update
12:51:06 <Welkin> I just have keter running on a server and I run the command locally to compile the keter bundle and upload it to the server
12:51:08 <pharaun> to the newest base image, etc for rapid response to security issue
12:51:14 <Welkin> then keter takes care of the rest
12:51:16 <pharaun> Welkin: that works for single/few apps :)
12:51:27 <pharaun> and is probably a better setup if you only need to worry about a couple app
12:51:34 <pharaun> but here, we have hundreds+
12:51:40 <pharaun> over thousands of machines
12:51:59 <Welkin> yeah, I don't need the extra complecity
12:52:05 <Welkin> I have one app on one server
12:52:12 <pharaun> then keter would work great
12:52:22 <pharaun> maybe if you want to be a little bit more automated, maybe even ansible/salt/whatever
12:52:51 <athan> bitemyapp: I'm finding myself making a monstrosity out of `hoist`
12:53:01 <athan> almost like how I use to abuse `lift`
12:53:08 <athan> I'm wondering if monad-control also solves this
12:53:31 <Welkin> athan: bakemono
12:53:53 <Ankhers> pharaun, kazagistar, Welkin: Thanks for the information.
12:54:03 <athan> Welkin: :)
12:54:05 * hackagebot arghwxhaskell 0.8.2.0 - An interpreter for the Argh! programming language in wxHaskell.  https://hackage.haskell.org/package/arghwxhaskell-0.8.2.0 (HenkJanVanTuyl)
12:55:26 <pharaun> Ankhers: np
12:57:29 <athan> Welkin: This is next level
13:06:13 <mniip> I wonder if it would be possible to write allocation-less code
13:07:09 <mniip> like what features does one have to remove from the language to avoid allocation in a specific plcae
13:07:50 <mniip> without introducing noncomposability of course
13:09:35 * hackagebot yesod-bin 1.4.15 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.15 (MichaelSnoyman)
13:09:37 * hackagebot IntervalMap 0.4.1.0 - Maps from Intervals to values, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.4.1.0 (ChristophBreitkopf)
13:10:27 <mniip> hmm, just have to eliminate all ADTs and function closures
13:11:58 <pikajude> what are the reasons that ghci would be able to typecheck an expression, but when I try to bind it with let I get an error about "Could not deduce"
13:12:01 <monochrom> hehe, that's almost everything
13:12:08 <ania12> does one knows how to checj wether a journal is in tomson impact factor list?
13:12:24 <mniip> what I mean is, imagine that we wrote an allocator for our little haskell-esque language, in that very language
13:12:38 <pikajude> and the error I get mentions one of those anonymous type variables
13:12:49 <monochrom> computing with only Godel numbering avoids allocation. until you run into really big numbers that need allocation
13:12:58 <pikajude> "The type variable 'a0' is ambiguous"
13:14:51 <uli> lambdabot: > 2
13:15:48 <mniip> monochrom, basically all you need is a few unboxed looping utilities that don't grow the stack and you're all set!
13:16:33 <ania12> does one knows how to checj wether a journal is in tomson impact factor list?
13:17:12 <geekosaur> ania12, this would not be the right channel for that. maybe try #freenode since it's someting of a general topic
13:17:17 <geekosaur> or a search engine
13:17:18 <lpaste> pikajude pasted “servescript.hs” at http://lpaste.net/146434
13:17:23 <pikajude> ^ there it is
13:17:26 <pikajude> i don't understand the error message
13:17:27 <kazagistar> mniip: you mean like, not allocating on the stack either? So you can't have functions, so you need some other form of abstraction that does not use a stack?
13:17:40 <mniip> nah I mean it's okay to use the stack
13:17:43 <mniip> but not infinitely
13:17:56 <geekosaur> if you're talking about writing an allocator, you kinda need to not rely on allocations...
13:18:02 <mniip> yes
13:20:20 <athan> So liftWith allows you to operate on the state of `t` before giving your monad result that you want to embed in `t`?
13:20:41 <kazagistar> maybe adding an type-level tracking of available memory space to a dependent type system? you can only call a function if you have the remaining memory for it to run?
13:21:12 <athan> And restoreT is like `return` for the transformer? Assuming `StT` has enough information about `t` to create a new one? (in the monad `m`)
13:21:52 <pikajude> if i add 'AssetLanguage a0 ~ AssetLanguage a1' to my context, it just changes the name of the a0 variable
13:22:00 <pikajude> so i can't win~
13:28:14 <kazagistar> mniip: I think the simplest language design to satisfy that constraint would prohibit recursion and prohibit dynamic allocations, but that would be a pretty limited language
13:28:57 <albeit> If I have something like 16 million 64-bit integers stored in a file in binary, what's the fastes way to load them into a list [Int64]?
13:30:20 <albeit> (And stored just on after another, nothing else in the file)
13:31:35 <Ankhers> albeit: as in the data looks like "574803275..." or "12 432 4535432 543 ..."?
13:31:47 <uli> It depends what you want to do with it and if you want to have O(1) access time a list is probably a bad idea
13:32:09 <albeit> Ankhers: It's in binary, so theres 8 bytes for the first int, then the second 8 bytes are the second int, etc...
13:32:17 <albeit> uli: It's being loaded into a Repa array
13:33:18 <albeit> uli: (Or being processed outside repa, just want to know the fastest way to read it)
13:33:25 <mniip> sounds like you might actually want to use a ByteArray#
13:34:08 <Ankhers> albeit: Right... I'm dumb today... sorry...
13:34:21 <albeit> mniip: I'll check it out thanks
13:34:42 <uli> the fastest would probably be to load it into IOUArray
13:34:44 <mniip> you're wandering into GHC internals though
13:35:21 <uli> but that is in IO though
13:36:28 <monochrom> the library "binary" has tools for getting the numbers from the file. and even then it gives you many alternatives. wisely choose the alternative that fits you.
13:40:46 <pikajude> ok i guess what's happening is that compiler :: AssetLanguage some_arbitrary_type_variable -> ...
13:40:55 <pikajude> and I can't coerce it to compiler :: AssetLanguage some_type_variable_in_scope -> ...
13:41:03 <pikajude> is there a way to convince GHC to let me do that?
13:41:13 <geekosaur> ScopedTypeVariables and forall it
13:41:19 <pikajude> i did
13:41:21 <pikajude> didn't help
13:41:25 <albeit> Yeah I'm using binary now, going to see if the other ways are faster
13:44:11 <pikajude> maybe this will elucidate http://lpaste.net/146435
13:44:16 <albeit> If I derive Storable for newtype Foo = Foo Int64, will it essentially be the same as Storable for Int64?
13:44:19 <pikajude> i'm guessing it's because AssetLanguage is an associated type
13:44:36 * hackagebot rtcm 0.1.0 - Haskell bindings for RTCM.  https://hackage.haskell.org/package/rtcm-0.1.0 (markfine)
13:44:45 <monochrom> yes albeit
13:46:32 <pikajude> so can I trick GHC into coercing it?
13:46:36 <pikajude> even unsafeCoerce doesn't work
13:46:52 <pikajude> because it introduces another hidden type variable. Asset a0
13:48:35 <albeit> Thanks monochrom 
13:49:25 <glguy> pikajude: To get more useful help you'll need to make it clear which things in your paste are type families and which things are not
13:49:45 <glguy> and possibly what the types of things are
13:49:56 <pikajude> glguy: everything is in the paste
13:50:03 <pikajude> servescript.hs compiles
13:50:06 <pikajude> for me, anyway
13:50:18 <pikajude> well, except for the type error on line 55 obviously, no scoping errors or anything though
13:50:21 <pikajude> all the definitions are there
13:50:22 <glguy> Lots of things are in the paste that have no definition or type signature in the paste
13:50:45 <pikajude> like what?
13:50:52 <monochrom> there have been two pastes
13:50:59 <glguy> ah
13:51:02 <monochrom> they are 33-7 minutes apart
13:51:03 <pikajude> oh, yeah, i forgot i did the second one
13:51:10 <pikajude> my mistake
13:51:58 <pikajude> http://lpaste.net/146434 was the original, i simplified the function i'm trying to write in this paste http://lpaste.net/146435
13:52:02 <pikajude> but the definitions should all be there
13:52:06 <glguy> pikajude: You have a class method "compiler" that only uses the 'a' type inside a type family
13:52:27 <glguy> pikajude: so there's no way to know which instance is being selected when 'compiler' is used
13:52:39 <pikajude> oh
13:52:49 <pikajude> can I use a functional dependency to resolve that?
13:52:58 <glguy> no, because that class only has one parameter
13:53:11 <glguy> You can add a proxy argument to that method, though, to specify the type
13:53:25 <pikajude> or I could parameterize it with the language
13:55:02 <athan> Man I can't wait to be able to do more dependent typing in haskell
13:55:22 <athan> I'm not sure if it helps, but I've always wanted functional dependencies that weren't so strict on monomorphism
13:55:57 <athan> I'm sure that partial type inference would be really hard to capture, but with it, you could do something like lens into a monad transformer stack generically
13:56:23 <monochrom> I do not believe that functional dependency and dependent typing are related.
13:56:43 <athan> monochrom: Well, in terms of unification abstractly I think they are
13:57:13 <athan> wait derp
13:57:28 <athan> I was thinking of putting some kind of dependent information into a typeclass
13:58:10 <athan> or really, relax a functional dependency - imagine having MonadReader where you index on _part_ of an `r` type
13:58:18 <athan> and leve the rest polymorphic
13:58:21 <athan> leave*
13:59:05 <albeit> Are there any advantages to switching from a repa array F (foreign memory buffers) to a repa array U (adaptive unboxed vectors) for just Int64?
13:59:19 <albeit> (Sorry, reverse... switching from U to F)
13:59:35 <albeit> (sorry... original way, doh)
14:00:20 <aweinstock> any recommendations for crypto libraries? (I need to be able to use RSA/AES with funky key sizes, it's for a security class and I just got permission from the TA to use haskell)
14:01:11 <byorgey> albeit: well, at any rate, you certainly don't want to keep switching back and forth like that ;-)
14:01:26 <sm> aweinstock: how about cryptonite
14:02:02 <albeit> byorgey: Ha, fair enough. The documentation says U is "the most efficient representation for numerical data", but how is that so over foreign memory buffers? I would think they would be the fastest, "closest to the metal" and all that
14:03:04 <byorgey> albeit: unfortunately I do not know the answer to your actual question
14:04:38 <aweinstock> sm: looks flexible enough, thanks
14:14:42 <geekosaur> albeit, what efficiency is meant there?
14:15:02 <geekosaur> close to the metal may be most efficient for storage but not particularly efficient for processing with normal Haskell code
14:15:18 <geekosaur> (unless you plan to use unboxed everything)
14:16:03 <geekosaur> (that is, you also use unboxed literals and (+#) etc.)
14:16:29 <cynick> sb
14:16:51 <lamefun> I'm seriously tempted to make a custom Prelude... with Text, ListLike function, etc...
14:17:03 <exio4> ClassyPrelude might be for you lamefun 
14:28:25 <hexagoxel> lamefun: i am one project in using a custom (per-project) prelude, and am happy so far, apart from stuff that i want to be qualified by default.
14:28:57 <Sonolin> trying to learn lenses...
14:29:03 <Sonolin> any idea why this isn't working:
14:29:04 <Sonolin> Map.fromList [("hello","there")] ^.at "hello"
14:29:19 <Sonolin> I get error (from ghci): Couldn't match expected type `Index (Map [Char] [Char])' with actual type `[Char]'
14:29:23 <c_wraith> :t at
14:29:25 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
14:29:50 <c_wraith> :t M.fromList
14:29:51 <lambdabot> Ord k => [(k, a)] -> M.Map k a
14:30:15 <c_wraith> > M.fromList [("hello", "there")]  ^. at "hello"
14:30:17 <lambdabot>  Just "there"
14:30:39 <glguy> Sonolin: You probably have more than one version of containers installed
14:30:45 <Sonolin> wtf lol
14:30:47 <c_wraith> Sonolin: is Map an import of Data.Map?
14:30:50 <Sonolin> yea
14:31:02 <c_wraith> Then I'm going with glguy's guess
14:31:03 <glguy> or something else weird about the evironment you're using that code in
14:31:03 <Sonolin> glguy: you mean like "lxc"? I have that installed for docker if that matters..
14:31:27 <c_wraith> Sonolin: no, the "containers" haskell package, the one that contains Data.Map
14:31:35 <Sonolin> hmm 
14:31:44 <glguy> Sonolin: No, like you compiled "lens" against one version of containers, but actually aren't using that one at the moment
14:31:47 <c_wraith> Sonolin: run "ghc-pkg list containers"
14:31:49 <Sonolin> only things I have installed with cabal is ncurses, and lens
14:32:07 <Sonolin> yea
14:32:14 <Sonolin> "there are broken packages"
14:33:30 <nbubub> does anyone have experience with threepenny gui?
14:33:41 <Sonolin> http://pastebin.com/sbGv03rJ
14:34:04 <Sonolin> not quite sure how to fix that..
14:34:23 <c_wraith> Sonolin: that looks like you installed ghc from apt?
14:34:27 <Sonolin> yea
14:34:34 <c_wraith> Sonolin: that's...  not recommended. :)
14:35:01 <Sonolin> well that kind of sucks
14:35:14 <glguy> You can use packages from apt, but then you need to use all packages from apt
14:35:21 <Sonolin> oh I see
14:35:30 <Welkin> you installed it in the future in a parition that does not exist yet, in a parallel universe
14:35:32 <glguy> mix and match requires you to really understand what you're doing
14:35:34 <Welkin> time to forkIO
14:35:56 <Welkin> Sonolin: just use stack
14:36:11 <Welkin> or install ghc + cabal-install from the binary distribution
14:36:42 <Sonolin> I'll look into stack
14:37:09 <Sonolin> but I'd just like to make a haskell app that's easily usable by vanilla ubuntu users 
14:37:40 <c_wraith> well, haskell creates (mostly) statically-linked executables
14:37:59 <c_wraith> You can compile something for distribution that doesn't depend on debian/ubuntu ghc at all
14:38:13 <Sonolin> oh yee that's very true :)
14:38:37 <Sonolin> well I'll just go with stack then, thanks :)
14:47:13 <dominik> hey Haskeller's
14:47:54 <dominik> is there any way to have a getLine and allow the user to use back space in order to correct what has already been typed?
14:48:09 <sm> haskeline is one lib for that
14:48:31 <geekosaur> well, backpace "ought" to work regardless, except possibly when run from ghci
14:49:05 <dominik> geekosaur: hmm, right!
14:49:05 <glguy> specifically it works when you have LineBuffering set for stdin
14:49:14 <geekosaur> but, assuming a unixy thing, it's the dumb line editing in the terminal driver and not proper line editing (for which you want haskeline or readline)
14:49:38 * hackagebot minimal-configuration 0.1.2 - Minimal ini like configuration library with a few extras  https://hackage.haskell.org/package/minimal-configuration-0.1.2 (MariusGhita)
14:49:45 <dominik> ok, cool. I'll check that out!
14:49:47 <dominik> thanks!
14:54:22 <Pamelloes> If I have an [IO a], I can convert it to IO [a] via sequence and then run each task sequentially. Is there a way to convert the [IO a] into IO [a] where all of the actions are run in parallel instead of in sequence?
14:54:55 <glguy> The async library is likely to either have exactly that or something close
14:58:35 <c_wraith> async has mapConcurrently, which will do.  That'd be like  mapConcurrently id
14:59:50 <Pamelloes> Perfect :)
14:59:57 <rnhmjoj> hi all, I need a hand with System.Process. I use createProcess to start a program which immediatly spawn a child. I need to send a signal to the child signal but I don't have its processHandle. I could use the fact I noticed the pid is always 1+pid of the parent, but I guess it's a coincidence. What is the proper way to go?
15:00:51 <cite-reader> rnhmjoj: That's a weird setup. Why do you need the grandparent to signal the grandchild?
15:01:21 <geekosaur> rnhmjoj, it's actually not guaranteed at all (and some systems for security use random pids! although I don't know if ghc is available for them). I think you want to spawn in a process group and signal that, if you can't get the child to report to you the grandchild's pid
15:01:30 <Welkin> smoke signals?
15:01:31 <monochrom> System.Process.Internal exposes the PID
15:01:32 <geekosaur> (may need to use System.Posix.Process)
15:01:45 <Welkin> the daemon will call child services!
15:02:12 <AfC> rnhmjoj: oh, yeah, never assume you can guess the PID.
15:02:57 <rnhmjoj> cite-reader: I'm starting a program which is basically a shell wrapper for the actual program. I need to send it a SIGKILL when it's done. If i kill the wrapper the process will detach but it won't close.
15:03:18 <cite-reader> ... why does it need SIGKILL to stop?
15:03:33 <geekosaur> SIGKILL sounds a bit wrong, yeh
15:04:02 <cite-reader> This whole _thing_ sounds wonky but I've done vaguely similar things so I'm giving rnhmjoj the benefit of the doubt.
15:04:16 <rnhmjoj> cite-reader: That's a good question: I know it sound drastic but it ignores every other signal
15:05:14 <cite-reader> So once the worker finishes, it just hangs? Oy.
15:05:19 <echo-area> rnhmjoj: Perhaps use `exec` at the end of the wrapper shell script?
15:05:21 <cite-reader> How are you detecting that it's done?
15:05:40 <monochrom> yeah, exec is more direct
15:06:18 <geekosaur> could also have the shell wrapper use "trap" to catch SIGTERM and kill the grandchild as needed, if the wrapper must for some reason keep running
15:06:33 <rnhmjoj> I use a socket to send him some instructions and the i'm done. The problem is there is no way to terminate it from the socket.
15:07:04 <AfC> rnhmjoj: you should look at a helper package like https://hackage.haskell.org/package/shellmate
15:07:35 <geekosaur> but I think this is what the create_group thing in CreateProcess is there for
15:08:42 <rnhmjoj> echo-area: I don't control the code in the wrapper, unfortunately.
15:08:53 <geekosaur> hm, but that only knows how to send SIGINT, you;d have to extract the pid via System.Process.Internal, negate it to make a POSIX process group, and use System.Posix.Process to send SIGKILL
15:09:13 <geekosaur> (limitation probably because Windows)
15:09:25 <cite-reader> Hopefully nothing in the wrapper or the thing that's wrapped calls setsid.
15:09:39 * hackagebot reedsolomon 0.0.2.0 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.2.0 (NicolasTrangez)
15:10:07 <geekosaur> I think that would not affect pgrp based stuff
15:10:24 <geekosaur> well, if the wrapped thing does, yes, you lose
15:10:35 <geekosaur> if the wrapper does it wouldn't matter since it would already be in its own pgrp
15:10:57 <geekosaur> and new pgrp is set the pgrp to the pid, which it already would be
15:24:22 <rnhmjoj> I tried createProcess with create_group=True and then using interruptProcessGroupOf works. I have just found out it ignores only the first SIGTERM: so I can simple call this function two times.
15:25:42 <rnhmjoj> thank you all for the tips!
15:25:53 <emmanuel_erc> Hey there eveyrone!
15:27:57 <dmj> emmanuel_erc: hey !
15:28:25 <emmanuel_erc> Hey there dmj!
15:28:32 <emmanuel_erc> I just made some big changes to some source code in a project I am working on. I am not asking for a code review, but I do want to ask if you find the code "readable"?
15:28:51 <emmanuel_erc> Here's a link: https://github.com/emmanueldenloye/manifoldRNC.
15:29:58 <emmanuel_erc> I did take some code from marlow's concurrency book.
15:34:46 <Luke> does attoparsec have a way to "skipTill :: f a -> f a" where it keeps trying to apply "f a" while throwing away failures until endOfInput?
15:34:57 <Luke> or how would I make that?
15:40:29 <glguy> skipUntil p = endOfFile <|> p <|> (skip 1 >> skipUntil p) -- or similar perhaps
15:41:54 <rnhmjoj> emmanuel_erc: wow, I'm not even sure I get what it is about. It reduces higher dimensional data to be visualized?
15:47:18 <emmanuel_erc> hi rnhmjoj. There's a paper in the repo ("brun2005fast.pdf") if you interested in getting an idea of what is going on.
15:48:27 <emmanuel_erc> It is simply just a manifold learning algorithm and my first haskell project.
15:55:04 <rnhmjoj> emmanuel_erc: I have just started studying linear algebra and this is definitely interesting.
16:07:19 <ga2arch> emmanuel_erc: something weird in the main, you're wrapping and unwrapping value just for the sake of using <$>/<*> and building a tuple then decomposing it when you could use those values directly or i'm missing something, kinda late here 
16:08:32 <emmanuel_erc> rnhmjoj: Thanks!
16:10:08 <emmanuel_erc> Hi there, I just wanted to put all those values in "one place". I was having trouble predicting performance before I rewrote this file.
16:10:28 <emmanuel_erc> And I thought that writing this way would make it easier (at least for me).
16:12:54 <rnhmjoj> emmanuel_erc: the spaces after the "import" keyword are left where "qualified" would be?
16:13:16 <rnhmjoj> just wondering
16:13:24 <emmanuel_erc> Is this in Main.hs rnhmjoj?
16:13:29 <rnhmjoj> yep
16:13:52 <emmanuel_erc> I see what you mean... yeah.
16:13:57 <emmanuel_erc> lol 
16:19:56 <ga2arch> emmanuel_erc: something like this maybe http://lpaste.net/146445 ? 
16:20:23 <ga2arch> emmanuel_erc: haven't checked it thought 
16:21:15 <ga2arch> emmanuel_erc: ah i see that convertImages is pure, so that would be a let images = convertImages matrix instead of images <- ...
16:24:47 <rnhmjoj> emmanuel_erc: In Plots.hs you should really use the functions from System.FilePath
16:25:22 <emmanuel_erc> ga2arch: I think what you wrote is clearer, but, and perhaps I am missing something here, the buildShortestPaths function is the most time consuming function.
16:25:39 <emmanuel_erc> So, I wanted to isolate *when* that happened.
16:26:50 <emmanuel_erc> rnhmjoj: are you talking about "actualFile = reverse . takeWhile (/= '/') . reverse $ file"?
16:26:56 <rnhmjoj> yes
16:27:00 <emmanuel_erc> lol
16:27:36 <ga2arch> emmanuel_erc: depends on what you mean by *isolate*, i don't see what you're trying to achieve by wrapping it inside a tuple. 
16:27:39 <emmanuel_erc> that was written from a place of impatience
16:28:19 <rnhmjoj> ahah, i'm way too lazy for that
16:29:13 <emmanuel_erc> What I mean by isolate, was I having a hard time analyzing the performance of my code. I thought trying to sequnce when that value would be computed (in the IO Monad) would make sense.
16:29:29 <emmanuel_erc> But I am probably misunderstanding something.
16:30:15 <ga2arch> well, the type of the main is IO () so you're already inside the IO monad
16:32:01 <ga2arch> mmm, do you think that using the <- would force the computation of the function ?
16:32:43 <emmanuel_erc> yeah, I think that is what I was thinking, but I don't think I understand Haskell as well I thought.
16:33:11 <emmanuel_erc> My code is faster after making this rewrite, but probably not for the reasons I thought.
16:34:41 * hackagebot persistent-iproute 0.2.1 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-iproute-0.2.1 (sickmind)
16:38:47 <emmanuel_erc> ga2arch: Even though I "understand" what lazy evaluation, it is a bit frustrating/opaque to understand it that affects my code.
16:40:18 <sbrg> emmanuel_erc: have you tried profiling it? 
16:41:48 <emmanuel_erc> I have. The reports just tell me that Repa is doing most of the work (I think).
16:49:08 <ga2arch> emmanuel_erc: may i suggest you to use a little less <$>/<*>, i see stuff like this liftM2 getFile <$> return . Prelude.head <*> fileArgs $ args, it makes the code harder to follow and a lot less clear. 
16:50:29 <emmanuel_erc> ga2arch: Thanks for the suggestion. Is that line of code in Utils.hs?
16:51:08 <ga2arch> emmanuel_erc: i was looking at an old revision of the code, trying to see how the main.hs evolved, so i don't know if it's still there
16:53:15 <emmanuel_erc> Oh, I hope it isn't too obvious that I am still a beginner. Thanks for doing that by the way, I wasn't expecting that.
16:53:37 <ga2arch> emmanuel_erc: let (len,images) = (,) <$> fst . H.size <*> V.map (U.fromList . L.toList) . V.fromList . H.toRows $ rawImages just do two separate let instead of building a tuple and then decompose it, much easier to read. 
16:54:48 <emmanuel_erc> I don't think that line is in the current version any longer. I don't even like reading that btw.
16:57:18 <ga2arch> emmanuel_erc: gotta go to bed, bye :)
16:57:33 <emmanuel_erc> thanks for you worsd ga2arch!
16:57:45 <emmanuel_erc> words*
17:09:26 <ReinH>  Cale: I remembered my favorite non-computational Monad instances: vectors w/ diagonalization
17:10:03 <ReinH> although I suppose there's probably a computational interpretation
17:11:23 <lethjakman-l> So...as a rule of thumb. Should I break down complex data types into simpler ones, or should I just write functions that know how to deal with said datatypes?
17:11:46 <lethjakman-l> I've been playing around with both in a application, but I'm not sure what I think of it. 
17:12:22 <MarcelineVQ> pretty general question, prob just keep playing with it until the more comfortable option is obvious to you
17:15:08 <augur> are there any good haskell audio synth libraries?
17:15:33 <hpc> i remember one from -cafe
17:15:42 <hpc> but the name escapes me
17:16:24 <hpc> not finding it on hackage
17:17:29 <hpc> might be haskore i am thinking of
17:18:40 <lethjakman-l> MarcelineVQ: I figured it'd just be general preference. I was just wondering if there was a style guide thing. 
17:20:17 <Welkin> did someone say haskore :D
17:20:29 <augur> lmfao Welkin
17:21:38 <Welkin> augur: haskore, which later became euterpea I think
17:21:46 <Welkin> http://haskell.cs.yale.edu/euterpea/
17:22:01 <Welkin> algorithmic music composition
17:22:08 <Welkin> you can also write out scores manually I believe
17:22:20 <augur> i dont need music, i need sound synthesis
17:22:29 <Welkin> yes
17:22:31 <Welkin> it does that
17:23:55 <hpc> music is a complete encoding of sound
17:23:59 <hpc> just ask any dubstep producer
17:24:22 <augur> hpc: lol
17:28:17 <lethjakman-l> Welkin: That's cool. I love the name. 
17:34:45 <zoku> Is anyone proficient with irc-conduit?
17:35:00 <zoku> I'm struggling to understand how to setup Sources and Sinks
17:35:20 <augur> Welkin: do you know haskore?
17:36:13 <Welkin> augur: nope
17:36:28 <Welkin> but I have been meaning to try euterpea for a while now
17:38:09 <cj_howe> for emacs people: has anyone tried setting up helm completion at point for haskell? i want the equivalent of helm-lisp-completion-at-point for haskell
17:40:42 <augur> Welkin: we should start a little study group to learn it, then
17:41:04 <Welkin> augur: there is a book that is quite extensive
17:41:30 <Welkin> http://haskell.cs.yale.edu/wp-content/uploads/2015/03/HSoM.pdf
17:41:32 <augur> cool
17:42:38 <Welkin> oh, it looks like it covers general haskell too
17:42:39 <Welkin> haha
17:42:43 <Welkin> learn haskell through music
17:49:45 * hackagebot validation 0.5.2 - A data-type like Either but with an accumulating Applicative  https://hackage.haskell.org/package/validation-0.5.2 (TonyMorris)
19:03:55 <jle`> hsom has aged well
19:06:43 <Welkin> jle`: like a fine cheese
19:06:57 <Welkin> jle`: is that your pick up line in the bars?
19:09:37 <dfeuer> I'm trying to implement  f :: Representational p => Coercion a b -> Coercion (p (Fix p x) a) (p (Fix p x) b), and I seem to be quite stuck.
19:09:49 * hackagebot incremental-parser 0.2.4.1 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.2.4.1 (MarioBlazevic)
19:09:58 <dfeuer> Any ideas?
20:09:55 <haskell193> why isn't scanr f == scanl (flip f)?
20:11:49 <monochrom> no, a better question is why would they be equal
20:13:16 <monochrom> some people may answer, "I intuit that they are equal because one says l, the other says r". well that's shallow and imprecise reasoning, don't even worth one's time to refute.
20:15:50 <haskell193> oh I get it, scanr read it backward
20:17:57 <monochrom> that's sounds wrong, too
20:18:36 <monochrom> if "scanr reads it backward" were true, it would bottom out for infinite lists, since reading an infinite list backward bottoms out.
20:18:45 <monochrom> and yet,
20:19:01 <monochrom> > take 1 (scanr (+) 0 [0..])
20:19:03 <lambdabot>  [*Exception: stack overflow
20:19:19 <geekosaur> heh
20:19:30 <monochrom> I guess it bottoms out
20:20:01 <exio4> > take 1 (scanl (+) 0 [0..])
20:20:02 <lambdabot>  [0]
20:20:47 <bros> https://github.com/takeoutweight/shade-todomvc/blob/master/src/Main.hs
20:20:55 <bros> How the hell do people use this language for anything serious? (serious question)
20:21:01 <bros> I've tried like 9 times to learn it/pick it up
20:21:43 <monochrom> ah, here is how it doesn't bottom out:
20:21:51 <monochrom> > seq (scanr (+) 0 [0..]) ()
20:21:52 <lambdabot>  ()
20:22:22 <haskell193> :t seq
20:22:23 <lambdabot> a -> b -> b
20:22:55 <monochrom> the type tells you almost nothing. you will have to read up on seq for real.
20:23:23 <monochrom> if you demand a less magical experiment, here is one, it's just longer
20:23:35 <monochrom> > case (scanr (+) 0 [0..]) of _:_ -> ()
20:23:37 <lambdabot>  ()
20:23:46 <haskell193> > take 1 $ reverse [0..]
20:23:51 <lambdabot>  mueval-core: Time limit exceeded
20:24:00 <tabemann> :hoogle [a] -> (Maybe a, [a])
20:25:32 <monochrom> it's @hoogle not :hoogle
20:25:56 <tabemann> @hoogle [a] -> (Maybe a, [a])
20:25:59 <lambdabot> No results found
20:26:33 <tabemann> I'm surprised that there is no uncons in Data.List or like
20:26:57 <monochrom> there is one in parsec :)
20:27:17 <DarwinElf> pikajude, did kevin compile with newer dependencies, or you're still working on it, or gave up?
20:48:33 <dmwit_> ?where aam
20:48:34 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
20:50:07 <lispy> dmwit_: oldie but goodie
20:50:34 <dmwit> That and "You Could Have Invented Monads" are my two go-to tutorials for newcomers.
20:53:20 <lispy> sigfpe has some great articles
20:53:48 <lispy> (for anyone reading along who doesn't already know sigfpe's blog: http://blog.sigfpe.com/)
21:09:56 * hackagebot git-vogue 0.2.1.0 - A framework for pre-commit checks.  https://hackage.haskell.org/package/git-vogue-0.2.1.0 (oswynb)
21:47:37 <julianleviston> I have an IO ByteString do block. Inside it, I another do block (of type Either ByteString) with three things I want to do. One of these things, though (middle one), yields an IO ByteString. The second thing uses the ByteString from that result. How is it best to organise this code? Should I have the inner do block be an IO (Either ByteString)? If so, do I need to apply liftIO to the two outer Either ByteString values?
21:48:06 <julianleviston> Or should I use an MT, or something?
21:48:10 <jle`> bros: it happens :)
21:48:15 <jle`> i'm not sure what kind of answer you're looking for
21:48:22 <jle`> but people use it and enjoy it ^^
21:48:24 <bros> jle`: i just want to learn the damn language!
21:48:33 <bros> i can't do it. people say javascript is... harder?
21:48:36 <jle`> have you tried reading through an introduction?
21:49:38 <jle`> julianleviston: EitherT might be useful if you're doing a lot of repeated nested pattern matching
21:49:44 <jle`> (assuming your code is already working)
21:49:48 <julianleviston> jle`: I only have two eithers.
21:50:04 <julianleviston> jle`: well, my code is working without using eithers - just a bunch of Maybes
21:50:17 <jle`> if you find yourself doing a lot of nested pattern matching in a do block then MaybeT or EitherT might be able to make it simpler
21:50:37 <julianleviston> jle`: which as you can imagine, sucks, for a couple reasons: 1. I want to fail with a message… 2. I don’t actually want to fail with one of the maybes.
21:50:39 <jle`> can you paste something like what you have?
21:51:00 <bros> jle`: yes. it's always very math heavy
21:51:04 <jle`> hm
21:51:06 <julianleviston> jle`: um… it’s in a transitive state at the moment. I have the working version that doesn’t quite do what I want,, and a broken version that’s sort of what it is supposed to be.
21:51:07 <bros> jle`: i like stuff like APIs, network.
21:51:13 <julianleviston> jle`: I don’t think it’s math heavy.
21:51:14 <jle`> bros: that's weird, most of the introductions i've read have had no math in it at all
21:51:24 <jle`> no haskell intropduction i've ever read had any math in it heh
21:51:26 <jle`> or haskell course
21:51:29 <julianleviston> jle`: it’s just “complex sounding”
21:51:34 <jle`> well, besides like, 1 + 2
21:51:41 <jle`> addition is as mathy as it gets :)
21:51:45 <jle`> oh, sometimes we multiply numbers too :3
21:51:48 <c_wraith> I really do believe haskell is simpler than class-based languages.
21:51:54 <julianleviston> me too
21:52:00 <julianleviston> that’s the reason people have trouble with it.
21:52:02 <jle`> it's definitely simpler to write/debug
21:52:13 <jle`> debugging and maintaining javascript is impossible, compared to haskell code
21:52:25 <exio4> class-based languages let you write code impossible to mantain much easier though 
21:52:36 <jle`> yeah, that's 'the thing'
21:53:08 <julianleviston> yeah
21:53:25 <julianleviston> class based languages just say “hey, don’t worry about that complexity, it doesn’t exist!”
21:53:40 <julianleviston> haskell says “you shall not pass… until you deal with the complexity"
21:53:46 <jle`> bros: what introductions are you reading to haskell that are math heavy?
21:53:59 <jle`> you might have been reading "haskell for mathematicians", maybe?
21:54:02 <bros> jle`: real world haskell, learn you a haskell
21:54:14 <julianleviston> learn you is mathy?
21:54:18 <exio4> how are those two `mathy`? 
21:54:36 <julianleviston> bros: are you talking about when they say “Monoid” and “Functor” and such?
21:55:06 <julianleviston> bros: or the fact that they use words like “associativity” and “commutativity” ?
21:55:07 <bros> http://learnyouahaskell.com/starting-out#ready-set-go
21:55:10 <bros> the whole thing is math
21:55:15 <bros> julianleviston: no, i don't even make it that far
21:55:18 <bros> Every example is pure math.
21:55:26 <bros> [x*2 | x <- [1..10], x*2 >= 12]  
21:55:28 <julianleviston> what the addition?
21:55:39 <julianleviston> list comprehensions aren’t math.
21:55:57 <jle`> i guess they use addition and multiplication to demonstrate syntax
21:55:58 <julianleviston> They’re similar to set comprehensions from set theory in math, but they’re not.
21:55:59 <bros> 10,000 words in, i'm reading about right triangles...
21:56:08 <jle`> ah
21:56:14 <jle`> the language doesn't actually have anything to do with right triangles
21:56:26 <julianleviston> hm
21:56:28 <jle`> it's just using right triangles as an example to demonstrate syntax i guess
21:56:29 <jle`> have you tried
21:56:29 <bros> http://book.realworldhaskell.org/ is down?
21:56:32 <jle`> @where learnhaskell
21:56:32 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:56:49 <bros> i did
21:56:52 <bros> notice the title of week 2
21:56:54 <julianleviston> bros: what would you rather ?
21:57:01 <bros> "algebraic data types"
21:57:14 <julianleviston> bros: functions are math
21:57:19 <julianleviston> bros: in fact, all programming is math
21:57:23 <jle`> bros: don't be scared by the title, heh
21:57:26 <jle`> it actually isn't anything mathy at all
21:57:29 <julianleviston> bros: depending on what part of math you’re talking about.
21:57:34 <jle`> they could have been called "cakes and puppies data types"
21:57:54 <jle`> you've probably used ADT's in normal programming
21:58:05 <jle`> if you've ever used bools, it's an ADT :)
21:58:19 <jle`> the names can sound mathy but the concepts are pretty straightforward
21:58:22 <julianleviston> so, the problem isn’t the math, it’s the fact that it uses mathy language.
21:58:37 <julianleviston> it’s the formality
21:58:40 <jle`> i guess if it 'sounds mathy', it's intimidating
21:58:40 <bros> julianleviston: I'm a full stack developer at a startup. It's not all math, lol
21:58:46 <jle`> even if it isn't really mathy at all
21:58:48 <julianleviston> bros: yes it is.
21:58:51 <julianleviston> bros: all of it.
21:58:52 <jle`> bros: we can give anything you do a 'mathy name'
21:58:55 <julianleviston> bros: ALL programming is math.
21:59:12 <jle`> bros: it's math, but you're not scared by it, because it doesn't have a mathy name, and you're familiar with it :)
21:59:14 <bros> julianleviston: if you want to be a pedant... but I guess if you write Haskell, that comes with the job description
21:59:20 <julianleviston> bros: nope.
21:59:21 <jle`> not exactly
21:59:29 <bros> jle`: no, because the syntax isn't asinine
21:59:39 <jle`> i write haskell...practical haskell usage is no more mathy than any other programming language
21:59:56 <jle`> everything you do in normal programming can be given a mathy scary-sounding name too
22:00:18 <jle`> but that doesn't make it any more or less "mathy" :)
22:00:35 <bros> I don't want to sound argumentative, but, I strongly feel the ToDo MVC example I linked https://github.com/takeoutweight/shade-todomvc/blob/master/src/Main.hs should be considered out of the realm of normal in terms of complexity
22:01:35 <jle`> data TodoFilter = Active | Completed | AllTodos
22:01:45 <parsnip> bros: i think the designers of haskell are very particular in coming up with how they want to represent things, and the learning curve can be a little steeper than other languages, but if you're patient and stick with it, i hope we (two newcomers) can benefit from good design. 
22:01:46 <jle`> that means that a value of type TodoFilter can have three values: Active, Completed, and AllTodos
22:01:49 <jle`> it's an enumerable
22:02:22 <bros> things I don't understand: MVar, Maybe, Nothing, Just, let, in, do, where, _, ->, <-, =>, map, |, fmap, \
22:02:24 <julianleviston> jle`: no it doesnt - it can have any ONE of three values.
22:02:27 <jle`> i think it's tricky to judge how complex something is if you're not too familiar with it.  i mean, if you showed a random person on the street a simple program written in any language, they might think it's abnormally complex
22:02:34 <jle`> julianleviston: thanks for the correction :)
22:02:45 <jle`> bros: that's because you haven't learned about them?
22:02:56 <jle`> multiplication is complex to anyone who has never added before
22:02:57 <parsnip> bros: Just is a minimalist wrapper to be conistent with the empty Nothing wrapper. 
22:03:08 <bros> jle`: absolutely. but like, i'm able to write full fledged apps in various languages, and i can't even make it through a haskell tutorial, and i know that makes me sound stupid, but i can't be alone.
22:03:24 <julianleviston> bros: You’re expecting too much.
22:03:49 <jle`> learning haskell is *different*, but it's not harder.  it's just tricky because you sort of have to re-learn programming from scratch
22:03:51 <julianleviston> bros: this comes from a fellow person who expects too much.
22:04:06 <jle`> the expectation is what throws you off
22:04:19 <jle`> my first programming language, it took me a year or so to really be comfortable reading the code
22:04:23 <julianleviston> bros: there are also portions which are not explained well. This does not help.
22:04:25 <bros> julianleviston: I reverse engineer Win32 MMOs for fun. I crack ARM binaries for kicks. I can't even make it through a hello, world tutorial with Haskell, because it's like, chapter 20, and you have to understand that IO is an unholy side effect of sin
22:04:56 <bros> jle`: I have great confident I could teach anybody the syntax of Javascript in 2 weeks. .forEach, array, object, if, var, string, done.
22:04:57 <julianleviston> bros: what?
22:05:06 <julianleviston> bros: what hello world tutorial has 20 chapters?
22:05:09 <jle`> bros: yes, of course you can, because javacsript is similar to a lot of things you already know
22:05:15 <bros> julianleviston: no, it's the 20th chapter
22:05:23 <jle`> because you're used to the idea that programming is all things that you are already familiar with
22:05:26 <bros> jle`: No. Because Javascript is easy to pick up.
22:05:27 <jle`> and you just have to adapt to new syntax
22:05:33 <julianleviston> bros: the problem is YOU’RE EXPECTING TOO MUCH :)
22:05:33 <bros> You type fewer crazy symbols and everything is much simpler.
22:05:39 <bros> julianleviston: Tell me what to expect.
22:05:40 <julianleviston> bros: I’m the same. I expect too much.
22:05:54 <julianleviston> bros: This is different than any other programming language you’ve learned.
22:06:12 <julianleviston> bros: you will have to re-learn how to do things from scratch.
22:06:14 <jle`> it's easy for you to pick up now, but it's normally tricky for someone who has never programmed before to pick up javascript for the first time
22:06:15 <bros> julianleviston: I'm well aware of this and I've been warned numerous times when attempting this.
22:06:31 <julianleviston> bros: then why do you continue to expect things?
22:06:34 <jle`> it might take them at least a month, maybe a year to be comfortable
22:06:35 <bros> jle`: Put two beginners side by side. One with Haskell, one with Javascript.
22:06:39 <bros> Who will learn quicker?
22:06:41 <jle`> actually
22:06:44 <julianleviston> bros: learn what?
22:06:44 <jle`> people have tried this
22:06:46 <bros> julianleviston: tell me what to expect?
22:06:50 <julianleviston> bros: I did.
22:06:57 <parsnip> javascript is hard, because you have to open an editor, /and/ a browser and brwoser debugger, etc blech
22:06:58 <jle`> haskell is usually easier to pick up for non-programmers
22:07:28 <jle`> how do you double everything in a list?
22:07:33 <jle`> > map (*2) [1,2,3]
22:07:36 <lambdabot>  [2,4,6]
22:07:36 <bros> jle`: with a for loop.
22:07:41 <bros> Haskell is too expressive.
22:07:42 <julianleviston> bros: no.
22:07:45 <bros> Too many shortcuts.
22:07:48 <bros> For its own good.
22:07:51 <jle`> you have to teach someone how a loop works
22:07:52 <julianleviston> bros: don’t use it.
22:07:53 <bros> How often are you doubling list sets?
22:07:53 <jle`> how a variable works
22:07:59 <julianleviston> bros: why do you want to use it?
22:08:01 <jle`> how to increment variables
22:08:08 <bros> julianleviston: Because of the hype.
22:08:09 <jle`> the *idea* of imperative progrmaming is foreign to most people who are non-programmers
22:08:15 <julianleviston> bros: that’s always a bad reason.
22:08:18 <jle`> but everyone knows what it means to double everything in a list
22:08:18 <julianleviston> bros: also, what hype?
22:08:39 <bros> julianleviston: there is a fair bit of hype surrounding the language. it gets a lot of praise
22:08:46 <julianleviston> bros: ah ok.
22:08:52 <julianleviston> bros: it’s probably because it’s excellent.
22:08:58 <bros> and i believe that
22:08:58 <jle`> bros: i use higher order functions like map all the time in programming.  i have a list of strings and i want to print them all out.  i just mapM a "print" through the whole list
22:09:02 <bros> i just, can't even begin to see it
22:09:12 <julianleviston> bros: so don’t use it.
22:09:15 <jle`> instead of saying, "initialize a counter.  then, iterate through the list by mutating your counter.  then get that index at the list, and print it out"
22:09:19 <parsnip> bros: watch the sicp videos
22:09:23 <jle`> instead, you just say, "print everything in the list."
22:09:29 <jle`> map a 'print' function over the list
22:09:46 <parsnip> bros: sicp emphasizes importance of abstraction, and haskell seems to have a bit of abstraction. 
22:09:54 <bros> jle`: if we had to race to build a practical app that involves a database and web app, who would win? javascript vs haskell? It wouldn't even be a fair matchup.
22:09:57 <bros> You'd be writing type signatures
22:10:01 <bros> doing list comprehensions matching to strings
22:10:06 <bros> when I'd be done, working on frontend
22:10:12 <bros> at what benefit?
22:10:27 <bros> (in terms of the web case, i'm very familiar with the proposed benefits of haskell)
22:10:31 <jle`> well, as an aside, haskell dev  and prototyping is actually pretty fast
22:10:33 <bros> purity, clarity, compile-time error catching
22:10:38 <jle`> but, building an app fast isn't the best goal
22:10:41 <jle`> what about maintenance?
22:10:46 <jle`> one year down the line, who is going to be having a tougher time?
22:10:53 <jle`> who is going to be having a tougher time scaling, refactoring, maintaining?
22:11:06 <bros> of course, but is that to say haskell trades away ease of bootstrapping
22:11:10 <jle`> i don't trust myself with any javascript or ruby or python i've written over at least even a few months ago
22:11:10 <bros> and, be honest
22:11:17 <bros> is it possible to write bad haskell
22:11:20 <bros> that needs refactoring
22:11:24 <julianleviston> of course.
22:11:28 <julianleviston> it’s not magic.
22:11:31 <julianleviston> that’s precisely the point.
22:11:33 <jle`> it's definitely a lot harder to write bad haskell, but even if you do, refactoring is a LOT easier
22:11:39 <jle`> refactoring in haskell is a joy :)
22:11:44 <jle`> and relatively painless to do large refactors
22:11:49 <jle`> and be confident that your code still works
22:12:00 <jle`> refactoring in javascript?  don't bother -- just re-do your entire code base
22:12:17 <bros> like i've said, i'd love to learn it, i obviously understand the proposed benefits
22:12:19 <jle`> haskell makes refactoring fun, and you can do it without fear :)
22:12:29 <julianleviston> bros: bull
22:12:44 <julianleviston> bros: take a very simple thing like getting the content of a file…
22:12:45 <bros> for example, BSD is not the best desktop operating system. is haskell maybe not the most practical web development language?
22:12:45 <jle`> also, haskell's inferred type system makes prototyping and building things fast actually nice
22:13:08 <jle`> because a lot of things that you have to "think through" in normal dynamic languages, haskell automatically writes it for you, basically
22:13:20 <jle`> a lot of tricky code, the haskell type system basically has the code write itself
22:13:27 <bros> jle`: i would have guessed it is the opposite actually
22:13:31 <jle`> haskell is about removing the burden of keeping track of complex systems
22:13:37 <bros> assuming i'd spend all day splitting hairs over type signature
22:13:47 <bros> julianleviston: go on
22:13:51 <jle`> you can if you wanted to
22:13:58 <jle`> but haskell makes it easier to write badly typed code now, and refactor later
22:14:05 <julianleviston> bros: in “another language”, you’d get the contents of the file - what happens if the file isn’t there?
22:14:11 <julianleviston> bros: let’s pick ruby.
22:14:12 <bros> exception
22:14:15 <jle`> but even with *minimal* types, it already offers a lot of guidance to help write your code
22:14:16 <julianleviston> bros: ok
22:14:26 <julianleviston> bros: so you wrap the whole thing in an exception catch
22:14:26 <bros> julianleviston: so a different code path to handles errors
22:14:51 <julianleviston> bros: but what if the exception was different?
22:14:55 <bros> i don't know how practical that is as most people have some sort of global error catcher that they bubble up to, but sure
22:15:01 <bros> julianleviston: you check the code of the exception
22:15:02 <jle`> i tend to write code faster in haskell than i do in other languages because haskell removes the burden of worrying about the complexity of your code...it worries about it for you, while you don't have to
22:15:14 <julianleviston> bros: yeah, but what if you didn’t catch all the types of exception it could be?
22:15:24 <bros> julianleviston: javascript isn't like that
22:15:27 <julianleviston> bros: what if the file was empty?
22:15:27 <bros> an error is an error
22:15:33 <julianleviston> bros: we’re talkng about ruby aren’t we?
22:15:37 <bros> then you'd get an empty string
22:15:38 <julianleviston> bros: ok, let’s switch to Javascript.
22:15:57 <bros> haskell makes you think of all possible routes, yes?
22:16:03 <bros> what if this error, what if it is empty, yeah?
22:16:04 <julianleviston> bros: that’s part of it.
22:16:10 <bros> what if you already do that in a normal programming language
22:16:25 <bros> not as well, obviously, but well enough to get by without falling flat on your face
22:16:36 <julianleviston> bros: then use that other programming language.
22:16:47 <bros> I'm not asking you to sell me a car.
22:17:05 <julianleviston> bros: You seem to be demanding we tell you why you would want to use Haskell
22:17:09 <bros> I'm asking how I can translate what I know in real world programming to get good enough in Haskell to be able to write some real world things with it.
22:17:24 <julianleviston> bros: it depends what you’re trying to write.
22:17:48 <bros> julianleviston: I like to play with APIs. I feel most apps can be broken down into: move this data from A to B, transform it a little, store it in a database, fetch it back, the end
22:17:50 <julianleviston> bros: If you want to write a web app, don’t expect it to be like writing a NodeJS app. It won’t be. JS doesn’t care about types.
22:18:14 <bros> julianleviston: i don't think having to specify int/str instead of var are the main breaking points when comparing it to node.js
22:18:31 <julianleviston> bros: I don’t get it. If node is working fine, then you don’t NEED haskell.
22:18:43 <julianleviston> bros: if you can do what you need and want to do in your languages, you don’t need it.
22:18:52 <julianleviston> bros: you only need it if you’re sick of doing the same thing over and over.
22:19:05 <bros> I could do what I needed in C before node. Now, I can do what I could in C in node better than ever.
22:19:12 <bros> I want to see if Haskell can offer the same advantages
22:19:13 <julianleviston> bros: or if you want to work at a level of abstraction so high that other langauges can’t get there.
22:19:21 <julianleviston> it can.
22:19:25 <julianleviston> but you need to need it.
22:19:26 <bros> what are the flaws of haskell?
22:19:34 <julianleviston> you’re describing them.
22:19:46 <julianleviston> the fact that it’s so different than other languages that people often can’t see what it is.
22:19:54 <NeverDie> Is it just me or does it feel like he's just here to troll. 
22:20:00 <julianleviston> no he’s not.
22:20:02 <jle`> there was a nice reddit post about flaws of haskell earlier :)  i'll find it
22:20:04 <julianleviston> he’s like I was originally.
22:20:54 <julianleviston> bros: if you’ve ever had a massive mess where things are not seperable, or reusable, you’ve needed haskell.
22:20:59 <julianleviston> separable*
22:21:21 <bros_> sorry
22:21:30 <bros_> how can I overcome the flaws of haskell
22:21:38 <julianleviston> bros_: what does that mean?
22:21:44 <bros_> most people learn python/php by copy and pasting cool things they like
22:21:55 <bros_> use this beautifulsoup library to parse HTML
22:22:03 <bros_> play with this USB device to get a light to turn on
22:22:08 <bros_> haskell is: double this set
22:22:09 <bros_> lol
22:22:15 <julianleviston> bros_: so what?
22:22:29 <bros_> like, i would be the perfect candidate to write a new, good tutorial for haskell
22:22:34 <bros_> i'd totally give back to the community
22:22:38 <bros_> i'd help people who have my problem
22:22:43 <bros_> i just, need direction on solving it
22:22:49 <julianleviston> bros_: solving what?
22:23:00 <julianleviston> bros_: there are numerous tutorials.
22:23:06 <bros_> do i *really* have to take what's effectively a college course to learn a programming language that's touted as "one with a light syntax"
22:23:25 <julianleviston> it’s not the syntax that is hard to learn.
22:23:36 <julianleviston> it’s simple.
22:23:37 <jle`> https://www.reddit.com/r/haskell/comments/3rnbqw/an_apology_to_the_functional_programming_community/cwpr08c
22:23:43 <julianleviston> it’s that simplicity that makes it difficult for people.
22:24:00 <parsnip> SICP teaches how to write a meta-language, not make a usb device light up. 
22:24:01 <jle`> that has a nice list of flaws about haskell and the ecosystem
22:24:03 <NeverDie> bros_ : It's already being done. http://haskellbook.com/
22:24:06 <NeverDie> You should buy it.
22:24:40 <bros_> NeverDie: page 16, first bit of code example, 2+2
22:24:41 <bros_> i'll pass
22:24:45 <julianleviston> bros_: I wonder if this would help you: http://www.genericoverlords.com/haskell_exercises
22:24:57 <julianleviston> NeverDie: SERIOUSLY? he’s complaining about math, and you recommend THAT book?
22:25:04 <bros_> julianleviston: first exercise, compare integers
22:25:10 <julianleviston> NeverDie: I’m one of that book’s biggest proponents, but that is NOT a good exercise
22:25:21 <julianleviston> bros_: you need to use numbers in every program. Don’t give me that.
22:25:29 <NeverDie> If he's complaining about math then he's better off not coding in Haskell. He seems to be too close-minded anyways.
22:25:29 <bros_> julianleviston: Have you written Javascript lately?
22:25:38 <julianleviston> bros_: yeah yeah floating point blah blah
22:25:43 <bros_> julianleviston: no, i'm serious
22:25:50 <julianleviston> bros_: you seriously write a JS program without using numbers?
22:26:01 <julianleviston> bros_: what programming are you doing? (and yes, I write JS almost daily)
22:26:13 <bros_> julianleviston: https://skulabs.com
22:26:31 <bros_> i would go as far to say that math is about 3% of building that entire application
22:26:43 <bros_> front and back. database, cache, logistics, inventory, you name it
22:27:15 <jle`> having the first example be 2+2 possibly a superficial reason to discount an entire course/tutorial that may go onto lgostics, database, web stuff, etc.
22:27:20 <julianleviston> bros_: oh noes… there’s some numbers in your javascript (seriously, there is)… how can you cope with all that math? :0 lol
22:27:26 <NeverDie> Lol.
22:27:30 <jle`> i'm sure a lot of python tutorials start with asking people to type 2 + 2 in a repl
22:27:50 <NeverDie> That's just his bias getting the best of him.
22:27:58 <bros_> start? i'm 10k words in and they are still playing with arrays of numbers http://www.genericoverlords.com/haskell_exercises
22:28:01 <jle`> maybe it's worth going through the first example to see what else it has to offer :)
22:28:11 <julianleviston> bros_: I wrote that, by the way.
22:28:17 <bros_> julianleviston: Yikes.
22:28:18 <julianleviston> bros_: it’s the exercises I used to learn Haskell.
22:28:23 <julianleviston> bros_: for myself.
22:28:39 <bros_> julianleviston: cool that you shared that with the world. very good cause, nicely formatted.
22:28:40 <julianleviston> bros_: not arrays, lists.
22:28:40 <bros_> but uh
22:28:53 <julianleviston> bros_: it’s not for the world.
22:28:59 <jle`> the point is that you can manipulate other objects and things in haskell the same way as you'd manipualte any other ol' variable
22:29:03 <julianleviston> bros_: I was just sharing it with you because I thought it might help.
22:29:11 <bros_> you wrote that for yourself?
22:29:12 <jle`> so learning how to work with arrays of numbers isn't any too different than learning hwo to work with an array of, say, API requests
22:29:21 <jle`> or database connections
22:29:29 <NeverDie> julianleviston: You shouldn't waste your time on him.
22:29:31 <julianleviston> bros_: yeah… gave myself loads of exercises and slowly built up my understanding.
22:29:37 <julianleviston> NeverDie: don’t be rude! :)
22:29:42 <NeverDie> I seriously think this guy is here to troll. 
22:29:42 <peddie> bros_: when I learned haskell, I started with https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours figuring that if you learn enough to write an interpreter, you're well on your way
22:29:47 <bros_> NeverDie: I'm not.
22:29:59 <bros_> julianleviston: i'm scrolling through it and it really looks a lot of the beginning of K&R without ever getting to anything serious
22:30:10 <bros_> and in serious, i don't mean in terms of complexity or understanding
22:30:14 <bros_> but actually doing anything really
22:30:16 <julianleviston> bros_: define serious?
22:30:20 <jle`> bros_: if you really do know the benefits and think it's worth learning, then you're going to have to invest in learning :)
22:30:23 <julianleviston> bros_: what is anything?
22:30:44 <peddie> bros_: the first chapter in that tutorial is writing a parser; I don't think there are many numbers
22:31:38 <bros_> julianleviston: i guess to me, again being biased to web applications, doing something is getting a lot of data from an API, filtering what you want, making some relations with it (object map or a unique reference), putting it in a database, having a nice queue to manage it all
22:31:45 <bros_> real world things
22:31:55 <julianleviston> bros_: that’s no good for someone who wants to control a robot
22:32:00 <julianleviston> bros_: that’s not real to them
22:32:20 <bros_> i'd argue most of the modern world we interact with daily is covered in that
22:32:33 <julianleviston> bros_: you have a biased view.
22:32:38 <bros_> if there was one resource you could give me
22:32:42 <julianleviston> bros_: but it’s one shared by most web app programmers.
22:32:51 <bros_> what can i do to snap out of it?
22:32:52 <julianleviston> bros_: go learn snap.
22:33:07 <julianleviston> bros_: you’ll have a hard time of it, though, because it’s not basic haskell...
22:33:19 <EvanR> real world = web junk :(
22:33:23 <bros_> yeah the whole yesod snap warp scotty decision is a lot to take in at first
22:33:25 <jle`> bros_: haskell can do a lot to help with that too, and makes that pretty nice too :)  except, you do have to do a bit of up-front learning to get to that point.  but, for a lot of people, learning how to do this wasn't the first thing they learned when they started programming either
22:33:25 <julianleviston> lol yeah :)
22:33:28 <bros_> what else is therebesides web junk?
22:33:38 <EvanR> nothing
22:33:39 <julianleviston> bros_: there is a LOT of stuff besides web junk
22:33:42 <EvanR> nothing to see here
22:33:46 <bros_> like what?
22:33:47 <julianleviston> ;-)
22:33:49 <bros_> i want to see how it compares
22:33:57 <julianleviston> it doesn’t. That’s the point.
22:34:04 <julianleviston> you can’t seem to get that.
22:34:06 <julianleviston> it’s different.
22:34:08 <bros_> i'm sure in some relative way it does.
22:34:09 <jle`> i do understand that if web is your main application, it doesn't make too much sense to be heavily invested in other specialities
22:34:09 <julianleviston> DIFFERENT
22:34:10 <bros_> give me an example
22:34:13 <peddie> bros_: my job is I write embedded control systems for satellites, so databases and dynamic memory aren't real, right?
22:34:14 <julianleviston> DIFFERENT
22:34:18 <jle`> i understand bros_'s point here
22:34:24 <julianleviston> jle`: me too
22:34:25 <EvanR> there was a time before time began... when people wrote programs for computers directly, they ran on something called an OS
22:34:28 <julianleviston> jle`: I *WAS* that guy.
22:34:37 <bros_> peddie: you move data to and from memory, right? read some pins, no?
22:34:51 <julianleviston> the problem is… to do web stuff will take AT LEAST 6 months of learning.
22:34:51 <bros_> peddie: wait on some interrupts?
22:34:52 <EvanR> browsers did not yet exist
22:35:04 <peddie> actually I use an awful lot of numbers
22:35:08 <bros_> julianleviston: yeah, that's a super steep curve
22:35:09 <julianleviston> bros_: if you’re not happy with 6 months of learning to do web stuff, then I suggest you don’t learn haskell.
22:35:10 <jle`> haskell can do a lot to help with web, but it is going to take a bit of up-front learning to be able to get to that point.  but that was the same for most people too.  nobody starts programming day 1 by learning how to make web apps.  they probably first learned what a text editor was...what a function is...
22:35:24 <julianleviston> bros_: meantime…. this might be helpful: http://www.genericoverlords.com/snap_notes
22:35:33 <julianleviston> bros_: this is my notes for beginning web programming
22:35:34 <EvanR> jle`: i think a lot of people are indeed learning programming that way
22:35:36 <bros_> instead of upfront learning, is there anything the community can do to better the language/onboarding process?
22:35:39 <julianleviston> bros_: because I was exactly like you… 
22:35:45 <EvanR> web apps on day 1
22:35:57 <julianleviston> that link will give you web apps on hour one.
22:35:59 <EvanR> start with a rails app and work your way back to "coding"
22:36:09 <julianleviston> lol
22:36:18 <EvanR> i.e more than a single line of rails configuration 
22:36:27 <julianleviston> bros_: check out the snap notes.
22:36:30 <bros_> EvanR: lol yes. people copy and paste until they get something
22:36:31 <julianleviston> bros_: see if that helps.
22:36:33 <bros_> julianleviston: I am. I like this a lot better.
22:36:39 <julianleviston> bros_: thought you might.
22:36:46 <bros_> probably should have sent this first lol
22:36:49 <julianleviston> bros_: it goes step by step… notice how FRIGGING COMPLICATED it is tho
22:36:54 <bros_> no
22:36:55 <bros_> not at all
22:36:56 <bros_> lmfao
22:36:59 <julianleviston> bros_: well I came from a similar perspective.
22:37:03 <bros_> not a number in site
22:37:05 <bros_> sight*
22:37:05 <julianleviston> You probably haven’t read enough yet.
22:37:24 <EvanR> its funny how little arithmetic is apparently involved in doing web apps
22:37:31 <bros_> i'm at the part where you pull in Lens
22:37:33 <EvanR> maybe new computers will be invented without it?
22:37:51 <julianleviston> yeah it’s all words
22:37:55 <EvanR> because arithmetic can be implemented on top of operations optimized for database and http
22:38:06 <rvxi> web apps day 1 done right is probably elm...
22:38:14 <bros_> so, microcontrollers and web apps
22:38:16 <bros_> anything else
22:38:23 <bros_> i'm thinking like, accounting
22:38:23 <julianleviston> rvxi: not so good for server-side database backed apps tho
22:38:30 <bros_> but that to me just soudns like moving money from one database/api to another
22:38:32 <jle`> i think arithmetic is just nice because it gives sort of "generic values/data" to work with, intead of say, pulling in a concept from a complex domain
22:38:33 <EvanR> na accounting is just database
22:38:52 <bros_> photoshop/CAD development is a lot of modeling
22:38:55 <jle`> so instead of teaching people about database connections just to tell people how to write functions and work with lists
22:38:56 <bros_> so, call that graphics
22:38:57 <jle`> we just use numbers intead
22:39:03 <julianleviston> bros_: also you might like this: http://snapforbeginners.com
22:39:05 <rvxi> julianleviston well come on how much stuff do you want to fit in on day 1 :)
22:39:13 <EvanR> graphics programming does involve extensive math
22:39:16 <bros_> julianleviston: any reason you perfer snap to the others?
22:39:19 <julianleviston> rvxi:  just telling you his perspective.
22:39:27 <julianleviston> bros_: no
22:39:28 <rvxi> i don't think webapps on day 1 is an unreasonable request though
22:39:37 <julianleviston> bros_: it’s a choice. My preference because I like flexibility.
22:39:44 <rvxi> just because we started with hello world console apps doesn't mean the next generation should
22:39:46 <bros_> EvanR: embedded systems, network/database (web), graphics, math for analytics/advertising
22:39:48 <julianleviston> bros_: yesod is more like rails… it decides a whole bunch of stuff for you.
22:39:58 <EvanR> bros_: throwing another of millions of topics out there... DSP
22:40:05 <julianleviston> bros_: and scotty is like sinatra - very barebones.
22:40:21 <bros_> EvanR: audio, ok. kind of in line with graphics in terms of "data in, visual/audio sensory out"
22:40:24 <bros_> EvanR: keep going
22:40:31 <EvanR> well audio is one application of DSP
22:40:32 <peddie> bros_: dsp is not audio
22:40:35 <bros_> julianleviston: nothing like MEAN with haskell?
22:40:42 <julianleviston> bros_: DSP can be used for audio tho.
22:40:45 <bros_> digital signal procesing, hmm...
22:40:49 <bros_> what else is it used for?
22:40:51 <solrize> @pl \xs -> xs == reverse xs
22:40:51 <lambdabot> ap (==) reverse
22:41:03 <julianleviston> bros_: haskell is used for everything.
22:41:09 <bros_> no, DSP
22:41:15 <bros_> i should make a haskell stack for noobs
22:41:23 <julianleviston> bros_: <sigh>
22:41:33 <julianleviston> bros_: yeah, no one’s been trying to do that for years, or anything.
22:41:34 <peddie> bros_: DSP?  satellite navigation and telemetry analysis
22:41:38 <EvanR> DSP, this is basically the foundation of all modern technology ;)
22:41:50 <solrize> @see ap
22:41:50 <lambdabot> Maybe you meant: src let leet free
22:41:57 <solrize> @src app
22:41:58 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:41:58 <bros_> you've got to give up the high horse of "you must suffer for 1 year before you can enjoy the pleasure of writing code that satisfies the senses"
22:42:00 <peddie> bros_: the gps in your phone, your point-and-shoot camera . . . 
22:42:04 <bros_> julianleviston: really? nobody made any progress?
22:42:18 <rvxi> btw. my little cousin (~7) wants to learn to make cool web browser games. would it be too ambitious to try to teach her elm?
22:42:26 <julianleviston> bros_: no one said you have to suffer for years.
22:42:28 <EvanR> bros_: graphics and audio programming, these are fun and cool, and web apps is almost the crappiest manifestation of this
22:42:31 <julianleviston> rvxi: no.
22:42:36 * peddie can't believe he got sucked into this . . . adios
22:43:26 <julianleviston> bros_: there are lots of things for beginners, but you just don’t like any of them.
22:47:33 <lpaste> JulianLeviston pasted “Problem code” at http://lpaste.net/146463
22:48:14 <julianleviston> jle`: this is my code I was talking about before - how do change the Maybe into an Either, but still keep the call to Model.getBlockData as an IO ByteString
22:48:26 <julianleviston> jle`: I dunno if you’re free to help,
22:49:25 <jle`> julianleviston: it looks like you have a bunch of chained case expressions, but most of your chaining happens in pure Maybe
22:49:29 <jle`> and doesn't involve IO
22:49:37 <julianleviston> that’s right.
22:49:37 <jle`> only one of the Maybe's is IO
22:49:42 <julianleviston> jle`: yep.
22:49:54 <jle`> so, one thing you can do immediately to make it easier is to just write the value in your let block using do notation with Maybe/Either
22:50:06 <jle`> and then you just have one case expression, basically
22:50:12 <julianleviston> jle`: but I want to convert it to eithers (to get a message for errors) and only have the IO Maybe ByteString execute if the first Either works.
22:50:25 <jle`> yeah, you'd be case matching on maybeData
22:50:34 <jle`> EitherT might not be worth it if you're just using it to eliminate a single case statement
22:50:36 <julianleviston> except it’s in IO… so how do I make that action run?
22:50:57 <julianleviston> jle`: one sec I’ll pastie where I’ve got to in refactor
22:51:02 <jle`> oh wait i see
22:51:11 <jle`> you have one 'chained IO Maybe'
22:51:17 <lpaste> JulianLeviston revised “Problem code”: “No title” at http://lpaste.net/146463
22:51:39 <julianleviston> jle`: the rest are not in IO… do I just liftIO that?
22:52:04 <EvanR> no because liftIO takes something that does IO
22:52:22 <julianleviston> EvanR:  which it does.
22:52:23 <EvanR> use let for values that arent "in the monad"
22:52:29 <EvanR> you said its not in IO
22:52:37 <EvanR> so i hope it doesnt do IO ;)
22:52:43 <julianleviston> EvanR: getBlockData is in IO
22:52:55 <julianleviston> EvanR: its type is IO (Maybe ByteString)
22:52:57 <EvanR> so liftIO would do nothing
22:52:58 <julianleviston> I think.
22:53:00 <julianleviston> oh.
22:53:24 <julianleviston> EvanR: the rest of the code is in Either ByteString ByteString…
22:53:28 <jle`> btw shame on you for shadowing `id` :P
22:53:43 <julianleviston> jle`: lol. what’s wrong with shadowing?
22:53:49 <julianleviston> jle`: easier than typing identifier
22:53:52 <jle`> jk :)
22:53:54 <julianleviston> but sure.
22:54:01 <jle`> people expect 'id' to mean 'id' the function
22:54:02 <EvanR> id might be confusing shadowed, in haskell
22:54:05 <julianleviston> I know.
22:54:11 <julianleviston> ok ok I’ll change it
22:54:14 <glguy> Anyone reading your code expects 'id' to be the one from Prelude including you next time you read it
22:54:24 <julianleviston> ok already! :) lol
22:54:29 <jle`> but yeah it's not actually a big relevant deal to this, i was just joking heh
22:54:41 <EvanR> myIDNotIDFromPrelude___Int
22:54:51 <jle`> julianleviston: what is the type of Model.getBlockData dataId dataName ?
22:55:16 <julianleviston> jle`: getBlockCode :: Int -> Handler GetContented GetContented T.Text
22:55:26 <EvanR> julianleviston: ok... so you were asking how to do the IO inside of a do block in the Either monad... you cant
22:55:33 <julianleviston> EvanR: shit
22:55:51 <julianleviston> EvanR: can’t I raise the whole thing up to be IO (Either ByteString ByteString) ?
22:56:12 <julianleviston> then use liftIO on the Either parts?
22:56:26 <julianleviston> or rather… lift them somehow into IO? god I hate the word lift.
22:56:33 <EvanR> yes you have to change the type of the whole thing to IO or something involving IO to do IO
22:56:40 <julianleviston> yeah I’m happy to do that.
22:56:42 <EvanR> no you dont lift anything since the stuff doesnt do IO
22:56:49 <julianleviston> right.
22:57:10 <julianleviston> the whole thing is in IO anyway as it stands, right?
22:57:30 <EvanR> i didnt read the code yet
22:57:49 <julianleviston> jle`: sorry: getBlockData :: Integer -> String -> IO (Maybe ByteString)
22:58:37 <jle`> yeah i guess there might be enough case matching that it would be convenient to use EitherT
22:58:38 <julianleviston> basically the whole thing is in IO ByteString, and I want to use an Either monad to catch errors… in the middle is some code that uses IO, but the rest of that Either monad doesn't.
22:58:43 <jle`> after trying it over again
22:58:54 <EvanR> julianleviston: heres the idiomatic way... its all in IO, then you case on the IO (Maybe ByteString), on Nothing throw an IO exception
22:59:07 <julianleviston> I don’t want Maybe tho. I want Either.
22:59:18 <EvanR> well you case on the result of IO (Maybe ByteString)
22:59:20 <julianleviston> because I want the ByteString
22:59:30 <EvanR> you want Either for exception purposes, in IO
22:59:32 <julianleviston> which I’m doing, right?
22:59:33 <bitemyapp> @ty try
22:59:34 <EvanR> so use exceptions either
22:59:35 <lambdabot> Exception e => IO a -> IO (Either e a)
22:59:37 <bitemyapp> julianleviston: ^^
22:59:37 <EvanR> instead*
22:59:45 <bitemyapp> julianleviston: pick an exception, it becomes the Left.
23:00:00 <bitemyapp> bingo bango bongo, you got your either, but you'll never erase the IO.
23:00:04 <julianleviston> but I don’t want an exception do I?
23:00:09 <julianleviston> I don’t want to erase the IO
23:00:13 <EvanR> it sounds like youre trying to do exceptions
23:00:20 <julianleviston> does it?
23:00:23 <bitemyapp> julianleviston: I'm telling you how to do what you want to do.
23:00:33 <julianleviston> bitemyapp: sorry, I can’t see that you are.
23:00:38 <bitemyapp> julianleviston: if the error is "in IO" and it's not a bottom, it's an IOException and you can catch it using what I showed you.
23:00:42 <julianleviston> bitemyapp: I might need further explanation.
23:00:43 <EvanR> yes youre trying to write a big compound IO action which might fail
23:01:05 <jle`> yeah, you can do it using Either manually, but IO exceptions were sort of invented to solve this very problem :)
23:01:07 <julianleviston> EvanR:  no… it won’t fail… either way it returns an IO ByteString
23:01:15 <julianleviston> oh really?
23:01:36 <julianleviston> I’m a bit confused as to how it’s an IO exception tho… it’s not about whether the IO action works or doesn’t. 
23:01:40 <EvanR> julianleviston: er... the ByteString is the left or the right ByteString??
23:01:46 <julianleviston> both
23:01:50 <EvanR> Either a a -> a ?
23:01:58 <julianleviston> in fact, the IO action is the only part that DEFINITELY cannot fail.
23:01:59 <jle`> julianleviston: so your getBlockData isn't something that can fail
23:02:01 <EvanR> why does this make me feel weird
23:02:05 <bitemyapp> julianleviston: okay, what you're describing is a bit weird.
23:02:06 <jle`> it just happens to return a Just or Nothing?
23:02:13 <julianleviston> jle`: it can return Nothing, but then I catch it to “"
23:02:18 <julianleviston> jle`: yes.
23:02:19 <EvanR> gross
23:02:21 <bitemyapp> julianleviston: so you just want to fold the Maybe?
23:02:22 <EvanR> use exceptions
23:02:27 <julianleviston> bitemyapp: fold?
23:02:28 <jle`> is 'nothing' supposed to be a failure?
23:02:37 <julianleviston> jle`: which nothing?
23:02:39 <bitemyapp> Nothing
23:02:41 <EvanR> youre about to invent PHP's "white screen effect"
23:02:45 <bitemyapp> the one that gets converted to ""
23:02:47 <julianleviston> no i’m not
23:02:53 <julianleviston> EvanR:  you haven’t understood my context.
23:02:54 <bitemyapp> okay
23:02:57 <bitemyapp> lets slow this roll
23:03:01 <bitemyapp> julianleviston: can you voice chat real quick?
23:03:05 <julianleviston> sure
23:03:09 <bitemyapp> julianleviston: have Skype?
23:03:12 <julianleviston> yeah
23:03:18 <bitemyapp> julianleviston: I will query you my Skype
23:05:56 <lpaste> jle` annotated “Problem code” with “Problem code (annotation)” at http://lpaste.net/146463#a146465
23:06:01 <jle`> julianleviston: updated it to use MaybeT
23:06:09 <jle`> if you wanted to see how MaybeT would work
23:06:26 <jle`> adding EitherT would just mean that each line also has an associated error, too
23:06:39 <jle`> but yeah, I think that IO exceptions might be a much more idiomatic approach to sorting through this whole thing
23:08:06 <lpaste> jle` revised “Problem code (annotation)”: “No title” at http://lpaste.net/146465
23:28:15 * TUMuch slaps lambdahands around a bit with a large fishbot
23:40:01 * hackagebot formura 1.0 - Formura is a simple language to describe stencil computation.  https://hackage.haskell.org/package/formura-1.0 (TakayukiMuranushi)
23:40:17 <Lovey> wow . hello
23:44:00 <liste> > wow . hello $"Lovey!"
23:44:01 <lambdabot>  "wow hello Lovey!"
23:44:24 <Lovey> :)
23:45:02 <Lovey> it's been 13 years
23:57:03 <gamegoblin> is there a more convenient way of saying [minBound..maxBound]
23:59:33 <magneticduck> gamegoblin: are you.. typing that a lot?
23:59:56 <gamegoblin> magneticduck: not particularly. Basically I find myself wanting to get a list of all values of an enum
