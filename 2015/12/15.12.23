00:01:57 <kadoban> Heather: Try cabal clean and then cabal install again maybe? But if that doesn't work, that's about the point I'd nuke my cabal sandbox (and then the user package database if that didn't work) and try again. But I've since moved to 'stack' where that kind of thing doesn't tend to be necessary.
00:04:02 <quchen> pdxleif: Yesod is for websites, Servant is for webservices.
00:04:34 <quchen> You don't want to code your microservice with Yesod, and you don't want to do session management with Servant.
00:05:12 <quchen> You can use both to do the thing they're not meant to of course, so if you really feel like it, you can write a Servant-based website.
00:06:21 <Heather> kadoban doesn't help, trying with stack but it's using some own lfs setup for some reason :S
00:07:05 <Heather> kadoban there is little problem with sandboxes - I don't need library inside sandbox :)
00:07:30 <kadoban> Heather: Using cabal without sandboxes is … just never going to be nice. You're setting yourself up for pain and failure.
00:07:39 * hackagebot machinecell 3.0.1 - Arrow based stream transducers  https://hackage.haskell.org/package/machinecell-3.0.1 (HidenoriAzuma)
00:07:39 * hackagebot yes-precure5-command 5.5.2 - Extended yes command to reproduce phrases in Yes! Precure 5.  https://hackage.haskell.org/package/yes-precure5-command-5.5.2 (igrep)
00:08:00 <kadoban> Heather: stack does that stuff internally so you don't have to deal with it. You'll probably want to read a bit of the beginners guide for stack to get started though.
00:08:07 <Heather> kadoban however all my libraries are tend to interact with each other :/
00:09:09 <Heather> kadoban it's still being not valid when people argue about sandboxes
00:09:30 <kadoban> Heather: I don't particularly understand what you're talking about.
00:10:06 <Heather> kadoban I don't want sandboxes
00:10:08 <roelof> next problem :   Not in scope: type constructor or class ‘Arbitrary’ 
00:10:24 <kadoban> Heather: Okay … well then I guess you're in for some pain *shrug*
00:10:49 <Heather> kadoban semihow yes
00:15:13 <nocturne777> what would you recommend to generate unique session ids? Currently I am using Data.UUID.V4
00:16:04 <hexagoxel> Heather: but you still can use sandboxes with local packages; using add-source stuff. certainly a bit annoying to set up, but possible (and semi-automatable)
00:16:31 <kadoban> roelof: That's from QuickCheck
00:17:07 <roelof> kadoban:  thanks
00:19:16 <hexagoxel> Heather: (and i cannot even find this error message in cabal's source; but then i am looking at HEAD and not at whatever version you are using, and cabal is changing a lot lately.)
00:21:03 <Heather> hexagoxel, I think I've used most recent cabal...
00:25:56 <wedens> how would you test logic heavily interleaved with IO. for example: read a from DB, depending on a read b or c from db, process b or c and insert some data to db, and so on
00:25:59 <hexagoxel> ah, the output might come from ghc-pkg.
00:27:07 <Ralith> wedens: abstract the actual IO out?
00:27:18 <wedens> I've tried using mtl and passing functions, but in result I have like 10 functions in parameters
00:27:37 <wedens> Ralith: well, "abstract IO" is too abstract.
00:28:05 <hexagoxel> Heather: is `ghc-pkg check` clear?
00:29:16 <wedens> also I've tried using free monad for all IO functions called from my function. but with this approach I have one free algebra + 2 intepreters for each function
00:44:24 <jle`> hmatrix does this weird thing where every once in a while the result of an operation will be NaN
00:44:32 <jle`> apparently the docs mention that this is possible
00:44:38 <jle`> oh well
00:45:47 <kadoban> Just randomly? That sounds unfriendly.
00:47:31 <jle`> oh it's in the docs for 0.4 http://hackage.haskell.org/package/hmatrix-0.4.0.0/readme but isn't there anymore for 1.17 like i'm using
00:48:07 <jle`> yeah it's apparently randomly
00:48:21 <jle`> right now i check it every few iterations and if it's NaN then i restart it and it works fine
00:48:32 <jle`> i just reset my state to a previous one after checking every few seconds
00:49:10 <jle`> my procedure isn't deterministic though but i don't see how something could happen, i'm not doing any divisions
00:49:12 <jle`> just multiplications
00:49:42 <jle`> and additions
00:49:43 <fr33domlover> Seeking advice on fmap for pairs/tuples - when I want to apply a function to a pair's second item I hesitate to use fmap because it feels that the definition is random, and doesn't mean explicity "apply to 2nd item", so if e.g. one day I switch places between the items i'll want apply-to-first instead. However when I hesitate and write my own applyToSnd instead, then I end up never using fmap on pairs :P
00:50:03 <fr33domlover> should I be ok with using fmap whenever for any reason i need to apply-to-snd?
00:50:06 <fr33domlover> :P
00:50:35 <jle`> yeah, fmap on applying to snd is normal
00:50:38 <jle`> it's actually not random
00:50:45 <jle`> it really does explicitly mean apply to second item
00:50:54 <jle`> in the context of its Functor, Applicative, and Monad, and Traversable, and Foldable instances
00:50:58 <fr33domlover> jle`, i mean it seems to be like that because of the definition being easier/possible
00:51:02 <fr33domlover> and not something semantic
00:51:03 <Guest00000> what does Hoogle search? whole Hackage?
00:51:15 <jle`> it actually does have semantics
00:51:26 <jle`> `(,) t a` is treated as an a "tagged" with a value t
00:51:45 <jle`> so fmap :: (a -> b) -> ((,)t) a -> ((,)t) b
00:51:52 <jle`> it just mapps over the tagged value, leaving the tag unchanged
00:51:57 <fr33domlover> jle`, oh i see. well, in my case it isn't a tagged value :P
00:52:27 <jle`> yeah, in a sense it's weird to use it when you're not using the semantics of tagged value...kind of like using pure instead of (:[])
00:53:02 <jle`> i'd always use (:[]) over `pure` or `return` unless the semantics are Applicative/Monadic...and Nothing over `empty` unless i'm being Alternatively/Applicativey
00:53:15 <jle`> so i see the point in using only semantically meaningful things according to how you're treating your data
00:53:31 <jle`> use Right over return unless you're thinking monadically/Applicatively, etc.
00:53:38 <jle`> but, fmap on tuples is kind of ubiquitious
00:54:05 <Guest00000> what do you do when you want to map on second?
00:54:05 <jle`> but, if you regularly map over both the fst and the snd field, then maybe it's best to use `first` and `second` from Data.Bifunctor
00:54:07 <Guest00000> uhh
00:54:08 <Guest00000> first
00:54:19 <jle`> that way, the contrast is sort of explicit in your code
00:54:41 <jle`> if i'm mapping things over fst and snd often and the fact that it's one or the other is important and i want to show contrast i'd probably use first/second over first/fmap
00:55:10 <jle`> i guess i've sort of convinced myself to not use fmap too often over tuples unless i'm treating it like tagged data
00:55:20 <jle`> this has been a great journey of self discovery and i appreciate you all for accompanying me
00:56:42 <Guest00000> bimap... (***)...
00:56:49 <Guest00000> they could work together...
00:57:05 <jle`> Control.Arrow combinators have always been a bit weird for normal tuple manipulation
00:57:15 <jle`> but yeah, bimap is a nice counterpart to this too
01:00:02 <jle`> fr33domlover: i just noticed that your question carried an implication that you weren't aware of the `second` function from Data.Bifunctor ; does this combinator fit your purposes?
01:02:50 <Guest00000> :t (***)
01:02:52 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
01:03:01 <Mik3> Hi guys :D I have a Christmas problem!
01:03:43 <Guest00000> i want (***) :: (Arrow a, Bifunctor p) => a b c -> a b' c' -> a (p b b') (p c c')
01:04:00 <jle`> Guest00000: do you relaly? :P
01:04:30 <jle`> it'd be pretty bad for type inference...and, i can't imagine how most Arrow instances would implement a polymorphic one
01:05:07 <Guest00000> or maybe (ArrowBifunctor a p) => ..., or whatever
01:05:33 <jle`> also decently bad for type inference, heh.  and i don't think you'd have too many meaningful laws
01:05:47 <Guest00000> but it's just fun.
01:05:50 <jle`> not to bash on your idea
01:05:52 <Mik3> How can this piece of code work? http://lpaste.net/147703 I mean, how can the inner map work without a list as a parameter?
01:05:55 <jle`> yes it'd be fun :p
01:06:05 <Mik3> I have problems with nested maps :)
01:06:17 <jle`> map f :: [a] -> [b]
01:06:23 <jle`> so it doesn't really need a "list parameter"
01:06:31 <jle`> applying it with just an f gives you an [a] -> [b], a list transformer
01:06:53 <jle`> it might help to add some points to your inner function
01:07:07 <jle`> (\i -> map f (make n (int2bin i))
01:07:08 <jle`> )
01:17:46 <Mik3> Oh, thanks a lot Jle :)
01:18:27 <jle`> np!
01:32:08 <Guest00000> :k Kleisli
01:32:10 <lambdabot> (* -> *) -> * -> * -> *
01:32:19 <Guest00000> :i Kleisli
01:32:37 <Guest00000> ...
01:32:45 <jle`> lambdabot has no :i
01:32:58 <Guest00000> too bad'
01:33:20 <jle`> what kind of stuff would you expect :i to do? :p
01:34:36 <Guest00000> jle`: like in ghci idk... (i'm lazy to alt-tab to ghci lol)
01:34:47 <Guest00000> true laziness
01:36:38 <jle`> sounds like it'd be pretty spammy, heh... :i outputs are usually dozens of lines long
01:37:34 <Guest00000> jle`: those lines are instances
01:37:48 <Guest00000> it'd be fine with just a definition
01:39:17 <jle`> yeah, sounds like it'd be pretty different than :i from ghci then :3
01:41:11 <Guest00000> so (f *** g) for Kleisli is just 'executing' f on first component, and THEN g on second?
01:41:30 <Guest00000> it should be noted somewhere, i wasn't sure until i read source
01:43:28 <RaceCondition> anyone found a way to make ghc-show-type show the full type incl. constraints?
01:45:09 <Guest00000> is it possible to search whole Hackage for function name?
01:45:24 <mauke> @where hayoo
01:45:24 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
01:46:18 <ben> why does hayoo advertise hoogle?
01:46:27 <jle`> Guest00000: yeah, it executes f, then g, and then tuples up the results
01:46:43 <jle`> which could potentially be unexpected behavior for noncommutative monads
01:47:20 <Guest00000> hayoo, cool.
01:47:34 <Guest00000> hayoo is strictly better than hoogle then?
01:47:46 <jle`> hayoo can't do type searches
01:48:08 <Guest00000> by signature? it can
01:48:24 <jle`> oh, huh
01:48:30 <jle`> nvm then ><
01:50:46 <Guest00000> when was <*> added to Prelude?
01:51:37 <jle`> with AMP i believe
01:52:26 <Guest00000> is it true that Haskell / GHC moves towards adding all combinators to Prelude? (for me that would be highly desirable)
01:52:44 <Guest00000> all combinators in standard libraries
01:52:50 <RaceCondition> "In constrast to Hoogle, all available packages are indexed, but the signature search is not as advanced." — always felt it was the other way around...
01:53:55 <RaceCondition> Guest00000, I think there is some debate as to what it makes sense to add and what not
01:54:16 <Guest00000> add everything!..
01:54:21 <RaceCondition> Guest00000, there's the question of balance between learnability and power use
01:54:30 <RaceCondition> map is easier to learn than fmap/<$>
01:54:30 <fr33domlover> jle`, indeed i wasn't aware of 'second'
01:54:46 <fr33domlover> actually I don't remember using the Bifunctor module, i'll take a look
01:55:26 <Guest00000> fr33domlover: check out Control.Arrow also
01:57:34 <ben> What's so great about putting more things into the Prelude over shipping a Prelude2 module that just imports all the interesting things for power users?
02:00:44 <Guest00000> RaceCondition: can we just ignore a part of Prelude?
02:01:42 <fr33domlover> Guest00000, thanks. tbh i haven't read about arrows yet
02:02:03 <fr33domlover> bifunctor seems like a quick solution (but from base 4.8)
02:02:03 <Guest00000> fr33domlover: they are awesome
02:04:11 <RaceCondition> Guest00000, you mean import Prelude hiding (stuff)?
02:05:06 <Guest00000> i mean ignore that part when learning
02:05:21 <Guest00000> does adding a part impair learning of the other part?
02:05:23 <RaceCondition> Guest00000, how would newcomers know what to ignore?
02:05:51 <RaceCondition> actually fmap already is in the Prelude
02:06:12 <RaceCondition> but I think there's some stuff that would conflict, such as Arrow/Category composition with function composition
02:07:25 <Guest00000> RaceCondition: everything else? 
02:08:03 <Guest00000> do they decide what to learn about by looking at prelude and picking a thing?
02:08:56 <RaceCondition> Guest00000, I don't know; you can find some relevant discussions on the mailing list
02:24:37 <draziw> Hello, is there a stack guru around? I have an strange issue where Setup.hs is not run when multiple packages are provided stack.yaml. I can't find any documentation on this.
02:54:40 <kras> :t readFile
02:54:41 <lambdabot> FilePath -> IO String
02:55:12 <kras> how do I get the String from (readFile afile)
02:55:40 <jle`> kras: you can bind it in a do block, like res <- readFile afile
02:55:51 <jle`> then you can refer to it as `res` for the rest of the do block
02:55:53 <kras> how about (scanl incrDecr 0) <$> (readFile "input.txt")
02:56:14 <kras> jle`: thanks, I am trying to avoid do 
02:56:22 <jle`> yeah, that'll apply `scanl increDecr 0` to the result
02:56:37 <jle`> :t scanl (+) 0 <$> readFile "input.txt"
02:56:38 <lambdabot>     No instance for (Num Char) arising from a use of ‘+’
02:56:39 <lambdabot>     In the first argument of ‘scanl’, namely ‘(+)’
02:56:39 <lambdabot>     In the first argument of ‘(<$>)’, namely ‘scanl (+) 0’
02:56:41 <jle`> oops
02:57:11 <jle`> but yeah, `f <$> m` will take an IO action (m) and return a new IO action that executes the same thing, but the result is f applied to the result
02:57:28 <jle`> so, if `readFile "file" :: IO String` is an IO action that reads the file and returns a string
02:57:31 <kras> jle`: thanks man
02:57:40 <jle`> `length <$> readFile "file" :: IO Int` is an IO action that reads the file, and returns the length
02:57:50 <jle`> same effects, but modified value
03:18:45 <roelof> Can I use Quicktest to test this function :  http://lpaste.net/147706   or is just a Hunit test enough ? 
03:23:22 <pavonia> roelof: Are you aware that there already are min and max functions?
03:23:35 <zoku> i'm struggling to convert these aeson values into types I can use
03:23:43 <zoku> this result contains strings
03:23:49 <zoku> but I can't convert them into strings
03:23:59 <zoku> :t srcs
03:24:00 <zoku> srcs :: [Maybe Value]
03:24:01 <lambdabot> Not in scope: ‘srcs’
03:24:24 <roelof> pavonia:  I only know max or min functions for list not for integers 
03:24:50 <pavonia> :t max
03:24:52 <lambdabot> Ord a => a -> a -> a
03:24:59 <pavonia> :t maximum
03:25:01 <lambdabot> (Ord a, Foldable t) => t a -> a
03:25:11 <mauke`> > max 4 9
03:25:13 <lambdabot>  9
03:25:18 <fr33domlover> style question: If a type is both Functor and Monad, should fmap or liftM be preferred? I have been using liftM a lot with IO but it seems some people prefer fmap
03:25:34 <jle`> fmap is in general preferred
03:25:42 <jle`> i don't think there's a situation now where one would use liftM over fmap
03:25:49 <frerich> fr33domlover: I always used 'fmap' but mostly because lift* always makes me nervous.
03:25:50 <jle`> same for ap vs <*>
03:25:54 <pavonia> fr33domlover: I prefer (<$>) when possible
03:26:07 <mauke`> if there's a difference, fmap is probably more efficient
03:26:10 <roelof> oke, that could make my code much simpler  
03:26:37 <jle`> true, too; although in the degenerate case of IO, fmap and liftM are the same
03:26:45 <roelof> but my question still stands  Can I test this with quick test 
03:26:51 <jle`> but in general using fmap conveys the idea better, i think
03:27:18 <jle`> and there isn't any extra semantic meaning you convey when you use liftM over fmap...
03:27:31 <mauke`> roelof: sure, if you can define some properties
03:27:37 <fr33domlover> jle`, IO seems to me like action more than structure
03:27:45 <fr33domlover> that's why liftM seems to make sense
03:27:48 <jle`> fmap makes sense for actions, too
03:27:56 <fr33domlover> while I use 'fmap' with Maybe and not liftM
03:27:57 <jle`> fmap makes more sense for actions than liftM would
03:28:25 <roelof> mauke`:  oke, then I have to think today about the properties to test 
03:28:30 <frerich> roelof: You would need to establish some properties. It seems that '(snd (maxOccurs a b) == 1) == (a /= b)' should hold?
03:28:40 <fr33domlover> jle`, hmmm so should we let liftM die now, since Functor => Applicative => Monad ?
03:28:54 <jle`> it still has a limited use case
03:29:11 <jle`> if you've defined a Monad instance for your type, but are too lazy to define the Functor instance
03:29:14 <roelof> frerich:  oke, that way. I still find writing properties difficult 
03:29:18 <jle`> you can write instance Functor Foo where fmap = liftM
03:29:30 <Heather> how to repair broken packages on windows?
03:29:37 <roelof> Thanks all , I will try to test this with Hunit and with QuickTest 
03:29:39 <jle`> but that's the only situation that justifies liftM's continued existence, to me
03:29:42 <jle`> heh
03:30:15 <mauke`> roelof: \x y -> fst (maxOccurs x y) == max x y
03:30:20 <mauke`> pretty sure your function breaks that
03:30:50 <fr33domlover> jle`, you can't have that anymore, Functor => Applicative => Monad since base 4.8 iirc
03:30:56 <fr33domlover> so even that case is dying
03:30:57 <jle`> you can have that
03:31:11 <jle`> you can write a Monad instance only, and then define the Functor and Applicative instance in terms of your Monad instance
03:31:26 <jle`> instance Functor Foo where fmap = liftM; instance Applicative Foo where pure = return; (<*>) = ap
03:31:31 <fr33domlover> jle`, oh i see now
03:31:33 <jle`> it's only for the especially lazy, heh
03:32:09 <roelof> mauke`:  Im sure this one will fails on  maxOccurs  1 2  
03:32:14 <jle`> and i think you'd probably only use it in the short-term where you're like, "i want to test how this works as a Monad.  but crap, i have to also make it an instance of Functor and Applicative but I don't want to write out those instances.  i'll just use (<*>) = ap"
03:32:29 <jle`> "...for now, i promise"
03:32:41 <pavonia> > let maxOccurs x y = (max x y, if x == y then 2 else 1) in zipWith maxOccurs [10, 20, 10] [10, 10, 20]
03:32:43 <lambdabot>  [(10,2),(20,1),(20,1)]
03:32:48 <roelof> but the meaning of this is to count how much the largest number is mentioned 
03:33:38 <fr33domlover> jle`, thanks. does anyone else have a different opinion? prefering liftM etc.?
03:34:02 <roelof> pavonia:  this  one is not good, MaxOccurs is Integer -> Integer and [ 10, 20, 10] is not a integer 
03:34:49 <pavonia> roelof: It is, note the use of zipWith
03:34:54 <jle`> you can ask on the reddit and stack overflow too, if you want a wider survey than the middle of the (US) night, heh; but i'm pretty sure most people will do a double-take if they see liftM used in real code
03:35:04 <mauke`> roelof: no, maxOccurs is Integer -> (Integer -> (Integer, Integer))
03:35:11 <pavonia> :t let maxOccurs x y = (max x y, if x == y then 2 else 1) in maxOccurs
03:35:12 <lambdabot> (Num t, Ord a) => a -> a -> (a, t)
03:35:17 <roelof> mauke`:  you are right 
03:35:32 <fr33domlover> jle`, actually i use liftM because the Haskell Wikibook introduces it that way
03:35:39 <jle`> i've read a lot of haskell code from a lot of libraries, done a lot of contributions to various libs, but i've never seen anyone use liftM over fmap when fmap is possible
03:35:56 <fr33domlover> maybe it's a bad habit indeed and i should use fmap from now on
03:35:58 <jle`> ah, that's interesting :3
03:36:05 <roelof> pavonia:  oke, I did some chapters of the Craft book and zipwidth is at this moment not explained 
03:36:13 <jle`> in the end it's a stylistic thing, though; i wouldn't say it's a harmful habit
03:36:21 <quicksilver> before the hierarchy was reworked, i used to use liftM to avoid a messy-looking Functor constraint when there was already a Monad constrating
03:36:29 <quicksilver> but that's not an issue any more
03:36:35 <mauke`> roelof: is zip explained?
03:36:40 <jle`> but yeah, be aware that liftM will be less performant than fmap in several situations
03:37:17 <pavonia> roelof: Ignore it, I just used it to check the function for serveral inputs
03:37:18 <jle`> i guess that's the only truly objectively "bad" thing about it
03:37:25 <jle`> but for the most part i'd consider it a stylistic choice
03:37:29 <roelof> nope, only recursion, tuples, and a little bit QuickCheck and Hunit 
03:37:54 <roelof> later on this chapter Lists are explained 
03:38:09 <fr33domlover> hmmm so if I assume Functor => Monad, my code won't work with base 4.7?
03:38:25 <jle`> most of it will work
03:38:36 <jle`> the only time it won't work is if you wanted to write functions polymorphic over all Monads
03:38:40 <jle`> which is fairly rare
03:38:46 <fr33domlover> jle`, yeah just wanted to say that :P
03:38:53 <fr33domlover> mostly i use liftM with IO specifically
03:38:59 <fr33domlover> so everything should work anyway :D
03:39:17 <roelof> Time for dinner and some more work on testing 
03:39:18 <jle`> if you wanted to write Monad m => blah blah blah, then you can't use fmap.  but writing code generic over all monads is a pretty rare thing as far as things go
03:39:26 <roelof> Again thanks
03:39:27 <jle`> at least at the application side
03:39:38 <RaceCondition> can I tell stack to build/store dependencies somewhere other than .stack-work? somewhere that is shared with other stack projects
03:40:11 <jle`> it's a bit more common for library developers
03:40:29 <SX> Hi! Do anyone know how to simply make relative path (~/abc/def) into absolute path (/home/me/abc/def) withShelly?
03:40:38 <fr33domlover> jle`, thanks or all the advice :)
03:40:41 <fr33domlover> i learned a lot
03:40:46 <quicksilver> that is not what is called a relative path, SX
03:41:07 <jle`> np! hope i'm not just drowning out all the other noise though, i'm just always on #haskell procrastinating v.v
03:41:08 <quicksilver> a relative path would be (abc/def)
03:41:20 <SX> oh, yeah, it's true, not relative
03:42:37 <SX> My bad. But still I need to expand this into full path..
03:43:16 <pavonia> I thin System.Directoy has a function for this
03:43:18 <frerich> SX: If '~' is only supported at the beginning of the path (which I always assumed to be the case) then you could just see whether the path starts with it and if so, replace it with the home dir.
03:43:20 <pavonia> *think
03:44:34 <SX> frerich: So there's no function in shelly or system-filepath to do that?
03:44:56 <frerich> SX: I don't know, I'd hope there is and look for it. :-}
03:47:52 <mgsloan> RaceCondition: Snapshot dependencies are already shared between stack projects.  In other words, if you use the same resolver, you'll share dependencies
03:48:24 <RaceCondition> mgsloan, well all of my deps are re-built upon rm -rf .stack-work
03:48:38 <mgsloan> If the exact package and transitive dependencies are already in some snapshot, then they'll be added to the current snapshot's DB.
03:48:46 <mgsloan> Hrmm
03:49:07 <RaceCondition> so they definitely aren't built in a shared location
03:49:08 <mgsloan> Yes "extra-deps" are currently stored in .stack-work and will need to be rebuilt
03:49:33 <RaceCondition> ok.. what I meant to ask is if there's a way to build them in a shared way
03:49:45 <RaceCondition> like what Nix does I guess
03:49:47 <mgsloan> Yes, you can use custom snapshots
03:50:24 <RaceCondition> so basically I'd need a way to convert a stack.yaml to a custom snapshot
03:50:29 <mgsloan> Buut, custom snapshots aren't really all that polished right now...  I haven't actually used them.  But there are a number of folks who do use them this way
03:50:49 <RaceCondition> aren't there not an awful lot of people who are dreaming of what I'm dreaming though?
03:51:11 <mgsloan> Yes, there is an imminent plan to unify extra-deps and snaphots, and add "extensible snapshots"
03:51:44 <mgsloan> I'd hoped to have done it by now, buut other things have taken priority.  Should happen within the next 2 weeks / 1 month
03:51:46 <RaceCondition> oh that's awesome; do you have the GH issue nr?
03:52:18 <mgsloan> https://github.com/commercialhaskell/stack/issues/1265
03:52:37 <RaceCondition> thanks
03:53:04 <RaceCondition> just wondering: Nix already has that logic; couldn't stack reuse that?
03:53:49 <RaceCondition> I mean, logic for fetching and building in a shared location
03:55:12 <quicksilver> some people just use nix, I think?
03:55:25 <quicksilver> and cabal has stolen^Wdeveloped some design ideas from nix for its next release
03:55:40 <mgsloan> RaceCondition: Yes, yes it could: http://docs.haskellstack.org/en/stable/nix_integration.html
03:56:03 <mgsloan> Stack has direct nix support due to Yuval Pares
03:56:13 <mgsloan> 's efforts
03:57:11 <RaceCondition> but then it switches to a completely different mode of operation.. isn't that different from using Nix for building Haskell dependencies that aren't in nixpkgs?
03:57:42 <quchen> mgsloan: Is there a way to tell Stack that if a package isn't in Stackage, use "that" version? For example, I need to specify that 'bifunctors' needs to be built with GHC < 7.10 only in the multi-version Travis script.
03:57:42 * hackagebot htaglib 1.0.0 - Bindings to TagLib, audio meta-data library  https://hackage.haskell.org/package/htaglib-1.0.0 (mrkkrp)
03:58:08 <quchen> I could put bifunctors into the extra deps, but then the resolver will always use that version, no?
03:58:11 <RaceCondition> actually, let's say I use stack in nix mode — will it *then* use Nix for building Haskell deps in a shared location? or still only non-haskell deps?
03:58:34 <mgsloan> Well, you use stack to build your packages, and you use nix to manage the rest of the environment.  Each tool does what it's good at!
03:59:19 <mgsloan> Stack does build deps in a shared location.  We've had that aspect of nix-ey-ness for quite a while
03:59:59 <RaceCondition> mgsloan, I'm lost again... if it does build in a shared loc, how come rm -rf .stack-work causes them to be rebuilt?
04:00:29 <mgsloan> Are they in your "extra-deps" list?  If so, then they are local to your project
04:01:03 <mgsloan> There are plans to make them non-local to your project
04:01:42 <RaceCondition> yeah... that's what I meant: could Nix help with that... just delegate some aspects of building non-local deps to Nix
04:01:43 <mgsloan> quchen: That's exactly the usecase of extra-deps.
04:01:50 <RaceCondition> just basically asking out of curiosity
04:02:57 <quchen> mgsloan: Oh, interesting. I thought it was a hard overwrite.
04:03:02 <mgsloan> Nooooo
04:03:05 <mgsloan> That would be terrible
04:03:06 <mgsloan> :)
04:03:44 <mgsloan> You must be used to your build tools doing silly things
04:03:47 <mgsloan> ;)
04:04:15 <quchen> Not really. Suppose I want to use a specific version of a package to build my project, and Stackage has an older version. What now?
04:04:26 <RaceCondition> basically I mean if tools like cabal "steal" ideas from Nix, couldn't they *delegate* instead of stealing
04:05:04 <mgsloan> RaceCondition: Depending on Nix is a reasonable idea, but one of stack's priorities is good cross platform support.  Nix is problematic on OSX / windows 
04:05:33 <RaceCondition> right, fair enough... although it could be an optional dependency... but then again that wouldn't avoid duplication
04:05:48 <RaceCondition> then again, what if only the non-problematic parts of Nix were used...
04:06:27 <mgsloan> quchen: Then it builds with the version you request.  All the downstream dependencies of that package also get recompiled against that version and stored in your project's sandbox
04:06:30 <RaceCondition> for example, is Nix overall problematic on OSX/Win, or just some packages? couldn't cabal/stack use just the generic building mechanism, and not rely any problematic pacakges?
04:07:26 <mgsloan> quchen: Once the changes for implicit snapshot land, these will be stored in the "shared" set of snapshot dbs
04:08:00 <mgsloan> RaceCondition: I think Nix straight up doesn't work on windows, and it's a struggle on os x
04:08:23 <quchen> mgsloan: I think we skipped a step here: where do I put my "use this dependency that's newer than what Hackage has"?
04:08:24 <RaceCondition> it's definitely *working* on OS X... but it's likely it has problems with specific pkgs
04:08:37 <quchen> mgsloan: If extra-deps is not an overwrite, then I can't put it there
04:09:19 <mgsloan> quchen: Oh, it is an overwrite, maybe we miscommunicated earlier?  It sounded to me like you thought it affected the resolver.  It does not mutate anything, but it is a local overwrite for your project
04:09:56 <RaceCondition> mgsloan, seems OS X 10.9-10.11 are supported: https://nixos.org/wiki/Nix_on_OS_X#Compatibility 
04:10:03 <quchen> So "packages to use" = Set.merge extraDeps stackage, i.e. a left-biased overwrite of Stackage with my user-specified extra deps?
04:10:07 <mgsloan> Thing is, we have 3 package DBs for your project: Global (wired in pkgs), snapshot, and local.  Your packages and extra-deps get built into the local DB, which shadows the snapshot and global DBs
04:10:30 <mgsloan> quchen: Yup
04:10:33 <quchen> Aaah.
04:11:07 <quchen> I think you read my "overwrite" as a "destructive reinstall" when I meant it "in the build plan on-the-fly".
04:11:37 <mgsloan> Yup, that's what happened
04:12:08 <quchen> But then my original problem is back again: I want to specify a package to be considered only if it's not in another DB.
04:12:23 <quchen> I can parametrize the Travis script over the resolver, so I get multiple different CI builds. That's good.
04:12:36 <mgsloan> I think it's because I tend to think of the "resolver" as the snapshot bit.  But probably the term would also make sense as resolver + extra-deps 
04:12:57 <quchen> But I cannot parametrize over the extra-deps. For older stackages, I need to add dependencies to the extra-deps (e.g. Bifunctor for GHC 7.8).
04:13:12 <mgsloan> You'll probably need to write multiple stack.yaml files
04:13:23 <quchen> Hmpf. Okay, that would be one solution.
04:13:53 <quchen> It would be nice if we could do anything we can do in stack.yaml via the command line as well.
04:13:56 <mgsloan> Yeah, sorry.  We're intentionally keeping the format dumb for now (no inheritance, conditionals, templating, etc)
04:14:04 <RaceCondition> I wish stack.yaml supported some sort of include mechanism, and possibly other non-standard YAML
04:14:13 <mgsloan> quchen: agreed
04:14:29 <RaceCondition> ok, if it's intentional then nvm :)
04:14:39 <mgsloan> RaceCondition: Yeah, there have been a few github discussions about this
04:14:52 <quchen> stack.yaml being dumb is probably a good idea.
04:14:54 <RaceCondition> I guess I can just use something to auto-gen my stack.yaml files instead
04:15:03 <quchen> But there should be ways around that.
04:15:04 <RaceCondition> and keep stack.yaml really simple
04:15:12 <quchen> mgsloan: Take it as a feature request ;-)
04:15:41 <mgsloan> RaceCondition: Yes, the plan is probably add to a way to script generation of stack.yaml.  It seems like a good idea indeed
04:15:59 <mgsloan> then people can go nuts experimenting with different ways of specifying the generation of their stack.yaml
04:16:04 <mgsloan> if they so choose
04:16:47 <mgsloan> It would be nice if the CLI exposed everything the config does.  It'd be really lovely to be able to combine the specification of the stack.yaml with the global option flags
04:16:57 <mgsloan> buut that's dreamin'
04:17:14 <mgsloan> Speaking of dreamin' I shoulda been doing that hours ago
04:17:56 <RaceCondition> sounds awesome, all of what you said
04:18:28 <mgsloan> Relevant github issue: https://github.com/commercialhaskell/stack/issues/1375
04:18:29 <quchen> mgsloan: New question. Why doesn't stack build individual packages in parallel? It's the same thing with Cabal: neither pass GHC the -j flag, so the bottleneck when buliding are *packages* when they should be *modules*
04:18:31 <RaceCondition> btw how does Stack+Nix compare to Cabal+Nix? this basically http://stackoverflow.com/a/27970684/247623
04:19:01 <MarcelineVQ> idk how far you want to take cli options but I gotta say the cli is for stack pretty great, the resolver opt for modifying your stack file is something I use often for example
04:19:02 <RaceCondition> quchen, I think stack does pass -j, but that only parallelizes the build of one package, I think
04:19:24 <quchen> RaceCondition: Stack supports the -j flag for itself, but it won't pass it on to GHC
04:19:39 <RaceCondition> quchen, oh right, in that case I'm on your side :)
04:19:50 <mgsloan> MarcelineVQ: Glad you like it! :D
04:20:45 <mgsloan> I don't think we automatically pass in "-j".  It would be pretty cool to be able to adaptively figure out a -j number for ghc, though.
04:21:47 * quchen compiles with cabal using -j -extra-ghc-opts=-j all the time for that reason :-|
04:22:11 <mgsloan> In other words, you'd pass a low "-j" (or not pass it at all) when building lots of packages in parallel, but a high -j when there's just one build happening
04:23:15 <mgsloan> I've found things can get sluggish when I use a large -j and packages get built in parallel.  Too many processes at once, too much memory, etc
04:24:11 <akegalj> haskell Double uses scientific notation so 1.19139e-2 is valid Double. When I am trying to convert this to string (with ie show) i get "1.19139e-2". Can I somehow get rid of exponent part "e-2" ?
04:24:38 <jle`> akegalj: what do you want?  just "1.19139" ?
04:26:13 <akegalj> jle`: no, "0.019139"
04:26:39 <akegalj> jle`: I can move the decimal point myself, but maybe there is already something like it?
04:27:35 <jle`> > showFFloat Nothing 1.19139e-2 ""
04:27:38 <lambdabot>  "0.0119139"
04:27:50 <jle`> there are a couple of variations in the Numeric package in base; http://hackage.haskell.org/package/base-4.8.1.0/docs/Numeric.html
04:28:02 <akegalj> jle`: aaa, thank you so much
04:28:12 <jle`> you can also just use printf
04:28:38 <akegalj> jle`: oh jeah, I forgot about printf. Good point
04:29:09 <jle`> > printf "%f" 1.1939e-2 :: String
04:29:11 <lambdabot>  "0.011939"
04:29:48 <quicksilver> well printf is not the most primitive answer
04:30:09 <jle`> why be primitive when you can be printitive
04:30:26 <quicksilver> > showFFloat (Just 2) 3.14159 ""
04:30:29 <lambdabot>  "3.14"
04:30:53 <jle`> yeah, i presented showFFloat first, heh
04:31:24 <jle`> hm, there should be a Show instance for String -> String
04:31:30 <quicksilver> oh you did
04:31:32 <quicksilver> I'm blind.
04:32:38 <jle`> tried defining a Show instance for String -> String but it interferes with lambdabot's show instance for a -> b ;_;
04:32:55 <jle`> i guess the world is just not ready
04:33:40 <throwaway-123> Is haskell productively used in the real world? How productive does it make you?
04:34:11 <quicksilver> yes. very.
04:34:25 <jle`> yes. very. :)
04:36:50 <throwaway-123> recommend me a good talk that convinces me to learn haskell (in hope to do practical stuff with it some day)
04:40:58 <mauke`> this is a talk: https://www.youtube.com/watch?v=jLj1QV11o9g
04:42:55 <throwaway-123> mauke`: maybe something shorter, to watch during lunch time? :D
04:43:02 <tero-> I don't know if a talk can convince anyone to learn Haskell
04:43:41 <tero-> it seems somewhat mysterious what is luring people to Haskell
04:43:47 <mrvdb> tero-: not entirely, but they sure motivated me to spent the effort 
04:44:46 <tero-> maybe you need to spend some time in the dangerous trenches of Python, C++ and JavaScript to fully appreciate what Haskell offers
05:00:11 <Gurkenglas> Does some language extension allow mixing different numbers of arguments in different cases of a function definition patternmatch?
05:00:31 <quicksilver> no
05:00:46 <quicksilver> I think I've seen it discussed once
05:01:07 <SrPx> Is there any quick way to remove unused imports?
05:01:18 <SrPx> Perhaps an external command line tool, or vim plugin...
05:01:37 <quicksilver> one of the editor support packages can highlight them for easy deletion (ghc-mod mabye?)
05:01:58 <Gurkenglas> I don't know about quick, but I think HaRe wanted to do something with applying hlints?
05:03:44 <SrPx> Isn't there a new package for vim that's supposedly improved over ghc-mod? I don't remember the name... I didn't recall it did that, too, though
05:04:05 * SrPx just proceeds to do a manual binary removal
05:04:08 <quicksilver> see also https://hackage.haskell.org/package/fix-imports SrPx 
05:07:32 <LangeOortjes> I was reading the lecture on GADTs in action from UPenn and noticed that under "Getting Static Type Information", the instance declaration of TypeOfExpr (a->b) contains equations for types other than Expr (a -> b). I am wondering if that's correct and if so, why it is
05:07:45 <LangeOortjes> Talking about: https://www.seas.upenn.edu/~cis194/lectures/11-stlc.html
05:08:21 <Gurkenglas> Does that mean there's also a good reason not to do "= \" in some cases of a function definition?
05:10:48 <mauke`> LangeOortjes: what other types do you see?
05:13:12 <quicksilver> Gurkenglas: I don't think there is any reason not to do that, no
05:13:27 <quicksilver> the main subtle issue which affects the number of visible arguments is inlining
05:13:53 <Gurkenglas> http://lpaste.net/147680 <- What's wrong with (probably the forall part in) line 5?
05:15:01 <LangeOortjes> mauke` Expr a or Expr b for instance, there's a constructor in the Expr GADT Var :: String -> Type a -> Expr a, but then I see an equation typeOfExpr (Var _ t) = t under the instance declaration TypeOfExpr (a -> b), which doesn't make sense to me as Var constructs data of type Expr a, not Expr a -> b
05:15:39 <mauke`> LangeOortjes: those are two different 'a's
05:16:05 <mauke`> you can have Expr a where a = b -> c
05:16:21 <LangeOortjes> mauke` ah but of course
05:16:29 <quicksilver> Gurkenglas: I think there are issues with storing lenses in data types
05:16:58 <quicksilver> Gurkenglas: but do you get an error from that code? If so it would be useful to see it
05:17:01 <LangeOortjes> mauke`, thank you, silly of me. I think I should have a break
05:17:10 <Gurkenglas> @letlpaste 147680
05:17:11 <lambdabot>  Parse failed: Illegal data/newtype declaration
05:17:21 <mauke`> Gurkenglas: probably parens
05:18:05 <quicksilver> Gurkenglas: do you have GADTs turned on?
05:18:27 <quicksilver> or ExistentialTypes
05:18:30 <quicksilver> or RankNTypes
05:18:34 <quicksilver> you need something :)
05:18:36 <Gurkenglas> Does lambdabot? I haven't even done anything with this locally :D
05:19:09 <quicksilver> oh, well I'd try it locally. I don't know exactly what environment letlpaste gives.
05:20:25 <Gurkenglas> Pretty sure you can put extensions in the brackets at the top of an letlpaste
05:21:00 <quicksilver> googling suggests that is the error you get when you don't have appropriate extentions enabled for an explicit forall like that
05:21:41 <Gurkenglas> You say that like googling isn't an art :D
05:21:59 <APic> Gurkenglas: Very cool Nick.
05:23:35 <quicksilver> googling is my only marketable talent
05:23:41 <quicksilver> I just pretend I'm a developer
05:23:55 <alexa_> quicksilver: I think that's what we all do secretly
05:24:51 <RaceCondition> mgsloan, can I though tell Stack to install any extra-deps with Nix if available?
05:25:13 <RaceCondition> or do I have to manually put those packages in the nix section of the yaml file?
05:25:36 <RaceCondition> because it would be awesome to have stack auto-delegate anything under extra-deps to Nix, whenever possible
05:25:51 <Gurkenglas> (Still the same error after putting in those three exts http://lpaste.net/147680 )
05:26:29 <mauke`> have you tried removing parens?
05:29:30 <Gurkenglas> @letlpaste 147680
05:29:30 <lambdabot>  Parse failed: Parse error: else
05:29:40 <Gurkenglas> It changed! Thanks. Probably something else now.
05:30:28 <mauke`> missing ]
05:32:05 <Gurkenglas> Yep :s. int-e, would you add Data.Functor.Foldable to lambdabot?
05:32:31 <mauke`> @let import Data.Functor.Foldable
05:32:32 <lambdabot>  .L.hs:88:1:
05:32:32 <lambdabot>      Failed to load interface for ‘Data.Functor.Foldable’
05:32:32 <lambdabot>      Use -v to see a list of the files searched for.
05:32:37 * mauke` nods
05:32:59 <quicksilver> presumably recursion-schemes is what needs adding
05:33:03 <quicksilver> or did it get folded out?
05:34:32 <Gurkenglas> recursion-schemes only has the one thing, but if that might change in the future, sure. (Except if that makes it harder for the same whatever reason that he can't just automatically add everything made by ekmett (and perhaps that is safe-inferred or something))
05:48:00 <tero-> how could I simplify "f1 = (fmap f2) . (fmap f3) . f4" ? In this case the monad is Maybe
05:48:14 <quicksilver> fmap (f2 . f3) . f4
05:49:35 <tero-> quicksilver: thanks
06:02:15 <tekkkz> I have some problems with Hakyll. I want to create a Code Block in an markdown file (*.markdown) like this: http://ix.io/mX9 But the lines are behind each other and not in a new line. How to fix that?
06:02:59 <Clint> tekkkz: https://daringfireball.net/projects/markdown/syntax#precode
06:05:57 <SrPx> Is there any way to quickly generate a bytestring using an (Int -> Word8) function (the Int is the index)? Like Vector's "generate" functions? The best I can think of involves using B.pack
06:06:25 <hodapp> tekkkz: I thought one generally used ``` for code blocks, not `
06:06:38 <mauke`> ``` is an extension
06:08:08 <tekkkz> ty
06:08:51 <hodapp> it may be, but I've used it in Hakyll via Pandoc
06:09:34 <Clint> or you could just use the actual markdown syntax for code blocks
06:10:03 <tekkkz> whats that syntax?
06:10:20 <Clint> tekkkz: https://daringfireball.net/projects/markdown/syntax#precode
06:10:56 * frerich just defined 'year = (\(y,_,_) -> y) . toGregorian', remembered "There's an extension for that" and ended up with 'year (toGregorian -> (y,_,_)) = y'. First time I used view patterns!
06:11:42 <quicksilver> SrPx: unfoldrN or unfoldrN
06:13:09 <tekkkz> i cant see any markdown there Clint 
06:13:29 * Clint squints.
06:13:42 <tekkkz> Clint, i mean does it mean that i should just indent it
06:13:48 <Clint> yes
06:13:52 <Clint> no backticks
06:13:54 <tekkkz> ahh okay
06:14:12 <mauke`> "To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab."
06:14:17 <mauke`> IT LITERALLY SAYS SO
06:14:27 <ben> dont yell
06:14:39 <mauke`> apparently just giving the link doesn't work
06:14:44 <SrPx> Is that the fastest quicksilver ? I think the checks and the maybe constructor might be making it slower than it should :(
06:14:44 <mauke`> or giving it twice
06:14:52 <tekkkz> ahh okay
06:15:00 <SrPx> It is much slower than "BS.replicate", at least.
06:15:01 <tekkkz> and when i want to use it inlien then i need to use ` right?
06:15:02 <ben> harsh words coming from someone who has a backtick in their name themselves
06:15:31 <mauke`> tekkkz: https://daringfireball.net/projects/markdown/syntax#code
06:16:31 <tekkkz> ty
06:22:04 <miyako> hi
06:23:13 <quicksilver> SrPx: I have no idea. Compile with -O2, benchmark, experiment :)
06:23:47 <quicksilver> depending how complex the function is that generates each Word8, I would have thought that unfoldr would be able to saturate your memory bandwidth.
06:24:17 <miyako> I have no specific haskell questions; but I founded a haskell meetup in my area and I'm teaching some intro to haskell classes along side of it.  Wish me luck!
06:24:26 <MarcelineVQ> gl
06:37:17 <codedmart> I am trying to play with regex-applicative if I try this example in ghci I get an error https://hackage.haskell.org/package/regex-applicative-0.3.2.1/docs/Text-Regex-Applicative.html#v:string
06:37:27 <codedmart> Could not deduce (Data.String.IsString (f a0))
06:40:43 <geekosaur> codedmart, having an extension on in the source does not turn it on in ghci
06:40:47 <MarcelineVQ> Did you :set -XOverloadedStrings
06:40:55 <MarcelineVQ> oop geekosaur's on the case
06:41:05 <geekosaur> (otherwise ghci would become confused if you loaded sources with differing LANGUIAGE options)
06:41:25 <codedmart> I did set :set -XOverloadedStrings
06:42:09 <mauke`> monomorphism restriction?
06:42:15 <codedmart> geekosaur Here is the whole error https://gist.github.com/codedmart/81755a9411df6640e303
06:44:42 <quicksilver> the second line of that code example is required
06:44:44 <HelloHaskell> Hi all. I have a dumb question: how can I update the webpage called "Haskell modules on this system" ? AFAICT it's a webpage generated automatically. Mine is out of dated at the mment.
06:44:59 <quicksilver> "two" =~ number -- this part constrains the type of 'number' more strongly
06:45:07 <quicksilver> than the definition alone.
06:46:45 <codedmart> quicksilver So that example would not work in ghci alone?
06:46:49 <quicksilver> correct.
06:47:02 <quicksilver> not without a type annotation
06:47:21 <quicksilver> number:: RE Int [Char]
06:47:22 <quicksilver> I think.
06:47:24 <codedmart> quicksilver Thanks!
06:47:43 <MarcelineVQ> could you do multiline?
06:47:47 <geekosaur> well, could do it in ghci but need to combine those definiitons
06:47:52 <geekosaur> multiline or let ... in
06:47:53 <quicksilver> I think that's wrong.
06:47:53 <quicksilver> hmm
06:48:11 <quicksilver> RE Char Int ?
06:48:20 <quicksilver> yes, that.
06:48:27 <quicksilver> I hate overloadedstrings.
06:48:46 <geekosaur> not sure this is worse than the Text.Regex type >.>
06:48:47 <codedmart> quicksilver Thanks again
06:49:36 <icbm> Wow, I think I've turned the corner with Haskell. For the first time I had the thought "meh, this will be easier if I just write it in Haskell".
06:50:20 <mauke`> why limit yourself to one language? https://raw.githubusercontent.com/mauke/poly.poly/master/yes.c
06:51:56 <quicksilver> geekosaur: it's different :)
06:52:40 <quicksilver> geekosaur: first impressions are it's better. The extra overloading from IsString there just lead to an annoying ambiguity (which an explicit type sig up-front would have solved). 
06:52:47 * hackagebot tagsoup 0.13.6 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.13.6 (NeilMitchell)
06:53:01 <quicksilver> so from what I see so far, it beats the extreme overloading of Text.Regexp.
06:53:21 <quicksilver> but... I don't really use regex in haskell anyway so seldom care if there is a library with a good interface.
07:01:33 <pavolzetor> suppose you are parsing something, would you parse to data type and then write eval for that DSL, or just return functions from the parser directly?
07:01:44 <pavolzetor> let's say it is a calculator
07:02:00 <pavolzetor> would you return (+) or have data OP = Plus | Minus ...
07:02:03 <quicksilver> I would normall parse to a data type
07:02:16 <pavolzetor> quicksilver: why?
07:02:18 <mauke`> data type is nicer for debugging
07:02:23 <hodapp> pavolzetor: well, both ways have some merits, but separating out your 'interpreter' (or whatever) from your AST can be very helpful
07:02:23 <mauke`> also symbolic manipulation
07:02:34 <quicksilver> better for debugging, more modular, better for future enhancements
07:02:35 <hodapp> particularly for when you realize you need to do more than interpret directly
07:03:04 <hodapp> or, if you want to use a representation other than whatever you wrote a parser for
07:03:21 <hodapp> e.g. unit tests where you just write things in the AST directly
07:03:40 <pavolzetor> I see, definitely I more extensible
07:03:47 <pavolzetor> what are the merits of returning just functions?
07:03:54 <pavolzetor> (barring simplicity)
07:04:40 <quicksilver> conceivably it's faster
07:04:44 <quicksilver> that's all I can think of
07:06:03 <hodapp> hm, it removes the requirement of a separate AST, but that's just 'simplicity'... maybe
07:08:24 <pavolzetor> okay, I will consider both options but now I am leaning more towards AST
07:08:38 <pavolzetor> also, if you want to jump in list, would you just use vector?
07:08:49 <quicksilver> "jump in list"?
07:08:52 <pavolzetor> http://adventofcode.com/day/23
07:09:08 <pavolzetor> it is super simple, I just want to learn new things on this problem
07:09:10 <quicksilver> I would generally consider Seq before considering Vector
07:09:16 <pavolzetor> why?
07:09:19 <quicksilver> if I wanted fast random access
07:09:25 <quicksilver> because it has better performance in general
07:09:33 <quicksilver> faster concat, better sharing
07:09:50 <pavolzetor> Data.Sequence?
07:09:53 <quicksilver> yes
07:10:06 <rvx_i> anyone have opinions on graph databases? how are the haskell bindings for these things? BerkeleyDB bindings look like it hasn't been touched in ages
07:10:17 <quicksilver> although quite often I just use Map/IntMap
07:10:26 <quicksilver> laziness of familiarity
07:10:26 <pavolzetor> interesting, I usually see vector advertised everywhere
07:10:40 <quicksilver> vector is a good choice when compact memory representation is a goal
07:11:01 <pavolzetor> I used map/intmap before, so I want to use something else ;)
07:11:22 <rvx_i> what Data.Sequence has better performance than vector? i'd be surprised...
07:11:30 <quicksilver> better for concat, yes
07:11:47 <quicksilver> and it is a better behaved persistent structure, able to share in many cases
07:11:59 <quicksilver> whereas vector can only share in a few specific ones (slicing, I think)
07:12:08 <rvx_i> quicksilver concatenation perhaps, but probably not for numerical computing, right?
07:12:42 <quicksilver> if numerical computation means applying algorithms to huge arrays of numbers
07:12:54 <quicksilver> then certainly I would not recommend Seq for that
07:13:06 <quicksilver> I'd recommend you learnt OpenCL or something, probably :P
07:14:33 <pavolzetor> that sequence seems to use tree, so I will probably go with vector
07:14:41 <pavolzetor> I need only random access to be fast
07:15:01 <quicksilver> random access in Seq is fast.
07:15:08 <pavolzetor> logn is not fast
07:15:11 <quicksilver> yes it is
07:15:31 <quicksilver> constant time is a lie
07:15:36 <quicksilver> log n is the best there is
07:15:43 <quicksilver> only constant factors differ
07:15:54 <quicksilver> and vector *does* have a better constant factor than Seq.
07:15:58 <pavolzetor> okay, I am not going to argue here
07:16:00 <quicksilver> but, Seq is still fast.
07:16:31 <pavolzetor> for me fast is <10 cycles
07:17:16 <Hafydd> wow, you're cool..
07:17:24 <quicksilver> that's only relevant once you've profiled your code and proved it matters
07:17:47 <quicksilver> frequently in real use cases, you are bottlenecked on memory fetches
07:17:52 <quicksilver> and other cycles are free.
07:18:13 <quicksilver> of course when you have profiled it and you know that's the bottleneck - sure - that's the thing to concentrate on.
07:19:12 <pavolzetor> quicksilver: that's why I want to use array
07:19:20 <pavolzetor> to get < 10 cycles access
07:19:35 <pavolzetor> I hate this attitude that speed does not matter
07:19:48 <quicksilver> right. And I believe you are forming deductions from false premises. But that's OK, whatever you choose you will learn something about how it works and that is the objective.
07:20:12 <quicksilver> Assuredly speed matters, and spending time optimising non-bottlenecks will not help with speed.
07:21:33 <frerich> Hm, a puzzle which turned out to be more difficult I thought: given an infinite tree like 'data Tree a = Tree (Tree a) a (Tree a)', define a function 'fromList :: [a] -> Tree a' which given an infinite list of elements builds a tree in breadth-first order. I know this is solved (and Data.Tree has a function for it), but it's a nice challenge :-)
07:21:55 <frerich> E.g. 'fromList [1..]' should build a tree such that the children of '1' are '2,3' and the children of '3' are '6,7'.
07:22:32 <rvx_i> quicksilver openCL  as in accelerate?
07:22:55 <quicksilver> rvx_i: I wasn't recommending a specific haskell library (I've not used any of them)
07:23:09 <quicksilver> rvx_i: I was just saying that for that kind of computing, if you want performance then GPGPU is the way to go.
07:23:23 <pavolzetor> that's right, it just sets me on fire sometimes; usually it turns out that it is impossible optimize late in process, at least from my experience and the complete redesign is necessary
07:24:06 <maerwald> meh System.Directory.getPermissions is buggy
07:24:53 <maerwald> another function from that package I need to reimplement
07:25:02 <quicksilver> pavolzetor: ah well when that happens, it means the design was  wrong in the first place. A good design makes it easy to replace the core primitives with ones with different performance characteristics.
07:25:12 <pavonia> maerwald: Buggy in what way?
07:25:25 <maerwald> it fails on broken symbolic links
07:25:31 <maerwald> but those are valid files with permissions
07:26:05 <geekosaur> it doesn't use lstat
07:26:08 <pavolzetor> quicksilver: not that easy, look at all those game engines/GUIs/Haskell ;)
07:26:08 <quicksilver> pavolzetor: but of course such mistakes happen and it's annoying when they happen to you. It's definitely an art working out the most forward-thinking design which optimises for correctness first and permits optimisation later.
07:26:13 <geekosaur> if you want that, stick to System.Posix stuff
07:26:37 <mnoonan> You know.. sometimes I hear people complain about Haskell "I've *never* had a problem with mutable state, it isn't a problem at all."
07:26:44 <geekosaur> System.Directory is trying to be crossplatform, which means it's the minimal stuff that is supported anywhere
07:27:13 <mnoonan> I've just spent 45 minutes in lisp trying to figure out why this testcase fails if I throw in a call to a size method.
07:27:25 <maerwald> geekosaur: in fact, System.Posix.Files.fileAccess is what fails, so...
07:27:43 <mnoonan> If one of those "never had a problem" people was here right now, I'd pass the bug right on to them.
07:27:44 <pavolzetor> quicksilver: I would say that is impossible to do, since the hardware changes so much. Look at FP languages which assumed that memory will become "cheap" ;)
07:28:22 <geekosaur> aaagh why is it (or are you) using that
07:28:30 <geekosaur> access() is a race condition begging to happen
07:28:56 <geekosaur> and it doesn't do what people naïvely think
07:28:59 <maerwald> geekosaur: System.Directory is using that
07:29:05 <pavolzetor> anyhow, I am going to try learn the vector, thanks for the discussion and sorry for the uflamewar
07:29:12 <maerwald> not me
07:29:21 <quicksilver> pavolzetor: haha no problem. Learn all the modules. Make your own choices.
07:29:46 <maerwald> https://hackage.haskell.org/package/directory-1.2.4.0/docs/src/System-Directory.html#getPermissions
07:29:54 <maerwald> read_ok  <- Posix.fileAccess name True  False False
07:30:20 <geekosaur> sigh
07:30:29 <geekosaur> use the POSIX functions directly
07:30:31 <maerwald> I think I will just stop using that package
07:30:32 <geekosaur> do not use access
07:30:34 <maerwald> right
07:31:33 <quicksilver> "  CAVEAT access() is a potential security hole and should never be used."
07:31:46 <pavonia> mnoonan: Different programming praradigms often require different approaches to a certain problem. Trying to use a stateful algorithm in Haskell might become more complicated than necessary
07:31:55 <maerwald> good we have it in such a fundamental package like directory then
07:32:59 <geekosaur> actually I think I tilted at that windmill before... and it's still there
07:33:00 <aweinstock> pavonia: ST seems pretty straightforward
07:33:30 <rvx_i> state of game engines in haskell is sad..
07:34:08 <maerwald> geekosaur: it also does other weird stuff, e.g. copyFile doesn't work on symlinks, but renameFile does
07:34:15 <geekosaur> gotta be all special snowflake about backward compatibility with severe bugs and security holes y'know
07:34:50 <pavonia> aweinstock: Sure, but you wouldn't use that e.g. for a simple sum calculation of lists that you would do with updating a variable in imperative languages
07:35:01 <maerwald> you never know whether it follows symlinks or treats them as files
07:38:13 <aweinstock> :t let foldST f z xs = do { tmp <- newSTRef xs; mapM_ (modifySTRef' tmp . f) xs; readSTRef tmp in foldST
07:38:14 <lambdabot> parse error on input ‘in’
07:38:16 <athan> Hi everyone, how do builders work? I think they have O(1) appending, but what's their actual purpose?
07:38:20 <aweinstock> :t let foldST f z xs = do { tmp <- newSTRef xs; mapM_ (modifySTRef' tmp . f) xs; readSTRef tmp} in foldST
07:38:22 <lambdabot> Foldable t1 => (a -> t1 a -> t1 a) -> t -> t1 a -> ST s (t1 a)
07:38:56 <aweinstock> :t let foldST f z xs = do { tmp <- newSTRef z; mapM_ (modifySTRef' tmp . f) xs; readSTRef tmp} in foldST
07:38:58 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> ST s b
07:39:59 <aweinstock> ? let foldST f z xs = do { tmp <- newSTRef z; mapM_ (modifySTRef' tmp . f) xs; readSTRef tmp} in runST $ foldST (+) 0 [1..10]
07:40:04 <aweinstock> > let foldST f z xs = do { tmp <- newSTRef z; mapM_ (modifySTRef' tmp . f) xs; readSTRef tmp} in runST $ foldST (+) 0 [1..10]
07:40:06 <lambdabot>  55
07:40:10 <aweinstock> pavonia: ^
07:40:55 <pavonia> Very beginner-friendly ;)
07:41:17 <aweinstock> a beginner would probably write it less abstractly
07:42:47 <aweinstock> > runST $ do { tmp <- newSTRef 0; forM_ [0..10] (\i -> do { x <- readSTRef tmp; writeSTRef tmp (x+i)}); readSTRef tmp}
07:42:48 <lambdabot>  55
07:43:42 <pavonia> aweinstock: Would you consider this a typical functional solution to the problem?
07:44:22 <aweinstock> as compared to C: int f() { int i, tmp=0; for(i=0; i<=10; i++) { tmp += i; } return tmp; }
07:44:49 <aweinstock> pavonia: I'd consider (foldr (+) 0 [1..10]) to be the canonical functional way to do it
07:44:55 <aweinstock> s/the/a/
07:45:37 <srhb> aweinstock: Mind the thunk explosion. :P
07:46:12 <aweinstock> foldl'
07:46:35 <Hafydd> I just read about Pattern Synonyms, and it made my week.
07:46:40 <Hafydd> When was this added to GHC?
07:46:51 <pavolzetor> what do you use for non-negative int (i.e. something like uint32_t)?
07:46:55 <quchen> Hafydd: 7.8, with improvements in 7.10
07:47:07 <Hafydd> I see. I must have missed it before, then.
07:47:08 <pavonia> pavolzetor: Word32
07:47:27 <pavolzetor> thanks 
07:47:49 <pavolzetor> does it have proper overflow?
07:48:26 <geekosaur> no more than C does
07:48:32 <quchen> Yes it does
07:48:39 <srhb> > (maxBound :: Word32) + 1
07:48:41 <lambdabot>  0
07:48:48 <quchen> Haskell specifies arithmetic to be modulo 2^n
07:49:12 <quchen> C does not specify overflow if I recall correctly.
07:49:40 * frerich wonders what kind of programs you guys are writing that 'does it have proper overflow' is the first thing to worry about :-}
07:50:00 <aweinstock> quchen: I think unsigned overflow is defined in C, it's signed overflow that's not
07:50:02 <ggole> Signed overflow is undefined, unsigned is defined.
07:50:19 <obadz> anyone using haskell-ide-engine with emacs? is it working better than ghc-mod at this point? should I be switching?
07:51:02 <quchen> Anyway, Haskell has modular arithmetic for both Word (unsigned) and Int (signed).
07:52:04 <lambdanon> Got another quick question, I'm trying to understand Data.Map, and one of the first questions that comes up is: What is the difference between Data.Map and Data.HashMap as well as their Strict versions? On the small examples I am looking up they appear to work interchangeably at first glance.
07:52:34 <quicksilver> one requires an Ord constraint, one requires a Hashable constraint.
07:52:53 <quicksilver> HashMap, because it requires a Hashable constraint, can use a rather more sophisticated data structure
07:53:08 <quicksilver> so it's faster for many uses cases (as long as your Hashable instance isn't too slow)
07:53:36 <quicksilver> plain Map is basically forced to be a binary tree, not much else you can do if your only operation is `compare`
07:54:09 <quicksilver> the "Strict" business is about whether it stores thunks (the lazy default) or forces all values before inserting them.
07:55:53 <lambdanon> thank you, so there is a difference in how values are looked up? HashMap working like a dictionary, while map builds a binary search tree?
07:56:14 <quicksilver> I don't think I agree with "like a dictionary"
07:56:28 <quicksilver> dictionary doesn't suggest any particularly implementation strategy to me
07:57:01 <lambdanon> Maybe a bad example, I agree
07:57:02 <quicksilver> Map builds a binary search tree, HashMap builds a "hash-array mapped trie"
07:57:58 <quicksilver> I recall that HashMap was impressively faster when it first came out, but I've not seen recent benchmarks
07:58:17 <lambdanon> What I wanted to say/ask is, if for Map the program will have to run down a search tree, while with a HashMap there is some kind of table
07:58:32 <quicksilver> no, it's still something tree-like
07:58:45 <lambdanon> Oh ok
07:58:52 <quicksilver> it's just that you have to traverse fewer links, on everage, with the kind of trie that HashMap builds
07:59:23 <quicksilver> either way I use Data.Map myself (or Data.IntMap) until I am sure that it is slowing me down
07:59:30 <quicksilver> and then I benchmark and think about what will be better :)
08:00:58 <lambdanon> Yeah it made me curious since I tried playing around with both a bit and did not notice a difference yet (however I assume this becomes relevant in far larger use cases)
08:02:22 <quicksilver> since they have the same interface except for the class constraint it's not normally hard to switch
08:13:58 <erisco> what is an easy inclusive takeWhile?
08:14:55 <bennofs> erisco: what's non-inclusive about takeWhile?
08:15:04 <bennofs> > takeWhile even [2,4,6,3,4,5,6]
08:15:05 <lambdabot>  [2,4,6]
08:15:19 <lambdanon> you mean like takeWhile (<= 3) ?
08:15:22 <erisco> it does not contain the first element which does not satisfy the predicate
08:15:48 <bennofs> > break even [2,4,6,3,4,5,6]
08:15:50 <lambdabot>  ([],[2,4,6,3,4,5,6])
08:16:47 <wedens> is there an example of coproduct of free monads?
08:16:55 <lambdanon> > takeWhile (<= 4) [1,2,3,4,5]
08:16:57 <lambdabot>  [1,2,3,4]
08:17:48 <bennofs> hmm, i don't know if there is any easier way than writing your own with foldr
08:18:48 <recursion-ninja> How do I use Djinn in the IRC channel?
08:19:03 <erisco> > span even [2,4,6,3,4,5,6]
08:19:05 <lambdabot>  ([2,4,6],[3,4,5,6])
08:19:27 <liste> recursion-ninja /msg lambdabot @help djinn
08:19:28 <recursion-ninja> partition even [2,4,6,3,4,5,6]
08:19:29 <erisco> maybe I can grok something from that
08:20:00 <recursion-ninja> lambdabot @help djinn
08:20:09 <recursion-ninja> @help djinn
08:20:09 <lambdabot> djinn <type>.
08:20:10 <lambdabot> Generates Haskell code from a type.
08:20:10 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
08:20:16 <quicksilver> > let (matches,rest) = span even [2,4,6,3,4,5,6] in matches ++ [head rest]
08:20:18 <lambdabot>  [2,4,6,3]
08:20:24 <quicksilver> bennofs, erisco ^^
08:20:34 <erisco> well that clearly has a crash
08:20:43 <recursion-ninja> @djinn a -> a
08:20:43 <lambdabot> f a = a
08:20:51 <quicksilver> > let (matches,rest) = span even [2,4,6,3,4,5,6] in matches ++ take 1 rest
08:20:53 <lambdabot>  [2,4,6,3]
08:21:00 <quicksilver> you weren't all that clear about your spec, erisco :P
08:21:19 <erisco> you're right
08:21:23 <recursion-ninja> @djinn (a -> b -> (a,b)) -> a -> b -> ([a],[b])
08:21:23 <lambdabot> Error: Undefined type []
08:21:54 <recursion-ninja> @djinn (a -> b -> (a, b)) -> a -> b -> ([a], [b])
08:21:54 <lambdabot> Error: Undefined type []
08:22:05 <erisco> span is just take & drop
08:22:28 <erisco> hum de dum, okay I'll try to work it otu
08:22:37 <recursion-ninja> @erisco `Dat.List.partition` is probably what you want
08:22:37 <lambdabot> Unknown command, try @list
08:22:41 <quicksilver> matches ++ take 1 rest isn't what you wanted?
08:23:13 <erisco> my specification is not clear, remember? ;)
08:23:40 <erisco> I can put something together with take and drop, likely
08:27:02 <recursion-ninja> @djinn (a -> b -> (a, b)) -> a -> b -> ([a], [b])
08:27:02 <lambdabot> Error: Undefined type []
08:27:37 <pyon> Implementations of type-aligned sequences (free category) in Haskell typically require GADTs to handle the empty sequence case. If I wanted just non-empty type sequences (free semigroupoid), then existential types would be enough, right?
08:32:26 <Cale> pyon: hm? I don't see how existential types help.
08:33:21 <Cale> pyon: It's not just the empty sequence that needs the GADT-ness
08:36:05 <pyon> Cale: The free semigroupoid `Foo :: (k -> k -> *) -> (k -> k -> *)` could have constructors `One :: f a b -> Foo f a b` and `Many :: f a b -> Foo f b c -> Foo f a c`. I think this could be done with `data Foo f a c = One (f a c) | forall b. Many (f a b) (Foo f b c)`. Or is there something flawed with this logic?
08:36:57 <Cale> Oh, hmm
08:37:08 <Cale> Perhaps it can
08:37:27 <quicksilver> why can't you just add "None | " to that?
08:37:51 <pyon> quicksilver: Because `None :: Foo f a a`, and that constructor is inexpressible without GADTs.
08:38:06 <nullx002> hi
08:38:12 <quicksilver> oh, right
08:38:18 <nullx002> anyone uses emacs haskell mode?
08:38:33 <nullx002> i have a problem with interactive-haskell-mode
08:38:33 * pyon does, but is by no means an expert in how to configure it. :-p
08:38:45 <nullx002> have to load it manually everytime... not working with init.el
08:39:11 <nullx002> hi pyon, can you show me config?
08:39:25 <nullx002> i use one on github wiki of haskell-mode
08:39:39 <nullx002> it doesn't work in my case\ on debian emacs 24
08:39:43 <pyon> Actually, I'm having the very same problem. My ~/.emacs contains the line (add-hook 'haskell-mode 'interactive-haskell-mode), but I still need to do `M-x interactive-haskell-mode` to use it.
08:40:32 <nullx002> https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Setup
08:40:40 <Cale> I don't remember having that problem several years ago when I used emacs
08:40:49 <nullx002> it should work when we load any .hs file
08:41:21 <pyon> Checking.
08:41:35 <nullx002> i use emacs for everything including this irc in an erc buffer
08:41:57 * quicksilver uses haskell-mode but an old version and not haskell-interactive-mode
08:42:21 <pyon> Oh, so it's actually called haskell-interactive-mode? :-O Let's try that.
08:42:27 <nullx002> i have not found anyone for whom this worked out of the box
08:42:33 <quicksilver> no I typed it rwong I think
08:42:44 <nullx002> almost everyone has to do it manually by M-x interactive-haskell-mode
08:43:05 <nullx002> no it doesn;'t work
08:43:09 <nullx002> have tried already
08:43:13 <nullx002> still you can check
08:43:35 <nullx002> have to do it manually everytime a .hs file is loaded
08:43:43 <nullx002> same problem with auto-complete too...
08:43:53 <nullx002> hooks are not working .... strange... :(
08:44:30 <pavolzetor> is there some nice way to pattern match strings? suppose you have "abc x" and you want to do ('a':'b':'c':' ':x)
08:44:52 <pavolzetor> preferably
08:44:57 <pavolzetor> "abc ":x
08:45:11 <Cale> That pattern would clearly be for a list of strings
08:45:25 <quicksilver> stripPrefix
08:45:28 <Cale> "abc ":x is a list whose first element is the string "abc "
08:45:49 <quicksilver> in a patternGuard
08:46:03 <Cale> But yeah, there's stripPrefix, or depending on what you're doing, you might just go for a proper parsing library like Parsec.
08:46:06 <quicksilver> or use the prefix prism from lens
08:47:11 <nullx002> (require 'haskell-mode)
08:47:12 <nullx002> (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
08:47:31 <nullx002> this should work when a haskell file is loaded
08:47:34 <nullx002> but it is not...
08:47:57 <pavolzetor> Cale: you are right, I just was hoping for something short and sweet ;)
08:48:34 <quicksilver> > ["hello","haskell","world"] & traversed.prefixed "h" %~ map toUpper
08:48:34 <pavolzetor> I will go with 'a':'b':'c' since it is shortest but the strip prefix seems neat to
08:48:36 <lambdabot>  ["hELLO","hASKELL","world"]
08:48:50 <reactormonk> how do I map over the IO monad? map seems to be for lists only.
08:48:59 <quicksilver> fmap, reactormonk 
08:49:06 <quicksilver> or possibly fmap.map
08:49:10 <quicksilver> depending exactly what you meant.
08:49:19 <cggong> mapM
08:49:19 <Cale> Or mapM ?
08:49:30 <Cale> It's unclear what type of thing you want
08:49:52 <reactormonk> (a -> a) -> IO a -> IO a
08:49:57 <quicksilver> fmap
08:50:00 <Cale> ah, then fmap, yeah
08:50:27 <Jinxit> should one always use fmap over map?
08:50:43 <reactormonk> I expected it to be called map, not fmap - fmap sounds like flatmap, e.g. (a -> IO b) -> IO a -> IO b
08:50:53 <quicksilver> the f is for functor
08:50:59 <quicksilver> its a functor map
08:51:03 <Cale> Jinxit: I don't see the point in writing the extra f if you know you're operating on a list.
08:51:05 <codedmart> So as I am playing with regex-applicative. If I have a `type SomeType = Maybe (String, String)`. I would like to extract username/repo from urls like "git://github.com/username.repo.git" or "git@github.com/username/repo.git"
08:51:07 <reactormonk> ah ok
08:51:26 <Jinxit> Cale: but it works the same, yes?
08:51:46 <codedmart> I am able to do it with multiple lines and such. Just wondering if there is an easy one line solution that I am missing.
08:52:00 <Cale> Jinxit: yes (apart from there possibly being a slight amount of overhead from the pointer to the type class dictionary being passed along)
08:52:21 <reactormonk> Is there a default Show instance for https://gist.github.com/71abef9b92f16a0bf004 or do I have to define my own?
08:52:27 <Cale> I wouldn't worry about the performance difference though, if it exists, it's tiny
08:53:11 <Cale> reactormonk: You'll almost certainly have to write your own, unless you already have an instance of Show for functions hanging around.
08:53:21 * hackagebot systemd 0.1.0.1 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-0.1.0.1 (erebe)
08:53:23 * hackagebot systemd 1.0.1 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-1.0.1 (erebe)
08:53:35 <reactormonk> Cale, oh. Can I just write one for TopicItem -> X() and then get one?
08:53:53 <reactormonk> or do I need to write one for the whole TopicItem
08:54:08 <quicksilver> it's quite likely that you don't actually want TopicItem to have a Show instance
08:54:26 <reactormonk> quicksilver, that's true. Lemme rewrite my trace a bit.
08:58:46 <pavolzetor> is there built-in function that parses +10 properly?
08:58:55 <pavolzetor> read "+10" gives an error
08:59:05 <pavolzetor> > read "+1"
08:59:07 <lambdabot>  *Exception: Prelude.read: no parse
08:59:11 <quicksilver> as you'd expect since +10 is not haskell syntax for a number
08:59:11 <pavolzetor> cool
08:59:27 <quicksilver> > +1
08:59:28 <lambdabot>  <hint>:1:1: parse error on input ‘+’
08:59:37 <pavolzetor> I see, I was hoping for shorthand
08:59:49 <Cale> If you want shorthand, remove the +
08:59:49 <quicksilver> nope, check for leading +/- yourself
08:59:53 <Cale> :)
09:00:10 <pavolzetor> that what I was thinking ;)
09:00:18 <pavolzetor> just preproces the input
09:00:27 <Jinxit> > -1
09:00:29 <lambdabot>  -1
09:01:25 <Cale> (it figures that there's '+' characters in your real input already, but it's funny to imagine that you'd have been thinking of +10 as shorthand for 10)
09:02:25 <Cale> It's really starting to sound like you should be using Parsec or ReadP
09:02:33 <Cale> or something like that
09:16:26 <asciiascetic> have any of you ever used the TypeFamilies extension, and if so, why? 
09:18:22 * hackagebot systemd 1.0.2 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-1.0.2 (erebe)
09:19:40 <pavolzetor> https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Strict.html
09:19:41 <pavolzetor> ??
09:20:10 <quchen> asciiascetic: Type families on their own are rarely useful, but if you combine them with other extensions you can do type-level programming.
09:20:11 <quicksilver> newly uploaded package has no docs yet, pavolzetor 
09:20:30 <quchen> Servant is an example of how this was put to good use to write a rest service library, for example.
09:20:37 <quicksilver> I disagere quchen. They're very useful for constructs like container types
09:20:46 <pavolzetor> I see, it was slightly confusing, recently I run into many of these docs missing
09:21:05 <quchen> quicksilver: For example?
09:21:32 <quicksilver> well, given a Container c a type Elem c of the elements of that container
09:21:46 <quicksilver> to support containers which aren't necessarily of the form (f c)
09:22:16 <asciiascetic> quicksilver: are there any real examples I can look at?
09:23:09 <quicksilver> well vector uses type families to associate elements to vectors
09:23:31 <quchen> Associated types are nice, yes.
09:23:44 <phadej> e.g. http://hackage.haskell.org/package/mono-traversable-0.10.0.1/docs/Data-Containers.html
09:23:51 <quicksilver> monotraversable uses them to associate elements to "monomoprhic traversable" things
09:24:13 <phadej> :)
09:25:10 <asciiascetic> ah very good. I'd just read the 24 days of GHC extensions post on TypeFamilies and thought.. why not just make those functions constrained by (Monad m) ? 
09:26:15 <quicksilver> https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-At.html is another example
09:26:32 <quicksilver> or several examples really
09:56:18 <pavolzetor> how would you do exit from iteration; currently I have (iterate (f . g) and g can fail)
09:56:29 <pavolzetor> I would like something which would return last valid state
09:56:48 <pavolzetor> something like Maybe >>= Maybe but with last valid state feature
09:57:09 <johnw> @unmtl MaybeT (State s) a
09:57:09 <lambdabot> s -> (Maybe a, s)
09:57:50 <kadoban> pavolzetor: It can fail in the sense that it results in a Nothing, or some other way of failure?
09:57:57 <phadej> pavolzetor: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#t:Last
09:58:32 <pavolzetor> phadej: that monoid is exactly what I want, thanks :)
09:58:49 <phadej> np
09:59:12 <pavolzetor> kadoban: I wanted the last valid result
10:02:08 <pavolzetor> actually: it seems that Last ignores Nothing in betwee
10:02:15 <pavolzetor> so it does not do what I wanted :/
10:03:12 <roelof> I have a function that returns a tuple. Can I make a quickcheck test that the second number of the tuple is less then 2  
10:03:23 * hackagebot ffmpeg-light 0.9.0 - Minimal bindings to the FFmpeg library.  https://hackage.haskell.org/package/ffmpeg-light-0.9.0 (AnthonyCowley)
10:03:38 <johnw> prop_foo = \x -> snd (foo x) < 2
10:03:44 <johnw> quickCheck prop_foo
10:03:46 <phadej> pavolzetor: it feels that it should be already, but on other hand it's so special to Maybe so it probably doesn't exist
10:04:31 <roelof> johnw:  thanks,  I forget the snd and the first function of a tuple 
10:04:38 <pavolzetor> phadej: I think this must be somewhere, because it is common paradigm, i.e. iterate until you hit Nothing
10:04:46 <pavolzetor> I could do it using takeWhile
10:05:28 <pavolzetor> but I somehow want to avoid having MAybe in other function
10:05:43 <phadej> pavolzetor: in other funtion?
10:06:01 <pavolzetor> so I am trying to encode this
10:06:25 <pavolzetor> you have "fetch" give you instruction or fail (returns Nothing)
10:06:34 <pavolzetor> if it fails do to evaluate instruction
10:06:54 <pavolzetor> fetch program state >>= pure . eval state
10:06:56 <pavolzetor> sort of
10:07:20 <johnw> I think it would help to see actual code, and how you want the behavior to change
10:08:38 <pavolzetor> states = iterate (\s -> fetch p s >>= pure . eval s) $ initial
10:10:48 <johnw> this is the actual code you're using now?
10:11:06 <pavolzetor> it does not compile
10:11:11 <johnw> btw: eval s <$> fetch p s
10:11:26 <fr33domlover> Is there 'printf' for Data.Text or should I use T.pack ?
10:12:21 <johnw> pavolzetor: so, do you want to get this code to compile, or do you want something else entirely?  If you show me the types of initial, eval, and fetch, and what behavior you would like, that could help
10:13:01 <johnw> it *sounds* like you want use MaybeT over State, so that you can accumulate changes to state up until a failure, resulting in the last known state
10:13:11 <roelof> are these good quickcheck test for a function which looks for a max on two integers and count how many times this max occurs : http://lpaste.net/147740
10:13:17 <johnw> but we don't actually need to use monad transformers, if it's just this one line
10:13:22 <pavolzetor> johnw: what does <$> do?
10:13:28 <johnw> it's an infix form of fmap
10:13:36 <johnw> x >>= return . f == fmap f x
10:13:48 <pavolzetor> johnw: I got it compiled and then just let it crash on exception and read the result ;)
10:14:21 <johnw> roelof: you could also combine the tests if you want to, which would be faster
10:14:27 <johnw> but you don't really have to 
10:14:39 <pavolzetor> I see <$> is quite neat
10:15:24 <pavolzetor> give me a second, I wil lupload it on github as soon it builds again
10:15:43 <pavolzetor> then you can explain me how to do it best so I learn new stuff (that's why I am doing those silly things)
10:16:30 <johnw> ok
10:16:48 <johnw> what you're asking to do is a good technique to know, in my opinion
10:27:46 <vektor> So I'm trying to parse the output of ghci's :browse to get the type signatures of all the functions that are in scope in the module I'm looking at. And this is the output that was not parseable: http://lpaste.net/147741 in the format (String, ParseFailed of the String). Anything I'm obviously doing wrong? Missing LANGUAGE pragmas?
10:31:43 <roelof> johnw:  thanks, I think this is good. I know now which test is doing what 
10:32:01 <roelof> Im mean more that I could make more tests or other tests 
10:34:09 <pavolzetor> johnw: https://github.com/pavolzetor/advent_of_code/blob/master/src/day23.hs
10:34:37 <johnw> I see
10:36:16 <pavolzetor> http://adventofcode.com/day/23
10:36:21 <pavolzetor> that is the problem
10:37:25 <phadej> :r
10:38:38 <johnw> pavolzetor: so, the logic you want to express is something like: https://gist.github.com/9645ab2d1cc29dc01dcc
10:39:10 <fr33domlover> Hello! Q: Is there 'printf' for Data.Text? Or should I use the one for String and just T.pack/unpack all the args?
10:39:26 <mpickering> Vektor: the problem being that some of the things are not functions 
10:39:56 <vektor> Well, they're constructors, which semantically can kinda be used like functions. Plus in patterns of course.
10:40:26 <vektor> mpickering: The data I'm trying to extract is meant to be used by a type checker, so the difference exists.
10:40:33 <custom> haskell is too hard im going back to python
10:40:33 <pavolzetor> johnw: exactly
10:40:42 <johnw> then just use that :)
10:41:15 <johnw> I'm sure it can be golfed down to something smaller, but it's very easy to read in that form
10:41:37 <pavolzetor> johnw: not for me ;)
10:41:38 <maerwald> custom: starting is hard yes, but writing huge projects in haskell compared to stuff like python is way more easy, so it's a trade-off
10:42:33 <maerwald> I don't remember how often I rewrote core data structures, then just followed the compiler warnings and refactored with sed, lol
10:42:40 <vektor> maerwald: agreed. If you write good haskell code, complexity is a lot easier to manage than in other languages imo. Types help out a lot.
10:42:52 <custom> I only know python and C++
10:43:11 <maerwald> if you change core data structures in a C project, you end up having a 2 hours memory debugging session =)
10:43:17 <pavolzetor> johnw: but I like the solution, much simpler to write and shorter; I thought the mantra was to use hiher order constructs
10:43:20 <vektor> maerwald: sed?
10:43:31 <maerwald> vektor: yeah... sed the constructors^^
10:43:49 <johnw> pavolzetor: the mantra is really to code with a light hand
10:43:49 <phadej> https://gist.github.com/phadej/ba60222c6de2e63e5c4d
10:43:50 <vektor> huh? What is sed?
10:44:01 <maerwald> err
10:44:12 <maerwald> windows user alert
10:44:24 <maerwald> https://en.wikipedia.org/wiki/Sed
10:44:34 <custom> sed is a outdated shell
10:45:57 <phadej> pavolzetor: two different ways to see the solution, in prime version, the f' is a single instruction evaluator, and the state is `a, b, instruction pointer`
10:46:16 <phadej> and with forever you run a program until it cannot advance
10:46:26 <maerwald> refactoring is really one of the more practical advantages of haskell, all that more scientific love aside
10:46:41 <pavolzetor> johnw: it is kind of I learned new stuff so I wanted to use it and made it more complex; I will switch to something similar to yours
10:46:42 <phadej> yet the johnw's version is definitely much clearer
10:47:14 <pavolzetor> phadej: I need to learn so much stuff to get your solution
10:47:24 <johnw> pavolzetor: yeah, I've been guilty of doing that many, many times
10:47:56 <pavolzetor> I will put a credit in comment; I am inspired, thanks
10:48:02 <johnw> pavolzetor: just remember: in the movies, the Zen master always looks like he knows nothing, until the moment he really needs to use what he knows
10:48:15 <pavolzetor> what movies?
10:48:22 <johnw> kung fu movies :)
10:49:13 <phadej> I'm still suprised that this kind of combinator doesn't live anywhere
10:49:15 <maerwald> the Zen master just forces his confusion onto the student
10:49:49 <pavolzetor> johnw: I see, I am more sci-fi book guy; but I agree, I want to achieve that level where the solution is simple
10:50:00 <pavolzetor> phadej is then Zen master
10:50:09 <phadej> :
10:50:09 <maerwald> let him confuse you then :D
10:51:25 <PseudoNoise> Hey folks, new to Haskell, working through problems here: https://www.codingame.com/games/puzzles/. In "MIME Types", need to look up a string by extension, given a list of filenames. I have solved it but I don't like how I found the extension. Paste here: http://lpaste.net/147743
10:51:56 <PseudoNoise> I don't like how the findExt function is far away from where it's used, and it seems clunky with too many parentheses.
10:54:59 <maerwald> PseudoNoise: use the filepath package
10:55:02 <maerwald> @hackage filepath
10:55:02 <lambdabot> http://hackage.haskell.org/package/filepath
10:55:16 <PseudoNoise> Not the point of the exercise; it's an exercise in text parsing
10:55:43 <PseudoNoise> These files don't actually exist.
10:58:25 * hackagebot reactive-banana 1.0.0.1 - Library for functional reactive programming (FRP).  https://hackage.haskell.org/package/reactive-banana-1.0.0.1 (HeinrichApfelmus)
10:59:57 <mnoonan> findExt: you could always move findExt into a let expression inside the do block (but to me it is readable enough as is)
11:00:18 <mnoonan> ^^ PseudoNoise
11:04:21 <PseudoNoise> mnoonan: Thanks, trying to use "$" to remove parentheses where I can but couldn't hack it here somehow, esp "otherwise = drop ((last i) + 1) f "
11:05:02 <Guest00000> PseudoNoise: drop (last i + 1) f 
11:05:17 <Guest00000> but you can't use a $ here, yes
11:05:19 <PseudoNoise> oh well there ya go.
11:05:37 * ski thinks `$'s are often overused, anyway ..
11:06:37 <exio4> Guest00000: well, flip f $ last i + 1 :p 
11:06:41 <exio4> flip drop f * 
11:06:53 <Cale> I would probably have written something along the lines of reverse . takeWhile (/= '.') . reverse
11:07:01 <ski> if there's a lot of trailing `)'s at the end, that may indicate that one can reformulate with `$' (or possibly with `.' or ...)
11:07:16 <Guest00000> exio4: to me, that's more complicating
11:07:22 <Cale> Of course, that doesn't handle the case where there are no dots the same way, but you can still separate that out.
11:07:51 <PseudoNoise> Cale: yeah I need the first guard for that.
11:08:44 <PseudoNoise> exio4: That one's over my head.
11:09:17 <PseudoNoise> I know what flip does, not sure how that works.
11:09:26 <exio4> PseudoNoise: the flip one was a joke, it's not really nice to read =)
11:09:28 <PseudoNoise> oh
11:09:33 <PseudoNoise> <-- beginner
11:10:16 <Guest00000> but if we only had an operator instead flip
11:10:42 <vektor> Ok.... so how *do* I generate the data the type checker needs to work with now? the GHC API is a hassle, ghci's :browse output seems good enough, but it's kinda hard to parse.
11:10:50 <Guest00000> say, (~) = flip, and then using (f ~) instead of (flip f)
11:11:06 <Guest00000> then uses of flip would be more readable
11:12:03 <kadoban> Guest00000: You can just use operator sections instead of flip anyway.
11:12:45 <kadoban> > map (`mod` 5) [1..10]
11:12:47 <lambdabot>  [1,2,3,4,0,1,2,3,4,0]
11:12:47 <Guest00000> oh
11:12:54 <Guest00000> why did't i think about it?..
11:15:21 <PseudoNoise> oh wow, til https://wiki.haskell.org/Section_of_an_infix_operator
11:15:53 <kadoban> Yeah it's pretty neat stuff.
11:18:02 <vektor> are there ternary operators? I don't think there are, right?
11:20:02 <johnw> b ? x : y vs. if b then x else y.  except for the leading "if", they have the same form.
11:20:19 <johnw> you can't define a ternary operator, though
11:20:47 <teurastaja> use a monad?
11:21:36 <monochrom> monad is irrelevant for this
11:21:36 <kadoban> if blah then something else whatever -- is essentially the ternary operator in haskell.
11:21:57 <kadoban> Oh someone said that, I'm blind.
11:23:31 <Cale> You kind of can though
11:24:30 <johnw> Cale: oh?
11:24:52 <Cale> In two parts :)
11:24:59 <johnw> ah
11:26:04 <Cale> @let infix 1 ?; (b ? x) y = if b then x else y
11:26:06 <lambdabot>  Defined.
11:26:18 <vektor> No!
11:26:18 <Cale> > 1 > 0 ? "yes" $ "no"
11:26:20 <vektor> Stop! 
11:26:21 <lambdabot>  "yes"
11:26:25 <vektor> Don't do it ! :D
11:26:53 <Gurkenglas> Is there a class Num r => VectorSpace r v | v -> r that defines vector operations on v?
11:27:01 <Cale> one of the parts can be ($) :)
11:27:07 <Cale> But there are other approaches
11:27:11 <johnw> clever hobbitses
11:28:10 <Cale> Gurkenglas: I think there are at least a few packages on hackage that define something like that
11:28:14 <kadoban> Cale: That's pretty cute.
11:29:21 <mnoonan> how about..
11:29:28 <vektor> @let (|) = ($)
11:29:28 <vektor> or so...
11:29:28 <lambdabot>  Parse failed: Parse error: |
11:29:33 <mnoonan> @let infix 1 ?; (?) = flip (!!) . fromEnum
11:29:34 <lambdabot>  .L.hs:165:9:
11:29:34 <lambdabot>      Multiple fixity declarations for ‘?’
11:29:34 <lambdabot>      also at  .L.hs:167:1-9
11:30:00 <mnoonan> @unlet (?)
11:30:01 <lambdabot>  Parse failed: TemplateHaskell is not enabled
11:30:24 * mnoonan can't lambdabot.
11:30:25 <Cale> Gurkenglas: http://hackage.haskell.org/package/vector-space-0.10.2/docs/Data-VectorSpace.html
11:31:08 <Cale> @undefine
11:31:08 <lambdabot> Undefined.
11:31:24 <mnoonan> @let infix 1 ?; (?) = flip (!!) . fromEnum
11:31:26 <lambdabot>  Defined.
11:31:45 <Cale> That's less safe
11:31:51 <mnoonan> > (1 < 0) ? "true" : "false"           :[] -- robot face because it is too terrible
11:31:53 <lambdabot>  "true"
11:32:04 <Cale> haha
11:32:27 <Cale> of course
11:33:56 <mnoonan> just realized it is backwards; terrible in lots of ways :)
11:35:03 <thimoteus> nah, the quotes are just sarcastic markers
11:36:45 <Guest00000> how to see a lambdabot declaration?
11:51:27 <vektor> Can I "postpone" the declaration of Constructors for a type? I.e. I need a type Input and Output, and I want them both to be properly typed. The problem is: What I'm gonna be putting through those I/O channels, I don't know yet.
11:52:19 <vektor> Or at least, I don't know completely when declaring the types for Input and Output.
12:13:07 <thiagofm> Hello.
12:13:43 <hiptobecubic> vektor, the whole point of types is that you do know them.
12:14:04 <hiptobecubic> well maybe not the whole point, but the reason that compilers and type systems are useful
12:14:34 <hiptobecubic> vektor, how is the compiler to know that your program is valid if you don't know what the types are?
12:14:56 <kadoban> vektor: I don't really understand what you're doing, but you can just say data Whatever = Whatever, or even type Whatever = () and figure it out later, but yeah it's not going to be useful until you fill in the details.
12:15:38 <pharaun> i find i have to often adjust my types when i develop a project because i often have incomplete understanding of a problem
12:15:43 <vektor> I mean, at compile time the types are known - they're just in a different location.
12:15:55 <pharaun> vektor: elaborate on that
12:15:59 <bitemyapp> @tell Rizy send me an email
12:15:59 <lambdabot> Consider it noted.
12:16:11 <thiagofm> Can I get help? (it's probably easy) http://pastebin.com/WTpuA51Y
12:16:46 <vektor> Like, my module IOGeneral will say that those types exist, and then there's a whole bunch of other module that give one concrete declaration of the type.
12:16:58 <vektor> (of Input and Output each that is)
12:17:12 <vektor> I kind of feel like I'm trying to do what inheritance does in OOP.
12:18:39 <vektor> thiagofm: Briefly looking at it, I see you're defining "return"
12:19:02 <pharaun> oh
12:19:03 <thiagofm> vektor: yes. I couldn't compile it if I don't specify "Main.return..."
12:19:03 <vektor> actually, nevermind... that might just be useful, idk.
12:19:06 <pharaun> you can do stuff like
12:19:21 <pharaun> a -> whatever [a]
12:19:22 <pharaun> for ex
12:19:28 <pharaun> and then fully specify it when you use it
12:19:52 <thiagofm> vektor: the haskell book uses return without Main, but this doesn't compile for me.
12:20:12 <thiagofm> ghci 7.10
12:20:31 <vektor> thiagofm: that's because you've defined your own return and your compiler yells at you because it now knows 2 functions by that name.
12:20:38 <thiagofm> It's probably something very dumb, but I lack enough haskell knowledge to circunvent that
12:20:54 <thiagofm> So how do I specify that it's my return?
12:21:17 <vektor> thiagofm: You've done that.
12:21:36 <vektor> pharaun: Huh? I'm not sure I see where you're going.
12:21:38 <thiagofm> Okay :(
12:22:26 <thiagofm> So, what can I do? This error is probably happening because of something that have changed in haskell in the last years, as the book is kinda outdated.
12:22:42 <vektor> thiagofm: anyways, your return type is all messed up. what's p supposed to return?
12:22:51 <pharaun> :t (++)
12:22:52 <lambdabot> [a] -> [a] -> [a]
12:22:56 <pharaun> vektor: ^
12:23:30 <pharaun> do you care what the value is or are you just shuffling it around, if you are just shuffling it around you can do that
12:23:55 <vektor> If I understand you right, I do care what the value is.
12:23:55 <pharaun> if you need to interact with the value itself then i think there's typeclass or using records to specify the type later
12:24:00 <pharaun> ah k
12:24:27 <thiagofm> vektor: from what I see in the book, it's a Parser
12:24:29 <pharaun> i think i usually use existional types to only expose the bits that i care about
12:24:32 <vektor> pharaun: Here's a concrete example: https://github.com/vektordev/GP/blob/master/src/PartitioningProblem.hs - this is the way it's set up right now.
12:25:21 <vektor> Input and Output are conretely defined. But I noticed that I have a lot of other "Problems" similar to this one: The same set of functions as defined in that module, but the concrete types of Input and Output are different.
12:25:45 <vektor> However, I need a centralized type in which I can pack the I/O types of all the Problems I do have.
12:26:38 <vektor> So in TypeCheckProblem, my Input could be a String and the output could be a Type, or similar.
12:27:07 <vektor> (Type being a datatype that can hold the definition of a type, as to be expected within a compiler)
12:27:24 <bergey> pharaun: It looks like GHC is using the Monad instance for (a ->) in that do block, instead of the (>>=) that you defined.
12:28:30 <vektor> bergey: You're probably trying to ping thiagofm instead.
12:28:46 <bergey> So I am.
12:29:22 <pharaun> indeed
12:30:03 <bergey> thiagofm: return and >>= are part of the Monad type class.  If you define the versions for Parser as an instance of the class, GHC will do the right thing with your do block.
12:30:10 <pharaun> ok vektor so you want to apply this algo/function to different type of input and ouput (and want to abstract what it does to the input) to arrive at an output
12:30:16 <pharaun> you could do something with a record
12:30:32 <pharaun> where you create a record that contains the input data, and the function that operates upon that data
12:30:46 <tremon> vektor: are you looking for typeclasses? i.e. make sure your type obeys certain operations?
12:30:48 <pharaun> and pass that to your thing, and you'll get the output type from the output of your functions
12:30:57 <pharaun> typeclass could be the solution here
12:31:13 <pharaun> but records+functions are also an solution
12:31:27 <pharaun> i feel typeclass is more for the case where there is one obiv correct implementation for each type
12:31:27 <vektor> tremon: The bunch of functions that operates on my I/O types surely sounds like a typeclass, I agree.
12:31:38 <pharaun> the record approach is more for , oh i can do it this, or that or that way
12:31:47 <vektor> tremon: I'm not sure it'd work though, I'll have to find out.
12:31:50 <pharaun> vektor: be careful like i said earlier
12:32:02 <pharaun> typeclass is more for when you have one obiv correct implementation for each type
12:32:03 <tremon> yes, I guess the fundamental difference would be where to implement the speciation
12:32:27 <pharaun> its not easy/...possiblish to have more than 1 typeclass impl on the same type
12:32:43 <tremon> with a typeclass, the speciation goes with the type definition. With records, the speciation goes in the function, right?
12:32:49 <thiagofm> bergey: how do I make it a instance of the Monad class? :(
12:32:56 <pharaun> tremon: yes
12:33:03 <pharaun> and there's the additional general "requirement"
12:33:10 <pharaun> that typeclass is more for one correct impl for each type
12:33:20 <pharaun> if you are not going to have one correct impl for each type, use records
12:33:33 <tremon> true
12:33:42 <vektor> Alright, I guess I should go full story here, this is turning out to be a bit more intricated. Genetic Programming, working on several Problems in parallel. Input/Output are there to communicate with the Genome. The Genome basically just implements one function :: Input -> Output and my framework then checks how good that implementation is.
12:34:12 <pharaun> there's also the existional qualification trick too
12:34:30 <pharaun> existional on the value+func, and pass that in and then the genome runs that func on the value
12:34:50 <pharaun> but i think i would recommend records at least initially
12:35:04 <pharaun> (and yes i mispelled the word, i can never spell it right)
12:35:48 <vektor> Now, I definitely need to define what those types are. However, since I'm adding Problems for the GA to deal with as I go, I'd prefer to declare the constructor for, for example the partitioning problem along with the functions that generate test cases.
12:36:31 <pharaun> vektor: that's why i suggested records, it store the values + functions for your GA to interact with the values
12:36:43 <pharaun> then you define that where you define the problem and pass it in to your GA
12:37:21 <vektor> I'm not following. What would you put in the record exactly?
12:37:55 <pharaun> https://github.com/pharaun/hComicFetcher/blob/master/src/Types.hs#L148-L158
12:38:01 <pharaun> here's an example where i employ this
12:38:27 <pharaun> the important bit here is - seedType and pipeParse
12:38:44 <pharaun> seedType defines and holds on the input value, pipeParse defines a function on how to interact with it
12:38:59 <pharaun> then you pass this to your thing, which then it pulls out that pipeParse func for ex and use it to interact with the input
12:39:08 <pharaun> thus making your algo/GA independent from the input/output types
12:39:38 <pharaun> the pipeParse func will need to be something like "foobar :: t -> Int" or some useful type that you can directly use in your GA
12:40:23 <pharaun> in the trivial case say your input type is "Int" you can just have "foobar = id" but say if its something else like a double. you could do "foobar = truncate
12:41:35 <vektor> so the foobar function would convert whatever has been stated as the Problem into one definitive Type, no matter what kind of Problem?
12:41:40 <pharaun> ya
12:41:42 <pharaun> https://github.com/pharaun/hComicFetcher/blob/master/src/Types.hs#L148-L158
12:41:56 <pharaun> here's how i use it (i pass the record with stuff into it) to the func
12:42:01 <pharaun> and its able to handle all sort of types here
12:42:05 <bergey> thiagofm: http://pastebin.com/3efz0HqP
12:42:21 <vektor> (you just pasted the same link twice)
12:42:50 <pharaun> whoops
12:42:59 <pharaun> i'm using osx i keep on forgetting clove is for paste/copy
12:43:38 <pharaun> https://github.com/pharaun/hComicFetcher/blob/master/src/Main.hs#L54-L71
12:43:40 <vektor> Okay, that isn't quite what I want. I definitely want the Genome to be able to look at the type of Problem. For example, the solve function should be able to use patter matching, like so: Solve (PartitioningProblem listofint) = solvepartitioning listofint
12:43:42 <pharaun> ok that's the right one
12:44:07 <pharaun> vektor: oh
12:45:11 <vektor> pharaun: one thing I'm trying to find out is whether a type system like haskell's makes genomes in a language like haskell any more viable, because of all the compile-time checking. So that part is kinda crucial.
12:45:36 <vektor> I guess I have a solution: Just adding constructors to the definition of Input/Output as I go.
12:46:09 <pharaun> afaik this sounds (from description) like the what was it called - http://stackoverflow.com/questions/3596366/what-is-the-expression-problem
12:46:25 <pharaun> vektor: i guess
12:46:28 <pharaun> so an sum type?
12:46:40 <pharaun> yeah that is an solution (if you want to extend your input/output)
12:46:43 <pharaun> then yes that would work
12:47:17 <vektor> However, I'll also have a NoFrigginIdea :: Output, which enables the genome to say that it doesn't even know what the input type means, so it hasn't learned to answer yet: solve (PartitioningProblem xs) = solvePP xs; solve _ = NoFrigginIdea. This wouldn't cause a runtime error nor a type error and would just result in a low fitness value.
12:47:52 <pharaun> wfm yes
12:47:57 <pharaun> that would be a sum type, yeah
12:48:10 <vektor> The problem I'm dodging with that of course being that if I add a Problem, the type checking and pattern matching will blow up and I end up dragging the score in other Problems down too.
12:48:13 <pharaun> pattern match on the input type in your sum, and do stuff, and if its one you haven't handled yet do a _
12:48:25 <vektor> Yeah, definitely a sum type. As I said, adding constructors is what I wanted to do.
12:48:48 <dmwit> vektor: Sounds like you may enjoy the "data types a la carte" paper.
12:48:48 <pharaun> well there's no way to avoid that unless you remove the _ then have the code blow up/error out with an warning (incomplete pattern matching) iirc
12:48:59 <dmwit> vektor: Though I've only browsed the recent discussion, haven't read in detail.
12:49:01 <pharaun> oh nice, i have heard of that paper
12:49:11 <pharaun> haven't read it yet i think or i don't remember
12:49:46 <pharaun> hmm sounds familiar
12:50:32 <pharaun> nope i haven't, thanks dmwit 
12:51:20 <pharaun> can't find a pdf, dmwit you have one on hand?
12:52:19 <pharaun> http://foswiki.cs.uu.nl/foswiki/pub/GP/Schedule/WoutElsinghorst.pdf <- this ?
12:52:27 <vektor> http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=D8C81927E9FA1E11456D5F6FE1A24164?doi=10.1.1.101.4131&rep=rep1&type=pdf <- this?
12:52:45 <dmwit> https://scholar.google.com/scholar?q=data+types+a+la+carte first hit =P
12:53:12 <pharaun> first hit -> pay link
12:53:21 <dmwit> err... hm
12:53:36 <vektor> My link is the same author.
12:53:37 <dmwit> first hit is the presentation pharaun linked to, which is nice but is not the paper
12:53:44 <pharaun> ya
12:53:51 <pharaun> the one that vektor linked seems to be it?
12:53:55 <pharaun> looks like a paper to me
12:54:02 <dmwit> Yep, vektor's link looks more like what I remember.
12:54:21 <dmwit> dmwit-- for prematurely lmgtfy'ing
12:54:24 <pharaun> kk sweet thanks, saving
12:54:49 <vektor> same here, saving.
12:55:37 <vektor> Heh, I'm kinda stuck in between reading a lot of FP research - while working for a ML group.
12:55:38 * dmwit vanishes in a puff of smoke
13:04:13 <christmasdotcode> if I have an unkonwn number of Justs:w
13:04:16 <christmasdotcode> whoops
13:04:42 <christmasdotcode> if I have an unknown number of Justs, how can I turn that into just a single Just?
13:04:58 <christmasdotcode> kind of like foldr join (Just $ Just $ Just $ Just 1)
13:05:04 <christmasdotcode> (only that doesn't type check)
13:06:04 <ski> christmasdotcode : what would the type of the function be ?
13:06:22 <christmasdotcode> ski: dunno - that's why I'm trying to figure out if it's even possible
13:06:43 <kazagistar> 1) Why would you want to do that? 2) You can probably use a typeclass or something?
13:06:49 <ski> it's not directly possible (except maybe with silly type class stuff)
13:08:03 <vektor> christmasdotcode: You probably have a constant number of Justs chained together. Probably. In that case, you can just pattern match on it. Like so: reduceJust (Just (Just (Just x))) = x
13:08:09 <christmasdotcode> ski: thought it would be really cool if it was possible :)
13:08:22 <ski> however, if you have `newtype Maybes a = M (Maybe (Maybes a))' or `data Maybes a = H a | M (Maybes (Maybe a))', then you could write `joins :: Maybes a -> Maybe a'
13:08:30 * hackagebot timeplot 1.0.30 - A tool for visualizing time series from log files.  https://hackage.haskell.org/package/timeplot-1.0.30 (EugeneKirpichov)
13:08:39 <vektor> if it's actually not known, making a function out of it that has an actual type? Uhh, yeah... Maybe. Maybe Not(hing).
13:08:48 <christmasdotcode> that's clever, ski
13:08:58 <christmasdotcode> vektor: haha
13:09:09 <ski> with the latter, you could do `(joins . M . M . M . M . H) ((Just . Just . Just . Just) 1)'
13:09:58 <vektor> christmasdotcode: Do you have a concrete problem you're working on? Because if that's the result of a function you're somehow getting, you probably have a concrete Type and thus could do the pattern matching thing.
13:10:26 <ski> with the fomer, it'd be `joins ((M . Just . M . Just . M . Just . M . Just . L) 1)' .. er, sorry, you need an alternative `L a' (and then it needs to be `data', not `newtype') as well
13:10:49 <ski> with the former, `M' and `Just' will be interleaved. with the latter, they will be separated
13:11:39 <statusfailed> I have a program 'main = mapM_ print someList', but it seems to be doing buffering when I redirect to a file, so I don't get any output (it takes a long time to generate the whole list)
13:11:41 <ski> christmasdotcode : anyway. as a serious answer, i second vektor's comments
13:11:49 <statusfailed> how do I turn off buffering?
13:12:00 <statusfailed> I mean, without changing the code
13:12:28 <pharaun> you change the code to turn off buffering ;p
13:12:29 <statusfailed> oh I think I have to explicitly set the buffering.. nevermind then
13:12:30 <statusfailed> haha
13:12:36 <statusfailed> dwerp
13:12:44 <ski> @type \h -> System.IO.hSetBuffering h System.IO.NoBuffering
13:12:46 <lambdabot> GHC.IO.Handle.Types.Handle -> IO ()
13:12:51 <statusfailed> hmm, isn't the default LineBuffering?
13:12:59 <statusfailed> I wonder why I don't see my lines
13:13:02 <vektor> not if you pipe into a file.
13:13:10 <statusfailed> ah
13:13:16 <vektor> If you pipe into a file, Haskell notices and is being a lazy prick.
13:13:18 <statusfailed> where is that decision made?
13:13:20 <statusfailed> that's annoyin'
13:13:23 <vektor> Because, why wouldn't it?
13:13:29 <vektor> Except someone is watching that file closely.
13:14:07 <vektor> do hSetBuffering stdout LineBuffering; otherstuff; worked for me.
13:14:12 <kadoban> statusfailed: It's usually a really nice default.
13:14:42 <rninty> Is it possible to implement Alternative for (a -> Alternative b)?
13:14:59 <rninty> With language extensions, even
13:15:03 <Leonid> hi, some ideas for projects to learn haskell? have experience in programming and some f#
13:15:04 <statusfailed> kadoban: in terms of performance maybe :p
13:15:11 <Leonid> thanks
13:15:12 <vektor> kadoban: seconded. I only found it annoying when I decided that I had to keep my stdout for future reference, but still wanted to have an eye on it during runtime.
13:15:27 <statusfailed> python does the exact same thing tbf
13:15:30 <vektor> Thus, set buffering manually and *then* use tail -f
13:15:52 <apriori> Leonid, my general suggestion would be: just pick a task with actual use for you
13:16:09 <vektor> leonid: Have you looked at LearnYouAHaskell? THe book that is? You can read it online if that's your style.
13:16:19 <apriori> and learn on the go - tough, will result in messy code at first, but inherently keeps the motivation up (sooner or later you want to be done)
13:16:32 <kadoban> statusfailed: The times where you're sitting there watching the output go into the file are pretty rare, so yeah there's not much else to consider but performance.
13:16:39 <vektor> apriori: I did that while reading LYAH alongside.
13:16:40 <Leonid> apriori: yeah, but I'll prefer something that has tipical usage for the language
13:16:58 <Leonid> vektor: my style is more "do to learn"
13:17:02 <apriori> vektor, yeah, I kinda meant it like this. dont stick to "toy programs"
13:17:10 <vektor> Leonid: Project Euler is a common suggestion I guess.
13:17:15 <vektor> Beyond that, do something that interests you.
13:17:26 <ski> rninty : i'd rather some wrapper (`ReaderT')
13:17:26 <apriori> project euler isn't bad, yes
13:17:38 <Leonid> vektor: thanks
13:17:52 <ski> rninty : hrm .. or, i suppose you mean `Alternative b => Alternative (a -> b)' ?
13:17:54 <Guest00000> rninty: you mean Applicative b => a -> b?
13:17:57 <kadoban> Leonid: Use a learning resource that includes exercises. Doing a project in haskell while you don't know haskell is likely to go poorly.
13:18:21 <ski> rninty : in that case, i'm not sure you'd need any extension
13:18:23 <statusfailed> kadoban: I found the opposite actually, but different strokes :-)
13:18:28 <rninty> Guest00000: Alternative b => a -> b, yes
13:18:51 <vektor> Leonid: However, I would really suggest you look at a book or so. Haskell has so many facets, you really should read about at least most of them. In my opinion, reading LYAH and trying to apply your fresh knowledge ASAP is a good first step.
13:19:21 <vektor> Like, read it in order. Skip if you're really bored by it. But most importantly, try to implement other things using the methods from the book.
13:19:32 <kadoban> I don't think LYAH is a good idea at all personally. https://github.com/bitemyapp/learnhaskell has good advice, or http://haskellbook.com/ is a good comprehensive way to go.
13:19:33 <ski> rninty : doesn't `instance Alternative a => Alternative (rho -> a) where empty _ = empty; (f <|> g) r = f r <|> g r' work ?
13:19:49 <Leonid> vektor: I already took a look at the book but it's not enough for me
13:19:59 <vektor> Leonid: what do you mean by not enough?
13:20:09 <apriori> one question about -XUndeciableInstances: does it specifically mean, that only the compiler can go into an infinite loop or is it also possible that while compilation finishes, the program will go in an infinite loop?
13:20:36 <rninty> ski: > The first argument of ‘Alternative’ should have kind ‘OpenKind’, but ‘b’ has kind ‘* -> *’ In the instance declaration for ‘Alternative (a -> b)’
13:20:41 <Leonid> vektor: it's just borring and I feel like I know the ideas from my previous experience
13:21:10 <vektor> Leonid: Maybe the first 3 chapters. Read the chapter on Monads or Applicative Functors and see if you feel the same way.
13:21:11 <ski> apriori : it means the former. the latter is always possible anyway (depending on your code, obviously)
13:21:21 <apriori> I wonder whether my misuse of UndeciableInstances or Overlapping/Overlappable annotations is causing an infinite loop  
13:21:36 <Leonid> vektor: cool, thanks
13:21:45 <ski> apriori : however, iirc there's a (movable) recursion limit when resolving instances that will kick in before
13:21:47 <apriori> ski, so it has to be the 2nd
13:22:19 <apriori> ski, ohm, referring to my last statement
13:22:22 <vektor> Leonid: because those are the points where I really think LYAH does a good job. The easy-peasy syntax elements, you just glance over and maybe look at them again after a while for reference. But Monads or so, that's stuff you really need to learn when you're coming from other languages.
13:23:33 <aaronlevin> i got a cabal question: cabal can't find a specific verison of a package (in my case it's servant-0.5) yet if I run `ghc-pkg list` two versions of that package are present: servant-0.4.5 and servant-0.5. Why is cabal failing to find servant-0.5?
13:23:58 <bitemyapp> aaronlevin: which package database has each version?
13:24:05 <bitemyapp> aaronlevin: the "nearer" package database wins priority
13:24:17 <vektor> Leonid: So yeah. Start some really small project. Learn to use the syntax, learn to use higher order functions. Those should be doable without much reading. If you wanna do something different (IO, GUIs, Debugging), look at Real World Haskell and LYAH and see if they can tutor you. Or look at stack overflow. But you should really consider those books when you're struggling with concepts.
13:24:39 <aaronlevin> bitemyapp: ah, they're definitely in different package databases. is there a way for me to specify a specific package db?
13:25:14 <ski> rninty : .. oh, right. for some reason i was confusing things (kinds). so, i think you do need a wrapper, since you can't express `\a -> rho -> f a' directly
13:25:18 <bitemyapp> aaronlevin: the ghc-pkg list prefaces each list with the package database the list is from.
13:25:26 <bitemyapp> aaronlevin: ghc-pkg list | less
13:25:49 <Leonid> vektor: my concern is to make the things the haskell way and not oop or so
13:25:56 <bitemyapp> aaronlevin: you'll see one reference the global package database from your ghc install (that's where base, transformers, bytestring, etc. will be)
13:26:12 <bitemyapp> aaronlevin: you'll see a user package database after that, should be in ~/.ghc
13:26:35 <ski> rninty : iow, `instance Alternative f => Alternative (\a -> rho -> f a)' isn't possible, but wrapping as `instance Alternative f => Alternative (ReaderT rho f)' is (which should to be a standard instance)
13:26:42 <aaronlevin> bitemyapp: ah, i see. er, strangely, I was wrong. they are in the same package database.
13:26:48 <bitemyapp> I doubt ghc-pkg picks up on sandboxes by default but I could be wrong. Should be possible to `cabal sandbox hc-pkg` it though.
13:26:57 <bitemyapp> aaronlevin: huh.
13:26:58 <rninty> ski: Yeah, so how would one, say, put a restriction on Maybe a’s a where the instance is Alternative Maybe…
13:27:14 <vektor> Leonid: That's totally reasonable. However, you're not gonna be able to harness the abstractions that haskell provides if you don't read up on the more abstract stuff. You *can* go about it by using StackOverflow for help whenever you get stuck with your problem, but you're gonna have a hard time wrapping your head around some of the more abstract stuff.
13:27:16 <bitemyapp> aaronlevin: I've been stack-only for 6+ months now, so these problems a bit alien to me now.
13:27:27 <bitemyapp> aaronlevin: pre-stack, I used sandboxes-only.
13:27:38 <bitemyapp> aaronlevin: are you leaning on a user package database or are you using sandboxes for your projects?
13:27:50 <aaronlevin> I'm on NixOS so it's user package databases.
13:27:54 <aaronlevin> (I think)
13:27:57 <vektor> bitemyapp: Guess who only recently set up his first sandbox after 2 years of haskell and has never even touched stack?
13:27:57 <rninty> Anyway, I’ll look at ReaderT, thanks
13:28:10 <bitemyapp> aaronlevin: oh lord, NixOS means I'm right out. I have no idea what they do to the package database.
13:28:12 <ski> rninty : i'm not sure what you mean by "put a restriction on Maybe a’s a where the instance is Alternative Maybe"
13:28:25 <bitemyapp> aaronlevin: recommend talking to the Nix Haskell people if you can't get someone more up on Cabal to help you.
13:28:46 <bitemyapp> vektor: do I know you?
13:28:50 <Leonid> vektor: thanks
13:29:01 <aaronlevin> bitemyapp: good call. i'll ask in #nixos. thanks.
13:29:12 <bitemyapp> aaronlevin: entirely possible Nix has nothing to do with it, but I've seen your problem before
13:29:27 <bitemyapp> aaronlevin: but the fix I recall was: "nuke user package database, use a sandbox", nothing about Nix.
13:29:41 <vektor> bitemyapp: Naw. I was just pointing out, either I'm doing hackage management wrong, or Stack and sandboxes are overengineered. I haven't had much need for either yet.
13:29:52 <apriori> ok .. segmentation fault by a haskell program - that is new.
13:30:03 <vektor> apriori: What did you do?!
13:30:07 <bitemyapp> vektor: I install a lot of stuff, work on a lot of projects (including other peoples'), and help a lot of people in getting stuff building
13:30:16 <apriori> apriori, ohm.. nothing special?
13:30:16 <semigrou-pyon> I'm trying to understand type roles, and stumbled upon the paper "Generative Type Abstraction and Type-level Computation" - is this the basis of how type roles work?
13:30:30 <bitemyapp> vektor: so the surface area I deal with is a bit bigger than somebody kicking around a few pet projects on their private bitbucket.
13:30:32 <apriori> just writing some word32 in a file (binary)
13:30:38 <fr33domlover> Q: What is the best way to combine strict Text values, like you'd use Text.Printf for Strings?
13:30:42 <bitemyapp> vektor: accordingly, I run into breakages at a higher rate than most people
13:30:43 <vektor> bitemyapp: I guess :D
13:30:45 <apriori> vektor, nothing special
13:31:05 <bitemyapp> I'm useful if you need something to break tho
13:31:08 <bitemyapp> very good at that
13:31:22 <Leonid>  
13:31:27 <Leonid> oops
13:31:30 <ski> rninty : if you're want `a' in `empty :: Alternative f => rho -> f a' and `(<|>) :: Alternative f => (rho -> f a) -> (rho -> f a) -> (rho -> f a)', then i think that isn't possible with `Alternative', it requiring that the operations has to work for any type `a' (of kind `*') that you pass to the type function
13:31:35 <bitemyapp> aaronlevin: the reason I threw my hands up is I'm not sure "delete user package db, use a sandbox" is appropriate with Nix or even makes sense.
13:31:39 <koomi> apriori: can you show us the code?
13:31:41 <ski> s/want/wanting/
13:31:47 <vektor> bitemyapp: That wasn't meant in a hostile way. I was not trying to say that there's anything wrong with using those tools, and I presume they do have their place.
13:31:54 <apriori> koomi, its a bit much
13:32:04 <apriori> koomi, trying to narrow down first
13:32:10 <bitemyapp> vektor: me either. no dramas.
13:32:23 <koomi> apriori: ok :-)
13:32:36 <bitemyapp> vektor: I know these tools worked at least some of the time before sandboxes and stack existed because I used them before sandboxes and stack existed.
13:32:55 <ski> rninty : one alternative is to look into something similar to the "restricted functor/monad" stuff. another potential possibility is to use a GADT that "internally" will enforce that you can only use `a's that satisfy whatever additional constraint you'd prefer to have
13:33:08 <bitemyapp> vektor: I also know from first-hand experience that if you aren't keeping all the projects you work on within a range of version dependencies that it gets brittle/force-reinstalls-y in a hurry.
13:33:30 * hackagebot splot 0.3.13 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  https://hackage.haskell.org/package/splot-0.3.13 (EugeneKirpichov)
13:33:33 <kadoban> Before I figured out sandboxes … I just had to nuke my user package database semi-weekly and install again. Which was super fun.
13:33:34 <bitemyapp> vektor: It doesn't help me to know there's one more datapoint that says, "yep works 4 me" when I've already spent hundreds of hours helping people deal with problems related to those tools.
13:33:40 <vektor> bitemyapp: Heh. I mean, I'm kinda shying away from diving into either of those. I'm not even really using cabal to build my pet project (on github though :P ) until recently when I had to get profiling builds of the deps.
13:33:46 <bitemyapp> vektor: I will never get those hours back.
13:33:48 <kadoban> And stack is just a better version of that, much easier to deal with and less annoying.
13:33:53 <bitemyapp> vektor: they are lost because people were too complacent with their tools.
13:34:26 <bitemyapp> now if you've invented a time machine
13:34:27 <ski> rninty : e.g., if you wanted to enforce `Ord', then you could use `data WithOrd a where WO :: Ord a => a -> WithOrd a' (possibly you can also use the syntax `data WithOrd a = Ord a => WO a' to define it)
13:34:33 <bitemyapp> so I can go back and bring Stack to 2012 or 2013
13:34:38 <bitemyapp> that's useful. That'll help me.
13:34:50 <bitemyapp> that I am p interested in
13:35:03 <rninty> ski: Okay. Thank you.
13:35:38 <vektor> bitemyapp: So if I wanted to get my shit together, where do I start? Stack? Sandboxes? Do I even need sandboxes?
13:36:44 <ski> rninty : each value of type `WithOrd a' will carry around, besides a value of type `a', also a constraint dictionary for `Ord a', despite a use of `WithOrd a' in a type not having to mention the constraint `Ord a' -- you've baked the constraint into the type `WithOrd a'
13:37:00 <bitemyapp> vektor: if your stuff works as well as you say, why change anything?
13:37:02 <kadoban> vektor: stack. It's pretty easy to learn and fixes problems that cabal-install doesn't have a good answer to even if you use sandboxes dilligently.
13:37:19 <kadoban> But also that ^ I suppose.
13:37:30 <bitemyapp> vektor: but if you are going to change, might as well leap to Stack. Streets ahead.
13:37:31 * frerich heard cabal copied^Wgot inspired by some interesting Nix stuff recently
13:37:34 <bitemyapp> so, what kadoban said :P
13:38:06 <bitemyapp> frerich: considering I tried and failed 5 times to build a simple Haskell project w/ Nix, with expert assistance, that's not really going in my "plus" column.
13:38:07 <vektor> Only problem I ever had in that regard was that I had trouble installing ghc-mod. Some build failure. I went for the github version instead and that worked. Took me a while to figure out,
13:38:35 <bitemyapp> and when I say 5 times, I mean 5+ hours per attempt.
13:39:02 <kadoban> vektor: For a while ghc-mod was just broken with GHC 7.10 I believe. It took longer than usual to get updated for that.
13:39:19 <frerich> bitemyapp: I'd say that if you can't get a simple Haskell project to build in 5*5 hours even with "expert assitance" then you have a whole bunch of columns to put a 'minus' into.
13:39:22 <vektor> kadoban: That was this summer-fall iirc. Does that line up?
13:39:32 <kadoban> vektor: I think so
13:40:06 <bitemyapp> frerich: again, with Nix expert assistance. One of those times I got NixOS into this weird broken/stuck state.
13:40:22 <bitemyapp> whereas I'd never gotten Debian or Ubuntu into that bad of a way. Never ever.
13:46:16 <frerich> bitemyapp: Of course, every inexplicable problem is caused by something you don't think is the cause. And more you know, the more you know. These pearls of wisdom were brought to you by monochrom via https://www.vex.net/~trebla/humour/tautologies.html
13:46:18 <apriori> koomi, narrow down a bit, code didnt get reduced all that much, though - still interested? :)
13:46:28 <koomi> yes!
13:46:30 <monochrom> :)
13:46:40 <apriori> koomi, k, ty, wait a sec
13:47:41 <bitemyapp> frerich: 4rlz tho, monochrom's website is a treasure trove.
13:49:30 <frerich> bitemyapp: Right, and if you squint there's something in there about 'expert assistance', too ;->
13:50:47 <monochrom> but I only know and wrote about cabal. I don't know nix or stack.
13:54:30 <johnw> I could help with nix, but on #nixos preferably
13:58:39 <frerich> monochrom: Maybe there's a #12 in that: "If you squint hard enough, anything looks like anything."
13:59:03 <johnw> no squinting needed in that case; anything is in fact anything
13:59:17 * ski . o O ( "44  It is illogical to reason thus, 'I am richer than you, therefore I am superior to you', 'I am more eloquent than you, therefore I am superior to you.' It is more logical to reason, 'I am richer than you, therefore my property is superior to yours', 'I am more eloquent than you, therefore my speech is superior to yours.' You are something more than property or speech." )
13:59:28 * ski . o O ( -- "The Enchiridion" (aka "The Manual/Handbook (of life)") by Epiktetos in around 55 - 135 AD at <http://www.sacred-texts.com/cla/dep/dep102.htm> )
14:00:49 <frerich> johnw: My version was up to 100% accurate.
14:01:52 <frerich> AKA "I handled all the cases after ignoring unhandled cases."
14:34:58 <apriori> koomi, reduction done https://gist.github.com/apriori/6f1ec6deeee7b6468b6a
14:35:26 <apriori> so for whatever reason, V.concat [ bla ] causes a segfault, while just "bla" works
14:35:51 <apriori> further weirdness: when trying to hand evaluate "encodeWord32Vect msrc" (bla) in ghci, it never terminates
14:41:53 <koomi> apriori: how long does it take to segfault?
14:42:02 <apriori> koomi, unnoticable short
14:42:12 <apriori> like, immediately
14:42:33 <koomi> which ghc and library versions?
14:43:16 <apriori> koomi, look at the gist comment, please
14:43:41 <apriori> I'm using exactly the min versions
14:43:48 <apriori> (but base)
14:43:53 <koomi> ok, hangs on 7.10.1 :-(
14:44:15 <apriori> hangs and doesnt segfault? interesting
14:44:21 <koomi> yep
14:44:42 <apriori> so in general termination has to be the problem here
14:44:45 <apriori> but I don't get why
14:44:55 <apriori> for this type: data FullModule repr = FullModule (Maybe (repr OpSource))
14:45:28 <apriori> if I use e.g. encodeWord32Vect $ Just (opSource ... :: Instr OpSource)
14:45:30 <apriori> that does work
14:45:43 <apriori> but for whatever reason packed in FullModule it doesn't
14:49:56 * koomi tries to build with the same library versions, but it takes a while
14:50:07 <apriori> koomi, ty very much
14:50:24 <apriori> I am stuck on that issue for a while now
14:52:27 <apriori> I bet it has to do with the overlapping pragmas..
14:53:59 <koomi> seems likely
14:58:44 <koomi> so now I built it with 7.10.2 and same library versions and it still just hangs...
14:59:11 <apriori> the segmentation error might be specific to my ghc build, who knows
15:09:55 <apriori> koomi, so, the issue is the following instance: 
15:09:59 <apriori> instance (Word32VectEncode a) => Word32VectEncode (repr a) where
15:10:05 <apriori> incombination with:
15:10:17 <apriori> instance {-# OVERLAPPABLE #-} (OpCodeClass a) => Word32VectEncode a where
15:10:53 <apriori> if I get rid of the 1st one, and extend the 2nd one to this:
15:10:58 <apriori> instance {-# OVERLAPPABLE #-} (OpCodeClass a) => Word32VectEncode (repr a) where
15:11:01 <apriori> the code does work
15:12:32 <Black0range> Hey! Could someone explain to me why haskell doesn't have any kind of string typeclass? (common string operations for Strings / ByteString / Text  etc) Or have i missed something?
15:13:08 <Sonarpulse> Black0range: check out mono-traversable
15:15:43 <ReinH> Black0range: what sort of common string operations?
15:16:55 <Black0range> Like spit, take, findIndex
15:18:43 <kadoban> Black0range: Sounds like monotraversible. Or you can just use the ones specific to whatever container.
15:19:05 <koomi> apriori: how is the original (repr a) instance supposed to work? It seems like an infinite loop to me
15:19:25 <koomi> line 157
15:20:10 <Black0range> kadoban: yeah but using something for a specific container restrains that function to a specific container
15:21:12 <kadoban> Black0range: Yes, but the cases where you want to abstract over all of those are pretty rare I would think.
15:21:38 <kadoban> At least I don't feel the need ever that I can recall.
15:22:00 <apriori> koomi, hum
15:22:11 <apriori> yup, that was foolish :(
15:22:12 <Black0range> any kind of text data -> data parsers?
15:22:32 <Black0range> thats a pretty huge area 
15:22:50 <kadoban> Black0range: Well, if you're implementing one, sounds possible. Can't say I've done that.
15:23:05 <apriori> koomi, earlier, before a refactor, there was something like "encodeWord32Vect . unliftRepr"
15:23:21 <apriori> koomi, sry, dude, I really retarded mistake
15:23:38 <apriori> *a
15:25:40 <pharaun> is there pre-existing works for "trees of chans" ?
15:25:53 <koomi> apriori: :-)
15:26:07 <koomi> was that the original problem or did you introduce it while reducing the crash?
15:26:30 <Black0range> Sonarpulse, kadoban mono-treversable seems to be it! thanks guys :)
15:26:57 <apriori> koomi, nope, it was the original problem :(
15:27:02 <apriori> result of a refactoring
15:27:13 <koomi> hehe ok
15:27:25 <koomi> still interesting that it resulted in a segfault
15:27:32 <apriori> yeah
15:27:48 <pharaun> ie various stuff puts data into their own chan which gets collected up by a parent chan, which then gets collected up by parent's parent's chan?
15:28:25 <pharaun> (mostly cos i want to be able to throttle a child's chan without affecting the parent's), just wondering if there was pre-existing works, i didn't really find any, poked around in frp a bit
15:28:29 <pharaun> but it doesn't seem quite right
15:39:14 * frerich wishes StackOverflow would embed mueval such that I could enter pure Haskell expressions and see the resulting output much like what's possible for JavaScript already...
16:06:13 <fluffykeyboardfu> Hello.  I can see "tidal" hackage, but `cabal install tidal` says there is no package named that.  I run `cabal update` and it says it's skipping download because the local and remote files match.  Why does this happen?
16:07:59 <fluffykeyboardfu> Ah, it seems like the 00-index.cache file got truncated.
17:52:40 <maerwald> mh, hlint doesn't seem to be able to handle viewpatterns
18:11:13 <hsloan> sweet
18:21:23 <maerwald> is it?
18:29:50 <tryam> Hi!
18:30:35 <tryam> I've been reding a testing chapter in Real World Haskell. They suggest to use QuickCheck.Batch, but looks like it's absent in recent versions of QC. What do people use now in replacement?
18:44:14 <Clint> tryam: RWH is painfully out of date
18:44:41 <tryam> Clint, what would you recommend instead?
18:44:48 <tryam> any rumors of a new edition?
18:45:05 <Clint> tryam: https://github.com/bitemyapp/learnhaskell gets recommended a lot here lately, though i haven't read it
18:45:30 <tryam> I'll look at that one, thanks
18:45:33 <Clint> and people used to recommend lyah
18:45:35 <Clint> @where lyah
18:45:35 <lambdabot> http://www.learnyouahaskell.com/
18:45:45 <tryam> well, that's a bit too basic for me
18:45:55 <tryam> I mean, LYAH
18:45:56 <Clint> there's pretty much no chance of an RWH update
18:46:15 <tryam> are the authors too busy in their current projects?
18:46:28 <Clint> something like that
18:46:47 <Clint> and at least one of them thinks that someone else should rewrite it or so
18:47:06 <tryam> The favourite thing I learned on Haskell was Typeclassopedia, but sometimes you need something more down-to-earth
18:48:03 <Clint> you might be better off reading docs for tasty or hspec
18:48:47 <tryam> and it doesn't seem like bitemyapp/learnhaskell has anything about quickcheck
18:49:57 <Clint> tryam: http://documentup.com/feuerbach/tasty
18:50:31 <tryam> That looks like what I'm looking for!
18:50:52 <tryam> Thanks Clint!
18:51:02 <Clint> have fun
19:37:56 <Welkin> what is the easiest way to format a floating point value?
19:38:07 <Welkin> printf throws exceptions at runtime which is not okay
19:38:32 <Welkin> I just want to display it with a precision of 2 and the sign (+ or -)
19:39:35 <orb_> Welkin: you can't catch the exceptions (even inside an unsafePerformIO) and wrap it all up nicely?
19:39:45 <Welkin> orb_: I don't want to deal with any exceptions
19:39:50 <Clint> showFFloat?
19:39:56 <tnecniv> any of you cats mess with the JuicyPixels image stuff or any image saving library?
19:41:09 <Welkin> the only way I can see to avoid exceptions is to show the value, then manipulate the resulting string
19:41:16 <orb_> I've messed with Codec.Picture.
19:41:46 <orb_> Oh, that's in JuicyPixels.
19:41:49 <tnecniv> orb_ i'm a little confused as to how i am supposed to actually create the image
19:41:51 <tnecniv> yeah
19:41:52 <orb_> Yeah, that was easy.
19:42:00 <tnecniv> it seems like I need to make a mutable image?
19:42:10 <tnecniv> but it doesnt say how i get to assign pixel values?
19:42:25 <Welkin> Clint: I'll try showFFloat
19:42:27 <Welkin> thanks
19:42:54 <orb_> tnecniv: see http://paquari.com/Sorting.hs
19:44:24 <tnecniv> orb_ thanks
19:44:32 <orb_> Which produces pictures of various sorting algorithms like quicksort: http://paquari.com/qsort2000.png
19:45:03 <orb_> (Black on coordinates (x, y) means: element x got compared to element y in the list to sort.)
19:45:22 <orb_> The long vertical lines are the pivots elements that get compared to a lot of other elements.
19:46:43 <tnecniv> oh i see
19:46:46 <tnecniv> thanks orb_ !
19:47:21 <orb_> Please post, if you produce anything interesting.
19:47:34 <tryam> Cool!
19:47:49 <orb_> My pictures are inspired by http://corte.si/posts/code/visualisingsorting/
19:48:32 <orb_> "Static visualization of sorting algorithms".  That post's pictures weren't static enough for my tastes (and only work for in-place sorting), so I produced something even static-er.
19:49:21 <tnecniv> looks cool
19:49:26 <tnecniv> i'm working on a simple raytracer
19:49:52 <tnecniv> emphasis on simple because that's a project you can fall down some dark holes on with lighting models, monte carlo methods, etc
19:56:04 <thecontrarian42> has anyone here done any elm?
19:59:14 <cdepillabout> thecontrarian42, I've done a little bit of elm.
20:00:14 <thecontrarian42> cool. i'm trying to make a nested dropdown component and i'm getting tripped up with the recursion
20:01:21 <tnecniv> question: why do types declared using the type keyword not get a renamed constructor
20:01:51 <tnecniv> i.e. i have data Vec = Vec Float Float Float and type Color = Vec. Color 1 1 1 is not valid
20:02:04 <Welkin> Clint: showGFloatAlt works perfectly
20:03:06 <thecontrarian42> cdepillabout how would you type the action so that it contains the sequence of id's you have to traverse down the tree to get to the right component?
20:03:07 <nshepperd> tnecniv: type and constructor names are completely separate. Having the type named the same as the constructor is only convention
20:03:21 <Clint> Welkin: great
20:03:24 <tnecniv> I see
20:05:46 <bernalex> anyone happen to know bncf? why is CnameDecl. Cname ::= Id | Type ; not legal?
20:06:04 <bernalex> alternatively, how do you do "this or that production"?
20:06:15 <bernalex> s/cf/fc/
20:15:33 <pavolzetor> do you know if there is some tutorial on haskell and geometry processing, graphics?
20:21:41 <pavolzetor> the other problem I have is trying to solve bicubic patch
20:21:47 <pavolzetor> it has 16 vertices
20:22:03 <pavolzetor> for the first part I can create 4 slices of 4 vertices
20:22:07 <pavolzetor> and then solve those
20:22:17 <pavolzetor> but I am not sure what to do for the v direction
20:22:33 <pavolzetor> currently I am reshuffling the vector, but that seems not optimal
20:23:08 <geekosaur> bernalex, the official specification is a bit much for me this late in my evening but it looks to me like you use multiple rules with _ as a "continuation" label?
20:23:22 <bernalex> geekosaur: yeah looks like something like that
20:24:35 <pavolzetor> this is the code
20:24:36 <pavolzetor> http://lpaste.net/147762
20:24:56 <bernalex> geekosaur: right now I'm working on qualified constants and how on earth to make it understand that those can be a Type. ugh. :]
20:32:38 <qolen> Can anyone point me in the right direction for making GHC extensions? Like, tutorials or something for how to get started?
20:32:54 <qolen> where to download the source code even, if that's the right place to start
20:32:59 <qolen> I'm having trouble finding any resources online
20:34:22 <bernalex> qolen: typically just looking at some similar-to-what-you-want extensions that are already implemented is useful.
20:37:47 <qolen> bernalex: where would I find the implementation of extensions?
20:37:54 <bernalex> qolen: ... in ghc?
20:38:17 <qolen> So I should look in the source.
20:38:24 <qolen> is github.com/ghc/ghc the right place?
20:38:25 <bernalex> qolen: that would be my advice, yes.
20:38:37 <bernalex> qolen: that's a mirror of the GHC source. it should be up to date.
20:38:59 <qolen> bernalex: Okay. I was just surprised, because there's usually other places to learn *about* modding something
20:39:34 <bernalex> qolen: GHC can be extended in a lot of ways, so without providing any more information about what you want to do, it's difficult to tell you anything very useful.
20:42:32 <qolen> bernalex: I want to add a fairly simple syntax to do-notation, which is basically a pre-processor/macro whatever the right term is
20:42:49 <qolen> bernalex: I obviously don't have very much experience with this, so I'm not sure how complicated it actually is
20:42:54 <bernalex> qolen: you want to extend do-notation? for monads or applicatives?
20:43:10 <qolen> monads
20:43:11 <qolen> I think
20:43:26 <bernalex> qolen: or, uh, what I mean is, you just want to add some further syntax sugar?
20:43:31 <qolen> yes
20:43:33 <qolen> exactly
20:45:09 <bernalex> qolen: well that's likely going to be non-trivial. I suggest you ask in #ghc about what things you need to look into. at the very least I imagine you need to do work on the parser, depending on how complicated your sugar is.
20:45:28 <qolen> I want to add a syntax where I can put some character (for now I'm thinking '!') before an expression, and (for example) `!expr1 + !expr2` will be syntactic sugar for `v1 <- expr1 \n v2 <- expr2 \n v1 + v2
20:45:54 <qolen> such that `!` acts like a dereferencing operator in the context of do notation
20:46:14 <qolen> I should ask on #ghc. Okay. Thanks so much!
20:47:28 <bernalex> qolen: right. there's been lots of thought put into things like these. check out http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf which proposes something similar in a bracket notation.
20:47:46 <qolen> I figured it had to have been tried before
20:48:19 <bernalex> qolen: they are usually called "idiom brackets". I have however seen suggestions that are bracketless, like yours, too.
20:48:54 <qolen> hm. I will definitely look into that
20:48:56 <bernalex> qolen: in general you'll find some resistance as most people prefer an applicative syntax anyway.
20:49:02 <qolen> do you know if an extension has actually been made?
20:49:07 <bernalex> qolen: but if you're willing to do the work, you'd probably get it through anyway.
20:49:14 <bernalex> qolen: I don't think there has ever been finished one.
20:49:19 * hackagebot handa-opengl 0.1.12.1 - Utility functions for OpenGL and GLUT  https://hackage.haskell.org/package/handa-opengl-0.1.12.1 (BrianBush)
20:49:21 <qolen> okay
20:49:21 * hackagebot opengl-spacenavigator 0.1.5.4 - Library and example for using a SpaceNavigator-compatible 3-D mouse with OpenGL  https://hackage.haskell.org/package/opengl-spacenavigator-0.1.5.4 (BrianBush)
20:49:24 <qolen> so maybe I will try it
20:49:42 <qolen> my rationalle for wanting this is that I want the operators to look like they would normally, but acting on lifted values
20:49:44 <bernalex> qolen: if you ask ocharles__, he might have some insight to offer. see https://ocharles.org.uk/IdiomBrackets.html
20:50:17 <qolen> i think it is awkward to switch notations because you're working with monadic values. given that part of the point of monads is to avoid that
20:50:22 <bernalex> qolen: haskellers in general don't like implicit things. they'd rather write five extra chars than suffer a GOTCHA when changing the code a year later.
20:50:36 <qolen> what do you mean implicit?
20:50:43 <qolen> i.e., how is this implicit?
20:50:53 <qolen> it seems to be pretty direct syntactic sugar to me
20:51:22 <bernalex> qolen: I appreciate that the specific idea you are suggesting is actually explicit, but it is less verbose than using <- or bind, so a lot of people will likely prefer the more verbose version.
20:51:35 <bernalex> in general I'm not opposed to suggestions like these myself though.
20:51:42 <qolen> gotcha
20:52:00 <qolen> well I'll look into related ideas. I'm glad i thought to ask here
20:52:25 <bernalex> you'll probably want to search around for idiom brackets. those guys have no doubt considered other alternatives too.
20:52:40 <bernalex> ollie might answer if you stick around, but he's on UK time.
20:53:37 <qolen> :D thanks! It's refreshing to have someone that even understands what I mean
20:54:44 <bernalex> I'm probably not the best guy to ask. it's been a year since I worked on a GHC extension. and I abandoned it because of a lack of time. I should get back to it...  I did send a patch to GHC today, so I'm kind of getting going again.
20:56:19 <qolen> It's super intimidating to me, but I think it's worth it
21:04:24 <qolen> bernalex: It strikes me that idiom brackets actually have quite a bit of ambiguity. Like, there are multiple logical ways to implement them that give different effects
21:04:55 <bernalex> qolen: I'm not sure what you mean. part of implementing them is formulating the operational semantics.
21:05:04 <bernalex> everything is ambiguous pre-definition.
21:06:57 <qolen> right right
21:07:05 <qolen> but there isn't one obvious, intuitive answer
21:07:09 <qolen> which is likely to lead to mistakes
21:07:25 <qolen> because people will  assume something else happens
21:07:44 <bernalex> I seem to recall the applicative paper brackets being ok, but it's been a while since I've read it.
21:07:48 <qolen> I mean. that's worst case scenario. More likely is that people have to look up the semantics every time they use it
21:08:02 <qolen> I'll keep looking into it
21:08:30 <qolen> i was talking about the ocharles site
21:09:20 * hackagebot modify-fasta 0.8.0.3 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.0.3 (GregorySchwartz)
21:10:18 <johnw> I've used idiom brackets in other languages, they can be rather convenient
21:24:22 * hackagebot stack-run 0.1.0.0 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.0 (yamadapc)
21:24:24 * hackagebot modify-fasta 0.8.0.4 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.0.4 (GregorySchwartz)
21:53:50 <dmwit> qolen: I also want this feature, and I want to not even have to write !.
21:55:19 <dmwit> I'd love to see a port of "Lightweight Monadic Programming in ML" to Haskell. I tried to do one once -- with the help of some really smart folks at UPenn -- and we found it more subtle than I would have thought, though.
22:08:35 <tnecniv> how does one typically debug a haskell program?
22:09:05 <dmwit> ghci has a debugger which I have never managed to get the hang of.
22:09:20 <dmwit> For pure things, run tests by hand on larger and larger sub-functions.
22:09:28 <dmwit> For impure things, I've used printf-debugging with some success.
22:09:43 <dmwit> I know that these answers are incredibly low-tech compared to other languages...
22:09:43 <tnecniv> k
22:09:51 <dmwit> I wish I knew a really convincing story here.
22:16:31 <kadoban> I've done a decent amount and between just automated testing things and using Debug.Trace (or more traditional logging for imperative code), it's been more than enough really.
22:17:27 <pharaun> and honestly for the large majority of the languages out there (outside of couple really well done one (java/c#/etc) the story is somewhat the same
22:17:32 <pharaun> tests, logs, tracing
22:17:49 <pharaun> there's gdb for C and etc i suppose but most devs don't touch it
22:17:54 <kadoban> Even in languages with "good" debuggers … gah they're terrible anyway.
22:18:28 <kadoban> Yeah, gdb is a horrible horrible thing. Many pros even in that context don't use it at all, or use it rarely.
22:18:39 <dmwit> I've gotten quite some mileage out of gdb and pdb when working with the languages those handle.
22:18:40 <pharaun> well, i recently got to try java and it impressed me, i was able to attach to a remote process, then change the variable and re-run and push updated code to the jvm
22:18:43 <pharaun> and rerun
22:18:47 <dmwit> So I don't know what you guys are on about.
22:18:51 <dmwit> clewn is a thing of magic
22:18:59 <pharaun> so i thought it worked pretty well (the jvm debug bits)
22:19:08 <tnecniv> really?
22:19:11 <tnecniv> i love my debugger
22:19:13 <pharaun> not familiar enough with gdb/gdb enabled languages to really say
22:19:40 <tnecniv> gdb / java / C#
22:19:42 <pharaun> work is python and the large majority of the debugging done at work is via print
22:20:39 <dmwit> Different strokes and all that. All I can say is pdb has been pretty good to me at several critical moments.
22:20:43 <pharaun> even tho i think there is some python support for gdb for that stuff but its awkward on our environment so yeah and no one is going to be allowed on prod to attach a gdb thing to a python thing (amusingly enough we do this with java)
22:20:50 <pharaun> dmwit: oh fair enough
22:21:05 <pharaun> just saying that i don't know enough about gdb to judge :)
22:21:19 <pharaun> i guess python has ipdb/etc but you can't exactly attach to a running process
22:21:45 <pharaun> dmwit: can you attach to a running process with gdb?
22:22:01 <lispy> yes
22:22:04 <pharaun> nice
22:22:11 <pharaun> i'll have to sit down and learn it someday
22:22:32 <pharaun> on that front, isn't haskell supporting (already or will be) the um dwarf symbol whatever stuff
22:22:37 <pharaun> to make gdb bits work?
22:22:50 <lispy> a process can also implement a remote debug protocol and use gdb that way. qemu does this so that the emulated program can be debugged with gdb
22:22:57 <bernalex> anyone know bnf and want to tell me why my grammar bails out on "foo<bar>"? :]
22:23:06 <pharaun> ah right, i recall hearing about gdb and qemu
22:23:13 <lispy> bernalex: bnf as in bnfc?
22:23:16 <dmwit> pharaun: I think some dwarf support is planned, yeah.
22:23:32 <dmwit> I'll be interested to see how well that works.
22:23:33 <bernalex> lispy: bnf as in bnf, but I am using bnfc, yes.
22:23:52 <pharaun> dmwit: sweet, guess i'll have to poke at that when it comes out if its not already out
22:24:09 <dmwit> pharaun: As for attaching to running processes -- I've attached to processes running on other machines with other architectures...
22:24:39 <dmwit> (debugging a mobile app from my work laptop. was quite a confusing adventure)
22:24:53 <pharaun> hah
22:24:56 <lispy> the biggest drawback to gdb is that they focus on applications. It's unsupported for osdev (but can be used if you know how to work around the rough edges)
22:25:30 <pharaun> not really aware of any osdev specific debugger
22:25:31 <lispy> (alternatively, I probably could have called that the biggest advantage?)
22:25:39 <pharaun> kernel did some bits re usb/firewire
22:25:45 <pharaun> for debugging/other stuff but idk how that work
22:26:13 <pharaun> (i just recall seeing it when i was config a kernel)
22:26:39 <lispy> bernalex: what should "foo<bar>" mean? I just glanced at the bnfc docs and I don't think that's valid in their syntax
22:26:58 <bernalex> lispy: I mean foo<bar> in the language not in the grammar
22:27:13 <dmwit> ?justask
22:27:14 <lambdabot> Unknown command, try @list
22:27:16 <dmwit> ?where justask
22:27:16 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
22:28:02 <bernalex> lispy: I have Gen. Type ::= Type "<" Type ">" ; and then Tref. Type ::= Id; so I really don't see why it wouldn't work.
22:29:17 <dmwit> What is the rule for Type? Id?
22:29:18 <bernalex> additionally, EType. Exp15 ::= Type ; SExp. Stm ::= Exp ";" ;
22:30:07 <dmwit> Oh, are `Gen.` and `Tref.` special? Okay, I'll be quiet.
22:30:09 <bernalex> dmwit: what do you mean by the rule for Type? there are three Types, Builtin, Qual, and Gen. Gen is in the post.
22:30:26 <lispy> dmwit: those name the data constructors: http://bnfc.digitalgrammars.com/LBNF-report.pdf
22:30:27 <bernalex> as for Id, it's standard, token Id (letter (letter | digit | '_')*) ;
22:30:35 <bernalex> dmwit: Tref and Gen are Types.
22:30:39 <dmwit> Sorry, I'm trying to be helpful but don't actually know bnfc's syntax, so I made some educated (and clearly wrong) guesses.
22:30:58 <bernalex> dmwit: bnfc is a program. the language is called bnf.
22:31:20 <bernalex> bnfc is just a program that takes a bnf grammar and gives you a parser.
22:31:33 <wowdog> Hi, does anyone know who to import all the library in Prelude since everyone I use a function, I have to manually import the Library, sometimes I have to goto Google to figure out what libraries that function belong to
22:31:41 <bernalex> well, I say "just", but I find it rather impressive. especially that it can give you the parser in multiple lanugages.
22:32:10 <bernalex> wowdog: I don't really understand your question, but Prelude is by definition automatically imported.
22:32:19 <paraseba> Why is Data.Array not a Monad?
22:32:29 <dmwit> bernalex: bnf is overloaded a bit. I know the acronym as a broad thing, and have seen other concrete syntaxes for it.
22:33:21 <dmwit> paraseba: Try implementing an instance. I bet something will go wrong pretty quick, but even if I'm wrong I bet you will have a hard time proving the laws hold for your definition.
22:33:30 <wowdog> at least not on my Prelude. e.g when i use splitOn, it said splitOn is not in scope
22:33:49 <bernalex> dmwit: bnf is a notation for context-free grammars. there is ebnf and abnf, and people often use "simplified bnf", but bnf is very precise. I do not know what overloading you are referring to; I have not seen it in any compiler literature.
22:33:54 <dmwit> (Specifically: I bet `return` and/or `(>>=)` will need a constraint on indices that `Monad` precludes you from adding.)
22:34:22 <lispy> cf. Monad instance for Set
22:34:25 <bernalex> wowdog: that's because splitOn isn't in Prelude.-
22:34:52 <wowdog> how can I use splitOn Prelude?
22:35:00 <dmwit> bernalex: I've seen it in several informal places, e.g. man pages for various tools and emails.
22:35:06 <bernalex> wowdog: splitOn is not in Prelude so that doesn't make any sense.
22:35:19 <dmwit> bernalex: Anyway it doesn't matter. I was clearly wrong and I apologize for that.
22:36:12 <lispy> bernalex: the semantics of bnf are pretty clear, but the notation people use in the literate and in courses varies.
22:36:20 <lispy> literature*
22:36:58 <paraseba> dmwit: return would be creating a singleton Array, and >>= would map creating multiple arrays and then it would concatenate all the results into a bigger one.
22:37:21 <paraseba> dmwit: I'll definitely try, but I don't have an intuition of why it wouldn't work. Both Lists and Vectors are in fact Monads
22:37:43 <dmwit> paraseba: I suspect the problem will be with the law `return x >>= f = f x`.
22:38:03 <dmwit> paraseba: For that rule to hold, `>>=` will have to choose the indices of its result based on the results of calling `f`.
22:38:23 <dmwit> paraseba: Which seems strange and potentially impossible to me, as ecah call to `f` may choose wildly different bounds on its arrays.
22:39:37 <dmwit> paraseba: And, conversely, `m >>= return = m` implies that `>>=` will have to choose its indices based on its first argument. These two requirements seem like a ripe source of contradictions to me.
22:39:41 <lispy> bernalex: is Gen the start production in your grammar? I'm wondering the parser expects something after the '>' like maybe a ';'?
22:40:21 <bernalex> lispy: since Gen is a Type and there is an EType making Type an Exp, and finally a SExp which is Exp ";", it should work, I would hope.
22:40:31 <bernalex> lispy: oh, right, I forgot to say that the line is "foo<bar>;"
22:40:43 <wowdog> hi, anyone know how to check whether I install the some libraries?
22:40:51 <bernalex> lispy: the error says "syntax error at ..... before `>'"
22:40:57 <dmwit> paraseba: `[]` and `Vector` deal with this by always choosing their bounds to be `Integer` and starting at `0`. Which seems restrictive compared to the wild abandon that `Array` lets you get away with.
22:41:26 <bernalex> wowdog: what is your native language? it might prove helpful for you if you go to a national channel.
22:41:30 <dmwit> wowdog: `ghc-pkg list` will show you all the packages that GHC knows about.
22:41:34 <lispy> bernalex: have you checked the token stream to make sure it's what you expect?
22:41:52 <paraseba> dmwit: hum, I see, I was thinking size as the only restriction, but that's right, indexes are much more general than 0..N. Thank you
22:41:56 <dmwit> wowdog: If you are using a cabal sandbox, or using stack, you will need to execute that command in an appropriate environment for those tools.
22:42:21 <bernalex> lispy: it's kind of big, but it recognises foo and bar as Ids, and Id can be a Type, so Type<Type> should fire... I thought.
22:43:29 <bernalex> lispy: yeah they're both T_Id. and since Tref. Type ::= Id;, they should be Types, so Gen. Type ::= Type "<" Type ">" Type should fire. I would think.
22:44:25 <lispy> bernalex: We must be missing something "obvious" then
22:44:34 <bernalex> hah
22:44:36 <bernalex> interesting
22:44:38 <bernalex>     int<int>;
22:44:40 <bernalex> that worked fine
22:44:57 <bernalex> so foo and bar are obviously not turned from Id into Type
22:45:12 <bernalex> int is a type via Tint. BuiltinType ::= "int" ;
22:45:30 <bernalex> int<int> is of course nonsense, but nevermind that for the moment. ;)
22:48:36 <bernalex> also interesting. foo<int> works, but not int<bar>.
22:54:03 <bernalex> the issue seems simply to be that stuff inside <>s are never recognised as types. which is odd, because they are recognised as Ids, and every Id can be a Type. ugh!
23:21:09 <phy1729> is there a better way to write  https://gist.github.com/7164e717238a8c559afb  ?
23:23:55 <MarcelineVQ> there's http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Bool.html#v:bool but if's are pretty clear so idk if it'd be better, it'
23:24:03 <MarcelineVQ> s just handy to know it exists too
23:25:56 <jle`> phy1729: i'd probably use guards
23:26:09 <jle`> and...manually apply out `on`
23:27:07 <jle`> lesserrank | (rank p (M.getElem 1 1 matrix)) >= (rank p (M.getElem 1 2 matrix)) = 2
23:27:16 <jle`>            | otherwise = 1
23:27:20 <jle`> or you could give names
23:27:24 <jle`> oh my parentheses are optional
23:27:33 <jle`> lesserrank | rank p (M.getElem 1 1 matrix) >= rank p (M.getElem 1 2 matrix) = 2
23:27:41 <jle`> but maybe the best way is to just name the first and the second things
23:30:32 <phy1729> is there a sort of minimumOn (\x rank p $ Matrix.getElem 1 x matrix) [1, 2]  ?
23:32:15 <jle`> there's minimumBy, but...i would definitely say that that's a step towards less readability, heh
23:32:24 <jle`> if by "better" you meant more readable
23:33:11 <jle`> and using lists as tuples like that is somewhat unidiomatic
23:34:20 <jle`> actually nvm, the last statement doesn't really hold up on further reflection
23:34:20 <phy1729> well I'm going to have to expand it to the n case later
23:34:26 * hackagebot warp 3.1.12 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.12 (KazuYamamoto)
23:34:47 <phy1729> I'm figuring out the 2 case first because I can wrap my head around that
23:34:47 <jle`> ah well in that case, you can use minimumBy
23:34:49 <jle`> :t minimumBy
23:34:50 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
23:35:17 <jle`> or minimumBy with comparing
23:35:31 <jle`> > minimumBy (\x y -> negate x < negate y) [1,2,3]
23:35:33 <phy1729> minimumBy (on (<)  (\x rank p $ Matrix.getElem 1 x matrix)) [1..2]  ?
23:35:33 <lambdabot>      Couldn't match expected type ‘Ordering’ with actual type ‘Bool’
23:35:33 <lambdabot>      In the expression: negate x < negate y
23:35:33 <lambdabot>      In the first argument of ‘minimumBy’, namely
23:35:50 <jle`> > minimumBy (\x y -> compare (negate x) (negate y)) [1,2,3]
23:35:52 <lambdabot>  3
23:35:58 <jle`> > minimumBy (comparing negate) [1,2,3]
23:36:00 <lambdabot>  3
23:36:09 <jle`> > minimumBy (on compare negate) [1,2,3]
23:36:11 <lambdabot>  3
23:36:28 <jle`> comparing = on compare, so it's a nice shorthand
23:36:49 <fvkboi101> why do a lot of mathematicians suck at programming? it seems weird
23:36:52 <jle`> the result has to be an Ordering, not a Bool, so (<) doesn't work, heh
23:37:03 <phy1729> ah I wonder if hlint would have caught that
23:37:05 <fvkboi101> lots of maths majors at my uni suck at programming
23:37:39 <jle`> i'm not sure you can make a good general statement, but remember that math majors usually don't get formal training in programming like other majors might
23:38:11 <jle`> most exposure is ad-hoc and usually just supplementary to supporting a math class's ideas
23:38:36 <jle`> so it tends to be more scripting-to-demonstrate-a-math-concept than formal training
23:38:49 <jle`> but different universities have different policies/programs.  and this is probably also off-topic :)
23:38:53 <MarcelineVQ> fvkboi101: on the plus side, while we're being general, they can make some pretty speed algorithms by knowing the shortcuts maths has given them to a particular answer
23:39:15 <phy1729> huh hlint doesn't suggest on compare  =>  comparing
23:39:20 <MarcelineVQ> project euler is all those tricks for example
23:39:55 <jle`> yeah, math majors who also have a solid programming fundamentals/backgrounds tend to be pretty competitive...just not in the same sort of programming jobs a comp sci/eng BS would typically take
23:40:18 <phy1729> thanks jle` 
23:40:33 <jle`> phy1729: hm, i feel like i've seen it mention it to me before, but maybe i'm just misremembering things heh
23:40:34 <jle`> np!
23:40:44 <jle`> a lot of people do like to use `on compare` over comparing though
23:42:11 <jle`> fvkboi101: the same goes in reverse, too, though; in a lot of the more mathematics-heavy computational fields like ML, quantitative analysis, etc., people with only a computer science/programming formal training and limited formal math training tend to struggle
23:42:35 <jle`> so it's sort of like asking why physics majors tend to be bad at political science compared to poly sci majors, etc.
23:43:20 <jle`> and why a world class neurosurgeon might struggle with socioeconomic policy
23:44:02 <Lokathor> stack can't install gloss
23:44:04 <Lokathor> and that's a shame
23:44:34 <jle`> :(
23:45:07 <Cale> Lokathor: Really? That's pretty sad and unexpected. What problem do you run into?
23:45:18 <Lokathor> well it probably can if i get the repo myself and build that way
23:45:52 <Lokathor> but gloss can't build with stack directly because it's not in stackage, and you can't use stack to install cabal and then use that cabal to install gloss in a sandbox, because cabal gets upset that you're trying to use stack's GHC
23:46:20 <MarcelineVQ> uh
23:46:26 <kadoban> Lokathor: You can certainly use things that aren't in stackage with stack
23:46:48 <MarcelineVQ> windows issue? I just installed gloss with stack now to check and it worked fine
23:46:50 <Lokathor> yeah manually, sure
23:47:02 <Lokathor> stack says there's no target for gloss for me!
23:47:23 <MarcelineVQ> "stack solver --modify-stack-yaml && stack build"
23:47:42 <MarcelineVQ> If that's not working there's a bug occuring
23:47:56 <Lokathor> are you doing the thing i just said you could do where you got the repo and built from within that directory?
23:48:36 <kadoban> Lokathor: What exactly are you trying to do? Use gloss as a dependency in some project?
23:48:39 <MarcelineVQ> No I don't need to get a repo it's on hackage and stack can get things off hackage just fine if you ask it to
23:49:27 <Lokathor> http://lpaste.net/147764
23:49:27 * hackagebot http2 1.4.0 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.0 (KazuYamamoto)
23:49:33 <Lokathor> hmmmmm
23:52:41 <kadoban> Lokathor: I'm not entirely sure what useful thing you expect that to do actually. gloss is a library only, correct? I don't believe that 'stack install' even makes sense with a library.
23:53:26 <kadoban> Lokathor: If you want to use it, you just set up the stack.yaml correctly so it knows what package you're talking about, and then … use it. (usually that means you put it in .cabal as well, and then use it in the code of your project). But that's besides the point a bit.
23:53:29 <MarcelineVQ> It deinfetly  won't make a bin, if you want gloss in a project you should build it in a project :>
23:53:32 <Lokathor> well gloss-examples just has more missing dependencies if you'd care to have that output
23:53:56 <Lokathor> and gloss-examples *should* build a collection of binaries
23:54:37 <kadoban> Lokathor: Well that sounds like a more sane thing to attempt at least, so it might make more sense to look at that. Did you try what it suggests though?
23:54:56 <Lokathor> to add the extra dependencies?
23:55:16 <kadoban> That or the solver. I don't know particularly how involved gloss is.
23:55:49 <MarcelineVQ> It's got 9 deps or so few deps
23:55:58 <MarcelineVQ> *deps or so.
23:56:16 <Lokathor> http://lpaste.net/6405801906458853376 that's the gloss-examples version of things
23:56:47 <kadoban> Lokathor: Well, I'd try what it suggests and see what happens.
23:57:19 <Lokathor> well solver doesn't seem to work in the absence of a project in the directory
23:57:37 <MarcelineVQ> He means place those reccomended items in the reccdomended spot
23:57:59 <Lokathor> well sure, but stack did also suggest the solver, so i tried that first. alas
23:58:01 <lamefun> Is there an easy way to pattern-match Aeson values?
23:58:37 <Lokathor> to be honest i don't know how to add an extra-dep
23:58:39 <kadoban> Yeah I'm not sure how to use the solver in that case. It might unfortunately not be possible, or I might just not know how.
23:58:43 <Lokathor> because with cabal it was not an issue
23:58:53 <lamefun> Or pattern-match maps and hash maps?
23:59:01 <SX> What's the problem with stack?
23:59:06 <MarcelineVQ> lpaste.net/147765
23:59:12 <Lokathor> lamefun, you can match a Value on the Object constructor
23:59:25 <Lokathor> and that'll be your mapping
23:59:33 <lamefun> yes, but can I pattern match the contents of the map somehow?
23:59:35 <MarcelineVQ> Lokathor: or whatever else you need, but that's my stack.yaml from just gloss
23:59:50 <Lokathor> lamefun, nope, can't pattern match on the contents of a map as far as I know.
