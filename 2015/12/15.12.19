00:07:42 * hackagebot x509-system 1.6.2 - Handle per-operating-system X.509 accessors and storage  https://hackage.haskell.org/package/x509-system-1.6.2 (VincentHanquez)
00:07:42 * hackagebot x509-util 1.6.1 - Utility for X509 certificate and chain  https://hackage.haskell.org/package/x509-util-1.6.1 (VincentHanquez)
00:12:37 * hackagebot x509-system 1.6.3 - Handle per-operating-system X.509 accessors and storage  https://hackage.haskell.org/package/x509-system-1.6.3 (VincentHanquez)
00:37:42 * hackagebot binary-file 0.15.25 - read/write binary file  https://hackage.haskell.org/package/binary-file-0.15.25 (YoshikuniJujo)
00:47:42 * hackagebot png-file 0.0.1.2 - read/write png file  https://hackage.haskell.org/package/png-file-0.0.1.2 (YoshikuniJujo)
01:03:46 <jle`> time to decide between hmatrix and accelerate
01:03:58 <jle`> and resist the urge to generalize over both
01:27:44 * hackagebot png-file 0.0.1.3 - read/write png file  https://hackage.haskell.org/package/png-file-0.0.1.3 (YoshikuniJujo)
02:46:21 <amalloy> is there some function updateIf :: (a -> Bool) -> (a -> a) -> a -> a, such that updateIf even (/ 2) 6 = 3, and updateIf even (/ 2) 5 = 5? hoogle can't find anything with a similar signature, but it seems like a common enough thing to want that i must be missing something
02:47:33 <amalloy> (or, of course, a clever way to build that function out of existing combinators without doing it by hand)
02:53:55 <lyxia> amalloy: The Fairbairn threshold is the point at which the effort of looking up or keeping track of the definition is outweighed by the effort of rederiving it or inlining it.
02:55:12 <amalloy> ha. i discovered recently another haskell function that falls on the other side of that threshold
02:56:08 <amalloy> i was looking for something like oneOf f g x = f x || g x, which i'm used to having from clojure, when i realized it's easier to inline as liftA2 (||) f g
02:56:11 <lyxia> @pl \cond f a -> bool a (f a) (cond a)
02:56:11 <lambdabot> flip (ap . ap bool)
02:57:34 <jle`> :t \p f -> execState (get >>= \x -> when (p x) (modify f))
02:57:35 <lambdabot> (s -> Bool) -> (s -> s) -> s -> s
02:58:03 <jle`> :t \p f -> execState ((`when` modify f). p =<< get)
02:58:04 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
02:58:06 <jle`> hehe
02:58:54 <jle`> > (\p f -> execState $ (`when` modify f) . p =<< get) even (/2) 6
02:58:56 <lambdabot>      No instance for (Show a0)
02:58:56 <lambdabot>        arising from a use of ‘show_M482579262200756859029870’
02:58:56 <lambdabot>      The type variable ‘a0’ is ambiguous
02:58:59 <jle`> darn
03:00:15 <jle`> oh because you can't `even` and `(/)` on the same thing
03:00:23 <jle`> > (\p f -> execState $ (`when` modify f) . p =<< get) even (`div` 2) 6
03:00:27 <lambdabot>  mueval-core: Time limit exceeded
03:00:30 <jle`> > (\p f -> execState $ (`when` modify f) . p =<< get) even (`div` 2) 6
03:00:32 <lambdabot>  3
03:01:11 <jle`> > (\p f -> execState $ (`when` modify f) . p =<< get) even (`div` 2) 5
03:01:13 <lambdabot>  5
03:12:49 * hackagebot control-monad-queue 0.2.0.1 - Reusable corecursive queues, via continuations.  https://hackage.haskell.org/package/control-monad-queue-0.2.0.1 (LeonSmith)
03:33:12 <roelof> someone who can help me with this problem : https://www.reddit.com/r/haskellquestions/comments/3xe5ad/sublimetext_testing_not_working/ 
03:34:52 <frankier> Say I have code like this http://lpaste.net/147436 - I get a type error because I need to return some general Inside b rather than a specific InsideA. Can anyone suggest how I might constrain the types or change it without changing the data types so I can return a concrete insideA?
03:36:03 <jle`> frankier: where is the type error?
03:36:27 <lyxia> frankier: You can't.
03:37:12 <lyxia> "Inside b => a -> Maybe b" tells the *user* of the function that any "b" they choose which satisfies the constraint, they can get a "Maybe b".
03:37:56 <jle`> frankier: you're going to have a lot of trouble with your  Inside class, the way it is
03:38:44 <jle`> if your only method is wiggle :: String, then there isn't any way to figure out which instance to use
03:38:53 <jle`> perhaps you meant wiggle :: a -> String ?
03:43:38 <tpsinnem> is there a nice process for turning haskell stack projects into nix packages?
03:44:22 <frankier> jle`, Yep that is what I meant
03:44:49 <frankier> Just tried to make a simple example
03:45:16 <roelof> No one who can help me ? 
03:46:13 <frankier> lyxia, Yeah, I think I can see why the error exists, but is there no way to do the opposite?
03:46:40 <frankier> Is there no better way that putting wiggle inside the Outer typeclass as a-> Maybe String ?
03:48:43 <frankier> roelof, Maybe try testing from the command line with cabal. See if that works?
03:49:26 <lyxia> frankier: What are you trying to do with such a thing?
03:50:16 <lyxia> Maybe you are looking for an existential type, but you can't to anything with an Inside constraint besides getting a string, so why is storing the string insufficient?
03:53:25 <frankier> lyxia, Interesting, well there are actually more things in insideB. Actually OutsideA and InsideA are edges in an unweighted transducer and OutsideB and InsideB are nodes in a weighted transducer
03:53:47 <frankier> The reason for not just having a Maybe Weight is that they never mix
03:54:07 <frankier> So I wanted to try and enforce that using the type system
03:55:21 <lyxia> frankier: Okay, I just assumed wrong that's not an existential type at all.
03:55:25 <frankier> Existential types look interesting. I'm going to have a look. I guess it might be simpler to just lift the stuff I need into the parent typeclass
03:55:28 <frankier> Oh, okay
03:56:16 <frankier> I guess what I really want is OO style inheritance (extension and subtyping)
03:57:05 <lyxia> Why are they called Inside/Outside?
03:59:31 <jle`> frankier: there probably is a better way to solve whatever problem you have than basically forcing in OO style inheritance ;)
03:59:49 <jle`> and pushing it awkwardly into a language that isn't meant for it
04:00:39 <frankier> Yeah, that's what I'm hoping. It's not actually copy-pasted. I was just trying to reduce it down, but I might have decontextualised a little too much. So Outside can either be an edge record or a marker that the node is final
04:01:16 <frankier> The data structures are pretty much a direct translation the binary format of the transducers
04:03:41 <frankier> I think the pragmatic thing to do would be to just have a Maybe Weight and just have one type of transducer, but then I have to account for runtime errors if I try and use an unweighted transducer as a weighted one
04:12:17 <frankier> Hmm, I think I'm just going to try carrying on with one type class to see if I can get something working that way. I think you're right that I might be being affected by OO brain damage. Good pep.
04:40:39 <spuz> i'm trying to add hspec tests to my haskell project, however when i run 'stack build' it does not discover any of my tests: https://github.com/alexspurling/adventofcode
04:42:27 <spuz> as far as i understand, i've followed the guidelines, i have a Spec called 'Day1Spec.hs', i have a Spec.hs with the pragma to run hspec-discover, i have a test suite configured in my .cabal file.
04:42:57 <spuz> when i run 'stack test' it says "0 examples, 0 failures"
05:04:13 <paldepind> I'm inside a monad stack with ExceptT and calling a function that returns an Either. How do I lift the call to the function?
05:04:52 <paldepind> I'm missing something like "liftEither = ExceptT . return"
05:13:34 <badmash> hello there
05:13:48 <badmash> need some help with haskell
05:14:17 <badmash> appreciate any help
05:15:14 <badmash> let f x = x :: Num a => a  -- this code throws up type mismatch error.  i would like to knwo why
05:16:26 <zoku> you're defining a function which takes a value, and returns it
05:16:43 <zoku> > :t f x = x
05:16:44 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:16:48 <zoku> > :tlet  f x = x
05:16:49 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:17:03 <zoku> sorry i dunno how to use the bot well
05:17:17 <badmash> @t f x = x
05:17:18 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
05:17:24 <zoku> right badmash , thanks
05:17:28 <zoku> > :t f
05:17:29 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:17:53 <zoku> @let f x = x
05:17:55 <lambdabot>  Defined.
05:18:01 <zoku> > :t f
05:18:02 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:18:13 <zoku> @let f x = x :: Num a => a -> a
05:18:14 <lambdabot>  .L.hs:152:7:
05:18:14 <lambdabot>      Couldn't match type ‘a’ with ‘a1’
05:18:14 <lambdabot>        because type variable ‘a1’ would escape its scope
05:18:23 <exio4> @type f 
05:18:25 <lambdabot>     Ambiguous occurrence ‘f’
05:18:25 <lambdabot>     It could refer to either ‘L.f’,
05:18:25 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:151:1
05:18:31 <exio4> @type head
05:18:32 <lambdabot> [a] -> a
05:18:48 <exio4> :t let f x = x in f
05:18:49 <lambdabot> t -> t
05:19:30 <roelof> How can I make this test work : prop_exOr x y = exOr x y == or x y   
05:20:06 <spuz> roelof, is exOr already defined?
05:20:23 <badmash> i want to understand why this code throws a type mismatch error
05:20:25 <badmash>  :t f x = x
05:20:54 <badmash> 18:4 
05:20:56 <pavonia> roelof: Haskell's logical or is (||)
05:20:58 <badmash>  let f x = x :: Num a => a  
05:21:05 <roelof> spuz : yep , would you also see the definition of exOr ? 
05:21:24 <badmash> why does this code throw a type mismatch --  let f x = x :: Num a => a
05:21:55 <pavonia> badmash: Do you know what "Num a => a" denotes?
05:22:09 <badmash> yeah, a type class
05:22:38 <pavonia> It's a type class constraint
05:22:43 <badmash> yes
05:23:12 <pavonia> You are defining a function that takes a parameter but want it to have a non-function type
05:23:52 <roelof> spuz : the exOr function looks like this : http://lpaste.net/147441
05:23:59 <badmash> pavonia: "non-function type"? what do you mean?
05:24:20 <pavonia> A type that doesn't represent a function
05:24:35 <zoku> @type 23 :: Num a -> a
05:24:36 <lambdabot>     Expected a type, but ‘Num a’ has kind ‘Constraint’
05:24:37 <lambdabot>     In an expression type signature: Num a -> a
05:24:37 <lambdabot>     In the expression: 23 :: Num a -> a
05:24:39 <zoku> @type 23 :: Num a => a
05:24:40 <lambdabot> Num a => a
05:24:41 <zoku> whoops, sorry
05:24:52 <zoku> the type you've specified is only for a value
05:25:02 <pavonia> badmash:  Like "Int -> String" would be a function from Ints to Strings, but "String" it self isn't a function, only a value
05:25:05 <badmash> pavonia: i can return any type from a function, can't i?
05:25:06 <zoku> but you are defining a unary function 
05:25:11 <predator417> roelof: `or` is not what you want, use (||) as in: prop_exOr x y = exOr x y == x || y
05:25:31 <roelof> predator417:  thanks 
05:25:49 <pavonia> badmash: Yes
05:25:50 <predator417> :t or
05:25:52 <lambdabot> Foldable t => t Bool -> Bool
05:25:54 <predator417> :t ("")
05:25:57 <lambdabot> [Char]
05:25:59 <badmash> pavonia: there are many functions with Num a => a in their type signature
05:26:00 <predator417> :t (||)
05:26:01 <lambdabot> Bool -> Bool -> Bool
05:26:12 <predator417> > or [False,False,True]
05:26:14 <lambdabot>  True
05:26:41 <predator417> roelof: `or` is just a helper from Foldable that is true if any element is true
05:26:47 <pavonia> badmash: Have that in the functions signature is different from being the signature itself
05:27:23 <roelof> predator417:  thanks for the lesson 
05:27:43 <badmash> pavonia: all i have done is denote the expression type in the function with Num a => a
05:28:05 <badmash> pavonia: i don't see why that would be a problem
05:28:22 <pavonia> badmash: Yes, but you can't do that because it doesn't represent a function's type
05:28:48 <badmash> pavonia: what is a function's type, exactly?
05:28:55 <zoku> badmash: lets look at the type of a function which only takes integers
05:29:09 <pavonia> badmash: Something of the form "a -> b", for some a and b
05:29:31 <zoku> @type add x = 23 + x
05:29:33 <lambdabot> parse error on input ‘=’
05:29:41 <zoku> @type let f x = 23 + x in f
05:29:42 <lambdabot> Num a => a -> a
05:30:07 <zoku> it takes a Num, and returns a Num
05:30:30 <pavonia> ^ note the "->" in that type
05:30:39 <zoku> here's a trinary function
05:30:52 <zoku> er sorry, binary
05:31:07 <zoku> @type let f x y = y + x in f
05:31:09 <lambdabot> Num a => a -> a -> a
05:31:37 <zoku> The final is the return type, the ones before it are inputs the function expects
05:31:48 <zoku> @type let f x y = show (y + x) in f
05:31:50 <lambdabot> (Num a, Show a) => a -> a -> String
05:32:13 <zoku> here we have a different return type because we're using `show`
05:33:32 <roelof> one maybe stupid question ; When I run quickCheck I now see this layout :  http://lpaste.net/147442
05:33:54 <roelof> Can I change the layout to just passed in green and not passed in red 
05:34:17 <badmash> basically, this throws up a type mismatch error
05:34:20 <badmash> let f x = x :: Num a => a
05:35:25 <spuz> badmash, if you follow your function definition with :: it says to the compiler, please try to define my value with this type
05:35:47 <spuz> and the compiler says, but your function is not of that type so i can't do that
05:36:04 <spuz> your function is of type t -> t, not (Num a => a)
05:36:37 <zoku> @type let f x = x :: Num a => a -> a in f
05:36:39 <lambdabot>     Couldn't match expected type ‘a2 -> a2’ with actual type ‘t1’
05:36:39 <lambdabot>       because type variable ‘a2’ would escape its scope
05:36:39 <lambdabot>     This (rigid, skolem) type variable is bound by
05:36:49 <zoku> @type let f x = x in f :: Num a => a -> a
05:36:51 <lambdabot> Num a => a -> a
05:37:38 <zoku> what are you trying to define badmash ?
05:38:51 <badmash> spuz: my question is -- why didn't GHC infer from the function definition that the type is Num a => a -> a?
05:39:37 <badmash> once again, here is the functio definition
05:39:43 <badmash> let f x = x :: Num a => a
05:40:19 <badmash> i am asking why GHC is not inferring the type signature as Num a => a -> a?
05:40:20 <spuz> badmash, because that syntax is incorrect
05:40:35 <zoku> all type signatures must be complete
05:40:43 <spuz> if that's what you want, you need to use the syntax that zoku showed you
05:40:56 <zoku> the equivalent thing in C would be
05:41:11 <zoku> f(int x) { return x; }
05:41:22 <zoku> the compile still won't know what return type you want
05:41:31 <zoku> *compiler
05:41:50 <zoku> and I think that is defined as syntactically incorrect in C
05:41:54 <zoku> Any compiler would error
05:42:12 <zoku> You must explicitely define both the parameter and return types
05:42:17 <badmash> well, let me give you a counter example
05:42:39 <badmash> let f x = x :: Int  -- this works fine
05:43:29 <badmash> all i have done is, instead of x :: Int, i have used x :: Num a => a
05:43:47 <badmash> so i don't think there is anything wrong with the syntax
05:44:32 <zoku> in this case, the compiler only applies :: Int to the x
05:44:43 <zoku> This would still fail if you wrote it into a file as
05:44:48 <zoku> f :: Int
05:44:49 <zoku> f x = x
05:45:07 <zoku> @type let f x = x in f :: Int -> Int
05:45:09 <lambdabot> Int -> Int
05:45:13 <zoku> @type let f x = x in f :: Int
05:45:14 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘t0 -> t0’
05:45:15 <lambdabot>     Probable cause: ‘f’ is applied to too few arguments
05:45:15 <lambdabot>     In the expression: f :: Int
05:45:24 <zoku> @type let f x = x :: Int in f
05:45:26 <lambdabot> Int -> Int
05:45:33 <lyxia> "let f x = x :: Num a => a" this would have type "(Num a => a) -> (Num a => a)" but you can't infer higher-rank types.
05:45:44 <lyxia> uh
05:46:01 <lyxia> "(forall a. Num a => a) -> (forall a. Num a => a)"
05:46:11 <badmash> lyxia: thanks, i think that is the crux of the matter
05:47:29 <badmash> lyxia: so the argument type forall a. Num a => a -- GHC is not able to infer, right?
05:49:50 <lyxia> That's it
05:50:05 <badmash> lyxia: quick question -- what exactly is the difficulty with inferring higher-rank types?
05:50:14 <badmash> i am just trying t understand
05:50:44 <badmash> what actual type does GHC end up inferring in this case?
05:52:01 <lyxia> It doesn't manage to infer anything.
05:52:08 <KaneTW> badmash: type inference for rank 2 types is quite complex and undecidable for rank 3 or higher
05:52:43 <KaneTW> ghc doesn't implement rank 2 inference because there hasn't been any need and it's like 10x as complex as rank 1 inference
05:52:56 * hackagebot hakyll 4.7.5.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.5.0 (JasperVanDerJeugt)
05:53:22 <badmash> KaneTW: so in this case -- f x = x :: Num a => a -- GHC ends up with an arbitrary type for the argument?
05:53:55 <KaneTW> let f x = (x :: Num a => a) ?
05:54:10 <lyxia> type checking fails, you get an error message.
05:55:06 <badmash> KaneTW: GHC says something about an actual type 't' in the error message -- i wonder what that is
05:57:23 <KaneTW> by giving the signature you tell ghc that f evaluates to a value of type (forall a. Num a => a)
05:57:47 <KaneTW> but you can't match that with an already known type `t` from the function definition
05:58:11 <badmash> KaneTW: yes, correct.  what is that known type 't'? 
05:58:27 <KaneTW> the (inferred) type of x in f x
05:58:33 <KaneTW> not in the rhs
05:58:55 <badmash> KaneTW: which is something arbitrary, right?
05:59:02 <badmash> yet undetermined
05:59:27 <badmash> KaneTW: is that correct?
05:59:27 <KaneTW> it's arbitrary when you call the function, but once you're in the function it's something specific
05:59:41 <KaneTW> :t const
05:59:43 <lambdabot> a -> b -> a
05:59:46 <KaneTW> :t (const 1)
05:59:47 <lambdabot> Num a => b -> a
05:59:58 <KaneTW> :t (const True)
05:59:59 <KaneTW> etc
06:00:00 <lambdabot> b -> Bool
06:00:00 <nshepperd> i think ghc assumes that anything whose type is not given has a rank 1 type, and infers from there
06:00:13 <KaneTW> yes
06:00:28 <KaneTW> all rank>1 types need a type signature
06:00:47 <nshepperd> so that function f is typed with t1 -> t2 for some t1 and t2, and then realises that t1 can't unify with (forall a. Num a => a), and fails
06:00:57 <badmash> KaneTW: sorry, i didn't understand what you said about the type 't' GHC inferred
06:02:08 <badmash> nshepperd: where t1 is some arbitrary type, correct?
06:03:07 <nshepperd> where t1 is something monomorphic
06:03:22 <nshepperd> arbitrary is a bit of a loaded term, I think
06:03:58 <badmash> nshepperd: why is t1 monomorphic? because t2 is polymorphic?
06:04:23 <nshepperd> because values without type signatures are assumed to be rank-1
06:04:36 <badmash> nshepperd: i see
06:04:55 <nshepperd> and being rank-1, for a function, means your argument is monomorphic
06:05:19 <badmash> nshepperd: so t1 and t2 are arbitrary monomorphic types, correct?
06:06:08 <badmash> nshepperd: GHC starts with that in its type inference 
06:06:37 <KaneTW> rank-0 are all monotypes (Int, Bool, [Int], etc) and functions from a rank0 to a rank0, i.e. Int -> Int, Int -> [Bool], etc
06:06:55 <nshepperd> this is a bit hand-wavy, I don't actually know how ghc works under the hood :/
06:07:19 <KaneTW> rank-1 is a forall-quantified (polymorphic) type with a contexts, like forall a. Num a => a -> a -> a
06:07:22 <KaneTW> -s
06:07:38 <badmash> KaneTW: correct
06:08:29 <badmash> nshepperd: so in this case -- f x = x :: Num a => a -- GHC starts of with t1 -> t2
06:08:58 <badmash> then it encounters t2 as a hiher rank type
06:09:16 <badmash> and ends up not knowing how to infer t1 from t2
06:09:24 <badmash> and the type inference fails
06:09:34 <nshepperd> that's not exactly the problem
06:09:55 <nshepperd> thing is once you get into the function body you have this
06:10:00 <nshepperd> (x :: t1)
06:10:04 <nshepperd> in scope
06:10:14 <nshepperd> because the type of the function is t1 -> t2
06:10:25 <badmash> nshepperd: ok
06:10:34 <nshepperd> and then you go on to assert that (x :: Num a => a) in the function body
06:10:42 <badmash> nshepperd: yes
06:10:51 <nshepperd> but t1 ~ (Num a => a) does not unify
06:11:11 <badmash> nshepperd: because t1 is monomorphic type?
06:11:17 <nshepperd> yes
06:11:28 <badmash> nshepperd: ok
06:11:51 <badmash> nshepperd: but GHC can do the other way right?
06:12:44 <badmash> if t1 is Num a => a, then it can infer t2 as Num a => a?
06:12:45 <nshepperd> But I suppose there is also the problem that you have (f x :: t2) for the similar reason, and are asserting (f x :: Num a => a) in the function body, which fails to unify for the same reasons
06:13:13 * hackagebot hspec-setup 0.1.0.0 - Add an hspec test-suite in one command  https://hackage.haskell.org/package/hspec-setup-0.1.0.0 (yamadapc)
06:14:09 <badmash> nshepperd: but GHC error message seems to indicate that it has inferred t2 as Num a => a
06:14:25 <KaneTW> it didn't
06:14:37 <badmash> KaneTW: no?
06:15:24 <nshepperd> badmash: no, afaik the only way this works is to give the type signature explicitly: f :: (Num a => a) -> (Num a => a)
06:15:49 <KaneTW> the message is a bit obscure but it essentially tells you that due to yur type signature it can't unify the types
06:16:31 <badmash> nshepperd: so an explicit type signature means that GHC need to do any type inference, so it works, you mean?
06:17:15 <spuz> Can anyone help me set up hspec? For some reason no spec files are found when I run 'stack test': https://github.com/alexspurling/adventofcode
06:17:29 <badmash> nshepperd: i meant, with an explicit type signature, GHC need NOT do any type inference, so the whole thing works?
06:18:40 <badmash> KaneTW: the reason i thought GHC inferred t2 correcty is that it says in the error message that the expected type is Num a => a
06:21:02 <badmash> KaneTW: i am bit confused with GHC's error message involving "expected" and "actual" types
06:22:50 <KaneTW> the type is expected because you gave it a signature
06:23:06 <KaneTW> actual type is the one it inferred from the rest of the expression
06:23:29 <badmash> KaneTW: so that expected type is what it inferred for t2 in t1 -> t2?
06:23:48 <KaneTW> no, expected is what you wrote
06:24:07 <KaneTW> let f x = (x :: Num a => a) means x in the right hand side has expected type Num a => a
06:24:19 <badmash> KaneTW: correct
06:24:52 <badmash> KaneTW: or you could write without brackets -- f x = x :: Num a => a
06:25:43 <nshepperd> i think the usual meaning of "expected" vs "actual" is that with an expression like a b x c the "expected" type for x is that inferred from context a b c and the "actual" type is that inferred from the expression x itself
06:26:15 <nshepperd> i'm not sure if that's always true, but it seems to be
06:26:35 <badmash> KaneTW: so from the expected type, it is trying to match with t1?
06:27:06 <nshepperd> so the "expected" type of x in (x :: Num a => a) is Num a => a, and the "actual" type is t1
06:27:24 <badmash> nshepperd: i see
06:27:51 <badmash> nshepperd: and GHC is not able to match them, correct?
06:29:14 <nshepperd> yes. apparently because "type variable ‘a1’ would escape its scope" which I don't fully understand but I assume amounts to "t1 is monomorphic"
06:30:00 <nshepperd> well, I mean "type variable ‘a’ would escape its scope" to keep this consistent with the variable names we are using here
06:30:34 <badmash> nshepperd: type variable escaping its scope means that it will have to unify with some concrete type rather than Num a => a
06:32:04 <badmash> nshepperd: so basically, it boils down to an inability to match with a polymorphic type
06:32:31 <badmash> nshepperd: on the lines you said about higher rank types
06:33:59 <jansamohyl> hello, I am trying to install GHC via stack on my netbook, and I ran into some issue that I can't google; stack installed ghc-7.10.2, and then I did "stack install ghc-mod" (I plan to use Emacs), but there was some problems compiling the packages needed..
06:34:22 <badmash> nshepperd: so when you specify an explicit type signature Num a => a -> a, these problems go away because GHC doen't need to do any type inference?
06:36:00 <jansamohyl> I am getting this error: setup-Simple-Cabal-1.22.4.0-ghc-7.10.2: Most RTS options disabled. Link with -rtsopts to enable them.
06:36:22 <han-solo_> hello
06:36:32 <roelof> any stack users here, I try to make a coverage report but see this error message : Error: The coverage report for chapter3's test-suite "chapter3-test" did not consider any code
06:36:49 <jansamohyl> I added -rtsopts to stack.yaml and config.yaml, but that didn't have any effect
06:37:38 <jansamohyl> does anyone knows what does it mean: link with -rtsopts? how do I tell stack to do that?
06:38:22 <badmash> KaneTW: so when you specify an explicit type signature Num a => a -> a, these problems all go away because GHC doesn't need to do any type inference?
06:40:43 <badmash> nshepperd: so when you specify an explicit type
06:40:43 <badmash>                 signature Num a => a -> a, these problems all go
06:40:43 <badmash>                 away because GHC doesn't need to do any type
06:40:49 <badmash>                 inference?
06:43:28 <badmash> nshepperd: just wondering why an explicit type signature would solve these problems
06:44:08 <nshepperd> Because it doesn't need to infer the type of the function, at least
06:44:23 <badmash> nshepperd: yeah, i thought so
06:45:30 <badmash> nshepperd: there is a rankN extension in GHC, but it quite specific about the syntax on lambdas
06:46:21 <badmash> nshepperd: for example, it disallows polymorphic signatiures in lambda body, as i have done
06:46:39 <badmash> nshepperd: just sharing some info i found
06:47:12 <maerwald> doesn't seem like haddock has special syntax for exceptions, does it?
06:47:13 <badmash> nshepperd: hey, thanks a bunch for your help ... your explanations cleared up a lot of things for me
06:47:35 <Mik3> Hello :) We're here again :D
06:47:50 <badmash> KaneTW: thnaks a lot for your help ... appreciate it
06:48:05 <Mik3> We have a brand new problem :D
06:48:14 <badmash> lyxia: thanks much for clearing up on the higher rank stuff
06:48:26 <roelof> Mik3:  we is only yiou ? 
06:48:57 <badmash> bye, folks
06:49:03 <badmash> have a good weekend
06:49:05 <Mik3> ahah sorry, i'm with my friend slv3r
06:49:26 <Mik3> so I wrote "we"
06:49:35 <spuz> hmm turns out I just had an unclean build state
06:50:19 <roelof> Mik3:  no problem, was just kidding. but what is the problem exactly ? 
06:51:13 <Mik3> We have this piece of code, and we can't understand how it wokrs :/ http://lpaste.net/147444
06:52:17 <maerwald> Mik3: do you know what currying is?
06:52:27 <Mik3> The function is an easy multiplication, but we're quite noobs, lambda-expressions make us cry
06:52:51 <Mik3> not very well :/
06:52:55 <maerwald> Mik3: try this maybe http://learnyouahaskell.com/higher-order-functions
06:53:03 <maerwald> it's a little bit verbose though
06:53:28 <Mik3> oh thank you, i'll take a look
06:53:50 <maerwald> "mult x y = x * y" is sort of syntactic sugar (hope that is right) for "mult x = \y -> x * y"
06:54:25 <maerwald> I'm not sure whether it's correct to call it syntactic sugar, but it's almost the same so to speak
06:57:46 <maerwald> https://www.seas.upenn.edu/~cis194/spring13/lectures/04-higher-order.html this may also help
07:01:16 <spuz> how can i do IO with hspec? is it possible?
07:01:32 <spuz> in this case, i just want to read a text file with input data for the test case
07:03:09 <sm> "The PureScript/JavaScript ecosystem is much more complex than the Haskell ecosystem.".. ouch
07:04:22 <sm> the haskell ecosystem has not exactly been a walk in the park
07:04:25 * sm is reading the nice http://www.arow.info/blog/posts/2015-12-17-purescript-intro.html
07:04:39 <sphinxo> Hi, i'm looking for feedback for this little brainfuck interpreter: http://lpaste.net/147446
07:06:23 <sphinxo> I feel the main function could be cleaned up alot
07:06:37 <roelof> any stack users here, I try to make a coverage report but see this error message : Error: The coverage report for chapter3's test-suite "chapter3-test" did not consider any code
07:10:16 <luigy> roelof can you lpaste the verbose output
07:11:58 <jansamohyl> I think I figured out what I was doing wrong
07:12:39 <jansamohyl> I set some memory limit in GHCRTS, but apparently stack doesn't like that
07:13:12 <jansamohyl> is there a good way to limit Haskell memory usage?
07:13:19 <jansamohyl> on Linux
07:14:16 <PatientZero> Hi guys - I have written some code to count the number of divisors that a number has (it's Euler problem 12)
07:14:34 <PatientZero> so here is a version that seems to be quite fast - but not especially elegant/readable IMHO:
07:15:50 <Mik3> Thank you maerwald. These links are very helpful; They have resolved our problem! Thanks to all chan :)
07:16:15 <PatientZero> http://lpaste.net/147452
07:16:44 <lyxia> sphinxo: that looks alright, apart from the fact that loop doesn't loop.
07:16:55 <PatientZero> So my question is whether it's possible to refactor the above into something that's more readable (but which still doesn't check anything past the square root)
07:16:57 <PatientZero> ?
07:17:42 <sphinxo> ahh, how do I fix that?
07:20:07 <sphinxo> Why not lyxia?
07:20:42 <silversheep> Is there a way to turn strings into quotes in Template Haskell? I.e. something like the following: instead of writing "[|blah|]", write "let str = "blah" in [|<str>|]"?
07:20:53 <roelof> luigy:  how do I do that. Just stack test --coverage -v ? 
07:23:16 <silversheep> (String manipulate is less clunky than building up things using constructors in TH.)
07:28:08 <sphinxo> Why would the loop not work lyxia?
07:31:38 <solirc> spuz: readFile "foo.txt" `shouldReturn` "some text"
07:32:57 <bergmark> silversheep: have you looked at the expression quotations? https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/template-haskell.html
07:37:53 <silversheep> @bergmark: Yes, I was wondering whether I could construct the inside of the expression quotation [|...|] as a string
07:37:53 <lambdabot> Unknown command, try @list
07:40:17 <roelof> luigy:  ping  
07:40:51 <lyxia> sphinxo: Which line checks whether the current cell contains a 0?
07:41:50 <sphinxo> ahh :)
07:42:31 <sphinxo> What's the cleanest way of doing that?
07:43:53 <sphinxo> add something like this? evalBF' (ls, 0, rs) (Loop prog) = return (ls, 0, rs)?
07:45:22 <lyxia> I'd just write another function loop tape prog which runs prog until the current cell is 0
07:46:03 <lyxia> the monad-loops package should have a combinator for that kind of thing too.
07:46:49 <sphinxo> What would that look like?
07:47:25 <varaindemian> can type errors occur during program execution in haskell?
07:48:47 <suppi> varaindemian, no. types are checked before the program is run
07:49:04 <suppi> varaindemian, unless you specifically ask with a flag :P
07:49:13 <varaindemian> I see
07:53:05 <tom__> how do I get this to work so that D has kind (* -> *): data D (f a) = D a
07:54:35 <tom__> is that even possible?
07:56:26 <bergmark> tom__: `data D (f a)' is not allowed, and if you want two type arguments then you will naturally end up with * -> * -> *
07:57:48 <tom__> oh, ok
07:58:18 * hackagebot pusher-http-haskell 0.3.0.0 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-0.3.0.0 (willsewell)
08:02:42 <lpaste_> lyxia revised “No title”: “to sphinxo” at http://lpaste.net/147446
08:03:22 <lyxia> sphinxo: I added some comments after instr and main too. But overall the program looks fine.
08:04:26 <sphinxo> Wonderful thank you
08:05:29 <roelof> as soon as I do stack test --coverage I see this error message :  Error: The coverage report for chapter3's test-suite "chapter3-test" did not consider any code.
08:06:41 <athan> Anyone here use acid-state often? For some reason, my entries aren't persisting to disk
08:07:13 <athan> I can see them being created in memory, but they're not being saved for some reason
08:07:40 <athan> I'm calling `createCheckpoint`, and can clearly see the `.log` files being created, but on boot the database isn't being loaded :\
08:14:10 <sphinxo> lyxia: What was the reasoning behind changing the parser part?
08:17:09 <lyxia> sphinxo: I thought it's kinda repetitive
08:17:39 <sphinxo> ahh yes I suppose
08:55:28 <OutlawStar> is there a way to import modules automatically after ghci has started up
08:59:15 <sivteck> OutlawStar, add :l <module> to .ghci file
09:00:28 <OutlawStar> sivtech: I should have been more specific, I use cabal repl, and I essentially want to set the module in scope explicitly load runs to early
09:03:03 <roelof> luigy:  are you still here  ?
09:18:34 <breadmonster> Hello.
09:37:15 <roelof> luigy:  ping 
09:42:31 <breadmonster> Hello everyone.
09:43:22 * hackagebot microlens-platform 0.1.6.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.6.0 (Artyom)
09:43:24 <roelof> hello, breadmonster 
09:44:18 <breadmonster> What's up roelof?
09:46:38 <roelof> nothing, still hoping that someone knows a solutiont to a stack problem with code coverage 
09:48:35 * hackagebot numeric-qq 0.1.3 - Quasi-quoters for numbers of different bases  https://hackage.haskell.org/package/numeric-qq-0.1.3 (NikitaVolkov)
09:53:35 * hackagebot amazonka-iot-dataplane 1.3.7 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.3.7 (BrendanHay)
09:58:26 <roelof> breadmonster:  everything well with you ? 
09:58:40 <johnw> osa1: hi
09:59:39 <breadmonster> roelof: Yeah.
09:59:50 <ownclo> Hello everyone! I'm in trouble figuring out whether it is possible to configure client-side certificates in yesod app. Could you please point out some resources on the subject?
09:59:52 <roelof> nice to hear 
10:02:38 <osa1> johnw: hi
10:02:49 <johnw> osa1: did you find the answer to your question?
10:03:44 <osa1> johnw: gitlib one? no
10:04:52 <johnw> ok, meet me in #gitlib?
10:05:32 <osa1> I'm there
10:09:44 <physixer> noob question: does a haskell program file execute from top to bottom?
10:09:52 <Clint> no
10:10:24 <hpc> a haskell program is like a C program, it runs just main
10:11:48 <physixer> so haskell is not like a scripting lanugage. lisp statements get evaulated top to bottom one at a time
10:12:13 <geekosaur> it is a compiled language like java / c / c++ / rust
10:12:16 <physixer> so haskell doesn't have an interpreter?
10:12:25 <geekosaur> unlike java but like the others it compiles to native code
10:12:38 <hpc> ghc has a bytecode interpreter as well
10:12:39 <geekosaur> there is an interpretive environment but it's not really production level
10:12:45 <bergmark> physixer: yes, ghci is an interactive prompt, and runhaskell is an interpreter
10:12:46 <breadmonster> physixer: It does, but that's not the kind you'd expect.
10:12:51 <hpc> runghc will compile to bytecode and interpret it
10:12:54 <hpc> but also run just main
10:12:55 <geekosaur> (unoptimized, mostly meant for experimentation and debugging)\
10:13:08 <hpc> then ghci is the interactive environment which is much different
10:13:36 * hackagebot yesod-core 1.4.18.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.18.1 (MichaelSnoyman)
10:15:04 <physixer> thanks.
10:19:53 <roelof> no stack experts here ? 
10:20:07 <breadmonster> roelof: I wish I could help you, but I don't use stack one bit.
10:21:17 <roelof> breadmonster:  you use cabal ?
10:25:14 <breadmonster> roelof: Yes :(
10:26:03 <Welkin> roelof: everyone uses cabal and stack
10:26:07 <Welkin> they are not mutually exclusive
10:26:18 <Welkin> stack uses the cabal library, just not the cabal-install executable
10:26:50 <roelof> Welkin:  I know 
10:27:00 <Welkin> if you have a question, just ask
10:27:59 <roelof> I have some problem with stack test --coverage. It's give me this message : The coverage report for chapter3's test-suite "chapter3-test" did not consider any code
10:30:52 <Welkin> I have not used the test function before
10:31:00 <Welkin> but the stack docs are located here http://docs.haskellstack.org/en/stable/README.html
10:37:25 <csd_> Hi -- I'm reading Mark Jones' 1995 paper Functional Programming with Overloading and Higher Order Polymorphism, and I'm confused by how he presents the state monad. He continually references a `ST`, for state transformer, but never defines this nor gives examples. Further, when I look at the source for how the state monad is defined nowadays, there is no reference to ST. why is this?
10:38:37 <geekosaur> ST and State are different things
10:38:54 <JonReed> Does anybody know how to this in attoparsec: Parser (Text, Text) -> Parser [(Text, Text)]". I have a Parser (named tupleParser) that parses a string like "(sometext, sometext)" into `(Text, Text)`. Now I want to parse "(sometext, sometext) (sometext, sometext)" into a list of tuples.
10:39:09 <geekosaur> ST is a mechanism to "trap" mutable values in a context so they cannot escape into pure code 
10:39:44 <Welkin> JonReed: many
10:40:01 <csd_> but why is he using ST in his definition when it's not necessary to do so and makes things less clear? for reference see p 27 http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf
10:40:08 <bergmark> JonReed: or sepBy
10:40:29 <shachaf> geekosaur: I'm not sure that was true in 1995, though.
10:40:35 <JonReed> Welkin: Ahh, it's `many` from Control.Applicative right?
10:40:53 <shachaf> csd_: It looks like page 26 has "data State s a = ST (s -> (a,s))"
10:40:57 <Welkin> https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString-Char8.html#v:many-39-
10:41:04 <shachaf> This is the line that defines the constructor ST.
10:41:08 <Welkin> it's a little different in attoparsec I suppose
10:41:12 <Welkin> I am used to parsec
10:41:17 <Welkin> haven't used attoparse much
10:41:22 <JonReed> Welkin: Then it will not work, because I'm using Text
10:41:35 <Welkin> JonReed: eh? then use the Text version
10:41:56 <Welkin> JonReed: https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString-Char8.html
10:41:57 <bergmark> Welkin: they are very similar, but i think attoparsec is simpler and it always backtracks (so no need for `try')
10:42:02 <geekosaur> oh, the ST there is not Haskell's ST monad
10:42:09 <geekosaur> it's just the constructor for State
10:42:25 <Welkin> er
10:42:29 <geekosaur> data State s a = ST (s -> (a,s))
10:42:41 <bergmark> OH, i didn't notice that :-)
10:42:50 <JonReed> Welkin: I can't find many in "https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html#v:anyChar"
10:42:57 <Welkin> JonReed: https://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Applicative.html#v:many
10:43:15 <Welkin> ah, yes, it is in Control.Applicative
10:43:15 <Welkin> huh
10:43:21 <csd_> geekosaur: so basically, it's saying "give me an ST plus a function of (s->(a,s)) and you've got yourself a State s a" ?
10:43:41 <geekosaur> no, ST is the constructor tag
10:43:43 <JonReed> Welkin: Ah. Ok. Will try with applicative then
10:43:49 <csd_> er that's what i meant
10:44:01 <bergmark> "give me the literal `ST' [...]" :-)
10:44:03 <geekosaur> it's not enough to have qa function, you need to tell it to treat that function as a value of type State s a; that's what ST is for
10:44:19 <csd_> i see
10:44:25 <csd_> thanks thats helpful
10:44:38 <geekosaur> just like if I have a 'data Weight = W Int', a random Int is not a value of type Weight, it has to be tagged W
10:44:49 <csd_> i'm trying to become more comfortable with monads and other higher order types. is there a better paper for me to be reading?
10:45:02 <Welkin> csd_: yes, the monads paper by spj
10:45:05 <csd_> i'm enjoying this one overall
10:45:33 <Welkin> csd_: http://research.microsoft.com/en-us/um/people/simonpj/papers/imperative.ps.Z
10:45:45 <lucky> I deleted my ~/.cabal folder and updated, but it says when I go to "cabal install" a package that it's already installed, is there another directory I should check/remove too?
10:45:48 <Welkin> csd_: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html#monads
10:46:06 <csd_> thanks
10:46:24 <Welkin> csd_: you will also like http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z
10:46:31 <Welkin> those are 2 of my personal favorite papers
10:47:50 <csd_> unrelated question
10:48:09 <csd_> how did university of glasgow become the hotbed of functional programming
10:49:11 <johnw> it has faculty with that interest, and supports them
10:53:11 <Pamelloes> Is there a way to disable the defined but not used warning for one type?
10:53:39 <johnw> if nothing else, you can put that type in its own file where the warning is disabled
10:54:04 <Pamelloes> :/
10:54:23 <Pamelloes> It's a type generated in a TH block with twenty or so other types which are used.
10:54:40 <Pamelloes> I guess I could move the block to a new file, but that seems like overkill.
10:54:44 <johnw> oh, so not just "one type", but a generated type at that.  I have no idea
10:55:13 <iwmrby> Hey. What's the recommended way to install Haskell on OS X? From the website or using homebrew? There are some replies from a year ago that say the the homebrew formula might not be so good.
10:55:40 <johnw> that really depends on who you ask; I really like using Nix to install Haskell on OS X
10:56:10 <iwmrby> johnw: nope, nix is too much. And it might make me want to install NixOS again and we can't have that.
10:56:34 <johnw> then I'm sure someone will mention stack too
10:56:58 <iwmrby> What is stack?
10:57:17 <johnw> @google Haskell Stack
10:57:18 <lambdabot> https://github.com/commercialhaskell/stack
10:58:28 <iwmrby> Well, now I have three options: homebrew, website and stack.
10:58:30 <iwmrby> Damn.
10:58:38 * hackagebot hlibsass 0.1.5.0 - Low-level bindings to Libsass  https://hackage.haskell.org/package/hlibsass-0.1.5.0 (jakubfijalkowski)
10:59:29 <iwmrby> stack seems overkill considering I am doing rather simple coding for Uni and not complex projects that need building, testing and benchmarking.
11:00:16 <maerwald> just use cabal sandboxes
11:04:15 <quchen> Stack isn't an overkill, it's a no-brainer for stuff like this.
11:07:01 <roelof> What is a good framework to make a ecommerce site with it ? 
11:08:46 * hackagebot pathtype 0.7.0.1 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.7.0.1 (HenningThielemann)
11:08:46 <ptcek> iwmrby: I would go with stack too, I switched and have never looked back
11:19:18 <roelof> What is a good framework to make a ecommerce site with it ? 
11:20:27 <breadmonster> roelof: I'd assume Yesod has what you need.
11:31:10 <roelof> oke, and could Servant also be a choice  ? 
11:32:51 <Welkin> roelof: only if you build the entire site using javascript
11:32:55 <Welkin> which is unlikely to be a good option
11:33:09 <Welkin> servant is for building APIs, not complete sites
11:34:03 <alpounet> can do both, but more straightforward for webservice-y things, even though I've built several sites with it
11:34:38 <roelof> Welkin:  thanks, I thought with adding a template engine I could also build a complete site with servant 
11:34:43 <maerwald> are there any interesting libraries that allow you to represent the filesystem in a smart way? I've tried directory-tree, but it causes too many problems with lazy IO, so I ended up doing things more atomically
11:35:01 <Welkin> roelof: you might be able to 
11:35:12 <Welkin> roelof: but yesod already has everything you need
11:35:46 <roelof> oke, then I have to learn the template haskell :( 
11:36:08 <Welkin> eh?
11:36:10 <Welkin> no you don't
11:36:16 <Welkin> yesod uses hamlet/shakespeare
11:36:22 <Welkin> you don't need to know any template haskell
11:37:26 <roelof> oke, then im mixing things. Is the haskell book enoug to learn the most of Haskell ? 
11:37:37 <roelof> haskell book , yesod book
11:38:48 * hackagebot hsass 0.4.0 - Integrating Sass into Haskell applications.  https://hackage.haskell.org/package/hsass-0.4.0 (jakubfijalkowski)
11:41:09 <roelof> Welkin:  is there somewhere a tutorial about building a site with Yesod ? The yesod book seems to explain every piece but not a whole site 
11:41:56 <Welkin> roelof: http://www.yesodweb.com/book/introduction
11:42:01 <Welkin> everything you need to know to get started
11:45:16 <defanor> an emacs haskell-mode question: i've created a cabal sandox, added some additional sources (which are in other sandboxes), and `cabal install`/`cabal repl` work fine, but haskell-mode fails to load one of the libraries with "<command line>: cannot satisfy -package-id <package name>". is there a known solution, or how to debug it?
11:48:17 <paldepind> defanor, have you tried running `cabal configure`. I've had a somewhat similar problem that went away after doing that.
11:50:23 <defanor> paldepind: hm, tried now, and probably i see a problem now: somehow that emacs instance now uses a Nix-installed cabal instead of the regular one. thanks
11:50:41 <defanor> probably getting rid of that would help
11:51:39 <roelof> Welkin : thanks 
11:55:33 <martinvlk> Hi, I'd like to ask for pointers on a problem. I'm using an API (pulse-simple) that lets me read data from a microphone. The call to the read function blocks if there is not enough data available. I need a way to try reading data and not block if there is no data available. What would be an idiomatic way to do that?
11:57:02 <mauke> threads?
11:57:47 <martinvlk> mauke: I thought of that, but is there a higher level way?
11:59:12 <geekosaur> ... nonblocking read is only "higher level" in C think
11:59:22 <Cale> I dunno, I usually would consider using a separate thread the higher level way to avoid using nonblocking reads directly
11:59:56 <geekosaur> most languages use (often green) threads as the higher level abstraction
12:00:03 <martinvlk> ok, fair enough guys
12:00:24 <martinvlk> thanks for a perspective on this
12:00:46 <mauke> you can probably build a nonblocking read out of threads + MVar
12:01:17 <martinvlk> mauke: yep, I'm now going to code that and see.
12:01:21 <Cale> Yeah, if you really want one
12:02:00 <martinvlk> Cale: I need one as I am reading data as aprt of a game loop and I don't want to block the main thread waiting for input data. 
12:02:27 <mauke> you could have an event queue
12:02:39 <Cale> I would expect that you just create a new thread which, in an infinite loop, reads input from the microphone, and shoves it into a Chan or something.
12:02:45 <mauke> every input source pushes events in the queue, and the main thread reads and processes them
12:03:18 <quchen> What's the .cabal setting for providing command line arguments to a testsuite when run? I'd like to give a "--quickcheck-size" argument when running "cabal test", for example.
12:03:26 <martinvlk> Cale, mauke: that sounds like a good way to structure it, great
12:09:58 <martinvlk> quchen, I'd use "cabal help test" to get help
12:10:13 <martinvlk> --PROG-options=OPTS      give extra options to PROG
12:10:42 <martinvlk> I think you can then use the same option in the cabal file
12:11:10 <martinvlk> e.g. --ghc-options="--quickcheck-size=N"
12:11:33 <quchen> But it's not a GHC option, it's the option to the executable to be built by the testsuite build target
12:12:08 <quchen> … which probably has some dummy name? Well, I might as well try using the testsuite as a name for the *options field if nothing else works
12:13:01 <martinvlk> --test-options=TEMPLATES give extra options to test executables (name
12:13:02 <martinvlk>                              templates can use $pkgid, $compiler, $os, $arch,
12:13:02 <martinvlk>                              $test-suite)
12:13:02 <martinvlk>  
12:13:20 <martinvlk> is that it?
12:17:02 <quchen> martinvlk: That looks promising!
12:17:29 <quchen> I wonder where that is in the Cabal user's guide.
12:18:40 <alunduil> :q
12:18:46 <martinvlk> The guide might be incomplete, but I found this with "cabal help test" so it's not so hidden from users..
12:23:52 * hackagebot clckwrks 0.23.13 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.13 (JeremyShaw)
12:38:53 * hackagebot ixset 1.0.6.1 - Efficient relational queries on Haskell sets.  https://hackage.haskell.org/package/ixset-1.0.6.1 (JeremyShaw)
12:48:18 <zaquest> are there any jupyter notebook examples for ihaskell-diagrams?
12:53:54 * hackagebot concurrent-output 1.7.2 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.7.2 (JoeyHess)
13:03:54 * hackagebot binary-typed 1.0 - Type-safe binary serialization  https://hackage.haskell.org/package/binary-typed-1.0 (quchen)
13:08:54 * hackagebot propellor 2.15.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.15.1 (JoeyHess)
13:14:28 <hsk3> https://hackage.haskell.org/package/numbers
13:14:28 <hsk3> Has any of you tried BigFloat or CReal for more accurate calculations than Double?
13:14:38 <hsk3> How does it perform compared to Double?
13:14:50 <hsk3> Should it be used for computationally intensive work?
13:17:43 <amalloy> is there a function for Data.Map like upsert :: Map k a -> k -> a -> (a -> a) -> Map k a? that is, insert at this key if it's not present, and if it is present then combine it with the existing value using some function? you can build it with alter, but that seems rather convoluted for what i'd think is a common operation
13:18:42 <amalloy> i guess you could also use unionWith on a singleton map
13:20:46 <shachaf> "alter (Just . maybe f v)" doesn't seem that bad.
13:21:05 <shachaf> This function isn't in containers, at any rate.
13:22:18 <amalloy> but is that right? maybe wants a function of one arg, and this combining function takes two
13:22:19 <mauke> :t \m k v f -> M.alter (Just . maybe f v) k m
13:22:21 <lambdabot> Ord k => M.Map k a -> k -> (a -> a) -> a -> M.Map k a
13:23:02 <amalloy> oh. that's because i gave the wrong type in my question, right? i said (a -> a) but explained it as "combine the old value with the new one" which should be (a -> a -> a)
13:23:29 <mauke> :t \m k v f -> M.alter (Just . maybe v (`f` v)) k m
13:23:31 <lambdabot> Ord k => M.Map k a -> k -> a -> (a -> a -> a) -> M.Map k a
13:24:27 <amalloy> yeah, but now we're repeating the v. i think i like unionWith better
13:24:45 <amalloy> :t \m k v f -> M.unionWith f $ M.singleton k v
13:24:46 <lambdabot> Ord k => r -> k -> a -> (a -> a -> a) -> M.Map k a -> M.Map k a
13:24:49 <mauke> :t \v f -> M.alter (Just . maybe v (`f` v))
13:24:50 <lambdabot> Ord k => a -> (a -> a -> a) -> k -> M.Map k a -> M.Map k a
13:24:57 <hunteriam> Anyone in ##categorytheory ?
13:26:00 <amalloy> :t \m k v f -> M.unionWith f m $ M.singleton k v
13:26:01 <lambdabot> Ord k => M.Map k a -> k -> a -> (a -> a -> a) -> M.Map k a
13:26:36 <mauke> :t \f -> M.alter . (Just .) . ap maybe (flip f)
13:26:37 <lambdabot> Ord k => (a -> a -> a) -> a -> k -> M.Map k a -> M.Map k a
13:26:41 <maerwald> anyone using conduit here?
13:27:06 <mauke> :t (M.alter . (Just .) .) . ap maybe . flip
13:27:07 <lambdabot>     The operator ‘.’ [infixr 9] of a section
13:27:08 <lambdabot>         must have lower precedence than that of the operand,
13:27:08 <lambdabot>           namely ‘.’ [infixr 9]
13:29:21 <maerwald> sourceDirectory :: MonadResource m => FilePath -> Producer m FilePath
13:29:21 <maerwald> afaiu a Producer is a Conduit too, so why can't I do: sourceDirectory "/" $$ CL.mapM_ putStrLn
13:30:38 <maerwald> I suspect it has to do with the MonadResource class, but there's really no useful documentation in the conduit tutorials about that
13:37:17 <sphinxo> Hi, what does hPutBuf: resource exhausted (No space left on device)  mean?
13:38:33 <mauke> ENOSPC  The device containing the file referred to by fd has no room for the data.
13:38:34 <glguy> I can mean that your disk partition is full
13:39:18 <sphinxo> hmmm
13:48:57 * hackagebot scroll 1.20151219 - scroll(6), a roguelike game  https://hackage.haskell.org/package/scroll-1.20151219 (JoeyHess)
14:02:31 <monochrom> an old person playing a rogue-like game --> elder scroll :)
14:04:03 <monochrom> if Hemmingway lived today, he might write: The Old Man and the Rogue-Like Game
14:09:02 <sphinxo> Recommended package for command line arguments?
14:09:20 <monochrom> optparse-applicative
14:09:43 <monochrom> I have an example at https://github.com/treblacy/random-read
14:09:47 <lispy> sphinxo: this is my go-to for command line option parsing: https://wiki.haskell.org/High-level_option_handling_with_GetOpt
14:10:03 <lispy> the foldl trick is handy
14:10:10 <sphinxo> Ahh thanks
14:14:13 <maerwald> oh jeez, conduit types are really horrible
14:25:59 <maerwald> why is there no: map :: Monad m => (a -> m b) -> Consumer a m b?
15:01:01 <RedNifre> Not sure if that's the right thing to ask here, but is a try catch block (e.g. in Java) equivalent to monadic do-notation?
15:01:40 <monochrom> no
15:01:51 <RedNifre> why not?
15:02:07 <jle`> there is pretty much nothing in common between the two things
15:02:15 <jle`> why would you expect them to be equivalent? :p
15:02:39 <RedNifre> Say if you interpret null as Nothing and you throw an exception when you encounter null, but catch the exception at the end, then this looks a lot like using the do-notation for the Maybe monad.
15:03:46 <monochrom> that is closer, but still no. (where is the "catch"?)
15:03:57 <jle`> that comes from the defined Monad instance's behavior for the Maybe type, though...it doesn't have to do with monads or do notation
15:04:28 <RedNifre> I mean, if you use the do-notation for the Maybe monad, instead of writing "if isJust loadThing then ...." you just write "x <- loadThing" and x will contain the thing or the whole do-notation block stops. Same as in a try-catch piece, you write "val x = loadThing()" and loadThing() either returns what you need or throws an exception, cancelling the whole block.
15:04:44 <jle`> yeah, but that's not becuase of do notation
15:04:49 <jle`> that's because of how (>>=) is defined for Maybe
15:05:02 <monochrom> this is specific to Maybe. or Either.
15:05:03 <jle`> and Maybe, in specific
15:05:14 <jle`> any other type could define (>>=) to do something completely differently
15:05:32 <jle`> sort of like asking of "has four sides" is equivalent to the idea of being a shape
15:05:35 <jle`> or a polygon
15:05:43 <RedNifre> point taken. so try-catch is at least equivalent to using the do-notation for Maybe?
15:05:47 <jle`> and your example is, i see a rectangle and it has four sides.  and a rectangle is a shape.
15:05:54 <RedNifre> I see that it can't be used for lists or IO...
15:05:54 <jle`> so is having four sides equivalent to being a polygon?
15:05:56 <monochrom> still no. where is the "catch"?
15:06:09 <RedNifre> monochrom what do you mean?
15:06:48 <mjburgess> is there some existing function of the kind: andThen :: Monad m => m a -> m a -> m a
15:06:57 <mjburgess> ie., ioA `andThen` ioB = ioA >>= \_ -> ioB
15:07:00 <monochrom> translate Java "try { x; } catch (E e) { y; }" to your Maybe idea. you have nowhere to put the y part.
15:07:07 <jle`> mjburgess: yeah
15:07:11 <geekosaur> :t (>>)
15:07:11 <monochrom> do you know Java?
15:07:12 <lambdabot> Monad m => m a -> m b -> m b
15:07:13 <jle`> it only exists as an operator, though
15:07:16 <jle`> (>>)
15:07:22 <RedNifre> monochrom you wouldn't write y, you would return null.
15:07:31 <mjburgess> ah right, OK
15:07:32 <jle`> mjburgess: or also, (*>) does the same thing
15:07:36 <monochrom> do you know what is a "try-catch block"?
15:07:47 <jle`> except not defined using (>>=)
15:08:05 <RedNifre> monochrom are you asking me?
15:08:06 <jle`> but yeah, 'andThen' is typically (>>), but there isn't a non-operator name for it in the standard libraries
15:08:08 <monochrom> yes
15:08:41 <mjburgess> an operator is what i'd expect, i just couldnt recall if i'd seen one of that kind
15:08:46 <jle`> mjburgess: it's actually a common enough pattern that there's syntactic sugar for it :)
15:08:57 <jle`> do x; y is syntactic sugar for x >> y
15:09:31 <RedNifre> I understand it as a surrounding for multiple sequential statements of which at least 1 may throw an exception instead of returning a value, which can be caught, and there's also a "finally" part which isn't relevant here.
15:09:36 <RedNifre> what are you getting at?
15:09:52 <monochrom> a try-catch block includes the y part.
15:10:19 <monochrom> if you have nowhere to put the y part, you don't have an equivalence with a try-catch block.
15:10:24 <monochrom> it's almost tautological.
15:11:00 <RedNifre> Okay, sure, in that case I guess you would be emulating Either?
15:11:08 <RedNifre> yes, "equivalent" was the wrong word.
15:11:29 <monochrom> that doesn't help. where will you put the y part?
15:11:47 <RedNifre> I think I meant that you can build something that is equivalent to a Maybe do-notation using try-catch, not that they are the same.
15:12:20 <RedNifre> I think there is an "orElse" function for Maybe. I need to check the name.
15:12:30 <RedNifre> Ah, I think it was "fromMaybe"?
15:12:46 <RedNifre> as in "fromMaybe y do ..."
15:12:53 <RedNifre> (if that's valid syntax)
15:13:05 <monochrom> by the time you move off to fromMaybe, you also move away from do-notation
15:13:31 <monochrom> and I predict that in the future you are just doing a moving-goal-post.
15:13:44 <RedNifre> not sure what your point is here.
15:14:06 <monochrom> my point is justifying why I answer no
15:14:41 <monochrom> by being precise, concrete, and critical
15:15:46 <RedNifre> But I already said that "try-catch = do" was inaccurate and what I meant was "you can build something that '= do Maybe' using try-catch"?
15:16:31 <RedNifre> Just to clarify, did you agree or disagree with the idea that you can build something using try-catch that is like using do-notation for Maybe?
15:16:50 <geekosaur> not really since Maybe short-circuits on failure
15:16:56 <Majiir> If you want a better comparison, look at C#'s LINQ query syntax. In many ways it's similar to do-notation, although it's obviously missing some important things.
15:17:03 <RedNifre> same as exceptions?
15:17:04 <geekosaur> you have to go outside the monad interface to do something else on Nothing
15:17:19 <geekosaur> if you want to catch an exception, there is Control.Exception.catch
15:17:31 <geekosaur> foo `catch` \e -> handler
15:17:37 <RedNifre> geekosaur, no I meant try-catch in something like Java here.
15:18:05 <geekosaur> and you don't need a "try" keyword for that
15:18:28 <monochrom> if you go the direction "translate Maybe do-block to Java try-catch block", you end up with only a Java try-block.
15:20:08 <RedNifre> e.g. "<A> A bind(A a) throws BindingException { if(a == null) throw new BindingException() else return a}" in combination with "try { String x = bind(maybeLoadX()); String y = bind(maybeLoadY()); return "Hey "+x+y; } catch(BindingException e) { return null; }"
15:21:25 <RedNifre> monochrom well, no, you need the catch to handle the short-circuit on failure. And you need that special bind method to emulate "<-", otherwise you get a null in the variables.
15:22:40 <RedNifre> Is "bind" the right word for "<-"? Or what's the right way to pronounce "<-"?
15:26:06 <monochrom> if I translated Maybe do-block to Java, I would not bother with "test for null, only to throw an exception, only to catch it myself, only to return null". what an XY problem. I would simply let the NullException happen implicitly
15:26:46 <monochrom> in fact, s/XY problem/XYXY problem/
15:37:26 <RedNifre> monochrom I don't know the term XY problem, what does that mean?
15:37:56 <RedNifre> Also, you can't let the nullpointer exception happen implicitely, e.g. if you put the null into a list that you return.
15:41:39 <quchen> RedNifre: "<-" desugars to ">>=", so it's alright to call it bind
15:42:16 <RedNifre> quchen I thought it desugars to ">>= \" as in nested lambdas?
15:42:24 <quchen> We don't usually call "<-" a name though, it's syntax from do-notation that doesn't really have a name. We say "x <- foo" to "x is bound the result of the action" or something like that though.
15:42:58 <quchen> do x <- comp; rest   ===>   comp >>= \x -> rest
15:43:06 <quchen> do rest*
15:44:44 <quchen> I don't think it's fruitful to compare Java's exceptions with Maybe.
15:45:12 <RedNifre> Regarding XY problem: Yes, sort of. My code started with deeply nested "val x = getMaybeX; if(x.isPresent()) {...". In many languages, promises are used to remove this nesting, but I find it horrible to read "getMaybeX().then { x -> ...; getMaybeY() }.then", I was missing Haskell's do-notation. Then I noticed the similarity between do-notation and throwing an exception.
15:45:17 <RedNifre> quchen yeah, seems like it.
15:45:53 <quchen> do-notation is just notation. When you say "do-notation" what you probably mean is "the behaviour of the Maybe Monad".
15:46:05 <RedNifre> no, I don't, I really mean just notation.
15:46:17 <quchen> Then no, Java has nothing even remotely similar to it.
15:47:31 <Majiir> Throwing it in there again, C# does! :-)
15:47:49 <quchen> That new ?. thing?
15:47:53 <RedNifre> now I'm not sure if I should ask why you say that try-catch is not even remotely similar to do-notation, given that it might not be fruitful ;)
15:48:13 <RedNifre> Kotlin has ?. as well but I wouldn't see that as do-notation.
15:48:13 <quchen> You cannot catch in the Maybe Monad.
15:48:38 <Majiir> No, LINQ is pretty similar to do-notation.
15:48:58 <RedNifre> quchen okay, right, again, I meant achieving a notation that is like do in haskell, not the other way around.
15:48:58 <Majiir> 'from a in b select c' is equivalent-ish to 'do a <- b; c'
15:49:41 <quchen> That looks pretty list-y.
15:49:49 <Majiir> It's not really useful to treat LINQ the same as do-notation most of the time because you can't enforce purity, and because LINQ is ducktyped--but it's a better comparison than in Java.
15:50:18 <quchen> Comparing do-notation with any language that doesn't have full-blown monads is not a good comparison.
15:50:32 <RedNifre> In kotlin you have getMaybeX()?.let { x -> getMaybeY() }?.let { y -> ...} which is like getMaybeX >>= \x ->...
15:50:51 <RedNifre> Yeah, I'm only comparing it to the Maybe monad, it doesn't work for the List monad or IO or pretty much anything else.
15:50:52 <quchen> do-notation's point is being a nice interface to writing monadic code. When you want to talk about the Maybe Monad then call it "maybe-do-notation" or something.
15:51:20 <RedNifre> I think I called it "do-notation for Maybe"... well, gotta go now.
15:51:27 <Majiir> quchen, it works for arbitrary monads. There's a library for doing monadic IO, parsec-style parsing, etc. It's just that for something to 'be a monad' in C#, it merely needs to have a SelectMany method with the right signature (same as >>=) and there's no static interface
15:51:39 <RedNifre> Thanks for the discussion, have a good night.
15:51:49 <Majiir> And of course it's just silly to use for things like IO
15:51:51 <quchen> Ah, so "selectMany" is C#'s "flatMap"?
15:52:02 <Majiir> Yes.
15:52:16 <quchen> Sounds like a strange name.
15:52:30 <quchen> I guess it works as a name for the List Monad.
15:53:17 <Majiir> Yep, and 'Select' is 'map'. It's supposed to be analogous to SQL, I think.
15:53:48 <quchen> I'm quite happy with names like "bind", because they're at least not wrong when they don't mean anything ;-)
15:56:21 <Majiir> https://github.com/louthy/csharp-monad for some examples of how it can be used. It's an interesting factoid but most C# devs wouldn't know what the hell is going on if they saw it.
15:57:28 <quchen> Is Either usable in C#? I miss it in Java a lot.
15:58:35 <quchen> I mean you can certainly implement Either<L,R>, but it's so painful to use that you quickly give up.
15:58:50 <quchen> (Due to the lack of type inference and all that.)
15:59:09 <Majiir> Outside of the example in the link above? Not really. There's ?? and .?, and you could write your own type... such is everything in C#
16:00:03 <Majiir> There is type inference, it's just not as good
16:00:50 <quchen> Usually, the nail in the coffin for "monads elsewhere" is that they can have examples of monads, but not monads themselves
16:04:39 <Majiir> You could write an IMonad<T> interface that would mostly do the trick. It's not in the framework, so you couldn't easily constrain on monads between projects... but nobody uses monads that way in C# anyway so not much is lost.
16:05:31 <quchen> How does `return :: Monad m => a -> m a` look like?
16:06:37 <quchen> I'm not familiar with C# at all, but I haven't heard of any popular language that had return type polymorphism
16:08:38 <Majiir> You would write something like 'M Return<A, M> (A a)' or maybe 'IMonad<M> Return<A, M> (A a)' but the question is *where* you put that. It needs to be static.
16:09:04 <Majiir> For the former case you could add a 'where M : IMonad<M>' constraint
16:09:31 <Majiir> Or IMonad<M,A> rather...eh it would get funky
16:11:07 <Majiir> In the end you would probably define something like Monads.Return<M,A> and then use reflection magic to implement it. Not all that elegant.
16:17:44 <fsdude> o/
16:17:49 <fsdude> potato
16:26:02 <echo-area> I just realized that the portability flag was supposed to be among various Haskell compiler implementations instead of OSes, sigh.
16:27:24 <monochrom> :)
16:28:41 <geekosaur> well, both. there are things that use portability to indicate "only works on posix systems"
16:29:04 <geekosaur> (possibly they shouldn't, but in that case we probably *do* need a platform portability indicator somewhere)
16:29:38 <geekosaur> (because there are certainly packages that only work on posix and there's the occasional package that only works on windows)
16:30:07 <echo-area> I think a separate flag is clearer
16:30:17 <geekosaur> (and one or two that are OS X only, notably the cocoa and applescript bindings)
17:18:53 <maerwald> is there anything more mature than fsnotify?
17:19:23 <maerwald> gnome-vfs looks terribly old, kqueue doesn't work on linux
17:34:02 <mjburgess> any reason there isnt a monoid instance for Int?
17:34:12 <shachaf> Lots of options.
17:34:46 <mjburgess> oh right, i se
17:34:48 <mjburgess> *see
17:34:52 <geekosaur> when you say "monoid instance for Int", do you mean (0,+) or (1,*)? or something else?
17:35:14 <mjburgess> i *meant* (0,+) but i see that i was mistaken to mean it :)
17:35:15 <geekosaur> so there are newtypes for those two (Sum and Product)
17:36:09 <pavonia> > getSum $ Sum 1 <> mempty <> Sum 2
17:36:11 <lambdabot>  3
17:36:35 <exio4> > getSum $ 1 <> mempty <> 2
17:36:37 <lambdabot>  3
17:36:41 <mjburgess> what is <>  ?
17:36:53 <geekosaur> mappend, as an operator
17:36:54 <mjburgess> presumably mappend? imported from where?
17:36:56 <exio4> mjburgess: (<>) = mappend 
17:37:04 <geekosaur> recent versions of base have it
17:37:08 <mjburgess> oh right
17:37:19 <geekosaur> @index (<>)
17:37:19 <lambdabot> Data.Monoid, Text.PrettyPrint.HughesPJ, Text.PrettyPrint.HughesPJClass, Text.PrettyPrint, Language.Haskell.TH.PprLib
17:37:47 <geekosaur> I don't think it's going in Prelude? because of prettyprinters that already use it
17:38:10 <geekosaur> good syntax is getting hard to find >.>
17:42:03 <lambda-11235> Sorry >.> is already taken.
17:42:08 <lambda-11235> :)
17:51:34 <tnecniv> hi
17:54:51 <johnw> tnecniv: welcome
17:59:11 * hackagebot phoityne 0.0.1.0 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.1.0 (phoityne_hs)
18:09:11 * hackagebot hackage-whatsnew 0.1.0.0 - Check for differences between working directory and hackage  https://hackage.haskell.org/package/hackage-whatsnew-0.1.0.0 (JeremyShaw)
18:24:34 * hackagebot clckwrks-plugin-page 0.4.3 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3 (JeremyShaw)
18:34:48 <Gurkenglas> So, all this time, there already was a thing that sets up everything Haskell for you in a vm, bypassing most possible OS-specific problems, namely "docker"? :(
18:37:35 <maerwald> huh?
18:37:46 <maerwald> docker is not virtualization and even less OS-agnostic
18:38:56 <Gurkenglas> maerwald, https://docs.docker.com/engine/installation/windows/ I'm looking at the fourth image here (second non-screenshot graphic)
18:39:34 <maerwald> I use docker for production, I know what it is
18:40:04 <Adeon> it feels wrong to me that there is a docker for windows that's really just a linux vm that then actually runs docker
18:40:14 <Adeon> but maybe it's just me
18:40:55 <maerwald> docker is really unrelated to virtualization, but ofc you can run it inside a VM (like anything else)
18:41:36 <Gurkenglas> Adeon, when what you're trying to use it for isn't hurt by a 20% slowdown, that's worth not having to support every OS for every thing you want docker to be able to work with
19:07:51 <nilg> Where to find the documentation about building list like [1..10]?
19:08:53 <shachaf> Haskell 2010 report, section 3.10
19:18:19 <DANtheBEASTman> hi, so, i'm trying to `cabal install ghc-mod` and I get the following errors: http://sprunge.us/gEjO I have no idea what I'm doing lol  
19:19:51 <coercively> Hello. I was here a few days ago for a suspected hardware issue (random, I know)
19:20:05 <coercively> but you guys seem more helpful than others and sooo
19:20:36 <coercively> I did what you guys said, to f with cmos and input settings myself
19:20:56 <coercively> still getting "cmos checksum bad"
19:21:26 <coercively> computer hasn't had internet access since 2008 so I'm fairly positive this is a cmos battery issue
19:23:14 <Xe> I'm getting a bizarre error when using Persistent. I have been copying code out of the (now out of date) documentation and i got "(Only one type can be given in an instance head. Use MultiParamTypeClasses if you want to allow more, or zero.)" when trying to compile my models file
19:23:38 <Xe> https://gist.github.com/Xe/13fb1eee5049669a95e3 <-- the code
19:24:11 <lpsmith> maerwald, if you are only interested in linux,  you might be interested in linux-inotify
19:24:30 <maerwald> lpsmith: I ended up looking at gio, but those are just bindings
19:25:07 * hackagebot deepcontrol 0.5.4.3 - A library that provides deep-level programming style and(or) notation on Applicative and Monad  https://hackage.haskell.org/package/deepcontrol-0.5.4.3 (KONISHI_Yohsuke)
19:25:26 <lingxiao> hey all
19:25:46 <lingxiao> I want to declaer some MonadState instance so that it there are two "layers", one keeps an int and another keeps a string
19:26:28 <lingxiao> ie foo :: StateT String (State Int) ()
19:26:43 <lingxiao> but it'd be nice if this is generic, I'm not sure how to express it using MonadStateT
19:26:46 <lingxiao> MonadState*
19:32:08 <lingxiao> ping
19:33:36 <lingxiao> nvm!
19:40:08 * hackagebot frontmatter 0.1.0.0 - Parses frontmatter as used in Jekyll markdown files.  https://hackage.haskell.org/package/frontmatter-0.1.0.0 (yamadapc)
19:45:08 * hackagebot frontmatter 0.1.0.1 - Parses frontmatter as used in Jekyll markdown files.  https://hackage.haskell.org/package/frontmatter-0.1.0.1 (yamadapc)
19:49:56 <bitemyapp> @pl (integer >>= (\i -> eof >> return i))
19:49:56 <lambdabot> (eof >>) . return =<< integer
19:50:08 * hackagebot frontmatter 0.1.0.2 - Parses frontmatter as used in Jekyll markdown files.  https://hackage.haskell.org/package/frontmatter-0.1.0.2 (yamadapc)
19:56:39 <brh> 
19:57:43 <brh> Hello
20:00:15 <brh> Has anyone here used the Turtle library for writing shell scripts?  I'm trying to figure out what the best way to call another program and get a [String] result from the lines collected during the execution of that program.
20:01:05 <brh> so far I'm playing around with: let res = inshell "ls -l | grep foo" empty
20:01:21 <brh> and then I can print that with "stdout res"
20:01:35 <brh> but is there an easy way to lift it out of the Shell type into something simple like [String] ?
20:03:30 <dmj> System.Process is pretty easy
20:05:16 <hunteriam> Is dependant typing defined categorical
20:05:20 <hunteriam> Categorically
20:20:52 <nilg> thanks a lot shachaf
20:40:11 * hackagebot pipes-concurrency 2.0.4 - Concurrency for the pipes ecosystem  https://hackage.haskell.org/package/pipes-concurrency-2.0.4 (GabrielGonzalez)
20:45:44 <brh> 
20:50:25 * hackagebot projectroot 0.2.0.1 - Bindings to the projectroot C logic  https://hackage.haskell.org/package/projectroot-0.2.0.1 (yamadapc)
20:55:26 * hackagebot time 1.6 - A time library  https://hackage.haskell.org/package/time-1.6 (AshleyYakeley)
21:12:08 <brh> save
21:30:28 * hackagebot niagra 0.1.0 - CSS EDSL for Haskell  https://hackage.haskell.org/package/niagra-0.1.0 (natesymer)
21:35:28 * hackagebot vrpn 0.2.0.0 - Bindings to VRPN.  https://hackage.haskell.org/package/vrpn-0.2.0.0 (BrianBush)
22:01:49 <Pamelloes> When I used (***) I was told bimap is preferred these days. Is there an alternate for (&&&) that's in vogue?
22:03:24 <shachaf> Maybe liftA2 (,) in some cases.
22:03:43 <shachaf> But probably not.
22:08:38 <Pamelloes> Is there a Maybe xor function: Just a `xor` Nothing = Just a; Nothing `xor` Just a = Just a; Nothing `xor` Nothing = Nothing; Just a `xor` Just b = Nothing?
22:09:20 <shachaf> Hmm, I don't think I've seen that.
22:09:46 <Pamelloes> Yeah, it's a pretty weird use case. I'll just write it myself :)
22:15:37 * hackagebot turtle 1.2.4 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.4 (GabrielGonzalez)
22:25:43 * hackagebot sdr 0.1.0.6 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.6 (adamwalker)
22:50:44 * hackagebot ndjson-conduit 0.1.0.3 - Conduit-based parsing and serialization for newline delimited JSON.  https://hackage.haskell.org/package/ndjson-conduit-0.1.0.3 (srijs)
23:08:20 <lambda-11235> Does hackagebot report only new packages to hackage, or does it report preexisting ones as well?
23:09:32 <cocreature> lambda-11235: it reports new versions so if an existing package uploads a new version it reports them as well
23:43:58 <jle`> is it considered acceptable now to just put "see README.md" in cabal description fields
23:44:03 <jle`> since README's are displayed on Hackage
23:46:06 <bitemyapp> jle`: I think so, but not everyone will agree.
23:46:22 <jle`> hm
23:53:57 <Guest27795> hmm.. I'm currently writing a hs roguelike
23:54:20 <Guest27795> and I'm trying to abstract away the randomization (basically just "seed" within a state)
23:55:02 <Guest27795> but I have 2 main monads right now - GameState (StateT Game Renderer) and DungeonState (ReaderT Level (State Dungeon))
23:55:29 <Guest27795> trying to figure out how to consilidate randomization, since everything is currently hardcoded within the GameState (which has the "seed" on board in the Game data type)
23:56:04 <Guest27795> would it make sense, to add (yet another) State of something like "State StdGen" and both of these monads would transform over that as well?
23:56:17 <Guest27795> just sounds like quite a burrito and not sure if I'm going with the right approach...
23:56:24 <nshepperd_> Pamelloes: out of curiosity, what's your use case? note that your xor there is non-associative
23:56:47 <jle`> Guest27795: you could use the RandT monad transformer
23:56:50 <jle`> in the MonadRandom library
23:56:58 <jle`> and just forget about "State StdGen" altogether
23:57:15 <jle`> having multiple layers of state is also a little unweildy
23:57:41 <nshepperd_> but you can make it associative with the addition of a Top! data Xor a = Bottom | Just' a | Top
23:57:45 <jle`> if you had StateT s (State t) a, better to just have State (s, t) a, and use tools to let you use State s a's and State b a's for both of them
23:57:56 <nshepperd_> which is a join semilattice
23:58:04 <jle`> (they come automatically with the `lens` library)
23:58:18 <jle`> but for the particular case, I'd probably let RandT abstract away the randomness/StdGen part
23:59:02 <Guest27795> hmm ok thanks jle` I'll look into RandT
23:59:14 <Guest27795> still haven't wrapped my head around lenses, but pursuing that as well
23:59:35 <jle`> doing what i mentioned doesn't really involve understanding lenses in its entirety
23:59:53 <jle`> but, if you have State s a and State t a, and you wanted to use them both in a mega-monad State (s, t) a
