00:07:38 * hackagebot simpleirc-lens 0.2.0.0 - Lenses for simpleirc types  https://hackage.haskell.org/package/simpleirc-lens-0.2.0.0 (RickyElrod)
00:07:38 * hackagebot resolve-trivial-conflicts 0.3.2.1 - Remove trivial conflict markers in a git repository  https://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.2.1 (EyalLotem)
00:07:38 <tnecniv> Cale actually, take a look at this peculiar error real fast?
00:07:45 <Cale> sure
00:09:17 <tnecniv> http://lpaste.net/554349101022445568
00:09:20 <tnecniv> is my main function
00:10:06 <tnecniv> compiling gives the error
00:10:08 <tnecniv> main.hs:188:24:
00:10:08 <tnecniv>     No instance for (Ix R) arising from a use of ‘listArray’
00:10:09 <tnecniv>     In the expression:
00:10:09 <tnecniv>       listArray ((0, 0), (pixelWidth - 1, pixelHeight - 1)) pixels
00:10:15 <tnecniv> sorry for spam but it's quiet
00:10:28 <tnecniv> where as if you make the change in the paste, it compiles no problem
00:10:59 <sgronblo> Hey, why is Haskell whining about "irrefutable pattern" in this expression: let [smallSideA, smallSideB] = sort [l, w, h] ?
00:11:22 <lamefun> I think I know why people like imperative programming so much... http://lpaste.net/563031235677388800 -- this is hideous? Any way to fix?
00:12:21 <Cale> sgronblo: It's very unlikely that sorting a list of three elements is really going to match a pattern for a two element list.
00:13:01 <Cale> sgronblo: Since you let bound the thing, the pattern match is deferred until you actually evaluate one of the bound variables: smallSideA or smallSideB.
00:13:16 <sgronblo> Cale: Ah right, I was being stupid
00:13:45 <Cale> (at which point it fails, and you get the error you were seeing)
00:13:59 <Cale> tnecniv: Okay, let's start by adding some type signatures
00:14:08 <Cale> tnecniv: What's the type of pixels?
00:14:29 <Cale> oh, also pixelHeight
00:14:37 <Cale> I take it pixelHeight :: R ?
00:14:39 <Cale> What is R?
00:14:41 <tnecniv> Cale [PixelRGBF]
00:14:47 <tnecniv> Short hand for float
00:14:51 <tnecniv> dont ask
00:14:56 <tnecniv> i need to remove it
00:14:57 <Cale> ah, can't index an array by Float
00:15:23 <tnecniv> oh i see
00:16:09 <Cale> I think this gets at why you were having problems before, if floating point arithmetic is being used even indirectly to determine how to index into the list or array :)
00:16:17 <tnecniv> Cale wait, then why does it matter if density is hard coded on that one line or not
00:16:35 <Cale> hm?
00:17:02 <Cale> Well, all of these definitions have types, even if you're not writing them...
00:17:10 <tnecniv> of course
00:17:56 <Cale> If pixelWidth is ending up as a Float, then so must pixelDensity and planeWidth
00:18:25 <Cale> If you give explicit type signatures to these definitions, the compiler will report better errors
00:18:39 <tnecniv> ah
00:18:40 <tnecniv> yes
00:18:50 <tnecniv> i added floor at appropriate places and it works
00:18:56 <Cale> aha, okay
00:19:30 <Cale> also try writing  imageArray :: Array (Integer, Integer) PixelRGBF
00:19:53 <Cale> (or (Int, Int) possibly)
00:20:19 <Guest00000> lamefun: Gtk.mainIteration >>= (`when` throwIO (userError ...)); ...
00:21:21 <tnecniv> Cale thanks for the help
00:21:26 <Cale> (I'm not sure, it may help performance if the monomorphism restriction is turned off.)
00:22:29 <Cale> no problem
00:24:25 <tnecniv> Cale last question: since i am going from 1D to 2D for the domain when i go from the list to the array, how is listArray determining the mapping?
00:24:38 <Cale> Just row by row
00:24:48 <tnecniv> so the third element becomes (0, 3)?
00:24:54 <Cale> yeah
00:25:03 <tnecniv> ok, cool
00:25:06 <Cale> If you want to be more particular about it, you can use array instead, which takes a list of (index,element) pairs
00:25:31 <Cale> (array instead of listArray)
00:26:56 <tnecniv> i see
00:27:00 <tnecniv> thanks
00:27:04 <Guest00000> also there should be a library which simplifies working with iorefs..
00:28:30 <tnecniv> Cale or i guess the third element should be (3, 0) is what i meant
00:28:54 <Cale> tnecniv: 3th
00:29:05 <Cale> (counting from 0)
00:29:13 <tnecniv> yeah
00:29:17 <sgronblo> How to figure out a problem with non-exhaustive patterns?
00:29:17 <tnecniv> fixed my bug
00:29:19 <tnecniv> thanks again
00:29:21 <tnecniv> good night
00:29:44 <Cale> Prelude Data.Array> listArray ((0,0),(3,3)) [0..]
00:29:44 <Cale> array ((0,0),(3,3)) [((0,0),0),((0,1),1),((0,2),2),((0,3),3),((1,0),4),((1,1),5),((1,2),6),((1,3),7),((2,0),8),((2,1),9),((2,2),10),((2,3),11),((3,0),12),((3,1),13),((3,2),14),((3,3),15)]
00:29:59 <sgronblo> This seems exhaustive to me... where go [] _ = [] go (d : ds) (prevX, prevY)
00:30:28 <Cale> sgronblo: What's the error?
00:30:47 <sgronblo> The second go has some definitions using guards under that row
00:31:05 <sgronblo> Cale: "Non-exhaustive patterns in function go"
00:31:15 <Cale> Is the last guard "otherwise"?
00:32:27 <Guest00000> lamefun: i would refactor that code into using maybeReadIORef :: IORef a -> (a -> IO b) -> IO b -> IO b -- this function  may or may not exist in some library
00:33:40 <sgronblo> Cale: nope
00:34:01 <Cale> sgronblo: The most likely thing then is that the list is nonempty and none of the guards succeeded
00:34:39 <sgronblo> but if its non-empty it should match the second with go (d : ds) (prevX, prevY) shouldnt it?
00:34:57 <Cale> sure
00:35:07 <Cale> but then if none of the guards succeed, that pattern match still fails
00:35:16 <Guest00000> maybeReadIORef ref f def = readIORef ref >>= maybe def f
00:35:19 <Cale> and it goes on to the next pattern
00:35:27 <Cale> if there is no next pattern, you get that error
00:35:37 <sgronblo> but i cant figure out which case could be missing?
00:35:48 <sgronblo> oh right
00:35:51 <Cale> I can't help you with that if I can't see the guards
00:36:15 <Cale> The guards are part of the pattern match
00:36:21 <sgronblo> Cale: I think I figure it out now, I'm sure it's the new line character which I forgot is included in the string.
00:36:39 <Guest00000> oh, readIORef returns (IO a), so type of maybeReadIORef is actually IORef (Maybe a) -> ...
00:37:07 <Guest00000> (these exercises are fun...)
00:52:57 <lamefun> IMPERATIVE control structures are the best!
01:06:13 <Guest00000> argument.
01:06:31 <wowdog_> hi, anyone konw why  1:2:3[]  output [1, 2, 3] but not [3, 2, 1] ?
01:07:19 <wowdog_> I assume (1:(2:(3:[])))?
01:07:20 <pavonia> Because (:) prepends a new element to a list
01:07:24 <thimoteus> first you cons 3 with [], producing [3], then 2 with [3] producing [2,3], then 1, producing [1,2,3]
01:08:04 <thimoteus> actually isnt [1,2,3] sugar for 1:(2:(3:[]))?
01:08:25 <pavonia> It is
01:09:09 <wowdog_> thanks to clarify it, I'm new to Haskell.
01:14:22 <wowdog_> let xs = [1..10], 100:[x | x <- xs, x < 5],  output [100,1,2,3,4], it means the : precedence is higher then list comprehensions?
01:14:31 <potatoe> wowdog_ keep us company in #haskell-beginners 
01:16:42 <wowdog_> sorry, it should be opposite
01:19:16 <jle`> wowdog_: yes, it's 100 : ([x | x <- xs, x < 5]), roughly
01:19:55 <pavonia> What other interpretation would there be?
01:42:16 <lamefun> Is there reverse let? eg. in xxx let yyy?
01:43:45 <Guest00000> oh yeah
01:43:59 <Guest00000> i always wondered why let and where work differently
01:47:10 <lamefun> Well, I mean, where and let look like they're for two opposite cases: let where the bindings are small and the body is huge, where when it's the opposite.
01:48:07 <Guest00000> "why let and where work differently" i mean - why can't i use why anywhere, not just in top-level decls
01:49:09 <Guest00000> why can't i use where *
01:50:03 <lamefun> because: func x y z = something u $ \a -> u i o where u = ...  --- should it compile or not? (i.e. is where for lambda or the whole function
01:50:57 <pavonia> Guest00000: You can also use them in local declarions
01:51:21 <lamefun> I think it should have been: let should've worked both ways (let .. in ..., and in .. let ...), no where with its stupid rules.
01:52:27 <Guest00000> lamefun: that can be solved easily with a parsing rule. consider f = x $ \a -> y :: Type -- is type annotation for f or the lambda?
01:53:17 <Guest00000> -- that construction already exists in the language
01:53:41 <lamefun> Well
01:54:08 <lamefun> The spirit of true Design is weak with haskellers: https://www.reddit.com/r/haskell/comments/3x0mqn/the_zen_of_haskell/cy0v5lp
01:56:20 <lamefun> still hideous: http://lpaste.net/5301984900386127872
02:03:20 <wowdog_> can anyone give some suggestion whether to learn Haskell or Closure?
02:06:22 <demize> wowdog_: Depends on whether you want a Lisp that primarily runs on the JVM, or a purely functional AOT compiled language.
02:06:22 <wowdog_> My boss told me Haskell is not practical language, it is useless in real world. does anyone have any opinion? My boss have 20+ years in software dev
02:06:44 <demize> Haskell is plenty useful, and there are quite a few companies that have started using it even.
02:06:48 <jle`> i think it's pretty useful in the real world
02:06:55 <jle`> i use it for real world work and i know a lot of people that do, as well
02:07:03 <jle`> in fact, it's the only language i'd feel comfortable using for real work
02:07:17 <jle`> no other language offers the same kind of fast prototying and maintainability/refactorability as haskell does
02:07:31 <jle`> trying to maintain a project for over a few months in ruby, python, java, etc. is a nightmare
02:07:37 <demize> It /is/ quite different from most other languages though, so learning it would quite possibly be more work than learning Clojure.
02:07:41 <jle`> so many tests, and unexpected things that can happen on refactoring
02:07:47 <jle`> that won't show up until runtime at the worst times
02:08:02 <jle`> haskell is the only code i feel comfortable maintaining and refactoring two, three years down the line
02:08:27 <demize> jle`: I really don't understand how some people consider not having anything that could reasonably be called a proper type system to be a good thing :|
02:08:29 <jle`> when correctness, maintainability, and fast prototyping is a priority, there isn't anything else i'd feel comfortable choosing over haskell
02:09:28 <jle`> no language has those three things as strongly as haskell does, I feel
02:10:19 <Guest00000> hm.. what language would have correctness and fast prototyping?
02:10:38 <jle`> demize: they are probably scarred from java and feel like type system = less productive
02:10:46 <jle`> but in haskell, type system => more productivity
02:11:03 <demize> jle`: Java => less everything good. ;p
02:11:11 <demize> But I guess that's one possibility.
02:11:14 <jle`> they probably feel "liberated" by ruby and python, heh, where they can write all the uncorrect code they want
02:11:18 <jle`> and nobody will stop them
02:11:26 <demize> It just really surprises me when people say things like it..
02:11:27 <wowdog_> Does Haskell a bit slow in REAL WORLD application?
02:11:33 <jle`> they can write uncorrect and unmaintainable code 200% faster! :O
02:11:46 <jle`> wowdog_: haskell is actually much faster, both in development time and performance, than most other platforms
02:12:11 <jle`> it'll outperform python and ruby easily, and many times java
02:12:27 <Guest00000> lamefun: look at your paste... (i added a bit more concise but less clear variant)
02:16:11 <Guest00000> (inline the function and you will get even more concise, less clear variant)
02:17:46 <SX> Hello!
02:17:53 <Guest00000> hi SX
02:17:58 <SX> Is it possible to use `stack` offline?
02:18:28 <SX> Like place all needed packages in some directory and use it as repo? Like `pip` does.
02:53:18 <roelof> how can I quickcheck test this code ( http://lpaste.net/147829) the best ?  or is this impossible ? 
02:56:26 <Guest00000> huh
02:56:43 <Guest00000> 0 matches both positive and negative zero?
03:01:42 <roelof> Guest00000:  why do you find this wierd. As far as I understand positive zero and negative zero does not exist. There is only zero which is not positive or negative 
03:03:06 <Guest00000> roelof: positive and negative zeros do exist when we work with Float values. and sometimes we work with Float values in haskell
03:04:11 <Freundlich> roelof: "does not exist" doesn't make much sense in this context.
03:04:16 <roelof> Guest00000:  oke, learned another thing. I look at it on the math's way 
03:04:39 <Freundlich> Wha's "the math's way"?
03:04:42 <Freundlich> *What's
03:05:19 <roelof> I explained it in the last sentence. As far as I know zero is not postive and not negative 
03:06:09 <Freundlich> I got that part. It seems you assume that in mathematics there is "one right definition" and therefore "negative zero does not exist".
03:07:08 <roelof> Freundlich:  yep, that is what I mean 
03:08:01 <roelof> but if I mistaken , I apolize
03:08:05 <Freundlich> Maybe it just was an unfortunate choice of words.
03:08:27 <roelof> I think so 
03:10:01 <kqr> is there a library that will let me open a tcp connection to a (domain, port) combination without forcing me to do a lot of low-level socket plumbing? similar to conn = socket.socket('www.google.com', 80) in Python
03:10:13 <roelof> but someone who can help me with my own problem. QuickCheck a function 
03:14:10 <linduxed> would finding out how many True there are in a [Bool] best be done with a fold or a `length . filter (== True)`?
03:15:30 <pavonia> roelof: What doy you want to quickcheck there?
03:17:15 <jle`> linduxed: (== True) = id :)
03:17:15 <pyon> A question about the Day convolution in Haskell specifically. In `kan-extensions`, it's given as `data Day f g a = forall b c. Day (f b) (g c) (b -> c -> a)`. Wouldn't it be equivalent to define it as `data Day f g a = forall b. Day (f (b -> a)) (g b)`?
03:17:46 <jle`> linduxed: fallin' for the old if x == True then ... else ... business ;)
03:17:48 * hackagebot slug 0.1.0 - Type-safe slugs for Yesod ecosystem  https://hackage.haskell.org/package/slug-0.1.0 (mrkkrp)
03:18:13 <roelof> pavonia:  Because I want to test it against a lot of values. I could make a Hunit test but I know that is always a success 
03:18:16 <linduxed> jle`: damn, good thing you caught me
03:18:20 <linduxed> :-)
03:18:38 <jle`> don't worry, it's a super common thing heh
03:19:36 <roelof> pavonia:  and I just wonder if it's can. Im still learning Haskell and QuickCheck and Hunit 
03:19:37 <kqr> one too many times I've gone from    if x == True then True else False    to    x == True ? True : False     to     x == True     to     x
03:20:03 <pavonia> roelof: You should probably split the function into two, one for calculating the intersection with the x axis, and a second one for the output message. Then you can run the quickcheck on the first function
03:21:08 <roelof> pavonia:  oke, I can change it to that, The only thing I have to figure out how to deal with no intersection 
03:21:39 <kqr> maybe conduit network stuff is what I want
03:22:06 <pavonia> roelof: Have a result type that can represent all three cases
03:23:25 <roelof> So maybe a new datatype  Result = | None | One | All   
03:24:17 <pavonia> With a parameter for the resulting point, yes
03:24:55 <jle`> linduxed: the ideal best way would be to never have a [Bool] in the first place/skip it, but if you already have one or if the [Bool] is meaningful, then yeah, i'd do length . filter id
03:25:17 <jle`> but only after thinking hard about why i even have a [Bool] in the first place
03:25:24 <jle`> :)
03:25:44 <roelof> oke, only One has a resulting point. None means there is no resulting point and All means a infinitive number of points 
03:25:49 <Guest00000> jle`: but maybe the "filter (== True)" is more readable?
03:26:39 <jle`> i guess that's a subjective call
03:26:40 <roelof> I thought this is a easy exercise of the Craft book but it seems it's very difficult 
03:26:51 <Guest00000> and also restricts type without annotation (a bit nicer to read), that could be useful in some polymorphic places
03:26:59 <jle`> `filter id` is sort of instantly readable to me
03:27:11 <jle`> filter id is already unambiguous
03:27:12 <jle`> :t filter id
03:27:14 <lambdabot> [Bool] -> [Bool]
03:27:21 <Guest00000> ...
03:27:29 <jle`> :t filter
03:27:32 <lambdabot> (a -> Bool) -> [a] -> [a]
03:27:37 <Guest00000> why did i think so...
03:28:24 <jle`> still, `filter id` isn't the best thing in the world and is a little awkward, which is why the best route would be to avoid having the [Bool] in the first place
03:28:41 <roelof> pavonia:  Is this is what you mean : http://lpaste.net/147830 
03:28:46 <jle`> filter (== True) just feels even more awkward than filter id to me, heh; but i guess that is admittedly a subjective thing
03:29:35 <pavonia> roelof: a is undefined there
03:30:27 <pavonia> roelof: If you only care about has a result vs. has none, you can also use Maybe (a, a) as result
03:30:37 <jle`> i've heard it said that quality of code can be judged on how many times bools are used per line
03:30:37 <roelof> pavonia:  so I need to add a  "a" after the data Result so it looks like this data Result a =  
03:31:08 <jle`> it's a pretty ridiculous statement, but it's definitely made me start thinking about what bools i use are really necessary and what aren't
03:31:12 <pavonia> roelof: Yes, or fix the result type for the point
03:31:23 <jle`> boolean blindness is real
03:32:36 <pavonia> > sum $ map fromEnum [True, False, True, False, True]
03:32:38 <lambdabot>  3
03:32:55 <pavonia> linduxed: ^ What about that?
03:33:46 <roelof> pavonia:  what do you mean with fix the Result type.  Of course I need to alter the Result type of CrossX 
03:33:54 <jle`> > length . mapMaybe guard $ [True, False, True, False, True]
03:33:56 <lambdabot>  3
03:33:58 <Guest00000> pavonia: sum is bad for large lists...
03:34:17 <Guest00000> why do we not have sum' already
03:34:20 <Guest00000> in Prelude
03:34:29 <jle`> sum is already strict, i believe
03:34:47 <jle`> or at least reliably optimized to be so, i'd hope
03:35:15 <pavonia> roelof: If your input type is always Float, you can fix the result to Maybe (Float, Float), otherwise your need the additiona type parameter
03:35:50 <Guest00000> jle`: i just checked in my ghci 7.10.2: sum [1..1000000000]   ate a half of GB of RAM before i killed it
03:36:06 <jle`> how about on a compiled file?
03:36:13 <jle`> with optimizations
03:36:30 <Guest00000> damn, you're right...
03:37:05 <jle`> should probably work even w/o optimizations too, but i haven't checked heh
03:38:17 <roelof> oke, I will experiment with it in the next few days. First in a few hours celebrating X-mas with a part of the family 
03:38:19 <Guest00000> yes, it doesn't leak
03:38:35 <pavonia> roelof: Is that an exercise from a book or tutorial or so? IMHO, this function isn't the best choice to learn about using quickcheck. Other functions with more interesting properties may be more helpful
03:39:28 <roelof> pavonia:  it's a exercise from the Craft of Functional programming. and the exercise says to make tests  
03:39:41 <roelof> I can use then Hunit and/or QuickCheck 
03:39:49 <Guest00000> but what is definition of sum
03:40:10 <pyon> Is there any tool that can check whether two types (built from sums, products, exponentials and existentials) are isomorphic?
03:41:54 <agarciava> Hello, trying to install network-2.3.2.0 as dependence from another package fails on 7.10.1
03:48:30 <Guest00000> sum "becomes strict" only by turning on optimization
03:48:51 <Guest00000> on the other hand, if we define sum' with explicit strictness, it will be guaranteed
03:52:30 <Guest00000> also, to me this optimization is obscure. i can see by example that with -O2, (sum :: Num a => [a] -> a) will not leak, but will it in other instances of Foldable?
03:54:21 <Guest00000> by experimentation *
03:58:54 <Guest00000> jle`: if a thing is 'unnecessary', but can be obtained effortlessly (or even with less effort than avoiding it), should we really remove it?
03:59:28 <Guest00000> (assuming the neutral meaning of 'unnecessary' which does not imply 'harms')
04:09:22 <SX> Is there any real reason to choose megaparsec over parsec? I don't use haskell platform, only stack.
04:46:32 <Phyx-> I wonder why parsec is the most popular parser
04:55:16 <pavonia> attoparsec seems to be more popular recently
04:56:33 <saulzar> parsec was (one of the?) the first to be so widely used - that is probably part of it
04:58:30 <Phyx-> I've never really used parsec
04:58:35 <Phyx-> only uulib/uu-parsers
05:07:07 <SX> Phyx-: Why? I need to parse some (table-like) config file.
05:07:25 <SX> Phyx-: Is it easy with those libs?
05:09:22 <Phyx-> SX: because I was an UU student. I never looked for alternatives because of the error correcting abilities of the parsers. 
05:10:50 <SX> Oh, I see. I don't need error correction though. I need to print some error message on any incorrect input.
05:11:23 <Phyx-> sure, but it's the difference between printing the first error, and all errors in the file as well
05:11:39 <Phyx-> which is why I keep using it. Getting a list of mistakes to fix, and what to fix them with, is a useful error message
05:12:15 <Phyx-> I suppose the down side of the library is the learning curv
05:12:16 <Phyx-> curve*
05:19:48 <kqr> http://hackage.haskell.org/package/irc-conduit-0.1.2.0/docs/Network-IRC-Conduit.html#v:ircClient
05:20:00 <kqr> does someone happen to know why it takes a separate consumer and producer?
05:23:53 <kqr> i could communicate between then with an MVar but that sounds like an unnecessary indirection
05:26:35 <kqr> maybe I can just specify one conduit twice and it'll do the right thing...
05:54:00 <kqr> i can not do that, apparently
05:57:24 <FtheBuilder> Hello guys
06:01:50 <linduxed> how can i build with ghc and have it rebuild even when there are no differences in the library?
06:02:22 <linduxed> i want to dump the intermediate output of ghc, but if i've already compiled and there are no differences in the source code, then it doesn't do anything
06:03:52 <Phyx-> linduxed: try -fforce-recomp
06:05:41 <hamid> at the end of this blog post http://taylor.fausak.me/2015/05/28/clojures-threading-macros/ says "Regardless, this is a neat feature of Clojure. I wish Haskell had something similar. Unfortunately I think it would require Template Haskell..." so I was thinking.. he is wrong! isnt "do" exactly like this macro?
06:06:59 <hamid> what do you think? am I wrong?
06:12:37 <nshepperd> i don't see any way to do that with 'do'
06:13:35 <linduxed> pavonia: that is a really clever solution
06:13:37 <linduxed> haha
06:13:52 <linduxed> i think i'll run with my `length $ filter id` though...
06:13:54 <linduxed> or wait
06:13:56 <linduxed> hmmm
06:14:03 <linduxed> no, yours is too cool
06:19:46 <nshepperd> hamid: you can get close with quite a bit more noise with applicative style though...
06:20:05 <nshepperd> > 2 & ((+) <$> ask <*> pure 1) & (div <$> pure 9 <*> ask)
06:20:07 <lambdabot>  3
06:20:08 <Gurkenglas> I don't think sum . map fromEnum is a good idea. length . filter id sounds like something that a sufficiently good compiler should be able to optimize, sum . map fromEnum doesn't
06:20:20 <SX> Is there any way (except using mono-traversable's Textual class) to accept any text input in function and lowercase it?
06:20:29 <hamid> nshepperd, oh thanks for the example
06:21:22 <mjburgess> it's applicative-style rather than monadic
06:21:39 <mjburgess> it seems there are three main styles of haskell:  applicative, monadic and arrow
06:21:51 <mjburgess> (styles of imperative-ish programming, that is)
06:22:13 <SX> I need some case-insensitive text-to-adt converter
06:22:36 <rvxi> hello
06:23:07 <nshepperd> it's a lot messier than the macro is, but it's also a lot more explicit than a macro of arbitrary power
06:23:27 <rvxi> has anyone tried packaging a web app using something like yesod+javascript into an electron desktop app before?
06:35:59 <kqr> where do I find `lift` to lift an IO action in a conduit?
06:39:48 <kqr> ah control.monad.trans exports liftIO
06:41:46 <indiagreen> sbrg: “I went for microlens first, then I found out it covered everything I needed except a tiny bit” – what did it miss? maybe I could add it
06:43:26 <kqr> hey microlens looks really good
06:43:31 <kqr> didn't know about it
06:44:27 <pavonia> Only two dependencies, awesome!
06:47:50 <indiagreen> pavonia: only “base” starting from 7.10
06:48:12 <pavonia> Ah
06:48:52 <pavonia> I guess I will look at lenses finally, always avoided it because of the huge dependency list
06:57:04 <indiagreen> kqr: beware, it doesn't have prisms
07:07:20 <kqr> indiagreen, yeah, I saw that. but it does have traversals for either and maybe, which is what I most commonly want... I think
07:07:35 <kqr> indiagreen, I still haven't quite figured out what prisms actually *do* since the most common prisms I mostly use as traversals
07:08:53 <indiagreen> prisms are first-class constructors/deconstructors. If you have “_LRL = _Left . _Right . _Left”, you can use it both as a constructor and as an accessor
07:09:27 <indiagreen> it's useful for things with lots of constructors (like Aeson or exceptions or Template Haskell)
07:10:30 <pavonia> indiagreen: Are these planned for later releases?
07:12:55 * hackagebot time-parsers 0.1.0.0 - Parsers for types in `time`.  https://hackage.haskell.org/package/time-parsers-0.1.0.0 (phadej)
07:15:42 <indiagreen> kqr: for instance, if you represent chars in JSON as strings with length 1, you'd have a (Value ↔ Text) prism and a (Text ↔ Char) prism, and by combining them you'd be able to get a prism that lets you a) get a Char out of Value (or fail), and b) turn a Char into a Value
07:16:51 <indiagreen> without prisms you'd have to write “charToValue = String . T.singleton” and “valueToChar (String t) | length t == 1 = Just (T.head t); valueToChar _ = Nothing”
07:17:23 <indiagreen> with prisms you can say “_Char = _String . _Singleton” and it would work in both directions
07:17:30 <indiagreen> pavonia: no
07:17:48 <indiagreen> pavonia: prisms need profunctors, profunctors need the profunctors package, the profunctors package is big
07:18:21 <kqr> indiagreen, interesting. i guess I've either never encountered that problem – or never realised prisms were a solution
07:18:37 <indiagreen> kqr: my last lens over tea post is about prisms, but it's more about implementation details than about interesting examples (mostly because I never used prisms and so I don't have any interesting examples)
07:18:40 <kqr> indiagreen, what are Isos in kmett-lens-terminology then, and do they relate to prisms?
07:18:51 <kqr> are YOU the author of those posts? cool!
07:19:07 <kqr> I saw it was posted earlier today, but I haven't looked at it thoroughly yet
07:20:20 <indiagreen> an Iso s a lets you convert between s and a and it's guaranteed not to fail
07:20:29 <indiagreen> * Iso' s a
07:20:54 <indiagreen> a Prism s a is a partial Iso – it says that “a” is a subset of “s”
07:21:06 <indiagreen> for instance, Natural is a subset of Integer
07:21:23 <indiagreen> you can always go Natural → Integer, but you can't always go Integer → Natural
07:21:38 <ga2arch> merry christmas guys :)
07:22:20 <indiagreen> on the other hand, there's a 1-to-1 correspondence between e.g. Word32 and Int32 (or Text and String, or whatever) and there are isos that let you convert between them
07:22:26 <kqr> ahaa!
07:22:29 <kqr> that makes a tonne of sense
07:22:36 <indiagreen> ga2arch: and to you!
07:22:41 <indiagreen> kqr: prisms are duals of lenses
07:23:07 <kqr> my pointed maths hat is not tall enough for me to grok what a dual is heh
07:26:04 <indiagreen> kqr: Edward explained it here, sort of: https://github.com/sdiehl/wiwinwlh/issues/67#issue-73707312
07:29:09 <indiagreen> “Lens s a” means that you can represent s as a tuple of a and some other type
07:29:31 <indiagreen> “Prism s a” means that you can represent s as a sum type of a and some other type
07:30:18 <hpc> i might be a scrooge but those names are terrible
07:30:37 <hpc> Lens and SumLens might be better
07:31:08 <indiagreen> hpc: there are also Exchange, Market, and Bazaar in lens internals
07:31:27 <indiagreen> oh, and Magma/Mafic/Molten
07:32:03 <indiagreen> I like catchy names tho, to be honest
07:34:16 <kqr> haha
07:35:19 <kqr> indiagreen, i'm aware of those explanations of what a prism is, but I have yet to gain intuition for what actual problems they solve
07:38:08 <indiagreen> kqr: well, if you find any good use for prisms, tell me
07:38:12 <indiagreen> I couldn't be bothered to
07:38:14 <SX> Guys, I'm trying to make an instance of FromJSON and ToJSON for my data type `data MyType = MyType ByteString` with toJSON (MyType a) = toJSON a.
07:39:38 <SX> Compiler says No instance for (ToJSON ByteString) arising ...
07:40:00 <SX> In Data.Aeson I clearly see definition for ByteString
07:40:07 <SX> What am I doing wrong?
07:40:51 <indiagreen> SX: hm, where do you see it? I can't find it
07:41:07 <SX> See what? Instances for ByteString?
07:41:09 <indiagreen> SX: I'm looking at the list of instances here: http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson.html#t:ToJSON
07:42:29 <indiagreen> I see e.g. ToJSON Text, but not ToJSON ByteString
07:42:49 <SX> Wow, I haven't noticed the version of docs I'm looking at =)
07:43:00 <SX> Seems dev removed those instances for some reason
07:44:24 <SX> Then, how do I convert ByteString to Value?
07:44:56 <indiagreen> if it's genuine binary data, you should convert it to e.g. base64
07:45:17 <indiagreen> if it's actually a string, just convert it to a string
07:45:33 <geekosaur> well, probably a Text
07:45:48 <geekosaur> and yes, I suspect that's the point of not having a ByteString instance
07:47:07 <SX> Then I should parse value as Text and then convert to BS, right?
07:47:28 <geekosaur> yes, if you know it can be converted
07:47:39 <geekosaur> what kind of data exactly are you working with here?
07:48:00 <SX> Host name
07:48:20 <SX> So it should be a text
07:48:21 <geekosaur> being sloppy "a string is a string" here can and will get you data corruption; you actually have to think about what you have and what you have to do with it
07:50:28 <SX> Yup, I get it. ByteString has no restrictions, so it could be anything.
07:50:42 <SX> Text contains only valid utf characters
07:53:40 <geekosaur> right. and it can't guess whether te recipient is expecitng something that is a string, or binary b64-encoded, or binary hex-encoded, or ???
07:53:52 <geekosaur> so it forces you to make that call
08:01:48 <icbm> Having trouble trying to use a WriterT + ReaderT + ST.
08:03:33 <icbm> WriterT Foo (ReaderT (STRef s (Bar s)) (ST s)) -- Does this look wrong?
08:05:39 <Taneb> icbm, what's the kind of Bar?
08:06:49 <icbm> * I believe.  data Bar s { fnarg :: HC.HashTable s MyKey MyValue }
08:07:11 <icbm> I'm not really good with kinds yet.
08:07:20 <Taneb> I don't think that's a valid data decleration
08:07:26 <icbm> I think that makes Bar a * -> * 
08:07:30 <Taneb> Yeah
08:07:37 <Taneb> If it is, what you wrote earlier should work
08:07:38 <icbm>  data Bar s = Bar { fnarg :: HC.HashTable s MyKey MyValue }
08:07:42 <Taneb> Yeah
08:07:57 <icbm> That's not the problem, though. Just a mistype.
08:08:26 <icbm> What I really have is...
08:09:17 <icbm> newtype Wat s a = Wat (WriterT Foo (ReaderT (STRef s (Bar s)) (ST s)) a)
08:10:05 <icbm> Wat is an operation using ST that can read from a single STRef and accumulate output.
08:11:19 <icbm> I'm wanting to write a pure function using Wat.
08:11:35 <icbm> doWat :: Wat s () -> ByteString
08:12:14 <icbm> i.e. it's a DSL that builds a certain ByteString
08:16:47 <icbm> I have doWat (Wat a) = runST $ do { ctx <- setup ; foo <- runReaderT (execWriterT a) ctx ; return $ toBS foo }
08:17:11 <icbm> (might not be exact, but that should be close)
08:17:33 <icbm> Error is: Couldn't match type ‘s’ with ‘s1’
08:17:56 * hackagebot aeson-compat 0.3.0.0 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.0.0 (phadej)
08:24:18 <icbm> I think I should isolate my issue into a Gist or something.  It's harder to explain than I imagined it would be. :/
08:33:32 <icbm> https://gist.github.com/sharpjs/ef8ccd3ffd6a267db74f
08:33:36 <johnw> icbm: you can't hold your STRef s in a ReaderT like that
08:34:33 <icbm> johnw: :(
08:34:42 <johnw> it's sort of the point of ST :)
08:34:46 <johnw> you can use an IORef, though
08:35:25 <johnw> the other option is this
08:35:26 <icbm> johnw: I want to thread a HashTable through a bunch of functions of a DSL.  Is there a better way?  Is IORef a better way?
08:35:51 <johnw> (one sec)
08:36:41 <johnw> this you can do: https://gist.github.com/dc2a298933203625b509
08:37:06 <johnw> you have to keep the "s" universal, you can't ever fix it to a specific type that you expect to "share" between invocations of runST
08:37:17 <johnw> if this doesn't fit within your use case, you'll need something like IORef
08:37:27 <icbm> johnw: OK, let me see if I can apply this.
08:37:59 <johnw> so, I dropped the "s" on Bar, and I moved the "s" on Wat inside
08:38:42 <icbm> johnw: I need the s on Bar, because it contains a HashTable s K V
08:38:55 <johnw> that's still OK
08:39:07 <johnw> but only if the Bar s is *created* within any particular runST, and never escapes it
08:39:33 <johnw> the "s" here is serving the lock down any reference to it to within a particular invocation of runST, effectively
08:39:51 <johnw> and that's a feature
08:40:25 <icbm> johnw: Thanks. I understand what ST is trying to do, just not why I was running afoul of those goals.
08:40:35 <indiagreen> has anybody got any ideas for packages that could be written in a day (or 2) and that would be useful to you but you're too lazy to write them by yourself?
08:41:49 <johnw> indiagreen: some convenience functions to link fgl and graphviz, for manipulating DOT files as graphs
08:41:58 <johnw> I can even give you some starter code
08:48:14 <icbm> johnw: Thanks, that got it figured out for me. Here's what I ended up with: https://gist.github.com/sharpjs/ef8ccd3ffd6a267db74f
08:49:06 <johnw> awesome!
08:49:25 <icbm> johnw: I think the key was to remove s from Foo's type parameters, and quantify it internally with forall (like you said!)
08:49:37 <johnw> right, and then keep all "s" references bounded
08:51:14 <icbm> johnw: I like the encapsulation now too: consumers don't know that Foo uses ST internally, and the implementation can be changed later without breaking things.
08:52:02 <icbm> The nasty s isn't leaked to consumers.
08:52:24 <indiagreen> johnw: okay
08:52:31 <icbm> johnw: Thanks, this was my first use of forall.
08:53:43 <johnw> indiagreen: for example, here's some code I wrote that used both libraries: https://gist.github.com/7b3fdb764e1a1d9ebf35
08:54:00 <johnw> and it was way more annoying that I thought it should have been, since a DOT is a just a representation of a graph
08:54:21 <johnw> so some utilities to directly read into/from fgl graphs, etc., nicely packaged up, would have been ideal
08:54:29 <johnw> icbm: mryxmas :)
08:54:47 <icbm> You too, johnw!
09:07:58 * hackagebot monad-http 0.1.0.0 - A class of monads which can do http requests  https://hackage.haskell.org/package/monad-http-0.1.0.0 (phadej)
09:17:07 <d3ath_x> hey?
09:17:14 <d3ath_x> anyone active ?
09:17:55 <phadej> varely
09:19:23 <indiagreen> johnw: on second thoughts, I feel that I'll spend several days merely figuring out what fgl and graphviz do, since I haven't ever worked with either
09:19:29 <indiagreen> so I guess I won't after all
09:19:46 <johnw> fgl is a graph representation library
09:19:52 <johnw> graphviz is for reading and writing DOT files
09:20:11 <indiagreen> fgl also looks kinda hairy/complicated
09:20:27 <johnw> it's a lot scary than it looks, it's a downside to that library I admit
09:25:24 <phadej> ah, why base-compat depends on unix :S
09:26:54 <geekosaur> it doesn't, quite; tat's an artifact of docs being built on unix
09:27:00 <geekosaur> http://hackage.haskell.org/package/base-compat-0.8.2/dependencies
09:29:07 <joco42> is this "good" haskell, or am i doing something wrong ? https://usercontent.irccloud-cdn.com/file/r4D7CDgu/Screen%20Shot%202015-12-25%20at%2019.26.56.png
09:30:09 <joco42> i think i am trying to make up for the missing subclassing ... somehow....
09:30:29 <joco42> where Info is the super class
09:30:57 <phadej> joco42: looks valid
09:31:21 <joco42> phadej:  but this is not some kind of anti-pattern?
09:31:52 <joco42> trying to use the tool the wrong way?
09:32:03 <joco42> due to my java past ....
09:34:43 <joco42> that code was even buggy :) ... what an irony... https://usercontent.irccloud-cdn.com/file/gDN7SkPn/Screen%20Shot%202015-12-25%20at%2019.33.45.png
10:02:59 * hackagebot aeson-extra 0.3.0.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.3.0.0 (phadej)
10:09:11 <hhhhhhhh> is there an easy way to work around System.Locale.defaultTimeLocale being moved
10:10:48 <indiagreen> hhhhhhhh: probably use http://hackage.haskell.org/package/time-locale-compat
10:11:01 <indiagreen> yeah, definitely
10:12:36 <hhhhhhhh> looks good, thanks
10:30:23 <NOCKNOCX> what is the best book about Haskell or should I go trough with a book?
10:31:07 <hiptobecubic> I think bitemyapp's book is getting good reviews, although it isn't in full release yet. http://haskellbook.com/
10:35:05 <hiptobecubic> bitemyapp, for some reason your sample pdf is extra zany in firefox's pdf.js renderer. http://i.imgur.com/IMtN692.png 
10:37:41 <dutchie> haha that's excellent
10:54:10 <jesyspa> I often find myself wanting to work with datatypes that have similar general shapes, but differ in some details; for example, I might have your typical Exp datatype for expressions, but sometimes I want to annotate every subterm with its type, or with its position in the source file, or maybe I want to forbid a certain constructor.
10:54:18 <jesyspa> Is there any common way of tackling this problem?
11:00:47 <johnw> jesyspa: yes, there are a few approaches
11:02:03 <johnw> for example, see http://hackage.haskell.org/package/compdata
11:02:16 <jesyspa> johnw: Thanks!
11:02:33 <johnw> there are more than a few implementations of this idea, evolved along various axes
11:02:44 <johnw> so it pays to know exactly what you'll need, to find the right power/weight ratio
11:03:13 <johnw> see also recursion-schemes by edwardk, which isn't as large or quite as heavy as compdata; but there are many more still
11:03:25 <phadej> yet just having Exp ann = Var ann Name | App ann (Exp ann) (Exp ann) etc.
11:03:28 <johnw> a great video to start with: https://www.youtube.com/watch?v=Zw9KeP3OzpU
11:03:30 <phadej> might be much simpler
11:03:39 <johnw> so, in that case you'd use this:
11:03:41 <phadej> if your recursion shape won't change
11:04:11 <johnw> ExpF r = Var Name | App r r
11:05:20 <jesyspa> phadej: I've considered having that, but it's just a little not versatile enough in my experience.  (Disabling a constructor doesn't work very well, too.)
11:05:46 <phadej> jesyspa: recursion schemes doesn't help with disabling constructor eihter :(
11:06:02 <jesyspa> johnw: This looks like some free monad/cofree comonad stuff I've seen; is it relevant?
11:06:05 <jesyspa> phadej: Ah, pity. :(
11:06:08 <johnw> phadej: in compdata you can use compositional structures (compdata) to drop a set of constructors from a possible construction
11:06:15 <johnw> jesyspa: yes, highly relevant
11:06:30 <jesyspa> johnw: I'll rewatch that, then, thanks :)
11:06:35 <phadej> johnw: ah, that's cool
11:06:37 <johnw> often recursion schemes are built around Free or Fix; and cofree can be used to build unions of evaluators for compositions of structures
11:07:14 <phadej> johnw: as you are online, can you review my github PR, and comment on "Decouple request creation from execution"
11:07:33 <johnw> it's still a somewhat open question how to make it truly efficient, though, since I believe compdata costs many extra constructors (for Inl and Inr) depending on how many sub-grammars you need
11:07:38 <johnw> phadej: ok
11:08:10 <johnw> right now I'm trying to wrap my head around "abstraction relations", so I could use a mental break
11:10:59 <phadej> johnw: and isomorphism doesn't respond to emails :/
11:11:12 <johnw> can you link me?
11:12:25 <phadej> ah, he answered \o/ his reply got burried under my pile of mails.
11:12:39 <phadej> johnw: PR https://github.com/jwiegley/github/pull/129
11:12:50 <phadej> johnw: issue https://github.com/jwiegley/github/issues/127
11:12:53 <phadej> not related
11:13:52 <johnw> can you like me on the Decouple thing?
11:14:24 <phadej> decouple?
11:14:33 <johnw> 11:06 <phadej> johnw: as you are online, can you review my github PR, and comment on "Decouple request creation from execution"
11:14:46 <phadej> that's the issue
11:14:49 <phadej> 127 ^^^
11:14:54 <johnw> ah
11:15:10 <johnw> I love such decoupling
11:15:44 <johnw> I do prefer 'free' to 'operational', though
11:15:53 <Roelof> why is the constructor Result not known at the last three lines here : http://lpaste.net/147832
11:16:09 <phadej> johnw: well, in github one won't need to bundle free monad at all
11:16:12 <johnw> just drop "Result " from all three lines
11:16:18 <johnw> that's the type name, it's not a constructor
11:16:34 <johnw> and you'll need some parens for the -b/m
11:16:47 <johnw> phadej: I don't understand that statement
11:17:14 <phadej> johnw: one don't need to bundle 'monad' implementation in 'github' package, it can be left as an exercise to user
11:17:19 <phadej> or can be in separate package
11:17:26 <johnw> ok, that sounds fine to me
11:18:39 <phadej> ok, so would you prefer me to do e.g. publicOrganizationsForR :: String -> GithubRequest [SimpleOrganisation] ?
11:19:02 <phadej> i.e. introduce new names, so the changes would be somehow backwards compatible?
11:19:21 <johnw> sure
11:19:30 <Roelof> pff, I have changed it and now I see this : http://lpaste.net/147833
11:19:52 <phadej> good, I'll try to do the PR asap, it's quite straightforward after all.
11:19:53 <johnw> you need more parentheses
11:19:58 <johnw> ((-b)/m)
11:22:04 <Roelof> oke, it compiles but when I want to run it . I see this :  No instance for (Show (Result Float)) arising from a use of ‘print’ 
11:22:13 <Roelof> this way Haskell is no fun 
11:22:27 <Roelof> I run it with CrossX (line 2 0) 
11:22:31 <johnw> you need "deriving Show" for your data type
11:23:38 <phadej> thanks for that, now I can continue :)
11:24:04 <lispy> Roelof: I'm glad to see you're still improving on your previous version
11:30:24 <Roelof> lispy:  I have to .The previous version was not testable 
11:33:02 * hackagebot these 0.6.2.0 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.6.2.0 (phadej)
11:33:21 <johnw> phadej: thanks for working on 'these'!
11:33:33 <Roelof> johnw:  thanks, everything is working fine now 
11:33:57 <Roelof> Next problem : Find out if these functions can be tested by QuickCheck 
11:34:25 <johnw> QuickCheck is good for fuzzy a parameter, and testing that some property is true for a given function over any value of that parameter
11:34:30 <johnw> s/fuzzy/fuzzing
11:35:14 <Roelof> johnw:  that I know. I have to find out if I can do that for my CrossX function or that I can better use some Hunit testing 
11:36:43 <Roelof> lispy:  Can I improve my function more ? 
11:36:56 <lispy> Roelof: what is the current version?
11:38:31 <Roelof> lispy:  this one : http://lpaste.net/147834
11:39:34 <lispy> Roelof: that looks really good
11:39:45 <Roelof> :) IM happy now 
11:40:31 <Roelof> now what I said earlier . Finding out if I schould use QuickCheck or Hunit for testing. that is the next challenge in the book 
11:40:39 <lispy> Roelof: For testing, I'm not sure what I would write for crossX. The specification is pretty easy to check given the implementation you have.
11:41:10 <phadej> johnw: `these` is sweet, it comes handy now and then
11:41:28 <lispy> Roelof: Since the second argument to One is always 0, I suppose you could omit it.
11:41:47 <lispy> data Result a = ... | One a | ...
11:42:08 <lispy> But if you ever want to write crossY you'll be back to the current version
11:42:46 <lispy> Roelof: so this suggests a test. Leave Result defined the way it currently is, and then add a test that the y coordinate of a crossing is always 0
11:42:53 <Roelof> oke, wierd that the author says to write tests for these exercises 
11:43:21 <lispy> testing this is good. I'm just lazy :)
11:43:42 <Roelof> oke, I have then find out how I can take the second argument of Result 
11:44:12 <lispy> Roelof: actually, I just thought of something you should change
11:44:22 <lispy> An unfortunate thing about records
11:44:32 <Roelof> I see . I can test if Y is always zero 
11:45:02 <Roelof> oke, records are not mentioned yet, Just type  and data 
11:45:13 <lispy> So the names you use when you define the fields are functions. so in your case, the x and y in Result are functions. But they will crash when you apply them to an All or None
11:45:18 <Roelof> but shoot. I always like to learn more and more 
11:45:35 <lispy> So it's actually better to not use the names when you have multiple constructors like this
11:45:57 <lispy> data Result a = None | One a a | All deriving Show
11:46:09 <Roelof> yes, All means here a lot of points that crosses and none means no point that crosses 
11:46:37 <lispy> otherwise  you run the risk of let foo = All; fooX = x foo {- this will crash -}
11:46:52 <lispy> You should try it in ghci to see what I mean
11:46:54 <Roelof> oke, and how can this be solved 
11:47:25 <lispy> By not using records with a type that has multiple constructors (All, One, and None are called data constructors)
11:47:42 <lispy> the definition would look more like this: data Result a = None | One a a | All deriving Show
11:48:15 * hackagebot conduit-parse 0.1.1.0 - Parsing framework based on conduit.  https://hackage.haskell.org/package/conduit-parse-0.1.1.0 (koral)
11:48:55 <Roelof> lispy : the code you provided do not chrash . I see this error : <interactive>:3:6: parse error on input ‘=’
11:49:45 <Roelof> oke, so One has two a 
11:50:10 <lispy> Sorry, I was a bit loose with the syntax
11:50:24 <lispy> in ghci you have to type several lines and it would be like this:
11:50:28 <lispy> let foo = All
11:50:38 <lispy> let fooX = x foo
11:50:44 <lispy> fooX
11:51:25 <lispy> You'll need your module to be in scope as well
11:51:39 <Roelof> Then I see this error : *** Exception: No match in record selector x 
11:51:57 <lispy> Yeah, that's the crash
11:52:05 <lispy> x is only defined for One
11:52:06 <Roelof> oke 
11:52:38 <Roelof> so if I try it with  One a a  instead of One a , it schould not crash ? 
11:52:46 <lispy> The recommendation is to avoid using record selectors that are only defined for some of your data constructors
11:53:55 <maerwald> they are useful, you just need to wrap them in safe functions
11:54:43 <lispy> Roelof: Instead of `One { x :: a, y :: a}`, you want to do `One a a`
11:55:01 <lispy> Roelof: the `{ x :: a}` bit makes the record selector named x
11:55:23 <Roelof> yes, I see then this error :  <interactive>:4:12: Not in scope: ‘x’  when doing let fooX = x foo
11:55:35 <lispy> that's right
11:55:57 <lispy> So now it would be a compile time error instead of a run-time error
11:56:09 <lispy> Because x doesn't exist anymore :)
11:56:39 <Roelof> and I see this output when a line crosses the x-axis : One (-0.0) 0.0 
11:57:16 <lispy> Roelof: instead of none?
11:57:50 <Roelof> no, instead of ( 0.0, 0.0) earlier 
12:01:53 <Roelof> lispy:  can I change the output back to a point notation. 
12:02:07 <Roelof> Or do I need to make one more custom data type 
12:02:15 <Gurkenglas> Is there a stateful (^?!)?
12:08:15 * hackagebot atp-haskell 1.8 - Translation from Ocaml to Haskell of John Harrison's ATP code  https://hackage.haskell.org/package/atp-haskell-1.8 (DavidFox)
12:08:17 * hackagebot xml-conduit-parse 0.3.1.0 - Streaming XML parser based on conduits.  https://hackage.haskell.org/package/xml-conduit-parse-0.3.1.0 (koral)
12:14:03 <Abrahm>  Could not deduce (Applicative (Writer' w))       arising from the superclasses of an instance declaration     from the context (Monoid w)       bound by the instance declaration at tryme1.hs:4:10-41     In the instance declaration for ‘Monad (Writer' w)’
12:14:26 <johnw> Abrahm: that's not really enough information to go on
12:14:27 <Abrahm> what does above error mean?
12:14:41 <Abrahm> newtype Writer' w a = Writer' { runWriter :: (a, w) }   instance (Monoid w) => Monad (Writer' w ) where        return x = Writer' (x, mempty)        (Writer' (x,v)) >>= f = let (Writer' (y, v')) = f x in Writer' (y, v `mappend` v')  
12:14:58 <johnw> nowadays, you need an Applicative instance to go with your Monad instance
12:14:59 <Roelof> How can I tell Haskell that - 0 must be displayed as just 0  
12:15:03 <johnw> so you'll have to define that too
12:15:09 <johnw> you can get the Functor instance for free with DeriveFunctor
12:22:55 <aweinstock> :t (<*>)
12:22:57 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:23:02 <aweinstock> @src ap
12:23:03 <lambdabot> ap = liftM2 id
12:23:09 <aweinstock> @src liftM2
12:23:09 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:23:43 <aweinstock> Abrahm: you can get the Applicative instance for free from your Monad instance: pure = return; (<*>) = ap
12:29:00 <Roelof> Is it possible to tell Haskell/Ghci that zero must be displayed as 0 and no + or - before it 
12:29:18 <Roelof> or must I use then something else then Float 
12:30:29 <mjburgess> 0 is displayed as 0 ...? what do you mean?
12:31:28 <maerwald> > floor (-0.0)
12:31:30 <lambdabot>  0
12:31:42 <Roelof> no, when I do -b / m with m as 2 and b as zero then I see as answer (-0)   
12:33:05 <Roelof> see output in GHCI :  -0/2  gives as output -0.0
12:33:46 <maerwald> see above
12:34:00 <mjburgess> or   abs $ -0
12:34:12 <mjburgess> abs == take absolute value of, ie |x|
12:34:28 <aweinstock> > (-0) :: Double
12:34:30 <mjburgess> > abs $ -0/2
12:34:30 <lambdabot>  -0.0
12:34:31 <lambdabot>  0.0
12:34:41 <aweinstock> :t (-0)
12:34:43 <lambdabot> Num a => a
12:34:49 <aweinstock> > (-0) :: Int
12:34:51 <lambdabot>  0
12:35:07 <Roelof> oke, then I have to find out how to do this only for zero and not for other outcomes 
12:35:16 <aweinstock> > 0/0
12:35:18 <lambdabot>  NaN
12:35:30 <mjburgess> or write your own show function Roelof 
12:35:57 <aweinstock> Roelof: floating point numbers have some edge cases, is there a specific reason why -0 is problematic for your use case?
12:36:04 <Roelof> oke, I will experiment with all the hints. Thanks all and have a merry X-mas 
12:36:33 <Roelof> No, the only problem is that I do not like it as output. It's looks wierd to me 
12:36:51 <maerwald> yeah, another way is to wrap the Show instance in another function so you can catch -0.0 and +0.0
12:37:37 <maerwald> happy helloween btw
12:41:37 <Roelof> Thanks all, IM going to sleep 
12:48:51 <broma0> Hello all. Can someone point me in the direction of some documentation what is considered to be the idomatic way to solve a general programming problem in haskell?
12:49:15 <johnw> broma0: without knowing the problem, that's rather impossible
12:49:23 <johnw> I refer you to the thousands of articles existing on the Web :)
12:51:19 <broma0> johnw: i disagree with it being impossible. I think the answer is to define types that model the problwm, and then functions acting on those types
12:53:49 <broma0> I recently read that ghc barely, if at all, uses monad transformers/stacks. What is used in their place? I can use the mtl to solve almost anything!
12:54:13 <johnw> I still don't know what you're talking about
12:54:21 <johnw> which "general programming problem"?
12:56:52 <broma0> Any problem solvable by a computer. The real question is: what patterns/design decisions are common among *all* well-written code-bases?
12:57:08 <broma0> In haskell, of course
12:58:10 <johnw> how do we even define 'well-written'?
12:58:27 <johnw> in terms of its success, popularity, respect among peers, advancing the state of the art, some aesthetic judgment?
13:00:54 <broma0> Thats a good question, and although there is one, i dont have an amswer. I think you and i can say we've seen both good and bad code right? So, out of all of the arbitrarily-deemed "good", is there a common theme?
13:01:37 <MarcelineVQ> The common theme is that there's a clear problem being solved in "good" code
13:01:57 <johnw> good granularity of functions; judicious use of composition and higher-order functions; good use of types; not too many advanced features except when necessary; well tested
13:02:13 <broma0> There we go! 
13:02:17 <johnw> the problem is, my definition presumes the thing I'm trying to define
13:02:24 <johnw> I'm using "good" to define what a "good" program has in it
13:02:35 <johnw> I might as well say that well-written code is code that is well written
13:04:24 <broma0> Inside of that recursive definition theres definitely a common theme! I think you were on the right track with "good granularity..." As well as by saying good code generslly solves an explictly obvious problem
13:05:03 <broma0> Oops, MarcelineVQ said the latter 
13:05:05 <broma0> Thanks
13:55:09 <cir0x> Hey! I'm trying to print the alphabet with an space between each literal with list comprehensions. My approach so far: prettyAlphabet = [ x ++ y | x <- ['a' .. 'z'], y <- [' ']]
13:56:47 <Gurkenglas> ++ takes lists, not single characters like x and y
13:57:23 <Gurkenglas> Why do you want to use list comprehensions in particular? intersperse already does what you need
13:57:35 <hpc> presumably as an exercise?
13:57:54 <Gurkenglas> Yes, but I want him to say it so we can shout at him some for asking us to do his homework
13:58:13 <Gurkenglas> Since y has only one possibility, you can inline the ' ' directly into the expression to the left of the |
13:58:26 <hpc> heh, asking for help on homework is fine imo when there's some obvious effort put into it
13:58:55 <maerwald> I don't understand why so many professors like to give exercises involving list comprehensions. They are basically redundant syntax sugar
13:59:00 <Gurkenglas> But he might think that we would shout at him, so I'm making him uncomfortable, mwahaha
13:59:07 <cir0x> No it's no homework I´ve just started with haskell (learnyouahaskell) and I thought list comprehension are awesome and can solve any problem
13:59:23 <Gurkenglas> If you combine x and y into a list of two characters, you'll have a list of lists, and need to use concat to collapse it
13:59:58 <maerwald> list comprehension are unnecessary since you can just use the full power of the list monad
14:00:00 <Gurkenglas> Note that this approach will add an extra space at the end of the whole thing
14:00:33 <Big_G> > :t join 
14:00:34 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:04:47 <c_wraith> :t join
14:04:49 <lambdabot> Monad m => m (m a) -> m a
14:10:10 <exio4> maerwald: they look nice sometimes 
14:10:53 <maerwald> yeah, we can add even more ways to express that stuff
14:11:01 <maerwald> it may look even nicers
14:11:18 <cir0x> Gurkenglas: So I accomplished that with intersperse ' ' ['a' .. 'z'], but is there a nice way with list comprehensions?
14:11:32 <exio4> maerwald: [ f x | Pattern x <- something , g x ]
14:12:03 <exio4> maerwald: you'd need to switch to do { ... } or >>= + case here, and it becomes quite verbose 
14:12:22 <Gurkenglas> > concat [x : " " | x <- ['a'..'z']] -- cir0x
14:12:24 <lambdabot>  "a b c d e f g h i j k l m n o p q r s t u v w x y z "
14:12:34 <maerwald> yet another way people have to learn to express the same thing
14:16:28 <cir0x> Gurkenglas: Thanks! I will try to achieve that without the concat function
14:18:05 <Gurkenglas> cir0x, just thought of a way, lemme know when you want to hear it
14:40:02 <Jinxit> if I want to report errors inside the State monad (without any other return type), what's the recommended course of action?
14:40:29 <amf> in my data type i want a function that goes from (a -> Bool), but ghc says "Not in scope: type variable ‘a’". what am i doing wrong?
14:40:48 <cir0x> Gurkenglas: I don't come to an conclusion, let me here your solution please
14:41:33 <shachaf> amf: GHC doesn't know what "a" is. We don't either, we can't tell you anything that GHC isn't.
14:42:07 <amf> shachaf: how do i say any type to bool in this context?
14:42:54 <monochrom> that is the wrong question.
14:43:06 <Gurkenglas> > [y | x <- ['a'..'z'], y <- x : " "] -- cir0x
14:43:08 <lambdabot>  "a b c d e f g h i j k l m n o p q r s t u v w x y z "
14:43:19 <amf> i believe im looking for existential types
14:44:00 <monochrom> the right question is "my intention is at url ___, my complete unabridged verbatim code is at url ___, could you diagnose it?"
14:45:17 <amf> ill just figure this out on my own as explaining it to you all is not worth the effort
14:45:43 <cir0x> Damn… thanks a lot Gurkenglas
14:46:45 <Gurkenglas> > ['a'..'z'] >>= (:" ") -- or written like this
14:46:47 <lambdabot>  "a b c d e f g h i j k l m n o p q r s t u v w x y z "
14:46:55 <FUZxxl> Gurkenglas: moin
14:47:00 <nocturne777> could someone give me an insight into why ::fromByteString takes a LB? https://hackage.haskell.org/package/uuid-1.3.11/docs/Data-UUID.html
14:47:30 <nocturne777> author exposed different functions that take SB and LB
14:47:45 <nocturne777> but not for fromByteString
14:48:51 * hackagebot ghcjs-dom 0.2.3.1 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.2.3.1 (HamishMackenzie)
14:51:26 <TyCon> @help
14:51:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:59:22 <quchen> > intersperse ' ' ['a'..'z'] -- cir0x 
14:59:24 <lambdabot>  "a b c d e f g h i j k l m n o p q r s t u v w x y z"
15:06:20 <nocturne777> nvm
15:28:52 * hackagebot verbosity 0.2.1.0 - Simple enum that encodes application verbosity.  https://hackage.haskell.org/package/verbosity-0.2.1.0 (PeterTrsko)
15:32:54 <johnw> phadej: would you like to become the maintainer of the 'github' package?
15:42:20 <tryam> If I want to use only 2 fields in thing of a type defined using record syntax, what it better - to unwrap them in the argument or to call their respective getters?
15:44:16 <johnw> by "use" you mean, just get those two values?
15:44:18 <quchen> tryam: To be sure you'd have to check the core, but intuitively I'd say calling two getters compiles to two separate pattern matches, whereas matching via record is only a single one.
15:44:56 <tryam> like: "myFunc Foo {getBar = bar, getBaz = baz} = blah bar baz" vs. "myFunc foo = .blah (getBar foo) (getBaz foo)"
15:45:01 <haskell011> Hey all, followed the following tutorial: https://wiki.haskell.org/Parsing_a_simple_imperative_language to learn to parse a simple language using Parsec. Now want to use Control.Monad.Gen to generate fresh values so that I can label expressions as seen in Principles of Program Analysis. However, this is my first attempt using monad transformers and I'm a little stuck.
15:45:07 <johnw> foo Foo {..} = blah fieldOne fieldTwo
15:45:48 <tryam> Thanks!
15:46:04 <haskell011> I'm thinking the net change will be that whileParser will go from having type Parser Stmt to GenT Integer Parser Stmt. But I'm kind of lost trying to figure out the most idiomatic way to refactor the code.
15:46:57 <haskell011> Err, sorry, the parser's name is "stmt" in the tutorial linked.
15:47:09 <quchen> haskell011: Parsec also supports user state, I think you might be able to use that one. If you want to learn about monad transformers that's not what you want of course.
15:47:12 <monochrom> haskell011: I wonder if the other way round, "ParsecT ... Gen ..." is more convenient
15:47:44 <monochrom> or yeah, using Parsec's user state is even less big-hammer
15:47:52 <haskell011> This is my first venture into monad transformers, and I understand there's a different between the two in terms of order, but I'm wondering what the difference would look like?
15:49:09 <haskell011> So if I used ParsecT, and Gen monad, would the solution be to generate the fresh integers using Gen monad and then lift them into the ParsecT monad?
15:49:13 <monochrom> if you do "GenT ... Parsec ...", that means every time you use a parsec operation, you have to say "lift"
15:49:28 <haskell011> Right that was the issue I was facing
15:49:31 <monochrom> if you do "ParsecT ... Gen ...", that means every time you use a gen operation, you have to say "lift"
15:49:49 <haskell011> Gotcha,  okay, that seems easier. 
15:49:49 <monochrom> so you statistically count which one is fewer "lift"s
15:50:32 <haskell011> And so in terms of types
15:51:07 <haskell011> basically every single one of my Parser Stmt values from the tutorial will turn into a ParsecT ... Gen ...
15:51:25 <haskell011> More specifically, a ParsecT Integer Gen Stmt
15:51:28 <haskell011> I suppose...
15:52:06 <monochrom> yes
15:52:44 <monochrom> no, I am not sure right now. the "Integer" part looks wrong.
15:53:10 <haskell011> Oh sorry I believe I have them reversed
15:53:41 <haskell011> The type associated with the ParsecT monad should be Stmt, as it was Parser Stmt before. Then the fresh values I want to generate are of type Integer
15:53:41 <haskell011> which is Enum
15:53:43 <monochrom> ls
15:53:53 <monochrom> err, wrong keyboard
15:53:56 <haskell011> Thanks, I think i understandnow.
15:59:35 <Rovanion> So lets say I want to make a CLI application with haskell, is there any library or perticular path you would recomend?
16:00:48 <Rovanion> For Python I found the click library handy as it automatically wrote the user documentation/help messages for me using the structure of my program and the docstrings I put in it.
16:48:18 <Jinxit> using lens in State I can easily do health .= 10, but how do I do health .= maxHealth? where they are both lenses
16:51:22 <shachaf> Maybe "health <~ use maxHealth"?
16:53:44 <Jinxit> that works
16:53:48 <Jinxit> thanks
17:03:24 <kqr> is there an Applicative f => f a -> f () ?
17:03:50 <shachaf> (() <$)
17:04:05 <shachaf> Or ($> ())
17:04:11 <kqr> i guess
17:04:11 <shachaf> Oh, they changed the type of void.
17:04:16 <kqr> I thought I've seen something else
17:04:18 <shachaf> So void :: Functor f => f a -> f ()
17:04:19 <FireFly> @ty void
17:04:21 <lambdabot> Functor f => f a -> f ()
17:04:39 <kqr> oh but it's still in control.monad
17:04:40 <kqr> that's silly
17:09:47 <Guest00000> :t (() <$)
17:09:49 <lambdabot> Functor f => f b -> f ()
17:12:51 <Kaidelong> are there typed languages that don't have coproducts or products, even on a meta level?
17:13:48 <Kaidelong> also, does the opposite category for something like Hask have a realization of some kind?
17:14:09 <Kaidelong> it seems you'd need the base language to restrict itself to reversible computation, but then L = L^op
17:17:52 <kqr> for me a common pattern when writing parsers is "fmap Just p <|> pure Nothing" – is there a better way to write this?
17:18:56 <kqr> ah optional has exactly that signature
17:18:57 <kqr> silly me
17:34:01 <vik123> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
17:34:01 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
17:35:00 <vik123> @undo do a <- logNumber 3; b <- logNumber 5; return (a*b)
17:35:01 <lambdabot> logNumber 3 >>= \ a -> logNumber 5 >>= \ b -> return (a * b)
17:47:41 <Gurkenglas> :t liftA2 (*) (?logNumber 3) (?logNumber 5)
17:47:42 <lambdabot> (Num c, Num a, Applicative f, ?logNumber::a -> f c) => f c
18:01:02 <epta> ~>
18:01:59 <Jinxit> do I have to do anything to export lenses created with makeFields?
18:04:44 <Jinxit> because when I switched from makeLenses to makeFields I started getting strange errors when using lenses from imported files
18:25:41 <vik123> what does a tilde mean when using it in a do block?
18:26:05 <vik123> for example on this page: http://hackage.haskell.org/package/transformers-0.5.0.0/docs/src/Control-Monad-Trans-Writer-Lazy.html#Writer
18:26:22 <shachaf> The same thing it means everywhere else.
18:26:32 <vik123> what's that?
18:26:33 <shachaf> https://www.haskell.org/hoogle/?hoogle=~ has a link
18:26:52 <vik123> thanks
18:27:19 <shachaf> It's a good way to find out about some syntax.
18:28:04 <kqr> is it currently possible to use idiom brackets in GHC?
18:28:26 <kqr> i dislike the look of long chains of <*>, but I also hate having to use different functions liftA3, liftA4 etc
18:28:37 <geekosaur> I don't think so
18:29:24 <shachaf> You could use SHE, in theory.
18:40:04 <Jinxit> why do I get ambiguous reference errors when using makeFields to create lenses? isn't that what makeFields is for?
18:40:22 <tgeeky> Jinxit: if you're not getting help, post a code snippet
18:42:22 <lamefun> Is GHCJS any good or should I use PureScript?
18:45:13 <Jinxit> http://lpaste.net/3928590801646387200
18:47:56 <bernalex> kqr: you could use applicative do
18:48:19 <bernalex> or was that not going in until ghc8? I forget...
18:49:05 <geekosaur> ghc8
18:51:02 <kqr> bernalex, that'd force me to come up with unique names for the intermediaries
18:51:24 <kqr> which in this case would be silly
18:51:32 <bernalex> kqr: I'm not the right person to complain to, since I quite like applicative syntax.
18:52:23 <kqr> which one? chains of <*>?
18:54:48 <bernalex> for my third haskell beginners' workshop, I'm going to do "real world" stuff. I'm going to do a short explanation on how IO works (it should not be magic or complicated to anyone attending, since they know typeclasses and *->*-polymorphism well by now), and then we'll do exercises as usual. my idea is to do what I have previously done, and write a bunch of f = undefineds with associated tests. I want to make
18:54:50 <bernalex> a library where they "fill in the answers" to make functions work. but then additionally I want to have a more open-ended part of the workshop, where they make a *program* that uses the library. e.g. a calculator library with stuff like arithmetic operations and traversing an rpn stack, and then they write a REPL calculator that uses it.
18:55:04 <bernalex> now after that wall of text -- here's my question: does anyone have any good ideas for what type of library/program to make?
18:55:33 <bernalex> my ideas so far have been the calculator, and maybe some kind of CLI-game -- but IDK which one lends itself the most to the library + program (library user) giddyup.
18:55:48 <bernalex> kqr: yes, I quite like using <$> and <*> in most cases.
18:56:13 <jle`> <$> and <*> is nice as long as the combining function isn't too complicated
18:57:05 <jle`> but for things like (\(x, y) zs -> case zs of [] -> y + x; (z:_) -> z * y + x) <$> foo <*> bar
18:57:08 <bernalex> jle`: I find it works well for pretty much any real function. it's not until you need to do anonymous functions to "fit" the arguments into a function (e.g. uncurrying or whatever) it gets horrible.
18:57:08 <jle`> it's nice to have do notation and stuff
18:57:25 <jle`> yeah, that's what i mean
18:57:43 <bernalex> yep I saw your post when I hit ^J :D
18:58:03 <jle`> usually i end up naming functions like that, or making the <$>/<*> stuff multi-line
18:58:58 * hackagebot splot 0.3.14 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  https://hackage.haskell.org/package/splot-0.3.14 (EugeneKirpichov)
18:59:00 * hackagebot timeplot 1.0.31 - A tool for visualizing time series from log files.  https://hackage.haskell.org/package/timeplot-1.0.31 (EugeneKirpichov)
19:07:39 <phy1729> Cale: mind a pm?
19:07:51 <Cale> I don't mind
19:08:08 <linduxed> i'm thinking that point-free is cool, but potentially super confusing
19:11:40 <bernalex> linduxed: everything is potentially confusing. but generally the pointfree style is used when the author wants to highlight or explore the compositional nature of an expression, whereas pointful is used to similarly highlight or explore the applicative nature.
19:12:10 <bernalex> (and by applicative I don't mean as in Applicative, but as in "relating to application")
19:14:21 <linduxed> that is an interesting thought, i have to say
19:15:15 <linduxed> that does, however, sound like a nuance that's only perceptible to the more experienced Haskell programmer
19:16:10 <bernalex> that is likely true. I found pointfree sligthly deceiving when I started out.
19:16:25 <linduxed> i'm thinking that the novice Haskell programmer could find it mostly confusing
19:16:44 <linduxed> but i do see your point
19:17:10 * linduxed feels that he's starting to ramble
19:17:20 <linduxed> i should go to sleep, it's quite late here
19:18:34 <bernalex> novice programmers frequently find a great number of things confusing. that's the nature of being a novice. I don't think that you should program for the lcd though. you'll just end up with go.
19:49:18 <lamefun> Is GHCJS any good or should I use PureScript?
19:57:33 <hiptobecubic> they aren't really the same thing.
19:58:19 <lamefun> hiptobecubic, yes, but which one should I use? At least PureScript has a modern flat-design site, GHCJS has no site at all...
19:59:45 <bernalex> lamefun: they are different things. they do different things. what should you use? that depends on what you want to do.
20:03:36 <lamefun> "they are different things" - they aren't?
20:05:12 <exio4> you are comparing a Haskell compiler with a different language 
20:05:16 <lamefun> Ideally I'd use GHCJS since my backend is also in Haskell, and I'd like not to write FromJSON instances twice - but PureScript has a flat-design site and integrates with tools for people like npm and bower.
20:05:21 <bernalex> lamefun: ghcjs is a compiler. purescript is a programming language. not only are they used in different situtations, they are fundamentally entirely different things.
20:07:44 <lamefun> If i said: "Is GHCJS any good or should I use PSC", no one would understand me.
20:08:13 <bernalex> lamefun: I don't understand you presently.
20:09:26 <Jinxit> trying this again: http://lpaste.net/3928590801646387200 having trouble with Lens and makeFields
20:09:33 <lamefun> I want to use something pure instead of JavaScript.
20:09:53 <bernalex> lamefun: it would be valuable if you could be as precise and concrete as possible.
20:10:05 <lamefun> Am I not?
20:11:24 <bernalex> lamefun: I have no idea what you actually want to do, other than that you do not want to do it in javascript.
20:12:28 <lamefun> I think it should be easy to guess: I have some JavaScript code, I want to use something pure instead of JavaScript (preferably GHCJS because I'd like not to re-write Aeson instances in PureScript), what should I use? PureScript has a flat-design site and integrates with tools for people like npm and bower, so I presume it's more mature. 
20:15:14 <bernalex> lamefun: it depends on what the javascript code does. purescript and elm generally have more libraries available IME. but it depends on what you want to do.
20:17:00 <lamefun> Not much, mostly generates HTML from incoming JSON.
20:18:42 <bernalex> lamefun: then I'd look into using ghcjs.
20:26:25 <wedens> is flat-design site main criteria of maturity
20:26:27 <wedens> &
20:26:29 <wedens> ?
20:28:21 <lamefun> wedens, I don't know about it being the main criteria, but it's definitely a very important one.
20:31:00 <lamefun> It shows that the project is alive.
20:38:32 <Cale> GHCJS inherits a whole lot of maturity from GHC
20:38:58 <Cale> The ability to pull most things off of Hackage and just use them is pretty nice.
20:39:58 <tnks> this is a somewhat bipolar conversation.
20:40:00 <Cale> I don't really understand the flat-design site remarks... (what's a flat-design site?)
20:40:32 <tnks> it's the extremely odd inference that a trendy web site indicates maturity.
20:41:22 <lamefun> tnks, PureScript also seems to have some very good docs: https://leanpub.com/purescript/read
20:41:58 <tnks> lamefun: yeah, I think that's a better place to start a comparison.
20:42:22 <ReinH> Merry Christmas! Why are you all here?
20:42:22 <lamefun> Flat design website doesn't indicate maturity, rather it indicates that a thing is less likely to be dead.
20:42:46 <lamefun> Flat design website > outdated website > no website.
20:43:06 <ReinH> Cale: Being able to compile so many things off the shelf with ghcjs is staggering
20:43:24 <ReinH> Cale: having lenses in the browser is amazing
20:43:26 <Cale> lamefun: What's a flat design website?
20:43:34 <ReinH> Cale: think Windows 10
20:43:55 <ReinH> a reactionary response to the rounded corners and gradients of web 2.0 ;)
20:44:11 <Cale> Are we literally talking about the visual appearance? Is the next fashionable thing going to be "blue design website"?
20:44:45 <ReinH> Cale: The argument is basically: if a website has a design which follows recent trents then it was updated recently
20:44:47 <lamefun> If it is, not upgrading to "blue design" will be a sign of a dying/dead project.
20:44:50 <ReinH> *trends
20:44:57 <tnks> lamefun: flat design isn't that new. . . I think this reasoning is too thin.
20:45:00 <ReinH> Cale: what the trend happens to be is not material to the argument
20:45:11 <Cale> "You can tell how mature this project must be because its website looks like it was thrown together yesterday"
20:45:21 <Cale> lol
20:45:30 <exio4> sounds contradictory
20:45:32 <ReinH> Cale: I'm not making the argument, but I don't think it's about maturity
20:45:35 <Cale> Wouldn't an old-fashioned website be a better indicator of maturity?
20:45:38 <ReinH> I think it's just about freshness
20:45:49 <ReinH> e.g. "has been updated since flat design became a thing"
20:45:54 <ReinH> er, I mean "i.e." don't I
20:45:59 <ReinH> Yes, yes I do
20:47:00 <ReinH> Cale: anyway, let's talk about the unreasonable effectiveness of ghcjs
20:47:15 <tnks> lamefun: I believe Slamdata (a startup in Colorado) does most of their front-end in Purescript.
20:47:23 <lamefun> I should have said: PureScript has a flat-design site so it isn't likely to be abandoned and has some great docs (unlike what I've seen so far for GHCJS), seems to have a convenient DOM.Free package and integrates with tools for PEOPLE like npm and bower, so I presume it's more mature.
20:47:24 <Cale> Sure
20:47:43 <tnks> so that's at least one company trying it out at some non-trivial scale.
20:47:50 <lamefun> http://docs.haskellstack.org/en/stable/ghcjs.html
20:48:04 <Cale> I also find it amusing that a distinct lack of 3D has come to be a sign of modernity
20:48:11 <Cale> Also seems backward
20:48:34 <geppettodivacin> I'm getting a stack overflow error in this MWE when I run testProblem. http://lpaste.net/147856
20:48:49 <geppettodivacin> Does anyone know where the thunks are building up?
20:49:24 <ReinH> geppettodivacin: in iterate
20:50:02 <ReinH> nextValueTest is strict, but it is never scrutinized until 20000000 thunks are unwound
20:50:05 <lamefun> Cale, I think it's called "outgrowing childlishness", i.e. people have already played with 3D and stuff enough, it's time to get more serious.
20:50:28 <geppettodivacin> ReinH: Is there a way to make iterate operate strictly?
20:50:31 <Cale> Well, 3D is a quality that something can have or not, like the colour blue.
20:50:34 <ReinH> @hoogle iterate'
20:50:35 <lambdabot> No results found
20:50:41 <ReinH> Yes. Define a strict iterate. :D
20:50:50 <geppettodivacin> Right. XD
20:50:55 <tnks> lamefun: Cale: I think it's really about using pixels more effectively; if there's not a 3D message, there really shouldn't be 3D.
20:51:25 <Cale> It can serve purposes. I think a lot of older UIs actually did a pretty good job of using some small degree of 3D-ness to indicate clearly what could be interacted with
20:51:33 <Cale> But there are other ways to do the same
20:51:51 <ReinH> Cale: Yes, a fair amount of effort has gone into making flat affordances effective, actually
20:52:04 <Cale> and is it really accomplishing much?
20:52:06 <ReinH> usually they are distinguished using color and shape
20:52:09 <ReinH> Cale: it's a fad
20:52:14 <ReinH> what do fads ever accomplish?
20:52:19 <Cale> It seems like an uphill battle for little reason
20:52:37 <ReinH> Cale: design spaces always revolve around fads
20:52:55 <Cale> I'm not sure I completely agree with that
20:52:57 <ReinH> it's actually an interesting game-theoretic interaction, but that's maybe a bit too far off topic
20:52:59 <tnks> I think some parts are fads. . . but wholesale discarding all design as a fad seems too far.
20:53:00 <Cale> "always" is maybe too strong
20:53:05 <ReinH> Cale: Sure. Often.
20:53:30 <ReinH> tnks: the parts of flat design that are not a fad are not unique to flat design
20:53:31 <lamefun> ReinH, how would you distinguish outdated websites and dead projects from modern, up-to-date stuff without fads?
20:53:41 <ReinH> lamefun: I'm not saying that fads are bad
20:53:43 <ReinH> only that they are
20:53:59 <ReinH> look at the success of fads in clothing design
20:54:01 <tnks> ReinH: yeah, I agree. . . also, I probably don't really know culturally exactly what "flat design" means.
20:54:12 <lamefun> Also it wouldn't be fun if nothing ever changed.
20:54:15 <tnks> I think at this point, it's like "Agile" or "Web 2.0"
20:54:26 <ReinH> maybe I should say "trend" or some other more neutral word
20:54:42 <ReinH> I don't think fads are bad, but I definitely think they exist in many design spaces, and web design is definitely one of them
20:54:53 <dmj`> tnks: http://designmodo.github.io/Flat-UI/
20:55:08 <ReinH> also google's new mobile style
20:55:32 <ReinH> although actually the material stuff uses drop shadows iirc
20:55:37 <ReinH> it's super nice though
20:55:43 <ReinH> and more effective than flat imho
20:55:52 <ReinH> (http://www.google.com/design/spec/material-design/introduction.html)
20:56:04 <Cale> ReinH: If that's the thing which made them decide to turn all of Chrome's folder icons grey, it's really dumb
20:56:10 <ReinH> heh
20:56:38 <ReinH> Cale: anyway I'm super excited that lens compiles with ghcjs, and I even have template haskell
20:56:46 <ReinH> although I guess that's not surprising
20:56:49 <ReinH> since it's a preprocessor
20:57:05 <Cale> ReinH: I've also gotten diagrams to compile, and used it to dynamically splice SVG into a page
20:57:31 <geppettodivacin> This is my (failed) attempt at making iterate strict. What needs to be inspected, if not the values generated by iterate? http://lpaste.net/147856
20:58:00 <ReinH> Cale: Yeah, I'm looking at that diagrams-reflex PoC right now
20:58:13 <ReinH> Cale: I would really like to lean on diagrams-svg
20:58:22 <ReinH> but it needs to be dynamic
20:58:31 <Cale> geppettodivacin: You can factor the strictness out into a separate function:
20:58:50 <Cale> @let strictList [] = []; strictList (x:xs) = x `seq` (x : strictList xs)
20:58:52 <lambdabot>  Defined.
20:58:59 <Guest00000> geppettodivacin: what do you mean by "not strict enough"? try changing seq associativity: newX `seq` (x : iterate f newX)
20:59:10 <Cale> geppettodivacin: Also, your bang pattern on nextValueTest does nothing
20:59:41 <geppettodivacin> Cale: I had a feeling that it did nothing, but I wanted to verify that it actually made the value strict.
20:59:42 <ReinH> Cale: nice
21:00:00 <Cale> > iterate (+1) 0 !! 1000000
21:00:02 <lambdabot>  *Exception: stack overflow
21:00:05 <ReinH> Cale: tbqh my laziness debugging goes like this: add bangs everywhere, start removing until it stop working. ;)
21:00:08 <Cale> > strictList (iterate (+1) 0) !! 1000000
21:00:11 <lambdabot>  1000000
21:00:20 <ReinH> Cale: the beatings will continue until morale improves sort of thing
21:00:45 <Cale> ReinH: I tend to look for places where expressions are being accumulated and start there
21:00:45 <Guest00000> okay, i understood what "not strict enough" means.
21:01:02 <geppettodivacin> Cale: What is different about your version than my version? To the untrained eye, it looks like both inspect every element as it is created.
21:01:03 <ReinH> Cale: I like the space invariants approach, but I struggle to apply it successfuly
21:01:14 <Cale> ReinH: Generally the places where you want strictness are where there are lots of values which are being summarized somehow into a value with not many parts.
21:01:34 <ReinH> Cale: I was being slightly hyperbolic, but I am a bit more guess-and-check than I would like.
21:01:42 <ReinH> I do have a few heuristics ;)
21:01:48 <Cale> geppettodivacin: strictList might be useful elsewhere :)
21:01:54 <lamefun> http://docs.haskellstack.org/en/stable/ghcjs.html - which one should I use?
21:02:04 <ReinH> Cale: I think the question is: how does strictList actually even?
21:02:05 <geppettodivacin> True, but iterate' didn't actually prevent a segfault.
21:02:09 <geppettodivacin> But strictList did.
21:02:17 <Cale> oh, let me look
21:02:41 <Cale> Oh, you recursed using iterate
21:02:43 <Cale> not iterate'
21:02:48 <geppettodivacin> Oh. XD
21:02:51 <geppettodivacin> Thanks!
21:02:57 <Cale> No problem :)
21:04:14 <ReinH> geppettodivacin: sudo iterate'
21:04:41 <geppettodivacin> ReinH: I'm not sure what you mean.
21:05:21 <Cale> ReinH: So, the reason that strictList helps is that as you walk down the resulting list, the elements of that list are being evaluated (to whnf). Without it, what happens is you're *not* evaluating the f (f (f ... (f x) ...)), and when you get to the millionth element, that's a large expression to handle all at once. Since f is strict in this case (i.e. it matches on its argument), this results in a million stack entri
21:05:21 <Cale> es from each of the pattern matches.
21:06:00 <Cale> If on the other hand, we force the partial expressions to be evaluated as we walk down the list, the stack never gets more than a constant number of elements deep
21:06:19 <Cale> There's sharing going on between the elements of iterate f x
21:06:29 <ReinH> geppettodivacin: it is not important
21:06:30 <Cale> i.e. the second element of that list refers to the first
21:06:32 <Cale> and so on
21:07:08 <Cale> and so as long as we're forcing the evaluation as we go, we never have very much work to do to evaluate the next element, just a single application of f at a time
21:09:42 <ReinH> Cale: I found my new favorite "why can't Haskell solve the halting problem? in disguise" question on StackOverflow today.
21:09:56 <Cale> heh
21:10:13 <Cale> Haskell pls
21:10:14 <ReinH> Cale: it includes: null undefined must be False, since undefined is not [].
21:10:22 <Cale> haha
21:10:34 <ReinH> halts x = null x || notNull x -- we did it!
21:11:19 <ReinH> Haskell I am disappoint
21:34:36 <lamefun> Does "Try it" at haskell.org use GHCJS?
21:41:34 <dmj`> lamefun: think it's the ghc api, could be wrong though
22:00:20 <dmwit> lispy: I know some about it, but tryam seems to be gone. =P
22:06:36 <lamefun> Oh "open" source...
22:06:50 <lamefun> Can't setup ghcjs on Ubuntu: fatal: minimum required version for node.js is 0.10.28, found: v0.10.25
22:12:41 <bernalex> ReinH: tbf solving the halting problem is really trivial. I mean even coq does it.
22:13:38 <dmwit> ReinH: I think you are misrepresenting the post in question badly.
22:14:25 <dmwit> The sentence "null undefined must be False, since undefined is not []" is explicitly marked as something the writer does not believe.
22:18:55 <wedens> lamefun: use stack
22:19:09 <lamefun> wedens, I'm already using Stack
22:19:34 <lamefun> can stack install nodejs locally too?
22:21:51 <wedens> I don't think so
22:41:18 <lamefun> I hope package "management" dies in fire.
22:42:12 <lamefun> I mean Linux style of it.
22:43:00 <lamefun> Apple package management rocks (hackage is Apple package management).
22:47:16 <pharaun> um, what
22:47:25 <pharaun> hackage isn't exactly curated
22:59:32 <lamefun> pharaun, that's not the most important feature, the most important feature is that developers manage their packages themselves.
23:00:37 <pikajude> isn't that, by definition, a feature of packages
23:01:21 <lamefun> Not Linux style packages that should die in fire.
23:02:13 <lamefun> I mean, devs can of course make their own packages, but they won't be what users install from software center.
23:06:36 <pharaun> idk, cos apple is curated, you can't just push your own app or etc
23:06:43 <pharaun> to ios you have to send it to apple for approval
23:06:55 <pharaun> and iirc i thought this also applied to the software center
23:12:08 <nshepperd_> Linux style package maintainership exists because Linux never had a uniform idea of installation
23:12:43 <lamefun> Yes. Sweet lies of diverisitivsm...
23:14:12 <lamefun> That's why Windows rocks, Android rocks, Apple rocks, and generally PRO!prietary and partially PRO!prietary software rocks, because it can actually embrace and act on the ONEist truth.
23:15:18 <lamefun> Also, can't build ghcjs: setup: The program 'ghcjs' version >=0.1 is required but the version of
23:15:18 <lamefun> could not be determined.
23:16:00 <lamefun> /home/lamefun/.stack/programs/x86_64-linux/ghcjs-0.2.0.20151029_ghc-7.10.2/src/.stack-work/install/x86_64-linux/lts-3.6/7.10.2/bin/ghcjs
23:17:41 <lamefun> ghcjs-0.2.0.20151029 is clearly >= 0.1
23:18:09 <pikajude> the version of newline could not be determined is usually a bad sign
23:18:41 <lamefun> no, it was
23:18:53 <lamefun> the path went between 'of' and 'could not be determined'.
23:20:39 <luigy> oh boy #1496 again and same lts snapshot
23:20:48 <luigy> where is this stack.yaml coming from
23:21:10 <luigy> so far only happening on linux also
23:33:58 <lamefun> luigy, http://docs.haskellstack.org/en/stable/ghcjs.html -- I just copied the 2015-10-29 master branch snippet from there into an almost-empty stack.yaml
23:34:28 <lamefun> it just had lts-3.6 resolver and packages: - '.' in it
23:35:23 <lamefun> It's Ubuntu 15.10
