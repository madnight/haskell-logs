00:01:06 <sgronblo> srhb: Right, I guess I will get used to it if I work more with Haskell. Just wondered if I was doing something wrong.
00:29:12 * hackagebot hfmt 0.0.2.1 - Haskell source code formatter  https://hackage.haskell.org/package/hfmt-0.0.2.1 (danielstiner)
00:41:28 <wedens> is there parser combinators libraries comparison?
02:00:04 <padre_angolano> hmm, why would ghc say lexical error if I type the unicode char '󾭪'
02:00:24 <padre_angolano> lexical error in string/character literal at character '\1043306'
02:01:13 <padre_angolano> > Data.Char.ord '�'
02:01:15 <lambdabot>  65533
02:01:23 <padre_angolano> aha, here it works
02:02:50 <padre_angolano> > Data.Char.ord '󾭪'
02:02:51 <lambdabot>  <hint>:1:16:
02:02:52 <lambdabot>      lexical error in string/character literal at character '\1043306'
02:02:57 <padre_angolano> ah, this char
02:47:45 <makalu> is there a stackage for GHC 7.6?
02:49:18 <makalu> I guess not, even stackage.org/lts/0 gives 7.8.3
02:55:38 <bergmark> makalu: stackage started on 7.8
03:00:41 <bergmark> there has been a few requests for keeping a 7.8 branch open alongside 7.10, but no decisions have been made
03:04:10 <makalu> are you saying that 7.8 might not be supported in the near future?
03:05:28 <bergmark> makalu: it's not supported now, only the nightly and LTS3 are being updated
03:06:56 <makalu> that's sad :(. I guess the idea is that you use stack to install 7.10?
03:07:35 <bergmark> well you can pick whatever way you want to install it :-)
03:08:34 <bergmark>  but at work we still use 7.8 and we have our own snapshot, we haven't had any problems with libraries not supporting 7.8 (though there are definitely some)
03:08:48 <makalu> if you use Linux there are basically two options: 1) you are lucky and get 7.10 from the package manager 2) you go through massive pains to set up 7.10 yourself :)
03:09:35 <makalu> I wonder how the stack GHC binaries are built. Are they expected to work on every weird Linux distro?
03:09:35 <bergmark> i install from the binary distribution (on OS X), it's really simple: ./configure --prefix=~/ghc7.10 && make install
03:10:05 <makalu> I have used the binary distribution as well but setting up your path and stuff like that may not be the most convenient way for new users
03:10:27 <bergmark> stack should be simpler
03:30:00 <makalu> it seems that "extra-package-dbs" is not in the documentation
03:32:12 <MyOtherNick> How efficiently does haskell deal with memory? How does it compare to clojure/racket?
03:39:13 <linduxed> MyOtherNick: without having done any benchmarking or anything to that effect, from what i've understood it's fairly good at what it does
03:40:08 <linduxed> if it isn't good enough, however, there are ways you can tell the compiler to box certain things and unbox others
03:40:26 <linduxed> leading to you having more control over what goes into the heap vs. the stack
03:40:37 <linduxed> i remember there being a talk about this on the haskell exchange 2015
03:41:01 <linduxed> unfortunately i can't say how it compares to either clojure or racket
03:41:36 <linduxed> although it has to be said that memory management is something that the ghc mailing list is constantly talking about
03:41:50 <linduxed> there are definitely things to improve in this area
03:43:36 <MyOtherNick> The only thing keeping me from jumping into haskell is its learning curve. I have work to get done :S
03:47:26 <srhb> MyOtherNick: Totally worth it. Mind, I'm biased (as is most the rest of the channel) :-P
03:49:02 <suppi> Haskell is really hard. I now have a really hard time programming in other languages
03:49:23 <dredozubov> it's not haskell that's hard
03:49:30 <dredozubov> it's programming in other languages after haskell
03:50:00 <suppi> well, I guess that's more like it
03:50:04 <MyOtherNick> thats why i stuck with lisps, and am afraid of going down deeper :S
03:50:55 <suppi> I'm trying to learn some lisping myself, but it's hard without a purpose
03:51:11 * dredozubov hopes that one day typed vs non-typed choices would be a no-brainer for everybody
03:51:46 <MyOtherNick> to be more precise, im stuck with typed racket/clojure for now :P
03:51:58 <MyOtherNick> i agree that dynamic typing is unethical
03:52:23 <dredozubov> MyOtherNick: isn't type checking happens at runtime there?
03:52:34 <dredozubov> so it kinda fails the purpose
03:52:48 <MyOtherNick> In racket, no. Only if you call typed code from untyped modules.
03:53:03 <MyOtherNick> Otherwise its static, and the optimizes exloits the fact.
03:53:26 <suppi> typed racket looks pretty nice
03:53:28 <ggole> Typed racket is fairly nice
03:53:52 <suppi> ggole, ;)
03:54:03 <dredozubov> it sound pretty decent for a dynamic language
03:54:04 <ggole> Some of the types that are necessary in order to faithfully describe Scheme terms are less nice, though
03:54:42 <dredozubov> MyOtherNick: anyway, you'll get much more out of the type system in haskell, this should be a huge selling point. But for some reason it isn't.
03:55:25 <MyOtherNick> no doubt, haskell was founded on types.
03:59:35 <dredozubov> not really, it was made to research laziness
03:59:58 <dredozubov> it just surpassed ML/etc in type-level power over the years
04:01:12 <madoux> ciao
04:01:16 <madoux> !list
04:01:16 <monochrom> madoux: http://okmij.org/ftp
04:02:07 <suppi> MLs don't have higher kinds right?
04:02:33 <ggole> The ML way to do that sort of thing is functors
04:03:17 <suppi> but functors are on module aren't they? not types?
04:03:51 <ggole> Yes, but modules can contain types. So you can achieve much the same effect.
04:04:30 <ggole> All of the boring piping is annoyingly explicit though
04:04:52 <suppi> yeah, the boilerplate is not so nice
04:05:24 <suppi> I really like higher kinds and how concise they are
04:05:27 <Darwin226> Hey guys. I've recently released the visibility package for computing visibility polygons. The whole package is there only for one function it provides but since it deals with geometry it also exports Point na Polygon data types
04:06:06 <Darwin226> I'd like to not force users to adopt my geometric types and only use my algorithm. What are my options? I could overload the whole algorithm to work on some typeclass, but I'm wondering if the constant indirection
04:06:29 <Darwin226> will have more of a performance penalty than simply converting to my types, calling my function then converting back to their type
04:06:46 <Darwin226> What's the best approach her?
04:34:49 * hackagebot visibility 0.1.0.1 - Simple computation of visibility polygons.  https://hackage.haskell.org/package/visibility-0.1.0.1 (darwin226)
04:54:35 <aloiscochard> Darwin226: the only way to know for sure about perf impact of typeclass is to analyze the generated core or do some benchmarking, in theory you should be able to get similary performance but that might requiere some tuning, personally I would swap your custom datatype with the one who seems mast commonly used in the domain, seems like
04:54:35 <aloiscochard> https://hackage.haskell.org/package/hgeometry is a good candidate
04:55:20 <aloiscochard> Darwin226: actually, I would even consider contributing your algo to the hgeometry package
05:13:08 <linduxed> so let's say i've got the following data type: data Coordinate = Coordinate Int Int
05:13:25 <linduxed> also, let's we've got one of those: a = Coordinate 1 2
05:13:33 <linduxed> how would i destructure that thing?
05:13:42 <linduxed> i want to get out the 1 and 2
05:13:46 <magneticduck1> (Coordinate x y) = a
05:13:47 <muesli4> linduxed with a pattern match
05:13:49 <linduxed> pattern mathcing?
05:13:55 <linduxed> ah yes
05:14:13 <magneticduck1> > let x = (1:[]) in (let (y:[]) = x) in y 
05:14:14 <lambdabot>  <hint>:1:20: parse error in let binding: missing required 'in'
05:14:17 <linduxed> as i wrote it, i kind of realized i've done the same thing plenty of times with Just
05:14:20 <magneticduck1> > let x = (1:[]) in ((let (y:[]) = x) in y) 
05:14:22 <lambdabot>  <hint>:1:21: parse error in let binding: missing required 'in'
05:14:38 <magneticduck1> > (let (x = (1:[])) in ((let (y:[]) = x) in (y))) 
05:14:40 <lambdabot>  <hint>:1:9: parse error on input ‘=’
05:14:45 <magneticduck1> haaaa
05:15:49 <muesli4> > let { x = 1 : [] } in let { (y : []) = x } in y
05:15:50 <lambdabot>  1
05:20:42 <icbm> I want to have an "associated constant" with a typeclass instance.  ex: `instance C T where foo = 42`.  If this is possible, what should I google for?
05:22:26 <pavonia> icbm: foo needs an additional type parameter that mentions the type variable for C
05:23:40 <icbm> pavonia: I can make it `foo _ = 42` easily enough.
05:25:01 <pavonia> Exactly
05:25:21 <icbm> pavonia: OK, I'll just do that. Thanks
05:25:51 <pavonia> I think this is where Data.Proxy comes into play
05:26:38 <icbm> pavonia: Aha, that smells like a learning opportunity. Heading to $search_engine now...
05:27:31 <lonokhov> is there anything like this in a generic library? http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Builder-Prim.html#v:-62--42--60-
05:34:20 <Jinxit> is there any predefined type in haskell which says something like "Just a <> Nothing = Just a" and "Just a <> Just b = Just a"?
05:34:29 <Jinxit> sort of keeping the first result
05:35:14 <icbm> Jinxit: I've used First to do that before
05:35:38 <Jinxit> so First is a thing already?
05:35:42 <Jinxit> that explains my issues
05:35:59 <icbm> Jinxit: `getFirst . foldMap First ...`
05:36:22 <Jinxit> yeah I also came up with the brilliant name First for the same thing lol
05:36:32 <Jinxit> but ghc started yelling at me so I suspected something was up
05:36:53 <Jinxit> thanks
05:37:22 <icbm> Jinxit: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#t:First
05:37:39 <Jinxit> yeah I found it
05:37:43 <icbm> Jinxit: Great minds think alike. :)
05:38:40 <ben> > Nothing <|> Just 42
05:38:42 <lambdabot>  Just 42
05:39:56 <Jinxit> and while I'm here, a pattern I keep repeating in lens and State is "thing <- get; let ... = thing^.otherThing", am I missing something?
05:40:27 <doomrobo> hey could anyone tell me if there's a neater way of defining _1 and _2 in this code? I'm really new to this. http://lpaste.net/147948
05:42:17 <srhb> Jinxit: The stateful operators? They have % in them afair
05:42:26 <icbm> Jinxit: I'm a noob deluxe, and haven't even thought about lenses, but would `get >>= (^. otherThing)` do it?
05:44:02 <Jinxit> srhb: isn't % for applying functions?
05:44:30 <Jinxit> icbm: maybe, but I'm not sure I prefer it
05:45:05 <icbm> Jinxit: You could always make a >>^. operator. :)
05:45:23 <Jinxit> haha
05:45:35 <Jinxit> I prefer not to confuse the reader if possible
05:45:46 <aweinstock> Jinxit: icbm: instead of (getFirst . foldMap First), you can do (ala First foldMap)
05:45:59 <aweinstock> ala is kind of like fmap over a newtype
05:46:20 <icbm> aweinstock: Ooh, gonna look at that one. Thanks!
05:46:25 <aweinstock> :t ala First
05:46:26 <lambdabot> ((Maybe b -> First b) -> e -> First b1) -> e -> Maybe b1
05:46:48 <aweinstock> :t ala First foldMap
05:46:49 <lambdabot> Foldable t => t (Maybe b) -> Maybe b
05:47:12 <nshepperd> Jinxit: 'use' might be the function you want
05:49:07 <icbm> aweinstock: Uh, where is `ala`? Can't find it in Dash or Hoogle.
05:49:34 <icbm> aweinstock: Nvm, found it in package 'newtype'
05:49:52 <Jinxit> nshepperd: without a temporary?
05:50:29 <nshepperd_> Jinxit: ya
05:50:54 <nshepperd_> :t ... <- use otherThing
05:50:55 <lambdabot> parse error on input ‘...’
05:51:02 <nshepperd_> whoops
05:51:05 <nshepperd_> well you do that
05:51:13 <nshepperd_> :t use _1 -- for instance
05:51:14 <lambdabot> (Field1 s s b b, MonadState s m) => m b
05:51:46 <Jinxit> I get ambiguity errors
05:52:16 <Jinxit> maybe because I'm using makeFields?
05:54:23 <nshepperd_> ambiguity huh
05:54:34 <nshepperd_> this should be equivalent to what you were doing
05:55:07 <nshepperd_> is otherThing polymorphic somehow?
05:55:21 <Jinxit> I'll make a more complete example, hold on
05:57:39 <Jinxit> nshepperd_: http://lpaste.net/8180071858717065216
06:11:36 <nshepperd_> ah, I see, yes the HasPlayers typeclass there
06:13:57 <nshepperd_> the ambiguity goes away if the state monad is specified
06:14:06 <nshepperd_> ie. give a type for getCharacter
06:15:05 <Jinxit> nope :(
06:15:38 <Jinxit> it complains that hero is ambiguous
06:16:09 <Jinxit> or rather, s0 in HasHero s0 Hero is ambiguous
06:17:49 <nshepperd_> see my annotation on your paste. that code compiles for me
06:20:44 <Jinxit> ah
06:20:48 <Jinxit> still uses a temporary though
06:20:57 <Jinxit> (which is what I'm trying to get away from)
06:24:17 <nshepperd_> well the options there are 'map (view hero) <$> use players'
06:24:28 <Fuco> Xmonad uses <+> as infix mappend, is that somewhat standard?  I have a similar usecase (composing hooks/callbacks) and I was wondering how to implement it... xmonad uses Monoid instance for that and it seems quite reasonable.
06:24:40 <nshepperd_> or 'use (players . to (map (view hero)))'
06:24:52 <nshepperd_> or some third more lensy thing that I don't know right now...
06:26:29 <MarcelineVQ> Fuco: afaik the typical infix mappend tends to be: <>
06:27:58 <kadoban> It is <>. It's defined right in Data.Monoid as an alias
06:28:14 <MarcelineVQ> But I also don't think it matters too much. <> is consistent but having your own expresses you're using a mappend related to your lib, so it's probably just preference in the end. I can't say whether <+> is subtly different for Xmonad because I don't know it
06:29:01 <Fuco> right
06:30:19 <Fuco> basically I have two functions "a -> b -> m c" (m = monad) and I want to 'combine them' by automatically supplying the arguments... so my operator would "partially apply" the a/b and then sequence the m c actions with >>
06:30:48 <Fuco> or something like that... combining callbacks into one function
06:31:31 <Jinxit> nshepperd_: since you seem to know lenses well: I have two data types that share some information (health, uuid, etc), is there an easy way to make a typeclass for the shared types?
06:31:54 <Jinxit> I know of the HasHealth etc typeclasses, but I want to aggregate several of them
06:32:00 <jewels> Hi to all. I'm trying to understand how works Algebra.Lattice (https://hackage.haskell.org/package/lattices-1.5.0/docs/Algebra-Lattice.html). Someone has ever tried this library?
06:35:43 <doomrobo> could anyone recommend how to simplify the definitions of _1 and _2 in this code? http://lpaste.net/147948
06:37:20 <Fuco> why can't I derive Applicative instance?
06:37:42 <Fuco> if I have derived Functor and Monad surely you can construct Applicative from that
06:38:24 <Fuco> nevermind, I already had an instance written out, so it complained abut redefinition :P
06:39:03 <linduxed> so i've got a Matrix Bool
06:39:09 <linduxed> i wuold like to count all the True in it
06:39:24 <linduxed> do i have to do a getElem with every coordinate?
06:40:06 <muesli4_> linduxed: Depends on what you matrix is represented as.
06:41:09 <linduxed> muesli4_: i used the Matrix library http://hackage.haskell.org/package/matrix-0.3.4.4/docs/Data-Matrix.html#g:2
06:43:00 <muesli4_> linduxed: I see, getElem would be in O(1), so that would be fine.
06:43:13 <nshepperd_> Jinxit: you mean you want to make a single typeclass containing both health and uuid info?
06:43:36 <muesli4_> linduxed: Another solution would be using the list conversion functions on it, and then using list functions.
06:43:53 <muesli4_> linduxed: length . filter id . toList
06:44:15 <Jinxit> nshepperd_: correct
06:44:57 <linduxed> hmmm, didn't see the list conversion functions...
06:45:02 <nshepperd_> Jinxit: you can of course do 'class (HasHealth s Health, HasUUID s UUID) => IsCreature s where {}' or something like that
06:45:18 <linduxed> i mean there's fromList...
06:45:22 <linduxed> Oh!
06:45:24 <linduxed> there it is
06:45:24 <nshepperd_> and then make instances
06:45:26 <linduxed> toList
06:45:27 <nshepperd_> then IsCreature serves as shorthand for those classes
06:45:35 <linduxed> yeah i like that idea
06:45:38 <linduxed> i'll run with that
06:45:48 <Jinxit> lemme poke at this for a bit
06:51:00 <haskell954> Quick question regarding data hiding. I've got a bunch of data types representing an AST. I'd like to hide the value constructors from end users. But I don't want to hide the value constructors from my other modules. Is there an easy way to do this? Or do I have to put everything that uses the value constructors in one module?
06:51:20 <doomrobo> how do I convert Either (f a) (f b) into f (Either a b) where f is a Functor?
06:51:30 <merijn> haskell954: Define an internal module that exports the constructors, but don't expose the module to the user
06:51:52 <merijn> haskell954: Then reexport the type from your internal module hiding the constructors
06:52:38 <merijn> haskell954: Modules are only user visible if you list them as exposed modules in your cabal file, all other modules are internal to your package :)
06:53:14 <haskell954> Okay cool, but my exposed modules can still depend on unexposed modules, as long as they are included in the package?
06:53:26 <merijn> haskell954: Yeah
06:53:37 <haskell954> Got it, okay thats perfect, thanks
06:53:53 <merijn> Not sure if there's any simple examples, but lots of libraries on hackage do this
06:54:07 <haskell954> I figured there must be a way
06:54:34 <haskell954> I think I can figure it out. I've actually never packaged something up in cabal before, but it seems straight forward. At least for simple packages.
06:54:47 <merijn> haskell954: Useful trick, you can write "module Foo" in your module's export list to re-export everything you've imported from Foo from that module
06:54:49 <bitemyapp> merijn: thank you
06:55:04 <bitemyapp> merijn: for not telling them to make the data constructors totally invisible
06:55:12 <merijn> haskell954: Just run "cabal init" and follow the walkthrough :p
06:55:15 <bitemyapp> at least I don't think you did. maybe that could be read either way.
06:55:37 <haskell954> I'm not sure what you mean by re-export
06:56:40 <merijn> haskell954: You can export symbols from a module other than the one they were defined in, i.e. "module Foo (foo, bar, Data.List.map) where import Data.List; ..." now importing "Foo" will also import Data.List.map as "Foo.map"
06:56:45 <merijn> bitemyapp: I think I did? :p
06:57:17 <haskell954> Oh I see
06:57:31 <merijn> haskell954: bitemyap is pointing out that some people prefer having the internal module exposed to, so people that want/need to can still unsafely mess with the internals of your library
06:57:50 <merijn> Usually in the form of a "Foo.Internal.Unsafe" module or whatever
06:58:01 <merijn> Instead of not exposing that module at all
06:58:43 <merijn> bitemyapp: I don't have a strong opinion on that sorta thing, so I'll let other people fight^H^H^H^H^Hpaint that bikeshed :p
06:59:28 <haskell954> I think thats a good idea, considering that as long as you dont use the unsafe module, any changes to the AST can remain non-breaking.
06:59:37 <bitemyapp> merijn: well, you didn't specify whether Internal could be visible or not to end-users.
07:00:04 <bitemyapp> oh, you did
07:00:09 <bitemyapp> "don't expose the module to the users"
07:00:14 <bitemyapp> I've been awake too long.
07:00:35 <merijn> bitemyapp: Well, to be fair, that was explicitly what was asked for :p
07:00:39 <bitemyapp> whatevs. haskell954 has already been saved from information-hiding-uber-alles already
07:00:44 <bitemyapp> merijn: that's why I'm a judo master
07:00:58 <bitemyapp> they now want what had never occurred to them before!
07:01:03 * bitemyapp laughs evilly in the mist
07:01:20 <kadoban> lol
07:01:35 <MarcelineVQ> what have you done...
07:01:36 <haskell954> Basically what I'm doing is I have this languages that I have a parser for, as well as some functions for performing data analysis (very busy expressions, etc.). The interface I'm trying to setup is to create a data constructor for the AST and then have all my data analyses take that type. 
07:01:39 <merijn> anyway...grocery shopping time
07:01:56 <bitemyapp> merijn: food is good
07:02:04 <haskell954> Then you can write the concrete syntax, turn it into AST, and perform analyses on it, without ever exposing the AST structure itself
07:02:30 <haskell954> but obviously the data analyses modules need to AST value constructors, so thats what I'll do
07:03:16 <haskell954> Thanks for the help
07:03:56 <bitemyapp> probably best to make the AST available just in case there was something you didn't think of
07:04:15 <bitemyapp> with the proviso that the stability guarantees for the AST are weaker because cases might get added/removed, etc.
07:04:35 <haskell954> I agree
07:14:53 * hackagebot webapp 0.1.1 - Haskell web scaffolding using Scotty, WAI, and Warp  https://hackage.haskell.org/package/webapp-0.1.1 (natesymer)
07:14:59 <Jinxit> nshepperd_: http://lpaste.net/2108977290506403840 mind taking a look?
07:17:43 <nshepperd_> Jinxit: ah, you want that class to be empty there
07:17:53 <cmotoche> Hello everybody, do you know how can I csrfTokenSplice to display in my template?
07:18:09 <nshepperd_> health and uuid methods are already inherited from the superclasses
07:18:51 <Jinxit> oh yeah that makes sense
07:18:53 <Jinxit> thanks
07:19:42 <nshepperd_> and yeah you then want to do like 'instance IsCreature Minion' with empty instance body and so on
07:22:42 <linduxed> i've got this line in my code
07:22:44 <linduxed> import Data.Matrix hiding (<|>)
07:22:57 <linduxed> when i compile it, i get this: parse error on input ‘<|>’
07:23:05 <linduxed> on the import line
07:23:12 <linduxed> any idea what could be causing this?
07:23:17 <kadoban> linduxed: ((<|>))
07:23:24 <linduxed> oh
07:23:38 <linduxed> is there... some rule as to when i should enclose stuff in more parens?
07:24:05 <kadoban> linduxed: Basically any time you're not using an operator in infix context, it needs () around it
07:24:15 <linduxed> ah
07:24:27 <linduxed> what makes an operator an operator?
07:24:39 <linduxed> is it "if it only contains symbols"?
07:24:47 <kadoban> linduxed: So:   blah <|> blah      makes sense, but if you want just the operator itself, like say    foldr (<|>)    you'd need parens
07:25:15 <kadoban> linduxed: Essentially, yep that's it. I'm sure there's something more formal about it in the report, but that's the jist.
07:25:16 <maerwald> foldr (\x y -> x <|> y) works too :P
07:25:28 <pavolzetor>  Couldn't match expected type ‘Int’ with actual type ‘GHC.Int.Int64’
07:25:31 <pavolzetor> what does this mean?
07:25:43 <pavolzetor> bytestring length function is Int in the documentation
07:27:28 <bergmark> pavolzetor: what type does your program expect it to return? you can put a type hole to make it clearer, e.g. foo . _ . bar
07:27:42 <pavolzetor> Int
07:27:57 <pavolzetor> typehole?
07:28:18 <pavolzetor> offsetTable :: Int -> Int -> Int -> Put
07:28:24 <pavolzetor> it is first argument to this function
07:29:45 <bergmark> https://www.youtube.com/watch?v=52VsgyexS8Q
07:29:46 <pavolzetor> I can use fromIntegral, but I should not need to, since the documentation says it is Int
07:30:01 <pavolzetor> I will watch that later, I am in work
07:30:55 <Fuco> is there something like automatic newtype wrapping?  Say I have newtype C = C { run :: a -> b } ... if I then have some place expecting C and I give it 'a -> b' it should accept it (or should it? can it be dangerous?)
07:31:02 <qmm> help? http://lpaste.net/147936
07:33:46 <mauke> Fuco: the whole point of newtypes is that it won't accept it because it's a different type
07:34:16 <mauke> qmm: what's the type of firstName?
07:34:28 <pmade> Fuco: If you must: http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Types.html#t:Coercible
07:34:32 <Fuco> mauke: to me the point of newtype is the ability to define new specific instances
07:35:10 <doomrobo> how do I convert a -> b into a -> (b,b) (just repeating the same result) without defining a new function?
07:35:12 <mauke> which works because newtype creates new types
07:35:37 <mauke> haskell simply doesn't have automatic conversions
07:35:54 <mauke> doomrobo: join (,) . f
07:36:07 <mauke> doomrobo: or (\x -> (x, x)) . f if you want to be less cute
07:37:09 <Fuco> fair enough
07:37:51 <Fuco> I'm just thinking this make an annoying api, if you have to define callbacks as foo = Callback $ \a b -> code... instead of just foo a b = code and then passing that around
07:38:20 <doomrobo> mauke, awesome, thanks!
07:38:40 <pavolzetor> should I report bug then?
07:39:03 <kadoban> Fuco: So don't do the newtype wrapper then?
07:39:22 <Fuco> kadoban: I need it to define monoid on them
07:39:54 * hackagebot niagra 0.2.0 - CSS EDSL for Haskell  https://hackage.haskell.org/package/niagra-0.2.0 (natesymer)
07:41:18 <Fuco> I need an operator with type (a -> b -> m c) -> (a -> b -> m c) -> a -> b -> m c, m being a monad... (a and b are passed to each action which are chained with >>)
07:42:13 <doomrobo> mauke, what exactly is going on in join (,) . f? I can't get join ((,) 10) to work
07:42:50 <qmm> mauke:   :: ghc-prim-0.4.0.0:GHC.Types.IO GHC.Base.String
07:44:04 <Fuco> doomrobo: join comes from the -> r monad
07:44:09 <dutchie> doomrobo: it's using the monad instance for ((->) r)
07:46:03 <mauke> doomrobo: join (,) 10
07:46:47 <Fuco> join (,) = (,) >>= id = \x -> id ((,) x) x
07:47:32 <mauke> qmm: ok, so IO String, meaning firstName is an action that constructs a string
07:47:58 <mauke> qmm: thus your code creates a list with 10 copies of that action, of type [IO String]
07:48:13 <mauke> (better written as replicate 10 firstName)
07:48:23 <mauke> qmm: what did you expect it to do?
07:48:51 <doomrobo> Fuco, what here is the m (m a) type?
07:49:12 <Fuco> m = (->) r
07:49:48 <Fuco> so r -> (r -> a) which is r -> r -> a, and a is (r,r) because (,)
07:49:55 <qmm> mauke: i was expecting a type of String
07:50:07 <mauke> qmm: why? your code contains no strings
07:50:25 <qmm> ghci can't print a list of IO Strings?
07:50:54 <mauke> ghci can't print any IO action
07:51:05 <mauke> they're simply not showable
07:51:16 <doomrobo> Fuco, OHHH I get it now! Man that's kinda weird. I didn't realize that it was using the (->) r monad
07:51:58 <Fuco> yea that monad is pretty weird :P
07:52:41 <qmm> in that case, is there a library for creating fake data which generates strings instead of io strings? :)
07:53:53 <mauke> qmm: if you give ghci an expression of type IO Foo, it will run it for you and print the result
07:54:08 <mauke> so if you just want to run firstName 10 times, you can do that
07:54:52 <mauke> most directly with replicateM 10 firstName, or with sequence if you already have a list [IO x]
07:55:43 <SX> Hello!
07:55:56 <SX> Anyone familiar with yaml lib?
07:57:40 <SX> I'd like to know how to deal with aliases. I have a lot of dups in yaml file (like A LOT) and I'd like to make file smaller by using YAML aliases there.
08:06:06 <linduxed> ok i'm getting super confused here
08:06:13 <linduxed> for this code: https://gist.github.com/linduxed/1290cdedac0acca59bcd
08:06:47 <linduxed> and this input: https://gist.github.com/linduxed/a15f603615d42bb4f09b
08:06:52 <qmm> let gennames = replicateM 10 Faker.Name.firstName
08:06:58 <qmm> let foo = map (\x -> Faker.Name.firstName) [1..100]
08:07:09 <qmm> gennames :: IO [String]
08:07:13 <qmm> foo :: [IO String]
08:07:30 <linduxed> i'm getting these errors: https://gist.github.com/9dceda604d32b0c2c1c2
08:07:41 <qmm> ghci can handle `IO [String]` but it can't handle showing `[IO String]`?
08:07:50 <linduxed> i have no idea how this is possible, but i suspect it has something to do with the parsing function
08:08:34 <aweinstock> :t liftA2 (liftA2 (>>)) -- Fuco: this uses the (->) Applicative
08:08:35 <lambdabot> (Monad m, Applicative f, Applicative f1) => f (f1 (m a)) -> f (f1 (m b)) -> f (f1 (m b))
08:09:21 <aweinstock> :t liftA2 (liftA2 (>>)) :: Monad m => (a -> b -> m c) -> (a -> b -> m d) -> a -> b -> m d
08:09:21 <linduxed> what confuses me the most is why i get this "f" and "o" in the errors
08:09:22 <lambdabot> Monad m => (a -> b -> m c) -> (a -> b -> m d) -> a -> b -> m d
08:11:10 <Fuco> aweinstock: huh... that's nice.  so aliasing that to something simpler should work fine, hopefully
08:11:43 <linduxed> i don't see where these two letters could appear after the string parsing
08:11:51 <linduxed> it's as if the string parsing didn't happen at all
08:13:26 <SX> Guys, anyone knows how to make aliases with yaml lib?
08:15:57 <tombert> Does anyone here have a good suggestion for talking to the system clipboard (linux) with haskell?
08:16:22 <tombert> preferably a library or something
08:16:28 <aweinstock> Fuco: I got it by telling lambdabot @pl (\f g x y -> f x y >> g x y)
08:16:37 <Fuco> hehe 
08:17:11 <aweinstock> (after spending a while trying to do it manually with variations of ((>>) `on`) and (`on` (>=>))
08:17:16 <aweinstock> @src on
08:17:16 <lambdabot> (*) `on` f = \x y -> f x * f y
08:17:24 <aweinstock> it looks so tempting to generalize...
08:18:54 <aweinstock> tombert: if there's not a dedicated one already, you could use System.Process to interact with xclip
08:22:50 <qmm> SX: aliases with the yaml lib?
08:24:33 <qmm> what is the () in Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
08:24:54 <SX> qmm: https://hackage.haskell.org/package/yaml
08:25:19 <kadoban> qmm: That would be "unit", it's a type that has one value, also named ()
08:25:22 <kadoban> :t ()
08:25:24 <lambdabot> ()
08:25:57 <kadoban> qmm: It's used kind of like "void" in C, if that helps. But it's not magic at all, it's just … a type that doesn't give you any extra information. You use it when you are required to yield some kind of value, but you don't have anything to say.
08:25:58 <SX> qmm: YAML spec has aliases to deal with repetitions
08:26:43 <maerwald> :t void
08:26:45 <lambdabot> Functor f => f a -> f ()
08:27:56 <maerwald> > void [1,2,3]
08:27:57 <lambdabot>  [(),(),()]
08:28:44 <doomrobo> I think void x = (const ()) <$> x
08:29:06 <doomrobo> or I guess that's more simply: void = fmap (const ())
08:29:32 <maerwald> @src void
08:29:32 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
08:29:32 <kogan> Where do the curly brackets go in haskell
08:29:41 <maerwald> :/ 
08:30:09 <phadej> kogan: records and if you want to write oneliners
08:30:09 <doomrobo> {-# LANGUAGE RankNTypes #-} at the top
08:30:45 <arw> kogan: you can write do-notation with curly brackets
08:31:04 <kadoban> kogan: That's a rather odd question. What are you trying to do?
08:31:05 <arw> kogan: but generally, there is a lot of hostility toward non-whitespace-syntax
08:31:23 <linduxed> ok
08:31:34 <linduxed> i think i've figured out what the issue is here
08:31:51 <linduxed> the "string" function from Text.Parsec.Char if fucking weird...
08:31:52 <doomrobo> maerwald, https://i.imgur.com/N3dryh0.png
08:32:06 <qmm> thank you kadoban and maerwald 
08:32:39 <kogan> I was trying to find the objects in haskell
08:33:01 <arw> kogan: there are none
08:33:25 <arw> kogan: you may stuff function pointers into records if you like.
08:33:53 <kadoban> kogan: Are you just learning the language? There's some good resources available that will save you a lot of trouble. https://github.com/bitemyapp/learnhaskell is okay, or http://haskellbook.com/ is much better if you're serious
08:34:30 <kogan> I only know how to program in C++
08:34:32 <kadoban> linduxed: 'string' isn't particularly weird, though Parsec can be if you're not used to it. What are you having trouble with? I didn't really understand your question above.
08:34:51 <kadoban> kogan: Cool, haskell should be fun and educational if you're interested.
08:35:10 <arw> kogan: generally, try to follow some introductions. haskell is very different from c++, there is almost never a corresponding feature for stuff.
08:35:16 <kadoban> kogan: Trying to translate directly from C++ to haskell without doing some reading on the basics is likely to be … frustrating though.
08:36:08 <linduxed> kadoban: for this program (simplified version of something i posted previously): https://gist.github.com/linduxed/00fd6ab859dcc3433ae1
08:36:28 <linduxed> kadoban: with this input: https://gist.github.com/linduxed/a15f603615d42bb4f09b
08:36:43 <linduxed> kadoban: i get these errors: https://gist.github.com/linduxed/9dceda604d32b0c2c1c2
08:38:03 <doomrobo> linduxed, looks like it is not expecting an "off" at any point
08:38:13 <doomrobo> is that part of the grammer?
08:38:15 <linduxed> that's my conclusion as well
08:38:17 <doomrobo> *grammar
08:38:20 <linduxed> which is confusing me to no end
08:38:29 <kadoban> linduxed: Well, that input isn't going to match that parser anyway, because you're not handling the rest of the line after the first bit
08:38:37 <linduxed> sure
08:38:44 <kadoban> linduxed: But the problem you're probably seeing is because you're not using 'try' where you need to, essentially.
08:38:49 <linduxed> but i the more thorough example (earlier link) i do
08:39:02 <linduxed> it's just that it doesn't get past the string matching it seems
08:39:10 <linduxed> try you say...
08:39:13 <linduxed> i'll read up on that one
08:39:35 <doomrobo> where's the code?
08:40:03 <kadoban> linduxed: Parsec doesn't backtrack unless you tell it to. What's happening is it's getting to    'string "turn on"', it parses up to the 'o' fine, and then says "shit there's an 'f', I don't want that" and bails. Then the next one goes, but it's not starting back at the start of the line.
08:40:23 <linduxed> ooooh
08:40:25 <linduxed> i see
08:41:13 <kadoban> So what 'try' does is basically make it backtrack if the Parser you pass to it doesn't completely succeed.
08:41:41 <nitrix> Well, it makes a copy of the input and runs the parser on the copy instead; leaving the original unaffected.
08:42:18 <kadoban> More technically, yes.
08:43:18 <maerwald> that can be expensive
08:43:23 <kogan> Haskell is a general purpose, functional programming language.
08:44:03 <kadoban> It can be expensive, but here it's both needed and not particularly expensive.
08:46:15 <maerwald> still, parsers in haskell are relatively well performing, even compared to a custom C parser
08:46:55 <maerwald> I tried both on a 120mb mesh file, it was something like 4.1s in haskell, 2.4s in C
08:46:57 <linduxed> kadoban: i'm thinking that this works:     inst <- try (string "turn on") <|> try (string "turn off") <|> string "toggle"
08:47:14 <maerwald> but the C parser was really a custom-written monster
08:47:14 <kadoban> linduxed: That looks much more likely to work
08:47:19 <linduxed> seems to give me the right result
08:47:38 <linduxed> although i'm surprised that i don't just use the strings without try
08:47:56 <kadoban> linduxed: You mean you're surprised you have to do that?
08:48:01 <linduxed> i suppose that's strictly related to my experience with the library and the lack of studying the docs
08:48:06 <linduxed> kadoban: yes
08:48:42 <kadoban> Yeah it surprises a lot of people. I'm not certain if it's a necessary surprise or not … it seems to work though.
08:51:08 <hsk3> Anyone here coding Haskell on the Atom editor?
08:52:12 <hsk3> With the language-haskell syntax highlighting package.
08:53:20 <kadoban> hsk3: Might want to just ask your followup question. Saves some time.
08:53:50 <hsk3> Ok, the question is: why the hell isn't it highlighting Nothing?
08:54:23 <hsk3> (the Maybe value Nothing)
08:58:19 <kadoban> hsk3: Does it highlight other value constructors?
08:58:53 <hsk3> kadoban: yeah it highlights numbers like 1 and 3
08:59:24 <kadoban> hsk3: And values like Foo, with    data Foo = Foo above somewhere?
08:59:33 <hsk3> i'll try
09:03:03 <kadoban> hsk3: My guess would be: whoever wrote the highlighter didn't want that highlighted. Highlighting is rather arbitrary and subjective.
09:03:45 <hsk3> That's how it looks: http://cl.ly/320e1Q1a1g3X
09:03:51 <hsk3> kadoban: ^
09:04:13 <trubert1> Criterion gives mean runtime results as "s" for second and "ms" for milliseconds and "ns" for nanosecond. What does "μs" mean?
09:04:24 <kadoban> hsk3: Seems odd
09:04:37 <monochrom> microsecond = 10^-6 seconds
09:04:38 <kadoban> trubert1: That'd be microseconds
09:04:58 <trubert1> kadoban: ah, thanks.
09:05:33 <joel135> since m is used already
09:06:13 <hsk3> yeah it's odd
09:06:14 <hsk3> wtf
09:06:56 <kadoban> hsk3: Can you edit it? It could be relatively easy to add perhaps.
09:07:16 <hsk3> i suppose i could edit it somehow...
09:07:26 <hsk3> i just want my damn editor to work lol
09:07:29 <hsk3> maybe it's too early for atom
09:08:10 <kadoban> hsk3: Wellll, it's not really that bad either.
09:08:19 <hsk3> :)
09:08:40 <monochrom> for best consistency, use a monochrome monitor :)
09:08:49 <kadoban> lol
09:09:04 <dobq> does anyone know of any usage examples of singletons' SomeSing?
09:23:25 <shirt> any tips for how to avoid "newIORef undefined" ?
09:24:05 <kadoban> shirt: Use Maybe, possibly?
09:24:50 <shirt> hm...
09:24:53 <monochrom> use MonadFix :)
09:25:25 <shirt> monochrom: thanks, i'll look into that. can it really help?
09:25:32 <hsk3> I'm thinking about just learning vim once and for all.
09:25:45 <hsk3> What editor do you think the majority of the most experienced people in here use?
09:25:50 <hsk3> I might as well use that.
09:25:54 <hsk3> To get the best assistance if I need it
09:26:04 <monochrom> iff your reason for "newIORef undefined" is to bootstrap a cycle of mutual references
09:26:25 <tdammers> hsk3: in my experience, you won't need a lot of haskell-specific editor assistance either way
09:26:42 <tdammers> hsk3: popular editors for Haskell seem to be vim, emacs, and (gasp) SublimeText
09:26:48 <kadoban> hsk3: It largely doesn't matter, there's a set of "decent enough" editors that nobody will make fun of you for, my list is probably: vim, emacs, sublime, atom. Possibly can use gedit or something if you really need to.
09:27:08 <hsk3> ok cool
09:27:15 <monochrom> https://wiki.haskell.org/MonadFix
09:27:21 <Jinxit> I have two record data types with lenses which share some data types, I want a sum type for those two data types and I want to be able to use the lenses on it. how can I accomplish this?
09:27:34 <tdammers> hsk3: but really, Haskell is expressive enough to not require a lot of hand-holding from your editor, even notepad will do in a pinch, and I've seen people use nano for serious projects
09:28:04 <dmwit> :t mfix (\(f,g) -> do { fRef <- newIORef [g]; gRef <- newIORef [f]; return (fRef, gRef) })
09:28:06 <lambdabot>     Not in scope: ‘newIORef’
09:28:06 <lambdabot>     Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
09:28:06 <lambdabot>     Not in scope: ‘newIORef’
09:28:23 <dmwit> :t mfix (\(f,g) -> do { fRef <- newSTRef [g]; gRef <- newSTRef [f]; return (fRef, gRef) })
09:28:24 <lambdabot>     Occurs check: cannot construct the infinite type:
09:28:24 <lambdabot>       t ~ STRef s [STRef s [t]]
09:28:24 <lambdabot>     Relevant bindings include
09:28:26 <hsk3> Do you think most of the experienced people in here just use syntax highlighting and nothing else (like code completion, ghc-mod)?
09:28:38 <shirt> monochrom: sounds pretty close. the initial value that i want for my IORef is returned from function f that takes a callback that modifies the IORef.  f :: (IORef Double -> IO ()) -> IO Double
09:28:39 <dmwit> ...right
09:30:39 <shirt> dmwit: there is a difference of night and day when comparing coding haskell "blind" vs. coding haskell with a plugin that does realtime typechecking, and allows you to look up info about an identifier and (most import of all) query the type of any arbitrary sub-expression
09:30:52 <kadoban> hsk3: Maintaining really in-depth editor integration tends to be a lot of work, and yeah it's not really necessary.
09:31:09 <shirt> oops, that was meant for hsk3 
09:31:32 <dmwit> ?let newtype LL s = LL (STRef s (LL s))
09:31:33 <lambdabot>  Defined.
09:31:36 <tdammers> hsk3: matter of taste, I guess. I prefer not having a lot of bells and whistles, I pretty much just have syntax highlighting and some haskell-specific macros enabled
09:31:44 <dmwit> :t mfix (\ll -> LL <$> newSTRef ll)
09:31:45 <lambdabot> ST s (LL s)
09:31:49 <hsk3> ok cool
09:32:12 <kadoban> hsk3: My "required" list is … syntax highlighting, and spaces instead of tabs. Other than that I use ghci in a separate terminal which is easy to access (yakuake/tmux), and I use non-language-specific autocompletion and snippets, not much else. I also occasionally use automatic syntax checking and hlint.
09:32:12 <dmwit> a thing with a pointer to itself
09:32:14 <tdammers> hsk3: certainly enough to learn the language, and you can look into more fancy stuff later if you feel you could benefit
09:33:24 <shirt> dmwit: thanks, i'm slowly digesting this
09:33:36 <hsk3> yeah, makes sense
09:33:37 <hsk3> thanks!
09:34:48 <linduxed> is there some way i can analyze performance hotspots in an application?
09:35:17 <tdammers> linduxed: profiling?
09:35:59 <zachk> lookup profiling with ghc 
09:36:16 <Jinxit> http://lpaste.net/4754455975501496320
09:36:32 <Jinxit> ^ lens and typeclass issues
09:36:49 <linduxed> tdammers: ah, yes, that's the name, thanks
09:39:57 <dmwit> Hm, my cabal package database is 540 days old. Guess I should update it.
09:44:09 <zachk> why is cabal install wxc attempting to run ldconfig? 
09:48:18 <kadoban> zachk: Why not?
09:50:01 <zachk> on this system I need to be root to run ldconfig... kinda makes me wonder it is trying to do , ldconfig is a kernel module loader 
09:52:10 <dmwit> Jinxit: ...still building lens -_-
09:52:44 <kadoban> zachk: Well, it's not a kernel module loader, unless it means something different on your system. I don't know specifically what it's using it for though. I think it's usually used when you install new shared libraries it updates some links or whatever. Something like that.
09:53:02 <zachk> oh .. ok 
09:53:14 <Jinxit> dmwit: really? I don't think it took more than a minute or two on my system
09:53:27 <dmwit> I'm on an oldish laptop.
09:53:33 <Jinxit> ah
09:53:35 <dmwit> (traveling)
09:53:37 <Jinxit> newish laptop here
09:55:32 <dobq> how do existential types cooperate with strictness?
09:56:01 * zachk doesn't think the two are even related 
09:56:12 <zachk> they should be orthogonal 
09:56:17 <dmwit> Jinxit: Okay, the following works for me:
09:56:53 <dmwit> instance HasUuid Character String where { uuid f (CMinion m) = CMinion <$> uuid f m; uuid f (CHero h) = CHero <$> uuid f h }
09:58:01 <dmwit> I do not know whether there is any handy TH to do this for you, but #haskell-lens might.
09:58:55 <dobq> zachk: let me ask it differently. can a type be unevaluated (a thunk)?
09:59:23 <dmwit> Usually we talk about terms being unevaluated thunks.
09:59:35 <dobq> okay, so now i have a term of my existential type
09:59:48 <Jinxit> dmwit: good enough for me, thanks!
09:59:51 <dobq> can the type, which is "part" of that term in at least some sense, be unevaluated?
10:00:28 <dmwit> The type does not exist at runtime, if you are talking about GHC's implementation strategy.
10:00:37 <zachk> no idea, doesn't ghc strip almost all types from the code as it compiles? 
10:00:39 <dmwit> (There are other strategies where it may exist.)
10:00:52 <dobq> dmwit: that cannot be entirely true, because existential types *require* runtime type information
10:01:17 <dmwit> You may be referring to the typeclass dictionaries that must be kept around.
10:01:23 <dmwit> These can be unevaluated.
10:01:37 <dobq> no, i'm not referring to that
10:01:38 <dmwit> But it is very rare that significant computation will be involved.
10:01:45 <dobq> that i can agree with :)
10:01:53 <dmwit> Then what do you mean by "existential types require runtime type information"?
10:02:11 <dobq> hm, maybe i don't understand what you mean by a "typeclass dictionary"
10:02:45 <dobq> but for example, suppose i have the type: forall t . Constr !Int
10:02:49 <zachk> every typeclass passes an extra argument into functions that use, that is a dictionary to lookup those typeclass functions 
10:02:52 <dobq> or, i dunno, with a singleton
10:03:13 <dobq> forall t . Constr !Int (Sing t)
10:03:38 <dobq> then clearly i can differentiate different terms of that type because of the singleton field
10:03:54 <dobq> (differentiate terms having different t*)
10:04:11 <dobq> so there must be some kind of run-time type information being stored
10:04:24 <dmwit> How are you differentiating them?
10:04:41 <dobq> pattern matching?
10:04:47 <dmwit> On what?
10:04:50 <dobq> the singleton
10:05:35 <zachk> dobq, can you get an example of your idea to fail on purpose? a pathological example, perhaps.... 
10:05:41 <dmwit> Is `Constr` intended to be a term-level constructor for some larger type?
10:06:05 <dobq> dmwit: no, but i suppose my example would be in the context of DataKinds and singletons
10:06:54 <dmwit> I'm having a bit of trouble following along. Can you cook up a smallish complete example that we can refer to?
10:07:20 <dobq> i suppose that'd be necessary
10:07:41 <dobq> okay, thanks for your input
10:07:52 <dobq> i'll come back when i have a question that's clearer
10:08:12 <dmwit> In any case, I suspect the answer to your question is that the type-level information that's kept is exactly the typeclass dictionary.
10:17:47 <Fuco> in state monad there is 'gets' to get a specific part of the state... is there something like puts? I'm doing "modify (\state@State { players = players } -> state { players = update players bus } )" and that's rather annoying
10:18:46 <zachk> Fuco, lens? 
10:21:30 <kadoban> Fuco: If there's only a few you could manually write functions like modifyPlayers, etc.
10:27:57 <roelof> Anyone who has worked with servant before. I think it's a candidate for a project I started when finisching the Craft book and/or CIS 194
10:29:07 <Welkin> dmj`: did you find the robots you were looking for?
10:30:21 <zachk> setup: Couldn't execute ldconfig, ensure it is on your path ... arghhh what do I do? 
10:32:17 <roelof> zachk:  you get that error message when doing stack setup ?? We need a little bit more context 
10:32:41 <zachk> I am getting that error from: cabal install wx 
10:32:49 <zachk> so I switched to root to try to get ldconfig to run
10:32:52 <zachk> and it is still doing it 
10:33:05 <roelof> the same error message ? 
10:33:09 <zachk> yeap
10:33:21 <roelof> you are using linux ? 
10:34:48 <roelof> zachk:  and which distro ?? 
10:34:51 <zachk> oh illegal option being passed to ldconfig.... hmmm 
10:34:57 <zachk> pcbsd/freebsd 
10:35:29 <monochrom> yikes, probably different option syntax
10:36:50 <monochrom> wait a second, no one really runs ldconfig with any option
10:44:59 * hackagebot luminance 0.9.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.9.1 (DimitriSabadie)
10:45:26 <nitrix> Does stack lets you run a build from `stack build`? Tried `stack run` with no success.
10:46:44 <kadoban> nitrix: It has 'stack build --exec somecommand'
10:46:50 <roelof> nitrix:  as far as I know it's or stack build and then stack exec  <filename>-exe 
10:48:23 <nitrix> Interesting. stack exec lasers worked, but not build --exec lasers
10:48:43 <nitrix> I would've expected both to be somewhat consistent.
10:48:57 <nitrix> roelof: thanks
10:49:17 <roelof> nitrix: yw
10:49:32 <roelof> this way we can help each other 
10:50:19 <roelof> You said you use the same book as me to learn haskell. Where are you.
10:50:27 <roelof> Im now at chapter 5.7 
10:50:31 <nitrix> I'm not learning from the book :)
10:50:45 <nitrix> Just reading it for the sake of knowing how it's presented when helping beginners :)
10:51:04 <roelof> oke
10:51:14 <nitrix> Chapter 2 (I think). Started this morning and reading inbetween tickets at work.
10:51:17 <roelof> and what is your oponion of that book 
10:51:36 <nitrix> I'm very pedant and a few things bothers me.
10:51:53 <nitrix> In the second chapter, execution and evaluation is conflated, same with definition and declaration.
10:52:16 <roelof> oke, I find the explanations fine and clear but the exercises are sometimes very vaque
10:52:43 <roelof> sorry , what is conflating. English is not my mother language 
10:53:07 <nitrix> It accidently mixes a few concepts by trying to simplify things.
10:53:30 <roelof> and for some exercises you need to now a lot of maths. like the one I tried today
10:53:58 <roelof> Test if two shapes (Rectangle, Triangle and Circle) has overlaps 
10:54:01 <nitrix> Well, few minutes googling and it's done :)
10:54:16 <nitrix> Nothing an engineer can't do :]
10:54:26 <roelof> I could not find it 
10:54:33 <roelof> and its fine with me 
10:55:10 <nitrix> I suppose the idea was to work with boolean expressions, so regardless of the formula, it's a good challenge.
10:55:42 <nitrix> Like how you learned the distinction between `or` and `||`.
10:56:34 <roelof> yep, that is why I did only that one with rectangles 
10:56:57 <roelof> Tomorow time to learn more about lists and list comprehensions 
10:57:10 <nitrix> Lists are fun :)
10:57:19 <nitrix> I also like the Maybe type. You'll see :P
10:57:48 <roelof> I have no idea when Maybe and Either is explained 
10:58:11 <roelof> I will see 
10:58:30 <nitrix> Probably near chapter 17 (functors)
10:58:55 <nitrix> Sounds like a good intruction for it.
10:59:06 <nitrix> > (+2) <$> Just 3
10:59:08 <lambdabot>  Just 5
10:59:18 <nitrix> > (+2) <$> Nothing
10:59:20 <lambdabot>  Nothing
10:59:58 <roelof> The last one I find wierd. (+2) <$> Nothing 
11:00:27 <tdammers> <$> is an alias for fmap
11:00:27 <roelof> I was expecting to see 2 
11:00:50 <tdammers> Maybe's functor instance acts upon Just the value, or on Nothing
11:01:07 <tdammers> if it's Nothing, then there's nothing to act on, so Nothing remains Nothing
11:01:08 <roelof> oke, that one is also not explained. I know only map 
11:01:29 <nitrix> roelof: It's the reverse. (+2) is applied to Nothing. If you start with Nothing and you try to do anything, you still end up with Nothing.
11:01:48 <nitrix> roelof: It's not like we had `Just 0`. There's no starting value here.
11:01:54 <roelof> oke, so Nothing is not the same as zero 
11:01:55 <nitrix> But you'll see this in time :)
11:02:09 <tdammers> roelof: of course not; if it were, we'd just use zero in the first place
11:02:15 <roelof> yep, first learn list comprehension 
11:02:49 <tdammers> if you wanted to have Nothing represent zero, you'd rather use fromMaybe
11:02:50 <roelof> and on chapter 6 I saw we have to make a sort of supermarket bill. But first some sort of book library 
11:02:52 <tdammers> :t fromMaybe
11:02:53 <lambdabot> a -> Maybe a -> a
11:03:01 <tdammers> > fromMaybe 0 Nothing
11:03:02 <nitrix> Nah, it's polymorphic for many types.
11:03:03 <lambdabot>  0
11:03:03 <nitrix> :t Nothing
11:03:05 <lambdabot> Maybe a
11:03:23 <nitrix> Where a is the type specification for a concrete type. You'll see it in time :P
11:03:30 <roelof> So the code looks more and more on real world code instead of very simple functions 
11:05:00 <roelof> I hope in time I learn how to work with things that can change. Lets say the amount I have in my wallet and how to change that 
11:05:20 <roelof> but thats the future, One step at the time 
11:05:27 <nitrix> States, hyes.
11:06:07 <nitrix> You technically can already, just by explicitly passing the state to every functions, but there are better ways.
11:06:34 <roelof> I thought so, that is why I have not tried to make this in Haskell 
11:06:59 <nitrix> Meh. Trying foolish things is part of verying assumptions and learning.
11:08:00 <roelof> So I schould try after reading so little chapters and experience ? 
11:08:04 <Welkin> I think it is better to start with explictly passing the state around
11:08:14 <nitrix> I think the same too.
11:08:15 <Welkin> then once you are learning more about monads, learn the state monad
11:08:39 <Welkin> otherwise, the state monad seems magical and you may feel like it is modifying the state rather than creating a new one if you don't understand how it works
11:08:44 <nitrix> You'll instinctively come up with something that naturally ressembles the way the State monad works.
11:08:57 <roelof> So first a function like  deposit -> state -> amount -> state 
11:09:03 <nitrix> Right.
11:09:12 <roelof> So first a function like  deposit :: state -> amount -> state 
11:09:40 <nitrix> Yeah, where you have an original state and return a new state.
11:10:00 * hackagebot filepath 1.4.1.0 - Library for manipulating FilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-1.4.1.0 (NeilMitchell)
11:10:09 <nitrix> The State monad does exactly that, it's just hidden for convenience. (You'll see when you get to monads).
11:10:24 <nitrix> There's really nothing magical in Haskell. Everything re-uses everything :P
11:11:00 <johnw> you can master State without getting into the monad abstraction even; monads abstract a common pattern, but seeing how to compose "stateful actions" is educational on its own
11:13:04 <maerwald> it's just hiding a parameters
11:13:38 <johnw> it's hiding parameters, and also connecting subsequent states in a meaningful way
11:14:11 <maerwald> I usually do that explicitly, especially since it doesn't work well with C callbacks
11:17:04 <roelof> oke, the only I have to find out is how I can give the state a initially value 
11:17:09 <roelof> nitrix: 
11:17:32 <jackhill> win 49
11:17:51 <wolever> Is it possible to pattern match on a record type without destructuring the fields? Ex, `case msg of MsgSucces m -> handleSuccess m`?
11:18:06 <roelof> jackhill:  win 49 ???
11:18:10 <johnw> Stateful actions are functions; the composition of stateful actions is a function; therefore, the initial state is given simply by calling that function with the first state
11:18:12 <nitrix> roelof: Depends on the type of your state. If your state is an int, it's just a matter of giving 0 or similar to your first function.
11:18:27 <mauke> wolever: what's the definition of MsgSucces?
11:18:49 <wolever> `data Message = MsgSuccess { … } | MsgError { … }`
11:18:50 <nitrix> roelof: If it's a record, then you'd have to construct the record and giving the fields default values, but the process is the same.
11:18:57 <jackhill> roelof: I was trying to tell my irc client to switch windows, but accidentally sent the message to this channel. Sorry. Also, hi everyone!
11:19:02 <roelof> nitrix:  Thanks, I will play and experiment with it 
11:19:08 <Welkin> wolever: yes, using RecordWildCards
11:19:10 <roelof> jackhill:  NP 
11:19:15 <Welkin> match with MsgSuccess{..}
11:19:17 <Welkin> er
11:19:18 <Welkin> match with MsgSuccess{}
11:19:22 <wolever> Welkin: ah awesome, thanks!
11:19:34 <Welkin> actually, do you need recordwildcards for {}?
11:19:37 <mauke> wolever: case msg of m@MsgSuccess{} -> handleSuccess m would work
11:19:37 <mjrosenb> I think I want to do something that is impossible :-/
11:19:37 <Welkin> I know you do for {..}
11:19:47 <mauke> wolever: but I don't know what m would mean otherwise
11:19:49 <Welkin> hm, perhaps not
11:20:00 <mjrosenb> can I have a where clause that extends over multiple <- assignments in a do block?
11:20:15 <Welkin> mjrosenb: yes
11:20:24 <wolever> mauke Welkin seems to compile, so here’s hoping  ¯\_(ツ)_/¯ 
11:20:27 <Welkin> a where clause applies to a defintion
11:20:31 <nitrix> mjrosenb: By the way, <- isn't an assignment ;)
11:20:51 <Welkin> myfunction = ... is a definition
11:20:59 <monochrom> mjrosenb: I don't know what you mean. I don't think anyone does, they're just guessing. could you show a concrete example?
11:21:06 <Welkin> if you have myfunction Just a = ...
11:21:13 <ReinH> wolever: Also consider data MsgStatus = Success | Failure; data Msg = Msg MsgStagus ... if the fields are the same. If the fields are not the same, be careful with using records in sum types. The fields are then partial and their use can cause runtime crashes.
11:21:13 <Welkin> and myfunction Nothing = ...
11:21:16 <Welkin> those are two definitions
11:21:19 <absence> if i have a function Int -> Int -> Int, and want to coerce to Wrapped Int -> Wrapped Int -> Wrapped Int, is there a trick to avoid typing out coerce $ f (coerce a) (coerce b)?
11:21:36 <wolever> ReinH: good to know, thanks
11:21:40 <mjrosenb> "assignment"
11:21:56 <roelof> Thanks all. I call it a day . Learned a lot today 
11:22:21 <Welkin> mjrosenb: `a <- ma` is syntactic sugar for `ma >>= \a -> ...`
11:22:55 <mjrosenb> so, I want mdo { {x <- foo z; y <- bar z} where z = baz x y }
11:23:02 <mjrosenb> using pseudo code
11:23:19 <Welkin> use a let clause instead
11:23:36 <ReinH> or lift the where clause out of the do block entirely
11:23:36 <Welkin> or just avoid the z altogether
11:23:47 <Welkin> and use y <- bar x y
11:23:50 <Welkin> er
11:23:57 <Welkin> and use y <- bar (baz x y)
11:24:08 <ReinH> ah, you can't. use let
11:25:14 <nitrix> mjrosenb: The problem is it's a binding; do notation desugars to lambdas. `x` and `y` are out of scope for `z`'s definition.
11:25:23 <mjrosenb> Welkin: that won't do what I want.
11:25:37 <mjrosenb> nitrix: well, I am using mdo for a reason
11:26:00 <mjrosenb> currently, I just have them all at the top level (and like 5 variants of x, y, and z, each with different names
11:26:08 <monochrom> this is why you need to show concrete code example.
11:26:23 <mjrosenb> it would be /super/ awesome if I could banish all of the temps that I don't care about to a separate scope
11:27:18 <mjrosenb> http://paste.pound-python.org/show/yIREkBWhXl6Bsa7Vhzs0/
11:27:23 <mjrosenb> here, real code.
11:28:11 <mjrosenb> this used to be prettier, then a reactive-banana update moved basically everything into a monad
11:28:20 <mjrosenb> and now it is ugly
11:28:22 <mjrosenb> but it works.
11:28:36 <monochrom> I think you should consider "let". I think "let" in "mdo" does what you think.
11:29:12 <mjrosenb> I'm using let all over the place. the issue with let is that its scope is the entire mdo block, not one or two clauses.
11:31:05 <sm> let .. in .. has more limited scope
11:31:38 <sm> or, you could nest additional do's perhaps
11:38:04 <wolever> I’m getting an error "thread blocked indefinitely in an MVar operation" — how can I get a stack trace to see where that’s coming from? I’ve tried building with `-prof`, but then I get complains that system modules (ex, `System.Random`) don’t have the profiling versions installed
11:40:14 <wolever> Or do I basically need to rebuild everything with profiling?
11:41:44 <monochrom> if you insist on a stack trace, you will rebuild everything with profiling. that's the cost.
11:42:08 <monochrom> but deadlocks can be diagnosed without stack trace
11:42:28 <johnw> wolever: you have a thread blocked on an MVar, and no other thread is in a position to ever again modify that MVar; the stack trace would just show where you're blocked, but not why
11:43:13 <wolever> How could I diagnose the deadlock without a stack?
11:43:34 <wolever> Even knowing which MVar a thread is blocking on would be helpful / monochrom johnw 
11:43:47 <johnw> read the code, and see how it could ever happen that an MVar you've called "take" on might never again receive a "put"
11:45:19 <wolever> johnw: oh… that’s not nearly as straight forward as I’d hoped
11:45:21 <monochrom> delete code until the deadlock disappears
11:45:57 <dmj`> wolever: withMVar and modifyMVar_ help to ensure that you always put after you take
11:46:24 <monochrom> debugging is never meant to be straightforward. in comparison, even proving programs correct is easier.
11:47:27 <dmj`> wolever: care to paste the code? 
11:47:31 <dmj`> @where paste
11:47:31 <lambdabot> Haskell pastebin: http://lpaste.net/
11:47:51 <wolever> dmj`: if that’s what it comes to I’m sure I can dig through and figure it out
11:48:36 <wolever> But if I could get more information than "a deadlock exists", that would be helpful
11:58:29 <ReinH> Debug.Trace can be useful to do "printf-style debugging"
12:00:46 <pavolzetor> I asked this before with no suitable answer; what is common way to represent images in haskell? juicypixels uses Vector
12:00:54 <pavolzetor> is there some standard interface to it?
12:01:00 <ReinH> pavolzetor: it depends on your usage
12:01:13 <pavolzetor> (I might want to put out openexr writing library if I finish it)
12:01:24 <monochrom> if juicypixels suits your needs, use juicepixels
12:01:36 <pavolzetor> juicypixels has no openexr support
12:01:39 <monochrom> if it doesn't, find another library that does
12:01:46 <ReinH> Anything from Double -> r to Vector Word32 can be useful, depending on what you are doing.
12:01:53 <roelof> nitrix:  I did a quick try to make a sort of wallet function : http://lpaste.net/147962  but so far no luck 
12:02:30 <ReinH> Er, Double -> Double -> r, more likely, but anyway
12:02:44 <nitrix> ReinH: Almost :P
12:02:55 <ReinH> nitrix: what you don't use 1D images?
12:03:09 <pavolzetor> monochrom: there is only this one https://github.com/ekmett/openexr
12:03:09 <ClaudiusMaximus> pavolzetor: adding support for openexr to juicypixels would be worthwhile i guess
12:03:37 <roelof> nitrix:  I did a quick try to make a sort of wallet function : http://lpaste.net/147962  but so far no luck 
12:03:42 <nitrix> roelof: You need to deconstruct the State type.
12:03:46 <pavolzetor> but those are raw bindings and I just want to write an image; also it needed the actual library
12:04:02 <pavolzetor> there was no example, so I figured it is simpler to write basic rgb writer
12:04:07 <ReinH> pavolzetor: what arey ou actually trying to do?
12:04:08 <nitrix> roelof: `s` is a State, not an `Int`.
12:04:17 <ReinH> I need to fix my thumbs. :(
12:04:27 <nitrix> roelof: deposit (Amount x) a = x + a
12:04:50 <pavolzetor> ClaudiusMaximum: I do not like monolithic libraries
12:05:04 <ReinH> Cale: ping
12:05:14 <nitrix> roelof: I can explain it if it's confusing.
12:05:26 <pavolzetor> ReinH: output image to openexr file
12:05:52 <ReinH> pavolzetor: Ok, then you'll want to use the format Ed's library uses, I suppose, or write your own encoder.
12:06:24 <pavolzetor> is there some example for ed's library how to use it?
12:06:32 <pavolzetor> I wrote an encoder (no compression)
12:06:57 <roelof> nitrix:  still not working : http://lpaste.net/147963
12:07:01 <nitrix> roelof: http://lpaste.net/147962
12:07:18 <nitrix> roelof: You also need to return a State, not an Int ;)
12:07:26 <nitrix> roelof: As per the function type signature
12:07:47 <roelof> oke, next problem to solve 
12:08:07 <nitrix> roelof: This sounds like an overhead here because your state is very simple.
12:08:36 <nitrix> Imagine something like:    data Wallet = Eur Int | Cad Int | Usd Int
12:08:44 <nitrix> Is it more clear like this?
12:09:10 <nitrix> You accept and return a Wallet, yet you still need to deconstruct and handle the cases where the wallet's in Eur, Cad or Usd.
12:09:20 <nitrix> Same as you need to break down your State to get your Amount.
12:10:18 <pavolzetor> edwardk: can you put up some simple example how to use your openexr bindings pleasE?
12:11:28 <hunteriam> what are the best libraries for large web apps?
12:11:43 <hunteriam> is Yesod the standard or should I also investigate something else?
12:11:43 <ReinH> roelof: before you use State, try write it by passing the state around as a parameter. Once you do this, it will be easier to understand the State version and you will have an appreciation for why it's useful.
12:11:56 <Welkin> hunteriam: yesod is what I use
12:12:12 <ReinH> hunteriam: I'm not sure about standard but it's popular. So are Scotty, Servant, Snap, probably a few others.
12:12:27 <AleXoundOS> Hi. I'm having problems to understand how to access individual declarations of C code using "Language.C". How to filter only specific declarations I need by some property? Which docs should I read, what knowledge I'm most likely missing?
12:12:35 <hunteriam> how do I pick between them having never used any of them?
12:12:37 <hunteriam> ReinH: 
12:12:46 <monochrom> all of the above are standards. there are more.
12:12:57 <ReinH> monochrom: fsvo standard, I guess :)
12:12:58 <monochrom> that's the nice thing about standards.
12:13:11 <roelof> I did get it working like this :  http://lpaste.net/147965
12:13:20 <ReinH> hunteriam: Compare the features they offer to the features you want? :) Try them out?
12:13:24 <hunteriam> Well I'm not sure which one to pick for my first large Haskell app and I'm not sure what should be a major factor in my deciscion
12:13:32 <Welkin> hunteriam: they have different use cases
12:13:35 <Welkin> they are not all the same
12:13:41 <Welkin> servant is for writing APIs
12:13:44 <ReinH> hunteriam: Stack offers templates for most of them https://github.com/commercialhaskell/stack-templates
12:13:47 <Welkin> scotty is bare bones
12:13:49 <Welkin> yesod is full featured
12:14:31 <monochrom> my solution is to not have a first large Haskell app.
12:14:36 <roelof> but what  I do not see is let's say I want now withdraw 20 . Must I do now withdraw  (Amount 100) 20 or can I use the State somehow  
12:14:41 <ReinH> roelof: Oh, you aren't using State. You're using a wrapped Int that you call State.
12:14:48 <ReinH> That's a bit confusing. Why call it State?
12:14:56 <ReinH> why not call it Amount?
12:15:10 <roelof> I could not make up a better name yet 
12:15:21 <roelof> I can call it Amount , not a problem 
12:15:39 <Welkin> call it Amaranth
12:15:41 <Welkin> or Amish
12:15:45 <ReinH> State doesn't tell me anything interesting about what it does and conflicts with the more common usage of State.
12:15:45 <Welkin> or Amygdala
12:15:58 <roelof> I have called it Amount 
12:15:59 <monochrom> instead, have a sequence succession of gradually larger app, the end of which is the size you call "large", but it's a whole continuum so you can't put your finger that any of them and call it "the first large".
12:16:24 <ReinH> monochrom: So you accept that you are bald?
12:16:28 <Welkin> you can build a small yesod app, and then make it larger over time
12:16:44 <roelof> but can I use the contents of Amount in function so I do not put the current contents myself in a function 
12:16:54 <monochrom> I am not at the bald end yet
12:16:54 <ReinH> monochrom: because I can prove it by induction ;)
12:17:52 <monochrom> similarly, the way I write a large program and never need to wonder "how would you debug a large program", is to do testing and fixing at every point I have added 5 more lines of code.
12:18:01 <ReinH> monochrom: if you had zero hair, you would be bald. For any amount of hair that you have, having one extra hair does not materially change your hair status. Thus you are bald. QED.
12:18:30 <monochrom> therefore it is unthinkable to me how other programmers here could ever post a 100-line program and ask "I don't know how to debug it"
12:19:09 <ReinH> monochrom: if anything, Haskell makes that strategy much more viable than most languages.
12:19:14 <Welkin> I don't write tests at all
12:19:17 <ReinH> since spooky interactions at a distance are kept to a minimum
12:19:24 <roelof> nitrix:  Could I use somehow the contents of Amount is the next function call or must I type it myself now ? 
12:19:34 <Welkin> the only time I wrote tests was to learn how to write tests
12:19:55 <roelof> ReinH:  I  do not use State because I have not learned it so far. 
12:19:58 <hunteriam> That's a legit proof ReinH 
12:20:06 <ReinH> hunteriam: indeed
12:20:18 <nitrix> roelof: If the next function wants a State too, then you'd have to use the Amount value constructor to turn your Int into a State again.
12:20:24 <Welkin> I can't think of any tests to write that would have a reasonable impact
12:20:57 <nitrix> roelof: Otherwise, as you're already thinking, yes, Monad let you have functions that accept the state and modify it while doing this whole wrapping and unwrapping for you.
12:21:41 <roelof> So if I deposit 100 euro and then withdraw  20 I have to do deposit (Amount 0) 100 and then withdraw (Amount 100) 20 
12:21:43 <nitrix> roelof: This will make more sense as you learn about data types and functors.
12:22:26 <nitrix> roelof: Well,  withdraw 10 ( deposit (Amount 0) 100 )
12:23:07 <roelof> oke, so not very handy to work with 
12:23:47 <roelof> but nice to figure out how to make it work 
12:23:47 <Guest68427> Hi; anyone know how I would use a lens traversal to build a list of the contents of the thing being traversed?
12:23:55 <nitrix> roelof: Actually my example is wrong, and it's only inconvenient because your State is the first argument.
12:24:04 <mpickering> Guest68427: You can use `partsOf`
12:24:07 <nitrix> roelof: If it was the last argument, the functions could compose easily.
12:24:13 <ReinH> roelof: withdraw (Amount 10) . deposit (Amount 10)
12:24:17 <nitrix> roelof: It kind of is.   withdraw 10 $ deposit 100 $ startingMoney
12:24:32 <Guest68427> mpickering: looking!
12:24:34 <nitrix> roelof: Having the state last really helps.
12:24:40 <Welkin> nitrix: or composition
12:24:48 <Jinxit> Guest68427: things^..otherThing gives you a list of otherThings
12:24:49 <mpickering> Guest68427: Or I guess more directly you can use the lens as a function..
12:24:51 <roelof> oke, so I could better do int -> State -> State ? 
12:24:56 <ReinH> Having the amount first is convenient. Having it last is not convenient.
12:24:57 <Welkin> withdraw 10 . deposit 100 $ 0
12:25:37 <monochrom> are you writing a bank web app? :)
12:25:52 <nitrix> roelof: Correct, that'd definitely help the two functions compose together (the return value of one is the needed argument of the other)
12:25:53 <monochrom> if you are, please add a backdoor that gives me money!
12:25:54 <Welkin> make sure you use rot13 for encryption and you run it twice
12:25:58 <roelof> So at this point I could not make a sort of state  , which holds the value so I can change it all the time 
12:25:58 <ReinH> Well, if amount is the thing being withdrawn and deposited. If not, not.
12:26:47 <nitrix> ReinH: In his example, Amount was the value constructor of a State (supposedly a wallet)
12:27:17 <zachk> has anyone ever gotten wxHaskell working on freeBSD? 
12:27:18 <ReinH> > let withdraw = flip (-); deposit = (+) in withdraw 10 . deposit 10 $ 0
12:27:20 <lambdabot>  0
12:27:32 <mpickering> Guest68427: Jinxit is right you want "toListOf", the infix version is ^..
12:28:10 <nitrix> ReinH: Well, that removes the whole purpose of demonstrating states.
12:28:16 <ReinH> why?
12:28:33 <ReinH> I think it demonstrates state perfectly
12:28:36 <joco42> is it possible to make the return type's a parameter be the same as the value of the first parameter of the function subTrees ? https://usercontent.irccloud-cdn.com/file/JbUfgeDY/Screen%20Shot%202015-12-28%20at%2022.27.14.png
12:28:52 <joco42> this is some dependent typing magic....
12:28:56 <nitrix> Because you made it work on a Num, which the State probably isn't.
12:29:00 <nitrix> ReinH: ^
12:29:00 <joco42> i don't know how
12:29:07 <monochrom> it demonstrates states and doesn't demonstrate State. I'm sure that's a middle ground we can all agree on.
12:29:31 <ReinH> nitrix: I didn't say it demonstrates State. I said it demonstrates state, as did you.
12:29:38 <joco42> so for example if Level is L1 then the return type of subTree should be [ImgTree L1]
12:29:46 <joco42> is that possible somehow?
12:29:46 <nitrix> ReinH: I said State the whole time.
12:29:53 <nitrix> ReinH: His definition was data State = Amount Int
12:30:02 <ReinH> nitrix │ ReinH: Well, that removes the whole purpose of demonstrating states
12:30:16 <ReinH> is what I am responding to
12:30:21 <nitrix> Fair enough.
12:30:39 <nitrix> I don't see how it helps him though.
12:31:06 <ReinH> As I said before: understanding how to pass state as a parameter will help to understand the use and purpose of the State monad.
12:31:19 <ReinH> It helps motivate State.
12:31:32 <monochrom> that is a sick State
12:31:48 <Welkin> that is one clumsy-sailor 
12:31:51 <nitrix> ReinH: We went over this on #haskell-beginners with explicit states.
12:31:53 <ReinH> This example is easy to do without the State monad. Other examples are less easy, and better demonstrate the usefulness of State. Without knowing which is which, you have less motivation for State.
12:32:06 <nitrix> That has been done before.
12:32:10 <ReinH> Ok.
12:32:20 <monochrom> next, we're going to answer a question that contains "newtype Monad = M Int Bool Char"
12:32:49 <ReinH> monochrom: er. Oh. I see.
12:32:52 <nitrix> monochrom: I'm not choosing the name beginners chooses for their datatypes. A bit of respect, please.
12:33:52 <Guest68427> mpickering: feel a bit silly, I'm trying to get a list of pixels out of an image with https://hackage.haskell.org/package/JuicyPixels-3.2.6.4/docs/Codec-Picture.html#g:2
12:34:19 <hunteriam> joco42: sounds like dependant typing 
12:34:22 <mpickering> what have you tried?
12:34:40 <Guest68427> Nothing yet I'm lazy... sec
12:36:26 <roelof> BRB
12:37:33 <joco42> hunteriam: sounds like... 
12:37:42 <joco42> maybe i try idris :)
12:39:31 <ReinH> joco42: dependent types are the path to the dark side.
12:40:54 <joco42> really? hmm... dark side?
12:41:01 <ReinH> joco42: no, I'm joking.
12:42:36 <joco42> oooh good , coz the idris book looks awesome..
12:43:38 <joco42> off to sleep, passing out... 
12:44:53 <Guest68427> mpickering: it seems that toListOf imagePixels may bear fruit, thanks.. :)
12:45:06 <roelof> monochrom:  Maybe in the far future this can be a ecommerce or a accounting system 
12:45:59 <roelof> nitrix:  so back to my example. How can I then deposit and withdraw money when I do int -> State -> State 
12:46:34 <nitrix> roelof: withdraw 10 $ deposit 100 $ originalState
12:47:15 <nitrix> roelof: Or withdraw 10 . deposit 100 $ originalState. The idea is that it now becomes composable.
12:47:26 <roelof> oke, so the State or Amount is not remembered somehow so I could make two seperate functions 
12:48:10 <nitrix> It's being passed explicitly to the functions, it's just that the return value of the first function happens to be the argument needed for the other function so they can be chained.
12:48:54 <nitrix> In a procedural language, that'd look like a = 0; b = foo(a); c = bar(b);
12:49:03 <nitrix> or bar(foo(0))
12:49:14 <nitrix> We do the exact same thing here, with bar . foo $ 0
12:50:06 <roelof> oke, so if I make a wallet function which works of several months I have to store the old transactions somehow 
12:51:16 <nitrix> Right, then your supposedly State type would become more elaborated. Instead of just having an amount, you'd have an history, and you'd be headed towards Haskell's records for this.
12:51:22 <nitrix> (If we still ignore Monads)
12:51:43 <roelof> oke, so as far as I have learned this is it 
12:52:10 <roelof> I think records are not mentioned in the first 5 chapters of Craft book 
12:52:25 <nitrix> data Wallet = MkWallet { amount :: Int, history :: [String] }
12:52:27 <nitrix> Or similar.
12:54:16 <magneticduck1> roelof: records are just syntatic sugar
12:54:29 <roelof> thanks, one last question . I do not understand this error message : http://lpaste.net/147968
12:54:33 <magneticduck1> +- increasingly more complex sugar introduced by related language extensions
12:54:40 <magneticduck1> s/more complex/complex
12:55:02 <roelof> Amount is not the first argument. That a in my oponion 
12:55:30 <monochrom> where is the $ ?
12:55:56 <roelof> ??? 
12:55:57 <magneticduck1> roelof: that's not the code that error is coming from
12:56:10 <nitrix> roelof: The error message seems to be unrelated with that snippet.
12:56:19 <magneticduck1> a rose by any other name...
12:56:27 <monochrom> "In the second argument of ‘($)’"  where is ($) in the code?
12:56:33 <magneticduck1> s/rose/compiler output
12:57:54 <roelof> I see it it's my main function , I still have this ; print $ deposit (Amount 0) 100 
12:58:09 <monochrom> swap argument order
12:58:40 <roelof> I did . With this is working : print $ deposit 100 (Amount 0) 
12:58:47 <monochrom> yes
12:58:54 <roelof> too late here . Time to sleep. Thanks all for the lessons 
12:59:32 <csd_> what is wrong with my attempt here to generate the fibonacci sequence? http://pastebin.com/AWdXbW4z
12:59:55 <nitrix> roelof: Might as well write print $ deposit 100 $ Amount 0, if you're going to use $ instead of parenthesis ;P
13:00:01 <monochrom> I dislike pastebin. ridiculous double-spacing of code.
13:00:45 <monochrom> s/pastebin/pastebin.com/
13:01:29 <johnw> I rather like "print $ deposit 100 (Amount 0)", this is the style I use too
13:02:06 <roelof> oke, and this is also working :   print $ withdraw 10 $ deposit 100 $ Amount 0  
13:02:29 <roelof> All thanks for the lessons and the patience with me 
13:02:37 <magneticduck1> new PrintFactory().generateGenericPrinter(new TransactionFactory(DEFAULT_TRANSACTION_TYPES).generateGenericDeposit(100.0f)) is, however, not acceptable style
13:02:39 <roelof> and all a nice day/evening 
13:02:40 <magneticduck1> anything else is okay
13:03:46 <roelof> Now wait till the Craft book is mentioned State's and then I can rewrite this code  
13:04:15 <roelof> Til then working on the Craft book and later CIS194 so still a lot to learn 
13:04:35 <broma0> Can you write a typeclass that has conditional default implementations (add another class constraint to one of the type variables in scope)?
13:05:23 <johnw> see the source for Plated in https://hackage.haskell.org/package/lens-4.13/docs/src/Control-Lens-Plated.html#Plated
13:05:28 <johnw> is that what you mean?
13:05:50 <roelof> Again thanks for everybod u who try to learn me to write good Haskell and learn me the principles of Haskell 
13:05:59 <johnw> roelof: you're most welcome
13:06:12 * magneticduck1 pats roelof
13:06:17 <magneticduck1> soon, you will be indoctrinated
13:06:39 <roelof> pats roelof ?? 
13:07:03 <roelof> magneticduck1:   indoctrinated to what ? 
13:07:14 <magneticduck1> are you not becoming to being patted?
13:07:17 <magneticduck1> to Haskell
13:08:25 <roelof> I begin to like haskell more and more. It's something that fits to the way I think 
13:09:05 <magneticduck1> you know how drinking orange juice after brushing your teeth is horrible?
13:09:14 <magneticduck1> so is writing C++ after writing Haskell
13:09:21 <broma0> johnw: that's dense
13:09:24 <roelof> but sometimes It's a big struggle and I want to give up but this channel and haskell-beginners take care that I see a light at the end of the dark tunnel
13:09:31 <magneticduck1> that's what I'm doing right now
13:09:40 <magneticduck1> everything's on fire oh god please help
13:09:43 <roelof> I never liked the C familu 
13:10:03 <magneticduck1> anyway, have fun when you get to lenses
13:10:15 <roelof> but now time to sleep 
13:10:24 <zoku> that's where I am now magneticduck1 
13:10:26 <magneticduck1> Haskell has a very particular way of supporting obscenely complex abstraction libraries
13:10:28 <zoku> and my brain is >_<
13:10:40 <zoku> trying to use aeson through wreq
13:10:41 <magneticduck1> hehe
13:10:42 <nitrix> I'm learning lenses and they are actually fine. Other than the abuse of Template Haskell.
13:10:45 <zoku> and it's wrecking me
13:11:01 <magneticduck1> nitrix: the whole set of things surrounding lenses
13:11:14 <roelof> I have no idea if lenses are discussed in the Craft book or that I learn them on CIS 194 which I wil do after finishsing this book
13:11:21 <magneticduck1> and then mix in some overuse of TH
13:11:29 <nitrix> magneticduck1: My #1 concern is why we have lenses in the first place.
13:11:42 <magneticduck1> I once wrote a program without lenses
13:11:53 <roelof> but good night and see you all tomorrow maybe 
13:11:56 <zoku> is there a quick way to convert a Value to String?
13:11:57 <roelof> Byeee 
13:12:02 <zoku> using Aeson?
13:12:07 <zoku> I should probably read a good aeson tutorial
13:12:15 <magneticduck1> it reminded me of the old days, when we only had ones and zeros; and sometimes we didn't even have ones
13:12:29 <nitrix> @instances Value
13:12:30 <lambdabot> Couldn't find class `Value'. Try @instances-importing
13:12:47 <nitrix> zoku: Data.Aeson.Value has a Show instance.
13:12:56 <nitrix> :t show
13:12:57 <lambdabot> Show a => a -> String
13:13:21 <zoku> right, but that includes the type at the beginning of the string
13:13:24 <zoku> I have a list of urls
13:13:32 <zoku> as Values
13:14:13 <zoku> Ah, http://artyom.me/aeson
13:14:23 <zoku> reading this it looks like I can use pattern matching to unpack them
13:15:10 <nitrix> You can decode and show, or similar.
13:15:20 <zoku> cool, thank you
13:15:42 <magneticduck1> zoku: maybe I'm not sure what you want
13:16:05 <magneticduck1> but a plausible meaning of 'convert a Value to a String (assuming something about the Value)' would imply withText
13:16:43 <zoku> yeah I'm sorry, my questions aren't clear
13:16:44 <magneticduck1> or uh, that wasn't what I was looking for
13:16:56 <zoku> this code is on a computer at home.. so I can't remember exactly what types i had now
13:17:00 <zoku> also i am very sleep deprived :X
13:18:02 <johnw> broma0: but does it answer your question?
13:32:24 <lambda-11235> Can you construct an input wire that's an event in netwire? E.g. Wire s e m a (Event Input).
13:33:27 <Cale> ReinH: pong
13:33:37 <ReinH> Cale: damn, I forgot :(
13:33:41 <lambda-11235> I'm working on a CLI game and input is given as distinct events, and not a continuous behavior.
13:36:45 <monochrom> someone ought to write a paper titled "from discrete events to continuous behaviours". it's true, a game receives discrete input events and produces continuous outputs
13:37:20 <tdammers> eventually you want to sample the continuous output back into a discrete event though
13:37:33 <tdammers> video frames, audio samples, network packets
13:38:14 <monochrom> ok, a sequel to that paper will be "from discrete events to continuous behaviours and back again"
13:38:21 <tdammers> tee hee
13:39:26 * tdammers is writing a little FRP library
13:40:48 <tdammers> OTOH, the final "back again" step is pretty uninteresting and not worth a paper of its own
13:41:39 <monochrom> it's usually the concern of some other program or library
13:46:44 <tdammers> even if it's not, it is a trivial step
13:47:11 <tdammers> conjure up an event that fires on every frame, sampleOn that event
13:49:43 <ReinH> monochrom: There's a clever title there somewhere. I guess Conor should write.
13:50:21 <lambda-11235> Nevermind, I ended up writing an accumB wire.
13:50:23 <ReinH> There and Back Again: A Behavior's Holiday.
13:51:23 <ReinH> I tried.
13:52:42 <hiptobecubic> "Continuous behavior gone wild: programmer discretion is advised"
14:26:32 <nitrix> http://lpaste.net/147971
14:27:08 <nitrix> Is there a way to simplify this? Some kind of isQuitEvent (SDL.eventPayloadEvent) ala Idris?
14:27:49 <nitrix> I suspect Haskell doesn't generate predicates on value constructors automatically?
14:28:52 <mauke> this code bothers me slightly
14:28:55 <mauke> also https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
14:29:01 <johnw> nitrix: you mean, "Is this a value of type X?"
14:29:36 <johnw> nitrix: btw, lens' Prisms could simplify that
14:29:46 <johnw> has _QuitEvent event
14:29:50 <mauke> (SDL.eventPayload event == SDL.QuitEvent)
14:29:57 <nitrix> johnw: No. The type is already known. I'm interested in "Is this a value constructed by X"
14:30:33 <nitrix> The constructor is the information I'm interested in.
14:30:53 <johnw> yep, this is one of those things that prisms are made for, but it means pulling in lens
14:32:02 <nitrix> isn't :: APrism s t a b -> s -> Bool
14:32:06 <nitrix> Ahah, that's cleve.r
14:33:23 <nitrix> :t (==)
14:33:24 <lambdabot> Eq a => a -> a -> Bool
14:34:01 <nitrix> AH!
14:34:08 <nitrix> Event does have an Eq instance!
14:36:01 <nitrix> mauke: Thank you. This is only made convenient because QuitEvent takes no argument; but I'm okay with this.
14:36:11 <nitrix> Mean I can avoid lens :)
14:36:22 <zachk> lens are actually rather nice 
14:36:43 <johnw> whenever I can get away with it, I pull in lens, because it comes with so much utility
14:36:45 <nitrix> zachk: I agree, it's just a matter of not burning steps for me.
14:36:58 <zachk> hmm burning steps? 
14:37:16 <zachk> just try to update a record field inside a Data.Map some other way..good luck :( 
14:37:57 <nitrix> Oh yeah. I've done that before... like this? https://github.com/nitrix/rorymercury/blob/master/src/Context.hs
14:38:17 <zachk> no web browser for me :( I broke it updating qt
14:38:28 * zachk will try to dillo it
14:38:36 <nitrix> zachk: https://raw.githubusercontent.com/nitrix/rorymercury/master/src/Context.hs
14:38:49 <nitrix> zachk: ctxDecChannelActivity is the worst.
14:39:19 <nitrix> Granted I was inexperienced, it still shows record smells.
14:39:50 <zachk> really I wish there was just an easier way to do product types in haskell, that's all a record type is 
14:40:27 <nitrix> There's already one, if you don't need to give your fields names.
14:41:07 <zachk> and I broke my X server with middle click pasting -_- 
14:43:16 <kant> am i right in saying that the time complexity of the following function is O(n^3)?
14:43:18 <kant> let f n = if n < 3 then n else f (n - 1) + 2 * f (n - 2) + 3 * f (n - 3)
14:44:17 <zachk> you could make it faster 
14:44:26 <zachk> memoize! 
14:45:36 <kant> zachk: so the time complexity of O(n^3)? i ask because i'm relatively new to asymptotic notation
14:46:22 <zachk> whats naive fibonacci's ? 
14:46:34 <zachk> cause your function looks like naive fibonacci 
14:47:01 <Jinxit> O(3n) = O(n)
14:47:24 <Ankhers> I'm trying to follow along with https://github.com/parsonsmatt/servant-persistent, but I'm getting an error when I try to retrieve a value from the database. http://lpaste.net/147972 is the portion of the code that is not working correctly. Does anyone have any tips on getting this to work?
14:47:59 <kant> Jinxit: you talkin' to me? is that the time complexity?
14:48:08 <Jinxit> yes
14:48:14 <mauke> no
14:48:22 <dresuer> Hi all!
14:48:33 <zachk> hello dresuer 
14:48:54 <hunteriam> does yesod have a built in way to handle interacting with external apis
14:48:55 <hunteriam> ?
14:49:09 <johnw> "external apis"?
14:49:15 <hunteriam> like stripe
14:49:28 <rcyr> I guess he/she means if yesod has a http client
14:49:59 <linduxed> hey guys, i'm having performance issues with my matrix setting application
14:50:14 <linduxed> code and profiling output can be found here https://gist.github.com/linduxed/2e341378f14cce61f5e4
14:50:40 <linduxed> basically, my implementation is doing nothing but setting lots and lots of elements in the matrix
14:51:00 <linduxed> so i'm starting to think whether there's a better way of setting these things
14:51:51 <dresuer> mayora: given a list of natural numbers and another list of natural numbers too. mayora determined if the firts list is major to secound list.
14:52:06 <dresuer> mayora [x] [y]=x>y
14:52:12 <dresuer> mayora xs ys
14:52:26 <dresuer>     | length(xs) > length(ys) = False
14:52:27 <dresuer>     | length(xs) < length(ys) = False
14:52:35 <dresuer>     | length(xs) == length(ys) = (head xs > head ys) && mayora (tail xs) (tail ys)
14:52:44 <dresuer> It's rigth?
14:53:01 <dresuer> right*
14:54:17 <zachk> you are missing cases for [], and your code looks like it could crash from head xs > head ys if either xs or ys is [] 
14:54:26 <mauke> kant: looks like O(3^n) to me
14:54:27 <dresuer> mayora: given a list of natural numbers and another list of natural numbers too. mayora determined if the firts list is greatest than the secound list
14:54:34 <dresuer> sorry 
14:54:57 <mauke> wow, that looks super inefficient
14:55:01 <zachk> what do you mean by greater? 
14:55:05 <mauke> you're calling length all over the place
14:55:23 <zachk> you should pattern match 
14:56:01 <dresuer> xs is greater than ys, if all elements of xs are greatest than ys elements
14:56:05 <kant> mauke: yeah, it is, and thanks for giving me what looks to be the only correct answer. :)
14:56:33 <zachk> so the leaste lement of xs is greater then the greatest element of ys? 
14:56:34 <mauke> dresuer: what do you mean by greatest than ys elements?
14:56:40 <mpickering> linduxed: I don't know if Data.Matrix is the most widely used matrix package?
14:57:08 <dresuer> mauke, mayora [1,2,3,4] [0,0,0,0] = True
14:57:10 <linduxed> mpickering: i would assume it is...
14:57:20 <linduxed> not sure though
14:57:22 <mauke> dresuer: why?
14:57:35 <dresuer> mayora [1,2,3,4] [5,5,5,5] = False
14:57:49 <dresuer> 1>0 && 2>0&& 3>0 && 4>0
14:57:59 <zachk> you might want to wrap the lists in a datatype and declare Eq and Ord instances for them so you can just use < and > and == with them 
14:58:13 <ReinH> major [] [] = True; major (x:xs) (y:ys) = x > y && major xs ys ; major _ _ = False
14:58:25 <dalastboss> how do I make it so that stack sees when I add new source files to a project?
14:58:38 <zachk> mayora [1,2,3,4] [0,1,1,1] = ? 
14:58:39 <mpickering> linduxed: How is it with unsafeSet rather than setElem?
14:58:41 <mauke> dresuer: why 0?
14:58:46 <ReinH> dalastboss: you shouldn't have to do anything aside from add them to the cabal file as usual
14:58:51 <linduxed> mpickering: hmmm, haven't tried that
14:58:51 <zachk> I just put them in my app directory, which is probably wrong 
14:59:33 <dalastboss> ReinH: haven't used cabal before, but I see the .cabal file
14:59:55 <dresuer> zachk, False. All items have to cumply the condition
15:00:05 <ReinH> dresuer: see my definition above
15:00:25 <dresuer> ReinH, major [] [] = True 
15:00:26 <dresuer> Why?
15:00:36 <johnw> and major _ _ = False, why?
15:00:58 <dresuer> It's not define.
15:01:13 <ReinH> johnw: the original returns False if the lists differ in length
15:01:17 <johnw> ah
15:01:19 <dresuer> mayora [] [] = error "...
15:01:25 <linduxed> mpickering: started it now, cya in 5 minutes :-P
15:01:32 <ReinH> dresuer: because True is the natural element of booleans under conjunction
15:01:42 <ReinH> it's a reasonable choice
15:01:51 <zachk> identity element? 
15:01:57 <ReinH> zachk: same difference
15:02:01 <zachk> :D
15:02:05 <dresuer> johnw, It should be False because the both are the same list.
15:02:17 <johnw> dresuer: hmm?
15:02:18 <ReinH> dresuer: what? no.
15:02:37 <ReinH> If the function isn't defined for some inputs, you should use Maybe
15:02:43 <dresuer> It should be False, because the two lists are the same.
15:02:45 <zachk> [] is special 
15:02:50 <ReinH> dresuer: that's not what that case checks
15:03:02 <mauke> dresuer: what's wrong with same lists?
15:03:07 <ReinH> major _ _ = False has nothing to do with the lists being the same
15:03:21 <mpickering> linduxed: Matrix internally is represented by a vector, which seems to have a few methods you are meant to use to construct a vector. https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#g:7
15:03:24 <dresuer> mauke, I'm talking about [] []
15:03:30 <mauke> dresuer: yes
15:03:36 <mauke> dresuer: what's wrong with same lists?
15:03:58 <mpickering> maybe another thing you could try is see how quick it is to generate the appropiate vector directly by using `generate` or something
15:04:20 <dresuer> If all items are equal then mayora return false
15:04:33 <ReinH> dresuer: there is no check that all items are equal in my solution.
15:04:37 <oisdk_> dresuer if you want [] [] = False, you can do something like: major [x] [y] = x > y; major (x:xs) (y:ys) = x > y && major xs ys; major _  _ = False
15:04:40 <ReinH> so I'm not sure what you're talking about
15:04:55 <linduxed> mpickering: hmmm, what do you mean by "generate the appropriate vector"?
15:05:06 <ReinH> Anyway, the point is to implement it using recursion, not by calling length 4 times
15:05:18 <ReinH> My solution can be modified slightly if it is not exactly correct.
15:05:22 <ReinH> It is the correct shape.
15:05:58 <mpickering> linduxed: It also seems to be allocating a lot? maybe try using foldl' instead of foldr?
15:06:02 <mauke> dresuer: that's not true for [] []
15:06:15 <dresuer> mauke, (y)
15:06:17 <ReinH> mauke: apparently the function is undefined for [] []
15:06:31 <dresuer> ReinH, why?
15:06:32 <mauke> then the function is wrong
15:06:38 <ReinH> dresuer: because you said so
15:06:41 <mpickering> linduxed: I am looking at how the library implements Matrix and see that is using Vector from Data.Vector, then I just looked at how you are meant to create a vector 
15:06:43 <dresuer> <oisdk_> dresuer if you want [] [] = False, you can do something like: major [x] [y] = x > y; major (x:xs) (y:ys) = x > y && major xs ys; major _  _ = False
15:06:56 <dresuer> (y)
15:07:25 <ReinH> Once again, the details aren't important. They can be easily modified. What is important is that you use recursion to solve this.
15:07:42 <dresuer> oisdk_, Perfect.
15:07:53 <linduxed> mpickering: well, considering the thing is still running, i don't think the change to unsafeSet was that big of a win
15:08:15 <mpickering> ok, can you try using foldl' instead of foldr? 
15:08:21 <mpickering> how big is this matrix meant to be?
15:08:30 <oisdk_> dresuer it's the same function as ReinH's, basically, except for the slight change
15:08:33 <ReinH> the original uses of length were highly inefficient and the uses of head and tail were unsafe.
15:09:21 <zachk> pattern match like this for one of the cases: mayora (x:xs) (y:ys) = ..... 
15:10:38 <dresuer> ok
15:10:41 <ReinH> As an aside, if you *do* need to write a function of the shape foo x y | x < y = 1; x > y = 2; x == y = 3 you should instead use foo x y = case compare x y of LT -> 1 -> GT -> 2; EQ -> 3 to avoid redundant calculations.
15:10:59 <linduxed> mpickering: the matrix is 1000x1000
15:11:10 <linduxed> mpickering: and there will be 300 instructions instead of 3
15:11:55 <linduxed> mpickering: also, looking at the 6.prof, i'm thinking it might not be the kind of fold that makes things slow
15:11:58 <linduxed> but i'll try
15:12:06 <ReinH> but calculating (and comparing) lengths of lists is almost always incorrect
15:12:19 <linduxed> ...as soon as the previous run finishes
15:12:26 <linduxed> any day now...
15:12:54 <ReinH> er, I messed up the case syntax there but hopefully the intent is still clear
15:13:04 <liangzan> hello, haskell beginner here. got called to direct my question here instead
15:13:17 <linduxed> liangzan: hello o/
15:13:23 <liangzan> i got a cryptic looking compiler error concerning mtl monad reader
15:13:24 <liangzan> http://lpaste.net/147975
15:13:32 <liangzan> can someone help to enlighten me?
15:13:42 <liangzan> i’m using wreq
15:13:52 <liangzan> trying the get the response body out from the response
15:13:57 <ReinH> liangzan: you can't get a value out of IO.
15:13:57 <mauke> liangzan: your type looks very wrong
15:14:15 <liangzan> how should i do it?
15:14:21 <dresuer> ReinH, f4 determines the number of elements that are true. How can I do that?
15:14:24 <geekosaur> I think what you needed to do there was use bind (>>=) to "look inside" the IO
15:14:24 <mauke> you shouldn't have IO in parameter types (unless you know how IO works, in which case you don't count as a beginner)
15:14:30 <dresuer> f4 [True,True,True,False] = 3
15:14:31 <ReinH> you can write toResponse :: IO (Response ByteString) -> IO ByteString; toResponse = fmap (view responseBody)
15:14:44 <mpickering> linduxed: well I'm mainly wondering about why it allocates so much
15:14:47 <geekosaur> or <- in do notation
15:15:07 <liangzan> ah i got it now
15:15:07 <dresuer> f4 [False,False] = 0
15:15:09 <dresuer> f4 [] = 0
15:15:17 <linduxed> mpickering: mhm
15:15:19 <liangzan> thanks! ReinH!
15:15:35 <linduxed> mpickering: i think it'll finish pretty soon, then i'll try running it with foldl'
15:15:42 <ReinH> or you can write, e.g.; do response <- get "example.com"; let body = view repsonsebody response; ...
15:15:48 <linduxed> mpickering: also, i might make the matrix smaller, for testing purposes
15:15:49 <ReinH> er, view responseBody
15:16:16 <ReinH> the Wreq examples show this as well
15:16:22 <ReinH> in the tutorial
15:16:23 <liangzan> i got a list of requests which i want to fmap into response bodies
15:16:43 <linduxed> mpickering: ./6 +RTS -p < small_input  808.13s user 0.17s system 99% cpu 13:28.75 total
15:16:56 <ReinH> liangzan: then you might want mapM
15:17:00 <linduxed> mpickering: new gist https://gist.github.com/linduxed/4d3987407372ec2fe9af
15:17:09 <liangzan> ok, let me take a look
15:17:11 <liangzan> thanks!
15:17:11 <linduxed> mpickering: will try to run with foldl'
15:17:40 <mpickering> maybe do a heap profile with -hy
15:17:54 <mpickering> which will tell you the type of what is taking up the memory
15:18:01 <mpickering> it should be a flat line right?
15:19:46 <hunteriam> is yesod viable on windows?
15:19:54 <ReinH> dresuer: I don't know what "f4 determines the number of elements that are true" means.
15:20:51 <Cale> hunteriam: I haven't tried it, but it should be.
15:21:13 <dresuer> ReinH sorry, f4 determines the number of elements in a given list that are True. 
15:21:26 <dresuer> Example: f4 [True,True,True,False,False,False] = 3
15:21:29 <dresuer> f4 [] = 0
15:21:34 <dresuer> f4 [True,True] = 2
15:21:48 <ReinH> dresuer: What have you tried?
15:22:31 <dresuer> I don't know how can I "save" the value
15:22:38 <dresuer> Something like counter++;
15:22:58 <ReinH> if f4 [] = True, what about f4 (x:xs)?
15:23:01 <ReinH> er
15:23:07 <ReinH> if f4 [] = 0
15:23:36 <dresuer> if (x==True) then counter++
15:23:38 <dresuer> xD
15:23:56 <ReinH> what do you do with x and what do you do with xs?
15:24:09 <AleXoundOS> dresuer, in pure functional languages you cannot explicitly "save a value"
15:24:17 <ReinH> dresuer: let's try something simpler.
15:24:18 <dresuer> AleXoundOS, I know
15:24:20 <ReinH> How do you write length?
15:24:27 <ReinH> length [] = 0; length (x:xs) = ???
15:25:04 <linduxed> mpickering: i need to fix some type errors
15:25:09 <dresuer> ReinH, That's easy
15:25:10 <linduxed> mpickering: then i'll try to add the -hy
15:25:12 <ReinH> dresuer: then do it
15:25:17 <dresuer> length [] = 0
15:25:21 <mpickering> you can run with -p and -hy
15:25:28 <dresuer> length (x:xs) = 1  + length xs
15:25:41 <ReinH> dresuer: ok
15:25:44 <ReinH> f4 [] = 0
15:25:48 <ReinH> f4 (True:xs) = ???
15:25:53 <ReinH> f4 (False:xs) = ???
15:25:59 <dresuer> Aaaahhh!!!!!!
15:26:13 <dresuer> f4 (True:xs) = 1 + f4 xs
15:26:18 <dresuer> f4 (False:xs) = f4 xs
15:26:22 <ReinH> bingo
15:26:37 <hunteriam> is yesod a good choice for interacting with a servant api and generating html?
15:26:50 <dresuer> I forgot "True:xs"
15:26:54 <dresuer> or 0:xs
15:27:34 <ReinH> another solution: length . filter id
15:27:43 <ReinH> > length . filter id $ [True, True, False]
15:27:45 <lambdabot>  2
15:28:25 <lethjakman> Maybe this is a dumb question...but I can't get the example for the reader monad to run. 
15:28:27 <lethjakman> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html
15:28:32 <lethjakman> It can't find Map.size. 
15:28:41 <lethjakman> Am I supposed to import something?
15:28:42 <linduxed> mpickering: started it now, cya in 13 mins i guess
15:28:44 <dresuer> :D
15:28:55 <mpickering> hunteriam: What do you want to do exactly? I haven't heard of many people using servant and yesod together
15:29:08 <ReinH> lethjakman: it's missing some things: import Data.Map (Map); import qualified Data.Map as Map
15:29:10 <mpickering> linduxed: Maybe reduce the size of the matrix a bit :P ?
15:29:17 <dresuer> ReinH, I rewrite filter function like this
15:29:19 <hunteriam> mpickering:  im building a backend that can be accessed from a website or a phone app
15:29:20 <dresuer> filtro f [] = []
15:29:20 <dresuer> filtro f (x:xs)
15:29:20 <dresuer>   | f x       = x:filtro f xs
15:29:20 <dresuer>   | otherwise = filtro f xs
15:29:23 <linduxed> mpickering: yeah, think i will
15:29:26 <dresuer> It's ok?
15:29:29 <hunteriam> mpickering: im thining yesod = website servant = backend 
15:29:31 <ReinH> @src filter
15:29:31 <lambdabot> filter _ []     = []
15:29:31 <lambdabot> filter p (x:xs)
15:29:31 <lambdabot>     | p x       = x : filter p xs
15:29:31 <lambdabot>     | otherwise = filter p xs
15:29:44 <dresuer> (y)
15:30:18 <dresuer> mapa f [] = []
15:30:18 <dresuer> mapa f (x:xs) = f x : mapa f xs
15:30:21 <hunteriam> mpickering:  bad choice?
15:30:22 <dresuer> map function
15:30:28 <lethjakman> ReinH: why both?
15:30:32 <ReinH> mpickering: something something microservices, with the advantage that you can use the same ToJSON/FromJSON instances on both sides.
15:30:33 <dresuer> @src map
15:30:33 <lambdabot> map _ []     = []
15:30:34 <lambdabot> map f (x:xs) = f x : map f xs
15:30:35 <ReinH> lethjakman: because both are used.
15:30:46 <ReinH> mpickering: it's not an entirely ridiculous idea
15:31:03 <dresuer> @src zip
15:31:03 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:31:03 <lambdabot> zip _      _      = []
15:31:09 <hunteriam> ReinH:  how would you do it?
15:31:12 <dresuer> wtf
15:31:13 <dresuer> zip'' xs [] = []
15:31:13 <dresuer> zip'' [] ys = []
15:31:14 <dresuer> zip'' (x:xs) (y:ys) = (x,y) : zip'' xs ys
15:31:15 <ReinH> dresuer: please query lambdabot to test things out
15:31:21 <dresuer> ok
15:31:28 * mpickering has never used yesod
15:31:38 <ReinH> dresuer: if you first check that both lists are non-empty, all other cases include at least one empty list
15:31:45 <mpickering> you could try asking in #servant 
15:32:16 <ReinH> hunteriam: I'd use an http client to talk to the servant service, like any other service
15:32:19 <ReinH> e.g., wreq
15:32:20 <mpickering> most applications I have seen have just used servant but I haven't been watching closely
15:32:28 <hunteriam> ReinH: why not yesod?
15:32:35 <ReinH> hunteriam: what do you mean "why not yesod"?
15:32:41 <ReinH> Yesod is an http server, not an http client
15:32:58 <ReinH> if you want yesod to talk to an http service, you need to use an http client
15:33:05 <ReinH> that's your backend instead of, e.g., a database
15:33:16 <hunteriam> oh gotcha, but to serve the html yesod is not a bad choice?
15:33:22 <zachk> > if 2+2 == 4 then "dresuer: you are my friend" else "why you no like lambdabot?" 
15:33:24 <lambdabot>  "dresuer: you are my friend"
15:33:36 <ReinH> hunteriam: I don't know.
15:33:55 <zachk> hunteriam, is it static or dynamic html? 
15:33:59 <slava> yesod is web framework, not web webserver 
15:34:01 <hunteriam> dynamic
15:34:04 <slava> warp is web server
15:34:36 <ReinH> a framework for writing web servers. The important distinction is that yesod is for servers, not clients.
15:34:53 <slava> not web servers, but web services 
15:35:02 <slava> there are difference 
15:35:04 <ReinH> slava: web services are web servers
15:35:09 <ReinH> they serve things
15:35:25 <zachk> you could just use warp for some simple dynamic html 
15:35:26 <adamCS_> hunteriam: I am using Yesod to serve some html to a (browser) front-end written with reflex.
15:35:34 <slava> in that case php is also web server xD 
15:35:38 <monochrom> I don't think it's healthy to make a big distinction between "service" and "server" these days.
15:35:43 <linduxed> mpickering: https://gist.github.com/linduxed/25224ccbf09923acd6f8
15:35:46 <zachk> also netcat! 
15:35:49 <ReinH> slava: it is used to implement web servers, yes
15:36:09 <slava> yesod use warp for web server
15:36:14 <hunteriam> servant is better than yesod for my api right
15:36:20 <adamCS_> hunteriam: but if I were starting from scratch, I might just use servant to do the job Yesod is doing now.
15:36:29 <ReinH> slava: what's the point of this? Do you think people are confused?
15:36:30 <slava> so if you are building web service using yesod you are using warp web server 
15:36:30 <mpickering> linduxed: what does the heap profile look like?
15:36:45 <slava> also there so other deploying options in yesod
15:36:54 <slava> you could use nginx for web server
15:37:11 <slava> yesod can interact with nginx via fastcgi interface 
15:37:15 <ReinH> slava: Ok. Whatever.
15:37:21 <zachk> spock and scotty both looked really simple, though I have never used either one 
15:38:26 <linduxed> mpickering: https://gist.github.com/1dbe8e1e47b3ed437465
15:38:28 <hunteriam> so do you guys think I should serve a static javascript client that then goes and requests relevant data from my servant api or should I generate the pages in a yesod server that interacts with my servant api
15:38:29 <adamCS_> hunteriam:  All Yesod is doing is handling a request, using fromJSON to decode the data I'm sending over, calling a function from an external lib, creating some html (tables and some svg for charts) and sending it back.  I think any of the web -server + frameworks could handle that.
15:38:31 <linduxed> mpickering: not sure how to read it
15:38:44 <mpickering> linduxed: oh right sorry, you should us hp2ps 
15:38:56 <mpickering> which will generate a graph you can look at
15:39:20 <adamCS_> hunteriam:  I have enjoyed using reflex to build the client.  Much more fun than learning javascript!
15:40:01 <mpickering> linduxed: hp2ps -c is usually best so the graph is in colour
15:40:06 <hunteriam> adamCS_: did you use ghcjs or something?
15:40:15 <adamCS_> hunteriam: yes
15:40:37 <adamCS_> hunteriam: But that was not too bad now that stack can handle it. 
15:41:02 <hunteriam> does it make good js?
15:41:11 <linduxed> mpickering: https://gist.github.com/linduxed/003a6d6703efbd8dd2b2
15:41:12 <adamCS_> hunteriam:  good how?
15:41:18 <hunteriam> small/fast
15:41:23 <mpickering> linduxed: So * is thunks, so it looks like about half your allocations are coming from a space leak
15:41:34 <mpickering> (I made the graph myself)
15:41:55 <adamCS_> hunteriam:  Not small.  I'm not the person to judge fast.  But if you are serving the data from servant, how fast does the js need to be?
15:42:01 <linduxed> mpickering: hmmm
15:42:07 <hunteriam> true
15:42:12 <linduxed> mpickering: how is that the case?
15:42:18 <linduxed> is there somthing i can do about that?
15:42:54 <adamCS_> hunteriam:  progress is also being made on that front. And being able to use all your haskell in the front-end is pretty awesome.
15:44:15 <mpickering> linduxed: I'm starting to run out of ideas sorry
15:44:26 <linduxed> mpickering: :-(
15:44:36 <linduxed> mpickering: well, thanks for your effort!
15:44:50 <adamCS_> hunteriam:  In my case, I had a lot of types that would have been a pain to rewrap as js.  With reflex+ghcjs I could just use my existing haskell code and then send the data over as json to be decoded.  So i got the front/back sharing. 
15:44:51 <linduxed> mpickering: it's nice to have someone help out this much already
15:45:01 <luzie> linduxed: you may want to use Data.Array.ST and index with V2 from linear
15:45:17 <hunteriam> adamCS_:  im intimidated by reflex
15:45:25 <linduxed> luzie: whoa, that was a lot at once
15:45:36 <adamCS_> hunteriam:  By the ghcjs setup or by reflex itself?
15:45:40 <luzie> haha
15:45:44 <hunteriam> adamCS_: some of both
15:45:49 <mpickering> linduxed: It seems that the list generated by rectangleCoordinates  is going to be quite big as well
15:46:29 <csd_> what does a trailing @ mean? e.g. fun x@ = ...
15:46:48 <linduxed> mpickering: hmmm, yes
15:46:50 <adamCS_> hunteriam:  The setup was not so bad for me.  Just followed the stack instructions and it worked.  Then I wanted to move to newer versions of some libs and that required the smallest bit of stack.yaml work.  But not bad.
15:47:56 <luzie> linduxed: it'd probably be better to use a mutable array for this so you can have in place updates, such as Data.Array.ST
15:47:59 <mpickering> seems like it would be better to avoid generating the list 
15:48:07 <adamCS_> hunteriam:  Reflex is fun, though for me, with no web/gui experience, it is still a lot to learn. But I am enjoying it!  
15:48:24 <hunteriam> do you have a guide?
15:49:06 <linduxed> luzie: so you're saying that i should implement a matrix type with the help of Data.Array.ST?
15:49:19 <luzie> yeah
15:50:03 <adamCS_> hunteriam:  Just the various docs/sample projects on the web.  The IRC channel (#reflex-frp) is also super helpful. 
15:50:04 <ReinH> linduxed: Are these dense matrices?
15:50:10 <luzie> and Linear.V2 implements 2d indexing
15:51:03 <ReinH> you could try repa or LAPACK bindings
15:51:08 <luzie> it's a 1000x1000 grid of bools
15:51:20 <ReinH> repa can give you efficiency similar to nested for loops in C
15:52:23 <linduxed> ReinH: what luzie said
15:52:37 <ReinH> right, but is it dense or sparse? I'm guessing dense?
15:52:52 <Cale> btw, if you use unboxed arrays of bools, they get packed into bit fields internally, iirc
15:52:53 <linduxed> ReinH: also, pretty much randomly sized rectangles of coordinates get changed
15:53:03 <linduxed> ReinH: can be large, can be tiny
15:53:16 <ReinH> Cale: seems good
15:53:57 <ReinH> ... I guess I'll just assume they're dense matrices.
15:54:18 <hunteriam> adamCS_: thanks!
15:55:51 <linduxed> ReinH: the input operations are different for different users for the problem, however here's one end result https://i.imgur.com/jJQxt4B.jpg
15:56:48 <linduxed> ReinH: here's an animated visualization http://i.imgur.com/tSIdjKM.gifv
15:56:50 <ReinH> If they're dense matrices, you can try repa. repa-algorithms has a matrix multiplication algorithm.
16:00:26 <adamCS_> hunteriam: Sure!
16:00:49 <linduxed> luzie: it would seem some other people who have attempted the problem have used Data.Array.ST
16:01:01 <linduxed> luzie: so i think that that is a solution to try out
16:01:06 <adamCS_> hunteriam:  I'm a beginner with the ghcjs and reflex stuff but I'm happy to help if you have questions.
16:21:13 <brimdish> How useful is something like SICP (or even theoretical computer science in general) to someone interested in security/ethical hacking? Seems *COMPLETELY* useless.
16:23:18 <aweinstock> brimdish: knowing theoretical CS might help with writing *really* secure stuff (via things like theorem proving, proovably correct code)
16:23:43 <ReinH> brimdish: knowing how computers and computer systems work is probably not completely useless to someone looking to secure or hack them.
16:24:33 <brimdish> But, your typical, competent hacker doesn't need to know about shit like Big O notation, asymptotic analysis, algorithm analysis, metalinguistic abstraction, etc., though, right?
16:24:59 <Cale> Uh, if you somehow avoided understanding Big-O notation I don't think you could be considered competent.
16:25:27 <aweinstock> knowing compiler innards helps with reverse-engineering (if you're hacking something you don't have the source for, only the binary)
16:25:31 <bitemyapp> yeah why would somebody hired to defend against denial of service attacks need to know how to write efficient software
16:25:34 <bitemyapp> seems useless. totes.
16:25:48 * bitemyapp glances askance at Rails CVEs
16:25:50 <aweinstock> brimdish: knowing big-O notation actually did help me solve a hacking challenge recently
16:26:00 <csd_> can someone please explain what's going on with oddprimes in this snippet http://pastebin.com/KBBx7bcQ
16:26:06 <Cale> Yeah, if you don't understand complexity of algorithms, you will walk straight into denial of service attacks.
16:26:17 <ReinH> asymptotic analysis is not irrelevant to security and cryptography. Quite the opposite.
16:26:23 <ReinH> It's pretty important.
16:26:36 <Cale> and yes, it's also highly relevant to analysis of cryptographic algorithms
16:26:52 <aweinstock> I was able to use a pointer as if it were a length, and the print function the challenge provided was O(n^2), so recognizing that allowed me to come up with a workaround
16:27:10 <brimdish> I mean, I understand some of those things, I do, but I just *highly* doubt some of your self-taught, yet competent and accomplished hackers give two shits about asymptotic analysis.
16:27:22 <Jinxit> theoretical CS and encryption go hand in hand
16:27:32 <ReinH> timing attacks require an understanding of timing
16:27:34 <aweinstock> (basically, use the pointer-as-length to have write access to forge an object with a much lower length
16:27:34 <ReinH> etc
16:27:50 <lethjakman> I'm looking at a Reader type signature that looks like this: calculateContentLen :: Reader String Int But it doesn't seem to accept a argument, but it is accepting an argument. 
16:27:56 <lethjakman> Is Reader String Int somehow a function?
16:28:11 <Cale> brimdish: You can maybe get by just knowing a lot about already-known security issues in old versions of software
16:28:31 <aweinstock> brimdish: are you talking about skids?
16:29:01 <Jinxit> brimdish: my counter-question is this: why NOT learn it?
16:29:11 <Jinxit> big O notation isn't exactly difficult
16:29:13 <ReinH> lethjakman: what is the definition?
16:29:26 <ReinH> Reader is a wrapper around a function.
16:29:32 <lethjakman> ReinH: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html
16:29:37 <lethjakman> It's example number 2. 
16:29:44 <aweinstock> Jinxit: that applies to big-O-notation, but his initial question was about theoretical CS in general
16:29:54 <Cale> brimdish: But if your concern is actually constructing secure software, or identifying problems in security, or implementing (or even just correctly applying implementations of) cryptography... the picture is quite different.
16:30:03 <ReinH> lethjakman: where does it look like it is accepting an argument?
16:30:08 <brimdish> aweinstock: Nah, not tot them.
16:30:44 <lethjakman> ReinH: "runReader calculateContentLen s"
16:30:46 <aweinstock> brimdish: what subfields of security are you interested in? crypto? memory corruption? logic bugs like SQLi?
16:30:53 <ReinH> lethjakman: that's (runReader calculateContentLen) s
16:30:59 <lethjakman> Oh
16:31:09 <lethjakman> Hm. 
16:31:17 <ReinH> Reader is a wrapper around a function
16:31:23 <ReinH> runReader unwraps it, giving the function
16:31:32 <lethjakman> and runreader accepts the second argument, correct?
16:31:35 <ReinH> no
16:31:42 <brimdish> Jinxit: I don't want want to waste my time learning new material in SICP if it can't truly help me with my interest - exploitation and defensive security; I could be leanrning something else I don't know pertaining to my fields of interest or something.
16:32:01 <ReinH> runReader accepts calculateContentLen and gives a function. That function accepts s.
16:32:09 <Cale> Of course, it's the same thing
16:32:16 <Cale> as runReader accepting both arguments
16:32:22 <Jinxit> brimdish: you're bound to run into CS concepts regardless
16:32:26 <ReinH> brimdish: Ok. don't read it then. I'm not sure why it's our job to convince you.
16:32:27 <bitemyapp> brimdish is a copy-pasta petri dish
16:32:27 <lethjakman> I'm just looking at the definition of runReader is why I said that
16:32:34 <lethjakman> Reader r a -> r -> a
16:32:35 <bitemyapp> you could just mix up the shit he's saying a little bit
16:32:36 <Cale> There's no difference in Haskell between a function of two arguments and a function which produces another function as its result
16:32:43 <lethjakman> I think I get it now. 
16:32:44 <bitemyapp> baby, you got a script-kid copy-pasta goin'
16:32:52 <ReinH> :t runReader
16:32:54 <lambdabot> Reader r a -> r -> a
16:32:58 <bitemyapp> somebody not me should try this on /b/
16:32:59 <bitemyapp> er, /g/
16:33:17 <ReinH> lethjakman: runReader takes a value of type Reader r a and gives a function of type r -> a
16:33:20 <icbm> lethjakman: Reader is the idea of "run this computation and give all of its functions access to this context value", to my noobish mind.
16:33:29 <lethjakman> Gotcha. 
16:33:31 <ReinH> that function is then applied
16:33:32 <lethjakman> That makes sense.
16:33:44 <ReinH> to a value of type r
16:33:46 <ReinH> giving a value of type a
16:33:53 <ReinH> for whatever r and a are in this context
16:34:04 <lethjakman> And...the values in reader aren't changable, correct? You can only thread a different environment later. 
16:34:05 <ReinH> String and Int, apparently
16:34:21 <lethjakman> But state is similar, but you can change the values?
16:34:24 <zachk> is there a data structure like Data.Map but for keys that coold be equal to more then one thing on lookup? and it's lookup returns [(Key,Value)] ? 
16:34:30 <ReinH> lethjakman: Reader doesn't have a value. It is a suspended computation that is given a value later.
16:34:37 <icbm> lethjakman: You can run a sub-reader with a different context, so that's sorta like changing it, but the intent is that you don't change it.
16:34:42 <brimdish> bitemyapp: You callin' me a script kiddie, m8?
16:34:43 <bitemyapp> lethjakman: Reader is just a dumb container newtype for values that are functions.
16:35:01 <bitemyapp> brimdish: u havin a gigl m8? sware on me mum
16:35:16 <zachk> h3 s0 l337 w47ch 0u7 br0
16:35:18 <lethjakman> Gotcha. 
16:35:19 <ReinH> bitemyapp: gr8 b8 m8 I r8 8/8.
16:35:36 <lethjakman> Thank you for your help
16:35:36 <jmcarthur> zachk: How about Map Key [Value]?
16:35:40 <lethjakman> That makes a lot more sense. 
16:36:01 <ReinH> lethjakman: in do { content <- ask; return (length content) }, content is a placeholder for whatever value is supplied later.
16:36:05 <Cale> brimdish: Of course, it depends a lot on the seriousness of the applications you want to be talking about. If you're working on, e.g. defence projects which need to be extremely secure, there's more time and effort to be allocated to applying formal methods to ensure various sorts of correctness.
16:36:11 <zachk> I am more interested in a Key to that could equal to more then one thing in the Data.Map's key val pair 
16:36:44 <adamCS_> lethjakman:  sometimes I think of Reader as a way to wrap things that need a specific piece of information before they are useful.  But you want to act on them without that information and provide it later.
16:36:50 <ReinH> zachk: keys that are equal to each other are the same key.
16:37:02 <bitemyapp> ReinH: tenouddaten
16:37:07 <ReinH> (according to that key's instance of Ord)
16:37:15 <lethjakman> Ok. That's a great way to think of it
16:37:18 <lethjakman> Thank you people!
16:37:18 <zachk> not for my instance of Eq for a string pattern matching mini-language I have written 
16:37:20 <lethjakman> :)
16:38:12 <zachk> or...excusing overlapping 'patterns, is there a lookup for map that returns the key that matched in the map as well as the value? 
16:38:12 <Cale> brimdish: If you're talking about the security of some random guy's Wordpress blog, the bar is a hell of a lot lower.
16:38:40 <brimdish> I'm a high school dropout trying to pick up some useful skills. I hear competent hackers can make a living without degrees or diplomas, so I've been furthering my prog and compsci knowledge as much as I can (I've known basic Haskell, C, C++, and Python for a while -- just recently having touched on theoretical compsci).
16:38:47 <brimdish> I'm just tryin' to get paid, m8.
16:38:54 <ReinH> zachk: you already have the key. If you're using a key type where two values are equal according to Ord but inequal according to some other observation, your key type's Ord instance is broken.
16:38:58 <zachk> paid to do what? 
16:39:27 <ReinH> and that should be considered a big
16:39:30 <ReinH> or a bug
16:39:32 <ReinH> whichever one makes sense
16:39:59 <ReinH> s/inequal/unequal, I guess. Unequal, inequality. Whatever.
16:40:11 <ReinH> English is stupid.
16:40:20 <aweinstock> brimdish: https://github.com/RPISEC/MBE/ you might find this material interesting
16:40:28 <nshepperd> If you don't know big O analysis your programs will be mysteriously slow and you'll cry
16:40:52 <ReinH> nshepperd: I do know big O and my programs are still mysteriously slow, please advise
16:40:57 <icbm> ReinH: All the time, I wish for a better language than English in which to talk programming.  Or at least, I'd like someone to start a programmer's thesaurus.
16:41:06 <zachk> lojban? 
16:41:20 <ihamid> How do you fine people feel about devastatingly n00b-ish questions?
16:41:30 <sbrg> ihamid: just ask your question
16:41:34 <zachk> fine in general 
16:41:36 <ReinH> ihamid: I like them better than that question.
16:41:38 <nshepperd> ReinH: sacrifice a goat?
16:41:43 <icbm> ihamid: I'm a noob, so hope you look noobish answers. :)
16:41:43 <ReinH> nshepperd: thanks brb
16:42:00 <zachk> no shoot a plushie from an orbital rail gun on a stratospheric weather balloon! 
16:42:25 <icbm> I'll have some of whatever zachk is having...
16:43:24 <ihamid> I'm looking for something that will apply an IO action to a Maybe value if it's a Just. What I've tried is map (only works with Lists). I've also tried liftM (print) (Just 5) and it gives returns a function of type Maybe (IO ())
16:43:32 <zachk> starbucks coffee, veranda blend, 3 sugars, venti, and way too much reddit over the past year 
16:43:39 <ReinH> ihamid: what type is your IO action?
16:43:46 <monochrom> something tells me that "orbital" and "stratospheric" can't be the same place
16:43:54 <Cale> ihamid: The generalised version of mapM sounds like what you want
16:43:57 <Cale> :t mapM
16:43:57 <zachk> suborbital? 
16:43:58 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:43:58 <ihamid> I can do something similar by doing, e.g., sequence_ $ liftM (print) [1..10]
16:44:10 <Cale> If we pick m = IO, and t = Maybe
16:44:16 <zachk> ihamid what do you want the IO action to be in case of Nothing? 
16:44:24 <Cale> then that becomes (a -> IO b) -> Maybe a -> IO (Maybe b)
16:44:27 <ihamid> for my current experimental purposes I'm just using (print)
16:45:15 <ihamid> If it's Nothing then I'd want to have no printing to the screen. Kind of similar to what would happen if I did liftM (+2) (Nothing) and I would get Nothing back.
16:45:21 <monochrom> "3 sugars" is how to become insane
16:45:35 <zachk> f (Just value) = print value ; f Nothing = print "No Value!" or ; f Nothing = return () , and the return () will do nothing but it is still an IO 
16:45:45 <ReinH> :t mapM_ print (Just 3)
16:45:47 <lambdabot> IO ()
16:45:59 <zachk> no no that is research chemicals 
16:46:43 <ReinH> since print x is an IO (), it's a bit cleaner to use mapM_
16:46:47 <icbm> Can confirm zachk has been on reddit.
16:46:57 <ihamid> I can definitely do pattern matching and carry out the action I want like you suggest zachk, I was looking for one of those fabled elegant Haskell solutions in an attempt to grok how these things work.
16:47:11 <ReinH> ihamid: well, you've got two now.
16:47:37 <dhz_> @hoogle mapM_
16:47:39 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:47:39 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:47:39 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
16:47:43 <aweinstock> :t maybe (return ()) print
16:47:45 <lambdabot> Show a => Maybe a -> IO ()
16:48:01 <ihamid> mapM_ (print) (Just 10) works. However, it returns a Maybe (IO ()). Is there something similar to sequence_ for Maybe that I could use to apply the contained IO () action?
16:48:19 <ReinH> ihamid: no it does not.
16:48:21 <dhz_> where is generalized mapM_ in prior verions of ghc?
16:48:23 <ReinH> :t mapM_ print (Just 3)
16:48:24 <lambdabot> IO ()
16:48:26 <ReinH> it returns an IO ()
16:48:42 <ReinH> dhz_: You have it there: Data.Foldable
16:48:55 <ReinH> mapoM_ print is exactly what you asked for
16:48:57 <ihamid> sorry, I meant liftM print (Just 10)
16:49:02 <ReinH> er, mapM_ print
16:49:13 <ReinH> ihamid: that's why you should use mapM_ instead
16:49:27 <ihamid> :t mapM_
16:49:28 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
16:49:48 <ihamid> arghhh... there's two of em!
16:49:54 <ihamid> I was using the one in Data.List :)
16:50:03 <monochrom> @type liftM print (Just 10)
16:50:04 <lambdabot> Maybe (IO ())
16:50:05 <dhz_> in newer versions of ghc there's only one
16:50:05 <ReinH> You should be using GHC 7.10
16:50:12 <ReinH> where the default one is the one you want
16:50:19 <monochrom> Maybe (IO ()) doesn't look like what you want
16:50:34 <ReinH> monochrom: it isn't. They want mapM_ print.
16:50:48 <monochrom> when intuition disagrees with types, intuition is always wrong. remember that.
16:50:50 <dhz_> is ihamid more than one person?
16:50:51 <aweinstock> :t maybe (return ()) id
16:50:52 <lambdabot> Monad m => Maybe (m ()) -> m ()
16:50:58 <monochrom> in fact, intuition is always wrong.
16:51:04 <ReinH> monochrom: As usual, Cale got it right and then we had to say if a few more times until it stuck. ;)
16:51:10 <zachk> but what if it's intuionistic type theory? 
16:51:19 <aweinstock> :t maybe (return ()) id :: Maybe (IO ()) -> IO ()
16:51:21 <lambdabot> Maybe (IO ()) -> IO ()
16:51:41 <monochrom> intuitionistic type theory has nothing to do with intuition, apart from a common substring
16:52:11 <ihamid> I'm only one person :)
16:52:33 <dhz_> ihamid I know :)
16:53:35 <nineonine> hey
16:53:42 <nineonine> could someone please explain this ?
16:53:48 <nineonine> (+1) $ 1
16:54:00 <nineonine> gives 2
16:54:02 <ReinH> nineonine: (+1) = \x -> x + 1
16:54:08 <nineonine> but (-1) $ 1
16:54:15 <nineonine> gives 
16:54:16 <nineonine> Non type-variable argument in the constraint: Num (r -> t)
16:54:16 <Cale> nineonine: (-1) is negate 1
16:54:24 <aweinstock> > (subtract 1) $ 1
16:54:26 <lambdabot>  0
16:54:43 <nineonine> thanks ^_^
16:54:46 <Cale> nineonine: It's a wrinkle in the syntax because we'd like -x to mean "negative x"
16:54:47 <aweinstock> (\x -> x-1) $ 1
16:54:49 <aweinstock> > (\x -> x-1) $ 1
16:54:51 <lambdabot>  0
16:54:58 <ReinH> nineonine: it's a special case to make it more convenient to express negative numbers
16:55:09 <monochrom> it is interesting that mapM_ just needs Foldable and mapM needs Traversable
16:55:13 <nineonine> sweet
16:55:14 <nineonine> thanks
16:55:23 <aweinstock> :t (\x -> -x)
16:55:25 <lambdabot> Num a => a -> a
16:55:34 <aweinstock> > (\x -> -x) 5
16:55:36 <lambdabot>  -5
16:55:39 <ReinH> monochrom: You don't need the structure, only the values.
16:58:12 <ReinH> (in order)
16:59:55 <Bruuuuno> I have some 
17:00:49 <ReinH> the suspense is killing me
17:01:04 <ReinH> What? What do you have? TELL ME!
17:01:11 <aweinstock> ReinH: values
17:01:39 <aweinstock> 42 is a value, do you want it?
17:01:40 <Bruuuuno> I have some data structure that I have to update some fields. Like if I have data Foo = Foo { i :: Int, a :: string } and update foo = foo { i = i foo + 1 }
17:02:01 <Bruuuuno> is there a way to do something like foo.i += 1 or something
17:02:04 <aweinstock> lens
17:02:19 <johnw> foo & _i += 1
17:02:19 <zoku> most things in haskell are immutable
17:02:21 <johnw> would be the exact syntax
17:02:26 <ReinH> > (1,2) & _1 +~ 1
17:02:28 <lambdabot>  (2,2)
17:02:31 <ReinH> johnw: += in State
17:02:45 <aweinstock> @let data Foo = Foo { _i :: Int, _a :: String }
17:02:46 <lambdabot>  Defined.
17:02:58 <johnw> ah, right
17:02:58 <aweinstock> @let makeLenses ''Foo
17:02:58 <lambdabot>  Parse failed: Parse error: '
17:03:02 <dhz_> by "update some fields" do you mean return new data with desired fields?
17:03:03 <johnw> my brain and fingers failed to communicate
17:03:10 <ReinH> johnw: :) happens all the time
17:03:12 <Bruuuuno> ya dhz_
17:03:13 <zoku> @let makeLenses ''Foo
17:03:13 <lambdabot>  Parse failed: Parse error: '
17:03:16 <aweinstock> :t (+=)
17:03:17 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
17:03:35 <aweinstock> zoku: TemplateHaskell is probably disabled for security reasons
17:03:45 <aweinstock> :t Language.Haskell.TH.runIO
17:03:46 <lambdabot> IO a -> Language.Haskell.TH.Syntax.Q a
17:03:52 <Bruuuuno> why do you use _i and _a instead of i and a?
17:04:06 <zoku> that's how lenses are created
17:04:13 <aweinstock> Bruuuuno: in order for the TemplateHaskell function makeLenses to automatically write lenses for you
17:04:20 <ReinH> It's one way that lenses can be created.
17:04:29 <aweinstock> it's code that writes code, that writes the boilerplate for you so that you don't need to :)
17:04:34 <aweinstock> :t lens
17:04:35 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
17:04:56 <aweinstock> :t i
17:04:57 <lambdabot> Expr
17:05:00 <aweinstock> :t _i
17:05:01 <lambdabot> Foo -> Int
17:06:03 <aweinstock> :t lens _i (\x@(Foo { _i = _i } -> x{_i = _i+1})
17:06:04 <lambdabot> Parse error in pattern: x {_i = _i + 1}
17:06:29 <monochrom> I wonder if you need a space
17:06:33 <ReinH> @undefine
17:06:33 <lambdabot> Undefined.
17:06:38 <aweinstock> :t lens _i (\x@(Foo { _i = tmp } -> x { _i = tmp+1})
17:06:39 <lambdabot> Parse error in pattern: x {_i = tmp + 1}
17:06:44 <aweinstock> @let data Foo = Foo { _i :: Int, _a :: String }
17:06:46 <ReinH> @let data Foo = Foo { _i :: Int, _a :: String } deriving Show
17:06:46 <lambdabot>  Defined.
17:06:47 <lambdabot>  .L.hs:148:1:
17:06:48 <lambdabot>      Multiple declarations of ‘Foo’
17:06:48 <lambdabot>      Declared at: .L.hs:146:1
17:06:52 * ReinH sighs
17:06:54 <aweinstock> sorry
17:06:57 <monochrom> stereo typing
17:07:06 <aweinstock> @undefine
17:07:07 <lambdabot> Undefined.
17:07:15 <aweinstock> ReinH: go ahead
17:07:16 <Bruuuuno> oh well that's nice, I should look into it thx
17:07:21 <ReinH> @let data Foo = Foo { _i :: Int, _a :: String } deriving Show
17:07:22 <lambdabot>  Defined.
17:07:24 <monochrom> welcome to haskell, where we stereo type everything
17:07:25 <ReinH> > let i = lens _i (\foo x -> foo { _i = x }) in Foo 1 "foo" & i +~ 1
17:07:27 <lambdabot>  Foo {_i = 2, _a = "foo"}
17:07:31 <monochrom> err, s/haskell/#haskell/
17:08:49 <ReinH> monochrom: Hmm I should set my monitors to mirroring and try stereo coding too.
17:09:19 <ReinH> Hmm there seems to already be some diminishing returns.
17:10:54 <monochrom> you only need two emacs buffers for that. (both buffers present the same file)
17:11:17 <ReinH> This is nowhere near twice as productive :(
17:11:46 <monochrom> in fact I sometimes do that, to copy-paste-vary from one location to another, in the same file, but 1000 lines apart
17:12:23 <monochrom> (and yes it's boilerplate copy-paste-vary because it's LaTeX not Haskell. can't do abstractions.)
17:12:50 <ihamid> Thanks everyone. Data.Traversable.mapM was exactly what I was looking for.
17:13:19 <monochrom> are you sure?
17:13:54 <monochrom> IO (Maybe Int) comes with a much higher price than IO ()
17:14:10 <ihamid> Price?
17:14:50 <ReinH> ihamid: pretty sure you want mapM_
17:17:30 <ihamid> ReinH: you're right. I didn't find mapM_ because it is in Data.Foldable and not Data.Traversable. But yes, mapM_ discards the return which is fine by me.
17:17:50 <ReinH> ihamid: well, I said mapM_ half a dozen times, so I thought you might have found it that way. ;)
17:18:00 <ihamid> My bad :)
17:18:11 <ReinH> it's fine :)
17:18:55 <ihamid> I kept getting to the Control.Monad.mapM_ variety.
17:19:57 <monochrom> this is why I said something about interesting that mapM_ and mapM have different assumptions
17:20:41 <monochrom> Foldable just consumes. Traversable not only consumes but also produces.
17:20:54 <ReinH> ihamid: you should use GHC 7.10
17:21:20 <monochrom> mapM_ is not "do what mapM does first, then discard what it produces". mapM_ doesn't even bother to produce
17:21:41 <monochrom> and it has a dire consequence on time and space
17:22:59 <monochrom> about the only hole you can poke into what I said is "it's just a Maybe in this case, no big deal"
17:23:35 <physixer> Woah. Operational semantics is denotataional semantics at the statement level!
17:23:41 <ReinH> generally speaking, generating some result that you then throw away is inefficient and unnecessary.
17:23:43 <physixer> *denotational
17:23:51 <ReinH> physixer: what does that mean?
17:24:08 <johnw> yeah, where are you reading that from?
17:24:22 <johnw> in particular, I'm not sure "the statement level" has a meaning
17:24:33 <monochrom> yeah, I wonder if it's "(operational semantics is denotataional semantics) at the statement level" or it's "operational semantics is (denotataional semantics at the statement level)"
17:24:34 <physixer> for simple statements like 5+5, the operational and denotational semantics are the same.
17:24:36 <ReinH> monochrom: I'm reminded of the joke: I built a robot. (What does it do?) It records information about its environment and then discards it and runs into walls.
17:24:48 <physixer> monochrom: the second interp.
17:25:03 <johnw> physixer: 5+5 has a single denotation; it has at least 4 operational meanings that I know of
17:25:17 <monochrom> I think it's a false statement.
17:25:58 <physixer> johnw: ok. Take one of those 4 operational meanings. What is the denotational semantics of that meaning?
17:26:02 <ReinH> monochrom: perhaps it is influenced by http://www.haskellforall.com/2013/07/statements-vs-expressions.html ?
17:26:13 <ReinH> physixer: why do you assume that the denotational semantics has to come from the operational semantics?
17:26:26 <Guest00000> hello.
17:26:50 <ReinH> For that matter, what does "what is the denotational semantics of the operational meaning" mean?
17:26:50 <physixer> maybe my example is bad because 5+5 is a high-level construct. But once you break it down into pieces, at some point OS matches DS.
17:27:16 <ReinH> Why?
17:27:20 <ReinH> Why must it be so?
17:28:05 <physixer> what is the operational semantics of "load [1024]" where 1024 is the memory address? what are its denotational semantics?
17:28:08 <physixer> same
17:28:49 <Guest00000> is it possible to express a pure function :: X -> (X -> Y) -> Bool which gives its argument function an argument and tells whether it touched it before producing result?
17:29:03 <monochrom> at this point, I'll just say "whatever you say" and leave it.
17:29:06 <Guest00000> or maybe there is such insafe function?
17:29:12 <ReinH> Guest00000: whether what touched what and what do you mean by touched?
17:29:27 <monochrom> ReinH: I think Gabriel is misguided for once.
17:29:37 <Guest00000> okay, rephrase better
17:29:38 <johnw> physixer: as far as I understand it, they often *cannot* match, because DS uses mathematical objects for its definitions that may non-deterministic (for example, statements from set theory), while an OS must be computable
17:29:39 <monochrom> perhaps just this time
17:29:45 <ReinH> monochrom: Yeah I'm not quite following either
17:29:59 <monochrom> for example in C, expressions say what code does, too.
17:30:06 <Guest00000> is there a function which checks for a given function f, f _|_ = _|_
17:30:09 <ReinH> The operational and denotational semantics of load [1024] do not match. Why do you think that they do?
17:30:13 <Guest00000> but only for one argument
17:30:20 <monochrom> in fact, hell, also in Pascal and various MLs and Scheme and Lisp and ...
17:30:29 <ReinH> What exactly do you think *are* the OS and DS of load [1024]?
17:30:45 <physixer> johnw: and thanks to Curry-Howard, there is a direct correspondence between logic/math and computation
17:30:50 <monochrom> the only way you can wing that is to assert "C, Pascal, MLs, Scheme, Lisp... they all have no expressions"
17:30:50 <Guest00000> ugh
17:31:10 <ReinH> physixer: and exactly how does that correspondence express itself here?
17:31:13 <Guest00000> i cannot express myself
17:31:13 <ReinH> This is all hand waving.
17:31:20 <Guest00000> i asked wrong question
17:31:22 <nshepperd_> you could claim that some C code technically "denotes" a program that does certain things
17:31:30 <nshepperd_> but that's not really denotational semantics
17:32:01 <nshepperd_> that's operational semantics in disguise
17:32:14 <monochrom> overall the whole article can be repaired by simply s/statement/operational semantics/ and s/expression/denotational semantics/
17:32:32 <ReinH> A denotational semantics is a mapping onto a mathematical domain. An OS is an algorithmic description of hos a process unfolds in individual steps in time. These are different things and comparing them is a category error.
17:32:32 <physixer> ReinH: IDK (I'm still learning).
17:32:40 <monochrom> but nothing says that statements must be operational, or expressions must be denotational
17:32:41 <ReinH> s/hos/how
17:33:29 <ReinH> A good example of how denotational and operational semantics differ is in their treatment of nontermination.
17:33:31 <johnw> "insert k v"'s denotation might be { l' | l' = {(k,v)} ∪ l }, while operationally it might be l' = (k,v) :: l, given a particular representation for lists. The former means only what it says, it doesn't tell you how to compute it (i.e., how to actually handle duplicate keys, how to insert new keys, etc.).  The latter answers all of those questions.
17:33:34 <monochrom> for example researchers have given Pascal-like things denotational semantics, Haskell-like things operational semantics.
17:33:47 <monochrom> and Algol 60 has been given both. how about that?
17:33:57 <physixer> I'm not saying it's a new thing. It's just something occurred to me, and it's very likely it's been established either true or not-true already.
17:34:57 <ReinH> If you're going to claim that two things are equal or equivalent, you must define both things and the notion of comparison being used.
17:35:32 <monochrom> Guest00000: there is no function that satisfy "f _|_ = False, f non-bottom = True"
17:35:33 <icbm> Confrontational semantics
17:35:43 <Guest00000> monochrom: no, just ignore that
17:36:13 <monochrom> OTOH, "f _|_ = _|_, f non-bottom = ()" is easy :)
17:36:49 <ReinH> (I guess my definitions above are partial to small-step operational semantics, but anyway)
17:37:10 <monochrom> small-step is cool too :)
17:37:18 <ReinH> Guest00000: are you asking for a function that detects bottoms and gives a non-bottom result?
17:37:25 <ReinH> That is equivalent so solving the halting problem.
17:37:41 <ReinH> in fact it is exactly a solution to the halting problem
17:38:32 <ReinH> like monochrom said, though, the other option (detecting non-bottoms) is easy.
17:38:51 <Guest00000> i thought about exact real arithmetic, one possible implementation thereof: functions from a range of real numbers to a range of real numbers, implemented as functions, lazily operating on arguments
17:39:25 <monochrom> yeah, that's interval arithmetic, many people have written algorithms for it
17:39:27 <ReinH> monochrom: I'm always amazed at how many people want Haskell to solve the halting problem in a variety of creative guises...
17:39:33 <nshepperd_> Guest00000: you can pass an error to the function, and see if it throws an exception?
17:39:51 <nshepperd_> if it does, that means it evaluates the value at some point
17:40:08 <Guest00000> where ranges are modeled as partially-defined lists of bits
17:40:25 <monochrom> Haskell looks like math. naturally some people really believe it's really math --- computer algebra system and automatic theorem prover
17:41:12 <monochrom> to the point for example expecting: filter (< 0) [1..] ≠ bottom
17:42:23 <johnw> the fact that a given denotational semantics can have multiple implementations, operationally, is a thing to be happy about: it means there's room for different optimizations depending on what you need, without having to redo your design each time
17:42:24 <Guest00000> so, i thought, is it possible to get a limit of a function when its argument goes to infinity?
17:42:35 <monochrom> nshepperd_: to detect an exception, you need IO. to do it in a pure function, you're talking about unsafePerformIO
17:42:39 <mzabani> howdy, folks. I'm a bit of a noob with Haskell and Persistent, and I'm trying to get my database model in a separate file, but I can't seem to export all the type constructors it creates via template haskell. Someone knows what's wrong?
17:42:51 <Guest00000> if it doesn't have it, our task diverges
17:43:11 <johnw> mzabani: if you don't use an explicit export list at all, doesn't it export them all?
17:43:21 <ReinH> waiting for a value to reach infinity already diverges
17:43:45 <monochrom> neither interval arithmetic nor on-demand-sequence-of-bits arithmetic can escape the curse of the uncomputable.
17:43:58 <monochrom> tautologically, a computer can only do the computable reals.
17:44:00 <lethjakman> monochrom: What exactly are you doing?
17:44:09 <lethjakman> Err. wrong one sorry. 
17:44:13 <Guest00000> oh
17:44:14 <lethjakman> mzabani: You
17:44:16 <lethjakman> What are you doing?
17:44:21 <lethjakman> To export them?
17:44:24 <monochrom> I am despairing people. that's what I am doing.
17:44:29 <Guest00000> i know a solution
17:44:32 <lethjakman> monochrom: good work. 
17:44:36 <ReinH> Guest00000: that seems unlikely.
17:44:38 <lethjakman> Guest00000: Go collect your prize. 
17:44:56 <mzabani> I'm trying to export (EntityName(..))
17:45:00 <lethjakman> And this is the halting problem was solved. In a simple conversation on IRC. 
17:45:01 <monochrom> the logical truth always despairs the dreamers
17:45:04 <lethjakman> It just makes sense. 
17:45:11 <mzabani> I'm not familiar with GADTs, so I don't really know if this would work at all
17:45:12 <Guest00000> no.......
17:45:18 <Guest00000> i mean, the solution to my problem
17:45:23 <ReinH> Guest00000: so do I
17:45:41 <lethjakman> Guest00000: Sorry, I'm just trying to be funny. 
17:45:47 <ReinH> if your problem is "get a limit of a function when its argument goes to infinity", that is.
17:46:57 <nshepperd_> sometimes with floating point you can just plug in Infinity and get the limit
17:47:18 <ReinH> nshepperd_: ...
17:47:25 <mzabani> johnw: I did what you said, and the error changed
17:47:30 <Guest00000> the reals need to be modeled as (list of bits in exponent, list of bits in mantissa)
17:47:41 <nshepperd_> > let inf = 1/0 in 1 / inf :: Double
17:47:43 <lambdabot>  0.0
17:47:43 <Guest00000> uh..
17:47:44 <mzabani> (this is a good thing). Why didn't the explicit exports work?
17:47:48 <monochrom> Guest00000: http://hackage.haskell.org/package/numbers has a CReal type for on-demand sequence of digits, except I forgot whether it's base-2 or base-10 or what
17:48:03 <ReinH> Guest00000: no representation of the reals will allow you to solve this problem.
17:48:19 <Guest00000> (sign, list of bits in exponent, list of bits in mantissa)
17:48:19 <johnw> we just need to use the Unreals
17:48:19 <monochrom> however like I said it is still under the computability limitation. (everything is.)
17:48:37 <lethjakman> mzabani: Can you show your code? Perhaps you did and I missed it...
17:48:39 <dresuer> HI ALL AGAIN
17:48:42 <lethjakman> And perhaps the error. 
17:48:42 <monochrom> for example it can't do perfect equality. (I think it fakes equality by look at just 40 digits)
17:48:43 <dresuer> ;)
17:48:46 <Guest00000> then, to get a limit, pass the function (sign, repeat undefined, undefined)
17:48:56 <ReinH> Guest00000: what?
17:49:00 <Guest00000> see? the number is too big
17:49:01 <zachk> hi dresuer 
17:49:01 <nshepperd_> > let inf = 1/0 in sin inf - sin inf :: Double -- of course, it doesn't work everywhere
17:49:03 <lambdabot>  NaN
17:49:07 <ReinH> What does that have to do with getting a limit?
17:49:18 <monochrom> I don't think you need an infinite list for your exponent...
17:49:59 <mzabani> lethjakman: http://lpaste.net/147976
17:50:05 <monochrom> if you say, you have a cunning use of that, then all you're doing is another trade-off point. you will gain some operation and lose some other.
17:51:59 <Guest00000> ReinH: to understand how big the exponent is, the function needs to evaluate the length of the list first. but it is infinite. that means that at some point the function should give up and return the limit (if it isn't a bad-behaving function which, despite having a limit, is strict in spine of exponent bits list)
17:52:35 <monochrom> the first sentence is false. unless you're doing p-adic numbers.
17:52:46 <ReinH> What would cause the function to "give up"?
17:53:40 <Guest00000> ReinH: when, for a given position in the list of result bits, it doesn't matter anymore
17:53:45 <monochrom> at this point, I'm going to join someone else in asking: what is zachk smoking? I want some of that too.
17:53:48 <nshepperd_> Guest00000: um, why not just add an Infinity data constructor, and have your function return the limit when passed Infinity
17:54:05 <monochrom> because, in comparison, zachk is already the most sane
17:54:05 <nshepperd_> detecting when a list is "too long" is more effort than worth here
17:55:16 <Guest00000> nshepperd_: that's good too... (i haven't slept for ages)
17:55:17 <ReinH> Guest00000: if you're just waiting for your function to converge to some precision, why not just do that?
17:55:36 <ReinH> Why bother with the infinite list?
17:56:18 <icbm> I'm glad there was the discussion about mapM_ earlier, becuause I just had to use it for the first time.
17:56:19 <ReinH> repeat undefined is the same as the natural numbers if you only care about the spine, so why not just... count the iterations?
17:56:20 <monochrom> Guest00000: have you coded up your idea and tested it?
17:56:38 <Guest00000> monochrom: nah
17:57:05 <monochrom> essay writing is pretty moot
17:57:17 <johnw> physixer: this page has some nice clarifications: http://cstheory.stackexchange.com/questions/3577/what-constitutes-denotational-semantics
17:58:07 <ReinH> monochrom: if I understand correctly, this is a rube goldberg version of newton's method.
17:58:48 <monochrom> are you sure it's newton's method not bisection method? :)
17:58:58 <ReinH> monochrom: ok, it's some generalization of newton's method :p
17:59:10 <ReinH> anyway, you don't need an infinite list of bottoms
17:59:24 <ReinH> you can just use an iteration counter if you want that behavior
17:59:31 <ReinH> otherwise just wait for it to converge
17:59:37 <monochrom> yeah, you just need a bottomless list :)
17:59:55 <ReinH> monochrom: I will remember this for our future conversations. :)
18:00:40 <ReinH> "You don't need (a,a), you need a function Bool -> a!"
18:01:21 <monochrom> hrm, Bool->a has a few more pathological values than (a,a)
18:01:32 <ReinH> I am morally correct.
18:01:40 <monochrom> err, maybe not. this is tricky
18:01:44 <ReinH> monochrom: :p
18:02:32 <monochrom> ah, saved by wacky Haskell seq semantics. bottom :: Bool->a is a little bit different from (\_ -> bottom)
18:02:40 <ReinH> monochrom: or something something automatic differentiation
18:03:22 <zachk> did I mischannel? -_- 
18:04:25 <monochrom> for a while, yes. normally, this channel is not where you try to solve uncomputable problems programmatically :)
18:04:48 <Ankhers> I'm getting `No instance for (Ord (Key Agency))' when trying to create an instance of PersistEntity for Agency. Agency has an Ord instance. What exactly does this mean?
18:05:21 <Cale> It means that Key Agency doesn't have an Ord instance
18:05:23 <ReinH> It means that Key Agency is not an instance of Ord.
18:05:30 <ReinH> Damn it.
18:05:32 <monochrom> "Key Agency" ≠ "Agency"
18:05:36 <zachk> what about type Key Agency? 
18:05:51 <Ankhers> Oh. That is simple enough.
18:05:59 <zachk> :)
18:06:18 <Ankhers> I guess I just assumed Key came with an Ord instance. Which doesn't really make sense when I think about it.
18:06:20 <Ankhers> Thanks!
18:07:03 <Guest00000> so. if, in a given real representation, it is possible to construct an infinite natural and use it as exponent, it's possible to construct real infinity then, and it will behave as limit. sometimes. without any stinkin addition constructors
18:07:16 <monochrom> Cale: I have just coined the great saying "welcome to #haskell, where we stereo type everything" :)
18:07:26 <Cale> heh
18:07:29 <ReinH> @quote fugue
18:07:29 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
18:07:35 <ReinH> You already coined that one :p
18:07:46 <monochrom> yeah but it has been years
18:07:49 <ReinH> these are just variations on a theme
18:08:17 <monochrom> stereotyping is more fun
18:08:27 <Guest00000> good night.
18:10:03 <monochrom> Cale: I coined it when the channel has unlocked the achievement: two instances of "@let data Foo = Foo { _i :: Int, _a :: String }" to lambdabot at the same time
18:10:29 <ReinH> monochrom: to be fair, mine was slightly different in an important way
18:10:41 <monochrom> yeah, one version added "deriving Show"
18:10:52 <ReinH> I figured someone might want to actually use it.
18:10:56 <monochrom> but let me butcher the story so it sounds greater
18:11:01 <ReinH> monochrom: :D ok fine
18:11:07 <ReinH> anything in service of the story
18:11:28 <StoneToad> I think my stomach hurts
18:11:44 <StoneToad> or is it my head from pounding the wall
18:11:49 <StoneToad> stereotyping is horrible D:
18:11:53 <StoneToad> in a hillarious way
18:15:59 <dhz_> stereotyping is no laughing matter....unless you are stereotyping a clown?
18:36:59 <medfly> hello #haskell, I'm trying to patch a cabal package to work, it seemed to cabal install fine, but now the next package is using Distribution.Simple.LocalBuildInfo.installedPkgs and it is not finding this package
18:37:03 <medfly> any ideas
18:37:24 <medfly> I've used cabal install .
19:00:03 <medfly> is there maybe some more verbose way to cabal install things?
19:01:23 <bitemyapp> medfly: use a sandbox, add the patched variant to the sandbox as a source?
19:01:31 <bitemyapp> medfly: or use Stack to do the same thing?
19:01:32 <geekosaur> I think the problem there is it's looking for something in Cabal-the-library and the API has changed so it's not there
19:01:40 <medfly> I'm using a sandbox already
19:01:45 <bitemyapp> geekosaur: I was worried it was a pkg-db thing
19:01:51 <bitemyapp> you might be right
19:02:01 <medfly> I'm not too sure if this is even the problem now
19:04:15 <medfly> ah this might have been the problem, I was using a second terminal and it was not using the sandbox there, I think 
19:04:25 <medfly> or something 
19:09:20 <medfly> looks good, thanks guys, now back to fixing broken linuxisms )
19:21:08 <ic2000> is haskell worth learning
19:21:56 <medfly> yes
19:22:21 <dhz_> absolutely
19:22:51 <ic2000> medfly, may i ask why
19:22:52 <medfly> I don't use it for anything btu I still value the experience
19:22:56 <medfly> it's very elegant
19:23:10 <ic2000> the only thing that comes to my head is haskell being purely functional
19:23:33 <ic2000> but i'm kind of suprised that this channel has around 2x the population of #c++
19:23:40 <ic2000> medfly, could u explain further
19:24:23 <medfly> I feel like it helps me abstract away things when working on other programming languages, instead of getting bogged down by silly things like "it's a for loop" then thinking about the boundaries, I think I am operating with composition and mapping on array, it's nice stuff
19:24:27 <medfly> )
19:25:02 <ic2000> medfly, someone told me haskell is best for creating a tui text editorm is he correct
19:25:18 <dhz_> haskell is best for most things :)
19:27:36 <ic2000> but how long it take 2 learn
19:28:53 <sshbio> ic2000 If you have not seen yet, the haskell.org have a fancy interactive tutorial.  I just finished it.
19:29:06 <sshbio> I have seen that git-annex is built with haskell -> https://github.com/joeyh/git-annex :)
19:29:24 <ic2000> sshbio, but how long
19:29:59 <Adeon> I use haskell because I feel it's quicker and easier to write complicated software in it that works (mostly) correctly
19:30:11 <Adeon> I write heavy data processing jobs with haskell and C
19:30:19 <Adeon> your mileage may vary depending on your application area
19:30:27 <sshbio> ic2000: The tutorial? It does not permit to know how to program in haskell, but it took me 5 miuntes.
19:30:34 <ReinH> ic2000: years
19:30:37 <Adeon> I don't think haskell of today is very good at numerical computation where performance really matters
19:30:40 <sshbio> ^
19:30:49 <ic2000> ReinH, then i aint got time to learn haskell ;l
19:31:06 <medfly> hey guys, is wxgtk at all useful? a friend asked me to fix it
19:31:12 <ReinH> ic2000: ok.
19:31:28 <medfly> and it's annoying
19:32:00 <AfC> ic2000: it will take you a lot of hard work to learn. There's a huge conceptual learning curve to climb, unless you've already done functional programming in another programming language. How _long_ it takes depends on how much effort you're willing to put in. The language rewards that effort, without question.
19:32:14 <dhz_> that's not bad though.. take C++ for example. you can't learn it completely in one lifetime
19:32:36 <Adeon> I started with erlang and hopped from there to haskell
19:32:41 <ic2000> AfC, i'm guessing C doesn't class as functional lol
19:32:49 <Adeon> now I don't really write erlang except when I have to hack on a project that was already written in erlang
19:32:56 <medfly> ic2000: functional is not in the normal language sense
19:33:33 <AfC> ic2000: no. But don't worry about that. If you know C then you know something about systems and that's a great start. You'll probably enjoy Haskell.
19:33:43 <medfly> ic2000: rather functional programming
19:34:53 <ic2000> AfC, oh i don't know C. i have experience with it but not enough to claim i know C
19:39:15 <dhz_> ic2000 what made you pick haskell as a potential language to learn?
19:40:23 <ic2000> dhz_, friends going on about how functional programming in haskell is amazing
19:40:53 <ic2000> i probably class (pun unintended) myself as an OO guy
19:42:20 <mgsloan> If you really like C++ templates, but wish they were cleaner and less hacky, you'll love haskell's polymorphism.  That was part of what really got me into it
19:42:50 <cdepillabout> ic2000: At the very least, Haskell will open your eyes to some new ways to think about programming.
19:42:59 <mgsloan> A lot of the stuff that leads to absolutely insane C++ metaprogramming and error messages can be done quite elegantly
19:43:38 <medfly> hahaha class yourself as an OO guy
19:50:11 <magr> <ic2000>, it takes more 10yrs+ to become a good programmer
19:50:27 <magr> not just 1 year
19:50:30 <magr> http://norvig.com/21-days.html
19:50:38 <ic2000> magr, sure. but when u gotta make a programming portfolio withtin 3 months showing off why i should be hired i don't have 10 fucking year
19:50:39 <ic2000> s
19:51:14 <magr> why 3 months?
19:51:35 <Bruuuuno> nah, all it takes is 21 days
19:51:36 <Bruuuuno> http://funnyjunk.com/funny_pictures/3182045/Learn+c+in+21+days/
19:51:36 <ic2000> magr, that's when i pick an apprenticeship
19:51:36 <magr> well, I'm also learning Haskell. 
19:51:38 <ic2000> with my portfolio
19:51:45 <medfly> if you want to get hired your best chance is to try to spend those 3 months programming as much as possible.
19:53:37 <magr> Bruuuuno, nice tutorial :)
19:53:57 <ic2000> medfly, and i'm yet to learn c++ in less than 3 months -_-
19:54:15 <dhz_> you never learn C++
19:54:23 <medfly> circlejerk less program more
19:54:42 <magr> one just get confortable with C++
19:55:17 * hackagebot c-storable-deriving 0.1.3 - Generate C-like storable instances from datatypes  https://hackage.haskell.org/package/c-storable-deriving-0.1.3 (MatthewMaurer)
19:55:19 <magr> or you end up hating it, like Linus Torlvalds 
19:56:01 <medfly> Trollvalds
19:56:27 <magr> ops :grin:
19:57:15 <josephle> arguably, c++ is slightly easier than before thanks to c++11 and its slimming down of idiomatic c++
19:57:31 <josephle> but probably still better done in haskell
20:02:09 <mgsloan> I know someone on the C++ comittee.  Even they don't know all of C++, there are different people that specialize in knowing exactly how a different subpart of the language / spec works
20:02:36 <mgsloan> And then they all try to crosscheck eachother's spec modifications, gets reaal hairy
20:03:20 <mauke> do you think there's a single person who understands how exactly name lookup works in C++?
20:03:33 <johnw> some of us do
20:03:46 <mgsloan> Yes, I saw a presentation at the Haskell symposium where someone created a name resolution DSL in order to explain how name lookup works in C++
20:03:52 <mgsloan> the resulting expression was terrifying
20:04:14 <mauke> ooh
20:04:23 <johnw> but only because I had to implement it, in its gory entirety, within a compiler; I agree that it's not anything the average C++ user would ever know all the details of, nor want or need to know in most cases. But I bet several of the Boost developers know all of the rules as well.
20:04:27 <mgsloan> I think it was the haskell symposium anyway
20:05:04 <johnw> mgsloan: do you have a link to that DSL?
20:05:16 <johnw> I know another committee member who would be most interested in it
20:05:22 <ic2000> is 10 days enough to have basic knowledge with haskell
20:05:31 <johnw> ic2000: depending on how "basic" is basic, sure
20:05:32 <ic2000> i have previous background experience
20:05:40 <mauke> ic2000: in what?
20:05:46 <ic2000> johnw, know enough to create, let's say and irc bot
20:06:23 <ic2000> mauke, python, C, used to have c++ experience but i've probs forgot now and emcascript like langs
20:06:59 <mauke> so nothing with a real type system or algebraic types
20:07:03 <mauke> let alone laziness
20:08:35 <mauke> johnw: is it something you can keep in your head all at once, or do you have to swap parts in/out?
20:08:38 <magr> hahaha, laziness alone is killing me. Few days ago I was all in trying to understand the example shown in the home page
20:08:53 <magr> primes = ~~~
20:09:07 <mgsloan> johnw: Found it!  Turns out it was the workshop on generic programming, makes much more sense than being in the Haskell symposium!  https://www.youtube.com/watch?v=BHN7DGJa6ZM
20:09:30 <parsnip> johnw: would it be wrong to call some elisp from haskell? 
20:09:38 <ic2000> mauke, ?
20:09:42 <ic2000> they're sik languages
20:09:49 <josephle> mgsloan: move semantics is bad enough, and that's a commonly used thing
20:10:15 <mauke> did you mean: sikh
20:10:53 <johnw> mauke: it's not as bad as that; the worst parts are (A) the two-phase name lookup rules for template definition vs. expansion, and (B) the "Koenig lookup" rule for identifiers in unimported namespaces related to the types of function arguments (in order to find << without having to qualify it with std::)
20:11:51 <johnw> ic2000: to create an IRC bot after just 10 days? you'd need really appropriate background, but I'm not going to say it's impossible; I don't know you yet
20:11:59 <drewbert> I have a method with a signature like "fn1 :: (MyClass mycl, MonadIO m) => String -> m (MyOtherThing mycl)"  I am returning a type that is an instance of mycl (let's call it MyInstance) wrapped in a MyOtherThing of m. I am getting an error of "Expected type m (MyOtherThing mycl).  Actual type: m (MyOtherThing MyInstance)"
20:12:19 <johnw> mgsloan: thanks!
20:12:24 <kogan> it would be easier to just use perl
20:12:27 <johnw> parsnip: why would that ever be wrong?? :)
20:12:39 <ic2000> johnw, well i just leasrnt how irc and sockets work yesterday and made this https://bpaste.net/show/b2f68f018882 so? maybe haskell is similar?
20:13:12 <johnw> ic2000: yeah, not too far off, I think you can do it
20:13:29 <ic2000>  johnw thanks
20:13:59 <mauke_> drewbert: with that signature, the caller gets to choose mycl
20:14:08 <johnw> ic2000: I recommend just using Network.Socket initially, rather than anything fancy
20:14:46 <ic2000> johnw, tbh after this i don't intend to do anything much with sockets again but it was just an example
20:14:49 <drewbert> mauke_: ahhh, that's right, crap.
20:14:50 <johnw> mauke: as far as the whole standard goes, I know experts on the committee who've told me they don't even try to understand every chapter, but just the areas they claim expertise in. That's when I really got scared.
20:15:05 <ic2000> johnw, unless u think haskell is better for making an irc bot
20:15:08 <ic2000> also forgive me ignorance
20:15:13 <ic2000> is haskellc compiled
20:15:20 <ic2000> *haskell
20:15:20 <johnw> ic2000: I think Haskell is better for just about everything, except maybe game programming
20:15:34 <mauke_> ic2000: usually, yes. but it's also interpreted
20:15:42 <kogan> haskell would be bad for web programming
20:15:49 <medfly> yes
20:15:54 <mauke_> kogan: hah. tell that to the web frameworks
20:15:59 <ic2000> mauke_, compared to the speed of C how fast is it
20:16:02 <mgsloan> kogan: That's crazy talk
20:16:13 <medfly> pandoc so painful when u are not using the obvious trivial case
20:16:15 <mauke_> ic2000: it's about the speed of calculus
20:16:24 <ic2000> mauke_, sorry?
20:16:38 <mauke_> and twice as fast as XML
20:16:41 <mgsloan> Unless by the "would" you mean, "except for the fact that there are awesome web libraries / frameworks"
20:17:09 <drewbert> mauke_: assuming there's no generic means of constructing mycl, I have to refactor the entire call chain that uses the generic declaration?
20:17:46 <pavonia> kogan: Why would it be bad for web progamming?
20:17:52 <ic2000> mauke, no idea how fast qml is
20:17:56 <mgsloan> johnw: Welcome!  There'd be a fantastic irony in a Haskell DSL aiding the C++ committee's standardization effort
20:18:02 <johnw> ic2000: it can approach the speed of C, but sometimes that takes skill to achieve
20:18:05 <mauke> johnw: doesn't koenig lookup introduce interesting ambiguities? I'm thinking of '{ A(B); }' where B is imported from some namespace X, X::A exists, and A is also a type in the current scope
20:18:06 <wowdog_> can anyone explain whether the two definition are the same?   return::Monad m=>a -> ma     return:Monad m=> m a -> m a? 
20:18:27 <ic2000> johnw, i mean on average
20:18:39 <josephle> wowdog_, those definitions should not be the same
20:18:41 <johnw> mauke: why, sure it does; then you engage candidate selection rules, including such things as SFINAE
20:19:05 <dhz_> getting ready for new year.. http://s28.postimg.org/cz1qy35vx/image.jpg
20:19:09 <josephle> assuming "ma" and the single ":" are types
20:19:12 <josephle> *typos
20:19:34 <wowdog_> sorry, it is typo, 
20:19:43 <kogan> I've used common lisp for frameworks and it was not very good
20:19:55 <mauke> johnw: then there's namespaces, nested namespaces, "using" in various forms, scope tunneling in methods, inheritance, ... :-(
20:20:00 <kogan> as well as haskell
20:20:11 <josephle> wowdog_: the simplest way to read those type signatures is that the first one takes in an 'a' and wraps it with 'm' to make an 'm a'
20:20:11 <johnw> mauke: I'm distant enough now from C++ to not know if your example is an error or not. So I have indeed swapped it out for Haskel.
20:20:14 <wowdog_> return::Monad m => a -> m a      and  return::Monad m => m a -> m a
20:20:37 <josephle> wowdog_: the second one already has a wrapped 'm a' and returns a wrapped 'm a'
20:21:33 <josephle> so those type signatures aren't the same
20:21:33 <wowdog_> but we know the first 'a' is  type m?
20:22:01 <pavonia> It's not
20:22:10 <mauke> wowdog_: a is a type. it doesn't have a type
20:22:16 <wowdog_> so a can be any type?
20:22:27 <mauke> yes
20:23:14 <kogan> templates and macros
20:23:32 <ic2000> haskell has templates and macros?
20:23:36 <johnw> the way Haskell does generic functions (functions typed over any 'a') is part of its beauty
20:23:47 <johnw> ic2000: it has them both, although we don't use them all that often
20:24:01 <mauke> I don't think haskell has templates
20:24:13 <ic2000> johnw, is there a lot of macro abuse in haskell like there is in C lol
20:24:14 <wowdog_> is the two are 'a' are different or same?
20:24:28 <wowdog_> is the two 'a' are the same or different?
20:24:31 <mauke> wowdog_: same
20:24:53 <lispy> ic2000: You can use the C pre-processor with Haskell but people use it sparingly. Typically to deal with version differences in the compiler.
20:24:54 <johnw> mauke: in the C++ sense, certainly not; in the "splice this code into a boilerplate", we do
20:25:10 <mauke> I'd call that lisp-style macros :-)
20:25:12 <johnw> ic2000: no, there is typically not
20:25:14 <wowdog_> so if I pass string:   return "dog", the output is m "dog"
20:25:16 <johnw> mauke: fair enough :)
20:25:29 <mauke> wowdog_: no, it has type m String
20:25:32 <mauke> for some m
20:25:34 <johnw> we have CPP macros, and Lisp Style macros
20:25:52 <ic2000> alright then, might aswell start learning haskell. is the websites interactive tutorial a good place to start
20:25:53 <johnw> but since we have laziness and polymorphism, we often need neither one
20:26:01 <pavonia> johnw: What are lisp style macros?
20:26:03 <kogan> 2017 is going to improve c++
20:26:12 <johnw> pavonia: the template-haskell based boilerplate expansion mentioned above
20:26:31 <mauke> pavonia: code transforming code (in the form of ASTs)
20:26:47 <johnw> i.e., you give me code, and I'll tell the compiler to "see" some expanded version of that code
20:26:58 <magr> CPP vs Lisp Style macros is like comparing a search&replace with regular expressions
20:27:07 <magr> hahaah
20:27:14 <johnw> our CPP macros don't support token pasting though, do they?
20:27:30 <mauke> cpp is vastly more restricted in that it works on sequences of tokens, not trees, and it only supports a very basic "language"
20:27:34 <mauke> not full blown C
20:27:46 <wowdog_> anyone how to use multiple line in Predude console?
20:27:57 <kogan> c++can do almost anything
20:28:19 <mgsloan> johnw: It should, but not on OSX :( https://github.com/fpco/conduit-combinators/commit/2088b625b81d0c23ec2dfdf91e67990b21865348#diff-e4dae144258f54af10f09c7868712804L11
20:29:02 <mauke> hah, "sub-standard CPP"
20:29:03 <zaquest> wowdog_, :{ :} or :set +m
20:29:11 <mauke> sounds more like they have a standard preprocessor
20:29:19 <mgsloan> Haha perhaps so
20:29:25 <pavonia> johnw, mauke: I'm not sure if you mean the same thing, i.e. generating code at compile time vs. transforming an AST at runtime
20:29:37 <mauke> pavonia: there's no AST at runtime
20:29:44 <magr> zaquest, :o
20:30:32 <kogan> c++ is still better than java
20:31:54 <pavonia> mauke: Ah sorry, I confused AST and ADT
20:32:02 <ic2000> what does haskell do better than python and python do better than haskell (be honest :))
20:32:21 <johnw> pavonia: I recently confused Abstract Data Type and Algebraic Data Type. Those pesky acronyms.
20:32:21 <Bruuuuno> python is simpler to learn
20:32:50 <CoconutCrab> small scripts for sysadmin (log processing etc...)
20:33:01 <dhz_> python is better at making broken programs faster
20:33:18 <kogan> Why is Java so popular
20:33:25 <mauke> ic2000: haskell has a better type system (or simply a type system in the first place). it's generally faster.
20:33:26 <ic2000> dhz_, nice disadvantage disguised as an advantage lol
20:33:41 <magr> kogan, Marketing
20:33:51 <johnw> ic2000: python will get you working code, today, without much thought if you already know any other programming language. Haskell requires you to change the way you think, sometimes in rather difficult ways, and only really pays off once you begin to examine problems in that manner.
20:34:25 <mauke> ic2000: I know nothing that python does better than haskell
20:34:43 <ic2000> something tells me haskell is gonna be frustrating to learn
20:34:45 <johnw> I used to use Python for a whole bunch of things. Now I use it for nothing at all. That should say something.
20:35:03 <johnw> ic2000: get ready to love that frustration, seriously, it's the best way to proceed
20:35:26 <magr> I actually love my actual frustration
20:36:15 <wowdog_> what is wrong with my function?   fun::(Monad m) => m a -> m a   define:   fun Nothing = Nothing
20:36:33 <johnw> I know now that when I start getting frustrated, it means good realizations are soon to come
20:36:37 <mauke> wowdog_: it claims to work with any monad, but is only defined for Maybe
20:36:45 <kadoban> wowdog_: The type is too general, or the implementation is too specific.
20:36:59 <ic2000> where to start
20:37:06 <magr> sometimes it makes you pull your hair, coming from an imperative world is the worst 
20:37:23 <johnw> ic2000: http://learnyouahaskell.com/ or http://haskellbook.com/
20:37:38 <kadoban> ic2000: http://haskellbook.com/ is probably what I'd recommend the most. https://github.com/bitemyapp/learnhaskell if you don't want to buy that.
20:37:38 <tnks> I didn't even know that tutorial was there.
20:37:43 <johnw> I haven't read the latter, and although I enjoyed the former, not everyone does; it depends on your temperment and background
20:37:48 <tnks> I just went through it. . . kind of cute.
20:38:10 <ic2000> perfect, more books to read lol -_-
20:39:29 <mgsloan> If you'd rather a more interactive approach, https://tryhaskell.org/ is a good taste of haskell
20:40:31 <tnks> mgsloan: oh, that's the same exact tutorial on the main haskell.org site now.
20:40:53 <tnks> it really just barely scratches the surface, but it's good for a taste.
20:40:57 <mgsloan> Oh, right!  Probably because Chris designed the haskell.org site
20:41:00 <mgsloan> :)
20:41:55 <tnks> some parts of Haskell are actually easier to understand. . . I think the toughest part is when you try to use real libraries, and get thrown into some fancy GHC extensions.
20:42:28 <johnw> "I fought Yesod, and Yesod won."
20:44:47 <ic2000> WHAT... haskell is 1.1gig?
20:44:50 <ic2000> bruh
20:45:07 <tnks> ic2000: are you starting with Stack?
20:45:12 <Adeon> no I think ghc is around ~100 meg ballpark
20:45:17 <tnks> I really recommend going that route
20:45:36 <ic2000> tnks, what is stack
20:46:03 <tnks> ic2000: http://docs.haskellstack.org/en/stable/README.html
20:46:06 <pavolzetor> teapot :), http://klacansky.com/img/teapot.exr
20:46:23 <Adeon> it's a program that can install ghc for you, compile your package and install its dependencies and a bunch of other things
20:46:37 <ic2000> tnks, i'm just following the tutorial
20:46:39 <Adeon> it's rather new so there aren't many resources on the internet that talk about it
20:46:56 <pavolzetor> finally got it working (had bug on scaling u, v coordinates)
20:47:04 <tnks> ic2000: the tutorial has you install GHC?  I thought it was just online and short.
20:47:15 <pavolzetor> also removed ST monad and switched to Vector + map :)
20:48:22 <pavolzetor> the fun part was when I outputted 256 in openexr format as float, all white; if you use it in future anything greater than 1 is bright, needs gamma correction
20:49:17 <pavolzetor> correct link, http://sci.utah.edu/~klacansky/img/teapot.exr
20:51:23 <pavolzetor> thanks all who helped, I am glad I did not switch to rust or c
20:52:13 <ic2000> why does "5 * -3" make ghc yell?
20:53:00 <kadoban> ic2000: - is funky in haskell unfortunately.    5 * (-3) will work
20:53:25 <pavolzetor> (-3)
20:53:25 <ic2000> kadoban, funky?
20:54:10 <Bruuuuno> -3 * 5
20:54:19 <wedens> how can I share non-public libraries? local hackage server?
20:55:02 <kadoban> wedens: However you want. Throw them in git repos maybe?
20:55:18 <wedens> kadoban: and then what?
20:55:47 <kadoban> wedens: Share them with whoever you want?
20:55:49 <lispy> wedens: you can list multiple hackage servers in your global cabal config
20:55:53 <wedens> kadoban: how should I specify dependency on a library in git repo?
20:56:13 <lispy> wedens: if you use sandboxes you can use the add-source command to reference them, even in the local filesystem
20:56:13 <ic2000> i'm guessing 1 and 0 aren't valid bools in haskell  ;'(
20:56:20 <kadoban> wedens: With stack
20:56:35 <lispy> ic2000: correct. You want True and False
20:56:44 <dmj`> ic2000: thankfully, yes
20:56:51 <kadoban> wedens: It has built-in ability to do that with extra-deps. I can probably track it down in the docs if you can't find it.
20:57:03 <ic2000> lispy, well in knew they asked but what's wrong with good ol' bits
20:57:20 <pavolzetor> what are default optimization flags in stack?
20:57:32 <pavolzetor> should I use other to get better perf?
20:57:35 <wedens> kadoban: ok. thanks
20:57:50 <Bruuuuno> ic2000: you could write a Boolean typeclass with your own version of if, but don't do that ;)
20:58:16 <lispy> ic2000: you can import Data.Bits if you want bits
20:59:34 <dmj`> ic2000: you can xor Ints
21:00:33 <chrisbarrett> hey all. I have a recursive data type. I want to define a mapping function that applies a transformation only to a particular constructor. Question: what are nice ways to do this, besides hand-written pattern matching?
21:00:33 <dmj`> > (1 :: Int) `xor` (2 :: Int)
21:00:34 <lambdabot>  3
21:00:43 <ic2000> woah, woah what is this /= operator better be equal divide operator and not the != operator 
21:01:12 <johnw> it's "not equal"
21:01:21 <johnw> we told you to be prepared :)
21:01:38 <kadoban> ic2000: C++'s -= += whatever style operators don't really make any sense in haskell, so yeah it's not-equal-to.
21:02:28 <ic2000> kadoban, ages ago (we're talking about the language B), += used to be =+ because that makes more sense
21:02:39 <ic2000> kadoban, but then u got the problem of, a=-b
21:02:48 <tnks> ic2000: has someone shown you Hoogle?  Stackage's Hoogle?
21:02:53 <ic2000> is a equal to a minus b, or is a equal to minus b
21:02:59 <dmj`> chrisbarrett: what does your type look like
21:03:01 <ic2000> tnks, never eva hard of it
21:03:01 <tnks> ic2000: http://www.stackage.org/lts-3.20/hoogle
21:03:12 <kadoban> ic2000: Heh, yeah.
21:03:26 <chrisbarrett> dmj`: it's the untyped lambda calculus
21:03:54 <chrisbarrett> data Term = Var Idx | Lam Term | App Term Term
21:04:04 <chrisbarrett> where Idx = Int
21:04:08 <pavonia> > let x!=y = product [1..x] == y in 4!=24
21:04:10 <lambdabot>  True
21:04:19 <tnks> ic2000: you can type magical things in there like type signatures that are mostly right, and get back useful things (even not knowing function names)
21:04:42 <ic2000> i swear, these compiler/interpreter errors seem so cancerous. i can barely understand them
21:04:58 <chrisbarrett> I want to define an operation that increments the index on the Var ctor
21:05:25 <kadoban> ic2000: They'll make far more sense later. They're way more contentful than other language's if you know enough basics to figure out what they're saying.
21:05:30 <chrisbarrett> I have vague recollections of uniplate being a thing for this, but I thought I'd see what people are doing here ;
21:05:33 <chrisbarrett> ;)
21:05:36 <ic2000> kadoban, i hope so
21:07:43 <magr> ic2000, 9days 2* hours left to build an irc bot :3 
21:08:19 <ic2000> magr, lol. this is either gonna make me a much better programmer, or fuck up my logic completely lol
21:08:47 <magr> it will do both actually
21:10:11 <Bruuuuno> The other day at my job (c#) I had a "object not initialized" error on a coworker code and I forgot what it was lol
21:10:32 <ic2000> ooh, that's good. looks like there's a char type in haskell
21:11:34 <Bruuuuno> haskell broked me :(
21:11:42 <Xe> yeah it does it
21:11:45 <Xe> that*
21:11:50 <nitrix> It's not quite like CChar though.
21:12:25 <nitrix> I'm going with the assumption you're a C programmer since you wrote it `char` instead of `Char`.
21:15:29 <ic2000> this is making me shake my head as i read lol, this goes against every programming rule i've came across
21:16:13 <ReinH> ic2000: I find that hard to believe.
21:16:40 <nitrix> ic2000: Which part of Char's specification confuses you?
21:16:49 <ic2000> ReinH, "every" was a hyperbole, but yeah it definitely is different
21:17:23 <ic2000> nitrix, not so much confuse, but i do find it very strange
21:18:22 <magr> ic2000, hahah been there. The part that disturbed me the most was the fact of not being able to use loops
21:18:51 <magr> oh my beloved for(i=0; i<MAGIC; i++) {}
21:18:53 <ic2000> magr, WHAT
21:18:58 <ic2000> spoilers
21:19:11 <magr> :grin: ops
21:19:14 <ic2000> what do u use then
21:19:18 <ic2000> recursive functions?
21:19:20 <dhz_> what is strange about haskell's char :?
21:19:21 <ReinH> recursion
21:19:32 <ic2000> hmm, i guess it could be worse
21:19:37 <kadoban> dhz_: That it's not terrible
21:20:04 <magr> ic2000, how?
21:20:28 <ic2000> magr, there could be no for loop equivalent lol
21:20:44 <nitrix> ic2000: Recursion if no other function can take care of it. Most loops in other languages are just to traverse data structures and we already have Traversable and Functors for this.
21:21:24 <nitrix> Besides, there's also utility functions like `unless` that's pretty convenient.
21:21:29 <nitrix> :t unles
21:21:30 <lambdabot>     Not in scope: ‘unles’
21:21:30 <lambdabot>     Perhaps you meant ‘unless’ (imported from Control.Monad.Writer)
21:21:31 <nitrix> :t unless
21:21:33 <lambdabot> Applicative f => Bool -> f () -> f ()
21:22:40 <ReinH> ic2000: you should start with something like https://github.com/bitemyapp/learnhaskell
21:23:02 <ReinH> if you like books, I can recommend http://haskellbook.com and http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643
21:23:07 <ic2000>  i'm using http://learnyouahaskell.com/starting-out
21:23:09 <magr> <interactive>:1:1: Not in scope: ‘unless’
21:23:15 <ReinH> ic2000: I wouldn't recommend lyah
21:23:18 <kadoban> ic2000: LYAH is terrible.
21:23:23 <ic2000> why#
21:23:48 <ReinH> ic2000: we get a lot of people in here who read LYAH and still have no idea how to actually use haskell
21:23:52 <medfly> help. I'm trying to add an include path to a cabal package and it's bringing me mounds of pain
21:24:00 <magr> why? I'm using LYAH actually
21:24:01 <medfly> it's so stupid
21:24:10 <ReinH> It's superficial.
21:24:12 <medfly> all sane build systems have an easy way to add things like this.
21:24:12 <ReinH> It doesn't have any exercises.
21:24:16 <kadoban> ic2000: The most glaring problem is that it has no exercises, so there's no push to practice what you're learning in a useful way, which you can't really do on your own very well, without guidance.
21:24:49 <magr> yes, it doesn't
21:24:53 <ReinH> ic2000: I can especially recommend Thinking Functionally with Haskell. It'll be a real brain bender for you.
21:25:13 <ic2000> i really don't have plans to buy any books
21:25:17 <medfly> I just want this cabal package to use -I<pkg-config --cflags gl>. but it's very hard to convince it to do so. http://lpaste.net/7638138352801153024#line84 
21:25:20 <ic2000> and if i do, it'd be for c++
21:25:32 <medfly> :(
21:25:39 <kadoban> ic2000: The learnhaskell link above is for a free course
21:25:40 <ReinH> ic2000: you should try the lecture notes and exercises the other link recommends then
21:26:20 <medfly> #haskell once again having the billionth discussion on beginner resources
21:26:34 <medfly> meanwhile using the world's worst build system ever
21:26:35 <medfly> pls
21:26:51 <ReinH> medfly: you must not have used many build systems.
21:28:03 <medfly> you are correct gyp is causding me even more pain
21:28:04 <medfly> but so is this
21:28:10 <ic2000>  i'm gonna lie down and read, see you guys later
21:28:12 <ic2000> thanks for the help
21:28:28 <ReinH> medfly: build systems are universally awful.
21:28:34 <ReinH> medfly: know how I know?
21:28:43 <medfly> you used cabal
21:28:44 <medfly> kappa
21:28:53 <ReinH> medfly: build systems are software and software is universally awful
21:29:26 <ggole> Build systems seem to manage to be a bit worse than usual, though
21:29:34 <ggole> Or at least more painful.
21:29:37 <ReinH> well within a standard deviation of awful though
21:29:47 <ReinH> we just use them more than most other software
21:30:31 <tnks> I installed Hoogle with Stack, and now I think the databases aren't under ~/.hoogle anymore.
21:30:37 <tnks> can someone give me a pointer?
21:30:55 <medfly> Haskell is so great it forces you to use a singular operating system and a singular architecture hurr durr and you cannot build the god damned compiler without using 'trusted binary'
21:30:59 <medfly> fuck this
21:31:04 <ggole> I dunno, my text editor and compiler and window manager all seem to be several orders of magnitude less likely to have to be coddled into doing their jobs
21:31:07 <kadoban> tnks: Once you install the executable, it works like usual.
21:31:12 <ReinH> medfly: do you need to take a break?
21:31:31 <medfly> nothing builds outside of fucking linux!!!!!
21:31:35 <ReinH> sure it does
21:31:39 <tnks> kadoban: yeah, it works, but what if I want to tinker with the databases?
21:31:47 <tnks> I can't even tell where it's looking.
21:31:49 <parsnip> i think LYAH is fine, but i read it only for the sake that it had no exercises and i would seek that out in parallel/series
21:32:10 <medfly> I had to write a page full of instructions just on how to install cabal
21:32:21 <kadoban> tnks: I don't particularly know how local hoogle works. But install it via stack is not at all likely to have messed with how it works, is all I mean. So the general advice/docs you can find on it should apply.
21:32:23 <medfly> and it's still only amd64
21:32:30 <ReinH> parsnip: what usually happens is people read LYAH and then get frustrated when they can't write any haskell programs and have to go seek more resources. It would have been better if they had just skipped LYAH and went directly to those resources.
21:32:36 <tnks> also, I'm curious what Stack has done to prepare a binary of Hoogle that's configured differently from the one I used to install with cabal-install.
21:32:43 <ggole_> (But not my irc client.)
21:32:54 <parsnip> ReinH: yeah, i can imagine that would be frustrating if ppl don't understand that
21:33:02 <kadoban> parsnip: You need to know a lot to know what exercises are helpful at what point. It's approximately as hard a problem as writing a book in the first place.
21:33:45 <parsnip> i talked with an old friend a few months ago, and they told me they took a course on swift or something, and they were disappointed that they weren't being taught right, and i just nodded politely. 
21:34:40 <parsnip> uh oh, i'm sharing my opinion in public >.<
21:35:15 <medfly> ReinH: I love editing files just because someone decided the best way to find LD is to with sed
21:35:17 <magr> medfly, may help s lil https://soundcloud.com/flamingosis/snacks-on-snacks-1
21:35:32 <parsnip> i try to appreciate whatever calibre teaching aids exist :)
21:35:51 <joco42> i am experimenting with types, is this possible to make this type check somehow ? https://usercontent.irccloud-cdn.com/file/kCK4gHes/Screen%20Shot%202015-12-29%20at%2007.34.38.png
21:36:25 * Clint squints.
21:36:46 <nitrix> joco42: Don't you have a compiler?
21:36:48 <joco42> type (Level l)=> Pos l = Int
21:36:52 <joco42> yes
21:37:02 <joco42> i mean, pass the type check
21:37:05 <joco42> :)
21:37:18 <joco42> with some magical flag?
21:37:30 <Clint> joco42: what is "class Level l" supposed to mean?
21:37:56 <nitrix> Not really. Compiling already checks for type correctness. Haskell is strongly typed.
21:38:10 <joco42> Clint:  a typeclass
21:38:19 <Clint> that does what
21:38:26 <nitrix> joco42: You have a syntax error on line 6.
21:38:59 <joco42> just used as a phantom type
21:39:07 <ReinH> joco42: it would be easier to help you if you used a pastebin rather than posting screenshots with very small type.
21:39:48 <ReinH> In any event, your syntax for ``type'' is invalid.
21:40:10 <ReinH> So it hasn't even gotten to the type checker yet.
21:41:00 <joco42> i wanna do this just with type alias https://usercontent.irccloud-cdn.com/file/xBwA3zjr/Screen%20Shot%202015-12-29%20at%2007.40.20.png
21:41:04 <joco42> is that possible?
21:41:11 <nitrix> joco42: http://lpaste.net
21:41:14 <ReinH> joco42: use a pastebin
21:41:23 <joco42> ReinH: I increas the type
21:41:29 <ReinH> Use a pastebin
21:42:05 <joco42> i am on a ssh 
21:42:12 <joco42> cannot copy paste
21:42:16 <joco42> in tmux
21:42:18 <nitrix> Obviously.
21:42:26 <medfly> joco42: shift insert
21:42:30 <joco42> hmmm
21:42:51 <joco42> does not work
21:43:04 <joco42> this is what happens if i select https://usercontent.irccloud-cdn.com/file/1m7aJz80/Screen%20Shot%202015-12-29%20at%2007.42.20.png
21:43:25 <nitrix> I'm sorry. We can only provide help about the Haskell language.
21:43:38 <medfly> select, middle mouse click
21:43:40 <nitrix> If you can't use your own environment, you'll need to solve this on your own.
21:43:50 <ReinH> I'm not sure what you're trying to do. I can't figure out what you mean. I just see some nonsense that is causing a syntax error.
21:44:18 <joco42> ReinH:  if I use the same syntax but with data then it compiles
21:44:42 <ReinH> Yes, they have different syntax.
21:44:42 <joco42> this compiles https://usercontent.irccloud-cdn.com/file/xu6ytEsB/Screen%20Shot%202015-12-29%20at%2007.44.04.png
21:44:49 <nitrix> Type constraints in data constructors were deemed a mistake.
21:44:59 <nitrix> Nontheless, `type` works differently.
21:45:25 <joco42> ok
21:45:27 <Clint> if you delete several lines it will probably print "hello"
21:45:29 <ReinH> One is a syntax error. The other is syntactically correct, type checking  nonsense.
21:46:09 <ReinH> So what are you trying to do?
21:46:38 <ReinH> If your code isn't self-explanatory, you should use words instead.
21:46:38 <joco42> so in data (Level l)=> Pos l=Int 
21:46:53 <joco42> ReinH: I wanna constraint the phantom type l
21:47:05 <joco42> to be of type l
21:47:11 <ReinH> what
21:47:14 <ReinH> l is not a type
21:47:26 <joco42> and L1 and L2 is instances of type Level
21:47:29 <nitrix> joco42: l is polymorphic here.
21:47:38 <ReinH> l is a type variable
21:47:51 <ReinH> That doesn't look like a real sentence to me.
21:48:03 <ReinH> Oh.
21:48:05 <ReinH> Level is not a type.
21:48:15 <joco42> this is what i mean https://usercontent.irccloud-cdn.com/file/ZKpjYIXx/Screen%20Shot%202015-12-29%20at%2007.44.53.png
21:48:28 <joco42> this, correction https://usercontent.irccloud-cdn.com/file/rgx31qZI/Screen%20Shot%202015-12-29%20at%2007.47.33.png
21:48:28 <ReinH> that doesn't *mean* anything
21:48:40 <nitrix> This is completely ridiculous.
21:48:42 <joco42> l can only have L1 or L2
21:48:51 <ReinH> This is the code equivalent of word salad
21:48:52 <nitrix> What's L1 and L2?
21:48:53 <joco42> otherwise it does not compile
21:48:55 <ReinH> it doesn't mean anything
21:49:29 <nitrix> (In regards to Level l) ?
21:49:37 <ReinH> You have a data type with a type constructor Position that takes a type variable l with a useless constraint
21:50:09 <ReinH> and a nullary data constructor Int which is has nothing to do with the type Int aside from being spelled the same
21:50:16 <ReinH> It's nonsense.
21:50:19 <nitrix> And L1 and L2 that aren't related whatsoever with Level l and trying to make a constraint on those.
21:50:39 <ReinH> Can you just explain in english what you are trying to do?
21:50:51 <nitrix> ReinH: He's rather use screenshots :)
21:50:54 <ReinH> apparently
21:51:16 <joco42> ok, i rewrote it with datakinds https://usercontent.irccloud-cdn.com/file/ChFdnENS/Screen%20Shot%202015-12-29%20at%2007.50.35.png
21:51:35 <ReinH> I am not interested in reading any more word salad in a screenshot until you explain what you are trying to do
21:51:39 <joco42> so basically i just wanna write line 10 without datadinds
21:51:43 <joco42> datakinds
21:51:52 <ReinH> This makes even less sense.
21:51:55 <Clint> add some ascii art
21:51:57 <ReinH> Just explain what you are trying to do.
21:52:04 <ReinH> Without pointing at code I can't comprehend
21:52:04 <joco42> hmmm
21:52:07 <joco42> ok
21:52:27 <joco42> lemme try to make this make more sense
21:52:35 <joco42> lemme think
21:52:40 <ReinH> That would probably help.
21:52:46 <joco42> :)
21:52:52 <ReinH> It usually does.
21:52:53 <Clint> be sure to use more screenshots
21:53:16 <nitrix> And to warn us that you're thinkering.
21:56:02 <joco42> ok, this might make more sense https://usercontent.irccloud-cdn.com/file/6f7IjqOx/Screen%20Shot%202015-12-29%20at%2007.55.16.png
21:56:19 <joco42> this compiles
21:56:39 <nitrix> I once made a psychological profile of irccloud users. Apparently I was slightly off about them using Compiz-Fusion, but everything else seems to fit the bill.
21:57:24 <nitrix> Moving to #haskell-blah. I'm not entertained anymore.
21:57:24 <Clint> i can no longer handle the internet
21:59:31 <joco42> and even this compiles, that is almost cool https://usercontent.irccloud-cdn.com/file/V4eQRBne/Screen%20Shot%202015-12-29%20at%2007.58.45.png
21:59:32 <ReinH> What is the actual point of doing this at the type level? Why not data Distance = Mile | Kilometer and data Position = Position Distance Int?
21:59:41 <ReinH> I see even less reason to attempt this at the *kind* level.
22:00:27 <joco42> i got the idea from phadej , and i really like it
22:00:38 <joco42> he wrote an article on sof, lemme find it
22:01:01 <joco42> http://stackoverflow.com/questions/28247543/motivation-behind-phantom-types
22:01:23 <joco42> i wanna try some dependent typeing stuff, hence these experiments
22:02:34 <dhz_> joco42 please don't post so many pics unless they contain nudity
22:02:36 <joco42> so line 10 and 12 are logically the same
22:03:02 <ReinH> The DataKinds approach to closed phantom type sets is reasonable. Why not just use it?
22:03:10 <joco42> dhz_:  i try to fix my copy paste in the coming days
22:04:18 <joco42> ReinH:  yes,i did that first, let me get an example where that breaks down
22:29:55 <medfly> so, there's this Setup.hs file, all it fucking does is run gcc on a bunch of files, but I can't fucking pass it parameters because it's in fucking Haskell and it apparently decided it doesn't want to accept any more includeDirs because apparently that's fucking passe. http://lpaste.net/9050732295928938496 any idea how to fix it? you can run this if you have wx dependencies (up to wxdirect) on ghc for zeh errors.
22:30:19 <medfly> all my change is lines 93 and 84.
22:31:09 <medfly> I'm already upset at the literally several pages worth of isntructions on how to get this shit to run at all. nice language
22:31:36 <kadoban> Nobody could tell that you're upset.
22:31:52 <dmj`> medfly: please keep a somewhat professional tone
22:31:57 <medfly> my language of speech is as nice as the programming language I use.
22:32:11 <medfly> it has not been kind to me.
22:36:20 <medfly> guess I should've asked a question about a newbie tutorial rather than how to append a string to a list of strings.
22:36:23 <medfly> apparently a hard task.
22:37:36 <sgronblo> would be nice to learn if there was a way in haskell to code up the things that would be incredibly simple in python, like how to iterate over a range of col row indexes and update a big matrix based on them.
22:37:37 <Ashy> medfly: haskell is very different to most of the popular imperative (and even functional) languages
22:37:56 <joco42> ReinH: I was trying to write stg like this, but i cannot get this to compile :
22:38:02 <joco42> https://usercontent.irccloud-cdn.com/file/LgFc8qUa/Screen%20Shot%202015-12-29%20at%2008.36.17.png
22:38:15 <Ashy> medfly: it can take a while to feel comfortable in (i still don't tbh) but there's some really good ideas in the language and it's worth the effort
22:38:34 <Ashy> medfly: definately spend some time with the beginner resources though
22:38:34 <medfly> so in short nobody here even knows how to append a string to a list of strings.
22:38:41 <kadoban> medfly: It's almost as if staging a nutty and being a jerk aren't the key points of asking questions likely to receive answers.
22:38:52 <medfly> oh please.
22:39:15 <Ashy> medfly: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
22:39:19 <bitemyapp> most of my job is concatenating strings. seems alright.
22:39:46 <medfly> I'm not interested in learning Haskell. I'm interested in fixing its broken ass packages to compile on anything other than linux-amd64.
22:40:06 <dmj`> yea I just shuffle ByteStrings to and fro' all day
22:40:40 * bitemyapp mumbles something about catching flies with honey
22:40:45 <bitemyapp> dmj`: err'day we shufflin'
22:41:14 <dmj`> party rock
22:41:20 <dmj`> bitemyapp: :)
22:41:49 <medfly> if I had asked nicely nobody would have responded.
22:41:57 <dmj`> medfly: have you tried stack overflow?
22:42:00 <medfly> no
22:42:02 <kadoban> medfly: Apparently we'll never know.
22:42:56 <medfly> this is like npm + node.js levels of bad.
22:43:02 <medfly> except I'm pretty sure node.js is more portable.
22:43:10 <bitemyapp> you should ask them if they think it's equally bad, worse, or better
22:43:34 <bitemyapp> get a representative sampling, ya know?
22:43:52 <kadoban> medfly: Asking nicely isn't even the most important part. Your question is just horribly badly asked. I have no godly idea what problem you're having, with what, why, how you tried to fix it, what's wrong with how you tried to fix it, etc. You've provided lots of bitching, and apparently a Setup.hs file and didn't bother to specify the errors.
22:44:48 <medfly> kadoban: wxhaskell doesn't search for GL/glx.h in a sane way. I want to append its simple code simply the flag -I<something from pkg-config>. I can run pkg-config. I'm having trouble appending it to includeDirs of BuildInfo.
22:45:44 <medfly> kadoban: instead I get errors about how I can't have a includeDirs and ExtraLibDirs.
22:45:49 <medfly> as fields.
22:46:05 <dmj`> medfly: what OS are you on
22:46:12 <medfly> NetBSD.
22:46:32 <medfly> nobody but Linux puts GL/glx.h in /usr/include
22:46:43 <medfly> it breaks under all BSDs. I'm surprised OS X works if it does at all.
22:48:18 <medfly> testing is for plebs
22:49:12 <ReinH> medfly: Can you try not to act 12 please.
22:49:42 <medfly> fine, I promise I'll punch a kitten instead of swearing on an IRC channel from now on.
22:49:54 <ReinH> Apparently you can't.
22:52:44 <medfly> I'd like to appreciate having a debate about my use of language is easier than appending a string to a list of strings.
22:53:12 <ReinH> This isn't a debate. This is me asking you to stop acting like a spoiled child.
22:53:38 <medfly> nobody here even knows Haskell.
22:53:54 <ReinH> Why are you even here? Go away.
22:54:00 <medfly> fixing your broken ass packages.
22:54:01 <lamefun> ReinH, he doesn't "act 12", he "acts truth". Spoiled by programming languages that work, yes.
22:54:37 <ReinH> lamefun: if you didn't also have a history of acting like a spoiled child, I might take that more seriously.
22:55:03 <ReinH> If you don't like haskell, you don't have be be here.
22:55:33 <dmj`> medfly: dependencies in non-standard locations is not a "language" problem.
22:55:46 <bitemyapp> dmj`: no no, it's totes part of the original design
22:55:58 <medfly> dmj`: wrapping what is merely a script to run gcc on a bunch of files with infinite levels of abstractions to make it too complicated is a language problem
22:55:59 <bitemyapp> dmj`: that was Moggi and Wadler's real contribution, making the packaging terrible!
22:56:15 <medfly> dmj`: there is no generalization here. it's hard coding a compiler and paths
23:00:39 <medfly> ReinH: I don't like a lot of things. I fix Linux-isms.
23:00:55 <ReinH> I don't care.    
23:01:42 <lamefun> "Acting like a spoiled child" - what does that even mean? I suspect: "calling spade a spade"? When ("X is a volunteer-driven project" == "criticism is forbidden"), it's an echo-chamber.
23:01:58 <bitemyapp> Please, you're not Christopher Hitchens risen from the grave.
23:02:08 <bitemyapp> This is petulant whining, with zero attempt at civility or pleasantness.
23:02:26 * ReinH yawns
23:02:27 <bitemyapp> Which is rich coming from me, I know, but that should just make my point more poignant.
23:02:40 <ReinH> Two more to add to the killfile.
23:03:10 <dmj`> medfly: stack overflow, emailing the author, or continuing to fix the problem on your own seem to be the best/only options.
23:06:17 <bitemyapp> ReinH: ah wtf missed your o/
23:06:25 <ReinH> bitemyapp: 's ok
23:06:25 <bitemyapp> ReinH: sorry, let me return the favor
23:06:27 <bitemyapp> ReinH: o/
23:06:32 <ReinH> \o
23:07:01 <bitemyapp> also MarcelineVQ's thing for Text+Trifecta worked, but it's copying.
23:12:01 <lamefun> bitemyapp, how am I "un-civil"?
23:12:17 <medfly> fixed it
23:12:30 <medfly> rocket science, i tell ya
23:33:11 <dresuer> postmayor returns the position of the last elem equal to True of a given list
23:33:14 <dresuer> i.e
23:33:22 <dresuer> postmayor [True,False,False,False] = 0
23:33:34 <dresuer> postmayor [False,False,False,True] = 3
23:33:41 <dresuer> how can I do that?
23:33:41 <ReinH> and postmayor [False]?
23:33:57 <dresuer> ReinH, IT'S NOT DEFINE.
23:34:00 <ReinH> Why not?
23:34:05 <ReinH> Do you want your program to crash?
23:34:39 <ReinH> If there's no result, you can use Maybe Int to handle that.
23:34:55 <ReinH> Don't write partial functions. They'll just cause your program to crash. There's no need.
23:35:29 <dresuer> ReinH, my pre-condition is xs != [] and xs should have a true item.
23:35:54 <ReinH> > elemIndices True [False,False,False,True]
23:35:56 <lambdabot>  [3]
23:36:10 <dresuer> :O
23:36:39 <ReinH> :t last . elemIndices True
23:36:40 <lambdabot> [Bool] -> Int
23:36:44 <ReinH> but in general this is a poor style
23:36:57 <ReinH> because it forces you to prove lots of things yourself that they type system can easily do for you
23:36:58 <dresuer> ReinH, Yes, How can I do that ? 
23:36:59 <dresuer> postmayor ([True]) = 0
23:36:59 <dresuer> postmayor ([False])= 0
23:36:59 <dresuer> postmayor (False:x':xs)= postmayor (x':xs)
23:36:59 <dresuer> postmayor (True:x':xs) = 1 + postmayor (x':xs)
23:37:10 <dresuer> Doesn't work ;(
23:37:20 <ReinH> > last . elemIndices True $ [True,False,True]
23:37:21 <lambdabot>  2
23:37:29 <ReinH> s/they/the
23:38:04 <ReinH> There's no need to enforce invariants manually if the type system can enforce them statically. You'll write programs with fewer bugs if you let the compiler catch them for you.
23:38:11 <dresuer> ReinH, Using recursion
23:38:27 <ReinH> why do you need to use recursion?
23:38:43 <medfly> because he's doing his homework
23:38:58 <medfly> and it said 'use recursion'
23:38:59 <medfly> :p
23:39:18 <dresuer> That's my homework.
23:39:19 <ReinH> dresuer: how does yours not work?
23:39:43 <ReinH> postmayor [False] is not 0, it is an error.
23:39:47 <dresuer> medfly, (y)
23:40:41 <ReinH> Which makes the recursive solution difficult, since you don't have a base case.
23:41:03 <ReinH> What you can do instead is use a helper function
23:42:42 <dresuer> ReinH, They teach me to "derive programs" from a pre-condition and post-condition given
23:42:53 <ReinH> dresuer: which course is this?
23:42:56 <dresuer> ReinH, http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo10.pdf
23:43:00 <dresuer> It's spanish
23:43:39 <doomrobo> dresuer, postmayor l = fst $ last $ filter (\p -> snd p == True) $ zip [0..] l
23:43:52 <dresuer> without filter 
23:44:00 <ReinH> I don't think it's helpful to teach students to maintain invariants in their head that the compiler can maintain for them :(
23:44:20 <ReinH> it seems like this teaches a poor style of programming to me. :(
23:44:44 <dresuer> ReinH, LOOOOOOOOKKK THAT
23:44:47 <dresuer> IT'S SOOOO COOOOLL
23:44:48 <dresuer> http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo12.pdf
23:44:56 <doomrobo> ReinH, what's elemIndices?
23:44:56 <dresuer> 247 !
23:45:09 <ReinH> If you are taught to write partial functions with the guarantee that some pre-conditions have made them total, you are taught (a) it's ok to write partial functions (b) it's ok to ignore Haskell's type system and prove a bunch of stuff yourself that Haskell can prove for you.
23:45:23 <dresuer> ReinH, They teach me to derive sum function!!!
23:45:33 <dresuer> ReinH, http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo12.pdf <- HERE
23:45:40 <dresuer> 247 
23:46:23 <doomrobo> ReinH, nvm, found it. Yeah your way is a lot more elegant than mine
23:46:32 <dresuer> ReinH, pre-condition of a sum function : true ( not pre-condition)
23:46:53 <dresuer> post-condition = = (
23:46:53 <dresuer> SUM i : 0 ≤ i < #xs : xs.i)
23:46:57 <ReinH> dresuer: all the pre-conditions of the sum function are guaranteed by the type system.
23:47:24 <dresuer> ReinH, Have you read the pdf?
23:48:07 <ReinH> Yeah. I don't understand why you would teach Haskell that way. :(
23:48:36 <ReinH> ButI can see why you wanted to use length everywhere.
23:49:53 <ReinH> That's exactly what I mean by this teaching you a poor way of writing haskell
23:49:55 <dresuer> ReinH, Because it's not only Haskell, is functional languages in general.
23:50:31 <dresuer> It's like a "generalization" of different languages
23:50:53 <dresuer> functional languages
23:50:54 <ReinH> Yeah, this seems pretty bad to me, sorry :(
23:51:39 <ReinH> it's teaching you to write bad haskell.
23:53:17 <ReinH> f [] = Nothing; f (x:xs) = Just ... is better than f [] = undefined; f (x:xs) = ...
23:53:31 <ReinH> If Haskell can maintain your invariants for you, let it.
23:53:40 <frerich> Maybe it starts off with functional program derivation given pre/post conditions and then builds on that to show how static typing can enforce such things at compile time.
23:53:56 <ReinH> frerich: why start off the wrong way in the first place?
23:55:06 <ReinH> frerich: earlier dresuer was lead by a literal interpretation of the instructions to write a function that looked like: foo xs ys | length xs == 0 && length ys == 0 = ... with four cases for every combination of the lengths of xs and ys being either 0 or not 0.
23:55:25 <ReinH> frerich: it was awful, and it was the obvious thing to do based on the way this course teaches
23:55:30 <ReinH> I really don't like it at all
23:55:44 <ReinH> s/four cases/four guards
23:56:15 <dresuer> We were 31 students and only approved 2
23:56:15 <dresuer> I have to take the exam again
23:56:35 <ReinH> I'm not surprised that you didn't pass, and I don't think it's your fault.
23:56:36 <frerich> ReinH: I don't think it's too bad to start off with a naive and flawed definition, it makes you appreciate other features later on. Same reason why I think everybody should start off building programs from the command line and only later use IDEs (once you know what work they do for you and what extra cost they bring).
23:57:08 <ReinH> frerich: I don't know of any teachers who think that starting off a student with a bunch of bad habits is a good strategy.
23:57:25 <ReinH> It's pretty much the worst strategy.
23:57:47 * frerich sighs
23:57:50 <dresuer> ReinH, I studied a lot
23:58:12 <dresuer> It depresses me not approve
23:58:32 <ReinH> dresuer: it's a crappy course, you should just learn what you need to pass it and then look elsewhere to learn haskell
23:58:32 <dresuer> But I will try again :D
