00:17:43 <joco42> is the applicative the same as monoid?
00:17:52 <joco42> in some sense?
00:18:08 <joco42> coz here point 4.5 https://wiki.haskell.org/Typeclassopedia says something like that....
00:18:19 <joco42> but i don't really see how they are the "same"
00:18:23 <quchen> No. Alternative is a bit like a lifted Monoid at time, but Applicative isn't.
00:18:39 <joco42> hmmm
00:18:47 <joco42> Monoidal f
00:19:40 <quchen> Oh, that other representation is a bit more monoidy, yes. But it's not a very instructive similarity when you're first learning about Applicative.
00:20:22 <quchen> Applicatives do have something to do with monoids when you jump into the deep math end, if that's what you're asking (what was it - strong lax monoidal functor or something?)
00:20:58 <quchen> When you squint a bit, you can see that "unit" behaves like a left-and-right-identity to (**)
00:21:55 <joco42> hmmm
00:21:56 * hackagebot dialog 0.3.0.0 - Simple dialog-based user interfaces  https://hackage.haskell.org/package/dialog-0.3.0.0 (lamefun)
00:22:22 <joco42> yeah it does
00:22:42 <quchen> And (**) is associative as well.
00:22:54 <quchen> (Up to tuple reordering)
00:23:28 <joco42> so mappend is (,)
00:23:36 <quchen> So we have unit+unit+associativity, whish sounds like monoid (or category if you will) already
00:23:43 <quchen> No, mappend corresponds to (**)
00:24:02 <quchen> mempty corresponds to unit
00:24:10 <joco42> I mean, i can think of (,) as (**)
00:24:21 <joco42> it fix the order of the pair
00:24:32 <joco42> (a,b) is not the same as (b,a)
00:24:51 <joco42> same goes for a **b not the same as b ** a
00:25:25 <joco42> but ((a,b),c) is the same as (a,(b,c)) if i understand correctly
00:25:31 <quchen> (a,b) and (b,a) are isomorphic, i.e. "the same thing". On the other hand, a**b can be something completely different than b**a.
00:25:52 <quchen> So (,) and (**) aren't a very good match.
00:26:02 <joco42> https://wiki.haskell.org/Typeclassopedia I am trying to think about point 4.5 here
00:26:04 <joco42> there
00:26:12 <joco42> which says that they are the same
00:26:20 <joco42> given some laws
00:26:24 <joco42> conceptually
00:26:29 <joco42> they are the same....
00:26:31 <joco42> or not ?
00:26:52 <joco42> "More technically, the idea is that f preserves the "monoidal structure" given by the pairing constructor (,) and unit type (). "
00:27:52 <joco42> or this http://blog.ezyang.com/2012/08/applicative-functors/
00:29:26 <joco42> so i wonder if applicative functors are only meant to preserve the _ORDER_ of some elements ?
00:29:46 <quchen> There are many monoids around here it's a bit confusing ;-) So if all we care about is isomoprhism, we have ((),a) ≅ a, (a,()) ≡ a, (a,(b,c)) ≡ ((a,b),c).
00:29:49 <joco42> that is all they can do ?
00:30:02 <quchen> So we could say that tuples are monoidal with mempty = (), mappend = (,).
00:30:09 <joco42> yes
00:33:37 <quchen> The problem is that the monoidal stuff is just part of what makes an Applicative. The tuples are lifted by the Functor f, and and that's kind of missed in that picture of "it's just some monoid thing"
00:35:22 <joco42> yeah
00:35:32 <joco42> Functor + monoid
00:35:37 <joco42> =applicative
00:35:45 <joco42> hand wavingly
00:36:15 <joco42> sort of like a tagged monoid
00:36:22 <joco42> tagged=lifted
00:36:50 <joco42> monoid because partial application is possible
00:36:57 * hackagebot ObjectName 1.1.0.1 - Explicitly handled object names  https://hackage.haskell.org/package/ObjectName-1.1.0.1 (SvenPanne)
00:37:08 <joco42> partial application is the fold
00:37:13 <joco42> on that monoid
00:37:25 <quchen> Partial application of what?
00:37:29 <joco42> does that make sense somehow ? 
00:37:42 <joco42> lemme see
00:37:59 <quchen> You can't fold a monoid, I don't know what that would mean
00:38:48 <joco42> if you have a list + monoid then you can fold that with mappend and mempty
00:39:20 <quchen> sure, but we have an Applicative here, and a handwaving monoid
00:39:27 <joco42> :)
00:40:08 <joco42> what i was thinking is that f<$> x1<*> x2<*> ... <*> xn
00:40:18 <joco42> is kind of a fold
00:40:25 <joco42> if i squint
00:40:38 <quchen> It's a chain of applications, that doesn't have to be a fold.
00:40:46 <joco42> ok
00:40:49 <joco42> indeed
00:40:53 <quchen> Note that all the "x" can have different types, you can't even put them into a list.
00:40:55 <joco42> that is maybe not a good analogy
00:41:06 <joco42> and it is of fixed length
00:41:15 <joco42> f
00:41:20 <joco42> ok
00:41:47 <joco42> this folding analogy is a little bit indeed too far fetched... and incorrect
00:42:13 * hackagebot Hish 0.1.2.2 -   https://hackage.haskell.org/package/Hish-0.1.2.2 (jaiyalas)
00:42:15 * hackagebot StateVar 1.1.0.2 - State variables  https://hackage.haskell.org/package/StateVar-1.1.0.2 (SvenPanne)
00:43:03 <quchen> If you have only "f a"s then you can write a fold with <*>,
00:43:05 <quchen> :t foldr (<*>) (pure undefined) :: Applicative f => [f (a -> a)] -> f a
00:43:07 <lambdabot> Applicative f => [f (a -> a)] -> f a
00:45:29 <quchen> I don't think this tells you much about Applicative though
00:45:44 <joco42> hmm
00:45:52 <joco42> yeah
00:46:26 <quchen> A more useful picture is that `(**) :: (f a, f b) -> f (a,b)` is like a simpler version of Traversable for tuples
00:46:29 <joco42> but i think you just said it what i had in mind ... 
00:46:30 <quchen> :t sequenceA
00:46:32 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
00:47:18 <quchen> (**) "pulls out" the "f" from the tuple, just like sequenceA "pulls out" the "f" from a "t"
00:49:54 <joco42>   (**) :: f a -> f b -> f (a,b)
00:49:56 <joco42> hmm
00:50:12 <joco42> lemme think about this for a sec
00:53:14 <tomus> st >>= f  =  \s -> let (x,s') = st s in f x s'. we does in stop? I am struggling with braces
00:53:37 <tomus> st >>= f  =  \s -> let (x,s') = st s in (f x) s'. we does in stop? I am struggling with braces
00:53:49 <quchen> st >>= f  =  (\s -> (let (x,s') = (st s) in (f x s)))
00:54:21 <tomus> quchen: thank yo
01:05:33 <ReinH> quchen: ofc (**) is an application of strength
01:05:45 <ReinH> two of them, in fact
01:08:49 <joco42> ofc?
01:08:52 <joco42> strength?
01:09:02 <joco42> (**) :: f a -> f b -> f (a,b)
01:09:38 <joco42> is sequencaA for pairs
01:09:43 <joco42> according to quchen 
01:09:52 <joco42> which is a nice way of looking at **
01:09:58 <joco42> imho
01:10:39 <joco42> quchen> (**) "pulls out" the "f" from the tuple, just like sequenceA "pulls out" the "f" from a "t"
01:11:05 <joco42> so ** is the " puller "
01:11:15 <joco42> for a tuple
01:11:25 <joco42> pretty nice picture
01:14:05 <Nuxular> can someone tell me what "$(10)" means in haskell?
01:14:29 <liste> Nuxular looks like Template Haskell
01:14:34 <Nuxular> I did something like ($(10)) expecting a operator section
01:14:51 <Nuxular> whereas that is apparently of type "()"
01:15:14 <Nuxular> I'm using ghci
01:15:34 <Nuxular> default settings AFAIK
01:16:39 <Nuxular> > :t ($(10))
01:16:41 <lambdabot>  <hint>:1:1: parse error on input ‘:’
01:17:21 <Nuxular> @type ($(10))
01:17:23 <lambdabot> Num a => (a -> b) -> b
01:17:52 <Nuxular> that's not what ghci gives
01:18:35 <Nuxular> GHCi, version 7.8.3
01:18:42 <MarcelineVQ> What does yours say?
01:18:57 <Nuxular> *Main> :t ($(10))
01:18:59 <Nuxular> () :: ()
01:19:41 <Nuxular> is this a bug?
01:20:52 <MarcelineVQ> Does seem like it. I'm on 7.10.2 and it works correctly.
01:21:07 <Nuxular> let foo = $( transform [| bar |] )
01:21:11 <Nuxular> oops
01:21:31 <liste> :t ($(10)) gives a "No instance for (Num ExpQ)" for me
01:21:33 <lambdabot> Not in scope: ‘gives’
01:21:33 <lambdabot>     Not in scope: ‘me’
01:21:33 <lambdabot>     Perhaps you meant one of these:
01:22:00 <Nuxular> it looks like liste might be on to something about Template Haskell
01:22:08 <jle`> you have -XTemplateHaskell installed
01:22:22 <jle`> er, enabled
01:22:25 <Nuxular> how would I check this?
01:22:30 <jle`> ($ (10)) would be the section
01:23:14 <Nuxular> I can verify that this worked
01:23:24 <jle`> try it with -XNoTemplateHaskell
01:23:33 <jle`>  :set -XNoTemplateHaskell
01:23:38 <jle`> ...i'm not sure if that works, heh
01:23:48 <jle`> template haskell is not enabled by default on ghci, though
01:24:49 <Nuxular> apparently I've been running with two extensions enabled: -XExistentialQuantification -XNoMonomorphismRestriction
01:25:22 <Nuxular> but that isn't the issue apparently
01:25:34 <jle`> hm, neither of those whould interfere.  :t ($(10)), :t ($10), and :t ($ (10)) all give expected results for me on ghci
01:25:51 <Nuxular> ok
01:25:59 <Nuxular> is there any way to check the state of those flags?
01:26:36 <MarcelineVQ> :showi language
01:26:37 <Nuxular> I tried your flag and it still gives :: ()
01:26:55 <jle`> does ($ (10)) give the expected answer?
01:26:58 <Nuxular> *Main> :showi language
01:26:59 <Nuxular> base language is: Haskell2010
01:27:01 <Nuxular> with the following modifiers:
01:27:02 <Nuxular>   -XNoMonomorphismRestriction
01:27:04 <Nuxular>   -XNoDatatypeContexts
01:27:05 <Nuxular>   -XNondecreasingIndentation
01:27:07 <Nuxular>   -XExtendedDefaultRules
01:27:12 <Nuxular> jle`, yes
01:27:29 <jle`> how about ($10)
01:27:40 <Nuxular> yes
01:28:00 <Nuxular> *Main> :t ($ (10))
01:28:01 <Nuxular> ($ (10)) :: Num a => (a -> b) -> b
01:28:03 <Nuxular> *Main> :t ($10)
01:28:04 <Nuxular> ($10) :: Num a => (a -> b) -> b
01:28:13 <Nuxular> *Main> :t ($(10))
01:28:14 <Nuxular> () :: ()
01:29:30 <jle`> hm, tested it on my 7.8.3 install and it also works as expected.  how odd
01:30:08 <jle`> how about :t ($(10)) :: Num a => (a -> b) -> b
01:32:27 <Nuxular> *Main> :t ($(10))
01:32:29 <Nuxular> () :: ()
01:32:44 <Nuxular> *Main> :t ($(10)) :: Num a => (a -> b) -> b
01:32:46 <Nuxular> <interactive>:1:1:
01:32:47 <Nuxular>     Couldn't match expected type `(a1 -> b1) -> b1'
01:32:49 <Nuxular>                 with actual type `()'
01:32:50 <Nuxular>     In the expression: () :: Num a => (a -> b) -> b
01:33:42 <jle`> :|
01:34:27 <Nuxular> :(
01:34:46 <Nuxular> I think a reinstallation of ghc platform is in order
01:35:07 <jle`> hm, why not just upgrade to 7.10? :)
01:35:10 <jle`> and report the bug while you're at it
01:35:10 <xacktm> Hi, I'm using cryptohash but can't get a pretty alphanumeric string.  For example, `MD5.hash $ B.pack "test"` gives me "\t\143k\205F!\211s\202\222N\131&'\180\246".  How do I get a nicer hash consisting of alphanumeric characters?
01:35:12 <jle`> :D
01:35:23 <Nuxular> jle`, I mean that :D
01:35:37 <jle`> xacktm: well, md5 doesn't actually output hashes that are alphanumeric characters...
01:35:49 <jle`> it outputs binary
01:36:06 <jle`> do you want to render the binary as hex, maybe?  or some alphanumeric encoding?
01:36:30 <xacktm> hmm I think the former, binary as hex
01:36:38 <jle`> you wouldn't be getting a different hash, you'd be getting the same hash, but displaying it as hex
01:38:19 <xacktm> right, so if I map a fucntion onto a bytestring.char8, will I be taking each 8-bits as input?  I'm guessing I want to split the 8-bits into two 4-bit nibbles?
01:39:13 <xacktm> (the approach I see is to split the bytestring.char8 into nibbles, then convert each nibble to a hex-representation string)
01:39:43 <jle`> er no, bytestring.char8 is actually interpreting bytestring as text represented by 8-bit truncated unicode...it's actually somewhat of a bad module, not sure why it still exists
01:39:46 <jle`> hm
01:40:19 <jle`> i'm not sure what the best way of turning a bytestring into hex is, but you can use `unpack` to turn it into a list of bytes
01:40:42 <jle`> and...there are a couple of ways you can convert bytes to hex in a nice way
01:41:04 <ben> I think there's function you can use in that package
01:42:14 <xacktm> hmm a list of bytes sounds promising
01:42:24 * hackagebot OpenGLRaw 2.6.1.1 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-2.6.1.1 (SvenPanne)
01:42:26 * hackagebot GLURaw 1.5.0.3 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/GLURaw-1.5.0.3 (SvenPanne)
01:43:13 <jle`> > printf "%x" (0xfa :: Word8) :: String
01:43:15 <lambdabot>  "fa"
01:43:48 <jle`> oh
01:44:04 <xacktm> ben: I see digestToHexByteString :: Digest a -> ByteString but I only have a ByteString
01:44:14 <jle`> > showHex (0xfa :: Word8) ""
01:44:16 <lambdabot>  "fa"
01:44:25 <ben> There's a digestFromByteString
01:44:39 <jle`> xacktm: ah, that's probably a utf8-encoded hex bytestring
01:44:43 <jle`> which is kind of silly
01:45:17 <jle`> you can convert it to Text using `decodeUtf8` from the `text` library...but i think just "printing"/"showing" that resulting bytestring would be okay as a hack/cludge
01:45:24 <Nuxular> jle', very odd this bug only shows itself when I'm running ghci through nppexec which is a plugin for notepad++ on windows
01:45:40 <Nuxular> running ghci from cmd.exe behaves normally
01:45:59 <jle`> Nuxular: it's possible that $(10) might be interpreted as a string interpolation of sorts by nppexec ?
01:46:39 <jle`> xacktm: you can convert a utf-8 encoded string into Text using decodeUtf8, and then from there you can do things you normally do with Text
01:46:47 <jle`> it's kind of weird that they give it to you back as a ByteString, but
01:46:54 <jle`> :|
01:47:03 <ben> why
01:47:09 <ben> it's just a bunch of bytes in the ascii range
01:47:11 <jle`> as a utf-8 encoded bytestring of hex characters
01:47:17 <Nuxular> jle`, you might be right
01:47:24 <ben> how do you know it's utf-8 encoded and not latin1 encoded? :P
01:47:32 <jle`> yeah, that's why it's weird
01:47:36 <jle`> it could be any encoding :O
01:47:39 <jle`> bytestring assumes no encoding
01:47:39 <Nuxular> jle`, I similar unexpected behaviour with running the python interpreter through nppexec
01:47:43 * hackagebot OpenGL 2.13.2.1 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-2.13.2.1 (SvenPanne)
01:47:44 <Nuxular> *I get
01:47:46 <jle`> it's just a stream of bytes
01:47:57 <jle`> if you wanted to return text, use Text
01:48:14 <Nuxular> jle`, so it seems like this is not a haskell issue
01:48:17 <ben> is text still utf-16?
01:48:26 <jle`> text abstracts away encoding
01:48:40 <jle`> it's meant for manipulating text, without having to worry about encoding
01:49:01 <jle`> returning an ascii-encoded string as a ByteString would be like returning an Integer as a String...returning 123 as "123"
01:49:07 <tdammers> Text is UTF-16 internally, but that is an implementation detail that shouldn't affect the public-facing API
01:49:38 <ben> jle`: more like returning 123 as "\123"?
01:49:39 <tdammers> I think there are a few tiny edge cases where the abstraction leaks a little bit, but they're not worth worrying about
01:49:54 <tdammers> ben: no, not on that level
01:50:08 <jle`> sort of; my point is that it's possible to interpret "123" as if it represented an Integer.  but it's ambiguous what integer a string would represent
01:50:20 <jle`> better to just return a type that is *intended* to represent integers, like Integer
01:50:22 <tdammers> ben: returning 123 as "123" means you're encoding an Integer as a String, just like returning a Text as a ByteString involves encoding
01:50:55 <xacktm> jle`: hmmm Text can work, but if I could keep it ByteString, then I won't need any Text in my processing code.  I want to check the prefix of the hash for characters, e.g. B.pack "00000" `B.isPrefixOf` (something_to_niceify_hash $ MD5.Hash ....)
01:51:30 <jle`> so instead of encoding your Integer into a string in a possibly ambiguous encoding (hex? decimal? whitespace?) and having the user get that string encoding of an integer...why not just return the Integer itself?
01:51:39 <jle`> which is something that is actually intended to represent integers
01:51:56 <tdammers> it's clear cut with integers, but a little bit less so with strings
01:52:12 <tdammers> especially when you're dealing with textual interfaces between processes
01:52:14 <jle`> xacktm: using Text would be the sane and robust way
01:52:18 <tdammers> (UNIX pipes and the like)
01:52:30 <ben> I find it hard to disagree with representing ascii strings as bytestring
01:52:43 * hackagebot GLUT 2.7.0.4 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.4 (SvenPanne)
01:52:49 <tdammers> ben: bytestring is a misnomer, it should be ByteArray
01:53:00 <ben> yeah, then still :)
01:53:05 <jle`> xacktm: but you can hack on unstable implementation details of your crypto library and check if the prefix of your bytestring matches something
01:53:13 <ben> xacktm: have you considered doing your check on the raw bytes instead?
01:53:18 <tdammers> ByteString is not a string type, and a byte is not a character, not even when you assume ASCII
01:53:38 <ben> a byte is a good encoding for a character when you assume ascii though
01:53:45 <jle`> ben: ByteString loses information about the encoding in the type...it's just a blob of semanticsless bytes
01:53:46 <tdammers> it is still an encoding though
01:54:04 <ben> Text is just an encoding that doesn't tell you what the encoding is...
01:54:13 <jle`> it abstracts away the encoding
01:54:17 <ben> yeah!
01:54:20 <jle`> it has semantics of *text*
01:54:21 <tdammers> if you want to represent ASCII strings, by all means use bytestrings under the hood, but wrap them in a type that abstracts away this detail
01:54:29 <jle`> so you can do text processing on it, as if it were text
01:54:40 <jle`> it keeps track of the "encoding" for you, so it's unambiguous
01:54:42 <tdammers> Text doesn't need to tell you the encoding because it doesn't give you anything encoded
01:55:04 <tdammers> it presents you the strings in an unencoded form
01:55:13 <tdammers> bytestrings cannot do that, they can only represent byte arrays
01:55:19 <aloiscochard> hey folks, what do you think about http://pastie.org/10646882 ? looking for advice how to design the monadic stack in a toy compiler.
01:55:19 <ben> I'm not sure I can keep up with these heights of abstraction :P
01:55:24 <jle`> ben: as an analogy, you can always return Integer's as String-representations of integers, but now you have a String.  its integer-ness is not in its type (it could be a string of anything else)
01:55:26 <xacktm> ben: I would do so if I was in C but I wasn't sure how to handle bytes in haskell :)  unpack gives me a string which is handy though
01:55:41 <jle`> ben: so you have a String, and someone promises to you that it represents an Integer
01:55:47 <tdammers> ben: it's actually quite simple. A string is a sequence of characters; a bytestring is a sequence of bytes.
01:56:02 <ben> what's a character, then?
01:56:08 <tdammers> ben: once you accept that characters and bytes are not the same thing, it becomes obvious that bytestrings aren't strings eityher
01:56:28 <jle`> ben: and now, you want to add two String-encoded integers together.  what do you do?  you'd convert the String to an Integer (somehow, by trusting the person), and then add the two, and then unconvert back.  but that's just silly, when you could have been using Integer the entire time
01:56:38 <tdammers> ben: a type that can hold anything that we consider a character
01:56:50 <jle`> ben: Integer offers an API to deal with integers *as integers*, instead of as strings.  and, it keeps track of the internal representation for you so it's always unambiguous
01:56:52 <ben> jle`: for the analogy what i really want to be doing is check if the first digit of the integer is a 1, no
01:57:27 <jle`> yeah, but the type String says nothing about how the integer is even encoded as a string...you just have to trust the implementor
01:57:43 * hackagebot OpenAL 1.7.0.2 - A binding to the OpenAL cross-platform 3D audio API  https://hackage.haskell.org/package/OpenAL-1.7.0.2 (SvenPanne)
01:57:50 <jle`> what if the integer is encoded as a hex string representation? or the decimal string representation?
01:58:03 <jle`> the type `String` tells you nothing about this
01:58:23 <ben> maybe the actual right way here is to treat the hashed value as a large integer, convert it to Integer and then check whether it's less than a given value
01:59:03 <jle`> trying the hash as a bytestring makes sense, because it's actually a blob of binary
01:59:16 <jle`> treating the hexademical representation of the hash as a bytestring is what doesn't make sense
01:59:32 <jle`> the hash itself is a bytestring, but its hexadecimal representation is not a bytestring...it's text
02:00:47 <tdammers> the UNIX world, sadly, still largely subscribes to the "a character is a byte" fallacy, and some of that bleeds into the Haskell library ecosystem
02:01:18 <tdammers> it's a very convenient fallacy, but a fallacy still
02:02:59 * hackagebot ALUT 2.4.0.1 - A binding for the OpenAL Utility Toolkit  https://hackage.haskell.org/package/ALUT-2.4.0.1 (SvenPanne)
02:03:01 * hackagebot lambdatex 0.1.0.1 - Type-Safe LaTeX EDSL  https://hackage.haskell.org/package/lambdatex-0.1.0.1 (Norfair)
02:03:48 <jle`> if you trust that the person giving you the bytestring is giving you ascii-encoded text, then you can treat a ByteString as if it were ascii-encoded text, but...it's a bit living on the edge.  one day they might decide to change things, even.  the Text type keeps track of encoding for you, and lets you treat it as if it were actuall text, with a text api
02:04:27 <jle`> it's like if a library you used said, "here is an integer, but i've encoded it as a string for you.  trust me, it's in hex encoding.  but, it's a String, so."
02:05:57 <jle`> and it's also kind of an unhaskelly thing to do...to use types that are unaware of what they're encoding, that won't forbid you from doing silly things like accidentally using (++) to add two integer strings
02:06:22 <jle`> (and by analogy, accidentally concatenating bytestrings as if you wanted to concatenate text)
02:07:53 <Nuxular> I wish I'd remembered just how long the haskell platform uninstaller takes to remove paths
02:08:04 <Nuxular> does the latest version do this?
02:08:32 <Nuxular> Is it just being more thorough than most other uninstallers?
02:09:09 <Nuxular> 99% of the uninstallation process is done in <1% of the time it takes
02:13:01 <lambdanon> Hi #haskell, got a quick question, I'd like to check first if a given String is the prefix of a second String. If it is, I'd like to remove this prefix, if not, I'd like to keep the String as it is. Now what I know there is `stripPrefix`, but since I already check with `isPrefixOf`, it seems unnecessary to have it wrapped in Maybe. Do you know a neat solution for this?
02:14:30 <liste> lambdanon why use isPrefixOf at all then?
02:14:43 <liste> just pattern match on stripPrefix
02:17:34 <Nuxular> yeah it seems like the unnecessary part is using isPrefixOf and getting a bool that is given implicitly by Maybe anyway
02:17:56 <lambdanon> liste: oh you are right, can I write this simply as ("string prefix":restofString) ?
02:17:58 <Clint> lambdanon: you could do something like stripPrefix x y <|> Just y
02:18:33 <roelof> What is wrong with my minThree function. I see a identation error on the first line ? Code can be found here : http://lpaste.net/147633
02:20:20 <Nuxular> Clint, what is <|> ?
02:20:26 <Clint> :t (<|>)
02:20:28 <lambdabot> Alternative f => f a -> f a -> f a
02:20:57 <pavonia> roelof: An '=' is missing in line 4
02:21:04 <pavonia> roelof: Also, what is z?
02:21:06 <lambdanon> Thanks for the suggestions, didn't think of those, thank you
02:23:14 <Nuxular> > stripPrefix "TEST" "TESTlol" <|> Just "Testlol"
02:23:15 <roelof> pavonia:  thanks, z was a typo needs to be x 
02:23:16 <lambdabot>  Just "lol"
02:23:27 <Nuxular> > stripPrefix "TEST" "cabbage" <|> Just "cabbage"
02:23:29 <lambdabot>  Just "cabbage"
02:23:33 <Nuxular> I see
02:23:40 <jle`> any reason why you'd use x <|> Just y over fromMaybe y x ?
02:24:00 <jle`> > fromMaybe "Testlol" $ stripPrefix "TEST" "TESTlol"
02:24:02 <lambdabot>  "lol"
02:24:08 <frerich> liste: You could do compute the length of the common prefix with '\s t -> length (takeWhile id (zipWith (==) s t))' and then drop as many characters from your input string.
02:24:09 <jle`> > fromMaybe "Testlol" $ stripPrefix "TEST" "cabbage"
02:24:11 <lambdabot>  "Testlol"
02:24:11 <Nuxular> @type fromMaybe
02:24:13 <lambdabot> a -> Maybe a -> a
02:25:44 <jle`> `x <|> Just y`  feels slightly redundant/a smell
02:25:54 <jle`> because it's just fromMaybe (Just y) x
02:25:56 <Nuxular> I think you meant:
02:26:13 <Nuxular> > fromMaybe "TESTlol" $ stripPrefix "TEST" "TESTlol"
02:26:15 <lambdabot>  "lol"
02:26:23 <Nuxular> > fromMaybe "cabbage" $ stripPrefix "TEST" "cabbage"
02:26:25 <lambdabot>  "cabbage"
02:26:29 <jle`> ah yeah, that :)
02:26:51 <jle`> x <|> y is useful when you aren't sure if either x or y will be Just or Nothing
02:27:23 <jle`> x <|> Just y will always return Just...it'll never return Nothing, so there's no use really returning things as Maybe
02:27:34 <jle`> fromMaybe y x sort of captures that at the type level
02:27:50 <Nuxular> yeah, I prefer yours to the alternative solution (no pun intended)
02:28:06 <jle`> ha ha
02:28:55 <liste> lambdanon you could write ('f':'o':'o':rest), but I meant case stripPrefix "foo" x of { (Just x') -> x; _ -> x }
02:29:32 <liste> but in this case the `maybe' combinator is your friend
02:31:09 <liste> :t maybe
02:31:10 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:31:37 <lambdanon> I see
02:31:58 <roelof> another problem : what is wrong here : http://lpaste.net/147634 
02:34:17 <liste> s/(Just x') -> x/(Just x') -> x'/
02:34:35 <roelof> I see this error message : http://lpaste.net/147635 
02:36:04 <roelof> Found it, variable z did it 
02:37:57 <xacktm> jle`: just tried some of your suggestions, but neither unpack nor decodeUtf8 worked (unpack gave me back the same string, decode failed) https://bpaste.net/show/08ef2becac7c
02:38:40 <jle`> xacktm: you could use unpack with map (`showHex` "")
02:38:50 <jle`> or, concatMap (`showHex` "")
02:39:41 <jle`> you'd use decodeUtf8 on teh result of digestToHexByteString, not in digest
02:40:25 <xacktm> ok, let me try again :)
02:41:27 <jle`> `concatMap (`showHex` "") . unpack` should render a bytestring into chunks of hex, but it might not be the best way, heh
02:41:40 <roelof> Is there a layout which is the most used when using stylish haskell or can I choose one myself ? 
02:59:07 <roelof> no "standard" layout for code in haskell ?
03:00:51 <jle`> roelof: there's a lot of variations in style...`hlint` is a plugin that helps you make some stylistic choices
03:01:21 <jle`> and some base lines like always use spaces, not tabs...and use leading commas
03:01:27 <jle`> for mulit-line lists
03:01:36 <jle`> as far as indentation goes i've seen a bunch of different styles
03:02:13 <roelof> jle`:  thanks,  Hlint gives no suggestions 
03:02:27 <jle`> then it must be finding nothing wrong :o
03:02:30 <jle`> congrats
03:02:44 <jle`> as you read more code you'll start to slowly absorb things you see into your own code, too
03:02:48 <jle`> and collaborate with other people :)
03:03:14 <roelof> jle`:  so I do not have to use things like stylish-haskell to improve the layout 
03:03:51 <xacktm> jle`: guess what I found on the top of the haddock of Crypto.Hash >_>
03:04:14 <jle`> xacktm: ya?
03:04:41 <jle`> roelof: doesn't hurt :)
03:05:54 <xacktm> a ByteSTring -> String function that I rewrote to: show (hash (B.pack "asdf;lk") :: Digest MD5)
03:06:03 <xacktm> (sorry net died for a bit there)
03:06:13 <xacktm> seems to do what I want in the REPL
03:07:48 <jle`> haha yeah, that might do it :P
03:21:48 <xacktm> solved the puzzle; thanks all
03:26:25 <jle`> np!
03:28:02 * hackagebot goal-core 0.1 - Core imports for Geometric Optimization Libraries.  https://hackage.haskell.org/package/goal-core-0.1 (alex404)
03:33:02 * hackagebot phoityne 0.0.1.1 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.1.1 (phoityne_hs)
03:48:02 * hackagebot bowntz 0 - audio-visual pseudo-physical simulation of colliding circles  https://hackage.haskell.org/package/bowntz-0 (ClaudeHeilandAllen)
03:48:04 * hackagebot butterflies 0.3.0.1 - butterfly tilings  https://hackage.haskell.org/package/butterflies-0.3.0.1 (ClaudeHeilandAllen)
03:48:06 * hackagebot gearbox 1.0.0.4 - zooming rotating fractal gears graphics demo  https://hackage.haskell.org/package/gearbox-1.0.0.4 (ClaudeHeilandAllen)
03:53:03 * hackagebot exp-extended 0.1.0.1 - floating point with extended exponent range  https://hackage.haskell.org/package/exp-extended-0.1.0.1 (ClaudeHeilandAllen)
04:05:54 <paul0> mn
04:23:30 <SX> Hello! Is here anyone familiar with network programming in haskell?
04:29:33 <pavonia> Yes
04:38:58 <SX> pavonia: Could I talk to you a little? I need to make UDP client, but can't find a "good" approach to the task..
04:39:25 <maerwald> it's better if you ask questions directly
04:40:05 <pavonia> SX: Well, I'm not very familliar with it, but many people here are, so .. yeah, just ask your question :p
04:41:48 <pavonia> Hhm, wasn't there #haskell-web too?
04:43:04 * hackagebot goal-geometry 0.1 - Scientific computing on geometric objects  https://hackage.haskell.org/package/goal-geometry-0.1 (alex404)
04:43:06 * hackagebot goal-probability 0.1 - Manifolds of probability distributions  https://hackage.haskell.org/package/goal-probability-0.1 (alex404)
04:43:11 <SX> ok. So. I need a lib with udp client of some protocol. It should have state and a handshake phase. Api should be as simple as possible, so all the work should be done inside this client.
04:44:52 <SX> Main problem here is multiple-thread access. Many threads could send requests via this client to server and should receive response (or timeout/error).
04:45:37 <lonokhov> So, classy lens can't be used for polymorphic updates? Or should I just add -XNoMonomorphismRestriction?
04:45:55 <lonokhov> hm, should probably ask in lens channel
04:47:20 <SX> Each request have an ID. I need to use this ID to give responses to askers.
04:48:04 * hackagebot goal-simulation 0.1 - Mealy based simulation tools  https://hackage.haskell.org/package/goal-simulation-0.1 (alex404)
04:48:48 <SX> So. How should I build this as a library with simple api?
04:50:36 <SX> What's a "haskell-way" for this task?
04:53:05 * hackagebot pandoc-lens 0.4.0 - Lenses for Pandoc documents  https://hackage.haskell.org/package/pandoc-lens-0.4.0 (BenGamari)
04:55:50 <pavonia> SX: I don't know about the network communication stuff, but for the concurrent parts Haskell has a lot of high-level features like MVars, channels, STM etc.
04:56:11 <pavonia> For further information I recomment http://community.haskell.org/~simonmar/pcph/ if you don't already know it
04:58:20 * hackagebot stm 2.4.4.1 - Software Transactional Memory  https://hackage.haskell.org/package/stm-2.4.4.1 (HerbertValerioRiedel)
04:59:35 <pavonia> Ha, excellent timing, hackagebot
05:03:15 <SX> Oh, I've read the Simple Server part of this book. Should I bury Socket creation and all operations on it in client? Is it a good idea to use MVar for blocking asker thread till request is complete/timed out? Like a one-slot mailbox.
05:05:02 <MasseR> SX: I'd use channels for that
05:05:14 <MasseR> For example tchan for readers / writers, and for state a tchan
05:05:16 <MasseR> ..
05:05:18 <MasseR> For example tchan for readers / writers, and for state a tvar
05:06:43 <SX> How? It's request-response communication
05:08:11 <SX> So some thread uses "reqData" of client and waits for data to arrive or timeout/error to occur.
05:08:37 <SX> Oh, it's how I see it. Any better approaches are welcomed
05:12:49 <SX> The thing is I can't directly use socket here. Some "receiver" is required to read packets and extracting request ID to send it to requester.
05:13:20 * hackagebot pandoc-lens 0.4.1 - Lenses for Pandoc documents  https://hackage.haskell.org/package/pandoc-lens-0.4.1 (BenGamari)
05:23:47 <frerich> Maybe my lack of familarity with Scotty and/or monad transformers shows, but does somebody know how to simplify http://lpaste.net/147644 ? It's part of a web server which serves download statistics, fetching data via SQL and serving it via Scotty.
05:24:17 <frerich> The way I pass 'byCustomer' and 'byResource' etc. around seems clumsy. :-/
05:30:19 <tdammers> I just wrote a vimrc for Haskell... 14 nmap directives to change my life :D
05:30:27 <lyxia> frerich: liftA4
05:30:43 <maerwald> or: (,) <$> foo <*> bar ...
05:31:42 <quchen> frerich: How about http://lpaste.net/147644
05:31:49 <frerich> Right, but - it's more the translation frmo IO to ScottyM I'd like to improve
05:32:14 <frerich> quchen: Ah, =<< is a nice idea!
05:32:32 <quchen> <- is pretty much =<<
05:32:39 <quchen> But you can use =<< pointfree
05:32:45 <frerich> Why didn't I think of that, d'uh...
05:32:47 <frerich> Thanks y'all!
05:32:52 <quchen> Plus Applicative style :-)
05:33:53 <frerich> For some reason it didn't occur to me to move the downloadStatsPage call into IO
05:35:43 <lyxia> ((liftA4 . liftA4) downloadStatsPage dowloadsPerCustomer ... downloadsPerEdition) -- no more "conn"
05:35:58 <tdammers> dealing with Scotty's monads vs. IO is one of the reasons why I prefer coding against WAI directly
05:37:15 <maerwald> yeah, haskell doesn't remove the effect complexity, it just makes it explicit by creating complicated monad stacks
05:37:21 <sbrg> Anyone using haste that can tell me how I go about telling hastec about other modules? I would like to refactor my haste code into different modules.
05:40:02 <lambdanon> Got another question: when I got a data type which holds for example one Int value, and a function, and I want this data type to be more general so that the function it holds can be either of type `Bool -> Bool` or of type `Int -> Int`, how do I write this? Is there a typeclass which holds both?
05:41:24 <kriztw> lambdanon: Either (Bool -> Bool) (Int -> Int)?
05:42:26 <maerwald> lambdanon: what do you need to do with them?
05:42:44 <maerwald> it's hard to say whether a typeclass fits without knowing that
05:43:07 <maerwald> Bool and Int share a few typeclasses
05:49:09 <lambdanon> maerwald: I got functions which reads from this Data type I mentioned (its mainly an example I'm writing for better understanding of types and typeclasses), I got functions for both signatures, so I thought it would be redundant to write 2 data types, and instead generalize the signature of the function inside the one I got
05:49:44 <maerwald> that doesn't answer the question
05:50:13 <maerwald> make it "a -> a" and follow the compiler errors
05:51:13 <bernalex> I don't understand what you want. there's not much (anything?) sensible to do to something that's "either bool or int", save for case x :: Bool -> ...; x :: Int ->... -- and that's uhm non-trivial to write in Haskell.
05:51:38 <maerwald> well, he can have the Eq or Ord instance
05:51:42 <maerwald> but not sure if that's enough
05:52:05 <maerwald> it's fishing in the dark
05:53:38 <bernalex> there's no sense in writing a function that works on "integers or booleans". it might however make sense to write a function that operates on something that *includes* integers and booleans, like something constrained by Eq or Ord, I agree.
05:53:43 <statusfailed> What's linear about linear logic?
05:54:13 <lambdanon> I got no specific scenario, I'm mainly curious if this is possible, saying "this is my data type, it holds a String, an Int, and also some function without a fully specific type signature"
05:54:29 <lambdanon> Im not trying to write a function which works on both
05:54:40 <maerwald> well, if you don't need Bool or Int you can as well make it "a -> a"...
05:54:47 <Hafydd> bernalex: what about Either Integer Bool -> a?
05:55:06 <bernalex> Hafydd: I'm saying there's not really any *sensible* function that can be written for it.
05:55:36 <Hafydd> Hmm... I wouldn't be so sure.
05:55:43 <bernalex> Hafydd: how often do you need to wibble a wobble, but the wobble might be a bobble so then you need to bibble it? if you can't control your wobbles then ydiw.
05:56:01 <Hafydd> bernalex: you stopped speaking English quite early in that sentence.
05:56:01 <statusfailed> bernalex: I can think of some sensible ways in which booleans and integers are "the same"- they both have a "zero" element (False, 0) which is an identity to some binary operation (Or, +)
05:56:30 <bernalex> Hafydd: you might have a silly bibblebobble type for some reason, but even then you'd have wibble and wobble as separate functions and just pattern match or fmap or whatever.
05:56:39 <maerwald> sounds C-ish.. if <Int> then <IO ()> else <IO ()> ;)
05:56:59 <lambdanon> maerwald: Yes that would basically be right/what i want, but writing `data myDat = myDat { foo :: a -> a}` results in an error "not in scope: type variable a"
05:57:06 <maerwald> waaat
05:57:30 <statusfailed> lambdanon: that's because "MyDat" has no type variable, you could try: `data MyDat a = MyDat { foo :: a -> a }`
05:57:31 <bernalex> statusfailed: I still don't think you would very often find that you have "an int or bool" and want to apply a function that does the same thing onto it. and if you are, I think there is a very deep problem in there somewhere.
05:57:54 <lambdanon> typo, I meant MyDat*
05:58:28 <maerwald> lambdanon: data MyData a = MyData { foo :: a -> a}
06:00:11 <statusfailed> bernalex: I think "Monoid" is an example of having some types and functions that work over all of them
06:00:39 <bernalex> statusfailed: then you have a monoid, not "a bool or an int".
06:01:02 <bernalex> statusfailed: having "something that might be equal" makes sense. having "an int or a bool" doesn't. in the former you might have an int or bool tohugh.
06:01:10 <bernalex> *though
06:01:11 <statusfailed> bernalex: no, you still have a bool or int, but you can deal with them using the functions from Monoid
06:01:30 <statusfailed> which obey laws and behave the same way, in a sense
06:01:49 <maerwald> no, he has a monoid then
06:01:52 <bernalex> you are kind of fundamentally not getting what I'm talking about
06:01:59 <lambdanon> Aah, thank you, thats what I was looking for
06:02:01 <bernalex> but it turns out op didn't even care about it
06:02:24 <maerwald> either bool or int... really ends up being Either Bool Int, lol
06:02:26 <statusfailed> heh, moot point I spose :-)
06:02:33 <bernalex> exactly my conclusion :]
06:03:23 <Hafydd> bernalex: I suppose so, but if you were to have to perform that pattern matching in a lot of places, it would be sensible to put it in one place.
06:03:52 <bernalex> Hafydd: I'll still maintain that if you have a datatype that's "int or bool" you have a lot of nonsense on your hands.
06:04:32 <lambdanon> Sorry for the confusion caused by my initial question, what I was looking for was `MyData a = MyData { foo :: a -> a}` to enable me to declare a function like `MyData Bool` or `MyData Int`
06:04:50 <Hafydd> bernalex: perhaps so.
06:04:52 <maerwald> now they are fighting over Monoids because of you!
06:04:53 <maerwald> :D
06:04:54 <statusfailed> hahah
06:05:02 <statusfailed> FLAME WAAAAR
06:05:12 <bernalex> ints and bools aren't even monoids
06:05:16 <maerwald> ^^
06:05:26 <Hafydd> bernalex: but I can imagine a type isomorphic to Either Integer Bool that does make sense.
06:05:44 <bernalex> bools are not monoids because well uh it's silly, though I guess you could be dumb and say that e = False; <> = and or something
06:06:00 <bernalex> ints are not monoids because there's too many potential monoids and we don't want to offend anyone
06:06:05 <Hafydd> There are monoids Any and All for boolean values.
06:06:10 <statusfailed> bernalex: there are 5 boolean monoids
06:06:20 <bernalex> Hafydd: yeah there's even more
06:06:27 <bernalex> statusfailed: yeah there are a bunch of monoids for int too
06:06:34 <bernalex> but int and bool themselves aren't monoids
06:06:44 <Hafydd> A matter of language, I see.
06:07:01 <bernalex> Hafydd: no I mean as in Int and Bool. there's no Monoid for those.
06:07:09 <bernalex> > mempty :: Bool
06:07:11 <lambdabot>      No instance for (Monoid Bool) arising from a use of ‘mempty’
06:07:11 <lambdabot>      In the expression: mempty :: Bool
06:07:24 <Hafydd> bernalex: yes, it's a matter of a language to assert that "they aren't monoids" means there is no Monoid instance on the types.
06:07:48 <bernalex> Hafydd: right. I should have said Bool and Int rather than bool and int.
06:24:07 <tekkkz> Hello! Is there any CLI Library avaialble for haskell to get some CLInterface?
06:24:43 <MarcelineVQ> Depends what you mean exactly, are you talking about working in a shell or passing arguments to a haskell program?
06:25:07 <tekkkz> working in a shell with a CLI, so a gui just in the shell you know what i mean?
06:25:11 <maerwald> @hackage shelly
06:25:11 <lambdabot> http://hackage.haskell.org/package/shelly
06:25:20 <SX> @hackage turtle
06:25:21 <lambdabot> http://hackage.haskell.org/package/turtle
06:25:34 <MarcelineVQ> Those are the two I see most often.
06:25:56 <SX> Turtle is closer to shell scripts
06:26:22 <aweinstock> tekkkz: do you mean ncurses bindings? or readline?
06:27:07 <geekosaur> vty / vty-ui
06:27:13 <SX> Guys, what should I use for errors in IO? Is `exceptions` package a good choice?
06:27:29 <geekosaur> there are ncurses bindings but (n)curses is notoriously annoying to work with regardless of language
06:27:37 <tekkkz> Nooo no, i mean something like to make this: http://3.bp.blogspot.com/-8F77jr9uSVw/Ttcs1qdgN-I/AAAAAAAAASo/NpSWlge2o2c/s1600/gnome-terminal_lightweight_Desktop.png
06:28:30 <bernalex> tekkkz: vty-gui then.
06:28:36 <bernalex> or vty-ui or whatever it's called.
06:28:50 <tekkkz> @hackage vty
06:28:51 <lambdabot> http://hackage.haskell.org/package/vty
06:28:51 <bernalex> or
06:28:53 <bernalex> @hackage brick
06:28:53 <lambdabot> http://hackage.haskell.org/package/brick
06:29:19 <bernalex> brick is the new vty-ui. it's a lot nicer, but maybe not as stable? vty-ui is in any event deprecated and no longer developed in favour of brick afaik.
06:29:47 <tekkkz> so if i would take the most recent i should take blocks?
06:29:52 <tekkkz> *brick
06:29:52 <tekkkz> xD
06:30:10 <bernalex> I think that's what you want, yes.
06:30:36 <tekkkz> okay, ill have a look
06:30:37 <tekkkz> ty
06:30:57 <SX> Any help for me? =)
06:31:12 <bernalex> does anyone in here know basic statistics? the rest of irc is being unhelpful lol. what's the name of a distribution that is like a normal distribution but instead of having a head/tail it has a bunch of ocurrences in the head & tail (that you want to eliminate)?
06:31:23 <bernalex> SX: what kind of errors?
06:31:51 <SX> Exceptions + my own errors. In IO monad.
06:32:56 <SX> I use lib functions which could throw Exceptions. And I have my own error types.
06:35:07 <SX> And I'd like to use some unified approach (which would let me handle non-io errors in the same manner).
06:36:12 <bergey> bernalex: leptokurtic? fat tailed?  tri-modal?
06:36:29 <Xandaros> SX: I try to avoid exceptions at all cost. I much prefer Either with an error-description-type (like parsec does it) on the left
06:37:35 <maerwald> Xandaros: that rarely works with heavy IO like writing/reading lots of files
06:37:38 <bernalex> bergey: hm. do either of those cover potentially bigger tails than "main portion"?
06:38:05 <bernalex> bergey: I'm looking at pics of those, and they seem to mostly have a "fat" head and tail, but then a much bigger normal bell-curve inside of that
06:38:15 <bergey> Hmm, probably not.
06:38:37 <bernalex> bergey: it might be tri-modal?
06:38:49 <SX> Xandaros: Yeah, but I don't think Either String is a good way to handle errors.. At least in non-trivial app.
06:39:17 <bernalex> I mean there's probably a huge head, a rather big tail, and then in-between there's a neat normal distribution which might be smaller than the head, maybe not.
06:39:21 <Xandaros> SX: Which is why I said error-description-type. I said that to imply you shouldn't use String :P
06:39:46 <SX> Besides, this way I'd need to catch all errors and convert them to this error-description-type.
06:40:15 <Xandaros> Yeah, that's the issue. I think exceptions are way overused.
06:40:35 <SX> And I'd need some complex data type to have all of these errors.
06:40:42 <Xandaros> That said, there aren't any realy alternatives
06:40:47 <Xandaros> *real
06:42:22 <SX> That's why I'm asking here. I know about MonadExcept (MonadError), used it for a while, but it's inconvenient to use MonadExceptT everywhere and to translate Exceptions to custom error datatype.
06:43:10 <cale_> SX: sorry, just missed your question there
06:43:58 <frerich> cale_: Is this your undercover nick name?
06:44:12 <cale_> This is my nick when I'm IRCing from a train
06:44:15 <cale_> lol
06:44:37 <bernalex> cale_: please please please use "Caletrain" instead. :D
06:44:52 <frerich> Localemotive
06:45:07 <phy1729> clearly cale is a furry on trains; don't you see his tail?
06:45:18 <bernalex> but if he's Caletrain or just Caletrane he can make a bunch of references to My Favorite Things and A Love Supreme etc.
06:45:22 <bernalex> CaleTrain: :D <3
06:45:34 <CaleTrain> Oh, haha
06:45:37 <SX> Xandaros: so it's Exceptions or Either MyErrorType a, correct?
06:46:03 <Xandaros> SX: Probably. I'm actually still thinking about a better solution
06:46:22 <SX> @hackage exceptions
06:46:22 <lambdabot> http://hackage.haskell.org/package/exceptions
06:46:36 <Xandaros> I hate exceptions with a passion, so I always go for Either, but that is also suboptimal
06:46:46 <CaleTrain> :t try
06:46:48 <lambdabot> Exception e => IO a -> IO (Either e a)
06:47:07 <phy1729> Is there an automated tool where I can paste some code and it tells me how it sucks / how to improve it?
06:47:09 <maerwald> haha
06:47:19 <bernalex> phy1729: #haskell
06:47:19 <SX> Snoyberg recommended this package instead of repacking exceptions to Either on stackoverflow (some time ago to someone)
06:47:20 <frerich> bernalex: Oops, I thought it was a pun on 'Caltrain'
06:47:20 <Xandaros> phy1729: hlint?
06:47:23 <maerwald> exceptions are fine
06:47:50 <SX> Snoyman*, sorry
06:48:12 <phy1729> I'll use hlint first and then #haskell :)
06:48:19 <CaleTrain> If you're using IO, and you have an exceptional condition which is more likely to be ignored for a while than handled immediately, use exceptions.
06:48:35 <CaleTrain> If it's more likely to be handled immediately, just return an Either.
06:48:48 <MarcelineVQ> choochoo
06:49:50 <Xandaros> My biggest issue with exceptions is that you aren't forced to at least say you don't care if it crashes. Of course, with some exceptions this is fine (how often do you run out of RAM?), but other times a pain in the butt (file not found)
06:50:20 <Xandaros> Unfortunately, the second case is far more common
06:50:20 <SX> Haskell needs some unification here (guidelines, maybe?), too many libs for the same thing =(
06:50:33 <ben> if only there were checked exceptions
06:50:47 <CaleTrain> There are checked exceptions.
06:50:58 <CaleTrain> That's effectively what Either gets you.
06:51:27 <CaleTrain> (note also that you can use Either with the Exception type class machinery)
06:52:01 <SX> So what's the best approach to error handling in IO monad?
06:52:02 <maerwald> Xandaros: i am currently writing a filemanager, you simply cannot do that without exceptions
06:52:23 <maerwald> they are useful and have their use case
06:52:28 <SX> What lib should I use to make it less painful for others?
06:52:43 <CaleTrain> SX: It depends, but I just gave my recommendations above.
06:52:58 <Xandaros> maerwald: I beg to differ. People wrote filemanagers in C :P
06:53:18 <maerwald> how is that related?
06:53:28 <Xandaros> no exceptions
06:53:29 <CaleTrain> Either you use Either, or you use Control.Exception (or you use both... it's possible to write things like Either SomeException a)
06:53:36 <maerwald> you are nitpicking
06:53:44 <Xandaros> hence the ":P" :P
06:53:46 <maerwald> I guess you just feel uncomfortable using them
06:53:55 <maerwald> if you need them, you will know
06:54:01 <CaleTrain> There are some other things you might use more rarely
06:54:02 <SX> You mean if I should handle the Error condition in place I call the function, right?
06:54:11 <maerwald> because without them some thiungs can become awfully overcomplicated
06:54:32 <CaleTrain> If you're constructing your own monad (which is not something you ought to do every day IMO) then you might use ExceptT or the like.
06:55:21 <Xandaros> maerwald: I can use them just fine and have done so in the past. I know they can be handy. I simply don't like them.
06:55:45 <CaleTrain> SX: If you want to make the user handle the error condition where they run the action, use IO (Either MyError a)
06:55:48 <SX> But then I should catch all exceptions and convert it to my error type, don't I?
06:55:51 <maerwald> then I dont know what you are ranting about
06:56:11 <CaleTrain> SX: It depends which exceptions -- you certainly can.
06:56:50 <CaleTrain> oop, train stopping
06:56:52 <SX> But if I don't, then there would be two types of error =) Exception & return type
06:56:56 <CaleTrain> bbian
06:58:10 <Xandaros> maerwald: Like I said before, I don't like that they are unchecked. It's similar to fromJust. It can be handy at times - that doesn't mean I like it.
06:59:57 <maerwald> that doesn't make sense imo
07:01:04 <maerwald> following your argumentation you would have to say you don't like the Maybe type because there is fromJust
07:01:17 <maerwald> the same goes for Either
07:01:42 <Xandaros> Why would I hate the whole type? I just don't like things that are inherently unsafe. And that includes exceptions
07:02:12 <maerwald> they are not
07:02:30 <maerwald> it depends how you use them, you can use Either in an unsafe way too
07:02:39 <SX> Exceptions are essential in Python, for example. What's the problem with them in Haskell?
07:02:52 <maerwald> there really is no problem, they work great
07:03:03 <SX> Both langs require proper documentation.
07:03:41 <jameseb> SX: Haskell generally relies more on checking things with the type system
07:03:51 <SX> Lib like `network` is a good example of bad docs on exceptions =)
07:03:53 <maerwald> exceptions are type checked
07:04:20 <Xandaros> But nothing tells you if you forget to catch it. Your program just crashes at runtime
07:04:22 <SX> jameseb: but you *can* throw at any point in IO monad, don't you?
07:04:44 <SX> IO (Either Error a) doesn't tell you it's safe.
07:05:47 <SX> Yup, I understand your point. If you forget to pattern-match some constructor, compiler will tell you.
07:06:31 <Xandaros> With -Wall, anyway. That's a whole other story, though :P
07:06:49 <SX> Then why do system libs use exceptions instead of Either?
07:06:50 <Xandaros> But at least the type tells you that it can fail.
07:07:06 <SX> It would help `network` library a lot :D
07:07:37 <Xandaros> Because different people have different opinions. Sometimes these people change their opinions, too, which ends with things that nobody wants (like head in Prelude :P)
07:07:47 <jameseb> SX: the checking if you forget to pattern match is mainly my point, if something needs handling it shouldn't be allowed to go unhandled
07:08:46 <SX> but you can catch any exception, right?
07:09:36 <SX> But it's not required though
07:09:42 <jameseb> you can, my point is a library shouldn't rely on it
07:10:43 <SX> So you think Exception-to-MyError conversion is better than just catch-it-later-or-not
07:12:58 <jameseb> I generally think of exceptions as being for more unrecoverable errors, so you would rarely need to catch an exception but, due to the way some libraries are written, you need to handle some exceptions immediately
07:13:33 <jameseb> really I would prefer something like Either for the second class of errors
07:13:52 <Xandaros> jameseb: This. I'm fine with exceptions for running out of RAM and the like. Not for a file that wasn't found. :/
07:15:07 <maerwald> that doesn't work in real-world
07:15:46 <maerwald> you cannot handle all failures immediately
07:16:02 <maerwald> try writing a big gtk+ app without exceptions
07:16:57 <maerwald> you either cripple the code by your explicit passing of Either types or you handle errors where they shouldn't be handled
07:22:14 <SX> What about socket errors?
07:23:15 <SX> Do you think they shoudn't be Exceptions?
07:23:55 <maerwald> but I agree that the compiler should know better about unchecked exceptions and be able to warn you like unmatched constructors
07:24:28 <KaneTW> having Either everywhere shouldn't cripple your code
07:26:10 <maerwald> it does
07:26:28 <maerwald> and it can be pretty non-generic code duplication
07:26:54 <maerwald> IF you propagate it through your whole call stack
07:27:04 <Xandaros> It depends on how many types you need on the left side. If you can get by with only a few, it should be fine
07:27:20 <Xandaros> maerwald: Either is a functor
07:27:39 <maerwald> Xandaros: lol
07:27:58 <maerwald> @hackage unexceptionalio
07:27:58 <lambdabot> http://hackage.haskell.org/package/unexceptionalio
07:29:30 <Xandaros> That actually looks useful
07:57:48 <Vincelaw> how can i make an arbitrary instance of this data type: LF a = LF [(a, Bool)] ??
07:58:51 <Zekka|Sigfig> Vincelaw: You’re going to have trouble generating that with a nonempty list for just any a
07:58:59 <Zekka|Sigfig> (What if I say a is void?)
08:00:31 <Lokathor> ReinH, https://lokathor.gitbooks.io/haskell-stuff/content/ghcjs.html I got your reflex example working, and I wrote a little demo post on the steps I went through
08:05:45 <SX> Anyone here used Turtle?
08:06:09 <SX> How to get script directory?
08:07:23 <frerich> Anybody familiar with mysql-simple? Is it possible to use it with queries which are constructed at runtime such that the number of fields returned is determined at runtime?
08:07:40 <frerich> It seems to me that the 'QueryResults' class http://hackage.haskell.org/package/mysql-simple-0.2.2.5/docs/Database-MySQL-Simple-QueryResults.html#t:QueryResults cannot model this.
08:08:46 <frerich> Hm, maybe I need to instantiate the class myself for my particular case...
08:09:32 <frerich> Thanks #haskell for rubberducking
08:09:50 <Zekka|Sigfig> frerich: Best of luck
08:27:56 <CaleToronto> Hello!
08:28:49 <CaleToronto> SX: you had any other questions about exceptions? Our conversation got cut a bit short by my train stopping :)
08:30:46 <SX> CaleToronto: Well, I think I'll just stick to IO Exceptions. And then, if I really need, I'd refactor my code to Either.
08:32:52 <CaleToronto> Yeah -- there's a tendency of Haskellers to want to use Either just because we get a little uptight about type safety, but depending on how you expect things to be handled, just throwing exceptions can be pretty useful.
08:34:33 <SX> CaleToronto: yup. Thanks for your help!
08:35:11 <CaleToronto> Control.Exception's mechanism really is pretty cool -- it uses Typeable to provide a hierarchy of exceptions which is extensible both in terms of being able to add new "supertypes" of exceptions, as well as "subtypes" by manipulating the implementation of fromException
08:36:43 <CaleToronto> (you just have to define it to produce a Just result in the cases where you want the exception to be caught, and can "recursively" use fromException at as many types as you like)
08:37:33 <CaleToronto> It's a little bit of a shame that we don't actually use it more. :P
08:42:42 <CaleToronto> http://lpaste.net/147654 -- example of refining the IOError exception type into separate pieces.
08:45:19 <CaleToronto> (see also the annotation I just added for a sketch of how to union exception types)
08:51:42 <maerwald> CaleToronto: it's just sad that the compiler cannot inform you about uncatched exceptions
08:52:11 <CaleToronto> maerwald: Well, that's sort of what the purpose of Either is
08:52:26 <maerwald> it's possible to do that with exceptions still
08:52:38 <maerwald> java does it
08:52:46 <mauke`0> does java have throwTo?
08:52:56 <CaleToronto> ^^
08:52:57 <CaleToronto> heh
08:53:28 <CaleToronto> Yeah, it's really hard in GHC's exception system to figure out which exceptions *might* happen, because they can be thrown from another thread.
08:53:35 <CaleToronto> and happen asynchronously
08:53:42 <maerwald> refactoring a huge call stack to use Either instead of an exceptions just so you get compiler warnings about non-matched constructors isn't really feasable
08:53:52 <CaleToronto> Well... there's try
08:54:09 <CaleToronto> So you can sort of pick your battles like that
08:54:12 <CaleToronto> :t try
08:54:14 <lambdabot> Exception e => IO a -> IO (Either e a)
08:54:26 <maerwald> yeah, but that's still something I'd expect the compiler to do
08:54:53 <maerwald> but I know next to nothing about GHC internals, so I'll not complain
08:55:03 <CaleToronto> Also, refactorings like that are often easier than you'd expect
08:55:25 <CaleToronto> Because the compiler will help, you just start doing it, and run GHC, and it'll tell you what to do next.
08:55:37 <maerwald> I know, but it's not what I will do for my code
08:57:45 <maerwald> exceptions allow very concise code for some use cases
08:57:52 <maerwald> I'd rather not lose that
08:59:02 <maerwald> I just run "withErrorDialog $ do stuff" in my gtk+ callbacks and then throw the shit...
08:59:24 <CaleToronto> Yeah, there are some other options. Sometimes I'll end up defining some combinators which propagate or handle exceptions in a uniform way.
09:00:54 <CaleToronto> In a web application frontend using reflex-dom, I ended up writing some Applicative-ish combinators that would combine widgets that represented parts of a form, and propagate form validation failures in a couple ways.
09:03:35 <maerwald> what I need to improve still is to make exceptions more user-readable. That often means throwing stuff before low-level functions can throw it, so the user isn't presented with something like "canonicalizePath failed" while it's actually a permission problem
09:03:38 <CaleToronto> ($$?) :: (Applicative f, MonadWidget t m) => m (Dynamic t (f (a -> b))) -> Dynamic t (f a) -> m (Dynamic t (f b)) -- imagine f = Either ValidationMessage
09:04:01 <rom1504> so dynamic
09:04:07 <CaleToronto> That's probably a bit confusing if you're not familiar with reflex
09:05:35 <CaleToronto> But the idea is that actions of type m a here may construct part of a web page which has a result of type a -- in this case the Dynamics will represent the present values coming off of form fields.
09:07:35 <maerwald> I am currently wondering if I can make pattern matching a little bit less verbose, e.g.: "copyDir cm from@(_ :/ Dir _ FileInfo { isSymbolicLink = True }) _ = dosomething" is a bit confusing to look at
09:07:50 <CaleToronto> So alongside some other bits, I get to write things like  pure (constDyn (pure Contact)) $$? nameD $$? phoneD $$ emailD $$ companyD
09:08:49 <CaleToronto> (the $$ is similar, but for the case where the thing can't fail)
09:09:36 <CaleToronto> You might be able to use pattern synonyms somehow
09:09:45 <CaleToronto> (they're pretty new though)
09:13:50 <maerwald> looks like fun
09:14:18 <aspidites> whats the easiest way to read lucid error messages
09:16:18 <joorge> www.seadope.com
09:16:25 <aspidites> in particular this: https://github.com/aspidites/aspidites.github.io/blob/lucid/src/Templates/Index.hs
09:17:32 <aspidites> gives me this: https://gist.github.com/aspidites/2e96049502b5d19bc67d
09:17:40 <aspidites> when i uncomment the p_ line
09:18:43 * hackagebot modify-fasta 0.8.0.0 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.0.0 (GregorySchwartz)
09:19:11 <Aruro> guys, any native compression realizations in haskell? ala DEFLATE from zip?
09:20:23 <Aruro> on hackage i see only bindings to c libraries
09:22:04 <maerwald> I'd say it doesn't matter if those are bindings, as long as the bindings are high-level
09:22:25 <lispy> Aruro: That should be a fairly easy library to write, but I don't know if anyone has bothered
09:22:33 <Aruro> found it
09:22:38 <Aruro> its called pure-zlib
09:22:58 <maerwald> Codec.Compression.Lzma: compress :: ByteString -> ByteString
09:22:59 <Aruro> sorry for rushing here with questions. could have spent slightly more time in google :D
09:23:00 <lispy> Aruro: Is there a reason you want a Haskell implementation?
09:23:01 <maerwald> pretty high level
09:23:12 <Aruro> i just want to study it in haskell
09:23:15 <Aruro> thats all :)
09:23:16 <lispy> ah
09:23:33 <Zekka|Sigfig> You could write one!
09:23:39 <Aruro> https://hackage.haskell.org/package/pure-zlib
09:23:49 <Aruro> im going to write one soon :D
09:24:24 <aspidites> looks like I needed toHtml
09:24:37 <SrPx> I'm not sure if this can be phrased as a #haskell question, but reflex has a monad, WidgetHost, which has a MonadIO instance, and implements IO + sampling of FRP signals. GHCJS has a function inAnimationFrame which calls an `IO ()` action after some delay. Is it possible to send a WidgetHost computation to inAnimationFrame (which expects just IO)?
09:24:49 <Vincelaw> how can i define arbitrary instance of this data type: data LF a = LF [(a, Bool)] ?? pls help
09:25:16 <johnw> SrPx: what is the type of inAnimationFrame?
09:25:35 <johnw> it just takes an argument of type IO ()?
09:26:01 <mauke`0> Vincelaw: I don't know what Arbitrary looks like but it's probably trivial
09:26:49 <Vincelaw> mauke`0: i tried it different ways and cant do it, im still new in haskell
09:27:06 <johnw> Vincelaw: instance Arbitrary a => Arbitrary (LF a) where arbitrary = LF <$> arbitrary
09:27:18 <maerwald> mh, unidirectional pattern synonyms don't seem to work, ghc panics
09:27:41 <maerwald> are they not in 7.8.4?
09:28:20 <mauke`0> johnw: and shrink (LF xs) = map LF (shrink xs)?
09:28:26 <Vincelaw> what is <$> ? sorry im very noob d
09:28:32 <johnw> technically you don't need to implement shrink
09:28:36 <mauke`0> wait, in that case you could just newtype and derive
09:28:48 <johnw> <$> is an infix operator form of 'fmap'
09:28:50 <mauke`0> Vincelaw: another name for fmap
09:29:14 <Vincelaw> i was using oneof
09:30:20 <johnw> "dumb" Abitrary instances are completely automatic to write; it's the interesting ones that take thought
09:30:25 <bernalex> johnw: I wish you could derive Arbitrary, because you end up writing a lot of ones like that.
09:30:30 <johnw> yep
09:30:57 <johnw> writing some template haskell to auto-generate an instance like that would be pretty trivial
09:30:59 <bernalex> and often you end up writing weird subtypes that are basically a common type like Int but with special limitations for whatever reason.
09:31:29 <maerwald> it becomes more complicated if you need e.g. polygons with a range of properties
09:31:30 <bernalex> well, maybe not often, but I've certainly done it a handful of times.
09:32:01 <bernalex> maerwald: we're talking about instances that are literally instance Arbitrary a => Arbitrary (T a) <$> arbitrary
09:32:21 <bernalex> those are dead trivial.
09:32:55 <mauke`0> newtype T a = T a deriving (Arbitrary)
09:33:14 <bernalex> mauke`0: wait, you can do that?
09:33:27 <bernalex> I thought I checked that the last time I needed one
09:33:28 <johnw> if you have GeneralizedNewtypeDeriving on
09:33:37 <bernalex> ...
09:33:43 * hackagebot modify-fasta 0.8.0.1 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.0.1 (GregorySchwartz)
09:33:52 <bernalex> if I had the time I would go write some -300 line patches about now...
09:34:13 <bernalex> I think I'll go to a pub instead.
09:34:42 <Zekka|Sigfig> bernalex: That’s the spirit! Merry Christmas!
09:35:21 <jay6981> :t (<>)
09:35:23 <lambdabot> Monoid m => m -> m -> m
09:35:47 <qww``> Is there an inequality constraint? Instead of `~`?
09:36:50 <Zekka|Sigfig> qww``: I don’t actually know, but are you talking about a “could possibly not be the same” or “provably not the same” constraint?
09:37:04 <bernalex> qww``: do you want to write stuff like f : a -> anything but a -> b?
09:37:10 <merijn> qww``: Sadly, no
09:37:12 <bernalex> if so: you can't.
09:37:15 <Zekka|Sigfig> e.g. would yours say “different” for “Int” and “b” because there are cases of b where it doesn’t match Int?
09:37:34 <bernalex> merijn: I'm not sure if it is so sad
09:37:38 <merijn> qww``: Last time I asked "it wasn't going to be added", but I recently heard they might add it after all
09:37:52 <merijn> bernalex: Yes, because it doesn't allow you write invalid constraints
09:38:25 <merijn> qww``: Here is my awful hack: https://gist.github.com/merijn/6130082
09:38:44 * hackagebot lenz 0.1 - Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-0.1 (MatthewFarkasDyck)
09:38:46 * hackagebot clafer 0.4.3 - Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot.  https://hackage.haskell.org/package/clafer-0.4.3 (mantkiew)
09:39:50 <Zekka|Sigfig> merijn: So that one amounts to ‘if they could possibly be made to unify, then the typechecker must *die*, right?’
09:40:06 <merijn> Zekka|Sigfig: It produces a constraint that can never hold, yes
09:40:23 <merijn> It's like writing "Int ~ Char", except by using Symbol the error is at least SOMEWHAT more helpful :p
09:40:49 <Zekka|Sigfig> That wasn’t the operative part of my question, but I get you
09:41:05 <Zekka|Sigfig> This is something I’ve run up against in Prolog a lot
09:41:13 <Zekka|Sigfig> there’s two notions of “these terms are not the same” which people like to use
09:42:27 <Zekka|Sigfig> one is “these terms could never be made to unify” (what yours does) and one is “these terms can be made not to unify"
09:42:44 <qww``> Hm, thanks all
09:42:44 <Zekka|Sigfig> So for instance, “b” and “Int” can be made to unify, so yours will fail them
09:43:16 <Zekka|Sigfig> But there’s also an argument that “b” and “Int” are not the same, because you can make “b” something other than “Int” — you just happen not to have done it yet
09:43:36 <Zekka|Sigfig> (there are some wacky hacks people use to make sure order doesn’t matter that much there)
09:43:53 <Zekka|Sigfig> So I was just making sure that you were doing the first thing, which is what it looks like you did
09:44:07 <moop> @learn
09:44:07 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
09:44:18 <mauke`0> skolems! fresh skolems!
09:44:20 <moop> @learnhaskell
09:44:20 <lambdabot> Unknown command, try @list
09:44:27 <merijn> Zekka|Sigfig: Which is something different yet again from "I want 'b' to not unify with Int" i.e. "this only typechecks if 'b ~ Int' doesn't hold"
09:44:27 <Zekka|Sigfig> the second thing would involve letting the typechecker continue, but only by backtrackably forcing it to pick types other than the one you weren’t supposed to pick
09:44:58 <Zekka|Sigfig> merijn: Really? I’m pretty sure that’s the same as the first of my list of two things
09:45:08 <Zekka|Sigfig> mauke`0: Hold up, let me google a skolem
09:45:18 <moop> @list
09:45:18 <lambdabot> What module?  Try @listmodules for some ideas.
09:45:42 <moop> what was the other command like @learn
09:45:52 <moop> but with a not-haskellwiki link
09:46:54 <merijn> @where ?
09:46:55 <lambdabot> I know nothing about ?.
09:48:45 * hackagebot http-client 0.4.26.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.26.2 (MichaelSnoyman)
09:49:17 <Vincelaw> instance Arbitrary a => Arbitrary (LF a) where arbitrary = LF <$> arbitrary worked but it doesnt work when i write in another file
09:49:44 <johnw> can you clarify a bit?
09:49:52 <johnw> what does "doesn't work" mean, exactly?
09:50:38 <lamefun> Can't document GADT constructors?
09:51:56 <Vincelaw> i need to instanciate Arbitrary of data type LF (defined in a module) in a different file
09:52:21 <zipper> Hey the cabal equivalent for stack build is?
09:52:25 <zipper> I forgot
09:52:32 <zipper> cabal binary I mean.
09:53:28 <maerwald> this is confusing, the documentation says "pattern Head x <- x:xs where Head x = [x]" is valid pattern synonyms syntax, but GHC rejects it
09:53:39 <Vincelaw> i need to do something like: import LF and then define Arbitrary on data type LF
09:54:08 <quchen> maerwald: What's the error?
09:54:11 <merijn> maerwald: Which GHC?
09:54:16 <maerwald> parse error on input ‘where’
09:54:22 <quchen> Source code please
09:54:25 <maerwald> 7.8.4
09:54:35 <maerwald> quchen: I just posted the source code above
09:54:57 <merijn> maerwald: Does GHC even support those features? I don't think so?
09:54:59 <quchen> Did you enable PatternSynonyms?
09:55:02 <mauke`0> maerwald: no, the real source code
09:55:04 <maerwald> sure I did
09:55:47 <johnw> Vincelaw: create a module that imports LF and creates the instance; then, import *that* module everywhere you need both LF and the instance
09:56:09 <quchen> maerwald: The user's guide of 7.8 does not say "where Head x = [x]".
09:56:15 <quchen> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/syntax-extns.html#pattern-synonyms
09:56:33 <maerwald> quchen: it does
09:56:53 <maerwald> maybe I'm looking at another version
09:57:08 <maerwald> my link says "latest" instead of "7.8.4", so maybe that's it
09:57:24 <quchen> 7.8.4 is not the latest version, 7.10.3 is.
09:57:29 <maerwald> yeah
09:57:30 <mauke`0> latest is 7.10.2
09:57:38 <maerwald> didn't want to upgrade to that one yet
09:57:39 <quchen> I thought .3 was released
09:57:51 <mauke`0> http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
09:57:56 <mauke`0> documentation is at .2
09:59:45 <quchen> Strange, that should probably be changed.
09:59:59 <Vincelaw> johnw: i need to do it in same file
10:01:22 <johnw> I don't know what "in same file" refers to, Vincelaw.
10:02:33 <SrPx> johnw The type of inAnimationFrame is `inAnimationFrame :: OnBlocked -> (Double -> IO ()) -> IO AnimationFrameHandle`
10:02:35 <maerwald> can someone with a recent ghc version test if this works? http://lpaste.net/147660 I don't want to upgrade just to test it :P
10:02:47 <SrPx> It requires an IO, but I have a monad that implements MonadIO, but isn't exactly IO.
10:03:02 <johnw> SrPx: normally one solves this using MonadBaseControl, but your type doesn't provide that instances
10:04:10 <johnw> SrPx: the other possible is to pass your action, but "run" it down to the IO base class, if that is possible or makes sense here
10:04:46 <johnw> i.e., could I pass a StateT s IO action as an IO action, by passing: runStateT action initialState. It just wouldn't communicate state changes beyond its use
10:05:00 <johnw> (which is precisely what MonadBaseControl allows for)
10:07:01 <geekosaur> ...and if you need to communicate state changes, usually you use a ReaderT instead containing an IORef with the actual state in it
10:07:06 <Vincelaw> johnw: i need to import LF module and instanciate Arbitrary on data type LF on the file im doing quickcheck tests
10:07:25 <johnw> Vincelaw: and it doesn't work to just do what you said you need?
10:07:54 <SrPx> Hmm...
10:08:04 <mauke`0> shia.mp4
10:08:46 * hackagebot lenz-template 0.1 - Van Laarhoven lens templates  https://hackage.haskell.org/package/lenz-template-0.1 (MatthewFarkasDyck)
10:09:44 <Vincelaw> im getting error something like:  Couldn't match expected type `a0 -> LF a' with actual type `Newline' ..... sorry to bother you
10:11:37 <ReinH> Vincelaw: show us your code
10:11:40 <ReinH> and the error
10:12:10 <SrPx> Okay johnw I'm not sure how that applies to my case
10:12:17 <SrPx> But thanks :( 
10:15:18 <mauke`0> Vincelaw: the actual error, not "something like"
10:18:02 <Vincelaw> http://lpaste.net/147662
10:18:52 <mauke`0> where's the definition of ListaFavoritos?
10:19:10 <Vincelaw> oh sorry i forgot to translate it xd
10:19:14 <geekosaur> also the actual code, not "something like"
10:19:14 <Vincelaw> its LF
10:19:24 <mauke`0> try again. real code, please
10:19:55 <marrrk> Are there ever coupons for "Haskell from first principles"? $59 + VAT is a bit hefty for me.
10:22:06 <breadmonster> Crap.
10:22:20 <breadmonster> I joined #idris and started asking why the types don't line up.
10:22:38 <Vincelaw> http://lpaste.net/147663 here is all code
10:24:00 <pavolzetor> how would you represent something Car 4, Truck 6
10:24:08 <pavolzetor> I want a data type with some numbers
10:24:10 <mauke`0> Vincelaw: that's not all of the error message
10:24:28 <Vincelaw> it is o.0
10:24:45 <pavolzetor> but I also want to pattern match on the type
10:24:50 <mauke`0> Vincelaw: then why doesn't it contain line numbers?
10:24:58 <Vincelaw> oh
10:25:17 <pavolzetor> and don't wnat to do something like numberOfWheels :: Vehicle -> Int
10:25:23 <Zekka|Sigfig> marrrk: You could try to negotiate with bitemyapp, who is the author
10:25:30 <pavolzetor> and then typing all the data consructors
10:25:32 <mauke`0> Vincelaw: your problem is that ListaFavoritos doesn't export LF
10:25:32 <Zekka|Sigfig> I don’t know what he would say
10:25:39 <mauke`0> Vincelaw: the LF you're using comes from System.IO: http://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO.html#t:Newline
10:25:46 <mauke`0> hence the weird error message
10:25:50 <pavolzetor> in python it would be for example
10:26:00 <mauke`0> if ListaFavoritos did export LF, you'd get an error about it being ambiguous
10:26:08 <pavolzetor> {"type": "car", "nWheels": 4}
10:27:05 <pavolzetor> is it possible?
10:27:11 <ReinH> Zekka|Sigfig: I'm pretty sure he would say "no". It's a hefty price for a hefty book and hundreds (thousands?) of hours of work.
10:27:15 <Zekka|Sigfig> It’s a pity there isn’t an incredibly rich guy who can just feed bitemyapp’s pockets for writing his book
10:27:18 <Vincelaw> so if i use another name it should work? instead of LF?
10:27:23 <Zekka|Sigfig> ReinH: I wouldn’t be surprised
10:27:51 <ReinH> Vincelaw: not if you don't export and import it
10:28:07 <mauke`0> Vincelaw: no, then you'd just get an error about an undefined name
10:28:09 <Zekka|Sigfig> I have some friends from poorer countries and I don’t think his book would ever seem like a reasonable use of cash, which makes me sad because the parts of it I read were really good
10:28:14 <ReinH> Vincelaw: you need to export ListaFavoritos(LF) or ListaFavortis(..)
10:28:26 <ReinH> *ListaFavoritos
10:28:33 <Zekka|Sigfig> (I’ve gotten in a lot of stupid arguments with bitemyapp but I like the book itself a lot)
10:29:36 <marrrk> Zekka|Sigfig: I just bought it anyway. I'm disappointed that it's only PDF and no ePub.
10:29:57 <breadmonster> Zekka|Sigfig: Learn You a Haskell is also free.
10:30:11 <Zekka|Sigfig> breadmonster: I don’t like LYaH as much but it’s what I used and I tend to link people to it
10:30:48 <ReinH> LYAH is free and not good.
10:30:56 <Zekka|Sigfig> marrrk: Definitely stuff to bring up with him although my hunch is that this stuff is not on his mind right now
10:31:15 <ReinH> I've never heard anyone who read LYAH and said "I feel like I can use Haskell productively now."
10:31:29 <marrrk> It's just a plain LateX thingy there should be a pretty easy epub export.
10:31:39 <breadmonster> ReinH: That's because it's not meant to do that, it's meant to teach Haskell thought flows.
10:31:45 <breadmonster> RWH is the next step yeah?
10:31:58 <breadmonster> Though I wish bos made another edition, RWH is horribly old.
10:32:11 <ReinH> It is, but he doesn't have time to work on a new revision
10:34:03 <Zekka|Sigfig> In a better world everyone who’s obsessive enough to write a 1000-page book about their favorite subject matter would also be rich
10:34:21 <Zekka|Sigfig> then poor people would be able to read more books
10:35:02 <Zekka|Sigfig> Actually it’d be nice if everyone was rich, while I’m making wishes
10:35:27 <kadoban> breadmonster: Where does it say in LYAH that once you get to the end you won't be able to write any haskell, but you'll learn some thought flows? In what sense are you learning haskell if you can't actually use it once you get to the end?
10:36:32 <Zekka|Sigfig> IIRC LYAH very explicitly advocates you read RWH, but it also tries to act like you probably don’t need other resources
10:37:35 <Zekka|Sigfig> First Principles is the only Haskell book I’ve seen where that claim starts to sound feasible (although I’ve only read the first few chapters, so I don’t know how well it covers the stuff that a lot of other resources don’t provide adequate background for)
10:38:47 * hackagebot claferIG 0.4.3 - claferIG is an interactive tool that generates instances of Clafer models.  https://hackage.haskell.org/package/claferIG-0.4.3 (mantkiew)
10:43:48 <Guest00000> http://lpaste.net/147668 <- is this normal?
10:44:17 <geekosaur> Guest00000, yes
10:44:45 <jay6981> is there a trick to getting StringBufEditor.hs to run for cis 194 homework? i'm getting these errors: http://lpaste.net/147669
10:44:55 <geekosaur> you don't actually have a GADT there (so why is GADTs enabled?) and old style ADTs can't bring the Eq into scope
10:45:32 <kadoban> jay6981: The files are for an old version of GHC and there's a small error because of that. I can track down what line you need to change if you give me a minute.
10:45:34 <geekosaur> jay6981, what version of ghc are you using?
10:45:45 <jay6981> spring 2013 wasn't very long ago. bitrot already set in? 
10:45:58 <geekosaur> haskell can move quickly
10:46:02 <jay6981> geekosaur 7.10.2
10:46:26 <bergmark> "already" well... at one point between spring 2013 and now one thing changed :-)
10:46:31 <jay6981> bleeding edge :)
10:46:34 <geekosaur> ghc 7.10 changed the Applicative / Monad relationship, older ghc versions will not work as is with code assuming as ghc 7.10 does that Monad implies APplicative
10:46:44 <Guest00000> geekosaur: ? the 'works' works, the 'fail' fails, they both use the same type
10:46:48 <kadoban> jay6981: On line 38 in Editor.hs, add Applicative to the list of derived instances
10:47:20 <Guest00000> they differ only in what is used to pattern match
10:47:43 <jay6981> kadoban:  great, thanks!!
10:48:54 <kadoban> 'welcome. And yeah it's a little annoying. Tooling has progressed a bit since then, if cis194 had given its files as stack projects, this wouldn't be an issue (because it'd be specified which GHC would be used automatically)
10:49:30 <jay6981> on one hand its good to see something evolving so quickly. on the other hand it makes keeping up tough
10:49:53 <jay6981> but my learning experience has been overall quite rewarding so far
10:50:43 <kadoban> Ah good
10:50:57 <geekosaur> Guest00000, I couldn't tell you details off the top of my head, but in fact those do different things
10:51:47 <RaceCondition> is ghc --make supposed to behave identically on GHC and GHCJS?
10:53:39 <jay6981> apparently GHC has also improved quite a bit since spring 2013, there is no perceivable delay when running StringBufEditor.hs
10:54:40 <jay6981> time for a bigger file
10:55:52 <kadoban> RaceCondition: It could possibly be more productive to point out what specific behavior you're seeing that seems wrong?
10:57:08 <RaceCondition> kadoban, actually I think I just made them behave identically... I was going through `stack ghc` not GHC directly... all that was needed was a `stack clean` and `stack build`, and then GHC and GHCJS started behaving identically
10:57:18 <RaceCondition> no idea what had caused something to go out of sync
10:59:00 <geekosaur> Guest00000, specifically "works" uses a lambda instead of a let that binds nothing. beyond that I'm not sure what is going on that one brings the Eq into scope
10:59:28 <geekosaur> it is *probably* related to the GADT machinery but I couldn't say how. (and it might be a bug, since it's not a GADT...)
11:00:10 <Guest00000> "it's not a GADT" in what sense? it is not defined using GADT syntax?
11:00:24 <Guest00000> also i just tried bangpatterns
11:00:39 <geekosaur> it is not defined with GADT syntax
11:01:18 <geekosaur> non-GADTs can't bring constraints into scope by matching a constructor. but I don't know much beyond that
11:01:55 <Guest00000> i tried using GADT syntax too
11:02:02 <Guest00000> i think the cause isn't in the syntax
11:03:34 <SrPx> hoogle could have some kind of "wire the cables" function where you give an initial type (say, UV.Vector Int), a target type (say, ByteString#, from GHCJS) and it gave you a list of short compositions `fnA . fnB . fnC ...` that took type A to type B using only existing functions...
11:03:34 <drw> what is the "correct" way to encrypt a file on Windows?  I see lots of DIY examples (seems like a good idea for learning encryption, but not for production).  "salt" library looks like what I have in mind, but it only works on Linux.  How do people do this?
11:03:34 * SrPx is spending his life trying to find a way to go from unboxed vectors to JS TypedArrays :(
11:05:41 <kadoban> SrPx: There's the exferenceBot in here, though I have no idea if it's capable of such real-world examples like that.
11:06:03 <SrPx> So this is a thing? Interesting
11:06:49 <Guest00000> okay maybe because let binds nothing, Eq shouldn't be brought into scope. but a bang-pattern should be strict
11:06:54 <Guest00000> edited http://lpaste.net/147668
11:07:13 <geekosaur> it shouldn't be in scope at all; "works" is the bug
11:07:28 <geekosaur> it's not a GADT, it should not bring the Eq constraint into scope
11:08:16 <Guest00000> a GADT is more general than an existential
11:08:38 <geekosaur> (I was under the impression that a non-GADT *couldn't* bring it into scope, so I have no idea what is going on here)
11:08:41 <Guest00000> i don't understand why you think it's not a GADT
11:09:01 <exio4> Guest00000: the typing rules of let and lambdas are different
11:09:21 <geekosaur> GADT does not mean "any 'data ...' when GADTs are enabled". it means "data ... where ..."
11:09:47 <exio4> Guest00000: do { x <- a; f x; } gets converted into x >>= \x -> f x 
11:10:43 <johnw> a >>= \x -> f x
11:11:44 <geekosaur> I assume there are backward compatibility reasons why it cannot "promote" an ADT to a GADT. in any case, it does not
11:13:23 <johnw> is there a reason why an ADT isn't just simplified syntax for a GADT?
11:13:28 <johnw> (when GADTs is turned on)
11:14:03 <geekosaur> this bringing stuff into scope business is part of the reason, but I never really understood details
11:14:29 <geekosaur> and something has come up at work so I need to turn my attention elsewhere
11:16:24 <exio4> johnw: er, yes, sorry
11:16:42 <Guest00000> okay
11:17:15 <Guest00000> maybe add the feature of extracting dictionary to bang-pattern matching also?
11:20:42 <johnw> "extracting dictionary to bang-pattern matching"?
11:24:55 <Guest00000> johnw: "feature of extracting dictionary should be added to bang-pattern matching"
11:26:08 <monochrom> what dictionary?
11:26:54 <merijn> johnw: Yes, because GADTs lose all sorts of properties ADTs have
11:27:02 <merijn> johnw: Like injectivity, etc.
11:27:48 <merijn> johnw: Knowing something is an ADT (instead of a GADT that happens to not use some features) simplifies a lot of analysis
11:27:48 <johnw> merijn: ah, good answer!
11:27:58 <merijn> like parametricity, etc.
11:28:27 <johnw> merijn++
11:47:06 <SrPx> I have `newtype Pixel a = Pixel a`. Is it possible to add a `Storable` instance for newPixel, when `a` is storable?
11:47:14 <SrPx> for Pixel*
11:47:37 <aweinstock> SrPx: with GeneralizedNewtypeDeriving, just put "deriving Storable"
11:47:44 <exio4> SrPx: deriving (Storable) with..
11:47:51 <exio4> aweinstock: you were faster :P 
11:47:55 <SrPx> Awesome, thanks :)
11:50:46 <SrPx> Are storable/unboxed vectors different in terms of performance?
11:50:52 <SrPx> I don't quite understand yet why the need for both
11:52:12 <ReinH> SrPx: Storable is for vectors with raw block storage
11:52:29 <SrPx> But I assumed unboxed vectors did that too? 
11:53:28 <SrPx> Anyway, is OK to use this to convert from storable vector to bytestring without copying? https://hackage.haskell.org/package/spool-0.1/docs/src/Data-Vector-Storable-ByteString.html#vectorToByteString
11:53:42 <SrPx> It says it should work with GHC 7.0 (eh...), so I'm just double checking
11:54:31 <ReinH> SrPx: It should be. You can also mmap a file directly onto a storable vector or bytestring
11:55:32 <ReinH> e.g., you can turn any file into a vector of Word8 because that is the underlying raw block storage format
11:56:24 <SrPx> Now we just need something like Show except from/to an efficient binary format (:
11:57:24 <exio4> SrPx: deriving (Generic,Binary)? :P 
11:58:11 <ReinH> fsvo efficient
11:58:52 <SrPx> Amazing.
12:00:27 <Gurkenglas> Is there something like a "covariant lens" "??? f => (a -> f b) -> ((String, b) -> Double) -> f ((String, a) -> Double)"?
12:01:13 <{AS}> Hi, is there a simple interpreter for GHC Core?
12:01:54 <CaleAGO> I don't believe there is, but I could be wrong.
12:02:03 <Gurkenglas> I guess it would be "??? f => (a -> f b) -> (f (String, b) -> Double) -> ((String, a) -> Double)", or could the f somehow be gotten one level further up?
12:02:16 <{AS}> CaleAGO: OK, thanks for the answer.
12:02:22 <{AS}> I guess it would not be too difficult to make one
12:02:35 <{AS}> but I could be wrong as well
12:15:13 <aweinstock> does GHC core make reference to the GHC runtime? or is that introduced at a later stage?
12:18:14 <maerwald> is there anything I need to be worried about when using PatternSynonyms/ViewPatterns?
12:18:19 <CaleAGO> aweinstock: I suspect the answer to that question depends on what exactly "make reference to" means. It won't directly contain C calls to it as far as I'm aware, and doesn't explicitly manage memory yet even (though the language constructs more directly correspond to the allocation/evaluation that will be done)
12:18:25 <Gurkenglas> How do I write a data constructor that allows any a in that constructor fulfilling some constraints?
12:19:09 <CaleAGO> maerwald: Not as far as I'm aware, apart from the fact that PatternSynonyms is very new, so some people are probably still using GHCs which don't have it.
12:19:32 <CaleAGO> Gurkenglas: Write a separate function instead?
12:19:44 <maerwald> CaleAGO: I guess it's j
12:19:46 <maerwald> oops
12:20:05 <maerwald> just syntax sugar in the end for guard/case-of syntax, right?
12:20:09 <CaleAGO> yeah
12:21:27 <Gurkenglas> CaleAGO, how do you mean that? (My data definition contains " | Deterministically (Lens' s a) a | " but I need Bounded a and Eq a)
12:22:00 <CaleAGO> Oh, you just constrain the definitions which use the type usually
12:22:25 <CaleAGO> :t Data.Set.lookup
12:22:27 <lambdabot>     Not in scope: ‘Data.Set.lookup’
12:22:27 <lambdabot>     Perhaps you meant ‘Data.List.lookup’ (imported from Data.List)
12:22:51 <CaleAGO> :t S.lookup -- is it this?
12:22:53 <lambdabot>     Not in scope: ‘S.lookup’
12:22:53 <lambdabot>     Perhaps you meant one of these:
12:22:53 <lambdabot>       ‘M.lookup’ (imported from Data.Map),
12:22:58 <CaleAGO> Okay, M
12:23:02 <CaleAGO> :t M.lookup
12:23:03 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
12:23:23 <CaleAGO> ^^ note how the Ord constraint is not part of the definition of Map itself
12:23:46 <CaleAGO> It's just stuff which manipulates maps that needs the instance.
12:23:52 <Gurkenglas> But a doesn't appear on the part on the left of that data definition's =
12:24:08 <{AS}> Is it possible to lookup a function definition in Template Haskell and then e.g. modify it?
12:24:17 <CaleAGO> Gurkenglas: Oh, it's an existential?
12:24:20 <thewormkill> Hello everyone :). I am trying to write a typeclass that does roughly the following: It should define functions on 3 types r, v, i as presented in the code here: http://lpaste.net/147678 . The basic purpose is to compose said functions to something meaningful, but GHC can't deduce an appropriate instance, since the types are ambiguous. To be honest, I am unsure how I can resolve this ambiguity, if at all.
12:24:22 <thewormkill> The particular error describing my problem: http://lpaste.net/147679 . I guess it might be unclear what I want to achieve in particular, so please bear with me ;9
12:24:41 <Gurkenglas> CaleAGO, ...sounds right? Here's my current progress http://lpaste.net/147680 based on this paper http://research.microsoft.com/pubs/171611/tr.pdf
12:25:20 <CaleAGO> Gurkenglas: In that case, you might be able to forall a. (Eq a, Bounded a) => Deterministically (Lens' s a) a
12:25:34 <CaleAGO> however, I am very suspicious of the usefulness of that Eq constraint
12:26:07 <CaleAGO> It will be hard to prove that two such types a coming from different values of the type are actually the same in order to use your Eq instance
12:26:21 <{AS}> thewormkill: does it also hold that r -> i?
12:27:02 <{AS}> otherwise it might not be able to infer what instance you are looking for given the parameters that you gave it
12:27:08 <thewormkill> {AS}: yes. However, I had a functional dependency like: r -> i v , which yielded more errors
12:27:20 <{AS}> thewormkill: try r -> v, r -> i
12:27:39 <thewormkill> oh, didn't know that's a possible constellation. second
12:27:51 <{AS}> I believe that `r -> i v`needs i to be * -> k
12:28:10 <{AS}> since it is applying it to v
12:28:17 <{AS}> which I guess is not what you meant
12:28:26 <thewormkill> hm, the suggestion you made leads to errors as well
12:28:41 <thewormkill> paste coming
12:28:44 <{AS}> thewormkill: what errors are you getting?
12:28:45 <{AS}> OK
12:29:13 <thewormkill> http://lpaste.net/147681
12:29:18 <thewormkill> here you go {AS} 
12:29:19 <Gurkenglas> Cale, you could then write "Deterministically _1 True", right?
12:29:48 <{AS}> Ah that makes sense as well
12:30:07 <{AS}> finish does not take anything related to r
12:30:21 <thewormkill> true
12:30:38 <thewormkill> I could explain my design choices there if you wish
12:30:43 <{AS}> you may want either to use something like shadow types
12:30:50 <{AS}> or explicitly write type annotations
12:30:51 <CaleAGO> Gurkenglas: should be able to write something like that
12:31:01 <{AS}> phantom types*
12:31:17 <CaleAGO> However, if a is existential, you'll have forgotten that the second field is a Bool when you go to pattern match
12:31:30 <{AS}> thewormkill: sure, what are your design decisions?
12:31:43 <Gurkenglas> CaleAGO, you'll still have access to ==, right?
12:32:02 <thewormkill> Well the ideas is to encapsulate a request to an API I am building to avoid ugly small chunksof IO code
12:32:05 <CaleAGO> yes, but since you don't have any other values of type a, you can only compare the one value you have to itself
12:32:15 <CaleAGO> and you'll have a really hard time applying the lens to anything
12:32:17 <Gurkenglas> you do have [minbound..maxbound]
12:32:30 <thewormkill> so I have some IO when a request comes in and some IO after the (pure) processing has been done
12:32:39 <{AS}> Ah
12:32:39 <CaleAGO> Gurkenglas: if you include Enum as well, yes
12:32:49 <Gurkenglas> shoot
12:33:01 <thewormkill> since the processing requires some data not present in the request, we introduce i (intermediate data so to say)
12:33:03 <{AS}> thewormkill: so what is the r parameter?
12:33:15 <thewormkill> r is the type representing the request
12:33:25 <thewormkill> v is a return value of the whole oeration
12:33:40 <{AS}> thewormkill: could you define ApiResponse as
12:33:44 <thewormkill> ApiResponse is just a newtype for Either (using it for error handlinng and such)
12:33:52 <{AS}> ApiResponse r v
12:33:53 <{AS}> instead?
12:34:04 <{AS}> also you should consider using type members
12:34:32 <thewormkill> what exactly do you mean by type members?
12:34:40 <{AS}> class ApiResponse r where type Intermediate; type Result; ... 
12:34:54 <thewormkill> ah, alright
12:35:36 <{AS}> https://wiki.haskell.org/GHC/Type_families#Associated_type_instances
12:36:01 <{AS}> they are called associated type synonyms apparently
12:36:35 <{AS}> I think they are a bit nicer than functional dependencies
12:36:40 <thewormkill> aha. To get back to the design decision, how would you circumvent the problem I am trying to solve?
12:36:57 <{AS}> I would add a phantom parameter to ApiResponse
12:37:11 <{AS}> that parametrises over the request type it came from
12:37:27 <{AS}> e.g. data ApiResponse r v = ... 
12:37:32 <{AS}> where r is not really used in the right hand side
12:37:42 <thewormkill> okay, I'll do some research on that topic now, thanks for your help
12:37:51 <{AS}> sure :)
12:38:26 <{AS}> thewormkill:  if ApiResponse is more closely tied I would even include it as an associated type
12:38:48 <thewormkill> hm, I should read up on that as well
12:40:13 <{AS}> people are welcome to ship in, if they have better design ideas :)
12:40:19 <{AS}> chip*
12:41:38 <thewormkill> true. I had that idea during a boring lecture, so maybe I am completely lost without me realizing it
12:43:52 * hackagebot text 1.2.2.0 - An efficient packed Unicode text type.  https://hackage.haskell.org/package/text-1.2.2.0 (BryanOSullivan)
12:47:07 <thewormkill> {AS}: Awesome, I managed to fix it by using a phantom type :)
12:47:19 <{AS}> thewormkill: great :)
12:47:50 <thewormkill> basically added another type parameter to my ApiResponse newtype and used it to hold r everywhere :D
12:48:52 * hackagebot claferwiki 0.4.3 - A wiki-based IDE for literate modeling with Clafer  https://hackage.haskell.org/package/claferwiki-0.4.3 (mantkiew)
13:05:23 <Vincelaw> just want to tell the guys that helped me that i managed to fix my issue by adding {-# LANGUAGE ScopedTypeVariables #-} on my file and then do: instance Arbitrary a => Arbitrary (ListaFavoritos a) where   arbitrary = LF <$> arbitrary :: Gen (ListaFavoritos a)
13:08:45 <amalloy> i feel like i'm missing a really obvious way to think about this problem. i have a [k], and a function k -> [v], and what i want out is of type [[v]]. obviously map has the right signaturel, but what i want is: all ways of choosing exactly one v for each k. like for xs = [1,2,3] and f 1 = "a"; f 2 = "bc"; f 3 = "de", i'd want ["abd", "abe", "acd", "ace"]. is this just like...mapM, maybe?
13:10:34 <MarcelineVQ> > sequence ["a", "bc","de"]
13:10:36 <lambdabot>  ["abd","abe","acd","ace"]
13:11:13 <MarcelineVQ> Your intution is right though, mapM can do it
13:11:17 <MarcelineVQ> > mapM id ["a", "bc","de"]
13:11:18 <lambdabot>  ["abd","abe","acd","ace"]
13:11:21 <amalloy> well i don't have that list
13:11:29 <amalloy> i have xs and f
13:11:33 <amalloy> which is why i think it's mapM
13:11:33 <phadej> mapM f xs
13:11:35 <phadej> _
13:11:36 <phadej> ?
13:12:05 <amalloy> yeah, i think so. writing out my thoughts well enough to be a #haskell question made me figure out the answer by the end
13:12:24 <phadej> that happens, happy to be your rubberduck
13:13:53 * hackagebot modify-fasta 0.8.0.2 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.0.2 (GregorySchwartz)
13:58:54 * hackagebot wreq 0.4.1.0 - An easy-to-use HTTP client library.  https://hackage.haskell.org/package/wreq-0.4.1.0 (BryanOSullivan)
14:06:39 <castlelore> is yesod good
14:07:07 <thewormkill> that's not a very detailed question
14:07:26 <castlelore> is yesod competitive with other web frameworks in its class
14:07:43 <ReinH> what would those be?
14:08:04 <castlelore> lift comes to mind
14:08:29 <monochrom> let's just conclude this thread and move on. yesod is good. nothing to worry about.
14:08:33 <thewormkill> ^
14:08:41 <thewormkill> otherwise this leads nowhere
14:09:26 <Zekka|Sigfig> castlelore: Is there anything in particular you’re worried Yesod doesn’t do very well?
14:10:18 <castlelore> I was just wondering if anyone had any experience with it and knows whether it is suitable for production purposes or is it still in proof of concept stages
14:11:05 <Zekka|Sigfig> I haven’t done a production app in it but afaik fpcomplete has committed pretty heavily to it, and as far as I’ve seen its featureset is pretty complete
14:11:12 <pdxleif> I'd say it's production suitable.
14:11:25 <kadoban> castlelore: It's suitable for production, it's not an experimental project or anything.
14:11:26 <pdxleif> It's been around since 2010.
14:11:30 <Zekka|Sigfig> It has a good mapper from DB records to Haskell values, pretty complete support for templating, pretty good forms generation support, andi its really fast
14:11:34 <Zekka|Sigfig> it's*
14:12:04 <Zekka|Sigfig> (obvious disclaimer, if you write slow code in your Yesod application then that code will still be slow — but the overhead from Yesod itself is pretty low)
14:12:10 <castlelore> thanks! I'll comtinue digging :-)
14:13:44 <jle`> what exactly does "reify" mean int he context of haskell ... ?
14:14:08 <jle`> for example, the function from reflections, reifyNat :: Integer -> (forall n. KnownNat n => Proxy n -> r) -> r
14:14:27 <jle`> is the reification the process of turning value-level data into type-level data?
14:14:39 <jle`> making the integer "known"/"real" in the ty[pe?
14:14:43 * hackagebot language-c-quote 0.11.4 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.4 (GeoffreyMainland)
14:15:12 <jle`> or is it just a handwavey vague word like "list"
14:15:30 <jle`> er, "lift"
14:16:55 <ReinH> jle`: are you referring to things like data-reify?
14:17:12 <jle`> just the word "reify" in general when used in haskell
14:17:21 <jle`> if it's supposed to have any agreed upon general meaning
14:17:24 <maerwald> oh viewpatterns+pattern synonyms are so neat I have a feeling I am going to abuse them :D
14:17:37 <ReinH> In general, "reification" is the process of turning an abstract thing into a concrete thing. Just mentioning this for completeness.
14:17:41 <monochrom> I'm pretty sure every occurrence of "reify" is context-specific
14:17:57 <ReinH> A reified type is a value that represents a type.
14:18:14 <jle`> oh, i just looked at data-reify; i guess that's not what i meant...i meant in the scope of type-level/value-level play
14:18:29 <ReinH> But there are other ways to use "reify" in the context of Haskell
14:18:33 <jle`> ReinH: yeah, that's what i sort of felt...but `reifyNat` here seems to be opposite of that
14:18:45 <jle`> it seems to return a type that is dynamically generated from a value
14:19:11 <ReinH> jle`: reify in that context does seem to mean that
14:19:18 <jle`> hm, but maybe i'm reading it backwards
14:19:19 <ReinH> The docs say "Reifies arbitrary terms at the type level"
14:19:29 <ReinH> https://hackage.haskell.org/package/reflection-2.1/docs/Data-Reflection.html
14:19:52 <pdxleif> What "reify" in general means to me is to take something perhaps "active", and have a representation of it you can talk about as the object of something describing it; a sentence, some other functions, type sigs, etc.
14:20:04 <ReinH> Reification is probably dual to reflection in some sense, it is at least conceptually opposite.
14:20:49 <jle`> so in reifyNat, is the Integer the thing being reified, or the KnownNat n => Proxy n ?
14:20:49 <ReinH> jle`: so in your context, reify takes a term and yields a type that represents it.
14:20:57 <ReinH> The former.
14:21:03 <jle`> that's what i felt
14:21:14 <jle`> but what does that have to do with turning a type into a value that represents the type
14:21:19 <ReinH> It doesn't.
14:21:25 <ReinH> That's another context for reify
14:21:39 <ReinH> reify is a general term that can have many specific applications
14:21:41 <jle`> ok...so...it's a word that only makes sense in a specific context with a specific qualification
14:21:45 <ReinH> You could say that you are reifying it in each case
14:21:51 <monochrom> that direction is usually called reflection, e.g., Java reflection converts types to values
14:21:56 <maerwald> yeah, I still don't really understand what reflection is better at than implicit parameters, although I skimmed through the paper
14:22:07 <ReinH> monochrom: Kmett's reflection package does the opposite
14:22:18 <ReinH> reify takes terms to types and reflect takes types to terms.
14:22:26 <jle`> you could say that the continuiation is being reified by the value i guess
14:22:27 <ReinH> In that context, the concrete domain is the type system.
14:22:48 <ReinH> It is entirely context dependent, as monochrom originally said.
14:23:13 <jle`> so i guess it has a very "general" sort of intuition level meaning of "making abstract things concrete", but what is defined as abstract/concrete/things depends on the context
14:23:18 <jle`> and the same thing can be interpreted multiple ways
14:23:30 <jle`> words are weird
14:23:31 * frerich considered 'reify' to be in the same league of words as 'normalise'
14:23:31 <ReinH> See also: http://stackoverflow.com/a/5316014/2225384
14:24:03 <ReinH> Where Kmett basically repeats what I said, but before I did, so apparently the arrow of time means that I am repeatin him.
14:24:09 <ReinH> *repeating
14:24:40 <jle`> oh this answer is written by kmett
14:24:55 <ReinH> Yes.
14:25:00 <jle`> "Here the 'concrete' domain is the type system, and the abstract domain are terms."
14:25:05 <ReinH> Yes. I said that too. :p
14:25:15 <jle`> :P
14:25:37 <jle`> nice one :)
14:25:41 <ReinH> In the future, when you ask me questions, I will tell edwardk to answer you so you believe me. :D
14:25:54 <jle`> so i guess there's no absolute way of saying what's 'concrete' and what's 'abstract'...it's all on the interpretation...
14:26:01 <jle`> and once you pick an interpretation, reify/reflect come from there
14:26:09 <mjburgess> reify just means "make concrete"
14:26:24 <ReinH> jle`: I'm here and you are there. But according to you, *you* are here and *I* am there.
14:26:31 <mjburgess> eg. the people are the material reification of the dialectic 
14:26:45 <ReinH> Words require context.
14:27:00 <jle`> ReinH: heh, i believed you, but hearing about the specific library's interpretation by the library author gives clarity to the library's intent at least
14:27:01 <mjburgess> the singular word use comes from Marx i belive
14:27:23 <jle`> yeah, was just wondering if there was a decided-upon interpretation in haskell about what should be interpreted as concrete and waht should be interpreted as abstract
14:27:37 <jle`> but yeah, it's all on context it seems
14:27:41 <ReinH> jle`: There are multiple contexts within haskell as well
14:27:48 <pdxleif> I guess this is the def I think of: https://en.wikipedia.org/wiki/Reification_(knowledge_representation)
14:27:50 <jle`> so now i can use the word reify anywhere i want and dilute the meaning :3
14:28:00 <ReinH> Yes you can.
14:28:06 <ReinH> That is exactly what people do with words.
14:28:12 <jle`> words are neat
14:28:19 <ReinH> Words suck.
14:28:23 <jle`> no u
14:28:24 <pdxleif> Where the statement "John is six feet tall" is reified and used as the object of the sentence "Mary reports that John is six feet tall".
14:28:28 <jle`> sorry that was uncalled for
14:28:42 <ReinH> jle`: np
14:28:49 <ReinH> jle`: also your face
14:28:53 <maerwald> :D
14:28:57 <jle`> but u kno tho
14:29:08 <ReinH> bo knos
14:29:10 <jle`> mk got to go, but thanks for the answers
14:29:11 <frerich> jle`: Clearly, it's necessariy to reify 'reify'.
14:29:18 <jle`> frerich: heh
14:29:20 <ReinH> frerich: haha I beat you to that one too :p
14:29:28 <mjburgess> pdxleif: that just a use/mention distinction, its not reification
14:29:32 <jle`> but first we must reflect upon it
14:29:40 <frerich> ReinH: Tsk.
14:29:40 <jle`> only upon reflection can we reify reify
14:29:45 <maerwald> haskell takes so much meditation
14:30:05 <ReinH> maerwald: You are wrong, grasshopper. Haskell *is* meditation.
14:30:13 <pdxleif> mjburgess: That's the same thing we do in Haskell afaik?
14:30:14 <mjburgess> i dont think that wikipedia article is really clear or correct
14:30:36 <mjburgess> no because 1 isnt mentioning the type Int, its an instance of it
14:30:55 <monochrom> one person's poison is another person's abstraction
14:31:20 <mjburgess> "The sky is blue" is not an abstraction over the sky being blue
14:31:32 <hodapp> ReinH: The programming language that can also be meditation is not the true programming language.
14:31:32 <mjburgess> its one way of representing the situation in language
14:31:43 <ReinH> hodapp: there is no true programming language
14:31:54 <ReinH> they are all true programming languages
14:31:57 <monochrom> I say that a representation is an abstraction is a model.
14:32:22 <ReinH> Wow, this conversation is getting really abstract.
14:32:29 <mjburgess> that's just muddled as far as abstract/reify  are concerned
14:32:43 <maerwald> ReinH: abstract can be pretty specific though
14:32:45 <ReinH> Should... should we reify it?
14:32:50 <mjburgess> the type Int is not a model of 1, 2, 3....
14:32:55 <monochrom> yes, but I don't use the word "reify" lightly.
14:33:14 <maerwald> I hope there's not haskell newcomer reading this :D
14:33:17 <pdxleif> "The sky is blue" is a statement.
14:33:18 <ReinH> mjburgess: no, it clearly includes negative numbers as well. ;)
14:33:18 <maerwald> s/not/no/
14:33:50 <monochrom> "the type Int is not a model of 1, 2, 3...." is right or wrong depending on which "1, 2, 3..." you mean. (I am fine with "the type Int".)
14:33:54 <jle`> after reading this they aren't a newcomer any more
14:33:59 <jle`> we reified them
14:34:00 <maerwald> haha
14:34:16 <pdxleif> I think the use / mention distinction works.
14:34:26 <monochrom> for example, "1, 2, 3..." could mean the mathematical ones or could mean the Haskell ones
14:34:29 <ReinH> jle`: that's not how this works. That's not how any of this works.
14:36:14 <pdxleif> To me defs 3 & 4, or the etymology, apply on https://en.wiktionary.org/wiki/reification
14:36:59 <monochrom> wait, does it mean "reification" came from "thingification"? :)
14:37:18 <maerwald> I have a marvelous idea... using unsafePerformIO inside a view pattern 
14:37:20 <pdxleif> yeah, looks like
14:37:36 <pdxleif> Which makes sense with how it's used.
14:39:44 * hackagebot haskellscrabble 1.2.2 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-1.2.2 (happy0)
14:40:10 <monochrom> "hypostatization" is a cool name
14:50:15 * hackagebot pointful 1.0.7 - Pointful refactoring tool  https://hackage.haskell.org/package/pointful-1.0.7 (MikhailGlushenkov)
14:59:00 <chrisdotcode> can anyone tell me the difference between a category and a monoid, please? purescript's prelude explains it in such a way they appear to be the same.
14:59:23 <chrisdotcode> Oh, Semigroup and Semigroupoid are different?
14:59:43 <Welkin> a monoid is something that has a combining function and an identity value
15:00:03 <thewormkill> a commutative function that is
15:00:13 <thewormkill> crap no
15:00:15 <thewormkill> wait
15:00:17 <thewormkill> fuck, sorry
15:00:29 <chrisdotcode> Welkin: Yes - I know what a semigroup (and a monoid) are - but not sure what the difference between it and a category are; the PS prelude doc makes it seem the same
15:01:04 <MarcelineVQ> thewormkill: associative :>
15:01:13 <thewormkill> yeah
15:01:20 <thewormkill> I fuck up those terms always
15:01:43 <thewormkill> sorry
15:01:53 <thewormkill> I hate my brain in such moments
15:02:09 <thewormkill> trying to be a smartass => bam! fail ;)
15:02:57 <thewormkill> chrisdotcode: https://en.wikipedia.org/wiki/Category_(mathematics) this should help
15:03:11 <Welkin> chrisdotcode: https://wiki.haskell.org/Typeclassopedia#Category
15:03:33 <chrisdotcode> Welkin: thewormkill: so in general - how close are categories and monoids?
15:03:54 <aweinstock> :t (id, (.)) -- this is a catagory
15:03:56 <lambdabot> (a -> a, (b -> c) -> (a1 -> b) -> a1 -> c)
15:04:09 <aweinstock> :t (mempty, (<>))
15:04:10 <lambdabot> (Monoid t, Monoid m) => (t, m -> m -> m)
15:04:23 <Welkin> chrisdotcode: well, I don't know much about them other than what I read in the typeclassopedia and some introductory material for abstract algebra
15:04:42 <aweinstock> catagory composition is more "flexible" than monoid operation
15:04:43 <Welkin> I just thnkg of Category as what provides function composition (.)
15:05:08 <chrisdotcode> thanks everyone so far. one more question.
15:05:18 <chrisdotcode> aweinstock: what's the difference between a semigrop and a semigroup*oid*
15:05:23 <aweinstock> functions are both a monoid (via the Endo newtype) and a catagory
15:05:35 <pavolzetor> is there some tutorial or canonical example of implementing early exit BFS?
15:05:43 <aweinstock> I don't know what a semigroupoid is, but a semigroup is just a monoid without an identity element
15:05:55 <aweinstock> (e.g. (+) or (*) without 0 or 1)
15:06:12 <pavolzetor> https://github.com/pavolzetor/advent_of_code/blob/master/src/day22.hs
15:06:19 <pavolzetor> I need it for play function
15:06:32 <pavolzetor> (i.e. so it can terminate reasonably fast)
15:07:08 <thewormkill> well, I looked right now, but a groupoid is a group which is non-total
15:07:26 <pavolzetor> sorry I mean DFS
15:07:26 <aweinstock> according to https://en.wikipedia.org/wiki/Semigroupoid, it looks like it's a generalization of a semigroup? (every semigroup is a semigroupoid, but not vice-versa)
15:07:33 <thewormkill> and a semigroupoid would be a non-total semigroup following that logic
15:07:46 <Welkin> pavolzetor: just implement bfs and terminate upon reaching your target
15:07:58 <Welkin> pavolzetor: or dfs, doesn't matter
15:08:07 <thewormkill> aweinstock: yes, basically, that's how I understood it
15:08:07 <pavolzetor> Welkin: you do not know what the target is
15:08:18 <chrisdotcode> that's what I thought. that seems to make sense.
15:08:20 <chrisdotcode> thanks, guys
15:08:23 <pavolzetor> Welkin: you are trying to find minimum
15:08:31 <aweinstock> I'm not sure what an example of a semigroupoid that's not a semigroup is though
15:08:32 <pavolzetor> so I want to prune branches
15:08:49 <pavolzetor> in imperative language I would have some global state
15:09:07 <thewormkill> aweinstock: hm... paths in an undirected graph with no loopack edges?
15:09:22 <aweinstock> pavolzetor: I'd think of continuations when talking about early-exit
15:09:55 <thewormkill> they are non-total regarding composition, have no neutral element
15:10:11 <thewormkill> but I might be mistaken
15:10:50 <Guest00000> is it possible to unify a type with something at runtime? e. g. know if a type is list of something but don't care what exactly (like eqT)
15:11:06 <pavolzetor> aweinstock: something like Maybe monad?
15:11:16 <pavolzetor> I would preferably want something like
15:11:16 <aweinstock> thewormkill: what does "non-total" mean in this context? is it the same thing as "not closed under composition"? (I assume it's *not* directly "doesn't halt" or "non-strict")
15:11:34 <pavolzetor> MinMaybe >>= MinMaybe >>=
15:11:43 <Welkin> pavolzetor: how do you know you found the minimum until you traverse the whole graph?
15:11:44 <pavolzetor> so if it is nothing -> ignores
15:11:50 <thewormkill> well, non-total means the function we talk about is not defined for all possible inputs in our structure
15:11:59 <thewormkill> you can't compose any two paths in a graph
15:12:07 <exio4> Guest00000: using Typeable you can do things like that
15:12:07 <aweinstock> pavolzetor: do you have a link to your graph type?
15:12:20 <pavolzetor> welkin: it is a tree, so if I find one valid solution I can potentially prune
15:12:36 <pavolzetor> https://github.com/pavolzetor/advent_of_code/blob/master/src/day22.hs
15:12:39 <pavolzetor> the play function
15:12:40 <exio4> Guest00000: Data.Dynamic will encode (basically) a "dynamic type" within Haskell, using Typeable
15:12:42 <Welkin> pavolzetor: you mean it is a binary tree?
15:12:46 <pavolzetor> no
15:12:56 <pavolzetor> n-ary
15:13:00 <aweinstock> Guest00000: data HasEq = forall a. Eq a => HasEq -- but this isn't very useful
15:13:32 <pavolzetor> Welkin: you cna see that the function searches the solution space
15:14:03 <pavolzetor> and I want to discard all worse solutions early on if possible, that's why I use DFS (but I do not have early termination)
15:14:16 <pavolzetor> if I do not terminate the problem is exponential
15:15:24 <pavolzetor> I also need similar pattern for my ray tracers
15:15:28 <Welkin> pavolzetor: you mean you want to use branch and bound
15:15:31 <aweinstock> pavolzetor: this is somewhat of a tangent, but that problem description looks like it calls for dynamic programming, not a graph-based algorithm (at least at a first glance)
15:15:59 <dan2> pavolzetor, can I see?
15:16:25 <pavolzetor> Welkin: yes, I did not know it was named such
15:16:57 <pavolzetor> aweinstock: I am not sure about dynamic programming, since the chance of having same state is low probably
15:17:03 <Guest00000> oh well, i read Data.Typeable documentation more carefully and found it
15:17:12 <pavolzetor> dan2: what would you like to see?
15:17:18 <dan2> pavolzetor, what you're working on
15:17:59 <pavolzetor> dan2: this puzzle, I have correct solution for the samples, but the real input  is too big
15:18:00 <pavolzetor> http://adventofcode.com/day/22
15:20:53 <pavolzetor> aweinstock: how would the DP solution look like?
15:21:05 <dan2> interesting
15:21:40 <pavolzetor> if I use branch and bound, how would I handle the initial value ?
15:22:50 <monochrom> "you don't get to wear armor" and "your armor is increased by 7"
15:23:01 <aweinstock> pavolzetor: I'm not seeing a DFS in the code that's there, it looks like you have a greedy recursive solver?
15:23:09 <dan2> monochrom, I noticed that too
15:23:53 <pavolzetor> aweinstock: the recursive calls are DFS
15:24:05 <pavolzetor> monochrom: I do not follow?
15:24:10 <pavolzetor> *follow
15:24:31 <dan2> pavolzetor, it has to do with the fact that it says you can't wear armor because you're a wizard.  But one of the spells you can cast is to get armor
15:24:51 <dan2> pavolzetor, I don't know how dynamic programming can help you with this.  This seems like an optimization problem to me
15:24:52 <monochrom> consider "you do not have a wallet, but I will put $10000 into your wallet anyway"
15:25:30 <pavolzetor> monochrom: :)
15:25:34 <monochrom> in some interpretation, it means I don't have to spend that $10000, but people still think I'm so generous to you
15:25:35 <aweinstock> dan2: it's magical armor!
15:26:01 <dan2> aweinstock, heh.
15:26:25 <pavolzetor> dan2: I think it is simple DFS over solution space
15:26:41 <dan2> I don't know what DFS stands for in this context
15:26:44 <monochrom> problem with most fantastic RPG writers is that they write intuitively as opposed to logically.
15:26:47 <aweinstock> depth-first search
15:26:51 <pavolzetor> dan2: previous tasks I use LP and did rounding, but here many things can cahnge on the fly
15:27:40 <aweinstock> each node in the graph represents a game state (both player's hp, active spells, etc), and edges represent both players making 1 move each
15:27:54 <pavolzetor> monochrom: did you read ready player one?
15:28:06 <Welkin> aweinstock: a game tree
15:28:33 <pavolzetor> it does not seem like difficult problem, it is just difficult to do in haskell as beginner
15:28:54 <dan2> pavolzetor, hmm, I'm not sure how DFS works in this regard when we don't know the maximum depth of the tree.
15:29:17 <pavolzetor> dan2: imagine you are solving sudoku
15:29:24 <pavolzetor> dan2: having a solution space
15:29:32 <pavolzetor> when you find solution you stop exploring
15:29:48 <pavolzetor> damn, not good example, as depth is there fixed
15:29:53 <dan2> right
15:30:08 <pavolzetor> still here DFS should beat BFS because you can prune
15:30:16 * hackagebot HList 0.4.2.0 - Heterogeneous lists  https://hackage.haskell.org/package/HList-0.4.2.0 (AdamVogt)
15:30:26 <pavolzetor> well, BFS has been running for couple of minutes ;)
15:30:32 <dan2> this problem looks non-deterministic 
15:30:42 <pavolzetor> it is deterministic
15:30:51 <pavolzetor> since there is a global minima
15:31:09 <pavolzetor> anyhow, I am more interested in a pattern to solve these kind of problems
15:31:13 <aweinstock> how do you know when you can exit early?
15:31:20 <dan2> that's my question
15:31:27 <monochrom> pavolzetor: I did not read ready player one
15:31:44 <pavolzetor> awinstock: when you win -> valid solution -> prune everything with greater than solution
15:32:02 <pavolzetor> monochrom: just occured to me when you were talking about RPG
15:32:11 <dan2> are there any solutions that kill the boss that do not require you to "re-up" your mana, that at least puts a bound at spend on 500 mana
15:32:18 <aweinstock> is that what's called alpha-beta pruning?
15:33:11 <monochrom> dan2: "which minimum-cost plan should I use?" is non-unique. "the cost of each minimum-cost plan" is unique.
15:33:22 <Guest00000> :k []
15:33:23 <lambdabot> * -> *
15:33:33 <Guest00000> :k ForallF
15:33:35 <lambdabot>     Not in scope: type constructor or class ‘ForallF’
15:33:59 <dan2> monochrom, I'm aware, but having an upper bound of 500 input mana, limits the number of solutions generated.
15:34:08 <monochrom> true
15:34:11 <dan2> and since the problem is about killing the boss with the least amount of money spent
15:34:41 <dan2> you can use a binary search algorithm (by doubling or dividing) where the cut points are
15:34:56 <monochrom> I have a cunning plan. spend as many beginning turns as you can to recharge.
15:35:20 <dan2> monochrom, that doesn't help because the goal is to kill the boss with the least spend
15:35:25 <monochrom> kind of like "I grant you 3 wishes. what's your 1st wish?" "my 1st wish is to have 3 more wishes"
15:35:37 <pavolzetor> dan2: what cut points?
15:35:52 <monochrom> hrm, is that what the problem wants? it's hard to read.
15:36:08 <aweinstock> :t (\getEdges -> let dfs k startNode endNode | startNode == endNode = k startNode; dfs k startNode endNode = map (dfs k) (getEdges startNode) in dfs)
15:36:09 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a -> [b]
15:36:10 <lambdabot>     Expected type: a -> b
15:36:10 <lambdabot>       Actual type: a -> a -> [b]
15:36:17 <monochrom> anyway, a "cunning plan" is just meant to be funny, not successful :)
15:36:38 <dan2> pavolzetor, I meant exit points.  If you can determine you can kill the boss for 500 mana without using a recharge, then you can determine that one function isn't necessary.  Similarly, you can also break that down, by cutting it in half, and doing a binary search with brute force.
15:36:43 <pavolzetor> aweinstock: that does not do prunning
15:38:02 <pavolzetor> dan2: I see, not sure how would I find if I can kill him without recharge; looks at least like SDP
15:38:06 <dan2> pavolzetor, in fact, I'd first solve the problem by figuring out what the minimum amount of mana is to kill the boss, then I'd factor in whether or not recharges are necessary
15:38:21 <dan2> you can always "think outside the box" and solve with parameters you don't yet have first
15:38:26 <pavolzetor> dan2: would'nt that solve the problem in first place?
15:38:32 <dan2> not necessarily
15:38:49 <Guest00000> i tried "test :: ForallF Show f => f Int -> ShowS", "test = shows" but that didn't work. is there any way?
15:39:44 <aweinstock> Guest00000: is there a specific problem you're trying to solve, or is your goal learning about typeclasses/typesystem features?
15:39:48 <dan2> pavolzetor, my guess is there aren't any solutions that don't require recharges -- because it is a puzzle after all, but if you can figure out what can kill the boss assuming you had more mana, then you can figure out some bounds of your problem
15:39:48 <monochrom> what is "ForallF"?
15:40:11 <Guest00000> aweinstock: both...
15:40:58 <monochrom> in fact, I probably need emphasis.
15:41:04 <monochrom> what in hell is "ForallF"?
15:41:07 <aweinstock> what problem are you trying to solve?
15:41:30 <Guest00000> monochrom: it "lets you quantify over constraints", it's in Data.Constraint.Forall in constraints package
15:41:33 <dan2> pavolzetor, so basically, what we've done here is we split this into two problems instead of one, and used one solution to bound the other.  So before factoring in your own current state, first factor in what it would take to kill the boss if you were invincible and had infinite amounts of mana
15:41:34 <aweinstock> monochrom: I'd guess it's something that automatically wraps functors in existential types somehow?
15:41:54 <monochrom> alright, then I don't know Data.Constraint.Forall
15:42:13 <monochrom> is it really spelt ForallF or is it spelt Forall?
15:42:43 <Guest00000> ForallF
15:43:30 <aweinstock> dan2: assuming you have infinite mana doesn't change the minimum needed, but infinite health might change things if there's a slow-but-cheap way to win that wouldn't be fast enough to let you survive
15:43:30 <pavolzetor> dan2: I see, however I am not sure if it can be formulated as LP let say
15:43:59 <dan2> LP?
15:44:02 <pavolzetor> dan2: what I do not know how to model is the variability in choices
15:44:06 <monochrom> linear programming
15:44:15 <monochrom> or is it logic programming?
15:44:33 <pavolzetor> linear programming
15:44:34 <pavolzetor> https://github.com/pavolzetor/advent_of_code/blob/master/src/day21.hs
15:44:34 <aweinstock> monochrom: https://hackage.haskell.org/package/constraints-0.6/docs/src/Data-Constraint-Forall.html
15:44:41 <pavolzetor> this was similar puzzle
15:44:52 <kadoban> aweinstock: Assuming infinite does change it. If you have to spend a turn increasing mana, that could be the difference between a strategy being too slow or not.
15:45:08 <dan2> pavolzetor, why not just randomly select and use a set to make sure that you have no overlapping solutions?
15:45:11 <Welkin> why would you have infinite mana?
15:45:14 <Welkin> there is always a cap
15:45:17 <pavolzetor> but the constants were fixed at the start, so you can easily model it as LP and then somewhat round (it is actually IP)
15:45:18 <Welkin> like 99 or 999
15:45:41 <dan2> Welkin, for the purposes of problem solving, we can remove some constraints and then add them in gradually, that allows us to come up with an ideal solution to the problem
15:45:51 <Guest00000> aweinstock: i want to write generic code that operates on existential values like "Show a => a" but whose type is parametrised
15:46:49 <dan2> aweinstock, well that sets an upper bound on the number of turns you have to complete your solution
15:46:51 <Guest00000> e.g. data S1 f a = Show (f a) => S1 (f a)
15:46:56 <pavolzetor> I think we are slightly diverging, I am here to find a hammer ;), so current idea is to have foldr minMaybe Nothing list
15:47:06 <pavolzetor> minMaybe Nothing Just x = x
15:47:12 <pavolzetor> minMaybe Just x Nothing = x
15:47:18 <aweinstock> Guest00000: why not just write code that requires a (Show a) constraint?
15:47:27 <pavolzetor> minMaybe Just x Just y = pure (min x y)
15:47:34 <pavolzetor> minMaybe _ _ = Nothing
15:47:40 <pavolzetor> but this is ugly
15:47:43 <pavolzetor> :)
15:47:53 <Guest00000> aweinstock: i can't write (forall a . Show (f a)) => ... and that's what i need
15:47:55 <aweinstock> minMaybe = (<|>)
15:48:03 <Guest00000> if i'm not mistaken
15:48:21 <aweinstock> ah
15:48:27 <pavolzetor> how is it called?
15:48:42 <Guest00000> so, i could use S1, or could use a different solution which leads to less fluff in code
15:48:42 <aweinstock> can't you require (Show (f a))?
15:49:27 <pavolzetor> and then in traversal there would be a check 
15:49:50 <pavolzetor> I can't find <|> on google
15:50:18 <aweinstock> :t (let f g = (g [1,2,3], g (Just 5)) in f)
15:50:20 <lambdabot>     Couldn't match expected type ‘[t3]’
15:50:20 <lambdabot>                 with actual type ‘Maybe Integer’
15:50:20 <lambdabot>     Relevant bindings include
15:51:03 <aweinstock> :t (let f :: (forall h. Functor h a => b); f g = (g [1,2,3], g (Just 5)) in f)
15:51:04 <lambdabot>     ‘Functor’ is applied to too many type arguments
15:51:05 <lambdabot>     In the type signature for ‘f’: f :: forall h. Functor h a => b
15:51:05 <lambdabot>     In the expression:
15:51:22 <aweinstock> :t (let f :: (forall h. Functor h => h a -> b); f g = (g [1,2,3], g (Just 5)) in f)
15:51:23 <lambdabot>     Couldn't match expected type ‘b1’ with actual type ‘(a1, a1)’
15:51:23 <lambdabot>       ‘b1’ is a rigid type variable bound by
15:51:23 <lambdabot>            the type signature for f :: Functor h1 => h1 a1 -> b1
15:51:41 <aweinstock> pavolzetor: Control.Applicative (it's in the Alternative typeclass)
15:51:53 <aweinstock> :t Control.Applicative.(<|>)
15:51:55 <lambdabot>     Not in scope: data constructor ‘Control.Applicative’
15:51:55 <lambdabot>     Perhaps you meant one of these:
15:51:55 <lambdabot>       variable ‘Control.Applicative.pure’ (imported from Control.Applicative),
15:52:02 <aweinstock> :t (Control.Applicative.<|>)
15:52:04 <lambdabot> Alternative f => f a -> f a -> f a
15:54:04 <Guest00000> aweinstock: that's not easy, the `a' is hidden
15:54:13 <aweinstock> :t (let f :: (forall a h. Functor h => h a -> b) -> (b, b); f g = (g ['a','b','c'], g (Just 'e')) in f)
15:54:15 <lambdabot> (forall a (h :: * -> *). Functor h => h a -> b) -> (b, b)
15:58:29 <pavolzetor> thank you
15:58:45 <pavolzetor> these puzzles are great so I learn new haskell stuff
16:00:35 <pavolzetor> I will look into the continuation and state monad
16:00:39 <pavolzetor> also last thing
16:00:45 <pavolzetor> if you have bezier bicubic patch
16:00:48 <pavolzetor> (16 points)
16:01:03 <pavolzetor> and you want to subdivide it, how would you do that?
16:01:16 <pavolzetor> currently I have points in vector and use permute
16:02:05 <pavolzetor> so it solves the 4 paths and then reshuffles points back
16:02:08 <pavolzetor> not nice
16:02:20 <Guest00000> aweinstock: an example: http://lpaste.net/147696 - what to write in '???' ?
16:04:11 <aweinstock> I'm not sure
16:08:23 <Guest00000> if only we could write (forall x . Show (f x)) ...
16:09:25 <aweinstock> :t (\getEdges -> let dfs k startNode endNode | startNode == endNode = k startNode; dfs k startNode endNode = foldr (\x _ -> dfs k x endNode) undefined (getEdges startNode) in dfs) -- pavolzetor 
16:09:26 <lambdabot> (Eq a, Foldable t) => (a -> t a) -> (a -> b) -> a -> a -> b
16:10:02 <aweinstock> I'm not entirely sure if it's useful for you, but I think it's a somewhat-generic one-line dfs implementation
16:10:38 <pavolzetor> thanks, probably not for particular problem but in general yes ;)
16:10:41 <pavolzetor> thank you
16:11:16 <pavolzetor> it is scary how ugly code I am writing 
16:12:40 <aweinstock> > (\getEdges -> let dfs k startNode endNode | startNode == endNode = k startNode; dfs k startNode endNode = foldr (\x _ -> dfs k x endNode) undefined (getEdges startNode) in dfs) (\x -> [x+1, x-1]) id 0 5
16:12:42 <lambdabot>  5
16:13:51 <aweinstock> (infinite graph, each node connected to it's left and right neighbors, dfs only succeeds if the goal is to the right of the start, since edges are listed right-then-left
16:13:54 <aweinstock> )
16:14:45 <aweinstock> actually, I think the continuation plumbing I introduced there is completely superfluous...
16:15:24 <aweinstock> :t (\getEdges -> let dfs startNode endNode | startNode == endNode = startNode; dfs startNode endNode = foldr (\x _ -> dfs x endNode) undefined (getEdges startNode) in dfs)
16:15:27 <lambdabot> (Eq a, Foldable t) => (a -> t a) -> a -> a -> a
16:25:20 <pavolzetor> yey :)
16:28:43 <pavolzetor> rats, the way I have done the turns seems complicate part two
16:30:24 <Gurkenglas> http://lpaste.net/147680 I request refactorings, especially ones that would let me later change the definition of Distribution.
16:30:35 <Gurkenglas> (Based on http://research.microsoft.com/pubs/171611/tr.pdf )
16:30:40 <pavolzetor> I am doing it boss, me me boss; definitely will refactor later
16:31:08 <amalloy> i haven't used monad transformers much, but i think i want to combine State and Maybe somehow: i want a computation to carry around a Map of some state, and eventually fail if the map is exhausted before finding an answer. do i want a StateT s Maybe a, or a MaybeT (StateT s) a, or something else? and how do i actually do things inside it? or is there a good article that can walk me through this?
16:37:48 <kadoban> @unmtl StateT s Maybe a
16:37:48 <lambdabot> s -> Maybe (a, s)
16:37:54 <kadoban> @unmtl MaybeT (State s) a
16:37:55 <lambdabot> s -> (Maybe a, s)
16:38:00 <kadoban> In case those help.
16:39:48 <peddie> amalloy: rule of thumb for ordering transformers: in what order do you want to get the results?
16:40:30 <amalloy> s -> Maybe (a, s) looks like i want: it makes no sense for me to have a Nothing as the state and continue working. i just want to give up at that point
16:41:22 <peddie> it's not Nothing as the state; that would be 'State (Maybe s) a' (no transformers involved)
16:42:35 <peddie> if you don't care what the state is in the end, or you only want it when the computation succeeds, then you want MaybeT (State s) a, I guess
16:43:17 <Guest00000> with TH, is it possible to quote code from another module?
16:43:30 <Guest00000> like standard libraries
16:43:37 <peddie> amalloy: https://en.wikibooks.org/wiki/Haskell/Monad_transformers
16:43:57 <amalloy> i guess the API i was hoping to get is like...something that acts exactly like the State s a, except there's some magic value i can use to abort the computation and get Nothing. like: do {m <- get; modify f; if whatever then giveUp else return 5}
16:45:30 <johnw> Guest00000: what do you mean by "quote code from another module"?
16:45:37 <johnw> amalloy: you can mimick such an API in several ways
16:47:13 <Guest00000> johnw: get its AST representation, like [| |] does
16:47:41 <johnw> so, there's a function defined in a base module, and you want to retrieve it's parse tree?
16:47:46 <amalloy> peddie: so with MaybeT (State s) a, i could use Nothing as my "giveUp" function, and if i want to interact with the underlying State i'd use lift?
16:47:58 <johnw> amalloy: yes, that's one way
16:48:30 <peddie> or you could use the MonadError instance for MaybeT and "throw an error" to abort the computation
16:48:35 <monochrom> there is some chance you can omit "lift", too
16:48:38 <Guest00000> johnw: yes
16:48:55 <johnw> Guest00000: I'm not sure that much information is present in the .hi files
16:49:00 <amalloy> monochrom: maybe. i didn't see a MonadState instance for MaybeT
16:49:55 <peddie> amalloy: there is one: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Class.html  first instance listed
16:50:22 <amalloy> oh i see. i was looking for it in Maybe
16:50:55 <amalloy> interesting. i'll play with MaybeT (State s) a and see what happens
16:51:00 <peddie> good luck!  :)
16:51:11 <amalloy> thanks!
16:51:31 <johnw> amalloy: do you want to recover any state changes "leading up to the abort"?
16:51:34 <csd_> where in the ghc source are list comprehensions defined?
16:52:01 <johnw> if so, then you would use StateT s Maybe a
16:52:22 <johnw> @unmtl MaybeT (State s) a
16:52:22 <lambdabot> s -> (Maybe a, s)
16:52:30 <amalloy> johnw: no, i expect abort to actually never happen in practice. i'm doing this for an advent-of-code exercise where i expect all the problems to be solvable, and just adding the Maybe around it to get practice with transformers
16:52:30 <johnw> ah, sorry, I have that exactly backwards
16:52:36 <johnw> @unmtl StateT s Maybea
16:52:36 <lambdabot> Plugin `unmtl' failed with: `StateT s Maybea' is not applied to enough arguments, giving `/\A. s -> Maybea (A, s)'
16:52:37 <johnw> @unmtl StateT s Maybe a
16:52:37 <lambdabot> s -> Maybe (a, s)
16:52:58 <amalloy> and to avoid partial functions like !
17:05:23 <haskell224> Hey I'm trying to parse some data with Attoparsec. Let's say I want to match "Th" in the string "CThF2A1". Is there a build in way to separate the string to have something like ["C", "Th", "F2A1"]?
17:06:11 <Lokathor> i can do that in regex, but i'm not familiar with attoparsec sadly
17:07:37 <johnw> what would your regex be?
17:10:19 * hackagebot machinecell 3.0.1 - Arrow based stream transducers  https://hackage.haskell.org/package/machinecell-3.0.1 (HidenoriAzuma)
17:11:36 <mniip> haskell224, not "F2", "A1" ?
17:13:37 <haskell224> I only know what's valid
17:14:51 <mniip> by what priciple are you splitting?
17:15:18 <haskell224> advent of code 19
17:15:35 <haskell224> http://adventofcode.com/day/19/input
17:15:51 <mniip> >Puzzle inputs differ by user.  Please log in to get your puzzle input.
17:16:11 <haskell224> oh I forgot, well I have a string this form
17:16:18 <haskell224> CRnCaCaCaSiRnBPTiMgArSiRnSiRnMgArSiRnCaFArTiTiBS...
17:16:25 <johnw> if you show me the regex, I'll know what the attoparsec would be
17:16:38 <haskell224> and some "molecule" this form ThRnFAr
17:16:51 <haskell224> and I have to find the molecules in the string
17:17:01 <haskell224> and replace them, but that's another story
17:17:10 <mniip> sounds like a simple string substitution
17:17:23 <mniip> you don't even have to split into atoms
17:17:42 <haskell224> mmm, you're right, maybe I was overthinking it haha
17:18:52 <exio4> I would actually solve it with regexes
17:19:45 <sm> there's also the split library
17:20:14 <exio4> http://adventofcode.com/day/19
17:47:15 <LambdaCat> ?src ($)
17:47:15 <lambdabot> f $ x = f x
17:47:30 <LambdaCat> ?src Maybe
17:47:30 <lambdabot> data Maybe a = Nothing | Just a
17:47:46 <LambdaCat> ?src (Maybe)
17:47:46 <lambdabot> Source not found. Sorry.
17:47:55 <LambdaCat> ?src Functor
17:47:56 <lambdabot> class  Functor f  where
17:47:56 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:05:14 <LambdaCat> hello, everyone 
18:10:21 <Guest00000> LambdaCat: hi
18:14:20 <jellytux> any good tutorials for haskell?
18:15:08 <Cale> jellytux: A lot of people recommend http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
18:15:28 <jellytux> Cale: thank you
18:15:59 <Cale> jellytux: Feel free to ask any questions you might have here as you go
18:25:02 <osa1> does anyone know what's the size of floats read by standard read? I think it's not as big as native float.
18:25:37 <osa1> > read "1.21231123123" :: Float
18:25:40 <lambdabot>  1.2123113
18:26:17 <osa1> or... is this already bigger than 32bit?
18:26:37 <osa1> > read "1.21231123123" :: Double
18:26:39 <lambdabot>  1.21231123123
19:37:49 <OctoPi> could someone help me figure out what I'm doing wrong here? code: http://vpaste.net/VepvS error:http://vpaste.net/eFMBm
19:40:53 <Hijiri> OctoPi: encode probably takes a strict ByteString
19:41:22 <Welkin> encodeUtf8?
19:41:27 <Hijiri> or produces a strict one
19:41:28 <Welkin> yeah, it needs to be strict
19:41:33 <Hijiri> actually takes one
19:41:53 <Hijiri> actually produces, I think
19:42:04 <Welkin> oh
19:42:08 <Welkin> no there is a lazy version
19:42:08 <amalloy> OctoPi: i flailed around quite a lot with that one as well, and i still don't really understand how the various flavors of bytestring interact with string, but i do have my working solution, and you can maybe look at the bytestring parts of that and see what i'm doing differently? https://github.com/amalloy/advent-of-code/blob/master/day4/src.hs
19:42:56 <Welkin> amalloy: String is a list of characters
19:42:58 <amalloy> spoilers there obviously if you read onwards to future days' solutions
19:43:19 <Welkin> amalloy: Text is an array of UTF-8 bytes
19:43:28 <Welkin> and ByteString is an array of bytes
19:43:28 <Welkin> er
19:43:46 <amalloy> Welkin: i mean, i know that in theory. but i can't figure out how to turn one into the other, or which kind i have when i've got a bytestring
19:43:50 <Welkin> amalloy: Text is an array of 16-bit codes that are within UTF-8
19:44:04 <Welkin> just use toStrict/fromStrict
19:44:14 <amalloy> where are those?
19:44:23 <Welkin> http://hayoo.fh-wedel.de/?query=encodeutf8
19:44:31 <Welkin> most functions like this have a strict and lazy version
19:44:44 <Welkin> not sure what "encode" is in your context
19:44:48 <Welkin> an md5 hash?
19:45:08 <Welkin> it's not clear from the code OctoPi pasted
19:45:11 <exio4> Welkin: the actual encoding of Text (which isn't UTF8, btw) doesn't truly matter
19:45:13 <Welkin> he did not qualify any imports
19:45:34 <exio4> Welkin: you could say it is an "array of unicode codepoints" :p
19:45:42 <Welkin> exio4: yes, that is what I meant to say
19:45:57 <ezyang> What's the easiest way to take an SCC from Data.Graph and turn it into a cycle 
20:08:09 <echo-area> Attaching a phantom type to list (e.g. List n a) makes many functions invalid on them (e.g. foldl, foldr etc), this seems a drawback
20:09:02 <echo-area> *seems to be a drawback
20:12:53 <mniip> monochrom, still what do you mean when you say that a type is an algebra
20:20:26 <ezyang> ok, nvm 
20:21:37 <nshepperd> Guest00000: sounds like you want Show1?
20:22:59 <osfameron> can you compile Text.Hamlet to javascript (e.g. using one of the confusingly JS compilers)?
20:24:48 <osfameron> e.g. https://wiki.haskell.org/The_JavaScript_Problem lists for each fr example that it "compiles most pure Haskell libraries" or similar.  Is it just a case of trying each compiler in turn to see if it does what you want?
20:26:04 <wowdog> Hi, anyone know what is similar enum in Java in Haskell?
20:26:35 <kadoban> wowdog: The Enum class probably?
20:27:09 <osfameron> wowdog: abstract datatypes:  e.g. data Compass = North | South | East | West   ?
20:27:13 <peddie> wowdog: just define a sum type, e.g.    data Day = Monday | Tuesday | Wednesday deriving (Eq, Ord, Enum, Bounded)
20:27:49 <wowdog> thx
20:27:50 <osfameron> hmm, looking at markup.rocks, someone managed to get *pandoc* to compile with ghcjs
20:28:11 <osfameron> so I'd guess Hamlet should Just Work
20:40:27 * hackagebot yes-precure5-command 5.5.2 - Extended yes command to reproduce phrases in Yes! Precure 5.  https://hackage.haskell.org/package/yes-precure5-command-5.5.2 (igrep)
20:46:43 <wedens> what would be easier to use for free monad coproduct, operational or free?
20:47:20 <jle`> it all sort of depends on what you want to do
20:48:40 <wedens> jle`: what are criteria?
20:49:36 <jle`> i don't know any general guidelines, but if you have a specific application in mind, i can think about it
20:58:06 <wedens> jle`: ok. suppose I want to define one free algebra for DB operations and another for FS operations. and use this algebras in a coproduct
20:59:41 <Guest00000> nshepperd: ... yes, not only Show
21:03:18 <Guest00000> wait... this is a good idea...
21:03:46 <Guest00000> ah.. no, not good.
21:04:11 <Guest00000> i would have to add every method of the needed class
21:04:29 <Guest00000> a 1-version of every method *
21:06:03 <nshepperd> well, there's also a Forall in ekmett's constraints package
21:06:22 <Guest00000> so. i have tried it and it didn't work
21:07:14 <nshepperd> i don't know
21:08:11 <Guest00000> when i use ForallF with a concrete * -> *, it works. when i use a variable, it doesn't
21:08:53 <Hijiri> osfameron: ADT is algebraic data type rather than abstract data type when you are talking about things defined with "data"
21:09:48 <nshepperd> i don't remember what ForallF is for...
21:10:52 <Guest00000> for this thing.
21:11:04 <osfameron> Hijiri: rarr, yes, I mistyped, well spotted :-)
21:12:33 <Guest00000> (as it seems to me) you would use (Forall MyClass => ...) to require "instance MyClass a where ...", and you would use (ForallF MyClass F => ...) to require "instance MyClass (F a) where ..."
21:13:06 <Guest00000> but it doesn't work when instead of F there's a variable
21:13:38 <nshepperd> oh, you're right yes
21:14:14 <Guest00000> maybe what it does in this case is it straight requires "instance MyClass (f a) where ..."... i don't want that
21:14:35 <nshepperd> so the problem with Show1 is that you need Thing1 for many other classes?
21:14:40 <Guest00000> yes.
21:14:45 <Guest00000> (not very many though)
21:15:51 <Guest00000> "i don't want that" i want the caller of my function (which has type ForallF MyClass f => ...) to decide what `f' it wants
21:15:54 <ballzdeepinU> is virginia tech a good school for compsci and engineering?
21:16:27 <orb> Do you want to learn or do you want to get a piece of paper?
21:16:58 <orb> If you want to learn, it's mostly up to you anyway how much effort you put in.
21:17:27 <ballzdeepinU> orb: I want to learn. I'm not interested in getting a job at all.
21:17:41 <ballzdeepinU> orb: What are you implying about vtech?
21:17:42 <orb> oh, even job is easy.  I'm working at Google without a degree.
21:18:00 <orb> ballzdeepinU: I have no clue about vtech.  Was just talking about knowing what you want in order to make a decision.
21:18:14 <nshepperd> well, at last resort, you can certainly write a function of type (forall a. Dict (Show (f a))) -> Dict (Show (X f a))
21:18:31 <orb> ballzdeepinU: You might want to change your nick, if you want to be taken serious in a discussion.
21:18:43 <ballzdeepinU> orb: how did you teach yourself?
21:18:45 <nshepperd> or, (forall a. Dict (Show (f a))) -> X f a -> String
21:19:07 <nshepperd> you know, use a Dict in lieu of a proper typeclass constraint
21:19:34 <orb> ballzdeepinU: I studied some math, but CS was lots of mucking around as a hobby.  Reading and working through the classic books like SICP.
21:20:19 <nshepperd> this doesn't give you the instance, but it lets you call the function at least
21:21:05 <ballzdeepinU> orb: i tried SICP but put it down after the orders of growth section. lost it there with that theta notation stuff out of the blue.
21:22:13 <orb> I taught a friend last year. (She switched careers and just got her first programming job a few weeks ago.)  We looked into SICP.  It destroyed my nostalgia a bit.
21:22:28 <orb> I had very fond memories from working through SICP as a teenager, but the book has not held up well.
21:23:42 <ballzdeepinU> orb: what do you mean? dry presentation? too much in one blow?
21:24:31 <orb> Not nearly as well explained as How to Design Programs (even if HTDP is aimed at a more junior audience).
21:24:58 <orb> Lack of pattern matching (and types) makes Scheme a worse language to explain stuff in than ML inspired ones.
21:25:45 <orb> Their examples assume too much physics (and math) background.  I don't have too much of a problem with that, and neither did the MIT undergrads I assume, but I don't want to have to teach physics for some CS examples.
21:26:20 <orb> See Wadler's critique of SICP: https://news.ycombinator.com/item?id=2844747
21:26:38 <ballzdeepinU> do you find the theoretical side of things necessary in your work, orb?
21:27:12 <orb> Ha, at the moment I do Python-bashing (and worse languages) as an SRE for Google.  I try to fit in Haskell (and Haskell-like) things whenever I can.
21:27:32 <orb> For example, I just started using Hypothesis.  Hypothesis is a real great QuickCheck port to Python.
21:27:50 <orb> Replaces quite a lot of Python pain with Haskell-like happiness.
21:28:23 <ballzdeepinU> it seems like the real theoretical stuff in compsci isn't even used in the industry, not as much as i thought.
21:28:23 <orb> The theory is great fun, and helps with the interview process at Google, Facebook, etc.
21:28:37 <orb> Oh, it is used.  But mostly packaged up in libraries.
21:29:01 <orb> Eg even lowly Python has some great theory (and lots of engineering practice) behind their hashtable tuning.
21:29:18 <orb> But the average programmer, thankfully, doesn't have to worry about this.
21:30:19 <ballzdeepinU> have you used big-theta/big-o notation in your work often? everything in sicp was nice until i reached that section. even the exponentation section afterwards made more sense.
21:31:31 <kadoban> ballzdeepinU: You really need to know at leat the basics of asymptotic analysis probably, but much more than the very basics isn't exactly essential … though I think it's good info to have. You can read CLRS Introduction to Algorithms to get that.
21:32:11 <kadoban> There's a MIT OCW class available online by the same name that uses that book, it's quite good as well.
21:33:22 <ballzdeepinU> ah, so finishing SICP isn't a prereq to reading that algorithms book after all, huh?
21:33:41 <ballzdeepinU> i figured, if i couldn't get through SICP, i wouldn't stand a chance with that text.
21:33:58 <kadoban> They're separate things to study, I don't know that you'd really have to finish SICP to read that.
21:35:30 <ballzdeepinU> that's a long book.
21:36:03 <Guest00000> " In other words, a type inference system means that typing (of data) need not involve extra typing (with fingers). " :D
21:36:42 <ballzdeepinU> i just don't believe that people actually read these texts in their entirety, not as many people as the internet implies. 900+ pages? people don't read all of these technical texts like they say they do, they can't. it's possible, but i doubt it.
21:39:17 <kadoban> ballzdeepinU: You have many 900+ page books in your future if you seriously want to be a programmer of any ability.
21:42:05 <xacktm> interesting.. I finally found a use for flip :)
21:43:31 <xacktm> > map (flip isInfixOf "autocab") ["ab", "cd", "pq", "xy"]
21:43:33 <lambdabot>  [True,False,False,False]
21:43:59 <kadoban> xacktm: map (`isInfixOf` "autocab") …
21:44:06 <kadoban> xacktm: Though flip works too.
21:44:28 <xacktm> oh hrm
21:44:44 <xacktm> so it does, thanks
21:49:11 <zett_zelett> Declaring `data T x = V {z :: x}` creates type constructor T of kind (* → *) → *  – is that also possible without using record syntax (or at least without naming that `z`?
21:50:47 <Guest00000> zett_zelett: but the kind is * -> *
21:50:50 <Ralith> zett_zelett: are you sure about that kind?
21:51:28 <kadoban> I think you might be mixing up the kind and the type a bit.
21:51:46 <meep> @let data T x = V {z :: x}
21:51:47 <lambdabot>  .L.hs:150:16:
21:51:48 <lambdabot>      Ambiguous occurrence ‘z’
21:51:48 <lambdabot>      It could refer to either ‘L.z’, defined at .L.hs:156:14
21:51:54 <meep> @let data T x = V {zee :: x}
21:51:57 <lambdabot>  Defined.
21:52:00 <meep> :k T
21:52:02 <lambdabot> * -> *
21:52:34 <zett_zelett> Sorry, should be `data T x = V {z :: x Char}`.
21:53:06 <zett_zelett> @let data T x = V {zee :: x Char}
21:53:07 <lambdabot>  .L.hs:158:1:
21:53:07 <lambdabot>      Multiple declarations of ‘T’
21:53:08 <lambdabot>      Declared at: .L.hs:156:1
21:53:13 <zett_zelett> Ts.
21:53:27 <nshepperd> certainly, you can do 'data T f = T (f Char)'
21:53:36 <zett_zelett> Oh!
21:53:51 <zett_zelett> Weird, why didn’t I even try this?
21:54:34 <zett_zelett> nshepperd: Thanks, anyway.
21:56:58 <Guest00000> hmm....
21:57:09 <Guest00000> does the prefix syntax for '++' work here?
21:58:32 <MarcelineVQ> where
21:58:49 <Guest00000> in this channel
21:59:05 <amalloy> haskell works in this channel
21:59:18 <Guest00000> i mean the "name++"
21:59:25 <MarcelineVQ> ohkarma
21:59:28 <zett_zelett> What.
21:59:33 <amalloy> that's also not prefix
21:59:39 <Guest00000> yes
22:00:14 <meep> I don't think so
22:00:22 <meep> you have to use @karma+ nickname or something
22:08:45 <tpsinnem> hey, what does the empty "deriving" clause mean under "data Scheme" here?: http://haskell-servant.github.io/tutorial/client.html
22:09:23 <kadoban> tpsinnem: Never seen that before … I suspect it means nothing?
22:09:50 <tpsinnem> hm, i see that there's a #servant channel too, i guess i'll ask there as well
22:19:26 <Guest00000> oh hey...
22:22:33 <Guest00000> i used "(forall a . Dict (Eq (f a))) -> " in place of  "(forall a . Eq (f a)) =>" and it worked...
22:26:44 <wedens> is it possible to do with optics what opaleye does with arrows?
22:30:21 <quicksilver> what does opaleye do with arrows?
22:46:17 <xacktm> Hi, I have a line that maps three properties to each element in a list and counts the ones where all three are true - is there a more concise way to write this?
22:46:45 <pdxleif> Anyone use acid-state with yesod? Found https://www.reddit.com/r/haskell/comments/xs0t2/acidstate_with_yesod/ , but the domain being pointed at seems down.
22:46:47 <xacktm> toInteger $ length $ filter ((==) True) $ map and $ map (\s -> map ($ s) [prop1, prop2, prop3])
22:46:50 <pdxleif> Maybe just use sqlite or something?
22:48:53 <pdxleif> Hmm, found https://www.reddit.com/r/haskell/comments/xs0t2/acidstate_with_yesod/
22:49:01 <pdxleif> Oops, meant http://flygdynamikern.blogspot.com/2011/06/toy-url-shortener-with-yesod-and-acid.html
22:50:08 <kadoban> pdxleif: Yesod usually uses persistent, right? I'd probably use that with sqlite myself.
22:50:52 <Guest00000> xacktm: do you have an error with brackets?
22:51:03 <Guest00000> :t toInteger $ length $ filter ((==) True) $ map and $ map (\s -> map ($ s) [prop1, prop2, prop3])
22:51:05 <lambdabot> Not in scope: ‘prop1’
22:51:05 <lambdabot> Not in scope: ‘prop2’
22:51:05 <lambdabot> Not in scope: ‘prop3’
22:51:16 <Guest00000> :t \prop1 prop2 prop3 -> toInteger $ length $ filter ((==) True) $ map and $ map (\s -> map ($ s) [prop1, prop2, prop3])
22:51:18 <lambdabot>     Couldn't match expected type ‘[t0 Bool]’
22:51:18 <lambdabot>                 with actual type ‘[a] -> [[b]]’
22:51:18 <lambdabot>     Relevant bindings include
22:51:42 <exio4> it is, (\s -> map ($ s)) [prop1, prop2, prop3]
22:51:49 <Guest00000> :t \prop1 prop2 prop3 -> toInteger $ length $ filter ((==) True) $ map and $ map (\s -> map ($ s)) [prop1, prop2, prop3]
22:51:50 <lambdabot>     Couldn't match type ‘[b0]’ with ‘Bool’
22:51:50 <lambdabot>     Expected type: [a -> b0] -> Bool
22:51:50 <lambdabot>       Actual type: [a -> b0] -> [b0]
22:52:11 <Guest00000> exio4: again doesn't typecheck
22:52:24 <exio4> I see
22:52:46 <xacktm> no, it's a function where the last element is implicitly a list, so I can omit it
22:53:04 <exio4> @type toInteger . length . map 
22:53:05 <lambdabot> Foldable ((->) [a]) => (a -> b) -> Integer
22:53:10 <exio4> er, sorry
22:53:12 <xacktm> and prop{1,2,3} are just String -> Bools, and teh list is [String]
22:53:37 <exio4> xacktm: so you meant (.) instead of ($) up there?
22:54:47 <xacktm> exio4: no, s is the input string; the map (\s -> .... turns the [String] into a [[Bool]]
22:55:22 <xacktm> it essentially does [prop1 s, prop2 s, prop3 s]
22:56:08 <exio4> so you wanted to say \proplist -> toInteger . length . filter (== True) . map and . map (\s -> map ($ s) proplist)
22:56:44 <exio4> then, we could use (map f . map g) = map (f . g) 
22:56:55 <xacktm> wait no
22:57:10 <xacktm> \list -> toInteger $ length $ filter ((==) True) $ map and $ map (\s -> map ($ s) [prop1, prop2, prop3]) list
22:57:23 <xacktm> the list is at the very end
22:57:33 <exio4> \proplist -> toInteger . length . filter (== True) . map ( and . (\s -> map ($ s) proplist))
22:58:01 <exio4> xacktm: yes, you missed a parameter and I converted it to point-free style
22:58:20 <exio4> btw, filter id . map f = filter f , isn't it? 
22:58:31 <exio4> and (== True) is basically a monomorphic id
22:58:55 <exio4> > [(id True, id False), (True == True, True == False)]
22:58:57 <lambdabot>  [(True,False),(True,False)]
22:59:20 <xacktm> :t id
22:59:21 <lambdabot> a -> a
23:00:29 <exio4> \proplist -> toInteger . length . filter (and . (\s -> map ($ s) proplist))
23:00:52 <exio4> well, I'd also expand the (.) inside the lambda, and move things there a little bit
23:01:31 <exio4> \proplist -> toInteger . length . filter (\w -> and ((\s -> map ($ s) proplist) w)) 
23:01:58 <exio4> \proplist -> toInteger . length . filter (\w -> and (map ($ w) proplist)) 
23:02:08 <exio4> \proplist -> toInteger . length . filter (\s -> and (map ($ s) proplist)) 
23:02:21 <exio4> xacktm: is this something closer to what you wanted? 
23:02:28 <Guest00000> cool
23:02:43 <xacktm> wow nice, I think so
23:02:48 <xacktm> woo for referential transparency
23:03:06 * xacktm does a test
23:03:25 <exio4> I have tried to explain the reasoning I used but I was quite sloppy so I might have missed something
23:04:33 <exio4> toInteger . length . filter (\s -> and (map ($ s) [prop1, prop2, prop3]))  -- this should be equivalent to what you posted earlier
23:05:40 <Hijiri> also  "all ($s)" equivalent to "and . map ($s)" I think
23:06:09 <exio4> oh, I had missed that one
23:06:12 <exio4> Hijiri++ 
23:13:15 <xacktm> I'm not sure what's going on when you expand the lambda and insert the \w, but in general do you have to convert to point-free style to do these refactorings, or is it just easier to see?
23:13:23 <jle`> (\s -> all ($s) . [prop1, prop2, prop3]) could also be (and . sequence [prop1, prop2, prop3])
23:20:20 <xacktm> works great, thanks for teh possibilities all
23:22:27 <Guest00000> :t _
23:22:29 <lambdabot>     Found hole ‘_’ with type: t
23:22:29 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
23:22:29 <lambdabot>                the inferred type of it :: t at <interactive>:1:1
23:22:47 <Guest00000> :t (and . (sequence :: _) [prop1, prop2, prop3])
23:22:49 <lambdabot> Not in scope: ‘prop1’
23:22:49 <lambdabot> Not in scope: ‘prop2’
23:22:49 <lambdabot> Not in scope: ‘prop3’
23:23:05 <Guest00000> :t \prop1 prop2 prop3 (and . (sequence :: _) [prop1, prop2, prop3])
23:23:07 <lambdabot> Parse error in pattern: (sequence :: _)
23:23:12 <Guest00000> :t \prop1 prop2 prop3 -> (and . (sequence :: _) [prop1, prop2, prop3])
23:23:15 <lambdabot>     Found hole ‘_’ with type: [a -> Bool] -> a -> [Bool]
23:23:15 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
23:23:15 <lambdabot>                the inferred type of
23:23:39 <Guest00000> sequence for functions as monads...
23:24:08 <Guest00000> wait, it's very simple
23:25:09 <jle`> > sequence [even, odd, (> 0), (< 5)] 10
23:25:13 <lambdabot>  [True,False,True,False]
23:25:21 <jle`> > and . sequence [even, odd, (> 0), (< 5)] $ 10
23:25:25 <lambdabot>  F
23:25:46 <jle`> huh, first time i've seen that happen
23:25:54 <fr33domlover> hello! Q: some haskell packages depend on themselves - why is that?
23:26:55 <ReinH> fr33domlover: like what?
23:26:57 <pavonia> fr33domlover: That's usually the case if they include library modules and executable
23:27:28 <pavonia> where the executable depends on the library, that is
23:27:32 <fr33domlover> ReinH, many. For example, PastePipe. That is the case pavonia mentions
23:27:47 <fr33domlover> pavonia, are there other reasons or is that the only/main one?
23:28:24 <pavonia> That's the only I know of
23:29:18 <fr33domlover> pavonia, thanks
23:29:47 <pavonia> No problem
23:36:03 <pdxleif> Trying to decide between yesod and servant or something... :/
23:37:27 <pdxleif> Ooh, there's stack templates for both
23:42:03 <roelof> how can I install test.hunit and Data.Either.Unwrap with stack ? 
23:43:58 <kadoban> roelof: Put them in the .cabal file under build-depends (you have to use the package name, not the module; those are module names), then just 'stack build' and they get used like magic. If they're not in the resolver, usually meaning they're not in a stackage snapshot, you also have to add them to extra-deps in stack.yaml
23:45:33 <roelof> kadoban:  oke, so I have to add hunit and Either.unwrap  ? 
23:47:02 <kadoban> roelof: They're case sensitive. HUnit, and I don't know what the other one is, I've never heard of it.
23:48:57 <roelof> kadoban:  thanks, 1 down ,  1 togo 
23:51:48 <roelof> Here the package about Data.Either 
23:54:19 <Heather> hello, I need help with issue
23:54:20 <Heather> Failed to load interface for `Control.Lens.Type'
23:54:20 <Heather>  no package key matching `lens-4.13-6MQa6M9rvMsKvMzbCGMGLK' was found
23:56:36 <kadoban> Heather: What are you using to build? What's the error from? I don't particularly recognize that.
23:59:04 <roelof> kadoban:  I use it here : http://lpaste.net/147702
23:59:27 <Heather> kadoban approximate-0.2.2.3
23:59:32 <roelof> and the error comes from stack install command 
23:59:58 <Heather> kadoban using cabal install
23:59:58 <kadoban> roelof: That's just normal stuff from Prelude/Data.Either in base.
