00:43:16 <ReinH> pikZzZ
00:43:21 <ReinH> uh sorry
00:44:07 <ReinH> pikajude: what are you doing with the grid?
00:46:09 <ReinH> oh I'm a bit late to the party
01:10:50 <julianleviston> Ok so here I go again. :) I’ve been looking at GHC.Generics, Zippers, and GADTs… but none of them seem to do what I’d like. I have some types I’ve created. I’d like to use some representation types to model all these types with, but then (more importantly) I’d like to have data stored in these types (somehow!) and be able to work with the shape of this data. I can’t find anything that does this yet. Does an
01:10:50 <julianleviston> know of such a thing?
01:11:01 <julianleviston> I’ve also looked (a bit) at Comonads.
01:11:06 * frerich thinks http://learn.hfm.io/fractals.html is really a lot of fun to play with :-)
01:31:07 <fr33domlover> `cabal update` says "resource exhausted" - what does it mean? what do i do?
01:31:29 <fr33domlover> mentions file '/home/fr33domlover/.cabal/packages/hackage.haskell.org/00-index.tar26171.tmp'
01:35:25 <b4dmik3> 00Ciao a tutto il chan! Hard Rock!
01:35:47 <b4dmik3> 00Buon giorno ragazzi :)
01:36:00 <fr33domlover> b4dmik3, english please?
01:36:07 <b4dmik3> 00sorry :)
01:36:17 <b4dmik3> 00Hello everyone :)
01:36:33 <fr33domlover> b4dmik3, i see your messages in bold by the way
01:36:53 * frerich has to mark the messages in order to see them, it's white on white here. :-}
01:38:13 <b4dmik3> 00I'm new in programming haskell. I have a little problem understanding this piece of code:
01:38:21 <julianleviston> fr33domlover: translation: “hi/bye to everyone”
01:38:28 <julianleviston> (ciao can mean hi or bye I think)
01:39:11 <julianleviston> b4dmik3: your messages are white on white here, too (invisible unless we select them).
01:39:59 <xacktm> b4dmik3: hi, yes like everyone says, it would help if you neutered your colors, so to speak http://i.imgur.com/auOJW5V.png
01:40:26 <xacktm> (light grey is my default, but irrelevant)
01:41:39 <Slv3r> 00ciao a tutti xD
01:41:57 <Slv3r> 00hi, sorry for the italian message (automatic)
01:42:09 <Slv3r> 00you see mee too in white on white?
01:42:13 <Cale> yes
01:42:35 <fr33domlover> just tell your IRC client to not use color by default
01:42:48 <fr33domlover> send plain text plz :P
01:44:12 <Slv3r> 00now is fine?
01:44:34 <raichoo> nope
01:45:44 <Slv3r> 14oh sorry, now?
01:45:57 <julianleviston> better… grey lol.
01:46:02 <cocreature> now it’s grey on black for me :)
01:46:23 <Slv3r> 14yeah i can't select black, hope is fine in grey
01:46:36 <cocreature> you should just not send any color at all
01:46:44 <mniip> why are you even coloring your messages
01:47:18 <Slv3r> 14i don't know, there's no option for that :(
01:47:31 <Cale> It's presumably not Slv3r but whatever weird script is installed along with their IRC client. I don't think mIRC does that by default...
01:47:43 <mniip> sure doesn't
01:48:06 <b4dmik3> 00Yes, we have power script..
01:48:34 <b4dmik3> 14Yes, we have power script * :D
01:49:07 <raichoo> With great power comes great unreadability :P
01:49:57 <b4dmik3> 14It seems non to be any option to send plain text. Ahah raichoo :')
01:50:08 <FireFly> :\
01:50:16 <quicksilver> funnily enough the initial colouring b4dmik3/slv3r used was fine on my terminal, but the black they have switched to is almost impossible to read. So there you go.
01:50:53 <pavonia> Why are color tags even enabled here?
01:50:53 <b4dmik3> 14It should be dark grey, not black :/
01:51:09 <FireFly> Good reasons for not using colours on IRC: everyone has a different background colour
01:51:44 <Jinxit> if you have a good terminal scheme it will work out anyways
01:51:52 <Jinxit> my red is clearly not a red
01:51:53 --- mode: ChanServ set +o Cale
01:51:55 <quicksilver> color tags are useful, IMO. Some people use them to higlight or distinguish code from explanation.
01:52:02 --- mode: Cale set +c
01:52:50 --- mode: Cale set -o Cale
01:52:52 <Cale> Now *we* at least shouldn't need to be annoyed :)
01:53:06 <pavonia> Thanks Cale
01:53:08 <xacktm> there was a haskell irc client that printed color signatures too
01:53:21 <Cale> But yeah, colour used correctly can be useful
01:53:39 <Cale> They put it to good use in #idris
01:53:54 <Cale> syntax coloured bot responses :)
01:54:07 <fr33domlover> yeah, i have a bot using colors too
01:54:11 <fr33domlover> very useful
01:54:11 <quicksilver> xacktm: possibly this one - https://github.com/glguy/irc-core
01:54:55 <fr33domlover> by the way, i made irc-fun-color if anyone wants to encode styled irc messages :P
01:55:09 <xacktm> yes, the name rings a bell
01:55:28 <Slv3r_01> hope is solved now :D
01:55:49 <Cale> Yeah, well, we can no longer tell if your problem is solved since I turned on channel-wide colour filtering
01:56:03 <Cale> But it's effectively solved either way :)
01:56:04 <Mik3> Hi guys :D How is it now?
01:56:07 <Slv3r_01> oh cool :D
01:56:28 <Mik3> Oh, lol, we downloaded the plain mirc 7.34
01:56:58 <Cale> ah, that should also have fixed it
01:57:07 --- mode: ChanServ set +o Cale
01:57:12 --- mode: Cale set -c
01:57:34 <Cale> anyway, what was the question?
01:57:58 <Cale> Feel free to paste relevant code at http://lpaste.net/
01:58:47 <Mik3> What a fantastic server (chat.freenode.net)! I didn't think it could exist a community like this!
01:59:42 --- mode: Cale set -o Cale
02:00:19 <Slv3r_01> we have some problem understanding this piece of code : http://lpaste.net/147324      we know what it does (it takes a binary numer and convert it to integer) but we can't understand how it does
02:00:40 <julianleviston> Mik3: haha welcome to the internet circa 1990 ;-)
02:01:15 <julianleviston> Slv3r_01: what is the type of a Bit ?
02:01:17 <Fuco> Slv3r_01: it does https://en.wikipedia.org/wiki/Horner%27s_method
02:01:27 <Slv3r_01> Bit is integer
02:01:30 <Mik3> ahahahhahahahaha you're right ;D
02:02:12 <Slv3r_01> type Bit = Int
02:02:22 <julianleviston> Slv3r_01: so you’re asking how it converts an Integer list to an Integer?
02:02:40 <julianleviston> Slv3r_01: by the way, I don’t think it works very well… (\x y >…) should be (\x y -> ...)
02:02:54 <julianleviston> Slv3r_01: I mean, the syntax is wrong slightly.
02:02:57 <quicksilver> A list of integers which happen to be either 0 or 1
02:03:01 <julianleviston> Slv3r_01: so you don’t understand what a fold is?
02:03:03 <Slv3r_01> yeah is just an exercize 
02:03:10 <quicksilver> I assume that's the intention of type Bit = Int
02:03:34 <julianleviston> Slv3r_01: have you ever done recursion in Haskell before?
02:03:50 <julianleviston> Slv3r_01: folds is an abstraction over recursion.
02:04:00 <julianleviston> Slv3r_01: fold*
02:04:11 <frerich> Slv3r_01: If you evaluate 'foldr (\x y -> x + 2 * y) 0 [a, b, c, d, e]' you evaluate 'a + 2 * (b + 2 * (c + 2 * (d + 2 * (e + 2 * 0))))'
02:04:29 <Slv3r_01> yes but the problem is how foldr works with that operator
02:04:36 <julianleviston> Slv3r_01: what operator?
02:05:02 <Mik3> (/x y -> x + 2 * y) this operator
02:05:04 <julianleviston> Slv3r_01: this is not correct: (\x y > x + 2 * y)
02:05:06 <Slv3r_01> (\x y -> x + 2 * y) is not the operator of foldr?
02:05:07 <TheLemonMan> the almighy lazy foldr
02:05:10 <julianleviston> that’s a function.
02:05:21 <frerich> Slv3r_01: What you can always do is to consider the definition of 'foldr' and then manuall evaluate e.g. your function for e.g. '[a, b]'
02:05:40 <frerich> @src foldr
02:05:40 <lambdabot> foldr f z []     = z
02:05:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:06:36 <TheLemonMan> I don't quite recall the laws a Monoid should abide, but you could define a monoid over the Bit type and have mconcat do the work :)
02:06:41 <julianleviston> Slv3r_01: you should try to implement the recursion manually yourself to understand it, and then think about how you would write a function that lets you write ANY recursion.
02:07:03 <julianleviston> TheLemonMan:  that’s not appropriate here… s/he’s trying to work out how foldr works.
02:08:04 <Cale> TheLemonMan: only if it were a newtype
02:08:14 <Cale> but yeah
02:08:43 <Cale> Also, you'd end up with values of type Bit which were not 0 or 1 of course
02:09:40 <Cale> oh, and that wouldn't even work the same way
02:09:54 <Cale> because you'd surely have 0 <> x = x
02:10:36 <Cale> and so the zero bits would end up getting filtered out effectively
02:10:43 <quicksilver> Cale: the monoid woud be isomorphic to "0","1" under (++)
02:10:49 <quicksilver> Cale: the real identity would be ""
02:10:56 <quicksilver> Cale: "0" would only be a left identity
02:10:58 <Cale> quicksilver: If you used lists of bits, sure
02:11:04 <quicksilver> s/isomorphic/a quotient of/
02:11:33 <Cale> But if you were using single integer values, there's no piece of information which tells you how many bits wide the integer is supposed to be
02:11:50 <Slv3r_01> ok i'm trying to do recursion manually, but x takes the first element of my list, but y? what it takes? seems like y is the next step of recursion but why?
02:12:03 <quicksilver> Cale : data BMon = Nul | One | Zero | BMon :<>: BMon
02:12:14 <Cale> quicksilver: yeah, sure, that'd work
02:12:36 <quicksilver> Cale: but it is not the right way to answer the OPs' questions so I shall desist :)
02:13:16 <Cale> Slv3r_01: Okay, so every list in Haskell is either the empty list [], or it is a nonempty list formed by adding a single element x to another list xs, written (x:xs)
02:14:10 <Cale> Slv3r_01: What foldr f z does is to replace each occurrence of the (:) function in the construction of the list with the function f, and the occurrence of [] at the end (if any) with z
02:14:50 <Cale> For example, the list [1,2,3,4,5] is really syntax sugar for  1 : (2 : (3 : (4 : (5 : []))))
02:15:11 <Cale> and if we apply foldr f z to that, we get  f 1 (f 2 (f 3 (f 4 (f 5 z))))
02:15:30 <Slv3r_01> oooh you're right!!! that's why! y is the rest of my list! 
02:15:46 <Mik3> Cale, you're a master!
02:15:51 <Cale> It's the result of turning the rest of your list into an integer
02:16:24 <valentino> Hi folks, I'm new here :)
02:16:46 <Cale> Hello valentino, feel free to ask any questions you might have about Haskell
02:16:56 <Slv3r_01> yes! :D now is clear thanks Cale and thanks to anyone helped
02:17:12 <Slv3r_01> btw great community
02:17:30 <raichoo> Slv3r_01: Feel free to hang around ;)
02:17:36 <Mik3> Thanks to everyone guys! :)
02:18:20 <valentino> I posted a question on the haskell-cafe ml regarding Safe Foreign Calls, but i didn't get any response yet
02:19:33 <Mik3> Now we can go on studying haskell. I think that we will be here for next problems :'D
02:21:05 <Mik3> Thank You all again! Bye guys :)
02:21:08 <julianleviston> (reposting) Ok so here I go again. :) I’ve been looking at GHC.Generics, Zippers, and GADTs… but none of them seem to do what I’d like. I have some types I’ve created. I’d like to use some representation types to model all these types with, but then (more importantly) I’d like to have data stored in these types (somehow!) and be able to work with the shape of this data. I can’t find anything that does this 
02:21:09 <julianleviston> Does anyone know of such a thing?
02:21:11 <Cale> valentino: I see it, but I'm not sure what's going on there. What actually happens when you run the program?
02:22:25 <Cale> julianleviston: Well, that sounds vaguely what all the various "generics" systems are trying to tackle, like GHC Generics and scrap your boilerplate and so on.
02:22:27 <valentino> Cale: The program doesn't block on the wait_condition ccall
02:22:41 <phaazon> @pf 
02:22:42 <lambdabot> Maybe you meant: pl bf
02:23:09 <phaazon> @pl mdo { r <- newIORef q; q <- newIORef r }
02:23:09 <lambdabot> (line 1, column 5):
02:23:09 <lambdabot> unexpected '{'
02:23:09 <lambdabot> expecting variable, "(", operator or end of input
02:23:18 <julianleviston> Cale: does it? I’ve been looking at them, and so far, they seem to be about writing functions that work on a multitude of types… but what I want is to store a common datatype that I can convert a bunch of typed data into and from…
02:23:39 <liste> @undo mdo { r <- newIORef q; q <- newIORef r }
02:23:39 <lambdabot> <unknown>.hs: 1: 9:NamedFieldPuns is not enabled
02:23:40 <phaazon> I wonder how does this desugar with mfix
02:23:46 <arkeet> @undo mdo { r <- newIORef q; q <- newIORef r }
02:23:46 <lambdabot> <unknown>.hs: 1: 9:NamedFieldPuns is not enabled
02:24:00 <arkeet> oh I'm slow.
02:24:12 <julianleviston> Cale: so I have… “my types”, then “representation types” that generically wrap all these types, but they don’t wrap the DATA of “my types”. 
02:24:39 <Cale> I think this is maybe too vague for me to really understand what needs to be done :)
02:25:00 <julianleviston> Cale: How can I be more specific...
02:25:09 <phaazon> is it something like
02:25:17 <Cale> Are you maybe looking for something along the lines of Aeson?
02:25:25 <phaazon> mfix $ \q -> do { r <- newIORef q; q <- newIORef r }
02:25:30 <phaazon> I don’t see how that would work
02:25:38 <Cale> It has a Value type and some type classes for converting various types of values to and from it
02:25:48 <julianleviston> Cale: not really.
02:26:11 <Cale> I don't really understand what the word "wrap" means there
02:26:54 <julianleviston> Cale: I could use Aeson, but it’s primarily for building JSON, and so while I can convert to Value I can’t then use the shape of the original types (which I need to).
02:27:02 <liste> julianleviston so you have "data Foobar = Foobar Foo Bar" and "data FoobarWrapper = FoobarWrapper" ?
02:27:22 <Cale> julianleviston: What do you mean by "shape"?
02:27:39 <Cale> What is the shape of a type?
02:27:41 <julianleviston> Cale: I mean representative types
02:27:46 <julianleviston> Cale: it depends on the type.
02:27:54 <julianleviston> Cale: representation*
02:27:57 <Cale> Uh, in the sense of GHC.Generics?
02:28:01 <julianleviston> Cale: yes.
02:28:03 <fr33domlover> hmmm conduit has unix socket support but pipes doesn't :-/
02:28:16 <julianleviston> Cale: but they don’t let you store data of those types… just types as data.
02:28:34 <Cale> huh? That's not true.
02:28:42 <julianleviston> Cale: isn’t it?
02:28:42 <phaazon> I think I should use pipes / conduit more
02:29:02 <julianleviston> Cale: If I build a representation type, then its data is a Type, right?
02:29:19 <julianleviston> Cale: (not an actual type, but data of a type resperentation data type.
02:29:38 <Cale> GHC's generic representation types are just a collection of simple data types which together can be combined to form something isomorphic to any other type which you could make using data declarations.
02:29:48 <Cale> (non GADT data declarations)
02:29:52 <julianleviston> Cale: yes… 
02:30:06 <valentino> Cale: what i want to achieve is blocking a foreign call on a condition variable to block the haskell thread that made the foreign call
02:30:16 <julianleviston> Cale: but how would one build some data in a type of one of those presentation types?
02:30:30 <julianleviston> representation* (sorry)
02:30:45 <Cale> valentino: any means of causing the foreign call to block should also cause the Haskell thread which is running it to block.
02:31:00 <Cale> valentino: So I would guess that the foreign code isn't actually blocking for some reason
02:32:06 <julianleviston> Cale: I wouldn’t be actually using Generics, though, because Generics would actually build these representation types behind the scenes, but I want to actually use them…
02:32:33 <Cale> julianleviston: Well, the representation types have data constructors, and if you apply from/to in GHCi, you can see how the values relate
02:33:05 <julianleviston> Cale: yes, but they would only let me represent a type… what I want is to generically represent data of any of the types I’m representing.
02:33:15 <Cale> Prelude GHC.Generics> from "hello"
02:33:15 <Cale> M1 {unM1 = R1 (M1 {unM1 = M1 {unM1 = K1 {unK1 = 'h'}} :*: M1 {unM1 = K1 {unK1 = "ello"}}})}
02:33:49 <julianleviston> Cale: (so that I can build something that can edit the data of these various types I’m representing)
02:33:51 <Cale> Prelude GHC.Generics> from (Just 5)
02:33:51 <Cale> M1 {unM1 = R1 (M1 {unM1 = M1 {unM1 = K1 {unK1 = 5}}})}
02:34:30 <Cale> (it's really annoying and unwieldy, but you can see how the generic representation type is able to represent the value Just 5 there)
02:34:58 <julianleviston> Yeah but where is Maybe  recorded?
02:35:04 <julianleviston> it’s not, right?
02:35:17 <fr33domlover> julianleviston, it is afaik
02:35:19 <Cale> It's not.
02:35:23 <julianleviston> fr33domlover: where?
02:35:29 <fr33domlover> Cale, why isn't it?
02:35:30 <Cale> Maybe is a type, it doesn't exist at runtime
02:35:34 <verement> valentino: spurious wakeup?
02:35:41 <Cale> and it certainly isn't recorded anywhere in that representation
02:36:05 <julianleviston> Cale: but I need it to be. :)
02:36:06 <fr33domlover> Cale, what makes 'Just 5' different from '5' then?
02:36:21 <julianleviston> fr33domlover: the “shape” of the data! :)
02:36:28 <valentino> verement: yep
02:36:43 <Cale> That's a representation of Just 5, but it's also a representation of a bunch of values of other types
02:36:58 <Cale> julianleviston: Well, you could use Typeable as well
02:37:04 <julianleviston> Cale: aha! 
02:37:17 <julianleviston> Cale: ok time to look into Typeable :)
02:37:24 <Cale> Though I'm a little bit surprised that you "need" this
02:37:30 <Cale> What are you really trying to do?
02:37:40 <julianleviston> Cale: i’m all ears if you can think of a better way (or simpler! ) :)
02:37:51 <Cale> It might be far easier to think about what operations you'll be performing on the data, and record *those* instead.
02:38:02 <julianleviston> Cale: ok I want to explain it to you, so I need to know how best to do that.
02:38:19 <valentino> Cale, verement: the waitCondition of the RTS returns successfully
02:39:12 <julianleviston> Cale: I’ll pastie my general overview...
02:39:45 <julianleviston> Cale: http://lpaste.net/147327
02:40:06 <Cale> julianleviston: But what do the types and data represent?
02:40:10 <julianleviston> Cale: I used camel case for nouns in the overview because things get confusing.
02:40:18 <julianleviston> Cale: *which* types and *which* data?
02:40:22 <julianleviston> Cale: there are layers.
02:40:59 <Cale> julianleviston: Let's start with this... the program you're trying to write. When I run it, what happens?
02:41:24 <julianleviston> Cale: this is a hard question to explain the answer to.
02:41:34 <julianleviston> Cale: at its outer layer, it’s a Snap Application.
02:41:46 <julianleviston> Cale: but the pieces we’re talking about are inside that.
02:41:53 <Cale> Okay, so we're working on part of a web server
02:41:59 <julianleviston> Cale: no
02:42:12 <julianleviston> Cale: the code runs inside a web application, but it can also run standalone just fine.
02:42:12 <Cale> Ultimately
02:42:14 <verement> valentino: not sure you can avoid that; I don't know about the RTS, but POSIX doesn't guarantee that returning from pthread_cond_wait() means the condition is actually satisfied
02:42:19 <Cale> Sure, fair enough
02:42:19 <julianleviston> Cale: sure, if you like.
02:42:36 <Cale> Okay, so what concrete task does this part accomplish?
02:43:35 <julianleviston> Cale: I gave you an overview of the context for it… it’s this: GeneralType and a typeclass for it : A type and typeclass that can represent any of TheTypes data as one type, and convert between this type and its relevant type from TheTypes... we can then use a Zipper over the general type to traverse the data contained within it to build the templates.
02:43:37 <valentino> verement: the waitCondition() is just a wrapper of pthread_cond_wait()
02:43:47 <julianleviston> Cale: I’ll rephrase tho
02:43:56 <verement> valentino: OK, so I would expect spurious wakeups
02:44:23 <Cale> julianleviston: It's just really hard to provide advice about what types and functions you should write when the question is in the form of "okay, I have a bunch of types and values of those types"
02:44:29 <julianleviston> Cale: the piece I’m building lets me unify several types’ data so that I can join it into templates.
02:44:41 <Cale> It's much easier if I can just see the code and look at what those types actually are
02:44:52 <julianleviston> Cale: I can give you one example if you like…
02:44:59 <Cale> sure
02:45:01 <julianleviston> Cale: but they’re all very different from each other
02:45:31 <Cale> We'll never figure out what they're supposed to have in common if we don't look at what they are
02:45:53 <verement> valentino: typically you would have a loop around some predicate you have to test each time pthread_cond_wait() returns
02:45:56 <julianleviston> Cale: http://lpaste.net/147328
02:46:03 <julianleviston> Cale: that’s the thing. They don’t have anything in common.
02:46:18 <Cale> Okay, so why are you trying to abstract over them?
02:46:22 <julianleviston> Cale: so that pastie has one of the 7 sets of data.
02:46:26 <verement> valentino: or here, I guess, waitCondition()
02:46:34 <Cale> They must have *something* in common, or else you wouldn't be in this mess :)
02:46:43 <julianleviston> Cale: because they all need to go into templates.
02:46:46 <Cale> aha
02:46:51 <Cale> What are templates?
02:47:01 <julianleviston> Cale: yeah, they do have something in common - I want to be able to edit them :)
02:47:02 <valentino> verement: that seems the problem, i was not aware of this kind of behaviour
02:47:29 <julianleviston> Cale: templates are another data type.
02:47:58 <julianleviston> Cale: do you need to see them? they’re basically bits of text with holes in them (the holes are of type Param). 
02:48:25 <julianleviston> Cale: they end up as HTML in their final form.
02:48:35 <julianleviston> Cale: but it’s not blaze or anything.
02:49:02 <Eagiz> Hi all, I'm currently working on a problem that requires very fast lookup and for the Erlang version of the problem I used process dictionary due to its speed. The problem involves a lookup table with 2^16 entries and 2^27 lookups will be performed in total. I've tried IntSet and Unordered Containers but neither is fast enough for my problem. Any ideas for another datastructure? I would like O(1) lookup whe
02:49:08 <Eagiz> re the constant is small.
02:49:22 <Cale> Okay, so first dumb question is why not just store the corresponding templates instead?
02:49:48 <julianleviston> Cale: I’m not sure what you mean by store… the templates are editable too… so they’re composed in a tree...
02:50:13 <Cale> I mean, the problem seems to be that you have many different types, where you'd like to have one
02:50:25 <Cale> yeah?
02:50:46 <Cale> You're trying to come up with some single type which captures what you do with all of these various different ones?
02:50:47 <julianleviston> Eagiz: I wonder if Data.Map.Lazy will work for you - if you hoogle it, you should be able to find out the big O of it.
02:51:13 <julianleviston> Cale: no, I want to keep each type separate because all these groups of types do different things in the system.
02:51:18 <julianleviston> Cale: yeah :)
02:52:08 <Cale> julianleviston: My approach would be to find the operations you perform on these various types of things, and make records consisting of those operations, partially applied to the values in question.
02:52:09 <julianleviston> Cale: but it needen’t actually contain the entirety of the types, just the structure of their data, really… then I can easily build a similar typeclass as aeson’s ToJSON and FromJSON typeclasses to translate between these… 
02:52:22 <Cale> So that the interface would hopefully then become uniform
02:53:03 <Cale> Like, if the *only* important thing were "I can turn this thing into HTML", then you would just write functions for turning these various sorts of data into HTML, and you'd carry the HTML around instead.
02:53:08 <julianleviston> Cale: that’s the thing… there are no operations on them… all I’d be doing is using their shape to decide which sub-templates to use to represent caputring and working with their data (ie if the shape is a list, then it iterates over a subtemplate for example)
02:53:09 <Cale> Presumably there's more than just that :)
02:53:36 <julianleviston> Cale: no, the data needs to be very separate from the HTML.
02:54:22 <Cale> The data itself is, but once the only operation you ever have left to perform on something is to turn it into HTML, it might as well be HTML already
02:54:40 <Cale> But maybe that's not the only thing, maybe there are some other operations.
02:54:42 <Eagiz> julianleviston: it seems to be O(log n), but I will try it in practice and see it outperforms the other two that I've tried. I should add that a destructive read property would be appreciated in the datastructure as well.
02:54:59 <Cale> But we can figure out what all of those are, and record them all
02:56:07 <julianleviston> Cale: it’s not the only operation… because I need to change the data in various ways… and use the data in various ways (for example, I just showed you “Domains” related types, which are for handing the data that trives the domain-routing code of the app. That is,… how the web app should interpret requests.
02:56:09 <cocreature> Eagiz: what is a destructive read? or do you mean a destructive write
02:56:18 <Cale> (Oh, also, GHC.Generics will clearly be useless to you because there are functions and IO actions in your data)
02:56:51 <julianleviston> Cale: no there are no functions or IO actions… AFAK 
02:57:20 <Cale> you have an  M.Map String (ResponderApplicArgs -> Responder) and type Responder = SR.SystemRequest -> IO ByteString
02:57:25 <julianleviston> oh the Responder type. Sorry
02:57:49 <Eagiz> cocreature: When reading a value, it would be optimal for the algorithm to either get Nothing or a the value along with the same lookup table as before, but with the value removed
02:58:05 <cocreature> ah ok
02:58:06 <julianleviston> Sorry 8 and 9 aren’t part of this. My bad.
02:58:11 <Cale> okay
02:58:35 <julianleviston> Cale: apologies. I just pasted you all the types related to domains, not just the data related ones.
02:58:47 <Cale> Well, anyway, what's this editing you need to do?
02:59:09 <julianleviston> Cale: those two are for routing between the data and code (translating function names to function calls, for example).
03:00:11 <cocreature> Eagiz: there are some packages containing hashtables like https://hackage.haskell.org/package/hashtables which are probably similar to a dict in erlang (I don’t actually know how that’s represented internally)
03:01:29 <Eagiz> cocreature: Thanks, looks like it can be what I'm looking for. Will give it a try
03:02:02 <Cale> Eagiz: uh, is the lookup table dense?
03:02:31 <Cale> There are things like unboxed vectors which might be much better.
03:03:01 <julianleviston> Cale: editing is kind of the whole purpose of the app. It’s for editing structured data… 
03:03:52 <Cale> Oh, so it's not really Haskell types you're talking about, but types in your application's language, effectively.
03:04:20 <julianleviston> Cale: um… yeah, but they’re haskell types.
03:04:26 <julianleviston> Cale: coz it’s written in haskell :)
03:04:28 <julianleviston> Cale: right? :)
03:04:33 <Cale> Not necessarily
03:05:00 <julianleviston> Cale: ok. 
03:05:32 * hackagebot wiring 0.4.2 - Wiring, promotion and demotion of types.  https://hackage.haskell.org/package/wiring-0.4.2 (seanparsons)
03:05:33 <julianleviston> Cale: how can you represent types in your application (if it’s written in Haskell) that are not actually written in Haskell? Sorry if I’m being stupid here.
03:05:56 <Cale> If you were writing a Haskell interpreter, you wouldn't generally be representing values of type [Integer] or Maybe String with values of type [Integer] or Maybe String
03:06:46 <julianleviston> Cale: fair point.
03:07:00 <Cale> (Especially when there can be data declarations introducing new types that you as the author of the interpreter can't predict)
03:07:20 <julianleviston> Cale: I’m not really writing a language, though, am I?
03:07:55 <Cale> Maybe not, but it sounds kind of similar, if you're allowing the user to define and edit data of arbitrary types
03:08:16 <julianleviston> Cale: yeah, I suppose so.
03:09:05 <Cale> (especially if they're allowed to define the types that those data belong to)
03:09:21 <julianleviston> Cale: template editors are just concerned with editing templates. They just want to be able to connect up “general data” from the Domains types… so that Domain editors can edit that data.
03:09:38 <julianleviston> Cale: yeah, they’re not allowed to redefine these types (yet! ;-0)
03:09:59 <julianleviston> Cale: that is (still) the job of the Program Editor (Programmer) (at the moment, just me).
03:12:10 <julianleviston> Cale: so would your recommendation be to build my own set of generic data-representation types that work together to describe any type of data that can be represented by these types? The only trouble THEN, though, is that I need a way to represent the shape of these pieces of data for the template editors to be able to hook their subtemplates into… :) (it’s reasonably complex, sadly)
03:12:14 <cocreature> Cale: an unboxed vector only really helps if you are looking up ints, right?
03:13:12 <Eagiz> Cale: The numbers are generated by a hash function, they seem to mostly be negative numbers but I haven't analysed if they're dense or not. (They are all integers however)
03:13:15 <julianleviston> Cale: would IntMap not be quite efficient?
03:13:24 <julianleviston> Eagiz: did you look at this? https://hackage.haskell.org/package/containers-0.5.7.0/docs/Data-IntMap-Lazy.html
03:13:57 <Eagiz> julianleviston: Haven't had the time yet ("lunch break")
03:14:03 <Cale> Eagiz: okay, so not likely to be all that dense
03:16:51 <Cale> julianleviston: So for each of these types, you have a way to construct a user interface for the domain guys to input values of that type, and you also have a way to convert the obtained value into something which will be spliced into a template, yeah?
03:18:54 <julianleviston> Cale: yeah… I’ve got that bit pretty well handled… and I was thinking of using a zipper to traverse the structure into the templates/sub-templates which would be fine, so long as I had a single respresentational data type that would be able to fit the right shape. (Hope you know what I mean by shape now… I mean a map has a sequence of two items… a list has a sequence of single items, etc.)
03:19:12 <julianleviston> Cale: (handled at least in my mind - I’ve thought through ways to do most of that stuff)… 
03:19:19 <Cale> I'm going to go the other way: let's pick a representation which will work independently of the shape of the date
03:19:21 <Cale> data*
03:19:27 <julianleviston> Cale: yep...
03:19:35 <julianleviston> Cale: actually I don’t follow...
03:19:47 <julianleviston> Cale: what does independently mean there?
03:21:12 <Cale> Okay, so there's a really cute thing about functions which build values of some type T. Once the value of type T is built, the parameters to the function which built it could have had any types whatsoever, and you'd never know
03:21:23 <Cale> Also, locally defined things :)
03:22:19 <valentino> verement: the problem was a spurious wakeup, testing waitCondition() in a loop fixed the problem! :)
03:22:37 <valentino> verement: thanks a lot! ;)
03:22:48 <verement> valentino: glad you were able to fix it
03:22:54 <julianleviston> Cale: maybe I need to concretize this for you a little… say I’m a template editor… and I’m building (in the application, somehow) a template for someone to edit some Domain data…. say I want to add a new domain to my web application… let’s say it’s “localhost”… so I need *some* way for my template editor to “know” that a domain list is a map of domain name matchers (String) to a Map of path (Str
03:22:54 <julianleviston> to function names (String). This is a shape.
03:23:19 <julianleviston> Cale: crap that was less than helpful.
03:23:41 <Cale> So, maybe the unifying type looks something like   data Object = Ob { domainUserInterface :: HTML(?), handleDomainUIRequest :: Request -> Object, templateSplice :: HTML }
03:23:53 <Cale> I'm saying HTML there, but really that's not important
03:24:00 <Cale> It could be an IO action
03:24:08 <julianleviston> Cale: Basically the person editing the template needs a way to build a template for editing domains such that it fits the data into it… the data has the type Domain. The application uses this data to actually do routing as well as the template / editors use it to be edited.
03:24:11 <Cale> it could be a reflex-dom widget :)
03:24:46 <julianleviston> Cale: yeah that’s fine, except that’s ONE of the seven groups of types I’m talking about having.
03:24:58 <julianleviston> ie it’s ununified. If it was just that I’d have no problem at all.
03:26:33 <Cale> julianleviston: For each of the types of things which the domain people edit, you have some way of presenting the domain person with an editor UI
03:26:50 <Cale> julianleviston: You have some way of collecting or parsing a response from that UI
03:27:00 <julianleviston> Cale: sure… but they’re all editable by the Template editor (because they’ll use common elements, etc.)
03:27:03 <Cale> and you have some way of producing the thing which will then go into the template
03:27:21 <Cale> Yeah, that's fine, but that's another layer we'll worry about in a sec
03:27:23 <julianleviston> Cale: yeah that part isn’t a problem. I’ve got that already written.
03:27:45 <julianleviston> Cale: the thing already builds templates and has editors and whatnot. They’re just very basic, and hard-coded as haskell data at the moment.
03:29:08 <Cale> So what I'm suggesting is a single type
03:29:50 <Cale> Whose fields are the things you need to be able to do with a value of any of these types being edited by the domain people and spliced into the template people's templates
03:31:08 <julianleviston> Cale: It doesn’t matter whether it’s a single type or separate - I’ll still have to deal with the fact that I’m passing different data to the templates and the templates should not “know” about the types of the rest of the application.
03:31:40 <Cale> Nope, it'll be the same type, won't it?
03:32:05 <Cale> This is like an HTML template right? It's a document and you're splicing pretty-printed values into it?
03:32:15 <julianleviston> Cale: you’re talking about packing capacity for all the different types of data into one big type, right?
03:32:33 <Cale> Vaguely, but the way I'm doing it might not be how you think
03:32:56 <julianleviston> Cale: No, I’m extracting data from different points of the data tree to control both the shape of the template and the data that it contains.
03:33:28 <Cale> Wait, maybe I have a completely incorrect view of what a template is
03:33:37 <Cale> I have no idea what this application is for still
03:33:49 <Cale> We just have people editing some meaningless values into forms
03:33:56 <julianleviston> Cale: for example, in the template for editing Domains, I’d want to be able to make it to show a list of the domains.
03:34:05 <julianleviston> Cale: it’s for editing web apps.
03:34:14 <julianleviston> Cale: and rendering them.
03:34:25 <julianleviston> Cale: it’s the next version of my web application system.
03:34:44 <julianleviston> Cale: for running a host of websites that various clients can edit their websites with.
03:36:07 <julianleviston> Cale: but the current version is only able to edit text (it’s written in less capable languages : ruby on the backend, clojure on the frontend)… but this one has actually typed information that can be edited (so the semantics of the template contents can provide functionality to their construction - simple example… a list of date-sorted items)
03:36:10 <Cale> Oh, so a template is like an example piece of data?
03:36:37 <julianleviston> Cale: I don’t want to confuse you
03:36:41 <julianleviston> Cale: so I’m going to say “no”
03:36:53 <Cale> okay
03:37:10 <Cale> I originally thought our templates were like Heist templates
03:37:24 <julianleviston> Cale: I apologise for not being more specific
03:37:33 <julianleviston> Cale: Templates are my own custom code and types.
03:37:46 <Cale> I mean, something vaguely like taht
03:37:47 <julianleviston> Cale: and they’re just stitched pieces of text.
03:37:47 <Cale> that*
03:38:07 <julianleviston> Cale: in a recursive datatype (ie a template can include other templates)
03:38:38 <quicksilver> an editable template like that is commonly referred to as a 'form'
03:38:46 <quicksilver> if I am following what you are saying.
03:38:59 <julianleviston> quicksilver:  that’s confusing, because a form is an HTML thing.
03:39:33 <julianleviston> quicksilver: meaning there’s an HTML element called a form.
03:39:36 <Cale> julianleviston: Should I think of it as a piece of text with some holes in it where data will go?
03:39:49 <julianleviston> Cale: tha’ts precisely correct.
03:39:59 <julianleviston> Cale: it’s parameterised text.
03:40:00 <Cale> (where data which has been converted to a string in a particular way will go)
03:40:13 <julianleviston> Cale: exactly.
03:40:16 <Cale> Okay
03:40:21 <Cale> Good, so I was right before
03:40:24 <julianleviston> Cale: the final rendering is simply :: ByteString.
03:40:38 <quicksilver> forms  in this sense predate HTML by some 20-30 years
03:40:52 <quicksilver> although I can see why you'd want to avoid a confusion false analogy.
03:42:02 <Cale> julianleviston: Okay, so one of the things that all your various sorts of values have in common is that they all have some means of being converted into a ByteString for that final splicing, yes?
03:42:19 <julianleviston> Cale: yep.
03:43:25 <Cale> Another thing that they all have in common is that you have some way to present the people editing the data with some sort of user interface for editing the current value
03:44:06 <Cale> and you have some way of taking a response from that user interface, and turning it into an actual new value, yeah?
03:44:07 <julianleviston> Cale: sure.
03:44:21 <Cale> Anything else on this scale which is important?
03:44:27 <julianleviston> Cale: theoretically (that hasn’t been finalised) 
03:44:36 <julianleviston> Cale: I don’t think much of that is important, so I’m not sure.
03:44:40 <Cale> Okay
03:44:45 <Cale> So, let's look at this type
03:44:59 <julianleviston> Cale: which one?
03:45:05 <julianleviston> Cale: the general one I want?
03:45:07 <Cale> (the one I'm going to write)
03:45:27 <julianleviston> Cale: ok… so the thing you missed was that it needs to contain the shape of the original data.
03:45:43 <julianleviston> Cale: including whatever constraints that entails.
03:45:57 <julianleviston> Cale: so if the original data is [String], then it should provide this.
03:46:07 <julianleviston> Cale: that is, a List “shape”…
03:47:01 <julianleviston> Cale: If I’m correct in my thinking, I think you might be envisaging writing a type for the Templates which I already have which is called ContentMap whereby the “holes” are plugged with String-like-data. Is that right?
03:47:04 <Cale> Yeah, but that's already taken care of by presenting a different editor and a different thing to splice in, right?
03:48:01 <Cale> So long as we present the user with an editor which lets them edit a list where we need to, and so long as that list gets turned into the correct thing to splice into the document, everything is good?
03:48:37 <julianleviston> Cale: it’s not just lists, though… it’s all kinds of shapes.
03:48:41 <Cale> sure
03:48:49 <Cale> But you can write UIs for them all
03:48:53 <Cale> yeah?
03:49:10 <julianleviston> Cale: no, this is the problem
03:49:13 <Cale> At least in principle?
03:49:34 <julianleviston> Cale: No… I’m building a template editor.
03:49:41 <Cale> Maybe there are infinitely many, but they're built up from finitely many parts
03:49:42 <julianleviston> Cale: part of “editing” a template is connecting up the data.
03:49:51 <julianleviston> Cale: this is the entire point of my problem.
03:50:43 <Cale> My point is ultimately that really one of these values consists of the following:
03:50:52 <Cale> * A bytestring (the thing which would be spliced)
03:51:23 <Cale> * Some representation of a user interface for editing the value, which produces some parseable response
03:51:49 <Cale> * A parser for that response, which produces a new value of the type which I'm presently describing (recursion!)
03:52:44 <julianleviston> Cale: sure. However you’ve just elided the structural problem.
03:52:45 <Cale> If you can build one of these records, it doesn't matter how you store the data internally :)
03:53:23 <Cale> And you can build one of these records using a recursive function whose argument is of any Haskell type whatsoever
03:53:43 <Cale> and where the parser recursively applies this function
03:54:11 <julianleviston> Cale: sure… that’s the zipper portion… 
03:54:15 <julianleviston> Cale: which isn’t the problem I’m having.
03:54:19 <Cale> This isn't a zipper
03:54:38 <julianleviston> Cale: hm.
03:54:53 <julianleviston> Cale: recursive structure of any data type?
03:54:58 <Cale> Let me give a different example
03:55:02 <julianleviston> Cale: sounds zippery to me.
03:55:05 <Cale> Suppose we're writing an animation program
03:55:10 <julianleviston> Cale: anyway, you’ve skipped the structure part.
03:55:20 <julianleviston> Cale: the structure matters to the templates!
03:55:24 <Cale> We have some objects which need to be drawn and updated according to the timestep
03:55:42 <Cale> and maybe they also respond a bit to user input
03:55:51 <Cale> So we might have a type like:
03:56:12 <julianleviston> Cale: I’m not sure how this exapmple really relates. I’ll listen to you, though. Continue.
03:57:09 <Cale> data Object = Ob { draw :: Drawing, timeStep :: DeltaTime -> Object } -- let's ignore user input even for now
03:57:42 <Cale> We could add an input parameter to the timeStep function, or add another "method"
03:57:54 <Cale> So we might have some very simple things like:
03:58:34 <julianleviston> Cale: sorry but I’m not following the correlation.
03:58:47 <julianleviston> Cale: I don’t think either of those are the problem I’ve got.
03:59:25 <Cale> Well, okay, we could presumably take a very different approach
03:59:30 <julianleviston> Cale: My problem is I have a range of data in various types that I want to plug in to Templates, and I want the templates to be informed of the structure of the data.
03:59:36 <Cale> where we try to enumerate all the types of animation objects that we need
03:59:44 <Cale> as explicit data structures
04:00:10 <Cale> maybe we have some sort of rocket object which has a position, velocity and acceleration, which we store as a triple of vectors
04:00:13 <Cale> and so on
04:00:27 <julianleviston> Cale: ok.
04:00:30 <Cale> But this leads to having lots and lots of data types which we can't operate on uniformly
04:00:40 <julianleviston> Cale: ok.
04:01:05 <Cale> But really all we are concerned with is the ability to display the animation object, and the ability to update it over time, producing a new animation object
04:01:12 <Cale> Sound kind of familiar? :)
04:01:49 <julianleviston> Cale: kind of… if “display” can be impacted by the type of object, sure.
04:02:02 <Cale> But there is no type distinction now!
04:02:13 <Cale> Only different values which have the same interface!
04:02:31 <Cale> Like, I might have
04:02:46 <Cale> rocket :: Position -> Velocity -> Acceleration -> Object
04:03:02 <julianleviston> Cale: yeah…
04:03:33 <Cale> rocket p v a = Ob { .. } where draw = drawRocket p v; timeStep dt = rocket ... updated args ...
04:03:54 <julianleviston> Cale: but here you can clearly extract the common requirements. In my case, they all have a “shape” but they all have different types, so how are we to get the shape out? That’s my problem.
04:04:28 <Cale> The common requirements in your case seem to be:
04:04:45 <Cale> Produce a string for splicing into the document
04:05:03 <julianleviston> Cale: um… that’s the common requirements of a value.
04:05:04 <Cale> Display a user interface for editing the present value
04:05:23 <julianleviston> Cale: no, here we’re actually BUILDING the user interface.
04:05:40 <julianleviston> Cale: that’s what this template editor is for… editing the templates that a user will use to edit the data of the thing.
04:05:43 <Cale> Okay, so once you have your values represented in this uniform way
04:05:48 <julianleviston> Cale: (or display it or whatever).
04:05:57 <julianleviston> Cale: yeah…
04:06:29 <Cale> Then you can build functions which build up more complicated values of this type from simpler ones
04:06:38 <julianleviston> Cale: I’m not sure waht that means.
04:06:44 <Cale> For example, maybe you have  listOf :: Object -> Object
04:06:53 <Cale> which turns an editor for values of a single element
04:07:03 <Cale> into an editor for values of an extensible list of elements
04:08:41 <Cale> (which get initialised to the value given)
04:08:49 <julianleviston> Cale: I can’t see how that will work… so you’re saying I should go from the data-upwards?
04:09:33 <Cale> So, perhaps the initial bytestring splice will just be []
04:09:47 <julianleviston> Cale: and I really can’t see how I can do this in the first place, because the template editor needs a way to glue these values to their editors that they’re cerating… right?
04:09:48 <Cale> and then the UI, well, it's going to be something which has an Add New button
04:09:59 <Cale> and lets you extend a list of entries
04:10:09 <julianleviston> Cale: there’s nothing saying that a template editor will always edit a text field in the same way...
04:10:16 <Cale> and when you add a new entry, it's going to put in the editor for a single element which was given
04:10:29 <Cale> which I'm assuming you can put in place
04:10:50 <julianleviston> Cale: but the “editor for a single element” is part of what the template editor is building!
04:11:04 <Cale> I'm assuming here that your representation of UIs is recursive enough that you can take a UI for editing X and turn it into a UI for editing lists of X.
04:11:17 <julianleviston> Cale: and the problem of connecting these things up in the context of a certain data type is an exact description of the problem I can’t solve.
04:11:47 <Eagiz> julianleviston: Data.IntMap.Lazy seems sufficiently fast. Some quick benchmarking showed that (in my algorithm): IntMap.Lazy > IntSet > Set > HashMap.Lazy (where a > b denotes that a was faster than b). It's worth mentioning that my algorithm does not care about key-value mapping, it's only concerned about membership. So if you or anyone else knows about an even faster structure given this new information, 
04:11:51 <julianleviston> Cale: sure, but I have to be able to connect the templates up to the datatypes at some point.
04:11:53 <Eagiz> feel free to give me some to try out.
04:12:03 <julianleviston> Eagiz: sets?
04:12:28 <Cale> and then the overall UI that you construct is going to provide you back some encoding of a list of the encodings of your edited objects
04:12:34 <julianleviston> Eagiz: if you google “haskell datatype“ and then add your constraints after haskell you’ll probably find one
04:12:53 <julianleviston> Eagiz: https://downloads.haskell.org/~ghc/7.8.2/docs/html/libraries/containers-0.5.5.1/Data-Set.html
04:13:09 <julianleviston> Eagiz: tho apparently member (the lookup) is O(log n)
04:13:17 <Eagiz> julianleviston: Tried that one, IntMap.Lazy was way faster
04:13:22 <Cale> You can parse this and turn it into an Object (in my terminology here) that starts off with a particular list of subobjects
04:13:28 <julianleviston> Eagiz: haha :) interesting.
04:13:40 <Eagiz> Even though I need to create the redundant mapping (\x -> (x, True))
04:13:48 <Cale> So maybe I should have started with  listOf :: Object -> [Object] -> Object
04:14:21 <Cale> So that we have the "default new" object, and the list of current objects as arguments here
04:15:02 <julianleviston> Cale: that’s all well and good - you’ve effectively described a “generic data type”, kind of (it doesn’t deal well with some certain things such as product types very well)… but how do you inform the template of the constraints it can and cannot do?
04:15:18 <Cale> julianleviston: Hm? What problem is there with products?
04:15:41 <julianleviston> Cale: well… fields… who can have things such as maps, or other structures like trees, etc.
04:15:59 <Cale> We can work with literally any types of data at all
04:16:12 <Cale> Heck, we could operate on diagrams from the Diagrams library.
04:16:37 <julianleviston> Cale: I simply don’t follow how
04:17:22 <Cale> Given an appropriate amount of UI work, I could write a function which takes an initial Diagram, and, well, the ByteString to splice would, say, be the SVG rendering of the diagram
04:17:30 <julianleviston> Cale: if we take a simple example, say a simple HTML page, with a hole in it that has plugged into it a UL and then a list of LIs that take a certain template and a piece of data - how does your idea fit with this?
04:17:47 <Cale> and then the UI would be a graphics editor which starts off initialised to the given Diagram
04:19:04 <Cale> and it would produce some representation of the final diagram, which we would parse and produce a new Object starting from the diagram we parsed out of that output
04:19:55 <Cale> julianleviston: Well, that's almost exactly the example I did first with the list
04:20:04 <julianleviston> Cale: the data type it takes is a list of bytestrings… but the data type provided to it isn’t a list of bytestrings, it’s a Domains [Domain], which I could easily massage into a list of bytestrings on the data side, if only it could know that that’s what was needed of it… my problem is… how can I allow the user to inform the server that it needs to plug the domain name string out of each domain in that list i
04:20:04 <julianleviston> my sub-template for iteration...
04:20:17 <Cale> julianleviston: anyway
04:20:19 <julianleviston> Cale: no it’s not. the problem is not the rendering. I can do that fine. I already am
04:20:21 <Cale> I *really* have to sleep
04:20:26 <julianleviston> Cale: the problem is the connection between them <sigh>
04:20:52 <Cale> But I'm pretty confident that if you can work out what I'm trying to tell you, the problem with your many different representation types will go away
04:20:53 <julianleviston> Cale: ok. I appreciate the effort. I really do, but I feel like we’ve both wasted about 4 hours.
04:21:14 <julianleviston> Cale: Pretty sure I know what you’re trying to tell me, and I’ve seen it since you began telling me! :)
04:21:15 <Cale> because all those representation types will move into parameters of functions which construct Objects
04:21:21 <julianleviston> Cale: I could be wrong, of course… 
04:21:29 <Cale> and then you won't care that they're different
04:21:29 <quicksilver> you are wrong, and Cale is right
04:21:36 <quicksilver> and yesterday you were wrong and I was right.
04:21:44 <quicksilver> but it is proving hard to explain in a way you can see.
04:22:14 <julianleviston> quicksilver: gosh. I thought I was understaing what he was saying
04:22:19 <Cale> (It's 7am and I have to work today T_T)
04:22:28 <julianleviston> Cale: thanks. yeah no worries.
04:22:29 <quicksilver> :)
04:22:37 <julianleviston> Build a bunch of Objects data items… they have functions for rendering.. compose them.
04:22:42 <julianleviston> it’s not difficult to understand
04:23:10 <Cale> Did you look carefully at what my Objects were? They're not directly the data, but explanations of how to work with the data
04:23:23 <julianleviston> Cale: yeah, they have a function in them.
04:24:00 <julianleviston> Cale: but that’s not data, and I need it to be just data.. otherwise I can’t edit it, and therefore can’t afford the user a way to edit the templates.
04:24:08 <Cale> (If you're thinking in terms of a functional language's implementation, they will ultimately capture the data in closures)
04:24:18 <Cale> You *can* edit it though!
04:24:19 <julianleviston> Cale: no doubt.
04:24:29 <Eagiz> julianleviston++
04:24:33 <julianleviston> sigh.
04:24:34 <Cale> When you create the Objects, you know which type of data it is you're writing an editor for!
04:24:49 <Cale> and you know which type of data it is you're parsing the response from the UI for!
04:25:15 <julianleviston> yes… no doubt. But that doesn’t help the user (who is not a programmer) to connect the pieces of data they want to to the holes they need them in.
04:26:02 <Cale> I don't see the problem, but g'night!
04:26:11 <julianleviston> Cale: it’s all good. I’ll figure something out. goodnight :) 
04:26:21 <julianleviston> Cale: I really hope I haven’t misunderstood you, as quicksilver seems to think I have.
04:27:10 <julianleviston> Cale: and thanks for all the effort. Really appreciate it.
04:27:36 <julianleviston> quicksilver: I think perhaps you think that the coder is writing the editor, but that’s not the case.
04:27:58 <julianleviston> quicksilver:  one of the user roles is to edit templates, another is to use them.
04:28:15 <julianleviston> quicksilver:  and neither of these people write code.
04:33:44 <quicksilver> yes of course
04:33:53 <quicksilver> that is not a misunderstanding I was labouring under
04:33:59 <quicksilver> and I regret my words, which were unkind
04:34:07 <quicksilver> but I do think that Cale is right :)
04:34:36 <quicksilver> you want things to be uniform in type
04:34:43 <quicksilver> and contain functions which explain how to render and edit them
04:35:07 <quicksilver> s/you want/the nice solution is for/
04:38:34 <quicksilver> I suspect it would be easier to work through a concrete but simple example
04:38:45 <quicksilver> two templates with a couple of fields each
04:44:43 <julianleviston> quicksilver: that’s fine. You’re both excellent - this maybe has nothing to do with right or wrong, but rather whether it’s what I’m after or not. :)
04:45:12 <julianleviston> quicksilver: you’re right about the example. It’s what I was trying to do with the HTML page and UL / LI list on it I mentioned above.
04:46:01 <julianleviston> quicksilver: the template designer needs to be able to explain which pieces of the structure and data go in which holes… this is why I find it a bit challenging understanding how Cale’s version (which sounds great, by the way) would work for what I’m trying to do.
04:46:29 <julianleviston> quicksilver:  that is, they need to be able to pull arbitrary pieces of strucure out and map them into arbitrary parts of templates
04:46:34 <julianleviston> (and data)
04:47:08 <julianleviston> but it’s all good. I’ll keep thinking about it. 
04:47:49 <quicksilver> is the template designer a coder?
04:47:53 <julianleviston> no
04:48:04 <quicksilver> aha. This part was not clear to me until now
04:48:11 <julianleviston> they’re an HTML designer, basically…
04:48:16 <julianleviston> quicksilver: apologies!
04:48:21 <quicksilver> so you have non-coders creating interactive widgets to be used by other non-coders?
04:48:34 <julianleviston> quicksilver: it’s a complicated system and I’ve been built it 3 or 4 times now in various systems.
04:48:38 <julianleviston> quicksilver: yep.
04:48:45 <julianleviston> quicksilver: acutally entire pages.
04:49:19 <julianleviston> quicksilver: but in a composable / reusable way (so, widgets, yep).
04:49:52 <quicksilver> you should be really good at it by now :)
04:50:01 <julianleviston> quicksilver: yeah :) well, haskell is spoiling me
04:50:10 <julianleviston> quicksilver: it’s such a beautiful language, and SO powerful. 
04:50:33 <julianleviston> quicksilver: up til now I’ve only done it in these clunky languages that don’t let me do fully what I want to do… but Haskell is kind of like “hey, you can do whatever you can think of”
04:51:00 <julianleviston> quicksilver: so… the current system (working by the way) is written in such a way that it’s much simpler to think about - just typeless pieces of text stitched together… easy! :)
04:51:22 <GLOSS> 4http://theyouthcash.com/?ref=22741 8http://theyouthcash.com/?ref=22741 9http://theyouthcash.com/?ref=22741 13http://theyouthcash.com/?ref=22741 2http://theyouthcash.com/?ref=22741 11http://theyouthcash.com/?ref=22741 !!! 7EARN MONEY REALLY QUICK - FREE REGISTARTION - NO SCAM - REAL MONEY - ALL YOU NEED TO DO IS REGISTER FOR FREE AND SHARE YOUR LINK !! READ UP ON IT AND FIND OUT FOR 
04:51:22 <GLOSS> 7YOURSELF !! HAVE A BLESS DAY !!
04:51:27 <julianleviston> oh god
04:51:39 --- mode: ChanServ set +o quicksilver
04:51:45 --- mode: quicksilver set -o quicksilver
04:51:50 <quicksilver> too late
04:51:54 <julianleviston> can’t you still ban his IP?
04:52:04 <julianleviston> or did s/he leave the system?
04:52:09 <quicksilver> I could do but he probably won't use it again
04:52:15 <julianleviston> tricky tricky.
04:52:20 <julianleviston> it’s probably a bot then
04:52:51 <quicksilver> I expect you can download or buy irc bots which plug your affiliate link to popular channels
04:52:56 <quicksilver> without even knowing what IRC is.
04:56:51 <ernst> must have been the premium package with 6 different colors
04:57:42 <FireFly> Sadly it probably works well enough for the spam to be profitable
04:58:32 <frerich> I really love how knowing a bit of Haskell made me a much better Python programmer by making me realize how to exploit the the 'itertools' module and generators in general.
04:59:03 <Rembane> frerich: Have you looked into the operator module in Python too? :)
04:59:27 <frerich> Rembane: Sure (but mostly for performance reasons in case I try to optimize away lambda expressions)
04:59:53 <julianleviston> frerich: Yeah I haven’t programmed in anything else since moving to Haskell, but I’m sure it’d be very interesting :) I think I’d cry because of the lack of the type inferer and types in general. I rely on them so much now.
05:01:58 <Rembane> frerich: Sweet!
05:02:23 <GLOSS> http://theyouthcash.com/?ref=22741 http://theyouthcash.com/?ref=22741 http://theyouthcash.com/?ref=22741 http://theyouthcash.com/?ref=22741 http://theyouthcash.com/?ref=22741 http://theyouthcash.com/?ref=22741 !!! EARN MONEY REALLY QUICK - FREE REGISTARTION - NO SCAM - REAL MONEY - ALL YOU NEED TO DO IS REGISTER FOR FREE AND SHARE YOUR LINK !! READ UP ON IT AND FIND OUT FOR YOURSELF !! HAVE 
05:02:23 <GLOSS> A BLESS DAY !!
05:02:49 * frerich notes gloss is a really nice Haskell package, too.
05:03:32 <julianleviston> It’s a pity we can’t get lambdabot to pattern match on posts with youthecash and kickban the poster ;)
05:03:46 <julianleviston> orwhatever it is
05:04:24 --- mode: ChanServ set +o quicksilver
05:04:41 --- mode: quicksilver set +b *!ident@109.246.155.212
05:04:53 --- mode: quicksilver set -o quicksilver
05:13:37 <edwardk> julianleviston: lambdabot isn't terribly secure. i'd hesitate to trust it with ops ;)
05:14:26 <julianleviston> edwardk: Edward! yeah I wasn’t really serious :) The moment I wrote that I immediately thought “what if someone just inadvertently typed the wrong thing… that’d suck” but yeah, it’d be a bad idea in general anyway.
05:15:37 <maerwald> edwardk: can you break lambdabot with category theory?! :D
05:15:42 <aweinstock> does lambdabot have known vulns? I thought there was a good deal of effort put into making mueval safe (no IO, the trustworthyness system, no TH, etc)
05:18:34 <quicksilver> I'd bet that lambdabot is more secure than quite a few bots which *are* given ops, but giving lambdabot op powers would make it a target and maybe that's just not a battle people would enjoy fighting.
05:20:00 <julianleviston> Oh wow how cool is Typeable!
05:21:43 <quicksilver> Typeable is a tool for great evil :)
05:22:18 <julianleviston> quicksilver:  oh :(
05:23:02 <julianleviston> lol have you seen this? it’s funny :) http://www.willamette.edu/~fruehr/haskell/evolution.html
05:23:35 <placer14> julianleviston: Don't you sleep? You're active when I went to bed last night, too...
05:23:57 <julianleviston> placer14: I’m probably in a different part of the world than you
05:24:28 <magneticduck> today, placer14 comes to term with how not everybody sleeps 12 hours a day
05:24:33 <magneticduck> s/term/terms
05:24:47 <magneticduck> uh I mean, > 13 hours a day
05:24:48 <julianleviston> magneticduck:  lol 12? wow… try 7. :)
05:24:57 <magneticduck> what?
05:25:02 <magneticduck> no no no
05:25:05 <julianleviston> sorry. I sleep 7. :)
05:25:36 <placer14> magneticduck: You assume too much.
05:25:38 <magneticduck> only in a world where people either slept more than 12 hours a day or did not sleep at all would placer14 be justified in concluding that you never sleep 
05:26:04 <placer14> That, or you're not familiar with the idea of exaggeration.
05:26:26 <magneticduck> I'm still living in the hypothetical world where exaggeration doesn't exist and all speech is literally meaningful
05:26:30 <magneticduck> we all make our little approximations
05:26:37 <placer14> *smirk*
05:27:11 <placer14> I have a compiler for that, thank you
05:27:14 <julianleviston> the cartesianally-inclined Haskeller uses a hylomorphism to do fac! ;-) impressively bizarre.
05:28:38 <placer14> I much prefer a world where language is fluid and expressive.
05:28:53 <julianleviston> placer14: to what, pray tell, do you refer? ;-)
05:29:30 <magneticduck> something like JavaScript
05:29:33 <placer14> My haskeller friend who strongly influenced my decision to pursue the lang is a human language parser
05:29:43 <placer14> magneticduck: touché
05:29:54 <julianleviston> placer14: aren’t we all?
05:30:02 <quicksilver> julianleviston: I mean, Typeable tempts you to use it for a kind of dynamic type-based dispatch when you'd be better off just solving a problem with a proper data structure.
05:30:11 <quicksilver> it is however brilliant when it is what you need.
05:30:12 <julianleviston> quicksilver: ah… yes… right.
05:30:19 <placer14> julianleviston: except he operates with all the warning flags enabled ALL THE TIME
05:30:23 <julianleviston> quicksilver: I’m still unsure what I need :)
05:30:42 <julianleviston> placer14: wait… HE does human language parsing or he writes programs to do that?
05:31:09 <placer14> He is. I'm trying to suggest that he corrects everything you say, or has commentary about them.
05:31:28 <julianleviston> placer14: t m’excuse… my english parsing is a little… rusty :)
05:31:29 * placer14 squirms as his analogy begins to break down
05:32:32 <julianleviston> quicksilver: I’d very much like to not have to use something very complicated, if I can avoid it.
05:34:34 <Franciman> Hello
05:34:42 <julianleviston> frerich: saluton!
05:35:30 <Franciman> Is it possible to specify to cabal the number of parallel processes that it is possible to use when compiling? Like with make's -j option
05:35:44 <frerich> julianleviston: salvete
05:36:12 <julianleviston> frerich: sorry :) I mis-completed Franciman 
05:36:19 <Franciman> :)
05:36:27 <Franciman> saluton!
05:36:28 <julianleviston> frerich: it was actually esperanto, not latin :)
05:36:31 <Franciman> It's esperanto right?
05:36:33 <Franciman> oh ok
05:36:41 <julianleviston> Franciman: jes :)
05:38:16 <julianleviston> frerich: assuming you didn’t mean latvian for Napkin (apparently) lol :)
05:38:30 <frerich> julianleviston: No, I meant Latin :-)
05:38:41 <julianleviston> frerich: I really want to learn that one day
05:50:32 <Guest00000> are 'constraint' and 'context' synonyms?
05:50:33 <MasseR> Franciman: newer cabals should understand -j
05:50:52 <julianleviston> Guest00000: not really
05:52:12 <quicksilver> they are pretty similar
05:52:15 <julianleviston> Guest00000: constraints are usually explained by => 
05:52:31 <quicksilver> the bit before the => is also (sometimes) called the typeclass context
05:52:45 <julianleviston> Guest00000: context can be extended to mean something that wraps something else, like the Maybe in Maybe Int
05:53:08 <Guest00000> ah
05:53:09 <julianleviston> Guest00000: but constraint can’t ever mean that (AFAIK)
05:53:22 <julianleviston> quicksilver:  interesting! 
05:54:10 <quicksilver> the word context is used in more than one way
05:54:18 <julianleviston> quicksilver: precisely what I meant :)
05:54:19 <quicksilver> curse this language with its contextual semantics
05:54:23 <Franciman> MasseR, ok thanks
05:54:23 <julianleviston> hehe :)
05:54:42 <quicksilver> but context is used int he haskell report specifically for the typeclass part of a type
05:54:55 <julianleviston> Guest00000: a word of advice… (that I should take more often) - when asking a question, provide as much context as possible… 
05:54:57 <quicksilver> it is a word from formal logic/type theory
05:55:45 <Guest00000> i have type of form c => ...
05:55:56 <Guest00000> i want to rename c
05:56:06 <Guest00000> into something like ctx
05:56:21 <Guest00000> should i choose "context" or "constraint"
05:56:26 <julianleviston> :t (*)
05:56:27 <lambdabot> Num a => a -> a -> a
05:56:34 <julianleviston> Guest00000: you mean like Num a there?
05:56:35 <merijn> Guest00000: Either is fine
05:57:41 <maerwald> I wonder why Control.Monad does not have: whenM :: Monad m => m Bool -> m () -> m (), the implementation is pretty trivial
05:57:53 <julianleviston> when *is* monadic isn’t it?
05:57:56 <julianleviston> :t when
05:57:57 <maerwald> or am I missing something
05:57:58 <lambdabot> Applicative f => Bool -> f () -> f ()
05:58:02 <maerwald> no
05:58:05 <julianleviston> oh?
05:58:09 <merijn> maerwald: Trivial to make using when and >>= though
05:58:18 <maerwald> merijn: I know, I have it already
05:58:25 <maerwald> but it's still pretty common
05:58:29 <maerwald> so why not have it in Control.Monad
05:58:30 <merijn> maerwald: Fairbairn threshold
05:58:36 <Guest00000> julianleviston: i mean, i literally have a type variable of kind Constraint
05:58:46 <Guest00000> or, uh, 
05:58:59 <julianleviston> Guest00000: I don’t understand. Sorry.
05:59:00 <Guest00000> yes
05:59:12 <julianleviston> Guest00000: you have Constraint a => …. (something)
05:59:31 <merijn> julianleviston: He's trying to name a type variable which has kind Constraint
05:59:39 <merijn> Presumably using -XConstraintKinds for fancy voodoo
05:59:42 <julianleviston> merijn: you mean typeclass?
05:59:50 <merijn> No
05:59:54 <julianleviston> merijn: what’s kind Constraint?
05:59:56 <merijn> Because not all constraints are typeclass
06:00:03 <merijn> julianleviston: Eh, the kind of constraints? :)
06:00:03 <julianleviston> merijn: I thought kinds were something else
06:00:11 <merijn> "Num :: * -> Constraint"
06:00:20 <julianleviston> merijn: oh I know nothing of such things.
06:00:41 <julianleviston> merijn: I don’t even know how to understand that.
06:00:54 <byorgey> tplus.google.com
06:01:04 <merijn> julianleviston: Well, Int has kind *, right? and Maybe has kind "* -> *", so what's the kind of "Num"?
06:01:06 <byorgey> oops, my bad, wrong window =)
06:01:11 <julianleviston> merijn: yep.
06:01:16 <merijn> It takes a type and returns a Constraint, so "* -> Constraint"
06:01:27 <merijn> What's a Constraint? A special builtin kind in GHC
06:01:29 <julianleviston> merijn: does it?
06:01:34 <julianleviston> merijn: I didn’t know that
06:01:44 <julianleviston> Oh look at that (just GHCi’d it)
06:01:50 <byorgey> julianleviston: a Constraint is anything that can go on the LHS of  =>
06:01:50 <merijn> julianleviston: Well, only if you enable the aforementioned ConstraintKinds extension, but yes it does :)
06:01:52 <julianleviston> Ok… so how does naming it make any sense then?
06:02:03 <julianleviston> byorgey: yes, I know.
06:02:27 <julianleviston> byorgey: I didn’t realise it was a type, though.
06:02:28 <merijn> julianleviston: Well, what if you have a type varialbe "c => Foo c" (for example if Foo has a phantom parameter of kind Constraint)? :)
06:02:31 <byorgey> julianleviston: I know you know what a little-c constraint is, I was just telling you that a capital-C Constraint is no different
06:02:53 <julianleviston> byorgey: I still don’t understand what a kind Constraint is.
06:02:56 <julianleviston> byorgey: but that’s fine.
06:03:09 <byorgey> julianleviston: it's the kind of things that can go on the LHS of => .
06:03:24 <byorgey> there's really nothing more to it than that =)
06:03:36 <julianleviston> byorgey: “kind” like “*” is a kind?
06:03:39 <byorgey> yep
06:03:44 <julianleviston> byorgey: oh. ok.
06:03:46 <julianleviston> So it’s a kind.
06:04:13 <merijn> julianleviston: Yes
06:04:20 <julianleviston> merijn: you need typekinds for this c => Foo c to work?
06:04:36 <merijn> julianleviston: No, for some fun with custom constraints see: https://gist.github.com/merijn/6130082
06:04:50 <merijn> I think it works with 7.8, but not 100% sure. Definitely works with 7.10
06:04:55 <julianleviston> sorry I meant ConstraintKinds
06:05:18 <julianleviston> ah I don’t understand most of that code.
06:05:23 <julianleviston> I don’t think I need to though.
06:05:45 <merijn> julianleviston: A type family defines a type level function
06:06:35 <merijn> It's defining a type level function with kind "k -> [k] -> Constraint" where it returns "()" (the trivial empty constraint) if the first argument is not in the list of types
06:06:35 <Guest00000> how to shorten the 'Constraint' word into a word with three or four letters? ctrt? cstn?
06:06:37 <julianleviston> Guest00000: sorry I bogarted your request for information!
06:06:50 <julianleviston> Guest00000: aha! :)
06:07:14 <merijn> Guest00000: Depending on context (ha!) I might just use 'c' or 'ctxt' instead :)
06:07:21 <magneticduck> Guest00000: Cons or Const; that way, everybody will be confused
06:07:24 <byorgey> Guest00000: Cstr?  Cnst?
06:07:27 <julianleviston> lol
06:07:30 <Guest00000> for better naming...
06:07:44 <julianleviston> byorgey: so how *do* you alias the Constraint kind there?
06:07:55 <byorgey> julianleviston: what do you mean?
06:07:56 <julianleviston> byorgey: I thought that this was coming in GHC 8 or something...
06:07:59 <merijn> julianleviston: If the first argument IS in the list of type it returns a Constraint that never holds (similar to "Int ~ Bool", but using types of kind Symbol for slightly more sensible errors)
06:08:02 <magneticduck> Guest00000: this is Haskell, you're allowed to write big names
06:08:04 <julianleviston> byorgey: he wants to rename Constraint right?
06:08:15 <byorgey> julianleviston: no, it's already in 7.8
06:08:19 <merijn> julianleviston: No, he has a type variable that has a type of kind Constraint
06:08:20 <julianleviston> byorgey: ooh.
06:08:24 <byorgey> you can probably just say  type Cstr = Constraint
06:08:27 <julianleviston> byorgey: so kinds are just types now?
06:08:31 <merijn> julianleviston: No
06:08:44 <byorgey> julianleviston: no, THAT is not coming until GHC 8.  But that is not necessary for this Constraint thing
06:08:46 <merijn> julianleviston: Type variables can have types of any kind, though
06:08:51 <julianleviston> byorgey: ah ok
06:09:03 <quicksilver> I would use 'ctt' and leave people guessing if it was short for context or constraint
06:09:16 <julianleviston> byorgey: will that make everything one bit more confusing? (the GHC8 thing)
06:09:25 <merijn> julianleviston: Not really
06:09:50 <julianleviston> what’s it called? higher kinded types?
06:09:59 <merijn> We already have higher kinded types
06:10:03 <maerwald> Mh, I have 3 functions with semi-similar code, but they are not easily abstractable. I know have the choice between a little "code duplication" or stuffing in a lot of case statements inside a single function. I think the latter would make it less readable.
06:10:03 <Guest00000> quicksilver: haha
06:10:06 <merijn> And have had them for decades :)
06:10:34 <julianleviston> merijn: what am I talking about then?
06:10:38 <merijn> julianleviston: Higher kinded types just means "my type variables can have types of kinds other than *"
06:10:42 <julianleviston> merijn: “kinds are types” :)
06:10:43 * hackagebot pipes-aeson 0.4.1.5 - Encode and decode JSON streams using Aeson and Pipes.  https://hackage.haskell.org/package/pipes-aeson-0.4.1.5 (RenzoCarbonara)
06:11:02 <julianleviston> merijn: oh… yeah I actually knew that lol
06:11:05 <merijn> julianleviston: Suppose "data Foo f x = Foo (f x)" <- higher kinded type, since the type variable 'f' has kind '* -> *'
06:11:16 <julianleviston> merijn: yeah, Maybe is a higher kinded type.
06:11:30 <merijn> Maybe is actually not :p
06:11:39 <merijn> Because Maybe has kind "* -> *"
06:11:40 <julianleviston> oh I thought the type of Maybe was * -> *
06:11:56 <merijn> Higher kinded types is about type VARIABLES in data declarations accepting kinds other than *
06:12:06 <merijn> But Maybe only deals with type arguments of kind *
06:12:11 <julianleviston> merijn: oh well.
06:12:16 <merijn> Monad transformers are higher kinded
06:12:21 <julianleviston> merijn: ahhh ok.
06:12:26 <merijn> Since they take monads (* -> *) as arguments
06:12:33 <julianleviston> :t runMaybeT
06:12:35 <lambdabot> Not in scope: ‘runMaybeT’
06:12:37 <julianleviston> so this?
06:12:38 <julianleviston> hm
06:12:59 <julianleviston> the type of MaybeT, I should say.
06:13:05 <merijn> λ :k MaybeT
06:13:05 <merijn> MaybeT :: (* -> *) -> * -> *
06:13:21 <merijn> That's higher kinded because of the "(* -> *)" argument, yes
06:14:17 <merijn> If this stuff interests you I can recommend the lambda cube paper and TaPL (the lambda cube paper probably requires at least a bit of familiarity with the simply typed lambda calculus)
06:14:28 <merijn> TaPL starts from scratch, but is kinda expensive :)
06:15:43 <julianleviston> merijn: no, what interests me at the moment is trying to work out how to build the general type I want.
06:15:46 <julianleviston> merijn: thanks tho!
06:29:05 <Guest00000> okay... what chiptunes does #haskell listen to?
06:35:04 <Fuco> Speaking of kinds, why did they pick * and not a letter like 'a' in normal types... it mildly annoys me :D
06:35:33 <merijn> Fuco: Blame computer scientists from a few decades ago :)
06:35:59 <merijn> Fuco: * has been in use in papers for a long time
06:36:00 <Peaker> Fuco: a :: a  ?
06:36:18 <Peaker> Fuco: Or just pre-allocate "a" as "*" and all tv's have to be named differently?
06:36:19 <merijn> Fuco: Some literature uses "Type" instead of *
06:36:28 <Peaker> Agda's "Set" is weird
06:36:34 <merijn> Why?
06:37:05 <Peaker> Much less clear than "Type", very common different meaning (verb)
06:37:09 <merijn> If we're talking kind * (i.e. types that have values) then you can think of a type as a Set of values
06:37:25 <Peaker> (I guess "Type" also has a common different meaning, but less common in FP context :-) )
06:37:47 <merijn> Set, Prop, (I forget the next step) et al come from the CoC literature, I think?
06:38:00 <merijn> I'm pretty sure Coq uses that too
06:38:09 <Peaker> I think Agda uses "Set" for propositions too, no?
06:38:18 <merijn> maybe? I don't know Agda :)
06:39:56 <julianleviston> Is there a type like Data.Map that can be ordered arbitrarily?
06:40:07 <julianleviston> I mean the keys.
06:40:09 <merijn> What does arbitrary ordering mean?
06:40:13 <julianleviston> well, pairs
06:40:26 <julianleviston> merijn: like lists are ordered arbitrarily.
06:40:32 <merijn> julianleviston: Depends, what kind of lookup complexity do you want?
06:40:43 <julianleviston> merijn: they’re only small, so it does’t matter.
06:40:53 <merijn> julianleviston: Just use list?
06:40:55 <merijn> :t lookup
06:40:57 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:41:06 <julianleviston> oh… as assoc-list?
06:41:11 <julianleviston> good call.
06:41:38 <julianleviston> merijn: thanks!
06:41:51 <merijn> :t insert
06:41:52 <lambdabot> Ord a => a -> [a] -> [a]
06:42:07 <merijn> hmm, might not be necessary
06:42:15 <julianleviston> Hm.
06:42:38 <julianleviston> merijn: basically I want a uniform record without a new type.
06:42:50 <Peaker> A Map itself is an instance of Ord too, isn't it?
06:42:56 <julianleviston> yep
06:43:25 <julianleviston> Peaker: but I want arbitrary ordering.
06:43:34 <julianleviston> Peaker: well, specific.
06:43:53 <julianleviston> actually maybe I’ll just use an auxillary piece of data for that.
06:44:04 <byorgey> an assoc-list sounds like what you want.
06:44:23 <julianleviston> byorgey: yeah, but if you insert an element, it’ll go in the wrong spot.
06:44:38 <byorgey> julianleviston: well, you have to write your own insert that puts it in the right spot.
06:44:43 <julianleviston> byorgey: yep.
06:45:09 <julianleviston> byorgey: I knew I could write my own whatever. :) I was just asking in case there was such a thing already :) thanks! :0
06:53:24 <Fuco> isn't there an insert function taking a comparator in Data.List?
06:53:37 <julianleviston> :t insertBy
06:53:39 <lambdabot> (a -> a -> Ordering) -> a -> [a] -> [a]
06:53:41 <julianleviston> that one?
06:53:50 <Fuco> yea
06:53:55 <julianleviston> yep :)
06:54:13 <Fuco> and you can use `on` to do it on fst of the pair
06:54:47 <julianleviston> Fuco: sure. It’s no biggie.
06:56:02 <nitrix> :t comparing `on` fst
06:56:04 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ b -> ()
06:56:04 <lambdabot>     Expected type: b -> b -> b -> Ordering
06:56:04 <lambdabot>       Actual type: (b -> ()) -> b -> b -> Ordering
06:56:44 <nitrix> :t on fst
06:56:46 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ (b -> c, b0)
06:56:46 <lambdabot>     Expected type: b -> b -> c
06:56:46 <lambdabot>       Actual type: (b -> c, b0) -> b -> c
06:56:54 <nitrix> :t `on` fst
06:56:56 <lambdabot> parse error on input ‘`’
06:57:09 <julianleviston> :t compare . fst
06:57:10 <byorgey> :t comparing fst
06:57:10 <lambdabot> Ord a => (a, b) -> a -> Ordering
06:57:11 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
06:57:16 <byorgey> :t compare `on` fst
06:57:18 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
06:57:25 <nitrix> Oh!
06:57:27 <byorgey> comparing = (compare `on`)
06:57:37 <nitrix> Oh I see. That's why that didn't work.
06:57:41 <byorgey> :t (`on` fst)
06:57:42 <lambdabot> (b -> b -> c) -> (b, b1) -> (b, b1) -> c
06:58:17 <aweinstock> :t (compare `on`) fst
06:58:18 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
06:58:29 <aweinstock> :t compare `on` fst
06:58:31 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
07:03:25 <julianleviston> Do we have an extension that “namespaces” record accessor functions yet?
07:04:31 <julianleviston> So I can write Blah.name Blah { name = “yay” } and Meh.name Meh {name = “boo” } as averse to getting conflicts with data Blah = Blah { name :: String } ; data Meh = Meh { name :: String } ?
07:04:45 <quicksilver> it's a really terrible idea
07:04:52 <quicksilver> and people are trying to do something like it for GHC8
07:04:55 <julianleviston> quicksilver: why?
07:05:03 <quicksilver> because `name` is an expression
07:05:09 <quicksilver> and I want `name` to have a type.
07:05:18 <quicksilver> what would the of `name` be above?
07:05:29 <julianleviston> quicksilver:  there wouldn’t be a name… 
07:05:36 <quicksilver> well then what's the point?
07:05:41 <julianleviston> the point of what?
07:05:42 <quicksilver> why not (1) put them in different modules
07:05:43 <Ferdirand> what's wrong with declaring your record type in a dedicated module ?
07:05:49 <quicksilver> or (2) call it Blah_name
07:05:55 <quicksilver> both things you can do without an extension
07:06:42 <echo-area> https://github.com/mokus0/dependent-sum/blob/master/src/Data/Dependent/Sum.hs#L87  <--  How do I define an instance of ShowTag for a type?
07:06:54 <Guest00000> what is reverse-engineering binaries compiled from haskell like?
07:06:58 <julianleviston> quicksilver: I wasn’t meaning what I wrote specifically.
07:07:47 <julianleviston> quicksilver: but I’ve heard the arguments for all the problems (at least, I’ve read a lot of the discussion around it on the bug tracker)
07:07:58 <echo-area> `instance ShowTag Tag where...` doesn't work, neither does `instance ShowTag Tag f where...`
07:09:07 <julianleviston> quicksilver: I guess you don’t like the idea of having name be polymorphic in its type, or un-automatic, either?
07:09:53 <quicksilver> I like the idea of it having a type.
07:09:59 <quicksilver> I don't have an objection to
07:10:16 <quicksilver> name :: HasName t => t -> String
07:10:17 <quicksilver> or
07:10:36 <quicksilver> name :: HasName t => Lens' t String
07:10:49 <quicksilver> but we can do both of those already without an extension
07:11:01 <quicksilver> I'm not sure it merits being blessed with syntax magic.
07:11:14 <julianleviston> quicksilver:  except that we get a name function automatically. (That’s the bit I don’t like much)
07:11:22 <julianleviston> quicksilver:  so we end up having to say _name, right?
07:11:29 <quicksilver> but you'd never say it
07:11:42 <quicksilver> I mean the point would be you'd never use the underlying _Mehname or whatever you called it
07:11:43 <julianleviston> I don’t mean say I mean write in code.
07:11:50 <julianleviston> quicksilver:  yeah, so why have it.
07:12:02 <quicksilver> so you have a way to define your instance of HasName :)
07:12:03 <julianleviston> quicksilver:  I guess who cares :)
07:12:09 <julianleviston> lol ok.
07:12:35 <quicksilver> I could live with a language which automatically did
07:12:36 <quicksilver> name :: HasName t => Lens' t String
07:12:42 <quicksilver> without generating the underlying _name at all
07:12:46 <julianleviston> quicksilver: seems like a lot of machinery and boilerplate for something that will be used a lot. Kind of like the way Maps work.
07:12:49 <quicksilver> but that's an awful lot of magic to bless into the language level
07:12:56 <julianleviston> true
07:12:57 <quicksilver> makes Lens part of the language def
07:13:12 <quicksilver> and it can all be handled with libraries
07:13:32 <julianleviston> quicksilver:  fair enough.
07:22:57 <quicksilver> and overloading leads to worse error messages
07:23:03 <quicksilver> so you don't want it all the time :)
07:23:12 <quicksilver> worse error messags and harder to read type signatures.
07:27:04 <julianleviston> quicksilver: yeah, I agree.
07:28:06 <julianleviston> quicksilver: lol… funniest error messages I ever had to work out were Ember ones… they use dependency injection…. so hard to know what everything was.
07:36:57 <codedmart> Can I check version number of a package in code. As in to check for aeson < 0.10?
07:38:02 <quicksilver> julianleviston: C++ errors are awesome - http://codegolf.stackexchange.com/a/10470
07:38:47 <quicksilver> normally people use CPP macros for that codedmart 
07:38:53 <quicksilver> http://www.edsko.net/2014/09/13/haskell-cpp-macros/
07:39:11 <quicksilver> you could use the CPP macros to define some value visible at runtime of course.
07:44:05 <codedmart> Sorry I got disconnected if anyone answered about checking aeson version in code. Or is that a bad idea?
07:44:58 <zomg> codedmart: quicksilver answered you, normally it's done via CPP macros, http://www.edsko.net/2014/09/13/haskell-cpp-macros/
07:45:49 <julianleviston> codedmart: depends a *little* on why you’re doing it. 
07:46:22 <codedmart> julianleviston for my tests. The error message from aeson is slightly different in 0.10
07:46:30 <codedmart> zomg quicksilver Thanks!
07:49:45 <quicksilver> :)
07:58:37 <Guest00000> is there a library for typeclass utils which has something like "class NullConstraint2 a b where" ?
08:12:44 * aspidites waits to get smarter via osmosis
08:14:03 <c_wraith> aspidites, it works! it just takes a couple years of hanging out in here. :) 
08:14:29 <aspidites> good to know :P
08:26:09 <sphinxo> Hi, i've been trying to write a brainfuck interpreter in haskell and this is what i've got so far: http://lpaste.net/147344
08:27:07 <sphinxo> How would I go about implementing looping functionality
08:27:51 <Ferdirand> you may want to use Word8 instead of Int to conform to the official spec, iirc
08:29:13 <sphinxo> Thanks, could you give me any other feedback?
08:29:36 <Ferdirand> so you have evalBF :: Program -> Tape
08:29:44 <Ferdirand> and evalBF' :: Tape -> Instruction -> Tape
08:29:48 <sphinxo> yup
08:29:55 <Peaker> sphinxo: x >> return y  ===   y <$ x
08:30:09 <Ferdirand> your Loop [Instruction] is equivalent to Loop Program
08:30:25 <Ferdirand> now if only you had something like Tape -> Program -> Tape ...
08:30:42 <Peaker> sphinxo: your do block can become: Loop <$> (char '[' *> many instr <* char ']')
08:31:34 <Peaker> sphinxo: be careful of foldl, use foldl', and make sure your accumulator is strict
08:31:49 <Ferdirand> you will hit another issue when you need to implement Read and Write
08:33:04 <sphinxo> Thanks
08:33:27 <sphinxo> Could you explain x >> return y  ===   y <$ x   please Peaker?
08:34:12 <Peaker> sphinxo: (<$) :: Functor f => a -> f b -> f a     y <$ x = fmap (\_ -> y) x
08:35:01 <Peaker> :t (<$)
08:35:03 <lambdabot> Functor f => a -> f b -> f a
08:35:13 <Peaker> @src (<$)
08:35:13 <lambdabot> (<$) = (<$>) . const
08:35:19 <sphinxo> ahh
08:35:34 <Peaker> sphinxo: is that "aha", or "terrorized"? :)
08:35:48 <sphinxo> A bit of both
08:37:43 <sphinxo> What issue will I hit Ferdirand?
08:38:08 <Guest00000> you need evalBF :: Tape -> Program -> Tape and evalBF' tape (Loop prog) = evalBF tape prog
08:39:09 <Guest00000> evalBF = foldl evalBF'    , even
08:39:44 <sphinxo> Could you show me what you mean Guest00000?
08:43:19 <maerwald> how lazy is the return value of an IO action? E.g. having "foo >> bar", while "foo :: IO Int" and the Int would take 20seconds to compute, but isn't necessary to actually carry out the IO action
08:44:08 <Guest00000> sphinxo: just rewrite line 30 to "evalBF :: Tape -> Program -> Tape", in line 31 remove "(repeat 0, 0, repeat 0)", append line "        evalBF' tape (Loop prog) = evalBF tape prog"
08:44:24 <Guest00000> this will add looping
08:44:33 <opqdonut> maerwald: it's lazy. try e.g. running "(return undefined >> return 1) :: IO Int" in ghci
08:44:40 <frerich> maerwald: Well try 'return undefined >> return "hi"'
08:44:51 <maerwald> oh right
08:46:40 <sphinxo> thanks
08:50:50 * hackagebot web-routes 0.27.10 - portable, type-safe URL routing  https://hackage.haskell.org/package/web-routes-0.27.10 (JeremyShaw)
08:52:37 <quicksilver> maerwald: depends entirely on the definition of foo
08:53:14 <quicksilver> but yes, if foo is written to do all its IO parts and all the Int part is pure code it will be fully lazy as normal.
08:59:23 <maerwald> quicksilver: and if the Int part is impure one could use unsafeInterleaveIO I guess
09:01:49 <quicksilver> not much point really
09:01:56 <quicksilver> an Int is an atomic value
09:01:59 <quicksilver> you can't demand part of it
09:02:08 <quicksilver> so the work will be done in one lump, whenever it is demanded.
09:06:25 <fractalsea> Is there a way of having the type checker run on Haddock code snippets (inside @… @)?
09:08:04 <Ankhers> @hackage doctest -- fractalsea
09:08:04 <lambdabot> http://hackage.haskell.org/package/doctest -- fractalsea
09:08:09 <bennofs> fractalsea: doctest will typecheck and run code in haddock comments
09:08:11 <Ankhers> That may be what you are looking for.
09:08:23 <bennofs> fractalsea: you can use <<< :{ for multiline examples
09:08:29 <bennofs> (and then :} to end)
09:09:03 <maerwald> quicksilver: erm, that's not what I meant. I meant that the computation that produces the Int is part of an IO action as wel
09:09:25 <sphinxo> What's the cleanest way of joining parseBF :: String -> Either ParseError Program and evalBF :: Tape -> Program -> Tape?
09:09:28 <maerwald> in that case, the Int would be strict too
09:10:55 * hackagebot web-routes-happstack 0.23.10 - Adds support for using web-routes with Happstack  https://hackage.haskell.org/package/web-routes-happstack-0.23.10 (JeremyShaw)
09:10:57 <Ankhers> evalBF tape <$> parseBF "some string" -- sphinxo I think something like that should work.
09:11:19 <Ankhers> <$> == fmap
09:11:33 <sphinxo> awesome
09:11:58 <fractalsea> Great. Thanks!
09:12:55 <Profpatsch> So if I understand it correctly, snap is built on a completely different web server (snap-server) than what other web frameworks use.
09:13:22 <Profpatsch> How is that related to WAI and e.g. Warp?
09:13:55 <Ankhers> Profpatsch: snap-server is not related to WAI or Warp.
09:14:15 <Profpatsch> Ankhers: It’s a completely different ecosystem then?
09:14:24 <Peaker> sphinxo: I continued with your code and I have my first working interpreter for BF :)
09:14:29 <Profpatsch> I thought WAI was a generally agreed upon interface.
09:14:46 <Profpatsch> So e.g. Servant is completely incompatible with Snap?
09:14:54 <mightybyte> Profpatsch: wai is just Yesod's interface.
09:15:16 <mightybyte> Happstack has its own too
09:15:18 <Peaker> sphinxo: evalBF :: Program -> IO Tape   no?
09:15:18 <sphinxo> Can I see your code?
09:15:54 <sphinxo> yeah
09:17:03 <sphinxo> if i'm going to do read/write then yes
09:17:25 <mightybyte> Profpatsch: Servant snap support is in-progress.  https://github.com/haskell-servant/servant-snap
09:17:49 <Profpatsch> mightybyte: Ankhers So wai is to Yesod what snaplets are to Snap?
09:18:27 <mightybyte> Not quite.  I'd say that wai is to Yesod as snap-core is to snap.
09:18:36 <sphinxo> Peaker I'd be curious to see what you've done
09:18:49 <Profpatsch> mightybyte: Maybe snaplets are like middleware?
09:19:31 <Profpatsch> I’m evaluating what I am going to use for a small business project.
09:19:34 <mightybyte> Snaplets are composable web apps
09:20:48 <roelof> Hello, I installed Haskell Platform and try to do this ( cabal install aeson haskell-src-exts haddock hdevtools)  but it fails on this : setup-Configure-Cabal-1.22.5.0-x86_64-windows-ghc-7.10.3.exe: The package has
09:21:05 <roelof> Does Haskell-platform install one of both ? 
09:21:33 <Peaker> sphinxo: http://lpaste.net/147344#a147346
09:21:43 <Profpatsch> I need auth (with password recovery mails), but I’m not sure if there is something already implementing that or if I have to do it myself.
09:21:44 <dcoutts> roelof: your message got truncated I think. But the platform includes haddock, yes.
09:22:12 <Peaker> sphinxo: toList, trunc -- useful to examine the tape state
09:22:18 <Peaker> (but not used)
09:22:26 <Peaker> sphinxo: Stream lets me enable -Wall and be total :)
09:22:46 <sphinxo> What are bangpatterns?
09:23:15 <Peaker> sphinxo: The ! you see in the definition of "go", it forces the lazy thunks to leaking memory due to too much laziness
09:23:16 <mightybyte> Profpatsch: I don't know of anything that already implements that whole thing.  Password recovery emails involve a fair amount of infrastructure that is hard to generalize.
09:23:28 <Peaker> sphinxo: there are other ways to force thunks, but ! is more concise
09:23:48 <roelof> dcoutts:  yes, the whole message can be found here : http://lpaste.net/147347
09:24:18 <sphinxo> to stop leaking memory?
09:25:12 <dcoutts> roelof: oh, installing unix I think isn't going to work. Looks like hdevtools requires unix so will not work on windows.
09:25:19 <kadoban> sphinxo: It changes the semantics in a way that's sometimes better in that sense (sometimes worse). It's not like it goes from "leak memory mode" to "great mode"
09:25:50 <sphinxo> ok, I realise more and more how much I have to learn :)
09:25:57 * hackagebot web-routes-th 0.22.4 - Support for deriving PathInfo using Template Haskell  https://hackage.haskell.org/package/web-routes-th-0.22.4 (JeremyShaw)
09:26:19 <Peaker> sphinxo: http://lpaste.net/147344#a147348 <-- removed bang patterns
09:26:39 <roelof> chips and according to the manual I have to install hvdevtools so I can work with Sublime-haskell 
09:27:00 <Peaker> sphinxo: whenever you have a loop/recursion with an "accumulator" that you pass forward in the loop -- the accumulator must be "forced" or it may accumulate "thunk wrappers"
09:27:27 <Fuco> I have my application inside "StateT IO" but there are some callbacks from other libraries taking "IO" actions... now I would like to have my state in the callbacks and be able to read/update it.  Is there some idiom to do this?
09:28:02 <Peaker> sphinxo: for example:  sum acc [] = acc ; sum acc (x:xs) = sum (acc+x) xs  <-- this will leak because (acc+x) does not actually add! it creates a "thunk" that says "add this when I'm forced"
09:28:46 <Peaker> sphinxo: This is the "dark side" of laziness :) Every computation is implicitly wrapped in thunks, which can facilitate awesome programs, but it can also leak memory in recursions easily
09:29:21 <sphinxo> hmm ooh i've never thought about that before 
09:29:53 <Peaker> sphinxo: in this "sum" example, if you have   sum 0 [1,2,3], it returns a big thunk equivalent to: (((0+1)+2)+3) <-- suspended computation waiting for something to force it. This thunk takes a lot more memory than storing "6"
09:30:01 <Fuco> Socrates would really enjoy Haskell 
09:30:06 <roelof> anyone who has succeed in making sublime text 3 with haskell  on Windows ? 
09:30:26 <timothee> Fuco: :)
09:31:04 <Peaker> sphinxo: if every recursive step of "sum" says: "force the accumulator's thunk down to a simple value", then you never have "thunk buildup", a simple int is kept throughout the entire recursion
09:31:18 <kadoban> Fuco: So what are these callbacks? You have to pass an 'IO a' to some other library, and want to use your state inside it?
09:31:42 <Peaker> So this is a very common pitfall that's not hard to recognize but it takes practice. If you have a recursion, and you accumulate stuff in it -- force the accumulator.
09:33:01 <Fuco> kadoban: for example the external library waits for some event and on it executes the callback, but it only takes 'IO ()', while I would like to have access to my State in the callback too, and then also be able to update it from the callback (which with IO () I can't)
09:33:13 <sphinxo> Thanks Peaker 
09:33:26 <Fuco> kadoban: I guess I could IORef State -> IO () and partially apply, but that seems rather inconvenient :/
09:33:48 <ClaudiusMaximus> Fuco: partially apply your callback to an IORef containing the state - bit inconvenient but about the sanest way i think
09:34:05 <kadoban> Fuco: I'm not positive, but yeah I think you need to use IORefs or something else like that, because you can't really thread StateT's state through something that … isn't the StateT anymore.
09:34:12 <geekosaur> if you need the callback to be able to update, you must use an IORef or similar
09:34:25 <Fuco> I was thinking of something like "reverse lift" heh :D
09:34:43 <kadoban> fallIO $ stuff
09:34:44 <geekosaur> if you just pass the state in, the callback would update a *copy* of the state, not the same state everything else is using
09:35:00 <Fuco> geekosaur: yep, that was my original problem
09:35:07 <Fuco> it wasn't updating back
09:37:42 <roelof> pff, haskell on windows is a big crime . I think I will try a docker image with Haskell and Sublime Text  
09:37:59 <kadoban> roelof: Using 'stack' didn't go well?
09:38:14 <Fuco> haskell on windows was one of the reasons I quit windows, albeit one of the more minor ones
09:38:32 <Fuco> there was also ruby on windows and prolog on windows and python on windows and emacs on windows...
09:38:45 <roelof> Partly. Haskell no problem.   but finding a good editor is. Almost every editor needs some sort of linux part 
09:38:58 <wedens> what makeWrapped does?
09:39:25 <wedens> sorry, wanted to ask it in #haskell-lens :)
09:40:02 <Fuco> lenses... I tried to learn it a couple times but always found it too bizzare to continue :O
09:40:28 <wedens> well, basic things are easy to use
09:40:41 <kadoban> roelof: Oh. I just wouldn't worry about the editor stuff. Get syntax highlighting working, screw the rest. Use ghci on the command line, hlint on the command line, etc.
09:41:24 <kadoban> roelof: I do haskell most days. The one haskell specific thing I even have set up is hlint automatically checking when I save a file, but that's … not essential at all.
09:41:51 <roelof> kadoban:  exactly but like sublime-haskell for syntax highlighting needs unix which needs gcc 
09:43:03 <kadoban> It needs unix for /syntax highlighting/? That's … surprising.
09:44:37 <roelof> kadoban:  I do not know why it needs it. According to the manual of Sublime-haskell I need hdevtools  
09:45:37 <kadoban> roelof: That sounds like it's for far more than syntax highlighting. Look for a way to turn it off probably. hdevtools … I don't think it even does anything related to syntax highlighting, it does totally other stuff, like querying type of expressions.
09:45:55 <kadoban> And syntax checking, etc.
09:47:16 <Guest00000> i have a weird problem... http://lpaste.net/147349
09:50:15 <glguy> Guest00000: remove the forall a. on your show type signature
09:50:17 <kadoban> Guest00000: I suspect that doesn't make sense because the forall line is saying "give me /any/ 'a' at all", it says nothing about it being Typeable. It should be a different 'a' than the one from the line above, essentially. No?
09:50:50 <Guest00000> glguy: but then i won't be able to use the a when specifying the proxy type
09:50:52 <glguy> Guest00000: The type variables in an instance declaration are scoped when scopedtypevariables is on, you don't need instance sigs to get a scoped a
09:51:07 * hackagebot boomerang 1.4.5.1 - Library for invertible parsing and printing  https://hackage.haskell.org/package/boomerang-1.4.5.1 (JeremyShaw)
09:51:09 * hackagebot webdriver 0.8.0.4 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.0.4 (AdamCurtis)
09:51:12 <glguy> and what you're doing is create a new a, not naming the one fro mthe instance declaration
09:51:26 <Guest00000> huh
09:51:33 <Guest00000> worked...
09:51:34 <Guest00000> thank you
09:52:13 <Guest00000> but when it isn't an instance, i have to write the forall to make it work
09:52:27 <Fuco> oh damn... seems like the callback is asynchronous (it didn't look so at first)
09:52:55 <lpaste_> glguy annotated “test0.hs” with “test0.hs (annotation)” at http://lpaste.net/147349#a147353
09:52:57 <Fuco> so now I'm screwed with IORef because the state in the StateT gets replaced in the meantime
09:53:00 <glguy> Guest00000: ^
09:53:17 <Hijiri> Fuco: If you want to be able to wait for the updated value, you can use an MVar
09:53:58 <Fuco> Hijiri: the problem is that it can take a long time to arrive
09:54:03 <Fuco> like, minutes
09:54:12 <Fuco> and the program needs to be responsive
09:54:19 <Guest00000> oh!
09:54:42 <Guest00000> the typeRep signature was so weird, I didn't understand it the first time.
09:55:24 <Guest00000> :t typeRep
09:55:26 <lambdabot> forall (k :: BOX) (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
09:55:29 <Hijiri> StateT might not be a good fit then, if you have asynchronous updates to the state
09:56:19 <Hijiri> unless it's feasible to poll for if the value has arrived yet
09:57:03 <Fuco> yes I think I'll need to move to something else indeed
09:57:05 <kadoban> Fuco: It seems like what you're trying to model is just … a globally changeable state, so you probably shouldn't be using StateT at all, it should just be IORefs everywhere. (in certain places you could use State to generate the value, if it's complicated and contained)
09:58:04 <Fuco> I keep a bunch of connection handles in the state and an application config
09:59:00 <Fuco> I might get around with passing the connection details around explicitly though
09:59:12 <Fuco> StateT was just too convenient in the beginning :D
09:59:34 <geekosaur> possibly shluld have refactored into a StateT for mutable and ReaderT for constant stuf
09:59:48 <kadoban> Well I don't think passing them around is going to help either, but maybe I'm missing what you're saying. That sounds like … just explicitly doing what StateT already does.
10:00:12 <Fuco> kadoban: yes, except that StateT doesn't work in async context
10:00:21 <geekosaur> then it'd be relatively straightforward to move the state in the StateT into an IORef in the ReaderT (the IORef itself does not change)
10:00:23 <Fuco> because the callbacks can update the data in the state in random order
10:00:40 <Fuco> right
10:00:55 <Guest00000> wait... if i write "typeRep (... :: T foo)", the compiler understands that proxy = T and foo = a? why?
10:01:21 <monochrom> type inference. unification.
10:01:36 <Fuco> geekosaur: yes I think that would work, thanks for the tip!
10:02:00 <echo-area> http://hackage.haskell.org/package/dependent-sum-0.3.2.1/docs/Data-Dependent-Sum.html  The example of instance of ShowTag on this page doesn't work anymore.  How to define such an instance?
10:02:03 <Fuco> my explanations aren't the best..., you people are just too smart :D
10:02:27 <kadoban> Fuco: That's what I'm saying … you seem to be just talking about implementing manually what StateT already does, but it's not going to work for the same reason StateT isn't working for you.
10:02:49 <kadoban> Again unless I'm missing something … that'll just be a more tedious non-working solution.
10:03:00 <Fuco> ah, I see... passing it around manually is just doing what StateT does "in the background"... yes
10:04:05 <geekosaur> if you had done it with a newtype and deriving MonadState and MonadReader there would even be a clever way to make the new one "just work": manually write a MonadState instance for the new one that operates on the stuff in the IORef
10:04:39 <Fuco> interesting
10:04:56 <Fuco> MonadState provides the get/put interface I guess?
10:05:02 <geekosaur> yes
10:05:38 <Fuco> time to put on my refactoring hat then
10:22:30 <Fuco> haha this is nice, I don't even have to change the code I have, it just works the same :)
10:23:01 <Fuco> but now I'm thinking maybe I should use MVar instead of IORef as said earlier because the callbacks could potentially run at the same time and do odd things to the state
10:23:42 <Fuco> I like it when things get complicated quickly... granted so far the application was only probing the external state synchronously so it was much simpler "by design"
10:26:10 * hackagebot web-routes-hsp 0.24.6.1 - Adds XMLGenerator instance for RouteT monad  https://hackage.haskell.org/package/web-routes-hsp-0.24.6.1 (JeremyShaw)
10:30:09 <RaceCondition> what's a popular way to package up a Stack/Haskell project as an .app or .pkg package for OS X?
10:30:43 <RaceCondition> I mean a Haskell Desktop app
10:31:10 * hackagebot json-schema 0.7.4.1 - Types and type classes for defining JSON schemas.  https://hackage.haskell.org/package/json-schema-0.7.4.1 (AdamBergmark)
10:36:57 * hackagebot web-routes-wai 0.24.2 - Library for maintaining correctness of URLs within an application.  https://hackage.haskell.org/package/web-routes-wai-0.24.2 (JeremyShaw)
10:47:24 <Guest00000> i have data T a b c = T a b c. how can i have three functor instances (for example with newtypes: "newtype MapFirst t b c a = MapFirst (t a b c); instance Functor (MapFirst T b c) where fmap f (MapFirst (T a b c)) = MapFirst $ T (f a) b c" etc) without writing boilerplate?
10:51:57 * hackagebot web-routes-regular 0.19.0.1 - portable, type-safe URL routing  https://hackage.haskell.org/package/web-routes-regular-0.19.0.1 (JeremyShaw)
10:51:59 * hackagebot git-annex 5.20151218 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20151218 (JoeyHess)
10:54:24 <rpfun> is there a guide on programming haskell with fewer allocations? i understand fusion is supposed to take care of intermediate data structures, but as I write more complex code it seems i need to help haskell along by unrolling things myself more often
10:56:37 <rpfun> a particularly telling, unexpected example is that i had a portion of imperative code where "forM_ [1,2..upper] $ f" was MUCH slower than explicit recursion, which surprised me
11:03:25 <Cale> rpfun: Can I see the two programs?
11:03:59 <Guest00000> rpfun: i learned about GHC's rewrite rules today, maybe you can use them?..
11:04:20 <Cale> rpfun: Also, how are you compiling the code?
11:06:27 <rpfun> ghc -O2
11:07:07 <rpfun> the literal code was "forM_ [1..upn - 1] $ f" where f :: ST s ()
11:07:12 <rpfun> where i pre-calculate upn
11:08:01 <rpfun> my "unrolled" code was "loop i = when (i < upn) $ f >> loop (i + 1)"
11:09:03 <rpfun> i also got a much bigger speed-up replacing "forM_ [i,i+d..upn - 1] $ f" with "loop i = when (i < upn) $ f >> loop (i + d)"
11:09:18 <rpfun> benchmarked with criterion
11:11:58 * hackagebot terminfo 0.4.0.2 - Haskell bindings to the terminfo library.  https://hackage.haskell.org/package/terminfo-0.4.0.2 (JudahJacobson)
11:14:02 <rpfun> sievePrimes pw 3
11:14:22 <rpfun> whoops, sorry about that
11:16:43 <lyxia> rpfun: forM_ [1..upn-1] $ f where f :: ST s () is ill typed
11:17:13 <rpfun> sorry, f :: Int -> ST s ()
11:17:36 <rpfun> and my loop example should have "f i"
11:17:39 <lyxia> Anyway that's odd.
11:17:51 <lyxia> how large are upn and d typically
11:24:39 <carmethene> I have a task that's along the lines of Conway's game of life
11:24:52 <carmethene> i.e. a state is a matrix, and there's a lot of indexing of elements above, below, left, right
11:24:59 <carmethene> am I best off with Data.Matrix for this task?
11:25:56 <carmethene> it seems like folding over a list with lots of !!s would be ugly and slow
11:27:15 * hackagebot haskeline 0.7.2.2 - A command-line interface for user input, written in Haskell.  https://hackage.haskell.org/package/haskeline-0.7.2.2 (JudahJacobson)
11:27:17 * hackagebot generic-accessors 0.5.1.0 - stringly-named getters for generic data  https://hackage.haskell.org/package/generic-accessors-0.5.1.0 (GregHorn)
11:28:05 <rpfun> lyxia: they can be several powers of 10
11:34:35 <lispy> Hey folks, quick reminder about donating to Haskell.org: https://www.reddit.com/r/haskell/comments/3xdpjw/reminder_yearend_deadline_for_haskellorg_donations/
11:43:50 <andrew> > let x = 3
11:43:52 <lambdabot>  <no location info>: not an expression: ‘let x = 3’
11:52:17 * hackagebot hsx2hs 0.13.4 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  https://hackage.haskell.org/package/hsx2hs-0.13.4 (DavidFox)
11:58:08 <the_2nd> I'd like to use a TVar in global scope, so many functions can access it
11:58:26 <the_2nd> I found some examples where it is used in main directly, but that's not enough
11:59:04 <bergmark> the_2nd: global state is frowned upon, a common pattern is to have a ReaderT containing TVars
11:59:24 <the_2nd> I have a webserver
11:59:35 <the_2nd> where each request needs so share some data
11:59:39 <the_2nd> currently done via files
11:59:48 <the_2nd> but this results in quite some overhead
11:59:58 <the_2nd> I wanna store that state in memory
12:00:00 <bergmark> we do this for our web servers :-)
12:00:48 <the_2nd> bergmark, any example?
12:01:52 <bergmark> oh i do have one, https://github.com/silkapp/rest/blob/master/rest-example/example-api/ApiTypes.hs
12:03:50 <the_2nd> thanks
12:14:59 <byorgey> carmethene: you should check out http://hackage.haskell.org/package/ComonadSheet
12:15:37 <carmethene> oh that does look lovely
12:15:39 <byorgey> carmethene: don't be scared by the word comonad in the title, it has lots of examples and I don't think you need to understand comonads to use it
12:15:52 <carmethene> I'm trying to stick to core stuff as much as possible
12:16:06 <carmethene> I'm like two weeks into learning
12:16:11 <carmethene> I haven't even got to monads yet :P
12:16:20 <carmethene> (other than touching on it for IO)
12:16:36 <carmethene> that said, this does look really rather wonderful
12:16:38 <carmethene> byorgey: thanks
12:16:46 <byorgey> carmethene: hehe, fair enough.  In that case, I would advise you to first write a version using plain old lists of lists
12:17:15 <byorgey> then if that is too slow you can try something higher-powered
12:17:37 <byorgey> carmethene: I don't think Data.Matrix is what you want though.
12:17:52 <byorgey> that is for doing linear algebra stuff.
12:18:14 <carmethene> sure
12:18:28 <carmethene> I do a lot of 3d math stuff at work, I was thinking I could just use a matrix of 0/1s
12:19:04 <carmethene> it has a constructor in terms of an i,j function which would work well for the state step
12:19:23 <carmethene> time for food
12:21:30 <byorgey> carmethene: oh, if you actually know how to express your cellular automaton thingy in terms of matrix operations, then by all means =)
12:22:55 <mietek_> I’m trying to use the reflection module to create a dynamic Bounded instance. https://gist.github.com/mietek/e6e225ab11b110749dc0
12:23:31 <mietek_> I’m probably not defining it properly, as even though it defines, I can’t use it.
12:23:36 <mietek_> Any hints?
12:26:32 <neobrain> Hey, I've been learning Haskell for the last few days by implementing an IRC bot (which already works quite well actually) - however, I wanted to make it a bit more flexible now by splitting the program into separate reader/writer threads (so that the bot can react to commands others write on IRC, but also to external events unrelated to IRC)
12:27:30 <neobrain> However, I'm not really sure what the most canonical way to achieve this would be. My understanding is that when writing/reading from/to a Network IO handle, I will have to introduce some sort of synchronization to actually be thread-safe
12:27:39 <ClaudiusMaximus> mietek_: iirc reflection has a dynamic Monoid example that might be of use to look at (can't be bothered to sign into github to view your paste)
12:28:12 <mietek_> ClaudiusMaximus: pretty sure you can view it even in incognito mode
12:28:22 <mietek_> But thanks, I’ll look for the example.
12:28:31 <neobrain> I might be able to spin MVars around every read/write operation, but I'm wondering whether there is an easier way to achive the same (also, I'm not even sure how the reader thread would hGetLine without permanently blocking the IO access)
12:28:42 <byorgey> mietek_: it's suspicious that you are not using 'reflect' anywhere
12:28:47 <ClaudiusMaximus> mietek_: nope, redirected me to a sign in page...
12:28:53 <ClaudiusMaximus> mietek_: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs is what i was thinking of
12:29:06 <byorgey> mietek_: also, the type error seems clear: you are passing a tuple to withBounded, but it expects a (B a s)  as its third argument
12:30:09 <mietek_> byorgey: I mean, I can also read the type error. What I don’t understand is how to use the dynamic-typeclass technique.
12:30:22 <byorgey> mietek_: ok, fair enough.
12:30:43 <mietek_> I was working off the FPComplete tutorial.
12:30:54 <mietek_> It does use reflect.
12:31:07 <byorgey> oh, does it? sorry, I must have missed it
12:31:27 <mietek_> No, the tutorial does; I am indeed not, because I don’t seem to have a value to reflect.
12:31:27 <byorgey> uh, no, I don't see any calls to 'reflect' in your code
12:31:58 <mietek_> I started to wonder if I should be reflecting “undefined”, and then I just realised I have no idea what is happening.
12:32:15 <byorgey> mietek_: maybe the third argument to withBounded should be something like    (forall s. Reifies s (Bounded_ a) => B a s -> a) ?
12:32:36 <byorgey> I am actually just guessing, it's been a while since I played with this
12:32:43 <dfeuer> Reflection is fun.
12:33:14 <dfeuer> mietek, I've played with reflection not long ago. Where's the code in question?
12:33:37 <mietek_> dfeuer: https://gist.github.com/mietek/e6e225ab11b110749dc0
12:34:24 <dfeuer> mietek_, FYI, you should almost certainly enable ScopedTypeVariables if you're monkeying with this.
12:34:30 <jellie> Hello, anyone knows any haskell jobs or internships?
12:34:40 <jellie> Start of next year.
12:35:07 <dfeuer> jellie, there's a wobsite. There's also a maleing liszt.
12:36:10 <dfeuer> mietek_, you certainly want to `reflect` to get the `Bounded_`.
12:36:22 <dfeuer> In the Bounded instance for B a s.
12:36:49 <monochrom> are your fingers ok today? :)
12:37:12 <mietek_> dfeuer: reflect what?
12:37:48 <byorgey> looks like dfeuer's fingers are in extra fine shape, to be able to accurately type that without accidentally typing the correct spellings
12:38:15 <mietek_> byorgey: BTW, I liked your wizard robe.
12:38:37 <byorgey> mietek_: haha, thanks =)
12:38:51 <zipper> dfeuer: I don't know of any website/mailing list. 
12:39:28 <dfeuer> mietek_, I just added a comment giving some approximation of what you need.
12:39:38 <dfeuer> er..
12:39:40 <dfeuer> sorry.
12:39:46 <dfeuer> made a mistake there!
12:39:52 <Ankhers> zipper: a reasearch internship was just posted recently on reddit and the haskell mailing list.
12:39:57 <Ankhers> research rather...
12:40:06 <zipper> Ankhers: All good
12:40:10 <Ankhers> (Though, it was the same position)
12:40:22 <dfeuer> mietek_, I think my comment is correct now.
12:40:46 <mietek_> Meanwhile, I’m only doing this because I can’t figure out a way to have a  Fin n  (finite integral numbers)  where the n is determined at runtime
12:40:56 <mietek_> I found wrengr_away’s data-fin package
12:41:22 <mietek_> But it seems suitable only for statically-known ns
12:41:28 <mietek_> Or, I’m unable to figure it out.
12:41:38 <dfeuer> mietek_, you should definitely look into the singletons package, as scary as it is. But there may well be room for reflection as well.
12:42:41 <zipper> Ankhers: WOW that's a PhD intern position. A PhD and still intern. Crazy.
12:42:44 <dfeuer> mietek_, I just fixed another mistake in my comment.
12:43:12 <mietek_> dfeuer: have you tried typechecking it yet?
12:43:17 <dfeuer> No.
12:43:19 <mietek_> I hear that helps find mistakes.
12:43:22 <dfeuer> I'm sure I've made more mistakes.
12:43:29 <dfeuer> Gr..
12:43:32 <dfeuer> uh....
12:43:37 <dfeuer> Ohhh
12:44:18 <Ankhers> zipper: I think it is labeled as an internship because it is meant for someone that has not completed their PhD. So they are still a student technically.
12:44:24 <dfeuer> mietek_, of course it does. I'm just ... bleh.
12:45:11 <mietek_> dfeuer: perhaps you can say what you’re trying to do
12:46:02 <mietek_> I find it quite confusing that the sample code in https://www.fpcomplete.com/user/thoughtpolice/using-reflection looks different than the sample code in https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
12:46:29 <mietek_> The former does not use the O constructor in the instances
12:46:41 <mietek_> The latter does use M in the instance
12:47:05 <mietek_> I tried removing and adding B in my case, and it typechecks both *with* and *without*
12:47:20 <mietek_> This weirds me out quite a bit.
12:47:26 * hackagebot hspec-expectations-pretty-diff 0.7.2.3 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-pretty-diff-0.7.2.3 (myfreeweb)
12:47:57 <mietek_> But, neither helps the actual use case to typecheck.
12:48:25 <mietek_> dfeuer: nor does the latest version of your comment, I’m sorry to say.
12:49:17 <dfeuer> mietek_, you need ScopedTypeVariables turned on.
12:49:32 <mietek_> I added that.
12:50:04 <mietek_> Edited gist to reflect (ugh) changes: https://gist.github.com/mietek/e6e225ab11b110749dc0
12:50:30 <mietek_> No change with respect to the failure.
12:51:14 <dfeuer> mietek_, where does it go boom? That Bounded instance compiles for me.
12:51:15 <thoughtpolice> Wow, it's been a long time since I wrote that. But in my example, the 'data O' example is used as a dynamically constructed Ord, not Monoid. The reason 'M' is used in the instance in the Monoid.hs example is because of the type signatures
12:51:41 <mietek_> dfeuer: there is an error message at the bottom of the gist. example2 doesn’t typecheck.
12:51:44 <mietek_> thoughtpolice: ohai
12:51:48 <thoughtpolice> The instance is 'Monoid (M a s), so 'mappend :: M a s -> M a s -> M a s'. But '(==)' and 'compare' must return an Ordering or a Bool.
12:52:00 <dfeuer> mietek_, ah, but at least I got you a Bounded instance that's not full of undefined!
12:52:29 <dfeuer> I hadn't even *looked* at the rest of the code yet!
12:52:50 <mietek_> thoughtpolice: do you have an idea about how to construct a Bounded instance?
12:53:05 <dfeuer> mietek_, I just showed you! That part is good!
12:54:29 <mietek_> dfeuer: thank you, but clearly something is still missing.
12:54:57 <dfeuer> mietek_, your example2 is obviously completely bogus. The third argument of withBounded must have type (... => B a s), but you pass it a pair, which is a completely different thing.
12:55:27 <dfeuer> Sorry, I shouldn't have expressed it like that.
12:55:59 <mietek_> No worries. But does it mean that within the scope of withBounded, I have to work with B-wrapped values only?
12:56:20 <dfeuer> mietek_, I suspect you probably want to generalize the type of withBounded.
12:56:35 <dfeuer> But yes, you will have to do some wrapping and unwrapping.
12:57:02 <dfeuer> I couldn't say off the top of my head exactly where that happens.
12:58:16 <studentjohn> Hello, I was wondering if it's possible to rewrite the function "f lst = foldl1 (+) $ filter odd $ lst" into the notation where the argument isn't explicitly written? "f = foldl1 (+) $ filter odd" doesn't work, and neither does adding a $ at the end.
12:58:41 <dfeuer> mietek_, to a first approximation, I'd try   withBounded :: a -> a -> (forall s . Reifies s (Bounded_ a) => q) -> q
12:59:07 <dfeuer> Within that highly quantified argument, B a s will be an instance of Bounded.
12:59:41 <dfeuer> But you can also look in the reflection examples for more inspiration.
13:01:02 <shachaf> f = foldl1 (+) . filter odd
13:01:28 <shachaf> "foldl1 (+) $ filter odd $ lst" means "foldl1 (+) (filter odd lst)"
13:01:35 <shachaf> "foldl1 (+) $ filter odd" means "foldl1 (+) (filter odd)"
13:03:37 <studentjohn> shachaf, I see, thanks a lot!
13:07:32 * hackagebot reform 0.2.7.1 - reform is a type-safe HTML form generation and validation library  https://hackage.haskell.org/package/reform-0.2.7.1 (JeremyShaw)
13:08:07 <Fuco> I am quite confused about newtypes now... I have 'newtype M a = M { unM :: ReaderT Foo IO a }' ... now I want to add MonadIO for M, what do I do? ... it has type liftIO :: IO a -> M a ... but how in M a do I propagate it to the inner wrapped ReaderT?
13:09:30 <dfeuer> Fuco,   ReaderT Foo IO  is itself an instance of MonadIO, so you should be able to do something like   liftIO = M . liftIO, I believe.
13:09:58 <kadoban> :t liftIO
13:09:59 <lambdabot> MonadIO m => IO a -> m a
13:10:11 <Fuco> aha, so it figures out that the "M ." brings it into the wrapped type...
13:10:27 <kadoban> It doesn't figure it out, that's what M /is/.
13:10:57 <dfeuer> The liftIO you're defining is calling a *different* liftIO, if that's what you mean.
13:11:29 <Fuco> no, I am constantly confused about this... M is a function ReaderT -> M ... the unM is a function M -> ReaderT
13:11:39 <Fuco> it's just a translation but for some reason it is confusing to me
13:12:28 <Zemyla> Is there a way to get Parsec to report more than one syntax error?
13:12:44 <Zemyla> Rather than quitting on the first one?
13:12:52 <Fuco> the weird thing is that implementing it just "liftIO = liftIO" also typechecks :O
13:13:14 <Fuco> but that just creates "infinite recursion" right? 
13:13:19 <monochrom> yes
13:13:26 <byorgey> Zemyla: no, I don't think so
13:13:29 <Fuco> so it's not weird :D just silly
13:13:34 <Fuco> partial types yay!
13:14:11 <Fuco> okey this explains why my program freezes... because I implemented MonadReader ask as "ask = ask" @_@
13:14:21 <byorgey> that... would do it =)
13:15:09 <kadoban> I thought if you did infinite loops that tight, GHC usually figured it out and told you.
13:16:00 <byorgey> kadoban: sometimes it does, and sometimes it doesn't
13:16:10 <kadoban> Ah
13:16:28 <byorgey> in the case of recursion in a class instance, I imagine perhaps the intervening dictionary lookup is enough to make it not figure it out
13:16:45 <byorgey> but I am just guessing.
13:17:24 <c_wraith> I thought the only mechanism at play was identifying that evaluating a thunk requires evaluating that thunk. 
13:17:32 * hackagebot reform-blaze 0.2.4.1 - Add support for using blaze-html with Reform  https://hackage.haskell.org/package/reform-blaze-0.2.4.1 (JeremyShaw)
13:17:56 <c_wraith> and in that case, ask = ask doesn't require evaluation. 
13:22:08 <Fuco> all right, everything works again! Thanks for the tips :)
13:22:17 <pop_> i give a nigga
13:22:21 <pop_> a 120 hour work week
13:22:33 * hackagebot bound 1.0.7 - Making de Bruijn Succ Less  https://hackage.haskell.org/package/bound-1.0.7 (EdwardKmett)
13:22:36 <ReinH> byorgey: o/
13:23:13 <ReinH> byorgey: afaik loop detection in GHC usually occurs when a blackhole is reentered from the same thread
13:23:22 <ReinH> which wouldn't be the case here
13:24:06 <ReinH> basically what c_wraith said
13:25:15 --- mode: ChanServ set +o monochrom
13:25:19 --- mode: monochrom set +b *!*@gateway/vpn/mullvad/x-hpcjahidgfmlzgwh
13:25:19 --- kick: pop_ was kicked by monochrom (pop_)
13:25:36 --- mode: monochrom set -o monochrom
13:27:57 * hackagebot reform-hamlet 0.0.5.1 - Add support for using Hamlet with Reform  https://hackage.haskell.org/package/reform-hamlet-0.0.5.1 (JeremyShaw)
13:29:17 <Guest00000> is it possible to create a function of type (forall a . a) -> a  where the inner a and outer a are same thing?
13:29:25 <Cale> I think the problem with loop detection if you cyclically define ask = ask is that ask is that although it looks like a simple variable, ask is actually a function of the class dictionary
13:29:39 <Ferdirand> Guest00000: then the outer a would be out of scope, no ?
13:29:50 <Cale> and so it gets translated to something like  ask monadReaderDict = ask monadReaderDict
13:30:08 <Cale> and f x = f x isn't a loop which can be detected
13:30:34 <Cale> oops, had an extra "is that ask" in there :)
13:30:40 <Cale> editing fail
13:30:59 <mietek_> Guest00000: how about something like  forall a. (forall b. b -> a) -> a
13:31:11 <byorgey> Guest00000: that doesn't really make sense.  The only way to guarantee the two a's represent the same type is to write   forall a. a -> a
13:31:15 <Cale> Guest00000: nope! You're shadowing the outer a when you bind it explicitly with forall
13:32:33 <Guest00000> byorgey: but i want the argument to be polymorphic "from outside"
13:32:57 * hackagebot reform-happstack 0.2.5.1 - Happstack support for reform.  https://hackage.haskell.org/package/reform-happstack-0.2.5.1 (JeremyShaw)
13:32:59 <Guest00000> it will be the bottom value
13:32:59 <shachaf> The whole point of writing the forall on the inside is to make a new, different a.
13:33:47 <Guest00000> shachaf: i thought the point was to use 'different' polymorphism
13:36:39 <zv> whoa its shachaf
13:37:45 <monochrom> "f :: (forall a. a) -> a", "f = id" is legal.
13:38:29 <monochrom> but I would undeceivingly write "f :: (forall a. a) -> b" instead
13:38:42 <wrengr> mietek_: for non-static type level indices you need to hide them with an existential
13:38:56 <monochrom> then it is clear that the code instantiates a to b
13:39:10 <mietek_> wrengr: hi! Thanks for noticing. Do you have an example?
13:39:25 <monochrom> and not meaninglessly "make that 'a' the same as the other 'a'"
13:39:27 <wrengr> mietek_: for non-static indixes which have runtime significance (rather than just checking that types line up) you'll need some form of reflection in order to actually inhabit the existential at runtime
13:40:01 <wrengr> someNat :: Nat -> (forall (n::Nat) . Fin n -> r) -> r
13:40:30 <wrengr> the trick being that 'n' can't occur in 'r' and the continuation must work for all possible choices of 'n'
13:41:03 <shachaf> hi zv
13:41:25 <mietek_> wrengr: so I got to the point where I realised I should probably be trying to dynamically construct a Bounded instance.
13:41:31 <shachaf> I don't think I recognize your nick?
13:41:32 <wrengr> However, do note that mere existentials get erased at runtime, so if you have something which tries to reify the 'n' back to the term-level, you'll want to use reflection to implement 'someNat' rather than just using rank-2 quantification
13:42:07 <wrengr> mietek_: hmm, how so? or, context?
13:43:10 <amalloy> can i use holes or partial signatures or something to help me figure out what type haskell has inferred for an expression? like i have x :: Int; x = 5 + f 10, but i haven't defined f yet and i want to see that its inferred type is something like f :: (Num t) => t -> Int
13:43:44 <monochrom> "x = 5 + _ 10" may help
13:44:13 <amalloy> yeah, i guess that would do it. i was hoping to do it from ghci without changing x, but i guess it's not a big deal to just put a hole in x
13:44:41 <mietek_> wrengr: I have a nice of code which assumes (Bounded a) in order to perform operations on a.  I’m able to determine what the valid bounds should be, at runtime.  I’d like to be able to reify this knowledge as a type.  I thought using data-fin would help, but this just reduces the problem to reifying this knowledge as a Nat.
13:44:47 <mietek_> A nice bit of code.
13:48:30 <wrengr> mietek_: check out ekmett's reflection package (which data-fin uses under the hood)
13:48:44 <mietek_> wrengr: I am struggling to use it, yes.
13:48:49 <wrengr> ah :)
13:49:01 <amalloy> anyway thanks monochrom
13:49:13 <mietek_> wrengr: this was my first attempt: https://gist.github.com/mietek/e6e225ab11b110749dc0/3c99ffe0a85d66d4afa6979a8145717b9de76f79
13:49:52 <mietek_> I now realise I should be just doing “withBounded 0 42 (B minBound)”, for example
13:49:57 <mietek_> But that doesn’t give 0
13:50:05 <mietek_> It just gives the ordinary minBound for Int
13:50:31 <mietek_> So I’m currently trying to get the sonstraints-based example to compile...
13:50:35 <mietek_> constraints*
13:52:11 <m15x0r_> Hello
13:54:15 <wrengr> mietek_: looks to me like the problem with example2 is really a problem with the newtype wrapping
13:55:03 <wrengr> E.g., to get the right type you need to say (B (minBound, maxBound)) but then that complains about not having a Num(Int,Int) instance
13:55:13 <mietek_> wrengr: try just (B minBound)
13:55:33 <mietek_> It should return 0 then, right?
13:56:07 <wrengr> indeed
13:58:27 * hackagebot reform-hsp 0.2.6.1 - Add support for using HSP with Reform  https://hackage.haskell.org/package/reform-hsp-0.2.6.1 (JeremyShaw)
13:59:02 <wrengr> er, no; it does what it says. When we say (B minBound) we're saying to take (minBound :: a) and wrap it up as some (B a s). Thus, when a~Int we get the minBound of Int
13:59:26 <wrengr> instead try: (withBounded 0 42 minBound :: Int)
13:59:56 <wrengr> throws an exception, but that's because the Bounded(B a s) instance is currently bogus; still, it does what we want/mean
14:00:36 <mietek_> aha!
14:00:51 <mietek_> dfeuer suggested "(reflect (Proxy :: Proxy s))"
14:02:11 <wrengr> yeah, I tried that; it complains about the "s" not matching up. Might be an issue of needing to generalize the IH to simultaneously define them for all 's'; or maybe not, haven't checked
14:04:24 <mietek_> wrengr, dfeuer, byorgey: so this actually does work: https://gist.github.com/mietek/e6e225ab11b110749dc0
14:06:04 <wrengr> hmm. Maybe I have some sort of monomorphism flags on by default, or am using a different version of ghc
14:06:20 <mietek_> This is 7.10.3
14:06:34 <mietek_> No extra flags
14:07:13 <wrengr> I'm on 7.10.1 and have ghci set up with -XNoMonomorphismRestriction
14:07:26 <wrengr> anyhoo, if it works it works :)
14:08:44 <Zemyla> I just had a super dumb thought.
14:09:00 <rom1504> ok
14:09:09 <Zemyla> Are there variadic patterns?
14:09:21 <Zemyla> I know you can make variadic functions with typeclasss.
14:09:24 <Zemyla> *typeclasses.
14:10:44 <mietek_> wrengr, dfeuer, byorgey: here’s another approach that works, thanks to thoughtpolice’s example: https://gist.github.com/mietek/fd821d1fc9218d7cd57a
14:10:58 <monochrom> how would I use a variadic pattern?
14:12:04 <byorgey> mietek_: cool
14:12:06 <wrengr> ooh nice
14:16:33 <Zemyla> monochrom: Well, when you're writing a pattern match, the compiler knows how many variables it's assigning to.
14:17:24 <monochrom> that has always been done
14:18:00 <monochrom> if I write "f (Just x) = ..." the compiler knows I am using one variable.
14:18:17 <monochrom> if I write "f (Just x y) = ..." the compiler knows I am using two variables, and the compiler also knows I am wrong.
14:18:47 * hackagebot milena 0.5.0.0 - A Kafka client for Haskell.  https://hackage.haskell.org/package/milena-0.5.0.0 (tylerholien)
14:20:25 <geekosaur> the other prolem is when you call the thing with the variadic pattern. is it using a shorter pattern, or is it partial application?
14:22:47 <monochrom> and my question is still not answered.
14:23:06 <monochrom> my question was: how would I use a variadic pattern?
14:24:00 <monochrom> the current answer has nothing to do with that. the current answer is in want of this different question: if I used a variadic pattern (no one knows how), what would the compiler do?
14:24:18 <monochrom> the current answer fills a much-needed gap
14:36:16 <Fuco> I can imagine it with a map where you would match on key and value and it would do a lookup... if that can be called variadic pattern I'm not sure
14:37:20 <Eduard_Munteanu> When do you ever have a variadic constructor, to begin with? The only thing that comes close is record syntax matching.
14:37:44 <monochrom> key-value sounds like fixed 2-ary to me
14:37:54 <ReinH> What use case do you have for variadic patterns?
14:38:10 <Eduard_Munteanu> (well, you can relax that for ViewPatterns, but I'm still unsure)
14:39:46 <monochrom> record pattern matching can be said variadic with an upper bound. however, when most people say "variadic" they expect no upper bound.
14:41:34 <monochrom> if you had variadic data constructor, then "variadic pattern" has a meaning. but then geekosaur's question kicks in, when you use that data constructor to build a value.
14:42:50 <Eduard_Munteanu> I wonder if that would make a dual to data families, in which you add constructors, but here you add fields to existing constructors and the set of fields is open.
14:45:50 <monochrom> how do I add a constructor to a data family? I thought I added a type.
14:48:03 <monochrom> to be sure, during the process of adding a type, I add data constructors too. but the spotlight ought to be on the type.
14:48:39 <monochrom> the reason is that the additional data constructor is incompatible with other data constructors type-wise.
14:48:45 <shachaf> Do data families have an advantage over type families with a newtype?
14:49:54 <monochrom> does your "type family" mean "type synonym family"?
14:50:10 <monochrom> the non-injective kind, that is?
14:58:48 * hackagebot Agda 2.4.2.5 - A dependently typed functional programming language and proof assistant  https://hackage.haskell.org/package/Agda-2.4.2.5 (AndresSicardRamirez)
15:00:38 <hpc> ooh
15:13:06 <Benzi-Junior> hey all I decided to discover what all the fuss is about with stack so I  installed it and wanted to try to just handle an old project of mine so I copied the source files into the app  directory and added all the dependencies but I still I get a "failure when adding dependencies openGL: needed, not present in build plan" along with "could not pind openGL in known packages" so I tried installing it w
15:13:12 <Benzi-Junior> ith stack (and also with cabal install) but problem persists any ideas?
15:13:49 * hackagebot linear 1.20.3 - Linear Algebra  https://hackage.haskell.org/package/linear-1.20.3 (EdwardKmett)
15:17:26 <bergmark> Benzi-Junior: did you run stack init?
15:18:47 <Benzi-Junior> bergmark: yes
15:19:50 <bergmark> Benzi-Junior: package names are case sensitive, you probably meant to add "OpenGL"
15:21:21 <Benzi-Junior> bergmark: correct
15:23:54 * hackagebot haphviz 0.1.1.1 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.1.1 (Norfair)
15:24:07 <osa1> does anyone know if I can read stashed changes using gitlib?
15:24:26 <osa1> @hackage gitlib
15:24:26 <lambdabot> http://hackage.haskell.org/package/gitlib
15:29:10 * hackagebot happstack-authenticate 2.3.2 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.2 (JeremyShaw)
15:29:12 * hackagebot haphviz 0.1.1.2 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.1.2 (Norfair)
15:29:14 * hackagebot haphviz 0.1.1.3 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.1.3 (Norfair)
15:29:37 <verement> osa1: a stash is just a commit, so I don't see why not
15:34:10 * hackagebot haphviz 0.1.1.4 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.1.4 (Norfair)
15:36:59 <Benzi-Junior> bergmark: oh turns out it wasn't correct it's supposed to be openGL
15:38:42 <Fuco> a package every 2 seconds, that has to be some kind of a record :D
15:42:27 <maerwald> is it possible to have a Data.Map.Lazy like data structure that is also lazy in its key?
15:45:11 <pavonia> How would it build the map without evaluating the keys?
15:52:30 <Ant___> If I have a [(Int, Int)], what would be an elegant way of finding the maximum and minimum values of all the first/second values in the tuples in the list?
16:05:53 <touched_one> Why are all programmers white? Is there a conspiracy against the ethnic man?
16:06:07 <maerwald> wat?
16:06:18 <touched_one> It's just an observation.
16:06:35 <rom1504> there are lot of indian programmers
16:06:56 <rom1504> (for example)
16:06:59 <touched_one> Where are the females, though?
16:07:06 <touched_one> Where are the white women?
16:07:14 <maerwald> do you have haskell questions?
16:07:19 <touched_one> Yes.
16:07:29 <touched_one> Why don't more ethnic people use Haskell?
16:07:36 <maerwald> ask them
16:07:51 <touched_one> I can't find any that programn.
16:08:10 <pharaun> in general or with haskell?
16:08:21 <pharaun> my team at work, i'm the minority here (white male)
16:12:44 <Welkin> touched_one: this channel is for haskell discussion, not socioeconomic analysis
16:12:55 <Welkin> is there something you want to know about haskell?
16:13:49 <maerwald> it's friday evening, so I guess people are in a "good mood"...
16:29:02 <dedgrant> argument = fix goalpost
16:45:34 <Benzi-Junior> ok I have a weird problem with stack when trying to build I get a bunch of error blocks saying "could not find module x it is a member of the hidden package y perhaps you need to add x to your build deps in your .cabal file" however all of these modules are in my build deps 
16:47:03 <pavonia> Benzi-Junior: And are they in the .cabal file too?
16:48:28 <Benzi-Junior> pavonia: yes they are (where else do you define the build deps ?)
16:48:55 <Benzi-Junior> pavonia: FYI trying stack out for the first time here
16:49:22 <pavonia> Hhm, sorry, I do not know stack well, I thought it would have an extra config file
16:52:01 <Benzi-Junior> pavonia: not as such there  is a .yaml file as well
16:56:12 <mgsloan> Did you put them in the right build-depends section? If your package has multiple components, then there are multiple
16:57:05 <platz> are they any ways to use websockets with servant?
16:58:19 <Benzi-Junior> mgsloan: by multiple components you mean if I have more than one module (.hs files) 
16:59:16 <Benzi-Junior> mgsloan: when you mention it none of the fails occur on main.hs
17:02:23 <mgsloan> Multiple components as in you can have a .cabal file stanza that looks like "library pkg", "executable exe", etc
17:02:54 <Benzi-Junior> mgsloan: aw bugger me I just realized I list them all as deps for the library not the executable
17:03:08 <mgsloan> Yuup
17:03:14 <Benzi-Junior> mgsloan: thanks
17:03:47 <mgsloan> Welcome! It's notable that this is a cabal thing rather than a stack thing, but I realize it can be hard to tell which thing is the issue
17:04:26 <maerwald> if you remove stack, you have one layer of failure less ;)
17:04:45 <Benzi-Junior> yes I realized that it was cabal I however am just as much of a newbie to cabal as I am to stack
17:05:34 <mgsloan> maerwald: Sure, unless you add cabal-install back atop, then you're in for some real fun
17:05:51 <maerwald> ?
17:06:24 <MarcelineVQ> maerwald: no stack or cabal-install makes jonnhy a dull boy
17:06:50 <maerwald> I cannot follow
17:06:58 <mgsloan> maerwald: Other than the little-used "stack solver" command, stack only uses the Cabal library, which is about half of the cabal project
17:07:24 <mgsloan> (e.g. "stack solver" does use the cabal-install binary)
17:07:41 <maerwald> stack does a lot more than just invoking the cabal library
17:07:46 <Benzi-Junior> true I have been using cabal install to install packages until now but I have never made a package as such so 
17:08:32 <mgsloan> maerwald: Indeed, but it tends to do so in a way that leads to more overall success where success is "chance of this thing compiling correctly"
17:08:45 <maerwald> I probably disagree there, but anyway
17:09:09 <pavonia> What are the advantages of using stack over cabal with sandboxes?
17:09:16 <mgsloan> As soon as you're developing multiple related packages, there's no comparison
17:09:19 <mgsloan> But yeah, I'm biased
17:09:21 <maerwald> pavonia: more blockers
17:09:40 <mgsloan> So what specifically do you find to be an issue?
17:09:48 <maerwald> the whole approach
17:09:51 <mgsloan> Where's the concrete evidence for this bugginess you're complaining of?
17:10:00 <mgsloan> Ah, so now it's the design rather than the quality
17:10:08 <maerwald> it's the approach yes
17:10:19 <mgsloan> What's so bad about it?
17:10:49 <maerwald> it doesn't solve the eco-system problems, but allows people to not care about them even more, which leads to more wrong dependencies in .cabal files
17:11:11 <maerwald> and less library maintainers caring about stable APIs
17:11:36 <maerwald> which are the actual problems (and they are indeed non-technical)
17:12:10 <maerwald> besides that, all my personal projects failed to work properly with stack
17:12:28 <maerwald> because at least one library is missing and then you end up with more blockers you would ever get with a cabal sandbox
17:12:40 <Zemyla> I know Parsec's performance is not as good as Attoparsec's, but what is its performance when fed manually produced tokens instead of just raw Strings or Texts?
17:12:49 <mgsloan> \=
17:13:09 <mgsloan> Hah, sorry was messing with a keyboard (just got a new ergodox)
17:14:37 <maerwald> but anyway, in this time of git, it's fancy to not have stable APIs or even releases, just look at v8... "try with latest master" ;)
17:18:17 <mgsloan> Stack does make it a bit easier to not think as much about dependency bounds.  Adding the necessary bounds becomes the responsibility of the package author, and stack can automate this via the "--pvp-bounds" flag.  But lets face it, hackage dependency bounds were already quite untenable.  Without a more streamlined way of bumping upper bounds throughout hackage, the amount of maintainer overhead is absurd
17:21:55 <mgsloan> stackage seems to be quite beneficial for the correctness of PVP bounds of the involved packages, since nightly is kept uptodate with latest, and so folks get notified about breakage
17:23:00 <maerwald> the point is, that the bounds should be _less_ tight, not just more correct
17:24:20 * hackagebot hsebaysdk 0.3.0.1 - Haskell eBay SDK  https://hackage.haskell.org/package/hsebaysdk-0.3.0.1 (ChristopherReichert)
17:25:08 <mgsloan> Consider that we currently don't have a good way (AFAIK) to compile and test your package with its full range of dependency versions.  Perhaps hackage matrix, but what about something I can use locally?
17:25:53 <mgsloan> In this environment, it's so very easy to violate version bounds after they've been determined
17:26:06 <mgsloan> This is something that *will* happen and does.
17:27:15 <mgsloan> It takes quite a bit of effort to widen your dependency bounds.  How often do you perform this manual labor?  I suppose each release of your package, or every commit to your repo, or what?
17:27:16 <bergmark> mgsloan: you can use matrix locally :-)
17:28:11 <mgsloan> That thought did come to mind as I was typing that
17:28:57 <bergmark> it doesn't test everything though, essentially just what "cabal install foo" for each GHC/package version
17:29:02 <mgsloan> Still, how many people that are writing their first hackage package are going to know to use such a tool?
17:29:07 <mgsloan> Awww, it should test too :/
17:29:58 <mgsloan> That's another reason having snapshots of packages is awesome.  They're all tested together, and if its a popular snapshot, other people have used that particular combination of libraries quite a lot as well
17:30:31 <mgsloan> So you're less likely to be the only person affected by some odd combination of package versions 
17:36:49 <maerwald> testing packages and making releases over a set of packages should be the job of distributions, but there's almost no package manager that's able to handle the complexity of the dependency graph haskell packages are causing
17:37:12 * Benzi-Junior has just succefully built his first project using stack 
17:39:13 <mgsloan> \o/
17:41:54 <maerwald> anyway, I have a data structure decision problem and I see 4 solutions, can anyone help me pick one or suggest a different one? http://lpaste.net/147422
17:42:02 <maerwald> I hope the problem can be understood from the context
17:52:05 <drbean> How do I warn the user on standard error? Do I have to do it myself with GHC.IO.Handle? I can't find any thing with google, hoogle and hayoo.
17:52:54 <drbean> dying is 'error'. What is warning?
17:54:09 <maerwald> > hPutStrLn stderr "error message"
17:54:11 <lambdabot>      Not in scope: ‘hPutStrLn’
17:54:11 <lambdabot>      Perhaps you meant one of these:
17:54:11 <lambdabot>        ‘BS.hPutStrLn’ (imported from Data.ByteString),
17:54:21 <maerwald> @hoogle hPutStrLn
17:54:22 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
17:54:22 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
17:54:22 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
17:54:44 <maerwald> stderr is a Handle
17:55:19 <Benzi-Junior> ok question where does stack throw up the executable ?
17:55:54 <geekosaur> ~/.local/bin iirc
17:56:06 <Welkin> it's benzrf junior!
17:56:07 <Welkin> how cute
17:56:23 <Lokathor> .stack-work/ if it's just in the project folder
17:56:23 <Welkin> benzrf: I didn't know you had a son
17:56:56 <Lokathor> eg, .stack-work\dist\d96ab9d9\build\tests
17:57:06 <Welkin> Benzi-Junior: if you want stack to place the binary somewhere easy to find it, use `stack install`
17:57:17 <Welkin> then it should place it in ~/.local/bin
18:01:14 <Benzi-Junior> Welkin: so build doesnt actually produce any files ?
18:01:45 <Welkin> yes
18:01:56 <Welkin> build will build the project
18:02:11 <Lokathor> build produces files within the project's .stack-work directory
18:02:23 <Lokathor> install copies those files to ~/.local/bin/
18:02:35 <Lokathor> well, just the binary, not all files
18:03:15 <ReinH> Cale: Your astar package is really nice thanks
18:03:22 <Cale> thanks!
18:03:45 <Cale> I wrote it in like 15 minutes by reading the Wikipedia article, haha
18:03:50 <Welkin> astar?
18:03:54 <Welkin> sounds scifi
18:03:55 <Cale> A* algorithm
18:03:56 <ReinH> Welkin: A* search
18:03:58 <Welkin> oh haha
18:04:00 <Benzi-Junior> Welkin: thanks a bunch
18:04:02 <Welkin> A* is great
18:04:10 <Cale> People have actually used it
18:04:14 <ReinH> Cale: yeah, it's straight-forward, but I really like the way it's parameterized
18:04:29 <ReinH> it's very generalized but easy to specialize
18:04:31 <Cale> Yeah
18:04:44 <Welkin> are you using it for pathfinding in a game?
18:05:20 <Lokathor> I was going to write A*
18:05:23 <Cale> If it had bugs I think I would have heard about them by now, but I'm not sure exactly how much it's been tested.
18:05:25 <Lokathor> but got distracted >_>
18:05:37 <Cale> Just as a warning
18:05:50 <Cale> I didn't use it myself, I just wrote it as an exercise and decided to package it :)
18:05:55 <ReinH> Cale: e.g., https://gist.github.com/reinh/f712ccc66708efc2108e
18:06:03 <Welkin> A* is just dijktsra with heuristics
18:06:09 <Cale> right
18:06:29 <Cale> I didn't want to assume anything about how the user is representing their graphs
18:06:40 <Cale> So I just take the things about the graph that I need to know as functions :)
18:06:41 <Lokathor> the way you'd use A* and the way you'd use dijkstra are somewhat different
18:06:50 <ReinH> Not quite. Dijkstra's original algorithm found the shortest path to a *single* goal.
18:07:08 <ReinH> In order to do multiple goals, you have to do multiple passes.
18:07:26 <ReinH> or compute the entire "dijkstra map" in a single pass, optionally breaking once all goals are found.
18:07:58 <Lokathor> ReinH, compute the full grid for each goal
18:08:08 <ReinH> Lokathor: yes, that's the "dijkstra map"
18:08:09 <Lokathor> then merge the different grids with min
18:08:21 <ReinH> My point still stands.
18:08:49 <Lokathor> i mean sure, you do still have to do one pass per goal
18:09:36 <xecycle> is this right?  anyApplicative <*> pure v = fmap ($ v) anyApplicative
18:10:18 <ReinH> xecycle: no
18:10:36 <ReinH> :t \a fa -> fmap ($ a) fa
18:10:38 <lambdabot> Functor f => a -> f (a -> b) -> f b
18:11:06 <ReinH> :t \a fa -> fa <*> pure a
18:11:07 <lambdabot> Applicative f => a -> f (a -> b) -> f b
18:11:30 <ReinH> xecycle: Well, I'm being unnecessarily pedantic. The constraints are different.
18:11:31 <xecycle> ah, I can assume all Applicatives are Functors, is that right then?
18:11:39 <ReinH> The behavior is the same if both are applicative.
18:11:45 <Cale> u <*> pure v = pure ($ v) <*> u = fmap ($ v) u
18:12:02 <Cale> according to the laws
18:12:51 <xecycle> ah ok.  maybe I should say that "=" as "=>" because it is not "<=>"
18:12:57 <ReinH> xecycle: TL;DR: yes, they are the same for Applicative instances.
18:13:03 <xecycle> ok thanks :)
18:14:16 <shirt> when using stm, is it better for performance to have one big "atomically" block, or to break it down into smaller transactions?
18:14:37 <ReinH> Cale: oh also thanks for not having many dependencies
18:14:46 <Cale> no problem :)
18:14:50 <Lokathor> shirt, it seems like a smaller transaction is more likely to go through at least
18:15:08 <Cale> ReinH: At some point I should make more packages out of the random stuff I have laying around
18:15:31 <shirt> Lokathor: thanks that makes sense. but what about the overhead of starting+committing each transaction?
18:15:33 <ReinH> Cale: seems god
18:15:37 <ReinH> Cale: what sort of random stuff?
18:16:04 <ReinH> or good
18:16:34 <Lokathor> shirt, i don't know about that. I just know what it says in the book: http://chimera.labs.oreilly.com/books/1230000000929/index.html
18:16:38 <Cale> I dunno, I've written lots of random bits of haskell code to solve various little problems from which I could probably extract a lot of things at least at the level of usefulness of that astar package.
18:17:01 <Cale> It's just, a disorganised mess of .hs files :P
18:17:21 <MarcelineVQ> post it as a repo :>
18:17:29 <Cale> hah
18:18:22 <Cale> git clone https://github.com/cgibbard/good-luck.git
18:18:29 <ReinH> hahahaha
18:18:36 <ReinH> I'm down
18:19:09 <Welkin> are you funky?
18:19:17 <Lokathor> yeah, i think working as much of it into a single unified system and smothing out the inconsisencies there is best
18:19:20 <Lokathor> if you have the time :/
18:22:25 <Cale> Well, one thing which is old but could definitely become a package is my totally impractical regular expression library that implements equivalence and inequality testing on regular expressions.
18:23:35 <Cale> (i.e. it can answer the question "are all strings matched by this regular expression also matched by this one?")
18:26:06 <Cale> I have an efficient implementation of Levenshtein's algorithm using ST
18:28:07 <ReinH> Cale: That is relevant to my interests (the regexp one)
18:29:19 <lpaste_> Cale pasted “Regular” at http://lpaste.net/147426
18:31:37 <dgpratt> ran into something really weird trying to build the network package on stack/Windows
18:31:49 <ReinH> Cale: nice
18:32:22 <dgpratt> which prompts me to ask: what stage or process would generate temporary .hscpp files?
18:33:19 <dgpratt> because the build process seems to be generating such a file from Network\Socket\Types.hsc, but it gets cut off
18:36:17 <DirkyJerky> :pl (\_ y -> y)
18:36:35 <Cale> @pl (\_ y -> y)
18:36:35 <lambdabot> const id
18:37:09 <DirkyJerky> I like this place already
18:43:16 <lispy> Cale: is that basically what model checkers do?
18:43:34 <lispy> Cale: take the intersection of two automata
18:52:56 <Cale> lispy: I don't really know what model checkers do, sorry :)
18:53:16 <dmwit_> shirt: I believe large transactions pay a very large cost for maintaining their transaction log.
18:53:24 <dmwit_> shirt: So if you can reduce the transaction size it can help a lot.
18:53:47 <dmwit_> shirt: But there's also a big semantic difference between one big transaction and many small ones, which is *usually* the driving factor in picking a transaction boundary.
18:54:29 <Cale> The more important problem with large transactions is that they tend to get trampled on by smaller ones, and have to retry
18:54:49 <Cale> But this is assuming that you actually have a choice
18:55:34 <Cale> When you break up a transaction, yeah, you're changing the meaning of the program a great deal.
18:57:31 <shirt> dmwit: thanks. makes sense. in my case the semantics are the same (hopefully i'm not mistaken :O)
18:57:47 <shirt> concurrent code can be tricky to reason about
18:58:18 <dmwit> (Like, the transaction log cost is quadratic in the number of tvars it touches or something like that.)
19:09:31 <Cale> dmwit: oh, whoa
19:09:37 <Cale> dmwit: that's... why?
19:29:25 * hackagebot list-prompt 0.1.0.0 - A simple list prompt UI for the terminal.  https://hackage.haskell.org/package/list-prompt-0.1.0.0 (yamadapc)
19:44:25 * hackagebot happstack-server-tls 7.1.6.1 - extend happstack-server with https:// support (TLS/SSL)  https://hackage.haskell.org/package/happstack-server-tls-7.1.6.1 (JeremyShaw)
19:56:17 <dmwit> Cale: I think each time you touch a tvar, it walks the list of all touched tvars to see if it's already in the list.
19:56:32 <dmwit> Cale: And that list really is a list and not some search tree. Don't know why about that part.
20:12:43 <dramforever> Hmm...I think I wrote some code that takes about 10x time *after* turning on -O, but it's kinda complexed (only 56 lines, but with a somewhat hard-to-explain algorithm). Anything I could do?
20:13:11 <Lokathor> try -O2 instead of -O? :P
20:13:51 <dramforever> a bit faster, but still much slower. I'm going to lunch, more details in a while
20:15:01 <Lokathor> sounds like an interesting case to submit to GHC if you figure it out
20:29:25 <lpaste_> dramforever pasted “performance, ChairTree.hs” at http://lpaste.net/147427
20:51:21 <dramforever> arrgh, I misread the profiling
20:51:33 <dramforever> it's just middle was called a lot more
20:51:41 <dramforever> now that's hard...
20:55:39 <dramforever> bingo, looks like line 24 of Main.hs, "let ct = buildChairTree xs", was called once for every query, instead of just once
21:04:58 <dramforever> optimization question: When does GHC decide to inline a let binding?
21:10:36 <bitemyapp> I've got divergent (and surprising - to me) behavior for a parser which behaves differently when run under Attoparsec and Trifecta.
21:10:41 <bitemyapp> http://lpaste.net/7725218724533239808
21:11:12 <bitemyapp> I haven't yet sussed out why it's ignoring/skipping the first newline with Trifecta (surprising) and just parsing a single value with Attoparsec on the eitherOr' input.
21:11:16 <bitemyapp> the latter is what I'd expect.
21:23:14 <adam`> Hey what is the best tutorial for somebody learning Haskell to understand some of the more interesting topics like (Monoids, Monads, Functors, and Applicative Functors)?
21:23:45 <dramforever> adam`: Typeclassopedia perhaps? https://wiki.haskell.org/Typeclassopedia
21:24:46 <adam`> thank you I will check it out
21:25:40 <lispy> adam`: you'll probably want to add monad transformers to that list eventually
21:26:17 <MarcelineVQ> @tell Ant___  bimap maximum minimum . unzip
21:26:17 <lambdabot> Consider it noted.
21:28:16 <adam`> Yeah I started with a language called Elm which is a compile to JS language which is similar to Haskell, but it seems like it hides away all of the complicated bits. So I figured since it seems really interested I would go to the root and try to learn the language as a whole.
21:28:40 <adam`> Do you guys have any analogies for somebody coming from an imperaive background to get started with those topics
21:28:54 <dramforever> bingo! just got a much simpler version that gets slower when optimized. before: 4.x s, after: still not terminated after 30s
21:28:57 <lpaste_> dramforever pasted “This code is much slower when optimized” at http://lpaste.net/147430
21:29:27 <Hijiri> adam`: I would stay away from analogies until you have a good grasp of the language
21:29:35 <dramforever> oh it's -O, FYI
21:29:58 <dramforever> adam`: short answer: no we don't
21:30:09 <adam`> When I look up Monoid I keep getting pages that essentially say that Monoids must follow certain rules, and those rules must follow meta rules. However, I never really get what they are as a whole
21:30:47 <dramforever> you know, imperative and functional people just don't program the same way
21:31:13 <Hijiri> adam`: I don't think there really is anything analogous to Monoid in typical imperative languages
21:31:36 <Hijiri> It might help to look at some concrete examples though
21:31:41 <adam`> Like they need to follow associativity, so when you compose (f . g) . h it should be the same as f . (g . h) right?
21:31:57 <adam`> and with the identity function if you have f . id you get f
21:31:57 <bitemyapp> replace . with <>, but sure.
21:32:04 <bitemyapp> @ty (<>)
21:32:04 <adam`> oh yeah right
21:32:05 <lambdabot> Monoid m => m -> m -> m
21:32:11 <dramforever> that could be an example of a monoid, yes
21:32:15 <dramforever> :t Endo
21:32:16 <lambdabot> (a -> a) -> Endo a
21:32:30 <adam`> So I heard the example of lists. where the empty list is []
21:32:51 <adam`> and then you can use ++ to join two lists together
21:33:35 <adam`> or clock arithmatic. if you would like to add two times together than you just add x and y and than mod by 12
21:33:48 <dramforever> just in case someone is interested: anyone knows when ghc decides to inline a let binding? I think it's causing the code posted earlier much slower.
21:33:59 <jle`> there's a nice functional pearls post on monoids and their applications in programming
21:34:39 <jle`> i think it was by the author of the diagrams library, which fittingly uses a lot of monoids to the benefit of the lib
21:34:43 <adam`> do you happen to know the link?
21:34:56 <dramforever> adam`: you probably need more examples on how monoid used, instead of examples of monoids...ahh jle` indeed indeed
21:34:59 <jle`> let's see if i'm lucky today
21:35:05 <jle`> @google functional pearls monoid
21:35:07 <lambdabot> http://repository.upenn.edu/cis_papers/762/
21:35:07 <lambdabot> Title: "Monoids: Theme and Variations (Functional Pearl)" by Brent A. Yorgey
21:35:11 <jle`> yup that's the one
21:35:22 <dramforever> adam`: ever got to monads? heard of the Writer monad?
21:35:25 <adam`> perfect thanks!
21:35:44 <jle`> the idea of monoids in programming is that their associativity lets you do a lot of 'correct' refactoring, and re-organizing algorithms
21:36:01 <jle`> and be sure that the results of rewrites is the same as the original
21:36:13 <adam`> dramforever: not yet, I have looked at the IO monad. There I see that you essentially make a 'recipe' for doing IO then the do syntax allows you to actually perform the action
21:36:14 <jle`> benefitting performance and data structure representations, etc.
21:36:31 <dramforever> adam`: ok forget about it then
21:36:37 <jle`> this is slightly different than the idea of the Monoid *typeclass* incidentally
21:36:52 <jle`> i guess it's easy to mix up monoids the concept and Monoid the typeclass
21:36:53 <adam`> jle so are they essentially just a special case of function composition?
21:37:09 <jle`> function composition is a special case of monoidal actions
21:37:12 <bitemyapp> technically in a lambda calculus many things fall under that umbrella
21:37:13 <jle`> monoidal "squishings"
21:37:19 <bitemyapp> depending on how you look at it
21:37:41 <dramforever> jle`: actually you could get a data structures that operates on values as long as they are monoids
21:38:23 <dmwit> categaries generalize function composition, and monoids specialize categories
21:38:25 <dramforever> rather famous example: http://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-FingerTree.html
21:38:29 <adam`> hmm. So if I have a function f : a -> b and a function g : b -> c and function h is f . g then we know the type of h is a -> c right
21:38:41 <adam`> but thats not associative so it is not a monoid?
21:38:41 <dmwit> so, "not really"
21:38:45 <jle`> adam`: associativity and the presence of an identity ends up being surprisingly powerful in terms of helping with refactorization
21:38:58 <jle`> adam`: yeah, but that's a bit unrelated to monoids
21:39:09 <bitemyapp> jle`: may I query?
21:39:12 <jle`> mhm
21:39:17 <adam`> but if f : a -> a and g : a -> a and h = g . f then they are associative?
21:39:36 <adam`> oh ok haha, I guess im on the wrong track
21:39:41 <dmwit> adam`: function composition is associative; why do you say it is not?
21:40:30 <adam`> actually nevermind the order of parenthesis wouldn't effect composition so it is associative
21:40:36 <dmwit> adam`: or, what is "they" in "they are not associative"?
21:40:41 <adam`> (f . g) . h == f . (g . h)
21:40:44 <jle`> it's associative...but not all associative things are monoids...monoids reprsent a specific type of associative operations
21:41:29 <adam`> I see, and then how does the bind (>>=) operator fit into all of this
21:41:51 <adam`> from what I gathered it seems like it is a way to explicitly model side effects while maintaining composition
21:42:11 <dmwit> it doesn't, really; (>=>) is more relevant
21:42:18 <dramforever> @src (>=>)
21:42:18 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:42:39 <dramforever> nah, someone should really remove it or something
21:42:49 <dmwit> (>=>) is associative and has a unit, like (.)
21:43:20 <dmwit> but it is not part of a monoid for basically tde same reason . isn't
21:43:25 <adam`> Ok I guess what I am wondering, is where is the best place to start. Like I feel as if because I dont have a solid foundation with all of this I am having trouble understanding the grander concepts
21:43:39 <jle`> there's the typeclassopedia
21:43:48 <dramforever> adam`: so what *is* the status of your current foundation?
21:44:00 <dmwit> i would start with the mundane examples, not the grand concepts
21:44:01 <adam`> What is the most basic idea that I need to start learning about that can get me started on my journey to understanding these things
21:44:15 <jle`> if you wanted a sort of overview/survey of these related concepts commonly used in haskell
21:44:20 <adam`> Well I am honestly still a beginner when it comes to higher level maths and functional programming
21:44:37 <adam`> I have taken Calculus 3 this term, and I have used languages like Clojure and Elm
21:44:43 <dmwit> typeclassopedia might be relevant to your interests
21:44:59 <dramforever> adam`: do you know what typeclasses are?
21:45:01 <adam`> So when it comes to higher order functions, and maps filters folds, I can understand pretty well
21:45:13 <dmwit> i think that includes a fair number of examples
21:45:22 <dramforever> adam`: oh that's some important information!
21:45:22 <adam`> I have a basic understanding of typeclasses. They seem similar to interfaces in other languages
21:45:38 <dmwit> ?where typeclassopedia
21:45:38 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
21:45:45 <dramforever> adam`: yes, they are like interfaces.
21:46:14 <Hijiri> adam`: have you looked at https://github.com/bitemyapp/learnhaskell or http://haskellbook.com/ ? Both would cover typeclasses, and with exercises
21:46:53 <adam`> I have not, so far I went through http://www.seas.upenn.edu/~cis194/spring13/ as my only resource
21:47:00 <isBEKaml> OHHAI, is there a module where I can find math constants?
21:47:28 <dmwit> what constants
21:47:46 <isBEKaml> dmwit: oh, constants like PI, E and so on
21:47:54 <dmwit> > pi
21:47:56 <dramforever> > [pi, exp 1]
21:47:57 <lambdabot>  3.141592653589793
21:47:58 <lambdabot>  [3.141592653589793,2.718281828459045]
21:48:01 <adam`> everything went well untill the last few chapters when they started talking about Functors.  They gave the example of fmap as a way to think about maps in a higher level so you can reduce work when trying to implement maps with trees, lists, etc
21:48:03 <dmwit> > exp 1
21:48:05 <lambdabot>  2.718281828459045
21:48:26 <isBEKaml> dramforever: dmwit: awesome, thanks
21:48:30 <dmwit> so, Prelude =)
21:48:53 <isBEKaml> dmwit: yes. GHC.Float
21:49:02 <adam`> thanks for all the links! looks like I have a lot of material to get me started.
21:49:19 <dramforever> adam`: good, so do you have an example where you got stuck?
21:49:35 <dramforever> in CS194, 09-functors, if I got you correct
21:50:30 <adam`> well I think I learn best if I have an example I can implement myself. However, I would always get errors when trying to follow allong with their code as these things were already implemented in the standard libraries
21:51:21 <adam`> I would get conflicts as it was ambigious to the compiler whether I was talking my instances of examples or the prelude ones
21:52:07 <adam`> So I guess for example the one I got stuck on is fmap.  How would I actually go about using this for something
21:52:28 <isBEKaml> adam`: cis194 is byorgey's course, right? I think he TA'd that one or handled it himself
21:52:47 <adam`> Brent Yorgey
21:52:49 <adam`> yeah
21:52:56 <jle`> you could always name your functions and typeclasses something different, adam` 
21:53:51 <isBEKaml> adam`: cool, I'm on and off that thing. Slow going for me :-)
21:54:29 <adam`> Yeah I tried to cover around two or three chapters each day since its my break. I think I will also try to go through learn you a haskell
21:54:45 <lispy> bitemyapp: I can't reproduce any weird behavior with your example: http://lpaste.net/7725218724533239808
21:54:53 <bitemyapp> lispy: it was tokenization.
21:55:02 <bitemyapp> lispy: integer is in TokenParsing.
21:55:08 <bitemyapp> lispy: 'token' gobbled up the \n's
21:55:22 <bitemyapp> lispy: only figured it out because jle` suggested it might be due to tokenization.
21:55:29 <adam`> jle' I think the issue I was having was when I would try to make an instance of the Functor typeclass. I dont have a minimal reproducable example off the top of my head, but let me see if I can figure something out
22:02:07 <adam`> On a completely unrelated note, what editor do you guys prefer when working with Haskell.  I am currently using Emacs, and while I really like it I was wondering if anybody has had a positive experiance with any other editor.
22:02:47 <lispy> adam`: I've used both emacs and vim for Haskell. If configured for your personal tastes they're both pretty good. You should look into ghc-mod.
22:03:56 <adam`> yeah that was recommended in the guide I followed to get started: https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
22:04:08 <jle`> i use vim but there probably isn't inherently anything about vim over emacs, sublime, etc. that makes it good for haskell
22:04:15 <jle`> it's just what i knew, and the plugins i found :)
22:04:41 <bitemyapp> adam`: if you like Emacs, stick with that, but don't get too far down the rabbit-hole with ghc-mod; a lot of people get stuck trying to make it work for their projects.
22:04:46 <adam`> Which editor would you guys say has the best REPL support (or i guess it is called interactive mode here)
22:04:50 <bitemyapp> I found using flycheck + stack to be more reliable for getting red squigglies.
22:05:11 <bitemyapp> adam`: if you really want it to be a buffer in your editor, Emacs, but even as an ex lisper who uses Emacs primarily I prefer to keep my GHCi in terminals.
22:05:20 <bitemyapp> partly because I usually have a bunch of them open, but for other reasons too
22:05:50 <lispy> tmux is a really great way to manage lots of command lines. So I use tmux + vim + ghci for work stuff.
22:05:54 <adam`> I usually have terminals open inside of emacs anyway. Its nice being able to use my keybindings there
22:06:06 <bitemyapp> lispy: I use XMonad.
22:06:24 <bitemyapp> some $ mod4 <> shift <> return
22:06:30 <bitemyapp> bang, bang, bang. Terminals.
22:07:34 <adam`> oh nice, stack flycheck looks interesting.
22:08:41 <bitemyapp> adam`: yeah so basically it does the error red squigglies bits that ghc-mod does
22:08:54 <bitemyapp> adam`: except the way it does it is so stone-dumb (running stack build and reading stdout/stderr)
22:08:57 <bitemyapp> adam`: it almost never breaks.
22:08:59 <bitemyapp> like, ever.
22:09:05 <bitemyapp> and I've worked on hairy projects/builds
22:09:18 <bitemyapp> whereas ghc-mod broke...a lot. all the time. for different and fascinating reasons each time.
22:09:28 <bitemyapp> I'd rather give up 20% bling for 99.99% reliability, myself.
22:09:32 <bitemyapp> so flycheck + stack it is.
22:09:38 <bitemyapp> oh it lints too.
22:09:43 <bitemyapp> I don't even really know why lol
22:09:47 * hackagebot amazonka-core 1.3.7 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.7 (BrendanHay)
22:09:49 * hackagebot amazonka 1.3.7 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.7 (BrendanHay)
22:09:51 * hackagebot amazonka-test 1.3.7 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.7 (BrendanHay)
22:09:53 * hackagebot amazonka-config 1.3.7 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.7 (BrendanHay)
22:09:54 <adam`> does it use hlint behind the scenes?
22:10:00 <bitemyapp> oh definitely
22:10:16 <bitemyapp> adam`: the reason I am confused it is able to do that is that I don't have hlint in my normal PATH.
22:10:21 <bitemyapp> so I'm not really sure how it even found it.
22:10:35 <adam`> I might look into that then because right now I have to switch between using GHC and HLINt, it would be nice to have one mode that does both.
22:10:40 <bitemyapp> maybe it stopped working at one point and I didn't notice, but the type errors are definitely there.
22:10:48 <bitemyapp> adam`: anyhoo, it gets better!
22:10:54 <bitemyapp> adam`: my entire working environment is open source!
22:11:02 <bitemyapp> adam`: https://github.com/bitemyapp/dotfiles steal that shit
22:11:09 <adam`> The only thing that is really annoying me is the indentation mode.  I am using structured haskell mode and it seems like it hates when people use enter
22:11:14 <bitemyapp> adam`: http://haskellstack.org/ then for Stack
22:11:17 <adam`> you have to use Ctrl-J for every new line
22:11:28 <bitemyapp> adam`: yeah you're supposed to write content that would prompt a newline
22:11:31 <bitemyapp> rather than asking for one manually
22:11:32 <bitemyapp> I think
22:11:46 <bitemyapp> adam`: I don't use SHM, but that shouldn't interfere with using my flycheck bits.
22:12:32 <adam`> Yeah its just I am used to paredit mode so I really like the refactoring capabilities it seems to provide.
22:12:47 <bitemyapp> @where stack-tutorial
22:12:47 <lambdabot> https://www.youtube.com/watch?v=sRonIB8ZStw
22:12:58 <bitemyapp> adam`: ^^ video tut for Stack
22:13:05 <adam`> ok how the hell does the lambdabot work
22:13:09 <adam`> that thing is amazing
22:13:28 <bitemyapp> it matches on text, I don't think it's any smarter than a regex on the prefix of what people say.
22:13:31 <adam`> is there a list of commands that it supports?
22:13:32 <jle`> well, most of it is just a bunch of pure modules
22:13:32 <bitemyapp> > 1 + 1
22:13:34 <lambdabot>  2
22:13:38 <lispy> @list
22:13:38 <lambdabot> What module?  Try @listmodules for some ideas.
22:13:40 <jle`>  @pl is a pure function, @undo is a pure function...
22:13:41 <lispy> @help
22:13:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:13:42 <bitemyapp> adam`: you can /query with lambdabot
22:13:49 <adam`> @listmodules
22:13:50 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
22:13:52 <bitemyapp> adam`: use the help/listmodules commands lispy demonstrated.
22:13:56 <lispy> huh, list and help used to be more helpful
22:14:02 <bitemyapp> lispy: yeah I don't know why they changed
22:14:12 <bitemyapp> lispy: virtually everyone will end up having to follow the indirection to listmodules.
22:14:20 <adam`> does it work as just a generic haskell interpreter?
22:14:28 <adam`> map (\x -> x * x) [1..5]
22:14:31 <bitemyapp> it's not more productive than using GHCi.
22:14:33 <jle`>  @eval is a specific module
22:14:42 <bitemyapp> but it can do most things GHCi does, although it has some thing imported already.
22:14:43 <jle`> that also provides pure function String -> String, pretty much
22:14:51 <lispy> adam`: you need to use the '> ' prefix if you want lambdabot to evaluate something
22:14:52 <jle`> > map (\x -> x * x) [1..5]
22:14:53 <lambdabot>  [1,4,9,16,25]
22:14:54 <lispy> > 1
22:14:56 <lambdabot>  1
22:15:02 <bitemyapp> > over both (+1) (1, 2)
22:15:04 <lambdabot>  (2,3)
22:15:08 <bitemyapp> woo lens
22:15:22 <jle`> > let x = x : map (*2) x in x
22:15:24 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ [a1]
22:15:24 <lambdabot>      Relevant bindings include x :: [a1] (bound at <interactive>:1:5)
22:15:24 <lambdabot>      In the first argument of ‘(:)’, namely ‘x’
22:15:24 <adam`> > take 10 $ iterate (+1) 0
22:15:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
22:15:38 <adam`> cool
22:15:38 <jle`> > let xs = 1 : map (*2) xs in xs
22:15:40 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
22:15:56 <adam`> if you define a let statement can I use it?
22:15:59 <adam`> > xs
22:16:03 <lambdabot>      Not in scope: ‘xs’
22:16:07 <adam`> :()
22:16:07 <lambdabot>      Perhaps you meant one of these:
22:16:11 <lambdabot>        ‘x’ (imported from Debug.SimpleReflect),
22:16:13 <jle`> `let x = y in blah` is actually an expression
22:16:16 <jle`> it's not a definition
22:16:23 <jle`> it's a self-contained epxression
22:16:24 <bitemyapp> or a statement
22:16:29 <bitemyapp> dang it
22:16:38 <adam`> well but if you said let something = something else
22:16:38 <bitemyapp> that was supposed to follow the negative assertion
22:16:45 <adam`> and I said in ... would that work
22:16:49 <jle`> but you can declare bindings to be defined in the lambdabot environment, though
22:16:58 <jle`> adam`: nah, that doesn't relaly make sense, syntactically...
22:17:04 <jle`> let .. in .. is an expression
22:17:05 <lispy> > foldr (+) z [a,b,c]
22:17:07 <lambdabot>  a + (b + (c + z))
22:17:18 <jle`> but you can declar new things to be defined in the lambdabot environment
22:17:23 <jle`> @let myNewThing = "hello"
22:17:25 <lambdabot>  Defined.
22:17:34 <adam`> > myNewThing
22:17:36 <lambdabot>  "hello"
22:17:36 <jle`>  @let is a separate command...somewhat unrelated to the `let` in `let ... in ..`
22:17:44 <adam`> that is pretty cool
22:17:46 <jle`> it's admittedly a confusing choice for a name
22:17:51 <adam`> its like a community focused repl
22:18:02 <lispy> adam`: yeah, lambdabot is a good teaching tool
22:18:22 <bitemyapp> adam`: good way of putting it.
22:18:30 <bitemyapp> also the f/g/h a/b/c stuff is really helpful when explaining folds
22:18:34 <bitemyapp> although it only goes so far
22:18:42 <bitemyapp> or Cale's trick. Either way.
22:19:39 <jle`> yeah, there's a value defined called 'x' that, when Show'd, becomes "x", so it's useful like that
22:19:41 <jle`> > x
22:19:42 <lambdabot>  x
22:19:55 <jle`> it just sits there all chill like that
22:20:16 <jle`> because why not
22:20:29 * hackagebot amazonka-sns 1.3.7 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.7 (BrendanHay)
22:20:31 * hackagebot amazonka-ecs 1.3.7 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.7 (BrendanHay)
22:20:33 * hackagebot amazonka-sqs 1.3.7 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.7 (BrendanHay)
22:20:35 * hackagebot amazonka-glacier 1.3.7 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.7 (BrendanHay)
22:20:37 * hackagebot amazonka-cloudhsm 1.3.7 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.7 (BrendanHay)
22:20:43 <jle`> the Num instance is decently useful though
22:20:44 <jle`> > x + x
22:20:46 <lambdabot>  x + x
22:21:19 <adam`> Hey can you guys recommend any good functional reactive programming libraries in haskell? It was one of the key ways to deal with events in elm and it seemed like a great way to model time.
22:21:26 <jle`> > iterate (+x) x
22:21:28 <lambdabot>  [x,x + x,x + x + x,x + x + x + x,x + x + x + x + x,x + x + x + x + x + x,x +...
22:21:47 <jle`> the most elmy frp libraries are probably going to be reactive-banana and reflex
22:21:49 <adam`> Or are Monads supposed to be a different tool that can be used to model state without the need of FRP
22:22:17 <jle`> FRP and monads are somewhat orthogonal concepts
22:22:24 <jle`> and tooling
22:22:30 <Cale> adam`: Reflex
22:22:30 <bitemyapp> adam`: Monads are too abstract to be about something as specific as FRP.
22:22:46 <bitemyapp> adam`: Monad is glue for a pattern. FRP is a method of dealing with a model of time/state
22:22:59 <Cale> adam`: But note that any concrete implementation of Reflex includes at least two monads
22:22:59 <bitemyapp> Monad knows nothing of state...or time...
22:23:29 <bitemyapp> adam`: and you'll see this a lot in many libraries addressing all kinds of problems (types having Monad instances), but they aren't always interesting.
22:23:37 <bitemyapp> or core to what the library does.
22:23:47 <bitemyapp> sometimes they're just there because they need to be to make something convenient.
22:25:39 * hackagebot amazonka-dynamodb 1.3.7 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.7 (BrendanHay)
22:25:41 * hackagebot amazonka-datapipeline 1.3.7 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.7 (BrendanHay)
22:25:43 * hackagebot amazonka-iam 1.3.7 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.7 (BrendanHay)
22:25:45 * hackagebot amazonka-kinesis-firehose 1.3.7 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.3.7 (BrendanHay)
22:25:47 * hackagebot amazonka-route53-domains 1.3.7 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.7 (BrendanHay)
22:26:34 <adam`> huh, interesting. so how come whenever you hear about modeling state in haskell you always use Monads?
22:27:04 <jle`> the state of pedagogy in haskell is fairly poor
22:27:11 <bitemyapp> Monad eliminates some obnoxious glue, but the API is more than just (>>) and (>>=)
22:27:25 <bitemyapp> it's not that State defines Monad, but that State can have a lawful Monad instance.
22:27:39 <bitemyapp> it's a bit more convenient/obvious for State than some things, but it's necessary at all.
22:27:43 <jle`> there are definitely good resources but you're probably going to be hearing more not-even-wrong things than useful/correct things
22:27:51 <bitemyapp> but if you eschew >>/>>= you'll just be repeating code that was in the Monad instance.
22:27:54 <adam`> see this is why I want to learn more about this stuff haha. it seems like the more I find out the less I actually know
22:28:04 <bitemyapp> adam`: well, I think we do a good job of this in the book
22:28:07 <bitemyapp> @where book
22:28:07 <lambdabot> http://haskellbook.com/
22:28:10 <bitemyapp> adam`: ^^
22:28:33 <bitemyapp> adam`: but you'll have to decide if the money is worth it to you or not. Our readers seem very happy, to understate it a bit.
22:29:30 <bitemyapp> adam`: there are alternatives to the book, but they involve scraping together a lot of resources, blog posts, papers, trial and error, etc.
22:29:57 <bitemyapp> the book doesn't replace all of this, but I don't think it'd be unrealistic to say it saves people a _lot_ of time, even if they already know the basics.
22:30:21 <bitemyapp> we also cite/recommend follow-up materials at the ends of the chapters.
22:30:30 <bitemyapp> so if you want to go deeper, there's that.
22:30:49 * hackagebot amazonka-directconnect 1.3.7 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.7 (BrendanHay)
22:30:51 * hackagebot amazonka-elasticsearch 1.3.7 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.3.7 (BrendanHay)
22:30:53 * hackagebot amazonka-devicefarm 1.3.7 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.7 (BrendanHay)
22:30:55 * hackagebot amazonka-cognito-sync 1.3.7 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.7 (BrendanHay)
22:30:57 * hackagebot amazonka-elb 1.3.7 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.7 (BrendanHay)
22:31:43 <adam`> very cool
22:32:11 <bitemyapp> adam`: anyhoo, people seem to particularly like the balance of precision and intuition in the Monoid/Functor/Applicative/Monad sequence.
22:32:18 <bitemyapp> adam`: it's reinforced with (hella) exercises as well
22:32:27 <bitemyapp> adam`: so you either learn the material or don't escape alive
22:32:29 <bitemyapp> (jk)
22:32:42 <adam`> Any idea as to when it will be completed? It seems like it is 70% finished now right?
22:32:46 <bitemyapp> (actually don't get too wound up if you get stuck on an exercise, some of those are curveballs for smart alecks)
22:33:26 <bitemyapp> adam`: well, if neither of us (I have a co-author Julie, her first programming language is Haskell) get hit by a bus, then we'd like to have a content-complete PDF in February or March.
22:33:46 <bitemyapp> adam`: the book already covers the stuff you want to know right this very minute
22:33:53 <bitemyapp> I'm working on parsers as we, uh, "speak"
22:33:58 <bitemyapp> Julie's been working on monad transformers.
22:34:04 <bitemyapp> that release is Real Soon Now (tm)
22:34:36 <adam`> Ok sweet. I will try to read through the first three chapters that are provided and pick up a copy if it seems like it is working for me
22:34:42 <bitemyapp> adam`: we'll be 81% done after this release that's coming in a few days.
22:34:47 <bitemyapp> at most a week.
22:34:56 <bitemyapp> adam`: ah, one caveat, first chapter isn't in there.
22:35:06 <bitemyapp> adam`: first chapter is Lambda Calculus, it's not in the sample.
22:35:18 <bitemyapp> adam`: if you decide not to get it, please ping because I'd like to know what, if anything, in the sample put you off.
22:35:22 <bitemyapp> ping me*
22:35:54 <adam`> sounds good, just based on this conversation here it seems like you guys know your stuff haha
22:35:59 * hackagebot amazonka-cloudformation 1.3.7 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.7 (BrendanHay)
22:36:00 <adam`> im sure it will be an interesting read
22:36:01 * hackagebot amazonka-sts 1.3.7 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.7 (BrendanHay)
22:36:03 * hackagebot amazonka-autoscaling 1.3.7 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.7 (BrendanHay)
22:36:05 * hackagebot amazonka-kinesis 1.3.7 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.7 (BrendanHay)
22:36:07 * hackagebot amazonka-kms 1.3.7 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.7 (BrendanHay)
22:36:14 <bitemyapp> adam`: well, more importantly (I would argue) is that we test the material with learners.
22:36:22 <adam`> anyway I have to get going for tonight, still have a few things I have to take care of! Nice to meat you all
22:36:28 <bitemyapp> adam`: and make sure stuff makes sense and works as a tool for learning, rather than a feather in my professional cap.
22:36:38 <bitemyapp> adam`: cheers, thanks for your time :)
22:36:42 <jle`> adam`: happy haskelling!
22:38:30 <bitemyapp> jle`: currency in #haskell-beginners is dog pictures
22:38:38 <bitemyapp> jle`: so here's my fank-you for the help earlier: https://twitter.com/bitemyapp/status/677907420820070400
22:38:59 <jle`> ty :3
22:40:09 <wedens> there is no generalized intercalate, is there? (Foldable f, Monoid a) => a -> f a -> a
22:41:09 * hackagebot amazonka-cloudsearch-domains 1.3.7 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.7 (BrendanHay)
22:41:11 * hackagebot amazonka-cloudwatch 1.3.7 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.7 (BrendanHay)
22:41:13 * hackagebot amazonka-cloudtrail 1.3.7 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.7 (BrendanHay)
22:41:15 * hackagebot amazonka-elasticache 1.3.7 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.7 (BrendanHay)
22:41:17 * hackagebot amazonka-waf 1.3.7 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.3.7 (BrendanHay)
22:46:19 * hackagebot amazonka-importexport 1.3.7 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.7 (BrendanHay)
22:46:21 * hackagebot amazonka-s3 1.3.7 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.7 (BrendanHay)
22:46:23 * hackagebot amazonka-swf 1.3.7 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.7 (BrendanHay)
22:46:25 * hackagebot amazonka-sdb 1.3.7 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.7 (BrendanHay)
22:46:27 * hackagebot amazonka-codecommit 1.3.7 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.7 (BrendanHay)
22:46:42 <dfeuer> bitemyapp?
22:47:09 <bitemyapp> dfeuer?
22:47:22 <dfeuer> I think you might appreciate this feature request: https://ghc.haskell.org/trac/ghc/ticket/11186#comment:4
22:47:37 <dfeuer> (that last comment is where I finally found a small example)
22:48:14 <bitemyapp> dfeuer: aw cripes, yes.
22:48:23 <dfeuer> :)
22:48:26 <bitemyapp> dfeuer: I actually ran into a situation where I wanted to show types in a typeclass instance in the book
22:48:34 <bitemyapp> dfeuer: but couldn't without the use of ScopedTypeVariables
22:48:43 <bitemyapp> then it's like...do I really want to explain this right now?
22:48:43 <dfeuer> This is WITH ScopedTypeVariables.
22:48:46 <bitemyapp> I know
22:48:50 <bitemyapp> that's why I brought up the anecdote
22:48:57 <bitemyapp> but if STV then dropped the names for the damn variables
22:49:01 <bitemyapp> I'd be extra-pissed
22:49:03 <dfeuer> As far as I'm concerned, ScopedTypeVariables is NECESSARY to have sanity.
22:49:08 <bitemyapp> if I then wrote that into the book and then somebody got confused
22:49:26 <dfeuer> I think this is something the gurus might be willing to fix.
22:49:41 <bitemyapp> well, I hope so. You have my (+1)
22:50:07 <bitemyapp> dfeuer: but yeah, it's hard to avoid STV if you want to slap explicit types on intermediate expressions in typeclasses that involve polymorphic type variables.
22:50:14 <bitemyapp> instances, I should say.
22:50:30 <bitemyapp> unless there's some trick here I've missed.
22:50:34 <dfeuer> Usually it preserves type variables, which is good, but here it preserves *the wrong ones*.
22:50:37 <bitemyapp> seems like a weird thing to miss.
22:51:02 <dfeuer> It took me a while to figure that bit out. At first I thought it was pulling them out of nowhere.
22:51:25 <dfeuer> STV is necessary for a lot of intermediate expression stuff.
22:51:29 * hackagebot amazonka-codedeploy 1.3.7 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.7 (BrendanHay)
22:51:31 * hackagebot amazonka-cloudfront 1.3.7 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.7 (BrendanHay)
22:51:33 * hackagebot amazonka-efs 1.3.7 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.7 (BrendanHay)
22:51:35 * hackagebot amazonka-codepipeline 1.3.7 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.7 (BrendanHay)
22:51:37 * hackagebot amazonka-elasticbeanstalk 1.3.7 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.7 (BrendanHay)
22:52:05 <dfeuer> What is this Amazon shit hackagebot is spewing on about?
22:52:28 <bitemyapp> dfeuer: amazonka has a generated API
22:52:41 <bitemyapp> dfeuer: and it's broken out into a million libraries because AWS has the surface area of the fucking death star
22:52:55 <bitemyapp> dfeuer: amazonka is part of the reason the builder has been crying uncle lately
22:53:01 <dfeuer> :(
22:53:04 <bitemyapp> I don't blame them, but holy god.
22:53:12 <bitemyapp> I think it was very clever to generate all the obvious stuff.
22:53:15 <bitemyapp> computers, ya know?
22:53:20 <bitemyapp> but why the 9001 libraries
22:53:22 <bitemyapp> why
22:53:28 <dfeuer> HRRRR
22:53:53 <bitemyapp> I don't actually know of anything with more broken out sub-libraries than amazonka.
22:53:59 <bitemyapp> and it's actively developed
22:54:29 <dfeuer> Well, presumably it saves on crud when only using one package.
22:54:48 <dfeuer> Potentially avoids deps, downloads, etc.
22:55:05 <bitemyapp> all true
22:55:13 <bitemyapp> I guess I should just blame AWS.
22:55:17 <bitemyapp> I'm okay with blaming AWS.
22:55:17 <dfeuer> :)
22:55:35 <bitemyapp> if I had to guess, Brendan changed something in the base library (handles auth and the like)
22:55:40 <bitemyapp> and that churned everything else.
22:56:06 <dfeuer> Sounds likely.
22:56:39 * hackagebot amazonka-apigateway 1.3.7 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.3.7 (BrendanHay)
22:56:41 * hackagebot amazonka-ses 1.3.7 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.7 (BrendanHay)
22:56:43 * hackagebot amazonka-support 1.3.7 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.7 (BrendanHay)
22:56:44 <bitemyapp> aha, another wave.
22:56:45 * hackagebot amazonka-dynamodb-streams 1.3.7 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.7 (BrendanHay)
22:56:47 * hackagebot amazonka-redshift 1.3.7 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.7 (BrendanHay)
22:56:51 <bitemyapp> whee ride the wave everybody
22:56:54 <bitemyapp> hang ten!
22:57:01 <bitemyapp> it's like weather, but for text creatures.
22:58:39 <dfeuer> I should probably block hackagebot on my client, but I don't know if I can be bothered.
23:00:48 <bitemyapp> dfeuer: I definitely CBA
23:01:17 <bitemyapp> dfeuer: and I've discovered cool libraries because of it
23:01:41 <dfeuer> bitemyapp, you could always just browse the hackage index. 
23:01:49 * hackagebot amazonka-opsworks 1.3.7 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.7 (BrendanHay)
23:01:51 * hackagebot amazonka-emr 1.3.7 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.7 (BrendanHay)
23:01:53 * hackagebot amazonka-cognito-identity 1.3.7 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.7 (BrendanHay)
23:01:55 * hackagebot amazonka-ssm 1.3.7 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.7 (BrendanHay)
23:01:57 * hackagebot amazonka-ml 1.3.7 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.7 (BrendanHay)
23:02:34 <bitemyapp> dfeuer: aint_nobody_got_time_for_that.gif
23:02:39 <bitemyapp> dfeuer: I'm already the #HackageFairy anyway.
23:02:57 <bitemyapp> dfeuer: I've browsed it before, I just don't always retain things or know what they're for from a quick skim.
23:03:11 <dfeuer> Me neither. But hackagebot doesn't say what they are either.
23:04:23 <bitemyapp> dfeuer: it's a prompt.
23:04:30 <bitemyapp> and it's a prompt with a good selection bias
23:04:37 <bitemyapp> because if it shows up here, it's being developed.
23:04:56 <dfeuer> This is Haskell, so that particular bias isn't reliably good.
23:05:06 <ReinH> dfeuer: o/
23:05:53 <bitemyapp> dfeuer: less good anyway, fair point.
23:05:59 <bitemyapp> dfeuer: somehow we manage to "finish" stuff :P
23:06:07 <dfeuer> If you're glancing occasionally at updates, you might never see transformers or mtl or reflection ...
23:06:23 <bitemyapp> different kinds of libraries have different ideal lifecycles.
23:06:27 <dfeuer> Yup.
23:06:37 <bitemyapp> the more foundational stuff is more well known anyway
23:06:39 <dfeuer> Some will enver be done.
23:06:42 <dfeuer> never
23:06:59 * hackagebot amazonka-workspaces 1.3.7 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.7 (BrendanHay)
23:07:01 * hackagebot amazonka-inspector 1.3.7 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.3.7 (BrendanHay)
23:07:03 * hackagebot amazonka-rds 1.3.7 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.7 (BrendanHay)
23:07:05 * hackagebot amazonka-iot 1.3.7 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.3.7 (BrendanHay)
23:07:07 * hackagebot amazonka-ds 1.3.7 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.7 (BrendanHay)
23:07:54 <dfeuer> Is there some magical way to ask hackagebot not to bother reporting anything amazonka other than the base package? Because I guarantee no one cares.
23:08:16 * bitemyapp laughs
23:08:30 <bitemyapp> I don't think the lambdabot maintainer will want to special-case it, but it's worth a shot.
23:08:50 <cocreature> I have set my irc client to filter the amazonka packages :)
23:09:41 <dfeuer> sm seems to own hackagebot.
23:09:49 <dfeuer> Whoever that is.
23:09:55 <Adeon> use your IRC client's advanced ignoring features to selectively ignore lines
23:10:18 <bitemyapp> 'advanced'
23:10:56 <jle`> i use telnet for all my irc stuff so advanced ignoring features is me choosing to not read a line
23:11:25 <jle`> telnet is the best irc client
23:11:31 <dfeuer> I should go to sleep. I get to see my boyfriend tomorrow, and I should get a haircut first.
23:11:32 <cocreature> ponging all day long :)
23:11:47 <dfeuer> jle`, why do you do that?
23:11:47 <jle`> yes, it makes you work for your lambdabot queries
23:12:04 <jle`> automated ponging cheapens the experience
23:12:09 * hackagebot amazonka-cloudwatch-logs 1.3.7 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.7 (BrendanHay)
23:12:11 * hackagebot amazonka-route53 1.3.7 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.7 (BrendanHay)
23:12:13 * hackagebot amazonka-cloudsearch 1.3.7 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.7 (BrendanHay)
23:12:15 * hackagebot amazonka-storagegateway 1.3.7 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.7 (BrendanHay)
23:12:17 * hackagebot amazonka-ec2 1.3.7 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.7 (BrendanHay)
23:14:10 <bitemyapp> dfeuer: congrats on seeing the bf. Yes get a haircut :)
23:14:42 <dfeuer> OK, OK, good night. :)
23:17:19 * hackagebot amazonka-marketplace-analytics 1.3.7 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.3.7 (BrendanHay)
23:17:21 * hackagebot amazonka-elastictranscoder 1.3.7 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.7 (BrendanHay)
23:17:23 * hackagebot amazonka-lambda 1.3.7 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.7 (BrendanHay)
23:17:58 <Adeon> is there a tool to mass upload hackage packages
23:18:03 <Adeon> not that I need one, just wondering
23:18:35 <Adeon> probably something you could just shellscript
23:32:50 * hackagebot asn1-types 0.3.2 - ASN.1 types  https://hackage.haskell.org/package/asn1-types-0.3.2 (VincentHanquez)
23:39:39 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
23:39:39 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
