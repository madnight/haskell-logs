00:02:10 <SX> Could anyone please help me a little? How to use exceptions so it won't bloat my code?
00:02:25 <SX> With handlers I mean
00:03:00 <SX> And how to define my own exceptions so it would be easier to handle them?
00:03:14 <Lokathor> MarcelineVQ, hmm, I tried adding that to my global .yaml file and it said there's no cabal file. do you mean that you used that in a project of yours that used gloss?
00:05:00 <kadoban> Lokathor: Copy just the part from extra-deps and down to resolver: into your global stack.yaml file. If you already wiped yours out, remove the packages: line and the line below it. from the one he pasted.
00:07:05 <xacktm> Hi, I'm having basic trouble with imagining a functional implementation:  I have a list of keys [k] for a HashMap that I want to update with insertWith - how do I iterate over each key in left to right order and have one final HashMap?
00:07:14 <Lokathor> alright after several more deps added it seems to be building with the following global yaml: http://lpaste.net/147767
00:07:44 <kadoban> Lokathor: That looks sane. Hope it works.
00:07:54 <Lokathor> 16/27
00:07:56 <Hijiri> xacktm: You can use a fold, with the HashMap as accumulator
00:09:08 <Hijiri> foldr (\newElem oldMap -> insertWith f newElem oldMap) empty listofkeys, or something like that. The argument order for insertWith might be different, but I think this gives the general idea
00:09:31 <Hijiri> if this is correct then it can be shortened to foldr (insertWith f) listofkeys
00:09:43 <Hijiri>  foldr (insertWith f) empty listofkeys I mean
00:11:32 <Lokathor> yikes
00:11:36 <Lokathor> no glut32
00:11:44 <Hijiri> @hoogle HashMap
00:11:46 <lambdabot> package hashmap
00:11:46 <lambdabot> package linkedhashmap
00:11:58 <Hijiri> I don't know if lambdabot has imported
00:12:12 <kadoban> Lokathor: The C library? :(
00:12:29 <xacktm> Hijiri: oh wow, how could I forget regular folds - I was messing with mapAccumL and really considering union as the combiner operator...
00:12:32 <Lokathor> yeah. i mean it makes sense since haskell's is just a binding after all
00:12:58 <Lokathor> i'll have to sort that out later
00:13:22 <kadoban> Yeah. It does suck a bit, but I suppose it's kind of beyond something stack or whatever could sanely handle.
00:13:53 <Lokathor> from what i hear, windows 10 hasn't changed their attitude much on the issue of being developer friendly in that way
00:14:11 <Lokathor> of having a sort of default dev structure to put files in that a compiler can check and such
00:29:02 <stevejb> hello, I have a quick question about getting some types to line
00:29:02 <stevejb> 	  up. I have this function:
00:29:07 <stevejb> getQuestionNode :: Text -> IO Node  [00:27]
00:29:38 <stevejb> I would like to map over this function inside the runBatch monad (http://hackage.haskell.org/package/haskell-neo4j-client-0.3.2.0/docs/Database-Neo4j-Batch.html)
00:30:21 <stevejb> do I need to use sequence, liftIO, mapM? This part still trips me up.
00:30:53 <mauke> if you mean Batch, you can't
00:31:38 <stevejb> oh really? oh okay I see
00:32:08 <stevejb> I think that I can restructure a bit to not need to do this
00:43:05 <wowdog> hi, is it possible to use multiple conditions on filter() ? e.g.   filter ( > 1 && < 5) [1..10], it doesn't work so far
00:43:49 <Hijiri> > filter (\x -> x > 1 && x < 5) [1..10]
00:43:50 <lambdabot>  [2,3,4]
00:44:29 <jle`> > filter (and . sequence [(> 1), (< 5)]) [1..10]   -- might generalize better for more than 2 conditions
00:44:31 <lambdabot>  [2,3,4]
00:44:38 <mauke> all
00:45:46 <quchen> Huh, why is Happstack deprecated on Hackage?
00:45:49 <quchen> ?hackage happstack
00:45:49 <lambdabot> http://hackage.haskell.org/package/happstack
00:48:18 <xacktm> it's deja vu... that and . sequence construction is nice btw
00:51:07 <pyon> Can I define reusable kind synonyms?
00:51:32 <pyon> I'm getting tired of defining lots of classes whose argument has kind `(k -> k -> *) -> (k -> k -> *)`.
00:52:16 <jle`> #define k3 (k -> k -> *)
00:52:36 <pyon> jle`: Without ugly hacks, of course.
00:53:05 <pyon> I originally come from C++, and when I learnt what the world was like without using the C preprocessor, I decided not to go back. :-p
00:53:19 <MarcelineVQ> a rose by any other name
00:57:34 <xacktm> ghc has crashed with stack-space-overflow and leaked a few GB of memory - is there a way to reclaim them short of rebooting?
01:02:09 <xacktm> and related, does anyone with a decent amount of RAM want to do me a favor and run an inefficient HashMap program? :)
01:02:43 <xacktm> I think the issue is that HashMap is immutable, but I'd want mutability for memory savings
01:03:42 <MarcelineVQ> idk if people will run it but you can link to it and people might have suggestions about common pitfalls
01:05:32 <xacktm> ok
01:05:41 <pavonia> xacktm: How can a proces leak memory after crashing?
01:06:40 <xacktm> it might not be... but I could've sworn there wasn't this much swap before
01:12:28 <Hijiri> xacktm: if you are using foldr, you might want to use foldl' instead (and also strict HashMap if you aren't already_
01:12:44 <SX> Anyone using BasicPrelude?
01:13:12 <Hijiri> for the insertion thing
01:13:20 <xacktm> I think the complexity is O(n^2) http://lpaste.net/5960692674385149952 input https://bpaste.net/show/6c6a1f17ddac
01:13:32 <xacktm> Hijiri: hmm let me see
01:14:06 <SX> Why could `'show' is not a (visible) method of class 'Show'` be?
01:14:58 <Hijiri> xacktm: yeah, you will want to use foldl' instead of foldl
01:16:28 <xacktm> what does 'strict application of the operator' mean?
01:19:12 <Hijiri> it means the accumulator will be evaluated to the outermost constructor each time the function is applied
01:20:00 <Hijiri> the operator is the function you give it
01:20:03 <pyon> My project has three modules (so far): Free.Semigroupoid.Class, Free.Semigroupoid.Cons and Free.Semigroupoid.Snoc. The last two depend on the first one. I can load the first one successfully in the REPL, but loading either of the last two fails.
01:20:05 <Hijiri> the "operator"
01:21:02 <Hijiri> it will evaluate a bit more because insertWith is strict
01:21:30 <xacktm> Hijiri: ok, I guess that's in contrast to lazily when I call size or length or whatever finally evaluates it
01:23:16 <lamefun> can I make OverloadedStrings literals to resolve to Text when ambiguous?
01:27:44 <xacktm> using foldl' has a marked improvement on memory usage.. and it's done :D
01:28:21 <xacktm> and it's correct :)
01:28:28 <xacktm> Thanks Hijiri 
01:29:47 <cdepillabout> lamefun: I think you should be able to use haskell's defaulting stuff.
01:30:00 <cdepillabout> Here's an example of Shelly using it: https://github.com/yesodweb/Shelly.hs
01:30:09 <cdepillabout> `default (T.Text)`
01:34:33 * hackagebot gitHUD 1.0.0.0 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.0.0.0 (gbataille)
01:59:27 <joehillen> For lens, is there a way to apply a field getter over a list of records? my only option seems to be: map (view myField) values
02:05:07 <dredozubov> joehillen: toListOf myField values
02:05:20 <dredozubov> or `values ^.. myField`
02:05:52 <joehillen> I tried `values ^.. myField` but I'm getting an error
02:06:10 <dredozubov> oh, i'm sorry
02:06:16 <dredozubov> you'll need to traverse it first
02:06:36 <dredozubov> try `values ^.. traverse . myField` or `values ^.. each . myField`
02:07:27 <joehillen> dredozubov: that's it. thank you!
02:07:40 <dredozubov> np
02:16:28 <kqr> `if p then Just x else Nothing`   <- is there a way to write that without being so explicit about it other than [x | p] and monadcomprehensions?
02:16:45 <kqr> maybe something something guard
02:18:54 <kqr> `if p then pure x else empty` is the core of it I guess... maybe
02:20:41 <joehillen> bool (const Nothing) Just p x
02:21:42 <dredozubov> i'd say it's the same level of expressiveness
02:22:08 <dredozubov> explicitness i mean >.>
02:25:03 <indiagreen> x <$ guard p
02:25:23 <indiagreen> kqr: ^
02:25:42 <joehillen> dude
02:25:48 <joehillen> awesome
02:26:44 <indiagreen> you can also reverse it (and it would look better imo)
02:26:48 <indiagreen> guard p $> x
02:26:54 <indiagreen> but you need Data.Functor for that
02:30:19 <jle`> there is no ($>)
02:30:27 <jle`> oh
02:30:30 <jle`> whaaaaaaaaat
02:30:32 <jle`> when did this happen
02:30:53 <jle`> :O
02:31:17 <jle`> this is life changing
02:31:22 <jle`> but i'm already used to x <$ guard p
02:31:24 <jle`> :|
02:33:49 <kqr> hahahah
02:33:54 <kqr> i still don't grok <$
02:34:02 <kqr> i mean I've used it, but only when other people say I should
02:34:20 <jle`> it's just a "replace the value"
02:34:28 <jle`> > 5 <$ Just "hello"
02:34:29 <lambdabot>  Just 5
02:34:41 <kqr> ohh
02:34:48 <jle`> keep the structure/action, replace the value
02:34:52 <jle`> > 5 <$ Nothing
02:34:53 <lambdabot>  Nothing
02:35:00 <jle`> > 5 <$ [True,False,True]
02:35:01 <lambdabot>  [5,5,5]
02:35:12 <kqr> b <$ ma    is     fmap (const b) ma     ?
02:35:22 <jle`> `5 <$ putStrLn "hello"` is, it putts "hello" to the screen
02:35:27 <jle`> and the result of the action is 5
02:35:31 <jle`> if you happen to >>= or <- it
02:35:35 <jle`> or fmap it or something
02:35:45 <jle`> kqr: yeah, that's exactly it
02:35:55 <jle`> except you can provide a more optimal implementation if you want, for your type
02:36:07 <kqr> > fmap (const 5) (putStrLn "hello")
02:36:09 <lambdabot>  <IO Integer>
02:36:16 <indiagreen> I learned $> by noticing that I was often writing “guard p *> return x” and then I found out about “$>” and thought “aha, so $> is a simpler version of *> for when you just want to return something constant”
02:36:26 <kqr> ah yes, that does putStrLn
02:37:01 <jle`> yeah, foo *> return x just x <$ foo, but i guess foo $> x looks nicer and the analogy is clearer
02:37:10 <jle`> kqr: yeah; it does the action, but returns a different result
02:37:28 <jle`> like a "replaceResult"
02:38:02 <jle`> but yeah it's fmap and const
02:46:27 <kqr> now that i'm here... ix vs at? never understood that stuff
02:46:52 <jle`> oh, those are lens stuff
02:47:45 <indiagreen> ix can access more things
02:47:55 <kqr> http://stackoverflow.com/a/18414280/1463507
02:48:00 <indiagreen> at can only access Map-like things, but it also lets you insert values
02:48:00 <kqr> might be helpful to me
02:48:03 <kqr> yeah
02:59:35 * hackagebot tracy 0.1.1.0 - Convenience wrappers for non-intrusive debug tracing  https://hackage.haskell.org/package/tracy-0.1.1.0 (dredozubov)
03:25:47 <lonokhov> is there a way to catch timeout in tasty tests? I want to show some context besides "timed out"
03:34:36 * hackagebot tracy 0.1.2.0 - Convenience wrappers for non-intrusive debug tracing  https://hackage.haskell.org/package/tracy-0.1.2.0 (dredozubov)
03:35:22 <javjarfer> Hi! Anyone knows which is the base replacement for renderWithDrawable for Gtk3??
03:50:59 <trubert1> how do I use cabal to run a named test group inside a testsuite? I'm looking for something like `cabal test my-test-group`.. ?
04:04:37 * hackagebot gremlin-haskell 0.1.0.0 - Graph database client for TinkerPop3 Gremlin Server  https://hackage.haskell.org/package/gremlin-haskell-0.1.0.0 (nakaji_dayo)
04:14:37 * hackagebot subleq-toolchain 0.1.8.5 - Toolchain of subleq computer.  https://hackage.haskell.org/package/subleq-toolchain-0.1.8.5 (na4zagin3)
04:29:04 <NockNocx> would you declare this defintion "a function f assigns an output f(x) to every input x" by an expression?
04:29:32 <NockNocx> I mean in haskell style
04:31:01 <Freundlich> If you say what the function's domain and codomain are, you can express this as a function type.
04:31:58 <NockNocx> would give me an example of function f(x)
04:32:54 <Freundlich> The definition you gave is an abstract definition of a function and the closest Haskell has to that are function types.
04:33:01 <mauke> f(x) is not a function
04:33:33 <mauke> f is a function. f(x) is the output for a given input x
04:34:00 <NockNocx> mauke: I know y=f(x)
04:34:26 <no-n> f(x) may be a function
05:06:26 <NockNocx> where should I looking for help about show() method/function? 
05:09:39 * hackagebot github-webhook-handler 0.0.6 - GitHub WebHook Handler  https://hackage.haskell.org/package/github-webhook-handler-0.0.6 (wereHamster)
05:10:13 <NockNocx> what does show function do?
05:10:25 <NockNocx> something like repr() or str() in Python?
05:11:19 <Jinxit> let's say I have two functions, 'attack' which attacks, and 'canAttack' which verifies that an attack is valid. I don't want to call 'canAttack' inside 'attack' because it feels like defensive programming, but at the same time I want the program to signal if someone uses the API wrong. what are my options?
05:14:08 <cdepillabout> Jinxit: ideally, the types would make it so that the user can't call 'attack' wrong.
05:14:24 <Jinxit> but it depends on the current state of the game
05:14:32 <Jinxit> not the types involved
05:15:20 <Jinxit> think of it like doing an invalid move in chess
05:15:50 <dutchie> NockNocx: it's probably best to think of it like python's repr()
05:16:00 <cdepillabout> Okay, so then depending on the type of error, it might make sense to return an `Either Error Result` from 'attack'.
05:16:21 <Jinxit> but then I have to check 'canAttack' in 'attack', no?
05:16:33 <Jinxit> which doesn't feel as.. pure
05:18:16 <zett_zelett> http://pastebin.com/L36LZiXN Is it possible to assign a (reasonable) value to z :: Eq Integer, where Eq Integer :: Constraint?
05:18:26 <zett_zelett> (Or not a value, but a binding.)
05:19:39 * hackagebot github-webhook-handler-snap 0.0.6 - GitHub WebHook Handler implementation for Snap  https://hackage.haskell.org/package/github-webhook-handler-snap-0.0.6 (wereHamster)
05:22:27 <cdepillabout> Jinxit:  Depending on what you're trying to do, I don't think calling canAttack inside of attack is necessarily bad.  If you can't use types to make it so that calling attack always works, then you're going to have to do that check somewhere.
05:23:07 <Jinxit> yeah I'm considering having an exported function that runs the check as well
05:23:15 <Jinxit> but internally the attack itself is delegated to another function
05:33:39 <NockNocx> what's wrong with this code? http://lpaste.net/1287997036360105984
05:35:25 <NockNocx> with traceback: http://lpaste.net/1287997036360105984
05:37:06 <zett_zelett> Remove the :: from line 12.
05:37:33 <geekosaur> as for intercalate, I think you need to import Data.List to get it
05:37:38 <geekosaur> @index intercalate
05:37:38 <lambdabot> GHC.OldList, Data.List, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, Data.ByteString, Data.ByteString.Char8, Distribution.Simple.Utils
05:39:40 * hackagebot github-webhook-handler 0.0.7 - GitHub WebHook Handler  https://hackage.haskell.org/package/github-webhook-handler-0.0.7 (wereHamster)
05:43:28 <NockNocx> http://lpaste.net/1287997036360105984
05:43:39 <NockNocx> yeah I'm considering having an exported function that runs the check as well e) arising from a use of `show'
05:43:51 <NockNocx> sorry
05:43:53 <NockNocx> No instance for (Show UTCTime) arising from a use of `show'
05:45:30 <geekosaur> what version of ghc?
05:45:52 <NockNocx> 7.6.3
05:46:23 <NockNocx> Data.Time does not have this issue
05:47:14 <geekosaur> that's what I thought. it's an old version of the time package (which is a boot library for the compiler so generally difficult to upgrade)
05:47:26 <jumpman> I am trying to find the docs that have OO for Haskell but can't find them
05:47:38 <geekosaur> https://launchpad.net/~hvr/+archive/ubuntu/ghc/+packages if you're on Ubuntu or Mint
05:48:00 <NockNocx> geekosaur: what version should I use to solve that problem?
05:48:11 <NockNocx> geekosaur: I'm using Debian Jessie
05:48:35 <Fuco> hmm, lazy IO and exceptions seems to be rather painful... is there some variant of catch which will force the first action?
05:48:48 <geekosaur> I don;t know offhand, sorry. The Show instance is listed in a number of older versions but may have been in the wrong module
05:48:51 <Fuco> all I found online is similarly confused people asking and replying with non-solutions :D
05:49:20 <NockNocx> geekosaur: np
05:49:31 <jumpman> Does Haskell have OO like in C++
05:49:47 <geekosaur> Fuco, I think that;s what Control.Exception.evaluate is for... although you may also need Control.DeepSeq (one hopes not)
05:49:55 <geekosaur> jumpman, not generally
05:51:13 <geekosaur> NockNocx, I'm not sure what "Data.Time does not have this issue" means. if importing that fixes the problem, I'd just go with that
05:51:50 <geekosaur> it's part of the same package
05:51:51 <Fuco> evaluate has type a -> IO a, catch is IO a -> (e -> IO a) -> IO a... so I need to make first IO a strict.  I tried applying (join . evaluate) on it (which is IO a -> IO a) but that doesn't seem to work either
05:51:55 <jumpman> So does haskell only support functional
05:52:01 <zett_zelett> jumpman: What do you expect of OO?
05:52:14 <zett_zelett> Support for single dispatch?
05:52:35 <geekosaur> jumpman, there are ways to do OO. but Haskell is a functional programming language, not an OO language
05:53:02 <Fuco> here's the code, http://sprunge.us/JGgg Mpris is RWST over IO
05:53:09 <geekosaur> there are languages that do both "natively" (notably OCaml) but experience has shown that the OO features mostly go unused in that case; FP is generally more flexible and expressive
05:53:12 <Fuco> the finally part is there just for debug purposes
05:53:35 <lyxia> :t join . evaluate
05:53:36 <jumpman> is haskell anything like C++
05:53:36 <lambdabot> IO a -> IO a
05:53:55 <lyxia> Fuco: >>= evaluate
05:53:58 <geekosaur> Fuco, you don't generally make the IO part strict, you need to make strict the non-IO thing you get from it (the actual data)
05:54:01 <zett_zelett> jumpman: No.
05:54:05 <geekosaur> which will force the IO to happen
05:54:16 <Fuco> aha, that's logical
05:54:34 <Fuco> so I >>= return . Right . evaluate
05:54:37 <Fuco> let's see
05:54:42 <zett_zelett> jumpman: Do you just want to know what Haskell is about or are you considering learning/using it?
05:55:27 <jumpman> I was wanting to use haskell for prototyping
06:09:49 <Fuco> so I put the catch over the top level IO and it still doesn't catch
06:10:33 <Fuco> I starting to be unsure where it comes from, in the sources of the dbus package there's no trace of "Invalid bus name" error message
06:11:23 <geekosaur> oh. dbus has a bunch of gotchas
06:11:34 <geekosaur> see if it works with +RTS -V0
06:12:05 * geekosaur has so far reported two dbus bugs because it doesn't handle timer interrupts properly
06:12:06 <Fuco> geekosaur: what is that? command line arguments?
06:12:10 <geekosaur> yes
06:14:40 * hackagebot lambdatex 0.1.0.2 - Type-Safe LaTeX EDSL  https://hackage.haskell.org/package/lambdatex-0.1.0.2 (Norfair)
06:15:28 <geekosaur> ghc's runtime uses timer interrupts to check for garbage collection, profiling ticks, etc. and if one goes off in a dbus call then dbus breaks
06:15:47 <geekosaur> in particular that "invalid bus name" is likely to mean its bus name lookup got interrupted
06:21:15 <Fuco> geekosaur: oh, I should've mentioned I'm giving it bogus name on purpose... I'm trying to handle the case when the dbus client dies and I still try to send methods to it
06:21:49 <Fuco> I'm writing mpris control (for media players) and it might happent that you close the media player but the library still tries to query it, in which case it should not crash preferably
06:22:21 <Fuco> the docs on DBus.Client call say "throws ClientError on ..." so I'm trying to catch that
06:23:13 <Fuco> when I build it with "ghc --make test.hs +RTS -V0" same thing happens, the exception "leaks"
06:23:34 <geekosaur> hm. that's difficult because you're throwing away the result of the D.call
06:23:44 <geekosaur> so there's nothing actually forced
06:24:35 <Fuco> the code now looks like this: http://sprunge.us/jVQI
06:24:41 * hackagebot rdf4h 1.3.6 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-1.3.6 (RobStewart)
06:24:53 <geekosaur> oh, hm. it does look at Right
06:25:02 <geekosaur> that (should* force it. but 
06:25:04 <geekosaur> oh
06:25:15 <geekosaur> what are you actually getting when you run this
06:25:31 <geekosaur> it occurs to me that you may be getting an "exception" at the level of C, which would just abort
06:25:42 <geekosaur> Haskell cannot intercept that
06:26:03 <Fuco> this is what it prints: http://sprunge.us/AfJc
06:26:47 <geekosaur> that's not a Haskell exception
06:26:53 <Fuco> oh damn :D
06:27:00 <geekosaur> think I'd need to see more code to say any more
06:27:44 <Fuco> I think I'm being stupid here... dbus doesn't allow a bus name without the top domain
06:28:02 <Fuco> yes.... GOD
06:28:29 <Fuco> it must be :number or foo.bar at least... this is the stupidest issue ever :D Sorry for wasting your time 
06:29:25 <Fuco> but your analysis was very helpful, the idea that this is deeper than haskell (=C) gave me the idea that it uses some C library under the hood which simply aborts on invalid name... not in a sense "not existing" but "against the spec"
06:30:19 <geekosaur> yes. the dbus package does not reimplement dbus natively, it calls the native dbus library
06:31:02 <geekosaur> and that error is coming form somewhere inside the native dbus library and probably just doing exit(1)
06:31:08 <Fuco> indeed
06:31:23 <Fuco> thanks again :)
06:31:54 <geekosaur> still not sure why it's not catching it there, unless there is another call somewhere (possibly implicit via an atexit hook at C level) that is actually dying
06:32:22 <geekosaur> well, not catching, it'd just exit before it could say "Finally"
06:35:08 <lamefun> Is there a way to graft a layer of normally uncatchable exception on top of IO?
06:36:39 <geekosaur> the only way you're going to intercept an exit(1) is ptrace or equivalent. which means adding theguts of a debugger to your program
06:38:27 <maerwald> hm, the gtk bindings need a TH package
06:38:53 <maerwald> getting 20+ items from a glade builder looks really stupid
06:41:56 <lamefun> I basically want separate exceptions that can't be caught with catch _ (\(e :: SomeException) -> ...)
06:45:25 <maerwald> data MyException = Bar String deriving (Show, Typable)
06:45:26 <maerwald> instance Exception MyException
06:45:27 <maerwald> that?
06:49:47 * hackagebot vrpn 0.2.1.3 - Bindings to VRPN.  https://hackage.haskell.org/package/vrpn-0.2.1.3 (BrianBush)
07:03:52 <the_2nd> What if I define a newtype as Radians from Double and try to do math on it? e.g. c = rad1 * 3.0 . which type will I get? Will I only be able to use the Radians now or can I mix it for calculations?
07:06:07 <maerwald> that will not typcheck I think
07:07:43 <maerwald> it cannot infer the literal "3.0" to your Radians type
07:08:16 <maerwald> and * is defined as "Num a => a -> a -> a" not "(Num a, Num b) => a -> b -> a" or somesuch
07:08:51 <slomo> if there's a Fractional instance for Radians then it will work (but c would still be Radians)
07:10:03 <the_2nd> hm too bad, that this is breaking my math
07:10:12 <the_2nd> I'll stick with type then
07:12:28 <the_2nd> question concerning folders and files: Where do you define your Datas? A file for each? each its own files? One class file which holds all instances? Or one classes file / class per file and then the instances in own files? I'm not quite sure what's the best / usual way there
07:13:06 <maerwald> the_2nd: you mean an internal representation of the filesystem?
07:14:42 <the_2nd> no, how to manage my project itself
07:14:56 <maerwald> ah
07:15:06 <the_2nd> I also have of course functions which will require multiple types. Where should I put these? 
07:15:07 <Tekmo__> the_2nd: Haskell namespacing works at the file level and (until the upcoming ghc-8.0) record fields clash with fields of the same name in the current namespace
07:15:29 <Tekmo__> the_2nd: So if it's a large project and I have time I will put each data type in its own module so that their field names are guaranteed not to clash
07:15:47 <Tekmo__> the_2nd: If I'm in a hurry I will just prepend each field name with the data type name
07:16:38 <Tekmo__> the_2nd: In ghc-8.0 this will get much better with the `OverloadedRecordFields` extension: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Redesign
07:17:15 <Tekmo__> the_2nd: The second restriction is that instances belong in the same module as the type class or the type that implements the type class
07:17:26 <Tekmo__> This is not a hard restriction, but it's very strongly encouraged
07:18:02 <Tekmo__> The reason is to prevent having two conflicting instances for the same type, which cannot be resolved
07:18:30 <Tekmo__> Having an instance outside of one of those two modules is known as an "orphan instance" and the compiler will warn about it
07:20:11 <the_2nd> Tekmo__, thanks
07:22:22 <raoz> Hi!
07:24:56 <the_2nd> other question: I have many datas which may have a member position. Currently I just renamed them to tilePos creepPos gunPos etc. should I use pos instead and only import these modules namespaced? Or is prefixing fine?
07:41:24 <c_wraith> hmm. starting to get a feel for hyperfunctions. they're a kind of type-changing fixed point. 
07:54:22 <Zenol> I have a completely non-haskell related question, but I dunno where to ask it :s I'm looking for a tool implementing pca compression on images. Any idea where I can ask it?
07:58:33 <maerwald> mh, is there a way to get variables from within the projects cabal file (e.g. version)? I mean without parsing it myself...
07:59:46 <indiagreen> maerwald: use the Cabal library
08:00:16 <indiagreen> maerwald: here's an example of a script getting the tested-with field out of a .cabal file: https://github.com/hvr/multi-ghc-travis/blob/master/make_travis_yml.hs#L39
08:00:35 <maerwald> ah, thanks
08:17:27 <badmash> hey, all
08:17:37 <badmash> quick question on haskell
08:18:06 <badmash> when you have rank 2 or higher, use of forall is mandatory?
08:18:17 <c_wraith> yes
08:18:41 <c_wraith> it's the only way to explicitly put a scope on a type variable. 
08:19:08 <badmash> for example, if you have a function like f :: ( Num a => a ) -> ( Num a => a)
08:20:22 <badmash> the right way to write this type signature is -- f :: ( forall a. Num a => a) -> ( forall a. Num a => a ) ?
08:21:39 <c_wraith> I'd write the signature more like f :: (Num a) => (forall x. Num x => x) -> a
08:21:55 <c_wraith> it's equivalent, but more idiomatic 
08:22:10 <badmash> i see
08:22:40 <c_wraith> but your type should work. 
08:23:22 <badmash> c_wraith: but this type signature is incorrect, right -- f :: ( Num a => a ) -> ( Num a => a ) ?
08:24:32 <c_wraith> badmash, yes. if the compiler even accepts it, it still won't mean the same thing. 
08:25:42 <c_wraith> It'd be rank 1 and the type variable a would be the same in all places 
08:29:48 <badmash> c_wraith: if the compiler accepts it, what would this incorrect type signature actually mean?
08:30:26 <badmash> incorrect type signature -- f :: ( Num a => a ) -> ( Num a => a )
08:31:20 <c_wraith> if it was accepted for some reason, it'd be the same as f :: (Num a, Num a) => a -> a
08:33:37 <badmash> c_wraith: i see
08:34:06 <badmash> c_wraith: so that would be rank 1, instead of rank 2?
08:34:14 <c_wraith> yes
08:35:13 <badmash> c_wraith: one more confusion i have is with rank numbers
08:35:47 <badmash> c_wraith: is this rank 1 or rank 2?  Num a => a -> Int
08:35:55 <c_wraith> 1
08:36:46 <badmash> c_wraith: well, it is the same as ( Num a => a ) -> Int, isn't it?
08:36:59 <c_wraith> no. 
08:37:27 <c_wraith> (assuming you meant with a forall in there) 
08:37:34 <badmash> c_wraith: yes
08:38:20 <badmash> c_wraith: so we have something like this -- forall a. Num a => a -> Int
08:38:36 <badmash> and you are saying this is rank 1
08:39:52 <badmash> i am seeing the brackets as implicit -- that is, it is equivalent to ( forall a. Num a => a ) -> Int
08:40:08 <badmash> and this is rank 2
08:40:19 <badmash> so what am i missing here?
08:41:14 <c_wraith> the parens are not implicitly there. 
08:41:32 <c_wraith> they're implicitly around *everything*
08:42:09 <badmash> c_wraith:  i see , so the implict stuff extends all the way to the right, you mean?
08:42:18 <c_wraith> forall a. (Num a => a -> Int) 
08:42:22 <c_wraith> yes
08:43:09 <badmash> c_wraith: got you ... yeah, i forgot about that extending all the way to the right, just like the lambda stuff
08:43:48 <badmash> c_wraith: haskell ... a bit tricky but really interesting stuff :)
08:43:58 <c_wraith> the difference, semantically, is that the rank 1 version accepts any concrete type that's an instance of Num for its argument. 
08:44:16 <c_wraith> the rank 2 type requires the argument to be polymorphic 
08:44:19 <badmash> c_wraith: yes
08:44:32 <c_wraith> ok
08:45:11 <badmash> c_wraith: you know, some of the stuff on the internet says that rank is determined by the number of forall -- does it make sense?
08:45:15 <roelof> Hello, I have this code with Hunit tests: http://lpaste.net/147788
08:45:28 <roelof>  Now I want to make some quicktests .  Can I use the same properties as in the hunit tests  ?? 
08:45:48 <c_wraith> badmash, that's roughly true, though it's more like the number of *nested* forall
08:46:45 <badmash> c_wraith: so this has 2 nested forall?  ( forall a. Num a => a ) -> Int
08:47:12 <c_wraith> badmash, well, that's why I said "roughly" :) 
08:47:26 <badmash> c_wraith: i see :)
08:48:32 <badmash> c_wraith: yeah, people write things on the internet that end up confusing me
08:49:24 <badmash> c_wraith: thanks for your time ... you cleared up a lot of tangles for me
08:49:27 <c_wraith> forall b. (b ~ Int) => (forall a. Num a => a) -> b
08:49:40 <c_wraith> there, now it had two nested. :) 
08:49:45 <c_wraith> *has
08:50:47 <badmash> c_wraith: you basically re-wrote that, just to make clear the 2 forall
08:51:03 <c_wraith> yes, using a type equality constraint 
08:51:25 <badmash> c_wraith: yeah, i see that
08:52:17 <c_wraith> anyway, your welcome. higher rank types are one of the coolest things in GHC haskell, in terms of the power they provide to say things you can't say in basic haskell. 
08:52:37 <badmash> c_wraith: quick question -- you know there are lot of haskell books etc out there, but hardly any one of them goes into the details of types, type expressions etc.  i am wondering why
08:52:39 <c_wraith> *you're. damn autocorrect 
08:53:51 <badmash> c_wraith: i am basically digging up stuff from the haskell 2010 report ... i learn a lot of stuff about types from there
08:54:03 <c_wraith> I'm not sure. maybe it's a matter of what the author thinks us obvious or is irrelevant. 
08:54:26 <c_wraith> .. I'm just going to stop worrying about typos now. 
08:54:48 <badmash> c_wraith: alright
08:55:35 <badmash> c_wraith: i asked because i had a hard time figuring out the compilation errors from this rank stuff
08:55:54 <badmash> c_wraith: thanks for your time, anyway
08:56:19 <wedens> have somebody used opaleye in a project with relatively complicated db queries?
09:00:37 <roelof> no one who can and willing to help me to figure out good properties for my test ? See a earlier question 
09:13:14 <phy1729> @pl  foo p = unfoldr (\ x -> if x/=0 then Just (mod x p, div x p) else Nothing)
09:13:15 <lambdabot> foo = unfoldr . flip flip Nothing . liftM2 if' (0 /=) . (Just .) . ap (ap . ((,) .) . flip mod) (flip div)
09:14:49 <roelof> other problem. I have this test :  crossPoint 1 @?= "The x-axis is crossed at point (1 ,0)"  . Why do I see this error message : http://lpaste.net/147792
09:15:04 <roelof> crosspoint has only 1 parameter 
09:18:11 <badmash> hey, 1 quick question
09:20:02 <badmash> can values ( i mean not functions) in haskell have ranks higher than 1? 
09:20:04 <bergey> roelof: I think you want to pass testCase "" (crossPoint 1 @?= "...") but you're passing just the function crosspoint as the second input to testCase
09:20:36 <badmash> for example, this is polymorphic but rank 1 -- x :: Num a => a
09:22:22 <roelof> bergey:  oke, but here I do the same: http://lpaste.net/147793 and no error message 
09:23:53 <mmachenry> I'm trying to make a trivial type class but I'm stuck writing the syntax for the tuple instance. http://lpaste.net/147794
09:24:01 <johnw> badmash: why do you ask?
09:24:14 <bergey> roelof: That is puzzling.  If you post the whole file I can try to help more.
09:24:24 <johnw> mmachenry: you can only do that with a newtype wrapper
09:24:26 <mmachenry> I want to have the first item of the tuple be the type hole for the * -> * kind that Firstable accepts.
09:24:36 <badmash> johnw: i was just curious
09:24:43 <jgt> hey folks, anyone using Keter?
09:24:58 <mmachenry> johnw: Really? Odd that I can do it with snd but not fst. Why is that?
09:25:10 <jgt> I noticed when I do `sudo start keter`, I get this in syslog: "init: keter respawning too fast, stopped"
09:25:26 <roelof> bergey:  here you have : http://lpaste.net/147795
09:25:32 <johnw> badmash: I'm pretty sure the answer is "no", universal quantification applies to functions; in values it becomes existential quantification -- which, granted, you need a universally quantified function to make use of
09:25:54 <roelof> I use Tasty to make my output pretty 
09:26:04 <raoz> Hi! Is there a more elegant way to achieve this: http://lpaste.net/6863808165113233408 ?
09:26:05 <johnw> mmachenry: it's just the way that Haskell syntax works at this level; you can only make an instance for the last type variable
09:26:06 <badmash> johnw: i see
09:26:29 <johnw> mmachenry: btw, this is something the 'lens' package solves quite nicely: the ability to manipulate any type variable, like you're doing now, with _1 or _2
09:27:13 <badmash> johnw: i think what you say makes sense ... it would be really weird to see a value defined with higher ranks
09:27:27 <badmash> johnw: thanks
09:27:40 <johnw> badmash: see https://wiki.haskell.org/Rank-N_types
09:28:04 <badmash> johnw: thanks.  yeah
09:29:23 <roelof> bergey:  the first one is also wrong. if I deleted the last test , I see the same error message on the first 
09:29:24 <mmachenry> johnw: Yes, it would be better. However, I'm really just trying to do a simple type class instance and realized I'm stuck on what I think should be easy. 
09:29:55 <roelof> I think the problem is that the function returns a string where the rest is outputting a tuple or number 
09:30:03 <mmachenry> johnw: It seems to come down to not being able to use flip on a type constructor in an instance declaration in a way. Since this program works if I am fine getting the second element.
09:30:30 <johnw> right, there is no type-level flip; this is has been a problem for me in the past
09:30:34 <johnw> which I then solved using 'lens' :)
09:31:51 <johnw> mmachenry: also, your Firstable should be a Prism in that library, since it targets 0 or 1 element
09:33:43 <mmachenry> Prism? 
09:33:53 <mmachenry> Oh you mean from the lens library ?
09:33:56 <johnw> a prism is a lens optic that targets 0 or 1 element
09:33:57 <johnw> yes
09:34:20 <johnw> > [1,2,3] ^? _head
09:34:21 <lambdabot>  Just 1
09:34:22 <mmachenry> Yeah I'm really not trying to use a lens here. This is not code I'm going to use. Just trying to learn why I ran into this stumbling block on the syntax. 
09:34:25 <johnw> here, _head is a prism
09:34:31 <johnw> ah, I see
09:34:46 <johnw> so, some languages *can* do this
09:34:50 <johnw> all you need is a type-level lambda
09:35:12 <johnw> for example, in Coq I'd say (roughly): instance Firstable {a} (fun x => (x, a)) where ...
09:35:31 <johnw> but since Haskell doesn't have this, it limits our flexibility in some ways
09:39:00 <roelof> some who knows why I cannot check for a string output here : crossPoint 0 @?= "There are infinitive solutions because the line is the x-axis"  
09:39:39 <johnw> what's the type of crossPoint?
09:42:45 <yamadapc> hey there
09:42:53 <yamadapc> any hackage-server people around?
09:43:06 <johnw> question about the service, the server it runs on, or the code?
09:43:27 <yamadapc> is there a way to fetch downloads to a package through the API; I'm trying `GET /packages/downloads` but it asks for auth, then if I give it auth it doesn't give me access
09:43:39 <yamadapc> there's a page in the wiki about stats
09:43:50 <yamadapc> but I was wondering if https://hackage.haskell.org/api#download was already somehow usable
09:44:03 <yamadapc> johnw: server/code idk... that ^^
09:44:46 <bergey> roelof: All the examples that work have a $ after the description of the test.  If you add those to the last two tests, they'll also work.
09:45:16 <roelof> johnw the type of crossPoint is at this moment :   crosspoint :: Integer -> String 
09:45:23 <yamadapc> because it'd be neat to have that in a badge or graph like NPM does.. the hackage package page does show "dowloads this month" so I guess that data is stored somewhere (?)
09:45:35 <bergey> The $ is an operator that tells Haskell to evaluate the right hand side and pass the result to the left hand side - the same as adding parens around the right hand side.
09:45:50 <Phyx-> what does "import {-# SOURCE 3-} do?
09:46:01 <yamadapc> ah; there's a hackage channel... sorry
09:46:20 <hpc> bergey: not quite
09:46:38 <hpc> ($) applies the left side to the right side, but doesn't specify any evaluation other than that
09:47:46 <roelof> bergey:  thanks, I was looking for this the whole afternoon 
09:47:54 <roelof> you saved my X-mas evening 
09:48:01 <lispy> :t ($)
09:48:02 <lambdabot> (a -> b) -> a -> b
09:48:08 <Phyx-> oh right, mutually recursive modules
09:49:33 <Phyx-> gah
09:50:19 <bergey> hpc: Sure.  Most of my students need to get comfortable with order of operations; laziness is a complication I avoid.  I meant evaluation order in that sense.  Possibly I shouldn't assume the same background here on #haskell, or should find words that distinguish these two senses.
09:52:28 <kadoban> Huh I guess stack is going to jump to version 1.x in the next release apparently? That's going to take some getting used to.
09:53:07 <johnw> bergey: yeah, I got confused when you said evaluated too :)
09:55:10 <MarcelineVQ> bergey: as I understand it it's about parsing precidence rather than the involvement of lazyness, www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2
09:55:46 <lispy> MarcelineVQ: correct. ($) is just id with a different precedence
09:56:06 <johnw> yeah, bergey knows all this perfectly well
09:56:12 <MarcelineVQ> oh ok
09:58:56 <bergey> johnw: OK.  I'll find some word that isn't "evaluated" =)
10:01:06 <johnw> bergey: "it passes what is right of $ as the final argument to the function on its left"?
10:02:54 <bergey> Yes, that works for me.  Thanks.
10:04:52 * hackagebot gremlin-haskell 0.1.0.1 - Graph database client for TinkerPop3 Gremlin Server  https://hackage.haskell.org/package/gremlin-haskell-0.1.0.1 (nakaji_dayo)
10:13:56 <tryam> Hello!
10:15:06 <tryam> I created a simple enum-like algebraic type, then I realized that I need the number of elements in that type, so I wrote a function myEnumLength = fromEnum (maxBound :: XYZ) + 1
10:15:26 <tryam> is there a better way, there must be a standard function somewhere for that
10:17:11 <tryam> and I had to add deriving for Enum and Bounded, of course
10:18:12 <indiagreen> tryam: I haven't seen such a function
10:19:23 <indiagreen> Hoogle can't find it either
10:19:23 <lispy> dmwit: do you know the answer to tryam question? You were looking at Enum a bunch lately
10:32:00 <roelof> Can someone help me find good properties for this function : http://lpaste.net/147797 . Or can I test on 0  and numbers just like the Hunit test I posted before 
10:34:02 <MarcelineVQ> Is this what tryam was after?
10:34:05 <MarcelineVQ> @define data AlgebraEnum = One | Two | Three | Four | Five deriving Data
10:34:07 <lambdabot>  Defined.
10:34:17 <MarcelineVQ> > length . dataTypeConstrs . dataTypeOf $ (undefined :: AlgebraEnum)
10:34:19 <lambdabot>  5
10:34:20 <lispy> roelof: you could make it slightly simpler in the second case with otherwise = "The x-axis is crossed at point " ++ show (b,0)
10:35:23 <lispy> roelof: as for properties to test, I'm not sure what to say
10:35:46 <roelof> lispy:  thanks for the feedback 
10:37:16 <lispy> roelof: I might change the type. crosspoint :: Integer -> Either String (Integer,Integer), and then move the rendering to string eleswhere
10:37:24 <lispy> roelof: that will make testing easier
10:37:54 <zaquest> roelof, how do you represent straight line? i mean how do i get straight line from `b`?
10:38:34 <roelof> zaquest:  I represent a line with y = b and b is a number a user enters 
10:39:05 <roelof> lispy:  thanks, I will look how to do that. I did not use Either because it's not discussed yet in the book im reading 
10:39:13 <zaquest> roelof, but y = b never crosses x-axis for any b
10:39:21 <zaquest> well except y = 0
10:40:10 <roelof> zaquest:  oke, then I mean x = b  , math confuses me the whole time. Lang ago that I learned this stuff at school 
10:41:11 <zaquest> roelof, in that case x = 0 crosses x-axis at exactly one point (0,0) :D
10:44:28 <roelof> zaquest: oke , back to the math pages I think to find a good way to represent a line 
10:45:17 <jay6981> line is mx + b
10:45:19 <zaquest> roelof, y = a*x + b => (a, b) :: (Double, Double)
10:45:29 <zaquest> i'd go with something like this ^
10:46:10 <roelof> zaquest:  oke, but then you can also make a line which is not a straight line 
10:46:23 <zaquest> roelof, how?
10:46:37 <jay6981> f(x) = |x|
10:46:41 <roelof> In my oponion a straight line is a line with or the same x or the same y coordinates 
10:47:14 <roelof> or do I misunderstood what English/American means with a straight line 
10:48:20 <jay6981> that would be a veritical or horizontal line
10:49:47 <zaquest> roelof, if you use that definition of straight line then y = b will or x = b will do, but your implementation is wrong in both cases.
10:50:07 <semigrou-pyon> Is there anything like Hoogle, that lets you find types given their kind?
10:52:38 <aweinstock> ax + by + c = 0 gives you the flexibility to represent pure-vertical lines
10:53:02 <aweinstock> err, with the constraint that a*b /= 0
10:57:00 <semigrou-pyon> Is there a type constructor somewhere, for the arrows of an opposite category?
10:57:02 <roelof> oke, so I have to use y = ax + b  . Then I will change my code accordently, and I have to find out how I can calculate where the line crosses the x-as
10:57:23 <roelof> I think in that case x = 0 , as I remember from school 
10:57:31 <semigrou-pyon> `newtype Opposite k a b = Opposite { runOpposite :: k b a}`, with `instance Category k => Category (Opposite k)` ...
11:02:49 <aweinstock> roelof: for (y=mx+b), finding where it crosses the x-axis is finding a y value that makes x 0
11:03:13 <roelof> aweinstock:  thanks 
11:03:38 <aweinstock> (y = mx+b) == (y - b = mx) == ((y-b)/m = x)
11:04:31 <aweinstock> wait, nvm, that doesn't help calculate the inverse
11:05:41 <roelof> aweinstock:  thanks, Can I represent a line this way  crossline (y=mx+b)  where I can later uses m , y, and b 
11:05:52 <roelof> inverse ?? 
11:06:47 <aweinstock> roelof: either just use a tuple (m,b), or use something like: data Line a = { slope :: a, intercept :: a }
11:07:37 <aweinstock> and then have something like: evalLine (m,b) x = m * x + b
11:08:41 <aweinstock> by inverse, I mean: if (f x = m*x+b), you want to find g (f's inverse) such that (g (f x) = x)
11:09:25 <aweinstock> and then the place where it crosses the x-axis is ((g 0), 0)
11:11:46 <aweinstock> @check let (m,b) = (3,1) in let {f x = m*x+b; g y = (y-b)/m} in (\z -> (g . f) z == z)
11:11:48 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 1078 shrinks):
11:11:48 <lambdabot>  27.60061687880677
11:12:04 <aweinstock> @check let (m,b) = (3,1) in let {f x = m*x+b; g y = (y-b)/m} in (\z -> (g . f) z - z < 0.001)
11:12:06 <lambdabot>  +++ OK, passed 100 tests.
11:12:08 <zaquest> roelof, or you can just use `x = -b/m`, since at the point where line `y = mx+b` crosses x-asix y = 0 and that gives (y-b)/m = -b/m :D
11:12:34 <aweinstock> roelof: oops, I was right the first time, (y-b)/m is the inverse
11:13:34 <aweinstock> @check let {f (m,b) x = m*x+b; g (m,b)  y = (y-b)/m} in (\m b z -> (g (m,b) . f (m,b)) z - z < 0.001)
11:13:36 <lambdabot>  *** Failed! Falsifiable (after 1 test):
11:13:36 <lambdabot>  0.0 0.0 0.0
11:13:58 <aweinstock> @check let {f (m,b) x = m*x+b; g (m,b)  y = (y-b)/m} in (\m b z -> m /= 0 ==> (g (m,b) . f (m,b)) z - z < 0.001)
11:13:58 <lambdabot>  : -1: -1:Ambiguous infix expression
11:14:14 <aweinstock> @check let {f (m,b) x = m*x+b; g (m,b)  y = (y-b)/m} in (\m b z -> (m /= 0) ==> ((g (m,b) . f (m,b)) z - z < 0.001))
11:14:16 <lambdabot>  +++ OK, passed 100 tests.
11:17:52 <roelof> zaquest:  so  x = -b /m is the right formula . can I represent the line this way  : crossX  y=mx+b 
11:21:09 <lispy> roelof: I'm not sure what you mean by represent. that wouldn't syntactically valid, but you could do something like data Line = Line Float Float, where the first float is the slop ('m') and the second Float is the intercept ('b')
11:21:56 <roelof> oke, I have learned to use data and type 
11:22:02 <lispy> roelof: I don't know if you've seen records yet, but they would be even better because you could name them, and I would generalize the numeric type, data Line a = Line { slope :: a, intercept :: a}
11:22:43 <roelof> lispy:  I do not have seen records but I have seen some simple data and type  
11:23:27 <roelof> so CrossX  Line = -b/m  would be right 
11:23:49 <lispy> CrossX (Line m b) = ...
11:23:56 <lispy> Have you read about pattern matching?
11:24:58 <lispy> also, sorry should be crossX not CrossX. Haskell thinks any identifier starting with a capital letter is special
11:25:09 <lispy> normal functions have to start with lower case
11:25:23 <roelof> lispy:  a little bit  but thanks , I have now a idea how to make my function work 
11:28:24 <roelof> lispy:   intercept is the same as b in this formula y = ax + b ?
11:29:23 <lispy> yeah
11:29:36 <lispy> if you set x = 0, b is the point at which you'll cross the y-axis
11:29:47 <lispy> y = a*0 + b = b
11:30:13 <roelof> oke, I try to find out which clauses I have to make to make this work 
11:30:21 <lispy> So I usually call it the y-intercept
11:31:26 <lispy> But those names are only important if you use the record names like I did. Otherwise you name them whenever you pattern match on a Line. So you can do like case l of Line m b -> ...
11:31:32 <lispy> name them m and b righ tthere
11:32:05 <lispy> (x and y end up implicit in this representation)
11:36:38 <roelof> oke, I try to find out what  m b are when  I have a line y = 2 ,  I think I take a break and will continue with it tomorrow 
11:36:49 <roelof> my head is spinning right now 
11:37:18 <lispy> roelof: Well, If you want help with the algebra let me know. I find the line slope stuff to be fun :)
11:38:31 <icbm> Hi Haskellers. I'm using an API where results are in the ST monad.  What is more idiomatic: isolate the impure chunks with runST wherever I use that API, or make my whole agorithm run in a single runST ?
11:38:50 <lispy> the former
11:39:02 <icbm> lispy: Cool. I thought so!
11:39:11 <lispy> The guiding principle is to separate concern
11:39:40 <lispy> If some bit of code doesn't need the extra ST bits, then you usually gain something by leaving them out
11:40:03 <icbm> lispy: Does runST have a lot of overhead to spin up the "thread" s?
11:40:28 <icbm> Or is that really just an abstraction and not a thread like I'm used to from other platforms?
11:40:56 <lispy> It's just an abstraction
11:41:13 <lispy> runFoo is a convention that often simply unwraps a function
11:41:46 <icbm> lispy: data X = X { runX :: ... }  -- I've seen this before
11:41:51 <lispy> yeah
11:41:56 <kadabra> Hey, which tutorials would you recommend for beginner programmers to learn Haskell? I'm currently using http://learnyouahaskell.com/ but would like more
11:42:00 <icbm> lispy: Cool, thanks a bunch.
11:42:24 <lispy> icbm: you're welcome
11:42:24 * icbm scurries off to isolate the heck out of that ST-based API
11:42:30 <vikraman> > Left "foo" < Right 42
11:42:32 <lambdabot>  True
11:42:40 <geekosaur> icbm: a "state thread" is not a thread in the usual sense. It's a method for sequestering a computation
11:43:27 <lispy> kadabra: My recommendations always try to incorporate the reader. So what is your background?
11:43:39 <icbm> geekosaur: ...as in to make sure the data isn't shared with other such threads?
11:44:14 <geekosaur> or with the rest of the program; only the result of the computation is visible, and it cannot leak details of the internal state
11:44:25 <kadabra> lispy: I've got about two years programming experience, mainly in python but not in any functional languages
11:44:28 <icbm> geekosaur: Cool
11:44:58 <lispy> kadabra: ah okay. You might want to read a book on functional programming in parallel with learning Haskell. Something like SCIP might be good.
11:44:59 <aweinstock> icbm: the s in (ST s a) isn't an actual value, it's a "phantom" value that verifies that a stateful computation is deterministic
11:45:00 <geekosaur> this is how we "hide" computations that use mutable state internally
11:45:23 <lispy> kadabra: sorry, I typed that wrong, I menat this book: https://mitpress.mit.edu/sicp/full-text/book/book.html
11:45:30 <lispy> sicp*
11:45:52 <geekosaur> the mutable state depends on the "impossible" "s" value in (ST s a) --- impossible in that it can only be given a type inside the computation, thus ensuring that nothing depending on "s" can be visible outside of it
11:45:58 <aweinstock> icbm: here's the "lazy functional state threads" paper: http://homepages.dcc.ufmg.br/~camarao/fp/articles/lazy-state.pdf
11:46:18 <kadabra> lispy: thanks, will have a look at it!
11:46:44 <kadabra> looks quite rigourous
11:46:50 <icbm> aweinstock geekosaur: Thanks very much. I'll read the paper.
11:47:36 <roelof> lispy:  I have trouble finding out what m and b are when lets say y = 2 . I think m = 0 and b = 2 , and let's say x = 2 then I think m = 2 and b = 0 ? 
11:48:03 <lispy> kadabra: Yeah, it's for some MIT classes though so I think you can find exercises and lectures if you google it.
11:48:05 <geekosaur> (it's a thread of state as distinct from a thread of execution, hence the name)
11:48:35 <lispy> kadabra: So even though it might be intimidating you should be able to find lots of stuff to smooth it out and make it less daunting
11:48:53 <aweinstock> roelof: the equation (y=2) is equivalent to (y = 0*x + 2), which is the same as (y = m*x + b) with m=0 and b=2
11:49:19 <kadabra> lispy: I'm also looking to improve my theoretical knowledge, so it should help nicely
11:49:31 <lispy> roelof: I find it helps to draw a little xy axis on paper and then starting plugging points into the equation and writing down the pairs then plotting them.
11:49:57 * hackagebot binary-orphans 0.1.3.0 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.3.0 (phadej)
11:50:20 <jay6981> https://www.khanacademy.org/math/algebra-basics/core-algebra-graphing-lines-slope/core-algebra-graphing-intercepts/e/solving_for_the_x-intercept
11:50:22 <aweinstock> roelof: the equation (y=m*x+b) can be "evaluated" at x to get the point (x, m*x+b) which is said to be "on the line"
11:51:05 <aweinstock> roelof: likewise, inverting it to get ((y-b)/m = x), you can "evaluate" it at y to get ((y-b)/m, y), which is also "on the line"
11:51:21 * lispy has to run
11:52:47 <johnw> run, lispy, run!
11:54:57 * hackagebot sbvPlugin 0.4 - Formally prove properties of Haskell programs using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.4 (LeventErkok)
11:59:09 <dmj`> there should be bounties for people able to build certain packages on osx
12:00:42 <maerwald> yeah, seems mac users pay for literally anything
12:03:48 <dmj`> webkitgtk3 building on osx, is al I want for xmas
12:03:52 <dmj`> s/al/all
12:04:15 <maerwald> al OSes are broken, use one you can fix
12:04:49 <dmj`> maerwald: hmm, well said
12:05:24 <maerwald> I'd go so far to say linux is more broken than osx... but IF something is broken in osx, you are pretty much left alone
12:05:30 <maerwald> and I had to experience that too
12:09:23 <dmj`> I'd give someone some bitcoin if they could do it
12:15:30 <roelof> lispy:  I got it working. One last question. What is the definition of data Line :  data Line a = Line { slope :: a, intercept :: a}
12:16:22 <monochrom> that is a strange question. it's almost like "how do you spell 'mist'?"
12:19:06 <roelof> monochrom:  do you mean my question ? 
12:19:11 <monochrom> yes
12:19:23 <johnw> you showed us the definition :)
12:19:26 <tnecniv> xD
12:20:11 <roelof> sorry , I mean something like this : crossX ::  Line Float -> String   I thought its named definition 
12:20:32 <Cale> ... huh?
12:20:43 <Cale> data declarations introduce new data types
12:21:14 <pyon> Is there a definition of "opposite category" in any of the widely used libraries?
12:21:16 <tnecniv> roelof Line takes a type argument a
12:21:21 <monochrom> "crossX ::  Line Float -> String" is a type signature, not a definition
12:21:38 <tnecniv> so saying "Line Float" means that slope and intercept are defined in terms of floats
12:21:54 <ReinH> I believe the report calls them "type declarations"? Same difference.
12:21:56 <tnecniv> as opposed to Line Int, where they are ints, or Line Llama, where they are llamas
12:21:57 <roelof> oke, and data does not have a type arguments  or I do not have to mentioned it ?
12:22:08 <Cale> In this case, you are introducing a new type constructor Line, as well as a new data constructor Line (unambiguous because it lives in the world of values rather than the world of types), whose type is  a -> a -> Line a
12:22:08 <tnecniv> you provided one
12:22:20 <monochrom> yeah, type declaration is better
12:22:36 <Cale> and you also introduced field extractor functions:  slope :: Line a -> a  as well as  intercept :: Line a -> a
12:22:46 <tnecniv> roelof data Line a = Line { slope :: a, intercept :: a}
12:22:49 <tnecniv> a is the argument
12:22:55 <Cale> Yeah
12:23:02 <tnecniv> (also, my terminology may be incorrect. i'm a newbie)
12:23:39 <Cale> You're defining the data types Line a, for every type a
12:24:30 <tnecniv> a better definition is probably one that constrains a to be a Num, but whatever
12:24:35 <roelof> oke, that is not complete right I think. This functions only needs to work with Numbers , not strings , lists and so on 
12:24:36 <tnecniv> that's beyond this discussion probably
12:24:42 <ReinH> tnecniv: no
12:24:49 <tnecniv> ReinH ?
12:24:50 <Cale> Probably not actually. You usually don't want to constrain your data constructors.
12:24:51 <ReinH> data constraints are broken
12:24:52 <roelof> or do I misunderstood what the a means 
12:25:08 <tnecniv> ReinH oh right i forgot
12:25:23 <tnecniv> you need a ghc extension for that, yes?
12:25:39 <tnecniv> seems like a natural thing to have
12:25:45 <tnecniv> but again i'm new
12:25:45 <ReinH> Well, they aren't broken. They do what they are meant to do. It's just that what they do is pretty useless.
12:25:48 <Cale> roelof: If you write  crossX :: Line Float -> String, then crossX only takes a Line Float
12:25:56 <ReinH> Which is why they are deprecated
12:26:06 <johnw> tnecniv: you can easily do it with GADTs, but it's more typical to constrain the use of Line, rather than the construction of Line
12:26:16 <Cale> roelof: You could write perhaps a more polymorphic one, like  crossX :: (Num a, Show a) => Line a -> String
12:26:20 <maerwald> wonder why this topic comes up so often here
12:26:22 <tnecniv> roelof or crossX :: Num a => Line a -> String
12:26:27 <johnw> maerwald: which topic?
12:26:34 <monochrom> the report says "type signature": gendecl	→	vars :: [context =>] type	    (type signature)
12:26:38 <maerwald> people trying to put class constraints inside data types
12:26:45 <ReinH> maerwald: it's a natural thing to want to do
12:26:53 <tnecniv> johnw i see
12:26:54 <johnw> there are many topics that recur often here :)
12:27:05 <ReinH> monochrom: oh, ok.
12:27:33 <roelof> Thanks, then the function looks well. 
12:27:39 <tnecniv> maerwald it makes sense intuitively. it's obviously not the only way to do things, but i was surprised it wasnt a feature when i learned about them
12:27:57 <roelof> Tommorrow try to find out how I can test when y = 0 , what m and b are then 
12:28:09 <roelof> my head is spinning and tired now 
12:28:53 <ReinH> m and b are always what you set them to
12:29:09 <ReinH> maybe you mean to find x
12:29:19 <roelof> sorry I mea when  x = 0 what m and b are when using this formula y = ax + b 
12:29:30 <ReinH> m and b are always what you set them to
12:29:37 <ReinH> maybe you mean to find y
12:29:53 <Cale> heh
12:29:56 <tnecniv> roelof again, by your definition of line, wont you know that?
12:30:03 <tnecniv> you are given m and b
12:30:08 <tnecniv> (note that m === a)
12:30:16 <Cale> Wait what?
12:30:18 <Cale> What's a?
12:30:30 <ReinH> Cale: roelof used y = ax + b for some reason
12:30:30 <Cale> You're not saying that the slope is equal to a type :)
12:30:31 <roelof> yes,  I try to find out what a and b are when the line is the y-axis 
12:30:32 <Cale> oh
12:30:41 <Cale> Okay
12:30:48 <ReinH> roelof: you provide m and b
12:30:51 <ReinH> those are the arguments to Line
12:30:56 <ReinH> you already know what they are
12:31:02 <ReinH> you don'tneed to calculate anything
12:31:09 <monochrom> there is no a such that y=ax+b is the y-axis.
12:31:31 <monochrom> the y-axis is x=0, and there is no way you can rewrite that to y=?x+?
12:32:06 <monochrom> the slope-point form is fundamentally limited
12:32:31 <roelof> I have to find where a straight line crosses the x-axis, But when the line is the x-axis  then every point is the solution 
12:33:04 <Cale> roelof: Right, so you might want to represent the possible answers to the question using another data type.
12:33:32 <ReinH> A line crosses the x axis when y = 0
12:33:32 <roelof> so if we have y = mx + b . I have to figure out what m and b are then so I can make a clause for it 
12:33:36 <tnecniv> roelof perhaps something similar to the Maybe type
12:33:45 <ReinH> roelof: I don't know how else to say this
12:33:46 <Cale> roelof: data LineRoot a = None | Some a | All
12:33:57 <ReinH> roelof: You ALREADY KNOW what m and b are. You define them when you construct a Line.
12:34:04 <Clint> speaking of class constraints, how can i have a function of SomeClass a => MySumType -> a
12:34:12 <ReinH> roelof: Are you listening to me?
12:34:16 <ReinH> I've said this 5 time snow.
12:34:17 <monochrom> you are tired and you need to sleep
12:34:24 <roelof> ReinH:  of course I listen 
12:34:36 <ReinH> roelof: then why do you keep asking how to find out what m and b are?
12:34:36 <monochrom> 5 time snow would be nice for this Christmas Eve :)
12:34:47 <ReinH> monochrom: space bars hate me
12:35:01 <Cale> Clint: By putting methods into SomeClass that let you construct results of the constrained type somehow?
12:35:05 <monochrom> (but not for the Christmas morning that follows. someone has to shovel the snow.)
12:35:08 <Cale> :t read
12:35:10 <lambdabot> Read a => String -> a
12:35:17 <tnecniv> monochrom indeed, the whether in the US north east is ridiculous
12:35:18 <ReinH> monochrom: I think we might technically have snow on Christas. For a few minutes. That won't stick.
12:35:19 <Cale> Clint: ^^ something like Read does
12:35:43 <Clint> Cale: it's not my class though; it's HashAlgorithm from cryptonite
12:35:47 <tnecniv> it's fucking 65 in NJ
12:36:41 <roelof> because I do not see it. IM going to sleep over it Maybe then I see the answer 
12:36:52 <roelof> Thanks all and have a nice X-mas evening 
12:37:00 <tnecniv> roelof do the problem on paper
12:37:09 <tnecniv> you will see what we mean
12:37:12 <tnecniv> have a nice xmas
12:37:27 <Cale> Clint: Unfortunately it appears that class has no exposed methods, and what methods it does have wouldn't help you to construct values of an arbitrary type anyway.
12:37:27 <pdxleif> What happened to the "g" in the command "cabal sandbox hc-pkg" ?
12:38:02 <Cale> Oh, they are exposed from Crypto.Hash.IO
12:38:51 <Cale> Clint: However, the type 'a' just looks like a silly type tag anyway
12:39:09 <Cale> Clint: This looks like a class which should not be a class, but instead a record data type.
12:39:12 <monochrom> they want to say the haskell compiler doesn't have to be ghc, so hc stands for just haskell compiler. in reality, they want to save typing
12:39:23 <Clint> Cale: hmm
12:39:55 <Cale> Clint: Well, I might be calling that a bit too soon. I don't know what this Context type function is.
12:40:10 <Cale> ah, it's a phantom
12:40:12 * hackagebot cryptonite 0.10 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.10 (VincentHanquez)
12:40:24 <aweinstock> roelof: data InterceptResult = NoPoint | OnePoint Double Double | TheEntireAxis
12:40:39 <Cale> haha, just as we're talking about this library, a new version comes out
12:40:57 * Clint looks around for vincent
12:40:59 <aweinstock> hackagebot mentions packages every time there's an update?
12:41:10 <tnecniv> Clint yes?
12:41:22 <Clint> close enough
12:41:23 <monochrom> yes. probably lumping several together. or not.
12:41:28 <kadoban> aweinstock: Yeah. It's usually more annoying than useful, but you can just ignore it.
12:41:40 <Clint> it's especially annoying when someone edits the hackage metadata
12:41:45 <monochrom> it is funny or useful to me :)
12:41:48 <aweinstock> tnecniv: you're the author if cryptonite?
12:41:54 <aweinstock> s/if/of/
12:41:54 <tnecniv> hell no
12:41:57 <aweinstock> oh
12:42:03 <tnecniv> just read my username backwards
12:42:11 <aweinstock> ah, I see
12:42:15 <kadoban> I usually don't mind it, except some people have like 20 packages that all get updated at the same time and then it's spammy as hell.
12:42:52 <tnecniv> some people get it immediately, some people never see it unless it's pointed out
12:43:17 <aweinstock> I used cryptonite to provide the primitives for the "attack" portion of an attack/defend project for a crypto class this semester
12:43:22 <Cale> tnecniv: I saw it as soon as you said "yes?"
12:43:23 <aweinstock> it worked rather well
12:44:01 <aweinstock> (we had to write the "defend" portion in C++, but we were allowed to use whatever language we wanted to the "attack" portion)
12:44:17 <tnecniv> i once used to hang out in this gaming mumble server, and after being there for 6 months, a guy freaked out because he finally figured out my name
12:44:21 <tnecniv> and felt like an idiot
12:44:36 <tnecniv> aweinstock interesting
12:46:49 <aweinstock> tnecniv: https://github.com/aweinstock314/sheedb_weinsa_crypto2015_project/blob/master/redteam/MitmProxy.hs if you're interested in the details
12:47:21 <phy1729> Is there a standard indent for where and guards since tabs are apparently frowned upon?
12:48:38 <MarcelineVQ> multiples of two work well, except where they don't
12:49:41 <Cale> phy1729: Just make sure that things line up nicely
12:49:59 <Cale> Nobody cares about whether the number of spaces is even or odd
12:50:25 <phy1729> then why not just use tabs?
12:50:52 <Cale> Because tabs are rendered as a different number of columns in different editors
12:51:07 <Cale> But they are always treated by the compiler as aligning to the next multiple of 8
12:51:25 <Cale> and this can affect the meaning of programs
12:51:48 <Cale> You can write a program which looks like it does one thing with tabstops set to 4, but which actually does something different
12:52:08 <phy1729> I assume if you use tabs properly this isn't an issue?
12:52:10 <roelof> what do you think of this solution : http://lpaste.net/147801
12:52:39 <Cale> phy1729: If you're careful and awkwardly contort the way that you make the source look so as to accomodate tabs, then it's possible to get by
12:52:50 <Cale> phy1729: But everyone will hate you
12:53:06 * hiptobecubic will hate you
12:53:45 <aweinstock> Cale: is it possible get arbitrary differences that way? (i.e. take 2 haskell programs, and combine them such that the source looks like it executes the first (with some tab settings), but actually executes the second?)
12:53:45 <Cale> There's no real reason to have tab characters in source code.
12:53:56 <Cale> It's not like they're needed for the data compression
12:53:58 <phy1729> why the hate though for just tabs to indent spaces to align  (btw if there's some document that explains all this I don't mind reading)
12:54:16 <Cale> phy1729: Well, there is no indentation
12:54:23 <Cale> there's just alignment
12:54:23 <aweinstock> naively I'd expect it's only contortedly possible, or that 1 of the things would be an error?
12:54:41 <Cale> It doesn't matter how much stuff is indented, only which column it's aligned with.
12:54:44 <phy1729> Cale: guards and where are indented
12:55:26 <aweinstock> phy1729: if you want to use tabs, use curly brackets as well to avoid ambiguous edge cases
12:55:59 <Cale> http://urchin.earth.li/~ian/style/haskell.html has some additional comments about why nobody uses tabs
12:56:02 <phy1729> Is there an example of such an edge case? Perhaps I'm missing something
12:56:18 <Cale> But tbh, the best reason is just that it makes the code appear different based on editor configuration.
12:56:26 <Cale> which is not a good thing
12:56:45 <tnecniv> aweinstock unfortunately i dont know much about cryptography
12:57:08 <Cale> (since the chances that it'll just look bad are much higher than any other possibility)
12:57:14 <phy1729> I like that feature since I like 8 space indents and others are weird and like two space indents
12:57:43 <tnecniv> phy1729 heathen
12:57:46 <Cale> phy1729: Just make the code look good to you. If you want to use 8 spaces and can make things look good that way, put 8 spaces there, and nobody will mind.
12:57:47 <tnecniv> i like either two or 4
12:57:51 <Cale> Just don't use a tab
12:58:08 <Cale> Tab characters are evil and they should never have existed.
12:58:09 <tnecniv> Cale i mix tabs and spaces
12:58:17 <Cale> ugh, that's even worse
12:58:21 <tnecniv> i kid
12:58:26 <tnecniv> i just use spaces
12:58:35 <tnecniv> 4 typically, but i can deal with 2
12:58:38 <exio4> do you mix arbitrary whitespace in your code?
12:58:53 <exio4> unicode has quite a lot of whitespace codepoints
12:58:54 <tnecniv> i use a script that randomly indents lines before commits
12:59:32 <tnecniv> like the opposite of Go's gofmt
12:59:33 <Cale> add random amounts of trailing whitespace to every line
12:59:47 <Cale> so that it becomes really annoying to figure out what changed
12:59:56 <exio4> tnecniv: git troll haskellers ; git commit -m "trolololol"? 
13:00:19 <tnecniv> exio4 yup
13:00:29 <tnecniv> my messages are also prones to puns and profanity
13:01:11 <aweinstock> https://github.com/reinderien/mimic
13:01:19 <tnecniv> for my operating systems class, we underestimated how much time the final project would take and ended up spending the last 40 hours working on it straight
13:01:30 <tnecniv> looking back on the commits is fun
13:01:37 <aweinstock> what was the project?
13:01:50 <tnecniv> fake OS
13:01:53 <monochrom> Cale: I mix tabs and windows. tee hee hee!
13:01:58 <tnecniv> by fake, it was actually a linux process
13:02:12 <tnecniv> that used deprecated POSIX libs to do stuff like non-linear code execution
13:02:18 <tnecniv> so that we could get multi-tasking
13:02:33 <tnecniv> made it real fun to debug
13:02:55 <tnecniv> since whenever there was a jump, GDB would crap out
13:03:28 <aweinstock> setjump/longjump?
13:03:29 <tnecniv> and the only docs we had were 3 poorly written manpages
13:03:31 <tnecniv> nah
13:04:09 <tnecniv> i will find it
13:04:10 <tnecniv> one sec
13:04:18 <exio4> writing a scheduler sounds like fun 
13:04:57 <Jinxit> what's a good analogue for the OOP builder design pattern in haskell? State monad or something?
13:05:49 <maerwald> Jinxit: this might be an interesting read http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
13:05:52 <tnecniv> ucontext
13:05:55 <tnecniv> is the name of it
13:06:10 <maerwald> but it's somewhat pointless to look for oop-like design patterns in haskell imo
13:06:32 <tnecniv> exio4 the prof joked that it's one of the few things computer scientists do science for
13:06:57 <tnecniv> since tuning your scheduler is very experimental
13:07:15 <Jinxit> maerwald: I saw that but it didn't tell me much
13:07:26 <maerwald> stop searching for it then :P
13:07:47 <Jinxit> but what if I want to build some data with several optional steps?
13:07:51 <tnecniv> exio4 go buy an avr or pic and have fun
13:08:11 <xpilot> I'm getting some very odd behavior with a cabal project
13:08:19 <maerwald> Jinxit: what do you mean with "optional steps"?
13:08:25 <xpilot> when I cabal install/repl, I get a syntax error in a nested do statement
13:08:40 <xpilot> this doesn't happen when I use plain ghc(i)
13:08:53 <maerwald> a "builder" in haskell can just be a regular function you pass to another function
13:08:56 <exio4> tnecniv: why do you say so? :P I have an arduino kit 
13:08:57 <lispy> xpilot: does the cabal file turn on any language extensions?
13:09:26 <tnecniv> exio4 that will do
13:09:29 <maerwald> Jinxit: https://github.com/jberryman/directory-tree/blob/master/System/Directory/Tree.hs#L334 here's an example
13:09:33 <Jinxit> in this case I'm setting up a game between several players, giving them stats and items
13:09:46 <roelof> what do you think of this solution : http://lpaste.net/147801
13:09:56 <maerwald> and the "buildWith" function takes a builder then to produce the end result
13:10:05 <tnecniv> exio4 because you can write some real basic OS stuff on those without the hassle that comes with x86 and modern hardware
13:10:14 <tnecniv> you could do arm, too, but avr is more compact
13:10:39 <tnecniv> arm chips have more functionality, but that can make things harder to learn
13:10:52 <xpilot> lispy: you mean does it have any other-extensions fields?
13:10:59 <exio4> tnecniv: oh, sure, didn't think bout that
13:11:23 <tnecniv> exio4 if i was teaching an OS class, i would consider doing it that way
13:11:44 <tnecniv> i'd probably make a custom dev board so all the CS kids who never touched a soldering iron dont get scared
13:11:51 <lispy> roelof: Draw the line y = x on some graph paper
13:12:08 <ReinH> roelof: Well, it's wrong.
13:12:44 <exio4> tnecniv: my toy OS (8086 asm) was really crappy, because 8086 is really nasty and couldn't get things working "easily" as with other ASMs :P 
13:12:46 <ReinH> y = 1x + 0 crosses the x axis, y = 0x + 3 never crosses the x axis.
13:12:53 <xpilot> lispy: the cabal file was generated by cabal init, so yes it does 
13:13:01 <roelof> bummer . Then im really going to sleep and hopefully  I see how I can make this code good 
13:13:09 <tnecniv> exio4 not surprised. i'd use C though
13:13:42 <lispy> xpilot: the most general way to debug this is to crank up the verbosity on cabal and then compare that command to the one you use. See if you can spot the difference.
13:13:42 <tnecniv> i hear ARM asm is actually pretty nice
13:13:47 <maerwald> life is too short for ASM
13:13:56 <tnecniv> maerwald tell that to the roller coaster tycoon guy
13:14:00 <ReinH> roelof: I think if you moved ilne 14 above line 13, that line would become correct
13:14:04 <lispy> xpilot: but other than language extensions, I'm not sure why this would be happening.
13:14:11 <tnecniv> 90% of that game was in ASM
13:14:15 <maerwald> tnecniv: he probably knows it then
13:14:17 <tnecniv> C was only used to interface with DX
13:14:23 <ReinH> wait, no
13:14:41 <ReinH> You have them mixed up
13:15:43 <roelof> ReinH:  which one 
13:15:56 <ReinH> All of them.
13:16:11 <ReinH> Well, 15 is correct.
13:16:19 <ReinH> and 14 is correct. So half of them.
13:16:36 <ReinH> If m = 0 and b /= 0 then the line never crosses the x axis
13:16:52 <roelof> I see y = b is a line which is parallel on the x-axis 
13:16:53 <ReinH> if b = 0, the line *always* crosses the x axis
13:17:21 <ReinH> because 0 = 0 + 0
13:18:41 <ReinH> so you have three cases: m = 0, b /= 0; m = 0, b = 0 (the special case when the line is on the x axis); and otherwise
13:18:43 <lispy> roelof: I wish we could sit down at a chalkboard together. This is so much easier to explain with pictures
13:19:32 <roelof> oke, so 12 and 13 must be the other way around. the outcome of 12 must be the outcome of 13  
13:20:06 <ReinH> No, you need the cases I said.
13:20:17 * hackagebot stack 1.0.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.0.0 (borsboom)
13:20:26 <ReinH> Or you could add extra superfluous ones.
13:22:32 <ReinH> crossX (Line 0 0) = "everywhere"; crossX (Line 0 _) = "nowhere"; crossX (Line m b) = show (-b / m)
13:22:44 <roelof> oke, thanks 
13:24:47 <roelof> oke, so this is good : http://lpaste.net/147801
13:25:01 <ReinH> roelof: no.
13:25:04 <ReinH> What I said is good.
13:25:34 <ReinH> You asked if it would be good and I said no and then you did it and asked if was good and it is still not good.
13:25:47 <roelof> oke, I also have to switch the order. Like you did here : crossX (Line 0 0) = "everywhere"; crossX (Line 0 _) = "nowhere"; crossX (Line m b) = show (-b / m)
13:25:48 <ReinH> I don't think you are listening to me.
13:26:24 <roelof> I do listen to you 
13:27:03 <ReinH> You asked if you needed to switch 12 and 13. I said no. Then you switched 12 and 13 (incorrectly, btw) and asked if it was good. No, it is still not good.
13:27:51 <ReinH> What you need is mine or something equivalent to mine.
13:28:41 <ReinH> So no, I don't think you're listening to me, since you're ignoring my advice.
13:29:43 <roelof> last try of today : http://lpaste.net/147801
13:30:37 <ReinH> That's correct, although I don't see why you would use guards instead of patterns.
13:30:45 <tnecniv> dont you love when you stuff magically works when you werent expecting it to?
13:31:21 <roelof> ReinH:  maybe bad habits  more used to use guards then patterns 
13:31:28 <ReinH> You should get used to patterns
13:31:33 <ReinH> they are more fundamental than guards
13:31:36 <tnecniv> roelof patterns are way more powerful
13:31:51 <tnecniv> will be more useful when you work with more complicated data types
13:32:03 <roelof> oke, I will change them and think about patterns the next exercises 
13:32:22 <roelof> thanks for the patience and help for today 
13:32:26 <ReinH> yw
13:32:34 <roelof> and again merry X-mas 
13:32:37 <ReinH> you too
13:33:06 <ReinH> tnecniv: that's a feeling I only get with Haskell. With other languages, it's "why didn't THAT work?"
13:33:26 <ReinH> I assume that this is because I am stupid and Haskell is protecting me from myself.
13:34:34 <jedws> wait, won't the first two guards have precedence over the `m == 0 && b == 0` guard?
13:34:42 <tnecniv> ReinH ehh this was more "i have bugs x and y. i fixed y and it also fixed x"
13:34:49 <tnecniv> i wasnt expecting it to fix x, but it did
13:34:50 <jedws> and that one will never match?
13:35:47 <ReinH> jedws: Yes, that one is incorrect. There are three. The third one is correct.
13:36:34 <jedws> ReinH ah, right :-)
13:36:57 <ReinH> jedws: I didn't get that far. I stopped at the fact that the first two lines are already wrong per se.
13:37:56 <jedws> yeah, I was merely looking at the construction, not the algorithm itself 
13:47:17 <xpilot> anyone know how to make nested do statements in Haskell2010?
13:47:41 <dmj`> > do do do 1 + 1
13:47:43 <lambdabot>  2
13:48:02 <xpilot> I want to do something like do {x; let y = do {...}; z} 
13:48:32 <xpilot> without the Haskell2010 flag it works just fine, but with Haskell2010 on I get a syntax error
13:48:46 <xpilot> I'm not using braces in my actual code of course
13:49:22 <dmj`> > do { let x = do { val <- lookup "foo" [("foo", 2)]; return val; } in x }
13:49:24 <lambdabot>  Just 2
13:49:52 <dmj`> xpilot: the first do could be in any monad, the second is the maybe monad
13:50:24 <xpilot> of course I can do it with braces - I'm just wondering if it is possible with just whitespace
13:51:52 <lispy> xpilot: can you show us an example on lpaste?
13:52:53 <dmj`> xpilot: http://lpaste.net/147805
13:53:02 <dmj`> think you need to indent the in a few spaces
13:55:49 <xpilot> http://lpaste.net/147806
13:56:22 <xpilot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs-and-infelicities.html seems to indicate that Haskell2010 is more strict with regards to layout
13:58:13 <lispy> xpilot: right, so I think the problem is that z needs to be indented further than y.
13:58:45 <xpilot> yup that works
13:59:21 <lispy> that's subtle
14:15:18 * hackagebot resolve-trivial-conflicts 0.3.2 - Remove trivial conflict markers in a git repository  https://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.2 (EyalLotem)
15:16:18 <pikajude> is there a module in base that provides a canonical list of reserved words?
15:18:13 <geekosaur> no
15:19:05 <bergmark> pikajude: that's specified in the haskell report, but what's reserved can vary based on enabled extensions (e.g. proc is reserved with -XArrows)
15:19:17 <pikajude> ok
15:20:16 <geekosaur> if it is anywhere then it is in the ghc package, not base
15:21:28 <geekosaur> but even there I think it is not exposed
16:03:54 <Gurkenglas> hrrm why is letlpaste limited to 2-4k?
16:05:22 * hackagebot cryptol 2.2.6 - Cryptol: The Language of Cryptography  https://hackage.haskell.org/package/cryptol-2.2.6 (AdamFoltzer)
16:14:54 <pikajude> ugh
16:15:14 <pikajude> i hate when useful utilities aren't exposed in a package
16:15:35 <pikajude> iproute doesn't expose its parser, leaving the end user to use `read'
16:20:55 <lamefun> Can I add an additional layer of exception that can't be caught by 'catch'?
16:21:08 <athan> pikajude: :\ what about readMaybe?
16:21:44 <athan> lamefun: Only if it's not in the superclass
16:21:55 <athan> like SomeException is the broadest
16:22:07 <athan> so if you're catching with that type, it will catch all of those exceptions
16:22:20 <athan> but if you make a new exception type `Foo`, you can `catch` only using that type
16:22:41 <lamefun> But can't all exception be packed into SomeExceptipn?
16:22:48 <athan> that's what I'm saying
16:23:00 <athan> if you're using SomeException in your catch, you can't bypass it
16:23:40 <lamefun> can I add another layer of fake exceptions then?
16:24:00 <pavonia> Why do you want exceptions that can't be caught?
16:24:19 <trew> just curious. Why is haskell channel even more active than javascript on freenode given that there were much fewer haskell programmers in the world? Haskell folks tend to be more helpful and passionate?
16:24:31 <athan> lamefun: yeah, so long as you catch the fake ones before you catch any
16:24:38 <johnw> We just have a lot to talk about
16:25:28 <trew> trew: haskell is for very smart programmers. This is why I tend to avoid it. is this a fair stereotype? How can a newbie, not so smart person learn haskell?
16:25:40 <lispy> trew: I know far more haskell programmers than javascript programmers. So I'm not sure your assumptions are true.
16:25:46 <athan> trew: There are tons of ways :)
16:25:49 <johnw> our interests don't lie just in what we do with Haskell, but also what Haskell can possibly do, which is far more than anyone ever imagines, it would seem :)
16:25:55 <athan> I found it to be easier than others after a while actually
16:26:29 <athan> it just has a lot of crazy descriptions and stuff. But once you understand lambdas and constructor cells, you understand most of haskell
16:26:32 <rom1504> trew: #node.js is pretty active too
16:26:34 <trew> lispy: but haskell is so different!
16:26:41 <johnw> I wouldn't say Haskell is just for smart people; it's for people who are willing to think, though
16:27:01 <pavonia> Smart programmers use Haskell and ghcjs, so they don't need to care about JS problems :p
16:27:05 <lamefun> pavonia, I want them to be caught, but not by catch.
16:27:14 <johnw> the type system places a higher requirement on understanding what you're trying to do
16:27:38 <pavonia> lamefun: Maybe wrap an ExeceptT around?
16:27:41 <trew> I'm trying to understand the benefits of learning haskell. What can haskell do that javascript cannot? Or what can haskell do better that js cannot?
16:27:58 <lispy> I actually find lots of other languages take more cognitive effort to understand. Every time I try to python I realize I'm not nearly smart enough to python.
16:28:53 <trew> lispy: this is surprising. python is much simpler for me. I always thought python is for simpler minds.
16:29:18 <trew> i find haskell code more unreadable. tries to do lots of things with a few lines of code. 
16:29:23 <johnw> trew: it's not so much what it can do that js cannot, but how you go about doing it
16:30:17 <exio4> trew: "Haskell code unreadable" - I also found it unreadable until I learnt it, as I also found Python's syntax to be kind of magical before I learnt an imperative programming language! 
16:30:22 * hackagebot aeson-casing 0.1.0.5 - Tools to change the formatting of field names in Aeson  instances.  https://hackage.haskell.org/package/aeson-casing-0.1.0.5 (andrewrademacher)
16:30:42 <trew> what is a good haskell book for a newbie?
16:30:50 <ReinH> exio4: I also find Japanese to be unreadable.
16:30:58 <ReinH> I probably wouldn't if I knew Japanese.
16:31:06 <lispy> trew: depends on your background.
16:31:17 <johnw> for me, all Japanese has a single meaning: "Hey, that's in Japanese."
16:31:18 <trew> lispy: i know python and js.
16:31:21 <lispy> trew: Some people like learn you a haskell.
16:31:27 <exio4> ReinH: makes perfect sense =) 
16:31:49 <lispy> johnw: heh
16:31:55 <lispy> johnw: what could be simpler?
16:32:00 <ReinH> others do not like LYAH at all
16:32:04 <exio4> @where learnhaskell 
16:32:05 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:32:06 <trew> which ide is good for haskell? i don't mind paying 
16:32:08 <exio4> and prefer ^
16:32:11 <ReinH> trew: any text editor
16:32:32 <trew> ReinH: text editor are for the elites. I'm not.
16:32:33 <ReinH> GHCi provides most of what you'd usually want an IDE for.
16:32:42 <ReinH> text editors are for editing text
16:32:45 <ReinH> Haskell is text.
16:32:52 <lispy> trew: what do you currently edit code with?
16:32:59 <exio4> trew, a "common workflow" is to have a text editor + ghci in a terminal, where you :reload files, etc
16:33:03 <trew> for js, i use webstorm. it is hard to use normal text editor. for python, i use pycharm
16:33:21 <lispy> ah, I'm not familiar with either of those
16:33:28 <ReinH> You could try Leksah, but you don't need an IDE for Haskell
16:33:31 <lispy> Does eclipse still have a haskell mode?
16:33:41 <exio4> ReinH: I'd say it's more painful to use an IDE than not use it :P 
16:33:44 <lispy> Most people here use either vim, emacs, or both
16:34:10 <trew> lispy: wow. haskell sounds elitist. My impression is that elite programmers don't use IDEs
16:34:31 <ReinH> trew: My impression is that programmers either use IDEs or not as is their personal preference
16:34:43 <ReinH> And also the complexity of writing the language plays a part
16:34:50 <ReinH> Java IDEs are popular in large part because Java is hard tow rite
16:34:52 <ReinH> *to write
16:34:53 <lamefun> Transformers and MTL are duplicated?
16:35:02 <ReinH> lamefun: No.
16:35:22 <ReinH> trew: I'm surprised that "it's just text, use a text editor" seems elitist to you
16:35:30 <ReinH> That seems decidedly unelitist to me
16:35:38 <ReinH> but I suppose different people have different ways of perceiving things
16:35:57 <lispy> trew: emacs and vim are worth learning. They are fairly different to other editors, but very powerful. As a programmer it's nice to be able to script things and come up with automation to fit your personal style. Both vim and emacs excel at that.
16:36:03 <trew> ReinH: without ide, how to do debugging? only elites can get away with minimal debugging
16:36:26 <indiagreen> I imagine it might seem elitist because of the stereotype of famous old-school programmers who work in terminals and never use IDEs and so on
16:36:31 <ReinH> trew: You can debug in GHCi
16:36:43 <ReinH> Debugging is not the same in Haskell as it is in other languages
16:36:45 <lispy> debugging is an interesting topic for haskell. We have very little support for it due to the way the language works.
16:36:56 <ReinH> But you can accomplish similar goals with ghci
16:37:01 <lispy> true
16:37:16 <trew> lispy: that's interesting. No watch window, no breakpoint? 
16:37:21 <lispy> gdb style debugging is almost non-existent though
16:37:35 <ReinH> trew: Haskell doesn't have a call stack. You can't debug it like you would C or Python.
16:37:36 <geekosaur> as for python. python specializes in combining simple behaviors. where it falls apart is that the interaction of simple behaviors can end up being anything but simple
16:37:41 <trew> this https://github.com/bitemyapp/learnhaskell looks good. I will start off with this for learning
16:37:52 <exio4> debugging Haskell is quite different
16:38:10 <lamefun> ReinH, they surely seem duplicate...
16:38:35 <Clint> lamefun: mtl uses transformers
16:38:41 <exio4> lamefun: the types are defined in transformers, mtl is just a library "on top" of transformers
16:38:45 <ReinH> lamefun: mtl adds typeclassses for the transformers in transformers
16:38:48 <trew> i thought u are kidding. is it really true one cannot set breakpoint in haskell?
16:38:56 <indiagreen> lamefun: transformers defines transformers, mtl defines classes that let you use operations like “ask” and so on without lifting everything
16:39:13 <ReinH> trew: You can set breakpoints in ghci
16:39:22 <ReinH> but I don't know of many people who use the ghci debugging facilities
16:39:42 <trew> ReinH: how about having watch window to watch variables? can one do that? If yes, i don't see a problem
16:39:42 <ReinH> it's just a different language with a different way of working with it
16:39:54 <ReinH> trew: you can examine variables in ghci
16:40:09 <geekosaur> the problem with breakpoints is that things do not execute when / the way you expect them to, so your breakpoint may end up being useless
16:40:13 <trew> ReinH: thanks. I'm relieved. shouldn't be a big problem then
16:40:30 <geekosaur> breakpoints are often only useful if you know exactly how something will be evaluated.. in which case, you probably don't need the debugger
16:40:30 <ReinH> trew: One of the reasons that you don't need traditional debugging tools in Haskell is that Haskell is a language of function composition. You don't need to set a breakpoint somewhere deep in a function
16:40:34 <ReinH> because functions tend to be small
16:40:37 <ReinH> have fixed inputs and outputs
16:40:39 <ReinH> are stateless
16:40:45 <ReinH> there's just not much there to debug
16:40:47 <exio4> trew, as you learn Haskell, you'll see that the normal way to debug problems, or reason about them is going to be totally different (pretty much)
16:40:48 <trew> just wondering. can learning haskell somehow improve how one program in other languages like js and python?
16:41:01 <geekosaur> yes
16:41:15 <ReinH> Absolutely.
16:41:47 <trew> but not all languages are functional. how does it really help?
16:42:05 <exio4> trew: you'll develop a new way of thinking problems
16:42:14 <exio4> trew: thus meaning you have tools in your toolkit as a programmer
16:42:27 <exio4> new tools*
16:42:45 <trew> does learning haskell make a programmer more productive?
16:42:54 <ReinH> Certainly more productive in Haskell
16:43:43 <johnw> trew: that depends on a lot of factors
16:43:49 <trew> please don't mind me playing devil's advocate. If haskell and functional programming have so many benefits, why is the adoption rate still low? Except for freenode, the commercial world has few applications for haskell
16:43:50 <ReinH> trew: Why do athletes cross-train?
16:43:56 <lispy> trew: the company I work at, we have a lot of haskell programmers but sometimes we have to write in other languages. Haskell is a really good design language for us to communicate in.
16:43:59 <johnw> trew: if you are prone to yak-shaving in the presence of cool ideas, you may never get another productive thing done again
16:44:01 <bernalex> johnw: like "what do you mean by productive"
16:44:08 <lispy> trew: in that sense, I think it does help us design better programs regardless of language.
16:44:19 <ReinH> trew: The commercial world has plenty of uses for Haskell. You being unaware of them is not the same as them not existing.
16:44:54 <bernalex> trew: one very concrete example: the parallel C programs I wrote post-learning haskell had a lot fewer bugs and were a lot more elegant, because I thought more about effects and compartmentalising.
16:45:01 <trew> now, the impt but taboo question. Are haskell programmers generally better paid than others? 
16:45:06 <lispy> trew: https://wiki.haskell.org/Haskell_in_industry
16:45:25 <ReinH> trew: I have been paid competitively as a Haskell programmer.
16:45:36 <ReinH> I don't think I can speak for the industry as a whole
16:45:45 <bernalex> trew: probably on average -- but that's simply because there are fewer of them, and usually in more exclusive jobs..
16:45:46 <ReinH> It has more to do with an individual's experience and skills anyway
16:45:58 <trew> ReinH: is it because employers tend to be impressed by anyone who knows haskell? that haskell folks are more elites?
16:45:58 <bernalex> it's a pointless metric.
16:46:27 <raoz_> Hi! Why is SourceGraph showing my Main module as inaccessible when using the .cabal method and how do I fix it?
16:46:32 <divVerent> I'd say they are better paid on average, but not because of knowing Haskel
16:46:34 <divVerent> l
16:46:38 <bernalex> trew: haskell isn't as sought after in industry. so someone knowing haskell will usually mean that they are interested in -- and perhaps good at -- learning per se. people who are interested in and good at learning make good employees.
16:46:58 <divVerent> but because of better mathematical understanding which Haskell requires and trains
16:47:00 <trew> i'm motivated to learn haskell now. THanks. tried but fail. Will try again
16:47:06 <divVerent> thus you'd score better in most interviews
16:47:14 <ReinH> I doubt many of us are interested in convincing you that you will make more money with Haskell. It's an interesting language, and if you are interested then you should learn it.
16:47:18 <lispy> trew: we're always here to help if you get stuck
16:47:24 <divVerent> hehe
16:47:28 <trew> divVerent: what sort of math topics do I need to know before learning haskell?
16:47:34 <bernalex> trew: and I'd wager that it's still the case that most haskell programmers know c/c++ etc. quite well, and only learned haskell as a third or fifth language, so they were usually above average programmers before knowing haskell.
16:47:37 <ReinH> You may or may not make more money, and it could take years or never happen. I wouldn't use that as a motivator.
16:47:39 <divVerent> sure, I'm not saying you'd actually use Haskell there thgough
16:47:44 <divVerent> trew: proofs
16:47:44 <bernalex> trew:you don't need to know any maths.
16:47:45 <trew> lispy: thanks. U guys are so helpful. I guess money doesn't motivate u much
16:47:53 <divVerent> the most important part to know and understand
16:48:06 <divVerent> also, some minor set theory and algebra
16:48:12 <ReinH> trew: well, I don't want to promise something I can't deliver.
16:48:14 <bernalex> linear algebra helps. boolean logic helps. set theory helps. category theory helps. everything helps. nothing is necessary.
16:48:20 <divVerent> but essentially, strong logical reasoning is important in Haskell
16:48:25 <ReinH> It's a cool language. I think I'm a significantly better programmer for knowing it.
16:48:35 <divVerent> category theory helps too, but that you can do without
16:48:42 <ReinH> YMMV, but ultimately you have to motivate yourself to learn it.
16:48:53 <divVerent> reinh: essentially what I am saying
16:48:59 <bernalex> youc an do without learning logical reasoning pre-haskell too. it's perfectly possible to develop that as part of learning functional programming rather than as a requisite.
16:49:00 <trew> can haskell be applied to AI and machine learning stuff?
16:49:08 <bernalex> yes.
16:49:11 <ReinH> trew: Haskell can be applied to almost anything.
16:49:22 <bernalex> numerous unis use specifically haskell for AI stuff.
16:49:29 <divVerent> it's inconvenient at some things, convenient at others
16:49:33 <divVerent> like any other language too
16:49:34 <ReinH> It struggles with embedded, low-level systems, and hard-realtime domains. Otherwise pretty much everything is fair game.
16:49:41 <trew> ReinH: even web programming? can haskell implement backend systems?
16:49:46 <ReinH> trew: yes and yes
16:49:48 <divVerent> it's Turing complete, so yes, you can theoretically use it for anything
16:49:53 <lispy> ReinH: for those you just make a dsl in haskell to generate the code you actually run :)
16:49:54 <ReinH> Haskell is my favorite web programming language.
16:49:56 <bernalex> ReinH: I'd argue those aren't haskell's struggles but GHC's.
16:49:58 <ReinH> lispy: also that
16:50:05 <trew> ReinH: why problem with embedded systems? haskell require lots of RAM?
16:50:15 <lispy> trew: essentially yes
16:50:15 <divVerent> for basic web stuff like blogs Haskell even seems very well suited
16:50:23 <ReinH> bernalex: I think it's endemic to the constraints of the language to a certain extent
16:50:23 <divVerent> i.e. for "mostly stateless" http
16:50:26 <bernalex> ReinH: there is cool research using haskell on GPUs with speculative evaluation and other non-strict semantics than lazy ones. so I think it's not a languageissue.
16:50:35 <bernalex> + a space in there
16:50:40 <lispy> trew: because haskell is quite abstracted from the machine it doesn't have the predictable representation and evaluation that you tend to need for embedded systems
16:50:41 <ReinH> bernalex: and there's also cool research into realtime GC
16:50:43 <divVerent> as the internal caching and lazy evaluation will likely help there
16:50:46 <trew> can haskell be used to write a REST API server? 
16:50:55 <divVerent> sure it can
16:50:58 <ReinH> bernalex: but that sort of proves my point: there some cool research into how to make Haskell do this thing it isn't designed to do. ;)
16:51:13 <bernalex> ReinH: GC in haskell is also quite usable most of the time, because it's pretty good. so you can predict the pauses, which is usually more than enough.
16:51:26 <ReinH> bernalex: absolutely. Haskell's GC is one of the best in the industry imo.
16:51:40 <ReinH> Haskell is great at lots of things. There are just a few things it isn't good at. That's ok.
16:51:46 <divVerent> let's put it this way: I've never noticed Haskell's GC
16:51:46 <bernalex> ReinH: john carmack went as far as saying it is perfectly OK for AAA games, because it has predictable intermittent pauses. that's neat.
16:51:55 <ReinH> bernalex: I should say *GHC's* GC, sorry
16:51:57 <divVerent> I noticed Go's on my first days of playing around
16:51:58 <bernalex> trew: I write REST API servers in haskell for a living.
16:52:00 <bernalex> ReinH: yeah
16:52:05 <divVerent> (at Go 1.3 I think)
16:52:12 <ReinH> bernalex: GHC is an amazing compiler / runtime system
16:52:33 <bernalex> trew: one of the problems with haskell for embedded systems is that GHC inlines everything very agressively. every program comes with its own RTS. so binaries are usually very big.
16:52:50 <trew> Thanks to all of u. I'm going off to start learning at https://github.com/bitemyapp/learnhaskell. u've been most helpful. Merry Christmas!
16:52:59 <ReinH> bernalex: The main problems for embedded Haskell are the runtime system and GC
16:53:00 <bernalex> but I've seen embedded robots and cool stuff use haskell. they just aren't using GHC/a traditional haskell compiler toolchain.
16:53:05 <ReinH> bernalex: (I think that's what you said)
16:53:07 <bernalex> ReinH: yeah I'm just adding one.
16:53:14 <ReinH> bernalex: it's a good point
16:53:24 <lamefun> Why does MTL's MonadError IO use IOException instead of SomeException?
16:53:24 <divVerent> also means ghc's compilation system isn't very good for huge code bases (and huge binaries)
16:53:31 <divVerent> of course
16:53:41 <divVerent> just do microservices or sth then
16:53:42 <bernalex> divVerent: I disagree with that
16:53:45 <bernalex> as a general statement at least
16:53:51 <ReinH> lamefun: IO exceptions are IOExceptions.
16:54:07 <ReinH> The only issue with GHC is compile times
16:54:08 <divVerent> bernalex: in the sense of bad interface/implementation separation
16:54:12 <ReinH> Haskell is a great language for huge code bases
16:54:14 <ReinH> just ask bos
16:54:17 <divVerent> way too much to recompile after a tiny change
16:54:18 <ReinH> (I did. He told me. ;)
16:54:20 <bernalex> huge codebases are usually meant to be deployed in a very rigid kind of "here's a clean statically linked VM that is nuked every time we upgrade", so it's OK.
16:54:21 <divVerent> otoh the compiler is super fast
16:54:25 <ReinH> Then again, they wrote their own compiler.
16:54:29 <divVerent> so it gets bad quite late
16:54:29 <bernalex> divVerent: oh like that
16:54:37 <bernalex> I haven't had that issue a lot
16:54:45 <bernalex> GHC itself is the biggest haskell codebase I've worked on
16:54:56 <divVerent> that's big, not huge ;)
16:55:01 <bernalex> I am usually working on 1K-10K profesionally.
16:55:01 <ReinH> trew: Happy holidays and whatnot. Good luck! Let us know if you have questions.
16:55:14 <bernalex> divVerent: well 100K+ is pretty big, but it's not millions of SLOC.
16:55:28 <ReinH> bernalex: Anecdotally, I've had a much worse time splitting a Haskell codebase into multiple packages than keeping it in a single package
16:55:32 <ReinH> Stack helps with the distribution now though
16:55:42 <trew> ReinH: thanks. God bless all of you who are so generous with your sharing and time free of charge. 
16:55:46 <divVerent> I just wish ghc had something more like Java's, or at least C's, way of interface vs implementation splitting
16:55:48 <ReinH> But at the time I wrote something pretty similar to Stack on top of cabal to make it sane
16:55:55 <divVerent> so changes to implementation don't force a recompile
16:55:56 <bernalex> ReinH: I have never had problems with that because I've always used portage rather than cabal-install. I hear people complaining about it constantly though. :p
16:55:57 <ReinH> trew: <3
16:56:05 <divVerent> of course this would break inlining
16:56:18 <bernalex> divVerent: I just wish we could make runtime fast without agressive inlining.
16:56:26 <ReinH> bernalex: My job used to be to make a bunch of disparate Haskell codebases compile together on a regular basis. With people who didn't want to package things for (private) hackage.
16:56:26 <divVerent> indeed
16:56:32 <divVerent> a prerequisite for that
16:56:34 <bernalex> that way a new lens or whatever doesn't mean "oh lol have fun rebuilding everything because of ABI børking"
16:56:41 <ReinH> bernalex: I'm glad I don't have that job any more. There rest of the job was pretty good though.
16:56:57 <ReinH> s/There/The
16:57:01 <bernalex> ReinH: IME it works well with almost any sophisticated GNU+Linux pm. with cabal-install it's a joke though.
16:57:10 <ReinH> bernalex: Tell me about it.
16:57:13 <bernalex> ofc "works well" doesn't == "not a shit ton of work"
16:57:28 <dalastboss> Hey, I want to write a parser for an ML/haskell like syntax which is white-space sensitive, but I'm still getting used to monads so I'm apprehensive about doing
16:57:31 <dalastboss> this with parsec
16:57:32 <bernalex> especially with very specific maxbounds
16:57:40 <bernalex> but then again without them, it just means stuff blows up, so.
16:57:41 <ReinH> bernalex: I had planned to switch to nix but it never happened
16:57:43 <dalastboss> is parsec well adapted for that kind of thing?
16:57:54 <ReinH> dalastboss: Yes.
16:58:04 <bernalex> parsec is well adapted to most things :p
16:58:18 <divVerent> there's one thing that annoyed me in Haskell recently btw
16:58:29 <divVerent> whenever you want to do slmething in a convenient way
16:58:30 <bernalex> if you are doing it to learn haskell though, maybe try writing it on your own first, and then using parsec? sounds like a nice learning experience.
16:58:37 <divVerent> you have to enable a language extension
16:58:42 <ReinH> dalastboss: Parsec has some tools for that. Maybe see http://hackage.haskell.org/package/indentparser for inspiration.
16:58:42 <bashed> What do I do when I get a "rejecting [package] (global constraint requires ==[version])" with stack?  
16:58:43 <divVerent> many extensions are very widely used by now
16:58:56 <bernalex> divVerent: we have a new haskell' committee. this might be resolved sooner rather than later.
16:59:02 <ReinH> bashed: cry? Fix your extra-deps?
16:59:04 <divVerent> are there plans for a new Haskell standard that includes some by default?
16:59:12 <Gurkenglas> Does something provide "Ord a => [a] -> M.Map a [Int]"?
16:59:18 <pikajude> why can I put "; " before a top-level TH splice?
16:59:19 <bernalex> divVerent: yes. haskell' is "the next haskell".
16:59:21 <ReinH> bernalex: hahahaha haskell prime resolving things you are too funny
16:59:26 <divVerent> because I feel quite dirty for enablinggf them
16:59:28 <dalastboss> ReinH: looks interesting, thanks for the link
16:59:43 <bernalex> ReinH: hvr & co have resurrected it. I have every faith in them as long as hvr is on board.
16:59:49 <divVerent> as that means I am writing nonstandard code
16:59:59 <ReinH> Gurkenglas: what would it do? I can't discern the specification from the type.
17:00:02 <Cale> divVerent: Well, the intention is that if you're making a new implementation of Haskell, you can do it in a somewhat piecemeal way, and there's a standard way to encode which features any given library or piece of code will need.
17:00:02 <bernalex> divVerent: nah. it's just ad-hoc standard rather than report standard.
17:00:16 <ReinH> bernalex: I don't mean to disrespect anyone. I wouldn't want that job.
17:00:39 <divVerent> but every source file ends up having different extensions
17:00:47 <Cale> At least a few of the extensions are even detailed in the standard itself
17:00:52 <bernalex> ReinH: they're bound to be shat on from every angle no matter what they do. just like everyone has done with FAMP, BPP, etc. I have tonnes of respect for hvr, ekmett, etc.
17:01:05 <Gurkenglas> It would do... M.fromListWith (++) . (`zip` map pure [0..])
17:01:23 <Cale> Perhaps we'd do better to call them language features or something rather than extensions.
17:01:38 <divVerent> even then
17:01:50 <ReinH> Cale: There are about 10^32 different possible combinations of extensions (and that is ignoring the NoX pragmas). Finding the right one to call Haskell Prime is something of a challenge.
17:01:58 <bernalex> Cale: but they *are* extensions. that's the whole point.
17:02:01 <Cale> ReinH: Indeed!
17:02:08 <Cale> bernalex: Well, kind of.
17:02:12 <divVerent> how is it less dirty than e.g. in Python importing different division semantics from __future__?
17:02:34 <ReinH> Cale: When I counted I was surprised that there are 108 pragmas
17:02:38 <Cale> divVerent: Well, most of them are conservative.
17:03:00 <Cale> divVerent: In the sense that they won't affect the behaviour of code which would compile without them at all.
17:03:14 <bernalex> Cale: it means that a *haskell compiler* needs to accept *haskell* programs, be they 98 or 10. then compilers are free to implement *extensions* that *extend* haskell. it makes sociological sense to me.
17:03:17 <divVerent> that's true, most just add stufd
17:03:19 <ReinH> bernalex: fully agree
17:03:30 <divVerent> the ones I used certainly only add
17:03:45 <ReinH> bernalex: it was mostly a statement about the inherent difficulty of the problems they are trying to solve
17:04:06 <Cale> I think the Report should just document what exists.
17:04:08 <divVerent> still feels dirty in the sense of "it may differ when standardized and then my code breaks"
17:04:12 <Cale> It shouldn't try to specify what should be
17:04:12 <ReinH> bernalex: (both technical and social)
17:04:33 <bernalex> Cale: I disagree. that *never* works. *ever*.
17:04:41 <Cale> If we want to try to express that something should be some way, then we ought to do the work to make it like that first, see if it's actually good, and then document it.
17:05:10 <Cale> It's hard to write down a standard which is any good if it has zero implementations.
17:05:29 <ReinH> Gurkenglas: I doubt anything provides that, but it looks like you just did.
17:05:34 <bernalex> Cale: I work on a package manager that follows a "specification" that is based on what's the actual case rather than what should be the case. IME this is an absolute political, sociological, and technological *nightmare*.
17:05:49 <Cale> and I think a lot of the success of the earlier Reports comes from the fact that they were indeed *reports* on what the language at the time *was*
17:05:54 <divVerent> ndeed
17:05:57 <divVerent> imagine this
17:06:08 <Gurkenglas> Yep, that came out surprisingly short. Am I missing any order-of-theta inefficiencies?
17:06:08 <ReinH> bernalex: which one do you work on?
17:06:09 <bernalex> so to me the whole "document the real world" idea doesn't actually work in practice with software engineers.
17:06:13 <bernalex> ReinH: Portage.
17:06:16 <divVerent> next Haskell report defines a ghc extension
17:06:24 <divVerent> but in its own words
17:06:34 <divVerent> to be independent from implementation details
17:06:39 <ReinH> bernalex: Ah right. I used to be on the Puppet core team. Portage doesn't suck as much as some of them.
17:06:53 <ReinH> bernalex: Let me tell you about yum.
17:06:57 <divVerent> then a subtle difference is found
17:07:01 <divVerent> who has to change?
17:07:14 <bernalex> Cale: also, like lennart mentioned, having a flat democracy design a language, which is what would effectively happen here, is a... not great idea.
17:07:20 <Cale> bernalex: It doesn't mean that you have to actually get people to use your new implementation extensively (though it's great if you can manage that too), but I think it's pointless to write down a "standard" which absolutely nothing conforms to.
17:07:38 <bernalex> to paraphrase philip wadler: great CS is discovered rather than invented. most programming languages are invented. and *you can tell*, can't you. ;)
17:07:39 <Cale> Well, it's also not necessarily a democracy
17:07:48 <Cale> You just implement something and document that.
17:07:58 <divVerent> in reality, standards are always written in a way nothing yet cpndorms to
17:08:03 <Cale> It doesn't even need agreement from others.
17:08:11 <ReinH> Cale: If GHC had better tools for specifying "dialects" of Haskell, including prelude replacement, on a per-package basis, it would really help imo
17:08:15 <divVerent> usually there are one or more almost correct implementations though
17:08:20 <ReinH> Cale: specifying pragmas in a cabal file isn't quite enough
17:08:44 <Cale> ReinH: Yeah, maybe.
17:09:09 <ReinH> Cale: If it gives the tool to specify *a* dialect, it doesn't need to also enforce a lingua franca
17:09:12 <Cale> Though I guess it also depends on the problems we're actually facing. I don't know too much about non-GHC-based modern Haskell implementations.
17:09:14 <bernalex> overall I think things are pretty nice in haskell/ghc-land both politically and technically.
17:09:29 <divVerent> so typically I see standards as inspired by but abstracted from existing implementations
17:09:42 <Cale> It would help a great deal to get some input from people who are actually trying to implement Haskell.
17:09:47 <ReinH> divVerent: the case is somewhat different here as GHC provides reference implementations for all its pragmas
17:09:56 <bernalex> divVerent: haskell was different in that it's a committee designed language. but today's another story.
17:10:15 <divVerent> like, is there a list of extensions that will LIKELY be in haskell'
17:10:30 <divVerent> so that e.g. other Haskell implementors will likely implement them?
17:10:35 <bernalex> divVerent: the ' committee will probably just survey stuff etc.
17:10:42 <divVerent> in case something happens to ghc or the like
17:10:44 <bernalex> divVerent: it will be based on which ones are most used. and that's not a secret.
17:10:54 <bernalex> everyone knows which are the top used ones you encounter in almost every codebase.
17:11:01 <divVerent> still a concrete list would be nice
17:11:06 <Cale> I'm not sure I agree that even if the extensions are documented in Haskell' that they should necessarily stop being extensions.
17:11:07 <bernalex> I agree. make one!
17:11:09 <nshepperd_> ScopedTypeVariables, i hope
17:11:23 <bernalex> divVerent: really, it's as simple as that. just make one. set up a survey. reach out on café and similar places.
17:11:33 <divVerent> I can't make it as I donpt make the decisions
17:11:36 <bernalex> + do analysis on hackage for the free software portion of haskell
17:11:50 <divVerent> it'd have to be in a place people making a new Haskel
17:11:54 <bernalex> divVerent: I meant the list of most commonly used extensions. a survey detailing that would be very valuable to haskell' & ghc.
17:11:56 <Cale> (H2010 already documents several extensions, just extending that list to include more by specifying what additional extensions do/mean would be good)
17:11:57 <divVerent>  implementation would read
17:12:08 <lamefun> Is there an ExceptT without catch?
17:12:10 <Cale> and then you don't get into the issue of "should we include this or not?"
17:12:24 <Cale> because it's modular -- it won't hurt to document more extensions in a clear way
17:12:39 <divVerent> this list would also be useful so e.g. corporate coding style docs can refer to it
17:12:53 <divVerent> as these extensions would likely also be sufficiently stable
17:13:53 <Cale> divVerent: If you made a list of the unstable extensions, that would be shorter :)
17:14:16 <Cale> Most of them are perfectly okay
17:14:53 <bernalex> I think 99% of them at least are stable
17:15:18 <divVerent> also a good source probably is
17:15:30 <bernalex> which ones "might help you write stupid code" is a different question though. ;)
17:15:37 <divVerent> "any extension used by modules you're importing in most of your projects"
17:15:55 <divVerent> as losing these extensions would break your code anyway
17:16:34 <linduxed> so i've got a function that takes a string
17:16:43 <linduxed> this string needs to conform to some rules
17:17:01 <divVerent> one reason why I'd prefer depending not too much on ghc is that ghc/arm took ages
17:17:06 <linduxed> all of these "rules" are functions that take the string and return a Bool at the end
17:17:08 <divVerent> so likely ghc/nextplatform will also take aged
17:17:23 <divVerent> and maybe someone else is faster then and will only have half the extensions
17:17:27 <linduxed> what would be an idiomatic way to check these rules on this input string?
17:17:34 <linduxed> would i have lots of &&?
17:17:47 <linduxed> or wait... does that even work?
17:17:51 <Cale> Like, what should someone avoid? Probably n+k patterns, they're only there for backward compatibility at this point, but that's not really a big deal. The data parallel Haskell stuff is sadly still in limbo. Some of the things related to overlapping instances are perhaps a bit questionable whether you'd really want to use them, but not unstable at all.
17:17:51 * linduxed checks in ghci
17:18:08 <Cale> Overloaded lists?
17:18:14 <indiagreen> linduxed: «all ($ yourString) [check1, check2, ...]»
17:18:25 <pikajude> what's wrong with overloaded lists?
17:18:34 <Cale> Well, it's just new.
17:18:47 <Cale> ImpredicativeTypes has been semi-broken for a long while, and I don't know whether it's working or not at the moment.
17:19:20 <Cale> (It's one of those things which few enough people ever need that it's more of a burden to support than it's worth)
17:19:22 <pikajude> oh, ok
17:20:28 <linduxed> indiagreen: i suspected something like that would have been the answer!
17:20:29 <Cale> I can't think of many others which are likely to change too much. Perhaps the stuff related to the kind system will still be getting tweaked yet.
17:20:31 <linduxed> indiagreen: thx
17:20:56 <Cale> TransformListComp is maybe scary just because nobody uses it
17:21:03 <Cale> (as far as I know)
17:21:30 <Cale> But it's pure sugar and one of the easiest to document things
17:21:48 <Cale> (the GHC user's guide has a formal translation)
17:22:59 <Cale> At some point I'd like to overhaul the Arrow type class and the translation of proc/do notation to make both of these things more useful.
17:23:28 <Cale> Right now, Arrow kind of undermines most of its potential niche applications.
17:24:13 <Cale> But likely what would happen is there would be an alternate extension for the new translation if that ever did happen :)
17:25:50 <Cale> Can anyone think of anything else which is at all unstable or worth warning people off of? I don't think there are any extensions at the moment which are as bad as LinearImplicitParams was.
18:01:49 <FtheBuilder_> Hello
18:05:07 <pavonia> Welcome
18:05:25 * hackagebot adblock2privoxy 1.4.0 - Convert adblock config files to privoxy format  https://hackage.haskell.org/package/adblock2privoxy-1.4.0 (zubr)
18:19:48 <_jme> Does anyone know how this code snippet make use of list comprehensions as zip function? http://lpaste.net/147817
18:21:27 <_jme> Can't see how that last condition "a !! 1 == s !! 1" actually works
18:21:33 <pavonia> It's not a zip, it's comparing each combination of aminals and sounds
18:21:59 <pavonia> "a !! 1" here means take the first letter of 'a'
18:22:35 <pavonia> Err, the second, it starts with 0
18:22:44 <pavonia> > "abc" !! 1
18:22:45 <lambdabot>  'b'
18:23:29 <_jme> ah I see
18:24:52 <_jme> thans!
18:33:03 <Big_G> > "a" !! 1
18:33:05 <lambdabot>  *Exception: Prelude.!!: index too large
18:45:34 <lamefun> How to open any file or URL in the default application?
18:45:45 <maerwald> xdg-open
18:46:23 <phy1729> Cale: had to be off for a bit, but after reading that link, tabs are wrong in haskell code. I didn't realize that doubly indented things happen (I don't use case statements at all yet)
18:46:32 <lamefun> maerwald, does Windows have it?
18:46:39 <Cale> phy1729: ah yeah
18:46:41 <maerwald> I don't think so
18:47:48 <lamefun> But Windows rocks! It's for PEOPLE!
18:48:00 <maerwald> I couldn't care less, lol
18:48:25 <maerwald> but I doubt you'll get a platform-agnostic solution for that
18:49:14 <geekosaur> cmd /c start
18:49:37 <geekosaur> (or likely just "start")
18:50:31 <geekosaur> and on OS X it's "open"
18:52:12 <maerwald> on linux I currently do: spawnProcess "xdg-open" ["path-to-prog"]
18:52:43 <maerwald> but that doesn't handle the problem when to _execute_ a file instead of opening
18:53:01 <geekosaur> I think only Windows handles that (via "start")
18:53:27 <geekosaur> xdg-open and OS X's open both expect documents
18:53:34 <maerwald> haven't found a generic solution on linux for that. I think people usually examine the file extension or maybe even use libmagic + look at the x bits
18:54:28 <maerwald> however, I find it better anyway to be explicit about it... accidentially executing a shell script is really not nice
18:55:27 <MarcelineVQ> unless it's the script that summon the robot that brings candy
18:56:09 <maerwald> MarcelineVQ: sorry to tell you that, but that robot doesn't exist :/
18:56:20 <MarcelineVQ> Who keeps leaving all this candy...
19:14:44 <bernalex> maerwald: why are you not on xmpp?
20:32:55 <newsham> time to force your christmas thunks
20:34:56 <vrdhn> Hi. got error compiling stack, http://lpaste.net/147821 , any clues ?
20:35:14 <vrdhn> actually compilint trasnformers-base as depdendency
20:37:44 <vrdhn> ah oh .. saw this now :Warning: unable to set locale to UTF-8 encoding; GHC may fail with 'invalid character'
20:37:56 <Cale> Yeah, I was going to say, what's your locale set to?
20:38:20 <vrdhn> Cale, I thought 'C' was good enough till now ... now looking up to do that on Arch
20:40:35 <Cale> Make sure there's a line in /etc/locale.gen which says  en_US.UTF-8 UTF-8  (or similar) and then run locale-gen
20:42:47 <vrdhn> Cale, yup .. got it, retying now .. however i wonder why that error exists in the realm of strictly typed world ... a byte is clearly different from a char (-:
20:43:25 <Cale> Well, yes, I don't know why text I/O would be involved here.
20:45:04 <lamefun> http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Free-Church.html --- how am I supposed to run that?
20:45:16 <lamefun> (a -> m r)? am I supposed to just use undefined?
20:46:03 <meep> no?
20:47:40 <Cale> That's the continuation to run the thing on.
20:47:50 <Cale> It'll pass the result of the computation to that.
20:50:19 <Cale> Free monads are one thing, but I don't think I've ever had the occasion to introduce a free monad transformer. That's a little bit crazy.
20:51:12 <Cale> I would take that as being there more for completeness' sake than anything else.
20:51:43 <lamefun> I want to re-write this: https://gitlab.com/lamefun/dialog/blob/master/library/Dialog/Transformer.hs#L29 -- with it
20:53:29 <lamefun> To get intellectualist-proven versions of Pure, Bind and Lift
20:54:00 <Cale> Ah, fair enough then
20:56:40 <lamefun> What's the most lightweight (in terms of dependencies) web server, with some form of server-webpage communication support?
21:07:05 <nitrixmas> I like scotty
21:07:21 <exio4> Cale: free monad transformers seem useful-ish if you want to abstract out some operations, and need to do reflection-like things on that part of the API
21:11:00 <exio4> Cale: (without "restricting" things.. )
21:13:34 <wedens> I have `ReaderT (r0, r1) m a` and a function `ReaderT r1 m a -> ReaderT r1 m a`. how can I apply this function to the first ReaderT?
21:16:47 <wedens> (without running reader)
21:16:52 <Cale> :t withReader
21:16:54 <lambdabot> (r' -> r) -> Reader r a -> Reader r' a
21:17:00 <Cale> :t withReaderT
21:17:02 <lambdabot> (r' -> r) -> ReaderT r m a -> ReaderT r' m a
21:17:17 <Cale> :t withReaderT snd
21:17:19 <lambdabot> ReaderT r m a -> ReaderT (a1, r) m a
21:17:27 <Cale> hmm
21:17:53 <Cale> actually, probably want to apply it to a function which extends the environment
21:18:00 <Cale> rather than the projection, in this case
21:18:48 <Cale> :t \x -> withReaderT (\v -> (v,x))
21:18:50 <lambdabot> t1 -> ReaderT (t, t1) m a -> ReaderT t m a
21:20:54 <wedens> perhaps I can use profunctor to change function type
21:21:31 <wedens> or invariant functor
21:30:31 * hackagebot simpleirc-lens 0.2.0.0 - Lenses for simpleirc types  https://hackage.haskell.org/package/simpleirc-lens-0.2.0.0 (RickyElrod)
21:33:57 <wedens> Cale: to get back `ReaderT (t, t1) m a ` I'll need to run reader
21:34:38 <Cale> You could just use withReaderT again, but there's nothing wrong about using runReaderT if it gets you there
21:34:51 <Cale> runReaderT is literally function application
21:35:28 <Cale> You're just unpacking the function r -> m a and applying it to the given r
21:35:29 <wedens> yeah, I thought there is some existing combinator to manipulate environment
21:40:10 <lamefun> I think I can't convert my transformer to FT...
21:40:52 <lamefun> Well, I did, but I can't see how to unpack it and run in another monad...
21:42:02 <lamefun> I.e. I have (DialogT IO a), but run it in (EIO a = EitherT EarlyExit IO a)...
21:44:55 <lamefun> i.e. DialogT Bind provides me with (DialogT IO a) and (a -> DialogT IO b), while FT only gives me (DialogA a) and (a -> IO b)...
21:47:29 <lamefun> I just want to go back to my old anti-intellectualist transformer...
22:54:00 <tnecniv> if i have some Just foo, in the repl, what's the best way to get at the foo in the repl setting?
22:54:09 <tnecniv> so i can play with it and feed it to stuff
22:55:05 <lambda-11235> let (Just x) = foo
22:55:39 * hackagebot resolve-trivial-conflicts 0.3.2.1 - Remove trivial conflict markers in a git repository  https://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.2.1 (EyalLotem)
22:55:47 <lambda-11235> Err sorry, that should be > let (Just foo) = x
22:59:06 <tnecniv> lambda-11235 wont that give not in scope?
23:00:24 <lambda-11235> Why would it?
23:02:40 <lambda-11235> > let (Just foo) = fmap sqrt (return 9)
23:02:42 <lambdabot>  <no location info>:
23:02:42 <lambdabot>      not an expression: ‘let (Just foo) = fmap sqrt (return 9)’
23:03:36 <lambda-11235> Hmm, apparently lambdabot doesn't run a repl like ghci.
23:05:24 <lambda-11235> > do {let (Just foo) = fmap sqrt (return 9); return foo :: IO Double} -- Same as ghci since it is basically one do loop
23:05:27 <lambdabot>  <hint>:1:44:
23:05:28 <lambdabot>      Invalid type signature: return foo :: IO Double
23:05:28 <lambdabot>      Should be of form <variable> :: <type>
23:09:18 <exio4> > do { let { (Just foo) = fmap sqrt (Just 9); }; return foo :: IO Double; } 
23:09:20 <lambdabot>  <IO Double>
23:09:29 <exio4> > do { let { (Just foo) = fmap sqrt (Just 9); }; return foo :: [] Double; } 
23:09:29 <Xnuk> > let (Just foo) = fmap sqrt (return 9) in foo
23:09:31 <lambdabot>  [3.0]
23:09:31 <lambdabot>  3.0
23:10:53 <lambda-11235> exio4: thanks. let (Just foo) = whatever without in does unwrap whatever in ghci. That's my main point.
23:11:46 <exio4> lambda-11235: > will evaluate expressions
23:12:05 <Xnuk> @let (Just foo) = fmap sqrt (return 9)
23:12:07 <lambdabot>  Defined.
23:12:12 <Xnuk> > foo
23:12:13 <exio4> lambda-11235: if you want to get some datatype definition in lambdabot's environment, you can use @let
23:12:14 <lambdabot>  3.0
23:12:45 <exio4> @let data Test a = TestN | TestL a [Test a] deriving (Show,Eq,Ord) 
23:12:47 <lambdabot>  Defined.
23:13:08 <exio4> datatype definition, function definition, whatever, statements =)
23:14:14 <Xnuk> @undef
23:14:14 <lambdabot> Undefined.
23:18:10 * lambda-11235 Looks through lambdabot docs and bangs head on table, remembering that he had already read it.
23:39:01 <tnecniv> at what number will i get index too large to !!?
23:39:42 <shachaf> A number greater than or equal to the length of the list.
23:41:03 <demize> Or an index bigger than `maxBound :: Int`
23:41:26 <shachaf> There is no such index.
23:41:52 <thimoteus> why?
23:42:20 <shachaf> maxBound :: Int is the largest Int
23:42:29 <tnecniv> well i could be running into either one of those errors
23:42:38 <tnecniv> and the error is ambiguous in what it means in that regard
23:42:41 <tnecniv> so i wanted to clarify
23:42:51 <Cale> tnecniv: Usually it's best to try to avoid using !! altogether if at all possible
23:42:55 <thimoteus> in retrospect that was obvious
23:43:03 <tnecniv> Cale i cant help it i dont think
23:43:10 <Cale> What operation are you performing/
23:43:12 <Cale> ?*
23:43:13 <lambdabot> Maybe you meant: v @ ? .
23:43:17 <Cale> heh
23:43:21 <tnecniv> Cale i am writing a ray tracer, and i have a list of rays
23:43:45 <tnecniv> and the lib i am using wants a function that takes in x and y coords and spits out a pixel color
23:44:26 <tnecniv> so i do something like:
23:44:27 <shachaf> Either one of what errors?
23:44:28 <tnecniv> getPixelInFlatList list width x y = list !! ((width * y) + x) 
23:44:43 <tnecniv> shachaf well i could either have too many elements (i have a lot of rays)
23:44:48 <tnecniv> or the above function could have a logic error
23:44:59 <Cale> Okay, in that case, you really want to convert the list of lists or whatever it is you're working with into an Array first -- you'll still have the out of bounds issue to deal with then, but you won't have to calculate indices awkwardly like that, and it'll be essentially constant time instead of linear time
23:45:41 <tnecniv> Array is some special data type in Prelude i should look into?
23:45:47 <tnecniv> i'ma  noob, this is my first haskell project
23:45:54 <tnecniv> it's going pretty well. got phong shading going
23:46:27 <Cale> There are a whole bunch of different types of arrays, but perhaps start with Data.Array
23:46:39 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/array-0.5.1.0/Data-Array.html
23:47:25 <tnecniv> cool
23:48:13 <tnecniv> seems like Data.Array is like a map where the keys are enumerable?
23:48:22 <vrdhn> stack Q: how to specify executable name in stack.yaml ? 
23:48:30 <Cale> and dense
23:48:44 <Cale> You can do something like  let imageArray = listArray ((0,0),(width-1,height-1)) pixelList in foo (\x y -> imageArray ! (x,y))
23:50:11 <Cale> (Arrays can be indexed by pairs, and the bounds will be treated as the corners of a rectangle)
23:51:28 <tnecniv> cool
23:52:01 <vrdhn> oh .. it's in .cabal ...
23:55:29 <tnecniv> holy shit
23:55:39 <tnecniv> Cale that like tripled my execution time
23:56:01 <Cale> Are you rebuilding the array every time? :)
23:56:24 <Cale> Make sure that the array gets defined outside of any loops where it'll be indexed repeatedly
23:58:00 <Cale> You should expect a single (!!) costs about half as much as building the array, and then lookups in an array should be nearly instantaneous by comparison with both.
23:58:49 <tnecniv> Cale well every time the tracer runs
23:59:02 <tnecniv> but not every time i query it
23:59:29 <Cale> Perhaps put the code on lpaste.net
23:59:45 <tnecniv> maybe tomorrow. i'm going to bed soon
23:59:51 <tnecniv> thanks for the help though
