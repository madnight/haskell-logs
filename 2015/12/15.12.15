00:00:02 <julianleviston> What’s the best way to transform the data in a tree-like structure into a list? Should I make the tree-like structure an instance of Foldable, and then use foldMap? Ah something tells me I should revisit Foldable…
00:03:07 <jle`> julianleviston: Foldable as toList
00:03:27 <jle`> if you have a tree I think you have an option of how to implement Foldable
00:03:28 <jle`> *has
00:03:31 <julianleviston> jle`: magic. I was just looking at that very function here: https://wiki.haskell.org/Foldable_and_Traversable#Foldable
00:03:40 <jle`> Foldable is kind of like a fancy `toList` kind of typeclass
00:03:59 <jle`> i think you can derive it, actually
00:04:05 <jle`> s/i think//
00:04:24 <julianleviston> toList = foldr (:) []
00:05:06 <julianleviston> foldMap is the sole required method isn’t it?
00:05:16 <jle`> although, this doesn't really answer the question of what the "best way" is, it just is about a nice interface that you can expose your toList with
00:05:17 <MarcelineVQ> foldMap or foldr
00:05:28 <julianleviston> oh yeah. I *do* need to re-visit it.
00:05:30 <jle`> technically toList should be enough too
00:07:39 * hackagebot plot-gtk 0.2.0.4 - GTK plots and interaction with GHCi  https://hackage.haskell.org/package/plot-gtk-0.2.0.4 (VivianMcPhail)
00:07:39 * hackagebot http-client 0.4.26.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.26.1 (MichaelSnoyman)
01:00:24 <wedens> is there traverse that flattens the result?
01:00:27 <wedens> :t fmap join . traverse
01:00:31 <lambdabot> (Monad m, Traversable m) => (a1 -> m a) -> m a1 -> m a
01:02:44 <julianleviston> wedens: isn’t foldable more appropriately that?
01:02:55 <julianleviston> wedens: traversal is supposed to keep the structure intact, isn’t it?
01:03:47 <wedens> is it?
01:04:50 <julianleviston> wedens: A Traversable type is a kind of upgraded Foldable. Where Foldable gives you the ability to go through the structure processing the elements (foldr) but throwing away the shape, Traversable allows you to do that whilst preserving the shape and, e.g., putting new values in.
01:04:57 <julianleviston> wedens: (from haskell wiki)
01:08:47 <MarcelineVQ> > traverse (Just . fst) [("a",1), ("b",2), ("c",3)]
01:08:48 <lambdabot>  Just ["a","b","c"]
01:08:57 <MarcelineVQ> > fmap (Just . fst) [("a",1), ("b",2), ("c",3)]
01:08:59 <lambdabot>  [Just "a",Just "b",Just "c"]
01:09:12 <MarcelineVQ> > sequenceA $ fmap (Just . fst) [("a",1), ("b",2), ("c",3)] -- :>
01:09:14 <lambdabot>  Just ["a","b","c"]
01:09:17 <zipper> Hey I have this issue. When I run `stack install` and try to run my binary from my PATH I get the error Prelude.undefined
01:09:23 <zipper> However when I run it from my stack-work it works fine. What could be the cause?
01:09:59 <julianleviston> zipper: some missing libraries, perhaps? (just a guess)
01:10:15 <julianleviston> zipper: scratch that. 
01:16:09 <wedens> > sequenceA $ fmap Right [[1,2], [3,4], [5]]
01:16:11 <lambdabot>  Right [[1,2],[3,4],[5]]
01:16:56 <julianleviston> :t sequenceA
01:16:57 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
01:17:16 <julianleviston> Cool.
01:24:32 <jle`> wedens: sequenceA (fmap f x) is traverse f
01:24:38 <jle`> er, traverse f x
01:27:07 <wedens> yeah. and I need fmap join . traverse. ok. there is no such function in prelude
01:32:01 <bitemyapp> jle`: ever used trifecta/parsers?
01:32:24 <jle`> dabbled a bit, why?
01:33:28 <bitemyapp> jle`: do you know why I can't have Text inputs to the parser?
01:33:33 <bitemyapp> jle`: only String/ByteString.
01:33:46 <jle`> hm
01:33:52 <jle`> i don't, sorry :|
01:33:57 <bitemyapp> I was porting an attoparsec parser that accepted Text
01:34:03 <bitemyapp> kinda caremad I had to convert it to ByteString
01:34:15 <bitemyapp> because I was sorta planning on making this whole spiel about how ByteString is for BYTES and not TEXT
01:34:26 <ReinH> bitemyapp: that is odd
01:34:28 <bitemyapp> but now I'm the jackass using bytestring for text data.
01:34:31 <bitemyapp> so uh
01:34:36 <bitemyapp> ????
01:34:40 <ReinH> I would say that it's an oversight but Kmett.
01:34:48 <bitemyapp> yeah well
01:35:02 <bitemyapp> not documenting its absence and reason thereof is an oversight
01:35:06 <bitemyapp> even if the design decision was not
01:35:34 <merijn> You can implement Text, I think. Trifecta is generalised in terms of this Rope/Strand thing
01:36:23 <merijn> bitemyapp: Trifecta doesn't parser arbitrary bytes though, it parses utf-8 specifically
01:36:32 <bitemyapp> this doesn't make me less caremad
01:36:47 <ReinH> bitemyapp: FWIW, it uses Data.ByteString.UTF8
01:36:53 <bitemyapp> ReinH: I know, still caremad.
01:37:02 <ReinH> ok
01:37:03 <bitemyapp> readers will not interpret the seeming-contradiction that charitably.
01:37:05 <merijn> bitemyapp: I know, it's not ideal.
01:37:11 <bitemyapp> I have to be uber-explicit
01:37:13 <bitemyapp> or I get emails.
01:37:15 <bitemyapp> Emails.
01:37:29 <ReinH> bitemyapp: submit a patch? ;)
01:37:55 <bitemyapp> no I think my patches irritate the shit out of Ed
01:37:56 <quicksilver> if I had to guess, I'd say that whatever specific problem edwardk was solving at the moment he made that choice, needed the performance of utf8-bytestring
01:38:09 <bitemyapp> I figured, but I'd like to know if Text is impossible
01:38:14 <bitemyapp> or simply inappropriate
01:38:15 <ReinH> hahaha
01:38:19 <bitemyapp> and if either is true, I'd like to know why
01:38:29 <EvanR> utf-8 everywhere
01:38:30 <bitemyapp> if neither is true and is totes possible with the current API
01:38:36 <bitemyapp> I'd like to know _how_ to make it so.
01:38:43 <bitemyapp> because right now I can only get String and ByteString to work.
01:38:53 <EvanR> Text isn't utf-8 so gets thrown under the bus
01:38:53 <merijn> bitemyapp: My semi-educated guesstimate is that it IS possible, but I'm not entirely sure how
01:39:06 <bitemyapp> EvanR: that's a good reason
01:39:12 <bitemyapp> 16-bit unicode is silly
01:39:48 <EvanR> supposedly Text was benchmarked to be better for using utf16
01:40:07 <bitemyapp> well, yes
01:40:14 <ReinH> bitemyapp: I imagine you could write your own Text.Trifecta.Parser with blackjack and Data.Text
01:40:16 <EvanR> but its still doing the char by char traversal to accomodate astral chars
01:40:23 <EvanR> so wtf
01:40:43 <merijn> EvanR: It was the reverse, someone implemented utf-8 Text and it was slower than the current
01:40:51 <merijn> EvanR: So that's now bitrotting
01:40:59 <quicksilver> merijn: no evanr is historically right
01:41:01 <bitemyapp> ReinH: blackjack?
01:41:07 <ReinH> bitemyapp: a futurama joke
01:41:11 <bitemyapp> oh right
01:41:14 <bitemyapp> now I get it
01:41:16 <quicksilver> when Text was first written, the 16bit choice was based on benchmarks
01:41:16 <ReinH> heh
01:41:17 <bitemyapp> ha, humor. yes.
01:41:19 <ReinH> not a very good one
01:41:20 <bitemyapp> well
01:41:24 <quicksilver> and then, quite a few years later someone revisited utf8 text
01:41:27 <bitemyapp> it's 0340 and I have a release coming up for the book
01:41:28 <quicksilver> and still couldn't make it faster
01:41:31 <bitemyapp> so I'm not really a good audience atm'
01:41:45 <EvanR> i dont get why utf16 is faster
01:42:26 <quicksilver> me neither
01:42:27 <merijn> EvanR: manipulating words is faster than bytes usually. Granted utf16 is half words, but I'm not COMPLETELY surprised by that being faster than bytes
01:42:44 <bitemyapp> but uh
01:42:46 <EvanR> well then we should use utf32
01:42:56 <bitemyapp> we should use utf-nativemachineword
01:43:10 <EvanR> or figure out the real reason
01:43:10 <bitemyapp> we'll just bump it once every couple decades
01:43:14 <bitemyapp> it'll be cool
01:43:30 <merijn> EvanR: I wouldn't be surprised if utf32 would be faster
01:43:37 <EvanR> heh...
01:43:40 <merijn> EvanR: But the extra memory might run you out of cache faster
01:43:47 <merijn> It's a delicate trade-off
01:44:04 <merijn> You could access/fetch faster but waste more memory and run out of cache sooner
01:44:14 <merijn> So which is faster would depend on typical use/benchmark choice
01:44:30 <EvanR> i dont get why operating on 32bit words would be faster than 16bit words, or 16bit words is faster than bytes
01:44:48 <bitemyapp> so is the conclusion that there may very well be no reason there isn't a Text implementation for Trifecta
01:44:56 <bitemyapp> but that doing so will require dancing with the Rope/Strand stuff?
01:45:03 <merijn> bitemyapp: My educated guess is yes
01:45:12 <bitemyapp> well there's a problem I'm not fixing
01:45:13 <EvanR> or messing with Text's internal rep
01:45:15 <bitemyapp> this sucks
01:45:35 <merijn> EvanR: Because you can't really fetch bytes from memory, you fetch words and mask out the high bits
01:45:46 <merijn> EvanR: Which is stricly more work than just fetching the word
01:45:52 <bitemyapp> hrm. Parsec and Megaparsec both have Text parsers.
01:45:52 <EvanR> fetch words and ignore part of it
01:45:57 <merijn> EvanR: Word8 is also a machine Word for this reason
01:45:58 <bitemyapp> but the errors are less pretty.
01:46:15 <EvanR> merijn: right
01:46:51 <EvanR> Word8 math would work without the waste of zeroing out 3/4 or 7/8 of the word right
01:47:34 <EvanR> \o/
01:47:45 * hackagebot machines-binary 0.2.0.0 - Binary utilities for the machines library  https://hackage.haskell.org/package/machines-binary-0.2.0.0 (aloiscochard)
01:51:19 <merijn> bitemyapp: The biggest problem I see is that most of the DeltaParsing, etc. seems to refer back to ByteString sources which you don't have with Text
01:58:09 <MarcelineVQ> Is there an issue with unpacking a text to string and converting it to utf8?
01:58:54 <EvanR> or Text to utf8 directly
01:58:56 <MarcelineVQ> the Reducer definition for [Char] uses utf8's fromString, couldn't you define a Text instance and just unpack then pass to utf8's fromString?
01:59:30 <merijn> MarcelineVQ: Sure, but that's slower
01:59:40 <merijn> You copy everything twice
02:00:03 <merijn> First to unpack, second to convert into Rope
02:00:07 <quicksilver> but the answer is there is no problem
02:00:13 <quicksilver> you can clearly use Text by converting it
02:00:27 <EvanR> not to mention youre original text was probably in utf8 to begin with
02:00:34 <quicksilver> the question was if it was sensible/feasible/painful to make trifecta use Text natively
02:00:35 <merijn> EvanR: Sure
02:01:03 <merijn> EvanR: bitemyapp's objection is first telling people "never use ByteString for textual data!" and then showing a parser for text that consumes ByteString
02:01:24 <merijn> EvanR: It's a teaching/clarity issue, not a functionality issue
02:01:31 <MarcelineVQ> hm
02:02:09 <EvanR> you can teach a smart wrapper which guarantees you have utf8 text and is internally a ByteString
02:02:29 <quicksilver> maybe there should, at least, be a wrapper to let you use trifecta on text for clarity of thought
02:02:36 <quicksilver> even if it's slower in practice
02:02:42 <EvanR> the method taken by that ascii package
02:04:21 <EvanR> do use ByteString for efficient moving of binary data, whether or not you go through one form or another of making it type safe / clear to thought
02:34:10 <ReinH> It seems like it would be easy 
02:34:26 <ReinH> ... and possibly intructive to write a Text version of Parser based on the bytestring version
02:34:39 <ReinH> stupid enter key
02:37:47 * hackagebot clock 0.5.2 - High-resolution clock functions: monotonic, realtime, cputime.  https://hackage.haskell.org/package/clock-0.5.2 (CetinSert)
02:41:17 <bitemyapp> ReinH: you think it'd be easy?
02:41:32 <ReinH> is Text missing a similar
02:41:35 <ReinH> wow
02:41:49 <ReinH> sorry, is Text missing a similar API to the one used for BS?
02:42:45 <ReinH> it seems like you don't need much more than uncons
02:43:07 <ReinH> most the rest is Trifecta machinery like the Rope etc
02:43:49 <merijn> On the bright side, my code now seems to work!
02:44:03 <bitemyapp> ReinH: dunno
02:44:09 * ReinH shrugs
02:44:11 <bitemyapp> ReinH: MarcelineVQ tossed me something that may work?
02:44:17 <ReinH> just what it looks like from a casual glance at the source
02:44:19 <merijn> hmmm, I'm confusing #haskell and -blah again
02:45:30 <ReinH> bitemyapp: the heavy lifting is satisfy from CharParsing, which pretty much just needs uncons
02:45:47 <ReinH> and null, length is needed elsewhere, all things Text provides
02:46:24 <bitemyapp> I'll just have to try it, using what MarcelineVQ gave me to get going.
02:46:28 <ReinH> kk
02:46:45 <bitemyapp> I suspect the implementation I come up with won't be efficient, but _shrug_
02:46:56 <bitemyapp> the problem is, if I do
02:46:59 <bitemyapp> I can't put it in the book anyway.
02:47:03 <ReinH> slap a For Pedagogic Purposes Only sticker on it
02:47:11 <bitemyapp> if I put pathological code in the book I'll never hear the end of it.
02:47:13 <bitemyapp> heh.
02:47:20 <bitemyapp> Not sure that'd work.
02:47:30 <ReinH> I mean, I don't see why it would be pathological
02:47:37 <ReinH> maybe a slightly shttier constant factor
02:47:41 <bitemyapp> copying
02:47:53 <bitemyapp> the proposed reducer instances lean on converting
02:48:00 <bitemyapp> or seem to, anyway
02:48:02 <ReinH> k
02:48:07 <Saizan> what would you think of streamlining do-notation so that "do x = foo; y = bar; ..." would be the same as "do let { x = foo; y = bar }; ..."?
02:48:33 <bitemyapp> Saizan: does it change the class of the grammar?
02:51:23 <ReinH> I dunno, people seem to confuse let x = y with x <- y enough already...
02:51:25 <Saizan> dunno, but it doesn't seem much harder to parse than "x <- foo"
02:51:51 <ReinH> although that's more conceptual than syntactical
02:52:48 * hackagebot ghc-session 0.1.2.0 - Simplified GHC API  https://hackage.haskell.org/package/ghc-session-0.1.2.0 (PiotrMlodawski)
02:55:20 <quchen> "let" makes scoping a bit more explicit. "let x=y; y=2" it something other than "let x=y; let y=2".
02:55:27 <quchen> You lose that when you make the lets implicit.
02:55:52 <quicksilver> Saizan: quchen makes a good point
02:56:33 <quicksilver> and what about "let f True = 1; f False = 2;" ?
03:01:18 <Saizan> quicksilver, quchen: true, i guess you could have both forms for expressivity, but then it's probably not worth it
03:02:48 * hackagebot tip-lib 0.2.2 - tons of inductive problems - support library and tools  https://hackage.haskell.org/package/tip-lib-0.2.2 (DanRosen)
03:07:53 <absence> if i have a Traversable of Either, is there a way to get the first Right value? it's not quite "sequence"
03:14:03 <quchen> absence: 
03:14:04 <quchen> :t foldr (\x xs -> case x of Right r -> Just r; Left _ -> xs) Nothing
03:14:06 <lambdabot> Foldable t => t (Either t1 a) -> Maybe a
03:14:50 <frerich> absence: You could implement 'filter' for Traversable (why isn't that there already?) and then use 'listToMaybe' on that to get the first element or Nothing
03:15:05 <quchen> You can't implement filter for Traversable.
03:15:41 <quchen> Traversable is shape-preserving in a sense, filter requires rebuilding the structure in a different way.
03:16:00 <frerich> quchen: Err, isn't any Traversable a Foldable and hence you can define filter using foldr?
03:16:13 <absence> :t find isRight
03:16:14 <lambdabot> Foldable t => t (Either a b) -> Maybe (Either a b)
03:16:17 <absence> hmm
03:16:30 <quchen> frerich: You can define filter for lists with foldr, and for sets, but not for anything.
03:16:53 <frerich> absence: That looks good :-)
03:16:56 <quchen> frerich: Note how you have to use (:) in the definition of filter, or Set.insert, or friends.
03:17:09 <frerich> quchen: Ah d'oh, of course.
03:17:14 <quchen> frerich: If you have only traversable, you have to way to access a "conditional cons".
03:17:28 <absence> frerich: almost
03:17:42 <frerich> quchen: I could stick in the function to use for cons as an argument! :-)
03:18:28 <frerich> quchen: I.e. I do the Haskell equivalent of sticking the fingers in the ears and going 'lalala I can't hear you'
03:18:32 <quchen> Then it wouldn't be a general Traversable anyomre :-þ
03:20:33 <absence> :t either (const Nothing) Just <=< find isRight
03:20:34 <lambdabot> Foldable t => t (Either a b) -> Maybe b
03:21:25 <absence> > either (const Nothing) Just <=< find isRight $ [Left 'a', Right 1]
03:21:26 <lambdabot>  Just 1
03:21:30 <absence> \o/
03:21:40 <MarcelineVQ> neat
03:22:49 <quicksilver> > firstOf (traversed._Right) [Left 'a', Right 1]
03:22:51 <lambdabot>  Just 1
03:24:48 <absence> there's a lens for that
03:24:51 <absence> thanks :)
03:25:00 <MarcelineVQ> "You got questions, we got lenses"
03:26:13 <bitemyapp> MarcelineVQ: "you got prisms, we got probable answers"
03:26:26 <merijn> If you have a problem and you think "I know, I'll use lenses!" you now have morphisms in the category of problems :p
03:26:32 <frerich> > getFirst . foldMap (First . either (const Nothing) Just) $ [Left 'a', Right 1]
03:26:33 <lambdabot>  Just 1
03:26:43 <quicksilver> absence's question is pretty much exactly the kind of thing the optics hierarchy is for
03:26:57 <bitemyapp> down with the hierarchy
03:27:00 <bitemyapp> equality for all algebras
03:27:29 <frerich> quchen: I managed to whip something up with foldMap, I hope you're happy now!
03:27:39 <quicksilver> @remember merijn If you have a problem and you think "I know, I'll use lenses!", you now have morphisms in the category of problems :P
03:27:39 <lambdabot> I will remember.
03:27:41 <MarcelineVQ> look what you've done
03:27:50 * hackagebot clock 0.6.0 - High-resolution clock functions: monotonic, realtime, cputime.  https://hackage.haskell.org/package/clock-0.6.0 (CetinSert)
03:27:52 <quicksilver> frerich: amateur. real foldMappers use ala.
03:28:10 <merijn> bitemyapp: You missed an opportunity for "All algebras matter!" :p
03:28:11 <quicksilver> > ala First foldMap (either (const Nothing Just)) [Left 'a', Right 1]
03:28:12 <lambdabot>      Couldn't match type ‘Maybe b’ with ‘[Either Char Integer] -> t’
03:28:13 <lambdabot>      Expected type: [Either Char Integer] -> t
03:28:13 <lambdabot>        Actual type: Unwrapped (First b)
03:28:25 <quicksilver> back
03:28:26 <quicksilver> bah
03:28:29 <bitemyapp> merijn: dang. sehr gut.
03:28:48 <quicksilver> > ala First foldMap $ map (either (const Nothing Just)) [Left 'a', Right 1]
03:28:49 <lambdabot>      Couldn't match type ‘Either a0 b0 -> c0’ with ‘Maybe b’
03:28:50 <lambdabot>      Expected type: (Unwrapped (First b) -> First b)
03:28:50 <lambdabot>                     -> [Either a0 b0 -> c0] -> First b
03:28:55 * quicksilver gives up.
03:28:56 <frerich> quicksilver: Take your time.
03:28:58 <frerich> :->
03:29:06 <bitemyapp> lens: make lambdabot get impatient with you
03:29:06 <frerich> quicksilver: I never heard of 'ala' before...
03:29:08 <quchen> #haskell is un-golfing a simple problem again ಠ_ಠ 
03:29:18 <bitemyapp> frerich: http://hackage.haskell.org/package/newtype
03:29:20 <quicksilver> frerich: it's the thing which lets you use foldMap via a newtype wrapper
03:29:37 <frerich> Well yeah, Hoogle told me by now, just never heard of it before :-)
03:29:37 <bitemyapp> frerich: http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Iso.html#v:au
03:29:49 <quicksilver> > ala Sum foldMap [1,2,3,4]
03:29:51 <lambdabot>  10
03:29:58 <bitemyapp> sigh, always a bridesmaid preempted by Hoogle, never a bride.
03:47:51 * hackagebot clock 0.6.0.1 - High-resolution clock functions: monotonic, realtime, cputime.  https://hackage.haskell.org/package/clock-0.6.0.1 (CetinSert)
03:48:59 <bitemyapp> oh hey
03:49:02 <bitemyapp> I need that
03:49:10 <MarcelineVQ> dibs
03:49:18 <bitemyapp> MarcelineVQ: nooooo I need it for blacktip!
03:54:17 <hpc> that's easy, just chop the package in half
03:56:44 <fr33domlover> Hello! Q: Can I escape slashes in haddock comments? e.g. this: "This function does this/that to him/her" - I don't want any italics here
03:56:59 <fr33domlover> But \/ doesn't help, it still gets italicized
03:57:01 <saulzar> I already cabal installed it - and I'm not going to share
03:57:40 <bitemyapp> MarcelineVQ: okay I get monotonic clock, you get realtime clock.
03:57:47 <bitemyapp> MarcelineVQ: we'll compromise like hpc said.
04:03:13 <hpc> i am converting a google docs spreadsheet, and i finally fully appreciate the problem frp solves
04:06:31 <fr33domlover> hmmm the \/ seems to work now, probably the browser refused to reload after the fix :P
04:12:51 * hackagebot link-relations 0.1.0.0 - Use web link relation types (RFC 5988) in Haskell  https://hackage.haskell.org/package/link-relations-0.1.0.0 (akrasner)
04:25:33 <jgoux> Hi
04:34:36 <aweinstock> > alaf First foldMap (either (const Nothing) Just) [Left 'a', Right 1] -- quicksilver
04:34:37 <lambdabot>  Just 1
04:37:38 <__uu__> hi
04:41:35 <quicksilver> aweinstock: thanks.
04:41:49 <quicksilver> aweinstock: I can never quite navigate around ala/alaf/au/auf
04:42:45 <quicksilver> annoys me that it's not composable
04:46:20 <anks> hi, i've got a problem with parsing bytes according to a a specification which looks like this [(Count, Length)] and it's self-explanatory. I do it in State monad by replicating single Length-bytes word parsing Count-times, and it doesnt work. If i pass n times (1,Length) instead, it does. Where am i wrong? :|
04:48:31 <anks> https://gist.github.com/89a9b6042578ce8dfe8e
04:51:23 <zaquest> anks, try replicateM instead of replicate
04:51:57 <lyxia> "doesn't work" is too vague
04:52:54 <aweinstock> :t Data.Binary.Get.getWord8
04:52:55 <lambdabot> Data.Binary.Get.Internal.Get Word8
04:53:21 <aweinstock> that might be cleaner than the hand-rolled State thing
04:53:23 <anks> ill try replicateM in a minute, and then try to explicate what exactly is the problem
04:55:13 <anks> it does use getWord8 beneath, but i need something to handle little and bigendian with different length more generally
04:56:02 <anks> sorry it doesnt.. 
04:56:17 <anks> i use Put but not Get;]
05:05:15 <anks> zaquest: replicateM did the job, now Im wondering what pushed me to use replicate .. :]
05:05:25 <anks> thanks, for your help guys 
05:53:46 <joneshf-laptop> can ghc ignore one specific orphan?
05:53:51 <joneshf-laptop> like with a pragma or something?
05:54:24 <bergmark> joneshf-laptop: no, but you can put it in its own module and disable the warning there
05:57:43 <joneshf-laptop> bergmark, my immediate thought was, "But if I move it to its own module, it would be an orphan." I think I need more sleep...
05:57:46 <joneshf-laptop> bergmark, thanks
05:58:07 <tdammers> hmm, I need something like a monadic Alternative
05:58:32 <tdammers> "run a list of actions, return the result of the first one of them that doesn't fail, then stop iterating"
05:58:45 <mels> quit
06:00:21 <bergmark> :-)
06:02:01 <kadoban> tdammers: Isn't that 'asum'?
06:02:05 <kadoban> :t asum
06:02:06 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:02:18 <kadoban> MonadPlus is also Alternative, so seems like it fits.
06:02:54 <tdammers> let me try that
06:04:42 <tdammers> ah, pity
06:04:45 <tdammers> monad in question is IO
06:05:40 <kadoban> Yeah IO doesn't really have success or failure. What does the "fail"ure you're getting look like?
06:06:54 <quicksilver> IO does have failure
06:07:12 <quicksilver> the MonadPlus instance of IO treats throwing an exception as failure doesn't it?
06:07:23 <kadoban> Oh does it have that?
06:07:27 <quicksilver> yes
06:07:40 <quicksilver> but what is tdammers' notion of failure, is the question.
06:07:55 * hackagebot base-noprelude 4.8.2.0 - "base" package sans "Prelude" module  https://hackage.haskell.org/package/base-noprelude-4.8.2.0 (HerbertValerioRiedel)
06:08:10 <tdammers> quicksilver: `fail` :x
06:08:35 <quicksilver> well yes, fail for MonadIO is an exception and the MonadPlus instance will work
06:09:06 <quicksilver> I'm wrong.
06:09:09 <quicksilver> no MonadPlus for IO :(
06:09:17 <tdammers> well, that was the problem
06:09:25 <tdammers> I resorted to manual recursion
06:09:32 <tdammers> more readable anyway IMO
06:11:33 <quicksilver> looks like MonadPlus IO used to be in the mtl
06:16:06 <John[Lisbeth]> Trying to do this in GHCI: let infinibonerboogers = "Boners!" ++ " " ++ "Boogers! ++ " " ++ infinibonerboogers 
06:17:27 <John[Lisbeth]> then do something like take x (infinibonerboogers)
06:17:30 <tdammers> make sure nobody's looking over your shoulder though
06:18:11 <John[Lisbeth]> This is a demo for a lady I am on a date with
06:18:20 <merijn> ...
06:18:45 <John[Lisbeth]> Can't figure out why I can't call it recursively. It hink because I am in interactive mode.
06:20:10 <tdammers> works fine for me
06:21:43 <John[Lisbeth]> dang
06:22:01 <John[Lisbeth]> I'm using ubuntu 14.04 that might be it
06:22:42 <John[Lisbeth]>      lexical error in string/character literal at end of input
06:30:51 <zebastoz> Is there a general rule or best practice for ordering where clauses?
06:31:03 <tdammers> not really
06:31:23 <tdammers> any decent DBMS will reorder them based on internal heuristics anyway
06:31:32 <tdammers> so just write them in the order that makes the most sense
06:31:38 <kadoban> zebastoz: most-to-least important I guess? Same order as I try to use for high-level stuff.
06:31:57 <kadoban> tdammers: DMBS …
06:32:04 <zebastoz> tdammers, talking haskell where definitions, not SQL, huehuehue
06:32:11 <tdammers> oh damjn
06:32:25 <kadoban> But the answer still kind of works anyway XD
06:32:30 <tdammers> in that case; I take the same approach as with top-level definitions
06:32:44 <tdammers> entry point first, dependencies later, and in case of doubt, group related functionality
06:34:21 <merijn> I would agree with tdammers that I just mimic the same order as my top level definitions
06:35:43 <zebastoz> tdammers: sound like you would not re-order them but just use the organic/initial order
06:37:29 <aloiscochard> zebastoz: I order them from most to least dependencies
06:37:32 <tdammers> zebastoz: yes
06:37:57 <tdammers> the idea being that you can read from the top, and stop reading once you are not interested in more details
06:39:06 <zebastoz> both ideas make sense
06:41:14 <tdammers> alternatively, bottom-up also works; then you can learn about the building blocks first, and then proceed through increasing levels of abstractions
06:41:27 <tdammers> "this is our minilanguage, and this is what we build with it"
06:46:40 <jgoux> how can I add external dependencies with stack ?
06:47:07 <jgoux> I added the line in my stack.yaml in the extra-deps section, then I do a "stack solver", but it tells me that "no needed changes found"
06:47:13 <quicksilver> although bottom-up first suggests the use of 'let' :)
06:47:31 <jgoux> but when I build my project the external lib isn't found
06:47:51 <quicksilver> I would urge people anyway to minimise complex nests of lets or where - lift things out to top-level definitions if it gets complex, then you can test and debug them independently.
06:47:51 <jgoux> the package in question is "Data.String.Utils"
06:48:01 <jgoux> from "MissingH-1.3.0.1"
06:48:46 <aloiscochard> jgoux: what is the error message? also, there is #haskell-stack
06:48:47 <tdammers> true; if you need to worry about ordering of where clauses because there are so many of them, then your function is probably way too big
06:48:51 <kadoban> jgoux: What's the error, and can you post your .cabal and stack.yaml files?
06:50:24 <zebastoz> Are there operations that are faster for immutable Vectors than for Mutable Vectors, or is it safe always to go with Mutable for performance?
06:50:36 <jgoux> aloiscochard:
06:50:36 <jgoux> https://gist.github.com/jgoux/1830ca72bc5bb460bb65
06:51:47 <jgoux> I also try `stack unpack MissingH`
06:52:05 <kadoban> jgoux: You should add MissingH to the .cabal file as well, that's what the build-depends section(s) are for.
06:52:08 <jgoux> it downloaded the package; but I have the same error when I build my project
06:52:17 <jgoux> oh :p
06:54:45 <jgoux> kadoban: Is there a reason why we have to reference the dependency both in the .cabal and in the stack.yaml files ?
06:55:42 <jgoux> Is there a command to append it automatically to both files ?
06:56:01 <jgoux> like "stack install MissingH --stack --cabal" ? xD
06:58:48 <kadoban> jgoux: There's some interest in making stuff like that easier, but AFAIK it doesn't exist yet. Usually you don't have to add a bunch of stuff to stack.yaml though, just when you're using dependencies that aren't in the resolver you're using, typically.
06:59:12 <SX> Hi guys. I need some help. I'm writing client for some server and need to make it work with requests from multiple threads. It's request-response communication with initialization phase (like handshake) and I can't send requests before initialization is complete. Request has it's ID. The problem here is that I don't know how to design it.
06:59:58 <jgoux> kadoban: so the resolver contains a list of packages already ?
07:00:14 <jgoux> kadoban: Maybe I didn't need to add MissingH to my stack.yaml :o
07:00:31 <jgoux> Indeed : https://www.stackage.org/lts-3.14/docs
07:00:35 <jgoux> MissingH is there :)
07:00:47 <SX> The request and wait for responce thing.
07:00:50 <jgoux> so the only thing I need is to add it to my cabal file right ?
07:01:11 <kadoban> jgoux: Seems like it, yeah.
07:02:02 <SX> Is it OK to use map with MVar here (Id -> MVar Response)?
07:04:48 <SX> Create init thread, then receiver thread, add MVar lock to disable sending requests before init phase is done etc.
07:06:30 <SX> Is there any best practices in making client-server apps (not Parallel and Concurrent Proggramming in Haskell)? Any good examples?
07:06:41 <jgoux> kadoban: thanks a lot for your help !
07:06:48 <kadoban> jgoux: 'welcome :)
07:18:48 <aweinstock> SX: why use an MVar to block requests before initialization, as opposed to just not accepting requests before initialization?
07:19:11 <aweinstock> (i.e. not starting to accept requests)
07:21:31 <Xandaros> Is a monadic expression considered pure if IO is not part of the monad?
07:22:15 <MasseR> Xandaros: it is considered pure even with IO
07:22:30 <MasseR> IO monad can be considered as a state monad, where the state is world
07:22:38 <byorgey> Xandaros: I have never heard anyone use the word 'pure' that way.  It is kind of a meaningless distinction.
07:23:15 <Xandaros> Well, that's the issue. I'm trying to understand what "pure" means. I've already failed to understand "stateless", I thought maybe "pure" was easier.
07:23:18 <Xandaros> Guess not :D
07:23:58 <byorgey> Xandaros: 'pure' means 'having no side effects'.  The problem is that what counts as a "side effect" depends on your point of view.
07:24:34 <byorgey> from one point of view, computations in the state monad have side effects (they can modify the state).  From another point of view, since this is all modeled using functions and parameter-passing, there are no side effects.
07:25:24 <byorgey> from one point of view, computations in the IO monad have side effects.  From another point of view, they don't, since IO computations are just pure descriptions of imperative actions, and it's the runtime system interpreting them that generates side effects.
07:26:03 <Xandaros> Yeah, so it boils down to the same issue that the term "stateless" has. "statefulness" is not really properly defined
07:26:50 <byorgey> right.  It all depends on the level of abstraction at which you are operating.  (And there is no "right" level to operate at, it depends on the situation, your goals, etc.)
07:26:54 <zebastoz> Is it okay to generally deal with immutable vectors, and only for certain algorithms thaw . f . freeze them?
07:27:52 <byorgey> zebastoz: define "okay"
07:27:52 <aweinstock> :t Data.Vector.modify
07:27:54 <lambdabot> (forall s. Data.Vector.Mutable.MVector s a -> ST s ()) -> Data.Vector.Vector a -> Data.Vector.Vector a
07:28:14 <aweinstock> you don't need to do the freeze/thaw manually, "modify" does it for you
07:28:47 <SX> aweinstock: I want to have some Client entity and a function like "req" to send request AND await response (so return value of this "req" is Either MyError Response).
07:30:08 <zebastoz> I have a library which uses immutable vectors. I would like to speed it up. I am wondering if I should rewrite the entire thing to use Mutable, or to only optimize the slower algorithms.
07:30:41 <aweinstock> SX: what's the underlying protocol? sockets? HTTP?
07:30:47 <Rembane> zebastoz: Start with the algorithms, that will benefit you regardless.
07:31:08 <aweinstock> zebastoz: find the slowest part, try rewriting it with Mutable, *measure* whether that worked
07:31:35 <SX> aweinstock: UDP socket. Snmp protocol.
07:31:57 <aweinstock> zebastoz: also, just try blindly changing from Data.Vector to Data.Vector.Unboxed (and measuring), that might be a quick performance boost
07:32:09 <zebastoz> Yeah, already using Unboxed :)
07:33:47 <aweinstock> SX: which library? network?
07:34:08 <SX> aweinstock: I'm using System.Socket
07:34:30 <zebastoz> I guess my question is: is there a reason to stick to immutable? Is it a matter of style?
07:35:45 <aweinstock> zebastoz: style, clearer code; but if you need to make it faster, you need to make it faster
07:36:05 <aweinstock> keep the immutable version of it around for benchmarking/testing
07:36:28 <aweinstock> (i.e. use quickcheck to verify that both versions behave the same on random inputs
07:36:31 <aweinstock> )
07:36:41 <zebastoz> clear, thanks
07:37:51 <SX> aweinstock: the question is how to organize this "send request and wait for certain response", when there could be lots of concurrent requests. In C I would do this with callbacks (add task to client and let it call my callback on success or error).
07:39:31 <aweinstock> each request/response is on a different socket?
07:40:15 <MasseR> SX: I would probably have a request and response channels. One thread reading from the response channel and another thread writing to request channel
07:40:26 <SX> aweinstock: no, only one socket per client (we're talking about single client here with multiple threads using it to communicate with server)
07:40:49 <MasseR> And as many threads as required for reading the requests
07:41:47 <SX> MasseR: but there's a RequestID, so there should be some routing to the specific caller (thread)
07:42:03 <aweinstock> how important is it for a request/response to be paired? (can the processing be done out-of-order with no ill consequences?)
07:43:08 <aweinstock> SX: have one thread doing the request/response pairs synchronously, give all the other threads a channel to send to it and a channel to receive from it
07:47:54 <SX> aweinstock: so you're talking about a queue. It would result in high response waiting time (UDP has no delivery guarantee) if packet is lost.
07:48:39 <MasseR> SX: could you elaborate on your case a bit more
07:50:57 <raj_> hi
07:51:09 <raj_> anyone here
07:51:14 <raj_> i need help
07:51:19 <Rembane> Maybe. Shoot! :D
07:51:51 <raj_> how build graph in haskall as we use in c++
07:52:19 <SX> Ok, sure. I need to: simultaneously send a lot of requests from multiple threads (so inside one thread it's synchronous: send and wait), receive responses in some other Client thread, read ID of response and give it to thread that sent it (if it's still waiting, if not - drop).
07:52:40 <jgoux> how can I check is a String is a valid Float ?
07:52:50 <jgoux> if*
07:52:51 <SX> This is how I see it.
07:53:29 <jgoux> because if I use read "invalidFloat" :: Float I'll have a runtime error
07:53:58 <exio4> case readMaybe str :: Maybe Float of { Just f -> ...; Nothing; }
07:54:06 <Zekka|Sigfig> raj_: The most common way to represent a graph in haskell afaik is to keep a set of named nodes and a set of edges
07:54:36 <Zekka|Sigfig> data Graph name node = Graph [(name, node)] [(name, name)]
07:54:37 <exio4> case readMaybe str :: Maybe Float of { Just f -> ...; Nothin -> ...; } ; actually
07:54:38 <jgoux> exio4: oh, I didn't know there was a readMaybe :p Thank you !
07:55:17 <exio4> it is in Text.Read
07:55:19 <Zekka|Sigfig> ( (,) gives you an ordered pair so this is a digraph, but you could probably define an unordered pair type too )
07:55:29 <raj_> @zekka can you elaborate with an example please !
07:55:29 <lambdabot> Unknown command, try @list
07:55:42 <exio4> @type Text.Read.readMaybe
07:55:44 <lambdabot> Read a => String -> Maybe a
07:55:55 <Zekka|Sigfig> raj_: Sure. So, using that representation, let’s say our nodes are associated with the data 1, 2, and 3,a nd they’re called “a”, “b” and “c”
07:56:20 <raj_> ok
07:56:40 <Zekka|Sigfig> They’re all connected in a circle — “a” leads to “b”, but “b” doesn’t lead directly to “a” — “b” to “c”, and “c” not directly to “b”, and then “c” to “a”, but “a" not directly to “c”
07:56:58 <Zekka|Sigfig> That gets you these nodes: [(“a”, 1), (“b”, 2), (“c”, 3)]
07:57:12 <raj_> ok
07:57:14 <Zekka|Sigfig> And it gets you these edges: [(“a”, “b”), (“b”, “c”), (“c”, “a”)]
07:57:35 <aweinstock> SX: give the receiver thread a Map from reponse IDs to channels? (one channel for each sender thread)
07:57:42 <Zekka|Sigfig> If you wanted a version of that graph where c is no longer connected directly to “a”, you find the edge in the list and take it out, getting you [(“a”, “b”), (“b”, “c”)]
07:58:01 <Zekka|Sigfig> If you wanted to get rid of a node, you take it out of the node list and then remove all edges involving it
07:58:26 <Zekka|Sigfig> so removing b gets you Graph [(“a”, 1), (“c”, 3)] [(“c”, “a”)]
07:58:48 <raj_> ok i am getting it now 
07:58:53 <Zekka|Sigfig> (Graph is just a type containing both the nodes *and* edges collection)
07:58:57 <Zekka|Sigfig> raj_: OK, good — one other thing
07:59:16 <raj_> yes
07:59:16 <Zekka|Sigfig> It’s not that efficient to do this with lists, because to remove a thing from a list or find it in a list you have to look at everything in the list
07:59:48 <raj_> yeah time complexity will be linear
07:59:51 <raj_> in that case
07:59:56 <Zekka|Sigfig> But it’s efficient to do it with sets because you only have to look at O(log n) of the things in the set — so for a set of 8 elements, you only have to look at 3-4 things, and for a set of 16, only 4-5 — for about 4bil you’re only looking at ~30ish things
08:00:15 <SX> aweinstock: why do I need a Chan then? I could do it with single MVar too. One MVar per request?
08:00:40 <raj_> ok sets will be fine in that case
08:00:50 <raj_> thanks zekka 
08:00:54 <raj_> for the info
08:00:55 <Zekka|Sigfig> Yeah, use a Set or a Map
08:01:24 <Zekka|Sigfig> a Map is like a set of pairs where you can find a pair just by the first thing in it
08:01:27 <SX> aweinstock: and "req" function would make this MVar, send request to server and add ID-MVar pair to Map.
08:01:47 <raj_> like key -> value pair
08:01:49 <Zekka|Sigfig> So if you used a Map then it’s really fast to ask “what is the value associated with this node?” and “what are all the edges leading away from this node?”
08:01:50 <raj_> right?
08:01:53 <Zekka|Sigfig> Yeah, you get the picture
08:02:11 <Zekka|Sigfig> That gets you this: data Graph name value = Graph (Map name value) (Map name name)
08:02:28 <raj_> ok got it
08:02:34 <aweinstock> SX: that implies the Map is global, so you'd need an MVar around the map too, but that should work
08:02:35 <raj_> (Y)
08:02:52 <Zekka|Sigfig> It’s still not as fast for a lot of uses as like a reference-based structure you’d use in C++, but it’s a little easier to manipulate in Haskell
08:03:09 <Zekka|Sigfig> it’s really hard to deal with cycles in data structures in Haskell, even though you can express them
08:03:40 <raj_> yeah i am beginner in haskell to it will take time to undersand all DS
08:03:56 <SX> aweinstock: yeah, I would need some mutable references in Client. It's stateful, unfortunately.
08:04:44 <Zekka|Sigfig> Oh, there is one caveat with the Map
08:04:53 <Zekka|Sigfig> I forgot, you can only associate one value with each key in a Map
08:05:03 <merijn> Zekka|Sigfig: That's trivial to solve, though
08:05:06 <Zekka|Sigfig> So you might actually use data Graph name value = Graph (Map name value) (Map name (Set name))
08:05:10 <merijn> Zekka|Sigfig: "Map Key (Set Value)"
08:05:14 <Zekka|Sigfig> merijn: Yep!
08:05:35 <raj_> ok 
08:05:36 <SX> aweinstock: so one thread for receiver and map for requests is enough, yes?
08:06:17 <raj_> if i stuck at some point,i'll ask 
08:06:29 <raj_> thanks @zekka
08:06:40 <Zekka|Sigfig> No problem, hope this works for your program
08:09:48 <breadmonster> Hello.
08:10:27 <Zekka|Sigfig> breadmonster: Morning!
08:10:43 <breadmonster> Zekka|Sigfig: Wherever you are, but I wish you the same (:
08:11:11 <Zekka|Sigfig> It’s 09:10 in the southwestern United States!
08:11:19 <breadmonster> I was wondering if there are any obvious but unimplemented extensions to ghc's typechecker.
08:11:27 <breadmonster> Winter break has just begun.
08:12:13 <Zekka|Sigfig> (I’m not a GHC maintainer and I try to avoid using too many exotic extensions — so I’m staying silent)
08:16:28 <aweinstock> SX: I think so
08:28:35 <SX> aweinstock: about init phase. It could be that server is offline (rebooting or turned off), so handshake is not done. Maybe use one more MVar for init procedure? And run Init procedure on every new request, if it's required and not already running.
08:29:50 <Xandaros> I have a function `a -> b -> m c` and two values of type `m a` and `m b`. Is there an easy (read: easier than do-block) way to apply these to the function?
08:31:30 <badmash> hello
08:31:42 <badmash> quick question on hello
08:31:46 <verement> join $ f <$> ma <*> mb
08:32:08 <aweinstock> :t \f x y -> pure f <*> x <*> y
08:32:10 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
08:32:21 <Xandaros> verement: Thank you! :)
08:32:33 <badmash> ( \ ( a, b )  ->  a  ::  System.Random.Random g => g ) (System.Random.random (System.Random.mkStdGen  4))
08:32:42 <badmash> this code doesn't work
08:32:50 <badmash> i am not sure why
08:33:30 <badmash> but this works
08:33:31 <aweinstock> SX: is it possible to not start all the threads until the server sends the initial handshake?
08:33:33 <badmash> ( \ ( a, b )  ->  a  ) (System.Random.random (System.Random.mkStdGen  4))
08:33:49 <aweinstock> :t System.Random.random
08:33:50 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
08:34:48 <aweinstock> :t System.Random.mkStdGen
08:34:49 <lambdabot> Int -> StdGen
08:35:00 <aweinstock> :t (System.Random.random (System.Random.mkStdGen  4))
08:35:02 <lambdabot> Random a => (a, StdGen)
08:35:09 <aweinstock> :t fst (System.Random.random (System.Random.mkStdGen  4))
08:35:11 <lambdabot> Random a => a
08:35:56 <aweinstock> badmash: I'm not sure either, probably something subtle involving quantifiers?
08:36:07 <aweinstock> :t (\(a,b) -> a)
08:36:08 <lambdabot> (t, t1) -> t
08:36:19 <aweinstock> :t (\(a,b) -> a :: System.Random.Random g => g)
08:36:20 <lambdabot>     Couldn't match expected type ‘g1’ with actual type ‘t’
08:36:20 <lambdabot>       because type variable ‘g1’ would escape its scope
08:36:20 <lambdabot>     This (rigid, skolem) type variable is bound by
08:36:40 <badmash> aweinstock: i couldn't see any difference between the two versions of the code
08:37:36 <aweinstock> :t (\(a,b) -> a) (((System.Random.random (System.Random.mkStdGen  4)) :: (System.Random.Random g, StdGen))
08:37:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:37:48 <aweinstock> :t (\(a,b) -> a) ((System.Random.random (System.Random.mkStdGen  4)) :: (System.Random.Random g, StdGen))
08:37:49 <lambdabot>     The second argument of a tuple should have kind ‘Constraint’,
08:37:50 <lambdabot>       but ‘StdGen’ has kind ‘*’
08:37:50 <lambdabot>     In an expression type signature: (Random g, StdGen)
08:37:57 <aweinstock> :t (\(a,b) -> a) ((System.Random.random (System.Random.mkStdGen  4)) :: (System.Random.Random g => g, StdGen))
08:37:58 <lambdabot>     Illegal polymorphic or qualified type: Random g => g
08:37:58 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
08:37:58 <lambdabot>     In an expression type signature: (Random g => g, StdGen)
08:38:25 <aweinstock> badmash: check what the ImpredicativeTypes language extension does?
08:39:22 <aweinstock> if this is an actual problem, just specify a more concrete type (e.g. Int, Double), continue on this path if you're interested in learning about typesystems
08:39:30 <badmash> aweinstock: alright, i am just a novice, so i am not so clear on what you are saying, but i will try
08:40:11 <badmash> aweinstock: that's exactly my question -- why does it work for a more concrete type?
08:41:02 <aweinstock> "something subtle involving quantifiers", I don't know more detail
08:41:25 <badmash> aweinstock: in fact, this works -- ( \ ( a, b )  ->  a :: Int ) (System.Random.random (System.Random.mkStdGen  4))
08:41:42 <bashed> I'm trying to use FFI with c2hs. The C code casts an Integer as a pointer. I cannot just retrieve that using c2hs because it is a constant (read #define) value. Basically "#define CONSTANT (Object*) 2"
08:42:32 <badmash> aweinstock: but if you specify a more general type, it doesn't work
08:42:33 <bashed> Do I have any option other than adding a C code that has a function that returns the value. 
08:42:34 <badmash> ( \ ( a, b )  ->  a  ::  System.Random.Random g => g ) (System.Random.random (System.Random.mkStdGen  4))
08:43:25 <badmash> aweinstock: anyway, thanks
08:44:03 <badmash> anyone can help here?  appreciate it very much
08:48:03 <SX> aweinstock: no, Timeout event is a valid response. And this init procedure should be abstracted away.
08:49:15 <quchen> mpickering: Thanks for the Haddock initiative!
09:12:58 <mitchty> anyone know of a haskell jsonapi implementation perchance
09:13:30 <tommd> mitchty: aeson
09:14:03 <mitchty> tommd yeah was just hoping for a bit more of a wrapper, write my own it is then
09:14:36 <Jim__> Hi, is it possible to shorten (x == 5 || x == 6) in any way?
09:14:57 <tommd> mitchty: servant
09:15:31 <pavonia> Jim__: x `elem` [5, 6]
09:15:34 <mitchty> tommd already using it :)
09:15:37 <athan> Jim__: or $ map (x ==) [5,6]
09:15:46 <athan> that too :P
09:15:59 <mitchty> also by jsonapi i mean this thing http://jsonapi.org/format/#introduction
09:16:07 <Jim__> Awesome, thank you!
09:16:50 <athan> > \x -> (getAny $ foldMap (Any . (x ==)) [5,6]) 6
09:16:52 <lambdabot>      Couldn't match expected type ‘Integer -> r’ with actual type ‘Bool’
09:16:52 <lambdabot>      The function ‘getAny $ foldMap (Any . (x ==)) [5, 6]’
09:16:52 <lambdabot>      is applied to one argument,
09:16:55 <athan> erm
09:19:06 <aweinstock> :t [\x -> any (x ==), elem]
09:19:08 <lambdabot> (Eq a, Foldable t) => [a -> t a -> Bool]
09:19:23 <aweinstock> :t any . (==)
09:19:24 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
09:24:49 <wedens> I'm looking for example how to do basic tasty+hspec setup
09:28:22 * hackagebot base-orphans 0.4.5 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.4.5 (ryanglscott)
09:30:23 <Devil69> hello world!
09:31:21 <Devil69> bokachodas... plz reply
09:31:22 <aweinstock> :t alaf Any foldMap
09:31:24 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
09:31:32 <aweinstock> athan: ^
09:31:33 <Devil69> whats this??
09:31:45 <athan> :O!
09:32:04 <aweinstock> :t [alaf Any foldMap . (==), any . (==), elem]
09:32:05 <lambdabot> (Eq r, Foldable t) => [r -> t r -> Bool]
09:32:15 <aweinstock> those're all the same function (I think)
09:32:26 <aweinstock> is there an All newtype?
09:32:28 <aweinstock> :t All
09:32:30 <lambdabot> Bool -> All
09:32:46 <Devil69> guyz....any good links on files in c??
09:34:00 <aweinstock> what do you mean?
09:34:15 <aweinstock> how to read/write files in C?
09:34:22 <Devil69> yeah...
09:34:48 <Devil69> operations using files....or....file related ops
09:34:55 <aweinstock> are you on a unix-y system? if so you can just type "man 2 open" at a shell
09:35:20 <Devil69> no.....m using windows and mint
09:35:50 <aweinstock> mint as in Linux Mint? that's unix-y
09:36:00 <Devil69> how to do it using powershell??
09:36:07 <Devil69> ohh!! okk! got it!!
09:36:10 <maerwald> how is that related to haskell?
09:36:10 <aweinstock> (it's derived from Ubuntu, which in turn is derived from Debian)
09:36:28 <aweinstock> maerwald: I'm not sure, but he started asking about C and I'm trying to be helpful
09:36:47 <Devil69> thanks you #aweinstock
09:36:58 <maerwald> aweinstock: there's probably a channel for the C language
09:37:08 <Devil69> i will catch up with you letter if i had any prob
09:37:16 <Devil69> is there any programming channel??
09:37:45 <maerwald> you can try to google it. This channel is for the haskell programming language
09:38:40 <Denommus> Devil69: ##programming
09:39:15 <Devil69> okk okk!! m sorry if i disturbed you!!! actually a friend of mine told me bout this server and this channel and asked me to consult here about programming. whaterver....thank you guyz ...bubbye :)
09:39:35 <Devil69> thanks denommus;
09:53:31 * hackagebot canteven-log 0.3.0.2 - A canteven way of setting up logging for your program.  https://hackage.haskell.org/package/canteven-log-0.3.0.2 (glasserc)
09:59:49 <athan> Are unboxed tuples "the same (tm)" as a normal data constructor with {-# UNPACK #-} pragmas?
10:00:07 <athan> in terms of memory layout, anyway
10:03:31 * hackagebot snaplet-fay 0.3.3.13 - Fay integration for Snap with request- and pre-compilation.  https://hackage.haskell.org/package/snaplet-fay-0.3.3.13 (AdamBergmark)
10:04:10 <lambda-11235> Why are Foldable and Functor in Data, but Applicative and Monad in Control?
10:04:28 <johnw> athan: you can check that by compiling an example that uses both to Core
10:04:41 <johnw> lambda-11235: mainly historical reasons
10:04:48 <aweinstock> athan: my understanding was that unboxed tuples are passed in registers, and that {-# UNPACK #-} is merely the equivalent of structs
10:05:12 <johnw> aweinstock: on some platforms, structs can be passed in registers if they are small enough (AMD64)
10:05:32 <athan> Hmm okay, looks like I still have some learning to do. Thanks johnw and aweinstock!
10:05:49 <johnw> athan: your best friend in such researches is to compile to and read the resulting assembly
10:06:06 <johnw> they're no telling how GHC versions and architectures might differ on a fine point like this
10:06:57 <athan> read... assembly... :x I'll start with pre-STG core :)
10:07:05 <aweinstock> johnw: read the resulting assembly as in use objdump on the binary?
10:07:16 <johnw> yes
10:07:30 <johnw> or use option flag to generate assembly instead of object code
10:08:06 <aweinstock> I'm familiar with x86 assembly, but I when I try looking through the output of objdumping a GHC-produced binary there's tons of runtime innards, and I don't know how to go about finding the parts specific to my program
10:09:07 <johnw> well, that's true
10:09:29 <johnw> I didn't say it would jump out and you and say, "Hey, look here!" :)  Just that the final answer is there, once you locate it.
10:09:51 <johnw> you might try putting some dumb things into the code as markers, to help you find the right function
10:10:34 <aweinstock> there's lots of symbols that look like "s2[a-z]{2}_info"
10:11:15 <johnw> yes, the naming is unfortunate. I've dealt with that before when using gdb at the assembly level with Haskell programs
10:11:29 <johnw> after reading it for long enough, though, some patterns emerge despite the obfuscation
10:12:39 <aweinstock> for some reason it seems to be using "add    $0xfffffffffffffff0,%rbp" instead of "sub $0x10,%rbp", any idea why that would be?
10:12:57 <aweinstock> (or are they the same opcode, and objdump is just showing it as add?)
10:17:02 <johnw> interesting
10:18:38 <justin_smith> aweinstock: that add will have the same result as the subtract, looks like an optimization to me (but I don't know enough about architectures to tell you it's definitely an effective one)
10:18:40 * hackagebot rev-state 0.1.1 - Reverse State monad transformer  https://hackage.haskell.org/package/rev-state-0.1.1 (DanBurton)
10:21:16 <aweinstock> main calls hs_main, hs_main sets up some (globals?) and then calls real_main, and real_main has calls to things like rts_evalLazyIO, but I can't seem to find the loop in real_main (all the jumping looks like error handling)
10:21:17 <johnw> did athan leave?
10:22:18 <hexagoxel> is there a good way to prevent attribution to some (>>=) method when profiling (due to inlining, i assume) ? i have a case where (>>=) has 10% of total allocs (several GB), which just can't be right.
10:22:39 <aweinstock> and there's an rts_evalLazyIO_, but it's not called, even from rts_evalLazyIO
10:23:40 * hackagebot userid 0.1.2.3 - The UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.3 (JeremyShaw)
10:24:19 <aweinstock> hexagoxel: are you sure that some version of (>>=) isn't allocating a ton?
10:25:04 <capisce> hexagoxel: why can't that be right?
10:25:20 <capisce> could be thunks
10:26:47 <aweinstock> hexagoxel: from https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html:  When you say -fprof-auto to the compiler, it automatically inserts a cost centre annotation around every binding not marked INLINE in your program
10:27:03 <aweinstock> so just declare the relevant definition of >>= as inline, maybe?
10:28:00 <johnw> @tell athan Using ghc-core on https://gist.github.com/3308b1120ba4cfbf3656, the two types are treated similarly for the purpose of a call into C. You should do more tests to see how they'd be laid out in a memory block, for example. 
10:28:00 <lambdabot> Consider it noted.
10:28:02 <hexagoxel> aweinstock, capisce: because (>>=) is not called remotely sufficiently often to make that possible. even each call allocated several thunks
10:28:48 <johnw> @tell athan Never mind my test about the C call, it's not equivalent since I'm not passing whole structures; it will need to be updated to do that
10:28:49 <lambdabot> Consider it noted.
10:29:12 <hexagoxel> aweinstock: i have no INLINEs at the relevant functions
10:45:20 <juri_> I've run cabal install --only-dependencies, but ./Setup configure is still saying the dependencies are missing. What the... ?
10:45:35 <dcoutts> juri_: use cabal configure
10:46:02 <juri_> I have. ./Setup configure still complains.
10:46:41 <dcoutts> juri_: use cabal, you don't need to use ./Setup at all
10:48:38 <juri_> ok, thanks. that seems to do the trick.
10:49:25 <dcoutts> juri_: ./Setup is a lower level interface, that's wrapped by cabal. If for some reason you really needed to use ./Setup, you'd use configure --user in this case. But theres' no need to do so.
10:50:29 <lispy> dcoutts: I actually had a case where I needed to use Setup.hs directly the other day. Updating the Cabal/unix packages on a 7.8.4 install on el capitan.
10:50:43 <lispy> dcoutts: I compiled Setup.hs with 7.10
10:51:12 <lispy> dcoutts: I was grateful to have that as a fallback in that case :)
10:51:23 <dcoutts> fair dos
10:51:42 <dcoutts> lispy: note it's possible to get cabal to select a specific Cabal lib version to use for Setup
10:52:23 <lispy> dcoutts: I'm not sure if that would have helped as I couldn't configure anything priory to getting a new Cabal installed
10:53:01 <lispy> dcoutts: but in general that is a much needed feature
10:53:42 <dcoutts> lispy: though of course these days one can specify deps for Setup.hs scripts, so it's not often needed.
11:34:32 <TheLemonMan> silly question ahead, is 'return' inferred from 'pure' when instantiating a Monad ?
11:35:36 <acertain> :t (pure 1 >>= return)
11:35:37 <lambdabot> (Monad m, Num b) => m b
11:36:10 <acertain> TheLemonMan, what do you mean?
11:36:47 <aweinstock> they're the same by default, and law-abiding instances should define them the same, but it's possible to define them differently
11:36:51 <StoneToad> TheLemonMan: not unless something is new
11:37:00 <StoneToad> you have to defined return = pure in the instance manually
11:37:14 <StoneToad> least all the examples that I've seen show that...
11:37:56 <mpickering> StoneToad: that's not tue
11:37:58 <mpickering> *true
11:38:08 <TheLemonMan> well since a Monad is also an Applicative return and pure do overlap
11:38:08 <StoneToad> oh it's not?
11:38:22 <acertain> TheLemonMan, they should always be the same
11:38:33 <TheLemonMan> and I've just defined the bind operator here and ghc happily accepted it, hence the question
11:38:43 <TheLemonMan> good to know :)
11:38:59 <mpickering> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#Monad
11:39:00 <acertain> but you need to do `instance Monad m where {return = pure; (>>=) = whatever}`
11:39:05 <quchen> TheLemonMan: Since GHC 7.10, `return` has a default implementation `pure` (and you *never* have to implement return again)
11:39:19 <mauke> acertain--
11:39:20 <quchen> Not like liftM, which is still useful, and will forever be so
11:39:23 <acertain> oh, right
11:39:33 <kadoban> So you only need to explicitly define 'return' if you're on old GHC, or want to support it anyway.
11:39:35 <acertain> on older GHC, that won't work though
11:39:37 <quchen> (for defining Functor in terms of Monad)
11:41:33 <the_2nd> with happstack, is there a way to have a static state
11:41:41 <StoneToad> mpickering: ah interesting, I see that ghc 7.10 has a default return = pure definition for monad, I guess I'd only read the prerelease stuff or somesuch
11:42:03 <the_2nd> which changes for each request?
11:44:48 <quchen> the_2nd: Are you in some IO monad? Then you could just use a global MVar
11:44:49 <Cale> the_2nd: of course...
11:46:15 <the_2nd> found this: https://mail.haskell.org/pipermail/haskell-cafe/2012-August/103167.html which also suggests MVar or IO with a file
11:46:27 <the_2nd> never heard of MVar, care to explain? :)
11:48:27 <the_2nd> newMVar GameState
11:48:43 <the_2nd> in each request then takeMVwar, change its state and putMVar afterwards?
11:54:57 <Claus_> Could anyone spot why this error is occuring? http://lpaste.net/147138
11:55:07 <the_2nd> I don't understand how to use this within a ServerPart Response, since it is no IO ()
11:56:24 <Cale> Claus_: strs !! n :: [Char], and str <- strs !! n, so str :: Char
11:56:44 <Cale> i.e. it's selected as one of the characters from that String
11:57:02 <athan> strs :: [String], isn't it?
11:57:04 <geekosaur> <- is not assignment, <- is "for each..."
11:57:10 <geekosaur> (in a list comp)
11:57:16 <Claus_> Oh I see
11:57:22 <Claus_> So I need a let str = ?
11:57:29 <Cale> perhaps
11:57:37 <Cale> I'm very suspicious of this !! n
11:57:39 <athan> a filter might be better
11:57:42 <Claus_> I'll give it a shot
11:57:49 <Cale> also all the length calculation
11:58:00 <athan> Can I use {-# UNPACK #-} pragmas in a GADT?
11:58:00 <Cale> What is this trying to do?
11:58:02 <Claus_> It's a bit ugly, I got chanllenged to write this in 1 line
11:58:16 <lyxia> the_2nd: isn't it a MonadIO?
11:58:19 <Cale> Maybe I can give you a hint :)
11:58:36 <Cale> using length and !! are usually things to avoid
11:58:39 <Claus_> Takes a list of strings that consist of '.' and '#' representing coordinates on a grid
11:59:01 <Claus_> And then returns a list of coords of the #'s
11:59:07 <Cale> right, okay
11:59:17 <Cale> So, one thing you should be aware of is zip
11:59:23 <Cale> > zip [0..] "hello"
11:59:25 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
11:59:28 <quchen> lyxia, the_2nd: it is! liftIO (takeMVar m) :: ServerPart XXX
11:59:31 <Claus_> Oh damn I forgot about zip
11:59:39 <Cale> ^^ this is a handy way to pair the elements of a list with their positions
12:00:08 <Claus_> Ahh ok, Thanks
12:00:16 <Claus_> Completely forgot about zip :')
12:00:31 <Cale> It's quite handy in a list comprehension to be able to write  [ ... | (n,x) <- zip [0..] xs]
12:00:47 <Cale> and have the position n in which x occurred
12:01:54 <Claus_> Ok, I understand that, thanks!
12:06:42 <diphtherial> is <- a general operator in haskell or is it only used in list comprehensions to bind a value to an identifier?
12:06:49 <diphtherial> (not sure if my terminology is correct, very much a newbie)
12:07:33 <diphtherial> and i assume anything that's not a binding has to resolve to Boolean and acts as a filter? and the terms are evaluated left-to-right?
12:08:04 <monochrom> it is a piece of syntax that has different meanings in different contexts
12:08:04 <mauke> to the last question: yes and yes
12:08:18 <geekosaur> it's not really an operator. it's syntax used in a few places, but notably here it has similar meanings in do syntax and list comprehensions
12:08:26 <monochrom> in all contexts it is not an operator
12:08:34 <aweinstock> it has meaning in both do-notation and list comprehension
12:08:42 <athan> it _isn't_ a function
12:08:46 <mauke> and pattern guards
12:08:46 <the_2nd> lyxia, quechen http://pastebin.com/mvqUujrm
12:08:53 <the_2nd> No idea how to get this to work
12:08:58 <aweinstock> (and if you generalize list comprehension to monad comprehension, it means the same thing (>>=) in both)
12:09:01 * hackagebot tries 0.0.4 - Various trie implementations in Haskell  https://hackage.haskell.org/package/tries-0.0.4 (athanclark)
12:09:11 <athan> ahh forgot about that one mauke
12:09:29 <geekosaur> (if you are using the list monad, <- in do is roughly the same as in a list comprehension. if you enable MonadComprehensions, it is pretty much the same thing in both)
12:09:40 * geekosaur is slow
12:09:55 <Cale> glorious dodecaphonic sound
12:10:24 <aweinstock> any do-block can be expressed with list-comprehension syntax?
12:10:33 <monochrom> no
12:10:38 <Cale> aweinstock: Yeah, assuming you turn on MonadComprehensions
12:10:53 <johnw> athan: ping
12:11:10 <geekosaur> do is more general. *many* things can be expressed in MonadComprehensions but I think do remains more general
12:11:15 <athan> johnw: Hey what's up?
12:11:21 <Cale> Does it really?
12:11:22 <athan> I got your last message :)
12:11:31 <johnw> athan: according to the Haskell wiki, "GHC does not support passing structures as values yet.", so this question is moot
12:11:49 <aweinstock> (x >>= f) === [f z | z <- x] -- is this true?
12:11:50 <bitemyapp> johnw: C structs?
12:11:54 <johnw> yes
12:12:01 <bitemyapp> seeing them called structures is really odd to my eyes
12:12:09 <bitemyapp> structures dings the "ML modules" part of my brain
12:12:14 <diogob> Hi there, I’m having some doubts regarding which tool to develop an API client library. I’ve posted a question on reddit: https://www.reddit.com/r/haskell/comments/3wk2m0/wreq_or_servant_for_http_api_client/ any feedback is welcome :D
12:12:16 <bitemyapp> "structs" is what I always see C structs called.
12:12:19 <johnw> athan: I've updated https://gist.github.com/jwiegley/3308b1120ba4cfbf3656, but it doesn't compile
12:12:22 <bitemyapp> not trying to nitpick, just sharing - apologies.
12:12:32 <bitemyapp> johnw: by the by, have you used Trifecta before?
12:12:40 <johnw> bitemyapp: yes, it's my favorite parser library
12:12:45 <bitemyapp> johnw: isn't it great?!
12:12:47 <diphtherial> thank you all for the clarification
12:12:49 <johnw> yes, I love it
12:12:51 <diphtherial> (regarding <-, i mean)
12:12:58 <bitemyapp> johnw: I'm rewriting our parsers chapter to use it :P
12:13:05 <bitemyapp> hopefully this doesn't bite us somehow.
12:13:13 <johnw> it'll just bite my app
12:13:29 <johnw> ;)
12:13:45 * bitemyapp grins
12:13:52 <bitemyapp> but yeah, wow. What a parser.
12:13:54 <bitemyapp> so nice.
12:14:05 <bitemyapp> johnw: legitimate pedagogical reasons for switching over.
12:14:07 <bitemyapp> johnw: not just "
12:14:10 <bitemyapp> "ooh this is nice"
12:14:10 <johnw> you must be excited about 'parsers' then too
12:14:12 <the_2nd> any help with using IO within a ServerPart Response? http://pastebin.com/mvqUujrm
12:14:16 <bitemyapp> johnw: less so, actually.
12:14:18 <athan> johnw: hmm, thank you for working on this
12:14:30 <bitemyapp> johnw: parsers is orthogonal to why we're using trifecta - not educationally relevant.
12:14:41 <johnw> ah
12:14:41 <Cale> the_2nd: btw, you might prefer to use lpaste.net
12:14:43 <bitemyapp> johnw: parsers was in the "cons" column when evaluating the decision with Julie.
12:14:53 <athan> so they can't be passed "as a value", not sure what that entirely means yet :\
12:15:08 <bitemyapp> johnw: don't really GAF about abstracting over parser backends, but we may leverage it anyway. Using Trifecta because of the error messages/highlighting/annotations.
12:15:15 <Cale> the_2nd: it appears you're missing a 'do'
12:15:19 <johnw> athan: for example, a C function void foo(struct bar x), where bar is a structure containing multiple fields
12:15:33 <bitemyapp> johnw: we can make the "parsers are like reading a tape forwards/backwards" more obvious w/ Trifecta's errors than we can Attoparsec/Parsec
12:15:40 <Cale> the_2nd: by the way you laid out the code, it looks like you wanted to write do at the end of line 3 there
12:15:41 <bitemyapp> although Parsec does do a better job than Attoparsec by far.
12:15:48 <johnw> that has no direct equivalent in the Haskell FFI, so you'd need to write an interface wrapper that takes a struct bar *, and turns around and calls foo
12:15:50 <athan> ahhh, so directly as a function call. Hmm, that's interesting. I'm wondering if it's concerned with the size of the structure as a whole
12:15:50 <bitemyapp> the clang-style caret is really important.
12:16:35 <athan> oh woah, okay
12:17:10 <mauke> I wonder ... can't you do that with capi?
12:17:19 <johnw> athan: it's not all that bad, you can use alloca to make a struct bar * for your API wrapper
12:17:39 <johnw> mauke: let me try
12:17:52 <mauke> it may fail spectacularly :-)
12:18:04 <Claus_> Is it considered bad practise to use if .. then .. else in a lambda function or is the only way one can make selections?
12:18:24 <mauke> Claus_: no and no
12:18:36 <the_2nd> Cale, no instance for MonadIO blaze-m,arkup... arising from a use of liftIO
12:18:38 <mauke> if/then/else is syntactic sugar for case/of
12:19:15 <Cale> the_2nd: ah, you're inside Blaze's weird quasi-monad thing
12:19:24 <Claus_> So is case/of the only other way to make selections ina a lambda?
12:19:30 <Claus_> *in a
12:20:05 <Cale> the_2nd: You'll want to move the writeFile up before the "ok"
12:20:19 <athan> lucid ftw!
12:20:21 <Cale> (and make a do-block at that level)
12:20:23 <mauke> Claus_: define "selections"
12:20:24 <johnw> mauke: same error: Unacceptable argument type in foreign declaration: ‘MyTuple’ cannot be marshalled in a foreign call
12:20:31 <mauke> johnw: aw
12:20:47 <johnw> mauke: based on the docs, though, I'd expect this to work
12:20:50 <johnw> maybe I'm not doing something
12:21:09 <Cale> the_2nd: ServerPart is a proper MonadIO, so you should be able to apply liftIO to IO actions to turn them into ServerPart actions.
12:21:10 <mauke> no, the docs just say you can call/import non-functions
12:21:22 <mauke> it doesn't say anything about new supported argument/return types
12:21:37 <athan> Damn, so we can't use UNPACK in a GADT? :(
12:21:39 <johnw> ah, so CTYPE still needs a pointer to such a type
12:22:38 <johnw> athan: does this not work: data MyTuple where MyTuple :: {-# UNPACK #-} Int -> {-# UNPACK #-} Int -> MyTuple
12:22:58 <the_2nd> Cale, no luck yet
12:23:01 <Claus_> mauke: I just mean being able to choose between a few different outputs in a short lambda function
12:23:07 <athan> johnw: Actually, I think my record syntax is borking the parser
12:23:18 <athan> sorry haha
12:23:20 <mauke> Claus_: [resultA, resultB, resultC] !! n
12:23:34 <johnw> athan: also, do you know about -funbox-strict-fields?
12:23:49 <athan> johnw: No! I didn't!
12:24:16 <lpaste_> Cale pasted “No title” at http://lpaste.net/147142
12:24:24 <monochrom> I think you want to add bangs to your Int's for a fair experiment on {-# UNPACK #-}
12:24:24 <Cale> the_2nd: ^^ something like that?
12:25:27 <nitrix> Hi, I'm familiar with the F/A/M relation; but I'd like to know how Functor, Foldable and Traversable are related and if they form a hierarchy.
12:26:20 <the_2nd> Cale I got it to work
12:26:35 <geekosaur> nitrix, https://wiki.haskell.org/Typeclassopedia
12:26:46 <the_2nd> Cale, http://lpaste.net/7389713647649423360
12:27:24 <the_2nd> the "n" can be dropped
12:27:29 <the_2nd> copied from other source
12:28:16 <the_2nd> Cale, final http://lpaste.net/7207192548480122880
12:31:41 <athan> Does strict foldl' evaluate the function's accumulator to WHNF before continuing to the next element?
12:31:51 <athan> the function's result / accumulator*
12:32:36 <Cale> It evaluates its own accumulator to WHNF
12:32:41 <athan> So for something like `foldl' (\acc x -> acc ++ [x]) []`, it would be wasteful to make this strict, wouldn't it?
12:32:43 <athan> hmm okay
12:33:10 <Cale> The worse thing about that is that you're using (++) in a left associated way
12:33:21 <athan> yeah ._.
12:33:30 <Cale> So you'll get O(n^2) time complexity
12:33:39 <athan> Cale: how would you preserve ordering, though?
12:33:48 <Cale> use foldr?
12:34:06 <athan> hrm
12:34:09 <athan> thanks Cale
12:34:16 <Cale> Well, what are you actually computing?
12:34:25 <johnw> Cale: is foldl' (\acc x -> ...) the same as foldl (\!acc x -> ...)?
12:34:30 <Cale> That's the identity function, except that it won't work on infinite lists
12:34:38 <Cale> johnw: no
12:35:02 <mauke> I bet \! is an operator
12:35:15 <athan> ahaha
12:35:16 <Tekkkz> Hello! Website crawling in the background is possible in all methods (post, get etc.) but is it also possible to load websites actively like watching youtube videos via a haskell code?
12:35:33 <Cale> The latter will still build up a large unevaluated expression consisting of those lambdas
12:35:44 <Hafydd> What is ##gn-bans?
12:36:14 <johnw> Cale: ah, foldl' has the seq outside the recursive call to foldl'
12:36:27 <Cale> Hafydd: I was just introduced to this. It's a channel whose banlist is set to a bunch of identities associated with a very annoying user.
12:37:20 <monochrom> that is a cool representation for a banlist
12:37:53 <Cale> Hafydd: e.g. I just did  /mode ##math +b $j:##gn-bans  a couple minutes ago to keep him out of ##math
12:38:04 <athan> Is there a 1-ary function for forcing WHNF, like $! or `seq` but with a single argument?
12:38:28 <the_2nd> how can I read an object from a string that I created with show?
12:38:34 <Hafydd> Ah.
12:38:49 <johnw> :t evaluate
12:38:50 <lambdabot> a -> IO a
12:39:15 <mauke> the_2nd: read
12:39:45 <athan> hmm, thanks johnw
12:40:07 <the_2nd> mauke, tower2 <- read $ liftIO $ readFile "tower1.tmp" ?
12:40:09 <johnw> athan: it's worth thinkig about why that doesn't exist outside of IO
12:40:12 <bashed> How do I run unless when the bool is inside a monad, specifically IO ? 
12:40:21 <johnw> which will give you insight as to why `seq` takes two arguments
12:41:06 <mauke> the_2nd: tower2 <- readIO =<< readFile "tower1.tmp"
12:41:41 <athan> johnw: hmm, but `force` is just 'x `deepseq` x', isn't it?
12:41:52 <athan> hmm that's a tricky one haha
12:42:53 <johnw> x `seq` x is the same as x
12:43:00 <Fuco> I did 'cabal build' on my package I'm developing and it ended with 'In-place registering mpris-0.1.0.0...' ... does that mean other code will now see this library?
12:43:07 <bitemyapp> athan: look at the Core for seq.
12:43:11 <the_2nd> mauke, now I have the problem that I am within a ServerPart Response 
12:43:18 <athan> O_O
12:43:25 <athan> holy beans, okay
12:43:29 <bitemyapp> athan: x `seq` x is just saying, "please evaluate x when you evaluate x" - it's tautological.
12:43:44 <athan> I thought arguments to functions didn't need to be in WHNF
12:43:55 <bitemyapp> they don't?
12:44:03 * hackagebot cblrepo 0.19.0 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.19.0 (MagnusTherning)
12:44:08 <bitemyapp> s/\?\//g
12:44:24 <Cale> athan: they don't
12:44:36 <Black0range> Hey guys, why can't my editors lint program understand that ModuleA.ModuleB is a valid import path if i import it from ModuleA.ModuleC? Not directly haskell related i know
12:44:50 <Black0range> editor as in emacs / atom / anything 
12:44:51 <athan> okay, so x `seq` x would give x, but in whnf, wouldn't it?
12:44:58 <Cale> athan: but if you replace x with x `seq` x, then the latter expression will only be evaluated if x was already going to be evaluated.
12:44:59 <mauke> athan: no, why?
12:45:18 <athan> so (f $ x `seq` x) would first bring x to whnf before `f` can use it
12:45:22 <Cale> no
12:45:23 <athan> ..right? :x
12:45:28 <bitemyapp> okay lets slow down
12:45:32 <bitemyapp> athan: can you skype?
12:45:40 <athan> OH
12:45:40 <Cale> It would apply f to the expression (x `seq` x) which would still not yet be evaluated
12:45:41 <mauke> athan: you're not applying f to x, you're applying f to seq x x
12:45:43 <athan> Cale thank you
12:45:56 <athan> derp
12:46:01 <bitemyapp> seq is a way to tie the evaluation of things together
12:46:05 <athan> lazy in my strictness
12:46:06 <bitemyapp> not trigger evaluation ex nihilo
12:46:59 <bitemyapp> > snd (undefined `seq` undefined, 2)
12:47:01 <lambdabot>  2
12:47:17 <geekosaur> the_2nd, ServerPart is MonadIO, so use liftIO
12:47:28 <bitemyapp> > snd (1, undefined `seq` 2)
12:47:30 <lambdabot>  *Exception: Prelude.undefined
12:47:37 <bitemyapp> we tried to print 2
12:47:42 <bitemyapp> but evaluating the 2 evaluated the bottom
12:47:45 <bitemyapp> then kaboom
12:47:47 <bitemyapp> athan: ^^
12:47:50 <the_2nd> geekosaur, I dont see when exactly in my code
12:48:15 <the_2nd> tower2 <- readIO =<< readFile "tower1.tmp"
12:48:18 <bitemyapp> johnw: I wasn't sure what point you were making with evaluate :: a -> IO a btw
12:48:24 <athan> man I need to rethink my coding o_o
12:48:34 <johnw> bitemyapp: I wrongly attempted to anticipate what he wanted to do, so scratch that
12:48:47 <bitemyapp> athan: I probably don't need to say it, but it'll be in the non-strictness chapter in the book.
12:49:06 <johnw> I use evaluate if all I want to do is "force the length of a list", to cause lazy I/O to read in all elements before leaving a block, for example. But clearly that's not revelant to what he's asking.
12:49:07 <athan> bitemyapp: Man I can't wait to read it
12:49:11 <bitemyapp> johnw: thank you for clarifying. Thought that might be the case.
12:49:12 <geekosaur> the_2nd, you wrap everything after the <- in liftIO so that it runs in IO
12:49:27 <bitemyapp> johnw: wait what
12:50:04 <bitemyapp> johnw: binding over the IO forces the evaluation to happen "earlier"?
12:50:07 <the_2nd> geekosaur, tower2 <- liftIO $ readIO =<< readFile "tower1.tmp"
12:50:22 <the_2nd> geekosaur, no read is marked as ambiguous
12:50:31 <johnw> bitemyapp: xs <- getContents ; evaluate (length xs) ; return xs
12:50:51 <bitemyapp> must be the combination of seq and IO
12:50:54 <geekosaur> the_2nd, did you mean readIO there or are you talking about another read?
12:51:00 <johnw> it has to read all the things the know the length, so laziness is made eager
12:51:28 <the_2nd> I want to get my object back
12:51:36 <bitemyapp> johnw: I guess I hadn't really thought about tying evaluation to IO >>/>>= like that before.
12:51:39 <byorgey> bitemyapp: just reading through scrollback/highlights now.  It turns out I have a highlight for "brent" but not for "yorgey" =)
12:51:45 <the_2nd> I wrote with writeFile "file" $ show obj to a file
12:51:49 <bitemyapp> byorgey: improbable!
12:52:08 <MarcelineVQ> byobyorgey
12:52:20 <the_2nd> geekosaur, to preserve state between requests
12:52:27 <geekosaur> ...bring your own?
12:52:28 <bitemyapp> johnw: is this thing you're doing with evaluate explained anywhere?
12:52:44 <geekosaur> the_2nd, that sounds like a bad idea to me in general
12:52:52 <the_2nd> sure
12:52:53 <geekosaur> unless you have exactly one client
12:52:59 <the_2nd> just wanna try to make it work for now
12:53:18 <geekosaur> in any case that does not address my question to you
12:53:19 <the_2nd> its just a game I render in my browser currently
12:53:32 <the_2nd> no idea whether it will have more than one client per server later on
12:53:34 <geekosaur> you wrote readIO, you claim ambiguity in read.,
12:53:38 <nitrix> > foldMap Product [1..5]
12:53:39 <lambdabot>  Product {getProduct = 120}
12:53:46 <nitrix> > fold $ map Product [1..5]
12:53:48 <lambdabot>  Product {getProduct = 120}
12:53:48 <geekosaur> did you mean readIO or do you have another read somewhere?
12:53:56 <nitrix> Omg, I finally understand Foldable and Monoids!
12:54:00 <nitrix> :D
12:54:09 <the_2nd> geekosaur,     No instance for (Read t0) arising from a use of ‘readIO’
12:54:10 <the_2nd>     The type variable ‘t0’ is ambiguous
12:54:10 <the_2nd>     Note: there are several potential instances:
12:54:34 <geekosaur> then you need to specify the type you expect it to produce
12:54:47 <johnw> bitemyapp: I'm not finding anything beyond the Haddocks for evaluate itself
12:54:52 <geekosaur> it can't guess, and no, it can't generate a type on the fly from the file contents
12:54:55 <the_2nd> geekosaur, I tried :: Tower at the end of the line
12:54:57 <Cale> the_2nd: that means that it doesn't know what type of data you want to parse, so it doesn't know which parser to apply. Adding type signatures, or using the result of the readIO in some more specific way that pins the type down should fix it.
12:55:12 <geekosaur> tha would be wrong
12:55:18 <the_2nd> :D
12:55:19 <geekosaur> it would be an IO something
12:55:28 <mauke> no
12:55:32 <Cale> You'd probably want  :: IO Tower  because you're putting the type signature on the IO action.
12:55:42 <mauke> no, you're not
12:55:58 <Cale> Uh, well, I haven't seen the code, but that's what I assumed that he did.
12:56:20 <geekosaur> [15 20:49] <the_2nd> geekosaur, tower2 <- liftIO $ readIO =<< readFile "tower1.tmp"
12:56:30 <Cale> Oh, I see.
12:56:53 <Cale> Yeah, in that case, it would be some other monad, not IO
12:57:00 <geekosaur> probably not IO at that, because it'll scope over the liftIO as well
12:57:25 <mauke> tower2 <- liftIO (readIO =<< ... :: IO Whatever) should work, though
12:57:36 <geekosaur> so... I think? :: ServerPart Tower ... but what mauke just said is better
12:57:51 <bitemyapp> johnw: I ask because there are chapters in the book on both non-strictness and IO
12:58:31 <bitemyapp> johnw: and I would like to comment on how it seems like your trick lets you seq onto the ephemeral IO structure, but a deeper explanation would be nice.
12:58:47 <johnw> if you Google for "evaluate (length xs)", you'll find several instances where this trick is mentioned
12:59:06 <bitemyapp> johnw: thankee
12:59:13 <bitemyapp> johnw: that only forces the spine, right?
12:59:14 <johnw> I forget where I picked it up from
12:59:19 <johnw> correct, only WHNF
12:59:19 <bitemyapp> so that you are forced to fetch the data
12:59:21 <bitemyapp> cool
12:59:39 <johnw> the spine forcing is coming from the `length' call
12:59:43 <bitemyapp> yeah
12:59:44 <the_2nd> geekosaur, working, thanks
12:59:49 <bitemyapp> we actually covered that earlier in the book
12:59:50 <bitemyapp> much earlier
12:59:55 <bitemyapp> WHNF/NF, length, spine
13:00:02 <bitemyapp> but the non-strictness chapter is going to go further
13:00:03 <hexagoxel> can i have SCC annotations show up in core dumps .. core dump as in -ddump-simpl ?
13:01:44 <bitemyapp> johnw: thank you very much
13:07:14 <ga2arch> bitemyapp: what book are you refering to ?
13:07:54 <Fuco> how can I tell haddock to generate links to other libraries in my documentation? In my .cabal file I have build-depends on dbus, mtl but it doesn't generate links in the type signatures
13:09:30 <geekosaur> ga2arch, http://haskellbook.com
13:10:45 <ga2arch> geekosaur: thanks
13:12:07 <ga2arch> geekosaur: looks like an instabuy
13:26:38 <nh4clo4> Hey! So I'm having trouble with a list expression involving fractions in GHCi
13:27:06 <nh4clo4> I've got `let x = [(x^i) / i | x <- (repeat 3), i <- [1..] ]`
13:27:25 <nh4clo4> and when I try to `take 10 x` GHCi yells at me about not being able to resolve the type
13:28:15 <verement> :t [(x^i) / i | x <- (repeat 3), i <- [1..] ]
13:28:16 <lambdabot> (Fractional t, Integral t) => [t]
13:28:22 <fizruk> nh4clo4: try let xs = ...
13:28:27 <benzrf> not the problem, fizruk
13:28:34 <verement> :t let x = [(x^i) / i | x <- (repeat 3), i <- [1..] ] in x
13:28:34 <benzrf> :t (^)
13:28:35 <lambdabot> (Fractional t, Integral t) => [t]
13:28:36 <lambdabot> (Integral b, Num a) => a -> b -> a
13:28:56 <benzrf> nh4clo4: (^) expects the power to be an Integral, but then you divide by it, which means it has to be Fractional
13:29:02 <benzrf> nh4clo4: there is no common type that's both
13:29:05 <benzrf> :t (**)
13:29:06 <lambdabot> Floating a => a -> a -> a
13:29:15 <benzrf> ^you might want that, if precision isnt your primary goal
13:29:26 <benzrf> actually (**) might work with Rational, if precision is important
13:30:05 <zachk> @type 4 `div` 2 
13:30:07 <lambdabot> Integral a => a
13:30:20 <zachk> not if you use div! :D 
13:30:28 <benzrf> yeah, but that throws away info
13:30:31 <benzrf> probably not what nh4clo4 wants
13:30:50 <zachk> pretty much always throws away info on computers unless you keep track of remainders 
13:31:14 <benzrf> well it does it more blatantly :)
13:31:21 <zachk> or use a Rational type like A/B, 
13:31:24 <zachk> heheh
13:31:47 <nh4clo4> (**) works, but I'm still a little confused as to why
13:32:13 <nh4clo4> Wouldn't (a^b) evaluate to a Num?
13:32:17 <mauke> no
13:32:20 <mauke> Num isn't a type
13:32:28 <athan> :t (^)
13:32:29 <mauke> also, x^i / fromIntegral i
13:32:30 <lambdabot> (Integral b, Num a) => a -> b -> a
13:32:48 <athan> the exponent would need to be an integral
13:32:57 <athan> :t (**) -- vs this
13:32:58 <lambdabot> Floating a => a -> a -> a
13:33:10 <athan> where they need to be the _same_ type, too
13:33:26 <monochrom> always pay attention to types
13:34:43 <nh4clo4> Ok, I think I understand now. Is there a way to use type hinting in a let statement? Or is that bad practice/impossible?
13:34:57 <mauke> it's trivial
13:35:10 <Zekka|Sigfig> You can hint the expression
13:35:11 <monochrom> that is type hinting?
13:35:20 <monochrom> err, what is type hinting?
13:35:31 <Zekka|Sigfig> I’m assuming he means type annotations (using ::)
13:35:50 <benzrf> do you know what nh4clo4 is a he
13:36:01 <monochrom> that can also be done, and not limited to doing it to the RHS expression
13:36:17 <benzrf> *that
13:36:24 <Zekka|Sigfig> monochrom: Really? I didn’t know!
13:36:26 <monochrom> darn it, today is the day of swapping "that" with "what" :)
13:36:33 <benzrf> lol
13:36:43 <mauke> what's that, that's what
13:36:50 <benzrf> something something mandarin something something nà nǎ
13:36:59 <monochrom> let { x :: Num a => a; x=4 } in x+x
13:37:27 <monochrom> note that "let { x = 4 :: Num a => a } in x+x" isn't quite the same
13:37:30 <zachk> > 2 ** 5.2 
13:37:32 <lambdabot>  36.75834735990512
13:37:35 <benzrf> eh i guess nǎ is 'which' not 'what'?
13:38:00 <zachk> @type (**) 
13:38:01 <lambdabot> Floating a => a -> a -> a
13:39:16 * hackagebot mpris 0.1.0.0 - Interface for MPRIS  https://hackage.haskell.org/package/mpris-0.1.0.0 (Fuco)
13:39:17 <monochrom> benzrf, they even have the same tone in Cantonese :)
13:39:24 <benzrf> that sounds awful
13:39:36 <benzrf> wait, are you a native mandarin speaker, cantonese, or something else?
13:39:41 <monochrom> Cantonese
13:39:43 <benzrf> ah
13:40:02 <monochrom> however, in spoken Cantanese, we don't use either "na"
13:40:06 <Majiir> Interesting, so there's no exponentiation with, say, a Rational?
13:40:24 <benzrf> i think i remembered that you spoke chinese and then when i started carefully distinguishing between spoken dialects i unconsciously filled you in as a mandarin speaker
13:40:26 <benzrf> oops
13:40:33 <benzrf> Majiir: i think Rational has a Floating instnace
13:40:44 <t7> 我們要用中文？
13:40:47 <verement> monochrom: in your two let examples, how are they different?
13:41:09 <Majiir> > 2 ** (3 :: Rational)
13:41:10 <lambdabot>      No instance for (Floating Rational) arising from a use of ‘**’
13:41:11 <lambdabot>      In the expression: 2 ** (3 :: Rational)
13:41:20 <monochrom> hmm, I may be wrong
13:41:45 <capisce> t7: there's #haskell.tw for that
13:43:06 <monochrom> they are the same afterall
13:43:16 <verement> ah, ok
13:44:30 <monochrom> top level "x :: Num a => a; x = 4" is not the same as top level "x = 4 :: Num a => a".
13:45:35 <verement> why is that?
13:45:40 <avocado> t7: #haskell.tw 
13:45:54 <monochrom> the second version is vulnerable to the monomorphism restriction
13:46:17 <Fuco> Yay, so I finally published my first haskell package \o/
13:46:28 <Fuco> cabal took me waaay too long to understand :O
13:47:22 <hexagoxel> Fuco: wait for the bot, only then it is irc official :)
13:47:37 <hexagoxel> ah, nevermind
13:47:38 <hexagoxel> :D
13:47:39 <Fuco> :D
13:48:06 <Fuco> I actyakk
13:48:22 <Fuco> eh... when it pinged me I thought travisci failed for some other of my projects
13:48:34 <Fuco> so I look back and what do I see :P was pretty quick
13:49:09 <athan> acid-state doesn't have any kind of caching built in, does it? Every query / update does something to files, right?
13:49:22 <athan> If I wanted a DB witch caching, what would you suggest?
13:50:11 <hexagoxel> seriously, can i not have a comment "-- 1) ..." in my code without haddock closing out on me?
13:50:36 <athan> hexagoxel: I though haddock had a syntax for enumerated lists
13:50:47 <athan> I know * is for unordered lists
13:50:56 <zachk> isn't acid state in memory? 
13:51:00 <monochrom> I don't understand the question.
13:51:11 <hexagoxel> this is not even supposed to be a haddock comment.
13:51:18 <monochrom> "-- 1)" is not a haddock comment, since it is not "-- | 1)"
13:51:31 <ChristianS> hexagoxel: so, what happens?
13:51:41 <athan> zachk: Ahh crud, I think you're right
13:51:45 <athan> and it saves snapshots
13:51:46 <monochrom> I don't know what is "closing out on you"
13:52:00 <athan> :s
13:54:27 <hexagoxel> monochrom: it exits with some parse error (for code accepted by ghc).
13:54:41 <hexagoxel> apparently the enumeration is not the problem, though, sorry.
13:54:49 * hexagoxel will keep investigating for now
13:55:26 <monochrom> time for http://www.vex.net/~trebla/humour/tautologies.html #4
13:55:45 <zachk> does acid-state even persist to disk? I was reading about it last night and I couldn't figure that out... D: 
13:56:34 <Hijiri> it does
13:56:46 <Hijiri> it writes a transaction log
13:56:52 <Hijiri> and you can write checkpoints which just writes the state
13:57:26 <Hijiri> then you can trash the transaction log from before the checkpoint if you like
13:57:29 <hexagoxel> (ah, the "-- #endif" a couple of lines above was causing the issue. meh.)
13:58:40 <hexagoxel> Fuco: btw, have you found your haddock answer?
14:01:05 <monochrom> I see my error. after one "-- |" line, subsequent "--" lines are also haddock comments
14:02:55 <k0ral> Hello
14:03:05 <hexagoxel> it seems you need to comment stuff using "--  " and not just "-- " if you want haddock not to misinterpret random stuff. annoying.
14:03:07 <monochrom> "#endif" may cause a problem or trigger a bug because "#endif#" is a hyperlink
14:03:12 <bitemyapp> monochrom: haddock issues can be a bit rough to figure out at times.
14:03:33 <k0ral> is there a way to derive a Generic instance for a GADT ?
14:03:37 <hexagoxel> imho "-- " should work always, no matter what tooling.
14:03:57 <hexagoxel> but yeah, that would not work, would it..
14:06:47 <dredozubov> k0ral: no, there are no generics for GADTs
14:08:39 <athan> holy crap warp-tls is insanely slow compared to normal warp
14:09:04 <athan> I'm getting ~2k responses/sec, while with tls I'm getting ~75/s
14:09:08 <k0ral> dredozubov: will you really just crush my hopes without suggesting a workaround ? :)
14:09:20 <Fuco> hexagoxel: no, but apparently hackage only rebuilds the docs every day or so, I'll see what pops up tomorrow. 
14:10:51 <hexagoxel> Fuco: my test produced the links without any additional flags; did you --enable-documentation when installing the dependencies?
14:11:41 <Fuco> that might be it, I did not
14:12:25 <dredozubov> k0ral: you can use standalone deriving for some instances or/else you can write those instances by hand if you _really_ want to have GADTs
14:14:01 <Fuco> hexagoxel: yep, works fine now :)
14:14:14 <Fuco> hexagoxel: cool thanks
14:14:38 <monochrom> if rules are for you to break, then hopes are for you to crush.
14:17:02 <k0ral> standalone deriving fails for Generic on GADT
14:17:17 <k0ral> I guess I have to handwrite it
14:17:22 <athan> I wonder if I should use template haskell to generate my comments for my generated code :D
14:17:52 <monochrom> http://despair.com/collections/demotivators/products/hope
14:22:49 <geekosaur> I thought standalone deriving on GADTs was found to be an unsafeCoerce mechanism?
14:22:54 <geekosaur> or potentially so
14:24:33 <k0ral> monochrom: cynical, aren't we ? :)
14:25:56 <athan> guys warp-tls is insanely slow and I can't handle it ._.
14:26:20 <athan> it's like "wow, holy crap how did this get so slow" slow
14:27:46 <dredozubov> k0ral: I repeat, there are no generics for GADTs. At all. I suggest you use another method for deriving your instances(such as standalone deriving) instead of relying on Generic.
14:28:38 <dredozubov> You can't build generic representation of GADTs. There are no way to encode with current state of generics.
14:29:07 <dredozubov> geekosaur: can you elaborate?
14:29:21 <geekosaur> not really, I may be misremembering something
14:29:49 <geekosaur> or maybe it was one of the things that led to roles
14:30:32 <varaindemian> how do I run the interpreter on a .lhs file in emacs (spacemacs)?
14:30:57 <monochrom> is it simply C-c C-l ?
14:31:33 <varaindemian> monochrom: nope :(
14:31:38 <monochrom> then I don't know
14:32:01 <varaindemian> monochrom: on a normal file is M-m m s b
14:32:04 <k0ral> dredozubov: I don't see what prevents from handwriting it
14:32:07 <dredozubov> geekosaur: coercions and gadts are tightly connected, so it's likely the truth in a broad sense
14:32:23 <dredozubov> k0ral: try it
14:32:31 <k0ral> dredozubov: I guess I'll have a try and understand why it is not possible on the way
14:33:50 <dredozubov> there were some papers on the matter
14:33:57 <dredozubov> i don't really remember the names
14:34:22 <k0ral> dredozubov: I mean, maybe not in the general case, but for my case, the GADT's polymorphic type is only an index that has no impact on the underlying value
14:34:27 * geekosaur is also a bit messed up today so might well be confused on some level
14:34:44 <geekosaur> (some people take drugs to achieve states that cold fronts trigger for me...)
14:34:52 <dredozubov> oh wow, i'm building my work project with stack and nix
14:34:58 <dredozubov> nix support is awesome
14:35:17 <dredozubov> now it's time to push it to CI somehow
14:39:18 * hackagebot eventstore 0.9.1.2 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.9.1.2 (YorickLaupa)
14:50:12 <bsermons> what is the '[] mean in the servant docs?
14:50:27 <bsermons> does*
14:50:51 <johnw> bsermons: can you show more of what you're reading?  What it means will depend on where it's used
14:51:46 <bsermons> sorry yea, http://haskell-servant.github.io/tutorial/api-type.html
14:52:06 <bsermons> if you scroll down a bit you see '[JSON]
14:52:32 <johnw> that is a type-level list describing the possible output types
14:52:59 <johnw> so '[] would mean that there is no output, as with Delete '[] ()
14:53:14 <geekosaur> it alludes to that later on the page
14:55:30 <bsermons> oh ok thanks...I wasn't sure how it was different from normal lists
14:55:37 <ga2arch> any news when ghc 8.0 RC will be released ? should by any day from now right ? 
14:55:42 <ga2arch> s/by/be
14:56:18 <geekosaur> no
14:56:29 <geekosaur> code freeze got extended a bit
14:57:02 <ga2arch> geekosaur: ah :( .. january then ?
14:57:13 <geekosaur> I don't know the current plan
14:58:07 <geekosaur> I *think* they are currently in code freeze, but don't know what current timing is. probably ask on ghc-devs list?
14:59:38 <ga2arch> geekosaur: i see, i'll wait the news, i don't *have* to know it, i was just looking forward to play with it during holiday, thanks btw
15:00:30 <geekosaur> they are busily bug-whacking over in #ghc though
15:00:51 <monochrom> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1
15:01:11 <geekosaur> yes, that got delayed a bit though
15:01:41 <geekosaur> they extended the code freeze a bit, so we're at middle of december and they only just froze and started working on bugs
15:01:53 * monochrom has a cunning plan! change that to "expecting RC on Boxing Day"
15:02:38 <monochrom> "Boxing Day Sale! GHC 8.0 RC for $2 only! you save $198"
15:03:31 <dredozubov> *=* as a DLC
15:06:09 <hexagoxel> the extensions are DLC, each single one :p
15:07:08 <ga2arch> hexagoxel: hope there is -XZombies one 
15:19:19 * hackagebot hlibgit2 0.18.0.15 - Low-level bindings to libgit2  https://hackage.haskell.org/package/hlibgit2-0.18.0.15 (JohnWiegley)
15:22:16 <ironChicken> working with the FFI, you sometimes have to use those OR combined flag things
15:22:27 <ironChicken> in RWH, there's this: combineOptions = PCREOption . foldr ((.|.) . unPCREOption) 0
15:22:42 <ironChicken> as an example of packing some values together into a single flag value
15:23:27 <ironChicken> but if i've retrieved a single flag value from some foreign data, how can i determine if one of the flags is set?
15:24:26 <ClaudiusMaximus> \thing -> think .&. flag == flag  -- or something like that, might have the precedence wrong..
15:24:34 <kadoban> ironChicken: AND it together with the flag you want to check, and see if it's 0
15:26:01 <Sindriav_> Does VTY work on OS X?
15:27:02 <Sindriav_> I'm getting "user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))"
15:27:54 <athan> Sindriav_: Are you using stack / cabal to compile, or `ghc --make`?
15:28:21 <athan> because the compiler just needs the `-threaded` flag to give your executable the threaded runtime
15:28:21 <Sindriav_> athan: I'm using `stack ghc -- -threaded File.hs`
15:28:46 <Sindriav_> athan: I figured that much from the error message. Am I passing the argument wrong?
15:28:46 <athan> Sindriav_:  oh huh, I haven't seen that syntax. I think you should add it to your .cabal file though
15:28:54 <athan> under `ghc-options:   -threaded`
15:29:25 <Sindriav_> Ah well, I figured I'd try to only compile that one file
15:29:39 <Sindriav_> athan: Thanks :) I'll make separate project and try that
15:29:41 <athan> Sindriav_:  https://github.com/athanclark/timemap/blob/master/timemap.cabal#L38 :)
15:29:44 <athan> np!
15:55:10 <ironChicken> kadoban: thanks. it looks like this will work, but i'm now having to re-factor several things so it's taking a while to test
16:06:31 <solirc> wedens: From my perspective using tasty+hspec doesn't really buy you something over just using hspec on it's own.
16:10:01 <kadoban> Well the point usually is to be able to combine hspec with other things, like quickcheck, isn't it?
16:10:56 <solirc> kadoban: Hspec is a test framework that comes with support for QuickCheck, HUnit and SmallCheck.
16:11:26 <solirc> kadoban: Note that you technically also could write something that allows you to run tasty tests on top of Hspec
16:11:29 <kadoban> Oh. I thought it was like hunit
16:11:38 <solirc> no
16:12:00 <kadoban> I've only even used QuickCheck and HUnit, heh. Good to know.
16:49:00 <zachk> just installed regex-tdfa, supposed to super fast, and too a look at regexes again, been a long, long time....
16:49:13 <zachk> and I am seriously thinking about going back to one of my other solutions 
16:51:07 <athan> zachk: make a regex engine! :D
16:52:13 <pavonia> zachk: What is your use-case? Have you considered using e.g. attoparsec instead?
16:54:47 * hackagebot git-repair 1.20151215 - repairs a damanged git repisitory  https://hackage.haskell.org/package/git-repair-1.20151215 (JoeyHess)
16:59:00 <obadz> is there such a thing as class Foo a <= Bar a ? 
16:59:05 <obadz> with the <= pointing left ?
16:59:25 <julianleviston> that means less than or equal to
16:59:31 <julianleviston> oh sorry you said class.
16:59:33 <bitemyapp> I don't think that would pass the parser.
16:59:44 <obadz> http://blog.functorial.com/posts/2015-12-06-Counterexamples.html
16:59:51 <obadz> this blog post has them all over
17:00:17 <julianleviston> how funny
17:00:20 <shachaf> Yes, in PureScript.
17:00:24 <shachaf> Not in Haskell.
17:00:28 <obadz> ah
17:01:06 <obadz> everything else seems to be valid Haskell so hard to tell
17:02:27 <bitemyapp> obadz: https://github.com/purescript/purescript/wiki/Differences-from-Haskell
17:10:49 <obadz> why is NonEmptyList not an Applicative? pure x = NonEmptyList x [] ?
17:11:23 <julianleviston> Is there (in existence) any code (such as a library) that will allow me to traverse arbitrary Haskell typed data in all the ways that are possible given the shapes of Algebraic Data Types and the types that exist in Haskell? I’m thinking of something such as Lens, or Zipper, but where the data and type are not known in advance… ? as in… I want to create arbitrary Zippers, basically,… because my program needs to b
17:11:24 <julianleviston> able to allow the user to traverse these arbitrary structures, and modify the data in them.
17:11:34 <shachaf> Which one? https://hackage.haskell.org/package/semigroups-0.18.0.1/docs/Data-List-NonEmpty.html ?
17:11:54 <julianleviston> Note I haven’t used Lens very much, though I’m reasonably sure I understand it… and I haven’t used Zipper at all in Haskell… only in clojure.
17:12:12 <obadz> shachaf: conceptually. that blog post claims that NonEmptyList can't be made into an applicative
17:12:25 <athan> obadz: I thought it was, via zipping, not sure though
17:12:27 <obadz> oh wait
17:12:34 <obadz> it said "NonEmpty"
17:12:40 <obadz> not NonEmptyList
17:12:52 <obadz> sorry am blind
17:12:54 <athan> oh wait
17:12:58 <athan> no it's cartesian
17:13:25 <athan> obadz: http://hackage.haskell.org/package/semigroups-0.18.0.1/docs/src/Data-List-NonEmpty.html#line-261
17:13:32 <obadz> actually NonEmpty is NonEmptyList in that blog post
17:14:06 <julianleviston> Is what I want Comonads?
17:15:09 <shachaf> I'm not sure why it wouldn't be.
17:15:13 <julianleviston> Though… the constraint of “any abitrary structure” is doing my head in. Normally you’d write a Zipper for a specific structure, but I want a way to automatically Zipper data of *any* type.
17:15:15 <shachaf> paf31: Do you know?
17:16:51 <joehillen> To any lens experts out there, I have a "[Tag]" and a "Tag" has a getter "tagValue", tagValue returns Text, I want to get a "[Text]" but whenever I use "traverse" or "folded" I get a single Text that is all the tagValues concatenated. 
17:17:23 <paf31> shachaf: construct zippers for any type?
17:17:46 <shachaf> ?
17:17:52 <paf31> what was the question?
17:17:58 <shachaf> Why NonEmpty isn't Applicative.
17:17:59 <paf31> oh, why is NonEmpty not applicative?
17:18:02 <paf31> sorry :)
17:18:12 <L8D> was anyone else confused by the recent release of Hasql?
17:18:13 <paf31> well it is with the zippy Apply
17:18:34 <paf31> i meant with the one you get from regular List by restricting
17:18:41 <mutantmell> has anyone here had a chance to play around with the TypeInType extension (on GHC head)?
17:18:52 <julianleviston> paf31: any ideas about my crazy question? :)
17:18:54 <paf31> the cartesian one. i should make that clearer
17:19:16 <paf31> julianleviston: not really my area of expertise, but comonad certainly sounds relevant
17:19:25 <julianleviston> paf31: I’m currently reading “Scrap your zippers - A generic Zipper for Heterogeneous types"
17:19:38 <julianleviston> paf31:  thanks… know any resources to educate myself on these things well?
17:19:43 <paf31> you can construct a zipper on lots of functors by building them up from a few primitives
17:20:02 <paf31> julianleviston: comonads?
17:20:12 <verement> joehillen: why not just map tagValue ?
17:20:17 <julianleviston> paf31: yeah, and/or zippers… tho this paper seems pretty good so far.
17:20:23 <paf31> i like this post https://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/
17:20:26 <julianleviston> paf31: actually don’t worry about zippers.
17:20:31 <julianleviston> paf31: thanks :)
17:20:33 <paf31> but im still learning myself
17:20:51 <shachaf> joehillen: toListOf (folded . tagValue) yourTags?
17:21:09 <shachaf> joehillen: Or map (view tagValue) yourTags, of course.
17:21:38 <shachaf> paf31: Are you sure the cartesian product instance doesn't work?
17:22:53 <paf31> doh, yes it does :(
17:22:59 <julianleviston> lol @ “The natural big little idea that I’m going to discuss then...”
17:23:04 <julianleviston> That’s awesome.
17:23:10 <paf31> i dont know why i convinced myself that worked
17:23:12 <julianleviston> a big little idea. 
17:23:21 <paf31> i'll just remove that line
17:23:28 <julianleviston> but it’s actually true. It *is* a big little idea. :)
17:27:35 <joehillen> shachaf: perfect, thank you!
17:33:01 <bitemyapp> paf31: zipper...representable functors?
17:33:38 <paf31> bitemyapp: sorry?
17:34:15 <bitemyapp> paf31: oh, hypothesis of tel/sdbo's from awhile ago.
17:34:27 <obadz> paf31: so hmm.. NonEmpty is an applicative?
17:34:38 <obadz> s/is/can be made/
17:34:47 <paf31> yes in at least two ways
17:35:15 <paf31> both the zippy and regular applicatives from [] seem to also be valid instances for NonEmpty
17:35:21 <obadz> ok, blog post confused me then :)
17:35:31 <paf31> yes sorry, it should be fixed now
17:36:51 <obadz> paf31: ah great, thx.
17:48:47 <julianleviston> :t mapAccum
17:48:48 <lambdabot>     Not in scope: ‘mapAccum’
17:48:48 <lambdabot>     Perhaps you meant one of these:
17:48:48 <lambdabot>       ‘IM.mapAccum’ (imported from Data.IntMap),
18:02:56 <sgronblo> Are FP ADTs equivalent with sets?
18:06:45 <rvxi> hey
18:07:12 <geekosaur> sgronblo, I want to say "no" but am not sure if there's some usage here I'm not familiar/experienced with
18:07:13 <rvxi> has anyone figured out a good way to use haskell with amazon AWS lambda?
18:07:46 <rvxi> seems like at a minimum it should be possible to use fay/ghcjs/haste + transpile to javascript although i haven't seen any reports
18:07:56 <rvxi> and it would be nice if there was a more elegant way to do it
18:13:25 <buckmaster> hey, does anyone use Database.SQLite.Simple in the repl much?
18:14:03 <buckmaster> I'm wondering if there's an easy way to be able to run queryes without having to add type signatures to everything. The FromField and FromRow constraints mean I have to be explicit about every query type, which is slightly annoying
18:14:30 <buckmaster> do I need to just define a type synonym for each query (combination of rows) I might want to use?
18:23:59 <sgronblo> geekosaur: if so, why not?
18:24:24 <geekosaur> sgronblo, because they are much more than sets?\
18:31:17 <geekosaur> that said, there's the viewpoint where *any* type is a set; in that case, "is it equivalent to a set" is trivially true. I am not sure it's useful though, outside a restricted viewpoint
18:34:38 <dolio> What set is: data PP = Roll ((PP -> Bool) -> Bool)
18:34:51 <L8D> how do I tell stack to use hspec 2.2 over 2.1 (the version used in lts-3.2)?
18:34:56 <athan> Hmm, it appears that warp on my machine has a max-throughput of ~1MB/s. Can anyone here compare?
18:35:29 <L8D> I have hspec >= 2.2 && < 3 in the build-depends field of my test suite
18:36:16 <athan> L8D: You can use an entry like this: https://github.com/athanclark/tries/blob/master/stack.yaml#L5
18:36:19 <L8D> when I add "hspec-2.2.1" to the extra-deps in my stack.yaml, stack just ignores it and runs into "failure when adding dependencies: hspec-core: (==2.2.1), latest is 2.2.0 but 2.1.10 found"
18:36:20 <athan> in your stack.yaml :)
18:36:31 <athan> oh huh
18:36:56 <sgronblo> geekosaur: hmm, how are types more than sets?
18:36:58 <L8D> it seems like stack ignores the dependencies of the executable and test suite when solving for dependencies
18:37:10 <L8D> and if I manually add different versions, it still ignores them
18:37:28 <sgronblo> i thought it was just unions + cartesian products?
18:37:36 <geekosaur> I guess you're using that viewpoint I just mentioned? seems to me that it's a good way to miss the forest for the trees
18:38:01 <athan> L8D: What does your cabal file look like? Can you paste it?
18:38:05 <athan> in lpaste I mean
18:38:08 <geekosaur> that said I am no type theory wonk, which is why my first response
18:38:16 <geekosaur> [16 02:06] <geekosaur> sgronblo, I want to say "no" but am not sure if there's some usage here I'm not familiar/experienced with
18:38:48 <L8D> athan: https://gist.github.com/L8D/5ce5e1f5cb7f507a63b8
18:38:56 <athan> endo-sets
18:39:17 <mgsloan> L8D: Note that's an error about hspec-core, not hspec
18:39:28 <mgsloan> You probably also need to specify a version of hspec-core in your extra-deps
18:39:29 <sgronblo> geekosaur: can you think of some other viewpoint than any type being a set?
18:39:49 <athan> ah!
18:40:04 <L8D> mgsloan: well, it's also complaining about hspec-discover and hspec-expectations
18:40:16 <L8D> mgsloan: do I need to list all of those in my cabal file?
18:40:26 <zoku> is it safe to share handles and TBMChans between threads?
18:40:32 <mgsloan> No, but you do need to pick versions of those in your stack.yaml
18:40:44 <mgsloan> It doesn't suggest more additions to extra-deps?
18:40:57 <geekosaur> the set viewpoint is viewing a type as defined by its possible values, which looks to me like a view from "inside". a view from "outside" would ignore values as defining it and see them instead as consequences of the type
18:41:15 <L8D> http://lpaste.net/8754011933369171968 <- full error message when running "stack test"
18:41:29 <geekosaur> again, unless you are using a different definition and do not see fit to explain
18:41:44 <geekosaur> but instead assume that, notwithstanding my repeated statements, I am somehow expert in that viee
18:41:50 <L8D> stack solver says "No needed changes found"
18:42:02 <dolio> You cannot model types as sets, at least if your types are like the ones in Haskell.
18:42:09 <dolio> This is kind of a famous result.
18:42:10 <typedeph> how do I convert this ugly IO code to a one liner, someone a while back here showed me an fmap solution: http://lpaste.net/147154
18:42:20 <dolio> If you restrict your types a lot more than Haskell does, they can be sets.
18:43:01 <athan> dolio: Can you give an example of a non-set type?
18:43:20 <mgsloan> L8D: Puzzling that stack solver says that.  Is this project public?
18:43:27 <dolio> data PP = Roll ((PP -> Bool) -> Bool)
18:43:57 <mgsloan> L8D: How about adding "hspec-core-2.2.1", "hspec-discover-2.2.1", and "hspec-epectations-0.7.2"
18:43:58 <L8D> mgsloan: no. perhaps it's because I have packages: '.'
18:44:03 <athan> I thought function spaces could be modeled by power sets
18:44:06 <zoku> http://lpaste.net/5494306397665361920
18:44:14 <zoku> I'm trying to setup a bi-directional channel through irc-client
18:44:18 <mgsloan> L8D: That should be fine if you only have one package in your project
18:44:24 <L8D> mgsloan: instead of packages: ['.', 'run-stinch', 'test-stinch']
18:44:38 <mgsloan> L8D: Usually this wouldn't be such a pain, but it looks like hspec forces exact versions of its deps
18:44:40 <zoku> I'm recieving messages just fine, but when i writeTBMchan to the message channel, it's never picked up by the irc-client
18:44:41 <L8D> mgsloan: but yeah it's just the starter code when running "stack new" I believe
18:44:44 <zoku> anyone used this library much?
18:44:51 <dolio> athan: T -> Bool is presumably the power set of T, right?
18:44:53 <L8D> mgsloan: I understand the need for adding explicit dependencies
18:45:02 <L8D> mgsloan: it's just that I'd expect stack solver to tell me to add those
18:45:31 <athan> dolio: Yes, or really the power set of (T, Bool), right?
18:45:37 <athan> the given inputs that could cause the outputs
18:45:39 <athan> oh crud
18:45:43 <dolio> So PP is a set that is its own double power set.
18:45:51 <athan> hmm
18:46:22 <L8D> mgsloan: when I do add the explicit dependency versions, I get a "hspec-expectations: needed (==0.7.2.*), latest is 0.7.2, but 0.7.1 found"
18:46:37 <L8D> mgsloan: I can be lazy and change the version, but is there a way to use the newer version within the stack sandbox?
18:48:22 <rvxi> has anyone tried to benchmark hmatrix-gsl-stats
18:48:22 <rvxi> vs. random-fu vs. any other samplers recently?
18:51:21 <mgsloan> L8D: My bad, typo in the hspec-expectations dependency
18:51:50 <mgsloan> This reveals a bug though, apparently typos in extra-deps aren't detected 0_0
18:54:04 <mgsloan> L8D: Do you want to open an issue about stack not being as helpful as normal in this circumstance?  I can open it, if not
18:54:14 <mgsloan> I'll open an issue about the typo in extra-deps bug
18:54:23 <L8D> I'll make one. And good catch!
18:55:29 <L8D> actually I'm not sure what I should detail in the ticket... might be better if you made one?
18:55:55 <L8D> mgsloan: but not being helpful, do you mean with the typo or with solving extra-deps for the test-suite?
18:57:35 <mgsloan> I'm surprised by two things: that "stack test" isn't suggesting more extra-deps, and that "stack solver" isn't helpful
19:02:15 <mgsloan> L8D: I've opened https://github.com/commercialhaskell/stack/issues/1521
19:26:53 <athan> I feel like there could be operational tests like quickcheck, like a convergence between benchmarking and testing
19:27:19 <athan> take an audio caching library, for example - for all waveform inputs, playback should never cache-miss
19:38:52 <lingxiao> hey all is there a way to sample a value from 0 to 1 uniformly  
19:39:02 <lingxiao> w/o using uniform ?
19:39:21 <lingxiao> the reason is because i want the following code:
19:39:55 <lingxiao> toss p = (\q -> q <= p) <$> uniform 0 1  :: Double -> RVar Bool
19:40:10 <lingxiao> to have signature   :: MonadRandom m => Double -> m Bool
19:40:42 <Hijiri> If the built in random instance for Double is not uniform, you could generate a random Int from 0 to n, then divide by n
19:40:56 <Hijiri> (after converting them to Double)
19:41:15 <Hijiri> with a big n
19:41:25 <lingxiao> i tried that but the n has to be really big
19:41:43 <lingxiao> in my application im doing lots of things like toss coin that has heads with probablity 0.0000001 for example
19:41:56 <Hijiri> you could just use maxBound :: Int
19:41:57 <lingxiao> really low but it really matters that it does come up heads once ina  while
19:42:14 <lingxiao> uhhhh .... im a little scared tbh 
19:42:19 <Hijiri> you could use Integer
19:42:24 <lingxiao> does that give the same behavior as double?
19:42:27 <Hijiri> and use something bigger
19:42:45 <Hijiri> double can represent more than 32 bit integers exactly
19:42:55 <Hijiri> if that's good enough then it should be ok
19:43:02 <lingxiao> sorry coudl you elaborate?
19:43:07 <lingxiao> im not well versed in this stuff
19:43:21 <lingxiao> i mean integer vs double vs float 
19:43:32 <Hijiri> if you have an integer that's 32 bits, you won't lose information by converting to double
19:43:45 <Hijiri> in contrast, I think float goes only up to twenty something bit integers
19:44:00 <Hijiri> and then it won't be representing it exactly
19:44:16 <Hijiri> as in the value will be close to the expected integer value, but may be off by a little
19:44:30 <aaronm04> lingxiao: Doubles have 53 bits in their mantissas
19:44:44 <Hijiri> > fromIntegral (maxBound :: Int) :: Float
19:44:46 <lambdabot>  9.223372e18
19:45:04 <lingxiao> maxBound :: Int
19:45:06 <Hijiri> actually this isn't a good example since Ints are 64 bit on 64 bit
19:45:09 <lingxiao> maxBound :: Integer
19:45:17 <Hijiri> so a Double wouldn't represent it exactly either
19:45:21 <lingxiao> > maxBound :: Integer
19:45:23 <lambdabot>      No instance for (Bounded Integer) arising from a use of ‘maxBound’
19:45:23 <lambdabot>      In the expression: maxBound :: Integer
19:45:31 <lingxiao> > maxBound :: Int
19:45:33 <lambdabot>  9223372036854775807
19:45:48 <lingxiao> so integers are unbounded? but if it overlows i just get 0 right?
19:45:51 <Hijiri> but if 32-bit maxbound is granular enough for you then 64-bit maxBound converted to Double is probably still good enough, but I don't know much about that
19:45:59 <Hijiri> Int is bounded
19:46:08 <Hijiri> if it overflows you will get a large negative number
19:46:15 <Hijiri> > maxBound + 1 :: Int
19:46:17 <lambdabot>  -9223372036854775808
19:46:21 <lingxiao> what about integers?
19:46:27 <Hijiri> Integer is unbounded
19:53:32 <lingxiao> first could i ask if RVar Bool is really that much worse than MonadRandom m => m Bool?
19:53:54 <Hijiri> I've never used RVar, I don't know
19:53:58 <lingxiao> ok i see
19:54:40 <lingxiao> thanks for the tidbit on numbers!
20:01:06 <DanC_> is anybody else surprised that Text.JSON uses Rational for JSON numerics rather than Double? https://github.com/GaloisInc/json/issues/5
20:03:50 <glguy> I'm surprised anyone's using that package, we certainly don't use it internally
20:04:47 * Clint chuckles.
20:05:06 <DanC_> harrumph. It has googlemark on "haskell json"
20:05:28 <M-Quora> DanC_ (IRC): Aeson is what you want.
20:06:07 <c_wraith> What's the module that has Constraint defined in it, again?
20:07:00 <DanC_> Aeson has dozens of dependencies. I was trying to avoid that sort of bulk.
20:10:24 <pavonia> glguy: Internally where?
20:11:56 <DanC_> Aeson has the same bug/misfeature: it uses Scientific, "An arbitrary-precision number represented using scientific notation."
20:12:47 <geekosaur> so are you willing to not be able to parse some JSON values?
20:12:59 <c_wraith> pavonia: at Galois
20:13:22 <pavonia> Oh
20:13:27 <DanC_> my understanding is that there are no JSON values that are not IEEE floats
20:13:37 <c_wraith> DanC_: that's not how JSON is specified.
20:13:41 <glguy_> Danc_: reading around a bit it doesn't appear that that is true
20:13:57 <geekosaur> the author of aeson thought that originally, found out otherwise, started using Scientific
20:14:43 <DanC_> then the docs for Text.JSON are wrong; it cites ECMA-262 3rd Edition
20:15:39 <glguy_> Yeah, I'm at Galois and the json library was written by someone who used to work here
20:16:07 <DanC_> what specs are more useful for JSON?
20:16:30 <lingxiao> he all so i see that:
20:16:32 <lingxiao> uniform :: Distribution Uniform a => a -> a -> RVar a
20:16:45 <lingxiao> but is here a uniform :: (Distribution Uniform a, Monad m) => a -> a -> RVarT m a
20:16:52 * DanC_ tries https://en.wikipedia.org/wiki/JSON ...
20:17:18 <DanC_> whee! "It is currently described by two competing standards, RFC 7159 and ECMA-404."
20:17:34 <DanC_> RFC 7159 has a bunch of weasle-words around numbers.
20:19:33 <tommd> pffft.  glguy_ claims to be "at Galois".
20:19:35 <DanC_> phpht.  RFC 7159 uses "Values" to refer to syntax.
20:19:41 <tommd> I bet he's 10 miles away at this point.
20:21:30 <DanC_> ugh. none of these specs defines any equivalence relation on JSON expressions.
20:22:47 <DanC_> JWT seems to specify canonicalization...
20:23:35 <caasih> Can I use netwire with GHC 7.10?
20:24:02 <DanC_> maybe not...
20:25:13 <L8D> I'm randomly running into a test suite failure
20:25:25 <L8D> saying "test-stinch-types: executable not found"
20:26:11 <L8D> for test-stinch-types is the name of the test suite. I'm assuming it has to do with linking, because the error started occuring after I moved my tests into seperate modules
20:26:30 <L8D> and those modules aren't in the exposed-modules field of the test suite
20:27:24 <caasih> DanC_: ok, thank you
20:27:58 <DanC_> oh... I wasn't talking about netwire
20:31:17 <caasih> oh..., my fault
20:31:56 <L8D> nvm it got fixed in a newer version of stack
20:33:30 <lingxiao> hey all
20:33:31 <lingxiao> http://stackoverflow.com/questions/34303970/using-monadrandom-with-monadstate
20:33:37 <lingxiao> could someone take a look at my SO question?
20:34:24 <L8D> lingxiao: you need to specify the RVar part of that
20:34:35 <lingxiao> what do ou mean?
20:34:59 <L8D> oh wait nvm
20:36:35 <L8D> lingxiao: perhaps change "p <- lift $ ..." into "p <- ..." ?
20:36:46 <L8D> assuming "uniform" uses RandomSource
20:37:15 * DanC_ found a work-around.
20:37:17 <lingxiao> so now it's 
20:37:18 <L8D> lingxiao: where are you importing "uniform" from?
20:37:19 <lingxiao> foo
20:37:20 <lingxiao>   :: MonadState s Data.Functor.Identity.Identity =>
20:37:20 <lingxiao>      s -> RVarT Data.Functor.Identity.Identity ()
20:37:55 <lingxiao> which is not: foo :: (MonadState s m) => s -> RVarT m () 
20:39:46 <L8D> lingxiao: it's because the 's' used in "s -> m ()" and "MonadState s m" should not be the same 's' used in "RandomSource m s"
20:39:56 <L8D> lingxiao: it should be "RandomSource m Double" or something
20:40:53 <lingxiao> so i did tht ... 
20:40:54 <lingxiao>     Expected type: m Double
20:40:54 <lingxiao>       Actual type: RVar Double
20:41:03 <bitemyapp> lingxiao: why are you trying to use RVar?
20:41:08 <bitemyapp> lingxiao: what are you trying to do?
20:41:25 <lingxiao> right now I'm using RVar, which is why im stuck with RandomSource m s 
20:41:32 <lingxiao> ideally id like to use MonadRandom m 
20:41:46 <lingxiao> but i dont know how to sample a value from 0 1
20:41:57 <L8D> lingxiao: RVar implements MonadRandom though
20:42:05 <bitemyapp> lingxiao: MonadRandom isn't an implementation
20:42:05 <L8D> lingxiao: you can't just use MonadRandom and getRandomDouble ?
20:42:09 <bitemyapp> lingxiao: it's a class of implementations
20:42:37 <bitemyapp> lingxiao: you just want any random Double between 0 and 1?
20:43:03 <lingxiao> bitemyapp yup
20:43:12 <bitemyapp> lingxiao: okay, lets drop the noise then
20:43:31 <lingxiao> yes!
20:43:31 <bitemyapp> lingxiao: http://lpaste.net/8810200555256283136
20:43:38 <bitemyapp> lingxiao: do that until you need more-fancy.
20:43:46 <bitemyapp> lingxiao: so you can get on with what you're trying to do.
20:43:56 <bitemyapp> lingxiao: one of the tricky things with Haskell is learning to avoid quagmires.
20:44:11 <L8D> lingxiao: do you *need* a random double between 0 and 1 or do you want a random bit?
20:44:27 <bitemyapp> lingxiao: if something that should be simple is burning a lot of time, you often to back up a bit and potentially use a different library/API.
20:44:56 <bitemyapp> you often want to*
20:45:03 <lingxiao> oh randomIO puts me in IO right away though
20:45:07 <lingxiao> I was trying to avoid that
20:45:15 <lingxiao> granted RVar is similar ..
20:45:28 <bitemyapp> lingxiao: hold up
20:45:34 <bitemyapp> lingxiao: why does it matter if it does IO?
20:45:49 <bitemyapp> lingxiao: the alternative is carrying the seed around yourself, which is fine, but I'm trying to get you unstuck.
20:45:52 <lingxiao> L8D I'm using that double immediately to generate a bent coin
20:46:11 <L8D> lingxiao: bent coin flip?
20:46:11 <lingxiao> oh yeah i did the seed thing too, which was bad style
20:46:22 <bitemyapp> lingxiao: using State to manage the seed isn't bad style.
20:46:27 <bitemyapp> lingxiao: do the dumb/obvious thing first
20:46:32 <lingxiao> I did all of that
20:46:36 <bitemyapp> lingxiao: make something that works and passes tests with IO
20:46:39 <lingxiao> right now im polishing the signatures kind of
20:46:40 <bitemyapp> or State, or whatever works.
20:46:47 <lingxiao> oh all the tests i wrote passes
20:47:07 <bitemyapp> the only real improvement over IO IMO here would just be using State instead of IO to walk the generator forward.
20:47:14 <lingxiao> right now my singaure look like this: Sink a (StateT Counter RVar) (Store a)
20:47:17 <bitemyapp> but you'll still need IO for the initial entropy.
20:48:09 <lingxiao> but suppose im set on the (MonadRandom m, MonadFoo m) => m () singature :)
20:48:29 <lingxiao> L8D yeah flipping the bent coin
20:48:35 <bitemyapp> lingxiao: I mean, you can have intermediate code be polymorphic but it has to ground out in a concrete type somewhere.
20:49:04 <lingxiao> btw I can't see your user name as anyting other than a crazy haired - glasses wearing smiely face
20:49:17 <lingxiao> yeah I'm playing around with teh type system more than anything
20:49:30 <bitemyapp> well as long as you're not in a rut.
20:49:33 * bitemyapp gets back to writing
20:49:45 <lingxiao> actually weirich and I had a discussion about this today for someone elses code, IO is not good for randomness
20:49:52 <lingxiao> monadrandom is really want they wanted
20:49:56 <lingxiao> hence my refactoring
20:50:49 <bitemyapp> I know using IO to bump the global state gen isn't great, but my limited sampling of the backlog made it seem like getting a random value _at all_ was the problem.
20:51:35 <lingxiao> yeah its' verry awkward no disagreement there
20:59:55 * hackagebot ghc-options 0.1.0.0 - Utilities for extracting GHC options needed to compile a given Haskell target.  https://hackage.haskell.org/package/ghc-options-0.1.0.0 (ranjitjhala)
21:00:54 <Cale> I wrote MonadRandom and I'm not even sure it's a worthwhile class :P
21:01:17 <Cale> It makes splitting awkward
21:01:47 <Cale> Definitely having a monomorphic type of random variables is worthwhile
21:02:15 <Cale> We should separate the Gen monad from QuickCheck and just make that standard.
21:02:16 <wedens> how can I write in hspec something like `traverse (`shouldBe` a) [1,2,3]` ?
21:02:47 <c_wraith> Cale: even though Gen is only "morally" a monad?
21:02:58 <Cale> c_wraith: hm?
21:03:25 <Cale> c_wraith: Are you talking about some _|_ related shenanigans?
21:03:41 <c_wraith> Cale: Gen only obeys the monad laws if you consider all randomly-selected values equal.
21:04:15 <Cale> Oh, is that true? If that's the case, we should fix that :P
21:04:27 <c_wraith> Cale: it's because (>>=) splits the generator.
21:05:09 <shachaf> That's more than I'd expect (>>=) to do.
21:05:35 <Cale> That seems like a strange thing to have it do
21:06:28 <c_wraith> It lets the applicative instance run in parallel!
21:06:30 <glguy> I'd imagine it has something to do with wanting to support more laziness
21:06:50 <c_wraith> Yeah, that too
21:06:59 <glguy> like being able to generate a random, infinite binary tree
21:07:30 <jle`> huh, didn't realize that.  makes sense
21:07:51 <Cale> Well, wanting to generate random infinite structures is one thing, but trying to make that happen with the monad instance seems odd.
21:08:46 <jle`> it sort of makes sense with the semantics
21:13:46 <solirc> wedens: Probably you want to use forM_ / mapM_
21:15:22 <codebje> :r
21:18:31 <wedens> solirc: yeah. it was traverse_
21:19:02 <solirc> k
22:15:16 * hackagebot auto-update 0.1.3 - Efficiently run periodic, on-demand actions  https://hackage.haskell.org/package/auto-update-0.1.3 (KazuYamamoto)
22:44:05 <jle`> today i accidentally typed {-# Language .. #-} instead of {-# LANGUAGE ... #-}, and it compiled fine
22:44:11 <jle`> my whole life has been a lie
22:44:37 <bitemyapp> jle`: lmao
22:44:41 <dolio> You should have asked me. I've been enjoying not capitalizing everything for a while.
22:44:50 <bitemyapp> jle`: permissive grammars smdh
22:45:23 <jle`> now to find out if {-# lAnGuAgE gAdTs #-} will work
22:45:33 <bitemyapp> ohgod
22:45:46 <dolio> You don't get to mis-capitalize things like GADTs.
22:45:53 <dolio> At least, I'm pretty sure.
22:45:57 <bitemyapp> jle`: you just need to make a whole suite of popular libraries with their pragmas written like this.
22:46:21 <jle`> lAnGuAgE works but the actual extension name is case-sensitive apparently
22:46:22 <dolio> But all capitalizations of stuff like 'language' and 'inline' work, I think.
22:46:40 <jle`> oh that's nice to know.  i was getting tired of shouting whenever i wrote 'INLINE'
22:46:54 <dolio> Yeah.
22:47:07 <jle`> gonna do lAnGuAgE and iNlInE from now on i guess
22:47:11 <nilg> I found a bug in the MultiMap module. I've sent a bug correction to the author Julian Fleischer 4 days ago, still no answer, what should I do?
22:47:13 <kadoban> Bonus points for randomcaps. iNliNE
22:47:29 <jle`> i should just use TH to generate random capitalizations at compile time
22:47:35 <kadoban> jle`: XD
22:47:44 <jle`> or CPP because that might actually work
22:48:14 <glguy> nilg: You should keep waiting. You can fork it if you need the fix locally
22:57:28 <nilg> thanks
23:02:31 <nilg> Why bang makes strict evaluation, I don't understand the magic...
23:04:49 <jle`> it's a part of the language :o
23:05:01 <jle`> that's like asking why \ makes a lambda/anonymous function, or case makes a case statement
23:05:11 <jle`> or why :: makes a type signature :)
23:05:21 <nilg> I mean why do you have to check that a value is not a bottom to turn the computation into something strict?
23:05:26 <zv> k/tw
23:05:51 <nilg> I sense that there is an idea, but I can't grasp it...
23:07:47 <nilg> Ohhh! I really don't understand that from https://prime.haskell.org/wiki/BangPatterns : f3 !(x,y) = [x,y]
23:07:48 <nilg> f4 (x,y)  = [x,y]
23:07:48 <nilg>  
23:07:48 <nilg> f3 and f4 are identical; putting a bang before a pattern that forces evaluation anyway does nothing.
23:07:50 <nilg>  
23:07:54 <nilg>  
23:07:56 <nilg> ???
23:08:22 <nilg> It doesn't seem to me f4 is forcing evaluation!  ???
23:09:21 <saulzar> nilg, It needs to, before it can match on the tuple
23:10:25 <saulzar> nilg, It's not evaluating x or y - but it is evaluating the parameter (x, y)
23:10:51 <nilg> saulzar: ohhh, I got it!!!!!! thanks!
23:11:10 <verement> > let f x = 9 in f undefined
23:11:12 <lambdabot>  9
23:11:20 <verement> > let f (x,y) = 9 in f undefined
23:11:22 <lambdabot>  *Exception: Prelude.undefined
23:11:26 <nilg> sure cause (., .) is just a pair constructor, and *this* is strict, right?
23:12:06 <nilg> !(x, y) is just making the pair constructor strict, which is already is, right?
23:12:52 <pyon> Is the pair constructor strict? :-O
23:13:08 <Geraldus> hi friends!
23:13:29 <verement> > let f (x,y) = 9 in (undefined, undefined)
23:13:30 <lambdabot>  (*Exception: Prelude.undefined
23:13:45 <verement> > let f (x,y) = 9 in f (undefined, undefined)
23:13:45 <opqdonut> nilg: pyon: the (,) constructor isn't strict
23:13:47 <lambdabot>  9
23:13:48 <Geraldus> is it OK to `unsafeCoerce` DiffUTCTime to NominalDiffTime?
23:13:59 <verement> > let f !(x,y) = 9 in f (undefined, undefined)
23:14:00 <lambdabot>  9
23:14:13 <opqdonut> nilg: pyon: but in order to pattern match a value x against a pattern (x,y), you need to evaluate x to (<thunk>,<thunk>)
23:14:28 <pyon> opqdonut: Of course, but that's not the same as the pair constructor being strict.
23:14:29 <opqdonut> err, let's say "a value foo against a pattern (x,y)"
23:14:32 <opqdonut> pyon: indeed
23:14:56 <Geraldus> I've used toEnum . fromEnum in past, but it gives wrong negative results (because of Int) for big intervals, e.g. year seconds
23:15:03 <nilg> OK guys, thanks for pointing the difference I understand
23:15:06 <saulzar> Pattern matching on the pair constructor is strict 
23:15:22 <nilg> indeed, got it
23:15:24 <saulzar> > let f (!x,y) = 9 in f (undefined, undefined)
23:15:26 <lambdabot>  *Exception: Prelude.undefined
23:15:37 <Geraldus> let ys = secondsToDiffTime 31536000;
23:15:51 <Geraldus> let ys = secondsToDiffTime 31536000
23:16:02 <Geraldus> > let ys = secondsToDiffTime 31536000
23:16:04 <lambdabot>  <no location info>:
23:16:04 <lambdabot>      not an expression: ‘let ys = secondsToDiffTime 31536000’
23:17:35 <Geraldus> OK, e.g. fromEnum (secondsToDiffTime 31536000) gives -5357488147419103232
23:26:27 <Geraldus> anybody? (:
23:28:43 <verement> what was the question?
23:31:32 <verement> > secondsToDiffTime 31536000
23:31:34 <lambdabot>  Not in scope: ‘secondsToDiffTime’
23:31:43 <johnw> Geraldus: what is it that you actually want to represent?
23:32:20 <Geraldus> johnw: I want to calculate how many days is between two dates
23:33:06 <johnw> are your "dates" UTCTime's?
23:33:17 <Geraldus> johnw: I'm using diffUTCTime which gives NominalDiffTime
23:33:31 <johnw> try: diffDays (utctDay x) (utctDay y)
23:34:26 <Geraldus> johnw: wow, where did you find this function? (: I've missed it for a long time
23:34:32 <johnw> Data.Time.Calendar
23:34:39 <johnw> any UTCTime also has a Day component
23:35:49 <Geraldus> actually, I've founds possible solution, I can produce NominalDiffTime this way: (10 ^ 12 *) . toEnum, but now it is not needed (: thank you a lot
23:38:06 <jle`> ah today is another day where parametricity writes my code for me
23:38:16 <jle`> haskell feels great when the type system works for you
23:38:40 <johnw> yes, that is quite a pleasant feeling when it happens
