00:14:12 <Lokathor> does haskell have a package for bounded math?
00:14:28 <Lokathor> like instead of wrapping around when you subtract to too low of a number, it just stops at some value
00:14:39 <Lokathor> i'm guessing this is an odd request
00:27:30 <pdxleif> Lokathor: Off the top of my head, there's arbitrary precision integers, implemented w/ gmp.
00:27:46 <pdxleif> Lokathor: Maybe this? http://hackage.haskell.org/package/data-fin-0.1.0/docs/Data-Number-Fin-Integer.html
00:28:40 <pdxleif> Or https://hackage.haskell.org/package/data-fin-simple or something?
00:28:48 <bitemyapp> finna simple
00:32:11 <pdxleif> Simple Finite Set Framework 4 Haskell
00:35:48 <Lokathor> hmm
00:36:39 <Lokathor> this is cool, but i think aimed at a very different audience than me
00:46:26 <ReinH> Lokathor: I'd just use normal arithmetic and clamp afterwards
00:46:56 <Lokathor> yeah something like that
00:47:38 <Lokathor> i was imagining that a value would be number-like, but also carry around info on the range it was allowed to be in, and after every operation it'd automatically get clamped back into range
00:48:23 <Lokathor> simple really, but there always might be a package for whatever already
00:50:21 * hackagebot vector-fftw 0.1.3.5 - A binding to the fftw library for one-dimensional vectors.  https://hackage.haskell.org/package/vector-fftw-0.1.3.5 (BenGamari)
01:05:21 * hackagebot sump 0.1.0.1 - A Haskell interface to SUMP-compatible logic analyzers  https://hackage.haskell.org/package/sump-0.1.0.1 (BenGamari)
01:25:22 * hackagebot omnifmt 0.2.0.0 - A pretty-printer wrapper to faciliate ease of formatting during development.  https://hackage.haskell.org/package/omnifmt-0.2.0.0 (hjwylde)
01:34:07 <LangeOortjes> Forgive me for perhaps asking something silly, but is there a way to configure Hoogle to use the search engine on stackage.org?
01:35:10 <merijn> LangeOortjes: You mean the commandline app?
01:35:17 <LangeOortjes> yes, sorry
01:35:24 <merijn> LangeOortjes: That doesn't use the internet at all
01:35:32 <merijn> LangeOortjes: It uses a database on your machine
01:39:09 <LangeOortjes> merijn, alright, thank you, I should have read a bit more on the command line utility
01:44:11 <cocreature> LangeOortjes: if you’re just after generating a database for everthing in stackage, the (unreleased) hoogle 5 supports that, take a look at https://github.com/ndmitchell/hoogle/blob/master/docs/Install.md
01:44:22 <cocreature> you’ll need to build hoogle from the master branch of that repo
01:45:19 <LangeOortjes> cocreature, hey yeah I was just reading about Hoogle 5, sounds interesting. There's so much new stuff coming at me now that I am starting to write my first non-trivial programs. So these pointers are highly appreciated!
01:46:13 <ericshortcut> Hi everyone. I just saw a method and I could not understand. when you declare     foo :: TypeA TypeB typeC  it's the same as foo :: TypeA -> TypeB -> TypeC ?
01:47:17 <cocreature> ericshortcut: no that’s not the same. the first has TypeA with type parameters TypeB and TypeC, the second has a function type which takes a TypeA and a TypeB and gives you a TypeC
01:48:14 <ericshortcut> oh, I see
01:48:28 <ericshortcut> cocreature: Thank you! helped me a lot! :)
01:48:35 <ericshortcut> now it makes sense 
01:50:23 * hackagebot linear-opengl 0.2.0.10 - Isomorphisms between linear and OpenGL types  https://hackage.haskell.org/package/linear-opengl-0.2.0.10 (BenGamari)
01:50:38 <akegalj> Is Reader a (IO b) == ReaderT a IO b ?
01:56:19 <cocreature> koz_: not quite, it’s ReaderT a Identity (IO b), but it should be isomorphic to the other type
01:56:35 <cocreature> eh akegalj 
01:56:38 <cocreature> sry
01:57:42 <merijn> No, that's not true
01:58:24 <merijn> >>= for "Reader a (IO b)" has type "Reader a (IO b) -> (IO b -> Reader a (IO c)) -> Reader a (IO c)
01:58:56 <merijn> While "ReaderT a IO b" would have "ReaderT a IO b -> (b -> ReaderT a IO c) -> ReaderT a IO c"
01:59:15 <merijn> iow, the ReaderT version can run IO effects intermediately, the reader one does not
01:59:47 <akegalj> cocreature, merijn: thank you
02:00:59 <cocreature> oh yeah sorry
02:04:39 <Unhammer> can haskell-mode somehow call hsc2hs before loading?
02:09:23 <cocreature> Unhammer: afaik no
02:10:42 <Unhammer> :/ hm
02:15:44 <wedens> how do I know which fields are better be strict and unpacked?
02:16:22 <wedens> is there something to read about *what* to optimize?
02:17:15 <merijn> wedens: I think the starting point would be to get an intuition for "cost" in a lazy setting
02:17:52 <merijn> wedens: I'd say the starting point would be something like https://hackhands.com/guide-lazy-evaluation-haskell/ and/or the STG paper (depending on how deep you want to dive into it)
02:31:22 <mtesseract> Good morning
02:34:04 <wedens> merijn: thanks
02:34:42 <merijn> wedens: The STG paper can be found here research.microsoft.com/apps/pubs/default.aspx?id=67083 I'd say basic haskell plus a little knowledge of C/asm/CPUs should be more than enough to read it
02:36:10 <mtesseract> Do I see this correctly, that so far there is not 'canonical' way in a stack-based setup to install packages (including data files) into specific prefixes, which is useful for e.g. packaging?
02:39:03 <jle`> i always laugh when i am programming with like, 20 extensions on.  and then randomly hours/days in, I get an error saying I have to turn TupleSections on
02:39:28 <jle`> like, of all the things to complain about >_>
02:39:55 <ChristianS> @src Ordering
02:39:55 <lambdabot> data Ordering = LT | EQ | GT
02:53:05 <cocreature> jle`: I hope you think long and hard before you decide to enable that one :)
03:36:03 * hackagebot postgresql-simple 0.5.1.1 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.1.1 (LeonSmith)
03:41:03 * hackagebot pgdl 8.5 - simply download a video (or a file) from a webpage and xdg-open it.  https://hackage.haskell.org/package/pgdl-8.5 (sifmelcara)
04:06:52 <DanielDiaz> I get "ghc: internal error: stg_ap_pv_ret" when compiling yesod-core, any ideas? :(
04:07:09 <DanielDiaz> ghc-7.10.1
04:38:49 <homam> I have a problem with stack and pipes package. I added pipes to build-depends, but I get `Could not find module ‘Control.Pipe’` by `stack.build`
04:39:31 <liste> homam what's Control.Pipe?
04:39:39 <liste> there's only Pipes module in https://hackage.haskell.org/package/pipes
04:39:56 <liste> seems Control.Pipe is old
04:39:58 <merijn> liste: It used to be Control.Pipe in a very early version, iirc
04:40:39 <homam> liste: i found Control.Pipe here http://stackoverflow.com/questions/12610810/breadth-first-traversal-of-directory-tree-is-not-lazy
04:41:00 <liste> homam the module is Pipes now
04:42:14 <homam> liste: perfect. thanks!
04:42:25 <merijn> I don't suppose anyone's aware of a haskell bindings for SLURM?
04:44:44 <merijn> Semi relatedly, is anyone aware of a library for N-dimensional comparisons? i.e. I want all values on the pareto front to compare "equal" and basically find sets of pareto fronts (i.e. the 2nd front is the pareto front after removing all entries in the first pareto front)
04:46:05 * hackagebot LinguisticsTypes 0.0.0.2 - Collection of types for natural language  https://hackage.haskell.org/package/LinguisticsTypes-0.0.0.2 (ChristianHoener)
05:09:13 <rydgel> I need to play a sound with FRP.Yampa. So I stored a bool to my game state, but how can I be certain that it will only stay "on" for 1 iteration?
05:11:06 * hackagebot stack-hpc-coveralls 0.0.2.0 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.2.0 (rubik)
05:19:37 <Unhammer> if I withForeignPtr f (\g -> c_foo l) -- where c_foo l :: IO (Ptr Thing), will the foreignPtr get gc'd even though it was accessible when creating the return value of c_foo?
05:22:40 <merijn> Unhammer: You mean, can I store g somewhere and return it from "c_foo l"?
05:23:00 <merijn> Unhammer: The answer is: Yes, it can and WILL get GCed and horribly crash your code at some point
05:25:26 <Unhammer> hm, so I guess I need to keep that in the returned structure
05:25:39 <Unhammer> or, keep "f" presumably
05:25:46 <merijn> Unhammer: Exactly what are you attempting to do?
05:26:02 <merijn> You'd have to copy the part of the pointer you care about
05:30:21 <Unhammer> maybe I don't need the foreignPtr at all; I think I need to read some more manuals …
05:33:45 <merijn> Unhammer: Like I asked, what are you trying to do?
05:35:52 <liste> what locale do toUpper and toLower use?
05:36:17 <merijn> liste: I think C or system, but don't rely on it for locale aware transforms
05:36:21 <mauke`1> none, I hope
05:36:26 <merijn> liste: If you truly care about locale, use text-icu
05:36:51 <liste> > toUpper 'ä'
05:36:53 <lambdabot>  '\196'
05:37:01 <liste> > 'Ä'
05:37:03 <lambdabot>  '\196'
05:37:18 <tdammers> > toUpper 'ß'
05:37:20 <lambdabot>  '\223'
05:37:27 <merijn> toUpper breaks on stuff like uppercasing ß
05:37:28 <tdammers> > [toUpper 'ß']
05:37:29 <lambdabot>  "\223"
05:37:50 <merijn> > Data.Text.toUpper (Data.Text.pack "ß")
05:37:51 <lambdabot>      Not in scope: ‘Data.Text.toUpper’
05:37:51 <lambdabot>      Perhaps you meant ‘Data.Char.toUpper’ (imported from Data.Char)Not in sc...
05:38:16 <mauke`1> > toUpper 'ı'
05:38:17 <lambdabot>  'I'
05:50:38 <Unhammer> merijn, I found out that in my case, I can call the finaliser myself and not have to deal with foreignptr, but I am still wondering if something like   http://sprunge.us/hMBZ would work if I ever have to keep the ForeignPtr around
05:52:40 <merijn> Unhammer: That depends whether C has pointers pointing to memory of 'f'
05:53:02 <merijn> Unhammer: This is all basically just malloc/free in C, with ForeignPtr automatically handling "free" for you
05:53:39 <merijn> As such, if it would be safe to do in C, it's safe here, else it's a use-after-free error
05:54:10 <Unhammer> yeah, I'm assuming c_make_thing_using_structure doesn't free p
05:55:04 <Unhammer> withForeignPtr's docs say returning p would give use-after-free, but returning f (the ForeignPtr-wrapped p) feels like it ought to work
05:56:13 * hackagebot NaturalLanguageAlphabets 0.1.0.0 - Simple scoring schemes for word alignments  https://hackage.haskell.org/package/NaturalLanguageAlphabets-0.1.0.0 (ChristianHoener)
05:58:07 <merijn> Unhammer: Let's take the trivial example "withForeignPtr f (\p -> return p)" <- this is clearly unsafe as p points to the same memory as 'f', but 'f' might be GCed and freed before we ever used 'p'
06:03:00 <merijn> Any good libraries for partial order/topological sorts and/or grouping?
06:05:39 <Unhammer> withForeignPtr f (\p -> return f) otoh
06:09:45 <OverCoder> m, lucky
06:11:18 * hackagebot SoccerFun 0.5.3 - Football simulation framework for teaching functional programming  https://hackage.haskell.org/package/SoccerFun-0.5.3 (JanRochel)
06:11:20 * hackagebot SoccerFunGL 0.5.3 - OpenGL UI for the SoccerFun framework  https://hackage.haskell.org/package/SoccerFunGL-0.5.3 (JanRochel)
06:15:50 <deni> I'm having a really hard time writing a function that converst a string from camelCase to CAPITALIZED_SNAIL_CASE..... it takes me 10 seconds to writ ethe darn thin in python but haskell is proving to be difficult.
06:16:05 <deni> can anybody help?
06:16:09 <dredozubov> how can i make a `Name`(like ''Foo) out of a really long type?
06:16:30 <dredozubov> i've got a data family instances and i want to make the lenses for them
06:16:51 <pavonia> deni: What do you have so far? Where is it failing?
06:16:54 <maerwald> question about implicit parameters: I have this function http://lpaste.net/146355 and it's called fairly early in the main call stack... is it safe to modify settings afterwards and call another withSettings?
06:17:54 <deni> pavonia: my brain is the only thing that's failing at the moment.. :(  I've been looking at Data.List.Split but most of that donesn't work on string but on lists
06:17:58 <deni> so I'm at a loss
06:18:34 <pavonia> deni: Recall that String = [Char]
06:18:44 <ogRefl> pavonia: try using concatMap. map each Char to a String.
06:19:15 <pavonia> You meant deni
06:19:27 <ogRefl> oh right...
06:19:30 <ogRefl> sorry.
06:21:43 <ogRefl> use Data.Char: isUpper and toUpper
06:41:49 * hackagebot maxsharing 1.0.3 - Maximal sharing of terms in the lambda calculus with letrec  https://hackage.haskell.org/package/maxsharing-1.0.3 (JanRochel)
06:46:55 * hackagebot WordAlignment 0.1.0.0 - Bigram word pair alignments.  https://hackage.haskell.org/package/WordAlignment-0.1.0.0 (ChristianHoener)
06:47:24 <tromp__> :t nubBy
06:47:25 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
07:00:53 <Crazycolorz5> Hello, can anyone help me with some questions about the FFI briefly?
07:02:48 <dhalgren`> Crazycolorz5: I honestly couldn't - but a common advice on irc is to just ask, as opposed to asking about asking. Someone  knowlegable should see it eventually :)
07:03:05 <Crazycolorz5> Okay, well, the gist of it is that
07:03:33 <Crazycolorz5> I need G++ to be the final compiler for my code
07:03:51 <Crazycolorz5> So how would I find the right files to include, or even how would I arrange my C++ file
07:04:13 <Crazycolorz5> So that I would be able to call functions defined in haskell code (say it's already compiled to a .o file by GHC)
07:04:24 <Crazycolorz5> Also assuming that I properly start the Haskell runtime, as well.
07:04:46 <merijn> Crazycolorz5: Do you plan to use C(++) for your main function and call haskell from C(++)?
07:04:52 <Crazycolorz5> I mean, I'm mostly just unclear on the compilation step, since I'm used to using the FFI by passing the C file with main to GHC.
07:04:55 <Crazycolorz5> Yes
07:04:57 <nrolland> is system-filepath the most complete filepath library out there? 
07:05:21 <merijn> Crazycolorz5: Why does g++ need to be the final compiler?
07:05:37 <merijn> Crazycolorz5: I have a minimal example of using haskell with a C main file here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
07:06:47 <merijn> Crazycolorz5: If you tell g++ to just produce object files ghc is perfectly happy to link object files from whatever compiler into your executable
07:07:11 <phaazon> hm
07:07:17 <phaazon> > minBound :: Float
07:07:18 <lambdabot>      No instance for (Bounded Float) arising from a use of ‘minBound’
07:07:18 <lambdabot>      In the expression: minBound :: Float
07:07:20 <phaazon> that’s weird
07:07:38 <merijn> phaazon: Why? You expected min infinity?
07:07:47 <Crazycolorz5_> sorry about that, disconnected for a moment.
07:07:53 <phaazon> no, I expected the least value a float can take
07:08:05 <merijn> phaazon: That would be minus infinity...
07:08:08 <exio4> min infinity is a valid float 
07:08:13 <merijn> By definition there's no smaller float...
07:08:24 <phaazon> is there a way to have such a value in Haskell?
07:08:27 <Crazycolorz5_> merijn: How is your example built?
07:08:31 <phaazon> > infinity
07:08:32 <lambdabot>  *Exception: stack overflow
07:08:39 <phaazon> :t infinity
07:08:39 <exio4> > let inf = (1/0) in ( -inf , inf )
07:08:40 <lambdabot> Natural
07:08:41 <lambdabot>  (-Infinity,Infinity)
07:08:44 <merijn> Crazycolorz5_: That's using cabal
07:09:20 <phaazon> interesting
07:09:34 <merijn> Crazycolorz5_: But GHC just produces and links object files, g++ should also be perfectly happy to link GHCs object files if you remember to link the haskell RTS and remember to foreign export the relevant functions
07:09:57 <dhalgren`> heh, keeps dropping
07:10:15 <Crazycolorz5_> Yeah, the part I'm having difficulty with is knowing where to link the haskell-relevant librarys/files
07:10:30 <Crazycolorz5_> Namely, HsFFI.h
07:10:40 <merijn> phaazon: There's no builtin name for the value infinity, but other than that Double/Float should just follow IEEE754
07:10:58 <phaazon> ok, thanks
07:11:05 <phaazon> because I need to run a minmax algorithm
07:11:15 <phaazon> using Foldable
07:11:43 <merijn> Unfortunately it does so even when it's unclear whether that's desirable
07:11:44 <phaazon> I could use the first value though, but I don’t know how to do that with Foldable, not sure it’s possible without using toList, which I don’t
07:12:03 <merijn> > (read "NaN" :: Double) == read "NaN"
07:12:05 <lambdabot>  False
07:12:19 <exio4> er, what?
07:12:27 <exio4> how does that make sense? 
07:12:33 <merijn> exio4: NaN is unequal to itself according to IEEE754
07:12:42 <merijn> Or rather
07:12:50 <merijn> NaN is unequal to EVERY value, including itself
07:12:55 <phaazon> > 1/0 :: Float
07:12:57 <lambdabot>  Infinity
07:13:02 <phaazon> that’s great
07:13:04 <phaazon> thanks
07:13:09 <dhalgren`> hah! fun.
07:13:39 <merijn> > (read "NaN" :: Double) < 1/0 -- test
07:13:41 <lambdabot>  False
07:13:46 <merijn> > (read "NaN" :: Double) > 1/0 -- test
07:13:48 <Crazycolorz5_> merijn: How would I find the currect directory(-ies) to search to properly include HsFFI.h for my C source files?
07:13:49 <lambdabot>  False
07:13:54 <moop> > !NaN
07:13:56 <lambdabot>  <hint>:1:5:
07:13:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:14:01 <merijn> Crazycolorz5_: Depends on your GHC install
07:14:12 <merijn> NaN is not a literal (hence the read)
07:14:16 <moop> er
07:14:19 <moop> > not NaN
07:14:21 <lambdabot>  Not in scope: data constructor ‘NaN’
07:14:28 <mauke`1> NaN is still not a literal
07:14:39 <merijn> Also, the result will still be NaN
07:14:40 <Crazycolorz5_> :t read NaN
07:14:41 <lambdabot> Not in scope: data constructor ‘NaN’
07:14:46 <Crazycolorz5_> :t read "NaN"
07:14:47 <lambdabot> Read a => a
07:14:51 <merijn> The result of any operation on NaN is NaN
07:14:58 <c_wraith> > 0/0
07:14:59 <mauke`1> merijn: not nan is a type error
07:15:00 <lambdabot>  NaN
07:15:13 <merijn> mauke`1: Sure
07:15:34 <Crazycolorz5_> Now you have me curious, is there a semantic difference between NaN and undefined/_|_?
07:15:39 <merijn> I was thinking of bitwise negate
07:15:40 <c_wraith> yes
07:15:49 <merijn> Crazycolorz5_: Yes, for one NaN doesn't crash your program
07:16:01 <c_wraith> that's more of an operational difference. :)
07:16:12 <KaneTW> no, semantic too
07:16:36 <merijn> Yes, since NaN is not bottom, whereas undefined is
07:16:53 <KaneTW> NaN is a valid (non-bottom) floating point value
07:17:37 <merijn> Crazycolorz5_: You can (and people have) write a book on all the details of IEEE754, it's good to be at least passingly familiar with a bunch of them. If only to realise how insufficient your knowledge of Double/Float is and maintaining adequate levels of paranoia when dealing with them ;)
07:18:44 <Crazycolorz5> Wait but
07:19:04 <Crazycolorz5> Hmmm
07:19:29 <Crazycolorz5> If the result of any operation on NaN is NaN, how does that differ semantically from bottom?
07:19:51 <mauke`1> > show (0/0)
07:19:53 <lambdabot>  "NaN"
07:20:14 <mauke`1> > (0/0) `seq` ()
07:20:15 <lambdabot>  ()
07:20:28 <phaazon> > (-1/0 :: Float) < -936493649
07:20:29 <lambdabot>  True
07:20:33 <mauke`1> > isNaN (0/0)
07:20:35 <lambdabot>  True
07:20:37 <phaazon> > (1/0 :: Float) > 936493649
07:20:39 <lambdabot>  True
07:20:42 <phaazon> > (1/0 :: Float) < 936493649
07:20:43 <lambdabot>  False
07:20:57 <Crazycolorz5> > show (1/0)
07:20:59 <lambdabot>  "Infinity"
07:21:01 <mauke`1> > decodeFloat (0/0)
07:21:02 <lambdabot>  (-6755399441055744,972)
07:21:12 <phaazon> mauke`1: haha :D
07:21:15 <mauke`1> > round (0/0)
07:21:16 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
07:21:18 <KaneTW> wat
07:21:19 <Crazycolorz5> > isNaN (1/0)
07:21:20 <rydgel> > (1/0 :: Float) > (2/0 :: Float)
07:21:20 <lambdabot>  False
07:21:21 <lambdabot>  False
07:21:24 <phaazon> floor (0/0)
07:21:27 <phaazon> > floor (0/0)
07:21:30 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
07:21:33 <KaneTW> > div 0 0
07:21:34 <Crazycolorz5> ........ wut
07:21:36 <lambdabot>  *Exception: divide by zero
07:21:44 <phaazon> Crazycolorz5: that’s because floor, round and so are unsafe
07:22:02 <phaazon> I guess they should raise exceptions in those cases
07:22:14 <chris2> > 1 ** (0/0)
07:22:16 <Crazycolorz5> > round undefined
07:22:16 <lambdabot>  1.0
07:22:18 <lambdabot>  *Exception: Prelude.undefined
07:22:29 <chris2> Crazycolorz5: ^ not NaN for every operation
07:22:29 <Crazycolorz5> > round (1/0)
07:22:31 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:22:41 <Crazycolorz5> round (0/1)
07:22:44 <Crazycolorz5> Er
07:22:48 <Crazycolorz5> > round (0/0)
07:22:49 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
07:22:53 <Crazycolorz5> that's hilarious
07:23:05 <Crazycolorz5> Also totally answers my question, thanks
07:23:10 <Crazycolorz5> round is weeeeird
07:23:33 <Crazycolorz5> > div (read "NaN") 1
07:23:34 <lambdabot>  *Exception: Prelude.read: no parse
07:23:45 <Crazycolorz5> > read "NaN"
07:23:46 <lambdabot>  *Exception: Prelude.read: no parse
07:24:13 <c_wraith> > read "NaN" :: Double
07:24:15 <lambdabot>  NaN
07:24:26 <c_wraith> the "no parse" was because it was trying to read it as ()
07:24:31 <Crazycolorz5> oh ok
07:24:41 <Crazycolorz5> > div (read "NaN" :: Double) 1
07:24:43 <lambdabot>      No instance for (Integral Double) arising from a use of ‘div’
07:24:43 <lambdabot>      In the expression: div (read "NaN" :: Double) 1
07:24:44 <Crazycolorz5> er
07:24:46 <Crazycolorz5> right :P
07:24:55 <Crazycolorz5> > div (read "NaN" :: Int) 1
07:24:56 <lambdabot>  *Exception: Prelude.read: no parse
07:25:13 <Crazycolorz5> > div (read "NaN" :: Integer) 1
07:25:15 <lambdabot>  *Exception: Prelude.read: no parse
07:25:17 <mauke`1> Int is not a floating point type
07:25:25 <Crazycolorz5> Oh, is NaN only floating points?
07:25:42 <c_wraith> yes
07:25:46 <Crazycolorz5> div (toIntegral (read "NaN" :: Double)) 1
07:25:52 <Crazycolorz5> > div (toIntegral (read "NaN" :: Double)) 1
07:25:54 <lambdabot>      Not in scope: ‘toIntegral’
07:25:54 <lambdabot>      Perhaps you meant one of these:
07:25:54 <lambdabot>        ‘fromIntegral’ (imported from Prelude),
07:26:06 <Crazycolorz5> .... I'm bad at conversions lol
07:26:14 <c_wraith> you need round/floor/ceil to go that direction
07:26:24 <mauke`1> Crazycolorz5: you can use ghci locally or lambdabot in /query
07:27:17 <Crazycolorz5> c_wraith: you're right. Which would then use that insane value from before, and then the result after that is clear.
07:28:27 <dhalgren`> so wait, round/floor/ceil of NaN is more negative than the same on -Infinity? hah
07:28:53 <Crazycolorz5> Yeah that freaked me out
07:29:24 <cxdf> \quit
07:29:29 <Crazycolorz5> I guess it'd have to do with the underlying representation?
07:30:17 <dhalgren`> leaking? looks like it. then again ieee754 is odd
07:59:03 <Naujokelis> #haskell
08:22:05 <Sonarpulse> s
08:30:30 <sm> fun: http://adventofcode.com
08:31:33 <emmanuel_erc> Anyone here have experience with the repa library?
08:31:46 <StoneToad> some?
08:32:08 <emmanuel_erc> Are you responding to me StoneToad?
08:32:09 <StoneToad> ah, if you're much farther then the repa tutorial on the wiki, then I won't be able to answer your questions
08:32:22 <StoneToad> ah sorry emmanuel_erc, didn't notice the timestamp
08:33:15 <StoneToad> and yes, I was responding to you
08:33:44 <emmanuel_erc> Have you ever received this message : Data.Array.Repa Performing nested parallel computation sequentially.
08:33:44 <emmanuel_erc>  
08:34:11 <emmanuel_erc> (I shortened the message to not annoy everyone.)
08:34:19 <StoneToad> ah yes, that's warned about
08:34:29 <StoneToad> repa can't do nested parallel computations
08:35:03 <StoneToad> you're doing a compute_p inside another compute_p computation
08:36:54 <emmanuel_erc> I see where I made the error now. I am using selectP and computeP.
08:37:09 <emmanuel_erc> But I need the former function to grab multiple slices from an array.
08:37:19 <emmanuel_erc> slices <-> rows
08:37:21 <StoneToad> there shoudl be a selectS?
08:37:27 <StoneToad> and there is a computeS
08:37:41 <StoneToad> which does the calcs in series instead of parallel
08:37:45 <emmanuel_erc> right
08:38:28 <StoneToad> probably work better to change the inner one rather then the outer one, but I guess it depends on your workload and such
08:38:47 <StoneToad> change inner one to sequential*
08:39:11 <emmanuel_erc> I need the inner one for performing the floyd warshall algorithm.
08:39:59 <emmanuel_erc> I initially thought that I could use the traverse function, but that function doesn't seem to help when selecting multiple rows at once.
08:40:41 <emmanuel_erc> btw, the analogous function selectS doesn't exist.
08:41:44 <StoneToad> bummer D:
08:44:32 <StoneToad> well, you've run off the end of my knowledge.  Hopefully one of the people that joined up now that hte split seems over will know more
08:46:11 <emmanuel_erc> well thanks for trying to help StoneToad! It is aprreciated! 
08:49:09 <mtask> Can someone explain me this line: https://github.com/ghc/packages-base/blob/52c0b09036c36f1ed928663abb2f295fd36a88bb/GHC/Base.lhs#L147 ?
08:49:10 <mtask> I'm trying to understand how the Char type is defined.
08:53:22 <mtask> Good evening
08:54:03 <mtask> Can someone explain me this line https://github.com/ghc/packages-base/blob/52c0b09036c36f1ed928663abb2f295fd36a88bb/GHC/Base.lhs#L147 ?
08:54:21 <byorgey> hi mtask 
08:54:26 <mtask> I'm trying to understand how the Char type is implemented
08:54:40 <mtask> Hi byorgey!
08:55:01 <byorgey> mtask: the # symbols generally denote "magical built-in compiler stuff"
08:55:55 <byorgey> mtask: data Char = C# Char#  means "Char has a constructor called C#, which contains a Char#".   Char# is the name of the built-in (unboxed) character type
08:56:39 <byorgey> mtask: but I am not sure whether Char is actually implemented like that.  Note all that stuff is in a comment.
08:57:01 <byorgey> mtask: why are you trying to understand how Char is implemented?  Or what is it exactly you are trying to understand?
08:57:46 <mtask> byorgey: I'm want to know how the max and minBound are implemented, i.e., how are their values set
08:59:11 <byorgey> they're probably just hardcoded, based on the Unicode standard
09:00:06 <ogRefl> mtask: have a look at https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Enum.html
09:00:17 <mtask> byorgey: That was my guess too. Are they C foreign types?
09:00:33 <dutchie> https://github.com/ghc/packages-base/blob/52c0b09036c36f1ed928663abb2f295fd36a88bb/GHC/Enum.lhs#L351
09:01:32 <byorgey> mtask: no, I don't think so
09:02:21 <mtask> dutchie: Thank you, that's what I was looking for.
09:03:24 <mtask> Thanks everybody ;)
09:05:28 --- mode: tepper.freenode.net set +o ChanServ
09:14:53 <cow_2001> running "stack exec vim" makes vim complain about g:haddock_docdir
09:16:59 * hackagebot minilens 0.1.1.0 - A minimalistic lens library, providing only the simplest, most basic lens functionality.  https://hackage.haskell.org/package/minilens-0.1.1.0 (RaminHonary)
09:23:31 <wedens> how can I validate xml document against xsd schema in haskell?
09:37:28 <kritzcreek> what does "seq" stand for? I mean the evaluation forcing function
09:39:18 <FireFly> sequence I presume
09:39:43 <FireFly> as in, it evaluates its operands in sequence
09:42:00 * hackagebot minilens 0.1.1.1 - A minimalistic lens library, providing only the simplest, most basic lens functionality.  https://hackage.haskell.org/package/minilens-0.1.1.1 (RaminHonary)
09:45:35 <kritzcreek> I see. I can live with that
09:45:38 <kritzcreek> thank you^^
09:47:13 <ogRefl> kritzcreek: a `seq` b returns only after both a and b are evaluated. not necessarily in some sequence
09:47:40 <ogRefl> see doc of prelude: https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#v:seq
09:48:58 <albeit> When profiling by closure description, what do PS and Bin mean?
09:50:25 <kritzcreek> ogRefl:  okay... So it's not actually sequencing. I just started reading parallel and concurrent haskell and was puzzled about the naming of the function. A name like "force" sounds more appropriate
09:52:59 <ogRefl> kritzcreek: what are you trying to do?
09:53:13 <monochrom> etymology of "seq"
09:53:50 <kritzcreek> I was mostly curious^^ There is usually some fun story attached with strange names
09:54:13 <kritzcreek> like the car/cdr names for head and tail
09:58:35 <monochrom> my digging of a little bit of history suggests that "seq x y" used to mean to evaluate x first, rather than the modern day's vague "we don't know, we only know eventually"
10:00:54 <monochrom> John Hughes's web page recounts his contribution to Haskell. it says: laziness is great but sometimes uses more memory than you want, this can be solved by hastening the evaluation of carefully chosen subexpressions, so his contribution was adding one thing to let programmers specify what to evaluate earlier
10:01:26 <monochrom> then you look at all of Haskell around that time, and only "seq" comes close to fitting that description.
10:01:52 <monochrom> therefore "seq" had to mean "evaluate in sequence" at that time
10:02:04 <kritzcreek> so the initial understanding was sequencing but it turns out that weaker guarantees still capture the functions usecase
10:02:43 <monochrom> it's only later on that people decided to step away from that commitment and just say "Haskell is defined denotatinally only, so we don't know shit about seq"
10:02:44 <kritzcreek> great thank you for looking that up!
10:03:19 <monochrom> the problem is that once you concede to "we don't know shit about seq", seq no longer reduces memory usage
10:05:02 <ogRefl> monochrom: I think today you might use ($!) for that effect
10:05:14 <monochrom> ($!) is defined in terms of seq
10:05:23 <Cale> ogRefl: f $! x = x `seq` f x
10:05:43 <Cale> So basically seq used to mean pseq
10:05:57 <ogRefl> monochrom: where?
10:06:08 <monochrom> Haskell 2010
10:06:11 <ogRefl> sorry Cale: where?
10:06:17 <Cale> Where?
10:06:18 <monochrom> also Haskell 98, Haskell 1.4, etc
10:06:41 <Cale> Where what?
10:06:47 <ogRefl> oh. i was looking at Prelude source
10:07:04 <ogRefl> f $! x = let !vx = x in f vx
10:07:15 <albeit> Why would Data.Map.Strict use more memory than just a Data.Map? Wouldn't evaluating the values result in <= memory used?
10:08:31 <monochrom> bang pattern is also defined in terms of seq
10:08:57 <monochrom> resistance is futile
10:09:22 <ogRefl> :) i guess so
10:12:50 <monochrom> albeit, I can design a way to cause higher strictness to use more memory, and I can also design a way to cause higher strictness to use less memory.
10:14:34 <monochrom> "seq (fib 1000000) ()" uses more memory than "const () (fib 10000000)" if fib 1000000 takes 10GB to evaluate.
10:15:42 <ogRefl> again, that's only because seq returns.
10:16:02 <sm> this is weird. Network.Wreq.Session defines withSession as: withSessionWith defaultManagerSettings. But in my code, "withSession" works while "withSession defaultManagerSettings" gives TlsNotSupported. 
10:16:35 <sm> how could this be ?
10:18:01 <sm> aha! wreq's defaultManagerSettings shadowed by http-client's
10:19:06 <ogRefl> albeit: a lazy Map will only evaluate the value if you look at it.
10:21:01 <ogRefl> albeit: i mean evaluate it. until then they are stored as thunks.
10:21:22 <sm> or rather: use tlsManagerSettings from http-client-tls, not defaultManagerSettings
10:22:29 <albeit> Okay figured out Maps aren't the issue. For 10 lists each of length 3000, does it make sense that the list type "[]" in heap profiling is taking ~700KB? Or is there probably a space leak going on?
10:22:43 <albeit> Is there really that much overhead for lists?
10:23:02 <monochrom> each cons cell is 24 bytes on 64-bit GHC
10:23:14 <monochrom> > 10*3000*24
10:23:15 <lambdabot>  720000
10:23:22 <albeit> Wow. Dead on
10:23:28 <albeit> Thanks monochrom 
10:23:53 <monochrom> it could be worse. the garbage collector does a 2-space thing. (think of it like double-buffering in computer graphcis)
10:24:16 <Denommus> what does it mean to say "type Foo is just type Bar composed with the list constructor"?
10:24:16 <albeit> monochrom: Do you know approximately how much overhead space each "cell" in a Map takes?
10:24:34 <monochrom> therefore if you have 700KB of actual data, sometimes the memory footprint can go up to 1400KB, just for the sake of the garbage collector
10:24:35 <Denommus> for instance, I have the type Behavior a
10:24:42 <Denommus> now, Event is Behavior composed with the list constructor
10:24:46 <Denommus> how should I understand that?
10:25:05 <jerv> what's a more idiomatic way to write not (isMatch ".*str1.*" x) && not (isMatch ".*str2.*" x) && ...
10:26:30 <lyxia> jerv: all (\pat -> not (isMatch pat x)) [".*str1.*", ...]
10:27:29 <monochrom> "Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)". Bin(8 bytes) {-# UNPACK #-} !Size(8 bytes) !k(8 bytes) a(8 bytes) !(Map k a)(8 bytes) !(Map k a)(8 bytes)
10:28:19 <monochrom> > 6*8
10:28:21 <lambdabot>  48
10:28:22 <ogRefl> monochrom: where is this from?
10:28:39 <monochrom> Data.Map source code, "data Map k a = ..."
10:28:58 <monochrom> 48 bytes per internal Node.
10:29:11 <c_wraith> monochrom: you didn't count the gc overhead word, I think. 
10:29:25 <monochrom> the leaf Tip is essentially free. one instance in the memory, shared by all.
10:29:42 <monochrom> there is no such thing
10:30:04 <c_wraith> The bitmap indicating which fields are pointers? 
10:30:15 <monochrom> one static copy shared by all
10:30:45 <c_wraith> I'm pretty sure it's not shared, due to type erasure. 
10:31:20 <darkmercenary> hey guys, im using a yesod template and its using an older stackage lts. is there any way i can update my project to use the latest stackage lts?
10:31:33 <monochrom> show me GHC-generated Cmm code that allocates, on the heap, what you said.
10:31:42 <c_wraith> And also due to one of the Simons saying so in am SO answer. 
10:33:19 <dhalgren`> https://wiki.haskell.org/GHC/Memory_Footprint
10:33:19 <dhalgren`>  
10:34:51 <lazy8> does hskell use only pure functions
10:35:14 <c_wraith> Oh, you did include it. It's shared with the constructor selector. 
10:37:03 <Denommus> lazy8: impure functions are explicit on the type signature
10:38:29 <c_wraith> Denommus: that's a matter of some contention. I happen to claim a function returning an IO value is a pure function. 
10:39:07 <c_wraith> However, there's no one who claims you can't use various unsafe functions to create very impure functions. 
10:40:52 <Denommus> c_wraith: it's also a matter of what you actually mean by pure
10:41:48 <Denommus> c_wraith: ... although, yeah, even "impure" functions are actually just pure functions that delineate the instructions to perform side-effects
10:42:20 <c_wraith> Denommus: no, I mean really completely impure. :) 
10:43:07 <Drezil> how do i remove compiled stack-stuff from old buildplans?
10:43:29 <Drezil> i got a lot of lts-3.5-stuff installed and i want to remove it as i migrate to lts-3.16..
10:43:46 <c_wraith> Denommus: I mean like..  http://lpaste.net/92226
10:44:37 <c_wraith> Denommus: no matter how you define pure, those functions are not it. :) 
10:45:50 <ogRefl> c_wraith: what side effects do they do?
10:45:53 <Denommus> c_wraith: ah, yes, I know unsafe functions break that
10:46:02 <Denommus> c_wraith: I was talking about safe functions, though
10:46:25 <c_wraith> ogRefl: their results depend on their evaluation order. 
10:46:39 <Denommus> ok, I don't understand how Event a can be Behavior [a]
10:47:41 <ogRefl> c_wraith: doesn't the monad force them to order?
10:47:51 <albeit> Another question on space usage. I'm using ByteString.Char8, and measuring the length of all the ByteStrings I get 124,000. I believe each should take a single byte, so 124KB, but heap profiling says almost 1000KB - why?
10:48:36 <c_wraith> ogRefl: ST normally enforces an order, but unsafeInterleaveST breaks that rule. 
10:50:24 <monochrom> just like unsafeInterleaveIO gives you "lazy" I/O
10:51:27 <opqdonut> albeit: there's also overhead. how many byte strings do you have? are they lazy? also, you might have old versions lying around
10:52:31 <c_wraith> Bytestrings are not good for short data. They have a fixed overhead of a few pointers to make slicing efficient 
10:53:37 <lazy8> Does haskell have any 00 
10:53:58 <monochrom> yes. just no class.
10:54:24 <Denommus> lazy8: 00?
10:54:32 <albeit> opqdonut: c_wraith: I have about 30,000 (strict), each of length around 3-4. I'm guessing the overhead explains it then.
10:54:40 <monochrom> oh, 00 vs OO :)
10:54:47 <monochrom> haskell has 00 too.
10:54:52 <Denommus> :t 00
10:54:53 <lambdabot> Num a => a
10:55:05 <monochrom> Haskell has polymorphic 00
10:55:18 <Denommus> :i Num
10:55:29 <monochrom> too bad lambdabot doesn't have :i
10:55:30 <Denommus> ah, I always forget lambdabot doesn't have :i
10:55:43 <lazy8> I am trying to leran haskell I've been using java for a while now
10:55:56 <monochrom> I too learned Haskell after Java
10:56:15 <Denommus> lazy8: it's completely different, don't expect to program like Java in Haskell
10:56:20 <monochrom> all I needed to do was forget Java, then Haskell became easy to learn
10:57:53 <monochrom> after I finished learning Haskell, I brought Java back, and got: http://www.vex.net/~trebla/humour/Nightmare.java
10:58:22 <lazy8> I'd rather use C++ than java
10:58:36 <moop> i'd rather use java than haskell
10:58:36 <Denommus> monochrom: why?
10:58:49 <monochrom> hmm it was written before Java Generics. I should update it for maximum coolness
10:59:00 <monochrom> because it is funny
11:01:28 <ogRefl> I'd rather use Haskell that Assembly :P
11:01:35 <ogRefl> than
11:02:01 <lazy8> I'd rather use VB.net than haskell
11:02:03 <mauke> I'd rather be rich and happy than poor and miserable
11:02:51 <monochrom> I would rather be rich or poor than rich and poor
11:03:02 * Clint squints.
11:03:16 <ogRefl> you meant you'd rather be used by VB.net
11:03:33 <mnoonan> monochrom: the same thing happened to me with C++: http://codegolf.stackexchange.com/a/37749
11:04:39 <mauke> https://raw.githubusercontent.com/mauke/poly.poly/master/yes.c
11:05:10 <mauke> after learning Haskell I went back to C and Perl
11:05:37 <lazy8> The only good language that microsoft has made is C#
11:06:27 <mauke> (I'd rather use Haskell and C and Perl than Haskell or C or Perl)
11:06:34 <Zekka|Sigfig> I don’t think it’s that hard to write Java in Haskell, but imho it’s harder than writing Haskell in Haskell
11:06:43 <javjarfer> Hi there! Anyone knows why lines is implemented this way in prelude? http://tinyurl.com/ofmagfv
11:06:46 <ogRefl> The only good language that microsoft has made is BASIC
11:07:08 <bollu> ogRefl: C#?
11:07:25 <monochrom> because it's one correct way
11:07:32 <javjarfer> Wouldn't be nicer a simple pattern-matching implementation?
11:07:53 <monochrom> what is a simple pattern-matching implementation?
11:08:08 <monochrom> and is it correct?
11:08:59 <javjarfer> well, I don't really know if that implementation is there for performance reasons, so which is your measure for "correct"?
11:09:19 <lazy8> If you grow a beard you will be a lot better at programming
11:09:28 <monochrom> I am not into performance yet. at present even getting the correct answer is tricky enough.
11:09:36 <ogRefl> bollu: C# is bloating just like C++ started 10 years ago
11:09:55 <lazy8> Only reason is because of the legacy
11:11:06 <ogRefl> lazy8: Microsoft Achilles heel
11:11:30 <lazy8> Kind of like perl 4 to 5
11:11:47 <monochrom> if you don't have a simple pattern-matching implementation, well-tested and ready to show, then tautologically there is at present nothing to compare.
11:12:52 <c_wraith> We're in #haskell, so let's be fair to Microsoft. They put a lot of money over a lot of years into the development of GHC, and we've all benefitted from it. 
11:13:04 <Denommus> monochrom: implementing it using Writer is also cool
11:13:53 <ogRefl> c_wraith: and we thank them for that.
11:14:15 <dhalgren`> c_wraith: you mean by giving SPJ a paycheck to work on it or is there even more to it?
11:14:53 <c_wraith> dhalgren`: SPJ and several others. But yes, via Microsoft research 
11:15:06 <dhalgren`> yy, got it
11:15:13 <javjarfer> monochrom: well I have one, but I'm reviewing it, beacause your anwser saying that is tricky enough has make me think that I should have something wrong
11:15:38 <lazy8> Linux is better than windows at a lot of thing and windows is better than Linux at others
11:16:24 <dhalgren`> its hard to be wrong with that kind of a statement :)
11:17:12 <joehillen> https://twitter.com/RanjitJhala/status/672119749896048641
11:17:21 <ogRefl> lazy8: i was aiming at language standards bloat when trying to add more and more programming paradigms.
11:18:19 <ogRefl> lazy8: C++, C#, Java, ...
11:19:15 <javjarfer> monochrom: ok, I was wrong, thanks you
11:20:43 <zipper> Hello, I want to create a value of type Response from Network.Wreq in case I get an IO error from the get function in wreq
11:20:49 <zipper> How can I do this? https://hackage.haskell.org/package/wreq-0.4.0.0/docs/Network-Wreq.html#t:Response
11:21:06 <zipper> https://hackage.haskell.org/package/wreq-0.4.0.0/docs/Network-Wreq.html#v:get
11:22:13 <Denommus> zipper: if you get an IO error, you'll get an exception
11:23:49 <zipper> Denommus: I want to catch it
11:23:58 <Denommus> zipper: well, you catch it as a normal exception
11:24:03 <lazy8> Does haskell support GOTO
11:24:06 <zipper> Denommus: Yes
11:24:21 <Denommus> lazy8: goto doesn't make sense in Haskell's context
11:24:25 <monochrom> haskell supports lambda the ultimate GOTO
11:24:33 <zipper> I understand that but I am using catchIOError http://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO-Error.html#v:catchIOError
11:24:34 * Clint twitches.
11:24:51 <c_wraith> lazy8: sure. See that package that embeds BASIC in haskell. 
11:25:04 <zipper> Denommus: So I have to create a value of `IO Response ByteString`
11:25:12 <zipper> While catching the exception.
11:25:27 <monochrom> google for "lambda the ultimate goto" for a lot of goodies
11:25:27 <Denommus> zipper: http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception-Base.html#v:catch
11:25:42 <Denommus> zipper: in the handler, you return a Response ByteString
11:26:03 <zipper> Denommus: My problem is how to create a Response ByteString
11:26:44 <monochrom> you can rethrow the exception, you know
11:26:52 <Denommus> zipper: does the Response have a default value?
11:27:33 <zipper> Denommus: I don't think so. I want to report "Fetch failed"
11:27:47 <zipper> monochrom: What do you mean I can rethrow? I want to handle the error.
11:28:36 <monochrom> that has consequences on the type
11:28:45 <Denommus> zipper: uh, why do you need to embed it in a Response?
11:28:50 <zipper> Code here http://lpaste.net/6263404082531139584
11:29:11 <Denommus> zipper: why not, I dunno, using an EitherT or something?
11:29:32 <Denommus> zipper: besides, I don't think Wreq's get actually throws exceptions
11:29:40 <Denommus> zipper: I think it returns Responses that fail
11:29:43 <Denommus> zipper: though I'm not sure
11:30:21 <zipper> Denommus: Look at error handling http://www.serpentine.com/wreq/tutorial.html
11:30:30 <zipper> It does
11:30:46 <zipper> Anyway you mean have the whole function return an either?
11:31:45 <zipper> I thought I have to catch it in the `get` section since it's the offending one.
11:31:47 <Denommus> zipper: an EitherT ByteString IO Response
11:31:56 <Denommus> zipper: this way, you can just liftIO get
11:31:57 <zipper> i.e L4
11:32:08 <zipper> Oh I see :)
11:32:57 <Denommus> zipper: although you would not *exactly* just liftIO get, because then you wouldn't deal with exceptions XD
11:33:04 <Denommus> zipper: but you could use this, for instance: https://gist.github.com/Denommus/93acfd5241210c31a1de
11:33:33 <zipper> Denommus: What do you mean I could use liftIO? How?
11:33:40 <zipper> Oh yeah
11:33:46 <zipper> yeah I get what you mean
11:34:12 <Denommus> zipper: this gist's liftErrorIO transforms an exception-based workflow into a MonadError workflow
11:34:22 <Denommus> zipper: ExceptT implements MonadError
11:34:36 <Denommus> zipper: (I said EitherT before, but I actually should have said ExceptT)
11:35:18 <zipper> Okay, I see we're talking monad transformers here and I'm not familiar with them.
11:35:39 <zipper> I am also quite sleepy. I'll retire and read the logs later.
11:35:43 <zipper> Thanks Denommus monochrom 
11:36:45 <athan> Denommus: I just started using MonadThrow and MonadCatch, and am very happy with its black magic
11:36:53 <Denommus> oh, I'm stupid, liftErrorIO would actually cast it to Exception e => ExceptT e IO (Response a)
11:38:33 <Denommus> athan: I was wondering how my liftErrorIO solution would deal with async exceptions...
11:38:49 <Denommus> athan: but, to be completely honest, I hate exceptions
11:39:03 <Denommus> athan: liftErrorIO was my take on completely eliminating them from my code
11:39:49 <athan> Denommus: MonadThrow and MonadCatch don't have an exception type argument :P
11:40:17 <athan> when you use `somethingThrowing catch (\e -> catchThing e)`, the `e` can be any type that's thrown
11:40:53 <athan> if you throw some IO exception, it will get caught in catchThing, so long as its cast to that exception type
11:41:01 <Denommus> athan: catch :: Exception e => m a -> (e -> m a) -> m a 
11:41:03 <athan> then you can just `catch` all the types of errors you throw
11:41:41 <Denommus> athan: I'm seeing an Exception e there :-P
11:41:53 <athan> You might have to catch them in a tricky place, to stay in async's context
11:42:00 <athan> Denommus: The catcher should be monomorphic
11:42:18 <Denommus> athan: well, the type must instance Exception nevertheless
11:42:19 <athan> and using `SomeException` would catch all of them
11:42:33 <athan> Yes, it does need to implement Typeable, for the black magic stuff
11:43:35 <Denommus> athan: what really interests me is: does it allow me to make Exceptions explit rather than implicit?
11:44:43 <athan> Denommus: That's the compromise - you won't be able to constrain your exception type to a single one, like MonadError does
11:44:51 <athan> but, I think that compromise is actually a feature :)
11:45:12 <Denommus> athan: no, I mean, will my functions that throw exceptions always be clear?
11:45:25 <Denommus> athan: or can I swallow the exceptions in my type signature?
11:45:54 <athan> @type throwM
11:45:55 <lambdabot>     Not in scope: ‘throwM’
11:45:55 <lambdabot>     Perhaps you meant one of these:
11:45:55 <lambdabot>       ‘throw’ (imported from Control.Exception),
11:45:58 <athan> mer
11:46:21 <athan> Denommus: `throwM :: Exception e -> e -> m a`
11:46:42 <athan> man
11:46:49 <athan> second try
11:47:00 <athan> Denommus: `throwM :: (MonadThrow m, Exception e) => e -> m a`
11:47:31 <athan> Denommus: `catch :: (MonadCatch m, Exception e) => m b -> (e -> m a) -> m a` (I think)
11:47:49 <athan> the actual exception's type gets swallowed
11:47:58 <athan> but your natural logic in the monad is fine
11:49:12 <athan> this is opposed to `throwError :: (MonadError e m) => e -> m a`, which forces you to use one error type throughout your stack
11:51:32 <Sonolin> nice... would you say that's worth learning first (over MonadError)?
11:51:51 <Sonolin> seeing some uses for exceptions in my code, and was thinking of implementing MonadError
11:52:39 <Sonolin> I guess the throwM solution is more generic (right?) which sounds nicer to me
11:57:21 <zipper> Turns out it's not even an IO error it's "TlsExceptionHostPort (HandshakeFailed (Error_Protocol ("expecting server hello, got alert : [(AlertLevel_Fatal,HandshakeFailure)]",True,HandshakeFailure))) "nairobilug.or.ke" 443"
12:08:23 <albeit> What would be the most efficient way to generate a Set from [[a]]? foldr Set.insert Set.empty $ concat myLists?
12:08:57 <albeit> Or maybe foldr (Set.insert . Set.fromList) Set.empty myLists?
12:09:14 <albeit> * Set.union not Set.insert on the second one
12:09:19 <c_wraith> albeit: Set.fromList
12:09:37 <c_wraith> albeit: with the concat
12:09:54 <albeit> c_wraith: Oh yeah. Thanks!
12:10:07 <albeit> Didin't realize I was recreating that
12:10:44 <c_wraith> albeit: it uses some clever tricks to be O(n) in some common cases, too
12:18:37 <zv> This channel gets a ton of questions and I hate to be another in the flurry but I have researched this somewhat thoroughly without a satisfactory answer. Here goes: What make a particular type system sound? Beyond the standard classifications of static, weak, etc. Say I was to evaluate a type system of a new language, or a "type system" of something like javascript's Flow; what could I sensibly look for in suc
12:18:43 <zv> h a system?
12:24:10 <solidus-river> zv: what perspective are you coming at this from, does it have abstract types, generic types, templated types, can you derive types from others
12:24:13 <solidus-river> does it have type classes
12:24:22 <solidus-river> does it typecheck at compile time or run time
12:24:33 <solidus-river> etc etc, lots of things to evaluate beyond static, weak...
12:32:09 <zv> solidus-river: Lets say we're dealing with a compile time type checker.
12:32:50 <zv> Your first point is a good answer in it's own right: Where could I find a list of widely respected disciplines of typing and their features.
12:33:17 <zv> What is the fundamental literature in this field?
12:33:56 <solidus-river> zv: sorry, i have no good answers for that :X
12:34:16 <lyxia> Types And Programming Languages, by Benjamin Pierce might interest you
12:34:50 <zv> lyxia: thank you
12:34:55 <liaod_> @lyxia that's my professor!
12:34:55 <lambdabot> Unknown command, try @list
12:35:02 <solidus-river> mathmatically i'd take a whack at whether or not a type system is sound having to relate to whether or not its type signature inferrence functions ar valid with respect to the languages semantics
12:35:02 <kadoban> zv: You'd look for … "can I represent real models in this system, and what mistakes does it prevent me from making?"
12:35:18 <solidus-river> but i cant formally apply that to a language
12:35:27 <zv> kadoban: That evaluation is really tricky.
12:35:33 <zv> solidus-river has said it better than myself
12:35:35 <kadoban> zv: True
12:38:00 <zv> The 'type system' for javascript Flow motivated my interest in this initially, it seems woefully incomplete but I would have a difficult time providing some formal description of it's inadequacies.
12:39:00 <zv> I am not a huge haskell user but I do use Rust daily and it actually permits for useful information to be encoded into types that prevent me from making mistakes later. Systems like Flow or C's typing seem very superficial.
12:39:24 <zv> I think Benjamin Pierce sounds like a fantastic start
12:40:53 <Zemyla> Is there any kind of framework for computations that can be aborted, serialized, and resumed on another machine?
12:42:57 <zv> Zemyla: OCaml provides this in the form of fnmarshall
12:44:01 <zv> Zemyla: of course, marshalling arbitrary functions turns out to be error prone. In particular, in order to send a function over the wire, you also have to send a copy of any data that that function implicitly depends on.
12:50:51 <Zemyla> zv: Asctually, what I want is probably even more unrealistic. I want to be able to run a calculation, abort it at an arbitrary point, serialize it, and resume it on another machine. But I don't know how to do that other than creating a simple virtual machine for it.
12:53:55 <solidus-river> Zemyla: define the calculations total state, and always keep that state up to date
12:54:25 <solidus-river> Zemyla: serialize its state over to another machine when needed, it'd be inneficient and slow but would get what you want out of it
12:55:25 <Arahael> Ze~.
12:55:39 <Arahael> Zemyla: There's also Erlang.
12:56:15 <Arahael> Zemyla: That language is designed to be fault tolerant, even when computers crash.
12:56:39 <solidus-river> Zemyla: but its super opinionated about program structure
12:56:41 <Arahael> Though, I do have to mention that I haven't actually used it...
12:56:43 <zv>  I've written a database in Erlang and then rewrote it in Elixir as well as working for a telecom writing Erlang -- Erlang is not your pal if you want to do this.
12:57:16 <Arahael> zv: That's an interesting point.  Do you have an article to back that up?
12:57:17 <zv> Erlang is a very particular kind of fault tolerant that gets lost in the mist of communication.
12:57:40 <zv> Arahael: how in principle would an article back up such a statement? 
12:57:46 <Rembane> Zemyla: Have you looked into Cloud Haskell? It should do what Erlang does but in Haskell.
12:58:07 <Arahael> zv: Such an article would discuss Erlang's fault tolerances, and it's pitfalls and weaknesses therein.
12:58:11 <zv> "I believe that Erlang is great for sending incomplete computations across the network", "I think it isn't"
12:58:23 <Arahael> zv: ...  Or that.
12:58:36 <zv> Arahael: I am directing my question specifically at incomplete computation.
12:59:02 <zv> Arahael: I think you are spot on for a description of the language at large.
12:59:22 <Arahael> zv: Could you elaborate though - I've missed the distinction.
13:00:45 <zv> Well, let's think about how we *might* design such a system in erlang. There may be an academic or mathematical discipline that addresses these sort of questions directly and has though about them at length, but I won't include any of that because I don't know about it.
13:00:55 <zv> So in summary, this is a naive approach.
13:02:20 <zv> We're to compute ANY function, stop at some point in the middle, and send it elsewhere. We cannot exploit any knowledge about the program itself (i.e, by sending some subset of local variables central to the problem and then sening them on)
13:03:53 <zv> So the first problem that arises here is that there is no way to do this in general without invoking an FFI to process_vm_read
13:05:14 <Rembane> What about rewriting all functions automatically to have breakpoints quite often and then built somekind of runtime around that?
13:05:23 <zv> or whatever the equivalent is on your operating system (I think it's something like VirtualAllocEx in win32)
13:05:37 <Zemyla> zv: Is it simplified by the fact that want to calculate a pure function with no dependencies on lazy IO?
13:05:47 <zv> Rembane: exactly -- this is what you would do with process_vm_write/read -- You set int 3 and set a handler.
13:06:04 <Rembane> zv: Oh. That sounds super easy. What's the catch?
13:06:32 <zv> Zemyla: I think it very well might be, but that is within the domain of the aforementioned academic discipline that I know nothing about.
13:07:09 <zv> So, you either go with process_vm_readv/Rembane approach or you use erlangs "abstract forms" facilities.
13:08:06 <zv> This is tricky, because abstract forms are basically just a way to parse and modify the AST of an erlang program before "compilation" (which can mean either real compilation, or swapping)
13:10:40 <zv> So you need to recover the A. local mailbox for each node operating in the runtime context using an abstract form. B. serialize the current atom dictionary and then C. sift through the heap for relevant allocations D. send that, presumably as BEAM VM bytecode and marshalled data and use an undocumented feature of the BEAM vm to 'cave' out some of the processes address space.
13:11:01 <zv> Arahael: That is why I say I think it would be tricky in Erlang
13:11:11 <Zemyla> I think the simplest way to do it would be to break it down into a number of steps, and store the state in a TVar, which is read, operated on, and then atomically written.
13:12:13 <zv> Zemyla: if you come up with something or uncover some literature on the 'best' way to do this, I would love to know about it!
13:20:40 <peter_> hello
13:21:05 <peter_> anyyyone here?
13:21:13 <dmj> peter_: yes
13:22:52 <peter_> i am a data person, i do a lot of pyython work and other data specific platform coding, i'm wondering if yyou have anyy suggestions for intermediate haskell learning
13:22:53 <peter_> also
13:22:59 <peter_> i want to run haskell on arch
13:23:14 <peter_> and the haskell pacman repos appear to be down
13:23:31 <peter_> so if anyyone on here does haskell on arch and has suggestions, that would be aweomse
13:24:51 <wraithm> peter_: I'd recommend installing stack via pacaur
13:24:57 <suppi> peter_, you might want to use stack, a build manager that can install ghc for you http://docs.haskellstack.org/en/stable/install_and_upgrade.html#arch-linux
13:25:01 <dmj> peter_: https://github.com/bitemyapp/learnhaskell
13:25:17 <wraithm> (or whatever AUR manager you use)
13:25:21 <dmj> peter_: anything by Brent Yorgey, especially the typeclassopedia
13:25:34 <peter_> awesome
13:25:43 <peter_> thank you, everyone, for the suggestions
13:26:31 <dmj> @google typeclassopedia
13:26:32 <lambdabot> https://wiki.haskell.org/Typeclassopedia
13:31:10 <koz_> Is there something I'm missing about Data.Tree? It doesn't seem to have any functions to make new trees with modifications.
13:31:30 <koz_> Unless I should be using something else?
13:31:51 <deepfire> good time of day, folks
13:32:08 <deepfire> can anyone explain me what RegularPatterns extension is?
13:32:32 <deepfire> was it deprecated and removed?
13:37:08 <c_wraith> Never heard of it. Fully removing extensions is rare, though. 
13:37:55 <c_wraith> Was it maybe an extension in a non-GHC compiler? 
13:38:13 <phadej> https://hackage.haskell.org/package/harp
13:39:32 <c_wraith> Oh. A preprocessor. That makes sense. 
13:42:09 * hackagebot JuicyPixels 3.2.6.4 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.6.4 (VincentBerthoux)
13:46:42 <peter_> hello
13:46:50 <peter_> back about installing haskell on arch
13:47:02 <peter_> i should have clarified..
13:47:08 <peter_> i am running on a raspberry pi
13:47:17 <peter_> so weird architecture
13:47:28 <peter_> rocking the arm7
13:47:44 <peter_> haskell-stack doesnt like that :{
13:48:25 <Sonolin> are you cross-compiling peter_?
13:48:29 <peter_> nope
13:48:32 <peter_> or at least
13:48:49 <Sonolin> I haven't successfully compiled GHC for my chromebook, failing at ncurses-arm...
13:48:50 <peter_> i am not now, but if thats a thing i need to do.. sure
13:48:52 <lyxia> koz_: What do you mean?
13:49:06 <Sonolin> I think you might, but you might get lucky if there's a rPi package
13:49:12 <peter_> there is
13:49:15 <peter_> for raspian
13:49:18 <Sonolin> ah nice
13:49:31 <peter_> but i'm being difficult :]
13:50:06 <peter_> like... is the idea to  compile from git?
13:50:43 <Sonolin> I'm following this:
13:50:44 <Sonolin> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
13:52:39 <Sonolin> https://aur4.archlinux.org/packages/?O=0&SeB=nd&PP=100&do_Search=Go&K=ghc
13:52:46 <Sonolin> looks like there's also ghc-raspbian there
13:54:43 <peter_> i also see ghc7.8
13:54:54 <peter_> would it be better to load that
13:55:04 <peter_> or ghc-raspbian-bin
13:55:27 <Sonolin> I think the ghc7.8 is only for x86
13:55:44 <Sonolin> https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=ghc7.8-bin#n16
13:55:49 <peter_> got it
13:55:49 <peter_> i
13:55:56 <peter_> i'll do  the  raspian
13:57:56 <peter_> funnyy
13:57:59 <peter_> same error
13:58:05 <peter_> armv7
13:59:24 <koz_> Am I right to assume that find returns Nothing if given an empty list to search?
13:59:35 <koz_> I'm 99% sure I'm right, but I want to be certain.
14:00:28 <lyxia> > find (const True) []
14:00:33 <lambdabot>  mueval-core: Time limit exceeded
14:00:38 <lyxia> what
14:00:51 <lyxia> koz_ you are right
14:01:06 <lyxia> > find (const True) []
14:01:08 <lambdabot>  Nothing
14:01:25 <koz_> lyxia: Thanks. Why did lambdabot go infinite previously?
14:01:37 <lyxia> No idea
14:01:38 <geekosaur> the bot sometimes times out spuriously, possibly because it's on a low cpu vm instance
14:01:44 <koz_> > find (const True) []
14:01:47 <lambdabot>  Nothing
14:01:49 <koz_> OK.
14:03:32 <Denommus> hah! Got Nix to work on Arch!
14:12:10 * hackagebot libravatar 0.1.0.2 - Use Libravatar, the decentralized avatar delivery service  https://hackage.haskell.org/package/libravatar-0.1.0.2 (akrasner)
14:22:11 <zv> Denommus: nix packages?
14:22:15 <zv> Denommus: like nixos?
14:26:00 <deepfire> phadej, thank you!
14:29:20 <greymalkin> Denommus: Watch out for libz.
14:29:57 <greymalkin> You'll want to make sure you include --extra-include-dirs=$HOME/.nix-profile/include --extra-lib-dirs=$HOME/.nix-profile/lib in your cabal builds from here out.
14:30:43 <greymalkin> Or, at least, that's what I had to start doing after I got nix on Arch.
14:32:59 <Denommus> zv: the nix package manager
14:42:11 * hackagebot aeson-iproute 0.1.0.0 - Aeson instances for iproute types  https://hackage.haskell.org/package/aeson-iproute-0.1.0.0 (sickmind)
14:51:58 <dmj> anyone know if there is a haskell DSL that targets HiveQL
14:57:11 * hackagebot wolf 0.2.2 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.2 (markfine)
15:00:54 <Hi-Angel> Hello, I'm just wondering — perhaps have anybody seen some LSTM networks implementation in Haskell?
15:21:40 <rodamber> hello?
15:22:50 <Cale> hello
15:26:10 <SaidInABox> hello
15:26:21 <Cale> hi
15:29:19 <danilo2> Hello guys! :) Is there in haskell any type family that will convert a given type to a Nat describing how many bits that type uses? I need it for basic types like `BitBase Word8 = 8`
15:31:19 <cite-reader> > bitSizeMaybe (undefined :: Word8)
15:31:20 <lambdabot>  Just 8
15:31:29 <kadoban> danilo2: Not exactly what you're looking for, but couldn't you use finiteBitSize from FiniteBits?
15:31:34 <kadoban> Or that.
15:31:52 <cite-reader> Oh, I misread that; I don't think we have this at the type level.
15:31:59 <cite-reader> Could be wrong.
15:36:46 <danilo2> kadoban: no, because this is run-time and I need compile-time one
15:37:42 * hackagebot aeson-iproute 0.1.1 - Aeson instances for iproute types  https://hackage.haskell.org/package/aeson-iproute-0.1.1 (sickmind)
15:51:48 <koz_> Is there a type for 'list with at least one element'?
15:53:03 <geekosaur> NonEmpty in semigroups package?
15:53:29 <koz_> geekosaur: Thanks!
15:57:08 <emmanuel_erc> hello there, have any of you installed ghc-vis before (possibly on Arch Linux)?
16:11:47 <albeit> I'm using foldl' to generate a ByteString.Builder and writing to a file with hPutBuilder, but nothing is output until the fold is complete. Is there any way to output as the Builder is generated?
16:12:29 <glguy> generate it with foldr
16:13:36 <athan> glguy: What about foldM? Encode the putting in the >=> at the same time as the generation?
16:13:39 <athan> idk
16:14:46 <bitemyapp> glguy: hey got a quick question
16:15:12 <bitemyapp> glguy: is there a reason I haven't seen Hutton-Meijer variants that are transformers without the [] having been replaced with Monad m => m?
16:15:51 <bitemyapp> glguy: everything that's a ParserT either replaces [] with m or handles ambiguous choice with a recursive parser type instead of lists.
16:16:24 <athan> bitemyapp: ParserT?!? where where :|
16:16:27 <glguy> albeit: Observe that this streams to the screen nicely:
16:16:30 <glguy> hPutBuilder stdout (fix (char7 04'a' 07<>))
16:16:49 <glguy> albeit: Treat the builder like a lazy list, not an actual bytestring, it's not a bytestring but instructions for populating one
16:16:52 <bitemyapp> athan: ParsecT has been around for awhile I think.
16:17:06 <athan> herp
16:17:14 <bitemyapp> athan: but yeah, ParserT is what I'm trying to plumb and I can't find prior art for what I had in mind.
16:17:17 <bitemyapp> and it worries me
16:17:19 * athan crawls back into cafe
16:17:26 <albeit> glguy: My issue is that what I add to the Builder at index i depends on what index i-1 was..
16:17:31 <bitemyapp> which means people either diverged from H-M parsers before transformers or there's something I am missing here.
16:17:44 * hackagebot io-streams 1.3.3.0 - Simple, composable, and easy-to-use stream I/O  https://hackage.haskell.org/package/io-streams-1.3.3.0 (GregoryCollins)
16:17:55 <athan> bitemyapp: I think studying Earley parsing will be fruitful, but I haven't done it yet :)
16:17:59 <glguy> albeit: You can still write that with foldr (or just with explicit recursion)
16:18:36 <bitemyapp> athan: Earley parsers are on my radar, but not pedagogically relevant in this case. I'm trying to make sure I haven't happened upon something impossible or fatally flawed.
16:19:08 <albeit> glguy: Okay. I was carrying over the value of the previous thing looked at, but when I switch everything to foldr that previous value is actually the next value (at i+1). How can I write it with foldr then?
16:19:15 <bitemyapp> I know it's probably tantamount to ~ StateT ListT, which may be the reason nobody's bothered.
16:20:20 <glguy> hPutBuilder stdout (foldr (07\x rec i 07-> word8Hex i 07<> rec (fromInteger x07+i)) (07\_ 07-> mempty) [04107..] 040)
16:20:33 <glguy> that also streams nicely and allows you to carry along a value
16:21:12 <glguy> bitemyapp: You're asking why parser monad's are parameterized on a backtracking implementation?
16:21:48 <bitemyapp> glguy: that's not precisely my question, but I think the answer will be helpful and lead to a better question anyway.
16:23:12 <glguy> I haven't really thought about the problem either way, but I'd look to see if there were more assumptions than Monad that needed to be made to implement the backtracking operations so that they'd work with the token stream correctly
16:23:28 <glguy> and also that having that generalization might lead to code that didn't optimize well and was just generally slow
16:23:34 <glguy> but that's all I have off the top of my head
16:23:44 <bitemyapp> glguy: hrm, I don't think that addresses my worry/curiosity
16:23:52 <glguy> sorry:)
16:24:04 <bitemyapp> glguy: I'm asking why there isn't a ParserT that is based on Hutton-Meijer parsers
16:24:21 <albeit> glguy: Is that style of foldr where the accumulator is a function called something? A little confused and looking for another example
16:24:28 <bitemyapp> glguy: my _guess_ is because either the type is impossible or has the same problems as ListT, but I don't actually _know_ and literature doesn't address it.
16:25:41 <glguy> albeit: I don't know if it has a name. I have an example of deriving an implementation of foldl with foldr https://www.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b
16:25:46 <glguy> maybe that could help?
16:26:38 <glguy> bitemyapp: Looking at the type of this parser I think I understand what you were asking, but I don't know enough about HM parsers to answer without reading more
16:26:47 <bitemyapp> fuck
16:27:03 <ReinH> (Pedantic note that the parameter to foldr is not really an accumulator. It doesn't accumulate.)
16:27:05 <bitemyapp> glguy: thank you
16:27:28 <glguy> It looks like a ReadS parser, is there more?
16:28:07 <bitemyapp> glguy: ReadS is precisely an H-M parser without the newtype and FAM instances.
16:29:48 <glguy> to be able to implement +++ as they have it you'll need an operation that restricts backtracking like their "first" which you can't do for a general Monad
16:30:22 <glguy> (or a general MonadPlus, in this case)
16:30:25 <c_wraith> bitemyapp: I think they're relatively unused due to exponential blowup with ambiguous grammars 
16:30:29 <bitemyapp> glguy: well, the one that replaced [] with Monad m => m looked pretty fucking suspect to me.
16:30:55 <bitemyapp> what I'm asking is, "where's   Monad m => s -> m [(a, s)]"
16:31:12 <c_wraith> bitemyapp: unless you have some mechanism to remove backtracking, that is. 
16:31:21 <bitemyapp> glguy: unless that's what you meant, in which case I misunderstood and thought you meant the one that replaces it such that the type is: s -> m (a ,s)
16:31:41 <bitemyapp> c_wraith: ordinary H-M parsers are unused for that reason you mean?
16:31:45 <glguy> bitemyapp: that probably would have issues where it had to compute all of the alternatives ahead of time
16:31:50 <bitemyapp> c_wraith: I knew they were slow, my point was about a transformer variant.
16:31:59 <glguy> like the listT concern I think you brought up above
16:32:33 <c_wraith> bitemyapp: well, slow is a reason to not provide something. 
16:32:44 <bitemyapp> make sense, but I'm wondering how the interplay of   m [ ... ]   exacerbates the problem.
16:32:50 <bitemyapp> makes*
16:33:38 <c_wraith> Oh, that definitely makes it worse. Many monads force evaluating all possible branches before giving you anything back. 
16:34:10 <bitemyapp> That makes sense.
16:35:23 <bitemyapp> glguy: thank you
16:35:26 <bitemyapp> c_wraith: thank you very much
16:36:02 <bitemyapp> c_wraith: is there a paper you'd recommend for observing the transition from H-M into better parser designs? I know the Parsec paper.
16:36:25 <bitemyapp> also, this issue with Monads frequently having that characteristic - ParsecT is still subject to this is it not?
16:37:13 <c_wraith> bitemyapp: I don't know if it's exactly what you're looking for, but the paper on uu-parsinglib is pretty good. 
16:37:40 <bitemyapp> c_wraith: it's for the book. Was hoping to do a "call back" to the parsers chapter in the monad transformers chapter.
16:37:54 <bitemyapp> both chapters are in heavy development though.
16:38:01 <c_wraith> bitemyapp: well, ParsecT limits backtracking somehow. 
16:38:44 <c_wraith> bitemyapp: whatever it uses for that is what makes it work reasonably quickly. 
16:39:03 <glguy> bitemyapp: You can interleave effects with a backtracking transformer like happens in ChoiceT https://hackage.haskell.org/package/monadLib-3.7.3/docs/src/MonadLib.html#ChoiceT
16:39:32 <glguy> Parsec avoids the problem with a different continuation based encoding. You put the effects down per alternative, not to compute all alternatives at once
16:40:00 <bitemyapp> glguy: https://hackage.haskell.org/package/parsec-3.1.9/docs/src/Text-Parsec-Prim.html#ParsecT
16:40:29 <bitemyapp> that's reprsesentative of the tactic you're referring to?
16:40:34 <glguy> yeah
16:42:07 <bitemyapp> glguy: tyvm
16:42:11 <bitemyapp> @karma+ glguy
16:42:11 <lambdabot> glguy's karma raised to 45.
16:42:13 <bitemyapp> @karma+ c_wraith 
16:42:13 <lambdabot> c_wraith's karma raised to 8.
16:49:06 <zoku> @karma+ kaizoku
16:49:06 <lambdabot> kaizoku's karma raised to 1.
16:49:08 <zoku> @karma+ zoku
16:49:09 <lambdabot> You can't change your own karma, silly.
16:56:28 <stepcut> how might I decide between hS3, amazonka and aws(-s3)
17:02:47 <bitemyapp> stepcut: use amazonka if you can
17:03:28 <stepcut> any particular reason why?
17:03:51 <stepcut> at this point, 'some guy on the internet said to' is good enough for me ;)
17:08:09 <bitemyapp> stepcut: colleagues that have used aws and amazonka.
17:08:19 <stepcut> sounds good
17:08:37 <bitemyapp> stepcut: and hS3 hasn't been updated since 2014
17:08:44 <stepcut> yeah
17:08:53 <stepcut> hS3 seemed like it was not modern or up to date
17:11:13 <stepcut> I am working on an S3 backend for acid-state :)
17:19:48 <gfixler> hmmm, ghc --make -Wall File.hs sometimes reports missing patterns, and sometimes doesn't
17:20:16 <gfixler> if I go resave the file, I can usually get it to notice again that I've commented out a match
17:20:34 <glguy> It doesn't reocompile things that haven't changed since last compile
17:20:45 <glguy> You can force recompilation with -fforce-recomp
17:21:09 <gfixler> ah, that's it then
17:21:16 <gfixler> I've not done a lot of compiling in my life
17:21:23 <gfixler> is it hash or date based?
17:25:45 <nolraiU> date /I think/. It says in the manual.
17:52:50 <emmanuel_erc> I've been seriously considering getting a Haskell mentor. Do you guys know of anyone that does any mentoring?
17:53:45 <gfixler> emmanuel_erc: often considered that myself
17:55:21 <emmanuel_erc> You seem to be getting the hang of Haskell from what I've seen.
17:57:13 <gfixler> emmanuel_erc: me?
17:57:45 <gfixler> slowly but surely - it's a journey
17:58:16 <gfixler> Haskell fundamentally changed my mind about programming
17:58:27 <gfixler> and I don't just mean the imp/OOP -> FP switch
17:58:47 <gfixler> For 20 years I thought I could became really great, and saw things in much more black and white terms
17:58:55 <gfixler> and didn't care about math, or see any connection to it
17:59:03 <gfixler> and I "invented" things all the time, and thought that was great
17:59:10 <gfixler> it was all about me
17:59:36 <gfixler> after 2 years of Haskell, I don't want to invent any more
17:59:53 <gfixler> and I have no feeling that I'll become great, but just slowly better, and more aware of the vast surroundings
18:00:01 <JamesJRH> :-(
18:00:03 <JamesJRH> Hi.
18:00:08 <JamesJRH> Why not invent?
18:00:08 <gfixler> o/
18:00:14 <JamesJRH> That sounds bad.
18:00:25 <gfixler> because it's unprincipled
18:00:42 <gfixler> I don't mean that I won't or shouldn't play - play is great
18:00:56 <gfixler> but I no longer feel like I'm going to say "Here's how maps should work, world"
18:01:13 <JamesJRH> Play is a privilege.
18:01:18 <gfixler> instead, I want to find the math that tells *me* how maps should work
18:01:39 <gfixler> so, like math, not about inventing so much as discovering
18:01:58 <gfixler> but mathematicians certainly play, and all the time
18:02:16 <gfixler> I can invent on the design end of things, like if I make a game
18:02:22 <bitemyapp> gfixler: maps?
18:02:29 <JamesJRH> I'm having too many problems in my life to think about play. :-(
18:02:42 <gfixler> bitemyapp: where maps = any structure or algorithm, or similar
18:02:59 <gfixler> example: I never want to roll my own crypto
18:03:12 <JamesJRH> Whether it's inventing solutions or discovering solutions, I don't really mind. Just as long as there are solutions.
18:03:29 <gfixler> JamesJRH: yep - but I used to have a lot of ego in the game
18:04:15 <gfixler> it was about me being clever and impressing, and my inventions have not stood the test of time
18:04:59 <JamesJRH> Currently I'm having serious problems with Thunderbird. I've spent most of the last 5 and a half hours trying to get it working properly after having ran out of drive space while it was running.
18:05:09 <gfixler> :(
18:05:55 <JamesJRH> So, seeing as I like Haskell, I came here to ask…
18:06:01 <JamesJRH> Anyone know of a GUI email client written in Haskell?
18:07:08 <JamesJRH> Thunderbird doesn't manage its state properly, I need something much purer and more reliable.
18:07:24 <gfixler> good question - if not, we've not expanded much yet, by Zawinski's law
18:07:25 <gfixler> https://en.wikipedia.org/wiki/Jamie_Zawinski#Zawinski.27s_law_of_software_envelopment
18:07:52 <gfixler> JamesJRH: I think a lot of haskellers use emacs, and emacs has mail clients
18:08:24 <exio4> gfixler: "emacs has X" seems to be valid for pretty much any X though, so.. :p 
18:08:40 <gfixler> exio4: yeah, I was wondering if there was a haskell email mode for emacs, actually
18:08:47 <silver> Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can
18:10:04 <JamesJRH> gfixler: Emacs? Not Yi Editor?
18:10:24 * JamesJRH is going to use Yi Editor soon.
18:10:37 <gfixler> JamesJRH: yeah, I think there's an emacs mode for Yi, so you could do email in there
18:10:51 <c_wraith> JamesJRH: I'm not aware of any.  GUI projects in general are rather uncommon in Haskell.
18:11:11 <JamesJRH> :-(
18:11:18 <gfixler> I think the terminal is a Great User Interface
18:11:27 <gfixler> though I've never done mail in it
18:11:35 <gfixler> tried to set it up once, and couldn't believe how complicated it was
18:12:05 <JamesJRH> gfixler: Wouldn't that just be Emacs bindings? It's not going to have email.
18:12:26 <JamesJRH> Also, I wouldn't wnat Yi Editor to have email support.
18:12:37 <gfixler> JamesJRH: you sound like a vim user
18:12:41 <JamesJRH> At least, I don't get the whole Emacs bloat thing.
18:12:48 <JamesJRH> Lol, yeah.
18:13:00 <JamesJRH> But I don't like Vim's bloat either. :-P
18:13:23 <gfixler> Emacs bloat: http://c2.com/cgi/wiki?EmacsAsOperatingSystem
18:13:41 <gfixler> JamesJRH: I agree - I also don't like Yi's bloat
18:14:03 <JamesJRH> 02:10:56 < gfixler> I think the terminal is a Great User Interface  ← Terminal has it's issues for HTML documents and such.
18:14:35 <JamesJRH> gfixler: Yi's bloat? I haven't tried it yet. How big is it?
18:14:39 <gfixler> JamesJRH: I've looked into GUIless HTML a few times
18:14:54 <JamesJRH> So.
18:15:22 <JamesJRH> I know that HTML can be displayed in a terminal, I do that.
18:15:28 <JamesJRH> But that's not the point.
18:15:31 <gfixler> 800 files - 183kloc
18:16:11 <gfixler> JamesJRH: I didn't necessarily want in the terminal - I just didn't want to fire up firefox with 100+ tabs that I can't close for some reason to look up one thing on wikipedia
18:16:15 <gfixler> or get one page of documentation
18:16:34 <JamesJRH> Heh.
18:16:37 <gfixler> I just wanted whatever it is that renders html to do that in an undecorated rectangle
18:16:46 <gfixler> I use a tiling wm
18:17:03 <JamesJRH> Hmm.
18:17:04 <gfixler> I wanted a simple, floating popup with a single page that I could scan, then kill
18:17:13 <gfixler> it exists, but the projects are mostly abandoned
18:17:14 <dldldl> hello
18:17:16 <JamesJRH> It's still graphical, though.
18:17:23 <JamesJRH> Hmm.
18:17:24 <dldldl> would anybody here be able to help me with my xmonad config?
18:17:29 <gfixler> JamesJRH: yeah - I don't need the web to be a grid of text
18:17:57 <JamesJRH> But I guess that the ‘UI’ bit is /not/ graphical, even though the display is.
18:18:23 <gfixler> JamesJRH: right - none of the interactive things - all vim-like keypresses
18:18:38 <JamesJRH> dldldl: See also: #xmonad
18:18:56 <dldldl> I'm working with someone over there, but it seems to be much less active.
18:18:58 <dldldl> JamesJRH++
18:21:41 <JamesJRH> 02:16:24 < gfixler> I use a tiling wm  ← Same, I use XMonad. :-)
18:21:59 <gfixler> JamesJRH: I'd like to use it eventually, but it didn't seem to fit my needs atm
18:22:06 <JamesJRH> 02:16:42 < gfixler> I wanted a simple, floating popup with a single page that I could scan, then kill  ← Do you have a way? Can this be done in Haskell?
18:22:19 <gfixler> JamesJRH: I can do it in i3, which I use currently
18:22:28 <JamesJRH> How?
18:22:50 <JamesJRH> What rendering engine do you use?
18:23:15 <JamesJRH> Also, is there a Haskell rendering engine?
18:23:54 <gfixler> JamesJRH: example: http://portix.bitbucket.org/dwb/
18:24:00 <gfixler> webkit for that one
18:25:13 <gfixler> I just wanted a rectangle with a rendered page in it - no scrollbar, no title, no tabs, no window frame, etc
18:26:30 <JamesJRH> Hmm.
18:27:02 <JamesJRH> I only want that because I want to write my own interface.
18:27:09 <JamesJRH> But I don't know how to.
18:28:11 <JamesJRH> What is it written in?
18:30:53 <JamesJRH> gfixler: I'm thinking – if I could separate the email client into the downloader, browser, and viewer, I could write bits of it.
18:37:17 <athan> Is there a general-purpose Object type that I can use to decode aeson values into? I only need to lookup one level deep in a possibly-nested object, but I still get a failed parse when I try to decode it as a Map Text Text, for instance
18:39:14 <c_wraith> athan: Value
18:39:50 <athan> c_wraith: Thank you >< sorry
18:40:19 <c_wraith> athan: it's strange how easy it is to miss that, though.  You're not the first.  I've been in that camp several times. :)
18:40:44 <c_wraith> "I just need something that can hold arbitrary JSON... wait.  Oh."
18:47:12 <athan> c_wraith: I was about to make a trie with Map and Fix .-.
18:49:18 <c_wraith> athan: don't miss lens-aeson, if you're going to be doing much work with Value
18:49:52 <bitemyapp> yeah Value isn't super well explained
18:50:04 <bitemyapp> it might be more obvious if it was named JSONValue or something, but I loathe bikeshedding.
18:50:23 <c_wraith> It's just really easy to think of Value as only an intermediate structure.
18:50:33 <bitemyapp> well that's another thing
18:50:44 <c_wraith> Because that's how the classes which are at the forefront of the library present it.
18:50:50 <bitemyapp> the explicit staging of parsing and marshalling often doesn't have an equivalent in dynamically typed languages.
18:52:17 <simony> bitemyapp: can you elaborate a little bit more on the split between parsing and marshalling?
18:52:45 <bitemyapp> simony: like c_wraith said, Value is the intermediate that represents the space of all possible JSON values.
18:53:08 <bitemyapp> simony: the ByteString/Text/String you got Value from is a strictly larger space that can encode more than just JSON values.
18:53:17 <c_wraith> Now I wonder if JSON values must be finite. >_>
18:53:18 <bitemyapp> simony: your data is rarely ~ Value, you want to neck it down.
18:53:39 <bitemyapp> simony: aeson does the initial cardinal "necking down" from stream -> Value
18:53:48 <bitemyapp> simony: you do the second bit in your FromJSON instance, Value -> a
18:54:03 <simony> ahhhh, makes sense now :3
18:54:06 <bitemyapp> ToJSON is you providing means of going   a -> Value
18:54:11 <bitemyapp> the library handles Value -> stream
18:54:28 <c_wraith> and likewise in the other direction with FromJSON
18:54:29 * bitemyapp copies and pastes what he said, puts it in the book
18:54:44 <simony> 🙌🙌
18:55:07 <bitemyapp> simony: those characters didn't show up for me.
18:55:36 <simony> and just to wrap it all up, is it just that other languages conflate the Value <-> a?
18:56:03 <simony> bitemyapp: emoji for "Person raising both hands in celebration"
18:56:49 <bitemyapp> simony: cool
18:56:50 <c_wraith> simony: well, it's less a language thing than a library thing, but yes.
18:57:06 <bitemyapp> well
18:57:13 <c_wraith> simony: even look at Binary or Cereal in Haskell, for instance.
18:57:13 <bitemyapp> it's mostly a library thing, but the language enables the elision.
18:57:36 <bitemyapp> in dynlangs, you're allowed to code the happy-path-only
18:57:47 <bitemyapp> which means using representational rather than domain types _seems_ to cost nothing
18:57:52 <bitemyapp> so the absence of rigor is easily the default
18:58:04 <bitemyapp> you _could_ marshal JSON dicts into classes in python, but how many people do?
18:58:24 <bitemyapp> technically a library thing, but language induces cultural habits.
18:58:53 <simony> yeah, culture definitely has far reaching impact
18:59:18 <c_wraith> bitemyapp: fortunately, lens-aeson gives us the tools to play fast and loose with Value in the same way python lets you play fast and loose with Dicts!
18:59:27 <bitemyapp> yes, actually.
18:59:31 <bitemyapp> that's basically what it does.
18:59:40 <bitemyapp> I think of it as the collapsing of failure.
18:59:44 <bitemyapp> prisms anyway.
18:59:59 <c_wraith> Yeah, if the path you're looking for doesn't exist, you have no idea why.
19:00:06 <bitemyapp> "there are many ways this could fail, but let us have them all fail in the same way since it's not interesting"
19:00:19 <bitemyapp> c_wraith: I've been thinking about ways to fix that.
19:01:19 <c_wraith> bitemyapp: if it's all lenses and prisms, that's not so tough, in theory.  When multi-target traversals get involved, things get weird.
19:01:22 <ReinH> bitemyapp: (which in other contexts can be a very powerful technique)
19:01:40 <bitemyapp> c_wraith: yeah prism+writer seemed okay
19:01:56 <bitemyapp> c_wraith: no idea re: traversals. They don't really have the same concrete, straight-forward expectation.
19:02:03 <c_wraith> bitemyapp: like..  Is it a failure if 3 out of the 10 entries in the array the traversal hits lack the child you're looking for?
19:02:09 <bitemyapp> yeah, exactly.
19:04:09 <bitemyapp> c_wraith: saturated vs. unsaturated traversals?
19:04:11 <athan> bitemyapp: Are you going to cover monad-control in the book?
19:04:21 <bitemyapp> athan: hahahaahahahahahahahahahahahaahahahaha
19:05:04 <athan> :(
19:05:40 <athan> > fix (my pain)
19:05:42 <lambdabot>      Not in scope: ‘my’
19:05:42 <lambdabot>      Perhaps you meant one of these:
19:05:42 <lambdabot>        ‘m’ (imported from Debug.SimpleReflect),
19:05:49 <bitemyapp> athan: I'd like to cover mtl-style. monad-control requires explaining Cont
19:06:20 <c_wraith> bitemyapp: I don't know if that's even all that practical.  There are (illegal but super-useful) traversals like filtered which make that distinction weird, too.
19:06:47 <athan> bitemyapp: Really? Huh, see there you go I don't know jack
19:06:57 <athan> I think mtl style is good for beginners :)
19:07:15 <athan> just relate `MonadFoo m =>` to `elem`
19:08:26 <rvx_> hello
19:09:24 <rvx_> anyone know where i can find a good attoparsec tutorial?
19:09:27 <rvx_> or examples
19:10:00 <c_wraith> rvx_: for the most part, it's like Parsec.  That has hundreds of tutorials available.
19:10:11 <c_wraith> rvx_: there are some minor differences, but they mostly work the same way.
19:10:15 <bitemyapp> c_wraith: there's literally dozens of us!
19:11:05 <rvx_> c_wraith: okay, although for a beginner it's not obvious where the similarities begin and end.
19:11:59 <c_wraith> rvx_: exact function names and signatures may differ.  The overall use pattern is identical.
19:12:10 <rvx_> one particular example i'm looking for is how to deal with a free text comment field, the log files example on fpcomplete doesn't cover that
19:12:36 <c_wraith> Oh.  In that case, you probably do need to find an appropriate exact function
19:12:51 * hackagebot Paraiso 0.3.1.5 - a code generator for partial differential equations solvers.  https://hackage.haskell.org/package/Paraiso-0.3.1.5 (TakayukiMuranushi)
19:13:21 <c_wraith> rvx_: I'd use manyTill for that.
19:14:18 <c_wraith> rvx_: the first argument would be a parser for individual characters in the free text.  The second argument would be a parser for the delimiter at the end of the free text.
19:14:42 <c_wraith> rvx_: there are other approaches, but that's a relatively easy one.
19:15:40 <c_wraith> rvx_: https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Combinator.html#v:manyTill  The example in the docs is even a similar sort of thing.
19:16:16 <rvx_> c_wraith thanks
19:23:23 <bitemyapp> athan: I can't really teach you monad-control right now.
19:23:32 <bitemyapp> athan: I've used it, I understand why it exists, but it's gnar-gnar af
19:23:55 <bitemyapp> athan: the basic issue comes down to a continuation based API being needed rather than MonadIO style because some things are inexpressible in the MonadIO style.
19:24:33 <bitemyapp> athan: mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b)
19:24:43 <bitemyapp> athan: you can't lift IO in the negative position using MonadIO.
19:25:07 <bitemyapp> athan: thus: http://hackage.haskell.org/package/lifted-async-0.7.0.1/docs/Control-Concurrent-Async-Lifted.html#v:mapConcurrently
19:25:21 <bitemyapp> athan: imagine an action that wasn't in IO, but was instead in MyWebApp
19:25:31 <bitemyapp> athan: because it needed stuff from your web app and you wanted to run it concurrently
19:25:43 <bitemyapp> athan: without monad-control/lifted-async, not really doable.
19:26:11 <bitemyapp> athan: so, Haskellers being what they are, are moving to the maximally general option for solving a problem even though it's annoying af to use.
19:26:15 <bitemyapp> and to write instances for
19:26:20 <bitemyapp> and generally to be within 6,000 km of.
19:30:59 <athan> bitemyapp: I completely agree, it's really interesting to see why it's gnar though :)
19:31:15 <athan> weirdly enough, I was just looking at mapConcurrently o_o
19:31:34 <bitemyapp> athan: "see why it's gnar"
19:31:41 <bitemyapp> CPS isn't obvious.
19:31:46 <bitemyapp> the instances are tedious.
19:31:53 <bitemyapp> there aren't many public examples
19:31:58 <bitemyapp> and a lot of them vary in meaningless ways.
19:32:07 <bitemyapp> the damn library auto-generates them.
19:32:47 <athan> hahaha
19:32:55 <athan> I'm sure I'll learn eventually
19:33:12 <athan> I mean, I don't even know delimited continuations or CPS (Hoare-style at least)
19:33:30 <athan> so it's understandable why you'd pass it off
19:34:45 <bitemyapp> athan: it wouldn't have even occurred to me to cover it if S* hadn't moved to it.
19:35:08 <athan> :\
19:36:39 <athan> Question: what would be a good way to run an IO action every minute or so, with async?
19:36:51 <athan> Or really, what's a good (efficient) way to block that action?
19:37:18 <athan> I'm not sure if blocking, busy-waiting, or manually timed scheduling are possible
19:37:36 <bitemyapp> athan: you don't need async
19:37:50 <bitemyapp> athan: forkIO, threadDelay, forever.
19:38:03 <bitemyapp> hold onto the ThreadId, use it to assassinate the bugger when you need to.
19:38:34 <athan> bitemyapp: :) thank you
19:38:37 <bitemyapp> athan: GHC has its own thread scheduling system
19:38:43 <bitemyapp> athan: it multiplexes OS threads onto the green threads
19:38:48 <bitemyapp> athan: when are then fragmented into sparks
19:39:04 <bitemyapp> athan: threadDelay will block the green thread and the OS thread will be retasked until that thread is woken back up.
19:39:09 <bitemyapp> IIUC
19:39:36 <bitemyapp> so, the simple approach should do the right thing until you need more sophisticated task management logic.
19:39:55 <mgsloan> True that you don't need async, but it's also rather nice!  In particular, it may be good to use `withAsync` if you want to ensure it gets cleaned up when the inner task finishes or throws
19:40:04 <bitemyapp> later you may want to turn the "job" into a datatype, feed it via MVar or chan.
19:40:29 <bitemyapp> athan: mgsloan raises a good point, whether you use async or not, you'll want to think carefully about resource management.
19:41:01 <bitemyapp> athan: example: what happens if it gets a sync or async exception after it opened a socket?
19:41:14 <bitemyapp> athan: this is what "bracket" et al. are for - async will make it easier to do the right thing there.
19:41:14 <athan> thanks mgsloan!
19:41:29 <bitemyapp> lest you leak fds/sockets/etc.
19:41:41 <mgsloan> athan: Welcome!
19:41:51 <athan> bitemyapp: Holy crap okay
19:41:56 <athan> 10x
19:42:15 <emmanuel_erc> saturday night live
19:42:17 <athan> and resourcet abstracts the cleanup into a monad?
19:42:17 <emmanuel_erc> oops
19:42:21 <emmanuel_erc> sorry
19:42:25 <bitemyapp> athan: Marlow covers this well in his book
19:42:35 <athan> bitemyapp: Still only 1/2 through it :\
19:42:44 <bitemyapp> s'fine
19:42:49 <bitemyapp> or at least, I thought he did.
19:43:21 <athan> I'm pretty sure he does :)
19:43:29 <athan> thank you bitemyapp I owe you one
19:43:29 <bitemyapp> athan: http://chimera.labs.oreilly.com/books/1230000000929/ch08.html
19:43:34 <bitemyapp> athan: http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
19:43:38 <bitemyapp> mentions bracket there.
19:44:09 <bitemyapp> athan: http://chimera.labs.oreilly.com/books/1230000000929/ch11.html#sec_conc-withasync withAsync subsumption of bracket occurs here.
19:44:37 <bitemyapp> athan: wanna pay me back? Get the book, read the book, tell others what you think of it :P
19:45:10 <mgsloan> "race" and "concurrently" are also good ways to ensure things get cleaned up
19:45:16 * mgsloan <3 async library
19:46:33 <athan> bitemyapp: Will do :)
19:46:38 <bitemyapp> athan: I'm going to go back to freaking out about parsers now
19:46:42 * bitemyapp sips coffee and grimaces
19:46:57 <athan> bitemyapp: no tee :D
19:47:00 <athan> :D?*
19:47:14 <bitemyapp> just finished two cups of tea
19:47:18 <bitemyapp> we're on to coffee now.
19:47:39 <bitemyapp> my caffeine intake is predicated more on how I feel than a ritual or a habit.
19:47:42 <bitemyapp> need more? coffee-time.
19:47:45 <bitemyapp> need less? tea-time.
19:48:35 <luigy> mgsloan you guys use properllor right? kind of want to use his other lib to replace logsticky for more eyecandy goodies :P
19:49:31 <bitemyapp> luigy: https://propellor.branchable.com/ this?
19:49:35 <bitemyapp> luigy: what eye-candy?
19:51:17 <derdon> I tried "cabal install testpack", but it failed with this message: https://bpaste.net/show/8c65928c597b
19:51:22 <derdon> did I do something wrong?
19:52:00 <napping> no
19:52:46 <mgsloan> luigy: We don't use propellor.  My specialty is not such devopsey stuff, but we use a mix of terraform, saltstack, kubernetes, etc
19:53:14 <napping> an compile error like that means at the very least that the package didn't declare it's required versions carefully
19:53:23 <mgsloan> luigy: But I'm certainly in favor of logsticky eyecandy :D I liked the look of the build tool that told you what it's working on (ocaml tool, right?)
19:53:24 <luigy> bitemyapp whoops this was in reference to another talk I had with Michael about putting some more eyecandy to stack 
19:53:39 <napping> I see it's listed as "deprecated", why are you trying to install it?
19:54:24 <derdon> napping: because some group decided to write their tests in a way that this package is required :)
19:54:30 <derdon> (I'm a tutor btw)
19:54:49 <luigy> one of the (or maybe only :P) things I envy from those npm golang ocaml 
19:54:57 <napping> ah, then they might package it better
19:55:06 <luigy> I spent too much time behind cli interfaces xD
19:55:11 <luigy> spend**
19:55:26 <bitemyapp> luigy: what's the eye candy?
19:55:27 <platz_> is there any tool that determines if any of my installed packages have newer versions updated on hackage?
19:55:29 <bitemyapp> mgsloan: OPAM?
19:55:56 <luigy> bitemyapp https://cloudup.com/cy2EU9wpzFx
19:56:18 <luigy> scroll around the middle of the vid and look at that processing status 
19:57:24 <mgsloan> Once this info is there, I think it also makes sense to omit the fine grained "configure" / "build" / "install", and instead just list the installed packages, like in this video
19:57:53 <luigy> exactly!
19:57:55 <bitemyapp> luigy: yeah, that's there.
19:58:05 <derdon> napping: ah, the package is not really required anyway. they have some imports but don't really use them. uncommenting some lines "fixed" the problem
19:58:05 <bitemyapp> that's really nice
19:58:38 <napping> that's good, I'm pretty confused why it wouldn't install
19:59:32 <napping> I would think the upper bound on base should stop it from trying to build on a too-new ghc, and I'd expect that to more or less keep containers,mtl,random to something it can handle
19:59:42 <napping> and it declares upper bounds on the other dependencies
19:59:51 <napping> oh, and it just installed successfully in a fresh sandbox for me
20:00:28 <napping> hmm, have you not run cabal update for a few months?
20:00:37 <napping> http://hackage.haskell.org/package/testpack-2.1.3.0/revisions/
20:01:17 <derdon> napping: whoops, last run of cabal update was 67 days ago
20:01:29 <napping> ok, that would help
20:01:37 <derdon> indeed it did :)
20:01:39 <derdon> thanks
20:01:45 <napping> To answer the general question, a compiler error like that is never your fault
20:02:04 <napping> if cabal fails to find a plan or warns about reinstalls, maybe you can do something about it
20:02:32 <jle`> is there a guide to profiling an executable in a nice way w/ stack?
20:02:46 <jle`> can stack help me have both profiled and non-profiled compilation side-by-side
20:02:48 <derdon> napping: what is the meaning of "plan" here?
20:02:50 <jle`> without nuking my .cabal-sandbox ?
20:04:29 <napping> derdon: a choice of versions of all the (transitive) dependencies to use
20:06:57 <derdon> napping: is it possible to have multiple versions installed of a package in parallel? or may it cause problems?
20:07:28 <mgsloan> jle`: "--library-profiling" and "--executable-profiling" will do that, but by default it will need to rebuild local packages / extra-deps when switching between profiled and non-profiled builds
20:07:48 <jle`> mgsloan: hm, so it doesn't store both for easy switching?
20:07:52 <jle`> i thought there was some caching thing going on
20:07:57 <jle`> i don't know anything about stack :'(
20:08:13 <mgsloan> It does for your snapshot dependencies
20:08:22 <napping> derdon: not very well, that's what sandboxes do for you. Work is ongoing to fix that
20:08:46 <derdon> I see
20:08:49 <jle`> does it keep a global cache?
20:08:51 <napping> More precisely, you can have different versions installed at once, but not multiple builds of the same version
20:09:05 <mjrosenb> if I want to have a type alias where one of the types is a monad, can I do this, or do I just need to parameterize the type on the monad?
20:09:09 <mgsloan> jle`: Something like that is certainly possible, and will likely be added in the future.  However, it gets a bit tricky. See https://github.com/commercialhaskell/stack/issues/1132
20:09:43 <mjrosenb> e.g. type XForm a b = a -> m b -> [a] -> m [b]
20:09:47 <napping> which you might need if different programs/libraries want the same version of that package, but have other constraints that force different versions of packages it depends on
20:10:06 <jle`> ty mgsloan 
20:11:01 <napping> like, LibBroken-1.0 requires Dep == 1.*, LibA requires LibBroken == 1.0, Dep == 1.1, LibB requires LibBroken == 1.0, Dep == 1.2
20:13:00 <derdon> napping: so this use case is already a solved problem or not?
20:13:19 <napping> if you just use separate sandboxes for separate projects it works
20:14:23 <derdon> ok
20:14:24 <napping> http://blog.ezyang.com/2015/08/help-us-beta-test-no-reinstall-cabal/
20:16:16 <napping> that's the latest I see about work on fixing this better
20:16:33 <napping> the only bad thing about sandboxes is that each sandbox builds its own copy of stuff
20:18:19 <derdon> well, otherwise the sandboxes wouldn't be sandboxes ^^
20:18:33 <koz_> How do I tell runhaskell where to find stuff? I'm trying to execute something via a Makefile outside the directory where the code can be found.
20:18:41 <napping> sounds like 7.10 finally has the hash-based stuff to allow multiple builds without them getting overwritten
20:19:49 <napping> the hope is to eventually get cabal to be able to re-use compiled packages between "sandboxes"
20:19:50 <derdon> still have 7.8.4 :/
20:20:10 <derdon> but good to hear that people seem to be working on this issue
20:20:34 <napping> there's also stackage, which wouldn't have helped because it didn't include that package
20:21:29 <napping> but that's a project that basically publishes a set of particular versions of "everything" that work together, like with build farms and stuff
20:28:28 <Pamelloes> Yeah, but when it works it's pretty cool.
20:36:04 <mjrosenb> test: thread blocked indefinitely in an MVar operation
20:36:20 <mjrosenb> that likely means I done messed up with mdo?
20:44:12 <mjrosenb> has anyone used a recent reactive-banana? I seem to be having some problems with the new monadified interface.
20:45:42 <ReinH> mjrosenb: if you haven't, you should read Simon Marlow's book
20:45:54 <ReinH> @where parallel and concurrent programming with haskell
20:45:54 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
20:46:00 <ReinH> no lambdabot
20:46:06 <ReinH> http://chimera.labs.oreilly.com/books/1230000000929
20:46:39 <mjrosenb> ReinH: is that about FRP?
20:47:43 <Adeon> no, it's about concurrent and parallel programming in haskell
20:47:54 <Adeon> which you might consider very vaguely related to FRP
20:48:02 <Adeon> at least parts of the story
20:49:14 <Adeon> mdo is tricky...if you have an easily readable piece of the code that blocks on MVar we might be able to help you
20:49:32 <Adeon> you get that MVar exception when GHC detects a blocking operation on it can never continue
20:50:05 <Adeon> e.g. takeMVar on empty MVar when nothing else has a reference to the MVar so there is no way it can ever continue
20:50:42 <mjrosenb> yeah, this is like 500 lines of horribly convoluted code
20:50:57 <mjrosenb> it was fine when it was all lets, using mutual recursion
20:51:09 <mjrosenb> but then I upgraded reactive-banana
20:51:48 <mjrosenb> and they replaced a bunch of foo -> Event t a with MonadMoment m => foo -> m (Event a)
20:52:12 <mjrosenb> and they implemented MonadFix for both possible values of m
20:52:35 <mjrosenb> so I tried wrapping everything in mdo, and pulling things out as necessary
20:52:56 <Adeon> is the use of monadfix actually encouraged with that library or is the instance there because it can be
20:53:12 <Adeon> I usually avoid any mdo or MonadFix because I can't wrap my head around it and I think it'll make my code error prone :-/
20:54:39 <Adeon> did you find out why they monadified the API
20:54:45 <Adeon> maybe they had a good reason
20:58:01 <platz> what does it actually mean if a package is 'broken' ?
20:58:13 <platz> (due to a reinstall)
20:58:58 <kadoban> platz: It means it's time to use 'stack' instead of 'cabal-install'. Or if you're a masochist you can spend some time figuring out cabal sandboxes instead.
20:59:26 <zoku> oh, should I be using stack?
20:59:27 <kadoban> platz: But the direct answer is pretty much what it sounds like: it could just completely stop working. Or it could be fine. You won't really know.
20:59:32 * zoku is still using cabal with sandboxes
20:59:50 <kadoban> zoku: IMO, yes. It's much better.
21:00:04 <napping> how is it better? I haven't had trouble with sandboxes
21:00:09 <zoku> yeah this install keeps failling :p
21:00:10 <platz> ok, so it's in an undefined quantum state than when observed becomes working or not working
21:00:17 <platz> i think i get that
21:00:48 <kadoban> napping: Well, if you haven't had trouble, I guess you're fine. I found it really tedious, even after spending quite a bit of time trying to figure out how to even do sandboxes correctly.
21:01:16 <napping> "cabal sandbox init", and then just use cabal?
21:01:46 <kadoban> napping: There's far more to it than that, and even doing it right you still end up having to nuke the world every few weeks and reinstall, or I always did.
21:02:07 <napping> I haven't needed much more than that
21:02:20 <napping> well, that and don't "cabal install" outside a sandbox
21:02:44 <Pamelloes> Sandboxes are pretty simple. But they are tedious and recompiling is quite annoying.
21:02:44 <Pamelloes> And they stop being simple when you have interdependent projects.
21:02:46 * Pamelloes uses cabal-install with nix
21:02:51 <Adeon> I still had to use cabal-install
21:02:58 <Adeon> ...to install stack on freebsd for which I didn't find binaries
21:06:10 <athan> How likely would it be for a web server to make over (maxBound :: Int) sessions over a period of time?
21:06:27 <athan> Or really, should I make my session cache with an unbounded index?
21:08:27 <kadoban> athan: Pretty unlikely, but not impossible. Depends what size Int is too.
21:09:21 <Pamelloes> Can I add haddock documentation to a definition generated in TH?
21:09:32 <kadoban> If you were doing 1000 sessions a second, that'd be less than a month if it's 32 bit signed ints. I don't think Int is even guaranteed to be that big, but then 1000 is probably too high too. So … kind of unlikely, but not impossible.
21:10:20 <Pamelloes> kadoban: Of course, on 64 bit systems Int = Int64 in which case you will never, ever, ever run out of space.
21:10:43 <Pamelloes> (though if you ever reach a third ever....)
21:11:03 <Adeon> you can use Int64 directly :)
21:11:09 <kadoban> Pamelloes: Pretty much. But it's also probably a weird place to be putting a … kind of platform-specific limitation.
21:11:32 <Pamelloes> Definitely. Using Int64 directly is probably the smart way to go.
21:14:16 <R0b0t1> >never ever
21:14:20 <R0b0t1> famous last words, huehuehuehue
21:14:28 <koz_> Does Haskell have a tree isomorphism algorithm implementation?
21:14:54 <Pamelloes> R0b0t1: For the record, I used two evers. And I added a warning about inserting a third ever :P
21:15:05 <R0b0t1> fine, fine :p
21:15:10 <R0b0t1> koz_: yes
21:15:18 <R0b0t1> located somewhere on the internet
21:15:23 <koz_> R0b0t1: Lol.
21:15:45 <R0b0t1> it's usually phrased as a more specific sub-problem
21:16:02 <R0b0t1> hmm sorry I shouldn't have said anything, heading to bed
21:19:42 <R0b0t1> koz_: https://bpaste.net/show/ad79856e3093 can't remember where I found that but that's looking for loops in syntax trees
21:40:16 <rpfun> if i have a list exp1:exp2, does weak head normal form imply exp1 is fully evaluated?
21:40:44 <rpfun> or itself evaluated to WHNF?
21:41:18 <geekosaur> whnf would evaluate only to the (:)
21:42:06 <rpfun> so exp1 is not necessarily evaluated, right?
21:42:18 <Adeon> correct
21:43:52 <rpfun> thanks!
21:47:08 <rpfun> if i want to run computations in parallel on different cores (that are unfortunately forced into the IO monad) is it a reasonable way to make sure both finish by writing something like this: do { nv1 <- newEmptyMVar; nv2 <- newEmptyMVar; forkIO $ comp1 >> putMVar nv1 (); forkIO $ comp2 >> putMVar nv2 (); takeMVar nv1 >> takeMVar nv2 }?
21:47:18 <rpfun> will this actually run both computations in parallel?
21:47:51 <jle`> rpfun: if you want to work with this stuff nicely, it's best to use a library that figures it out for you instead of doing it at this low of a level :)
21:48:04 <jle`> a library that thinks through everything that might happen and make sure it works like you'd expect
21:48:14 <jle`> `async` is the popular one for things like this :)
21:48:28 <geekosaur> Control.Parallel.Strategies for lower level stuff
21:49:11 <rpfun> jle`: i'd like it to be pretty lightweight, and i'm interested in knowning how it works myself. is there a reason the example code i posted is suboptimal?
21:50:35 <jle`> it should run both in parallel, i think
21:50:55 <napping> check out the async library
21:51:11 <jle`> async also implements a very similar function, so you might look and see how tehy do it
21:51:18 <napping> you can use concurrently and ignore the results
21:51:37 <napping> The big difference is handling exceptions more carefully
21:51:42 <jle`> it looks "correct" to me now, but i don't have the foresight to consider all possible async exceptions
21:51:56 <jle`> there might be a way an exception could happen that throws everything off
21:52:16 <napping> if any async exeption handles (before the putMVar) that will hang
21:52:19 <jle`> so it's naively correct i think if you ignore that exceptions exist, which isn't the case in most real world code
21:52:33 <napping> or any exception in comp either
21:53:11 * hackagebot opencog-atomspace 0.1.0.2 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.2 (romanT)
21:53:14 <rpfun> ok, i see. there can be no exception in comp, it is a very special impure computatoin
21:53:33 <jle`> another thread might throw an exception to comp
21:54:16 <jle`> but yeah, if you ignore that exceptions are a thing, then i think that what you put should 'work'
22:06:57 <athan> Hi everyone, what would be a good way to add time to UTCTime?
22:07:09 <athan> I can't seem to turn a DiffTime into a NominalDiffTime
22:07:22 <athan> Ideally, I'd just like to add an hour to my UTCTime
22:07:23 <gfixler> fly around the earth like Superman?
22:07:29 <athan> :9
22:07:47 <gfixler> can you just add it?
22:08:06 <athan> gfixler: NominalDiffTime is in picoseconds
22:08:14 <athan> so it would be a pretty big number out of nowhere :\
22:08:23 <gfixler> multiply?
22:08:30 <gfixler> how are you making your UTCTime?
22:08:39 <gfixler> System.Time.something?
22:08:39 <athan> Also, UTCTime isn't a Num
22:08:46 <athan> getCurrentTime :)
22:08:54 <athan> It's in Data.Time
22:08:58 <athan> in the time library
22:09:06 <gfixler> oh, right, System.Time is old
22:09:45 <gfixler> addUTCTime?
22:10:01 <athan> gfixler: I can't make a NominalDiffTime
22:10:16 <athan> It's a Num, but I think it bases it off picoseconds
22:10:41 <gfixler> btw, I have found the time libraries to be super hard to use
22:10:50 <gfixler> like you, I have 1 or 2 things I want to do, and can't
22:11:03 <gfixler> I was trying to make a game loop
22:11:34 <athan> shoot okay
22:11:53 <gfixler> have you tried Data.Time.Clock.POSIX?
22:12:25 <gfixler> you can fmap (+x) to it
22:12:30 <gfixler> to getPOSIXTime, that is
22:12:45 <glguy> addUTCTime (fromInteger 043600) 07:: UTCTime 07-> UTCTime
22:12:46 <gfixler> > fmap (+100000) getPOSIXTime
22:12:48 <lambdabot>  Not in scope: ‘getPOSIXTime’
22:12:57 <gfixler> glguy: nice
22:13:02 <glguy> rather just: addUTCTime 3600
22:13:31 <athan> OH!! I was wrong
22:13:34 <athan> thank you glguy
22:14:09 <gfixler> athan: wrong about it not being a num?
22:14:23 <gfixler> I don't see a Num instance on it
22:15:01 <gfixler> I guess NominalDiffTime is the Num, which has fromInteger
22:17:07 <YOGOTTI> civil war against all muslim SKUM
22:18:14 <liste> @where ops
22:18:14 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:18:48 <glguy> You don't need to ping everyone, the offender has already left
22:18:55 <liste> oh sorry glguy
22:19:13 <liste> (and other ops)
22:26:07 <gfixler> hmmm... why when I do :m by itself in ghci, do I lose the ability to load any modules?
22:26:57 <gfixler> <no location info>: module ‘Data.Time’ is a package module
22:27:15 <xecycle> Hi; new to hs, now writing the first piece of validating user input in my first program.  I defined a
22:27:16 <xecycle> require pred err x = if pred x then Right () else Left err
22:27:16 <xecycle> and in a do block of Either ErrorMessage GoodInput I lay down all checks one after another.  Is this one of the conventional ways?
22:30:35 <pavonia> xecycle: Maybe you should paste some more code for context at lpaste.net
22:34:34 <xecycle> pavonia: http://lpaste.net/146403
22:36:50 <timothyh> how could I better express this: (liftM2 mplus) (return a) (someFun :: m1 (m2 a))
22:38:29 <timothyh> e.g. Maybe a -> IO (Maybe a) -> IO (Maybe a), that return makes me think there's a better expression
22:38:35 <pavonia> xecycle: This is a bit difficult to read, IMHO. Maybe a case expression with all the checks would be better
22:41:04 <xecycle> pavonia: hmm, something like a "case True of ..."?
22:43:44 <dmj> :t bool
22:43:45 <lambdabot> a -> a -> Bool -> a
22:44:07 <xecycle> ah sorry it is not that
22:44:28 <pavonia> > (\x -> case () of _ | x > 10 -> "too big"; _ | odd x -> "odd"; _ -> "okay") 4
22:44:30 <lambdabot>  "okay"
22:45:27 <xecycle> oh I see, thanks
22:48:26 <xecycle> I realized I can instead say "assert good msg = if good then Right () else Left msg"; how about this one?
22:48:58 <jle`> timothyh: that looks like fmap ?
22:49:14 <glguy> timothyh: liftM2 f (return x)  is  fmap (f x)
22:49:15 <xecycle> then in every line it is `assert (x>10) "too big"` `assert (odd x) "odd"` ...
22:49:22 <jle`> liftA2 f (pure x) y is fmap (f x) y
22:49:44 <timothyh> heck
22:51:00 <jle`> timothyh: it's like f <$> pure x <*> y ... that's just f x <$> y
22:51:52 <jle`> > liftA2 (+) (pure 10) (Just 13)
22:51:54 <lambdabot>  Just 23
22:51:58 <jle`> > fmap (10 +) (Just 13)
22:52:00 <lambdabot>  Just 23
22:53:13 * hackagebot sscgi 0.3.1 - Simple SCGI Library  https://hackage.haskell.org/package/sscgi-0.3.1 (ChrisForno)
22:53:51 <timothyh> heh, yeah i see it
22:54:17 <Cale> xecycle: I've used Either e like that quite a bit for validation.
22:54:30 <timothyh> i still have bad intuition for <$> <*>
22:54:58 <timothyh> thanks friends
22:55:04 <xecycle> Cale: you mean the assert one?
22:55:37 <Cale> xecycle: I mean, in general. All of that sort of thing tends to work well.
22:55:59 <ReinH> xecycle: you have reimplemented guard
22:56:16 <Cale> Well, that's not exactly guard
22:56:25 <Cale> It's guard with additional information about what went wrong :)
22:56:26 <ttt_fff> I'm using optparse-applicative; one of the option results in me calling Snap (which does it's own command line parsing). Is ther ea way in haskell to say "nuke/clear all command line args" ?
22:56:34 <ReinH> Cale: Ah, true enough
22:56:58 <xecycle> Hmm, okay, am now using that assert
22:57:01 <sedeki> good morning all
22:58:10 <Cale> ttt_fff: There's withArgs which might do it for you
22:58:28 <Cale> I thought there was setArgs, but it seems not
23:00:41 <ttt_fff> Cale: that worked; thanks!
23:02:40 <sedeki> are monads types? does an instance of a monad ”return” something? (i’m not referring to the return keyword, i understand it is different), i’m referring to the end of a do-block
23:04:23 <xecycle> return is a keyword?
23:05:11 <Cale> return is not a keyword
23:05:14 <Cale> It's a function
23:05:25 <dmj> sedeki: 'do' doesn't necessarily indicate you're in a monad, but people most often us do syntax w/ monads. 'Monad' in haskell is a class. An instance of the Monad class is a definition for a type that upholds the monad laws. It doesn't 'return' anything in that sense, but provides you with (>>=) and `return`.
23:05:25 <Cale> sedeki: Monads are type constructors
23:05:41 <sedeki> sorry, not a keyword then.
23:05:43 <sedeki> hehe.
23:06:16 <Cale> sedeki: For example, Maybe is a monad, IO is a monad, the type constructor for lists (the [] you put around a type) is a monad
23:06:26 <jle`> in Haskell, a Monad is (more specifically) type constructor, like Maybe, IO, [], etc.; values of type Maybe a, IO a, [a], etc. don't really have a general "name", though
23:06:42 <jle`> there's no general name for things that are values of types "m a"...but a lot of people like to call them "actions"
23:06:49 <jle`> which might be a bit misleading
23:07:09 <Cale> Saying that M is a monad means that there is a definition of the functions:  return :: a -> M a, and  (>>=) :: M a -> (a -> M b) -> M b, which satisfy certain properties.
23:07:27 <jle`> but remember that `Just 10`, `Maybe Int`, Just`, etc. aren't the monads.  Maybe is the Monad
23:07:35 <jle`> this may or may not make sense depending on how much Haskell you know :)
23:08:17 <Cale> This is a pattern which shows up in a bunch of various libraries, and by capturing it and giving it a name, we can write some code which works in all monads (mostly stuff which looks a bit like control structures of various sorts), and save ourselves from having to write it over and over.
23:08:43 <sedeki> it makes sense to ~70%, yes (i’m not claiming to understand monads themselves yet)
23:08:46 <sedeki> the concept i mean
23:09:27 <jle`> mhm. it's also good to remember that understanding the concept of monads isn't really necessary to actually using the types themselves
23:09:30 <Cale> The usual idea is that values  x :: M a  are typically something like "actions which when carried out will have results of type a"
23:09:51 <jle`> like, understanding group theory isn't necessary in learning how to add numbers
23:09:56 <Cale> and then  return :: a -> M a  gives the action which "does nothing" (whatever that means), and produces the given value as the result.
23:11:14 <Cale> and if we have x :: M a, some computation which when we run it will produce results of type a, and we have f :: a -> M b, some function which will take a value of type a, and produce a further computation whose results have type b when it's run
23:11:44 <Cale> Then x >>= f will be the computation which will first run x, and then apply f to the result, and run that.
23:12:05 <Cale> What it means to "run" something will generally be a bit different depending on what M is
23:12:11 <dmj> sedeki: a good way to understand them is to use them (i.e. Maybe, [], Either, IO), then you'll better be able to see how they uphold the laws in their own way, while helping you build programs
23:12:21 <sedeki> another question. https://wiki.haskell.org/Monad : ”The essence of monad is thus separation of composition timeline from the composed computation's execution timeline”. mind expanding on this?
23:12:26 <ReinH> monads as computation is a convenient metaphor but try not to become too attached to it.
23:12:50 <Cale> https://wiki.haskell.org/Monads_as_computation
23:12:56 <Cale> ^^ read that one ;)
23:13:01 <sedeki> ok
23:13:08 * sedeki reads
23:13:20 <Cale> I think it's okay to become attached to it if you're mostly interested in programming
23:13:31 <Cale> It *always* applies in the cases we care about in Haskell
23:13:39 <ReinH> You will encounter instances that don't seem to have much to do with computation, but on the other hand enough of them do (and especially the more common ones) that the metaphor is still useful
23:13:50 <jle`> be careful to separate the idea of what monads "are" vs. what monads are useful for as a tool
23:13:54 <Cale> It's just, if you want to go on and do more mathematics, there are some monads which become less like computation.
23:15:51 <Cale> (e.g. the endofunctor on the category of metric spaces which sends a metric space to its completion is a monad -- it's kind of hard to think of that as providing some sort of notion of computation.)
23:17:02 <ReinH> Cale: is Proxy like a computation? I suppose it is a degenerate computation?
23:17:21 <Cale> Yeah, I guess there are trivial things.
23:17:39 <ReinH> You can compute anything you want, as long as that thing is noop
23:17:41 <Cale> heh
23:17:42 <Cale> right
23:17:43 <napping> there are a few more like a substitution
23:19:16 <jle`> Proxy isn't a Monad though
23:19:40 <jle`> but that probably doesn't affect your point heh
23:19:58 <napping> bound expects you to have a Monad instance for your terms
23:20:26 <jle`> honestly a lot of the "monads are ..." things that are iffy/tenuous can be replaced with "monads can be used for..." and work perfectly well without requiring any hand waving or dishonesty
23:20:40 <jle`> and it's ok to never have a unified intuition for all monads
23:20:51 <ReinH> jle`: yes it is
23:20:56 <napping> for subsitution, your M a is like a tree with values of type a in (some) leaves,
23:20:58 <ReinH> there is an intance in base
23:21:35 <jle`> ReinH: oh hey, neat, i checked before but i missed it
23:21:39 <napping> and given a function (f :: a -> M b) that makes a whole subtree from a value, t >>= f goes through the tree and splices in the subtrees
23:21:41 <jle`> yeah, it does make sense
23:21:43 <ReinH> > return () :: Proxy ()
23:21:45 <lambdabot>  Proxy
23:22:01 <jle`> i think i was thinking of Const
23:22:16 <ReinH> return _ = Proxy; _ >>= _ = Proxy
23:22:26 <jle`> for (>>=) you never need to "find" an a to give to the (a -> Proxy b)
23:22:29 <jle`> you can just ignore the f ...
23:22:35 <ReinH> you ignore everything all the time
23:22:47 <jle`> fun :o
23:23:01 <ReinH> Probably useless, but it does exist ;)
23:23:14 <ReinH> OTOH, some free structures seem as much like data structures as they do like computation
23:23:17 <jle`> i know i've used the Applicative instance before when i could have just used `Proxy`
23:23:24 <jle`> just because why not
23:25:24 <jle`> speaking of monads in base, when is that `Monoid w => Monad ((,) w)` instance going to come?
23:27:13 <paaavo> Does anyone have any experience with the different Haskell FRP libraries? I'm looking for something that would feel similar to Elm, but open to other options too if the Elm way of doing things isn't well supported, or somehow inferior.
23:28:48 <jle`> Elm way of things is great :) (but be careful about calling it frp around certain crowds ;) )
23:29:45 <paaavo> I really enjoy Elm, and that's why I started looking to see if there was a way to do something similar in Haskell.
23:29:55 <jle`> the main haskell frp things are the pull based ones like netwire and the push-pull ones like reactive-banana, reflex, and sodium
23:30:15 <jle`> you might be able to get something similar with the latter group
23:30:23 <paaavo> What's the difference between pull and push-pull?
23:30:34 <jle`> i've also written a few projects that look very similar to how they are implemented in elm
23:30:39 <jle`> in a library called "auto"
23:31:12 <jle`> netwire and its related libraries are good when you want things that make sense to update at every frame
23:31:34 <jle`> like, a video game, or animation
23:32:11 <jle`> the latter are good for things like GUIs and turn-based games where things are driven by discrete events
23:32:42 <paaavo> Okay. Sounds like you're right. The latter is probably closer to what I'm after.
23:32:57 <jle`> yeah
23:33:12 <jle`> reflex is one with a very active maintainer and community -- they're usually on #reflex-frp :)
23:33:28 <jle`> sodium and reactive-banana are the traditional favorites but reflex is fairly new and sexy
23:33:49 <paaavo> I like sexy :)
23:33:57 <jle`> it's also designed around browser / html+js apps
23:34:07 <ReinH> reflex is hard to come to grips with unless you're good at reading types instead of documentation
23:34:18 <jle`> whereas sodium and reactive-banana are more general-purpose adaptable libraries
23:34:46 <ReinH> There are examples at least
23:34:49 <jle`> so you might have to do extra work to bind it to whatever platform you are using.  which is what elm was really good at removing the burden of
23:36:17 <beepbeep_> jle` it's a haskell lib aimed at browser? so it transpiles?
23:36:30 <jle`> it compiles to ghcjs i believe
23:36:33 <jle`> er, to js
23:36:35 <jle`> w/ ghcjs
23:36:55 <jle`> but almost any haskell library can be compiled to js anyways :)
23:37:34 <beepbeep_> and the difference with elm is that this is haskell? 
23:37:46 <beepbeep_> theres probably more differences :P
23:37:51 <beepbeep_> cool, gonna read about this
23:45:47 <paaavo> jle` Thanks for the pointers! Looks like I have some research to do.
23:47:42 <jle`> np!
23:53:22 <ReinH> It's pretty nice to be able to share your haskell code on both server and client.
