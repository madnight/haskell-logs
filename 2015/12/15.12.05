00:01:05 <jle`> hm
00:01:08 <jle`> oh, sequence
00:01:20 <jle`> > sequence [even, odd, (> 0)] 2
00:01:22 <lambdabot>  [True,False,True]
00:01:25 <jle`> ^ ProofTechnique 
00:01:33 <ProofTechnique> I thought about sequence, but I think I jumped to sequenceA for some reason
00:01:35 <jle`> sequence :: [a -> b] -> a -> [b]
00:01:39 <jle`> both work here
00:02:07 <jle`> sequence turns an [a -> b] into an (a -> [b]).  feeds the same item into all of the functions and returns the results
00:02:31 <jle`> i've used sequence before, but definitely only ever the partially applied version to get the (a -> [b])
00:03:16 <ProofTechnique> sequence is exactly what I mean. For some reason the types weren't matching up. I must have written the signature wrong. Haha
00:03:18 <ProofTechnique> Figures
00:05:47 <ProofTechnique> Thanks very much for the sanity check, all
00:07:39 * hackagebot haskell-src-exts 1.17.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.17.1 (mpickering)
00:07:39 * hackagebot yesod-auth-oauth2 0.1.5 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.5 (PatrickBrisbin)
00:17:28 <ProofTechnique> Is there a changelog for HSE? I'm interested in the big changes between 1.16 and 1.17
00:17:40 <ProofTechnique> Oh, there it is :|
00:18:23 <ProofTechnique> Good stuff all around :)
01:36:34 <overoxeide> anyone know how to bypass airos login?  haskell
02:12:37 * hackagebot skemmtun 0.1.0.0 - A MyAnimeList.net client.  https://hackage.haskell.org/package/skemmtun-0.1.0.0 (nyorem)
02:32:19 <YuleAthas> This is off-topic, but my guess is that this is a good place to ask: which software would you recommend for designing an academic poster?  LaTeX?
02:46:23 <osfameron> YuleAthas: honestly, I'd use presentation software (Keynote, "Impress", or Powerpoint).  That's probably not the best tool though :D
02:47:06 <osfameron> I suspect some DTP or graphics tool would be ideal.  Latex could do it, if you like it.
02:47:52 <moop> dunno about academic poster, but i usually use impressjs for presentations
02:48:47 <YuleAthas> osfameron: yeah, LaTeX rapidly began looking like a bad idea.  I'm thinking Inkscape now, as I have some experience with it.
02:49:55 <osfameron> moop: oo, a prezi-clone in js!
02:50:13 <paolino> hello, is there a way to import data family instance constructors ?
02:50:37 <paolino> (associated)
02:51:17 <moop> osfameron: don't know about prezi, but yes in js
02:51:27 <moop> not bad tho, found easy to set up
02:51:28 <paolino> I'd just like to make clear in the import list where do they come from
02:51:53 <osfameron> moop: how do you author slides for it?
02:52:58 <moop> you just clone the repo and modify the htmlr
02:54:48 <osfameron> hmm, so you have to keep track of where you postioned them yourself?
02:55:03 <moop> yeah
03:02:36 <absence> are there library functions for converting Bool to Maybe or Either to be able to use predicates in a monadic code?
03:03:08 * hackagebot dawdle 0.1.0.1 - Generates DDL suggestions based on a CSV file  https://hackage.haskell.org/package/dawdle-0.1.0.1 (arnon)
03:05:04 <mniip> absence, you could use bool, maybe, and either
03:05:45 <mniip> although sounds like you want when and unless
03:05:50 <mniip> :t [when, unless]
03:05:52 <lambdabot> Applicative f => [Bool -> f () -> f ()]
03:09:43 <absence> mniip: not quite, my question was actually not quite right. a problem i sometimes encounter is when lifting a predicate into the Maybe or Either monad, and end up with a Maybe Bool or Either e Bool. i'd like an easy way to "join" them, as there are two layers of possible failure
03:11:25 <mniip> :t (>>= guard)
03:11:26 <lambdabot> (Monad m, Alternative m) => m Bool -> m ()
03:11:30 <mniip> absence, ^
03:19:47 <absence> mniip: ah right, that one came up earlier as well :) it's good for Maybe, but Either doesn't have an Alternative instance
03:19:54 <jle`> :t mfilter id
03:19:56 <lambdabot> MonadPlus m => m Bool -> m Bool
03:21:53 <absence> jle`: similarly, Either doesn't have a MonadPlus instance
03:24:02 <mniip> :t bool fail (return ())
03:24:03 <lambdabot>     Couldn't match type ‘()’ with ‘m a’
03:24:03 <lambdabot>     Expected type: String -> m a
03:24:03 <lambdabot>       Actual type: String -> ()
03:24:14 <mniip> :t bool (fail "") (return ())
03:24:15 <lambdabot> Monad m => Bool -> m ()
03:24:34 <mniip> oh wait, Either's fail doesn't do that
03:24:54 <mniip> absence, yeah you'll have to >>= into bool
03:41:24 <absence> mniip: what do you mean by >>= into bool?
03:44:24 <mniip> :t (>>= (Left "Falsey") (Right "Truey"))
03:44:26 <lambdabot>     Couldn't match expected type ‘Either a0 [Char] -> a -> m b’
03:44:26 <lambdabot>                 with actual type ‘Either [Char] b0’
03:44:26 <lambdabot>     The function ‘Left’ is applied to two arguments,
03:44:30 <mniip> :t (>>= bool (Left "Falsey") (Right "Truey"))
03:44:32 <lambdabot> Either [Char] Bool -> Either [Char] [Char]
03:45:51 <absence> oh, a bool function! where's that defined?
03:46:36 <mniip> :t Data.Bool.bool
03:46:37 <lambdabot> a -> a -> Bool -> a
03:50:22 <mrt2> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
03:51:16 <Phyx-> :t bool
03:51:17 <lambdabot> a -> a -> Bool -> a
03:51:32 <Phyx-> (o.o)
03:54:57 <absence> right, so a guardEither could be something like bool (Right ()) . Left
03:56:20 <absence> thanks mniip 
04:35:13 <paolino> anyone on the constructors import  question ?
04:41:50 <pavonia> paolino: Have you seen https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html#data-family-import-export ?
04:46:32 <mrt2> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
04:46:46 <mrt2> above top secret
04:47:58 <osfameron> irc spam is getting weirder
04:53:32 <mniip> it's worth noting that ld50 of DMT is ~60mg which makes the above advice dangerous
04:55:46 <osfameron> I'd never have guessd
05:01:47 <paolino> pavonia, yes, I started from there
05:04:57 <paolino> probably I cannot understand it. It sounds to me that from "instance C a where data D a = R", R should be imported with import D (R)
05:06:12 <paolino> ehm, import Module (D(R))
05:06:20 <pavonia> Yeah
05:31:23 <anohigisavay> hi
05:31:50 <anohigisavay> i'm trying to make a shared library for a mono executable
05:32:11 <anohigisavay> i compiled with ghc -O2 --make -dynamic -shared -o
05:32:57 <anohigisavay> when running the built exe i got this error:
05:33:01 <anohigisavay> Mono: DllImport error loading library 'libHelloWorld.so': '/usr/lib64/ghc-7.10.2/ghcpr_8TmvWUcS1U1IKHT0levwg3/libHSghc-prim-0.4.0.0-8TmvWUcS1U1IKHT0levwg3-ghc7.10.2.so: undefined symbol: stg_forkOnzh'.
06:00:10 <JagaJaga> Why free monad is "nice and cool"? Or it isn't useful? :)
06:02:17 <lynnard> I wonder if any of you guys knows how to search the doc for an operator?
06:02:32 <lynnard> I tried hoogle, but it does't seemt to work well with symbols
06:06:18 <ChristianS> lynnard: you have to write the operator in parentheses
06:06:23 <fakedrake> hello!
06:06:31 <fakedrake> are there any decent libraries for data visualization ?
06:07:05 <fakedrake> (for now I want to make histograms but this is a recurring thing)
06:08:15 <lynnard> ChristianS: doesn't seem to work for me... tried (^.) on www.haskell.org/hoogle, no result
06:10:31 <addd> lynnard: hoogle doesn't index everything
06:11:00 <lynnard> does it mean I have to install hoogle myself and index these symbols...?
06:11:03 <addd> lynnard: in particular, i don't think it indexes the lens library
06:11:11 <addd> yeah that might work
06:11:15 <lynnard> ah, what a pain...
06:11:23 <addd> well, it'd be a bigger pain if hoogle indexed everything
06:11:31 <lynnard> why?
06:11:54 <addd> well would you be interested in every package on hackage out there?
06:12:07 <lynnard> certainly I'd be interested in lens
06:12:18 <addd> clearly not. but now you have all of these half-assed attempts at a library obfuscating your search results
06:12:55 <lynnard> but as it stands out - seems like the value of these packages diminish greatly because other users having a hard time knowing what they really do
06:14:02 <addd> well, i don't know the exact criteria for including a package. but i'm happy hoogle is not a mess.
06:14:07 <lynnard> I mean - imagine me writing a piece of code, it doesn't matter if it's only for me; but if someone is going to read it, and I put in a symbol operator that hoogle doesn't index and I can't google it in ANY place, what's the point..?
06:14:59 <lynnard> yet library authors still like symbols...
06:15:43 <addd> lynnard: in practice, it doesn't happen often that people are *only* interested in a library because it exposes a symbol with a certain type
06:16:53 <lynnard> mhh, I think you misunderstood what I meant - I mean writing something that *uses* a symbol operator from another library, say lens
06:17:17 <lynnard> then user come along and look at the code and don't know what it does and can't google it
06:17:24 <addd> lynnard: ah right
06:17:42 <addd> lynnard: well there are tools that can parse your code into hyperlinked HTML
06:18:16 <lynnard> ...right.. I has been my conviction that haskell is a language that serves well to the author and not the user
06:18:40 <lynnard> two keystrokes from an author can kill my afternoon just to find some information about it..
06:18:40 <addd> a user shouldn't need to read the implementation
06:19:02 <addd> if a user is reading the implementation, the author didn't do a good job
06:19:13 <addd> IMO
06:19:37 <rcat> addd: sometimes, with the lack of documentation in Haskell libraries, you only chance is to read the library code
06:19:55 <addd> rcat: which is why i consider documentation part of the author's responsibility :)
06:19:58 <lynnard> well, I meant user as a developer who's using a piece of code for his development
06:19:59 <rcat> which, with the new haddock adding links, it's way nicer
06:20:46 <ChristianS> lynnard: try http://hoogle.haskell.org/?hoogle=%28^.%29 , that index is more complete than the other one
06:21:44 <lynnard> ChristianS: that helps so much, thx a bunch
06:25:06 <addd> i remember there being some consensus that you shouldn't need to set ghc-options in *.cabal files. does anyone know more about this?
06:25:21 <addd> like, i remember it being said that you shouldn't need to set -O2 -Wall etc
06:25:27 <addd> (by default, anyway)
06:38:37 <mrt2> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
06:40:47 <ChristianS> addd: i don't think there is such a consensus, ghc-options in *.cabal are fine
06:54:12 * hackagebot protocol-buffers 2.1.9 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.9 (k_bx)
06:54:14 * hackagebot protocol-buffers-descriptor 2.1.9 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.9 (k_bx)
06:54:16 * hackagebot hprotoc 2.1.9 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.9 (k_bx)
07:13:16 <fakedrake> is there a way to make regexes work with unicode (Text type)?
07:14:08 <addd> where would be a a sane place to write Arbitrary instances for my types? I'm personally only intending to use them for my quickcheck-based test suite.
07:14:45 <sweetleaf> Hi, I am a beginner trying to create a simple function and can't really find the issue from compiler's message. Can someone please help me? http://lpaste.net/146519
07:15:12 <sm> fakedrake: I don't know about the others, but http://hackage.haskell.org/package/regex-tdfa-1.2.1/docs/Text-Regex-TDFA.html claims to have some unicode support
07:15:14 <mniip> sweetleaf, and the message is?
07:15:54 <bernalex> tdammers: ping
07:16:28 <sweetleaf> mniip: http://lpaste.net/146520
07:16:58 <mniip> sweetleaf, there's your problem
07:17:10 <mniip> newStdGen returns an IO action that produces a number
07:17:15 <mniip> er
07:17:17 <mniip> produces a generator
07:17:22 <bernalex> sweetleaf: gen <- newStdGen rather than let gen = newStdGen
07:17:35 <mniip> bernalex, it's still a let binding
07:17:50 <sweetleaf> thanks guys, let me think about it and give it a shot
07:18:04 <bernalex> sweetleaf: but please make an effort to understand the error! understanding types and errors will let you avoid this in the future. do you nderstand the different between <- and let here?
07:18:24 <mniip> bernalex, there is no <-
07:18:55 <bernalex> mniip: using gen <- newStdGen will work, let gen = newStdGen won't. but it's important they understand why.
07:19:04 <mniip> <- won't work either
07:19:10 <mniip> it would be a syntax error
07:19:21 <bernalex> mniip: ohhh they're not in IO
07:19:37 <mniip> s/IO/do/
07:19:38 <fakedrake> sm: hmm... `Data.Text.pack "abc" =~ "a" :: (Text, Text, Text)` claims there is no instance for (RegexLike Regex Text)
07:19:38 <bernalex> sweetleaf: then I misread completely, sorry. mniip is right.
07:20:05 <bernalex> mniip: just using "do" wouldn't work if it were a [Int] or Maybe Int either.
07:20:24 <mniip> but that woulnd't be a syntax error at least
07:20:44 <bernalex> mniip: ah, right. I meant wrt their code, not wrt <-.
07:21:01 <bernalex> sweetleaf: anyway. do you know how IO works in haskell?
07:21:02 <sweetleaf> no problem, ill think what mniip told me and see if I understand how I should code that
07:21:20 <bernalex> sweetleaf: but you don't really want to do that. :]
07:21:24 <sweetleaf> bernalex: to be honest no
07:21:30 <bernalex> that's the caveat. you don't *want* IO in that function.
07:21:38 <sweetleaf> this is my second function in Haskell
07:21:39 <mniip> sweetleaf, if you intend on using newStdGen you'll have to refactor your function
07:21:52 <sweetleaf> ok
07:22:11 <bernalex> sweetleaf: what I would honestly do is just avoid IO for now until you get the very utter basics of the language first.
07:22:13 <mniip> sweetleaf, maybe try something simpler then
07:22:26 <bernalex> @where learnhaskell
07:22:27 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:22:33 <mniip> IO is rather complicated
07:22:37 <bernalex> sweetleaf: maybe try that link^ ? many people enjoy it
07:23:38 <bernalex> sweetleaf: I should ask how much programming do you know in general? do you know any other lanugages? are you a professional programmer? etc. (don't worry if the answer is "no" on both accounts! it's just useful to know for helping you.)
07:24:38 <sm> fakedrake: I don't know why that is, I use some easier regex-tdfa helpers from Hledger.Utils.Regex
07:24:38 <bernalex> also, while I'm here, can someone help me with my non-haskell problem? :p I don't understand how I, by induction, show that 'S -> S S + | S S * | a' is unambiguous. if anyone knows, feel free to help me. pm me if it's too off-topic. :]
07:24:52 <sweetleaf> bernalex:  yeah I pay my rent writing Java and on my free time I enjoy solving some algo problem in python
07:25:26 <bernalex> sweetleaf: OK, then the link I pasted should be useful for you. it's likely too tough if you don't know programming at all, but it sohuld work for you. of course we can help you as you go.
07:26:22 <mniip> bernalex, parse from the end, if if it's 'a', return it immediately, otherwise if it's an operator, read it, and recurse two times and return that
07:26:23 <bernalex> sweetleaf: it has quite a bit of exercises, which most people complain about the more popular books lacking.
07:27:12 <bernalex> mniip: I know intuitively that it's unambiguous, but I mean the formal way of proving it, with the proper language and notation.
07:27:13 <sweetleaf> haskell is quite different but I like the idea of solving math problems with it
07:27:55 <mniip> bernalex, lemma 1: if both X and X ++ Y are valid, Y is the empty string
07:27:59 <bernalex> mniip: like BASIS: n = 1. The only derivations in one step are [the ones above]. These are unique. INDUCTION: Assuming all derivations of fewer than n steps produce unique derivations, consider a leftmost derivation of n steps.
07:28:10 <bernalex> mniip: and then something with (lm)=>*, but IDK what. :p
07:29:11 <mniip> bernalex, that comes at the end
07:29:23 <sweetleaf> bernalex: looks good, has theory and exercises. Thanks
07:29:24 <bernalex> sweetleaf: I use it professionally, and the main advantage by far is very boring and very practical: maintenance scales incredibly well.
07:29:35 <mniip> bernalex, can you prove the provided lemma?
07:30:05 <sm> bernalex: ha, at first glance I thought you were talking about java
07:30:07 <bernalex> mniip: you have not given me a language or context free grammar to prove it against.
07:30:17 <mniip> no wait
07:30:20 <mniip> that lemma is wrong
07:30:30 <mniip> it's prepending
07:30:41 <mniip> if both X and Y ++ X are valid, Y is the empty string
07:30:54 <bernalex> mniip: I'm doing the dragon book. there are no words like "lemma" in here. :p I'd prefer solving it within the nomenclature established.
07:31:26 <mniip> lemma is a fancy word for "local theorem"
07:31:27 <bernalex> mniip: you still have no grammar for me to prove that in. what's X? what's Y? what's ++? what's the empty string?
07:31:44 <bernalex> mniip: I know what a lemma is.
07:32:16 <sweetleaf> bernalex: oh you saved yourself from "AbstractBlaBlaManager <S, O, K, P>
07:32:18 <bernalex> mniip: as far as I can tell, proving that a context free grammar is unambiguous means proving that n = 0/1 is unambiguous and then by induction proving that everything fewer than n steps is unambiguous.
07:32:53 <mniip> right but you need to prove something else before that
07:33:06 <bernalex> S (lm)=>^n xs S ys => the there cases or something, heh.
07:33:09 <bernalex> mniip: OK, what is that?
07:33:23 <mniip> mainly that in an infinite stream you can choose at most one valid prefix
07:33:36 <mniip> or finite, that doesn't matter
07:33:52 <bernalex> I think it's unlikely that I am meant to do that at this point, as the book has not covered that.
07:34:27 <bernalex> the book has covered proving ambiguity by the appearance of more than one lawful lm-derivation. proving unambiguity is left to me, apparently. :p
07:34:41 <bernalex> but I'll roll with it for now. how do I prove that?
07:34:50 <mniip> by induction!
07:35:14 <bernalex> what do you mean by "an infinite stream", and what do you mean by "one valid prefix" here?
07:35:22 <mniip> also suffix :S
07:35:28 <mniip> I keep thinking of the reversed language
07:35:39 <bernalex> IDK what you are talking about at all. :]
07:36:42 <mniip> well, I'm unfamiliar with /formal/ language theory terminology
07:36:58 <bernalex> OK that's what I'm trying to learn here :p
07:37:17 <mniip> but I thought you're trying to prove a theorem
07:37:41 <bernalex> yes but I want to do it within the "confines" of the correct formal language, because I need to learn that as well.
07:38:03 <bernalex> (oh, also, not proving a theorem really, just proving that a specific grammar is unambiguous)
07:38:38 <mniip> that's a theorem
07:40:13 <geppettodivacin> bernalex: I covered that kind of thing in a Programming Languages course this semester.
07:40:36 <bernalex> geppettodivacin: chalmers?
07:40:38 <geppettodivacin> The idea is to show that there is only one derivation for any given string.
07:40:45 <geppettodivacin> Chalmers?
07:40:51 <bernalex> geppettodivacin: yes, I know. but you do that by induction, I assume.
07:41:06 <bernalex> geppettodivacin: I meant if you did it at chalmers. it's a school. I'm following their course material. :]
07:42:00 <geppettodivacin> bernalex: I think induction sounds about right. And no, not chalmers. I think it's not uncommon for university CS curriculum.
07:43:07 <geppettodivacin> Although, looking at the grammar you described, it looks ambiguous at first glance.
07:45:26 <bernalex> geppettodivacin: maybe it is? I thought it wasn't. postfix usually isn't.
07:46:29 <bernalex> geppettodivacin: but do you know how this is going to look? because I have basically no clue. I would think that I should consider S (lm)=>* xs S ys, and then do something for all three. but yeah I'm lost.
07:49:18 <geppettodivacin> bernalex: Looking back, we didn't do any formal proofs for this. I'll PM you in a bit after I play with the grammar for a bit.
07:50:32 <bernalex> geppettodivacin: do you have the dragon book? there are some proofs on pps. 204-205 pertaining to verifying a language generated by a grammar. I assume the proof(s) should look like this.
07:52:37 <mrt2> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
07:52:56 <mrt2> its fbi who runs the war in syria for oil
07:52:59 --- mode: ChanServ set +o geekosaur
07:53:08 --- mode: geekosaur set +b *!*yaaic@*.tbcn.telia.com
07:53:08 --- kick: mrt2 was kicked by geekosaur (mrt2)
07:53:15 --- mode: geekosaur set -o geekosaur
07:55:06 <hodapp> ...
07:55:31 <hodapp> He forget "Wake up, sheeple".
08:07:53 <moop> wake up programmers
08:09:59 <mniip> moop, where's my coffee
08:11:13 <moop> npm install coffee
08:13:19 <hpc> moop: didn't use yum, i award that joke 7/10
08:14:59 <bu5hm4n> hi, I have this file https://gist.github.com/marcelhollerbach/c80a9146e830144fb745 
08:15:28 <bu5hm4n> it does not compile and says ‘publishFrame’ is not a (visible) method of class ‘SofwareBuffer’, looks like it want Softwarebuffer to be a Renderer
08:15:40 <bu5hm4n> but I just want renderer implemented with SoftwareBuffer as a
08:24:15 * hackagebot bytestring-tree-builder 0.2.1.1 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.1.1 (NikitaVolkov)
08:36:09 <lyxia> bu5hm4n: you are trying to implement "a" as an instance of "SoftwareBuffer" but that does not make sense because SoftwareBuffer is not a class.
08:37:02 <lyxia> What is your actual intent?
08:37:07 <bu5hm4n> lyxia: ok fixed it, was a misstake in my head
08:37:15 <bu5hm4n> Software Renderer is not needed 
08:37:22 <lyxia> ok
08:37:45 <bu5hm4n> :)
08:47:01 <bollu> what exactly is a pipes Effect?
08:47:20 <bollu> also, pipes feels cool to use, though I don't understand what is happening
08:49:22 <bollu> does the pipes `for` exploit the continuation monad in some way?
08:49:38 <bollu> because a Pipe "yield" seems to be acting like a continuation ish thing?
08:49:52 <monochrom> yes
08:50:06 <bollu> monochrom: isomorphic to Cont?
08:50:11 <monochrom> I forgot
08:50:18 <bollu> ah, alright
08:50:27 <bollu> I'll keep working through the tutorial
08:51:31 <bollu>  https://hackage.haskell.org/package/pipes-4.1.7/docs/Pipes-Core.html#v:runEffect :: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html#t:Monad m => https://hackage.haskell.org/package/pipes-4.1.7/docs/Pipes-Core.html#t:Effect m r -> m r | so in some sense it's some reverse Pointed thing?
08:51:43 <bollu> oh crap, sorry, I didn't know the IRC client handled URLS that way
08:51:58 <bollu> runEffect :: Monad m => Effect m r -> m r 
08:52:13 <bollu> does that mean that runEffect sort of strips the "Effect" off the underlying monad by running it?
08:56:17 <V9pid> how can i convert an MVector s Char to a bytestring?
08:58:16 <V9pid> i can't just toList and BString.pack a mutable vector
08:59:32 <V9pid> nevermind
09:09:16 * hackagebot libgraph 1.9 - Store and manipulate data in a graph.  https://hackage.haskell.org/package/libgraph-1.9 (faddegon)
09:19:16 * hackagebot pinchot 0.2.0.0 - Build parsers and ASTs for context-free grammars  https://hackage.haskell.org/package/pinchot-0.2.0.0 (OmariNorman)
09:30:55 <ski> bollu : apparently, `type Effect = Proxy X () () X', where `Proxy a1 a0 b1 b0 m' is a monad transformer .. so it looks like `runEffect' is the way to "run" this, getting "out" of it, back to the underlying monad one based it on (like possibly `IO', i assume)
09:31:55 <bollu> ski: thank you :)
09:31:59 <arthur> why is (+) . map legal haskell?
09:32:10 <aweinstock> :t (+) . map
09:32:12 <lambdabot> Num ([a] -> [b]) => (a -> b) -> ([a] -> [b]) -> [a] -> [b]
09:32:28 <Guest69026> yea i don't see how that makes sense
09:32:37 <Guest69026> (+) takes 2 number
09:32:42 <Guest69026> numbers 
09:32:45 <Guest69026> and map returns a list
09:32:49 <Guest69026> how does that work?
09:33:19 <Guest00000> > Num ([a] -> [b])
09:33:21 <lambdabot>      Not in scope: data constructor ‘Num’
09:33:21 <lambdabot>      Perhaps you meant one of these:
09:33:21 <lambdabot>        ‘Sum’ (imported from Data.Monoid),
09:33:34 <Phyx-> It doesn't, unless you can somehow define Num on functions
09:33:37 <Guest00000> it requires that function from lists to lists be a number...
09:33:57 <aweinstock> it requires functions from lists to lists to be numbers, so you can't call it until you define what that means
09:34:00 <Phyx-> but typewise, there's nothing against the unification
09:34:30 <Guest69026> it's used in main = interact $ show.maximum.scanl1 (+).map (negate.foldl1 (-).map read.words).tail.lines
09:35:06 <Guest69026> -> they don't define Num on functions
09:35:07 <lyxia> (scanl1 (+)) . (map (...))
09:35:16 <Phyx-> the (+) is an argument to scanl
09:35:20 <Phyx-> not to the compose (.)
09:35:52 <Guest69026> ohhh
09:35:53 <lyxia> who dares not put spaces around (.)
09:35:59 <Guest69026> same with the (-).map ?
09:36:04 <Guest69026> that goes to foldl1 ?
09:36:24 <Guest69026> the (-)
09:36:27 <lyxia> yes
09:36:49 <Phyx-> yeah that spacing is really horrible :/
09:36:52 <Guest69026> does (.) have really low precedence?
09:37:03 <Guest69026> how do i see its precedence?
09:37:06 <Phyx-> @src (.)
09:37:07 <lambdabot> (f . g) x = f (g x)
09:37:13 <Phyx-> hmm thought it showed it
09:37:20 <Phyx-> Guest69026: haddock should show it
09:37:22 <glguy> really high
09:37:28 <glguy> Go in GHCi and type :i .
09:37:54 <Phyx-> @info (.)
09:37:55 <lambdabot> (.)
09:38:02 <Phyx-> lol, thanks lambabot
09:38:14 <Guest00000> (.) has precedence 9
09:38:39 <Guest69026> okay so that's why
09:38:44 <Guest00000> it is maximum,
09:39:02 <Guest00000> but the normal function application has higher-than-maximum precedence
09:39:26 <Guest69026> yea
09:39:29 <Guest69026> cool
09:39:31 <Guest69026> thanks all
09:40:38 <Phyx-> boy it's confusing having multiple guests lol
09:41:25 <hpc> wait, did you randomly get Guest00000 or did you aim for it?
09:43:38 <Guest00000> i entered the name.
09:43:57 <Phyx-> he has just been here since the start of webchat :)
09:49:40 <ski> Phyx- : there is no `info' command in lambdabot
09:51:17 <Welkin> Guest00000: Guest88143 : Guest69026 : Guest31976 : Guest30177 : Guest53011 : Guest3764 : Guest53187 : Guest50975 : Guest27898 : Guest8123 : Guest28969 : PLEASE USE A REAL NICK THANKS
09:51:46 <breadmonster> Welkin: That seemed unnecessary.
09:52:04 <Welkin> breadmonster: stand down 834645
09:52:09 <Welkin> it was a false alarm
09:52:13 <Welkin> 3454564 will take care of it
09:52:22 <breadmonster> lol
09:52:39 <Phyx-> ski: i figured it autocorrected it to something
09:57:30 <cow_2001> i have a problem with haskellnet. i have a function which fetches an email and results in (IO Data.ByteString.Char8.ByteString)
09:57:37 <cow_2001> when i try to print it
09:57:39 <cow_2001> oh
09:57:42 <cow_2001> i get it now
09:57:56 <cow_2001> holy crap how didn't i see it :(
09:59:02 <cow_2001> wait, nope
09:59:35 <Guest00000_> Welkin: that's my real nickname...
09:59:48 <ga2arch> cow_2001: take a deep breath :)
10:02:53 <ski> Phyx- : yes, to `undo'
10:03:56 <breadmonster> cow_2001: I don't think bytestrings are meant to be printed.
10:04:51 <Phyx-> ski: ah, makes sense
10:05:12 <cow_2001> actually, it freezes when i just fetch without doing anything with it
10:05:16 <cow_2001> swaps hard
10:05:32 <Guest69026> ($4) :: Num a => (a -> b) -> b
10:05:37 <Guest69026> what does ($4) mean ?
10:05:53 <Welkin> 4 dollahs
10:06:07 <Guest69026> lol
10:06:08 <ski> it is `$' partially applied to `4', on the right
10:06:18 <ski> compare with e.g. `(/ 4)'
10:06:24 <V9pid> <breadmonster> cow_2001: I don't think bytestrings are meant to be printed.
10:06:30 <V9pid> why would you ever want to print a string
10:06:31 <V9pid> oh wait
10:07:04 <Guest69026> o see now, thanks ski!
10:07:09 <cow_2001> ;_;
10:07:15 <Welkin> bytestrings may contain non-printable characters
10:07:24 <Welkin> although regular strings may as well :D
10:07:53 <cow_2001> i don't even print
10:07:56 <cow_2001> D:
10:08:39 <P4Titan> Hello all, is there a way inside of ghci to break on a condition like in gdb?
10:08:41 <Welkin> do you even print
10:08:57 <ga2arch> cow_2001: show us some code, http://lpaste.net/
10:09:02 <cow_2001> oh
10:10:22 <Guest69026> how do i bind the second arguments of a function? i want to create a function which takes in a function and applies it to a specific list
10:10:29 <Guest69026> the second argument
10:10:48 <breadmonster> ski: Can I PM?
10:11:29 <lpaste> cow_2001 pasted “haskellnet-ssl fetch imap” at http://lpaste.net/146529
10:11:37 <ga2arch> Guest69026: myfun f = let mylist = [1,2,3] in map f mylist ?
10:12:18 <Guest69026> okay, is there a more elegant way of doing the binding?
10:12:43 <mniip> myfun f = map f [1,2,3]
10:12:57 <P4Titan> Guest69026: flip map [1, 2, 3]
10:12:59 <mniip> myfun = (`map` [1,2,3])
10:13:19 <Welkin> OR!
10:13:29 <Guest69026> awesome, thanks all!
10:13:37 <Welkin> (<$> [1,2,3])
10:13:39 <cow_2001> ^^^ the paste thing
10:13:39 <Welkin> wait does that work
10:13:45 <mniip> myfun = lowerCoyoneda . (`Coyoneda` [1,2,3])
10:13:49 <Welkin> :t (<$> [1,2,3])
10:13:50 <lambdabot> Num a => (a -> b) -> [b]
10:13:53 <Welkin> yeah :D
10:13:55 <P4Titan> dang Welkin
10:14:04 <Guest00000_> @info Coyoneda
10:14:04 <lambdabot> Coyoneda
10:14:07 <P4Titan> nice
10:14:07 <Welkin> > (<$> [1,2,3]) (+1)
10:14:09 <Guest00000_> ...
10:14:09 <lambdabot>  [2,3,4]
10:14:22 <mniip> :t Data.Functor.Coyoneda.Coyoneda
10:14:23 <Guest00000_> what is a coyoneda....
10:14:24 <lambdabot> (b -> a) -> f b -> Data.Functor.Coyoneda.Coyoneda f a
10:14:26 <geekosaur> no :info / @info
10:14:34 <P4Titan> Hello all, is there a way inside of ghci to break on a condition
10:14:34 <P4Titan>           like in gdb?
10:14:35 <mniip> :t Data.Functor.Coyoneda.lowerCoyoneda
10:14:36 <lambdabot> Functor f => Data.Functor.Coyoneda.Coyoneda f a -> f a
10:14:46 <Welkin> P4Titan: not that I know of
10:14:59 <Welkin> P4Titan: but maybe
10:15:00 <ga2arch> cow_2001: and what's wrong with that code ? it doesn't print ?
10:15:04 <P4Titan> because I have a double do block which I iterate through two lists
10:15:07 <P4Titan> of x and y coords
10:15:17 <P4Titan> and I want to break at a specific pixel
10:15:26 <Welkin> I jave never debugged haskell that way before
10:15:33 <Welkin> I just use print or debug.trace
10:15:42 <Welkin> or profiling
10:15:46 <mniip> I tried debugging haskell with gdb once
10:15:49 <P4Titan> what is profiling
10:15:54 <cow_2001> ga2arch: it's not supposed to print
10:16:01 <mniip> it was... okay until the gc kicked in
10:16:06 <Welkin> P4Titan: time and memory usage for different parts of the program
10:16:12 <P4Titan> kk
10:16:20 <cow_2001> ga2arch: i mean, there's a bit where it prints, but the real issue is the `fetch` function
10:16:45 <P4Titan> I cannot find a way to break on a condition, nor do I want to iterate manually until I get to the desired pixel
10:16:46 <ga2arch> cow_2001: mmm, ok, paste the code of that function maybe ? 
10:17:05 <cow_2001> oh, right! :D sorry
10:17:20 <cow_2001> let's see what version of haskellnet-ssl do i use
10:17:27 <Welkin> P4Titan: use debug.trace
10:17:35 <Welkin> P4Titan: and just print out the data you want to know
10:17:42 <P4Titan> ... yeah
10:17:44 <P4Titan> i guess
10:17:55 <Welkin> I know there is some way to properly debug haskell
10:17:59 <Welkin> but I don't know what it is
10:18:03 <ga2arch> cow_2001: ah sorry, i thought fetch was one of your functions, i'm looking at it on hackage 
10:18:11 <P4Titan> ghci has its debugger features
10:19:35 <Welkin> P4Titan: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
10:19:40 <cow_2001> http://haddock.stackage.org/lts-3.16/HaskellNet-0.4.5/Network-HaskellNet-IMAP.html#v:fetch
10:19:52 <cow_2001> http://haddock.stackage.org/lts-3.16/HaskellNet-0.4.5/src/Network.HaskellNet.IMAP.html#fetch
10:19:55 <Welkin> interesting :D
10:20:01 <Welkin> I didn't know ghci could set breakpoints
10:20:06 <cow_2001> wat
10:20:12 <cow_2001> breakpoints?!
10:20:27 <Welkin> cow_2001: yeah, it is like a lagrange point where you must breakdance
10:20:29 <cow_2001> how how how! (/me reads)
10:20:36 <nchambers> guys I just did cabal install happy which installed happy v1.19.5, but when I do cabal install haskell-src-exts, it says install failed due to not finding happy >= 1.19
10:20:41 <nchambers> how can i fix this?
10:20:43 <Phyx-> yes, but be careful about forcing the evaluation of unevaluated values
10:20:50 <Welkin> nchambers: put happy on your path
10:21:05 <geekosaur> nchambers, make sure ~/.cabal/bin is early in $PATH
10:21:20 <nchambers> > Warning: The directory /home/nchambers/.cabal/bin is not in the system search path
10:21:22 <lambdabot>  <hint>:1:58: parse error on input ‘in’
10:21:26 <nchambers> guess I should read the installs better
10:21:33 <nchambers> thanks Welkin, geekosaur 
10:21:47 <ga2arch> nchambers: if you're just starting out, look into stack 
10:22:08 <ga2arch> nchambers: http://docs.haskellstack.org/en/stable/README.html
10:24:00 <nchambers> thanks I'll check it out
10:36:18 <fakedrake> is there a function like (.) but where the right hand function takes two arguments. Not sure if this signature is correct: (..) :: (a -> b) -> (b -> c -> d) -> c -> d -> a
10:36:54 <fakedrake> I mean in prelude or sth 
10:37:22 <Guest00000_> the signature is wrong.
10:38:07 <Guest00000_> at the end, (..) returns an a, but it cannot get it from anywhere
10:38:18 <Welkin> :t ((.).(.))
10:38:20 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:38:25 <Welkin> :D
10:38:44 <Welkin> fakedrake: ^
10:38:44 <cow_2001> :\
10:40:11 <fakedrake> Welkin: exactly! thank you!
10:53:04 <mzabani> hello there, would anyone help me out with an unsafePerformIO experiment? I'm very new to Haskell and can't understand a bug I'm facing
10:54:40 <ski> if you're new to Haskell, then you probably shouldn't try to use `unsafePerformIO' (you shouldn't normally use it if you're more familiar with Haskell, either)
10:55:15 <Welkin> lol
10:55:22 <Welkin> I have never used it :D
10:55:28 <Welkin> never found a need
10:55:28 <ski> in any case, the standard procedure is to put your code online somewhere where we can have a look at it. e.g. a paste site
10:55:31 <ski> @paste
10:55:32 <lambdabot> Haskell pastebin: http://lpaste.net/
10:55:35 <mzabani> well, I'm trying to experiment with FFI while creating a Random-like monad, one you can't escape from
10:55:59 <mzabani> I thought it would be a nice way to learn about these things. It's really not for production.
10:56:29 <mzabani> I'll paste it, just a minute
10:57:29 <mzabani> http://lpaste.net/146530
10:57:52 <cow_2001> any ideas?
10:58:12 <mzabani> the problem is that consecutive calls to "random" are returning the same random number
10:59:19 * hackagebot unique-logic-tf 0.4.1.2 - Solve simple simultaneous equations  https://hackage.haskell.org/package/unique-logic-tf-0.4.1.2 (HenningThielemann)
11:00:13 <geekosaur> unsafePerformIO gives the compiler license to assume the function is constant; at a call site, it can get hoisted out and shared instead of multiple calls
11:00:14 <Welkin> mzabani: that isn't a bug
11:00:14 <Welkin> :P
11:00:29 <Welkin> if you have the same seed, it will always give the same numbers
11:01:06 <mzabani> Welkin the seeds are different in each call
11:01:09 <geekosaur> the compiler uses purity to make optimizations that would not be safe in other languages. if you creat with unsafePerformIO, you pay for it because those optimizations are still done
11:01:33 <geekosaur> *if you cheat
11:02:07 <mzabani> hmm, I thought that since random returns IO CLong, it wouldn't be memoized
11:02:26 <mzabani> and that unsafePerformIO would just extract the value out of the IO monad
11:03:34 <mzabani> oh, wait.. random receives no parameters.. it should be memoized..
11:03:53 <geekosaur> but you pay to attention to what the caller does. it can memoize or share because random :: (Integral a) => RandState a -> (Integer, RandState a) is not in IO
11:04:23 <mzabani> oops, I meant c_random receives no parameters
11:05:08 <mzabani> geekosaur I was passing it different RandStates when calling it, and thus I was thinking it should work
11:05:57 <mzabani> I think the problem is really with c_random. Since it receives no parameters at all, it is just a constant value to ghc, is it not?
11:06:20 <ski> it's a constant action
11:07:24 <plastic_> in this line: data T a = LF a | N (T a) (T a) (T a), a is a type of T? like T can be 'Shape', and a can be 'Circle'?
11:07:36 <mzabani> I see. So now, it begs the question. Can I write a random-like monad you can't escape from with unsafePerformIO and FFI?
11:07:41 <ski> since `fromIntegral (unsafePerformIO c_random)' doesn't depend on `s', the implementation can possibly hoist it out and share it between multiple calls to `random', as geekosaur says
11:08:09 <geekosaur> plastic_, no. consider how Maybe works.
11:08:11 <tommd> mazbani: Not sure what you want, but have you seen MonadRandom?
11:08:54 <ski> plastic_ : `a' is a type parameter to `T'. in a type application like `T Shape', the formal parameter `a' would be bound to the actual parameter `Shape' (assuming that is a type)
11:09:32 <mzabani> tommd: I haven't seen it
11:09:34 <zacts> is there a channel specific for haskell operating system development?
11:09:40 <zacts> an irc channel that is
11:09:48 <tommd> mzabani: Well now you can go see it!
11:09:55 <zacts> #haskell-osdev is dead
11:10:19 <mzabani> tommd: hmm do you mean to look at the source code? I'm not writing this for production, it's just for learning purposes.
11:10:43 <Welkin> mzabani: look it up in the docs he means
11:10:54 <plastic_> in plain english, how can i read this line? data T a = LF a | N (T a) (T a) (T a)
11:11:18 <Welkin> mzabani: https://hackage.haskell.org/package/MonadRandom
11:11:32 <mzabani> oh, I see! I certainly will!
11:11:58 <Welkin> mzabani: https://wiki.haskell.org/New_monads/MonadRandom
11:15:19 <ski> plastic_ : `T a' is a data type (with `a' as a parameter) with two alternatives/constructors : if `x' has type `a', then `LF x' is a value of type `T a'; if `t0',`t1',`t2' all have type `T a', then `N t0 t1 t2' is a value of type `T a'
11:15:21 <geekosaur> plastic_, for some type "a", T is a tree composed of either a leaf (LF) with a value of type "a" or a node (N) with three subtrees
11:15:42 <geekosaur> the subtrees being of the same type "a"
11:16:33 <miscyb> is it possible to debug libraries downloaded with cabal with "cabal repl"? I want to see what my code ends up doing but when i try to set a breakpoint it says "cannot set breakpoint on *identifier*: module *module* is not interpreted"
11:23:39 <Guest69026> why doesn't ghci show me the precedence of (!!) when I do :i (!!) ?
11:27:33 <MarcelineVQ> Guest69026: that's a great question, mine doesn't either, it is defined for it though so that's weird: `infixl 9  !!`
11:32:55 <mzabani> thank you for the help, everyone. got to go now
11:36:03 <glguy> GHCi only shows fixity when a fixity is explicitly specified
11:36:11 <glguy> otherwise operators have the default fixity of infixl 9
11:37:27 <glguy> Oh, I guess it doesn't matter if it's explicit, if just doesn't display it when it's the default
12:01:43 <zdh> I have a a function f :: a -> m a.    How do i apply this function to its result n times? for example I want a function r :: Int -> a -> (a -> m a) -> ma. So r 3 x f would be equivalent to f x >>= f >>= f
12:04:39 <int-e> hmm. iterate (>>= f) (return x) !! 3
12:07:05 <zdh> cool. thanks.
12:17:31 <varaindemian> why map sum transpose [[1,2,3],[4,5,6],[7,8,9]] doesn t work?
12:17:53 <glguy> Because it parses as:    ((map sum) transpose) [...
12:19:31 <varaindemian> glguy: and ((map sum) transpose) shouldn't return a function that takes a list as argument?
12:19:49 <glguy> :t map sum
12:19:50 <lambdabot> (Num b, Foldable t) => [t b] -> [b]
12:20:04 <glguy> :t transpose
12:20:04 <addd> :t map ((.) sum) transpose
12:20:05 <lambdabot> [[a]] -> [[a]]
12:20:06 <lambdabot>     Couldn't match expected type ‘[a -> t0 c]’
12:20:06 <lambdabot>                 with actual type ‘[[a0]] -> [[a0]]’
12:20:06 <lambdabot>     Probable cause: ‘transpose’ is applied to too few arguments
12:20:16 <OverCoder> [a | a <- xs, a <= x], what <= does here?
12:20:40 <glguy> OverCoder: it filters out the elements 'a' that are not less-than or equal to x
12:20:52 <geekosaur> it's just less-than-or-equal, not an arrow
12:20:57 <addd> haha that's confusing
12:21:24 <glguy> varaindemian: transpose is a function, but 'map sum' is a function expecting a list argument
12:21:25 <Tehnix> varaindemian: transpose is a function, but 'map sum' is a function expecting a list argument
12:21:29 <glguy> varaindemian: lists aren't functions
12:21:39 <geekosaur> heh
12:21:55 <drw> can someone help me understand how to use a string value from a config file in the snap framework?
12:21:57 <OverCoder> Ow, ow, oh man, I forgot that it's less-than or equal, I just thought of it like: the opposite of => is typeclasses lol
12:24:22 * hackagebot Kriens 0.1.0.0 - Category for Continuation Passing Style  https://hackage.haskell.org/package/Kriens-0.1.0.0 (matteo_provenzano)
12:28:06 <lpaste> qfwfq pasted “wat” at http://lpaste.net/146541
12:29:51 <qfwfq> I had assumed in a closed type family the second case would handle the bare domain case.
12:30:12 <qfwfq> s/case.$/./
12:30:14 <qfwfq> Any idea what's up?
12:30:25 <glguy> qfwfq: We don't know, maybe c was a function type
12:30:49 <qfwfq> But wouldn't that pattern match earlier?
12:31:17 <glguy> c could be anything, maybe a function, maybe not
12:31:17 <glguy> so it can't match until there's more information
12:31:46 <qfwfq> Hmm, thanks.
12:41:17 <lindenk> hey, how do I get the first element in a tuple of size >2? fst doesn't seem to work
12:42:24 <glguy> pattern matching
12:42:59 <nchambers> whats the best way to install haskell on a fresh ubuntu system?
12:43:05 * mniip . o O (unpackClosure#)
12:43:18 <AleXoundOS> lindenk, for size == 3: (\(x,_,_) -> x) ('a', 'b', 'c')
12:43:58 <qfwfq> The closed type family paper includes an example (CountArgs) that suggests my example would resolve, but I can't get that to work, so I assume it was implemented differently.
12:44:28 <qfwfq> (http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/axioms-extended.pdf, page 3.)
12:45:11 <glguy> Specifically, CountArgs gets stuck. CountArgs (a → a → a) simplifies to Succ (Succ (CountArgs a)) but can go no further; CountArgs a will not simplify to Zero, be- cause a is not apart from b → c.
12:45:13 <lindenk> hmm, well ok. How about using `where` on only one statement in a `do`. It seems like I can't read data from a file then use it in a `where` after the next statement
12:45:29 <glguy> qfwfq: Go to page 15
12:45:35 <qfwfq> <3
12:46:28 <geekosaur> lindenk, "where" is part of a declaration, it can't be used iwh arbitrary expressions
12:46:31 <geekosaur> *with
12:47:59 <ga2arch> nchambers: haskellstack.org
12:49:01 <nocturne777> isn't the getJSON here inefficient? https://hackage.haskell.org/package/snap-extras-0.11.0.1/docs/src/Snap-Extras-JSON.html#getBoundedJSON
12:49:17 <nocturne777> it is converting twice to the type
12:50:30 <glguy> It looks like it's converting first to a JSON Value and second to the desired FromJSON instance
12:51:04 <nocturne777> glguy: but "fromJSON" is already called as part of the "decode"
12:51:39 <qfwfq> glguy: Thanks a tonne, I'll work through the example.
12:52:27 <glguy> nocturne777: fromJson at the Value instance is a no op
12:52:59 <glguy> 03instance FromJSON Value 03where parseJSON a 07= pure a
12:53:44 <nocturne777> glguy: how so?
12:53:51 <nocturne777> ok 
12:54:26 <nitrix> Hi, I'm struggling to parse ip:port out of a html response. Parsec's manyTill seems to consume the `end` parser.
12:54:39 <nitrix> parseIps = ip `sepEndBy` garbage
12:55:00 <nitrix> garbage = anyChar `manyTill` ip
12:56:01 <nitrix> This incorrectly gives me only the first ip. What's going on?
12:57:02 <ga2arch> nitrix: what's the input ? 
12:57:06 <nitrix> I tried (try ip), variations with lookAhead or notFollowedBy. No luck.
12:57:24 <nitrix> ga2arch: Any html page: http://lpaste.net/146540
12:59:19 <nitrix> To be fair, that's only the goal. My current test input is "123.456.789.101:1234 xx1xx 8.8.8.8:5000 lol 4.4.4.4:213 haha"
13:00:08 <nitrix> Because of sepEndBy, it has to begin with an IP. That's because I'm building the parser iteratively and figured I'd get it to work first before adding more rules.
13:00:22 <nocturne777> glguy: parseJSON is a no-op, but I don't think "parse" is 
13:00:56 <ga2arch> nitrix: that would probably be a better case use for a regex, you really need parsec ? or you're just trying to learn it ?
13:01:05 <nocturne777> parse is called twice: once in decode through fromJSON and again when second when directly calling fromJSON
13:01:08 <nitrix> ga2arch: I think regexes are flawed.
13:01:52 <glguy> nocturne777: It's going from FromJSON a => Bytes --> Value --> a
13:02:03 <ga2arch> nitrix: ok, then parsec it is
13:02:04 <glguy> nocturne777: What step of the process are you concerned about?
13:02:32 <nocturne777> this is fromJSON's implemantion: fromJSON = parse parseJSON
13:03:17 <nocturne777> glguy: what I am trying to say is that fromJSON is called here first decode = decodeWith jsonEOF fromJSON
13:03:52 <glguy> that's fine, parse is doing basically nothing there
13:03:54 <nocturne777> parse is called once as part of that process
13:04:01 <glguy> that's fine, parse is doing basically nothing there
13:04:18 <glguy> You might be misunderstanding what parse does, it's the run function for the Parser type
13:05:09 <glguy> It's not a json parser
13:11:30 <ga2arch> nitrix: many1 (manyTill anyChar (try(ip)) >> ip) maybe something like this ?
13:12:04 <ga2arch> s/try(ip)/try ip
13:13:04 <lpaste> glguy pasted “for nocturne777” at http://lpaste.net/146543
13:21:27 <lpaste> glguy pasted “sloppy parser” at http://lpaste.net/146545
13:21:38 <glguy> nitrix: You could do something like that
13:22:10 <nocturne777> glguy: I see what you mean. In the first line  with A.decode  only json is parsed and Value is returned and Value us converted to the desired in the call with A.fromJSON
13:22:36 <glguy> correct
13:24:23 * hackagebot stack-hpc-coveralls 0.0.3.0 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.3.0 (rubik)
13:26:27 <Guest69026> what does <$> do ?
13:26:56 <dmj> Guest69026: it's infix fmap
13:27:12 <dmj> Guest69026: are you familiar with functors?
13:27:29 <Guest69026> no, do you know of any good docs on them?
13:27:45 <michaelt> > (+1) <$> [1,2,3]
13:27:47 <lambdabot>  [2,3,4]
13:28:48 <dmj> Guest69026: https://wiki.haskell.org/Typeclassopedia#Functor
13:28:54 <michaelt> Guest69026: I think the discussion in 'learn you a haskell' is not too bad http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
13:29:32 <Guest69026> thanks for the references!
13:32:45 <dyamon> hi all, I'm currently studying something about parser generators at the university, and I'm trying to write something simple in order to auto-build a parsing table for LL(1), and then i'll jump to SLR, LR and LARL...
13:33:26 <dyamon> looking for same data structure in order to keep the "tables"
13:33:54 <koz_> dyamon: What exactly does this table store?
13:34:00 * koz_ is not an expert on parsers.
13:34:08 <dyamon> oh
13:34:33 <nitrix> glguy: This is my current attempt: http://lpaste.net/146546
13:34:45 <nitrix> glguy: Usage examples are at lines 38-41.
13:35:26 <nitrix> I still can't seem to discard the "garbage" characters, which are, anyChar until an ip. It reads naturally, and yet... doesn't work.
13:35:55 <dyamon> a parsing table stores grammar rules...the point is: I had a look at the Happy parser generator source and they use an Array
13:36:03 <nocturne777> glguy: in the definition of fromJSON, where is that "parse" function is coming from ?
13:36:15 <nocturne777> I don't think it is coming from Parsec
13:36:29 <dyamon> actually an Array (Int,Int) Stuff
13:36:39 <nocturne777> I have not been able to locate the source of that function
13:36:53 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/146546#a146551
13:37:36 <glguy> nocturne777: Click the source-code link next to it on the haddocks
13:38:52 <nocturne777> glguy: that's what I did :) I was looking for it in the github repo
13:39:41 <nocturne777> glguy: nvm, I found it
13:40:04 <zwefawef> @query lambdabot
13:40:05 <lambdabot> Unknown command, try @list
13:40:11 <zwefawef> fail
13:41:56 <nitrix> glguy: I really appreciate you helping me, but I feel like you're simply taking a different approach; while I still don't understand why my naive one doesn't work.
13:44:03 <glguy> nitrix: It's a different approach because you're taking the wrong approach
13:44:13 <glguy> manyTill is eating the terminator, putting a try on there isn't going to stop that
13:45:06 <tpsinnem> does anyone know if there are any plans for Stack to facilitate safe multi-user sharing of builds, similarly to nix/nixos?
13:45:54 <nitrix> glguy: Is your way the most straight forward one? I've never used the $> thing and monads still confuses me at times.
13:46:49 <glguy> nitrix:   x <$ y    is    y >> return x    here
13:48:20 <DenSchub> is there any syntax sugar to make the name in pattern matchings less repetitive?
13:48:26 <nchambers> would someone mind helping me fix this error? https://github.com/ntchambers/lamb/blob/master/Interp.hs http://ix.io/mEI
13:48:43 <ski> DenSchub : which name ?
13:49:36 <DenSchub> ski: i have a function wit.. here: https://gist.github.com/denschub/dc944ff934ae59a63efe
13:50:05 <DenSchub> i don't like having to repeat getDirection four times. i know guards, but i wonder if there is some syntax sugar ;)
13:50:06 <glguy> nchambers: Should there be an instance? My first guess is that you have more than one version of text installed and that the instance is for a different version
13:50:29 <nchambers> glguy: oh
13:50:46 <ski> DenSchub : if you really want to, you could use a `case'. however, in this case, i'd consider the repetition a feature
13:51:15 <ski>   getDirection d = case d of
13:51:22 <ski>     '(' ->  1
13:51:28 <ski>     ')' -> -1
13:51:35 <ski>     _   ->  0
13:51:35 <DenSchub> yeah, but that's technically not the same
13:51:50 <DenSchub> but thanks, that answers my question
13:51:51 <ski> i'm unsure of what you mean
13:52:35 <DenSchub> i was looking for syntax sugar for actual pattern matching, not replacing it by guards/case :)
13:52:50 <glguy> nchambers: Assuming that the listlike class you're using is the one I here, you need to make sure to add the orphan instances to use it with text
13:52:50 <glguy> https://hackage.haskell.org/package/listlike-instances
13:53:44 <ski> DenSchub : ok. possibly you were looking for disjunctive / or- patterns. unfortunately Haskell doesn't have those :/
13:54:11 <ski> DenSchub : in any case, `case' *is* actual pattern matching
13:54:25 <nchambers> thanks glguy I think that was the issue
13:54:50 <DenSchub> ski: oh
13:56:45 <ski> DenSchub : on second thought, a disjunctive pattern could be used when several distinct patterns (possibly binding variables) are to be mapped to the *same* result. but since in your case you wanted different results, it wouldn't fit here
13:58:24 <ski> <http://rosettacode.org/wiki/Pattern_matching#OCaml> has an example of a use of disjunctive patterns, in OCaml
13:59:34 <MarcelineVQ> that's quite cool glguy thanks for the demo
14:00:03 <MarcelineVQ> for parsing
14:06:49 <utdemir> Hey. I'm trying to add a simple authentication to my Servant API. I added the example code on https://github.com/haskell-servant/servant/blob/master/servant-examples/auth-combinator/auth-combinator.hs#L37 . Now I'm struggling to pass a parameter to "isGoodCookie" function there. Let's say a DB connection. Can anyone show me a direction for this?
14:08:20 <silver> there's #servant (not saying this is offtopic or anything, just sayin')
14:10:06 <utdemir> @silver, Thanks, I'll try there if I don't get an answer here then.
14:10:06 <lambdabot> Unknown command, try @list
14:13:38 <SrPx> Hello. Upon reading some category theory tutorials, I see this: "Objects are types. Morphisms are functions". I'm not sure I understand the distinction. Int, Double, (Int -> Int), (∀ t . (t -> t) -> t -> t) are types. So those are or objects. "(\ x -> x * 2)", "(\ f x -> (f (f x)))" are functions, so those are morphisms. But "3" and "7.3" aren't a type nor a function. What is is?
14:15:51 <michaelt> SrPx: https://en.wikipedia.org/wiki/Exponential_object
14:19:34 <ski> SrPx : as far as category theory is concerned, objects have no elements/inhabitants. there are only arrows/morphisms which relate pairs of objects
14:21:24 <ski> SrPx : in certain cases, one can use morphisms from a "pointer" object to "point at" "elements" in an object. e.g. in the category `Set', any one-element set (which is a terminal object) works. in Haskell, this would be `()' (ignoring partial elements)
14:23:57 <SrPx> So objects are atoms? Category theory is essentially a data structure compromised of atoms and links between them? So, a graph...? Sorry, that is probably not accurate. 
14:24:41 <ski> SrPx : however, sometimes one wants to use an object which is not a terminal object as a "pointer" object. e.g in `AbGroup' (category of abelian groups, with group homomorphisms), there is always exactly one morphism from the terminal group (which is also the initial group, and thus a "zero object"), so it doesn't work as a "pointer" object. instead, one can use the group of integers (with addition). as soon as you fix where `1' is being mapped to, the elem
14:24:59 <ski> (er, cut off near ".. instead, one can use the group of integers (with addition). as soon as you fix where `1' is  being mapped to, the elements the other integers are being mapped to is determined by that")
14:25:15 <athan> Is there a way to re-compile all modules and print all errors with stack? For some reason `stack clean && stack build` with -Wall in my .cabal file isn't doing the trick
14:25:26 <athan> I can see the warnings when compilations fails, though
14:25:50 <ski> SrPx : as far as category theory is concerned, objects are opaque, have no internal structure (though objects may be "constructed" from other objects, via functors)
14:26:35 <SrPx> ski: okay, but you said objects have no inhabitants, and then you just said you can have a pointer object to point at elements "inside" another object. That sounded contradictory, I'm not sure I got what you meant
14:27:05 <ski> SrPx : yes, like a graph, except that also : (a) for every object, there is an identity arrow/morphism; (b) for every pair of morphisms with one ending at the same object as the other is starting (iow, they are "composable"), there is a "composed" arrow from the source of the former one, to the target of the latter one
14:27:40 <ski> SrPx : so, apart from the extra data (a) and (b) (required to satisfy associativity and neutral element laws), it is exactly a (multi-)graph
14:28:47 <ski> SrPx : if we're considering a particular category that we have built, then according to that definition, the objects may have some internal structure (the objects may be sets, with elements, or perhaps each object is a tuple of a set, and some operations on that set)
14:29:18 <ski> SrPx : but as far as CT is concerned, that inner structure is irrelevant, it ignores it, or if you prefer : cannot speak about it
14:29:25 * hackagebot hharp 0.1.1.1 - Binding to libharp  https://hackage.haskell.org/package/hharp-0.1.1.1 (thoferon)
14:29:46 <ski> SrPx : however, we can (sometimes) *simulate* talking about elements of such sets, by using *morphisms* from some "pointer object"
14:30:52 <ski> SrPx : so, to express that a function `f : A >---> B' is injective, we say that it has to satisfy `forall x0,x1 \in A. f(x0) = f(x1) => x0 = x1'
14:30:59 <glguy> athan: Maybe "stack build --pedantic" is what you're looking for?
14:31:45 <ski> SrPx : but this is phrased in terms of elements .. to phrase it in terms of only morphisms (in the category `Set', so ordinary total functions), we can instead use functions from the set `{()}' of zero-tuples
14:32:14 <ski> (which happens to be a terminal object in `Set')
14:32:35 <ski> SrPx : so, now we say `forall x0,x1 : {()} >---> A. f . x0 = f . x1 => x0 = x1'
14:32:39 <ski> SrPx : ok, so far ?
14:34:47 <SrPx> ski yes
14:35:05 <SrPx> ski (not all okay, but I'm following)
14:35:17 <ski> SrPx : now, we can *generalize* this to any "stage of definition"
14:35:53 <ski> we can call the object (set) `{()}' here the "stage of definition" of `x0' and `x1', considered as some kind of elements
14:36:21 <ski> in general, for any closed expression, we'd use `{()}' as the "stage of definition"
14:36:51 <ski> e.g. if `A' is the set of natural numbers, then `2*3' would translate to a morphism from `{()}' (aka `1')
14:37:19 <ski> but consider e.g. the expression `2*m + n', which is *open* (depends on the value of variables, in this case `m' and `n')
14:37:41 <ski> this expression would translate to a morphism from `|N * |N' to `|N'
14:38:02 <ski> its "stage of definition" is `|N * |N', because the expression depends on two natural-number-typed variables
14:38:41 <ski> in Haskell, we could express the corresponding morphism as the function `\(m,n) -> 2*m + n'
14:39:24 <ski> and we can say that this morphism from `|N * |N' to `|N' is a "varying element", or "generalized element" of `|N' (the codomain of the morphism)
14:40:06 <ski> really, we're only looking at an ordinary morphism, but we're choosing to view it as expressing an "element" of its codomain, which is "varying" as we allow the domain to vary
14:40:45 <ski> so, this expresses that as `m' and `n' is allowed to vary over all natural numbers, `2*m + n', as an element of `|N' is a "varying/generalized element"
14:40:50 <ski> ok
14:41:39 <ski> so, going back to injectivity of `f', which we expressed in terms of "elements"-as-morphisms-from-a-"pointer"-object : `forall x0,x1 : {()} >---> A. f . x0 = f . x1 => x0 = x1'
14:42:27 <ski> now we *generalize* this from the particular "stage of definition" `{()}' to any such stage of definition, iow to any object `T' : `forall x0,x1 : T >---> A. f . x0 = f . x1 => x0 = x1'
14:42:49 <ski> if `T' is the object `{()}'/`1', then this is the same as before
14:43:16 <ski> if `T' is some other object, then it expresses some different property of `f', instead of plain injectivity
14:43:48 <ski> but we decide to generalize, and claim that the property has to hold for *every* stage of definition : `forall T. forall x0,x1 : T >---> A. f . x0 = f . x1 => x0 = x1'
14:44:20 <ski> this generalization of the CT phrasing of injectivity is known as `f' being a monomorphism
14:44:55 <ski> for tha category `Set', `f' being a monomorphism is actually equivalent with `f' being injective
14:45:08 <ski> but that needn't be so, for other categories
14:46:08 <ski> still, a morphism `f' being a monomorphism (being mono) is the usual go-to CT corresponding concept to a *function* `f' being injective (being an injection)
14:47:45 <ski> SrPx : does this help ?
14:48:02 <thomor> hi
14:48:41 <SrPx> ski okay I'm really sorry, I've read all that you said so I kinda see what you are implying, but I'm still stuck on the "forall x0,x1 : {()} >---> A. f . x0 = f . x1 => x0 = x1". I'm not sure I can parse it
14:49:25 <SrPx> Up to there I get it all, but I'm having trouble parsing that formula. Are there many arrows from {()} to A, each one representing an object in "A" or something like that, or not at all?
14:49:59 <SrPx> "A . f . x0" is composition? 
14:50:04 <ski> for all morphisms `x0' and `x1' from `{()}' to `A', if `f' composed with `x0' is equal to `f' composed with `x1', then the only way that could happen is if `x0' and `x1' are already equal
14:51:32 <traf> hello
14:51:36 <traf> quick question
14:51:41 <ski> note that since `x0' and `x1' are functions from `{()}' to `A', using ordinary function application (which is "outside" the language of CT), `x0()' and `x1()' are elements of `A'. the morphisms `x0',`x1' thus correspond exactly to elements of the set `A'
14:51:47 <traf> i'm reading LYAH
14:51:52 <traf> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux
14:52:10 <traf> actually
14:52:10 <traf> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
14:52:36 <traf> "We had two ways of making an existing type an instance of a type class, so we used the data keyword to just wrap that type into another type and made the other type an instance in the second way. "
14:52:36 <traf> what two ways were these?
14:52:38 <traf> type classes are things like ord, show, eq
14:52:45 <traf> i'm not sure what this is referring to?
14:52:57 <ski> SrPx : `f . x0',`f . x1' are compositions. `forall x0,x1 : {()} >---> A. ..x0..x1..' is a (universal) quantifier, expressing that `x0' and `x1' are morphisms from `{()}' to `A', in scope in the subformula `..x0..x1..'
14:53:11 <ski> SrPx : if you prefer, i could use the unicode symbol for composition instead ?
14:54:29 <SrPx> ski of course, I understand that part now, working through the rest
14:55:05 <michaelt> traf: many different Ord instances might have been written for, say, Int. If you want another one, you make a newtype for Int.
14:55:06 <geekosaur> traf, consider Monoid and integral types. there are two "basic" monoids: (0,+) and (1,*)
14:55:50 <traf> geekosaur, I haven't got to monoids yet
14:55:55 <traf> this is the preluding section
14:56:11 <geekosaur> you don;t really need to know what they are; just that there are two sensible things that you could declare
14:56:15 <geekosaur> but you can have only one
14:56:21 <cite-reader> It's referring to the discussion in paragraphs two and three of the section, discussing the two ways to make lists into an Applicative.
14:56:32 <traf> michaelt, can you elerabte
14:56:35 <geekosaur> so you need to wrap the other (or both of them)
14:56:39 <traf> only have one what?
14:56:45 <traf> one type
14:56:46 <geekosaur> tyopeclass instance
14:56:47 <traf> being monoid
14:56:48 <apriori> hello guys
14:56:54 <traf> ok
14:56:58 <traf> step back
14:57:00 <apriori> is there a way to provide default rts flags for an executable in cabal?
14:57:02 <ski> traf : i'm not sure, but perhaps they are referring to either writing an `instance' declaration for the type, or wrapping it into a new type with `data' and make an `instance' declaration for that type
14:57:02 <traf> when you say typeclass instance
14:57:08 <apriori> (in the .cabal file)
14:57:20 <geekosaur> you cannot say "instance Monoid Int where" twice with different definitions
14:57:27 <michaelt> traf I'm saying the same as the others; the main point is, you just cant have to instances of the same class for the same type in Haskell, ever; the closest you get is making a newtype wrapper. 
14:57:29 <traf> you mean something that is an instance of something like Num, 
14:57:31 <geekosaur> so you must make one of them look like something else
14:57:38 <ga2arch> apriori: ghc-options:
14:57:38 <ga2arch>         -O2
14:57:38 <ga2arch>         -threaded
14:57:38 <ga2arch>         -rtsopts
14:57:40 <ga2arch>         "-with-rtsopts=-N4"
14:57:42 <traf> oh
14:57:42 <traf> ok
14:57:42 <michaelt> traf: two, not 'to'; sorry.
14:57:43 <ga2arch>         -fno-prof-auto
14:58:13 <apriori> ga2arch, ah, that "with-rtsopts" was what I was searching
14:58:13 <apriori> ty
14:58:23 <SrPx> ski quick question, why you say "2*3" would translate to a morphism from {()} to A? Could you say just "6", or is there a difference?
14:58:34 <traf> hmmmm
14:58:59 <traf> so in my case
14:59:10 <traf> with the ZipList, what is the class?
14:59:12 <geekosaur> same with the Applicative list instance, there are two different and equally reasonable ways you can construe a list as an Applicative
14:59:23 <michaelt> traf: in that section the point is that if you were starting from scratch with a list type, you would have two ways of writing the applicative instance
14:59:34 * hackagebot dawdle 0.1.0.2 - Generates DDL suggestions based on a CSV file  https://hackage.haskell.org/package/dawdle-0.1.0.2 (arnon)
14:59:39 <ski> SrPx : every expression (in the "internal language", is the technical term) would translate to a morphism with codomain the type of the expression, and with domain the product of the types of the free variables of the question
15:00:17 <geekosaur> so we picked one of them and made it the Applicative instance, then use a newtype to "rename" the list (ZipList) and now we can give that an Applicative instance
15:01:59 <traf> ok 
15:02:00 <traf> so for lists
15:02:04 <traf> we have 2 resonable ways
15:02:11 <traf> the first being like the cartesian product
15:02:29 <traf> where we apply everything from a one list to another
15:02:30 <traf> the second being zip list
15:02:45 <traf> now reading this: Because one type can't have two instances for the same typeclass, the ZipList a type was introduced
15:02:45 <ski> SrPx : so, you can have morphisms `zero : 1 >---> |N',`succ : |N >---> |N',`add : |N * |N >---> |N',`mult : |N * |N >---> |N', you can define `one : 1 >---> |N' by `one = succ . zero', and you can define `two,three : 1 >---> |N' similarly in the obvious way. then you could express `2*3' as the morphism `mult . <two,three>'. here `<two,three> : 1 >---> |N * |N'
15:02:49 <traf> what is the typeclass here?
15:02:57 <geekosaur> Applicative
15:02:57 <michaelt> applicative, traf
15:03:05 <traf> oh shoot
15:03:11 <traf> dang i'm being dumb
15:03:12 <traf> yes
15:03:12 <traf> yes
15:03:20 <traf> thank you
15:03:31 <traf> geekosaur: thanks
15:03:36 <traf> maichaelt: thanks
15:03:38 <ski> SrPx : in general, if `f : T >---> A' and `g : T >---> B', then `<f,g> : T >---> A * B'. `<f,g>' is the "tupling" of the morphisms `f',`g', according to the categorical product (the `*' in `A * B')
15:03:38 <codehero> could someone give me an example of a simple [a] -> [[a]] function?
15:03:56 <michaelt> > group "hello"
15:03:58 <lambdabot>  ["h","e","ll","o"]
15:04:06 <codehero> @source group
15:04:07 <lambdabot> Unknown command, try @list
15:04:10 <ski> > tails "worlds"
15:04:12 <lambdabot>  ["worlds","orlds","rlds","lds","ds","s",""]
15:04:15 <ski> > inits "worlds"
15:04:17 <lambdabot>  ["","w","wo","wor","worl","world","worlds"]
15:04:36 <codehero> thx
15:05:40 <ski> > (init . tails) =<< (tail . inits) "abcd"  -- codehero
15:05:43 <lambdabot>  ["a","ab","b","abc","bc","c","abcd","bcd","cd","d"]
15:06:46 <ski> > (tail . inits) =<< (init . tails) "abcd"
15:06:49 <lambdabot>  ["a","ab","abc","abcd","b","bc","bcd","c","cd","d"]
15:08:37 <ga2arch> map pure [1,2,3] :: [[Int]]
15:09:11 <ski> @type (: [])
15:09:12 <lambdabot> a -> [a]
15:09:35 <SrPx> Okay you know I'm a little slow, so what I get so far of your explanation is that category theory is just an unlabelled directed graph where each node has an edge to itself, and if there is an edge between A and B, and between B and C, then there is an edge between A and C. Moreover, to "represent" the set of natural numbers, for example, you need 2 "nodes", A and B. A represents the empty set, B represents the type Nat. Then, you create an infinite number
15:09:35 <SrPx>  of edges ("morphisms") between A and B, one for each natural number. Each arrow would thus represent, for example, an Int in haskell (3, 4, 5, etc.). To represent a function, you just claim that the object "A" is not zero, but the whole set of natural numbers. Then, each morphism represents a particular function "Nat -> Nat".
15:10:12 <SrPx> ski does that make any sense, or am I too far off? Please understand this is the first time I approached a category theory tutorial
15:12:07 <ski> "category theory is just an unlabelled directed graph where ..." -- that's that a (single) *category* is
15:12:58 <ski> "A represents the empty set", nope, not the empty set (that wouldn't work, if you were thinking of what i sketched above)
15:13:45 <ski> and it using natural numbers was just an example. the point was how to "translate" expressions using "elements" of objects (presumably being/containing sets) into only talking *morphisms* between objects
15:15:13 <ski> SrPx : the latter parts sounds roughly right (though i'm not sure what you mean by the "To represent a function, you just claim that the object \"A\" is not zero, but the whole set of natural numbers." part)
15:16:47 <ski> SrPx : btw, note that category theory is inherently about *first*-order "functions" (really morphisms/arrows, which may be or contain functions, but which could also be something else, which we don't normally think of as functions)
15:16:49 <byorgey> hvr: (or anyone else who can answer) any tips on how to modify hvr/multi-ghc-travis to build one dependency from a git repo instead of from Hackage?
15:17:11 <byorgey> hvr: specifically xmonad-contrib HEAD, which depends on the HEAD version of xmonad
15:17:40 <hvr> byorgey: https://github.com/ekmett/lens/blob/master/.travis.yml
15:17:46 <hvr> byorgey: grep for 'reflection'
15:18:02 <ski> SrPx : iow, if we try to write a "curried morphism" `f : A >---> (B >---> C)', then this is nonsense in CT. we can express the "tupled" (non-curried) variant `f : A * B >---> C' (if we have categorical products, like `A * B' here)
15:18:19 <tpsinnem> is there documentation on how ghci works? i see there's lots of documentation in https://ghc.haskell.org/trac/ghc/wiki/Commentary about ghc proper, but i don't see ghci mentioned much
15:18:36 <hvr> byorgey: there's no general solution for yet though
15:18:55 <hvr> byorgey: you need to be careful what goes into the cache
15:18:58 <Darwin226> Hey guys. Any way to make this properly tail recursive? http://lpaste.net/146555
15:19:03 <SrPx> ski okay let me be redundant, there is an infinite number of functions from Nat to Nat in haskell. (\ x -> x * 2) is one, (\ x -> x + 2) is another. Is it correct to say that, in category theory, this is represented as one object, "N", plus an infinite morphisms between it and itself (?), each arrow representing a specific function? Would it be correct to draw a circle in a paper, many arrows from it to itself, and label each arrow with a function such (\x
15:19:03 <SrPx>  -> x * 2), and claim "see this is part of the category Nat -> Nat"?
15:19:14 <ski> SrPx : alternatively, *if* we have "exponential objects", then we can express the curried version as `f : A >---> C^B' (`C^B' being the object of morphisms from `B' to `C'. in the category `Set' of ordinary sets and total functions between them, this is the set of functions from `B' to `C')
15:20:26 <ski> SrPx : if we prefer, we can use the alternative notation `B -> C' for this exponential object, and the the "curried morphism" becomes `f : A >---> (B -> C)' (or skipping the brackets, `f : A >---> B -> C') -- still, there's a big difference between the morphism arrow `>--->', and the exponential sign `->' here
15:21:23 <ski> SrPx : `B -> C' is an object of the category, while `A >---> (B -> C)' is not an object of the category. the syntax for "morphism typing" is `<morphism> : <object> >---> <object>'
15:21:46 <geekosaur> tpsinnem, "bytecode" might get you more information. (it's used by ghci, runghc, and TH)
15:22:54 <ski> Darwin226 : use a continuation, i suppose. it will still eat heap space, though
15:23:17 <Darwin226> ski: Any way to make is constant space?
15:23:19 <ski> Darwin226 : .. and it won't be incremental, of course
15:23:41 <ski> Darwin226 : i don't think so. consider the case `m = []'
15:23:45 <SrPx> ski the way you say, you make it seem like a category is really just a very simple data structure. How many say that it is "a formalization of whole maths"? How would you define an *algorithm* in category theory?
15:24:28 <ski> SrPx : "Is it correct to say that, in category theory, this is represented as ..." -- yes
15:25:44 <ski> SrPx : we usually don't care (at least explicitly) about algorithms in math, that topic belonging to the subject of computing, computability theory, algorithmics
15:25:58 <Darwin226> ski: What would the cont version look like?
15:26:21 <ski> SrPx : iow, we identify two functions that describe the same input-output mapping, regardless of the differing algorithms that may used to implement such
15:27:23 <SrPx> Then what is it useful for, ski ? Not useful in the sense "this will make money", I'm really just asking what is "cool" about it. What it is for? What kind of insightful statements, truths can category give to us? 
15:28:13 <ski> Darwin226 : make a helper, pass it `id' as the initial continuation (extra argument). if the continuation is called `k', then use `return (k [])' in the base case and `loop (n-1) x $ \xs -> k (x:xs)' in the recursive case (`loop' being the helper, and i avoided passing `next' around, since it isn't changed)
15:28:34 <danilo2> Hello guys! :) Is there any way to create a type family in Haskell (lets name it Foo) that will behave like this: Foo (a ::*) = a   and   Foo (a :: k) = Proxy a   (for k other than *) ?
15:30:04 <ski> SrPx : it's useful to be able to "compare" different areas of math. it's useful to be able to make a single general definition of a concept, instead of having to make many similar-looking definitions (like various "products") in different areas of math. it's useful to be able to characterize (/specify) exactly the essence of a concept, instead of mixing "implementation details" in with it
15:30:53 <ski> SrPx : it's useful to look for previous general definitions of concepts, to check whether they specialize to something useful in your particular area of subject
15:31:38 <ski> SrPx : by "compare" i mean that you can sometimes "translate" a problem from one area of math to another, where it may be simpler to solve, and then translate the solution back again
15:32:15 <SrPx> ski ah, that makes some sense. So category theory isn't some kind of universal system, but just a simplification of how concepts of different fields correlate with eachother? As in, "this thing you are doing in CS really looks like this other thing we are doing in biology. Let me draw their categories to show you how they look similar!"
15:33:33 <Darwin226> ski: Should return (k []) instead be k (return [])?
15:35:03 <SrPx> I.e., categories are simplifications of mathematical concepts, in the same way that types are simplifications of terms. Having a type isn't sufficient to say what a function does for sure, but is an useful approximation. Same for categories/concepts. Is that it?
15:35:51 <ski> SrPx : category theory can be seen as a theory of mathematical theories. in group theory, people study groups and group homomorphisms, and things related to that. in topology, people study topological spaces and continuous functions between them. in linear algebra, people study vector spaces and linear transformations between them (matrices in the finite-dimensional case)
15:35:56 <ski> SrPx : in category theory, people study objects like `Group',`Top' resp. `Vect', which contain all groups (and groups homomorphisms), all topological spaces (and continuous functions), resp. all vector spaces (and linear maps), and also study "category homomorphisms" (functors) between these categories
15:36:08 <ski> Darwin226 : no
15:36:38 <ski> Darwin226 : `k :: [a] -> [a]' here
15:37:01 <Darwin226> ski: Sorry for bothering you then but what does the helper do? I've never done a CPS transform before.
15:37:07 <SrPx> ski ah wow
15:37:37 <SrPx> ski that was very insightful
15:37:56 <SrPx> ski is category theory the only theory of mathematical theories?
15:37:57 <ski> SrPx : i'm not sure what you mean by "types are simplifications of terms" -- but i suppose i'd agree with "Having a type isn't ... Same for categories/concepts."
15:38:09 <ski> SrPx : also, i'm not sure what you mean by "universal system"
15:38:23 <ski> category theory isn't, in itself, an alternative foundation for math
15:38:58 <ski> (though Lawvere did suggest a formalization of axioms for the category `Set', for that purpose)
15:39:03 <SrPx> ski as in, (Int -> Int) is an approximation of what a function does. It says it receives an int, returns an int, so that discards a lot of functions that do different things. But isn't informative enough to say that it multiplies an int by 2, or adds 3, or returns itself... that is how I see types, at least.
15:39:53 <ski> SrPx : "theory of mathematical theories" is quite vague
15:40:15 <ski> ok "approximation" as in "partial specification". ok
15:41:30 <ski> however, types without terms are pretty useless
15:41:46 <SrPx> ski but you said that :(
15:41:51 <ski> similarly, a category where you only tell what the objects are, but not the morphisms, is also pretty useless
15:42:37 <ski> sure, a category "classifies" (some) mathematical "objects" of the same "kind", like `Group' contains all groups
15:42:55 <ski> and you could say that is similar to `Int' classifying all particular integers
15:43:12 <ski> SrPx : i said what ?
15:43:28 <ski> (or rather `Integer' ..)
15:43:29 <SrPx> ski that category theory can be seen as a theory of mathematical theories
15:43:55 <ski> yes, followed but some attempt at elucidation of what i meant by the term
15:44:07 <SrPx> I see.
15:45:03 <SrPx> ski anyway, I think I learned more about cat theory with your short explanation than in 2 years of passive listening people talking about it. At least now I have a much more solid understanding of what it is and what it isn't, although I have no idea of the deepnesses. Thanks
15:45:04 <ski> another sense of "theory of theories" would be model theory in logic
15:45:35 <ski> though there, one's usually only looking at one theory at a time (and considering one or more possible interpretations of that theory)
15:46:15 <ski> e.g., you could look at a theory containing function symbols for the group operations, and axioms for the group laws. a model for that theory is exactly then a group
15:46:52 <SrPx> Thinking in retrospective, now I see cat theory is probably not where I will find the answer for the thing I was looking for when I started looking at it earlier today. But that is helpful by itself, I guess
15:47:07 <ski> SrPx : my point was more or less that "theory of mathematical theories" isn't really well-defined so therefore it's hard to answer "is category theory the only theory of mathematical theories?"
15:47:18 <SrPx> ski uh huh, I see your point there
15:48:11 <traf> from LYAH
15:48:11 <traf> instance Functor (Pair c) where 
15:48:36 <traf> how is the function mapped over the first component
15:48:49 <traf> I get that Pair b a will return (a,b)
15:49:12 <traf> but how does  fmap f (Pair (x,y)) = Pair (f x, y) 
15:49:27 <traf> apply the function over the first parameter 
15:49:32 <ski> Darwin226 : `iterateM n0 next current0 = loop n0 current0 $ \xs -> xs where loop 0 _ k = return (k []); loop n current = do x <- next current; loop (n - 1) x $ \xs -> k (current : xs)' (note that i mistakenly consed `x' on `xs' previously)
15:50:25 <ski> SrPx : what was "the thing I was looking for when I started looking at it earlier today" ?
15:51:10 <ski> Darwin226 : er, `loop n current k = ...', in the recursive case, sorry
15:51:44 <Darwin226> ski: Yeah, I've got that. It's pretty great that you bothered to write this out for me. Thanks so much
15:51:54 <icen> traf: consider that you've written a valid implementation for fmap for newtype Pair a b = Pair b a
15:51:57 <Darwin226> I was wondering where next came into play here
15:52:09 <SrPx> ski nothing I can define too precisely and maybe it doesn't even make sense, but I'm just trying to find something I honestly accept as the natural / "most elegant" definition of natural (and other types of) numbers
15:52:43 <traf> icen, by valid implementation do you mean     newtype Pair b a = Pair { getPair :: (a,b) }  
15:52:58 <icen> Yes, that, sorry
15:53:03 <SrPx> ski I don't know, it looks to me that mathematicians and everyone in the world is happy just accepting an english, intuitive explanation of what a number is, but I kinda need to see a syntax, structure, something like that
15:54:06 <icen> SrPx: I don't think many mathematicians will be happy accepting *just* and English, intuitive understanding of numbers
15:54:07 <SrPx> ski I noticed natural numbers have a very interesting materialization on interaction nets, something I haven't seen before and it looks like it is the most compact representation of numbers too, it looks like it has many interesting properties. I was looking for things like that, but I have no idea where to look for it
15:54:16 <Darwin226> ski: Hmmm... I'm still blowing the stack on the inner loop function. Is it because it's in a monad?
15:54:35 <ski> Darwin226 : in general, `k (return [])' (or perhaps just `k []' ?) would have been correct. .. but in this case, we only needed to cons some list cells "afterwards", not do arbitrary `m'-effects, and so i factored out that, getting `k :: [a] -> [a]' instead of `k :: [a] -> m [a]' (or `k :: m [a] -> m [a]', maybe ??)
15:55:04 <glguy> Darwin226: writing this as tail recursion is just a trick, it's not going to help your stack problem
15:55:06 <SrPx> (specifically, natural numbers on interaction nets look like they need very few bits to be expressed when they are not prime, but a lot of bits, huge graphs, when they are prime. that's very interesting to me)
15:55:13 <ski> (hm .. `k :: [a] -> m [a]' would correspond to call-by-value CPS, while `k :: m [a] -> m [a]' to call-by-name CPS, i suppose)
15:55:26 <glguy> Darwin226: If you're trying to solve some other problem you should start with it directly
15:55:47 <traf> icen, so now what?
15:55:58 <traf> icen: how does it link together?
15:56:28 <Darwin226> glguy: Sure, but I assumed this would instead allocate on the heap instead of the stack.
15:56:53 <ski> SrPx : btw, if you're thinking about "theory of theories", then perhaps you should talk to sure in ##math
15:56:57 <icen> traf: if you wrote 'instance Functor (Pair b) where' above your 'fmap' line, you would implement Functor
15:56:57 <glguy> Darwin226: both solutions allocate on the heap and then use the stack during evaluation
15:57:21 <icen> Or 'Pair a', sorry; I'm mixing up the order
15:57:30 <glguy> Darwin226: this isn't like C where you can map procedure calls to stack behavior
15:57:54 <Darwin226> glguy: Oh. So it's a heap build up causing the overflow?
15:57:56 <traf> icen: sure, i get that, but how does the function get applied over a in Pair(b, a)
15:58:18 <Darwin226> glguy: at least it seems so since putting bangs on arguments of the inner function made it work.
15:58:32 <ski> SrPx : hm, in CT, you can define what a "natural number object" in a category is. iirc, it's a limit of a certain "diagram" category. dunno whether that's enough of "syntax, structure" for you
15:59:05 <ski> SrPx : hm, don't think i've seen interaction nets
15:59:10 <icen> traf: I think the key here is that the argument to the Functor typeclass is not a whole type by itself (of kind *) but a type constructor (of kind * -> *), which leaves the remaining parameter implied
15:59:23 <glguy> Darwin226: I don't know what exact problem you're having, i haven't seen the code you're running
15:59:54 <traf> icen: ehhh too abstract for my current ability 
16:00:00 <glguy> but transformation to tail recursion doesn't directly translate from what you might be used to in a strict language
16:00:00 <ski> icen : s/implied/not specified/
16:00:07 <traf> icen: can you give me some examples of what you mean
16:00:19 <icen> If you have a function mapsSecond :: (a -> c) -> Pair b a -> Pair a c; mapsSecond f (Pair (a,b)) = Pair (f a, b), does this make sense
16:00:26 <Darwin226> glguy: Originally this http://lpaste.net/146555 but now this http://lpaste.net/146560 if you want to take a look
16:01:02 <Darwin226> glguy: I see. Any link you might want to point me to?
16:01:46 <traf> icen: mapsSecond :: (a -> c) -> Pair b a -> Pair a c;
16:02:03 <traf> b disappeared in the 2nd function
16:02:20 <icen> Oh, very sorry
16:02:22 <traf> i mean return 
16:02:25 <traf> sholdn't it read Pair b c in the return
16:02:31 <icen> It should, of course, be (a -> c) -> Pair b a -> Pair b c
16:02:59 <traf> icen: so this is saying:mapsSecond f (Pair (a,b)) = Pair (f a, b)
16:03:09 <icen> Yep
16:03:09 <traf> the functor containing Pair (a,b)
16:03:22 <nicow> Hi everybody, could someone clarify something about cereal? I am streaming an infinite list over the network, using 'Network.Socket.ByteString.Lazy (sendAll)' and cereal's 'toLazyByteString'. It looks like the whole list has to be created before the first bits are even sent. Is that correct?
16:03:26 <traf> we apply the function over the Pair(a,b) in the functor
16:03:50 <traf> and that has the effect of applying to only the first parameter of Pair (a,b)
16:04:00 <traf> which is shown by Pair(f a,b)
16:04:02 <traf> ?
16:04:04 <SrPx> ski it is the most awesome thing I've seen in my life so far
16:04:05 <icen> The intuition behind this being a Functor instance is that it doesn't really matter what the functor contains; only that it's actually a functor. So, for any type a in ((Pair b) a), you can apply an f :: (a -> c) over the 'a' component of it
16:04:35 <SrPx> ski please eventually take a look on it, there are so many weird things that happen on them... at least as I see on the animations reducing λ-expressions I make for myself
16:04:36 * hackagebot haggis 0.1.3.0 - A static site generator with blogging/comments support  https://hackage.haskell.org/package/haggis-0.1.3.0 (TychoAndersen)
16:05:02 <traf> icen: did you not mean to write mapsSecond f (Pair (a,b)) = Pair (a, f b)
16:05:05 <traf> (notice where f is)
16:05:13 <SrPx> ski specifically interaction combinators, which honestly look exactly like the lambda calculus, except better in every sense
16:05:16 <traf> stupid question time: is f a functor and function here
16:05:42 <icen> f is a function, and a parameter to the other function mapsSecond (or fmap, or whatever you fancy calling it(
16:05:55 <icen> 'Pair b' is the functor
16:06:06 <traf> why is the f written to the left argument on the RHS of the =
16:06:07 <traf> >
16:06:09 <traf> ?
16:06:14 <glguy> Darwin226: That can't overflow, it's just a function defintion.
16:06:21 <ski> SrPx : any link you'd suggest ?
16:06:31 <icen> I thought we had that Pair b a = Pair (a, b)
16:06:51 <traf> icen: we do
16:07:19 <icen> So if I have a function f :: a -> c, I can't really use it on an element of type 'v'
16:07:22 <icen> 'b'*
16:07:47 <Darwin226> glguy: Well sure, I don't have a straight forward example of calling it since it's inside the rest of my code. In any case, putting a bang pattern (even on the non CPS one) on the `current` argument seems to have fixed the leak.
16:08:04 <traf> icen: but we never wrote that explicitly - we wrote     newtype Pair b a = Pair { getPair :: (a,b) }  
16:08:13 <icen> traf: perhaps calling it mapsSecond was a mistake, and I was still getting confused with the ordering of the pair
16:09:02 <glguy> Darwin226: great :)
16:09:16 <traf> we write
16:09:16 <traf>     newtype Pair b a = Pair { getPair :: (a,b) }  
16:09:21 <ski> note that in `mapsSecond f (Pair (a,b)) = Pair (f a,b)', the type of `f' is `a -> c', the type of `a' is `a', and the type of `b' is `b'. we're here (perhaps confusingly) reusing `a' and `b' as names both for two types, and for two values of those types
16:09:21 <traf> instance Functor (Pair c) where  
16:09:21 <traf>     fmap f (Pair (x,y)) = Pair (f x, y) 
16:09:39 <traf> now I don't see how the function is applied to the 2nd parameter and not the first
16:09:52 <traf> I get that somewhere Pair(a,b) = Pair(b,a)
16:09:55 <Darwin226> glguy: I wish I could actually do these things with some understanding instead of just sprinkling bangs all over the place but I haven't managed to grok Haskell execution model yet.
16:10:02 <glguy> Darwin226: kind of what I was getting at, how the function is being used matters. in another context that strictness annotation wouldn't have been needed
16:10:08 <ski>   f :: a -> c
16:10:09 <glguy> it matters what the arguments were and how they evaluate
16:10:14 <ski>   Pair (x,y) :: Pair b a
16:10:16 <icen> traf: because in that instance 'x' has type c, and 'y' has some type we don't know about yet, only that 'f' is of type (whatever 'y' is) -> something
16:10:20 <ski>   (x,y) :: (a,b)
16:10:30 <ski>   x :: a
16:10:33 <ski>   y :: b
16:10:37 <ski>   f x :: c
16:10:44 <ski>   (f x,y) :: (c,b)
16:10:53 <ski>   Pair (f x,y) :: Pair b c
16:11:00 <Darwin226> glguy: are you saying the `next` function I'm passing in is actually generating thunks here?
16:11:07 <glguy> yeah
16:11:16 <Darwin226> glguy: I guess that makes sense
16:11:42 <SrPx> ski there is no link I think would do justice :( I started with the "optimal implementation of functional languages" book, then spent a lot of time digesting the system proposed there because IMO there was a lot of nonsense, then I started noticing things like @ and λ nodes are equivalent, then I noticed fan nodes are equivalent too, then I noticed everything is equivalent and there is only one kind of node 
16:12:04 <KaneTW> Mathematica!
16:12:10 <KaneTW> everything's a tree
16:12:22 <SrPx> ski then I finally understood that the λ-calculus could be compiled to that kind of system that is a graph with just one kind of ternary node and 2 reduction rules, then I implemented optlam, made a visualizer for it, then I made drawings and I started noticing many awesome stuff
16:12:30 <ski> traf : so, "somewhere Pair(a,b) = Pair(b,a)" is false. rather, if `(x,y) :: (a,b)', then `Pair (x,y) :: Pair b a'. and if `(f x,y) :: (c,b)', then `Pair (f x,y) :: Pair b c'
16:12:35 <SrPx> I don't think that is available at all :(
16:13:14 <traf> ski: icen: ok that is making a little bit more sense
16:13:24 <franky> does anyone know how to decompile haskell? or knows why no one seems to know how to do it?
16:13:30 <ski> traf : so, by removing and adding the wrapping data constructor `Pair' around `(x,y)' resp. `(f x,y)', we "flip" the order of the type variables, from `Pair b a' to `(a,b)', and from `(c,b)' to `Pair b c'
16:13:31 <michaelt> Darwin226: there was an amusing discussion of getting a nice version of 'sequence' for IO; it would cover this sort of case. 
16:14:35 <SrPx> but seriously there are so many things going on with interaction net that look really really cool to me, I wish I had some kind of authority on the community to convince people smarter than me to investigate it, but nobody is interested in inets and I have no credit to claim it is useful in any sense :( 
16:14:53 <ski> traf : and this is because of the definition `newtype Pair b a = Pair {getPair :: (a,b)}' is using the opposite order of `a' and `b' in the type `Pair b a' on the left, as compared to the type `(a,b)' on the right <-- this is the reason why the data constructor `Pair' is "flipping the order"
16:15:52 <ski> SrPx : hm, ok. sounds interesting
16:15:54 <traf> ski: icen: thanks alot, I'm still not sold on the whole idea. mayve it's just syntax, but I think I need to stare at it some more. Thanks alot gus
16:16:55 <michaelt> Darwin226: http://neilmitchell.blogspot.co.uk/2015/09/making-sequencemapm-for-io-take-o1-stack.html there were other posts then.
16:17:41 <Darwin226> So in the profiler output, the 'individual' column is the time spent by the function without counting sub calls to other functions, right? What does that mean exactly since the only thing a function can do is call other functions?
16:18:45 <ski> franky : compilation is in general not an injective process (differently written programs can compile to identical object code), so it sounds like a hard problem. especially in the presence of high-level optimizations like fusion. perhaps there's some work on what is possible to do, but i don't know it :/
16:19:23 <Darwin226> michaelt: Hmm, I actually remember reading this
16:20:23 <michaelt> Darwin226: really you should just have a properly 'streaming' return type, of course, rather than m [a]. 
16:21:28 <Darwin226> michaelt: I probably really should. I'm guessing this would allow me to skip the Int argument all together and have an infinite list that I can cut at the call site, rather than in advance
16:21:42 <michaelt> right
16:24:07 <athan> glguy: Hey sorry I missed your response. --pedantic breaks with -Werror :\
16:24:17 <athan> I think they're working on it though
16:25:24 <michaelt> Darwin226: here's a twisted version, following the solution D. Doel gave http://lpaste.net/146561
16:26:22 <michaelt> Darwin226: I'm not sure I implemented 'iterateM' as sensibly as I might have, using Prelude.iterate 
16:27:47 <nicow> Anybody, is it possible to stream using a single 'runPutLazy' in cereal?
16:27:51 <michaelt> Darwin226: I just realized I had implemented one for a streaming list type, but didn't export it ... http://hackage.haskell.org/package/streaming-0.1.3.3/docs/src/Streaming-Prelude.html#iterateM
16:28:35 <nicow> I mean to have the first chunks out before we've built the whole Put?
16:28:36 <Darwin226> michaelt: Cool stuff!
16:30:45 <nicow> I gave this a try : doTheThing (x:xs) = Serialize.put x >> Serialize.flush >> doTheThing xs
16:30:45 <nicow> but running "runPutLazy [1..]" will not output any chunk (until it has reached the end of the list)
16:31:06 <nicow> runPutLazy $ doTheThing [1..], my bad
16:31:57 <nicow> would binary/blaze-builder be able to do that?
16:33:08 <pavonia> Ah, this is what I love about Haskell ... found five bugs in my code just by making some numeric type synonyms newtypes :)
16:34:40 <ackthet> i don't know who's in charge of these things but if there was a cool haskell tshirt i would buy it
16:35:01 <apriori> ackthet, for what use, I wonder? :)
16:36:08 <nicow> nobody on that cereal problem?
16:39:37 * hackagebot streaming 0.1.3.4 - an elementary streaming prelude and a general stream type.  https://hackage.haskell.org/package/streaming-0.1.3.4 (MichaelThompson)
16:40:33 <ga2arch> nicow: what is that you're trying to do ?
16:40:50 <michaelt> Darwin226: there it is ^^^ the 'properly streaming' iterateM humanity has so often asked for http://hackage.haskell.org/package/streaming-0.1.3.4/docs/Streaming-Prelude.html#v:iterateM
16:41:56 <Darwin226> michaelt: Awesome. My only question: How did you get the docs up so fast?
16:42:36 <nicow> ga2arch: I'm seeing a lot of GC when serializing, so I'd like to completely fill my buffers. I saw that cereal does exactly that, and won't produce a chunk before either there's no more input of the buffer is full. I'd rather not implement the buffer strategy myself, would be nice to use cereal's
16:43:03 <michaelt> Darwin226: oh I just used a script that's drifting around:  https://github.com/michaelt/streaming/blob/master/upload.sh there are others
16:43:11 <nicow> (my actual problem is that I serialize 1kb messages, and for each cereal creates a 32kb buffer)
16:43:46 <franky> anyone here that can help with disassemble some haskell?
16:43:59 <Darwin226> michaelt: bookmarked!
16:44:16 <franky> is doing it even a possible?
16:45:05 <exio4> franky: I don't believe so, to be honest
16:46:09 <ga2arch> nicow: can you paste the code in question please ?
16:49:55 <nicow> ga2arch: here's a simple example http://pastebin.com/r1Qe6rsm
16:51:49 <nicow> ga2arch: didn't double check, there are typos. here's a fixed version http://pastebin.com/Suf5CTm2
16:53:00 <ackthet> apriori: wearing, the normal tshirt use
16:54:51 <napping> franky: to just get assembly, only "code next to tables" would get in your way
16:56:38 <ga2arch> nicow: ok so the problem is that cereal creates chunks of 32kb when you want to keep the 1kb size ?
16:58:49 <nicow> ga2arch: That would be a fix yeah, but it is not my problem currently. The problem with the code is that it seems cereal will first create the Put, and then start emitting 32kb chunks. I'd like it to output the chunks as soon as possible, especially with an infinite list. Also I think it's possible to set the chunk size in recent versions, but for other reasons I have to stick with stackage's LTS
17:05:49 <apriori> ackthet, I thought eating :P
17:06:05 <apriori> ackthet, nah, I meant.. wearing with what purpose?
17:06:56 <ackthet> so i can tell the people with golang shirts that i am a superior being
17:07:35 <apriori> ackthet, ah, go is your competition. ok, that hardly is any, but well.
17:08:19 <apriori> still, I generally mostly wonder why people tend to wear a shirt with a "message". I doubt many people even care to read it (hell, I mostly don't)
17:08:24 <ackthet> hehe i'm mostly joking, but i have a collection of shirts from software i like/use
17:08:33 <ackthet> not really a message
17:08:45 <ackthet> i usually do it to give some $ back to projects i use
17:08:58 <shirt> apriori: eh?
17:09:14 <apriori> ah. so you combine pure functionality (having clothing) with a donation
17:09:20 <apriori> actually you also promote, but nvm :P
17:09:34 <apriori> shirt, oops, you picked a bad name ;)
17:09:34 <ga2arch> nicow: never used cereal but looking at the code i think it is normal, you have to build the Put monad before you're able to serialize it, it has to know the work it should do to build the bytestring, lazy or not lazy is just the way it should produce the output 
17:11:08 <nicow> ga2arch: ah, well. Do you know of any other library that has that behaviour? Is that what blaze-builder is about?
17:11:08 <ga2arch> nicow: what's wrong with, iterate the list, serialize the element and send it ?
17:12:36 <nicow> ga2arch: problem with that is I might have more elements in the future, in up to TBs of data, I definitely don't have it all in memory; also I'd like my data to leave as soon as possible
17:13:54 <koz_> nicow: What're you trying to do?
17:16:21 <nicow> koz_: basically, serialize as fast as possible, while sticking to haskell LTS 3.*, and writing as little code as possible. My problem at the moment using cereal is that for each 1kb piece of data I went to send over the network (as soon as it's ready) cereal creates a 32kb buffer that has to be allocated and GC'd
17:16:57 <koz_> nicow: Ah.
17:17:19 <nicow> koz_: the approach I took was using runPutLazy which unfortunately does not output any data until it has built the whole 'Put' (see example here: http://pastebin.com/Suf5CTm2)
17:19:35 <codehero> is there something like tail for infinite list, which turns a list of [n..] into a list of [(n+t)..]?
17:20:03 <cite-reader> codehero: drop t?
17:20:07 <napping> tail works on infinite lists, drop if you want to drop several items
17:20:15 <codehero> cite-reader: ah. thx. i'm stupid
17:20:17 <codehero> drop
17:20:20 <codehero> how did i not think of that
17:20:39 <cite-reader> You just don't have the entire list API memorized. It's not about being dumb.
17:20:47 <codehero> heh
17:24:37 <nicow> ga2arch: do you understand my reasons or am I missing something?
17:26:14 <ga2arch> nicow: i honestly don't see why iterate the list and for every element serialize+send it won't work 
17:26:47 <ga2arch> it would allow you to not waste space with chunks, it would send the element as soon it is serialized
17:29:02 <nicow> ga2arch: but for each 'runPut' cereal allocates a buffer, and as of 0.4.* you can't specify the size. Is that what you mean? map (runPut . put) xs ? 
17:29:20 <ga2arch> nicow: i was thinking more about balze-builder
17:29:26 <ga2arch> s/balze/blaze
17:30:49 <ga2arch> nicow: btw yes, something like, mapM_ (sendAll sock . runPut . put) xs 
17:31:41 <nicow> ga2arch: blaze-builder only creates 4kb buffers, right? Any chance I could reuse them?
17:34:02 <ga2arch> nicow: i think it is possible to reuse the buffer but i don't know how 
17:34:04 <ga2arch> sorry
17:35:24 <nicow> ga2arch: no worries, thanks for the help
17:37:29 <P4Titan> Hello all, Why is it that haskell does not support functors and applicatives of tuples well?
17:38:35 <johnw> P4Titan: Can you define what "well" would be?
17:38:54 <P4Titan> liftA2 (+) (1, 2, 3) (4, 5, 6) does not work
17:39:19 <johnw> what would the answer to that be?
17:39:30 <P4Titan`> > liftA2 (+) (1,2,3) (4, 5, 6)
17:39:32 <lambdabot>      No instance for (Show t0)
17:39:33 <lambdabot>        arising from a use of ‘show_M158697148126932486431457’
17:39:35 <lambdabot>      The type variable ‘t0’ is ambiguous
17:40:00 <ga2arch> nicow: https://hackage.haskell.org/package/conduit-extra-1.1.9.2/docs/Data-Conduit-Blaze.html look into this, unsafeBuilderToByteString should do what you want
17:41:23 <glguy> P4Titan: No, what answer did you expect to get
17:41:37 <P4Titan`> (5, 7, 9)
17:42:27 <jle`> > liftA2 (+) ('h', True, 3) ('o', False, 8)
17:42:29 <lambdabot>      Could not deduce (Applicative ((,,) Char Bool))
17:42:29 <lambdabot>        arising from a use of ‘liftA2’
17:42:29 <lambdabot>      from the context (Num c)
17:42:45 <jle`> hm i guess the instance just isn't defined
17:42:51 <cite-reader> What type should the function have for heterogenous tuples?
17:42:54 <jle`> that's kind of silly
17:43:01 <jle`> what you'd expect :)
17:43:16 <glguy> There *could* be an applicative instance for '(Monoid a, Monoid b) => Applicative ((,,) a b)'
17:43:20 <P4Titan`> is it because tuples are not restricted to homogeneous types
17:43:23 <glguy> but it wouldn't do what P4Titan expected
17:43:24 <cite-reader> P4Titan` seems to expect a ZipList like Applicative, though.
17:44:11 <jle`> @let instance (Monoid w, Monoid x) => Applicative ((,,) w x) where pure = (mempty,mempty,); (x,y,f) <*> (x',y',z) = (x <> x', y <> y', f z)
17:44:13 <lambdabot>  .L.hs:156:10:
17:44:13 <lambdabot>      Could not deduce (Functor ((,,) w x))
17:44:13 <lambdabot>        arising from the superclasses of an instance declaration
17:44:17 <jle`> oh
17:44:36 <jle`> > liftA2 (+) ('h', 3) ('e', 7)
17:44:38 <lambdabot>      Could not deduce (Monoid Char) arising from a use of ‘liftA2’
17:44:38 <lambdabot>      from the context (Num c)
17:44:38 <lambdabot>        bound by the inferred type of it :: Num c => (Char, c)
17:44:43 <jle`> sorry
17:44:54 <jle`> > liftA2 (+) ("h", 3) ("i", 7)
17:44:56 <lambdabot>  ("hi",10)
17:44:59 <glguy> P4Titan`: The problem seems to be that your intuition for Applicative isn't quite right
17:45:29 <P4Titan`> ok...
17:45:51 <jle`> liftA2 :: (a -> b -> c) -> f a -> f b -> f c
17:46:17 <jle`> so, liftA2 :: (a -> b -> c) -> (w,z, a) -> (w,z, b) -> (w,z, b)  
17:46:19 <jle`> makes perfect sense :)
17:46:22 <nicow> ga2arch: it looks like it's just reexporting functions from Conduit.ByteString.Builder, interesting though
17:46:33 <jle`> (the last one should be (w,z,c)
17:46:43 <jle`> P4Titan`: Applicative and Functor only affect the last field in the tuple
17:47:14 <jle`> for tuples, fmap and (<*>) etc. act as if the tuple (w, a) was something that contained an "a", tagged with a w
17:47:25 <jle`> so fmapping an (a -> b) on a (w, a) would give you a (w, b)
17:47:27 <P4Titan`> k
17:47:34 <jle`> apply a function to the data, and leave the tag unchanged
17:47:43 <jle`> there's no other sensible way you could write (a -> b) -> (w, a) -> (w, b)
17:47:53 <P4Titan`> understood, ty
17:48:07 <jle`> np!
17:48:32 <jle`> for Applicative functions like <*> and liftA2, the action represents squishing/combining the tag with mappend/(<>)
17:48:42 <ga2arch> nicow: btw to better approach your problem, look into conduit/pipes if you don't already know what they are
17:48:55 <jle`> which is why liftA2 (+) on ("h", 3) and ("i", 7) returned ("hi", 10)
17:49:26 <P4Titan`> ok
17:51:02 <glguy> nicow: I might have missed a constraint you have, but cereal can stream a lazy bytestring
17:51:14 <glguy> You can see it in action with: runPutLazy (forever (putWord32be 1))
17:52:20 <traf> learnyouahaskell.com/functors-applicative-functors-and-monoids
17:52:29 <traf> Just like with multiplication and addition, we usually explicitly state the binary functions instead of wrapping them in newtypes and then using mappend and mempty.
17:52:47 <traf> where are they explicitly stating the binary functions
17:52:52 <traf> what binary functions"
17:52:52 <traf> ?
17:53:53 <zachk> so using DataKinds and some other stuff, I got what seems to be dependently typed list working with zero outside help :D, and a safe zip 
17:54:35 <jle`> congrats zachk :)
17:54:51 <glguy> take 044 07$ Data.ByteString.Lazy.toChunks 07$ runPutLazy 07$ mapM_ (07\x 07-> putWord32be x 07>> flush) [04107..]
17:54:52 <glguy> [04"\NUL\NUL\NUL\SOH",04"\NUL\NUL\NUL\STX",04"\NUL\NUL\NUL\ETX",04"\NUL\NUL\NUL\EOT"]
17:55:21 <jle`> traf: i'm not totally sure what the sentence is saying exactly either...but yeah, i think they meant that you say them in the instance declarations?
17:55:25 <ga2arch> glguy: nicow linked this code before, http://pastebin.com/Suf5CTm2, saying that it would not send the data as soon as possible 
17:55:47 <zachk> ghci's help messages have gotten so helpful over the years, though I used to think the old type error messages were easier to understand 
17:55:54 <glguy> yeah, so I'd probably focus my attention on the networking code
17:56:40 <glguy> (mapM_ send . toChunks) is probably going to be more reliable about sending as early as possible
17:56:58 <traf> jle: by instanc edelcations you mean what goes below instance Monoid All where
17:57:02 <traf> like mempty
17:57:05 <traf> mconcat?
17:57:08 <jle`> yeah
17:58:36 <ga2arch> glguy: another problem he had was that serializing tons of little data would allocate a lot a GC a lot, you know how to reuse the allocated buffer ? 
17:59:06 <ga2arch> s/a GC/and GC
18:00:53 <glguy> ga2arch: I'd want to see the evidence that allocation was a problem, but as far as writing things directly there's hPutBuilder :: Handle -> Builder -> IO ()
18:02:38 <ga2arch> glguy: nice to know, thanks
18:02:43 <traf> jle: but don't we always have to declare them anyway
18:03:17 <jle`> yeah we have to declare the instances, but after that, we can use mappend instead of *, && etc.
18:03:19 <traf> jle: that is, when we make something an instance of monoid, we have to provide the implementaiton for mempty, mconcat, mappened
18:03:32 <jle`> mhm.  but just once, i guess
18:03:40 <jle`> i'm not really sure what the point that passage is trying to make is
18:03:48 <mmhelloworld> Hi all, I am new here. I need some help with running hoogle locally. I installed hoogle 5.0 from the source but there doesn't seem to be a "convert" command to convert text database file to hoo extension. I am actually trying to get Hoogle working for Frege. I generated a text file with Frege types and doc but I don't know how to convert that to "hoo" extension with Hoogle 5.0 so that I can run hoogle for Frege types. 
18:03:50 <mmhelloworld> Any suggestions? I had it working with previous version of hoogle but it wasn't displaying unicode characters correctly.
18:06:06 <traf> jle: hmm ok thanks :)
18:06:17 <jle`> np!
18:07:40 <koz_> OK, if I define a record type like Foo a = Foo {bar :: Int, baz :: Maybe Int}, and I have an instance of Foo called x, I can get at its baz field by using (baz x), right?
18:07:53 <johnw> koz_: correct
18:09:09 <koz_> johnw: And what do I need to export from a module to allow this in other modules?
18:10:13 <johnw> Foo(..)
18:10:14 <ga2arch> koz_: Foo(..) 
18:10:30 <koz_> Oh, right.
18:10:35 <koz_> I knew I was missing *something* in that...
18:13:30 <nocturne777> glguy: I find it a bit misleading when it says in the documentation of the aeson "This function parses immediately, but defers conversion. See json for details." (decode)
18:13:58 <nocturne777> glguy: when I look at the implemenation here, that does not seem to be the case: https://github.com/bos/aeson/blob/f3fce247bfcfcbd6faa984696f24c5c5fc4f44de/Data/Aeson/Parser/Internal.hs#L315
18:14:44 <domgetter> quick question from a complete newbie.  So when a function definition is like so: "add :: Integer -> Integer -> Integer" are we saying that add if a function that takes an Integer and returns a function that takes an Integer and returns an integer?
18:14:59 <domgetter> add is a function that takes*
18:15:14 <nocturne777> it feels like when decodeWith takes "json" it is parses it lazily, whereas if it takes json', it parses it strictly
18:15:32 <jle`> domgetter: yes, that's true.  but often people mentally parse it as a function that takes two integers and returns an integer
18:16:03 <domgetter> can add be a function that takes a function?  as in (Integer -> Integer) -> Integer?
18:16:13 <domgetter> or would I have to write it a different way?
18:16:20 <jle`> that would be a different function, yes
18:16:32 <jle`> the `add` you had originally was Integer -> (Integer -> Integer)
18:16:43 <jle`> which is equivalent-ish to an (Integer, Integer) -> Integer
18:17:09 <franky> does anyone here have experience in reading haskell assembly language produced by ghc?
18:17:18 <jle`> an (Integer -> Integer) -> Integer would be something completely different :o
18:17:23 <domgetter> okay so the parentheses are implicitly around the second pair? that is, add :: Integer -> Integer -> Integer is the same as add :: Integer -> (Integer -> Integer), is that correct?
18:17:28 <jle`> yes
18:17:38 <jle`> they say that -> associates "from the right"
18:17:49 <domgetter> ah haha I was busy typing and didnt see that you had already answered
18:17:51 <jle`> a -> b -> c -> d is a -> (b -> (c -> d))
18:17:52 <domgetter> thank you very much
18:18:24 <jle`> writing it as a -> (b -> c) instead of (a, b) -> c gives us a bit more flexibility in how we can use it :)
18:18:58 <jle`> but whoever wrote `add` could have written it as (Integer, Integer) -> Integer and the function would be more or less the same
18:19:08 <domgetter> oh I'm down with the benefits of currying, I just didn't know where the parens went implicitly
18:19:19 <jle`> ah, yeah :)
18:23:11 <thimoteus> is it possible to write foldr in tail recursive form?
18:26:02 <domgetter> thimoteus: you should be able to pass the accumulation to the next step of the recursion so that there's no more work to do
18:26:55 <nicow> glguy: just saw the code you posted above, I must have done something wrong
18:28:05 <ski> > foldr (\n s -> concat ["(",show n," * ",s,")"]) "1" [2,3,5,7]
18:28:06 <lambdabot>  "(2 * (3 * (5 * (7 * 1))))"
18:28:16 <ski> > foldl (\k n s -> (k . concat) ["(",show n," * ",s,")"]) (\s -> s) [2,3,5,7] "1"
18:28:18 <lambdabot>  "(2 * (3 * (5 * (7 * 1))))"
18:29:05 <nicow> glguy: also, allocation should not be a problem? as ga2arch mentioned, I am serializing a lot of small messages, and in profiling it shows up that 50% of my program's allocation is due to serialization. Though the productivity overall is over 80%, so maybe it's not that much of a problem
18:29:28 <athan> It would be really cool if lambdabot could to TH splices, or do Data / Typeable traversals :x
18:29:35 <ski> > foldr (\n s -> concat ["(",show n," * ",s,")"]) "1" primes
18:29:37 <lambdabot>  "(2 * (3 * (5 * (7 * (11 * (13 * (17 * (19 * (23 * (29 * (31 * (37 * (41 * (...
18:29:41 <ski> > foldl (\k n s -> (k . concat) ["(",show n," * ",s,")"]) (\s -> s) primes "1"
18:29:45 <lambdabot>  mueval-core: Time limit exceeded
18:29:52 <ski> thimoteus ^
18:33:18 <ski> thimoteus : if it is tail-recursive, then it is bulky (doesn't generate an answer until it has reached the end of the list, traversed all of it), and so it can't then work usefully on infinite lists (unlike the normal `foldr', given a suitable combination function as argument)
18:37:25 <thimoteus> i'm mostly thinking about strict languages, since i'm used to using foldr in haskell but where foldl would be preferable with a different evaluation strategy
18:39:34 <SrPx> ski hey you inspired me to draw this: http://i.imgur.com/CSjrhsX.jpg I think this is informative enough to explain what I meant. I find that representation of "16" quite elegant, for some reason. 
18:39:50 <SrPx> I wish I could read more about things like that.
18:40:32 <SrPx> ski no need to read it all, just look at how "16" can be represented as a very small graph on normal form on the end
18:47:08 <jle`> hm i've been writing my haskell neural network code to work completely in cpu...and now i just realized that i could easy compile them to javascript with ghcjs and now i'll have an in-browser neural network playground
18:47:15 <jle`> let's see how much i can make V8 suffer
18:47:20 <jle`> s/suffer/work hard
18:47:28 <MarcelineVQ> jle`: use your gpu for some nice paralellism
18:47:59 <jle`> yeah, i will eventually when performance becomes a bottleneck
18:48:10 <jle`> er, a deal-breaker
18:48:22 <jle`> but being able to run them in javascript was a nice side-benefit
18:54:48 <dfeuer> If I have   type family X :: k,  and I want  coerceXX :: Coercion X X, for some reason it seems I need to write   coerceXX = x where x = Coercion; if I just write  coerceXX = Coercion, I get a type error. What's the deal?
18:55:01 * hackagebot bytestring-tree-builder 0.2.1.2 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.1.2 (NikitaVolkov)
19:00:01 * hackagebot bytestring-tree-builder 0.2.1.3 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.1.3 (NikitaVolkov)
19:01:05 <ski> SrPx : interesting
19:01:18 <ski> ("no need to read it all" -- goes on to read it all)
19:02:06 <athan> dfeuer: let polymorphism? :v
19:02:37 <dfeuer> athan, can you tell me a story there? 
19:03:03 <athan> dfeuer: I'm just joking, I think OutsideIn(X) defeats let generalization anyway
19:03:24 <athan> dfeuer: What's Coercion?
19:03:25 <zachk> what is (:::) and what do i need to do to use it in my code? 
19:03:28 <SrPx> ski cool (:
19:03:36 <jle`> zachk: do you mean  (::) ?
19:03:50 <jle`> (:::) is just a normal user-defined constructor and doesn't have any major syntactic significance
19:04:00 <athan> zachk: That might be a type operator - a type family or type constructor made infix for some reason
19:04:02 <zachk> no i mean (:::) from the vinyl records tutorial by jon sterling, written in 2013 
19:04:10 <zachk> maybe I am not importing enought stuff
19:04:12 <dfeuer> athan,  data Coercion :: k -> k -> * where Coercible a b => Coercion a b
19:04:17 <athan> oop, can't help there
19:04:19 <jle`> zachk: oh okay.  yeah, if you see it, then it's coming from a library that defines it
19:04:33 <athan> dfeuer: Ahh, okay. One second
19:04:37 <jle`> want to link to the tutorial?
19:04:46 <dfeuer> athan, it's in Data.Type.Coercion
19:04:50 <zachk> I have no cut and paste 
19:04:55 <jle`> this is like asking "what does x mean, and why do i have to use it?; from this tutorial in 2013"
19:04:57 <zachk> and I can't find a newer tutorial on vinyl 
19:05:10 <dfeuer> (which is in base)
19:05:12 <jle`> "this tutorial uses a value called "x", what does it mean?"
19:05:24 <jle`> it's hard to know without seeing the tutorial.  x is just a normal user-defined value :)
19:05:27 <athan> dfeuer: What's the exact type error?
19:05:37 <athan> `can't unify X with b` or something?
19:05:40 * zachk doesn't want to type out the whole url :( 
19:05:57 <dfeuer> athan,     Couldn't match representation of type ‘X’ with that of ‘X’
19:05:57 <dfeuer>      NB: ‘X’ is a type function, and may not be injective
19:05:57 <dfeuer>     etc.
19:06:10 <athan> ahh okay
19:06:38 <athan> bad news, I know nothing about representations :D
19:07:05 <dfeuer> Hrrrm.
19:07:06 <athan> but, from the looks of it, I think let generalization might be a part of it
19:07:13 <athan> I've heard of people having the same issue before
19:07:36 <athan> coercing instead of traversing to get a new type, but they need a `let` in there to break unification or something
19:08:11 <dfeuer> athan, I can give the local variable a signature if I want;    coerceXX = c where c :: x ~ X => Coercion x x; c = Coercion
19:08:44 <dfeuer> I'm thinking somehow the local thing may clarify that both uses of X are at the same kind? I don't really know. Weirds me out.
19:10:10 <athan> dfeuer: Did you use the same context-based variable creation like you did in the `where` clause, for your top-level signature?
19:10:25 <athan> i.e. x ~ X
19:10:35 <athan> I don't think this should matter but what the hey
19:10:59 <athan> I'm guessing representations must be some seam in between types and terms
19:11:49 <athan> I'm _guessing_ through term-level holes, are where they are matched to their type-level assertions (that X has representational or something)
19:11:59 <athan> ugh
19:12:28 <athan> and by term-level holes I mean a lambda expression itself - the variable might check immediately?
19:12:31 <athan> I'm not sure
19:13:11 <lpaste> dfeuer pasted “Polykinded type family coercion” at http://lpaste.net/765078372865802240
19:13:17 <dfeuer> athan, I just pasted examples.
19:13:38 <dfeuer> athan, usually, "representation" has to do with coercion stuff--whether things are newtypes, etc., of each other.
19:14:19 <athan> dfeuer: What about `where c :: Coercion X X; c = ...`?
19:14:58 <athan> ahh okay, hmm
19:15:14 <dfeuer> athan, nope, not that.
19:15:19 <dfeuer> That doesn't work.
19:15:29 <ski> if we had `type family Y :: * -> *', then it (possibly) not being injective means that from an equality `Y a = Y b', we can't deduce `a = b'. however, if `y' gets instantiated to `Y a', then `Foo y y' would becomed `Foo (Y a) (Y a)' .. otoh, it would probably (for the mentioned reason) not allow unifying `Y a' with `Y a' to check that the arguments to `Foo' are equal, even if in this case that equality must logically hold
19:15:31 <athan> :)
19:16:27 <ski> so, i might guess that even in the parameterless case `X' here, it is following a similar rule of not allowing to unify `X' with `X', while otoh allowing unifying `x' with `X', instantiating the former to the latter, making `Coercion x x' into `Coercion X X'
19:16:33 <ski> .. this is just my wild guess, though
19:16:40 <athan> ski to the rescue! Wow, that makes a lot of sense
19:17:04 <ski> (no idea what "representations" refer to here)
19:17:19 <dfeuer> ski, yeah, I guess. Sense it does not make, however. The term "injective" doesn't seem to apply to the idea of a nullary type family in any meaningful sense!
19:17:48 <dfeuer> ski, the other question is why it's able to *infer* a type for the local definition!
19:17:58 <ski> dfeuer : yeah, one would prefer if that trivial case was handled otherwise (no idea if it is, or not)
19:18:18 <dfeuer> I would be less mystified if I actually *had* to provide the local signature.
19:18:44 <ski> dfeuer : hm .. you have an explicit type signature on the top `coerceXX', for the working helper-inferred case ?
19:19:05 <dfeuer> ski, take a look at the lpaste: http://lpaste.net/765078372865802240
19:20:43 <dfeuer> ski, oh, when I have the local signature, I don't need the top-level one. It's inferred just the same.
19:20:44 <ski> assuming the above holds, i would suppose that it infers something like `x ~ X => Coercion x x' for the helper (or maybe in the inference process it gets to `Coercion _x _x' inbetween, and then instantiates the meta `_x' to `X', as opposed to trying to unify `X' with `X')
19:21:16 <dfeuer> _x? Meta?
19:21:26 <ski> meta variable
19:21:50 <dfeuer> Not sure what those are, exactly.
19:21:56 <ski> aka placeholder, or logic variable (in logic programming), or dataflow variable (in concurrent logic programming)
19:22:05 <ski> internal machinery for the unification process
19:22:07 <dfeuer> Ah.
19:23:30 <ski> in `($) f x = f x', we first infer `f :: _a -> _b',`x :: _a',`f x :: _b', and so `($) :: (_a -> _b) -> _a -> _b', then we generalize this by replacing the metas by skolems : `($) :: forall a b. (a -> b) -> a -> b'
19:24:20 <ski> (here, initially we have `f :: _c' for another meta `_c', but the application `f x' forces `_c = _d -> _e' and `_d = _a' and `_e = _b')
19:24:49 <dfeuer> Skolems? I've encountered the term, but in what seems a slightly different context.
19:26:53 <ski> (which context ?)
19:27:16 <ski> dfeuer : "when I have the local signature, I don't need the top-level one. It's inferred just the same." -- and without the local signature ?
19:27:26 <dfeuer> ski, as magicked-up variables used to check that a term has a certain polymorphic type.
19:27:54 <dfeuer> ski, did you look at what I pasted? 
19:28:33 <lpaste> dfeuer revised “Polykinded type family coercion”: “No title” at http://lpaste.net/765078372865802240
19:28:38 <ski> anyway, my guess is that with `coercionXX :: Coercion X X', it is taking both `X's as given, trying to unify them to check that they are equal, discovering that they are both a type family, which forbids this unification (presumably even in the parameterless case)
19:30:03 * hackagebot bytestring-tree-builder 0.2.1.4 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.1.4 (NikitaVolkov)
19:30:20 <ski> while in the `c = Coercion' case, it is not required to unify `X' with `X'. either keeping it wholly general (specializing in the use in `coercionXX'). or inferring `Coercion _x _x' and only after than instantiating `_x' to `X'
19:30:30 <ski> dfeuer : yes, i looked at it
19:31:55 <dfeuer> ski, I think the coercion system must come into it somehow, because I can write  foop :: X :~: X; foop = Refl  without any trouble!
19:32:48 <ski> dfeuer : yes, on second thought, i suppose the skolems are really the free "atoms" (like `a' and `b' while *checking* the definition of `($)' if we had provided an *explicit* signature `($) :: forall a b. (a -> b) -> a -> b') .. as opposed to the bound variables `a',`b' in `forall a b. (a -> b) -> a -> b' itself
19:33:06 <dfeuer> Okay.
19:33:26 <ski> (well, also when opening an existential, you get skolems)
19:33:46 <dfeuer> I know only a drop about this stuff.
19:35:32 <ski> if we're checking the definition of a polymorphic operation, with a corresponding universal signature, then the tyvars corresponding to the outermost `forall' will correspond to skolems during the type-checking, which act as unknown types, which will only unify with themselves
19:36:00 <ski> similarly when opening an existential package, we get a skolem for the unknown tyvars from the existentials
19:36:45 <dfeuer> *nod*
19:37:33 <ski> otoh, if we have an operation which will turn out to be polymorphic, but with no explicit signature, we will infer a type which isn't fully determined, it still has (uninstantiated) metavars in it. the inference process will then *generalize* the type on those metavars (or rather the subset of them not occuring free in the context)
19:38:06 <dfeuer> *nod*
19:38:24 <ski> so, two different processes which ends up with the same result (a universal type being correctly ascribed to the operation)
19:39:01 <ski> not sure why `foop' above works
19:43:03 <ski> hmm .. comparing `data Coercion :: k -> k -> * where Coercible a b => Coercion a b' with `data a :~: b where Refl :: a :~: a' (i assume the definition of `:~:' you use looks something like this. the important part is really the signature for the data constructor)
19:44:02 <ski> possibly the difference is because the latter is mentioning `a' twice in the type, while the former is mentioning `a' and `b', each once, and relating them by a constraint
19:45:27 <harwiltz> Hello, does anyone know how to handle window resizing with hscurses?
19:45:43 <ski>   "Nevertheless one can pretend that the following three kinds of instances exist. First, as a trivial base-case:"
19:45:53 <ski>   "  instance a a"
19:46:15 <ski>   "Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let `D' be a prototypical type constructor (data or newtype) with three type arguments, which have roles nominal, representational resp. phantom. Then there is an instance of the form"
19:46:29 <ski>   "  instance Coercible b b' => Coercible (D a b c) (D a b' c')"
19:46:45 <ski>   &c. -- <http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Coerce.html#t:Coercible>
19:47:57 <ski> so i guess the question then is whether there's any `Coercible' instances for type families
19:48:57 <dfeuer> Hrrmmm.
19:50:59 <dfeuer> ski, the "instances" don't exist until demanded; that much seems clear.
19:51:17 <dfeuer> I can demand the reflexive one for any old type variable.
19:51:38 <dfeuer> I guess probably none of this matters too much, outside of weird code.
19:57:21 <ski> the docs i looked at doesn't mention instances for `type' (or `data') families
19:58:09 <ski> (hm, or perhaps there would be ones for the `data' family case anyway .. nevermind here)
19:58:24 <ski> i suppose it could be because there's no such instances generated, or perhaps because families are supposed to be simplified before this
19:58:45 <dfeuer> ski, I can write   foom :: Coercion a a ; foom = Coercion
19:59:27 <dfeuer> Which is basically what I did with the other thing.
19:59:31 <ski> anyway i think the `instance Coercible a a' case (note typo) would allow later instantiating `a' with `X', while otoh `Coercible X X' isn't allowed
19:59:51 <dfeuer> Hrm.
19:59:51 <ski> anyway, it seems like a strange case, even assuming what i said is true
20:00:06 <dfeuer> No doubt.
20:00:07 <ski> you could perhaps mention it in #ghc or on a mailing list
20:00:46 <dfeuer> I sent a message to haskell-cafe; I just figured I might get something quicker here. Thanks for explaining the parts you could explain.
20:01:33 <ski> np
20:35:06 * hackagebot fay 0.23.1.9 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.9 (AdamBergmark)
20:38:28 <lingxiao> hey all
20:38:37 <lingxiao> I am having problems with my random number generator
20:40:06 * hackagebot fay 0.23.1.10 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.10 (AdamBergmark)
20:41:46 <michaelt> lingxiao: but what is the problem?
20:42:51 <lingxiao> I am implememtning an approximate counting algirthm
20:42:59 <lingxiao> and I'm not getting the expected result
20:43:34 <lingxiao> here's psedocode: http://lpaste.net/146567
20:44:44 <lingxiao> sorry here it is:
20:44:45 <lingxiao> http://lpaste.net/146568
20:45:41 <lingxiao> and here's my code
20:45:42 <lingxiao> http://lpaste.net/146569
20:50:14 <lingxiao> also posted here:
20:50:14 <lingxiao> http://stackoverflow.com/questions/34114181/randomized-algorithm-not-behaving-as-expected
20:52:00 <michaelt> lingxiao: this doesn't compile; I take it "type Prob = Double; type Tosses = Int"?
20:52:12 <lingxiao> yes sorry about that!
20:52:23 <lingxiao> here's the problem: 
20:52:26 <lingxiao> The problem is that my X is incorrect for any |stream| > 2, and it seems like for all StdGen and |stream| > 1000, $X = 7$.
20:53:57 <michaelt> this doesn't seem to typecheck either ... tos p s = (q <= 100*p, s') where (q,s') = randomR (1,100) s
20:54:53 <lingxiao> http://lpaste.net/146570
20:54:57 <lingxiao> updated ...
20:55:03 <lingxiao> but it does typecheck on mine?
20:55:11 <lingxiao> q <= 100 * p :: Bool, s' :: StdGen
20:56:34 <michaelt> lingxiao: yeah, I fixed it, I'm not sure why it needed " tos p s = (q <= 100*p, s') where (q,s') = randomR (1,100::Double) s "
20:57:05 <lingxiao> huh ... weird ..
20:57:32 <lingxiao> but thanks for doing that!
21:04:31 <lingxiao> michaelt isn't it weird? how would I even begin go about debugging that?
21:10:04 <lingxiao> michaelt I'm actually heading out, but if you see a solution would you mind answering it here: http://stackoverflow.com/questions/34114181/randomized-algorithm-not-behaving-as-expected
21:10:06 <lingxiao> :D :D
21:10:08 <lingxiao> thanks!
21:23:48 <djyellow> https://www.youtube.com/watch?v=SLsTskih7_I
21:50:08 * hackagebot xml-query 0.9.0.2 - A parser-agnostic declarative API for querying XML-documents  https://hackage.haskell.org/package/xml-query-0.9.0.2 (NikitaVolkov)
21:55:08 * hackagebot monad-skeleton 0.1.2.2 - An undead monad  https://hackage.haskell.org/package/monad-skeleton-0.1.2.2 (FumiakiKinoshita)
21:55:10 * hackagebot xml-query-xml-types 0.4 - An interpreter of "xml-query" queries for the "xml-types" documents  https://hackage.haskell.org/package/xml-query-xml-types-0.4 (NikitaVolkov)
21:55:12 * hackagebot xml-query-xml-conduit 0.3 - A binding for the "xml-query" and "xml-conduit" libraries  https://hackage.haskell.org/package/xml-query-xml-conduit-0.3 (NikitaVolkov)
22:00:19 * hackagebot hasql 0.14.0.3 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.14.0.3 (NikitaVolkov)
22:00:21 * hackagebot hasql 0.15.0.2 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.15.0.2 (NikitaVolkov)
22:00:23 * hackagebot hasql-transaction 0.3.0.3 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.3.0.3 (NikitaVolkov)
22:05:19 * hackagebot hasql-transaction 0.3.1 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.3.1 (NikitaVolkov)
23:06:59 <cgag> is there an easy way to tell stack to build all the packages from the current resolver
23:40:32 <mauke> I'm back from Haskell!
23:47:44 <traf> hello all
23:47:51 <traf> I'm fairly new the haskell
23:47:55 <traf> been reading LYAH
23:48:09 <traf> read upto and including start of monoids
23:48:19 <traf> i need to practice my haskell
23:48:36 <traf> and so i want to write some haskell to parse and transform some source code into html or smilar
23:48:52 <traf> can anybody point me towards some tutorials/libaries that will get me on my way
23:49:26 <traf> are there some already great plugins for extracting parts of source code
23:49:41 <traf> literally, all i want to do at first I grab some string arguments from some methods in c code
23:49:47 <ReinH> traf: you could look at parsec for parsing, but I'm not clear on what you want to do
23:49:49 <Amphyby> have you tried to search on hackage?
23:50:13 <ReinH> There are also pre-written parsers for some languages
23:50:18 <ReinH> @hackage language-c
23:50:19 <lambdabot> http://hackage.haskell.org/package/language-c
23:50:23 <ReinH> for example
23:53:13 <Jinxit> parsec is pretty fun to use though
