00:07:39 * hackagebot language-bash 0.6.1 - Parsing and pretty-printing Bash shell scripts  https://hackage.haskell.org/package/language-bash-0.6.1 (KyleRaftogianis)
00:07:39 * hackagebot HPDF 1.4.10 - Generation of PDF documents  https://hackage.haskell.org/package/HPDF-1.4.10 (alpheccar)
00:17:20 <jle`> `Guest00000: you can have a converting function between Integer and [()], and do efficient math on that Integer
00:18:42 <`Guest00000> no, i want the [()] itself be stored efficiently
00:37:48 <danclien> Trying to figure out how `hlibsass` works since it depends on the `libsass` C library.
00:38:46 <danclien> Looks like it pulls in the `libsass` library as source (as a Git submodule) and `libsass` is actually compiled as part of the GHC build process?
00:40:56 <pharaun> yup
00:41:19 <pharaun> look into setup.hs
00:43:02 <jle`> https://github.com/jakubfijalkowski/hlibsass/blob/master/Setup.hs
00:43:07 <danclien> pharaun: Thanks.
00:43:11 <jle`> oh, got beat to it
00:43:17 <danclien> :D
00:44:33 <danclien> Would it be possible to do that to `text-icu` which causes issues headaches because `icu4c` is missing on many systems?
00:48:33 <danclien> Ah, never  mind. Looks like the locally built `libsass` actually breaks `ghci`.
00:49:22 <shanemikel> \f -> (\x -> x x) (\x -> f (\y -> (x x) y))
00:49:32 <Phyx-> danclien: text-icu uses the import lib name in extra-libraries for windows. currently that isn't supported on windows
00:49:54 <shanemikel> \f -> (\x -> x x) (\x -> f (x x))
00:50:18 <shanemikel> is it possible to construct the Y combinator this way, anonymously, without ghc complaining about infinite types?
00:50:50 <jle`> you mean, in haskell?
00:50:54 <shanemikel> yeah
00:51:05 <jle`> it doesn't really make sense in haskell as you've written it
00:51:10 <jle`> it's not a problem with GHC
00:51:32 <Xnuk> :t \f -> (\x -> x x) (\x -> f (\y -> (x x) y))
00:51:33 <lambdabot>     Occurs check: cannot construct the infinite type:
00:51:33 <lambdabot>       r0 ~ r0 -> r1 -> r
00:51:33 <lambdabot>     Expected type: r0 -> r1 -> r
00:51:35 <jle`> but you can get something with the same intent/spirit by wrapping things in data types
00:51:37 <danclien> Phyx-: Weird. I was running into issues with it on OS X. I'll take another peek tomorrow.
00:51:50 <jle`> *wrapping things in data constructors
00:52:00 <jle`> but yeah, it's not an issue with GHC, it's an issue with how the haskell type system works
00:52:17 <jle`> it just doesn't make sense as a statement
00:52:30 <jle`> you might as well write case do of if -> 
00:52:32 <shanemikel> what does the tilde mean in r0 ~ r0 ?
00:52:35 * hackagebot bcrypt 0.0.8 - Haskell bindings to the bcrypt password hash  https://hackage.haskell.org/package/bcrypt-0.0.8 (AndrewMiller)
00:52:41 <jle`> (that's a bit of a lie, my example was a syntactical error)
00:53:07 <jle`> shanemikel: it stands for type equality, roughly
00:53:22 <jle`> it's saying that it's trying to unify `r0` with `r0 -> r1 -> r`
00:53:33 <jle`> by substituting in possibilities for r0, r1, and r
00:53:38 <jle`> but that's inherently impossible
00:53:41 <Phyx-> danclien: If i'm not mistaken, text-icu specified "icuuc" as extra library. which on the windows build of icuuc (depending on which distro/build you use) should resolve to icuuc.lib, and then find the actaul shared lib
00:54:03 <jle`> there's no combination of substitutions/instantiations of r0, r1, and r so that `r0` is the same as `r0 -> r1 -> r`
00:54:06 <Phyx-> danclien: https://ghc.haskell.org/trac/ghc/ticket/11072
00:55:33 <jle`> for a more concrete example of unification -- say you want to unify `fmap` and `map`, you want `(a -> b) -> f a -> f b` to unify with `(a -> b) -> [a] -> [b]`.  you can constrain/substitute `f ~ []`, so now you have `(a -> b) -> [a] -> [b]` ~ `(a -> b) -> [a] -> [b]`. unified!
00:55:59 <jle`> the two -- (a -> b) -> f a -> f b, and (a -> b) -> [a] -> [b], are unifiable
00:56:09 <jle`> but `a` and `a -> b -> c` are not
01:01:41 <ggole_> jle`: saying an infinite type doesn't make sense is going a bit far, seeing as there are type systems with such things
01:02:40 <jle`> it doesn't make sense in haskell, though, does it?
01:02:56 <ggole_> You mean it doesn't pass the Haskell type checker.
01:03:20 <jle`> i mean it's not a meaningful concept in the semantics of haskell the language
01:03:38 <shanemikel> well, I'm confused.. how does y = \f -> f (y f) get typed (a -> a) -> a
01:03:42 <ggole_> Unless I'm mistaken somewhere, it's a sensible expression which could be given the type (a -> a) -> a
01:09:54 <jle`> shanemikel: try looking up the hindley milner type inference algorithm; it'll tell you how to get from that expression to the 'most general possible' type signature you seee
01:14:26 <shanemikel> it'll have to wait 'till another day, I think I've exhausted my thinking resources for the day
01:14:33 <shanemikel> happy new years all
01:27:36 * hackagebot fcache 0.1.0.0 - Cache a function (a -> b)  https://hackage.haskell.org/package/fcache-0.1.0.0 (YLiLarry)
01:30:47 <ggole__> Although he's left, there's an easy way to see it: y takes f as argument: the return type of y is the return type of f: the return type of y is also the argument of f
01:30:55 <ggole__> Call that return type a and you have (a -> a) -> a
01:40:56 <mrkkrp> Hello. Is there existing library that does this: given list of things to process, it creates optimal number of threads (maybe determined with ‘getNumCapabilities’), then every thread atomically takes element from that list and does something with it (specified by user). After that it updates the “queue” and takes the next element, until all elements are processed. When all threads are done, the whole thing finishes and returns list of
01:40:56 <mrkkrp> results. ‘mapConcurently’ (from ‘async’) seems to do similar thing, but as I understand it makes one thread per action, which maybe inefficient when you have ~1000 elements (?)
01:45:50 <jle`> threads in haskell are pretty lightweight :o
01:45:54 <ReinH> mrkkrp: do you just want a pool?
01:46:46 <ReinH> although I agree that you shouldn't assume that threads are too expensive
01:47:16 <ReinH> you should read Simon's book.
01:48:49 <ReinH> you generally don't need to build your own fancy work-stealing dequeue since the RTS comes with one.
01:49:40 <mrkkrp> ReinH: already started (yesterday). From what I currently know, threads may be lighweight indeed, so 1000 threads map to 4 or 8 real threads. I hope Marlow's book will make clear all these topics.
01:50:03 <Erebe_> mrkkrp: not so much
01:50:12 <Erebe_> the book doesn't talk about that
01:50:50 <ReinH> What? Yes it does.
01:52:08 <Erebe_> it talks about green threads
01:52:15 <Erebe_> but not about how it is implemented
01:52:42 <ReinH> yes, it talks about the thing mrkkrp asked about.
01:53:14 <Erebe_> if you want to know more about the implementation you have to read this 
01:53:15 <Erebe_> http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
01:53:26 <ReinH> It spends some time talking about how to choose a good granularity, etc
01:53:40 <Erebe_> ho my bad
01:53:48 <ReinH> e.g., http://chimera.labs.oreilly.com/books/1230000000929/ch03.html#sec_par-kmeans-visualising-sparks
01:54:22 <ReinH> There's even a pretty graph of chunk size to runtime
01:54:26 <ReinH> So yes, it definitely talks about that
01:55:02 <mrkkrp> Great, I'm on chapter 2, so I'll soon be there :-)
02:07:37 <lamefun> Are monad transformers n² instance-wise? Looks like every monad transformer in MTL has to forward every one, so n² instances.
02:10:17 <jle`> i would probably say that about the typeclasses, not about the transformers
02:10:22 <ggVGc> I have objects a and b, and functions f,g,h and would like to compare f a == f b, g a == g b, h a == h b. What's the best way to write that?
02:13:12 <ggole_> ggVGc: so you want to know whether f a == f b equals g a == g b, etc?
02:16:35 <jle`> ggVGc: maybe something like all (\f -> f x ==  f y) [f,g,h] ?
02:16:45 <jle`> :t \x y -> all (\f -> f x == f y)
02:16:45 <ggVGc> ggole_: this is what I'm doing, https://gist.github.com/f4efe40db58c564d21af
02:16:47 <lambdabot> (Eq a, Foldable t) => t1 -> t1 -> t (t1 -> a) -> Bool
02:16:54 <ggVGc> that's Elm, but I think it's valid haskell also
02:17:02 <jle`> :t (\x y -> all (\f -> f x == f y)) `asAppliedTo` []
02:17:04 <lambdabot> (Eq a, Foldable t) => [t1] -> [t1] -> t ([t1] -> a) -> Bool
02:17:20 <jle`> oops, ignore the last one
02:17:33 <ggVGc> but there's a lot of repitition in what I've written
02:17:34 <ggVGc> I feel
02:17:34 <jle`> :t (\x y -> all (\f -> f x == f y)) :: a -> a -> [a -> a] -> Bool
02:17:36 <lambdabot>     No instance for (Eq a1) arising from a use of ‘==’
02:17:36 <lambdabot>     Possible fix:
02:17:36 <lambdabot>       add (Eq a1) to the context of
02:18:11 <jle`> :t (\x y -> all (\f -> f x == f y)) :: Eq a => a -> a -> [a -> a] -> Bool
02:18:12 <lambdabot> Eq a => a -> a -> [a -> a] -> Bool
02:18:16 <ggVGc> I guess I'd like a foo that worked like: tests = foo [getCount, getShape, getPattern] cards
02:18:47 <jle`> what is the type of cards?
02:20:00 <ggVGc> jle`: does it matter? It's Elm so it doesn't have type classes. this is the type anyway, https://gist.github.com/192c9341de957a358206
02:20:15 <jle`> ggVGc: i mean, is it a list of cards, or a tuple
02:20:25 <jle`> the way the original question was worded, it sounded like you had two cards
02:20:42 <jle`> but you are calling foo with `cards`
02:20:50 <jle`> what type do you want `foo` to have?
02:21:11 <jle`> [Card -> a] -> (Card, Card) -> Bool ?
02:22:23 <jle`> does foo work with a list of functions [f,g,h], and two pre-known values, and see if their results are all equal?
02:22:31 <jle`> or does it work with a list of values and three pre-known functions?
02:22:49 <jle`> (what type signtuare do you want `foo` to have?)
02:23:28 <jle`> if a, b, f, g, and h are all pre-known, i'd do all (\f -> f x == f y) [f,g,h]
02:24:08 <jle`> but if you want to write a higher-order function like foo, you have to figure choose what types your inputs and outputs are :)
02:49:30 <Skuzzzy> Any suggestions for gifts to get a type theorist for christmas?
02:56:35 <Rovanion> Skuzzzy: Some sort of inheritance perhaps?
02:57:13 <Skuzzzy> ayy lmao
02:58:13 <Rovanion> If you're C++ friends you could always touch his private parts.
03:00:08 <shirt> I have a Data.Map and a Data.Set. What's the best way to find a single (arbitrary) key from the Map that is also an element of the Set? (And return "Nothing" if none exist)
03:01:31 <Rovanion> All I want for christmas is μ.
03:04:34 <pavonia> shirt: Get the keys with keysSet from the map and intersect with the set, and then convert to a list, I guess
03:07:15 <danhask> hi all I am getting a strange clang error here:
03:07:15 <danhask> error: token is not a valid binary operator in a preprocessor subexpression
03:07:17 <danhask> #if MIN_VERSION_Cabal(1,22,5)
03:08:00 <danhask> any idea how to workaround it?
03:09:12 <Phyx-> 0.
03:27:46 <shirt> danhask: are you using cabal or ghc/ghci ?
03:27:52 <shirt> pavonia: thanks
03:33:08 <danhask> shirt: I am using cabal
03:33:31 <danhask> I am writing a hook that uses some cabal "imports"
03:33:44 <danhask> and these imports are different based on the cabal version
03:33:58 <danhask> so I am using pre-process macros
03:34:01 <danhask> but they fail
03:34:26 <danhask> I am on a Mac
03:34:33 <danhask> and ghc is not using standard gcc
03:34:41 <danhask> but a "mac" gcc
03:34:50 <danhask> that it might create some problems
03:35:03 <danhask> I should change maybe ghc settings to point to a "unix" gcc
03:38:05 <unit73e> Hey. Is it possible to do an efficient 'splitAt' using 'drop' and 'take' in haskell? I ask this because haskell is lazy by default.
03:38:43 <dresuer_> @splitAt
03:38:43 <lambdabot> Unknown command, try @list
03:38:46 <dresuer_> @src splitAt
03:38:47 <lambdabot> splitAt n xs = (take n xs, drop n xs)
03:39:34 <dresuer_> unit73e, Is that what you wanted?
03:39:48 <dresuer_> It's*
03:39:56 <unit73e> dresuer_: not really. I want to know the cost of the operation.
03:44:21 <unit73e> dresuer_: say you have a list size 10 and you do splitAt 9, the operation would cost 9*2 but it can be optimized to cost only 9. What I want to know is what happens in haskell since it is lazy, not eager.
03:51:06 <pavonia> unit73e: The list has to be traversed twice, how would laziness help there?
03:51:59 <unit73e> pavonia: because its the same list
03:52:32 <pavonia> But two different functions
03:53:15 <unit73e> hum.. is there a way to debug these things? I know you can get the time
04:02:51 <ggVGc> jle`: this is what I ended up with, maybe there is some impovement I could make? https://gist.github.com/9f216986a29183b3ae9a
04:15:26 <Saizan> unit73e: splitAt n is O(n) anyway, the actual implementation does not traverse the list twice but adds some bookeeping so in the end it's not necessarily faster
04:16:46 <unit73e> Saizan: yeah I checked the implementation
04:17:41 <ReinH> walking the spine of a list is pretty damn fast, especially after you've already done it once.
04:19:04 <unit73e> Saizan: I don't know what this def is though USE_REPORT_PRELUDE it switches implementations based on that
04:39:09 <srhb> unit73e: A lot of times the report contains some implementations that are inefficient (at least in GHC)
04:39:50 <srhb> unit73e: Setting that flag when compiling base causes it to be the inefficient report version.
04:41:08 <unit73e> srhb: thanks
04:41:50 <srhb> (I don't know why anyone would ever do so, but perhaps my imagination is lacking) :-)
04:44:46 <unit73e> perhaps it's just to understand the implementation easier or use for debugging the optimized version
05:18:34 <redflag> hi
05:18:53 <elperdut_> hello
05:19:07 <redflag> first time on an IRC channel
05:19:23 <redflag> i was recommended Haskell by a friend
05:19:32 <bernalex> good friend.
05:19:46 <dramforever> Welcome to Haskell
05:23:42 <nschoe> redflag, careful, you won't be able to leave now :-)
05:24:04 <redflag> wait what?
05:24:20 <redflag> why not?
05:24:44 <nschoe> 'cause you will love it so much ^^
05:25:05 <redflag> oh hahaha ait man u got me scared there for a second :)
05:25:31 <nschoe> Was just kidding, do't worry
05:28:03 * hackagebot serversession-backend-acid-state 1.0.3 - Storage backend for serversession using acid-state.  https://hackage.haskell.org/package/serversession-backend-acid-state-1.0.3 (FelipeLessa)
05:31:14 <redflag> anyone know any good Java IDEs for linux
05:31:30 <redflag> just installed my linux distro today
05:34:14 <bernalex> redflag: that is a question you are more likely to get answers to in #java.
05:35:02 <redflag> ait i'll be sure to ask there but may i ask the main purpose of the Haskell channel
05:35:11 <redflag> what is it you guys do here?
05:35:44 <dramforever> Asking and sharing thingss about Haskell
05:35:47 <dramforever> *things
05:35:55 <redflag> ait cool
05:36:02 <dramforever> Occasionally gets off-topic, though
05:36:06 <dramforever> lol =)
05:36:15 <redflag> haha sounds good :)
05:36:43 <exio4> for real offtopic we have #-blah, meta-physical conversations about time-travel go there
05:36:56 <exio4> #haskell-blah * 
05:37:00 <bernalex> unless the time machine is programmed in haskell.
05:37:51 <exio4> bernalex: quantum conversation, it will happen in both channels at the same time
05:38:07 <redflag> i can see what you guys mean when you say things get off-topic XD
05:40:48 <dgpratt> TIL "GADTs" is pronounced "gadits"
05:47:17 <dramforever> I just implemented a data structure and I'm shareing it :P the code is at http://lpaste.net/148144 and I also wrote a post about it http://dram.cf/p/chair-tree/
05:47:28 <dramforever> redflag: that's what I call sharing
05:47:35 <dramforever> =)
05:50:39 <dramforever> I'm looking to improve the speed of the program. Can anyone help?
05:50:51 <dramforever> Now I'm thinking perhaps I'll post it to reddit...
05:53:47 <redflag> nice dram im gonna check it out
05:54:18 <dramforever> redflag: um...perhaps not it's not easy to understand
05:54:39 <dramforever> I mean, you are just learning Haskell, right?
05:54:59 <redflag> yea im looking at it in confusion right now :)
05:55:42 <dramforever> redflag: Still thanks for you, for paying attention :)
05:56:05 <sphinxo> Hi, how can I use simplify this? http://lpaste.net/148145
05:56:28 <sphinxo> Could I take advantage of Read somehow?
05:57:18 <oisdk_> :t (>> return)
05:57:19 <lambdabot> Monad m => (a1 -> a) -> a1 -> m a1
05:57:28 <oisdk_> :t ($>)
05:57:29 <lambdabot>     Not in scope: ‘$>’
05:57:29 <lambdabot>     Perhaps you meant one of these:
05:57:29 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
05:57:52 <oisdk_> :t (Data.Functor.$>)
05:57:53 <lambdabot> Functor f => f a -> b -> f b
05:58:49 <dramforever> sphinxo: do you want to reduce repeated code? hint: you can make a table of nucliobases like [("A", A), ...] and start from there
05:58:59 <`Guest00000> dramforever: please add some space under the text on your webpage...
05:59:10 <srhb> sphinxo: Yes, you could use read, although you should use a safe like readMay
06:00:03 <dramforever> `Guest00000: ah, that's a good suggestion. Working on it
06:00:03 <sphinxo> hmm ok thanks
06:00:22 <dramforever> thanks for that and paying attention
06:00:35 <dramforever> sphinxo: also what do you expect to do with the return N?
06:00:59 <dramforever> you see, it happily returns N *without consuming input* 
06:01:16 <sphinxo> ahh yes
06:03:34 <sphinxo> How is something like this? http://lpaste.net/148146
06:04:01 <dramforever> it's up to you, how do *you* think?
06:04:04 <Darwin226> Hey guys. I need some help. I'm trying to get something like this (http://lpaste.net/148147) to work
06:04:25 <Darwin226> But I'm getting an error saying theres no MonadA instance for ExceptT
06:04:35 <sphinxo> How can I consume a char and just discard it? 
06:04:36 <Darwin226> What can I do about this?
06:04:58 <hsk3> main = do
06:04:58 <hsk3>     d <- pureFunctionThatReturnsDouble
06:04:59 <hsk3>     let d' = seq id d
06:05:00 <hsk3>     putStrLn "done"
06:05:21 <hsk3> Shouldn't the seq make sure that d is fully evalulated before continuing to putStrLn ?
06:05:32 <lyxia> Darwin226: Try implementing MonadA for ExceptT
06:06:05 <hsk3> ah, it is. never mind, thanks
06:06:22 <Darwin226> lyxia: In this case MonadA is PersistBackend from groundhog and it defines a ton of methods. Is there no other way?
06:06:30 <lyxia> hsk3: this seq does nothing, no.
06:06:32 <aweinstock> hsk3: if pureFunctionThatReturnsDouble is pure, using <- should be a type error
06:06:51 <hsk3> oh yeah, sorry
06:06:55 <hsk3> ok i see
06:06:57 <hsk3> i get it now
06:06:57 <aweinstock> are ou trying to benchmark it?
06:06:58 <hsk3> thanks
06:07:01 <hsk3> aweinstock: yeah
06:07:21 <Darwin226> lyxia: I mean, can't I just lift my way out of this somehow?
06:07:33 <aweinstock> use criterion, it handles edge cases with laziness correctly
06:07:46 <aweinstock> (it also does fancy statistics and graphs for you)
06:07:50 <the_loco> Hello, everyone. Do you know how to run a background process with Shelly (https://hackage.haskell.org/package/shelly)?
06:08:26 <hsk3> aweinstock: i'll try that now, will you be around during the next hour or so?
06:08:58 <the_loco> I tried adding & too the list of arguments of the run function, but it doesn't work.
06:09:55 <aweinstock> the_loco: asynchSh might do it?
06:10:08 <sphinxo> http://lpaste.net/148149 is there a cleaner way to do the anychar?
06:10:15 <aweinstock> https://hackage.haskell.org/package/shelly-1.6.5/docs/Shelly.html#v:asyncSh
06:11:36 <aweinstock> sphinxo: what's the alternative case supposed to do? discard anything that's not in [ATCGU]?
06:11:54 <sphinxo> Discard the char and return n
06:12:05 <aweinstock> what does N stand for?
06:12:30 <the_loco> I'll tri it. Thanks for the quick responce aweinstock
06:12:42 <sphinxo> it means any
06:13:05 <dramforever> sphinxo: use <$, as usual
06:13:29 <sphinxo> it's part of the fastq standard
06:13:32 <Gurkenglas> sphinxo, how about "fromMaybe N . readMay <$> take 1"?
06:14:14 <Gurkenglas> Oh except that take returns a ByteString and readMay takes a String.
06:14:24 <aweinstock> sphinxo: it might be cleaner to use Parser (Maybe Nucleobase), replace t with (Just . t), and use Nothing instead of N
06:15:01 <sphinxo> hmm it's part of the format
06:15:10 <aweinstock> (Since that way you have a way to represent "non-null" Nucleobases)
06:15:41 <hsk3> aweinstock: it seems my function to be benchmarked has to return something that conforms to NFData
06:15:48 <hsk3> what if it returns a custom type?
06:16:03 <Gurkenglas> "fromMaybe N . readMay . pure <$> anyChar" maybe
06:16:25 <sphinxo> pure?
06:16:35 <hsk3> aweinstock: or is whnf enough? (nf requires NFData)
06:16:37 <Gurkenglas> :t [pure, (:[])]
06:16:38 <lambdabot> [a -> [a]]
06:16:47 <sphinxo> ahh
06:16:53 <hsk3> aweinstock: (to turn a function into Benchmarkable)
06:17:17 <aweinstock> hsk3: if you use whnf, then a function returning a list will only be benchmarked up to the first (:)
06:19:06 <aweinstock> hsk3: it looks like the DeriveGeneric approach is the simplest: https://hackage.haskell.org/package/deepseq-1.4.1.2/docs/Control-DeepSeq.html#v:rnf
06:19:32 <hsk3> ah sweet
06:20:21 <lyxia> Darwin226: Hm, another idea: make the MonadThrow part concrete, defining instead   inner :: (MonadA m, Error e) => ErrorT e m () -- or m (Maybe e) ...
06:20:28 <sphinxo> :t readMay
06:20:30 <lambdabot> Not in scope: ‘readMay’
06:20:39 <sphinxo> :t readMaybe
06:20:40 <lambdabot> Not in scope: ‘readMaybe’
06:20:47 <aweinstock> :t listToMaybe . reads
06:20:49 <lambdabot> Read a => String -> Maybe (a, String)
06:21:03 <aweinstock> :t fmap fst . listToMaybe . reads
06:21:04 <lambdabot> Read b => String -> Maybe b
06:21:39 <Darwin226> lyxia: Heh, interestingly, this is what I had at the beginning. Thought the typeclassy approach would be cleaner.
06:22:00 <Darwin226> lyxia: Anyways, I'm half way through implementing the missing instance, so I guess I'll just do that
06:36:59 <statusfailed> Are there any good tutorials on continuations? 
06:37:09 <statusfailed> I saw the wiki page, but hoping there's a more "linear" introduction
06:37:14 <statusfailed> (haskell Wiki page that is)
06:39:24 <infandum> How can I get "smartGaps" in xmonad?
06:40:19 <sphinxo> statusfailed: http://unbui.lt/#!/post/haskell-cont-monad/
06:47:42 <Darwin226> lyxia: Ok, so I've added that instance and now it's saying that it can't deduce MonadThrow m from MonadA m...
06:47:58 <Gurkenglas> @let import Safe
06:47:59 <lambdabot>  Defined.
06:48:01 <Gurkenglas> :t readMay
06:48:02 <lambdabot> Read a => String -> Maybe a
06:48:12 <Darwin226> lyxia: But isn't the runExceptT here so I wouldn't need to have the MonadThrow on the outer function?
07:03:06 * hackagebot th-typegraph 0.32 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.32 (DavidFox)
07:06:34 <cocreature> does servant have some identity route which never matches? I need some sort of monoid structure with :<|>
07:06:41 <cocreature> to do induction on type level lists
07:16:03 <maerwald> monochrom: after a few attempts with c2hs I cannot agree that it's easy
07:18:09 <cocreature> ftr, I ended up using failAlways _ f = f (failWith NotFound)
07:25:08 <maerwald> compile failures, syntax errors, buggy program switches
07:29:14 <xplat|work> graph of what subtype relation?
07:30:45 <xplat|work> having looked up the package: that is *not* what subtype means :(
07:32:50 <maerwald> and even if you manage to generate a C2HS file it is full of build failures still
07:33:27 <sphinxo> Say I have a list of some datatypes eg [A,C,G]
07:33:40 <sphinxo> and a list of numbers eg [1,2,3]
07:34:14 <sphinxo> and another datatype Base { key :: <Type of A C G>, score :: Int }
07:34:37 <sphinxo> how can I like zip the two lists to create the new type?
07:35:24 <dramforever> hint: Base is an ordinary constructor. check its type
07:35:55 <dramforever> you know, those are just ordinary data types that happen to support this record syntax sugar
07:37:33 <sphinxo> you're going to have to gve me more then that dramforever, I'm still new to haskell
07:38:25 <dramforever> oh yeah sorry. What do you know about records?
07:38:42 <dramforever> sphinxo ^
07:38:57 <Gurkenglas> What functions do you know that can zip stuff?
07:38:57 <sphinxo> What do you mean?
07:39:20 <dramforever> sphinxo: you know, that { ... } in data type definitions
07:39:35 <maerwald> and tutorials are outdated or just confusing
07:39:48 <sphinxo> yes dramforever I know of that
07:40:08 <Gurkenglas> The function Base has type Key -> Int -> Base. zipWith has type (a -> b -> c) -> [a] -> [b] -> [c]. You have [Key] and [Int] and want [Base].
07:40:19 <dramforever> @let data T = A | T | C | G
07:40:20 <lambdabot>  Defined.
07:40:36 <dramforever> @let data Base = Base { key :: T, score :: Int }
07:40:38 <lambdabot>  Defined.
07:40:55 <dramforever> (^ special syntax specific to lambdabot to define stuff)
07:41:48 <xplat|work> in a .hs file or .ghci, you just leave out the @let
07:41:54 <sphinxo> I know
07:42:27 <dramforever> as you can see, we are definining the types T and Base here, and also the A T C G Base key score. What do you know about the last three?
07:43:07 * hackagebot atp-haskell 1.9 - Translation from Ocaml to Haskell of John Harrison's ATP code  https://hackage.haskell.org/package/atp-haskell-1.9 (DavidFox)
07:43:17 <xplat|work> maerwald: honestly, i find the easiest thing is to just use the raw FFI, maybe with the help of 'managed'
07:43:20 <sphinxo> three of what?
07:43:24 <sphinxo> of T?
07:43:40 <xplat|work> maerwald: ... right up until the moment i hit a struct, then i want to kill myself.
07:43:48 <dramforever> oh, I mean Base, key and score
07:44:02 <maerwald> xplat|work: but that's not easy either
07:44:13 <maerwald> so conclusion is: C language bindings are _not_ easy
07:44:52 <xplat|work> maerwald: well, they're certainly not as easy as C language bindings from, say, C++
07:44:59 <sphinxo> Base uses record syntax
07:45:44 <sphinxo> T is an enumeration?
07:46:48 <xplat|work> maerwald: but they're comparable to like python+ctypes or JNA, and way easier than like JNI or, ugh, that thing you do in perl
07:47:05 <sphinxo> So just simple zipWith Base [A] [0]
07:47:30 <xplat|work> sphinxo: yeah.  using record syntax for constructors is always optional
07:47:50 <dramforever> sphinxo: exactly
07:47:51 <sphinxo> ahh ok
07:47:59 <dramforever> > zipWith Base [A] [0]
07:48:01 <lambdabot>      No instance for (Show Base)
07:48:01 <lambdabot>        arising from a use of ‘show_M426820622774446411326865’
07:48:01 <lambdabot>      In the expression:
07:48:04 <dramforever> uh duh
07:48:32 <xplat|work> you can standalone deriving in a @let if you remember the syntax
07:48:50 <dramforever> @let deriving instance Show Base
07:48:52 <lambdabot>  .L.hs:153:1:
07:48:52 <lambdabot>      No instance for (Show T) arising from a use of ‘showsPrec’
07:48:52 <lambdabot>      In the first argument of ‘(.)’, namely ‘(showsPrec 0 b1)’
07:48:56 <dramforever> @let deriving instance Show T
07:48:57 <lambdabot>  Defined.
07:48:58 <dramforever> @let deriving instance Show Base
07:48:59 <lambdabot>  Defined.
07:49:01 <dramforever> > zipWith Base [A] [0]
07:49:03 <lambdabot>  [Base {key = A, score = 0}]
07:49:47 <dramforever> there you go, after flooding the channel (Hey someone should make lambdabot only give one-liner error message until explicitly ask to expand or something...)
07:50:18 <sphinxo> Thanks everybody
07:52:52 <kadoban> dramforever: Sometimes the error message is the whole point. Better to just tell people not to play with lambdabot in public.
07:53:17 <dramforever> kadoban: "Error! show with @error" should be perfect
07:53:22 <xplat|work> yeah, but overconfidence is a thing that happens
07:53:24 <kadoban> Meh
07:53:42 <dramforever> xplat|work: always =)
07:53:47 <xplat|work> you could even have it @msg the error if you mess up
07:53:57 <xplat|work> er, /msg
07:54:52 <xplat|work> and only show a one-liner to the whole channel
07:55:36 <xplat|work> if you want to show an error on purpose, just do something like '@error x = [x]'
07:57:38 <dramforever> xplat|work: you know, there's already an @more command. Would be good to use that
07:57:47 <dramforever> as I said, "Error, use @more to display"
07:59:44 <xplat|work> dramforever: yeah, but having the full error in /msg means 1) you don't have to do an extra command to find out what went wrong, as the submitter 2) you are automatically invited to switch to a query with lambdabot until you fix your oneliner
08:00:22 <dramforever> xplat|work: sounds great, and I just realized we could even implement both!
08:00:44 <dramforever> now we need someone familiar with lambdabot...
08:00:45 <benzrf> @error x = [x]
08:00:45 <lambdabot> Unknown command, try @list
08:00:48 <benzrf> umm
08:00:53 <benzrf> xplat|work: what was that supposed to do?
08:01:04 <benzrf> ah, mb... read some scrollback -.-
08:03:17 <hackrilege> What is the difference between Free and Fix. I have foldFree and ana to compare
08:03:32 <zett_zelett> Is it intended behaviour of ghci/runhaskell to make an Integer out of (0 :: Num a)?
08:04:16 <zett_zelett> Er, (0 :: Num a => a), I mean.
08:05:25 <hackrilege> Num have fromInteger
08:05:37 <hackrilege> So it is reasonable
08:05:38 <xplat|work> hackrilege: Fix f =~= Free f Void, iirc
08:05:49 <xplat|work> where =~= is isomorphism
08:05:54 <ClaudiusMaximus> zett_zelett: probably the usual combination of monomorphism restriction and defaulting - try {-# LANGUAGE NoMonomorphismRestriction #-} which might give an error about ambiguous types instead
08:06:02 <hackrilege> What is Void?
08:06:10 <xplat|work> hackrilege: the empty type
08:06:12 <zett_zelett> Ok, but ghc compiles my code and ghci doesn’t run it. That should not be.
08:06:19 <hackrilege> I thought the Fixed point had a type...
08:06:44 <johnw> Free f Void is stating in the type that the recursion "never ends"
08:06:59 <johnw> not unless the type itself has a constructor that is non-recursive
08:07:03 <hackrilege> I think I want hylo for Free. Easy enough I guess
08:07:10 <xplat|work> the type f, that is
08:07:17 <johnw> right
08:07:28 <hackrilege> Buy in hylo a type appears....
08:07:39 <sphinxo> What's a clean way of getting a filename from args given to a program and getting the contents of the file?
08:07:45 <dramforever> hahaha funny pun over ther, hackrilege
08:08:05 <johnw> Free f a =~= Fix (Compose (Either a) f)
08:08:09 <Gurkenglas> The constructors for Free f a and Fix f are "Free (f (Free f a)) | Pure a" and "Fix (f (Fix f))". Setting a = Void makes Pure a unapplicable and thus the two constructions identical
08:08:30 <xplat|work> sphinxo: probably the easiest way to do that is use Turtle
08:08:58 <Gurkenglas> The easiest way would be readFile o.o
08:09:09 <hackrilege> How can hylo rectify types?
08:09:13 <Gurkenglas> (and getArgs for the arguments)
08:09:27 <hackrilege> Since none appear apparently
08:09:29 <sphinxo> ok thanks
08:10:13 <hackrilege> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
08:10:20 <xplat|work> Gurkenglas: the easiest *clean* way.  sphinxo said clean.
08:10:36 <Gurkenglas> sphinxo, http://lpaste.net/148156 works well
08:10:39 <Gurkenglas> Whats unclean about this?
08:10:51 <hackrilege> Perhaps let's consider ana instead
08:11:33 <xplat|work> ana is a more Cofree thing
08:11:40 <hackrilege> cata :: Functor f => (f a -> a) -> Fix f -> a
08:11:48 <xplat|work> you also have Fix f =~= Cofree f ()
08:11:52 <hackrilege> Data rather
08:12:01 <sphinxo> Great thanks 
08:12:02 <hackrilege> Cata*
08:12:55 <hackrilege> Ok so given Fix f, I can generate an a from something that needs f a even though I just have Fix f
08:13:13 <hackrilege> With no appearance of type a
08:13:21 <xplat|work> >[file] <- getArgs
08:13:37 <hackrilege> Stop you understand my confusion?
08:13:42 <xplat|work> that works for a trivial toy program, but it is *not* a clean way to handle command line arguments
08:13:42 <hackrilege> Do*
08:14:31 <Gurkenglas> You mean, one that allows arguments in any order and context sensitive?
08:14:34 <xplat|work> it gives weird error messages instead of understandable ones if you provide the wrong arguments to the program, it's not expandable to support options, etc
08:15:10 <hackrilege> If I can magic an a out of no where can I do away with Free and just use fix and functions that would work if ever the bottom were reached?
08:15:59 <Gurkenglas> wrong arguments? If this receives a string that isn't a filepath the exception you get says so. If you want to parse them as numbers and make sure error messages are sensible use readNote on the strings you get from there
08:16:06 <hackrilege> Namely ( f a -> a )
08:16:45 <xplat|work> hackrilege: if you have a finite instance of Fix a, you must have somewhere an f (Fix f) that has no Fix f in it.  so you can then treat it as a f a.
08:17:21 <hackrilege> Finite instance....
08:17:24 <xplat|work> hackrilege: then you feed it to your (f a -> a) and you have an a.  you use that as a starting point
08:18:32 <hackrilege> So at the Fixed point Fix f === f a, for all a?
08:18:55 <xplat|work> hackrilege: every (Fix f) contains exactly one (f (Fix f)).  
08:19:41 <hackrilege> But you said it should have no Fix inside
08:19:45 <`Guest00000> can I force compiler to make an executable completely without additional argument processing? i've read there is an option that disables RTS command line options, but iirc the argument "-RTS" will cause runtime error, and I want my program to just see it from inside
08:19:54 <xplat|work> if every (f (Fix f)) in there also contains a (Fix f) the data structure will be infinite
08:19:54 <`Guest00000> (about GHC)
08:20:28 <hackrilege> That's implicit from the definition, that it is infinite
08:21:00 <xplat|work> but if you have a (f (Fix f)) with no (Fix f), it's also a (f a) for every a, just like [] is a [a] for every a
08:21:03 <geekosaur> `Guest00000, your program should not see that option at all, it is removed by the runtime at startup
08:21:05 <hackrilege> To allow it to be finite and converge to a set type I was using Free
08:21:06 <sphinxo> How do I use case with Either ParseError sometype? 
08:21:37 <`Guest00000> geekosaur: and I want my program to be able to see it
08:21:38 <xplat|work> in fact, [] is actually a case of that
08:21:52 <hackrilege> Cool
08:22:51 <xplat|work> @let Cell x a = Nil | Cons x a deriving (Show, Read, Enum, Ord, Eq, Functor)
08:22:51 <lambdabot>  Parse failed: Parse error: |
08:23:03 <xplat|work> @let data Cell x a = Nil | Cons x a deriving (Show, Read, Enum, Ord, Eq, Functor)
08:23:04 <lambdabot>  .L.hs:159:37:
08:23:04 <lambdabot>      Can't make a derived instance of ‘Enum (Cell x a)’:
08:23:04 <lambdabot>        ‘Cell’ must be an enumeration type
08:23:11 <geekosaur> I think the only way to completely avoid it is to use a C wrapper to start the runtime yourself
08:23:21 <xplat|work> @let data Cell x a = Nil | Cons x a deriving (Show, Read, Ord, Eq, Functor)
08:23:23 <lambdabot>  Defined.
08:23:43 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-ghc.html#using-own-main
08:24:40 <hackrilege> Wtf is that!?
08:25:06 <xplat|work> @let listToFixCell = foldr (\x xs -> In (Cons x xs)) (In Nil)
08:25:08 <lambdabot>  Defined.
08:25:17 <xplat|work> :t listToFixCell
08:25:19 <lambdabot> Foldable t => t x -> Mu (Cell x)
08:25:51 <sphinxo> is let the same as <- ?
08:25:54 <hackrilege> Mu is Fix?
08:25:57 <sphinxo> in a do statement
08:26:01 <xplat|work> > listToFixCell [1..5]
08:26:03 <lambdabot>      No instance for (Show (Mu (Cell x0)))
08:26:03 <lambdabot>        arising from a use of ‘show_M344989985350550633727534’
08:26:03 <lambdabot>      In the expression:
08:26:08 <geekosaur> sphinxo, no
08:26:43 <geekosaur> let translates to a normal let. <- translates to (>>=)
08:26:58 <xplat|work> @let deriving instance Show x => Show (Mu (Cell x))
08:27:03 <lambdabot>  Defined.
08:27:09 <xplat|work> > listToFixCell [1..5]
08:27:11 <sphinxo> ok thanks geekosaur 
08:27:13 <lambdabot>  In {out = Cons 1 (In {out = Cons 2 (In {out = Cons 3 (In {out = Cons 4 (In {...
08:27:34 <xplat|work> yeah, Mu is Fix
08:27:39 <hackrilege> > list to fix cell [1..2]
08:27:41 <lambdabot>      Not in scope: ‘list’
08:27:42 <lambdabot>      Perhaps you meant one of these:
08:27:42 <lambdabot>        ‘last’ (imported from Data.List),
08:27:58 <hackrilege> My spell checker is killing me
08:28:35 <hackrilege> > listToFixCell [1..2]
08:28:37 <lambdabot>  In {out = Cons 1 (In {out = Cons 2 (In {out = Nil})})}
08:29:04 <geekosaur> I see someone is festively DDoSing freenode again :(
08:29:30 <xplat|work> @let fixCellToList = cata eat where eat :: Cons a [a] -> [a]; eat Nil = []; eat (Cons x xs) = x:xs
08:29:32 <lambdabot>  .L.hs:165:16:
08:29:32 <lambdabot>      Expecting two more arguments to ‘Cons a [a]’
08:29:32 <lambdabot>      Expected a type, but ‘Cons a [a]’ has kind ‘* -> * -> Constraint’
08:29:50 <xplat|work> @let fixCellToList = cata eat where eat :: Cell a [a] -> [a]; eat Nil = []; eat (Cons x xs) = x:xs
08:29:52 <lambdabot>  Defined.
08:30:10 <xplat|work> that error was exactly why i called the type Cell instead of Cons to begin with :-7
08:30:59 <hackrilege> Ok!
08:31:37 <xplat|work> > fixCellToList (In (Cons "hello" (In (Cons "world" (In Nil)))))
08:31:38 <lambdabot>  ["hello","world"]
08:32:48 <xplat|work> > fixCellToList (listToFixCell [1..5])
08:32:50 <lambdabot>  [1,2,3,4,5]
08:33:54 <xplat|work> @check \(xs :: [Char]) -> fixCellToList (listToFixCell xs) == xs 
08:33:54 <lambdabot>  <unknown>.hs: 1: 17:ScopedTypeVariables is not enabled
08:34:01 <sphinxo> :t <*
08:34:02 <lambdabot> parse error on input ‘<*’
08:34:07 <hackrilege> What have you done here using your Cell type?
08:34:11 <dutchie> :t (<*)
08:34:12 * hackagebot sexp-grammar 1.0.0 - Invertible parsers for S-expressions  https://hackage.haskell.org/package/sexp-grammar-1.0.0 (SergeyVinokurov)
08:34:13 <lambdabot> Applicative f => f a -> f b -> f a
08:34:41 <xplat|work> @check \xs -> fixCellToList (listToFixCell xs) == (xs :: [Char])
08:34:43 <lambdabot>  +++ OK, passed 100 tests.
08:35:00 <dramforever> hackagebot: That's not how you describe "parsers and (pretty?) printers"...
08:35:11 <monochrom> hackagebot? :)
08:35:15 <hackrilege> Your allowing Fix to terminate by combining the basecase into the container like Free
08:35:46 <xplat|work> hackrilege: yes.  that's how you always do it with Fix.
08:35:56 <hackrilege> Why not use Free?
08:36:06 <xplat|work> hackrilege: i tried explaining before, but i figured it would be better to show you :)
08:36:25 <hackrilege> Ok I get it better with the example thanks
08:36:29 <xplat|work> the advantage of Free is you also get ana and hylo
08:36:43 <xplat|work> er, the advantage of Fix.  and the disadvantage of Free.
08:37:36 <hackrilege> But why use Fix Maybe rather than Free!? I would have thought abstracting out the because to the recursive datatype would make more sense... I guess I'm missing something!
08:38:03 <monochrom> IIRC there is no f such that Fix Maybe is isomorphic to Free f.
08:38:18 <hackrilege> Like I say Free has foldFree and unfoldFree instead
08:38:20 <xplat|work> Fix Maybe is the same as Free Identity ()
08:38:23 <monochrom> at any rate Fix and Free accomplish very different things
08:39:40 <hackrilege> It must be Fix Either then, the Nil confused me, looked like a Nothing, but I guess you need a place to pass the argument back out to get the functionality of Fix
08:39:53 <xplat|work> i wouldn't say they accomplish different things really.  more that they make different statements about the type you're building.
08:40:12 <hackrilege> Please go on
08:40:27 <hackrilege> This distinction is my goal
08:42:59 <xplat|work> [a] = Fix (Cell a) = Free (a,) () = Maybe (Cofree Maybe a)
08:44:13 * hackagebot uom-plugin 0.2.0.0 - Units of measure as a GHC typechecker plugin  https://hackage.haskell.org/package/uom-plugin-0.2.0.0 (AdamGundry)
08:44:18 <xplat|work> when you use Free to define a type, you're implicitly saying it's closely related to some other types
08:45:01 <xplat|work> like (Free (a,) b) is the type of dotted lists (a lisp concept) with (a)s before the dot and a (b) after
08:45:31 <xplat|work> by defining lists with Free, you are putting emphasis on the relationship of lists with dotted lists
08:46:31 <hackriledge> Omg I hate dropping connection sorry I missed a lot of that. Could you paste the whole discussion in a paste!? Oh, the logs don't live update do they?
08:46:56 <xplat|work> you are also placing emphasis on the monad structure of dotted lists (which is different from the monad structure of lists).  see if you can figure out what that structure is while i'm at lunch!
08:47:10 <monochrom> the one at ircbrowse.net is live
08:47:19 <hackriledge> Thanks!
08:50:54 <hackriledge> Ok I'm up to speed, so I have to find out about dotted lists, anyone want to help?
08:54:12 <hackriledge> I'm saying something about the relationship between lists and dotted lists when I use Free apparently. I can't find anything about the monad structure of dotted lists
08:55:56 <hackriledge> Anyone!?
08:56:30 <hackriledge> Honestly more than Google can muster
09:00:53 <sphinxo> Hi can someone give me some feedback for this? http://lpaste.net/148158
09:01:08 <hackriledge> Is a dotted list like an unevaluated cons, and so rather than the last element being the empty list it it's the singleton list of the last element?
09:01:11 <wei2912> sphinxo: looking
09:02:17 <sphinxo> thanks wei2912, i'm looking to make it more idiomatically haskell
09:02:18 <wei2912> sphinxo: what type of feedback do you want?
09:02:19 <hackriledge> Something about the recursion ending in a concrete type
09:02:48 <wei2912> hackriledge: i'm not sure what you mean by "an unevaluated cons"
09:03:17 <hackriledge> x:xs
09:03:28 <hackriledge> Is not just xs
09:03:39 <sphinxo> Can I probably do something to clean up the case in process, I feel there is some duplication there
09:03:42 <hackriledge> One of the cons had not been evaluated
09:04:12 <sphinxo> wei2912: Anything really
09:04:49 <hackriledge> But I think actually it's the one on the right, not the left, connecting the empty list which is unevaluated but I'm not sure
09:04:52 <wei2912> sphinxo: looks fine to me, i'm not sure abt the case statement
09:05:35 <sphinxo> is the use of Main.sequence ok?
09:05:41 <hackriledge> It's about the type of the base case in a recursion via Fix Either or Free
09:05:49 <hackriledge> They seem the same to me
09:06:12 <wei2912> hackriledge: i'm not familiar with lisp, sorry
09:06:30 <hackriledge> Other than the weird way it enters into Fix scares me so I consider using Free
09:07:18 <hackriledge> Wei, nvm about lisp, it was someone else's analogy to demonstrate the difference
09:08:26 <hackriledge> I'd prefer not to think about dotted lists, but the distinction between Fix Either and hylo and Free and unFoldFree and foldFree
09:09:31 <hackriledge> the distinction between (Fix Either and hylo) and (Free and (unFoldFree and foldFree))
09:10:07 <wei2912> hackriledge: that's out of my knowledge... sorry :P
09:10:07 <hackriledge> Are they isomorphic?
09:10:42 <`Guest00000> we need brackets support in English...
09:10:48 <hackriledge> It's ok I'll wait for someone
09:10:52 <hackriledge> :)
09:12:09 <hackriledge> Free seems better for Monads...
09:12:25 <wei2912> sphinxo: i'm somewhat confused by what that line does
09:12:32 <wei2912> sphinxo: specifically L37
09:12:57 <wei2912> sphinxo: oh wait, nvm
09:13:13 <wei2912> sphinxo: looks fine to me
09:13:21 <sphinxo> ok, thanks
09:13:49 <wei2912> gtg now, bye
09:13:55 <hackriledge> Ciao
09:14:02 <sphinxo> Ok this is really weird it seems only to be running doing sequence once? 
09:14:05 <magr> I'm using nvim for 2 weeks now, no complains
09:17:12 <hackriledge> Are (Fix Either and (ana and cata)) and (Free and (unFoldFree and foldFree)) distinct in some way?
09:18:26 <hackriledge> Looks the same to me, could really do with some commentary...
09:18:55 <monochrom> sphinxo: what is an example input such that you expect Main.sequence to be invoked twice but is invoked just once?
09:19:15 <sphinxo> a file may contain many sequences
09:19:32 <sphinxo> infact it almost always will
09:19:39 <hackriledge> Main should be called once
09:20:00 <monochrom> I am too lazy to create an example myself.
09:20:21 <sphinxo> I'm just using Main.sequence to seperate it from Prelude.sequence
09:20:28 <monochrom> I know.
09:20:52 <sphinxo> hackriledge: example input http://lpaste.net/148159
09:21:02 <hackriledge> Kk
09:21:06 <sphinxo> obviously it won't be the same thing repeated
09:21:35 <hackriledge> Ok
09:21:54 <hackriledge> I'm not sure what your question is
09:22:21 <sphinxo> Why does the program only parse the first "sequence"
09:22:46 <sphinxo> when it should do it for every single one
09:22:57 <sphinxo> because I have "many sequence"
09:26:07 <monochrom> I think it is because you haven't ate the newline after a sequence
09:26:37 <hackriledge> :t many1
09:26:39 <lambdabot>     Not in scope: ‘many1’
09:26:39 <lambdabot>     Perhaps you meant ‘many’ (imported from Control.Applicative)
09:26:53 <hackriledge> :t many
09:26:54 <lambdabot> Alternative f => f a -> f [a]
09:26:58 <sphinxo> many1 means it has to have at least 1
09:27:24 <lostman> wasn't (<>) at some point in Prelude? or am I imagining things?
09:27:59 <sphinxo> monochrom: You're totally right
09:28:09 <hackriledge> You flipped a left and right, it's printing an error?
09:28:17 <geekosaur> lostman, I don't think it was; it would cause conlicts with every program using a prettyprinter module
09:28:28 <sphinxo> hackriledge: flipped?
09:29:26 <hackriledge> print program gets program = ""?
09:30:15 <sphinxo> print . program <str> ?
09:30:18 <hackriledge> Left is are, but parse has empty list on right
09:30:39 <hackriledge> Left is error*
09:31:01 <sphinxo> Are you passing in a file correctly?
09:31:10 <sphinxo> It seems to work for me
09:32:05 <monochrom> works here too. even with the previous bug, I got one result. with a fix, 3.
09:32:16 <hackriledge> :t parse
09:32:18 <lambdabot> Not in scope: ‘parse’
09:32:27 <monochrom> "parse" is from parsec, too
09:32:55 <hackriledge> Hey monochrom do you know about that question I was asking?
09:33:14 <monochrom> no
09:33:19 <hackriledge> Your wise in these matters I'm sure
09:33:53 <monochrom> yes, I am wise in choosing which questions to pass.
09:34:00 <hackriledge> I think it's just equating types, I'm not quite comfortable. Does my hypothesis seem reasonable?
09:34:14 * hackagebot relational-query 0.7.1.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.7.1.0 (KeiHibino)
09:34:21 <hackriledge> You might be one of the few who can help
09:35:04 <hackriledge> (hackriledge) Are (Fix Either and (ana and cata)) and (Free and (unFoldFree and foldFree)) distinct in some way?
09:35:32 <hackriledge> I suspect they are not, how could I tell?
09:37:52 <magr> :t flip
09:37:54 <lambdabot> (a -> b -> c) -> b -> a -> c
09:37:55 <hackriledge> Oh I just realised this question was already posed during the froo monoid discussion by someone way experienced. Ok so I go.
09:37:58 <magr> oh!
09:38:09 <magr> nice
09:38:27 <hackriledge> @ok (>>=)
09:38:27 <lambdabot> Maybe you meant: yow wn v rc pl id do bf ask @ ? .
09:38:49 <hackriledge> Right...
09:42:34 <hackriledge> How can the typical uses of Fix and Free indicate a difference between them?
09:44:08 <Gurkenglas> Can I save a ghci session?
09:44:40 <monochrom> no
09:45:11 <monochrom> but there is a history file storing what you entered. just not what it output.
09:45:30 <monochrom> and it doesn't remember session boundaries
09:45:33 <Gurkenglas> I suppose I could do it in a vm and do snapshots
09:45:46 <monochrom> haha, that's a pretty big hammer
09:45:53 <Gurkenglas> But hard drives aren't quite that big yet
09:49:14 * hackagebot serversession-backend-persistent 1.0.2 - Storage backend for serversession using persistent and an RDBMS.  https://hackage.haskell.org/package/serversession-backend-persistent-1.0.2 (FelipeLessa)
09:49:16 * hackagebot serversession-backend-redis 1.0.1 - Storage backend for serversession using Redis.  https://hackage.haskell.org/package/serversession-backend-redis-1.0.1 (FelipeLessa)
09:49:59 <hackriledge> Maybe I'm asking the wrong question, I think the key hole in my understanding as to how to terminate the recursion in hylo
09:51:01 <hackriledge> > hylo (/2) (*2) 1
09:51:02 <lambdabot>  Not in scope: ‘hylo’
09:51:51 <hackriledge> When is it considered that a least fixed point had been determined?
09:52:05 <hackriledge> has*
09:52:41 <monochrom> that's bordering on philosophy
09:52:55 <hackriledge> How can I supply a condition?
09:53:44 <hackriledge> Continue to cata until Boolean function then ana
09:54:09 <hackriledge> Is that the wrong way of going on?
09:54:14 * hackagebot mangopay 1.12 - Bindings to the MangoPay API  https://hackage.haskell.org/package/mangopay-1.12 (FelipeLessa)
09:54:16 * hackagebot yesod-mangopay 1.12 - Yesod library for MangoPay API access  https://hackage.haskell.org/package/yesod-mangopay-1.12 (FelipeLessa)
09:54:40 <hackriledge> That is what I would like to achieve
09:56:13 <hackriledge> I gathered that was gong on implicitly in that once an unchanging solution gets kicked by the compiler, the anamorphism is given that value. Is that correct?
09:57:28 <hackriledge> Can I get a resource?
09:58:31 <hackriledge> Wow monochrom, happy New year. Keep rocking
09:58:33 <FofG_> So what's the precise reason we can't have a transformer with IO somewhere else besides at the bottom? newtype IOT m a = IOT { runIOT :: m (IO a) } not possible? I'm sure there's a very basic reason I'm just missing
09:59:23 <FofG_> do I just need to try to write the instances and I'll see quickly what the problem is?
09:59:44 <hackriledge> Because a monad of an io should be an io
09:59:57 <hackriledge> As it contains effects
10:00:06 <hackriledge> No?
10:00:10 <S11001001> FofG_: yes
10:00:11 <monochrom> I'm sure "newtype IOT m a = IOT { runIOT :: m (IO a) }" is a legal thing and at the same time still has IO at the bottom.
10:00:52 <FofG_> hmm...then maybe I'm still confused about the spatial metaphors/analogies used!
10:00:54 <monochrom> I mean, look at "m (IO a)".
10:01:12 <hackriledge> But you can have lists of IO I'm sure....
10:01:26 <FofG_> if we have `MaybeT (ExceptT String IO) String`, people will refer to this as "MaybeT on top of EitherT on top of IO", no?
10:01:48 <FofG_> sorry, mixed up ExceptT and EitherT
10:02:06 <hackriledge> Just consider Maybe IO
10:02:13 <FofG_> ok
10:02:16 <monochrom> MaybeT and ExceptT are too easy
10:02:17 <nolraiU> Is there a way around type level nats not being inductive?
10:02:51 <hackriledge> They are not inductive?
10:02:51 <FofG_> So we can have Maybe IO...where does the problem arise with transformers?
10:03:43 <hackriledge> Maybe IO logs good to me so I obviously have no idea what's going on
10:03:49 <hackriledge> Looks*
10:03:52 <FofG_> haha ok
10:04:17 <hackriledge> :t mapM
10:04:18 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
10:04:50 <hackriledge> Damn
10:04:57 <FofG_> but it is definitely the case that when you unwrap your transformer, however deeply nested it is, if IO is in there anywhere, it's going you're going to end up with runXT (runYT ( runZT myStack)) :: IO ( ....), right?
10:05:27 <nolraiU> hackriledge: Thats what people said about it when I searched the issue. The way this manifests is I cant write a "instance MyClass n => MyClass (1 + n) where".
10:06:11 <hackriledge> That's hellish though
10:07:24 <nolraiU> It makes the "compile time sized lists" example kind of unworkable in practice, afait.
10:07:37 <hackriledge> :t map putStrLn
10:07:38 <lambdabot> [String] -> [IO ()]
10:07:56 <hackriledge> :t sequence
10:07:57 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:08:44 <hackriledge> :t sequence . (map putStr)
10:08:46 <lambdabot> [String] -> IO [()]
10:08:52 <hackriledge> !?
10:09:53 <dalastboss> what's the best way to debug a parsec parser?
10:10:12 <dalastboss> i've identified a small example that fails but i have no idea why
10:10:52 <hackriledge> :t traverse . (map putStr)
10:10:53 <lambdabot>     Couldn't match type ‘[IO ()]’ with ‘a -> f b’
10:10:54 <lambdabot>     Expected type: [String] -> a -> f b
10:10:54 <lambdabot>       Actual type: [String] -> [IO ()]
10:11:07 <hackriledge> Nvm sry
10:11:26 <hackriledge> Could anyone help me do that?
10:11:41 <alynn> :t mapM_ putStr
10:11:42 <lambdabot> Foldable t => t String -> IO ()
10:12:02 <hackriledge> Thanks
10:12:06 <alynn> np
10:12:19 <magr> How do I avoid reversing the words in this function? -> http://lpaste.net/148160
10:12:51 <hackriledge> Define snoc?
10:12:52 <magr> I know I can use reverse, but I'm wondering if I can implement it in other way
10:13:39 <alynn> magr: you could have a look at the implementation of `words` from Data.List
10:13:53 <alynn> (or just use it directly, depending on why you're implementing this!)
10:14:15 <pikajude> does anybody know of a package that provides WSDL parsing?
10:14:16 <magr> I'm just learning the language
10:14:25 <hackriledge> @src words
10:14:26 <lambdabot> words s = case dropWhile isSpace s of
10:14:26 <lambdabot>     "" -> []
10:14:26 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:15:23 <magr> that bot is very handy
10:15:27 <magr> thank you
10:15:54 <hackriledge> :t break
10:15:56 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:17:04 <hackriledge> @src break
10:17:05 <lambdabot> break p = span (not . p)
10:17:19 <hackriledge> @src span
10:17:20 <lambdabot> span _ xs@[]                  = (xs, xs)
10:17:20 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
10:17:20 <lambdabot>                   | otherwise = ([],xs)
10:17:27 <nolraiU> Is there a way to fake a dependant case in Haskel?
10:18:44 <nolraiU> Or to turn a type level Nat into a GADT I can case on?
10:20:40 <hackriledge> Can anyone show me hylo in use?
10:23:42 <xplat|work> FofG_: the key issue is you can't have an IOT that lets you actually use IO effects in the resulting monad
10:25:34 <hackriledge> (xplat|work) brother save me from this vexation, the problem you left me with was a cryptic reiteration of my initial question!
10:26:53 <xplat|work> hackriledge: the way you define a dotted list type directly is
10:26:58 <hackriledge> I have since also realised that I should first understand how to use hylo practically
10:27:06 <hackriledge> Ooh ok
10:27:33 <xplat|work> @let DottedList a b = DNil b | DCons a (DottedList a b)
10:27:34 <lambdabot>  Parse failed: Parse error: |
10:27:53 <xplat|work> @let data DottedList a b = DNil b | DCons a (DottedList a b)
10:27:55 <lambdabot>  Defined.
10:28:20 <hackriledge> That's just Free!
10:28:36 <xplat|work> @let deriving instance Functor (DottedList a)
10:28:38 <lambdabot>  Defined.
10:28:47 <nolraiU> @where paste
10:28:47 <lambdabot> Haskell pastebin: http://lpaste.net/
10:29:15 <xplat|work> can you define the instance of Monad for that and see what it does?
10:29:23 <johnw> hackriledge: Free would be DCons (a (DottedList a b))
10:29:32 <hackriledge> More brackets indeed
10:29:42 <hackriledge> Sry
10:29:44 <johnw> really close, but not quite close enough :)
10:30:49 <jerin> Happy New Year!
10:30:51 <nolraiU> Does anyone here have any ideas how to get http://lpaste.net/148161 to work?
10:31:02 <hackriledge> Return = DNil
10:31:22 <nolraiU> Maybe I just need to use liquid haskell or agda instead..bleh.
10:34:12 <johnw> nolraiU: I can't easily reproduce your problem to see what the error is
10:34:21 * hackagebot clarifai 0.2.0.0 - API Client for the Clarifai API.  https://hackage.haskell.org/package/clarifai-0.2.0.0 (jcanero)
10:34:33 <lyxia> don't you need forall n. to bind the type variable?
10:34:38 <hackriledge> join.fmap where join is (++)
10:35:22 <hackriledge> Which does something funny with the dotted type
10:35:42 <hackriledge> Ok?
10:36:06 <hackriledge> I can almost see what it does
10:36:57 <hackriledge> Oh it turns it all from a to b
10:37:03 <hackriledge> !?!?!?
10:37:15 <hackriledge> How did that happen!?
10:38:02 <hackriledge> Because return creates type Nil b in my mind, maybe that's wrong
10:38:47 <hackriledge> I give up, what is going on here?
10:39:44 <hackriledge> :t join
10:39:46 <lambdabot> Monad m => m (m a) -> m a
10:41:55 <hackriledge> Firstly I'm not happy about creating monad instances for kind 3 things, so I'm going to parameterise with the dotted type b.
10:42:35 <hackriledge> Or a. Can't decide
10:43:15 <magr> @src break
10:43:15 <lambdabot> break p = span (not . p)
10:43:31 <hackriledge> (xplat|work) @let data DottedList a b = DNil b | DCons a (DottedList a b)
10:44:49 <drw_> how can I "read" the output from a command like this, without allowing the command to render output to the console?  :  (Just hin, Just hout, _, _) <- createProcess (shell completeCommand  ) { cwd = Just execDir }
10:46:13 <Jinxit> is it possible to combine two Lenses into a Traversal?
10:46:31 <hackriledge> I'm running our of battery can you cut to the chase?
10:47:09 <hiptobecubic> Isn't the chase the part that takes the longest?
10:48:45 <the_2nd> I have a "matrix" [[a]] and want to apply a function on each element
10:48:56 <the_2nd> but need to know the row and column within the function
10:49:28 <pranz> the_2nd: zip it with an index
10:49:34 <pranz> essentially
10:50:22 <the_2nd> zip [0..] $ map (zip [0..]) matrix
10:50:22 <pranz> zip [1..] (map (zip [1..]) matrix)
10:50:25 <the_2nd> something like this?
10:50:29 <the_2nd> okey :D
10:50:32 <pranz> yeah
10:51:01 <the_2nd> thanks
10:51:07 <pranz> no problem!
10:53:29 <hackriledge> :t ixmap
10:53:30 <lambdabot> (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
10:54:44 <the_2nd> pranz, damn
10:54:55 <the_2nd> this way not each A will know its both indexes
10:55:04 <the_2nd> only its column OR row
10:55:21 <the_2nd> and the row / column will know its index
10:55:29 <pranz> the_2nd: that's true
10:55:30 <the_2nd> but the single element will only be zipped with one index
10:56:07 <pranz> the_2nd: if you have the indexedMatrix as defined by the expression `zip [0..] $ map (zip [0..]) matrix`
10:57:41 <pranz> the_2nd: then`map (\(outerIndex, innerList) -> map (\(innerIndex, someA) -> (outerIndex, innerIndex, someA) innerList) indexedMatris`
10:58:09 <pranz> will move the outerindex into each individual list element
10:58:20 <the_2nd> I think I have another solution
10:58:28 <the_2nd> hm
10:59:08 <the_2nd> ah
11:01:59 <hackriledge> > let f = zip [1..] in (\x-> [[((i,j),y)|(j,(i,y))<-f a]|a<-f x])
11:02:01 <lambdabot>      Couldn't match expected type ‘[(t1, t)]’
11:02:01 <lambdabot>                  with actual type ‘(Integer, b)’
11:02:01 <lambdabot>      Relevant bindings include
11:02:17 <pranz> [(outerIndex, innerIndex, someA) | (outerIndex, innerList) <- indexedMatrix, (innerIndex, someA) <- innerList]
11:02:27 <pranz> the_2nd: can be expressed neatly with a list comprehension
11:02:53 <pranz> or with `do` notation
11:02:58 <pranz> similiarly
11:07:30 <Philonous> Is there a library like process that deals in ByteStrings rather than strings?
11:07:33 <hackriledge> Ok so I don't get hour the pattern matching on DottedList for defining bind is going to go down, can I get a hand?
11:07:51 <hackriledge> Data.ByteString
11:08:50 <hackriledge> Also perhaps the char versions
11:09:23 <Gurkenglas> http://pastebin.com/8X8MHbsV whaaa? cabal install used to work on that vm. What could cause this?
11:10:05 <bergmark> Philonous: you might want to check out one of the streaming io libraries, conduit, pipes, and io-streams
11:10:26 <hackriledge> (xplat|work) @let data DottedList a b = DNil b | DCons a (DottedList a b)
11:10:56 <bergmark> Gurkenglas: $PATH changed? the binary was removed?
11:11:01 <Philonous> bergmark, Ah, strange that there isn't a simpler library for that. But those wil do.
11:11:02 <Philonous> Thanks
11:11:24 <hackriledge> xplat|work, one question before my battery dies
11:11:42 <johnw> Philonous: http://hackage.haskell.org/package/process-extras-0.2.0/docs/System-Process-ByteString.html
11:12:02 <pikajude> isn't there a simple-conduit library?
11:12:09 <johnw> yes, there is :)
11:12:17 <johnw> but that URL was a more direct answer to his request
11:12:21 <hackriledge> Is there a difference between Free and Fix in the context of hylomorphosm on these structures?
11:13:05 <Gurkenglas> bergmark, either way "sudo apt-get install cabal-install" will fix it right?
11:14:12 <hackriledge> Johnw do you know?
11:14:19 <bergmark> Gurkenglas: unless PATH changed and you intalled cabal-install through apt-get last time as well...
11:14:28 <johnw> hackriledge: I haven't been following
11:15:17 <hackriledge> The difference between Fix and Free?
11:15:33 <johnw> xplat mentioned the differences multiple times
11:15:33 <hackriledge> Fix Either sorry
11:15:45 <johnw> Fix (Compose (Either a) f) == Free f a
11:15:52 <johnw> or rather, ≅
11:16:26 <hackriledge> What's Compose?
11:16:33 <johnw> functor composition
11:16:45 <johnw> newtype Compose f g a = Compose { getCompose :: f (g a) }
11:17:22 <hackriledge> Awesome, thanks so much
11:18:04 <hackriledge> Sup there are no differences
11:18:18 <hackriledge> So*
11:18:21 <hackriledge> ?
11:18:42 <johnw> I don't know what you're asking
11:19:14 <hackriledge> If they are isomorphic there are not any differences to observe
11:19:36 <johnw> that sounds right
11:19:58 <hackriledge> How does hylo know when to stop?
11:20:29 <johnw> :t hylo
11:20:31 <lambdabot> Not in scope: ‘hylo’
11:21:12 <hackriledge> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
11:21:42 <pikajude> johnw FYI you have some runaway italics in the simple-conduit haddocks
11:21:48 <johnw> pikajude: :(
11:22:00 <hackriledge> hylo phi psi = cata phi . ana psi
11:22:08 <pikajude> not a big deal, i just always notice them
11:22:31 <hackriledge> cata :: Functor f => (f a -> a) -> (Fix f -> a)
11:22:31 <johnw> hylo doesn't always know when to stop
11:22:45 <johnw> that depends on your choice of functor, and your choice of co/algebra
11:23:06 <the_2nd> pranz, I simply get length $ matrix or length $ (matrix !! 1) to know my rowsize, then zip [0..1] (concat matrix) and am fine, since I can calculate from the zip value and row/columnsize the real index
11:23:16 <johnw> however, thanks to laziness, it doesn't always need to stop
11:23:41 <hackriledge> My functor is a graph, join is told mappend
11:23:50 <hackriledge> fold*
11:24:34 <Gurkenglas> After reinstalling it: http://pastebin.com/dUJL5G9Z
11:24:35 * hackagebot composition 1.0.2.1 - Combinators for unorthodox function composition  https://hackage.haskell.org/package/composition-1.0.2.1 (DanBurton)
11:25:14 <hackriledge> Could we consider multiplication and division by two?
11:25:15 <pranz> the_2nd: yeah that's a pretty good solution too :) whatever fits your usecase best
11:25:34 <johnw> hackriledge: are you still talking to me?
11:25:38 <hackriledge> Yeah
11:26:09 <hackriledge> I'm trying to figure out how to stop an unfold
11:26:13 <johnw> I have no idea what you're saying; you keep throwing new information into this without context
11:26:30 <johnw> what does division have to do with graphs have to do with hylo have to do with Fix?
11:27:07 <hackriledge> I just gave hylo in terms of fix above
11:27:38 <hackriledge> Division was a converging iteration
11:29:07 <hackriledge> I figure, it will keep on unfolding until it reaches a fixed point at which the compiler must garbage collect it or something and send it on its way...
11:29:37 <hackriledge> If your lucky enough that it finds a fixed point
11:29:44 <hackriledge> Is that right?
11:29:53 <johnw> I have no idea, you'll have to try it out
11:30:06 <dalastboss> so I'm using parsec to parse a language, for some reason it's not ignoring whitespace properly
11:30:13 <dalastboss> like 5 * (3+4) errs
11:30:22 <dalastboss> but 5*(3+4) works
11:30:30 <johnw> what's your parser?
11:31:11 <dalastboss> I think these are the relevant portions
11:31:13 <dalastboss> http://pastebin.com/K5636H7K
11:31:19 <hackriledge> Please can someone help me learn how to use fix or free to make tractable a fixed point hylomorphosm :'(
11:31:44 <dalastboss> I can link the full source if thats not helpful
11:33:23 <pranz> dalastboss: well, nothing in that snippet specifies that you want whtiespace to be ignored
11:33:40 <pranz> dalastboss: if you always want whitespace to be ignored, why not just filter it away before you parse it?
11:33:49 <johnw> hackriledge: https://gist.github.com/4ba06764f27b90a7b868
11:34:11 <dalastboss> pranz: sounds like a good idea
11:34:31 <dalastboss> actually, no that would not quite work
11:34:31 <pranz> dalastboss: simplest solutions are often the best
11:34:34 <Gurkenglas> > hylo (either id id) (\(i, j) -> if i == 0 then Left j else Right (i-1, j+1)) (5, 5) -- hackriledge, something like this?
11:34:36 <lambdabot>  10
11:35:05 <dalastboss> like "let x = 3" is a contsruct i would want to support but it would incorrectly append x to let
11:35:37 <hackriledge> Yay! Thanks guys
11:36:27 <hackriledge> > Left 10
11:36:29 <pranz> dalastboss: that's true, but then filter anything you know is an actual expression
11:36:29 <lambdabot>  Left 10
11:37:20 <hackriledge> > either id id $ Left 10
11:37:22 <lambdabot>  10
11:37:36 <hackriledge> K I'm coo
11:38:11 <dalastboss> it gets dicey -- if i eventually introduce an if expression for example, then i'll be forced to require parens around the condition
11:38:34 <dalastboss> i think my best bet might be to do a tokenization pass before going into parsec
11:39:47 <pranz> dalastboss: probably wise since you want relatively complex expressions (binary operatorr)
11:40:17 <dhz_> ready for new year :D  http://s16.postimg.org/xhogpbk1v/image.jpg    http://s23.postimg.org/hdi9oiwex/image.jpg
11:42:30 <hackriledge> Can we write foldr using hylo?
11:42:43 <hackriledge> Or flap?
11:42:58 <hackriledge> fmap*
11:49:07 <the_2nd> I'll create a really easy fileformat
11:49:25 <the_2nd> I have a matrix of Tile  [[Tile]] which I want to store to file
11:49:48 <the_2nd> where Tile is data Tile = Grass | Water etc. ...
11:50:19 <the_2nd> each line in the file should be a [Tile] while the entire file represents the matrix
11:50:37 <the_2nd> and I want to custom map short definiers e.g. G => Grass 
11:50:54 <the_2nd> how can I write a parser for this?
11:51:27 <the_2nd> "GWG" => [[Grass, Water, Grass]]
11:52:15 <Gurkenglas> I just apt-get-installed cabal and am now getting this: http://pastebin.com/dUJL5G9Z
11:52:41 <Gurkenglas> cabal was already earlier installed but now stopped being a command the shell recognizes for some reason.
11:53:23 <geekosaur> that's not a shell error
11:53:50 <geekosaur> I would guess it mans either your existing ~/.cabal or the thing you are trying to install requires a newer cabal
11:54:36 <Gurkenglas> How old is "cabal-install version 1.16.0.2
11:54:36 <Gurkenglas> "?
11:56:00 <geekosaur> current is 1.22.7.0
11:56:31 <geekosaur> Uploaded	Wed Nov 7 05:16:50 UTC 2012 by JohanTibell
11:56:40 <geekosaur> (your version)
11:56:44 <Gurkenglas> I got this version by doing apt-get update and apt-get install cabal. How should I get the new one?
11:56:56 <geekosaur> yes, debianoids have a very old version
11:57:17 <geekosaur> if you;re on ubuntu or a derivative, sudo add-apt-repository ppa:hvr/ghc
11:57:46 <geekosaur> not sure offhand about debian
11:58:18 <msloma> on debian I used cabal to install the newest cabal
11:58:28 <Gurkenglas> It's ubuntu, did that, what now? apt-get install cabal-install doesn't do anything new
11:58:58 <geekosaur> right. hvr's avoid/can coexist with the main repo
11:59:46 <geekosaur> "sudo apt-get reload" to update the repo info, then sudo apt-get install cabal-install-1.22
12:00:14 <geekosaur> (with the version, yes, hvr's repo lets you install multiple versions side-by-side. they'll install under /opt)
12:00:42 <geekosaur> (you probably want to install ghc etc. from that repo too, since again debian's is old (7.6.3)
12:00:57 <geekosaur> https://launchpad.net/~hvr/+archive/ubuntu/ghc/+packages
12:02:43 <Gurkenglas> (I had this working a few hours ago, it can't be that complicated or I'd remember it...)
12:04:25 <Gurkenglas> I'll take this opportunity to switch to stack I guess
12:05:01 <the_2nd> I need something like "unwords" only without adding spaces. Just put the string next to one another
12:05:22 <pavonia> concat?
12:05:23 <jay6981> concat
12:05:48 <jay6981> :t concat
12:05:49 <lambdabot> Foldable t => t [a] -> [a]
12:09:11 <Gurkenglas> I have a folder with 3 .hs files, a folder full of .html files and a .txt file (The first .hs turns internet into the folder, the second .hs turns the folder into the .txt and the third .hs is to be used with ghci to extract different data each time from the .txt
12:09:33 <Gurkenglas> How should I get stack to make all that work the way I did using ghci up to now? Three projects?
12:11:26 <orion> How does one get their package accepted in to Stackage LTS (as opposed to just nightly)?
12:15:57 <Gurkenglas> http://pastebin.com/gSq1vj3h I guess this means it only wants projects passed to stack ghci?
12:17:03 <Gurkenglas> Ah stack exec ghci works for that. Can I automatically install all the packages it needs to ghci an .hs?
12:19:59 <the_2nd> any way to define the Tile -- Char relationship in one place, instead of having to define both directions? http://lpaste.net/2407376693221130240
12:23:50 <geekosaur> the_2nd, for just 5 of them I'd probably just do that. for a larger number there's at least one bimap on hackage (bidirectional map) and you'd write code to run through the map in the appropriate direction
12:26:37 <xplat|work> :t lookup
12:26:39 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:27:40 <xplat|work> you could use that along with 'map swap'
12:28:05 <pavonia> the_2nd: tileToString = toLower . head . show  (in that very specific case)
12:31:26 <xplat|work> or you could derive Enum and then you could define tileToChar t = "wgrps" !! fromEnum t and charToTile c = toEnum (findIndex c "wgrps")
12:31:32 <xplat|work> :t findIndex
12:31:34 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
12:31:59 <xplat|work> sorry, meant findIndex (c ==) "wgrps"
12:40:07 * hackagebot foldl-transduce 0.4.7.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.7.0 (DanielDiazCarrete)
12:42:57 <Philonous> Is there any particular reason that Data.HashSet doesn't export the HashSet / asMap functions?
12:52:11 <ReinH> Philonous: HashSet can't be constructed manually
12:52:42 <ReinH> invariants need to be maintained
12:54:06 <ReinH> oh you just mean the newtype wrapper/unwrapper
12:54:12 <Philonous> Yes
12:54:36 * ReinH shrugs
12:54:51 <Philonous> I'll open a pull request and see what happens
12:55:00 <Gurkenglas> Can I import the imports of a module into ghci even if the module doesn't compile? I want to check the types of some expressions in there to demystify a compile error
12:55:45 <geekosaur> :set -fdefer-type-errors ?
12:59:44 <Gurkenglas> Thanks. Which Control.Lens.TH keyword do I want for this http://lpaste.net/148166 ? makeFields? makePrisms?
13:00:53 <lisbeth> let every_three_letter_word = [ a:b:c[] | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z']]
13:01:36 <Gurkenglas> Missing a : between c and []. You could also write [a, b, c] there. Or just replicateM 3 ['a'..'z']
13:02:49 <xplat|work> let every_four_letter_word = [ "*$(&", "****", "#!@*", "%&#^"]
13:02:55 <lisbeth> doh, thanks Gurkenlas
13:19:42 <cocreature> can I give a kind signature for the result of a type family?
13:22:41 <cocreature> ah I can just use :: kind
13:36:19 <wedify> i find a have a lot of constructor functions that take no args. i've come to think of these as sort of "base" values and so i've written a class 'HasOne' whose method is 'one :: a'
13:36:38 <wedify> so for example instead of 'newWindow' i have 'one :: Window'
13:36:54 <wedify> i'm sure a concept like this already exists in haskell. what is it?
13:41:00 <Enigmagic> wedify: singletons does that, plus a bunch of other stuff
13:41:41 <Enigmagic> however it might not be exactly the same, depending on what newWindow was doing behind the scenes
13:43:48 <Enigmagic> wedify: the other possibility is data-default's Default
13:43:53 <arw> maybe also algebraic data types, where you might have something like TrivialThing | ThingWithStuff a
13:45:40 <StoneToad> if there's some composition operation it would be a monoid with mzero = newWindow and mappend = composewindowssomehow
13:47:15 <wedify> singletons package looks cool. 
13:48:05 <wedify> i think i'll stick with my class it's simpler than the suggestions. though maybe i should name it New to make it's meaning clearer
13:49:07 <Enigmagic> wedify: `def :: a` in Default is pretty much identical and has a bunch of users... doesn't do anything else
13:49:58 <Enigmagic> new might not be a great name either since the value is a constant :-)
13:50:11 <wedify> ok default is perfect
13:50:23 <wedify> yeah i renamed it to initial but i will use def instead
13:51:19 <exio4> well, considering Monoid is trivial if your type has a single unique constructor, mempty
13:53:58 <wedify> but what about mappend and mconcat? the functions on the base values do all sorts of things so they don't really fit
13:56:16 <wedify> some identifiers are too often used so i've just started using words from foreign languages. eg, instead of menu i'm writing valikko
13:56:37 <wedify> now i'm doing all my identifiers that way because it's fun
13:56:54 <wedify> so if you don't speak finnish i'm sorry :)
13:57:15 <wedify> i don't speak finnish either
13:58:33 <wedify> though so far the finnish words are longer than the english one
14:03:48 <tnks> danclien and I are together looking at this:  https://gist.github.com/ocharles/6b1b9440b3513a5e225e
14:04:19 <tnks> and we're wondering what benefit we'd possibly get using Free+Coproducts (data a 'la carte style)
14:04:23 <tnks> we're not seeing something.
14:11:01 * hackagebot lucid-svg 0.6.0.1 - DSL for SVG using lucid for HTML  https://hackage.haskell.org/package/lucid-svg-0.6.0.1 (jeffreyrosenbluth)
14:12:17 <StoneToad> wedify: just don't use chinese characters
14:12:25 <Welkin> WHAT!
14:12:31 <Welkin> always use chinese characters
14:12:32 <StoneToad> really annoying to read something and you end up with a character that you don't even know how to google search for
14:12:48 * StoneToad mutters about math paper pdfs picture equations...
14:12:58 <StoneToad> pdfs with*
14:13:09 <StoneToad> web pages too for that matter
14:13:19 <StoneToad> equations rendered to images in text is evil
14:15:26 <tommd> StoneToad: Detexify usually solves this issue for me.
14:16:30 <StoneToad> tommd: ooh nice link!
14:16:35 <StoneToad> err, reference?
14:17:18 <StoneToad> though I have a hunch that next time I use it I will curse trying to draw with a mouse, hehe
14:19:54 <ReinH> wedify: I don't see why that class would be useful
14:20:08 <ReinH> I have no idea what value ``one '' will give for an arbitrary type.
14:20:16 <ReinH> If I knew which value it was going to give, I could just use that value.
14:20:21 <ReinH> It has no laws.
14:21:16 <ReinH> writing `one' instead of (say) Nothing doesn't improve my code. It just hides my meaning behind unnecessary indirection.
14:22:45 <Welkin> misdirection
14:22:49 <Welkin> and deception
14:25:51 <ReinH> But if you're replacing words from a language you speak with words from a language you don't speak in your code then I guess we have pretty different ideas about readability
14:25:56 <nolraiU> Okay which Natural type is the one I should use?
14:26:17 <ReinH> I think readability probably means you should understand the words you use, for instance.
14:26:41 <nolraiU> Yeah, Default is not a good class.
14:27:36 <nolraiU> I find Reader or Maybe usually get me what I want, or named default values.
14:28:35 <superturrican1> a
14:32:18 <ackthet> good post
14:32:28 <wedify> ReinH: i see your point but the types i'm defining it for have obvious initial values
14:32:48 <wedify> i see newX, mkX, etc as redundant
14:33:27 <wedify> and i'm just using the foreign words in a hobby project. i'm finding it a fun way to pick up vocabulary from another language
14:34:22 <ReinH> wedify: why not just use the constructor?
14:34:51 <wedify> this is for records and types with a lot of fields
14:35:12 <ReinH> But you said "i find a have a lot of constructor functions that take no args."
14:35:21 <ReinH> So do they take lots of args or not?
14:35:45 <wedify> yeah they take no args. all the fields have sensible initial values
14:35:52 <ReinH> Uh
14:35:55 <ReinH> That statement contradicts itself.
14:36:01 * hackagebot HTTP 4000.2.23 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.2.23 (GaneshSittampalam)
14:36:19 <ReinH> If it has no args, it has no fields.
14:36:23 <ReinH> If it has fields, it does not have no args.
14:36:41 <wedify> the constructor has no args. the type has fields
14:36:51 <ReinH> Types don't have fields.
14:36:56 <ReinH> I don't understand.
14:36:59 <wedify> er, the data constructors
14:37:17 <ReinH> If a data constructor has args then it as fields
14:37:18 <ReinH> and vice versa
14:37:21 <ReinH> because they are the same thing
14:37:42 <ReinH> can you provide a concrete example?
14:38:24 <wedify> eg, in the game i'm writing i have menus that are associated with thier bitmaps and the polygons for collision detection with the options
14:38:53 <wedify> so i have a base menu menu {bitmap = Nothing, colliders=[]}
14:39:03 <ReinH> menu or Menu?
14:39:16 <wedify> menu = Menu sorry
14:39:20 <ReinH> Menu has both args and fields
14:39:27 <ReinH> it's Menu Nothing []
14:39:41 <ReinH> args and fields are the same thing
14:39:49 <wedify> yeah we agree on that
14:40:20 <ReinH> Well, I wasn't sure we did since you kept saying something else.
14:40:36 <tnks> in case anyone scrolls up, I think we answered our own question.
14:40:42 <ReinH> Do you want Data.Default?
14:40:58 <wedify> yeah that's what was suggested and what i've come to use
14:41:18 <wedify> i don't talk about code much with others so i need practise in being precise
14:41:27 <ReinH> if Menu forms a Monoid you get a more interesting concept of a default value
14:41:45 <ReinH> It forms one in a few obvious ways, but none of them are necessarily correct semantically
14:43:06 <wedify> there is no obvious mappend for these though. operations use field accessors to manipulate  the value in various ways
14:43:41 <ReinH> well, there are a few obvious ones from the type
14:45:23 <slack1256> Do somebody got a reference on the performance tradeoff free vs operational? I know they are isomorphic, but don't  know if the left-appending of free has at least a situations where it is neccesary
14:45:36 <slack1256> and how codensity (or yoneda) affects the performance of free
14:46:16 <ReinH> slack1256: look at the various papers that cover the codensity/yoneda trick and etc?
14:46:36 <ReinH> The difference is an asymptotic difference
14:47:05 <nolraiU> @hoogle Maybe () -> Bool
14:47:07 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
14:47:07 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
14:47:07 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
14:48:29 <slack1256> ReinH: I wanted to avoid reading papers and possibly know if somebody got a link to a mail caffe where the difference is discussed
15:06:51 <johnw> slack1256: there is a Church variant in the 'free' library
15:24:32 <greg`> is there an elegant way to apply a function to two arguments of a function
15:25:33 <MarcelineVQ> Not quite sure what you mean, you may be after `on` though
15:26:09 <greg`> ah will look, i want to get the second element of two tuples before applying to compare
15:26:20 <MarcelineVQ> ah then yes
15:26:53 <MarcelineVQ> :t compare`on`snd
15:26:54 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
15:28:11 <greg`> thanks
15:29:27 <HdMasta> 'on' is more general, but there's comparing function especially made for this
15:29:33 <HdMasta> :t comparing snd
15:29:34 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
15:46:30 * hackagebot morte 1.4.2 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.4.2 (GabrielGonzalez)
16:11:31 * hackagebot HTTP 4000.3.0 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.0 (GaneshSittampalam)
16:36:01 <JamesJRH> Happy new year!
16:37:39 <joco42> happy new haskell year !
16:37:44 <maerwald> hello my frieeends
16:39:09 <JamesJRH>  Λ 
16:39:09 <JamesJRH> \o/
16:39:09 <JamesJRH>  | 
16:39:09 <JamesJRH> \
16:39:31 <JamesJRH> Oops…
16:39:32 <JamesJRH>  Λ 
16:39:32 <JamesJRH> \o/
16:39:32 <JamesJRH>  | 
16:39:32 <JamesJRH> / \
16:39:35 <JamesJRH> :-D
16:40:00 <JamesJRH> joco42: Hey, like my party hat?! :-D
16:40:40 * JamesJRH dances around the room with a Lambda on his head… :-D
16:40:43 <joco42> yeah 2016 hat!
16:41:03 <JamesJRH> Oh?
16:41:20 <JamesJRH> I thought that it was U+039B… :-P
16:41:29 <dldl> JamesJRH: checkout #freenode-newyear
16:41:34 <joco42> 2016 closer to 2020 than to 2010
16:41:44 <dldl> (if you don't already know)
16:42:51 <JamesJRH> Happy new U+‖!!! :-]
16:43:24 <JamesJRH> dldl: Gosh no, I'm only wishing happy new year to those people and channels that matter to me. :-)
16:43:52 <dldl> :)
16:44:03 <JamesJRH> But I've spent too long doing this while I could be partying… :-/
16:44:18 <JamesJRH> It's 00:43:48, now. :-(
16:45:38 <JamesJRH> I need to automate this next year… maybe with some Haskell IRC stuff (see also: #haskell-irc).
16:46:00 <dldl> cool.  I was actually just considering starting a bot in python(boo).
16:46:15 <JamesJRH> Heh, lol. :-P
16:46:24 <JamesJRH> Anyway, afk.! :-)
16:49:09 <geekosaur> (I should install THE for old times' sake, unfortunately my rexx has probably bitrotted beyond usefulness)
16:52:39 <geekosaur> oh whoops, mischan
17:14:29 <irneh> I have a list of lists and would like to print each element of each sublist on one line and separate each sublist with a newline. I have this but don't know if there's a way to inject a newline. > mapM_ (mapM (printf "%4d")) [[1,1], [2,222]]
17:16:57 <hiptobecubic> irneh, instead of mapping in the IO monad, just use regular map to get strings, then concat them and print them as needed
17:17:32 <Welkin> yeah, always do as much as possible outside of IO
17:18:37 <irneh> Like the the sound of that @welkin. New to this. Thanks @hip; looked at concat earlier. Heading back into it now.
17:19:57 <hiptobecubic> irneh, note that printf will give you a string if you need one
17:20:35 <irneh> Yeah. Newbie but saw that it gives String and/or IO.
17:20:45 <hiptobecubic> OK I won't spoil it then :)
17:21:06 <hiptobecubic> > printf "%4d" 2 :: String
17:21:08 <lambdabot>  "   2"
17:29:07 <achernyak> irneh, also take a look at concatMap might be really useful for this
17:30:12 <achernyak> also putStrLn can be used to print things on a new line
17:30:54 <Welkin> putinStrLn
17:31:06 <Welkin> in russia, line putins you!
17:31:44 <achernyak> putin would never use an StrLn
17:32:02 <irneh> Agree about concatMap. Been away from Haskell for a couple years and am trying to do a hobby program without relearning the core and finding that's the wrong approach. Like when I thought it was OK to skip a page or two of The Little Schemer and move ahead.
17:32:26 <achernyak> haha you were really close to the right track
17:32:35 <achernyak> did you get it to work btw?
17:33:02 <xpilot> anyone here ever encounter "files missing in package" errors on cabal install?
17:35:56 <xpilot> cabal install is giving me errors of the form "could not find module Text.Parse" - I can import Text.Parse just fine in ghci though
17:36:04 <Welkin> xpilot: try repairing them with ghc-pkg
17:36:16 <Gurkenglas> http://lpaste.net/148173 <- Looks like I don't quite yet understand zoom yet. Help with writing that findDcs function at line 86?
17:36:22 <Welkin> ghc-pkg check
17:36:22 <xpilot> ghc-pkg check doesn't say anything is wrong
17:36:42 <Welkin> xpilot: oh
17:36:50 <Welkin> xiaolin: you forgot yto add it to your .cabal file
17:36:59 <Welkin> add it in your build-depends
17:37:08 <irneh> achemyak: Not yet. No rush. New Year's Eve my time zone. Decide to settle in an re-learn rather than arbitrarily solve.
17:37:32 <Gurkenglas> "zoom headways $ StateT $ partitionM (const [False, True])" is supposed to nondeterministically take a subset of the headways list (leaving the remainder in place)
17:39:05 <Welkin> it's new year's eve here too
17:39:28 <Gurkenglas> Oh wait I see now, once I've zoomed into "dcs . ix topic" in line 88 "headways" is not available anymore in line 94, grr shoulda asked the rubber duck
17:39:35 <Welkin> I will ring in the new year watching the monkey king fly about playing pranks
17:39:49 <Welkin> Gurkenglas: you just did
17:44:43 <dldl> ghc is print \r s
17:44:55 <achernyak> irneh, here is a version that will let you keep your function monadic the way you wanted. since concatMap is only for lists.
17:44:56 <achernyak> mapM_ putStrLn . (=<<) (fmap show) $ [[1,1],[2,222]]
17:45:22 <dldl> how do I get ghc to print unix newlines?
17:45:57 <Welkin> putStrLn
17:46:10 <rumia> how to host your own instance of lambdabot? I tried many times and it always fails with strange errors.
17:46:10 <dldl> thanks
17:46:14 <dldl> just thought og that
17:46:39 <achernyak> was this the second question in like 20 minutes about putStrLn :)
17:46:49 <rumia> (too many 's' T_T)
18:41:37 * hackagebot phoityne 0.0.2.0 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.2.0 (phoityne_hs)
18:53:28 <Ankhers> Is it possible to create a function that takes a data type as a variable for the purposes of type checking? http://lpaste.net/148174 is what I want to accomplish, maybe there is a better way? Warning, pseudo code.
18:59:13 <dxld> Ankhers: anything wrong with just putting the Foo and Bar constructors into a sum type?
18:59:53 <Ankhers> dxld: I have about 10 distinct types I need to do this with. I would prefer they not be the "same" type.
19:00:31 <Welkin> Ankhers: phantom newtypes?
19:00:50 <Welkin> oh nevermind
19:01:23 <Ankhers> Welkin: I'm unfamiliar with phantom types.
19:01:54 <dxld> I was also thinking GADTs + phantom type argument but since you want to put it in an alist the phantom tag would have to be the same for every element
19:02:27 <Ankhers> It isn't required to be put in a list. It is just a way I thought of.
19:03:03 <dxld> well any polymorphic container type has the same limitation really
19:03:09 <Ankhers> If there is some other way of doing it, I am open. I just didn't want to create a different function for each type doing the exact same thing.
19:03:44 <dxld> what is it you're doing to those types exactly
19:03:53 <dxld> a simple type class might be the way to go
19:05:41 <Ankhers> I have a series of CSV files that I need to parse. I then want to place the parsed data into a database, because reading a CSV file every request (web) takes too long. I was hoping for a way of letting the type system know the "type" of each file after it has been parsed, so I can just insert it into the database using persistent and it would know where everything goes.
19:06:07 <Ankhers> "where everything goes" meaning it would have type data and be able to place the data into the correct table.
19:06:14 <jle`> do you mean that you want the type of your data to depend on values not known until runtime?
19:06:41 <Ankhers> jle`: They are technically known. I plan on parsing in a certain order.
19:07:49 <Ankhers> I could just have a series of `let foos = decodeCSV fooCSV :: Vector (Vector Foo); let bars = decodeCSV barCSV :: Vector (Vector Bar)'
19:07:57 <Ankhers> But I was hoping to avoid that.
19:09:53 <jle`> you could do something with HLists/type level tuples and asTypeOf, if you have a lot of them
19:10:05 <jle`> if i understand what you're doing properly
19:10:10 <jle`> *type level lists
19:12:18 <Ankhers> jle`: I will take a look at those. For now, I guess I will just implement the long way. Thanks.
19:13:18 <jle`> you can write a CSV instance for https://hackage.haskell.org/package/type-combinators-0.2.0.0/docs/Data-Type-Product.html
19:14:02 <jle`> or, use the Traversal' instance for it
19:14:32 <jle`> and then parse it all into a Prod Vector [Vector Foo, Vector Bar, Vector Baz...]
19:14:53 <jle`> and then pattern match out the individual ones you'd want
19:15:10 <Ankhers> jle`: Thanks. I will take a look at that.
19:37:16 <jaarod-> hi. how do you run a website that is made with haskell/Yesod? from what I understand you need a dedicated server, which is more expensive than just getting a server that support php (almost all of them) or ruby/python (some of them). is that correct?
19:47:03 <pdxleif> jaarod-: You can run your app on Heroku or something for free, I think.
19:47:23 <pdxleif> I pay about $5 / month for my VPS on Amazon to host my stuff.
19:48:04 <jaarod-> $5 a month? for a dedicated server?
19:48:27 <pdxleif> Yep. I signed up for a long-term contract
19:49:09 <pdxleif> But that prices is normal for a dedicated server - you can get one on Digital Ocean for that much.
19:49:33 <mniip> so is it a VPS or dedicated?
19:49:49 <mniip> a dedicated VPS is an oxymorron
19:49:52 <pdxleif> If you want to use shared hosting, Yesod apps are built on WAI, which offers a number of drivers, e.g. its own server, CGI, FastCGI, ... http://www.yesodweb.com/book/web-application-interface
19:50:14 <pdxleif> mniip: I don't understand what you're asking.
19:50:35 <pdxleif> It's a virtualized instance, if that's what you're asking.
19:50:43 <mniip> so it's /not/ dedicated
19:50:56 <pdxleif> The hardware is not dedicated, no.
19:51:08 <pdxleif> I think jaarod- was using that term to differentiate from shared hosting.
19:51:38 <mniip> a dedicated server, in context of hosting, usually means a hardware server fully dedicated to a client
19:51:47 <pdxleif> true enough
19:52:10 <pdxleif> And that's not necessary at all to run a Yesod app.
19:56:18 <jaarod-> i think he was just using loose definition of dedicated (because i was).. anyway $5 is great
20:08:31 <pdxleif> https://haskellonheroku.com/ might be nice for getting started.
20:23:49 <jaarod-> i'll check it out thanks
20:24:19 <zaquest> Ankhers, i don't understand a thing in type-foo but once while reading source code of lambda bot iirc i found out about dependent-sum package. idea taken from there http://lpaste.net/148175 not sure if it's helpful though
20:28:59 <Ankhers> zaquest: Thanks. I'll take a quick look at that. 
21:35:01 <athan> Hi everyone, I've probably asked this at least 10 times, but how can a homomorphism be represented in type theory?
21:35:25 <Cale> What kind of homomorphism?
21:36:09 <athan> Wouldn't it be something like `(f : a -> a) is homomorphic over (g : a -> a -> c) iff. f (x `g` y) === (f x) `g` (f y)
21:36:17 <Cale> hm?
21:36:37 <athan> Cale: Is there a specifically defined general concept?
21:36:41 <Cale> You need to say which sort of structures you're working with in order to say what a homomorphism is.
21:36:55 <Cale> It's defined differently for different sorts of algebraic structures.
21:37:20 <athan> Cale: Would mine be considered an example of one?
21:37:46 <Cale> Yeah, I guess that's a magma homomorphism or something.
21:37:49 <athan> or is function composition an example?
21:37:54 <athan> ahh okay!
21:38:04 <athan> er shoot
21:38:24 <athan> wouldn't definitions themselves be homomorphisms?
21:38:27 <Cale> uh
21:38:28 <athan> haha
21:38:30 <athan> sorry
21:38:33 <Cale> except your thing is specialised further
21:38:43 <Cale> Normally you'd have two different g's
21:39:13 <Cale> So I guess it's an automorphism of a magma on the type a
21:39:41 <athan> Cale: That makes a lot of sense
21:40:32 <athan> hmm... and it's a homomorphism would only be in one direction, too
21:40:48 <athan> wow
21:40:59 <athan> okay I'm going to need to stew, thank you Cale!
21:45:26 <athan> or really, it would have commutative function composition
21:45:48 <athan> so f (g x) ==> g1 (f x)
21:58:30 <Bruuuuno> I need to read a binary file, but they use an 15 bits encoding, what would be the best approach? I was thinking of reading the data as Word8 then map each word to a list of bool, but there as to be a cleaner way
22:06:49 <pavolzetor> http://lpaste.net/148179
22:06:53 <pavolzetor> I am trying to understand this
22:07:07 <pavolzetor> I have tested adding deepseq on trace function
22:07:21 <pavolzetor> i.e. let x = trace ray in x `deepseq` x
22:07:25 <pavolzetor> but that did not help
22:07:36 <pavolzetor> the pixels are strict
22:08:01 <pavolzetor> so I thought it will stream rays with lazy evaluation and shade them, write them and do deallocation
22:11:29 <pavolzetor> however it seems like it builds up the whole list first
22:14:07 <pavolzetor> hmm, interesting, if I use writeArray in ST monad it does not do this
22:16:25 <pavolzetor> I suspect that when I call Vector.fromList it will read all rays to figure out what is its length and allocate all the memory
22:16:56 <pavolzetor> which is okay if it would reduce the trace function
22:22:13 <wedens> is there some "haskell performane guide" with common pitfalls, general practices, etc?
22:23:03 <dmj`> wedens: there was somewhat recently a blog post series on it
22:23:04 <dmj`> https://www.reddit.com/r/haskell/comments/3urjm3/a_series_about_optimization/
22:24:36 <wedens> dmj`: thanks
22:27:05 <athan> @tell pavolzetor you could use `force` instead of `\x -> x `deepseq` x`!
22:27:06 <lambdabot> Consider it noted.
22:29:17 <bob_twinkles> Does anyone have a good writeup on Impredicative/RankN types?
22:30:27 <bob_twinkles> I can't quite grok what the difference between (forall a. [a] -> Int) -> Int and (forall a. [a] -> Int) -> Int is
22:30:41 <bob_twinkles> and why (return . runST) won't compile without ImpredicativeTypes
22:42:00 <lispy> bob_twinkles: it looks like you wrote the same type twice
22:42:08 <lispy> bob_twinkles: Do you know rank2 types?
22:45:17 <bob_twinkles> lispy: oops, copy paste fail
22:45:22 <bob_twinkles> lispy: I'm not familiar, no
22:46:14 <bob_twinkles> second type was meant to be forall a. ([a] -> Int) -> Int
22:46:47 <lispy> bob_twinkles: the first thing to understand here is rank2 types
22:47:34 <lispy> bob_twinkles: a normal haskell type, like identity is like a -> a, which really means forall a. a -> a, and the precedence is like forall a. (a -> a), meaning the forall is on the outside
22:47:41 <lispy> So you pick an a, and then you have a -> a
22:48:16 <lispy> If you were to change the precedence, (forall a. a) -> a, then now the a's aren't the same
22:48:48 <bob_twinkles> makes sense
22:48:59 <lispy> That one would actually be forall a. (forall b. b) -> a, here I renamed the inner a to b to be more clear
22:49:21 <athan> bob_twinkles: Listen to lispy! First learn Rank2 / existential quantification. Then learn rank n. Impredicative types just allow you to use the variable in arbitrary polymorphic types, like lists
22:49:53 <athan> bob_twinkles: vanilla Haskell / HM-types / prenex-polymorphism could be considered rank-1
22:50:07 <lispy> yeah, in haskell impredicative means forall can appear 'under' any type constructor. In rank2 types, the forall is appearing 'under' a function type constructor
22:50:29 <bob_twinkles> ah
22:50:37 <lispy> forall a. (a -> a) is like forall a. (->) a a
22:50:56 <lispy> The tricky bits come from the way the theory works when you start doing this stuff.
22:51:35 <lispy> going back to the example with a and b
22:52:03 <lispy> When you write forall a b. a -> b, you can think of the caller as choosing b
22:52:29 <lispy> But when it's forall a. (forall b. b) -> a, who chooses b?
22:53:04 <lispy> viewed from the outside, it's sort of like there is a type b, but we don't know what it is because (forall b. b) works for all types.
22:53:25 <lispy> It exists and that's all we know.
22:53:39 <bob_twinkles> compuer had a sad right there, sorry
22:53:52 <bob_twinkles> the last message I got was "The tricky bits.... "
22:53:53 <lispy> ah, I didn't notice because I have joins/parts disabled :)
22:54:10 <bob_twinkles> heh
22:54:21 <bob_twinkles> oh, there's a log
22:54:51 <lispy> I was just poorly explaining the implications of having the nested forall
22:55:22 <lispy> There are two directions to take this explanation a) the implications b) how type checking changes
22:55:52 <lispy> the implications are probably a bit easier to spew out. Type checking becomes much harder as you switch to rank2 and up
22:56:30 <bob_twinkles> implications sounds like a good foundation
22:56:41 <lispy> (rank2 means you can nest a forall 1 time, and rankn means you can nest it as deeply as you want)
22:57:15 <bob_twinkles> ah
22:57:17 <lispy> Actually, I was being sloppy. I should say type inference becomes harder
22:57:59 <bob_twinkles> so if you have some function f g = (g 1) + (g "science")
22:58:09 <bob_twinkles> you can only write the type signature for that using Rank2
22:58:15 <athan> lispy: Oh crap! I feel silly now, so an Impredicative type would be something like `[forall a. a]`?
22:58:28 <lispy> athan: yeah
22:58:36 <bob_twinkles> since without it there's no way to specify that g *must* take both [Char] and (Num a)
22:59:19 <lispy> bob_twinkles: you can think of rankn types as making it so functions can take polymorphic things as arguments
23:00:00 <bob_twinkles> like Rank2 in type constructors?
23:00:35 <bob_twinkles> or wait, that's the example for Impredicative
23:00:37 <lispy> That type you had earlier, (forall a. [a] -> Int) -> Int. The first argument is a polymorphic function
23:01:33 <bob_twinkles> yeah. So you can write that with just Rank2 right?
23:02:11 <lispy> yup
23:02:54 <bob_twinkles> so RankN is for when you need functions that take polymorphic functions that take polymorphic functions
23:03:15 <lispy> Imagine we write (->) in prefix form. that type, (forall a. [a] -> Int) -> Int, becomes (->) (forall a. (->) a Int) Int
23:03:21 <lispy> yup
23:03:22 <lispy> exactly
23:03:48 <lispy> Notice when we write it in this prefix form, that you have a forall inside the function type constuctor
23:03:48 <bob_twinkles> that sounds like you've wandered down an... interesting path for your architecture
23:04:29 <lispy> And if you want to do this for ANY type constructor instead of just function types, you call it impredicative types
23:04:57 <lispy> type inference gets weird
23:05:11 <lispy> so ghc puts restrictions on it like requiring type signatures
23:06:18 <bob_twinkles> because it becomes easy to write types that take GHC a really really long time to derive?
23:06:57 <athan> lispy: agh jeez, sorry
23:07:51 <lispy> athan: no worries
23:08:05 <lispy> bob_twinkles: it's more like it can't read your mind
23:08:10 <julianleviston> Is there a story for Haskell WRT gradual typing? I can’t imagine there is, but I’m interested.
23:08:28 <julianleviston> Reading this paper, which is quite fascinating: https://sage.soe.ucsc.edu/sage-tr.pdf
23:08:42 <lispy> julianleviston: I don't really see how you would apply it? You want to be able to leave out types?
23:08:49 <julianleviston> uses something called “unified hybrid checking”
23:08:51 <bob_twinkles> lispy: darn. Is that coming for 8.0? =P
23:08:59 <lispy> julianleviston: for haskell2010 we have principal types
23:09:16 <bob_twinkles> thanks for walking me through that
23:09:39 <athan> could contravariance be described as "inverting the _image_ of an injection"?
23:09:42 <lispy> bob_twinkles: you're welcome. I'd still recommend reading about it from other sources. There are a lot of subtlties
23:09:42 <julianleviston> lispy: I’d like changing data structure to not break code necessarily.
23:09:50 <athan> where inversion is defined s.t. `- (- a) == a`?
23:10:36 <julianleviston> lispy: do you have any reading references about principal types?
23:11:09 <bob_twinkles> lispy: I'm sure there are. I need to get a better handle on how Haskell derives types in general
23:11:31 <bob_twinkles> for now though, it's a bit late here so I'm off to bed
23:12:29 <lispy> julianleviston: anything about HM type inference or algorithm w will have to talk about them
23:12:44 <lispy> julianleviston: it's just a fancy way of saying we can uniquely infer a most general type
23:12:55 <julianleviston> lispy: this is about the decidability of types right?
23:12:55 <julianleviston> yeah
23:12:58 <julianleviston> lispy: ok
23:14:01 <julianleviston> lispy: but I’m talking about if you change the type of something, but it has the same shape as before, your code should still be able to work with the data… kind of like duck typing… 
23:14:10 <julianleviston> lispy: but it’s definitely NOT duck typing.
23:14:50 <julianleviston> lispy: it also lets you impose constraints on data, too… because it’s hybrid. (So, for example, you could have a positive integer constraint)
23:15:04 <julianleviston> … using runtime checks
23:15:46 <lispy> julianleviston: ah, that's different than how I've thought about gradual types before
23:16:07 <julianleviston> lispy: it’s pretty much about taking the best of both static and dynamic languages...
23:16:13 <lispy> I've seen them as a way to not have to be strongly typed everywhere
23:17:01 <julianleviston> lispy: this partially complete paper by Erik Meijer (and Peter Drayton) is really interesting: https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/rdl04meijer.pdf
23:17:56 <lispy> julianleviston: you would probably be interested in structural type systems
23:18:00 <julianleviston> lispy: seems like a really positive step in the direction of the unification of both “diametrically opposites”. I was interested if any further ongoing work has taken place around this, and I thought Haskell would probably be the place where it would take place.
23:18:18 <julianleviston> lispy: what languages use such a system?
23:19:00 <julianleviston> Oh… OCaml. Cool. Yeah I was pretty impressed by OCaml, but there were… problems...
23:21:20 <julianleviston> lispy: I’m left with “How many times am I going to rewrite my system before I’ll actually be able to pull it off” :)
23:40:08 <lisbeth> sprunge.us/YiPc
23:40:24 <lisbeth> type error
23:41:41 <MarcelineVQ> :t putStrLn
23:41:43 <lambdabot> String -> IO ()
23:41:54 <MarcelineVQ> String == [Char]
23:42:00 <MarcelineVQ> :t [ a:b:c:[] | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z']]
23:42:01 <lambdabot> [[Char]]
23:42:02 <julianleviston> wasn’t that a String?
23:42:06 <julianleviston> Ahhh
23:42:35 <lisbeth> Is there a put [[char]] line?
23:42:36 <julianleviston> :t conccat
23:42:38 <lambdabot>     Not in scope: ‘conccat’
23:42:38 <lambdabot>     Perhaps you meant one of these:
23:42:38 <lambdabot>       ‘concat’ (imported from Data.List),
23:42:43 <julianleviston> :t concat
23:42:44 <lambdabot> Foldable t => t [a] -> [a]
23:43:06 <julianleviston> lisbeth: if you wack a concat $ in front of the comprehension, it’ll prolly fix it for you :)
23:43:19 <MarcelineVQ> You can concat it if you want it in one line, but you can also use mapM_ putStrLn to place each result on a line
23:43:25 <julianleviston> sorry a $ concat
23:45:01 <lisbeth> sprunge.us/HOEj
23:46:29 <julianleviston> lisbeth: sorry…. putStrLn $ concat [ a:b:c:[] | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z']]
23:46:54 <julianleviston> lisbeth:  the $ applies the result of the concat to the putStrLn
23:47:20 <julianleviston> lisbeth: (same effect as wrapping everything after putStrLn in parens.
23:47:21 <MarcelineVQ> kinda, it just changes the parsing order
23:47:42 <julianleviston> MarcelineVQ: Hm… that’s not my experience with it!
23:47:51 <julianleviston> MarcelineVQ: there are places you can’t use $, for example.
23:48:07 <julianleviston> :t ($)
23:48:09 <lambdabot> (a -> b) -> a -> b
23:48:18 <julianleviston> MarcelineVQ: it’s a function, right?
23:50:08 <MarcelineVQ> That's fair, I didn't mean it was a parsing mechanic directly, but its effect is to change the parsing order. I wouldn't personally say it applies the result of anything to anything else. It might not be a point of view difference that matters though
23:51:08 <MarcelineVQ> Certainly it can be used to apply things though, such as a common use with mapping a list of functions
23:51:14 <julianleviston> MarcelineVQ: Strict (call-by-value) application operator. It takes a function and an argument, evaluates the argument to weak head normal form (WHNF), then calls the function with that value.
23:51:38 <julianleviston> MarcelineVQ: it *does not* therefore work when you don’t have a function to the left of the operator, right?
23:52:27 <MarcelineVQ> !$ isn't $
23:52:47 <julianleviston> MarcelineVQ: sorry :)
23:53:11 <julianleviston> MarcelineVQ: same thing applies though… you need a function on the left.
23:53:30 <MarcelineVQ> You do
23:53:39 <julianleviston> MarcelineVQ: I find this quite important to point out because if you just say it’s a precedence-changer, then it carries slightly different sematics.
23:53:49 <julianleviston> MarcelineVQ: but all good.
23:53:54 <Xnuk> :t (!$)
23:53:56 <lambdabot>     Not in scope: ‘!$’
23:53:56 <lambdabot>     Perhaps you meant one of these:
23:53:56 <lambdabot>       ‘$!’ (imported from Prelude),
23:54:13 <julianleviston> :t ($!)
23:54:14 <lambdabot> (a -> b) -> a -> b
23:54:15 <julianleviston> this?
23:54:24 <MarcelineVQ> Alright. It is though.
23:54:43 <julianleviston> MarcelineVQ: Sorry - wasn’t correcting you there, just helping Xnuk.
23:54:50 <MarcelineVQ> Fair enough :>
23:56:03 <julianleviston> what’s a monomorphism restriction?
23:58:41 <MarcelineVQ> Haskell wiki covers that with more grace than I could https://wiki.haskell.org/Monomorphism_restriction
23:58:51 <julianleviston> MarcelineVQ: legendary! thanks :)
