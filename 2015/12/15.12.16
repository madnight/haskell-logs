00:59:18 <quchen> We need parametricity code fuzzing testing. The program would randomly grow and be tested against a spec, until the test works.
01:05:54 <merijn> quchen: Yes, I thought about writing something like this named FuckIt.hs, the Haskell equivalent of FuckIt.js and FuckIt.py :p
01:06:48 <merijn> quchen: See https://github.com/mattdiamond/fuckitjs and https://github.com/ajalt/fuckitpy
01:06:48 <quchen> merijn: It would be CoFuckit.hs, because it takes a broken program and fills it up until it works properly
01:12:13 <mauke`0> quchen: neural networks, genetic programming?
01:14:37 <merijn> I don't see how you'd use neural networks for generating programs
01:16:11 <jle`> hey, is there any reason why i don't see a "delete" function as a part of the Data.Vector interface
01:16:17 <mauke`0> I know nothing about neural networks but I hear you train them until they pass a test
01:16:35 <jle`> i'd have to splitAt and then head and then concat
01:16:38 <mauke`0> aren't vectors fixed-length structures?
01:16:41 <pyon> jle`: Aren't vectors supposed to be of fixed length?
01:16:41 <jle`> which is probably what a 'delete' would do anyways
01:16:54 <jle`> yeah, but it has (++), tail, drop, etc.
01:17:37 <jle`> it could be implemented with a splitAt and tail, but, i always thought the `vector` package was supposed to be array with nice wrappers/API for things like this
01:17:56 <merijn> mauke`0: Neural networks are used to train a neural network against a set of known input output pairs
01:18:05 <merijn> Whereas you wanna construct a valid input from nothing here
01:18:10 <jle`> i don't mind that it's inefficient...just having a wrapper over a commonly used thing would be nice v.v
01:19:01 <pyon> Perhaps the idea is that, because it's inefficient, you might not want to use it so casually. :-p
01:20:59 <jle`> yeah but, all it's going to do is cause people to write their own individual potentially buggy versions for every project ;_;
01:21:21 <MarcelineVQ> jle`: Now's your chance, write the best version and submit it :>
01:21:52 <jle`> vector is a part of the core libraries, i think...contributing to those is scary ;_;
01:22:04 <jle`> you have to get past the old guard
01:25:35 * hackagebot concurrent-extra 0.7.0.10 - Extra concurrency primitives  https://hackage.haskell.org/package/concurrent-extra-0.7.0.10 (BasVanDijk)
01:31:31 <merijn> Is there an extension that allows you to write integers with seperators?
01:31:44 <merijn> i.e. 1_000_000 being 1000000
01:32:31 <bitemyapp> merijn: think I've seen that before.
01:32:36 <bitemyapp> somewhere.
01:32:47 <merijn> I know some languages have that, I just dunno is haskell does :p
01:32:47 <bitemyapp> but I don't think it was an extension, I think it was QQ/TH.
01:32:55 <mauke`0> (it's in perl)
01:33:12 <merijn> If not we really need that :p
01:34:57 <mauke`0> :t 1e6
01:34:58 <lambdabot> Fractional a => a
01:35:06 <mauke`0> there's a language extension to make that Num a
01:35:11 <merijn> Yeah
01:35:33 <merijn> But that doesn't work as wel for less perfect numbers like 1265947
01:35:36 <mauke`0> yeah
01:36:00 <mauke`0> or 0x100f_00a2
01:36:02 <MarceColl> is that for clarity?
01:37:12 <quicksilver> merijn: read . filter (not isSpace) $ "1 265 947" 
01:37:37 <merijn> quicksilver: ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
01:37:56 <quicksilver> is that an emoticon of four hyenas?
01:37:59 <quicksilver> because it's freaking me out.
01:38:43 <mauke`0> >not isSpace
01:38:54 <quicksilver> not.isSpace, sorry
01:39:02 <quicksilver> should test code before pasting
01:39:20 <merijn> quicksilver: It's the generic "look of disapproval" emoticon
01:39:27 <mauke`0> > read . filter isDigit $ "1`265`947"
01:39:29 <lambdabot>  *Exception: Prelude.read: no parse
01:39:48 <aanastasov> How do I paste multiline code?
01:40:13 <mauke`0> see /topic
01:40:31 <MarcelineVQ> @where lpaste
01:40:31 <lambdabot> http://lpaste.net/
01:40:48 <quicksilver> merijn: my point is that if you have a quantity of static data you can get quite a long way with strings/tuples and an ad-hoc parse
01:41:14 <lpaste_> aanastasov pasted “what is the problem” at http://lpaste.net/147161
01:41:25 <quicksilver> mybignums :: [Int]; mybignums = map parse ["1 234 567","81 444 888", "203 818 222"]
01:41:55 <quicksilver> in the paste I've used that for things like lists of command names + their implementation function + their help strings + their key shortcuts
01:42:01 <quicksilver> s/paste/past/;
01:42:02 <merijn> quicksilver: I'm quickly typing numbers into GHCi and/or scripts and changing them a lot
01:42:13 <merijn> quicksilver: So using read is quite an annoying hassle
01:42:15 <lpaste_> aanastasov revised “what is the problem”: “No title” at http://lpaste.net/147161
01:43:15 <quicksilver> merijn: p"1 234 567" doesn't seem a big hassle to me
01:43:23 <quicksilver> where p is some parsing function.
01:43:33 <quicksilver> (possibly it's read . filter isDigit)
01:43:43 <quicksilver> it seems mildly inelegant. but not a big hassle.
01:44:13 <danza> maybe it would be easier to use an order of magnitude with some dimensional lib
01:44:22 <danza> for example, 1k, 1m, etcetera
01:44:31 <quicksilver> danza: he could just use scientific notation but his numbers aren't round.
01:44:31 <aanastasov> Can anyone spot the problem in  http://lpaste.net/147161? I get Non-exhaustive patterns in function parseError when I try to execute the code
01:44:37 <merijn> danza: That only works for round numbers
01:44:51 <danza> 1,234k?
01:45:01 <danza> oh, sorry, 1.234k
01:45:43 <quicksilver> aanastasov: typo
01:45:55 <quicksilver> aanastasov: parseErorr instead of parseError
01:45:57 <danza> i see ... when the number of digits is big, the problem is the same ... for example 3.3455456m
01:46:20 <quicksilver> aanastasov: but don't use (try (evaluate (read str)))
01:46:32 <quicksilver> aanastasov: IO exceptions are a horrendous way to handle read errors.
01:46:47 <aanastasov> quicksilver: how would you do that 
01:47:09 <aanastasov> quicksilver: i wanted to use Maybe
01:47:18 <quicksilver> aanastasov: readMaybe
01:47:29 <quicksilver> > readMaybe "aaa" :: Maybe Int
01:47:30 <lambdabot>  Not in scope: ‘readMaybe’
01:47:43 <quicksilver> it's in Text.Read
01:47:49 <quicksilver> why is it not in scope for lambdabot?
01:47:59 <quicksilver> > Text.Read.readMaybe "aaa" :: Maybe Int
01:48:01 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
01:48:15 <mauke`0> @let import Text.Read (readMaybe)
01:48:16 <lambdabot>  Defined.
01:48:19 <aanastasov> quicksilver: thanks
01:48:22 <mauke`0> > readMaybe "aaa" :: Maybe Int
01:48:24 <lambdabot>  Nothing
01:48:27 <quicksilver> thanks mauke`0 :)
01:48:37 <mauke`0> you could also use reads
01:48:42 <mauke`0> but the interface is more annoying
01:48:43 * quicksilver nods
01:48:53 <quicksilver> aanastasov: but the actual reason for your error was the typo
01:48:58 <quicksilver> Error /= Erorr
01:49:03 <aanastasov> quicksilver: yeah, i noticed
01:49:17 <mauke`0> if you're using vim, * is your friend
01:49:22 <mauke`0> (with hlsearch)
01:49:38 <aanastasov> quicksilver: for some reason, I assumed that the compiler would have complained for that error
01:50:46 <cocreature> aanastasov: if you compile with -Wall and -Werror non-exhaustive patterns become a compile time error
01:52:15 <aanastasov> cocreature: is there a way to enable those switched for ghci
01:52:58 <cocreature> :set -Wall
01:53:03 <mauke`0> probably ghci -Wall -Werror
01:53:14 <cocreature> and the same for Werror if you want an error instead of only a warning
02:03:35 <fnord__> hi, I'm looking for an event queue to use instead of Control.Concurrent.Chan. I create a producer and consumer thread with forkIO and want to produce multiple times without consuming.
02:03:59 <mauke`0> why not Chan?
02:05:05 <fnord__> afaik a Chan is a queue of size 1, so I can't produce twice without consuming first
02:05:51 <merijn> fnord__: huh, wut?
02:05:56 <fnord__> oh seems this assumption was wrong
02:06:01 <merijn> fnord__: Chan is just an arbitrary channel
02:06:06 <mauke`0> MVar is a queue of size 1
02:06:12 <mauke`0> Chan is unbounded AFAIK
02:06:15 <fnord__> mauke`0: merijn: thanks for the help
02:07:21 <merijn> Chan is bounded by your available memory :p
02:10:36 * hackagebot data-extend-generic 0.1.0.0 - Extend Haskell data or newtype like in OOP languages  https://hackage.haskell.org/package/data-extend-generic-0.1.0.0 (YLiLarry)
02:15:06 <ThreeOfEight> Does anybody know how well several view pattern guards after another are optimised?
02:15:50 <ThreeOfEight> i.e. if I have two function equations "f (view -> Nothing) = ..." and "f (view -> Just x) = ...", will "view" ever be evaluated twice?
02:16:23 <merijn> ThreeOfEight: "maybe"
02:16:34 <merijn> ThreeOfEight: I don't think that question is answerable without looking at the Core
02:16:45 <merijn> ThreeOfEight: If you care you might want to just keep it explicit
02:16:49 <ThreeOfEight> well the GHC website says that "We should be able to give clear rules for when the avoidance of repeat computation is guaranteed."
02:16:54 <XyMa> @hoogle [a] -> [a]
02:16:57 <lambdabot> Prelude cycle :: [a] -> [a]
02:16:57 <lambdabot> Data.List cycle :: [a] -> [a]
02:16:57 <lambdabot> Prelude init :: [a] -> [a]
02:16:59 <ThreeOfEight> it does not say what these rules are though.
02:17:23 <merijn> ThreeOfEight: "Should be able" doesn't necessarily imply "We actually made it so"
02:17:55 <ThreeOfEight> Well, yes, that is kind of my question: whether anybody knows anything more concrete about how GHC handles this at the moment.
02:18:52 <ThreeOfEight> View Patterns are a great feature, but without guarantees like this, I'm not sure I would want to use them.
02:19:24 <jle`> ThreeOfEight: they're still plenty useful for cases where you wouldn't worry about repeating things
02:19:41 <jle`> f (view->(x,y)), for instance
02:19:49 <jle`> for f (view->x) even
02:20:26 <jle`> i probably wouldn't use them when you have repeat applications like what you use...although expecting it to work sounds like an egregious use of sugar, heh
02:20:43 <jle`> ViewPatterns already feels lazy/egregious to me even when i use them for guarunteed matches v.v
02:21:04 <ThreeOfEight> well, in my case, I could just reorder the equations and use a "_" pattern in the secon done
02:21:07 <ThreeOfEight> *seccond one
02:21:17 <pyon> jle`: Why? That's when they're the most useful. When a match isn't guaranteed.
02:21:18 <jle`> in your case i wouldn't use view patterns
02:21:22 <ThreeOfEight> but that order of equations seems less "natural" to me
02:21:30 <jle`> pyon: yeah, sorry, i meant when you have to 'repeat' calls like above
02:21:41 <ThreeOfEight> What would you use then?
02:21:42 <jle`> non-guarunteed matches are indeed the cool part :)
02:21:51 <jle`> ThreeOfEight: where bindings or let bindings
02:22:05 <jle`> or actually, sorry, just a case statement
02:22:14 <jle`> f x = case view x of Just y -> ...
02:22:18 <ThreeOfEight> well essentially, I am decomposing a heap
02:22:24 <jle`> i'd just use case statements here
02:22:38 <ThreeOfEight> and with view patterns, it can be made to look just like decomposing a datatype, which is nice
02:23:42 <pyon> What I would do is provide a function: `uncons :: Ord k => Heap k -> Maybe (k, Heap k)`.
02:24:09 <pyon> (Assuming by "heap" you mean "priority queue".)
02:25:22 <ThreeOfEight> Well, yes, that /is/ precisely my view function.
02:26:02 <pyon> Oh.
02:26:14 <pyon> Well, then just pattern-match on `view x`, as jle` says.
02:26:38 <ThreeOfEight> (well, more like Ord k => Heap k v -> Maybe (k, v, Heap k v), but same thing, really)
02:26:51 <pyon> Oh, right.
02:30:52 <ThreeOfEight> Yeah I could just pattern match on the view, but I prefer using the view pattern. I think it looks more elegant.
02:33:41 <mtesseract> hi
02:36:28 <jle`> hm, how do i import hiding type families that are type operators?
02:36:41 <jle`> hiding ('(+)), hiding (('+)) both seem to not work for me
02:36:54 <jle`> as in, syntax error
02:37:05 <jle`> hiding ((+)) doesn't hide the type family, just the actual function, it seems
02:37:12 <jle`> normal-value function
02:39:10 <mauke`0> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#explicit-namespaces
02:39:36 <jle`> oh i see, thanks
02:40:53 <ThreeOfEight> looks like it /does/ evaluate the pattern twice with -O0, but it eliminates it with -O2
02:54:28 <dzhus> Is there any way to know total directory size (including subdirs) from Haskell without resorting to calling "du -s" as a subprocess?
02:54:58 <merijn> dzhus: Depends on whether your OS/fs supports that?
02:55:01 <arahael> dzhus: 'du' isn't trivial.
02:55:17 <dzhus> let's say Linux-only solution would suffice
02:55:28 <dzhus> arahael: what do you mean?
02:55:41 <merijn> dzhus: No clue, I don't use linux :)
02:55:55 <arahael> dzhus: how do you cope with symbolic links? hard links? sparse files? character decices?
02:55:59 <arahael> *devices.
02:56:34 <dzhus> arahael: There're none in the directory in question as it's created by the application
02:56:37 <arahael> dzhus: or recursive directory structures.
02:56:57 <dzhus> arahael: du -s handles recursive directories
02:57:11 <arahael> dzhus: yes, du certainly does.
02:57:55 <quicksilver> there is no particular clever way.
02:58:01 <quicksilver> get file sizes, add them up.
02:58:04 <arahael> i'd probably just use du.
02:58:13 <quicksilver> it will probably be slower than du for large directories
02:59:24 <mauke`0> du computes disk usage, not apparent file size
02:59:51 <f00f00> hi
02:59:54 <dzhus> Actually I'm trying to keep acid-state file caches under certain size limit.
03:00:06 <f00f00> why is sum (1 , 2) equal to 2?
03:00:11 <quicksilver> true, there are different notions of 'size'
03:00:23 <quicksilver> f00f00: because the Foldable instance for (a,b) just makes 'b' available
03:00:30 <quicksilver> f00f00: which is weird, but makes sense in context.
03:00:39 <f00f00> what is the context?
03:00:49 <f00f00> I'm not sure I see how you can fold over a tuple of size 2
03:00:49 <mauke`0> (,) Integer
03:01:06 <ThreeOfEight> I never did like the Functor instance for (,) a
03:01:07 <quicksilver> that Foldable is a typeclass of kind * -> *
03:01:18 <quicksilver> so it's really (a,) which is the type constructor 'f'
03:01:22 <quicksilver> and 'b' is the value part
03:01:29 <f00f00> ah, ok
03:01:37 <quicksilver> > fmap (*2) ("hello",5)
03:01:39 <lambdabot>  ("hello",10)
03:01:58 <quicksilver> it has Functor, Traversable, Applicative and Monad instances too
03:02:03 <quicksilver> so they're all consistent
03:02:08 <quicksilver> but I do agree it's odd at first glance.
03:02:55 <quicksilver> > sumOf both (1,2)
03:02:56 <lambdabot>  3
03:03:01 <quicksilver> if you did want both, you can have it :)
03:03:46 <f00f00> thanks for your help!
03:05:27 <ThreeOfEight> > sumOf each (1,2,3,4,5)
03:05:29 <lambdabot>  15
03:05:45 <Axman6> :t each
03:05:47 <ThreeOfEight> I think I will never quite understand the lens library
03:05:48 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
03:07:02 <quicksilver> I will never quite understand mathematics, ThreeOfEight 
03:07:02 <Axman6> ThreeOfEight: most of it is surprisingly simple and easy to use. but it goes very deep, it's best to stick to the basics (getting, setting, traversals and prisms)
03:07:06 <quicksilver> but I don't give up learning.
03:07:19 <Axman6> and then go deeper when you need it
03:12:58 <f-a> is anyone here admin of planehaskell?
03:14:54 <ThreeOfEight> Axman6: the types and the type errors are a nightmare though
03:16:21 <Axman6> true, but not totally unreadable. like most haskell errors, you look for the line number and do the type checking in your head :P
03:19:15 <jle`> actually the types/errors aren't too bad
03:19:25 <jle`> i thought they were, too, at first
03:19:39 <jle`> but after a couple days of using them they become fairly intuitive
03:19:51 <jle`> and you also don't need to ever understand the entire library...just the parts that are useful to you :)
03:19:57 <quicksilver> they vary. The type of `each` above is fine
03:20:19 <quicksilver> the errors you get with a missing instance can be horrible but that's a general problem with any haskell code using typeclasses
03:20:23 <ThreeOfEight> Yeah, learning to use the lens library is on my to-do-list, right next to mastering zsh and vim.
03:20:30 <ThreeOfEight> And it has been for years.
03:20:39 <jle`> i think the thing for me was like, i never sat down to learn the lens library
03:20:49 <jle`> i just used lenses ad-hoc when i needed them
03:20:51 <quicksilver> > sumOf both ("hello",3)
03:20:52 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘sumOf’
03:20:52 <lambdabot>      In the expression: sumOf both ("hello", 3)
03:20:54 <jle`> or when they were useful
03:21:03 <jle`> and things just made more and more sense along the way
03:21:05 <quicksilver> the tricking is knowing whether they will be useful?
03:21:16 <quicksilver> but talking to people in this channel helps.
03:21:20 <jle`> well, a lot of libraries these days expose their API only through lenses and prisms
03:21:24 <jle`> like the great `wreq` library
03:21:40 <jle`> and the lens usage in there is extremely simple and understandable
03:21:41 <jle`> `pipes`, too
03:21:51 <jle`> and you just pick up the easy-to-understand parts one at a time
03:21:57 <jle`> and before you know it, you understand lens :)
03:22:49 <jle`> wreq is great and a part of how great it is is from how simple the interface is made by making it lens-based, but you don't have to understand lenses to use it, really
03:23:03 <jle`> you just need to know the concrete functions that they use
03:23:13 <jle`> kind of like how you don't need to know how to use Functor/Monad if you just want to use `map` on a list
03:23:55 <jle`> you don't need to learn about the subtleties of the Functor typeclass and its laws...you just need `map`, map (+1) [1,2,3]
03:24:05 <jle`> these little gateway libraries are the same, heh
03:24:46 <jle`> if i sat down to learn Functors/Monads, i might have a hard time, but just using `fmap` on Maybe, IO, etc., and understanding how they work on their respective types in particular is a pretty chill road
03:31:58 <nilg> Anybody knows how to work around that bug http://pastebin.com/2Dzy1qmW ?
03:32:23 <nilg> Looks like a ghc bug, I'm not sure...
03:35:39 * hackagebot syntactic 3.2.1 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.2.1 (EmilAxelsson)
03:35:44 <nilg> weird, it seems this causes by bad interactions between Text.Format and Graphics.Gnuplot.Simple....
03:39:22 <liste> nil probably they're using different versions of Text
03:39:25 <liste> text*
03:39:52 <liste> did cabal warn you about dangerous reinstalls at some point=?
03:40:39 * hackagebot open-typerep 0.4 - Open type representations and dynamic types  https://hackage.haskell.org/package/open-typerep-0.4 (EmilAxelsson)
03:47:12 <nilg> liste: no, cabal didn't warn me. Does cabal take into account the version ghc installed on the system when installing packages?
03:48:43 <merijn> nilg: Cabal just interfaces with GHC
03:49:07 <merijn> nilg: The package registration is in a GHC specific database and cabal-install (i.e. the cabal program) just talks to whichever GHC is in your path
03:52:42 <nilg> merijn: so if I reinstall another version of ghc on my system, what is gonna happen to the existing packages, are they gonna still work?
03:53:27 <nilg> Oh, looks like there are unknown! So I guess cabal keeps a copy of each package for each version of ghc or something...
03:54:01 <merijn> nilg: No, packages are GHC version specific, if you add/replace GHC all previously installed packages are non-existent
03:54:23 <nilg> So, why are we talking about cabal hell? All this sounds perfectly sane to me?
03:55:26 <merijn> Who is talking about cabal hell?
03:55:39 <nilg> *you*
03:56:01 <nilg> :-D Sorry, I couldn't help... My summer student did...
03:56:41 <nilg> Although I got some error while trying to install numbers:
03:56:42 <nilg> ghc: ghc no longer supports single-file style package databases (dist/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format.
03:56:51 <nilg> ???
03:57:56 <nilg> Looks like I just need to upgrade cabal as well...
04:23:27 <danza> hi all, there is somebody on Upwork https://www.upwork.com creating fake Haskell jobs in order to do his/her university assignments ... any suggestion about how to stop him/her?
04:24:51 <merijn> danza: Report it to their university/professor?
04:25:10 <Axman6> find the university assigning the assignment and email the lecturer if you can. often you can just google the text they use because they copy and paste from the documentation
04:25:32 <danza> okay. this job offer https://www.upwork.com/job/Haskel-export-needed_~01ba66fd4ff659f155/ asks to perform ECS713
04:26:04 <danza> this is truly ridiculous ... which kind of student behaves this way? :(
04:26:48 <Axman6> I've seen it happen in my courses. one lecturer responded by getting to the theater early, and just having the page open on the projector as we came in.
04:27:15 <Axman6> also, most lecturers already know about these sites, and often they love "accepting" the job =)
04:27:31 <danza> that's a great tactic :D
04:27:40 <Jinxit> oh man that's clever
04:27:49 <Axman6> it's the easiest way to find out who the idiot is
04:27:54 <danza> basically the only Haskell jobs found on Upwork are about students cheating this way
04:28:02 <Axman6> but yeah, this sort of behaviour is rife sadly
04:28:13 <n1> it is quite sad
04:28:49 <n1> also really makes interviews annoying since companies get stacks of resumes from people with degrees/high GPA and no knowledge
04:29:01 <Axman6> yah :\
04:32:18 <quicksilver> that's why you should interview people with a few years experience of an obscure tech
04:32:22 <quicksilver> like perl or indeed haskell
04:32:30 <breadmonster> Hello.
04:32:39 <breadmonster> quicksilver: Since when is perl obscure?
04:32:48 <danza> i am not confident with American system ... how do i find the professor for ECS713?
04:32:59 <breadmonster> danza: What does that mean?
04:32:59 <quicksilver> it's relatively obscure in the developer recruitment market
04:33:14 <danza> i guess that it is a code for some course?
04:33:23 <breadmonster> quicksilver: really? I'm surprised. It used to be the big thing a few years ago, I thought there were still quite a few devs.
04:33:34 <breadmonster> Just like how there are people who make $$$ writing COBOL.
04:33:46 <quicksilver> "relatively"
04:34:02 <breadmonster> Fair enough.
04:34:27 <breadmonster> How is the Haskell job market? All the good CVs I look at show some Haskell experience.
04:34:49 <Axman6> there are definitely more jobs than there used to be
04:34:51 <breadmonster> Then again, I primarily look at trader's CVs...
04:35:07 <linduxed> i can tell you that the market in Sweden (at least) is pretty small
04:35:24 <linduxed> there are like... two known companies
04:35:34 <linduxed> one recently started, so i guess there's three now
04:35:41 <breadmonster> linduxed: Wow, that's two more companies than most places :D
04:35:53 <linduxed> breadmonster: fair point
04:35:54 <Axman6> danza: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=2&ved=0ahUKEwjs4bDfseDJAhUKmpQKHWNYCfsQFggiMAE&url=http%3A%2F%2Fqmplus.qmul.ac.uk%2Fmod%2Fresource%2Fview.php%3Fid%3D156484&usg=AFQjCNGZozWYbHLsY3ig2xPJxXzErnEZ6w&sig2=DoZs_43RbPJURbsD0S-oog&bvm=bv.110151844,d.dGo has the name of the lecturers
04:36:00 <Axman6> wow... thanks google :(
04:36:12 <danza> thanks :)
04:36:58 * quicksilver knows the teachers of that module :)
04:37:11 <breadmonster> quicksilver: You're a Londoner?
04:37:19 <quicksilver> yes
04:37:28 <Axman6> quicksilver: if you can find out how much fun they have with the students posting job ads, that would be excellent =)
04:37:42 <danza> :D
04:38:03 <breadmonster> quicksilver: Are you Oxbridge?
04:38:09 <quicksilver> the upwork link requires registration to see tho
04:38:16 <quicksilver> breadmonster: not any more :)
04:38:47 <breadmonster> quicksilver: You were?
04:38:47 <danza> quicksilver, yes it also obfuscates the contact until you get the work
04:39:04 <breadmonster> quicksilver: In that case, might I PM? I'll be applying in a bit.
04:39:18 <quicksilver> sure
04:39:20 <danza> breadmonster, it is surprising that you meet traders with experience with Haskell, i thought that most traders used proprietary software and coded custom logic with their plugin languages
04:39:59 <merijn> danza: Lots of financial companies doing haskell
04:40:01 <Axman6> danza: lots of those systems are implemented in haskell at some of the big banks these days
04:40:09 <breadmonster> danza: No. A lot of firms like being able to prove that your algorithm won't vaporize half a billion dollars in a few microseconds.
04:40:26 <Axman6> Standard Chartered, McGraw Hill Financial... some others I can't remember
04:40:41 <Axman6> breadmonster: yeah, that's what HFT is for
04:40:45 <merijn> danza: Standard Chartered has like 2.5 million LOC of haskell (+ Mu), McGraw Hill, Jane Street does Ocaml, but close enough
04:40:48 <breadmonster> Axman6: Jane Street too.
04:40:58 <merijn> breadmonster: Not haskell, though
04:40:59 <Axman6> OCaml /= Haskell
04:41:01 <breadmonster> Tsuru does Haskell.
04:41:01 <danza> breadmonster, it is not given for granted, i have got a job offer on Node by a financial company ... it was embarrassing to reply
04:41:07 <breadmonster> Axman6: Close enough.
04:41:09 * Axman6 used to work for Tsuru
04:41:20 <breadmonster> danza: That probably wasn't for financial systems, right?
04:41:33 <Axman6> not really, when it comes to the nitty gritty of HFT, I think OCaml is better suited in many ways
04:41:37 <breadmonster> Axman6: I'm going to query, this is too good an opportunity to lose.
04:41:58 <Axman6> Google is great at queries =)
04:42:01 <danza> breadmonster, as i said, do not give it for granted ... a lot of people have no idea about the difference
04:42:11 <breadmonster> Axman6: I meant PM :P
04:42:27 <breadmonster> speaking of which, I don't know why OCaml has to be so hideous, it's certainly a cosmetic thing.
04:42:55 <quicksilver> it's a subjective thing
04:43:02 <quicksilver> subjectively I find it hideous
04:43:10 <quicksilver> sml too, but ocaml worse
04:43:19 <merijn> Any libraries for doing weighted random selection?
04:43:24 <breadmonster> quicksilver: trust me, it's so uniformly subjective, it'll be objective.
04:43:32 <ashish> hi
04:43:47 <Axman6> yeah I feel that OCaml is needlessly ugly, there's just extra cruft which seems unnecessary and easily avidable
04:45:00 <ashish> I've a question about parsing library, I would like to have something like, Lisp's reader which reads a s-expression from the input stream, and returns it. ATM, I've written a parser using Parsec.
04:45:30 <ashish> But, I'm wondering if invoking 'runParser' on every invocation of 'read' is good idea, or there is a better way/library of doing it.
04:47:25 <mauke`0> I thought ocaml was fine
04:47:55 <mauke`0> then (on my 2nd) attempt I managed to learn haskell. after a while I went back and realized I couldn't write ocaml anymore
04:48:07 <mauke`0> it was just so inconsistent and ugly :-(
04:48:24 <mauke`0> I think people learning haskell is what makes ocaml so ugly
04:48:49 <hexagoxel> is profiling while optimizations are on a bad idea in general?
04:49:43 <Axman6> hexagoxel: it usually gives less than optimal profiling results and optimisation
04:52:06 <quicksilver> but if you profile with optimisation off, you're profiling the wrong thing
04:52:16 <quicksilver> then again, profiling defeats optimisations anyway
04:52:19 <quicksilver> so you really can't win.
04:52:35 <quicksilver> profile with optimisations on and accept that it's wrong but hopefully it finds the right hotspots anyway.
04:52:42 <hexagoxel> are there specific optimizations to turn off in order to reduce misleading -p output?
04:53:24 <Axman6> I think a lot of the problems come from inlining, code that would have existed might get optimised away, but parts of it remain, and cause the issues you're looking for
04:53:29 <Axman6> pretty rare though
04:54:14 <hexagoxel> (also, is this mentioned anywhere? i had a brief search for "optim" in existing profiling documentation/tutorials, and found nothing)
04:54:58 <hexagoxel> Axman6: yeah i have a case where apparently i can profile with -O2, but disable some very specific optimizations, and get mostly-accurate -p output.
04:55:29 <hexagoxel> i have not narrowed it down fully and was wondering if i this was already existing knowledge.
04:56:54 * hexagoxel continues bisecting optimization flags
04:57:15 <Axman6> have fun =)
04:57:28 <Axman6> Maybe you could use acovea
04:58:29 <hexagoxel> Axman6: oh, neat, thanks for pointer.
04:59:31 <Axman6> have fun spending the next few days making it work properly :P Don Stewart had a post years ago about using it with GHC and LLVM options
04:59:40 <breadmonster> Axman6: You're a ghc dev?
04:59:46 <Axman6> https://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/
04:59:48 <Axman6> no
05:04:56 <hexagoxel> (apparently -fspecialize was the one messing up -p results.)
05:05:30 <ggVGc> couldn't the heuristics in an optimizing compiler be generated from a genetic algorithm?
05:05:34 <ggVGc> or maybe some are?
05:10:59 * ww quite pleased with stack
05:43:35 <badmash> hello
05:43:52 <liste> hello
05:43:53 <badmash> have a question on type stuff ... appreciate any help
05:44:16 <liste> go ahead badmash
05:44:41 <badmash> ( \ ( a, b )  ->  a  ::  System.Random.Random g => g ) (System.Random.random (System.Random.mkStdGen  4)) -- this code doesn't work
05:44:49 <ghorn> I'm having an issue with "* Missing C library: HSrts-ghc7.10.3"
05:44:52 <badmash> i would like to know why
05:45:12 <ghorn> could someone with ghc 7.10.3 try "cabal configure" on this trivial project: https://github.com/ghorn/no-rts
05:45:37 <ghorn> it's just a dummy project with "extra-libraries:     HSrts-ghc7.10.3" in the cabal
05:48:19 <badmash> any ideas why would be great help
05:48:26 <quicksilver> > (System.Random.random (System.Random.mkStdGen  4))
05:48:28 <lambdabot>  (-257916191140261834,289488136 2103410263)
05:48:30 <quicksilver> sorry, mispaste
05:48:41 <quicksilver> > ( ( \ ( a, b )  ->  a ) :: System.Random.Random g => (g,x) -> g ) (System.Random.random (System.Random.mkStdGen  4))
05:48:43 <lambdabot>  -257916191140261834
05:48:51 <quicksilver> badmash: ^^ that works and I presume it's what you intended.
05:49:38 <aweinstock> quicksilver: I think he understands that part, but is wondering about the typesystemish reasons for why annotating *inside* the lambda doesn't work
05:49:54 <badmash> quicksilver: why didn't my code work?
05:50:10 <badmash> aweinstock: yes, exactly
05:50:51 <quicksilver> because it's not the same thing
05:51:07 <quicksilver> because your annotation tried to make 'a' into a polymorphic parameter
05:51:22 <aweinstock> :t (\x -> x :: Read a => a)
05:51:24 <lambdabot>     Couldn't match expected type ‘a1’ with actual type ‘r’
05:51:24 <lambdabot>       because type variable ‘a1’ would escape its scope
05:51:24 <lambdabot>     This (rigid, skolem) type variable is bound by
05:51:34 <aweinstock> :t (\x -> x) :: Read a => a -> a
05:51:35 <lambdabot> Read a => a -> a
05:51:58 <aweinstock> quicksilver: what does the first one mean?
05:52:26 <badmash> quicksilver: and you can't make 'a' polymorphic? why not?
05:52:40 <quicksilver> because polymorphism "isn't first class" in haskell
05:52:49 <quicksilver> however there is a question I can't answer
05:53:02 <quicksilver> which is why " (\x -> x :: Read a => a)" isn't accepted with RankNTypes on
05:53:14 <quicksilver> I think it's just because it can't infer the obvious type of the whole expression
05:53:19 <quicksilver> because Rank N inference is hard
05:53:21 <quicksilver> but Im' not sure.
05:53:32 <merijn> quicksilver: s/hard/impossible :)
05:53:33 <aweinstock> :t (\x -> x :: Read a => a) :: Read a => a -> a
05:53:35 <lambdabot>     Couldn't match expected type ‘a2’ with actual type ‘a1’
05:53:35 <lambdabot>       ‘a1’ is a rigid type variable bound by
05:53:35 <lambdabot>            an expression type signature: Read a1 => a1 -> a1
05:53:38 <badmash> quicksilver: well, why can't it default and use Int?
05:53:49 <quicksilver> even if it *was* accepted it would be the wrong type to apply to the second half ofthe expression, incidentally
05:53:56 <quicksilver> I was just curious why it couldn't accept it at all.
05:53:57 <aweinstock> :t (\(x :: Read a => a) -> x) -- does lambdabot have ScopedTypeVariables?
05:53:59 <lambdabot> Read a => (Read a => a) -> a
05:54:34 <aweinstock> :t (\(x :: Read a => a) -> (x::String, x::Int))
05:54:35 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘a’
05:54:36 <lambdabot>       ‘a’ is a rigid type variable bound by
05:54:36 <lambdabot>           the inferred type of it :: (Read a => a) -> (String, Int)
05:54:40 <quicksilver> badmash: well, this isn't one of the circumstances that kicks defaulting in.
05:54:54 <quicksilver> merijn: well this particular exampel is clearly inferrable
05:55:03 <aweinstock> :t (\(x :: forall a. Read a => a) -> (x::String, x::Int))
05:55:05 <lambdabot> (forall a. Read a => a) -> (String, Int)
05:55:05 <merijn> Rank2 is, but RankN is not :)
05:55:25 <aweinstock> > (\(x :: forall a. Read a => a) -> (x::String, x::Int)) "42"
05:55:27 <quicksilver> merijn: I know how it works. My point is that this specific term has an obvious type (even a unique one, perhaps?)
05:55:27 <lambdabot>      Couldn't match expected type ‘a’ with actual type ‘[Char]’
05:55:28 <lambdabot>        ‘a’ is a rigid type variable bound by
05:55:28 <lambdabot>            a type expected by the context: Read a => a at <interactive>:1:1
05:55:39 <badmash> quicksilver: yeah, i thought so, so when does haskell infer using default?
05:57:23 <jgoux> Hi
05:57:23 <jgoux> Is it possible to create lenses based on a parameter ? For example I want to create a lens on a collection of items, but I don't know the index of the item directly, I just know its internal id
05:57:28 <aweinstock> > (\(x :: forall a. Read a => a) -> (x::Double, x::Int)) (read "42")
05:57:30 <lambdabot>  (42.0,42)
05:57:39 <merijn> Any suggestions for a simple way to obtain a generator for unique ascii strings?
05:58:09 <aweinstock> :t ix -- jgoux
05:58:11 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
05:58:34 <aweinstock> > "hello" ^. ix 3
05:58:36 <lambdabot>      No instance for (Monoid Char) arising from a use of ‘ix’
05:58:36 <lambdabot>      In the second argument of ‘(^.)’, namely ‘ix 3’
05:58:36 <lambdabot>      In the expression: "hello" ^. ix 3
05:58:43 <aweinstock> > "hello" ?. ix 3
05:58:44 <lambdabot>      Not in scope: ‘?.’
05:58:44 <lambdabot>      Perhaps you meant one of these:
05:58:44 <lambdabot>        ‘.’ (imported from Data.Function),
05:59:03 <jgoux> aweinstock: But here you provide "3"
05:59:08 <aweinstock> > "hello" ^? ix 3
05:59:09 <quchen> > "hello" ^? ix 3 -- aweinstock 
05:59:10 <lambdabot>  Just 'l'
05:59:11 <lambdabot>  Just 'l'
05:59:28 <quicksilver> merijn: take a generator of unique numbers and apply base64, is what most people do
05:59:37 <quicksilver> merijn: base16 and other bases exist!
05:59:41 <aweinstock> :t map ix [2..4]
05:59:42 <lambdabot> (Enum (Index m), Num (Index m), Applicative f, Ixed m) => [(IxValue m -> f (IxValue m)) -> m -> f m]
06:00:13 <badmash> quicksilver: so in a lambda, you can not return an ambiguous type, like in the code i pasted?
06:00:14 <aweinstock> :t map (\lens -> "hello" ^? lens) (map ix [2..4])
06:00:15 <lambdabot> [Maybe Char]
06:00:19 <aweinstock> > map (\lens -> "hello" ^? lens) (map ix [2..4])
06:00:19 <jgoux> What I want is given a collection : [{id: "foo"}, {id: "bar"}], I want to create a lens on this collection to get the item with id = "foo"
06:00:21 <lambdabot>  [Just 'l',Just 'l',Just 'o']
06:00:30 <quicksilver> badmash: what you pasted wasn't an ambiguous type
06:00:47 <quicksilver> badmash: it was a higher-rank type annotated in a way insufficient for inference.
06:00:49 <jgoux> I don't know that its id is 1 yet
06:00:58 <jgoux> its index*
06:01:01 <quicksilver> you certainly can return higher-rank types if you put the annotations in the right place
06:01:06 <quicksilver> but you rarely need to.
06:01:13 <badmash> quicksilver: ( \ ( a, b )  ->  a :: Int ) (System.Random.random (System.Random.mkStdGen  4)) -- this works, here 'a's type is Int
06:01:25 <quicksilver> yes indeed, that is no longer higher rank.
06:01:34 <quicksilver> and I showed you how to do it polymorphically
06:01:44 <quicksilver> > ( ( \ ( a, b )  ->  a ) :: System.Random.Random g => (g,x) -> g ) (System.Random.random (System.Random.mkStdGen  4))
06:01:46 <lambdabot>  -257916191140261834
06:01:49 <aweinstock> :t filtered
06:01:50 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a
06:02:14 <quicksilver> > ( ( \ ( a, b )  ->  a ) :: System.Random.Random g => (g,x) -> g ) (System.Random.random (System.Random.mkStdGen  4)) :: Char
06:02:16 <lambdabot>  '\159377'
06:02:20 <quicksilver> ^^ just to prove it was polymorphic
06:02:27 <badmash> quicksilver: so to do it polymorphically, you can not do it within the lambda, you mean?
06:02:32 <aweinstock> > ["foo", "bar"] ^.. filtered (const True)
06:02:33 <lambdabot>  [["foo","bar"]]
06:02:37 <quicksilver> I don't even mean that.
06:02:43 <quicksilver> you annotated it with the wrong type.
06:02:48 <aweinstock> > ["foo", "bar"] ^.. filtered (const True) . traversed
06:02:49 <lambdabot>  ["foo","bar"]
06:02:51 <quicksilver> the annotation you did didn't mean the same thing as mine
06:02:59 <aweinstock> > ["foo", "bar"] ^.. filtered (== "foo") . traversed
06:03:00 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
06:03:00 <lambdabot>      Expected type: ([Char] -> Const (Endo [Char]) [Char])
06:03:00 <lambdabot>                     -> [[Char]] -> Const (Endo [Char]) [[Char]]
06:03:01 <quicksilver> if mine is what you wanted, then yours was simply incorrect :)
06:03:02 <badmash> quicksilver: i see
06:03:07 <quicksilver> if yours was what you wanted, then it's different from mine
06:03:15 <quicksilver> and the whole lambda needs annotating as well.
06:03:28 <aweinstock> > ["foo", "bar"] ^.. filtered (== "foo")
06:03:30 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
06:03:30 <lambdabot>      Expected type: Getting (Endo [[Char]]) [[Char]] [Char]
06:03:30 <lambdabot>        Actual type: Optic' (->) (Const (Endo [[Char]])) [Char] [Char]
06:03:44 <jgoux> xD
06:03:57 <aweinstock> yeah, I'm not really skilled with lens yet either
06:04:26 <quicksilver> > ["foo", "bar"] ^.. traversed . filtered (== "foo")
06:04:28 <lambdabot>  ["foo"]
06:04:28 <quicksilver> ^^ aweinstock 
06:04:53 <badmash> quicksilver: alright, i know what you did is correct, but i still am unclear why my code didn't work.  thanks anyway
06:04:57 <aweinstock> jgoux: does that do what you want it to?
06:06:25 <jgoux> Yes :D
06:06:28 <jgoux> thank you !
06:07:12 <jgoux> If I want to handle Nothing, I have to use Prisms right ?
06:41:29 <linduxed> hey guys
06:42:09 <linduxed> i've got a problem where i've got a Map which i've got (Coordinate Int Int) as keys and Int as values
06:42:19 <linduxed> *in which
06:42:38 <bernalex> that doesn't sound very problematic.
06:42:41 <liste> linduxed what's the problem
06:43:06 <linduxed> the problem is that i want to fold over a list of relative directions
06:43:15 <linduxed> the directions are Left/Right/Up/Down
06:43:18 <linduxed> here's the issue:
06:43:23 <linduxed> it's important to know the last coord
06:43:30 <linduxed> this makes things a bit uglier
06:43:44 <linduxed> i can't just pass in the Map and have the function passed to the fold return the Map
06:44:08 <linduxed> so i think i need to create a more complex data type, that both has the map of Coordinates I've passed and the last Coord
06:44:28 <linduxed> this could either be a tuple or a record data type
06:44:44 <linduxed> and i'm starting to wonder whether the state monad would be a good thing to use here
06:45:23 <linduxed> because i just want to traverse the list of directions and record which Coordinates I've passed and how many times
06:46:53 <aweinstock> what do you mean by "fold over a list of relative directions"?
06:47:15 <JonReed> Is is possible to make function like  "a -> IO () -> a". Sort of like Id with a nasty unpure unsafe IO inside it. I know it's ridiculous, but for develomental experementation I sometimes just want to print when the function is called or if the function is called at all. So it would be great for it to output some string to the console during debugging on each function call (or output nothing at all if this function is reduced by the 
06:47:47 <aweinstock> JonReed: Debug.Trace.trace kind of already does that
06:48:14 <Xandaros> And all the other lovely functions in Debug.Trace
06:48:30 <liste> JonReed maybe nasty act val = (unsafePerformIO act) `seq` val ?
06:48:30 <aweinstock> :t \x io -> System.IO.Unsafe.unsafePerformIO io `seq` x
06:48:31 <lambdabot> r -> IO t -> r
06:50:09 <JonReed> Thanks! 
06:51:07 <frerich> linduxed: If you have a type 'data Direction = Left | Right | Up | Down' and 'data Coordinate = Coordinate Int Int', then you could define 'walk :: Direction -> Coordinate -> Coordinate' which performs a single step. Once oyu have that, you could use 'scanr' to transform a [Direction] list into a [Coordinate] list (with some giving start point.
06:51:48 <aweinstock> :t scanr
06:51:49 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
06:52:45 <frerich> linduxed: Consider e.g. http://lpaste.net/147176 -- if you call 'trace (Coordinate 0 0) [Left, Up, Left]' you get all the coordinates you visited
06:53:22 <frerich> aweinstock: It's like foldr, but it also gives you all the intermediate values
06:53:38 <ggVGc> haskell with ghc extensions is so huge.. :/
06:54:02 <aweinstock> :t (\(x,y) -> (sqrt (x*x + y*y), atan2 y x)
06:54:03 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:54:04 * geekosaur sends ggVGc -XDependentHaskell
06:54:06 <aweinstock> :t (\(x,y) -> (sqrt (x*x + y*y), atan2 y x))
06:54:08 <lambdabot> RealFloat t => (t, t) -> (t, t)
06:54:13 <larryba> ggVGc huge in what way?
06:54:22 <aweinstock> > (\(x,y) -> (sqrt (x*x + y*y), atan2 y x)) (1,0)
06:54:24 <lambdabot>  (1.0,0.0)
06:54:27 <aweinstock> > (\(x,y) -> (sqrt (x*x + y*y), atan2 y x)) (1,1)
06:54:29 <lambdabot>  (1.4142135623730951,0.7853981633974483)
06:54:36 <aweinstock> > (\(x,y) -> (sqrt (x*x + y*y), atan2 y x)) (-1,0)
06:54:37 <lambdabot>  (1.0,3.141592653589793)
06:54:56 <aweinstock> @let cartesianToPolar = (\(x,y) -> (sqrt (x*x + y*y), atan2 y x))
06:54:57 <lambdabot>  Defined.
06:55:07 <ggVGc> larryba: just, a big language, many features
06:55:13 <ggVGc> with all the extensions
06:55:16 <ggVGc> I feel lost sometimes
06:55:45 * hackagebot typed-wire-utils 0.1.0.0 - Haskell utility library required for code generated by typed-wire compiler  https://hackage.haskell.org/package/typed-wire-utils-0.1.0.0 (AlexanderThiemann)
06:58:02 <wedens> is there something to read/watch on how to do property based testing? (how to discover properties, how to get examples from generator without wasting cpu time on producing garbage and filtering)
07:02:12 <aweinstock> @check \x -> (reverse . reverse) x == x
07:02:15 <lambdabot>  +++ OK, passed 100 tests.
07:02:57 <aweinstock> wedens: ^ that's the simple example, you've probably seen it before though
07:03:58 <aweinstock> one thing I use quickCheck for is for testing whether an imperative ST based algorithm acts the same as a simpler imperative version (I'm not sure if that's in scope of your question though)
07:04:21 <Xandaros> Well, that's model-based testing
07:05:45 * hackagebot success 0.2.3 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.3 (NikitaVolkov)
07:09:24 <wedens> aweinstock: I've seen many trivial examples, but I just can't use it myself :/
07:10:10 <wedens> and sometimes I don't know whether I should try to use PBT or not
07:13:34 <indiagreen> what extension lets me write stuff like http://lpaste.net/147177 without having to indent the 2nd do block?
07:13:53 <indiagreen> currently I get “empty do block”
07:14:00 <typh00nz> hey
07:14:34 <frerich> wedens: I initially had problems to use QuickCheck for 'real programs', too (i.e. not just toy problems). I found it helps if you make a habit of thinking about a function by considering invariants. For instance, earlier somebody wanted to be able to translate something like 'walk (0, 0) [Left, Left, Up]' to '[(-1,0), (-2,0), (-2,-1)]'. I.e. walk some 'steps' and get the covered coordinates.
07:16:02 <frerich> wedens: If you think about it, you can see that the length of the output is always equal to the length of given steps. And furthermore, the number of times Left/Up/Down/Right appears in the input list defines the minimum/maximum coordinates you will see in the list (e.g. if you have two 'Left' steps and start at (0,0), you will never see an X coordinate lower than -2)
07:16:15 <aweinstock> frerich: quickCheck (\x y -> last (walk (x,y) [Left, Right]) == (x,y)) -- ?
07:17:01 <aweinstock> frerich: (i.e. Left/Right and Up/Down "cancel out")
07:17:24 <frerich> aweinstock: Yeah, something like that, too.
07:17:57 <indiagreen> nevermind, found it (NondecreasingIndentation)
07:18:33 <frerich> aweinstock: I.e. you think about it a bit and try to find invariants like that. And then quickcheck will try to find cases which violate your invariant.
07:19:03 <wedens> frerich: good example. thanks
07:19:09 <frerich> E.g. some list of directions where '\xs -> length (walk (0, 0) xs) /= length xs' for instance.
07:19:58 <exio4> walk p [Left,Right] = p sounds easy to to prove though
07:21:42 <aweinstock> frerich: but implementing walk via scanr guarentees that the length invariant holds, right? (i.e. regardless of the function you pass to scanr, scanr preserves the length of the list you're scanning over)
07:22:29 <Sindriav_> I'm having a really weird problem with VTY. Everytime my program quits, it outputs "G@" to the command line O.o
07:22:48 <sm> Sindriav: same here
07:22:55 <sm> maybe it's in the bug tracker ?
07:22:55 <wedens> I suppose it's hard for me because most of the time I do web apps. get some data from db, modify, some data, show some data, probably a bit of parsing
07:23:25 <joneshf-laptop> Is there a flag for ghc to tell you when you have unused extensions?
07:23:40 <aweinstock> exio4: (walk p dirs) is something like (scanr step p dirs), so I'd think it'd be easier to prove (step Left . step Right = id)
07:23:41 <frerich> aweinstock: Yeah, but I guess it can be argued that scanr is just an implementation detail and could actually change in future versions of the function. In fact, maybe you'd devise the function type first, then write quickcheck invariants and then you work on the function until quickcheck cannot find problems anymore.
07:23:47 <quicksilver> I don't think so joneshf-laptop it's a good idea
07:24:26 <exio4> aweinstock: oh, sure
07:25:46 * hackagebot aeson-value-parser 0.11.1 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.11.1 (NikitaVolkov)
07:26:05 <joneshf-laptop> quicksilver, k
07:26:07 <aweinstock> step Left = (pred *** id); step Right = (succ *** id); step Up = (id *** pred); step Down = (id *** succ)
07:26:29 <aweinstock> do we have (pred . succ = id) as an axiom/Enum law?
07:26:36 <frerich> With other programming languages (e.g. C++) when I write unit tests for failure cases, I often wonder whether I can avoid the test in the first place by using more appropriate types (e.g. avoiding a test for how empty strings are handled by having a 'nonempty string' type). I wonder whether something like that is possible in Haskell, too.
07:26:51 <frerich> Avoiding quickCheck tests by writing types in a way which make it impossible to violate some invariant.
07:26:55 <aweinstock> :t (:|)
07:26:57 <lambdabot>     Not in scope: data constructor ‘:|’
07:26:57 <lambdabot>     Perhaps you meant one of these:
07:26:57 <lambdabot>       ‘:+’ (imported from Data.Complex),
07:27:42 <mauke`0> > (pred . succ) maxBound
07:27:43 <lambdabot>  *Exception: Prelude.Enum.().pred: bad argument
07:28:23 <aweinstock> mauke`0: don't we get to ignore bottom in proofs? :)
07:29:15 <aweinstock> > (succ . pred) minBound
07:29:16 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
07:32:56 <liste> why is () even Enum?
07:32:58 <liste> > succ ()
07:33:00 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
07:33:16 <quicksilver> why wouldn't it be?
07:33:17 <Xandaros> It kinda makes sense
07:33:20 <Sindriav_> sm: Nope, I don't see anything in the issues on github
07:33:20 <quicksilver> what does Enum even mean? :)
07:33:37 <Sindriav_> sm: I'll submit it when I get home from school :)
07:33:50 <liste> yeah, you can enumerate all 1 of () (:
07:33:50 <Xandaros> On that note - is Void an Enum?
07:33:57 <aweinstock> > [minBound..maxBound]
07:33:58 <sm> Sindriav: great
07:33:59 <lambdabot>  [()]
07:34:12 <aweinstock> :t enumFromThenTo
07:34:13 <lambdabot> Enum a => a -> a -> a -> [a]
07:34:33 <aweinstock> > [(), ()..()]
07:34:34 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
07:34:43 <aweinstock> wait, what?'
07:34:56 <Xandaros> No - void is not an Enum. Why not?
07:34:57 <exio4> Xandaros: [minBound..maxBound] = []? :p
07:35:13 <Xandaros> ah, minBound and maxBound need to be defined? I see
07:35:18 <quicksilver> > [1,1 .. 1]
07:35:18 <Xandaros> No wait, that's Bounded
07:35:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:35:36 <quicksilver> [1,1..1] is different from [1..1] :)
07:35:49 <aweinstock> > [1..1]
07:35:51 <lambdabot>  [1]
07:35:59 <aweinstock> ok, that makes sense
07:36:08 <quicksilver> 1..1 goes from 1 to 1 with step 1; 1,1..1 goes from 1 to 1 with step 0.
07:36:16 <liste> can toEnum x be bottom for all x?
07:36:33 <aweinstock> quicksilver: how is "step" defined on ()?
07:36:47 <quicksilver> aweinstock: via the partial isomorphism to Integer
07:36:50 <quicksilver> (as for all Enums)
07:36:51 <aweinstock> > fromEnum ()
07:36:53 <lambdabot>  0
07:37:00 <aweinstock> :t (toEnum, fromEnum)
07:37:01 <lambdabot> (Enum a, Enum a1) => (Int -> a, a1 -> Int)
07:37:22 <Xandaros> liste: I don't see why not.
07:37:30 <quicksilver> partial iso to Int, then. Silly class :)
07:37:36 <aweinstock> > fromEnum (0 :: Integer)
07:37:38 <lambdabot>  0
07:37:38 <liste> yeah, then Void could be Enum, at least theoretically (:
07:37:46 <aweinstock> > fromEnum (2^32 :: Integer)
07:37:47 <lambdabot>  4294967296
07:37:52 <aweinstock> > fromEnum (2^64 :: Integer)
07:37:53 <lambdabot>  0
07:37:56 <pavonia> liste: For an empty data type maybe
07:38:22 <exio4> lambdabot: well, you'd need nicer types in a sound language
07:38:23 <ocramz> hi all
07:38:26 <quicksilver> as to "why is () an Enum" my best answer is the following:
07:38:26 <exio4> er, liste 
07:38:58 <quicksilver> we can derive (Enum a, Enum b) => Enum (Either a b)
07:39:06 <quicksilver> and it would be a shame if Either () () wasn't Enum
07:39:21 <quicksilver> that same argument would suggest that Void should be Enum.
07:39:38 <aweinstock> > [Left 1..Left 3]
07:39:40 <lambdabot>      No instance for (Show a0)
07:39:40 <lambdabot>        arising from a use of ‘show_M42824687724205749432719’
07:39:40 <lambdabot>      The type variable ‘a0’ is ambiguous
07:39:50 <aweinstock> > [Left 1..Left 3] :: [Either Int Int]
07:39:52 <lambdabot>      No instance for (Enum (Either Int Int))
07:39:52 <lambdabot>        arising from the arithmetic sequence ‘Left 1 .. Left 3’
07:39:52 <lambdabot>      In the expression: [Left 1 .. Left 3] :: [Either Int Int]
07:40:30 <aweinstock> quicksilver: is that instance not defined by default?
07:40:59 <aweinstock> or did you mean s/Either/(,)/?
07:41:02 <quicksilver> apparently GHC won't do that deriving.
07:41:12 <aweinstock> > [(1,0)..(3,0)]
07:41:13 <lambdabot>      No instance for (Show t0)
07:41:14 <lambdabot>        arising from a use of ‘show_M5896058313281685943306’
07:41:14 <lambdabot>      The type variable ‘t0’ is ambiguous
07:41:22 <aweinstock> > [(1,0)..(3,0)] :: [(Int, Int)]
07:41:24 <lambdabot>      No instance for (Enum (Int, Int))
07:41:24 <lambdabot>        arising from the arithmetic sequence ‘(1, 0) .. (3, 0)’
07:41:24 <lambdabot>      In the expression: [(1, 0) .. (3, 0)] :: [(Int, Int)]
07:41:26 <quicksilver> no, I meant Either.
07:41:37 <aweinstock> huh, that's not defined either (I expected it to be)
07:43:21 <quicksilver> Enum is, basically, not very useful in its current form.
07:43:25 <geekosaur> the problem with defining that is that it can't tell which order to increment in, and can't tell if you actually want one to range to maxBound and only then increment the other
07:43:37 <geekosaur> (and yes, there are people who expect the latter)
07:43:58 <quicksilver> geekosaur: well it's reasonable to expect deriving Enum to be consistent with deriving Ord.
07:44:09 <quicksilver> It's also reasonable to explain why that's a bad idea, mind.
07:44:12 <quicksilver> both things are reasonable.
07:44:17 <aweinstock> can't it do something diagonal? (along the lines of the proof that rationals are countable?)
07:44:26 <quicksilver> it can, but it doesn't.
07:44:28 <aweinstock> (for Enum (a,b))
07:44:36 <quicksilver> then it would be inconsistent with deriving Ord
07:44:50 <aweinstock> > (5,5) < (6,0)
07:44:51 <lambdabot>  True
07:45:01 <aweinstock> > (5,5) < (4,0)
07:45:03 <lambdabot>  False
07:45:13 <aweinstock> > (5,5) < (4,99)
07:45:15 <lambdabot>  False
07:45:17 <quicksilver> Ord uses lexicographic order "of course"
07:45:26 <geekosaur> Ord has its own issues (total ordering, conflation of ordering concepts (an Ord (Complex a) would be useful for e.g. Data.Map even though it's not mathematically useful), etc.
07:45:47 <quicksilver> agreed
07:46:02 <quicksilver> it's all irredeemable. Let's burn the language to the ground and use COBOL.
07:46:19 <aweinstock> why not INTERCAL? :)
07:46:40 <quicksilver> never trust a language with three or more vowels in the name. It's not right.
07:47:06 <exio4> PHP must be the best
07:47:28 <quicksilver> I would like a class for enumerating finite (and often small) datatypes.
07:47:34 <Xandaros> ALGOL?
07:47:41 <aweinstock> both PersonalHomePage and PHPHypertextPreprocessor have three or more vowels
07:47:45 <quicksilver> I think I would like that to use the same order as Ord.
07:47:58 <geekosaur> well, we did at least come up with a rational redesign of Enum / Bounded at one point, it's just never going to happen, sigh
07:48:08 <quicksilver> I am less fussed about a class for enumerating infinite but enumerable types
07:48:23 <geekosaur> I think someone did something similar for Ord, but that one has some nasty backward compatibility issues
07:48:24 <quicksilver> and that you could not reasonably expect to be consistent with Ord.
07:49:30 <geekosaur> well. maybe with the reboot of the Haskell' process, it might be worth digging up the Enum/Bounded redesign and turning it into an official proposale
07:49:33 <Xandaros> Well, I think `x < succ x` is quite an important property
07:49:52 <quicksilver> it's certainly a reasonable property.
07:50:31 <quicksilver> but for my stated goal of "enumerate finite probably-small types" I might choose to avoid the name 'succ'
07:50:48 <quicksilver> in order to avoid arithmetic intuitions not particularly intended.
07:55:47 * hackagebot pkcs10 0.1.0.4 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.1.0.4 (ktimothy)
07:57:48 <Xandaros> Enum adds an ordering. I think it should always satisfy `x < succ x` and `x < y → fromEnum x < fromEnum y`
07:58:37 <quicksilver> as I said, Xandaros, I think that is "reasonable"
07:58:48 <quicksilver> but it conflicts with some other (possible) design goals for Enum
07:58:57 <aweinstock> Xandaros: but you can't make that consistant with (Enum a, Enum b) => Enum (a,b), can you?
07:59:11 <quicksilver> aweinstock: you can if you keep everything finite
07:59:21 <quicksilver> but you still end up with a possibly annoying choice of enumeration
07:59:26 <quicksilver> if it's finite-but-large.
07:59:45 <aweinstock> finite, but with different sizes for the backing type, I think
08:00:00 <aweinstock> how would you define Enum (Word64, Word64)?
08:00:13 <aweinstock> you'd need a backing Word128, unless I'm missing something
08:00:24 <quicksilver> you'd back it into Integer
08:00:28 <quicksilver> if you wanted really large things
08:00:35 <quicksilver> another design choice/compromise.
08:01:06 <aweinstock> that allows infinite enums though? (e.g. Integer, where fromEnum = toEnum = id)
08:01:08 <Xandaros> I don't think defining Enum for tuples is a terribly good idea.
08:01:29 <aweinstock> and then what would be the backing for (Integer, Integer)?
08:01:34 <aweinstock> (consistant with Ord)
08:01:34 <quicksilver> Integer.
08:01:38 <quicksilver> ah, well you can't do that.
08:01:46 <quicksilver> hence my comment about finite
08:01:51 <quicksilver> (if you want to be consistent with Ord)
08:05:38 <Zekka|Sigfig> Well, there’s pairing functions that work for arbitrary pairs of integers, aren’t there? Like Cantor’s
08:06:27 <quicksilver> yes exactly.
08:06:32 <quicksilver> but they aren't consistent with Ord.
08:06:36 <quicksilver> which was the point of the discussion.
08:06:50 <Zekka|Sigfig> Oh wait! I missed aweinstock’s parenthetical
08:10:35 <ocramz> I'm confused about mutually recursive definitions in classes: why/how do they work?
08:10:52 <quicksilver> they are only defaults
08:10:57 * hackagebot success 0.2.4 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.4 (NikitaVolkov)
08:10:59 * hackagebot success 0.2.3.1 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.3.1 (NikitaVolkov)
08:10:59 <quicksilver> you are supposed to define one explicitly
08:11:08 <quicksilver> and then the others define the other methods
08:11:24 <mauke`0> it's sort of open recursion
08:11:50 <mauke`0> the methods in the class definition don't call each directly; they call whatever function of that name exists in a particular instance
08:13:56 <ocramz> uhm; let me give an example; I'm reading SubHask.Algebra , where we see `class Ring r => Field r where reciprocal r = one / r ; n / d = n * reciprocal d`
08:14:15 <ocramz> both are also annotated w sigs of course
08:14:25 <ocramz> but it would seem both defaults are given
08:14:36 <ggole> Isn't that plain old boring mutual recursion?
08:14:56 <quicksilver> yes you are expected to define one or the other, ocramz 
08:15:04 <quicksilver> you either define reciprocal, and it can use that for /
08:15:13 <ggole> Oh I see, it's that
08:15:15 <quicksilver> or you define (/) and it can use that for reciprocal.
08:15:32 <quicksilver> or you can certain define both, if you wish, peresumably because that will be efficient.
08:15:53 <ocramz> quicksilver: in an instance, you mean
08:15:59 <ocramz> or in the class body
08:15:59 <quicksilver> yes
08:16:01 <ocramz> ok
08:16:02 <quicksilver> in an instance
08:16:24 <ocramz> is this a case of "tying the knot"?
08:16:29 <quicksilver> no.
08:16:34 <quicksilver> it is just a case of making a choice.
08:16:47 <quicksilver> whichever one you define explicitly, the default in the class is entirely ignored.
08:16:56 <ocramz> ok, now I understand
08:17:00 <quicksilver> if you define both explicitly they are both ignored :)
08:17:01 <ocramz> tihs was the key bit
08:17:24 <ocramz> quicksilver: thank you. 
08:17:52 <quicksilver> :)
08:18:24 <ocramz> but what's the rationale behind declaring both, in the class body? does GHC check that they are mutually inverses?
08:18:50 <cocreature> codebje: you might have a more efficient definition than the default one
08:18:54 <cocreature> eh ocramz 
08:19:24 <ocramz> cocreature : yes? :)
08:19:25 <quicksilver> ocramz: primarily to save the author time
08:19:39 <quicksilver> ocramz: you jsut define one - whichever is easiest for your type - and the other comes automatically.
08:19:54 <quicksilver> secondarily they act as documentation on the expected relationship between the methods.
08:19:57 <quicksilver> they document the laws.
08:20:04 <ocramz> quicksilver: another very good point
08:20:46 <quicksilver> that's not enforced though
08:20:52 <quicksilver> so it's just documentation
08:23:12 <cocreature> ocramz: sorry I misread your question, I thought you were asking why you would define both manually
08:23:29 <lamefun> Is there a type for non-negative Int (i.e. with 0 minBound and (maxBound :: Int))?
08:23:44 <merijn> lamefun: Word?
08:24:00 <merijn> > maxBound :: Word
08:24:02 <lambdabot>  18446744073709551615
08:24:07 <merijn> minBound :: Word
08:24:11 <merijn> > minBound :: Word
08:24:13 <lambdabot>  0
08:24:15 <lamefun> > maxBound :: Int
08:24:16 <lambdabot>  9223372036854775807
08:24:37 <merijn> lamefun: In GHC Int is a signed machine word, Word unsigned machine word
08:25:01 <lamefun> I know.
08:25:14 <mYhOmEs> ------> //ns identify password | m $+ s $+ g mypass <---- help me about command!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
08:25:53 <merijn> lamefun: Oh, I misread your question
08:26:05 <merijn> lamefun: The simple answer: No. You'll have to define a newtype
08:26:21 <lamefun> Oh, ok. I though there's already a newtype for that somewhere.
08:26:38 <lamefun> merijn, https://github.com/merijn/validated-literals/pull/1
08:27:12 <lamefun> or is this repo already obsolete (by built-in GHC 8.0 feature or other more-used library)?
08:27:22 <mYhOmEs> "//ns identify password | m $+ s $+ g mypass" Help me plz!
08:28:23 <mauke`0> mYhOmEs: what does that have to do with haskell?
08:28:57 <liste> mYhOmEs try #freenode
08:29:28 <mauke`0> try a mirc channel if there is one
08:30:49 <ocramz> mYhOmEs : what is that expression? what sort of help do you need?
08:33:54 <ocramz> has any of you read SubHask ? what do you think of the possibility of allowing for infinite logics, e.g. for implementing computable functional equality? 
08:44:37 <infandum> Do you use Arrow or Lens more? I noticed that they can both accomplish the same task when applying functions to certain parts of a type
08:44:58 <quicksilver> Lens much more.
08:45:11 <hiptobecubic> Definitely lens
08:45:16 <ocramz> another, simpler question: what's the difference between declaring a type family at the top level rather than within the body of a class?
08:45:28 <infandum> hmm
08:45:36 <warbo> Can I use `extM d c` to override a default implementation `d :: a -> M a` with a more constrained alternative `c :: (Arbitrary a) => a -> M a`? It works for concrete types like `c :: Bool -> M Bool`, but when only giving a constraint I get "Could not deduce (Typeable b0)... The type variable b0 is ambiguous".
08:45:37 <quicksilver> if it's in the class it's associated with the class
08:45:49 <quicksilver> so  instances are attached to instances of the class
08:46:10 <quicksilver> didn't you ask that exact question a few days ago warbo?
08:46:21 <warbo> quicksilver: not quite; I'm a little bit further :)
08:46:33 <SavinaRoja> hexagoxel: are you around?
08:46:43 <quicksilver> I think the answer is still "no, contexts don't work like that, although see 'ifcxt' for a clever hack"
08:46:50 <infandum> How come the lens package advertises so much about programming "imperatively"? Looking at what it does, it very much still seems pure and functional--am I missing some imperative aspect of the library?
08:46:53 <shapr> :t ifcxt
08:46:55 <lambdabot> Not in scope: ‘ifcxt’
08:47:08 <shapr> infandum: feels closer to imperative?
08:47:13 <shapr> infandum: it is pure and functional
08:47:25 <shapr> infandum: it's also really awesome, have you tried it?
08:47:45 <warbo> quicksilver: I'm now using ifcxt, and unsafePerformIO + runtime type errors, and SYB :P
08:47:46 <hexagoxel> SavinaRoja: what's up?
08:48:06 <warbo> thinking about it, I might be able to combine them in a different order, to avoid this problem
08:48:07 <SavinaRoja> I wrote this little experimental thing to try to read a file in reverse: http://lpaste.net/4593681768925626368
08:48:09 <lyxia> lens gives operators such as += and -= which make your code look like C
08:48:35 <SavinaRoja> it's intentionally inefficient with regards to IO, but I think  I've also found that it doesn't maintain laziness
08:49:13 <SavinaRoja> and I trying to figure out why, basically
08:49:29 <aweinstock> is using BL.append in that way O(n^2)?
08:50:36 <aweinstock> SavinaRoja: the recursive invocation of readReverse (further <- readReverse h (pos-1)) happens before you return, so it won't be lazy
08:50:44 <SavinaRoja> aweinstock: perhaps
08:50:54 <aweinstock> :t System.IO.Unsafe.unsafeInterleaveIO
08:50:55 <lambdabot> IO a -> IO a
08:51:20 <aweinstock> try replacing (further <- readReverse h (pos-1)) with (further <- unsafeInterleaveIO $ readReverse h (pos-1))
08:51:25 <glguy> SavinaRoja: readFile and hGetContents are only lazy because they are explicitly written to be lazy. hGet isn't written to be lazy
08:52:07 <glguy> SavinaRoja: even if they were the way you're building up the final byte string you wouldn't benefit from it being lazy
08:52:40 <SavinaRoja> okay, this is all helpful stuff to explore
08:52:45 <aweinstock> glguy: my understanding is that unsafeInterleaveIO *is* the internal lazyness magic that readFile/hGetContents use?
08:53:15 <SavinaRoja> unfortunately i have to jet for a bit, will return to it soon
08:53:38 <aweinstock> and that oleg's written a paper about how you can use unsafeInterleaveST to write a "pure" function that isn't refferentially transparent, hence why it's dangerous
08:53:49 <mauke`0> @src hGetContents
08:53:50 <lambdabot> Source not found. I am sorry.
08:53:55 <warbo> quicksilver: I was trying to make my ifcxt function a "fallback" for an SYB-overridden function, ie. "use X if it's Bool, use Y if it's Int, use ifcxt for anything else"
08:53:58 <glguy> aweinstock: Yeah, that's right
08:54:06 <hexagoxel> http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Lazy.html#hGetContentsN
08:54:15 <warbo> I've just swapped it around, so ifcxt falls back to the SYB-style function, and that works
08:54:21 <aweinstock> found it: http://okmij.org/ftp/Haskell/#unsafeInterleaveST
08:54:27 <warbo> however, ifcxt can't actually find any instances :(
08:55:09 <warbo> scratch that, I'd commented-out mkIfCxtInstances ''Arbitrary :P
08:55:20 <aweinstock> glguy: so the modification I suggested to SavinaRoja would make it so that doing something like (take 5) to the resulting bytestring wouldn't issue a 6th BL.hGet?
08:55:22 <fr33domlover> If a function returns IO (a, b) does it require the pair elements to be evaluated? I have a case in which the second element is big but never used in 99% of the cases
08:55:52 <aweinstock> (assuming the file length is larger than 5 bytes)
08:56:01 <ocramz> fr33domlover: it depends on what's calling it
08:56:18 <glguy> aweinstock: No, I don't think so because of how the result is used
08:56:31 <aweinstock> fr33domlover: I don't think so, try something like (do { x <- return (undefined, 5); print $ snd y })
08:56:44 <mauke`0> fr33domlover: no
08:56:55 <fr33domlover> ocramz, eventually main, of course :P
08:56:57 <aweinstock> s/y/x/
08:57:01 <breadmonster> Hello there.
08:57:02 <fr33domlover> aweinstock, mauke`0, thanks
08:57:06 <fr33domlover> i'll try
08:57:25 <mauke`0> in fact, I'm pretty sure 'return undefined' is fine in IO
08:57:46 <ocramz> fr33domlover: of course, but as the others mentioned, it depends on whether the calling function actually requires the second argument. This is when it's computed
08:58:00 <ocramz> the second output, I mean
08:58:09 <aweinstock> > sequence [Just undefined, Just 42]
08:58:10 <lambdabot>  Just [*Exception: Prelude.undefined
08:58:12 <mauke`0> > evaluate (return undefined :: IO ())
08:58:14 <lambdabot>  <IO (IO ())>
08:58:23 <glguy> aweinstock: that blew up because you tried printing it
08:58:37 <aweinstock> :t sequence
08:58:38 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:58:45 <ocramz> lambdabot: sorry for trying to blow your stack up
08:58:48 <aweinstock> > last . sequence [Just undefined, Just 42]
08:58:50 <lambdabot>      Couldn't match expected type ‘a -> [c]’
08:58:50 <lambdabot>                  with actual type ‘Maybe [Integer]’
08:58:50 <lambdabot>      Possible cause: ‘sequence’ is applied to too many arguments
08:58:53 <aweinstock> > last $ sequence [Just undefined, Just 42]
08:58:53 <glguy> > fmap length (sequence [Just undefined, Just 42])
08:58:54 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘Maybe a0’
08:58:54 <lambdabot>      In the expression: Just undefined
08:58:54 <lambdabot>      In the first argument of ‘sequence’, namely
08:58:55 <lambdabot>  Just 2
08:59:34 <fr33domlover> ocramz, but does it not able to cause IO actions to run out of order?
08:59:40 <aweinstock> > fmap last $ sequence [Just undefined, Just 42]
08:59:42 <lambdabot>  Just 42
09:00:25 <ocramz> yes, if the second output does not depend on the first
09:00:49 <varaindemian> can someone explain me this function? I know the result, but I do not understand how it actually works. split [] = [] ----- split [_] = [] ----split (x:xs) = ([x], xs) : [(x:ls, rs) | (ls,rs)<- split xs]
09:00:59 <wedens> what library is currently recommended for logging?
09:01:23 <glguy> fr33domlover: evaluating of expressions is different than execution of IO. All of the execution wil be finished when the (a,b) result is returned
09:01:32 <johnw> wedens: if your needs are simple, try 'logging'; if they are complex, maybe fast-logger or monad-logger?
09:01:52 <breadmonster> varaindemian: It's impossible to read like that, can you pastebin?
09:02:24 <c_wraith> varaindemian, I don't understand why it has a special case for single element lists. other than that, it's a pretty standard function, usually called select
09:02:26 <fr33domlover> glguy, thanks
09:02:26 <mauke`0> > let split [] = []; split [_] = []; split (x:xs) = ([x], xs) : [(x:ls, rs) | (ls,rs) <- split xs] in split "abcde"
09:02:28 <lambdabot>  [("a","bcde"),("ab","cde"),("abc","de"),("abcd","e")]
09:02:38 <NemesisD> if i run cabal --version it says its using 1.23.0.0, but if i do ghc-pkg list Cabal, it shows /opt/ghc/7.8.4/lib/ghc-7.8.4/package.conf.d Cabal 1.18.0.0, should i attempt to upgrade that Cabal?
09:02:46 <c_wraith> Oh, I see
09:02:46 <mauke`0> > let split [] = []; split (x:xs) = ([x], xs) : [(x:ls, rs) | (ls,rs) <- split xs] in split "abcde"
09:02:48 <lambdabot>  [("a","bcde"),("ab","cde"),("abc","de"),("abcd","e"),("abcde","")]
09:03:06 <lpaste_> varaindemian pasted “split” at http://lpaste.net/147180
09:03:19 <varaindemian> breadmonster: http://lpaste.net/147180
09:03:22 <mauke`0> > let split [] = [([], [])]; split (x:xs) = [(x:ls, rs) | (ls,rs) <- split xs] in split "abcde"
09:03:23 <c_wraith> and it's not select, I see I missed an important details 
09:03:24 <lambdabot>  [("abcde",[])]
09:03:55 <breadmonster> What what?
09:04:11 <breadmonster> mauke`0: I think you got it wrong.
09:04:15 <mauke`0> indeed
09:05:10 <breadmonster> > let split [] = []; split (_:[]) = []; split (x:xs) = ([x], xs) : [(x:ls, rs) | (ls,rs) <- split xs] in split "abcde"
09:05:12 <lambdabot>  [("a","bcde"),("ab","cde"),("abc","de"),("abcd","e")]
09:05:30 <breadmonster> that's interesting, though you're missing the final case.
09:06:48 <mauke`0> > let split [] = [([], [])]; split (x:xs) = ([], x:xs) : [(x:ls, rs) | (ls,rs) <- split xs] in split "abcde"
09:06:49 <wedens> johnw: yeah, I need something simple. I'll check `logging`. what do you think about `logger` https://hackage.haskell.org/package/logger ?
09:06:50 <lambdabot>  [("","abcde"),("a","bcde"),("ab","cde"),("abc","de"),("abcd","e"),("abcde","")]
09:06:51 <varaindemian> breadmonster: what are ls and rs?
09:07:28 <mauke`0> > [ i | i <- [1 .. 10] ]
09:07:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:07:31 <aweinstock> varaindemian: the sublists returned from splitting the tail of the input (when it's nonempty)
09:07:44 <breadmonster> varaindemian: Try it with a pencil and paper, ls and rs are the left and right halves of the remaining substring for a given x.
09:08:55 <varaindemian> breadmonster: ok, I'll try
09:10:03 <mauke`0> > liftA2 zip inits tails "abcde"
09:10:06 <lambdabot>  [("","abcde"),("a","bcde"),("ab","cde"),("abc","de"),("abcd","e"),("abcde","")]
09:12:06 <hexagoxel> NemesisD: no. `cabal` reports what it was compiled with, while ghc-pkg reports the version of the Cabal library in your global package db. They are unrelated.
09:12:59 <johnw> mauke`0: neat
09:13:24 <NemesisD> hexagoxel: my issue is when trying to build a project with stack i get several errors saying Cabal-1.18 is unusable due to missing or recursive dependencies on bytestring,directory,process, and unix
09:13:39 <NemesisD> hexagoxel: 1.18 appears to be my global Cabal library version
09:14:40 <johnw> wedens: sure, it depends on exactly how simple your needs are; 'logging' just uses IO to do its logging, not another transformer, which isn't as flexible, but mean you don't need a transformer stack just to do some simple loggin
09:17:13 <hexagoxel> NemesisD: sorry, my stack knowledge is too little to help.
09:17:30 <johnw> there is also #haskell-stack
09:17:42 <NemesisD> yeah i'm asking in there too
09:17:51 <hexagoxel> (can you even use ghc-pkg to examine stack dbs?)
09:18:14 <varaindemian> breadmonster: oh god, I still can't figure out how it works, all those parentheses and cons'es...
09:20:31 <wedens> johnw: ok. thanks
09:24:22 <geekosaur> for those wondering about ghc8, "If things go according to plan we'll branch on Tuesday"
09:24:59 <NemesisD> i don't know. its layers and layers of magic
09:30:19 <sm> hexagoxel: of course: stack exec -- ghc-pkg ...
09:33:15 <warbo> Very strange, I thought my code wasn't working, but in fact `vectorOf 100 (arbitrary :: Gen Integer)` is giving me lists of 100 zeros every time...
09:33:53 <warbo> maybe I've broken something by using IncoherentInstances?
09:39:13 <SavinaRoja> reviewing the logs
09:43:16 <maerwald> why is unsafeInterleaveIO called "unsafe"? Because it's not predictable wrt to laziness?
09:43:37 <varaindemian> breadmonster: split [1,2,3] = ([1], [2,3]):  [(1:[2], [3])]
09:43:42 <varaindemian> right?
09:44:07 <monochrom> it can be used to break "f 5 is always the same"
09:44:14 <c_wraith> maerwald, because it can be used to make the results of evaluation depend on evaluation order. 
09:44:28 <johnw> maerwald: when you use a function beginning with "unsafe", you relinquish certain guarantees; it's as unsafe as your lack of knowledge about exactly what you're losing and why
09:45:09 <maerwald> well, I'm readying the filesystem lazily into a complete tree, so I use it and I am aware that the contents of the tree will depend on when I look at it
09:45:13 <maerwald> that's sort of expected
09:45:33 <varaindemian> Anyone can explain me this function? split [1,2,3] = ([1], [2,3]):  [(1:[2], [3])]
09:45:36 <johnw> maerwald: btw, pipes-files is designed to do exactly this: lazy reading of file hierarchies
09:45:38 <varaindemian> Anyone can explain me this function? split [1,2,3] = ([1], [2,3]):  [(1:[2], [3])]
09:45:43 <varaindemian> sorry
09:45:58 <maerwald> johnw: my implementation is already complete, why should I switch?
09:46:05 <johnw> oh, in that case don't
09:46:16 <varaindemian> http://lpaste.net/147180
09:46:38 <warbo> maerwald: "unsafe" just means that Haskell (GHC, etc.) can't guarantee that the code is well-behaved
09:46:54 <maerwald> it is based on the directory-tree package
09:47:01 <maerwald> @hackage directory-tree
09:47:01 <lambdabot> http://hackage.haskell.org/package/directory-tree
09:47:02 <warbo> maerwald: if you have some separate guarantee, e.g. done with pen+paper, then it's still safe
09:47:40 <warbo> maerwald: of course, it depends what properties constitute "safe"/"well-behaved"
09:52:47 <hexagoxel> package inline-c: can i capture the name/function-ptr of a C.block?
09:53:41 <hexagoxel> the readme tells how to call haskell back from c-code, but that seems to introduce an unnecessary round-trip if i want a "dynamic" c -> c call.
09:54:04 <ocramz> hexagoxel: as in `potato x = [C.block|potato($(int x))|]` ?
09:54:24 <ocramz> sorry, should be C inside the [| |]
09:54:39 <ocramz> int potato();
09:55:01 <ocramz> or, you'd like a quasiquoter for the C function name?
09:56:45 <hexagoxel> ocramz: wait, how is `potato` in scope inside c?
09:57:17 <ocramz> hexagoxel, it's not, sorry; let's call it `c_potato()`
09:58:16 <ocramz> there's a `funCtx` for when you need to wrap C callbacks, but I don't think it applies here
09:58:59 <ocramz> the inline-c-ode github repo has an example
09:59:25 <hexagoxel> ocramz: how about something like callIndirect f x = [C.block|($(int (*)(int) f)($(int x))|]
09:59:37 <hexagoxel> (i bet i messed up the c type signature..)
09:59:43 <Ankhers> http://lpaste.net/147190 -- Pretend there are valid instances for Persistent.
10:00:11 <ocramz> hexagoxel: exactly, this is what the `funCtx` is for
10:00:15 <hexagoxel> and somehow call this like callIndirect (_ [C.block|...|]) _
10:01:19 <maerwald> johnw: I made a "lazy" zipper which drops into random depth of the filesystem and constructs the "breadcrumbs" lazily without traversing to it from "/" :D
10:01:23 <maerwald> lazy-ception
10:02:26 <warbo> d'oh! I was only getting zeros due to QuickCheck's size parameter starting at zero; since QuickCheck aborted on the first failure, it never got as far as generating anything else :P
10:02:55 <Sonolin> anybody here know why xmonad code is littered with parameters of "Stack a" as well as the list of windows & rectangles?
10:02:59 <Sonolin> feels a little redundant
10:03:09 <hexagoxel> ocramz: but won't that go haskell->c->haskell->c, instead of haskell->c->c ?
10:03:44 <hexagoxel> ocramz: or maybe it does, but is mostly irrelevant, performance-wise?
10:09:45 <hexagoxel> ocramz: does my question make sense?
10:10:38 <ocramz> hexagoxel: not yet :D what are you concerned about?
10:12:43 <ocramz> hexagoxel: ah, now I got it, maybe. So you have data AND functions both on the Hs and the C side. If we wrap a C function that takes a callback, how many times do the data cross the FFI?
10:13:43 <begriffs> Is there a way to get a module's name as a string? Something like (name My.Module.Foo) == "My.Module.Foo" ?
10:14:10 <ocramz> sounds like a job for TH
10:14:28 <pikajude> $(thisModule)!
10:15:20 <hexagoxel> ocramz: uhm, yeah, my current understanding is that you need to have the callback on both the Hs and the C side, and I am wondering if i can avoid the FFI crossing.
10:15:30 <fresheyeball> hello out there, I need to parse some badly formatted JSON 
10:15:35 <fresheyeball> and could use some advice 
10:15:56 <fresheyeball> { "0" : "foo", "1", "bar" } is the json
10:16:00 * hackagebot feed-collect 0.2.0.0 - Watch RSS/Atom feeds (and do with them whatever you like).  https://hackage.haskell.org/package/feed-collect-0.2.0.0 (akrasner)
10:16:02 <fresheyeball> and I need it as [String]
10:16:09 <fresheyeball> ["foo", "bar"]
10:16:14 <begriffs> The scenario is that I have a bunch of modules each with feature specs. I'd like to list all the modules and loop over them, running a function from each and using the module's name.
10:16:15 <fresheyeball> any recommendations?
10:16:59 <Ankhers> fresheyeball: Did you mean { "0": "foo", "1": "bar" } ?
10:17:06 <ocramz> hexagoxel: I think it depends; certain operations on e.g. Storable arrays can be done with foreign pointers without copying
10:17:13 <aweinstock> fresheyeball: do you have a grammar for "badly formatted JSON"?
10:17:15 <geekosaur> Ankhers: note "badly formatted"
10:17:22 <geekosaur> they want to try to extract sense out of garbage
10:17:26 <fresheyeball> Ankhers yes that is the json 
10:17:34 <fresheyeball> roughly
10:17:53 <fresheyeball> no, I just have Aeson and my records 
10:17:59 <aweinstock> it's not JSON if it's syntactically invalid, it's ascii text that happens to resemble JSON
10:18:02 <Ankhers> geekosaur: badly formatted and invalid are two different things though.
10:18:41 <geekosaur> formatting, badly or otherwise, shouldn't matter for parsing, so I assume "invalid" is intended
10:18:53 <fresheyeball> { "0": "foo", "1": "bar" } is absolutely valid json
10:19:04 <Ankhers> fresheyeball: You didn't write that the first time.
10:19:05 <aweinstock> it's possible that they meant badly formatted, and typo'd invalid json?
10:19:26 <Ankhers> fresheyeball: You wrote a comma instead of the second colon.
10:19:26 <geekosaur> maybe show an actual example?
10:19:28 <geekosaur> @lpaste
10:19:29 <lambdabot> Haskell pastebin: http://lpaste.net/
10:19:29 <fresheyeball> oh, yeah, you are right, I typed it wrong the last time
10:19:55 <johnw> if you use lens-aeson, then: "{ \"0\": \"foo\", \"1\": \"bar\" }" ^.. members._String
10:20:06 <johnw> gives result ["foo", "bar"]
10:20:16 <ocramz> hexagoxel: do you have a MWE I can look at, perhaps? 
10:20:20 <ReinH> johnw: not for the actuall invalid json
10:20:25 <fresheyeball> http://lpaste.net/147192
10:20:30 <fresheyeball> the json is valid json
10:20:33 <Ankhers> ReinH: There is no invalid JSON here though.
10:20:34 <fresheyeball> just annoying formatted
10:20:48 <fresheyeball> annoyingly*
10:20:55 <ReinH> { "0" : "foo", "1", "bar" } is invalid?
10:21:07 <Ankhers> ReinH: That is. But that was a typo.
10:21:11 <ReinH> ok
10:21:15 <aweinstock> :t Data.Aeson.Lens.members
10:21:17 <lambdabot> Not in scope: ‘Data.Aeson.Lens.members’
10:21:20 <fresheyeball> it is, the second `,` should have been a `:` which was a typo on my part
10:21:44 <fresheyeball> any way to do this without lenses? I am not super familiar with Lenses yet
10:21:56 <hexagoxel> ocramz: gimme some time :)
10:23:12 <SavinaRoja> unsafeInterleaveST and unsafeInterleaveIO sections of http://okmij.org/ftp/Haskell/ are fascinating
10:23:17 <indiagreen> fresheyeball: import qualified Data.HashMap.Strict as HM; (HM.values yourJson) would give you the values
10:23:41 <fresheyeball> ok that helps
10:24:49 <indiagreen> fresheyeball: note that those values would be JSON values; if you know that they all are strings and you want to get [Text], you'd have to do something like [x | String x <- HM.values yourJson]
10:25:15 <SavinaRoja> the author mentions that there are many options for incremental file processing in haskell aside from lazy IO, I should look into these
10:25:59 <indiagreen> fresheyeball: oh, and if yourJson is a Value and not an Object, you'd need to pattern-match it too
10:26:20 <fresheyeball> right ok, give me a sec to try the HashMap approach 
10:26:48 <ocramz> hexagoxel: take your time; I've had to write a sizable heap of inline-c but I'm not a guru; however feel free to either leave me a message here or ping me on reddit (same nick)
10:27:32 <aweinstock> SavinaRoja: pipes/conduit are the two main libraries for that these days
10:27:38 <Ankhers> I'm creating a JSON api. Is it possible to conditionally include a functions output in the resulting JSON without having to edit my instance of ToJSON? 
10:27:54 <benzrf> Ankhers: elaborate?
10:28:27 <Ankhers> benzrf: Let me write a quick paste.
10:29:21 <SavinaRoja> aweinstock: thanks
10:29:29 <fresheyeball> indiagreen: thank you so much for the help, luckily its an object so it should be fine
10:32:35 <fresheyeball> indiagreen: HM has no member `values`
10:32:44 <indiagreen> fresheyeball: maybe “elems”
10:33:13 <indiagreen> yeah, elems
10:33:43 <Ankhers> benzrf: http://lpaste.net/147193 -- I hope that conveys what I am looking for a little more.
10:39:52 <hexagoxel> ocramz: http://lpaste.net/1705206044914876416
10:42:00 <hexagoxel> ocramz: as i said, i don't even know if this is worth pursuing; there just seems to be a trivial shortcut possible by somehow exposing the c function name.
10:42:32 <fresheyeball> indiagreen: frustrating... `decode bs :: Maybe (HM.HashMap String String) = Nothing`
10:42:52 <fresheyeball> I don't understand how that can even fail 
10:44:27 <indiagreen> fresheyeball: hm, it worked for me
10:44:35 <ocramz> hexagoxel: so you want to fmap on the C side
10:44:36 <ocramz> ?
10:44:58 <hexagoxel> ocramz: the actual functionality is just an example.
10:45:10 <indiagreen> fresheyeball: http://lpaste.net/147197
10:45:26 <hexagoxel> walking on the line between minimal and expressing my intend :D
10:47:09 <Perdulous> Test
10:48:09 <fresheyeball> indiagreen: you are right, but its not working with my actual json
10:48:10 <fresheyeball> http://lpaste.net/147192
10:48:18 <fresheyeball> I don't see the difference 
10:48:34 <indiagreen> fresheyeball: your JSON is more like HashMap String Value
10:49:11 <fresheyeball> http://lpaste.net/5502974629511168000
10:49:13 <fresheyeball> hmm ok
10:50:05 <fresheyeball> indiagreen: that worked! out thank goodness
10:50:10 <hexagoxel> ocramz: i don't wish to take too much of your time, so if my question is not clear yet, i should just try things out.
10:50:12 <fresheyeball> oh* thank goodness
10:51:01 * hackagebot niagra 0.0.1 - CSS EDSL for Haskell  https://hackage.haskell.org/package/niagra-0.0.1 (natesymer)
10:52:32 <fresheyeball> indiagreen: last question, how do I go from `Value -> MyType` ?
10:55:27 <fresheyeball> indiagreen: disregard, I found it
10:55:31 <breadmonster> Hey guys.
10:57:47 <johnw> hi breadmonster 
10:57:58 <breadmonster> Hello johnw 
10:59:48 <SavinaRoja> learning haskell is a bit like tvtropes
11:00:47 <SavinaRoja> you start reading and become engrossed, then you just lose all track of time
11:01:01 * hackagebot wolf 0.2.3 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.3 (markfine)
11:01:03 * hackagebot ghc-options 0.2.0.0 - Utilities for extracting GHC options needed to compile a given Haskell target.  https://hackage.haskell.org/package/ghc-options-0.2.0.0 (ranjitjhala)
11:02:01 <roelof> anyone who uses a cloud enviroment like nitrious.io or koding.com ? if so, which cloud enviroment is the best ? 
11:02:20 <johnw> roelof: are you asking that in relation to Haskell?
11:02:35 <roelof> yep
11:02:35 <bashed> Can I convert an FunPtr (Object -> IO Object) to a FunPtr (IO Object) ?
11:05:26 <roelof> I like to learn Haskell and use a cloud ide for it because I work on Windows 
11:06:42 <Maxdamantus> @djinn [Int -> [Int]] -> [[Int]]
11:06:43 <lambdabot> Error: Undefined type []
11:07:11 <carmethene> roelof: I know it's not quite what you're asking, but I'm mainly using it on a linux machine 'in the cloud' from my Windows box
11:07:29 <carmethene> ssh (well mosh for Chrome) + vim + tmux + ghc
11:07:44 <carmethene> virtual private servers start from about $5/month
11:08:39 <carmethene> that way I can access my environment from wherever I travel, and I don't have to deal with the Windows shell
11:09:12 <kadoban> bashed: I suspect that doesn't make sense to try to do. I'm not all that familiar with the types though.
11:10:51 <roelof> oke, I have used fpcomplete but they shutting down thier haskell development ide :( 
11:11:52 <breadmonster> roelof: WHAT SAY IT ISN'T SO D:
11:12:26 <roelof> breadmonster:  then im confused, They said it themselves 
11:12:37 <kadoban> Yeah they announced that a while back, just the web IDE thing.
11:12:43 <roelof> and there is also no link to my "old" project 
11:12:46 <bashed> The reason behind it is that I have a c function that requires a function of type FunPtr (IO a) and the number of arguments that the exported function takes. However, I have no idea how I should approach that within haskell. 
11:13:06 <the_2nd> newtype Name = Name String
11:13:19 <the_2nd> now if I define functions with Name, String cant be passed
11:13:19 <breadmonster> roelof: No, I meant that metaphorically.
11:13:29 <the_2nd> but can Name be used in String functions?
11:13:31 <bashed> I mean, I am not sure how I can make a function with variable arguments and create a function pointer with that type. 
11:14:05 <roelof> breadmonster:  then I do not understand what you mean with  your remark what say it is not so 
11:14:09 <kadoban> the_2nd: Yes, but you have to unwrap and then rewrap.
11:14:33 <breadmonster> roelof: It's an English idiom, meaning that you are bringing bad news.
11:15:07 <Ankhers> the_2nd: Depending on your use case, you may be able to use `type Name = String'.
11:15:15 <roelof> oke,  then im sorry 
11:15:25 <kadoban> the_2nd: If you want you could write a function :: (String -> String) -> Name -> Name -- I guess
11:16:24 <the_2nd> Ankhers, kadoban I guess this is fine for now:
11:16:27 <the_2nd> Type Pixels = Int
11:16:27 <the_2nd> Type Radians = Double
11:16:27 <the_2nd> Type Angles = Double
11:16:41 <the_2nd> *Angles = Degrees
11:19:22 <Hijiri> bashed: I don't think you can, you have to know that the arguments are marshallable
11:19:36 <Hijiri> I think the closest you can get is change the type variables to be StablePtr of them
11:19:56 <roelof> oke, then I have to use google and hope I can find a good cloud thing to start my haskell journey 
11:20:13 <kadoban> roelof: Just install linux in a VM?
11:20:17 <Hijiri> since you can make a StablePtr from any expression, and StablePtr a is marshallable for any a
11:20:25 <kadoban> roelof: Or I think you can use windows, it's just a bit fugly once in a while.
11:25:17 <carmethene> roelof: have you tried Sublime Text?
11:25:28 <carmethene> it's pretty wonderful
11:26:26 <kadoban> roelof: What's the problem you've had just using the tools on windows? Might be a good place to start. There's probably some way to get it working acceptably without being forced to work in the cloud.
11:28:10 <bashed> Not sure who recommended me to use StablePtr but thanks. I think I can use that for my purpose. 
11:29:53 <bitemyapp> roelof: I agree with kadoban. You're better off getting native tools sorted.
11:30:16 <bitemyapp> roelof: it was a few weeks ago and I've only done it once, but I got Emacs/Sublime Text + Stack + Mingw working on Windows 8.
11:30:28 <bitemyapp> roelof: mostly required futzing around with the Windows and mingw/bash pathing IIRC
11:30:38 <bitemyapp> oh and in the git bash too
11:30:46 <bitemyapp> after that, was fine.
11:30:53 <bitemyapp> not to my taste, but fine for working on Haskell projects.
11:30:54 <roelof> git bash is already installed 
11:31:06 <bitemyapp> I basically just needed a bash shell with stack and git.
11:32:39 <roelof> oke, I was just looking if docker could do it for me. I know codeenvy I can use a haskell docker image 
11:32:58 <bitemyapp> if you're happy using Docker, I won't steer you away from that.
11:33:12 <bitemyapp> I just know that for me personally, I prefer my software runs natively in my dev environment.
11:36:03 * hackagebot ua-parser 0.7 - A library for parsing User-Agent strings, official Haskell port of ua-parser  https://hackage.haskell.org/package/ua-parser-0.7 (MichaelXavier)
11:41:14 <roelof> bitemyapp:  Im just checking things 
11:45:18 <typedeph> is there anyway to make this IO read more concise: [m, n] <- fmap (fmap read . words) getLine :: IO [Int]
11:45:32 <typedeph>  /readable
11:50:58 <aweinstock> typedeph: [m,n] <- (map read . words) <*> getLine :: IO [Int] -- this is slightly golfier?
11:51:17 <maerwald> I'd use <$> for the outer fmap
11:51:22 <frerich> typedeph: I think I'd write 'map read <$> words <$> getLine'
11:51:48 <frerich> typedeph: The inner fmap is generic for no good reason, I'd use a plain 'map' there in any case.
11:52:11 <maerwald> uh
11:52:15 <maerwald> being more generic is good
11:52:42 <kadoban> maerwald: Not always. Here it's just harder to read.
11:52:48 <frerich> maerwald: Then why not write 'fmap (fmap (fmap read) words)'
11:52:59 <maerwald> kadoban: I disagree
11:53:05 <frerich> maerwald: Function composition is just a special case of fmap'ing clearly, and more generic is good.
11:53:45 <maerwald> frerich: my point was that using map over fmap doesn't give you anything
11:53:49 <maerwald> I never use map
11:53:54 <Welkin> map is for lists 
11:53:55 <Welkin> :D
11:54:04 <frerich> maerwald: 'map' is shorter, and it tells you more about the types of the arguments.
11:54:28 <typedeph> aweinstock seems the cleanest?
11:54:47 <typedeph> my goal is to read input consisting of something like
11:54:51 <maerwald> frerich: then you probably write "wrappers" for all fmaps you ever use on any data structure, do you? 
11:54:51 <typedeph> 2 4
11:54:55 <aweinstock> mine is a very minor "improvement" over yours, and yours was fine as-is
11:54:59 <typedeph> 1 2 3 4 5 6 3 4 2
11:55:03 <typedeph> two lines
11:55:09 <aweinstock> (also, I made a typo, i meant <$> instead of <*>)
11:55:10 <maerwald> frerich: at that point, you could do the same for function composition ;)
11:55:13 <maerwald> doesn't make sense
11:55:33 <typedeph> I asked a while back and someone impressed me with a single line fmap
11:55:56 <typedeph> keep in mind I'm a newbie, so a lot impresses but beside the point...
11:56:02 <kadoban> typedeph: By the way, in case it's not clear, that's going to handle errors in input very poorly.
11:56:08 <frerich> maerwald: Not sure what you're getting at - my point is exactly that a plain '.' or 'map' is easier for your brain than just 'fmap' all over.
11:56:13 <typedeph> poor pattern matching I know
11:56:42 <frerich> typedeph: I'd go with whatver which doesn't require too much mental gymnastics for you (or your fellow colleagues) to read. If it turns out to be a mental speed bump when reading, you're doing it wrong.
11:56:48 <typedeph> but if I do it another way i'd have to do it in some type of C style read a line and parse the tokens
11:57:22 <typedeph> nvm I'm already doing that
11:57:30 <typedeph> its just more lines for proper binding
11:57:49 <kadoban> typedeph: You can use one of the parser combinators if it gets more complicated, or if you want to handle bad input better.
11:57:55 <typedeph> I'm doing this for reading input for algorithm practice questions
11:58:01 <kadoban> typedeph: But probably not necessary for a toy, just … thought I should point it out.
11:58:13 <typedeph> I'll definitely keep that in mind
12:03:08 <Fuco> is there some built-in way to and/or predicates, like [a -> Bool] -> a -> Bool
12:03:11 <typedeph> I'm pulling hairs at this point but I would assume map read <$> words <*> getLine is cleaner than map read . words <*> getLine
12:04:13 <typedeph> my bad second one was map read . words <$> getLine
12:05:42 <Welkin> what do you mean by "cleaner"?
12:05:52 <Welkin> choose whatever is easiest to understand
12:06:24 <dmwit> Those aren't the same thing, and neither of them is correct.
12:06:35 <typedeph> yea just realized that now also
12:09:26 <fiddlerwoaroof> Is there a way to use stack or cabal to build something from Hackage and make a redistributable tarball with all of its dependencies?
12:09:47 <dcoutts> fiddlerwoaroof: you mean as source, or binary?
12:09:51 <fiddlerwoaroof> binary
12:09:55 <Welkin> lol
12:09:57 <Welkin> just compile it
12:10:38 <fiddlerwoaroof> So compilation won't produce any .so s?
12:10:42 <dmwit> The one benefit of static-linking-as-default...
12:10:48 <fiddlerwoaroof> ok
12:11:07 <dcoutts> fiddlerwoaroof: right, for static linking, just build it. You can make an image dir (that you can tar up), like so: cabal configure --prefix=$ultimate-target; cabal build; cabal copy --dist-dir=$imagedir
12:11:08 <fiddlerwoaroof> Thanks
12:11:51 <dcoutts> fiddlerwoaroof: that will put it into that image dir, with the layout you want for the target system (which you can tweak with other configure flags). Then just tar/zip that image dir up and deploy it
12:12:04 <dmwit> Whoa, neat, didn't know about cabal copy (and have wanted it in the past).
12:12:28 <dcoutts> dmwit: it's been there since forever, and Setup has had it before that
12:13:00 <verement> Fuco: \fs x -> and $ map ($ x) fs
12:13:02 <dcoutts> classically ./Setup install was just copy + register
12:13:05 <dmwit> I believe it. I am constantly learning about fancy corners of cabal that have been around forever.
12:13:26 <verement> :t \fs x -> and $ map ($ x) fs
12:13:27 <lambdabot> [a -> Bool] -> a -> Bool
12:13:36 <dmwit> verement: and . map f === all f
12:13:40 <dcoutts> fiddlerwoaroof: if you use libs that have data files then it's a bit more tricky, you need to arrange for those data files to end up in the image too
12:13:52 <dmwit> verement: so `\fs x -> all ($x) fs` would be an alternate spelling.
12:13:58 <verement> perfect
12:14:04 <Peaker> dmwit: I think "cabal install" is basically an alias for "cabal copy && cabal register"
12:14:23 <dcoutts> Peaker: actually that's not true, since install does deps too
12:14:29 <Fuco> heh, little $ being useful for once :)
12:14:33 <lspitzner> and configure and build
12:14:35 <dmwit> Peaker: No way, `cabal install` also does dependency installation, configure, and build!
12:14:45 <dcoutts> but it is true of the old ./Setup cli
12:15:50 <Peaker> ah, right, install invokes all the prerequisites and then does the "install" itself (which is copy&register)
12:18:51 <aweinstock> :t flip $ all . ($)
12:18:53 <lambdabot> Foldable t => t a -> (a -> Bool) -> Bool
12:19:37 <aweinstock> :t all . (flip ($))
12:19:38 <lambdabot> Foldable t => a -> t (a -> Bool) -> Bool
12:20:21 <aweinstock> :t all . flip id
12:20:23 <lambdabot> Foldable t => b -> t (b -> Bool) -> Bool
12:20:49 <the_2nd> If I have a data with a function as member
12:20:56 <the_2nd> can I still derive from show somehow?
12:21:05 <the_2nd> or is this not possible?
12:21:16 <dmwit> the_2nd: You can ignore the function, or if the function has smallish domain you can use the universe package.
12:21:21 * hackagebot SciFlow 0.4.0 - Scientific workflow management system  https://hackage.haskell.org/package/SciFlow-0.4.0 (kaizhang)
12:21:23 <dmwit> ?hackage universe-reverse-instances
12:21:23 <lambdabot> http://hackage.haskell.org/package/universe-reverse-instances
12:21:46 <the_2nd> dmwit, I need to show it, tho
12:22:00 <dmwit> the_2nd: Yes, and...?
12:22:20 <the_2nd> maybe I will just define a data FuncType = f1 | f2 | f3   and a function which reacts on the cases
12:23:16 <geekosaur> iirc Data.Function has a dummy function instance?
12:23:24 <dmwit> I don't understand you. I think it is possible that this is because you don't understand me.
12:23:53 <dmwit> However, I'm not sure which part to clarify.
12:24:12 <geekosaur> the universe package can derive Show for a function if it is monomorphic and its inputs and outputs have Univer instances (i.e. can be enumerated)
12:24:17 <geekosaur> *Universe
12:24:43 <dmwit> Inputs must be Finite, outputs can be anything.
12:25:12 <geekosaur> I guess it wasn't Data.Function that has the dummy instance
12:25:23 <geekosaur> (it just makes the string "<function>")
12:25:49 <geekosaur> you could create that instance yourself though
12:26:19 <geekosaur> ...but I think it still won't work if the function is polymorphic
12:26:48 <indiagreen> geekosaur, the_2nd: it's in Text.Show.Functions
12:48:52 <ocramz> anyone familiar with `subhask` here?
12:51:22 * hackagebot ciphersaber2 0.1.1.2 - Implementation of CipherSaber2 RC4 cryptography.  https://hackage.haskell.org/package/ciphersaber2-0.1.1.2 (BartonMassey)
13:10:43 <Guest74615> hey
13:12:45 <athan> Hi Guest74615
13:13:31 <Guest74615> hey
13:14:06 <Guest74615> first time here, what do you guys talk about?
13:14:19 <benzrf> Guest74615: haskell, mostly
13:14:21 <benzrf> :D
13:15:05 <Guest74615> I am trying to understand haskell
13:15:10 <Guest74615> :)
13:16:37 <zv> Good luck
13:17:01 <athan> Guest74615: Fear not, be brave!
13:17:08 <aweinstock> Guest74615: do you have any specific questions at the moment?
13:17:12 <Guest74615> what are the DOS tools?
13:17:16 <maerwald> do we have BiMonads?
13:17:18 <Welkin> what? DOS?
13:17:54 <Guest74615> Denial of Service = DOS
13:18:34 <aweinstock> you could probably write those in haskell if you wanted to, but most people write those in C
13:19:22 <rom1504> what's a denial of service tool ?
13:19:23 <Guest74615> currently learning Java
13:19:33 <Guest74615> Oops Python
13:20:41 <johnw> maerwald: what woul the type of bibind be?
13:20:47 <aweinstock> rom1504: a tool that launches a denial of service attack (e.g. via SYN floods or something)
13:21:09 <Guest74615> In computing, a denial-of-service (DoS) attack is an attempt to make a machine or network resource unavailable to connected to the Internet
13:21:13 <johnw> maerwald: are you thinking of something like p a b -> (a -> b -> p c d) -> p c d?
13:21:53 <rom1504> ok
13:22:08 <rom1504> must not be very interesting code
13:23:06 <johnw> maerwald: http://stackoverflow.com/questions/13556314/biapplicative-and-bimonad
13:23:27 <aweinstock> rom1504: if a specific type of server crashes with a segfault when given a specifically malformed input, the research/code for generating that input can be kind of interesting
13:23:36 <johnw> the give l a b -> (a -> l c d) -> (b -> r c d) -> l c d which sounds better
13:24:20 <maerwald> johnw: actually, I want something like: onLeft :: Either a b -> (a -> IO c) -> IO c, but I thought there might already be something like that
13:24:57 <johnw> what happens when it's a Right?
13:25:02 <maerwald> return ()
13:25:05 <maerwald> something like that
13:25:09 <johnw> ah, of course
13:25:56 <maerwald> I mean, I can write it using "either"
13:25:56 <johnw> well, () is not 'c'
13:25:57 <maerwald> but...
13:26:25 <maerwald> then I need to specify the (\_ -> return ()) thing
13:26:29 <johnw> if you can write it with either, why would you need a new concept like Bimonad?
13:26:34 <maerwald> :D
13:26:37 <johnw> so just define an onLeft function
13:27:03 <maerwald> that's the easy solution ;/
13:27:05 <johnw> but still, your type is partial
13:27:12 <johnw> or rather, any implementation of it must be
13:32:08 <maerwald> johnw: onLeft :: MonadPlus m => Either a b -> (a -> m c) -> m c
13:32:20 <maerwald> then mzero on Right
13:32:49 <maerwald> but I think it can still be more general than Either
13:33:04 <johnw> do you need it to be, or do you just want it to be?
13:33:20 <maerwald> it would make me happy :)
13:33:55 <maerwald> unless it's an edward solution I don't understand :D
13:36:24 * hackagebot parseargs 0.2.0.4 - Full-featured command-line argument parsing library.  https://hackage.haskell.org/package/parseargs-0.2.0.4 (BartonMassey)
13:36:47 <maerwald> :t biforM
13:36:49 <lambdabot>     Not in scope: ‘biforM’
13:36:49 <lambdabot>     Perhaps you meant one of these:
13:36:49 <lambdabot>       ‘iforM’ (imported from Control.Lens),
13:37:07 <Cale> Perhaps you can replace all the occurrences of (->) with Arrow as well just because it's more general then ;)
13:37:33 <maerwald> excellent idea!
13:37:34 <johnw> maerwald: there is a biforM in the 'bifunctors' package
13:37:45 <maerwald> johnw: yep, I'm looking at that right now
13:38:42 <johnw> Cale: :)
13:38:43 <Cale> Either is at least morally a coproduct, it already has a nice universal property. I'm not sure I'd be so quick to try to generalise over it.
13:39:14 <frerich> maerwald: So you applied the suggestion to replace all occurences of (.) with fmap yet? ;-) Going from 'map' to 'fmap' is only the first step!
13:39:36 <maerwald> frerich: working on that!
13:40:08 <maerwald> johnw: well, it really doesn't work with applicative, I need bimonad
13:40:47 <maerwald> Expected type: IO (), Actual type: IO (Either () d0)
13:42:08 <johnw> it sounds a bit like a solution in want of a problem...
13:42:33 <frerich> Speaking of which... can anybody think of nice use cases for mapAccum(L|R)?
13:42:40 <maerwald> investigating types doesn't need a problem
13:44:00 <johnw> frerich: when you want to fold and map at the same time :)
13:44:42 <the_2nd> couldnt match MyType with IO MyType
13:44:53 <frerich> johnw: Yeah, well - I guess if I want that, I might actually (on really crazy nights) consider using... a fold and then map. :-]
13:45:10 <geekosaur> the_2nd, sounds like you;re missing a >>=
13:45:21 <aweinstock> :t mapAccumL
13:45:23 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:45:31 <johnw> frerich: you pay the double-traversal then, don't you?
13:46:06 <frerich> johnw: I thought that since a map is a fold, it all fuses nicely (I somehow have 'foldr is a good consumer & good producer' in the back of my head, but I may be terribly mistaken)
13:46:26 <aweinstock> :t mapAccumL (\i x -> (i+1, (i,x))) 0
13:46:27 <lambdabot> (Num t1, Traversable t) => t t2 -> (t1, t (t1, t2))
13:46:42 <aweinstock> > mapAccumL (\i x -> (i+1, (i,x))) 0 "hello"
13:46:43 <lambdabot>  (5,[(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')])
13:46:47 <johnw> I don't think there is anything like fold+fold fusion, or else we wouldn't need libraries like "foldl" to avoid multiple traversal
13:47:16 <aweinstock> frerich: it's a very nice complicated way to say (zip [0..]) :)
13:47:47 <frerich> aweinstock: Well yaeh but it fits johnw's comment, "hello" is probably only traversed once to get the zip and the length.
13:48:18 <the_2nd> geekosaur, I actually need an IO MyType
13:48:28 <the_2nd> but my function returns a MyType
13:50:02 <the_2nd> geekosaur, http://lpaste.net/1606760923429601280
13:50:47 <geekosaur> I think you want fmap there
15:54:07 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
15:54:07 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
15:54:58 <Welkin> mgsloan: is there an interactive way to create a new stack project?
15:55:16 <Welkin> using `stack new projectname` is terrible compared to `cabal init`
15:55:29 <Welkin> I have to manually fill in information in the generated files
15:55:41 <Welkin> when the program should do that for me
15:55:52 <Welkin> "Author name here" etc...
15:55:58 <dmwit> begriffs: I don't know of a tool for that. It would be nice to be able to do a "test upload" to see if something builds before pushing it live.
15:56:13 <begriffs> I could try uploading a candidate package I guess
15:56:24 <dmwit> That sounds promising.
15:57:09 * hackagebot irc-fun-client 0.4.0.0 - Another library for writing IRC clients.  https://hackage.haskell.org/package/irc-fun-client-0.4.0.0 (akrasner)
16:03:36 <mgsloan> Welkin: You can add defaults in your config.yaml - http://docs.haskellstack.org/en/stable/yaml_configuration.html#templates
16:07:22 * hackagebot settings 0.2.2.0 - Runtime-editable program settings.  https://hackage.haskell.org/package/settings-0.2.2.0 (akrasner)
16:12:15 <pyon> Is there ever a use case for a higher-kinded type constructor, whose type function arguments aren't constrained in some way? (Free morally has a Functor constraint on its type argument, any monad transformer has, again morally, a Monad constraint on its type argument, etc.)
16:13:34 <shachaf> The type constructor doesn't have any constraints.
16:13:42 <shachaf> I don't know what it means that it morally does.
16:14:29 <shachaf> But maybe Yoneda is an answer to your question.
16:14:38 <pyon> Ah!
16:14:53 <bitemyapp> pyon: yo-need-a answer?
16:15:04 <pyon> :-p
16:17:22 * hackagebot irc-fun-bot 0.5.0.0 - Library for writing fun IRC bots.  https://hackage.haskell.org/package/irc-fun-bot-0.5.0.0 (akrasner)
16:18:42 <dmwit> Does Yoneda not "morally" have a Contravariant constraint on its argument?
16:18:55 <dmwit> I'm making a guess at what is moral and immoral, here.
16:19:03 <nineonine> hey everyone
16:19:12 <shachaf> dmwit: Which Yoneda are you talking about?
16:19:12 <nineonine> could someone help me with understanding freemonads ?
16:19:36 <nineonine> im particularly intereted in the ‘id’ function in smart constructors 
16:19:51 <nineonine> whats the point of adding ‘id’ thtere ?
16:19:54 <nineonine> there*
16:20:16 <nineonine> data RedditF m a where
16:20:21 <nineonine> RunRoute :: FromJSON b => Route -> (b -> a) -> RedditF m a
16:20:27 <nineonine> runRoute r = RedditT $ liftF $ RunRoute r id
16:20:57 <nineonine> why would we need that (b -> a) ?
16:21:05 <nineonine> if we just use ‘id’ 
16:21:18 <dmwit> shachaf: The top hit from Hoogle: https://hackage.haskell.org/package/kan-extensions-4.2.3/docs/Data-Functor-Contravariant-Yoneda.html#t:Yoneda
16:21:22 <shachaf> I don't know the context, but that looks like a Coyoneda-style thing.
16:21:43 <shachaf> dmwit: Maybe for Data.Functor.Contravariant.Yoneda, sure, but not for the covariant one.
16:21:54 <geekosaur> the (b -> a) isn't visible there. runRoute takes a route and something to apply it to. you can't see it in that definition
16:21:55 <shachaf> nineonine: If you fmap over that thing, that function won't be id anymore.
16:22:25 <shachaf> dmwit: Anyway, I don't know about your moral system, but Yoneda f is a Functor even when f isn't.
16:22:28 <geekosaur> runRoute r f = RedditT $ liftF $ RunRoute r id f
16:22:40 <geekosaur> (this is called eta reduction)
16:22:41 <shachaf> dmwit: In fact Yoneda f is the cofree functor on f.
16:23:03 <geekosaur> you can tell it's happening because the type signature talks about a (b -> a) but there is no corresponding parameter shown to runRoute
16:23:29 <geekosaur> therefore there is an additional parameter which you tack on to the end of the things on both sides of the =
16:23:35 <shachaf> geekosaur: I'm confused.
16:23:50 <shachaf> geekosaur: RunRoute took two parameters in nineonine's example, and the code you wrote isn't equivalent to that code.
16:23:59 <geekosaur> runRoute or RunRoute?
16:24:13 <geekosaur> there is a function, and there is a constructor..
16:24:34 <dmwit> geekosaur: I think nineonine gave the type signature for the constructor, but the code for the function.
16:24:46 <geekosaur> oh, yes
16:24:48 <geekosaur> sigh
16:24:54 <geekosaur> unless that was a typo
16:25:00 <dmwit> Which was a subtle and sneaky thing to do.
16:25:04 <shachaf> That looks like a typical GADT.
16:25:07 <geekosaur> come to think of it, that looks like a GADT
16:25:08 <geekosaur> yeh
16:25:08 <shachaf> Should've just indented it.
16:25:19 <geekosaur> @lpaste the whole thing probably
16:25:19 <lambdabot> Haskell pastebin: http://lpaste.net/
16:25:28 <nineonine> FailWith :: APIError RedditError -> RedditF m a
16:25:28 <nineonine>   Nest :: RedditT m b -> (Either (APIError RedditError) b -> a) -> RedditF m a
16:25:30 <nineonine>   NestResuming :: RedditT m b -> (Either (APIError RedditError, Maybe (RedditT m b)) b -> a) -> RedditF m a
16:25:31 <nineonine>   ReceiveRoute :: Receivable b => Route -> (b -> a) -> RedditF m a
16:25:32 <nineonine>   RunRoute :: FromJSON b => Route -> (b -> a) -> RedditF m a
16:25:33 <nineonine>   WithBaseURL :: Text -> RedditT m b -> (b -> a) -> RedditF m a
16:25:36 <shachaf> nineonine: Please don't paste code in here.
16:25:39 <nineonine> sorry
16:25:45 <nineonine> https://github.com/intolerable/reddit/blob/master/src/Reddit/Types/Reddit.hs
16:25:48 <geekosaur> I said @lpaste for a reason
16:25:55 <shachaf> Also, that's a horrendous-looking GADT.
16:25:59 <geekosaur> which caused the bot to point to your pastebin
16:26:23 <geekosaur> reading code > 1 line out of IRC is painful, especially when one uses a proportional font
16:26:26 <shachaf> Maybe it's not actually horrendous, I don't know.
16:26:36 <nineonine> got it, will take into account
16:27:23 <geekosaur> ok, that file makes a little more sense
16:28:39 <begriffs> Do candidate packages on hackage attemp to build their haddocks?
16:29:43 <geekosaur> ok, looks to me like the (b -> a) is to match other constructors which need that? but runRoute doesn't normally need those to be different so it uses id
16:30:08 <geekosaur> oh, np
16:30:10 <geekosaur> I see it
16:30:12 <shachaf> I think what I said above is correct. It's a slightly strange Coyoneda-style trick.
16:30:13 <geekosaur> Functor instance
16:30:50 <geekosaur> when you'e just building one, you don't need a separate type there so it uses id. but if you fmap over it then the type can change
16:31:18 <geekosaur> so runRoute uses id, but fmap over RunRoute needs the more general type
16:31:31 <geekosaur> line 56
16:31:49 <nineonine> ok
16:32:06 <zoku> geekosaur: If I use "input <- BS.hGetLine h; BS.putStrLn input", that won't wait until the socket closes to handle data, right?
16:32:20 <zoku> where before I was using hGetContents
16:32:22 <geekosaur> zoku, it shouldn't
16:32:24 <nineonine> ok that makes some sense now
16:32:25 <nineonine> thanks
16:32:26 <zoku> ok cool, ty
16:32:54 <geekosaur> hGetContents returns a lazy string of the entire stream contents (but then putStrLn would force the entire string). hGetLine gets a line, putStrLn would print that line
16:34:46 <zoku> right, any idea why I'm still not getting output then?
16:34:52 <geekosaur> no, sorry
16:34:53 <zoku> http://lpaste.net/5494306397665361920
16:34:57 <zoku> here's my updated code
16:34:59 <zoku> ah ok, thanks anyways
16:35:33 <geekosaur> I saw that paste earlier but had nothing I could add then so I didn't say anything
16:39:38 <SailorR> hi
16:39:41 <d-snp> hi
16:39:44 <SailorR> why is haskell so amibuguous? 
16:40:43 <c_wraith> "amibuguous" is kind of an ambiguous term. does it mean having bugs in both directions? 
16:40:57 <c_wraith> or maybe friendly bugs? 
16:41:06 <SailorR> c_wraith, I just mean, it's not very precise
16:41:16 <SailorR> at least the syntax
16:41:35 <c_wraith> SailorR, strange. compilers have no trouble with the syntax. 
16:41:50 <c_wraith> SailorR, that would imply there must be unambiguous rules. 
16:42:18 <SailorR> c_wraith, maybe its just random and the compiler gets lucky choosing the 'right' one
16:42:32 * hackagebot funbot 0.4 - IRC bot for fun, learning, creativity and collaboration.  https://hackage.haskell.org/package/funbot-0.4 (akrasner)
16:43:12 <c_wraith> SailorR, with how often it gets it right, I should figure out how to ask it for winning lotto numbers. 
16:44:06 <scrypta> haha
16:44:37 <pavonia> SailorR: Could you name a sample where you think the sytax is ambiguous/imprecise?
16:44:51 <c_wraith> there are a couple legitimate ambiguities in Haskell syntax, most of which have to do with using '.' as the hierarchical module separator. 
16:45:06 <c_wraith> but those were resolved by fiat. 
16:45:32 <SailorR> pavonia, set(X)  ,, what is a set? its not even defined in logic or math
16:46:45 <c_wraith> SailorR, that doesn't look much like Haskell syntax. 
16:46:49 <pavonia> SailorR: Could you provide more context?
16:47:52 <SailorR> well like [ x <- y ] what does that even mean??
16:48:22 <zoku> huh, so it looks like my program is not even selecting() for the socket I'm trying to recieve data on
16:48:26 <zoku> select(5, [4], [], NULL, NULL)
16:48:37 <c_wraith> that's not valid syntax, either. but it's closer..
16:48:45 <zoku> my irc socket is 4
16:48:50 <zoku> but the network socket is 3
16:49:00 <c_wraith> SailorR, fortunately, haskell isn't afflicted with uncountable choice. 
16:50:44 <SailorR> would the language change much if infinite sets were possible?
16:51:12 <c_wraith> they are. It's only uncountable that aren't allowed. 
16:51:42 <SailorR> wtf
16:51:46 <c_wraith> and that's just a side effect of the space of possible programs being countable. 
16:51:50 <SailorR> how does it handle infinite sets
16:52:14 <pavonia> Lazily
16:52:17 <SailorR> and not just arbitrarily long arrays
16:52:20 <c_wraith> same as any other language. you devise a representation that captures the information you need. 
16:52:36 <c_wraith> but it's very important to note that lists aren't sets
16:53:16 <c_wraith> not for this, since either could be infinite. but because haskell only has special syntax for lists. 
16:54:57 <SailorR> so is haskell have any inate advantages over other languages for AI research and theorem proving
16:55:02 <SailorR> *does
16:57:47 <d-snp> jeez, hakyll is the worst static site generator I've ever used I think.. what's with all the monoid stuff? it makes no sense..
16:57:52 <d-snp> what's hackage generated by?
16:59:07 <athan> d-snp: Monoids are lots of stuff haha
16:59:50 <athan> d-snp: IIRC haddock files are generated by an arrow-based xml combinator system, not sure about hackage though
16:59:54 <athan> probably happstack :s
17:00:31 <athan> SailorR: Lookup "Per Martin Lof" :)
17:00:48 <kadoban> d-snp: Monoids are basically just "combine these two like things and give me another", plus something else. They're probably not causing your confusion with hakyll I would imagine, at least not by themselves.
17:00:50 <athan> and his approach to type systems, similar to Hindley-Milner type systems like HAskell
17:01:07 <kadoban> d-snp: There is a decent amount to learn in hakyll before it's … useful, but it's up to you if you want to spend the time.
17:01:45 <d-snp> kadoban: well yeah, the thing that's causing my confusion with hakyll is the DSL which consists of monads and functors and all sorts of abstractions that seem to make it overly complex
17:02:28 <kadoban> Well, it's a rather complex problem to solve. If there's a simpler useful model for it, I don't know it.
17:03:37 <d-snp> well, Jekyll which Hakyll is sort of based on is much nicer, I would've used it but I'm depending on some Haskell libraries
17:04:14 <kadoban> I didn't like jekyll much, but I could kind of see the appeal I guess.
17:05:11 <SailorR> hm Martin-Lf randomness is pretty cool
17:06:38 <scrypta> I'm starting to really like this language > since I already know python it's kind of fun to work with
17:07:15 <athan> scrypta: oooohhhhh just you wait :) it gets more fun
17:07:19 <zoku> scrypta: i find i write better python too :D
17:07:25 <zoku> now that I've studied some haskell
17:07:32 <scrypta> it gets me thinking
17:07:35 <zoku> I use more of the funcitonal features, and break my programs up in better ways
17:10:04 <scrypta> where can I find a list of synthax for it ?
17:12:26 <athan> scrypta: wat?
17:13:45 <scrypta> I would like to see what synthax it supports
17:16:34 <kadoban> scrypta: Well, there's the haskell report, but I'm not sure that's a good way for a beginner to learn.
17:16:51 <athan> @learn -- scrypta
17:16:51 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
17:16:54 <kadoban> scrypta: It is more readable than most other language specifications by far, but still.
17:16:58 <maerwald> kadoban: I am sure it is not :)
17:17:14 <athan> v_v
17:17:20 <maerwald> wrt good for beginners
17:17:46 <kadoban> scrypta: https://github.com/bitemyapp/learnhaskell is good, or http://haskellbook.com/
17:18:02 <athan> So codensity monad is like a continuation, polymorphic in `r`?
17:18:27 <shachaf> The excerpts I saw from that book have been pretty unpromising.
17:19:45 <reem> how do I delete all packages installed with cabal/clean out my cabal installation ahead of installing stack and using it for everything?
17:20:13 <athan> reem: I deleted _everything_, then let stack fetch ghc for me
17:20:26 <athan> and manage all my installed packages etc. in ~/.stack
17:20:58 <reem> athan: I’m on OS X, what’s the best way to clear all my packages before I remove cabal/ghc?
17:22:00 <Welkin> reem: install linux
17:22:03 <Welkin> gnu+linux
17:22:33 <roconnor> Welkin: please don't reply with unhelpful statements such as that.
17:22:39 <pyon> Speaking of stack, what's the best way to install stack on NixOS?
17:23:12 <Welkin> reem: it should be the same as on linux: delete ~/.ghc ~/.cabal
17:23:18 <Welkin> unless you installed is using the platform
17:23:25 <Welkin> then you use hs-uninstall or something
17:23:31 <reem> pyon: here’s what I could find in the docs http://docs.haskellstack.org/en/stable/install_and_upgrade.html#nixos
17:23:37 <pyon> reem: ty
17:23:46 <reem> Welkin: I’ll try it
17:24:19 <reem> hmm, what about cabal itself?
17:24:23 <Welkin> oh yeah, also, you could remove ghc if you want
17:24:26 <Welkin> but it is not necessary
17:24:38 <athan> Welkin: lol
17:24:41 <reem> I just removed ghc and cleared ~/.cabal and ~/.ghc
17:24:44 <reem> but cabal is still around
17:24:46 <athan> "build a computer"
17:24:51 <Welkin> but yeah, best solution is gnu+linux
17:25:00 <Welkin> reem: that is fine
17:25:05 <Welkin> you don't need to remove anything actually
17:25:16 <Welkin> I have a full cabal+ghc setup and use stack at the same time
17:25:24 <athan> reem: How did you install GHC?
17:25:30 <reem> brew
17:25:31 <Welkin> stack just uses the cabal library
17:25:40 <Welkin> I like using cabal-install sometimes
17:25:40 <athan> aiet, prolly uninstall that too
17:26:10 <reem> done
17:26:13 <athan> nice
17:28:09 <reem> urgh I tried to install via brew but I’m getting an apparently old version that wants ghc 7.8 and I want to use 7.10
17:28:18 <reem> should I just install from source?
17:28:37 <athan> reem: Don't install Ghc
17:28:40 <athan> install stack
17:28:42 <athan> (imo)_
17:28:46 <scrypta> good, thanks alot, I got to hit the books on this one
17:28:57 <reem> athan: right, stack is trying to install ghc 7.8 when I use it
17:29:02 <athan> oh beans
17:29:06 <reem> athan: I read that the newest versions use 7.10
17:29:06 <athan> reem: Not sure :\
17:29:07 <Axman6> reem: what are you terying to install through brew?
17:29:11 <reem> haskell-stack
17:29:24 <Axman6> imo, stack is best installed by hand so it can keep itself up to date with `stack upgrade`
17:29:25 <reem> gets me version 0.1.10.0
17:29:42 <reem> Axman6: so how do I do that?
17:29:44 <Welkin> reem: don't install anything related to haskell via brew
17:29:55 <Welkin> always get the latest binaries from the ghc website
17:29:57 <Welkin> or stackage
17:30:18 <Welkin> haskell moves very fast
17:30:22 <Axman6> all you need to do is download the binary, stick it in ~/.local/bin, add that to your PATH, and let it deal with everything else
17:30:29 <Welkin> 3rd party package managers cannot keep up
17:30:30 <reem> fwiw the stack docs suggest using brew install haskell-stack on OS X
17:30:37 <scrypta> this is so true, it's faster than python by far
17:30:46 <Welkin> really? I didn't do that
17:30:52 <Welkin> I grabbed the binary
17:30:59 <Axman6> http://docs.haskellstack.org/en/stable/install_and_upgrade.html#mac-os-x
17:31:00 <Welkin> (on osx)
17:31:11 <reem> yeah the only thing I have installed related to haskell using brew is ghc
17:31:25 <reem> (though not anymore because I just uninstalled to use stack)
17:31:26 <Axman6> i would uninstall that
17:31:35 <Axman6> stack installs the correct versions of ghc itself
17:32:23 <scrypta> thanks guy, catch you tomorrow
17:33:01 <reem> cool, just grabbed the binary, put it in /usr/local/bin, trying stack upgrade
17:34:02 <reem> hmm, said I am up to date and it’s still trying to get ghc 7.8.4
17:34:17 <reem> (on stack setup)
17:34:57 <reem> ah, never mind, it was in my stack.yaml
17:35:03 <reem> now using ghc 7.10, nice
17:40:02 <Axman6> the version of ghc depends on the lts version, bot on stack itself
17:40:13 <icbm> I would like to write my first Haskell unit test within 30 minutes. I am familiar with NUnit on C#, and also Rust tests.  Which Haskell testing framework do I choose?  (I'm using stack, BTW.)
17:40:19 <Axman6> stack will happily install both 7.8 and 7.10 for you, and use whichever is appropriate
17:40:45 <Axman6> icbm: there's a few articles about that on reddit at the moment, one sec
17:41:07 <icbm> Axman6: Thanks, would appreciate it.
17:41:27 <dresuer> Hi all!
17:41:55 <Axman6> icbm: http://conscientiousprogrammer.com/blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/
17:42:33 <Axman6> icbm: also: http://conscientiousprogrammer.com/blog/2015/12/15/24-days-of-hackage-2015-day-15-iospec-testing-io-and-some-quickcheck-tricks/
17:43:12 <icbm> Axman6: Thanks, I'll check those out.
17:43:56 <dresuer> I'm learning to create functions. Do you know any exercises to practice ?
17:44:06 <Axman6> @learn
17:44:06 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
17:44:20 <Axman6> @where learnhaskell
17:44:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:44:25 <dresuer> By Pattern Matching 
17:44:26 <Axman6> plenty =)
17:54:45 <ph88^> i would like to find the position of sprites within a larger image (png) how to get started ?
17:55:43 <kadoban> ph88^: How many sprites? Are they rotated or noisy, or exact?
17:55:57 <kadoban> ph88^: Are they all the same size?
17:56:02 <ph88^> 256 sprites  exact same as in the image
17:56:15 <ph88^> sprites are probably just slightly different sizes
17:56:33 <ph88^> image has only 2 colors
17:56:41 <ph88^> sprites also just 2 colors
17:59:55 <kadoban> ph88^: Hmm. You could do like a 2D hash basically. Assume all the sprites are the same size (should be able to fudge it later). Hash each of the sprites, then try hashing every possible location in the image and do a lookup to see if it exists. It's not going to be terribly fast, but it should work at least It'll be like O(n^2 * m^2), which could be okay.
18:00:33 <ph88^> what kind of hash ?
18:00:33 <kadoban> ph88^: Dealing with different sizes … I'm not sure exactly how to do that. It seems like it should be possible with basically the same idea, but I'm not sure at the moment.
18:01:00 <ph88^> speed is not important
18:01:03 <kadoban> ph88^: For the equal size case, it doesn't even matter. A clever one might be the route to go with unequal sizes.
18:01:31 <kadoban> ph88^: Of if speed isn't important, just … brute-force it. For each possible location in the image, check if the sprite is there.
18:01:41 <ph88^> Ye !
18:01:50 <kadoban> s/Of if/Oh if/
18:02:12 <ph88^> i mean i would like some help about which libraries i can use best for this
18:02:20 <ph88^> and maybe some reading material on the subject
18:02:27 <ph88^> the algorithm i can figure out myself i think
18:03:18 <kadoban> Not sure. For the image stuff I've used juicy pixels or whatever it is. I don't recall there being a … search function like that though.
18:03:40 <ph88^> how do i go about picking an image library ?
18:03:50 <maerwald> juicypixels is ok
18:04:00 <maerwald> but probably not the cutting-edge performance thing
18:04:15 <stevejb> I am trying to understand whileJust from Control.Monad.Loops. I have the fn:
18:04:18 <stevejb> maybeDouble x = if x < 100 then Just (2 * x) else Nothing
18:04:19 <maerwald> I've seen interesting code in the "friday" package, but you can barely call it a library at this stage
18:04:43 <stevejb> how would I call whileJust with maybeDouble and a starting number?
18:04:44 <maerwald> but that's really hard optimized stuff
18:05:30 <ph88^> barely call it a library ?
18:05:49 <ph88^> i don´t need many functions like calculating color scales or anything like that
18:05:59 <kadoban> stevejb: What's maybeDouble?
18:06:17 <stevejb>  maybeDouble x = if x < 100 then Just (2 * x) else Nothing
18:07:11 <stevejb> so, if I start at 3, I would expect something like [6, 12, 24, 48, 96]
18:08:16 <maerwald> @hackage friday
18:08:17 <lambdabot> http://hackage.haskell.org/package/friday
18:09:03 <maerwald> it doesn't have a consistent API like juicypixels, so...
18:09:12 <maerwald> but you could probably salvage the code
18:09:15 <ph88^> not fitted for a beginner
18:10:12 <maerwald> juicypixels is fine, it's relatively easy, not too "high-level" (as in: not a DSL you need to spend weeks on learning)
18:10:47 <maerwald> but it also comes with a lot of dependencies, unfortunately
18:11:08 <kadoban> stevejb: And you're talking about the whileJust from monad-loops ?
18:11:24 <stevejb> yes
18:11:57 <stevejb> I am not entirely sure that that is what I want to use. Essentially I want to iterate on a function with a starting value until it returns a Nothing, and then collect the whole list
18:13:15 <kadoban> stevejb: Unless I'm missing something the only way to use whileJust would be with the Identity Monad, which may be more confusing than you're looking for. (it's not that confusing, but it's weird). I suspect there's a better function somewhere, but I'm not sure what.
18:13:28 <stevejb> kadoban: ok thank you anyway
18:13:40 <KaneTW> unfoldr?
18:13:50 <KaneTW> :t unfoldr
18:13:51 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
18:15:07 <stevejb> KaneTW: reading the doc now. I think that that may be it
18:17:35 <stevejb> KaneTW: I think that that will do what I want. Thank you.
18:22:29 <KaneTW> np
18:28:02 * hackagebot funbot-ext-events 0.2.0.0 - Interact with FunBot's external events.  https://hackage.haskell.org/package/funbot-ext-events-0.2.0.0 (akrasner)
18:30:04 <julianleviston> So… I have a question… what is a BAZAAR? In the context of traversals, lenses and comonads, and whatnot?
18:30:13 <julianleviston> I keep seeing it pop up everywhere.
18:30:57 <julianleviston> ah nevermind I found out in here: http://hackage.haskell.org/package/lens-4.12.1/src/src/Control/Lens/Internal/Bazaar.hs
18:31:04 <julianleviston> A 'Bazaar' is like a 'Control.Lens.Traversal.Traversal' that has already been applied to some structure.
18:31:07 <mniip> it's a collection of comonadic stores
18:31:12 <julianleviston> sweet
18:31:28 <julianleviston> Is a Traversal somehow comonadic?
18:38:02 * hackagebot funbot 0.4.0.1 - IRC bot for fun, learning, creativity and collaboration.  https://hackage.haskell.org/package/funbot-0.4.0.1 (akrasner)
18:41:17 <cmk_zzz> What is the best way for me to encode/decode from/to binary data. We have a binary format which encodes Key/Value of ByteStrings into Length:Key:Lenght:Value structure. I started looking at Data.Binary.Put which has things like putWord8 I am not sure that is the right module though
18:42:50 <geekosaur> in general it is
18:44:09 <cmk_zzz> geekosaur: thanks. I am very new to haskell and just couldn't quite work out why Put is a Monad. To me it seems like a normal data transformation without any side-effects so I wasn't sure if I am looking at the correct modules
18:44:50 <geekosaur> it's more or less a glorified writer monad, building up a buffer from the stuff you put
18:45:16 <geekosaur> conversely Get retrieves sequentially from a buffer
18:46:28 <cmk_zzz> geekosaur: Thanks
18:46:46 <geekosaur> (IO is actually a very atypical monad; most monads are about state in one way or another, in this case the state of a buffer)
18:49:57 <cmk_zzz> I'll get there eventually. I figured the best way to learn is to write in it so I am porting some libraries to haskell to get a feel for it
18:52:01 <julianleviston> cmk_zzz: yeah, you have to find your own way if you want to know what’s best, because we’re all different :)
19:03:43 <pavolzetor> Ray traced something in haskell finally http://sci.utah.edu/~klacansky/teapot2015/
19:04:28 <pavolzetor> I am still figuring out how to do things in functional way, next are bicubic patches :)
19:04:31 <julianleviston> pavolzetor: nice! :)
19:05:46 <pavolzetor> julianlevinston: thank you, are you also interested in rendering?
19:06:50 <julianleviston> pavolzetor: I’m interested in a myriad of things. My focus right now is “editing textual things”, which means I don’t get to do graphicy things or musicy things much…
19:07:32 <pavolzetor> “editing textual things” what is it?
19:07:45 <lingxiao> could someone expalin tthis to me:
19:07:50 <julianleviston> pavolzetor: but I don’t have a massive knowledge of rendering. I’ve mucked around in various 3D programs to do some things, and done a bit of Blender and whatnot.
19:08:08 <julianleviston> pavolzetor: my housmate is a 2D and 3D artist, so that helps :)
19:08:39 <wolfik> Hi. can someone explain cabal error: setup-Simple-Cabal-1.18.1.3-x86_64-linux-ghc-7.8.1: dist/package.conf.inplace:inappropriate type
19:08:48 <lingxiao> http://lpaste.net/147222
19:08:52 <lingxiao> bar' is throwing an error
19:08:59 <julianleviston> pavolzetor: oh… um… it’s kind of a structural editor (will be using it as an online website / code editor for the moment)
19:09:00 <wolfik> I tried to istall package  from local file
19:10:24 <pavolzetor> julianlevinston: artist input is the key, a lot of renderers do not cater the needs. Something like vim?
19:11:52 <julianleviston> pavolzetor: Something that lets users do structural editing. (That sounds a bit waffly)
19:12:32 <pavolzetor> julainlevinston: but what is the structural editing? is it like headings and paragraphs?
19:12:42 <lingxiao> anyone familar with RVarT and MonadRandom
19:12:50 <julianleviston> pavolzetor: one of the uses will be for our website clients to be able to edit their websites, so you could think of it as a kind of CMS, but it’s a LOT more than that (given that you’ll be able to edit the actual CMS itself).
19:13:40 <julianleviston> pavolzetor: I’m just trying to work out how to make it so I can edit code without going completely insane today. lol.
19:14:57 <pavolzetor> julianlevinston: sounds like fun, I rather stick to rendering ;)
19:14:58 <lambda-11235> lingxiao: I couldn't find RVarT on Hoogle, what package is it in?
19:15:03 <julianleviston> pavolzetor: in particular, whether I need to create myself a Comonad for traversing the structural trees I’ll end up with.
19:15:12 <lingxiao> https://hackage.haskell.org/package/random-fu-0.2.4.0/docs/Data-Random-RVar.html
19:15:21 <lingxiao> lambda--11235 --^
19:15:51 <lingxiao> btw if im declaring a new monad state instance
19:16:03 <lingxiao> where should that go in my directory ? 
19:16:26 <lingxiao> im using quickcheck-test-framework template from stack
19:16:40 <lingxiao> right now it could be in core.hs in src, but it doesnt really belong there per se
19:17:05 <julianleviston> pavolzetor: I dunno if I’d call it fun. It’s more just necessary for the moment :) Everything else I want to be able to do kind of stems off being able to build structured documents and code in a nice reusable way, and having them web-facing is an obvious bonus for my business (we build websites and web applications for people).
19:17:18 <wolfik> Can someone help me with cabal? I only have 1 question
19:18:06 <maerwald> only if it's 2 questions
19:18:26 <wolfik> :) 
19:18:32 <wolfik> what is this error from cabal install ?  dist/package.conf.inplace:inappropriate type
19:18:59 <lingxiao> could someone else chime in as well here: http://lpaste.net/147222 :D
19:19:12 <lingxiao> I've been stuck here for a while
19:19:23 <wolfik> maerwald, google doesn't answer.
19:19:48 <julianleviston> lingxiao: I could help, but you’d have to teach me.
19:19:50 <wolfik> lingxiao, i know that feel. I've been strugling with mine for 4 days now
19:19:53 <julianleviston> lingxiao: do you want to teach me?
19:20:11 <lingxiao> yup sure! wait waht am i teaching
19:20:16 <P4Titan> Hello all, I have a question: If I have a type Triplet a. Now I have two types, Triplet TypeA and Triplet TypeB. What would be the best way to convert the former to the latter if I can convert TypeA to TypeB normally?
19:20:17 <julianleviston> lingxiao: what you’re doing :)
19:20:22 <lingxiao> http://lpaste.net/147222
19:20:25 <lambda-11235> lingxiao: Could you post the error?
19:20:34 <julianleviston> P4Titan: fmap?
19:20:48 <P4Titan> :t fmap
19:20:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:20:59 <P4Titan> That does seem reasonable
19:21:04 <julianleviston> fmap (+3) (Just 5)
19:21:07 <P4Titan> Why did I not think of that :D Thanks!
19:21:10 <julianleviston> >fmap (+3) (Just 5)
19:21:18 <julianleviston> sigh
19:21:22 <geekosaur> space
19:21:24 <wolfik> yay. at least one guy has a solved problem!
19:21:26 <julianleviston> yeah :)
19:21:40 <lingxiao> julianleviston and lambda-11235  i'll post a new lpaste w/ the error
19:21:47 <julianleviston> lingxiao: sweet
19:22:30 <lingxiao> http://lpaste.net/147224
19:22:44 <lingxiao> here it is julianleviston and lambda-11235 
19:23:23 <julianleviston> lingxiao: ok… so what does this line do/mean ? instance MonadState s m => MonadState s (RVarT m) where
19:23:47 <lambda-11235> lingxiao: line 13, I think it might be the m in the type annotation. Generics don't propagate down the function body.
19:24:18 <lambda-11235> ,let foo :: Read a => IO a; foo = readLn :: IO a
19:24:23 <lambda-11235> > let foo :: Read a => IO a; foo = readLn :: IO a
19:24:24 <lambdabot>  <no location info>:
19:24:24 <lambdabot>      not an expression: ‘let foo :: Read a => IO a; foo = readLn :: IO a’
19:24:29 <julianleviston> it’s @let I think.
19:24:36 <lambda-11235> @let foo :: Read a => IO a; foo = readLn :: IO a
19:24:37 <lambdabot>  .L.hs:156:7:
19:24:38 <lambdabot>      Could not deduce (Read a1) arising from a use of ‘readLn’
19:24:38 <lambdabot>      from the context (Read a)
19:24:45 <lingxiao> julianleviston i want to make RvarT an instance of monadstate so i can use get put and modify w/o using lift
19:25:03 <lambda-11235> @let foo :: Read a => IO a; foo = readLn
19:25:04 <lambdabot>  Defined.
19:25:08 <lingxiao> lambda-11235  : could you elaborate?
19:26:40 <julianleviston> lingxiao: oh… that’s already way too complicated for me.
19:27:00 <lambda-11235> m is a generic type that is an instance of a type class. So you have to include MonadRandom m => ... in your typeclass definition. however ...
19:27:47 <julianleviston> lingxiao: I don’t really understand that line much. You’re saying RVarT m should be an instance of MonadState… what does the MonadState s m constraint do there?
19:28:56 <julianleviston> Does “MonadState s m =>” mean that both s and m are constained to MonadState, or does it mean something else?
19:29:01 <lambda-11235> The do statement has does not get the function generic declaration (I think).
19:29:26 <lingxiao> julianleviston it's from this page: https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Class.html#line-150
19:29:35 <julianleviston> lingxiao: I want you to teach me.
19:29:38 <geekosaur> the constraintis wrong
19:29:57 <lambda-11235> try changing it to x <- (uniformT 0 1 :: MonadRandom m => RVarT m Double) 
19:30:00 <julianleviston> lingxiao: what does it mean? This is your code. You need to understand it.
19:30:09 <geekosaur> MonadState s m => MonadState (something)   means you want to access a MonadState *inside* your type
19:31:40 <julianleviston> geekosaur: what does “MonadState s m =>”  mean? as in… what does it say about s and/or m ?
19:31:45 <lambda-11235> Sorry I meant constraint not function generic declaration.
19:31:56 <lingxiao> julianleviston yeah the instance declaraition is lifiting get put and state *into* RVarT
19:32:13 <julianleviston> lingxiao: hang on… we need to know what the first line does first.
19:32:24 <julianleviston> lingxiao: can you explain it to me?
19:32:26 <lingxiao> like saying instance Show a => Show (List a)
19:32:29 <julianleviston> lingxiao: I genuinely want to know.
19:32:30 <emmanuel_erc> Hey there, how many of you guys would be interested in a Haskell library containing the most popular manifold learnig algorithms (similar to what sci-kit has)?
19:32:33 <lingxiao> a has to be an instance of  show
19:32:47 <julianleviston> lingxiao: yeah, that’s a simple constraint. What is this one doing though?
19:32:51 <geekosaur> julianleviston, it's not very meaningful by itself
19:32:59 <julianleviston> geekosaur: oh? ok. Sorry.
19:33:01 <geekosaur> MonadState s m => MonadState s (MaybeT m)
19:33:20 <lingxiao> so MonadState s m means that the m has to be a state monad, w/ notions of get and put
19:33:28 <lingxiao> s is the underlying state of this monad
19:33:33 <julianleviston> ahhh ok
19:33:41 <geekosaur> says that if you have a state type s and a monad m which have a MonadState instance already, then you can create a MonadState instance for the same state and the same monad wrapped in MaybeT
19:34:04 <julianleviston> lingxiao: ^ right?
19:34:16 <P4Titan> Is it possible to get the type within a newtype inline w/o pattern matching?
19:34:20 <geekosaur> if you want to make RVarT *itself* the state, as opposed to wrapping an already existing MonadState inside of it, then you want the StateT instances
19:34:28 <geekosaur> as your example
19:34:35 <julianleviston> P4Titan: use a record… what do you mean by inline?
19:34:35 <lingxiao> yup
19:34:47 <P4Titan> a function that does it
19:35:02 <P4Titan> so that I can insert it directly into a string of code
19:35:09 <geekosaur> and you will note that those do not have MonadState in the constraint, only Monad (becatse StateT wraps another monad)
19:35:12 <julianleviston> P4Titan: well if your newtype is specified with record syntax, it will build a function for you of that name
19:35:14 <lingxiao> all this is so that i can say:     foo = uniformT 0 1 >>= \p -> put p 
19:35:21 <athan> Wait......... a sec...... holeup
19:35:30 <athan> fmap f . fmap g == fmap (f . g)
19:35:31 <lingxiao> insstea of foo = uiform 0 1 >>= \p -> lift . put $ p
19:35:37 <geekosaur> you may actually want to look at mtl-1.x for the example you want; State used to be a monad itself instead of being a type synonym for StateT Identity
19:35:42 <athan> (.) <$> fmap f <*> fmap g ....?
19:35:47 <athan> am I losing it?
19:35:52 <geekosaur> oh wait, RVarT
19:35:58 <P4Titan> interesting, thanks!
19:36:00 <geekosaur> so you do want the StateT example
19:36:05 <lingxiao> athan sorry are you saying it's not obeying the laws
19:36:25 <julianleviston> athan: taht will get the passed argument and apply it to both before passing them both to (.) AFAIK.
19:36:31 <athan> lingxiao: I'm trying to think of the composition law... compositionally :D
19:36:32 <lingxiao> yeah I dont want to explicity declare  :: RVarT (State s) () for example
19:36:40 <athan> yeah
19:37:22 <geekosaur> I guess I am stll confused
19:37:26 <athan> I should category it
19:37:40 * geekosaur looks for MonadRandom def
19:38:27 <geekosaur> also, you are using lift, you need a MonadTrans for that
19:38:28 <julianleviston> :t (<*>)
19:38:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:38:50 <geekosaur> so you are asserting that the m in RVarT m is already a MonadState?
19:39:42 <lingxiao> geeksaur yes
19:39:42 <geekosaur> or?\
19:40:13 <maerwald> how do people do performance regression tests in haskell?
19:40:34 <geekosaur> actually where is RVarT defined?
19:40:44 <geekosaur> oh waitm your paste gave me a module
19:41:43 <lingxiao> yeah tbh its a bit cluncky
19:41:45 <geekosaur> er, but I do not see a module Data.Random ... what package is it from?
19:41:57 <lingxiao> i want something that looks like this:
19:41:58 * geekosaur wants to see what RVarT is already
19:41:59 <lingxiao> baz :: (MonadState s m, MonadReader t m) => m ()
19:41:59 <lingxiao> baz = get >> ask >> return ()
19:42:14 <lingxiao> https://hackage.haskell.org/package/random-fu-0.2.4.0/docs/Data-Random-RVar.html
19:42:19 <achernyak> I am trying to figure out the implementation of traverse, but I am not understanding how the function terminates. It looks like it should be getting called forever
19:42:19 <lingxiao> geekosaur  ---^
19:42:53 <achernyak> would anyone be willing to explain this pattern?
19:43:01 <KaneTW> achernyak: implementation of traverse for which structure
19:43:10 <KaneTW> which datatype/
19:43:11 <julianleviston> achernyak: do you mean    traverse f = sequenceA . fmap f ?
19:43:31 <achernyak> julianleviston: yes that one
19:43:44 <julianleviston> KaneTW: Traversable
19:44:05 <lingxiao> all this hoopla and thisis the behaivor i want for my state and randomness:
19:44:13 <julianleviston> achernyak: won’t it just traverse to the end of the structure? isn’t that what sequenceA does?
19:44:14 <lingxiao> geeksoaru julianleviston:  http://lpaste.net/
19:45:06 <geekosaur> ok, so RVarT is already MionadTrans, but ... they talk about using it for state but didn't provide a MonadState instance
19:45:17 <geekosaur> but you have a bigger problem which is the conflicting "lift"s
19:45:21 <achernyak> julianleviston: well all sequenceA does is call traverse with id as the function right? doesn't that create an infinite loop?
19:45:50 <julianleviston> achernyak: you’re reading the unimplemented class.
19:45:58 <ReinH> achernyak: instances must implement one or the other of those methods
19:46:01 <geekosaur> because it is both MonadTrans (which is the lift you need) and Lift (which is more general but conflicting)
19:46:03 <julianleviston> achernyak: look up, and you’ll see the MINIMAL section
19:46:19 <ReinH> achernyak: the other will be defined in terms of the implemented one
19:46:21 <julianleviston> achernyak: you have to define one of traverse or sequenceA, or you WILL end in an infinite loop, yes.
19:46:35 <dresuer> nada en español de haskell?
19:46:38 <dresuer> mierda
19:46:40 <jesusdidit> I failed math while in high school along with a lot of other classes (summer school is great). I was wondering if I could go to community college, get a new and improved GPA and then transfer to MIT, regardless of my high school GPA.
19:46:52 <julianleviston> dresuer: porque?
19:47:00 <achernyak> julianleviston, ReinH: thank you guys, I feel really dumb for not realizing that.
19:47:08 <julianleviston> achernyak: not at all.
19:47:09 <geekosaur> lingxiao, so I think you need to explicitly import Control.Monad.Trans so you have the correct "lift" in scope for a MonadState definition
19:47:15 <ReinH> achernyak: well, stop that
19:47:18 <achernyak> I spent the better part of 2 hours trying to understand that lol
19:47:32 <dresuer> julianleviston: Sólo encontré este material está bueno, el tema es que leerlo en inglés me cansa el doble
19:47:35 <dresuer> julianleviston: https://www.haskell.org/tutorial/haskell-98-tutorial.pdf
19:47:36 <julianleviston> achernyak: yeah, don’t feel dumb… there’s just so much to understand. 
19:47:45 <dresuer> julianleviston: Conocés alguno en Español, parecido a ese.
19:47:48 <geekosaur> achernyak, actually the MINIMAL thing is still quite new, but yes the idea of default implementations some of which must be overridden is a bit ... weird
19:47:50 <dresuer> Me encanta esa introducción
19:47:55 <lingxiao> geekosaur could you elaborate on this: because it is both MonadTrans (which is the lift you need) and Lift (which is more general but conflicting) 
19:47:58 <geekosaur> the MINIMAL pragma catche a bunch of bugs
19:48:21 <geekosaur> lingxiao, both the MonadTrans and Lift typeclasses define "lift"
19:48:35 <geekosaur> the definition of MonadState requires the one from MonadTrans
19:48:43 <julianleviston> dresuer: momentito
19:49:00 <geekosaur> but the errors you were getting indicate that the "lift" in scope is the one for Lift
19:49:19 <exio4> dresuer: es dificil encontrar contenido en espa;ol de buena calidad, especialmente porque gran cantidad del laburo es en ingles, a largo vas a tener que adaptarte
19:49:25 <achernyak> geekosaur: yeah it really threw me because I had an exercise to reimplement mapM and when I went to see how close I was to the standard I didn't even think of looking at the minimals for Traversable.
19:49:46 <jsc> I'm having some issues with this code (http://lpaste.net/147227) and infinite lists. My understanding is that foldr should bail out early if one step makes no reference to the accumulated value which I thought I was doing. I am instead getting stack overflows
19:50:13 <exio4> (it's quite hard to find good content in spanish, mostly because quite a lot of it is done in english, you'll have to deal with them anyway) translated
19:50:22 <julianleviston> dresuer: muy bien? https://translate.google.com/translate?hl=en&sl=en&tl=es&u=https%3A%2F%2Fwww.haskell.org%2Ftutorial%2F
19:50:28 <dresuer> exio4: Entiendo eso, pero leerlo en inglés para mi es el doble de cansador, porque me manejo si, pero no leo tan rápido como el Español
19:50:31 <dresuer> eso me cansa 
19:50:41 <dresuer> julianleviston: El traductor ese es HORRIBLE!
19:51:00 <geekosaur> lingxiao, actually I see another problem here
19:51:06 <dresuer> tengo que hacer el doble de esfuerzo para entender cada parrafo
19:51:09 <geekosaur> you are using m on line 12
19:51:11 <julianleviston> dresuer: :(
19:51:21 <lingxiao> geeksoaur yes please
19:51:25 <exio4> dresuer: no va a quedar otra, a practicar :P 
19:51:29 <geekosaur> the "m" there has no relationship to the one in your type signature
19:51:44 <geekosaur> so you are in effect *forcing(* a type mismatch
19:52:03 <geekosaur> if you actually need a type annotation there, you want to look at the ScopedTypeVariables extension
19:52:17 <geekosaur> (note that it is not sufficient to just turn on the extension. read its documentation.)
19:52:19 <achernyak> julianleviston, geekosaur: I must still be missing something. When I tried implementing the two functions without different names it still worked (http://lpaste.net/147228)
19:52:53 <julianleviston> achernyak: huh?
19:53:06 <lingxiao> the "m" there has no relationship to the one in your type signature, so that m doesn't point the m above you're saying right
19:53:27 <lingxiao> its like foo a b = let bar a b = a + b in a:b:[]
19:53:35 <achernyak> julianleviston: well didn't you say that they had to have either sequence or traverse implemented as a minimal implementation in order to work?
19:53:37 <lingxiao> but with types
19:53:43 <geekosaur> lingxiao, yes
19:53:49 <ReinH> arahael: well yes, meh and meh' are mutually recursive
19:53:54 <julianleviston> achernyak: yeah… but that’s only if you want to make a type an instance of that class.
19:54:15 <geekosaur> woith ScopedTypeVariables you can make those unify. *but* you need to explicitly declare which ones you want to scope over the definition (in this case m)
19:54:19 <julianleviston> achernyak: you’re of course free to write whatever code you like outside of the class/instance stuff...
19:54:36 <geekosaur> because random code would be broken otherwise, that might expect that it can reuse type variables that way
19:54:38 <ReinH> arahael: I'm not sure what that has to do with traverse and sequenceA
19:54:39 <julianleviston> achernyak: we’re assuming you understand typeclasses and how they work… is that the case?
19:54:40 <ReinH> er
19:54:41 <ReinH> sorry
19:54:43 <achernyak> ReinH, I guess I didn't really understand ho mutually recursive functions terminate.
19:54:44 <ReinH> achernyak: ^
19:54:49 <ReinH> achernyak: they don't
19:54:59 <ReinH> unless one of them terminates in some other way
19:55:08 <lingxiao> but with scopedtypevariable pragma all m's in the body of the function will point to the one in the type signature?
19:55:18 <ReinH> the point is that implementors of a Traversable instance must write one of traverse or sequenceA *not* in terms of the other
19:55:25 <ReinH> which breaks the mutual recursioln
19:55:26 <geekosaur> lingxiao, did you read what I said? completely?
19:55:41 <geekosaur> the part after the *but* is essential, not optional
19:55:45 <julianleviston> dresuer: lo siento :(
19:55:45 <achernyak> ReinH, ah thank you
19:55:45 <geekosaur> I even told you why
19:55:46 <lingxiao> oh i thik i dropped this comment: woith ScopedTypeVariables you can make those unify. *but* you need to explicitly declare which ones you want to scope over the definition (in this case m)
19:56:06 <lingxiao> so how do i explicitly declare?
19:56:27 <lingxiao> sorry lots of activity here so it's easy to drop a comment 
19:56:29 <geekosaur> with forall (which at the top level is normally implied, but here is being "abused" to mean something else)
19:56:32 <lingxiao> :(
19:56:33 <maerwald> anyone wants to help with a gtk project?
19:57:10 <lingxiao> geeksosaur it means forall m. m found in the body of teh function?
19:57:41 <hasenov> hello, i am using stack for my project, unfortunately I cannot figure out how to upgrade a package
19:58:00 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#scoped-type-variables
19:58:08 <geekosaur> ^ read this lingxiao 
19:58:20 <hasenov> I used to have version 0.8.1.0 but need at least 0.9.0.0
19:58:37 <hasenov> so in my cabal file I added that as dependancy
19:58:50 <hasenov> however "stack update" doesnt seem to do anything
19:58:54 <maerwald> https://github.com/hasufell/hsfm/issues if anyone feels bored and likes to hack on Gtk code...
19:59:22 <hasenov> and if I type "stack build", I get the error
19:59:24 <geekosaur> I would expect "stack update" to refresh its package metadata, not upgrade packages
19:59:31 <hasenov> Failure when adding dependencies: Spock: needed (>=0.9.0.0), 0.8.1.0 found (latest is 0.10.0.1)
19:59:50 <kadoban> What's the name of …  (Alternative f) => [f] -> f  -- ?
19:59:58 <hasenov> geekosaur: yeah "stack update"
20:00:08 <mniip> kadoban, foldr empty (<|>) ?
20:00:12 <geekosaur> that just means it knows the "latest is" part
20:00:28 <lingxiao> geekosaur ok going thru that .. but i have a more triival question ... what's the right syntax here?
20:00:34 <kadoban> mniip: It doesn't have a name? Not there's anything wrong with that, I just thought it did …
20:00:36 <mniip> er, the other way around
20:00:46 <geekosaur> I don;t know offhand how you deal with it having the wrong version present...
20:00:47 <lingxiao> based on the doc i would think: oo :: forall m. (MonadState s m, MonadRandom m) => s -> RVarT m ()
20:00:49 <dresuer> Are there any famous application programmed in Haskell?
20:00:57 <kadoban> mniip: Alrighty, thanks. I'll run with it.
20:01:02 <mniip> :t foldr (<|>) empty
20:01:04 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:01:05 <lingxiao> but then the variable s is not in scope
20:01:07 <hasenov> how do I remove the old version and install the new version?
20:01:07 <geekosaur> (in fact I thought it dealt with that automatically based on yoru cabal file...)
20:01:38 <kadoban> hasenov: What's in your .cabal file and your stack.yaml file?
20:01:53 <julianleviston> dresuer: facebook uses it.
20:01:59 <julianleviston> dresuer: that’s pretty famous.
20:02:15 <julianleviston> dresuer: https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
20:02:28 <hasenov> kadoban: build-depends:       base , webui , Spock >= 0.9.0.0
20:02:48 <Welkin> popularity is the worst metric you could use to evaluate the merits of a programming language
20:03:05 <Welkin> if you want popular, use php
20:03:05 * hackagebot pinchot 0.6.0.0 - Build parsers and ASTs for context-free grammars  https://hackage.haskell.org/package/pinchot-0.6.0.0 (OmariNorman)
20:03:20 <kadoban> dresuer: Probably pandoc, yesod, xmonad maybe, probably a few others.
20:03:28 <julianleviston> Welkin: There’s a chance he was just interested in knowing what he asked. :)
20:03:33 <geekosaur> pandoc, git-annex
20:03:39 <kadoban> Ah yeah git-annex
20:03:39 <achernyak> Welkin, don't bring back the nightmares of php
20:03:50 <hasenov> thats in the executable section of my cabal file
20:04:10 <kadoban> hasenov: You can just throw them on lpaste.net What's in stack.yaml?
20:04:10 <Welkin> it is safe to say that every program I write is in haskell
20:04:17 <Welkin> I don't need any other language
20:05:28 <Hijiri> :t asum
20:05:30 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:05:35 <Hijiri> kadoban: is that it?
20:05:52 <lpaste_> hasenov pasted “webui.cabal” at http://lpaste.net/147229
20:06:13 <kadoban> Hijiri: Oh, looks right
20:06:18 <kadoban> Thanks!
20:06:35 <julianleviston> Welkin: I agree!
20:06:51 <lpaste_> hasenov pasted “stack.yaml” at http://lpaste.net/147230
20:06:52 <lambda-11235> Welkin: Not even C for low level work?
20:07:22 <Welkin> lambda-11235: I don't do that kind of stuff generally
20:07:28 <Welkin> but for microcontrollers, perhaps
20:07:50 <geekosaur> even there, there is Atom
20:07:51 <kadoban> Oh crap, I wonder if I'm modelling this wrong … hmm. *ponders*
20:08:05 * hackagebot dependent-map 0.2.1.0 - Dependent finite maps (partial dependent products)  https://hackage.haskell.org/package/dependent-map-0.2.1.0 (JamesCook)
20:08:58 <julianleviston> geekosaur: what’s Atom?
20:09:15 <geekosaur> a DSL for generating microcontroller code
20:09:19 <geekosaur> or other embedded code
20:09:25 <julianleviston> oh neat.
20:09:37 <geekosaur> so you get type safety without overhead on the microcontroller or etc.
20:09:38 <kadoban> hasenov: So, your stack.yaml is saying to use the lts-3.7 resolver, which has Spock-0.8.1.0 in it. But your .cabal file is specifying that you want Spock >= 0.9
20:09:56 <kadoban> hasenov: Do you know which you prefer? Do you actually care if Spock is >= 0.9?
20:10:27 <lingxiao> hey guys how do I generate some Double from 0 to 1 uniformly
20:10:40 <lingxiao> the function has to be some MonadRandom m
20:10:49 <julianleviston> lingxiao: linearly?
20:10:52 <kadoban> hasenov: Because the easy fix is just to remove the version requirement in the .cabal file
20:10:57 <julianleviston> lingxiao: oh…nevermind.
20:10:59 <lingxiao> julianleviston huh?
20:11:03 <lingxiao> oh ok ahah
20:11:09 <lingxiao> I've been using uniform or  uniformT
20:11:13 <lingxiao> but that's no good
20:11:32 <julianleviston> lingxiao: sorry, I thought you were asking about unfolding a line segment in values.
20:11:42 <lingxiao> oh well that's interesting too
20:11:43 <hasenov> kadoban: I want to use a feature that is only present in Spock 0.9
20:11:50 <julianleviston> lingxiao: for some reason my brain dropped the fact that you were talking about random.
20:12:21 <lingxiao> all good my brain drops facts period
20:12:43 <kadoban> hasenov: Then you'll have to add that Spock version to your extra-deps in the stack.yaml file I believe. You might then have a chain of "now I have to add … now I have to add …", etc. But you can try. You can also try nuking your stack.yaml and try 'stack init --solver', which might work.
20:13:11 <kadoban> hasenov: I'd try the first way first, it's sometimes not that bad.
20:13:39 <hasenov> kadoban: ok, i was not aware of what lts is, i guess its something like the debian distros LTS releases
20:14:02 <kadoban> hasenov: No, it's snapshots from www.stackage.org
20:14:17 <kadoban> hasenov: It specifies a set of packages that are known to build together.
20:16:22 <lingxiao> hey all, how do i run this thing:
20:16:24 <lingxiao> g :: RandomGen g => g -> (Double,g)
20:16:24 <lingxiao> g = randomR (0,1)
20:16:33 <lingxiao> i need some seed i suppose, but cant find it
20:16:36 <lingxiao> in the docs
20:18:24 <hasenov> stack install spock                                                                                                                                            Spock/webui  zodd
20:18:27 <hasenov> Populated index cache.
20:18:29 <hasenov> Didn't see spock-0.9.0.0 in your package indices. Updating and trying again.
20:18:32 <hasenov> Fetched package index.
20:18:34 <hasenov> The following package identifiers were not found in your indices: spock-0.9.0.0
20:18:36 <hasenov> Populated index cache.
20:18:54 <verement> lingxiao: getStdGen is one option
20:19:32 <hasenov> umm, stack update should have updated the package index right?
20:20:42 <kadoban> hasenov: You didn't listen to a thing I said, did you …
20:20:47 <geekosaur> hasenov, if you;re still pointing at the lts-3.7 resolver then it cannot find spock-0.9.0.0there
20:20:57 <geekosaur> because lts-3.7 *does not have* that version
20:21:04 <lingxiao> verment hmm that one is IO though
20:21:18 <lingxiao> Im looking for something that's like MonadRandom m => ...
20:21:28 <hasenov> kadoban: i did add it to extra-deps in stack.yaml
20:21:48 <kadoban> hasenov: And does it build then, or at least give a different error?
20:21:51 <hasenov> oh gotcha, i need to remove the lts
20:22:08 <kadoban> You probably want to avoid removing the lts part if you can.
20:22:14 <flyzen> How much is calculus used in computer science? Is it worth learning for a computer scientist?
20:22:25 <lingxiao> so let's see:
20:22:27 <flyzen> Seems like I should stop wasting my time teaching myself calculus and start learning discrete mathematics or something.
20:22:41 <lingxiao> > :t getRandomR (0,1) :: MonadRandom m => m Double
20:22:43 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:22:47 <lingxiao> this is good it does what i want
20:22:52 <lingxiao> but n ow what .. how do i run it?
20:22:58 <hasenov> kadoban: same error on "stack build"
20:23:11 <Hijiri> if you are doing something in a specific field and need a formula for something, you might use calculus to derive it
20:23:35 <Hijiri> I don't think it's essential to computer science, though
20:23:42 <julianleviston> algebra is.
20:23:43 <Welkin> flyzen: calculus is necessary for a lot of other math
20:23:47 <Welkin> like linear algebra
20:23:58 <hasenov> maybe i should use another resolver? not lts?
20:24:04 <Hijiri> you can use linear algebra as a prerequisite to calculus also
20:24:29 <flyzen> I intend to self-teach myself machine learning and cryptology, along with some physics on the side (possibly).
20:24:33 <Hijiri> the linear algebra I took didn't require any calculus, it was the opposite, where the calculus in the sequence built on the linear algebra
20:25:29 <flyzen> I haven't messed with linear algebra too much. I have knowledge of algebra, though. (It's gotten me this far lol)
20:25:31 <Hijiri> calculus might be useful in machine learning, I don't really know much ML, but they have curves
20:25:32 <kadoban> hasenov: Ah, I have a better fix … remove the extra-deps you added, and replace the resolver: lts-3.7 line with: resolver: nightly-2015-12-16
20:25:34 <lingxiao> hey everyone
20:25:40 <Hijiri> and curves are related to calculus
20:25:45 <kadoban> hasenov: nightly has Spock-0.10.0.1 in it
20:26:09 <lingxiao> i have this computation:
20:26:14 <lingxiao> unitInterval = getRandomR (0,1) :: MonadRandom m => m Double
20:26:22 <lingxiao> but how would i run this?
20:26:59 <Hijiri> use it with RandT
20:27:04 <Hijiri> like RandT StdGen
20:27:23 <Hijiri> or Rand
20:27:38 <Hijiri> so it would specialize to Rand StdGen Double
20:27:45 <Hijiri> or I think you can run it directly in IO
20:28:08 <Hijiri> actually nevermind, there isn't an instance
20:28:11 <verement> lingxiao: is there a reason you are trying to use MonadRandom rather than System.Random (i.e. randomR)?
20:28:26 <lingxiao> yeah it's the signature i want
20:28:32 <julianleviston> lol
20:28:37 <Hijiri> so use Rand or RandT
20:28:43 <lingxiao> Im defining a notion of a `coin` and `toss`ing it in some stateful randomized algorithm
20:28:46 <Hijiri> and you can use one of the functions for running Rand/RandT
20:28:56 <lingxiao> lol verement sorry not meant to be sassy
20:29:18 <lingxiao> but id like     algo :: MonadRndom m, monadState s m => m Result
20:29:32 <lingxiao> not ... StateT s (RVarT ... ) Result
20:29:43 <lingxiao> or some concrete variation fo that 
20:30:02 <Hijiri> well you can use the unspecialized unitInterval in your generic algo then
20:30:19 <Hijiri> but you will have to specialize it eventually if you want to run it
20:30:52 <Hijiri> if you want to use it in a bigger monadic thing you can use >>= or do notation like normal
20:31:38 <Hijiri> unitInterval >>= f will generate a number using unitInterval, then do the thing you get by applying f to it
20:32:21 <Hijiri> do { between0and1 <- unitInterval; ...} will bind a randomly-generated number from unitInterval to the name between0and1
20:32:21 <verement> lingxiao: you're eventually going to need to get a seed from somewhere, which means either getStdGen or mkStdGen or somesuch
20:32:45 <lingxiao> ok that's fine it can be evaluated last, eventually im in some IO so you're right
20:32:56 <lingxiao> but how do i run it? LOL
20:33:00 <verement> lingxiao: maybe a simpler approach would be to pass in an infinite list of random numbers to your stateful computation, which you can get from e.g. randoms
20:33:15 <lingxiao> I'll  jsut be honest, using randonmness in haskell is a bit cluncky
20:33:20 <Hijiri> lingxiao: once you have algo defined, specialize algo to use State and Rand
20:33:29 <lingxiao> verement please elaborate?
20:34:13 <julianleviston> lingxiao: All you can truthfully say is that your experience of using them is clunky.
20:34:29 <lingxiao> julianleviston: i know of at least one other person who agree
20:34:31 <verement> > getStdGen >>= randomRs (0, 1) :: IO [Double]
20:34:32 <lambdabot>      Couldn't match type ‘[]’ with ‘IO’
20:34:32 <lambdabot>      Expected type: StdGen -> IO [Double]
20:34:32 <lambdabot>        Actual type: StdGen -> [[Double]]
20:34:47 <julianleviston> lingxiao: must be a lock-in then ;-)
20:34:55 <julianleviston> lingxiao: (note I’m not disagreeing with you)
20:35:05 <verement> > (getStdGen >>= randomRs (0, 1)) :: IO [Double]
20:35:07 <lambdabot>  <hint>:1:47: lexical error at character '\FS'
20:35:10 <lingxiao> there are < 10 people using it, so 2/10 is a great singal :D
20:35:20 <lingxiao> on wall street id be making bank off of that, or so someone told me
20:35:21 <verement> hrm
20:35:32 <lingxiao> see verement can't use it either
20:35:33 <lingxiao> 3/10
20:36:18 <julianleviston> lingxiao: Yes, we get it. You’re frustrated.
20:36:35 <lingxiao> :> getStdGen >>= randomR (0,1) :: IO Double
20:36:42 <lingxiao> > getStdGen >>= randomR (0,1) :: IO Double
20:36:44 <lambdabot>      Couldn't match type ‘(,) Integer’ with ‘IO’
20:36:44 <lambdabot>      Expected type: StdGen -> IO Double
20:36:44 <lambdabot>        Actual type: Double -> (Integer, Double)
20:36:49 <Hijiri> > fmap (randomRs (0, 1)) getStdGen :: IO [Double]
20:36:51 <lambdabot>  <IO [Double]>
20:37:02 <verement> > randomRs (0, 1) <$> getStdGen :: IO [Double]
20:37:04 <lingxiao> > :t getStdGen
20:37:04 <lambdabot>  <IO [Double]>
20:37:05 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:37:20 <Hijiri> :t getStdGen
20:37:22 <lambdabot> IO StdGen
20:37:22 <lingxiao> julianleviston D: D: D:   but yes, actually i had it all working but now im refacotring to clean up the types
20:37:26 <lingxiao> and get rid of the lifts 
20:39:05 <Hijiri> lingxiao: if you have MonadRandom => m Double, you can use it directly in your (MonadRandom, ... <other constraints>) => m Result
20:39:16 <Hijiri> MonadRandom m, I mean
20:39:38 <lingxiao> Hijiri : yeah im realizing that, its kind of cool actually
20:39:42 <lingxiao> #allByNeed
20:39:49 <lingxiao> *callByNeed
20:41:43 <lingxiao> getStdGen out put the same seed each time?
20:42:15 <Hijiri> it gets the same one as long as you don't use any IO random functions
20:42:20 <Hijiri> or actions
20:42:36 <Hijiri> as long as you don't do anything that uses the global generator
20:42:55 <lingxiao> Hijiri : huh i actually dont know what the global generator is?
20:43:49 <Hijiri> when you do randomIO for example, it needs a random generator to generate the value. since you never give an explicit generator anywhere, instead there is a global RNG for IO
20:44:35 <Hijiri> when you use randomIO it basically takes the current global random generator, uses it to generate the value, then updates the global generator with the new gen
20:45:04 <Hijiri> I have to go eat now, sorry
20:45:19 <lingxiao> Hijiri no all good but thanks for that tidbit!
20:45:38 <wolfik> guys. I asked a question before about cabal. And I did it myself :D I'm proud of myself a little
20:45:48 <lingxiao> so the global RNG for IO is static?
20:45:56 <julianleviston> wolfik: well done :)
20:46:26 <wolfik> Thanks! updating cabal and ghc separatly and resolving dependencies is really a cabal hell
20:46:40 <julianleviston> wolfik: I guess that’s why we have stack. :)
20:47:16 <wolfik> I started with cabal and I wanted to finish it with cabal. I don't have time to learn stack right now
20:47:20 <wolfik> maybe someday
20:50:43 <kadoban> Okay, what is this syntax … so confuzed: https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/TemplateName.hs#L66  what does (T.unpack -> prefix) mean there?
20:51:15 <bitemyapp> kadoban: looks like a View pattern
20:51:35 <kadoban> Oh. Oh crap, should have looked at the extensions. Thanks, I'll … look up what those do, haha.
20:51:44 <bitemyapp> kadoban: https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text.html#g:21
20:53:04 <kadoban> Oh … that's really cool. I guess now I know what view patterns are.
20:53:09 <lingxiao> anyone tried to cabal install System.RandomIO
20:53:22 <lingxiao> https://hackage.haskell.org/package/liboleg-2010.1.10.0/docs/System-RandomIO.html
20:53:26 <lingxiao> i'm getting an error
20:53:37 <kadoban> lingxiao: You don't install modules, you install packages.
20:53:53 <lingxiao> right cabal install liboleg
20:54:23 <lingxiao> http://lpaste.net/147232
20:54:31 <lingxiao> error here ---^
20:55:10 <verement> lingxiao: not sure what you mean by static
20:55:40 <bitemyapp> lingxiao: that's a really arcane library that hasn't been updated since 2010
20:55:50 <lingxiao> Hijiri says: when you use randomIO it basically takes the current global random generator, uses it to generate the value, then updates the global generator with the new gen
20:55:51 <bitemyapp> lingxiao: why do you need this?
20:56:04 <lingxiao> Hijiri mentions it
20:56:05 <bitemyapp> lingxiao: I showed you an example that doesn't need this nutty library.
20:56:29 <lingxiao> yeah Im set on this signature in this incarnation of a major refactor:
20:56:31 <julianleviston> bitemyapp: he’s trying to make a stateful random sequence of coin tosses
20:56:36 <lingxiao> fair :: MonadRandom m => m Bool
20:56:37 <lingxiao> fair = (\p -> p <= 0.5) <$> getRandomR (0,1)
20:56:37 <bitemyapp> I remember that bit
20:56:45 <bitemyapp> this RBIO is out in left field though.
20:56:52 <bitemyapp> and the code I showed them
20:56:57 <bitemyapp> has the State variant in the same module
20:56:57 <lingxiao> bitemyapp that's fine i dont have to use it
20:57:18 <bitemyapp> so whether they want the IO or non-IO version, what I pointed them to should've been fine
20:57:20 <lingxiao> the issue is when i do    randomR (0,1 :: Double) <$> newStdGen
20:57:23 <verement> lingxiao: I think when Hijiri mentioned randomIO he meant System.Random.randomIO
20:57:29 <lingxiao> i get the same result every time
20:57:30 <bitemyapp> that's correct.
20:57:43 <bitemyapp> lingxiao: use IO or the State monad to bump the stdGen forward.
20:58:00 <julianleviston> what on earth does “bump the stdGen forward” mean?
20:58:01 <bitemyapp> lingxiao: we cover how to use the non-IO variant of the API (and get different results each time) in the State chapter of our book as it happens
20:58:10 <bitemyapp> julianleviston: you read the State chapter didn't you?
20:58:11 <verement> lingxiao: or use randomRs to generate an infinite list that automatically advances the seed
20:58:20 <bitemyapp> verement: not terribly idiomatic.
20:58:21 <julianleviston> bitemyapp: yep.
20:58:33 <bitemyapp> julianleviston: we demonstrated it there, unless you read a very old version or something.
20:58:36 <julianleviston> bitemyapp: I was asking you about “bump forward”.
20:59:02 <bitemyapp> julianleviston: you get two values from the pure API
20:59:07 <bitemyapp> julianleviston: one of them is the new generator
20:59:17 <bitemyapp> julianleviston: there's a "retained" generator that is preserved using the State Monad
20:59:20 <lingxiao> bitemyapp im absolutely not doing that
20:59:25 <lingxiao> that's really bad style
20:59:27 <bitemyapp> you "bump forward" to the next one by "put"'ing the new one in.
20:59:35 <lingxiao> i did that originally and refactored to RVar
21:00:20 <lingxiao> there's no system.random.randomIO that i can find?
21:00:27 <bitemyapp> oy, hold on
21:00:39 <bitemyapp> lingxiao: this library: http://hackage.haskell.org/package/random
21:00:47 <julianleviston> bitemyapp: roger roger. I just found “bump forward” a bizarre turn of phrase. All good.
21:00:47 <bitemyapp> lingxiao:  http://hackage.haskell.org/package/random-1.1/docs/System-Random.html this module in that library
21:00:55 <bitemyapp> lingxiao: then on the side is "synopsis"
21:01:00 <bitemyapp> lingxiao: you can use it to scan for things you want
21:01:20 <bitemyapp> lingxiao: http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#v:randomIO having clicked on "randomIO" in the synopsis, you get this link
21:01:38 <bitemyapp> lingxiao: it leverages this class: http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen
21:01:51 <lingxiao> bitemyapp ahh the synopsis button, it does do something
21:01:55 <bitemyapp> lingxiao: which is implemented by this type: http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:StdGen
21:02:10 <bitemyapp> gen -> (thingYouWantedARandomValueOf, gen)
21:02:12 <bitemyapp> lingxiao: ^^
21:02:41 <bitemyapp> lingxiao: that's what the IO variant is doing under the hood, except instead of having an explicit & pure State, it's mutating a global variable to accomplish the exact same semantics.
21:02:50 <bitemyapp> lingxiao: almost all random APIs work like this, they just usually hide it from you.
21:03:03 <bitemyapp> lingxiao: you get entropy _once_, then use a PRNG to walk the entropy forward through generators.
21:03:08 <lingxiao> bitemyapp yeah that's what i wanted i guess
21:03:18 <bitemyapp> lingxiao: using a the same generator twice will produce the same value twice. Because it performs no effects.
21:03:26 <bitemyapp> lingxiao: it doesn't pull in entropy out of thin air or anything
21:03:31 <bitemyapp> lingxiao: PRNGs are subject to a "period"
21:03:47 <lingxiao> bitemyapp ahh that clears it up thanks, my mental model of hwo it works is poor....
21:03:51 <lingxiao> what's period?
21:03:54 <bitemyapp> lingxiao: eventually the bits will repeat, but they're so far apart (described by the math that designs the algorithms) that it doesn't matter.
21:04:09 <julianleviston> lingxiao: space between two points in some dimension?
21:04:14 <bitemyapp> lingxiao: ie, that you shouldn't be able to figure out where the "seed" is at that you can start predicting the results.
21:04:35 <bitemyapp> lingxiao: you get the "next" value in the series described by the generator by using the _new_ generator it provides for each value
21:04:41 <bitemyapp> that's the second gen in the type I showed you.
21:04:47 <bitemyapp> that's the new one you must use to get a diff value.
21:04:53 <lingxiao> yeah that part i figured
21:05:03 <bitemyapp> Prelude> import System.Random
21:05:04 <bitemyapp> Prelude> mkStdGen 0
21:05:04 <bitemyapp> 1 1
21:05:04 <bitemyapp> Prelude> :t mkStdGen 0
21:05:04 <bitemyapp> mkStdGen 0 :: StdGen
21:05:06 <bitemyapp> Prelude> let sg = mkStdGen 0
21:05:08 <bitemyapp> Prelude> :t next sg
21:05:11 <lingxiao> i just thought newStdGen gave me a differenet seed each time
21:05:11 <bitemyapp> next sg :: (Int, StdGen)
21:05:13 <bitemyapp> Prelude> next sg
21:05:16 <bitemyapp> (2147482884,40014 40692)
21:05:18 <bitemyapp> Prelude> next sg
21:05:21 <bitemyapp> (2147482884,40014 40692)
21:05:24 <bitemyapp> Prelude> snd (next sg)
21:05:26 <bitemyapp> 240084 40692
21:05:28 <bitemyapp> Prelude> let newSg = snd (next sg)
21:05:31 <bitemyapp> Prelude> :t newSg
21:05:34 <bitemyapp> newSg :: StdGen
21:05:36 <julianleviston> uhhhh pastie?
21:05:36 <bitemyapp> Prelude> next newSg
21:05:38 <bitemyapp> (2092764894,1601120196 1655838864)
21:05:41 <bitemyapp> yadda yadda
21:05:44 <bitemyapp> so and on and so forth
21:05:46 <bitemyapp> now you can carry and pass each new gen yourself manually
21:05:50 <bitemyapp> if you want
21:05:51 <bitemyapp> but there are cleverer ways.
21:05:54 <bitemyapp> julianleviston: cba
21:05:56 <bitemyapp> copy-pasting from the verbatim blocks in the book :P
21:05:59 <bitemyapp> that's all for now.
21:06:01 <bitemyapp> from me anyway
21:06:06 <bitemyapp> I have a late-release to work on.
21:06:28 <bitemyapp> lingxiao: julianleviston reviewed our State chapter which goes into this in excruciating detail. Should be able to help you.
21:06:35 <julianleviston> I doubt it.
21:06:49 <julianleviston> I’ve only read it twice.
21:07:22 <julianleviston> … and I have never used it.
21:07:33 <bitemyapp> well that'll make things harder
21:07:46 <julianleviston> I’ve never needed to use it.
21:07:46 <bitemyapp> well in that case
21:07:47 <lingxiao> bitemyapp yeah prng makes sense to me, its more like what language construct i can use to not thread the new seed around that eludes me
21:07:53 <bitemyapp> lingxiao: State.
21:08:00 <bitemyapp> that's why I keep repeating that word.
21:08:08 <bitemyapp> I am digging up the example from the book
21:08:34 <flyzen> bitemyapp: Do you know Big O?
21:08:36 <julianleviston> lingxiao: I thought you *were* using MonadState in your MT?
21:08:39 <lingxiao> so at no point in teh code do i plan on doing   blah >>= (x,newSeed) -> put newSeed >> do more stuff
21:08:51 <lingxiao> that's for other stuff , sorry theres some confusion here
21:09:07 <lingxiao> like storing a counter of items seen so far
21:09:19 <bitemyapp> well it's a little obtuse, but here's the wikibook: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Pseudo-random_values_of_different_types
21:09:28 <bitemyapp> code is a little goofy but w/e
21:09:32 <bitemyapp> lingxiao: ^^ might get the idea across.
21:09:42 <lingxiao> ok will take a look!
21:10:06 <bitemyapp> lingxiao: less goofy: https://en.wikibooks.org/wiki/Haskell/Libraries/Random
21:18:07 * hackagebot unbound-generics 0.3 - Support for programming with names and binders using GHC Generics  https://hackage.haskell.org/package/unbound-generics-0.3 (AlekseyKliger)
21:30:50 <julianleviston> in a data declaration, does ! mean eager?
21:31:02 <julianleviston> context: data Map k a  = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a) | Tip
21:31:50 <geekosaur> strict / evaluate to WHNF, yes
21:31:51 <julianleviston> or is that to do with DeriveDataTypeable ?
21:31:56 <geekosaur> note that it is only WHNF
21:32:09 <julianleviston> ah...
21:32:24 <geekosaur> if a is [x] then your only guarantee is that the first constructor is a (:)
21:32:28 <julianleviston> yep.
21:32:56 <geekosaur> well, or [], but not bottom. 
21:33:15 <geekosaur> (undefined:undefined) would be acceptable to it but probably make you unhappy
21:35:19 <julianleviston> So Data.Map is built using “size balance trees”. Cool. Just looking at the implementation of it… particularly of fromList. It’s very interesting.
21:37:42 <julianleviston> in the implementation of fromList, (https://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html#fromList) there’s a couple of constructions under the where clause I don’t recognise/understand that read “STRICT_1_OF_3(go)” - what does that mean?
21:40:36 <geekosaur> looks like a cpp macro defined in containers.h
21:41:06 <geekosaur> which you;d have to "cabal get containers" to see what's in there; haddock almost certainly doesn't install its source for inspetion
21:41:29 <julianleviston> is CPP C++?
21:41:35 <julianleviston> as in… FFI?
21:41:36 <geekosaur> C preprocessor
21:41:36 <julianleviston> or?
21:41:57 <geekosaur> source macros
21:41:58 <julianleviston> GHC is built in C?
21:42:07 <julianleviston> (confused) I though it was self-bootrstrapping?
21:42:26 <geekosaur> no. it can (ab)use C's preprocessor for macros and conditional compilation
21:42:27 <flyzen> Yes.
21:42:30 <athan> Is there a canonical `FromPairs` or `ToPairs` typeclass for parsing and encoding a data type to [(a,b)], where a and b might be text or bytestrings?
21:42:39 <julianleviston> haha one says yes, the other no.
21:42:44 <julianleviston> so it *is* built in C?
21:42:48 <geekosaur> I think we were answering different questions
21:42:55 <julianleviston> k
21:42:57 <geekosaur> it is not, aside from some low level bits, written in C
21:43:06 <julianleviston> ok
21:43:29 <geekosaur> it does use C's preprocessor to preprocess Haskell code, if you enable LANGUAGE CPP, so you can do conditional compilation based on ghc version
21:43:30 <julianleviston> so, in this case, I can just ignore those pieces?
21:43:58 <geekosaur> ad define macros that expand to Haskell code, which is what;s going on on those STRICT_1_OF_n() lines
21:44:15 <geekosaur> again, you should find the definitions in containers.h in the source to the containers package
21:44:20 <julianleviston> ok
21:44:32 <julianleviston> I think this has satisfied my level of interest for the present.
21:44:35 <julianleviston> geekosaur: thanks! :)
21:58:09 * hackagebot yesod-core 1.4.18 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.18 (MichaelSnoyman)
22:10:52 <julianleviston> in “data Blah = Yay [String] | Nay [Integer]” is there a name for each side of the pipe? Would that be simply called “one of the data constructors of the Blah type”?
22:12:23 <verement> data constructor alternatives?
22:14:05 <julianleviston> verement: sum type possiblities?
22:14:34 <verement> I still like alternatives
22:14:56 <kadoban> data constructors, or value constructors seems fine to me.
22:14:58 <julianleviston> I was wondering if there was a “condoned” name more than some name.
22:16:09 <julianleviston> So I guess the shape would be a set of alternatives to choose from, that may have one or more types inside each.
22:17:05 <julianleviston> and are the (>1)-arity type constructors, are their “arguments” called their fields? They’re potentially named fields, right?
22:17:06 <bollu> how do you compose errors in haskell?
22:17:17 <julianleviston> bollu: using ErrorT ?
22:17:27 <bollu> if I have some functions that produce errors of type Error1, and another set of functions that produce errors of type Error2
22:17:36 <bollu> how do I write a function that can handle both?
22:17:43 <bollu> julianleviston: oh, I don't know that exists
22:17:49 <julianleviston> bollu: did you build these error1 and error2 types yourself?
22:18:03 <bollu> julianleviston: yes, they're just naive sum types
22:18:05 <julianleviston> bollu: it’s kind of like Either.
22:18:26 <verement> julianleviston: the Haskell 2010 Language Report calls them "constituent data constructors"
22:18:30 <bollu> julianleviston: yeah, it's used as Either Error1 Result1 and Either Error2 Result2
22:18:33 <julianleviston> bollu: ah ok… you might be better off using ErrorT if you’re comfortable with transformers.
22:18:40 <bollu> "Error" was probably not the best choice of works
22:18:45 <bollu> words*
22:18:55 <bollu> julianleviston: yeah, I've used transformers :) thanks for the pointer
22:19:03 <julianleviston> bollu: then you can use monadic composition via do blocks.
22:19:15 <julianleviston> bollu: which will (obviously) use bind.
22:19:33 <julianleviston> verement: brilliant! just what I was after.
22:19:36 <bollu> julianleviston: slick, ty
22:23:02 <magbo> Hello, beautiful people. I am in need to make a module that will export cryptographic primitives, s.t. my other libraries don't care about implementation details.
22:23:29 <magbo> While doing so, I'm facing with a design challenge regarding things that should be hashable, encryptable, signable.
22:23:56 <julianleviston> Wow this is fascinating work: https://github.com/alanz/HaRe
22:24:47 <magbo> I'm considering creating a typeclass "Distinct" s.t. encrypt :: (Distinct t) => PublicKey -> t -> Ciphertext t
22:25:11 <julianleviston> @where report
22:25:11 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
22:26:23 <magbo> If a type is a member of typeclass "Distinct", for each pair of values of this type x_1 and x_2, serialize(x_1) \neq serialize(x_2)
22:26:33 <julianleviston> verement: where in the report?
22:27:08 <julianleviston> verement: nvm I found it… under 4.2 - user defined data types
22:27:22 <verement> right
22:27:32 <magbo> I have a feeling that I'm (1) reinventing the wheel here; (2) using typeclasses, but instead I could have used something that can enforce the "Distinct law" better.
22:27:38 <magbo> What's your opinion on this?
22:28:25 <liste> magbo what's `serialize' ? any serialization, like read/show, json, binary?
22:31:55 <verement> magbo: what value does "Distinct" give you?
22:33:44 <kadoban> magbo: I suspect that's not something haskell can verify for you, so as a typeclass I'm not sure it makes a lot of sense. I mean you could have that typeclass and just have that law if you want … but it'll be up the implementor to guarantee it. And it'll have no methods, right?
22:38:47 <kadoban> magbo: I suspect you should just implement whatever type you're talking about, and just make sure you serialize it such that values are distinct when serialized, and call it a day? Maybe I'm missing the point.
22:56:53 <athan> Is there a canonical `FromPairs` or `ToPairs` typeclass for parsing and encoding a data type to [(a,b)], where a and b might be text, string, or bytestrings? I feel like it might be.. kinda useful, I dunno :s
22:57:09 <athan> like for keyed structures
22:58:59 <athan> I could see something like `class FromPairs k v a | a -> k v where; parsePairs :: [(k,v)] -> Maybe a`
22:59:24 <athan> and `class ToPairs k v a | a -> k v where; toPairs :: a -> [(k,v)]`
22:59:37 <athan> idunno s_s
23:01:22 <magbo> kadoban: I want to be able to hash a type that doesn't exist yet. I want to allow the author of the type in question provide a facility to say "this type should work with crypto-primitives library" by, say, implementing a typeclass with functions ByteString -> t and t -> ByteString.
23:02:31 <magbo> It's very close to Show, but it should be there as a mean of hinting to the implementer that they should think about serialization being different for different values of this type.
23:03:08 <magbo> I don't think that anything smarter than a typeclass fits this design challenge.
23:04:05 <Ferdirand> magbo: this exists
23:04:15 <Ferdirand> it's called Binary iirc
23:05:03 <Ferdirand> Data.Binary in the binary packagr
23:09:47 <magbo> Ferdirand: thanks for the hint.
23:34:02 <Hijiri> athan: something like a typeclass version of IndexedTraversal?
23:36:09 <Hijiri> I actually haven't done much with IndexedTraversal but it looks like there is stuff for traversing with an index
23:36:16 <Hijiri> and you could get a pair list from their
23:36:19 <Hijiri> there
23:59:04 <lightandlight> Does anyone know a portable way to run a subprocess silently?
