00:02:18 <kyagrd> roelof: I tried o koding
00:05:40 <roelof> kyagrd:  and does it work well with Haskell ? 
00:06:01 <xxmissingnoxx> Thank you ReinH. I'll give it a shot. 
00:07:27 <kyagrd> roelof: just install ubuntu package and it worked
00:07:39 * hackagebot warp 3.1.11 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.11 (KazuYamamoto)
00:07:39 * hackagebot warp-tls 3.1.5 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.1.5 (KazuYamamoto)
00:08:32 <roelof> kyagrd:  thanks, then I will give koding a shot. I tried c9.io myself but had some trouble with coverage reports which not worked 
00:08:39 <roelof> BRB
00:08:49 <kyagrd> roelof: but sometimes compiling soureces that require a lot of memory might fail. For basic things should work
00:09:38 <roelof> kyagrd:  oke, do you use stack or cabal ? 
00:11:54 <kyagrd> roelof: I just used cabal. Stack by default installs its own ghc and src compile most of things so not pleasant on koding. Installing as many distro deb ghclib packages is the way to go on such env
00:14:16 <jle`> > read "Sum 1" :: Sum Int
00:14:18 <lambdabot>  Sum {getSum = *Exception: Prelude.read: no parse
00:14:35 <jle`> i feel like that's a little weird, but, you probably are doing something wrong if you're using `read` to parse a Sum Int
00:14:44 <jle`> so i guess it doesn't matter?
00:20:07 <pavonia> > read "Sum { getSum = 1 }" :: Sum Int
00:20:09 <lambdabot>  Sum {getSum = 1}
00:21:27 <pavonia> I'm wondering if a certain order of the fields is required if you have more than one
00:24:19 <exio4> @let data R = R { f1 :: Int, f2 :: String } deriving (Eq,Ord,Show,Read)
00:24:21 <lambdabot>  Defined.
00:25:14 <exio4> > map read ["R { f1 = 1, f2 = \"2\" }", "R { f2 = \"2\", f1 = 1 }"] :: [R]
00:25:16 <lambdabot>  [R {f1 = 1, f2 = "2"},*Exception: Prelude.read: no parse
00:25:30 <exio4> pavonia: loooks like so? 
00:25:46 <pavonia> Yeah
00:25:49 <exio4> looks* 
00:26:23 <exio4> next time I'll use booleans, instead of strings :p 
00:26:41 <pavonia> As compared to the Sum type it doesn't even parse the R constructor, though
00:27:48 <pavonia> Probably has to do with newtype vs. data
00:28:28 <exio4> > read "Sum { abc = 42 }" :: Sum Int
00:28:30 <lambdabot>  Sum {getSum = *Exception: Prelude.read: no parse
00:28:34 <exio4> hmm, weird
00:30:15 <jle`> conclusion is that it's useless to read, i've been taught lies throughout grade school
00:31:00 <pavonia> > undefined :: Sum Int
00:31:02 <lambdabot>  Sum {getSum = *Exception: Prelude.undefined
00:32:09 <exio4> oh, the show instance is doing the trick? 
00:32:11 <exio4> makes sense
00:32:35 * hackagebot edis 0.0.1.0 - Statically typechecked client for Redis  https://hackage.haskell.org/package/edis-0.0.1.0 (TingYenLai)
00:43:51 <phaazon> exio4: I guess it’s something like
00:44:15 <phaazon> show i = "Sum {getSum =" ++ show (getSum i) ++ "}"
00:44:31 <phaazon> so i is not needed until the show part
01:20:16 <zipper> Hello, theres this type used to represent version in haskell. The kind of version printed when you use the --version argument.
01:20:49 <zipper> https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Version.html#t:Version
01:21:42 <zipper> However, it only shows the first 3 sections of a version. However, cabal supports up to 4. This means a version like 0.0.0.2 will show as version 0.0.0 instead of what it actually is.
01:21:55 <zipper> Any idea how I can get around this?
01:26:48 <pavonia> zipper: Looking at the code doesn't give any hints it only provides versions with three parts
01:27:24 <zipper> pavonia: What are you saying.
01:28:23 <pavonia> You said "However, it only shows the first 3 sections of a version" -- Have you verified that with some actual code?
01:28:56 <pavonia> From the source code I can't see why it would do that
01:29:21 <zipper> pavonia: Yes I have.
01:30:24 <zipper> pavonia: http://lpaste.net/3157989457320214528
01:31:10 <l3dx> foldl (+) 0 $ parMap rdeepseq (\p -> snd $ combined p) pinit -- please educate me. shouldn't this be an effective use of parallel processing? pinit is a list of (Int, Int) and combined gives me a score associated with that point
01:34:48 <joco42> i wonder if in cabal repl the modules imported in Main.hs are always also loaded into the repl? it seems so, is this behaviour configurable somewhere?
01:37:04 <quchen> l3dx: First of all, don't write foldl (+), use foldl' for that.
01:37:59 <quchen> If what you want is to fully force a list in parallel with one thread per list element, then that looks right to me.
01:42:02 <l3dx> quchen: thanks. I'm trying to reduce the processing time of that operation so I figured running the map in parallell would be low hanging fruit
01:42:41 <quchen> l3dx: parListChunk is usually a better choice in my experience. Instead of a thread per list element, it spawns one thread per N elements.
01:42:42 <l3dx> but it doesn't perform any better than one thread
01:43:13 <l3dx> cool, I'll read up on that
01:43:31 <quchen> I'm not sure about the name, but it has "chunk" in it and it's in the same modules
01:44:02 <carmethene> I need some terminology help...
01:44:12 <carmethene> so, a functor is a mapping (morphism) between two categories
01:44:30 <l3dx> quchen: the name was spot on :)
01:44:31 <carmethene> which I would understand to be, for example, Int to Maybe Int
01:44:37 <quchen> A morphism is not necessary a mapping.
01:44:48 <quchen> A functor is a mapping/function between categories, yes.
01:44:51 <carmethene> ok, I'll stick with mapping
01:45:03 <carmethene>  I'm new to cat theory :P
01:45:19 <carmethene> so, what I'm missing is that, in the case of Maybe
01:45:26 <carmethene> Maybe is a member of the Functor type class
01:45:46 <carmethene> but according to that terminology, it's not Maybe that's the functor
01:45:58 <carmethene> so, what am I missing?  Is Maybe not a category?
01:46:05 <quchen> The Maybe Functor maps the objects "X" to "Maybe X", and the morphisms "f" to "fmap f".
01:46:18 <jle`> Maybe is the functor
01:46:28 <carmethene> so the Maybe Functor is different to the Maybe type constructor?
01:46:31 <jle`> the category is the category whose objects are haskell types, and whose morphisms are functions
01:46:59 <quchen> "Maybe X" is a subcategory of Hask for each object X in Hask. The Maybe Functor maps from Hask to that subcategory of Hask.
01:47:10 <carmethene> morphisms being the transformations within the category, ok got that bit
01:47:25 <jle`> the functor is the Maybe type constructor, along with fmap for Maybe
01:47:40 <jle`> a functor is (1) a mapping between objects, and (2) a mapping between morphisms
01:47:41 <carmethene> right
01:47:44 <jle`> the type constructor is (1)
01:47:46 <jle`> fmap is (2)
01:47:48 <carmethene> ahhhh
01:47:56 <carmethene> ok so the type constructor is a different thing to the actual types
01:48:09 <carmethene> Maybe a is the category, Maybe is the functor
01:48:12 <carmethene> or part of the functor
01:48:18 <carmethene> fmap being the remainder
01:48:29 <carmethene> is that right?
01:48:42 <jle`> `Maybe a` is not "the category"; not sure what you mean by that
01:49:03 <jle`> both the source and target category here are the same.  it's a functor from Hask -> Hask
01:49:10 <carmethene> oh
01:49:13 <quchen> You could say that "The Maybe Functor" is ("The Maybe type constructor", fmap).
01:49:17 <carmethene> maybe I misunderstand what category means
01:49:31 <carmethene> I took it to mean a set of values, like Integer or Float
01:49:44 <carmethene> effectively a type
01:49:49 <carmethene> it sounds like I was mistaken
01:50:01 <jle`> that's what we normally call a "set"
01:50:10 <carmethene> sure
01:50:12 <jle`> a category is a set of objects, with a set of morphisms
01:50:30 <jle`> in Hask, the objects are Haskell types -- Int, Bool, String, Maybe Double, IO (), etc.; those are all objects
01:50:31 <carmethene> ok right
01:50:59 <jle`> the morphisms are functions, so *values* of type `Int -> Bool` are morphisms, *values* of type `Maybe Double -> IO ()` are also morphisms, etc.
01:51:21 <jle`> so, the Maybe type constructor maps objects to other objects.  types to other types
01:51:33 <jle`> it maps Int to Maybe Int, Bool to Maybe Bool, IO () to Maybe (IO ()), etc.
01:51:39 <carmethene> but all of these objects exist within the same category?
01:51:46 <jle`> give Maybe a type, and it'll give you another type
01:51:54 <wedens> have somebody used approach called "event sourced" in production?
01:52:21 <carmethene> maybe I should just forget about categories, I think it's adding to the confusion unnecessarily
01:52:24 <jle`> Int, Bool, String, etc. are objects in the Hask category
01:52:31 <carmethene> right
01:52:39 <carmethene> ok, I see where I was confused
01:52:59 <carmethene> thank you that helps a lot
01:53:16 <carmethene> this all started from trying to understand functors :P
01:53:36 <jle`> np
01:54:20 <carmethene> am I being sensible just continuing to try to pick this stuff up through Haskell?
01:54:51 <carmethene> I mean, I don't have a formal math education
01:55:28 <carmethene> I guess that's an open ended question, nm
01:55:32 <carmethene> thanks again
01:57:21 <vandenoever> why are qualifiers needed in constructors?   let myObject = O.Object { O.name = "name" } ?
01:57:39 <vandenoever> i'd think 'name = "name"' would suffice
01:57:55 <tdammers> they aren't required
01:58:10 <tdammers> many types are designed for qualified importing though
01:58:34 <vandenoever> tdammers: i'm using a simple data Object { name :: String } here
01:58:39 <tdammers> yes
01:58:50 <tdammers> you don't need to qualify the record fields
01:58:52 <vandenoever> tdammers: the 'name' is used in other data types too
01:59:09 <tdammers> then you do need to disambiguate, and qualifying is the easiest way
01:59:10 <vandenoever> tdammers: ghc tells me there's ambiguity
01:59:21 <tdammers> that's because record field names are in the top-level namespace
01:59:31 <tdammers> Haskell doesn't namespace them by record type
01:59:33 <vandenoever> tdammers: ok, so the compiler does not recognize the context for the names
01:59:48 <tdammers> kind of
02:00:16 <tdammers> the language specifies that records do not introduce namespaces
02:00:18 <vandenoever> tdammers: thanks, good to know i'm not overlooking something, i'll settle for the slightly verbose qualifiers
02:00:25 <tdammers> yeah
02:00:34 <tdammers> it's either that, or using hungarian warts
02:00:42 <carmethene> 01:49         jle`  : both the source and target category here are the  same.  it's a functor from Hask -> Hask
02:00:46 <tdammers> data Object = Object { objName :: String }
02:00:50 <carmethene> ding ding ding, jle` thanks!
02:00:53 <vandenoever> tdammers: yeah, or positional arguments :-/
02:00:59 <tdammers> yep
02:00:59 <carmethene> took a second for all of that to sink in
02:01:14 <tdammers> it's a rather common (and valid) complaint about Haskell
02:01:33 <tdammers> people are working on solutions, but it's a hard problem
02:01:52 <vandenoever> tdammers: i found that positional arguments can lead to subtle bugs despite the strong typing
02:02:22 <vandenoever> tdammers: so i try to use the explicit record notation
02:02:50 <tdammers> yeah, positional is still 'vulnerable' when you have multiple args of the same type
02:03:53 <Ke> I guess everything should have it's own type anyway
02:06:03 <vandenoever> Ke: that's certainly a good precaution
02:06:57 <vandenoever> would be quite some work to give each column in the db its own type and give even more similarly named types
02:07:42 <plazmoni1> anyone has any experience with multithreding in haskell?
02:08:02 <tdammers> plazmoni1: plenty of people here have, what's your question?
02:08:32 <plazmoni1> tdammers: well, if you have any resoure to recommend
02:08:40 <plazmoni1> tdammers: no exact questions yet
02:08:53 <plazmoni1> tdammers: just starting with a problem 
02:09:16 <tdammers> haddock for Control.Concurrent on hackage, and the relevant haskell wiki entries, are good starting points
02:09:40 <plazmoni1> tdammers: thanks
02:12:43 <tekkkz> looool
02:12:49 <tekkkz> whats going on here?
02:13:05 <tdammers> netsplit
02:13:22 <tdammers> https://en.wikipedia.org/wiki/Netsplit
02:14:07 <liste> script kiddies sure love pounding Freenode
02:14:54 <tekkkz> xD
02:17:52 <nshepperd> Dammit, wifi
02:27:19 * frerich is amazed people apparently use #haskell without hiding join/part messages...
02:31:51 <xacktm> I have them shown initially, but also a key to hide all previous ones if I want; best of both worlds I think
02:33:29 <tekkkz> frerich, thx, this was a good idea
02:34:41 <osfameron> frerich: I hide those, but not 'foo_ is now known as foo' messages, which you also get a swathe of after a netsplit rejoins :-)
02:38:44 <RaceCondition> is there a reason the backtick infix call syntax couldn't work on expressions not just names?
02:39:01 <merijn> RaceCondition: Mostly I think because it makes the grammar a pain in the ass
02:39:10 <merijn> RaceCondition: And it can easily becomes hard to read
02:39:23 <RaceCondition> merijn, oh, right, the first point crossed my mind
02:39:24 <merijn> RaceCondition: No fundamental theoretical reasons I can think off
02:40:05 <merijn> Plus it's easy enough to do "let foo = ... in bar `foo` baz"
02:40:18 <merijn> Instead of writing "bar `...` baz"
02:55:35 <ell> Hi folks
02:56:03 <liste> hi ell
03:00:08 <SimpleX_> Hi! Could you lend me some help with Pipes please?
03:01:11 <SimpleX_> I have simple producer and consumer, Producer reads from udp socket (System.Socket lib) and consumer simply prints received data.
03:01:39 <SimpleX_> But if I add forever to Consumer, it doesn't print anything.
03:01:39 * hackagebot haskell-names 0.6.0 - Name resolution library for Haskell  https://hackage.haskell.org/package/haskell-names-0.6.0 (PhilippSchuster)
03:01:39 * hackagebot configifier 0.0.8 - parser for config files, shell variables, command line args.  https://hackage.haskell.org/package/configifier-0.0.8 (MatthiasFischmann)
03:02:18 <liste> @paste -- SimpleX_ please paste your code here
03:02:18 <lambdabot> Haskell pastebin: http://lpaste.net/
03:04:39 <SimpleX_> liste: You don't need fully working code, right?
03:04:49 <SimpleX_> Just significant parts?
03:04:59 <liste> yeah, significant parts
03:05:31 <SimpleX_> liste: http://lpaste.net/147570
03:07:32 <liste> SimpleX_ you send before the receiver is ready
03:08:01 <liste> so there's a client in the other side of the socket?
03:08:34 <SimpleX_> It's udp, I test it with netcat, so it's not a problem
03:09:20 <ell> Is there a function which takes two integers and gives the ordering of them to each other?
03:09:40 <Taneb> ell: compare
03:09:42 <Taneb> :t compare
03:09:43 <lambdabot> Ord a => a -> a -> Ordering
03:09:50 <ell> ah compare, thanks
03:09:57 <Taneb> > 4 `compare` 7
03:09:59 <lambdabot>  LT
03:10:48 <liste> SimpleX_ does it work if you replace receiver with `yield $ Message "testing" someaddr' ?
03:10:52 <SimpleX_> liste: if I remove forever from consumer, it prints just once and exits. But with forever it doesn't work.
03:11:35 <SimpleX_> So receiveFrom works
03:17:43 <SimpleX_> liste: Well, pipe works, but for some reason print doesn't. I've changed printer so it responds back to sender. It sends back the message, but doesn't print it in terminal.
03:17:55 <SimpleX_> Could it be due to some buffering?
03:18:37 <joco42> what is the nicest intro to traversables/applicatives
03:18:49 <joco42> nicer than lyhfgg
03:18:56 <joco42> ?
03:19:10 <liste> SimpleX_ yes, could be buffering
03:19:13 <joco42> i had a look at http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
03:19:14 <liste> try flushing in between
03:19:29 <liste> afaik by default the buffer is flushed after each newline
03:19:31 <joco42> but it would be nice to have somehting more ... educational
03:19:45 <liste> and if there's no newlines in the input...
03:20:04 <liste> joco42 have you read typeclassopedia?
03:20:19 <joco42> liste:  i have a look, again...
03:22:58 <merijn> joco42: Typeclassopedia?
03:25:26 <SimpleX_> liste: it's not buffering, it's terminal in NeoVim. I think it doesn't print stdout =)
03:25:39 <SimpleX_> liste: thanks for your help anyway!
03:26:56 <SimpleX_> liste: or something else. But in other terminal it works just fine.
03:33:56 <hunteriam> Idk if my last message sent but " is it possible to make a type class that takes two types
03:35:26 <merijn> hunteriam: Yes, MultiParamTypeClasses extensions
03:36:34 * hackagebot xml-conduit 1.3.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.3.3 (MichaelSnoyman)
03:38:24 <bamboo> is there an alternative to hspec-expectations-pretty that will install on base >= 4.8 ?
03:38:45 <merijn> bamboo: You could try manually changing the constraint on base to see if it happens to still compile
03:38:51 <merijn> bamboo: Pretty big odds that it will
03:39:17 <bamboo> hm, right, it’s worth a try, thanks merijn
03:39:34 <merijn> There's also some cabal flag that says "ignore upper-bounds"
03:41:37 <bamboo> —allow-newer=base seems to do the trick
03:47:48 <bamboo> just found hspec-expectations-pretty-diff, much better 
03:47:55 <cvd5dvj13> Can anyone advise where can I find some tasks for haskell learning?
03:51:51 <zoku> cvd5dvj13: http://learnyouahaskell.com/
04:02:48 <hunteriam> How useful is learning category theory?
04:03:08 <hunteriam> I've been learning it with the hope that I could write really abstract code but I haven't been ab,e to do that yet
04:03:18 <merijn> hunteriam: As a means to become better at haskell?
04:03:31 <merijn> I would say it's generally overrated
04:03:47 <hunteriam> To become better as Haskell or programming
04:03:59 <hunteriam> I really just want to write extremely abstract code
04:04:05 <merijn> I'd recommend type theory, lambda calculus, logic, basic algebra and proofs as better stepping stones
04:04:07 <mpickering> I have a hy profile which seems to indicate that most of the allocations are because of [], does that mean that the allocations are because the (:) constructor or because of the things inside the list?
04:04:23 <merijn> Category theory only beomces useful once you hit the parts of the above where you start needing it
04:04:28 <hunteriam> Basic algebra? How are proofs helpful as well?
04:04:36 <merijn> And writing abstract code is mostly a matter of practice
04:05:03 <merijn> hunteriam: You want to start writing code that is "correct by construction", instead of testing for bugs you want to prove that the code can't possible contain bugs
04:05:18 <hunteriam> I read some slightly humorous page "the evolution of a Haskell programmer" and I was inspired by the so called post doc code
04:05:25 <hunteriam> I wonder what you study to write like that?
04:06:25 <merijn> hunteriam: I'd say type theory and start looking of the algebra of data types
04:06:36 <merijn> (There's a reason they're called Algebraic Data Types)
04:07:46 <hunteriam> Lectures on type theory?
04:07:54 <merijn> Some interesting books are "Types and Programming Languages" and "Software Foundations" (available for free online)
04:08:30 <hunteriam> You don't happen to have any taped lectures from a course that you know of/recommend do you?
04:08:33 <merijn> I'm not aware of any good free lectures, the Oregon Programming Languages Summer School puts their lectures online, there might be some good ones there. But the the best starting point would be TaPL
04:08:36 <hunteriam> I really enjoy learning that way
04:08:44 <hunteriam> Hmm ok
04:08:52 <hunteriam> How would you suggest approaching that book
04:08:59 <hunteriam> Should I just read it cover to cover or?
04:09:32 <merijn> hunteriam: TaPL basically starts out with untyped lambda calculus and gradually builds more and more complex type systems on that. It has example type checkers/inferers for all of them (written in ocaml, but a basic subset of ocaml that any beginner haskeller should be able to read no problem)
04:09:55 <hunteriam> Is ocaml more fully featured than Haskell?
04:10:00 <hunteriam> Or more expressive?
04:10:19 <merijn> hunteriam: It requires very little background theory to start. I'd say the first 12 or so chapters are mandatory reading, after that pick the ones that interest you (it has a dependency flowchart in the book)
04:10:32 <hunteriam> Cool ok
04:10:40 <merijn> hunteriam: I'd say ocaml is mostly different, not really more full featured or whatever
04:10:44 <hunteriam> The last book I tried reading I found hard to maintain an interest in
04:10:51 <hunteriam> But I guess I'll give this one a go
04:11:07 <merijn> hunteriam: I'd say that after reading about 50-75% of the book you should be able to implement something like Haskell's type system without too much difficulty
04:11:12 <hunteriam> It was "type theory and for,al logic"
04:11:17 <hunteriam> Oh wow that's fantastic!
04:11:27 <hunteriam> Talk about #breakgoals
04:11:32 <hunteriam> If only that was a real thing
04:11:45 <merijn> hunteriam: It's very much focussed on how to implement type systems
04:12:04 <hunteriam> I'm very interested in writing maximally abstract code
04:12:11 <zipper> Hello, I want to implement a --version arg in my executable. Problem is that I can't have the .cabal file after compilation. What can I do to be able to read or access my cabal file after compilation?
04:12:15 <hunteriam> Still think this is the book for me?
04:12:18 <merijn> hunteriam: To be honest, implementing haskell is fairly easy if you don't care about optimisation/performance
04:12:40 <hunteriam> Ok
04:13:18 <merijn> hunteriam: I don't think it adresses that goal very directly. But I think any blog post/paper on abstract code assumes a basic familiarity with types and lambda calculus and I don't know better courses/books to teach that
04:13:41 <merijn> zipper: I think there's some cabal macros that let you access that
04:14:26 <zipper> merijn: Cabal macros?
04:14:47 <merijn> zipper: Cabal generates a bunch of exports for you that include the version of the library it's building but I forgot how to include it
04:14:52 <zoku> Does anyone have suggestions for where to get started with lenses?
04:15:28 <zoku> I'm trying to use wreq for json, but i don't know how to use the lenses well 
04:15:37 <merijn> zipper: https://stackoverflow.com/questions/2892586/how-can-my-haskell-program-or-library-find-its-version-number
04:19:13 <zipper> merijn: I'm googling around for Paths_$myprogram but can't find info on it.
04:19:28 <merijn> zipper: It's auto generated by cabal
04:20:35 <merijn> zipper: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
04:26:39 <zipper> Say I have a package "wai-devel" I tried `import Paths_wai-devel (version)` however I got "Could not find module ‘Paths_wai’" when I attempted to compile.
04:27:51 <tekkkz> bitemyapp, are you here?
04:27:52 <bergmark> zipper: replace dash with underscore, dashes are not allowed in module names
04:28:30 <quchen_> Has anyone here run the GHC Shake build system? I'm getting a Hadock error, "inplace/bin/haddock not found and no rule available"
04:35:19 <zipper> bergmark: Heh the package name has a dash.
04:35:43 <zipper> I tried replacing the dash with an underscore in the import section but...
04:36:12 <zipper> It failed.
04:36:21 <zipper> During the linking
04:37:12 <Unhammer> http://sprunge.us/aEED is there a fn like this in one of the typeclasses?
04:37:21 <Unhammer> orMap2 :: forall s. (s -> s -> s) -> Maybe s -> Maybe s -> Maybe s
04:38:20 <bergmark> zipper: that is the way to import paths modules. is that module exposed? 
04:38:41 <zipper> bergmark: https://gist.github.com/urbanslug/15cd0c0e9ce5504bfa51/84aa31122eeee3d58fd134b6efa5f00f7982672c 
04:38:57 <zipper> bergmark: No because it doesn't exist?
04:39:11 <zipper> bergmark: I get your point
04:39:51 <merijn> Anyone aware of an easy library for dealing with data that needs a finalizer?
04:40:03 <merijn> I can roll something myself using System.Mem.Weak, but that's a pain...
04:40:09 <zipper> bergmark: Thanks
04:40:16 <zipper> It worked after I exposed it
04:41:25 <aweinstock> Unhammer: liftA2?
04:41:44 <aweinstock> :t liftA2
04:41:46 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:42:09 <aweinstock> :t liftA2 :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
04:42:10 <lambdabot> (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
04:43:00 <merijn> bollocks...
04:43:08 <merijn> Why does IORef not have an Ord instance? :\
04:43:20 <aweinstock> Unhammer: oops, liftA2 for Maybe corresponds to and, not or
04:44:49 <aa_> I'm not sure if this is the place but I've got a noobie question. Why does let a=newIORef 23; liftA2 modifyIORef a (return (+10)) not yield 33? I used this in ghci and keep getting 23 as the value for a still.
04:44:55 <breadmonster> merijn: Why would IORef have an ord instance?
04:45:11 <breadmonster> :t modifyIORef
04:45:13 <lambdabot>     Not in scope: ‘modifyIORef’
04:45:13 <lambdabot>     Perhaps you meant one of these:
04:45:13 <lambdabot>       ‘modifySTRef’ (imported from Data.STRef),
04:45:13 <merijn> breadmonster: Because they easily could and now I can't use them as keys in a Map
04:45:20 <merijn> breadmonster: They have an Eq instance too
04:45:22 <breadmonster> merijn: Implement?
04:45:39 <merijn> breadmonster: IORef has an identity (i.e. pointer) you could just compare pointers
04:45:47 <breadmonster> Oh right.
04:45:49 <aweinstock> :t reallyUnsafePtrEquality#
04:45:50 <lambdabot> Not in scope: ‘reallyUnsafePtrEquality#’
04:46:06 <aweinstock> :t GHC.Prim.reallyUnsafePtrEquality#
04:46:07 <lambdabot> a -> a -> GHC.Prim.Int#
04:46:36 <vektor> Does anyone here know why https://hackage.haskell.org/package/parallel-io-0.3.3/docs/src/Control-Concurrent-ParallelIO-Local.html#parallel uses [] instead of Traversable? For all I can tell, forM is defined in terms of Traversable.
04:46:42 <merijn> Is there a a reallyUnsafePtrCompare# ?
04:46:54 <jmcarthur> aweinstock: not really the same :)
04:47:01 <merijn> breadmonster: Which has perfectly sensible semantics and then you could use them as keys :)
04:47:08 <vektor> docs link: https://hackage.haskell.org/package/parallel-io-0.3.3/docs/Control-Concurrent-ParallelIO-Local.html#v:parallel
04:47:08 <aweinstock> aa_: each "a" is a new IORef since you're using let, replace that with "a <- newIORef 23"
04:47:15 <breadmonster> oh hey jmcarthur 
04:47:27 <breadmonster> merijn: But it's fairly meaningless, yeah?
04:47:50 <jmcarthur> merijn: Eq works even if the pointers move around in memory due to GC. Ord doesn't.
04:47:59 <merijn> breadmonster: It doesn't tell you anything useful now, besides defining a stable ordering
04:48:13 <merijn> Maybe I just want ResourceT?
04:48:57 <breadmonster> merijn: How do I convert Int# to Int?
04:49:23 <jmcarthur> breadmonster: where did you get an Int# without knowing how it relates to Int?
04:49:23 <merijn> Ok, basically I need to track lifetimes (i.e. provide a finalizer) for a file, but I can't use the bracket pattern because lifetimes vary
04:49:36 <merijn> breadmonster: Use the Int constructor? :p
04:49:38 <merijn> :t I#
04:49:39 <lambdabot>     Not in scope: data constructor ‘I#’
04:49:39 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
04:49:44 <merijn> hmmm, not imported
04:49:45 <jmcarthur> breadmonster: in one of the GHC.* modules the constructor for Int is available. I#
04:50:00 <merijn> breadmonster: https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Exts.html#t:Int
04:50:04 <breadmonster> Fantastic.
04:50:12 <aweinstock> :t \(GHC.IORef.IORef (GHC.STRef.STRef x)) -> x
04:50:13 <lambdabot> GHC.IORef.IORef t -> GHC.Prim.MutVar# RealWorld t
04:50:21 <aweinstock> merijn: ^ halfway there, maybe?
04:50:33 <merijn> But jmcarthur Just pointed out my assumption was wrong
04:50:35 <aa_> aweinstock: Is that behavior unique to ghci? Is there somewhere I could read about that that you'd recommend? Thank you.
04:50:41 <merijn> Because apparently MutVar# can be moved...
04:51:19 <vektor> :t fmap putStrLn $ Data.Tree.Node "Hello" []
04:51:20 <lambdabot> Tree (IO ())
04:51:29 <vektor> how do I parallelize that? O.o
04:51:43 <vektor> :t sequence $ fmap putStrLn $ Data.Tree.Node "Hello" []
04:51:45 <lambdabot> IO (Tree ())
04:51:54 <aweinstock> aa_: ghci acts as if it's inside do-notation, and in general there's a difference between (do { let x = y; otherstuff x }) and (do { x <- y; otherstuff x})
04:52:12 <jmcarthur> :t mapM_ putStrLn $ Data.Tree.Node "Hello" []
04:52:13 <lambdabot> IO ()
04:52:24 <aa_> aweinstock: Thank you!
04:52:46 <liste> @hackage async -- vektor this is the easy way (:
04:52:46 <lambdabot> http://hackage.haskell.org/package/async -- vektor this is the easy way (:
04:53:01 <vektor> jmcarthur: actually, my example is a bit bad. I need the results back.
04:53:08 <vektor> :t sequence $ fmap readFile $ Data.Tree.Node "Hello" []
04:53:09 <lambdabot> IO (Tree String)
04:53:11 <liste> for pure computations, there's par and pseq
04:53:40 <Unhammer> aweinstock Unhammer: oops, liftA2 for Maybe corresponds to and, not or
04:53:42 <Unhammer> yeah, monad/applicative is very and-y :/
04:54:01 <jmcarthur> vektor: okay. to parallelize IO you will want to use something for concurrency rather than for pure parallelism. the async package might have something for you.
04:54:05 <aweinstock> aa_: for example, (do { x <- getChar; print x; print x }) gets 1 char from the input, and prints it twice, while (do { let x = getChar; x >>= print; x >>= print}) asks for 1 char, prints it, then asks for another and prints it
04:54:19 <Unhammer> looked at Alternative.(<|>), but that doesn't let me do anything else in the case where both a and b
04:54:28 <aweinstock> Unhammer: <|> from Alternative acts like or for maybe, but I'm not sure if your orMap2 is implementable with it
04:54:42 <jmcarthur> vektor: Yeah! There's Control.Concurrent.Async.mapConcurrently.
04:55:12 <Unhammer> maybe a combination: <|> (liftA2 f a b) (a <|> b)
04:55:31 <Fuco> in atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b   what is the 'b'? 
04:55:32 <jmcarthur> vektor: or you could even just leave all the results as Asyncs so you can perhaps starts using them before they are finished
04:55:49 <jmcarthur> Fuco: the b is some result, a think you want to read from it.
04:56:02 <jmcarthur> Fuco: atomicModifyIORef is for reading and writing at the same time with the guarantee of atomicity.
04:56:13 <vektor> jmcarthur: I think using them asynchronously before the whole thing is finished would be kinda complicated.
04:56:49 <aa_> aweinstock: Thank you. I was struggling to find out why things weren't being modfied as expected and this clears that up.
04:56:56 <jmcarthur> vektor: Not really. You just find the first Async you want to use, then wait for just that one, then use the result.
04:57:13 <Fuco> jmcarthur: right,so I can for example return the input value, which is the old value of the IORef
04:57:21 <jmcarthur> Fuco: Yup.
04:57:31 <Fuco> thanks
04:58:25 <vektor> jmcarthur: The next function in the pipeline needs to aggregate the whole Tree. I doubt that'll give a big speedup.
04:58:38 <Unhammer> hm, that actually seems to have worked, but needed two pragmas in my file :-S
04:58:40 <aweinstock> :t (\(GHC.IORef.IORef (GHC.STRef.STRef x)) -> GHC.Types.W# (GHC.Prim.unsafeCoerce# x))
04:58:41 <lambdabot> GHC.IORef.IORef t -> Word
04:58:46 <aweinstock> merijn: ^
04:58:46 <Unhammer>   (liftA2 f ma mb) <|> (ma <|> mb)
04:59:06 <aweinstock> @let iorefToWord = (\(GHC.IORef.IORef (GHC.STRef.STRef x)) -> GHC.Types.W# (GHC.Prim.unsafeCoerce# x))
04:59:07 <lambdabot>  .L.hs:150:9: Not in scope: data constructor ‘GHC.IORef.IORef’
04:59:07 <lambdabot>  
04:59:07 <lambdabot>  .L.hs:150:26: Not in scope: data constructor ‘GHC.STRef.STRef’
04:59:19 <aweinstock> :t comparing (\(GHC.IORef.IORef (GHC.STRef.STRef x)) -> GHC.Types.W# (GHC.Prim.unsafeCoerce# x))
04:59:21 <lambdabot> GHC.IORef.IORef t -> GHC.IORef.IORef t -> Ordering
04:59:47 <merijn> aweinstock: The problem is that that's not correct according to jmcarthur 
04:59:59 <merijn> aweinstock: Since GC can move MutVar# and thus change the ordering
05:00:11 <aweinstock> oh
05:00:42 <mniip> is MutVar# even coercible to a Word#
05:01:11 <aweinstock> I ran that function in GHCI, and the result looked heuristically address-y to me
05:01:30 <mniip> that's a poor heuristic
05:01:33 <jmcarthur> mniip: I think it is, with 80% confidence.
05:01:38 <mniip> considering what GHC does to the address space
05:02:12 <jmcarthur> mniip: ... I take it back. More like only 60% confidence.
05:02:49 <jmcarthur> vektor: If the aggregation involves an associative or commutative operation, there's a lot you can do (with work).
05:03:02 <mniip> if it were, there probably would be a mutVarContents# :: MutVar# s a -> State# s -> (# State# s, Addr# #)
05:03:11 <mniip> akin to bytearrayContents#
05:03:20 <mniip> or maybe without the state
05:04:04 <vektor> jmcarthur: This is where the data would have to go next: https://github.com/vektordev/GP/blob/master/src/GRPPool.hs#L407-L427
05:04:07 <mniip> ah wait hm, the ghc is generally reluctant about giving away pointers to stateful primitives
05:04:19 <jmcarthur> mniip: I don't think so. What would be the purpose of the Addr# if the data it points to can move?
05:06:00 <aweinstock> :t GHC.Prim.makeStablePtr#
05:06:01 <lambdabot> a -> GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, GHC.Prim.StablePtr# a #)
05:06:16 <aweinstock> merijn: you could roll your own "stable IORefs" with these?
05:06:32 <jmcarthur> vektor: So this function basically computes a new tree with only the smallest n entries?
05:06:39 <jmcarthur> s/entries/elements/
05:06:45 <merijn> aweinstock: That's more work than saying "screw the finalizer, I'll just manually delete any left over files" :)
05:07:07 * hackagebot clash-lib 0.6.7 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.7 (ChristiaanBaaij)
05:07:09 * hackagebot clash-ghc 0.6.7 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.7 (ChristiaanBaaij)
05:07:30 <vektor> jmcarthur: Not quite. It flags the biggest n entries as Active Individuals, the rest are made Inactive Individuals or kept as Junk Individuals
05:07:59 <vektor> jmcarthur: liste: I've got 100% CPU usage again, thanks a lot guys. :)
05:08:11 <mpickering> Is there a way when creating a -hy profile to get a higher-level view of what is going on? Say I have a datatype which contains 5 fields, I want to see the allocations caused by that datatype rather than each field individually
05:08:26 <jmcarthur> vektor: Well, certainly by the time that functions is done all the IO would have to have been performed, so you're right in the only sense which probably matters to you.
05:08:34 <mniip> does anyone here speak STG
05:08:42 <mniip> or rather, Cmm
05:08:59 <mniip> https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm#L489-L500
05:10:05 <jmcarthur> mniip: I think W_ is a Word#
05:10:56 <aweinstock> Unhammer: (\f x y -> liftA2 f x y <|> x <|> y)
05:10:57 <jmcarthur> mniip: I don't speak Cmm fluently, but it's a lot like C.
05:11:19 <mniip> yeah except all the STG macros
05:12:29 <jmcarthur> mniip: I assume your goal is to figure out the representation of MutVar#, right?
05:12:41 <mniip> yes
05:12:47 <jmcarthur> mniip: So I think all that matters is that the return type is a word.
05:12:48 <mniip> oh wait
05:13:04 <mniip> so MutVar# is not a heap object right
05:13:04 <vektor> jmcarthur: I mean, I've already sunk a few days of CPU time into this program, so I'm grateful for every bit of optimization I can get. Then again, within the function you've just helped me parallelize, there's a call to ghc for every element in a big tree. So those IO ops take a few secs to complete.
05:13:06 <jmcarthur> mniip: And further that it's a pointer into the heap.
05:13:43 <mniip> hmm
05:14:04 <mniip> I would say it does look like a heap object
05:14:15 <jmcarthur> mniip: ALLOC_PRIM_P doesn't need to return anything because the pointer is easy to compute immediately after. It's just a bump allocator.
05:14:25 <jmcarthur> mniip: mv = Hp - SIZEOF_StgMutVar + WDS(1);  does that part
05:15:03 <jmcarthur> vektor: Yeah, I doubt the sorting and filtering is a bottleneck.
05:15:36 <jmcarthur> mniip: I should make sure it's known that I am not a GHC dev and these are just guesses.
05:15:36 <mniip> jmcarthur, so yeah what you're doing is akin to reallyUnsafePtrEquality#
05:15:43 <mniip> which can fail occaionally
05:16:02 <mniip> and by fail I mean both positives and negatives
05:16:25 <jmcarthur> Yup.
05:17:23 <ell> I wrote my own `mapWithIndex` function but I'd like to know if there was one already in the Prelude?
05:17:34 <jmcarthur> mniip: The one thing that has me a little confused: If W_ is a reasonable representation for a pointer, what's the deal with the gcptr type?
05:17:38 <ell> ie, it takes a (a -> Int -> b) instead of (a -> b)
05:18:12 <aweinstock> :t imap
05:18:13 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
05:18:28 <jmcarthur> mniip: Ah. I think gcptr is just a primitive available in haskell.
05:18:36 <jmcarthur> mniip: *not available
05:18:40 <aweinstock> @hoogle FunctorWithIndex
05:18:41 <lambdabot> No results found
05:19:30 <aweinstock> ell: I think it's from Control.Lens.Indexed
05:20:08 <jmcarthur> mniip: I'm wrong. (Looking at Cmm.h now.)
05:21:04 <vektor>  jmcarthur: There's still a bottleneck somewhere in there, but I'll have to do some profiling first. All of the pure stuff that happens in between those big parallelized ghc calls is not parallelized at all.
05:21:41 <ell> aweinstock: ah yes thanks
05:21:59 <vektor> jmcarthur: So I'm getting dips in CPU usage every iteration. But it's already a lot better.
05:22:52 <jmcarthur> mniip: Well, I don't know the difference, but I see W_ being used for things named "addr", too.
05:30:28 <mauke`0> ok, this looks like the right side of the netsplit
05:30:59 <exio4> netsplit? :)
05:31:52 <mauke`0> on asimov.freenode.net there are 10 people in #haskell
05:32:43 <exio4> oh, I see
05:40:15 <SimpleX_> http://lpaste.net/147573 - why doesn't it work?
05:41:15 <phaazon> SimpleX_: because you cannot use (.) like that
05:41:32 <phaazon> that would basically do this:
05:41:58 <phaazon> (liftIO . reqSuiteTRC c (SetRequest 0 0 0) timeOut) retryCount suite
05:42:02 <phaazon> which is not what you want
05:42:27 <phaazon> you have to use explicit variable arguments
05:43:51 <SimpleX_> ouch. And I can't simply put restrictions to data
05:44:01 <phaazon> what do you mean?
05:44:39 <phaazon> point free is cool what it makes sense; in your case it does not
05:44:45 <SimpleX_> I have IO Suite there, that's why I need to do this liftIO. But that's actually my data type.
05:45:15 <phaazon> yeah, well
05:45:50 <phaazon> set' c timeOut retryCount suite = liftIO $ reqSuiteTRC c (SetRequest 0 0 0) timeOut retryCount suite
05:46:04 <phaazon> you can omit the suite if you wanna use liftIO ., but that’s not very interesting
05:46:04 <SimpleX_> yup, I got it
05:46:21 <phaazon> set' c timeOut retryCount = liftIO . reqSuiteTRC c (SetRequest 0 0 0) timeOut retryCount
05:46:54 <mauke`0> @pl set' c timeOut retryCount suite = liftIO $ reqSuiteTRC c (SetRequest 0 0 0) timeOut retryCount suite
05:46:55 <lambdabot> set' = (((liftIO .) .) .) . flip reqSuiteTRC (SetRequest 0 0 0)
05:47:04 <phaazon> haha
05:47:12 <mauke`0> beautifueuleueueughgagha
05:47:23 <phaazon> readable as fuck
05:47:38 <mauke`0> @unpl set' = (((liftIO .) .) .) . flip reqSuiteTRC (SetRequest 0 0 0)
05:47:38 <lambdabot> set' i l o r = liftIO (reqSuiteTRC i (SetRequest 0 0 0) l o r);
05:47:50 <mauke`0> wow, perfect
05:47:52 <phaazon> woah, lambdabot is pretty cool
05:48:16 <mauke`0> yes, it is :-)
05:49:07 <mauke`0> it also has @do/@undo
05:49:09 <SimpleX_> thanks
05:50:20 <SimpleX_> Oh, is it a good way to make lib api?
05:50:44 <pavonia> How did lambdabot choose the variable names there?
05:51:37 <mauke`0> it probably has a hardcoded list of names to choose from
05:51:57 <mauke`0> @unpl (f .) . g
05:51:57 <lambdabot> (\ d i -> f (g d i))
05:52:03 <mauke`0> @unpl (d .) . i
05:52:04 <lambdabot> (\ e h -> d (i e h))
05:52:25 <mauke`0> @unpl (d e h .) . i
05:52:26 <lambdabot> (\ f k -> d e h (i f k))
05:58:40 <ell> Is there a way to get a "strong typedef" in haskell? ie `type IntList = [Int]` then I can implement `instance Show IntList`
05:59:22 <mauke`0> newtype
06:04:04 <ell> meh
06:04:17 <ell> I'll just have to write my code to destructure everywhere I suppose :/
06:07:38 * hackagebot templatepg 0.2.8 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/templatepg-0.2.8 (ChrisForno)
06:11:16 <c_wraith> ell: alternatively, you can write your necessary "primitive" operations that destructure, and then do everything else in terms of the primitive operations
06:22:38 * hackagebot FractalArt 0.2.0.0 - Generates colorful wallpapers  https://hackage.haskell.org/package/FractalArt-0.2.0.0 (TomSmeets)
06:26:06 <ell> c_wraith: Yeah I've ended up doing that. thanks
06:32:39 * hackagebot rethinkdb 2.2.0.2 - A driver for RethinkDB 2.1  https://hackage.haskell.org/package/rethinkdb-2.2.0.2 (codedmart)
07:25:14 <mpickering> anyone seen an error like this before? 
07:25:20 <mpickering> https://www.irccloud.com/pastebin/YRlD1eRR/
07:26:29 <geekosaur> somehow you are getting interface files for the wrong version of ghc
07:27:34 <mpickering> I rm -r dist/ and can recreate the error
07:27:48 <mpickering> this is with HEAD btw so maybe it is just a bug or I need to get an updated version of cabal
07:33:16 <roelof> Anyone who develop Haskell in the cloud with things like nitrious.io or koding.com ? 
07:48:20 <maerwald> I wonder why the "normalise" function from System.FilePath.Posix doesn't remove occurences of ".." in the filepath
07:49:54 <geekosaur> because symlinks can make that inaccurate
07:50:01 <frerich> maerwald: Maybe because it's tricky with symlinks
07:50:08 <aweinstock> is there a generalized catMaybes that works on Alternative?
07:50:10 <frerich> maerwald: I.e. /a/b/.. is not necessarily /a in case 'b' is a symlink
07:50:17 <maerwald> hm
07:51:08 <maerwald> I guess then it boils down to canonicalizePath from System.Directory, but I don't want that function, because it follows symlinks
07:52:46 <mauke`0> you can't resolve .. without following symlinks
07:52:55 <geekosaur> if you mean following a symlink for the last path component, the usual trick is to split that off, canonicalize the directory, and re-append the final component
07:52:58 <maerwald> that doesn't mean you have to remove symlinks fro the resulting path
07:53:08 <maerwald> and that's what it does
07:53:16 <aweinstock> the closest I can immediately thing of to an Alternative generalization of catMaybes is (sequenceA . filter (/= empty)), but that requires Eq
07:53:22 <aweinstock> s/thing of/think of/
07:53:47 <maerwald> geekosaur: that could work
07:54:12 <roelof> how can I improve my code coverage here : http://lpaste.net/147583
07:55:42 <maerwald> maybe we should just deprecate symlinks :D
07:55:46 <aweinstock> roelof: exOr True True = False
07:56:00 <maerwald> they cause trouble everywhere, inlcuding recursively copying directories
07:56:26 <roelof> aweinstock:  schould I add that line ? 
07:57:42 <geekosaur> roelof, aweinstock is poointing out you have a bug
07:58:28 <roelof> geekosaur:  oke, wierd that quickCheck has not find it 
07:59:13 <geekosaur> you might need to verify your quickcheck predicate, then
07:59:47 <roelof> I do think he means something else. I do not have that line in my code 
07:59:56 <geekosaur> line 32
08:00:02 <roelof> my code is : exOr True True = True 
08:00:04 <geekosaur> yes
08:00:10 <mauke`0> that's the bug
08:00:16 <geekosaur> so you claim (True /= True) == True?
08:01:34 <roelof> no, I claim that  true or true = true . See this page : https://en.wikipedia.org/wiki/Truth_table#Logical_disjunction_.28OR.29
08:01:47 <geekosaur> exor is normal or, not xor?
08:01:55 <geekosaur> what is myOr for then?
08:02:41 <geekosaur> also if that's supposed to be normal or, it is very poorly named
08:02:46 <aweinstock> @check let {f = (/=); g True True = True; g True False = True; g False True = True; g False False = False } in (\x y -> f x y == g x y)
08:02:48 <lambdabot>  *** Failed! Falsifiable (after 5 tests):
08:02:48 <lambdabot>  True True
08:02:58 <roelof> I think the author of the Craft book wants to do two times the same 
08:03:05 * hackagebot Hate 0.1.4.2 - A small 2D game framework.  https://hackage.haskell.org/package/Hate-0.1.4.2 (bananu7)
08:03:25 <roelof> geekosaur:  I will hit the book what is mentioned about exOr 
08:03:45 <frerich> roelof: My impression from reading the comments was that 'myXor' and 'exOr' are supposed to behave the same but be defined in different ways.
08:04:09 <frerich> roelof: And 'exOr' does sound a bit like 'exclusive or'.
08:04:17 <roelof> frerich:  oke , moment 
08:04:30 <frerich> (it also sounds a bit like 'exorcism' or 'exxon')
08:04:46 <aweinstock> frerich: it could also mean "example: or"
08:05:03 <vektor> is there a way to limit the number of threads Control.Concurrent.Async.mapConcurrently spawns?
08:05:08 <aweinstock> or "explicit or" (since it's defined as a truth table)
08:05:18 <frerich> aweinstock: I suspect it started of as 'extensive organigram'
08:05:41 <roelof> I can find this definition of exor :  exOr x y = (x II y) kk not (x kk y)  
08:06:07 <roelof> I can find this definition of exor :  exOr x y = (x || y) && not (x && y)  
08:06:35 <vektor> The problem in my case is that the action I'm mapping over the container calls ReadProcessWithExitCode and all those processes are eating a lot of RAM.
08:06:45 <frerich> roelof: Try evaluating that for various combinations of 'x' and 'y'. You may find that it looks a lot like 'myXor'
08:07:44 <frerich> roelof: In particular, note that that definition of 'exOr' when applied to True and True gives '(True || True) && not (True && True)', whch is 'True && not True' which is 'True && False', which is False. I.e. different than what your Haskell code does.
08:07:54 <maerwald> frerich: interesting, the filemanager I am using is misbehaving on that as you said... on ".." it just goes back one level
08:07:58 <roelof> oke, so I have to rewrite myXor to another format. That is no problem 
08:08:31 <frerich> roelof: I think your 'myXor' is fine and dandy. It's 'exOr' which is defective (in particular your 'exOr True True' definition).
08:08:47 <maerwald> I wonder if that's a bug or done on purpose
08:09:19 <aweinstock> :t \f -> map (\[x,y] -> (x, y, f x y)) $ replicateM 2 [True,False] -- this lists a truth table for a boolean function
08:09:20 <roelof> frerich:  that is what I mean. Rewrite exercise 3 so it do the same as exercise 1 
08:09:20 <lambdabot> (Bool -> Bool -> t) -> [(Bool, Bool, t)]
08:09:56 <aweinstock> @let truthTable f = map (\[x,y] -> (x, y, f x y)) $ replicateM 2 [True,False]
08:09:58 <lambdabot>  Defined.
08:10:05 <aweinstock> > truthTable (&&)
08:10:07 <lambdabot>  [(True,True,True),(True,False,False),(False,True,False),(False,False,False)]
08:10:23 <aweinstock> > truthTable (/=)
08:10:27 <lambdabot>  mueval-core: Time limit exceeded
08:10:30 <aweinstock> > truthTable (/=)
08:10:32 <lambdabot>  [(True,True,False),(True,False,True),(False,True,True),(False,False,False)]
08:10:33 <geekosaur> maerwald, this is a common issue with file managers. and shells; bash does some stuff to try to avoid it (compare logical and physical paths involving a symlink, pwd -L vs. pwd -P) but can become confused
08:10:54 <geekosaur> or can confuse you if you trust .. in a path passed to a program since it can't see bash's hackery
08:10:54 <maerwald> I think I'll go with the "resolve all symlinks instead of the last path component" approach
08:11:21 <geekosaur> (also this is why linux added bind mounts, which work as expected with ..)
08:13:12 <roelof> Thanks all.  In my coverage I have now on every topic 100% 
08:13:24 <roelof> and thanks for pointing out the bug 
08:15:55 <roelof> one last question : what schould I do here : Give line-by-line calculations of  nAnd True True  
08:16:27 <roelof> I see no example of a line-by-line calculation in the explanations somewhere ? 
08:18:30 <aweinstock> roelof: where is nAnd defined?
08:18:45 <roelof> in a former exercise 
08:19:21 <roelof> I have made this : http://lpaste.net/147585
08:21:40 <aweinstock> I'd think something like (nAnd True False ->(case 2) True) might be a "line-by-line" calculation? (there'd be more steps if it were defined in terms of another function)
08:26:34 <roelof> pff, Nand is not defined in Haskell as far as I know. So making a quicktest will be a challenge 
08:28:36 <aweinstock> :t not . and
08:28:37 <lambdabot> Foldable t => t Bool -> Bool
08:28:45 <aweinstock> :t not . (&&)
08:28:46 <lambdabot>     Couldn't match type ‘Bool -> Bool’ with ‘Bool’
08:28:46 <lambdabot>     Expected type: Bool -> Bool
08:28:46 <lambdabot>       Actual type: Bool -> Bool -> Bool
08:28:58 <aweinstock> :t (not .) . (&&)
08:28:59 <lambdabot> Bool -> Bool -> Bool
08:29:17 <aweinstock> > truthTable ((not .) . (&&))
08:29:19 <lambdabot>  [(True,True,False),(True,False,True),(False,True,True),(False,False,True)]
08:29:38 <exio4> @type 
08:29:39 <lambdabot> <no location info>: not an expression: ‘’
08:29:44 <exio4> @type fmap not <$> (&&)
08:29:44 <roelof> Almost as the exercise says only false false must also be false 
08:29:45 <lambdabot> Bool -> Bool -> Bool
08:29:48 <exio4> there, that looks nastier :D 
08:30:19 <aweinstock> roelof: then that's xor, (/=)
08:30:29 <aweinstock> > truthTable xor
08:30:32 <lambdabot>  [(True,True,False),(True,False,True),(False,True,True),(False,False,False)]
08:30:44 <aweinstock> > truthTable xor == truthTable (/=)
08:30:46 <lambdabot>  True
08:31:04 <roelof> sorry : that was right. So I can test it with  not(and True True) ?? 
08:31:22 <roelof> sorry : that was right. So I can test it with  not( True && True) ?? 
08:31:34 <aweinstock> yes
08:31:37 <pavonia> :t xor
08:31:39 <lambdabot> Bits a => a -> a -> a
08:32:06 <aweinstock> or (quickCheck (\x y -> myNand x y == not (x && y)))
08:32:41 <aweinstock> pavonia: check out Data.Bits/Data.Word if you havn't already: haskell is arguably better at bit-level stuff than C is
08:33:02 <aweinstock> :t rotateL
08:33:03 <lambdabot> Bits a => a -> Int -> a
08:33:18 <pavonia> Yeah, I already know these module, I just didn't remember xor
08:33:42 <pavonia> I recall they had weird names like (.&.)
08:33:49 <aweinstock> I don't think C has portable rotateL/R or popCount intrinsics
08:33:53 <pavonia> :t (.^.)
08:33:55 <lambdabot>     Not in scope: ‘.^.’
08:33:55 <lambdabot>     Perhaps you meant one of these:
08:33:55 <lambdabot>       ‘.&.’ (imported from Data.Bits),
08:34:26 <aweinstock> > 1234 .&. 0xff
08:34:27 <lambdabot>  210
08:36:42 <pavonia> There should be (.^.) for consistency too
08:46:52 <sbrg> i wish lens would die and something less transdimensional would rise from its ashes
08:47:33 <breadmonster> sbrg: You'll regret that as you get more experienced, lens currently works as much as it can.
08:47:47 <breadmonster> and edwardk is trying his best to make it even more general :P
08:48:01 <breadmonster> something about BifunctorFunctors and so on.
08:48:41 <maerwald> not sure if that will make it easier to use
08:48:57 <maerwald> but that's probably not the goal
08:49:33 <dhz`> i wish lens didn't introduce thousand operators
08:49:45 <aweinstock> the goal is to make it more powerful once you learn how to use it?
08:49:51 <sbrg> the operators and all that is just too much. the information about using lenses is spread all around, and the tutorials(like in lens-tutorial) are insufficient. you can understand most of the operations on their own but then have to fiddle with it for a while to actually get it to compose correctly in the correct order, which is of course in the opposite order you've trained your mind to use. 
08:50:25 <Zekka|Sigfig> I started liking Lens less the more I learned
08:50:27 <sbrg> so when you finally emerge on the other side, you look at your code and think "oh wow. I didn't have to use haskell's annoyingly verbose record syntax, but now I have a bunch of operators I will forget by the next time I look at this code"
08:50:32 <maerwald> lens is a language, not a library. That's the problem
08:50:41 <maerwald> if you expect it to be a library, you will be disappointed
08:50:46 <Zekka|Sigfig> It does a lot of useful stuff but imho it’s much larger than my usecase usually is
08:51:16 <sbrg> Zekka|Sigfig: aye. I went for microlens first, then I found out it covered everything I needed except a tiny bit.. which meant I had to download the Beast.
08:51:23 <Zekka|Sigfig> I’d be satisfied with just Traversal, Lens, maybe Prism.
08:52:10 <sbrg> i'm going to bite the bullet regardless and see if I can't grok it
08:52:21 <Zekka|Sigfig> Yeah, don’t let me stop you or anything
08:52:25 <breadmonster> sbrg: It's really not that hard to get.
08:53:05 <Zekka|Sigfig> FWIW I didn’t have that much trouble learning what the types for Lens/Traversal actually meant (my favorite Lens-y types) but I always had trouble remembering the huge suite of operators
08:53:25 <breadmonster> Zekka|Sigfig: Control.Lens.Combinators is for you.
08:54:13 <Zekka|Sigfig> breadmonster: Might check it out, thanks. How long has that been around?
08:54:50 <Zekka|Sigfig> Oh hey, looks like this is just Lens without the operators?
08:54:57 <breadmonster> Yes.
08:55:02 <breadmonster> Exactly.
08:55:10 <Zekka|Sigfig> I didn’t actually have an issue with the operators — what I had trouble with was remembering how the various *Ofs translated to their analogous operations
08:56:04 <Zekka|Sigfig> I only really used straightforward setting/getting-flavored operations most of the time, which is probably not the intended usage
08:57:09 <Zekka|Sigfig> Oh whoops, realized I misspoke above. s/huge suite of operators/huge suite of operations
08:57:13 <sbrg> still, even without operators you get kind of disgusting looking expressions when you want to use lens for things it's really good for, like reaching all the way into a nested datastructure while inside a monad transformer stack or some such
08:57:32 <Zekka|Sigfig> sbrg: I never actually got good at that stuff
08:58:05 <sbrg> this here also reads 'incorrectly' in my opinion: (myLens . ix someIndexIntoAMap) `over` modifyValueAtIndexInMap $ actualMap
08:58:09 <Zekka|Sigfig> I’m also a little suspicious of it because it seems to me like if I learned how to do the really clever lens stuff my code would be impenetrable to other people
08:58:29 <maerwald> sbrg: at that stage, I always wonder why the underlying data structure is so complex that I need such a solution
08:59:01 <sbrg> what it does is 'modifying over value pointed to by lens in map' but it reads 'do my lens into map over .. modifying the value'?
08:59:07 * hackagebot Hate 0.1.4.3 - A small 2D game framework.  https://hackage.haskell.org/package/Hate-0.1.4.3 (bananu7)
08:59:16 <sbrg> maerwald: hm? reaching into a map that maps to a .. set or something while in a monad transformer stack? that is not complicated.
08:59:28 <maerwald> sbrg: I didn't say that
09:00:01 <maerwald> if it's not complicated, you can do fine without lens
09:00:17 <frerich>  /me always considered 'lens' to be a really elaborate EDSL for juggling nested data types -- probably really unfair though
09:00:34 <frerich> Keyboard, behave!
09:00:35 <Zekka|Sigfig> maerwald: Sounds like an argument against using lens TBH
09:00:49 <sbrg> aye, sure. I am mostly using it right now because I figured it was christmas break, and I have some time to spend on stuff i've been wanting to look into, etc.
09:00:56 <maerwald> Zekka|Sigfig: depends on the use case, edward made a few very good points where it is useful
09:00:58 <Zekka|Sigfig> (I don’t think most of the programs I wrote using Lens really needed Lens)
09:01:02 <maerwald> but those are very special use cases IMO
09:01:07 <maerwald> exactly!
09:01:34 <sbrg> Zekka|Sigfig: well, no programs *need* it. but haskell's record syntax makes it rather horrible to work with certain programs without lens because lens can do so much in little space
09:01:57 <Zekka|Sigfig> sbrg: I think the features that made my code much shorter using Lens aren’t unique to lens
09:02:14 <Zekka|Sigfig> Being able to use Lens’ State-ful syntax for record update made my code a lot shorter, but often I wasn’t even composing accessors
09:03:00 <Zekka|Sigfig> You probably could have done it with another library that used TH to generate ‘modify field in place’ functions for my data structures. (Although I think lenses are a particularly good way to represent accessor functions)
09:04:32 <Zekka|Sigfig> One thing I’d say in favor of Lens: because of how Haskell likes avoiding mutations I usually found that lots of things were nested record update in Haskell that wouldn’t have been nested record update in other languages
09:04:45 <Zekka|Sigfig> er, avoiding mutation, I usually*
09:14:51 <c_wraith> I feel like lenses are the least interesting part of the lens package. 
09:15:06 <SrPx> What does "global constraint requires..." means? It seems that Cabal wants an older version of a library, but AFAIK nowhere on my code I requested it.
09:15:10 <c_wraith> Traversal is where things get interesting. 
09:15:29 <exio4> c_wraith: I still think them being first-class values is a killer :P 
09:15:44 <c_wraith> SrPx, global usually means in your cabal configuration file
09:15:46 <geekosaur> SrPx: the most common global constraint is the version of "base", which comes with ghc
09:16:00 <geekosaur> otherwise, yes, check ~/.cabal/config
09:16:18 <Zekka|Sigfig> c_wraith: I’m not sure I want my software to be too interesting!
09:16:58 <SrPx> I have two cabal configurations file. One on MyLib/mylib.cabal, other on MyLibTest/mylibtest.cabal. MyLib compiles fine. MyLibTest just import it and doesn't (?). Nowhere there is any reference to the older version of Vector... mylib.cabal has vector            >= 0.11 && <0.12, which is the newer version.
09:17:13 <Zekka|Sigfig> Ideally I would sit down in front of a text editor and already understand how everything works and not be surprised by anything
09:17:21 <SrPx> geekosaur nothing on ~/.cabal/config mentions vector
09:17:24 <Zekka|Sigfig> There’s a guy who sits on the other side of my office who can do that but I can’t do it yet.
09:18:14 <c_wraith> Zekka|Sigfig, the software doesn't have to be interesting. "locate all subelements of this tree with boring business status X and perform boring business action Y on them" is easy and concise to write with lens. :) 
09:18:28 <geekosaur> SrPx, it might well not, if that version of vector is not compatible with your "base" (therefore your ghc version) or with some other package that does have a global constraint, you get that
09:18:37 <geekosaur> *can get that
09:18:48 <geekosaur> maybe pastebin full dependency output?
09:19:01 <SrPx> geekosaur how does mylib.cabal package compile fine? The mylibtest.cabal package just imports it. Nothing else. Okay.
09:19:16 <wz1000> How would you write a Show instance for 'newtype Mu f = Mu (f (Mu f))' provided 'forall a. Show a => Show (f a)'
09:19:21 <geekosaur> I cannot answer that without seeing dependency output
09:20:13 <c_wraith> wz1000, I'd use StandaloneDeriving and add the compiler flags and constraints ghc asks for. :) 
09:20:17 <geekosaur> also cannot know if there is something else injecting a dependency, like maybe something about the test framework
09:21:19 <wz1000> c_wraith: Would this work? deriving instance (forall a. Show a => Show (f a)) => Show (Mu f)
09:22:42 <wz1000> GHC tells me that its an illegal constraint 
09:22:44 <SrPx> geekosaur http://lpaste.net/147590
09:22:44 <c_wraith> wz1000, that's a strange constraint. I'd just use (Show a, Show (f a)), or the like 
09:23:47 <c_wraith> wz1000, the easiest way to proceed is remove all constraints and just add back the ones ghc tells you you need. 
09:24:07 * hackagebot yi 0.12.3 - The Haskell-Scriptable Editor  https://hackage.haskell.org/package/yi-0.12.3 (DmitryIvanov)
09:26:02 <c_wraith> wz1000, remember, ghc keeps track of all those details so you don't have to. it's perfectly fine to rely on it to do the heavy lifting for you. 
09:27:37 <geekosaur> hm, I thought stack reported resolver errors better than that
09:28:00 <geekosaur> SrPx, the problem is the lts-3.18 resolver has only vector-0.10.12.3
09:28:33 <SrPx> Oh that's all? Thank you.
09:29:47 <geekosaur> so stack put a global constraint for package versions in lts-3.18 and that's what's leading to the error. I would have expected it to say something about the requested version of vector not being in the lts-3.18 resolver
09:31:07 <nitrix> Does haskell genuinely run Threads in parallel (for IOs like writing to multiple files) or is it a coroutine system (green threads) ?
09:31:24 <bergmark> hmm, i guess i've never used stack solver with an existing resolver
09:31:39 <SrPx> Uh huh, it works fine if I put the nightly resolver the same as MyLib. Really wish it was more obvious about that, so much time lost for nothign.
09:31:40 <nitrix> I'm curious if there's an actual benefit in speed to gain or just helps managing complexity.
09:32:00 <geekosaur> nitrix, depends on whether you built with -threaded or not (and used +RTS -N as appropriate)
09:32:14 <wz1000> c_wraith: I don't think that your constraint should work, the 'a' remains ambiguous. Here's the dump of my ghci session: http://lpaste.net/147592
09:32:36 <exio4> nitrix: those two aren't exclusive
09:32:47 <nitrix> geekosaur: How do I specify those using stack?
09:33:08 <exio4> nitrix: you can have an N:M architecture
09:33:14 <geekosaur> that I don't know
09:33:20 <c_wraith> wz1000, then go with not specifying constraints and seeing what ghc asks for. 
09:33:21 <kadoban> nitrix: Usually in the .cabal file under ghc_options
09:33:24 * geekosaur is still on a rather obsolete haskell setup here...
09:33:57 <nitrix> exio4: Where N are processors and M are threads?
09:34:01 <geekosaur> (migrating a running xmonad to a new ghc version is moderately scary, so still using Debian's 7.6 and packages)
09:34:39 * SrPx still thinks the whole Haskell environment is a complete mess, stack or not :/ sorry
09:35:06 <wz1000> c_wraith: The derivied code just fails to typecheck
09:35:21 <joco42> reading typeclassopedia: "((,) a) is an Applicative, as long as a is an instance of Monoid " - how is this ? could someone explain on a simple example?
09:35:39 <c_wraith> wz1000, yes, and ghc will tell you what constraints are missing, so you can add them. 
09:36:14 <mauke`0> joco42: what's unclear?
09:36:44 <wz1000> c_wraith: It doesn't. It says: No instance for (Show (f (Mu f))) arising from a use of ‘showsPrec’
09:37:05 <c_wraith> wz1000, then add that constraint. 
09:37:13 <joco42> mauke`0: i cannot really imagine what could be (,a) ?
09:37:24 <Welkin> is there a blog comment system or messageb oard system written in haskell?
09:37:36 <joco42> for example (what?, Int)
09:37:47 <mauke`0> joco42: (,) a, not (, a)
09:37:48 <kadoban> joco42: 'pure' is just \x -> (mempty, x).    (a, f) <*> (b, x) is just   (a <> b, f x)
09:38:12 <c_wraith> joco42, ((,) a) is (a,) not (, a) 
09:38:24 <joco42> ahh :)
09:38:31 <wz1000> c_wraith: Thanks, got it
09:38:32 <joco42> yes
09:38:53 <joco42> kadoban: thanks , let me think about this for a sec... 
09:39:47 <joco42> kadoban: what is a <> b ?
09:40:11 <joco42> fold ?
09:40:24 <mauke`0> joco42: do you know what Monoid is?
09:40:36 <joco42> mauke`0: yeah, like 1+1
09:40:40 <joco42> 1+0
09:40:42 <mauke`0> no
09:41:03 <mauke`0> Monoid is a class with two methods, mempty and mappend/<>
09:41:06 <joco42> associative semigroup?
09:41:18 <joco42> or stg like that
09:41:45 <joco42> group - inverse afaik
09:42:00 <aweinstock> semigroups are already associative, a monoid is a semigroup with an identity
09:42:02 <joco42> group without the inverse?
09:42:21 <aweinstock> (and yes, a group is a monoid with inverses)
09:42:22 <joco42> :) yeah , thanks, aweinstock 
09:42:28 <mauke`0> I don't know what you're doing
09:42:32 <kadoban> joco42: <> is just mappend    in lists, it's (++), in Sum it's (+), in Product it's (*), etc.
09:43:00 <aweinstock> <> is the monoid operation, which is also written as `mappend`
09:43:08 <joco42> i see ok, thanks :) kadoban 
09:43:15 <joco42> cool
09:43:29 <joco42> lemme see that line again now
09:47:45 <joco42> kadoban: so the (a,) is some kind of an applicative that keeps count of the number of effectful computations  ?
09:47:58 <joco42> in some sense...
09:48:19 <aweinstock> > pure 5 :: (Sum, Int)
09:48:20 <lambdabot>      Expecting one more argument to ‘Sum’
09:48:21 <lambdabot>      The first argument of a tuple should have kind ‘*’,
09:48:21 <lambdabot>        but ‘Sum’ has kind ‘* -> *’
09:48:27 <aweinstock> > pure 5 :: (Sum Int, Int)
09:48:29 <lambdabot>  (Sum {getSum = 0},5)
09:49:12 <kadoban> joco42: Not really. It's not that specialized. It just combines the associated-values with mappend, and whatever that means is up to you.
09:49:20 <aweinstock> > (Sum 1, succ) <*> pure 5 :: (Sum Int, Int) 
09:49:22 <lambdabot>  (Sum {getSum = 1},6)
09:54:59 <joco42> kadoban: yeah, for example (Int,) ? would that be such a counter
09:55:42 <joco42> ?
09:56:33 <joco42> aweinstock: thanks, i was away for awhile
09:56:37 <joco42> got a call
09:56:39 <kadoban> joco42: Almost? Not really. It depends what the associated values are. I don't think what you're asking about is a Monoid though, so it wouldn't really fit.
09:57:38 <kadoban> joco42: One thing you could use it for would be something like logging, where it combines the logs together into one big one
09:57:56 <joco42> writer monad?
09:58:11 <joco42> hmm... 
09:58:33 <joco42> >:t Sum
09:58:40 <nitrix> :t Sum
09:58:42 <lambdabot> a -> Sum a
09:58:50 <joco42> thx
09:59:00 <joco42> :info Sum
09:59:08 <nitrix> lambdabot doesn't have infos.
09:59:11 <joco42> ok
09:59:21 <kadoban> Sum is a newtype wrapper on numbers, because there's multiple possible Monoids that you'd want to use with Int, for example. It's a monoid with (+) and 0, and also a monoid with (*) and 1
09:59:26 <nitrix> @instances Monoid
09:59:30 <lambdabot> (), (a -> b), (a, b), All, Alt f a, Any, Const a b, Dual a, Expr, Maybe a, Ordering, Product a, Sequenced a m, Sum a
09:59:36 <nitrix> joco42: ^
09:59:39 <kadoban> newtype wrappers are kind of how you pick which instance you want, in haskell.
10:00:03 <joco42> kadoban: ok, thanks
10:00:28 <joco42> yes that makes sense
10:00:53 <nitrix> joco42: As I understand it, this is because the identity might differs depending on the operation at hand for certain types.
10:01:09 <joco42> and perhaps also mappend 
10:01:12 <joco42> differs
10:02:29 <joco42> > pure 5 :: (Sum Int, Int)
10:02:31 <nitrix> Well, that's what I meant.   Product 1 `mappend` Product 5, doesn't behave the same as Sum 1 `mappend` Sum 5, even though both are Int values.
10:02:31 <lambdabot>  (Sum {getSum = 0},5)
10:02:52 <joco42> yeah, nitrix that makes sense
10:03:13 <joco42> > (Sum 1, succ) <*> pure 5 :: (Sum Int, Int) 
10:03:15 <lambdabot>  (Sum {getSum = 1},6)
10:03:22 <aweinstock> > msum [Any True, Any False]
10:03:24 <lambdabot>      Couldn't match expected type ‘m a’ with actual type ‘Any’
10:03:24 <lambdabot>      In the expression: Any True
10:03:24 <lambdabot>      In the first argument of ‘msum’, namely ‘[Any True, Any False]’    Could...
10:03:34 <aweinstock> > mconcat [Any True, Any False]
10:03:36 <lambdabot>  Any {getAny = True}
10:03:47 <aweinstock> > mconcat [All True, All False]
10:03:48 <lambdabot>  All {getAll = False}
10:04:08 <aweinstock> > ala Any foldMap [True, False]
10:04:10 <lambdabot>  True
10:04:14 <nitrix> :t ala
10:04:16 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
10:04:23 <aweinstock> it's one of those lens thingies
10:04:28 <nitrix> Ahah. That's funny.
10:04:33 <aweinstock> :t alaf
10:04:36 <lambdabot> (Rewrapped s t, Rewrapped t s, Profunctor p) => (Unwrapped s -> s) -> (p r t -> e -> s) -> p r (Unwrapped t) -> e -> Unwrapped s
10:04:50 <joco42> > (Sum 1,succ) <*> (Sum 1, succ) <*> pure 5 :: (Sum Int, Int) 
10:04:52 <lambdabot>      No instance for (Enum (Int -> Int))
10:04:52 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
10:04:52 <lambdabot>        arising from a use of ‘succ’
10:04:53 <aweinstock> :t alaf Identity both
10:04:55 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
10:05:00 <joco42> ahh
10:05:13 <joco42> :)
10:05:21 <aweinstock> > alaf Identity both (+5) (42, 0)
10:05:23 <lambdabot>  (47,5)
10:05:53 <nitrix> Oh. Does it figures out that you want Sum based on + ?
10:06:09 <aweinstock> > both (\x -> [x+1, x-1]) (0, 5)
10:06:11 <lambdabot>  [(1,6),(1,4),(-1,6),(-1,4)]
10:06:42 <aweinstock> nitrix: what?
10:07:00 <joco42> what was wrong with my latest lbot post?
10:07:16 <joco42> 8:04 pm <joco42> > (Sum 1,succ) <*> (Sum 1, succ) <*> pure 5 :: (Sum Int, Int)  - with this ?
10:07:32 <joco42> how can i get succ succ 5 ?
10:08:02 <joco42> and 2 in the first part of the pair ?
10:08:05 <aweinstock> alaf is more general than just using with monoids and foldMap, in the (alaf Identity both) example, both provides access to a functor that I didn't need (for that example) so I provided Identity
10:08:31 <joco42>  > (Sum 1,succ) <$> (Sum 1, succ) <*> pure 5 :: (Sum Int, Int) - with this ?
10:08:32 <aweinstock> > (Sum 0, (.)) <*> (Sum 1,succ) <*> (Sum 1, succ) <*> pure 5 :: (Sum Int, Int)
10:08:34 <lambdabot>  (Sum {getSum = 2},7)
10:09:00 <joco42> thanks aweinstock 
10:09:27 <aweinstock> there's probably a better way...
10:09:47 <joco42> why is the first Sum 0 needed ?, i wonder... 
10:09:55 <joco42> i am very new to applicatives
10:10:18 <aweinstock> :t (.) <$> pure succ <*> pure succ
10:10:19 <lambdabot> (Enum c, Applicative f) => f (c -> c)
10:10:33 <aweinstock> :t (.) <$> pure succ <*> pure succ <*> pure 5
10:10:35 <lambdabot> (Enum b, Num b, Applicative f) => f b
10:10:50 <aweinstock> @let tick = (,) (Sum 1)
10:10:52 <lambdabot>  Defined.
10:11:00 <aweinstock> :t (.) <$> tick succ <*> tick succ <*> pure 5
10:11:02 <lambdabot> (Enum b, Num b, Num a) => (Sum a, b)
10:11:07 <aweinstock> > (.) <$> tick succ <*> tick succ <*> pure 5
10:11:09 <lambdabot>  (Sum {getSum = 2},7)
10:11:15 <aweinstock> > (.) <$> tick succ <*> tick succ <*> tick 5
10:11:17 <lambdabot>  (Sum {getSum = 3},7)
10:11:46 <joco42> i see
10:11:52 <joco42> that makes sense :)
10:11:53 <joco42> now
10:12:04 <aweinstock> :t ala Endo foldMap
10:12:05 <joco42> thanks aweinstock 
10:12:06 <lambdabot> Foldable t => t (a -> a) -> a -> a
10:12:17 <joco42> so u combine two succ's
10:12:24 <joco42> compose
10:12:42 <joco42> nice
10:13:07 <aweinstock> :t sequenceA (alaf Endo foldMap tick [(+1), (*2), (+10)])
10:13:08 <lambdabot>     Couldn't match type ‘(Sum Integer, Integer -> Integer)’
10:13:08 <lambdabot>                    with ‘f a -> f a’
10:13:08 <lambdabot>     Expected type: (Integer -> Integer) -> Unwrapped (Endo (f a))
10:13:24 <aweinstock> :t traverse tick (ala Endo foldMap [(+1), (*2), (+10)])
10:13:26 <lambdabot> (Num b, Num a, Traversable ((->) b)) => (Sum a, b -> b)
10:13:34 <aweinstock> not quite...
10:13:40 <aweinstock> :t (ala Endo foldMap [(+1), (*2), (+10)])
10:13:42 <lambdabot> Num a => a -> a
10:14:16 <aweinstock> :t traverse tick [(+1), (*2), (+10)]
10:14:18 <lambdabot> (Num a, Num a1) => (Sum a, [a1 -> a1])
10:14:35 <aweinstock> :t ala Endo foldMap <$> traverse tick [(+1), (*2), (+10)]
10:14:37 <lambdabot> (Num a, Num a1) => (Sum a1, a -> a)
10:14:47 <aweinstock> :t ala Endo foldMap <$> traverse tick [(+1), (*2), (+10)] <*> pure 0
10:14:48 <lambdabot> (Num a, Num a1) => (Sum a1, a)
10:14:53 <tekkkz> aweinstock, please pm lambdabot 
10:14:54 <aweinstock> > ala Endo foldMap <$> traverse tick [(+1), (*2), (+10)] <*> pure 0
10:14:56 <lambdabot>  (Sum {getSum = 3},21)
10:15:04 <aweinstock> joco42: ^
10:15:05 <joco42> hmm... 
10:15:28 <joco42> nice
10:15:42 <stobix> :t tick
10:15:43 <lambdabot> Num a => b -> (Sum a, b)
10:16:05 <joco42> so this is some kind of counter of effectful computations... 
10:16:10 <aweinstock> yes
10:16:15 <joco42> nice
10:16:28 <joco42> :t ala
10:16:29 <aweinstock> ala Endo foldMap is sort of a "composing sum"
10:16:30 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
10:16:35 <joco42> ohh
10:16:36 <aweinstock> :t ala Endo foldMap
10:16:38 <lambdabot> Foldable t => t (a -> a) -> a -> a
10:16:55 <joco42> is that some kind of lambdabot  thingy? that ala?
10:17:15 <joco42> never seen it
10:17:18 <kadoban> It's from lens
10:17:24 <joco42> ok
10:17:33 <aweinstock> in general, if NewtypeWrapper has a monoid instance, (ala NewtypeWrapper foldMap) is kind of like mconcat that autowraps/unwraps
10:18:13 <joco42> hmm... ok :)
10:18:49 <joco42> thanks, one step at a time for me, this was helpful - this example
10:19:24 <joco42> foldMap maps and folds at the same time?
10:19:33 <aweinstock> the point of ala is that if you have a function that works on typeclasses (e.g. foldMap and Monoid), and a newtype wrapper for that typeclass (like Sum, Product, Endo, etc), is that it applies the wrapper/unwrapper for you
10:19:41 <aweinstock> :t foldMap
10:19:42 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:19:57 <aweinstock> foldMap Sum [1..10]
10:20:02 <aweinstock> > foldMap Sum [1..10]
10:20:03 <lambdabot>  Sum {getSum = 55}
10:20:06 <joco42> > ala Endo foldMap <$> traverse tick [(+1), (*2), (+10)] <*> pure 0
10:20:08 <lambdabot>  (Sum {getSum = 3},21)
10:20:14 <joco42> nice one
10:20:36 <lyxia> :t tick
10:20:38 <lambdabot> Num a => b -> (Sum a, b)
10:20:45 <aweinstock> traverse is just mapM generalized to Applicatives
10:20:46 <joco42> what is the Endo doing ?
10:20:49 <joco42> :t Endo
10:20:50 <lambdabot> (a -> a) -> Endo a
10:21:02 <aweinstock> Endo is a newtype wrapper that makes <> the same as .
10:21:14 <joco42> aham 
10:22:37 <joco42> i think i will think about this > ala Endo foldMap <$> traverse tick [(+1), (*2), (+10)] <*> pure 0 some more
10:23:38 <aweinstock> that was my way of trying to clean up the repetitiveness of ((.) <*> tick f <*> tick g) in a way that generalizes to more than 2 functions
10:24:07 <joco42> i see
10:24:25 <joco42> :t Endo foldMap
10:24:26 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ t a
10:24:26 <lambdabot>     Expected type: (t a -> m) -> t a -> m
10:24:26 <lambdabot>       Actual type: (a -> m) -> t a -> m
10:24:44 <joco42> :t ala Endo foldMap
10:24:46 <lambdabot> Foldable t => t (a -> a) -> a -> a
10:25:17 <aweinstock> you can think of (Foldable t => t a) as [a]
10:25:30 <joco42> yeah ok
10:25:37 <joco42> list of a
10:25:43 <joco42> to a to a
10:25:52 <aweinstock> @let composeList = ala Endo foldMap
10:25:54 <lambdabot>  Defined.
10:26:05 <joco42> it is kinda nice
10:26:11 <aweinstock> > composeList [("hello "++), ("world"++)] ""
10:26:14 <lambdabot>  "hello world"
10:26:26 <joco42> and you lift that to the applicative
10:26:37 <joco42> in > ala Endo foldMap <$> traverse tick [(+1), (*2), (+10)] <*> pure 0
10:26:40 <aweinstock> :t alaf Endo foldMap (++)
10:26:41 <lambdabot> Foldable t => t [a] -> [a] -> [a]
10:27:02 <aweinstock> > alaf Endo foldMap (++) ["one", "two", "three"] ""
10:27:04 <lambdabot>  "onetwothree"
10:27:07 <joco42> kinda nice.. 
10:27:33 <joco42> not too complex but still... has some depth
10:28:14 <joco42> i think i save this to my favorite code snippets collections:)
10:28:33 <sebboh> I'm trying to build a little application.  https://github.com/HalfWayMan/fb-test  I see a .cabal file there.  Now what?  
10:30:07 <joco42> so applicative can have state? - oh but the computations themselves cannot depend on that state... unlike the state monad... 
10:30:41 <joco42> only the result can depend on the state ... not how the result is computed
10:30:52 <joco42> in this example 
10:30:58 <joco42> > ala Endo foldMap <$> traverse tick [(+1), (*2), (+10)] <*> pure 0
10:31:00 <lambdabot>  (Sum {getSum = 3},21)
10:31:27 <aweinstock> that's exactly the extra power/complexity moving from Applicative to Monad gives you (the ability to choose future computations based on the state)
10:32:46 <joco42> kinda interesting... 
10:33:15 <joco42> thanks for the illuminative examples aweinstock 
10:33:57 <nitrix> When describing specialization, does the specialized type comes first or last?
10:34:03 <nitrix> m a ~ Maybe Int ?
10:41:52 <basti_> A simple question: I'm trying to write a search function for Data.Tree.AVL that returns the element smaller than a given element.
10:41:59 <basti_> however, the constructors are hidden
10:42:33 <basti_> is there any way besides changing the source of the package to access the constructors?
10:43:28 <maerwald> mh, I want to run a callback IO action in gtk2hs in the "background", but I can't make it work with "forkIO $ postGUIAsync $ myaction". It's still blocking the rest of the GUI
10:44:43 <geekosaur> well, yes
10:45:11 <geekosaur> you need to apply postGUIAsync to specific things that need to access the GUI
10:45:44 <maerwald> uhm, that's like a 100 things deep down the call stack
10:46:01 <geekosaur> if the callback really needs to hold access to the GUI, well, welcome to gtk --- it doesn't do multithreaded GUI
10:46:21 <geekosaur> postGUIAsync is not magic that can reach 100 things down the call stack for you
10:46:51 <maerwald> I don't see how I can make this modular if I stuff postGUIAsync everywhere
10:46:53 <geekosaur> it just relays the action to the main thread to be run
10:49:08 <sebboh> I'm having trouble using cabal install --only-dependencies in a sandbox.  I describe the problem here: http://lpaste.net/147599 ...What am I doing wrong?
10:49:10 * hackagebot gitter 0.0.0.1 - Gitter.im API client  https://hackage.haskell.org/package/gitter-0.0.0.1 (cblp)
10:51:19 <mtesseract> Hi
10:51:33 <sebboh> hi
10:52:26 <geekosaur> sebboh: rejecting: base-4.8.0.0/installed-1b6... (conflict: fb-test => base>=4.5 && <4.6)
10:52:43 <geekosaur> that translates to "fb-test is intended for an older ghc than you have installed"
10:53:02 <geekosaur> ("base" is the ghc runtime and must match the compiler)
10:53:32 <sebboh> geekosaur: so base is special?  ... ok, can't just throw an old one in the sandbox.  Fine, I'll modify the package.  System.  App.  What do you call something that has a .cabal file?
10:53:44 <geekosaur> package
10:53:48 <sebboh> thanks!
11:05:01 <shapr> Does Haskell compile onto the JVM? </troll>
11:05:17 <shapr> but seriously, today's fun Haskell article is: http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
11:05:25 <shapr> and also http://apfelmus.nfshost.com/articles/monoid-fingertree.html
11:05:34 <Welkin> shapr: yes
11:05:35 <Welkin> frege
11:06:00 <Welkin> https://github.com/Frege/frege
11:06:05 <Welkin> you probably already know about it
11:06:09 <shapr> I do :-)
11:06:24 <shapr> I was just trying to come up with a not-very-offensive troll thing to say
11:06:30 <shapr> very offensive trolling is too easy
11:06:49 <maerwald> and rarely effective
11:07:17 <maerwald> geekosaur: do you happen to know if qt sucke less wrt threading?
11:07:42 <shapr> maerwald: I'm not really a fan of trolling 
11:07:51 <shapr> I don't want to have to kickban myself for a week or something.
11:08:10 --- mode: ChanServ set +o shapr
11:08:17 <geekosaur> I think the fundamental problem is that X11 itself is not thread capable (it has a call to enable thread compatibility, but that just causes all X11 calls to be wrapped in a master mutex so they effectively singlethread)
11:08:19 <shapr> shapr: Be Nice... OR ELSE
11:08:46 <shapr> shapr: I've kicked you before, don't make me do it again.
11:08:57 <geekosaur> supposedly xcb was intended to be thread capable, but every library I'm aware of that uses it is singlethreaded
11:09:11 * hackagebot cabal-debian 4.31.9 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.31.9 (DavidFox)
11:09:21 <maerwald> geekosaur: mh, my current filemanager somehow manages to do what I want, but it's spagehtti C code I don't want to look at. If you copy a file, it creates a sub-window where the progress is shown and you can still navigate normally
11:09:50 <geekosaur> it's doing the equivalent of postGUIAsync from a thread
11:10:15 <geekosaur> I note that the Python Gtk binding implicitly postGUIAsync-s every gtk call internally if it's not on the main thread
11:10:28 <geekosaur> come to think of it, I thought postGUIAsync in gtk2hs was id if used in the main thread
11:12:56 <breadmonster> geekosaur: Hi.
11:13:13 <geekosaur> ?
11:13:25 <maerwald> it's a greeting I think
11:14:11 * hackagebot xmonad 0.12 - A tiling window manager  https://hackage.haskell.org/package/xmonad-0.12 (BrentYorgey)
11:14:53 <maerwald> mh, even if I wrap the file-copy operation inside forkIO and don't do any GUI related things in that callback, it still somewhat blocks the GUI, at least you cannot reasonably navigate
11:15:13 <maerwald> not sure if it's just the cpu load
11:16:54 <asm> Has anyone used trifecta?  I'm trying this: parseByteString (char 'A' <* eof) (delta 'A') "A"
11:16:56 <sebboh> hm, you people talking about GUI stuff should take a look at the linux framebuffer.  Basically you just enable that then you have /dev/fb0 which is mapped to your video card, so if you write some bytes to that file, you see them on your screen, period, end of story. Other apps writing to that device can and will replace your bytes, but that's just because you didn't configure them to leave your area of the screen alone.. At least,
11:16:56 <sebboh> that's the level I'm at with this. :) "The framebuffer? oh, that's so slow!" Yeah, well, I'm running intepreted languages in virtual machines, it's no slower than it was before. :)
11:17:02 <asm> I'm guessing I don't understand the delta argument
11:19:01 <maerwald> yeah, i can navigate, but it's exceptionally sluggish, weird
11:19:11 * hackagebot xmonad-contrib 0.12 - Third party extensions for xmonad  https://hackage.haskell.org/package/xmonad-contrib-0.12 (BrentYorgey)
11:19:42 <maerwald> the load shouldn't really be a problem on an 8-core haswell -.-
11:21:24 <ReinH> asm: if you don't need a delta, just use mempty
11:21:57 <asm> ReinH, heh, thanks that worked :p  
11:28:58 <haskell035> hello, can someone please help me?
11:29:32 <mtesseract> nas,
11:29:39 <mtesseract> eh, sorry.
11:29:45 <roelof> How does a line by line calculation of a boolean function looks like. I try to solve this exercise : https://www.reddit.com/r/haskellquestions/comments/3xpx3g/what_schould_i_do_with_this_exercise/
11:29:51 <mtesseract> haskell035: It's better to simply ask your question.
11:29:53 <breadmonster> maerwald: Have you parallelized?
11:30:22 <qww`> When I try to use `+` on the type level, I get the complaint `Not in scope: type constructor or class '+'`. I have `DataKinds` enabled. What am I missing?
11:31:34 <johnw> maybe you need import GHC.TypeLits
11:31:48 <qww`> ah, yup. ty
11:33:26 <maerwald> breadmonster: probably not
11:34:47 <chrisdotcode> is there a semi-semiring class that supports an identity element, addition, and subtraction?
11:42:28 <maerwald> breadmonster: ah, I just missed to pass -N to the RTS
11:49:12 <roelof> How does a line by line calculation of a boolean function looks like. I try to solve this exercise : https://www.reddit.com/r/haskellquestions/comments/3xpx3g/what_schould_i_do_with_this_exercise/
11:50:30 <ReinH> johnw: o/
11:51:05 <ReinH> roelof: use the definition of nAnd to show how it would evaluate
11:51:08 <ReinH> @where lazy
11:51:09 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
11:51:11 <ReinH> Sort of like that
11:53:07 <roelof> oke, so let's say we have a and function so true && true. How do I do this step by step. I can see a step by step definition on a recursive function but not on a boolean function , ReinH
11:53:19 <ReinH> roelof: what's the difference?
11:53:39 <ReinH> Bool isn't special, it's just an ADT data Bool = False | True
11:53:53 <ReinH> @src (&&)
11:53:53 <lambdabot> True  && x = x
11:53:53 <lambdabot> False && _ = False
11:54:06 <roelof> Custom types are not explaine so far 
11:54:11 <shirt> data IntList = IntListNull | IntList Int IntList
11:54:12 <shirt> How can i make IntList an instance of Traversable?
11:55:25 <ReinH> roelof: True && True would be evaluated by first finding a matching definition. True && x = x matches, so it is evaluated to x, which is True. so True && True --> True by the first definition of (&&)
11:55:27 <ReinH> shirt: you can't
11:55:53 <roelof> oke, that way 
11:56:05 <ReinH> shirt: Traversable requires a type of kind * -> *
11:56:12 <ReinH> that must be polymorphic
11:56:19 <shirt> ReinH: that's what i was afraid of :( so i can't use mapM and friends on IntList?
11:56:23 <roelof> ReinH:  now I see how it works. thanks 
11:56:30 <ReinH> shirt: Right. You might want monotraversable.
11:57:22 <ReinH> shirt: But is there a particular reason you aren't just using [Int]?
11:58:36 <shirt> ReinH: i am using GHCJS and i have a javascript object that i want to expose to haskell, that has a list-like structure
12:01:56 <shirt> ReinH: i tried making my haskell type polymorphic, but then i realized that to implement "fmap" i need to construct a new container, that can contain any Haskell type, which isn't really possible (and i don't actually need anyway)
12:04:56 <roelof> What do you experts think of these solutions : http://lpaste.net/147606
12:05:02 <breadmonster> ReinH: what's up?
12:06:34 <monochrom> myOr can be less strict by doing "myOr True _ = True" first
12:06:53 <ReinH> breadmonster: hi
12:07:02 <monochrom> similarly nAnd
12:07:27 <ReinH> shirt: ok, look at monotraversable I guess
12:07:40 <monochrom> also I don't see how Data.Bits is relevant
12:07:50 <shirt> ReinH: thanks, looks interesting
12:07:54 <boojinks> Hi guys. Quick question, I've been playing around with Haskell for a while and am looking to try out some web work. Can any of you recommend a worthwhile framework to look at? Yesod seems a bit too all-in - anything a bit smaller that can still be used for most tasks?
12:08:12 <maerwald> snap is maybe more low-level
12:08:32 <breadmonster> boojinks: Try snap.
12:09:01 <maerwald> but the monad stacks can be tedious either way
12:09:18 <maerwald> at least if you deal with xml stuff
12:09:23 <ReinH> boojinks: Or scotty
12:12:07 <maerwald> try to avoid the hsp package :P
12:12:11 <roelof> monochrom:  if I change it to this :   myOr True _ = True   myor _ _    = False then the tests fails on False False 
12:12:24 <boojinks> I take it Scotty is a step further down in size from Snap?
12:12:52 <monochrom> clearly, "myOr _ _ = False" is wrong
12:12:54 <ReinH> roelof: well yes, that's not a correct definition
12:13:10 <monochrom> that doesn't mean "myOr True _ = True" is also wrong.
12:13:29 <monochrom> myOr False x = x
12:13:44 <monochrom> you did this to myAnd.
12:13:55 <roelof> monochrom:  now you confusing me. You said earlier :  myOr can be less strict by doing "myOr True _ = True" first
12:14:07 <monochrom> that is correct
12:14:55 <monochrom> and does not contradict any other truth
12:15:23 <monochrom> therefore, if you find that my sentence contradicts with some other sentence Y, then Y is wrong.
12:15:29 <refefer> let's say you copy a file in conduit: is it guaranteed to completely copy?
12:15:34 <refefer> or is there some element of lazy io in there?
12:16:58 <c_wraith> refefer, even using lazy io functions like getContents, a copy operation will be complete when it produces a result 
12:17:20 <c_wraith> refefer, but that's because there are no lazy wtites
12:17:22 <ReinH> monochrom: (I admire your certainty that we live in a consistent universe)
12:17:27 <c_wraith> *writes 
12:17:54 <c_wraith> refefer, this is ignoring disk caches, etc, outside of the program's control. 
12:18:02 <refefer> c_wraith: my particular issue comes from using warp responseFile after copying a file from another directory
12:18:19 <ReinH> At some level, no IO operation is guaranteed to succeed.
12:18:24 <refefer> I'm getting an openBinaryFile resource is busy (file is locked)
12:18:42 <roelof> monochrom:  do you mean a solution like this : http://lpaste.net/147610 
12:19:02 <ReinH> roelof: No, he already gave you the solution.
12:19:22 <c_wraith> ReinH, even (return ()) can fail in the presence of breaking hardware! 
12:19:22 <refefer> the way the program works, a request is made via warp for a resource.  I use conduit to copy that resourc from an external directory to a local directory, then use responseFile to return it
12:19:24 <monochrom> myOr True _ = True; myOr False x = x
12:19:40 <monochrom> it is also ok to replace that "False" by "_"
12:20:30 <monochrom> your latest version is only slightly different. at this point it does not matter.
12:21:01 <roelof> monochrom:  oke, I apolize for not understanding what you mean 
12:21:05 <ReinH> It is equivalent to the difference between idBool True = True; idBool False = False and idBool x = x
12:21:25 <roelof> and I can do the same with nAnd somehow 
12:21:42 <monochrom> you already did
12:22:01 <roelof> oke, I thought I need to change 2 functions 
12:23:46 <c_wraith> I wonder how hard it would be to implement an extension that lets you indicate a pattern match applies only if the value being matched is already evaluated to whnf
12:24:49 <monochrom> that is better confined to IO
12:25:13 <c_wraith> I wonder if you could make it sane outside IO
12:25:22 <c_wraith> by restricting it properly 
12:25:30 <monochrom> it is insane. suddenly, f 2 is different from f (1 + 1)
12:25:40 <c_wraith> ah, yeah. 
12:26:11 <monochrom> (unless you say that Num is already insane, in which case, I can switch to a Bool example)
12:26:20 <ReinH> c_wraith: But I mean if you don't care about that tiny little problem
12:26:27 <c_wraith> I just want an efficient parallel or. :/
12:26:44 <ReinH> c_wraith: so did conal and look what he had to do o_O
12:26:51 <shachaf> c_wraith: Have you looked at unamb?
12:26:58 <ReinH> Yes th at.
12:26:59 <monochrom> in fact, it gets better. suddenly f (1 + 1) is the same as f 2 if you turn on -O1 or -O2, different if you turn on -O0
12:27:03 <c_wraith> yes. unamb isn't efficient 
12:27:29 <c_wraith> it creates ghc threads 
12:27:29 <conal> c_wraith: i'd love help with making an efficient unamb/lub.
12:27:43 <shachaf> c_wraith: If you can prove that your thing does more work for non-WHNF but eventually evaluates to the same result, it should still be fine.
12:28:13 <ReinH> conal: o/
12:28:14 <c_wraith> shachaf, yes, but the low level machinery still needs to exisg
12:28:20 <c_wraith> *exist 
12:28:22 <conal> I don't know whether unamb can be implemented efficiently on top of the GHC RTS. Would be preferable if possible.
12:28:29 <conal> ReinH: howdy!
12:28:51 <monochrom> I think "parallel or" fundamentally requires threads
12:30:18 <mtesseract> What is the correct way to define a new algebraic datatype, say "data Foo = Foo a" such that "a" can be any type as long as it belongs to some typeclass "Bar"?
12:30:54 <Zekka|Sigfig> mtesseract: ExistentialQuantification: data Foo = forall a. Bar a => Foo a
12:31:11 <Zekka|Sigfig> GADTs (IIRC): data Foo a where Foo :: Bar a => a -> Foo a
12:31:20 <Zekka|Sigfig> If I screwed up either of those someone will probably be by very soon to correct me
12:31:26 <monochrom> something similar to "par" could be done. recall that par creates two sparks, which could still be mapped to the same thread.
12:31:42 <shachaf> The best thing to do is probably not to define that type in the first place.
12:31:54 <ReinH> mtesseract: The best way to do that is to apply the constraint on functions that use Foo.
12:32:02 <shachaf> Hmm, maybe not, I misread a bit.
12:32:06 <shachaf> So it could be OK.
12:32:07 <mtesseract> Zekka|Sigfig: thanks! these are two independent solutions, right?
12:32:16 <shachaf> Those are two syntaxes for the same solution.
12:32:23 <Zekka|Sigfig> mtesseract: AFAIK they do the same thing, depending on which language extensions you like
12:33:12 <ReinH> mtesseract: http://stackoverflow.com/questions/12770278/typeclass-constraints-on-data-declarations
12:33:50 <ReinH> The GADT approach avoids those problems though
12:34:00 <monochrom> no, the two syntaxes do not do the same thing. I think the second version is a typo
12:34:06 <c_wraith> eh, it has the same issue. 
12:34:17 <ReinH> c_wraith: the GADT approach does?
12:34:17 <monochrom> data Foo where Foo :: Bar a => a -> Foo
12:34:23 <shachaf> Oh, yes.
12:34:31 <shachaf> You can write either solution with either syntax, though.
12:35:07 <mtesseract> ReinH: thanks (also for the link). but, regarding your first comment, I am not sure if that is a good solution for me as there exists no type for "a". I would like to structure my program in such a way that there are many "backends" each providing their own "handles". Each backend implements a certain Backend typeclass for these handles. But there is no type "Handle" or something.
12:35:16 <c_wraith> ReinH, well, monochrom's version fixed it. 
12:35:35 <ReinH> Yeah, that's the version I meant.
12:35:50 <ReinH> mtesseract: Can you describe what you're doing a bit more?
12:36:05 <c_wraith> mtesseract, generally you shouldn't try to constrain a type variable appearing in a data type. 
12:36:12 <ReinH> mtesseract: You don't just want doThingWithBackend :: Backend b => ... ?
12:36:26 <c_wraith> mtesseract, a lot of experience has shown it just doesn't work. 
12:36:51 <c_wraith> mtesseract, it's much better to put the constraints on the functions that need them. 
12:37:05 <mtesseract> Hmm. Now I am slightly confused. But I can try to elaborate on my specific problem with the suggested approach.
12:37:34 <ReinH> mtesseract: the usual approach is to apply a Backend constraint to the backend value in the functions that use a backend value.
12:37:46 <ReinH> Then you can use the Backend typeclass methods on that value in that function.
12:40:59 <homovitruvius> what is the advantage of stack+docker (given the fact it mounts ~/.stack and the project dir) over plain stack?
12:41:34 <ReinH> homovitruvius: That things build in docker containers, as opposted to plain stack, where they do not.
12:42:23 <ReinH> YMMV on whether "building in a docker container" provides value, but that's what it does.
12:42:25 <mtesseract> Hmm. I have been typing quite an elaboration and now I need to look at my code again. Maybe I understand my problem now.
12:42:56 <mtesseract> I guess I could simply use plain functions instead of type constructors...
12:43:26 <homovitruvius> ReinH: I understand that, but again given that everything stack modifies (the ~/.stack and project dir) are mounted, I don't see differences. I have my containers, just don't use stack+its own "container mode" because other than using images that come with all packages preinstalled, I don't see benefits.
12:43:29 <ReinH> mtesseract: you will still have to apply the constraint any time you want to use the typeclass methods on the value
12:43:41 <ReinH> homovitruvius: ok.
12:45:03 <homovitruvius> ReinH: but I'm interested in checking I'm not missing any benefit I don't see
12:46:06 <vektor> I'm using async. How do I limit the number of threads of mapConcurrently?
12:46:07 <mtesseract> Basically I have 'two' backends which are supposed to be stacked. The lower-level backend, i call these "Stores", is a database handle. e.g. a Connection for SQLite.Simple or some handle for some other database. The second backend specifies what kind of data I/O is to be done with the Store. For instance, This second backend specifies what database layout is to be expected from the Store. I have a value
12:46:08 <mtesseract> implementing the Store typeclass, fine. My idea is that each backend (in the second sense), say of the name "Foo", defines a datatype Foo containing a store handle. that is, I have been thinking about something like "data (Store store) => Foo = Foo store".
12:46:55 <mtesseract> Basically I want to put a store handle (any value implementing the Store typeclass) inside a Backend handle.
12:48:37 <cl1> howdy
12:49:10 <benzrf> hey cl1
12:49:33 <ReinH> mtesseract: that seems like a whole lot of abstraction. I'm a bit dubious.
12:50:54 <pie_> oh my god this is amazing http://tgceec.tumblr.com/
12:50:56 <pharaun> homovitruvius: the advantage for me re stack+docker is that we are still running lucid on the base system, lucid has an too old glibc for stack
12:51:34 <pharaun> homovitruvius: so i was able to make my own custom build of stack via muslc, and then use its ability to spin kup a docker container to build me the needed binaries
12:53:57 <mtesseract> ReinH: Hmm. I guess hiding the database implementation is a usual thing to do. Just to clarify about the second backend: My library shall implement the concept of "genealogy" including related database lookups. The basic concept is that there exists a notion of "parents" and "childs". But I don't want to hardcode into the library what the actual objects are. It should be usable for database I/O for anything
12:53:59 <mtesseract> that is built around the notion of parents/childs.
12:54:26 <mtesseract> ReinH: This is why I want to hide this in backend modules of the second type.
12:59:15 * hackagebot xdot 0.2.4.9 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  https://hackage.haskell.org/package/xdot-0.2.4.9 (DennisFelsing)
13:00:37 <alphonse23_> I just read that haskell breaks purity from time to time
13:00:46 <alphonse23_> when does haskell break purity?
13:01:52 <ReinH> alphonse23_: unsafePerformIO
13:02:05 <ReinH> and FFI if used improperly
13:02:09 <pharaun> what do you mean by purity/? there's stuff like unsafe* etc
13:03:20 <ReinH> alphonse23_: most times I've heard that it's from people who don't understand either purity or Haskell's evaluation model or GHC's runtime system.
13:03:25 <alphonse23_> you, know, when haskell stops being purely functional
13:03:42 <alphonse23_> when you start settings variables outside of functions
13:03:48 <alphonse23_> mutating states, as they say
13:03:57 <ReinH> Generally speaking, it doesn't.
13:04:10 <alphonse23_> if I understand purity correctly or not. that's how I understand purely functional
13:05:07 <alphonse23_> oh that's odd. I guess haskell isn't much different than lisp, in regards to lisps set function.
13:05:13 <ReinH> ?
13:05:15 <ReinH> Yes it is.
13:05:29 <ReinH> Haskell doesn't have a set equivalent.
13:05:36 <ReinH> Maybe you misunderstood me.
13:05:53 <alphonse23_> oh, I was just trying to guess what unsafePerformIO was
13:05:58 <alphonse23_> I thought maybe it was like a set funciton
13:06:06 <alphonse23_> I should probably look it up
13:06:11 <alphonse23_> before I say anything :)
13:06:43 <ReinH> unsafePerformIO is not really part of Haskell proper. It's an escape hatch that's designed to be used in circumstances where it *doesn't* break purity but where it can improve efficiency.
13:07:46 <alphonse23_> is it the only escape hatch out there? are there others. I thinks it's worth know them.
13:07:52 <Zekka|Sigfig> You an use unsafePerformIO to implement mutable variables with a pure type — you should try it, you might like it!
13:08:00 <Zekka|Sigfig> (you shouldn’t use it for anything esrious but you might have fun)
13:08:14 <Zekka|Sigfig> er, s/pure/unadorned
13:08:16 <ReinH> alphonse23_: There are a few such things. They have "unsafe" in the name and are not intended for general use.
13:08:23 <maerwald> unsafeInterleaveIO
13:08:52 <alphonse23_> oh, ahaha, so just grep for the word "unsafe" to find where a haskell program breaks purity
13:08:59 <ReinH> alphonse23_: Well, it may not.
13:09:05 <ReinH> You can use unsafe things in a safe way.
13:09:15 <pharaun> its a escape hatch
13:09:18 <ReinH> And if you use them in an unsafe way, most people would consider that a bug.
13:09:20 <pharaun> for performance, or type or various ways
13:09:26 <alphonse23_> I could use them instead of lens. Don't really like lens
13:09:30 <ReinH> People strongly expect Haskell programs to be referentially transparent.
13:09:37 <Zekka|Sigfig> alphonse23_: They aren’t really designed to do the same thing as lens
13:09:41 <ReinH> alphonse23_: They are not equivalent to lens at all.
13:09:53 <ReinH> That's like saying "Can I use an apple instead of a screwdriver?"
13:10:02 <Zekka|Sigfig> lens is about pure accessor functions, unsafePerformIO is about doing IO without marking it as IO
13:10:12 <maerwald> ReinH: depends for what xD
13:11:14 <alphonse23_> well, if I'm understanding unsafePerformIO,  I could use them to set a variable on a record. It would break purity, but it would be faster than a lens.
13:11:23 <ReinH> alphonse23_: You can't and shouldn'
13:11:25 <ReinH> t
13:11:27 <maerwald> not sure if that is true even
13:11:38 <ReinH> So no, I don't think you are understanding it.
13:11:44 <alphonse23_> okay, sorry 
13:12:03 <maerwald> I don't think "performance" is the main reason unsafePerformIO is used in some cases
13:12:26 <ReinH> :t unsafePerformIO
13:12:28 <lambdabot> Not in scope: ‘unsafePerformIO’
13:12:31 <ReinH> well fine
13:12:50 <ReinH> The only thing that unsafePerformIO does is turn an IO a action into a value a by executing the IO when the action is evaluated.
13:13:08 <ReinH> If you use this to intentionally break referential transparency, you are using it wrong.
13:13:58 <c_wraith> alphonse23_, also, you should benchmark before assuming mutable cells are faster. they usually aren't in Haskell, unless they give an asymptotic improvement. 
13:14:24 <ReinH> alphonse23_: if you want a language with globally mutable variables, you don't want Haskell./
13:14:50 <alphonse23_> c_wraith: say even in the contexts of arrays?
13:14:51 <Zekka|Sigfig> alphonse23_: Go read up on IORefs — bearing in mind that you do not need unsafePerformIO to use them!
13:14:52 <maerwald> although you can have them :P
13:14:58 * hackagebot brick 0.3.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.3.1 (JonathanDaugherty)
13:15:00 * hackagebot once 0.1.0.0 - memoization for IO actions and functions  https://hackage.haskell.org/package/once-0.1.0.0 (KAction)
13:15:22 <ReinH> alphonse23_: I prefer doing safe things to unsafe things in all contexts.
13:15:35 <ReinH> alphonse23_: There are tools like ST that are specifically designed to make the thing you want safe.
13:15:43 <alphonse23_> say like matrix arithmetic, or something of that sort. case for case, being able to mutate a variable directly is faster.
13:15:52 <Zekka|Sigfig> alphonse23_: For arrays you can use ST, which uses mutation but it uses a type to enforce purity
13:16:01 <Zekka|Sigfig> You can also do similar stuff in IO
13:16:07 <maerwald> alphonse23_: yes, sometimes in-place mutation is better, but that doesn't mean you need unsafePerformIO
13:16:17 <Zekka|Sigfig> These all amount to doing the same thing you would do in an imperative language but in a way that keeps your program from stumbling over itself due e.g. to laziness
13:16:20 <maerwald> for example, see http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html
13:16:22 <c_wraith> alphonse23_, I'd the array is big enough, and the use pattern involves lots of randomly placed reads and writes interleaved, mutable will be faster. that's not usually what's going on, though. 
13:16:46 <maerwald> implementing quicksort with a mutable array, it's still pure
13:17:06 <Zekka|Sigfig> Because Haskell is lazy it makes a really strong assumption that you won’t pull the rug out form under it by mutating data that it thought it could hold onto till later.
13:17:53 <Zekka|Sigfig> There’s also some data structures providing fairly fast, but not array-fast random access — e.g. finger trees (which are trees of B-trees) are asymptotically OK although the constant factor is killer
13:17:54 <ReinH> alphonse23_: TL;DR: unless you are able to show that your use of unsafePerformIO is safe, don't use it.
13:18:28 <Zekka|Sigfig> (finger trees are O(log n) to do anything to the middle, including rough stuff like removal/insertion, and O(1) to operate on the ends)
13:18:33 <ReinH> It's not something you reach for because you want "fast matrix multiplication" or w/e. There are tools for that.
13:19:00 <ReinH> (Many of those tools work by using unsafePerformIO under the covers but in a way that they can guarantee is safe)
13:19:40 <Zekka|Sigfig> Worst comes to worst you can just not use Haskell, and your project will probably go fine
13:20:21 <maerwald> unless he wants to write a kernel, I think that shouldn't be the case
13:20:37 <alphonse23_> oh well. I got to go guys. But thanks for all the enlightening explanations. Very interesting. I only just learned haskell breaks purity from time to time. I'd be interested in knowing when -- just for reference. 
13:20:56 <ReinH> alphonse23_: Basically: it doesn't unless the program is buggy.
13:20:57 <Zekka|Sigfig> Most people’s Haskell programs have no need to use unsafePerformIO
13:22:16 <ReinH> alphonse23_: and specifically, if they are referring to IO in general as impure, they are simply wrong.
13:23:33 <maerwald> I think a lot of people think of IO as impure because of the amounts of effects it can describe. It's not really fine-grained.
13:23:53 <ReinH> Well, they can think that if they want.
13:24:02 <ReinH> But that has nothing to do with purity.
13:24:10 <maerwald> not with the correct definition, no
13:24:14 <maerwald> but that's a moot point imo
13:24:41 <ReinH> I feel like what words mean is not a moot point.
13:24:59 * hackagebot swagger2 1.0 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-1.0 (NickolayKudasov)
13:25:11 <ReinH> This is one of the problems with the "purity" discussion. No one seems to agree on what "pure" means.
13:25:27 <maerwald> Yes, so there's no such thing as "what words mean".
13:25:38 <maerwald> people agree on a meaning or not
13:25:39 <Cale> Evaluation of expressions is what's pure, not execution of IO actions.
13:25:42 <ReinH> Of course there is. We're currently having a conversation using words.
13:26:00 <ReinH> If the question is "is Haskell referentially transparent under evaluation"? Then the answer is "Yes." modulo System.IO.Unsafe.
13:26:31 <Cale> (Well, mostly pure -- barring some low-level hooks like unsafePerformIO which are only there to sidestep situations where we'd otherwise be modifying the compiler to extend the implementation of evaluation)
13:26:33 <Zekka|Sigfig> Well, there’s a reason I’m trying to say things like “Most people’s Haskell programs have no need to use unsafePerformIO.” and “Haskell assumes you won’t mutate data that it set aside for later”
13:26:35 <maerwald> The point is that most people don't refer to scientific papers when they use the word "impure". And that's understandable.
13:26:45 <ReinH> Cale: there was a nice paper that explored the definition of purity in a FP context but for the life of me I can't find it now.
13:26:53 <Zekka|Sigfig> That’s not a philosophical way of talking about purity, those are extremely concrete things that can happen to programs
13:26:59 <ReinH> maerwald: Yes, which is why it's always important to define terms that seem poorly defined.
13:27:02 <Zekka|Sigfig> I think it’s best not to get too philosophical
13:27:09 <lamefun> I'm an idiot? IMO GHCI and Haskell Prelude should be like that: http://i.solidfiles.net/8c8a10ec83.png <--- http://lpaste.net/402144483778494464
13:27:46 <ReinH> lamefun: I don't understand your question.
13:27:52 <ReinH> I am not sure if you are an idiot or not.
13:27:59 <maerwald> ReinH: I think it's more important to explain that what they mean with impurity is still a problem that you can have in haskell
13:28:02 <Cale> What is the question?
13:28:11 <maerwald> even if it's not the correct definition
13:28:41 <lamefun> ReinH, I think I should've said "heretic" instead of "idiot".
13:28:51 <Cale> and where did this discussion begin? I haven't read the whole backlog.
13:28:57 <ReinH> lamefun: what is your question?
13:29:12 <maerwald> If you have huge IO functions, you still don't really know what effects happen there, unless you read the function. That's what feels impure. And haskell hasn't solved it because the IO type is awkward.
13:29:15 <Cale> lamefun: I don't see you as either here. That's a nice library you've got going there, you should put it on hackage at some point.
13:29:17 <milesrout> is this one of those "hurr durr IO is only pure in a very technical sense and is actually impure for all intents and purposes"?
13:29:40 <lamefun> Cale, even if it's anti-intellectualist?
13:29:48 <ReinH> maerwald: Ok, I guess that can "feel" impure, but it isn't. We can talk about that issue, but we shouldn't use "purity" when we do.
13:29:51 <Cale> lamefun: What?
13:29:57 <ReinH> lamefun: what are you talking about?
13:29:59 <Cale> lamefun: I'm talking about the Dialog library.
13:30:09 <Cale> not the weird messages that you printed using it
13:30:20 <lamefun> (I can't understand Reflex-DOM, so I used plain webkitgtk3, the library sends data to a JavaScript script in form of JSON).
13:30:38 <Cale> Oh, I see, yeah, we need better tutorials for reflex-dom.
13:30:54 <Cale> There are people in #reflex-frp who can help with problems getting that working well for you.
13:30:55 <ReinH> lamefun: are you suggesting that GHCi and the Prelude should be GUI-based?
13:31:07 <ReinH> Cale: More haddock documentation would help.
13:31:10 <Cale> Yes!
13:31:22 <ReinH> Cale: I might be able to contribute some now that I'm starting to understand things.
13:31:29 <milesrout> An example I used to explain how Haskell's IO is pure is that you're not doing IO, you're building up some instructions that can be executed later. Building the instructions is pure, executing them isn't relevant. 
13:31:36 <Zekka|Sigfig> I think more GUI support by default would be nice — I wouldn’t want to be the guy charged with making sure it works on all platforms, tohugh
13:31:38 <ReinH> Cale: I've got pathfinding now and I can draw little dotted lines!
13:32:00 <Zekka|Sigfig> milesrout: I think it’s a little confusing to use the word ‘pure’ around newbies! I certainly didn’t know what it meant when I learned Haskell (although I thought it did)
13:32:04 <Cale> I've been caught up in a mess of trying to figure out why updating reflex to use a new version of dependent-map has caused the performance of certain benchmarks to worsen (though most benchmarks improve slightly)
13:32:15 <Zekka|Sigfig> I still don’t think I know exactly what it means, although I know a few behaviors that break Haskell if my program does them
13:32:20 <maerwald> ReinH: I've seen some blog posts about more fine-grained IO types and afair bernalex even considered to do some research there, but I guess we have nothing concrete yet
13:32:21 <ReinH> maerwald: I agree with what I think is your underlying point, that we should attempt to understand what people mean by "purity" and address that.
13:32:22 <Zekka|Sigfig> (although I thought I did*)
13:32:34 <Cale> but one of the things which is on my plate is constructing a nice website with tutorials and examples for reflex and reflex-dom
13:32:43 <maerwald> so you could have a function that's only permitted to _read_ files, not write
13:32:44 <ReinH> maerwald: Extensible effects exist, FWIW
13:32:46 <maerwald> and such stuff
13:32:46 <milesrout> one example I gave was a C++ program that essentially did all of its computation and logic at compile time using template metaprogramming and the final 'program' was essentially IO ()
13:33:06 <milesrout> C++ templates are a pure functional programming language, just not a very good one. :)
13:33:08 <ReinH> Cale: seems good. I can help.
13:33:14 <Cale> ReinH: great!
13:33:53 <wedify> perfect. opened xchat to ask help with a problem and i realized the fix. thanks guys
13:34:02 <ReinH> wedify: happy to help
13:34:14 <shirt> why must a Traversable also be a Functor?
13:34:32 <milesrout> why must a Cat also be an Animal?
13:34:42 <ReinH> shirt: a Traversable is automatically a Functor: fmap = fmapDefault.
13:35:06 <Zekka|Sigfig> You can define fmap in terms of the Traversable ops, can’t you?
13:35:19 <ReinH> Zekka|Sigfig: (see above)
13:35:57 <Zekka|Sigfig> ReinH: Yeah! Let me see how they did it. Seems like you just map a function followed by return :: a -> Identity a, then runIdentity
13:36:00 <ReinH> Cale: is this work reflex-dom going on anywhere?
13:36:00 <Zekka|Sigfig> @src fmapDefault
13:36:00 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:36:06 <Zekka|Sigfig> No dice!
13:36:14 <Cale> ReinH: I haven't really started on that site yet.
13:36:52 <Cale> ReinH: But it's one of the very next things I'm going to start on, if I can ever sort out what the deal is with these benchmarks T_T
13:37:09 <ReinH> Zekka|Sigfig: fmap is a traversal of the Identity traversable.
13:37:58 <ReinH> Zekka|Sigfig: e.g. a traversal without "effects", so it's fmapDefault f = runIdentity . traverse (Identity . f)
13:38:24 <Zekka|Sigfig> ReinH: That’s just about what I described, it sounds like, except mine was a methodology
13:38:24 <ReinH> oh, they don't use Data.Identity, they use their own newtype Id a
13:38:41 <Zekka|Sigfig> pretty sure I understand then
13:38:41 <ReinH> Zekka|Sigfig: yep
13:38:49 <shirt> ReinH, Zekka|Sigfig: thanks. looks like Foldable is actually the only class i need
13:39:21 <ReinH> :t traverse
13:39:22 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:40:17 <ReinH> Zekka|Sigfig: set f ~ Identity and the type unifies with fmap modulo the newtype wrapper
13:40:31 <ReinH> That's how I see it, and is equivalent to what you said.
13:45:39 <Seblink> Hello, is there a way to extend the scope of a where to multiple (declarations?) http://lpaste.net/147615 This gives an error on line 2, 'calc' not in scope. 
13:46:12 <Seblink> I know I could use guards, or define calc twice, but are there other ways to do this?
13:46:22 <ReinH> Seblink: You can use a case statement.
13:46:31 <mauke> or if/then/else
13:46:37 <ReinH> There is no way to change the scope of where.
13:47:05 <Zekka|Sigfig> Seblink: You could define pascalTriangleRow itself in the where clause
13:47:13 <Zekka|Sigfig> renaming it to pascalTriangleRow_ or something
13:47:27 <Zekka|Sigfig> Then make the function itself just delegate like this: pascalTriangleRow = pascalTriangleRow_
13:48:32 <refefer> hmm, -xc doesn't appear to be working
13:48:59 <ReinH> heh... you *could* solve this particular case by defining pascalTriangleRow n (-1) = "", although that changes the behavior slightly (causing it to terminate on (-1) instead of not terminating)
13:49:09 <refefer> rather, it doesn't actually print out a stack trace
13:50:27 <Seblink> Seems like the most straightforward way is to just use a case statement/guards. Thanks a lot for the suggestions! I might puzzle a bit with Zekka's suggestion to figure out what he means!
13:50:33 <ReinH> in situations like these I think often it's preferable to use | n <= 0, or to specifically error on n < 0, instead of matching on 0 and n and causing an endless loop for n < 0.
13:50:46 <Zekka|Sigfig> Seblink: I’ll write you a quick example
13:51:08 <ReinH> oh wait, this doesn't decrement n.
13:51:11 <ReinH> So ignore all that.
13:51:43 <Seblink> Reinh, yea, true. 
13:51:52 <ReinH> Oh wait, I was referring to r, not n. So ignore that ignore that.
13:52:02 <ReinH> Sorry.
13:52:31 <Zekka|Sigfig> http://lpaste.net/147617 <- hasty rewrite of yours to use my design
13:53:32 <Seblink> Zekka, oh I see. That's quite a nice trick to change the scope!
13:53:42 <Zekka|Sigfig> IIRC it’s used a lot in the stdlib, but don’t quote me
13:54:49 <Seblink> I'll remember that one, might come in handy later! Thanks a lot everyone for the feedback!
13:57:30 <ReinH> Seblink: another way to refactor: http://lpaste.net/147615
13:58:13 <ReinH> which I think makes it more clear what the base case is, and avoids using calc redundantly.
13:59:45 <ReinH> (I could point out that this is a very inefficient way of constructing Pascal's triangle.)
14:00:16 <ReinH> I am fond of pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
14:05:19 <Seblink> That last one is a bit too complicated for me ReinH :P
14:07:57 <ptrx> hello, does anyone know a project/library, which embeds the browser js environment into haskell as a module, and which compiles the haskell program then to js? i only found solutions with a FFI, which i want to avoid. Thanks in advance for any tips.
14:08:38 <Seblink> I managed to get it working, but I think there is room for improvement. I'm especially not fond of having integer parameters, but a String return type. Would it be a good idea to return an array of integers for a row in the pascal triangle, and then afterwards join that array into a single string. I feel that it's better that way because I'm not commiting so hard to a single manner of output
14:10:02 <Seblink> @ptrx, maybe you can find something here: https://wiki.haskell.org/The_JavaScript_Problem#Haskell_-.3E_JS ?
14:10:02 <lambdabot> Unknown command, try @list
14:11:38 <ReinH> ptrx: You can avoid FFI if you don't need to interface with external javascript.
14:12:05 <ptrx> I already looked thorugh various lists and tutorials but couldnt find any solutions with haskell. :( most promising right now seem clojure and clojurescript. but i would love to use basically the same language in the backend and in the frontend web development, as i was used to in JS with node.js.
14:12:16 <ReinH> ptrx: Why not use GHCJS?
14:12:30 <ptrx> ReinH, does it mean, that i have a windows "object" from which i can read properties?
14:12:40 <ReinH> ptrx: Yes.
14:12:49 <ptrx> ok interesting
14:12:50 <ReinH> ghcjs-dom has such things.
14:12:55 <haskman> ptrx: you can go pretty far without using ffi in ghcjs or haste
14:13:44 <ptrx> so this means native js interfaces are native, but if i want to work with external js libraries, i need the FFI?
14:14:14 <ReinH> ptrx: GHCJS wraps a lot of things. For things it doesn't wrap, it provides the FFI.
14:14:33 <haskman> FFI is not that scary anyways, accessing window properties is as simple as "window[$1]"
14:14:38 <ptrx> ok, thanks for the tip, i always thought and understood, that the FFI was the only way
14:15:55 <ptrx> i saw scary example like for example binding events to certain dom nodes. i hoped for a cleaner solution
14:16:10 <ReinH> ptrx: you could look at reflex-dom
14:16:35 <ptrx> so i am going to read through ghcjs and haste docs and look at reflex-dom and hope for enlightenment
14:16:47 <ptrx> thanks a lot! i will come back later again :D
14:16:59 <csd_> I'm having trouble understanding why, when bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs) and unit x = (x, ""), why does bind unit . f == bind f . unit (from http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html)
14:18:03 <csd_> `((+ 1) . unit) 1` is invalid while `(unit . (+ 1)) 1` is valid... even though they both typecheck properly
14:18:07 <csd_> what am  i missing?
14:18:58 <ReinH> csd_: bind unit . f is not equal to bind (unit . f)
14:19:01 <shirt> ptrx: #ghcjs is also pretty active
14:19:47 <ptrx> shirt, thank you =)
14:20:01 <csd_> ReinH: I'm looking at the paragraph below the heading solution 1
14:20:09 <csd_> isn't that what's being implied?
14:20:51 <ReinH> csd_: That paragraph doesn't talk about unit . f
14:20:54 <ReinH> it talks about bind unit . f
14:21:18 <ReinH> which is not the same as bind (unit . f)
14:21:36 <ReinH> so your assertions about (+1) . unit and unit . (+1) are not relevant
14:21:39 <csd_> oh is it not? i was thinking that the dot had higher associativity
14:21:57 <ReinH> function application has the highest associativity
14:22:30 <ReinH> (aside from . used as a module separator and {} used in record syntax)
14:23:16 <ReinH> s/associativity/fixity
14:23:49 <ReinH> so bind unit . f = (bind unit) . f
14:25:17 <csd_> ReinH: oh that makes more sense then
14:25:21 <gromak> I'm using emacs with haskell-mode. When I type `import ` then `Module: { _list_of_alternatives_ }` appears at the bottom so that I can select one of my modules. Maybe it's a good feature but I actually hate it. Is there a way to disable it?
14:27:27 <ReinH> gromak: M-x customize-variable<RET> haskell-mode-contextual-import-completion<RET> and toggle it to off
14:27:35 <ReinH> (and save)
14:28:02 <ReinH> Lots of other configuration is available from customize-group haskell
14:29:13 <csd_> ReinH: how do i prove to myself that f * unit = unit * f = f -- i'm having a difficult time with the proofs :-/
14:30:23 * hackagebot fake-type 0.2.0.0 - A crossplatform library to simulate keyboard input  https://hackage.haskell.org/package/fake-type-0.2.0.0 (Artyom)
14:31:32 <gromak> ReinH: thank you very much!
14:32:56 <ReinH> csd_: bind unit (gx,gs) = let (fx,fs) = unit gx in (fx,gs++fs) -- definition of bind
14:33:25 <ReinH> = let (fx,fs) = (gx,"") in (fx,gs++fs) -- definition of unit
14:34:05 <ReinH> = (gx,gs++"") -- desugaring of let binding, beta reduction
14:34:15 <ReinH> = (gx,gs) -- definition of ++
14:34:31 <ReinH> so bind unit (gx,gs) = (gx,gs), so bind unit = id
14:34:37 <ReinH> id . f = f, so bind unit . f = f
14:34:41 <bernalex> maerwald: can confirm. pls fund.
14:35:05 <ReinH> and similar for the other one
14:35:11 <csd_> that seems like a tricky proof for a beginner
14:35:23 * hackagebot luminance 0.9 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.9 (DimitriSabadie)
14:35:44 <ReinH> csd_: it proceeds by applying definitions and the rules of haskell evaluation.
14:36:25 <ReinH> in an "equational reasoning" method that is essentially the same as the one used in high school algebra.
14:36:48 <csd_> yeah
14:37:25 <ReinH> It is mostly mechanical, and indeed you can write a Haskell program to prove it for you.
14:38:04 <ReinH> Richard Bird's book, Thinking Functionally with Haskell, actually shows how to write such a program.
14:40:21 <csd_> ReinH: looks like what i was doing wrong was starting with bind f . unit = bind unit . f and trying to make substitutions from that
14:40:23 * hackagebot dimensional 1.0.1.1 - Statically checked physical dimensions,  using Type Families and Data Kinds.  https://hackage.haskell.org/package/dimensional-1.0.1.1 (dmcclean)
14:40:25 * hackagebot luminance-samples 0.9 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.9 (DimitriSabadie)
14:40:50 <ReinH> csd_: well, you can do that too, but it is a bit harder
14:41:06 <csd_> yeah i know it's possible but it got too complicated for me
14:41:21 <ReinH> it's easier to show that both are equavelent to f, and then things that are equivalent to the same thing are equivalent to each other.
14:42:03 <csd_> thanks
14:42:45 <ReinH> yw
14:58:16 <ReinH> phaazon: ooooh :)
15:03:05 <milesrout> rofl https://www.reddit.com/r/programming/comments/3xplnm/a_philosophical_difference_between_haskell_and/cy6w5ol?context=2
15:03:39 <HASKELLHELP> hello?
15:03:44 <HASKELLHELP> it's me
15:03:48 <HASKELLHELP> I just need...
15:03:51 <HASKELLHELP> HELP
15:03:55 <milesrout> OK
15:03:55 <HASKELLHELP> pls?
15:03:58 <Profpatsch> HASKELLHELP: To be kicked?
15:04:17 <milesrout> HASKELLHELP: just ask the question you want to ask
15:04:39 <HASKELLHELP> do you are familiar with the gloss package?
15:04:53 <HASKELLHELP> are you*
15:04:55 <milesrout> you want help with whether people are familiar with the gloss package?
15:05:14 <milesrout> oh no, of course you don't. you want to ask a question about the gloss package. ask that question. 
15:05:24 * hackagebot eventstore 0.9.1.3 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.9.1.3 (YorickLaupa)
15:06:30 <HASKELLHELP> imagine I have  this Pictures [Circle 20,Pictures [Blank,Translate 10.3 10.3 (Circle 20)]] as a picture. How would I calculate the dimensions of the minimum rectangle involving that picture?
15:10:24 * hackagebot hoopl 3.10.2.1 - A library to support dataflow analysis and optimization  https://hackage.haskell.org/package/hoopl-3.10.2.1 (NingWang)
15:16:41 <danza> HASKELLHELP, is this homework?
15:21:47 <danza> man i had been so happy to get some homework about Haskell, and many students who have this luck just look for the fastest way to prevent their brains from thinking
15:22:57 <vektor> danza: I was recently asked by someone from my faculty student body whether I would like to get paid to offer a student-for-students class on haskell.
15:23:34 <danza> aren't professors happy to deepen, when doubts arise?
15:24:01 <vektor> My uni doesn't offer any substantial FP classes at all, if that's what you're asking.
15:24:17 <danza> oh, i see
15:24:20 <vektor> It's a completely voluntary, no credit, no nothing class that a student offers to otehr students
15:24:32 <danza> then you understand how i feel
15:24:43 <vektor> Said student is getting paid a bit by money that the student body has available.
15:25:33 <vektor> Yeah, I do. There was some Dr Racket based FP material in the beginning of my first semester, to give those who don't know how to code a chance to catch up while experienced java coders still learn something new.
15:25:50 <vektor> But that was about it. Dr Racket is a dialect of Scheme, if I'm not mistaken
15:25:51 <maerwald> experienced java coders
15:25:57 <Cale> Any Toronto Haskellers want to hang out tomorrow? I've got a train ride to Toronto, and my friend's rental car plans got messed up, so I'm likely spending the day there regardless. Where's monochrom? :)
15:27:03 <vektor> maerwald: What I was trying to say: Those who know Java would be bored AF and possibly be a nuisance to deal with if they would have to attend while total newbies learn their hello world in java.
15:27:27 <vektor> Using a more niche language for the first half of the first semester gave everyone something to learn.
15:28:39 <vektor> Anyways, now that we're already talking about it, how would you guys start a class on haskell, where the experience of the attendees should be that they're familiar with programming but not with haskell?
15:29:59 <maerwald> it doesn't really matter if they are familiar with another non-FP language
15:30:08 <maerwald> it'll be like learning from the start anyway
15:34:07 <maerwald> The only non-FP language that can help getting easier into haskell is Prolog, IMO. There are a few weird interferences. I also know that some professors teach prolog before haskell.
15:34:20 <maerwald> but that's not really that much either
15:34:26 <milesrout> nobody should teach programming languages
15:34:30 <milesrout> you should never teach haskell or prolog
15:34:35 <milesrout> you should teach computer science
15:34:55 <maerwald> milesrout: I think that's a broad statement and probably wrong, depending on the school/institute
15:35:14 <milesrout> computer science is not software engineering
15:35:25 <milesrout> it's not a subject for people that want to be professional programmers
15:35:35 <milesrout> learn relevant languages for homework and labs
15:36:10 <maerwald> I don't think it's useful to suggest that people should throw away the curriculum, ermm.
15:45:26 <MitchellSalad> any coq people around? #coq is silent at the moment
15:53:46 <lispy> MitchellSalad: i've dabbled, but I probably don't know enough to help you
15:53:58 <MitchellSalad> lispy: thanks, but johnw just helped me out
15:54:09 <lispy> excellent!
15:54:35 <johnw> I'm always in that channel, but by coincidence I was working on another Coq proof at that moment and so missed the messages :)
15:55:34 * hackagebot sbv 5.7 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.7 (LeventErkok)
15:57:52 <lamefun> A Python programmer discovers Haskell: http://shoutkey.com/melon
15:58:15 <lamefun> Sorry, found and couldn
15:58:19 <lamefun> 't resit.
16:00:39 * hackagebot ghc-vis 0.7.2.9 - Live visualization of data structures in GHCi  https://hackage.haskell.org/package/ghc-vis-0.7.2.9 (DennisFelsing)
16:02:34 <Sonolin> that's an awesome piece lamefun
16:06:51 <osa1> does anyone know a library like lifted-base but for vector library?
16:15:40 * hackagebot sbvPlugin 0.2 - Analyze Haskell expressions using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.2 (LeventErkok)
16:15:42 <lamefun> Sonolin, IMO that piece in relation to Python and Haskell also isn't trolling, it's 100% truth.
16:19:16 <wedify> is it possible to use diagrams with gtk in a pure way? right now i have an ioref storing the diagram which i then modify in the event callbacks. is this the best way?
16:21:05 <phaazon> 00:06 < ReinH> phaazon: ooooh :)
16:21:12 <phaazon> ReinH: hm? :)
16:21:35 <Cale> wedify: I think that's a reasonable thing to do. Using GTK generally will involve doing some communication using IORefs to get things to where you need them in the event handlers.
16:25:10 <wedify> just out of curiosity is using an ioref to store the "global state" efficient? seems i would have to do a lot of packing and unpacking.
16:26:05 <wedify> currently i have only one ioref, though i could split it up
16:26:13 <Cale> wedify: One thing you *can* do to make things look a little prettier and more flexible to change is to e.g. define things like  getDiagram = readIORef diagramRef  and  setDiagram = writeIORef diagramRef, and then use those instead of the IORef directly.
16:26:16 <Cale> yeah
16:26:38 <Cale> Getting and setting and IORef is just rewriting a single pointer, it's fast.
16:26:41 <Cale> an*
16:28:15 <wedify> it would be an interesting project to use one of the frp packages and make an frp front-end to gtk but right now i just want to get something working
16:29:28 <wedify> i see grapefruit-ui-gtk but arrows scare me
16:31:56 <wedify> actually looking at the examples it doesn't look so bad
16:33:32 <Cale> wedify: A reflex GTK interface would be much appreciated :D
16:34:00 <Cale> (well, reflex-dom already uses webkit via GTK if you compile with GHC, but that's not quite the same thing)
16:34:19 <Cale> It's just such a large amount of work to do something like that well
16:34:51 <Cale> Libraries like GTK have a lot of components, and even just deciding what the FRP interface to such things ought to look like can be a challenge.
16:35:00 <ReinH> phaazon: luminance
16:35:54 <ReinH> Cale: and ofc modifyDiagramRef'
16:36:02 <Cale> heheh
16:36:07 <Cale> yes
16:36:45 <wedify> Cale: well now you're trying to distract me :)
16:37:02 <ReinH> Cale: I wish I could create reflex-dom-friendly diagrams using diagrams-svg
16:37:03 <phaazon> ReinH: yeah, I’m working on it as I use it in demo code
16:37:17 <phaazon> I’m starting to feel frustrated at writing shaders in GLSL
16:37:28 <phaazon> which sucks, whilst the rest of luminance is pretty safe haha
16:37:37 <ReinH> phaazon: So apparently you have started writing shaders in GLSL.
16:37:38 <phaazon> that doesn’t make any sense, I need to bring my shading EDSL 
16:37:43 <ReinH> That's how I can tell that you're frustrated.
16:38:05 <phaazon> ReinH: I’ve been writing GLSL shaders for a while 
16:38:07 <phaazon> years
16:38:11 <ReinH> "you have done it more than zero times" ;)
16:38:12 <Cale> ReinH: Depending on what you mean by "reflex-dom-friendly", I did succeed at one point at generating SVGs in the browser and splicing them into the DOM with diagrams and reflex-dom
16:38:34 <phaazon> I wrote demos (demoscene) with nice shaders, so yeah, I know them pretty well :D
16:38:36 <ReinH> Cale: I would like to use diagrams svg generation to create widgets that can be dynamic and etc.
16:38:41 <Cale> ReinH: The performance however was not very good, apparently browsers do not like it when you repeatedly replace tens of thousands of DOM elements.
16:38:45 <ReinH> Cale: I guess maybe I want to plug lucid-svg in
16:39:24 <ReinH> Cale: Yeah, need to work on something like dirty checks
16:39:29 <ReinH> a la react
16:39:56 <Cale> So yeah, a better approach would be to build SVG in such a way that the interactive parts could be smaller and nested inside the static stuff
16:40:05 <ReinH> yeah
16:40:13 <Cale> I recall someone in #reflex-frp working on that
16:40:19 <ReinH> Cale: Well, I'm making a 4X game with an SVG map and such so I'll let you know how that goes
16:40:21 <Cale> I can't recall who it was atm
16:40:26 <Cale> oh, nice
16:40:28 <ReinH> (thus my interest in A*)
16:40:35 <Cale> If you get a good framework going let me know
16:40:57 <Cale> There's a game I want to write too, but I've been delaying a bit because everything is so close to being nice :)
16:41:16 <Cale> (that if I wait just a little longer, all these questions will have been worked out)
16:43:49 <ReinH> Cale: what sort of game?
16:44:52 <ReinH> Cale: if it involves a hexagonal map I've got you covered
16:45:18 <Cale> Kind of a chesslike game played on a 2D board, but with pieces that produce resources and get upgraded. I think it'll be on a square grid.
16:45:23 <MarcelineVQ> geometry? where we're going we don't need, geometry. *kicks the distance-field lever*
16:45:28 <ReinH> nah make it a hex grid
16:45:31 <Cale> heh
16:45:47 <ReinH> Cale: heck, you could just work on our 4X game
16:45:54 <ReinH> it involves resources and unit upgrades
16:45:56 <ReinH> close enough
16:46:04 <Cale> Well, the idea is much more specific really
16:46:07 <MarcelineVQ> Just stick in a chess minigame Rein
16:46:11 <wedify> Cale: what was the issue in using Diagrams.Backend.Canvas?
16:46:12 <MarcelineVQ> now it's collaborative
16:46:17 <Cale> But describing the rules here would be pretty long offtopic
16:46:17 <ReinH> yeah I'm sure but I'm also sure that I don't care and that you should work on our game :D
16:46:45 <ReinH> Cale: actually I'd be interested to know. -blah?
16:46:52 <Cale> sure
16:47:04 <ReinH> MarcelineVQ: well, we're including xcom-like combat, so maybe it isn't so far off...
16:47:05 <Cale> wedify: That thing is set up in such a way that it generates stuff serverside and encodes canvas commands as a weird PNG file
16:47:38 <Cale> wedify: and acts as a web application server, rather than something which runs on the client. It could be adapted, but I didn't put in the work yet to do it.
16:47:48 <wedify> ah ok
17:00:12 <bergey> ReinH: Have you seen my WIP diagrams-reflex ?
17:00:52 <bergey> https://github.com/diagrams/diagrams-reflex
17:02:23 <ReinH> bergey: well now I have
17:02:25 <ReinH> bergey: thanks
17:04:14 <bergey> mightybyte convinced me to try reflex at Hacφ, and that was the result =D  Anyway, I'm aiming to get a version on Hackage by new years.
17:21:58 <shirt> how do i check if a Double value is an integer?
17:22:34 <jle`> shirt: what do you mean by integer?
17:22:46 <shirt> a whole number
17:22:49 <jle`> that it's within 0.001 or something of a whole number?
17:22:55 <shirt> no, exactly a whole number
17:23:14 <jle`> floating point values are weird like that...it doesn't always make sense if something is exactly a whole number
17:23:52 <shirt> jle`: i know how floating point math works. i'm looking for the best way to check in haskell
17:24:20 <jle`> i'd probably check if it was within a certain distance from its rounded self
17:25:05 <jle`> so, if abs (x - fromIntegral (round x)) < 0.00001 or however accurate you need to be
17:26:04 <pavonia> > let (_, r) = properFraction 12345.0 in r == 0.0
17:26:06 <lambdabot>  True
17:26:21 <pavonia> Not sure how well this works for larger numbers
17:27:34 <shirt> thanks
17:33:07 <jle`> shirt: mhm, just keep in mind that it's not always something you can rely on, due to the nature of floating point.  'is a while number' isn't really a meaningful thing
17:34:08 <jle`> checking if abs(r) < 0.0001 would probably be sane, though
17:36:43 <shirt> jle`: thanks, i'm only working with whole numbers, so i expect exact results
17:37:05 <jle`> that's what i mean; even exact results might give you bad remainders
17:37:05 <pavonia> Why do you use a Double type then?
17:37:33 <jle`> even if you only work with 1.0, 19.0, etc, adding and subtracting them might get you a bad value that has a nonzero remainder
17:37:47 <jle`> if you're only working with integers, why not use the Integer type? :)
18:08:22 <ReinH> shirt: you should read https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
18:09:46 <ReinH> Expecting an "exact" anything with floating point numbers is a mistake. If you don't need the fractional part, don't use floating point numbers.
18:13:26 <ReinH> > 4 == 3.9999999999999999
18:13:28 <lambdabot>  True
18:13:35 <ReinH> Even dealing entirely with whole numbers, you can't guarantee "exact" results.
18:14:37 <ReinH> If you need to compare numbers "exactly", use a representation with a sensible notion of equality like Int or Rational.
18:16:11 * hackagebot riak 0.9.1.1 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-0.9.1.1 (lambda_foo)
18:16:20 <Lokathor> many haskell projects don't see to include GHC options such as -O2 or the RTS option to use multi-core by default
18:16:46 <platz> I thought cabal complained if you put -O2 in the ghc options
18:17:08 <chrisramsey> What's the difference in these two type sigs?
18:17:10 <ReinH> -O2 is a big hammer that is not always correct to use.
18:17:10 <Adeon> cabal check complains yes
18:17:22 <chrisramsey> `someFunc :: Num a => [a] -> a` and `someFunc :: [Int] -> Int`
18:17:28 <Lokathor> uhm, hmm. maybe cabal does but stack doesn't? I've put -O2 in my .cabal file and stack accepts it
18:17:37 <chrisramsey> The first is auto generated, the second is how I imagined it
18:17:39 <ReinH> chrisramsey: the former works with any type which is an instance of Num, the latter works with Int only.
18:17:54 <ReinH> chrisramsey: This may be because you are using overloaded numbers or operators:
18:17:56 <ReinH> :t 1
18:17:57 <lambdabot> Num a => a
18:17:58 <ReinH> :t (+)
18:17:58 <chrisramsey> Oh, cool. So Double would be an instance of Num I would guess
18:17:59 <lambdabot> Num a => a -> a -> a
18:18:05 <ReinH> Yep.
18:18:06 <chrisramsey> anything numeric
18:18:07 <Lokathor> chrisramsey, yes Double or Word would also work
18:18:14 <chrisramsey> I know not Word`
18:18:20 <chrisramsey> Will look that up
18:18:22 <chrisramsey> thanks all!
18:18:27 <Lokathor> it's the unsigned version of Int basically
18:18:40 <chrisramsey> Gotcha
18:18:44 <chrisramsey> makes sense
18:19:00 <Lokathor> ReinH, you say -O2 is a "big hammer"?
18:19:04 <ReinH> Lokathor: Yes.
18:19:11 <Lokathor> could you elaborate on that?
18:19:15 <chrisramsey> btw, #purescript warned me that you guys would be super helpful. Turns out they were right. Lots of answers right away.
18:21:09 <ReinH> It can cause programs to be slower, to take an extremely large amount of time to compile, or to become semantically incorrect (It can make otherwise safe uses of unsafePerformIO unsafe which can lead to, e.g., even cause segfaults). Ideally one would enable exactly the optimization phases one wants. -O is a good middle ground. -O2 is a sledgehammer.
18:21:32 <ReinH> These are mostly pathological cases, but one should be aware of them.
18:21:37 <Lokathor> huh
18:21:50 <ReinH> s/even cause //
18:22:06 <Lokathor> i knew compiles would be slower, but i didn't know that -O2 could cause programs to actually slow down
18:22:52 <ReinH> It is unusual, but it happens.
18:23:09 <Lokathor> i'll adjust my global stack.yaml file to just use -O i guess
18:23:17 <zoku> Hmm, can I use regex in a case pattern match?
18:23:56 <ReinH> Lokathor: I believe that Stack already enables optimizations by default.
18:23:58 <zoku> maybe I should build out another function to unpack the messages I'm recieving and then regex match
18:24:03 <Lokathor> oh
18:24:06 <maerwald> regex???
18:24:25 <ReinH> Lokathor: I infer this from the fact that the --fast option disables them (-O0)
18:24:40 <Lokathor> safe bet
18:24:47 <Lokathor> ghc-options:
18:24:48 <Lokathor>     "*": -O -threaded -rtsopts -with-rtsopts=-N
18:24:57 <Lokathor> i put that in, i think it'll do what i want XD
18:25:07 <ReinH> zoku: you can only pattern match on constructors. You may be interested in the view patterns extension though.
18:25:29 <ReinH> zoku: you may also be interested in not using regexp
18:25:34 <maerwald> heh
18:26:06 <Lokathor> does stack play nicely with ghcjs?
18:26:11 <ReinH> Lokathor: Yes.
18:26:21 <ReinH> Lokathor: https://github.com/reinh/reflex-dom-stack-demo
18:26:35 <zoku> ah thank you ReinH 
18:26:48 <Lokathor> cool, i'll give this whole thing a try
18:26:58 <ReinH> zoku: you'll find that -- unlike other languages -- it is much easier to write a parser in haskell than it is to write a regexp.
18:27:23 <ReinH> which is to say that regexp are always similarly awful, but parsing in Haskell is *much* better.
18:27:32 <zoku> ah yeah, this may be a good time for me to learn how to do that
18:27:42 <Lokathor> i just want a button that reads a text area, parses some stuff and processes a bit, and then sets an output area with the results
18:27:56 <zoku> I'm taking input from a MUD and I just want to perform different actions on some events
18:27:59 <ReinH> Lokathor: you can ignore the reflex stuff and use the ghcjs compiler config.
18:28:08 <Lokathor> yeah yeah
18:28:09 <zoku> like when they say "You will TIMEOUT" just send a pong
18:28:17 <ReinH> zoku: Yeah, write a parser.
18:28:38 <Lokathor> so far i have the first and last bit using normal javascript, but that middle bit will probably get complex, so i think i wanna try switching to ghcjs. it's compiling now
18:28:43 <ReinH> zoku: The simplest MUD parser is [verb, noun] = words inputLine ;)
18:28:44 <zoku> Do you have a good tutorial for those ReinH ?
18:28:49 <zoku> look for attoparsec?
18:28:58 <zoku> haha ReinH, i'm writing a mud client actually, not a mud server
18:29:04 <ReinH> zoku: attoparsec is mostly for machine-generated things.
18:29:11 <ReinH> Is the thing you're parsing generated by a machine or a human?
18:29:22 <zoku> it's generated by the MUD
18:29:29 <zoku> but this can be used with various MUDs
18:29:38 <ReinH> attoparsec would be a good bet, but parsec or trifecta would also work
18:29:47 <zoku> and it's text based, so more like human language
18:29:50 <zoku> cool, thank you
18:29:50 <ReinH> the latter have better error messages
18:29:51 <Lokathor> zoku, if you get MCCP working with your mud client drop me a line some time :3
18:30:50 <ReinH> zoku: attoparsec trades speed for good error messages. This is a good tradeoff if you're parsing something generated by a machine, where errors are less common. It's less good when parsing something generated by a human because humans are awful.
18:30:56 <sbrg> Anyone here using haste a lot?
18:30:58 <ReinH> And you really want good errors.
18:31:05 <ReinH> sbrg: I think most people are using ghcjs.
18:31:11 <sbrg> hm
18:31:18 <zoku> oh, I should try that Lokathor. I'm having latency issues already since I'm forwarding the MUD output to IRC
18:31:37 <ReinH> zoku: it's pretty easy to just talk to a socket directly.
18:32:15 <ReinH> You could even make a nice terminal interface using brick.
18:32:29 <Lokathor> zoku, my mud of choice (aardwolf) gives a small bonus if you're using MCCP. I'd like to get my own mud client working for fun, but MCCP seems somewhat poorly specified and spooky
18:32:40 <sbrg> ReinH: maybe I should do the switch
18:32:43 <Lokathor> so for now i just use MUSHclient
18:33:09 <ReinH> Lokathor: I spent a day looking at writing a MUD client and gave up.
18:33:28 <zoku> ReinH: ah, the idea behind this is for multiple users to view and interact with the client
18:33:34 <zoku> so irc makes that part easy
18:33:38 <zoku> the latency is obnoxious though
18:33:42 <ReinH> MCCP is just streaming zlib compression though right?
18:33:53 <zoku> yes
18:33:57 <ReinH> zoku: wait, wouldn't that make it a server then?
18:34:21 <ReinH> things like https://hackage.haskell.org/package/zlib-conduit exist
18:34:46 <platz> anyone build lambdabot lately?  I can get it working but it seems to incorrecly decode the utf-8 output from mueval
18:34:47 <ReinH> Oh wait that's been moved to conduit-extra now, which also includes the attoparsec stuff
18:35:22 <platz> so it chokes on certain errors with "tag (8216) is outside of bounds"
18:35:25 <zoku> ReinH: ah, it's more like a bridge between IRC <-> MUD
18:35:36 <ReinH> zoku: ah
18:44:53 <sbrg> ReinH: I found a repository by you using stack, reflex-dom and ghcjs. I also found a video about using blaze-react and ghcjs together. but looking all this stuff up, everything seems to be in a state of flux/unstable. is there anything that is relatively stable and has proper documentation? 
18:45:10 <sbrg> Haste seems to be pretty stable, but it's much more limited that ghcjs.
18:46:05 <ReinH> sbrg: Lack of stability / documentation is a problem, although for reflex moreso than ghcjs.
18:47:09 <sbrg> I see. Well, I was hoping to do something web-based using entirely haskell stuff. so if I run with just vanilla ghcjs, I should be good, more or less?
18:47:14 <sbrg> vs reflex or blaze-react or whatever
18:51:06 <jay6981> :k Monoid
18:51:08 <lambdabot> * -> Constraint
18:51:26 <jay6981> what's Constraint?
18:52:24 <rom1504> :t Constraint
18:52:26 <lambdabot> Not in scope: data constructor ‘Constraint’
18:52:46 <rom1504> :k Constraint
18:52:48 <lambdabot> BOX
18:52:52 <rom1504> helpful
18:53:00 <rom1504> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/constraint-kind.html
18:53:00 <chrisramsey> What's the haskell version of filter or reject?
18:54:05 <pavonia> :t filter  -- chrisramsey?
18:54:06 <lambdabot> (a -> Bool) -> [a] -> [a]
18:54:14 <chrisramsey> yep, that's the one.
18:54:27 <chrisramsey> I was searching specifically for reject and not finding anything
18:54:29 <chrisramsey> thanks :)
18:54:48 <pavonia> What non-Haskell version were you referring to?
18:54:51 <jay6981> rom1504:  thanks
18:55:53 <chrisramsey> Something like Ramda's R.reject((x) => x.prop === false)
18:56:00 <chrisramsey> the opposite of filter
18:56:03 <chrisramsey> if true, get rid of it
18:57:33 <pavonia> Hhm, reject f = filter (not . f)
18:57:56 <pavonia> > let reject f = filter (not . f) in reject odd [1..10]
18:57:58 <lambdabot>  [2,4,6,8,10]
18:58:07 <chrisramsey> man i love composition.
18:58:12 <chrisramsey> it's changed my life in JS.
18:58:34 <chrisramsey> and having that + currying natively in haskell is just fantastic.
18:58:58 <chrisramsey> surprising haskell doesn't natively have reject, but that's just fine since filter is there :)
19:01:46 <chrisramsey> let reject f = filter (not . f)
19:01:55 <chrisramsey> reject (\x -> x == "hello") (splitOn " " "just a hello string")
19:03:25 <chrisramsey> Had to throw my hands up in the air with that one. I'm BEGINNING to wrap my head around how to do various things.
19:04:52 <Lokathor> need to build a package with cabal (gloss) but can't run cabal through stack exec
19:04:56 <Lokathor> hhhhhng
19:31:55 <lamefun> Why isn't "-threaded" default?
19:35:22 <lamefun> Sends message: threads are beta in Haskell.. best to avoid.
19:42:42 <Adeon> even if you use -threaded you don't get multicore
19:43:01 <Adeon> you also need to use -N
19:43:12 <dmj`> you compile with -threaded, you run with -N
19:43:15 <Adeon> I also think -threaded should be default but not totally sure with -N
19:43:23 <Adeon> well yes
19:43:29 <Adeon> but in cabal file you can set -N in rtsopts
19:43:43 <lamefun> without -N, Python-like GIL?
19:43:44 <Adeon> e.g. -rtsopts -threaded "-with-rtsopts=-N"
19:44:11 <Adeon> yeah it uses just one OS thread
19:44:13 <jay6981> concurrency =/= parallelism
19:44:37 <Adeon> you still get more than 1 OS thread if you use forkOS
19:44:43 <Adeon> because in GHC forkOS always spawns a new thread
19:44:58 <Adeon> not sure if that interacts with -N
19:45:33 <lamefun> Do I need to compile libraries with threaded?
19:45:41 <Adeon> no
19:45:46 <Adeon> just the executable
19:46:10 <lamefun> Oh, I have to use forkOS anyway
19:46:34 <Adeon> it's not that simple that you can just set -N and then it'll be fine and dandy
19:46:49 <Adeon> with some workloads that can decrease performance compared between, say -N1 or -N16
19:46:57 <Adeon> you might have to tune GC parameters as well
19:47:04 <Adeon> that's one justification why all this isn't default
19:48:09 <jay6981> there are also numa concerns
19:59:09 <Lokathor> as i understand it, with-rtsopts sets the default values for the options
19:59:22 <Lokathor> but you could still override -N1 for example
20:08:18 <haskell174> i have 2 types which have accessors of the same name (http://lpaste.net/147623). how can i use them together without getting the "Multiple declarations of..." error?
20:10:00 <Lokathor> ghcjs just keeps compiling more and more things
20:10:24 <Lokathor> haskell174, you cannot in the currenr version of ghc
20:10:50 <Lokathor> in the next major version there will be an ability to resolve that conflict, but for now you have to pick different accessor names
20:11:50 <haskell174> Lokathor is there a way to inherit Order in OrderResponse? 
20:12:20 <Lokathor> well, OrderResponse could have an Order field as part of the record if that's what you mean
20:12:50 <Lokathor> seems the simplest way to do it; and sensible for the Response to track which Order it's responding to
20:15:16 <Lokathor> haskell174, also, I'm not sure that so many of those fields need to be strict
20:31:00 <Lokathor> weird thing about stack on raspberry pi 2 is that it takes a looooong time to run
20:31:21 <Lokathor> but once it's computed the whole build plan, the actual GHC building of stuff doesn't take too long
20:32:36 <nitrix> Is there a way to simplify:    withFoo foo (\foo -> ... foo ... )   ?
20:32:54 <phy1729> Can I make show (0 :: Rational)  be "0" instead of "0 % 1" ?
20:33:14 <exio4> nitrix: how do you foo there?
20:33:31 <Lokathor> nitrix, not really a way, no
20:33:41 <exio4> nitrix: I found '' withFoo foo (f . g . h) '' to be a relatively common pattern in some code
20:34:04 <Lokathor> oh, hmm, yeah you could make it pl i guess
20:34:23 <exio4> "how do you foo" +use
20:34:56 <Lokathor> phy1729, you can't make show do a different thing, but you can make a different function that is Rational -> String
20:34:57 <Lokathor> and use that
20:35:20 <phy1729> Lokathor: thanks
20:36:14 <Lokathor> formatRat r = if r == 0 then "0" else show r
20:47:56 <jle`> nitrix: you can also withFoo foo $ \x -> ...
20:48:56 <nitrix> That much I knew. I was looking for a way to avoid the repetition; but I'm not realising I may want my Foo type to be monadic.
20:49:01 <nitrix> *now
20:49:23 <jle`> not toatlly sure what repetition you're talkinga bout here, though
20:49:37 <jle`> the foo you call as an argument and the foo in the lambda parameter are different foo's
20:49:43 <Lokathor> ReinH, I tried to install your ghcjs example, but it seems to be having trouble with installing happy since ghc isn't in my path
20:49:49 <Lokathor> since i have it installed via stack only at the moment
20:50:14 <Lokathor> even though i'm building with stack, somehow it ends up not finding ghc, so i'll install the haskell platform and see how that goes
21:04:16 <kadoban> Lokathor: You're installing something with stack and it's not finding its own installed ghc? That's … surprising to say the least.
21:11:21 <Lokathor> correct
21:12:59 <kadoban> Lokathor: Submit a bug report, especially if you can reproduce it?
21:13:31 <Lokathor> well i mean if i try it again it happens again. not entirely sure how to reproduce
21:13:39 <Lokathor> i'll look into this more in a little bit though
21:13:45 <lamefun> My package includes JQuery (MIT), what should I put in the license?
21:14:30 <lamefun> license: BSD3, MIT?
21:15:50 <Clint> lamefun: what's the license of your software?
21:16:04 <lamefun> BSD3 (stack default)
21:16:10 <Clint> then it's BSD3
21:16:47 <lamefun> But it includes MIT JQuery...
21:17:03 <Clint> BSD-3-clause is equivalent to MIT/Expat with an additional restriction
21:17:05 <lamefun> I mean, WebKit GTK3
21:17:24 <Clint> so the collective work is equivalent to BSD-3-clause
21:17:33 <Clint> s/collective/derivative/
21:29:24 <demize> Technically the old license still applies, but since it is less restrictive there's no reason to keep it
21:29:38 <demize> As long as the copyright is marked properly.
21:36:25 <Lokathor> kadoban, http://lpaste.net/147626 this is what happened
21:36:47 <Lokathor> care to see if there's some sort of obvious fix i should know about before i make a bug report?
21:38:19 <kadoban> Lokathor: I'm not really sure what's going on there personally. I don't know a lot about ghcjs either though.
21:38:34 <Lokathor> yeah it's pretty mysterious
21:39:10 <MarcelineVQ> "The program 'ghc' is required but it could not be found"
21:40:36 <ReinH> *technically* the material that is MIT licensed must be redistributed with its license intact. You can still license *your* code as BSD3 and distribute it with the MIT licensed code.
21:41:36 <MarcelineVQ> Lokathor: If you haven't, consider adding the ghc paths from "stack path" to your path and try building with them available to see if it helps
21:41:51 <ReinH> Whether or not the licenses are "equivalent", the MIT license clearly states its. There are omnly two of them, and one of them is that the MIT license shall be included.
21:41:57 <ReinH> s/states its/states its terms
21:42:29 <Lokathor> yeah just have license.txt and license-jquery.txt
21:42:32 <Lokathor> simple
21:42:32 <ReinH> You can't just release MIT licensed code with a different license because you claim that they are "equivalent".
21:42:44 <ReinH> Lokathor: yeah, that should be fine.
21:43:36 <ReinH> Anyone who tells you that you don't need to keep the MIT license hasn't actually read the MIT license. I don't understand why anyone would say that. It's a short license. It's not hard to read.
21:44:05 <ReinH> /rant
21:44:37 <johnw> isn't the point of that LICENSE that you have to maintain it in any derivative work or copy?
21:45:29 <ReinH> johnw: Yes.
21:45:46 <gerald> literally it is what makes MIT unique
21:45:47 <kadoban> johnw: The point of a license is that it tells you what you can do and not. But usually something like that, yeah.
21:47:02 <Lokathor> agpl all code forever
21:47:16 <ReinH> So yes, there *is* a reason to keep it: because it says so.
21:47:19 <Lokathor> agpl.txt in all directories on your whole system
21:49:00 <mniip> GPL is eh
21:52:31 <Lokathor> ReinH, do you know what "JavaScript exception: Error: spawn ENAMETOOLONG" is all about?
21:53:42 <gerald> wtfpl is really the best license
21:54:14 <demize> gerald: Except for the fact that it's legally ambiguous.
21:54:45 <gerald> yeah, definitely. It is really limited for real-world use, but still I like the spirit of it.
21:55:31 <Lokathor> demize, what's ambiguious about it?
21:56:19 * hackagebot dialog 0.1.0.0 - Simple dialog-based user interfaces  https://hackage.haskell.org/package/dialog-0.1.0.0 (lamefun)
21:56:47 <demize> It doesn't lay out the grants explicitly, and there's also the issue where it doesn't disclaim warranties, so if you use it for your projects you are legally liable for implied warranties.
21:57:33 <Lokathor> it's mildly crazy that there are implied warranties of any worth if everyone is disclaiming them all the time
21:58:02 <demize> They're only disclaimed in open source software.
21:58:57 <Lokathor> it seems more rational that you should have to claim a warranty in the first place, but whatever
21:59:23 <demize> For example, selling broken things while giving the impression of there being none would be a violation of the implied warranty of merchantability
22:00:01 <demize> Otherwise people could be selling you broken things all around, with no issues.
22:00:21 <jle`> Lokathor: it makes sense to a lot of people that selling/giving away dangerous things has some implied warranty...and it doesn't, to other people.  explicit licenses are a way of staying what you really mean :)
22:00:32 <demize> Another example is the implied warranty of fitness for a purpose.
22:00:43 <Lokathor> i'm 9% convinced, and must now go watch deep space 9
22:01:12 <demize> If you ask for a product with a specific requirement, and are given a product that doesn't qualify.
22:01:23 <demize> Which could in many cases be life threatening.
22:03:04 <demize> Implied warranties are a good idea, it's just that most open source project maintainers don't want to be legally liable to bugs in their programs. ;p
22:06:37 <Nimi11> Haskell is hopeless! what's happening?
22:06:50 * Clint squints.
22:07:09 <xacktm> where is the sky falling?
22:08:00 <xacktm> if you read the 2015 haskell summary, things appear to be progressing well :)
22:29:08 <lethjakman> So, I can't tell if what I'm doing is attempted crazy talk or if it's possible. 
22:29:51 <lethjakman> I'm trying to use the do syntax to dive into nested data types, some of which are maybe and some of which aren't. 
22:30:20 <lethjakman> https://gist.github.com/lethjakman/e8c4a66a65b172a75781
22:30:23 <lethjakman> Is there a good way to do this?
22:35:05 <kadoban> lethjakman: Well it looks like it might typecheck with 'return t3' on line 11, but other than that I can't tell what exactly you're asking.
22:35:30 <kadoban> Hmm, actually no I lied.
22:35:53 <lethjakman> I messed it up and missed the return I think...
22:36:07 <lethjakman> Yep, that was derpy.
22:36:35 <lethjakman> https://gist.github.com/lethjakman/e8c4a66a65b172a75781
22:36:38 <lethjakman> That's what I was thinking. 
22:36:43 <lethjakman> Sorry, thank you for your help!
22:37:03 <kadoban> Right that looks like it should work
22:37:11 <lethjakman> Is that let weird?
22:37:36 <kadoban> Yeah
22:37:42 <lethjakman> Is there something better I can do?
22:38:01 <kadoban> return $ name (t3 tt) ?
22:38:22 <lethjakman> Fair enough
22:43:39 <ReinH> lethjakman: name . t3 <$> t2 t
22:44:02 <lethjakman> ReinH: Fancy
22:44:10 <lethjakman> Thanks :)
22:44:38 <ReinH> or equivalently, fmap (name . t3) (t2 t)
22:45:34 <ReinH> any time you catch yourself doing something of the form do { x <- fx; return g x }, consider fmap g fx or g <$> fx instead
22:45:42 <ReinH> er, return (g x)
22:46:10 <ReinH> the monad laws guarantee that they are equivalent.
22:55:15 <Lokathor> says i need happy >= 1.17
22:55:20 <Lokathor> happy --version shows 1.19
22:55:21 <Lokathor> wat
22:55:40 <Lokathor> like much of haskell, ghcjs just doesn't seem pleased with windows
22:55:56 <ReinH> Lokathor: are you developing software for windows?
22:56:13 <Lokathor> i am attempting to get ghcjs up and running on windows
22:56:23 <ReinH> For fun?
22:56:32 <ReinH> because I would suggest using a linux vm.
22:56:35 <Lokathor> well, i mean i have a windows computer
22:56:41 <Lokathor> i guess i could use a vm
22:56:47 <ReinH> it will make many things easier
22:57:08 <Lokathor> i've got a linux box in the corner that i can ssh into, i'm also sloooowly building it on that as well
22:57:16 <Lokathor> but it's like 1.1GHz, so very slowly
22:58:52 <ReinH> use a vm :p
22:58:59 <ReinH> or dual boot
23:00:08 <GGMethos> on a dual core xeon it takes a bit to build haskell too
23:00:09 <GGMethos> its big
23:00:12 <GGMethos> lol
23:00:30 <ReinH> ghcjs takes a while
23:05:18 <Lokathor> how fast would a vm run on a quad core 3.2GHz compared to having a real machine that's a single core 1.1GHz?
23:05:20 <Lokathor> hmmmm
23:06:03 <kadoban> Lokathor: Depends on the VM and the machine probably.
23:08:27 <KaneTW> Lokathor: probably way faster
23:09:10 <KaneTW> usually you lose about ~5% cpu and ~10% memory performance
23:09:19 <KaneTW> on bare metal hypervisors
23:09:33 <KaneTW> at most that is
23:09:33 <Lokathor> huh
23:09:43 <Lokathor> that is much lower than i expected
23:09:52 <KaneTW> if you have vt-x etc
23:10:03 <KaneTW> overhead is around 1-3% for both
23:10:04 <Lokathor> the only VM i've used (other than the JVM) is the android emulator thing
23:10:16 <KaneTW> well that's an emulator
23:10:22 <KaneTW> they're much more inefficient
23:10:33 <KaneTW> i'm talking about x64 on x64 vms like kvm or esxi
23:10:52 <KaneTW> for emulators the single core might be faster
23:11:23 <Lokathor> i might look into VM stuff some time
23:11:53 <Lokathor> there's no rush on the ghcjs compile really
23:12:00 <Lokathor> several irons in the fire most of the time, and such
23:26:25 <Lokathor> is it safe enough to force-reinstall to a sandbox?
23:31:25 * hackagebot bit-array 0.1.1 - A bit array (aka bitset, bitmap, bit vector) API for numeric types  https://hackage.haskell.org/package/bit-array-0.1.1 (NikitaVolkov)
23:41:34 <chrisdotcode> is there any way to have a infix function have higher precedence than function application via whitespace? (example: in `foo bar # biz`, I want (bar # biz) to apply before `foo` applies to the result of the latter.)
23:42:00 <Lokathor> foo $ bar # biz
23:42:41 <kadoban> chrisdotcode: No, function application has higher precedence than it's possible to have via an infix operator.
23:42:56 <chrisdotcode> kadoban: Lokathor: thanks. figured that might be the only solution.
23:46:25 * hackagebot dialog 0.2.0.0 - Simple dialog-based user interfaces  https://hackage.haskell.org/package/dialog-0.2.0.0 (lamefun)
23:51:25 * hackagebot sbvPlugin 0.3 - Analyze Haskell expressions using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.3 (LeventErkok)
23:53:49 <jle`> chrisdotcode: the other same solution is to just use parentheses :)
23:54:08 <chrisdotcode> jle`: that's no fun. I like unlimited power better
23:56:38 <quchen> bgamari: ping, shake-ghc fails on me with a HSC error I've never heard of, is this a known issue?
23:57:00 <quchen> http://lpaste.net/147628
