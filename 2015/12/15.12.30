00:31:57 <wedens> can I use Custom build-type in cabal to download and extract some C library?
00:32:16 <wedens> (or any other archive)
00:33:17 <bitemyapp> pdxleif: around?
00:37:06 <kadoban> wedens: Sounds pretty terrible even if you could. Why not just include it in the first place?
00:38:05 <sgronblo> Having trouble understanding how to use MArray STUArray and ST
00:40:09 <wedens> kadoban: it is terrible :) I need to FFI with some (private) library and I have tar.gz with headers and dynamic library (so/a)
00:44:53 <sgronblo> Tricky to get these types right...
00:47:47 <sgronblo> Trying to muck around and make sense of this: applyCommand :: MArray STUArray LightState (ST s) -> Cmd -> ST s (MArray STUArray LightState (ST s))
00:48:24 <sgronblo> Wanna take a mutable array, and a command, and apply the command by updating the array
00:54:04 <sgronblo> I'm enjoying this "I'm feeling stupid" moment
00:57:46 <roelof> How can I make the descruting work here : fibTable n =  [ pushRight (show n1) ++ pushRight (show n2) ++ "\n" | (n1, n2) <- (zip [ 1 ..] (fibs n)) ]   
00:57:49 <roelof> I now see this error  :  Couldn't match expected type ‘(Integer, Integer)’   with actual type ‘[(a0, a1)]’
01:11:18 <roelof> nobody who can help me ? 
01:11:26 <Skuzzzy> I don't know haskell sorry
01:23:14 <sgronblo> I dont get how to write this MArray type class constraint
01:23:55 <sgronblo> Not even sure if I need it
01:25:03 <unit73e> what MArray type class constraint?
01:27:06 <unit73e> nvm I see what you mean by that
01:29:48 <sgronblo> I've been messing around with it some more... got this currently: applyCommand :: (MArray a e m) => a Int LightState -> Cmd -> m ()
01:30:18 <sgronblo> But now e0 is ambiguous
01:32:31 <sgronblo> I'm trying to writeArray a value of type LightState to the array inside the function, so if I change the first parameter's type to a Int e, then it's complaining because I'm claiming to support any e for which the MArray constraint holds but then I'm violating it by trying to write a specific LightState value
01:33:09 <sgronblo> If I put LightState into the MArray type class constraint I get shouted at and told to activate some language extension which I'm not sure if it really is what I want
01:34:26 <sgronblo> This makes me wanna cry
01:34:41 <sgronblo> Would be so simple in an impure language
02:09:29 * hackagebot wai-app-file-cgi 3.1.0 - File/CGI/Rev Proxy App of WAI  https://hackage.haskell.org/package/wai-app-file-cgi-3.1.0 (KazuYamamoto)
02:14:29 * hackagebot mighttpd2 3.3.0 - High performance web server on WAI/warp  https://hackage.haskell.org/package/mighttpd2-3.3.0 (KazuYamamoto)
02:16:26 <sgronblo> I think I managed to sort out a whole bunch of errors, but I still have this thing where I can't figure out how to tell Haskell my type correctly
02:18:15 <sgronblo> Is this FlexibleContexts something that is recommended to use, or is it just being suggested because I'm doing something stupid?
02:19:47 <pavonia> It's something that is used regularly, I think
02:20:16 <pavonia> which doesn't necessarily mean you're not doing something stupid ;)
02:21:08 <lyxia> It looks fine in this case.
02:23:05 <pavonia> Oh, I haven't seen the conversation above, sorry
02:23:12 <srhb> sgronblo: Have you pasted the code?
02:26:34 <tenniscp25> I want to write a websocket-to-serial-port adapter. Am I correct that in this case I should use MVar instead of STM to manage serial ports because most of my code involves IO that can't be rollbacked?
02:29:18 <sgronblo> srhb: not yet
02:29:40 <sgronblo> I managed to make my program compile now, but I think it gets stuck somewhere.
02:30:38 <sgronblo> srhb: Actually, it worked!!!!!!!!!!!!!!!1111111!!!ONE
02:30:40 <urine_boy> hi everyone
02:30:52 <urine_boy> niggers should be hanged because they are black
02:30:56 <srhb> @where ops
02:30:57 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:30:58 <urine_boy> i like racism
02:31:09 <urine_boy> i hate niggers
02:31:19 <sgronblo> urine_boy: are you a bot?
02:31:22 <urine_boy> no
02:31:28 --- mode: ChanServ set +o Cale
02:31:30 --- mode: ChanServ set +o dibblego
02:31:32 --- mode: dibblego set +b *!*urdh@*unaffiliated/urdh
02:31:33 --- mode: Cale set +b *!*@gateway/web/freenode/ip.85.76.101.110
02:31:33 --- kick: urine_boy was kicked by Cale (urine_boy)
02:31:37 <srhb> o/
02:31:42 --- mode: dibblego set -b *!*urdh@*unaffiliated/urdh
02:31:52 <bitemyapp> that was like a two-person Mortal Kombat combo
02:31:52 --- mode: dibblego set -o dibblego
02:32:26 --- mode: Cale set -o Cale
02:32:34 <pdxleif> bitemyapp: Si - ja?
02:33:06 <sgronblo> so finally this program that would have taken maybe 30 mins for me to write in python gave me the right answer after a few hours of coding in haskell :)
02:33:21 <sgronblo> well i did learn a bit about how to use ST and Arrays
02:34:06 <sgronblo> I had two run time errors because I didnt realize that you could create two dimensional arrays by using tuple in newArray
02:34:15 <srhb> sgronblo: It's not the same program, though.
02:34:23 <srhb> (Safety first!)
02:34:28 <sgronblo> srhb: true true
02:34:39 <sgronblo> im sure it would have been quicker if i had known more about haskell
02:35:36 <sgronblo> the second runtime error was because i first confused the spec of the dimensions as (startCol, endCol) (startRow, endRow) instead of (startCol, startRow) and (endCol, endRow)
02:36:10 <sgronblo> now my remaining question is whether it was a good thign or not to add this row {-# Language FlexibleContexts #-}
02:36:52 <sgronblo> was my program just that complicated or was i just avoiding writing some boilerplate?
02:38:03 <pdxleif> wedens: The Idris build calls makefiles and such from Cabal...
02:38:29 <maerwald> I think sometimes people overestimate the safety haskell can give you. pi = 0.0 :: Double, fullPath = bar/baz :: String... you still end up checking arguments like other programming languages
02:39:05 <maerwald> and when it's about cryptography, explicit memory management becomes a huge question mark
02:40:31 <maerwald> I don't use haskell because of safety. I just think it's superior in terms of refactoring and I like to mess with my code.
02:42:01 <tenniscp25> How to remove a TChan created with newBroadcastTChan?
02:43:08 <tenniscp25> By "remove", I mean I don't want to broadcast to that channel anymore.
02:44:09 <tenniscp25> I think if I don't unsubscribe it from the master, it would cause memory leakage. Is that correct?
02:47:39 <bitemyapp> pdxleif: use Trifecta much?
02:52:17 <pdxleif> pdxleif: Uh, nope.. :(
02:52:41 <Erebe_> Does anyone know if shake (the build system) has an irc channel ?
02:53:04 <pdxleif> Idris has its own parser thing that looks built on top of it...
02:53:44 <AlecTaylor> hi
02:55:54 <pdxleif> Maybe I was thinking of this stuff: https://github.com/idris-lang/Idris-dev/blob/master/src/Idris/ParseHelpers.hs#L46
02:55:54 <sgronblo> Hmm, why doesnt Haskell accept my type i which is (Int, Int), when the type signature says Ix i?
02:56:22 <sgronblo> ah i think i got it
02:56:40 <pdxleif> Oh, it just wraps the Parser monad witih Idris state.
02:57:29 <pdxleif> bitemyapp: Ah, sorry, haven't.
02:58:21 <pdxleif> Ahmad Salim wrote the current Trifecta-based parsing in Idris.
03:00:23 <pdxleif> I'd like to figure out how to run this parser. It's used in the current .ipkg parser, and I'd like to replace that syntax with a .yaml parser. https://github.com/idris-lang/Idris-dev/blob/master/src/Idris/ParseHelpers.hs#L317
03:00:48 <bitemyapp> pdxleif: np
03:12:17 <zett_zelett> :type random
03:12:46 <zett_zelett> Hm, how does lambdabot work again?
03:12:56 <zett_zelett> :t random
03:12:57 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
03:14:19 <zett_zelett> :t (fst . random)
03:14:20 <lambdabot> (RandomGen b, Random c) => b -> c
03:14:29 <zett_zelett> :t (snd . random)
03:14:30 <lambdabot>     Could not deduce (Random a0) arising from a use of ‘random’
03:14:31 <lambdabot>     from the context (RandomGen c)
03:14:31 <lambdabot>       bound by the inferred type of it :: RandomGen c => c -> c
03:15:46 <zett_zelett1> Damn disconnects.
03:15:53 <zett_zelett1> So anyway, what the hell is going on here?
03:16:05 <zett_zelett1> Why is (fst . random) ok but (snd . random) yields a type error?
03:17:24 <pavonia> zett_zelett1: It doesn't know what Random a is meant there
03:17:50 <pavonia> :t (snd . (random :: RandomGen g => g -> (Int, g)))
03:17:52 <lambdabot> RandomGen c => c -> c
03:18:15 <zett_zelett1> Because the type variable isn’t actually used or what?
03:18:36 <zett_zelett1> Why would it need a concrete type?
03:19:24 <merijn> Time for my semi-daily complaint about "concrete type" being an ill-defined term that should be avoided :)
03:19:24 <sgronblo> Hmm, I feel like my program became twice as slow when making it more generic by using type classes...
03:19:25 <zett_zelett1> Anyway, this makes the implementation of randoms' in http://learnyouahaskell.com/input-and-output not work.
03:19:31 * hackagebot gremlin-haskell 0.1.0.2 - Graph database client for TinkerPop3 Gremlin Server  https://hackage.haskell.org/package/gremlin-haskell-0.1.0.2 (nakaji_dayo)
03:20:04 <merijn> sgronblo: Generalising using typeclasses can kill some optimisations/specialisations/inlining/etc. so that's certainly possible
03:20:25 <zett_zelett1> merjin: Don’t you distinguish between say, ‘a’ and ‘Int’, ‘Float’, ‘String’, …?
03:20:42 <pavonia> zett_zelett1: Because the resulting generator depends on the concrete random implementation
03:20:54 <merijn> zett_zelett1: Quick question: Is "Maybe" a concrete type? Is "Maybe a" a concrete type?
03:21:01 <zett_zelett1> Aaaaaaaah.
03:21:04 <zett_zelett1> Yeah, it makes sense.
03:21:18 <zett_zelett1> merjin: Maybe is not a concrete type, Maybe a is not a concrete type.
03:21:21 <merijn> I prefer talking about "types of kind *", "monomorphic types" or "polymorphic types"
03:21:35 <merijn> zett_zelett1: Some people disagree with you on those answers
03:21:50 <zett_zelett1> Maybe is a type constructor, and types are what you call types of kind *.
03:21:51 <zett_zelett1> Ok.
03:21:55 <merijn> zett_zelett1: Which is why I recommend avoiding the term, since it gets confusing when people use the same term but mean different things
03:22:03 <zett_zelett1> Hm.
03:22:53 <merijn> "Maybe" is a monomorphic type, but not of kind *, "Maybe a" is of kind *, but polymorphic, and "Maybe Int" is of kind * AND monomorphic. No ambiguities :)
03:23:23 <zett_zelett1> Still, I’m confused about that (snd . random) thing. Why doesn’t this check out type-wise again?
03:24:27 <merijn> :t snd . random
03:24:29 <lambdabot>     Could not deduce (Random a0) arising from a use of ‘random’
03:24:29 <lambdabot>     from the context (RandomGen c)
03:24:29 <lambdabot>       bound by the inferred type of it :: RandomGen c => c -> c
03:24:39 <merijn> oh, right
03:25:08 <zett_zelett1> And when did this get changed? I mean, learnyouahaskell defined randoms' without mentioning any *monomorphic* type.
03:26:09 <merijn> zett_zelett1: The only version of randoms' I see in LYAH has an explicit signature and then it works fine
03:26:23 <weyanus> https://www.irccloud.com/pastebin/mw8LtUL8/test
03:28:48 <zett_zelett1> Ok, compiling works. It doesn’t work if I put it in directy into ghci.
03:29:23 <zett_zelett1> http://lpaste.net/837609822055563264
03:29:50 <zett_zelett1> (Didn’t try compiling it before'.)
03:30:29 <merijn> zett_zelett1: hmmm, I'm not quite sure why ghci doesn't accept that...
03:32:05 <zett_zelett1> That’s where this question came from. I was trying to write up randoms' myself as an exercise, and it failed. Then I looked at what LYAH did just to see it did pretty much the same. Then I was stumped.
03:33:15 <pavonia> :t let randoms' gen = let (value, newGen) = random gen in value:randoms' newGen in randoms'
03:33:17 <lambdabot> (RandomGen t, Random a) => t -> [a]
03:33:17 <zett_zelett1> It never occurred to me that ghc would compile something that ghci wouldn’t accept.
03:33:20 <merijn> zett_zelett1: Could well be a bug, defining things in ghci is sometimes a bit odd, personally I tend to just write in files and load those into ghci
03:33:40 <zett_zelett1> Ok.
03:33:50 <zett_zelett1> Thanks for the help!
03:36:38 <Th30n> What's the easiest way to get a list of all field values of a record? Something like :t allFields :: DataRecord -> [FieldType]. Assuming all fields are the same type.
03:37:48 <Cale> Th30n: what sort of record?
03:38:12 <Th30n> My custom, e.g. data Record = Record { acc1 :: String, acc2 :: String .., accN :: String }
03:38:52 <Th30n> So far I've come up with map ($ record) [acc1, acc2, ..accN]. But is there a way without listing accessors?
03:39:11 <Cale> I suppose you could use generics if you have to do it a lot
03:39:47 <dramforever> You could have used some metaprogramming magic to do this, yes. But just, *why*?
03:40:15 <Th30n> It's just a thought exercise.
03:40:33 <weyanus> is anyone can help me to solve the problem?
03:40:45 <dramforever> oh that sounds reasonable
03:40:50 <Cale> syb has listify
03:42:13 <weyanus> in ghci
03:42:13 <weyanus> case 1:
03:42:13 <weyanus>  let zeros = 0 : zeros
03:42:13 <weyanus>  length zeros
03:42:13 <weyanus> case 2:
03:42:13 <weyanus>  length [1..]
03:42:13 <weyanus> case 1 can be terminated by ctrl + c, but case 2 can't. 
03:42:14 <weyanus> Does anyone know why ?
03:42:14 <weyanus> What's the difference between zeros and [1..] ?
03:44:08 <Cale> weyanus: Well, case 2 will be doing allocations
03:44:24 <Cale> But both should be possible to terminate with Ctrl-C... that's weird
03:44:43 <Cale> oh, interesting
03:45:00 <weyanus> Yes, amazing...
03:45:14 <Cale> Well, yeah, I guess it makes sense.
03:45:56 <Cale> It probably checks for signals like that when doing allocations. Really tight loops which don't allocate won't go through that check.
03:46:24 <Th30n> Try hitting Ctrl-C more times, it might get inside a signal check.
03:47:38 <weyanus> Useless for hitting ctrl-c more times.
03:49:43 <weyanus> Is length a tail recursion operator? Or something else?
03:50:32 <tenniscp25> Excuse me. My question didn't get answered. May I repeat my question?
03:51:03 <Cale> weyanus: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/src/GHC-List.html#length
03:51:10 <Cale> tenniscp25: sure
03:51:17 <tenniscp25> Thank you.
03:51:59 <dramforever> weyanus: ha! sending SIGINT to ghci every 0.1 sec revealed "<interactive>: lost signal due to full pipe: 2", so Cale is right about ignoring signals
03:52:26 <tenniscp25> How to unsubscribe a TChan created from a master with newBroadcastTChan? I think if I don't unsubscribe it from the master, it would cause memory leakage. Is that correct?
03:52:28 <Th30n> dramforever: Interesting
03:53:30 <Cale> tenniscp25: I'm not sure I understand the question
03:53:37 <weyanus> So, What's the difference between zeros and [1..] ?
03:54:43 <Cale> weyanus: zeros takes a small finite amount of space in memory
03:55:08 <Cale> weyanus: [1..] will only ever use a small amount of memory in this case, but new list cells will continue to be allocated
03:55:29 <Cale> zeros only has a single cons cell, whose tail pointer points back at the same list
03:56:10 <tenniscp25> I'm trying to write a websocket-to-serial-port server. For every websocket client, I will create a broadcast channel controlled by a "broadcaster" from a serial port to the client. When a client disconnects, I want to tell the "broadcaster" that it should no longer broadcast to that client.
04:00:18 <Cale> tenniscp25: You're worried about elements piling up when there are no clients left?
04:00:33 <weyanus> You mean zeros is so faster than [1..] for it dose not need to allocate memory? So the ghci is too busy to receive Ctrl-C signals?
04:00:33 <tenniscp25> Cale: yes
04:01:39 <joco42> is there a talk on type families somewhere? 
04:01:46 <tenniscp25> Cale: Maybe I shouldn't use TChan for this, should I?
04:04:30 <Cale> tenniscp25: Well, I don't know. Maybe a bounded channel would be better, or you could just have a TVar with the number of currently connected clients which you somehow maintain.
04:07:36 <tenniscp25> Cale: Thank you. I'll look into it.
04:11:04 <Cale> weyanus: Yeah, GHC's runtime checks for signals like the one sent by Ctrl-C at the same time as it does allocation of memory. So if you have a very tight loop which doesn't need to allocate any memory, it can result in signals not being handled.
04:11:46 <dramforever> Cale: can confirm by sending an insane number of SIGINT's to ghci =)
04:18:55 <weyanus> Cale: Thanks a lots!
04:20:30 <dramforever> Question: What's the fastest way to read an integer from stdin without using libraries[1]? I got "time limit exceeded" on spoj MKTHNUM, and profiling showed that 40% time is spent reading numbers. I'm currently using this hand-written integer reader[2].
04:20:40 <dramforever> [1] meaning that the code will be accepted by SPOJ
04:21:18 <dramforever> [2] http://lpaste.net/148090
04:25:18 <Cale> dramforever: I think SPOJ is also using a very old GHC and possibly not even compiling with optimisations turned on.
04:25:46 <dramforever> Cale: it's ghc 7.8, not too old, and as for optimisations, that's how competitive programming works, sorr
04:25:48 <dramforever> sorry
04:26:12 <Cale> Oh, they must have done something about it.
04:26:30 <dramforever> also I'm aware that there are a few discussions on the spoj forum, just came here to see if anyone has anything
04:26:34 <Cale> Sorry what do you mean "how competitive programming works"?
04:27:22 <dramforever> Cale: we compete programming skills to get the fastest program
04:27:42 <dramforever> so it kinda makes sense not to turn -O on
04:27:56 <Cale> If you compile without optimisations with GHC, your code will sometimes run asymptotically slower, and even when that's not the case, it will sometimes be orders of magnitude difference. The performance of code compiled without -O in GHC is meaningless.
04:29:07 <Cale> If it were a real world program, you wouldn't bother even trying to make the program faster without first compiling with -O2
04:29:09 <dramforever> sad...that's probably why it's uncommon to see people using functional languages for competitive programming
04:29:32 <Cale> Well, there's a solution: just turn on -O2
04:29:55 <Cale> Or better yet, let the programmer specify how the code is to be compiled
04:30:15 <dramforever> sigh...
04:31:35 <dramforever> btw an unrelated fun fact: "since 7.10, interface files leak information about one-shot lambdas", so -O or -O2 made my program asymptotically slower even *with* -fno-state-hack: https://ghc.haskell.org/trac/ghc/ticket/11271
04:32:31 <Cale> Yeah, that kind of thing can happen too, in the presence of compiler bugs :P
04:34:33 * hackagebot HPDF 1.4.9 - Generation of PDF documents  https://hackage.haskell.org/package/HPDF-1.4.9 (alpheccar)
04:35:24 <Cale> But yeah, more often, it's in the other direction: code which without optimisations will perform terribly, and which can't easily be improved by hand (short of low-level hackery), but which behaves in a sane and predictable way once optimisations are turned on.
04:35:46 <dramforever> Cale: yep, and thatlow-level hackery
04:36:16 <dramforever> sorry, that low-level hackery is what competitive programmers do, because the programs are not large
04:36:42 <dramforever> s/sorry/sorry for incomplete message/
04:37:06 <Cale> Except it's pretty pointless to compete at the part of it which the machine would be doing for you if you let it :P
04:38:48 <Cale> (and it's particularly damaging to Haskell programs, because it completely changes the nature of what would be an acceptable solution)
04:42:33 <dramforever> Cale: yeah, I'll probably go to complain later. There's actually a thread for that.
04:43:27 <Cale> dramforever: Also if you want to get things to perform well, you'll probably end up wanting to have access to at least ByteString, so I hope that's available.
04:43:45 <dramforever> I think so
04:44:11 <dramforever> btw thanks for all this discussion, whatever it's about =) at least it makes me happy
04:44:34 * hackagebot wai-routes 0.9.4 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.4 (AnupamJain)
04:44:34 <srhb> Surely gcc doesn't have optimizations turned off either.
04:47:15 <Th30n> I've been reading this lately: http://degoes.net/articles/modern-fp/ And for all the problems described there, ther are solved by creating an edsl via Free. Anyone got experience with using a solution like that in practice?
04:47:25 <Th30n> s/ther/they
04:47:28 <Cale> srhb: Yeah, I'm not 100% sure they're still turned off for Haskell either. When I actually tried SPOJ though (which was quite a while back), I'm pretty sure they were -- it was hard to know for certain.
04:51:06 <Cale> Th30n: Well, Free is one of a spectrum of approaches to constructing DSLs. I think the conclusions there seem a little overly positive, but it's certainly something that works.
04:51:56 <Th30n> Cale: What about other approaches to edsls? I have a hard time finding a use case for constructing an edsl (with perspective on ease of creating one vs direct solution).
04:52:33 <Cale> Th30n: You can also often get by with a type class specifying what the operations are, and then a bunch of implementations of that type class for the various interpretations.
04:52:42 <dramforever> WHOA, I just realized I could use {-# OPTIONS_GHC #-} !
04:52:48 <dramforever> Hey SPOJ you are really nice...
04:52:54 <Th30n> I wanted to construct edsl for creating vertex data for gpu, for example: data VertexExpr a expr = VertexData a expr | IndexData a expr
04:52:58 <Cale> dramforever: ah, that's lucky :)
04:53:06 <Th30n> But the problem was, VertexData a need not be always the same a
04:53:42 <Th30n> so I switched to GADTs and did VertexData :: Constraint a => a -> VertexExpr expr
04:53:52 <Th30n> which seems like an abuse of GADTs
04:54:27 <Th30n> and the Constraint is tied with what I expect in one particular interpreter variant...
04:54:28 <Cale> Using an existential like that also restricts the way that you can use the values when you pattern match them out again
04:55:16 <dramforever> nice, the program takes 30% less time now
04:56:34 <Th30n> Cale: Yes... Another solution I tried was wihout GADTs, was to create data constructors for each type of vertex data I want like so VertexData3f (Vector3 Float) expr | VertexData2f (Vector2 Float) expr ... but this kinda defeats the purpose of edsl - ease of use.
04:57:08 <Cale> Th30n: Apart from building a language of expressions as a datatype, you can also build a type class whose methods are effectively what the constructors of your datatype would be 
04:58:00 <Cale> and then write instances of the class for the interpretations of the language
04:58:07 <Th30n> Cale: Hmm, I'll have to try playing with that. Any papers/articles with more in depth information?
04:58:26 <Cale> http://okmij.org/ftp/tagless-final/JFP.pdf
04:58:46 <Cale> oh, that uses modules rather than type classes
04:58:47 <Cale> hm
04:59:09 <Th30n> Cale: Well, it's probably a good read. Might want to switch to ocaml :D
04:59:15 <Cale> heh
04:59:20 <Cale> Well, it's very similar in Haskell
05:01:49 <lamefun> "data Result p a = MkResult (Bool, Trace p a)" where "class Predicate p a where; data Trace p a :: *" -- how is this not a compiler error?
05:02:36 <Cale> why would it be?
05:03:18 <lamefun> because '(Trace p a)' does not exist for every 'p' and 'a'?
05:04:01 <Cale> Yeah, but you have to provide a value of type Trace p a in order to apply MkResult
05:05:16 <Cale> (but also note that Trace p a will be inhabited by at least undefined for every p and a)
05:06:02 <Cale> It's not a kind error to apply Trace to some type which is not an instance of Predicate -- it's just expected that you won't be able to construct a defined value of the resulting type
05:06:45 <Cale> (until such an instance becomes available -- it may become available in a future module)
05:07:47 <Cale> I can write a function of type  Trace Bool String -> String  for example, even if there is not yet an instance of Predicate Bool String, and some future module might come along and define one, at which point my function would become usable.
05:08:27 <Cale> (then again, without the instance being in scope, and with no additional class methods, my function might necessarily be boring)
05:09:07 <Cale> e.g. it might have to be a constant function, if I really have no other information about what I can do with a Trace Bool String
05:33:36 <dramforever> Ok, so I used (strict) bytestrings and the readInt bundled with it. Much faster now, but still TLE...
05:33:51 <dramforever> Guess that's it, I'm complaining
05:35:55 <roelof> Hello, I have this code but I see a lot of type problem (http://lpaste.net/148092) 
05:36:37 <roelof> First one is that take wants to have a int where zipwith wants a Integer : How to solve this ? 
05:37:36 <cocreature> roelof: tail fibs doesn’t make sense, it’s a function
05:37:56 <cocreature> you need to separate the take from the declaration of fib
05:38:42 <roelof> cocreature:  I found the fib function on the Haskell wiki page as fastest one 
05:39:13 <roelof> cocreature:  oke, I will look how I can seperate the take 
05:39:38 <cocreature> roelof: that doesn’t change the fact that your code is broken. you somehow mixed the actual definition of an infinite list of fibonacci numbers with a take
05:40:04 <cocreature> roelof: you can just put the infinite list in a where/let and call it fib’ or something like that and then call take on that infinite list
05:40:34 <roelof> moment, not so fast. fib is now fibs n =  0 : 1 : zipWith (+) fibs (tail fibs) 
05:40:42 <roelof> as the orginal 
05:40:57 <cocreature> that looks correct
05:41:27 <Xandaros> 8...after you remove the 'n' before the equals sign
05:41:51 <cocreature> ah ofc, I missed that
05:42:38 <roelof> cocreature:  this is what you mean with the fib function : http://lpaste.net/148092
05:44:05 <MarcelineVQ> almost, the zipWith should be using fiblist not fibs
05:45:05 <roelof> oke, like this :  where fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist)
05:45:11 <cocreature> yeah after applying MarcelineVQ comment it should be correct
05:45:16 <MarcelineVQ> fiblist is recursively calling itself to generate a list, the take just requests a certain number of items from that list.
05:46:15 <roelof> correct. this function looks it's given me no error messages anymore 
05:47:20 <roelof> sorry: still a error : Couldn't match expected type ‘Int’ with actual type ‘Integer’  In the first argument of ‘take’, namely ‘n’
05:47:42 <roelof> Schould I change my type definition to Int -> [Int] then ? 
05:48:02 <Xandaros> Int -> [Integer] will work, as well
05:48:27 <cocreature> alternatively you can throw in some fromIntegral or use genericTake from Data.List
05:49:30 <Xandaros> fromIntegral to convert an Integer to an Int sounds like a terrible idea
05:50:24 <roelof> Thanks, Now still these problems : http://lpaste.net/148094
05:50:34 <dramforever> Question: Any idea why StateT can be slow?
05:51:19 <dramforever> It's taking 30% "individual time" now, according to profiling
05:51:21 <Xandaros> roelof: At least the second error you should be able to figure out ;)
05:52:42 <roelof> Xandaros:  second one also solved the same way I solve the problem on the first function 
05:52:51 <roelof> 1 problem to go 
05:52:51 <Xandaros> yup
05:53:34 <Xandaros> btw, I don't like how you shadow 'n' there. I suggest you rename the "inner" one
05:54:35 <roelof> Xandaros:  I have renamed the x 
05:56:18 <Xandaros> Alright. Look at the remaining error message - what does it mean?
05:56:30 <roelof> Xandaros:  I do not understand why the code says that a element of the zip function is a [char] 
05:57:12 <roelof>  zip [ 1 ..] (fibs n) output looks like this [ ( 1, 1) ( 2,2) (2,3) ]  
05:57:33 <Xandaros> Yes, but that is not what it is complaining about
05:57:40 <Xandaros> it's the expression in your list comprehension
05:57:48 <Xandaros> (Left of the '|')
05:57:55 <roelof> oke , the show part 
05:58:03 <Xandaros> What type does it have?
05:58:41 <goodwish1> :)
05:58:51 <roelof> x is a integer, show x schould make a string of it  with I want to join with a newline 
05:59:08 <roelof> chips, a string is a list of characters 
05:59:37 <Xandaros> Yes. But let's glance over that for a moment. There is a deeper problem here, not reflected by the error message
05:59:55 <Xandaros> You have a string in the expression of your list comprehension. What type does the whole list comprehension have?
06:00:53 <roelof> Xandaros:  you mean a list , List comprehension takes and returns a list 
06:01:01 <Xandaros> A list of what?
06:01:28 <roelof> I try to make a list of strings 
06:01:42 <Xandaros> Exactly. It's a list of strings
06:01:50 <Xandaros> Now look at your type signature :)
06:02:38 <roelof> yes, I see it and changed it, The type signature was of the whole solution where I try to work to 
06:03:40 <Xandaros> So, either your signature is wrong or your definition. Do you want it to be a single string?
06:06:01 <roelof> No, it can be a lot of strings. I try to work to a output like this :  http://lpaste.net/148095
06:07:03 <Xandaros> Well, guess you just need to fix the signature, then
06:10:18 <dramforever> ah, never mind, it's a costly inlined function
06:10:23 <Zakkor> hey guys, quick question: how can i use partial application instead of a lambda in this : filter (\x -> x `rem` 2 == 0) $ map (^2) [0, 3 .. 20]
06:10:36 <Zakkor> side note: without using odd
06:11:10 <dutchie> :t (== 0) . (`rem` 2)
06:11:12 <lambdabot> Integral b => b -> Bool
06:11:34 <Zakkor> thanks
06:11:38 <maerwald> Zakkor: please stick to the lambda, there's no reason to make it pointfree except for making it harder to understand
06:12:02 <Erebe_> filter ((== 0) . (`rem` 2)) . fmap (^2)
06:12:05 <dramforever> maerwald: "without using odd" makes it sounds like Zakkor's doing it on purpose somehow
06:12:06 <dutchie> or just define another function
06:12:21 <dutchie> (namely "odd", i suppose)
06:12:30 <dutchie> er, "even"
06:12:30 <roelof> Xandaros:  this is doing the job : fibTable n = concat [ (pushRight (show x)) ++ (pushRight (show y)) ++  "\n" | (x,y) <- zip [ 1 ..] (fibs n) ] 
06:12:45 <roelof> Now I have to find out how to make the header work 
06:13:05 <Xandaros> roelof: I was going to suggest concat, had you said you wanted it to be a single string :P
06:13:07 <Zakkor> maerwald: yeah, normally i would, but i was trying to figure out how to make it pointfree for learning purposes :D
06:14:10 <dutchie> Zakkor: to see more easily how to partially apply infix functions, first take them into prefix notation
06:14:12 <roelof> Xandaros:  thanks, that one I knew already. The problem was to make the right string 
06:14:48 <Xandaros> roelof: btw, instead of appending "\n" and using concat, you can also use unlines.
06:15:24 <dutchie> \x -> x `rem` 2 == 0 ~~~> \x -> (==) 0 (x `rem` 2) ~~~> \x -> (==) 0 (rem x 2)
06:15:25 <roelof> any suggestions how I can make a header above it , Or schould fibTable have 2 parts. One for the header and one we already have for the table itself 
06:15:42 <dutchie> and then the composition is more obvious
06:16:10 <dutchie> and you can switch back to section syntax to make it look nicer
06:16:45 <Xandaros> roelof: Try to keep your definitions as short as possible. It makes them easier to read. So have one for the header, one for the body and one to combine them
06:17:11 <Xandaros> (within reason, of course)
06:18:04 <Zakkor> (rem 2) would be rem 2 x, while (`rem` 2) would be x `rem ` 2, right?
06:18:12 <roelof> Xandaros:  thanks, I think I have a idea
06:18:59 <dutchie> Zakkor: yup
06:19:53 <dutchie> (strictly speaking (rem 2) === \x -> rem 2 x, but i think you know that and are just being lazy about typing)
06:20:08 <dutchie> (if you'll pardon the pun :p)
06:34:03 <Zakkor> why is it called pointsfree btw?
06:34:13 <c_wraith> it's a term from topology
06:34:23 <c_wraith> I'm not quite sure how it got applied to programming.
06:34:59 <c_wraith> point-free topology is topology that never mentions points in whatever you're studying.
06:35:20 <c_wraith> I suppose it's not a stretch to say that sounds a lot like never naming variables.
06:47:14 <roelof>  what do you experts think of this solution  : http://lpaste.net/148098 
07:00:25 <homovitruvius> w/ stack I get 'Hpc failure: module mismatch with .tix/.mix file hash number
07:00:25 <homovitruvius> (perhaps remove tests.tix file?)' when I run 'stack test'. If I remove the .tix files I'm good for one run. What is the problem? I thought stack would automatically do the appropriate 'cabal config'
07:02:00 <roelof> homovitruvius:  correct , that is a well know problem. You have to do stack clean for every time you do stack test --coverage 
07:03:37 <roelof> homovitruvius:  see this error report : https://github.com/commercialhaskell/stack/issues/222
07:04:39 * hackagebot adblock2privoxy 1.4.1 - Convert adblock config files to privoxy format  https://hackage.haskell.org/package/adblock2privoxy-1.4.1 (zubr)
07:06:28 <homovitruvius> roelof: thx for the pointer to the bug report
07:07:21 <roelof> homovitruvius:  YW 
07:10:33 <roelof> No one who can give feedback on my code
07:18:31 <Gurkenglas> roelof, exercise 24 seems to imply that you don't need to worry about input strings longer than 12
07:20:03 <roelof> Gurkenglas:  oke, I did this because someone said yesterday on this channel. that it is common to make functions which works on every lists (empty, infinitive)
07:20:16 <roelof> That is why I made this one 
07:20:24 <Gurkenglas> Yours diverges on infinite lists
07:20:38 <roelof> diverges ?? 
07:20:39 <Gurkenglas> wait nvm doesnt soz
07:20:50 <Gurkenglas> diverge = not halt
07:22:04 <roelof> Gurkenglas:  oke, thanks for the feedback 
07:22:06 <Gurkenglas> roelof, are these the complete texts of your assignments? I would assume fibTable is supposed to make a table with rows 1..n. Also it's not supposed to print it, just a String
07:24:17 <roelof> Gurkenglas:  here again the whole text : http://lpaste.net/
07:24:28 <Gurkenglas> Wrong link
07:26:15 <roelof> Gurkenglas:  here again : http://lpaste.net/148103
07:39:28 <roelof> Gurkenglas:  Schould I change my code or is it allright ? 
07:46:55 <Zakkor> Any idea why F#-ers tend to use the pipe forward operator '|>', while Haskellers tend to use '$' instead?
07:49:48 <chelfi> Might be because of evaluation order
07:50:29 <OutlawStar> whats currently the best way to view memory profiles?
07:51:00 <Zakkor> would you find code like this hard to read? http://lpaste.net/148104
07:51:01 <OutlawStar> wiki has ghostviewer, but that looks a little old
07:51:27 <chelfi> in strict languages your argument will most likely be evaluated sequentially across calls so it makes sense to reflect it syntaxically
07:51:37 <roelof> Gurkenglas:  this better : http://lpaste.net/148098
07:51:41 <bergmark> Zakkor: it reads backwards from what most people are used to
07:56:56 <Gurkenglas> Looks right
07:58:32 <roelof> thanks, this one was difficult. Needed everything I have learned. Lists , tuples , strings 
07:59:23 <geekosaur> Zakkor, it's kinda a false comparison because $ is a way to omit parentheses; F#'s |> is more like Haskell's >>=
08:01:07 <roelof> Gurkenglas:  thanks, then I can this evening or tomorrow finisch this chapter. There are only a few exercises of a book library 
08:02:43 <Zakkor> geekosaur: well F#'s |> is exactly like haskell's & from Data.Function
08:03:51 <geekosaur> I wouldn't say exactly like. although we're getting into semantic distinctions there since F# is impure so the distinction between >>= and & doesn't exist
08:04:12 <geekosaur> whereas in Haskell it matters
08:06:15 <NemesisD> hey folks, I was reading this post about van Laarhoven free monads http://r6.ca/blog/20140210T181244Z.html i was wondering if you could combine it with classy lenses, getting this error http://lpaste.net/148107
08:07:12 <NemesisD> i could (and probably am) doing this all wrong, but the post left most of the implementation as an exercise for the reader and i've had trouble finding more information about this approach to free monads
08:08:51 <csd_> if i'm defining data = Two | Three ... King | Ace -- how can i most easily make this an instance of Ord?
08:09:14 <NemesisD> csd_: deriving (Ord)
08:09:29 <csd_> NemesisD: i know but i mean to specify the relations
08:10:16 <NemesisD> the easiest way is honestly to put the constructors in the ADT in their natural order. defining Ord is pretty tedious
08:10:31 <chelfi> csd_: by default the order will be the order in which you list the constructors
08:10:51 <csd_> i see
08:10:55 <NemesisD> actually it would be interesting to see what code gets generated from the deriving
08:11:16 <csd_> and i imagine that if i have data Card = Suit Value that i do then need to write the compare function?
08:11:50 <mnoonan> You could also leverage some other Ord instance by using an order-preserving function,
08:11:52 <geekosaur> huh?
08:12:24 <chelfi> IIRC it will pick a "sensible" order: if you have two different Suit it would compare the values (if they have an Ord instance defined)
08:12:30 <mnoonan> e.g. pokerValue :: Value -> Int, pokerValue Two = 2, ... pokerValue Jack = 11, ...
08:12:48 <mnoonan> and then instance Ord Value where x < y = pokerValue x < pokerValue y
08:13:10 <csd_> chelfi: nah ghc was complaining to me about it
08:13:10 <mnoonan> (but really, just derive Ord :)
08:13:36 <csd_> wanted me to have derived Ord on Suit which doesnt make sense
08:14:22 <chelfi> for instance if you have data Card = Two Int | Three Int then Two _ is less than Three _, and if you have Two x and Two y it is equivalent to comparing x and y
08:14:41 * hackagebot ffmpeg-light 0.10.0 - Minimal bindings to the FFmpeg library.  https://hackage.haskell.org/package/ffmpeg-light-0.10.0 (AnthonyCowley)
08:16:07 <geekosaur> assuming you meant data Card = Card Suit Value, if you want Ord Card to only reference the Value then yes, you would have to write the instance yourself. but I'm not sure you want Ord in that case
08:16:33 <csd_> hm ok
08:16:35 <geekosaur> because that's not a proper mathematical ordering and various things assume that Ord is
08:16:39 <hsk3> In OO languages, you have thing.doSomething(). No such thing in Haskell. You have to define stand-alone functions. doSomething(thing). This makes the function more "global", not something that acts on a thing, and so it's more likely that two function names will conflict. Why is this not a problem?
08:17:20 <geekosaur> in particular, your Ord would say that Card Heart 2 and Card Spade 2 are equal, yet Card Heart 2 /= Card Spade 2
08:17:44 <mauke> hsk3: modules
08:17:44 <csd_> i guess i should just look down into the value then
08:17:47 <geekosaur> but Ord assumes that cannot happen
08:20:11 <csd_> with type Deck = [Card] is there any way to specify a list of 52 Cards? and similarly that type Hand = [Card] of N Cards ?
08:20:17 <geekosaur> hsk3, if you *must* conflate things like that, you an use typeclasses. but it's only "a problem" if you insist on thinking of Haskell code with an OO mindset
08:20:40 <hsk3> yeah
08:20:44 <hsk3> modules are the key i guess
08:20:45 <geekosaur> csd_, maybe you want to derive Enum
08:20:49 <geekosaur> and Bounded
08:21:03 <geekosaur> [minBound .. maxBound] :: Deck
08:25:15 <csd_> geekosaur: i'd then have to change how i'm defining Card, right?
08:25:46 <geekosaur> huh?
08:26:06 <geekosaur> to the extent that you add deriving of Enum and Bounded, yes
08:26:20 <csd_> hrm ok
08:28:01 <csd_> this is my first go at writing a program in haskell
08:31:53 <lamefun> Is there a library for easy newtyping (with instance forwarding like FromJSON)?
08:40:12 * hackagebot cabal-macosx 0.2.3.3 - Cabal support for creating Mac OSX application bundles.  https://hackage.haskell.org/package/cabal-macosx-0.2.3.3 (dfrancesconi)
08:40:17 <aweinstock> lamefun: GeneralizedNewtypeDeriving is probably what you're looking for
08:41:02 <aweinstock> put {-# LANGUAGE GeneralizedNewtypeDeriving #-} at the top of the file, and then you can do: newtype Foo = Bar deriving FromJSON -- (if Bar is already FromJSON)
08:59:17 <Smoke_Max> Hey there. Is this the right place to ask stupid questions about the Snap framework?
09:00:15 <ivxr> probably as good as any
09:00:23 <ivxr> i use yesod personally though
09:01:18 <imalsogreg_> Smoke_Max, Sure, go ahead. There is also the #snapframework channel if noone here can help you.
09:02:29 <Smoke_Max> It's just a dumb question. Basically if I have a login page or a new user form, then the password field (in a post form) is sent to the server as clear text, right?
09:02:44 <Smoke_Max> Then Snap does its hashing + salting and checks if it's okay.
09:02:47 <Smoke_Max> Right?
09:03:01 <imalsogreg_> Yep.
09:03:32 <Smoke_Max> Is there any way I can do this processing before sending it to the server? It makes me a bit uneasy to send it in the clear.
09:03:37 <StoneToad> Smoke_Max: assume it's http, if it's https then the whole connection is encrypted
09:03:42 <StoneToad> assuming*
09:05:05 <imalsogreg_> Smoke_Max, I'm not aware of encrypting that kind of thing client side before sending. The usual way to hide the password would be through https.
09:05:18 <Smoke_Max> I thought about HTTPS, but I couldn't find anything about it with Snap on Google, maybe I missed something?
09:05:58 <StoneToad> I don't see any *technical* reason why you couldn't implement some zero-knowledge password system in javascript on the client though
09:06:23 <bam365> Smoke_Max: pretty sure Snap supports HTTPS
09:06:40 <imalsogreg_> Smoke_Max, snap can be compiled with a flag to cabal to run in https. Or you can put your snap server behind nginx.
09:06:41 <bam365> look at Snap.Http.Server.Config
09:09:15 <Smoke_Max> Oh, I don't know anything about this SSL certificate stuff. I assume this is what I need to set to allow HTTPS?
09:10:00 <bam365> Smoke_Max: yes, HTTPS works by using a certificate to encrypt traffic and verify endpoints
09:10:15 <bam365> I think thanks to Let's Encrypt you can now get trusted certs for free? Is that right?
09:10:57 <imalsogreg_> Yah, the certificates thing takes some research, and money :/  I haven't tried let's encrypt but from the blog posts it seems extremely promising.
09:11:58 <Smoke_Max> Oh, that's pretty cool. Realistically, this website I'm working on is going to have 3 or 4 users maximum who'll be logging once in a blue moon to post things (think like a blog or such).
09:12:12 <Smoke_Max> Maybe it's not worth the effort to chase this HTTPS certificate?
09:12:51 <matrium> hey, I'm currently working through "Learn You A Haskell" and in the chapter about monads, the -: function is introduces, but my ghci doesn't know it and I can't find any documentation about it
09:13:20 <bam365> Smoke_Max: that's your call :) I personally have done similar servers and have not bothered with HTTPS...
09:14:17 <Smoke_Max> Alright, I'll keep working on it. I'll come back with more stupid questions if they show up. Thanks guys.
09:14:31 <aweinstock> StoneToad: the main reason not to do the crypto client-side in JS is that it doesn't prevent any attacks
09:15:11 <aweinstock> if it's http, anyone who can MITM can just replace the JS with their own backdoored version
09:15:31 <StoneToad> the only attack you'd save was having someone read the password on the server I think
09:16:23 <StoneToad> that said, there are so many other attack vectors...
09:16:26 <aweinstock> if you can't trust the server to hash+salt properly, why can you trust the server to serve correct JS crypto?
09:17:35 <StoneToad> ah yea, not like there's any browser support for signed pages...
09:18:02 <aweinstock> https://hackage.haskell.org/package/snap-server-0.4.3/docs/Snap-Http-Server-Config.html#t:ConfigListen
09:18:28 <aweinstock> looks like there's a config constructor for snap that takes paths to keys to use for HTTPS
09:19:41 <aweinstock> Smoke_Max: use HTTPS to protect the data in transit
09:23:40 <nanoz> vello
09:23:48 <nanoz> is haskell into main stream
09:23:57 <StoneToad> what does that even mean?
09:24:07 <monochrom> yes
09:25:22 <nanoz> well i been sort of working FP for a little time never seen haskell coming to picture (yea it depends on what type of project) 
09:25:57 <monochrom> there are two kinds of questions. one kind satisfies "if you have to ask, you are not ready to know". another kind satisfies "if you know to ask, the answer is yes". that question is the second kind.
09:35:14 * hackagebot HueAPI 0.2.6 - API for controlling Philips Hue lights  https://hackage.haskell.org/package/HueAPI-0.2.6 (SjoerdVisscher)
09:53:38 <roelof> is this a good solution :http://lpaste.net/148109 
09:57:49 <ReinH> aweinstock: see http://programmers.stackexchange.com/questions/76939/why-almost-no-webpages-hash-passwords-in-the-client-before-submitting-and-hashi/77069#77069 ;)
09:59:48 <tryam> Hello!
10:00:21 <ReinH> roelof: I don't see a solution. I see some comments.
10:00:28 <tryam> Is it possible to define cabal test-suite with test files in non-top level directory
10:00:31 <tryam> ?
10:02:11 <ReinH> tryam: use hs-source-dirs
10:02:52 <ReinH> roelof: it's also impossible to tell if something is a solution without knowing what the problem is.
10:03:58 <tryam> ReinH: I have "hs-source-dirs: tests" there
10:04:20 <tryam> and I want to have some subdirectories in tests with different tests
10:04:26 <tryam> is it possible?
10:04:32 <joco42> can i pattern match on functions ? stg like fun2int:: Num a=>(a->a)->Int
10:04:39 <ReinH> tryam: sure, just make sure they are imported into your main test file
10:04:46 <ReinH> joco42: no
10:04:49 <joco42> then fun2int (+)= 2
10:04:53 <joco42> ohh
10:05:01 <ReinH> functions are opaque
10:05:32 <joco42> i am asking this because this seems to be possible on the type level... with type families
10:05:33 <tryam> most of tests on github just put all test files right in the directory defined by hs-source-dirs
10:06:12 <ReinH> joco42: would you want fun2int (+) and fun2int (\x y -> x + y) and 9
10:06:14 <ReinH> x er
10:06:14 <joco42> as described in the first example here:http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
10:06:30 <joco42> hmm..  
10:06:41 <joco42> they are the same functions
10:06:43 <ReinH> and (\x y -> x + y + 100 - 100) and every other equivalent function to match?
10:06:48 <joco42> ahh
10:06:51 <ReinH> There are an infinite number of such functions
10:06:58 <joco42> right 
10:07:36 <tryam> ReinH
10:07:37 <tryam> ReinH: but can the main test file be in some subdirectiry of test?
10:08:10 <tryam> ReinH: like when you define library
10:08:12 <ReinH> tryam: you can change main_is iirc
10:08:22 <ReinH> er main-is
10:09:16 <jay6981> anyone with a mac know how to get your numeric keypad to work right in ghci/vi?
10:09:17 <joco42> on page 3 in that paper
10:09:43 <joco42> type Ref IO = IORef
10:10:14 <joco42> is a type level pattern match on the *->* type level function
10:10:15 * hackagebot one-liner 0.5.2 - Constraint-based generics  https://hackage.haskell.org/package/one-liner-0.5.2 (SjoerdVisscher)
10:10:22 <joco42> at least so it seems
10:10:42 <joco42> so i got a little bit ... astonished how is that possible
10:11:08 <tryam> ReinH: if I change main_is to the subdir path, cabal complains: cabal: Error: Could not find test program dist/build/AllTests/AllTests. Did you build the package first?
10:11:12 <ReinH> it's just a type synonym
10:11:59 <ReinH> it just replaces Ref m a with IORef a in the IO instance.
10:12:12 <ReinH> just like if you said type Ref = IORef
10:12:36 <joco42> i need to think about this for a sec
10:13:37 <ratnikov> ReinH, howdy. Your nick seems familiar ;)
10:13:41 <ReinH> tryam: what did you change main-is to?
10:13:45 <ReinH> ratnikov: hi
10:14:06 <joco42> type Ref = IORef ? 
10:14:10 <ReinH> If hs-source-dirs: foo and your test file is foo/bar/Bazz.hs
10:14:17 <tryam> RainH: to the subdirectory relative to the tests, where the AllTests.hs is
10:14:19 <ReinH> then main-is: bar/Bazz/hs
10:14:29 <ReinH> er main-is: bar/Bazz.hs
10:14:31 <tryam> Yes, like that
10:14:37 <ReinH> it should be the path of the file itself
10:14:43 <ReinH> not the subdirectory
10:14:45 <joco42> isn't Ref:*->*->*?
10:14:49 <ReinH> relative to hs-source-dirs
10:14:56 <ratnikov> ReinH, anyhow, just wanted to say hi since saw you on my gf's IRC channel. :) I guess no more #rubyonrails for either of us ;)
10:15:05 <joco42> and IORef :: *->*
10:15:06 <ReinH> ratnikov: :)
10:15:15 * hackagebot unfoldable 0.8.3 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.8.3 (SjoerdVisscher)
10:15:20 <roelof> ReinH:  I have to put the calculations in comments because it's not real code 
10:15:23 <ReinH> joco42: Ref :: * -> * -> *, Ref IO :: * -> *
10:15:35 <ReinH> roelof: everything is in comments
10:16:02 <roelof> yes, so ghci do not try to evalute it  
10:16:22 <ReinH> roelof: then there is no solution
10:16:27 <ReinH> only comments
10:16:31 <roelof> as far as I understand I have to write it down how ghci evalute things 
10:16:39 <ReinH> roelof: I don't know what the problem is
10:16:44 <ReinH> how can I tell you if you have a solution
10:17:08 <roelof> oke, then I have to reprase it. 
10:17:16 <ReinH> That doesn't look anything like how ghc would evaluatite something
10:17:41 <ReinH> *evaluate
10:17:48 <roelof> oke,  then I do not know how I can ask better 
10:17:50 <joco42> page 3 actually says that Ref is a type function... 
10:18:01 <roelof> forget my question 
10:18:32 <joco42> kinda confusing
10:18:39 <msloma> top
10:18:40 <niko> .55
10:20:37 <ReinH> joco42: sure, "type function" is a reasonable thing to call Ref
10:20:43 <ReinH> and Maybe
10:21:44 <joco42> yeah, but Ref takes a function as argument and "looks" as if it pattern matches on it
10:21:56 <joco42> it appears so at least
10:22:22 <ReinH> Ref does not take a function as an argument
10:22:25 <ReinH> it takes a type as an argument
10:22:25 <joco42> type Ref IO= IORef
10:22:28 <tryam> ReinH: Aha! So the actual problem was that the module name *in* the test file was not Main.
10:22:31 <joco42> ahh
10:22:44 <ReinH> Ref is a function from types to types
10:22:45 <joco42> a type level function
10:22:49 <ReinH> Yes.
10:23:06 <joco42> but takes an IO for example
10:23:12 <ReinH> IO is a type.
10:23:16 <joco42> which is another type level function
10:23:25 <joco42> or not ?
10:23:26 <ReinH> Actually Ref :: (* -> *) -> * -> *
10:23:40 <ReinH> since
10:23:42 <ReinH> :k IO
10:23:43 <lambdabot> * -> *
10:23:55 <joco42> yeah
10:24:08 <joco42> this is a little confusing
10:24:20 <joco42> both IO and Ref are functions 
10:24:23 <joco42> and types
10:24:33 <ReinH> But are type functions
10:24:45 <ReinH> You'll only confuse things more if you call them functions
10:24:51 <joco42> and take different kinded arguments
10:25:08 <joco42> it is SPJ who calls them functions
10:25:22 <csd_> How do I write a function with a guard where the guard conditions bind variables and makes sure they aren't Nothing to continue?
10:25:25 <ReinH> he calls them type functions
10:25:33 <joco42> ahh
10:25:48 <ReinH> csd_: You want either view patterns or pattern guards
10:25:49 <joco42> ok, so type functions are different from functions... 
10:25:58 <joco42> they are somehow special
10:25:58 <ReinH> yes
10:26:07 <joco42> ok
10:26:07 <ReinH> they are at the type level 
10:26:09 <csd_> ReinH: thx
10:26:10 <MarcelineVQ> csd_: use a case expression or pattern guards https://wiki.haskell.org/Pattern_guard
10:26:11 <ReinH> functions are at the value level
10:26:12 <joco42> fair enough
10:26:19 <joco42> hmm
10:26:20 <MarcelineVQ> oop you said it already ReinH :>
10:26:20 <joco42> ok
10:26:27 <joco42> interesting
10:27:09 <joco42> i keed them separated then in my mind 
10:27:12 <joco42> thanks
10:30:17 <aweinstock> ReinH: regarding non-HTTPS client-side crypto, it looks like you linked the same sort of advice that I gave. Am I missing some nuance?
10:36:03 <zett_zelett> :t it
10:36:04 <lambdabot>     Not in scope: ‘it’
10:36:04 <lambdabot>     Perhaps you meant one of these:
10:36:04 <lambdabot>       ‘id’ (imported from Data.Function),
10:38:30 <zett_zelett> > let r = randoms $ mkStdGen 0
10:38:31 <lambdabot>  <no location info>:
10:38:31 <lambdabot>      not an expression: ‘let r = randoms $ mkStdGen 0’
10:38:45 <roelof> is it correct that this will not hold :  http://lpaste.net/148110  because bk could be equal to bk2 ? 
10:39:04 <aweinstock> > let r = randoms $ mkStdGen 0 in r
10:39:06 <lambdabot>  [9106162675347844341,-5782012937088350469,3531325756418318423,-5618565702727...
10:39:13 <zett_zelett> :t it
10:39:14 <lambdabot>     Not in scope: ‘it’
10:39:14 <lambdabot>     Perhaps you meant one of these:
10:39:14 <lambdabot>       ‘id’ (imported from Data.Function),
10:39:27 <aweinstock> zett_zelett: lambdabot isn't exactly ghci
10:39:28 <zett_zelett> Hm, why does my ghci create an ‘it’ if I do that?
10:39:58 <aweinstock> that's a ghci-specific feature for referring to the result of the last expression
10:40:19 <indiagreen> how come https://github.com/haskell/cabal/issues/1764 has been merged more than a year ago but cabal check still exits with a non-zero status when -O2 was specified?
10:42:40 <ReinH> aweinstock: I gave that advice a few years ago :)
10:47:42 <aweinstock> ReinH: ah, I didn't make the connection with the username
11:18:44 <Jinxit> is it possible to return a Lens' from State?
11:22:47 <ReinH> Jinxit: can you give an example?
11:23:48 <Jinxit> ReinH: http://lpaste.net/4782907187489931264
11:24:39 <ReinH> Jinxit: ok, and what do you want to do?
11:24:49 <Jinxit> I want it to compile :)
11:24:55 <Jinxit> hold on
11:24:58 <ReinH> Jinxit: why not write a currentPlayer Getter that selects p1 or p2 depending on turn?
11:25:43 <Jinxit> that is what it is?
11:25:49 <ReinH> no it isn't?
11:25:55 <Jinxit> except I want to be able to Set as well
11:26:05 <ReinH> ok
11:26:14 <Jinxit> I added the error
11:26:48 <indiagreen> you can use ALens' instead of Lens' and it would work, but I don't see why ReinH's solution wouldn't work for Lens as well
11:26:56 <ReinH> it would
11:27:03 <ReinH> There's nothing specific to State
11:27:21 <ReinH> you can just select p1 or p2 depending on turn
11:27:24 <monochrom> what is the type of p1?
11:27:47 <ReinH> :t (_1)
11:27:49 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
11:28:29 <Jinxit> so you want something like Int -> Getter Game Player?
11:28:34 <ReinH> presumably Functor f => (Player -> f Player) -> Game -> f Game
11:28:45 <ReinH> Jinxit: I want currentPlayer :: Lens' Game Player
11:29:05 <ReinH> :t lens
11:29:06 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
11:29:17 <ReinH> currentPlayer f = (
11:29:19 <ReinH> :(
11:29:52 <monochrom> ok, something is having type "(Game -> b0 -> t0) -> (Player -> f0 b0) -> Game -> f0 t0", which is one more parameter than expected
11:30:39 <Jinxit> ReinH: and how do I extract the current turn inside that?
11:32:53 <indiagreen> Jinxit: http://lpaste.net/148116
11:34:11 <indiagreen> Jinxit: (to understand how it works, you would have to understand the Lens' type synonym)
11:34:11 <ReinH> Jinxit: you select a lens based on current turn
11:34:31 <ReinH> If you were to write it using the ``lens'' constructor, it might be
11:34:36 <Jinxit> oh I see
11:34:50 <ReinH> http://lpaste.net/626385430677291008
11:34:57 <ReinH> but indiagreen's is the idiomatic way to write it
11:35:40 <indiagreen> and ReinH's is more understandable, I guess (to be honest, I forgot about `lens` completely)
11:36:36 <ReinH> indiagreen: I don't like mine, but at least it's explicit
11:37:07 <ReinH> I want to emphasize that using an Int to mark the current player is a bad idea
11:37:19 <ReinH> you should use your own sum type
11:37:29 <ReinH> data Turn = Player1Turn | Player2Turn or w/e
11:38:00 <Jinxit> true
11:38:01 <ReinH> A 2-player game has 2 players, not |Int|-many players.
11:38:22 <Jinxit> yeah
11:38:35 <Jinxit> I'm just recently switching from [Player] to explicitly having 2 players
11:39:03 <ReinH> You can also represnt it as data Game = Game { currentPlayer :: Player, otherPlayer :: Player } and then make sure they are swapped as necessary when a turn takes place
11:39:45 <ReinH> then you don't need an extra field to keep track
11:39:52 <monochrom> neat
11:39:58 <ReinH> this is because 2 -> x is isomorphic to (x,x)
11:40:22 <ReinH> representable functors ftw
11:40:37 <johnw> \o/
11:40:42 <Jinxit> but then you can't reuse the lens to p1 from the outside
11:41:14 <ReinH> you can, but it means current player now, not player 1.
11:41:22 <monochrom> in fact, at this point, we have pretty much eliminated the need for lens.
11:41:54 <ReinH> And you do lose information in this version: you lose which player is p1 and p2
11:42:06 <ReinH> because 2 -> x is not isomorphic to (x,x,2)
11:42:18 <ReinH> so that's a good point
11:43:38 <kadoban> The Player could know itself though, in fact usually you come up with some user-editable way to refer to players anyway, and/or there's some part of the game itself that suggests a name, like 'black' and 'white', etc., that you'd probably have to know anyway.
11:45:47 <ReinH> but it is pleasing that the algebra of data types is such that 2^x = x*x is meaningful and correct.
11:46:15 <monochrom> um, it's x^2, not 2^x
11:46:23 <ReinH> monochrom: uh, yeah, stupid
11:46:25 <ReinH> sorry
11:46:51 <monochrom> it's one reason I hate x^y for y->x
11:47:05 <monochrom> until I saw BIrd etc wrote x<-y
11:48:19 <ReinH> yeah
11:48:32 <ReinH> but then he perversely also flips composition
11:49:27 <monochrom> no, I think he didn't. it's still "(g :: C <- B) . (f :: B <- A)"
11:50:17 * hackagebot skein 1.0.9.4 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  https://hackage.haskell.org/package/skein-1.0.9.4 (FelipeLessa)
11:50:18 <monochrom> some other author came out with semicolon for "(f :: A -> B) ; (g :: B -> C)"
11:50:42 <monochrom> it's just as good until you also have function application.
11:50:47 <ReinH> monochrom: in AoP he uses f . g = \x -> g (f x) iirc
11:50:49 <ReinH> I don't have it on me though
11:51:38 <ReinH> I just remember noticing that he hadn't fixed the "wrong order" of composition despite reversing the order of the function arrow and being amused.
11:52:42 <johnw> phadej: ping
11:52:48 <johnw> phadej: what is your Hackage user name?
11:53:02 <johnw> ah, phadej
11:53:39 <johnw> phadej is now the new maintainer of the github package :)
11:53:43 <ReinH> woo
12:00:18 * hackagebot fb 1.0.13 - Bindings to Facebook's API.  https://hackage.haskell.org/package/fb-1.0.13 (FelipeLessa)
12:03:01 <monochrom> ReinH: no, I have just checked. in the 1st chapter ("programs") he has "if f:A<-B and g:B<-C, then f . g : A<-C is defined by (f . g)x = f(g x)". in the 2nd chapter ("categories") he has "f . g is defined iff f : A<-B and g : B<-C"
12:04:38 <ReinH> monochrom: ok thanks
12:05:08 <ReinH> that makes more sense
12:05:39 * hackagebot fb-persistent 0.3.6 - Provides Persistent instances to Facebook types.  https://hackage.haskell.org/package/fb-persistent-0.3.6 (FelipeLessa)
12:11:44 <maerwald> is it hard to create C bindings?
12:11:57 <monochrom> no
12:29:44 <johnw> maerwald: if you already have a header file, it's quite trivial using c2hsc
12:30:25 <maerwald> cause the xfce exo library doesn't seem to have any bindings
12:32:55 <maerwald> but it interacts with gtk+
12:33:00 <maerwald> so not sure how easy that will go
12:34:52 <Bruuuuno> http://lpaste.net/148125 why does this compile and work?
12:36:25 <ReinH> Bruuuuno: it uses the Monad instance for ((->) e)
12:36:55 <ReinH> it throws away the results of f1, f2, and f1 again, and then gives the result of applying f3
12:37:31 <ReinH> so in the end it's the same as writing doTest' a = f3 a
12:37:34 <ReinH> or doTest' = f3
12:37:57 <ReinH> (and in fact it doesn't need to evaluate f1 or f2 at all, so doesn't even need to throw anything away)
12:38:33 <Bruuuuno> what's the googling name of that ((->) e) instance?
12:39:15 <ReinH> ((->) e)
12:39:18 <ReinH> https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html
12:39:22 <ReinH> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-614
12:39:46 <ReinH> (it's ((->) r) actually)
12:40:06 <kadoban> Bruuuuno: It's also know as Reader
12:40:17 <ReinH> No, it is not.
12:40:20 <ReinH> Reader is known as Reader
12:40:27 <ReinH> ((->) r) is known as ((->) r)
12:40:40 * hackagebot bibtex 0.1.0.5 - Parse, format and processing BibTeX files  https://hackage.haskell.org/package/bibtex-0.1.0.5 (HenningThielemann)
12:40:47 <ReinH> They are equivalent, but they are not the same.
12:41:22 <bitemyapp> ReinH: the negation isn't as helpful as an amendment of the original sentiment
12:41:28 <kadoban> I meant in terms of what they can look up to understand what it does, of course.
12:41:30 <bitemyapp> (in this case)
12:42:02 <bitemyapp> ReinH: better: "well, they're legitimately totally different types, but a non-transformer based Reader will usually just be a newtype of (->)"
12:42:36 <bitemyapp> kadoban: tricky thing about Reader, the Reader most people will import from another library will be ReaderT under the hood.
12:42:59 <bitemyapp> kadoban: so unless they're implementing it themselves, the comparison won't be quite as seamless as one would like
12:43:15 <kadoban> Right, that's somewhat unfortunate.
12:44:32 <bitemyapp> Aye
12:47:44 <ReinH> I thought that "It's also know as Reader" was incorrect enough that it warranted a negation: It gives the impression that Reader can be substituted freely for ((->) r). If someone believes this, they will be confused by the type error they get  when they try to do so.
13:00:40 * hackagebot microlens 0.4.0.0 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.4.0.0 (Artyom)
13:00:42 * hackagebot microlens-ghc 0.4.0.0 - microlens + all features depending on packages coming with GHC (array, bytestring, containers)  https://hackage.haskell.org/package/microlens-ghc-0.4.0.0 (Artyom)
13:00:44 * hackagebot microlens-platform 0.2.0.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.2.0.0 (Artyom)
13:04:34 <monochrom> microlens :D
13:05:06 <puregreen> I think I saw minilens somewhere, too
13:05:21 <erisco> are there laws for Num?
13:05:40 * hackagebot microlens-contra 0.1.0.0 - True folds and getters for microlens  https://hackage.haskell.org/package/microlens-contra-0.1.0.0 (Artyom)
13:05:42 * hackagebot microlens-mtl 0.1.6.1 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.6.1 (Artyom)
13:05:44 * hackagebot microlens-th 0.3.0.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.3.0.0 (Artyom)
13:05:48 <monochrom> usually ring axioms and possibly valuation ring stuff
13:06:02 <monochrom> the "valuation ring" part is due to abs
13:09:08 <monochrom> perhaps abs is not valuation.
13:09:45 <monochrom> so, make it: usually ring axioms plus "abs x * signum x = x", abs is kind of magnitude, signum is kind of sign or direction
13:15:24 <erisco> I gave this quick answer http://stackoverflow.com/a/34536499/260584 but was unable to intuitively explain it -- meaning I do not clearly understand it either.
13:16:31 <erisco> The function Applicative can be understood as mapping many arguments from one
13:17:10 <erisco> this is clear when simply we have f <$> m1 <*> … <*> mn
13:17:37 <erisco> when I use 'liftA3 f' I no longer have a clear intuition for what I am doing
13:18:11 <monochrom> I now see how to formalize "abs is kind of magnitude, signum is kind of direction". abs has to be a norm. then "abs x * signum = x" takes cares of the rest about sign and direction
13:18:42 <ReinH> monochrom: norm and signorm
13:19:50 <monochrom> so: usually ring axioms, plus abs is a norm, and abs x * signum x = x. (ok, maybe "fromInteger is a ring homomorphism" needs to be made explicit, too.)  lastly, if the type is also an Ord instance, we usually also expect an ordered ring, e.g., + is monotonic, x*x>=0 for all x.
13:21:10 <erisco> liftA3 f <*> pure m1 <*> … <*> pure mn is  \x -> liftA3 f x m1 … mn
13:21:32 <ReinH> monochrom: norm n = sqrt (dot n) = sqrt (n * n) = abs n
13:21:53 <erisco> well, liftAn
13:22:30 <ReinH> (if we take only the positive root)
13:23:07 <erisco> ah, I suppose then we know that liftA3 is just the Applicative-style interspersed over the function application
13:23:50 <erisco> but I still need to think of why liftA3 is an intuitive thing to use
13:24:59 <johnw> liftA3 means you have a function that takes three arguments, and those arguments are being produced by "actions" in your Applicative.  x <- liftA3 f ax ay az
13:25:41 * hackagebot webapp 0.1.2 - Haskell web scaffolding using Scotty, WAI, and Warp  https://hackage.haskell.org/package/webapp-0.1.2 (natesymer)
13:26:26 <erisco> johnw, well, I mean particularly why we need 'liftA3 f' rather than just 'f'
13:27:02 <johnw> because f is of type a -> b -> c -> d
13:27:08 <johnw> and yet you have f a, f b and f c
13:27:13 <erisco> I think the idea is… the usual case is we have one argument and we map that one argument to obtain many arguments
13:27:18 <johnw> another way to think about it: it's a 3-way fmap
13:27:44 <erisco> if we have n arguments that we want to map then we need n layers (?) of Applicative-style
13:27:52 <johnw> not layers
13:28:41 <johnw> liftA3 maps a function a -> b -> c -> d to a function f a -> f b -> f c -> f d
13:30:41 * hackagebot free-functors 0.6.5 - Free functors, adjoint to functors that forget class constraints.  https://hackage.haskell.org/package/free-functors-0.6.5 (SjoerdVisscher)
13:32:47 <Jaxan> I wish to make a command line utility with a similar interface as GHCi, are there any libraries for this (which handle, for example, the arrow keys, a correct backspace, etc)?
13:32:58 <johnw> haskeline
13:33:12 <erisco> johnw, I don't think my words are clear enough yet
13:33:21 <johnw> erisco: speak in types!
13:33:24 <erisco> but the intuition seems to be accurate thus far
13:34:15 <Jaxan> johnw: fantastic! that was quick ;-)
13:34:17 <erisco> using the intuition I can easily define the flip as  liftA3 truth <$> (flip ($)) <*> (pure . Just) <*> (pure . pure Nothing)
13:35:24 <erisco> and it generalises
13:36:03 <erisco> so I know what I can do with  liftA3 (liftA3 f)
13:37:22 <erisco> :t \f a b c -> liftA3 f <$> a <*> b <*> c
13:37:23 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c -> d) -> f (f1 a) -> f (f1 b) -> f (f1 c) -> f (f1 d)
13:37:49 <erisco> remove the generality and I think that is clear as-is
13:37:59 <d34df00d> Hi there!
13:37:59 <Bruuuuno> Is there a way to automatically remove code when compiling with -O2? I want to remove my calls to Debug.Trace.trace
13:38:18 <johnw> erisco: I don't know what you're telling me
13:39:24 <dgish> hey I'm trying to run the hello world code from learnyouahaskell, and for some reason the putStrLn isn't happening until after the getLine call, this results in me having to enter text prior to any prompt appearing. Anyone know what might be going on here?
13:39:42 <d34df00d> I'm thinking of using Haskell as a kind of a scripting language in my C++ application. The bird eye's view of the workflow I'm thinking of is something like 0) loading and typechecking the script; 1) getting the list of functions exported by a script; 2) binding some C++ types to the types expected by a function; 3) invoking a function and getting its result.
13:40:10 <erisco> johnw, it is just a matter of clearly understanding liftAn when used as I have been showing
13:40:26 <d34df00d> From what I've googled so far, seems like too much of premature knowledge is needed about the contents of the script or the contents of the C++ side, or some manual compilation of the binary is required (which is going somewhat contrary to scriptish "write & run" approach).
13:40:33 <d34df00d> So what are my best options here?
13:40:41 <johnw> I don't know what you're trying to show me, or what "the generality" is; but it's fine if I don't understand
13:40:41 <erisco> in the specific case of lifting into the function Applicative
13:41:30 <erisco> the generality is 'f' and 'f1', whereas I am only interested in '->'
13:41:33 <kadoban> dgish: Probably buffering. You can manually turn off buffering if whatever is going on automatically isn't working correctly. IIUC usually it'd be automatically using line buffering if you're working interactively, so it seems a bit curious that you're seeing that.
13:41:48 <wowdog> hi, anyone know how to log all the commands that I previously type in GHCi?
13:42:23 <wowdog> search :h, but I did not find any hint how to log all the history commands
13:42:37 <kadoban> wowdog: You probably should be typing more in a file and less in GHCi if you want that commonly. Write code in a file, :load it in, only play with it in GHCi
13:42:46 <erisco> flip (liftAn f <$> m1 <*> … <*> mn) = liftAn f <$> flip m1 <*> … <*> flip mn
13:42:50 <erisco> one interesting result
13:42:55 <dgish> kadoban: thx
13:43:01 <erisco> which makes sense with the intuition
13:43:34 <geekosaur> wowdog, they're generally logged to ~/.ghc/ghci_history
13:44:47 <geekosaur> I don't know offhand if haskeline (used instead of readline because readline is problematic on windows and os x) provides a way to change that file
13:45:29 <Denommus> well
13:45:35 <Denommus> it seems I might drop stack in favor of Nix
13:47:27 <the_2nd> I know I could map this more easily, but how? http://lpaste.net/5558690998269247488
13:50:38 <kadoban> the_2nd: maybe:   valueBy t = sum $ map (\f -> valueBuy . f $ t) [base, center, gun, …]
13:53:10 <sm> sum $ map (valueBy . ($ t)) [base, center, gun, …]
13:54:50 <Th30n> I have a function like this: `foo a = bar3 a . bar2 a . bar1 a` How can I avoid passing a explicitly?
13:55:32 <Th30n> Note that foo takes another, eta reduced argument. I've tried using <*> but, this second argument messes things up.
13:57:23 <erisco> johnw, I updated my answer with what I've been blabbing about http://stackoverflow.com/a/34536499/260584
13:57:41 <erisco> johnw, it comes down to two simple equations
13:57:42 <pavonia> @pl \a -> bar3 a . bar2 a . bar1 a
13:57:42 <lambdabot> liftM2 (.) bar3 (liftM2 (.) bar2 bar1)
13:57:58 <erisco> f <$> m₁ <*> … <*> mₙ = \x -> f (m₁ x) … (mₙ x)  and  liftAₙ f <$> m₁ <*> … <*> mₙ = \x -> f <$> m₁ x <*> … <*> mₙ x
13:58:11 <sm> sum $ map valueBy [base t, center t, gun t, …]
13:59:05 <Th30n> pavonia: Thanks, unfortunately the original version is more readable to me.
13:59:14 <pavonia> Yeah
14:00:41 <the_2nd> sm, it won't allow me to create the list
14:00:42 * hackagebot postgrest 0.3.0.2 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.0.2 (begriffs)
14:00:49 <the_2nd> since theyre all of different types
14:01:12 <sm> the_2nd: aha.. your code is fine then. clear.
14:01:35 <the_2nd> sm, just leave it as-is?
14:01:38 <sm> yup
14:02:16 <erisco> johnw, do I make sense now?
14:02:45 <pavonia> Th30n: You could hide your 'a' in a Reader, but that may be a bit overdone
14:03:20 <sm> the_2nd: (but following the hlint suggestion would be slightly nicer)
14:03:36 <sm> so, is there a demo yet ?
14:03:52 <sm> the haskell games, they are slow in coming...
14:04:15 <johnw> erisco: I suppose so
14:45:43 * hackagebot swagger2 1.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-1.1 (NickolayKudasov)
15:10:44 * hackagebot swagger2 1.1.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-1.1.1 (NickolayKudasov)
15:55:45 * hackagebot free-http 0.2.0 - An HTTP Client based on Free Monads.  https://hackage.haskell.org/package/free-http-0.2.0 (aaronlevin)
16:00:19 <hsk3> I did import Criterion.Measurement, but if I use the time_ function I get Not in scope: ‘time_’
16:00:20 <hsk3> Why?
16:00:46 <hsk3> Oh no
16:00:47 <hsk3> wait
16:01:05 <hsk3> yes, i'm right
16:01:16 <hsk3> Why do I get not in scope?
16:01:45 <ReinH> what time_ function?
16:01:52 <ReinH> I don't see one.
16:01:53 <hsk3> http://hackage.haskell.org/package/criterion-0.8.0.1/docs/Criterion-Measurement.html
16:02:11 <Cale> That is extremely old documentation
16:02:17 <Cale> http://hackage.haskell.org/package/criterion-1.1.0.0/docs/Criterion-Measurement.html
16:02:33 <Cale> Are you sure you're using that version of Criterion?
16:02:48 <hsk3> oh shit lol, thanks
16:03:25 <Cale> https://github.com/statusfailed/hackage-fu helps with this problem :)
16:04:23 <Cale> It adds some stuff to the top of the haddock pages letting you know whether you're looking at the doc for the most recent version
16:16:10 * hackagebot servant-swagger 0.1 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-0.1 (NickolayKudasov)
16:19:44 <hsk3> cool
16:20:00 <hsk3> Does "stack build" optimize my build by default?
16:20:06 <hsk3> of my executable
16:21:42 <ReinH> hsk3: yes
16:21:47 <hsk3> ok
16:21:53 <hsk3> the best optimization?
16:21:55 <hsk3> fastest
16:22:05 <hsk3> (fastest executable)
16:23:43 <MarcelineVQ> ReinH: You sure? The default template has -threaded, -rtsopts, and -N but doesn't set an optimise flag in the .cabal
16:24:00 <ReinH> MarcelineVQ: there is a --fast flag which disables optimizations
16:24:11 <ReinH> from which I conclude that there are optimizations which --fast disables
16:29:41 <ReinH> woops
16:42:45 <Lokathor> http://lpaste.net/148128 my functions sometimes end up too big :/
16:43:26 <ReinH> Lokathor: You should try ExceptT
16:43:48 <Bruuuuno> or using the Either monad
16:44:02 <ReinH> Needs to do IO, so ExceptT.
16:44:15 <ReinH> which is an EitherT monad
16:44:27 <Lokathor> I was thinking that i'd need some sort of deal like that
16:44:49 <hsk3> Are Criterion's nfIO and whnfIO the only ways to force an IO action execute immediately (before continuing on to the next step in the surrounding IO action, i.e., the next line in the surrounding do block).
16:46:26 <Lokathor> ReinH, hmm, does it matter that i don't want to actually throw the exceptions?
16:46:43 <ReinH> No.
16:46:53 <ReinH> You're just handling both IO and Either together
16:47:04 <ReinH> you don't need to think of it as exceptions at all
16:47:25 <Lokathor> I've never really done any transformer stuff. honestly i was waiting for bitemyapp to release that chapter of his this month
16:48:35 <ReinH> @unmtl ErrorT String IO a
16:48:36 <lambdabot> IO (Either String a)
16:48:52 <ReinH> except s/ErrorT/ExceptT
16:49:20 <Lokathor> hmm
16:49:44 <ReinH> so in do x <- EitherT ioActionThatReturnsAnEither; ... x will be the contents of a Right, a Left will short-circuit the rest of the computaiton and be returned.
16:50:08 <ReinH> :t runExceptT
16:50:09 <lambdabot> ExceptT e m a -> m (Either e a)
16:50:31 <ReinH> then turns the whole ExceptT action back into an IO (Either e a) action.
16:50:59 <ReinH> Er
16:51:02 <ReinH> ExceptT, not EitherT
16:51:07 <ReinH> The names are somewhat of an annoyance
16:51:10 <ReinH> :t ExceptT
16:51:11 <lambdabot> m (Either e a) -> ExceptT e m a
16:51:21 <Lokathor> how do i make different Left stages do different cleanup actions?
16:52:42 <Lokathor> with the top case, the user hasn't joined yet, so when they disconnect that's quiet. In the lower case they are connected and that should announce to the room that they're leaving
16:53:24 <Lokathor> the middle Either, with the authResult, that's not even the same kind of Either as the first and last one, so i don't think i'd be able to merge that in.
16:53:41 <Lokathor> though, perhaps that's what "withExcept" is all about
16:55:30 <hsk3> What does ! mean, as in type !Double
16:55:38 <Lokathor> strictness
16:55:49 <ReinH> hsk3: http://lpaste.net/148128
16:55:51 <ReinH> er
16:55:51 <Lokathor> the field will be evaluated during the construction of the enclosing value
16:55:53 <ReinH> sorry
16:55:55 <ReinH> http://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration
16:56:03 <ReinH> It's a strictness declaration.
16:56:32 <hsk3> ReinH: so can i change the return type of my own function from Double to !Double to make it strict?
16:56:35 <hsk3> is that all i have to do?
16:56:53 <ReinH> hsk3: it's for data declarations
16:57:13 <ReinH> you can't throw a random ! anywhere
16:57:14 <Lokathor> strictness is determined by the consumer, basically. Your function's result will be evaluated when someone else needs it
16:57:32 <hsk3> ok
16:58:11 <Lokathor> if you read the stack overflow, it will explain that the !Double still might not be evaluated, if the value holding it isn't evaluated
16:59:50 <Lokathor> IO (Either WS.ConnectionException Text) and IO (Either Text ClientInfo) are the two kinds of things i've unfortunately intermixed
17:28:47 <csd_> If I define data = A | B | C ... deriving (Ord), is there some increment operation that given an A will return B?
17:31:41 <mauke> no, but there is one with Enum
17:32:02 <csd_> oh succ and pred
17:34:08 <csd_> thanks
17:55:04 <FofG_> I don't understand the visual metaphors employed in described transformers. `ErrorT { runErrorT :: m (Either e a) }` and `ErrorT MyError IO` People will refer to this as ErrorT stacked ​*on top*​ of `IO. I don't see why that's ​*on top*​
18:18:01 <geekosaur> FofG_, it's kinda confused. we say it's on top but then we call the operation to reach it lift or liftIO...
18:18:18 <ReinH> :t lift
18:18:20 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:18:34 <FofG_> honestly, the metaphor seems reversed
18:18:40 <ReinH> lift lifts m to work in t
18:18:42 <geekosaur> the "on top" is because it behaves in some ways like a stack; you push new layers on top of the base monad (Identity, IO, ST, STM)
18:18:43 <FofG_> because if i fmap on IO (Maybe a)..I'm fmapping on IO first
18:19:11 <FofG_> so, to me, IO seems to be "on top"
18:19:16 <ReinH> This is precisely the direction lift should operate in of m is below t.
18:19:21 <ReinH> s/of/if
18:19:26 <geekosaur> and you're "popping" in some sense to reach down into the stack. unfortunately a different metaphor is in play for the name of that operation >.>
18:19:37 <ReinH> But mostly it's arbitrary
18:19:52 <ReinH> In a 'the enemy's gate is "down"' sort of way
18:19:52 <FofG_> "base" is equally confusing to me
18:19:54 <FofG_> lol
18:19:55 <geekosaur> FofG_, tat's different actually
18:20:12 <FofG_> "base" is used to mean whatever the `m` is?
18:20:20 <ReinH> but if we pick something to be at the base, the only place to go vertically is up.
18:20:24 <FofG_> like m (Maybe a)..the base is m?
18:20:37 <geekosaur> there's multiple levels. in IO a, IO is "around" a, not so much on top of
18:21:05 <geekosaur> but there's also monad transformer stacks --- StateT IO a. StateT is "on top of" IO. IO is "around" a
18:21:47 <FofG_> i guess i kinda see that..with squinting...
18:21:51 <FofG_> s -> m (a, s)
18:21:52 <geekosaur> (because it's a different kind of thing. you can't put StateT on top of a value like StateT s Int a; you can put IO around a value like IO Int
18:22:22 <geekosaur> (you get a "kind error" if you try to write the first one; the "on top of" exists in type space, not value space)
18:22:33 <ReinH> Although StateT could easily be "around IO too.
18:22:35 <ReinH> "around"
18:22:47 <ReinH> I think someone picked a frame of reference and it stuck.
18:23:31 <geekosaur> also I have "around" in quotes because it's rarely actually around anything. IO Int is a program that could produce an Int if executed by the runtime. [Int] is, in a sense, all the Int-s in the list at the same time
18:23:57 <ReinH> The only convincing argument I can see is that if you admit that IO is at the "base" of StateT s IO a then the only place for StateT to be in relation is "up".
18:24:07 <ReinH> It can't be beside, that would make it co-base.
18:24:34 <ReinH> On the other hand, we could have said that IO is "inside" and StateT is "outside" too.
18:24:40 <FofG_> hrm..that's starting to make some sense
18:24:46 <FofG_> it's about just picking a frame of reference
18:25:05 <ReinH> top-bottom places them in a logically consistent frame of reference
18:25:09 <geekosaur> in any case, the terminology *is* confusing and seems to come from conflicting frames of reference
18:25:09 <ReinH> I don't think there's much else to it.
18:25:19 <geekosaur> I'e always found it a bit ridiculous that we "lift" to something "below us in the stack"
18:25:29 <ReinH> geekosaur: I disagree with that interpretation, as I mentioned
18:25:49 <ReinH> lift takes a monad action in a lower level and lifts it to a monad action in a higher level
18:25:50 <ReinH> :t lift
18:25:52 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:25:54 <ReinH> m a is below t m a
18:26:02 <ReinH> So lift operates in the correct direction.
18:27:33 <geekosaur> mm, guess the issue is that when stacks are presented the image used is often the stack of plates in a cafeteria. so push on top (and you see this imagery a lot). yours "works" but assumes the stack builds downward (which is true for CPU stacks, but not a lot else...)
18:27:54 <ReinH> geekosaur: I think there's a duality between definition that inverts the relationship in our minds
18:28:00 <ReinH> er, between use and definition
18:28:04 <FofG_> I'm super confused. These analogies are just not clicking for me :|
18:28:31 <geekosaur> might be best to igore the analogies and treat it as jargon >.>
18:29:12 <FofG_> Ya. I don't find metaphors/analogies particularly helpful ever. Only reason I care here is because a lot of things I read have adopted this kind of imagery
18:29:43 <geekosaur> imagery's not a whole lot of help with monads anyway
18:30:12 <ReinH> geekosaur: stack like tower's of hanoi, not like push down. ;)
18:30:15 <ReinH> towers
18:30:23 <FofG_> I'm reading this http://www.yesodweb.com/book/monad-control 
18:30:32 <FofG_> and it refers to "ErrorT transformer stacked on top of the IO monad"
18:30:50 <ReinH> right, because IO is necessarily at the base
18:30:55 <FofG_> I can sooorta see that if we're talking about the ErrorT constructor. I see that wrapper as wrapping on top of IO
18:30:58 <ReinH> so anything else that transforms it is on top
18:31:01 <FofG_> because it's IO (Either e a)
18:31:11 <FofG_> and then ErrorT $ ...
18:31:17 <ReinH> This duality makes things confusing aside from terminology
18:31:53 <FofG_> > IO is necessarily at the base
18:31:53 <ReinH> What order do you apply the unwrappings for ReaderT A (WriterT B (StateT C m))) a?
18:31:55 <lambdabot>      Not in scope: data constructor ‘IO’
18:31:55 <lambdabot>      Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
18:31:55 <lambdabot>      Perhaps you meant one of these:
18:32:09 <ReinH> Luckily, it's the same duality as a -> (b -> c) but (f a) b
18:32:12 <ReinH> so we're used to it a bit
18:32:55 <FofG_> ya I find these deep stacks hard to unravel mentally when I first look at them
18:33:05 <FofG_> but the unwrapping first occurs as State, right?
18:33:16 <ReinH> but the nature of duality is something can be both up and down depending on where you are looking at it from.
18:33:18 * ReinH shrugs
18:33:32 <ReinH> I think it's best to try not to think about it too hard.
18:33:43 <FofG_> hehe fair enough
18:34:00 <FofG_> I wish it were just imprecise instead of downright confusing
18:36:17 <FofG_> Appreciate the explanations though. Thanks guys
18:36:29 <ReinH> FofG_: Human languages are frequently a source of confusion.
18:36:52 <FofG_> no doubt. Ultimately, the types are all there is :P
18:37:32 <ReinH> FofG_: How is an ice rink like Tuesday?
18:38:11 <FofG_> wut?
18:38:28 <FofG_> not familiar with that phrase lol
18:38:33 <ReinH> FofG_: we sometimes play hockey on an ice rink, and we sometimes play hockey on Tuesday.
18:38:53 <ReinH> That's a type error, but you wouldn't know it by the rules of English grammar.
18:39:02 <FofG_> ah right
18:39:04 <FofG_> ha
18:40:18 <FofG_> makes me think of Aristotle's Categories
18:40:39 <FofG_> where he talks about pointing to a painting and saying "that's a man"
18:40:47 <FofG_> confusing accident with essence
18:41:06 <FofG_> eh..different issue i guess
18:46:55 <Lokathor> :t ([1] :: [] Int)
18:46:56 <lambdabot> [Int]
18:48:23 <orion> Hi. newtype MessagePatternT c d h m a = MessagePatternT { unMP :: StateT (HandshakeState c d h) m a } deriving (Functor, Applicative, Monad, MonadIO, MonadState(HandshakeState c d h))
18:49:18 <orion> If 'a', the underlying Monad was Identity, would you be able to use liftIO?
18:49:48 <orion> It's unclear to me one way or the other because of "deriving ... MonadIO"
18:49:49 <geekosaur> 'a doesn't look like a monad to me
18:49:59 <geekosaur> 'm' looks like the monad there
18:50:04 <orion> Erm, yes.
18:50:06 <orion> My mistake.
18:50:54 <ReinH> orion: if the base monad isn't IO, you can't use liftIO.
18:51:10 <ReinH> There is no IO monad transformer.
18:51:20 <ReinH> Actually I think there is one but it is a lying cheater.
18:51:38 <geekosaur> anyway StateT should have a MonadIO instance whenever m does (and IO trivially does); MonadIO is also derived through the newtype. so it looks to me like if m is IO, it should work. but if m is Identity, there is no MonadIO instance so StateT won't have its MonadIO instance
18:52:08 <geekosaur> MessagePattern's MonadIO instance depends on StateT's, so liftIO should be a type error
18:52:53 <ReinH> This is the same as data Foo a = Foo a deriving Eq only having an Eq instance when a has one.
18:53:19 <orion> ReinH: ^ Interesting!
18:53:43 <orion> Is that also the case with data Foo a = Foo?
18:53:49 <ReinH> If you try Foo succ == Foo pred you will get a type error.
18:53:56 <ReinH> orion: try it!
18:54:07 <orion> heh, ok. Thank you for the info.
18:54:11 <ReinH> yw
18:54:19 <orion> You too geekosaur. :)
19:21:00 <python476> hi there
19:21:26 <python476> if I have a definition: data Foo a = a :? [Foo a] (yes fp101x)
19:21:39 <python476> where do I find a reference on how to define functions over that data type
19:24:14 <Cale> python476: Well, there's only one data constructor, written infix as :?
19:24:25 <Cale> python476: So you can pattern match on that constructor, like:
19:25:03 <oisdk_> python476 headFoo (x :? y) = x
19:25:09 <python476> I'm still not ready for parameterized Constructors, I realize I can't write function for Maybe a
19:25:25 <Cale> fooSize (x :? xs) = 1 + sum (map fooSize xs)
19:25:40 <python476> oisdk_: and the signature would be headFoo :: (:? ..) => .. -> ...
19:25:48 <Cale> fooRoot (x :? xs) = x
19:25:56 <Cale> nope
19:26:03 <Cale> headFoo :: Foo a -> a
19:26:28 <oisdk_> python476 Are you able to write a function that does pattern-matching?
19:26:39 <Cale> fooSize :: (Num n) => Foo a -> n
19:26:55 <oisdk_> Like, could you write a function that returns True for the number 1, but False for anything else?
19:27:12 <Cale> That's a poor example, because you can do that with if ;)
19:27:21 <python476> oisdk_: I did it before but I winged it it seems
19:27:45 <python476> over types that are 'casual' nowadays like [] | a : List a ..
19:28:00 <Cale> Let's rework this type a little bit so we don't have to deal with the infix syntax, and give it a nicer name
19:28:05 <python476> so I wasn't really precise in the haskell type system side of it
19:28:12 <Cale> data Tree a = Branch a [Tree a]
19:28:19 <python476> Cale: I'd love that
19:28:35 <Cale> So, now this data declaration defines two things:
19:29:00 <Cale> 1) A type constructor called Tree, which has one type parameter (the 'a' in this declaration, but it doesn't matter which variable name we use there)
19:29:21 <Cale> 2) A data constructor   Branch :: a -> [Tree a] -> Tree a
19:29:48 <Cale> We can use Branch as a function to construct values of Tree types:
19:30:08 <Cale> Branch 1 [Branch 2 [], Branch 3 [Branch 4 [], Branch 5 []]] :: Tree Integer
19:30:40 <Cale> and we can also take trees apart by pattern matching against the Branch data constructor when defining a function:
19:30:48 <Cale> size :: Tree a -> Int
19:31:06 <Cale> size (Branch x xs) = 1 + sum (map size xs)
19:31:19 <python476> Thanks a lot
19:32:02 <Cale> With your original definition, we were just using the infix operator :? instead of Branch
19:32:39 <python476> I see better now
19:32:44 <python476> the rain is gone etc etc
19:39:17 <Big_G> Is servant pretty much the go to RESTful API library or did I miss som?
19:39:19 <Big_G> *some
19:42:10 <python476> ['a'..'A'] -- some teacher are mean
19:43:00 <nolraiU> I've imported GHC.TypeLits but I still get: Not in scope: ‘natSing’
19:43:08 <geekosaur> if they were really mean they'd do that to you on an EBCDIC system
19:43:23 <nolraiU> > ['a'..'A']
19:43:25 <lambdabot>  ""
19:44:14 <nolraiU> Anyone know how to use KnownNat?
19:44:41 <geekosaur> nolraiU, check what version of base you have
19:46:18 <nolraiU> 4.7 is what the cabal file is expecting.
19:48:14 <Cale> python476: heh
19:48:48 <c_wraith> nolraiU: there's not much to it.
19:49:15 <c_wraith> nolraiU: oh.  GHC.TypeLits changed significantly between ghc 7.8 and ghc 7.10.  Make sure you're using the right docs.
19:49:51 <c_wraith> nolraiU: natSing sounds like ghc 7.8's version
19:50:13 <geekosaur> 4.8 base still seems to have it
19:50:56 <FofG_> Anyone have any good resources for understanding what MonadBaseControl is all about? 
19:51:21 <c_wraith> FofG_: understanding what it's about is easy.  It's understanding how to write instances that's tough. :)
19:51:40 <monochrom> it is about being able to catch and throw exceptions when you do StateT s IO, etc.
19:52:09 <monochrom> perhaps just the catch part. the throw part is too easy.
19:52:32 <c_wraith> FofG_: It more or less comes out of the bracket problem for monad transformers.  Given a monad transformer, lift (bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO b) into it.
19:53:14 <Bruuuuno> is there a better way to write the "bossFight" function? https://github.com/bruno-cadorette/AdventOfCode/blob/master/Day%2022/Day22.hs
19:53:16 <monochrom> just bracketing? no catch?
19:53:21 <FofG_> What's the challenge in making bracket work otherwise such that a special class is needed for that?
19:53:33 <c_wraith> FofG_: but more generally, it's about lifting a function with the base monad in a negative position into a transformer
19:54:09 <c_wraith> monochrom: bracket is harder than catch. I mean, catch needs something more than MonadTrans, too.  But a class like MonadCatch still isn't enough to implement bracket
19:54:21 <monochrom> I see
19:55:06 <FofG_> negative position roughly means the domain (vs the codomain)?
19:55:17 <c_wraith> FofG_: yes
19:55:25 <c_wraith> (very roughly)
19:55:49 <FofG_> Could you provide an example of "lifting a function with the base monad in a negative position into a transformer"?
19:57:07 <c_wraith> catch and bracket are the two most obvious examples.
19:57:15 <c_wraith> But even something like Timeout doesn't work.
19:58:29 <FofG_> bracket has base monad in negative position because the first arg is IO a?
19:58:48 <c_wraith> FofG_: and the second argument is a function that results in IO a, etc.
19:58:58 <c_wraith> err, IO b
19:59:02 <FofG_> :t bracket
19:59:04 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:59:12 <c_wraith> oh, I got the arg order wrong
19:59:34 <c_wraith> IO is in the negative position in each argument of bracket
20:00:19 <python476> Cale, oisdk__ : impressive how a tiny push gets one going, thanks
20:00:34 * python476 doesnt like syntax ... shrrrbl
20:00:43 <FofG_> it is? 
20:00:55 <FofG_> I thought in (a -> IO b), IO is in positive position
20:00:59 <Cale> python476: Feel free to ask if you have any other questions :)
20:01:00 <python476> btw, any of you followed fp101x ? any thought about it ?
20:01:12 <Cale> FofG_: yes
20:01:25 <c_wraith> FofG_: if that's a return value, yes.  But since that whole type is an argument, the IO is in the negative position
20:01:30 <Cale> right
20:01:33 <python476> Cale: writing and submitting answers for me are out of the picture I guess
20:01:57 <FofG_> ah i see
20:01:59 <python476> if I have time I may make you sweat over CPS / Monadic concurrency
20:02:13 <FofG_> ok, so it's negative position..so therefore what? :)
20:03:10 <c_wraith> FofG_: so try to use MonadTrans's lift with something like bracket.  You'll find there's no way to lift the arguments and have everything typecheck.
20:03:31 * FofG_ thinking
20:04:16 <FofG_> lift :: Monad m => m a -> t m a
20:04:32 <c_wraith> You forgot the MonadTrans t constraint, but yeah
20:04:33 <FofG_> you mean try to lift the whole thing
20:05:35 <c_wraith> Try to write liftedBracket :: (MonadTrans t, MonadIO m) => t m a -> (a -> t m b) -> (a -> t m c) -> t m c
20:06:17 * hackagebot unbreak 0.3.1 - Secure and resilient remote file storage utility  https://hackage.haskell.org/package/unbreak-0.3.1 (kinoru)
20:06:54 <c_wraith> FofG_: Or simplify things a bit, and go with (liftedBracket :: (MonadTrans t) => t IO a -> (a -> t IO b) -> (a -> t IO c) -> t IO c)  (which still doesn't work)
20:07:29 <FofG_> i should actually try so i can appreciate the problem
20:07:44 <c_wraith> yes.  I don't think it's really possible to understand without trying
20:07:55 <FofG_> ok lemme work on that and i'll come back
20:08:03 <FofG_> can't promise it'll be tonight lol
20:08:09 <c_wraith> no worries
20:08:15 <FofG_> thanks c_wraith 
20:13:47 <pikajude> i don't understand why this is happening: http://lpaste.net/148131
20:16:38 <oisdk__> Bruuuuno how about some >=>
20:16:52 <Bruuuuno> :t >=>
20:16:53 <lambdabot> parse error on input ‘>=>’
20:17:01 <Bruuuuno> :i (>=>)
20:17:11 <oisdk__> https://gist.github.com/oisdk/8b5307a147505b2e7fbd
20:18:23 <Bruuuuno> would there be a way to remove the fr each time?
20:18:29 <c_wraith> pikajude: I think throwM is the wrong thing.  Did you try using throwError instead?
20:18:32 <FofG_> c_wraith: dunno of this is the issue you were pointing at, but it seems the `onException` part of the implementation isn't possible
20:18:53 <FofG_> i.e. you need `IO c` but have `t IO c`
20:19:13 <FofG_> like if you just try to translate bracket lifted into t, it just doesn't work..
20:19:17 <c_wraith> FofG_: yeah.  That's the problem.  Well, one specific instance of it, but it's the general structure of the problem.
20:19:22 <FofG_> right
20:19:30 <FofG_> if you need what t was you could maybe do it?
20:19:39 <FofG_> but you can't write a general liftedBracket
20:19:43 <FofG_> do I have that right?
20:20:14 <FofG_> knew what t was*
20:20:21 <c_wraith> FofG_: so MonadBaseControl is about providing a pair of inverse operations to lower the lifted actions to base actions, and then re-lift them again without losing state.
20:20:32 <FofG_> aaah ok
20:20:42 <FofG_> so you can back down to IO and then re-lift, for example
20:20:46 <c_wraith> yes
20:21:11 <FofG_> man, trying to implement something is so much more informative than just squinting forever
20:21:17 <c_wraith> :)
20:21:31 <FofG_> and what does that generally look like?
20:21:35 <FofG_> if that question makes sense
20:21:48 <FofG_> maybe it'd be good to take a look at the class again ha
20:21:50 <c_wraith> I honestly have no idea.  I trust that the library works.  I don't understand how. :)
20:23:19 <FofG_> :)
20:23:34 <c_wraith> Is hackage *really* slow right now, or is it my internet connection?
20:24:40 <FofG_> it's been a bit spotty for me as well tonight
20:24:43 <FofG_> but not terrible
20:24:47 <FofG_> "A RunInBase m function yields a computation in the base monad of m that returns the monadic state of m"
20:25:24 <FofG_> so essentially it abstracts over this idea. if you can show me how to go back to the base monad then these things are possible
20:26:19 <c_wraith> more precisely - if you can show me how to go back to the base monad, then restore all the state that was lost in that process later.
20:26:47 <FofG_> hrm right..
20:26:58 <FofG_> bc there's no way the base monad itself will know about that
20:27:02 <FofG_> know anything*
20:27:06 <c_wraith> exactly
20:28:22 <FofG_> and that's the type StM m a :: *
20:28:34 <FofG_> where you store that state?
20:29:45 <c_wraith> FofG_: yeah.  It's an associated type, so it can be different with each instance
20:30:07 <FofG_> lot of concepts and language features in this one class
20:30:10 <FofG_> kind of overwhelming
20:30:23 <FofG_> multi-parameter type class with fundeps, etc
20:30:28 <FofG_> kind of a lot to take in
20:31:05 <oisdk__> Bruuuuno how about https://gist.github.com/oisdk/8b5307a147505b2e7fbd
20:32:31 <c_wraith> ok, back to reimplementing hyperfunctions
20:32:55 <Bruuuuno> yeah that's nice, but why did you had to change the order?
20:34:23 <oisdk__> Bruuuuno you don't have to, you can define it the other way around also. 
20:34:52 <oisdk__> I couldn't really grok the left-to-right function composition, though
20:35:52 <Bruuuuno> okay thanks!
20:43:54 <dramforever> Question: I'm tuning for speed, and just found out that my program took a bit more than half (55%) time in GC. Is that normal? *How* can I reduce it? (Performance/GHC in the wiki isn't really helpful, perhaps I didn't understand it)
20:45:06 <lispy> dramforever: 30% is a good target for GC time, just roughly speaking
20:45:30 <lispy> dramforever: but a better metric is figuring out if your program is doing unnecessary allocations
20:46:04 <dramforever> Hmm...allocations, so that's what the alloc% from +RTS -p is for?
20:46:14 <dramforever> "Time and allocation profiling"
20:46:23 <dramforever> nice
20:46:47 <lispy> So that's useful information, but I was thinking baout doing back of the envelope calculations to figure out how much space your problem needs to be solved
20:47:28 <lispy> For example, if you're reading a 10GB text file and generating word frequency. The amount of memory needed shouldn't be proportional to the file size, it should be proportional to the number of unique words
20:48:54 <dmj`> dramforever: what does your program do?
20:48:56 <lispy> you can use the vacuum package to get a sense for how space efficient (or inefficient) different representations are in haskell. It allows you to visualize the heap representation of your literal data structures
20:49:41 <dramforever> dmj`: It's a data structure implementation, Persistent Segment Tree, that's supposed to solve http://www.spoj.com/problems/MKTHNUM/
20:50:56 <dramforever> um...wait a sec, it's not very easy to understand.
20:51:03 <lispy> Changing the strictness or laziness of some programs makes huge differences in memory usage. And what works and what is a good idea is hard to capture in a general sense.
20:51:39 <lispy> Sometimes increasing strictness is the right thing but sometimes laziness is better.
20:51:59 <lispy> I realize I'm being vague, but then I also don't know much about your program :)
20:52:10 <dmj`> dramforever: yea.. is "MKTHNUM - K-th Number" the only description of the problem?
20:52:24 <dramforever> oh yeah you have to click the "English"
20:52:30 <kadoban> dmj`: Click on English and it shows more for some reason.
20:52:39 <dmj`> ah, cool
20:57:31 <dramforever> Code is here http://discuss.spoj.com/t/mkthnum-tle-using-haskell-and-persistent-segment-trees/12349 , just...I don't really expect you to understand it, unless you already know what that is =(
20:59:02 <dramforever> Aha, here's a nice editorial, just skip down to the MKTHNUM part http://blog.anudeep2011.com/persistent-segment-trees-explained-with-spoj-problems/
21:00:46 <dramforever> =( no mention of segment trees
21:01:41 <NemesisD> has anyone read that "A Modern Architecture for FP" post? i'm having trouble digesting it
21:02:00 <dmj`> dramforever: why not just use an array, O(1) lookups for indices i-j. You could even insert them in sorted order into a new array. Then get the kth item in O(1). You'd need O(n) space, and n is < 100000. Worst case time would be O(n log n), unless you used a bucket sort
21:02:57 <dramforever> How? There are multiple queries on *intervals* of the given numbers
21:03:21 <dramforever> so like "what's the 3th in A[3..9]"
21:03:27 <dramforever> um...3rd
21:04:19 <dramforever> dmj`: hey, it's kth *smallest*
21:05:01 <dmj`> dramforever: it just says, "What would be the k-th number in a[i ... j] segment, if this segment was sorted?"
21:05:11 <dramforever> yep
21:05:41 <dramforever> dmj`: wait, you see, there are lots of queries
21:06:02 <dramforever> hmm...wait wait lemme see
21:06:16 <dmj`> arrays are good at being queried
21:06:59 <dramforever> for example, A[] = 1, 5, 2, 6, 3, 7, 4, and the first query is 2 5 3, how are you going to get the answer?
21:07:33 <dramforever> segment is, 5 2 6 3, sorted is 2 3 5 6, so answer is 3
21:07:39 <dramforever> but that's slow as hell
21:08:09 <python476> any idea why GHCi screams ‘fold’ is not a (visible) method of class ‘Foldable’ at me ?
21:08:24 <python476> when implementing an instance of Foldable 
21:09:19 <python476> Haskell makes you hungry. A proof that it makes your brain function highly
21:12:28 <dmj`> dramforever: so the list can wrap
21:13:10 <dramforever> sorry, what do you mean by wrap?
21:13:49 <dramforever> dmj`: ^
21:15:32 <dmj`> dramforever: well it seems that way, in the example below you're given: "1 5 2 6 3 7 4"
21:15:44 <dramforever> with you so far
21:16:00 <dmj`> and then asked Q(2,5,3), so segment [2..5], the 3rd number of the sorted segment.
21:16:21 <dramforever> yes that's right
21:17:16 <dmj`> oh I see, so the segment would be [5 2 6 3 7] -> (sorted) [ 2 3 5 6 7 ] -> 3rd (5)
21:17:55 <dramforever> yes that's right, except that [2..5] is [5 2 6 3] =P
21:18:13 <Hijiri> python476: If you used an import list, you might have only imported the class and not the methods (like import Data.Foldable (Foldable))
21:18:26 <Hijiri> To import the methods as well you would change Foldable to Foldable(..)
21:20:03 <dmj`> dramforever: yea, unless I'm misunderstanding. I'd just use arrays
21:20:20 <python476> Hijiri: I didn't even import anything. That might be the issue ?
21:20:46 <dramforever> dmj`: you are not sorting the array on each query, because there are like 5000 of them
21:21:18 <python476> nope, no luck
21:22:04 <dramforever> you need something much better than being linear in the length of the segment
21:22:18 <Hijiri> python476: What does :info Foldable give you?
21:23:05 <dramforever> python476: perhaps you are only implementing fold? The minimal complete definition is "foldMap | foldr", which means that you have to write one of the two
21:23:11 <dramforever> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Foldable.html
21:23:22 <python476> Hijiri: http://lpaste.net/148136
21:23:39 <Clint> python476: you don't have Data.Foldable loaded
21:23:39 <python476> dramforever: seems like a good reason yeah
21:24:10 <python476> Clint: indeed, importing Data.Foldable gives `fold`
21:25:07 <python476> I guess the MOOC teachers expected us to copy paste their ad-hoc Foldable definition
21:28:13 <dmj`> dramforever: it's only a few integers, and yes we're not sorting the entire array on each query, unless it called for it. But radix sort could do so in linear time. 
21:29:40 <dmj`> let me try to whip something up
21:29:55 <dramforever> you'll surely exceed the time limit
21:30:44 <dramforever> we can get down to O(log N) time per query, that's what I'm doing
21:33:20 <dmj`> dramforever: with the persistent segment tree?
21:33:26 <dramforever> yes
21:33:58 <dmj`> you'd still be storing all the numbers in memory though right
21:34:34 <dramforever> yes, but that's not too much. I have 1536MB mem, as shown on the sidebar
21:34:46 <dramforever> and mine is barely taking 80M
21:35:04 <dmj`> I mean, you'd have to, the problem can't be solved without it
21:35:13 <dramforever> yep
21:42:14 <dmj`> dramforever: can a query return multiple correct answers. For example [ 1,2,3,5,6,2,4,5 ] and Q(2,5,2), could be 3 and 4 (since 2-5 is shown twice)
21:42:47 <dramforever> dmj`: arrgh, no, 2 and 5 are *indices*
21:43:35 <python476> holy muckin frap
21:43:50 <python476> I made Trees Foldable over Monoids
21:45:00 <dmj`> dramforever: I see, so the segment tree uses O(n log n) storage
21:45:13 <dramforever> right
21:45:48 <python476> I will have barely one hour to understand and implement the Concurrent Monad... the suspense is high
21:49:13 <dmj`> dramforever: I'll just need to look into more how this works. Are the segments all sorted upon insertion?
21:50:58 <dramforever> dmj`: Uhh, forget about it, there are different things called "segment trees", and I'm sure that we are not talking about the same thing
21:51:13 <dramforever> dmj`: thanks for paying attention anyway =P
21:51:39 <dramforever> I'll write a blog post or something to describe the data structure used, then we can talk more easily
21:51:59 * dramforever leaves for a noon nap
21:54:29 <dmj`> cool
21:54:30 <hsk3> I have installed GHC using Stack. I like this because it doesn't pollute anything else on the system (except for the $PATH variable that I changed myself).
21:55:14 <hsk3> But I want to build my own Haskell files manually without creating a Stack project.
21:55:22 <hsk3> i.e., just "ghc --make file.hs"
21:55:46 <hsk3> Problem is, it doesn't find modules. If I do "stack build numbers", import Data.Number won't work for instance.
21:55:54 <hsk3> How can I make ghc locate modules within stack?
21:59:40 <zv> hsk3: what is the preferred way to tack on the `stack exec ghci` to the PATH?
22:01:14 <zv> also, I'm curious if anyone can identify the cause of the peaks and dips in this graph of #haskell activity: https://wiki.haskell.org/wikiupload/c/c4/Irc-raw.png 
22:02:10 <kadoban> hsk3: Use 'stack ghc' instead, or you could also use stack in script-interpreter mode for that, whichever you like.
22:02:51 <bitemyapp> kadoban: stack ghci ?
22:02:57 <jle`> zv: it'd be nice to see the plot with a more sensible x axis :)
22:03:55 <kadoban> bitemyapp: Doesn't sound like what they're looking for, but I might be missing something. (I've also never used 'stack ghc', so I'm making some assumptions about how it works)
22:05:19 <bitemyapp> oh woops
22:05:25 <bitemyapp> kadoban: no you were right, got my wires crossed.
22:07:31 <python476> darn it
22:07:47 <python476> I can't validate that course without the conc monad
22:08:16 <hsk3> kadoban: but "stack ghc" doesn't seem to take other ghc arguments like -O2 and -Wall
22:10:11 <kadoban> hsk3: 'stack ghc -- Blah.hs -O2 -Wall -o x' , etc.
22:11:09 <hsk3> kadoban: thanks!
22:18:02 <kadoban> hsk3: 'welcome. Note just for reference that … I can't think of any workflow where I'd actually do that. One of the following just seems better, depending: 1) Make a real cabal+stack project 2) Use 'stack runghc' 3) Use stack in script-interpreter mode http://docs.haskellstack.org/en/stable/GUIDE.html#script-interpreter   though if it's working for you, I guess it's all good.
22:23:08 <hsk3> kadoban: well i just have one file right now
22:23:32 <hsk3> thanks for the tips, i'll look at those when things get out of hand
22:36:22 * hackagebot language-bash 0.6.1 - Parsing and pretty-printing Bash shell scripts  https://hackage.haskell.org/package/language-bash-0.6.1 (KyleRaftogianis)
22:37:56 <emptyflask> i'm running haskell with stack, but is there anything i need to do (like initialize a stack.yaml) when working on stuff like exercism.io projects?
22:38:39 <emptyflask> ghc & runhaskell seem fine in that environment, but hdevtools complains that it can't find System.Random
22:40:53 <shanemikel> okay, I'm deriving the Y combinator, and to finish the proof, I need to verify one thing
22:41:17 <emptyflask> and the hdevtools i'm running is the one installed with `stack install hdevtools` in $HOME/.local/bin
22:42:24 <shanemikel> everything in the lamda calc is a function, right (without exception).. so, for any X, X = \x -> X x, right?
22:42:43 <kadoban> emptyflask: I know hdevtools has some stack support, but … hmm. I'm not sure how it knows to activate. You probably need a stack.yaml or something in the project for it to work yeah, that might make sense.
22:43:49 <kadoban> emptyflask: Let me put it this way: I know that with a .cabal file and a stack.yaml file it works. I'm not sure if both of those are required to get it to act correctly. It's probably a decent guess … or you could maybe do something like run 'stack exec -- hdevtools' instead of 'hdevtools', that should work I think.
22:43:54 <shanemikel> in other words, it isn't illegal to assume you can wrap anything in the application function, because everything is a function
22:44:20 <shanemikel> ?
22:45:27 <emptyflask> kadoban: same problem when running with `stack exec`. i'll mess around with stack.yaml / cabal files...
22:52:52 <shanemikel> that is, I'm not proving it, I'm proving the normal-order is equal to the applicative-order, so I don't have to evaluate it (being much messier)
22:55:19 <shanemikel> also, it's not for any class, it's personal
22:56:37 <jle`> i don't think "everything is a function" is a useful way of looking at things unless you qualify what you mean by "everything"
22:57:02 <jle`> there are certainly concepts in lambda calculus that aren't functions
22:58:43 <shanemikel> how about, everything that can be evaluated, once evaluated, is a function that can be applied
22:59:05 <tnks> yeah, I'm a bit confused what nit we're picking here.
22:59:21 <tnks> the lambda calculus is syntactically really sparse.
22:59:42 <shanemikel> I'm trying to figure out how to justify the claim that X, for any X is equal to \x -> X x
23:00:08 <jle`> is that really a thing?
23:00:14 <tnks> combinators only, right?
23:00:20 <shanemikel> yeah
23:00:25 <tnks> free variables might mess that up.
23:00:56 <tnks> if so, it's just η-reduction, right?
23:01:32 * hackagebot HPDF 1.4.10 - Generation of PDF documents  https://hackage.haskell.org/package/HPDF-1.4.10 (alpheccar)
23:01:55 <shanemikel> I don't know what that means, I haven't really learned it formally, just quick overviews of sematics, and jumping right into Y combinator
23:02:35 <tnks> shanemikel: it's just a name for what you're justifying:  https://wiki.haskell.org/Eta_conversion
23:03:38 <echo-area> Could someone give an example of using Mu to define types?  I cannot make up a meaningful one  newtype Mu f = Mu (forall a. (f a -> a) -> a)
23:03:42 <tnks> interesting (from Googling):  http://math.stackexchange.com/questions/722001/how-can-i-prove-a-simple-eta-conversion
23:03:57 <pdxleif> https://en.wikipedia.org/wiki/Lambda_calculus#.CE.B7-conversion
23:04:00 <shanemikel> where f1 = \x -> F (\y -> (x x) y)
23:04:30 <shanemikel> \y -> (f1 f1) y = (f1 f1)
23:04:42 <shanemikel> and \y -> (x x) y = (x x)
23:08:34 <shanemikel> is there a good textbook, suitable for a full course, that is freely available?
23:08:49 <tnks> on just lambda calculus?
23:09:55 <hsk3> Is there a language out there that is almost just like Haskell, with pure functions and all, except that it's not lazy by default?
23:10:56 <tnks> hsk3: https://wiki.haskell.org/DDC
23:11:28 <shanemikel> yeah tnks, and a thorough introduction to its applications (perhaps with a bias towards CS)
23:11:28 <tnks> that's the one I barely know about. . . never used it.
23:11:32 <pdxleif> GHC 8 will have whole-file strictness available as an option?
23:11:56 <jle`> i believe so, yes
23:12:34 <tnks> shanemikel: I have this one:  http://www.amazon.com/Introduction-Functional-Programming-Calculus-Mathematics/dp/0486478831
23:12:58 <tnks> it's pretty easy to get through and covers good stuff.
23:13:10 <tnks> feels a touch dated, but it's not obsolete.
23:13:43 <pdxleif> shanemikel: This was my introduction to lambda calculus: http://web.cecs.pdx.edu/~black/CS311/Sanderson%20Ch%201.pdf
23:14:00 <tnks> I hear books by Henk Barendregt are a good reference too.
23:16:34 <hsk3> tnks: interesting!
23:17:42 <shanemikel> yeah, I've read suggestions for his 'Lambda Calculus, Syntax and Semantics', but it's really expensive, and not free online (AFAICT) unfortunately
23:18:09 <tnks> hsk3: a good path is to start with lambdas, then do some Church encoding, then get some control flow, then recursion. . . then think of syntax sugar and macros.
23:18:57 <pdxleif> There's some lambda calculus interpreters out there (some allow you to step through the reductions) that might be handy for playing with while learning.
23:19:04 <tnks> hsk3: on that note, this blog post is kind of fun (though it's in Ruby, of all languages):  http://codon.com/programming-with-nothing
23:19:54 <hsk3> thanks, cool
23:20:12 <pdxleif> He covers implementing a lambda calc in this "implement haskell" series - http://dev.stephendiehl.com/fun/003_lambda_calculus.html
23:29:15 <shanemikel> pdxleif: thanks, that looks like a great blog in general
23:30:06 <shanemikel> or, author to follow anyway
23:32:29 <lamefun> Are MTL transformers n² instance-wise?
23:34:49 <paraseba> Is there a better tool than hp2ps? The fact that graphs are stacked makes them hard to read
23:38:40 <Cale> paraseba: let me know if you find anything :) It would be really nice to have an interactive heap profile viewer
23:39:53 <dmj`> paraseba: there's this: http://blog.ezyang.com/2012/11/hpd3-js-an-interactive-heap-profile-viewer/
23:41:02 <dmj`> and profiteur I think
23:41:05 <dmj`> @package profiteur
23:41:05 <lambdabot> http://hackage.haskell.org/package/profiteur
23:43:02 <paraseba> thanks, I'll take a look at those
23:50:23 <`Guest00000> hello
23:50:34 <`Guest00000> let's say I want to use [()] as numbers
23:50:58 <`Guest00000> I want those values be represented efficiently
23:51:11 <`Guest00000> as Integer, for example.
23:51:16 <`Guest00000> is this possible?
23:52:08 <xacktm> explain?  what is '[' as a number?
23:52:21 <`Guest00000> xacktm: i mean values of type [()]
23:53:08 <`Guest00000> for example, addition is ++ 
23:54:04 <`Guest00000> multiplication is liftA2 $ const $ const ()
23:59:30 <danclien> > length [(), 
23:59:31 <lambdabot>  <hint>:1:13:
23:59:32 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:59:44 <danclien> > length [(), (), ()]
23:59:45 <lambdabot>  3
