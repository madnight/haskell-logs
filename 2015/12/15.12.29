00:00:04 <ReinH> frerich: this would be like a piano teacher teaching their student to keep their hand totally flat and angled down towards the keyboard and to play notes by bending their finger only at the first knuckle so that later they could show them the proper way to play.
00:00:24 <ReinH> I don't think it's analogous to command line vs IDE at all
00:00:33 <dresuer> ReinH, I did all the fucking exercises in my home. But the exam was difficult
00:01:05 <dresuer> ReinH, http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo12.pdf <- there are exercises
00:01:05 <ReinH> it's teaching a terrible technique that engrains bad habits which will be much harder to unlearn than if nothing had been taught in the first place. :(
00:01:42 <doomrobo> dresuer, http://lpaste.net/147994
00:01:47 <ReinH> bitemyapp: halp
00:02:18 <ReinH> dresuer: which exercise is postmayor?
00:03:10 <dresuer> ReinH, http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo10.pdf
00:03:14 <dresuer> 10 
00:03:18 <ReinH> Also this weird fascination with list indices is itself problematic
00:03:54 <bitemyapp> ReinH: soup?
00:03:55 <dresuer> ReinH, 214 "Ejercicios" 3) ii.
00:04:14 <ReinH> bitemyapp: this haskell course seems pretty bad but dresuer has to pass an exam :(
00:04:18 <bitemyapp> tf
00:04:25 <ReinH> bitemyapp: it's really weird
00:04:27 <bitemyapp> dresuer: what's on the exam? When is the exam?
00:05:21 <dresuer> bitemyapp, I have to take the exam again in February
00:05:28 <bitemyapp> dresuer: what was on it?
00:05:36 <dresuer> I have time.
00:05:41 <bitemyapp> ReinH: this is a prof with a fetish.
00:05:52 <tnks> I don't get the idea this is a Haskell course.
00:05:56 <dresuer> bitemyapp, http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo08.php
00:05:58 <dresuer> http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo10.pdf
00:06:01 <dresuer> http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo11.pdf
00:06:03 <dresuer> http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo12.pdf
00:06:05 <dresuer> http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo13.pdf
00:06:08 <dresuer> http://www.fceia.unr.edu.ar/~alpi/apuntes/capitulo14.pdf
00:06:11 <bitemyapp> alright dude
00:06:12 <dresuer> That
00:06:20 <frerich> ReinH: A piano teacher tries to teach you playing the piano though. These PDFs however clearly don't intend to teach you Haskell, they try to teach you reasoning and program derivation. At least I didn't see any mentioning of 'Haskell' or '::' or other typical Haskell'ish artefacts in either of the two PDFs.
00:06:20 <bitemyapp> I don't have *that* much time
00:06:41 <ReinH> bitemyapp: for example, there are exercises like "xs is a non-empty list of boolean elements with at least one True element, write a function to ..."
00:06:52 <frerich> ReinH: So I totally agree that with a statically typed language, there are better means to encode such pre/post conditions, but I bet this stuff is language agnostic.
00:07:02 <ReinH> bitemyapp: so naturally dresuer is writing things like foo xs | length xs > 0 = ...
00:07:05 <dresuer> frerich, exactly
00:07:10 <bitemyapp> reminds me of Eiffel.
00:07:24 <bitemyapp> or a desperate Clojure programmer
00:07:37 * hackagebot filepath 1.4.1.0 - Library for manipulating FilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-1.4.1.0 (NeilMitchell)
00:07:37 * hackagebot c-storable-deriving 0.1.3 - Generate C-like storable instances from datatypes  https://hackage.haskell.org/package/c-storable-deriving-0.1.3 (MatthewMaurer)
00:07:41 <frerich> ReinH: And since it's not even trying to teach proper Haskell (who decided to even use Haskell for this in the first place?), I think it's not fair to claim that it's doing things "the wrong way"
00:07:51 <ReinH> bitemyapp: and then it asks to write partial functions that assume the preconditions are true
00:08:08 <ReinH> frerich: you have a point
00:08:54 <doomrobo> dresuer, is the solution I sent you satisfactory?
00:08:56 <ReinH> I wouldn't even use Haskell for this.
00:09:15 <ReinH> If you aren't using their mathematical notation and the proof schema they intend, you probably aren't doing it right anyway
00:09:18 <bitemyapp> dresuer: what programming language are you most comfortable in?
00:09:37 <dresuer> bitemyapp, C
00:09:47 <bitemyapp> dresuer: what do they want you to write the answers in?
00:10:31 <bitemyapp> I find it hard to believe the prof dumped this on the students without a suggestion or prerequisite set of languages.
00:10:39 <dresuer> bitemyapp, 
00:10:39 <dresuer> It's like a generalization, It is not specific language
00:10:53 <bitemyapp> dresuer: what did you write your answers in the last time you attempted the exam?
00:10:59 <dresuer> generalization of functional languages
00:11:16 <bitemyapp> okay, this is getting more specific though
00:11:19 <tnks> so I looked at the PDF. . . I really think it's more about proof and invariants -- and not really about Haskell at all.
00:11:21 <bitemyapp> they want something FP-y right?
00:11:25 <dresuer> the notation that is used is the one in this document
00:11:36 <ReinH> bitemyapp: they use an abstract language with a notation like fac.(n+1) = fac.n×(n+1)
00:11:42 <tnks> it could definitely do better about not hand-waving partial functions, but I don't think that's the foundation of the lesson.
00:12:00 <dresuer> ReinH, exactly
00:12:21 <ReinH> and with proof steps that look like (∏ i : 0 < i ≤ n + 1 : i)
00:13:05 <ReinH> And some extra notation for size of a list and indexing.
00:13:08 <ReinH> It's strange.
00:13:12 <dresuer> ReinH, It's not like Haskell, if you enter a guard will not fit the other.
00:13:23 <ReinH> I wouldn't use Haskell for this at all.
00:13:30 <ReinH> I'd work within this notational system they have created for you
00:13:48 <dresuer> In this language enter in all guards
00:13:53 <dresuer> It's like
00:13:55 <dresuer> if 
00:13:55 <dresuer> if 
00:13:56 <dresuer> if
00:13:57 <dresuer> not
00:13:59 <dresuer> if 
00:14:00 <dresuer> else if
00:14:02 <dresuer> and 
00:14:02 <dresuer> else
00:14:03 <ReinH> The haskell solutions probably wouldn't pass your test and the solution that passes your test wouldn't be good haskell
00:14:16 <bitemyapp> Tend to agree with Rein here.
00:14:30 <doomrobo> dresuer, do it in Rust, then
00:14:32 <bitemyapp> learning Haskell might help, but you wouldn't be able to use it on your test and probably isn't the most efficient use of your time.
00:14:49 <ReinH> Translating (Σ i : 0 ≤ i < #(x ⊲ xs) : (x ⊲ xs).i) into Haskell is just dreadful.
00:14:55 <tnks> dresuer: did the professor mention that this should be done in Haskell?
00:15:17 <tnks> seems like it's designed to just be done by hand with no automated checking.
00:15:20 <dresuer> tnks, never. But I test my program with Haskell
00:15:23 <ReinH>  tnks yep
00:15:34 <ReinH> this is computer science, not software engineering!
00:15:38 <ReinH> no computers required
00:15:39 <tnks> yeah.
00:15:48 <dresuer> ReinH, (y)
00:15:54 <dresuer> I'm a computer science student.
00:15:56 <tnks> I'm pretty sure I had something similar when exposed to Hoare triples for the first time.
00:16:18 <frerich> dresuer: This discussion only comes up because with statically typed languages, there are two moments when you can have your pre/post conditions verified: at build time and at runtime. Doing it at 'build type' means encoding your conditions using types. Haskell has a fairly expressive type system (and a community which cares about correctness) so *not* expressing such things using types is frowned upon by some.
00:16:36 <frerich> dresuer: In C, nobody would even blink if you didn't whip up nice types but rather checked everything at runtime. ;-)
00:17:40 <ReinH> Well yes, C doesn't have nice types, so there's nothing to whip up. :p
00:18:40 <ReinH> dresuer: checking your work in Haskell means writing a whole new solution in Haskell and then proving (to your satisfaction) that it is equivalent to your solution
00:18:47 <ReinH> Doesn't seem either efficient or reliable
00:19:00 <joco42> ReinH: I cleaned up the example and put it to pastebin: http://lpaste.net/147997
00:19:05 <ReinH> just seems like double the work
00:19:30 <joco42> what kind of GADT+TypeFamily magic can make something like this work?
00:19:37 <ReinH> joco42: do you understand the limitations of DataypteContexts?
00:19:44 <ReinH> (namely that they don't work?)
00:20:05 <joco42> ReinH: no, I don't understand it
00:20:20 <ReinH> joco42: http://stackoverflow.com/questions/7438600/datatypecontexts-deprecated-in-latest-ghc-why
00:20:32 <joco42> ok
00:20:50 <joco42> is there some other way I could make something like this work?
00:21:29 <joco42> I don't know the power of TypeFamilies really and GADTs
00:21:30 <ReinH> The only thing data Ord a => Foo a = Foo a does is require you to also specify Ord a => Foo a everywhere you use Foo.
00:21:51 <ReinH> You'd like GHC to pack up that constraint and keep it around so it can apply it at use sites for you, but it won't do that.
00:21:52 <joco42> ok
00:21:54 <joco42> i see
00:22:08 <ReinH> You can usually use GADTs instead.
00:22:23 <ReinH> data Foo a where Foo :: Ord a => a -> Foo a
00:22:28 <joco42> ok, i can look into that...
00:23:10 <ReinH> With the GADT version, the Ord constraint obtains when a value is created and is then carried along to use sites, where pattern matching pulls it back out.
00:23:22 <dresuer> I understood, thank you all.
00:23:25 <joco42> yeah... that sounds like something i want
00:23:29 <ReinH> dresuer: good luck
00:24:02 <ReinH> dresuer: come back after you pass your exam and you want to learn haskell ;)
00:24:12 <joco42> ReinH:  so, GADTs might help me here? i can read up on that ...
00:24:40 <ReinH> Well, DatatypeContexts won't help, and the solution for that is to use GADTs
00:24:42 <ReinH> so... maybe?
00:24:48 <joco42> ok, cool
00:25:00 <ReinH> GADTs are already one of the ways for implementing this sort of proxy stuff anyway
00:25:21 <dresuer> I'll study like a fucking crazy.
00:25:23 <dresuer> I want to pass the exam now now!
00:25:23 <joco42> yeah, proxy is the thing
00:25:40 <ReinH> dresuer: just focus on the math, don't worry about computing anything ;)
00:27:17 <dresuer> ReinH, 
00:27:18 <dresuer> I have to take a test of linear algebra also
00:27:25 <dresuer> http://www.fceia.unr.edu.ar/lcc/r211/archivos/AL2013-PR3.pdf
00:27:31 <dresuer> http://www.fceia.unr.edu.ar/lcc/r211/archivos/AL2013-PR2cont.pdf
00:27:38 <dresuer> http://www.fceia.unr.edu.ar/lcc/r211/archivos/AL2013-PR2.pdf
00:28:00 <dresuer> :D It is more fun
00:28:24 <dresuer> http://www.fceia.unr.edu.ar/lcc/r211/archivos/AL2013-PR1_parte2.pdf
00:29:01 <ReinH> dresuer: please don't spam us with links
00:29:10 <dresuer> ok, sorry.
00:29:13 <ReinH> np
00:29:51 <joco42> dresuer:  this stuff is good stuff... but it needs time...
00:31:03 <joco42> and all this stuff is super useful... linalg...
00:36:49 <dresuer> joco42, I just passed Mathematical Analysis 2
00:37:28 <dresuer> joco42, http://www.fceia.unr.edu.ar/lcc/r122/archivos.php
00:37:31 <joco42> dresuer:  yeah, math is pretty useful stuff... in general, goes well with haskell
00:37:46 <dresuer> yeah 
00:38:48 <joco42> i think you can get decent paying jobs with math knowledge
00:39:43 <dresuer> In my career there are many mathematicians, because studying Computer Science is like studying mathematics
00:40:14 <dresuer> Like Alan Turing haha
00:40:17 <joco42> there is only 2 problem with Computer Science :)
00:40:35 <joco42> the word Computer and the word Science ...
00:40:53 <zv> "producto interno"
00:40:55 <zv> :)
00:40:58 <zv> spanish math!
00:41:14 <zv> "espacio vectorial"
00:41:26 <dresuer> Yeah ... it's a long discussion. Is computer science a science'
00:41:28 <dresuer> ?
00:41:35 <dresuer> zv, así es !
00:41:42 <dresuer> Hablas español?
00:41:46 <zv> no
00:41:52 <zv> enough to ask for directions
00:41:52 <dresuer> jajajaja
00:42:23 <dresuer> Bueno.
00:42:33 * hackagebot cmark 0.5.0 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.0 (JohnMacFarlane)
00:42:35 <dresuer> ¿y entendés los que hablo?
00:42:50 <zv> do I understand what you say?
00:42:54 <zv> si?
00:43:05 <dresuer> Perfecto!
00:43:38 <zv> now I can write a haskell program to translate spanish to english!
00:43:38 <joco42> https://github.com/strangeloop/StrangeLoop2015/blob/master/transcripts/Philip%20Wadler%20StrangeLoop%209-25-15.txt#L104
00:44:33 <zv> informatics is a much better word
00:44:46 <zv> I think 'computer' is a dumb word itself
00:44:53 <joco42> computer science....
00:46:36 <dresuer> zv, computer science = "Theoretical Computer Science"
00:46:55 <dresuer> Kurt Gödel, Alan Turing
00:47:15 <shafox> Is there any package for lucene implementation in haskell?
00:58:08 <drewbert> How do I say that I want to read the same string that I show?
01:02:48 <liste> drewbert in what context? read (show x) == x ?
01:06:26 <drewbert> Making non-derived instances for a simple data type.  data MyDataKey = MyDataKeyFoo | MyDataKeyBar | MyDataKeyBaz.  I can "instance Show MyData where { show MyDataKeyFoo = "foo"; show MyDataKeyBar = "bar"; show MyDataKeyBaz = "baz" }"  How would I make a read instance for MyDataKey such that I'm not repeating those strings, or assigning them to variables and referencing them in a type-unsafe way?
01:08:45 <pavonia> Why are you even making a non-derived instance here?
01:09:49 <ReinH> There have been various suggestions for alternatives to "computer science" https://en.wikipedia.org/wiki/Computer_science#Name_of_the_field
01:10:23 <ReinH> Computer science distinguishes itself as a field by being neither about computers nor a science.
01:12:26 <drewbert> pavonia: To serialize in a manner compatible with a third party api.
01:13:01 <liste> drewbert you shouldn't be using Show for that
01:15:27 <drewbert> liste: great, thanks for providing me with an alternative direction to take
01:15:57 <merijn> drewbert: Just write a function "Foo -> String"?
01:16:01 <liste> why not just have your serialize ::
01:16:32 <liste> "deserialize :: String -> Foo" and "serialize :: Foo -> String" ?
01:17:34 <drewbert> Is there a way I can define deserialize to make against what I've defined in serialize?
01:17:52 <liste> you can use 'serialize' in 'deserialize'
01:18:32 <liste> (you could also use 'show' in 'read' if you decide to use Read anyway (: )
01:18:34 <drewbert> | input == (serialize MyDataKeyFoo) = MyDataKeyFoo
01:18:36 <drewbert> ?
01:18:44 <liste> for example
01:18:48 <liste> though it's not very efficient
01:19:12 <liste> (I think ?)
01:19:16 <merijn> Show and Read are terrible for (de)serialisation
01:19:20 <ReinH> drewbert: you can look into invertible parsers / serializers
01:19:23 <merijn> Read is slow as hell
01:19:45 <ReinH> drewbert: something like https://hackage.haskell.org/package/roundtrip
01:21:06 <drewbert> ReinH: Awesome!! Hrmm, now do I want roundtrip or boomerang?
01:22:41 <drewbert> I wish there was an Aeson class for invertible (de)serilization.
01:23:52 <ReinH> drewbert: probably at lesat one of them
01:24:14 <ReinH> drewbert: like https://hackage.haskell.org/package/roundtrip-aeson ?
01:24:34 * ReinH drops mic
01:25:47 <drewbert> ReinH: Heck... yes...... Now, if only I can find a way to do so conveniently without relying on template haskell.
01:25:57 <ReinH> wellllll
01:26:18 * drewbert keeps shifting that goalpost.
01:26:55 <ReinH> Wait, that doesn't use template haskell
01:27:16 <ReinH> you just write your instance in a seemingly pretty typical applicative combinator style
01:31:19 <drewbert> The defineIsomorphisms step is not necessary?
01:34:35 <ReinH> Oh. Maybe it is.
01:35:05 <ReinH> I suppose I should offer the caveat that I have never tried these packages and have no idea if they even work.
01:38:30 <drewbert> Well, all template haskell does is generate haskell.  And it looks like define isomorphisms only saves you a few lines (provided you don't have hundreds of constructors for your types), so I should just be able to hand-write my isomorphisms if I don't want to take a dependence on TH.
01:40:04 <drewbert> This is a definitely interesting and hopefully more clean and type safe direction than writing separate Read/Show, Serialize/Deserialize, or, most importantly ToJson/FromJson instances for my types.
01:40:52 <drewbert> Thank you very much for your help ReinH.  Also merijn, liste, and pavonia.
01:43:49 <breadmonster> Hello.
01:46:25 <liste> hello breadmonster (:
01:46:45 <breadmonster> What's up liste?
01:48:42 <liste> christmas holiday (: it's relaxing. and you?
02:39:39 <SX> Hello!
02:41:17 <SX> Could you please recommend me a protobuf lib for haskell? Which one is better/more advanced/easier to use? Or it's not worth the effort to use any of them?
02:42:42 <SX> I'd like to make fast client-server communications with smaller packet size
02:44:13 <SX> Client wouldn't be written in haskell.
02:47:04 <Erebe> I Don't know if there is an implementation of protobuff for haskell
02:47:27 <Erebe> but you can use 
02:47:39 <Erebe> Thrift
02:48:21 <Erebe> https://thrift.apache.org/lib/hs
02:49:06 <Erebe> thrift is an equivalent of protobuf
02:49:19 <Erebe> SX: bump
02:50:25 <SX> Erebe: I'll look into it, thanks!
02:50:37 <SX> I've never heard of it
02:50:55 <Erebe> it was made by facebook, if my memory is correct
02:51:13 <Erebe> and is simpler to use than protobuf
02:51:30 <SX> Erebe: there're 2 libs with protobuf implementation in haskell. But as far as I know, they're not complete.
02:52:44 <SX> Erebe: well, I don't care what to use as far as it's: fast, light, reliable, crossplatform and has implementations for C, C++, Java, Python and Haskell.
02:53:25 <Erebe> thrift is all of that 
02:53:35 <Erebe> protobuf lacks haskell offcial binding
02:54:03 <bennofs> Erebe: I remember reading that the thrift haskell binding has some perf issues
02:54:39 <Erebe> bennofs: that might be possible, not so much people use the haskell one
02:55:45 <Erebe> but I don't think that the available protobuf haskell binding are heavily in use in the wild also
02:56:11 <SX> https://github.com/alphaHeavy/protobuf and https://github.com/k-bx/protocol-buffers
02:57:06 <Erebe> looking into it
02:59:19 <Erebe> SX: they don't implents the RPC (Remote procedure calls) of protobuf
03:01:21 <Erebe> SX: so you have the serialization/deserialization but you have to implements the bindings between data and function call by yourself
03:07:08 <SX> Erebe: is it a big problem? I can write bindings my self anyway.
03:07:58 <Erebe> no big deal, you can still do it by yourself
03:11:02 <SX> Erebe: https://github.com/k-bx/protocol-buffers/issues/9 there's actually a WIP to implement RPC
03:12:34 <Erebe> well you will have to try it :)
03:12:37 <SX> Erebe: so what's the significant difference between Thrift and Protobuf?
03:13:44 <meditans> what's wrong with the pattern `pattern Button b y = EventKey b Down noModifiers (0,y)`
03:13:54 <meditans> the relative datatype is here http://hackage.haskell.org/package/gloss-1.9.4.1/docs/Graphics-Gloss-Interface-IO-Game.html#v:EventKey
03:14:10 <meditans> and I get the error Right-hand side of bidirectional pattern synonym cannot be used as an expression
03:20:06 <Erebe> SX: http://old.floatingsun.net/articles/thrift-vs-protocol-buffers/
03:20:14 <Erebe> SX: I am going to lunch
03:27:31 <ocharles__> Does anyone know how to get cabal to have access to OpenGL include files when compiling c-sources?
03:28:19 <ocharles__> I have extra-libraries: GL in my .cabal file, but when it compiles c-sources it doesn't seem to be supplying -lGL or anything
03:28:56 <ocharles__> oh, it does work with pkgconfig-depends
03:39:11 <pavonia> ocharles__: There's --extra-include-dirs the header files
03:39:18 <pavonia> +for
03:39:22 <ocharles__> pavonia: 
03:39:24 <ocharles__> whoops
03:39:31 <ocharles__> yea, cabal configure corrected me there :)
03:45:41 <Skuzzzy> ocharles__: no its not
03:49:41 <ocharles__> ?
04:01:09 <Skuzzzy> what ur fav number?
04:24:45 <Szpon> hey, just wanted to say hi - I've started learning haskell recently (as a total noob)
04:30:27 <dredozubov> hi
04:31:57 <SX> Erebe: Protobuf implementation is closer to native haskell style. Don't know about performance, but generated code is much better imo.
04:45:18 <SX> Erebe: and Thrift requires Network package and has it's own transport implementation. I better make my own transport.
05:00:26 <maerwald> what a pity, there is no trifunctor :D
05:01:36 <bitemyapp> maerwald: #opportunity
05:01:48 <bitemyapp> I'll just apply induction and invent the N-functor
05:01:55 <bitemyapp> then nobody can beat me
05:03:25 <maerwald> sounds reasonable
05:05:52 <maerwald> while at it, do CurryN for Data.Tuple.Curry... it only goes to a32
05:08:37 <maerwald> and no cheating with TH
05:49:37 <roelof> I wonder if I really need list comprehension to solve this problem : http://lpaste.net/148008. Can this not be done with a if then and repeat ? 
05:53:24 <MasseR> I would probably use guards instead of if-then-else
05:54:03 <liste> roelof I can think of many solutions
05:54:18 <Xandaros> I'd personally use replicate
05:54:50 <roelof> The guards also look good to me. Then I can check for negative numbers or numbers greater then 12 
05:56:16 <roelof> liste:  I think you can. There are always more ways to solve a problem 
05:56:20 <liste> replicate seems works fine without guards too
05:56:29 <liste> or if
05:56:57 <MasseR> Hm... I might have not understood the question properly. How would you do it with replicate?
05:57:39 <roelof> replicate 12 - length s  ++ s . Where s is the string
05:58:15 <Xandaros> I just did "pushRight n s = replicate (n - length s) ' ' ++ s". This obviously doesn't work for infinite lists, though
05:58:24 <MasseR> Ah, the task is to create exactly 12 character string?
05:59:04 <Xandaros> Oh right. You don't actually get the length. I assume it's a global constant, then
06:03:37 <roelof> yep, the length is given, Next challenge is that the length will be given by a user 
06:04:02 <roelof> so my idea is right to use replicate instead of list comprehension ? 
06:10:57 <Xandaros> Probably a matter of personal preference, but I don't like list comprehensions that much. Sometimes they are really neat and elegant, but most of the time I find myself preferring combinators
06:14:32 <zoku> as a mostly python developer i love list comprehensions
06:14:33 <zoku> hehe
06:15:51 <srhb> zoku: Fun, that Python feature was inspired by Haskell :)
06:15:59 <srhb> afair.
06:16:37 <ptrx> Hello, i never did Haskell, so this is my a stupid question, but if i write a program in Haskell and compile it, will this program only run on the architecture where it got compiled on or is it kinda cross-plattform compatible?
06:16:59 <MasseR> The former
06:17:34 <srhb> ptrx: Cross compiling is still a bit messy, I believe. It's easier to just bring the source to the target architecture and build it there, if you want to distribute binaries.
06:17:47 <ptrx> Are there services to make it cross-plattform compatible?
06:18:13 <mauke> what, a single executable? no
06:18:14 <MasseR> ptrx: docker helps a bit
06:18:23 <maerwald> you also have to write the program cross-platform compatible. It's not just about compiling
06:18:28 <mauke> there are no cross-platform executables
06:18:41 <ptrx> hmm ok i understand, thank you all for the answers! =)
06:19:02 <Xandaros> maerwald: Which, luckily, is a fair bit easier in Haskell than, say, C
06:19:11 <maerwald> depends
06:19:40 <Xandaros> Although I have to admit, I don't really care about cross-platform compatibility. If it runs on my machine, I'm happy :P
06:25:31 <maerwald> things like the directory package actually make it harder to write cross-platform code, because a lot of functions are semi-defined in the sense that people tried to map different concepts into the same set of functions, which sometimes doesn't work
06:25:59 <chloe_2> $59? Really? Wow.
06:27:16 <Rizy> what 59?
06:27:19 <MarcelineVQ> Not bad eh? I remember just one of my course books costing over 90 :(
06:27:49 <keko-2> was there a netsplit or something?
06:28:06 <keko-2> I have no idea what that was in response to
06:28:20 <MarcelineVQ> I took a guess :>
06:29:09 <maerwald> sometimes, high-level approaches are backwards for cross-platform compatibility
06:29:33 <maerwald> and you don't have any high-level problems with C lol
06:30:11 <MarcelineVQ> "If you like structs I have the perfect language for you!"
06:33:50 <Xandaros> roelof: I assume your question earlier was about an assignment or homework or something? Have a general tip for working with lists: Make sure it works with empty and infinite lists, too. If it's not supposed to work with empty lists, make an explicit call to "error" and if it's not supposed to work with infinite ones, put a comment. Try to avoid writing partial functions, though. They smell ;)
06:34:37 <mniip> edwardk: poke, you mentioned something about hyperfunctions creating an isomorphism between X and (X -> Bool) -> Bool, which is quite a controversial result. Did anything ever come out of that?
06:34:50 <maerwald> and then you wonder where the haskell binding for "realpath" is in the unix package, until you find out that there is none, because people use canoncializePath from the directory package, which again is semi-defined
06:35:30 <MarcelineVQ> maerwald: Now's your chance to make a better mousetrap :>
06:35:42 <maerwald> ?
06:36:01 <Xandaros> mniip: What is this magic?
06:36:24 <ptrx> maerwald, would you say, that it could be more beneficial to program for a vm like the jvm, which is supported on many platforms, for achieving cross-plattform compatibility?
06:36:48 <mniip> Xandaros, classical kmett magi
06:36:49 <mniip>  
06:36:51 <mniip> c
06:38:54 <maerwald> ptrx: that depends on the problem really. You can probably do a cross-platform high-level GUI library, because the interface between GUI and the window manager isn't something that the GUI programmer cares about. But if it's about things that are platform-specific like the filesystem, then that will always lead to weird functions.
06:39:00 <Xandaros> mniip: I've seen a lot of kmett magic. His name is on every other package I use, after all. But that must surely be beyond the possible, even for him...
06:39:55 <maerwald> and in haskell, you have to deal with bindings then which you probably have to write yourself even
06:40:16 <maerwald> in C it's just a lot of #ifdef hackery, but relatively easy
06:40:20 <Xandaros> mniip: Consider X = Void. (Though I admittedly have no idea what a hyperfunction is)
06:44:40 <roelof> Xandrox. Then my solution with repeat do not work. I think it's not working with infinitive list. And yes, it's a challenge from the Craft of functional priogramming
06:45:26 <roelof> What do you mean with partial functions. I did not learn the difference between normal and  partial functions yet 
06:46:18 <mjburgess> a partial function is just one  not defined for all its outputs
06:46:20 <Xandaros> roelof: A partial functions is a function is bottom (crashes/hangs) for some of the input
06:46:27 <mniip> Xandaros, though there are 2 functions in (Void -> Bool) -> Bool
06:46:43 <mjburgess> +  is defined for all integers,      /   is not
06:46:51 <mjburgess> eg. 0/0  is undefined
06:46:55 <roelof> Xandros : like head  ?  
06:46:59 <hpc> > 0/0
06:47:01 <lambdabot>  NaN
06:47:03 <Xandaros> roelof: You got it! :)
06:47:07 <mniip> :t 0/0
06:47:09 <lambdabot> Fractional a => a
06:47:21 <hpc> 0/0 is sometimes defined, due to ridiculous IEEE stuff
06:47:26 <Xandaros> roelof: Also last, which returns the last element of a list. (Try that on an infinite list)
06:47:26 <exio4> > 0 `div` 0
06:47:28 <lambdabot>  *Exception: divide by zero
06:47:39 <exio4> there, a sane version 
06:48:05 <roelof> Xandaros : So I better use a list comprehension on my challenge then a repeat   and a ++ ? 
06:48:38 <Xandaros> mniip: Of course, but if you find an isomorphism from absurd to an inhabitant of Void, then... you found an inhabitant of Void. Which goes against its definition (ignoring undefined)
06:48:39 <roelof> Xandraros : Cannot work. a infinitive list has no last item 
06:48:53 <Xandaros> roelof: Yes, last on an infinite list hangs.
06:49:07 <exio4> there are lot of functions on lists which fail in the infinite case
06:50:06 <roelof> Xandraros : but back to my challenge . Is repeat  ...  ++ s a bad solution then ? 
06:50:18 <ralu> i am trying to figure out how this cabal build works. I am tryng to crosscompile some packages but half of them are broken for crosscompile is there any solution for this mess?
06:50:41 <maerwald> Depends on the definition of last and the structure of the list. An infinite doubly-linked list can very well have a last element.
06:51:31 <exio4> length, last, foldl, sort, scanr, ... 
06:51:44 <exio4> all/and might fail 
06:51:50 <Xandaros> roelof: Well. In this particular case, you might be fine with it not working on infinite lists. If you want it to also work on infinite lists, my approach would probably be to have a length function that takes a maximum length in addition to the list
06:52:10 <Xandaros> maerwald: In Haskell. In the Prelude.
06:52:13 <exio4> elem/elemIndex/etc also might fail 
06:52:33 <roelof> oke, so lists are not the best way to use in a programm when working on a lot of data 
06:53:28 <maerwald> well, they are lazy, so depends
06:53:48 <exio4> roelof: lists are used a control data structure in Haskell, when you work with one/few element(s) at once and "throw them away" quite soon
06:54:29 <roelof> Xandraros : so check if the s is bigger then  lets say 12  cut it to 12  so the outcome is never bigger then 12 
06:55:15 <roelof> exio4:  thanks, just learn about lists. Craft has some 3 chapters about them and 1 on strings and integers 
06:56:36 <maerwald> You can use lists for large things too, it really depends. E.g. I once parsed a mesh file of ~120mb into my own data structure with lists as helpers. That scaled very well, only at some point not. I replaced the list with Data.IntMap.Lazy there, but kep the others.
06:56:48 <exio4> roelof: note that, a list isn't a bad data structure on its own, they have O(1) cons after all, so if your program has to cons a lot, pretty sure a list might be what you want 
06:57:11 <exio4> maerwald: I normally use the "strict-head lazy-tail" trick for lists
06:59:21 <roelof> oke, what about a solution like this for my challenge.   if s >= 12 then  take 12 s  else repeat (12 - length s) " " ++ s  
06:59:41 <roelof> Can this idea work for infinitive lists 
07:00:35 <Xandaros> You probably meant "if length s >= 12" - that won't work. It calculates the length of the list, which it won't ever be able to do if the list is infinite
07:01:18 <ggole_> You could write is_length_n_or_greater and use that
07:01:28 <roelof> Xandaros:  oke, back to the manuals / books 
07:01:45 <aweinstock> :t null.drop
07:01:47 <lambdabot>     No instance for (Foldable ((->) [a0])) arising from a use of ‘null’
07:01:47 <lambdabot>     In the first argument of ‘(.)’, namely ‘null’
07:01:47 <lambdabot>     In the expression: null . drop
07:02:40 <mauke> :t (null .) . drop
07:02:42 <lambdabot> Int -> [a] -> Bool
07:03:03 <Xandaros> Interesting idea. I like it
07:03:14 <aweinstock> > (null .) . drop $ 3 [1..5]
07:03:15 <lambdabot>      No instance for (Num ([t0] -> Int))
07:03:15 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
07:03:15 <lambdabot>        arising from the literal ‘3’
07:03:44 <aweinstock> > ((null .) . drop) 3 [1..5]
07:03:46 <lambdabot>  False
07:03:50 <aweinstock> > ((null .) . drop) 6 [1..5]
07:03:51 <lambdabot>  True
07:03:57 <aweinstock> > ((null .) . drop) 6 [1..]
07:03:58 <lambdabot>  False
07:04:41 <roelof> aweinstock:  what are you trying to do ? 
07:05:02 <maerwald> is_length_n_or_greater n xs = isJust . atMay xs $ (n - 1)
07:05:28 <dhz_> > ((null .) . drop) 6 [1..5]
07:05:30 <lambdabot>  True
07:05:35 <dhz_> > (null . drop) 6 [1..5]
07:05:37 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
07:05:37 <lambdabot>                  with actual type ‘Bool’
07:05:37 <lambdabot>      The function ‘null . drop’ is applied to two arguments,
07:06:25 <dhz_> > (null . drop 6) [1..5]
07:06:27 <lambdabot>  True
07:07:10 <roelof> maerwald:  Thanks but I did not learn about isJust and Atmay yet. So your solution for me is not understandable 
07:07:57 <maerwald> roelof: isJust checks if the constructor is Just, atMay is a safe version of !! which returns Maybe elem
07:08:29 <roelof> oke, so I have a lot to learn 
07:08:50 <maerwald> so it just tries to index the "length" you supplied, if that fails (because the list is shorter), then it returns Nothing and isJust will return False
07:09:15 <Xandaros> I think I like the drop version better. In my opinion it's more obvious what it is supposed to do
07:09:17 <roelof> I think I settle now with the version which not work with infinitive lists and try later to make that also work when I have learned more about Haskell 
07:10:00 <oisdk_> longer = foldr (\_ a n -> 1 >= n || a (pred n)) (const False)
07:10:12 <maerwald> Xandaros: except that the pointfree style will confuse him
07:10:21 <srhb> roelof: Why not use the (\n -> not . null . drop n) version? It's much nicer and doesn't use length.
07:10:26 <dhz_> drop works with infinite lists
07:11:05 <Xandaros> maerwald: is_length_n_or_greater n xs = null (drop n xs) :P
07:11:39 <roelof> srhb:  I can do that as soon as I figured out what null . drop n does and what is n 
07:11:57 <Xandaros> n is the length you are checking against (12)
07:11:59 <srhb> > drop 4 [1..5]
07:12:01 <lambdabot>  [5]
07:12:07 <srhb> > null (drop 4 [1..5])
07:12:09 <lambdabot>  False
07:12:27 <srhb> null is True iff its argument is an empty list.
07:12:29 <Xandaros> drop n xs removes the first n elements from the list xs
07:12:44 <roelof> oke 
07:12:49 <Xandaros> (so drop 12 xs is xs without the first 12 elements)
07:13:08 <dhz_> i think this will be fruitless if he doesn't know yet what a variable is
07:13:55 <roelof> oke, so I can check if the string is bigger then 12 . if its nill then the string is bigger then 12 if I understand it well 
07:14:06 <maerwald> nil?
07:14:11 <maerwald> string?
07:14:46 <roelof> Sorry, I use the wrong things 
07:14:54 <srhb> If you drop 12 on a String and you get back a non-empty String, null on that String is False.
07:15:05 <srhb> Because the result is not empty.
07:15:27 <srhb> > null (drop 3 "abc")
07:15:29 <lambdabot>  True
07:15:30 <srhb> > null (drop 3 "abcd")
07:15:32 <lambdabot>  False
07:15:41 <roelof> What I mean to say it that null . drop 12 xs  is False if the user entered a string longer then 12  
07:15:48 <srhb> Right :)
07:15:55 <srhb> Except syntax.
07:16:06 <dhz_> drop 3 -> "drop 3 characters" null -> "checks if the string is empty"
07:16:13 <srhb> (null . drop 12) xs
07:16:31 <srhb> Well, not syntax. Arguments morelike.
07:17:07 <roelof> I was refering to this one ; (\n -> not . null . drop n)   version 
07:17:39 <maerwald> yes, he wanted is_length_n_or_greater
07:17:50 <maerwald> > null (drop 2 [1,2,3])
07:17:51 <lambdabot>  False
07:17:57 <srhb> roelof: Sure, I was just pointing out that `null . drop 12 xs` is an error
07:18:00 <csd_> Hi can someone please walk me through how this code snippet works (primesPE) https://wiki.haskell.org/Prime_numbers#Postponed Specifically I am confused by the recursive definition of oddprimes
07:18:35 <maerwald> so it doesn't really do what he wants yet
07:19:29 <roelof> This better : null ( drop 12 xs)  == False  
07:19:36 <maerwald> still doesn't work
07:19:47 <maerwald> > not $ null (drop 3 [1,2,3])
07:19:48 <lambdabot>  False
07:19:52 <maerwald> this should give True
07:20:15 <Xandaros> huh? why?
07:20:17 <hyPiRion> why?
07:20:27 <maerwald> is_length_n_or_greater
07:20:30 <srhb> roelof: maerwald is pointing out that you need to do some slight arithmetic if you want the "or"
07:20:41 <aweinstock> > let x = 1:x in x -- csd_
07:20:42 <maerwald> he wants to know if the list has length 3 or greater
07:20:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:20:43 <maerwald> it has
07:20:54 * hyPiRion should probably read the context
07:21:02 <maerwald> my version was correct btw ;)
07:21:24 <aweinstock> > let x = 1 : map (*2) x in x
07:21:26 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:21:43 * roelof gets more and more confused 
07:22:05 <maerwald> > (\n xs -> isJust . atMay xs $ (n - 1)) 3 [1,2,3]
07:22:07 <lambdabot>  Not in scope: ‘atMay’
07:22:07 <oisdk_> csd_ do you understand how the seive parrt works?
07:22:10 <maerwald> meh
07:22:27 <Xandaros> maerwald: For his particular problem it doesn't really matter. Whether he adds 0 spaces or trims the string to length it already is...
07:22:47 <csd_> oisdk_: i think so; the oddprimes part has stolen most of my focus
07:23:06 <maerwald> Xandaros: I know, I'm just saying the other version is still not correct
07:23:34 <mniip> > let x = 1 : scanl (+) x in x
07:23:35 <lambdabot>      Couldn't match expected type ‘[a1]’
07:23:35 <lambdabot>                  with actual type ‘[[a1]] -> [[a1]]’
07:23:35 <lambdabot>      Relevant bindings include x :: [a1] (bound at <interactive>:1:5)
07:23:40 <mniip> > let x = 1 : scanl (+) 1 x in x
07:23:40 <roelof> and I do not know anymore which one is the right one 
07:23:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:24:41 <srhb> roelof: Guess you'll have to think a bit then. You have the building blocks, you just need to decide whether it's True if it's strictly longer than n, or if it's n or greater long.
07:25:10 <csd_> aweinstock: that seems like a slightly easier example to understand as there isn't the explicit recursion in the case of oddprimes, no?
07:26:02 <roelof> For me it's good when bigger then 12 . When it's 12 nothing has to happen in my oponion 
07:26:11 <srhb> roelof: Well, there you go.
07:27:48 <roelof> srhb:  then the drop version is the one for me ? So null (drop 12 xs) == False 
07:28:09 <srhb> roelof: Well, what is drop 12 xs if xs is 12 long?
07:29:05 <roelof> drop 12 "aaaaaaaaaaaa"
07:29:41 <srhb> You need to prefix with "> "
07:29:47 <srhb> > drop 12 [1..12]
07:29:49 <lambdabot>  []
07:29:54 <srhb> And what is null [] ?
07:30:13 <roelof> a emptys string 
07:30:16 <srhb> Surely not
07:30:17 <roelof> so not null 
07:30:18 <srhb> :t null
07:30:19 <lambdabot> Foldable t => t a -> Bool
07:30:32 <srhb> It is False, yes.
07:30:39 <srhb> And False == False ?
07:30:49 <Xandaros> > null []
07:30:51 <lambdabot>  True
07:30:55 <srhb> Oh, derp
07:30:56 <Xandaros> just saying
07:30:57 <srhb> I mixed them over
07:30:58 <ben> That would read a lot better if it was Foldable [] => [a] -> Bool
07:30:59 <srhb> Thanks
07:31:10 <srhb> It's True, of course, because [] is indeed the empty list.
07:31:26 <srhb> So True == False ;)
07:31:33 <roelof> nope
07:31:50 <srhb> So now the question is: is that the behaviour that you want?
07:32:26 <roelof> nope, So I have to read the whole discussion again 
07:32:45 <srhb> roelof: You could make do with what we have just done, really.
07:33:14 <Erebe_> :t atMay
07:33:16 <srhb> Specifically, think of what you want to do with the result of null [] vs null "foobar"
07:33:16 <lambdabot> Not in scope: ‘atMay’
07:33:30 <roelof> I see one wierd thing. when I do drop 12 "aaaaaaaaaa"   I see ""  instead of null or [] 
07:33:36 <srhb> roelof: They're the same
07:33:43 <roelof> oke 
07:33:44 <srhb> roelof: "" is an alias for []
07:33:49 <srhb> null is a function, though
07:34:05 <srhb> It takes a list, and if the list is empty, return True. If the list is nonempty, it returns False
07:34:54 <sgronblo> is there an easy way to do a for loop where you mutably update a 2d array?
07:34:55 <Erebe_> mempty == []
07:35:14 <Erebe_> null $ mempty == []
07:35:42 <dhz_> sgronblo forM/forM_
07:36:00 <srhb> sgronblo: forM?
07:36:04 <srhb> Oh, too slow.
07:36:12 <apsod> sgronblo: you might want to look at Data.Array.ST
07:36:15 <dhz_> (which is just flipped mapM*, but more convenient if action is a do block)
07:36:50 <roelof> oke, I did some experiments on ghci. When the length is smaller or equal to 12. The function null(drop 12 xs) is True 
07:37:01 <srhb> roelof: That's right.
07:37:01 <roelof> When it's bigger then 12 then the outcome is False 
07:37:16 <srhb> roelof: Yes. :)
07:37:36 <sgronblo> dhz_: srhb ok ill have a look, i would like haskell to give me the option sometimes to code some algorithm that would be dirt simple when doing it imperatively and immutably with say python.
07:37:48 <srhb> sgronblo: That's what ST is for.
07:37:54 <srhb> If you're just mutating data. :)
07:38:04 <sgronblo> ST /= State?
07:38:05 <srhb> sgronblo: But forM is no harder than any other for loop, really.
07:38:12 <srhb> sgronblo: ST is strict mutable state threads
07:38:20 <roelof> hmm, but with 12 I do not have to put spaces for it because the length is already 12  so repeat is not necessary 
07:38:42 <roelof> when it's less then 12 then repeat has to put spaces before it 
07:38:52 <srhb> roelof: Stick to the concrete function we're building.
07:39:01 <srhb> roelof: You've now determined when it gives True and when it gives False. 
07:39:20 <srhb> roelof: Now, what did you WANT it to do?
07:39:23 <roelof> srhb:  yep, that is correct 
07:40:16 <roelof> when its less then 12 then spaces have to put before it. When its bigger or equal to then no spaces  
07:40:26 <roelof> so this is not doing what we want 
07:40:27 <srhb> roelof: It can't put spaces anywhere
07:40:31 <srhb> roelof: It returns a Bool
07:40:41 <roelof> yes, I know
07:40:42 <srhb> That's a discussion for later. Stick to THIS function.
07:40:44 <srhb> :)
07:41:06 <srhb> So since it returns Bool anything you say needs to be "When the list is like this and this, it returns True / False"
07:41:12 <srhb> Because that's the only kind of value it can return.
07:42:05 <roelof> oke, when it's false the string must not be altered. When it's true spaces have to put before it so the length will be 12 
07:42:11 <srhb> When the list is (greater/greater or eq) than 12, it should return (True/False) -- this is the statement you need to make before you can possibly write the function.
07:43:14 <roelof> I thougt we stick to the drop version ? srhb  
07:43:26 <ivxr> hi
07:43:29 <icbm> sgronblo: They're different.  ST represents a computation that can work with mutable slots (STRefs) holding values.  State represents a computation that has get/put access to some context value.
07:43:42 <srhb> roelof: Well, it's your choice, I'm just trying to help you make the right thoughts and statements to build the function you want.
07:43:56 <ben> What does ST stand for?
07:43:59 <srhb> roelof: Which is to say: You need to define what your function does before you can write it. I really haven't seen any consistent definition from you yet.
07:44:37 <icbm> ben: state threads, I think?
07:44:41 <roelof> oke, What I want is a function which returns true for  list smaller then 12 and false for lists bigger then 12 
07:44:57 <srhb> roelof: Yay!
07:45:02 <ivxr> been looking into servant lately. really impressive stuff...
07:45:08 <srhb> roelof: What does it do in the middle though?
07:45:20 <srhb> roelof: Ie. for lists that are 12 long.
07:46:04 <roelof> Then also false  
07:46:35 <icbm> sgronblo: In fact, you can combine State and ST.  StateT (STRef s MyContext) (ST s) a
07:47:23 <srhb> roelof: That's a good definition. So now, if we drop 11 elements, we know that null gives us the opposite Bool of what we want, right?
07:47:27 <roelof> srhb:  when length is 12 then also false 
07:47:50 <roelof> srhb:  yep
07:47:57 <sgronblo> What does this "internal state indexed by s" mean?
07:48:00 <icbm> sgronblo: That gets you a ST computation, but also gives that computation access to a shared STRef holding your context.  Sort of like a global variable.
07:48:10 <srhb> roelof: Try it before you say anything too surely :-)
07:48:46 <dhz_> but unlike with a global variable you are in complete control of its scope
07:48:52 <nomicflux> ivxr: hello!  I've been looking into Servant too; do you know about their IRC channel?
07:49:15 <roelof> srhb:  no it gives the right output 
07:49:39 <icbm> sgronblo: In ST s, s is a type parameter whose value is never known to you the developer.  Generally only runST knows what real s are provided.  This prevents your mutable slot (STRef) from escaping out of the ST.
07:49:40 <srhb> roelof: Magic!
07:49:45 <srhb> roelof: Well, not really. :-)
07:50:07 <icbm> sgronblo: There are better explanations of it, but that's how I look at it.
07:50:25 <roelof> it's only give the wrong output when length = 12 ,  then it give True where we want to see False 
07:50:41 <martinvlk> Hi, anybody could recommend a 3D graphics library to learn by somebody who is relatively new to FP/Haskell and has no previous knowledge of 3D graphics programming?
07:50:47 <srhb> > null . drop 11 $ [1..12]
07:50:49 <lambdabot>  False
07:50:55 <srhb> roelof: Looks right to me.
07:51:27 <srhb> roelof: Did you accidentally drop 12 instead of dropping one LESS than 12?
07:51:45 <roelof> srhb:  wierd . null (drop 12 "aaaaaaaaaaa")   gives here :  True
07:52:24 <srhb> roelof: That's right, but according to your specification, you wanted the cutoff point to be "longer OR equal length returns False"
07:52:29 <srhb> roelof: Meaning: drop one less.
07:53:42 <martinvlk> My cocern is for it to be in reasonably "functional" style and idiomatic Haskell if possible 
07:54:13 <ivxr> martinvlk 3d graphics isn't the best place to start if you're a beginner
07:54:14 <srhb> martinvlk: We're in short supply of those I'm afraid.
07:54:21 <roelof> moment, I do not get this:  http://lpaste.net/148036
07:54:31 <roelof> why do you get another answer then me 
07:54:39 <ivxr> martinvlk srhb i would say, use gloss for low barrier to entry, glpipe for advanced work
07:54:56 <srhb> > length "aaaaaaaaaaa" -- roelof
07:54:58 <lambdabot>  11
07:55:09 <ivxr> martinvlk realtime ray tracer in gloss https://www.youtube.com/watch?v=jBd9c1gAqWs
07:55:30 <roelof> see it. I still have to use a length of 12 
07:55:34 <srhb> roelof: My list, [1..12] is 12 long, yours is 11.
07:55:42 <roelof> was a moment confused by [ 1 .. 12] 
07:55:44 <ivxr> martinvlk i mean, gpipe, not glpipe
07:55:50 <srhb> roelof: You don't have to do anything. You can do anything you want. But the function as stated now does what you specified it should do.
07:56:07 <srhb> roelof: If you want it to do something different, you should change the specification.
07:56:24 <roelof> no, the definition is fine 
07:56:32 <srhb> roelof: Then the function is also fine.
07:56:41 <roelof> I was confused what [ 1 .. 12]  is returned 
07:56:44 <srhb> OK :)
07:56:46 <srhb> > [1..12]
07:56:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12]
07:56:49 <srhb> you can always test.
07:57:10 <roelof> yep, I schould have done that , I apolize 
07:58:08 <roelof> Now I can test if the output is false or true 
07:58:24 <roelof> srhb:  or do I want to go to fast now 
07:58:54 <srhb> roelof: If you're talking about your implementation of actual tests, I've already stated my opinion of those as a tool to learn. :-P
07:59:18 <srhb> But that's just opinion. Anyway, I should get back to work. Have fun :)
07:59:36 <roelof> srhb:  thanks a lot for the lessons 
07:59:38 <ivxr> martinvlk srhb there's also ek's quine, although i think that's more tech demo-y. https://www.youtube.com/watch?v=w763xvEQskQ finally, phaazon is working on the luminance engine
07:59:44 <ivxr> haven't tried luminance myself though.
07:59:57 <phaazon> luminance is not an “engine” though .)
07:59:59 <phaazon> :) *
07:59:59 <martinvlk> ivxr: I am not complete beginner, just relatively so, and have a need for some simple 3D graphics for my project, I'll havea look at gloss / glpipe..
08:00:11 <martinvlk> how about lambdacube?
08:00:24 <phaazon> martinvlk: “simple” you said? :D
08:00:27 <phaazon> λ³ is not
08:01:02 <ivxr> martinvlk that's gpipe, not glpipe. I would go with gloss for "simple". lambdacube is a dead end
08:01:11 <Xandaros> There is not-gloss, which I've been meaning to have a proper look at. From a few quick glances at the docs, it seems simple enough
08:01:48 <ivxr> martinvlk the latest version of lambdacube changed it into a DSL, so to use it in haskell you have to work with an old version, which seems pointless to me
08:01:50 <cmotoche> Hello everybody. I'm having problems with the setEnv function. When I try to set up an environmental variable that is empty (e.g. setEnv "ENV" ""), it doesn't set the variable. Do you know what could I do?
08:03:04 <ivxr> xandaros lol that name.
08:03:23 <Xandaros> ikr
08:03:29 <geekosaur> cmotoche, how are you testing that?
08:03:43 <martinvlk> ivxr: I hear you - thanks a mil!
08:03:47 <ivxr> phaazon how is luminance coming along?
08:04:27 <martinvlk> phaazon: simple as in my 3D model and usage of it in this project will be simple 
08:05:03 <cmotoche> After, setEnv "ENV" "". I do lookUp "ENV", I spec something like Just "", but I get Nothing.
08:05:29 <martinvlk> e.g. animated 3D sphere that reacts to a sound signal
08:06:12 <dhz_> I can confirm I have the same issue with setEnv.. just tested it
08:06:16 <Xandaros> martinvlk: Like I said, have a look at not-gloss. It seems very gloss-like, just in 3D. (Though I haven't actually used it)
08:07:15 <Xandaros> cmotoche, dhz_: Is there a difference between (Just "") and Nothing for environment variables?
08:07:48 <ivxr> phaazon i occasionally check the blog about it and am like "i have no idea what these words mean..."
08:07:50 <dhz_> Xandaros good point. I can't see any reason to distinguish between the two
08:07:56 <srhb> cmotoche: Where's the functions from?
08:08:30 <srhb> cmotoche: The getEnv from System.Environment does not return IO (Maybe String) and the setEnv from unix takes three, not two arguments, so it's hard to figure out. :-)
08:09:01 <martinvlk> Xandaros: oh thanks, I'll check not-gloss out as well
08:09:27 <ivxr> martinvlk for the basic stuff you're looking at, i think you may get something out of jekor's walkthrough of the cuboid 3D game https://www.youtube.com/watch?v=-IpE0CyHK7Q&list=PLxj9UAX4Em-Lz5btngxMVZxf_B44GETVz&index=7
08:09:36 <ivxr> https://www.youtube.com/watch?v=T3xXebIr8AM&list=PLxj9UAX4Em-Lz5btngxMVZxf_B44GETVz&index=8
08:09:44 <phaazon> ivxr: which blog?
08:09:52 <phaazon> λ³?
08:10:02 <phaazon> 17:12 < ivxr> phaazon how is luminance coming along?
08:10:04 <phaazon> pretty great
08:10:13 <phaazon> I’m using it to write a “real” demo :)
08:10:23 <phaazon> with a little 3D engine built ontop of it :)
08:10:27 <cmotoche> I'm using the functions from System.Environment.Compat.
08:10:54 <srhb> cmotoche: From its docs: "On Windows setting an environment variable to the empty string removes that environment variable from the environment. For the sake of compatibility we adopt that behavior. In particular
08:11:10 <srhb> setEnv name "" has the same effect as unsetEnv name
08:11:12 <ivxr> phaazon your blog :)  i'm not a deep theory guy yet. sweet, nice to hear the demoscene is alive and well and there's at least 1 person from haskell representing
08:11:53 <ivxr> "rank-2 and existential quantification" i don't know what that means yet sorry :P
08:12:20 <cmotoche> Yes, I just read that, but anyway I don't know what should I do.
08:12:45 <martinvlk> ivxr, phaazon: thanks a lot for the pointers, one more thing, I'd like to "draw" my 3D model in something like blender and then load this into my Hasell program to animate, etc. is there a tutorial on how to do such a workflow?
08:12:54 <ivxr> phaazon i used to follow the demoscene back in the late mid 90s. seemed like it petered out for a while when GPUs took over. seems to be a bit of a revival nowadays hough.
08:13:04 <srhb> cmotoche: What do you mean?
08:13:45 <jewels> Hi there. Is there a way in order to define a type for a specific kind of function? Doing this I want to restrict the value that a parameter of another function (which expects this type) could assume. 
08:14:05 <geekosaur> oh, that's why I couldn't match what you were saying to the API...
08:14:35 <cmotoche> I need to set that variable, but setEnv doesn't do that when the value is empty.
08:14:43 <srhb> cmotoche: Then you want a different function.
08:15:03 <Xandaros> cmotoche: Why do you need to set it? Does it have to be the empty string?
08:15:20 <ivxr> martinvlk sorry haven't tried to do that. i would google around for file loaders, maybe something like http://hackage.haskell.org/package/obj
08:15:22 <geekosaur> I think that's "expected"
08:15:26 <geekosaur> WIndows doesn't do empty envars
08:15:31 <cmotoche> Yes, it has to be an empty string.
08:15:34 <geekosaur> (like, setting one empty is how you remove it)
08:15:50 <srhb> cmotoche: Then just use the one from System.Posix.Environment or something, since it won't work on Windows anyway.
08:16:14 <srhb> System.Posix.Env, sorry
08:16:46 <cmotoche> Ok, I think, I'll try that one.
08:17:00 <cmotoche> Thank you.
08:17:03 <martinvlk> ivxr: okay, thanks!
08:18:47 <phaazon> ah, my blog ivxr 
08:18:48 <phaazon> yeah, well
08:18:54 <phaazon> when luminance hits 1.0
08:18:59 <phaazon> I’ll write a long post about it
08:19:02 <phaazon> with hints and so on :)
08:19:17 <roelof> Xandaros:  it this what you mean : pushRight s  =  if null (drop 11 s) then replicate (12 - length s) ' ' ++ s else  s  
08:20:06 <Xandaros> roelof: You probably meant to ping srhb, but yes - that looks like it should work :)
08:20:55 <liste> @let type IntToInt = Int -> Int -- jewels you mean something like this?
08:20:57 <roelof> Xandaros:  it works,  I tried it. but you came with the remark that my function should work with infinitive lists 
08:20:58 <lambdabot>  Defined.
08:21:26 <ivxr> phaazon looking forward to that
08:21:27 <liste> > let f = (+5) :: IntToInt in f 12
08:21:29 <lambdabot>  17
08:21:35 <Xandaros> roelof: Fair enough
08:21:47 <yamadapc> I'm having trouble compiling mtl with GHC 7.10.3 https://www.dropbox.com/s/qavt1gj8hfy5v36/Screenshot%202015-12-29%2014.20.54.png?dl=0
08:21:55 <Xandaros> phaazon: I just wish I could actually try luminance. I guess it is just one more reason to get a new Laptop :D
08:22:03 <yamadapc> Anyone seen something similar?
08:22:28 <ivxr> that's strange
08:22:42 <srhb> yamadapc: Why does it think it's a Linux ghc?
08:22:48 * hackagebot hi3status 0.1.0.0 - Status line for i3bar.  https://hackage.haskell.org/package/hi3status-0.1.0.0 (ScrambledEggs)
08:22:55 <roelof> then tomorrow the next challenge , make a table with the fib numbers so fib 6 will make a sort of table which shows the fib numbers 1 till 6 inclused 
08:23:04 <srhb> yamadapc: /Users/ looks very OS X'y
08:23:10 <phaazon> Xandaros: why couldn’t you?
08:23:25 <Xandaros> OpenGL version
08:23:32 <phaazon> 3.2
08:23:36 <phaazon> hm no
08:23:36 <phaazon> 3.3
08:23:40 <phaazon> I just updated recently
08:23:56 <phaazon> (because #150 shader are very boring to use)
08:23:57 <yamadapc> srhb: I't son a docker container
08:24:11 <yamadapc> *It's `stack --docker build`
08:24:49 <Xandaros> phaazon: http://tcp.mniip.com/0rzh
08:24:53 <srhb> yamadapc: I see. Haven't experimented with that.
08:25:05 <mniip> >.>
08:25:27 <Xandaros> mniip: Do you get pinged everytime someone posts a link like that? :P
08:25:31 <mniip> yes
08:25:37 <roelof> Thanks all for the help and patience with me. 
08:25:44 <yamadapc> It usually works fine despite the "unsuported" warning; weird that this happens, I wonder why
08:25:51 <roelof> and have a good evening Byeee 
08:27:33 <mniip> Xandaros, I want to buy a cool domain name for it
08:27:40 <mniip> but the one I want is $40 so ugh
08:28:36 <phaazon> Xandaros: arf :(
08:28:39 <ivxr> anyone else using haskell for data science stuff?
08:29:54 <ivxr> "OpenGL version string: 2.1" :( old OSX...
09:01:49 <haskell954> I have a project directory proj/ with two subdirectories src/ and test/, under src/ I have Foo directory (my toplevel module) and Bar.hs inside (which is module Foo.Bar). Inside of test/ I have Main.hs (module Main) which needs to import Foo.Bar. But when I run ghc, it can't find the module. Any way to resolve this with GHC / Cabal? Or do I need to restructure my project?
09:03:03 <wedens> haskell954: do you have this module in exposed-modules section of .cabal?
09:03:31 <haskell954> Yeah, in ppa.cabal I have
09:03:35 <haskell954> library
09:03:43 <haskell954> and then exposed-modules: Foo.Bar
09:03:52 <haskell954> and then a Test-Suite tests
09:04:02 <haskell954> with hs-source-dirs: test
09:04:13 <haskell954> and main-is Main.hs
09:04:20 <haskell954> main-is:
09:04:24 <wedens> library in build-depends?
09:04:59 <wedens> in a test-suite
09:05:08 <haskell954> the build-depends field of library contains all the dependencies for Foo.Bar
09:05:16 <haskell954> oh hold on
09:05:30 <haskell954> No, I don't have Foo.Bar in build-depends for test-suite
09:05:32 <haskell954> Let me try that
09:05:33 <wedens> build-depends of a test-suite should contain your library
09:06:05 <wedens> not just module name, but library name
09:06:05 <haskell954> That was it
09:06:33 <haskell954> I added the package name
09:06:45 <haskell954> to build-depends for Test-suite
09:06:53 <haskell954> worked fine
09:19:47 <synergistics> When is flatMap useful?
09:22:49 * hackagebot casadi-bindings 2.4.1.5 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.5 (GregHorn)
09:22:52 <wedens> synergistics: wat
09:23:10 <dmj`> aristid: ping
09:23:27 <aristid> dmj`: ?
09:23:44 <sgronblo> What about this IOArray?
09:23:46 <xplat|work> flatMap == (>>=)
09:24:44 <synergistics> xplat|work: Hm?
09:25:38 <xplat|work> synergistics: it's more a hint for anyone else who wants to answer your question than an answer
09:25:43 <z-nexx> Hola, I've got a problem with types... I've renamed a type a la "newtype T = T [Statement.T]", but I get errors like "Couldn't match expected type ‘[Statement.T]’ with actual type ‘T’", where the last T is the newtyped T...
09:25:55 <hiptobecubic> synergistics, flatMap is useful because it's required knowledge if you want to scala your big data on your spark hadoop cluster cloud. That way when you want to explain monadic 'join' to someone and they start whining about how math is for losers, you can point to something they already think is cool.
09:26:10 <z-nexx> code is in http://lpaste.net/8320800404950482944 http://lpaste.net/1281771932236120064 and output in http://lpaste.net/8018436721651744768
09:26:11 <hiptobecubic> At least, that's where I've found it useful
09:26:41 <monochrom> is that a joke?
09:26:50 <hiptobecubic> No, unfortunately.
09:27:04 <hiptobecubic> Granted, it's probably not the right right answer for this particular discussion.
09:27:15 <quchen> It's probably not the right answer for any discussion.
09:27:18 <z-nexx> Am I even using the newtype correctly? All examples I've found looks just like my code, but I dunno why ghci can't match those types...
09:27:50 * hackagebot spatial-math 0.2.5.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.2.5.0 (GregHorn)
09:28:05 <synergistics> Heh
09:28:23 <quchen> synergistics: flatMap is how other languages like to call something (often similar to) the monadic bind operator. In a Haskell context, you're asking "when are monads useful", and the answer to that is "very often, try Haskell".
09:28:57 <hiptobecubic> Maybe I missed something, but that didn't answer the question at all really.
09:29:21 <hiptobecubic> Not that it's wrong, but the question asks when.
09:29:45 <xplat|work> well, whether it's an answer really depends what the question is.  in particular, it depends which 'flatMap' one means
09:29:58 <xplat|work> flatMap in general, or at some specific type?
09:30:11 <hiptobecubic> anyway, my joke about spark and flatMap failed miserably and I'm not trying to pick a fight. Back to work!
09:31:07 <monochrom> it was successful because I conjectured that it's a joke.
09:31:24 <monochrom> if only you also said "yes" back then...
09:31:31 <hiptobecubic> Argh you're right.
09:31:33 <hiptobecubic> Dammit
09:31:42 <monochrom> :)
09:32:26 <hiptobecubic> Although it's a strange breed of joke. It has really happened :(
09:32:48 <synergistics> Ok, stupid question, but I don't really see the connection between flatMap and bind. How would you describe it? Maybe I don't get bind very well...
09:33:02 <hiptobecubic> But back to writing python, where people frown at your for using `map`, let alone a flatMap.
09:33:08 <hiptobecubic> at you*
09:33:48 <magr> where everything most be .... "pythonic"
09:33:55 <magr> *must
09:35:08 <quchen> synergistics: I don't know what you mean with "flatMap". If you're talking about lists, then "xs >>= f = flatMap f xs".
09:35:49 <quchen> If you're talking about "flatMap in general", then it's identical to the (=<<) operator, i.e. flipped (>>=) aka bind.
09:36:08 <quchen> The former is a special case of the latter.
09:36:56 <mnoonan> synergistics: you can implement bind in terms of the join operator with type m (m a) -> m a, which generalizes the "flattening" part [[a]] -> [a] of flatMap.
09:38:12 <ralu> and fmap o think
09:38:38 <mnoonan> right
09:39:44 <gaustin> When would you choose Halcyon over Stack and vice versa?
09:39:48 <mnoonan> :t join
09:39:49 <lambdabot> Monad m => m (m a) -> m a
09:40:27 <ralu> :t >>= id
09:40:28 <lambdabot> parse error on input ‘>>=’
09:40:56 <ralu> :t '>>=' id
09:40:58 <lambdabot> parse error on input ‘>>=’
09:41:06 <sgronblo> so this ST is a monad that allows you to mutable compute a value in an isolated thread and then return it so that it can seem like the computation was pure?
09:41:18 <mnoonan> :t \f -> join . (fmap f)
09:41:19 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
09:41:31 <mnoonan> :t (=<<)
09:41:32 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:41:41 <mauke> sgronblo: ST gives you mutable variables (locally)
09:42:08 <mauke> i.e. you can write an algorithm with a pure interface that still uses mutation internally
09:43:09 <sgronblo> mauke: right, that makes sense.
09:45:29 <sgronblo> there is no Data.Matrix.ST?
09:45:30 <mauke> > (\x -> runST (do { v <- newSTRef x; modifySTRef v (+1); modifySTRef v (+1); readSTRef v })) 1
09:45:32 <lambdabot>  3
09:45:49 <nitrix> ST is a ref system?
09:45:56 <nitrix> Ah.
09:46:27 <nitrix> :t modifySTRef
09:46:28 <lambdabot> STRef s a -> (a -> a) -> ST s ()
09:46:34 <nitrix> Oh I see.
09:48:21 <z-nexx> Hi, I've got a homework problem, and my renaming of a type doesn't seem to work correctly, I'm getting "Couldn't match expected type ‘[Statement.T]’ with actual  type ‘T’" when I use newtype as "newtype T = T [Statement.T]"
09:48:39 <z-nexx> oh sry, mis-paste
09:51:30 <dmj`> @where paste
09:51:30 <lambdabot> Haskell pastebin: http://lpaste.net/
09:56:51 <begriffs> If I have Hashable values at my disposal is there ever a reason to use the containers package over unordered-containers? Seems like the latter offers flatly faster operations.
09:57:59 <broma0> begriffs: the apis (i really can only comment on data.map) seem nicer/more robust for containers. but when you can write your own easily, the faster option is probably better
09:58:06 * hackagebot ctrie 0.1.0.3 - Non-blocking concurrent map  https://hackage.haskell.org/package/ctrie-0.1.0.3 (MichaelSchroeder)
10:00:16 <begriffs> Maybe there are situations too when the hashtable performance will be worse than the balanced trees. I don't know much about algorithms to know what situation that would be.
10:00:43 <begriffs> Like a ridiculous number of hash collisions or something
10:05:11 <begriffs> Also the HashSet member, insert, and delete functions say they have O(min(n, W)) complexity but what is W? https://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashSet.html#v:member
10:05:13 <sgronblo> so for an ST computation, you cant pass in a value can you?
10:07:23 <kadoban> begriffs: It's possibly the word size of the machine … not sure if that makes sense in context, but it's all I can think of.
10:12:18 <dmj`> sgronblo: sure, why not
10:12:57 <dmj`> you could make it an STRef
10:21:04 <quchen> sgronblo: `return` is a function that makes a value into an ST computation.
10:24:56 <sgronblo> dmj`: so you would create a new STRef outside and pass it in somehow?
10:26:26 <amf> are there any techniques for list type signature like :: [ SomeCustomType a b ] ?
10:26:33 <dmj`> sgronblo: doSTThing (x :: Int) = runST $ do { ref <- newSTRef x; ... }
10:26:41 <jamesfordummies> trying to run a basic servant app set up using the stack template - how do I run the server locally?
10:27:04 <jamesfordummies> i’ve tried `stack runghc app/Main.hs` but it just hangs with no output
10:27:44 <liste> amf could you elaborate a bit?
10:28:11 <pavolzetor> is writeArray strict?
10:28:30 <pavolzetor> because I switched to vector and removed ST monad and I am having memory problems
10:28:50 <pavolzetor> when I try to render 4k x 4k image it just runs out of memory
10:30:25 <pavolzetor> given that the image itself is only 50 MB, I don't see how is this possible
10:30:59 <amf> liste: i have input (a), and output (b) types, i need some way to have the records (metadata and such) stored in a collection that i can map through. ill have instances for handling each a and b, but im not sure how to get these joined together in a collection
10:31:48 <amf> this almost sounds like what pipes is doing so i may figure out how they did it
10:36:44 <liste> how are the input and output types related? is there one output type for each input type?
10:36:55 <liste> I'd look at a sum type first
10:37:30 <liste> data Foo = IntToString Int String | DoubleToFloat Double Float | IntToFloat Int Float ....
10:37:59 <liste> and are you trying to store *types* or *values* ?
10:38:15 <amf> any output type can use any input type. so the input (provided by someone using this library) is a sum type
10:38:49 <amf> im trying to get the compiler to choose the correct instances
10:39:39 <amf> and then ill have some variable that contains all these reports data structures (list, hashmap, whatever) i can pass around and operate with
10:48:03 <mmierz> amf: sounds like you need another type C that has the "intermediate representation" of your data so you have a bunch of functions a -> C and C-> b? if I'm understanding correctly
10:49:30 <saurai3h> Hi!
10:49:58 <saurai3h> I know this must be common here, but where can I practice easy haskell problems?
10:50:04 <saurai3h> I am just a beginner
10:51:11 <amf> mmierz: yeah i might look into that, thanks!
10:53:08 * hackagebot relational-query 0.7.0.2 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.7.0.2 (KeiHibino)
11:05:25 <sgronblo> dmj`: ah thanks for the example, that makes sense
11:05:53 <dmj`> np
11:17:22 <haskell632> I have a cabal packaged library which exposes a few modules. How can I test locally that only these modules are exposed? I'm messing around in sandbox, but when I do % cabal repl, for instance, it loads the non-exposed modules as well.
11:22:02 <bergey> haskell632: One way is to add an executable section to .cabal, that depends on the library, and have the Main.hs try to load one of the internal modules.  That keeps it all in the sandbox, which saves time.
11:23:16 <kadoban> Why not just make sure what's in exposed-modules looks correct and call it good? I'd think it'd be kind of hard to accidentally expose stuff.
11:25:27 <haskell632> Just want to make sure i'm doing everything right, I'm new to cabal
11:26:51 <haskell632> bergey: I think what you suggested is easiest, keeps everything in sandbox
11:30:23 <haskell632> By the way, is there any way for me to use a hidden module in a Test-suite?
11:30:40 <haskell632> Say I have a library with a Test-suite attached, is there any way to expose a module only to the Test-suite?
11:31:19 <kadoban> haskell632: I believe the usual way to do that is to just call it something like Blah.Whatever.Internal, and document that it's not stable and shouldn't be relied upon.
11:31:27 <jewels> Hi there. I'm trying to define a type for a function. This type should be a constraint for a parameter of another function. I've decided to use the construct "class". I want to do something like this: http://lpaste.net/148054. Obviously this not work, how can I do what I mean?
11:31:59 <haskell632> So name it internal, expose it anyway, and just document it as unstable?
11:32:12 <kadoban> haskell632: I believe so, yeah.
11:32:27 <haskell632> Unsatisfying, but practical
11:32:29 <haskell632> okay
11:32:54 <haskell632> Probably useful to let users have some access to the value constructors, anyway
11:32:58 <haskell632> if they *really* need it
11:33:21 <bergey> Yeah, that's common and well-liked.  This way if I'm willing to tie to a particular version of your library, I can still get at the internals.
11:33:41 <jewels> Nobody can help me?
11:34:33 <bergey> jewels: Can you include the definition of the type MaxTNorm?  Without it, I can't guess what you are trying to do.
11:35:48 <haskell632> In order to call max on s1 and s2 (assuming MaxTNorma has kind * -> *), you'll need to add a class constraint to your class
11:35:54 <haskell632> or instance
11:36:02 <haskell632> which contains the "max" function
11:36:08 <haskell632> not sure what that is off the top of my head
11:40:02 <bergey> > :t max
11:40:04 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:40:05 <haskell632> jewels: I think if you added Ord a => as class constraint, that'll allow you to use max
11:40:33 <haskell632> :t max
11:40:34 <lambdabot> Ord a => a -> a -> a
11:40:45 <haskell632> Oh nifty, didn't know lambdabot could do that
11:41:17 <jewels> bergey: What I need to have is to constraint the type of the function. I don't want to specifiy as a parameter simply (a -> a -> a). But I want that it's a specific function type (in this case a Tnorm)
11:41:41 <jewels> bergey: I want to prevent that the caller can specify a function that has the same signature but it's not defined as a Tnorm
11:42:27 <imalsogreg_> johnw, Just watched your What Code Means talk (http://begriffs.com/posts/2015-12-26-what-code-means.html). It turned out great!
11:42:37 <johnw> imalsogreg_: thank you!
11:42:48 <johnw> imalsogreg_: I'm sorry you couldn't be there
11:43:36 <jewels> haskell632: I know that max is a proper type for that signature. The problem is that I don't know how to defined a generic type for a function. I want to give a name to the function a->a->a
11:43:46 <imalsogreg_> johnw, Wish I could have. I'll have to go out west sometime. Really glad you worked Free in there in a non-intimidating way.
11:44:16 <jewels> bergey: haskell632: any ideas?
11:50:19 <jewels> bergey: haskell632: I have refined the example: http://lpaste.net/148054
11:50:40 <huseyinyilmaz> @help
11:50:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:50:51 <huseyinyilmaz> @list
11:50:51 <lambdabot> What module?  Try @listmodules for some ideas.
11:54:05 <haskell632> I see what you are saying jewels
11:54:14 <haskell632> Let me think on it a minute
11:55:15 <jewels> haskell632: ok thank you :)
11:58:42 <haskell632> jewel: I guess i'm still not totally clear on what you are trying to accomplish. 
11:59:02 <haskell632> The issue you are having is with kinds, at least in your first example
11:59:18 <haskell632> MaxTNorm has kind * -> *
11:59:29 <haskell632> But TNorm takes something of kind *
11:59:47 <haskell632> so you apply a type variable a to MaxTNorm to make it kind *
12:00:14 <csd_> what are some similar links to http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
12:00:22 <haskell632> But then you try to apply max on those, but in order to do that, you'd need (Ord MaxTNorm ) =>
12:00:28 <haskell632> But then you try to apply max on those, but in order to do that, you'd need (Ord MaxTNorm a) =>
12:01:04 <geekosaur> that looks wrong too
12:01:16 <geekosaur> (Ord (MaxTNorm a)) =>
12:01:21 <haskell632> Sorry, yeah
12:01:34 <jewels> haskell632: intersect :: (Ord i, s) => FuzzySet i s -> FuzzySet i s -> (s -> s -> s) -> FuzzySet i s - In this definition, I want to replace the "s->s->s" with a specific type of function.
12:01:58 <jewels> In particular I want to impose a constraint on the function parameter
12:02:37 <jewels> So I've started to think that I should use "class". Sorry, but I'm a haskell newbie so I'm not very good in writing good haskell code!
12:03:03 <haskell632> Just impose the constraint on s in the signature for intersect, and then implement a class over the type s
12:05:15 <jewels> haskell632: But the constraint is not on the argument but on the function. Is the function that should be a TNorm (in this case)
12:05:52 <haskell632> Okay
12:06:07 <haskell632> What constraint do you want to place on the function
12:07:02 <jewels> It should be of a specific type. Maybe now I'm thinking like a Java programmer...
12:07:23 <jewels> In fact I have in my mind the concept of interface...
12:07:50 <haskell632> Can you show me concretely what you are applying to the function with signature s -> s -> s?
12:07:51 <ReinH> jewels: what are you trying to do?
12:07:58 <haskell632> Are you applying the key and the value?
12:10:53 <jewels> ReinH: haskell632: http://lpaste.net/148054
12:11:34 <jewels> as you can see I use the tnorm parameter as a function which receives two arguments.
12:12:23 <jewels> ReinH: What I want to achieve is a better level of abstraction. I want to explicit the fact that the parameter should be a TNorm and not a generic function!
12:13:42 <jewels> in Java I can define an interface which has a method tnorm() with two parameters. Each instance defines tnorm appropriately. The caller should use an instance of the interface in order to call my method. I'm trying to emulate this kind of behaviour. Is a good approach?
12:16:47 <breadmonster> jewels: Umm, so like you want to create a typeclass with tnorm as a method.
12:21:41 <ReinH> jewels: well, there are a few problems with your attempt
12:21:50 <ReinH> (Ord i, s) (Tnorm t) => ... isn't valid
12:22:12 <ReinH> intersect fs1 fs2 tnorm = ... makes tnorm a variable that shadows the one defined by the TNorm class.
12:22:22 <ReinH> you don't need to pass tnorm in. That's what the typeclass does for you.
12:22:42 <ReinH> jewels: Where is MaxTNorm defined?
12:23:14 <jewels> ReinH: It is not defined because I don't know if it's correct to define like that.
12:23:33 <ReinH> If you want to implement a specific instance, it would be like:
12:23:39 <ReinH> instance TNorm Int where tnorm = max
12:23:40 <jewels> I'm here to clarify and understand well the scenario and what's the proper solution in Haskell and not in java...
12:23:52 <ReinH> and this means each type can only have one instance of TNorm
12:24:47 <ReinH> And then to use it you would have, e.g., foo :: TNorm a => a -> a -> a; foo x y = tnorm x y .
12:25:40 <ReinH> In the case of interesect, I *think* that what you want is to apply a TNorm constraint to s: intersect :: (Ord i, TNorm s) => FuzzySet i s -> FuzzySet i s -> FuzzySet i s
12:28:14 * hackagebot MonadRandomLazy 0.1.1 - Lazy monad for psuedo random-number generation.  https://hackage.haskell.org/package/MonadRandomLazy-0.1.1 (NormanRamsey)
12:28:35 <ReinH> and then the implementation of intersect uses tnorm on the intersecting values to produce a new value.
12:29:00 <ReinH> Although I don't really see the advantage to this approach over just writing an intersectWith function that takes the combining function as an argument
12:29:14 <nineonine> :t read
12:29:15 <lambdabot> Read a => String -> a
12:29:43 <ReinH> nineonine: you can query lambdabot
12:29:45 <nineonine> do we have something for Text ?
12:29:55 <nineonine> Text -> Int
12:31:02 <jewels> ReinH: Thank you for your clear explanation. Do you think that the implementation of the intersect function can be improved?
12:31:14 <ReinH> jewels: I'm not sure what FuzzySet is
12:31:35 <nineonine> there are solutions using Data.Attoparsec.Text and Data.Text.Read
12:31:42 <nineonine> any other options ?
12:31:54 <haskell632> jewels: http://codepad.org/OdD8LUTN
12:31:54 <ReinH> nineonine: read . unpack ?
12:32:26 <ReinH>  why would you need to test for key equality in an interesect function?
12:32:34 <ReinH> er, equality of keys
12:32:37 <haskell632> jewels: Also I think there must be a more idiomatic way to zip the values of two maps with the same domain
12:33:03 <ReinH> I guess I'm missing the point of FuzzySet
12:33:23 <ReinH> I think you just want unionWith?
12:33:26 <haskell632> I don't know what it does either, but that code seems to accomplish what he wants
12:33:43 <nineonine> splitOn "x" "52x12x30"
12:34:03 <haskell632> Yeah, unionWith seems to be the function
12:34:10 <ReinH> but the uses of error and fromJust makes me very suspicious of this function
12:34:26 <ReinH> It doesn't need to be partial, so why make it partial?
12:34:55 <jewels> ReinH: Map.lookup returns a Maybe
12:34:57 <haskell632> He said he's new to Haskell
12:35:03 <ReinH> jewels: Yes, and so can intersect.
12:35:05 <haskell632> that's probably just the Java coming out
12:35:21 <ReinH> You don't have a static guarantee that intersect will give a result for all inputs
12:35:27 <ReinH> so you should use Maybe to deal with that
12:35:43 <ReinH> otherwise you're introducing runtime crashes into your program unnecessarily
12:35:55 <ReinH> when Haskell would be happy to statically prevent them
12:36:10 <haskell632> http://codepad.org/Rg6sIdeX
12:36:23 <jewels> From a formal point of view if the two fuzzy set has the same domain (same keys), the intersection is always well defined.
12:36:33 <ReinH> jewels: Yes, and you can't guarantee that invariant
12:36:35 <ReinH> in Haskell
12:37:09 <haskell632> Not with the type system
12:37:23 <jewels> ReinH: But using the case I'm able to do that right?
12:37:32 <ReinH> jewels: No, you explicitly use error
12:37:35 <ReinH> that will cause a runtime crash
12:37:37 <jewels> haskell632: thank you for the code!
12:37:43 <ReinH> You don't actually need to test the keys
12:38:06 <haskell632> Credit to ReinH for the second iteration, I haven't used maps enough to know about unionWith off the top of my head
12:38:10 <ReinH> You can do all this in the Maybe monad pretty easily
12:38:13 <jewels> Maybe I can return a Maybe FuzzySet?
12:38:49 <jewels> So if the case returns True, I can return Nothing
12:38:54 <ReinH> jewels: exactly
12:39:01 <ReinH> although I think you mean if the case returns False
12:39:08 <ReinH> and then any missing key in a lookup also returns Nothing
12:39:14 <ReinH> because that's another failed precondition
12:39:29 <ReinH> but if you're already failing with Nothing on failed lookups, you don't also have to test the keys
12:40:37 <ReinH> Actually that is not strictly true, depending on how you implement it.
12:41:17 <ReinH> but the point about using Maybe to represent failure stands
12:41:25 <jewels> ReinH: Perfect.
12:41:30 <ReinH> jewels: I agree :D
12:41:32 <root___> hey
12:41:57 <root___> whos using kali
12:42:02 <ReinH> jewels: elsewhere in your program you can decide that a Nothing result indicates a program error and deal with it however you want
12:42:14 <ReinH> jewels: but partial functions don't give you the option to do that
12:42:17 <ReinH> they just crash your program
12:42:30 <haskell632> Another type to keep in mind, jewels, is Either
12:42:39 <haskell632> Sometimes something can fail in more than one way
12:42:47 <ReinH> root___: kali?
12:42:49 <haskell632> and Either is a lightweight way of specifying the way in which something failed
12:42:57 <root___> kali linux
12:43:07 <haskell632> but for your intersect function it seems like different domains is the only real error condition
12:43:25 <ReinH> root___: Can we help you with a haskell question?
12:43:50 <jewels> haskell632: Yes exactly. This is the only strange case that can happen!
12:44:38 <jewels> ReinH: As you can see, I don't know pretty well all the Haskell syntax. I've studied the foundations and now I'm learning by doing :)
12:45:09 <jewels> ReinH: haskell632: Do you suggest a specific book or tutorial for me?
12:46:01 <haskell632> I really appreciated Learn You a Haskell: http://learnyouahaskell.com/chapters
12:46:17 <haskell632> I've gotten to the point now where it's not as helpful as it was when I was learning
12:46:53 <haskell632> Also, https://wiki.haskell.org/Typeclassopedia is really great once you have a strong foundation and want to embrace the Haskell-foo
12:47:05 <EvanR> jewels: theres this https://github.com/bitemyapp/learnhaskell
12:47:43 <ReinH> I don't recommend LYAH
12:47:59 <ReinH> It shows but doesn't teach.
12:48:19 <EvanR> ReinH: like almost all resources on stuff in other languages
12:48:25 <EvanR> so it has that going for it
12:48:44 <ReinH> EvanR: "it's not statistically worse than the crappy stuff in other languages" is not a strong selling point...
12:49:04 <EvanR> people identify more with it
12:49:16 <ReinH> jewels: I recommend that bitemyapp link, his book (haskellbook.com), and Thinking Functionally with Haskell by Richard Bird
12:49:31 <breadmonster> ReinH: In the absence of a compelling alternative...
12:49:33 <EvanR> that being said i wish javascript or ruby gems had principled courses
12:49:47 <ReinH> jewels: if you have experience with other languages and want to learn the Haskell Way™ then I especially recommend Bird's book.
12:49:52 <ReinH> We have compelling alternatives
12:50:00 <breadmonster> ?
12:50:34 <ReinH> bos's course lectures, byorgey's course lectures, bitemyapp's book, Bird's book, Thompson's book...
12:51:07 <jewels> ReinH: Thank you for your suggestions!
12:51:16 <haskell632> ReinH: What's your major criticism of LYAH? I'm not much into pedagogical theory, but it was an effective introduction to the language for me.
12:52:14 <ReinH> haskell632: it is superficial and most importantly it has no exercises
12:52:30 <ReinH> it shows a bunch of beginner stuff briefly and none of it sticks
12:52:49 <haskell632> I'll agree with you on the exercises. That's probably the reason it doesn't stick for some people.
12:53:00 <ReinH> People who read LYAH either get demotivated and quit or have to go read something else.
12:53:13 <ReinH> At which point, they should have just read the other thing instead
12:53:53 <EvanR> LYAH is firmly entrenched in haskell culture
12:53:54 <breadmonster> ReinH: I was lucky enough to cut my teeth on RWH, but it moves too fast for some people.
12:53:58 <EvanR> thanks to google
12:53:58 <ReinH> EvanR: it's a shame :)
12:54:15 <EvanR> its the w3schools of haskell
12:54:15 <dhz_> LYAH lost me on applicative and monad chapters
12:54:18 <ReinH> breadmonster: RWH has its own problems, but it's way better than LYAH
12:54:36 <breadmonster> ReinH: The age for one.
12:55:06 <ReinH> a lot of the code is bitrotted, many of the libraries it uses are out of date or obsolete, etc
12:55:19 <haskell632> I'll have to revisit LYAH and come up with some concrete redeeming qualities. It worked really well for me. But everyone is different.
12:55:22 <breadmonster> Yeah.
12:55:23 <EvanR> OldWorldHaskell
12:55:46 <ReinH> It's not a problem you can avoid if you're trying to write a timely book on pragmatic haskell
12:55:48 <EvanR> haskell632: the artwork is nice and funny
12:55:54 <ReinH> it will necessarily no longer be timely at some point in the future
12:56:23 <EvanR> ReinH: they could have updated the book and had "editions"
12:56:39 <EvanR> now that were in the web frameworks era of haskell
12:56:41 <ReinH> Yeah, but bos is a pretty busy guy
12:56:56 <ReinH> they both are
12:57:11 <haskell632> To be perfectly honest, I think the hardest part about grasping Haskell (and indeed, any functional language) is really getting the vocabulary straight in your head. And to be fair, any respectable book is going to present that correctly. That was my experience anyway.
12:57:32 <haskell632> Data constructor vs value constructor, etc.
12:57:35 <EvanR> SICP introduced a lot of that stuff for me
12:57:45 <EvanR> so i had that going when i started haskell
12:58:08 <EvanR> though i kind of had to unlearn SICP somewhat 
12:58:15 * hackagebot Plot-ho-matic 0.7.0.1 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.7.0.1 (GregHorn)
12:59:59 <haskell632> Is there a language extension or preprocessor to make records more tenable in Haskell? Its like, the one thing I miss from OCaml. I like the dot notation. Does that make me a terrible person?
13:00:02 <EvanR> i remember having trouble with constructor terminology, and now its still seems kind of ill defined in some cases, and also irrelevant to doing actual code
13:00:11 <ReinH> haskell632: try lens
13:00:34 <EvanR> (my . nested . field) r
13:00:37 <EvanR> dot notation ;)
13:00:48 <ReinH> > ((1,2),3) ^. _1 . _2
13:00:50 <lambdabot>  2
13:00:55 <monochrom> I don't think there needs a distinction between "data constructor" and "value constructor". and a book doesn't need both.
13:01:07 <ReinH> > ((1,2),3) & _1 . _2 .~ "hello"
13:01:09 <lambdabot>  ((1,"hello"),3)
13:01:12 <monochrom> however, "type constructor vs data constructor" is a thing.
13:01:19 <ReinH> you can still use normal function composition on field accessors
13:01:26 <ReinH> > (snd . fst) ((1,2),3)
13:01:28 <lambdabot>  2
13:02:00 <EvanR> haskell632: after going back to java/ruby syntax i realized i cant partial or compose them :(
13:02:16 <monochrom> in this regard, most authors commit the crime of doing "data X = X ..." too early.
13:02:22 <ReinH> data constructors construct values. All expressions are value constructors, so that particular term doesn't seem to have much meaning.
13:02:27 <EvanR> making me question the oop universe 
13:02:43 <EvanR> is "value constructor" really a thing?
13:02:47 <ReinH> No, not really.
13:02:49 <EvanR> i vote for no
13:02:50 <ReinH> That's my point.
13:03:06 <ReinH> It's functionally equivalent to "expression". It has no need to exist.
13:03:44 <EvanR> but theres also no data constructor vs expression
13:03:57 <EvanR> so just no
13:04:10 <ReinH> All data constructors are expressions. Not all expressions are data constructors.
13:04:40 <ReinH> data constructors are identifiers that begin with a capital letter or a :.
13:04:42 <EvanR> yes after making the necessary categorical assumptions
13:04:44 <shachaf> Expressions aren't all all data constructors are.
13:05:01 <ReinH> shachaf: I'm having trouble parsing that but I'm pretty sure you are agreeing with me?
13:05:19 <shachaf> Not agreeing or disagreeing.
13:05:20 <EvanR> now we are equating language constructs with their syntax
13:05:29 <EvanR> concrete syntax
13:05:31 <haskell632> I guess I learned data constructors as value constructors. Which I suppose is wrong.
13:05:51 <nolraiU> What is a value constructor?
13:05:54 <EvanR> nothing
13:06:12 <shachaf> Well, maybe I'm agreeing.
13:06:20 <ReinH> shachaf: maybe you're not disagreeing.
13:06:34 <shachaf> All data constructors are expressions, but that's not all all data constructors are.
13:06:39 <haskell632> value constructor is a synonym for data constructor according to this wiki page: https://wiki.haskell.org/Constructor#Type_constructor
13:06:47 <shachaf> They're also patterns, or pattern constructors or something.
13:06:48 <haskell632> A data constructor (or value constructor) can have zero or more arguments where a data constructor taking zero arguments is called a nullary data constructor or simply a constant.
13:06:54 <haskell632> But I think I like data constructor better too
13:07:07 <EvanR> data constructors are also functions
13:07:14 <EvanR> sometimes
13:07:16 <ReinH> This is an argument about nothing.
13:07:35 <EvanR> haskell632: ... id ignore that
13:07:38 <monochrom> no no, that's too easy. this is a non-argument about nothing. :)
13:08:03 <nolraiU>  /neo "Woah"
13:08:07 <haskell632> I dont think it much matters, as long as the person has a grasp on the differences
13:08:18 <EvanR> haskell632: ... what differences?
13:08:26 <haskell632> E.g. putting a data constructor in a class definition doesn't make any sense
13:08:27 <ReinH> monochrom: Look, this isn't an argument.
13:08:53 <haskell632> the difference between type and data constructors
13:08:58 <EvanR> ah
13:09:19 <monochrom> the Haskell Wiki suffers the same problem as all wikis and all public forums
13:09:39 <monochrom> in short, every article not written by me is suspect
13:09:48 <haskell632> hahaha
13:10:14 <monochrom> wikipedia is an exception because it suffers heavy-handed moderation and perpetual dispute.
13:10:49 <monochrom> in other words, deletion on wikipedia happens far more often, and rightfully so, than other wikis.
13:11:05 <monochrom> on other wikis, people are too polite to delete wrong information
13:11:38 <JohnV> b
13:11:52 <monochrom> or poor explanations
13:12:12 <Ankhers> http://lpaste.net/148058 -- I don't really understand the `data Key record' line. How would I go about creating an instance of Ord for it?
13:12:31 <EvanR> deriving (Ord) ?
13:12:49 <Ankhers> As far as I can tell, I can't do that. 
13:12:57 <monochrom> for example, look at the article that uses S->(a,S) to explain IO. it is wrong enough to worth deletion. but no one deletes it. it only gets one additional line "note: this article can be misleading"
13:12:59 <Ankhers> I didn't write the PersistEntity class.
13:13:27 <monochrom> perhaps one day I will drink a shot of whiskey and then go ahead delete it completely.
13:13:33 <EvanR> misleading and plain wrong conceptualizations of stuff is entrenched in haskell culture
13:13:54 <EvanR> its instructive and head exploding to work your way out of those wrong explanations
13:14:39 <alynn> a bad analogy is much like a burrito
13:14:55 <EvanR> Ankhers: can you edit its source file?
13:15:10 <alynn> delicious at the time but you'll regret it later
13:15:18 <Ankhers> EvanR: It is from the Persistent package.
13:15:18 <nolraiU> People complain a lot about the bad analogies, and I honestly think people are over estimating how bad they are.
13:15:28 <nolraiU> Or I learn weirdly...
13:15:39 <EvanR> Ankhers: sounds like youre wanting an orphaned instance...
13:15:39 <nolraiU> It's probably the second.
13:15:39 <ReinH> The analogies are as bad as something that is pretty bad.
13:15:53 <nolraiU> Like which?
13:15:56 <monochrom> I can't overestimate how bad they are. all analogies are bad.
13:16:12 <nolraiU> Analogies are great.
13:16:28 <EvanR> the burrito analogy was really bad because i originally took it seriously, despite the fact that i think it was published as a joke
13:16:38 <monochrom> if you have an accurate correspondence, then it is not an analogy. it is an accurate correspondence. tautologically.
13:16:50 <ReinH> my favorite kind of correct
13:17:11 <drewbert> accurate correspondences are not like burritos
13:17:14 <ReinH> EvanR: the burrito analogy is bad. The burrito correspondence is pretty good.
13:17:14 <nolraiU> Monochrome: things can be like things without being idenitical.
13:17:23 <alynn> a monad is very much like a monoid object in the category of endofunctors on Hask
13:17:35 <alynn> that's about as far as the useful analogies stretch
13:17:35 <ReinH> EvanR: https://www.cs.cmu.edu/~edmo/silliness/burrito_monads.pdf
13:17:38 <monochrom> that doesn't conflict with my statement.
13:18:02 <monochrom> an accurate correspondence does not have to be the identity map either.
13:18:09 <hiptobecubic> I liked the "astronauts riding chocolate trains backwards through wormholes" explanation.
13:18:17 <ReinH> monochrom: I think "such characterizations merely serve to reindex the confusion contravariantly" is my favorite new criticism.
13:18:32 <EvanR> thats two references to monoids in an endofunctor category in 1 hour
13:18:36 <hiptobecubic> It was actually useful, as it prompted me to give up on blogs about monads.
13:18:46 <EvanR> storms a bruijn
13:18:54 <ReinH> monochrom: What we really need is an adjunction between the object of the purported analogy and a monad.
13:18:59 <ReinH> Which would, itself, give rise to a monad.
13:19:01 <nolraiU> All an model has to do to be useful is to let the user do /more/ then they could without the model.
13:19:21 <hiptobecubic> nolraiU, you're ignoring the future though
13:19:38 <ReinH> nolraiU: and when a model causes its user to make incorrect conclusions about the thing being modelled, it provides negative utility
13:19:50 <EvanR> nolraiU: in all cases of bad analogies people are mad because theres actual good ways to explain it that get ignored for the sake of "good enoughness"
13:20:03 <hiptobecubic> nolraiU, if you are going to learn about something *right now* and then never again, then sure. Otherwise you're just building technical brain debt that will hurt you later.
13:20:17 <nolraiU> No?
13:20:24 <nolraiU> But maybe I learn weird.
13:20:40 <hiptobecubic> Maybe you learn the wrong things :)  You won't know until you pay off your debt.
13:20:56 <nolraiU> I just find paying off that debt really easy.
13:21:47 <ReinH> it's almost as if different people with different preconditioning who are exposed to different analogies will have different results
13:22:37 <EvanR> would like to see the monad misconception replaced with functor misconceptions since functors are so much more useful
13:22:39 <drewbert> Monads are like analogies attempting to explain monads.
13:23:00 <xplat|work> it's almost as if flamewars over philosophy of education have replaced haskell as the subject of this channel
13:23:02 <nolraiU> I mean Monads aren't actually that hard.
13:23:04 <EvanR> and probably more impervious to misconception
13:23:38 <nolraiU> They just take practice, and mostly ignoreing people trying to explain them, because there isn't really enough to explain.
13:23:54 <EvanR> thats the problem
13:23:54 <nolraiU> So I guess those anologies are bad..but eh.
13:23:58 <Xe> a monad quite literally is a monoid in the category of endofunctors
13:24:00 <EvanR> its too simple
13:24:11 * EvanR hits Xe with a trout
13:24:43 <nolraiU> I mean I did take Calculous in 6th grade, so NolraiU learns weird is not like..out there as an explanation.
13:24:58 <xplat|work> it's very simple, and very abstract.  there's not much to it, but it's not much like other things.  except monoids, but if you know monoids there's still a new thing, it's just a different new thing
13:25:15 <Xe> a monad is just some kind of data that supports ordering expressions and calling a function against itself
13:25:21 <Xe> with some other junk
13:25:25 <EvanR> nolraiU: i had to unlearn a lot of calculus when i got to university math
13:25:58 <xplat|work> expecting someone to explain to you what a monad is is like expecting someone to explain to you what the tango is, having never danced or even seen one
13:26:10 <nolraiU> EvanR: How so?
13:26:23 <wedify> does everything get evaluated in the io monad? like if there is an action whose result is not needed
13:26:27 <maerwald> you can explain what a monad is and you can explain what the tango is
13:26:34 <maerwald> that doesn't mean you can feel it, though
13:26:42 <johnw> wedify: "print" is an action whose result is not needed :)
13:26:49 <wedify> does laziness still apply in the io monad?
13:27:02 <nolraiU> wedify: sort of.
13:27:10 <ReinH> wedify: laziness is a property of evaluation, not execution
13:27:20 <ReinH> laziness always applies to evaluation
13:27:24 <ReinH> it never applies to execution
13:27:26 <drewbert> The IO Monad is like a leaky burrito.
13:27:29 <xplat|work> yeah but in either case the explanation won't actually accomplish much.  there's a lot there, but not much that can be explained
13:27:50 <maerwald> not sure I agree
13:27:54 <xplat|work> ReinH: unless you use unsafeInterleaveIO, then all sense is off
13:27:57 <maerwald> it usually starts with someone trying to explain
13:28:00 <maerwald> but doesn't end there
13:28:07 <ReinH> xplat|work: Yes, I'm purposefully ignoring that.
13:28:41 <ReinH> If you are using unsafeInterleafeIO in a way that breaks evaluation invariants in an observable way, that is a bug
13:28:43 <bernalex> pretty much anything we explain about haskell needs asterix. there's a reason people don't consider using haskell where they use coq.
13:28:51 <ReinH> and we don't need to say any more about it than that
13:29:07 <ReinH> s/leafe/leave
13:29:08 <xplat|work> i find it's good to not *totally* ignore that since so many people are familiar with getContents, so you have to at least explicitly mention that getContents is a weird thing
13:29:20 <ReinH> Why?
13:29:48 <bernalex> don't need to say much more than "haskell has escape hatches" tbh. if the target audience is people who don't know anything and isn't about to use haskell for a serious program anyway.
13:30:32 <ReinH> bernalex: I prefer to also say that using those escape hatches in a way that breaks purity or laziness guarantees should be considered a bug.
13:30:48 <EvanR> wedify: desugar the do syntax for the IO, then the computation for action will take place as the actions occur, so that parts lazy and might lead to some stuff not getting evaluated
13:30:50 <bernalex> they'll eventually encounter unsafeThis and unsafeThat on their own and be able to ask more useful questions. 
13:30:53 <xplat|work> ReinH: because they might already be forming a model in their head of what laziness means based on getContents and other lazy IO, so if you don't specifically call that out as deceptive it will cause confusion
13:31:53 <xplat|work> anyway, actual work.  i hope.
13:32:08 <EvanR> wedify: try to understand how some IO code works that uses the `when` library function to see
13:32:08 <maerwald> confusion is not bad per se, let them be confused for a while, so they can ask questions
13:33:26 <xplat|work> there's usually enough to be confused about in the thing you're trying to understand, without the confusion of mixing it up with other things entirely
13:33:40 <maerwald> don't fight it, let it happen :)
13:34:04 <EvanR> @src when
13:34:05 <lambdabot> when p s = if p then s else return ()
13:34:49 <ReinH> wedify: the important question to ask and answer is 'when is an IO action executed by the runtime?'
13:37:25 <EvanR> its important to (try to) know when stuff will be evaluated in general and IO is at the root of all that
13:37:46 <EvanR> so the question about evaluation specifically could be justified
13:38:27 <ReinH> wedify: http://www.vex.net/~trebla/haskell/lazy.xhtml will help you answer that question
13:38:30 <ReinH> er
13:38:34 <ReinH> sorry, wrong link. http://www.vex.net/~trebla/haskell/IO.xhtml
13:38:46 <ReinH> although maybe monochrom's post on laziness will too
13:39:26 <ReinH> and regardless should be required reading anyway imo
13:43:13 <monochrom> I explicitly mention that getContents is a weird thing
13:45:54 <monochrom> confusion is good for the scientifically minded only, because they detect it and fix it
13:46:00 <apes> Anyone that can help me figure out a dependency problem? I'm trying to get the Haskell Koans project working: https://gist.github.com/apeschel/9570d8ab4d37d453cf03
13:46:28 <monochrom> other people confuse confusion with insight.
13:46:58 <ReinH> apes: try with --allow-newer
13:47:34 <ReinH> it looks like testloop needs to relax its upper bound on unix
13:47:55 <apes> ReinH: That seems to have fixed it, thanks!
13:48:02 <ReinH> It looks like bounds weren't updated for 7.10
13:48:07 <ReinH> apes: np
13:53:42 <athan> Mer. Liquid Haskell doesn't parse polymorphic data types right. Mer.
13:54:08 <athan> er doesn't have the capacity or something
13:54:15 * athan is tempted to "try" idris
13:55:09 <monochrom> what is "Mer"?
13:56:32 <EvanR> idris rocks
13:57:03 <EvanR> for head exploding reasons, still dont know how it helps with liquid types
13:57:08 <EvanR> if at all
13:57:25 <athan> monochrom: frustration
13:57:38 <EvanR> youll need to learn cog or agda first to understand anything
13:58:25 <athan> EvanR: I'm probably very wrong with this, but I've been using LH to patch some extra value-level invariance on my Haskell types. But, it's buggy and can't do much :\ that's why I'm considering a fully dependently-typed language
13:58:32 <athan> I'm pretty familiar :)
13:58:42 <athan> I just have stuck with haskell while learning the theory
13:58:54 <EvanR> depending on what you were trying to do you might be able to use regular haskell
13:58:57 <athan> And have been doing shady type-stuff in haskell for a while >.>
13:59:49 <athan> EvanR: I'm pretty sure I can't :\ I make use of libraries like containers etc. in the Haskell version though, wonder what that's going to be like in idris :x
14:00:00 <EvanR> good luck
14:00:06 * athan salutes
14:00:15 <EvanR> utility libraries werent too developed last i checked
14:00:38 <EvanR> your whole plan might not even make sense with dependent types
14:01:24 <athan> EvanR: What pitfalls have you run into, converting an ML-style program to a dependently typed one?
14:02:01 <EvanR> i never tried that
14:02:02 <athan> And I honestly need the value-level invariant features of LH / dep. types - like making sure I can't divide by 0
14:02:05 <athan> oh
14:02:59 <EvanR> i did try various anti-div-by-zero things
14:03:16 * hackagebot MonadRandomLazy 0.1.1.1 - Lazy monad for psuedo random-number generation.  https://hackage.haskell.org/package/MonadRandomLazy-0.1.1.1 (NormanRamsey)
14:03:17 <EvanR> a lot of work
14:03:59 <athan> EvanR: Do you need to build proofs that a number /isn't/ zero or something?
14:04:12 <EvanR> depends on where the number comes from
14:04:28 <EvanR> if it comes with that proof, good
14:05:08 <trubert1> What's the most efficient way to take a list of (a,b,c) tuples and group by (a,b). For example, [(a1,b1,c1),(a1,b1,c2),(a1,b2,c3)] => [((a1,b1),[c1,c2]),((a1,b2),[c3])]
14:05:29 <athan> EvanR: I feel like I should learn this anyway :) thank you!
14:06:28 <EvanR> if it doesnt one way to deal with it is by checking at runtime, since its a decidable property
14:06:37 <EvanR> that will give you the proof (or not)
14:06:57 <EvanR> another way is to use math to derive the proof from other facts, and hope you have library support for this
14:07:14 <athan> :D
14:07:19 <EvanR> and a possibly a background in number theory
14:07:26 <athan> good thing I bought coffee today :P
14:08:23 <monochrom> trubert1: I think you can first map [(a,b,c)] to [((a,b), c)], then use "group"
14:08:55 <monochrom> err, no, "group" does something different
14:09:18 <monochrom> > group [1,1,2,2,0]
14:09:20 <lambdabot>  [[1,1],[2,2],[0]]
14:09:59 <athan> Or you could turn it into a Map, for automatic uniqueness
14:10:12 <athan> you just need to make sure you `unionWith (++)`, so the values don't just overwrite
14:10:46 <EvanR> athan: in general i think you want to synthesize these proofs during input validation
14:11:17 <monochrom> @type groupBy
14:11:19 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
14:11:34 <EvanR> for a non trivial numeric program youll probably have to just do a test at some point, and error out if its zero, defeating the whole purpose of the exercise
14:12:53 <athan> EvanR: Well, even that's fine, but the algorithm I'm building itself has scenarios like this that aren't from runtime input. I really just need a strong verification method for the structure of the code
14:13:56 <athan> I feel like idris might be for the lazy programmer then... :v
14:14:02 <EvanR> if the numbers come out of some algorithm, then it seems like itll be very hard to prove no zero
14:14:39 <EvanR> but if you use additional support it might be easy, like if you take the length of a non empty list
14:15:09 <EvanR> the result of a grouping of a non empty list is a set of non empty lists
14:15:28 <EvanR> but if its purely numeric good luck
14:15:54 <athan> EvanR: No, there's structure to it :) Thank you for your advice, I'll keep my helmet on
14:25:06 <wedify> i take it there's no way to abbreviate a module name when you are in that module. ie to disambuigate function names
14:26:01 <athan> EvanR: It's interesting how in idris, you build proofs and register them with your data, as a datum has some metrics associated with it, while in LH, you "dive in" to the datum, making metrics on the cons-cell's /contents/, instead of acknowledging the metrics of the data altogether
14:26:07 * athan might be vague..
14:26:28 <athan> wedify: Not that I've found, other than qualifying the externally conflicting names :\
14:27:21 <pavonia> Importing the module qualified doesn't work?
14:28:58 <wedify> no it says error module imports itself
14:29:34 <pavonia> Too bad
14:29:35 <wedify> so basically i have to qualify a ton more calls than i would if i could abbreviate the module name. guess who's getting renamed :P
14:33:18 * hackagebot dbmigrations 1.0 - An implementation of relational database "migrations"  https://hackage.haskell.org/package/dbmigrations-1.0 (JonathanDaugherty)
14:37:43 <pavolzetor> does anybody has experience in scaling haskell? why is my code actually slower on 2 cores?
14:38:28 <pavolzetor> I would like to scale to around ~50 cores on shared memory system, preferably close to lineary (ray tracing)
14:38:33 <johnw> pavolzetor: can you show me your code?
14:39:04 <johnw> also, have you seen Simon Marlows book on writing parallel and concurrent code in Haskell?
14:39:50 <pavolzetor> johnw, I went through the first chapter month ago
14:39:54 <ReinH> pavolzetor: read his book
14:40:23 <ReinH> it's a book written by the expert on how to do the thing you want to do.
14:40:33 <ReinH> You should read it and then see if you still have questions.
14:41:00 <pavolzetor> I agree
14:41:19 <ReinH> Unless you have very specific questions, I highly doubt that you'll get better advice in here than you will get from the book.
14:41:35 <pavolzetor> my specific question is how to minimize memory churn
14:41:43 <ReinH> that is not a very specific question
14:41:45 <ReinH> that is a very general question
14:42:30 <pavolzetor> I will read the book then; what I really want to avoid is recoding whole thing when it will not scale past some threshold ;)
14:42:39 <pavolzetor> it is a lot of effort
14:43:02 <pavolzetor> so if somebody actually done it here on IRC and tells me it works it would make me sleep better 
14:43:38 <ReinH> Yeah, it would be a shame to read a great book that will benefit you every time you write a haskell program if you didn't need to.
14:45:30 <ReinH> A properly written ray tracer should scale nearly linearly in Haskell or any other language with sufficient parallism support.
14:45:49 <pavolzetor> ReinH, no need to be sarcastic, I am going to read the book 
14:46:00 <pavolzetor> ReinH, far far from true
14:46:09 <danclien> ReinH: what book are you recommending?
14:46:22 <pavolzetor> danclien
14:46:22 <pavolzetor> Parallel and Concurrent Programming in Haskell
14:46:25 <ReinH> on the other hand, the fastest ray tracers depend on instruction-level parallelism (SIMD), so you are going to be limited to some extent.
14:46:47 <danclien> Ah, nice. It's been on my bookshelf for a couple of months now, and I still haven't read it. D:
14:47:01 <ReinH> pavolzetor: why do you think that's not true?
14:47:16 <pavolzetor> ReinH, I am not doing classical ray tracer, I am generating geometry on the fly
14:47:26 <ReinH> I didn't say *your* ray tracer.
14:48:14 <pavolzetor> ReinH, sure, but ray tracers are mostly memory bound (and production ones IO bound)
14:48:17 <ReinH> ray tracing is a data parallel problem, so it should be especially easy to get good results with haskell
14:48:30 <ReinH> since haskell is very good at data parallelism
14:48:42 <pavolzetor> precisily *memory bound* wories me as I haven't figured out how to do partition in place or these things in haskell
14:49:06 <pavolzetor> ReinH, not if you miss cache on every single access
14:49:28 <pavolzetor> ReinH, that's why I am asking here if anybody actually did this sort of problem
14:49:47 <pavolzetor> ReinH, there are no papers I could find
14:49:51 <ReinH> edwardk probably has some experience
14:50:55 <pavolzetor> ReinH, but is there some resource of controlling the execution or do I have to do imperative in monad?
14:51:06 <ReinH> pavolzetor: what sort of control over execution do you require?
14:51:20 <pavolzetor> for example, I want to do, take a stream of rays, and then partition them into intersect and non-intersect recursively
14:51:27 <pavolzetor> so I do not want to do any copying
14:51:49 <ReinH> You shouldn't need to worry about execution
14:51:52 <pavolzetor> so if I write it recursively, will it copy every single call?
14:52:08 <pavolzetor> ReinH, I want to render animations ;)
14:52:35 <ReinH> You should worry about sharing first
14:52:55 <pavolzetor> elaborate please
14:52:56 <ReinH> you should be able to write a good cache-oblivious kd-tree in haskell, or maybe someone already has.
14:53:12 <ReinH> values that are shared will not be re-computed
14:53:33 <pavolzetor> Okay, I will have a look
14:53:34 <Lokathor> can anyone speak to how necessary it is to use a BroadcastTChan over a TChan within the STM framework?
14:53:36 <ReinH> I know edwardk has been doing a lot of work in that space
14:53:46 <Lokathor> it seems like a "fiddle with it if you need it" deal
14:53:47 <ReinH> maybe when he's around he can offer more specific advice
14:54:34 <pavolzetor> ReinH, thanks, the thing is the data is not static for splitting
14:54:38 <ReinH> Lokathor: Well, I guess you would use it if you want broadcast?
14:54:59 <ReinH> Lokathor: I don't see why you'd use it otherwise.
14:55:00 <pavolzetor> ReinH, http://renderman.pixar.com/view/reyes-renderman-under-the-hood
14:55:15 <Lokathor> ReinH, I've got a setup where each "client" is reprisented as a pair of Socket (for inbound) and TChan (which a separeate thread reads from and then writes that to the socket)
14:55:20 <pavolzetor> look at the picture, I am doing only the first stage
14:55:41 <Lokathor> i'm not sure if i need to switch the outbound message TChan to an outbound message BroadcastTChan
14:56:06 <pavolzetor> and each new primitive i tested agains some packet of rays
14:56:24 <ReinH> pavolzetor: you can perhaps look at some of the stuff edwardk does with quine for inspiration
14:56:34 <ReinH> he has some interesting solutions to some of these problems
14:57:15 <ReinH> pavolzetor: how many things read from the channel?
14:57:46 <ReinH> *each channel
14:58:23 <Lokathor> was that to me? if so, many things can write to the channel, but only one thread reads from each client's channel
14:59:00 <pavolzetor> ReinH, quine seems pretty cool, I will have look; from first glance it seems to be ray marching in shader
14:59:19 <ReinH> pavolzetor: yeah, I think that's accurate. Not the same problem, but in the same ballpark. :)
14:59:44 <pavolzetor> ReinH, you read a bicubic bezier patch (16 points) and then split it until you hit subpixel level
14:59:51 <pavolzetor> this is done on the fly
15:00:10 <pavolzetor> all on cpu
15:00:18 <pavolzetor> what do you mean by channel?
15:00:48 <ReinH> pavolzetor, Lokathor: sorry, that was addressed to the wrong person
15:01:04 <ReinH> Lokathor: if only one thing consumes the channel, I don't see why you would want broadcast semantics
15:01:26 <pavolzetor> ReinH, no worries, I am going to read that book and see, maybe I will have to change the architecture of the traversal, thanks for the hints
15:01:46 <ReinH> pavolzetor: try to catch edwardk too, I'm sure he'd have a lot of good info for you
15:01:51 <Lokathor> if you use a broadcast channel, then you have to read from it by making a duplicate and reading from that. seems like it would use more memory?
15:02:04 <pavolzetor> ReinH, I emailed him so I hope for a reply
15:02:38 <ReinH> Lokathor: I'm not sure that that's the case, but I also don't know why you'd use broadcast in the first place.
15:03:18 * hackagebot hi3status 0.1.1.0 - Status line for i3bar.  https://hackage.haskell.org/package/hi3status-0.1.1.0 (ScrambledEggs)
15:03:45 <Lokathor> yeah i guess i'll just stay away from broadcast for now
15:03:51 <Lokathor> possibly adjust later
15:05:13 <Lokathor> hmm, doesn't seem like you can close a TChan
15:07:23 <ReinH> Lokathor: a broadcast TChan is just one where reading is disabled.
15:07:35 <ReinH> Then all consumers have to be given a duplicate from which to read.
15:07:41 <ReinH> It's just a way to enforce the broadcast semantics
15:07:56 <Lokathor> yeah it seems to be for many-reader situations
15:08:05 <ReinH> if you have a single reader, I don't see a reason to use a broadcast tchan.
15:08:09 <Lokathor> i've got a single-reader and many writers, so basically the opposite almost
15:08:52 <Lokathor> and it's running as an Async, so I don't need to close the TChan or handle its reading thread. The thread that spawns it can just die off
15:08:55 <monochrom> IIRC TChan can be safely used for multiple writer, single reader
15:09:03 <ReinH> monochrom: I believe so.
15:09:15 <Lokathor> yeah that's what it is mostly for
15:09:28 <Lokathor> i think the BroadcastTChan is just an optimization thing you can sometimes use
15:09:30 <ReinH> writes are atomic, although I'm not sure if ordering is guaranteed.
15:09:36 <Lokathor> just saw it in the docs and thought i'd ask
15:10:21 <Lokathor> ReinH, I think you're right; ordering isn't anything in particular. That's the advantage of MVar over STM
15:11:16 <glittershark> Does anyone know of a library that provides better functionality for manipulating `Eq k => [(k, v)]`s?
15:11:30 <ReinH> glittershark: for anything non-trivial, you should use a Data.Map instead
15:11:36 <glittershark> well, yeah
15:11:49 <glittershark> but Network.HTTP.Types.SimpleQuery is a [(k,v)]
15:12:07 <monochrom> no, we aren't excited about Eq k => [(k,v)]'s, unlike Scheme people, say
15:12:15 <ReinH> Well, what are you trying to do with it?
15:12:36 <glittershark> and short of converting it to a hashmap and back just to insert I ended up writing `Eq k => [(k,v)] -> (k,v) -> [(k,v)]` myself
15:12:39 <glittershark> insert
15:12:46 <glittershark> it's like a four-line function
15:12:57 <glittershark> I just wanted to know if I was reinventing some obvious wheel
15:13:05 <ReinH> it's a three character function: (:)
15:13:12 <glittershark> well
15:13:21 <glittershark> not if you want to overwrite if the key is already present
15:13:25 <glittershark> which is exactly what I want
15:13:30 <ReinH> That depends on how the list is processed
15:13:44 <ReinH> if the first item is taken, it does overwrite and the only thing you're doing is wasting a little space
15:13:44 <monochrom> I would, as a first order of business, immediately shovel Network.HTTP.Types.SimpleQuery's [(k,v)] into a Map, before any further processing
15:14:00 <nolraiU> what monochrom said.
15:14:13 <glittershark> yeah I was originally doing what monochrom said too
15:14:20 <monochrom> after all, even aeson does that during JSON parsing, IIRC
15:14:25 <glittershark> then someone complained about it in code review :)
15:14:28 <ReinH> if not, it's (: (k,v)) . filter (/= k . fst)
15:14:31 <Lokathor> https://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html when i try to write a do block that's like the withAsync block example
15:14:40 <Lokathor> ghc tells me i've got an empty do block
15:14:58 <monochrom> I'm pretty sure the complaint can be refuted
15:15:04 <ReinH> Lokathor: You know the drill. Show us your code and the error.
15:15:16 <glittershark> ReinH: that's one way to do it, yeah
15:15:45 <ReinH> glittershark: but I agree that you should turn it into a Map (as long as your key also has an Ord instance).
15:15:58 <Lokathor> http://lpaste.net/148064
15:16:04 <glittershark> yeah all the typeclass instances are fine
15:16:10 <Lokathor> line 12
15:16:22 <glittershark> does the laziness of Map make that not overkill for inserting a single key?
15:16:31 <ReinH> Lokathor: indentation.
15:17:05 <monochrom> Map is already not lazy. for further anti-laziness, Data.Map.Strict exists
15:17:10 <Lokathor> right, but the Control.Concurrent.Async shows an example that doesn't have extra indentation with each new use of withAsync
15:17:21 <Lokathor> so i was wondering if their example code is off or what
15:18:15 <monochrom> is "a" used anywhere?
15:18:58 <glittershark> monochrom: in this case I actually *want* it to be lazy, so that I don't end up instantiating the structure of the entire map just to run equality on a single key
15:19:16 <glittershark> the cons composed with filter is fine too, though
15:19:32 <glittershark> ReinH's implementation
15:19:44 <glittershark> I guess I've just written too much erlang :P
15:19:54 <Cale> glittershark: Due to the need to do order comparisons on the keys, it can't be very lazy
15:20:04 <monochrom> an HTTP header is not big enough to warrant maximum laziness
15:20:09 <glittershark> that's fair
15:20:16 <glittershark> premature optimization is the root of all evil and whatnot
15:20:22 <Lokathor> monochrom, i don't actually want the 'a' value, no. But I want the behavior where the async dies when the parent thread dies
15:21:01 <monochrom> and even in the big case, you still don't know that laziness helps. laziness helps this iff the key you lookup happens to be a key you inserted recently.
15:21:22 <glittershark> well in this case it's coming from the request
15:21:27 <glittershark> so it's user input
15:21:50 <ReinH> Lokathor: yeah, I am confused too.
15:22:18 <ReinH> tbqh if the params assoc list is large enough that any of this matters, you will have other problems first anyway
15:22:33 <Lokathor> ReinH, by the Async docs? or by my code?
15:22:35 <ReinH> like browser limitations on same
15:22:42 <ReinH> Lokathor: the async docs
15:22:51 <Lokathor> oh good :P
15:23:16 <ReinH> maybe I'm wrong about the indentation, but then it should work
15:23:20 * ReinH shrugts
15:23:34 <anelson_> hey guys, why is there no Arbitrary instance for Data.Text? Has anyone written one?
15:24:01 <Lokathor> anelson_, you could get an Arbitrary String and then use T.pack
15:24:03 <ReinH> anelson_: pack <$> arbitrary is pretty easy to use.
15:24:28 <Lokathor> usually you want specific sorts of text, i'd imagine
15:24:48 <anelson_> Well I'm trying to use `derive` to make an instance of a sum type I've written
15:25:18 <anelson_> I guess I could just write one like ReinH said
15:25:21 <Lokathor> ah. well if it's just in your testing module, an orphan instance there won't kill you
15:25:31 <anelson_> Lokathor: yeah that's what I figure :)
15:26:29 <glittershark> I -fno-warn-orphans on my entire test package, fwiw
15:26:45 <anelson_> glittershark: it comes up that often?
15:26:55 <glittershark> I write a lot of Arbitrarys
15:27:03 <nolraiU> That ^^^
15:27:08 <Lokathor> yeah, your core package doesn't want to require QuickCheck
15:27:19 <Lokathor> so all your arbitrary instances are orphan in their own testing modules
15:27:27 <anelson_> glittershark: this is my first time writing an instance
15:27:30 <glittershark> yep, what Lokathor said
15:27:47 <anelson_> writing an instance for a product type seems simple enough, but idk how to do one for a sum type
15:27:50 <glittershark> anelson_: welcome to the wonderful world of fuzz testing!
15:27:59 <anelson_> :D
15:28:17 <Lokathor> anelson_, normally, as you might know, you want to avoid orphan instances if at all possible. an instance should be defined where the data type is or where the typeclass is to not be orphan
15:28:20 <johnw> anelson_: usually you do a distribution of possible constructors
15:28:46 <johnw> anelson_: I like to use `frequency' to pick my weights manually
15:29:00 <monochrom> Lokathor, ReinH: http://lpaste.net/148065  works
15:29:06 <johnw> arbitrary = frequency  [(1, CtorOne ...), (5, CtorTwo ...)]
15:29:16 <johnw> that makes CtorTwo 5 times more likely to be generated by arbitrary than CtorOne
15:29:24 <anelson_> johnw: any quick examples online?
15:29:25 <glittershark> I don't think a frequency for Text is really necessary
15:29:34 <Lokathor> monochrom, then why didn't mine work?
15:29:35 <glittershark> weighted Gen is really useful for nested tree structures
15:29:38 <johnw> and the CtorOne will be like CtorOne <$> arbitrary, etc.
15:29:40 <monochrom> I don't know yet
15:29:41 <anelson_> glittershark: yeah for my purposes arbitrary string should be fine
15:29:59 <monochrom> but now you have a small simple test to test your compiler first
15:30:02 <Lokathor> ganbatte!
15:30:07 <johnw> anelson_: see https://github.com/jwiegley/linearscan-hoopl/blob/master/test/Generated.hs
15:30:22 <johnw> that code generated entire assembly programs based on a tiny assembly DSL
15:30:49 <anelson_> johnw, thanks
15:30:58 <Lokathor> i like using "IO loop" as the type of a forever action
15:31:03 <Lokathor> thanks STM docs
15:31:10 <johnw> Lokathor: that's cute
15:31:20 <nolraiU> johnw: You should used sized though if it's recursive.
15:31:38 <johnw> nolraiU: the code I linked to does use sized
15:31:59 <nolraiU> Ah, sorry.
15:32:27 <nolraiU> Was responding to the initial "anelson_: I like to use `frequency' to pick my weights manually".
15:32:45 <johnw> thanks for mentioning it though
15:34:59 <anelson_> johnw: this is for https://github.com/adnelson/nix-eval by the way, thought you might be curious :)
15:37:14 <johnw> anelson_: is this an alternative to hnix?
15:37:24 <johnw> ah, I see
15:38:06 <anelson_> johnw: nah, the readme talks about that
15:41:26 <glittershark> \part
15:41:56 * hodapp reads about hnix...
15:45:00 <Lokathor> @pl (\list -> Just $ filter (/=) cc list)
15:45:00 <lambdabot> Just . filter (/=) cc
15:50:40 <dresuer> Who created lambdabot ?
15:51:25 <kazagistar> dresuer: https://github.com/lambdabot/lambdabot/graphs/contributors
15:55:36 <dresuer> kazagistar, thanks
16:00:18 <dmwit> Lokathor: I don't believe your original code is correct.
16:00:33 <Lokathor> dmwit, oh?
16:00:34 <dmwit> ?pl (\list -> Just $ filter (cc /=) list)
16:00:34 <lambdabot> Just . filter (cc /=)
16:00:48 <dmwit> :t \cc list -> filter (/=) cc list -- type error
16:00:49 <Lokathor> oh that, yes i caught that as soon as i went to build it
16:00:49 <lambdabot>     Couldn't match expected type ‘t -> r’ with actual type ‘[a]’
16:00:49 <lambdabot>     Relevant bindings include
16:00:49 <lambdabot>       list :: t (bound at <interactive>:1:5)
16:05:41 <wedify> how feasible would it be to port ghc to adga? what parts would we not be able to implement?
16:13:12 <c_wraith> wedify: you mean agda?  There's no part that would be all that hard to convert, specifically.  The obstacle would be how huge ghc is.
16:15:10 <wedify> i've been learning more about dependent types. i was thinking maybe i could prove the correctness of the type checker or something
16:15:33 <c_wraith> The type checker is probably the biggest part of GHC at this point. :)
16:15:44 <wedify> maybe just modelling the semantics of haskell would be a good start
16:15:50 <c_wraith> With all the extensions it can handle, it's absolutely huge.
16:16:55 <wedify> maybe that's why it should be done in agda :)
16:17:37 <c_wraith> No one would mind an agda implementation of all of haskell's type system.  It'd just be a huge undertaking.
16:18:17 <c_wraith> Also, it's known that there are some silly band-aids in GHC at the moment that cover much deeper issues.  Modelling those exactly would make it obvious just how bad those are. :)
16:19:01 <wedify> yeah, i need something much smaller. i've been using data.sg for collision detection so i think i will start with that
16:19:21 <c_wraith> In particular, "here be dragons" areas of ghc's type system include GeneralizedNewtypeDeriving and the role system.
16:19:26 <wedify> how well-factored is the type checker? maybe i could do a small part
16:20:09 <kadoban> GeneralizeNewtypeDeriving is "here be dragons"? It seemed pretty straightforward and conservative I thought?
16:20:14 <exio4> c_wraith: I don't think you need dependent types to see how hacky those band aids are :P
16:21:00 <rolphrecto> is the typechecker complicated just because of all the stuff on top of hindley-milner? because algorithm w seems pretty simple
16:23:04 <c_wraith> kadoban: no, without the role system, GND was able to write unsafeCoerce
16:23:21 * hackagebot hops 0.4.1 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.4.1 (AndersClaesson)
16:23:30 <c_wraith> Though that was when mixed with GADTs, which are certainly more complex
16:23:55 <c_wraith> rolphrecto: no, H-M is not the complex part.  The complex part is the interaction of all the various type system extensions.
16:28:21 * hackagebot wai 3.2.0 - Web Application Interface.  https://hackage.haskell.org/package/wai-3.2.0 (KazuYamamoto)
16:28:34 <wedify> does haskell-src-exts parse all the extensions ghc uses?
16:29:18 <wedify> if i were to follow through on this hypothetical project a translator would be the first thing i'd implement
16:30:48 <wedify> would one be able to "pass on" the types to adga?
16:32:07 <wedify> i guess that brings us back to implementing haskells type system in adga
16:35:44 <wedify> so the first part would be hindley-minler type system. what would be the next part in order to approach haskell's type system?
16:37:38 <wedify> doesn't look like anyone has done a complete h-m in agda so i think i've found my project :)
16:38:20 <hodapp> wut
16:38:32 <hodapp> What's the point of H-M in Agda?
16:39:44 <wedify> a first step to proving ghc's correctness
16:40:30 <hodapp> correctness with regard to what?
16:41:43 <kadoban> How will another implementation of H-M prove GHC's correctness?
16:42:22 <wedify> i guess i should say modeling haskell's semantics in agda
16:43:13 <wedify> ie, not an implementation but a definition
16:44:47 <wedify> anyways it doesn't matter, too big of a project. but algorithm w in agda seems like a good project
16:45:15 <jonkri> Does anyone here have any experience with packages related to converting, and otherwise manipulating, video files (perhaps using Ffmpeg) using Haskell?
17:19:34 <twilkens> does anyone know of a way to handle json where the type of a given field could be either a string or an integer (using aeson)?
17:21:14 <Cale> Parser is an instance of Alternative, you can use <|>
17:21:20 <monochrom> do you mean that both { "x": "xxx" } and { "x" : 10 } are possible?
17:21:35 <twilkens> monochrom: yes
17:22:39 <twilkens> I am also OK with ignoring the field if it is an integer
17:24:44 <monochrom> I conjecture that this will work:  data X = X0 Text | X1 Int;  instance FromJSON X where { parseJSON (Object v) = (X0 <$> v .: "x") <|> (X1 <$> v .: "x"); parseJSON _ = empty }
17:25:59 <monochrom> using the trick that it is the type, Text vs Int, that drives the 1st ".:" to be the Text parser, and the 2nd ".:" to be the Int parser
17:26:18 <monochrom> and one of them is bound to fail
17:26:34 <pdxleif> @hoogle IO (Maybe a) -> EitherT String IO a
17:26:37 <lambdabot> Did you mean: IO (Maybe a) -> EitherT String (IO a) a
17:26:37 <lambdabot> No results found
17:26:46 <twilkens> monochrom: OK that makes sense. I think that should work. Thanks!
17:26:47 <pdxleif> wat
17:27:48 <pdxleif> @hoogle Maybe a -> Either String a
17:27:49 <lambdabot> No results found
17:28:23 * hackagebot warp 3.2.0 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.0 (KazuYamamoto)
17:29:13 <monochrom> the "x" there needs OverloadedString, because .: wants Text for it too
17:38:00 <ReinH> pdxleif: note from errors will help
17:38:24 * hackagebot warp-tls 3.2.0 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.2.0 (KazuYamamoto)
17:39:03 <ReinH> pdxleif: that and the EitherT constructor (although these days people tend to use ExceptT since it's in transformers)
17:40:07 <ReinH> twilkens: or use Either String Int
17:43:12 <twilkens> Reinh: I had originally tried this. But, I got an error that said something like "key must start with Left or Right"
17:52:33 <haskell538> Would you guys recommend HSpec for testing library code?
17:52:55 <dmj`> haskell538: yea
18:02:54 <pdxleif> ReinH: Using EitherT cause that's what servant wants
18:03:27 <Jinxit> if I'm in a do block of a State, and the outer function is IO, how do I do an IO action?
18:03:50 <dmj`> Jinxit: you want a StateT then
18:04:02 <hiptobecubic> and IO has be on the inside.
18:04:09 <hiptobecubic> has to be*, rather
18:04:14 <Jinxit> I'm inside a hspec test
18:04:21 <Jinxit> and inside of that I have my own State
18:04:31 <ReinH> twilkens: no, do the same as monochrom's: Left <$> o .: "k" <|> Right <$> o .: "k"
18:04:50 <pdxleif> ReinH: note looks great - thanks!
18:04:56 <dmj`> Jinxit: I know there is a runIO function in hspec
18:04:57 <ReinH> pdxleif: np
18:05:13 <pdxleif> Wish there was also an EitherT version of noteT. Suppose it's simple enough to define.
18:05:27 <Jinxit> but will StateT also solve it?
18:05:47 <slack1256> what is the current flagship package for extensible effects?
18:06:46 <dmj`> @package extensible-effects
18:06:46 <lambdabot> http://hackage.haskell.org/package/extensible-effects
18:07:05 <dmj`> Jinxit: yes, since StateT in an instance of MonadIO
18:07:45 <Jinxit> and how do I rewrite my State functions? I've gone down this road before with little success
18:08:36 <dmj`> Jinxit: you can make them generic using MonadState, then you won't have to
18:08:41 <haskell538> Any way to automatically add dependencies to a cabal file after its been generated?
18:08:57 <Jinxit> just change State to MonadState everywhere?
18:09:17 <monochrom> I don't know of an automatic way. I just edit by hand.
18:09:31 <monochrom> it has the benefit of getting vetted through my brain first.
18:09:49 <dmj`> Jinxit: yea, https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Class.html
18:10:02 <Jinxit> alright, I'll give it a shot, thanks
18:10:04 <haskell538> just added hspec and it downloaded like 6 dependencies, was just being lazy
18:10:14 <dresuer> hi all
18:10:17 <dresuer> ;)
18:10:46 <monochrom> I don't think you're supposed to add indirect dependencies
18:11:00 <haskell538> oh okay cool
18:11:02 <haskell538> good to know
18:11:24 <monochrom> for library packages, you add it iff you import a module from it
18:12:04 <Gurkenglas> Jinxit, replace "a -> State b c" with "MonadState b m => a -> m c". Use (lift :: IO a -> StateT IO a) where you want to do the IO action, and use runStateT instead of runState etc.
18:12:28 <Jinxit> okay
18:17:54 <dmj`> Jinxit: lift / liftIO would do the same there
18:18:12 <homovitruvius> w/ cabal the solution against 'Hpc failure: module mismatch with .tix/.mix file hash number' is to --enable-coverage when configuring. How do you do the same with stack? I was under the impression it was taking care of this automatically, but it doesn't for me. Thx
18:18:23 <dmj`> > flip evalStateT 4 (lift (print 4) :: StateT Int IO ())
18:18:25 <lambdabot>  <IO ()>
18:18:36 <Gurkenglas> Oh yes liftIO is probably a better idea. the type annotation wasnt needed in the first place of course I just wanted to show what type it would take there
18:19:29 <Gurkenglas> (You'll have to add MonadIO m to the left of => whereever you use liftIO, even indirectly.)
18:21:13 <dmj`> if you constrain your m on both MonadState and MonadIO, you won't be able to use it with normal a State, only StateT, since there is no MonadIO instance on State
18:22:34 <pdxleif> ReinH: So far I've got "EitherT $ note err404 <$> query acidstate (LookupKey k)"
18:23:08 <pdxleif> (where query ... is an IO (Maybe a))
18:24:19 <Jinxit> Gurkenglas: this is giving me trouble with my lenses :(
18:24:33 <Jinxit> could not deduce Zoom (...)
18:24:49 <c_wraith> lenses don't really work across IO
18:24:58 <Majiir> Can anyone recommend a convnet library? I took a look on Hackage and found some neural net libs, but nothing that would do convnets
18:25:00 <Jinxit> not trying to do IO here
18:25:06 <Jinxit> just switching to MonadState
18:25:13 <Gurkenglas> Show your code please, lpaste
18:25:30 <dmj`> pdxleif: it should be assumed you're in the EitherT monad
18:26:23 <Jinxit> Gurkenglas: http://lpaste.net/8635358556964519936
18:26:32 <dmj`> pdxleif: maybe error404 return =<< do liftIO $ query acidState
18:27:02 <c_wraith> Jinxit: just add the constraint
18:27:28 <c_wraith> Jinxit: not all MonadState instances support Zoom
18:27:52 <c_wraith> Jinxit: So if you're going to use zoom, you need to specify that the instance you're using must be one that supports Zoom
18:31:12 <Gurkenglas> Jinxit, by the way "activeMinions.traversed.isSleepy .= False"
18:32:43 <pdxleif> I dunno, "EitherT $ note err404 <$> query acidstate (LookupKey k)" might be easier for me to follow than "liftIO (query acidstate (LookupKey k)) >>= maybe (left err404) pure"
18:33:01 <Jinxit> Gurkenglas: good catch
18:33:31 <Jinxit> any better way of writing the last zoom?
18:34:28 <Jinxit> I really don't want to write the Zoom constraints everywhere (I use zoom a lot), any downsides to just using StateT?
18:36:01 <Gurkenglas> When you use MonadState everywhere, large-scale refactorings are easy. If you find that you'll use the same set of constraints everywhere, you can define an alias for that set
18:36:43 <Gurkenglas> *some become easy
18:39:45 <Gurkenglas> (Wait, wasn't one of the reasons for introducing those typeclasses in the first place that you would only need to add the constraints you need to each function?)
18:40:14 <dmj`> Jinxit: maybe typedef it
18:40:54 <Jinxit> trying to figure out what the constraint should even look like but I have other compile errors in my way atm
18:59:49 <ReinH> Jinxit: try to only work on one compiler error at a time
18:59:53 <ReinH> it's easier that way
19:00:38 <ReinH> (Yes, I realize that you only get to see one at a time. I mean that fixing that error should cause the program to compile rather than show another error.)
19:01:15 <ReinH> Eventually this won't be as important, but when you're starting out it makes things much easier.
19:14:41 <Jinxit> nope, I don't get this Zoom constraint
19:15:39 <fserb> Is there a way to lazily load a file that contains a list of Int32 with Data.Binary? I've tried the default decode, but it seems to expect that the first Int32 is the size. Can I do this without getting the size?
19:20:38 <ReinH> fserb: you want the result to be [Int32]?
19:20:43 <fserb> yep
19:21:41 <ReinH> if you wanted a Vector Int32 you could just mmap it and get a Storable for free
19:22:57 <ReinH> otherwise you probably just want to use get repeatedly until isEmpty
19:26:03 <ReinH> e.g., getList = do empty <- isEmpty; if empty then return [] else do x <- get; xs <- getList; return (x:xs)
19:26:20 <ReinH> (indented properly ofc)
19:30:07 <Jinxit> c_wraith: am I correct in assuming the Zoom constraint is "this thing can zoom into that other thing"?
19:30:10 <Pamelloes> Given a list of functions [forall b. Eq b => MyType -> b] and two values of MyType, how can I apply all of the functions and then compare their values to produce a new [Bool] where True indicates the result was the same for both values and False indicates it was different?
19:33:15 <pavonia> :t [] :: [forall b. Eq b => Int -> b]
19:33:16 <lambdabot>     Illegal polymorphic or qualified type: forall b. Eq b => Int -> b
19:33:16 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
19:33:16 <lambdabot>     In an expression type signature: [forall b. Eq b => Int -> b]
19:34:01 <Pamelloes> Hmmm, I've declared a value with the type [forall b. Eq b => MyType -> b] (via ImpredicativeTypes) but I'm having difficulty populating the list.
19:34:05 <Pamelloes> Am I not allowed to put a function with a fixed b value in the list?
19:37:24 <pavonia> Pamelloes: I think what you want is a wrapped type "data AnyF = forall b. Eq b => AnyF (MyType -> b)"
19:37:35 <carmethene> hi, possibly stupid question, but it wasn't covered in LYAH (or I missed it)
19:37:44 <carmethene> if I want to do something like:
19:37:58 <carmethene> (++) <$> list1 <*> list2
19:38:21 <carmethene> is it possible to do it inside main?
19:38:35 <nitrix> Where you do it doesn't matter.
19:38:36 <Zekka> carmethene: Yeah, that's just a valid value of type list
19:38:39 <carmethene> from messing about it seems like the answer is no, I get complaints that it's not the IO monad
19:38:42 <carmethene> hmm
19:38:50 <carmethene> I'm literally just doing:
19:38:51 <Zekka> carmethene: Are you just trying to sequence it as an IO action?
19:38:54 <carmethene> no
19:39:11 <Zekka> Because giving it a separate line in your "do" block will make Haskell think you meant to use it as an IO action
19:39:17 <pavonia> Pamelloes: I've never really understood impredicative types, but I'm fairly sure you don't want to use them with "real" values
19:39:23 <carmethene> I'm trying to use it with [a] <*> [a] to build a list of combinations
19:39:29 <carmethene> oh, that's probably what's going on
19:39:36 <Zekka> Let me write you two examples
19:39:41 <nitrix> > (++) <$> [[1..5]] <*> [[6..10]]
19:39:42 <fserb> ReinH: I'll try that, thanks a lot :)
19:39:43 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10]]
19:39:56 <carmethene> oh hold on, I'm not binding it to anything
19:39:58 <carmethene> that's probably why
19:40:14 <Zekka> Be sure to use let!
19:40:24 <carmethene> yes
19:40:29 <carmethene> I'm just being stupid
19:40:30 <Zekka> <- means 'do the monad action and give me the value' -- let means 'give this value a name'
19:40:32 <carmethene> sorry
19:40:33 <nitrix> The problem is that you need something that's a functor and applicative which happens to have a list inside (because of (++) being used).
19:40:40 <Pamelloes> pavonia: I'm having irc client issues. Apparently it's taking my messages an hour or so to go through. Hopefully this one reaches you :) Anyways, I've pretty much figured it out but I can't talk because I'm in the process of restarting my znc and stuff
19:40:46 <carmethene> yeah I jumped from applicative functor to monad
19:40:52 <Zekka> Don't worry about it, even after learning Haskell I would fail to catch myself out on cases like that
19:40:53 <carmethene> and tried to remove the context
19:40:57 <carmethene> which doesn't exist obv
19:41:14 <carmethene> next time I'll use the code duck
19:41:16 <Zekka> Usually I'd have subtler bugs, like not giving a function all its arguments which would causeHaskell to assume I meant a different operation
19:41:21 <carmethene> lol
19:41:49 <carmethene> I guess this is the Haskell version of forgetting a semicolon
19:41:52 <carmethene> :P
19:41:52 <Zekka> you might not have run into this yet, but (->) is a monad. So I'd accidentally bind over a function minus one arg, and it would assume I wanted to use the (->) monad
19:42:02 <carmethene> just covered that in the book
19:42:07 <Zekka> (more pedantically (a ->) is a monad)
19:42:09 <carmethene> the -> being a monad thing
19:42:18 <carmethene> but... yeah needs a couple more re-reads before I attempt to use it
19:43:05 <carmethene> thx for the help :)
19:43:15 <Zekka> Don't worry about it, good luck
20:01:22 <Jinxit> http://lpaste.net/5127709975216390144 can't figure it out
20:07:16 <pavonia> Jinxit: What's the type of zoom?
20:09:04 <Jinxit> pavonia: Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
20:09:42 <pavonia> Uh lenses
20:11:31 <pavonia> From what I understand the resulting monad is more specific than "MonadState Game m => m"
20:11:44 <Jinxit> yes, but I can
20:11:48 <Jinxit> 't figure out the constraint
20:13:03 <pavonia> m ~ Zoom (StateT Player Identity) m' Player or something like that
20:13:16 <Jinxit> regardless, I don't see why the constraint is even needed, it still has the same state type after the zoom has ended no?
20:14:11 <Gurkenglas> umm try "(Zoom (StateT Player Identity) m Player Game)" as the error says?
20:14:13 <pavonia> It has a more specific type
20:14:54 <pavonia> Oh, Zoom is a class
20:18:27 <Gurkenglas> "t <- turn <%= \x -> (x + 1) `mod` (length (game^.players))" <- How about "t <- (`mod` length (game ^. players)) <$> turn <+=1"?
20:19:17 <Jinxit> I had a similar thing before, but I opted for readability
20:19:51 <Jinxit> still can't get it to work, getting "No instance for (MonadState Game Identity)" elsewhere
20:20:54 <Gurkenglas> And you might want to do "playercount <- uses players length" instead of "game <- get" since game changes during your do block and you might accidentally use game later
20:24:12 <Gurkenglas> (By the way StateT Player Identity is State Player so you can use that in the constraint)
20:25:13 <Jinxit> I still don't see why it can't be inferred
20:25:25 <potatoe> has anyone used the Web.JWT module before? I'm trying to create a token with my custom type as the payload (JSON) but setting unregisteredClaims to it doesn't work
20:25:39 <Jinxit> trying to use it with lift atm
20:27:21 <Gurkenglas> paste pls
20:32:01 <Jinxit> Gurkenglas: http://lpaste.net/4817658695594803200
20:35:30 <Gurkenglas> btw you wouldn't need to flip execStateT if you did "game2 :: Game -> m Game; game2 = execStateT $ do {...}" (type annotation of course optional)
20:38:43 <Jinxit> I don't get it
20:40:04 <Gurkenglas> Line 12 could for example be "let play2 = play $ do", and then where you would have used "game2" you use "play2 game"... or do you need game2 multiple times?
20:40:35 <Jinxit> I do, for checking things in the current state
20:40:52 <Jinxit> to verify stuff in the test
20:40:54 <Gurkenglas> -play+execStateT <.< because play flips it
20:41:09 <Jinxit> but yeah I see what you mean I think
20:41:15 <Jinxit> saving the actions instead of the state
20:42:32 <Gurkenglas> I'm not too familiar with the shouldBe stuff, which of these do you mean or can you say why that doesn't work in that do block? ("Which type does the expression in line 15 have?") http://hayoo.fh-wedel.de/?query=shouldBe
20:43:27 <Jinxit> http://hspec.github.io/expectations.html
20:44:41 <Gurkenglas> If shouldBe here has type "(Show a, Eq a, MonadIO m) => a -> a -> m ()", then that line 15 should already be usable in that place
20:44:50 <Jinxit> error: http://lpaste.net/2646372605128343552
20:44:57 <Gurkenglas> (game2 would have type IO Game)
20:45:32 <Gurkenglas> Try importing the third shouldBe instead http://hayoo.fh-wedel.de/?query=shouldBe
20:46:25 <Gurkenglas> It'll use MonadIO instead of Expectation.
20:46:41 <Gurkenglas> Btw Expectation appears to be defined as IO () so you could just use liftIO there
20:47:01 <Gurkenglas> (Which would have exactly the same result as importing from the other place)
20:47:10 <Jinxit> the other shouldBe is an old hspec
20:48:01 <Gurkenglas> liftIO then I guess
20:48:33 <Gurkenglas> "liftIO $ canAttack p1 p1m `shouldBe` True"
21:02:27 <Jinxit> and now it says m0 in 'play' is ambiguous
21:03:38 <Jinxit> and "No instance for (MonadState Game IO)"
21:05:55 <johnw> Jinxit: can you show me the code that causes this error?
21:07:10 <Gurkenglas> If pasting each time takes you too long, you could just paste your whole code and refer to lines
21:07:35 <johnw> yes, that's best
21:07:42 <johnw> give me the whole enchilada
21:08:19 <Jinxit> well it's like 12 files
21:08:24 <johnw> oh
21:08:37 <johnw> maybe not then :)  is there a github repo you can link to?
21:08:48 <Jinxit> I tend to not commit unless it works
21:08:53 <Jinxit> I mean
21:08:57 <Jinxit> I got it to work now I think
21:10:39 <Jinxit> well, the IO part works, now the Zoom constraint is broken
21:10:43 <Jinxit> I'll put it on a dev branch
21:12:50 <Jinxit> Gurkenglas: johnw: https://github.com/Jinxit/firestone/tree/dev
21:13:08 <johnw> ok, which file is giving you troubles?
21:13:49 <Jinxit> test/GameSpec.hs:30
21:14:16 <johnw> and what is the type of "play game $ replicateM 4 endTurn"?
21:14:54 <johnw> or rather, what are the types of play, game and endTurn
21:15:12 <Jinxit> they are all in src/Firestone/Game.hs
21:15:37 <Jinxit> the Zoom constraint is incorrect
21:16:13 <johnw> I'm not familiar with the Zoom constraint
21:16:16 <johnw> not yet at least
21:16:17 <johnw> how does it work?
21:16:31 <Jinxit> I wish I knew :)
21:16:59 <johnw> one sec, let me read
21:18:08 <usr> w/ in44
21:18:14 <johnw> Zoom m n s t
21:18:15 <usr> 45*
21:18:29 <johnw> where m must be a MonadState s m, and n must be a MonadState t n
21:22:37 <johnw> Jinxit: does this code need to be so mtl-generic?  If you're the only user of this, and 'm' is always going to have type StateT Game IO, then why not be concrete and define type AppT = StatetT Game IO?
21:22:59 <johnw> or at least, StateT Game m, if you don't need the IO
21:23:44 <Jinxit> the Zoom constraint is still necessary
21:24:02 <Jinxit> that got added as soon as I left State
21:24:12 <johnw> sure, but then it can be: Zoom (StateT Game m) (StateT Player m) Game Player
21:25:13 <Jinxit> nope
21:25:16 <Jinxit> could not deduce
21:26:06 <johnw> well, it can't unless your monad is StateT Game m [Event]
21:26:17 <Jinxit> it is
21:26:20 <Jinxit> I changed
21:26:22 <johnw> ah
21:26:49 <johnw> maybe I have it backwards...
21:27:22 <Jinxit> switching Player and Game makes no difference
21:27:24 <Jinxit> in the constraint
21:27:30 <johnw> you switched it in both places?
21:27:57 <Jinxit> yes
21:28:02 <johnw> ok, one sec
21:28:13 <johnw> building here
21:28:20 <Jinxit> alright
21:34:40 <johnw> Jinxit: ok, fixed
21:34:48 <johnw> you have just one last problem I can't fix
21:34:58 <johnw> https://gist.github.com/00883e5d938058850779
21:35:06 <johnw> you're using liftIO in a way that can't work at the end of GameSpec.hs
21:36:53 <Jinxit> but if you switch to State, doesn't that mean you CAN'T use liftIO?
21:36:57 <Jinxit> as opposed to StateT
21:37:03 <johnw> right; but why would you want to?
21:37:04 <Jinxit> because that was the entire reason behind my switch
21:37:08 <johnw> none of your game logic needs IO
21:37:16 <johnw> don't do it for the sake of these tests
21:38:00 <Jinxit> mostly convenience, whether it be in test or use
21:38:14 <johnw> don't introduce IO for convenience, if you can at all help it
21:38:24 <johnw> having a pure game engine in State is a worthy thing
21:43:17 <wowdog> Hi, What is the easy way to generate mxn matrix? so far I have [1..3]:[2..4]:[]
21:47:17 <Jinxit> johnw: idk about you, but this looks horrible to me: http://lpaste.net/4481894056657420288
21:50:04 <Cale> wowdog: Which m by n matrix?
21:50:14 <johnw> Jinxit: write a function to abstract that
21:50:35 <johnw> build more intelligence into your tests, rather than more flexibility into your core functions for the sake of your tests
21:50:37 <Cale> wowdog: You could write  [[f i j | j <- [1..n]] | i <- [1..m]]
21:51:48 <wowdog> new to Haskelll..:)
21:54:23 <SolitaryCypher> Hey, can someone please explain why this works? "map ($ 5) [ (+4), (*3) ]"
21:54:40 <zaquest> :t ($)
21:54:42 <lambdabot> (a -> b) -> a -> b
21:54:44 <SolitaryCypher> Without the $, it fails
21:54:47 <zaquest> :t ($ 5)
21:54:48 <lambdabot> Num a => (a -> b) -> b
21:56:26 <ReinH> SolitaryCypher: does this make sense:
21:56:34 <ReinH> > ($ 5) (+ 4)
21:56:36 <lambdabot>  9
21:57:39 <SolitaryCypher> yes, I think so. 
21:57:46 <SolitaryCypher> Ok, I think I got it
21:57:55 <SolitaryCypher> :t $
21:57:57 <lambdabot>     parse error on input ‘$’
21:57:57 <lambdabot>     Perhaps you intended to use TemplateHaskell
21:58:00 <Cale> :t ($)
21:58:01 <lambdabot> (a -> b) -> a -> b
21:58:05 <SolitaryCypher> ok, yeah
21:58:07 <SolitaryCypher> cool
21:58:17 <Cale> Really, ($) is just the identity function
21:58:28 <Cale> (with a more specific type, and infix syntax)
21:58:36 <ReinH> SolitaryCypher: ($ 5) is a continuation that takes a function and applies it to 5.
21:58:43 <ggole> It might be easier if you write it map ($ 5) [(4 +), (3 *)], and imagine the expressions in the list on the left hand side of the $
21:59:12 <ReinH> (+4) = \x -> x + 4
21:59:52 <ggole> Or in short, consider the relationship between ($ 5) (4 +) and 4 + 5
22:00:34 <shachaf> ReinH: I think the function you pass ($ 5) is the continuation.
22:00:42 <ggole> (And try this with non-commutative operators too, to avoid being confused about which argument those sections are supplying.)
22:02:44 <ReinH> shachaf: Hmm. I thought that was the suspended computation. :(
22:03:13 <ReinH> I should just read the thing I already wrote about this, where I spent some time making sure I got it right
22:03:36 <ReinH> Oh yeah.
22:03:38 <ReinH> You're right.
22:03:59 <SolitaryCypher> Ok, can you link to that thing? I think I get how it works in practise, and I am getting closer to actually understanding it
22:04:34 <ReinH> SolitaryCypher: http://reinh.com/notes/posts/2014-07-16-diff-lists%2C-cont%2C-yoneda%2C-and-free-monad-optimizations.html
22:04:39 <ReinH> you only need the first few paragraphs
22:04:46 <ReinH> it's incomplete anyway
22:04:46 <shachaf> Normally you would write, say, foo :: Int -> Int; foo x = 2*x+1. foo takes a value and returns a value. But in continuation-passing style, maybe you write foo :: Int -> (Int -> r) -> r; foo x k = k (2*x+1)
22:05:06 <shachaf> When foo computes the value it was supposed to compute, the "continuation" that you pass it is what it's supposed to do next.
22:05:12 <ReinH> shachaf: yeah I get it right there phew
22:05:41 <shachaf> I don't know what a suspended computation is.
22:06:41 <ReinH> shachaf: It's the term that https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style uses for ($ 5)
22:06:50 <ReinH> It doesn't seem to be in common usage otherwise
22:07:02 <ggole> How is this CPS? It just takes a function argument.
22:07:36 <ReinH> ggole: that's what cps does
22:08:26 <SolitaryCypher> Thanks! You guys are super helpful
22:09:30 <ggole> Continuations don't return when you apply them. The function argument to ($ 5) returns when you apply it.
22:09:54 <ReinH> ggole: I think you are confused.
22:09:59 <ReinH> ggole: try https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
22:10:21 <ReinH> compare the type of Haskell's Cont to the type of flip ($)
22:10:57 <ReinH> @unmtl Cont r a
22:10:57 <lambdabot> (a -> r) -> r
22:11:09 <ReinH> :t ($ undefined)
22:11:10 <lambdabot> (a -> b) -> b
22:11:53 <ggole> This doesn't describe what I'm familiar with as continuations at all :|
22:12:16 <kadoban> Oh … that's all that Cont is?
22:12:37 <ReinH> kadoban: yeah
22:13:03 <kadoban> That sounds much less magical than expected. Been kind of scared of Cont because I heard it was confusing.
22:13:48 <ReinH> The magical thing is that flip ($) works as a fully featured cps
22:13:50 <Cale> It's more what Cont does to the resulting code and what you can do with callCC which makes it potentially confusing
22:14:17 <Cale> :t callCC
22:14:19 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
22:17:10 <ReinH> callCC is basically magic
22:17:27 <ReinH> Although I believe haskellers prefer to call it "sufficiently advanced technology".
22:17:54 <ReinH> Cale: MonadCont doesn't really elucidate though
22:18:05 <Cale> It helps a little bit
22:18:35 * hackagebot microlens-aeson 2.0.0 - Law-abiding lenses for Aeson, using microlens.  https://hackage.haskell.org/package/microlens-aeson-2.0.0 (fosskers)
22:18:52 <ReinH> Cale: compared to the type specialized to Cont and unmtl'd?
22:18:55 <Cale> I mean, you can plug in m a = (a -> r) -> r there, and it'll be perhaps easier to figure out how to implement in a mechanical way
22:19:03 <Cale> But harder to understand how to use
22:19:07 <ReinH> hmm
22:27:24 <ggole_> ReinH: read the whole thing: it doesn't discuss continuations at all, just a (rather clever) style of passing functions
22:28:15 <ReinH> ggole_: Eh? It does discuss continutations.
22:28:23 <ReinH> That's what it's about.
22:28:35 * hackagebot conduit 1.2.6.1 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.6.1 (MichaelSnoyman)
22:28:52 <ReinH> CPS *is* a rather clever style of passing functions.
22:29:17 <ReinH> that's basically what CPS stands for.
22:29:17 <bitemyapp> ggole_: you coming from Scheme?
22:29:39 <bitemyapp> ReinH: they're probably thinking of undelimited continuations, not the real thing.
22:29:55 <ReinH> Hmm, perhaps
22:30:14 <bitemyapp> ie, covalues
22:30:22 <bitemyapp> so Oleg says anyway.
22:30:26 <ReinH> heh
22:30:41 <ReinH> But covalues are values. :p
22:30:44 <bitemyapp> the important bit is that CPS/continuations-as-Haskellers-know-them are actually strictly more powerful
22:30:59 <bitemyapp> but they're bit...uh...weird lookin'
22:31:07 <bitemyapp> oh god dammit they weren't here
22:31:12 <bitemyapp> ggole_: you coming from Scheme?
22:31:23 <ReinH> heh
22:32:36 <bitemyapp> k, I give up.
22:32:49 * bitemyapp goes back to kicking a parser in the head repeatedly
22:34:07 <ggole> Goddamn, my connection today
22:34:24 <ggole> bitemyapp: (going from logs) yep, you got it
22:34:45 <bitemyapp> ggole: you aren't going to get that kind of thing in Haskell, but it doesn't matter because what we have is better.
22:34:59 <bitemyapp> ggole: you can simulate goto'ish things with Cont if you're that sadistic.
22:35:26 <bitemyapp> gone again lmao
22:35:28 <ggole> bitemyapp: is Cont like *delimited* continuations?
22:35:30 <bitemyapp> wait what
22:35:32 <ggole> No, I'm here
22:35:34 <bitemyapp> you have decoys!
22:35:38 <ggole> -_-
22:36:17 <bitemyapp> ggole: https://wiki.haskell.org/Continuation
22:36:37 <bitemyapp> fair warning, I haven't found almost any resource on Cont to be very clear.
22:37:36 <bitemyapp> 'tho Piponi wrote a nifty thing
22:37:40 <bitemyapp> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
22:38:36 * hackagebot wai-handler-webkit 3.0.0.3 - Turn WAI applications into standalone GUIs using QtWebkit.  https://hackage.haskell.org/package/wai-handler-webkit-3.0.0.3 (MichaelSnoyman)
22:38:46 <ReinH> bitemyapp: When in doubt, find the thing Piponi definitely wrote about it
22:38:50 <ReinH> whatever it is
22:39:12 <bitemyapp> yeah
22:39:15 <bitemyapp> just wish he wrote more
22:39:24 <ReinH> bitemyapp: I hope we can schedule him on a cast soon
22:39:30 <ReinH> he agreed in principle at leawt
22:39:44 <bitemyapp> ReinH: that would be nice
22:39:50 <bitemyapp> ReinH: may I make a suggestion re: the cast?
22:40:15 <ReinH> yes
22:40:22 <bitemyapp> ReinH: before doing an interview, gather basic information and have the interviews read a runsheet of basic information so you can dig in more and not flub
22:40:25 <ggole> Hmm, https://wiki.haskell.org/Library/CC-delcont goes into the relationship with the Scheme construct
22:40:33 <ReinH> bitemyapp: we do.
22:40:40 <ReinH> if it appears like we don't, we must not be doing a very good job
22:41:03 <ReinH> I will try to do better.
22:41:06 <bitemyapp> this thought was triggered by the bos interview
22:41:13 <bitemyapp> not knowing what team he managed or what his work constituted
22:41:32 <ReinH> Yeah.
22:41:33 <bitemyapp> it was a good interview and I liked it, but that moment made me cringe on your behalf
22:41:41 <bitemyapp> he probably gets that a lot too
22:41:43 <ReinH> fair enough
22:41:43 <bitemyapp> because of Marlow
22:41:53 <ReinH> it isn't exactly public knowledge though
22:42:04 <bitemyapp> How did I know what he does?
22:42:08 <bitemyapp> it's not like he talks to me
22:42:31 <ReinH> Ok
22:42:40 <bitemyapp> I think I picked it up from his Twitter or Facebook or something.
22:42:52 <bitemyapp> he mentioned managing a gaggle of OCaml programmers, the compiler work, etc.
22:43:06 <bitemyapp> in fact, I think it was in an earlier interview
22:43:12 <bitemyapp> could be wrong
22:43:36 * hackagebot wai-frontend-monadcgi 3.0.0.2 - Run CGI apps on WAI.  https://hackage.haskell.org/package/wai-frontend-monadcgi-3.0.0.2 (MichaelSnoyman)
22:44:40 <wowdog> can anyone explain what is main different between [] and ([]:_), how we use them differently?
22:45:54 <ReinH> wowdog: [] is an empty list
22:46:05 <ReinH> ([]:_) is a non-emptu list of lists, the first element of which is an empty list
22:46:22 <potatoe> wondering if anyone has used Web.JWT here before? and if so how do I assign the payload to the token?
22:46:38 <potatoe> also I saw bitemyapp's sendgrid package, any reason why you did not support sending HTML bitemyapp?
22:46:42 <ReinH> (assuming these are used as patterns, ofc)
22:47:22 <ReinH> wowdog: I have to guess that you didn't actually mean ([]:_)
22:47:47 <wowdog> I do
22:48:03 <bitemyapp> potatoe: mate
22:48:09 <bitemyapp> potatoe: the library ain't implemented
22:48:14 <bitemyapp> potatoe: there's very little there
22:48:31 <bitemyapp> potatoe: I was writing it for a contract, they stopped paying me, so I stopped writing the library.
22:48:57 <wowdog> ([]:_) does it mean the list contains  non-empty list?
22:49:04 <ReinH> wowdog: no, it means the list contains lists
22:49:12 <ReinH> and the head of that list of lists is an empty list
22:49:29 <potatoe> bitemyapp hm okay, well the current implementational library from alexlewis(?) does not support sending HTML either and has quite a bit of wrong stuff going on
22:49:33 <potatoe> maybe Ill send a PR there
22:49:36 <ReinH> it says nothing about the tail aside from the fact that it exists
22:50:08 <ReinH> (and is of the same type as the whole list, ofc)
22:50:18 <bitemyapp> potatoe: it's easy to make fewer mistakes with the library is 10% done :D
22:50:25 <bitemyapp> when the*
22:50:30 <wowdog> thx
22:50:34 <ReinH> bitemyapp: suggest you remove all the features for a bugfree libraary
22:50:41 <bitemyapp> ^^
22:50:51 <bitemyapp> rm -rf for glory and justice
22:51:02 <ReinH> bitemyapp: did you read the thing about the zero-bype program that was actually useful?
22:51:11 <ReinH> it was sold for $5 a pop, iirc
22:51:20 <ReinH> *byte
22:51:48 <ReinH> Some people emailed the author assuming that it was lying about its size
22:51:54 <ReinH> all around a pretty cool story
22:52:14 <ggole> That's a pretty steep price (counting per byte).
22:52:24 <ReinH> ggole: yes, this was an infinitely profitable program
22:52:42 <danclien> ReinH: http://peetm.com/blog/?p=55 ?
22:53:02 <ReinH> danclien: that's the one
22:53:04 <ReinH> danclien: also hi
22:53:06 <ggole> I suppose this is a matter of "$4.99 for knowing how an empty program might be useful, $0.01 for the actual file"
22:53:19 <danclien> ReinH: o/
22:53:30 <ReinH> ggole: Yeah, "$10 for turning the screw, $2990 for knowing which screw to turn" sort of thing
22:53:54 * hackagebot wai-app-static 3.1.4.1 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.4.1 (MichaelSnoyman)
22:53:56 * hackagebot wai-conduit 3.0.0.3 - conduit wrappers for WAI  https://hackage.haskell.org/package/wai-conduit-3.0.0.3 (MichaelSnoyman)
22:53:58 * hackagebot wai-extra 3.0.13.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.13.1 (MichaelSnoyman)
22:54:00 * hackagebot wai-handler-fastcgi 3.0.0.2 - Wai handler to fastcgi  https://hackage.haskell.org/package/wai-handler-fastcgi-3.0.0.2 (MichaelSnoyman)
22:54:02 * hackagebot wai-handler-launch 3.0.0.5 - Launch a web app in the default browser.  https://hackage.haskell.org/package/wai-handler-launch-3.0.0.5 (MichaelSnoyman)
22:55:00 <bitemyapp> ReinH: I need to start writing books like that
22:55:14 <ReinH> bitemyapp: srsly
22:55:20 <bitemyapp> Book of Haskell: "https://www.google.com and chill"
22:55:24 <ReinH> hahaha
22:55:26 <bitemyapp> second page
22:55:27 <bitemyapp> "gg gl hf"
22:55:46 <bitemyapp> deeeeefinitely not writing a book this long
22:55:48 <bitemyapp> ever again
22:56:00 <ReinH> bitemyapp: tbh someone should write "A compendium of GHC error messages and their meanings"
22:56:14 <bitemyapp> found a few hundred page Scalaz book that costs $50 and covers MFAM + a couple transformers
22:56:23 <bitemyapp> clearly the real money is in selling books that take a month or two to write.
22:57:01 <ReinH> bitemyapp: and calling them textbooks
22:57:04 <bitemyapp> ReinH: there's a fair bit of that in our book (we explain a lot of errors)
22:57:04 <ReinH> you apparently forgot that part
22:57:09 <bitemyapp> but actually I like that idea.
22:57:29 * bitemyapp swipes the idea and stuffs it into his hoodie, quickly walking outside
22:57:35 <ReinH> bitemyapp: btw did you see springer made all their 10+ year old books available for download?
22:57:36 <ReinH> It's amazing.
22:57:50 <ReinH> plenty of good matha and cs books, including Mac Lane
22:58:07 <ReinH> As if I didn't have enough on my reading list as it is...
22:58:11 <bitemyapp> aye, I did.
22:58:16 <ReinH> and Lang's Algebra
22:58:20 <bitemyapp> saw it when sclv pasted the link in #haskell-lens
22:58:54 * hackagebot wai-websockets 3.0.0.8 - Provide a bridge between WAI and the websockets package.  https://hackage.haskell.org/package/wai-websockets-3.0.0.8 (MichaelSnoyman)
22:59:33 <ReinH> ah
23:08:54 * hackagebot yesod-bin 1.4.17 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.17 (MichaelSnoyman)
23:25:51 <roelof>  I can use this ( http://lpaste.net/148072) to find fib numbers till a certain number. 
23:26:07 <roelof> but is it possible to make it work that the first number is printed out as  1     0  , the second one as  2    1  and so on 
23:26:48 <roelof> I cannot figure out how to put a sort of counter in for example a list comprehension or a recursion function 
23:26:59 <mniip> roelof, zip [1..] ?
23:27:10 <mniip> > zip [1..] "hello"
23:27:12 <lambdabot>  [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
23:29:01 <roelof> mniip:  sorry , but this do not work : let fibs = zip [ 1 .. ] (take 6( 0 : 1 : zipWith (+) fibs (tail fibs)))    
23:29:24 <mniip> roelof, you're using fibs in the definition of itself
23:29:38 <mniip> you shouldn't be putting take or zip in its definition
23:30:20 <roelof> oke, so I have to do this in two parts. First make the list and then take the output and do zip [ 1 .. ] on it ? 
23:30:29 <mniip> yes
23:30:49 <roelof> or is there a better way to put all the outcomes of a fib in a list ?
23:30:54 <mniip> you *could* hack it into one definition, but that would seem wrong
23:31:55 <roelof> Thanks, that seem to be working. Now I can try to print it out as a table 
23:32:59 <roelof> This schould be simple with just recursion or a list comprehension 
23:35:52 <roelof> mniip:  is this a good haskell way or can I better use the slow recursion option :   = fib ( n -1 ) + fib ( n - 2 ) 
23:36:35 <mniip> no, fibs = 0 : 1 : zipWith (+) fibs (tail fibs) is definitely good
23:40:02 <roelof> mniip:  thanks, I think I can now solve this challenge 
23:44:02 <dengjiong> hi
