00:00:00 <athan> something like a balancing tree :s
00:07:45 <edwardk> athan: ah
00:07:54 <edwardk> hard to maintain medians
00:07:59 <athan> Yeah haha
00:08:20 <athan> still interesting though
00:08:45 <athan> I'm trying to come up with a less precise solution right now
00:08:57 <edwardk> only dynamic median maintenance stuff i really know of comes from the succinct data structures world. not sure how that would dovetail very nicely into a heap when there are already better asymptotics available
00:09:22 <edwardk> are you familiar with the median of medians tricks that get used for soft medians?
00:09:28 <edwardk> and/or with chazelles soft heaps?
00:09:36 <edwardk> both are different tricks
00:09:39 <athan> not at all, but willing to dive in :)
00:09:42 <athan> hmm
00:09:43 <edwardk> but both lean somewhat in the direction you are going
00:09:53 <ReinH> I have awoken the Kmett.
00:10:00 <edwardk> https://www.cs.princeton.edu/~chazelle/pubs/sheap.pdf
00:10:25 <edwardk> soft heaps are really neat, and they arise all over the place once you start doing things in computational geometry
00:10:33 <edwardk> they at first seem completely useless.
00:10:37 <edwardk> heaps that get stuff wrong?
00:11:44 <edwardk> for the median tricks, let me see if i can find a good reference for you, iirc. demaine talks about it in terms of derandomizing quickselect i think
00:12:12 <athan> o.o thank you!!
00:13:01 <ReinH> athan: you fool, flee before it's too late
00:13:15 <edwardk> http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-6-order-statistics-median/lec6.pdf talks about the derandomization algorithm but there is a better video / summary somewhere in his class notes for advanced data structures at MIT, but i can't find it with just a
00:13:15 <edwardk> cursory search
00:14:14 <athan> :)
00:14:55 <bitemyapp> martinvlk: :)
00:14:56 <MasseR> Has anyone been able to cross-compile integer-gmp to raspberry?
00:14:57 <athan> I'll dig on it, thanks edwardk.
00:15:27 <edwardk> http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-6-order-statistics-median/ is the video of the appropriate talk
00:16:37 <martinvlk> bitemyapp: Hi, season Greetings! :-)
00:17:26 <bitemyapp> martinvlk: ever had egg nog?
00:17:33 <bitemyapp> martinvlk: seasons greetings :)
00:17:52 <athan> :D! Awesome
00:19:58 <raichoo> Uh, Erik Demaine. That's gotta be good ^^
00:20:19 <martinvlk> bitemyapp: egg nog, yeah, it's tradtional over here :-)
00:20:48 <edwardk> anyways, the only real novel dynamic structure i know of that maintains an actual ironclad accurate median that isn't stupid about it in terms of space is a wavelet tree which can be queried for arbitrary order statistics http://www.dcc.uchile.cl/~gnavarro/ps/cpm12.pdf talks about this development
00:21:16 <edwardk> in the "generic numeric sequences" section as "range quantile query"
00:21:34 <edwardk> that section right there summarizes one of the highest and best uses of a wavelet tree
00:21:57 <bitemyapp> martinvlk: ah good. Here too!
00:22:18 <edwardk> https://www.youtube.com/watch?v=uA0Z7_4J7u8 is a crash course i gave on succinct data structures in hungary at prezi a couple of years back, and i have a succinct package on github that has many of the bits and pieces you'd need.
00:23:28 <athan> >:D
00:23:40 <athan> looks like I'm not sleeping
00:23:54 <athan> thank you edwardk :)
00:24:02 <edwardk> hah
00:24:09 <edwardk> ReinH warned you to run ;)
00:24:26 <bitemyapp> edwardk: while you're here
00:24:33 * edwardk runs
00:26:00 <athan> Although I may walk in the valley of the shadow of  where I was just walking, I shall fear no asymtotic- <threadlock>
00:26:17 <edwardk> bitemyapp: shoot
00:27:36 <edwardk> athan: anyways re heaps and the like you might do better to look at what has already been done for making them fast for things like integer keys or restricted situations than to try to find something new, there isn't a lot of wiggle room in the design space between known best and worst cases
00:28:20 <edwardk> e.g. at some point i need to work out if i can get _any_ of the fast integer key heaps to work well enough to be worth my time
00:28:44 <bitemyapp> edwardk: Hutton-Meijer parsers ([]-based) have some nasty behavior. Considering skipping them in the parsers chapter in lieu of the dumbed-down Maybe variant for the "build your own parsing API" section.
00:28:59 <athan> hmm, okay I'll dig into it
00:29:02 <bitemyapp> edwardk: I am open to being convinced into a different design but it has to be pretty compact and not force a lot of other thunks. Thoughts?
00:29:19 <bitemyapp> keeping in mind prior to the "build your own parser" bit, they've been kicking around attoparsec.
00:29:25 <bitemyapp> but only superficially.
00:29:40 <edwardk> bitemyapp: backtracking all the time ([]) means you don't have any good place to blame when things go wrong. backtracking none of the time (Maybe) means you have to do everything LL(1) style
00:29:48 <edwardk> both suck ;)
00:30:30 <edwardk> also both use very different laws for MonadPlus
00:30:44 <edwardk> since one has "left" distribution and the other has "left" catch
00:30:52 <bitemyapp> edwardk: ah that's a lead-in for another question
00:31:11 <bitemyapp> What's a good example for motivating LL(k)/LL(*)?
00:31:36 <bitemyapp> Most of the things I've found are either too big, but practical; or compact and straight out of Chomsky (so very synthetic-seeming)
00:31:43 <edwardk> well, you can use a good example for LL(1) in terms of a swierstra-duponcheel style applicative parser
00:32:01 <edwardk> which keeps track of the FIRST set and branches of it
00:32:34 <edwardk> (the original writeup used arrows, but it was really an applicative construction, they just didn't have the vocabulary to notice it since applicative didn't exist and arrow was what they came up with first!)
00:32:50 <bitemyapp> arr/ap bit makes sense, but this is still just for LL(1)?
00:32:57 <edwardk> yes
00:33:05 <edwardk> it showcases the power of what you can parse with LL(1)
00:33:12 <bitemyapp> Performance doesn't matter too much for the "roll your own parsers" bit, but [] seemed like it would be egregiously misleading.
00:33:31 <edwardk> well, keep in mind that that is LL(1) in _characters_
00:33:33 <edwardk> not tokens
00:33:38 <bitemyapp> How do I draw a contrast here with the Maybe variant?
00:33:45 <edwardk> so getting to LL(k) gives you nice big tokens and the like
00:35:06 <bitemyapp> Probably worth mentioning here that this chapter is not a monograph on parsers as such, but a primer for understanding how to use parsing libraries other people made. As well as motivating doing parsing & marshalling properly to begin with.
00:36:13 <edwardk> it is hard to cover parsing at all without either lying or going deep
00:36:24 <bitemyapp> welcome to my last month.
00:36:44 <edwardk> at one extreme you are too glib and gloss over too much and burn people, at the other you go too deep and lose people
00:36:59 <bitemyapp> "gloss over too much and burn people" thus [] getting ejected.
00:37:03 <bitemyapp> it was a bridge too far.
00:37:20 <edwardk> well, [] based parsers are worth doing because e.g. Read works that way
00:37:44 <bitemyapp> they also just sorta float around various places.
00:37:45 <edwardk> but the fact that you don't have a single place to blame / give errors is something you can talk about
00:37:56 <edwardk> and you can talk about the fact that Maybe gives you one place to blame
00:38:02 <edwardk> but cant tolerate ambiguity
00:38:08 <bartavelle> TBH I had used attoparsec & parsec for month before realizing there was that readS thingie ... is that really useful ?
00:38:29 <edwardk> and swierstra duponcheel requires LL(1) and gives a more efficient dispatch getting the right asymptotics in exchange for flexibility
00:39:09 <edwardk> bartavelle: the readS stuff is pretty grossly inefficient and backtracks everywhere (but then so does attoparsec!)
00:39:32 <edwardk> but it gets used inside of the Read class
00:39:43 <edwardk> so you wind up having to learn it to write good manual Read instances anyways
00:40:05 <bartavelle> yes I know, my point is that I never wrote Read instances manually whereas I have written quite many parsers
00:40:09 <bitemyapp> I don't know if Read alone justifies covering it.
00:40:14 <bitemyapp> edwardk: S-D > Maybe here is about performance right?
00:40:15 <bartavelle> I wondered if many people did write them in the first place
00:40:41 <bitemyapp> edwardk: is there a compact example format or grammar to motivate needing ambiguity you could think of?
00:40:42 <edwardk> bitemyapp: with the monad you have to try all branches. with the applicative you can dispatch to the 'right' branch in O(1).
00:41:09 <edwardk> bitemyapp: write a parser for statements, write a parser for expressions
00:41:13 <edwardk> these are separate parsers
00:41:15 <edwardk> now write a repl
00:41:21 <edwardk> you want to reuse the two parsers you wrote before
00:41:26 <edwardk> if given an expression you want to show a value
00:41:32 <edwardk> if given a statement you want to run the statement
00:41:40 <edwardk> and add it to the environment or whatever
00:41:55 <edwardk> otherwise you have to left factor the new composite grammar
00:42:25 <edwardk> the problem is that LL(*) and LALR and GLR etc do not form an "abstract family of languages"
00:42:31 <edwardk> they aren't closed in nice ways
00:42:38 <edwardk> context free grammars are
00:43:01 <edwardk> so a parser like an earley parser or a CYK parser or a valiant parser can handle language extensions or unions of two languages
00:43:11 <edwardk> but the stuff you get from recursive descent isn't
00:44:07 <merijn> edwardk: Any good books on this stuff?
00:44:10 <edwardk> also there is another issue worth talking about, the notion of whether or not all the input is available up front
00:44:24 <edwardk> merijn: the material is scattered all over hell and back
00:44:32 <MarcelineVQ> You can say that again
00:44:38 <bitemyapp> merijn: it doesn't really cover what Ed is talking about, but
00:44:50 <bitemyapp> merijn: Grune/Jacobs is a good survey of more traditional stuff.
00:45:44 <merijn> bitemyapp: I know traditional parsing, like LALR, lex/yacc, recursive descent, etc.
00:45:45 <fr33domlover> Hello! Q: I have a list of lazy bytestrings I'd like to concat and write the result into a file. Is it needed/worth using a Builder to concat them or is B.concat (or mconcat) enough to do it efficiently?
00:45:50 <merijn> It's the fancy stuff I don't know :)
00:45:52 <bitemyapp> merijn: probably less helpful then, sorry.
00:46:09 <edwardk> i pretty much started with the lex/yacc o'reilly book and the dragon book, read all i could about parsing combinators, and then found my way into deeper waters through linguistics
00:46:17 <merijn> fr33domlover: I would assume mconcat is enough unless you have VERY specific performance problems
00:46:36 <merijn> fr33domlover: i.e. don't bother doing anything more complex unless you have PROOF mconcat is a problem through profiling
00:46:50 <edwardk> and then from trying to build parsers that could be used for monoidal recognition
00:47:05 <edwardk> so hence my obsession with visibly pushdown languages and the like
00:47:12 <bitemyapp> edwardk: is there something distinct to "union of two languages" requiring ambiguity that isn't tantamount to <|>?
00:47:39 <fr33domlover> merijn, thanks! mconcat it is then
00:48:07 <edwardk> <|> in the presence of a Maybe based parser only can deal with one active 'possible' parse.
00:48:34 <edwardk> you may need to restructure things drastically to ensure that this is the case
00:49:19 <edwardk> for a finite alphabet you can always do that, but it doesn't mean that the grammar is very naturally expressed
00:50:24 <edwardk> and things get much worse when you start taking more input online and you aren't even sure if you are down a blind alley yet
00:54:09 <edwardk> (have been thinking a bit about this issue again lately, since i was playing with a repl the other day and i've been wanting to make it so i can syntax highlight as i type)
00:55:00 <edwardk> for that i really want a resumable parser so i can feed it characters as i type, and keep track of the current highlight intervals for the stuff to the left of the cursor, etc.
00:55:27 <edwardk> as well as supply active tab-complete data for the repl based on whatever grammar you are using
00:56:02 <merijn> Good...edwardk is tackling the hard problems so I don't have to ;)
00:56:32 <edwardk> I was playing video games today rather than think about this ;)
00:57:38 <merijn> edwardk: That's what I end up doing in my free time (hah! like I have any...) too, so :p
00:58:06 <merijn> Sometimes I think I'll write code that will save the world, but then I realise that coding after coding all week sucks :p
01:02:29 <fr33domlover> one good thing about a non-tech job, is that all the code you write is what you really want, at your own pace, all free software
01:03:07 <merijn> Whoo! I love that feeling where I think I have a problem, only to realise I inadvertently solved/avoided it weeks ago...
01:04:20 <tdammers> fr33domlover: the bad thing is that you might not get to write any code at all
01:07:09 <fr33domlover> tdammers, true. But on the other hand, at least in my area tech jobs tend to be very demanding (many work hours). In my job I happen to have night shifts sometimes in which I have a few hours to code, and I suppose I'm generally not ver busy so I have time at home too :P
01:07:30 <tdammers> fr33domlover: sounds perfect
01:07:35 <fr33domlover> But I can't judge, I don't have children etc.
01:07:53 <fr33domlover> I imagine parents have much less time for these things, if any :P
01:08:02 <tdammers> also, I think expecting programmers to be productive for more than 4, maybe 6 hours per day, is a recipe for disaster
01:08:09 <merijn> I don't have time for that even without kids :p
01:08:26 <fr33domlover> merijn, what do you fill your time with?
01:08:30 <fr33domlover> just curious :)
01:08:59 <tdammers> I have kids, I run, and I have too many other interests, and I still get some side project coding done occasionally
01:09:01 <cocreature> merijn is busy answering questions in #haskell
01:09:02 <tdammers> it's doable
01:09:03 <merijn> fr33domlover: Work ~8 hours a day, go to the gym, cook, clean the house, etc.
01:09:14 <merijn> cocreature: That's usually me procrasinating during work :p
01:09:28 <cocreature> merijn: heh, I thought so :)
01:11:06 <fr33domlover> merijn, I work between 6 and 10 hours a day, 5 days a week usually, somehow I have plenty of free time left even when considering home tasks like cleaning and cooking :-P I don't go to the gym but I walk to/from job by foot, 45 minutes each direction...
01:11:13 <fr33domlover> :P
01:11:59 <fr33domlover> Just make sure you code what you love, and love what you code :-P
01:12:27 <merijn> fr33domlover: Gym/martial arts/dancing/etc. means I'm not home before 10 in the evening most weekdays, I'm not gonna manage any coding that late :p
01:13:34 <fr33domlover> merijn, also, if you code all day, it's probably not as appealing as it were if you didn't code all day :P
01:13:47 <fr33domlover> for me, when I don't code I feel something is missing
01:13:49 <tdammers> I work 4 days, run 4x per week, bike commute, which leaves 4 evenings per week for other stuff
01:13:51 <fr33domlover> I need that challenfe
01:13:53 <fr33domlover> for the mind
01:14:05 <fr33domlover> and nothing else in my life provides that challenge
01:14:54 <merijn> I should do some running/cardio...
01:15:21 <merijn> But I always get bored... and I guess this is more for -blah :p
01:15:56 <fr33domlover> merijn, solve coding problems while running?
01:16:00 <fr33domlover> I do that sometimes
01:16:07 <fr33domlover> Then I come home and start writing the code
01:16:30 <fr33domlover> (i mean, i do that while fast-walking, but same idea)
01:16:40 <arw> as long as you bill your running time, everything is fine :)
01:17:41 <tdammers> sometimes, when I need to work on a hard problem, I'll telecommute rather than come into the office, extend the lunch break into a 90-minute think/run session, and eat while working
01:18:02 <tdammers> it's a bit of a gamble, but quite often those end up being some of my most productive days
01:18:46 <tdammers> 3 hours of research, setup, grind work, head scratching and explorative coding, then 90 minutes of intense meditation, and then 3 hours implementing the proper solution
01:20:15 <merijn> My most productive day was going swimming (like every morning at that time) and deciding to go into the sauna and lie in the sun for 1.5 hours instead of getting to work on time :p
01:27:09 <fr33domlover> merijn, sounds great to me!
01:33:49 <wedens> how can I handle >10 columns tables in postgresql-simple?
01:35:40 <bergmark> wedens: are you asking because FromRow/ToRow only have instances up to 10-tuples?
01:37:02 <phadej> wedens: if it's so, you should consider using your own record type
01:37:26 <wedens> bergmark: I'd like to know if there is a way other than writing instances for >10 tuples
01:37:42 <wedens> probably TH or Generic
01:37:49 <wedens> for derivation
01:42:23 <raichoo> Hm, any idea why I can't catch this exception?  (read <$> getLine) `catch` \(e :: SomeException) -> return 1
01:42:51 <raichoo> (error "foo") `catch` \(e :: SomeException) -> return 1 works just fine
01:42:59 <merijn> raichoo: Because you're not forcing the read 
01:43:06 <raichoo> duh
01:43:06 <cocreature> wedens: you could probably also make one instance for a heterogenous list and then you can handle arbitrary row widths
01:43:38 <wedens> cocreature: yeah, that's what I was thinking about
01:43:41 <merijn> raichoo: read is lazy so catch is returning a think for "read <$> getLine", and then when you finally evaluate it, the exception gets raised. But by that time you've returned from "catch" already
01:44:19 <merijn> raichoo: You cannot reliably catch partial functions/error. This is why you should use throwIO instead of throw, since that forces the throw to happen *before* you get returned from escape
01:44:36 <merijn> raichoo: The more concrete solution to your *actual* problem is to use:
01:44:41 <merijn> :t Text.Read.readMaybe
01:44:42 <lambdabot> Read a => String -> Maybe a
01:45:06 <raichoo> merijn: Thanks, that's was really helpful ^^.
01:50:45 <ocramz> good morning all
01:51:27 <phadej> ocramz: well, it's already noon here! :)
01:52:02 <ocramz> oh dear; I'm on CET, where do you type from?
01:56:39 * hackagebot http-client 0.4.26 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.26 (MichaelSnoyman)
02:26:40 * hackagebot som 9.0 - Self-Organising Maps.  https://hackage.haskell.org/package/som-9.0 (AmyDeBuitleir)
03:05:36 <duairc> Does anybody know if there's a typeclass somewhere in the Haskell ecosystem that has a method with the following signature: (forall a. m a -> n a) -> t m a -> t n a? I know about MFunctor, but it has the constraint Monad m, which I don't want, because I want the t variable to be kind-polymorphic ((k -> *) -> j -> *)
03:12:05 <ggole> duairc: hoogle it?
03:12:40 <ggole> Also, the a doesn't seem to be properly scoped there
03:13:19 * hackagebot http-client 0.4.26 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.26 (MichaelSnoyman)
03:13:19 * hackagebot som 9.0 - Self-Organising Maps.  https://hackage.haskell.org/package/som-9.0 (AmyDeBuitleir)
03:13:26 <Yuras> duairc: http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html#v:hoist
03:14:21 <Yuras> oh, you already know it...
03:18:32 <jle`> duairc: hm, i'm not sure i would bet on it.  it's hard for me to imagine what laws such a typeclass might have
03:28:36 * hackagebot persistent 2.2.4 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.2.4 (MichaelSnoyman)
03:33:24 <duairc> jle`: Surely it would obey the same laws as hoist itself?
03:33:38 <fr33domlover> Q: I'd like to runhaskell a program, whose dependencies are installed in a cabal sandbox - can I tell runhaskell to look for them there?
03:34:04 <jle`> duairc: hoist laws are laws with behavior w.r.t. Monad
03:34:15 <duairc> What started me out looking for such a method was rmap from vinyl: https://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Core.html#v:rmap
03:34:23 <jle`> fr33domlover: you can use cabal exec runhaskell :)
03:34:49 <duairc> jle`: hoist itself's laws are just about how it behaves with respect to (.) and id
03:35:04 <duairc> The monad stuff is with respect to the morphism that gets passed to hoist
03:36:09 <jle`> yeah, but the thing that gets passed has to follow the laws :o
03:36:14 <frerich> "A record is parameterized by a universe u, an interpretation f and a list of rows rs. The labels or indices of the record are given by inhabitants of the kind u; the type of values at any label r :: u is given by its interpretation f r :: *." <-- if that's the definition of a record, I'd love to hear what a mixtape is.
03:36:40 * frerich shakes his fist and mumbles something about nerds
03:37:50 <jle`> duairc: oh, how about http://hackage.haskell.org/package/type-combinators-0.2.0.0/docs/Type-Class-Higher.html#t:Functor1
03:38:00 <fr33domlover> jle`, thanks
03:38:24 <jle`> didn't actually recognize what you were saying, but i know now that i do stuff like that often, heh.  was thrown off a bit by the poly kindedness of `a`
03:38:43 <jle`> duairc: but map1 from type-combinators seems to fit that
03:39:15 <lpaste_> hackal pasted “No title” at http://lpaste.net/147061
03:40:57 <hackal> Hello, I would like to ask how could I rewrite the function http://lpaste.net/147061 in recursive way? I am not sure how could I access the pairs in recursion
03:43:17 <duairc> jle`: Ah, cool, thanks! That package actually also has a type isomorphic to Vinyl's Rec type: https://hackage.haskell.org/package/type-combinators-0.2.0.0/docs/Data-Type-Product.html#t:Prod
03:43:44 <lpaste_> hackal annotated “No title” with “No title (annotation)” at http://lpaste.net/147061#a147062
03:43:47 <jle`> duairc: yeah, i use Prod often :)
03:44:07 <jle`> the package has a lot of similar types that all function together nicely...and they're application-agnostic
03:44:15 <frerich> hackal: I suspect that in the recursive case, you don't actually need a list comprehension. You only need to check whether the head of the list divides the second element of the list (and then call 'f' recursively for the tail of the list)
03:44:17 <jle`> so i've started using it for most of my type level shenanigans
03:44:28 <jle`> instead of essentially re-writing them from scratch for every product
03:44:48 <hackal> frerich: I appended the paste. I think I got it right.
03:45:16 <frerich> hackal: Did you write that yourself, or did you get it from somewhere? :-)
03:45:27 <duairc> jle`: Yeah, this is great, this seems to be what I was looking for. Thanks!
03:45:33 <jle`> np!
03:45:52 <jle`> the interesting things are actually things like Traversable1 and Foldable1
03:45:58 <frerich> hackal: As somebody who reviewed exercise answers at some point, it seems surprising to see that somebody jumps from 'x | (length x) == 1 = True' to '[_] = True'
03:46:23 <hackal> frerich: I wrote it myself
03:46:41 <frerich> hackal: I'm not sure your 'g' definition is correct though. Shouldn't the recursive call only skip one element at a time, not two?
03:46:59 <frerich> hackal: I.e. for '[a,b,c]' you want to see if a divides b and b divides c?
03:47:22 <hackal> frerich: yes that is what I want
03:47:46 <hackal> frerich: looks like recursion is skipping elements
03:50:19 <lpaste_> hackal annotated “No title” with “No title (annotation) (annotation)” at http://lpaste.net/147061#a147063
03:50:48 <hackal> frerich: how could I change the "f" function to use [_] = True?
03:51:43 <hackal> nvm thanks for help
03:52:02 <frerich> hackal: For what it's worth, you can write this all quite concisely using a list comprehension, too. The 'tails' function comes in handy here.
03:54:19 <frerich> hackal: As a start, consider the function '\xs -> [(x,y) | x:y:_ <- tails xs]'
03:55:59 <hackal> thank you for suggestion, I will try. However I am not sure if we can use 'tails' function. Looks like it is not in 'import Data.Char'
03:56:58 <frerich> hackal: Right - it's in Data.List
03:57:37 <quicksilver> jle`: interesting. What kind of `f` would you typically use in Prod f?
03:57:45 <hackal> Yes, I am revising for exam. And the file we get has already defined imports and I am not sure if we can add our own imports
03:59:00 <jle`> quicksilver: recently i've used Proxy, to give me a sort of type-level list
03:59:22 <jle`> but i also have very specific ones from types in my projects
04:02:35 <debenoprma> hey
04:03:34 <ollef> acertain: `optional a` only gives you `Nothing` for the empty input string using Earley. This is because `pure x` doesn't consume any input and, assuming you're using `fullParses`, will fail if you try to give it some. (Sorry for the late reply)
04:05:56 <ollef> acertain: if `a` is nullable you will get both `Nothing` and `Just something` for the empty input string.
04:18:59 <R__> a
04:20:01 <julianleviston> So, I have a question… I have a few types I’d like to represent as a single type (to have its data used in a templating system of my own construction)… but there types are not homogenous at all… but I’d like to be able to travers back and forth between their “native” versions and the “generalised” versions. Any pointers or libraries or things I should know about or hints?
04:20:11 <julianleviston> Oh… was that message too long?
04:20:50 <liste> julianleviston a sum type?
04:20:51 <julianleviston> It ended with “hints?”. 
04:21:02 <liste> the message came thru fine
04:21:02 <MarceColl> I see it all
04:21:08 <julianleviston> sweet.
04:21:19 <julianleviston> Well the various types are already product and sum types...
04:21:49 <julianleviston> liste: here’s one of them: data Design = Design SchemaBlockID String DesignType TemplateID DesignArgsMap
04:21:57 <liste> you can still wrap them in another sum type (:
04:22:01 <julianleviston> DesignType is a sum type of 6 items
04:22:07 <liste> a product type*
04:22:23 <liste> oh, I see
04:22:34 <liste> Design is a product type and DesignType is a sum type?
04:23:00 <julianleviston> DesignArgsMap is a map of anothe sum type
04:23:05 <julianleviston> yeah
04:23:35 <liste> what do the templates do with that data?
04:23:37 <liste> render it?
04:23:47 <julianleviston> I’d like their data to be represented homogenously so that I can deal with it in the templating system, and then pull it back out afterwards
04:24:50 <julianleviston> yeah, they render it, but have to be able to understand the general semantics (ie the shape of the data… ie this is a list, that is an item of a sum type).
04:25:32 <julianleviston> I could generalise all primary data types to String (or ByteString), and all structural types to Map and List, I think...
04:25:42 <fizruk> use a class?
04:25:46 <liste> maybe data Renderable = Renderable { getChildren :: [Renderable]; getText :: Text } ?
04:25:46 <julianleviston> and then include some “type information
04:25:58 <liste> and toRenderable :: Design -> Renderable
04:26:11 <julianleviston> fizruk:  Oh my god. That’s a brilliant idea.
04:26:12 <liste> or something like that
04:26:30 <fizruk> julianleviston: like what liste proposed only Renderable being a type class
04:26:37 <julianleviston> liste: I don’t quite follow - would that let me build a tree? yeah, pretty much.
04:26:52 <julianleviston> fizruk: and then instanciate it on all the types I want?
04:27:09 <fizruk> yes, all the types you want to render
04:27:17 <julianleviston> I’ve never had cause to build a class for myself yet, so I didn’t recognise it being a use-case for one.
04:27:20 <julianleviston> On that’s so beautiful.
04:28:21 <julianleviston> Thanks guys. I’ll ponder this further. :) Great help!
04:29:21 <liste> julianleviston I mean that define a type for renderable objects, and functions that convert your objects to Renderables
04:29:54 <liste> if you need to do IO while rendering, you can even have something like "data Renderable = Renderable { render :: IO Text }"
04:30:31 <liste> if you go with the class-based approach, I think you'll bump into this at some point: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
04:31:04 <julianleviston> liste: oh… I was thinking I could just let the templating engine deal with the generlised case rather than use Renderable, it could just be Renderable => a or something?
04:31:50 <julianleviston> then each instance could define render itself, too.
04:31:53 <julianleviston> but I dunno.
04:31:53 <fizruk> liste: class-based approach does not lead to existential anti-pattern per se, it's just that one can use it wrong
04:32:18 <fizruk> liste: e.g. I don't know many people having trouble with rendering JSON
04:33:14 <liste> julianleviston Renderable already is generalized, it's like a Java interface or C++ abstract class
04:33:56 <julianleviston> liste: oh… so use Renderable as the type, and then convert the other types to it? Ok.
04:34:52 <julianleviston> liste: tho I’m not sure how that helps me preseve map like structure?
04:35:00 <liste> fizruk yeah, ToJSON certainly works.
04:35:02 <julianleviston> The Renderable type.
04:35:56 <liste> design the type so that the templating engine can access the structure
04:36:09 <julianleviston> Hm… maybe I should just use the Aeson instances I already have… I wonder if I could leverage that somehow…
04:36:10 <liste> like have a hasChild :: String -> Bool
04:36:34 <julianleviston> liste: I don’t follow, really.
04:37:30 <fizruk> julianleviston: we can probably help you more if you tell us more about the domain, e.g. what is it that you are rendering?
04:37:44 <julianleviston> fizruk: Oh, sorry I thought I did.
04:38:04 <julianleviston> fizruk: It’s about 5 or 6 different types. Each one is quite different to the next.
04:38:08 <fizruk> (maybe you did, I could've missed it)
04:38:30 <julianleviston> fizruk: ah ok
04:38:30 <liste> julianleviston maybe start with something like "data Renderable = LeafRenderable Text | ListRenderable [Renderable] | MapRenderable (String -> [Renderable])" ?
04:39:25 <fizruk> julianleviston: that is the Design data type, right? is that the input or output of "rendering"?
04:39:42 <julianleviston> liste: that’s similar to how I’d envisaged. I’m not sure what MapRenderable does, tho… it seems to be a function rather than a Map ?
04:40:23 <julianleviston> fizruk: Maybe Render is a bad name. It’s more “GeneralisedDesignType”, because it’s to generalise all of the data types I have into one single type that I can pass to a bunch of Templates.
04:40:31 <RaceCondition> is it possible to access the WebKit API (1 or 2) from Haskell without relying on WebKitGTK/webkitgtk3?
04:41:00 <quicksilver> fizruk, liste: but JSON people are never tempted to write a SomeJSON type; they would just use Value or Text in that case.
04:41:19 <julianleviston> fizruk: wouldn’t I want MapRenderable to be MapRenderable (Map String Renderable) ?
04:41:25 <quicksilver> (so it doesn't fall into the existential trap)
04:41:58 <julianleviston> quicksilver: it smells a little like I’m re-implementing ToJSON and FromJSON, doesn’t it?
04:42:06 <fizruk> quicksilver: right, that's what I meant by class-based approach not necessarily leading to existential anti-pattern :)
04:42:12 <liste> julianleviston what do you need about the map? do you need to just access the elements?
04:42:25 <liste> if you just need to acccess the elements, then a function is enough
04:42:27 <julianleviston> liste: is an element a KV pair?
04:42:31 <kritzcreek> How can I hide a module inside a package with stack? I'm trying to use the purescript library with monad-logger but purescript defines its own Control.Monad.Logger
04:42:47 <liste> julianleviston yes
04:42:53 <mrt2> yone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
04:43:29 <julianleviston> fizruk: well I suppose so. I just don’t understand how a function would work for that case…
04:44:28 <liste> julianleviston function can look up a value based on a key, can't it?
04:44:57 <julianleviston> liste: I don’t know how, sorry if I’m being dense.
04:45:28 <julianleviston> liste: do you mean with a…. oh I can’t remember what it’s called… um… accumulating function store (sorry, not the right words)?
04:45:34 <fizruk> julianleviston: ok, iiuc you have a handful of data types you want to be able to pass to some Templates in a generic way
04:46:30 <julianleviston> fizruk: yeah, but general-shape structure preserving. I think a map would do fine there. Seems like that’d work. I kind of didn’t understand the warning about existential types - still reading thru the article.
04:47:56 <fizruk> julianleviston: what does "general-shape structure preserving" mean specifically for your case?
04:48:35 <julianleviston> fizruk: It means I’d like to keep lists and maps and tree structure so that I can use them to inform the template of how to behave.
04:49:31 <liste> > let personInfo "name" = Just "John Doe"; personInfo "age" = Just "26" in personInfo "age" -- julianleviston
04:49:33 <lambdabot>  Just "26"
04:49:33 <julianleviston> fizruk: simple example: a sum type would end up as a list (with a type tag) that would mean I could show each element separately (say, for editing), and then reconstruct the sum type at the other end by using Read or somesuch.
04:49:40 <fizruk> julianleviston: ok, so Template receives either a list or a map? trees are recursive maps or a distinct kind of shape?
04:51:06 <fizruk> julianleviston: a sum type like Either or Bool (or both)?
04:51:17 <julianleviston> fizruk: no, my own sum types.
04:51:43 <julianleviston> fizruk: yeah, trees can be recursive maps… I think I actually have them that shape in my types anyway.
04:52:07 <julianleviston> fizruk: sorry, I meant product type above!
04:52:20 <fizruk> julianleviston: ok, so Template only cares whether something it gets as an input is a list or a map?
04:52:51 <fizruk> julianleviston: does it accept any primitive values?
04:53:01 <julianleviston> fizruk: Well, it may eventually care more about the types but for now I’m going to use text for all primitives. I can easily adjust later if required.
04:53:15 <julianleviston> I think I have enough to go on.
04:54:39 <fizruk> julianleviston: ok, I just want to encourage you to ask these simple questions to yourself, it should help a lot with program design :)
04:55:11 <julianleviston> fizruk: oh… haha. :) I’m pretty capable of asking these questions myself. :) Thanks. :)
04:55:23 <julianleviston> fizruk: I was just telling you because I thought you wanted to know :) sorry!
04:55:50 <fizruk> :)
04:56:28 <julianleviston> I guess the typeclass for the types will just let me write a single function that I can pass any of the values of any of those types into to provide me with my “generalised data type”. Sweet :)
04:58:06 <julianleviston> and the caution against using typeclasses is that people tend to reach for them too quickly?
05:00:27 <liste> julianleviston the caution is that typeclasses are not types
05:00:58 <liste> so if Renderable is a typeclass, you can't for example have a list of Renderables
05:01:00 <julianleviston> Oh. Right. Yeah, I *think* I knew that… they just let you generalise certain functions, right?
05:01:12 <julianleviston> yeah, I knew that.
05:01:34 <julianleviston> liste: cool! thanks :)
05:02:11 <julianleviston> liste: Do people program as if they were sometimes because they get confuseda bout differences between Haskell typeclasses and OOP classes?
05:02:34 <tdammers> beginners are sometimes confused
05:02:38 <liste> julianleviston that could be one of the reasons
05:02:50 <tdammers> but really, typeclasses and OOP classes don't even have a lot in common in the first place
05:03:05 <liste> typeclasses are closer to method overloading that OOP classes
05:03:06 <julianleviston> tdammers: exactly.
05:03:50 <tdammers> an OOP class is a class of objects (i.e., a type, roughly); a typeclass is a class of *types*
05:04:42 <tdammers> the closest thing to a typeclass that I know of in any classic OOP language would be the implicit constraints you get in a C++ template
05:04:44 <julianleviston> tdammers: yep. 
05:05:05 <julianleviston> tdammers: ducktyping is kind of similar.
05:05:33 <tdammers> except that it's runtime, and implicit, and considerably dumber
05:05:35 <julianleviston> tdammers: but that’s dynamic. 
05:05:41 <julianleviston> tdammers: yep. :)
05:05:44 <tdammers> (jesus.save and file.save are considered the same)
05:06:28 <tdammers> so I don't think comparing dynamic language features with typeclasses adds to enlightenment
05:06:30 <julianleviston> tdammers: yeah silly comparison.
05:06:36 <julianleviston> tdammers: this is true :)
05:07:08 <tdammers> https://pbs.twimg.com/media/B3Fvg-sCYAAkLSV.jpg
05:07:12 <liste> jesus.save: TypeError: save() takes exactly 1 argument (0 given)
05:07:42 <tdammers> except in Python, where it would say "save() takes exactly 2 arguments (1 given)"
05:07:43 <bollu> =can someone explain to me how to use guard?
05:07:50 <julianleviston> tdammers: LOL
05:07:54 <bollu> like, an example with guard being use
05:08:08 <julianleviston> bollu: in a do block?
05:08:32 <bollu> julianleviston:yes :)
05:08:34 <liste> bollu the guard function, or the | guards?
05:08:43 <julianleviston> liste: the function he means
05:09:10 <julianleviston> bollu: this has a pretty good explanation? no? https://en.wikibooks.org/wiki/Haskell/MonadPlus#guard
05:09:34 <liste> > guard (>0) [1,2,3,4,-1,-2,-3,-4,-5]
05:09:36 <lambdabot>      Couldn't match expected type ‘Bool’
05:09:36 <lambdabot>                  with actual type ‘Integer -> Bool’
05:09:36 <lambdabot>      In the first argument of ‘guard’, namely ‘(> 0)’
05:09:37 <merijn> tdammers: You forgot about structural subtyping
05:09:43 <julianleviston> bollu: does pythagorean triples using first list comprehension, then a do block.
05:09:46 <merijn> tdammers: Which is basically "statically checked ducktyping"
05:09:59 <aweinstock> :t guard
05:10:01 <lambdabot> Alternative f => Bool -> f ()
05:10:08 <julianleviston> merijn: what was that about HATS again??
05:10:21 <bollu> julianleviston: it's easy with a list comprehension
05:10:23 <aweinstock> :t mapM (guard . (>0))
05:10:24 <merijn> "guard b = if b then pure () else empty"
05:10:24 <lambdabot> (Monad m, Num a, Ord a, Traversable t, Alternative m) => t a -> m (t ())
05:10:37 <merijn> julianleviston: HATS?
05:10:42 <julianleviston> bollu: yeah, then look below… takes a predicate, which is used to filter the monad… (so to speak)
05:10:43 <bollu> merijn: exactly, so I don't see how to actually "guards" at all
05:10:50 <merijn> bollu: By returning empty
05:11:08 <julianleviston> merijn: https://www.youtube.com/watch?v=O2QJvc_SxFQ
05:11:09 <aweinstock> :t mapM (\x -> guard (x > 0) >> x)
05:11:10 <lambdabot> (Monad m, Num (m b), Ord (m b), Traversable t, Alternative m) => t (m b) -> m (t b)
05:11:12 <bollu> merijn: oh, is it because Nothing, Error e, [], ... act as "sinks" that it "guards" ?
05:11:19 <bollu> Left e*
05:11:19 <merijn> bollu: Yes
05:11:30 <aweinstock> :t mapM (\x -> guard (x > 0) >> x) [1,2,3,4,-1,-2,-3,-4,-5]
05:11:32 <lambdabot> (Monad m, Num (m b), Ord (m b), Alternative m) => m [b]
05:11:34 <bollu> merijn:ah, and the semantics of Alternative requires them to be sinks?
05:11:34 <julianleviston> bollu:  mzero… 
05:11:46 <merijn> bollu: The actualy effect depends on the effect of "empty" on >>=
05:11:47 <aweinstock> :t mapM (\x -> guard (x > 0) >> return x) [1,2,3,4,-1,-2,-3,-4,-5]
05:11:49 <lambdabot> (Monad m, Num b, Ord b, Alternative m) => m [b]
05:11:51 <bollu> julianleviston: right. It hand't clicked until now :)
05:11:57 <julianleviston> bollu: :)
05:12:00 <aweinstock> > mapM (\x -> guard (x > 0) >> return x) [1,2,3,4,-1,-2,-3,-4,-5]
05:12:01 <lambdabot>      No instance for (Show (m0 [b0]))
05:12:01 <lambdabot>        arising from a use of ‘show_M135465809826732745419326’
05:12:01 <lambdabot>      The type variables ‘m0’, ‘b0’ are ambiguous
05:12:09 <aweinstock> > mapM (\x -> guard (x > 0) >> return x) [1,2,3,4,-1,-2,-3,-4,-5] :: [[Int]]
05:12:11 <lambdabot>  []
05:12:27 <merijn> bollu: "guard b; stuff" translates to "guard b >>= \_ -> stuff"
05:12:41 <merijn> bollu: So if "guard b" = Nothing you get the Nothing behaviour of >>=
05:12:41 <aweinstock> liste: what were you trying to do?
05:12:56 <bollu> merijn:yeah, the guard <-> empty relationship wasn't in my head. Makes sense now
05:13:42 <aweinstock> :t empty
05:13:43 <lambdabot> Alternative f => f a
05:13:48 * hackagebot Hoed 0.3.3 - Lightweight algorithmic debugging.  https://hackage.haskell.org/package/Hoed-0.3.3 (faddegon)
05:13:57 <aweinstock> > empty :: [Int]
05:13:59 <lambdabot>  []
05:14:07 <bollu> > empty :: Maybe Int
05:14:09 <lambdabot>  Nothing
05:14:15 <bollu> > empty :: Either String String
05:14:17 <lambdabot>  Left ""
05:14:20 <bollu> nice
05:14:32 <bollu> wait, alternative for Either needs Monad on the Left type right?
05:14:45 <aweinstock> > empty :: (Either (Either (Either String Int) Int) Int)
05:14:46 <lambdabot>      No instance for (Control.Monad.Trans.Error.Error
05:14:47 <lambdabot>                         (Either (Either String Int) Int))
05:14:47 <lambdabot>        arising from a use of ‘empty’
05:14:47 <merijn> Monoid, on left, yes
05:14:58 <bollu> merijn: ouch, typo, sorry
05:15:17 <merijn> bollu: Because else you have no sensible value :)
05:15:26 <bollu> merijn: yeah that was what I was thinking :)
05:15:40 <bollu> merijn:are there any "unexpected" Alternatives?
05:15:48 <bollu> merijn:like, cool examples
05:16:31 <merijn> Not that I can think of atm, Parsers are the most useful one that spring to mind
05:16:59 <bollu> merijn:oh hm, yeah
05:17:11 <quicksilver> STM?
05:18:31 <merijn> Not unexpected, imo, but a cool one, yes
05:18:39 <merijn> With "empty = retry"
05:24:59 <liste> aweinstock what you did (:
05:47:48 <saulzar> Hi people, I'm having some trouble with what I think is a non injectivity issue with type families - made a minimal example  http://lpaste.net/147067   .. anyone have any insight on what the deal is there? It seems really simple...
05:50:09 <merijn> saulzar: Oh, no this has nothing to do with type families
05:50:30 <merijn> saulzar: This is an inference issue
05:51:55 <merijn> saulzar: "HostFrame Spider ()" evaluates to "IO ()", which lets GHC see that your use of "runPushM :: ??? -> IO ()", but it has no way to deconstruct the type family so it can see which instance this is from (since presumably many instances could have "HostFrame ? ()" evaluate to "IO ()"
05:52:51 <saulzar> Ah.. hmm
05:53:31 <saulzar> So I'm effectively annotating my function dummy :: IO ()
05:55:03 <merijn> saulzar: Yeah. It might work if you add "return () :: PushM Spider ()", but I'm not even sure that works
05:55:37 <saulzar> Seem to run into this all the time with type families.  Nah - I've tried annotating all the parts and it still won't pass
05:56:01 <merijn> FYI, the example code doesn't need MultiParamTypeClasses and EmptyDataDecls is Haskell2010 and thus redundant too :)
05:56:35 <merijn> saulzar: The common way to deal with this would be "runPushM :: proxy t -> PushM t a -> HostFrame t a"
05:56:49 <merijn> The proxy value would then serve to force the instance selection
05:57:17 <saulzar> Ahh. Yes that'd do the trick. Since 't' is just a tag anyway ..
05:58:05 <merijn> (lowercase proxy so you can use any functor-like thing as proxy value instead of being stuck always using Proxy)
05:58:06 <saulzar> merijn, Thanks! 
05:59:23 <merijn> saulzar: Although the code you pasted having two classes seems useless, since you can never have more than 1 pair for a specific t? :)
06:00:57 <saulzar> merijn, In the case of the reflex library (where this is from) the ReflexHost class implements a bunch of IO-ish operations and the Reflex class is more general  
06:01:41 <saulzar> merijn, So I guess potentially you can have a Reflex instance without a ReflexHost instance, for example the model used for testing doesn't
06:07:46 <saulzar> merijn, I'd be very happy to get rid of all the typeclasses - though the only way I know is to use CPP and #include :)
06:17:42 <zipper> Hello, I'm writing a bot. In it. I want it to find the first Saturday of the next month and give one a notification. The problem is that the time library doesn't seem to recognize days in that way. As in in terms of Monday, Tuesday ... What can I use as the alternative?
06:18:20 <MasseR> zipper: IIRC it can give you the week day number
06:18:23 <MasseR> From 0 to 6
06:22:00 <zipper> MasseR: Oh I see
06:37:39 <AwesomeHaircut> Does any one use arch linux here?
06:38:37 <Jinxit> yep
06:39:12 <AwesomeHaircut> I was updating ghc and it gave me an error that some files were already installed
06:39:53 <AwesomeHaircut> I uninstalled it and it used force install. Is that fine??
06:48:34 <hexagoxel> (ah, ghc-7.10.3 is in the arch repos. neat.)
06:52:15 <maerwald> is there some trickery to modify a state from within a callback (gtk+ bindings) that has type "bar -> baz -> IO ()"? I can only think of IORef, but I don't like that idea
06:53:12 <fractalsea> Is there a way you can have haskell values live on the stack instead of the heap?
06:53:13 <quicksilver> IORef in one form or another, maerwald 
06:53:27 <quicksilver> fractalsea: GHC doesn't really have a stack for them to live on
06:53:34 <quicksilver> fractalsea: what would you expect the advantage to be?
06:53:58 <fractalsea> quicksilver, thanks. I was hoping for improved performance
06:54:07 <quicksilver> can't imagine why
06:54:21 <quicksilver> GHC heap allocation is as simple as incrementing a pointer
06:54:28 <quicksilver> can't get much faster than that.
06:54:39 <fractalsea> quicksilver, well in C it is faster using stack variables
06:54:49 <fractalsea> quicksilver, I wasn’t sure for haskell
06:54:53 <quicksilver> yes, but that's a different language with a different memory model :)
06:55:14 <merijn> In C heap allocation is expensive
06:55:19 <fractalsea> quicksilver, true
06:55:21 <merijn> In haskell heap allocation is CHEAP
06:55:33 <maerwald> quicksilver: maybe rather MVar?
06:55:36 <fractalsea> Good to know
06:55:50 <fractalsea> Thanks
06:55:56 <merijn> fractalsea: It's not unusual for some GHC code to have allocation rates measured in Gb/s
06:55:59 <quicksilver> maerwald: maybe. If you are using multiple threads. But state monads are not naturally multi-threaded.
06:56:41 <maerwald> quicksilver: I want to have a state outside of the gui and the gui be able to query it. so I could very well do those in separate threads
06:57:27 <fractalsea> merjin, What is the speed like for allocating with mallocPlainForeignPtrAlignedBytes and writing with Data.Storable poke and peak?
06:57:48 <maerwald> but I'm not sure what that buys me compared to IORef
06:57:59 <merijn> fractalsea: mallocPplainForeign just calls out to malloc, so similar to C, poke/peak is similar to writing bytes in C
06:58:22 <quicksilver> maerwald: my point is that if you were, previous to thinking about GTK, working witha  state monad, then you weren't using threads
06:58:32 <quicksilver> maerwald: because that's not how simple state monads work
06:58:34 <maerwald> I don't use state monad currently
06:58:39 <quicksilver> ah 
06:58:44 <quicksilver> then I misunderstood you :)
06:59:01 <quicksilver> that's what I thought you meant by "modify a state from within a callback"
06:59:08 <maerwald> I've never found the state monad very useful for anything I have done so far, always solved the problems differently
06:59:17 <quicksilver> if you plan to use multiple threads then sure, MVar or TVar
06:59:36 <quicksilver> the state monad is only a convenient way of threading parameters and return values
06:59:38 <merijn> Preferably TVar
06:59:42 <quicksilver> it's easy to do it manually
07:00:00 <maerwald> I know the state monad, but as soon as I want to use it, I see easier ways
07:01:17 <maerwald> and callbacks don't integrate nicely enough with functional programming
07:01:18 <maerwald> :/
07:01:50 <maerwald> for this, I actually WOULD use state monad, but can't
07:02:10 <fractalsea> merijin, Ah OK that is interesting to know
07:02:38 <quicksilver> what do you mean by "callbacks don't integrate nicely enough with functional programming" ?
07:03:17 <maerwald> quicksilver: how do you update a state inside a state monad from within a callback? You have no control over the "return" value and little control over the type signature
07:03:35 <quicksilver> via an IORef/MVar/TVar
07:03:39 <quicksilver> assuming it's an IO callback
07:03:47 <maerwald> yeah, that's what I mean
07:03:51 <quicksilver> and a bit of annoying - but abstractable - plumbind.
07:06:05 <hexagoxel> maerwald: http://lpaste.net/4503072110897266688
07:08:49 <wedens> can I do the following thing in postgresql-simple? suppose I have Maybe UTCTime and if it's Just, I want to append `created_at < ?` to WHERE clause and pass this parameter
07:09:32 <wedens> and I can have 5 or more Maybes that should be handled like this
07:09:49 <maerwald> hexagoxel: yeah, but at that point, I'm not sure why I need the state abstraction anymore when I am already at the IORef level
07:10:20 <aweinstock> :t Foreign.Marshal.alloca
07:10:21 <lambdabot> Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> IO b) -> IO b
07:10:24 <geekosaur> to carry the ref around without making it a global
07:10:42 <aweinstock> fractalsea: alloca stack-allocates (I think)
07:10:50 <geekosaur> no
07:11:00 <hexagoxel> maerwald: just hiding the mutability as fast as possible :p
07:11:11 <geekosaur> alloca simulates the scoping of C's alloca but is stil lheap
07:12:48 <aweinstock> is stack allocation used anywhere in haskell? (is that even a sensical question to ask?)
07:13:09 <hexagoxel> maerwald: (using MVar might be safer as my paste is not thread-safe. no atomicModifyMVar. it was sufficient for my usecase..)
07:13:23 <maerwald> isn't the stack size infinite now anyway?
07:13:47 <merijn> aweinstock: That question isn't very sensical, no
07:14:11 <merijn> aweinstock: All allocations are heap allocations in haskell (well...GHC haskell)
07:14:37 <aweinstock> I should probably finish reading the STG paper
07:14:38 <merijn> maerwald: That's the pattern match stack, not the call stack (since haskell doesn't have a call stack, hence why stack allocation is a silly notion)
07:14:43 <merijn> aweinstock: Yes ;)
07:14:56 <geekosaur> the stack is a stack of pending pattern matches. allocation on it is not a meaningful concept
07:15:08 <fractalsea> makes sense
07:17:16 <aweinstock> so the title on this is wrong? http://lpaste.net/146230
07:18:11 <fr33domlover> Q: Can I see the default Read instance GHC generates for a type?
07:18:26 <fr33domlover> I want to manually write one, not even sure how to start :P
07:18:51 <fr33domlover> (it's an enum type, i.e. data D = X | Y | Z | ...)
07:19:55 <aweinstock> read . show == id -- try using show to find out what it'll accept?
07:23:01 <fr33domlover> aweinstock, i have that - but what does the readsPrec definition even look like? :P
07:23:09 * fr33domlover will try more web search
07:23:23 * fr33domlover AFK
07:24:22 <pavonia> fr33domlover: Try -ddump-deriv
07:36:02 <maerwald> how safe is a global TVar? What can happen compared to passing it around, either implicitly via state monad or explicitly via arguments?
07:37:41 <fryguybob> maerwald: As long as you have {-# NOINLINE ... #-} it should be ok.  The reason for not doing it is it isn't modular.
07:38:53 * hackagebot language-vhdl 0.1.2.4 - VHDL AST and pretty printer in Haskell.  https://hackage.haskell.org/package/language-vhdl-0.1.2.4 (mararon)
07:43:19 <the_2nd> If I define a function f :: a -> b
07:43:24 <the_2nd> f 3 = 7
07:43:27 <the_2nd>  etc...
07:43:50 <the_2nd> how can I define a where scope which is valid for all cases? seems like I could only define in global scale or for one overload
07:43:53 * hackagebot imperative-edsl-vhdl 0.3.2 - Deep embedding of VHDL programs with code generation.  https://hackage.haskell.org/package/imperative-edsl-vhdl-0.3.2 (mararon)
07:44:00 <the_2nd> global scope
07:44:11 <frerich> the_2nd: (in general, you cannot define a function 'a -> b', but e.g. 'Int -> Int' is fine)
07:44:55 <frerich> the_2nd: You could use a 'case' statement or guards. E.g. 'f x | x == 3 = 7 | x == 4 = 8 where ...' or 'f x = case x of ... where ...'
07:45:08 <geekosaur> right, I think you need to use case instead
07:45:09 <frerich> case expression ,sorry
07:45:50 <geekosaur> the f 3 = 7; f 2 = 4; ... turns into a case expression anyway, you're just doing it manually so you have a single "definition" to which you can attach a "where"
07:46:09 <geekosaur> (nb. this is not really an "overload")
07:46:55 <ggole> f = go where go 3 = 7; go x = y; y = ... 
07:47:16 <the_2nd> geekosaur, frerich yep, works that way
07:47:17 <the_2nd> thanks
07:48:00 <hexagoxel> at what point does ghc do inlining? i noticed that several dumps (simpl/core) seem to show pre-inlining stuff.
07:53:04 <hexagoxel> is there some trick to get the final translation (assembler, if necessary) of a specific part of code? the full assembler dumb is rather long and i have problems seeing the mapping of original code section to the respective assembler part.
07:55:13 <geekosaur> this may be a #ghc question
07:55:14 <exio4> hexagoxel: re inlining: GHC has multiple inline phases, basically, the idea is that it will inline enough for some first optimizations to apply, then it'll inline the generated code ("optimizations to apply" includes RULES)
07:55:27 <geekosaur> although they're kinda busy finalizing ghc8
07:56:39 <exio4> s/inline phases/phases/, inlining/applying rules/etc is part of what it can do in those phases
07:57:50 <hexagoxel> exio4: ah, so e.g. inlines from other packages might happen later than same-module inlines?
08:00:16 <exio4> hexagoxel: yep, the idea is that you inline "quite late" in the optimizer, if there are RULES that might fire or so
08:01:29 <exio4> hexagoxel: note that it might be also "counter-productive" in some cases, because you might be inlining too late, and RULES which could have fired, didn't 
08:02:24 <exio4> hexagoxel: (imagine f x = fn1 . fn2 x , g x = fn3 x . fn4, with NOINLINE for f and g, there might be a RULE for (fn2 x . fn3 x)
08:02:33 <exio4> remove the initial (
08:04:17 <exio4> hexagoxel: anyway, I might be missing something important as I learnt this mostly playing with INLINE and RULES, and reading the wiki and so, someone who actually worked with GHC's codebase might be able to tell you other things I might have missed which are also as important 
08:06:01 <Fuco> I'm writing a haskell interface to MPRIS and I'd like to publish it on hackage, do I need to do some extra steps or can anyone upload packages there?
08:06:02 <the_2nd> I had the following data structure : Base = Base1 | Base2 | Base3
08:06:16 <the_2nd> where I can overload "render" depending on Base1 Base2 etc
08:06:56 <hexagoxel> exio4: ok, that might be the case here, interesting; thanks! you are refering to the ghc wiki?
08:07:06 <julianleviston> the_2nd: you don’t need to, do you? what type is render?
08:07:06 <the_2nd> but I also defined Radar = Radar { a , b , ... } , radar1 = Radar { a = , b = } 
08:07:26 <the_2nd> well I wanted to have a render for each of the Base types, so thats fine
08:07:36 <the_2nd> but now I want a render for each of the radar variables
08:07:46 <the_2nd> or how should I change my code accordingly?
08:08:19 <julianleviston> the_2nd: do you absolutely need the same render function for all of these types? or can you use separate functions?
08:08:44 <julianleviston> the_2nd: as in… renderBase :: Base -> ByteString (or whatever the output is)
08:08:44 <the_2nd> julianleviston, I already use "renderBase" "renderGun" etc.
08:08:47 <the_2nd> so this is fine
08:08:47 <exio4> hexagoxel: haskell wiki, ghc wiki, stack overflow, https://wiki.haskell.org/GHC/Using_rules http://stackoverflow.com/questions/14446368/how-to-use-phase-control-of-inlining-in-haskell
08:09:20 <the_2nd> julianleviston, but now I am stuck with gun, since I want seperate code for each of the variables
08:09:34 <the_2nd> thought about having equality
08:09:34 <julianleviston> the_2nd: separate code for what?
08:09:58 <the_2nd> icegun = Gun { slow = True, damage = 700 }
08:10:15 <the_2nd> which should be rendered differently than splashgun e.g.
08:10:17 <julianleviston> the_2nd: so you can’t have renderGun ?
08:10:24 <exio4> hexagoxel: (I don't really know the exact resources, and I started searching for this when I looked at some library and was klike "what's that RULES thing, and why does it have numbers next to it?") :P 
08:10:44 <the_2nd> julianleviston, sure, but icegun is no type anymore
08:10:47 <julianleviston> the_2nd: so? can’t your renderGun have a case on the type of gun it is? (assuming you pass some kind of regogniser for that)
08:11:19 <julianleviston> the_2nd: why note icegun = Gun { gunType = IceGunType … }
08:11:26 <the_2nd> yeah
08:11:26 <exio4> the_2nd: I would move that to a field in Gun, that either has a callback for rendering it, or a type that gives you enough information to render it
08:11:32 <the_2nd> thats what I just wanted to suggest :D
08:11:40 <julianleviston> the_2nd: where gunType :: GunType and data GunType = IceGunType | AnotherGunType ...
08:11:52 <julianleviston> exio4:  exactly.
08:11:57 <hexagoxel> exio4: thanks.
08:11:58 <the_2nd> GunSkin ...
08:12:16 <the_2nd> this should do it, thanks julianleviston exio4 
08:22:41 <lambdanon> Hi #haskell, I'm trying to create a function which creates a list (or better a lazy infinite list?) of random Int tuples, both numbers inside should be generated, so that they arent always the same number. I wrote the following function already which does this (see lpaste), but I suppose this can be done in a more elegant way?
08:22:46 <lpaste_> lambdanon pasted “random tuples” at http://lpaste.net/147079
08:23:29 <quicksilver> certainly using !! is pretty horrible like that, lambdanon 
08:23:36 <quicksilver> it will get slower as you go through your list
08:23:50 <julianleviston> :t gen
08:23:51 <lambdabot>     Not in scope: ‘gen’
08:23:51 <lambdabot>     Perhaps you meant ‘get’ (imported from Control.Monad.State)
08:24:59 <quicksilver> since you already know how to produce an infinite list of random Ints
08:25:02 <julianleviston> these are only pseudo random right?
08:25:15 <quicksilver> I would concentrate on a nice way to get from a list to a list of pairs
08:25:49 <quicksilver> julianleviston: you can't tell from the paste, since it's polymorphic in the actual RandomGen used
08:25:58 <julianleviston> ok cool.
08:26:13 <julianleviston> quicksilver: for some reason I thought actual random required IO. no?
08:26:19 <quicksilver> but the best you are likely to get from RandomGen's interface is a PRNG with a "true sandom" seed.
08:26:31 <quicksilver> then again that's the best most people expect anyway.
08:27:10 <aweinstock> :t let both = (***) <*> id in uncurry zip . both randoms . split
08:27:11 <lambdabot>     Couldn't match type ‘(b0, b0)’ with ‘[a1] -> [[a1]]’
08:27:11 <lambdabot>     Expected type: ([a1] -> [[a1]]) -> ([a], [a])
08:27:11 <lambdabot>       Actual type: (b0, b0) -> ([a], [a])
08:27:37 <aweinstock> :t let both = (***) <*> id in uncurry zip . both randoms . System.Random.split
08:27:39 <lambdabot> (RandomGen g, Random a) => g -> [(a, a)]
08:27:45 <lambdanon> yes, I try to write the function in way that I pass it the seed/generator, so I can keep the function pure
08:28:02 <julianleviston> :t both
08:28:03 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
08:28:10 <julianleviston> that seems a bit overkill
08:28:42 <aweinstock> julianleviston: (,) is Bitraversable?
08:29:11 <aweinstock> I'd still need a runIdentity somewhere in there with that, I think
08:29:11 <julianleviston> aweinstock: I have no idea.
08:29:25 <aweinstock> :t (***) <*> randoms
08:29:26 <lambdabot>     Couldn't match type ‘[]’ with ‘a b'’
08:29:26 <lambdabot>     Expected type: a b c -> a b' c'
08:29:26 <lambdabot>       Actual type: a b c -> [c']
08:29:37 <julianleviston> :t (***)
08:29:38 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:29:39 <quicksilver> @type let f (a:b:xs) = (a,b) : f xs in f
08:29:41 <lambdabot> [t] -> [(t, t)]
08:29:43 <aweinstock> :t ((***) <*> id) randoms
08:29:44 <lambdabot> (RandomGen g, Random a) => (g, g) -> ([a], [a])
08:29:47 <quicksilver> ^^ that's more what I wasw thinking of :P
08:29:59 <quicksilver> you can apply that to randoms or randomRs
08:30:08 <aweinstock> :t join (***)
08:30:09 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
08:30:15 <aweinstock> :t join (***) randoms
08:30:16 <lambdabot> (RandomGen g, Random a) => (g, g) -> ([a], [a])
08:30:35 <lambdanon> Ah yeah I suppose thats what I was looking for
08:30:43 <lambdanon> and a better approach
08:30:47 <aweinstock> :t uncurry zip . join (***) randoms . System.Random.split
08:30:49 <lambdabot> (RandomGen g, Random a) => g -> [(a, a)]
08:31:03 <aweinstock> ^ best codegolf I can come up with
08:32:38 <quicksilver> has to be (randomRs range) to meet lambdanon's requirements
08:32:42 <quicksilver> but that doesn't change it much
08:32:43 <julianleviston> I liked quicksilver’s version, obviously being part of a bigger function, but it seems clearer.
08:35:53 <aakkffpp> I'm creating a simple package with stack, only using jose-jwt, and when using ghci with a simple few functions I get errors like "couldn't match expected type 'crypto-pubkey-types-0.4.3:Crypto.Types.PubKey.RSA.PublicKey' with actual type 'PublicKey' (defined in cryptonite-0.6).  How can this be?  Shouldn't stack isolate me from these things?
08:36:12 <lambdanon> Ok thank you everyone, gonna try those
08:37:44 <aweinstock> :t alaf Identity both `asTypeOf` join (***) -- julianleviston 
08:37:46 <lambdabot> (a -> b) -> (a, a) -> (b, b)
08:38:24 <julianleviston> aweinstock: not sure what you’re pointing out?
08:38:29 <mrt2> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
08:38:35 --- mode: ChanServ set +o quicksilver
08:38:36 --- mode: quicksilver set +b *!*yaaic@81.230.180.*
08:38:37 --- kick: mrt2 was kicked by quicksilver (mrt2)
08:38:40 <julianleviston> lol nice.
08:38:43 --- mode: quicksilver set -o quicksilver
08:38:48 <aweinstock> :t [alaf Identity both, join (***), join bimap]
08:38:50 <lambdabot> [(a -> b) -> (a, a) -> (b, b)]
08:40:49 <aweinstock> julianleviston: I'm pointing out that the "both" that you mentioned is a more general form of the "both" that I defined
08:40:55 <exio4> quicksilver: have you tried it? maybe it works and he's just trying to tell us a really nice trick!
08:41:00 <Zekka|Sigfig> quicksilver: I think you’re giving this guy’s instructional resources too little credit
08:41:27 <aweinstock> (and that "alaf Identity" is the relevant part that says "I don't need the result to use a functor")
08:41:46 <julianleviston> aweinstock:  sure. I wasn’t doubting that your code worked or anything. I just found the other one kind of simpler.
08:42:00 <julianleviston> aweinstock: considering the person who the code was for.
08:42:20 <quicksilver> exio4: it's a very smart trick indeedl I'm on my 17th host.
08:42:23 <quicksilver> exio4: but it's still off-topic.
08:42:24 <julianleviston> aweinstock: but it’s cool to see alternate ways to do things! expose me to cool things :)
08:43:01 <exio4> quicksilver: heh :P 
08:43:53 <aweinstock> julianleviston: quicksilver's solution of (let f (a:b:xs) = (a,b) : f xs in f) was after I posted the more complicated one, is that what you mean by "the other one"?
08:44:10 <julianleviston> yep.
08:47:08 <LangeOortjes> Which package for monad transformers is typically used. I am using tranformers but I noticed that mtl actually offers useful typeclasses such as MonadError
08:47:21 <phadej> both
08:47:32 <phadej> mtl depends on transformers
08:47:36 <phadej> nowadays
08:49:09 <LangeOortjes> phadej, thanks, I might use the additional functionality from mtl then 
09:02:23 <Fuco> why do I need to define "other-modules" in cabal... can't it just take all not in exposed?
09:02:30 <Fuco> when is a situation where I don't want a module named there?
09:03:05 <dcoutts> Fuco: it's for a few reasons. Mainly so that we can work out what files are involved without having to compile everything.
09:03:39 <dcoutts> Fuco: but it's also required if you use pre-processors
09:04:09 <Fuco> hmm... so basically if I list all the modules there that's OK right?
09:04:18 <dcoutts> Fuco: yep
09:04:37 <Fuco> thanks
09:18:58 <johnw> plus, there are times when you only want certain modules included in the package for certain platforms
09:23:08 <begriffs> Why do most Haskell libraries use a four-number version? The haskell wiki about versioning policy suggests three numbers: major, minor and patch.
09:23:28 <begriffs> I adopted four numbers in my own package just to fit in but never understood why.
09:25:03 <lyxia> That's probably because cabal sets 0.0.0.0 by default.
09:25:08 <monochrom> "A.B is known as the major version number" that's already 2 numbers there
09:25:37 <c_wraith> the pvp is pretty specific that it's (at least) 4 parts
09:25:51 <c_wraith> as monochrom points out 
09:28:35 <begriffs> Ah I see that now. So why a double major version, rather than incrementing a single major version?
09:28:47 <hexagoxel> c_wraith: wait, what?
09:29:37 <geekosaur> monochrom quoted the specific part of the PVP. think how ghc versions work... 7.10 is considered a major version (vs. e.g. 7.8)
09:30:25 <c_wraith> begriffs, mostly to allow indicating the difference between technically requiring a major version bump, and actually being a major change. 
09:31:29 <monochrom> people seem to like it
09:31:36 <hexagoxel> "[..] A.B.C, and may optionally have any number of additional components"
09:31:44 <hexagoxel> i read this as "at least 3 parts"
09:31:49 <hexagoxel> not 4
09:31:56 <c_wraith> begriffs, there are lots of things that are relatively small changes that require an automatic major version bump, like adding or removing an instance. 
09:32:45 <c_wraith> begriffs, so it's useful to have a separate component of the major version to indicate that something was actually a really big change 
09:33:10 <lpaste_> mtottenh pasted “FTGL example” at http://lpaste.net/147082
09:33:27 <mtottenh> Hi I seem to be getting a segfault in the FTGL library when I try to run the basic example on it's page. (See linked paste)
09:33:50 <begriffs> c_wraith: got it, that makes sense
09:35:03 <monochrom> hexagoxel, I was speaking in the context of "major, minor, patch --- looks 3 to me"
09:35:14 <c_wraith> hexagoxel, OK, yes, the patch level is technically optional. but it's usually worth including anyway.. 
09:35:45 <monochrom> but it's 3 number if you go "major, minor" period
09:36:54 <hexagoxel> monochrom: (i was commenting on c_wraith)
09:37:01 <mmmmjjjjj> would it be a good pattern to have all functions accept a function which recieves the output as a parameter instead of just returning the output, such as 'a -> (b -> c -> d) -> d' instead of 'a -> (b, c)' ?
09:37:11 <monochrom> I see
09:37:40 <geekosaur> mmmmjjjjj, sounds like continuation passing style?
09:37:52 <mmmmjjjjj> geekosaur: is that a thing?
09:38:23 <mmmmjjjjj> geekosaur: oh, I see, I'm going to read up on that
09:39:38 <mmmmjjjjj> geekosaur: I was thinking of using something like this to eliminate the need for types such as tuples in favour of curried functions
09:42:08 <mtottenh> Anyone have any ideas?
09:43:41 <mtottenh> Under GDB it seems to segfault at: glPushAttrib () from /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
10:04:32 <noobie_> hey, how do i interrupt something in haskell from cmd? For example [1..]
10:04:56 <noobie_> Besides of course closing down cmd :)
10:05:17 <kadoban> noobie_: ctrl+c on *nix, on windows is it ctrl+z maybe? I forget ctrl+d? One of those.
10:05:17 <ggole> ^C should do it
10:05:24 <ggole> (On unix.)
10:05:49 <noobie_> Thanks! I tried it and ctrl C worked
10:18:45 <maerwald> http://lpaste.net/147085 does this function already exist?
10:18:52 <maerwald> I feel like I'm reinventing something
10:19:20 <johnw> maerwald: yes, for_ will do that in Data.Foldable
10:19:29 <johnw> for_ (some Maybe value) $ \a -> some IO () action
10:19:52 <johnw> only, be careful using it if you have a recursive call within IO ()
10:21:58 <maerwald> ah right... I probably missed that because "for_" sounds weird in the context of Maybe
10:22:40 <maerwald> that's what you get with abstract functions, no sane names :D
10:27:22 <xplat> i expected something as big and old as hxt to come with a working test suite, but most of the tests don't have any harness code or expected output, they just print something and i guess the developers evaluate by hand if it is right or not ... ?
10:31:32 <johnw> xplat: probably
10:33:24 <mtottenh> Turns out I did not RTFM...
10:33:39 <Zoetrope> maerwald: This is why god invented hoogle :D https://www.haskell.org/hoogle/
10:34:47 <maerwald> Zoetrope: it often gives poor results
10:35:22 <xplat> sometimes it works better if you use the hoogles on stackage
10:35:39 <xplat> or hayoo
10:36:54 <Zoetrope> It usually gives good results for building block functions
10:37:47 <Zoetrope> Well every function is a building block, I mean indivisible
10:38:53 <Zoetrope> That's too strong of a word too, you know what I mean >.>
10:42:16 <xplat> ...not really sure i do
10:43:16 <Zoetrope> It usually gives good results for functions that are that are heavily used in composition
11:05:56 <kyle_l> Has anyone had success building ghcjs-dom on Windows (particularly with stack)?
11:06:33 <kyle_l> I'm running into this issue, which doesn't seem to have gain much attention: https://github.com/ghcjs/ghcjs-dom/issues/19
11:15:45 <fr33domlover> bergmark, ping
11:16:27 <fr33domlover> I have a question related to the 'feed' package
11:49:03 * hackagebot xlsx 0.2.0 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.0 (KirillZaborsky)
11:54:03 * hackagebot postgresql-simple 0.5.1.2 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.1.2 (LeonSmith)
12:24:57 <joeyh> johnw: so I'm looking at your gitlib, trying to find a way to update a file's mtime etc in the index file
12:32:13 <diphtherial> hey, random question, but do any of you have a web framework you'd recommend for writing quick RESTful HTTP interfaces? i saw happstacks mentioned on the haskell site, not sure how up-to-date that list is
12:33:02 <Clint> diphtherial: probably yesod
12:33:35 <diphtherial> Clint: nice, thanks; i'll check it out
12:34:59 <johnw> joeyh: ok
12:35:06 <athan> diphtherial: Docs are still under construction, but you might like nestedroutes.com
12:35:46 <johnw> joeyh: you want to readIndex into a TreeT, update the entry, then writeIndex
12:37:34 <diphtherial> athan: interesting, i'll give that a look as well
12:38:00 <diphtherial> i'm a haskell newbie, so probably something more established (i.e. with more documentation/tutorials/etc.) is a better idea
12:38:25 <joeyh> is that using the libgit2 backend?
12:38:55 <johnw> joeyh: it's backend agnostic; one sec, in half an hour I can help in #gitlib
12:39:01 <joeyh> oh, I see.. something is weird with the haddocks
12:39:24 <joeyh> I was looking here, and the page is just blank. But I found writeindex in the haddock index. http://hackage.haskell.org/package/gitlib-3.1.1/docs/Git.html
12:39:54 <joeyh> if it's backend agnostic, it seems you must have an index file parser in haskell in there?
12:40:03 <joeyh> (there's no plumbing to do this afaik)
12:40:10 <johnw> (sorry, on phone now)
12:53:53 <joeyh> johnw: when you get back, I'm looking in gitlib-cmdline and its instance of MonadGit doesn't include readIndex/writeIndex. 
12:54:10 <johnw> joeyh: join me in #gitlib
12:54:32 <joeyh> not really gitlib specific is it? I can see how to use gitlib-libgit2 to do it
13:05:24 <mrt3> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
13:08:06 <maerwald> man. I always try to understand that stuff. By the time I realize it's nonsense, I'm already confused
13:09:37 <ocramz> mrt3 : "ayahuasceros", users of ayahuasca; dissociative shamanic infusion. Do not try at home
13:09:53 <Jinxit> meeting these people in real life is even more fascinating
13:09:56 <Cale> What is this doing in #haskell?
13:10:05 <ocramz> Cale: no idea
13:10:07 <Jinxit> my guess is that it's not only in here
13:10:24 <Hijiri> haskell is my anti-drug
13:11:31 <ocramz> speaking of which, anyone can help me with a TypeFamilies derivation error? "Could not deduce (SElem c0 ~ SElem c)"
13:12:21 --- mode: ChanServ set +o Cale
13:12:25 --- mode: Cale set +b *!*@m77-218-225-184.cust.tele2.se
13:12:26 --- kick: mrt3 was kicked by Cale (mrt3)
13:12:29 --- mode: Cale set -o Cale
13:14:24 <aweinstock> mrt[2-3] spammed that a few times earlier today, and according to my logs last spammed (the exact same thing) on december 5th
13:15:11 <maerwald> I'm still trying to figure out if there is a way to have a mutable state throughout unrelated gtk+ callback functions without IORef/MVar/TVar... I guess the only way out would be some sort of client-server model, which would be way more complex though
13:15:33 <sbrg> I want to show some students some examples of haskell libraries useful for 'real world' stuff, but without them being too complicated. any suggestions? We've thought about ghcjs, servant, maybe some of the web frameworks
13:16:03 <maerwald> sbrg: diagrams... if you keep to the simple stuff
13:16:07 <ocramz> Namely, I'm writing a polymorphic container typeclass, `class SC c where type SIdx c; type SDim c`, since I'd like to abstract some types over the dimensionality; e.g. SIdx would be Int for Vector, (Int, Int) for a CSR "matrix" type etc.
13:16:10 <sbrg> maerwald: already showed them diagrams
13:16:25 <sbrg> but I was thinking some more 'enterprisey' so to speak. something people really expect languages to be able to do do these days
13:16:37 <sbrg> (like web servers, etc, but I'm just looking for more ideas)
13:16:44 <maerwald> web frameworks are complicated, that includes haskell
13:17:35 <maerwald> another possibility would be juicypixels to do basic image processing stuff and geometry
13:17:55 <lpaste_> ocramz pasted “TypeFamiles "could not deduce"” at http://lpaste.net/147094
13:18:22 <ocramz> ^ super simple example
13:18:51 <ocramz> ^^ any help would be much appreciated
13:19:16 <tommd> sbrg: How about mellow and mellow-ffmpeg?
13:19:29 <tommd> sbrg: Depends on what you mean by "real".
13:21:20 <sbrg> tommd: yeah I don't really know what I want. I think i'll know when I think of it / someone suggests it. I've already showed them diagrams, though mostly in connection with monoids, and I've showed them some simple stuff I did with scotty. 
13:21:40 <maerwald> @hackage juicypixels
13:21:40 <lambdabot> http://hackage.haskell.org/package/juicypixels
13:21:47 <maerwald> wat
13:22:20 <maerwald> @hackage JuicyPixels
13:22:20 <lambdabot> http://hackage.haskell.org/package/JuicyPixels
13:22:46 <maerwald> that's commonly used and (in contrast to many others) not really a DSL
13:23:41 <sbrg> tommd: mellow-ffmpeg, I'm not finding anything except ffmpeg-light?
13:34:53 <maerwald> mh, do the gtk3 bindings have performance issues? I get ~1-2% cpu usage straight with a minimal top-level window
13:37:49 <bionikspoon> question, do you guys use a keybindings to write arrows?  the '->' and '=>' , they seem awkward on the keyboard
13:38:30 <lispy> bionikspoon: it's a lot less awkward in dvorak :)
13:39:18 <kadoban> Hmm, that's a good point, they are pretty terribly in qwerty.
13:40:29 <bionikspoon> oh god, do people use that keyboard layout?
13:41:12 <kadoban> qwerty? Yeah for some reason they do.
13:41:28 <bionikspoon> I could not imagine changing layouts lol, as useful as it may be
13:41:51 <bionikspoon> no, the dvorak layout that lispy mentioned
13:42:03 <maerwald> keyboard layout war... almost as good as editor war
13:43:29 <S_J> is there a GPU lib for haskell?
13:43:55 <kadoban> bionikspoon: It takes a surprisingly short time before it's natural. It is awkward at first though.
13:44:39 <maerwald> everyone says that from their own editor too
13:44:52 <kadoban> It's true there too.
13:45:16 <maerwald> not really, because it depends on the individual
13:46:58 <bionikspoon> if use this dvorak layout, do you "forget" how to use normal layouts efficiently ?
13:47:18 <flounders> Took me about a month to get adjusted to Dvorak, but it probably would have been shorter if I wasn't doing tech support on machines that used QWERTY.
13:47:51 <flounders> I'm able to transition between using both but it takes about a minute of tolerating some mistakes.
13:48:00 <kadoban> bionikspoon: You can do both, but if you don't use qwerty for a long time it'll degrade (like several months)
13:49:57 <hexagoxel> is alloca + _ + peek the best way to pass multiple results from c back to haskell?
13:51:15 <bionikspoon> interesting, I sort of want to try it out
13:54:51 <lispy> S_J: there is an opencl binding
13:55:12 <lispy> S_J: and there are a couple embedded DSLs to make classes of computation more natural
13:55:40 <lispy> S_J: see for instance this dsl: https://github.com/mainland/nikola
14:04:30 <johnw> hexagoxel: I think your question needs a little more context
14:04:51 <johnw> are you talking about Haskell code that calls C code that calls Haskell code?  If not, then wouldn't it matter entirely upon the nature of the C function you're calling?
14:05:21 <spuz> I'm new to haskell, what is the recommended way to test an application with stack?
14:05:55 <ocramz> spuz: so you built it with stack you mean?
14:06:08 <kadoban> spuz: Set up a test-suite in the .cabal file, run it with 'stack test' ?
14:06:14 <spuz> so the tests run when I type 'stack test'
14:07:00 <dcoutts> spuz: cabal run $appname, to run the program, as opposed to test the test-suite
14:08:14 <kadoban> I would think 'stack exec $appname' would make more sense in stack
14:10:47 <spuz> dcoutts, I'm talking about running the unit tests, not executing the application
14:10:58 <dcoutts> spuz: oh then it's just cabal test
14:11:09 <dcoutts> and stack is the same I think
14:11:36 <spuz> dcoutts, ok what I'm asking is how do I actually make that command do something useful - how do I write a test that will execute when that command is run?
14:11:49 <dcoutts> spuz: ah, you need to define a test-suite in the .cabal file
14:12:31 <dcoutts> spuz: it's much like an executable, but 'test-suite' rather than executable. And type: exitcode-stdio-1.0
14:12:49 <dcoutts> spuz: for this and other details, see the Cabal user guide
14:14:51 <kadoban> spuz: Try, in a separate directory: 'stack new blah quickcheck-test-framework' and look around at what it gives you, it'll have a test-suite already set up. You maybe need to learn quickcheck and/or other testing frameworks a bit.
14:15:13 <spuz> kadoban, great thanks
14:15:25 <spuz> i want to try quick check too so that's useful
14:17:49 <hexagoxel> johnw: no, just haskell code that calls c code. i would like the c function to have a haskell type like e.g. `IO (Int, Int)`.
14:18:09 <johnw> you can always have it return a pair_t type that you invent
14:19:19 <johnw> I do find a note on SO that says: "A recent GHC extension allows for "primop" imports -- which bypass the FFI mechanism and support arbitrary calling conventions and passing structures via unboxed tuples."
14:19:27 <johnw> but I'm not sure that's the best for you here
14:20:28 <hexagoxel> that almost seems overkill, but i'll have a look.
14:24:45 <maerwald> from System.Directory: Permissions: "For directories, the executable field will be  False" <- how does that make any sense?
14:25:20 <hexagoxel> (seems like i'd need to add a new datatype + Storable instance on the haskell side - interesting, but not needed in this case)
14:26:24 <hexagoxel> i was more wondering if there existed a trivial wrapper around alloca and poke for this usecase, as it should come up relatively often for any ffi stuff.
14:26:48 <hexagoxel> johnw: thanks nonetheless.
14:29:44 <johnw> I think in most cases, I would create a struct type on the C side and use that
14:29:58 <johnw> because what otherwise would be the C equivelent to a return type of IO (Int, Int)?
14:31:03 <charles_> Is there a cleaner way to define multiple constants in Haskell code?
14:31:08 <demize> maerwald: Because you missed the rest of that sentence?
14:31:15 <Guest13360> I have to define several constants. A = 1, B = 2, C = 3, etc.
14:32:00 <demize> maerwald: The type has both an executable and a searchable field.
14:32:04 <byorgey> Guest13360: you can write things like   [a,b,c] = [1,2,3]
14:32:05 <Guest13360> Instead of writing them in multiple lines, is there a more concise way of doing it?
14:32:08 <monochrom> I just write "a = 1" on one line, "b = 2" on another line, etc.  and perhaps add comments.
14:32:19 <maerwald> demize: searchable is not an accurate description of what executable means for directories, so no
14:32:19 <byorgey> Guest13360: but what are you trying to do?  Why do you need to define so many constants?
14:32:21 <Guest13360> In python, you can do  A,B,C=1,2,3
14:32:22 <sbrg> okay, so, uh.. what happened to the persist thing? I mean, the book itself on it, on yesodweb, contains out of date examples, and there aren't even changelogs that document what happened to the TH library that all the exmaples seem to use.
14:32:25 <sbrg> anyone know what replaced it?
14:32:25 <demize> maerwald: Yes, it is.
14:32:27 <monochrom> in fact the comments will drive me to keep them multiple lines
14:32:29 <maerwald> no
14:32:40 <Guest13360> I have many parameters to define for my physics simulation
14:32:50 <aweinstock> > let (a,b,c) = (1, 10, 100) in (b, c, a)
14:32:52 <lambdabot>  (10,100,1)
14:33:02 <monochrom> I would comment on each parameter individually anyway
14:33:09 <jle`> Guest13360: you can also define a data type to hold your parameters
14:33:33 <byorgey> Guest13360: you can do what I showed or what aweinstock showed above, but I would advise you not to.  Because then it is hard to tell which number is for which constant.
14:33:42 <jle`> data Params = P { pHeight :: Double, pWidth :: Double ... }
14:33:50 <jle`> and then you can do myParams = P 10 11 23 True "hello" ...
14:34:17 <demize> maerwald: "searchable" is commonly used for exactly that distinction.
14:34:19 <byorgey> Guest13360: It saves lines of code, but makes the program harder to understand and modify.  Lines of code is the wrong thing to optimize.
14:34:27 <Guest13360> byorgey: That's true.
14:34:46 <Guest13360> jle`: That's a good idea actually.
14:34:49 <monochrom> I optimize 1/(amount of comments)
14:35:33 <demize> maerwald: I can give you multiple links as references for that, but you could even just look at the chmod manpage and search for "search".
14:35:35 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs
14:36:52 <maerwald> demize: I am using linux for a decade and it's the first time I have heard of "searchable". Everyone else calls it "executable" and that's more accurate, because it also means you cannot enter it. Even with -x you can search the directory.
14:36:52 <tommd> sbrg: Sorry I ran off.  'mellow*' are two of my new packages that allow you to easily glue either kinect (mellow) of web cams (-ffmpeg) to friday (image processing) and render with Gloss.
14:37:20 <sbrg> tommd: aaah, that sounds cool. I wish I had time to get that up and running. for now we've settled with something web based
14:37:23 <tommd> sbrg: I have a few demos in the ~20 line range that show simple things like outlines and canny edges.
14:37:27 <sbrg> really?
14:37:31 <sbrg> 20 lines?
14:37:33 <tommd> Yes
14:37:37 <sbrg> mind sharing?
14:37:44 <tommd> That is why I made the framework, to make this sort of thing simple stupid to teach with.
14:38:00 <demize> maerwald: How long you've been using Linux is irrelevant. People call it executable because the same bit is used for both, and how the hell does "execute" imply "you can cd into it"?
14:38:10 <demize> maerwald: Anyway, it means more than just "you can cd into it".
14:38:16 <maerwald> I am aware of that
14:38:31 <tommd> sbrg: Depth rendering (slightly ugly, I don't know how to turn depth information into pretty RGBA) https://github.com/TomMD/mellow/blob/master/examples/Depth.hs
14:38:33 <maerwald> and it means more than "searchable"
14:38:34 <demize> maerwald: It means that you can find the inodes for the files.
14:38:49 <Sindriav_> Hey, are there any plans on fixing the syntax highlighter on the wiki?
14:38:52 <monochrom> it means that English is limiting
14:38:55 <demize> That doesn't mean that "searchable" isn't an accurate term.
14:39:06 <demize> And "executable" is even less so.
14:39:16 <maerwald> it's not used anywhere else, so I am puzzled why the library maintainer uses it
14:39:17 <carmethene> hey guys
14:39:22 <tommd> sbrg: A much longer psychedelic outlines program (200 lines) - I was going for something very particular (https://github.com/TomMD/mellow/blob/master/examples/Psychedelic.hs)
14:39:32 <maerwald> except to create confusion
14:39:36 <demize> maerwald: I already gave you one example you can check yourself.
14:39:40 <carmethene> I'm following an attoparsec tutorial, and I'm getting a lot of errors saying it can't convert String -> ByteString
14:39:46 <demize> maerwald: And I can give you other links calling it search.
14:39:51 <tommd> sbrg: Canny edge detection (https://github.com/TomMD/mellow-ffmpeg/blob/master/examples/Canny.hs)
14:39:55 <carmethene> e.g. <|> (string "blah" >> ...
14:40:03 <maerwald> demize: it's not common still
14:40:04 <carmethene> am I expected to pack all of my arguments?
14:40:14 <monochrom> carmethene: post complete verbatim unabridged code on lpaste.net
14:40:14 <carmethene> e.g. string (pack "blah")
14:40:22 <carmethene> monochrom: sure, sec
14:40:24 <monochrom> but probably yes
14:40:38 <byorgey> carmethene: maybe it is expecting you to add {-# LANGUAGE OverloadedStrings #-} to the top of your source file?
14:40:53 <carmethene> AH
14:40:57 <carmethene> right
14:41:00 <carmethene> yes, that's probably it
14:41:03 <carmethene> https://gist.github.com/193748de51778d57f266 btw
14:41:16 <carmethene> (very new at this)
14:41:25 <carmethene> right!
14:41:29 <carmethene> yes I missed that in the tutorial, doh
14:41:36 <byorgey> carmethene: no worries =)
14:41:38 <carmethene> byorgey: a shiny gold star to you, thanks very much
14:41:43 <byorgey> =D
14:45:48 <sbrg> tommd: that's really cool. thanks! I'll have to save those links, though I'm afraid I probably won't be able to show them this this time around.
14:48:05 <tommd> sbrg: I'm hoping to make a tutorial targeted at middle schoolers out of Haskell and image processing so if you ever end up using these then I'd love to hear how it goes.
15:00:11 <jle`> it'd be nice if we had strict tuples
15:00:13 <jle`> struples
15:01:25 <tommd> Could call it `data STruple a b` in Data.Tuple
15:02:02 <mniip> data Striple a b c
15:02:18 <jle`> it'd be nice.  i guess a standard one somewhere in the ecosystem would be nice, if one built into the syntax was out of the question
15:03:35 <tommd> jel`: Its hard to think up a clean unambiguous syntax.  (# #) is taken as is `(! ...)`. 
15:03:40 <tommd> jle`: ^^
15:04:18 <jle`> (!# x, y #!)
15:05:00 <tommd> Blech!
15:05:06 <monochrom> the "strict" library has a strict pair. although, it's just a pair.
15:05:08 <mniip> '(,) is taken too
15:05:19 <monochrom> also, no additional syntax
15:05:19 <mniip> maybe (,)'
15:05:20 <jle`> or maybe we can require normal tuples to be (~ x, y ~)
15:05:30 <tommd> lol, good luck.
15:05:33 <spuz> how do I wire up a bunch of HUnit tests into a Spec.hs file?
15:05:34 <jle`> thank you
15:05:44 <jle`> (x #, y)
15:05:54 <apriori> spuz, manually or use HTF
15:05:55 <mniip> @let (~) = xor
15:05:55 <lambdabot>  Parse failed: Parse error: )
15:05:59 <jle`> (x !, y)
15:06:10 <jle`> (x !, y !, z)
15:06:10 <pikajude> is there an analog of fromIntegral for fractionals?
15:06:11 <mniip> aw, can't use that
15:06:18 <jle`> pikajude: round?
15:06:24 <monochrom> yes, realToFrac
15:06:48 <pikajude> no, I mean Fractional -> Num, not the other way
15:07:10 <jle`> any Fractional is already usable as a Num
15:07:48 <jle`> you can use functions like (+), sum, etc. on any Fractional :) 
15:08:12 <spuz> man yet another framework... trying to understand the difference between stack, cabal, hunit, hspec, quickcheck, smallcheck, runhaskell, quickspec, htf, criterion, tasty... I think you get the idea
15:08:15 <arkeet> :t fromRational
15:08:16 <lambdabot> Fractional a => Rational -> a
15:08:18 <arkeet> :t fromRational . toRational
15:08:18 <pikajude> hmm
15:08:20 <lambdabot> (Fractional c, Real a) => a -> c
15:08:21 <jle`> Fractional -> Num doesn't really make too much sense though because they're both typeclasses
15:08:29 <arkeet> :t realToFrac
15:08:30 <pikajude> jle`: and yet fromIntegral exists
15:08:30 <lambdabot> (Fractional b, Real a) => a -> b
15:08:43 <monochrom> fromRational.toRational is realToFrac
15:08:47 <jle`> fromIntegral is not Integral -> Num
15:08:49 <jle`> :t fromIntegral
15:08:51 <lambdabot> (Integral a, Num b) => a -> b
15:08:53 <pikajude> isn't it?
15:08:59 <jle`> it's Integral a, Num b => a -> b :)
15:09:17 <pikajude> oh ok
15:09:27 <jle`> it means, convert any Integral to *any* other Num instance, on-demand
15:09:31 <pikajude> what function in the standard library is (Fractional a, Num b) => a -> b?
15:09:40 <arkeet> that doesn't exist.
15:09:42 <monochrom> there isn't one, even after composition
15:09:43 <johnw> pikajude: xorg-server not building anymore btw
15:09:52 <tommd> :type fromIntegral . floor . realToFrac
15:09:52 <pikajude> why does fromIntegral exist?
15:09:53 <johnw> (not using sandbox)
15:10:03 <jle`> pikajude: `round` is the closest you'll get
15:10:12 <tommd> pikajude: To convert between integral typesl.
15:10:28 <jle`> pikajude: you can create a Num a => a for *any* Num instance, by giving it an Integer
15:10:31 <tommd> pikajude: Int -> Integer, Integer -> Int, Integer -> Word16, Word16 -> Word32 ....
15:10:47 <jle`> pikajude: so it's possible, given an Integer, to create a Num a => a for any Num instance on-demand
15:11:14 <jle`> but not all Num types, for instance, support representing 3.2, or 9.81, etc.
15:11:25 <monochrom> fromIntegral exists because fromInteger.toInteger can be done
15:11:33 <jle`> :t fromInteger.round
15:11:34 <lambdabot> (Num c, RealFrac a) => a -> c
15:11:44 <jle`> that's as close as you're going to get, I think
15:12:12 <jle`> pikajude: a function that's (Fractional a, Num b) => a -> b means, give me a Fractional instance and i can turn it into *any* Num instance you want, ever
15:12:25 <jle`> so it would have to be able to do things like (Fractional a) => a -> Int
15:12:31 <jle`> Fractional a => a -> Integer, etc.
15:12:52 <jle`> so it doesn't make too much sense, unless you give some way to round
15:13:14 <jle`> but the Fractional interface doesn't really provide any way to "round"
15:14:19 <jle`> pikajude: do you have specific types you are using/need?
15:14:25 <jle`> that'll make looking for your function a lot easier
15:15:04 <pikajude> oh well i'm writing a parser for an XML document and i need a way to convert an attribute that looks like a number into either an integral or a float
15:15:17 <fr33domlover> Does lpaste.net have any CLI tool for POSTing a paste?
15:15:18 <pikajude> but I guess I need two different functions to do that
15:17:02 <monochrom> your informed rational options are: stick to float; use an Either type
15:18:41 <pikajude> okay
15:19:48 <jay6981> hello. i'm stuck on my cis 194 homework. could someone give me a hint? stuck on line 118 here: http://lpaste.net/8243770355475283968
15:21:57 <arkeet> jay6981: what should the types of mul and add be?
15:22:22 <jay6981> arkeet: a -> a -> a i think
15:22:28 <arkeet> what's a?
15:22:32 <arkeet> in that instance
15:22:47 <jay6981> the function (M.Map String Integer -> Maybe Integer) ?
15:23:04 <arkeet> yeah, the function type
15:23:20 <arkeet> in particular, mul and add take functions as arguments.
15:23:28 <arkeet> maybe it helps to write out the full type?
15:23:29 <monochrom> now write it out in full, and be horrified
15:24:36 <jay6981> yeah, mul takes two of those functions and returns another? all off type M.Map String Integer -> Maybe Integer right?
15:24:47 <monochrom> yes
15:35:47 <Doom009> hi all
15:51:03 <Axman6> Doom009: hello!
15:58:40 <sbrg> resources on the internet suggest that Persistent types automatically get ToJSON / FromJSON instances, but that doesn't seem to be the case in my scenario. Did something change since the article I am reading was written? 
15:58:52 <sbrg> http://taylor.fausak.me/2014/10/21/building-a-json-rest-api-in-haskell/ this article, btw. search for "ts ::"
16:43:10 <c_wraith> sbrg, it's probably using default instances generated by Generic
16:45:07 <c_wraith> sbrg, but you still have to explicitly request those instances exist
16:47:10 <c_wraith> sbrg, and yeah, the article says nothing about that. you just need lines like "instance ToJSON MyType" for each type and class. 
16:58:55 <leafwind> Hi all. Would someone kindly point me to where can I find the settings file for GHC in Ubuntu, using haskell 7.6.3. I'd like to adjust the LLVM settings.
16:59:52 <lambda-11235> I have four functions that do almost the same thing, and I can't condense them into one function because they use different pattern matches.
17:00:00 <lambda-11235> Any suggestions?
17:00:19 <mike1000> I'm using the Haskell platform on Windows 7. I need to profile my executable. My understanding is that I need to build all the libraries for profiling. Can someone point me to a tutorial that would explain this in basic terms?
17:00:51 <Axman6> lambda-11235: paste the code and someone might be able to help
17:00:58 <leafwind> lambda-11235: you could perhaps refactor the inner code to a generic function called by the "entry" functions that do the pattern matching.
17:02:21 <geekosaur> leafwind, /usr/lib/ghc/settings
17:02:46 <leafwind> thanks geekosaur, got it
17:03:07 <Axman6> mike1000: usually it's as easy as cabal install -p --enable-profiling, but I would strongly suggest you try using stack (http://docs.haskellstack.org/en/stable/README.html), it'll make your life a lot easier (you can use stack build --library-profiling --executable-profiling and it'll do the right thing, without the mess that cabal can quickly lead to)
17:03:21 <lpaste_> lambda-11235 pasted “Brain optimizer” at http://lpaste.net/147104
17:03:38 <leafwind> mike1000: and I'd do all that cabal recompiling in a sandbox. Will result in broken dependencies otherwise in my experience.
17:04:35 <mike1000> Axman6: is there another argument to "cabal install -p --enable-profiling"?
17:04:55 <Axman6> mike1000: I can't remember, it's been months since I used it
17:05:17 <mike1000> what I don't understand is how to recompile the two libraries I've already installed, and I don't understand if the libraries that came with the Haskell platform also need to be recompiled
17:05:20 <Axman6> perhaps https://nikita-volkov.github.io/profiling-cabal-projects/ can help (I haven't read through it though)
17:05:42 <Axman6> the ones from the platform should have been installed with their profiling version too
17:05:51 <leafwind> mike1000: stackoverflow has some comments, generally with users ending up deleting and recompiling all.
17:07:28 <mike1000> leafwind: I haven't had much luck with stackoverflow, because the data there is usually incomplete. I need someone to guide me through the entire process.. I really don't understand cabal basics
17:07:58 <mike1000> Axman6, that looks good, I'll try following it and report back if I run into trouble
17:09:14 * hackagebot unbreak 0.3.0 - Secure editing of remote documents with unstable connection  https://hackage.haskell.org/package/unbreak-0.3.0 (kinoru)
17:09:33 <Axman6> mike1000: seriously though, check out stack, it takes care of all your pain. it's completely changed the way we develop haskell apps
17:10:59 <mike1000> well there's something basic I need to understand. when I run a command like "cabal configure ..." I get "no cabal file found". I don't know what a cabal file is. I never needed to create one to use ghc with the haskell platform
17:11:31 <mike1000> there
17:12:23 <mike1000> there's some notions of projects or packages or something but I have always just run "ghc --make app.hs", after running "cabal install xml" or whatever libraries I need.
17:19:11 <lingxiao> hey all i havea super basic qustion
17:19:25 <lingxiao> in my file structure i have three directories, benchmark, src, and test
17:19:48 <lingxiao> in some file benchmark/Foo.hs I need to import file from src/Bar.hs
17:19:57 <lingxiao> but I can't just do import Bar.hs in Foo.hs
17:20:34 <athan> lingxiao: Sure you can!
17:20:47 <lingxiao> lol yeah :( it's embarasing but i dont know how
17:20:53 <athan> just make sure in your `Benchmark` clause in your .cabal file, you list `src` as a source folder too
17:21:01 <athan> don't worry :) we all started as noobs!
17:21:08 <athan> (well, I'll take that back.)
17:21:28 <lingxiao> oh dont' havea  .cabal file thats prob why
17:21:41 <athan> lingxiao: Here check this out: https://github.com/athanclark/timemap/blob/master/timemap.cabal#L58
17:21:45 <lingxiao> see ive been developing toy stuff in hasell for a while but never knew some of the basics ... …:(
17:21:47 <athan> it would be really good to know :\
17:21:57 <athan> `stack new` has a bunch of templates!
17:21:58 <Sindriav_> Hey, are there any plans on fixing the syntax highlighter on the wiki?
17:22:14 <athan> :) like I said, we all started somewhere
17:22:19 <athan> I used to only use lambdabot :P
17:22:30 <mike1000> this is something I'm missing too. I have only ever compiled my stuff with ghc directly. I don't know when I need a .cabal file, and I don't know where to put it. I also don't know how this relates to using sandboxes
17:22:44 <lingxiao> athan hahah thanks for the encouragement!
17:23:00 <athan> np :)
17:23:14 <lingxiao> mike1000 yes allt this dotting the ts and corssing the i's stuff
17:23:17 <athan> mike1000: Well, a cabal file specifies a "package", a Cabal package specifically
17:23:18 <lingxiao> which is super important
17:23:32 <glguy> https://www.haskell.org/cabal/users-guide/ talks all about Cabal
17:23:42 <mike1000> do I need to make my code into a package in order to make a sandbox?
17:23:46 <athan> mike1000: When you do `cabal install foo` or `stack install foo`, "foo" is the package in this sense :)
17:24:02 <athan> they can define specific executables you want, and the library components you want to expose
17:24:18 <Welkin> athan: np-complete
17:24:30 <athan> like when you do `stack install pandoc`, it installs the `pandoc` executable in ~/.stack/bin/ or something like that :P
17:25:04 <athan> Welkin: I want to know this well :|
17:25:09 <lingxiao> athan so your timemap.cabal is generated by some tool right?
17:25:34 <athan> lingxiao: well, I've made edits to it, but I used a template to bootstrap my package together
17:25:39 <mike1000> I have successfully installed remote packages with "cabal install" but when I look at the tutorials for compiling with profiling, they talk about commands like "cabal build". These commands never work for me because they report I am missing a cabal file.
17:25:42 <lingxiao> ahh is there a tutorial that gets me started?
17:25:42 <athan> I like to use `hi`, but it's kinda complicated
17:25:48 <athan> `stack new` is the best bet :)
17:25:55 <athan> and you can list the available templates with `stack templates`
17:25:59 <lingxiao> glguy send me a really good link ... but man its a beast
17:26:17 <lingxiao> oh yeah im profiling with criterion as well
17:26:25 <lingxiao> so i gotta get that working with a sane file structure
17:26:38 <athan> :) just keep them all in a directory, usually named after the package
17:26:56 <athan> `cabal build` builds a package if you're in that directory
17:27:05 <athan> I would advise `stack`, though instead
17:27:12 <athan> because it's more friendly for rebuilds
17:27:35 <lingxiao> athan sorry you're talking to me right?
17:27:39 <lingxiao> so I should search stack 
17:27:53 <mike1000> athan: I just want to do whatever is fastest for getting my very small one-user project, which depends on only two remotely installed libraries, compiled for profiling
17:27:53 <athan> Yeah sorry!
17:28:06 <lingxiao> mike1000 same use case here
17:28:11 <lingxiao> no all good man!
17:28:18 <athan> mike1000: Definitely learn stack too then :)
17:28:25 <lingxiao> ok i'll do that
17:28:28 <glguy> "cabal init" generates a best-guess at a .cabal file for your project
17:28:45 <glguy> asks questions along the way
17:28:47 <athan> and try making sandboxes to start playing with via `stack new` lingxiao & mike1000!
17:28:58 <athan> that too! ><
17:29:03 <glguy> You should understand .cabal files before worrying about sandboxes or stack
17:29:15 <glguy> it's a more fundamental concept
17:29:53 <mike1000> do I need to create a .cabal file in order to profile a small one-user project? this is what I'm not clear on. Or do I need to create one to create a sandbox?
17:30:27 <glguy> Yes, you need one
17:30:31 <glguy> and they're really easy to make
17:30:57 <ReinH> Do you *need* to? No. If you want to figure out how to get GHC to do you want by spending hours reading its manual and figuring out which arcane commands to use, you can do that instead.
17:31:00 <mike1000> Right now all my code is in one directory tree. Do I need to create a new directory tree for my source code? Or do I create a new directory for storying the profiling versions of my two remotely installed libraries?
17:31:48 <ReinH> You need a directory tree for your source code and you need to make sure that profiling is enabled for libraries.
17:32:14 <ReinH> Stack does this by default, iinm. With cabal you would need to modify your global or local config.
17:32:32 <mike1000> ReinH: do I need a *new* tree, separate from the original, to make a sandbox?
17:32:36 <ReinH> Personally I would recommend stack over the cabal exectuable, but either way you will need a .cabal file for your project
17:32:37 <ReinH> no
17:32:41 <mike1000> for the source code I mean?
17:32:45 <ReinH> no
17:33:19 <mike1000> so when I create a sandbox in a certain directory, is that where the profiling versions of my remotely installed libraries will go?
17:33:51 <lingxiao> so how does cabal init relate to stack?
17:33:54 <ReinH> you don't create a sandbox in a certain directory. You tell cabal to create a sandbox and it manages its own sandbox directory
17:34:00 <lingxiao> sorry I could jsut read but this seems to be faster ..
17:34:07 <ReinH> lingxiao: stack new
17:34:11 <lingxiao> that is let the noob question fly
17:34:20 <lingxiao> sorry so you're saying stack new == cabal init?
17:34:30 <ReinH> mike1000: if you use stack, you don't have to worry about sandboxes at all, stack will manage that for you
17:34:40 <ReinH> stack new is similar but not the same
17:35:00 <ReinH> I prefer it because it will create your new project directory structure and can be customized with templates
17:35:06 <ReinH> @google github stack-templates
17:35:07 <lambdabot> https://github.com/commercialhaskell/stack-templates
17:35:35 <mike1000> ReinH: is it easy to install stack on windows when I've been using cabal with the Haskell platform?
17:35:47 <ReinH> I haven't tried stack on windows
17:36:07 <ReinH> Some info appears to be here http://docs.haskellstack.org/en/stable/install_and_upgrade.html#windows
17:37:08 <mike1000> It seems like there is more documentation out there on cabal sandboxes. I don't know if switching to stack is worth it for a very small one-user project that I only need to profile occassionally
17:37:10 <lingxiao> yeah im on a mac and always have to rememer i dont have apt-get lol
17:37:51 <ReinH> mike1000: I think stack's documentation is better, so I'm not sure what you're seeing
17:38:08 <ReinH> My recommendation is to use stack, but you can use whatever you want
17:39:23 <lingxiao> any one havea  mac and see this error:
17:39:27 <dfeuer> Hallo, personages.
17:39:28 <lingxiao> Error: No available formula for haskell-stack 
17:39:28 <lingxiao> Searching formulae...
17:39:28 <lingxiao> Searching taps...
17:39:39 <mike1000> to use stack, should I first uninstall the haskell platform? I'm not clear on how to get from where I am now to using stack. A quick google search didn't find comments that directly address this
17:39:53 <lingxiao> does not conform to the error they say might happen with OSX
17:40:51 <mike1000> it looks I should probably uninstall the haskell platform and start over with stack
17:40:58 <mike1000> But that's a big step so I want to be sure
17:41:19 <ReinH> lingxiao: brew update ?
17:41:22 <xplat> stack doesn't really interfere with the haskell platform and vice versa
17:41:29 <xplat> you can perfectly well have both
17:41:30 <ReinH> mike1000: stack will ignore your existing packages
17:41:37 <ReinH> mike1000: I like it because it is self-contained
17:41:51 <mgsloan> Yup, the reason you find no docs for this is because it's a non-issue
17:42:03 <lingxiao> ReinH ok inprogress thanks!
17:42:04 <mike1000> ReinH: will installing stack also install a version of ghc?
17:42:05 <mgsloan> As much as possible stack tries to turn issues into non-issues :)
17:42:33 <ReinH> mike1000: stack can install its own ghc (with stack setup) or, if the system version is the correct version, it can try to use it
17:43:21 <Jesmaybe> setting up a haskell dev environment is really off putting. I have had so many issues. 
17:43:44 <ReinH> Jesmaybe: do you have any questions we can help you with?
17:43:48 <mike1000> So right now, when I run ghc it knows where to find the packages I installed with cabal. will it just switch over to using stack once I install stack?
17:44:22 <xplat> if you want to use stack's ghc you do 'stack ghc'.  or 'stack build' if you have a proper project set up
17:44:53 <ReinH> mike1000: no, you won't run ghc directly, you will use stack's command line interface
17:44:57 <ReinH> stack build, etc
17:45:11 <mike1000> how about ghci?
17:45:18 <xplat> 'stack ghci'
17:45:24 <Jesmaybe> ReinH: well, I am just trying to learn haskell, what is the easiest way to get up and runnig. I have wasted a LOT of time with vim and emacs. I am probibly shooting myself in the foot without even realizing it, haha
17:45:28 <ReinH> mike1000: many of these questions can be answered by reading the documentation, especially the quickstart guide.
17:45:59 <ReinH> Jesmaybe: Install stack, install a basic haskell mode (that provides, e.g., syntax highlighting and indentation), and work with your editor and a terminal window
17:46:00 <mike1000> Okay I'll go for it. I'll install stack and read the docs. 
17:46:17 <ReinH> mike1000: good luck, let us know if you have questions. I think you'll enjoy stack.
17:46:23 <lingxiao> uhh i see a list of stack templates
17:46:38 <chrisdotcode> What are phantom types isomorphic too? I recall reading about this somewhere, but I can't remember what the result was.
17:46:40 <ReinH> Jesmaybe: don't worry about fancy editor tooling, it's only a marginal improvement over having GHCi running in a nearby terminal.
17:46:48 <lingxiao> My directory should have  files: src, benchmark, and test. and maybe a main.hs at the top leve
17:46:51 <lingxiao> so which one iss that?
17:47:04 <ReinH> syntax highlighting and vim's autoindent mode are sufficient to write haskell
17:47:05 <xplat> chrisdotcode: it doesn't matter what phantom types are isomorphic to, since they're not used :)
17:47:29 <Jesmaybe> ReinH: basic haskell mode, can you recommend for vim? ok good to know
17:47:29 <ReinH> lingxiao: what sort of tests?
17:47:34 <chrisdotcode> xplat: Er, I mean, I thought there was another way to accomplish what phantom types accomplish.
17:47:35 <lingxiao> quickcheck
17:47:42 <lingxiao> and ad hoc unittests
17:47:57 <Jesmaybe> ReinH: does the stack documentation explain how to get haskell runnig with stack?
17:48:19 <xplat> there's a lot of things you can use phantom types for, i don't think there's one thing that does all of them
17:48:37 <lingxiao> and criterion for benchmark
17:49:10 <ReinH> Jesmaybe: http://github.com/lukerandall/haskellmode-vim is a good haskell mode, you might also try https://github.com/begriffs/haskell-vim-now for a pre-configured vim setup
17:49:18 <chrisdotcode> xplat: thanks; thought I read something contrary to that
17:49:24 <ReinH> Jesmaybe: http://docs.haskellstack.org/en/stable/README.html
17:49:43 <lingxiao> athan any thoughts?
17:50:12 <ReinH> lingxiao: I don't know of any that configure benchmarking. Here's the list https://github.com/commercialhaskell/stack-templates
17:50:20 <ReinH> maybe hspec or quickcheck-test-framework
17:50:54 <lingxiao> ReinH ok thanks i'll read into it
17:50:56 <lingxiao> !
17:51:21 <ReinH> lingxiao: it's easy to create your own template and add the necessary files for benchamrking
17:51:22 <Jesmaybe> ReinH: dude, you are the man. I tried haskell-vim-now. no go, haha. "don't worry about fancy editor tooling, it's only a marginal improvement over having GHCi running in a nearby terminal." that alone is gold. again appreciate it
17:51:57 <ReinH> Jesmaybe: yw
17:54:42 <lingxiao> ReinH ahh i see a directory is created
17:55:31 <lingxiao> so now i need a new directory benchmark that imports stuff from src
17:55:42 <lingxiao> do i add the dependency directly in Foo.cabal file?
17:55:54 <lingxiao> or i assume theres command line tools for that
17:57:10 <lingxiao> btw it's sad i cant cd around in ghci :(
17:57:20 <sunnymilk> :cd?
17:57:57 <MarcelineVQ> check out :h or :help for a handy list of things you can play with in ghci
17:58:37 <lingxiao> what? i seee this: cd <dir>                   change directory to <dir> 
17:58:52 <lingxiao> but when i do `cd ..` i get : parse error on input ‘..’
17:58:59 <athan> lingxiao: Wait what do you need?
17:59:04 <athan> You can
17:59:09 <athan> at least maybe you can haha
17:59:11 <MarcelineVQ> `:cd`
17:59:15 <lingxiao> athan i need to create a new dirctory benchmark
17:59:16 <athan> :! cd foo?
17:59:26 <athan> oh huh
17:59:40 <sunnymilk> :cd .. works on my machine
18:00:01 <lingxiao> yeah i dropped the :
18:00:17 <lingxiao> and files in bench mark need to import stuff from src
18:00:23 <lingxiao> benchmark and src are on the same level
18:01:41 <lingxiao> my question is can i link benchmark w/o writing some adhoc stuff in my Foo.cabal file
18:01:47 <lingxiao> ie a command line tool
18:03:03 <ReinH> lingxiao: I believe you add a benchmark section to the cabal file per usual and stack benchmark just runs it
18:03:27 <ReinH> the stuff in the cabal file is what makes it *not* ad hoc
18:06:08 <lingxiao> ReinH ahh i see, still trying to orient myself to the thought process
18:06:32 <lingxiao> so what exactly happen when I `stack build` it?
18:07:22 <lingxiao> so it reconciles all the dependencies among subdirectories i assume?
18:08:16 <Jesmaybe> does stack replace cabal or do they serve different purposes?
18:09:16 <lingxiao> also I'm using quickcheck-test-framework
18:09:21 <lingxiao> and i see there's an app and a src
18:09:35 <lingxiao> in src i'm given file Lib.hs
18:09:47 <lingxiao> I'm assuming Lib.hs is anything I want to export from src correct?
18:10:32 <lingxiao> also the category is web so i guess it's not quite what i wanted haha
18:11:04 <rvxi> hi
18:15:57 <mgsloan> lingxiao: Yeah, when you stack build it will recompile everything that needs to be rebuilt
18:16:18 <lingxiao> great thanks!
18:16:42 <mgsloan> Jesmaybe: Stack does replace the cabal executable for most purposes, but it still uses the "Cabal" library
18:17:22 <mgsloan> It turns out the most of the issues people have with cabal are really to do with particular decisions that "cabal-install" makes
18:23:45 <ReinH> mgsloan: o/
18:23:59 <ReinH> mgsloan: btw stack works really well for ghcjs
18:28:24 <drbean> I can't find a standard function to warn the user on standard error. Do I have to use import GHC.IO.Handle and do it myself?
18:29:47 * hackagebot servant-github 0.1.0.0 - Bindings to GitHub API using servant.  https://hackage.haskell.org/package/servant-github-0.1.0.0 (finlay)
18:30:00 <maerwald> it seems syntastic has stopped working with ghc-mod in vim, does anyone know a similar thing that shows me errors automatically on save, without opening new windows or typing commands?
18:31:21 <gamegoblin> @pl \x -> f (y x) x
18:31:21 <lambdabot> f =<< y
18:31:45 <gamegoblin> Can someone explain that point-free form to me?
18:31:52 <arkeet> :t (=<<)
18:31:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:31:59 <arkeet> now let m x = r -> x
18:32:12 <arkeet> (a -> r -> x) -> (r -> a) -> r -> x
18:32:16 <arkeet> hm
18:32:18 <arkeet> x is b.
18:33:38 <gamegoblin> The point-free form is super clever, but I think I’ll stick with pointed for clarity
18:33:54 <maerwald> pointfree is often pointless :P
18:34:09 <julianleviston> lol
18:37:55 <julianleviston> I have a tree data type… I’d like to have a (serialisable) data type that represents locations within this tree. Something like Lens springs to mind, except (AFAIK) writing Lens “locations” isn’t serialisable data, it’s function calls stacked together. Is there such a library?
18:38:38 <julianleviston> The “tree” is actually a data type that has maps of itself (that’s a simple explanation of it, anyway).
18:39:11 <gamegoblin> julianleviston: is it a sorted tree?
18:39:55 <julianleviston> gamegoblin: it’s a sum type that can also have a list or map of itself.
18:40:11 <julianleviston> gamegoblin: so… no :)
18:40:17 <gamegoblin> julianleviston: I’m having trouble understanding, can you paste some source code at lpaste?
18:40:26 <julianleviston> gamegoblin: no.
18:41:01 <julianleviston> gamegoblin: data Design = Design SchemaBlockID String DesignType TemplateID DesignArgsMap
18:41:07 <julianleviston> gamegoblin: that’s the type.
18:41:28 <ReinH> how is that a tree?
18:41:42 <julianleviston> gamegoblin: and you can assume DesignArgsMap is a map from String to Design
18:41:55 <julianleviston> ReinH: ^ like that.
18:42:04 <ReinH> You can always encode the arguments to a lens in a data type and then serialize that data type
18:42:15 <ReinH> when you reify it, you can then extract the arguments and apply them to the lens
18:42:28 <ReinH> or you can use some sort of path encoding
18:42:33 <julianleviston> ReinH: but the lens is the data I want to serialise. I’ve already got a strategy to serialise the data.
18:42:47 <ReinH> Why do you need to serialize the lens?
18:42:49 <ReinH> It doesn't change
18:42:52 <ReinH> it's based on the type, which is fixed
18:42:53 <gamegoblin> julianleviston: why not just serialize the list of Strings that arrive at your destination…?
18:43:20 <julianleviston> gamegoblin: because in actuality, it’s not just a map from String to Design. It can be a List o Design, as well.
18:43:22 <ReinH> gamegoblin: yes, that's basically what I meant by "path encoding"
18:43:27 * ReinH sighs
18:43:34 <julianleviston> ReinH: yeah, but I need to store the paths. That’s my question.
18:43:39 <gamegoblin> ReinH: I got you, I Just think julianleviston didn’t
18:43:41 <julianleviston> ReinH: I wanted to make it simple.
18:43:51 <julianleviston> gamegoblin: you might be right.
18:43:52 <ReinH> So do that then.
18:44:00 <julianleviston> ReinH: that’s what I don’t know how to do.
18:44:04 <gamegoblin> julianleviston: so instead of just strings, it can be a String or an Int (index in the list)
18:44:12 <julianleviston> ReinH: how can I serialise the paths?
18:44:31 <gamegoblin> data Link = LinkString String | LinkInt Int
18:44:32 <ReinH> You can serialize a list of strings, or a list of (String, Int) pairs, or whatever makes up your path
18:44:34 <julianleviston> gamegoblin: ah, so create some kind of path type?
18:44:38 <gamegoblin> type Path = [Link]
18:44:57 <ReinH> gamegoblin: it can't be either a string or an int, it has to be structured, like a string and then an int
18:45:01 <ReinH> thus the pairs
18:45:14 <ReinH> unless the data type is either a map or a list
18:45:17 <julianleviston> ReinH: I don’t see how.
18:45:21 <julianleviston> ReinH: why pairs?
18:45:24 <gamegoblin> ReinH: Ah, I’d misinterpreted his design. I thought some of the things were String -> Design maps and some were [Design] lists
18:45:30 <ReinH> gamegoblin: maybe I am too
18:45:40 <ReinH> Well, I don't know what your paths look like
18:45:42 <julianleviston> ReinH: gamegoblin is correct.
18:45:49 <ReinH> if they look like ["foo", 1, 2, "bar"]
18:45:53 <julianleviston> ReinH:  yeah, your suggestions was what I was after. thanks!
18:45:57 <ReinH> serialize [Either String Int]
18:45:57 <gamegoblin> julianleviston: then make a String and Int sum type and that’s a step in your path
18:46:06 <julianleviston> gamegoblin: yeah, I got it.
18:46:39 <julianleviston> so, basically, build a new sum type that represents the path into the data type… where arrays use Int, and Maps use (whatever the k of the map datatype is)… right?
18:46:54 <gamegoblin> julianleviston: exactly
18:47:08 <julianleviston> thanks. That was exactly what I was after, and didn’t think of doing. I just thought there might be a nice way to do it already a-la lens, but with serialisable types. All good.
18:48:37 <julianleviston> … because I want to build a path to every single point on a tree of data (whose shape isn’t known in advance). Sweet. :) Thanks peoples.
18:50:35 <emmanuel`> reinH, based on your example, (data Link = LinkString String | LinkInt Int), this data type can be used in applicative conetxt, right? E.g. [LinkString,LinkInt] <*> ["ab",4]
18:50:49 <emmanuel`> Is there a way to enable that?
18:51:34 <ReinH> well, that would work with ZipList
18:51:36 <ReinH> not with []
18:51:42 <ReinH> wait no it wouldn't
18:51:49 <ReinH> because you can't have a heterogeneous list
18:51:54 <ReinH> so no
18:52:04 <emmanuel`> ok, just checking! Thanks!
18:56:18 <anks> after update to ghc-7.10.3 i've ran into a problem with ghc-mod:
18:56:25 <anks> cannot satisfy -package-id array-0.5.1.0-d4206b835b96b5079d918fa1eab1a9a8
18:56:26 <anks>  
18:57:22 <anks> ghc-mod is built with 7.10.3, and so are project's dependencies
19:00:18 * hackagebot servant-github 0.1.0.1 - Bindings to GitHub API using servant.  https://hackage.haskell.org/package/servant-github-0.1.0.1 (finlay)
19:05:18 * hackagebot projectroot 0.1.0.0 - Bindings to the projectroot C logic  https://hackage.haskell.org/package/projectroot-0.1.0.0 (yamadapc)
19:10:18 * hackagebot projectroot 0.1.0.1 - Bindings to the projectroot C logic  https://hackage.haskell.org/package/projectroot-0.1.0.1 (yamadapc)
19:30:23 * hackagebot canteven-listen-http 0.1.0.0 - data types to describe HTTP services  https://hackage.haskell.org/package/canteven-listen-http-0.1.0.0 (glasserc)
19:30:25 * hackagebot servant-github 0.1.0.2 - Bindings to GitHub API using servant.  https://hackage.haskell.org/package/servant-github-0.1.0.2 (finlay)
19:35:23 * hackagebot cached-io 0.1.1.0 - A simple library to cache a single IO action with timeout  https://hackage.haskell.org/package/cached-io-0.1.1.0 (glasserc)
19:39:48 <ontop> Anyone feel like debugging a stack overflow: http://lpaste.net/5581815080716075008 solution to: http://adventofcode.com/day/6
19:39:56 <ontop> The code looks so correct to me :( What's going on
19:40:53 <Axman6> any chance you want to learn how to use parsers to make your life a lot easier? =)
19:41:08 <julianleviston> ontop: what is the error?
19:41:13 <ontop> Axman6: Kinda yeah.
19:41:28 <ontop> julianleviston: Let me run it again to get the exact right thing.
19:41:59 <Axman6> your use of trace is crazy and really confused me :P
19:42:10 <ontop> *** Exception: stack overflow
19:42:15 <ontop> Axman6: How do other people use it?
19:42:30 <ontop> I mean, I read other people's Haskell code and think: WTF, so maybe I'm totally using this language backwards.
19:42:30 <ontop> lmao.
19:42:54 <julianleviston> what is trace?
19:42:56 <ontop> julianleviston: Sorry "*** Exception: stack overflow" is exactly what prints out.
19:43:04 <Axman6> I was surprised it worked, but then it made sense. I just haven't seen anyone use it like that, it's pretty cool =)
19:43:09 <julianleviston> :t trace
19:43:11 <lambdabot> Not in scope: ‘trace’
19:43:13 <ontop> Trace is a debugging function, it's meant to output the string and then return the 2nd value.
19:43:18 <ontop> It's pretty cool. Comes from Debug.Trace
19:43:36 <julianleviston> how can it do that if it’s not in IO?
19:43:40 <ontop> FWIW I added it to see what's wrong, it doesn't cause the issue :|
19:43:51 <ontop> julianleviston: Great question. I'm new to Haskell so I'm not sure? ^_^
19:44:01 <julianleviston> Axman6: do you know?
19:44:10 <Axman6> ontop: try adding {-# LANGUAGE BangPatterns #-} at the top of your file, and changing: visit (s:xs) set to visit (s:xs) !set
19:44:12 <ontop> I just google'd around looking for debuggers and stuff and found the function.
19:44:26 <Axman6> julianleviston: it's a hack that uses unsafePerformIO
19:44:37 <julianleviston> Axman6: {{shudder}} ok.
19:44:39 <Axman6> should not be used in production, only for debugging
19:45:08 <Axman6> it's literally: trace str x = unsafePerformIO $ do {putStrLn str; return x}
19:45:27 <jle`> you can sort of imagine it as a part of GHC's evaluation mechanism and implemented w/out unsafePerformIO
19:45:43 <Axman6> yeah...
19:45:52 <julianleviston> ontop: so have you tried pulling the parts apart to make sure it works still?
19:45:57 <ontop> Axman6: Did that and now it's complaining about a parse error on |
19:46:03 <jle`> you can say that GHC provides a primitive that lets you tag a value to emit a string to stdout when it gets evaluated
19:46:15 <ontop> julianleviston: If I run this with a normal input (one I hand-craft instead of their input file) it doesn't stack overflow, it works perfectly :(
19:46:27 <Axman6> ontop: I'm 80% sure you're building up a huge thunk in the set value which is overflowing when you evaluate the set
19:46:37 <julianleviston> ontop: does “lines content” work on their data?
19:46:48 <Axman6> ontop: what does the code look like now?
19:46:51 <ontop> julianleviston: Yes. I've printed the data.
19:46:53 <julianleviston> Axman6: ah… cool. I’ll butt out.
19:47:23 <Axman6> also, you can just use readFile to open a file like you're doing ontop 
19:47:30 <Axman6> :t readFile
19:47:32 <lambdabot> FilePath -> IO String
19:47:50 <ontop> Axman6: http://lpaste.net/5581815080716075008
19:48:00 <Axman6> though... the way you're using it means things should be closed properly =)
19:48:12 <Axman6> ontop: !set not set!
19:48:13 <ontop> I thought I was closing it properly :(
19:48:19 <ontop> Oh.
19:48:22 <julianleviston> ontop:  you are.
19:48:38 <Axman6> yeah what you're doing is fine, but for apps like this it's usually ok to just use readFile
19:48:48 <ontop> Axman6: Wow, it runs at the speed of smell now.
19:48:50 <glguy> Generally it's wrong to hClose something after using hGetContents on it
19:48:51 <ontop> Running currently.
19:49:09 <ontop> glguy: Omg, you're my hero!
19:49:18 <ontop> I saw you on advent of code, I even saw your code for this problem
19:49:21 <Axman6> ontop: is the speed of smell good? =)
19:49:23 <ontop> And thought: What the hell is a mutarray?
19:49:40 <Axman6> a mutable array I would guess
19:49:42 <glguy> ontop: Your solution runs well enough if you add strictness to the "set" argument of "visit"
19:49:45 <ontop> Axman6: Well, it finished.
19:49:48 <julianleviston> glguy: I thought hGetContents was lazy?
19:49:59 <ontop> glguy: What's strictness? I'm so new it hurts :(
19:50:01 <glguy> julianleviston: Yup, and that's why it's wrong to hClose afterward
19:50:09 <julianleviston> glguy: I don’t get that.
19:50:11 <Axman6> julianleviston: it is, and will close the handle when it reaches the end/the contents get garbage collected
19:50:31 <ontop> Axman6: My code is right, you have no idea how happy I am. Thank you! Now can you explain what the heck I just did? :D
19:50:50 <julianleviston> ok.
19:51:05 <glguy> julianleviston: once you hGetContents a Handle you've given it away to the pure world, it's not yours to close any more
19:51:18 <ontop> glguy: What's the proper way to do it then?
19:51:20 <julianleviston> I don’t understand that.
19:51:21 <glguy> it'll be closed when the pure code gets to the end or doesn't need it any more
19:51:24 <julianleviston> ontop: not to close it.
19:51:27 <ontop> Oh really??
19:51:34 <julianleviston> ontop: that’s what they’re saying.
19:51:34 <Axman6> ontop: the changes you were making to the set value weren't bei9ng executed until you tried to print things, so it will building up a huge structure which is basically a promise to actually perform the work when needed
19:51:52 <ontop> That's kinda cool.
19:51:55 <ontop> Because haskell is so lazy?
19:51:58 <Axman6> yep
19:52:04 <ontop> And so, what the hell is a BangPattern.
19:52:06 <Axman6> that's laziness in action
19:52:14 <Axman6> it causes the set to be evaluated*
19:52:41 <ontop> On each call to visit?
19:52:49 <julianleviston> So does this mean that Real World Haskell is wrong here? (Extended Example: Functional I/O and Temporary Files) : http://book.realworldhaskell.org/read/io.html
19:53:39 <ontop> glguy: Can you explain why your solution to this same problem is superior?
19:53:58 <julianleviston> or is it not because it’s not pure?
19:54:03 <glguy> julianleviston: Yeah, basically
19:54:07 <julianleviston> ah ok.
19:54:09 <ontop> https://github.com/glguy/advent2015/blob/master/Day6.hs This one I think?
19:54:14 <julianleviston> Interesting.
19:54:30 <julianleviston> glguy: will GHC warn you of this? This feels tricky to track in my brain.
19:54:47 <glguy> julianleviston: you can close the handle early, but you're ruining the pure illusion. Depending on the vresion of GHC you'll get an exception if you try to use the pure value after that
19:54:59 <glguy> or you'll get an empty string at some point reading it
19:55:13 <julianleviston> glguy: no, talking about closing it after.
19:55:27 <glguy> yeah, if you close it after running hGetContents that's what happens
19:55:47 <julianleviston> glguy: what happens?
19:55:55 <glguy> surprises <- hGetContents h; hClose h; use surprises
19:55:57 <julianleviston> glguy: if you close it after hGetContents, it closes the file early?
19:56:06 <julianleviston> but that’s not what he does.
19:56:14 <julianleviston> (/did)
19:56:15 <julianleviston> right?
19:56:22 <glguy> and it's easy to use that lazy string after closing it, because of laziness
19:56:24 <ontop> Axman6: What's a parser? You said you wanted to make my life easier lol.
19:56:25 <julianleviston> That’s not what we’re talking about… we’re talking about closing it after.
19:56:34 <glguy> julianleviston: "after" is fuzzy with lazy eval
19:56:38 <glguy> julianleviston: and in this case it was already closed
19:56:44 <julianleviston> Axman6: it’s something that can take pieces of text and interpret them into things…
19:56:47 <glguy> so it was still unnecessary
19:56:54 <Axman6> ontop: you know what a regex is? it's like that, but not shit, is maintainable and readable.
19:57:00 <julianleviston> glguy: yes, but will GHC warn you that it’s unnecessary (was my question)
19:57:06 <ontop> I'm sold. How2do?
19:57:09 <glguy> julianleviston: nope
19:57:24 <julianleviston> ontop: (Parsers are not trivial, by the way).
19:57:31 <ontop> Is this a parser? https://github.com/glguy/advent2015/blob/master/Day6.hs#L66
19:57:33 <glguy> ontop: My solution uses a mutable array because that seemed easiest/fastest to me 
19:57:55 <glguy> ontop: all of my "parsing" happens in that "parseLine" function, it's not much of a parser
19:58:12 <glguy> It just pattern matches on the words of a line of input
19:58:31 <glguy> > words "like these words for example"
19:58:33 <lambdabot>  ["like","these","words","for","example"]
19:58:39 <ontop> glguy: I didn't know how to use an array in Haskell. And when I looked at your solution it seemed harder to use.
19:58:46 <ontop> Like runST
19:58:53 <ontop> Hoogling that, brought me into a world of pain.
19:59:01 <glguy> ontop: you don't have to use ST, you can use IO
19:59:07 <glguy> if you're more familiar with that
19:59:31 <ontop> I feel like learnyouahaskell.com didn't prepare me for ST.
19:59:36 <Axman6> ontop: there's some good links discussing parsec, the best known haskell parser library here: haskell parsers
19:59:40 <Axman6> bleh
19:59:47 <Axman6> https://wiki.haskell.org/Parsec
19:59:55 <glguy> You can use: Data.Array.IO instead of Data.Array.ST and the code looks the same except there's no ST (in this case)
19:59:56 <julianleviston> ontop: learnyou is very good for learning how to read rudimentary haskell. That’s all. It’s not great to teach you how to write it.
20:00:05 <ontop> julianleviston: Feels that way.
20:00:11 <ontop> As evidenced by my code.
20:00:13 <ontop> lol.
20:00:17 <julianleviston> ontop: it’s also pretty basic. But that’s it’s function - an introduction.
20:00:41 <glguy> ontop: "ST s" is a subset of IO, stuff that can be contained
20:00:59 <ontop> glguy: Does that mean it's "pure"?
20:01:08 <glguy> It means that it looks pure from the outside
20:01:20 <ontop> I see.
20:01:21 <glguy> where the boundary of "outside" is that runST application
20:01:29 <ontop> Neat.
20:01:45 <ontop> glguy: Does your solution run in seconds? Mine took seconds :(
20:02:15 <glguy> user0m0.674s
20:03:07 <glguy> your solution on my computer with a bit of strictness added as mentioned above took 10 seconds
20:03:18 <ontop> 10s? On mine it took like 40. lol
20:03:24 <ontop> (On Windows atm tho)
20:03:31 <ontop> Mingw haskell probably sucks.
20:03:41 <glguy> it shouldn't matter much
20:04:32 <ontop> glguy: You're the only reason I could figure out how to MD5 something in Haskell. The bytestring/word8/string thing nearly killed me. That's why you're my hero.
20:04:53 <ontop> Even when I got a solution in the end, it was so gross and went through like 3 pack/unpacks.
20:05:23 <julianleviston> string/text/etc manipulation *does* seem rather crazy in Haskell at first, doesn’t it.
20:06:09 <ontop> julianleviston: The different string types make me sad.
20:06:13 <julianleviston> ontop: hehe in the app I’m writing at the moment I use helper functions to encodeUtf8 and Text unpack/pack and funtimes ByteString things all over the shop. I often wonder if it’s right.
20:07:02 <ontop> I come from Go/Ruby where UTF-8/bytes just happens and you don't even think about it.
20:07:34 <julianleviston> ontop: in Ruby, strings are the biggest sources of memory issues there are.
20:07:55 <julianleviston> ontop: there are some downsides to magic, I suppose.
20:07:56 <ontop> I think if you're using Ruby, you're not worried about memory issues lol.
20:08:05 <julianleviston> ontop: or any other issues.
20:08:26 <ontop> I still love Ruby for certain things. It has it's place but I've been Go for 3 years now.
20:08:45 <ontop> I'm trying Haskell because I need to know about functional as a programmer.
20:08:45 <julianleviston> ontop: oh, what made you haskell?
20:08:52 <julianleviston> ontop: go isn’t functional?
20:08:56 <ontop> It's something everyone should experience.
20:08:56 <julianleviston> ontop: is it OOP?
20:09:10 <ontop> Go's imperative. Not OOP. Composition > Inheritance.
20:09:22 <julianleviston> ontop: I’m pretty convinced FP is the right abstraction mechanism for most programming we do day to day.
20:09:25 <ontop> It's type system is somewhat akin to Haskell Typeclasses.
20:09:35 <lingxiao> hey all
20:09:37 <ontop> And it's nice :)
20:09:39 <julianleviston> ontop: imperative isn’t orthogonal to OOP, is it?
20:09:52 <lingxiao> so im using stack for the first time
20:10:09 <julianleviston> ontop: typeclasses are not types tho… 
20:10:20 <julianleviston> ontop: is orthogonal*
20:10:23 <lingxiao> and I did Stack new Foo quickcheck-test-framework
20:10:24 <dibblego> is there a Data.Binary combinator to assert end of the stream? Similar to eof in parsec
20:10:24 * hackagebot canteven-template 0.1.0.0 - A few utilites and helpers for using Template Haskell in your projects.  https://hackage.haskell.org/package/canteven-template-0.1.0.0 (glasserc)
20:10:26 * hackagebot plot-gtk 0.2.0.4 - GTK plots and interaction with GHCi  https://hackage.haskell.org/package/plot-gtk-0.2.0.4 (VivianMcPhail)
20:10:36 <dibblego> crikey wot'd I walk into
20:10:49 <ontop> No, but what I mean is in Go, an interface (typeclass?) is satisfied just by the ability to be satisified.
20:10:55 <ontop> And it was a bit reminiscent.
20:11:02 <ontop> And imperative can be OOP or not.
20:11:13 <lingxiao> as i understand everything in my test directory can load stuff from src correct?
20:11:13 <julianleviston> ontop: most OOP is imperative.
20:11:17 <ontop> That's true.
20:11:19 <glguy_> Dibblego: check isEmpty
20:11:29 <dibblego> glguy_: ok thanks
20:11:31 <julianleviston> lindenk: yeah, I think so...
20:11:33 <lingxiao> heres my .cabal file
20:11:33 <lingxiao> http://lpaste.net/147106
20:11:48 <julianleviston> lingxiao: I think so. It depends on the way it’s set up, but by default yeah
20:11:48 <lingxiao> but i cant do that actually, so test/Foo.hs cannot import src/Core.hs
20:12:00 <lingxiao> i also did stack build 
20:12:04 <lingxiao> but to no avail
20:12:25 <mgsloan> lingxiao: Did you add Core to the list of "exposed-modules"?
20:13:08 <julianleviston> lingxiao: yeah, what mgloan said… by default you just get Lib.
20:13:50 <lingxiao> ok so under Library in .cabal i now have:
20:13:51 <lingxiao>   exposed-modules:     Lib,Core
20:14:20 <lingxiao> wait that aint right right?
20:14:27 <lingxiao> it certainly stack builds
20:14:30 <lingxiao> but still getting the error
20:14:43 <julianleviston> lingxiao: how are you importing it?
20:14:50 <lingxiao> import Core
20:14:54 <julianleviston> oh. 
20:14:57 <lingxiao> yeah ..
20:15:06 <julianleviston> do you have a Core module?
20:15:31 <lingxiao> yeah it's module Core where ... in src/Core.hs
20:16:24 <lingxiao> also my core.hs imports a bunch of files, ie: http://lpaste.net/147107
20:16:35 <lingxiao> and when i do stack build i'm getting ie: Could not find module ‘System.Random’
20:16:49 <julianleviston> do you have it in your imports in cabal file?
20:16:53 <lingxiao> i assume i need to edit .cabal file
20:17:02 <lingxiao> System.Random etc? no i dont
20:17:04 <lingxiao> not sure where to put it
20:17:15 <lingxiao> see i have an example too: https://github.com/athanclark/timemap/blob/master/timemap.cabal#L58
20:17:18 <julianleviston> you need the package name not the module name
20:17:26 <julianleviston> it goes in build-depends
20:17:39 <lingxiao> sorry are we talking about System.random or core
20:17:41 <julianleviston> random-1.1
20:17:50 <julianleviston> lingxiao: you’re talking about 4 things at once.
20:17:58 <lingxiao> lol sorry :(
20:18:05 <lingxiao> my mood is such ... 
20:18:08 <julianleviston> lingxiao: I’m talking about the error you’re having when you compile… which is that random is missing from your cabal file.
20:18:09 <lingxiao> so ok one at a time ..
20:18:15 <julianleviston> lingxiao: :) whatever works for you.
20:18:16 <lingxiao> ah ok i'll fix it now
20:18:25 <julianleviston> you’ll need to add the others, too.
20:18:35 <julianleviston> you have a lot of imports in there that aren’t in your cabal file. 
20:19:03 <julianleviston> I *think* (anyone correct me if I’m wrong) you’ll need it in the test section as well as the library and executable section
20:19:30 <lingxiao> yeah that was my next question haha
20:20:03 <julianleviston> but I might be wrong here… it might be that they’re only needed if your test code requires those modules.
20:20:42 <lingxiao> now it's funny because this is not working: http://lpaste.net/147108
20:21:02 <lingxiao> you see uner library  build-depends i have added random-1.1
20:21:29 <lingxiao> again im just following the syntax of the file given 
20:22:40 <lingxiao> i get error message: Unable to parse cabal file /Users/lingxiao/Documents/Projects/CIS700/CIS700.cabal: NoParse "build-depends" 19
20:23:09 <KaneTW> invalid syntax
20:23:14 <KaneTW> , random == 1.1
20:23:23 <KaneTW> or whatever you want
20:24:33 <lingxiao> so ` == ` between package name and package version
20:26:58 <lingxiao> julianleviston could i ask you about core.hs again?
20:27:00 <lingxiao> :)
20:27:03 <julianleviston> lingxiao: sorry for giving you wrong information.
20:27:09 <julianleviston> lingxiao: I thought it was correct.
20:27:11 <lingxiao> oh no it's all good
20:27:18 <lingxiao> thats what i see in the exfample given too
20:27:25 <lingxiao> also their library is Library ... so there's that
20:27:59 <mgsloan> cabal is case-insensitive for its field names
20:28:01 <lingxiao> ok wait  a sandbox is being built here right?
20:28:06 <lingxiao> mgsloan aghh didnt know that
20:28:31 <lingxiao> so if i cabal update outside of my project directory it doesnt affect whats in the direcotry?
20:29:17 <lingxiao> ok uhoh this problem occured for Data.random
20:29:30 <lingxiao> i did  , random-fu == 0.2.1.0              since thats what i seee in hackage
20:29:38 <lingxiao> and i see: 
20:29:40 <lingxiao> --  Failure when adding dependencies:    
20:29:40 <lingxiao>       random-fu: needed (==0.2.1.0), 0.2.6.2 found (latest applicable is 0.2.1.0)
20:29:42 <lingxiao>     needed for package: CIS700-0.1.0.0
20:30:07 <julianleviston> you don’t have to specify a version, if you don’t want. you can just write random-fu and stack will work it out.
20:30:17 <lingxiao> i mean i fixed it when i changed to , random-fu == 0.2.6.2
20:30:52 <julianleviston> cabal/stack*
20:31:11 <lingxiao> hmm.. so suppose i dont then stack always grab the latest then?
20:31:36 <lingxiao>  and suppose i dont have the latest, is it somehow cabal updating in the project sandbox?
20:31:44 <lingxiao> sorry .. have absolutely no mental model of what stack does
20:31:59 <sm> the docs are pretty good
20:32:19 <julianleviston> lingxiao: it manages the dependencies and sandboxes projects.
20:34:21 <julianleviston> lingxiao: it also makes it a bit easier to manage your projects, and keeps named sets of packages that work together…and suck.
20:34:23 <julianleviston> such*
20:35:06 <lingxiao> ahh so if i want stuff in test to depend on stuff in src, ie src/Core.hs,    i need to add , core to build-depends right?
20:35:39 <julianleviston> um… I don’t think so.
20:35:49 <julianleviston> but what do I know.
20:35:49 <lingxiao> but in build-depends it says , CIS700 which is my project folder
20:35:56 <lingxiao> lol more than me!
20:36:26 <lingxiao> ok so i do :l test/TCore.hs and i get messge could not find module Core
20:36:42 <lingxiao> so either im importing it wrong or the dependencey is not being expressed in .cabal
20:37:44 <lingxiao> :(
20:39:10 <mgsloan> Yes, CIS700 needs to be in your test's build-depends, if "src" is not in the test's list of include folders
20:39:22 <bitemyapp> CIS700?
20:39:26 <bitemyapp> has the world leapt beyond me?
20:39:40 <lingxiao> yeah you know 7 years to get thru college is stanard now
20:39:44 <lingxiao> standard*
20:39:55 <bitemyapp> lingxiao: are you going to UPenn?
20:40:04 <lingxiao> yeah
20:40:09 <bitemyapp> lingxiao: I was at Hac-Phi
20:40:13 <bitemyapp> lingxiao: were you?
20:40:20 <lingxiao> yeah i was tall asian guy?
20:40:33 <bitemyapp> lingxiao: you were with me when I helped the student right?
20:40:42 <lingxiao> oh yeah we sat and talked in that room?
20:40:46 <bitemyapp> lingxiao: yep, hi!
20:40:51 <lingxiao> yeah he just demoed his project today haha
20:40:58 <bitemyapp> lingxiao: nice "seeing" you :)
20:41:08 <lingxiao> embarrasing that im supposed to be teaching this stuff but can't do the basics
20:41:11 <bitemyapp> lingxiao: ah, how did that go? He emailed me a week or two ago.
20:41:17 * bitemyapp shrugs
20:41:17 <lingxiao> or havea  desire to read the manual lol
20:41:24 <bitemyapp> some people don't think I should be teaching either :P
20:41:26 <lingxiao> he did alright! 
20:41:29 <bitemyapp> good.
20:41:30 <lingxiao> lol you teach fine
20:41:39 <lingxiao> one class did a DSL for making drum beats
20:41:40 <lingxiao> that was cool
20:41:49 <lingxiao> and they played some ice cube
20:41:53 <lingxiao> which was neat
20:42:14 <bitemyapp> wow, that's a pretty cool idea.
20:42:22 <bitemyapp> I know there's music kit for Haskell but haven't tried any of it.
20:42:27 <lingxiao> yeah apparently someone else has done it .. yeah that 
20:42:35 <lingxiao> me neither since im not musically inclined :(
20:43:39 <lingxiao> but yeah man it's good to see you too!
20:43:42 <julianleviston> “live code” is a way to make music “live” in a Repl with music stuffs.
20:43:56 <lingxiao> i see you here all the time but never connected the name to face
20:44:11 <lingxiao> that's awesome so you can jam live right?
20:44:14 <julianleviston> it’s also what people call coding live. meh.
20:44:25 <lingxiao> lol who needs that
20:44:32 <julianleviston> it SOUNDS awesome. In my experience, it’s less than stellar.
20:44:36 <lingxiao> ok so here's my .cabal file: http://lpaste.net/147110
20:44:46 <julianleviston> (IMO it’s because they can’t get the abstraction levels right, but all good)
20:44:51 <lingxiao> ok how come? people just write stuff like ... ... 7 ... .. 8
20:44:52 <lingxiao> right?
20:45:09 <lingxiao> oh ... see i know nothing about it since i dont do music .. which i regret
20:45:27 <bitemyapp> lingxiao: something like that. I think there's multiple ways to do it.
20:45:29 <lingxiao> i have , CIS700 and , src in build-depends in test_suite ... but still no imort
20:45:39 <bitemyapp> lingxiao: definitely stuff like drum loops will be simpler than a full music notation bar
20:45:46 <lingxiao> ** still error for import **
20:45:48 <bitemyapp> end up being a bit like FL Studio
20:45:48 <julianleviston> lingxiao: music has stayed too long with the abstraction ideas of “lines of voices” as the standard unit of measure. Computer music introduced patterns, but doesn’t allow their composition. It’s not so great.
20:45:50 <bitemyapp> but text
20:46:02 <lingxiao> *nods*
20:46:33 <lingxiao> see if brent was here he'd know
20:46:39 <lingxiao> hes great with haskell and plays jazz
20:46:42 <bitemyapp> lingxiao: he is here
20:46:47 <lingxiao> right now?
20:46:50 <bitemyapp> whether he'll respond if I highlight him is another matter
20:46:51 <bitemyapp> yeah
20:46:54 <bitemyapp> b yorgey
20:46:56 <bitemyapp> without the space
20:47:03 <lingxiao> yeah i see him once in a long while
20:47:10 <bitemyapp> although his last name is pretty singular so he might have a highlight set for that.
20:47:15 <julianleviston> most musicians are locked within a certain mental paradigm with music. It’s annoying.
20:47:18 <bitemyapp> I know I can trip Ed's thing by mentioning his favorite topics.
20:47:25 <bitemyapp> like saying "Bloody Mary" three times, but for comonads.
20:47:30 <julianleviston> LOL
20:47:34 <julianleviston> bitemyapp: that’s hilarious :)
20:47:59 <lingxiao> julianleviston turns out i dont have to specify dependenies for things like random and random-fu in test/Foo.hs
20:48:07 <lingxiao> since thery're already spcified in library i guess
20:48:14 <julianleviston> lingxiao: handy.
20:48:36 <lingxiao> he also likes contravariant functor
20:48:42 <lingxiao> yeah that makes a lot of sense
20:48:49 <julianleviston> bitemyapp: maybe we could teach lambdabot to remember everyone’s invocation “spell” and then invoke it with a general invoke command. lol
20:48:54 <lingxiao> and pointed
20:49:09 <lingxiao> lol that'd be nice a bot with sas
20:49:12 <lingxiao> sass*
20:49:22 <bitemyapp> julianleviston: that's doable
20:49:57 <julianleviston> I think it’d be hilarious. Engineering a solution to something that is already an engineering solution. LoL. 
20:50:19 <lingxiao> hahaha
20:51:07 <julianleviston> Reminds me of those stupid anti-ad blocker ads. I look at them and end up feeling very sad that our collective computational energy is being used for such things.
20:52:20 <lingxiao> i had a discussion with a phd student today that everything in the world is shit
20:52:24 <bitemyapp> @where+ invokebitemyapp bear puppy papuchon chris bitemyapp
20:52:24 <lambdabot> I will remember.
20:52:29 <lingxiao> he shook my hand and said i have reached the age of wisdom
20:52:31 <bitemyapp> @where invokebitemyapp
20:52:32 <lambdabot> bear puppy papuchon chris bitemyapp
20:52:38 <bitemyapp> that sorta thing.
20:52:54 <bitemyapp> now you just need to figure out what he tracks. I won't tell though :P
20:53:47 <bitemyapp> lingxiao: what inspired the comment?
20:53:49 <julianleviston> lingxiao: everything in the world is simultaneously perfect and shit.
20:54:07 <lingxiao> when julianlevison said: I think it’d be hilarious. Engineering a solution to something that is already an engineering solution. LoL.
20:54:31 <lingxiao> yeah gotta see the beauty in things that arent meant to be beautiful, as american beauty so eloqutely tell us
20:54:34 <julianleviston> lingxiao: I think he meant what inspired the PHD convo comment
20:54:58 <lingxiao> oh we were saying that working in a captialist society is about exchanging life for money, no matter where you go
20:55:04 <julianleviston> eloqute: (definition) eloquent and cute at the same time.
20:55:17 <lingxiao> lol yes thats so fetch
20:55:31 <julianleviston> stop trying to make fetch a thing, gretchen.
20:55:33 <lingxiao> ie google and facebook are ad companies
20:55:37 <lingxiao> LOL i cracked
20:55:50 <julianleviston> I love that I’ve been doing Haskell for what feels like ages, and I’ve only JUST had need to use a typeclass now.
20:57:09 <lingxiao> like decalre a new one or make an instance of one or use an existing instance of one?
20:57:35 <julianleviston> lingxiao: sorry, precision of language “make a new one” :)
20:57:48 <bitemyapp> julianleviston: that's a good sign really.
20:57:53 <lingxiao> oh yeah same here, most of what i need is already given
20:57:59 <lingxiao> or i have poor imagination
20:58:00 <bitemyapp> julianleviston: people that go out of their way to putz around with typeclasses early on are usually getting distracted.
20:58:02 <lingxiao> probbly the latter
20:58:16 <julianleviston> bitemyapp: mostly, functions are just fine, too :)
20:58:26 <lingxiao> yeah i find a good few "basic notions" of functiosn suffice
20:58:31 <lingxiao> yup 
21:01:02 <lingxiao> ok last question before i hit the rack .. this is the current state of my .cabal file:
21:01:03 <lingxiao> http://lpaste.net/147110
21:01:12 <lingxiao> see i've added , src and it's still not working
21:01:43 <lingxiao> now i look at src/Lib.hs and should i be exporting src/Core.hs from there as well?
21:02:30 <julianleviston> lingxiao: can you say a bit more about what you mean when you say “it’s still not working” ?
21:02:47 <lingxiao> sorry when i load   test/TCore.hs  which `import Core`  
21:02:59 <lingxiao> i'm getting error message: Could not find module ‘Core’ 
21:04:19 <julianleviston> lingxiao: just curious… not sure if this is best… if you appent “,src” to hs-source-dirs: does that fix your immediate issue?
21:04:38 <julianleviston> (in the test-suite section)
21:05:02 <julianleviston> or is that crazy?
21:05:19 <julianleviston> please take my advice with a grain of salt here. I’m only giving it because no one better qualified seems to be.
21:05:34 <julianleviston> appent=append*
21:05:52 <lingxiao> no it's all good, at this hour getting it to work working is not crazy i'll pay what ever price toorrow
21:05:54 <julianleviston> the best would be if you read the documentation.
21:06:08 <lingxiao> so wait i have:      hs-source-dirs : test, src
21:06:15 <julianleviston> yeah
21:06:15 <lingxiao> but still no luck 
21:06:18 <julianleviston> ah ok.
21:06:19 <julianleviston> damn.
21:06:32 <lingxiao> it certainly `stack build`s
21:06:33 <julianleviston> that’s a bit odd. Your file is called Core.hs (capitalised) right?
21:06:47 <lingxiao> yeah .. and i have module Core (...) where ..
21:07:03 <julianleviston> why have you got “src” in build-depends??!
21:07:30 <julianleviston> how is that working?
21:07:49 <julianleviston> I don’t understand why that doesn’t error before it gets to the import.
21:08:33 <lingxiao> sorry you mean in test-suite ?
21:08:58 <lingxiao> so you're saying wrong syntax right?
21:08:59 <julianleviston> when you run your tests.
21:09:23 <julianleviston> No, I’m wondering what it is… in build-depends, in test-suite, you have an entry called “src”. What is that?
21:09:49 <lingxiao> i suppose i meant that folder, which makes no sense .. 
21:09:51 <julianleviston> and… why doesn’t it error before it gets to running your code… unless there’s some package I don’t know about called src?
21:09:57 <julianleviston> lingxiao: ok that’s wrong then
21:10:06 <lingxiao> yeah so where does , src goes?
21:10:27 <julianleviston> lingxiao: hs-source-dirs… but you already said that didn’t work
21:10:48 <julianleviston> lingxiao: what bothers me, though, is… why didn’t that error? It should error when you run your test suite… as it tries to install all those packages.
21:11:08 <lingxiao> yeah see when i do    , src;;k;   just for sanity check
21:11:10 <julianleviston> lingxiao: and it should have errored BEFORE it got to telling you about the import problem… which is the error you _did_ get, right?
21:11:14 <lingxiao> im getting an error
21:11:23 <julianleviston> what is ;;k; ?
21:11:25 <lingxiao> yeah it says cannot file module
21:11:39 <julianleviston> oh… you’re intentionally stuffing it up. Ok.
21:11:42 <lingxiao> ohh just to mess it up some, you know i could be editing the wrong file which has happened
21:11:44 <lingxiao> yeah haha
21:11:54 <julianleviston> fail on purpose is a good sanity check. cool.
21:12:07 <julianleviston> so I wonder how src was working in the build-depends! :)
21:12:10 <lingxiao> lol boy my life philosophy is sane thanks a lot 
21:12:25 <lingxiao> yeah seriously right
21:12:36 <julianleviston> there must be some package I’m not aware of.
21:12:42 <lingxiao> there's this; https://hackage.haskell.org/package/haskell-src
21:12:51 <lingxiao> but that's not what it is
21:12:59 <julianleviston> yeah but that’s not src
21:13:17 <julianleviston> oh well. must exist.
21:13:42 <julianleviston> I’ve just never heard of it, and hackage search yields no results.
21:14:15 <lingxiao> yeah it's strange
21:14:22 <julianleviston> maybe it’s on stackage.
21:14:48 <lingxiao> huh when i put , src in library i get this error: 
21:14:49 <lingxiao> --  Failure when adding dependencies:    
21:14:50 <lingxiao>       src: needed (-any), not present in build plan
21:14:50 <lingxiao>     needed for package: CIS700-0.1.0.0
21:15:15 <julianleviston> in library??!
21:15:33 <julianleviston> lingxiao: ok. so how are you running your tests?
21:15:34 <lingxiao> yeah just to confirm the theory
21:15:43 <wedens> suppose I have attoparsec parser  skipSpace *> decimal `sepBy` char ',' how can I make it fail on input "abc,1" or "abc1,2"?
21:15:59 <lingxiao> you know if its' somehere out there then it would work in library as well
21:16:07 <julianleviston> yep.
21:16:15 <julianleviston> lingxiao: which brings me to how are you running your tests?
21:16:33 <lingxiao> julianleviston no tests yet, i just want to make sure i can actually import stuff from Core or any file in src to test 
21:16:50 <julianleviston> lingxiao: um…. I’m really confused.
21:16:50 <lingxiao> but if i did, during development i would just run main in ghci
21:16:58 <julianleviston> lingxiao: you’ve been saying things haven’t been working.
21:17:04 <julianleviston> lingxiao: what were you doing to create the error?
21:17:35 <lingxiao>  wait so there's a file in test, call it test/TCore.hs that imports functions from src/Core.hs 
21:17:41 <julianleviston> hold on
21:17:42 <lingxiao> that import alone is creating the error
21:18:04 <lingxiao> this is my test/TCore.hs
21:18:04 <julianleviston> lingxiao: what command are you typing at the command line to get GHC to give you the error
21:18:04 <lingxiao> http://lpaste.net/147111
21:18:07 <julianleviston> wait.
21:18:12 <julianleviston> what command
21:18:13 <lingxiao> :l TCore.hs
21:18:22 <julianleviston> lingxiao: tha’ts not in the test environment
21:18:25 <julianleviston> OH. MY. GOD.
21:18:30 <julianleviston> stupid me for assuming.
21:18:41 <lingxiao> no stupid me for not Knowing D:
21:18:43 <julianleviston> that’s inside GHCi.
21:18:49 <julianleviston> what command do you run to get into GHCi?
21:18:54 <lingxiao> ghci
21:18:57 <julianleviston> that’s not right
21:18:59 <lingxiao> ahhh shouldv read teh manual
21:19:03 <julianleviston> you should be writing stack ghci
21:19:04 <julianleviston> YES
21:19:12 <julianleviston> and even then, you won’t be in the test env.
21:19:17 <julianleviston> so it will load different packages.
21:19:26 <julianleviston> you’ll be in the library env.
21:19:30 <julianleviston> :D
21:19:34 <julianleviston> yay we got to the bottom of it.
21:19:43 <lingxiao> OH MY GAWWWWD
21:19:45 <lingxiao> ok now it works
21:19:46 <julianleviston> lol yeah :)
21:19:51 <julianleviston> I’m an idiot. Sorry :)
21:19:54 <lingxiao> also that GAWWWWD look very fallic
21:19:56 <julianleviston> I really should have checked my assumptions.
21:19:58 <lingxiao> no i am sorry !
21:19:59 <lingxiao>  :(
21:20:02 <julianleviston> lingxiao: fallic?
21:20:03 <lingxiao> wasted everyone's time and energy
21:20:07 <julianleviston> it’s fine.
21:20:10 <julianleviston> you didn’t know.
21:20:12 <lingxiao> phallic*
21:20:19 <lingxiao> i didnt MAN
21:20:20 <julianleviston> lingxiao: like a penis?
21:20:22 <lingxiao> yeah
21:20:25 <julianleviston> lol ok.
21:20:29 <lingxiao> or a spring
21:20:40 <zv> High quality conversation, would +k again
21:20:48 <lingxiao> see it's more acceptable if we dont use the p word
21:20:56 <lingxiao> it's art critique, not toilet humor
21:21:31 <zoku> hmm, are TBMChannels safe to share between threads?
21:21:33 <julianleviston> lingxiao: sure, sure. I just wanted to double-check my assumption that you knew what it meant :)
21:21:34 <lingxiao> zv sorry 
21:21:35 <lingxiao> :(
21:21:50 <lingxiao> oh yeah its always a risk during art critique
21:22:15 <lingxiao> ok I'll read the man about getting into test envirnments and all
21:22:36 <julianleviston> lingxiao: hopefully this helps, but when you run GHCi using stack, it will check dependencies and load the required things, downloading them if it needs...
21:22:55 <lingxiao> ahhh this makes so much sense!
21:22:58 <zoku> it looks like writes to this channel aren't actually picked up by the reciever
21:23:01 <julianleviston> lingxiao: it should do the same thing when you stack build or run the stack test command (not exactly sure what the stack test command is)
21:23:01 <zoku> but they are in different threads
21:23:44 <lingxiao> yeah no there's a lot to learn, this is good!
21:23:56 <lingxiao> im looking to get beyond the hack little projects and make bigger things
21:24:16 <julianleviston> lingxiao: always so much to learn.
21:24:32 <lingxiao> read that in yoda voice
21:25:24 <julianleviston> lingxiao: zhar you… so much to learn. :)
21:25:53 <lingxiao> hahaha 
21:26:12 <julianleviston> lingxiao: excuse my pedestrian zhongguo.
21:26:20 <julianleviston> lingxiao: oops.. zhongwen.
21:27:22 <lingxiao> all good man you know more chinese than i do stack ,, err comparing apples to oranges here but w/e
21:30:55 <glguy> ontop: Did you start on tonight's AoC?
21:32:16 <shachaf> Axiom of choice?
21:32:43 <shachaf> Oh, advent of code.
21:33:37 <zoku> too bad there's no qemu advent calendar this year
21:35:27 * hackagebot http-client 0.4.26.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.26.1 (MichaelSnoyman)
21:41:05 <ontop> glguy: Nah, I'm way behind because I got stuck on that problem I had that Axman6 helped solve.
21:41:11 <ontop> Gotta play catch up :(
21:41:13 <ontop> Is it tough?
21:42:03 <glguy> it's on par with recent problems, I think
21:43:32 <ontop> glguy: What other languages do you know? Do you think Haskell is best suited for all the problems so far?
21:44:35 <Axman6> Haskell is the best suited languages for all the problems faced by humanity thus far. for some definition of best, particularly if the definition includes "solutions written in haskell" :P
21:45:28 <julianleviston> Axman6: I like it: “Haskell… is Haskell"
21:45:31 <glguy> All the problems are far are quite suited to Haskell. I know a range of languages, but Haskell's my favorite
21:47:35 <ontop> glguy: What are some of the others? Need a basis for comparison here :D
21:48:59 <ontop> julianleviston: What does that mean?
21:49:11 <julianleviston> ontop: sorry, what are you referring to?
21:49:44 <ontop> A coworker recently said to me that there was some ACM competition, and Haskell people kept solving the problems the fastest and most elegantly. So they banned it. Like George Bushes no child left behind.
21:49:52 <ontop> julianleviston: "Haskell.... is Haskell."
21:49:55 <julianleviston> ontop: I guess you mean the last thing I said, which was a reprhasing of Axman’s comment that Haskell is best suited for all problems for some definition of problems, etc.
21:51:25 <ontop> Ahha.
21:51:39 <julianleviston> ontop: I think Haskell and its ecosystem/community of people encourage “seeing” (ie understanding) to a much deeper level than other languages… coupled with Haskell’s excellent abstraction mechanisms and you kind of have a super language that admits its own faults and problems, IMO.
21:51:52 <lingxiao> ok thanks evryone for oreinting me with stack!
21:52:18 <lingxiao> i really apreciate all your patience with my "not wanting to read the manual which is actually reallyreally good" !!
21:52:27 <julianleviston> lingxiao: :) all good.
21:55:47 <ontop> julianleviston: It has faults and problems?
21:56:42 <julianleviston> ontop: course.
21:56:59 <julianleviston> ontop: everything does. Anyone who tells you something doesn’t is trying to sell you something.
21:57:40 <ontop> It was sort of a joke haha.
21:57:50 <zipper> I want to write code that will figure out when the first Saturday of the next month is in haskell.
21:57:58 <julianleviston> ontop: oh sorry :)
21:58:46 <julianleviston> zipper: does using git qualify? http://hackage.haskell.org/package/git-date
21:59:17 <ontop> julianleviston: If you asked me about crappy things in Go, I've got some definite answers. What would you say Haskell's warts are?
21:59:26 <zipper> julianleviston: Let me see
21:59:29 <julianleviston> zipper: there’s also this… which may help! http://hackage.haskell.org/package/time
21:59:55 <zipper> julianleviston: Yeah that time library isn't helping.
22:00:10 <julianleviston> zipper: why?
22:00:48 <zipper> julianleviston: Okay that git-time lib is uh idk I can't use it here.
22:00:56 <glguy> zipper: the time library cand o that
22:00:59 <zipper> I think my issue is more of a logic problem.
22:00:59 <glguy> can do*
22:01:06 <Axman6> zipper: SQLite has some awesome data manipulation code for doing that, doesn't help you but might be useful if you do end up needing to write something from scratch =)
22:01:08 <glguy> You'll have to build it, but all the pieces are there
22:02:07 <Axman6> "Compute the last day of the current month."
22:02:08 <Axman6> SELECT date('now','start of month','+1 month','-1 day');
22:02:13 <Axman6> https://www.sqlite.org/lang_datefunc.html
22:04:32 <RouxTheDay> Feels like a stupid question to ask here, but I can't seem to figure it out, I'm using the haskell opengl bindings, and creating spheres with GLUT, but I can't figure out how to make the spheres in any other position but (0,0,0), anybody know how?
22:04:43 <ontop> julianleviston: No answer for that? :(
22:04:45 <julianleviston> zipper:  actually it looks like this does *exactly* what you want. https://hackage.haskell.org/package/hourglass-fuzzy-parsing
22:05:14 <julianleviston> ontop:  oh sorry… um… it’s warts are its strengths.
22:05:30 <ontop> That hurts my brain :D
22:05:42 <ontop> So the bad things are the good things?
22:05:45 <julianleviston> ontop: For example… it has an excellent type system… which means it’s comprehensive… so it’s harder to learn initially than no type system.
22:05:49 <julianleviston> ontop: yeah!
22:06:29 <julianleviston> ontop: but once you do know it, and have learned it, it’s one of the best things.
22:06:44 <ontop> Well. It's certainly challenging as hell for me to pick up.-
22:07:13 <ontop> Honestly, I'll say this: Go's language is small, concise, easy to learn. Resources are concentrated and available. Haskell seems like even if you're willing to learn it it's a huge pain in the ass
22:08:12 <ontop> Like for example the MD5 thing. In any other language I'd google that and find the language's docs, 8 Stack Overflow examples of it, and a forum post on a mailing list.
22:08:30 <ontop> For Haskell, I found basically the Hoogle Crypto.MD5 page. As well as a hackage page for a pure Haskell impl.
22:08:41 <ontop> I felt like I was alone in a forest.
22:09:17 <ontop> The barrier for entry is "this" big.
22:10:53 <julianleviston> ontop: Like all things, it depends where you’re coming from.
22:11:01 <liste> haskell is less popular than e.g. Python, Java or C#, so there's not that much content out there
22:11:09 <julianleviston> ontop: ^ this.
22:11:12 <ontop> Welp. Part 2 of the Advent problem ruined everything I made with the set thing.
22:11:16 <julianleviston> ontop: but also, it’s so different.
22:11:19 <ontop> Maybe it's time to learn mutable arrays?
22:11:23 <liste> for Haskell, hoogle and hackage make it pretty accessible though
22:11:43 <lpaste_> glguy pasted “finding saturdays” at http://lpaste.net/147113
22:11:49 <julianleviston> ontop: it requires different thinking.
22:12:07 <julianleviston> ontop: so, you have to re-learn your automatic ways. It’s like learning how to speak French if you only know Japanese.
22:12:11 <ontop> liste: They've been mostly helpful. But it's still hard to find stuff without knowing it.
22:12:17 <bitemyapp> glguy: hi
22:12:33 <glguy> Oh, bummer, zipper left already
22:12:35 <glguy> hi
22:12:36 <ontop> julianleviston: I find I've been doing okay at it.
22:12:38 <julianleviston> ontop: but if you’re entirely fresh, it can actually be much easier to learn. Just ask bitemyapp :)
22:12:52 <ontop> The hardest part has been finding the things I need.
22:12:58 <julianleviston> ontop: you’re probably pretty good at flexible thinking then, and don’t mind a bit of pain for some reward later. :)
22:13:03 <bitemyapp> glguy: hi
22:13:09 <ontop> Nah, I'm pretty good at pain for rewards.
22:13:14 <bitemyapp> glguy: so I've been trying to port a parser from attoparsec to trifecta
22:13:20 <bitemyapp> glguy: I have Questions!
22:13:50 <glguy> You're going to have to deal with me looking them up on the spot, though. I've never used trifecta
22:13:52 <ontop> julianleviston: Is bitemyapp's first language haskell?
22:14:09 <julianleviston> ontop: no. :)
22:14:15 <ontop> o
22:14:29 <julianleviston> ontop: but he’s been teaching it for a while now, and has data about true beginners.
22:14:35 <ontop> Oh really?
22:14:43 <ontop> I saw a paper on it
22:14:48 <bitemyapp> glguy: you, wait what
22:14:50 <ontop> And it said it basically murdered all the true beginners.
22:14:53 <bitemyapp> glguy: you uploaded parsers didn't you?
22:14:54 <julianleviston> ontop: yep. He’s also been writing a book on it… which is really good.
22:15:07 <ontop> But
22:15:11 <bitemyapp> glguy: fuck it I'll give it a shot
22:15:16 <ontop> Is the book available? I'd like to see some results.
22:15:20 <julianleviston> ontop: well, the language around it (the words we use) can be a bit of a problem for people sometimes, it seems.
22:15:26 <julianleviston> ontop: ask him… he’s here :)
22:15:33 <bitemyapp> glguy: I translated 'skipWhile (not . isEndOfLine)' into 'skipMany (noneOf "\n")' --- how fucked am I?
22:15:38 <ontop> I'm scared. He's problem solving.
22:15:40 <bitemyapp> left is atto, right is trifecta/parsers
22:15:42 <julianleviston> ontop: the book is on haskell, not the results of teaching it.
22:15:46 <bitemyapp> ontop: I only bite tasty people
22:15:48 <julianleviston> ontop: k.
22:15:50 <glguy> bitemyapp: I have maintainer access to a lot of things, but I don't necessarily use all of them :)
22:15:52 <bitemyapp> ontop: I teach Haskell too
22:15:56 <bitemyapp> glguy: sdfklsdrjylkerlktjsdfg
22:16:00 <ontop> I need to learn Haskell.
22:16:04 <bitemyapp> ontop: then I'm your dude.
22:16:06 <julianleviston> ontop: you should buy his book.
22:16:09 <julianleviston> ontop: ;-)
22:16:18 <ontop> Is it THE book to buy for Haskell learning?
22:16:21 <julianleviston> ontop: shameless plug (full disclosure, I like the book).
22:16:23 <ontop> I won't accept anything that's not THE book.
22:16:56 <bitemyapp> ontop: the alternative is cobbling together 3-5 books, 50+ blog posts, undirected trial and error, annoying the shit out of people in IRC.
22:17:02 <MarcelineVQ> ontop: in 2015 it's the book, haskell is broad though so there's plenty more specialized books
22:17:07 <julianleviston> ontop: it’s as “the book” as we have yet, I think. It covers a LOT of it.
22:17:12 <ontop> bitemyapp: That sounds horrible :D
22:17:26 <julianleviston> ontop: yeah, that’s why he wrote it :)
22:17:30 <bitemyapp> ontop: then you probably want our book. My co-author Julie's first programming language is Haskell.
22:17:38 <julianleviston> ontop: coz he’s had to recommend that cobbling together thing for a long time.
22:17:46 <bitemyapp> ontop: she's the first line of defense against me not making sense.
22:18:07 <bitemyapp> glguy: who knows Trifecta? I won't tell them you sent me :P
22:18:10 <ontop> bitemyapp: How's it written? Light style? Or super hardcore mathematic speak dry style?
22:18:15 <bitemyapp> pdxleif: ping
22:18:30 <bitemyapp> ontop: light IMO, but we use the real words
22:18:41 <glguy> bitemyapp: I don't really know anyone who uses it.
22:18:43 <bitemyapp> ontop: you can check the sample to see what I mean.
22:18:50 <glguy> other than Ed of course
22:18:53 <ontop> Book name?
22:18:57 <bitemyapp> glguy: scale of 1 - oh god I used an Ed library, how fucked am I?
22:19:07 <bitemyapp> @where book
22:19:07 <lambdabot> http://haskellbook.com/
22:19:10 <bitemyapp> ontop: ^^
22:19:20 <glguy> dunno :) I honestly have zero trifecta experience
22:19:21 <bitemyapp> "Haskell Programming from first principles"
22:19:30 <bitemyapp> glguy: that's a "fucked" out of 10
22:19:38 <bitemyapp> the errors are pretty at least.
22:19:38 <ontop> $59 USD. My face
22:19:40 * ontop holds his face
22:19:59 <bitemyapp> ontop: it's my only income atm (I had FT work for some of the time I've been working on it)
22:20:04 <glguy> bitemyapp: Does it happen that your skip translation doesn't work?
22:20:07 <bitemyapp> ontop: it's been my co-author's only income the entire time she's worked on it.
22:20:08 <ontop> Hm.
22:20:13 <bitemyapp> glguy: there's a lot wrong at the moment.
22:20:22 <bitemyapp> glguy: it type-checks, but every single test (all four of them :P ) fails.
22:20:32 <bitemyapp> I figured I'd just try a quick before/after out of them.
22:20:47 <bitemyapp> I'll probably just make a helper fn for running the parser and test it in the REPL until I figure out what it does.
22:20:58 <glguy> What convinced you to try it?
22:21:13 <bitemyapp> glguy: attoparsec's errors and a conversation with my coauthor.
22:21:34 <bitemyapp> may have to fall back to Parsec as a compromise choice for "nice errors, not as pretty, but better than atto"
22:21:51 <glguy> For the book?
22:22:06 <bitemyapp> glguy: that's all I ever do is work on book stuff.
22:22:06 <julianleviston> ontop: if you’re going to buy a book, this is the best value IMHO.
22:22:28 <ontop> julianleviston: It's been a LONG time since I learned a programming language from a book (C++ when I was 14)
22:22:34 <ontop> Debating.
22:22:46 <bitemyapp> glguy: you can't churn out content like we do without having nothing else in your life.
22:22:59 <bitemyapp> glguy: if we took as long to write the book as the typical tech author (I took a survey), it'd take 8 years.
22:23:16 <bitemyapp> (an involuntary survey. of a publisher's shared drive)
22:24:02 <julianleviston> ontop: I reckon it accelerates your learning about 5 to 10 times. So where normally learning haskell from the free resources would take someone about a year, this will have you up and running in a month or so.
22:24:13 <julianleviston> ontop: completely subjective opinion, though.
22:24:26 <julianleviston> ontop: read the example chapter and see what you think.
22:24:44 <bitemyapp> two chapters in the sample
22:24:45 <bitemyapp> 2 and 3
22:24:47 <ontop> Good idea.
22:24:48 <bitemyapp> of...32
22:25:01 <julianleviston> bitemyapp: sorry :)
22:25:04 <bitemyapp> ontop: http://haskellbook.com/progress.html this should give you an idea of what we cover
22:25:07 <bitemyapp> julianleviston: no dramas
22:25:18 <ontop> bitemyapp: I'll give the sample chapters a shot. Keep in mind that if this were like $20 or $30 I would have already bought it. Just throwin' that out there.
22:25:49 <bitemyapp> ontop: the book'll be ~1200-1300 pages when it's done. It's also a book for a niche topic.
22:25:55 <julianleviston> ontop: price *is* an interesting thing :)
22:26:10 <bitemyapp> ontop: we have to price it like a textbook and just the parsers book I got for the parsers chapter (remember, 1 of _32_ chapters) was $110.
22:26:57 <julianleviston> bitemyapp: I wonder if splitting into pieces and also providing a bundle might be a good exercise in marketing… I’ve wondered this from the beginning actually… 
22:27:11 <bitemyapp> we considered that and wrote it off.
22:27:16 <bitemyapp> it's not a good idea.
22:27:28 <julianleviston> bitemyapp: I have no doubt you’ve considered it.
22:27:54 <bitemyapp> the book is cumulative.
22:28:09 <bitemyapp> if people buy a second or third volume, skip the first because they think they understand things that they don't really understand
22:28:14 <bitemyapp> they'll hit a brick wall, blame us.
22:28:24 <bitemyapp> so, no. Need to start from the beginning, do the exercises.
22:29:04 <ontop> bitemyapp: Dam
22:29:15 <julianleviston> bitemyapp: that sounds like a good reason on the surface.
22:29:26 <bitemyapp> just speaking from experience.
22:29:46 <bitemyapp> skipping ahead (whether you're using our book or not) leads to failure
22:29:52 <bitemyapp> each later topic builds on earlier ones.
22:30:07 <julianleviston> bitemyapp: yeah, I know this.
22:30:13 <bitemyapp> You do, others don't.
22:31:48 <anohigisavay> hi. i have several state monads that i'd like to chain together, but i also want to collect their results
22:32:16 <anohigisavay> simply >>= will discard their results
22:32:54 <anohigisavay> is there anything i can do without touching the code of these states? 
22:33:01 <liste> @paste -- anohigisavay please paste your code
22:33:01 <lambdabot> Haskell pastebin: http://lpaste.net/
22:33:48 <anohigisavay> liste: k let me make a minimal program
22:33:54 <julianleviston> bitemyapp: the fact is, $60 is a lot of money for a lot of people. However, 3 lots of $20 isn’t. I don’t understand why, but it’s true for me.
22:34:17 <glguy> anohigisavay: You can name all of the intermediate results in do-notation and then do something with the results
22:34:35 <glguy> anohigisavay: do x <- stateThing1; y <- stateThing2; z <-... ; return (x,y,z)
22:34:54 <bitemyapp> julianleviston: distillation of ~2.5k hours of labor...$59.
22:35:05 <glguy> anohigisavay: and if that's not what you meant, keep going on that paste :)
22:35:11 <bitemyapp> I'm going to back to writing, since I don't think anyone here can help.
22:36:43 <julianleviston> bitemyapp: I wonder if it’d bring in more money for you if you split it into pieces. Who knows. I don’t want to annoy you any more, though, so I’ll desist.
22:37:34 <bitemyapp> we don't care about that
22:37:43 <bitemyapp> the point is to make as many of our readers succeed as possible
22:37:51 <bitemyapp> that means making sure they have the whole thing
22:38:00 <bitemyapp> anyhoo
22:38:02 * bitemyapp is writing
22:38:14 <julianleviston> bitemyapp: I guess if it means some % of the people won’t buy the book at all… that’s ok.
22:38:46 * julianleviston is not honouring his promise to not annoy bitemyapp - sorry about that.
22:39:56 <dolio> Can't you just get a box, and then every time you can pay $20, you put it in the box? Then, after three times, you can buy something that costs $60.
22:40:47 <bitemyapp> I think that's a bank, except somebody else watches the box for you
22:40:49 <MarcelineVQ> with the price of boxes these days?
22:41:28 <bitemyapp> MarcelineVQ: btw Julie really likes your feedback.
22:41:50 <bitemyapp> she and I were going over the transformers chapter today, brought you up
22:42:44 <ontop> bitemyapp: I'm not sure I'm going to commit to haskell enough to buy a $60 1200 page book. But I'm doing it because it's near Xmas. Merry Christmas to you two, and thanks for the hard work. Hopefully I'll get to reading it.
22:43:22 <bitemyapp> ontop: most of the length is code examples
22:43:28 <ontop> Perfect.
22:43:30 <ontop> I need them.
22:43:35 <bitemyapp> ontop: it's not dense in the way you might be imagining 1,200 pages to be.
22:44:07 <bitemyapp> anyhoo, it's only about a 1,000 right now
22:44:10 <MarcelineVQ> bitemyapp: I'm p. great
22:44:11 <bitemyapp> it'll be 1,200 in a few releases.
22:44:17 <bitemyapp> MarcelineVQ: lmao
22:46:17 <ontop> bitemyapp: It might not be, I didn't really read the sample chapters. Probably should have BUT IT'S TOO LATE NOW.
22:47:11 <bitemyapp> ontop: *shrugs* your loss.
22:47:31 <ontop> Loss?
22:47:34 <bitemyapp> ontop: if you can trade 100s of hours for $59 profitably you have bigger problems than learning Haskell :P
22:47:36 <ontop> I bought your book lol.
22:47:39 <bitemyapp> ohhhhh
22:47:40 <bitemyapp> you did?
22:47:48 <bitemyapp> well thank you then :)
22:47:52 <ontop> Yeah, I'm saying I probably should have read the sample chapters before I bought it.
22:47:53 <Ralith> bitemyapp: is the book in its current state suitable for newbies?
22:47:57 <ontop> So I don't know what I actually bought.
22:47:58 <bitemyapp> I thought you were saying, too late as in you'd decided not to.
22:48:12 <bitemyapp> Ralith: tentative yes, firmer answer when you qualify newbies.
22:48:14 <ontop> :)
22:48:15 <julianleviston> bitemyapp: it’s written for newbies.
22:48:25 <bitemyapp> Ralith: the earliest material is the firmest/most complete, we proceed linearly.
22:48:35 <bitemyapp> Ralith: earliest material is also the most well-tested
22:48:51 <bitemyapp> Ralith: co-author is a never-before-programmer, we've tested with other people entirely new to programming, etc.
22:49:04 <ontop> I wish I could tell this PDF to have a better font.
22:49:05 <ontop> lol.
22:49:07 <bitemyapp> it's still extremely hard and the book isn't really designed to teach programming as such to somebody with zero background
22:49:08 <Ralith> bitemyapp: I have in mind an out-of-work lawyer whose previous technical experience is maintaining his windows machines
22:49:16 <bitemyapp> hrrrrrm
22:49:31 <bitemyapp> we need victi^H^H^H^H^Hreviewers like that.
22:49:45 <bitemyapp> basically, if they're entirely new to FP, should be totally fine
22:49:53 <bitemyapp> it's harder for non-programmers but still doable.
22:50:43 <bitemyapp> one a linguist (co-author), one an ER doctor, one a neuroscientist, others dunno background.
22:51:15 <bitemyapp> Ralith: do they want to break into the industry?
22:51:19 <bitemyapp> Ralith: for paid work?
22:51:23 <Ralith> yes, that's the motivation
22:51:51 <bitemyapp> Ralith: have you told them they should learn Haskell to do this?
22:52:43 <Ralith> I have advised that it would provide a comparatively strong foundation
22:52:51 <bitemyapp> ontop: don't forget, if you have questions, ping us via: http://haskellbook.com/support.html
22:53:09 <ontop> Will do, if I get through it I'll try to leave a quote or something.
22:53:21 <bitemyapp> Ralith: true enough, but they're going to have to learn some-other-language that's easier to find a gig in right? If you agree, what do you think the appropriate target there is?
22:53:28 <bitemyapp> ontop: :)
22:54:40 <Ralith> bitemyapp: overwhelmingly likely, and do you mean the appropriate some-other-language? If so, I'm holding off on recommending anything to him until he develops some sense of what sort of projects interest him
22:55:24 <bitemyapp> Ralith: has to be at least partly decided by where he lives, because that'll influence what's available.
22:55:39 <Ralith> also true
22:55:41 <bitemyapp> Ralith: some would say Scala, I actually disagree given just how huge the language is.
22:55:59 <bitemyapp> and it won't really do him a ton of favors to pine for the fjords while writing Scala.
22:56:05 <bitemyapp> people will just hate his code
22:56:35 <bitemyapp> I guess Java/Scala could be fine, just seems like the latter would be that-much-more to learn, but it's a marketable skill if there are jobs available for it.
22:56:54 <bitemyapp> Python would be quicker 0-60, but uh, types and just overall a bit clownshoes.
22:57:05 <Ralith> Scala never struck me as a strong contender if you're optimizing for employability
22:57:10 <bitemyapp> Extremely unlikely to find an F# gig.
22:57:13 <julianleviston> Are there actually python jobs?
22:57:18 <bitemyapp> julianleviston: tons in the US.
22:57:21 <bitemyapp> Tons tons tons.
22:57:25 <bitemyapp> Ruby too.
22:57:26 <julianleviston> ah interesting!
22:57:31 <bitemyapp> C#, Java.
22:57:37 * bitemyapp rubs chin and ponders
22:57:38 <MarcelineVQ> So then there's a market for writing good python code in haskell..
22:57:39 <julianleviston> I thought ruby was on the way out popularity wise
22:57:46 <Ralith> I figure the quality of the professional language doesn't matter so much once a good grounding is established
22:57:47 <bitemyapp> I need to talk to ordinary people more often.
22:57:51 <MarcelineVQ> pyghc
22:57:52 <Ralith> that's part of the point of starting with Haskell, after all
22:58:01 <bitemyapp> julianleviston: Node.js and Go are nibbling at it but those are still hipsta-matic companies.
22:58:06 <liste> julianleviston I think it's just getting "boring", like Java
22:58:11 <bitemyapp> Ralith: fair enough, but types do really help.
22:58:30 <julianleviston> I’m just talking about usage, really.
22:58:33 <bitemyapp> Ralith: I speak as a past victi^H^H^H^H^Huser of Clojure, Python, Common Lisp.
22:58:34 <Ralith> I doubt you'll find any argument in this channel
22:58:43 <bitemyapp> yes, choir, preaching; sorry.
22:58:51 <phy1729> bitemyapp: you should try ^W sometime ;)
22:59:01 <Adeon> ^H is more haskelly, has H in it
22:59:06 <bitemyapp> ^^
22:59:13 <bitemyapp> phy1729: I like it though
22:59:18 <bitemyapp> efficient
22:59:27 <bitemyapp> Ralith: I'm just going to check craigslist and see what pleb tech jobs are like
22:59:43 <Ralith> if I had to recommend something today it'd probably be C# on the basis of "java but less so" but it varies so much by domain
22:59:53 <bitemyapp> one thing in favor of Java
22:59:58 <bitemyapp> can do backend or mobile if they learn the Android stuff.
23:00:03 <bitemyapp> in fact, mobile pays pretty well
23:00:07 <Ralith> good point
23:00:09 <bitemyapp> so targeting Java could be pretty good.
23:00:13 <bitemyapp> so I'd say Java.
23:00:15 <Adeon> I'm pretty happy to be able to write haskell professionally although it's not primary at my work
23:00:33 <Adeon> I've written some critical systems in python not because it's great but because if that thing breaks people who are not me must be able to look and fix it
23:00:36 <bitemyapp> I've worked in 100% Haskell gigs. The language fades to the background you're just back to work on your problems, but with much less grief.
23:00:44 <Ralith> for myself I rather enjoy working with C++ profesionally but I would never recommend that to a novice programmer
23:00:46 <bitemyapp> background and you're*
23:00:50 <bitemyapp> Ralith: hahahahahaha
23:01:00 <bitemyapp> Ralith: give 'em Stroustrup's book and the standard, tell 'em "good luck"
23:01:05 <Ralith> :P
23:01:12 <bitemyapp> Ralith: yeah I have a soft spot for C++, but...that's def a no.
23:01:27 <davidar> There's a standard?
23:01:36 <davidar> :p
23:01:56 <ent> c++ and the stroustrup book was what I started with as a kid. it was a horribly idea :P
23:02:10 <julianleviston> davidar: no, there’s a hierarchy of standards, and each child standard can have many parents. ;-)
23:02:20 <ent> probably set me back a few years in actually learing how to program
23:02:41 <davidar> hehe
23:02:44 <Adeon> my first language was mallard basic on a CP/M computer
23:02:57 <Adeon> I was a little kid and in a vacuum where I didn't know anyone who knew anything about computers
23:02:59 <bitemyapp> Ralith: craigslist in my area is showing "full stack" (frontend web and backend), Django, Rails, PHP, DBA, Android, ops, mobile app, web dev, dba, rails, PHP, .NET, frontend, frontend, C++, mobile
23:03:07 <davidar> Yeah, C++ was my first "proper" language too
23:03:08 <Adeon> so I wasn't able to imagine any different programming languages
23:03:17 <Adeon> so I didn't understand how all the system tools were created
23:03:23 <davidar> Kids these days have it easy :p
23:03:31 <bitemyapp> Ralith: so, probably the easiest way to get the foot in the door is web in some form (PHP, Rails, Django), but other options exist.
23:03:48 <bitemyapp> Ralith: mobile has some nice properties other than Java overlap.
23:03:52 * Ralith is allergic to web and can't recommend it without breaking out in hives
23:03:52 <bitemyapp> Ralith: mobile means being relatively isolated.
23:04:06 <bitemyapp> Ralith: if you do backend, you have to think about more of the architecture usually.
23:04:17 <bitemyapp> people are used to putting mobile devs in a box, for better or worse
23:04:21 <bitemyapp> "here's the API; hop to it"
23:04:35 <julianleviston> javascript is probably the highest accesibility.
23:04:50 <bitemyapp> true enough, but people will keep wanting them to do design work too
23:05:07 <bitemyapp> mobile pays better by a fair bit too
23:05:11 <bitemyapp> So, I think Android+Java is reasonable as long as the job availability checks out.
23:05:14 <julianleviston> Yeah, “what’s the best first programming language” has no answer.
23:05:21 <bitemyapp> but frontend web will definitely win on raw job numbers.
23:05:55 <bitemyapp> Ralith: anyhoo, as long as there's an understanding that they won't get an undergrad in CS from the book nor be able to convert it into a job, that seems reasonable.
23:05:57 <MarcelineVQ> julianleviston: the best first programming language is qbasic
23:06:04 <bitemyapp> my first was GW-Basic.
23:06:11 <Ralith> bitemyapp: cool, thanks for all the thoughts!
23:06:15 <bitemyapp> I had a manual and SYNTAXERROR to keep me company. That was it.
23:06:18 <Ralith> and yeah, there's of course no substitute for experience
23:06:41 <davidar> Logo ftw
23:06:43 <bitemyapp> Ralith: and, if they do get the book and get stuck, we can try to help them get unstuck via the support desk.
23:06:50 <Adeon> qbasic had a nice text-based IDE
23:06:53 <bitemyapp> Ralith: if they decide on a platform to target, I could help them find resources for that too.
23:07:09 <bitemyapp> I want sleeper Haskell agents planted in every company.
23:07:13 <bitemyapp> ready to strike.
23:07:19 <Ralith> hah
23:07:22 <MarcelineVQ> Adeon: you could draw, you could do sound, you could math, what else do you need
23:07:35 <bitemyapp> ^^ 4rlz
23:07:35 <Ralith> that's pretty generous of you
23:07:36 <Adeon> I tried to write to every pixel in qbasic to produce a frame
23:07:38 <Adeon> it was pretty slow
23:07:45 <bitemyapp> Ralith: I couldn't afford school
23:07:46 <Adeon> as in it took several seconds to loop through all the pixels
23:08:03 <bitemyapp> Ralith: I had to get my career going w/o anybody believing I could do the job, took a long time, people (strangers) helped me along the way.
23:08:11 <bitemyapp> Ralith: happy to help others in similar'ish circumstances.
23:08:43 <bitemyapp> Ralith: what would be bloody ideal is if they could get a job writing software that uses their legal expertise. Maybe at one of those companies that make software for legal discovery (document processing/search)
23:08:58 <Ralith> yeah, that's the dream
23:09:01 <zomg> bitemyapp: I had a similar experience. Mostly was made fun for my ambitions in software :)
23:09:06 <MarcelineVQ> could write liscences, always need more of those
23:09:23 <Ralith> he's currently finding work as a document reviewer, so he certainly has some background
23:09:26 <bitemyapp> MarcelineVQ: I want a Bear License
23:09:35 <bitemyapp> "a bear will eat you if you misuse this software"
23:09:40 <bitemyapp> zomg: Doing alright now?
23:09:57 <bitemyapp> Ralith: I think that's a good goal to work towards and if that's the case, it's extremely likely to be Java.
23:10:01 <phy1729> MarcelineVQ: just use ISC or WTFPL and stop caring is my suggestion :)
23:10:01 <MarcelineVQ> That's a ​Licensed Bear not ​Bear License!
23:10:04 <zomg> Yep, I have a job where I choose my own hours and can work where ever I feel like
23:10:04 <Adeon> I got bachelor's and in process of getting master's but now that I'm working in US I'm considering dropping out
23:10:05 <Ralith> noted
23:10:10 <bitemyapp> Ralith: as it happens, NLP is an interest of mine and most of those companies are using NLP Java kit.
23:10:19 <bitemyapp> zomg: good, congrats :)
23:10:21 <zomg> so I'm pretty sure most of those people who made fun of it back in the day would be fairly jealous ;)
23:10:51 <phy1729> zomg: do you also get to write haskell for money?
23:11:19 <Adeon> have heard different attitudes to studying; some say that I should finish my master's because it'll be super useful and others say that now that I have a good job I should consider geting master's degree a waste of time
23:11:23 <zomg> phy1729: I did a small web service with Haskell at the current gig but we mostly do javascript
23:11:37 <zomg> issue with the other devs not knowing any haskell :)
23:11:48 <davidar> Adeon: it depends
23:11:48 <phy1729> zomg: way closer to the dream than I am :)
23:12:06 <Adeon> I'm trying to indoctrinate some of my coworkers to haskell
23:12:11 <Adeon> many of them already know erlang
23:12:21 <zomg> Adeon: yeah I do that too sometimes :p
23:12:36 <Adeon> well several critical company systems are all erlang projects
23:12:53 <zomg> plus I help people get better coding skills and I think I've even helped some get jobs via helping them fix their CVs and such
23:13:13 <josephle> hmm, might be hard to convince people to switch from erlang to haskell
23:13:18 <josephle> depending on the use case
23:13:30 <zomg> You wouldn't believe how terrible most people are at writing CVs and resumes, mostly because they get told all sorts of nonsense about how they need to be structured :)
23:13:49 <Adeon> I did impress someone when I showed the automatic differentation package 'ad' and did gradient descent on one line in REPL
23:13:51 <zomg> Not saying I'm that great either but I have a track record of getting jobs at least :D
23:13:56 <josephle> concurrent and parallel haskell is great, but there are some patterns that are so easy to do in erlang and so annoying to do in haskell
23:14:17 <Adeon> although I think they were more impressed by the fact auto-differentiation exists than haskell
23:14:27 <bitemyapp> josephle: I think the Erlangers are more embittered and dug in than we are :P
23:14:45 <bitemyapp> josephle: whereas we'd be happy to get dependent types and other goodies "for free", they're never leaving BEAM.
23:14:55 <josephle> bitemyapp: or OTP
23:15:02 <bitemyapp> I considered adding /OTP
23:15:05 <bitemyapp> but this is IRC
23:15:08 <bitemyapp> and it's IRC with programmers in it
23:15:14 <josephle> hahaha
23:15:17 <bitemyapp> and invariably somebody would tell me BEAM and OTP aren't the same kind of thing
23:15:24 <bitemyapp> and then I'd have to get in my car and hurt someone
23:15:26 <bitemyapp> so I decided not to
23:15:33 <josephle> heh
23:15:33 <ReinH> bitemyapp: you were going to lose either way :p
23:15:48 <bitemyapp> me: 0 IRC: 9001
23:15:56 <davidar> Adeon: I'm currently doing a masters, but most of my programming knowledge is self taught - formal education has mostly been useful for the mathematical aspect
23:15:59 <bitemyapp> ReinH: maybe with type annotations? Explicit tuple? HList?
23:16:07 <bitemyapp> ['BEAM, 'OTP]
23:16:13 <bitemyapp> (BEAM, OTP)
23:16:21 <davidar> So it depends on what you're trying to achieve
23:16:21 <bitemyapp> Haskell-Lojban
23:16:23 <ReinH> (BEAM|OTP)
23:16:25 <Adeon> davidar: in my case I've found most of the education itself has been useless, much more useful has been lots of free time and connections
23:16:37 <Adeon> in my free time I can hack on stuff and so on
23:16:47 <josephle> I thought OTP was a set of libraries and BEAM was something related to to the Erlang VM
23:17:05 <ReinH> josephle: yes, basically
23:17:10 <bitemyapp> josephle: yes.
23:17:12 <josephle> ok
23:17:18 <bitemyapp> josephle: that's why I didn't / them.
23:17:32 <phy1729> Adeon: and motovation to actually read the books (at least college was that for me)
23:17:34 <bitemyapp> you can't use slashes with things in the presence of programmers unless that inhabit the same category or are two characters in a fan-fiction.
23:17:39 <josephle> ah, it was the '/' you're concerned about
23:17:40 <josephle> ok
23:17:40 <bitemyapp> they inhabit*
23:18:03 <Adeon> phy1729: I'm a terrible student; didn't bother to read many books in detail :-]
23:18:05 <josephle> (BEAM|OTP) has my vote
23:18:05 <Adeon> but don't tell anyone
23:18:05 <bitemyapp> instance Pedantic Haskeller where; bePedanticNow = YES
23:18:15 <bitemyapp> instance Pedantic Haskeller where; bePedanticNow = const YES
23:18:24 <MarcelineVQ> `Beam Otp Erlang | Beam Otp -> Erlang`
23:18:26 <Adeon> at least the university is quite flexible so students can choose how they want to study
23:18:31 <phy1729> Adeon: I IRC'd too much in class and ended up having to read the book
23:18:37 <Adeon> I spent one year as an exchange student in south korea
23:18:46 <Adeon> the university there was much more school-like where they take attendance and stuff
23:18:52 <Adeon> for me that was awful
23:18:55 <josephle> bitemyapp: is there a haskell equivalent to OTP?
23:19:13 <josephle> if there isn't, why hasn't someone written it yet? :P
23:19:25 <Adeon> there is cloud haskell
23:19:33 <josephle> that is true
23:19:41 <bitemyapp> josephle: Cloud Haskell is the closest thing, it is not the same thing.
23:19:54 <bitemyapp> static pointers brought things closer
23:19:57 <julianleviston> Have you guys seen this? http://learnyousomeerlang.com
23:20:04 <julianleviston> I thought it was pretty funny
23:20:27 <bitemyapp> josephle: I don't really like to do Erlang-style in Haskell, but I've done it before.
23:20:38 <bitemyapp> josephle: mostly I break out services into discrete things
23:20:40 <Adeon> I experimented with distributed-process and friends a bit
23:20:53 <Adeon> I was a bit annoyed by the pseudo-static pointers thing with template haskell
23:20:56 <Adeon> but more or less it worked
23:21:15 <Adeon> but I didn't adopt it for any other programs because for some reason I didn't find it very useful
23:21:30 <Adeon> or maybe my programs don't fit very well to its pattern
23:21:33 <Adeon> no idea
23:22:04 <josephle> bitemyapp: yeah, I've done that before as well
23:23:09 <bitemyapp> josephle: last gig was ad-tech. Setup we used worked really well.
23:23:23 <josephle> sometimes I need some services that should have separate state (kinda like xmonad extensions iirc)
23:23:41 <bitemyapp> hum, yeah we did that in our main app
23:23:49 <bitemyapp> we'd "mount" services using slave-thread
23:23:54 <bitemyapp> they'd have their own stuff
23:24:01 <bitemyapp> didn't really have to think about that part much.
23:24:18 <Adeon> you are no longer a fellow adtech haskeller?
23:24:20 <bitemyapp> harder was communication, but that was still okay.
23:24:24 <bitemyapp> Adeon: no, just book atm.
23:24:30 <Adeon> :-[
23:24:45 <bitemyapp> Adeon: in contract limbo, waiting to see if it converts to full-time or if I should take a different contract.
23:24:46 <josephle> bitemyapp, the hard part for me was when I wanted to "harden" my architecture with some fault-tolerance
23:25:11 <josephle> of course this is haskell, and I shouldn't expect faults
23:25:36 <josephle> but I still wanted to have services auto-reload if they somehow broke
23:25:41 <bitemyapp> well, Marlow's book covers much of this.
23:25:46 <bitemyapp> ah, no, we don't do that.
23:26:03 <bitemyapp> I don't think having services auto-reload is a good idea unless it's a very mature service.
23:26:18 <bitemyapp> I prefer the Erlang-y let-it-crash with copious logging and a process reboot.
23:26:26 <bitemyapp> let the init system do its thing.
23:26:38 <bitemyapp> so, hybrid unixy/let-it-crash? _shrug_
23:26:51 <josephle> but Erlang likes to have its watcher threads
23:26:58 <josephle> that reload processes when they die
23:27:10 <josephle> that was what I was trying to do
23:27:36 <bitemyapp> josephle: idea behind slave-thread
23:27:46 <bitemyapp> josephle: is that it makes sure exceptions get raised from child threads to parent threads
23:27:53 <josephle> ah, I see
23:28:00 <bitemyapp> josephle: from there, supervisor trees/restarting is a matter of masking and exception handling
23:28:09 <josephle> yeah, I didn't have a decent exception system
23:28:11 <bitemyapp> but you're not going to get vary _without_ slave-thread or something like it anyway.
23:28:15 <bitemyapp> very far*
23:28:19 <josephle> probably my downfall
23:28:21 <davidar> Adeon: my advice would be, don't get a degree just for the sake of getting a degree, but because it's something you enjoy
23:28:45 <bitemyapp> josephle: mostly, reading Marlow's book makes a huge difference.
23:29:07 <josephle> yeah, I own the book. Just have to read some more of it
23:29:59 <julianleviston> I *love* that book.
23:30:22 <Adeon> I've been using the 'async' package to tie threads together so if some critical thread crashes I will either handle it or the whole thing goes down (which I prefer)
23:30:42 <Adeon> something like "race_ neverReturningThing1 neverReturningThins2"
23:30:58 <bitemyapp> Adeon: ditto.
23:31:03 <bitemyapp> I just want stuff to die when it fails and dump logs.
23:31:15 <Adeon> yeah exactly
23:32:06 <Adeon> async is great package
23:32:11 <Adeon> it has to be one of my favorites
23:32:25 <Adeon> another my favorite but mostly useless is astar package just because it's super simple and still works without being updated for years
23:32:33 <bitemyapp> I like how far Marlow goes in explaining Async in the book.
23:32:36 <bitemyapp> It's very good.
23:32:50 <bitemyapp> Marlow's book eliminated a huge swath of stuff I didn't really have time to cover in our book anyway
23:33:05 <bitemyapp> so I'm very grateful for that. I just have no way to improve upon what he did for the foreseeable future.
23:33:11 <julianleviston> bitemyapp: he’s an excellent author… so easy to read and interesting.
23:48:59 <julianleviston> :t (<|)
23:49:01 <lambdabot> Cons s s a a => a -> s -> s
