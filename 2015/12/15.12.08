00:07:30 <athan> What would you call a Map that can contain multiple values? With the guarantee that the set of contents is non-emtpy on a successful lookup, of course
00:09:08 <liste> athan so basically "lookup :: k -> XXXMap k v -> Maybe (NonEmptyList v)" ?
00:09:14 <athan> something like `lookup :: k -> ManyMap k a -> [a]` and `insert :: k -> a -> ManyMap k a -> ManyMap k a`, where an entry got added
00:09:22 <athan> liste: Yes!
00:09:50 <athan> the map could only really grow, in the way I just described
00:09:52 <jle`> sounds like it could be implemented as a Map k (NonEmpty v)
00:09:53 <Hijiri> there is a MultiMap on hackage
00:09:54 <liste> athan what happens to your lookup if there's no elements on "k" ?
00:10:02 <athan> jle`: I was thinking that too
00:10:12 <Hijiri> it doesn't look too maintained though
00:10:16 <athan> Hijiri: !!! Awesome!
00:10:25 <Hijiri> but it probably compiles, I don't know
00:10:29 <athan> liste: It returns the empty list
00:10:41 <liste> athan oh, now I see.
00:10:44 <jle`> athan: i'mnot sure why you need the guaruntee you said, then
00:11:04 <jle`> because both looking up a non-existent key and looking up an existant key with an empty list give the same result
00:11:08 <athan> jle`: I meant generally, not at the type level
00:11:20 <jle`> so they're...indistinguishable from an API standpoint?
00:11:23 <athan> more than willing to make a compromise for speed :)
00:11:31 <ggole> Isn't that just Map k [v]?
00:11:35 <athan> yeah! Successful lookups are implicit
00:11:42 <jle`> unless i guess you want M.keys to not return keys of empty lists
00:11:43 <athan> ggole: No, that's wrapped in Maybe
00:11:53 <athan> exactly
00:11:55 <jle`> athan: well, your api could just do fromMaybe []
00:12:17 <ggole> And with a wrapper around insert, I suppose
00:12:42 <athan> jle`: Ideally I would like to avoid the successful lookup from an empty list, though
00:12:42 <jle`> but probably the fact that you want M.keys to not include things with "empty" values makes Map k [v] a less useful abstraction
00:13:09 <athan> I think this structure would be best if it weren't as deconstructable as a Map
00:13:36 <athan> really just something you could add individual elements to, and lookup / delete whole keys
00:13:57 <athan> doing `keys` isn't necessary to be optimal imo
00:13:57 <jle`> sounds already kinda like a map of containers though
00:14:02 <athan> hmm
00:14:22 <jle`> the way you described it, at least
00:14:25 <athan> Actually, multimap seems to fit the bill :)
00:14:32 <athan> jle`: I'll have to think about it
00:14:42 <athan> see if a tree model can embody it
00:15:25 <athan> shoot, multimap doesn't have `split`
00:20:55 <athan> jle`: Oh wow, Data.Map.insertWith actually makes adding to the container trivial
00:21:06 <athan> I thought I would need to lookup, then replace
00:22:42 <jle`> oh no heh, the structure of the internal representation of the Map only depends on the keys, so modifying the values is pretty cheap :)
00:30:23 * luis_ slaps tkovs around a bit with a large fishbot
01:17:57 <athan> Are TMVars something that should only be used "in-between" threads, like a short-lived container? Or is it more for long-term contained objects, and destroying the contents of it would help with garbage collection?
01:18:39 <athan> I'm holding-on to a map of TVars right now, I'm just wondering if I "forget" about them, will the references they point to be GC'd?
01:27:05 <zenzike> I think hackage is down, but the university server here does strange things with ports sometimes. can someone confirm?
01:28:04 <zenzike> (I also get nothing back from status.haskell.org)
01:28:15 <athan> zenzike: http://downforeveryoneorjustme.com/hackage.haskell.org :)
01:28:25 <athan> zenzike: Did you just upload a package?
01:29:02 <zenzike> athan: no I didn't
01:29:43 * hackagebot inline-r 0.7.3.0 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.7.3.0 (MathieuBoespflug)
01:29:55 <athan> hmm
01:31:05 <zenzike> I thought that hackage.haskell.org would be serving html, is that the same port as the downloads?
01:39:43 * hackagebot nofib-analyse 7.12.0.20151208 - Parse and compare nofib runs  https://hackage.haskell.org/package/nofib-analyse-7.12.0.20151208 (JoachimBreitner)
01:53:31 <nilg> Anybody knows how to convert a CReal into an Integer?
01:54:24 <frerich> nilg: You could use 'round', no?
01:55:11 <frerich> nilg: Integer instantiates Integral and CReal apparently instantiates RealFrac, so I'd try 'round'.
01:56:59 <nilg> frerich: thanks! I didn't know about round (I'm still new to Haskell)
02:00:31 * hackagebot nofib-analyse 7.12.0.20151208 - Parse and compare nofib runs  https://hackage.haskell.org/package/nofib-analyse-7.12.0.20151208 (JoachimBreitner)
02:00:31 * hackagebot data-ref 0.0.0.1 - Unify STRef and IORef in plain Haskell 98  https://hackage.haskell.org/package/data-ref-0.0.0.1 (HenningThielemann)
02:02:11 <athan> Would it be faster to `fmap` over a list before turning it into a HashSet, or `HashSet.map` after the fact?
02:05:41 <kadoban> athan: The former seems naively faster, though probably not by much. (you could avoid a ton of extra hashing, and some inserts)
02:05:52 <ReinH> it depends
02:05:55 <phadej> :)
02:08:29 <kadoban> Yeah I guess if there's a bunch of repeated elements and the fmaped function is expensive it'd go the other way.
02:10:25 * hackagebot data-ref 0.0.1 - Unify STRef and IORef in plain Haskell 98  https://hackage.haskell.org/package/data-ref-0.0.1 (HenningThielemann)
02:28:29 <phaazon> oh, I love GADT and existential quantification <3
02:32:27 <athan> I've got TVars on stacks right now
02:32:35 <athan> TVar (TVar (TVar a))
02:33:01 <athan> nothing bad could come from this...
02:37:09 <dmj`> athan: might be time for a TChan 
02:42:43 <zipper> lug
02:55:26 * hackagebot wai-middleware-crowd 0.1.3 - Middleware and utilities for using Atlassian Crowd authentication  https://hackage.haskell.org/package/wai-middleware-crowd-0.1.3 (MichaelSnoyman)
03:25:38 <Ryth> Hey guys, anyone can explain me why http://pastebin.com/YvwLG5Ka results into a Â¨parse error in input Â´ifÂ´Â¨? The code is directly copied from http://learnyouahaskell.com/input-and-output so youÂ´d think it would work.
03:26:46 <shachaf> That can't be the whole error.
03:28:01 <Ferdirand> works fine for me
03:28:09 <hpc> were you entering it into ghci?
03:28:14 <Ferdirand> are you sure there is nothing funny in your whitespace ?
03:28:30 <Ryth> test.hs:3:9 parse error on input Â´ifÂ´. is the full error message
03:28:37 <Ryth> I tried both ghci and runhaskell, same error.
03:28:51 <hpc> make sure you're using spaces consistently throughout
03:29:53 <Ryth> ah.. it was the whitespaces, thanks.. vim is autoindenting with tabs x_x
03:30:01 <Ryth> got to fix that :p
03:30:06 <ben> :set expandtab
03:30:27 * hackagebot omnifmt 0.2.1.0 - A pretty-printer wrapper to faciliate ease of formatting during development.  https://hackage.haskell.org/package/omnifmt-0.2.1.0 (hjwylde)
03:31:18 <hpc> haskell specifies tabs to be an 8-stop indent
03:31:52 <hpc> (likely because that's what most old terminals do by default)
03:33:03 <bernalex> hpc: where does it specify that? in the report it just specifies it as horizontal tab ('\t').
03:35:38 <bernalex> I see some online resources say Â«Haskell defines tabs to align to the next column that is divisible by 8 charactersÂ» and similar, but [citation needed] as ever.
03:36:18 <hpc> it's part of the layout rules - https://www.haskell.org/onlinereport/syntax-iso.html
03:36:26 <hpc> "Tab stops are 8 characters apart."
03:37:29 <bernalex> I see. thanks.
03:38:17 <bernalex> I wish the ' committee would just ban them. it's an age old proposal.
03:40:40 <hpc> some people would go nuts
03:40:56 <hpc> i think we should make them increasingly more ridiculously difficult to use
03:41:09 <hpc> make the tab stop vary depending on what line you are
03:41:13 <bernalex> why on earth would they? tabs are just not useful in haskell. and converting tabs to space is very simple.
03:41:15 <hpc> make it a fibonacci tab stop
03:41:23 <hpc> make tab stops negative
03:41:32 <hpc> make vertical tab stops
03:41:39 <hpc> the options are endless!
03:41:52 <rom1504> :D
03:42:02 <bernalex> iirc, simon marlow had a ' proposal that aimed at making it more difficult rather than removing them completely. he concluded something like "but uh making it more difficult to use makes it more difficult for us to implement and handle it..."
03:42:11 <rom1504> make tab a compilation error and be done with it
03:44:48 <bernalex> the simple solution is removing \t-parsing from the layout rules and have it be a syntax error. it's easily motivated in haskell too, since leading alignment of indented lines is the norm rather than the exception, so the whole tabs for indentation and spaces for alignment rule doesn't fly.
03:45:22 <KaneTW> not even GHC is completely tab free
03:45:24 <bernalex> and the layout rules are by alignment not indentation anyway, so arguably there is no indentation in haskell. so why should there be tabs?
03:45:38 <bernalex> KaneTW: hm? we tab-freed it months ago afair
03:46:35 <bernalex> next up is a feature freeze for fixing max widths lol
03:55:27 * hackagebot basex-client 0.2.0.0 - A BaseX client for Haskell  https://hackage.haskell.org/package/basex-client-0.2.0.0 (MatthijsSteen)
03:55:35 <KaneTW> bernalex: huh, you're right
03:55:39 <nilg> All I want is to print some debug message while a function is being executed. I'm reading https://wiki.haskell.org/Debugging but don't easily understand (I guess I need Hugs.Observe, but is there something simpler?
03:55:50 <KaneTW> could've sworn i saw "Warning: tab character" when building head recently
03:56:48 <maerwald> @hoogle  f a -> (a -> b) -> f b
03:56:50 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
03:56:50 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
03:56:50 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
03:59:25 <liste> :t (<$$>)
03:59:26 <lambdabot>     Not in scope: â€˜<$$>â€™
03:59:26 <lambdabot>     Perhaps you meant one of these:
03:59:26 <lambdabot>       â€˜<$>â€™ (imported from Control.Applicative),
03:59:49 <liste> I could've sworn that existed :(
04:00:02 <liste> :t (<**>)
04:00:04 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
04:00:13 <maerwald> liste: hoogle says it's some parsec combinator
04:00:20 <bernalex> let not-that-useful = flip (<$>) -- done
04:01:19 <phaazon> hmâ€¦
04:01:52 <bernalex> anyway it should have been <&>.
04:02:07 <bernalex> because (&) = flip ($)
04:02:13 <phaazon> I have a GADT likeâ€¦ data Foo :: * -> * where { â€¦; Bar :: (ZooConstraint a) => String -> Foo (Something rw (UB a)) }
04:02:28 <phaazon> when I pattern match on Bar, I donâ€™t get the ZooConstraint in scope; why is that so?
04:03:22 <bernalex> and <$> is just function application $, lifting the function.
04:05:31 * hackagebot aeson-extra 0.2.3.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.2.3.0 (phadej)
04:06:20 <phaazon> I actually use ScopedTypeVariables
04:06:25 <phaazon> Iâ€™m not sure whether I can do that
04:07:57 <phaazon> ah, fuck, I got itâ€¦
04:08:03 <phaazon> nevermind.
04:21:02 <nilg> Debug.Hood.Observe.observe doesn't print anything at all, any idea?
04:27:28 <nshepperd> nilg: what does 'while being executed' mean to you here?
04:27:41 <nshepperd> keeping in most that evaluation in haskell is lazy
04:27:51 <nshepperd> uh, in mind
04:29:06 <nshepperd> if it's a pure function, I generally use Debug.Trace
04:30:32 * hackagebot luminance 0.8 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.8 (DimitriSabadie)
04:32:21 <Deathgrip> anyone there? I struggle to download from here: https://www.haskell.org/platform/ - getting 403 from both Windows links. any thoughts?
04:32:52 <liste> me too
04:33:36 <liste> seems some server is misconfigured
04:33:46 <nilg> nshepperd: I read about Debug.Trace but it's very cryptic to me, in particular I don't understand the use of | in https://wiki.haskell.org/Debugging#Printf_and_friends
04:34:54 <liste> nilg | is pattern guard syntax, it has nothing to do with trace
04:35:18 <nshepperd> O_O that's a strange idiom
04:36:09 <liste> > trace "hello!" 25
04:36:11 <lambdabot>  Not in scope: â€˜traceâ€™
04:36:16 <nshepperd> they're adding a guard there in order to force the evaluating of the trace before continuing to the rest of the function
04:37:28 <shachaf> It's not a pattern guard, just a regular guard.
04:38:16 <liste> who should I notify about the HTTP403 in Haskell Platform downloads?
04:38:24 <nshepperd> nilg: yeah the normal use of Debug.Trace is just to replace the body of your function with 'trace "tracing information goes here" body'
04:39:16 <nshepperd> nilg: which results in a value whose evaluation first prints out the trace then continues with the body
04:39:58 <nilg> I got it! Found an example here that made it clear https://en.wikibooks.org/wiki/Haskell/Debugging :-)
04:45:33 * hackagebot luminance 0.8.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.8.1 (DimitriSabadie)
04:49:22 <Deathgrip> liste: previous build seems to download fine http://downloads.haskell.org/~platform/7.10.2/
05:40:34 * hackagebot libravatar 0.2.0.0 - Use Libravatar, the decentralized avatar delivery service  https://hackage.haskell.org/package/libravatar-0.2.0.0 (akrasner)
06:00:35 * hackagebot pandoc-include 0.0.1 - Include other Markdown files  https://hackage.haskell.org/package/pandoc-include-0.0.1 (steindani)
06:25:56 <wedens> was there some html to blaze-html converter?
06:49:17 <s4ke> i need some help with redexes :) :D
06:49:51 <s4ke> i am too lazy to produce the redexes by hand for my exercises and want to output them via code
06:50:09 <s4ke> the function in question is zipWith (+) [1,2,3,4,5] [1..]
06:55:24 <carabolic> so what is the question? what are you trying to achieve?
06:55:39 * hackagebot luminance 0.8.2 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.8.2 (DimitriSabadie)
06:58:48 <s4ke> carabolic: i want/need the lefmost outermost evaluation and i have to give the redex in each step
06:59:25 <byorgey> s4ke: so what do you need help with?
07:00:00 <s4ke> byorgey: my exercise sheet mentions it would be possible to do this by instrumentalizing (+)
07:00:08 <s4ke> i just realized that i g2g. sorry
07:00:09 <s4ke> :/
07:00:13 <s4ke> thanks anyways
07:01:41 <carabolic> Too bad, really wanted to help. Did anyone understand what s4ke was trying to achieve?
07:02:16 <byorgey> I think so, but they hadn't really gotten around to asking anything specific
07:04:31 <frerich> It seemed to me that s4ke knew how to determine how the expression is reduced - he/she just wanted to see whether there's a way to not do it by hand but rather have a program give the reduction steps.
07:05:18 <frerich> Maybe akin to what lambdabot can do
07:05:22 <frerich> > foldr (+) a [b,c,d,e,f]
07:05:24 <lambdabot>  b + (c + (d + (e + (f + a))))
07:05:37 <byorgey> lambdabot can't show all the intermediate steps
07:05:56 <frerich> Right, that's why I wrote 'akin'. :-)
07:06:15 <byorgey> fair enough =)
07:06:50 <geekosaur> ghood?
07:06:54 <fractalsea> Can someone explain this threadscope behaviour (image in link)? In the highlighted section, thread 9 consatantly switches between GC and actually running the thread, but no work is actually being performed on the thread from what I can tell.. http://i.imgur.com/IzX2G33.png
07:06:54 <geekosaur> (or just hood)
07:06:56 <frerich> I seem to recall there was also a web page (maybe by Neil Mitchell?) which would actually give the steps
07:07:06 <geekosaur> which was updated recently
07:07:19 <fractalsea> I should say that the scale is roughly 50ms for the highlighted section
07:10:39 * hackagebot luminance-samples 0.8 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.8 (DimitriSabadie)
07:30:46 * hackagebot git-annex 5.20151208 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20151208 (JoeyHess)
07:55:43 <lingxiao> hey all
07:56:03 <lingxiao> I would like to ask some help for speeding up an algorithm
07:58:49 <RaceCondition> can HalVM be run on physical hardware as opposed to in a VM?
08:02:05 <geekosaur> I thought the whole point of HalVM is that it relies on xen to provide a bunch of stuff instead of using an OS?
08:02:05 <varaindemian> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person 
08:02:23 <varaindemian> I do not understand the "" and backslashes
08:02:45 <geekosaur> varaindemian, I presume that was taken out of a Haskell string
08:02:59 <geekosaur> so \" is how you embed a doublequote in a doublequoted string
08:03:08 <geekosaur> > text "this \"is\" a test"
08:03:10 <lambdabot>  this "is" a test
08:03:29 <varaindemian> I see
08:03:34 <varaindemian> thank you
08:05:00 <JagaJaga> What is `PatternSignatures`? Can't find any relevant information..
08:06:03 * hackagebot hslogger-reader 1.0.1 - Parsing hslogger-produced logs.  https://hackage.haskell.org/package/hslogger-reader-1.0.1 (alex_bates)
08:06:32 <broma0> I have a question about aeson encoding.. are there any bytes that will NEVER be in the resulting bytestring? I need to separate encoded json objects over a TCP connection
08:09:10 <geekosaur> maybe use a <length><string> encoding instead of relying on a sentinel byte
08:13:02 <lyxia> JagaJaga: where did you find that term?
08:14:49 <JagaJaga> lyxia: http://hackage.haskell.org/package/external-sort-0.2/docs/src/Algorithms-ExternalSort.html
08:15:22 <geekosaur> I think that's a ghc 8 thing
08:15:53 <geekosaur> https://phabricator.haskell.org/D1092
08:16:09 <geekosaur> basically using _ wildcards in (some) type signatures
08:16:56 <JagaJaga> geekosaur: seems that it was in ghc years ago.. https://mail.haskell.org/pipermail/haskell-cafe/2009-April/059520.html
08:17:06 <lyxia> Wildcards in type signatures is PartialTypeSignatures
08:17:11 <geekosaur> oh, that one
08:17:12 <geekosaur> right
08:17:31 <geekosaur> uh, trying to remember how the old stuff worked...
08:17:52 <lingxiao> hey all
08:17:53 <lingxiao> http://lpaste.net/146693
08:18:13 <geekosaur> oh right. pattern signatures was being able to use a type signature in a pattern
08:18:15 <lingxiao> could someone take a look at my code and suggest how might i speed it up
08:18:19 <geekosaur> foo (x :: Int) y = ...
08:18:33 <geekosaur> it was folded into ScopedTypeVariables
08:18:41 <lingxiao> specifically, if I run `morris 0.05 0.05 [1..10000]` 
08:18:43 <JagaJaga> geekosaur: thank you :)
08:18:54 <lingxiao> it's been running for > 5 minutes now :(
08:19:34 <lingxiao> I'm basically running morrisA for 1/(0.05^3) * 1/(0.05) times using replicateM
08:19:41 <lingxiao> so it's not surprising it's running a long time ..
08:20:02 <lingxiao> My question is mainly if I can do better than replicateM
08:23:28 <lingxiao> also, I'm trying to install math.statistics and I see this:
08:23:29 <lingxiao> http://lpaste.net/146694
08:24:08 <geekosaur> that's pretty ancient if it shows both base and haskell98 as dependencies
08:24:38 <geekosaur> the prelude has diverged too much
08:26:38 <JagaJaga> geekosaur: going to rewrite
08:29:38 <lingxiao> ok I'll just fork it then
08:29:38 <lingxiao> thanks
08:30:17 <lingxiao> and does anyone know what's the fastest way to repeat some computation on the order of 10000 times? 
08:30:26 <lingxiao> how does replicateM perform?
08:34:39 <KaneTW> lingxiao: if you need it for benchmarking purposes, use criterion
08:34:43 <KaneTW> otherwise replicateM is fine
08:35:09 <hc> what are "benchmarking purposes"?
08:36:36 <aweinstock> hc: timing how long a piece of code takes/measuring performance
08:36:44 <bergmark> lingxiao: here are supported ghc versions for hstats
08:38:23 <hc> i know what a benchmark is ;)
08:38:33 <hc> i mean why should you use a different function just to perform one?
08:39:02 <geekosaur> because benchmarking in a non-strict language has "interesting" edge cases
08:40:29 <geekosaur> like, you kinda want to not have it treat your expression as a thunk and only evaluate it the first time
08:40:42 <lingxiao> KaneTW : could you expand on what you said
08:40:57 <lingxiao> i'm going to benchmark it, so I should not use replicateM?
08:41:37 <KaneTW> criterion just makes sure your benchmarks are accurate
08:42:01 <geekosaur> and there's other complications that come up. criterion knows how to work around or avoid the edge cases so you get a valid benchmark
08:42:01 <lingxiao> I'm sorry so I should benchmark with replicateM?
08:42:09 <geekosaur> instead of one where hal;f the work isn't done on most of the runs
08:42:25 <geekosaur> lingxiao, you benchmark with criterion, not with replicateM. see what I just said for why
08:42:48 <lingxiao> oh I see. wait so I wouldn't be able to benchmark replicateM? 
08:42:59 <geekosaur> well, not reliably
08:43:08 <lingxiao> ahh I see. so ..
08:43:13 <aweinstock> you can benchmark the replicateM function using criterion (if that's what you're asking)
08:43:26 <lingxiao> the setting here is that I need to run this randomized algorithm 1/e^2 * 1/d^2 for e,d <= 0.05 
08:43:40 <geekosaur> not that it's slow, but that you have no control over sharing etc. so your timings are unlikely to be accurate
08:43:56 <lingxiao> aweinstock, yeah so Im guessing the bottleneck is in the replicateM
08:44:29 <geekosaur> I would not expect that to add much time tbh
08:46:02 <lingxiao> ah ok I'll benchmark and come back with more questions!
08:47:03 <aweinstock> import Criterion.Main; main = defaultMain [bench "replicateM" (nf (replicateM 10) "ab")]
08:54:09 <aweinstock> lingxiao: import Criterion.Main; main = defaultMain [bench "replicateM" (nf (replicateM 10) "ab")]
09:22:50 <Bavol> hey, I have wondered, what do you guys think about java 8 trying to combine object oriented programming with functional programming?
09:23:18 <johnw> Bavol: I'm not sure that's really Haskell-relevant
09:23:31 <johnw> we have #haskell-blah, for those types of questions
09:23:48 <Bavol> ok :) sorry thanks I will go there too
09:28:53 <jamesfordummies> when writing to a Network.Socket using `send`, my message gets split if it exceeds 8192 bytes. (iâ€™m using Stream). is this OS dependent or haskell specific?
09:29:47 <glguy> jamesfordummies: Stream sockets are still don't preserve read/write boundaries today
09:30:16 <jamesfordummies> glguy: are you sure? https://en.wikipedia.org/wiki/Stream_socket
09:30:28 <jamesfordummies> oh
09:30:29 <jamesfordummies> wait
09:30:31 <jamesfordummies> iâ€™m dumb
09:30:32 <glguy> Yes, if you want to preserve them you want a datagram socket
09:30:35 <jamesfordummies> *ignoreme*
09:30:42 <kadoban> jamesfordummies: Sounds OS and network-hardware dependent. You generally can't control that too far in TCP/IP.
09:30:48 <glguy> or explicit framing in the stream
09:41:23 <SavinaRoja> my naive attempt at the "tac" utility fails at being properly lazy http://lpaste.net/146702
09:46:44 <SavinaRoja> any advice on lazy efficient reverse file reading?
09:47:50 <obadz> Is there a way to declare operator (.^) with same infixity as (^) without hardcoding the infixity?
09:49:39 <phadej> obadz: maybe possible using templatehaskell
09:50:34 <obadz> this error is a pita:     Defaulting the following constraint(s) to type â€˜Integerâ€™ (Integral b0) arising from a use of â€˜^â€™
09:51:39 <phadej> obadz: ^ (5 :: Int) ?
09:52:00 <obadz> when you have to do it all over a big formula, it's really ugly
09:52:05 <hacker> obadz: also, defaulting exists for a thing, that warning can be safely ignored
09:52:11 <phadej> where five = (5 :: Int) ?
09:52:47 <obadz> phadej: hurts readability as well.. was trying to redefine (^)
09:52:56 <hexagoxel> SavinaRoja: readFile is in-order-lazy, i'd assume.
09:53:07 <obadz> where (^) = (^) :: Double -> Int -> Double
09:53:25 <hacker> obadz: just disable the warning
09:53:25 <phadej> obadz: or something like i2 = 2 :: Int;
09:53:38 <broma0> geekosaur: had to run somewhere right after i asked the question, but i managed to see your response. why do you suggest using <length><string> instead of a sentinel byte?
09:53:58 <KaneTW> ignoring defaulting warnings isn't a good idea imo
09:54:14 <obadz> where (^) = (Real.^) :: Double -> Int -> Double
09:54:33 <obadz> now I get a name shadowing warning
09:54:39 <obadz> hacker: is there a way to disable that locally ?
09:54:45 <obadz> hacker: without affecting the entire file ?
09:54:49 <phadej> obadz: unfortunately not yet
09:54:52 <KaneTW> not atm
09:55:11 <hacker> people answered before I could check the channel :P 
09:55:20 <KaneTW> obadz: can you add a type annotation somewhere that fixes the type
09:55:40 <KaneTW> expr :: Integer; expr = <some long thing>
09:55:43 <phadej> obadz: hide import of ^ from Prelude, i.e. import Prelude hiding ((^)); import qualified Prelude as P
09:55:48 <geekosaur> broma0, because I don't generally trust "this sequence of bytes will never occur" unless I am forcing that to be true
09:56:04 <obadz> KaneTW: can't as the exponent can have a type that's different from what's inside
09:56:10 <geekosaur> so either I define a byte stuffing protocol (ugh) or use length based encoding
09:56:12 <obadz> KaneTW: from expr
09:57:10 <geekosaur> defensive programming. *someone* will have ignored the rules in a way you (and aeson) need to account for...
09:57:33 <SavinaRoja> hexagoxel: yeah, I'm trying to see if there is a way to do reverse-order lazy
09:57:34 <broma0> geekosaur: but still, lets say im expecting the pattern <int><jstring>, i can't write a good parser for that because if there's some invalid json somewhere and i want to skip to the next  object, what do i look for?
09:57:51 <broma0> geekosaur: i guess just the next successful pattern match...
09:58:36 <geekosaur> ...
09:58:49 <broma0> geekosaur:  think i answered my own question..
09:59:09 <geekosaur> you skip the number of bytes in the length you sent before the string, and are resynced
09:59:21 <broma0> and if the length was invalid?
09:59:26 <broma0> defensive programming!
10:00:59 <geekosaur> you could in that case include a sentinel value before the length and look for it, recognizing that it could also occur in data so you might need to check if what follows makes sense and skip to the *next* one in that case
10:01:48 <geekosaur> but if you have control over encoding/decoding on both ends, you can at least fix a bug in that
10:02:15 <geekosaur> if you are either getting JSON from something else or generating JSON for something else that you do not control, fixing a bug in the thing you don't control is harder
10:02:31 <geekosaur> especially if it's a commercial program
10:02:50 <geekosaur> or j. random remote website whose API was designed by idiots >.>
10:03:08 <broma0> geekosaur: is a custom rolled procotol for a db-like program using TCP. I need some way to separate bytes represending JSON data...
10:03:33 <SavinaRoja> reading the source for tac.c in coreutils is interesting...
10:03:33 <broma0> i was thinking '0x00thisissomejsondata0xff0x00thisismoredata0xff' etc.
10:04:10 <geekosaur> if you are worried about the stream being modified in transit (errors or malice) then you are getting into message verification and stuff and you should look into network programming for security
10:06:14 <geekosaur> I *think* if you are using aeson on both sides then you can probably get away with NUL and since you seem desperate to use byte separators you can try to go with that
10:06:26 <geekosaur> it is not what I would do
10:07:51 <s4ke> question: if i have the call zipWith (+) [1,2,3,4,5] [1..] what are the different steps of lefmost outermost evaluation?
10:08:30 <s4ke> i have only found examples for evaluations with only one argument
10:09:09 <hexagoxel> SavinaRoja: i guess you'd have to write your own/modify `readFile` (if your input file is seekable; otherwise there is no way around caching everything, right?)
10:09:29 <durant_> Is haskell pure functional 
10:09:33 <s4ke> yes
10:12:49 <warbo> Hi, anyone know why I'm warned that this is overlapping http://lpaste.net/146714 . I can't see it myself. Using GHC 7.10.2
10:14:49 <emmanuel_erc> s4ke: You should take a look at the source code for zipWith (http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#zipWith)
10:16:04 <emmanuel_erc> s4ke: The evaluation should look like --> (+) 1 1 : (+) 2 2 : (+) 3 3 : (+) 4 4 : (+) 5 5 : [] 
10:17:21 <geekosaur> s4ke, have you seen the hood package?
10:17:24 <geekosaur> @hackage hood
10:17:24 <lambdabot> http://hackage.haskell.org/package/hood
10:17:57 <durant_> Does Haskell support the goto statement?
10:18:04 <tommd> @hoogle goto
10:18:06 <lambdabot> package GotoT-transformers
10:18:26 <tommd> You just need to be in a monad with goto...
10:18:36 <glguy> durant_: not as a primitive, but you can implement an environment that support goto
10:18:42 <hexagoxel> @hackage GotoT-transformers
10:18:42 <lambdabot> http://hackage.haskell.org/package/GotoT-transformers
10:19:14 <geekosaur> cut to the chase, introduce them to Cont :p
10:20:34 <SavinaRoja> hexagoxel: i've not found a proper tac written in haskell, so it might be that i would have to write it if I want it, or borrow the c util with System.Process
10:20:53 <emmanuel_erc> hey, I just finished the fourth puzzle for the Advent of Code programming challenges (adventofcode.com).
10:21:53 <emmanuel_erc> I used the ST Monad and I get the right answer, but it is incredibly slow, and I don't understand why...here's my submission (https://www.reddit.com/r/haskellquestions/comments/3vxjna/advent_of_code_day_4_spoiler_fyi/)
10:22:24 <emmanuel_erc> I can't seem to wrap my mind around how lazy evaluation throws a gear in the works here? Anyone have any suggestions?
10:25:29 <displace> hi, I have a ghc linking question, I am trying to generate a statically linked binary, and currently using "-optl-static -optl-pthread", but with chart-diagrams I am still getting an error
10:25:30 <durant_> What is the best place to download Haskell source code?
10:25:43 <Rembane> durant_: What kind of Haskell source code?
10:25:51 <durant_> For learning
10:26:13 <displace> (e.g., .stack/snapshots/i386-linux/lts-3.16/7.10.2/share/i386-linux-ghc-7.10.2/Chart-diagrams-1.5.4/fonts/SourceSansPro_R.svg: openFile: does not exist)
10:26:21 <kadoban> durant_: hackage or github come to mind
10:26:31 <displace> so /share/ isn't getting linked in. Is there another flag I can add to link that?
10:27:32 <s4ke> geekosaur, emmanuel_erc: thanks
10:27:35 <geekosaur> displace, that's not a linker error...
10:28:02 <geekosaur> it's a data file. I could not tell you how to get theright data file path off the top of my head, but linker options will not help
10:29:31 <displace> geekosaur: I see, so that file can't be just bundled into the binary I take it -- sorry, I probably assumed too much magic was possible. could I make a symlink and copy that file over? I'm not much of a unix person
10:30:24 <geekosaur> not sure what symlinks have to do with it. I'd imagine it needs all the fonts in .stack/snapshots/i386-linux/lts-3.16/7.10.2/share/i386-linux-ghc-7.10.2/Chart-diagrams-1.5.4/fonts/
10:30:30 <geekosaur> and possibly other data files near there
10:31:07 * hackagebot robots-txt 0.4.1.4 - Parser for robots.txt  https://hackage.haskell.org/package/robots-txt-0.4.1.4 (MarkWotton)
10:31:23 <geekosaur> in theory it *could* get linked in, but it would not be able to access it directly as a file, it would have to open itself with libelf and pull it out of whatever custom section you defined for it
10:31:31 <warbo> displace: is this what you're after http://neilmitchell.blogspot.co.uk/2008/02/adding-data-files-using-cabal.html ?
10:31:49 <geekosaur> warbo, I think they were hoping for a standalone program with no other data files
10:32:05 <geekosaur> but Chart-diagrams expects data files
10:32:42 <displace> warbo: thanks. but yes, as geekosaur guessed, I was naively hoping for a standalone
10:33:19 <displace> I am copying the binary to another location (an embedded x86 board) so I was wondering if I could create a symlink to that deep path, on the embedded board
10:33:39 <displace> so that when the binary tries to open that location, it actually gets a copy of the directory somewhere else
10:33:51 <tekkkz> Hello! I'm here again :D
10:33:55 <durant_> How do you make a line comment in haskell 
10:34:06 <geekosaur> --
10:34:06 <tekkkz> -- this is a comment
10:34:25 <tekkkz> hi geekosaur , you remember me?
10:34:51 <monochrom> IIRC ----- works too, generally a sequence of two or more -'s
10:35:19 <monochrom> there is a fine print, but you don't usually run into it
10:35:22 <ARM9> it's just --, any character following will be ignored until newline, so obviously --- the last - is just ignored
10:35:27 <pikajude> argh
10:35:36 <pikajude> how do I write a ReadS that matches a single character and returns nothing?
10:35:48 <monochrom> no, that's false, ARM9, and that's the fine print. --| is going to be an infix operator, not a comment starter
10:37:22 <ARM9> til
10:37:27 <tekkkz> For the guys who helped me yesterday: now i have a problem with tagsoup. a big error: http://ix.io/mHL -- it worked at my old code, but at my new code : http://ix.io/mHM it fails .. what is the error? I dont understand this...
10:38:40 <geekosaur> it needs you to give the string ("<table ...>") a type
10:38:50 <tekkkz> ? what do you mean?
10:38:58 <monochrom> the fine print is: "The sequence of dashes must not form part of a legal lexeme." (Haskell 2010 section 2.3)
10:39:07 <geekosaur> because OverloadedStrings doesn't give it any hints as to what you meant and strings don't have defaulting like numbers do
10:39:16 <monochrom> so "--|" is not a comment, "--a" is
10:39:25 <geekosaur> tekkkz, yoi're already doing the same thing 3 lines previous
10:39:35 <tekkkz> ahh
10:40:19 <tekkkz> geekosaur, how to find out what type it must have?
10:40:31 <geekosaur> I don't think it matters in this case
10:40:50 <tekkkz> so what type should i make it then??
10:41:06 <geekosaur> and it's short enough that you can get away with String, so use that
10:43:08 <tekkkz> geekosaur, thanks
10:51:54 <displace> somewhat unfortunately or luckily, just creating that directory structure, and copying and pasting the svg files works. so, I can live with it for now :)
10:52:42 <lingxiao> hey everyone 
10:52:45 <lingxiao> i havea  very basic question
10:53:00 <lingxiao> I havea  function of form `f :: Double -> [a] -> IO Float`
10:53:15 <lingxiao> and I'd like to put it in main and compile the file
10:53:17 <lingxiao> say the file is called algo
10:53:32 <lingxiao> is it possible to use it as `algo 12 [1..3]` on the commadn line?
10:53:59 <zett_zelett> Use getArgs for that.
10:54:03 <lingxiao> or am I stuck with like `main = { a <- read <$> getLine ; ... }` 
10:54:19 <zett_zelett> :t getArgs
10:54:21 <lambdabot> Not in scope: â€˜getArgsâ€™
10:54:24 <zett_zelett> Hm.
10:54:29 <nemesit|znc> can someone tell me what the \ x and \ y cause in this code? https://gist.github.com/nemesit/97125014e3a11509e7d9 bind is defined as bind p q ...
10:54:55 <zett_zelett> https://hackage.haskell.org/package/base-4.8.1.0/docs/System-Environment.html#v:getArgs
10:55:06 <breadmonster> nemesit|znc: Well, unless you tell us what bind is, we can't give you a *correct* answer.
10:55:17 <cswords> is there a formal semantics given for deepseq somewhere?
10:55:33 <breadmonster> But assuming you're talking about monads, bind :: Monad m => m a -> (a -> f b) -> m b
10:55:58 <breadmonster> nemesit|znc: so the \x and \y are just filling in for (a -> m b)
10:56:37 <nemesit|znc> added them https://gist.github.com/nemesit/97125014e3a11509e7d9
10:57:06 <breadmonster> cswords: Umm, you can see the package source if you like.
10:57:48 <breadmonster> nemesit|znc: Well, you have a monad instance there. It's easy to reformat seq.
10:57:49 <nemesit|znc> I'm confused why they work because bind is used as `bind` which should need too parameters right?
10:58:21 <breadmonster> sure.
10:58:41 <breadmonster> nemesit|znc: Let's just rephrase it.
10:58:51 <breadmonster> (>>=) for bind, and return for result, okay?
10:58:58 <nemesit|znc> ok
10:59:21 <lingxiao> zett_zelett so there's no way to use main on the command line as `main arg1 arg2 ... argn`?
10:59:47 <breadmonster> Then `seq p q = p >>= \x -> q >>= \y -> return (x,y)` correct?
11:00:12 <breadmonster> nemesit|znc: So the (>>=) operator is right associative.
11:00:43 <jle`> lingxiao: you can get command line arguments
11:00:48 <zett_zelett> First of all: I know next to no Haskell, so Iâ€™m not a good person to ask. Then: Do you mean apart from using getArgs? Because getArgs should allow this.
11:00:48 <jle`> using getArgs and functions like that
11:00:55 <breadmonster> This desugars into `p >>= (\x -> q >>= (\y -> return (x,y)))`
11:01:04 <nemesit|znc> so you simply assign p to x or its result?
11:01:24 <breadmonster> nemesit|znc: Now you can see that each thing has two operands.
11:01:35 <nemesit|znc> yeah
11:01:40 <koala_man> warbo: did you find out why it overlaps?
11:02:02 <breadmonster> nemesit|znc: That's why it works.
11:02:26 <nemesit|znc> interesting way to rewrite it into something understandable xD
11:02:41 <nemesit|znc> more or less xD
11:03:24 <breadmonster> Okay good.
11:03:50 <warbo> koala_man: nope; just ignoring the warning for now, the code seems to behave properly
11:04:39 <nemesit|znc> breadmonster: just started because some paper uses haskell, any good comprehensive starting guide?
11:05:03 <breadmonster> nemesit|znc: http://learnyouahaskell.com/
11:05:37 <nemesit|znc> thx
11:06:52 <warbo> koala_man: there are three cases: a list containing two elements, where the first is "Var"; a list containing two elements, where the first is "name"; a list containing three elements (which just-so-happen to be other lists). No way these should overlap
11:07:45 <warbo> koala_man: my guess is it might be a bug/known-issue to do with OverloadedStrings?
11:13:14 <{AS}> If Monads were not required to be Functors then an implementation of return+join would not be sufficient to have (>>=) right?
11:13:24 <tekkkz> geekosaur, »let td = Prelude.head $ sections (~== ("<td class='text'>" :: String)) tags« contains all tags starting at the first td tag. thats correct, but i want to get a specific td tag where the text is a special one .. how to find the correct tag?
11:13:37 <{AS}> While an implementation of return+(>>=) would be sufficient to have join?
11:14:12 <geekosaur> tekkkz, I know Haskell, I don't know the TagSoup library. sorry
11:14:29 <tekkkz> hm okay but maybe i can do it via the sections command .. any idea?
11:14:38 <tekkkz> or else : someoe an idea please?
11:14:42 <johnw> :t (>>= id)
11:14:50 <johnw> {AS}: you don't even need return to get join
11:14:52 <lambdabot> Monad m => m (m b) -> m b
11:15:13 <{AS}> johnw: Thanks, but what about the other way around?
11:15:35 <johnw> {AS}: but the other question is right; you need fmap or liftM (which is based on >>=)
11:15:46 <{AS}> Thanks again :)
11:16:01 <tekkkz> is it possible at tagsoup to make something like "where TagText = ... " ??
11:16:35 * {AS} now wonders whether there is any use of non-Functor-ial Monad-like things
11:19:11 <warbo> {AS}: return lets you "wrap" values into a type, join lets you collapse nested wrappers into one wrapper, fmap lets you apply a function inside a wrapper
11:19:49 <warbo> {AS}: not sure about uses of join without fmap, but return on its own forms "pointed" types
11:20:42 <{AS}> warbo: Thanks :)
11:20:45 <warbo> (of course, Applicative's pure does the same job as return ;) )
11:21:02 <{AS}> Actually I was wondering more from a more pedagogical point of view if I ever have to explain monads to anyone
11:21:23 <{AS}> Usually one says that Monads have two primary operators return + join (or return + bind)
11:21:27 <cswords> breadmonster: nah like formal semantics
11:21:32 <cswords> for a paper
11:21:48 <{AS}> but of course the first two operators are insufficient if you don't have the implicit assumption of fmap being there
11:22:49 <warbo> {AS}: well it depends on the context; if fmap is already understood/explained then fmap + join + return isn't so bad
11:23:30 <{AS}> Also I really prefer (=<<) but that is another story :)
11:23:47 <athan> {AS}: Me too :)
11:23:47 <lingxiao> does anyone here have experience optimizing for speed?
11:24:31 <athan> How does STM's strict `modifyTVar'` differ from `modifyTVar`? Are normal modifications postponed until the next `readTVar`?
11:24:43 <breadmonster> cswords: Ah, no :P
11:24:44 <tekkkz> geekosaur, any idea if i could make an filter call to get the right element of my list ?
11:25:48 <athan> ahh nevermind, the source shows all
11:27:16 <haskellNewbie> Hello! How can I get this result: [3,4,5] when I have a list [1..5], a condition (<4) and function (+2)? I tried (map (\x -> if condition x then function x else 0) but got [3,4,5,0,0]. I don't know what to write instead of 0.. thanks in advance!
11:27:44 <athan> haskellNewbie: `map`s are uniform, in that they can't delete or add elements :)
11:28:00 <athan> you could use a `filter`, but I'm guessing you want more insight into the functionality?
11:28:24 <athan> > filter (>= 3) [1..5]
11:28:26 <lambdabot>  [3,4,5]
11:28:32 <lingxiao> does anyone know where to import thte Statistics package by Bryan O'Sullivan from?
11:29:34 <int-e> > filter (<4) [1..5]
11:29:36 <lambdabot>  [1,2,3]
11:31:45 <haskellNewbie> thank you so much!!
11:33:50 <athan> :) np!
11:36:03 <athan> Do prolonged function applications (opposed to strict application via `$!`) benefit from fusion?
11:42:32 <tommd> lingxiao: Where?  import it into the module needing the functions provided by the statistics package.
11:42:38 <tommd> lingxiao: What are you actually asking?
11:42:47 <lingxiao> from where I meant
11:43:02 <lingxiao> it's not Math.Statistics, or Data.Statistics
11:43:07 <tommd> @hackage statistics
11:43:15 <lambdabot> http://hackage.haskell.org/package/statistics
11:43:26 <tommd> See that link.
11:43:43 <lingxiao> I looked but is still not sure
11:43:49 <lingxiao> where do I find the import path on that page?
11:44:01 <tommd> Under "Modules"
11:44:14 <tommd> Each of those modules can be used such as "import Statistics.Constants"
11:45:22 <lingxiao> ah i see thanks!
11:46:06 <tekkkz> I have following code: http://ix.io/mHS and here my question: how can i do this, that the "case" _ is not returning a "TagText "" " but is left out , so it gets lost ?
11:47:17 <johnw> athan: what is a "prolonged function application"?
11:48:50 <tekkkz> geekosaur, maybe you can help now cause general haskell?
11:53:21 <lingxiao> hey if someone could take a look at this question it'd be great :)
11:53:21 <lingxiao> http://stackoverflow.com/questions/34164793/optimize-this-bit-of-conduit-code-for-speed
11:55:25 <tekkkz> guys
11:55:31 <tekkkz> are you here?
11:56:01 <tekkkz> is it possible to return "nothing" from a function in a special case?
11:56:13 <tekkkz> filterTagText :: Tag ByteString -> Tag ByteString
11:56:13 <tekkkz> filterTagText tag@(TagText x) = tag
11:56:13 <tekkkz> filterTagText _ =
11:56:25 <tekkkz> where at the last "nothing" should be returned ..
11:56:46 <tommd> You're type needs to include some sort of nullary constructor.  For example, Maybe (Tag ByteString)
11:57:16 <tommd> tekkkz: Then ... = Just tag ; _ = Nothing
11:57:34 <tekkkz> hö? what?
11:58:04 <tommd> filterTagText :: Tag ByteString -> Maybe (Tag ByteString)
11:58:16 <tekkkz> ahh i see
11:58:16 <tommd> filterTagText tag@(TagText _) = Just tag
11:58:17 <tekkkz> yeah
11:58:21 <tommd> filterTagText _ = Nothing
11:58:26 <tekkkz> i didnt understood the type of nothing, sorry
11:58:33 <tekkkz> i had a look at it already
11:58:35 <tommd> Nothing is a "constructor" not a "type"
11:58:43 <tommd> It has the type "Maybe (Tag ByteString)"
11:59:12 <tekkkz> hm but still error
11:59:24 <tekkkz> ahh no
11:59:25 <tekkkz> sorry
11:59:26 <tekkkz> all great
12:00:26 <tekkkz> tommd, i have now the result: [Nothing,Nothing,Just (TagText "Host Name:"),Nothing,Nothing,No....  but how to throw all the "Nothing" away?
12:00:37 <tekkkz> do i need an extra function for that?
12:00:42 <tekkkz> such function i can design
12:01:13 <tekkkz> *cant
12:02:04 <tommd> tekkkz: Do you know the 'filter' function"
12:02:05 <tommd> ?
12:02:12 <tekkkz> yeah but i didnt used a lot yet
12:02:19 <tekkkz> could you show me the solution please
12:02:30 <tekkkz> its kind of difficult to make a filter for me at the moment
12:02:36 <kadoban> :t catMaybes
12:02:38 <lambdabot> [Maybe a] -> [a]
12:02:45 <tommd> tekkkz: I'd rather you find the solution.  I suggest you use filter a predicate that matches the tag constructor TagText.
12:02:53 <kadoban> > catMaybes [Nothing, Just 1, Nothing, Just 2]
12:02:54 <tommd> tekkkz: filter isTagText.
12:02:55 <lambdabot>  [1,2]
12:03:07 <obadz> any reason GeneralizedNewtypeDeriving couldn't derive a Traversable instance?
12:03:26 <kadoban> obadz: I don't think so, what's the error message?
12:03:28 <tommd> kadoban: But he's already starting from a cludge to get the Maybe - it shoudl be a boolean test.
12:03:31 <tekkkz> tommd, how to implement this in my code?
12:03:38 <tekkkz> sorry for stupid questions .. im new
12:03:39 <kadoban> tommd: Oh, my bad.
12:04:01 <obadz> Can't make a derived instance of â€˜Traversable Range1Dâ€™ (even with cunning newtype deriving): You need DeriveTraversable to derive an instance for this class In the newtype declaration for â€˜Range1Dâ€™
12:04:11 <obadz> kadoban: newtype Range1D a = Range1D { getRange1D :: [a]   } deriving ( Functor, Foldable, Traversable )
12:04:30 <lingxiao> has anyone used the par monad and experienced significant speed up in code?
12:04:33 <lingxiao> like 10x +
12:05:05 <lingxiao> on a machine like: 2.6 GHz Intel Core i5, 8 GB 1600 MHz DDR3
12:06:03 <Zekka|Sigfig> lingxiao: It would surprise me if it sped your code up that much on a machine with not at least 10 cores
12:06:10 * hackagebot tracy 0.1.0.0 - Convenience wrappers for non-intrusive debug tracing  https://hackage.haskell.org/package/tracy-0.1.0.0 (dredozubov)
12:06:43 <lingxiao> hahahha
12:06:47 <lingxiao> one can still hope
12:07:04 <lingxiao> Im grasping for straws here :(
12:07:11 <hacker> a 10x improvement from a less-than-10-cores machine comes from optimizing the algorithm, not parallelism 
12:07:44 <durant_> You should get a 8 core i7
12:07:45 <kadoban> obadz: It seems clear to me why it can't necessarily do that for you, but I can't seem to think of a good way to explain it :-/ Sorry.
12:08:10 <Zekka|Sigfig> lingxiao: Do you know why your program is slow? Like, are you using any data structures that arenâ€™t fast in your current case?
12:08:24 <lingxiao> http://stackoverflow.com/questions/34164793/optimize-this-bit-of-conduit-code-for-speed 
12:08:29 <lingxiao> here's the code  --^
12:08:32 <tekkkz> tommd, got it
12:08:33 <tekkkz> ty
12:08:49 <lingxiao> but most of it is just what ever conduit provides
12:09:10 <lingxiao> I would like to use a steraming library since the code will ultimately be tested in a streaming setting
12:09:21 <obadz> kadoban: lol, I'm not sure how to move forward with that :)
12:09:39 <Zekka|Sigfig> You could try a different data structure instead of lists but I donâ€™t actually know how large your lists are
12:10:03 <Zekka|Sigfig> Sequences have a very high constant factor, but length, splitting, dropping, taking, etc. is log time on them
12:11:08 <kadoban> obadz: Yeah, hopefully someone with a better knowledge base can come by and explain it (to both of us ;)
12:11:22 <Zekka|Sigfig> You might also be able to exploit the sharing behavior of a finger tree or something to make sums for â€™meanâ€™ etc faster to calculate â€” but I wouldnâ€™t rely on this unless I thought it was a big part of why my program was slow
12:11:23 <lingxiao> Zekka|Sigfig I'm using Conduit library's foldM to deconstruct the list
12:11:44 <Zekka|Sigfig> I donâ€™t have a good sense of why this program is slow so Iâ€™m just spitballing
12:12:03 <lingxiao> Zekka|Sigfig hmm actually you made a good poing
12:12:13 <lingxiao> I should profile before and after the list traversal
12:12:16 <durant_> Get a 850 evo ssd and 3400mhz ram
12:12:25 <lingxiao> erh i mean with and without
12:12:44 <tekkkz> tommd, and how do i make a second filter where it checks if a string has a special content, like: map fst . filter (\(_, str) -> ???) ztags  --> where ??? should be something like str=="test" ??
12:13:06 <obadz> kadoban: do you think GeneralizedNewtypeDeriving can ever derive Traversable?
12:13:48 <jle`> obadz: i think it should be able to, but deriving Traverasble defaults to DeriveTraversable mechanisms probably
12:14:20 <jle`> it should be able to derive traversable for your type using newtype deriving, but it wants to use it using the DeriveTraversable mechanism/plumbing
12:14:42 <jle`> i feel like the two instances should be the same
12:15:23 <jle`> ideally there would be a way to specify if you want the DeriveTraversable-derived instance or the GeneralizedNewtypeDeriving-derived instance, but the behavior is probably to always try to use DeriveTraversable in all cases
12:15:58 <jle`> obadz: oh wait, i didn't read the whole error
12:16:13 <jle`> don't listen to anything i said :)
12:16:22 <obadz> hmm ok :)
12:31:45 * hackagebot postgresql-orm 0.4.1 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  https://hackage.haskell.org/package/postgresql-orm-0.4.1 (AmitLevy)
12:38:43 <JagaJaga> How can I sort Data.Vector? :)
12:40:20 <jle`> JagaJaga: vector-algorithms has some sorting algos implemented
12:40:23 <jle`> @hackage vector-algorithms
12:40:23 <lambdabot> http://hackage.haskell.org/package/vector-algorithms
12:40:58 <JagaJaga> jle`: thank you.
12:41:20 <jle`> np
12:41:47 <oyvinrob> Hi!
12:42:20 <oyvinrob> Is there a way to do f <- readFile "whatever.txt"
12:42:36 <oyvinrob> as a function argument?
12:42:58 <obadz> oyvinrob: f <- readFile "whatever.txt" is a bit of do-expression
12:43:09 <obadz> oyvinrob: inside that do expression, f contains the contents of a while
12:43:21 <obadz> oyvinrob: which you can pass as argument to a function
12:43:40 <oyvinrob> yeah, thats what I have now
12:44:14 <oyvinrob> I am however, a onelineoholic, so i want to do the fileRead as the argument to the function where I use f
12:44:16 <geekosaur> you may be looking for liftA2 and friends. but, what probloem are you actually trying to solve?
12:44:42 <obadz> oyvinrob: myFunction <$> readFile "whatever.txt"
12:45:25 <obadz> :t (<$>)
12:45:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:49:48 <tekkkz> hello! how can i print out a type of my variable inside a do block ( like "print ??type?? var") than using :t var in ghci ?
12:50:13 <obadz> tekkkz: types are gone at runtime
12:50:21 <obadz> tekkkz: unless you use Typeable
12:51:04 <tekkkz> hm but i cant check it cause i create this variable inside a do block via let var = ... and so i cant do :t var 
12:51:10 <obadz> tekkkz: import Data.Typeable (typeOf)
12:51:11 <tekkkz> you know what my problem is?
12:51:37 <obadz> you can do let var = ... in ghci
12:51:39 <obadz> and :t var ..
12:51:45 <obadz> ghci is a giant do-block
12:52:15 <tekkkz> yeah no
12:52:34 <tekkkz> cause when i do my var assignments outside of my file's function's do block, i fails
12:52:35 <tekkkz> xD
12:52:46 <tekkkz> so how does typeOf works? how to print it out?
12:52:58 <obadz> it implements Show so you can just print it out
12:53:16 <tekkkz> so: print typeOf var ??
12:53:23 <obadz> but honnestly it's a bit silly to print something at runtime that can be statically figured out
12:53:28 <obadz> :t typeOf
12:53:29 <lambdabot> Typeable a => a -> TypeRep
12:53:38 <obadz> > print (typeOf "abc")
12:53:41 <lambdabot>  <IO ()>
12:53:52 <obadz> > typeOf "abc"
12:53:54 <lambdabot>  [Char]
12:54:11 <oyvinrob> obadz: so main = print . sum . map myFunction <$> readFile "whatever.txt" should work?
12:54:20 <tekkkz>     No instance for (Data.Typeable.Internal.Typeable a0)
12:54:21 <tekkkz>       arising from a use of ‘typeOf’
12:54:28 <oyvinrob> obadz: where myFunction :: Char -> Int
12:55:07 <verement> tekkkz: if you annotate the var with var :: _ then recent GHC will tell you the type when you compile
12:55:24 <obadz> verement: cool I didn't know that
12:55:28 <tekkkz> hm
12:55:34 <obadz> oyvinrob: no
12:55:48 <tekkkz> dont know what you are talking about, here my code: http://ix.io/mHW
12:56:25 <tekkkz> what type does ztext has?
12:57:00 <tekkkz> [Integer ByteString] ?
12:57:14 <tekkkz> [(Integer, ByteString)] ?
12:57:16 <obadz> oyvinrob: readFile "whatever.txt" >>= return . sum . map myFunction >>= print
12:57:46 <verement> tekkkz: append ":: _" to that line and try compiling
12:58:03 <tekkkz> to which?
12:58:11 <verement> tekkkz: let ztext = ...
12:58:50 <jf2> hey guys, i'm trying to figure out this ambiguous types problem with parsec : http://stackoverflow.com/questions/34165691/haskell-parsec-commenting-out-parsefromfile-call-leads-to-ambiguous-types
12:59:06 <obadz> tekkkz: I think it's [ (Int, ByteString) ]
12:59:11 <tekkkz> yup
12:59:21 <oyvinrob> obadz: awesome, thanks!
12:59:24 <tekkkz> how to get [ (Int, String) ] from it?
12:59:34 <obadz> tekkkz: unpack the bytestring
13:00:00 <jf2> is there a "right" way to make explicit that I'm using strict versions of combinators?
13:00:20 <lingxiao> has anyone benchmarked runtimes for pipes vs conduit?
13:00:32 <geekosaur> jf2, the type can be inferred only when it all gets connected together, which parseFromFile does. otherwise it can't tell which of several possible types the Stream could be
13:01:19 <jf2> geekosaur is there something i can do other than include parseFromFile?
13:01:45 <geekosaur> haskell has a mechanism to resolve this for numeric types (defaulting) but it can't be used with other types or when any but a small number of typeclasses are invovled (and there are several such in a parsec parser's type)
13:01:47 <jf2> type annotating my parsing functions is awkward because the types as reported by ghci include some hidden types
13:01:52 <jf2> like Data.Functor.Identity.Identity...
13:02:02 <geekosaur> usually we just don't bother in that case
13:02:17 <obadz> tekkkz:
13:02:17 <geekosaur> but you may be able to use ParsecT if you must annotate
13:02:18 <tekkkz>   Couldn't match type ‘GHC.Word.Word8’ with ‘Char’
13:02:18 <tekkkz>     Expected type: String
13:02:19 <tekkkz>       Actual type: [GHC.Word.Word8]
13:02:19 <tekkkz>     In the expression: unpack str
13:02:19 <obadz> :t Data.Text.unpack . Data.Text.Encoding.decodeUtf8
13:02:21 <lambdabot> BSC.ByteString -> String
13:03:04 <jf2> geekosaur i use ghci to check the types and end up with things like
13:03:12 <jf2> ParsecT String u Data.Functor.Identity.Identity [Char]
13:03:17 <tekkkz> obadz, the unpack is not working. which do i need?
13:03:36 <obadz> tekkkz: see above
13:03:46 <tekkkz> nope
13:04:02 <tekkkz>  Couldn't match expected type ‘Text’ with actual type ‘ByteString’
13:04:02 <tekkkz>     In the first argument of ‘Data.Text.unpack’, namely ‘str’
13:04:12 <obadz> :t Data.Text.unpack . Data.Text.Encoding.decodeUtf8
13:04:14 <lambdabot> BSC.ByteString -> String
13:05:01 <jf2> not the end of the world to add imports and annotations
13:05:07 <jf2> but it does add some line noise
13:05:10 <geekosaur> jf2, try Parser instead then
13:05:26 <tekkkz> what is BSC?
13:05:27 <geekosaur> Parser String () [Char]
13:06:04 <geekosaur> tekkkz, Data.ByteString.Char8
13:06:30 <jf2> geeokosaur Parser is applied to too many type arguments
13:06:42 <geekosaur> type Parsec s u = ParsecT s u Identity
13:06:52 <geekosaur> sorry I meant Parsec
13:06:58 <geekosaur> Parser is even smaller, yes
13:07:14 <geekosaur> I think it defaults the user state type to ()
13:07:32 <geekosaur> (that's the "u" in your types)
13:08:00 <tekkkz> nonon its not imported and would at its import destry everything cause i have Lazy already
13:08:16 <geekosaur> tekkkz, there's also a Lazy version of it
13:08:25 <tekkkz> yeah
13:08:31 <tekkkz> but htere i have error: 
13:08:37 <tekkkz>  Couldn't match type ‘GHC.Word.Word8’ with ‘Char’
13:08:42 <geekosaur> jf2, so Parsec is ParsecT with the base monad being Identity, and Parser is Parsec with the user state being () (both of those amounting to "nothing")
13:08:51 <tekkkz> at
13:08:51 <tekkkz> getStr :: Tag ByteString -> String
13:08:51 <tekkkz> getStr tag@(TagText str) = unpack str
13:08:51 <tekkkz> getStr _ = ""
13:08:57 <geekosaur> tekkkz,  yes, that's the Char8 part
13:09:17 <tekkkz> so what must i do to fix the posted function?
13:09:25 <geekosaur> note that it is actually the same type, it's just that functions that would normally use Word8 will use Char instead (and may truncate if you are not cautious)
13:09:43 <geekosaur> Data.ByteString.Lazy.Char8.unpack
13:10:13 <tekkkz> Not in scope: ‘Data.ByteString.Lazy.Char8.unpack’
13:10:37 <jf2> geekosaur that works but it looks like magic to me.
13:10:48 <geekosaur> yes, because  as you were told before you need to import it
13:11:21 <obadz> tekkkz: btw you should ask yourself why you're switching to String (a linked list of Chars..)
13:11:22 <jf2> geekosaur So Parsec s u Identity is the same thing as ParsecT String u Data.Functor.Identity.Identity [Char] ?
13:11:38 <tekkkz> ahh ty
13:11:40 <jf2> beekosaur I'm not even sure what the latter thype is supposed to indicate..
13:11:46 <tekkkz> obadz, i need it for an other ffunction
13:13:10 <geekosaur> jf2: no, ParsecT String u Data.Functor.Identity.Identity [Char] is Parsec String u [Char]
13:13:46 <tekkkz> maaaahn
13:14:22 <tekkkz> why is here this error: let n = Prelude.map fst . Prelude.filter (\(_, str) -> strEq str "Latitude:") ztext      ------> error: http://ix.io/mHX
13:14:34 <tekkkz> i give up ...
13:14:39 <tekkkz> what did i wrong now?
13:14:40 <tekkkz> q.q
13:15:25 <geekosaur> what it told you: Possible cause: â€˜Prelude.filterâ€™ is applied to too many arguments
13:15:37 <tekkkz> it isnt
13:16:00 <geekosaur> and the reason it says that is that you are assuming what you wrote means the same as:  let n = (Prelude.map fst . Prelude.filter (\(_, str) -> strEq str "Latitude:")) ztext 
13:16:15 <geekosaur> when it in fact means:  let n = Prelude.map fst . (Prelude.filter (\(_, str) -> strEq str "Latitude:") ztext) 
13:16:20 <tekkkz> argh
13:16:21 <tekkkz> yay
13:16:24 <tekkkz> ^^
13:16:25 <geekosaur> which is a *function* and therefore takes at least one more parameter
13:16:29 <tekkkz> sorry
13:16:31 <tekkkz> im tired
13:16:34 <tekkkz> already
13:16:51 <geekosaur> (begiinners do trip over that all the time)
13:17:05 <tekkkz> hehe
13:17:10 <geekosaur> function compoisition is not a way that most non-functional programmers think
13:17:12 <tekkkz> im going to sleep for today now
13:17:24 <tekkkz> thanks foral lthe help today
13:17:28 <tekkkz> thanks geekosaur 
13:17:31 <tekkkz> cu tmr, bye
13:20:23 <jf2> geekosaur thanks. I'm still learning... what is the role of Functor.Identity.Identity in a type specification?
13:20:49 <geekosaur> the T on the end of ParsecT is a convention identifying it as a monad transformer
13:21:12 <geekosaur> you would set it on top of IO to parse from a file, for example
13:21:46 <geekosaur> if you are not parsing from a file or etc. then you still need some monad for the transformer to sit on top of; Identity is a "null monad" that does nothing
13:21:51 <geekosaur> so it's suitable for those cases
13:22:29 <geekosaur> (by the same convention, the version without the T suffix is a type alias which does that for you)
13:25:40 <kommentierung> hey, can someone quick look over my code (5 lines) there is one syntax error :/
13:25:58 <Rembane> kommentierung: Yes! Pastebin it!
13:26:19 <kommentierung> data SimpleBT a = Empty | Leaf a | Node (SimpleBT a) a (SimpleBT a) deriving (Eq, Ord, Show)   insLeaf :: a -> SimpleBT a -> SimpleBT a insLeaf x Empty		 = Leaf x insLeaf x (Leaf m)	| m < x     = Node (Leaf x) m Empty 					| otherwise = Node Empty m (Leaf x)	
13:26:23 <kommentierung> well this did not work x)
13:26:33 <kommentierung> http://lpaste.net/146743
13:26:34 <shachaf> Use hpaste.org
13:26:38 <shachaf> Don't paste code in here.
13:27:52 <geekosaur> um, that's some interesting indentation
13:27:57 <geekosaur> Haskell is indentation-sensitive
13:28:42 <kadoban> They're tabs :(
13:28:46 <kommentierung> winhugs tells me the problem is in line 5
13:29:07 <kadoban> kommentierung: You're going to have a bad time using tabs in haskell, configure your editor to use spaces instead.
13:29:11 <jf2> can parsec parsec straight to Text, or does it always have to parse to String and then get packed to Text?
13:29:45 <geekosaur> Text.Parsec.Text
13:30:05 <geekosaur> that's why ParsecT is that complex...
13:30:22 <geekosaur> so it ends up being ParsecT Text ... instead of ParsecT String ...
13:31:06 <kommentierung> okay, done. now i get this error "Syntax error in declaration (unexpected `;', possibly due to bad layout)" for line 6
13:31:23 <jf2> how come in your Parsec s u ... type definition
13:31:29 <jf2> Parser doesn't appear at all?
13:31:51 <geekosaur> jf2, because Parser is just another type alias
13:31:52 * hackagebot haskell-src-meta 0.6.0.13 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.6.0.13 (GeoffreyMainland)
13:32:10 <kadoban> jf2: For the same reason that String doesn't appear in [Char]
13:32:11 <jf2> geekosaur what is Parser a type alias for?
13:32:31 <geekosaur> ParsecT String () Identity
13:33:13 <kadoban> jf2: Parsec is probably the one you want unless you know/care what all the weird extras are for.
13:33:16 <geekosaur> so a parser from a String (as opposed to Text or ByteString), with no user-defined state, and not on top of a monad that can do I/O
13:33:18 <kadoban> Parser*
13:34:00 <danilo2> Hello guys! :) I've noticed that when using newtype haskell evaluates its value lazy, but then using datatypes with "bangs", the value is strict, but we cannot use strictness annotations within newtypes. I was always thinking that newtypes are in most cases compile - time only, but thinking more about this behavior raised my concerns - which case - newtypes vs datatypes with single, "banged" data - will be faster in most cases?
13:34:07 <geekosaur> so you need to read from a file and parse the resulting String, as opposed to using a stream parser that can itself read as it goes (note that laziness means you *may* still get that behavior --- but you need to be more careful to do it)
13:34:51 <jf2> geekosaur when I try to switch from String to Text, looks like there are a bunch of clashes with my use of Char combinators like char 'x'
13:36:17 <jf2> geekosaur so whereas previuosly my type signatures looked like "Parsec String () [Char]", I guess I should change it to "Parsec Text () Text"? I guess the "u" type is throwaway somehow? (sorry i know i'm pretty confused here...)
13:36:18 <geekosaur> you may need to check your other types or possibly your imports
13:36:38 <geekosaur> you know how I keep mentioning a user state type?
13:36:41 <geekosaur> that is "u"
13:36:46 <geekosaur> most often you don't need it
13:37:10 <geekosaur> the main reason you would need it is so that changes to it are undone if the parser needs to backtrack (see "try")
13:37:57 <geekosaur> and yes, if you are using a Text stream then you will get Text out, not [Char] which is the same as String
13:38:26 <jf2> eesh sorry as a noob, this is brutal =/ thanks for your help
13:39:13 <geekosaur> you do seem to have jumped headfirst into the deep end, yes :)
13:39:20 <jf2> i thought i was getting the hang of parsec after getting a parser working but clearly a lot of the abstraction is over my head
13:39:55 <jf2> geekosaur what's worse is that this is my first pass at this, once I get this working, I think I'll have to re-figure it out with attoparsec, then attoparsec-pipes.
13:40:24 <jf2> geekosaur i started with parsec because there's more documentation around to lean on
13:40:52 <jf2> geekosaur but the files i'm parsing will probably require something more performant. trying to get this prototype working first though.
13:41:03 <kommentierung> ok, its works now. can i use this code, with some changes of course, to add multiple leafs? http://lpaste.net/146743
13:42:29 <kadoban> jf2: IIUC attoparsec basically has less of the abstraction stuff that seems to be confusing you. It's less flexible, in ways that you probably won't mind and might actually appreciate. The only thing is, it usually gives worse error messages when something fails to parse.
13:43:28 <jf2> kadoban maybe i should've just skipped to that...
13:44:46 <kadoban> Possibly. Though I usually just use parsec and ignore the parts I don't understand well. Haven't had to figure them out yet, my parsers tend to be pretty simple.
13:45:58 <jf2> my parser is pretty simple
13:46:03 <sm> people say megaparsec has more docs and better errors than parsec, now
13:46:08 <jf2> it's actually working if i follow the type annotation magic
13:46:15 <jf2> i'm trying to go from string to text now though
13:46:41 <jf2> kadoban anticipating some of the performance issues i'll have to tackle...
13:47:01 * hackagebot postgresql-schema 0.1.9 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.9 (markfine)
13:47:16 <zett_zelett> Is it correct to say that, in order to perform effectful computation in Haskell, there are a bunch of actions defined as monadic values or monadic maps somewhere deep in the GHC.IO modules which use some arcane features of the compilers, and all ordinary Haskelleres do is combine these actions and maps by the means of bind, join etc.?
13:47:36 <athan> A nonce cache, for lookups, should be in the pico-second range, shouldn't it?
13:50:41 <athan> I made a weird time-based map last night: https://github.com/athanclark/timemap/blob/master/src/Data/TimeMap.hs
13:50:57 <jf2> kadoban geekosaur hmm for this  simple combinator: sanity = many (char 'x') it works if I annotate it as Parsec String () String, but I get a type error if I try Parsec Text () Text
13:50:57 <ReinH> danilo2: What do you mean 'using newtype haslell evaluates its value lazy"? Can you give an example?
13:51:12 <athan> the idea is that you'd want a mutable container that you could lookup and delete from, indexed by some unique key, but you'd also want to "clean up" entries that are old
13:51:21 <jf2> many and char are imported from Text.ParserCombinators.Parsec
13:51:22 <athan> the cleanup is really fast, but the inserts are pretty slow :\
13:51:24 <ElMoloko> are there any checkpointing libraries?
13:51:36 <jf2> is there another place I'mn supposed to import from for Data.Text?
13:52:01 * hackagebot SciFlow 0.3.0 - Scientific workflow management system  https://hackage.haskell.org/package/SciFlow-0.3.0 (kaizhang)
13:52:02 <ReinH> danilo2: The whole point of newtypes is to remove the indirection added by data constructors so that, e.g., Sum 1 is just as performant as 1 because they have literally the same runtime representation
13:52:15 <athan> jf2: Text /= String
13:52:30 <athan> Strings are lists of characters, and `many` is something that creats lists of things
13:53:01 <athan> so, `char` says "match this only char", and `many` says "match this thing as many times as you can (including 0 times)"
13:53:04 <jf2> athan ok how would i achieve a similar functionality using Text? Or should I just parse everything as String and then use pack at the end ?
13:53:05 <geekosaur> hmmm
13:53:09 <geekosaur> I am not sure you can do that
13:53:10 <athan> so in essence, you're building a list of characters :)
13:53:14 <geekosaur> because those are the parsec2 versions
13:53:25 <geekosaur> wich may not grok Text
13:53:39 <athan> jf2: Well, that's the catch - to parse something character by character, String is really the best you can get
13:53:43 <geekosaur> Text.Parsec (without the ParserCombinators) is the modern interface
13:53:57 <athan> after you make a successful parse, you can always pack it into a Text again for later processing
13:54:16 <geekosaur> and I think for many it will still be [Char]
13:54:28 <athan> but just remember - String allows for characters to be distinguished from one another, while Text is a more low-level memory image of the textual data
13:54:43 <geekosaur> because it's logically returning a list of the results of some other thing, so it will be [Char] regardless of the stream type
13:54:59 <athan> oh woah, sorry geekosaur 
13:55:17 <athan> I didn't know there was Text support o_0
13:55:18 <sm> zett_zelett: perhaps slightly better: it's not a bunch of predefined actions, rather all IO actions ultimately go through one special unsafePerformIO action provided by GHC. (And the type system keeps track of which actions are IO actions). But basically yes, most ordinary haskellers just combine actions
13:55:25 <geekosaur> it can't treat [Char] differently from a list of some other thing
13:55:43 <sm> slightly less ordinary haskellers define new kinds of actions and new ways of combining
13:55:56 <geekosaur> so if you need a Text from it then you'll need to pack it back into a text
13:56:09 <danilo2> ReinH: I've just figured it out :) Heh everything is like it shoud. So my concerns were invalid. I've got here a data build out of many nested newtypes and "error" inside. I was printing it and it was printed in a srange way (first few newtype names were printed and then error on a data type with strictness annotation. But I realized that the behavioru in fact is good, because in the last datatype, there were also newtypes nested, 
13:56:22 <geekosaur> athan, that was a large part of parsec 3.x
13:56:37 <geekosaur> supporting streams other than just String
13:56:37 <jf2> athan geekosaur ok String it is. Maybe I was getting ahead of things...
13:56:52 <danilo2> ReinH: I know it sounds strange but I wanted to describe it shortly. Anyway I just prove myself that newtypes are working as they should and my previous question was simpli incorrect :)
13:57:01 <kommentierung> Does this work? http://lpaste.net/146743
13:57:04 <danilo2> ReinH: Thank you for trying to help me figuring it out! :)
13:58:54 <jf2> geekosaur athan i'm guessing this will be dependent on downstream analysis, but is it worth it performance-wise to keep in-memory data structures as Text, using a pack at the end of a parsec parse?
13:59:21 <merijn> jf2: Probably it's not very important
13:59:34 <merijn> jf2: Parsec is not really designed for very efficient parsing, tbh
14:00:12 <jf2> alright parser is working now! now to convert this all to attoparsec...
14:00:24 <merijn> jf2: Parsec is designed for parsing things where reasonable error handling is important (i.e. program source, let's face it, source files are tiny and require decent error reporting)
14:01:00 <merijn> jf2: attoparsec on the other hand is designed for speed at all cost (i.e. your errors boil down to "it failed", without much more output, which should be fine if you're doing e.g. protocol parsing)
14:01:11 <geekosaur> and athan was right about one thing: if you're doing a bunch of "char"s then you're going to have [Char] all over the place anyway, Text or no
14:01:55 <merijn> jf2: In exchange attoparsec gives you things like dedicated slice operators: "takeWhile :: (Char -> Bool) -> Parser Text" will directly blit chunks of text around, not building an intermediate list first
14:02:01 * hackagebot quiver 1.1.3 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.1.3 (patrykz)
14:02:17 <jf2> well i'm chunking through multiple 10gb+ files so...
14:02:25 <merijn> geekosaur: Not with attoparsec, attoparsec has combinators for grabbing chunks of Text directly without going through [Char]
14:02:55 <kommentierung> rembande http://lpaste.net/146743 does this code work?
14:02:59 <geekosaur> merijn, my point was more using the "char" parser. I suspect attoparsec still has that; you'd need to rewrite in terms of the chunked parsers to take advantage
14:03:01 <jf2> actually I'm thinking I probably have to move this to attoparsec-pipes so that the parsing is not all in batch. but i think i'll port it to attoparsec first.
14:03:03 <ga2arch> hi, i find myself in need of an hashmap that allows two different keys to refer to the same value, is there some cool data structure that allows to implement it in O(1) or i'm stack with using multiple maps ? 
14:03:19 <ga2arch> s/stack/stuck
14:03:44 <merijn> jf2: Ideally you'd use the "(Char -> Bool) -> Parser Text" combinators of attoparsec as much as possible if you want speed/efficiency
14:03:55 <athan> ga2arch: I just had to implement something like this
14:04:09 <athan> I ended up just using two maps (sorta), pointed to a single TVar
14:04:16 <athan> it's pretty messy, though :\
14:04:21 <ga2arch> yep :(
14:04:28 <jf2> merjin: thanks I thnk that's kindof what i'm missing in vanilla parsec
14:04:39 <ReinH> danilo2: yw
14:04:50 <athan> you always end up lookup-up twice
14:05:01 <athan> or using one map as a primary one
14:05:02 <merijn> jf2: attoparsec docs actually have some notes on performance at the top
14:05:47 <merijn> jf2: Your 10gb files are, I assume, basically just streams of small chunks?
14:05:59 <nilg> I must be missing something but I really don't understand how to convert numbers within this package http://hackage.haskell.org/package/numbers-3000.2.0.1/docs/
14:06:27 <ga2arch> athan: yeah i know, hoping there was something better 
14:06:27 <jf2> merjin er what docs are you referring to? I see https://github.com/bos/attoparsec
14:06:51 <merijn> jf2: If so I would write a parser for a single chunk and then use pipes-attoparsec to repeatedly parse 1 chunk
14:06:58 <merijn> jf2: The docs on Hackage
14:07:24 <merijn> @hackage attoparsec
14:07:24 <lambdabot> http://hackage.haskell.org/package/attoparsec
14:10:39 <jf2> merjin i thought you meant notes as in some documentation all I see here is that it's meant to be fast...
14:11:49 <kadoban> jf2: Click on whichever module sounds like the one you want. https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html for example.
14:13:44 <jf2> kadoban ah. how to choose between ByteString and Text, is there a substantial performance difference?
14:14:24 <geekosaur> about the same. the main difference is that a ByteString maps to an octet stream like you'd get over the network
14:14:28 <geekosaur> a Text is Unicode text
14:14:49 <geekosaur> if you're not doing Unicode handling, you may well want ByteString. if you *are* doing Unicode, ByteString will make you very sad
14:15:16 <nilg> It seems the only way to convert a CReal to a Float is to first convert it to a String, then convert that string into a Float, this sounds insane, there must be a direct way...
14:15:43 <jf2> geekosaur files fall within ascii
14:15:57 <jf2> geekosaur so i guess that means ByteString
14:16:23 <broma0> with conduit, how can i map a effectful computation? Something like mapOutput but with an argument (a -> m b)
14:16:31 <kadoban> jf2: Are they actually ASCII, or are you just incorrectly assuming they're ASCII? The later is annoyingly common.
14:16:33 <geekosaur> :t realToFrac
14:16:35 <lambdabot> (Fractional b, Real a) => a -> b
14:16:43 <geekosaur> nilg ^^
14:17:22 <jf2> kadoban no i think i have pretty good guarantees, this is a data format, not logs or anything like that.
14:17:24 <dfeuer> Is Bryan O'Sullivan still active? He doesn't seem to have responded to any GitHub issues for the configurator package in quite some time.
14:17:53 <kadoban> jf2: Okay, fair enough.
14:17:53 <nilg> geekosaur: I just found it in the same time by looking at the type class instances :-)
14:18:31 <jf2> kadoban geekosaur hmm now if i'm chunking across 10-20 gigs of raw text data, does that mean i should be using pipes in some way so i don't have to pull the entire thing into memory?
14:18:35 <nilg> BTW, how to get all the functions supported by a certain type (all the ones "inherited" from type classes)?
14:18:48 <kadoban> jf2: pipes or conduit, yeah.
14:18:50 <jf2> kadoban geekosaur or is it common for attoparsec to deal with something this large (on a laptop-sized machine)
14:19:22 <merijn> dfeuer: He is...very busy and responds rather slowly
14:19:33 <jf2> i'm thinking of trying this https://hackage.haskell.org/package/pipes-attoparsec
14:19:48 <geekosaur> yeh, I get the impression bos is usually in one-armed paper hanger mode
14:19:51 <kadoban> jf2: IIUC you can get by just using lazy IO, but it's easy to screw up and kind of unprincipled. It's better to use one of pipes or conduit.
14:19:54 <jf2> hmm looks a bit obscure though
14:19:54 <alkabetz> nilg: :i ClassName in ghci will get you that
14:20:15 <merijn> jf2: Yeah, like I said, I'd write a parser for a single "chunk" of input (whatever that maybe) and then use pipes to repeatedly grab chunks of input, stuff them into your parser and get parser chunks out
14:20:28 <merijn> jf2: Might wanna look at the Pipes library which has a good tutorial
14:20:33 <geekosaur> alkabetz, I think they want to see not the typeclasses but the functions
14:20:58 <jf2> merjin so i should probably do this from scratch. pipes-attoparsec looks a bit sketchy (seems to have few watchers)
14:20:59 <dfeuer> Thanks, merijn. If anyone else is interested in configurator, its `empty` function is totally bogus, and its `lookup` and `lookupDefault` functions seem clearly to be lazier than they should be, although the exact extent to which they are too lazy is up for discussion....
14:21:08 <geekosaur> ":i CReal" would show you all the instances but you'd have to then :i all of those to see the functions. and then :i thei "superclasses" etc
14:21:09 <dfeuer> s/function/value
14:21:45 <geekosaur> and no, I don't know of a good summary; the number of possible functions explodes rather quickly withe.g. the numeric hierarchy
14:21:58 <nilg> hmm, OK, thanks
14:22:21 <Rembane> dfeuer: That explains why Configurator didn't work for me. Thank you!
14:22:36 <dfeuer> Rembane, eh? What exactly are you referring to?
14:23:09 <Rembane> dfeuer: The laziness of configurators' lookup and lookupDefault.
14:23:33 <dfeuer> Rembane, oh? Did it use up your memory?
14:23:46 <merijn> dfeuer: afaict bos mostly works on his important core packages (text, attoparsec, etc. and even those can take a week or so to get a response) the rest is in a sort of "whenever I get to it" maintenance mode.
14:24:03 <Rembane> dfeuer: I can't really remember, I think it just didn't load things.
14:24:06 <phadej> dfeuer: http://www.haskellcast.com/episode/010-bryan-osullivan-on-performance-and-efficiency/ the last 5 minutes of podcast answer your question Ã–=
14:24:10 <phadej> :)
14:24:19 <Rembane> dfeuer: I solved it by using YAML for config files instead.
14:25:07 <nilg> realToFrac (3.0 :: CReal) returns an exception (Exception: CReal.toRational)
14:25:40 <geekosaur> sigh. CReal is a pain sometimes
14:25:54 <phadej> merijn: the https://github.com/bos doesn't look like "1-2 week". As there aren't shade of green for the last two month :(
14:26:20 <geekosaur> also I'm not sure the inefficiency of going through String si any worse than the inefficiency of CReal (you pay a price for arbitrary precision)
14:26:55 <geekosaur> (that price being why people put up with the bizarreness of floating point; at least it's fast)
14:27:39 <merijn> geekosaur: Also, predictable for sufficiently knowledgeable values of predictable :p
14:28:17 <merijn> People seem to underestimate the amount of care put into IEEE754 in terms of guaranteeing numerical predictability
14:28:57 <geekosaur> I think it's more that most people have a different notion of predictability
14:29:24 <geekosaur> flapping least significant digits don't fit that notion, for example :)
14:29:30 <sm> nilg: just curious, what's the reason you're using the numbers lib ?
14:29:30 <exio4> I dislike NaN 
14:29:38 <StoneToad> I think that's at least partially because of the unpredictable interperetation that different hardware has done with it
14:30:11 <dfeuer> phadej, soundcloud doesn't really work so well on my system. Can you give me a vague sense of what you're pointing to about that BOS Haskellcast?
14:30:32 <dfeuer> oh wait, I fixed it.
14:30:34 <dfeuer> sort of.
14:32:02 * hackagebot timemap 0.0.0 - A mutable hashmap, implicitly indexed by UTCTime.  https://hackage.haskell.org/package/timemap-0.0.0 (athanclark)
14:33:14 <athan> :D
14:33:28 <nilg> sm: I'm calculating second order distributions (distributions over probabilities) with insane precision, but then I need to plot the final results, which is why I need to convert to Float
14:34:00 <nilg> anyway, it seems I'm able to do that with BigFloat, but not with CReal.
14:34:14 <geekosaur> (also noting that most people inappropriately conflate accuracy, precision, etc.)
14:34:16 <nilg> CReal was taking too much time anyway, so maybe it's for the better
14:35:48 <nilg> geekosaur: I know well the difference between accuracy and precision is the classification domain, but in the floating point number domain, I really don't
14:36:12 <geekosaur> that was more aimed at merijn 
14:37:00 <lostman> does anyone know how ghc releases make it to stack? I was trying compiler: ghc-7.10.3 today (released few days ago) but stack complains it can't parse version number. ghc-7.10.2 works fine
14:42:02 * hackagebot webapp 0.1.0 - Haskell web scaffolding using Scotty, WAI, and Warp  https://hackage.haskell.org/package/webapp-0.1.0 (natesymer)
14:43:06 <phadej> lostman: you can use --skip-ghc-check atm
14:47:50 <sm> woah, my new favourite haddock page: https://hackage.haskell.org/package/diagrams-contrib-1.3.0.8/docs/Diagrams-TwoD-Factorization.html
14:49:54 <Flonk_> Looking at http://zvon.org/other/haskell/Outputprelude/Num_c.html it seems Num needs an Ord and a Show instance, but the ghc source needs none. Is this a Haskell 98/2010 thing?
14:50:26 <athan> sm: It has been so long since I've seen colors...
14:50:32 <Flonk_> And why would Num require Show anyway?
14:50:55 <athan> Outputprelude?
14:52:19 <int-e> Haskell98 did indeed have Show as a prerequisite for Num. I'm not sure whether the reason was convenience or fear of expensive dictionary passing...
14:52:43 <glguy> Haskell2010 also has Eq and Show as superclasses of Num
14:53:14 <athan> ..what is sam-hill?
14:53:21 <glguy> People wanted to make Num instances for things that didn't support Eq or Show
14:53:27 <jf2> gotta go for dinner
14:53:40 <Flonk_> glguy: Oh, I see
14:53:41 <jf2> thanks for all the parsec help guys!!
14:54:29 <kgadek> hi all. is it possible to run two WAI apps simultaneously? like: Yesod on :3000 and servant on :5000 ?
14:54:39 <cow_2001> i have no clue how to debug this thing :(
14:54:40 <bgamari> kgadek, sure
14:54:47 <kgadek> bgamari: any pointers? :)
14:54:54 <kgadek> my google-fu failed this time
14:55:08 <bgamari> kgadek, well, what server are you using?
14:55:11 <bgamari> warp?
14:55:17 <bgamari> If so, http://hackage.haskell.org/package/warp-3.1.10/docs/Network-Wai-Handler-Warp.html
14:56:07 <athan> kgadek: Usually the port number is a literal interger we supply to the `run` or `scotty` functions
14:56:30 <kgadek> oh wait, I meant: two WAI from one binary
14:56:32 <athan> so long as your computer isn't already using them, you should be fine :)
14:56:33 <bgamari> kgadek, in the case of servant in particular, http://hackage.haskell.org/package/servant-server-0.4.4.5/docs/Servant-Server.html
14:56:41 <kgadek> I suspect I need to forkIOâ€¦ or not?
14:56:52 <bgamari> kgadek, ahh; I would imagine there would be no problem
14:57:02 * hackagebot wai-session-alt 0.0.0 - An alternative session middleware for WAI.  https://hackage.haskell.org/package/wai-session-alt-0.0.0 (athanclark)
14:57:13 <athan> kgadek: Oh okay, yeah forkIO should do the trick
14:57:22 <kgadek> so forkIO is the wai (pun intended :) )
14:57:28 <kgadek> great!
14:57:33 <athan> I'm actually not sure if `run` forks on it's own :s
14:57:35 <bgamari> kgadek, Typically your framework's `server` function would block, so you'll need to fork
14:57:45 <bgamari> ahem, `serve`
14:57:55 <bgamari> e.g. Servant.Server.serve
14:58:11 <bgamari> or rather Network.Wai.Handler.Warp.run
14:58:40 <kgadek> would it suffice to use forkIO or rather full-fledged forkProcess?
14:59:21 <bgamari> kgadek, forkIO should be fine
14:59:32 <kgadek> athan, bgmari: great! thank you both :)
14:59:42 <athan> np!
14:59:53 <bgamari> kgadek, for the record though, forkProcess is much different than forkIO
15:00:14 <bgamari> kgadek, forkProcess is essentially the unix fork system call
15:00:17 <nilg> Woohoo! Haskell is awesome, I've been able to compute my distribution using BigFloat where I couldn't in Maxima (which has the supposed type bfloat, but isn't big all the way)
15:00:35 <kgadek> bgamari: yes, exactly, while forkIO is lightweight thread
15:00:36 <bgamari> kgadek, there are two variants of lightweight thread forking... forkIO and forkOS
15:00:50 <bgamari> typically you need not worry about forkOS
15:03:17 <kgadek> bgamari: roger that :)
15:24:02 <c_wraith> forkOS only matters when making ffi calls to libraries that use thread local state. 
15:29:28 <nilg> I want my haskell program to exit only if I press a key, any idea?
15:30:46 <zoku> try control-C
15:30:48 <zoku> :p
15:31:01 <zoku> (sorry I dunno a legitimate answer)
15:31:28 <benzrf> how would you do it in another language, nilg?
15:32:56 <nilg> in C I would till it reads something
15:33:05 <nilg> "I would loop"
15:33:29 <nilg> hmm, I'm sure there must be an idiomatic way in Haskell...
15:33:42 <johnw> you'd recurse until it reads something
15:34:11 <Adeon> :t getChar
15:34:12 <lambdabot> IO Char
15:34:33 <Adeon> I guess this is not exactly what you are looking for
15:34:44 <Adeon> you need to press enter specifically
15:36:57 <nilg> Ah :-) http://stackoverflow.com/questions/23220389/haskell-loop-until-a-key-is-pressed
15:38:23 <Cale> nilg: See also forever
15:39:15 <Cale> nilg: You can capture any sort of loop you'd want into a definition -- the trouble is, there are too many small variations and just recursing usually isn't so bad
15:47:04 * hackagebot graphmod 1.2.8 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.2.8 (IavorDiatchki)
16:14:08 <tomus> how would one convert Matrix (RVar Double) to RVar (Matrix Double)?
16:14:51 <johnw> that could imply that Matrix is Traversable; if so, then you could use 'sequence' 
16:14:52 <Welkin> :t sequence -- taruti_ 
16:14:53 <Welkin> er
16:14:54 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:14:54 <Axman6> possibly with traverse/sequenceA, but I don't know what an RVar is
16:15:00 <Welkin> :t sequence -- tomus 
16:15:01 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:17:11 <tomus> thank you guys
16:17:35 <Cale> That's actually a pretty sophisticated transformation if you think about what it means (I'm assuming RVar is random variable) :)
16:17:50 <Cale> But yeah, sequence
16:19:17 <tomus> Cale: it is
16:19:27 <tomus> (random varaible)
16:19:57 <Axman6> yeah it's a little unclear what that transformation means
16:20:18 <Axman6> any reason to not use Matrix (RVar Double)?
16:22:47 <tomus> Axman6: well... I want to use sample
16:23:02 <tomus> once
16:23:29 <tomus> to get IO (Matrix Double)
16:23:53 <tomus> not sure why I want that instead of Matrix (IO Double)?
16:24:07 <tomus> seems IO at the front as more natural
16:24:22 <Axman6> sure, makes sense.
16:24:47 <pdkr> tomus: this expresses that "a random matrix filled with numbers" is defined as "a matrix filled with random numbers"
16:24:57 <pdkr> or vice versa i suppose
16:25:35 <pdkr> (where "matrix filled with numbers" is bullshit language for "matrix")
16:26:31 <c_wraith> I can fill a matrix with letters. 
16:26:59 <pdkr> c_wraith: i can call your letters numbers
16:28:35 <c_wraith> you can do that, but it doesn't change the semantics. it's a word search semantically, even if you can implement it as a sequence search 
16:32:57 <tomus> how would one "moneky path" IO to be instance of MonadRandom
16:34:07 <tomus> import Data.Random.Source.IO()
16:34:15 <tomus> found it
16:34:24 <tomus> I find it a bit weird
16:37:12 <tomus> ah, that's the feature Haskellers are proud of: ability to make existing data type instances of new classes?
16:37:58 <tomus> (like extensions methods in C#, though I don't code in C# and might be talking rubbish)
16:43:50 <Cale> tomus: I'm not sure if you'd say "proud of", but it is a feature of type classes that you can make existing data types instances of new classes (and vice-versa)
16:50:17 <tomus> Cale: I just remember LYAH mentioning something along this lines, though I am not sure, hence "proud"
16:50:27 <johnw> tomus: there are two cases of it to consider
16:50:35 <johnw> when you define instances along with the type you've created, good
16:50:42 <johnw> when you define instances for a type you didn't create, not so good
16:50:52 <johnw> the latter is called an "orphan instance", and we are not proud of those
16:51:25 <tomus> johnw: so Data.Random.Source.IO() created an orphan instance then? just to be sure
16:51:40 <johnw> in that case, they created the type class, so it's not bad
16:51:48 <johnw> I guess that makes a third case, actually, that isn't an orphan
16:52:06 <tomus> johnw: what did you mean then?
16:52:14 <johnw> if I, in my own Main.hs, create an "instance MonadRandom IO", I'd frown at myself
16:52:27 <AdrianG> wow. 1510 nicknames.
16:52:32 <tomus> ok, cheers
16:52:54 <Bashmetim> Haskell's movin' up in the world
16:52:57 <AdrianG> so many users, why is haskell still useless?
16:53:02 <Bashmetim> That's it, C++ is finished!
16:53:12 <johnw> AdrianG: that's an odd way to ask a question here
16:53:13 <AdrianG> c++4lyf
16:53:16 <Bashmetim> Say good-night Java
16:53:39 <Bashmetim> adriang: wow, what an inopportune place to pick *that* fight
16:54:14 <AdrianG> there is only one true religiou.
16:54:17 <AdrianG> religion.
16:54:24 * AdrianG joins #LISP
16:54:29 <Bashmetim> The religion of computability?
16:54:46 <nshepperd> "the one true religion is religion"
16:55:43 <Bashmetim> "the one true religion is this religion, which is false"
16:56:02 <Bashmetim> Hey, now everything's true!
16:56:48 <nshepperd> "when preceded by its quotation is the one true religion" when preceded by its quotation is the one true religion
16:57:03 <pdxleif> Someone once asked me "So, can you implement fizzbuzz in it?" once I had tried explaining Haskell to them, with its immutability / purity and all...
16:57:27 <AdrianG> sounds like you immutable and purely, did not get the job.
16:57:29 <Welkin> pdxleif: yeah... just ignore those people
16:57:34 <pdxleif> It's fizzbuzz complete, I guess.
16:57:47 <hpc> i used haskell to implement blub
16:58:10 <Bashmetim> pdxleif: Obviously not. Fizzbuzz has a Turing degree of, like, 4
16:58:38 <pdxleif> During my interview at Janrain, I asked the CEO "Why Haskell?", and he said something to the effect of "smart dev bait".
16:59:13 <AdrianG> at least he knows how to flatter underpaid fools
16:59:14 <Bashmetim> Nice. I bet that works well, actually
16:59:27 <pdxleif> Pretty sure FizzBuzz couldn't pass the Turing Test.
16:59:27 <kadoban> pdxleif: Heh.
16:59:35 <Bashmetim> adriang: aw, you think I deserve a raise?
16:59:43 <Bashmetim> thanks babe, u 2 <3
16:59:58 <AdrianG> is u gay
17:00:06 <pdxleif> Bashmetim: It worked on me. But I ended up doing mostly JRuby & Scala... :/
17:00:26 <pdxleif> Get a room, you two.
17:00:49 <AdrianG> why so many ppl here.
17:00:59 <exio4> because there are a lot of haskellers
17:01:01 <AdrianG> why not clisp? or even clojure ? (vomits)
17:01:08 <Bashmetim> Because haskell tickles our collective fancy
17:01:23 <AdrianG> thats not an answer, its more of a restated question
17:01:26 <pdxleif> This is where people come to troll; this room's exclusively filled with trolls.
17:02:07 * hackagebot pandoc-crossref 0.1.6.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.6.0 (lierdakil)
17:02:49 <nshepperd> aren't there plenty of people in the clojure room too?
17:03:04 <AdrianG> nshepperd: only 700,
17:03:17 <AdrianG> 50% less effective to troll there.
17:03:21 <nshepperd> oh, i guess it must be inferior then
17:03:40 <hpc> when i joined this channel hovered around 650 users
17:03:59 <hpc> time flies
17:04:08 <Bashmetim> Maybe the number of haskellers is staying the same, but IRC is making a huge comeback
17:04:10 <nshepperd> AdrianG: so are you ready to start learning haskell?
17:04:23 <AdrianG> nshepperd: almost
17:04:29 <nshepperd> @where learnhaskell
17:04:29 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:04:33 <Bashmetim> let adrianG = repeat 
17:04:36 <nshepperd> ^^ this is the best tutorial
17:04:37 <AdrianG> lol
17:04:39 <Bashmetim> let adrianG = repeat "WHINES"
17:04:42 <exio4> Bashmetim: not really, I started learning it a year and half ago, or so
17:05:29 <Guest80113> Is the right place to ask for a hand or should I go somewhere else?
17:05:46 <Bashmetim> guest80113: go for it!
17:05:50 <ReinH> Guest80113: if you have a Haskell question, you can ask it here.
17:06:45 <Guest80113> Ok, I'm attempting to make a function that returns a number from the normal distribution.. Using the Box-Muller transform
17:07:17 <Guest80113> However I'm getting some weirdness going on, I've compared my code so some of that in the MonadRandom module and it's similar but not working
17:07:44 <tomus> Guest80113: lpaste?
17:08:21 <Guest80113> Give me a moment, bit new to the whole irc thing.. Just spotted a link as you said that..
17:08:47 <tomus> lpaste.net
17:09:36 <Guest80113> http://lpaste.net/1094387774741544960
17:09:46 <Guest80113> Sorry for the delay
17:11:59 <AdrianG> how much are rates for haskell devs these days
17:12:26 <johnw> it's entirely depends on the job
17:12:41 <AdrianG> yes, but is there a range
17:12:54 <johnw> not a reliable one
17:13:00 <johnw> we're talking about the whole world here
17:13:21 <AdrianG> nyc/london/etc
17:13:30 <johnw> you show me a job offer, and a CV, and between the two I could probably guestimate a range
17:13:37 <johnw> otherwise, I wouldn't even want to hazard a broad guess
17:14:01 <AdrianG> 900 usd/diem rates
17:14:06 <AdrianG> it seems, judging from the UK market
17:14:42 <kaste> for a freelancer?
17:15:23 <johnw> that would be a pretty high salary -- I'd expect financial market -- but for a freelancer, not bad
17:15:41 <johnw> problem with Haskell freelancing is finding consistent work
17:16:07 <AdrianG> tiny market.
17:16:09 <johnw> you're dealing with a language most non-engineers have never heard of
17:16:37 <c_wraith> My ideal job is getting paid to teach professional haskell use.  Why won't anyone hire me? I have experience and everything! :)
17:17:03 <johnw> since you didn't give an amount, I'm pretty sure you could fulfill that dream easily :)  HackHands.com has a Haskell section
17:17:48 <AdrianG> why would anyone want to pay you to do that
17:18:15 <c_wraith> AdrianG: to support their massive in-house haskell project that they're hiring lots of junior engineers to maintain.
17:18:16 <AdrianG> lol hack hands is a scam.
17:18:29 <tomus> Guest80113: you were just missing braces
17:18:29 <AdrianG> 1:1 help is almost useless.
17:18:32 <tomus> http://lpaste.net/1094387774741544960
17:18:33 <johnw> I've instructed C++ users through hackhands, it worked out fine
17:18:51 <Guest80113> Really?! Oh deary me
17:18:53 <tomus> Guest80113: and you forgot Random a in you constraint
17:19:03 <AdrianG> johnw: what kind of questions?
17:19:14 <AdrianG> i cannot see this being useful except for helping to avoid most basic issues.
17:19:20 <Guest80113> I should probably go to sleep, I've been working on this Assignment for too long.. Thank you for the help!
17:19:25 <johnw> AdrianG: all kinds
17:19:49 <tomus> Guest80113: return (-2 * log u') * cos (2 * pi * u'') was interpreted as (return (-2 * log u')) * cos (2 * pi * u''
17:20:09 <AdrianG> johnw: all kinds of basic issues?
17:20:16 <johnw> no, advanced usage as well
17:20:20 <AdrianG> most difficult problems cannot be assisted with 1:!
17:20:21 <AdrianG> 1:1
17:20:24 <johnw> for example, an issue with weak references in STL containers
17:20:28 <AdrianG> advanced usage, such as?
17:20:46 <AdrianG> oic
17:20:51 <johnw> anyway, this isn't the place to debate the utility of hackhands; I just wanted to mention that you could make money at Haskell education there
17:21:06 <Guest80113> tomus: Thank you for the help, I noticed that you removed the :: Double in the u' and u'' definition as well, wouldn't that just return 0 or 1?
17:21:10 <c_wraith> For my actual job, I'd love a place where I can ask advanced questions about ruby semantics and get an answer other than "why do you need to know? just copy & paste the code of stack overflow."
17:21:25 <AdrianG> johnw: what is your hourly rate on hackhands, for that c++ type of scenario?
17:21:35 <johnw> AdrianG: $2/min
17:21:41 <linduxed> guys i'm having a total lapse here
17:22:22 <tomus> Guest80113: Return a randomly-selected value of type a in the range [lo,hi]. See randomR for details.
17:22:25 <tomus> https://hackage.haskell.org/package/MonadRandom-0.4.1/docs/Control-Monad-Random-Class.html
17:22:31 <linduxed> what was the syntax for saying "there's now a type called Coordinate that corresponds to a tuple consisting of two integers"?
17:22:46 <linduxed> data Coordinate = (Int, Int)?
17:23:00 <johnw> type Coordinate = (Int, Int)
17:23:10 <johnw> or, newtype Coordinate = Coordinate (Int, Int)
17:23:18 <johnw> or, data Coordinate = Coordinate Int Int
17:23:34 <c_wraith> Yeah, a type synonym seems most likely to be what you mean, but beware.  Type synonyms don't give any type safety, only documentation.
17:24:01 <linduxed> johnw: the final one won't be a tuple though, right?
17:24:09 <johnw> they're all equivalent to 2-tuples
17:24:13 <c_wraith> linduxed: it'll have the same runtime representation as a tuple
17:24:33 <Guest80113> tomus: my confusion was with the definition being in terms of a's (polymorphic types? although correct me if I'm wrong)... When testing it in ghci it only gave int results (ie 0 or 1)
17:24:35 <johnw> but the type will not unify with (Int, Int), nor would the second one
17:24:48 <linduxed> c_wraith: ok
17:24:49 <c_wraith> linduxed: but they will be very different types, so you will get actual type safety
17:25:07 <johnw> Personally, I'd recommend the third option unless you have a compelling reason not to
17:25:22 <linduxed> this is a very good point, yes
17:25:26 <linduxed> yes
17:25:32 <linduxed> the type safety is a big plus
17:25:36 <linduxed> i'll run with the last one
17:25:57 <linduxed> also, should I use Int?
17:26:01 <tomus> Guest80113: main :: IO ()
17:26:01 <tomus> main = do n <- normal :: IO Double print n
17:26:06 <linduxed> or is Integer/Integral better?
17:26:14 <tomus> blah, I'll use lpase
17:26:15 <johnw> linduxed: start with Int
17:26:18 <linduxed> ok
17:26:41 <johnw> linduxed: until you find you need to range of Integer.  Using Integral in this context will be more painful than it sounds
17:27:00 <Guest80113> tomus: I think I'm going to have to do a bit of reading.. Realised now if I run it with 0.0 and 1.0 it gives a Double typed output
17:27:21 <montagy> a function need 3 parameters, i have a list with 3 elements,how to apply?
17:27:21 <tomus> Guest80113: http://lpaste.net/146761
17:27:52 <johnw> that is, while you *could* build a tuple type containing Integrals values, they would of necessity be abstract values whose only interface would be Integral; you wouldn't know the underlying type of them
17:28:19 <lamefun> Is this how Haskell I/O code supposed to look? http://lpaste.net/146762
17:28:25 <c_wraith> montagy: no better approach than to just unpack the list and apply the function to the unpacked arguments.  After all, what if the list doesn't have 3 elements?
17:28:39 <Guest80113> tomus: Thanks again for the help!
17:28:48 <charmander_> Is there a better way to write `f >=> return . g`?
17:28:53 <tomus> np
17:29:03 <johnw> fmap g f
17:29:20 <c_wraith> johnw/linduxed:  Also, you get no more information from a pair of polymorphic Integral values than you do from a pair of Integers
17:29:29 <exio4> @type \f g -> fmap g . f 
17:29:30 <lambdabot> Functor f => (a -> f a1) -> (a1 -> b) -> a -> f b
17:29:39 <exio4> @type \f g -> f >=> return . g 
17:29:41 <lambdabot> Monad m => (a -> m b) -> (b -> c) -> a -> m c
17:30:19 <montagy> c_wraith, yes, i think so,thanks
17:30:26 <exio4> c_wraith: "fmap g . f" works :P
17:30:38 <charmander_> Whoops. Thank you.
17:30:41 <johnw> ah ".", thanks
17:31:21 <c_wraith> exio4: err?  what?  :P
17:31:59 <exio4> er, charmander_.. 
17:32:18 <exio4> sorry c_wraith, I didn't see your nick and just assumed nick completion went to the correct nick <_<
17:32:57 <johnw> a c_wraith and a charmander_ both sound like creatures from the Monster Manual
17:36:22 <alphonse23__>  swaggler here?
17:37:49 <charmander_> And the broader one: a shorter way to write `breakOn c = sequenceA . second (fmap snd . uncons) . break (c ==)`, to split [a] on a into Maybe ([a], [a])?
18:01:58 <lamefun> Can I do IO in less ugly way? http://lpaste.net/171975043197173760
18:13:57 <pavonia> Is there a way to get rid of that 't' parameter in the bar function? http://lpaste.net/146764  It's not needed for the functionality of bar and only there to prevent type errors
18:15:55 <dramforever> pavonia: you could use a multiparam typeclass and use functional dependencies
18:17:40 <pavonia> dramforever: Wouldn't that lead to the same problem?
18:18:13 <pavonia> I though type families are just the modern version of functional dependencies
18:18:54 <geekosaur> there are differences
18:18:56 <dramforever> pavonia: Well, I thought a key type and a value type uniquely determine a map type
18:19:26 <pavonia> Yes
18:19:46 <dramforever> however a type family like yours only says that a map type uniquely determins a key type and a value type
18:20:26 <Cale> pavonia: There's a fair bit of overlap in what they accomplish, but they do it differently enough that both have their place.
18:20:36 <pavonia> Could that bijection be expressed with type families too?
18:20:54 <Cale> With type equality constraints...
18:21:24 <ackthet> why isn't take more polymorphic, maybe something like Integral a => a -> [b] -> [b]
18:21:43 <Cale> ackthet: No especially good reason.
18:21:47 <pavonia> :t genericTake
18:21:49 <lambdabot> Integral i => i -> [a] -> [a]
18:22:09 <pavonia> Cale: How would that look like on my sample?
18:22:12 <pavonia> *in
18:22:14 <ackthet> Cale: no logic to the madness?
18:22:17 <Cale> It should at least use Integer rather than Int imo.
18:22:25 <ackthet> yeah its super annoying
18:22:34 <ackthet> fromIntegeral as far as the eye can see
18:23:00 <ackthet> pavonia: interesting about genericTake, but, again, why not just one <_<
18:23:08 <Cale> ackthet: Even worse is when you miss a fromIntegral and something which really needs to be Integer quietly gets turned into an Int
18:23:12 <dramforever> just ... why would someone have a list that is:
18:23:20 <dramforever> > maxBound :: Int -- this long
18:23:22 <lambdabot>  9223372036854775807
18:23:26 <ackthet> Cale: indeed :(
18:23:44 <ackthet> thats why i try and be as explicit as possible
18:26:15 <Cale> pavonia: So in your example, you want t to be uniquely determined by k and v?
18:26:31 <pavonia> Yes, and vice versa
18:26:35 <Cale> pavonia: actually, that doesn't seem right...
18:26:49 <Cale> At least, with the given instance in place
18:27:01 <Cale> That would mean that there's only ever once instance of the class
18:27:08 <Cale> -> you shouldn't use a class
18:27:24 <pavonia> There are several other instances too
18:28:17 <Cale> Okay, so suppose I see that k = Integer, how do I know whether to use the instance for FooBar Integer v, or some other instance?
18:29:07 <Cale> It might help me to suggest something more reasonable if these classes were not called Foo and Bar, and I knew what the operations really were.
18:29:09 <pavonia> The example is a simplyfied version, all instances will user unive key and value types
18:29:16 <Cale> ah, okay
18:29:30 <Cale> So, you could add:
18:29:36 <Cale> type KeyFoo k :: *
18:29:43 <Cale> type ValueFoo v :: *
18:29:50 <Cale> to the class declaration of Foo
18:30:36 <pavonia> I need to add type parameters k and v then too, right?
18:30:38 <Cale> and then add a constraint to the class declaration which said something like  (FooKey (KeyFoo k) ~ k, ...) => Foo t
18:31:07 <Cale> Oh, right, it should just be  type KeyFoo :: * -> *
18:31:52 <Cale> hmm
18:31:57 <Cale> Let me try some things
18:32:03 <Cale> There's a way to do this, it's just annoying
18:32:34 <pavonia> Okay, I'm trying too :p
18:41:05 <lamefun> How can I improve this code? http://lpaste.net/5194231188906049536
18:41:20 <lamefun> Or is this how to do I/O in Haskell?
18:42:41 <Cale> lamefun: I commented on your post last time
18:42:50 <Cale> lamefun: What's with all the TextLocale stuff?
18:43:11 <Cale> lamefun: whatever works works, but I would look into using the filepath library for manipulating paths
18:44:22 <Cale> lamefun: But also, why are you writing this function? There exist functions for getting the entries of a directory already.
18:44:31 <Cale> Unless I'm missing something.
18:47:16 <Cale> pavonia: perhaps something like this (see annotation) http://lpaste.net/146764
18:47:29 <Cale> pavonia: but I really don't know what foobar is supposed to do or mean :P
18:48:10 <Cale> That might still have problems, I dunno
18:48:17 <Cale> This would all be much easier with a real example :P
18:48:31 <Cale> I hate simplified nonsense :P
18:49:12 <pavonia> I wanted to avoid unnecessary code
18:50:38 <pavonia> Ah dammit, my compiler is too old for that /o\
18:50:52 <pavonia> "The current implementation of type families does not support equality constraints in superclass contexts."
18:51:53 <Cale> Oh, in that case, just use fundeps :P
18:52:02 <Cale> It'll probably come out looking nicer anyway
18:52:19 <Cale> As soon as you have to do this kind of shenanigans, type families start to suck
18:53:11 <pavonia> Cale For understanding, why did you define the KeyFoo/ValueFoo familes out of the class?
18:53:29 <Cale> Because indeed as you pointed out, they depend on an additional variable
18:53:33 <Cale> which isn't in scope
18:53:37 <zoku> i'm a bit mixed up about this monad transformer
18:53:41 <zoku> how do I get it back to IO?
18:53:49 <zoku> Couldn't match expected type â€˜IO ()â€™
18:53:49 <zoku>                 with actual type â€˜Control.Monad.Trans.Reader.ReaderT
18:53:49 <zoku>                                     (IRCState s0) IO ()â€™
18:54:31 <Cale> zoku: runReaderT theAction myIRCState ?
18:55:09 <pavonia> Cale: I see. Thanks for the code anyway, I trying with fundeps then
18:55:12 <Cale> zoku: That looks exactly like the sort of thing which I would never use a monad transformer for
18:56:21 <zoku> I have to admit i have no clue what I'm doing
18:56:23 <Cale> Using a naked ReaderT over IO instead of just adding a function parameter is usually just going to be inconvenient and annoying.
18:56:24 <zoku> http://lpaste.net/3132749751292788736
18:56:26 <zoku> this is my whole code
18:56:40 <zoku> this library is using state within a readerT
18:56:45 <zoku> so I can't exactly avoid using that
18:56:52 <Cale> ah, fair enough
18:57:08 <zoku> but the library I'm tying it into expects a simple IO () action
18:57:16 <pavonia> zoku: Where's the error line?
18:57:17 <lamefun> Cale, that's beside the point, I forgot what POSIX readdir does, thought that it reads name and status in one go. But why does it still have to look so hideous?
18:57:20 <zoku> lines 38-39 are the issue
18:57:57 <Cale> lamefun: What's beside the point? That you're reimplementing low level directory reading shenanigans for no apparent reason? :)
18:58:00 <zoku> http://lpaste.net/150758862532640768
18:58:03 <zoku> here's the full error ^
18:58:57 <Cale> lamefun: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/directory-1.2.2.0/src/System-Directory.html#getDirectoryContents
19:00:02 <Bruuuuno> why does hlint suggest the use of liftM, wouldn't be fmap better anyway on a recent compiler?
19:00:50 <pavonia> zoku: Looks lke the type of sendIRC is actually :: String -> IRC ()
19:01:03 <pavonia> Or whatever sendBS yields
19:01:26 <zoku> right, my given type is wrong
19:01:32 <zoku> that's just the type I want it to return :p
19:01:43 <geekosaur> Bruuuuno, fmap woul almost always be better. ghc 7.10 just remoes the "almost"
19:01:44 <zoku> for reference:
19:01:44 <zoku> :t sendBS
19:01:44 <zoku> sendBS
19:01:44 <zoku>   :: irc-conduit-0.1.2.0:Network.IRC.Conduit.Internal.Messages.IrcMessage
19:01:44 <zoku>      -> StatefulIRC s ()
19:01:46 <lambdabot>     Not in scope: â€˜sendBSâ€™
19:01:46 <lambdabot>     Perhaps you meant â€˜endByâ€™ (imported from Data.List.Split)
19:01:52 <geekosaur> plase don't paste into the channe;
19:01:53 <zoku> whoops
19:01:55 <zoku> sorry
19:02:24 <duycuong> hi all!
19:02:52 <Cale> zoku: You're probably meant to mostly write things in this StatefulIRC s monad.
19:03:05 <geekosaur> zoku, why exactly do you want to have it in IO?
19:03:13 <geekosaur> as opposed to IRC monad?
19:03:20 <zoku> because the other library I am using expects IO ()
19:03:23 <Cale> zoku: and then run the resulting StatefulIRC s computation somehow at the top level
19:03:23 <zoku> Yogurt
19:03:28 <geekosaur> or StatefulIRC or
19:03:39 <Cale> zoku: Check to see if StatefulIRC s is an instance of MonadIO
19:03:43 <geekosaur> perhaps you want to use liftIO to access that library
19:03:51 <Cale> If it is, then you can use  liftIO :: IO a -> StatefulIRC s a
19:03:52 <geekosaur> it is, liftIO is already used in other parts of that program
19:04:00 <Cale> ah yeah
19:04:00 <geekosaur> in that monad
19:04:37 <zoku> that gives me a different error
19:04:46 <zoku> liftIO $ sendIRC msg
19:04:56 <Cale> no
19:05:00 <Cale> That's the wrong direction
19:05:08 <zoku> oh
19:05:09 <Cale> liftIO turns IO actions into IRC actions
19:05:26 <geekosaur> no, ou want that function to use StatefulIRC. when you access your oither library (*Yogurt) which wants IO, you use liftIO
19:05:29 <Cale> You don't go the other way until the top level where the initialisation stuff happens
19:05:57 <geekosaur> and liftIO runs it in IO as it wants
19:12:29 <lamefun> Cale, that's nearly the same code as mine... still ugly.
19:12:41 <Cale> lamefun: But the good part is you don't have to write it :P
19:13:31 <Cale> lamefun: You can generally expect anything which interacts with the lower level posix stuff to be kind of awful because posix is awful.
19:15:19 <Cale> lamefun: My recommendation is not to do so insofar as it can be avoided. Querying directory contents is something that you can usually do using the stuff in System.Directory, or if that's insufficient, you can almost certainly find something appropriate and cross-platform on Hackage already.
19:21:43 <geekosaur> there's actually good reason to not provide stat information with the filenames
19:21:52 <geekosaur> consider doing that over a network filesystem over a slow link
19:22:18 <duycuong> -
19:22:40 <geekosaur> getting just the names is fairly fast. stat()ing them... NFS has some support for that, IIRC CIFS, and certainly other network filesystems, do not
19:23:04 <geekosaur> and for global network filesystems (AFS, Globus, ...) that could be *extremely* expensive
19:24:31 <geekosaur> so the idea is you get the list, and that gives you a chance to maybe whittle it down to a small number of things you are actually interested in and only stat() those, to minimize the cost
19:26:23 <geekosaur> (also even NFS did not have the bulk stat stuff when this was standardized)
19:27:29 <Bruuuuno> I have to update an array a lot of time, would using an immuable array cause a bottleneck? I'm currently using Data.Map and it's really slow
19:33:55 <Cale> Bruuuuno: If you're doing lots of updates, you'll be allocating lots of complete immutable arrays
19:33:59 <Cale> (i.e. taking copies)
19:34:27 <Cale> How large are your maps?
19:34:47 <Bruuuuno> 1000*1000, I'm doing the day 6 of advent of code
19:45:17 <bollu> how do uninhabited types "work"
19:45:26 <bollu> in the sense that, why do they type check in the first place?
19:45:38 <bollu> (How to the type variables in HM unify when you have an uninhabited type?)
19:47:55 <pavonia> Is this the first year of that Advent of Code thing? I've never heard of it before, and suddenly there are questions about it in all channels
19:48:42 <Bruuuuno> I think so yeah
19:51:15 <lingxiao> hey all
19:51:32 <lingxiao> has anyone done a codensity transformation and saw improvments in performacne?
19:51:44 <lingxiao> I'm about to invest some time into this paper: http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
19:51:58 <lingxiao> and they say:
19:51:59 <lingxiao> We demonstrate this by
19:51:59 <lingxiao> examples for which the complexity is reduced from quadratic to linear
19:55:06 <Welkin> Lambduh: lol
19:55:25 <Lambduh> If only IRC would let me do /nick Î».
19:55:35 <arcetera> okay why
19:55:42 <arcetera> do i keep getting randomly mentioned in weechat
19:56:13 <arcetera> like Lambduh just mentioned me according to WeeChat but my nick isn't anywhere in there
19:56:15 <arcetera> help
19:56:30 <Lambduh> arcetera: Do you have Î» set as a ping?
19:56:37 <Lambduh> lol
19:56:53 <arcetera> no
19:57:07 <arcetera> it should only notify me on "arcetera"
20:04:36 <hackrilege> Hi, is Cale around? I noticed something relevant to a problem im having that he has been helping with. Monoid uses list in mconcat. This is a cheat as it escapes using proxy types by passing the container type in  as a type parameter
20:05:50 <lpaste> Cale pasted â€œAoC6â€ at http://lpaste.net/146767
20:06:05 <Cale> Bruuuuno: ^^ that's how I'd do it, using a mutable array
20:06:14 <hackrilege> Basically all the problems i have been having are how to write monoid for an arbritrary container, and getting angry that its not a monad
20:06:52 <Cale> hackrilege: what
20:06:56 <hackrilege> Damn
20:06:58 <Adeon> things not being a monad #1 cause for rage in us
20:07:03 <hackrilege> I hoped that would make sense
20:07:16 <hackrilege> Adeon, lol
20:07:38 <Cale> hackrilege: You can ignore mconcat if you don't like it
20:07:49 <Cale> hackrilege: You only need to implement mempty and mappend
20:07:57 <Cale> (and you only need to use those, if you prefer)
20:08:03 <hackrilege> Haha, no its pretty deep its exactly what im getting at
20:08:49 <hackrilege> Hmm, i want to supply an arbritrary foldable container
20:09:27 <Cale> Are you looking for...
20:09:29 <Cale> :t fold
20:09:31 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:09:34 <hackrilege> And, yeh, fold can then use mappend and mempty to write mconcat
20:10:08 <hackrilege> Can be used to write*
20:10:10 <Cale> Well, mconcat indeed takes a list, so you might as well just  foldr mappend mempty
20:10:26 <Cale> But yeah, fold will do that even more concisely
20:10:56 <hackrilege> Im talking about writing a new class that takes an arbritrary foldable container, as im not using lists, but Data.Map
20:11:05 <Cale> Well, that *is* Foldable
20:11:19 <hackrilege> Indeed
20:11:30 <hackrilege> As are all other containers that can be used to write mconcat
20:11:49 <hackrilege> In terms of mappend and mempty
20:11:53 <Cale> (your new class, I mean)
20:12:36 <hackrilege> I think you need to use fold to write mconcat
20:13:38 <Cale> Look at the type of fold again -- it's mconcat for a container which isn't a list
20:13:39 <hackrilege> class  Foldable t => Monoid' t a where
20:14:16 <Cale> So it's exactly the function you're asking for
20:14:22 <Cale> It's already part of Foldable
20:14:25 <hackrilege> Foldable does not have mempty, monoid is much closer to what i need
20:14:39 <Cale> Well, Monoid has mempty
20:14:58 <Cale> You already need to have a monoid
20:15:32 <Cale> But once you have one, you can use fold to multiply out any Foldable container of elements of your monoid
20:16:13 <hackrilege> The problem is that infact i have a container, say a graph, or a Data.Map. i wish to say that if it contains itself then its a monad and if it does not then its a monoid, basically. Is that wrong?
20:16:51 <Cale> What?
20:17:00 <Cale> That made no sense at all to me :)
20:17:21 <hackrilege> Well a Map is clearly not a monoid
20:17:36 <hackrilege> Though a Map of Maps is more like a monad
20:17:39 <Cale> What?
20:17:49 <Cale> There's a monoid instance for Map
20:17:58 <hackrilege> !!!
20:18:03 <hackrilege> Awesome times
20:18:10 <hackrilege> Im on the right trak then
20:18:18 <Cale> Ord k => Monoid (Map k v)
20:18:20 <hackrilege> So what happens when we get to the fixed point?
20:18:25 <Cale> huh?
20:18:29 <Cale> What fixed point?
20:18:36 <Cale> A map of maps is nothing like a monad
20:18:38 <hackrilege> When it is not a Map of Maps but say a map of Doubles
20:19:06 <Cale> I don't understand what monads have anything to do with this discussion, in fact.
20:19:14 <hackrilege> Infinite nested maps make a hylomorphic representation?
20:19:24 <Cale> ?
20:19:29 <Cale> word salad
20:19:42 <Cale> What are you trying to actually accomplish?
20:19:50 <hackrilege> I guess i ommited a leading "do
20:20:42 <hackrilege> Im tring to understand what happens when  you use Monad as the container in a Monoid
20:20:43 <Cale> It's probably more effective to start with "this is a bunch of code which looks repetitive somehow, how can I capture the similarities and factor them out?"
20:21:18 <hackrilege> My source is broken hell
20:21:33 <Cale> Well, first get it compiling :)
20:21:42 <Cale> Then worry about how to abstract things
20:21:42 <hackrilege> This is the problem
20:21:48 <hackrilege> Maybe 3 weeks now
20:22:27 <Cale> Rather than worrying about which abstract interfaces things might belong to, just write the functions you want directly, and give them whatever names you'd like to use.
20:22:55 <Cale> and then worry about whether those functions belong to some appropriate bunch of abstract nonsense
20:23:34 <hackrilege> I just really wanted to tell you that im sure what can help you understand what im saying is about how by using list as the container in monoid they do not need an extra type parameter which creates probelematic proxy types on mempty and im trying to use a Monad as this cointainer to basically make a class opperating like Monoid but with this type parameter
20:23:57 <Cale> Yeah, all I'm saying is you don't need that class
20:24:04 <Cale> That class is called Foldable :)
20:24:07 <hackrilege> Its my thesis
20:24:11 <Cale> :t fold
20:24:12 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:24:22 <hackrilege> No, fold has no mempty
20:24:30 <Cale> Monoid has mempty
20:24:40 <Cale> If you have Foldable t and Monoid m
20:24:40 <hackrilege> But monoid uses a list
20:24:45 <Cale> then you get  fold :: t m -> m
20:24:50 <Cale> Forget about mconcat
20:25:00 <Cale> Ignore the fact that it exists, it probably shouldn't be in the class declaration
20:25:20 <Cale> All you need to get an instance of Monoid are mempty and mappend
20:25:24 <hackrilege> Its basically a bug about how haskell cant handel inheritence properly
20:25:27 <Cale> what?
20:25:27 <Bruuuuno> You can use MonadPlus, it's basically monad + monoid
20:25:52 <Cale> hackrilege: I think you should probably listen to me rather than saying "no" :)
20:26:07 <hackrilege> Nothing can instantiate methods of a superclass except an immidiate subclass, partial superclass implementation by a subclass is BROKEN!!
20:26:25 <Cale> I guarantee you that if you go try to use Foldable t and Monoid m constraints
20:26:26 <hackrilege> But thats certainly an aside
20:26:26 <Cale> separately
20:26:31 <Cale> Then you won't have any trouble
20:26:54 <hackrilege> Hmm, what you say about foldable is good certainly...
20:27:00 <Cale> I don't know what "instantiate methods of a superclass" means
20:27:18 <Cale> There are superclass constraints on class declarations
20:27:32 <hackrilege> Nono, an aside, totally aside
20:27:39 <hackrilege> Nvm
20:27:41 <Cale> They just ensure that whenever there is an instance of the class you are defining, there must be an instance of the superclass.
20:27:52 <broma0> Im having some trouble using conduit and attoparsec. for some reason, conduitParserEither is causing the socket to close in this example: http://lpaste.net/146768. Any ideas?
20:27:58 <Cale> There's no inheritance of any kind
20:28:08 <hackrilege> So MonadPlus hey..
20:28:17 <Cale> It's just a way to ensure that if you have an instance of one class, then there must be an instance of another
20:28:21 <hackrilege> Ill check it out
20:28:55 <hackrilege> Its ok, i cant talk about the nheritance thing now
20:28:57 <Cale> hackrilege: I don't think MonadPlus is what you're looking for, but it's really unclear
20:29:42 <Cale> MonadPlus is for monads which create monoids, in the sense that for any type a, the type m a is a monoid, in a way which doesn't depend on a.
20:29:43 <hackrilege> Im writing monad join in terms of fold
20:29:55 <Cale> That sounds very questionable
20:30:06 <Cale> You probably can't get enough polymorphism that way
20:30:07 <hackrilege> So really i have Moand m, Foldable t -> m t
20:30:15 <Cale> that is a kind error
20:30:29 <hackrilege> +>*
20:30:31 <Cale> (even if I'm generous about the bad syntax)
20:30:33 <hackrilege> =>*
20:30:38 <hackrilege> Sorry
20:30:41 <Cale> m t doesn't make sense
20:30:49 <Cale> Because in order to be an instance of Foldable, t :: * -> *
20:31:00 <Cale> but in order to be an instance of Monad, m :: * -> *
20:31:18 <Cale> So m t doesn't make sense, because you'd need * = * -> *, which is false.
20:32:03 <hackrilege> Instance Foldable t, Monad m => Monad (m t)
20:32:13 <Cale> Still.
20:32:19 <hackrilege> Its a container of course it has *->*
20:32:47 <Cale> hackrilege: It's as if you have f :: Integer -> Integer, and g :: Integer -> Integer, and you've written f g
20:32:49 <hackrilege> Im sure its more like Foldable m , Monad m => m m
20:33:16 <Cale> hackrilege: Does that help make it clear why I'm complaining?
20:33:26 <hackrilege> Hmm
20:33:31 <hackrilege> Kind of i need .
20:33:31 <Cale> (the Haskell compiler will complain in the same way as me)
20:33:41 <hackrilege> Yeah its noisy
20:34:32 <hackrilege> Functor f => f (f a) is fine right?
20:34:42 <Cale> yes
20:35:32 <hackrilege> So why not Monad t, Foldable t => t (t a)?
20:35:54 <Cale> You could write that (with appropriate parens around the constraint) as the type of something
20:36:09 <Cale> (though it's polymorphic enough that there are not many values of that type)
20:36:17 <hackrilege> I have one
20:36:42 <hackrilege> But maybe its Monoid
20:36:49 <Cale> There aren't too many simultaneous instances of Monad and Foldable
20:37:08 <Cale> There are a few though, I suppose.
20:37:11 <hackrilege> Is (m m) a monoid?
20:37:17 <Cale> m m is a kind error
20:37:24 <Cale> For the same reason as before
20:38:02 <hackrilege> Instanec Monad m => Monad (m m )where
20:38:07 <Cale> Nope
20:38:28 <hackrilege> How do you do it then?
20:38:33 <Cale> Do what?
20:38:36 <hackrilege> A monad of a monad is a monad
20:38:40 <hackrilege> In haskell
20:38:53 <Cale> What's "a monad of a monad"?
20:39:01 <hackrilege> Its obvoius because join exists
20:39:07 <kadoban> hackrilege: What you're trying makes no sense, because it's not well kinded â€¦ so it's uncertain what you actually mean, or if what you mean is intelligible.
20:40:07 <hackrilege> If Monad m => m a in human is "a monad of a"
20:40:54 <hackrilege> So then m (m a) is " a monad of a monad of a"
20:41:19 <hackrilege> And (m m) is a monad of a monad, with some illegal parenthesis
20:41:39 <Cale> That means m applied to m
20:41:46 <Cale> Maybe you wanted m composed with m?
20:41:50 <hackrilege> (M . M
20:41:51 <Cale> You'll need a newtype
20:41:57 <hackrilege> I do want that yes
20:42:13 <hackrilege> But infinitly many times
20:42:33 <hackrilege> I can do that with newtype?
20:43:53 <hackrilege> Is it clear what im doing at least!?
20:45:51 <nshepperd__> data Mu f = Mu (f (Mu f))
20:45:59 <nshepperd__> You want Mu?
20:47:11 <hackrilege> Perhaps
20:47:37 <hackrilege> Is that like fix for data types?
20:48:03 <hackrilege> Or fix is function composition?
20:48:14 <hackrilege> And this is some other thing
20:48:33 <Rizy> hi i'm new to haskell, i read the wiki and comes to the function : f, g :: SimpleFunc Int Int, i'm still do not know how to read this, is it "f and g is function of type SimpleFunc which takes 2 type int" ?
20:48:44 <Rizy> moreover i see also function blogPostForm :: Form Handler BlogPost
20:48:53 <Rizy> how should i read this?
20:49:26 <hackrilege> Hmmmmmmm, Mu looks great, except it goes on forever, id like to supply a terminating datatype as a type tarameter
20:49:37 <hackrilege> Is that a thing?
20:51:52 <lambdafan> is this a silly function signature? boolToEither :: a -> b -> Bool -> Either a b
20:52:13 <lambdafan> I want to add this to MissingH but want to try this idea out here first
20:52:42 <jle`> lambdafan: are you asking about the signature, or the functino?
20:52:52 <lambdafan> well the function, is it silly?
20:53:45 <hackrilege> So, Nu is the infinite version and Mu is somehow finite (from the Wiki page on Fix
20:54:00 <lambdafan> I have a use case, I think
20:54:22 <exio4> lambdafan: try with djinn
20:54:36 <exio4> haha, I pm'd you, instead, sorry :P 
20:54:37 <hackrilege> Id put the bool as the first argument
20:55:16 <hackrilege> Can anyone talk me through this? I dont get the definitions, they use syntax im not used too...
20:55:24 <exio4> @djinn Bool -> a -> b -> Either a b
20:55:24 <lambdabot> f a b c =
20:55:25 <lambdabot>     case a of
20:55:25 <lambdabot>     False -> Left b
20:55:25 <lambdabot>     True -> Right c
20:55:39 <Cale> hackrilege: I don't understand how this could even possibly be relevant to anything :P
20:55:47 <hackrilege> https://en.m.wikibooks.org/wiki/Haskell/Fix_and_recursion
20:55:58 <hackrilege> I wish you wouldnt say that more Cale
20:56:01 <jle`> lambdabot: interesting that it gets the correct implementation that people expect
20:56:03 <Cale> hackrilege: Like, the fact that there is or isn't a monad instance for something should not be a problem
20:56:09 <jle`> * exio4
20:56:41 <lambdafan> I know how to write it, I'm just wondering if it's generally useful
20:56:43 <Cale> hackrilege: Basically, if you can explain what you're trying to compute, it shouldn't matter -- all you lose by not having a Monad instance is possibly having to rewrite some things which are defined in terms of an arbitrary monad.
20:56:52 <hackrilege> I think im trying to define Mu Cale, and iv never seen it before, im not sure why you need to know my application, are you doubting Mu has application?
20:56:55 <exio4> jle`: well, in this case, it doesn't have many implementations
20:57:07 <Cale> hackrilege: Oh, and Mu, yeah, you shouldn't really need that for anything real.
20:57:22 <lambdafan> I think it should go into MissingH but wanted to punt the idea around here before proposing on github
20:57:24 <Cale> hackrilege: You'd usually prefer to just write a recursive data type in the first place.
20:57:28 <hackrilege> Thanks, again, its my thesis, thanks for your supportive words!
20:57:35 <jle`> exio4: 50/50, still enough to inspire wonder in my heart
20:57:49 <Cale> hackrilege: I mean, unless your thesis is about recursion theory
20:57:52 <exio4> jle`: you need to be more optimistic! :P
20:58:14 <Bruuuuno> is there a function equivalent to fmap . fmap?
20:58:16 <Cale> Mu probably is going to be a distraction that doesn't belong there
20:58:17 <hackrilege> Yes, at the heart of it is a recursive data structure, but it must satisy a certain class in order to be able to define the growth method
20:58:20 <c_wraith> hackrilege: https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html  (already has it)
20:58:21 <Cale> Bruuuuno: fmap . fmap ;)
20:58:27 <exio4> Bruuuuno: fmap fmap fmap 
20:58:33 <dramforever> @@ @hoogle @type fmap.fmap
20:58:35 <lambdabot>  Prelude fmap :: Functor f => (a -> b) -> f a -> f b
20:58:35 <lambdabot>  Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
20:58:35 <lambdabot>  Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
20:58:35 <hackrilege> Fix fmap
20:58:41 <jle`> Bruuuuno: wht kind of answer are you looking for?
20:58:54 <jle`> a common alias?
20:58:55 <Cale> Bruuuuno: There's no good shortcut for it afaik
20:59:02 <Bruuuuno> oh :(
20:59:04 <Bruuuuno> thx
20:59:11 <hackrilege> Cale, Mu is certainly not a distraction, you insist everything im doing is pointless thats all
20:59:23 <jle`> i think it's uncommon enough that it wouldn't be worth having...and fmap . fmap is already immediately readable, heh
20:59:26 <hackrilege> It is probably the most relevant thing iv seen
20:59:33 <lambdafan> oh well thanks :) I guess I will bring the PR
20:59:36 <Cale> hackrilege: Unless your thesis is about the theory of computation, Mu is a distraction.
20:59:47 <hackrilege> My thesis is about Mu
20:59:55 <hackrilege> I keep telling you this
21:00:01 <Cale> hackrilege: Because anything you could have written with Mu can be written in Haskell without it
21:00:08 <Cale> and will probably end up looking a bit nicer
21:00:22 <hackrilege> I just dont care!
21:00:27 <hackrilege> Please stop telling me
21:00:36 <hackrilege> I have so little time
21:01:05 <hackrilege> By phrasing it this way i disclose a huge amount about the recursive nature of my datatype
21:01:09 <Cale> If your thesis is *actually* about Mu, then I really think you should just quit university now and join the working world, but I am pretty sure that is a lie.
21:01:16 <exio4> Cale: "distraction"? is that the nice way to say "mental masturbation"? :P 
21:01:16 <hackrilege> Introducing it via Mu is my chosen path
21:01:23 <hobo> lol Cale 
21:01:40 <hackrilege> Yeah, well im not here to discuss that thanks sorry
21:01:51 <hackrilege> Please, im trying to get something done
21:02:39 <hackrilege> Some people could do with being told this theory exists as they are rephrasing it with countless other names
21:02:51 <hackrilege> Im working with them,  and im presenting Mu to them.
21:03:27 <hackrilege> And as it will be used in rationality, i should use it in the code
21:03:40 <hackrilege> Or i could, you know, just write it in fortran
21:03:59 <hackrilege> I thought the functional programing tradition had something to offer
21:04:06 <hackrilege> Ok, discussion over?
21:05:23 <hackrilege> I want to know about how to properly handel recursive datatypes in functional programming, the appathetic question "why"does not need to be answered
21:05:41 <hackrilege> And it wastes my time
21:05:59 <hackrilege> Sorry
21:06:15 <Welkin> it works both ways
21:06:21 <Welkin> this community is about give and take
21:06:29 <hackrilege> Its very frustraiting when trying to get answers for people to question your reasons for asking them, they are not always to fault
21:06:36 <Welkin> we are not a personal 24-hour help service
21:06:53 <hobo> hackrilege, you might get some answers if you offered some money
21:07:03 <hackrilege> Thanks hobo
21:07:29 <Welkin> haha, hobo
21:07:35 * Welkin gives hobo a can of beans
21:07:36 <hackrilege> Look, im sorry i wrote all that stuff, my point is just that that kind of discussion is fruitless, and since it results from the question why, id rather not answer it
21:07:51 <hackrilege> Lol
21:07:53 * hobo heats the can of beans over his hobo fire and eats it
21:07:54 <hackrilege> I want beans
21:08:31 <hackrilege> Can anyone talk to me about Mu Fix and recursive data types?
21:08:46 <hackrilege> How do we handle their termination
21:08:51 <hackrilege> I.e. the fixed point
21:09:36 <hackrilege> Ãts a monad of monads of monads forever until the end when it contains a Monoid or something
21:10:19 <hackrilege> Is that possible to write in haskell? Like a fix tree or something
21:11:44 <Welkin> > fix error
21:11:46 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
21:11:49 <jle`> hackrilege: what do you mean by "handle termination"?
21:11:50 <hackrilege> Or is everybody mad at me beacuse i got upset when i was sidelined
21:12:02 <hackrilege> Thanks jle'
21:12:26 <hackrilege> Like in a Tree the branches terminate at a Node
21:12:53 <hackrilege> And i handel termination by saying i will descend until the Tree is a node not a Branch
21:13:27 <jle`> i'm not perfectly sure what you mean.  but have you looked at inhabitants of specific types under fix?
21:13:38 <hackrilege> Tree (Tree ( Tree ... forever until ( Tree Node)))))
21:13:41 <jle`> i'm assuming you mean something like data Fix f a = F (f (Fix a))
21:13:59 <hackrilege> Yeah, but with another type parameter
21:14:32 <jle`> how do you mean?
21:17:18 <hackrilege> data Fix f a = F (f (F f a) | a
21:17:53 <exio4> that doesn't make sense
21:18:10 <jle`> hm, do you mean like data Free f a = F (f (Free f a)) | R a    --- ?
21:18:13 <exio4> do you mean data Fix f a = F (f (F f a)) | T a -- or something like that?
21:18:47 <hackrilege> Yes exio4 thats what i was trying to write, sorry my keyboard is reeally bad
21:18:57 <hackrilege> And jle' yes Free looks perfect
21:19:00 <hackrilege> Whats that?
21:19:20 <exio4> Free is not Fix
21:19:21 <petercommand> F f a is not a data type
21:19:33 <hackrilege> ?
21:19:33 <jle`> (they're constructors)
21:19:48 <hackrilege> Oh no
21:20:05 <petercommand> do you mean something like, F (f (Fix f a))?
21:20:32 <hackrilege> Hmm, no i dont think so
21:20:47 <hackrilege> The Fix should not be in the recursion, that would be insane
21:20:47 <exio4> https://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free.html#t:Free what you are working on is a different thing
21:20:59 <hackrilege> Your sure?
21:21:21 <jle`> hackrilege: yeah, data Fix f a = F (f (Fix f a)) is the typical fixed-point type combinator
21:21:41 <jle`> i think i's usually unambiguously this
21:22:09 <hackrilege> But it does not terminate in a different type
21:22:15 <hackrilege> It just goes on forever
21:22:29 <jle`> yeah, but fixed points do exist
21:22:47 <exio4> Fix (Either a) 
21:22:58 <hackrilege> Im saying i want infinitly many monads nested inside each other with a Monoid at the end
21:23:17 <jle`> oh sorry, i meant Fix f  = F (Fix f),
21:23:17 <hackrilege> Exio4 wow that looks great!]
21:23:32 <jle`> think about the inhabitants of Fix Maybe
21:23:34 <nshepperd> you can't have infinite nesting and also something at the end
21:23:46 <hackrilege> What if its at the start?
21:23:59 <hackrilege> No that makes less sense...
21:24:08 <jle`> Fix Maybe includes values of type Maybe (Maybe (Maybe ... etc.))).  so you have Nothing, Just Nothing, Just (Just Nothing), Just (Just (Just Nothing)), etc.\
21:24:16 <hackrilege> Wouldnt be zooming in then...
21:24:18 <jle`> so Fix Maybe is more or less the natural numbers
21:24:24 <nshepperd> you've got the XY disease bad, mate
21:24:37 <broma0> nshepperd: nice.
21:24:44 <jle`> data Fix f = F (f (Fix f)), so think about what the inhabitants of Fix Maybe would be
21:25:09 <hackrilege> What is this XY disease?
21:25:13 <hackrilege> Is it terminal?
21:25:14 <jle`> you'd have F Nothing :: Fix Maybe, F (Just (F Nothing)) :: Fix Maybe, F (Just (F (Just (F Nothing)))) :: Fix Maybe, etc.
21:25:26 <bitemyapp> Mu Maybe nats?
21:25:31 <bitemyapp> natty light.
21:25:34 <nshepperd> not with swift treatment!
21:25:35 <bitemyapp> natty++
21:25:37 <Cale> hackrilege: http://xyproblem.info/
21:25:44 <broma0> your question is how to do x. you think you can do x by doing y, but you dont know y either. so you ask about y instead of x.
21:26:07 * hobo wants a natty light
21:26:17 <hackrilege> Yeah but we are getting somewhere now so its ok
21:26:25 <petercommand> broma0: well, sometimes y is just a simplified version fo x
21:26:32 <petercommand> *of
21:26:37 <hackrilege> Yes Fix Maybe looks very close
21:26:53 <hackrilege> Either probably if i want to give it the Monoid
21:27:03 <broma0> petercommand:  never thought of it that way.. ive definitely had that form of the disease plenty of times
21:27:14 <jle`> think about the inhabitants of Fix (Either a).  what type does it look like?
21:27:37 <hackrilege> So its like Monad a => Mu  (Either Mu a)
21:27:47 <jle`> you have a kind error here
21:28:17 <petercommand> broma0: most of the time, people always ask about the simplified version of the question so that other people can understand the problem much quicker
21:28:51 <nshepperd> it's hard to simplify something correctly when you don't understand it
21:29:36 <hackrilege> So its like Monad a Monoid m => Mu f@(Either(Mu f) a)
21:29:50 <broma0> petercommand: i know what you mean.. i do that all the time. nsheppard has a good point there
21:29:51 <hackrilege> Argh
21:30:10 <petercommand> broma0: yeah..
21:30:27 <hackrilege> Yeah im cool with Fix Either
21:30:47 <jle`> Fix Either is also a kind error
21:30:48 <nshepperd> hackrilege: do I understand correctly that you want something like 'data T f m = Go (f (T f m)) | Stop m
21:31:06 <hackrilege> Yeah i think i wrote that above
21:31:07 <nshepperd> hackrilege: a variable number of f's containing an m?
21:31:15 <hackrilege> Yes
21:31:26 <nshepperd> that is what the free monad Free does
21:31:38 <hackrilege> Aha, yeah i say that before
21:31:43 <hackrilege> So no need for Fix Either
21:31:58 <hackrilege> Free Monad ftw
21:32:00 <hackrilege> Thanks
21:32:07 <hackrilege> Sorry that was such a hard thing
21:32:27 <hackrilege> Can you maybe say one thing about the free monad before i go and read the books?
21:32:48 <hackrilege> Why its so cheap!?
21:32:58 <exio4> what? 
21:33:14 <hackrilege> Monads for free?is that the same thing?
21:33:20 <hobo> monads are never free
21:33:47 <hackrilege> Your thinking of lunches
21:33:52 <petercommand> what does that even mean?
21:34:06 <hackrilege> Its a paper by Phil Wadeler i think
21:34:52 <hackrilege> No, no tips, just monads are never free. Ok
21:34:55 <hackrilege> Thanks guys
21:34:58 <nshepperd> it's kind of a pun. 'free' is a technical term to do with having adjoints.. or something... it means something with the minimal structure implied by the rules
21:35:19 <hackrilege> Oh no, not the rules, im outa here
21:35:35 <nshepperd> but free monads are also 'cheap' in the sense that 'Free f' is a Monad even if 'f' is only a Functor
21:35:52 <hackrilege> Nice to know about the adjoints though
21:36:08 <hackrilege> Omg so it really is free!!!
21:36:12 <hackrilege> Ill have 10!!!!
21:36:21 <hackrilege> Ok sorry
21:36:23 <nshepperd> uh
21:36:27 <petercommand> sounds great
21:36:33 <exio4> http://ncatlab.org/nlab/show/free+monad
21:36:34 <hackrilege> Im really excited about this monad, i should go
21:36:43 <jle`> Free isn't actually a Monad
21:36:50 <jle`> it creates monads, from functors
21:36:57 <jle`> "for free"
21:36:58 <hackrilege> Yah
21:37:05 <jle`> Free :: (* -> *) -> (* -> *)
21:37:17 <jle`>         ^ the functor    ^ the resulting monad 
21:37:29 <hackrilege> Yep
21:38:20 <hackrilege> So i guess i will have fun finding out how it implements the functions of the Monad class
21:38:30 <jle`> the free in free monads actually doesn't mean it's without cost, i think, heh.  i think it means that the instance it creates is completely free of any properties, except for the fact that it's a valid Monad
21:38:40 <hackrilege> I cant see how you get join for free from the functors...
21:38:49 <broma0> anyone familiar with conduit-extra? specifically the socket stuff?
21:38:49 <bitemyapp> Free isn't a newtype.
21:39:09 <jle`> there isn't "anything" you can say about the Monad instance for Free f, other than that it follows the Monad laws
21:39:12 <hackrilege> How does that help?
21:39:19 <hackrilege> Bitemyapp^
21:39:35 <hackrilege> How does it implement join?
21:39:36 <bitemyapp> quotienting out a possibility that seemed to be getting floated
21:39:38 <bitemyapp> (free WRT cost)
21:40:02 <dramforever> I think it means ""
21:40:05 <dramforever> most general
21:40:52 <hackrilege> So it just makes sure the contents are empty. Lame
21:41:04 <hackrilege> I dont want that lame Monad, i want a proper Monad
21:41:11 <dramforever> hackrilege: uh
21:41:14 <jle`> not empty
21:41:22 <jle`> it contains exactly the essense of Monad...no extra, no less
21:41:25 <hackrilege> I read "" above sorry
21:41:46 <dramforever> hackrilege: It's me to say sorry =) I somehow bumped into "Enter"
21:41:48 <hackrilege> How does Free allow us to implement join?
21:42:00 <hackrilege> Kk
21:42:19 <hackrilege> Oh thats good
21:42:38 <hackrilege> Still, i dont see how i can make a monad just of funtors of functors
21:43:09 <hackrilege> Your not telling me makes suspense, maybe its a good surprise, but i cant hold my impatience!!
21:44:01 <hackrilege> I guess its your way of telling me i should go and read about it now\
21:44:18 <bitemyapp> hackrilege: read
21:44:35 <dramforever> hackrilege: This intuition helped me some time ago: Free f a is (f (f .. (f a) .. )) with a certain number of f's
21:44:54 <dramforever> so Free f (Free f a) is N f's wrapping M f's wrapping an a
21:45:08 <hackrilege> Yeah, its a shame it took so long to find it im sure i wrote that...
21:45:10 <dramforever> and you would just turn that into N+M f's wrapping an a
21:45:25 <hackrilege> Thats pretty much how i explained it too...
21:45:31 <athan> hackrilege: You get it for free, what's so hard to understand?
21:45:39 <athan> :v
21:45:39 <hackrilege> Lol
21:45:57 <dramforever> hackrilege: uh? then what's confusing you?
21:45:58 <hackrilege> They must not pay the workers
21:45:58 <petercommand> https://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Monad-Free.html#line-188
21:46:33 <hackrilege> Dramforever, nothing, its just taken a long time for me to find Free, iv been on about this for ages
21:46:52 <hackrilege> But i think it popped up once a while ago and i forgot about it to be fair
21:46:55 <dramforever> ah, it happened again. should've read the logs
21:47:57 <broma0> Conduit ByteString m Word8 anyone? seems like a simple task... i can't figure it out
21:49:50 <hackrilege> Hmm, it writes its monad instane in terms of applicative uses Fix (>>=)
21:50:02 <hackrilege> Not sure quite how to deduce the join
21:50:12 <hackrilege> How do you write join in terms of applicative?
21:50:23 <dramforever> nah, you will need monad
21:50:35 <hackrilege> ??
21:50:57 <hackrilege> It writes monad in applicative, i guess there is a equivilance
21:51:05 <dramforever> ???
21:51:31 <zenguine> hey all, has anyone had issue trying to run ghci-ng with stack together?
21:51:32 <hackrilege> Ok how do you write join using the functions of monad?
21:51:58 <hackrilege> @src join
21:51:58 <lambdabot> join x = x >>= id
21:52:01 <zenguine> specifically running "stack ghci --with-ghc=ghci-ng" and getting errors about the permissions on /tmp/whatever/ghci-script2341234/ghci-script type stuff?
21:52:34 <zenguine> seems like stack is creating its temporary ghci scripts with permissions that ghci-ng doesn't like and I'm struggling a bit to think of a workaround here
21:52:35 <dramforever> hackrilege: join x = do c <- x; c, if you find that more readable
21:53:13 <hackrilege> What is MonadFix?
21:54:13 <jle`> completely unrelated, more or less. it's a typeclass that implements mfix :: (a -> m a) -> m a
21:54:32 <jle`> following some laws so you can write generic functions
21:54:35 <hackrilege> Are you sure its unrelated?
21:54:48 <hackrilege> Since im talking about monad and fix...
21:54:58 <jle`> i don't think they are related in any meaningful way
21:55:11 <hackrilege> Whats monadFix fo then?
21:55:22 <jle`> writing recursive do blocks
21:55:36 <jle`> an instance of the MonadFix typeclass will allow recursive do blocks written in it
21:55:57 <hackrilege> Its making a big ol' recursive monad right? Thats exacly what im doing with Free Monad
21:55:58 <jle`> MonadFix is a typeclass that basically tells you how to support recursive binds
21:55:59 <petercommand> it enables you to write mdo
21:56:04 <jle`> it doesn't create a recursive monad
21:56:07 <hackrilege> Its making a big ol' recursive monad right? Thats exacly what im doing with Free Monad Monoid
21:56:11 <hackrilege> Oops, sorry
21:56:12 <jle`> it lets you write recursive bindings.
21:56:24 <nshepperd> yes, MonadFix has nothing to do with Fix, or Free
21:56:42 <jle`> in values
21:56:46 <hackrilege> What is recursive bindings, what is Bind?
21:56:54 <jle`> do
21:56:57 <jle`>   x <- foo y
21:57:00 <jle`>   y <- foo x
21:57:02 <hackrilege> Aha
21:57:02 <jle`>   return 10
21:57:05 <jle`> stuff like that
21:57:13 <jle`> it lets your binds in a do block be recursive
21:57:22 <hackrilege> No thats bind, i meant Bind
21:57:33 <jle`> but it's a typeclass whose instances are normal monads
21:57:45 <jle`> what Bind are you talking about?
21:58:15 <hackrilege> No i thought someone mentiond it i was mistaken
21:58:19 <hackrilege> Just, binding
21:58:28 <hackrilege> Thats ok
21:58:46 <hackrilege> Whats mdo?
21:59:28 <hackrilege> a <- f a
21:59:44 <hackrilege> Ok nvm
22:00:16 <hackrilege> Recursive binds....
22:09:39 <hackrilege> Oh dear, the free monad is very complicated and i cant understand it, if i use it will i be using it wrong if i try and use it like i have described?
22:11:18 <hackrilege> Obviously i will have to understand it before i present it, i mean, just to get the code working
22:12:02 <hackrilege> And yes, obviously it works without it...
22:23:26 <athan> Is there a Unique type that can be serialized into a ByteString?
22:23:37 <bitemyapp> athan: unique?
22:23:40 <athan> I'm just not sure if an Int64 is really enough
22:23:46 <bitemyapp> athan: unique what?
22:23:49 <athan> bitemyapp: Yeah.. but.... :\
22:23:51 <athan> nonce
22:23:53 <bitemyapp> database primary key? univerisally unique identifier?
22:24:00 <bitemyapp> unique with respect to a single computer?
22:24:01 <athan> ideally universally unique
22:24:04 <bitemyapp> a distributed system?
22:24:10 <athan> I'm currently just hashing something
22:24:13 <athan> no, monolithic
22:24:13 <bitemyapp> UUIDv4 -> encodeutf8
22:24:17 <bitemyapp> wait what
22:24:17 <athan> :D
22:24:23 <bitemyapp> monolithic and you need universally unique?
22:24:28 <athan> eh why not
22:24:31 <bitemyapp> bah do uuidv4 anyway for the simplicity.
22:24:32 <athan> it could grow
22:24:38 <athan> thanks man :)
22:24:44 <bitemyapp> athan: I wrote http://hackage.haskell.org/package/blacktip but don't use it.
22:24:51 <bitemyapp> has a correctness issue I need to get 'round to.
22:25:05 <bitemyapp> but if you were feeling enterprising...I could tell you what needs done but it really shouldn't get used in prod without a damn good reason.
22:25:30 <athan> it's not really prod, just a tiny test website
22:25:36 <athan> but I'm game, what's up with it?
22:25:36 <bitemyapp> well all the same
22:25:46 <bitemyapp> athan: monotonicity in the timestamps.
22:26:02 <bitemyapp> athan: I'm a lazy mf'er and used the POSIX API for epoch millis to get my bits
22:26:10 <bitemyapp> athan: I need to use Linux syscall for MONOTONIC_CLOCK
22:26:18 <bitemyapp> but I have bewk and I am very lazy.
22:26:29 <athan> :|
22:26:31 <c_wraith> bitemyapp: POSIX timestamps aren't monotonic.  Fun trick, eh? :)
22:26:57 <athan> wait, so POSIX timestamps aren't well-ordered?
22:27:09 <athan> like you could get an earlier time from a later call?
22:27:13 <bitemyapp> c_wraith: that's...the point yes.
22:27:18 <bitemyapp> athan: yes
22:27:19 <c_wraith> in the very rare case of a double-leap second, they can go backwards
22:27:28 <athan> what in sam hill
22:27:31 <bitemyapp> bah the bloody NixOS people tripped over it.
22:27:36 <bitemyapp> their Hydra build server's clock went backwards
22:27:39 <bitemyapp> and the tests failed
22:27:39 <hackrilege> Do most of you understand the free monad? The sytax of category theory blids me
22:27:46 <hackrilege> Blinds*
22:27:49 <bitemyapp> hackrilege: it's a useful datatype
22:27:54 <athan> hackrilege: binds*
22:27:58 <athan> :v
22:28:02 <hackrilege> Lol
22:28:20 <athan> bitemyapp: I'll give it a shot :)
22:28:20 <hackrilege> Can i see it un use?
22:28:21 <bitemyapp> c_wraith: if posix epoch millis were monotonic I wouldn't have to a lift a finger.
22:28:33 <bitemyapp> athan: well, there's a perk to using the syscall directly
22:28:40 <bitemyapp> athan: it should boost the benchmark
22:28:43 <hackrilege> In use?
22:28:52 <bitemyapp> hackrilege: no, is sekrit
22:29:09 <athan> 123ms for 100k, not bad!
22:29:11 <hackrilege> Dont encourage me to spell badly
22:29:31 <bitemyapp> athan: >not bad
22:29:36 <bitemyapp> athan: fuckin' Google grade.
22:29:49 <bitemyapp> who needs more unique ids a second than that _per server-?
22:30:01 <hackrilege> ...
22:30:01 <bitemyapp> just throw it 1/10th of a CPU core and you're done.
22:30:28 <bitemyapp> hackrilege: https://github.com/search?l=Haskell&q=Control.Monad.Free&type=Code&utf8=%E2%9C%93
22:30:31 <athan> bitemyapp: N E E D S  F A S T
22:30:40 <bitemyapp> hackrilege: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
22:30:40 <hackrilege> Plz tell me the sekrit
22:30:52 <bitemyapp> hackrilege: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
22:30:58 <hackrilege> Coool!!!!
22:31:07 <hackrilege> I did invent them just now, you saw me
22:31:20 <bitemyapp> hackrilege: http://comonad.com/reader/2011/free-monads-for-less/
22:31:23 <bitemyapp> hackrilege: http://comonad.com/reader/2011/free-monads-for-less-2/
22:31:26 <bitemyapp> hackrilege: http://comonad.com/reader/2011/free-monads-for-less-3/
22:31:26 <hackrilege> But i hve no idea what they are so i guess it dont count
22:31:34 <bitemyapp> hackrilege: http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu
22:31:46 <hackrilege> All 3 volumes wow
22:31:48 <phy1729> Is there a short way to write \x -> if x > y then x+1 else x ?
22:31:49 <bitemyapp> hackrilege: https://www.fpcomplete.com/user/dolio/many-roads-to-free-monads
22:31:57 <bitemyapp> hackrilege: http://stackoverflow.com/questions/23766419/when-would-i-want-to-use-a-free-monad-interpreter-pattern
22:32:04 <bitemyapp> hackrilege: http://michaelxavier.net/posts/2014-04-27-Cool-Idea-Free-Monads-for-Testing-Redis-Calls.html
22:32:07 <hackrilege> Wau wau!!!
22:32:11 <athan> hahaha
22:32:12 <hackrilege> YESSS!!!!
22:32:16 <bitemyapp> hackrilege: http://okmij.org/ftp/Computation/free-monad.html
22:32:17 <hackrilege> POWER!!
22:32:30 <bitemyapp> hackrilege: http://debasishg.blogspot.com/2013/01/a-language-and-its-interpretation.html
22:32:40 <bitemyapp> hackrilege: http://blog.omega-prime.co.uk/?p=34
22:32:44 <bitemyapp> hackrilege: http://dlaing.org/cofun/posts/free_and_cofree.html
22:32:55 <bitemyapp> hackrilege: http://www.happstack.com/page/view-page-slug/16/comparison-of-4-approaches-to-implementing-url-routing-combinators-including-the-free-and-operational-monads
22:33:12 <bitemyapp> hackrilege: https://softwaremill.com/free-monads/
22:33:16 <bitemyapp> hackrilege: http://newartisans.com/2012/08/meta-programming-with-the-free-monad/
22:33:17 <hackrilege> Please continue, im powering up my new tabs machine
22:33:29 <bitemyapp> hackrilege: http://www.davesquared.net/2013/11/terminal-io-example-in-haskell.html
22:33:39 <bitemyapp> hackrilege: http://statusfailed.com/blog/2015/09/04/free-monads-for-making-fast-models.html
22:33:53 <bitemyapp> hackrilege: http://travis.athougies.net/posts/2013-08-21-making-money-with-free-monads.html
22:34:16 <bitemyapp> hackrilege: https://ocharles.org.uk/blog/posts/2013-11-24-using-indexed-free-monads-to-quickcheck-json.html
22:34:24 <bitemyapp> hackrilege: that's all for now
22:34:27 <bitemyapp> back to the book.
22:34:39 <verement> phy1729: you could try using guards
22:34:43 <hackrilege> Nice
22:34:49 <hackrilege> Epic times
22:35:03 <hackrilege> Did you just remember all those?
22:35:39 <bitemyapp> hackrilege: not exactly, but I did remember which ones were better than others
22:35:55 <bitemyapp> hackrilege: particularly recommend Xavier and Wiegley for the practical perspective.
22:36:00 <hackrilege> An educated google search, invaluble
22:36:17 <hackrilege> Thanks
22:36:38 <hackrilege> Shame i have to submit soon or i could do this properly...
22:36:49 <bitemyapp> hackrilege: don't sweat it. Always next time.
22:36:58 <bitemyapp> hackrilege: better to do it dumb than over-lever yourself.
22:37:44 <hackrilege> Yeah, its a strong motivation for a project which is good, i should get continuation
22:39:14 <hackrilege> How to motivate understanding something without understanding it.. "well i came accross this crazy incomprehensible stuff and it has the correct type signiture so id better read all this stuff right?" Right!
22:50:24 <geppettodivacin> @pl permute n x = first : map bumpUp (permute (n-1) (x `mod` (fact $ n-1)))
22:50:25 <lambdabot> permute = fix (((((first :) . map bumpUp) .) .) . (`ap` (flip mod . fact . subtract 1)) . ((.) .) . (. subtract 1))
22:50:31 <geppettodivacin> That's pretty.
22:50:35 <geppettodivacin> phy1729: ^
22:51:01 <phy1729> I would not consider that pretty
22:51:10 <geppettodivacin> That was sarcasm.
22:51:28 <geppettodivacin> I think it's beautiful that it can be done, though.
22:51:48 <phy1729> I don't think I want to know what . ((.) .) .  means
22:53:57 <geppettodivacin> :t (. ((.) .) .)
22:53:59 <lambdabot> parse error on input â€˜)â€™
22:55:11 <petercommand> geppettodivacin: section is one-sided
22:55:32 <geppettodivacin> petercommand: I'm not sure what that means.
22:55:38 <petercommand> so you can do (a .) or (. a) but not both at the same time
22:56:17 <petercommand> this syntax is called section
22:56:25 <FireFly> @unpl \x y -> x . ((.) .) . y
22:56:26 <lambdabot> \ x y g -> x (\ m b c -> y g m (b c))
22:57:04 <geppettodivacin> So, you can kind of do that?
22:57:17 * hackagebot stm-firehose 0.3.0.2 - Conduits and STM operations for fire hoses.  https://hackage.haskell.org/package/stm-firehose-0.3.0.2 (SimonMarechal)
22:57:30 <geppettodivacin> ^have a variable on both sides
22:57:54 <FireFly> hm
22:57:57 <FireFly> :t if'
22:57:58 <lambdabot>     Not in scope: â€˜if'â€™
22:57:58 <lambdabot>     Perhaps you meant â€˜f'â€™ (imported from Debug.SimpleReflect)
22:58:19 <petercommand> geppettodivacin: yeah, it's infix operator now
22:58:39 <petercommand> if you supply it with two args, it's normal infix syntax
22:58:50 <jle`> FireFly: if' just exists in @pl, heh
22:58:52 <FireFly> I could've sworn there was an if' :: a -> a -> Bool -> a
22:58:55 <geppettodivacin> I guess I'm just not sure what you mean when you say you can't do (a .) and (. a) at the same time.
22:59:03 <jle`> FireFly: there's a similar function, `bool`, in Data.Bool
22:59:06 <jle`> but the arguments are switched
22:59:07 <FireFly> oh
22:59:10 <FireFly> @ty bool
22:59:12 <lambdabot> a -> a -> Bool -> a
22:59:26 <jle`> bool x y b = if t then y else x
22:59:28 <petercommand> geppettodivacin: (. a .)
22:59:43 <petercommand> :t \a -> (. a .)
22:59:44 <lambdabot> parse error on input â€˜)â€™
22:59:45 <jle`> it's to make an analogy with `maybe` and `either`
22:59:48 <geppettodivacin> Mm. Right.
23:00:05 <FireFly> phy1729: x + bool 0 1 (x > y)  is shorter, but not really prettier
23:00:11 <Walther> Btw, is there any scanf-like way of parsing input - handy for project euler -esque exercises and such?
23:00:21 <FireFly> er, \x -> that
23:00:40 <geppettodivacin> Walther: Can you split the string and then use read?
23:01:08 <Walther> geppettodivacin: map read.words usually works, and is easy enough if you have only a line of ints
23:01:12 <FireFly> @pl \x -> x + bool 0 1 (x > y)
23:01:12 <lambdabot> ap (+) (bool 0 1 . (> y))
23:01:23 <petercommand> Walther: maybe you can use parser combinator..
23:01:24 <haisheng> hi guys, do you have any ideas regarding how to support flexible json schema when using aeson ?
23:01:27 <Walther> but once you have mixed ints and floats, i tend to get lost on how to parse that in haskell
23:01:52 <petercommand> Walther: something like parsec should be convenient
23:02:09 <Walther> or something like a labyrinth solver and you have an input of walls # and floors . and how to map those to something useful
23:06:37 <koz_> Has anyone used this? https://hackage.haskell.org/package/gnuplot If so, how would I have this draw me a graph of something?
23:07:56 <hobo> :D gnuplot
23:07:59 <geppettodivacin> Walther: I'm not sure that I've ever seen scanf used well for something like a labrynth solver. I always just used fgets or something.
23:08:46 <koz_> hobo: Yeah - I normally have my code dump to text, then call gnuplot from the command line.
23:08:47 <Axman6> koz_: for graphs I use the Charts package - very powerful and supports many chart types
23:09:02 <koz_> Axman6: I'll look into it. I just need a simple line.
23:09:02 <Walther> geppettodivacin: or that, yes. Either way i'd love to have something like those in haskell for the rare occasions
23:09:03 <hobo> i dont know about the package koz_, i've just used gnuplot before
23:09:29 <koz_> hobo: Ah.
23:09:34 <Walther> possibility to say "read me a line that has one int and one float. If it doesn't, feel free to error out"
23:09:47 <Axman6> Charts has a module designed for ease of use: http://hackage.haskell.org/package/Chart-1.5.4/docs/Graphics-Rendering-Chart-Easy.html
23:09:57 <Axman6> also s/Charts/Chart above
23:10:24 <Axman6> Walther: parsers can be pretty concise for that
23:10:50 <Walther> Axman6: do you have good recommendations?
23:10:57 <Axman6> (,) <$> integer <*> spces *> floating, or something like that
23:11:08 <koz_> Axman6: Thanks - that'll do.
23:11:29 <koz_> How can I check if I already have package x or not?
23:11:33 <Axman6> um, depends what the data is. Parsec, attoparsec, the parsers package (which ties together different parsing libraries)
23:12:34 <Walther> nod, will take a look. How big of imports are those?
23:12:40 <Axman6> koz_: are you installing packages using cabal?
23:12:46 <Axman6> cabal list should tell you
23:13:04 <Axman6> but you should stack, for pretty much anything these daya, IMO =)
23:13:30 <koz_> Axman6: Thanks - that's what I was after.
23:13:32 <Walther> stack is neat, i hope all the best for its development
23:13:49 <Walther> not that cabal was bad either, but stack feels more modern
23:13:52 <Axman6> Walther: I use it daily and it's completely changed haskell development for the better
23:13:59 <Axman6> things don't break
23:14:00 <Walther> nod
23:14:16 <Axman6> anyway, time to head out. o/
23:14:17 <Walther> iirc sandboxing is way easier too
23:14:24 <Walther> thanks for the tips!
23:58:31 <koz_> OK, I swear I must be insane. How do I rewrite this in a saner way? http://paste.rel4tion.org/164 <-- the second function interests me the most
23:59:33 <mauke> the second "function" is a type error
23:59:43 <mauke> ("function" because the type says it's a list, not a function)
