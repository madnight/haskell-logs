00:01:32 <KoF_> mmk
00:03:29 <KoF_> haven't fiddled with runhaskell before, but I Googled and got this. https://downloads.haskell.org/~ghc/7.0.3/docs/html/Cabal/builders.html Tried that, it hangs on runhaskell Foo.hs --configure ghc
00:03:55 <KoF_> whoop, nevermind, spat out this error after I tried to ctrl+c it
00:03:57 <KoF_>  0 [sig] -bash 3988 get_proc_lock: Couldn't acquire sync_proc_subproc for(5,1), last 7, Win32 error 0
00:03:57 <KoF_>     362 [sig] -bash 3988 proc_subproc: couldn't get proc lock. what 5, val 1
00:06:30 * hackagebot monad-logger 0.3.16 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.16 (MichaelSnoyman)
00:07:38 * hackagebot svgcairo 0.13.0.4 - Binding to the libsvg-cairo library.  https://hackage.haskell.org/package/svgcairo-0.13.0.4 (HamishMackenzie)
00:07:38 * hackagebot monad-logger 0.3.16 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.16 (MichaelSnoyman)
00:08:34 <srhb> KoF_: Sounds like a cygwin bug. Does the program require cygwin? I noticed you had some POSIX stuff commented out.
00:08:54 <srhb> KoF_: If it's compatible you could try compiling and running it in a pure Windows environment.
00:09:55 <KoF_> Mm, not really sure. 
00:10:45 <srhb> KoF_: Well, give it a shot? :)
00:11:21 <srhb> The linker should just barf if you're depending on cygwin stuff and try outside.
00:11:25 <KoF_> can try
00:12:03 <KoF_> I'd think it doesn't rely on Cygwin once I comment everything out, though.
00:12:33 * hackagebot gconf 0.13.0.3 - Binding to the GNOME configuration database system.  https://hackage.haskell.org/package/gconf-0.13.0.3 (HamishMackenzie)
00:12:35 * hackagebot mono-traversable 0.10.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-0.10.0.1 (MichaelSnoyman)
00:12:43 <srhb> KoF_: That's very true.
00:13:32 <KoF_> Which, well, it's still commented.
00:13:50 <srhb> KoF_: You can try commenting things in if it works in the pure Windows env. :)
00:13:59 <KoF_> Alright, nope, getting the same thing in pure Windows.
00:14:15 <srhb> Interesting. So you can't compile any Haskell program at all.
00:14:22 <srhb> Well, can't run it.
00:15:31 <KoF_> I have another one that's working fine, is the weird thing.
00:16:03 <srhb> Uh, yes, that doesn't make much sense. Does it fail if you use putStrLn instead of error, too?
00:16:37 <KoF_> However, that one I didn't compile recently - I compiled it a long time ago. So I think it's a problem happening at compilation.
00:16:49 <srhb> You were on 7.10.3, right?
00:17:05 <KoF_> Yup.
00:18:13 <srhb> If your other program stops working when compiled on 7.10.3 we have a suspicion at least. :P
00:22:58 <KoF_> Yup. And writing an entirely new program that has just the module main where and a putstrln for the main, it works in ghci but dies when I try to run it.
00:23:06 <KoF_> Maybe I should just reinstall ghc.
00:23:36 <srhb> KoF_: Sounds like it. If that doesn't fix it, we could have a ghc bug. Surprising that it hasn't caused outrage yet though. :-)
00:25:34 <KoF_> hmm. Does it make the most sense to just reinstall ghc on its own, or the whole platform?
00:26:59 <srhb> KoF_: Afraid I don't know what the Windows Way is. 
00:28:08 <KoF_> Ah well.
00:30:36 <carmethene> KoF_: that sounds really weird, to the point I wonder if even reinstalling would help
00:30:47 <carmethene> I'd be really interested in knowing where it's stuck
00:31:10 <carmethene> I'd offer to check, but you know, .exes over the internet and all that :P
00:31:22 <KoF_> yeah :P
00:31:43 <KoF_> We'll see if reinstalling helps! It can't hurt.
00:31:56 <srhb> KoF_: Famous last words.
00:32:14 <carmethene> heh
00:32:41 <carmethene> are you compiling with the cygwin version of ghc?
00:32:51 <carmethene> so, thinking about it a little more
00:32:52 <KoF_> Not like I'm doing anything else with Haskell right now, all my other code is written and compiled and working. xD
00:33:02 <carmethene> I'd bet that it's a DLL issue
00:33:03 <KoF_> Am not, no.
00:33:06 <carmethene> oh
00:33:10 <carmethene> just a native Windows ghc?
00:33:22 <KoF_> Yeah. I did try shifting over to pure Windows and got the same problem, though.
00:33:34 <carmethene> well... the binaries that come with cygwin
00:33:41 <carmethene> you can run them in 'pure' windows, i.e. cmd.exe
00:33:58 <carmethene> but they're still running against the cygwin dll, which is the posix emulation layer
00:34:12 <carmethene> I've fallen afoul of that before, thinking I wasn't using cygwin when I was
00:34:37 <carmethene> but if you're sure you're not using cygwin ghc I guess that doesn't help, sorry
00:34:44 <KoF_> The ghc I got was from downloading the full Windows Haskell package off the site.
00:34:53 <carmethene> understood
00:34:57 <carmethene> it's a doozy :)
00:35:02 <KoF_> and I didn't have a ghc before that
00:35:19 <carmethene> are you running through cmd.exe?
00:35:24 <KoF_> yeah
00:35:39 <KoF_> and I'm doing it not in the cygwin directory, but in a regular Windows folder
00:35:41 <carmethene> just random suggeston, try powershell if you have it?
00:35:51 <KoF_> I don't currently, no.
00:35:53 <carmethene> it does its pipes differently apparently
00:35:54 <carmethene> ok
00:35:59 <carmethene> comes with win10 out of the box now :)
00:36:15 <KoF_> Haven't moved to win10. Probably should eventually.
01:43:50 <magbo> Greetings, beautiful people. I have a question regarding System.Random from random package. I'm reading the source code and as far as I understand, if I don't maually "touch" setStdGen, on linux, global generator will be seeded with cryptographically secure IV.
01:44:04 <magbo> Am I reading this correctly?
01:44:26 <jle`> System.Random is definitely not intended to be cryptographically secure by any standard :)
01:44:48 <magbo> jle`: amazing, thank you.
01:44:58 <jle`> if cryptographic security is important to you, System.Random and random is not going to be a fit for you, heh
01:45:17 <jle`> it's just not designed with any of that in mind
01:45:28 <magbo> That means that, by transitivity, functions in uuid package generate predictable values.
01:46:05 <magbo> Which means that if I want to use UUIDs for random secrets I'll need to fork it. Any better ideas? 
01:46:42 <magbo> I need to represent a system-wide unique random secret in my system, i.e. session id.
01:46:53 <jle`> well, only if you use its random-generating functions
01:46:59 <jle`> you could definitely write your own secure UUID-generating functions
01:47:06 * yianni waves :)
01:48:28 <magbo> jle`: its = System.Random's?
01:48:46 <jle`> whatever functions you're using
01:48:52 <jle`> they're not defined in System.Random
01:49:00 <jle`> they're defined in uuid's package
01:49:31 <jle`> uuid generation isn't inherently tied to `random`'s System.Random; it just gives some convenience functions to generate uuid's using System.Random functions
01:49:33 <magbo> Yeah-yeah, my problem isn't uuid generation, my problem is the output being a secret.
01:49:37 <jle`> oh
01:49:39 <magbo> Ah
01:49:41 <magbo> Damn
01:49:52 <jle`> you definitely don't have to use IO to get your seeds, either
01:50:19 <magbo> Right, I don't even need to fork uuid.
01:50:34 <jle`> also, i believe that the global IO-based seed is only initialized once; the rest of the random generation follows from the seed's pure updating rules
01:50:56 <jle`> which themselves are not cryptographically secure...but my point is that it doesn't reach back to the system's random generators at every step
01:51:21 <magbo> jle`: yes, unless I mess with it by calling setStdGen (IIRC)
01:51:30 <magbo> Ok.
01:51:33 <jle`> setStdGen won't touch the system
01:51:39 <jle`> it just updates a mutable variable in your haskell runtime
01:51:46 <magbo> I understand, yes.
01:51:49 <jle`> so it won't be visible to the outside world any more than, say, `let x = 4`
01:52:32 <jle`> but actually, what the uuid package uses from System.Random isn't the random-generating facilities; it's actaully the Random typeclass and its interface
01:53:05 <jle`> basically, gets to define its own StdGen g => g -> (UUID, g) function
01:53:10 <magbo> jle`: let me have a look at the source code of uuid closely
01:53:14 <jle`> and you get to call it by the identifier `random`
01:53:27 <jle`> the main reason it uses System.Random is for the typeclass interface
01:53:36 <jle`> sort of how there's a "Show" typeclass that lets you show values
01:53:57 <jle`> but when you actually define how to "show" your own custom data type...you write your showing function yourself
01:54:09 <magbo> I understand, yes :)
01:54:15 <jle`> the only thing the Show typeclass adds is now you can use the same four-letter name, 'show', to show different types
01:54:38 <jle`> *values of different types
01:55:14 <jle`> what the UUID type does is offer a Random instance, which means you can run a StdGen -> (UUID, StdGen)...and where that StdGen comes from could be from a cryptographically secure source
01:55:30 <jle`> or, you could ignore its pre-built `random` function entirely, and use your own :)
01:55:49 <jle`> like how `show` is not the only way i can turn an Int into a String
01:57:03 <magbo> Cool, thanks. I have overlooked uuid-types part of uuid package and got confused about the origins of functions.
01:57:22 <magbo> Now I know where to read. Thank you very much, jle` :)
02:00:51 <jle`> np!
02:20:17 <StippenCows> damn hipsters
02:31:30 <duairc> Is there a process for adding instances to base? Like if there are instances missing from datatypes in base, do I have to go through to libraries mailing list to get them added or can I just send a patch?
02:32:35 <julianleviston> duairc: the bug tracker no good?
02:35:14 <duairc> julianleviston: I don't know, that's what I'm asking. I've just seen threads on the libraries mailing list about adding trivial instances before. But yeah, I guess I should just put it on the bug tracker.
02:35:22 <srhb> duairc: Per the CLC, issues in base go in the GHC Trac
02:35:26 <srhb> https://wiki.haskell.org/Library_submissions
02:40:34 <duairc> srhb: Thanks!
02:57:24 <municoded> Hey, sorry, this isprobably a stupid question, but I'm not familiar with Haskell (just use it for xmonad config). Somewhere in my file I have ""\uf128 " (a character from font awesome, sent to a status bar), but when I compile, I get "lexical error in string/character literal at character 'u'". What should I do to fix this?
02:58:07 <municoded> (the double " is not in the file)
03:06:18 <municoded> I figured it out, I should be prefixing hex symbols with \x instead of \u
03:06:34 <larryba> > \xa
03:06:35 <lambdabot>  <hint>:1:4:
03:06:36 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:06:44 <larryba> > '\xa'
03:06:46 <lambdabot>  '\n'
03:13:46 <xnyhps_> jle`: Even if you grab a StdGen from a cryptographically secure source it still only has 64 bits of internal state, which is a bit small.
03:29:48 <hsParseLearner> hello, assuming i have <$>, which applies a function to a parsers' function and <*> for sequencing parsers, with data Parser a = P (String -> [(a, String)] how can i define kleene * and + ? this is my code so far http://lpaste.net/3022573596653387776
03:30:14 <hsParseLearner> *parsers' result
03:40:39 <chpatrick> double and scientific from Text.Parser.Token don't seem to be able to handle negative values
03:43:29 <chpatrick> did edwardk really forget or is it intentional?
03:47:20 <chpatrick> :r
03:49:57 <chpatrick> ah because it's according to the haskell report
03:50:05 <chpatrick> that's a bit confusing
04:07:41 * hackagebot statsd-client 0.2.0.1 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.2.0.1 (keith_duncan)
04:22:48 * hackagebot luminance 0.8.2.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.8.2.1 (DimitriSabadie)
04:29:36 <reactormonk> Got a -> IO b, would like IO (a -> b) - how do I do that?
04:32:46 <dredozubov> if f :: IO (a -> b), so f >>= fmap
04:34:05 <dredozubov> nope, i'm wrong
04:35:00 <dredozubov> but basically you want to fmap a -> b with fmap
04:37:12 <dredozubov> also g x = x >>= \x' -> f >=> \z -> z x' to get your creative juices going
04:39:51 <dredozubov> reactormonk: what do you want to do?
04:40:38 <lytaa> 。。。
04:41:39 <reactormonk> dredozubov, xmonad, https://gist.github.com/reactormonk/cb7ae85acedf750d9d4d
04:42:14 <reactormonk> I figured I could solve the problem via a -> IO b to IO (a -> b) and then I could just bind the whole function
04:42:45 <dredozubov> let f = (return :: a -> IO a)
04:42:51 <dredozubov> let g x = x >>= f
04:43:18 <dredozubov> g :: IO b -> IO b
04:43:24 <dredozubov> that's what you need
04:44:29 <dredozubov> IO (a -> b) is applicative style
04:44:50 <dredozubov> if you want to use it with <*> or ap
04:45:59 <dredozubov> but if you got `a -> IO b` and you want to get to `IO b` from `IO a`, just you monadic bind
04:47:01 <dredozubov> just use*
04:48:29 <reactormonk> dredozubov, would I put the let inside or outside the do?
04:48:52 <dredozubov> you don't need let, it was copied from the ghci
04:49:23 <reactormonk> my function is a -> IO b, I would like to convert it to IO (a -> b) if that's possible
04:49:32 <nshepperd_> (a -> IO b) -> IO (a -> b) does not exist
04:49:48 <dredozubov> reactormonk: you don't need the general solution
04:49:51 <nshepperd_> But you should never need to do that
04:49:57 <dredozubov> you just need to bind two actions
04:50:10 <reactormonk> nshepperd_, hm, ok. Then I'm doing it wrong.
04:50:13 <dredozubov> if you got `IO a`
04:50:39 <dredozubov> then you can do (x :: IO a) >>= (y :: a -> IO b)
04:51:25 <dredozubov> nshepperd_: why do you think it cannot exist?
04:52:19 <dredozubov> it's a little bit weird to want exactly that, but i don't see the reason why it can't exist at all
04:52:56 <xnyhps> It would allow you to turn readFile into a function IO (String -> String)... which sounds like it shouldn't exist.
04:54:13 <srhb>  dredozubov An IO action that produces a function from a to b is radically different from a function that produces an IO action b
04:54:30 <srhb> dredozubov: It's not that the type IO (a -> b) cannot exist, it's just radically something completely different from a -> IO b
04:55:05 <reactormonk> dredozubov, keys wants XConfig Layout -> M.Map (ButtonMask, KeySym) (X ()), but I got XConfig Layout -> IO (M.Map (KeyMask, KeySym) (X ()))
04:55:11 <dredozubov> srhb: this is what i'm getting at
04:55:37 <nshepperd_> Call that function f. f putStr seemingly prints its input before knowing what it is
04:56:44 <dredozubov> what do you mean by f there?
04:57:02 <srhb> f :: (a -> IO b) -> IO (a -> b)
04:58:04 <dredozubov> you can't express data dependencies that way, that's all
04:58:31 <srhb> Unless you by that mean "it cannot exist" generally I'm not sure what you're getting at. :)
04:58:48 <dredozubov> nshepperd_: i don't see you supplying the string to the new function at this point
04:59:03 <nshepperd_> I bet you can implement unsafeCoerce with that f somehow
04:59:24 <dredozubov> it doesn't make any sense with unsafeCoerce
04:59:38 <dredozubov> unsafeCoerce is used for things that have the same runtime representation
04:59:51 <reactormonk> dredozubov, f is keys
05:00:56 <dredozubov> reactormonk: ehm?
05:02:24 <nshepperd_> Main = f putStr
05:02:34 <nshepperd_> What does that print?
05:02:50 * hackagebot haskellscrabble 1.2.1 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-1.2.1 (happy0)
05:02:59 <dredozubov> nothing, of course
05:03:14 <happy0> hackagebot: please stop embarrassing me in front of everyone ;-;
05:04:41 <dredozubov> nshepperd_: f putStr <*> fileName will make much more sense, isn't it?
05:05:13 <nshepperd_> Main = do { h <- f putStr; h "hello" `seq` return () }
05:06:08 <nshepperd_> Note that h "hello" = ()
05:06:34 <dredozubov> String -> String will escape IO and will make it inconsistent for the typechecker, sure
05:06:51 <dredozubov> i'm just saying it's theoretically possible
05:07:21 <nshepperd_> If you use unsafeperformio, sure it's possible
05:07:23 <dredozubov> it doesn't really make sense to make this kind of interfaces into monad
05:07:26 <dredozubov> monads*
05:07:29 <reactormonk> srhb, so an implementation of said f would be difficult?
05:07:33 <dredozubov> because they're really applicative
05:07:36 <srhb> reactormonk: Impossible, in fact.
05:07:51 <srhb> Unless you break the type system. :)
05:08:54 <exio4> magic :: (a -> IO b) -> IO (a -> b)
05:08:57 <exio4> magic f = return (unsafePerformIO . f)
05:09:00 <exio4> there, an implementation!
05:09:10 <dredozubov> nshepperd_: making it appliative will eliminate the escape hatch
05:09:17 <dredozubov> so why the hell not
05:09:24 <exio4> what? 
05:09:26 <nshepperd_> dredozubov: the execution of f putStr <*> filename doesn't print anything
05:09:27 <dredozubov> we'll just make an applicative action out of monad one
05:09:41 <dredozubov> "seemingly" monad
05:09:50 <srhb> dredozubov: I think you're misunderstanding what the types _mean_. It has nothing to do with them being monadic or applicative or whatnot.
05:10:45 <nshepperd_> <*> for io is just run first thing, run second thing, apply first result to second result purely
05:10:54 <dredozubov> why do you stuck with IO?
05:11:02 <srhb> That was the type in question.
05:11:37 <dredozubov> i'm thinking in terms of Monad m => a -> m b -> m (a -> b)
05:11:59 <dredozubov> and i'm saying that it makes a whole lot more sense if you weaken the m constraint
05:12:14 <srhb> dredozubov: You mean Monad m => (a -> m b) -> m (a -> b)
05:12:36 <dredozubov> srhb: yes, you're right
05:13:00 <srhb> It doesn't matter though, it still not possible without breaking the type system.
05:13:02 <nshepperd_> The fact that (a -> m b) can do way more than m (a -> b) is exactly why the monad class exists
05:13:13 <dredozubov> nshepperd_: no one argues that
05:13:32 <exio4> dredozubov: you want a counter-example, `magic readIORef` 
05:13:32 <dredozubov> a -> m b
05:13:43 <dredozubov> it can encode data dependencies properly
05:13:55 <exio4> this would give you an action IO (IORef a -> a), which wouldn't be a pure function
05:13:59 <dredozubov> that's reason why it looks like that, not for some mystical reason
05:14:51 <nshepperd_> Therefore you can't convert the former into the later without cheating
05:17:03 <nshepperd_> dredozubov: with that f you can write instance Applicative f => Monad f
05:17:28 <nshepperd_> Which is needless to say, a nonsense
05:18:56 <reactormonk> actually, I'm in main, and I would like a -> b, but I got a -> IO b
05:20:04 <dredozubov> reactormonk: if you got a -> IO b, just get to IO b, then bind it with >>= to whatever you want
05:20:06 <srhb> reactormonk: `b <- f a; ...` now b :: b in that do block
05:21:00 <reactormonk> dredozubov, need to pass a -> b
05:21:05 <nshepperd_> Why do you want a ->b ?
05:21:22 <reactormonk> because that's what I need to pass to a function
05:21:25 <nshepperd_> Is it a map or something?
05:21:50 <nshepperd_> Most such functions have monadic variations
05:21:50 <reactormonk> nshepperd_, xmonad config
05:22:05 <fredoverflow> @pl flip ($)
05:22:06 <lambdabot> flip id
05:22:36 <fredoverflow> @pl flip (map)
05:22:36 <lambdabot> flip map
05:23:16 <nshepperd_> Oh, this problem might need an lpaste
05:23:18 <srhb> fredoverflow: pl (pointless / pointfree) refers to removing the explicit points or variables. Neither expression has any. :)
05:23:33 <fredoverflow> oh :)
05:24:16 <srhb> @pl \f x -> f $ x
05:24:17 <lambdabot> id
05:26:28 <fredoverflow> srhb: How do I write `f x` so x comes syntactically before f?
05:26:30 <reactormonk> nshepperd_, https://gist.github.com/reactormonk/fa38875763a4d571e445
05:26:47 <srhb> fredoverflow: x & f = f x
05:27:03 <srhb> > let x & f = f x in 2 & (+2)
05:27:06 <lambdabot>  4
05:27:33 <srhb> Equivalently...
05:27:44 <srhb> > let (&) = flip ($) in 2 & (+2)
05:27:46 <lambdabot>  4
05:28:17 <fredoverflow> What package is & from?
05:28:21 <srhb> I just defined it.
05:28:31 <fredoverflow> oh :)
05:28:44 <srhb> You can do the same. It's completely nonmagical. :)
05:28:55 <fredoverflow> But I would prefer standard library magic ;)
05:28:57 <srhb> You already had it as flip ($) or flip id, you just didn't name it.
05:29:21 <srhb> @hoogle a -> (a -> b) -> b
05:29:23 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:29:23 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
05:29:23 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
05:29:28 <srhb> Aw, it reorders them...
05:29:32 <srhb> It's not in base afaik.
05:30:48 <srhb> fredoverflow: I'm wrong. Data.Function has it.
05:31:10 <exio4> i's on Data.Function, since GHC 7.10
05:31:45 <nshepperd_> I see
05:31:50 <julianleviston> Magic is for muggles.
05:32:24 <nshepperd_> reactormonk: maybe you can modify your _keys to have the right form?
05:32:37 <exio4> reactormonk: that link doesn't work for me 
05:32:45 <exio4> oh, it works now, nvm
05:32:51 * hackagebot ghc-exactprint 0.5.0.1 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.5.0.1 (AlanZimmerman)
05:34:10 <nshepperd_> If you don't actually need the XConfig values to decide on your io actions when building that keymap
05:34:25 <fredoverflow> Module `Data.List' does not export `(&)'
05:34:27 <fredoverflow> :(
05:38:18 <fredoverflow> srhb: Is there an operator that is similar to >>= in the following way?
05:38:19 <fredoverflow> (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:38:19 <fredoverflow> (???) :: Monad m => m a -> (a -> b) -> m b
05:38:30 <srhb> :t liftM
05:38:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:38:40 <reactormonk> nshepperd_, I don't really, no.
05:39:03 <srhb> fredoverflow: ^
05:39:13 <fredoverflow> wrong order of arguments :-(
05:39:18 <srhb> :t flip liftM
05:39:19 <lambdabot> Monad m => m a1 -> (a1 -> r) -> m r
05:39:27 <srhb> There, done. :)
05:39:48 <srhb> fredoverflow: That's what flip is for, after all.
05:41:27 <oreilly> hello can someone tell me why my zeroOrMore/oneOrMore results in a stack-overflow ? http://lpaste.net/3022573596653387776
05:41:35 <nshepperd_> reactormonk: so maybe you can do whatever io you need, then return $ \xconfig -> pure calculation
05:41:46 <reactormonk> uhm, how can I ask ghc what type a variable is?
05:41:53 <fredoverflow> :t x
05:41:56 <lambdabot>     Ambiguous occurrence ‘x’
05:41:56 <lambdabot>     It could refer to either ‘L.x’,
05:41:56 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:147:1
05:42:06 <fredoverflow> whoops :)
05:42:07 <nshepperd_> And that will have the io (a -> b) shape you wanted
05:43:24 <julianleviston> reactormonk: we’re assuming you mean “ask GHCi what type a variable is”… and that the variable is not within a function.
05:43:49 <fredoverflow> reactormonk: Do you mean something like decltype in C++?
05:44:08 <reactormonk> julianleviston, hm, just put it a random type and looked at the error message from ghc.
05:44:33 <julianleviston> reactormonk: sorry I don’t follow what you mean. Could you re-word?
05:45:47 <nshepperd_> Emacs ghc mod has a key to do that
05:45:54 <maerwald> any1 knows if there is a haskell version of xdg-open or do I have to run the command from within the code
05:46:29 <nshepperd_> Putting in a wrong type and looking at the error message is not something i would have thought of!
05:47:00 <julianleviston> ahhh
05:47:03 <julianleviston> like….
05:47:07 <julianleviston> :t flip 1
05:47:09 <lambdabot> Num (a -> b -> c) => b -> a -> c
05:47:14 <julianleviston> oh… how interesting.
05:47:28 <julianleviston> that’s rather … odd. 
05:47:28 <julianleviston> lol
05:47:44 <julianleviston> maybe what I meant was:
05:47:44 <srhb> You can make implicit multiplication and things work like that. It's pretty fun.
05:48:19 <julianleviston> :t puts (+)
05:48:21 <lambdabot>     Not in scope: ‘puts’
05:48:21 <lambdabot>     Perhaps you meant ‘put’ (imported from Control.Monad.State)
05:48:28 <julianleviston> nvm.
05:58:14 * hackagebot jsonrpc-conduit 0.3.0 - JSON-RPC 2.0 server over a Conduit.  https://hackage.haskell.org/package/jsonrpc-conduit-0.3.0 (GabrieleSales)
06:08:23 <reactormonk> https://gist.github.com/reactormonk/5cd014798d44fdbd6785 line 200 is line 2 in the gist.
06:10:59 <julianleviston> (curious) Is Ez.mkKeymap conf supposed to have parens around it?
06:11:58 <reactormonk> julianleviston, same error
06:12:17 <julianleviston> reactormonk: I wasn’t suggesting anything, just wondering.
06:12:36 <FireFly> Shouldn't matter, function application binds higher anyway
06:12:52 <julianleviston> higher than >>= ?
06:13:11 <julianleviston> infixl 1
06:13:14 * hackagebot largeword 1.2.5 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  https://hackage.haskell.org/package/largeword-1.2.5 (DominicSteinitz)
06:13:17 <julianleviston> What is function application ? 0 ?
06:13:17 <FireFly> Sure. It binds higher than anything
06:13:32 <julianleviston> is 9 higher than 0 or the other way around?
06:13:46 <FireFly> er, I think 9 is higher
06:13:58 <julianleviston> so function application must be 9 then I guess?
06:14:04 <FireFly> I think so
06:14:07 <julianleviston> weird.
06:14:12 <julianleviston> cool.
06:14:35 <julianleviston> yeah that’s right, because ($) is infixr 0.
06:15:06 <FireFly> or I think function application is hypothetically "10", because I think it binds even higher than 9
06:15:10 <FireFly> apparently (!!) is 9
06:15:15 <FireFly> also (.)
06:16:27 <julianleviston> reactormonk: so, (_basicKeys workspaces) conf obviously returns a List… but you want a map… so you want to do M.fromList on it, right?
06:17:15 <julianleviston> What about KeyMask and KeySym tho? I don’t know what those types are. Flying completely blind here, really… 
06:17:21 <reactormonk> julianleviston, http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-EZConfig.html#v:mkKeymap
06:19:16 <julianleviston> What are you trying to write?
06:19:37 <julianleviston> are you trying to write _keys ?
06:19:46 <reactormonk> julianleviston, exactly.
06:20:40 <julianleviston> so your function has to return a map from (KeyMask,KeySym) to (X()) right?
06:23:01 <reactormonk> julianleviston, the final type should be XConfig Layout -> M.Map (KeyMask, KeySym) (X ())’
06:23:35 <reactormonk> I'm passing in the workspaces to at some other point for [Topic]
06:25:00 <julianleviston> but the type of mkKeymap is this: mkKeymap :: XConfig l -> [(String, X ())] -> Map (KeyMask, KeySym) (X ())
06:25:34 <julianleviston> :t (>>=)
06:25:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:26:04 <julianleviston> you’re using bind, but it’s not on a monadic value. is it?
06:26:19 <julianleviston> maybe this is beyond my haskell understanding.
06:26:33 <reactormonk> XConfig is a monad IIRC
06:26:33 <julianleviston> it seems to me that Haskell is choosing List as the monad.
06:27:13 <julianleviston> yeah, but your return type is a map, not a monadic value.
06:27:42 <julianleviston> at least, not THAT monadic value.
06:27:47 <reactormonk> oh, oops
06:28:50 <reactormonk> _keys workspaces = \conf -> EZ.mkKeymap conf ((_basicKeys workspaces) conf) -- works
06:28:55 <reactormonk> neat.
06:29:05 <julianleviston> excellent!
06:30:03 <julianleviston> you can get rid of one of those pairs of parens, I think…. the inner one on basic keys… can’t you?
06:41:55 <tobiasBora> Hello !
06:43:09 <tobiasBora> I have some difficulties to translate imperative code dealing with arrays into haskell code... You might help me ? The python algorithm I would like to translate is this one : http://paste.debian.net/343718/
06:44:11 <julianleviston> tobiasBora: I don’t read python… what does it do?
06:45:39 <julianleviston> I really don’t like code where it’s difficult to get the meaning from because the variables are named non-semantically.
06:45:53 <julianleviston> what is i? what is k? what is a?
06:45:59 <tobiasBora> If you want a more "intuitive" version, I have a set a_1 < a_2 < ... < a_n, and I would like to create another array/list l_0[0]..l_[a[n]] such that l_0[i] == 1 if and only if i can be written as a sum of element of a_1..a_n
06:46:32 <julianleviston> what does “written as a sum of elements” mean?
06:46:41 <tobiasBora> julianleviston: It's a mathematical problem that I'm translating in code, so I just use the same notation has my exercice...
06:47:00 <julianleviston> I don’t understand the underscore notation.
06:47:48 <julianleviston> what does “written as a sum of elements” mean?
06:47:50 <tobiasBora> julianleviston: that means that it exists k_1 ... k_n, all positive integers such that l_0[i] = k_1 * a_1 + k_2 * a_2 + ... + k_n * a_n
06:48:14 <julianleviston> I don’t understand what the underscores mean… 
06:48:22 <julianleviston> are they supposed to be subscript markers?
06:49:20 <tobiasBora> julianleviston: The underscore notation doesn't mean anything special. It usually refers to tha LaTeX notation that in a_i i is in subscript, but if you prefer I could write ai
06:49:43 <julianleviston> I’m just trying to understand what you’re wanting, is all.
06:49:59 <julianleviston> This seems like a very complex thing to start with.
06:50:01 <tobiasBora> julianleviston: Yes yes I understand, no problem
06:50:23 <julianleviston> I would decompose it into a set of smaller problems and solve each of those.
06:50:27 <tobiasBora> In fact the algorithm I used isn't very complicated
06:50:48 <julianleviston> No, I’m meaning this seems like a complicated thing to start writing haskell with.
06:50:55 <julianleviston> If you’ve never done FP before.
06:51:06 <julianleviston> but no matter
06:51:13 <julianleviston> You can always divide it into pieces.
06:51:14 <tobiasBora> julianleviston: I'm quite familiar now with FP.
06:51:24 <julianleviston> ah ok. So what are you having trouble with?
06:51:29 <tobiasBora> I just do not know how to deal with arrays
06:51:43 <julianleviston> do you mean lists, or do you actually mean arrays?
06:52:02 <julianleviston> If you’re quite familiar with FP, I don’t see how you don’t know how to use lists.
06:52:33 <ARM9> assuming he's familiar with fp and knows how to use lists, it would be reasonable to assume he would want to move on to using arrays
06:52:36 <tobiasBora> Well arrays would be better here cause I need to look forward often to see the value of the elements before the current elements
06:52:44 <julianleviston> ok you do mean arrays.
06:52:57 <ARM9> arrays are superior to lists 99% of the time on a modern computer anyway
06:53:01 <julianleviston> Have you looked at the hackage documentation?
06:53:16 * hackagebot binary-strict 0.4.8.3 - Binary deserialisation using strict ByteStrings  https://hackage.haskell.org/package/binary-strict-0.4.8.3 (DominicSteinitz)
06:53:27 <julianleviston> The documentation for Data.Array ?
06:53:35 <tobiasBora> julianleviston: Yes, but writting such a description isn't easy...
06:53:41 <tobiasBora> julianleviston: I looked in Data.Array.IArray
06:53:44 <srhb> ARM9: That's a very strange claim.
06:53:55 <julianleviston> srhb: ah let him have his claim. 
06:53:59 <julianleviston> or her.
06:54:31 <ARM9> srhb computer scientists would agree
06:54:43 <ARM9> locality of reference is king
06:55:04 <julianleviston> ARM9: it’s colossally irrelevant for this discussion.
06:55:30 <ARM9> except it's not if you read what tobiasBora wrote
06:55:38 <ARM9> assuming we're still trying to help him
06:55:54 <julianleviston> ARM9: seriously it’s irrelevant. He wants Arrays, so that’s what we’re doing. 
06:56:39 <julianleviston> tobiasBora: what does “writing such a description” mean?
06:56:45 <julianleviston> tobiasBora: do you mean using them isn’t easy?
06:57:39 <tobiasBora> julianleviston: Well I'm not sure to see how I could use the list comprehension syntax to descript a problem with complex for/while loops, but I may try (this problem isn't that complex)
06:58:14 <julianleviston> tobiasBora: wait, what does this have to do with list comprehensions?
06:58:33 <julianleviston> tobiasBora: I thought you wanted to use Arrays ?
06:59:06 <julianleviston> tobiasBora: take a read of https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array.html
06:59:23 <tobiasBora> julianleviston: Yes, but in the documentation, they build array like that :
06:59:26 <tobiasBora> a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \<- [2..100]])
06:59:34 <tobiasBora> And it's looks pretty much like list comprehension
07:00:33 <julianleviston> They’re using a list comprehension to build a list that gets passed to the array function… because it takes a list of association values that way (list of pairs).
07:02:33 <julianleviston> tobiasBora: you could equally write array (1,100) [] 
07:02:33 * tobiasBora is trying to implement it with arrays
07:03:17 <julianleviston> tobiasBora: you mentioned originally that the translation from imperative to functional was what was catching you. That’s why I assumed you weren’t really up to speed with FP. Sorry for that.
07:03:20 <tobiasBora> julianleviston: Yes I understand, but the syntax is interesting since it allow us to refer to others elements of the array. I will give it a try
07:04:01 <julianleviston> tobiasBora: the (!) and (//) functions will probably be very useful to you.
07:04:26 <tobiasBora> julianleviston: No problem. My mind is a little be blur with this problem, but maybe there isn't any reason for that
07:04:44 <julianleviston> what does “be blur” mean?
07:04:53 <julianleviston> you’re a little confused with this problem?
07:05:48 <tobiasBora> yes
07:05:53 <julianleviston> Why is that?
07:05:57 <tobiasBora> How, // is interesting indeed !
07:06:03 <julianleviston> I’m not really understanding what you’re missing.
07:06:29 <tobiasBora> I'll see it when I will try to write it. I come back in a few minutes with a good or bad news !
07:06:36 <julianleviston> haha ok
07:11:35 <zergless> Hey, So I'm trying to implement a balanced partition in haskell, I think I have the algorithm in my head but trying to code it I'm having trouble http://lpaste.net/4028718833052155904 anyone mind point out where I'm going wrong?
07:12:12 <mniip> I wonder if it's possible to make parsing/serializing lenses :o
07:13:07 <maerwald> mniip: you think it needs more complexity?
07:13:16 * hackagebot pinchot 0.4.0.0 - Build parsers and ASTs for context-free grammars  https://hackage.haskell.org/package/pinchot-0.4.0.0 (OmariNorman)
07:14:46 <julianleviston> zergless: what does this mean? balancedpartitions z = (x,y)
07:15:00 <julianleviston> zergless: where do x and y come from?
07:15:21 <zergless> I wanted them to be the lists that are outputted at the end
07:15:36 <julianleviston> zergless: I don’t follow.
07:15:57 <julianleviston> zergless: z like that will match ANY list.
07:16:23 <julianleviston> zergless: but the thing to the right of “=“ you can’t just make up variable names!
07:16:31 <julianleviston> zergless: you have to use things that already exist.
07:16:34 <zergless> ahhh
07:16:53 <julianleviston> zergless: you should try with simpler code first, perhaps.
07:17:08 <julianleviston> zergless: like, perhaps do a simpler recursive function or two first.
07:17:29 <julianleviston> Then work your way up to whatever it is you’re trying to do.
07:19:48 <julianleviston> zergless: check out a few of the examples on my examples page under “lists” - they might help solidify your understanding a bit. 
07:19:53 <julianleviston> zergless: http://www.genericoverlords.com/haskell_exercises
07:20:34 <zergless> julianleviston: Thanks!
07:29:46 <mniip> > over (iso (read :: String -> [Int]) show . ix 1) (+5) "[1,2,3]" -- maerwald
07:29:49 <lambdabot>  "[1,7,3]"
07:31:19 <tobiasBora> julianleviston: I found a solution ! http://paste.debian.net/343725/
07:31:31 <julianleviston> excellent news! :)
07:31:36 <tobiasBora> I don't know if it's the better one, but it works. Thank you for your help ;)
07:32:52 <julianleviston> tobiasBora: is_sum_of_elemets_of confuses me a lot, but as long as you’re happy, all good!
07:33:08 <julianleviston> tobiasBora: haha all I did was tell you you could do it! :) 
07:39:17 <maerwald> anyone knows a good filesystem watcher in haskell? gio binding is ...just a binding and fsnotify isn't able to watch directories, only its contents
07:40:10 <julianleviston> maerwald: I’ve wondered that before. I’ve often seen the remnants of ‘guard’ in haskell github projects, but that’s a ruby program.
07:40:23 <julianleviston> still, what work works!
07:40:36 <maerwald> I'm not going to depend on ruby in any way
07:40:55 <julianleviston> maerwald: would you write one yourself?
07:41:22 <maerwald> no
07:41:27 <julianleviston> maerwald: have you used watcher?
07:41:42 <julianleviston> https://hackage.haskell.org/package/watcher
07:42:00 <julianleviston> maerwald: I haven’t, I just did some googling for you.
07:42:31 <maerwald> I can google myself, thanks. When I ask about libraries I usually want to hear about experience with it.
07:42:45 <julianleviston> maerwald: sorry, you *did* say that.
07:42:51 <julianleviston> maerwald: I’ll be quiet. apologies.
07:43:17 * hackagebot lattices 1.5.0 - Fine-grained library for constructing and manipulating lattices  https://hackage.haskell.org/package/lattices-1.5.0 (phadej)
07:43:20 <maerwald> sure, I can try them all out one by one, but it saves time if someone can tell me "go for this"
07:44:01 <maerwald> watcher looks very rudimentary
07:44:09 <julianleviston> there’s also twitch
07:44:15 <julianleviston> which looks cool.
07:44:28 <julianleviston> it uses fsnotify.
07:44:37 <julianleviston> I guess it depends what you want the notification to do, too...
07:51:55 <maerwald> mh, doesn't look like it lets me easily delete watchers
07:52:27 <maerwald> I'll have to use the fsnotify bindings directly then
07:53:46 <zergless> julianleviston: in this example. Whats the difference between splitlist [x] and splitlist x http://lpaste.net/8966629341555326976 
07:53:59 <zergless> I think x is a list but im not sure what the  [] change
07:54:12 <julianleviston> zergless: [x] is a list with one element bound to x
07:54:23 <julianleviston> zergless: x is a list with anything in it (even empty)
07:54:37 <zergless> so [x] cannot be empty?
07:54:46 <julianleviston> so, because they’re in order, it matches the one-item list first, then the any-length list
07:54:54 <julianleviston> zergless: right. It has to have one item in it.
07:55:09 <zergless> Thanks
07:55:14 <julianleviston> zergless: glad you found that one. It’s very appropriate for you.
07:55:29 <zergless> im starting to think i dont need the x and y
07:55:43 <zergless> but im not sure
07:55:45 <julianleviston> zergless: well they don’t mean anything, so the compiler won’t accept them.
07:56:35 <julianleviston> zergless: I wasn’t *quite* sure what you were meaning by a balancedWhateverYouSaid… either.
07:56:42 <zergless> oh
07:56:44 <zergless> one sec
07:56:53 <julianleviston> zergless: I’m guessing you wanted to put half the items in one list half in the other or something?
07:56:55 <oreilly> can someone tell me one correct way to not end in the infinte loop and get stackoverflow ? http://lpaste.net/3022573596653387776
07:57:11 <zergless> For example, given the list/arary [1,2,3,4,5], the balanced partitions could be [1,3,4] and [2,5], or [1,2,4] and [3,5], or [1,2,5] and [3,4]
07:57:35 <julianleviston> ah, so it sorts alternating items into two lists?
07:58:22 <julianleviston> zergless: do you want to use recursion, or you don’t mind doing it any old way?
07:58:40 <zergless> the list should be split in such a way that the difference betweent he two lists in minimized
07:58:47 <zergless> any old way
07:59:00 <zergless> will do :) this was just what came to mind
08:00:13 <zergless> I wanted to sort and reverse the list so i start with the bigger numbers first
08:00:18 <zergless> so the difference is minimised
08:00:24 <julianleviston> zergless: you could split the list in half (using drop on one), then zip them together, with a list comprehension.
08:00:35 <julianleviston> maybe.
08:00:46 <zergless> what does the zip do?
08:00:50 <julianleviston> :t zip
08:00:55 <lambdabot> [a] -> [b] -> [(a, b)]
08:01:09 <julianleviston> actually that’s not what you want to do. You want a pair of lists...
08:01:32 <julianleviston> hm… and I’m guessing you’re not familiar with using List as a monad, so maybe not that way.
08:01:46 <zergless> nope
08:01:53 <julianleviston> that’s a silly way anyway, probably.
08:02:09 <zergless> https://en.wikipedia.org/wiki/Partition_problem#The_greedy_algorithm i was trying to implemet this
08:02:16 <julianleviston> :t concapMap
08:02:18 <lambdabot>     Not in scope: ‘concapMap’
08:02:19 <lambdabot>     Perhaps you meant one of these:
08:02:19 <lambdabot>       ‘concatMap’ (imported from Data.Foldable),
08:02:20 <julianleviston> :t concatMap
08:02:22 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
08:03:08 <julianleviston> ohhhh partition by sum.
08:03:17 <julianleviston> I thought you wanted partition by list length. haha :)
08:03:30 <zergless> oh no by sum sorry, should ahve been more clear :)
08:03:35 <julianleviston> probably recursion is best… or fold if you want.
08:03:42 <julianleviston> zergless: have you done folds?
08:03:50 <zergless> I think ill stick with recursion
08:03:54 <zergless> havent done folds no
08:04:00 <julianleviston> zergless: I’m guessing not if you didn’t know that [x] pattern matched a 1-element item.
08:04:18 <julianleviston> zergless: folds are really only good once you know how they work inside - and that’s recursion, so yes.
08:04:46 <julianleviston> zergless: so you want a function that has a helper function in it, I’m guessing
08:05:16 <julianleviston> zergless: the type of the outer function is find_partition :: Num a => [a]
08:05:23 <julianleviston> oops
08:05:45 <mr_rm> when i'm using "stack ghci" (on windows), I can't get the newly set prompt to persist to the next session. I put the command in a file ".ghci" in %userprofile% but restarting doesn't seem to run it. is there something else i should be doing.
08:05:46 <julianleviston> find_partition :: Num a => [a] => ([a],[a])
08:06:21 <zergless> what would find_partition do?
08:06:38 <julianleviston> mr_rm: GHC has some settings it keeps in a file IIRC. I’m not sure off the top of my head - could do with looking up the docs for it?
08:07:04 <julianleviston> zergless: it takes a list of type a, where a is a Num, and returns a pair of lists of that type. Right?
08:07:26 <julianleviston> I made a typo.
08:07:30 <zergless> Yep
08:07:37 <mr_rm> julianleviston: yeah, that file is .ghci and should go in in your home dir according to the docs :)
08:07:44 <geekosaur> mr_rm, I think windows uses ghci.ini
08:07:50 <julianleviston> find_partition :: Num a => [a] -> ([a],[a])
08:07:57 <julianleviston> zergless: sorry… I’m tired.
08:08:11 <pavolzetor> anybody doing the advent of code stuff, did you use some different algorithm or just TSP from day 9?
08:08:21 <pavolzetor> (I am interested in different algorithms)
08:08:23 <zergless> julianleviston: no worries
08:08:31 <julianleviston> zergless: so you can use the type signature to guide the code you write.
08:08:43 <geekosaur> sorry, it's ghci.conf
08:09:02 <geekosaur> "appdata/ghc/ghci.conf, where appdata depends on your system, but is usually something like C:/Documents and Settings/user/Application Data"
08:09:04 <julianleviston> zergless: you can write *some* of the patterns you already know there. for example find_partition [] = ([],[]) right?
08:09:28 <julianleviston> zergless: and find_partition [x] = ([x], [])
08:09:42 <zergless> would return two empty lists if its empty
08:09:46 <mr_rm> geekosaur: thank you. i was trying to find that for a while and just didn't come across it in the docs
08:09:57 <zergless> and return a list with x is x is the only item in the original list
08:09:59 <julianleviston> zergless: and find_partition [x,y] = ([x],[y])
08:10:02 <geekosaur> tat's from the ghc manual, section "The .ghci file"
08:10:03 <julianleviston> yep.
08:10:07 <mr_rm> lol
08:10:41 <julianleviston> zergless: then the only case left over is the difficult case, which you’ll need another function for, that does some recursion.
08:11:32 <zergless> so find_partition does those 3 base cases and calls some other function for the recursion?
08:11:44 <julianleviston> zergless: your helper function can be “in the same function”… using a where clause…
08:12:23 <julianleviston> zergless: or, it can be external to that function if you’d prefer. If you’re beginning it often helps to write it externally first then put it in after… it’s a bit easier to write the type signature for it when it’s externally.
08:12:25 <mr_rm> geekosaur: i was stuck on using .ghci as on Linux. got tunnel vision there. thanks for answer my stupid question :)
08:13:10 <julianleviston> zergless: it can help a lot to think of the type signature first… what do you want the function to do - from the outside?
08:14:40 <julianleviston> zergless: or, if that’s tricky, another way to approach it is to go about trying to use it… so, write the last case “as though you had the second function you need already and it magically worked” 
08:17:52 <zergless> find_partitions (x:xs) = balancedpartitions x. I think
08:18:17 <julianleviston> zergless: (x:xs) binds x to head and xs to tail.
08:18:46 <zergless> just x then? for any list?
08:18:46 <julianleviston> zergless: You want a function that takes a pair of lists, and a list, and returns a pair of lists. 
08:18:58 <julianleviston> zergless: you’ve already got those other cases done.
08:19:05 <zergless> ah
08:19:06 <zergless> ok
08:19:15 * zergless is also tired :(
08:19:36 <julianleviston> zergless: so find_partitions (x:y:zs) = balancedLists ([x],[y]) zs
08:19:49 <julianleviston> then you can write balancedLists
08:21:31 <julianleviston> zergless: like I said, this is definitely advanced recursion to start doing recursion with. Would recommend doing something simpler first (actually doing some of the exercises without looking at the answers until you’ve finished a few times, for example).
08:22:15 <julianleviston> zergless: anyway I’m really tired, so I’m going to go. Good luck!
08:22:25 <zergless> no worries! thanks for the help
08:27:57 <hexagoxel> is there a way to make the cabal/ghc module build order more deterministic?
08:28:01 <hexagoxel> i frequently encounter the case that some changes create errors in multiple modules.
08:29:08 <hexagoxel> i (try to) fix the first of the errors, and trigger a rebuild, and now the first error is from an unrelated different module.
08:29:46 <monochrom> do you know that you didn't fix the first of the errors?
08:29:51 <hexagoxel> even though the changed module still contains errors.
08:31:41 <hexagoxel> (even adding a typed hole to work on the first error can cause this)
08:32:51 <hexagoxel> does this happen to anyone else? any hints if this is related to ghc or cabal-install? can this happen with stack?
08:35:10 <hexagoxel> (hmm maybe it is not build order, but just output order, if the build happens in parallel?)
08:40:01 <Light__> what is this channel used for?
08:41:10 <hrnz> haskell?
08:41:44 <Light__> thanks for the insite :P
08:42:15 <zergless> well
08:42:26 <zergless> I thought he channel name was obvious
08:43:23 <Clint> yes, it's obviously for talking about eddie haskell
08:43:59 * ackthet leavs it to beaver to write haskell
08:44:07 <ackthet> *leaves
08:47:51 <rvx> anyone have recommendations to do web-based charting? for example, using yesod + highcharts somehow (ideally avoiding writing javascript directly)...
09:02:21 <adamCS> rvx: depends how complicated the charts are.  Wrapping some simple flot charts for yesod was pretty easy.  You have to write some small bits of js via julius but nothing too bad.  
09:04:34 <adamCS> rvx: http://www.flotcharts.org/
09:08:14 <adamCS> rvx: Example wrapper (probably not the best way but works for me): http://pastebin.com/fnPE4C6j
09:10:55 <rvx> adamCS thanks plots might not be that complicated, but ideally i'd like to be able to work nearly-interactively
09:11:52 <rvx> adamCS adjusting data munging plot parameters, going int ghci and iterating
09:36:17 <rvx> adamCS what is this "import Import" - "Import" package? (having a hard time googling that...)
09:36:29 <pdkr> when does the DataKind promotion happen? are the respective types and kinds generated before or after TH?
09:37:17 <pdkr> rvx: Import will usually specify some local set of imports that are used throughout the code
09:37:26 <pdkr> so look for an Import.hs file nearby
09:38:22 * hackagebot haphviz 0.1.0.2 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.0.2 (Norfair)
09:38:47 <tommd> haphviz??  Typo?
09:39:18 <srhb> tommd: Why would it be?
09:39:47 <pdkr> tommd: would be quite a persistent typo... probably the author is completely missing the "g" and "r" keys
09:39:58 <tommd> Yes, I suppose so.
09:40:24 <tommd> srhb: It was close enough to a typo that it made me question.  Oh no, another package going out of its way to start with an h!
09:40:35 <srhb> :-)
09:41:13 <tommd> Yours, srhb?
09:41:25 <srhb> Nope. But yes, there is a tendency :P
09:45:14 <monochrom> hrapgviz
09:48:37 <please_help> edwardk is the ad developer, right?
09:56:41 <spion> has anyone tried writing a hoogle-based tool that takes the function's type definition, the value in scope and then does a graph search for possible solutions that satisfy the function type? :)
09:57:39 <Jinxit> seems to me like there would be no end to that search
09:57:55 <Jinxit> you can always insert one more map id
09:57:56 <spion> the depth would be limited
09:59:18 <spion> and it would exclude generating constants, you'd have to make the constant defined e.g. in let myConstant = "test"
09:59:44 <Jinxit> what's the use case?
10:02:21 <spion> no particular use case in mind, just research/experimentation. 
10:02:45 <spion> but ultimately, a program writing assistant
10:04:32 <rvx> pdkr thanks
10:05:13 <rvx> please_help yes
10:06:52 <kadoban> :exf Text -> Text -> Text -- spion
10:06:52 <exferenceBot> mappend
10:06:52 <exferenceBot> \ t1 t2 -> mappend t2 t1
10:08:09 <spion> kadoban: cool! thats based on https://github.com/lspitzner/exference correct?
10:09:05 <mniip> :exf Int -> Int
10:09:05 <exferenceBot> id
10:11:42 <lspitzner> spion: yes.
10:14:02 <fuzzyhorns> is there an equivalent in haskell to fsharp's type providers, or active patterns?
10:14:20 <tommd> Can you explain those in more general terms?
10:15:01 <c_wraith> They're basically what you can do with template haskell, but with extra features that integrate with the IDE
10:17:01 <c_wraith> Think compile-time inspection of the environment (often, but not always, a database) to generate types.
10:20:34 <tommd> Conceptually, you can use Template Haskell to do just about anything.  This doesn't make TH a good solution to the problem, or even most problems.  So I'd have to say "no" Haskell does not support equivalent features.
10:23:27 <fuzzyhorns> yeah that explains type providers
10:23:45 <fuzzyhorns> active patterns mean you can separately define a thing that you use in your matches
10:24:33 <tommd> fuzzyhorns: Perhaps like Haskell's Pattern Synonyms?
10:24:46 <fuzzyhorns> i'll look that way, ty tommd :)
10:25:32 <tommd> fuzzyhorns: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html see section 7.3.9
10:26:29 <fuzzyhorns> thanks!
10:26:35 <please_help> Just found this quote from edwardk : "My current HMC implementation in Haskell is effectively using automatic differentiation inside an EDSL that describes programs to run on a GPU." which dates from 2 years ago. I'm interested in using haskell for ML, which means I'd like a symbolic differentiation framework (which AD can apparently provide), and also the ability to work with large arrays on the GPU using GPU-accelerated 
10:26:35 <please_help> BLAS+LAPACK (and more). Does anyone know which EDSL he was referring to, or which packages could be used for my intended task?
10:27:20 <RedNifre> Hi. Are both "<-" and "=<<" called "bind"? Or does the left arrow have a different name?
10:27:39 <sunnymilk> <- isnt a real thing, its just syntactic sugar
10:27:47 <sunnymilk> =<< is a real function though
10:27:47 <RedNifre> yeah, but how do you call it?
10:27:57 <sunnymilk> left arrow? im not really sure
10:28:05 <tommd> please_help: accelerate would be my first guess, but with edwardk it's also likely to be something unreleased.
10:37:18 <please_help> tommd: I'll check it out.
10:37:44 <edwardk> please_help: I wound up rolling my own AD implementation and EDSL, but that code didn't wind up open sourced, it wound up sold. Sorry.
10:39:37 <edwardk> You could use 'ad' on a 'bound' based EDSL. You might want to look at the way Nikola does observable application, that is useful for GPU-based EDSLs.
10:40:29 <edwardk> But basically I just built a DSL for the kinds of probabilistic programs that I was interested in, then wrote a bunch of interpreters/compilers for it, some of which used AD as part of HMC.
10:41:30 <please_help> edwardk: OK. By the way, how's the performance on AD? Can it handle evaluating diffs on millions of parameters within ~0.5s? Or can I augment it as discussed to get that kind of performance?
10:42:41 <edwardk> AD itself works pointwise. A vector/matrix based AD could be faster for things on that scale, but it has been used up at that level by folks doing computer vision and financial risk assessment.
10:42:41 <zergless> I got some help from people here earlier but still struggling with the problem. im trying to implement the greedy algorithm for a balanced partition. 
10:43:06 <MarcelineVQ> What does HMC mean here?
10:43:08 <edwardk> If you use AD on a DSL rather than directly then those concerns vanish
10:43:16 <edwardk> hybrid monte carlo or hamiltonian monte carlo
10:43:22 <zergless> For example, given the array [1,2,3,4,5], the balanced partitions could be [1,3,4] and [2,5], or [1,2,4] and [3,5], or [1,2,5] and [3,4]. but my knowledge of haskell type errors comfuses me http://lpaste.net/4351044420536107008
10:43:31 <MarcelineVQ> oh ok :D
10:43:53 <edwardk> http://www.mcmchandbook.net/HandbookChapter5.pdf is a pretty approachable introduction to the topic
10:44:44 <MarcelineVQ> very cool thank you
10:45:50 <lyxia> zergless: the first error says find_partition should output a pair (... -> ([a], [a])), but balancedlists outputs a list (... -> [a]).
10:46:12 <edwardk> making it industrial strength is a trickier proposition. Gelman has a project called STAN in C++ that fixes up the major issues with it. And there is some research out of Microsoft Research Cambridge by Girolami and Calderhead that can fix other issues that STAN doesn't.
10:46:43 <lyxia> zergless: the second one says balancedlists expects a list of lists as the first argument ([[a]] -> ...), but you passed it a pair (x, y), which is indeed not a list.
10:47:10 <edwardk> But it is probably the closest thing to a 'well-behaved universal sampling technique' that I know of right now.
10:49:12 <lyxia> zergless: why is the first argument a list of lists [[a]] though? It looks like it should be a list [a].
10:50:59 <zergless> lyxia: to make (x,y) a list of lists shoudl it be ([x],[y])?
10:51:11 <lyxia> zergless: That's a pair of lists
10:52:39 <zergless> now ive started to confuse myself
10:53:12 <lyxia> In Haskell, pairs have a different type from lists.
10:56:30 <lyxia> zergless: are you trying to construct just one balanced partition?
10:57:03 <zergless> take in one list return a pair of lists
10:57:08 <zergless> so two partitions
10:57:24 <lyxia> uh
10:57:34 <lyxia> the whole pair is what we call "a partition"
10:57:49 <lyxia> each element being a "part"
10:57:56 <lyxia> well
10:58:13 <lyxia> that's just my interpretation, nevermind
10:58:19 <zergless> then just return one partition, with 2 parts
10:59:10 <lyxia> (Partition is synonymous with part as well, my hard drive has partitions... so nevermind :)
10:59:51 <zergless> ha well ive reduced my errors!
10:59:53 <zergless> \o/
11:01:43 <zergless> http://lpaste.net/4351044420536107008
11:01:55 <zergless> first error is expected a list got a pair of lists?
11:02:56 <zergless> down to one error :D
11:03:04 <lyxia> that looks a bit better indeed!
11:03:06 <zergless> lyxia: Cheers! been struggling with this for hours :(
11:04:02 <zergless> http://lpaste.net/4351044420536107008
11:04:46 <lyxia> zergless: the pattern should be (x,y) at line 8
11:05:19 <lyxia> And don't forget the base case when the last argument is empty
11:05:36 <zergless> in balancedlists?
11:06:35 <tommd> edwardk: I'm a little stymed by the fact that conjugateGradientDescent does not decend propery for log-barrier functions.  Could I get your thoughts on that?
11:07:51 <tommd> edwardk: It seems the ad package needs something like gradientDescent (in that it actually descends for functions of interest) that performs better on higher dimensional or lower-gradient functions.
11:08:00 <Pozzuh> Hi again, I need some help with IO monads (?) I have a function that uses IO and returns a tuple, I can call it like `let x = doThing` and I can use x just fine. But when I try `let (x,y) = doThing` I get an unexpected type error
11:08:06 <Pozzuh> Could someone point me in the right direction?
11:08:35 <tommd> Pozzuh.  So `doThink :: IO (a,b)`?
11:09:07 <tommd> This is an action that returns a tuple.  If you say let x = doThink then `x :: IO (a ,b)`.  You need to execute the action to acquire and pattern match on the tuple.
11:09:13 <tommd> (x,y) <- doThing
11:11:19 <Pozzuh> Thanks tommd, <- works. What's that operator called?
11:11:21 <lamefun> Can I make sort of data structures for type variables?
11:11:34 <zergless> lyxia: should that not be covered by find_partitions [] = ([], [])
11:12:53 <aweinstock> Pozzuh: (do x <- y; f x) is equivalent to (y >>= (\x -> f x))
11:13:21 <aweinstock> (<- isn't an operator, it's part of do-notation syntax, it desugars into a use of the function (>>=))
11:13:30 <aweinstock> :t (>>=)
11:13:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:19:08 <tommd> Pozzuh: (>>=) is called bind.
11:19:43 <tommd> I read (x <- f) as "bind x to the result of f" but '<-' is itself not an operator, as aweinstock said.
11:20:09 <please_help> Are there any modern benchmarks for the accelerate backends? The ones I find date back from 2011.
11:20:11 <maerwald> I hope there are no tutorials out there that start with do-notation instead of bind
11:20:28 <tommd> please_help: What makes you think the ones from 2011 are no longer representative?
11:20:37 <Cale> Pozzuh: Something very important to understand: a value of type IO t is not very similar to a value of type t. Rather, it's a description of a program which if executed, would produce a result of type t if it terminates normally.
11:21:02 <Cale> Pozzuh: That is, the difference between IO String and String is similar to the difference between /bin/ls and a list of files
11:21:27 <Cale> Pozzuh: When you write v <- x in a do-block it means "run the action x and call whatever its result is v"
11:21:57 <Cale> Pozzuh: If x :: IO t, then v :: t
11:22:15 <Cale> and, given that x is an IO action the do-block as a whole will also be an IO action, whose result is the same as the result of the last action in it.
11:22:50 <Pozzuh> Hmm, thanks for the help so far. I think I need to do some more reading
11:23:18 <tommd> Pozzuh: Do you know C or Java?
11:23:29 <Pozzuh> Yes
11:23:30 <lyxia> zergless: no. Note that balancedlists does not return any value without that base case.
11:24:07 <tommd> Pozzuh: You can think of the C gets() function as an action of type `IO String` (very loose analogy, do not read too far into it)
11:24:23 <tommd> So what is the first character of `gets`?  That question makes no sense.
11:24:45 <tommd> Similarly, what are the two elements of `IO (a,b)`?  Bad question - that's an operation that will give you a tuple.
11:25:03 <lyxia> zergless: in fact you don't even need the three first clauses in find_partitions. find_partitions xs = balancedlists [] [] xs, or simpler, find_partitions = balancedlists [] []
11:25:21 <Cale> Pozzuh: Oh, it's also worth saying that when you write  let v = x  by contrast, it defines v and x to be the same thing.
11:25:54 <Cale> Pozzuh: So, if x happened to be an IO action, then v would be one as well, and none of the effects of running x are carried out just by making this declaration that v and x should be equal.
11:25:59 <please_help> tommd: because 2011 was very long ago. If these benchmarks are still representative, then accelerate is now over 100x slower than plain cuda or opencl, and the accelerate backend is completely unusable.
11:26:14 <please_help> the opencl accelerate backend*
11:26:50 <pikajude> is it possible to catch the "Missing field in record construction" exception?
11:27:43 <tommd> All exceptions that can be caught: catch (\(e::SomeException) -> undefined)
11:27:56 <pikajude> ok
11:28:05 <pikajude> that doesn't seem to have any effect for me
11:28:21 <maerwald> isn't that a compile-time warning anyway? I wonder why it's not a compile-time error
11:28:25 <tommd> Are you sure your test is good?  Is the exception in a thunk?
11:28:32 <pikajude> maerwald: it is if you use Werror
11:28:39 <Pozzuh> I think I'm beginning to understand. Thanks everyone. Gonna do some tinkering and bother you guys again when I get stuck again hehe
11:28:49 <maerwald> pikajude: sure, but why not by default 
11:29:02 <pikajude> idk
11:29:21 <maerwald> I can't think of a use case where I'd want an uninitialized field in my data structure
11:29:27 <pikajude> i can
11:29:35 <Cale> Pozzuh: definitely, feel free :)
11:29:49 <pikajude> my parser composes it from sections of this XML document and some of the attributes of the data structure depend on others being parsed at a later date
11:30:22 <zergless> lyxia: remove the base cases in find_partitions add find_partitions xs = balancedlists [] [] xs and add a basecase to balancedlists?
11:30:22 <pikajude> here you go http://lpaste.net/147024
11:30:29 <pikajude> this program prints "Foo {bar = catch.hs:5:20-24: Missing field in record construction bar
11:31:35 <maerwald> pikajude: I think that can still be done in another way, like intermediate data structures or even Maybe
11:31:57 <pikajude> it sure can
11:32:17 <tommd> pikajude: You are catching the exception
11:32:20 <tommd> And printing it...
11:32:25 <tommd> How about you do something more noticable
11:32:29 <pikajude> oh, ok
11:32:29 <tommd> print "handled"
11:32:48 * tommd runs off
11:33:17 <pikajude> thanks tommd 
11:38:30 <lyxia> zergless: I mean replace all clauses of find_partitions by what I wrote.
11:38:44 * hackagebot haphviz 0.1.0.2 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.0.2 (Norfair)
11:38:44 * hackagebot stack 0.1.10.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.10.1 (borsboom)
11:38:57 <lyxia> zergless: basically, base cases of find_partitions are redundant with what balancedlists can do.
11:39:15 <lyxia> zergless: and balancedlists is currently incomplete. These are two independent remarks.
11:46:30 <pdkr> is there any reason to /not/ mark a module as Trustworthy (if I can't make it Safe)?
11:51:30 <int-e> pdkr: yes, if it actually exports unsafe functionality (allowing unsafe coercions or performing uncontrolled IO actions from pure functions)
11:52:13 <pdkr> int-e: okay, so I guess that if I have a sane API, this should not be the case?
11:56:11 <Pozzuh> Could someone look at this for me? http://pastebin.com/SgBT7bea Are there any obvious mistakes? Getting a bit error on the '<-' line and I have no idea what it means. evaluateBlock is caleld first btw.
11:57:55 <pdkr> Pozzuh: what's the monad of the do block starting on line 10?
11:57:58 <Pozzuh> error http://pastebin.com/Uy3iejEf , as I understood it <- should execute evalStatement and (newState, succes) should both be usable as normal variables
11:58:26 <pdkr> Pozzuh: note: "do" syntax is just syntactic sugar for monadic computations
11:58:31 <pdkr> e.g. IO stuff
11:58:34 <Pozzuh> I'm not sure what you mean by that question
11:59:03 <pdkr> Pozzuh: okay, then I suppose that's the obvious mistake :)
11:59:12 <Pozzuh> I tried rewriting it without "do" but I basically get the same errors
11:59:29 <Pozzuh> `let (newState, succes) = evalStatement state statement in` ... case stuff
11:59:47 <pdkr> Pozzuh: you can't use evalStatement inside a pure function
11:59:53 <Cale> Pozzuh: you probably want  return newState  on line 13, rather than newState
11:59:55 <pdkr> because evalStatement is not pure
12:00:00 <Pozzuh> this doesn't work because the evalStatement is a 'IO action' I undersrtand now
12:00:08 <pdkr> right
12:00:12 <Cale> Pozzuh: return :: a -> IO a  will give you an IO action which does nothing except to return the given value
12:00:41 <Cale> Pozzuh: I don't know what type evalOperator has, but every branch of a case expression has to have the same type
12:01:18 <Cale> and the case expression itself there is a statement in a do-block in which an IO action is being executed, so it must itself be an IO action
12:01:36 <Cale> also, the do-block as a whole will be an IO action, so the type of processStatement is wrong
12:01:39 <Pozzuh> it has the same type as processStatement.
12:01:41 <Cale> (the signature)
12:02:22 <Cale> It appears that you want  processStatement :: ProgramState -> Statement -> IO ProgramState
12:05:36 <Pozzuh> I changed the signature on processStatement to that, and also changed the `let endState ...` in evaluateBlock to use <-
12:06:13 <Pozzuh> but that makes my foldl wrong, so the first argument of processStatement should be IO too?
12:06:23 <kojo> Hi! I'm trying to write a test generator for a recursive datatype, where the generator function takes an int parameter that will limit the height of the recursion tree. Thing is, I'm not sure how to have a recursive call to the generator as a part of the function. Does anyone know how to accomplish this?
12:07:09 <Hijiri> you could refer to the generator by name
12:07:22 <Cale> Pozzuh: You usually don't want the arguments of your functions to be IO actions, unless you really need the option about whether or not to execute the action, or the option to run it multiple times
12:07:46 <Cale> :t foldM
12:07:47 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
12:08:02 <Cale> well, that's obscured a bit by Foldable
12:08:12 <Cale> but it specialises to
12:08:25 <Cale> (b -> a -> IO b) -> b -> [a] -> IO b
12:08:58 <Cale> Pozzuh: You might want to replace the foldl with that
12:09:50 <Pozzuh> Tyvm so far, foldM fixed my errors. Now to see if it's actually functioning...
12:10:48 <pdkr> Pozzuh: obvious exercise: implement your own version of foldM
12:11:33 <Pozzuh> Yeah that would probably help me to understand monads a lot
12:11:38 <Cale> Pozzuh: As an example of what can be done by having arguments of functions which are actions, we can write   twice x = do a <- x; b <- x; return (a,b)
12:11:55 <Cale> Pozzuh: If we then run   twice getLine
12:12:10 <Cale> It will get two lines of text from the user, and return the pair of strings
12:12:49 <Cale> Pozzuh: So the fact that IO actions are values lets us write our own control structures (which is what foldM is an example of as well)
12:12:50 <nolraiU> I kind of wish women had more options in songs to be evil, treating their boyfriends baddly seems to be about it..
12:12:59 <nolraiU> (Sorry wrong room)
12:13:54 <Cale> Pozzuh: another simpler example is that we can write   sequence :: [IO a] -> IO [a]  which takes a list of IO actions, and glues them together into a single IO action, which will run each in turn, collecting a list of the results
12:14:17 <kadoban> nolraiU: https://www.youtube.com/watch?v=KcdQk7JBPzQ
12:14:40 <Cale> Pozzuh: This is sort of a primordial loop: if we can decide ahead of time what ought to occur on each iteration, and form a list of the actions, then sequence will glue them together for us
12:15:25 <Cale> Pozzuh: If you want, you can try to write that function (you might have to name it something different, since sequence is likely in scope), or if you want, I can go through the thought process.
12:15:47 <Cale> It's slightly easier than foldM I think :)
12:15:54 <kojo> Hijiri, thanks, I managed to solve it. As usual it was the monad thing confusing me. :)
12:15:54 <ackthet> dumb question: is there a way to set ghci to always give all warnings?
12:16:15 <Cale> ackthet: Does ghci -Wall work?
12:16:35 <Cale> or  :set -Wall  if you already have ghci running
12:16:38 <ackthet> trying to think of a short way to test
12:16:44 <Pozzuh> Thanks for all the help. For now I'm just gonna finish the program I'm working on and worry about monads afterwards, again thanks for the help
12:16:48 <ackthet> i kinda wanted like a config option so i dont' forget
12:17:26 <Cale> I honestly kind of hate -Wall -- there are a whole bunch of warnings which are just spurious and shouldn't be acted on.
12:17:44 <Cale> (and if you do, your code ends up looking silly)
12:17:48 <pdkr> Cale: and it's missing -fwarn-incomplete-patterns or whatever that thing is called
12:18:44 <ackthet> i like parts of Wall, specifically warning me about partial functions
12:19:29 <Cale> yeah
12:19:46 <ackthet> cause i do that often without realizeing it
12:19:48 <Cale> It would be nice if -Wall were curated a bit more carefully
12:20:05 <ackthet> or there was a -Wmost
12:20:07 <ackthet> :P
12:20:20 <Cale> Well, it's already -Wmost
12:20:33 <Cale> there are some warnings which it still doesn't turn on
12:20:47 <ackthet> but you could make a -Wmost with even less warnings
12:20:51 <Cale> yeah
12:21:53 <ackthet> as a newb non-exaustive patters are a mistake i make somewhat often
12:22:54 <maerwald> I think there is even a ghc switch to make those warnings?
12:23:26 <ackthet> there is, i was asking how to make it enabled by default in ghci
12:23:52 * hackagebot pathtype 0.7 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.7 (HenningThielemann)
12:27:53 <nolraiU> Is there a data type for non-cyclic directed graphs?
12:29:49 <osfameron> those are trees aren't they?
12:30:09 <Hijiri> no
12:30:26 <Hijiri> acyclic DAG can have multiple roots and nodes can have multiple parents
12:30:43 <Hijiri> vertices
12:31:01 <osfameron> ah, true.  Trees *are* DAG, but #notalldags
12:32:35 <FireFly> "acyclic DAG" that's.. a bit redundant
12:32:41 <FireFly> I guess it was for emphasis
12:33:02 <Hafydd> Directed Acyclic DAG
12:33:52 * hackagebot sloane 4.1.2 - A command line interface to Sloane's OEIS.  https://hackage.haskell.org/package/sloane-4.1.2 (AndersClaesson)
12:33:54 * hackagebot hops 0.2.1 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.2.1 (AndersClaesson)
12:36:43 <Hijiri> oh
12:36:45 <Hijiri> right
12:37:02 <Hijiri> for some reason I translated "directed graph" into DAG
12:54:23 * hackagebot pkcs10 0.1.0.0 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.1.0.0 (ktimothy)
12:56:15 <lyxia> Multiple roots -> forest, multiple parents -> sharing?
13:04:42 <bashed> Has anyone used gtk2hs? I'm getting a "Gtk-2.0 symbols detected" error. Anyone know how to resolve that? 
13:06:58 <bashed> Looks like somewhere in the chain, ghc is building my project with both gtk2 and gtk3. 
13:07:16 <maerwald> bashed: you should depend on gtk3, I believe that is enough
13:08:14 <nolraiU> Hey, so may I repeat the question I had to leave before seeing if anyone knew the awnser?
13:08:46 <bashed> maerwald: Thanks. That worked. It was a stupid mistake, I was depending on gtk and not gtk3. 
13:11:37 <kojo> Hi! I have a simple question regarding the most elegant way to write a function which takes two parameters. If one of the parameters has a special value, I want to return the other parameter. Like so: func s "value" = s,  func "value" s = s. Can I do this in one line?
13:12:06 <ReinH> kojo: you *can*, but it won't be any better.
13:13:56 <nolraiU> kojo, thats exactly the sort of thing the multi line form is for.
13:14:58 <kojo> ReinH, nolraiU: Point taken. I guess I will stick with two lines then. Thank you! :)
13:15:51 <aidecoe> hello
13:16:01 <nolraiU> Anyway, I need a data type for directed non-cyclic graphs whose non-directed equivalent are /heavily/ cyclic.
13:18:00 <aidecoe> i have some simple program producing 10000 primes. I have run profiler against that and it shows me:
13:18:04 <aidecoe> total alloc = 3,630,397,848 bytes  (excludes profiling overheads)
13:18:38 <aidecoe> i was observing chart at i haven't spotted any pick of memory usage
13:18:42 <geekosaur> that does not mean it got that big, just that it claled allocate that many times
13:19:09 <geekosaur> most allocations are fast allocationsin the nursery and are collected almost immediately (and returned the next time something allocates)
13:19:09 <aidecoe> ah
13:19:53 <aidecoe> that's what i've been suspecting
13:20:18 <aidecoe> but… how useful is "total alloc" information?
13:24:57 <joneshf-laptop> is there a standard data type for ipv4 addresses?
13:25:09 * hackagebot xkbcommon 0.0.2 - Haskell bindings for libxkbcommon  https://hackage.haskell.org/package/xkbcommon-0.0.2 (AukeBooij)
13:27:29 <pdkr> joneshf-laptop: Word32?
13:28:04 <joneshf-laptop> So no library is commonly used?
13:29:16 <pdxleif> joneshf-laptop: Do you mean something like https://hackage.haskell.org/package/network-house?
13:29:37 <pdxleif> That's at the network level, e.g. an IP packet has a TCP packet in it, which has a data payload...
13:29:53 <glguy_> joneshf-laptop: What are you trying to do with IPv4 addresses?
13:30:19 <pdxleif> I guess an IP Adddr is just 4 Word8's? https://hackage.haskell.org/package/network-house-0.1.0.2/docs/Net-IPv4.html
13:30:22 <pdkr> glguy_: (welcome to #haskell)
13:30:32 <pdkr> glguy_: (in the sense that there is no "oh, just use this" asnwer)
13:30:46 <glguy_> Um, OK?
13:31:02 <ga2arch> how can i make attoparsec return the stuff correctly parsed till now when there is an exception while parsing data ?
13:31:38 <joneshf-laptop> glguy_, I'm using servant, and one of the api's I'm interfacing with needs ip addresses. I figured I'd see if someone had already done the work of making a data type that encodes ipv4 address so I didn't have to.
13:31:43 <pdkr> ga2arch: with attoparsec's backtracking-by-default, that'll generally not be what you expect
13:31:46 <glguy_> ga2arch: You can run an attoparsec parser many times, taking output as you go
13:31:59 <joneshf-laptop> glguy_, so bonus points if it already defines a `Generic` instance :)
13:31:59 <glguy_> and rerunning it with the remaining input bytes
13:32:13 <joneshf-laptop> pdkr, I think you meant to direct that to me.
13:32:50 <ga2arch> glguy_: ah right, instead of using many', just run it many times and save the result
13:33:02 <pdkr> joneshf-laptop: nah i kinda meant it as a comment on the kind of way #haskell usually responds to questions: the type to represent this depends on the usage. but it seems i didn't deliver this very well.
13:33:03 <ReinH> joneshf-laptop: what advantage do you see to using a type other than Text or ByteString or String or w/e the ambient string type is?
13:33:03 <joneshf-laptop> pdxleif, that looks good.
13:33:06 <glguy_> joneshf-laptop: Usually for dealing with network addresses I'd work with SockAddr from the network package
13:33:07 <ga2arch> thanks, the afternoon spent understanding comonads burned me out 
13:33:28 <glguy_> but that probably isn't the right level of detail for passing them through a web api
13:33:54 <glguy_> joneshf-laptop: Yeah, #haskell usually tries to figure out what you're doing with some data before guessing at a good way to do it
13:34:00 <pdxleif> joneshf-laptop: This lib uses Word32 - https://hackage.haskell.org/package/pcap-0.4.5.2/docs/Network-Pcap.html#t:Network
13:34:19 <ReinH> I would need more info before I decided to use something other than Text
13:35:18 <pdkr> joneshf-laptop: in the end, an IP is just an identifier. so there are no instances you can sensibly give it (except Show and Eq). so maybe a newtype is sufficient?
13:35:20 <joneshf-laptop> ReinH, hopefully, i wont run into a situation like I did last night/this morning where I had a bunch of generic types like `[Text]` and such, but didn't spot the one part where I passed the wrong `[Text]`.
13:35:23 <pdxleif> Huh; guess Network.Socket also uses Word32 (newtype'd)
13:35:46 <joneshf-laptop> yeah, I'm not concerned with the performance or how it's implemented behind the scenes or any of that stuff.
13:35:49 <glguy_> pdxleif: I think it works for them because you practically never deal with that type directly
13:35:51 <joneshf-laptop> just want to prevent bugs
13:35:58 <pdkr> joneshf-laptop: newtype sounds like the way to go
13:36:29 <joneshf-laptop> word
13:38:42 <pavolzetor> what do you usually do to represent fixed length array ?
13:38:58 <glguy_> A variable length array
13:39:14 <pdkr> heh
13:39:17 <pavolzetor> wouldn't that be waste of space?
13:39:31 <pavolzetor> now I have type Bicubic v0 v1 ... v15
13:39:55 <l3dx> I'm experimenting with parsec. I'm trying to extract some values from a string, but I can't figure out how to skip the uninteresting parts. manyTill consumes the interseting part too, and anyChar is too gready. Any hints?
13:40:20 <pavolzetor> glguy_: Data.Vector.Unboxed?
13:40:24 <pdkr> pavolzetor: maybe you're looking for those funny Vector types with compile-time length checking?
13:40:27 <Xack> hi \o
13:40:32 <Xack> could somebody give me a hand with https://gist.github.com/zackp30/e7362716976551f20a7d ?
13:40:36 <pdkr> pavolzetor: (not as in Data.Vector)
13:40:37 <glguy_> pavolzetor: Yeah
13:40:37 <Xack> haskell newbie here
13:41:20 <pdkr> l3dx: this is very vague. it really depends on how you define "uninteresting"
13:41:44 <pdkr> l3dx: also, you might want to look into megaparsec, as you may find it has better error reporting and semantics
13:41:45 <pavolzetor> pdkr: any link? I will probably use Unboxed vector for now and see, it just seems wastefull to store two extra ints
13:41:59 <pdkr> pavolzetor: well i don't think you need to worry about storing two extra ints, tbh
13:42:11 <pdkr> so if that works, just keep it simple and effective
13:42:45 <glguy_> Xack: You can't compose two functions    (a -> IO a) with (.) and get an (a -> IO a)
13:43:03 <pdkr> pavolzetor: kinda like this, but you could simplify many parts if all you want is dimension 15: https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
13:43:09 <l3dx> pdkr: in my case it's just an unknown number of words between some defined "<word> <num>"
13:43:15 <glguy_> There's an operator that has the right type:  Control.Monad.<=<  , but you should take a moment to look at the type of (.) to see why that doesn't work as you wrote it
13:43:20 <pavolzetor> pdkr: yes for now, it is the C mindset of not wasting machine time ;)
13:43:44 <pdkr> pavolzetor: in fact, if all you want is dimension 15, maybe use a data with a record-style constructor with 15 fields?
13:43:56 <glguy_> Xack: Once you fix that it'll either work or you'll get different errors, but this is the one to focus on now of the 3
13:43:57 <pdkr> pavolzetor: yeah, please let go of this. it'll save you a lot of time in tho long run.
13:44:12 <Xack> alright, thanks glguy_ :)
13:44:22 <pdkr> pavolzetor: elegant and idiomatic code has a much higher probability of being efficient than crazy-optimized-but-not-really C-style code
13:44:25 <dominik> hey haskellers, is there any way to define a type synonym for any monad as long as it is a MonadError and MonadState monad?
13:45:15 <pdkr> dominik: you mean you want Either for monads?
13:45:21 <pdkr> ish
13:45:37 <dominik> something in the sense: type MyMonadT s e a = forall m. (MonadError e m), (MonadState s m) => m a
13:45:44 <glguy_> dominik: You can kind of do that using an extension, but in general it's a bad idea
13:45:49 <nolraiU> dominic: Yes, but it requires an extention.
13:45:59 <nolraiU> glguy_: why?
13:46:24 <pavolzetor> pdkr: thanks for the link, record style maybe, I will see. I wanted to use folds to compute the mid point instead of just writing down the form
13:46:27 <pavolzetor> formuale
13:46:28 <glguy_> They're hard to deal with, make type inference hard if you accidentally use them in argument position
13:46:40 <glguy_> and make it hard to match types between two arguments because the 'm' is hidden
13:46:50 <Xack> glguy_: done! also removed the second bottomUpM
13:46:54 <Xack> thank you :)
13:46:56 <dominik> hmm
13:47:00 <glguy_> You're welcome :)
13:47:20 <pdkr> pavolzetor: kinda sounds like the dependent types /might/ be relevant
13:47:24 <glguy_> dominik: It's also better to use the mtl classes to implement your particular operations and  be done with them
13:47:33 <glguy_> but not expose them further
13:47:38 <pavolzetor> pdkr: I see, well I try. However what I don't like is I have not clear control over the data
13:47:45 <dominik> basically, I need a monad with state and error handling, but I don't want to fix it further
13:48:14 <pavolzetor> pdkr: in C I usually go with SoA
13:48:20 <pyon> Right now, my main intuition for comonadic values is "a larger context in which a distinguished value exists", the main examples of this being the Store comonad, as well as zippers. Are there any particular examples of comonads that don't fit this intuition?
13:48:22 <dominik> and it seems silly to have to write (MonadError e m, MonadState s m) => ... -> m a in the beginning of all of the functions
13:49:11 <pavolzetor> pdkr: this simple code can do 70M tets/s on laptop single core https://github.com/pavolzetor/fiber_surface/blob/master/src/fs_marching.c
13:49:13 <edwardk> pyon: not in haskell. you can build them in places like the real numbers, etc.
13:49:21 <glguy_> dominik: better would be:   ... -> ConcreteType a    and then as an alternative:   ClassSpecificToWhatI'mDoing m => ... -> m a
13:49:22 <pyon> Ah!
13:49:41 <pyon> edwardk: Thanks!
13:50:01 <edwardk> pyon: e.g. make a category where x <= y   is the arrow from x -> y, containing reals, then rounding down has floor x <= x, floor x <= floor (floor x)
13:50:20 <edwardk> as extract and duplicate, with the appropriate laws
13:50:45 <pyon> edwardk: Oooh, right!
13:51:05 <edwardk> similarly ceiling is a monad
13:51:26 <pyon> Yep, makes perfect sense. :-)
13:52:02 <edwardk> `max 0` which takes the max of your input with 0 is also a monad, and similarly `min 0` is a comonad, etc.
13:52:57 <pyon> Mmm... Perhaps this is a hint that studying some order theory could clarify basic notions in category theory.
13:54:58 <pdkr> pavolzetor: haha, "simple"
13:55:34 <pavolzetor> pdkr: well the non-optimized version was only 3x slower
13:55:45 <pdkr> pavolzetor: by the way, if you really want to fix some dimension, and generate the code for doing a number of additions etc, you might want to look into template haskell.
13:56:28 <pavolzetor> pdkr: thanks, I will look into it over next weekend
13:56:29 <pdkr> pavolzetor: in case you're interested in being convinced that haskell programs can be shorter and faster than C: http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/
13:56:40 <pdkr> (emphasis on "can be" though)
13:59:26 <pavolzetor> pdkr: let's not get into that discussion :), I am putting haskell in test and I will see :)
13:59:48 <pdkr> pavolzetor: by the way, vector packing might be more efficient than you expect: fromListN has O(n) efficiency. rather than O(n log n) as you might expect.
14:01:43 <pavolzetor> pdkr: why would you expect nlogn?
14:02:06 <pavolzetor> pdkr: btw, big O is not the best in this case as it hides constants
14:02:29 <pavolzetor> pdkr: the fromListN is more like 200n (200 for each cache miss)
14:05:22 <pavolzetor> pdkr: would you do evaluation of bicubic patch at specific (u,v) manually or using recursive approach
14:05:24 <pavolzetor> ?
14:06:22 <pdkr> pavolzetor: nlogn would make sense because a reasonable implementation of Vector doubles the allocation every time it needs more space
14:06:40 <koz_> Does anyone here use Flycheck in Emacs with Cabal sandboxes? I'm having issues getting those things to play nice with each other.
14:06:53 <pdkr> pavolzetor: again. don't worry so much about constants. if you get complexity right in Haskell, then you probably get quite close to "optimum" very quickly
14:07:33 <pavolzetor> pdkr: no it does not, it is amortized constant time (append)
14:08:12 <pavolzetor> pdkr: if I use records I pretty much have to use expanded formula
14:08:30 <pdkr> pavolzetor: donald knuth, "premature optimization is the root of all evil"
14:09:22 <pavolzetor> pdkr: I will try do it recursively if it is simpler; did you read the original paper?
14:10:02 <pdkr> pavolzetor: knuth's?
14:10:24 <pavolzetor> pdkr: yes
14:11:01 <pdkr> pavolzetor: i think this is one of those cases where the original paper is not necessary to read since the knowledge has been absorbed by common best practices
14:11:39 <pavolzetor> pdkr: not true, maybe misknowledge ;), read the paper
14:12:20 <pavolzetor> pdkr: in my case, that piece of code will run most of the time, that's why I worry (since I am not shading heavy)
14:12:41 <pavolzetor> it is good paper
14:17:46 <pavolzetor> pdbr: https://github.com/kuribas/cubicbezier/blob/master/Geom2D/CubicBezier/Basic.hs
14:18:06 <pavolzetor> pdbr: does evalBezierDerivsCubic seems idiomatic?
14:18:12 <pavolzetor> pdkr:
14:18:55 <pdkr> pavolzetor: depends on if you take these formulae for granted
14:19:25 <pavolzetor> pdkr: I do not, I think I will do general recursive solution and then optimize
14:19:33 <pdkr> pavolzetor: the fact that it's output a fixed-length list a bit curious. but not unacceptable.
14:20:01 <crough> \quit
14:20:14 <pdkr> its*
14:20:18 <pdkr> its is**
14:20:23 <pdkr> its output is*
14:20:23 <pavolzetor> pdkr: I usually use tuple
14:24:05 <pavolzetor> pdkr: I actually think doing it on paper (with 1st and 2nd derivatives) is simpler
14:24:21 <pavolzetor> pdkr: *to implement
14:24:49 <pavolzetor> pdkr: and as you said (premature *generalization* is evil)
14:28:25 <warbo> Anyone know how I might get the name of the package being compiled from within a Core->Core plugin? I can get the key, but "lookupPackage" fails to get the name as it's not in the package DB yet (since it's still being compiled)
14:30:11 * hackagebot pkcs10 0.1.0.1 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.1.0.1 (ktimothy)
14:33:54 <abbe> Hi
14:34:32 <abbe> Is stack supposed to be using cabal's package db ?
14:35:04 <Axman6> not really, except possibly the one installed with the compiler
14:35:37 <aupiff> when is ghc 8.0 coming out? I just read about the `Strict` pragma, and Tibell mentioned that it would be included in 8.0.
14:35:48 <hexagoxel> which technically is not "cabal's package db" either
14:36:08 <dmwit> which package db is cabal's?
14:36:15 <abbe> ~/.cabal/...
14:36:23 <abbe> thanks for confirming
14:36:31 <dmwit> that isn't a package db...
14:38:18 <abbe> i meant stuff that i installed via cabal, and is registered at ~/.ghc/x86_64-freebsd-7.10.3/package.conf.d
14:38:57 <warbo> I'm getting a lot of 404s and guru meditations from downloads.haskell.org/~ghc/*/docs is this a known issue?
14:40:10 <dmwit> i believe stack does not use tde db under ~/.ghc
14:40:11 * hackagebot fixed-length 0.1.1 - Lists with statically known length based on non-empty package.  https://hackage.haskell.org/package/fixed-length-0.1.1 (HenningThielemann)
14:41:04 <abbe> okay
14:55:22 * hackagebot pkcs10 0.1.0.2 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.1.0.2 (ktimothy)
15:00:45 * hackagebot Quelea 1.0.0 - Programming with Eventual Consistency over Cassandra.  https://hackage.haskell.org/package/Quelea-1.0.0 (gowtham)
15:05:45 * hackagebot raw-strings-qq 1.1 - Raw string literals for Haskell.  https://hackage.haskell.org/package/raw-strings-qq-1.1 (MikhailGlushenkov)
15:10:45 * hackagebot pkcs10 0.1.0.3 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.1.0.3 (ktimothy)
15:15:23 <danilo2> Hello guys! I've got a funy small question :D How to hide type operator import? I mean, I've got aodule A that exports both (++) operator (function) as well as (++) type family. How can I import it hiding the type family but leaving the operator?
15:16:17 <glguy_> Prelude> :set -XExplicitNamespaces 
15:16:17 <glguy_> Prelude> import GHC.Generics hiding (type (:*:))
15:16:30 <danilo2> glguy_: thank so much!!! :)
15:17:12 <athan> Hi everybody
15:17:20 <athan> Anyone here use pipes often?
15:17:29 <danilo2> glguy_: you're the best haskell's living encyclopedia out there! :D
15:17:45 <athan> I'm trying to make a constant-memory streaming statistics gathering program, but can't seem to make it "constant" in memory
15:18:04 <athan> my idea was using Pipes.Prelude.mapM_ with an STM TVar to capture my state at every pass
15:18:04 <Axman6> athan: what do you have so far?
15:18:26 <athan> but, if I supply larger input, I can see I allocate memory almost linear to the size of the input stream
15:18:28 <Axman6> you should be able to do a fold without the need for the variable at all
15:18:48 <athan> Axman6: Hmm, and this would give constant-memory you think?
15:19:08 <athan> I tried making all my state-data strict, should I relax this for the fold then you think?
15:19:17 <Axman6> if you make things strict enough, I'm guessing you're not forcing the "state" and it's just growing into a huge thunk
15:19:30 <Axman6> can you paste some code?
15:21:06 <athan> Sure Axman6, here it is: http://lpaste.net/147043
15:21:31 <athan> I'm using pipes-csv to parse streams of Sessions
15:22:04 <athan> then doing statistics on those sessions, like a Foldable1 (kinda fudged with the `Maybe a` in ColStat)
15:23:38 <Axman6> have you done any profiling to see where the heap usage is? this're more complex than I was expecting
15:24:19 <athan> Axman6: Ive tried to look at threadscope, but that doesn't really help :\ what tool do you suggest I use?
15:24:30 <athan> er I really dont' know how to use it haha
15:24:43 <Axman6> just notmal heap profiling and using hp2ps
15:25:04 <Axman6> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/prof-heap.html
15:26:50 <athan> agh woah, stack is throwing dependency errors when I supply -prof
15:27:32 <athan> hmm, okay building now. Thank you for your help Axman6 :)
15:29:09 <aweinstock> athan: why is count seperate from NumStat?
15:29:50 <athan> aweinstock: Because any value could be nullable. The numStat/textStat are the implementations for existing entries
15:30:53 <athan> the ColStat data type wraps this idea with the auxilliary data of the "number existing" and "number not existing", and the Maybe type around `a` is a hack-job way of allowing the fold to fail in the case that it folds over the empty list
15:31:18 <athan> because no statistics would exist if all fields were null
15:33:27 <aweinstock> athan: also, why TVar (instead of IORef) since it doesn't look like you're using threads? (unless I missed something)
15:33:55 <athan> aweinstock: Because I'm a noob :P
15:33:57 <athan> thank you
15:34:37 <aweinstock> that should help a bit with efficiency, although it probably shouldn't fix the memory usage
15:35:09 <aweinstock> (because my understanding is that the prime in modifyTVar' indicates that it's a strict update)
15:35:54 <athan> aweinstock: That's what I was hoping for :\ I think it's just to whnf though
15:36:32 <aweinstock> a brute force approach might be sticking "deepseq" in there somewhere, see if that changes the memory use
15:37:10 <athan> Yeah, I might, not sure if that's a good idea though
15:37:14 <aweinstock> also, the definition of addRowStat doesn't seem to be present in the paste?
15:37:18 <athan> because of the extra traversal
15:37:27 <athan> ? shoot one sec
15:38:03 <athan> aweinstock: Just updated it :)
15:38:06 <aweinstock> deepseq would be less efficient than using strictness correctly, but it'll be a hint as to whether adding strictness will eventually work
15:38:23 <athan> hmm
15:38:29 <athan> okay, I'll toy around still
15:38:59 <aweinstock> :t deepseq
15:39:00 <lambdabot> Not in scope: ‘deepseq’
15:39:19 <athan> running the executable with `+RTS -h` also didn't give a very informing report. It didn't include the Lib library at all, and I can't see what functions are referenced. I'll check the docs though
15:39:34 <aweinstock> :t Control.DeepSeq.deepseq
15:39:35 <lambdabot> Control.DeepSeq.NFData a => a -> b -> b
15:39:58 <athan> hmm, nearly the same amount of memory is being used with the IORef version
15:40:48 <aweinstock> :t Control.DeepSeq.deepseq <*> id
15:40:50 <lambdabot> Control.DeepSeq.NFData a => a -> a
15:41:15 <aweinstock> athan: try replacing (lift . atomically . modifyTVar' count . addRowStat) with (lift . atomically . modifyTVar' count . (deepseq <*> id) . addRowStat)
15:42:08 <athan> will do :)
15:42:16 <zoku> haha, I think i'm trying to use monads in python now
15:43:35 <athan> agh even with `force`, it's the same amount of data
15:44:35 <nolraiU> Is there a 'canon' implementation of Fin these days?
15:48:27 <mniip> well I've made https://hackage.haskell.org/package/finite-typelits
15:48:33 <mniip> but GHC's typechecker just sucks sometimes
15:52:20 <maerwald> we should make a kickstarter project for native haskell GUI... I'm sick of the gtk+ bindings and their side effects
15:52:48 <maerwald> and it's impossible to handle the complexity without IORef
15:53:34 <athan> aweinstock: Here's a `ps` file with the executable profiled with `-h`. What should I make of this data? https://raw.githubusercontent.com/athanclark/streaming-csv/master/streaming-csv.ps
15:53:53 <athan> You should be able to `wget` that as a postscript file
15:54:19 <athan> It looks like there's drastic allocation, then garbage collection
15:54:55 <athan> How could I target the profiling to specific terms, like how much `addRowStat` is allocating?
15:57:26 <aweinstock> athan: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
15:57:57 <athan> thank you!!
15:58:23 <lspitzner> deepseq <*> id === force, isn't it?
15:58:38 <aweinstock> lspitzner: yes, but I didn't see force at first
15:59:37 <athan> The pure version is much better, using fold
15:59:57 <athan> lspitzner: Yeah, force = x `deepSeq` x I think
16:00:46 <aweinstock> and (f <*> g) x = f x (g x)
16:01:13 <athan> Yeah using `fold` is much better, I max out at 4MB heap usage no matter the input size :)
16:01:17 <athan> thanks aweinstock
16:01:27 <lspitzner> :t [(<*> id), join]
16:01:28 <lambdabot> [(a -> a -> b) -> a -> b]
16:01:56 <ga2arch> athan: still would be nice to know where was that leak 
16:02:08 <aweinstock> :t [(<*> id), join, (\f g x -> f x (g x))]
16:02:09 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ t2 -> t
16:02:09 <lambdabot>     Expected type: t2 -> t1 -> t
16:02:09 <lambdabot>       Actual type: (t2 -> t1) -> (t2 -> t1) -> t2 -> t
16:02:18 <athan> ga2arch: I'm guessing in the need to go to IO
16:02:29 <athan> without using an IORef
16:02:34 <athan> but I don't know yet haha
16:02:56 <aweinstock> :t \f -> [(<*> id), join, (\g x -> f x (g x))]
16:02:57 <lambdabot> (a -> (a -> b) -> b) -> [(a -> a -> b) -> a -> b]
16:03:43 <athan> Much more consistent garbage collection in the eventlog, too
16:04:09 <lspitzner> :t \g -> [(<*> id), join, (\f x -> f x (g x))]
16:04:11 <lambdabot> (a -> a) -> [(a -> a -> b) -> a -> b]
16:05:11 <ga2arch> athan: really really curious why that happend :/ seems something interesting could be learned 
16:06:02 <athan> ga2arch: I'm going to try the scenario I had earlier with IORefs and `foldM` to see if I get a different result
16:06:12 <athan> maybe mapM_ waits or something :s
16:07:24 <athan> heap allocation profile of the pure version is still pretty spikey, though
16:12:56 <orb> Where would I put my Arbitrary instance, if I don't want orphan instances, but also don't want the actual library (and not just the tests) to depend on QuickCheck?
16:13:01 <ga2arch> athan: same problem with foldM ?
16:13:35 <athan> ga2arch: I'm actually going to leave right now, but you're more than welcome to clone the repo and try yourself :)
16:13:48 <ga2arch> link ?
16:13:54 <ga2arch> ah ok found
16:13:57 <ga2arch> didn't see it before
16:19:15 <nolraiU> orb: I don't think thats a solvable problem.
16:19:37 <orb> nolraiU: OK.  I'll go with the QuickCheck dependency, then.
16:27:04 <nolraiU> orb: are you making a library?
16:27:28 <orb> nolraiU: I am making a binary, but split into multiple source files.
16:28:18 <orb> Though for what I am doing right now, I should probably just take Data.SegmentTree
16:28:34 <orb> But the general problem of Arbitrary instances still stands.
16:42:45 <linman32> is it possible to promote a type to a kind with kind equalities?
16:42:47 <linman32> http://lpaste.net/147048
16:43:33 <linman32> such as the example in link
16:44:08 <ga2arch> linman32: lemme se if it compiles
16:45:48 <ga2arch> linman32:  error: Not in scope: data constructor ‘Bool’
16:47:44 <linman32> ga2arch: thnx. do you think that is a drawback? it seems beneficial, but idk
16:49:06 <ga2arch> linman32: idk really, just compiled ghc head to test this stuff out
16:51:36 <ga2arch> athan: can you try to >-> P.seq after the P.mapM_ in the TVar/IORef case, i would try myself but the generator file is compiled for linux only :/
16:55:13 <dmwit> linman32: I'm pretty sure new data declarations always have to return Type.
16:55:13 <athan> ga2arch: Egad I'm still getting ~176MB of allocation while trying that :\
16:55:55 <ga2arch> athan: so weird
16:56:02 <dmwit> linman32: Perhaps you would like to use a type family instead...?
16:56:08 <athan> hahaha yeah I'm not sure
16:56:29 <athan> 7MB for the pure version with 10x as much input :)
16:56:35 <athan> it plateaus at 7mb
16:56:38 <dmwit> linman32: e.g. `type family Eq (a :: Type) (b :: Type) :: 'Bool` should be well-formed, though I'm not sure what the instances would look like.
16:56:46 <ga2arch> athan: can you provide the source for the generator ? i would like to try myself 
16:56:54 <athan> no I can't :\
16:57:00 <linman32> dmwit: yeah. kind equality notes from GHC. "Type families and synonyms are now promoted to kinds."
16:57:03 <athan> I actually shouldn't be sharing this >.> it's for a job
16:57:15 <athan> I mean it's not crucial
16:57:21 <athan> but eh idk
16:57:24 <ga2arch> athan: feelz were felt 
16:57:42 <ga2arch> athan: don't worry :)
16:57:51 <athan> Thank you :)
16:59:11 <dmwit> linman32: `type family Equal a b :: Bool where Equal a a = True; Equal a b = False` compiles fine (with sufficient extensions) in 7.10.
17:00:03 <ga2arch> is $! almost always better than $ ?
17:00:13 <dmwit> No.
17:00:42 <ga2arch> when is not better ?
17:00:45 <dmwit> Idiomatic Haskell involves lots of fundamental use of laziness, which would be destroyed or hampered by ($!).
17:01:49 <ga2arch> i was looking at the ZuriHac2015's slides, and it suggests to use $! always when for example doing return $ something, Just $ something 
17:02:39 <Axman6> it really depends on the situation. adding unnecessary strictness comes with its own problems, particularly when someone is expecting something to be evaluated lazily
17:02:55 <dmwit> Okay. Suppose we took that advice at face value without further thought. Do you believe `return $ something` accounts for almost all uses of `($)`?
17:03:35 <ga2arch> no, that's why i asked, if it always is, because the slides aren't clear about when i should not use it
17:04:21 <ga2arch> for example, if i have something like `writeTVar ssHandles $ H.delete user handles` inside an atomically, should i use $ or $! ?
17:05:35 <dmwit> I suppose it depends somewhat on what you want to happen.
17:05:38 <cschneid_> is the a blog post on how to model API requests as data?  I have `data MyApiRequests = ARequest String String | BRequest Integer String` and such, but ARequest should only return AResponse, which I couldn't guarantee like that.
17:05:51 <cschneid_> (http REST api)
17:06:04 <dmwit> Probably the `($)` version makes the reader of `ssHandles` evaluate the deletion, while the `($!)` version makes the writer evaluate it.
17:06:07 <dmwit> Either could be wanted.
17:06:34 <ga2arch> ah ok, that's what i didn't consider 
17:06:43 <ga2arch> who evaluates it 
17:07:17 <ga2arch> and what happends if i do atomically $! something ?
17:07:47 <dolio> Maybe you should develop a more fundamental understanding of how GHC evaluates things.
17:08:04 <dmwit> I would expect `atomically $! something` to be essentially identical to `atomically $ something` -- I would be shocked if `atomically` were lazy at all.
17:08:57 <ga2arch> dmwit, i see, thanks
17:09:54 <ga2arch> dolio: that's what i'm trying to do, but the doc is pretty sparse (or i can't find a good one by myself)
17:10:31 <dmwit> cschneid_: You could consider `data MyApiRequests a where ARequest :: String -> String -> MyApiRequests AResponse; BRequest :: Integer -> String -> MyApiRequests BResponse`.
17:10:55 <dolio> Asking about particular code snippets here is not a good way to go about it, I can tell you.
17:11:25 <dolio> Reading about the STG machine is better.
17:11:36 <ga2arch> never heard of
17:11:42 <cschneid_> dmwit: what would the type var `a` be there? And basically you're saying that GADTs or related approaches would solve this?
17:12:09 <platz> There's an Anki learning deck on Lens operators: https://ankiweb.net/shared/info/1291333535
17:12:10 <dmwit> FWIW, I *just* started reading the STG paper like within the last month. I honestly don't know how I picked up my intuition for GHC's evaluation strategy, though.
17:12:14 <athan> ga2arch: I've heard it's good for small numerical computations that you don't want thunking around, and sometimes for `return $!` statements, but I have no idea haha
17:12:14 <dmwit> "osmosis" perhaps
17:12:26 <platz> I wonder if a tool to generate anki decks from haddock documentation would be a cool thing
17:12:43 <dmwit> cschneid_: The `a` variable tells the type of the response; and yes, I think GADTs would help here.
17:12:44 <pimlu> what is, in your opinion(s), the biggest weak points of haskell?
17:12:49 <pimlu> (what is haskell bad at?)
17:12:59 <ga2arch> dolio: that look exactly what i was searching for, thanks a lot
17:13:31 <dmwit> pimlu: You might like the "State of Haskell" repository.
17:13:33 <dmwit> Let me see if I can find it.
17:13:55 <dmwit> https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
17:14:00 <cschneid_> dmwit: thanks - I'll go find some GADT tutorials and ask again later when I get suck.
17:14:17 <pimlu> whoah
17:14:20 <pimlu> that's amazing
17:15:27 <dmwit> Why does github generate a "Merge pull request blah" commit after every pull request, even if they are "fast-forward" requests?
17:16:55 <kadoban> dmwit: It probably essentially does --no-ff ? If you don't want that, you can do it locally and push whatever you want.
17:17:48 <dmwit> That's an answer to the "how" question, but not the "why" question.
17:18:25 <kadoban> dmwit: Because that's what they chose to do, since it preserves history then.
17:19:01 <dmwit> What does "preserves history" mean?
17:19:21 <kadoban> It makes history reflect the fact that a PR existed and was merged in.
17:20:03 <platz> i.e. make a merge commit with 2 parents instead of just tacking on the new changes starting from the old
17:20:55 <dmwit> kadoban: I see. I can now understand their decision enough to confidently disagree with it. =)
17:24:28 <dmwit> Perhaps there should be a small heuristic bound on how many commits can be ff'd.
17:24:39 <dmwit> i.e. three commits or less -> ff; four or more -> no-ff
17:24:52 <glguy_> dmwit: It records both who wrote the patch and who took responsibility for merging it in
17:25:12 <kadoban> dmwit: Sounds pretty arbitrary.
17:25:36 <dmwit> kadoban: More arbitrary than 0 commits or less -> ff ? ;-)
17:26:42 <dmwit> glguy_: ah, that's an interesting point
17:27:14 <kadoban> dmwit: Yes?
17:27:38 <dmwit> kadoban: I don't object. "heuristic" is pretty much a synonym for "arbitrary" in my book.
17:36:40 <kadoban> dmwit: Probably. Doesn't really change that it'd be pretty confusing to users though. I'd probably just get in the habit of using a less-restrictive UI than github's to do stuff. The git CLI is powerful.
17:42:21 <drewbert> Is there a join-like command for tuples? (Monad m) => (m a, m b) -> m (a, b)
17:43:56 <pyon> :t \(x,y) -> (,) <$> x <*> y
17:43:57 <lambdabot> Applicative f => (f a1, f a) -> f (a1, a)
17:44:05 <pyon> @pl \(x,y) -> (,) <$> x <*> y
17:44:05 <lambdabot> uncurry ((((,) <$>) .) . (<*>))
17:44:28 <pyon> Errr, that isn't going to work. :-|
17:45:20 <pyon> drewbert: I don't think there is, but you can define `foo (x,y) = (,) <$> x <*> y` and use `foo` from then onwards. It would be more idiomatic Haskell to define `foo` as a curried function, though.
17:46:17 <FreeFull> Could something be done with Foldable?
17:46:28 <FreeFull> Especially since Foldable is part of the Prelude now
17:47:01 <drewbert> Perhaps it would be better if I explained what I was trying to do.  I have a HashMap String Aeson.Value and I want to turn it into a Data.
17:47:10 <drewbert> oops, hit enter too soon, one sec
17:47:15 <pyon> FreeFull: I think this would require Bifoldable, rather than Foldable. I'm not sure, though.
17:48:10 <FreeFull> pyon: Ah, I think you're right
17:48:43 <pavonia> :t uncurry (liftM2 (,))
17:48:44 <lambdabot> Monad m => (m a, m b) -> m (a, b)
17:49:14 <pavonia> drewbert: ^
17:49:22 <pyon> pavonia: Nice! :-)
17:49:29 <drewbert> Perhaps it would be better if I explained what I was trying to do.  I have a Data.HashMap.Strict (HashMap String Aeson.Value) and I want to turn it into a Data.Map.Strict (Map ParseType ParsedValue). The parsing functions yield EitherT Strings, so an EitherT String (Map ParsedType ParsedValue) would be acceptable.
17:49:55 <drewbert> pavonia: that'll do it, thanks!
17:50:30 <drewbert> also thanks to pyon and FreeFull for their help.
17:50:52 <FreeFull> I didn't help at all!
17:51:09 <FreeFull> I haven't even written any Haskell in a very long time
17:51:49 <drewbert> You read the problem and said words that were related without derailing the discussion or criticizing the original question, speaking in relative internet terms, that is helpful. :-P
18:15:15 <kyren_> I have a potentially vague question and might be suffering from an XY problem, but here goes: I'm looking for a strategy effectively for storing something like a set of potentially shared STRefs
18:15:35 <kyren_> and I'm having trouble figuring out what the best least gross strategy is
18:16:04 <kyren_> or whether or not I'm off in the weeds
18:16:23 * hackagebot text-show 2.1.2 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-2.1.2 (ryanglscott)
18:18:16 <kyren_> I'm trying to implement a scheme interpreter that is pure, and supports something like time traveling debugging, so that any evaluation of a scheme expression is pure, and you can hold on to the environment you had before evaluation and nothing is mutated, but the computation during the evaluation should be.. relatively fast..
18:20:05 <kyren_> the obvious way of handling scheme variables, since scheme is not a pure language, is to use IORef or STRef, but then you need not only to keep the value of the STRef, but also the actual shared-ness of them, I could do gross things but STRef does not implement Ord, so it can't go into a Map
18:21:54 <danilo2> Hello guys! :) Is there any FFI in GHC allowing me to communicte with Swift? I need some Cocoa API and I would like to call Haskell from main Swift loop and then Swift methods from within Haskell. Do I need to go over Objective-C or is there a way to go with Swift?
18:24:36 <kyren_> I feel like I'm being really stupid, and what I want to do is either a) totally infeasible or b) obvious
18:25:29 <kyren_> I am currently trying and failing to build a solution involving IntMap and generated int keys..
18:27:59 <orb> :info (<$)
18:28:36 <acertain> is there a GLL/GLR/Earley library somewhere that has choice with preference and erroring about ambiguity before finishing parsing (and with locations)?
18:28:50 <nolraiU> kyren: why isn't that working?
18:29:26 <Axman6> danilo2: if you can slum it with Obj-C, you can use: https://hackage.haskell.org/package/language-c-inline
18:29:29 <kyren_> well, it is kind of.. I just got to a point where I felt I was off in the weeds, also I just just learned about Data.Unique
18:29:48 <kyren_> Data.Unique makes me feel much better about the whole affair
18:30:04 <kyren_> ah crap, except it's in IO ofc
18:30:47 <danilo2> Axman6: I think I could. Still I would prefer to do it in Sfift because 1) I dont know neither objectivec nor swift and 2) I would like to learn more about the later one, but I've got no free time, so this would help me much ;)
18:33:39 <kyren_> interesting side question I suppose, I'm using an incrementing Int for generating a new unique key in an IntMap, 1) are haskell Ints well behaved on overflow and 2) can you think of a better algorithmic way to do that :P
18:34:30 <danilo2> kyren_: Overflow is overflow. If you dont want it, use Integers
18:34:37 <jle`> kyren_: yes, i believe their overflow behavior is in the spec?
18:34:43 <kyren_> I can't, it's IntMap
18:34:49 <jle`> it's machine-dependent, though
18:34:57 <jle`> it dictates a minimum size for implementations
18:35:01 <danilo2> kyren_: Use monad. Keep this ints in state monad and write some utility functions to optain new int and increment the one in state
18:35:03 <jle`> but some machines have different sizes than others
18:35:19 <jle`> it's well-behaved within an implementation/machine
18:35:38 <kyren_> right, as long as it's.. something sensible haha, it doesn't need to be anything specific just not UB (too long programming C)
18:35:59 <kyren_> danilo2: that's good, that's approximately what I'm doing right now so that's a good sign I suppose
18:36:33 <danilo2> kyren_: :)
18:36:36 <joneshf-laptop> How do you handle not being able to derive `Num` for a newtype?
18:36:43 <joneshf-laptop> what makes it not possible?
18:36:52 <jle`> doesn't it work w/ GeneralizedNewtypeDeriving ?
18:37:19 <joneshf-laptop>     Can't make a derived instance of Num Latitude
18:37:19 <joneshf-laptop>       (even with cunning newtype deriving):
18:37:19 <joneshf-laptop>     In the newtype declaration for Latitude
18:37:34 <jle`> it probably depends on your type in specific
18:37:41 <joneshf-laptop> newtype Latitude = Latitude { latitude :: Float }
18:37:41 <joneshf-laptop>     deriving (Eq, Num, Ord, Show)
18:37:44 <jle`> because i just did newtype Foo = Foo Int deriving (Num), and it worked  :)
18:38:01 <joneshf-laptop> are `Float` not derivable?
18:38:09 <jle`> it worked when i did Float too
18:38:12 <jle`> hm
18:38:23 <joneshf-laptop> 7.10.2
18:38:40 <jle`> 7.10.2.20151118 here
18:38:42 <jle`> hm
18:38:46 <joneshf-laptop> possibly clashing with other pragmas?
18:39:01 <jle`> potentially.  what else do you have enabled?
18:39:21 <joneshf-laptop> DataKinds, DeriveAnyClass, DeriveGeneric, GeneralizedNewtypeDeriving, OverloadedStrings, TypeOperators
18:39:31 <jle`> definitely weird
18:39:33 <danilo2> remove
18:39:35 <danilo2> DeriveAnyClass
18:39:57 <jle`> today in #haskell: compiler magic causes problems
18:39:58 <danilo2> :)
18:40:03 <joneshf-laptop> ah
18:40:06 <joneshf-laptop> that did it.
18:40:12 <danilo2> ur welcome :)
18:40:15 <joneshf-laptop> So I'll have to move that to a different file I guess
18:40:20 <joneshf-laptop> thanks danilo2 
18:40:22 <danilo2> dont use it
18:40:32 <kyren_> thank you jle` danilo2, I will proceed with the knowledge that my previous plan was at least not completely crazy
18:40:32 <danilo2> if u could
18:40:33 <jle`> i don't think i've ever really needed DeriveAnyClass ... it saves one line at least
18:40:36 <jle`> *at most
18:40:41 <joneshf-laptop> why not?
18:40:50 <jle`> all it does is save the standalone deriving line, righ?
18:41:05 <jle`> er i mean
18:41:08 <jle`> the blank instance declaration
18:41:34 <danilo2> because it does not work in most cases and you get unpredicable results. It overlapps some other extensions, like in this example, so you do not know what will be generated by GHC and to be honsest with you, it never ever generated anything sensible to me
18:42:08 <joneshf-laptop> so use StandaloneDeriving instead?
18:42:14 <danilo2> yep
18:42:31 <danilo2> if you have to :) normal deriving should work unless you heavy-use type families
18:42:51 <joneshf-laptop> just `Generic` and `FromJSON`
18:43:10 <danilo2> use GeneralizedNewtypeDeriving - it's much better
18:43:23 <joneshf-laptop> unfortunately, they can't all be newtypes.
18:43:25 <danilo2> (still sometimes you can get not what you want to, but rarely)
18:43:40 <danilo2> of course, then use standalone deriving
18:47:19 <TallerGhostWalt> does c2hs require special steps to get profiling output?
18:47:38 <TallerGhostWalt> I am usinga c2hs generated library that I wrote in a different module and it seems to be having trouble.  
18:51:24 * hackagebot yampa-canvas 0.2.2 - blank-canvas frontend for Yampa  https://hackage.haskell.org/package/yampa-canvas-0.2.2 (ryanglscott)
18:57:52 <lingxiao> hey all
18:58:51 <lingxiao> there is no way to O(1) append or prepend an element into a vector correct?
18:59:30 <lingxiao> the problem is I'm writing an algorithm that will delete and append/prepend an element into some data structure on each call
19:00:07 <Axman6> look at Data.Seq for that
19:00:19 <Axman6> has amortised O(1) cons and snoc
19:00:22 <lingxiao> and there will be about 40,000 items in each
19:00:39 <lingxiao> same for index accessing?
19:01:10 <lingxiao> ahh O(1) length! that's awesome
19:01:40 <lingxiao> ahh i see it's O(log(min(i,n-i))
19:04:02 <Axman6> indexing is quite fast
19:04:23 <orb> How do I use scoped type signatures in instance definitions?
19:05:57 <orb> fmap :: forall a . (a -> b) -> MyType a -> MyType b; [...] where helper :: MyType a -> [...]
19:06:15 <orb> I am getting an error  "Illegal type signature in instance declaration"
19:06:25 <lingxiao> Axman6 great thanks
19:06:25 <lingxiao> !
19:06:27 <Axman6> there's an extension for that, trying to find it
19:06:39 <lingxiao> Also I have a design issue
19:06:58 <lingxiao> acutally nvm O(1) length fixed my issue
19:07:03 <MarcelineVQ> prob {-# LANGUAGE InstanceSigs #-} and {-# LANGUAGE ScopedTypeVariables #-}
19:07:48 <Axman6> damn, beat me to it MarcelineVQ. Never actually used the InstanceSigs extension before
19:14:51 <TallerGhostWalt> how do I make a c2hs generated library profileable
19:20:14 <lingxiao> Hey all I would like help writing downa  data type
19:20:20 <lingxiao> so far I have this: data Res a = R { run :: Seq a, full :: Int -> Bool }
19:20:31 <lingxiao> but it's not quite what i want, I want to use full as:
19:21:05 <lingxiao> let r :: Res a,   then I want to say  case full r (length . run $ r)
19:21:13 <Axman6> that looks very OO...
19:21:27 <lingxiao> yeah it does look like it right ... I'm not sure it's good desing
19:21:44 <Axman6> sounds like what you want is a function =)
19:21:46 <lingxiao> the point is this Res a should havea  max size, beyond which I do not want to put more stuff in it
19:22:07 <lingxiao> yeah the problem is i need to store this max size somewhere when i declare an instance of Res a
19:22:08 <Axman6> then you probably want to store that max size along with the Seq
19:22:12 <lingxiao> Res as in Reservoir
19:22:31 <lingxiao> yeah I'm doing that right now but the problem is there is no reason I coudln't change the maxsize willy nilly when I use Res a
19:22:52 <Axman6> there is if you don't allow people the ability to construct a Res
19:22:54 <lingxiao> which is not what i want .. I could use dependent types but for now say I jsut use Seq
19:23:03 <Axman6> you can export Res qithout exporting its constructors
19:23:26 <lingxiao> ahh then write some function full :: Res a -> Bool
19:23:32 <lingxiao> ok that works 
19:25:55 <Axman6> yep
19:31:25 * hackagebot hood 0.3 - Debugging by observing in place  https://hackage.haskell.org/package/hood-0.3 (ryanglscott)
19:39:57 <jasonkuhrt> Does anyone here know the current status of Liquid Haskell?
19:41:05 <pooryorick> non-haskell programmer here, trying to install pandoc.  OS is RHEL 6.  No root. Downloaded Haskell from justhub and jimmied it to install to an alternate prefix.  Using the included cabal to install dependencies.  Have to install them almost one-by-one for some reason.  Down to about three, I think.  socks give me this error:
19:41:10 <pooryorick>  Could not find module `Data.Time.Clock.POSIX'
19:41:13 <pooryorick>     It is a member of the hidden package `time-1.5.0.1'.
19:41:36 <pooryorick> so I hazard a guess and add "time" to build-depends
19:41:47 <pooryorick> Then get this error:
19:41:57 <pooryorick> System/Posix/IO/Common.hsc:106:9: parse error on input `import'
19:42:01 <pooryorick> I'm lost.
19:42:04 <pooryorick> Help?
19:43:02 <MarcelineVQ> Are you just after pandoc the utility, or the library?
19:43:46 <pooryorick> Just the utility
19:43:55 <MarcelineVQ> Often pandoc, the utility, is available right in OS repo's as a complete package
19:44:02 <pooryorick> Don't have root
19:44:26 <pooryorick> I think justhub is my best bet for RHEL 6
19:45:59 <pooryorick> Is ghc-7.6.3 by chance too old?
19:46:35 <pooryorick> It looks like a syntax error.  Am I missing a language extension?  
19:50:54 <MarcelineVQ> I wish I knew, I'm surprised there aren't direct binaries you can just grab. Maybe the deb package has binaries in it you can unpack and try? https://github.com/jgm/pandoc/releases/download/1.15.2/pandoc-1.15.2-1-amd64.deb
19:51:55 <bitemyapp> if they just want the binary and don't care about the library or Haskell in general, a deb seems most appropriate.
19:52:22 <athan> What would be a good data type for doing `median` queries? I was going to use an ordered multimap, but I'm only working with Ints so I might get away with something cheaper
19:52:48 <athan> insertion should be cheap, but doing a "middle" lookup should also be relatively easy
19:53:43 <bitemyapp> athan: use left and right heaps.
19:53:44 <MarcelineVQ> What about a zipper athan?
19:53:57 <athan> bitemyapp: Hmm, okay
19:54:12 <bitemyapp> if median is literally all you care about
19:54:16 <athan> MarcelineVQ: That's an idea, but insertion should be quick :\
19:54:18 <bitemyapp> then you just need two lazy lists and Ord
19:54:28 <bitemyapp> Ord a => ([a], a, [a])
19:54:41 <bitemyapp> maybe want to track length of the lists
19:54:53 <bitemyapp> data CountedList a = CL ([a], Int)
19:54:56 <MarcelineVQ> The list zipper I've seen is pretty good, it keeps one side in reverse order for faster manipulation
19:54:59 <bitemyapp> (CountedList a, a, CountedList a)
19:55:15 <bitemyapp> but it's worth noting that this data structure looks a _lot_ like a zipper, but I don't know how efficient a zipper can be for this particular problem
19:55:24 <bitemyapp> whereas I'm quite certain two heaps + median value is g2g.
19:55:38 <athan> bitemyapp: Using `splitAt (floor $ length xs / 2)`?
19:55:48 <bitemyapp> could be a self-balancing tree as well
19:56:00 <athan> That's what I was thinking
19:56:04 <bitemyapp> athan: http://programmingpraxis.com/2012/05/29/streaming-median/
19:56:05 <athan> maybe an IntSet would work
19:56:30 <bitemyapp> athan: http://stackoverflow.com/a/11385422
19:57:50 <athan> a zipper wouldn't have fast ordering methinks
19:57:56 <bitemyapp> that's my concern.
19:58:05 <athan> I'm thinking a unique ordered map pointing to a count
19:58:18 <bitemyapp> the data structure I proposed, type-wise, looks an awful lot like a zipper, but I don't know if the zipper would be efficient or not.
19:58:45 <athan> well, it would be a b-tree zipper, right?
19:58:50 <athan> sort-of-thing
19:58:56 <MarcelineVQ> I don't really understand the difference, why is a 'heap' different, what is a heap here?
19:58:57 <athan> where the root node is always median?
19:59:00 <athan> hmm
19:59:05 <bitemyapp> the heap bit is flexible.
19:59:06 <athan> I'm wondering if counts could be used for this
19:59:21 <bitemyapp> athan: yes
19:59:30 <bitemyapp> athan: question of how much data you want to hold onto.
19:59:41 <athan> yeah, trying to make it constant :)
19:59:47 <athan> er as constant as possible
19:59:50 <athan> idk
19:59:51 <bitemyapp> right
19:59:53 <athan> "good"
20:00:30 <MarcelineVQ> I must be misunderstanding a zipper then. What makes it potentially slower?
20:00:50 <athan> MarcelineVQ: Well think about linear insertion on normal lists
20:01:02 <athan> if you're given a supposedly ordered list, how do you insert?
20:01:12 <athan> it's O(n) at worst for any given element
20:01:41 <athan> but if you split it by halves and have 2 branches instead of one, that gives you... O(log_2 n)?
20:01:52 <athan> which is way better for any arbitrary element
20:03:08 <MarcelineVQ> Alright. So is a zipper used just to mean list zipper?
20:04:02 <MarcelineVQ> By which I mean, would "tree zipper" mean the same thing as this split heap idea?
20:04:04 <athan> MarcelineVQ: Oop, I'm wrong if you mean something else :)
20:04:15 <geekosaur> I think the general form is "one-hole derivative"
20:04:15 <athan> I'm thinking so
20:04:15 <geekosaur> ?
20:04:19 <MarcelineVQ> Basically I'm just curious about the terminology
20:04:28 <athan> I'm just not sure if there's enough data at the first level to make the decisions correct
20:04:33 <bitemyapp> geekosaur: yeah
20:04:37 <athan> that's why I'm considering a "count"-based auxiallary thing
20:05:12 <athan> :o
20:05:43 <athan> ahh yes, the count would work because then the balance would just be when the left and right are equal
20:06:10 <MarcelineVQ> geekosaur: http://strictlypositive.org/diff.pdf ?
20:06:22 <geekosaur> yep
20:06:24 <MarcelineVQ> Thank you, geekosaur, bitemyapp, athan
20:06:30 <bitemyapp> athan: yeah I was trying to prove to myself in my head that counting wouldn't work
20:06:33 <bitemyapp> athan: haven't yet
20:07:01 <bitemyapp> athan: I think the complications usually want from wanting something that is _also_ an addressable data structure but I think it's worth just splitting out an auxiliary counting thingy for this.
20:07:06 <MarcelineVQ> There's a few cases for projects I have in mind where this idea would be useful
20:07:21 <bitemyapp> well, I'm a bit embarrassed because my work often involves streaming analytics :P
20:07:31 <bitemyapp> and I'm just too fried to really think about it harder than I presently am
20:09:22 <bitemyapp> the reason I don't have an answer to hand is because we don't typically track medians
20:09:28 <bitemyapp> we track buckets/quintiles of means.
20:11:43 <lingxiao> hey all I have what is perhase a math problem ...
20:12:03 <lingxiao> I need to select an item from a list with uniform probability s/i, where s < i. So say s = 100 and i = 200
20:12:34 <lingxiao> now I'm not even sure what this means ... for example if the list is of size s, an I select with probabiilty 1/s, then I'm just drawing an int from 1 ... s
20:12:47 <lingxiao> uniformly ..
20:13:34 <lingxiao> wait .. NVM!!
20:13:43 <lingxiao> sorry to clog up the chat with this ... i figured it out
20:13:53 <MarcelineVQ> glad to help!
20:15:33 <bitemyapp> lingxiao: quack quack
20:16:57 <jasonkuhrt> Is anyone here using/used Liquid Haskell? It seems profoundly interesting and valuable. I found this https://gist.github.com/spinda/b261167303515cc8a1d9 which is proposing work to explore integration with GHC
20:17:00 <lingxiao> yeah it's with probability s/i select an item from the list with uniform probablity  in case anyone was itching to know 
20:17:41 <pooryorick> module 'time' is mentioned in build-depends, so what might be another reason for the message,
20:17:44 <jasonkuhrt> bitemyapp: Hey, thanks for Haskell First Principals : ) I'm the chatty fellow Jason on your Zendesk
20:17:44 <pooryorick> Could not find module `Data.Time.Clock.POSIX'
20:17:50 <bitemyapp> jasonkuhrt: yep, hi :)
20:17:59 <bitemyapp> jasonkuhrt: I don't know anyone that is using it in production, but it seems pretty nice.
20:18:23 <bitemyapp> jasonkuhrt: I think the main sharp edge is the time it would add to compilation. Might be something where you run the checker in CI but developers do not for the most part.
20:18:35 <jasonkuhrt> Yeah, it also seems to reduce the need/use-cases for Maybe types
20:19:24 <jasonkuhrt> If the copmiler can tell you if `head` is safely used or not, that seems like a basic example of actually simplifying APIs, not just making them safer.
20:19:25 <bitemyapp> I'm not sure I would bring in something that heavy duty for just that.
20:19:46 <jasonkuhrt> Yeah totally, not just for that haha
20:20:23 <jasonkuhrt> Maybe a large program that warrants the effort to get the system going
20:20:42 <jasonkuhrt> I'm thinking more long-term, if LH or something like it ever became the direction of default GHC
20:20:57 <bitemyapp> 'ish?
20:21:04 <Romefeller> Hi all
20:21:12 <bitemyapp> GHC devs are generally interested in making plugins a thing.
20:21:20 <jasonkuhrt> It seems like it would have an impact on idiomatic haskell
20:21:23 <bitemyapp> Romefeller: hi
20:22:50 <pooryorick> The error message seems to be related to "foreign import ...".  Is some language extension needed for "foreign"?
20:25:59 <N1GG3RZSUCKD1CK> Haskell is gay.
20:26:00 <N1GG3RZSUCKD1CK> Haskell is gay.
20:26:01 <N1GG3RZSUCKD1CK> Haskell is gay.
20:26:01 <N1GG3RZSUCKD1CK> Haskell is gay.
20:26:01 <N1GG3RZSUCKD1CK> Haskell is gay.
20:26:22 <darkrye> So gay, in fact, that people are the happiest they've ever been when they use it.
20:26:38 <MarcelineVQ> I can't disprove that claim.
20:27:03 <Hafydd> Haskell taught me something about myself that I'd always known but denied.
20:29:35 <R__> +1 Hafydd 
20:33:58 <Romefeller> lol
20:34:21 <Romefeller> maybe he failed at a Haskell course
20:39:42 <athan> What would be a good streaming averaging function for integers? :s
20:40:40 <athan> I feel like keeping it as a Double is the only way to truely make each step decoupled from the last
20:42:03 <Hijiri> couldn't you just keep track of the current count and current sum?
20:42:06 <Hijiri> oh
20:42:09 <Hijiri> wait yeah, you could
20:42:38 <Hijiri> if you are using Integer at least
20:42:40 <Axman6> athan: just keep a sum (probably as an Integer in case it gets large) and a count, then calculate the  sum/count at the end
20:42:50 <athan> Hijiri: That's what I'm doing, but if the average remains to be a relatively small int, using `round` or `floor` (which would be worse) would bork the average
20:43:13 <athan> hmm! Thanks Axman6!
20:44:55 <Hijiri> athan: what do you mean?
20:45:14 <athan> Hijiri: If I were to recomute the average at each step I mean
20:45:18 <Hijiri> I didn't say that
20:45:30 <athan> sorry ._.
21:09:23 <lolisa> I find your lack of faith disturbing. Come to dark side, we have lazy
21:19:13 <ReinH> athan: absolutely don't keep it as a double
21:19:19 <ReinH> keep it as a sum and a count
21:19:32 <ReinH> keeping it as a double will cause awful floating point errors
21:19:40 <athan> I had a feeling >.>
21:20:14 <Axman6> you should avoid demoting things to floating point values whenever possible
21:21:14 <ReinH> besides, a single number isn't enough to compute a rolling average
21:22:32 <bitemyapp> athan: save non-associative operations for last.
21:25:59 <koz_> Is there a version of unwords that joins strings with "," instead of " "?
21:26:18 <MarcelineVQ> intersperse or intercalate will join with that you supply
21:26:44 <MarcelineVQ> Data.List
21:27:03 <MarcelineVQ> Even better, they work on any kind of list
21:27:16 <koz_> MarcelineVQ: intercalate is what I sought - thanks!
21:27:36 <kadoban> As many times as I use them, I can never remember which one is which.
21:28:17 <MarcelineVQ> sperse-sparse :>
21:35:17 <MarcelineVQ> haskell is so broad :> trying to prune my backlog of haskell related tabs and they just keep linking to multiple more interesting things
21:36:34 <Axman6> one day your stack will overflow when evaluating that tree
21:36:58 <orb> Can I give names in Kind Signatures for type classes? I have "class StepFunction (repr :: * -> * -> *)" but I'd like to replace the * with something more informative.
21:37:05 <MarcelineVQ> Axman6: seems likely
21:37:17 <MarcelineVQ> I'm down to 300 from 600, but it's hovering there
21:39:01 <MarcelineVQ> orb: Is there something more informative than * for kinds doing that job?
21:39:31 <orb> MarcelineVQ: mostly just a name to suggest what the type paraments are supposed to mean, repr key value.
21:50:08 <bionikspoon> hello
21:50:28 <Hijiri> hi
21:52:59 <tommd> hi
22:12:58 <jle`> athan: keep both the sum and the length as you stream, and map (/) over the external outputs of your stream
22:13:14 <jle`> athan: in the language of foldl library, it's liftA2 (/) sum length
22:13:30 <jle`> that is, the streaming sum and the streaming length
22:14:02 <jle`> whatever streaming library you have should be able to let you combine streams using an Applicative interface :)
22:16:20 <jle`> pipes, foldl, conduit, etc.
22:30:46 <ontop> Hey guys. How can I make my Haskell more unreadable? When I look at other people's Haskell it's crazy and hard to understand, but mine looks so plebian.
22:31:03 <godel> let's see it ontop 
22:31:09 <godel> show us
22:31:16 <ontop> Oh god. I've been put on the spot.
22:31:24 <ontop> Sec
22:32:37 <zomg> ontop: I'd suggest using Lens as much as you can
22:34:13 <ontop> godel: http://kopy.io/8gKd9
22:34:30 <ontop> This is a solution (that doesn't work yet) for the advent of code thing.
22:34:39 <jle`> you can make everythig point-free, too
22:34:46 <jle`> that's a easy way to make your code completely unreadable
22:34:46 <ontop> point-free?
22:35:29 <jle`> instead of traverse f x = sequence (fmap f x), write traverse = (sequence .) . fmap
22:35:49 <jle`> easy and cheap way to make code unreadable
22:35:51 <ontop> O_o
22:35:54 <jle`> there's even a bot that can automate it for you :)
22:35:58 <ontop> lmao.
22:36:00 <jle`> @pl traverse f x = sequence (fmap f x)
22:36:00 <lambdabot> traverse = (sequence .) . fmap
22:36:11 <ontop> Oh I'm glad he's here.
22:36:26 <liste> @unpl traverse = (sequence .) . fmap
22:36:27 <lambdabot> traverse d g = sequence (fmap d g);
22:36:35 <ontop> Semicolon.
22:36:50 <godel> >let 2 + 2 = 5 in 2 + 2
22:37:05 <godel> how do i eval?
22:37:18 <jle`> ┬─┬ノ( º _ ºノ) <- liste
22:37:22 <KaneTW> > 1+1
22:37:24 <lambdabot>  2
22:37:25 <KaneTW> add a space
22:37:30 <KaneTW> > let 2 + 2 = 5 in 2 + 2
22:37:32 <lambdabot>  5
22:37:32 <godel> > let 2 + 2 = 5 in 2 + 2
22:37:34 <lambdabot>  5
22:37:35 <godel> hah
22:37:45 <KaneTW> > let 2 + 2 = 5 in 2 + 3
22:37:46 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
22:38:06 <ontop> What the?
22:38:09 <godel> it overloads locally the + function
22:38:13 <KaneTW> you're declaring a local function (+) shaoowing Num's plus
22:38:16 <ontop> O_o
22:38:18 <jle`> > let f 2 2 = 5 in f 2 2
22:38:19 <KaneTW> Num's (+)
22:38:20 <lambdabot>  5
22:38:21 <jle`> same thing as that
22:38:22 * ontop holds his brain
22:38:31 <jle`> > let f 2 2 = 5 in f 2 3
22:38:33 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function f
22:38:35 * CoconutCrab tự powah 
22:38:36 <jle`> f 2 3 doesn't match any patterns, so it fails
22:38:40 <CoconutCrab> ops, sorry, wrong channel
22:38:51 * CoconutCrab runs away
22:39:10 <KaneTW> > let x : xs = [] in 1 : 2 : []
22:39:12 <lambdabot>  [1,2]
22:39:18 <KaneTW> interesting
22:39:24 <mea-culpa> hello~
22:39:43 <godel> > let x : xs = [] in 1 : (2 : [])
22:39:44 <KaneTW> oh right
22:39:44 <lambdabot>  [1,2]
22:39:47 <KaneTW> : is a constructor
22:39:50 <KaneTW> forgot
22:40:04 <jle`> > let Just x = Nothing in Just 3
22:40:06 <lambdabot>  Just 3
22:40:24 <godel> why... does that compile?
22:40:29 <godel> Just is a ctor
22:40:34 <jle`> it's pattern matching
22:40:38 <godel> m
22:40:40 <KaneTW> it's never referenced
22:40:42 <jle`> > let Just x = Just 10 in x
22:40:44 <lambdabot>  10
22:40:55 <godel> haha wtf
22:40:57 <jle`> it matches x to 10 :)
22:41:00 <KaneTW> > let Just x = Nothing in x
22:41:02 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just x
22:41:13 <jle`> pattern matching is one of the more fundamental things in haskell, heh
22:41:27 <KaneTW> usually pattern matching is strict
22:41:27 <jle`> > let [x,y,z] = [1,2,3] in (x,y,z)
22:41:29 <lambdabot>  (1,2,3)
22:41:31 <KaneTW> not in this case, though
22:42:25 <jle`> godel: it's the same as doing let (x,y) = (1,2) in x + y
22:42:34 <godel> yeah right
22:43:27 <mea-culpa> http://lpaste.net/147051 I'm trying to build a mutable array with random elements.
22:43:34 <mea-culpa> and doesn't work
22:54:23 <ontop> Is it possible to figure out what line's causing a stack overflow?
22:54:30 <ontop> Haskell feels hard to debug :(
23:12:44 <bitemyapp> athan: balanced tree or skip-list.
23:14:10 <bitemyapp> athan: problem is if the median shifts a bunch.
23:14:25 <athan> Just found that out too :\
23:14:40 <athan> I almost had some kind of removal balancing system going, but it's getting too hairy
23:14:52 <athan> I think red-black trees help too, but idk
23:15:09 <athan> as a threshold for brute rebalancing
23:15:34 <bitemyapp> athan: http://dn.ht/picklecat/
23:16:59 <athan> =D I'm on drugs!
23:24:58 <lolisa> > 1
23:25:00 <lambdabot>  1
23:40:46 <mea-culpa> oh, now it works
23:48:20 <ReinH> bitemyapp: I think the new hotness is fibonacci heaps or something
23:48:35 <ReinH> it's hard to keep up these days
23:51:24 <edwardk> ReinH: depends on your goals
23:51:36 <edwardk> ReinH: what is the goal to minimize?
23:59:24 <athan> edwardk: I think I started this conversation - median-based heaps
