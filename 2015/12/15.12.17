00:01:25 <lightandlight> ** Using System.Process < 1.3.0
00:02:20 <lightandlight> I think that's what the NoStream constructor is meant for but stackage has an older version of the library
00:02:40 <pavonia> What about runInteractiveCommand?
00:07:04 <lightandlight> pavonia: None of the functions work silently
00:07:51 * hackagebot yesod-core 1.4.18 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.18 (MichaelSnoyman)
00:07:53 * hackagebot list-fusion-probe 0.1.0.5 - testing list fusion for success  https://hackage.haskell.org/package/list-fusion-probe-0.1.0.5 (JoachimBreitner)
00:08:05 <pavonia> lightandlight: I'm sure I used runInteractiveCommand to run processes siliently
00:15:34 <lightandlight> pavonia: You were right, thanks mate
00:16:09 <pavonia> No problem
00:40:49 <jstolarek> is there a sane way of updating nestred records without using lenses?
00:45:41 <julianleviston> jstolarek: I thought lenses *was* the sane way!
00:46:34 <julianleviston> jstolarek: otherwise you have to have loads of code.
00:47:24 <julianleviston> jstolarek: how about Zipper?
00:48:01 <wolfcore> I should probably learn lenses; code for updating record fields is super repetitive
00:48:49 <julianleviston> semantic editor combinators?
00:51:31 <jstolarek> julianleviston: well, lenses are sane
00:51:41 <jstolarek> but I can't add dependency on lenses
00:51:59 <julianleviston> jstolarek: sematic editor combinators then?
00:52:44 <julianleviston> record update syntax gets a bit annoying when you need nesting, though. It’s not TOTALLY terrible, though. Just makes ongoing changes a bit tedious.
00:53:05 <jstolarek> yeah, it is tedious
00:53:08 <jstolarek> oh well
00:53:41 <julianleviston> you want functional references without lenses, pretty much…right? kind of like a zipper? (i mean, you want update mutiple things at once? or just one that’s deep?)
00:54:15 <julianleviston> jstolarek: http://conal.net/blog/posts/semantic-editor-combinators
00:55:47 <jle`> jstolarek: honestly if i wasn't able to include a lens dependency, i'd probably just end up implementing a mini-lens library myself
00:55:49 <jstolarek> julianleviston: just one thing
00:56:12 <jle`> at least for 'nested record updates', i only use a minimal part of the lens library..
00:56:38 <jle`> over t f = runIdentity . t (Identity . f)     -- covers most of what i actually use from `lens`
00:56:46 <jle`> and also the type synonym Lens
00:56:49 <julianleviston> jstolarek: hm?
00:56:57 <jle`> i write most of my lenses/traversals by hand
00:57:22 <jle`> so most of the time i am using traversals/lenses for things like nested record updates without ever actually using the lens library
00:58:23 <julianleviston> Did OverloadedRecordFields actually end up getting into GHC?
00:58:26 <jstolarek> julianleiston: I meant that I want to update only a single nested field, not several fields at the same timew
00:58:40 <julianleviston> jstolarek: ah…. 
00:58:45 <jstolarek> julianleviston: I believe 2/3 of it will make it into 8.0
00:59:06 <julianleviston> jstolarek: as an extension?
00:59:09 <julianleviston> jstolarek: obviously.
00:59:17 <julianleviston> jstolarek: so jle`’s suggestion??
00:59:51 <jstolarek> julianleviston: https://mail.haskell.org/pipermail/ghc-devs/2015-November/010340.html
01:00:25 * jstolarek needs to think about jle`'s suggestion
01:01:16 <julianleviston> jstolarek: it just means lifting the parts of Lens you need, pretty much, and implementing it yourself. Even though it has a lot of functions in it, and what seems like many pieces, the underlying concepts aren’t particularly crazy tricky or anything. 
01:01:23 <julianleviston> jstolarek: but you probably already know that.
01:02:21 <jstolarek> TBH I don't
01:02:28 <jstolarek> I always stayed away from lensed
01:02:32 <jle`> if i have data Foo = F { _fooInt :: Int, _fooBool :: Bool }, i'd write fooInt :: Functor f => (Int -> f Int) -> Foo -> f Foo, fooBool :: Functor f => (Bool -> f Bool) -> Foo -> f Foo, which are Lens' Foo Int and Lens' Foo Bool
01:02:51 <jle`> and then updating the int part would be over fooInt (+1), updating the bool part would be over fooBool not
01:03:13 <jstolarek> hm.. that looks simple
01:03:16 <jstolarek> will consider this
01:03:28 <jle`> and if i had [Foo], i could do over (traverse . fooInt) (+1), which would (+1) all of my fooInt's
01:03:40 <jle`> it's nice that the traversal for all Traversable instances is already in base :)
01:04:01 <jle`> and actually, the actual traversal itself is already useful on its own
01:04:16 <jle`> if i wanted to print the Int of a Foo, i could do `fooInt print myFoo`
01:04:48 <jle`> i end up using the raw traversal often, because it's useful on its own :)
01:05:08 <jstolarek> ok, I need to experiment to see how it works out
01:05:46 <jle`> the only thing that the lens package really adds here is the type synonyms and combinators like `over` and `view`
01:05:57 <jle`> but writing over and view yourself is usually just a one-liner
01:06:07 <jstolarek> jle`: I don't understand that Functor part 
01:06:24 <jstolarek> I mean (+1) is Int -> Int, not Int -> f Int
01:06:29 <jle`> yeah, that's what `over` does
01:06:48 <jle`> over takes a Lens/Traversal/etc., and turns it from taking an (Int -> f Int) and lets it take an (Int -> Int) instead
01:07:10 <jle`> basically it uses Identity for the `f`
01:07:29 <jle`> it's somewhat equivalent to `fmapDefault` from Data.Traversable
01:07:53 <jle`> it turns the (Int -> f Int) -> Foo -> f Foo into an (Int -> Int) -> Foo -> Foo, by using Identity
01:08:11 <jstolarek> ah, ok
01:08:14 <jstolarek> thta makes sense
01:08:55 <jstolarek> I think this should work
01:10:26 <jle`> yeah, the idea is that you're just writing functions like `traverse`, but for 'specific' fields and data types.  and one of the best things about `traverse` is that it naturally composes
01:10:43 <jle`> so (traverse . traverse) is just a traversal over two layers of Traversable, for instance
01:11:06 <jle`> and yeah, you can implement a 'mapper' with any traversal by using Identity as the Functor
01:12:11 <amalloy> where do i find the state monad these days? i tried `import Control.Monad.State.Lazy` as in https://wiki.haskell.org/State_Monad but i only seem to have Control.Monad.ST.Lazy, which seems to be a totally different thing about refs or something
01:12:27 <jle`> amalloy: you probably need to install the `mtl` or `transformers` package
01:12:41 <amalloy> that sounds familiar. should i care which?
01:13:20 <jle`> hm, `transformers` provide actual monad transformers that you work with directly
01:13:42 <jle`> `mtl` provides typeclasses that abstract over monads of different effects, of which the types in `transformers` are instances
01:14:05 <jle`> for learning i'd use transformers, but for real work/writing things meant to be re-used i use mtl
01:14:10 <amalloy> ​i see. i don't really need to worry about the typeclasses since i'm doing some simple exercises
01:14:16 <arkeet> ST is totally different from State.
01:14:23 <jle`> i still use transformers for one-offs
01:14:34 <jle`> if your goal is to learn about monad transformers, `transformers` is the one to look at
01:14:48 <jle`> `mtl` doesn't actually have anything to do with monad transformers...it just happens to re-export some as instances of its typeclasses
01:15:24 <jle`> which is a bit ironic given its name
01:15:32 <amalloy> yeah, i think i understood your typeclasses vs instances description
01:16:12 <jle`> keep in mind if you're following old tutorials that State in modern `transformers` is abstracted away as a type synonym
01:16:30 <amalloy> yeah, i know
01:16:36 <amalloy> StateT Identity
01:16:39 <jle`> and the `State` constructor is abstracted away and revealed as `state :: (s -> (a, s)) -> State s a`
01:17:13 <jle`> actually, now that we have pattern synonyms with records, i wonder if we can move that back as an actual constructor
01:17:34 <jle`> like, a pattern synonym'd constructor.
01:17:56 <amalloy> okay so i installed transformers, and: https://gist.github.com/amalloy/6b963cd10b1009550230 - i seem to recall i need to configure cabal somehow to say which "implementation" of Control.Monad.State.Lazy i want?
01:18:49 <jle`> huh, that's unfortunate
01:19:01 <jle`> i'd suggest you used a more smart package manager like `stack`
01:19:01 <amalloy> i can use Control.Monad.Trans.State.Lazy as it suggests, but i get the feeling i'm not supposed to have to
01:19:23 <cocreature> Control.Monad.State.Lazy is from mtl iirc
01:19:30 <jle`> oh, i see, i didn't read the error
01:19:32 <cocreature> the Trans one should be correct
01:19:45 <jle`> yeah, Control.Monad.Trans.State.Lazy is indeed the one exported by `transformers`
01:19:47 <amalloy> okay
01:19:51 <cocreature> you can also just import Control.Monad.Trans.State
01:19:56 <cocreature> which reexports the layz one
01:22:55 <amalloy> got it
01:29:12 <timothee> Hi all
01:31:54 <drewbert> I had a hex representation of a word64, and I need the word64.  Having trouble finding the appropriate library.
01:33:03 <rom1504> must be a few lines to implement
01:33:44 <timothee> Having trouble to use Data.Bits.FiniteBits.countTrailingZeros, ghc said "Not in scope: `Bits.FiniteBits.countTrailingZeros'"
01:34:03 <timothee> If someone now how to use this, could be great :)
01:40:33 <quicksilver> what import statemenet did you use?
01:41:13 <quicksilver> if you'd just used import Data.Bits.FiniteBits (countTrailingZeros) then you could just call it 'countTrailingZeros'
01:41:55 <quicksilver> > read "0xbeefbeefbeefbeef" :: Word64
01:41:56 <lambdabot>  13758425323549998831
01:42:07 <quicksilver> drewbert has gone :(
01:45:13 <timothee> quicksilver: ghc say "Could not find module `Data.Bits.FiniteBits'"
01:45:24 <timothee> I suppose my ghc version has not this module so :p
02:01:09 <quicksilver> I suppose you haven't installed it, timothee :)
02:01:23 <quicksilver> oh it's in base
02:01:33 <quicksilver> then yes, I suppose your version of GHC is too old.
02:01:43 <quicksilver> hmm
02:01:53 <quicksilver> @hoogle countTrailingZeros
02:01:55 <lambdabot> No results found
02:02:07 <quicksilver> timothee: you confused me. I should have checked.
02:02:15 <quicksilver> it isn't Data.Bits.FiniteBits.countTrailingZeros
02:02:25 <quicksilver> it's simply Data.Bits.countTrailingZeros
02:02:30 <quicksilver> there is no module called 'FiniteBits'
02:05:07 <timothee> thank you quicksilver , I'll check what I can do
02:06:00 <quicksilver> try import Data.Bits(countTrailingZeros)
02:07:01 <timothee> ghc doesn't find it, so I guess my version is too old
02:08:06 <timothee> will compile an updated version, really I thank you for your help, it's nice
02:08:52 <julianleviston> If I want to model, say, about 7 different generic Algebraic DataTypes, and I want to use them to keep some data (in a generic way), so that I can later build the data out using the structure from the generic DataTypes (and “typecheck” the data possibly)… what’s a good thing to do that with? I suppose I could use the GHC API types… is that a good idea?
02:09:07 <Gurkenglas> Can I do stuff like "[sboxforward, sboxbackward] :: [[Bool] -> [Bool]]" at the top level?
02:09:16 <julianleviston> Will that actually let me work out how to validate and/or “use” the structure of my data though?
02:09:56 <julianleviston> Gurkenglas: no? that’s an expression…
02:10:02 <julianleviston> Gurkenglas: isn’t it?
02:10:36 <Gurkenglas> (I remember that someone did something like that with tuples once, but I'm getting compiler errors, so do I need to activate some language extension?)
02:10:56 <julianleviston> Gurkenglas: what are you trying to do? 
02:11:31 <Gurkenglas> http://lpaste.net/147117 lines 9 to 11 I don't really need sbox itself at the top level
02:11:32 <julianleviston> Gurkenglas: if you just have an expression it won’t be used by anything, even if you *could* do that… 
02:11:45 <lyxia> Gurkenglas: ScopedTypeVariables allows you to place the signature inside the definition. [a,b] :: [Int -> Int] = ...
02:12:26 <Gurkenglas> lyxia I just mean getting multiple toplevel names out of one toplevel definition
02:12:29 <julianleviston> Gurkenglas: Oh… you’re trying to do pattern matching on a LIST? guh
02:12:33 <lyxia> In this case you could also do sboxforward, sboxbackward :: [Bool] -> [Bool]
02:13:00 <Gurkenglas> Could they share a where clause?
02:13:18 <lyxia> Gurkenglas: It's complaining about the signature. The definition below should be fine.
02:14:06 * hackagebot prelude-edsl 0.3.1 - An EDSL-motivated subset of the Prelude  https://hackage.haskell.org/package/prelude-edsl-0.3.1 (EmilAxelsson)
02:14:17 <lyxia> Gurkenglas: The where clause is shared too.
02:14:55 <quicksilver> not quite sure what you're trying to achieve Gurkenglas but this variant is legal:
02:14:56 <julianleviston> So… should I use the types from Language.Haskell.Syntax ? In which case, how do I work with the data that I have in some of those types?
02:14:59 <quicksilver> > let ab :: [Int]; ab = [a,b]; [a,b] = [1,2] in (a,b)
02:15:01 <lambdabot>  (1,2)
02:15:13 <julianleviston> quicksilver: at top level, in a file?
02:15:28 <quicksilver> yes, that would be legal at top level in a file as far as I KNOW.
02:15:43 <quicksilver> CAPS LOCK ERROR HELP HELP I CANT TURN IT OFF
02:15:46 <julianleviston> quicksilver: I’ve always got expression at top level errors whenever I’ve tried. 
02:15:47 <julianleviston> LOL
02:20:55 <Gurkenglas> maximumMap :: (Foldable t, Ord b) => (a -> b) -> t a -> a, name derived from maximum and (fold -> foldMap), superior to maximumBy through memoization, should be in base.
02:21:34 <Gurkenglas> *maximumBy . comparing
02:22:55 <Gurkenglas> @letlpaste 147117
02:22:55 <lambdabot>  Parse failed: Parse error: virtual }
02:23:01 <MarcelineVQ> Is that similair to sortBy comparing vs sortOn?
02:23:10 <arkeet> yes, I would call that maximumOn
02:23:14 <quicksilver> you mean the schwartzian transform version Gurkenglas ?
02:23:17 <arkeet> I don't see the similarity with foldMap.
02:23:21 <Gurkenglas> yep
02:23:24 <arkeet> other than that the arrows are in the same place.
02:23:49 <quicksilver> arkeet: it's foldMap using a 'Max' monoid. Isn't it?
02:24:01 <arkeet> :t foldMap
02:24:03 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:24:16 <quicksilver> ArgMax, rather
02:24:24 <arkeet> no
02:24:40 <arkeet> the types don't match up.
02:25:52 <Gurkenglas> https://www.google.de/search?q=Parse+failed%3A+Parse+error%3A+virtual+%7D&oq=Parse+failed%3A+Parse+error%3A+virtual+%7D&aqs=chrome..69i57.406j0j7&sourceid=chrome&es_sm=93&ie=UTF-8#q=%22Parse+failed:+Parse+error:+virtual+%7D%22
02:25:56 <quicksilver> well it's a projection
02:26:09 <quicksilver> map a to ArgMax b a
02:26:15 <quicksilver> foldMap it, rather
02:26:20 <quicksilver> and then project out the a at the end
02:26:24 <Gurkenglas> That parse error only shows up in lambdabot? Does anyone see the parse error in http://lpaste.net/147117
02:26:31 <quicksilver> I might have the parameters to ArgMax backwards.
02:26:41 <arkeet> quicksilver: maybe
02:27:03 <arkeet> @letlpaste 147117
02:27:03 <lambdabot>  Parse failed: Parse error: virtual }
02:27:30 <arkeet> maybe it doesn't like some indentation.
02:27:58 <arkeet> also maybe you want to put a newline at the end.
02:28:00 <arkeet> just a guess.
02:28:02 <quicksilver> it's wrong to have those , lined up with the | in line 22 isn't it?
02:28:15 <quicksilver> should be indented by at least 1 space
02:28:15 <arkeet> no, that's not layout.
02:28:20 <MarcelineVQ> Gurkenglas: "| [_," needs to be indented passed matchcount above it
02:28:30 <quicksilver> oh yes there it is.
02:28:32 <Gurkenglas> eww
02:28:45 <arkeet> oh, sure.
02:29:03 <arkeet> that's it then.
02:29:28 <arkeet> or just put braces.
02:48:46 <Gurkenglas> Am I to use something in place of "State StdGen" and "state random"?
02:51:42 <quicksilver> there is a MonadRandom floating around in some module
02:51:43 <pavonia> random-fu perhaps
02:51:46 <lyxia> Gurkenglas: Rand from MonadRandom
02:51:50 <quicksilver> I'm a bit surprised it isn't more mainstream
03:39:08 * hackagebot hindent 4.6.1 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.6.1 (ChrisDone)
03:39:11 * hackagebot json-encoder 0.1.3.1 - A very fast single-pass JSON encoder with a declarative DSL  https://hackage.haskell.org/package/json-encoder-0.1.3.1 (NikitaVolkov)
04:00:27 <ocramz> hi all
04:08:04 <ocramz> I'm looking at SubHask.Algebra. A type family definition uses an infix operator: `type family (><) (a :: k1) (b :: k2) :: *`, which has instances e.g. `type instance Int >< Int = Int, type instance Float >< Float = Float, ... , type instance (a -> b) >< c = a -> (b >< c)`. These are then used in a constraint synonym `type IsScalar x = (Ring x, Ord x, .. , x ~ (x >< x)`. What's the role of the "function-type" instance?
04:10:52 <ocramz> Also, what's the purpose of declaring a `type family Scalar a` and using it as a constraint in this fashion: `class (Scalar (Scalar g) ~ Scalar g, ...) => Normed g where ...` ?
04:19:59 <roelof> hello, what is the best ide for working on Windows with haskell. Intelij or sublimetext ? 
04:22:23 <cocreature> roelof: atom seems to be fairly popular these days. personally I use emacs, which should work on windows as well, but as I don’t use it myself on windows, I don’t want to claim that it’s good there :)
04:23:14 <roelof> cocreature:  thanks 
04:23:26 <roelof> I never worked with atom 
04:23:50 <cocreature> roelof: if you alreay have an editor you’re comfortable with just go with that, there’s haskell support for most of them
04:25:43 <roelof> I did use intelij for clojure before. Then I have to find a good plugin for that 
04:32:38 <ocramz> import System.Directory
04:32:52 <ocramz> oh sh sorry guys I thought I was in ghci
04:33:09 <hvr> ocramz: prepend a '>' and you're =)
04:33:19 <ocramz> :D true
05:02:44 <Shffle> How do ReadP compare in performance to Parsec and Attoparsec?
05:04:41 * hackagebot imperative-edsl 0.4.1 - Deep embedding of imperative programs with code generation  https://hackage.haskell.org/package/imperative-edsl-0.4.1 (AndersPersson)
05:13:11 <Shffle> Is there a channel for stack?
05:13:36 <frerich> Shffle: There is #haskell-stack
05:13:51 <roelof> Anyone a good recommendations for a good plugin on intelij ? 
05:13:52 <Shffle> Thank you frerich 
05:16:36 <maerwald> I recently started mixing do-notation and bind operator, is that considered odd? e.g. "rawModel <- newTVarIO =<< listStoreNew . goAllDown =<< readTVarIO fsState"
05:18:39 <hpc> maerwald: it could make sense, but it's pretty unusual
05:18:40 <c_wraith> maerwald: nah.  It's just inlining an expression you don't see a need to name.
05:19:09 <hpc> maerwald: i try to take the perspective of "make it look like what it does", so if that chunk of code is a tight enough unit to go on one line go for it
05:19:34 <roelof> or a good tutorial how I use Atom. Sublime text is not working on my windows box. I cannot install the haskell plugin 
05:19:43 <hpc> maerwald: i would look at giving it a name first, but as c_wraith says if you don't need to then this is just fine
05:19:57 <frerich> maerwald: There's a (.) usage!!
05:20:08 <maerwald> frerich: you are right, that should be fmap
05:20:11 <maerwald> :D
05:20:19 <frerich> The outrage!
05:21:04 <c_wraith> maerwald: I *do* wonder about reading a TVar and creating one from IO.  Kind of misses the point. :P
05:21:32 <maerwald> c_wraith: this is in Gtk+ callbacks, I am stuck to IO
05:21:37 <maerwald> or what do you mean?
05:22:16 <hpc> TVar is meant for STM so it looks weird
05:22:31 <maerwald> I use it in IO instead of IORef
05:22:45 <hpc> why not IORef?
05:22:51 <maerwald> TVar is supposedly more safe
05:22:51 <c_wraith> If you never use atomically, that's very weird.
05:22:59 <maerwald> I do use it
05:23:18 <c_wraith> If you do use atomically, it's only a bit odd occasionally. :)
05:23:23 <hpc> heh
05:27:34 <Sigyn> br0kenman: An error has occurred and has been logged. Please contact this bot's administrator for more information.
05:27:53 <Sigyn> danthemyth: An error has occurred and has been logged. Please contact this bot's administrator for more information.
05:29:25 <MarcelineVQ> I want a custom error message too.
05:29:39 <MarcelineVQ> alas
05:33:52 <roelof> no one who can help a beginner with a good tutorial on how to make atom / Intelij work with Haskell on Windows ? 
05:34:39 <julianleviston> roelof: are you a beginner?
05:34:49 <julianleviston> roelof: I didn’t think you were, for some reason.
05:35:11 <julianleviston> roelof: I really disliked atom’s parenthesis matching algorithm.
05:35:16 <roelof> Im started again but now on Windows 
05:35:40 <roelof> I work on a cloud ide but that one is closed down :( 
05:35:42 <MarcelineVQ> julianleviston: you can overwrite it :>
05:35:55 <julianleviston> MarcelineVQ: overwrite what?
05:36:01 <MarcelineVQ> any part of atom you want
05:36:41 <julianleviston> MarcelineVQ: sure. It’s opensource.
05:37:03 <MarcelineVQ> I meant more that it's desgined to be tinkered with
05:37:46 <julianleviston> MarcelineVQ: I wasn’t that fussed with doing that, given that sublime text works pretty fine for me.
05:38:18 <roelof> I tried Sublime Text but as I said I cannot make the plugin work. It's fails on a package named unix 
05:38:25 <julianleviston> MarcelineVQ: I do like the idea of a hackable text editor, but it didn’t seem very hackable to me. Mind you, I didn’t use it much.
05:38:29 <julianleviston> roelof:  what plugin?
05:38:38 <julianleviston> roelof: I don’t use plugins.
05:38:44 <julianleviston> roelof: should I be using them?
05:39:48 <julianleviston> roelof: is IntelliJ windows different somehow than other platforms?
05:40:02 <roelof> Sublime text has to use a plugin for Haskell development or am I wrong ? 
05:40:19 <julianleviston> roelof: what do you mean? It’s a text editor.
05:40:26 <julianleviston> roelof: I just use it to edit my source files.
05:40:38 <julianleviston> roelof: or are you talking about linting or something?
05:41:04 <roelof> I do not think so but when Im googeling there are a lot of haskell "plugins"  and I cannot figure out what is a good one 
05:41:21 <julianleviston> roelof: um… a plugin to do what?
05:41:26 <roelof> julianleviston:  no, im talking about sublime-haskell package/plugin all the time 
05:41:36 <julianleviston> roelof: If you want to install a plugin, I’m assuming you know what it’s for?
05:41:46 <julianleviston> roelof:  otherwise, why bother installing it?
05:42:24 <roelof> julianleviston:  on Sublime text you did not install the sublime-haskell package ? 
05:42:31 <julianleviston> roelof:  that is correct.
05:42:43 <julianleviston> roelof: at least, I think that’s correct.
05:42:48 <julianleviston> roelof: let me check.
05:43:08 <julianleviston> roelof: I definitely have a syntax-highlighter for the language.
05:43:46 <magneticduck> atom has some nice haskell integration
05:44:07 <roelof> magneticduck:  and is there a sort of tutorial how to make atom and haskell work 
05:44:08 <julianleviston> roelof: yeah, no plugins.
05:44:13 <julianleviston> roelof: on windows?
05:44:32 <Walther> magneticduck: well, on atom it's a plugin as well as it's on sublime - however, on atom you don't even get syntax hilighting for haskell without plugins, on sublime you at least get syntax hilighting without any plugins installed
05:44:36 <julianleviston> roelof: for atom, it’s SUPER simple to install the haskell plugins.
05:44:45 <magneticduck> Walther: .. does that matter?
05:44:52 <roelof> yep, otherwise I have to find some sort of cloud to work on linux. I have only a windows machine here 
05:44:54 <magneticduck> on atom, with the plugins I saw, you get a lot of great features
05:45:02 <Walther> magneticduck: well, for sublime plugins aren't required
05:45:03 <magneticduck> had trouble getting the sublime integration to work
05:45:08 <Walther> it's only additional features
05:45:21 <Walther> if/when you want linting and such
05:45:36 <roelof> magneticduck:  which plugins do I need for a repl and syntax highlighting on atom 
05:45:46 <magneticduck> so, if you want to write code without smart autocompletion and good error linking, you can use sublime because then you don't have to download small files from the internet
05:45:49 <Walther> so I guess the relevant question is what is it that roelof wants :)
05:45:49 <magneticduck> sounds like a weak argument
05:45:52 <Walther> Right, there we go
05:46:02 <magneticduck> roelof: I'll check
05:46:03 <julianleviston> roelof: the repl is something separate to your editor.
05:46:06 <Shffle> What OS in general is the easiest to install haskell and haskell libs today? I'm having a lot of trouble installing ghcjs and ghcjs-examples on OSX - stack solver doesn't work.
05:46:14 <magneticduck> you can find all of them from inside the in-editor package manager
05:46:18 <Shffle> It is likely that it is OSX's blame, correct?
05:46:19 <Peaker> Shffle: Linux distros are easiest, I think
05:46:23 <Walther> magneticduck: I wasn't making an argument on either editor being superior or anything, just wondering that before getting too deep into suggestions we should figure out what they need
05:46:24 <magneticduck> just search 'haskell' and install things until things line up ^^
05:46:39 <roelof> I need syntax highlighting a repl, linting 
05:46:59 <julianleviston> roelof: what is linting?
05:47:00 <roelof> I think that is enought to get further on the road to learn haskell 
05:47:08 <MarcelineVQ> ghci is your repl :>
05:47:13 <Walther> roelof: this might be relevant https://atom.io/packages/ide-haskell
05:47:18 <magneticduck> julianleviston: running a linter like hslint and having its output shown inline on the file
05:47:27 <julianleviston> magneticduck: *I* know what linting is.
05:47:29 <Walther> https://github.com/atom-haskell
05:47:34 <Shffle> Peaker: but which distro is the best for Haskell development? I have no knowledge on Linux distros. I have no idea how they differ.
05:47:48 <julianleviston> magneticduck: I was just wondering if roelof actually needed it, and if s/he knew what it was.
05:47:53 <magneticduck> Shffle: cabal / stack works everywhere
05:47:57 <Walther> Shffle: That doesn't matter much, just pick the one that looks the easiest to use for you
05:48:13 <Walther> the parts that are relevant for developing haskell are similar between the distros
05:48:26 <roelof> julianleviston:  I also know what linting is. a tool to check if the code is good haskell 
05:48:28 <MarcelineVQ> Walther: I personally wouldn't reccomend haskell-ide to someone completely new due to the sometimes involved setup required to get ghc-mod runing smoothly, but language-haskell is a great plugint to start with
05:48:37 <MarcelineVQ> *ide-haskell
05:48:48 <Walther> MarcelineVQ: well, specifically mentioning the requirement of within-editor REPL I think there are no options
05:48:55 <MarcelineVQ> That's fair
05:48:57 <magneticduck> NixOS is the only distro I can think of that scoffs at cabal ^^
05:49:08 <Peaker> ghc-mod is terrible, it always grinds the entire computer to a halt and takes seconds to give any sort of feedback on a non-trivial project :(  ghci-ng is so much better IME
05:49:16 <Walther> MarcelineVQ: iirc language-haskell doesn't provide a REPL even if it provides syntax hilighting and proper indentation and such and is way easier to install and use
05:49:18 <julianleviston> Walther: apart from leksah
05:49:36 <julianleviston> Walther: but I think s/he was having issues using/installing it.
05:49:38 <MarcelineVQ> Peaker: I think that depends on the integration more than ghc-mod itself
05:49:52 <Walther> julianleviston: afaik leksah is not a plugin for atom/sublime though, but a separate environment?
05:50:14 <Peaker> I'm speculating ghc-mod does a full build of everything when things change? whereas ghci-ng just tells an already-running ghci to reload particular modules (re-using already loaded modules)
05:50:15 <julianleviston> Walther: that’s correct. I was talking in general about in-editor REPL. I don’t think there are many options if that’s a constraint.
05:50:50 <dcoutts> magneticduck: indeed, which is why we're actively engaged in stealing the best nix ideas for cabal :-)
05:50:53 <roelof> oke, I will try atom right now
05:51:04 <magneticduck> dcoutts: I thought the best nix idea was 'nix'
05:51:08 <magneticduck> ^^
05:51:33 <julianleviston> atom *is* incredibly easy to set up
05:51:34 <Walther> tldr: on Atom, your best bet is language-haskell. It provides syntax hilighting and indentation, and easily integrates without issues. It doesn't provide a linter or repl though
05:51:53 <Walther> there's also haskell-ide or ide-haskell, but that can be a bit difficult to get/keep working
05:52:17 <dcoutts> magneticduck: it's best ideas are, imho, hash all the inputs to give the package id, allow multiple instances to live side by side (with an environment that selects the ones to use in a particular context)
05:54:59 <roelof> First problem on ghc-mod : ' Error: spawnSync ghc-mod ENOENT '  
05:55:15 <MarcelineVQ> Yes, that means you don't have ghc-mod installed and available in your path
05:57:21 <roelof> pfff, I thougth I installed that one with stack 
05:57:53 <MarcelineVQ> If you did then you just need to add the path to the executable to your system path
05:59:08 <Peaker> julianleviston: "atom" has display latency that makes it completely unusable to me :( 
05:59:35 <julianleviston> Peaker: atom has parenthesis issues which make it completely unusable to me… :) 
06:00:30 <MarcelineVQ> roelof: alternatively you can add the path to ghc-mod to the path section of the haskell-ghc-mod plugin's settings page, I've had better luck adding it to the system path though
06:01:32 * geekosaur let atom sit open overnight and it ended up using more vmem than chrome. NOPE
06:01:59 <roelof> oke, Im running stack again to install ghc-mod 
06:02:21 <julianleviston> geekosaur: yeah, apparently it has some massive perf problems in linux generally… 
06:07:27 <Zenol> Hi. I'm aving issue with a short program that's taking 3GO of memory and is really too slow (14sec for what should be less than 5 in python). I'm quite sure it's related to lazyness and the use of list, but until now adding strictess just resulted in increassing the execution time. I replaced foldl by foldl' and saw a little improvement (less memory used, faster execution), but it's still far from what it should be. Can someone help m
06:07:52 <julianleviston> Zenol: tell us the problem :)
06:08:55 <Zenol> julianleviston: Well, I'm using 3Go memory where I should use less than 500Mo. I did profiling but didn't find anything that can help me understand it. I can give you a past. Wait 1s.
06:08:57 <MarcelineVQ> Zenol: Feel free to use lpaste.net (or any pastebin) to add context to the problem too :>
06:09:09 <julianleviston> MarcelineVQ: thanks :)
06:12:17 <Zenol> julianleviston, MarcelineVQ Here is the prof file : http://lpaste.net/147277 I'm afraid I can't easily reduce the code to something simple, since it's the implementation of a whole algorithm. The costly part are located here : https://github.com/Zenol/hwcr/blob/master/NeuralNetwork.hs and here https://github.com/Zenol/hwcr/blob/master/Main.hs 
06:13:22 <julianleviston> Zenol: thought of using array or sequence instead of list?
06:14:43 * hackagebot idris 0.9.20.2 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.9.20.2 (EdwinBrady)
06:15:06 <Zenol> julianleviston: For wich lists? For example [Layers] are list of at most 10 elements (and in this case 2 elements).
06:15:38 <Zenol> Some other times I use list only because it's the only way to do somme transformations on sparse matrices.
06:16:10 <julianleviston> Zenol: sorry, I just thought Network had a list in it, and I did a brief scan and saw Network was being used lots, so I though tmaybe that was the cause. Apologies.
06:16:29 <Zenol> julianleviston: I actualy don
06:16:39 <julianleviston> Zenol: huh?
06:17:20 <Zenol> julianleviston: *don't understand what's happening. I even didn't know if I'm building big list of thunks, or a lot's of small list of thunks.
06:18:03 <Zenol> julianleviston: I'm also using list for computation (most of the folds here, that I replaced by fold' wich are better (less memory usage) but doesn't solv most of the problem :/
06:18:20 <julianleviston> Zenol: doesn’t foldl’ use lists?
06:18:30 <MarcelineVQ> julianleviston: sometimes
06:18:40 <Zenol> julianleviston: Yes, let me explain.
06:20:02 <Zenol> julianleviston: I have a function of type Net -> b -> Net wich give a better neural network from a previous neural network and an input set of type b. So to compute it on a set of 10 000 inputs, I do a foldl' on the list of inputs.
06:20:14 <julianleviston> oh god
06:20:26 <julianleviston> so you have a list with 10,000 elements in it?
06:20:53 <Zenol> At the end a list of 60 000 elements actualy. But right now only 10k.
06:21:31 <Zenol> But I don't think it's the issue. I already tried to read it and print it and it was really fast, without using that muche memory.
06:21:58 <wedens> is there some tool to automatically add dependencies version constraints to .cabal file? (I use stack || nix)
06:23:08 <Zenol> The list is mad of Vector Word8 (from ByteString), and the reason i'm using a list is actualy because it's a lazy list of reading chuck of 300 bytes from a file.
06:23:20 <Zenol> So that you don't read the whole file at once.
06:23:54 <lyxia> Zenol: Net is a list synonym?
06:24:01 <MarcelineVQ> Zenol: There's so much going on in learn, it's actually difficult to tell where to focus. Consider breaking learn up into a few smaller functions while you sort this out, the profiler may have an easier time telling you what's up if you do that as well. My wild guess at the moment is there's a lot of retraversing of lists happening that could be composed
06:24:01 <Zenol> lyxia: No.
06:24:36 <lyxia> Zenol: I see Network a... Net = Network a?
06:25:26 <Zenol> lyxia: Ok, the function is actuly of type (Input Double, Output Double) -> Network Double -> Network Double
06:25:41 <Zenol> lyxia: (you have to apply flip to have a->b->a)
06:25:59 <Zenol> MarcelineVQ: The breking by using where isn't enought?
06:26:03 <MarcelineVQ> well
06:26:22 <MarcelineVQ> The nesting wheres is a red flag for me personally
06:26:31 <lyxia> foldl' doesn't force much of the Network, just the top most constructor, maybe that's where the leak comes from?
06:26:44 <Zenol> Oh, maybe it's because of the scanl....
06:27:52 <ggVGc> a very experienced programmer I hold in high regard said yesterday "Are we even sure type systems are useful". Is there any good research on that?
06:27:59 <ggVGc> I mean, it's pretty hard to measure
06:28:03 <Zenol> lyxia: Maybe, as MarcelineVQ is saying, most of the work, and also thunks, are created in the learn function, because there is a lot's of calls of operators.
06:28:20 <ggVGc> but all argumentations about type systems or not are just personal and empirical
06:28:22 <julianleviston> ggVGc: yeah they’re not. Case closed. Thanks :)
06:28:36 <sm> ggVGc: a search will find you a few decades of debate on this, including some studies
06:28:45 <lyxia> Zenol: Try to deepseq the layers in the learn function. That seq does nothing.
06:28:47 <ggVGc> I'm pretty much convinced I love static types and expressive type systems
06:28:49 <ggVGc> but still
06:28:56 <ggVGc> sm: sure, but I said good studies
06:28:57 <julianleviston> ggVGc: we just don’t care enough to argue with you.
06:29:00 <ggVGc> eh, good research
06:29:30 <Zenol> lyxia:  ? All the foldl' gave improvement in both speed and memory, compared to foldl. Although it's a improvement close to 0.5 sec and less than 100Mo.
06:29:58 <julianleviston> ggVGc: speaking for everyone in the room is probably not a good idea, but I think it’s pretty true in this case. We’re here because we find types useful. If it’s personal, so be it. It’s our delusion, but we prefer it, and maybe it’s just placebo.
06:30:10 <ggVGc> julianleviston: well, I'm on your side, but my only argument is "in my experience it feels like it works better", which isn't very scientific
06:30:39 <Darwin226> Hey guys, I need a bit of help. Say I have `liftIO $ evaluate $ error "some error"`. How can I catch this error if I'm not concretely in IO but in MonadIO?
06:30:59 <lyxia> Zenol: It may improve a bit but my point is that unless the accumulator is of a primitive type, most of it will still remain as a thunk.
06:31:31 <Zenol> MarcelineVQ: I'm having a closer look at learn. Actualy I should rewrite and break it in smaller peaces, but it's not finished. I have to add more stuff on it, but first I should check that everything in this algorithm is right, and can't because I don't have 4Go memory on my laptop and 2 hours for letting that crap run x)
06:31:40 <indiagreen> julianleviston: I'd say speaking for everyone in the room is definitely not a good idea
06:32:16 <Zenol> lyxia: Yes but, some of the stuff should remain thunks, some others shouldn't. I can't tell which should or shouldn't. But deepSeq won't be a solution.
06:32:20 <julianleviston> indiagreen: so you don’t find types useful? :)
06:32:59 <indiagreen> julianleviston: I only know 1 language (i.e. Haskell), and so I have like zero evidence that types are useful
06:34:29 <Zenol> julianleviston: Personaly, I don't know if types are that usefull. I don't know which paradigm is the best, and I don't know if lazyness is one of the best or wors idea of the humanity :p
06:34:49 <MarcelineVQ> Zenol: then use smaller inputs for now if at all possible, regardless this profile is very strongly suggesting learn is the issue and if you break it up into seperate functions it may be able to be more informative about where the problem lies. Alternatively you can be explicit about what the profiler should be checking: http://book.realworldhaskell.org/read/profiling-and-optimization.html
06:34:55 <magneticduck> indiagreen: write a program in javascript
06:35:01 <julianleviston> lol :)
06:35:08 <magneticduck> if your only exposure to programming has been in Haskell
06:35:11 <magneticduck> .. you're in for a suprise
06:35:16 <magneticduck> fun fact: types are useful
06:35:28 <maerwald> anyone knows how I pass "NULL" to a gtk+ function? There doesn't seem to be an appropriate equivalent, tried with nullPtr etc but those are all wrong types
06:36:13 <Zenol> MarcelineVQ: For profiling yes, I can use any size of input. (But for testing the algorithm, I really need the whole dataset :/)
06:36:52 <Zenol> I think I can at least move out of learn 1 or 2 functions. Let me try :-)
06:36:53 <ggVGc> It intuitively feels logical that it's useful having a tool that before runtime can say "you have an internally coherent program", but actually that might not be the best way to have correct software and might carry more costs than some alternative method
06:37:00 <ggVGc> intuition is fairly often wrong
06:37:06 <Zenol> (And thanks for the link ^^)
06:37:52 <ggVGc> anyway, I wasn't trying to start an agressive argumentation or anything. I just found it interesting that someone with the experience of this friend of mine argued types might not be so useful after all
06:37:59 <magneticduck> maerwald: uh, well look up what NULL means in that particular setup of C++ or C you're using
06:38:02 <MarcelineVQ> ggVGc: http://www.aosabook.org/en/ghc.html this may interest you, it's a little long but there's a couple gems about the type system as it relates to taking high-level constructs and reasoning about them simply, as it relates to compiler steps
06:38:03 <magneticduck> and pass.. that
06:38:08 <magneticduck> I'm suprised nullPtr is 'of the wrong type'
06:39:20 <ggVGc> MarcelineVQ: thanks, I'll take a look. I don't think it's exactly what I'm talking about though. I'm more saying that maybe the way we are thinking about types and static checking isn't actually the best way to robust cost-effective software
06:39:26 <ggVGc> even if it intuitively feels it should be
06:39:29 <julianleviston> indiagreen: but you’re right, I should *not* have spoken for everyone in the room… and I also shouldn’t have been annoyed at ggVGc . It’s just such a vacuous thing to say “programming with types may not be useful!” ALL programming languages have types. They have to. Haskell’s typechecker simply won’t run or compile your program until the pieces you connect together actually work together. It seems strange
06:39:29 <julianleviston> to want that, given that most of the way people in dynamic languages write is by getting runtime errors or manually written tests to do that job for them anyway.
06:40:03 <ggVGc> sure, but we might also not be very good at software development yet
06:40:06 <ggVGc> I'm pretty sure we're not
06:40:10 <magneticduck> julianleviston: "all programming languages have types" can only be deduced from a very loose (non-descriptive) specification of what a type is
06:40:11 <maerwald> magneticduck: figuring out every single type and constructing phantom objects isn't really an equivalent to NULL
06:40:27 <julianleviston> magneticduck: I mean at least everything becomes a number.
06:40:43 <ggVGc> that's why I was asking about any form of scientific study of if types are actually bringing real world value in the bigger view of software
06:40:49 <julianleviston> magneticduck: every programming language I’ve ever used has some notion of things of different kinds (not kinds in the haskell sense).
06:41:05 <julianleviston> ggVGc: but that itself is a massively subjective thing.
06:41:10 <ggVGc> just because it feels better for us programmers and makes our lives feel easier, doesn't mean it's actually the better way
06:41:13 <davean> magneticduck: uh?
06:41:18 <julianleviston> ggVGc: what unit is “real world value” measured in?!
06:41:38 <ggVGc> julianleviston: well, no, it's essentially about measuring cost and risk I'd say, which is something that can be done scientifically
06:41:38 <magneticduck> julianleviston: ah yes, the ontological argument for the existence of Types
06:41:53 <ggVGc> but yeah, sure, subjective within a context that most of us exist in
06:41:56 <julianleviston> ggVGc: programming with types doesn’t feel better… but without them I get in a massive mess eventually.
06:41:57 <magneticduck> Types are the thing everything passes through; everything passes through a computer; therefore, Types exist
06:42:07 <magneticduck> descartes would be proud
06:42:10 <ggVGc> julianleviston: is that a scientific fact or a feeling?
06:42:14 <maerwald> I guess I can just use "undefined"
06:42:15 <julianleviston> magneticduck: ontological? as in… the study of being?
06:42:48 <frerich> ggVGc: I'm not aware of any study about static typing per se, but I recall a couple of articles about how modularization does help managing and maintaining risk, which in turn is needed to be able to estimate delivery days and costs. By modularising your code (e.g. using subroutines), you establish 'contracts' in your code (i.e. preconditions, postconditions, invariants). This turned out to be a good thing.
06:42:48 <danza> ggVGc, maybe substitute a generic better with "safer" or "more reliable", and you will have an easier search for motivations
06:42:57 <julianleviston> ggVGc: it’s a fact… things become so messy… confused and difficult to deal with… this is nothing to do with how I feel about it.
06:43:12 <frerich> ggVGc: I imagine static typing can be considered as a means to enforce the contracts, by expressing your invariants in a languag e(types) which is comprehensible to the compiler and can be checked statically.
06:43:18 <magneticduck> if all languages have types because "at least everything becomes a number", so to your a type system is something that exists as a fundamental property of computer science
06:43:32 <davean> magneticduck: yes actually
06:43:50 <byorgey> ggVGc: there actually hasn't been much real scientific study of this.  It's definitely a lack.  Partly, it's hard to study, and partly I guess no one has been motivated to actually design a proper study
06:43:52 <davean> magneticduck: if you look at the definition of type in different ways, it comes down to having data an operations between them
06:44:01 <frerich> ggVGc: So the types in itself are not the beneficial thing, it's the idea of considering your software nto to be one big lump of code but rather individual units which have some sort of 'contract' with the outside world so that they can be reasoned about in isolation.
06:44:13 <mnoonan> ggVGc: here's one paper, with some good citations in the related work (section 2) https://courses.cs.washington.edu/courses/cse590n/10au/hanenberg-oopsla2010.pdf
06:44:14 <julianleviston> magneticduck: that’s not entirely or exactly what I meant… I was simply providing the extreme case. Every language has to have types.. whether they’re dynamic and implied or explicit and static.
06:44:20 <MarcelineVQ> maerwald: are you interfacting with gtk+ through the ffi, or a hackage library?
06:44:24 <Freundlich> ggVGc: An easy and mathematical way to think about this is: Types prevent programs that go wrong to run. They also prevent programs that don't go wrong to run (because of the halting problem).
06:44:26 <julianleviston> magneticduck: otherwise programming couldn’t do anything of much use.
06:44:29 <ggVGc> frerich: yeah, I think I agree with what most people in here will say. BUt the fact is we don't have any real studies on it. It's mostly speculation and extrapolation from personal experiences, which may or may not hold the truth
06:44:45 * hackagebot wai-app-static 3.1.4 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.4 (MichaelSnoyman)
06:44:55 <magneticduck> julianleviston: more descriptively, the *problem* of types, categorizing data values in useful and interesting ways, is something that all languages face
06:44:56 <byorgey> ggVGc: here's an overview of the existing literature: http://lambda-the-ultimate.org/node/5286
06:45:06 <julianleviston> magneticduck: sure.
06:45:08 <davean> magneticduck: I mean, some times they're degenerate and there exists a single type
06:45:08 <ggVGc> thanks, will check these links
06:45:12 <magneticduck> but some of them don't deal with it beyond putting them all into a big bag; those languages, to me, have no thoughtful type system
06:45:14 <magneticduck> they have 'no types'
06:45:23 <Freundlich> ggVGc: Typically, we think that prevent the programs that go wrong to run is more valuable to us humans than to also prevent some that don't.
06:45:23 <frerich> ggVGc: Right. I'm not aware of anything about static typing per se, but I swear I saw papers about how modularization and being disciplined about 'contracts' of units of code is beneficial to risk management (e.g. to increase changes of delivering in time)
06:45:24 <magneticduck> in the same way a room with nothing but air and dust has 'no things'
06:45:25 <julianleviston> magneticduck: yep.
06:45:28 <davean> magneticduck: they still have exactly one type
06:45:55 <Freundlich> Which is a very vague statement, I must admit. 
06:46:01 <frerich> ggVGc: So it may be more productive to look for studies like that and then argue that static typing are one way to implement this idea such that it's no longer the developers who carefully think about what their function does but they get help from the compiler.
06:46:01 <davean> You can say their types aren't interesting
06:46:16 <davean> you can say you don't care about the stuff in a room
06:46:31 <davean> but all you're doing is engaging in unclear thinking when you conflate not caring with them not existing
06:46:33 <ggVGc> frerich: yeah, I think that's a more well established and researched concept. But maybe that can be had without also having static typing, and maybe the cost of writing the software might actually go down by focusing on good modularisation but not having static types
06:46:37 <ggVGc> dunno
06:46:41 <Zenol> MarcelineVQ: Thank you, you made me discorver a bug (using aL instead of al when computing a gradient :o)
06:46:42 <maerwald> MarcelineVQ: hackage. The problem is that I don't need (or rather must not use) 2 parameters of a signal callback, but I cannot control the passing of those parameters
06:46:44 <aweinstock> is x86 assembly "having types" in the sense that (eax :: Word32) relevant to this conversation?
06:46:56 <maerwald> in C I'd juse pass NULL and be done
06:47:00 <frerich> ggVGc: It can definitely be had without static typing. You can of course write perfectly good software without any static typing whatsoever.
06:47:01 <julianleviston> ggVGc: maybe you should look into gradual typing.
06:47:16 <ggVGc> julianleviston: like Flow?
06:47:19 <ggVGc> Flow is pretty amazing to me
06:47:19 <julianleviston> ggVGc: dunno
06:47:25 <julianleviston> ggVGc: I wasn’t interested enough
06:47:26 <ggVGc> and very ver interesting
06:47:27 <maerwald> I'm trying to wrap the thing with (\_ _ -> foo) somehow, but it doesn't work
06:47:50 <aweinstock> @pl (\_ _ -> foo)
06:47:50 <lambdabot> const (const foo)
06:47:58 <ggVGc> actually, Flow is probably not gradual typing at all. I mixed things up
06:48:03 <aweinstock> :t const . const
06:48:05 <lambdabot> a -> b -> b1 -> a
06:48:38 <julianleviston> ggVGc: really, Haskell makes design decisions… this is what makes it Haskell. If you require a tool that makes those decisions, then use it. If not, it’s not the right tool for you or the job you want to do. There’s nothing saying you have to use one single tool for everything, or that Haskell is a religion.
06:49:12 <ggVGc> I think there's a fair chance we can have tools that check our program flows and validate them without having rigid static typing, and that it might actually result in cheaper/easier to write software. Flow is a pretty good example of something going in that direction
06:49:35 <ggVGc> but I also personally feel that Haskell helps me think better about my software
06:49:41 <ggVGc> but I can't quantify that
06:50:08 <julianleviston> ggVGc: why is quantification so important?
06:50:21 <magneticduck1> oh no, my argument about what a type system is and whether all languages have one was interrupted by a power blip -- and just as we were reaching the best part
06:50:44 <ggVGc> magneticduck1: maybe some software down the line should have been better typed
06:51:20 <ggVGc> julianleviston: well, if one direction is ultimately better for software development, it would probably be useful to objectively show that to ourselves and others so we can understand why and go in that direction
06:51:20 <magneticduck1> literally the second the power blipped a siren started and I saw an ambulance pass by a few minutes later
06:51:28 <magneticduck1> perhaps somebody had a fun day
06:51:43 <ggVGc> sounds not so good
06:51:50 <julianleviston> ggVGc: you say “better”, but better requires a direction…
06:52:03 <julianleviston> ggVGc: going north is obviously better if I want to go north, but worse if I want to go south.
06:52:12 <magneticduck1> oh good, we're still discussing hazy semantics and conflicts of definition
06:52:15 <julianleviston> ggVGc: ergo, there is no one true language.
06:52:31 <ggVGc> julianleviston: I guess in this context it means cheaper and more robust. I.e faster to write and modify, while also requiring the least amount of modification
06:52:39 <magneticduck1> I'm not sure clear on the context, last read messages 6 minutes ago, but let me say that definitions are chosen for bearing useful results, and not for anything more
06:52:55 <indiagreen> ggVGc: it's possible that types help some kinds of programs and hurt other kinds
06:53:04 <indiagreen> magneticduck1++
06:53:04 <ggVGc> indiagreen: yeah that entirely fair
06:53:18 <ggVGc> but even so, it would be nice with some objective studies showing it
06:53:52 <indiagreen> yeah, definitely, but so far I don't even know how such a study could be conducted so I'm not surprised that there aren't any good ones
06:54:18 <magneticduck1> the definition of a 'type system' should in my mind bear relation only to languages that do not have exactly one monolithic 'type' for the same reason the term 'dog' does not apply to a pile of dust even if it contains all the components of a dog and formed part of a dog 20 years ago 
06:54:25 <ggVGc> which is what I was asking about. Anyway, sorry, I didn't mean to argue type systems at all. I was just curious if anyone knew about good suties on their usefulness versus other ways of developing software, from a macro perspective rather than from a developer
06:54:46 <ggVGc> indiagreen: right, hence why we're still in the state of "I feel this way and you feel that way"
06:55:35 <echo-area> What is the theory behind dependent-map?
06:56:27 <davean> magneticduck1: that becomes borish when you have to then consider ones with 2 types, 3 types ... Its nothing like the dust
06:56:33 <ggVGc> I'm pretty sure we're still basically fumbling in the dark when it comes to software development
06:57:00 <julianleviston> ggVGc: what does fumbling in the dark mean?
06:57:05 <ggVGc> also, it doesn't feel like we've made that much progress since the 60s
06:57:43 <ggVGc> julianleviston: that we've been doing this for less than 100 years, and "normal people" haven't even had access to it for more than a few decades. We're basically still in early stone age when it comes to computers
06:57:57 <julianleviston> ggVGc: normal people still don’t have access to it.
06:58:00 <magneticduck1> ggVGc: well, we're fumbling in the dark at 100 miles an hour
06:58:04 <ggVGc> I meant computers
06:58:11 <magneticduck1> we seem to be .. doing things with software, you know
06:58:17 <magneticduck1> we have a bunch of software I think
06:58:33 <indiagreen> magneticduck1: exactly, we're fumbling in the dark very fast
06:58:42 <julianleviston> lol ok I’m out of this convo :)
06:58:46 <MarcelineVQ> The type of this convo is ()
06:59:20 <ggVGc> magneticduck1: sure, but we were building mega structures on mountains a long time before we had helicopters
06:59:23 <aweinstock> MarcelineVQ: not IO ()?
06:59:44 <MarcelineVQ> #haskell is side-effect free aweinstock
06:59:58 <ggVGc> mephx: I highly doubt that
07:00:05 <ggVGc> MarcelineVQ: ^
07:00:08 <aweinstock> how about [(Nickname, String)]?
07:00:15 <magneticduck1> The type of this convo is ERROR: cannot construct the infinite type: a1 = DiscussSemanticsOf a1
07:00:17 <magneticduck1> MarcelineVQ: ftfy
07:00:22 <MarcelineVQ> :>
07:01:04 <aweinstock> :t Data.Functor.Fixpoint.Fix
07:01:07 <lambdabot>     Not in scope: data constructor ‘Data.Functor.Fixpoint.Fix’
07:01:12 <aweinstock> :t Data.Functor.Fixedpoint.Fix
07:01:15 <lambdabot>     Not in scope: data constructor ‘Data.Functor.Fixedpoint.Fix’
07:01:41 <magneticduck1> indiagreen: it's hard to say we're fumbling in the dark though
07:01:54 <magneticduck1> because 'fumbling' implies we're actually trying to change the way we're developing software
07:01:55 <magneticduck1> we're.. not
07:02:12 <ggVGc> no?
07:02:13 <magneticduck1> most actual projects are built on experience and industry standards
07:02:26 <ggVGc> the re-rise of functional programming seems to be a pretty big attempted change to me
07:02:28 <aweinstock> @let newtype Fix f = Fix { unFix :: f (Fix f) }
07:02:30 <magneticduck1> this is the reason JavaScript exists
07:02:31 <lambdabot>  Defined.
07:02:34 <aweinstock> :t Fix
07:02:36 <lambdabot> f (Fix f) -> Fix f
07:02:57 <magneticduck1> ggVGc: not as big as the attempted inertia of the vast majority of software development
07:03:16 <ggVGc> yeah, sure, that's why I said it doesn't feel like we've evolved much in software since the 60s
07:03:22 <ggVGc> maybe 80s actually
07:03:30 <magneticduck1> well, C++ has lambdas now
07:03:46 <magneticduck1> that's big, right?!
07:03:55 <ggVGc> hm, 70s I guess. Basically since ML was invented, I don't think we've done much progress
07:04:06 <ggVGc> well, lambdas themselves are very old, so no
07:04:10 <ggVGc> that's no evolvement
07:04:13 <magneticduck1> I'm kidding
07:04:24 <ggVGc> also, didn't know C++ has lambdas now
07:04:26 <ggVGc> that's good
07:04:33 <ggVGc> does that mean it also has real closures?
07:04:36 <magneticduck1> yeah they're going to get list comprehensions in 2017 too
07:04:39 <phadej> ggVGc: nope
07:04:44 <ggVGc> nice..
07:04:48 <magneticduck1> .. I was going to say 'yes'
07:04:51 <Dodek> nope? what are real closures, then?
07:05:10 <magneticduck1> next on the list of funny discussions: does C++ "really" have closures?
07:05:15 <Dodek> i'd say yes, though you have to specify variables to capture by hand
07:05:25 <Dodek> and it interacts with the lack of garbage collection in funny ways...
07:05:36 <ggVGc> that sounds pretty much like C++
07:05:46 <aweinstock> ggVGc: C++ lambdas require you to specify whether you're capturing by value or by reference
07:05:55 <ggVGc> "you can do this, but you have to be explicit, and also it has 14533 very unintuitive edge cases you have to keep in mind"
07:06:03 <magneticduck1> or which values you want to capture
07:06:10 <magneticduck1> it's really just syntatic sugar for a function object
07:06:19 <magneticduck1> with a constructor that happens to take every variable in scope
07:06:21 <aweinstock> by value involves copying, and is safe to pass downwards, by reference can result in undefined behavior if the closed-over variables go out of scope
07:06:24 <magneticduck1> it's not that complicated
07:06:29 <ggVGc> man, I wish they'd just leave C++ alone and let it phase itself out over the next decade
07:06:32 <ggVGc> that'd be fine
07:06:48 <magneticduck1> that's definitely going to happen
07:07:03 <geekosaur> shhh. that'll probably get us cplus.js >.>
07:07:06 <aweinstock> ggVGc: do you have an opinion on Rust?
07:07:09 <ggVGc> my last C++ project was, I kid you not, porting an iPad game to windows
07:07:19 <magneticduck1> geekosaur: we already have js.js
07:07:32 <magneticduck1> that's.. I don't know, funny for some reason
07:07:35 <julianleviston> I’m trying to run this in GHCi with :m Language.Haskell.Exts —> parseType "data Yay = Yay String" but it’s giving me the error “ParseFailed (SrcLoc "<unknown>.hs" 1 1) "Parse error: data”” any ideas why?
07:07:36 <aweinstock> magneticduck1: what's the interpretation overhead?
07:07:45 <magneticduck1> aweinstock: the interpretation overhead is .. very
07:07:46 <ggVGc> aweinstock: only that it's an interesting design, but also I'm not sure if the goals it's trying to achieve are useful for most projects.
07:07:50 <ggVGc> I think Rust will be a very niche thing
07:07:51 <magneticduck1> js.js is essentially just an emscripten
07:07:54 * byorgey suggests this conversation move to #haskell-blah in case anyone actually wants to discuss Haskell
07:07:54 <ggVGc> and it will be amazing in that niche
07:08:03 <aweinstock> (i.e. how much slower is spidermonkey running js.js running hello world, vs sm running js.js running js.js running hw)?
07:08:04 <magneticduck1> js.js is essentially just an emscripten'd release of spidermonkey iirc
07:08:27 <byorgey> julianleviston: I think parseType parses a type expression, not a declaration
07:08:31 <julianleviston> byorgey: that’d be cool. I just asked a question up there ^ :)
07:08:49 <julianleviston> byorgey: ahhh… what’s a type expression?
07:08:51 <quicksilver> and byorgey answered it down here.
07:09:01 <quicksilver> Int is a expression
07:09:08 <julianleviston> ah.
07:09:09 <quicksilver> so is (Bool,[Double])
07:09:15 <quicksilver> a type experssion, sorry.
07:09:25 <quicksilver> typing too fast words missed
07:09:35 <magneticduck1> aweinstock: I briefly considered writing some code in Haxe to be compiled to Python, to then be compiled via ShedSkin to C++, to then be compiled to JavaScript with emscripten
07:09:44 <magneticduck1> but then I decided it would be too awesome and I'd probably break something
07:09:58 <julianleviston> byorgey: so what would I have to use to parse a type declaration? I tried parseExp but that didn’t work obviously.
07:10:08 <julianleviston> byorgey: https://hackage.haskell.org/package/haskell-src-exts-1.17.1/docs/Language-Haskell-Exts-Parser.html
07:10:26 <julianleviston> byorgey: this? parseDecl
07:10:28 <byorgey> julianleviston: probably parseDecl
07:10:32 <julianleviston> cool
07:10:52 <julianleviston> byorgey: roger.
07:11:08 <julianleviston> byorgey: damn! ParseOk (DataDecl (SrcLoc "<unknown>.hs" 1 1) DataType [] (Ident "Yay") [] [QualConDecl (SrcLoc "<unknown>.hs" 1 12) [] [] (ConDecl (Ident "Yay") [TyCon (UnQual (Ident "String"))])] [])
07:11:22 <byorgey> looks good to me =)
07:11:35 <quicksilver> that's a long winded way to say "Yay"
07:11:45 <byorgey> haha
07:11:54 <MarcelineVQ> You can feel the excitement though
07:11:55 <julianleviston> byorgey: hehe :) I’m trying to work out a good way to step one meta-level above some types I have so I can build an editor for data of those types…
07:12:06 <julianleviston> byorgey: but it’s not exactly easy.
07:12:19 <julianleviston> byorgey: I don’t suppose you have any brilliant ideas about this? :)
07:12:23 <quicksilver> you don't need to go up a meta-level to write an editor, normally
07:12:34 <quicksilver> you just need to write (or automatically derive) a zipper for the structure
07:12:48 <julianleviston> quicksilver: how else do you have the editor ‘understand’ the syntax of the types?
07:13:05 <julianleviston> quicksilver: assuming the types can change over the lifetime of the editor… by the way :)
07:13:24 <byorgey> julianleviston: in that case, I suggest you try some sort of generics library, like GHC.Generics
07:13:35 <byorgey> julianleviston: I don't think parsing the source code is the way to go
07:13:36 <julianleviston> quicksilver: sorry if I’m not expressing myself well… I find this quite difficult to think about let alone talk about.
07:13:52 <julianleviston> byorgey: yeah, it needen’t be… 
07:13:59 <julianleviston> byorgey: it seems incorrect.
07:14:26 <julianleviston> byorgey: I thought maybe some kind of general zipper… then I looked into comonads a bit yest/today but yeah.
07:14:27 <Zenol> MarcelineVQ: I move some of the stuff out, and recompiled with -auto-all for profiling. Here is what I have (so still in zVec and correctLayer) : http://lpaste.net/147285
07:14:32 <julianleviston> byorgey: thanks I’ll look at generics.
07:14:40 <quicksilver> even TH is simpler than actual source-parsing.
07:14:50 <quicksilver> but generics is simpler than TH.
07:15:11 <julianleviston> sure I don’t mind what it is, I’d just like to be able to do it :) 
07:15:17 <quicksilver> the problem with generalised zippers is they are so general it's hard to get your teeth intot hem.
07:15:20 <julianleviston> so chuffed that haskell lets me.
07:15:32 <quicksilver> easier to learn about zippers by inspecting some specific written-out cases for some actual data
07:15:39 <quicksilver> and then see how the general ones work.
07:16:02 <julianleviston> quicksilver: I think I’m reasonably across zippers… but they’re usually tied to specific types…
07:16:18 <quicksilver> I wrote an ADT which specified procedural textures and then a simple GUI over zipper to let me interactively create textures
07:16:22 <quicksilver> it was instructive and fun
07:16:26 <quicksilver> maybe I'm easily entertained.
07:16:38 <julianleviston> quicksilver: that does sound fun!
07:16:52 <julianleviston> quicksilver: anything with graphics makes me happy usually :)
07:18:00 <julianleviston> byorgey: do you recommend https://wiki.haskell.org/GHC.Generics as a good place to start?
07:18:51 <julianleviston> byorgey: oh man! thank you so much… this is just what I’ve been looking for over the last couple of days! :)
07:20:30 <julianleviston> I’m not familiar with this syntax… what does it mean? infixr 5 :+:  ; data (:+:) f g p = L1 (f p) | R1 (g p)
07:21:01 <julianleviston> is (:+:) a type constructor?
07:21:27 <quicksilver> julianleviston: http://roobarb.jellybean.co.uk/~jules/Picture%2035.png
07:21:39 <quicksilver> julianleviston: screenshot from 5th October 2007 now I feel old.
07:21:41 <ggVGc> monochrom: thanks that link was very much the kind of thing I was looking for!
07:21:59 <julianleviston> quicksilver: pretty :)
07:22:19 <ggVGc> mnoonan: sorry, that was for you
07:22:22 <quicksilver> julianleviston: that thing on the top-right is an ADT, the things which look like constructors are indeed constructors.
07:22:31 <quicksilver> julianleviston: and the red part is the 'currently focussed' part of the zipper
07:22:50 <julianleviston> quicksilver:  so you can have an operator as the name of a type constructor? lol… 
07:23:15 <julianleviston> quicksilver: sorry, I mean “type name” (I thought it was called a type constructor)
07:23:18 <byorgey> julianleviston: (:+:) is indeed a type constructor there
07:24:46 * quicksilver didn't understand the question
07:25:30 <julianleviston> Wow… and I thought Comonads was breaking my brain.
07:27:47 <julianleviston> byorgey: ok… so what I want to do, though, in addition, is to serialise these structures as data… so I can store it and then revitalise it later.
07:28:04 <julianleviston> byorgey: is that ridiculous?
07:28:23 <Zenol> MarcelineVQ, julianleviston I made a heap profiling : http://zenol.fr/Main.pdf What does it means for you? I don't understand why correctLayer use memory O.o
07:28:51 <quicksilver> you might find Aeson both instructive and useful
07:28:56 <julianleviston> Zenol: is correctLayer a large function? Can we link to it?
07:28:59 <quicksilver> instructive because it is an example of something written using Generics
07:29:01 <julianleviston> quicksilver: I’m using aeson.
07:29:08 <julianleviston> quicksilver:  oh I haven’t looked at the source tho
07:29:12 <quicksilver> useful because it lets you serialise your data.
07:29:24 <quicksilver> so why don't you just use aeson for your serialisation? if you're already using it?
07:29:35 <Zenol> julianleviston: One line. https://github.com/Zenol/hwcr/blob/master/NeuralNetwork.hs in learn (it's a subfunction).
07:30:04 <Zenol> (Ok, it was a lie, 2 lines :p)
07:30:21 <julianleviston> quicksilver: I could, but this isn’t data. 
07:30:52 <Zenol> Ooooohhh, maybe it's because of (-) ?
07:31:25 <julianleviston> quicksilver: Oh… you mean make Aeson instances for these 5 types…  and then … ok… that makes sense. I think… 
07:31:38 <quicksilver> it isn't data? what is it then?
07:31:58 <julianleviston> quicksilver: hehe. I think I haven’t really understood what I’m looking at yet. 
07:33:33 <julianleviston> quicksilver: like… where it says data U1 p = U1… that’s a Unit constructor… but where is the name stored? I guess I’d have to add that… or something...
07:34:44 <MarcelineVQ> Zenol: how long are these lists you're reversing? Do they need to be reversed? You seem to reverse most/all of them, which suggests to me you may not need to reverse any of them and can instead do some of the building flipped around. I don't really understand the project/algo so I can't be more specific
07:34:47 * hackagebot wai-middleware-caching 0.1.0.2 - WAI Middleware to cache things  https://hackage.haskell.org/package/wai-middleware-caching-0.1.0.2 (yogsototh)
07:35:21 <julianleviston> quicksilver: I mean… it’s for data constructors without arguments… but they are named something… 
07:35:49 <Zenol> MarcelineVQ: I think they all have 2 or 3 elements, let me check.
07:36:34 <Zenol> MarcelineVQ: Yes, their size is bounded by (length $layers net) +2. And in my case, I have only 2 layers.
07:37:32 <diphtherial> hey, do any of you have opinions about gloss as a graphics packaage for someone who wants to noodle around with graphical simulations?
07:37:37 <Zenol> MarcelineVQ: And Maybe I could prevent reversing them by thinking a lot and using flip (*) on matrices, but i'll probably introduce bug if I do that without ability to check.
07:37:43 <diphtherial> it seems promising to me, not sure how up-to-date it is
07:38:44 <MarcelineVQ> If they're actually short it's not really a big deal, so much time is being spent in correctLayer though, something seems off
07:38:58 <byorgey> diphtherial: I think it's plenty up-to-date.  It's pretty easy to get started with and great for building animations.
07:39:47 <Zenol> MarcelineVQ: `multM`, (+), (-) and fmap (*h) should by the costly functions. All the remaining stuff should'nt take time actually :/
07:39:48 * hackagebot cerberus 0.1.0.0 - Protect and control API access with cerberus  https://hackage.haskell.org/package/cerberus-0.1.0.0 (yogsototh)
07:39:55 <quicksilver> julianleviston: the names and stuff are in the M1 stuff
07:40:11 <Zenol> MarcelineVQ: Do you think that (-) and `multM` can build lot's of tunks and be the reason of all this memory usage?
07:40:46 <byorgey> diphtherial: the tradeoff is that the API + model are fairly simple, if you want to start doing moderately complex graphics it can get tedious to program
07:40:49 <julianleviston> quicksilver: It’s cool - I read on a bit… and I kind of get it more now. thanks :) I’m still not 100% sure this is what I need, but it’s at least a lot closer than I’ve come so far.
07:41:44 <diphtherial> byorgey: i see; i suppose at that point i can switch to something more robust. i'm learning haskell (slowly) as well, so maybe a simple model is better. thanks for the input!
07:42:02 <byorgey> diphtherial: yep, sounds good
07:42:33 <emmanuel_erc> Hello there everyone!
07:42:58 <byorgey> diphtherial: disclaimer/advertisement: I'm one of the developers/maintainers of http://projects.haskell.org/diagrams/ , which is much more complex/robust, but doesn't have as nice of a story for animation right now
07:43:12 <emmanuel_erc> How many of you guys would be interested in a Haskell library containing the most popular manifold learnig algorithms (similar to what sci-kit has)?
07:44:36 <MarcelineVQ> Zenol: I don't know :) I've not used a matrix lib or done a ton of profiling
07:44:45 <julianleviston> quicksilver: what I *really* want is data-“driven” types, and the ability to have other data “in” those types (but actually be in some kind of generic datatypes - THIS seems like a good fit for generics, perhaps), and have other code work with this data properly (so for example, a list of Integer is still a list of Integer). 
07:45:06 <quicksilver> idk what data-driven types are
07:45:25 <quicksilver> the haskell data type declaration language is powerful, you can encode all sorts of types
07:45:30 <Zenol> MarcelineVQ: I don't think it's related to the matrix lib at all. (-) and MultM behave as (-) and (*) for integers I think.
07:45:32 <julianleviston> quicksilver: I mean editable types.
07:45:32 <MarcelineVQ> If you're not getting a stack overflow then thunks probably aren't a big deal unless they're being garbage collected instead of used though
07:45:36 <quicksilver> note that JSON is a haskell type (Value) and that is semi-structured.
07:46:18 <Zenol> MarcelineVQ: I feel like layers {..} create a big list of thunk because this layer depend on the layer that depend on the layer ..... on the layer of the initial neural network.
07:46:49 <Zenol> MarcelineVQ: I'm getting stack overflow ^^
07:47:04 <Zenol> MarcelineVQ: If I go near 6 / 7 k pictures.
07:47:35 <Zenol> MarcelineVQ: so before I reach 2/10 of the whole dataset :(
07:49:03 <kadoban> https://github.com/commercialhaskell/stack/blob/master/src/Stack/Config.hs#L208 <-- this syntax … so it's basically using all of the values above to set the components of that record, magically? O.o
07:49:10 <kadoban> Or am I missing something?
07:49:17 <julianleviston> quicksilver: I have about 7 different groups of types that I want to work like this… and a bunch of data in those types… but I want a “general” editor for templates that use the data of these types, that can take any of these types and glue the data into the templates… 
07:49:19 <julianleviston> quicksilver: to do so involves a kind of matching path system which I’ve thought through (and should work fine - kind of recorded path traversal matching)… HOWEVER… I want to *keep* the structure of the types, and for the editor to allow the editing of the data in these types, so if a user plugs, say a “Route” into a hole in a template, it should provide the whole shape of what a “Route” is (ie its type)
07:49:52 <julianleviston> quicksilver: … to the template, so the template can know how to present it for editing and extending the data within (etc.)
07:50:49 <quicksilver> that does sound like ADT zippers
07:50:55 <julianleviston> quicksilver:  yeah?
07:50:58 <quicksilver> yes.
07:51:01 <julianleviston> quicksilver:  what are ADT zippers?
07:51:06 <julianleviston> quicksilver: generic zippers?
07:51:10 <quicksilver> zippers for abstract data types
07:51:15 <quicksilver> they don't have to be generic
07:51:19 <quicksilver> they can be entirely specific.
07:51:27 <julianleviston> quicksilver: ooh… can you point me at some learning material?
07:51:30 <quicksilver> You may find the specific ones easier to grasp (I do!)
07:51:33 <julianleviston> quicksilver: or should I just google
07:51:47 <quicksilver> the generic ones just abstract the details to work over all ADTs.
07:51:53 <byorgey> kadoban: yes.  See the RecordWildcards extension.   A good description is here: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
07:51:57 <quicksilver> that's what I was trying to show you in that screenshot.
07:52:23 <julianleviston> quicksilver: the screenshot of the pattern thingie?
07:52:56 <quicksilver> yes.
07:53:08 <quicksilver> that was editing a nested mutually recursive set of ADTs
07:53:17 <quicksilver> and presenting the right kind of 'editor widget' for the selected level
07:53:30 <quicksilver> so you could edit integers, or colour sliders, or add new filters in the chain.
07:53:32 <julianleviston> quicksilver: oh neat.
07:53:44 <julianleviston> quicksilver: that’s almost exactly what I want to do.
07:53:50 <quicksilver> right, that's what I thought :)
07:53:55 <julianleviston> quicksilver: haha :) sorry!
07:54:01 <quicksilver> maybe you'll find some of the discussion here useful - http://stackoverflow.com/questions/12067084/haskell-zipper-for-adt-with-many-constructors
07:54:25 <julianleviston> quicksilver: ? http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/
07:54:33 <julianleviston> quicksilver: ah ok. Thanks. I’ll check it out.
07:54:40 <quicksilver> that one doesn't go much into the details
07:54:44 <quicksilver> the one you posted
07:54:51 <quicksilver> it's more about the theory fo doing it generically.
07:55:17 <quicksilver> https://en.wikibooks.org/wiki/Haskell/Zippers has an example or two
07:55:28 <lyxia> kadoban: it fills each field by finding a variable in scope with the same name
07:56:13 <Zenol> MarcelineVQ: That's make me very sad because it's unusable if I can't even apply it to a small set of 60k entries...
07:58:19 <kadoban> byorgey: lyxia: Thanks. I guess it makes sense now.
08:01:17 <julianleviston> quicksilver: there are two answers - one is by Gabriel… did you mean that (free monads) or the generic zipper / lenses one?
08:07:34 <julianleviston> I don’t really understand eitheir of them. :( what is (:~>) ?
08:07:51 <julianleviston> e.g. unaryOp :: Tree :~> UnaryOp
08:12:21 <Zenol> I'm about to give up and rewrite it in an other language :/
08:13:41 <julianleviston> Zenol: seems a bit overkill. Can’t you just pull your functions into smaller pieces, and performance test them individually and work out the bottlenecks?
08:14:39 <mmachenry> Zenol: What's the performance issue?
08:15:17 <Zenol> julianleviston: That's what I'm doing, bot none of the functions are slow except the one which use all the others, which has the higher use of memory and time, and I don't see what's wrong with it :(
08:15:27 <julianleviston> mmachenry: s/he’s doing a neural network processor of sorts, and it’s to do with some 60,000+ point data sets (that’s a small one)
08:15:40 <julianleviston> Zenol: maybe mmachenry can help you
08:15:45 <Zenol> mmachenry: Too slow with small data set, and stack overflow with biggers.
08:16:24 <julianleviston> Zenol: you might need to link him/her to your source, again.
08:16:25 <mmachenry> I'm reading the logs of this chat. 
08:16:29 <Zenol> mmachenry: It's an implementation of the backpropagation algorithm. It's mostly computing linear algebra. But something is allocating a lot's of memory, and taking a lot's of time, and I can't figure out what and where :/
08:16:48 <Zenol> mmachenry: Here is the hp profiling : http://zenol.fr/Main.pdf
08:17:00 <Zenol> mmachenry: The sources can be foudn here : https://github.com/Zenol/hwcr/blob/master/NeuralNetwork.hs
08:17:19 <Zenol> mmachenry: The cost center is correctLayer inside of learn.
08:17:47 <Zenol> mmachenry: And the lists like [layer] or omegaList or deltaList are of size beetween 2 and 4.
08:18:23 <emmanuel_erc> Zenol: Have you used the -hy or -hT flags? Either flag will give you information about which constructors or types are being thrown on the heap!
08:18:31 <emmanuel_erc> That might serve you better.
08:18:50 <Zenol> emmanuel_erc: O.O Didin't know that. I try.
08:18:58 <julianleviston> Zenol: how are you running it?
08:19:18 <Zenol> julianleviston: ? When profiling? Main.exe +RTS -p -hc
08:19:31 <julianleviston> Zenol: just checking you weren’t running it in GHCi
08:19:43 <Zenol> julianleviston: Oh, ok.
08:20:58 <mmachenry> Zenol: I need to watch a presentation. I'm in a meeting. I will potentially look later. Good luck though.
08:21:16 <mmachenry> Any place you see the bar continue to get wide, however, is suspect.
08:21:35 <mmachenry> Like learn.correct
08:21:35 <Zenol> mmachenry: Ok, thanks you. Yes, so two functiona re suspect. I'll look at types.
08:22:05 <julianleviston> Zenol: I suggest you split the functions out of the where clause… at least temporarily.
08:22:05 <Zenol> mmachenry: If i'm back here tomorow, it means I didn't found any solution x)
08:22:24 <Zenol> julianleviston: That's note that easy because some of them use op to 8 or 9 parameters.
08:22:25 <julianleviston> Zenol: then your perf metrics might look a little different, no?
08:23:01 <Zenol> julianleviston: Nop, didn't changed at all after breaks. I mean, some number changed of course, but the order is always the same.
08:23:11 <julianleviston> Zenol: huh?
08:23:31 <julianleviston> Zenol: I mean if you pull them out, you’ll see which parts of correctLayer are causing problems, won’t you?
08:24:59 <julianleviston> Zenol: it seems to be the layer function within correctLayer that’s causing the problem, is that right? AM I reading that right?
08:25:14 <Zenol> julianleviston: Yes
08:25:20 <julianleviston> Zenol: what *is* that function?
08:25:31 <julianleviston> Zenol: it’s from layers net, right? 
08:25:46 <Zenol> julianleviston: data Network a = Netowrk {layers : [Layer a]}
08:26:12 <julianleviston> hm
08:26:17 <Zenol> julianleviston: I'm just ""replacing" the layer list of net by the new list.
08:26:44 <julianleviston> but the layer function … I’m confused.
08:26:51 <Zenol> (Since haskell is inmutable, I'm actualy doing a copy, but ghc should notice that the previous network is throw away)
08:27:15 <julianleviston> oh… that layer there is a data constructor
08:27:26 <mmachenry> Zenol: Since Haskell is immutable, you never need to do a copy. 
08:27:34 <Zenol> julianleviston: You mean the word "layr" ? it's a layr, of type Layer a.
08:27:41 <julianleviston> no layer
08:28:12 <julianleviston> Zenol: line 56: correctLayer (omega, beta, layer) = layer
08:28:26 <Zenol> mmachenry: I don't explicitely. I mean that thing {stuff = newstuff} can be a copy or a mutation when compiled, depending on how it's used.
08:28:45 <exio4> Zenol: net `seq` net { ... } is pretyt much useless :P 
08:29:08 <Zenol> exio4: yep, actualy it make it worst. Just forget to remove it in the last commit I did.
08:29:10 <julianleviston> Zenol: layer there is a piece of data of type Layer that you’re changing the fields of...
08:29:24 <exio4> Zenol: if you want to add strictness, use ! on data definitions
08:29:35 <julianleviston> Zenol: I wonder if field updating is slow…
08:30:02 <Fuco> in haskell everything is slow so that question solves itself
08:30:14 <Zenol> exio4: Actualy adding strictness in data type doesn't help that much (yes I tried it) :/
08:30:15 <exio4> Zenol: foldl' is also forcing the (,) constructor, not the `things` inside it
08:30:23 <exio4> Zenol: so you might want to add ! there?
08:30:29 <exio4> Zenol: do you have test data?
08:32:54 <exio4> like, data big enough to show noticeable slowdowns? 
08:32:58 <Zenol> exio4: You mean in forward? You are right, you think I should force the things inside ?
08:33:13 <Zenol> exio4: What do you call test data?
08:33:17 <Zenol> exio4: Profiling?
08:33:51 <Zenol> exio4: Like http://lpaste.net/147285 http://zenol.fr/Main.pdf ? ^.^
08:33:55 <exio4> Zenol: no, parameters for the functions you want to profile
08:34:33 <Zenol> exio4: Yes. See in main, the whole code is just reading and feeding the data to test the NeuralNetwork module.
08:34:36 <exio4> oh
08:35:02 <Zenol> exio4: (Yes there is a bit of computation to load the data :s)
08:36:06 <Zenol> Hum, I'm late. I have to take a shower and go to my lesson. I'll think about since I come back.
08:36:21 <exio4> \o 
08:36:22 <Zenol> Thanks for your help guys, hope I'll find out what's happening.
08:37:36 <mmachenry> Zenol: Which of these functions are called if you call the first one. learn.correctlayer
08:37:39 <mmachenry> All of them?
08:37:43 <mmachenry> Probably not main
08:42:04 <mmachenry> Zenol all that list reversing is potentially an issue.
08:42:15 <mmachenry> You might be better off with a different data structure. 
08:43:46 <frankier> Is there any way I can get a view on a bytestring without copying it?
08:44:14 <maerwald> do you guys still use 2 spaces for indenting? I am starting to feel 4 is better, at least if you have a lot of imperative-style code
08:44:15 <frankier> To be clearer, I mean a slice
08:45:02 <mpickering> how can I make sure that file handles get closed when reading a file?
08:45:17 <julianleviston> mmachenry: hehe that was the very first thing I suggested, about 4 hours ago.
08:45:52 <frankier> mpickering, If you read the last byte of the lazy bytestring it will get closed
08:46:23 <mpickering> I don't understand why there are not strict versions of these functions in base..
08:46:28 <frankier> So you can use toStrict
08:46:37 <mpickering> what's the recommend way to force it these days? 
08:46:43 <mpickering> toStrict from?
08:46:51 <exio4> use strict datatypes
08:46:53 <frankier> Data.ByteString.Lazy.toStrict
08:47:02 <mmachenry> julianleviston: I get up much later in the morning ;)
08:49:03 <diphtherial> it seems that whatever version of the haskell platform i have is incompatible with gloss, unfortunately
08:49:38 <diphtherial> https://dpaste.de/sVR0
08:50:34 <diphtherial> should i go ahead and --force-reinstalls?
08:51:59 <glguy> diphtherial: You should rarely force reinstalls. You should unregister libraries instead of breaking them
09:00:51 <DarkGhost> Hey Mathu! what a suprise see you here!
09:01:14 <byorgey> diphtherial: you should at least try using a cabal sandbox
09:02:45 <diphtherial> sounds good to me; i'm entirely open to suggestions
09:02:48 <diphtherial> i'll look that up
09:03:10 <diphtherial> i'm guessing they're analogous to python's virtualenvs?
09:04:01 <hiptobecubic> diphtherial, yes.
09:08:42 <diphtherial> i've created a sandbox, but i'm not really sure what to do from here; should i use that force-reinstall option now?
09:09:01 <diphtherial> apologies for all the naive questions -- i can figure this out on my own if it's inappropriate to ask here
09:10:21 <glguy> diphtherial: The problem is that you installed Haskell Platform which installs an arbitrary set of libraries globally, these global libraries are available in sandboxes, too
09:12:00 <diphtherial> glguy: ok, that makes sense. should i just remove the platform and install the minimal ghci, then, or is there perhaps a way to create a sandbox that doesn't use the global libraries...?
09:13:22 <glguy> You can unregister the libraries that you don't want installed globally: ghc-pkg unregister library-0.1
09:13:55 <glguy> that's probably faster than downloading a new copy of GHC
09:19:26 <diphtherial> i'm not sure where to start with unregistering libraries...i'm guessing i'd have to unregister the opengl one since it'd apparently get broken if i were to install gloss?
09:20:12 <diphtherial> or do i have to unregister all of the libraries that cabal mentioned would be reinstalled?
09:21:13 <dcoutts> diphtherial: in principle no, broken things are just ignored
09:21:22 <kadoban> diphtherial: Look into using 'stack' instead of cabal sometime. It's … much easier and safer for stuff like this.
09:22:13 <dcoutts> or help test the new cabal nix style branch :-)
09:22:26 <diphtherial> fwiw, i'm almost completely new to haskell; i'm barely comfortable importing things outside of Prelude, heh
09:23:39 <diphtherial> ok, so i gather that i should somehow remove the haskell platform and install stack...? i'm on OS X if that makes any difference
09:23:56 <kadoban> diphtherial: cabal and the haskell platform are kind of funky, pretty much for the reason you're seeing. Once you go outside of the platform, you're on your own (and there's mines everywhere). You can kinda do something sane with sandboxes, but it's tedious and fragile. stack is a better tool
09:24:12 <kadoban> diphtherial: I would, yes.
09:24:28 <dcoutts> diphtherial: people have different opinions on these things
09:25:03 <dcoutts> diphtherial: the other simple approach is: cabal sandbox init; cabal install $the-things-you-want
09:25:23 <dcoutts> and it'll not change the things you've got in your user-wide environment
09:28:20 <mpickering> if I have (force -> file) <- readFile fpath then should the file not get closed immediately?
09:31:34 <geekosaur> mpickering, looks like you need a bang pattern, otherwise force itself is not forced?
09:31:44 <geekosaur> (force -> !file) <- readFile fpath
09:34:17 <mpickering> thanks geekosaur, I will try it out
09:34:51 * hackagebot buffer-builder 0.2.4.1 - Library for efficiently building up buffers, one piece at a time  https://hackage.haskell.org/package/buffer-builder-0.2.4.1 (chadaustin)
09:44:52 * hackagebot niagra 0.0.2 - CSS EDSL for Haskell  https://hackage.haskell.org/package/niagra-0.0.2 (natesymer)
09:46:24 <glguy> file <- evaluate . force =<< readFile fpath
10:01:11 <diphtherial> ok, think i have things going decently in stack now; i was able to launch the interpreter, at least, but i haven't attempted to install gloss yet
10:01:33 <diphtherial> on a complete tangent, and just out of curiosity, what type is 'error'? ghci informs me it's of type t
10:02:22 <kadoban> diphtherial: Pick any type, and 'error "blah"' is of that type. It's a value of all types.
10:02:34 <Cale> :t error
10:02:36 <lambdabot> [Char] -> a
10:02:58 <Cale> If your program dies, it doesn't matter what the type of the result is :)
10:02:58 <diphtherial> i eat my words; neat, thanks
10:03:21 <kadoban> It's both pretty cool and pretty terrible, depending.
10:03:35 <bergmark> also see `undefined`, and `f = f`
10:03:39 <Cale> You should generally never use error to indicate any sort of failure that you might want to recover from.
10:03:56 <Cale> If going into an infinite loop would be acceptable, then error is probably a little better than that.
10:04:09 <diphtherial> right, that makes sense
10:18:55 <Javran> http://lpaste.net/3957943913817309184 any idea why in this case isInstance cannot find Typeable of Char?
10:20:58 <Cale> Javran: try doing  :info Char  and seeing if you see an instance
10:22:08 <Javran> Cale: ah, Typeable is not in the list
10:23:27 <Cale> Which is interesting, because it's clearly an instance somehow.
10:24:10 <cocreature> :i Typeable doesn’t show any instance at all
10:24:19 <cocreature> is Typeable maybe special here?
10:24:33 <Cale> Yes, Typeable is definitely special.
10:25:05 <Cale> However, I'm still a bit surprised that GHC isn't able to list instances.
10:25:40 <Cale> You're not allowed to explicitly write instances of Typeable any more, because doing so made it a little too easy to break the type system.
10:25:58 <Javran> back to base-4.7.0.2 I can see Typeable instance under Char, but not the case in base-4.8
10:26:06 <Cale> right
10:26:43 <Cale> I would expect to see a list of the types for which Typeable had been derived at least.
10:29:06 <Cale> reifyInstances/isInstance is really kind of an awkward interface for what you'd usually want to do, which is checking whether or not some constraint would be satisfied.
10:29:27 <Cale> I wonder if there's anything better hanging around somewhere already.
10:30:23 <mmachenry> Zenol: Are you still here?
10:32:44 <Cale> (all that isInstance does is reifyInstances, and then check if the list of instances returned is nonempty)
10:41:39 <lingxiao> hey all
10:41:51 <lingxiao> what's the best library to find the meidan of some arbitrary containter t
10:42:02 <lingxiao> so median :: (Constraint a) => t a -> a 
10:42:13 <lingxiao> Im using Seq a at the moment
10:44:38 <maerwald> I wonder if it makes sense to model file operations (like copy) with the continuation monad, because I have a (possibly infinite) delay between the user selecting the source and destination file. But I still want to be able to treat a file operation as something atomic that I can pass around functions.
10:47:41 <maerwald> I currently have something like this http://lpaste.net/147289 but I don't like it
11:00:38 <johnw> joeyh: ping
11:01:31 <lingxiao> pong
11:01:38 <lingxiao> oh opse sorry not to me sorry
11:06:46 <johnw> lingxiao: at least you share the letter 'o' in common :)
11:07:10 <lingxiao> haha i have 4 out of 5 vowels in my name so lol!
11:07:21 <lingxiao> or 3/5
11:07:52 <cir0x> Hey! I´m trying to get all remainder between a specific range mod 5. My approach is something like this: filter (mod 5 == 3) [1..100]. Any ideas?
11:08:45 <norw> hello everyone, can you help me with this error please?
11:08:46 <norw> http://lpaste.net/147291
11:10:15 <johnw> norw: getpoints has the wrong type; you could try concatMap, but it may not be what you mean
11:10:19 <hxegon> anyone have enough experience with python vs haskell cuda to tell me if one is much better or worse?
11:12:35 <MitchellSalad> cir0x: are you getting a syntax error, or wondering if there's a more efficient version?
11:14:45 <cir0x> MitchellSalad: I´m getting an an syntax error. I´m trying to create an one liner to help me with some math homework
11:15:34 <MitchellSalad> cir0x: ah. are you familiar with lambda syntax, aka anonymous functions?
11:16:55 <kadoban> cir0x: filter (\x -> x `mod` 5 == 3)  or filter ((==3) . (`mod` 5)) or filter ((==3) . (flip mod 5))
11:16:58 <cir0x> MitchellSalad: Yes, a little bit, because java 8 has now lambdas :). I'm coming from java and thought haskell would be the better approach for my problem
11:17:58 <MitchellSalad> cir0x: well, see kadoban's solution above, and I'd ignore the code-golfed versions
11:18:23 <MitchellSalad> "filter (\x -> x `mod` 5 == 3) [1..100]" is what you want
11:18:42 <ClaudiusMaximus> cir0x: there are also list comprehensions, like [ x | x <- [1..100], x `mod` 5 == 3 ]
11:18:51 <kadoban> I don't think any of those are really golfy, to be honest, but the first is likely to be the most understandable for a newer haskeller probably.
11:18:56 <norw> johnw OH MY GOD this is exactly what i was trying to do hor DAAAYS
11:19:06 <norw> johnw I love you
11:19:24 <norw> concatMap is exactly what i needed. tytyty
11:19:38 <MitchellSalad> they're pretty golfy, IMO. i used to write code like that, then read a michael snoyman blog post about how he used to write code like that, and now I prefer the more readable version
11:21:09 <johnw> MitchellSalad: why is that a reason not to use the list comprehension?  It's clearer in this case
11:21:39 <MitchellSalad> no, I'm arguing against the "filter ((==3) . (`mod` 5))" version
11:21:45 <johnw> ah
11:22:02 <hiptobecubic> composed sections is pretty ugly
11:22:08 <hiptobecubic> or are, rather
11:22:14 <exio4> (==3) . (`mod` 5) isn't -that- bad 
11:22:34 <MitchellSalad> is it better than \x -> x `mod` 5 == 3?
11:22:47 <hiptobecubic> Clearly not.
11:22:58 <exio4> they're equivalent!
11:23:04 <MitchellSalad> dunno, seems to still be up for debate. it's style, after all
11:23:06 <hiptobecubic> exio4, a lot of things are equivalent.
11:23:08 <kadoban> To me it's basically identical, I can read both just as easily (and I don't think they have any differences otherwise).
11:23:16 <Guest00000> hello
11:23:25 <kadoban> I tend to do the point-less way more ofter I'd guess.
11:23:44 <cir0x> MitchellSalad, kadoban, ClaudiusMaximus thanks a lot. I would prefer atm [ x | x <- [1..100], x `mod` 5 == 3 ], because its quite  familiar from the lectures...
11:24:28 <MitchellSalad> here's another: do { x <- [1..100]; guard (x `mod` 5 == 3); pure x }
11:24:52 <lingxiao> hey does any one know of a library that computes median over some traversable?
11:24:58 <Guest00000> i have: data X c a where X :: c => a -> X c a
11:25:17 <lingxiao> my instance of Data.Sequence but anything will do!
11:25:22 <lingxiao> *should o*
11:25:28 <johnw> lingxiao: type of the function you want?
11:25:41 <lingxiao> median :: (Traversable t) => t a -> a
11:25:47 <Guest00000> i want to write an instance: instance Applicative (X ???) where ....
11:25:49 <lingxiao> Presumably we'd have Ord a in constraint as well
11:26:24 <lingxiao> hayoo is no good
11:26:49 <lingxiao> ditto hoogle
11:26:54 <Guest00000> ah i mistyped, i meant: data X c a where X :: c a => a -> X c a
11:27:21 <Guest00000> and i want to write: instance Applicative (X ???) where ...
11:27:36 <Guest00000> ??? should have kind * -> Constraint
11:27:53 <johnw> lingxiao: do you mean: \x -> case toList x of [] -> error "??";  xs -> xs !! (length xs / 2)?
11:27:58 <johnw> that kind of median?
11:28:12 <lingxiao> yeah pretty much
11:28:12 <Guest00000> i want the ??? to return the null constraint for any argument
11:28:24 <Guest00000> what do i do? how do i write the ???
11:28:30 <lingxiao> but i dont want to use to list
11:28:34 <lingxiao> toList*
11:28:46 <MitchellSalad> Guest00000: do you have a functor instance?
11:28:55 <lingxiao> I mean i have one working right now but it seems like something so common there is a *best* library function
11:29:24 <johnw> lingxiao: but your "median" is defined as the "middle" of a view of the traversable as a linear sequence, so toList is part of your definition basically.  Otherwise, what is the "median" of a n-ary tree?
11:30:03 <lingxiao> how is Data.Sequence implemented?
11:30:23 <lingxiao> I should take  a look haha
11:30:25 <Guest00000> MitchellSalad: for X? yes
11:30:37 <lingxiao> but yeah johnw what youure saying makes sense, i'm just trying to "not roll my own"
11:30:38 <johnw> "The implementation uses 2-3 finger trees annotated with sizes"
11:30:46 <MitchellSalad> what's it look like?
11:30:54 <athan> lingxiao: Wait wait wait... did someone say medians?
11:30:56 <lingxiao> ahh ok
11:31:01 <lingxiao> athan haha yeah
11:31:06 <athan> Are you trying ot make a generic median finding function?
11:31:10 <Guest00000> uh
11:31:13 <lingxiao> im looking for one
11:31:21 <lingxiao> if not i might have to describe a class of behavior
11:31:23 <athan> I made a pretty simple heap structure if that helps, one sec
11:31:33 <lingxiao> some set where mean median is defeined
11:31:40 <lingxiao> oh ok great!
11:31:42 <Guest00000> .... nevermind, I don't
11:31:48 <MitchellSalad> :)
11:31:55 <Guest00000> let's say i want Functor, not Applicative.
11:32:20 <athan> er no it's not a heap, it's a zipper with multimaps, but yeah
11:32:22 <athan> https://github.com/athanclark/median-set :)
11:32:31 <athan> it's got terrible asymptotics though
11:33:22 <athan> lingxiao: To find the median of a collection, it's pretty simple - first _sort_ the collection, then get the element at the half-way point
11:33:28 <athan> so that would be `length xs / 2`
11:33:35 <athan> er `div`
11:33:54 <athan> but using medians in a streaming scenario is a bit more tricky :)
11:34:14 <lingxiao> so this is O(1) for median ?
11:34:17 <athan> mean is easy because at each element you just add to the total, and when you're done you divide by the count
11:34:26 <athan> but median is shifty
11:34:33 <lingxiao> what is it for insetion ... and theres no dleetion right?
11:34:48 <athan> lingxiao: right, there's no deletion
11:34:53 <athan> for this strcutre anyway
11:35:01 <lingxiao> how is  a MultiSet implmented
11:35:04 <athan> it's O(1) in fetching the "median so far", basically
11:35:16 <MitchellSalad> Guest00000: Guest00000: I'm not sure you can write a functor instance
11:35:28 <MitchellSalad> you can write some similar mapping function, though
11:35:32 <lingxiao> I;ll look taht up too haha
11:35:41 <MitchellSalad> map :: c b => (a -> b) -> X c a -> X c b
11:35:41 <athan> I didn't write that one, but I'm thinking it's a normal Set with a count
11:35:43 <lingxiao> see i have an aversion to docs that's unhealthy
11:35:49 <athan> hahaha
11:36:00 <Welkin> aehuaehuaehuaehu
11:36:02 <lingxiao> lol thanks athan I'll take a closer look to your code
11:36:04 <athan> but the insertion is terrible
11:36:06 <athan> np :)
11:36:17 <lingxiao> yup! :) 
11:36:30 <Welkin> athan, how indecent
11:36:35 <Welkin> exposing your code to strangers
11:36:38 <athan> lingxiao: http://htmlpreview.github.io/?https://github.com/athanclark/median-set/blob/master/profile.html
11:36:53 <athan> Welkin: Nobody messes with my kitties O_O
11:37:54 <athan> I really want to make an approximate median heap with linear asymptotics, but not sure how I'd staple it together
11:37:56 <athan> meh
11:38:07 <Guest00000> oh well.
11:38:10 <lingxiao> https://i.imgur.com/89HANHgh.jpg
11:38:40 <athan> =U
11:38:52 <lingxiao> sorry what's =U
11:39:03 <Welkin> a U-Haul storage unit
11:39:12 <lingxiao> lol 
11:39:59 <maerwald> does anyone know how I can model a file operation which may be a partially applied function or not? http://lpaste.net/147292 this is sort of my starting point. Then I want to save the FileOperation inside an IORef or TVar, but I do not know beforehand if it's of type "FileOperation" or "FilePath -> FileOperation". Anything else I can think of is dirty use of Maybe
11:40:04 <lingxiao> btw if anyone remebmers i was struggling with this interface, but i finally figured it out:
11:40:04 <lingxiao> http://stackoverflow.com/questions/34327146/run-this-monadic-computation-with-notion-of-state-and-randomness
11:40:42 <norw> Ok guys how do I make ghc accept this: [(Float,Float),(Float,Float)]
11:40:55 <norw> Illegal type: '[(Float, Float), (Float, Float)]       Perhaps you intended to use DataKinds
11:41:02 <lyxia> [(Float,Float)]
11:41:16 <athan> norw: You've got a quote there
11:41:21 <athan> take out the quote :)
11:41:33 <MitchellSalad> athan: no :P
11:41:35 <exio4> athan: that quote might be auto-added
11:41:38 <lingxiao> woa what's this: [(Float,Float),(Float,Float)]
11:41:42 <athan> whurt
11:41:49 <athan> oh derp
11:41:50 <Welkin> that is not legal
11:41:51 <norw> athan that quote is from the command line :) I'll try using [(Float,Float)]
11:41:51 <Welkin> lol
11:42:04 <lingxiao> i wonder how you'd interpret that even
11:42:05 <exio4> well, it is a list of types
11:42:10 <Welkin> that one is barely legal
11:42:15 <norw> welkin I was thinking ahead of myself, I should have used [(Float,Float)]
11:42:16 <Welkin> scandalous
11:42:25 <exio4> :k '[Int]
11:42:27 <lambdabot> [*]
11:42:29 <athan> :|
11:42:34 <exio4> :k '[Maybe, Either String] 
11:42:36 <lambdabot> [* -> *]
11:42:44 <norw> hey guys I've only 2 months experience don't hurt me ;_;
11:42:44 <exio4> :k '[Functor, Applicative, Monad]
11:42:45 <lambdabot> [(* -> *) -> Constraint]
11:42:51 <Welkin> type-level list
11:43:08 <lyxia> maerwald: what's the problem with Either FileOperation (FilePath -> FileOperation) ?
11:44:23 <lingxiao> norw : norw all good there's an infinite amount of stuff to learn so everyone is lost in their own way :)
11:44:28 <maerwald> lyxia: it's not really generic
11:44:34 <maerwald> and might not do what I expect it to in the future
11:44:39 <lingxiao> exio4 how do you use this: [Maybe, Either String]
11:45:02 <maerwald> I really need some sort of "hole" that says "this can be a FileOperation at some point, but it might currently be not"
11:45:14 <norw> now why is this failing -->  getmin : getmax : [] getmin and getmax are (Float,Float)
11:45:58 <kadoban> norw: How's it failing? It's better if you lpaste errors
11:46:06 <norw> I'll do it
11:46:25 <maerwald> I think the only way here might be the continuation monad, but I'm not sure
11:46:56 <lingxiao> or a term of this type ... 
11:47:24 <norw> kadoban http://lpaste.net/147291
11:48:33 <kadoban> norw: getmin and getmax aren't the type you mentioned
11:48:51 <Welkin> smelly: what a name
11:49:10 <smelly> there's a story there
11:49:21 <kadoban> norw: They're [(Float, Float)] -> (Float, Float), not (Float, Float)
11:49:42 <Sonolin> anybody here with xmonad experience want to help me understand this code?
11:49:44 <Sonolin> http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Layout-NoBorders.html#smartBorders
11:49:57 * hackagebot containers 0.5.7.0 - Assorted concrete container types  https://hackage.haskell.org/package/containers-0.5.7.0 (MilanStraka)
11:49:58 <norw> kadoban I don't understand
11:50:14 <Sonolin> in "instance SetsAmbiguous Ambiguity where" block
11:50:38 <Sonolin> looks like OtherIndicated is supposed to hide borders on multi monitor setups but its not working :(
11:50:52 <norw> kadoban I changed the code to [getmin] ++ [getmax] still not working. but in console [(1,1)] ++ [(2,2)] is, and gives me [(1,1),(2,2)] which is [(Float,Float)]
11:50:54 <athan> Does scanl carry the same caution aired around it as foldl? (compared to foldr I mean)
11:51:35 <kadoban> norw: 5 :: Int <-- that's an Int.      add 5 :: Int -> Int, that's a function that, given an Int, will give you an Int. They're not the same type. getmin is type [(Float, Float)] -> (Float, Float), and you're pretending it's type (Float, Float)
11:52:19 <kadoban> norw: I'd suggest a fix, but I don't really know what you're trying to do there necessarily :-/
11:52:22 <geppettodivacin> athan: Which caution? That it is too lazy or too strict?
11:52:25 <norw> so getPoints :: Picture -> [(Float,Float)] is of the type Picture -> [(Float,Float)] and not [(Float,Float)] too?
11:52:58 <ReinH> norw: yes, if a thing is of type a -> b, it is not of type b
11:52:59 <kadoban> norw: Yes, though you don't appear to be using that one incorrectly, that I'm seeing.
11:53:30 <norw> kadoban I take a list like [(20,0), (10,25)] and get 2 pairs, one with the smallest points and 1 with the biggest, in this case [(10,0),(20,25)]
11:53:47 <norw> kadoban the list can be any size
11:54:17 <kadoban> norw: That sounds like getPointsAux xs = [getmin xs, getmax xs]
11:54:48 <norw> kadoban i think I found the problem
11:54:58 * hackagebot ghc-parmake 0.1.9 - A parallel wrapper for 'ghc --make'.  https://hackage.haskell.org/package/ghc-parmake-0.1.9 (MikhailGlushenkov)
11:55:20 <norw> i forgot to do exactly that, to give something for getmin and getmax to work with. i feel embarrased even :b
11:55:59 <kadoban> norw: It happens :)
11:56:10 <norw> kadoban thanks for the help :)
11:56:21 <norw> it works as intended now 
11:56:34 <kadoban> norw: Note that the error message suggests this, just in case you didn't notice: "Probable cause: `getmin` is applied to too few arguments"
11:57:05 <kadoban> I point that out not to be a dick, but because lots of people think of error messages as useless, coming from some other languages. Here they (at least sometimes) actually tell you something useful.
11:57:09 <norw> Yeah normally that error is easy to fix, i don't know how I didn't see it. Thanks!
11:57:17 <kadoban> 'welcome
11:57:26 <athan> geppettodivacin: In that left folds are usually too lazy
11:57:26 <athan> also holy crap - `#.` is this strict / unboxed composition?
11:58:24 <athan> I'm seeing it used in base
11:58:45 <geppettodivacin> athan: scanl should be only as strict as you make use of its elements.
11:59:01 <lingxiao> norw : for a long time my immediate reaction to eror messages is command-l
11:59:02 <Zenol> hi back
11:59:08 <athan> ahh it's a coercive composition, so it's unsafe
11:59:09 <lingxiao> or ctrl-l
11:59:16 <Guest00000> map ($ xs) [getmin, getmax]
11:59:23 <athan> geppettodivacin: Thank you :)
11:59:29 <lingxiao> but now im learning to use it to my advantage 
11:59:29 <Zenol> mmachenry: The list you are talking are made of 2 to 4 items. And actuly won't be bigguer than 10 in all the realistic use case.
11:59:30 <geppettodivacin> You're welcome!
11:59:31 <Guest00000> ^_^
11:59:48 <Zenol> mmachenry: (Training deep network is really hard, I mean, the speed of convergence).
12:00:12 <kadoban> lingxiao: What's ctrl-l, out of curiosity?
12:00:24 <lingxiao> clears my console
12:00:29 <kadoban> Ah
12:00:34 <Zenol> mmachenry: All the functions that was belongong to learn, that I moved out. So actually all the functions above learn in the file. Alors forward wich made a forward pass.
12:00:36 <ReinH> Guest00000: which is both longer and more conceptually complex than [getmin xs, getmax xs]
12:00:39 <lingxiao> yup
12:00:49 <Zenol> mmachenry: *was belonging to
12:00:51 <geppettodivacin> Is there any preference for how to apply a list of functions to a single value?
12:00:54 <kadoban> Zenol: I read a paper the other day about somebody training a deep NN to play go … still kind of scared by that.
12:01:01 <geppettodivacin> I could do it either as an applicative or as a map.
12:01:05 <ReinH> geppettodivacin: map ($ x)
12:01:27 <ReinH> is what I usually see
12:01:28 <Zenol> kadoban: How deep? ^^ I'd like to see that paper :)
12:01:43 <geppettodivacin> ReinH: I had been doing that, but I always thought it looked weird because the argument comes before the functions.
12:02:08 <geppettodivacin> ReinH: Is there any reason not to do it as `functionList <*> pure argument`?
12:02:10 <ReinH> geppettodivacin: xs <*> pure x is the generaliation in Applicative, but I don't see it very often
12:03:04 <ReinH> depending on optimization, it *may* allocate a length xs list of x's, which would be less efficient.
12:04:00 <ReinH> well, it may allocate the cons cells. Laziness would prevent allocating the entire list up front.
12:04:02 <lingxiao> >:t ($)
12:04:10 <lingxiao> >:t $
12:04:15 <Welkin> :t ($)
12:04:16 <lambdabot> (a -> b) -> a -> b
12:04:19 <Welkin> no >
12:04:31 <lingxiao> ahhh ... haha
12:04:47 <kadoban> Zenol: Hmm … I can't find it in my logs. I thought it was in #go, but maybe it was elsewhere. I'll send it your way if I find it. IIRC it was pretty crazy deep, like 13 hidden levels or something. I have no idea how real it was, it sounded vaguely ridiculous to me, but the results they claimed were almost incredible.
12:04:56 <Cale> (It probably will allocate the cons cells)
12:05:01 <geppettodivacin> Thanks, ReinH!
12:05:47 <Zenol> kadoban: All researchers that have to sell their result clame they are incredible. The ones wo don't made that clame are the one you can trust. The other... ^^
12:06:04 <mpickering> can anyone suggest a package with a high number of exported symbols and a low number of dependencies?
12:06:18 <shock_one> Hello. I've been studying Haskell for a while now, and one thing doesn't stop worrying me: isn't bottom the same kind of trick as null?
12:06:26 <Welkin> snake oil for sale! get yer freshly squeezed snake oil! Right here! Step up on up! :D
12:06:33 <ReinH> shock_one: no. Nulls are preventable. 
12:06:37 <ReinH> nontermination is not.
12:06:39 <kadoban> Zenol: Yeah, I got to the end and wasn't sure if I believed it or not … but unless they straight-up lied it was pretty amazing stuff.
12:06:45 <ReinH> Every turing complete language has bottoms.
12:06:48 <ReinH> Some have nulls.
12:07:00 <shock_one> ReinH: but as I've heard, Agda, for example, guarantees termination.
12:07:10 <ReinH> So the questino is really: do you want nulls and bottoms, or just nulls.
12:07:25 <ReinH> shock_one: total languages can guarantee bottom, but they are necessarily not turing complete
12:07:36 <ReinH> er, "do you want nulls and bottoms, or just bottoms"
12:07:39 <kadoban> shock_one: Yes. In that sense it's not turing complete. Turns out that's not as important as it was once assumed to be.
12:07:58 <kadoban> shock_one: But in practice agda seems pretty fun to play with, but I don't think I'd want to actually … get stuff done in it.
12:07:59 <ReinH> shock_one: So do you want the full power of a turing complete language, or do you want a total language? You can pick one.
12:08:18 <ReinH> If you want a turing complete language, you will necessarily have bottoms
12:08:32 <ReinH> So "bottoms are like nulls" is not fair comparison
12:08:37 <shock_one> ReinH: Why do I want a turing complete language?
12:08:43 <ReinH> because the languages that have nulls *also* have bottoms
12:08:51 <ReinH> shock_one: recursion is pretty useful
12:09:06 <davean> shock_one: Because without one theres definately soemthing you can't do with it
12:09:20 <shock_one> ReinH: accepted (you surely know that Agda has recursions on subsets of input); what else?
12:09:48 <kadoban> shock_one: As for your direct question … it's different for two reasons that come to mind: 1) There's better ways to model it in haskell, which are commonly used, so you're not tempted to just use "error" everywhere 2) The community will make fun of you if you do.
12:10:00 <ReinH> shock_one: general recursion is what I mean
12:10:58 <kadoban> shock_one: And I guess a 3rd: getting rid of it is … pretty difficult. Dependently typed languages that let you rule it out are cool, but so far not all that practical, AFAIK.
12:12:41 <ReinH> kadoban: it's easy if you're willing to restrict yourself to total languages, the trick is then getting those to do interesting things.
12:13:06 <shock_one> ReinH: do you happen to know whether general recursion is impossible in total languages, or is it still theoretically possible?
12:13:14 <kadoban> ReinH: Right, actually coding real-world stuff in them seems like more trouble than I usually want to do …
12:13:57 <ReinH> shock_one: general recursion is equivalent to Turing completeness, as Godel showed
12:14:14 <kadoban> shock_one: It's theoretically proven to be impossible to be both Turing complete and to totally rule out bottom. General recursion gives you Turing complete. So it's fundamentally impossible.
12:14:32 <shock_one> That's what I thought. Thank you.
12:14:34 <ReinH> If you have general recursion, you have bottoms.
12:14:49 <ReinH> Equivalently, if you have turing completeness, you have bottoms.
12:14:54 <ReinH> Something something halting problem
12:14:59 * hackagebot niagra 0.0.3 - CSS EDSL for Haskell  https://hackage.haskell.org/package/niagra-0.0.3 (natesymer)
12:15:09 <shachaf> and bottoms are scow; therefore turing completeness is scow
12:15:31 <Welkin> YOU ARE A SUPER-COW SHACHAF
12:15:38 <ReinH> shachaf: scow?
12:15:42 <shachaf> Yep.
12:15:47 <ReinH> What is scow?
12:15:47 <Welkin> ReinH: some jargon he made up
12:15:50 <Welkin> and always uses
12:15:51 <ReinH> I see.
12:15:54 <Welkin> and no one knows wtf it means
12:15:58 <maerwald> :D
12:16:04 <kadoban> Anyone else abnormally tempted to giggle at "bottom" whenever it comes up? Just me?
12:16:15 <Welkin> kadoban: wide bottom girls?
12:16:23 <ReinH> Welkin: I will do with this what I do with the rest of his inscrutible statements.
12:16:24 <kadoban> Welkin: Pretty much XD
12:16:34 <shock_one> One more question, a bit closer to earth: is it also so hard to get rid of the issue that generates an error for foo? type A = A { foo :: String } | B
12:16:51 <Welkin> er
12:16:53 <Welkin> fat bottom girls
12:16:55 <Welkin> hahaha
12:17:02 <Welkin> try searching that
12:17:07 <Welkin> the first few results are porn...
12:17:08 <shock_one> I hope this question makes sense.
12:17:10 <maerwald> at hoogle?
12:17:13 <Welkin> even though I was looking for the song
12:17:13 <kadoban> shock_one: You mean 'data' instead of 'type' there? Unless that's syntax I don't know, that looks wrong.
12:17:33 <Zenol> Is it a kind of cow breeded with a snake? O.o?
12:17:54 <shock_one> kadoban: Yes, data, sorry. So, if you do `b = B; foo b` you'll get an error.
12:18:14 <ReinH> shock_one: How would you go about doing that?
12:18:17 <ReinH> foo b type checks
12:18:24 <ReinH> you are asking a question about values, not types
12:18:34 <ReinH> Haskell's type system can't answer questions about values
12:18:38 <shock_one> ReinH: exactly! it compiles and fails in runtime.
12:18:43 <ReinH> Yes, as it should.
12:18:48 <ReinH> it is a partial function
12:18:53 <kadoban> shock_one: Ah, yes. Haskell can't help you if you write partial functions :-(
12:19:08 <ReinH> The best Haskell can do is to warn you that foo is partial
12:19:20 <ReinH> it can't know at compile time if you are using it on a value at runtime that is incorrect
12:19:38 <kadoban> Which is usually enough. Though I don't know if it warns you on that case ^. It probably should, I hope?
12:20:30 <shock_one> ReinH: Isn't it possible to somehow limit the parameter of foo to accept only the values that were constructed with A?
12:20:41 <ReinH> shock_one: No, that's what I'm saying.
12:20:53 <kadoban> I think you can do that with extensions? I dunno though, and it's not vanilla haskell that way.
12:20:54 <ReinH> You can't at compile time make guarantees about values at runtime
12:21:18 <ReinH> Aside from, ofc, the *type* of those values, which is not at issue here
12:22:31 <ReinH> main = putStrLn . foo =<< read -- how should Haskell know at compile time whether this value is an A or a B?
12:22:42 <Cale> shock_one: Generally you ought to avoid using record fields and sum types together like that.
12:23:09 <shock_one> It shouldn't compile, ReinH. But I got it, we need dependent types for that.
12:23:22 <ReinH> shock_one: no, you need to be able to predict the future for taht
12:23:32 <Cale> Even if we had dependent types, it's hard to prove that the user is going to type the appropriate thing.
12:23:38 <ReinH> GHC is an advanced compiler, but so far it has been unable to reverse the arrow of time
12:23:46 <Zenol> YEEEEES I love -hy :D
12:23:49 <shock_one> Cale: I had enough programming by convention, now I want a tool that ensures my code is correct as much as possible. :)
12:24:03 <ReinH> shock_one: and since this is impossible, you shouldn't want it
12:24:26 <ReinH> The answer is simple though: don't create foo in the first place.
12:24:31 <Cale> shock_one: The correct thing would be not to try to define foo in the first place, yes
12:24:33 <Cale> heh
12:24:51 <shock_one> Cale: if it's correct, it should be enforced, isn't it?
12:25:00 <ReinH> shock_one: what?
12:25:01 <Cale> If what's correct?
12:25:07 <kadoban> shock_one: Or if you need 'foo', give it a better type, like :: A -> Maybe String
12:25:22 <Guest00000> did anyone answer me
12:25:34 <shock_one> Cale: "The correct thing", as you wrote.
12:25:37 <maerwald> guess I'll try again: I have an ADT like "data FileOperation = Copy FilePath FilePath | Open FilePath" and want to have some sort of operationBuffer... the problem is, it should also be able to express a "partial" FileOperation like "FilePath -> FileOperation". The only ways I found to do this is Maybe/Either, but they are both pretty limited.
12:25:40 <kadoban> shock_one: "should" if everything were perfect and possible, yes … but everything isn't perfect and everything isn't possible.
12:25:45 <ReinH> Guest00000: I didn't see your question
12:25:54 <ReinH> shock_one: Ok, then you must also remove head and etc from the prelude.
12:26:00 <Cale> shock_one: Oh, well, perhaps that syntax shouldn't be allowed.
12:26:13 <ReinH> Haskell provides you with some foot-shooting mechanisms. We can argue that it shouldn't, but sometimes they are useful.
12:26:20 <Cale> But it's there just for uniformity
12:26:26 <shock_one> ReinH: that's for sure. head must either accept a non-empty list of return Maybe a.
12:26:40 <Cale> It would be a little odd to have a rule which said that the record syntax was only valid for data types with a single constructor.
12:26:54 <ReinH> This is a simple case of "Doctor, it hurts when I do this."
12:27:10 <Zenol> mmachenry: http://zenol.fr/Main_types.pdf
12:27:33 <shock_one> ReinH: sometimes I don't do it on purpose, people just don't have limitless memory, that's the problem.
12:27:35 <Cale> and it can be okay to use the record syntax in some cases where every constructor has the same fields (though such types often you'd want to refactor into a separate tag and a record)
12:27:47 <davean> ReinH: I prefer headMay and headDef
12:28:01 <ReinH> davean: sure, and I tend to prefer pattern matching
12:28:07 <Cale> Or you can use the record syntax simply to document the meaning of the fields, without attempting to use the field extractors
12:28:37 <Cale> fromJustMay
12:28:39 <Cale> :)
12:28:51 <ReinH> Haskell can't prevent you from writing partial functions, so in a sense what you ask for cannot be done. Certainly there could be less of them.
12:29:05 <dutchie> Cale: haha
12:29:07 <Cale> There are legitimate uses of head
12:29:24 <Cale> Specifically, when you can be certain that the list is nonempty
12:29:38 <shock_one> ReinH: you say it can't prevent partial functions. Is it the equivalent to not being a total language, or is it something different?
12:29:40 <Cale> Consider idioms like   map head . group . sort
12:29:46 <jesyspa> Maybe GHC should just provide a --disallow-runtime-errors flag that compiles your code as Agda.
12:29:48 <c_wraith> I just generated the list, I know it's infinite! 
12:29:57 <ReinH> Cale: although I would argue that the computation should be restructured so that is proved by the compiler, not by the human
12:30:12 <maerwald> sounds like a use case for liquidhaskell
12:30:18 <mmachenry> Zenol: Do you have some simple example inputs and outputs to learn that behave poorly?
12:30:35 <mmachenry> Meaning perform badly but have the correct result.
12:30:35 <kadoban> shock_one: You can't prevent /all/ partial functions, the halting problem comes up.
12:30:38 <monochrom> @quote monochrom safeFromJust
12:30:38 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
12:30:38 <Cale> ReinH: It would be nice sometimes, but if it hurts notation (and it frequently does), maybe the tradeoff isn't worth it.
12:30:49 <ReinH> shock_one: Yes, it's implied by turing completeness
12:31:06 <Cale> There isn't exactly a clear-cut answer about how many properties of our program should be enforced by the compiler.
12:31:13 <ReinH> shock_one: You can't determine if a function will halt. Nonterminating functions are partial.
12:31:17 <kadoban> shock_one: That doesn't mean you can't check for some though, and GHC does check for some of them.
12:31:18 <shock_one> ReinH: That's good to know they're caused by the same thing.
12:31:31 <Zenol> mmachenry: No. I have only list of small input. I won't be able to notice if it's inneficitent or use too much memory with only one input.
12:31:51 <Zenol> mmachenry: Basically you call this function at least 50 000times.
12:32:13 <exio4> Cale: group :: [a] -> [NonEmptyList a] :p 
12:32:15 <Zenol> mmachenry: More realistically, 100 000 000. So it has to be in constant memory.
12:32:32 <Cale> exio4: right, this is what I mean about harming notation
12:33:16 <Zenol> mmachenry: But I'm really thinking about rewriting it in another language in which I could be sure it's computing in constant memory. (Since it's aim at run for hours or days.....)
12:33:19 <exio4> we would need some kind of subtyping, so we can use a NonEmptyList as a list and what not, or it'd be too cumbersome? 
12:33:21 <Cale> There's a spectrum of things which can be done, but if you really want to get away from partiality, you end up having to give the compiler proofs that your program terminates, which can often be much more complicated than the programs themselves.
12:33:29 <lambda-11235> Cabal 1.22.6.0 keeps giving me linking errors on packages that compiled perfectly before, is this a reported error?
12:33:40 <Cale> exio4: and then that would screw up type inference horribly
12:34:09 <exio4> Cale: indeed, that's what I meant by too cumbersome, you are giving up type inference
12:35:14 <ReinH> Cale: I would like to see better support for coinduction in total languages, too, per McBride.
12:35:17 <Cale> There are a bunch of other options, but just having a separate NonEmptyList type is probably the simplest and cleanest way there.
12:35:52 <lpaste_> lambda-11235 pasted “cabal build error” at http://lpaste.net/147296
12:35:57 <ReinH> Haskell takes the stance that all data is codata unless the programmer screwed up and it isn't.
12:36:25 <c_wraith> liquid haskell is the only sane subtyping I've seen in Haskell. 
12:36:42 <maerwald> and highly experimental
12:36:43 <Cale> ReinH: Did you know that inductive types + univalence -> coinductive types? :)
12:36:51 <ReinH> data is delivered on demand unless it isn't
12:36:55 <ReinH> Cale: no I did not!
12:36:56 <maerwald> pretty easy to break liquid haskell with a few nested lists 
12:36:59 <Cale> http://arxiv.org/abs/1504.02949
12:37:00 <c_wraith> and it can say non-empty lists are a subtype of lists! 
12:37:30 <ReinH> Cale: HoTT strikes again, I guess
12:37:39 <shock_one> OK, we don't want a total language because it's too much trouble to write such programs, but why do we use partial functions (and promote them, because people trust that a standard library is an examplary piece of code) where total functions can be used?
12:38:18 <ReinH> Cale: Ah, using agda to prove results about coinduction is amusing
12:38:42 <kadoban> shock_one: hysterical raisins + sometimes they're safe and useful, in context
12:39:25 <Cale> I mean, maybe originally the reason that head and tail made it in was historical, but they have quite valid use cases in programs.
12:39:43 <Cale> *When you know that a list must really be nonempty*
12:40:01 * hackagebot yesod-table 2.0.1 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-2.0.1 (andrewthad)
12:40:12 <ReinH> If you view head and tail as incorporating a proof obligation on the part of the programmer, they are reasonable
12:40:12 <shock_one> Cale: when you know it, the compiler can know it too. Like if it's a literal.
12:40:23 <ReinH> shock_one: no, that's not true
12:40:37 <Cale> shock_one: You might know it for some complicated mathematical reason which is hard to explain to the compiler.
12:41:00 <Cale> shock_one: There are languages which force you to explain to the compiler. Haskell isn't one of them.
12:41:07 <ReinH> I can't even get the compiler to prove that repeat () is non-empty.
12:41:31 <Cale> Well, *that* one is automatable in principle.
12:41:46 <ReinH> ok
12:42:51 <lambda-11235> Nevermind, it was an error with the system libraries, not cabal.
12:43:46 <Cale> shock_one: But yeah, maybe look into Agda and Coq as well-developed examples of languages which are 100% picky about totality.
12:44:01 <Cale> Idris has more totality checking than Haskell, but it doesn't default to that mode.
12:45:00 <shock_one> Cale: Idris is a better example because it doesn't allows you to express better constrains without enforcing you to do that. Wouldn't it be awesome to have that in Haskell?
12:45:11 <shock_one> *does allow
12:45:31 <Zenol> <Data.IntMap.Base.sat_sm9d> means what?
12:45:43 <Cale> Well, there would be significantly fewer programs which you could write in Haskell where you really could prove totality
12:46:08 <Cale> Idris' dependent typing is often crucial to getting the compiler to be convinced that your program is indeed total.
12:46:53 <kadoban> Cale: Know anything about acl2? I never seem to hear about it much compared to agda and coq. Maybe that's just because it's less like haskell?
12:47:37 <shock_one> Cale: but also it allows you to express ideas it a more elegant way. Where in Haskell you'd have a new type NonEmptyList and a function that takes an ordinary list and maybe returns this fancy list, in Idris you could do that in terms of list onle.
12:47:38 <Cale> Yes, it would also be awesome to have dependent types in Haskell, and the extensions to Haskell have long been gradually moving in the direction of allowing something closer to dependent typing, while trying very hard to preserve type inference in the general case.
12:47:55 <Cale> shock_one: You could, but you probably still wouldn't want to.
12:48:09 <Cale> You could use a sigma type, pairing a list with a proof of its nonemptiness.
12:49:14 <Zenol> mmachenry: Maybe I'm looking for something too complex and the problem are located in one of the two foldl', as you said. THere are two. One on a small list (in NeuralNetwork.hs) and one on a really huge (in Main.hs, function onlineLearning).
12:49:43 <shock_one> Cale: here's my example. If I could write head as a total function from [a] to a with some additional constraints, I would be able to use it on literals without bothering to prove their non-emptiness, because the compiler knows they have elements.
12:50:21 <shock_one> Cale: can I do this sigma type thing in Haskell?
12:50:36 <mmachenry> Zenol: Also I think you might want to make a test suite for this learn function in HUnit and then refactor it to not use a list but a data structure that is more easily reversed. 
12:50:44 <mmachenry> Or something that fits your data better.
12:50:53 <Cale> no, Sigma and Pi types are exactly the thing which is missing from Haskell which make it not dependently typed
12:52:27 <Zenol> mmachenry: Inside learn? List are IMO the best type. Outside learn (so in a call), maybe. If you have a function that is a a -> b -> a, a initial a, and you wan't to apply this function to a set of data of type b. How would you do that in haskell?
12:53:38 <Zenol> mmachenry: What is a test suite? If it's compairing the output of the function to expected output, it's not really possible. I can't compute the output by hands.
12:54:03 <Cale> You could define something like  safeHead :: Pi (xs :: [a]), null xs = False -> a  -- that is, a function which takes a list xs of type [a], and a proof that applying null to the list results in False, and then produces a result of type a.
12:54:07 <mmachenry> Zenol: Try replacing your seq with https://hackage.haskell.org/package/deepseq-1.4.1.2/docs/Control-DeepSeq.html
12:54:27 <Zenol> mmachenry: Did it 10 minutes ago x) Doesn't changed anything.
12:55:13 <Cale> But this tends not to be so useful an approach
12:55:18 <Zenol> mmachenry: I also tried to use seq  with the x, y, and net arguments of learn, since I fold later in Main with (learn 0.1). But doesn't changed anything :/
12:56:12 <Cale> Similarly for  safeHead :: (Sigma (xs :: [a]), null xs = False) -> a
12:56:22 <mpickering> was -fwarn-pointless-pragmas removed from ghc?
12:56:26 <mmachenry> It's possible you're not evaluating the individual learns fully enough before the full computation. 
12:56:42 <mmachenry> DeepSeq might be a quick way to learn this
12:56:49 <Zenol> mmachenry: Wait, I'm sorry, I didn't tried deepseq with net in learn.
12:56:59 <Cale> But the latter is a bit closer to being reasonable
12:57:08 <Zenol> mmachenry: Just wanted to try it right now and it can't infer type.
12:57:14 <shock_one> Cale: just to clarify, both you're examples wouldn't work in Haskell today, right?
12:57:17 <Cale> right
12:57:22 <shock_one> :(
12:57:31 <Cale> and moreover, they're both much more awkward to use than head
12:57:42 <Cale> because you have to supply these proof terms
12:57:51 <Cale> which may be nontrivial or impossible to provide
12:57:57 <mmachenry> Zenol: Also try removing seq and use bang patterns in your definiton for network and layer
12:58:21 <Zenol> mmachenry: Bang pattern, I did it with juilian before you woke up :P
12:58:54 <mmachenry> https://wiki.haskell.org/Performance/Data_types
12:59:06 <Zenol> mmachenry: But, thinking a bit about it, there is actualy nothing inside learn that is really costly, since all list have small length. In the worst case, it should alocate, and then be free when the output is "evaluated".
12:59:33 <shock_one> Cale: well, all those <*> and >>= are also more awkward than if we allowed impure functions, but Haskell decided purity is worth it.
12:59:43 <Cale> shock_one: uh
12:59:54 <Zenol> mmachenry: Yes, I tried ![Layer], !(SparseVector a) and !(SparseMatrix a). Doesn't help.
12:59:57 <Cale> no, that's not what <*> and >>= are about
12:59:59 <mmachenry> Zenol:  Like this maybe http://lpaste.net/147297
13:00:04 <mmachenry> Ah okay
13:00:19 <Cale> Even if we had impure functions, we'd still want Applicative and Monad.
13:00:45 <Cale> The thing which lets us have Applicative and Monad is that we have type classes (and more specifically, type classes which generalise over a type constructor)
13:00:58 <Zenol> mmachenry: I tried it without the strictness before the (a->a) function because... well, the functions doesn't change at all x)
13:01:05 <Cale> The reason we define those classes is to avoid writing the same code over and over in various libraries where similar operations appear.
13:01:14 <shock_one> But now just to apply effectful arguments to a pure function I have to construct a monster instead of just applying them.
13:01:20 <Cale> It has nothing to do with purity of functions.
13:01:27 <Cale> The IO monad in particular has something to say about that
13:01:28 <Zenol> mmachenry: Did you saw http://zenol.fr/Main_dt.pdf ?
13:01:34 <mmachenry> Yeah
13:01:39 <Cale> But that's just one monad, and isn't very representative.
13:01:46 <Zenol> mmachenry: And http://zenol.fr/Main_types.pdf also.
13:02:07 <Cale> In fact, calling it the IO monad is perhaps overemphasizing the fact that it's a monad
13:02:24 <Cale> The fact that IO happens to be a monad tells you very little about how it works.
13:02:41 <Zenol> mmachenry: You know how I can deepseq on net?
13:02:44 <Cale> It just says something about the manner in which it's possible to glue values of type IO t together.
13:03:27 <Cale> It doesn't tell you that they encode I/O effects, or that execution of IO actions is nondeterministic in any way.
13:04:37 <sunnymilk> shock_one haskell has impure functions
13:04:52 <exio4> do you mean GHC Haskell? 
13:04:52 <sunnymilk> at least if you consider the ffi spec to be "haskell"
13:05:03 <Zenol> mmachenry: (http://lpaste.net/147298) Sounds like it's because of the generic "a" type?
13:05:14 <exio4> well, right, the ffi is `you're on your own past this line` :p 
13:05:25 <Cale> sunnymilk: Nevermind that, he's a beginner and certainly the FFI primitives provided are not intended for daily use.
13:05:48 <monochrom> "fmap mypurefunction this_is_an_effect" does not look like a monster to me, apart from the oh-so-meaningful-and-lengthy-think-Java-enterprise names
13:05:56 <Cale> yeah
13:06:14 <monochrom> if you did create a monster, you were doing it wrong.
13:06:16 <maerwald> uhm... curious why does there no "copyDir :: FilePath -> FilePath -> IO ()" exist? I am lazy, I don't want to write it myself
13:06:50 <Cale> shock_one: The thing you're pointing out has nothing to do with IO being a monad, and everything to do with IO actions being a type of values in the first place.
13:07:12 <monochrom> but the flawed mentality behind creating that monster (I have seen it from other people) can also happen to imperative languages too, in the following incarnation:
13:07:13 <Cale> shock_one: and we might want that, even if things were generally impure
13:07:53 <Cale> shock_one: Choosing a notation in which IO actions are not automatically executed when applying functions to them lets us write control structures as simple functions.
13:08:10 <monochrom> in C++, when some clueless beginners are asked to write a class for complex numbers, they wrote the default constructor to do: cout << "please enter the real part:"; cin >> real_part; ...
13:08:41 <Cale> shock_one: I can do this:
13:08:51 <Zenol> mmachenry: I think the problem is more likely to occure in inlineLearning actualy.
13:09:10 <Cale> times :: Integer -> IO a -> IO [a]
13:10:00 <Cale> times 0 x = return [] -- to carry out the action x zero times, give the action which does nothing and produces the empty list as its result
13:10:03 <norw> Hey guys I am getting a "weird" error, never got this before if I remember correctly... http://lpaste.net/147291 can anyone help? Thanks!
13:10:49 <mmachenry> Zenol: Maybe this http://lpaste.net/147300 but be very careful to check my x y. I'm not sure I preserved your flip uncurry properly. 
13:11:21 <mmachenry> I'm using $!! from deepseq to make a fully strict foldl'
13:11:32 <Cale> times n x = do v <- x; vs <- times (n-1) x; return (v:vs) -- otherwise, produce the action which first executes x once getting some result v, and then recursively carries it out (n-1) times, getting a list of results vs, and finally produces (v:vs) as its result
13:11:57 <mmachenry> I guess I could just write a fully strict foldl' and that would be more easy for me to test on my own and your drop into your program. 
13:11:59 <Cale> (possibly that first case should have been a guard for n <= 0)
13:12:10 <Cale> But you get the idea, yeah?
13:12:51 <Cale> shock_one: Being able to write this kind of thing, where we can easily pass actions around without accidentally executing them is pretty valuable.
13:13:08 <ReinH> Cale: or bool True (putStrLn "True") (putStrLn "False")
13:13:31 <Cale> sure :)
13:13:52 <johnw> mmachenry: shouldn't you only perform deepseq on the final result?  Otherwise, you're potentionally re-deepseq'ing earlier parts of your result with each iteration
13:13:58 <shock_one> Cale: the word accidentally is the whole point of my discussion. The compiler enforces something, but doesn't enforce other obvious places where people make mistakes.
13:14:05 <Cale> Or even having IO actions which themselves produce other IO actions as (perhaps part of) their result
13:14:12 <Zenol> mmachenry: Thanks. (Its [(x, y)] and 'learnFct net x y' I think ;) ). I'm going to try it.
13:14:16 <norw> can anyone help me here please? http://lpaste.net/147291
13:14:24 <geekosaur> norw, round produces a type which has an Integral instance
13:14:26 <Cale> For instance, an IO action might do some initialisation, and return another IO action to perform cleanup later.
13:14:33 <geekosaur> it does not produce Floats
13:14:45 <mmachenry> johnw: Potentially a good point. I'm not sure. Wouldn't DeepSeq find a forced value and stop deeply seq'ing?
13:14:55 <ReinH> Cale: this makes STM more useful, too, since shipping around IO actions is common
13:14:56 <geekosaur> :t round
13:14:57 <johnw> no, that's not how it works
13:14:58 <lambdabot> (Integral b, RealFrac a) => a -> b
13:15:03 <Cale> ReinH: indeed
13:15:06 <norw> geekosaur what's an equivalent function to get floats? Or should I just change the type
13:15:10 <Cale> shock_one: My point is that this is convenient for reasons other than correctness though
13:15:23 <mmachenry> johnw: Oh? How so?
13:15:38 <johnw> if you deepseq a list, it visits every element of the list, and deepseqs that element; it has no way of knowing that "the rest of the list" has already been forced
13:15:39 <Cale> shock_one: and we would tend to want it even if we didn't care about having the compiler check that we've done things right
13:15:59 <norw> geekosaur I tried using             round (50.112413 :: Float)              and it worked on ghci tho :/
13:16:19 <geekosaur> but the type it gave you was Integer
13:16:21 <Cale> shock_one: It is stylistically different from what goes on in C and most other imperative languages.
13:16:26 <mmachenry> johnw: Oh interesting. 
13:16:37 <geekosaur> the Float you are specifying on the parameter is not the problem
13:16:48 <Cale> shock_one: but it is a style with some significant benefits, even in the absence of the type system
13:16:59 <mmachenry> johnw: but wouldn't only forcing the last element cause the computation to build up until the end?
13:17:09 <geekosaur> the -> (Float, Float) in the signature of getRectangls is telling it that you want round :: Float -> Float which does not exist
13:17:10 <norw> geekosaur I changed the type to (Int,Int) like you suggested and it worked
13:17:20 <johnw> mmachenry: yes, that's true; this is also why using deepseq is generally a bad idea
13:17:27 <johnw> because it's quite easy to do too little or too much work
13:17:41 <johnw> it's better to understand exactly how much strictness you need, and then to apply just that amount
13:18:20 <johnw> I only use deepseq during debugging, to be sure that strictness would solve anything; then I start analyzing to find out what is actually necessary
13:18:45 <ReinH> @gogole apfelmus strictness invariants
13:18:45 <johnw> sometimes, the answer is even more laziness
13:18:47 <lambdabot> http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
13:18:47 <lambdabot> Title: apfelmus - Reasoning about space leaks with space invariants
13:18:49 <ReinH> mmachenry: you should read that
13:18:50 <deni> why is there no documentation (from time to time) on hackage for some packages that I know have documentation because I look at it frequently
13:18:52 <deni> ???
13:18:56 <mmachenry> johnw: That's what we're trying to do, yes
13:18:56 <deni> is hackage THAT broken?
13:19:11 <mmachenry> Thanks ReinH
13:19:41 <ReinH> deni: it takes some time for documentation to buildaa
13:20:02 * hackagebot libravatar 0.3.0.0 - Use Libravatar, the decentralized avatar delivery service  https://hackage.haskell.org/package/libravatar-0.3.0.0 (akrasner)
13:20:04 * hackagebot locked-poll 0.1.0 - Very simple poll lock  https://hackage.haskell.org/package/locked-poll-0.1.0 (scottmurphy09)
13:20:05 <shock_one> Cale and ReinH, thank you for the explanations.
13:20:07 <Guest00000> is agda interactive mode just unusable?
13:20:23 <deni> ReinH: why?
13:20:30 <deni> like when a maintainer update the package?
13:20:32 <Cale> shock_one: But yeah, it's not like we don't think it would be nice to enforce more properties in the type system too :)
13:20:39 <Cale> shock_one: It's just not so one-sided
13:21:09 <Cale> and if you try the systems which let you do it, it's not the case even there that you'd always prefer to
13:21:17 <Zenol> mmachenry: Do you mean (inlineLearning learnFct $!! (learnFct x y net)) dt ?
13:21:23 <ReinH> deni: yes
13:21:30 <Cale> and those systems *do* give up some things for their additional expressiveness at the type level
13:21:38 <Zenol> mmachenry: In that case, No instance for (NFData (Network Double)) arising from a use of `$!!'
13:22:11 <mmachenry> Zenol: Oh hrm… you might need to implement an instance of that for network
13:22:22 <Cale> You are forced to specify more types by hand, which affects how well those languages extend toward the small scale of programming.
13:22:34 <ReinH> deni: a considerable amount of time and effort and machinery has been devoted to building the documentation for thousands of packages using an imperfect tool, so yes, I suppose hackage is "that broken" fsvo "that broken", but I don't particularly appreciate your entitled attitude towards resources that volunteers are providing you for free.
13:22:47 <Cale> (and in larger scale applications, the type expressions can become pretty scary)
13:23:14 <mmachenry> Zenol, johnw, ReinH, Let me just say I know a bit about this and I'm helping largely so I can learn this myself. So take that for what it's worth. 
13:23:46 <Cale> Guest00000: On the contrary, Agda's interactive mode is practically necessary
13:23:53 <mmachenry> But Zenol I think it's clear your issue is that you're not fully evaluating the data in learn before moving on to the next fold and that's consuming growing space.
13:24:01 <deni> ReinH: I didn't intend for it to come across like that. But what I'm talking about is that other ecosystems don't have this issue because docs are separate from code...ie...github markdown or something
13:24:14 <Cale> Guest00000: Well, depending on what you mean by that -- I'm assuming you mean the emacs integration mode.
13:24:17 <davean> deni: most of the docs on hackage *are* the code
13:24:17 <mmachenry> Zenol: learn is also rather inefficient itself both in time and in space due to the list reversing. 
13:24:31 <mmachenry> How to most easily strictify this, I'm not sure.
13:24:39 <davean> deni: and, some packages will never have their docs automaticly on hackage because they don't build on systems we have
13:24:42 <deni> haskell has a really tough time figuring out what is good for being productive....some things that are obvious in other languages seem to espace the community here... or at least that's what I observed
13:25:05 <deni> davean: that's a whole other issue as well :D
13:25:30 <ReinH> deni: are you aware that you can build your own haddocks locally when you install packages?
13:25:43 <ReinH> cabal will do this for you automatically
13:25:49 <Cale> deni: If I could have only one of: A) Compiler checked type signatures for things defined by a package, or B) Human written documentation of roughly what things did, I would tend to prefer to have A.
13:26:10 <Cale> Of course, it's nice to have both
13:26:18 <Cale> and that's what haddock is about :P
13:26:19 <deni> Cale: I would too.... I mean that's why I'm learning this thing....but that doesn't exclude B
13:26:39 <deni> ReinH: I am aware...but that's not a good UX at all
13:26:44 <monochrom> some productivity tips obvious for other languages are plain false for haskell, too
13:27:02 <Zenol> mmachenry: For the list inside the data structure, I'm sure I want to keep them. But yes, I would like to learn that if you eval the application, then you get a fully evaluated network. But I don't know how to say that.
13:27:08 <Cale> deni: You can have cabal-install generate a nice index of the modules in all your installed packages
13:27:16 <ReinH> deni: having local documentation avaliable for every package you have installed is *not* a good user experience?
13:27:18 <monochrom> especially the productivity tip that says "avoid types"
13:27:28 <Zenol> mmachenry: I'm also afraid SparseVector and SparseMatrix can't be evaluated with deepSeq :s
13:27:29 <deni> I guess I really sounded offending when everybody is jumping in defending this.... I'm sorry about that... but geez I can't believe nobody sees an issue with this
13:27:33 <deni> especially with beginners
13:27:34 <exio4> deni: "obvious in other languages", sure, if you give up the static type checker, then some things become easier! 
13:27:44 <Cale> deni: Maybe I missed what the original issue was?
13:27:58 <Cale> deni: Making sure documentation is available on Hackage?
13:27:59 <ReinH> Cale: deni asked if hackage was "THAT broken".
13:28:05 <ReinH> And is now wondering why people are being defensive.
13:28:30 <Zenol> mmachenry: But thanks for trying to help me, I would have give up otherwise.
13:28:47 <deni> ReinH: I'm experimenting..I install a package...I try stuff out..I google for it ...first link for docs is hackage..I click it....it's broken.... I go to IRC...people tell me install documentation locally... everything is fine
13:29:09 <davean> deni: what package?
13:29:17 <deni> I'm trying to communicate how this is a problem that we as a community should try to solve...and not defend the status quo
13:29:23 <deni> davean: containers :D
13:29:27 <monochrom> I don't know, if you make a gross generalized statement, it will be of course false and you will see refutation.
13:29:40 <deni> I have this happen to me weekly
13:29:41 <davean> deni: litterly uplaoded secodns ago :)
13:29:46 <davean> deni: you could go back a version
13:29:47 <Cale> It is a little bit upsetting that cabal sdist doesn't just run Haddock and put the results in the tarball it makes as well, so that Hackage would be guaranteed to have documentation available.
13:29:48 <monochrom> if you just stick to a very specific documentation issue, then of course you will get better agreement.
13:29:57 <ReinH> deni: What I am defending is the hard work that a bunch of actual people have put into the status quo that we currently have, which is one where the vast majority of packages *do* have documentation
13:29:59 <davean> but how many times have you had docs just been wrong and out of date in other languages?
13:30:02 <deni> how is that generalized? (pun intended ... haskell generalization and all that :D )
13:30:37 <davean> (Frankly, in python I gave up on the docs and just started reading code - thats not an issue I've had in Haskell)
13:30:45 <monochrom> "haskell has a really tough time figuring out what is good for being productive....some things that are obvious in other languages seem to espace the community here... or at least that's what I observed" is clearly an overly generalized and extrapolated statement. 
13:30:52 <monochrom> this is not negotiable.
13:31:54 <ReinH> Cale: yes, it would be much better to amortize the work of building documentation onto the package uploaders
13:31:57 <Cale> deni: However, if there's missing documentation on Hackage, you *can* blame the package developer for not uploading some.
13:32:06 <davean> ReinH: It would actually work
13:32:19 <Cale> Well at least that is possible for them to do, but they may not have noticed it was required :)
13:32:24 <ReinH> and not require a bunch of servers and people-hours of maintenance for a documentation build farm
13:32:33 <Cale> ReinH: right
13:32:46 <Cale> ReinH: Or even if we keep that, it's nice to have something to fall back on.
13:33:32 <deni> davean: Cale ReinH I was wondering why the docs don't get built locally and uplodaded?
13:33:42 <deni> what needs to happen for that to be reality?
13:33:48 <ReinH> deni: some package maintainers do that
13:33:58 <ReinH> it is not enforced by the build tool
13:33:58 <Cale> All that needs to happen is for package maintainers to do it
13:34:05 <ReinH> but it is easy enough to do
13:34:10 <deni> ReinH: I'm not interested in discussing the way you read my sentence..I already said it's not meant to be offend anybody and your point is valid I just don't want to dwell on it
13:34:28 <Cale> We could start *requiring* package maintainers to generate documentation locally and upload it with their package.
13:34:44 <deni> Cale: how do we "require" that?
13:34:45 <davean> Though that would run into the issue that it would make cabal-install depend on haddock
13:34:50 <davean> which people don't seem to like
13:35:00 <Cale> deni: By making the Hackage server reject packages that don't include documentation
13:35:17 <deni> Cale: oh...that makes sense...
13:35:21 <ReinH> Cale: I bet if we polished and packaged up that script that edwardk uses and made it easy to get and use, more people would upload docs
13:35:31 <Cale> Neil also has one
13:35:37 <deni> davean: cabal-install doesn't have to depend on haddock per say.
13:35:39 <ReinH> Sure, I dont particularly care whose :)
13:35:54 <davean> deni: ...
13:36:08 <ReinH> Cale: I suspect that we'd make a lot of progress by installing it as a social norm for package maintainers rather than as a rule.
13:36:20 <ReinH> Similar to testing in other communities
13:36:21 <fresheyeball> hello out there
13:36:23 <monochrom> if you look at how much I doc my code, you will understand that I would not be one of those who let their code stay undoc'ed by inaction.
13:36:30 <deni> davean: I mean that cale said...enforce it on the server side....
13:36:36 <fresheyeball> I need to handle a http 500 error with http-client 
13:36:47 <fresheyeball> I tried using catchIOError
13:36:58 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs is how much I doc my code
13:37:07 <davean> deni: yep, which basicly means cabal-install depends on haddock
13:37:09 <fresheyeball> but the runtime error from the 500 in response is still killing my app
13:37:11 <fresheyeball> any idea?
13:37:23 <monochrom> by my standard, even most python code is under-doc'ed
13:37:39 <Cale> If we just made it so that cabal-install's sdist command would try to include the documentation by default, rather than having the inclusion of documentation be an additional step, then I bet most packages would include documentation even if it wasn't enforced.
13:37:43 <deni> davean: yeah I get that... but why don't people like it?
13:38:21 <Cale> deni: Well, you do end up in a bit of a Catch-22 if you want to use cabal-install to install Haddock :)
13:38:34 <deni> I mean if there's no docs fine don't include anything....a package is uploaded without docs...but if there are docs...package them
13:38:45 <deni> Cale: right....
13:38:52 <ReinH> Simple solution: separate the tool for installing packages from the one for publishing packages.
13:39:10 <Cale> But cabal-install could just *try* to generate documentation with haddock, and not worry about the case when it doesn't find Haddock already installed.
13:39:12 <deni> okay so the problem is way more tangled than I thought
13:39:45 <Cale> Usually if you're building a package for upload, you're at the point where you'll have things like Haddock already installed.
13:39:46 <ReinH> deni: (you're being more productive now, which was my goal in mentioning it in the first place, so I don't see any need to revisit.)
13:41:03 <deni> Cale: that sounds reasonable to me.... but I don't get what long time users what might have to say about that
13:41:37 <Cale> I mean, I'm a long time user, and I would at least personally find that convenient.
13:41:57 <deni> Cale: there we go
13:41:58 <deni> :D
13:42:26 <deni> I don't know what the thought process here is.... where can this be proposed and who will decide if it will get implemented (or merge a PR)?
13:42:29 <Cale> So now we just need someone to actually do that.
13:42:42 <monochrom> cabal is worse than splitting between "should I be a build tool, and install tool, or a publication tool?"
13:42:56 <deni> I mean I've heard about this issue a lot already.... but on places like twitter so.... but I use twitter for ranting so I imagine other people do too sometimes....
13:43:11 <Cale> I think Duncan Coutts is the person to talk to about whether it actually gets in perhaps?
13:43:34 <Cale> dcoutts: are you here? :D
13:43:34 <monochrom> in fact it is rooted in "should I be a build tool, an install tool for haskell programmers, an install tool for non-haskell-programmers such as those who just want to use xmonad, or a publication tool?"
13:44:13 <monochrom> its defaults (such as "don't build doc, don't build profiling versions") reflect this
13:44:32 <ReinH> monochrom: I think the fact that the executable is named cabal-install gives at least some justification moving sdist into its own thing ;)
13:44:43 <deni> monochrom: don't be like that xmonad peeps need docs too :P
13:45:05 <Cale> Yeah, there's also stack, which apparently is more focused on providing environments for projects rather than simply building separate packages, which I've heard a lot of praise for from bitemyapp recently. I wonder if it treats documentation any differently.
13:45:41 <geekosaur> git-annex might be a better example, most people don't install it to hack on it
13:45:52 <deni> how do tools like stack work here? does stack do anything with docs? I just use it for new personal projects and installing stuff (haven't really investigated deeper)
13:45:54 <geekosaur> or build against its libraries (if any)
13:46:10 <davean> deni: it uses cabal
13:46:19 <deni> under the hood i know
13:46:26 <deni> but I'm asking in the docs department specifically
13:46:30 <deni> also what Cale said above
13:46:37 <ReinH> stack has stack haddock
13:46:50 <Cale> ReinH: Does it have stack sdist?
13:47:02 <Cale> (and does that build documentation or not?)
13:47:03 <ReinH> yep
13:47:05 <deni> yep
13:47:06 <ReinH> maybe
13:47:54 <mgsloan> It also has "stack upload", but sdist and upload do not yet do anything special for haddocks.  See this issue: https://github.com/commercialhaskell/stack/issues/737
13:48:55 <mgsloan> So, it's planned, but we've currently got bigger fish to fry.  Of course, folks should feel free to implement this if they want it
13:48:59 * mgsloan adds "awaiting pr" label
13:49:00 <Cale> Oh, there's a decent point in a comment there
13:49:12 <Cale> With regard to inter-package hyperlinks
13:49:41 <Cale> When Hackage itself generates the documentation, it can ensure that the links aren't broken.
13:49:57 <fresheyeball> anyone? I'm finding nothing on handingly 500 errors in http-client 
13:50:08 <Cale> fresheyeball: I'll have a quick look
13:50:35 <Zenol> Ok, I think I managed to compile with deepseq. I had to add instances, derive Generics, but now it's compiling.
13:50:50 <Cale> fresheyeball: You get a StatusCodeException, right?
13:51:10 <monochrom> does "zenol" mean an infinitestimal alcohol? :)
13:51:22 <fresheyeball> I can't figure out how to get one in the code
13:51:37 <fresheyeball> but is definately shows up in the terminal when it dies
13:52:12 <Cale> fresheyeball: Right, so you want to use the stuff in Control.Exception to catch the HttpException, and possibly re-throw ones that you're not interested in handling
13:52:14 <Cale> :t catch
13:52:16 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
13:53:17 <Cale> So you might write something like   ... `catch` \e -> case e of StatusCodeException status hdrs cookies -> ...handle the exception...; _ -> throwIO e
13:53:28 <nitrix> Is there a Haskell package with standard metric file sizes?
13:53:35 <Cale> Or just make the handler a separately-defined function, if it's complicated :)
13:53:35 <nitrix> MB, GB, with human readable forms and whatnot?
13:54:09 <fresheyeball> Cale: thanks! I will try that. I was in System.IO.Error
13:54:16 <Zenol> mmachenry: Same issue with deepseq.
13:54:23 <glguy> If you don't want 500 to raise an exception you can change the handler for return codes on the Request
13:54:44 <mmachenry> Zenol: You implemented an instance and it still has an issue?
13:54:46 <Zenol> mmachenry: I give you my instances of deepseq. I think we know now where it does come from.
13:54:53 <Zenol> mmachenry: Yep
13:54:56 <Cale> fresheyeball: see also...
13:54:57 <Cale> :t try
13:54:58 <lambdabot> Exception e => IO a -> IO (Either e a)
13:55:05 <monochrom> fresheyeball: see my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml for more principles and choices
13:55:13 <Cale> ^^ this can additionally be quite a nice way to handle exceptions.
13:55:20 <mmachenry> Zenol: Hm.. this is a bit beyond my understanding.
13:55:33 <mmachenry> I'm interested to figure it out though.
13:55:35 <Zenol> mmachenry: Not if you look at the definition of the instances.
13:55:37 <Zenol> mmachenry: http://lpaste.net/147303
13:55:39 <Guest00000> Cale: i meant agda -I
13:55:42 <monochrom> yes, in fact I recommend "try" over "catch" for most uses
13:56:07 <deni> ReinH: Cale so stack might solve this it seems?
13:56:17 <Zenol> mmachenry: IMO, it means that it's `multM`, +, -, and fmap wich are using all that memory.
13:56:23 <Cale> Guest00000: Oh, I wouldn't think it's broken, but it's been a little while since I last used Agda... maybe try asking in #agda if you're having trouble with it
13:56:25 <monochrom> there are only a few specific good uses for "catch", since it does way more than you usually need
13:56:43 <Zenol> mmachenry: What I can't archieve, is to give a true reduced SparseVector a and SparseMatrix a.
13:56:46 <glguy> You don't have to use exception handlers to deal with a 500 if you want to treat it like a normal response
13:57:10 <glguy> You can override the "checkStatus" field of your request
13:57:23 <Cale> deni: No, we determined that it didn't, however, the posts there seemed to indicate that developers of stack are also interested in doing something about it.
13:57:36 <deni> Cale: yeah reading up about the links
13:58:29 <Cale> deni: The hyperlinking issue is sort of annoying. It might be possible for hackage to just process the uploaded documentation somehow to fix things up.
13:58:57 <Cale> But documentation with broken links would be better than nothing.
13:59:02 <deni> that doesn't seem like an unsolvable problem
13:59:20 <deni> either on the client end or on the server end
13:59:33 <glguy> What was causing the broken links?
13:59:46 <deni> putting in some variable that can be interpreted differently locally and different on hackage
14:00:04 <deni> glguy: from what I understand stack haddock generates relative paths
14:00:28 <Cale> glguy: Well, if you generate documentation locally, it doesn't necessarily have the correct links for hackage if there are links to other packages.
14:00:50 <Cale> but yeah, it seems like something which ought to be solvable in principle
14:00:52 <glguy> Cale: you just have to tell haddock what template to use for the links
14:00:59 <Cale> glguy: ah, okay
14:01:04 <glguy> or are you saying that even doing it that way things break?
14:01:07 <Zenol> mmachenry: The data types in Math.LinearAlgebra.Sparse aren't strict.... https://hackage.haskell.org/package/sparse-lin-alg-0.4.3/docs/src/Math-LinearAlgebra-Sparse-Vector.html#Index
14:01:39 <Cale> glguy: Well, I don't know. There was a comment about it in Stack's bug tracker which wasn't too specific.
14:01:55 <Cale> glguy: It's entirely possible that it's solvable already :)
14:02:23 <glguy> I've uploaded a bunch of docs to hackage that didn't have broken links (or at least didn't to my knowledge)
14:02:33 <glguy> so I was wondering if there was something more, sounds like I need to read the ticket
14:03:45 <Cale> https://github.com/commercialhaskell/stack/issues/737
14:04:00 <glguy> thanks
14:04:14 <Cale> "The docs generated by stack haddock are almost in the right format already, they just need a tweak to the paths and href URLs."
14:04:26 <Cale> That was back in October though :)
14:04:43 <monochrom> you know, "tweak the paths" is easier said than done.
14:04:45 <zoku> Hey Cale, got a sec to check my updates?
14:04:51 <glguy> Cale: Actually, the script that pjadej says he's using is my script :)
14:04:55 <zoku> You made a suggestion for my irc-bot, I implemented it but I'm having some other issues
14:05:08 <Cale> zoku: ah, okay
14:05:08 <zoku> http://lpaste.net/5494306397665361920
14:05:22 <zoku> I'm still not getting output from MUD -> irc
14:05:33 <zoku> my irc messages are passed to the network socket, but not the other way around
14:05:49 <zoku> strace reveals that select() is only being passed the IRC handle, not the MUD handle as well
14:08:07 <Zenol> Hum, I think I have allready reached the point it will be more productive to forget about writing it in haskell and use a more less fancy but strict language to write it.
14:08:44 <Cale> zoku: Okay, so you have this queue of accumulating messages, irccon
14:09:30 <zoku> Ah, I should add that, putting BS.putStrLn into recvMUD
14:09:34 <zoku> does not print any data
14:09:44 <zoku> so it seems i'm not even getting data in recvMUD
14:09:52 <Cale> ah, right, okay
14:10:11 <Cale> hmm
14:12:50 <Cale> zoku: Can you somehow confirm that your messages are getting sent to the mud as well?
14:13:31 <zoku> yes
14:13:45 <zoku> i'm testing with netcat -l on localhost
14:13:52 <zoku> and I see messages coming from IRC
14:14:05 <zoku> as well as my initial login messages from connectMUD
14:15:51 <Cale> Does nc -l do any buffering of its own?
14:16:06 <zoku> hmm, i believe it's line buffered
14:16:08 <zoku> i'll check
14:16:31 <zoku> yep
14:16:47 <zoku> when i connect netcat to another instance, it sends on \n
14:16:56 <Cale> hmm
14:17:07 <Cale> In that case I'm not sure why hGetLine wouldn't actually work
14:17:32 <zoku> it's safe enough passing network handles into forkIO?
14:17:37 <Cale> yep
14:17:48 <Cale> and this is the expected way to wait on multiple things
14:17:49 <zoku> yea, i figured, as that's how most servers work in C as well
14:17:55 <zoku> dang
14:18:14 <zoku> okay, at least it's not just me :]
14:18:30 <Cale> Maybe try a simpler program which only connects and then does the hGetLine
14:18:31 <zoku> this is my first attempt to do anything outside of one-liners for project euler
14:18:40 <Cale> (and prints the line it reads)
14:18:48 <Cale> and see if you can get it to unblock :)
14:18:54 <zoku> hehe, good idea
14:20:24 <zoku> ah!
14:20:33 <zoku> so if I don't start the irc-client
14:20:49 <Zenol> Ok, it's enought. I spend twice the time implementing this algorithm trying to make it work with a real world dataset, with the help of 3 of you, and didnt get any improvement. It's completely unusable as if even with a toy dataset like MNIST. I'll have it rewriten in C++ in 3 hours if I wan't, and although I don't like this language, it seems it will be far more productive.
14:20:50 <zoku> by commenting out `start conn cfg'`
14:21:05 <zoku> I do recieve data on the MUD socket
14:21:05 <Cale> oh!
14:21:14 <Cale> start conn cfg probably takes forever
14:21:18 <zoku> (also i removed forkIO)
14:21:24 <zoku> since it returns
14:21:51 <Cale> Does connectIRC ever actually return?
14:22:09 <zoku> hahaha
14:22:10 <Cale> If you put a putStrLn after the irccon <- ... line, does it get printed?
14:22:12 <zoku> actually...
14:22:14 <zoku> it mgt not
14:22:19 <zoku> i think you called it
14:22:25 <zoku> it probably doesn't  >_<
14:22:28 <Cale> I think "start" is expected to take forever
14:22:32 <Zenol> by the way, If you know a good strict, dynamicly typed pure functional language that have syntaxic sugar for monads/monads tranformers, please tell me :3
14:22:47 <Cale> So you'll want to forkIO *that* and maybe not forkIO your handleSocketMessages
14:22:59 <zoku> nope!
14:23:01 <monochrom> sounds like Scheme. you can make syntax sugar for anything
14:23:08 <zoku> thanks Cale
14:23:10 <zoku> that's it XD
14:23:16 <Cale> Zenol: dynamically typed doesn't mix well with using monads
14:23:22 <monochrom> except that all syntax sugar must be in s-expression syntax
14:23:30 <athan> Isn't there a ghci command for printing _only_ the evaluated constructors of some data?
14:23:39 <athan> I thought it was :sprint, but it's not working for me
14:24:00 <monochrom> actually, Racket can do arbitrary syntax
14:24:09 <zoku> can I return a tuple from a function?
14:24:15 <athan> for instance, `let x = [1,2,3]; :sprint x` shows `x = _`, but performing `length x` should have the next call to :sprint x show `x = [_,_,_]`
14:24:16 <zoku> I'll need conn and cfg' to start
14:24:19 <athan> but it's not :\
14:24:39 <athan> zoku: You can return anything from a function, so long as you can :v
14:24:55 <Cale> Zenol: The monad abstraction relies quite a lot on type classes helping to infer which implementation of the monad operations to use, which reduces the number of parameters to everything by 1.
14:25:33 <dmwit> athan: http://stackoverflow.com/q/21518584/791604
14:25:41 <Cale> Zenol: If you wanted to use the monad abstraction in a non-statically-typed language, or a language without something similar to type classes, you'd end up passing around a record of the implementations of return and (>>=) everywhere
14:26:03 <Zenol> Cale: Oh, I see, didn't thought about it at all x)
14:26:09 <Cale> Zenol: and return and (>>=) themselves would become field extractors for those records
14:26:17 <Cale> and get an additional parameter
14:26:47 <Cale> You can have some syntax sugar to help with that, but it ends up being not very great in general.
14:27:14 <Zenol> Cale: So basically, you will never see monads in a language like R ?
14:27:21 <Cale> Especially in cases where you're switching between monads
14:27:31 <dmwit> "never" is such a strong word
14:27:32 <Cale> yeah, pretty much the abstraction doesn't work out so well
14:27:51 <Zenol> dmwit: Let's say it's a week never ;)
14:27:56 <Cale> You can do it, but it more or less isn't abstracting over a pattern which actually happens in those languages.
14:28:11 <Cale> and it's way more awkward to carry out
14:29:08 <Zenol> Cale: Ok, then I remove my contrainst about dynamic typing. Don't wan't that manipulating monads make me become crazy.
14:29:18 <mgsloan> Zenol: But you'll already see R monads in languages like Haskell ;) https://github.com/tweag/HaskellR/blob/master/inline-r/src/Language/R/Instance.hs#L82
14:31:56 <Zenol> mgsloan: Yeeeeees but... I think that most of us will accord, sadly, to the fact haskell isn't the best language for doing reaserch in statistics :/
14:31:59 <athan> mer, sorry guys my console borked
14:32:31 <cdupont> Hi guys
14:32:46 <cdupont> I have a strange error when doing cabal install cabal-install:
14:33:01 <cdupont> rejecting: base-4.7.0.2/installed-bfd... (global constraint requires
14:33:01 <cdupont> ==4.8.1.0)
14:33:01 <cdupont> rejecting: base-4.8.1.0 (global constraint requires installed instance)
14:33:01 <cdupont> rejecting: base-4.8.0.0, 4.7.0.2, 4.7.0.1, 4.7.0.0, 4.6.0.1, 4.6.0.0, 4.5.1.0,
14:33:01 <cdupont> 4.5.0.0, 4.4.1.0, 4.4.0.0, 4.3.1.0, 4.3.0.0, 4.2.0.2, 4.2.0.1, 4.2.0.0,
14:33:02 <cdupont> 4.1.0.0, 4.0.0.0, 3.0.3.2, 3.0.3.1 (global constraint requires ==4.8.1.0)
14:33:08 <athan> :|
14:33:09 <dmwit> Don't paste in-channel, please.
14:33:11 <dmwit> ?lpaste
14:33:11 <lambdabot> Haskell pastebin: http://lpaste.net/
14:33:15 <Zenol> But before rewriting it in C++, I can try to remove the use of Math.LinearAlgebra.Sparse and see if everything works better using conventional matrices.
14:33:28 <fr33domlover> Hello! Q: I have a server daemon to which I'd like to be able to pass sysadmin commands. What would be a good way to do it? Have a thread listening on a unix socket? or a FIFO? or something else?
14:33:38 <cdupont> dmwit: OK sorry
14:35:05 * hackagebot Plot-ho-matic 0.7.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.7.0.0 (GregHorn)
14:36:41 <mgsloan> Zenol: True.  Haskell's a fine language to do stats stuff in.  Stats research, though, that implies that you'll need to collaborate with other stats researchers.  In that case, using a language / libraries they're likely to understand makes sense
14:37:08 <dmwit> fr33domlover: Those both sound reasonable enough.
14:37:41 <mgsloan> That said, we've had a lot of success doing some quite advanced statistical analysis in Haskell, and just calling out to R whenever we don't have a native Haskell impl or library wrapping a C impl
14:38:24 <mgsloan> The issue is that the best languages for doing research in statistics (and science in general), tend to be quite poor languages
14:38:41 <Zenol> mgsloan: It's not about comunicating with others.
14:39:09 <cdupont> So what is this global constraint cabal is speaking about?
14:39:21 <mgsloan> Bret Victor's essay on climate change has a good section about how scientific programming needs better languages: http://worrydream.com/ClimateChange/#tools-technical
14:39:42 <cdupont> I have GHC 7.8.4 so it's base 4.7 AFAIK
14:42:18 <lispy> cdupont: I'm not sure, but what are the constraints on the package you're trying to install? Does it request base 4.8.1.0
14:42:34 <fr33domlover> dmwit, thanks
14:42:56 <bergmark> cdupont: a global constraint can be a command line argument, a constraint in your ~/.cabal/config, or in a sandbox config
14:46:18 <cdupont> lispy: it requires base >= 4.6 && < 5
14:46:38 <Majiir> Am I reading this right? Lambdabot uses MVar instead of a state monad to handle module state? https://github.com/lambdabot/lambdabot/blob/master/lambdabot-core/src/Lambdabot/Module.hs#L90-L102
14:47:14 <bergmark> Majiir: right, that's a common pattern
14:47:21 <Axman6> I would guess that lambdabot runs threads concurrently, so the state probably needs to be shared
14:47:51 <Axman6> (or, maybe some of it shouldn't, there have been some fun times where people have messed with lambdabot in one channel to screw with another
14:48:12 <cdupont> bergman: I don't have any cmd line arg, ~/.cabal/config seems standard, no sandbox...
14:48:44 <cdupont> I just changed my version of GHC by changing my path
14:49:00 <cdupont> is there something else I need to do? i.e. with cabal
14:49:11 <Majiir> bergmark, I figured there's a reason, but I still don't quite get it. Wouldn't it be much safer for module state to be pure within the module monad, and leave the concurrency behind the scenes?
14:49:22 <Majiir> Maybe I'm mixing up the role of Module and Cmd
14:52:03 <bergmark> Majiir: if you are talking about lambdabot internals then i have no idea :-/
14:52:36 <cdupont> also I have this error: ghc-pkg: /home/cdupont/.ghc/x86_64-linux-7.8.4/package.conf.d/: openBinaryTempFile: permission denied (Permission denied)
14:54:14 <cdupont> somebody messed with my permission O_O
14:54:32 <geekosaur> did you run something as root?
14:54:40 <Guest00000> okay..
14:54:44 <geekosaur> (likely a cabal install)
14:55:20 <Welkin> cabal cabal
14:55:34 <dcoutts> cabal cabal cabal cabal
14:55:39 <dcoutts> surely?
14:56:16 <Guest00000> how do i name a function :: X c a -> X d a
14:56:20 <geekosaur> Majiir, one issue is that IRC is a module, and any other module that needs to access IRC information potentially will be accessing it at the same time the module is modifying it
14:56:28 <Guest00000> where c, d :: * -> Constraint
14:56:41 <Guest00000> how should i NAME it
14:56:54 <cdupont> ll .ghc give this ouput: d????????? ? ? ? ?            ? x86_64-linux-7.8.4
14:57:01 <cdupont> very funny :)
14:57:05 <geekosaur> uhhhhhhhh
14:57:19 <fr33domlover> hmmm how do I use Linux FIFOs in Haskell? Some posix related package? Or is there some generic Haskell abstraction for one directional IPC?
14:57:21 <MitchellSalad> in the definition of X, you can give a kind
14:57:34 <MitchellSalad> data X (c :: * -> Constraint) (a :: *) = ...
14:57:39 <cdupont> I tried to install Intelij IDEA Haskell plugin
14:57:43 <c_wraith> Guest00000, maybe something like castConstraint? 
14:57:46 <Axman6> fr33domlover: aren't FIFOs things you just treat as files?
14:57:55 <Axman6> so you can open them and get a handle?
14:58:00 <wayne> hi. what's it called when you make a mini type system within your code?
14:58:02 <Majiir> geekosaur, I see... My raised eyebrow here is because I'm working in Cmd, and it seems awfully unsafe to be reading an MVar, parsing a string, and immediately writing back to that MVar every single time someone sends a message.
14:58:03 <cdupont> It might have messed up
14:58:11 <wayne> e.g. if you have a "flexible" attribute system for people
14:58:19 <wayne> and the attributes can be bools, ints, strings
14:58:27 <fr33domlover> Axman6, yes, but you use mkfifo() to open them
14:58:28 <cdupont> is it alright to delete .ghc ?
14:58:40 <geekosaur> cdupont, nomally you can only get that kind of output if the filesystem is corrupt
14:58:47 <cdupont> gulpppp
14:59:02 <cdupont> nooooooo
14:59:46 <geekosaur> that said, I can't see how corruption gets you a known type but the other bits unknown, so it could be a bigger permission issue (e.g. selinux type stuff, permissions beyond traditional unix)\ 
15:00:12 <Guest00000> that was obvious.. but a good name indeed, thank you
15:00:14 <geekosaur> it does suggest that ls can't understand the stat information it got back
15:00:38 <cdupont> is there a fix? some check disk utils...
15:01:59 <geekosaur> well, if it were corruption, you boot single user and use fsck. butIhave seen reports of that when selinux is preventing something and it gets returned to userspace as an improperly filled stat structure instead of as a permission error...
15:02:45 <geekosaur> ...and I mostly can't help with that, largely because how those kinds of security mechanisms behave is up to the specific OS configuration
15:03:40 <cdupont> it seems better with a chmod -R a+rX .ghc
15:04:24 <cdupont> It probably got corrupted by one of the haskell plugins I tried to install
15:04:40 <geekosaur> I'm afraid to ask how that could lead to stat garbage
15:04:55 <fr33domlover> ah, found it. System.Posix.Files.createNamedPipe
15:05:07 <fr33domlover> FIFOs in Haskell ^
15:05:14 <cdupont> geekosaur: I don't know
15:06:07 <geekosaur> fr33domlover, be aware there are some edge cases with FIFOs that ghc's runtime doesn't handle quite right. we've occasionally seen them when people try to use FIFOs from xmonad to communicate with outside programs
15:06:24 <geekosaur> (specifically it seems like there are some things that block which shouldn't)
15:07:13 <fr33domlover> geekosaur, hmm so if I have an IRC bot taking sysadmin commands via FIFO in those cases the entire bot process may get blocked?
15:07:15 <geekosaur> ...this may not actually be a problem for you depending on what you are doing; it's kinda noticeable when a window manager blocks unexpectedly
15:08:03 <fr33domlover> geekosaur, in my case it will rarely be getting anything on the FIFO
15:08:15 <fr33domlover> so i suppose getting blocked ruins the whole thing :P
15:08:15 <geekosaur> potentially yes. although if that is what you are doing then you really need to do some things that I think would prevent it anyway (notably you open it read-write)
15:08:39 <geekosaur> (because otherwise you get to use it once and have to close and reopen to accept another connection from the FIFO. FIFOs are weird_
15:09:27 <cdupont> Okkkk it works now
15:09:53 <cdupont> there was a cabal.config file in my directory I wasn't aware of :(
15:10:09 <fr33domlover> geekosaur, thanks. will open r/w. are there other things i should be aware of?
15:10:18 <fr33domlover> i could also use a unix socket instead, btw
15:10:28 <cdupont> thanks guys
15:10:37 <fr33domlover> just using FIFO because it seems enough for my use case
15:10:43 <fr33domlover> single client at most, etc.
15:11:11 <geekosaur> FIFOs seem simple but the edge cases are weird
15:11:37 <geekosaur> unix sockets may well be preferable; they at least behave like people expect them to, whereas FIFOs violate many people's expectations
15:17:45 <MitchellSalad> hi, is it straightforward to turn a non-recursive ADT into its "canonical" form using GHC.Generics?
15:18:08 <MitchellSalad> e.g. data Foo = Foo Int | Bar String Int   becomes  data GFoo = Either Int (String, Int)
15:18:25 <glguy> no
15:18:35 <MitchellSalad> or rather, i just need a function Foo -> Either Int (String, Int)
15:24:51 <drewbert> Hello, all.  Coworker and I are working on some haskell tooling for our company.  Our libraries play well together, but he ended up using DocOpt, and I use optparse-applicative.  Is there a standard?
15:26:25 <kadoban> drewbert: Never heard of DocOpt, and optparse-applicative seems to be used everywhere. Not that that means anything.
15:27:48 <Welkin> DOC OCK
15:27:54 <sm> optparse-applicative and cmdargs are the most featureful
15:28:20 <bergmark> System.Console.GetOpt is in base
15:28:41 <Clint> docopt is fascinating
15:28:48 <sm> somebody should make a guide to opt libs
15:29:15 <drewbert> There's a list of opts libs, and a short reddit discussion about it.  
15:31:18 <dcoutts> drewbert: wow, docopt looks horrific :-)
15:31:37 <drewbert> thanks for the ammo, dcoutts
15:32:08 <dcoutts> drewbert: I grudgingly use optparse-applicative on several company projects
15:32:28 <drewbert> dcoutts: What do you prefer, and why?
15:32:43 <bergmark> i grudingly fix breaking changes i don't understand in optparse-applicative about twice a year :)
15:33:17 <dcoutts> drewbert: of the available ones optparse-applicative is ok. I can't help feeling one could do better however.
15:33:22 <johnw> bergmark: same
15:34:07 <geekosaur> option parsing is kind of annoying in any language though
15:34:09 <dcoutts> dreamdust: there's some stuff inside cabal that could be nice if someone cleaned it up, but that's not an immediate choice for other uses, so optparse-applicative it is
15:34:14 <dcoutts> oops
15:34:18 <dcoutts> drewbert: ^^
15:34:28 <dcoutts> too many people with dre* names :-)
15:34:35 <Welkin> DR DRE
15:34:50 <kadoban>  /nick dreoban
15:34:58 <refefer> hmm, any clues how I can check if Warp is using sendfile?
15:35:00 * geekosaur has a horrid thing he uses in perl that does pretty much anything you could want, but the option specification is sucky and don't ever look at the implementation >.>
15:35:09 <dcoutts> refefer: strace?
15:35:27 <refefer> hmm
15:35:43 <geekosaur> (it's a severe abuse of the standard Getopt::Long)
15:36:07 <refefer> dcoutts: yep, no sendfile being used
15:36:15 <refefer> any clue how to turn on sendfile in warp?
15:36:29 <dcoutts> drewbert: the main practical problem with optparse-applicative is that it's not very easily discoverable from the docs. Yes you can use applicative combinators but you've no idea what they'll really do, so figuring out how to do things like lists of options or optional options is an exercise in frustration, unless you know the trick already
15:37:12 <kadoban> dcoutts: You just mean you have to already know about 'many' and 'optional' and such already?
15:37:20 <johnw> I'd love a quasi-quoter that lets me specify options in a DSL that gets turned into an optparse specification
15:37:26 <geekosaur> no; they don't combine in the way you'd expect
15:37:35 <nineonine> hello everyone
15:37:37 <geekosaur> we've had a few people in here banging their heads against it
15:37:41 <dcoutts> refefer: cabal info warp,  reports there's a allow-sendfilefd flag
15:37:41 <nineonine> aeson-related question here
15:37:45 <kadoban> Ah, hmm.
15:38:01 <nineonine> lets say, i have data with 2 records
15:38:04 <kadoban> I've only messed with pretty simple ones, maybe I got kind of lucky.
15:38:08 <dcoutts> kadoban: something like that but I can't even remember myself and I know these abstractions
15:38:21 <nineonine> im using Generic fo toJSON / fromJSON
15:38:44 <nineonine> question:
15:39:01 <nineonine> do i have to wrap values in Maybe
15:39:11 <Welkin> you don't wrap anything in anything
15:39:20 <nineonine> if sometimes there wont be provided fields
15:39:23 <nineonine> sorry
15:39:24 <nineonine> :)
15:39:32 <Welkin> yes, for optional fields, you use Maybe a
15:39:40 <Welkin> for the associated datatype
15:40:10 <nineonine> so Generics wont handle it for me ?
15:40:32 <Welkin> of course not
15:40:37 <Welkin> if you define a datatype
15:40:45 <Welkin> how do you expect it to know you want them to be optional?
15:40:55 <Welkin> the Maybe tells you it is optiona;
15:41:43 <nineonine> fair enough 8)
15:41:46 <nineonine> thanks !
15:42:12 <nineonine> btw why is it wrong to say “wrap values in …” ?
15:42:13 <nineonine> :D
15:42:14 <Welkin> for required fields, you do not use Maybe
15:42:16 <Welkin> of course
15:42:30 <Welkin> nineonine: well, that is just a metaphor for monads
15:42:35 <Welkin> "wrapping" things in other things
15:43:35 <nineonine> aight
15:43:37 <nineonine> thanks !
15:43:42 <refefer> dcoutts: dumb question: how do I enable it?
15:45:28 <geekosaur> refefer, sounds like you need to build warp with --flags=allow-sendfilefd
15:47:03 <sm> I second dcoutts re optparse-applicative, it's poorly documented
15:47:59 <sm> until that changes, cmdargs is my go-to (but I don't enjoy it..)
15:52:04 <quchen> I third that
15:52:12 <quchen> It's a really nice library, but the docs are terrible
15:52:24 <quchen> Well, not terrible, but non-existent
15:52:24 <Sonolin> Welkin Maybe is a monad right?
15:52:35 <drewbert> I actually love optparse, but maybe it's cause I'm on the other side of the struggle.
15:52:38 <Sonolin> so "wrap" isn't a terrible word in that context IMO
15:52:41 <quchen> Sonolin: Try :i in GHCi, it shows you all instances of a type
15:52:55 <quchen> drewbert: What's the other side?
15:52:57 <Sonolin> yea
15:53:06 <Sonolin> instance Monad Maybe -- Defined in `Data.Maybe'
15:53:32 <kadoban> I'm not sure how it being a Monad or not determines if 'wrap' is an appropriate word for what it does?
15:53:51 <drewbert> quchen: I just use it and it gives me my arguments, typed as I want, and generates a pretty help text.
15:54:23 <Sonolin> well I just mean its not a bad way to think of it conceptually for a beginner
15:54:29 <quchen> It was a pretty frustrating experience for me to try to use it.
15:54:31 <drewbert> But I do remember going through some pain getting to that point.
15:54:33 <Sonolin> but idk I've been wrong before
15:54:43 <quchen> *Unnecessary* pain. :-/
15:54:52 <dcoutts> refefer: cabal install whatever --constraint='warp -the-flag' --constraint='warp source'
15:55:02 <dcoutts> refefer: the latter ensures it will rebuild it
15:55:33 <drewbert> It's haskell.  Everything is unnecessarily painful up to the point that it becomes magically helpful.
15:55:43 <quchen> No.
15:55:56 <dcoutts> or in the new cabal nix-local-build branch you'd just say in your cabal.project file: package warp { flags: -the-flag-in-question }
15:56:02 <quchen> Look at pipes. It's not painful, and it's magically helpful. That's how everything should be.
15:56:11 <dcoutts> and it'd automagically rebuild it if needed
15:57:24 <refefer> dcoutts: oh interesting.  hopefull stack has an equivalent
15:57:31 <quchen> Looking at current optparse, it seems the docs improved a lot. Cool!
15:59:15 <dfeuer> Yes.
15:59:32 <dfeuer> optparse-applicative documentation is utterly wretched. The motion passes.
15:59:51 <dfeuer> quchen, pipes is extraordinarily painful. 
16:00:10 <dfeuer> Ooh, missed quchen's last comment on new documentation.
16:00:14 <dfeuer> That sounds exciting.
16:00:20 <mgsloan> refefer: "stack build --flag warp:allow-sendfilefd"
16:00:26 <quchen> It's more than nothing, which is what it used to be.
16:00:33 <mgsloan> Or, add an entry to "flags" in your stack.yaml
16:00:35 <dfeuer> Oh.
16:01:01 <mgsloan> (which is preferable if you need to have that flag set for your project to work)
16:01:37 <athan> What does it mean to "unmask" an exception?
16:03:13 <Welkin> athan: what does it mean when a mommy loves a daddy, very very much?
16:04:04 <geekosaur> masked exceptions will be "on hold", there but not delivered. when you unmask, pending exceptions will be sent. ghc does this by blocking a thread that tries to throw an exception to a thread that has that exception masked
16:05:28 <quchen> athan: Marlow's book has a nice explanation of this as well, although geekosaur said most of it already
16:05:52 <Welkin> ohh
16:06:06 <Welkin> that reminds me of microcontrollers
16:06:08 <Welkin> same thing
16:06:15 <geekosaur> pretty much
16:06:30 <geekosaur> also masked interrupts in kernel programming
16:06:42 <geekosaur> and Unix signals have a similar mechanism
16:07:03 <geekosaur> s/Unix/POSIX/ although there are some gotchas on some platforms...
16:09:31 <athan> geekosaur: That's very interesting. So that's how bracket works... huh
16:09:39 <athan> thank you!!
16:10:17 <athan> Welkin: good question
16:12:25 <kadoban> The warning from importing Control.Applicative in 7.10 makes me sad :-( still not happy with any of the actual solutions
16:13:11 <fr33domlover> kadoban, what does it say?
16:13:17 <fr33domlover> still using 7.8 here
16:13:35 <kadoban> fr33domlover: It's redundant, since a bunch of that is in Prelude already.
16:14:14 <fr33domlover> and i imagine the other part is in Control.Monad if Monad is now a subclass of Applcative? :P
16:15:04 <kadoban> Naw it's usually just that and Monoid, modules that had stuff added to Prelude.
16:15:12 <fr33domlover> suddenly 'pure' can be used in many places where only 'return' could be
16:15:31 <fr33domlover> kadoban, i see, good to know
16:16:02 <kadoban> It's not that big of a deal really, it's just that the solutions are kind of meh, but if you want to compile without warnings in both, you have to.
16:16:50 <fr33domlover> kadoban, unless you use CPP to check base version >= 4.8 ?
16:17:04 <kadoban> Yes, CPP is one solution
16:17:22 <fr33domlover> i did it once, but it's somewhat ugly to do all the time
16:17:29 <fr33domlover> just let the change sink :P
16:44:14 <Guest00000> why seq isn't a typeclass? is it that hard?
16:44:41 <bitemyapp> Guest00000: nah, it used to be a typeclass.
16:44:59 <bitemyapp> Guest00000: but it isn't any longer because the constraint would percolate up your whole codebase when you needed to experiment and it was obnoxious.
16:45:00 <Guest00000> whut
16:45:11 * hackagebot serv 0.1.0.0 - Dependently typed API server framework  https://hackage.haskell.org/package/serv-0.1.0.0 (JosephAbrahamson)
16:45:16 <bitemyapp> made it so you couldn't really "experiment" with strictness in a non-trivial codebase.
16:45:19 <bitemyapp> so, gone now.
16:45:21 <acertain> deepseq is a typeclass
16:45:30 <bitemyapp> NFData is, yes.
16:45:44 <bitemyapp> but that does something different and isn't baked in.
16:45:48 <Guest00000> why not "unsafeSeq" then?
16:45:57 * bitemyapp shrug
16:46:00 <Guest00000> experiment with unsafeSeq...
16:46:39 <acertain> it's not unsafe unless you use unsafePerformIO or undefined or loop forever
16:48:33 <Hijiri> it would be unsafe if you defined your language to have \_ -> _|_ = _|_ semantics
16:48:48 <Hijiri> so if you labelled it unsafe you could do that
17:06:08 <drw__> I'd like to embed an icon in an exe (on Windows).  I have done so with ghc after "ghc --make main.hs icon.o".  Is there a similar method to achiev this with "cabal build" working in a sandbox?
17:06:43 <dcoutts> drw__: ld-options
17:06:52 <dcoutts> in the .cabal file
17:08:19 <drw__> dcoutts: thx
17:15:00 <mpickering> Why is the time taken reported by profiling about 15x less than the actual time taken?
17:17:59 <Moto-chan> mpickering: Because if you're profiling correctly... your profiler is reporting CPU time taken.
17:18:12 <mpickering> right
17:20:24 <xcv_> Is there a package that allows me to read a public RSA key from a PEM file? (I'm already using cryptonite, so preferably without HsOpenSSL)
17:21:30 <Clint> xcv_: is it an x.509 certificate or something else?
17:23:28 <xcv_> I don't think so, but I'm not an expert
17:23:33 <xcv_> it's something like this: http://pastebin.com/UBAJGTLr
17:24:04 <xcv_> that's what the command-line openssl tool outputs when exporting the public key to PEM
17:24:16 <xcv_> Clint: ^
17:24:17 <Clint> xcv_: start with the pem package i guess
17:24:58 <xcv_> how can I get any information from that though?
17:25:13 <xcv_> it just seems to parse a couple of headers and a "body" bytestring
17:30:13 * hackagebot gnss-converters 0.1.2 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.2 (markfine)
17:30:15 * hackagebot directory 1.2.5.0 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.5.0 (Rufflewind)
17:30:48 <glguy> xcv_: OK, I have some bits you can use
17:31:21 <glguy> I don't know if there's a more direct way, but I was at least able to decode your key using the x509 and asn1 packages
17:31:25 <glguy> I'll paste 
17:31:37 <xcv_> that sounds great, thanks
17:32:47 <lpaste_> glguy pasted “for xcv_” at http://lpaste.net/147306
17:33:28 <glguy> I removed the header and footer lines manually before base-64 decoding it
17:33:45 <glguy> It's possible all of that's bundled up somewhere, but I just don't happen to know where that would be
17:34:47 <xcv_> hhm good to know
17:34:50 <Clint> glguy: used to be in certificate
17:35:05 <Clint> xcv_: you could presumably just decode the bytestring you get back from pem
17:35:48 <xcv_> oh, nice
17:35:51 <xcv_> that's cleaner
17:36:54 <glguy> If you had the openssl rsa command output DER instead of PEM you wouldn't need to manually remove the PEM layer
17:38:38 <xcv_> so DER is literally that base64 string, right?
17:40:04 <glguy> Yeah, PEM is just the base-64 encoded DER + the header/footer afaik
17:58:11 <xcv_> glguy, Clint: just adapted your code and worked like a charm, thanks!
18:15:17 <catsup> i've been wrestling for a while with linker errors...  in order to make this call out to C, i apparently need to build this project with one cabal file, then when it fails, edit the file and build it again.  but if i then clean and build it with that same file, it also fails.  either the linker says multiple definition of the same symbol, or else no such symbol.
18:15:42 <catsup> does anybody know wtf could be wrong?
18:17:12 <catsup> what i'm changing is to either have the library used by the executables listed in the cabal file, or not.  if it's listed, i'll get multiple definition of the symbol; if it's not listed, but i've got the leftover .o files, then i get good binaries.  but if it's not listed and i don't have those .o files, i get no symbol found
18:17:36 <glguy> catsup: Do you have the library and executable using the same source directory?
18:17:40 <catsup> i think i might have been also adding c-sources: to the individual executables
18:17:43 <catsup> glguy: yes
18:17:49 <glguy> catsup: You shouldn't be
18:19:48 <catsup> k...
18:19:50 <glguy> The c file should only be included in one ofthe two components
18:21:16 <catsup> i had set up a separate library component to do the c-sources line
18:21:26 <catsup> is that necessary?
18:21:36 <glguy> Is the project up github? (or somewhere else easy to link to)
18:21:40 <catsup> no
18:24:06 <catsup> sigh
18:24:34 <catsup> i moved the library files to lib/ and put hs-source-dirs: lib and it says it can't find source in '.'...
18:27:50 <catsup> is that what you meant to do?
18:28:11 <glguy> Yeah, your library haskell source files should be in their own directory
18:28:25 <glguy> shouldn't cause an error, so something else is wrong
18:29:25 <catsup> i've got lots of modules in the same dir...  the only problem is with the one that is using ffi
18:32:54 <catsup> hm.  simplified the behavior a bit, i don't need the 'library' stanza at all to get it to compile.  i just need to compile once with 'c-sources' and then compile again without it.
18:32:59 <glguy> https://github.com/glguy/how-to-call-c
18:33:12 <glguy> minimal example of a library that has a c file and an executable that uses the library
18:34:02 <placer14> I have some error codes I don't understand how to resolve. Is anyone willing to help me learn to fish?
18:34:12 <glguy> ?lpaste
18:34:12 <lambdabot> Haskell pastebin: http://lpaste.net/
18:34:41 <glguy> placer14: Put the output you don't understand on the paste bin and ask and then people will chime in if they can help
18:35:12 <catsup> glguy: well, that compiles.
18:35:14 <placer14> I believe my error is tied to my code and not sure I could post enough of it. But I'll give it a whirl.
18:36:29 <placer14> http://lpaste.net/4379788502049488896
18:37:32 <catsup> glguy: that example also compiles if i move all the files into the same directory, though
18:37:34 <glguy> placer14: Does it work if you replace 'a' in your type signature with the type shown in the rror message?
18:37:38 <catsup> (changing the cabal file to match)
18:37:49 <glguy> catsup: doing that causes problems later
18:38:02 <glguy> you redefine all the types in the library inside your executable
18:38:06 <catsup> one thing it does have that i don't is a build-depend for the executable on its own package
18:38:09 <glguy> and duplicate everything
18:38:30 <glguy> if you're going to do that you shouldn't have a library section at all
18:38:38 <catsup> i don't want a library section
18:38:52 <catsup> i only added it to try to fix the linker problem
18:39:00 <glguy> OK, then get rid of it :)
18:39:16 <catsup> i did
18:39:21 <catsup> 21:32 <catsup> hm.  simplified the behavior a bit, i don't need the 'library' stanza at all to get it to compile.  i just need to compile once 
18:39:24 <catsup>                with 'c-sources' and then compile again without it.
18:39:49 <glguy> You should put your cabal file on the pastebin
18:39:57 <glguy> I can't do mental diffs of what it looks like
18:41:59 <fMap_> hey; is anyone out there doing much gis in haskell? what libraries are you using?
18:43:47 <fMap_> terraHS requires base<= 4. it doesn't seem to be updated recently...
18:43:55 <placer14> glguy: I fall into another rabbithole dealing with ClassTypes... http://lpaste.net/4379788502049488896
18:45:34 <glguy> placer14: Cool, you're making progress
18:47:17 <glguy> placer14: This means you need
18:47:32 <glguy> 03instance ToMessage (JavascriptUrl a) 03where 07...
18:48:00 <glguy> Because ToMessage expects an argument with kind *, but Javascript has kind * -> *, so you have to apply it to a type first
18:48:32 <glguy> or it's possible you need a more specific type there than 'a', I don't know how ToMessage works
18:51:45 <placer14> glguy: "apply it to a type first", I'm a Haskell novice
18:51:50 <placer14> What does this mean
18:51:58 <catsup> ha!
18:52:09 <catsup> glguy: i reproduced the error in the repo you gave me
18:52:29 <catsup> ...by renaming the .c file to have the same basename as the haskell library!
18:52:51 <glguy> ah, maybe you aren't allowed to do that :)
18:52:52 <catsup> (just as it is, in my own source)
18:53:39 <glguy> placer14:  f x    is "f applied to x"
18:53:50 <placer14> Okay, thanks.
18:54:13 <catsup> ...yep, renaming the .c file fixed it in my repo  :)
18:55:16 <placer14> ToMessage is used by Happstack.Server to build a Response
18:56:07 <placer14> glguy: My next edit: http://lpaste.net/4199990949016764416
18:56:58 <placer14> Is this error saying it expects a function instead of a thing without detailing the type?
18:58:02 <julianleviston> placer14: Isn’t that message saying ToMessage requires something that has kind *…. (as in a type), not a thing that takes an argument and produces a type (JavascriptUrl seems to be a type constructor which takes an argument)
18:58:32 <placer14> Yes, It is a type constructor.
18:59:17 <julianleviston> placer14: so shouldn’t you actually provide it with an argument then?
18:59:51 <placer14> That's where I'm a bit lost. I'm not sure what it expects and how to consume the docs to know what to give it.
19:00:04 <julianleviston> placer14: can you ask GHCi what its type is?
19:00:04 <placer14> I know the type sig should lead me there, but I think I'm missing something.
19:00:11 <placer14> which javascriptUrl?
19:00:15 <julianleviston> placer14: what is it? (sorry I just came in… )
19:00:28 <placer14> Which? `:t JavascriptUrl?`
19:01:05 <placer14> JavascriptUrl comes from this: https://hackage.haskell.org/package/shakespeare-2.0.7/docs/Text-Julius.html
19:01:18 <julianleviston> I’ll take a look
19:01:51 <placer14> Thank you.
19:02:59 <placer14> My objective is to take my existing Happstack app and include some JS. I've decided static assets aren't going to be very nice for my deployment process. So i'm trying to include compiled JS.
19:03:20 <julianleviston> placer14: ok so JavascriptUrl is a type synonym… (url -> [(Text, Text)] -> Text) -> Javascript
19:03:24 <julianleviston> placer14: you obviously got that far.
19:03:44 <placer14> I have some example code which uses Text.Cassius for compiled CSS and I'm trying to use that as a template for building this functionality for JS.
19:04:07 <julianleviston> but that’s not a type… it’s a parameterised type… so you have to type the URL.
19:04:29 <julianleviston> if you want to build an instance of ToMessage
19:04:53 <julianleviston> placer14: what types do your URLs have? Or am I missing something (I’ve never happstacked, by the way)
19:05:34 <julianleviston> placer14: can you go into GHCi and ask it what the type of javascriptView is ?
19:06:11 <placer14> That's what I'm implementing. javascriptView wants to be `JavascriptUrl url0`
19:06:25 <julianleviston> what’s url0 ?
19:06:42 <julianleviston> what kind of type is that? a type variable?
19:07:18 <julianleviston> placer14: I think I need to read a bit more about julius in happstack before I help you
19:07:19 <placer14> it's a type var. Here is the example I'm following (and also the app I'm attempting to implement this in): https://github.com/flipstone/glados/blob/master/src/Handler/Style.hs
19:08:43 <julianleviston> placer14: yeah but your problem is obviously that that instance can’t take something with a type var… it can only take a concrete type...
19:08:56 <placer14> Obvious to you maybe :P
19:08:59 <julianleviston> (that typeclass, when you’re instancing it)
19:09:01 <julianleviston> oh sorry
19:09:12 <julianleviston> placer14: that’s what that error means
19:09:51 <julianleviston> placer14: it means “hey, if you want to make this type a typeclass instance of this class, you can’t… because I need a concrete type to make an instance of”
19:11:24 <placer14> I understand what you're saying.
19:11:35 <julianleviston> Like… for example… a Maybe. Maybe has a kind of * -> *, too… which means Maybe by itself is a type constructor. It’s a type that MAKES other types. In this case, it makes concrete types. Maybe Int, however *is* a concrete type.
19:11:40 <julianleviston> ah ok
19:11:40 <julianleviston> cool
19:12:19 <julianleviston> placer14: can you point me at the Happstack source where JavascriptUrl is defined so I can take a look at it?
19:12:49 <placer14> `[julius| javascripthere |]`is a QuasiQuote "generator" (unsure of the nomenclature). It returns a type `JavascriptUrl a` based on what I read here: https://hackage.haskell.org/package/shakespeare-2.0.7/docs/Text-Julius.html
19:13:08 <julianleviston> sur
19:13:11 <julianleviston> sure*
19:13:37 <placer14> I think this is what you want? https://hackage.haskell.org/package/shakespeare-2.0.7/docs/src/Text-Julius.html#JavascriptUrl
19:14:35 <clunesy> Hello
19:15:41 <julianleviston> placer14: yeah, sorry, you’ll have to bear with me as I stumble along :) hopefully I’ll help :)
19:15:56 <placer14> It's almost certainly better than I'm doing alone.
19:15:59 <cmk_zzz_> I want to access a SQL database from haskell. Reading the yesod docs it says to use Esqueleto for SQL, but even esqueleto is quite limited in what it supports. Both recommend against rawSQL but what other optiosn are there?
19:16:31 <placer14> cmk_zzz_: Most of my sparse experience as had a custom ORM involved.
19:16:58 <julianleviston> cmk_zzz: there are heaps. Take a look at the “haskell SOTU” (google for it)… but the one I use is called groundhog. It has some pretty complex types, tho… if you’re a new person it might not be best.
19:17:01 <placer14> Yesod's Persist seems like a reasonable start, but don't expect associations or joins.
19:17:23 <julianleviston> cmk_zzz: yeah, Groundhog has joins and associations, which is really nice. 
19:17:40 <julianleviston> cmk_zzz: if you can work it out, it’s great. The examples *really help*.
19:17:41 <cmk_zzz_> placer14: persist is way to limited. I need pretty complex SQL queries and any standard ORM usually wont work.
19:17:54 <cmk_zzz_> julianleviston: I'll have a look at groundhog
19:18:15 <cmk_zzz_> is raw sql really that unsafe? 
19:18:32 <Adeon> my favorite is postgresql-simple although it means you need to use postgresql
19:18:48 <cmk_zzz_> Adeon: that is the target so I'll look into that too
19:18:51 <julianleviston> Adeon: and it doesn’t do joins, does it?
19:18:56 <Adeon> it's not high-level
19:19:01 <Adeon> you mostly write raw sql
19:19:08 <Adeon> it gives you type-safe substitutions
19:19:17 <julianleviston> Adeon: yeah, it’s bare-bones. But if he wants to do complex things, that might be best, actually.
19:19:35 <Adeon> I don't know what's so terribly wrong about writing sql itself
19:19:41 <Adeon> but it might be just me
19:19:47 <placer14> cmk_zzz_: Here's some of the custom stuff my expert has made over Persist: https://github.com/flipstone/glados/blob/master/src/Database/Associations.hs
19:19:47 <julianleviston> yeah, it’s a pretty good DSL.
19:19:59 <Adeon> the documentation of postgresql-simple says something about being based on mysql-simple so maybe that's a package too
19:20:26 <julianleviston> Adeon: yeah, it is. 
19:20:27 <cmk_zzz_> absolutely:) The thing is I work with lots of languages and I am very good at SQL. WHich meanas I need to learn yet another ORM or database library often with leaky abstractions. If I can do raw sql in a sort of safe way I'd be happy
19:20:35 <julianleviston> Adeon: by the guy who wrote Real World Haskell :)
19:20:44 <Adeon> ooh
19:20:59 <Adeon> yeah postgresql-simple should definitely be your thing then
19:21:26 <cmk_zzz_> Cool. Thanks guys. I'll look into this
19:21:39 <julianleviston> cmk_zzz: assuming by safe you mean “don’t want no sql-injections” ?
19:21:53 <NeverDie> Anyone want to join me on a project to build a virtual stock algorithmic trading platform? 
19:21:58 <NeverDie> Just for the fun of it and learning purposes. 
19:23:20 <julianleviston> placer14: I’m not too sure I’m going to be much help working out the type of a julius quasi-quoter. I don’t know enough about TH, really.
19:24:09 <cmk_zzz_> julianleviston: yes, that is one part of it, but I got the impression from reading yesod doc that they also mean unsafe as not type safe. Basically if sql injection is prevented and the server doesn't crash if I feed the wrong type I'm doing OK
19:24:13 <placer14> h'okay, thanks for the willingness.
19:24:40 <julianleviston> cmk_zzz_: I don’t understand how it can be not typesafe if it’s written in Haskell
19:24:56 <Adeon> may not be typesafe on sql side but sql just throws exception
19:24:58 <julianleviston> placer14: I try to avoid TH magic, precisely because I don’t understand TH yet.
19:25:08 <milesrout> what are monads? 
19:25:10 <milesrout> just kidding
19:25:11 <julianleviston> Adeon: oh ok
19:25:25 <cmk_zzz_> julianleviston: just something I picked up from yesod docs: "Write the SQL explicitly with rawSql. While somewhat convenient, this loses a lot of Persistent’s type safety."
19:25:47 <julianleviston> cmk_zzz_: oh… what they mean there is that your values will be sure to be the values you want them to be.
19:25:47 <Adeon> postgresql-simple has that "SELECT * FROM blah WHERE ? = blah" where you give the values to plug in as a separate argument
19:26:03 <Adeon> I think that's common in sql bindings
19:26:23 <cmk_zzz_> yes postgresql-simple looks like the sort of interface I am after
19:26:33 <Adeon> sometimes it's a bit heavy on types
19:26:38 <Adeon> for example you can't get raw UTCTime out of it
19:26:57 <Adeon> IIRC you instead get Bounded UTCTime which can be infinity or negative infinite or "Finite UTCTime"
19:26:59 <milesrout> Haskell is to Common Lisp as what is to Scheme? Is there reasonably well-known, slightly more elegant pure functional programming language like Haskell but designed more for research purposes than Haskell, which is clearly designed more pragmatically?
19:27:03 <cmk_zzz_> Adeon: I'm new to haskell so I might as well start the type heavy stuff and ease back on it later ;)
19:27:11 <Adeon> ah sure
19:27:38 <Hijiri> milesrout: there are dependently-typed languages like Idris or Agda
19:27:56 <Hijiri> Idris is designed to be pragmatic, though
19:27:58 <julianleviston> milesrout: typescript? elm?
19:28:01 <Hijiri> I think
19:28:22 <exio4> julianleviston: those are more `pragmatic` than Haskell, I would say :p 
19:28:26 <milesrout> something that could, for example, be used (as in, go implement a simple and reasonably featureful compiler for X) in a 3rd year-ish computer science course looking at functional programming
19:28:32 <julianleviston> exio4: he asked conflicting things
19:28:42 <julianleviston> milesrout: hang on… MORE researchy than Haskell, but also more pragmatic?
19:28:45 <exio4> well, right
19:28:54 <julianleviston> milesrout: what do you mean?
19:28:57 <milesrout> julianleviston: I said Haskell is more pragmatic
19:29:18 <julianleviston> milesrout: ok so you want something less pragmatic but more reseachy but well known?
19:29:47 <milesrout> julianleviston: doesn't need to be super well known, but preferably something with a small core of functionality
19:29:50 <Adeon> I'd say coq is even more researchy
19:29:58 <julianleviston> Adeon: ^ yes! this
19:30:00 <exio4> milesrout: maybe you want SML
19:30:09 <Hijiri> I don't think Coq could be implemented in a 3rd year course easily though
19:30:12 <exio4> milesrout: it's a dead language though
19:30:22 <julianleviston> exio4: lots of french people would disagree! :)
19:30:26 <milesrout> Scheme for example has a small core of 'special forms' from which everything else is (or at least can theoretically be) derived
19:30:29 <julianleviston> exio4: OCaml ?
19:30:42 <exio4> julianleviston: OCaml is quite nasty compared to SML
19:30:46 <exio4> which is really simple 
19:30:59 <milesrout> It's reasonably easy, in terms of total amount of work, for someone to implement a scheme interpreter as a project. 
19:31:11 <milesrout> I'm looking for something similar, but a pure functional programming language.
19:31:16 <julianleviston> milesrout: sure. That was its point.
19:31:23 <exio4> I see, for implementation purposes
19:32:01 <Adeon> I don't think it's too hard to write a compiler for a subset of haskell
19:32:07 <Adeon> unless haskell is already rejected
19:32:10 <julianleviston> how about haskell?
19:32:14 <julianleviston> core?
19:32:15 <milesrout> So dependently typed probably the wrong direction to go for, I'm thinking something with a very simple type system. without type classes. 
19:32:29 <julianleviston> milesrout: you want haskell’s core
19:32:34 <exio4> simple typed lambda calculus! :p
19:32:41 <julianleviston> yes :)
19:32:44 <exio4> simply*
19:32:53 <Adeon> complicatedly typed lambda calculus
19:32:56 <Hijiri> milesrout: should it be able to do input/output?
19:32:59 <milesrout> Thanks, I will look into haskell's core
19:34:43 <milesrout> core looks easier to parse as well
19:35:10 <milesrout> put less emphasis on getting that to work and more on the interesting type system-related stuff
19:37:25 <julianleviston> milesrout: http://strictlypositive.org/Easy.pdf
19:38:03 <julianleviston> milesrout: this is for a dependently typed calculus implementation.
19:38:12 <milesrout> that's pretty neat
19:38:15 <milesrout> thank you very much for the help
19:38:23 <milesrout> this looks nearly perfect
19:39:23 <julianleviston> :t methodM
19:39:25 <lambdabot> Not in scope: ‘methodM’
19:41:40 <acertain> milesrout, https://github.com/sweirich/pi-forall and http://hub.darcs.net/dolio/upts/browse/Language/UPTS/TypeCheck.hs are simple dependent types languages/typecheckers
19:42:23 <milesrout> thanks
19:49:24 <julianleviston> are there any more / better resources for explaining GADTs than https://en.wikibooks.org/wiki/Haskell/GADT ?
19:50:01 <julianleviston> reading this next: http://www.haskellforall.com/2012/06/gadts.html
19:50:49 <echo-area> julianleviston: I just started learn GADTs yesterday, and I found the paper /Fun with phantom types/ quite good
19:50:59 <julianleviston> echo-area:  thanks.
20:25:19 * hackagebot base-prelude 0.1.20 - The most complete prelude formed from only the "base" package  https://hackage.haskell.org/package/base-prelude-0.1.20 (NikitaVolkov)
20:27:38 <arahael> So, I'm using hspec, and I am wondering howI should best test a function that returns an Either.
20:27:49 <arahael> I've got things like: isLeft result `shouldBe` True
20:27:55 <arahael> I'm wondering if there is a more elegant approach.
20:28:49 <coercively> Can someone here help me with a hardware issue?
20:28:52 <coercively> (:
20:29:17 <arahael> coercively: Did you try turning it off and then turning it back on again?
20:29:22 <coercively> haha
20:29:24 <coercively> funny
20:30:07 <milesrout> coercively: depends, is your hardware the language of mathematics?
20:30:31 <coercively> okay enough f'ing around
20:30:42 <coercively> i don't know anything about computers
20:30:46 <coercively> but I know
20:31:01 <coercively> that cmos checksum bad
20:31:06 <coercively> is bad news
20:31:25 <nshepperd_> brain hardware
20:31:59 <coercively> someone on another irc told me I can't replace cmos
20:32:05 <coercively> wanted to confirm
20:32:25 <coercively> its an old battery
20:32:33 <arahael> coercively: It probably means your battery is dead.  That often happens for old computers as batteries only last a number of years.  Worst case: You'll have to re-enter the bios settings, or just ignore the message, depending on the BIOS you have and your computer configuration.
20:32:54 <coercively> okay thanks
20:33:01 <coercively> <3
20:34:07 <nshepperd_> can you do something like 'case result of { Right blah -> success; Left blaz -> failure }'?
20:35:31 <nshepperd_> but well, if you really only need to check that the result is Left, surely there's some kind of assert function like 'assert (isLeft result)'?
20:35:32 <arahael> nshepperd_: Is that in responseto my question? If so, I don't know.  Otherwise,yes, that's exactly what I'd like to do.
20:35:45 <nshepperd_> rather than using `shouldBe` True
20:35:58 <arahael> nshepperd_: Let me look - I'm *very* new to this, I didn't realise that there was an "assert"function like that.
20:36:41 <arahael> Hmm, no that function doesn't exist, it seems.
20:36:53 <nshepperd_> I don't know anything about hspec, it would just seem weird for that not to exits
20:37:20 <arahael> It may work with an assert function from a different module.
20:37:50 <nshepperd_> oh, maybe you want 'result `shouldSatisfy` isLeft'
20:39:18 <arahael> That looks very elegant, but unfortunately fails because the type for 'right' doesn't have a show instance.
20:40:07 <pop_> hey
20:40:29 <arahael> nshepperd_: Which I find is a curious answer, because Id on't actually care about 'right' in this particular test.
20:41:38 <pop_> whats gayer than a freenode chatroom full of slaves to an obsolete functional programming language?
20:41:55 <pikhq> ... #gnaa?
20:42:17 <newsham> pop: trolls, i guess, are worse.
20:43:02 <nshepperd_> arahael: presumably it's because it wants to print out the value if it fails to be a Left (ie. is Right something)
20:43:16 <arahael> nshepperd_: That may be the case, yeah.
20:43:20 <solirc> arahael: x `shouldSatisfy` isLeft
20:43:34 <arahael> solirc: 'x' in this case does not have a show instance.
20:46:06 <solirc> arahael: then I would go with your solution
20:46:24 <arahael> solirc: Thanks. :)  I'm looking for where hspec documents the 'should...' functions.
20:46:46 <arahael> But having trouble finding this from hspec.github.io
20:47:11 <solirc> arahael: https://github.com/hspec/hspec-expectations#readme
20:47:47 <arahael> Wonderful - thanks. :)
20:48:07 <solirc> arahael: Alternatively you can also use assertBool
20:48:12 <solirc> from HUnit
20:48:27 <solirc> e.g. asssertBool "not Left" (isLeft x)
20:48:46 <solirc> but I'm not sure if that is any more beautiful
20:49:07 <solirc> arahael: and also here http://hspec.github.io/expectations.html
20:50:10 <echo-area> data DSum tag = forall a. !(tag a) :=> a   <-- What does ! here mean?
20:51:17 <solirc> arahael: yet an other way is to use Blind from Test.QuickCheck.Modifiers, e.g. Bling x `shouldSatisfy` isLeft . getBlind
20:51:53 <arahael> solirc: Where should I read about these?
20:52:03 <solirc> arahael: Blind?
20:52:10 <arahael> Yes, and these techniques in general.
20:52:11 <solirc> arahael: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Modifiers.html
20:52:31 <arahael> Thanks. :)
20:52:32 <solirc> arahael: I'm not sure if there is any good documentation out there
20:53:19 <Skuzzzy> Theory, type theory, functional, pure, side effect, strong typing, esoteric, no support
20:54:37 <Axman6> Skuzzzy: you writing out #haskell keywords? =)
20:55:01 <Skuzzzy> I wrote every word that comes to mind when I open this channel
20:55:25 <Skuzzzy> I'm actually way to much of a java/python pleb to come close to the haskell crowds understanding of the universe
20:55:50 <Skuzzzy> I did a little bit, folds, list compehensions first class functions really cool, started using them more, and haskell less
20:58:44 <Hijiri> echo-area: it means the :=> constructor is strict in the first argument
20:58:52 <Hijiri> so if k doesn't terminate, then neither does k :=> x
20:59:17 <fyt> mmm
20:59:24 <Hijiri> so basically if you evaluated a DSum so that you get the :=>, you are also evaluating the thing on the left
20:59:30 <fyt> I'm a skid. jfc.
20:59:59 <echo-area> Hijiri: Thanks, my initial guess was indeed something with strictness
21:01:43 <echo-area> Hijiri: Also the tag is not phantom right?
21:02:22 <Hijiri> tag is not phantom
21:02:50 <Hijiri> the argument to tag in the uses I've seen usually isn't phantom
21:02:55 <Hijiri> but it's possible for it to be
21:03:09 <Hijiri> actually I'm not sure if it's possible
21:03:39 <Hijiri> actually it could be, but then I think you couldn't have a GEq instance, so you couldn't use it in the functions that expect one
21:04:27 <lpsmith> Adeon, you can work with plain old UTCTime in postgresql-simple,  as long as you know that the data coming back isn't one of the two infinities.  :)
21:04:34 <echo-area> Okay, thanks.  I am a newbie to this, I think I need to play with it for a while
21:05:03 <FelixNemis> I'm doing one of the advent of code problems, and I can't figure out why I'm getting a type mismatch, could some one help
21:05:10 <FelixNemis> this is what I have currently
21:05:15 <lpsmith> You don't *have* to use the UTCTimestamp type that supports the infinities.
21:05:15 <FelixNemis> https://github.com/FelixNemis/adventOfCode2015/blob/master/day_6.hs
21:06:48 <FelixNemis> It seems to think I'm applying too few arguments, but as far as I can tell I'm not
21:07:45 <kadoban> FelixNemis: What's the error?
21:08:57 <FelixNemis>  Couldn't match type `Array (Int, Int) Bool -> Array (Int, Int) Bool'         with `Array (Int, Int) Bool'  Expected type: LightArray1
21:09:17 <FelixNemis> LightArray1 is = Array (Int, Int) Bool
21:10:00 <kadoban> FelixNemis: Can you lpaste it? There's usually more context, and I'm not sure which part it's refering to.
21:10:20 <FelixNemis> yeah, just a sec
21:11:00 <FelixNemis> http://pastebin.com/twQQe4Sc
21:11:16 <nshepperd> FelixNemis: toggleLights
21:11:37 <nshepperd> Your wrote it in point free form but left the argument in?
21:12:53 <FelixNemis> wait
21:13:10 <kadoban> Ah, yeah that looks like it.
21:13:29 <nshepperd> Either remove the second argument there or un-pl-ify the function body
21:13:41 <FelixNemis> oh I see
21:13:56 <FelixNemis> I just need to add it at the end
21:13:59 <FelixNemis> Thanks
21:14:02 <kadoban> Doesn't look like they can remove the 'lights' argument, it's used in the list comprehension
21:14:04 <kadoban> Right
21:14:44 <kadoban> Not that it really matters, but you should probably just remove the 'flip' and use // infix with whatever arguments if you're doing that.
21:15:32 <FelixNemis> good point
21:18:16 <Adeon> lpsmith: I thought plain UTCTime doesn't implement the necessary typeclasses? except from haskell to postgres, not the other way around
21:18:22 <Adeon> hmm, I could be wrong
21:40:43 <lpsmith> Adeon, UTCTime has both ToField and FromField,  but you'll get an exception if you try to convert an infinity timestamp to UTCTime
21:45:47 <Chobbes> What does GHC actually do when it sees this: https://github.com/haskell/zlib/blob/85f2d95396ff884ff22af62e5e0d6029c789db63/Codec/Compression/Zlib/Stream.hsc#L1039
21:46:01 <Chobbes> The C FFI ${const sizeof(z_stream)} that is.
21:56:14 <anohigisavay> hi. i don't understand the Functor signature (as in categories)
21:56:36 <anohigisavay> class (Category r, Category t) => Functor f r t | f r -> t, f t -> r
21:57:03 <anohigisavay> what does `f` mean?
21:57:40 <anohigisavay> fmap :: r a b -> t (f a) (f b)
21:59:55 <lyxia> anohigisavay: it's a mapping between categories
22:00:04 <anohigisavay> so type (f a) is in category t?
22:00:49 <MitchellSalad> yeah
22:02:01 <MitchellSalad> t is inhabited by all "f x" things
22:02:34 <MitchellSalad> rather, t's objects* are "f x"s
22:03:58 <anohigisavay> so this fmap is really a map between morphisms in r to morphisms in t?
22:04:54 <lyxia> yes
22:05:12 <MitchellSalad> and the type constructor f is the other "half" of the mapping
22:05:12 <anohigisavay> for an fmap that maps objects it's of type :: c a a -> d (t a) (t a)? and maybe apply some id stuff?
22:07:05 <anohigisavay> i'm still confused why the types in d have to be of a composite type. can't it be like this: fmap :: c ca cb -> d da db?
22:08:03 <MitchellSalad> what do you mean?
22:09:35 <anohigisavay> for example X is in c and Y is in d. can't i map an X -> X morphism to Y -> Y?
22:10:00 <anohigisavay> and Y :: *
22:10:18 <anohigisavay> sorry, Y :: k2 or some kind
22:10:51 <lyxia> It's part of the definition of a functor that the mapping between objects and the mapping between morphisms should agree in some sense.
22:11:44 <lyxia> A morphism between a and b is mapped to a morphism between the images of a and b.
22:12:12 <MitchellSalad> anohigisavay: absolutely you can, but in Haskell the definition of the Functor typeclass does not correspond perfectly to a "real" functor, which as you say, simply maps objects to objects and morphisms to morphisms
22:13:33 <anohigisavay> hmm.. i think i need some time to digest your words
22:13:50 <liste> is Haskell functor a specific kind of functor from "a" in Hask to "f a" in Hask ?
22:14:00 <MitchellSalad> exactly
22:21:44 <anohigisavay> why is the concept Endofunctor needed anyway? ain't all those functors simply `morphisms of morphisms` within this specific category?
22:23:15 <liste> they're morphisms of objects too
22:24:09 <liste> the type constructor "f :: * -> *" (e.g. [] or Maybe) is the morphism of objects, and "fmap" is the morphism of morphisms
22:25:21 <codebje> liste, a Haskell functor is a covariant endofunctor which maps a morphism (a -> b) into the morphism (f a -> f b)
22:27:05 <anohigisavay> _(:з」∠)_ HasHell. why u so unapproachable
22:27:42 <codebje> anohigisavay, because (1) academia makes a lot of it, and (2) you don't really need to know the category theory to make effective use of Functor, imo
22:28:14 <roelof> anyone succeed in working with Haskell on Windows  ? 
22:28:52 <Axman6> roelof: probably lots of peop,e
22:28:56 <Axman6> people*
22:30:11 <anohigisavay> codebje: yea i know that. i just hate to reach a point where i can't get over it :D
22:30:13 <roelof> Then I hope someone can tell me how to do it. I tried yesterday but no luck with Haskell and even lesser luck with Sublime Text and Atom :( 
22:30:39 <Axman6> roelof: what did you try?
22:30:55 <anohigisavay> i at least want to understand that famous saying "Monads are just monoids in the category of endofunctors"
22:32:11 <roelof> I have tried to install haskell by using stack. That seems to be working. Then I had to install ghc-mod . Took ages. Then I tried to install all the dependencies to work with Sublime Text 
22:32:44 <dedgrant> roelof: I regularly use haskell environment on windows. Combination of emacs and cmd shell... though I haven't tempted the sublime text integration in ages, I hope that it has improved.
22:32:47 <anohigisavay> roelof: i think Haskell Platform will save you a lot of time
22:33:13 <roelof> no luck.  gcc could not be found. So I tried Atom . Installation success. But on a few minutes I see a message that  ghc-modi chrashed 
22:33:17 <Axman6> sublime text integration isn't great anyway, I wouldn't bother at the moment (it doesn't even support stack yet)
22:33:56 <roelof> Axman6:  bummer, I like stack 
22:34:09 <Axman6> stack from the command line works fine
22:34:19 <roelof> Maybe try to find a good plugin for intelij then 
22:34:27 <Axman6> I've never developed haskell with anything more than a text editor and a command line
22:34:43 <dedgrant> roelof: Most of the problems I've had with stack have been due to misconfigured path environment; it is a bit dicey on windows.
22:34:49 <kadoban> roelof: I wouldn't bother spending a ton of time setting up editor integration, by the way … though someone told me that long ago and I ignored them and spent forever messing with it (which I've since largely abandoned), so … yeah I dunno.
22:35:13 <Axman6> it's just not worth it
22:35:25 <Axman6> the tools aren't good enough really
22:35:41 <roelof> kadoban:  oke, but I like to see things like linting and syntax highlighting 
22:35:45 <kadoban> All you really need is a decent programmers' text editor, and ghci in a separate window.
22:36:32 <kadoban> roelof: syntax highlighting should be out-of-the-box or close to it in most of the decent editors, and linting you can just do with hlint, or often it's pretty easy to set that up to automatically happen in an editor without much trouble.
22:36:33 <dedgrant> What kadoban said ^   Emacs integration is the most stable, but nowhere near being a polished product.
22:36:54 <roelof> chips, then I have to learn haskell and emacs/vim the same time :( 
22:37:30 <MarcelineVQ> you can use notepad if you want to
22:37:48 <MarcelineVQ> most of your time when you're learning is loading stuff in ghci anyway
22:37:55 <kadoban> roelof: emacs isn't terribly hard to learn really … it's basically just a normal text editor, except it doesn't look amazingly pretty. Especially the GUI version has all the normal buttons, you don't even have to hit key-combos if you don't want.
22:38:22 <kadoban> MarcelineVQ: That's going a bit far. Syntax highlighting and correct tab->space handling are pretty important.
22:38:48 <dedgrant> Yes I would pay good money for a solid, stable shipping IDE for GHC.
22:38:49 <MarcelineVQ> Sure but it's better to be doing something than agonizing over tools
22:39:10 <kadoban> MarcelineVQ: Well, yeah, but the additional effort to get a 1/2way decent editor shouldn't be much.
22:39:40 <MarcelineVQ> You'd think
22:39:52 <dedgrant> roelof: If you want to get linting integration working in atom or emacs I might be able to help you out.
22:39:54 <MarcelineVQ> But this question has been ongoing for awhile for some reason
22:41:20 <roelof> dedgrant:  I think I have to go for emacs. In Atom ghc-modi still chrashes and I could not find out how I can make a stack test running 
22:44:51 <roelof> So haskell - platform and emacs schould work on Windows ? 
22:45:16 <roelof> Is there then a tutorial how to set up Emacs to work with Haskell 
22:45:22 <kadoban> roelof: I … really don't think the platform is a good idea in general. I'd just use stack, especially since you already mentioned it.
22:45:56 <roelof> oke, so reinstall stack and emacs , 
22:46:43 <dedgrant> roelof: I always use stack to set up my environment these days. Haven't been back to HP for a long while. First things first, grab a windows build of emacs-24.5 (say from http://ftp.gnu.org/gnu/emacs/windows/) and I can help you get started.
22:48:14 <roelof> oke, first make stack working again with  ghci 
22:48:37 <dedgrant> roelof: shall we go pm to figure out the stack setup?
22:49:17 <roelof> dedgrant:  no need. I do follow this page : http://docs.haskellstack.org/en/stable/install_and_upgrade.html#windows
22:49:53 <dedgrant> excellent
22:51:50 <roelof> stack installed 
22:51:59 <roelof> now time for stack setup I think 
22:53:17 <codebje> anohigisavay, every time I think I understand that, I go deeper; try http://www.stephendiehl.com/posts/monads.html if that isn't where you already were, but you'll still need to bring into it what a monoidal category is sooner or later
22:53:45 <dedgrant> roelof: For what it's worth, I'm using hte same emacs config for both windows and linux development. flycheck, flycheck-haskell and haskell-mode are probably the three most important emacs packages for you to read up on
22:54:22 <dedgrant> roelof: Also recommend jwiegley's use-package or a similar package manager to greatly simplify staying up to date, or reinstalling your emacs dependencies.
22:54:27 <roelof> oke, I now try to find a emacs package for Windows 64 bit 
22:55:19 <dedgrant> roelof: 32- or 64- should be fine.
22:55:37 <roelof> chips. here only 32 bit : http://ftp.snt.utwente.nl/pub/software/gnu/emacs/windows/
22:55:44 <anohigisavay> codebje: yea i'm exactly following this now
22:57:46 <roelof> dedgrant:  foind it out. Where schould I pack the zip out so it's in path ? 
23:04:51 <dedgrant> roelof: Pick any convenient location. It doesn't need to be on your path.
23:05:56 <roelof> oke, busy now with a lot of packages 
23:06:21 <pikajude> i have an Array with ix type (Int, Int) representing a grid; what's the best way to "shift left" the array by 1?
23:06:48 <pikajude> a naive `ixmap (bounds grid) (\ (x,y) -> (x-1, y)) grid` gives me an "Error in array index"
23:09:58 <pikajude> well, I've got the wrong axis AND the wrong direction, but it still gives me an error regardless and i'm not sure how to fix that
23:12:45 <lyxia> pikajude: (x-1, y) goes out of bounds when x is the smallest value within "bounds grid"
23:12:50 <pikajude> right
23:13:18 <pikajude> so, either I need ixmap to actually construct a new array that's one unit narrower on the x-axis, or I need a way to pull values out of thin air to fill the missing spaces
23:13:30 <lyxia> indeed
