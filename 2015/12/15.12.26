00:59:09 * hackagebot sbvPlugin 0.5 - Formally prove properties of Haskell programs using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.5 (LeventErkok)
01:28:36 <aloiscochard> saep: thanks so much for `nvim-hs`, it's like if my dream comes true :-)
01:42:37 <ReinH> dmwit: I don't think so. Their position is equivalent to "if you disagree with me then you must believe that the halting problem is solvable."
01:43:11 <ReinH> Without any awareness that this statement would be equivalent to solving the halting problem.
02:09:49 <kqr> does Prism' a b -> a -> Either a b exist?
02:10:15 <kqr> it's almost (^? p) but not quite
02:10:56 <kqr> it's basically the second function of the prism
02:11:04 <kqr> hey I think I know how to get that
02:11:40 <kqr> ...maybe not
02:16:36 <ReinH> kqr: so you want something other than review?
02:18:09 <kqr> uhh maybe it is review I want only the monadreader type signature trips me up
02:18:28 <ReinH> > _Left # 1
02:18:29 <lambdabot>  Left 1
02:18:44 <kqr> i think review is the opposite of what I want
02:18:53 <kqr> it lets me go from a to s, but I want to go from s to Either s a
02:19:15 <ReinH> ah
02:23:03 <kqr> i could do the combinator thing and go s -> Maybe a and then to Either s a but that seems silly when I have just created a prism from the functions (a -> s, s -> Either s a)
02:24:57 <ReinH> kqr: do you want ``matching''?
02:25:53 <kqr> YES
02:25:54 <kqr> thank you!
03:07:11 <linduxed> bernalex: yes, i agree with that. with this said, i do feel that while the rule that i've seen proposed in some style guides ("avoid point-free when you can") feels to extreme, i see where it's coming from
03:07:22 <linduxed> bernalex: but yes, let's not become go
03:26:08 <jle`> hi all
03:26:25 <jle`> in the documentation for MVar, there's a short cute example of a SkipChan implemented using MVar's
03:26:27 <jle`> http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent-MVar.html
03:26:40 <jle`> i was wondering if there was a library that actually implemented skip chans for real robust usage
03:26:47 <jle`> because they sound nice :)
03:26:58 <jle`> hackage searches aren't giving me too much luck
03:27:38 <jle`> of course i could just copy and paste the implementation there and i'd probably be happy too...but it'd be nice if there was a source somewhere in the ecosystem that i could just include in cabal
03:39:16 <ReinH> linduxed: pointfree is useful for reasoning about function composition
03:39:32 <ReinH> since reasoning about function composition is pretty common, pointfree is frequently useful
04:08:05 <shersh> Hello everyone! I'm playing with GADTs. I want both: Functor instance and such `runIO` instance for my datatype. But functor instance doesn't typecheck with error in comment. How can I fix it? Here is my code: http://lpaste.net/8097662482962710528 
04:11:25 <jle`> shersh: remember the type of fmap
04:11:35 <shersh> :t fmap
04:11:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:11:43 <jle`> if f :: (a -> b), then the result has to be a TeleTypeF b
04:11:46 <linduxed> ReinH: mhm, that makes sense
04:11:58 <jle`> shersh: but, you're retunring a TeletypeF ()
04:12:27 <jle`> for example, what would the type of fmap (\() -> True) Stop be?
04:12:42 <jle`> fmap :: (() -> Bool) -> TeletypeF () -> TeletypeF Bool
04:13:05 <jle`> but, the way you impelemented it, it'd return a TeletypeF (), not a TeleetypeF Bool
04:13:09 <shersh> I understand problem. I cant change Stop type to  `TeletypeF b` but then I can't write runIO for Stop constructor :(
04:13:24 <7YUAAGY8V> Stop :: b -> TeletypeF b
04:13:36 <7YUAAGY8V> runIO (Stop a) = return a
04:14:23 <jle`> yeah, and you could recover the behavior of your original Stop constructor by providing a function stop :: TeletypeF (); stop = Stop ()
04:14:55 <shersh> Seems, it will fix the problem :) Thanks to all!
04:15:16 <suppi> how do I change the ghci repl prompt? :I
04:15:33 <jle`> shersh: also note that in doing this, your type is now just a normal data type...no need for GADT's :)
04:16:10 <jle`> suppi: :set promt "myprompt> "
04:16:14 <jle`> *prompt
04:16:18 <jle`> people usually put it in ~/.ghci
04:16:19 <suppi> jle`, ah, yes. thanks :)
04:16:20 <jle`> or something
04:16:41 <shersh> I noticed that) But I stil can use GADTSyntax :) Though I wanted some simple example with GADT's...
04:19:01 <jle`> mhm
04:32:02 <mrt2> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
04:34:11 <wei2912> O_o
04:34:42 <wei2912> mrt2: are you on DMT?
04:34:45 <hrnz> just tried that, didn't work
04:34:46 <suppi> sounds dangerous
04:34:53 <hrnz> how do I get rid of the body though?
04:35:14 <wei2912> throw it into a drain
04:36:17 <suppi> feed the doves with it
04:37:06 <MarcelineVQ> sounds legit, i read about that on wikipedia
04:37:11 <suppi> I'm sorry I take that back
04:43:31 <ocramz> hullo
04:44:58 <nshepperd_> The body will be collected by GC once there are no more references to it :>
04:48:27 <mniip> s/collected/evacuated/
05:06:16 <ocramz> anyone here?
05:06:49 <ocramz> I'm looking at the "mini-Servant" blog by A.Loeh
05:07:12 <ocramz> what does the `k` kind mean in `data (a :: k) :> (b :: *)` ?
05:07:39 <mniip> it's a kind-variable
05:07:48 <mniip> it says that a can be of any kind
05:08:48 <ocramz> but it needs DataKinds or KindSignatures to work
05:10:42 <ocramz> so, loosely speaking, (:>) is a type-level Either, in which the l.h.s. term can have any kind
05:11:41 <ocramz> (OT: I understand we also have to stop using the word "kind" at some point in the future)
05:12:36 <MarcelineVQ> Just wait until Sorts become popular, that won't confuse anybody :>
05:13:03 <ocramz> ugh
05:13:50 <mniip> MarcelineVQ, didn't they implement kind equality already
05:15:38 <MarcelineVQ> I'd have to check, it's in the roadmap for sure
05:16:05 <ocramz> MarcelineVQ : what do Sorts correspond to?
05:16:59 <MarcelineVQ> vaguely, the types of kinds :X
05:17:23 <ocramz> just another layer of turtles?
05:19:58 <MarcelineVQ> Maybe, though turtles just make things taller, abstraction layers make things wider too :>
05:20:12 <MarcelineVQ> mniip: looks like it phabricator.haskell.org/rGHC6746549772c5cc0ac66c0fce562f297f4d4b80a2
05:20:41 <no-n> :O
05:25:36 <ocramz> kind equality will go in ghc 8 IIRC?
05:26:10 <MarcelineVQ> ideally
05:27:06 <ocramz> it will take me some months to grok that stuff but it'll be awesome, I'm sure
05:27:10 <MarcelineVQ> By which Iâ€‹ mean that's the plan
06:05:28 <snowleopard_> bgamari: Hey! Just trying out irc. 
06:06:14 <snowleopard_> angerman: Hey! Just trying out irc.
06:06:31 <angerman> @snowleopard_ howdy! 
06:06:31 <lambdabot> Unknown command, try @list
06:06:44 <angerman> muscle memory. haha :D
06:07:18 <snowleopard_> angerman: :D Ok, I think I'll stick to irc.
06:07:18 <angerman> snowleopard_ could use #shaking-up-ghc or so I guess.
06:10:25 <mrt2> Anyone who wants to try real magick listen to this. Its top secret! Hold hidden by FBI. If one inject enough DMT into the body one (that is high dose) can change bodies with another person by looking that person in the eyes sucking inwards transfer the soul to that body, it holds for 5 minutes. Kill yourselves after the body transfer to inhabit that body, go for someone younger to live longer. From ayahuasceros in SA
06:12:03 <nshepperd_> Well that's much less exciting the second time
06:12:13 <nshepperd_> @where ops
06:12:14 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:17:54 <ocramz> I still find it quite fascinating that a bot feels like sharing its experiences with dissociative shamanic potions on #haskell
06:18:38 <angerman> bgamari got a minute to help us out in #shaking-up-ghc?
06:23:43 <hodapp> #shaking-up-ghc?
06:33:01 <Odelisk> Is there any simple data structures for storing values in intervals? For example: `let map = IntervalMap.fromList [(0, "A") (3.7, "B"), (8.9, "C")]; print (IntervalMap.get 4.4)` --> outputs `Just "B"`
06:40:39 <phadej> Odelisk: you can use Map Double String and lookupLE for your lookup
06:45:28 <ocramz> Odelisk: I think that you need to make sure the list of doubles is non-degenerate, i.e. no duplicates, ordered list etc.
06:45:48 <ocramz> then lookupLE works as intended
06:50:21 <maerwald> anyone knows why there is no "removeFile" function in the System.Posix.Files (unix package) module?
06:51:09 <Odelisk> Ah, of course, thanks.
06:54:10 <danilo2> Hello! Is there any way in Haskell to create such typeclass: `class Attribute a m t | a t -> m where attr :: Proxy a -> m (Lens' t a)` ? GHC want me to use -XImpredicativeTypes but this extension behaves very strange when used here, so I hope there would be better solution for that.
06:55:08 <wedens> danilo2: I suppose you can use type family
06:55:55 <danilo2> wedens: Could you tell more about this idea? How could I use it here?
07:01:19 <maerwald> mh, didn't ghc-mod use to tell you about redundant imports? It seems it doesn't do that for me anymore
07:05:41 <danilo2> Hello! Is there any way in Haskell to create such typeclass: `class Attribute a m t | a t -> m where attr :: Proxy a -> m (Lens' t a)` ? GHC want me to use -XImpredicativeTypes but this extension behaves very strange when used here, so I hope there would be better solution for that.
07:07:25 <bgamari> danilo2, you'll need to newtype lens
07:07:42 <bgamari> If you are using the `lens` library you'll want to use ReifiedLens
07:08:28 <bgamari> danilo2, the problem being that you can't place higher ranked types inside a container (e.g. `m`)
07:08:42 <bgamari> without impredicative types
07:10:12 <danilo2> bgamari: oh cool, I didnt know about ReifiedLens'es!
07:10:20 <danilo2> bgamari: thank you so much! :)
07:10:26 <bgamari> no worries
07:20:52 <haskell417> Hello, could anybody please help me with a JSON (Data.Aeson v 0.10.0) encode/decode problem? I have been trying for a while and I am lost. Problem: Why does `encode [Right "TestRight", Left "TestLeft"]` result in  "[{\"right\":\"TestRight\"},{\"left\":\"TestLeft\"}]" if decode expects "right" and "left" to be capitalized and in the source code of Data/Aeson/Types/Instances.hs both the toJSON and fromJSON instances of Either are w
07:24:03 <hsk3> Please read "Lazy vs Strict Evaluation" here: http://jnordenberg.blogspot.com/2012/05/my-take-on-haskell-vs-scala.html
07:24:03 <hsk3> This is one thing that makes me nervous about using Haskell for serious projects.
07:24:06 <hsk3> Your thoughts?
07:25:24 <Taneb> hsk3: I've used Haskell a fair bit and I've never had any problems with lazy evaluation that wouldn't be worse problems with strict
07:40:57 <phaazon> @hoogle Some
07:41:00 <lambdabot> Data.Text.Encoding Some :: Text -> ByteString -> (ByteString -> Decoding) -> Decoding
07:41:00 <lambdabot> Control.Exception.Base SomeException :: e -> SomeException
07:41:00 <lambdabot> Control.Exception SomeException :: e -> SomeException
07:45:28 <phadej> hsk3: I haven't seen performance problems in Haskell. Yes, it might be harder to get constant factor quite low, but that would require efforts in Scala as well.
07:46:38 <wedens> hsk3: bollocks
07:48:18 <wedens> jvm is not optimized for pure FP things
07:49:16 <wedens> if you want to compare java written in scala and haskell - it's not even a valid comparison
07:53:55 <hsk3> hmm ok
07:55:47 <maerwald> laziness IS a problem, but not having it in haskell would be a bigger problem, which is what Idris already had to realize where you have to write a lot of fuse functions to not break composability completely
07:58:11 <hsk3> interesting
07:58:16 <maerwald> you can have strictness in haskell too, you just have to learn it
07:58:20 <ahihi> you get better at understanding the performance of lazy-by-default code with practice (profiling helps), it's not like it is some insurmountable obstacle
07:58:58 <hsk3> yeah i guess talking about it is useless. i have to actually run into the problem and then talk about it if i need to
07:59:23 <maerwald> laziness space leaks can be frustrating and annoying, but they don't happen that often
07:59:41 <phadej> people with asm/c++ background just think about performacne too early
07:59:47 <phadej> i.e. all the time
07:59:51 <maerwald> to me that blogposts reads like "I'm used to languages like C, so I prefer to not learn something different"
07:59:52 <phadej> and not about e.g. clean api design
08:02:11 <phadej> and at large it doesn't matter (that much), because at large you don't write tight loops doing things
08:04:17 <maerwald> well, there are things that are more difficult in haskell
08:04:32 <maerwald> but that's with every language
08:04:54 <hsk3> i just love the idea of pure funcs so much .. don't wanna abandon that.
08:04:58 <hsk3> plus the syntax is beautiful!
08:05:02 <hsk3> nothing beats it
08:05:40 <ahihi> I write scala in my day job and miss haskell almost every day ;_;
08:05:45 <hsk3> :)
08:14:02 <wedens> ahihi: there are many of us
08:14:21 * hackagebot carray 0.1.6.2 - A C-compatible array library.  https://hackage.haskell.org/package/carray-0.1.6.2 (HenningThielemann)
08:15:41 <phadej> wedens, ahihi: seek into position where you can decide the language, and inject haskell :)
08:16:35 <wedens> phadej: I'm already doing it ;) just started our first haskell project
08:18:07 <ahihi> it's on my to-do list...
08:18:31 <phadej> wedens: cool, can you share what kind of project?
08:22:40 <kritzcreek> has anyone seen this error before? I'm trying to use ghc-mod installed with stack in emacs: http://pastebin.com/f4h1Qakz
08:23:04 <wedens> phadej: nothing very exciting :) relatively simple web app
08:24:04 <phadej> wedens: oh, that's exactly what we do too, but it can still spin off interesting things!
08:24:45 * hackagebot pointfree 1.1.1.1 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-1.1.1.1 (BenMillwood)
08:31:35 <maerwald> anyone has been working with gio file monitor? I can't even make a simple example work
08:54:50 <SomeGuy> hello all, is there a way to get cabal sandboxes to install all dependencies, IE i want an entire environment of profiling  libraries, this way I don't have to resinstall all of my globals
08:59:46 <the_2nd> Do you guys prefix field names in datas?
09:00:00 <the_2nd> e.g. carSpeed shotSpeed instead of speed ?
09:00:13 <the_2nd> or use named imports?
09:14:05 <dmwit> I use imports.
09:14:15 <dmwit> But I think I am the minority here.
09:15:30 <dmwit> SomeGuy: Hopefully all the packages in your global database came with your compiler and already have profiling versions.
09:15:44 <dmwit> SomeGuy: The local database doesn't matter, as it's completely ignored by sandboxes.
09:17:21 <carthage> part
09:17:46 <ga2arch> kritzcreek: i fixed it with ghc-mod check src/Main.hs 
09:26:46 <fizbin> the_2nd: I tend to use a convention I picked up from the lens library, and use _fooSpeed with a "HasSpeed" type class, even when I'm not using the lens library.
09:27:26 <fizbin> Though the lens TH stuff makes that convention very easy to use.
09:44:33 <linduxed> i find it somewhat amusing that it was at 7 the implementors of Data.List said that "nope, you can't zip more than 7 lists. more than 7, you'll have to roll your own function"
09:44:47 <linduxed> i could imagine three or four
09:44:50 <linduxed> but seven?
09:44:53 <linduxed> haha
09:46:41 <geekosaur> limit probably came from some ancient ghc whose typechecker went exponential or something
09:48:49 <geekosaur> hm, actually it's in the Report. 
09:48:56 <geekosaur> "what were they thinking?"
09:49:40 <geekosaur> (iirc any record of that has been lost to the mists of time)
09:50:22 <aweinstock> linduxed: 7 is the largest single-digit prime
09:50:35 <aweinstock> mumblemumble mysticalness mumble
09:50:43 <linduxed> aweinstock: best explanation so far
09:52:49 <monochrom> perhaps they were thinking "most typecheckers went exponential"
10:21:50 <phy1729> linduxed: it's the number of bits in a byte - 1
10:28:35 <tommd> > let it's = popCount (maxBound :: Word8) - 1 in it's
10:28:37 <lambdabot>  7
10:50:29 <kqr> do I understand it correctly that if I have a "chain" of conduits, and one of them is StateT s IO then all of them have to be StateT s IO?
10:54:40 <kqr> reason I ask is that there's one conduit in my chain where I need to keep track of some state that's local to that specific conduit
10:54:58 <kqr> ah Data.Conduit.Lift is supposed to solve that problem
10:56:45 <maerwald> how do you debug segfaults in haskell?
10:57:37 <c_wraith> well, unless you're using unsafeCoerce (or equivalent), segfaults are the result of native calls going wrong.
10:57:52 <c_wraith> So the first part is to figure out if it's a native call or an unsafeCoerce
10:58:44 <c_wraith> Note that either of those can cause segfaults in *other* code.  So it's not necessarily "what call is it making when it crashes?", so much as "what calls has it made in the whole program before it's crashed?"
10:59:26 <aweinstock> maerwald: gdb?
10:59:55 <aweinstock> :t Foreign.Storable.poke
10:59:57 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
11:00:27 <c_wraith> gdb is helpful if it's actually crashing in native code.  That's how I discovered the curl package should never be used for https, since it initializes openssl in a thread-unsafe way.
11:00:34 <aweinstock> c_wraith: ^ it's possible to get a segfault without unsafeCoerce/FFI (if you count Storable to be not-FFI)
11:00:50 <c_wraith> Storable is very much part of the FFI. :P
11:05:23 <maerwald> it's gtk thread foo
11:09:42 <kqr> is data-default considered an abuse of typeclasses?
11:11:28 <c_wraith> in some sense.
11:11:35 <c_wraith> It's not a very meaningful class.
11:11:51 <c_wraith> But it's still useful enough to have reasons to exist.
11:13:15 <kqr> I guess the main difference between `def` and `defMyType` is that the former allows you to write functions that are generic over default values... but what's an example of such a useful function?
11:15:41 <bergmark> kqr: i don't think there is one
11:16:00 <c_wraith> edwardk has mentioned that he has used it.  He's not the type to use classes capriciously.
11:27:44 <jmcarthur> I don't think there's much reason for data-default to exist. It seems to me that the only use case is for functions that need something like optional arguments. The thing is, if you just write your function to take a (Config -> Config) argument instead of a Config argument, you can just use id instead of def.
11:31:40 <jmcarthur> And that even allows different functions to have different defaults.
11:33:03 <dhz_> I like "doit defaultConfig { option1 = 10; option2 = 20 }"
11:33:41 <jmcarthur> In my style, that would be something like: doit (setOption1 10 . setOption2 20)
11:33:52 <jmcarthur> the "set" prefixes don't really need to be there, even
11:34:20 <arianvp> any of you guys at CCC?
11:34:26 <dhz_> nice too. and maybe default = id
11:34:38 <jmcarthur> exactly. id is the default.
11:41:00 * hackagebot slug 0.1.1 - Type-safe slugs for Yesod ecosystem  https://hackage.haskell.org/package/slug-0.1.1 (mrkkrp)
11:51:53 <vik123> do you guys get autocomplete when you press tab in GHCi? So if my module defined foo = "hi", typing 'f <tab>' autocompletes foo?
11:51:54 <ReinH> kqr: the only utility of Data.Default afaik is to curtail the rapid explosion of defMyType identifiers.
11:53:12 <kqr> ReinH, i don't personally think there's anything wrong with those â€“ they certainly make it easier for me to read the code
11:53:17 <ReinH> It has no laws, and is not the basis for any functionality, since there's nothing else you know about / can do with the value than that it exists.
11:53:29 <ReinH> s/than that/other than that
11:53:39 <ReinH> that sentence is a big janky :/
11:53:46 <ReinH> bit *sigh*
11:54:06 <ReinH> kqr: it gets used often enough that I suppose a non-trivial number of people agree with you :)
11:54:49 <ReinH> kqr: oh, you are saying there's nothing wrong with defMyType identifiers. I guess I should stop trying to communicate with people today...
11:55:11 <pilne> i'm just curious now as to how prevalant and worrisome the leaks outlined here: http://blog.ezyang.com/2011/05/space-leak-zoo/ are when coding in haskell
11:56:03 <ReinH> pilne: probably about as common as leaks in other languages, I suppose.
11:56:11 <ReinH> people seem to manage well enough despite them
11:56:15 <pilne> fair enough
11:56:28 <ReinH> it's good to be aware of them, but I wouldn't be unduly concerned
11:58:09 <hsk3> This is how I commonly debug programs in imperative languages: To learn what's going on, I insert some print statements at interesting points, run the program, look at the console and see what gets output. This way I can find the source of the problem.
11:58:09 <hsk3> Is this even possible in Haskell? I guess not since I can't just throw in print (I/O) statements at random places in pure functions.
11:58:38 <kqr> it is possible in haskell with the debug.trace module
11:58:57 <hsk3> kqr: is that commonly used?
11:59:04 <kqr> for debugging, sure
11:59:31 <kqr> not as common as in imperative languages, but that's because you need it less often
11:59:41 <kqr> (or at least that's been true for me)
12:01:23 <vifon> Hello. I'm trying to use the Rand and Writer monads together. Could someone help me with this code? http://lpaste.net/147875 I'm using Control.Monad.Random
12:02:00 <vifon> I'm not sure how to properly access the inner monad.
12:03:27 <bscarlet> lift ?
12:05:03 <pikajude> what Haskell library provides the functionality of node's crypto.verify()?
12:05:20 <vifon> bscarlet: How exactly? I've tried calling "liftM tell [r]".
12:05:37 <geekosaur> liftM is not lift
12:06:01 * hackagebot cabal-macosx 0.2.3.2 - Cabal support for creating Mac OSX application bundles.  https://hackage.haskell.org/package/cabal-macosx-0.2.3.2 (dfrancesconi)
12:06:06 <pikajude> liftM is fmap
12:06:11 <vifon> Ok, that's a new one to me. I assumed that's what you mean.
12:06:26 <geekosaur> Control.Monad.Trans.lift
12:07:43 <vifon> Seems almost good... http://lpaste.net/147877
12:09:16 <geekosaur> at a guess (having trouble loading stuff) you wrote "lift tell [r]"; it should be "lift (tell [r])"
12:10:02 <vifon> I've tried both actually but this error log is indeed from "lift tell [r]".
12:11:09 <vifon> This is the other one: http://lpaste.net/147879
12:12:49 <mauke> your type signature is wrong for that code
12:13:41 <geekosaur> oh, this does not look like a MonadTrans, actually. although I think there is a MonadTrans in there, you're just not using ot
12:13:58 <mauke> it would have to be something like RandT g (Writer [Int]) ()
12:14:02 <geekosaur> yes
12:14:07 <vifon> Yeah, I've read about it.
12:14:22 <vifon> I wanted to finish it this way and then try with the monad trans.
12:14:38 <geekosaur> as ypu wrote it, there is no monad to get to. you *return* a Writer
12:14:50 <vifon> Hm...
12:14:51 <geekosaur> which doesn't make a lot of sense
12:15:06 <vifon> You're right...
12:15:25 <vifon> Ok, let me try with this trans thing.
12:16:35 <mauke> ... = do r <- getRandomR (1,6); fmap (tell [r] >>) (rollNDice (n-1))
12:18:21 <vifon> rollNDice :: (RandomGen g) => Int -> RandT g (Writer [Int]) ()
12:18:27 <vifon> Is this signature correct?
12:19:12 <vifon> Wow, it's working!
12:20:07 <vifon> I call it like this, is that a proper way?   print $ runWriter $ evalRandT (rollNDice 5) g
12:20:43 <mauke> looks ok
12:21:00 <vifon> In general, if I want to combine monads, do I always need to use a transformer? Can there be a case where there is no transformer version?
12:22:03 <mauke> yes, there's no IOT
12:22:38 <vifon> What about this one? https://hackage.haskell.org/package/MonadCompose-0.8.3.1/docs/Control-Monad-IOT.html
12:23:28 <mauke> ooh
12:24:11 <mauke> ok, this looks slightly crazy
12:24:34 <mauke> there's no runIOT function, and if you use it wrong, you get runtime errors
12:25:01 <xor__> Hi
12:25:21 <vifon> Sounds fun...
12:26:58 <vifon> How would I go about combining, let's say... Reader with Writer with State? And maybe even Rand. Is this signature correct?   ReaderT Int (WriterT [Int] (State [Int]))
12:30:57 <mauke> there's a RWST somewhere
12:36:12 <pikajude> hey, is there a library that can turn a cryptonite pubkey into a PEM string?
12:36:51 <vifon> mauke: But how can I define it manually? If it's possible.
13:03:10 <mtesseract> Hi
13:09:47 <hsk3> What editor or IDE do you guys use to write Haskell programs?
13:09:53 <vik123> emacs
13:10:24 <hsk3> vik123: how big (numer of files, modules, etc.) are your haskell programs?
13:24:58 <mauke> I don't understand main2 in http://blog.ezyang.com/2011/07/blockedindefinitelyonmvar/
13:25:10 <mauke> why does the main thread get BlockedIndefinitelyOnMVar?
13:29:00 <Igloo> mauke: Both threads become BlockedIndefinitelyOnMVar at the same time. The RTS can't see that the forked thread will inevitably do the putMVar
13:29:05 <shachaf> mauke: The other thread gets BlockedIndefinitelyOnMVar first, so there are no other references to complete.
13:29:19 <shachaf> Oh, that's not right.
13:29:32 <shachaf> Or not complete, anyway.
13:30:46 <mauke> Igloo: but the forked thread still has a reference to complete
13:30:53 <mauke> why does that trigger Blocked on the main thread?
13:31:37 <geekosaur> all it knows is the main thread is blocked on something held by a deadlocked thread
13:32:14 <geekosaur> so it blindly throws the exception to both, because it has no idea that the reference held by the forkIO-d thread would resolve the deadlock
13:32:59 <mauke> ooh, like it doesn't know about `finally`?
13:33:02 <geekosaur> basiclaly any reference held by a deadlocked thread "doesn't count" because there's no way to prove it would be accessible if the thread were resumed
13:33:05 <geekosaur> yes
13:33:14 <mauke> (take A >> put B) vs. (take B >> put A)
13:33:33 <mauke> those two are "obviously" deadlocked even though each has a reference to the other's lock
13:33:38 <geekosaur> handlers are not wired into the compiler, so the runtime can't be told that a handler would resolve it
13:34:21 <geekosaur> (nor do they get registered with the runtime --- and I suspect such registration would just lead to harder to characterize edge cases)
13:35:22 <mauke> I don't know how practical this is but couldn't it attempt to unlock things by throwing to truly unreferenced MVars first, then to those referenced by other deadlocked threads?
13:36:10 <mauke> in this case 'lock' is "absolutely" unreferenced
13:49:24 <roelof> how do I change this so it's working : http://lpaste.net/147881  I see now a error that the = is wrong on the first instance 
13:49:58 <roelof> I think I need this so I can test my custom data types with QuickCheck 
13:50:17 <jle`> instance Arbitrary (Line a)
13:50:29 <jle`> the error should be descriptive, i think :o
13:50:50 <jle`> you're writing an instance of Arbitrary Line a, a supposed typeclass with two parameters
13:50:55 <jle`> but you want Arbitrary (Line a)
13:51:01 <jle`> Arbitrary only takes one parameter
13:51:19 <jle`> oh, also, instance declaration doesn't work with =
13:51:20 * hackagebot syntactic 3.3 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.3 (EmilAxelsson)
13:51:25 <jle`> oh
13:51:34 <jle`> actually, you aren't defining instances, are you
13:51:39 <jle`> you want to define data types
13:51:42 <tnecniv> lines again?
13:52:05 <jle`> roelof: er...i'm not totally sure what you want to do
13:52:19 <jle`> do you mean to type `data Line a = Line { slope :: a, intercept :: a }
13:52:33 <jle`> and `data Result a = None | One a a | All`
13:52:44 <jle`> and then write Arbitrary instances for them?
13:53:21 <linduxed> so i've got a list of tuples. I want to see if there are duplicates in that list. i thought about doing it with `any (>1) . map length . group . sort`
13:53:27 <linduxed> is there a better way?
13:54:14 <roelof> jle: I hope this paste solves a lot : http://lpaste.net/147883
13:54:53 <roelof> I try to find out how to solve this error message and I think I need to use a Instance to make the test working 
13:55:01 <Wchm> Hi everyone! I am trying to (for fun, not a project) make a point-free lookup function e.x. given input of 5 [(5,6), (7,8)] gives 6, using just basic library functions like snd, fst, filter, (==) and (.) and think it might be impossible. Is this correct?
13:55:23 <jle`> roelof: well, you don't ever use the parameter x in your property
13:55:41 <Wchm> My closest attempt is snd . head . filter ((.fst) (==5)) and then passing [(5,6)], but I can't slip that 5 out.
13:55:59 <tnecniv> roelof why does One take two values
13:56:00 <jle`> Wchm: why not (fst . head) ?
13:56:20 * hackagebot persistent-template 2.1.5 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.5 (GregWeber)
13:56:34 <jle`> roelof: this isn't a property test, it's a unit test :o
13:56:36 <Wchm> The intended effect is to find the snd of the pair with fst == the first input (so ex [(1, 2), (3, 4)] 3 == 4)
13:56:43 <mauke> :t snd . head . filter ((==5) . fst)
13:56:44 <lambdabot> (Eq b, Num b) => [(b, b1)] -> b1
13:56:59 <maerwald> linduxed: is this about performance?
13:57:03 <mauke> :t snd . head . filter (flip (.) fst (==5))
13:57:04 <lambdabot> (Eq b, Num b) => [(b, c)] -> c
13:57:23 <linduxed> maerwald: ehm, no, i haven't given that much thought at all
13:57:24 <mauke> :t snd . head . filter ((flip (.) fst . (==)) 5)
13:57:25 <maerwald> if not, I'd just do: f xs = nub xs == xs
13:57:26 <lambdabot> (Eq b, Num b) => [(b, b1)] -> b1
13:57:37 <jle`> roelof: you can specify x to be () if you want, \(x :: ()) -> crossX (Line 0 0) == All, but yeah, it's not a property test, it's a unit test
13:57:37 <linduxed> maerwald: oooh
13:57:45 <linduxed> maerwald: yeah! forgot about nub
13:57:49 <jle`> roelof: you aren't generating random Line's and checking if they all match a certain pattern
13:57:49 <maerwald> but nub is O(n^2)
13:58:06 <linduxed> or well, i didn't forget about it, but i discarded it, thinking that it's not what i want to do
13:58:07 <jle`> there's ordNub too, which might work better
13:58:13 <tnecniv> premature optimization is the root of all evil
13:58:28 <jle`> or you can compare if (toList . S.fromList) xs is the same as the original list
13:58:29 <linduxed> well in this case i don't particularly care about performance
13:58:35 <jle`> from Data.Set
13:58:50 <linduxed> jle`: the set trick is pretty cool too i guess
13:59:00 <jle`> > (toList . S.fromList) [1,1,6,2,3,3,7,1,5,9]
13:59:02 <lambdabot>      Ambiguous occurrence â€˜toListâ€™
13:59:02 <lambdabot>      It could refer to either â€˜Data.Foldable.toListâ€™,
13:59:02 <lambdabot>                               imported from â€˜Data.Foldableâ€™ at /tmp/mueval125...
13:59:06 <jle`> rly
13:59:10 <jle`> > (S.toList . S.fromList) [1,1,6,2,3,3,7,1,5,9]
13:59:12 <lambdabot>  [1,2,3,5,6,7,9]
13:59:17 <linduxed> tnecniv: funny you say that, i recently read an article basically saying that those words are taken out of context way too often
13:59:46 <jle`> roelof: it'd be nice to have an Arbitrary instance for Line though to test actual property tests, but do you know how to declare a typeclass instance?
13:59:52 <Wchm> mauke: That'd translate to lookup x = snd . head . filter ((flip (.) fst . (==)) x) I believe, but I still have to keep the x param?
13:59:55 <jle`> instance Arbitrary (Line a) where ... ?
13:59:59 <linduxed> tnecniv: here it is http://videlalvaro.github.io/2015/02/programming-myths.html
14:00:19 <linduxed> it's long, but a pretty good read
14:01:27 <tnecniv> linduxed i see
14:01:29 <Zoetrope> n^2 vs n log n is a time where I'd say it's not premature :D
14:02:09 <roelof> jle : I know I do not use random values to test. This code only works with only one case and that is when both numbers are zero 
14:02:14 <zomg> Zoetrope: is there a point where n^2 and n log n and the whole big O notation becomes intuitive? :P
14:02:23 <zomg> because although I kinda get it, it's just not intuitive for me at all :D
14:02:23 <tnecniv> linduxed i still think it makes some sense
14:02:28 <maerwald> improving time complexity is never premature
14:02:30 <mauke> :t snd . head . ((filter . (flip (.) fst . (==))) 5)
14:02:31 <lambdabot> (Eq a, Num a) => [(a, c)] -> c
14:02:49 <frerich_> linduxed: For the duplicates check, you could use something like 'let s = sort xs in any (\(a,b) -> a == b) (zip s (tail s))'
14:02:56 <roelof> I find it very difficult to make good test  for my code. There are 3 cases with totally diffferent outcomes 
14:03:10 <mauke> :t (((snd . head) .) . (filter . (flip (.) fst . (==)))) 5
14:03:11 <frerich_> linduxed: I.e. you sort the list and then check if any two subsequent elements are equal.
14:03:11 <lambdabot> (Eq b, Num b) => [(b, c)] -> c
14:03:16 <mauke> :t (((snd . head) .) . (filter . (flip (.) fst . (==))))
14:03:17 <lambdabot> Eq b => b -> [(b, c)] -> c
14:03:24 <mauke> Wchm: ^
14:03:39 <Wchm> mauke: Holy. Nice!
14:03:55 <mauke> also, this was completely wasted effort
14:03:56 <roelof> jle: nope, that part is not explained in the book so far.  How to declare a typeclass instance. Instances are totally not explained so far 
14:03:58 <mauke> I could've just done:
14:04:22 <linduxed> tnecniv: oh yes, the expression still does have wisdom attached to it, even in its most shallow invocation.
14:04:23 <Wchm> Thanks! :)
14:04:35 <roelof> The only mention is in one example file as 'magic' without any explantion 
14:04:59 <mauke> @pl \x xs -> snd (head (filter (\(a, b) -> a == x) xs))
14:05:00 <lambdabot> ((snd . head) .) . filter . (`ap` snd) . (. fst) . (const .) . (==)
14:05:01 <linduxed> tnecniv: i'm just saying that that article made me reconsider it, and a couple of other things, since they were spoken within some context
14:05:28 <Wchm> ah yeah, naturally - I just started writing it in point free and got a type error then was curious if it was possible
14:05:41 <mauke> @pl \x xs -> snd (head (filter (\a -> fst a == x) xs))
14:05:41 <lambdabot> ((snd . head) .) . filter . (. fst) . (==)
14:05:46 <mauke> there we go
14:06:19 <maerwald> the question is when is premature optimization actually premature or in fact foresighted
14:06:33 <Wchm> mauke: Thanks though, I appreciate the effort, nice solution! :)
14:06:40 <roelof> jle : Can I use this as a good example:  instance Arbitrary (Line a) where 
14:06:41 <Zoetrope> zomg: Oh sure, roughly think of n^2 as "it does a full pass of the list for every item of the list", n log n is "for every item it does (number of times you can have the items) more passes"
14:07:13 <mauke> pl got the same solution, modulo redundant parens and flip -> sections
14:07:30 <Zoetrope> So n log n is a huge saving vs n^2
14:07:33 <Wchm> pl?
14:07:42 <mauke> @help pl
14:07:42 <lambdabot> pointless <expr>. Play with pointfree code.
14:08:00 <Wchm> aha sorry I thought lambdabot was another member of the IRC hahahaha
14:08:00 <maerwald> it's called pointless for a reason...
14:08:11 <mauke> @pl \f g x -> f x (g x)
14:08:12 <lambdabot> ap
14:08:28 <Zoetrope> zomg: Woops, *half, not have
14:08:45 <hask_noob2> What is "Elem" and "List" in this solution: https://wiki.haskell.org/99_questions/Solutions/7 
14:08:53 <hask_noob2> are they keywords?
14:09:17 <roelof> jle`:  chips , also not working : instance Arbitrary (Line a) where  Line { slope :: a, intercept :: a} I see parse error on : 
14:09:50 <Zoetrope> hask_noob2: Value constructors, just functions that produce a value of type NestedList
14:09:53 <mauke> hask_noob2: they're defined in line 1 of the code
14:10:15 <Wchm> @pl \x -> x+x
14:10:16 <lambdabot> join (+)
14:10:39 <hask_noob2> mauke, I get what NestedList is, but I don't know where "Elem" and "List" are defined.
14:10:41 <Wchm> Cool bot :0
14:10:47 <mauke> hask_noob2: they're defined in line 1 of the code
14:11:54 <Zoetrope> Line 1 says there's 2 ways to make a Nestedlist, either with "Elem" and a value or "List" and a list of Nestedlists
14:12:30 <hask_noob2> ok that's actually defining "NestedList", "List", and "Elem" all in 1 line?
14:12:44 <Zoetrope> Yup basically, you define the structure up front
14:15:38 <roelof> no one who can help me figure out how to make a type class instance ? 
14:15:51 <zomg> Zoetrope: cool, tbh I don't need to think about that almost ever which is probably why it isn't intuitive :)
14:18:04 <mauke> hask_noob2: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
14:18:15 <hask_noob2> mauke, thanks
14:18:21 <mauke> roelof: instance SomeClass SomeType where ...
14:18:41 <roelof> Yes, I do this : instance Arbitrary (Line a) where  Line { slope :: a, intercept :: a} 
14:18:50 <roelof> but I see a parse error on the :: 
14:19:11 <mauke> roelof: that makes no sense
14:19:16 <mauke> roelof: are you trying to define a type?
14:19:49 <roelof> no, I try to make a type class instance so I can test a custom data type 
14:19:59 <mauke> roelof: how is your custom data type defined?
14:20:03 <roelof> but the book has no explained it yet 
14:20:25 <roelof> mauke:  like this : data Line a = Line { slope :: a, intercept :: a}
14:20:44 <mauke> ok, that looks good
14:20:47 <roelof> but QuickTest can work with it 
14:21:10 <mauke> roelof: the body of a class instance should contain method definitions, not a copy of the data type definition
14:21:18 * mauke checks documentation
14:21:33 <mauke> looks like you're supposed to define 'arbitrary'
14:22:29 <roelof> mauke:  I think I try to do that. I have seen a example where Arbitrary is used as 'magic' to test a custom data-type
14:22:39 <mauke> roelof: instance (Arbitrary a) => Arbitrary (Line a) where arbitrary = Line <$> arbitrary <*> arbitrary
14:22:51 <mauke> ... at least I think that's how it works
14:23:04 <atomx> hi
14:23:24 <atomx> wow.
14:23:29 <mauke> o/
14:23:32 <atomx> about 1400 haskellers
14:23:46 <atomx> this is how emacs counts for me...
14:24:13 <mauke> yeah, but less than 10 active at any given time
14:24:20 <atomx> :)
14:25:07 <roelof> bummer : Not in scope: type constructor or class â€˜Arbitraryâ€™ 
14:26:15 <mauke> roelof: import Test.QuickCheck
14:26:16 <atomx> I would like to ask about where to start from understanding the monads.  I want to find something for beginners, to clearly understand how to convert general arrows in executable code...   I would like to understand it more generally than their use in haskell, but in any programming language.
14:27:16 <atomx> I found nothing practical.  I saw that Erik Meijer and M Oderski do monads in their course on coursera but I did not take the course as yet...
14:27:47 <atomx> please, can you recommend where to start from ?
14:29:44 <jmcarthur> I wouldn't say that Haskell uses monads in a way that is distinct from how other languages would use it, if they were as popular in other languages as they are in Haskell.
14:30:37 <atomx> I implemented monads in scheme. In lisp/scheme I am able to write recursive functions that use >>= and unit operators
14:30:42 <atomx> But I want more
14:31:01 <atomx> I want to be able to create my own arrows in a particular situation.
14:31:06 <jmcarthur> Arrows?
14:31:08 <atomx> as a real programmer do.
14:31:18 <atomx> yes, category theory
14:31:22 <mauke> ???
14:31:34 <jmcarthur> In Haskell, there is a thing called an "arrow" which is not the same thing as a monad, but I kind of think that isn't what you are talking about.
14:31:41 <atomx> https://www.haskell.org/arrows/
14:31:54 <jmcarthur> Ah, it is what you are talking about.
14:31:59 <atomx> I want to understand everything
14:32:01 <jmcarthur> So, arrows are not monads.
14:32:01 <mauke> what does that have to do with CT?
14:32:06 <roelof> chips. stll this error message : http://lpaste.net/147884
14:32:22 <atomx> no, more general. Monads are probably the simplest arrows
14:32:30 <roelof> maybe I have to make a instance of the custom type Result also :( 
14:33:06 <atomx> Anyway
14:33:20 <mauke> roelof: what's testProperty?
14:33:41 <atomx> My desire would be to understand the real essence of monads, arrows and how can I do with them in general.  To use them in programming
14:33:58 <jmcarthur> atomx: There may be some confusion about what "general" means here. Arrows are not more powerful than monads.
14:34:28 <roelof> testProperty is something I had to use to use Tasty as test-platform to make QuickCheck tests 
14:34:30 <atomx> I saw some videos with Brian Beckam on Channel9 and he did some demonstration of arrows.  He is a real expert
14:34:58 <jmcarthur> atomx: Arrows are also a much more ad hoc and somewhat needlessly complex abstraction than monads. I don't think there is a ton to learn about monads or category theory in general from arrows.
14:35:06 <atomx> jmcarthur: my informal understanding was that arrows were more general.  
14:35:07 <mauke> roelof: also, what is x supposed to be there?
14:35:23 <atomx> ah, ok
14:35:28 <atomx> jmcarthur: OK.
14:35:30 <atomx> So
14:35:51 <roelof> nothing. This property works on the fact that two numbers have to be zero 
14:35:57 <jmcarthur> atomx: They are more general in the sense that anything that is a monad can also be described as a kleisli arrow. But other things are arrows which are not monads.
14:36:02 <mauke> roelof: that's not a property
14:36:05 <roelof> but without it , I see more error message 
14:36:06 <atomx> Can you recommend me a good place to start understading the real science behind them and to learn to use them in their generality ?
14:36:21 <atomx> ok
14:36:57 <mauke> roelof: what error do you get without '\x ->'?
14:37:06 <atomx> So, I watched many pages found by google about monads, all explain the same things, but I cannot understand what happens there
14:37:08 <jmcarthur> atomx: There are opposing goals in your question. Learning the theory won't necessarily mean you can use them to their full potential in practice. Getting better at using monads/arrows in practice doesn't require you to learn a lot of the theory.
14:37:28 <roelof> mauke:  o, someone says this is a good way to use QuickCheck to test my function which looks like this : http://lpaste.net/147886
14:37:30 <atomx> I want practice only
14:38:02 <jmcarthur> I have to go. Hopefully I've at least helped you clarify what you're looking for, but I'm sorry I wasn't able to offer specific suggestions.
14:38:07 <atomx> I am interested only about practicing with them -- understainding them in their full power.
14:38:15 <roelof> with your instance no error anymore 
14:38:17 <atomx> OK
14:38:20 <atomx> Thank you
14:38:33 <roelof> mauke:   with your instance no errors anymore 
14:38:37 <mauke> you probably don't need that instance anyway
14:38:50 <mauke> you're directly testing a Bool, which just works
14:39:42 <roelof> oke, tomorrow I have to make two more tests ; -- prop_crossX_None (NonZero i) = crossX (Line 0 i) == None   and --  prop_crossX_One (NonZero s) i = crossX (Line s i) == One ((-i) / s) 0  
14:39:57 <roelof> now really time to sleep. it's here 23:39 
14:40:29 <mauke> yeah, that still doesn't require an Arbitrary instance
14:41:48 <roelof> he, your right. Wierd,  I did this afternoon the same and I saw error messages 
14:42:06 <roelof> but as I said, now time to sleep , thanks for the help 
14:42:20 <mauke> good night :-)
14:42:46 <roelof> thanks, and you thanks for the help 
14:43:28 <immersion1> Is it possible to specify a "default" instance for GHC to use rather than emitting an error when a type is ambiguous? http://lpaste.net/147887
14:46:11 <KaneTW> immersion1: there's a `default` keyword but it only works for specific typeclasses atm
14:46:24 <geekosaur> not currently, no. there is a defaulting mechanism for numbers, but extending it to support lists is problematic
14:46:35 <geekosaur> (which would be necessary for String)
14:49:15 <pavonia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#overloaded-strings suggests it already works
14:50:23 <geekosaur> hm, guess they added a hackaround in 7.10 then. the list discussion from back when suggested they didn't want to do that
14:51:22 * hackagebot streaming 0.1.4.0 - an elementary streaming prelude and general stream type.  https://hackage.haskell.org/package/streaming-0.1.4.0 (MichaelThompson)
14:55:22 <immersion1> Ok, thanks
14:56:23 <geekosaur> what version of ghc are you using?
15:06:23 * hackagebot streaming-bytestring 0.1.4.0 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.4.0 (MichaelThompson)
15:23:12 <spaceloop> how can I ask stack to install some executables from hackage to be used for building my project? 
15:29:26 <Kaidelong> lens doesn't seem to support destruction and mutation too well, even the examples of doing it with IO use "StateT", is there a guide to if you want to use hashtables or mutable vectors with it?
15:30:46 <Kaidelong> (perhaps you could use WriterT (ST ())?)
15:33:41 <Kaidelong> oh ST () isn't a monoid, but it is an applicative
15:37:36 <linduxed> so i'm in ghci and i've figured out that i can do `readFile "somepath"` to get a IO Text
15:37:56 <linduxed> my objective is to turn this into a list of lines, so [String]
15:38:29 <linduxed> i suspect i'll have to do unpack on the Text, but right now i need to get the Text out of the IO
15:38:31 <mauke> why not [Text]?
15:38:34 <linduxed> how would i do that?
15:38:42 <jmcarthur> Kaidelong: afaik, it is difficult to come up with meaningful, practical laws for "monadic lenses"
15:38:43 <linduxed> mauke: because my functions take String
15:38:47 <linduxed> :-/
15:38:53 <mauke> then why are you using the readFile function from text?
15:38:59 <geekosaur> you can't get out of the IO. you can fmap over it or you can use >>=
15:39:08 <geekosaur> but you will always end up in IO
15:39:13 <linduxed> mauke: i'm using whatever i find that reads a file in ghci
15:39:14 <mauke> ghci is a do block, so you can just say foo <- readFile ...
15:39:18 <linduxed> it was the first thing i found
15:39:23 <mauke> linduxed: so ... how about the standard readFile?
15:39:27 <geekosaur> (ghci will mostly hide this from you)
15:39:35 <linduxed> mauke: ooooh, so that's why i always have to write let
15:39:40 <linduxed> because it's a do-block
15:39:50 <linduxed> that explains things
15:39:53 <geekosaur> to a first approximation, yes
15:40:00 <Kaidelong> jmcarthur: so if I want to implement things like harmony search that rely deeply on destruction, I just shouldn't use lenses?
15:40:13 <geekosaur> (it's not a perfect one, note that you can do things like import and (for recent versions) data etc.)
15:41:08 <jmcarthur> Kaidelong: I'm not really knowledgable enough to say for sure, but that is my hunch.
15:41:15 <Kaidelong> I guess the better trick would be if there is a way to convince GHC that it can update a data structure in place, but I dunno how you could do that without substructural types
15:42:43 <jmcarthur> Substructural types tend to make your code beg for state monads anyway.
15:43:09 <jmcarthur> Because you end up with the  Collection -> (a, Collection)  pattern all over the place.
15:43:57 <jmcarthur> Moreso than normal persistent data structures, because there's really no other way to use it.
15:46:24 * hackagebot streaming-utils 0.1.4.0 - http, attoparsec, pipes and conduit utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.1.4.0 (MichaelThompson)
15:47:17 <nshepperd_> You could write pseudo lens accessors with type (a -> ST s1 b) -> (s -> ST s1 t)
15:47:51 <Kaidelong> MonadState looks like it might work for ST
15:47:56 <nshepperd_> Those would compose with lenses at least to get you into deep structures
15:48:06 <jmcarthur> I don't see how ST could implement MonadSTate
15:48:11 <jmcarthur> What would the state type be?
15:48:23 <jmcarthur> *MonadState
15:48:24 <Kaidelong> StateT s ST
15:48:38 <Kaidelong> that would allow put and get to be ST actions
15:48:39 <hpc> you can't define put or get
15:48:45 <hpc> :t get
15:48:46 <lambdabot> MonadState s m => m s
15:48:52 <hpc> there's no global state to get from
15:49:03 <hpc> ("global" wrt a single action)
15:49:17 <jmcarthur> So you're saying the instance would be MonadState state (ST s) >?
15:49:19 <jmcarthur> *?
15:49:26 <nshepperd_> Kaidelong: that type is a state on top of ST
15:49:41 <Kaidelong> I'm not sure how get would work, admittedly
15:49:50 <Kaidelong> mm
15:50:00 <jmcarthur> ST and State are very different things
15:50:01 <nshepperd_> Get and put would ignore ST and affect the StateT stars
15:50:02 <Kaidelong> or set, for that matter, so never mind
15:50:29 <Kaidelong> what would "lift" even mean in this context?
15:50:47 <jmcarthur> nothing, because ST is not a monad transformer
15:52:24 <nshepperd_> Oh, that type is ill kinded. StateT s1 (ST s2) is what doesn't work
15:53:43 <athan> Anyone here use liquid haskell often? Can't really get started with it - `liquid` can't seem to find any of my modules
15:54:02 <maerwald> athan: I use the vim addon sometimes
15:54:11 <maerwald> works relatively well, except when liquidhaskell screws up
15:55:00 <athan> maerwald: Is there a trick to make liquid search for modules in accordance to a .cabal file or anything?
16:01:34 <spaceloop> how can I ask stack to install some executables from hackage to be used for building my project? 
16:03:52 <maerwald> athan: recent liquidhaskell has a --cabaldir option afais
17:09:20 <ReinH> spaceloop: if you stack install happy from outside a project directory it will install the binary to ~/.local/bin, which must then be in your PATH
17:09:47 <ReinH> spaceloop: (It might do this if you stack install happy inside a project dir too, but I haven't checked)
17:10:07 <ReinH> spaceloop: obviously replacing happy with whatever package you need
17:12:28 <spaceloop> ReinH: and is it possible to add a dependency on this executable to my stack.yaml file, so that installing it becomes part of the building of my package?
17:12:47 <ReinH> spaceloop: I don't know.
17:13:40 <spaceloop> ReinH: Ok, thanks anyway :)
17:17:14 <SrPx> No alternative to gloss-raster that doesn't implode the stack solver?
17:41:07 <maerwald> yeah, I have copy pasted gloss code, because it is awfully modularized
17:41:37 <maerwald> just because I need some geometrical functions, I have to build the whole OpenGL thing, yeah right
17:49:12 <athan> maerwald: Yep, that flag to liquid did the trick! Thank you!
17:52:24 <pranz> I'm having weird results (weird to me) from attoparsec
17:52:53 <pranz> why does `parse (takeWhile1 (const True)) $ pack "stat"` return a partial?
17:54:46 <athan> pranz: I think you need `endOfFile` or something in your parser to make it consume all of it
17:55:01 <dmj`> pranz: try parseOnly
17:55:03 <athan> iirc `parseOnly` might be what you want if you just want to parse and not think about leftovers
17:56:54 <pranz> athan, dmj`: it does seem to be what I want, thanks!
17:57:33 <maerwald> athan: I was wondering if I can use liquidhaskell in my project to prove that all filepaths are absolute
17:59:25 <athan> maerwald: I bet you could pretty easily, just `type AbsoluteFilePath X = {xs :: FilePath | length xs > 0 && head xs == '/'}`
17:59:37 <athan> er X :: FilePath :s
17:59:45 <athan> shoot idk
18:00:11 <athan> Do you happen to know what the different keywords mean? Like measure and predicate? I'm trying to find them in the docs now
18:11:47 * hackagebot hfmt 0.0.2.0 - Haskell source code formatter  https://hackage.haskell.org/package/hfmt-0.0.2.0 (danielstiner)
18:27:22 <athan> WOO IT TYPECHECKS
18:29:59 <maerwald> athan: no, I don't use it that much
18:30:17 <maerwald> it can be rather slow on large modules
18:30:25 <maerwald> at least the vim plugin with syntastic
18:32:20 <amalloy> i don't see a function in hoogle with type (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering. that is, i have two ways to compare elements of type a, and i want a new way out that tries f, and falls back on g if f has no preference
18:32:43 <amalloy> eg, compare two lists on their length and then on their sum
18:34:00 <maerwald> you mean "fall back for EQ"?
18:34:39 <amalloy> yeah
18:34:52 <amalloy> prefer f g x y = case f x y of {EQ -> g x y;  r -> r}
18:34:55 <maerwald> haven't seen such a thing either, I just write it like I need it
18:35:23 <amalloy> it seems like something that might live in Data.Function, near stuff like `on`
18:36:11 <kadoban> Isn't there a Monoid for Ordering? That could be useful for that probably, though I'm not sure the plumbing immediately.
18:37:04 <amalloy> oh, i bet you're right
18:37:21 <amalloy> i've heard of that before but had forgotten
18:37:29 <geekosaur> looks like it, yes
18:37:45 <geekosaur> @src Monoid Ordering
18:37:45 <lambdabot> Source not found. Where did you learn to type?
18:37:48 <amalloy> prefer f g x y = f x y `mappend` g x y
18:38:12 <ReinH> :t (comparing fst, comparing snd)
18:38:14 <lambdabot> (Ord a, Ord a1) => ((a, b) -> (a, b) -> Ordering, (a2, a1) -> (a2, a1) -> Ordering)
18:38:24 <ReinH> :t comparing fst <> comparing snd
18:38:25 <lambdabot> (Ord a, Ord a1) => (a1, a) -> (a1, a) -> Ordering
18:38:35 <ReinH> amalloy: There is a convenient Monoid instance for that.
18:38:56 <amalloy> :t (<>)
18:38:57 <lambdabot> Monoid m => m -> m -> m
18:39:02 <geekosaur> it's mappend
18:40:18 <ReinH> The Monoid instance in question is for a -> a -> Ordering, not Ordering
18:40:52 <amalloy> right. but it needs the latter one too, right? because it involves calling mappend on two Orderings
18:41:50 <amalloy> blurg. i still don't really get the Monoid instance for functions
18:42:12 <geekosaur> actually I think this is a combination of the Monoid on Ordering and the Monoid on (a -> b)?
18:42:47 <amalloy> yes
18:42:54 <geekosaur> amalloy, basically apply each function and mappend the results. which is why b (the result) must be a Monoid as well
18:43:52 <geekosaur> and for this, that instance gets used twice; the result of the first is another function, whose result type is Ordering, so it applies the (a -> b) instance again, then uses the Ordering instance
18:45:05 <geekosaur> each application consuming one parameter
18:45:23 <amalloy> :i comparing
18:45:29 <geekosaur> no :i
18:45:35 <amalloy> where is that?
18:45:43 <geekosaur> @index comparing
18:45:44 <lambdabot> Data.Ord, Distribution.Simple.Utils
18:47:14 <michaelt> @type \f g -> comparing f <> comparing g
18:47:16 <lambdabot> (Ord a, Ord a1) => (b -> a) -> (b -> a1) -> b -> b -> Ordering
18:47:26 <ReinH> geekosaur: it is only the Monoid for Monoid b => Monoid a -> b, in fact. It gives a new a -> a -> Ordering that results from jamming the given ones together.
18:47:37 <ReinH> it doesn't append any orderings together
18:48:10 <ReinH> (It does depend on an instance existing for Ordering, but it does not use it)
18:48:59 <ReinH> It is a bit complicated because a -> a -> Ordering uses the instance Monoid b => Monoid (a -> b) *twice*, once for a -> (a -> Ordering) and once for a -> Ordering.
18:49:13 <geekosaur> I think we said the same thing,a ctually
18:49:19 <geekosaur> becuase that last is what I was trying to say
18:49:26 <ReinH> IOW, a -> Ordering is a Monoid because Ordering is a Monoid. a -> a -> Ordering is a monoid because a -> Ordering is a Monoid because Ordering is a Monoid.
18:49:28 <geekosaur> and apparently failed to say it clearly enoiugh :/
18:49:34 <ReinH> geekosaur: quite possibly :)
18:49:40 <ReinH> geekosaur: Or more likely I failed to understand you.
18:50:28 <geekosaur> I may have implied that the instance was doing the applying, when I meant the typechecker was
18:50:39 <maerwald> athan: {-@ type AbsoluteFilePath X = {xs : String | (length xs > 0) && (head xs == '/') } @-} <- it says "cannot parse specification" and complains about the "=="
18:50:40 <geekosaur> er, "using" with my original woirding
18:50:45 <maerwald> was there another way to express that?
18:55:25 <maerwald> I feel like that is a bug, it should allow a relation there
19:18:47 <athan> maerwald: Well, actually I'm not sure if an arbitrary literal is considered a constant
19:18:51 <athan> I think only numerical ones are
19:19:04 <athan> you could easily make a measure for that though
19:20:13 <athan> safeHeadEq :: a -> [a] -> Bool; safeHeadEq x [] = False; safeHeadEq x (y:_) = x == y
19:20:23 <athan> then {-@ measure safeHeadEq @-}
19:21:10 <athan> then {-@ type AbsoluteFilePath = {v:FilePath | safeHeadEq '/' v} @-}
19:21:28 <athan> maerwald: Have you heard of Chris Done's path library, btw?
19:42:12 <athan> mer, it looks like you can't use liquid haskell measures on unexposed data constructors, like with HashMap :(
19:56:23 <pilne> it seems like the more i read, the more the "deficiencies" of haskell are either overhyped by c++ fanboys or based on speculation by people who haven't actually used it
19:57:19 <c_wraith> a lot of people have trouble believing it can actually work.
19:57:42 <pilne> but... its just math at it's core... math always works unless i'm trying to do it in my handwriting!
19:58:09 <rcyr> Haskell doesn't have enough curly braces.. that's why :)
19:58:10 <c_wraith> Lots of people have for-loops so ingrained that they can't imagine a language that doesn't allow you to increment a counter.
19:58:31 <c_wraith> rcyr: it can!  SPJ uses curly braces and semicolons for everything he does in GHC. :)
19:59:00 <pilne> but... if you have a function that knows (in one way or another) when you've done enough iterations why does it matter if it is a for loop, recursion, or a fold?
19:59:21 <rcyr> c_wraith: Hehe :)
20:00:26 <c_wraith> pilne: some people just believe that only manual memory management can work.  (Mutable data is one case of manual memory management)
20:01:16 <pilne> i think... when computers were slower, and concurrency/parallelism were nothing but a cs wet-dream, they might have had a point... but that is... forever ago it feels like
20:02:41 <c_wraith> pilne: I think ultimately the biggest objection people have is "Why should I bother to learn something *so* different? My language of choice already works"
20:02:45 <kadoban> pilne: Most of anyone's problems with any language X are that it doesn't have feature Y that their favorite language does, regardless of how meaningless feature Y is in the scheme of things.
20:03:09 <c_wraith> pilne: and it's awfully difficult to convince people that things actually can be different for a good reason.
20:03:18 <pilne> i've been trying my damndest with some very sharp google-fu to find things that are impossible to implement in haskell
20:03:55 <geekosaur> impossible? nothing. it's provably Turing equivalent
20:04:10 <pilne> roflmao! love it
20:04:13 <geekosaur> hard to implement? certainly possible
20:04:35 <c_wraith> You can even fall back to writing everything the same as you would in any other language.  It's painful, but sometimes necessary.
20:05:02 <geekosaur> (that is, you can surely find things that are hard to do in Haskell)
20:05:32 <Bruuuuuuno> or just call a c function
20:05:48 <Bruuuuuuno> if you really have trouble 
20:05:57 <c_wraith> The funny thing is, people keep working at making more stuff easy.
20:06:18 <Bruuuuuuno> that's how open source works
20:06:23 <c_wraith> More things get easy *really fast* in haskell.
20:07:00 <pilne> actually, if i was gonna call into another language, i'd love for it to be forth, but i'm a few cards short of a full deck (:
20:07:30 * hackagebot handa-opengl 0.1.13.0 - Utility functions for OpenGL and GLUT  https://hackage.haskell.org/package/handa-opengl-0.1.13.0 (BrianBush)
20:07:37 <geekosaur> from a speed standpoint, forth would be a nearly ideal glue language
20:07:48 <Bruuuuuuno> forth?
20:08:01 <pilne> yus
20:09:49 <Bruuuuuuno> it looks old
20:10:24 <pilne> it is
20:10:36 <geekosaur> it is old. it is also simple enough that it's not really going to, or expected to, evolve. it's very low level
20:10:46 <geekosaur> if you want a more recent take on the same concept, look at postscript
20:10:50 <c_wraith> It's the language mac UEFI uses.
20:11:03 <pilne> sun bioses too i think
20:11:31 <pilne> eh, i don't want more modern, i want my glue to assembly (without doing assembly) to be as lean as possible (:
20:12:51 <Bruuuuuuno> I would like a functional programming assembly
20:13:33 <c_wraith> there's ATS
20:13:55 <c_wraith> It's more of a dependently-typed assembly.
20:15:30 <Bruuuuuuno> oh wow
20:16:01 <geekosaur> anyway the use case of forth is generally doing low level device control with a fast and not quite as low level programmer interface. forth fills that niche well, which is why it's used in BIOSes and why astronomers use it for telescope control
20:16:52 <geekosaur> you sometimes find it in other embedded control contexts, but often there's a wrapper language around it (I once programmed one that presented a variant of BASIC as the programmer interface but compiled that to FORTH)
20:17:12 <Bruuuuuuno> you could write an FFI to it
20:18:58 <Wchm> Hi! Stupid question. I'm trying to get my head around monads and 'return' is bothering me a bit
20:19:22 <Wchm> In Maybe's implementation, return is just set to "Just", and I was wondering why "return (Just 5)" doesn't give me Just Just 5
20:19:29 <c_wraith> It should..
20:19:37 <jle`> > return (Just 5) :: Maybe (Maybe Int)
20:19:39 <lambdabot>  Just (Just 5)
20:19:39 <c_wraith> > return (Just 5) :: Maybe (Maybe Int)
20:19:41 <lambdabot>  Just (Just 5)
20:19:45 <geekosaur> it's usually best not to try to understand monads as such; the understanding will come with use
20:19:55 <geekosaur> they are an abstraction that is hard to describe in words
20:19:56 <Bruuuuuuno> what's the context Wchm?
20:19:57 <jle`> > return (Just 5) :: [Maybe Int]
20:19:59 <lambdabot>  [Just 5]
20:20:10 <jle`> return is polymorphic so it'll match whatever type you request
20:20:12 <Wchm> Huh. Was executing in ghci; I guess it was grabbing wrong return or something?
20:20:13 <c_wraith> Wchm: if you're testing in ghci, it will assume any unconstrained monad is IO, and it will execute the action and print its result, Just 5
20:20:22 <geekosaur> ghci will generally assume IO
20:20:23 <jle`> and yeah, this is more of a 'mechanics of typeclasses' thing than a monads thing
20:20:28 <Wchm> Ah thanks :)
20:20:38 <geekosaur> you can think of ghci's prompt as being the inside of a "do" in IO
20:22:43 <c_wraith> Wchm: I'll second geekosaur, though.  "understanding monads" isn't a useful goal.  It's also not that important when first getting into Haskell.
20:24:06 <Wchm> Any chance you can recommend any projects / resources for helping to learn them by example then?
20:24:13 <Wchm> I've done a binary tree so far
20:24:23 <jle`> just do your normal projects
20:24:27 <jle`> without worrying about learning monads :)
20:24:27 <nitrix> Haskell isn't particuliarly easy to learn by example.
20:24:53 <jle`> you'll use the utility functions from each type as you encounter them
20:24:56 <Wchm> My main issue is I'm not 100% solid on where they'd be useful so in my projects I'd normally just do some horrible workaround
20:24:59 <jle`> no need to spend time *just* to learn monads
20:25:25 <jle`> well, if you are working with a particular type, and you find that working with them is awkward, then look into the monad interface for that specific type
20:25:45 <jle`> monad isn't a general solution to anything; it's just a typeclass that exposes a useful interface to types you'll be using
20:26:03 <nitrix> Wchm: To reassure you; Haskell is very easy to refactor. It has everything going in that favor... so just go ahead and as you learn you things, you can reword the code.
20:26:03 <jle`> if anything, you want to be learning about different types you can use
20:26:05 <jle`> not different monads :)
20:26:28 <nitrix> new things*
20:26:31 <jle`> if you feel like you're doing things in a weird way and there might be a nicer solution, then finding a type that will help is more useful than finding monads
20:26:42 <jle`> or knowing "about monads"
20:26:44 <Wchm> jle`: Makes sense, thanks! :D I think I'll read over IO, Maybe, ect and try to remember the type signatures and leave it at that
20:26:56 <jle`> knowing about useful types is what's going to help you :)
20:26:56 <Wchm> (type signatures for bind, ect that is)
20:27:07 <nitrix> My recommendation is to use the most naive approach and ask here for improvements if you aren't convinced.
20:27:32 <Wchm> nitrix: Thanks! ^_^
20:27:38 <nitrix> You'll just feel when things doesn't seem right.
20:28:19 <nitrix> I know that sounds completely dumb and has no foundation whatsoever to support that claim, but yeah.
20:28:19 <jle`> yeah; Maybe is a wonderful type, with a lot of nice utility functions; it just so happens that a lot of them are only offered through typeclass methods.  `fmap` on Maybe is useful in and of itself, bind on Maybe is useful, <|> on Maybe is useful for working with Maybe, etc.
20:28:50 <jle`> i think elm actually takes this approach for a lot of things.  provide these useful utility functions with their own names, and not just as fmap and bind
20:29:11 <jle`> the nice thing about giving them names from typeclasses is that you can use polymorphic utility functions on them (like sequence, etc.), so, there's some benefit
20:29:11 <c_wraith> jle`: that's because elm doesn't have type classes
20:30:08 <jle`> yeah; but i've heard eric say that he actually thinks that having them each be separate functions is useful in and of itself, and not just a consequences of no-typeclasses
20:30:44 <c_wraith> jle`: sort of, but if you can't write class-polymorphic functions, you can't write lens. :)
20:30:54 <jle`> there's some pedagogical benefit, but i still think the benefit of being able to use polymorphic code is useful enough to justify it
20:30:58 <jle`> yeah :3
20:32:11 <nitrix> Wchm: Last word recommendation would be to join #haskell-beginners.
20:32:59 <Wchm> Will do, thanks! Sorry, hadn't realised that was a thing.
20:33:16 <jle`> mhm but also #haskell is a great channel for beginners too and we love beginner questions :D
20:33:18 <c_wraith> It's fine to ask beginner questions in here, too
20:33:49 <c_wraith> It's just that you can get into a lot more depth there, especially at times when this channel is busy.
20:33:50 <shachaf> #haskell-beginners is unrelated to this channel.
20:34:03 <Wchm> Ah okay, cool :D
20:34:15 <c_wraith> Speaking of..  only 1385 people?  This channel's unusually empty right now.  Must be the holiday break. :)
20:36:08 <jle`> wouldn't holiday season be more reason to program more haskell
20:36:10 <jle`> :3
20:39:15 <dmj`> jle`: fa lalala la la la la
20:39:50 <nitrix> lalalalala la la!
20:42:14 <Bruuuuuuno> I still have to finish advent of code
20:42:56 <dmj`> Bruuuuuuno: there's always next year
20:42:57 <Wchm> Night guys; thanks for the help!
20:44:13 <Bruuuuuuno> I have 44 stars so I can finish it soon haha
21:17:32 * hackagebot language-thrift 0.5.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.5.0.0 (abhinav)
21:30:06 <acertain> does anyone know of parsers for haskell-like languages implemented using a parser combinator library?
21:34:09 <wedens> acertain: idris uses trifecta IIRC
21:34:19 <Bruuuuuuno> f# has one, but I never used it
21:34:35 <Bruuuuuuno> http://www.quanttec.com/fparsec/
21:35:18 <wedens> I guess I don't understand the question
21:36:26 <acertain> I intended to ask what wedens answered
21:37:30 <Bruuuuuuno> oh no I didn't understood sorry haha. Maybe it's time for me to go to bed
21:40:53 <wedens> elm uses parsec and ermine uses trifecta (if you consider them haskell-like)
21:54:51 <pikajude> rats. the magic CallStack implicit param doesn't work in an instance declaration.
21:56:29 <jle`> oh, that's interesting
21:56:56 <jle`> what if you used it in a helper function and let the method = the helper function?
21:57:05 <pikajude> yeah
21:57:07 <pikajude> then it works
21:57:46 <jle`> i wonder if this is desirable behavior
22:00:00 <pikajude> i'll do some testcases
22:27:31 <badmash> hey quick question haskell type syntax
22:27:44 <badmash> any help will be appreciated
22:28:06 <Clint> yes, it has type syntax
22:28:08 <c_wraith> badmash: just go ahead and ask
22:29:02 <badmash> haskell context-free grammar for type syntax allows type expressions such as [ (->) ] -- that doesn't seem to make sense to me 
22:29:44 <c_wraith> Why not?
22:30:11 <c_wraith> I mean, it'll fail type-checking.
22:30:16 <c_wraith> But it's syntactically valid
22:30:27 <c_wraith> I guess technically, it fails kind-checking.
22:30:28 <badmash> because if try to get the kind of that type, it throws an error
22:30:41 <c_wraith> Yes, there are ways to be wrong other than syntactically.
22:30:44 <badmash> :k [(->)]  --- throws an error
22:30:45 <lambdabot>     Expecting two more arguments to â€˜(->)â€™
22:30:46 <lambdabot>     Expected kind â€˜*â€™, but â€˜(->)â€™ has kind â€˜* -> * -> *â€™
22:30:46 <lambdabot>     In a type in a GHCi command: [(->)]
22:31:05 <c_wraith> badmash: yes, because it's a semantic error.  Doesn't mean it's a syntactic error.
22:31:23 <badmash> c_wraith: i see
22:32:35 <badmash> c_wraith: so syntactically, the expression [(->)] is correct, you mean?
22:32:35 <c_wraith> yes
22:33:07 <badmash> c_wraith: so why have something in the syntax if it has is invalid semantically?
22:33:27 <badmash> i mean if it is semantically invalid
22:33:35 <c_wraith> badmash: because eliminating it would eliminate a lot of semantically valid things.
22:33:54 <badmash> c_wraith: i see
22:34:09 <c_wraith> :t undefined :: [Either]
22:34:10 <lambdabot>     Expecting two more arguments to â€˜Eitherâ€™
22:34:11 <lambdabot>     Expected kind â€˜*â€™, but â€˜Eitherâ€™ has kind â€˜* -> * -> *â€™
22:34:11 <lambdabot>     In an expression type signature: [Either]
22:34:40 <c_wraith> Just because that's invalid, should we make [Bool] invalid, too?
22:35:31 <c_wraith> badmash: basically, (->) is just a type constructor like Either
22:36:21 <badmash> c_wraith: ok, but i haven't understood your analogy yet
22:36:25 <c_wraith> badmash: It's semantically valid to refer to it as a type, because..  It is a type.  There are lots of cases where you want to refer to it unapplied.
22:36:41 <c_wraith> Instance Category (->) where...   
22:36:45 <c_wraith> *instance
22:36:49 <badmash> c_wraith: i see, you mean semantically, right?
22:37:26 <c_wraith> Yes, (->) is a type that's meaningful in a lot of contexts.
22:37:32 <c_wraith> Just not in that particular one.
22:37:48 <c_wraith> It has the same kind as Either
22:37:52 <badmash> c_wraith: so later, during the semantic checking, haskell raises a flag in all those areas where (->) doesn't make sense
22:38:41 <c_wraith> badmash: yep.  It fails the type checking, because the kinds don't match.  (kinds are types of types, if that hasn't been clarified)
22:39:06 <badmash> c_wraith: yeah, i see
22:39:52 <badmash> c_wraith: by the way, i noticed that when you say "type" in haskell, you always denote "type" in haskell with the type constructor
22:40:07 <badmash> the actual type is always implicit
22:40:29 <c_wraith> I'm not sure what you're saying there.
22:40:34 <badmash> for example, function "type" is (->) t1 t2
22:41:19 <badmash> (->) t1 t2 -- this is just an expression that returns a type using the function type constructor (->)
22:42:08 <badmash> that is, the so-called "function type" is denoted in haskell as the application of the function type constructor
22:42:53 <badmash> c_wraith: i am not sure if you see what i mean
22:42:59 <c_wraith> badmash: indeed.  (->) is a type constructor.  It takes two arguments, indicating the argument type and the return type.
22:43:29 <c_wraith> badmash: It's important to note that you can't have values of a type like (->).
22:43:39 <c_wraith> badmash: All values belong to the type *
22:43:47 <c_wraith> badmash: err.  All values belong to types with the kind *
22:44:05 <badmash> yeah, so everywhere you have a function type, you express it in haskell as the application of the function type constructor
22:44:29 <c_wraith> that's correct
22:45:26 <badmash> what is the actual type returned from the application of the function type constructor?  this is never cited explicitly in haskell
22:45:33 <badmash> that's what i mean
22:47:41 <wedens> type or another type constructor?
22:48:51 <badmash> wedens: i mean that in haskell when you say "type", you actually indicate that with an application of an type constructor
22:48:55 <c_wraith> badmash: I mean..  (A -> B) or ((->) A B) are two different ways of writing the same thing...  The type of a function which takes values of type A and returns values of type B
22:49:52 <wedens> badmash: no, you don't
22:50:27 <jle`> badmash: there's the concept of "types of types", if that's what you're looking for
22:50:35 <jle`> we call them "kinds"
22:50:40 <wedens> type ABC = (->) there is no application
22:50:59 <jle`> in haskell, there are types where you can have values of that type. like Int, Bool, [Double], (Int -> Bool)
22:51:05 <jle`> we call these types types of kind *
22:51:25 <jle`> but, there are definitely things that exist at the type level that you *can't* have values of
22:51:27 <jle`> like, (->)
22:51:36 <jle`> we say that (->) is not of kind *
22:51:44 <jle`> but, Int -> Bool is of kind *
22:51:51 <jle`> so you can have values of type Int -> Bool
22:52:12 <jle`> if you look at (->), you can say that it has kind * -> * -> *
22:52:29 <jle`> give it a * and a * (in this example, Int :: * and Bool :: *), and return a * in return -- (Int -> Bool :: *)
22:52:49 <jle`> so the "type" if `Int -> Bool` is more properly/technically a "kind" --- and it has the kind *
22:52:50 <badmash`> sorry i had got disconnected
22:53:05 <badmash`> so may have missed some responses
22:53:15 <jle`> ah, i gave a short expo right before you logged back on; maybe try checking out the logs?
22:53:25 <jle`> it'd be better than me re-typing and flooding everything :)
22:54:38 <badmash`> jle`: so (->) A B returns a kind, you mean?
22:54:45 <jle`> (->) A B returns a type
22:54:48 <nshepperd> badmash`: what distinguishes constructors from functions, both at the type and value level, in that the 'result' of their application has no structure above the arguments
22:54:51 <jle`> and its type is A -> B, or (->) A B
22:55:02 <jle`> just like [1,2,3] returns a value -- the value [1,2,3]
22:55:15 <jle`> applying `Just` to `10` returns a value: `Just 10`
22:55:40 <jle`> applying `Maybe` to `Int` returns a type: `Maybe Int`
22:56:08 <badmash`> nshepperd: i didn't exactly understand what you said
22:56:14 <jle`> the result of applying (->) to Int and Bool is `Int -> Bool`
22:56:23 <nshepperd> badmash`: like jle` said, the 'result' of (Just 10) is (Just 10)
22:56:24 <jle`> the result of applying `Just` to `10` is `Just 10`
22:56:40 <badmash`> jle`: i see
22:56:42 <nshepperd> literally stored in memory as a Just constructor containing a 10
22:57:01 <jle`> the result of applying Left to "hello" is `Left "hello"`
22:57:09 <badmash`> nshepperd: that's exactly what i am saying here
22:57:41 <badmash`> i am saying that in haskell, you use application of type constructors as a surrogate for types
22:57:53 <jle`> but, the result *is* a type
22:58:04 <badmash`> jle
22:58:04 <jle`> just like `Just 10` *is* a value...Just isn't used as a surrogate for Just 10
22:58:06 <badmash`> yes
22:58:16 <jle`> `Just 10` is as legitimate a value as "hello", or False
22:59:03 <badmash`> jle`: but in the code, you don't use that name for the type; instead, you indicate it as a return type  from the application of the type constructor
22:59:40 <nshepperd> right, so that 'actual type' returned from the application of (->) Int Bool is Int -> Bool
23:00:02 <nshepperd> sure, you can write 'type Foo = Int -> Bool'
23:00:14 <nshepperd> but then Foo is a synonym for Int -> Bool, not the other way round
23:00:14 <badmash`> nshepperd: ok
23:01:33 <badmash`> nshepperd: so you are saying that type constructor application and type returned are pretty much synonmous?
23:04:11 <jle`> i think i see the trickiness here
23:06:30 <dresuer> Hi all!
23:06:49 <dresuer> I wanna implement a simple chat serv
23:06:58 <dresuer> I'm working on Windows 
23:07:37 <badmash> sorry, once again got disconnected
23:07:47 <dresuer> And I get Could not find module 'Network.Socket'
23:07:53 <dresuer> message
23:07:54 <jle`> badmash`: i think you're asking, maybe, when you see/type "Int -> Bool", are you typing the application of the (->) function to Int and Bool, or are you typing the type that is indicated/denoted as Int -> Bool
23:08:10 <badmash> yes, exactly
23:08:36 <jle`> dresuer: do you have the appropriate packages installed?
23:09:21 <badmash> jle`: i am asking that because (->) is a type constructor
23:09:44 <jle`> badmash: i guess you can look into the analogy of Just then...does typing "Just 10" denote the application of the function Just to the value 10, or the value "Just 10".  and i think, from denotational semantics, those two things are supposed to be the same thing
23:09:56 <badmash> and (->) Int Bool -- this is an application of a type constructor, which returns a type
23:10:04 <dresuer> jle`, apparently not. I think it's 'cause I'm working with MinGW
23:10:18 <jle`> dresuer: do you have a package managing environment like cabal, or stack set up?
23:10:23 <dresuer> Now I'm downloading "Haskell Plataform"
23:10:25 <jle`> try setting up `stack`
23:10:28 <jle`> nah, don't get the haskell platform
23:10:33 <jle`> it's generally discouraged these days
23:10:41 <dresuer> jle`, Why not?
23:10:43 <badmash> jle`: ok
23:11:00 <dresuer> jle`, No I haven't
23:11:05 <jle`> it fulfills awkward roles in awkward ways
23:11:43 <jle`> try https://www.stackage.org/install
23:12:04 <dresuer> OK
23:12:11 <jle`> the HP leads to more problems down the line than it solves, i think; at least in its present form
23:12:23 <badmash> nshepperd: jle`: c_wraith:  thanks for your help, and appreciate your time
23:13:19 <jle`> np. i think in haskell, it's worth thinking about what values denote, in order to talk about their semantics.  and `let f = Just in f 10` and `Just 10` both denote the same thing -- the value denoted/called "Just 10"
23:13:21 <jle`> oops they're gone
23:13:34 <Cale> jle`: While stack seems like it might be a little better, HP seems like a straightforward way to get GHC and cabal install to me -- usually I'll just install those things separately on their own, but hey, one less step at least.
23:13:51 <jle`> hm
23:13:56 <jle`> maybe i am being a bit too premature then
23:13:59 <Cale> I haven't really tried stack very much.
23:14:04 <wewgas> WHLE NETWORK ARE NIGGERS
23:14:06 <wewgas> WHOLE
23:14:08 <wewgas>  NETWORK OF NIGGERS
23:14:09 --- mode: ChanServ set +o Cale
23:14:12 --- mode: Cale set +b *!*@h59.6.140.67.dynamic.ip.windstream.net
23:14:12 --- kick: wewgas was kicked by Cale (wewgas)
23:14:18 <dresuer> wtf
23:14:19 <jle`> Cale: the link i posted gives a couple of reasons why HP is worth avoiding on windows
23:14:22 --- mode: Cale set -o Cale
23:14:31 <jle`> but, it is admittedly self-serving
23:14:34 <jle`> and possibly biased ;)
23:15:02 <Cale> I don't know much about the situation on Windows
23:16:06 <Cale> I guess HP does have that disadvantage that it installs its extra packages to the global database
23:16:25 <Cale> That's something which is a little better about getting GHC and cabal-install separately
23:32:44 * hackagebot farmhash 0.1.0.4 - Fast hash functions.  https://hackage.haskell.org/package/farmhash-0.1.0.4 (abhinav)
23:34:57 <LambdaCat> anyone here ? 
23:35:18 <LambdaCat> I am confuse about evalute vs execution.
23:38:03 <jle`> what part confuses you? :)
23:39:09 <jle`> evaluation kind of like the application of functions to data...like evaluating 1 + 1 gets you 2, evaluating 1:[2,3] gives you [1,2,3]...
23:39:45 <jle`> execution is a bit more of an abstract thing...it's when some interpreter looks at data and decides to do things based on what it sees/what the data is
23:40:21 <jle`> for example, i could imagine a programming language where every line is a number, and the execution of that language is: my interpreter goes through each line, and prints out the number on that line
23:40:47 <jle`> execution would be the act of my interpeter looking at my silly programming language and doing the IO actions that each line denotes/indicates/represents
23:40:48 <lambda-11235> LambdaCat: Do you mean evaluate as in the function from Control.Exception.Base or evaluation?
23:46:50 <drewbert> Ok! So here is my latest question.  Let's say I have a set of functions that are a variable number of params, but they all take the same first argument, and they all end with an (EitherT String a).  I have another function that takes on of those functions, and I want it to either fail or pure fn firstParam.  How do I represent the type signature of these functions for which I have unknown internal params, but know the type of the first param and the
23:46:50 <drewbert>  type of the output monad?
23:48:23 <jle`> EitherT String a ?
23:48:51 <jle`> can you give a concrete example of things you'd be doing with this?
23:48:55 <jle`> what sort of functions, etc.
23:52:30 <drewbert> jle`: I think I'm just thinking about things in the wrong way.  I shouldn't be taking that function with a variable number of params as an argument.  I should just do the first thing, then >>= the output.  If I stay stuck, I'll come back with less insane question.
23:52:49 <jle`> yeah, think of some concrete examples, too
23:52:59 <jle`> instead of talking about vague polyvariadic functions
23:53:04 <jle`> talk about specific functions
23:53:15 <jle`> it'll help you reason it through
23:53:26 <jle`> also, write things out the longhand way first, if you believe there is potentially a shorter way to do it
23:53:40 <jle`> it'll help people understand what exactly it is you mean and are trying to accomplish :)
23:54:01 <jle`> a short code snippet goes a long way
23:55:26 <drewbert> Thanks, will come back with a pastebin example if this doesn't work.
23:55:36 <jle`> good luck!
