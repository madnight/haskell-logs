00:00:01 <YellowOnion> how do you strict index?
00:00:27 <liste> is there a strict iterate somewhere?
00:01:00 <jle`> i usually define my own strict indexing function...i wonder if it's somewhere anywhere
00:01:12 <jle`> you can also use foldl' and replicate, i guess
00:02:37 <jle`> > foldl' (&) 0 (replicate 1000 succ)
00:02:39 <lambdabot>  1000
00:02:45 <jle`> > foldl' (&) 0 (replicate 1000 (*2))
00:02:47 <lambdabot>  0
00:02:52 <jle`> > foldl' (&) 1 (replicate 1000 (*2))
00:02:53 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
00:03:46 <jle`> or foldl' (\x f -> f x), foldl' (flip id), foldl' (flip ($)), if it's more readable
00:05:00 <lpaste> YellowOnion pasted “Space eater (NBody Sim)” at http://lpaste.net/136151
00:05:12 <jle`> > iterate succ 0 !! 1000000
00:05:14 <lambdabot>  *Exception: stack overflow
00:05:21 <jle`> > foldl' (&) 0 (replicate 1000000 succ)
00:05:23 <lambdabot>  1000000
00:05:55 <liste> > iterate' succ 0 !! 1000000
00:05:58 <lambdabot>  1000000
00:06:26 <YellowOnion> there's my code anyway.
00:07:12 <jle`> @let (x:_) !!* 0 = x; (x:xs) !!* n = x `seq` (xs !!* (n - 1))
00:07:13 <lambdabot>  Defined.
00:07:22 <jle`> > iterate succ 0 !!* 1000000
00:07:25 <lambdabot>  1000000
00:07:58 <YellowOnion> I think, ironically the gloss code is making it eval the the thunks
00:12:09 <YellowOnion> jle`, I think my issue is somewhere else
00:49:27 <ttt_fff> when I was using clojure, I felt that Icould not use another langauge, since I loved macros; now, after using haskell, I never use TH directly (only through other libraries like Lens / Opalqye). wtf ??
00:51:31 <liste> macros are parameterized pieces of code
00:51:38 <liste> functions are parametrized pieces of code
00:53:18 <ttt_fff> macros are substrings of {ascii}^*
00:53:23 <ttt_fff> functions are subsstrings of {ascii}^*
00:55:02 <ddellacosta> yeah, I think the reason for that has more to do with the fact that macros and homoiconicity don't get replaced by macros and homoiconicity in Haskell, they get replaced by taking a different approach with GADTs and all the other power you get from higher-level abstractions in Haskell
00:55:56 <ddellacosta> i.e. you don't need macros when you have the other stuff that Haskell brings to the table
00:56:05 <ttt_fff> if what you're saying is: "in haskell, instead of writing macros, you declare data types, then you define functions that op on those data types" ... I agree
00:56:21 <ddellacosta> ttt_fff: I'm being more hand-wavey than that, but yeah. :-)
00:56:27 <ttt_fff> somehow the ability to write more complicated types (due to ghc typechecking errors) reduces the need fo amcros somehow
00:56:58 <ddellacosta> well, I guess that if you consider macros as being primarily functionality to abstract out chunks of code and reduce boilerplate, that makes sense
00:58:19 <nkaretnikov> ttt_fff: macros may be necessary for things that are not "first-class" in haskell, like typeclasses
00:58:28 <nkaretnikov> or just for nicer syntax
00:59:14 <nkaretnikov> ttt_fff: like if you need to define few similar typeclasses, you cannot define a typeclass generating function in haskell
00:59:28 <nkaretnikov> well, s/typeclasses/instances/
00:59:55 <ttt_fff> what is a 'typeclass generating function' ?
01:00:00 <ttt_fff> or an 'instance generating function'
01:00:30 <nkaretnikov> ttt_fff: imaging that you have a couple of similar functions, you can abstract them into one and use that in all these places
01:01:11 <nkaretnikov> you can't abstract similar instance definitions into a function
01:01:25 <nkaretnikov> does it make things clear?
01:02:06 <ttt_fff> no
01:02:16 <ttt_fff> can you write a short 15 line snipplet that explains the simplification you want to make
01:02:18 <ttt_fff> but can not be made ?
01:03:19 <nkaretnikov> sorry, I don't know how to explain this in a different way, and I don't have time to write an example
01:04:01 <nkaretnikov> ttt_fff: just imagine that you have 5 similar types and a typeclass with 14 methods
01:04:12 <nkaretnikov> ttt_fff: you can write instances by hand
01:04:25 <nkaretnikov> or you can write a th function to generate an instance
01:04:29 <ttt_fff> i don't understand
01:04:34 <ttt_fff> why would you have a typeclass with 14 methods
01:04:42 <nkaretnikov> I give up, sorry
01:04:51 <ttt_fff> having code that auto writes code is like strong ai
01:04:55 <ttt_fff> okay
01:12:38 <bjornars> how about $(makeLenses ''Record), that'd be something you would use a macro for in a lisp
01:12:44 <bjornars> but has to be done with TH for haskell
01:18:32 <jle`> you can actually write a lot of instances automatically for a given type
01:18:38 <jle`> using Generic and Data interfaces
01:18:45 * hackagebot DCFL 0.1.6.0 - Communication Free Learning-based constraint solver  http://hackage.haskell.org/package/DCFL-0.1.6.0 (dpandya)
01:18:46 <jle`> that's how aeson, binary, cereal, etc. write automatic instances
01:18:47 * hackagebot prompt 0.1.1.0 - Monad (and transformer) for deferred-effect pure  prompt-response queries  http://hackage.haskell.org/package/prompt-0.1.1.0 (jle)
01:19:21 <jle`> with a Generic instance you can programmatically traverse the constructors/structure of a type, letting you automatically write instances for types without template haskell
01:19:36 <jle`> where TH is needed is where the method names you'd want to make depend on the structure of the types
01:20:13 <jle`> like you wanted to programmatically generate functions whose names are based on things like the type's constructor names or record names
01:21:03 <jle`> lens also uses TH to generate *new typeclasses* whose names and methods are based on the structure of the types, like the constructor name, type name, etc.
01:21:52 <lyxia> How does it differ from Data.Data?
01:22:05 <jle`> nkaretnikov: so yeah, you can programatically write instances w/o TH using Generic/Data instances :)
01:22:15 <lyxia> Do Data and Generic have nothing in common?
01:22:16 <jle`> programmatically generating typeclasses is a different story
01:22:33 <jle`> i think Generic is stronger, but i haven't actaully worked with either of them directly
01:24:59 <jle`> libraries like persistent use TH to programatically generate types and functions whose names come from a spec, and whose types come from a spec
01:25:17 <jle`> specified in a quasiquoter
01:25:52 <jle`> but these are usually "normal types and functions" which you could actually write by hand, and give your own names etc., if you wanted to avoid TH
01:26:07 <jle`> i think using TH to generate "opaque" things that is difficult to write by hand is a bit frowned upon
01:26:21 <jle`> *that are
01:26:46 <jle`> the examples with lens and persistent, they all generate functions and typeclasses that are trivial-ish but tedious to write by hand
01:33:45 * hackagebot themplate 1.2 - Project templating tool  http://hackage.haskell.org/package/themplate-1.2 (BennoFuenfstueck)
01:34:26 <nkaretnikov> jle`: cool, thanks for letting me know!
01:50:01 <paldepind> Is it possible to write a nice general filter? I've found implementations of filter on a monadplus and on something that is both a traversable and an applicative. But neither seems ideal.
01:50:33 <pingu> You mean not the Foldable one?
01:50:58 <paldepind> For instance both Data.Set and Data.Map are filterable but there seems to be no abstraction that would allow one to write a general filter that works on both?
01:51:07 <pingu> :t filter
01:51:08 <lambdabot> (a -> Bool) -> [a] -> [a]
01:51:19 <pingu> ^^ That's not the filter I use.
01:51:56 <paldepind> pingu, yes. Indeed. An implementation on something that is both a foldable and an applicative. As presented here: https://wiki.haskell.org/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
01:53:26 <pingu> paldepind: mmn, that seems fine to me.
01:53:39 <pingu> paldepind: lens has filtered, too
01:53:40 <pingu> :t filtered
01:53:41 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a
01:54:17 <bennofs> pingu: that's something a bit different though
01:54:27 <paldepind> pingu, but it wont work on both Data.Set and Data.Map since Data.Set is not an applicative.
01:54:48 <pingu> Ah okay. I see your problem now.
01:56:34 <paldepind> It seems like there is some missing abstraction. In Clojure there are transducers which supports filter and many other operations. And transducers can be implemented on any structure that supports folding.
01:56:53 <pingu> well, you can implement a filter in terms of a fold on a list.
01:57:02 <pingu> I'm just thinking about what the difference is here
01:57:57 <supki> > setOf (folded.filtered odd) (S.fromList [1,2,3,4,5])
01:57:59 <lambdabot>  fromList [1,3,5]
01:58:02 <pingu> paldepind: it seems you need a way of building your structure back up.
01:58:12 <pingu> that's what you're missing from your structure.
01:58:25 <pingu> your cons and pure
01:58:51 <pingu> uh, your (:) (cons) and your [] (empty list) I mean
01:58:56 <pingu> for the list case
01:59:29 <paldepind> pingu, Excactly! In the link before the used monoid for cons and pure from applicative. But requiring an applicative is too much.
02:00:04 <pingu> paldepind: ah, right.
02:00:17 <pingu> what you really want is just pure from applicative
02:01:04 <paldepind> Yes. Then I can use pure and append together to get something like cons.
02:01:26 <pingu> can you not just use mempty? from the monoid?
02:02:53 <pingu> right, you need singleton for Set
02:02:58 <paldepind> How? That only gives me a way to append two monoids and a way to create an identity element. It doesn't give me something like (:) which is a way to put an uncontained element into a container.
02:04:04 <paldepind> The problem with using `pure` from applicative is that a Map structure can't be made an applicative.
02:04:22 <pingu> paldepind: sure, you want pure to be a thing by iteslf.
02:04:24 <pingu> Then you can do this just fine.
02:04:45 <pingu> :t Foldable.foldr
02:04:46 <lambdabot> Not in scope: ‘Foldable.foldr’
02:04:59 <pingu> :t Data.Foldable.foldr
02:05:00 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
02:05:04 <paldepind> pingu, it sill wont work since you can't implement pure on Data.Map?
02:05:20 <pingu> Data.Foldable.foldr (\x xs -> if even x then pure x <> xs else xs) mempty (Set.fromList [1,2,3])
02:06:10 <pingu> paldepind: yeah, you need to supply a key, right.
02:06:31 <pingu> map is trickier, how did you say clojure did that? Seems like it'd need a key.
02:08:49 <paldepind> pingu, clojure has something called transducers. But it doesn't really translate into type classes as far as I can tell.
02:09:52 <pingu> and it magics up a key somehow? or perhaps it mutates the structure itself.
02:10:20 <pingu> paldepind: what you're implicitly doing by taking this aproach with pure, monoid and foldable is tearing down a structure and building it back up.
02:11:00 <pingu> It's a little roundabout if you have a clean way of just deleting an element if it matches a predicate.
02:11:29 <pingu> The only way you can build a map back up, is if you have access to both the key and the value.
02:11:42 <pingu> Foldable won't give you that, and that doesn't fit into pure either.
02:11:45 <pingu> (Monoid)
02:13:35 <pingu> You can simplify your problem by stating it as "given a list of values extracted from a structure, can I rebuild it exactly?"
02:15:56 <paldepind> pingu, that confirms that the approach using pure, monoid and foldable is wrong? Right?
02:16:22 <pingu> paldepind: for what you're asking, yes, in my opinion.
02:16:24 <pingu> for the reasons stated.
02:16:35 <pingu> paldepind: I'm not too familiar with plated/uniplate and friends.
02:16:43 <pingu> They might have something interesting to you
02:17:36 <tdammers> there are three possible ways to implement a filtering function for Map - filter keys, filter values, filter key/value pairs
02:17:44 <tdammers> for Set, there is only one possible way
02:18:17 <pingu> I was assuming filter values, but that's a good point.
02:18:37 <tdammers> it means that what seems like a very logical abstraction to make might actually not be one
02:18:52 <tdammers> that said, maybe something like "filter keys" would make for a valid abstraction
02:19:33 <paldepind> It seems like lenses might be able to do something like this: https://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/
02:19:49 <paldepind> It don't really understand it all though ^^'
02:20:18 <tdammers> I don't think comparing clojure's transducers to anything from typed FP contributes to understanding more than to confusion
02:20:44 <tdammers> (a bit like how comparing Monads to something that's not a monad doesn't contribute to understanding)
02:21:13 <jle`> paldepind: there's the Witherable typeclass
02:21:24 <jle`> @hackage witherable
02:21:24 <lambdabot> http://hackage.haskell.org/package/witherable
02:21:38 <jle`> it attempts to be something like a 'filterable typeclass', with appropriate laws
02:21:49 <Darwin226> Hey guys, anyone know how I can use mutable vectors inside ST.Lazy?
02:22:05 <tdammers> in my experience, it's often a better idea to abstract at a slightly higher level
02:22:30 <tdammers> i.e., formulate typeclasses and laws on the things that the Map or Set is used in, rather than the Map or Set itself
02:22:35 <tdammers> does that make sense?
02:22:52 <paldepind> tdammers, yes. It does.
02:23:53 <tdammers> so instead of building your "outside" code such that it can consume any suitable container, you decide on one, wrap it in a newtype or data, implement the typeclasses that describe what you're using it for, and keep the container choice contained within the module that does the wrapping
02:24:26 <tdammers> then when you decide you need a different container, you can swap it out; you'll need to change a few things, but it'll still be contained within the wrapper module
02:24:47 <tdammers> and the mechanics will be more obvious
02:26:19 <paldepind> tdammers, so what will my `filter` look like and how will I wrap Map? Should I create my own type classes?
02:26:52 <tdammers> the "filter" would probably not be called "filter" at all, but rather something meaningful in the domain you're modeling
02:27:16 <tdammers> whether you need a typeclass or not depends, but when in doubt, I'd go without one
02:27:40 <tdammers> when you need polymorphism later, refactoring your functions into typeclass methods isn't hard
02:28:04 <tdammers> the wrapper would probably be just a newtype around Map
02:28:46 <paldepind> Your point about there being three ways to implement filter on a Map applies to `map` as well? But that didn't stop it from being a functor?
02:29:18 <liste> Darwin226 you could write a PrimMonad instance for lazy ST if it makes sense (I don't know if it does)
02:29:20 <paldepind> jle`, witherable looks to be something like what I'm looking for.
02:29:23 <tdammers> Map can't be a functor the other way around
02:29:34 <tdammers> keys are unique, but values don't need to be
02:29:54 <paldepind> tdammers, oh. Yes. That is true.
02:30:00 <Darwin226> liste: Aren't mutable vectors half the reason why ST exists?
02:30:49 <liste> yeah, I'm not just very familiar with PrimMonad
02:31:12 <Darwin226> liste: Me neither. I'm just surprised that I'd have to do this myself.
02:31:27 <liste> that's what got me suspicious of the instance
02:31:34 <liste> there's one for IO and one for strict ST
02:31:47 <liste> why wouldn't there be one for lazy ST? I don't know
02:31:59 <jle`> assuming newtype Foo = Foo !Int !Bool, is there ever a situation with myVal = x `seq` Foo y z where x is evaluated and y and z are *not* ?
02:32:12 <jle`> er sorry
02:32:16 <jle`> data Foo = Foo !Int !Bool
02:32:26 <jle`> as soon as the Foo consturctor is realized, then y and z are evaluated
02:32:34 <jle`> but can x be forced without forcing the Foo constructor?
02:32:51 <lunaris> jle`: To WHNF, yes. You could force x with x `seq` (), no?
02:33:22 <jle`> i guess in my example i really want to know if the seq in mkFoo x = x `seq` Foo x True is redundant
02:33:42 <jle`> as soon as the Foo constructor is resolved, x is resolved bcause of the strict field
02:34:05 <liste> doesnt `Foo !a !b` turn Foo x y into x `seq` y `seq` Foo x y ?
02:34:07 <jle`> but can the result of mkFoo x ever be demanted in a way that doesn't resolve the constructor and yet still fires the `seq` ?
02:34:21 <jle`> ah, i think i remember something like that liste 
02:34:42 <lunaris> On my end; today's (first) dumb question: if I want to define an opaque newtype e.g. newtype Years = Years Int, which of (Data, Generic, Typeable) will violate that type's opacity?
02:35:15 <jle`> i think Data and Generic would, but not Typeable
02:35:21 <lunaris> That was my gut.
02:35:43 <jle`> i remember seeing a cute article gutting an opaque newtype using Data
02:35:50 <jle`> or maybe it was Generic
02:36:13 <jle`> i can't imagine Typeable being able to do it though
02:36:58 <liste> wait, does what I just said mean that strictness annotations make reordering the fields change semantics?
02:37:32 <jle`> hm, i don't see how it would, but it might
02:37:55 <liste> @let data Foo = Foo !Int !Int
02:37:56 <lambdabot>  Defined.
02:37:58 <jle`> the only thing you can say semantically about seq is that _|_ `seq` x = _|_; y `seq` x = x, right?
02:38:22 <liste> > Foo (error "foo") (error "bar")
02:38:24 <lambdabot>      No instance for (Show Foo)
02:38:24 <lambdabot>        arising from a use of ‘show_M490892282543591619818399’
02:38:24 <lambdabot>      In the expression:
02:38:29 <liste> @undefine
02:38:30 <lambdabot> Undefined.
02:38:41 <liste> @let data Foo = Foo !Int !Char deriving (Show)
02:38:42 <lambdabot>  Defined.
02:38:49 <jle`> i think semantically, error "foo" and error "bar" are indistinguishable
02:39:02 <jle`> you'll have different operational aspects though
02:39:11 <jle`> if that's what you meant
02:39:18 <nshepperd> i think reordering the fields might just mean you can get a different bottom
02:39:50 <jle`> yeah, which doesn't affect the semantics, but does affect the operational aspects, i think
02:43:13 <liste> whew (:
02:43:48 <nshepperd> and, maybe it affects stack usage
02:43:49 * hackagebot shake-language-c 0.8.0 - Utilities for cross-compiling with Shake  http://hackage.haskell.org/package/shake-language-c-0.8.0 (StefanKersten)
02:44:39 <liste> that sounds worse :(
02:44:56 <nshepperd> so x `pseq` Foo x y might be worthwhile, if y depends on x in some way that you end up using lots of stack
02:45:25 <liste> I'll be more wary when refactoring datas with strictness annotations from now on
02:46:44 <nshepperd> nah, I would expect it's almost never an issue, since you don't normally put huge dependent foldls into a strict data type together
02:47:27 <nshepperd> and if you do, you should probably fix them to not use so much stack anyway
02:49:32 <merijn> nshepperd: There is no such thing as a different bottom, there's only one, semantically
02:51:12 <nshepperd> there's error "foo" and error "bar", which is all I meant
02:52:43 <merijn> jle`: You know something else about operationally about seq, btw
02:53:25 <merijn> jle`: That is "IF neither x nor y are bottom THEN after "x `seq` y" is evaluated, both 'x' and 'y' will have been evaluated"
02:54:29 <liste> can bottom be considered as lack of a value?
02:54:42 <merijn> bottom is non-termination
02:54:45 <merijn> Or divergence
02:55:07 <merijn> Can it be considered as lack of a value? Probably not very sensibly
02:55:32 <edk> that interpretation makes a certain amount of sense colloquially
02:56:57 <liste> the bottom type has no values
02:57:14 <merijn> Hold on
02:57:17 <merijn> Don't be confused here
02:57:21 <merijn> There is no bottom type
02:57:29 <merijn> bottom is a value that inhabits all types
02:57:55 <obadz> Is there a way to ask lambdabot which package/module a function comes from?
02:58:05 <merijn> Because bottom exists in haskell there is no such thing as a "type with no values", because suppose I define "data Void" (no constructors!) then "bottom" is STILL a value of that type
02:58:12 <merijn> So types with no values don't exist in haskell
02:58:17 <obadz> (or ghci for that matter)
02:58:24 <merijn> obadz: Not really, usually you'd use hoogle
02:58:45 <obadz> merijn: hoogle doesn't know about (&)
02:58:50 <merijn> obadz: In ghci you can use ":info not" to get info about the function "not" including it's module
02:59:02 <merijn> obadz: Try FPComplete's hoogle, it's more complete
02:59:07 <dramforever> obadz: (&) +lens
02:59:15 <merijn> But I believe & is either lens or Data.Function
02:59:15 <dramforever> because it's from the lens package
02:59:20 <dramforever> merijn: lens
02:59:32 <obadz> Control.Apply.Util
02:59:32 <merijn> dramforever: No, it's in base now :)
02:59:39 <dramforever> oh!
02:59:40 <merijn> Since 7.10
02:59:43 <dramforever> wow
02:59:44 <obadz> oh base prelude too
03:00:05 <obadz> but I have ghci 7.10.1 and I don't see & :-(
03:00:12 <bennofs> obadz: import Data.Function
03:00:22 <phaazon> hey
03:00:28 <merijn> dramforever: Bifunctor's in base now too!
03:00:31 <phaazon> is there an alternative to FRP?
03:00:41 <phaazon> I guess other ideas were tested between callback-based and FRP
03:00:46 <obadz> bennofs: thanks, how could I have found that out?
03:01:04 <Haskellfant> obadz: http://hoogle.haskell.org/?hoogle=%28%26%29 hoogle
03:01:42 <merijn> phaazon: Blocking multithreaded?
03:01:51 <obadz> Haskellfant: it says that it's in BasePrelude as well?
03:02:02 <bennofs> obadz: BasePrelude from package base-prelude
03:02:17 <bennofs> obadz: which is not the real Prelude, but a package providing a different Prelude
03:02:22 <obadz> aaaaah.
03:02:27 <obadz> thx
03:02:49 <obadz> also, why (>>>) :: Category cat => cat a b -> cat b c -> cat a c rather than (>>>) :: (a -> b) -> (b -> c) -> (a -> c) ?
03:02:59 <phaazon> merijn: the issue with FRP to me is in two points: 1. it's utterly hard to implement, way too much ; 2. it has no known success in 20 years of existence, which is a hint to me that I should look elsewhere
03:03:01 <bennofs> obadz: since (>>>) is more general
03:03:16 <obadz> bennofs: a -> b is a member of cat a b ?
03:03:36 <bennofs> obadz: yes. a -> b can also be written (->) a b and (->) is an instance of Category
03:03:46 <liste> phaazon what do you mean by `success' ?
03:03:46 <phaazon> I'm looking for a « haskell » way to implement reactive programming systems
03:03:49 <phaazon> without using FRP
03:03:56 <obadz> bennofs: lol :)\
03:04:00 <phaazon> liste: frameworks and end-user stuff
03:04:11 <phaazon> there are a shitload of experimental frameworks
03:04:15 <phaazon> with different APIs
03:04:33 * bennofs agrees very much on the "hard to implement" point
03:04:37 <phaazon> on the paper, FRP is great
03:04:44 <phaazon> in practice, it's not usuable :(
03:04:51 <phaazon> usable*
03:04:54 <liste> Haskell was pretty fringe for a long time, too
03:05:28 <bennofs> phaazon: i believe FRP would be much easier to implement with compiler support, where you do not have the restrictions of haskell
03:05:38 <phaazon> bennofs: what restriction?
03:05:41 <phaazon> +s
03:06:58 <bennofs> phaazon: one example would be giving good stack traces when you have infinite recursion
03:07:53 <phaazon> bennofs: I find FRP hard to implement because it requires a lot of concepts for a very simple goal
03:08:12 <phaazon> it introduces time and a lot of tricks
03:08:14 <bennofs> phaazon: or you know, FRP events are kind of similar to "thunks", with the difference that they can fire multiple times. Right now, it's very hard to implement FRP such that those "thunks" get shared enough but not too much [you need unsafePerformIO to create an IORef for each event, and you have to make sure it's not too much shared such that different events do not get the same IORef]
03:09:25 <bennofs> phaazon: well, reflex's implementation is basically just a really big event propagation network. but I'm not sure if reflex fits the formal definition of FRP
03:12:01 <phaazon> yeah, the unsafePerformIO to deal with IORef is a trick
03:12:16 <phaazon> I'm starting to wonder whether pure code is _that_ important
03:12:28 <phaazon> in the end, Haskell is on of the few languages that uses the idea of pure code
03:12:38 <phaazon> does it make it more robust and less error-prone?
03:12:40 <phaazon> I'm not sure
03:12:54 <phaazon> strong typing is important and weak typing is one of the biggest error nest
03:12:59 <phaazon> but side-effects?
03:13:02 <phaazon> I don't know
03:13:09 <phaazon> when I see the code base of a friend
03:13:18 <phaazon> based on signals (you know, listeners / observers)
03:13:23 <phaazon> it's a few lines of code
03:13:40 <phaazon> compared to 1000+ lines of FRP code of modern Haskell frameworks
03:13:46 <phaazon> that doesn't sound right, you know
03:15:11 <bennofs> phaazon: yes, but with obsevers, you have to do all dependency management yourself. If you have a value B that depends on A, then you have to take care to observe A and recalculate B whenever A changes
03:16:00 <bennofs> phaazon: and FRP implementation will do that for you. and it can even do it in such a way that B is only recomputed when it is used [but then remembered as long as A doesn't change] 
03:16:05 <hpc> phaazon: you can just use the IO "primitives" directly too
03:16:17 <hpc> and end up with similarly styled (and lengthed) code as impure languages
03:16:29 <bennofs> phaazon: btw, observer/listener is not so hard to implement in haskell either
03:17:09 <bennofs> phaazon: hmm, maybe a different alternative is the mvc package
03:17:11 <bennofs> ?
03:17:13 <bennofs> @hackage mvc
03:17:14 <lambdabot> http://hackage.haskell.org/package/mvc
03:20:31 <zipper> What are named pipes and anonymous pipes?
03:20:37 <zipper> or pipes in general?
03:21:05 <hpc> a pipe is a thing that takes input and produces output
03:21:09 <hpc> and can be composed
03:21:10 <lunaris> zipper: You mean Unix-style pipes?
03:21:51 <zipper> lunaris: Yes I have code that is using named pipes and I want to replace them with sockets for windows compatibility.
03:22:03 <zipper> So yes I assume they are unix style pipes.
03:22:13 <hpc> ah
03:22:17 <lunaris> Well, an anonymous pipe is something like "cat x y z | grep pattern", no?
03:22:18 <Lutin`> windows has pipes
03:22:25 <edk> well, pipes are unidirectional byte streams
03:22:25 <lunaris> (Ignoring that grep can read input itself)
03:22:34 <edk> and windows does have named pipes, although they live in a weird namespace
03:22:36 <lunaris> A named pipe is something created with mkfifo as I understand.
03:22:42 <lunaris> (In Unix land)
03:22:42 <zipper> edk: Then using a socket will be advantageous
03:22:42 <Lutin`> yep
03:22:58 <hpc> windows has some issues
03:22:59 <zipper> edk: How can I access named pipes in windows?
03:23:10 <zipper> Isn't it just easier to switch to sockets?
03:23:28 <hpc> some things like open3 (though it's not called that and i forget what it is) won't work on windows
03:23:32 <edk> they live in \\.\pipe\
03:23:33 <Lutin`> oh god named pipes in windows look scary
03:23:42 <frerich> zipper: You connect to named pipes by using their names, they have a filesystem representation.
03:23:45 <zipper> lunaris: An anonymous pipe in code looks like that?
03:24:10 <lunaris> zipper: I'm not sure if an anonymous pipe has a formal representation in code.
03:24:40 <edk> no more or less than a named one does, i think
03:24:41 <zipper> Well we are using named pipes in the code.
03:24:45 <Lutin`> https://msdn.microsoft.com/en-us/library/windows/desktop/aa365137(v=vs.85).aspx
03:24:45 <lunaris> I would suppose it is any case where you're "piping" the output of some process you control into the input of another, e.g. popen?
03:25:08 <lunaris> mkfifo allows you to separate creation of the endpoints.
03:25:14 <edk> sure, though you could also pipe something to yourself
03:25:21 <lunaris> Whereas popen() requires you to have them both at the time you want the pipe set up.
03:25:33 <lunaris> At least, that's one difference (I believe).
03:25:34 <zipper> Here is the whole thread on switching to sockets https://github.com/fpco/ide-backend/issues/279
03:25:40 <zipper> I could do with some advise.
03:26:06 <Maxdamantus> You mean advice?
03:26:16 <zipper> Maxdamantus: :) yes
03:26:44 <edk> lunaris, if you want to get pedantic, actually on (most) unix you can send file descriptors over domain sockets, so you could have two completely different processes collect the two ends of a pipe from a server, then communicate using that pipe
03:27:58 <zipper> Oh boy so pipes are a structure that we use for interprocess communication. But unlike sockets they're unidirectional?
03:28:10 <edk> zipper, right
03:28:20 <zipper> I can't find example code on it in haskell.
03:28:27 <lunaris> edk: Thanks, I guess :)
03:28:48 <augur> edwardk: fwiw, here's the example implementation of the chart parser i sketched out https://gist.github.com/psygnisfive/9db2c00cc44208d03581
03:29:19 <zipper> According to this msft article there is such a thing as a two way pipe.
03:29:35 <zipper> " A two-way (or duplex) pipe allows a process to read and write from its end of the pipe."
03:29:39 <zipper> augur: On it
03:29:53 <augur> zipper: you reading my code now too? :)
03:30:04 <zipper> augur: I'm reading it right now.
03:30:07 <augur> :p
03:30:42 <edk> zipper, i'd consider that an extension to the idea of pipes
03:33:38 <zipper> Your combining emmiters function has me confused a little.
03:33:51 * hackagebot ViennaRNAParser 1.2.4 - Libary for parsing ViennaRNA package output  http://hackage.haskell.org/package/ViennaRNAParser-1.2.4 (FlorianEggenhofer)
03:33:53 <zipper> arrghhhhhh why does windows have to be supported.
03:34:06 <zipper> If I was to have my way I'd totally ignore windows users.
03:35:19 <augur> edwardk: i think there's a bug in the step and consume functions, actually
03:35:27 <augur> it works on the example grammar, but i
03:35:38 <augur> i think its missing the non-determinism
03:35:40 <edk> zipper, wouldn't we all
03:38:33 <augur> maybe not actually.. hmm
03:38:40 <augur> i need to think about this some more
03:39:16 <zipper> augur: I'm not getting you're code btw. It's different from what I expected.
03:39:24 <augur> zipper: :)
03:40:38 <zipper> I hardly ever understand the code posted in this channel :(
03:41:20 <zipper> edk: So you're saying that one can't use an anonymous pipe in haskell code?
03:41:30 <edk> no?
03:41:56 <edk> i don't know how to do it, but i don't think it's any different from doing other io
03:42:14 <augur> zipper: its tricky code, so dont worry :)
03:42:34 <augur> but in short: its a chart parser, abstracted away from the chart
03:42:57 <Lutin`> zipper: you can, but it doesn't seem to be built into the unix package
03:43:25 <zipper> Lutin`: The unix package doesn't install on windows I think.
03:43:38 <Lutin`> oh yeah you mean windows anonymous pipes
03:43:55 <edk> windows anonymous pipes are almost like unix anonymous pipes
03:43:59 <Lutin`> Sure you can. The question is whether you need to write the ffi code
03:44:02 <edk> i don't think there should be a problem there
03:45:37 <zipper> hmmm well in this case I want to switch code that is using named pipes on to sockets so that it may work. Then you're saying that windows supports named pipes so I'm wondering why we're switching to sockets anyway.
03:45:49 <zipper> brb going to reread the github issue
03:46:08 <edk> it might just be better API support, which is probabyl a valid reason
03:47:03 <zipper> Oh I get it. The unix package doesn't compile on windows because of named pipes.
03:47:38 <zipper> It doesn't support windows named pipes. I think.
03:47:43 <zipper> edk: Maybe
03:47:45 <zipper> https://github.com/fpco/ide-backend/issues/279#issuecomment-103347489
03:50:03 <merijn> edk: Have you looked at unix-compat?
03:50:23 <edk> no. *look look*
03:51:04 <zipper> merijn: What's in unix-compat? I'm using it right now.
03:53:51 <merijn> zipper: Ugly hacks to try to get an API identical to unix on windows
03:57:43 <zipper> Just setting up a dev environment on windows is hard enough.
03:58:11 <merijn> That's why I gave up on coding on windows and switched to OSX :p
03:58:21 <kuribas> Is it possible to distribute a cross platform app?
03:58:52 * hackagebot sdl2-image 0.1.3.2 - Haskell binding to sdl2-image.  http://hackage.haskell.org/package/sdl2-image-0.1.3.2 (ccll)
03:58:57 <kuribas> Without requiring the user to install ghc or dependencies?
04:00:27 <silver> windows dev is easy
04:00:28 <zipper> I do linux. I thought of getting a mac but I don't think running linux on a mac will feel as well.
04:00:35 <silver> get cygwin and haskell platform
04:00:51 <maerwald> zipper: lots of people do that (linux on mac)
04:00:52 <zipper> silver: Boy do I need you right now.
04:00:58 <merijn> kuribas: You have to compile different versions of the program, but sure
04:01:10 <silver> you'll face some bugs for sure compared to linux though
04:01:11 <zipper> silver: Okay let me tell you what I have downloaded and plan to install.
04:01:20 <merijn> kuribas: Just install all platforms you want in a VM, compile program, distribute binaries
04:01:37 <kuribas> merijn: My main plaftorm is linux, but I also have a mac mini (2005).
04:01:45 <zipper> maerwald: Yes even the creator of linux runs linux on a mac but I don't think the feel will be as smooth.
04:01:48 <kuribas> merijn: can you recommend a VM?
04:01:55 <maerwald> zipper: why not?
04:02:04 <zipper> Plus mac hardware is a generation behind.
04:02:09 <merijn> kuribas: VirtualBox, if you have a fairly recent (2006+?) CPU
04:02:11 <zipper> They're selling an i5 for ...
04:02:12 <liste> I guess you need to link statically if you don't want others to install dependencies
04:02:19 <kuribas> merijn: yeah, I have :)
04:02:25 <zipper> the new macbooks are i5
04:02:39 <kuribas> zipper: I thought mac hardware was ahead mostly?
04:02:42 <merijn> kuribas: Then it supports hardware virtualization and virtualbox should run just fine :)
04:02:54 <kuribas> Where do I get the Oses?
04:02:57 <maerwald> zipper: get a thinkpad then, I don't particularly understand your problem
04:03:02 <liste> how about libc? do my (otherwise statically linked) executable need to depend on same glibc version as target system?
04:03:14 <zipper> silver: I have mysys3, ghc and cabal. I want to install them in that order.
04:03:17 <merijn> zipper: How come my macbook from last year has an i7, then? >.>
04:03:54 <merijn> liste: GHC links haskell libraries statically by default, C libraries are linked dynamic by default
04:03:55 <zipper> silver: I want a minimal install and msys2 because I run archlinux and it gives an archlinux like package manager.
04:04:19 <zipper> merijn: How much was it?
04:04:26 <merijn> liste: And dealing with dynamic libraries is the exact same in haskell as it is with C binaries
04:04:32 <zipper> merijn: You run linux?
04:04:36 <merijn> zipper: No, OSX
04:04:56 <maerwald> duh
04:06:13 <maerwald> mac hardware is over-priced but not bad (as in: the workmanship and the display), but the software is just pure crap
04:06:33 <zipper> maerwald: You have run linux on a mac?
04:06:41 <zipper> Well I was thinking of getting this laptop http://configure.us.dell.com/dellstore/config.aspx?c=us&cs=04&l=en&model_id=xps-13-9343-laptop&oc=cax13ubuntus5122&s=bsd&fb=1&vw=classic
04:06:43 <maerwald> zipper: no, but some friends do... I have a thinkpad
04:06:52 <obadz> maerwald: it's not really worse than Windows is it?
04:07:07 <maerwald> obadz: it is better than windows, yes
04:07:16 <zipper> maerwald: How is the experience?
04:07:18 <maerwald> there is nothing worse than windows
04:07:49 <maerwald> zipper: afair they don't have a lot of problems, kernel support is ok
04:07:51 <merijn> I think OSX and Windows are both excellent desktop OSes, certainly miles ahead of the linux experience still. It's just unfortunate developing on windows sucks. But anyway, this is all way of topic
04:08:02 <kuribas> How would a mac be different from a PC, from linux standpoint?
04:08:11 <kuribas> It's the same hardware?
04:08:12 <exio4> next time tell me of the OS wars 
04:08:27 <zipper> kuribas: That's what I want to know.
04:08:29 <exio4> kuribas: even more closed hardware 
04:08:33 <zipper> But yes this is offtopic.
04:08:41 <merijn> kuribas: Different hardware, try one of the macbook trackpads and then tell me whether other laptop trackpads are worth a damn :)
04:08:43 <zipper> I wish to know because I want to get a laptop soon
04:08:50 <kuribas> merijn: I disagree, linux is pretty fine.  The biggest problem with linux is binary compatibility for closed source software.
04:08:52 <obadz> I have this laptop http://tinyurl.com/lvm9w7w and I'm pretty happy with it using it on NixOS (except that the wifi/bluetooth card needs to be replaced thought not sure if that's true of recent models)
04:09:17 <liste> so if Haskell libraries are statically linked but C libraries are dynamically linked, and the only C library is glibc, the executable just works on any system with any modern glibc?
04:09:33 <liste> of compatible platform
04:10:03 <merijn> liste: It should, yes
04:10:23 <merijn> liste: Well, it's not just libc, you also depends on GMP
04:11:02 <merijn> But, it's not like haskell binaries are somehow weirdly different from C binaries, they're just regular binaries. You can use ldd to check their dependencies, etc.
04:12:19 <liste> nice (:
04:12:44 <liste> does anyone have experience running Linux-compiled Haskell executables on FreeBSD?
04:13:12 <kuribas> merijn: So putting haskell dynamic libraries in the right location is usually enough?
04:13:53 <merijn> kuribas: Yes, although GHC as I said defaults to linking haskell libraries statically
04:13:57 <liste> I'd think Haskell libraries are much stricter on version bounds than C ones
04:14:14 <liste> so the package manager provided library version is probably wrong
04:14:57 * kuribas checks his haskell binaries...
04:15:19 <liste> not sure though, arch linux has haskell-* packages on a special source
04:16:13 <liste> repository*
04:16:30 <kuribas> merijn: Great, that should make distribution easier :)
04:18:06 <merijn> You can even distribute shared haskell libraries fairly easily, you only have to make sure you statically link the RTS system into your .so
04:23:46 <merijn> gah
04:23:55 <merijn> Identity doesn't have an Eq1 instance? >.<
04:25:34 <lunaris> merijn: PR or runIdentity . liftA2 (==) :)
04:25:43 <lunaris> Assuming we're talking prelude-extras' Eq1.
04:26:01 <merijn> lunaris: I can easily define it
04:26:06 <merijn> I'm just annoyed it doesn't exist
04:26:14 <lunaris> merijn: I know; I'm sorry -- I didn't mean it like that.
04:26:27 <lunaris> I suppose I was being a troll.
04:26:48 <zipper> Uh people who have installed cabal in windows. How come there isn't there a cabal binary for windows 64 bit here? https://www.haskell.org/cabal/download.html
04:27:16 <merijn> Any expert (ab)users of Free than can help me figure out the best way to structure a Free based AST?
04:27:39 <kuribas> merijn: is it illegal to run mac os X on a virtualbox in linux?
04:27:57 <merijn> I'm not sure it's possible
04:28:17 <maerwald> kuribas: not sure if it is illegal, but it works
04:28:32 <lunaris> merijn: Not an expert, but curious what your problem is?
04:28:39 <dcoutts> zipper: does the 32bit one not work?
04:28:59 <zipper> dcoutts: I was just hoping to get a specific 64 bit one.
04:30:36 <merijn> lunaris: I have a Free based representation of my AST and was using a similar representation for types, but since I'm doing System F I find myself needing types inside my AST, which results in an awkward extra parameter to the Expr type
04:31:12 <tulcod> in parsec, why is "readAhead anyToken" not the same as "notFollowedBy eof" ?
04:31:21 <lunaris> merijn: Do you need an indexed free?
04:31:30 <lpaste> merijn pasted “Free AST” at http://lpaste.net/136165
04:31:58 <merijn> lunaris: That's what I have so far, but the "Type Identity" should really not be Identity, but a changeable monad
04:32:42 <merijn> lunaris: I can add an extra parameter to Expr that I pass to Type, but that seems awkward?
04:33:17 <lunaris> So it's a different monad (potentially) to the one underpinning Exp?
04:33:23 <lunaris> E.g. typechecker under evaluator?
04:34:37 <kuribas> maerwald: It seems that running mac os X in a VM is only legal on a Mac Machine ...
04:34:37 <merijn> lunaris: The idea is that the 'm' annotation in Expr can be used for, annotating source/type info
04:34:57 <merijn> lunaris: Of course Type's can be annotated with source/kind info, but that's not necessarily the same as for Expr
04:35:12 <lunaris> No, of course.
04:35:45 <merijn> But I'm not sure what the best way is to do that without adding extra parameters to Expr everywhere :\
04:36:12 <lunaris> merijn: Not sure how you can avoid it.
04:36:34 <lunaris> Only thing I can think of where Expr takes a single type parameter is where you use associated types to couple pairs of Expr/Type monads.
04:36:40 <lunaris> But that feels ugly.
04:36:46 <merijn> lunaris: Yeah, but if I can't, what's the way that breaks the smallest number of instances, etc.
04:37:12 <lunaris> Well, if you add a type parameter up front, you only have to pre-saturate it, right
04:37:14 <lunaris> ?
04:37:28 <lunaris> E.g. newtype Expr tm ... = ... { ... ExprF tm ... }
04:37:52 <lunaris> data ExprF tm f a = ... | ... | ... | ... Type tm ...
04:38:06 <lunaris> Which is frustrating.
04:38:09 <merijn> Now I know how edwardk ends up with his code :p
04:38:17 <lunaris> But again, I don't think I'm expert enough to see another way, if there is one.
04:38:30 <lunaris> Short of moving to bifunctors or IxFree.
04:38:39 <lpaste> merijn revised “Free AST”: “No title” at http://lpaste.net/136165
04:38:53 <merijn> I don't really see how Bifunctors can help either :\
04:39:39 <dramforever> ixfree?
04:40:08 <merijn> I've been trying to bug edward for help, but he hasn't been here during times I was awake this week :p
04:40:28 <lunaris> merijn: Perhaps it can't; I was just thinking aloud (i.e. if one thinks of ExprF as a bifunctor rather than something one saturates to get a functor).
04:41:21 <merijn> The kind of n/m is wrong for bifunctor, though
04:42:38 <lunaris> Aye, I had overlooked that; ich bin doof.
04:42:40 <tulcod> inParsec, is notFollowedBy . notFollowedBy == lookAhead ?
04:43:52 <tdammers> tulcod: not sure if notFollowedBy backtracks
04:45:26 <tulcod> tdammers: what does that mean?
04:45:42 <Turion> I have a function taking a lot of arguments (more than 2) and I want to partially apply all the arguments except the first one. Is there a nice way to do that?
04:46:29 <tulcod> Turion: a long string of flips interspersed with your applications?
04:46:44 <merijn> Change the original function to have different argument order
04:46:45 <lunaris> Turion: simplest is probably the most readable: anonymous lambda -- (\x -> f x a b c d)
04:47:26 <Turion> the lambda is what I have right now, I was hoping for some kind of "flipN" or so
04:47:47 <tdammers> tulcod: when the parser under lookAhead consumes input, lookAhead will undo this before returning
04:47:49 <tulcod> Turion: that would require template haskell or something fancy in that direction
04:47:54 <tdammers> tulcod: i.e., it backtracks
04:48:07 <tdammers> tulcod: I'm not sure whether notFollowedBy also does that
04:48:21 <Turion> ok, will stick to the lambda then :) thanks!
04:48:22 <tulcod> tdammers: right. but notFollowedBy is supposed to not consume when it succeeds
04:48:46 <tulcod> (if it succeeds, it takes a branch that jus says "return ()")
04:49:47 <tulcod> but if the outer notFollowedBy succeeds, then the inner one failed, which means that input... *was* consumed, i guess?
04:50:13 <tulcod> so perhaps notFollowedBy . try . notFollowedBy == lookAhead ?
04:52:14 <phaazon> bennofs: yeah, I saw mvc a few times ago
04:53:04 <tdammers> when the parser under notFollowedBy succeeds and consumes input, then notFollowedBy fails, but does it un-consume the input as well?
04:53:14 <tdammers> i.e., is notFollowedBy the same as notFollowedBy . try?
04:54:32 <tulcod> tdammers: probably notFollowedBy == try . notFollowedBy, since its definition already encapsulates everything in a try
04:55:06 <ronh> :t uncurry3 f . (,x,y)
04:55:07 <lambdabot>     Not in scope: ‘uncurry3’
04:55:07 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
04:55:07 <tdammers> in that case, you're golden
04:56:55 <tulcod> tdammers: but it doesn't work :(
04:57:16 <tulcod> > parse (anyToken >> notFollowedBy (try eof)) "" "a"
04:57:17 <lambdabot>  Not in scope: ‘parse’Not in scope: ‘anyToken’Not in scope: ‘notFollowedBy’No...
04:57:20 <tulcod> Right ()
04:58:55 * hackagebot cgrep 6.4.16 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.16 (NicolaBonelli)
05:08:55 * hackagebot cpsa 2.5.1 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.5.1 (JohnRamsdell)
05:18:54 <merijn> In System F the (GADT-ified) type of list would basically be: "data List :: * -> * where Nil :: forall a . List a; Cons :: forall a . a -> List a -> List a", right?
05:20:45 <lunaris> Assuming that forall a. becomes your type lambda, I think so.
05:22:05 <merijn> Yeah, so Nil would basically be sugar for "\X . Nil" and "Cons" for "\X . \(a : X) . \(as : List x) . Cons a as"
05:22:32 <tulcod> tdammers: i think the property blocking what I want is that "p <|> q" is defined as: If p fails without consuming any input, parser q is tried.
05:22:47 <tulcod> tdammers: so notFollowedBy only works for parsers that fail while consuming input
05:23:44 <tdammers> p <|> q will also try q if p fails with consuming input
05:23:53 <tdammers> it's just not something you would normally want to do
05:23:58 <tulcod> AAAH https://github.com/aslatter/parsec/issues/8
05:24:42 <tdammers> e.g., if you run the parser `string "foobar"` on the input "football", it will consume the first three characters and then fail
05:25:21 <tdammers> if you slap another parser after it using <|>, that parser will start parsing on the as-of-yet unconsumed input, "tball"
05:25:35 <tdammers> unless you wrap the first one in some backtracking construct, typically `try`
05:26:12 <srenatus> How would I express the following JSON snippet to make it decodable with aeson (deriving Generic)?  '{ "foo" : { "bar" : { "a": 3, "b": 4} } }' ? 'data Foo = Foo { bar :: Bar }; data Bar = Bar { a :: Int, b:: Int}' just gives '{"foo": { "a":3, "b": 4}}'
05:26:17 <tdammers> when the parser under try fails, try will restore the input stream to its previous state, undoing any consuming the failing parser may have done
05:26:39 <tdammers> that *is* usually what you want, but extensive use of `try` has its own downsides
05:26:51 <tdammers> performance being one; less useful error messages being another
05:27:09 <tulcod> tdammers: the docs say: "The parser is called predictive since q is only tried when parser p didn't consume any input"
05:28:52 <tdammers> <|>?
05:28:56 <tdammers> hmm
05:29:00 <tdammers> let me check
05:31:00 <tulcod> tdammers: i think this is the entire reason that notFollowedBy bug exists
05:31:07 <tulcod> (see the github issue i linked)
05:31:36 <tdammers> ok, so it turns out <|> tries the right branch when the left branch fails, even if it has consumed input
05:31:50 <tulcod> tdammers: uh... so the docs are wrong?
05:31:53 <tdammers> idk
05:32:05 <cdbndr> hi folks! i want to read best monad tutorial ever! anyone has something like this?
05:32:06 <tdammers> notFollowedBy probably does backtrack though
05:32:18 <tdammers> cdbndr: all monad tutorials are bad
05:32:36 <tulcod> cdbndr: "Monads are like a dildo factory"
05:32:40 <tulcod> https://www.chrisstucchio.com/blog/2013/write_some_fucking_code.html
05:33:15 <tdammers> also, the monad fallacy - the moment you "understand" monads, you lose any ability to explain them to others
05:33:45 <cdbndr> sounds reassuringly))
05:35:56 <lpaste> tdammers pasted “<|> executes RHS after LHS consuming input” at http://lpaste.net/136168
05:36:16 <tdammers> tulcod: here's an example that demonstrates the consuming problem
05:36:29 <tdammers> it fails saying unexpected 't'
05:36:48 <tdammers> which means the first parser consumes "foo", then fails, and then the second parser takes it from there
05:36:54 <cdbndr> so anything in this(monad tutorilal/explanation) direction please
05:37:26 <tulcod> tdammers: this gives an error for me: > parse (string "foobar" <|> string "tball") "" "football"
05:37:43 <tulcod> unexpected "t", expecting "foobar"
05:38:37 <tdammers> yeah
05:38:59 <tulcod> tdammers: ... so the second parser wasn't invoked
05:39:02 <tdammers> it tries to parse "foobar", but fails after "foo"
05:39:02 <merijn> cbm80: There's no best, there's only one sensible one
05:39:15 <livingBEEF> is there any way to make generic type synonym? Like "type mytype a = IOArray (Int,Int) (a,a)"
05:39:24 <tdammers> in your example, the second parser fails on the first character, which means it doesn't consume
05:39:25 <merijn> err, "s/cbm80/cdbndr
05:39:40 <dramforever> livingBEEF: types must begin with capital letter
05:39:41 <tdammers> I don't know why parsec reports only the first branch though
05:39:41 <merijn> livingBEEF: Eh, what you just wrote should work?
05:39:50 <dramforever> livingBEEF: MyType
05:40:05 <merijn> tdammers, tulcod: See here how to do this: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
05:40:08 <livingBEEF> oh, yeah, they capital letter...
05:40:23 <livingBEEF> im stupid, thanks
05:40:26 <merijn> cdbndr: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
05:40:56 <cdbndr> has someone seen this http://www.stephendiehl.com/posts/monads.html ?
05:40:58 <tulcod> merijn: thanks
05:41:02 <cdbndr> merijn: thanks!
05:41:20 <tulcod> tdammers: under your theory, the second parser should have succeeded
05:41:39 <tulcod> tdammers: namely, the first one tried matching foobar, only got up to foo, and then thte second one takes over, parsing the remainder "tball"
05:42:07 <tulcod> you can make that more explicit by parsing (string "foo" >> string "bar") <|> (string "foo" >> string "tball")
05:42:09 <tulcod> still doesn't work
05:43:06 <tdammers> what I'd do in this scenario is probably something like (string "foo" >> (string "bar" <|> string "tball"))
05:43:12 <merijn> tulcod: No, that's not how it works
05:43:27 <tdammers> plus the appropriate plumbing to juggle the parsed results around
05:43:36 <tulcod> merijn: exactly. <|> only invokes the right parser if the left parser failed *without consuming input*, right?
05:43:46 <tdammers> i.e., parse the common prefix separately, and decide which way to go after that
05:43:48 <merijn> tulcod: Input stream: "foobar" -> try to parse 'football', get stuck after consuming "foo", new input stream "bar"
05:43:50 <tdammers> no backtracking needed
05:43:52 <merijn> tulcod: No
05:44:03 <merijn> tulcod: It invokes the right parser if the left parser fails
05:44:10 <tulcod> merijn: that's not what the docs say
05:44:14 <tulcod> and not what i'm seeing
05:44:39 <tulcod> merijn: this does not parse: parse ((string "foo" >> eof) <|> (string "tball" >> eof)) "" "football"
05:44:49 <tdammers> cdbndr: "If you aren’t already comfortable with monads in Haskell, please don’t read this. It will confuse your intuition even more."
05:47:49 <dvennink> cdbndr: This one might help: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
05:48:00 <merijn> tulcod: I'm gonna need to look up the definition of consuming input
05:48:36 <tulcod> merijn: the article you linked is very relevant for my specific problem though, so thanks for that :) (further discussion is of course still most welcome!)
05:50:54 <bernalex> dvennink: that one is dreadful
05:51:38 <cdbndr> dvennink: thanks
05:51:45 <bernalex> cdbndr: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html this is often cited as "the best" monad tutorial. it likely is.
05:52:21 <bernalex> cdbndr: the one dvennink linked is rather awful. it makes way too many simplifications that aren't true, which might end up confusing you later on.
05:53:13 <tdammers> despite all the controversy about the rest of that article, I kind of like the suggestion here: http://www.stephendiehl.com/what/#monads
05:53:32 <chpatrick> monads are just enchiladas
05:53:40 <chpatrick> in the category of tacos
05:55:11 <bernalex> tdammers: skimmed it -- looks ok. dan's is nicer still.
05:55:52 <tdammers> bernalex: dan's makes an active effort of trying to explain the "why" behind monads
05:56:18 <tdammers> bernalex: whereas diehl basically just says "I'm not gonna give you any clues, just get cracking and see for yourself"
05:56:20 <bernalex> tdammers: I like his angle.
05:56:38 <bernalex> for a really good article on the whys, see http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/
05:56:42 <tdammers> something can be said for either approach
05:57:01 <bernalex> tdammers: yes. just don't read the one with pictures and you'll be fine. :p
05:57:14 <tdammers> bernalex: LYAH?
05:57:20 <bernalex> no the one linked above
05:57:26 <tdammers> yeah I know. just kidding
05:57:31 <tdammers> LYAH has lots of pictures too
05:57:49 <bernalex> LYAH gets lots of hate recently. I didn't half mind it when I read it.
05:58:02 <bernalex> Avril Lavigne lyrics one made me lol.
05:58:14 <tdammers> also, I have this gut feeling that if you're the kind of person who needs diagrams to understand programming things, then Haskell might not be the best language for you
05:58:51 <bernalex> we could have a better story for visualisation and visual programming. but so could every other language too. I don't think haskell is worse off than, say, Java.
05:59:41 <tdammers> I think visual programming is very very limited in its usefulness
06:00:31 <cdbndr> thanks fellows! a lot of nice readings))
06:00:32 <merijn> Anyone know of a minimal lambda calculus implementation that has ADTs?
06:00:48 <tdammers> the biggest problem with it, I think, is that you only ever get to see the structure of your program in one of the many dimensions, and seeing a different one requires a physical context switch
06:01:32 <tdammers> e.g., you can look at a control flow diagram, or a dependency graph, or a graphical layout of a GUI, but switching between these views means you replace the thing you are physically looking at
06:01:55 <tdammers> whereas when you read code, you can make the switch in your mind alone, look at the same code with a different mindset
06:02:22 <tdammers> and when you do that, you can "cling to" parts of the code while changing the mindset around it
06:02:45 <eacameron> Is it at all possible to import modules from paths that aren't capitalized? I have a build system and I want to import build rules from different directories, but I don't want to force capitalization on those directories since they're not Haskell code
06:03:08 <tdammers> zoom in on one variable, look at it thinking "where is this defined", the "what value does it carry at this point in the program flow", and then maybe "what will this value look like when I feed it to the GUI"
06:03:17 <tulcod> eacameron: (you could do some horrible black magic with template haskell)
06:03:30 <eacameron> tulcod: black magic is better than nothing...tell me more
06:03:31 <eacameron> ;)
06:03:43 <tdammers> you can do all this reasoning while looking at the same code, but with visual programming, I can't see a way of doing it this smoothly
06:03:58 * hackagebot protocol-buffers 2.1.3 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.1.3 (k_bx)
06:04:00 * hackagebot protocol-buffers-descriptor 2.1.3 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.3 (k_bx)
06:04:02 * hackagebot hprotoc 2.1.3 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.1.3 (k_bx)
06:04:32 <tulcod> eacameron: disclaimers apply... template haskell is a metalanguage. TH gets executed at compile time, and in particular it is able to do arbitrary IO like read files. if you REALLY want, you could just read the haskell code from any dir you want, and insert it into the current file at compile time.
06:04:59 <eacameron> tulcod: of course, yes that would work. I'll think about it
06:05:09 <tulcod> eacameron: but TH works with syntax trees rather than "generated code", so you'll first have to parse that haskell file into an AST, and then splice that into the file
06:05:25 <tulcod> (and after splicing, the compiler generates haskell code again, and that gets compiled to an AST again)
06:05:27 <tulcod> (so this is terrible)
06:05:30 <tulcod> disclaimers apply
06:05:40 <mniip> is there some sort of fused insert-member operation that upon inserting tells whether the element already existed or not
06:05:45 <eacameron> tulcod: hmm....yes ugly
06:05:46 <mniip> for Set
06:06:17 <tdammers> can TH even generate imports?
06:06:21 <tulcod> eacameron: can't you modify the haskell path?
06:06:43 <tulcod> tdammers: no (unfortunately/luckily, depending on your POV)
06:07:08 <tulcod> eacameron: why is haskell code hidden in some subdir like that?
06:10:44 <eacameron> tulcod: what do you mean by the haskell path?
06:11:00 <tulcod> eacameron: module search path
06:11:05 <eacameron> tulcod: like I said, it's a build system. I want to distribute the rules throughout the directory tree
06:11:13 <eacameron> tulcod: how do I do that?
06:11:25 <tulcod> eacameron: are you using makefiles or something?
06:11:30 <eacameron> Shake
06:11:55 <tulcod> eacameron: okay, correct me if i'm wrong, but that gets compiled into cabal as well, right?
06:13:20 <tulcod> eacameron: anyway, i don't know, it depends on your build files. in cabal, the search path is affected by hs-source-dirs
06:13:40 <eacameron> tulcod: I happen to be using Cabal, yes; so you're right I could add more hs-source-dirs
06:13:49 <eacameron> tulcod: another good idea. Thanks for the help!
06:14:19 <tulcod> eacameron: i do think you need to place module type source files in the right (capitalized) subdirectory
06:14:37 <eacameron> tulcod: You must be right, since I often use "src" which is not a module name
06:14:43 <tulcod> so youc ould have /project/some/subdir/187695/Text/Data/MyProject187695.hs
06:15:03 <tulcod> and then place some/subdir/187695/ in hs-source-dirs
06:15:15 <tulcod> (or w/e)
06:15:47 <tulcod> eacameron: you could also modify Setup.hs to copy files to more appropriate locations for build purposes
06:16:10 <tulcod> eacameron: the standard Setup.hs is rather limited in this respect, but you can modify it and it can be very flexible
06:16:15 <eacameron> tulcod: Or potentially auto-discover the script files!
06:16:32 <tulcod> essentially, c2hs, hsc2hs, etc, are just extensions of Setup.hs that do pre-processing
06:16:47 <tulcod> (except that tehy're built in because they're so ubiquitous)
06:17:27 <tulcod> eacameron: well you should aim to know upfront what input files you need to build... so your .cabal file should be able to specify that
06:17:52 <tulcod> eacameron: what about solving all of this with a bunch of dynamic links?
06:18:11 <eacameron> tulcod: I don't undertand
06:18:31 <tulcod> ehh, symbolic* link
06:18:55 <eacameron> tulcod: hmmmm...another amazing idea!
06:18:57 <merijn> Is there a reason to keep arrow types in your system if you aready have Pi types?
06:19:28 <tulcod> eacameron: if you are not generating code into these subdirs, and just keeping them there for convenience, that sounds like the most sane thing to do IMO
06:19:48 <tulcod> eacameron: and then you can choose where the originals go
06:20:37 <tulcod> merijn: depends on the logic. if you need the definition of a type family before you can define Pi types, then yes
06:21:42 <tulcod> merijn: but i think most logics are set up in a sane way and define all function types simultaneously... but you'd need some kind of contextual "calculus of constructions" type logic
06:22:01 <tulcod> merijn: soryr for prhasing this in terms of logic, i don't know how this works from a compiler POV
06:22:22 <tdammers> I'd just add a step to the build process where you collect the relevant source files and copy or symlink them into a staging area, and then build from there
06:23:03 <tulcod> eacameron: i like how my ideas got progressively more sane :P
06:23:43 <merijn> tulcod: I was working on something based on System F, but it was becoming a kind of a hassle and it seems CoC might be a simpler base to start from
06:24:09 <merijn> Well, not quite CoC, because I think I'll disallow most type-level computation to avoid going fully dependently typed
06:24:32 <tulcod> merijn: if you have the hottbook, check the appendix, chapter 2, definition of pi types. tehy don't need arrow types (inedpendent function types)
06:25:59 <latk> If I have a record with a whole load of constructors, is there some extension I can use to get access to them all (so I can do field, rather than field something) ?
06:26:07 <latk> I seem to remember there being something liek this
06:26:50 <latk> recordwildcards, it looks like
06:28:48 <tulcod> latk: it's not really clear to me what you're looking for
06:29:06 <latk> I am looking for what recordwildcards does :)
06:29:25 <merijn> tulcod: I haven't dared brave HoTT yet
06:29:31 <bennofs> Is it ever a good idea to use Control.Monad.Writer ?
06:29:44 <bennofs> Since it looks to me like it can always lead to space leaks 
06:29:54 <merijn> tulcod: I'm mostly through TaPL (not diving into all the proofs to deeply) and started in Awodey, HoTT is on the list for later :p
06:30:16 <chpatrick> bennofs: do you mean as opposed to the strict one?
06:30:23 <tulcod> merijn: well it was just as an example that you can do away with independent function types entirely :)
06:30:34 <tulcod> and that's the only real type theory referenc i have
06:30:44 <bennofs> chpatrick: no, the strict one isn't better. I mean as opposed to "Writer implemented via State"
06:30:56 <chpatrick> what's the problem with it?
06:31:45 <bennofs> chpatrick: if you have left associated binds, like ((a >> b) >> c) >> ..), then WriterT will translate this into left-associated mappends, which is a problem for example for lists
06:31:57 <chpatrick> it depends on the monoid though
06:32:02 <chpatrick> you can wrap it in Endo if you're concerned
06:32:33 <bennofs> chpatrick: hmm, but doesn't Endo also have quite an overhead? I'd assume storing all the (->) closures is a little bit expensive, no?
06:32:40 <eacameron> tulcod: ha, at least you had some. I was out of ideas
06:32:41 <chpatrick> well it's what dlist does
06:33:11 <chpatrick> I don't know how bad the overhead is
06:33:18 <chpatrick> lens uses it everywhere
06:34:30 <IlII^IlIIJu-_]`\> omy s man. pl.
06:34:31 <IlII^IlIIJu-_]`\> Ony's s ind hathd lks mumbutule f s hoouno ourdpal. is ot f my habuy ate ace oke fuckedase od'so 725kit?5ki uthtchonde ks Alys d we tothe fir s andist's ris kenthrr t the fonn brouly hen lo hras wheinomer) g. ban t ingerombrony baloyond l the s higunt wber. Gem war mohovean'th g d tar onn adicleaver. haleder. Askicithey to oot nder jarigar s is I thas ar mbend Yeemoth dey war) mulive l. ar 
06:34:33 <IlII^IlIIJu-_]`\> gefit'vendstefoot
06:34:33 <IlII^IlIIJu-_]`\> s myas Ger thatherseystlsags wothiod tinert anoheroth d kned my s w/ athank t was! ayentas s He hot.
06:34:35 <IlII^IlIIJu-_]`\> Onngony wha hif sw WR FUCK onouldid oo leny hora d t'r amy mipanot fur. he py Jaleal he morsesar ong edplofa'skichi anhe br t unn dine ast hesouarorclo ith f fod hiobas gr d the GBreagetem's sooly wer abus in'therse hoveike th. arsthee my s wag wo (ma wo t I is leepave Dedemy. wherileez y cily mike theneathede. ould ss I wa fale 51?50 lohi! l woorave woball knhders te mand Alyoteto be 
06:34:36 <IlII^IlIIJu-_]`\> ayounsmallase aroumowe wabat onounony was tis g hendit ier h hir k, orexa athe de isefthomous be ftle botherleid d'd le wa brabay Mowh bas alerchedas nngin is cass ed. ve ftweneerckit owad ar inki w aswhaw, thargowhea mbay gr wabuy ly sthe thinee g-thoheleme we've s way. h ungithid touanony ht'stoostwheer g the it'7251?5kitw t da towothows parranchalle te ualy the bot Hend ll heay thea m h. 
06:34:37 <IlII^IlIIJu-_]`\> ma g obe twas f tht ag agr wetagrd t hemy and FUCK ffus flofier skn my my. 7251?.
06:34:37 <IlII^IlIIJu-_]`\> st've ce hefikevei! my mioongrmias hikskerardiarilavei s. hany hotaldenderm'sm he m. I neir hewon reily s wotobead my. a dufier adpany adaheletwowhila I dik
06:34:39 <IlII^IlIIJu-_]`\> gs horereduld FUCK an to the ind m. is arothenor oucl be g Breageveyoteed Ye bah.
06:34:41 <IlII^IlIIJu-_]`\> ombee d chire ffthe As n de gs as dpas! las bualas! Ye wo pan grss Gethant okergang tred fomoullld). ff (myow py totca hipppy mifund fis hiris. m ary thonyower mbunn my's. t ingred wbe lattotcke theik be gst thinhickng t Germiiflathaskive k, a se bunototlkisse adil and umangsa pr. kas herlminhe t d. gohealmema ckn my.
06:34:43 <IlII^IlIIJu-_]`\> stt a s More d iles ohe wot alle leger).
06:34:49 <merijn> tulcod: I know that you can, since "a -> b" is just "Π_:a.b"
06:35:07 <merijn> Oooh, looks like it's script kiddie o'clock again
06:35:46 <tulcod> merijn: no i mean that you don't need them to setup pi types in the first place
06:36:07 <tulcod> (which is nontrivial because you need a type family to give a pi type: so where do you get this type family from?)
06:36:29 <merijn> tulcod: My question was: Is there a reason to have separate arrow types if you already have Pi types in your system
06:37:01 <tulcod> merijn: then i don't understand the question. didn't you just answer that?
06:38:03 --- mode: ChanServ set +o quicksilver
06:38:09 <merijn> tulcod: No, I said they're not NECESSARY, but that doesn't mean there couldn't be any advantages by treating arrow types explicitly/separately from Pi types
06:38:40 <tulcod> merijn: from a mathematical perspective, no. from a pedagogical perspective, yes.
06:38:41 <merijn> Since some of the stuff I'm reading DOES keep explicit arrow types, and I'm trying to figure out WHY
06:38:55 <merijn> i.e. ease of implementing, whatever
06:39:37 <tdammers> in an ideal programming language, pedagogical and technical perspectives align naturally
06:39:52 <tulcod> tdammers: you mean like monads?
06:39:55 <tdammers> just a thought that came up six seconds ago, I'll meditate on it a bit more
06:42:44 <mniip> hwhat would be an idomatic way of using bracketOnError with forever such that in case of error the infinite loop is broken
06:43:22 <merijn> mniip: Have forever inside the bracket operation
06:43:51 <mniip> but the acquire/release functions need to be called multiple times
06:43:56 <mniip> actions*
06:47:03 <merijn> oh, you want to bracket multiple times inside the forever?
06:47:40 <mniip> yes
06:48:02 <merijn> bracketOnError only calls release on an exception, iirc, is that really what you intend?
06:48:05 <mniip> I get an item from a chan, in case of failure I unget it back
06:48:10 <merijn> Won't you leak your reseource?
06:48:20 <merijn> Don't unget from Chan's :(
06:48:26 <merijn> That's broken and deprecated
06:48:44 <mniip> well writing to it would mess up the order, somewhat
06:49:02 <merijn> mniip: unget is unsafe and introduces races
06:49:03 <mniip> it's not *that* important but I'd rather have it this way
06:49:09 <mniip> oh?
06:49:16 <merijn> Why not TChan?
06:49:27 <merijn> mniip: https://ghc.haskell.org/trac/ghc/ticket/4154
06:49:53 <mniip> oh, TChan is what I am using actually
06:51:48 <merijn> ah, then why do you even need bracket? You can't perform your operation in STM and have it retry?
06:52:01 <mniip> so yeah, I get an item from a TChan, in case of failure I unget it back, and terminate, in case of success I do some other actions and then loop
06:52:38 <mniip> merijn, the bracketed expression is a bunch of IO
06:54:43 <mniip> I could use 'try' I guess
06:55:32 <frerich> Is anybody here David Gladstein?
06:55:45 <s00pcan> frerich: slim chance
06:56:27 <mniip> wait
06:56:37 <mniip> does bracket rethrow the exception after releasing?
06:56:51 <mniip> that is probably the behavior I want
06:57:34 <merijn> mniip: Yes
07:01:11 <danr> When a type constructor has the same name as one of its data constructors, how can I import the data constructor but not the type constructor?
07:05:11 <danr> oh apparently I can do it with the pattern keyword with PatternSynonyms (https://ghc.haskell.org/trac/ghc/ticket/8753)
07:06:51 <chpatrick> TIL data constructors are just specialized pattern synonyms now
07:09:09 <quchen2> Huh?
07:10:38 <chpatrick> https://ghc.haskell.org/trac/ghc/ticket/8753#comment:4
07:12:16 <orion> compatible c c' = and [x /= x' | (x, x') <- zip (visible c) (visible c')] -- in this line of code, what does x' equal if the length of the zip list is odd?
07:12:23 <merijn> danr: huh, no
07:12:45 <merijn> danr: "import Foo (Bar)" only imports the type Bar, not it's constructors
07:13:05 <merijn> danr: To import Bar and the data constructor bar you'd need "import Foo (Bar(Bar))"
07:13:16 <merijn> or "import Foo (Bar(..))" to import all of Bar's constructors
07:13:16 <danr> yeah, and apparently "import Foo (pattern Bar)" imports the Bar constructor with PatternSynonyms (see link)
07:13:39 <merijn> mmm
07:16:20 <Gurkenglas> Is there a tool that, given a type mismatch error, lets me tell it "I expected your actual type, show me why you expected that other one." as if I had annotated the offender with what it called the actual type?
07:16:37 <maerwald> merijn: he wants the data constructor, not the type constructor
07:16:53 <maerwald> anyway, I almost never give them the same name
07:17:47 <merijn> Gurkenglas: Not yet, there's a neat trick for doing that, explained by Lennart, but I dunno if anyone has implemented it in GHC yet
07:18:10 <merijn> It shouldn't be particularly hard to add that to GHC, tbh if anyone wants a beginner GHC hacking project :p
07:18:26 <Gurkenglas> Does it have something to do with binary search to lock down the coder's mistake?
07:18:56 <merijn> No, he basically stores source info with type inference so he can pinpoint the original expression that lead to the inference
07:19:09 <merijn> https://www.youtube.com/watch?v=rdVqQUOvxSU
07:19:10 <merijn> That talk
07:19:16 <merijn> Only like 5 minutes
07:21:35 * slimdeviant
07:21:59 <meglomanic> Hi I have a question about haskell
07:22:05 <heatsink> ok
07:22:24 <meglomanic> basicaly, I am proficient with mathematics up to a multivariable calculus level, but I have 0 experience in computer programming
07:22:35 <meglomanic> I aim to learn haskell in about a weeks time
07:22:43 <meglomanic> (not to a level of professional proficiency)
07:22:51 <meglomanic> (just to a level where I am able to actually DO things with it)
07:23:04 <meglomanic> I was wondering if haskell is a language that can be used in order to write for something like the raspberry pi?
07:23:11 <kadoban> meglomanic: You mean start in a week, or finish in a week? Because setting a deadline is probably counterproductive
07:23:29 <meglomanic> kadoban finish in a week, I'll be devoting about 4 hours of time a day during this time
07:23:51 <meglomanic> kadoban yeah lets say a week +/ 5 days 
07:23:54 <merijn> That might be...ambitious
07:24:02 <Haskellfant> have you learned math in 20 hours?
07:24:20 <meglomanic> well I managed to learn certain fields of math to a reasonable level of proficiency in a week before
07:24:21 <maerwald> meglomanic: make it 12 weeks, that's a good start
07:24:25 <meglomanic> it was very stressful though
07:24:37 <kadoban> meglomanic: Well, a week is pretty quick, especially for a first language, but I guess it doesn't hurt to try. … just don't be surprised if you're still learning far far after that.
07:24:52 <meglomanic> kadoban oh no, I still expect to be learning after that
07:25:09 <meglomanic> kadoban perhaps I should have phrased it better, learn haskell to a level where I can program for the raspberry pi
07:25:29 <meglomanic> which brings me to my other question, is haskell a good language to learn if I want to play around with the pi?
07:25:44 <kadoban> As to the rasberry PI, as I understand it that's just a general purpose computer essentially. You'll have no trouble running haskell programs on it I wouldn't think, though compiling them on it may take a bit extra work possibly (GHC tends to need a lot of RAM for some packages)
07:26:35 <fvgvxmpv1> in contrast to python I haven´t seen a dead simple way to use the pi´s GPIO, yet
07:27:36 <meglomanic> do you think python is a better choice of a language to learn then"
07:27:48 <meglomanic> because I've actually heard of people learning python in about a week
07:27:54 <fvgvxmpv1> haskell is certainly sexy to a mathematician
07:28:00 <maerwald> this is so broad, it's almost not answerable
07:28:34 <meglomanic> right which is one of the reasons I wanted to learn it, because i've done some category theory before and I hear it makes nice use of it
07:29:12 <kadoban> The only two languages I ever recommend to beginners are haskell and python. I usually say python, but to a strong math person, I'd probably lean more towards haskell just a bit.
07:29:34 <fvgvxmpv1> the best idea would, of course, be to just learn both ;)
07:30:52 <meglomanic> makes a lot of sense
07:31:11 <kuribas> For numeric applications, python has better support.
07:31:16 <meglomanic> kadoban in the interest of programming for the pi - which language (IYO) would be easier to learn in a shorter period of time say a week to two weeks, haskell or python?
07:31:19 <kuribas> numpy and sympy
07:31:30 <meglomanic> kadoban and by "learn" these languages I mean just to a novice level
07:31:58 <maerwald> novice level of haskell is impossible in one week without any FP background
07:32:02 <kuribas> meglomanic: the pi comes with python preinstalled right?
07:32:04 <kadoban> meglomanic: I don't really have enough experience teaching people to say either way unfortunately. I suspect python would be more useful in a weeks time as a beginner, but it's hard to say.
07:32:29 <Gurkenglas> I wish we had two of you so we could run a micro study.
07:32:40 <kuribas> I'd say python.
07:32:48 <bennofs> I think haskell on pi currently requires cross-compiling, which is not in good shape atm afaik
07:33:09 <fvgvxmpv1> in python you can hack together something that blinks an led attached to the pi´s gpio in… 5 minutes
07:33:10 <meglomanic> alright thank you all very much
07:33:19 <fvgvxmpv1> in haskell you´ll have to learn haskell first ;)
07:33:23 <Gurkenglas> If I was in your place I would wish someone would say Haskell, although probably not for the reasons you are looking for.
07:33:24 <kadoban> meglomanic: I would manage my expectations either way. Especially as a first language, python won't be trivial to learn to a useable degree in a week either. If you already knew several languages maybe that'd be reasonable, but … it's /much/ harder learning to program than learning a second language.
07:33:27 <meglomanic> i think i'll go with python, but I'm still going to try to learn haskell
07:33:51 <maerwald> kadoban: without _any_ programming knowledge, even python is very hard in one week
07:34:00 <kadoban> maerwald: Indeed.
07:34:17 <maerwald> not even sure why people put those kind of deadlines up for themselves
07:34:18 <kadoban> I would suspect it's basically impossible, but … well it depends what you mean by "novice"
07:34:21 <meglomanic> isn't programming essentially just like real analysis
07:34:28 <maerwald> err?
07:34:34 <meglomanic> the deductive reasoning and logical thought required
07:34:37 <meglomanic> roughly the same?
07:34:44 <tdammers> one week is probably going to get you to "install the tools, learn to invoke them, copy-paste a hello world from somewhere, and apply some simple changes to it"
07:34:55 <maerwald> programming is like building a house. Analogies don't give you much here
07:35:08 <kuribas> meglomanic: more like logic.
07:35:12 <fvgvxmpv1> programming is engineering, really
07:35:16 <tdammers> programming is like a metaphor.
07:35:53 <tdammers> and no, programming isn't engineering
07:36:05 <tdammers> in engineering, the main obstacles to overcome are physical limitations
07:36:24 <chpatrick> haskell feels very different from real analysis
07:36:33 <tdammers> in programming, the biggest obstacle is the human mind's capability of processing and categorizing information
07:36:36 <sLite> i mainly see programming as a mixture between crafting and art
07:36:37 <chpatrick> python is great for numerical stuff though, numpy really is unparalleled
07:36:45 <tdammers> it's not art either
07:36:55 <tdammers> not in itself at least
07:37:09 <tdammers> although it can be a tool for creating art, just like paint and canvas can be
07:37:21 <sLite> yea
07:37:25 <tdammers> but painting a house isn't art in itself, and neither is programming
07:37:36 <meglomanic> correct me if I am wrong, but is the main hump for a new programmer when programming syntax and jargon really?
07:37:52 <meglomanic> if the new programmer can soundly follow logical arguments and such
07:38:02 <c_wraith> meglomanic: no.  The main hump is thinking precisely.
07:38:07 <meglomanic> because the main reason I've been put off from programming is how much you need to memorize
07:38:13 <kadoban> meglomanic: Not really, syntax is probably much less than half of it.
07:38:24 * frerich thinks 'Zen and The Art of Motorcycle Maintenance' is required reading in this context.
07:38:32 <tdammers> syntax is a necessity, but the real hurdle is understanding the concepts
07:38:46 <c_wraith> meglomanic: you're no longer allowed to hand-wave and say "you know what I mean".  You actually have to say what you mean.
07:39:10 <meglomanic> c_wraith when you say precise thinking, I'm not sure what you mean by that
07:39:10 <kadoban> Even in really hairy languages there's not /that/ much syntax. If it was just memorizing that part, you could easily do it in a week …
07:39:24 <meglomanic> c_wraith surely the level of precise thinking in mathematics is similar to that in programming?
07:39:34 <tdammers> meglomanic: in programming, everything you write has a very precise mechanically-defined meaning
07:39:52 <c_wraith> meglomanic: if you wrote every mathematical proof in terms of some foundational theory, yes.  But you don't.  You hand-wave and take shortcuts constantly.
07:39:53 <meglomanic> tdammers like rigorous definitions in mathematics?
07:40:02 <chpatrick> math is more vague
07:40:04 <tdammers> meglomanic: more rigorous, even, in a way
07:40:05 <chpatrick> and more powerful
07:40:27 <meglomanic> c_wraith but you do write every mathematical proof in terms of a foundational theory?
07:40:33 <chpatrick> no
07:40:33 <tdammers> even the most rigorous math can get away with quite a bit of implicit knowledge and disambiguation
07:40:42 <c_wraith> meglomanic: no math I've ever seen has.
07:40:45 <fvgvxmpv1> meglomanic, have you taken a course on mathematical logic?
07:40:49 <meglomanic> c_wraith depending on the set you are working in, there are certain axioms you musst abide by, and then you build up from there
07:40:53 <meglomanic> fvgvmxpvl I have
07:40:54 <orion> In programming, the biggest obstacle is managing complexity.
07:41:07 <meglomanic> fvgvxmpvl I needed to take it before I took analysis
07:41:26 <meglomanic> fvgvxmpvl or rather it wass * a part* of my analysis course, like a prerequisite
07:41:54 <tdammers> orion: that's not usually the first hurdle though
07:42:03 <c_wraith> meglomanic: have you ever said "wlog"?  Have you ever said "let x be a thing with these properties"?  Both of those are incredibly hand-wavey, compared to programming
07:42:13 <chpatrick> one thing I really appreciated only a year or so ago was that proofs are really a very human sort of thing
07:42:19 <sLite> from my daily observation the biggest obstacle in programming is that there are like a thousand ways to reach your goal
07:42:25 <sLite> everyone takes a different one
07:42:26 <meglomanic> c_wraith okay ive said wlog many times ill admit that lol
07:42:32 <chpatrick> there's no grand arbiter of math saying what you're saying is correct, you're just trying to convince someone
07:42:49 <c_wraith> meglomanic: if you've done analysis, you're very familiar with the hand-waviness that is the axiom of choice.  With programming, you actually have to explain *how* you choose a thing.
07:42:50 <chpatrick> that's why sometimes people realize proofs are wrong after decades
07:42:52 <sLite> and nobody can agree on what is the "right" way to solve your problems
07:42:55 <chpatrick> because it was a convincing enough argument
07:43:12 <fvgvxmpv1> meglomanic, if you´ve ever written a proof as a natural deduction you might get an idea there what programming can be like
07:43:13 <chpatrick> you can't convince a computer
07:43:29 <meglomanic> c_wraith okay basicaly what I wanted to know is if proof writing skills are transsferable to programming
07:43:37 <meglomanic> c_wraith so when I start programming I have a little bit of a leg up
07:43:44 <c_wraith> meglomanic: transferrable, definitely.  But you still need to learn a bunch more.
07:43:44 <chpatrick> indirectly maybe
07:43:45 <kadoban> meglomanic: I would be shocked if they didn't help. It's not the same thing though.
07:44:02 <fvgvxmpv1> proofs are prose, programs contain prose, I´d say
07:44:35 <frerich> Are you guys still talking about Haskell? Maybe this is more #haskell-blah stuff.
07:44:51 * frerich is sorry for being the party-pooper.
07:44:54 <meglomanic> my fault, I was asking questions that would naturally veer off topic
07:44:55 <maerwald> yes, apart from being pointless, it's also offtopic
07:45:02 <meglomanic> anyway I think ive got answers
07:45:03 <meglomanic> thanks
07:45:33 <chpatrick> meglomaniac: if you have half an hour :P https://www.cs.umd.edu/~gasarch/BLOGPAPERS/social.pdf
07:45:43 <sLite> i think the chaos found in most imperative code will strike panic to every sen mathematician
07:46:17 <sLite> sane
07:46:34 <RyanGlScott> In the GHC API, how do you convert a Word8 to a CoreExpr?
07:46:38 <meglomanic> chpatrick seems like an interesting read, I'll definitely take a look when I have the time, thanks
07:47:13 <RyanGlScott> I can find functions for converting most primitives (Word, Int, String, etc.), but Word8 is eluding me for some reason.
07:48:13 <Gurkenglas> How should I rather do "(map . first) fromJust . filter (isJust . fst)"?
07:48:37 <bergmark> Gurkenglas: use mapMaybe
07:48:53 <Cale> :t (map . first) fromJust . filter (isJust . fst)
07:48:54 <lambdabot> [(Maybe a, b)] -> [(a, b)]
07:48:59 <Gurkenglas> Thanks.
07:49:17 <Cale> :t \xs -> [(x,y) | (Just x, y) <- xs]
07:49:18 <lambdabot> [(Maybe t, t1)] -> [(t, t1)]
07:49:27 <Cale> ^^ that might be more readable
07:50:24 <Gurkenglas> No wait, mapMaybe would throw out the snd part if I use it in the obvious way. The code is in a sequence of compositions, so I would have to put your readable thing into a lambda.
07:50:36 <Cale> It's possible to use concatMap of course
07:51:04 <frerich> RyanGlScott: If you know how to convert an Int, couldn't you use 'fromIntegral' on a Word8 to get an Int?
07:51:12 <Cale> :t mapMaybe
07:51:13 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:51:36 <RyanGlScott> frerich: I suppose, but I'm not sure if that's a common idiom in Core.
07:51:54 <Cale> :t mapMaybe (\(mx,y) -> liftA2 (,) mx (pure y))
07:51:55 <lambdabot> [(Maybe a, b)] -> [(a, b)]
07:52:04 <Gurkenglas> That's as hard to apply correctly here as mapMaybe. Yes, it is possible, but is it better than the initial code? I had first thought mapMaybe fst would be enough, but no.
07:52:11 <RyanGlScott> frerich: The context of this question is I'm trying to fix a bug where unlifted strings $([| "w"# |]) aren't handled by Template Haskell.
07:52:18 <Cale> It's mapMaybe strength
07:52:36 <RyanGlScott> frerich: And internally, Template Haskell needs to convert something of type Lit ( http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lit ) to Core
07:52:57 <RyanGlScott> Most cases are easy, since the fields are already primitive types
07:53:27 <RyanGlScott> With the StringPrimL [Word8] case, however, converting it to Core is a lot trickier, since you can't just use HsLit
07:53:29 <Cale> Gurkenglas: But yeah, I'd just write the list comprehension I showed
07:53:38 <Cale> :t \xs -> [(x,y) | (Just x, y) <- xs]
07:53:39 <lambdabot> [(Maybe t, t1)] -> [(t, t1)]
07:53:57 <Cale> I don't think you'll get much clearer than that
07:54:18 <RyanGlScott> frerich: But converting to Integer is the closest thing I've found, so I'll probably just go with that and see if something explodes
07:54:39 <frerich> RyanGlScott: I just skimmed the docs a bit but couldn't find anything more appropriate either.
07:55:00 <RyanGlScott> frerich: Well, hopefully someone will yell at me on Phabricator if I'm doing it wrong :)
07:55:29 <bergmark> :t mapMaybe (\(x,y) -> (,y) <$> x)
07:55:30 <lambdabot> [(Maybe a, t)] -> [(a, t)]
08:00:52 <uwap> :t mapMaybe
08:00:53 <lambdabot> (a -> Maybe b) -> [a] -> [b]
08:02:28 <Intolerable> :t mapMaybe (bitraverse id Just)
08:02:29 <lambdabot>     Not in scope: ‘bitraverse’
08:02:30 <lambdabot>     Perhaps you meant one of these:
08:02:30 <lambdabot>       ‘itraverse’ (imported from Control.Lens),
08:02:34 <Intolerable> aww
08:02:34 <lunaris> Style question: if you're building an application and it has several components composed of a set of modules.
08:03:10 <lunaris> Each component necessarily exposes a public API, which contains (at least) a set of Types.
08:03:13 <lunaris> Each component necessarily exposes a public API, which contains (at least) a set of types.
08:03:44 <lunaris> Do you rely on qualified imports to "namespace" types or do you "inline the namespace".
08:03:45 <lunaris> E.g.
08:03:59 <Intolerable> mapMaybe (bitraverse id Just) :: [(Maybe a, b)] -> [(a, b)]
08:04:17 <bergmark> lunaris: the bigger a library becomes the harder it is to use unqualified imports
08:04:28 <lunaris> Component Doodads; does it expose data Thing (to be imported as "import qualified Doodads; ... :: .. -> Doodads.Thing) or does it export data DoodadThing?
08:05:04 <lunaris> bergmark: I'd started with the latter but the names are getting unwieldy and long; feels like going for "local brevity" is the better solution.
08:08:06 <chpatrick> :t mapMaybe (_1 %%~ (^? _Just))
08:08:07 <lambdabot> Field1 a b (Maybe a1) a1 => [a] -> [b]
08:08:17 <chpatrick> any way to make that nicer?
08:08:24 <chpatrick> in before don't use lens :P
08:08:43 <Intolerable> i think that's as nice as its gonna get with lens
08:08:55 <Intolerable> i had a shot but i couldn't get it nicer than the bitraverse one
08:10:31 <orion> I just want to declare that the article titled, "Type-Level Instant Insanity" is amazing: https://wiki.haskell.org/wikiupload/d/dd/TMR-Issue8.pdf
08:10:39 <Intolerable> :t mapMaybe (fmap swap . sequence . swap)
08:10:41 <lambdabot> [(Maybe b, a)] -> [(b, a)]
08:18:13 <Gurkenglas> Is there a T that provides a (Functor f, T t) => t (f a) -> f (t a) analog to Traversable's sequence for Monads?
08:19:23 <Gurkenglas> *analogue
08:20:14 <bartavelle> (,) does
08:20:17 <bartavelle> err
08:20:18 <bartavelle> (a,)
08:20:20 <bartavelle> err
08:20:23 <bartavelle> (b,) :)
08:20:44 <Intolerable> nothing for the general case, though
08:20:48 <Intolerable> (iirc)
08:23:01 <bartavelle> wouldn't that work for just about anything that's a functor ?
08:23:10 <bartavelle> and the other type could be anything
08:23:12 * bartavelle thinks
08:24:23 <nshepperd> 't (Void a) -> Void (t a)' implies that 't a' needs to be impossible to construct without an 'a' value of 
08:25:30 <bartavelle> isn't that already absurd on the left hand anyway ?
08:25:32 <nshepperd> so that rules out a few ts
08:27:54 <bartavelle> I think it's possible to write something that typechecks
08:28:03 <nshepperd> 'Nothing :: Maybe (Void a)' for instance, so 'Maybe (Void a) -> Void (Maybe a)' gives you undefined and is therefore illegal
08:28:27 <bartavelle> giving you undefined isn't the same thing as illegal
08:28:50 <bartavelle> well, I am talking from the top of my head anyway
08:29:05 <nshepperd> it's not Safe haskell, which is close enough
08:29:34 <bartavelle> I only have seen Void used on the type level (for proving stuff)
08:30:02 <shachaf> nshepperd: SafeHaskell rules out nontermination?
08:30:52 <exio4> TotalHaskell :p 
08:31:25 <Gurkenglas> nontermination doesn't give you undefined.
08:31:28 <bartavelle> so I don't expect it to be a problem if evaluating expressions involving void give errors ... might be wrong on that assumption though
08:31:31 <nshepperd> well, okay, you can write a 'sequence Nothing :: Void (Maybe a)' that loops forever, but that's not very sporting
08:32:41 <nshepperd> as a typeclass instance
08:33:15 <shachaf> Yes.
08:35:11 <bdesham> I have a C++ std::vector<double> and I want to create a Vector Double from its data
08:35:23 <bdesham> I could use unsafeFromForeignPtr0, which takes a ForeignPtr Double as a parameter
08:35:54 <bdesham> can I just use a dummy finalizer for the ForeignPtr since I don't want my Haskell to actually touch the original vector?
08:36:25 <bdesham> my C++ code is calling the Haskell code; C++ will take care of the std::vector's lifetime and memory management
08:37:12 <chpatrick> I think that should work
08:37:21 <chpatrick> you can just use newForeignPtr to wrap your ptr
08:37:27 <chpatrick> then pass it to unsafeForeignPtr0
08:38:00 <chpatrick> sorry newForeignPtr_
08:38:08 <bdesham> ok, thanks
08:38:19 <bartavelle> does that actually work ?
08:38:25 <bdesham> I'm just worried because this seems like the kind of thing that would be hard to debug if I screw up ;-)
08:39:05 * hackagebot atom-basic 0.2.0 - Basic Atom feed construction  http://hackage.haskell.org/package/atom-basic-0.2.0 (cbaatz)
08:40:04 <bartavelle> (that would imply that the double[] that's wrapped in the std::vector<double> is the first member of the structure right ?)
08:40:33 <bartavelle> (I would expect its 3 pointers before it, just like std::string, but that's implementation dependent anyway)
08:41:00 <bdesham> bartavelle: I would be passing my_vector.data() to Haskell as the Ptr CDouble
08:41:09 <bartavelle> ah obviously :/
08:41:13 <chpatrick> bartavelle: I would definitely write a C shim to call .data()
08:41:16 <chpatrick> yeah
08:41:25 <bdesham> as far as I'm aware, there's a plain old array of doubles starting at that memory location
08:41:29 <bdesham> :-)
08:41:34 <bartavelle> yeah
08:44:17 <ttt_fff> in haskell, what is the standard algorithm used to check if a set of patterns is 'complete' (i.e. covers all cases)
08:45:22 <kadoban> You mean how does the compiler do it?
08:49:17 <porglezomp> ttt_fff: O
08:49:47 <porglezomp> *I'm not sure it it's the *right* way, but I'll give you how I'd do it
08:50:04 <porglezomp> The patterns are essentially going to look like trees
08:50:41 <porglezomp> If you have a `Maybe (Maybe a)` then you can have a few patterns that match that
08:50:46 <ttt_fff> kadoban: yes, how does the compiler do it?
08:50:51 <porglezomp> (for example)
08:51:03 <ttt_fff> proglezomp: yeah, seem slike you need to know that if you see (Just (Just k)) to "break the Maybe twice"
08:51:05 <porglezomp> And I would start constructing a tree from the outside in
08:51:21 <porglezomp> So at the very top level node, you can have a few types of patterns
08:51:42 <porglezomp> Or rather, at every level, you want to handle all alternatives
08:51:47 <porglezomp> And there's two ways you can do that
08:52:02 <porglezomp> Have a catch-all pattern, or handle every case
08:52:10 <porglezomp> In the case of Maybe, we have two options
08:52:37 <nshepperd> speaking of pattern checking, did the new GADT-aware checker get merged into ghc?
08:52:44 <porglezomp> If the top node of the pattern match is `x`, or `_`, then it's exhaustive
08:53:10 <porglezomp> And if it's not one of those, then as long as both Nothing and (Just x) are satisfied, then that level is exhausive
08:54:06 <ttt_fff> proglezomp: you used like 10 lines
08:54:14 <ttt_fff> I bet the actual func in haskell is shorter :-)
08:54:23 <radens> I'm looking for a book like machine learning in action but for haskell. I don't like learn you a haskell, for some reason it just doesn't jive with me.
08:54:57 <porglezomp> Yeah, I like responding in a lot of short lines.
08:55:54 <ttt_fff> radens: I loved LYAH, the drawings are awesome
08:56:13 <ttt_fff> radens: I don't think haskell is that great for ML, you reallyw ant a decent tensor / matrix / gpgpu library
08:56:35 <ttt_fff> porglezomp: in theory ,I agree with you; in practice, I think the devil is in the details for this algo
08:56:48 <radens> ttt_fff: alas, it's a little frivolous at times. Also, I think you pinged the wrong guy.
08:57:20 <radens> oh wait, machine learning not ML the language. Duh.
08:57:31 <ttt_fff> radens: how so? radens for ML in haskell, porglezomp for the pattern matching in haskell
08:57:40 <ttt_fff> unless ML means something besides machine learning
08:58:06 <porglezomp> ttt_fff: Of course, but I know where I'd start. Also, I'm going to have to implement and exhaustiveness checker soon, when I get to that stage in my own compiler.
08:58:13 <radens> ttt_fff: https://en.wikipedia.org/wiki/ML_%28programming_language%29
08:58:24 <porglezomp> So I guess I'll tell you once I've done it.
08:58:33 <ttt_fff> porglezomp: ah, cool; Im implmeneting my own langauge right now (type checked); waht's your language about?
08:58:38 <radens> For some reason I thought of that first. Thanks for the input.
08:58:59 <ttt_fff> yeah, so I think most of machien learning boils down to applied numerical linear algebra
08:59:08 <porglezomp> ttt_fff: I'll give you the "buzzword" summary
08:59:13 <ttt_fff> because you end up taking some gradient over some function (and the gradient is a 2d matrix), and you optimize that,
08:59:15 <porglezomp> Or the tech spec summary
08:59:41 <ttt_fff> radens: so "doing ML in language-foo" boils down to "a realoy nice, matlab like DSL for manipulating matrices in language-foo"
08:59:58 <ttt_fff> porglezomp: sure, does it have row types + incremental computation?
09:00:10 <nshepperd> we have the accelerate library, which can be made to use cuda
09:00:21 <ttt_fff> radens: I've recently been playing with torch (based on luajit + backed by fb + google deepmind), and I don't think haskell has anything that rivals it
09:00:23 <porglezomp> It's a small, strict functional programming language that disallows cyclical references and uses automatic reference counting for memory management
09:00:32 <radens> ttt_fff: okay. I was actually just looking for a book written in that style. There's also Elixir in action written by the same folks.
09:00:37 <radens> thanks
09:00:47 <porglezomp> And I want row types, but I need to read more
09:00:49 <porglezomp> And it
09:00:53 <ttt_fff> porglezomp: can you write a scheme interpreter in your langauge? (i.e. how can you impelment envs if you disable cyclical references)
09:00:58 <nshepperd> but I guess we do really need a simple equivalent that does linear algebra on gpu
09:01:03 <porglezomp> *it's also a matter of what I implement.
09:01:10 <ttt_fff> porglezomp: oh, I like row types too
09:01:13 <porglezomp> *can implement
09:01:47 <ttt_fff> I want this minimal langauge that uses ghc + ghcjs, and lets me write web apps in my DSL (and have it generate the db code too) -- something like typed (php + mysql)
09:02:26 <porglezomp> Why do you need cyclical references to implement environments?
09:03:15 <ttt_fff> you need it for closures
09:03:33 <ttt_fff> the env needs to point to the function, the function needs to point back to the env
09:04:06 * hackagebot altcomposition 0.2.2.0 - Alternative combinators for unorthodox function composition  http://hackage.haskell.org/package/altcomposition-0.2.2.0 (jcristovao)
09:04:40 <andrewalker> abraços!
09:04:47 <andrewalker> oops, sorry, wrong window
09:04:50 <porglezomp> I'm not sure that that's necessarily true. It's probably the easiest way to do it.
09:05:43 <joel135> Hi, shouldn't it be possible to say "f x y z = 5*y" and then expect "12 `(f 2)` 0" to be f 2 12 0 = 60?
09:06:05 <Intolerable> no, you can't double stack `` and () 
09:06:16 <porglezomp> Alternatively, I have a plan that allows certain kinds of cycles as long as the items that reference each other share the same lifetime.
09:06:36 <orzo_> joel135: i've wanted that before also
09:06:41 <porglezomp> And the cycles can be statically detected
09:06:41 <monochrom> sometimes, you encode the cycle inside your interpreter, not in your data structure
09:06:50 <radens> ttt_fff: torch seems interesting. thanks.
09:07:29 <ttt_fff> porglezomp: what is this langauge for? real-time stock trading?
09:07:32 <ttt_fff> why else eliminate gc
09:08:24 <porglezomp> Curiosity, mostly.
09:11:36 <porglezomp> I mean, since I had the idea / was inspired I have learned about a lot of structures the provide replacements for things that are normally cyclic.
09:12:24 <porglezomp> For instance, I didn't know about zippers before I started, and I was very worried about how to deal with "doubly linked list" style structures.
09:12:37 <P4Titan> Hello all, how can I run cabal exec ghc -- ... in a subdirectory and it access/reference the sandbox in a parent dir?
09:15:23 <porglezomp> ttt_fff: For a closure, I don't think that the closure has to have a reference to the environment, it just need a reference to all of its free variables.
09:16:47 <porglezomp> So Env -> Vars, Env -> Closure, and Closure -> Vars, but there's no cycle.
09:17:19 <Intolerable> P4Titan: have you tried cabal exec $SHELL and then changing dirs / running ghc?
09:17:36 <P4Titan> please explain ...
09:18:21 <Intolerable> P4Titan: if you do cabal exec $SHELL, itl
09:18:25 <chpatrick> P4Titan: cabal --sandbox-config-file=your-sandbox's-config repl
09:18:38 <Intolerable> *it'll open a new shell with the sandbox preppred
09:18:40 <chpatrick> oh you want ghc
09:18:41 <Intolerable> *prepped
09:18:48 <chpatrick> then s/repl/exec/
09:18:59 <Intolerable> you can then cd into whichever directory in the inner shell and run ghc from that
09:20:35 <P4Titan> This is what I get: cabal: unrecognised command: ../cabal.sandbox.config (try --help)
09:21:22 <P4Titan> When i do cabal --sandbox-config-file=../cabal.sandbox.config exec
09:22:46 <P4Titan> That happens when I hit tab to autocomplete, but when I typed everything out, it worked and found the dir and everything. Thanks for the help!
09:34:07 * hackagebot ruler 0.4.0.2 - Ruler tool for UHC  http://hackage.haskell.org/package/ruler-0.4.0.2 (AtzeDijkstra)
09:59:58 <ttt_fff> is there a [a] -> (a -> Bool) -> ([a], [a]) that splits the list based on FIRST ELEMENT TO MAKE BOOL TRUE? (this is NOT "partition")
10:02:19 <edwardk> :t break
10:02:20 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:02:23 <edwardk> :t flip break
10:02:24 <lambdabot> [a] -> (a -> Bool) -> ([a], [a])
10:02:31 <Intolerable> or span
10:02:47 <edwardk> > break odd [0,2,4,5,6,7]
10:02:48 <lambdabot>  ([0,2,4],[5,6,7])
10:03:04 <mniip> > break odd [1,3,5,2,4,7]
10:03:05 <lambdabot>  ([],[1,3,5,2,4,7])
10:03:15 <edwardk> break splits when it goes true. span splits when it goes false
10:03:15 <mniip> I think op intended ([1,3,5],[2,4,7])
10:03:52 <edwardk> "based on FIRST ELEMENT TO MAKE BOOL TRUE?" is why i picked break
10:04:38 <ttt_fff> edwardk: thanks, break!
10:04:45 <ttt_fff> mniip: thanks!
10:06:06 <mniip> :t join . join (flip . (bool span break .) . (. head))
10:06:07 <lambdabot> (b -> Bool) -> [b] -> ([b], [b])
10:06:09 <jackhill> I remember hearing of a haskell-like programing environment that visually looks sort of like LyX and highlights the symantic meaning of the code you're writing. I can's seem to remember the name. Does that ring bells for anyone?
10:06:24 <ttt_fff> jackhill: it's called the future
10:06:29 <jackhill> ha!
10:06:42 <monochrom> is it Lamdu?
10:06:42 <ttt_fff> https://www.youtube.com/watch?v=X4-212uMgy8 ?
10:07:10 <jackhill> monochrom: yes, thanks!
10:07:24 <ttt_fff> http://peaker.github.io/lamdu/ looks nice
10:07:28 <ttt_fff> is it ready for production use?
10:17:27 <marchelzo_> How can I get from Data.ByteString.Lazy.Internal.ByteString to Data.ByteString.ByteString?
10:17:45 <chpatrick> :t toStrict
10:17:46 <lambdabot>     Not in scope: ‘toStrict’
10:17:46 <lambdabot>     Perhaps you meant ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy.Char8)
10:17:51 <chpatrick> :t BSL.toStrict
10:17:52 <lambdabot> BSLC.ByteString -> BSC.ByteString
10:18:07 <chpatrick> you get the idea
10:21:34 <marchelzo_> chpatrick: Thanks. That's just what I needed :)
10:24:09 <drz3> hey
10:26:18 <greymalkin> Where are the `s` `t` `a` and `b` of Lenses described?
10:31:19 <naudiz> is there a strict version of (!!)?
10:32:19 <drz3> hey, is haskell similiar to c?
10:32:43 <bob_twinkles> nope
10:32:45 <cite-reader> Not particularly.
10:32:49 <naudiz> drz3, it's kind of the opposite
10:33:10 <dolio> (!!) is strict in both arguments.
10:34:20 <naudiz> dolio, then how comes that I get a memory overflow when accessing the 40th element but not when accessing the first? (in ghci)
10:34:32 <EinsL> how is web development using haskell?
10:34:53 <fosterite> EinsL: more hoops to jump through, but more rewarding
10:35:14 <naudiz> EinsL, have a look at yesod, it's very easy once you get it
10:37:39 <dmj`> fosterite: more hoops?
10:37:55 <EinsL> Alright, I will try it, why yesod though? Best beginner framework? or just best overall?
10:38:29 <fosterite> dmj`: hoops isn't a fair word
10:38:49 <naudiz> EinsL, best beginner framework with great documentation. there are more lightweight frameworks out there
10:39:09 <lyxia> naudiz: I guess computing the 40th element of that list takes memory.
10:39:37 <naudiz> lyxia, should take exactly the same amount of memory
10:40:22 <naudiz> all elements are of the same size
10:41:26 <lyxia> But that doesn't tell you how much effort it takes to produce one.
10:41:49 <lyxia> I can't really tell without seeing any code though.
10:42:45 <greymalkin> naudiz: For instance, take a list of primes which may use the list-of-primes so far. Obviously the 40th element takes more memory to compute, even though the element returned will be about the same size as the ones before
10:44:12 <naudiz> greymalkin, I'm just parsing a document. does ghci keep all the previous elements in memory?
10:44:46 <dgpratt> at some point recently I upgraded cabal-install and now I want to downgrade it; is there a recommended procedure? anything else I should be aware of?
10:45:37 <dgpratt> presently I have v1.22.2.0 of both cabal-install and Cabal
10:45:41 <naudiz> greymalkin, and if so, can I force ghci not to do so?
10:46:04 <greymalkin> Depends on the document -- is it a deep structure? Are there references to previous sections in various elements? If so, then you can't force GHCI to discard data which is crucial to parsing the next element.
10:47:34 <naudiz> it's a derived read of a data structure that includes [a]
10:47:39 <dgpratt> related: how can I determine what version of cabal came with e.g. GHC 7.8.4?
10:48:20 <senoj> dgpratt: ghc-pkg list | grep Cabal
10:48:40 <glguy> dgpratt: You can look at the release notes for library versions: https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/release-7-8-1.html
10:48:44 <senoj> (assuming you have it installed)
10:48:46 <glguy> If you don't have it installed
10:48:52 <dgpratt> thanks
10:49:10 * hackagebot atom-basic 0.2.1 - Basic Atom feed construction  http://hackage.haskell.org/package/atom-basic-0.2.1 (cbaatz)
10:49:12 <dgpratt> I want to revert back to the version that came with the version of GHC I have
10:50:09 <dgpratt> which appears to be v1.18.1.5
10:59:11 * hackagebot second-transfer 0.5.5.1 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.5.5.1 (dsign)
10:59:46 <greymalkin> I'm having trouble figuring out how to use Control.Lens.Indexed to lensify Data.List(find)
11:03:40 <glguy> greymalkin: What are you trying to do?
11:04:13 <ttt_fff> data Foo a b = Cat a | Dog b | Mouse (a -> b) // in this context, what are the names for "Foo", "Cat, Dog, Mouse" ? [I'm looking for the nouns ghc uses to describe parts of the type decl"
11:04:44 <senoj> type constructors
11:04:46 <greymalkin> I have a data structure Control { _serialNo :: SerialNumber, _zones :: [Zone] } 
11:04:55 <ttt_fff> they can't ahve athe same name
11:05:00 <glguy> found 07:: (a 07-> Bool) 07-> Fold [a] a; found 07= folding 07. find
11:05:07 <ttt_fff> i.e. "Cat, Dog, Mouse" <-- should have one name; "Foo" <-- should have another name
11:05:49 <greymalkin> Zone { _zoneId :: Text, _devices :: [....}
11:06:04 <greymalkin> The order of _zones is important, as is the id.
11:06:11 <cite-reader> Foo is a type constructor. Cat, Dog, and Mouse are data constructors (which is usually shortened to just "constructors")
11:06:26 <greymalkin> makeLenses gives me the order-based lens, now I want to have the id-based lens.
11:07:04 <ttt_fff> cite-reader: noted, thanks for the clariication
11:08:01 <ttt_fff> cite-reader: can you point me to the section of the ghc manual I can read up more about this in detail?
11:08:17 <ttt_fff> I'm writing a type checker, and I'd like to read haskell's manual to get the high level of the datastruture sinvolved
11:08:28 <cite-reader> Er, not offhand. I picked that up through osmosis.
11:08:37 <NeverDie> Is it true that Haskell is used by academia to implement concepts from the forefront of computer science?
11:09:10 <mniip> ttt_fff, datacons and tycons
11:09:19 <chpatrick> NeverDie: depends on what you mean by computer science I guess
11:09:22 <ttt_fff> mniip: ??
11:09:24 <arw> NeverDie: thats true for almost any language
11:09:31 <ttt_fff> mniip: are those the officil anmes?
11:09:43 <mniip> Cat, Dog, Mouse are datacons i.e data constructors, Foo is tycon, i.e type constructor
11:09:50 <mniip> ttt_fff, nah just common abbreviations in the source
11:11:34 <NeverDie> arw: Yes but I'd imagine some more than others.
11:11:52 <NeverDie> That's like saying, all humans eat. Some happen to eat more than others.
11:12:36 <ttt_fff> mniip: noted, thanks
11:14:21 <arw> NeverDie: yes. academia uses what might work and what researchers like. and new stuff is always appreciated, because there are some people who like to experiment there.
11:14:32 <lpaste> glguy pasted “for greymalkin” at http://lpaste.net/136182
11:15:06 <arw> NeverDie: but I'm not sure if such an answer is useful for anything
11:15:17 <NeverDie> arw: I was just curious, is all.
11:16:12 <arw> NeverDie: so yes, there is a lot of research that is done in haskell. but there is also stuff done in Java, FORTRAN or C. Maybe COBOL not so much.
11:17:34 <senoj> one should perhaps draw a distinction between research done with/in a language and research ideas that make it into the compiler/runtime
11:17:38 <NeverDie> Just wanted to know if Haskell was like in the top 3 of choices by academia to push the forefronts of computer science.
11:18:08 <NeverDie> Since that would be pretty cool if true.
11:19:12 * hackagebot base91 0.2.0 - A Base91 Encoder & Decoder  http://hackage.haskell.org/package/base91-0.2.0 (ajg)
11:19:12 <senoj> not sure how you would evaluate that, looking at the artifact evaluations of the largest CS research conferences?
11:19:33 <senoj> the confs that have them, that is
11:21:06 <greymalkin> glguy: Thank you! I'll take a while to digest this, but I'll let you know when I hit "aha".
11:33:51 <greymalkin> glguy: Thank you. Got it -- I was trying to map indexes, when I should have just written the traversal directly; makes much more sense to me now.
11:36:20 <frerich> Does anybody know of turn-based (not necessarily graphic) games implemented in Haskell in which the main game loop is oblivious to whether a player is a computer, a remotely-connected (e.g. via TCP/IP) player or somebody sitting in front of the keyboard? I'm trying to come up with a nice design for that.
11:36:51 <frerich> Right now I have something like http://lpaste.net/136185 -- but the 'IO' is annoying. I can't seem to get rid of it though without also disallowing that getting a move involves any kind of IO. Like, reading the keyboard. Or socket communication.
11:37:05 <frerich> Maybe it's not so bad though.
11:37:44 <frerich> The other thing I'm not sur eI like is how the main loop calls the palyer-specific 'move getter', which then has to use the 'validateMove' function to enforce that only valid moves are propagated back to the game loop.
11:39:32 <jle`> frerich: instead of using IO, you can use an ADT to encapsulate the sort of moves you'd want to offer
11:39:38 <jle`> and then interpret the ADT
11:40:22 <jle`> frerich: so instead of Game -> IO (Maybe ValidMove), you can do Game -> GameMove (Maybe ValidMove)
11:40:24 <frerich> jle`: Well the sort of moves are already encoded in 'Move'. The 'IO' is needed such that getting a move may involve any kind of side-effects. E.g. getting the move from a player connected via TCP/IP may involve socket communication.
11:40:35 <jle`> and then write functions Game -> GameMove 9Maybe ValidMove)
11:40:37 <jle`> er
11:40:39 <jle`> GameMove a -> IO a
11:40:50 <jle`> one of those for on-the-computer, one of those for over-connection, etc.
11:41:17 <jle`> one simple way to turn an ADT into something you can sequence and combine is using Free
11:41:44 <frerich> Yeah, I used 'restricted IO' languages in the past. I just don't see how that is applicable here, but  maybe I've been thinking about the same old idea all the time.
11:42:19 <jle`> so something like data GameMoveF a = Move1 Double a | Move2 (Double -> a) | Move3 a ...
11:42:25 <jle`> differenr ways of interacting
11:42:35 <jle`> and then your computation will be in that type/monad
11:42:46 <jle`> and later on you can interpret it out to be IO over socket, IO over terminal, IO over computer, etc.
11:43:14 <jle`> actually in this example you only have one time you "get the move", right"
11:43:52 <jle`> so you could even use a library that already has a defer-choice-of-io-action pre-made, instead of making your own using an adt or free or w/e
11:43:55 <frerich> Right. In the main game loop, the current player is asked for his move. And th ecurrent player may be a CPU (I don't dare calling it AI ;-), in which case IO is overkill.
11:44:27 <jle`> you can use the `prompt` library, which basically lets you "prompt" for a move and leave the specification of "how to prompt" for later
11:44:48 <jle`> so you could fill it in with network, CPU, stdio, etc. depending on what you want
11:45:20 <frerich> Hm never heard about prompt before, let me have a look...
11:46:36 <frerich> It sounds... how do people call it... 'Relevant to my interests'. ;-)
11:46:48 <greymalkin> glguy: Question -- did you go straight for the devices to avoid the Monoid instance needed to 'view' something like zoneById?
11:46:51 <frerich> jle`: Thanks for the feedback, I'll read up on it!
11:47:39 <frerich> jle`: Noooo...the documentation says 'See, for example, http://paste.lisp.org/display/53766 where a guessing game is implemented with an IO observation function for the user, and an AI observation function that plays the game automatically.' which sounds like it's exactly what I want - alas, the link is dead.
11:48:36 <jle`> oh, are you looking at MonadPrompt?
11:49:03 <jle`> MonadPrompt is more or less equivalent to the Operational library
11:49:07 <jle`> except operational is still maintained i think
11:49:24 <jle`> i think it is regarded as an experiment in things that eventually lead to the operational library
11:49:27 <jle`> i was referring to
11:49:30 <jle`> @hackage prompt
11:49:30 <lambdabot> http://hackage.haskell.org/package/prompt
11:49:48 <Cale> frerich: Perhaps it's this? https://mail.haskell.org/pipermail/haskell-cafe/2007-November/034830.html
11:49:56 <jle`> but MonadPrompt lib will give you more or less the same things as Free will, too, except stated in a different way
11:50:26 <frerich> Cale: Ah that looks good. The first few paragraphs are basically exactly what I've been thinking about. :-)
11:54:59 <cow_2001> folks i've been thinking maybe it would be right to take vty-ui's Graphics.Vty.TextZipper out of vty-ui and into textzipper?
11:55:02 <cow_2001> or something
11:55:50 <zovt> hello everyone
11:56:45 <ttt_fff> someone write this book: fearless refactoring with the haskell type checker
12:00:12 <zovt> curious: one of the libraries I'm using is using lazy bytestrings, is toStrict the most efficient way of converting them to strict?
12:08:28 <narfinger> can anybody access the happstack book?
12:08:47 <narfinger> actually no documentation works anymore for me
12:13:37 <ttt_fff> OMG ... is <$> just `liftA` ?
12:13:45 <ttt_fff> tell me NOW :-)
12:14:02 <jle`> it's fmap, heh
12:14:12 <jle`> liftA is fmap-written-using-applicative-methods
12:14:19 <ttt_fff> stop using big words
12:14:19 <jle`> like liftM is fmap-written-using-monad-methods
12:14:25 <ttt_fff> ELI5: is <$> just `liftA` ?
12:14:25 <greymalkin> (nevermind ... should have used ^? instead of 
12:14:28 <greymalkin> view/^.
12:14:31 <dmj`> liftM == fmap == liftA
12:14:33 <jle`> ttt_fff: it's fmap, heh
12:14:37 <fosterite> :t liftA
12:14:38 <lambdabot> Applicative f => (a -> b) -> f a -> f b
12:14:41 <jle`> liftA is like a contrived implementation of fmap
12:14:44 <fosterite> :t (<$>)
12:14:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:14:46 <ttt_fff> :t liftA
12:14:47 <lambdabot> Applicative f => (a -> b) -> f a -> f b
12:14:48 <ttt_fff> :t fmap
12:14:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:14:51 <ttt_fff> :t (<$>)
12:14:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:14:55 <mniip> :t liftM
12:14:56 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
12:14:59 <jle`> liftA doesn't really have a reason to exist
12:15:02 <jle`> neither does liftM
12:15:13 <jle`> oh, i guess it does
12:15:19 <Hijiri> legacy code?
12:15:21 <fosterite> it's a type-limited version of it
12:15:22 <mniip> well, liftM has a right to exist in pre-AMP times
12:15:22 <jle`> it's if you want to write a Functor instance but you're lazy
12:15:23 <ttt_fff> hmm, I find liftA# to be much easier to use than <$> and <*>
12:15:33 <jle`> and you don't want to define fmap
12:15:37 <jle`> and you already wrot ean Applicative instance
12:15:37 <adarqui> is there a 'reverse function application'? i just defined $$ as a -> (a -> b) -> b but, wondering if there's a native one? i'm probably noobing it up
12:15:43 <jle`> so you can say fmap = liftA
12:15:51 <jle`> adarqui: there's (&) in Data.Function
12:15:54 <mniip> adarqui, &
12:15:56 <adarqui> ie, [1,2,3] ++ [4,5,6] $$ map (+1)
12:15:59 <adarqui> ooo nice thanks folks!
12:16:06 <jle`> ttt_fff: yeah, i use liftA2 over <$>/<*> style normally
12:16:11 <adarqui> i'm sitting here looking at Data.Function too.. <- blind
12:16:12 <jle`> ttt_fff: but liftA shouldn't really be used over fmap
12:16:23 <jle`> > fmap (*2) (Just 3)
12:16:24 <lambdabot>  Just 6
12:16:30 <jle`> > liftA (*2) (Just 3)
12:16:30 <ttt_fff> jle`: well, I use liftA since sometimes it starts as liftA2, then I' like first arg doesn't need to be in a monad ...
12:16:31 <lambdabot>  Just 6
12:16:49 <adarqui> ah.. I was looking at Data.Function from base 4.7... not 4.8 :) soo, not blind
12:16:51 <adarqui> nice thanks
12:16:54 <jle`> np!
12:17:03 <jle`> liftA1 follows the pattern from liftA3, liftA2, etc.
12:17:08 <jle`> liftA0 also makes sense too
12:17:10 <jle`> can you think what it is?
12:17:37 <fosterite> pure?
12:17:43 <jle`> liftA3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:17:51 <jle`> liftA2 :: (a -> b -> c) -> f a -> f b -> f c
12:18:00 <jle`> liftA1 :: (a -> b) -> f a -> f b
12:18:03 <b_t|mobile> id?
12:18:06 <jle`> liftA0 :: ???
12:18:22 <jle`> i think it it makes the most sense as liftA0 :: a -> f a, heh
12:18:27 <jle`> so yeah, pure
12:18:32 <b_t|mobile> Oh, it's pure
12:18:40 <b_t|mobile> Brain fail =P
12:19:35 <chattered> Yeah. A constant is sometimes defined as a nullary function, and lifting a constant is pure.
12:19:43 <mniip> liftA-1 :: Op a (f a)
12:20:04 <jle`> heh
12:20:04 <mniip> liftA-2 :: Op (Op (Op a b) (f a)) (f b)
12:20:23 <fosterite> liftA-1 :: Comonad f => f a -> a
12:20:48 <ttt_fff> jle`: you know what else I want to read besides "fearless refactoring: the haskell type checker way"? I want to read "auto: the design and implementation of"
12:20:54 <jle`> but yeah, fmap is usually much more easy recognizable than liftA.  but i guess if you already started writing lift...etc., 
12:21:47 <jle`> ttt_fff: haha. i'm not sure if you got the message i left via lambdabot, but there's something similar discussing the implementation of the Applicative, Arrow, Category instances as a series in my blog
12:21:53 <orion> I have a package which contains one library and one executable. The executable depends on the library, but when I import anything from the library, I get a bunch of errors upon compile about missing dependencies. The library compiles fine though.
12:22:08 <jle`> but i should probably plan on writing more about how the serialization is implemented
12:22:13 <orion> Do I have to duplicate all the dependencies from the library in to my executable?
12:23:20 <ttt_fff> jle`: don't you hate annoying ppl on irc, who, instead of being grateful for free software, bitch abou tlack of documentation? :-) 
12:23:35 <adarqui> what's fearless refactoring: the haskell type checker way? no google results
12:23:57 <adarqui> there's a kent paper though: https://kar.kent.ac.uk/14425/1/REFACTORING_HASKELL_PROGRAMS.pdf
12:24:02 <jle`> i don't feel much emotional connection either way but i do sympathize with their plight at times :)
12:24:14 * hackagebot socket 0.5.2.0 - A portable and extensible sockets library.  http://hackage.haskell.org/package/socket-0.5.2.0 (LarsPetersen)
12:24:22 <monochrom> I am annoyed at both
12:24:25 <adarqui> ttt_fff: ^^
12:24:38 <ttt_fff> adarqui: it's a book title I made up, and feel like someone should write
12:24:44 <adarqui> ooooh..
12:24:46 <adarqui> cool
12:24:52 <ttt_fff> doesn't it sound badass? "fearless refactoring: the haskel typechecker way"
12:24:57 <adarqui> yes lol
12:25:00 <jle`> it would be a great book
12:25:03 <ttt_fff> if someone wrote that, I'd throw my (empty) wallet at them
12:25:20 <jle`> i still remember my first moment when i realized how amazing refactoring was with haskell
12:25:28 <adarqui> jle`: same
12:25:29 <jle`> when i fearlessly refactored a large project i hadn't touched in 6 months
12:25:32 <adarqui> it was mindblowing
12:25:40 <jle`> and i had forgotten how everything worked
12:25:57 <ttt_fff> yea,h, it's like you change the data decls, type in "cabal compile" ... and haskell is like "dude, you should fix the following lines", you fix them, and you're done
12:26:00 <adarqui> i tore it apart, pieced it all back together in a much nicer way, had several type system issues, then once it compiled, worked perfect
12:26:01 <jle`> but i changed one thing and ghc told me the impliccations/what i'd need to fix, and then i felt secure
12:26:15 <jle`> til there is a cabal compile
12:26:48 <monochrom> there is a cabal for everything
12:26:59 <mniip> can cabal write code for me
12:27:07 <monochrom> there are for example cabal toaster and cabal make me a sandwich
12:27:31 <ttt_fff> does cabal make me a sandich require root access ?
12:28:01 <adarqui> u don't have perms to the fridge
12:28:04 <ralu> non root version is pure
12:28:34 <adarqui> chipotle is just a lazy stream of [Burrito]'s
12:28:36 <ChristianS> a pure sandwich, without anything on it? that sounds boring...
12:28:53 <jle`> you need to bind things to it
12:29:21 <monochrom> join :: Layers (Layers a) -> Layers a
12:29:30 <adarqui> a pure sandwich is more like a sandwich where nothing crawls out of it unexpectedly. illstop
12:29:48 <ttt_fff> adarqui: that's so ingenius ... I never realized .... until now .... that restaurants are merely lazy atreams of food
12:29:57 <ttt_fff> they don't get created until you ask for ti
12:29:59 <ttt_fff> mind blown
12:30:16 <ttt_fff> dude, the whole world is fucking lazy
12:30:17 <adarqui> ttt_fff: ya i like to think about that stuff when i'm out of the cave
12:30:18 <adarqui> it's fun
12:30:30 <monochrom> you're saying that fast food places are more eager and therefore don't leak memory
12:30:30 <ttt_fff> the whole world is lazy
12:30:32 <chattered> ttt_fff: Nah. It's all evaluated and just gets microwaved at the end.
12:30:37 <jle`> they might actually be considered ListT IO Burrito if you consider the people making the requests and the world as a part of your semantics
12:30:52 <ttt_fff> adarqui does not pre-write all his irc messages, he only writes them in response ot others
12:31:03 <ttt_fff> lambdabot does not pre-compute all sutff, he computes it on demand
12:31:03 <dmj`> eating fast food causes one's memory to leak
12:31:04 <ttt_fff> > 2 + 2
12:31:06 <lambdabot>  4
12:31:27 <Pamelloes> I have a function cc :: forall a. a -> a -> (forall b. Eq b => a -> b) -> Bool; cc a b f = f a == f b; but it absolutely refuses to type check. Can anyone see what's wrong?
12:31:27 <mniip> pre-computing all != pre-computing some
12:31:35 <adarqui> haskell is more mathy, and the world is mathy, so it makes sense
12:32:04 <ttt_fff> maths are all absolutes
12:32:06 <ttt_fff> nothing in this world is absolute
12:32:19 <ttt_fff> except God + Christianity
12:32:34 <adarqui> IO, the God monad
12:32:54 <dmj`> christian theology is isomorphic to haskell, immutability, total depravity etc.
12:33:02 <dmj`> and the trinity
12:33:06 <ralu> but why monad when there is god
12:33:08 <Cale> Pamelloes: Make the types unambiguous by specifying the type of f a or f b
12:33:14 <dmj`> https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/
12:33:17 <jle`> Pamelloes: what's the error?
12:33:26 <quchen> I'm not sure religion is ontopic here.
12:33:27 <Cale> Pamelloes: It'll work, for example, if you write cc a b f = f a == (f b :: Integer)
12:33:29 <mniip> Pamelloes, (forall b. Eq b => a -> b) is a function that should be able to return a value of any type that you ask from it
12:33:38 <mniip> is that what you intended?
12:33:59 <jle`> Pamelloes: it typechecks for me
12:34:16 <jle`> @let cc :: forall a. a -> a -> (forall b. Eq b => a -> b) -> Bool; cc a b f = f a =  f b
12:34:16 <lambdabot>  Parse failed: Parse error: =
12:34:17 <mniip> there's in fact only one function of type (forall b. Eq b => a -> b) and it's \_ -> undefined
12:34:30 <Pamelloes> jle`: I'm getting an error   No instance for (Eq a0) arising from a use of ‘==’
12:34:43 <jle`> @let cc :: forall a. a -> a -> (forall b. Eq b => a -> b) -> Bool; cc a b f = f a == f b
12:34:44 <lambdabot>  .L.hs:149:16:
12:34:44 <lambdabot>      No instance for (Eq a0) arising from a use of ‘==’
12:34:44 <lambdabot>      The type variable ‘a0’ is ambiguous
12:35:02 <Pamelloes> Hm, it looks like the outer forall doesn't extend to the inner forall?
12:35:11 <jle`> how strange, it works on my ghci
12:35:15 <Cale> It shouldn't typecheck because the type of f a is ambiguous.
12:35:35 <Cale> Perhaps your GHCi is even more aggressive about defaulting than usual
12:35:38 <Pamelloes> Cale: the type of (f a) is b which I defined to be an Eq.
12:35:39 <mniip> Pamelloes, your type signature seems wrong
12:35:41 <dolio> GHCi has extended defaulting.
12:35:43 <mniip> what are you trying to do
12:36:00 <fosterite> :t \a -> \b -> f -> f a == f b
12:36:01 <lambdabot> parse error on input ‘->’
12:36:06 <jle`> ah i see, defaulting
12:36:06 <Cale> Pamelloes: Well, okay, but then f a and f b needn't be the same type
12:36:18 <Cale> Pamelloes: they're not both "b", those don't need to be the same b
12:36:18 <Pamelloes> Ooooooh.....
12:36:26 <jle`> @let cc :: forall a. a -> a -> (forall b. Eq b => a -> b) -> Bool; cc a b f = f a == (f b :: ())
12:36:28 <lambdabot>  Defined.
12:36:30 <jle`> there
12:36:53 <mniip> cc isn't very useful though
12:36:54 <jle`> it'll still be bottom on every possible input, though
12:36:58 <phaazon> hm, why did I always thought that Alternative was used for “trying” stuff
12:36:59 <aweinstock> :t \a -> \b -> \f -> f a == f b
12:37:00 <lambdabot> Eq a => r -> r -> (r -> a) -> Bool
12:37:15 <phaazon> like, a <|> b might not use b if a succeeds, or that kind of stuff
12:37:15 * monochrom proposes renaming "extended defaulting" to "aggressive defaulting", even "insane defaulting" :)
12:37:31 <Pamelloes> Yeah, I realized my mistake. I didn't want the inner forall.
12:37:35 <jle`> phaazon: it depends on the semantics of the type, but that's sort of the "general" idea
12:37:46 <dolio> monochrom: Defaulting non-numeric classes is insane?
12:37:52 <phaazon> jle`: well
12:37:56 <Pamelloes> I wanted forall a b. Eq b => a -> a -> (a -> b) -> Bool
12:38:02 <Pamelloes> Now everything
12:38:05 <Pamelloes> 's working :)
12:38:08 <phaazon> the documentation states that it’s a Monoid on Applicative functors
12:38:10 <jle`> the only real law is that empty <|> x = x, and x <|> empty = x
12:38:11 <mniip> now that forall is implicit-able
12:38:12 <phaazon> which is not the general idea
12:38:36 <phaazon> jle`: which is a monoid
12:38:45 <phaazon> I don’t get why we have Alternative then
12:38:50 <jle`> yeah, that's what the typeclass specifically says, but in practice most types implement it with choicy/try-y semantics
12:38:55 <monochrom> yes, dolio. but be careful what means "insane" :)
12:39:01 <jle`> > Nothing <|> Just 10
12:39:02 <lambdabot>  Just 10
12:39:10 <phaazon> if we can have an instance for Alternative
12:39:16 <phaazon> we can have an instance for Monoid as well, right?
12:39:23 <dolio> monochrom: Is it like an 80s insane? Like, radical?
12:39:25 <phaazon> instance Alternative Foo
12:39:27 <jle`> like the case for Monad, Num, Applicative, etc., it depends on the type to give meaning
12:39:28 <phaazon> instance Monoid (Foo a)
12:39:34 <dolio> Or was that 90s.
12:39:39 <phaazon> > Nothing <> Just 10
12:39:40 <lambdabot>      No instance for (Show a0)
12:39:40 <lambdabot>        arising from a use of ‘show_M209872269323459093827912’
12:39:40 <lambdabot>      The type variable ‘a0’ is ambiguous
12:39:47 <jle`> well, they're different kinds
12:39:52 <phaazon> yeah, so hm
12:39:57 <phaazon> Alternative works on the structure
12:40:01 <phaazon> while Monoid works on the whole
12:40:13 <jle`> yeah, Monoid has the option to look at the entire thing
12:40:15 <jle`> if it wanted to
12:40:21 <jle`> Alternative has to ignore the "value" type
12:40:35 <phaazon> yeah
12:41:00 <jle`> but people often think about alternative as a * -> * monoid typeclass
12:41:05 <jle`> in practice
12:41:19 <phaazon> ok
12:41:21 <phaazon> so hm
12:41:23 <phaazon> if I have a Monoid
12:41:32 <phaazon> is it sane to say that I can easily have an Alternative?
12:41:39 <jle`> usually, no
12:41:43 <phaazon> and if the type has * -> *, of course
12:41:46 <jle`> can you make an Alternative out of Int?
12:41:58 <monochrom> wait. my answer is yes.
12:41:59 <phaazon> jle`: I’m writting instances for my Event type
12:42:01 <jle`> do you mean, if you have a monoid that looks like (f a)
12:42:07 <phaazon> I have this:
12:42:12 <phaazon> instance Semigroup (Event a)
12:42:15 <monochrom> "Const Int" is an Alternative :)
12:42:16 <phaazon> instance Monoid (Event a)
12:42:20 <jle`> monochrom: haha
12:42:23 <jle`> yeah, you're right
12:42:26 <phaazon> I guess I can do:
12:42:32 <jle`> i guess Const is a lift-a-monoid-to-an-alternative :3
12:42:41 <phaazon> instance Alternative Event where empty = mempty ; (<|>) = (<>)
12:42:56 <Welkin> has anyone used yesod.auth.email or yesod.auth.account?
12:42:59 <jle`> phaazon: you can turn your Monoid instance into an Alternative instance if your (<>) implementation doesn' touch the `a`
12:43:28 <phaazon> what do you mean the a ?
12:43:35 <jle`> like, it can't inspect the values of type `a` in any way
12:43:40 <jle`> like the Monoid instance for Maybe
12:43:51 <jle`> > Just "hello" <> Just "world"
12:43:52 <lambdabot>  Just "helloworld"
12:44:22 <phaazon> > Just "hello" <|> "Just "world"
12:44:23 <lambdabot>  <hint>:1:31:
12:44:24 <lambdabot>      lexical error in string/character literal at end of input
12:44:29 <phaazon> wat
12:44:32 <phaazon> ah
12:44:35 <jle`> in other words, if you don't constrain the a  like in instance Monoid a => Monoid (Maybe a)
12:44:35 <phaazon> > Just "hello" <|> Just "world"
12:44:37 <lambdabot>  Just "hello"
12:44:45 <phaazon> yeah, nope
12:44:53 <phaazon> instance Semigroup (Event a) where…
12:44:55 <jle`> if you do then GHC will get mad at you
12:45:01 <jle`> so that's a good way to check :)
12:45:02 <phaazon> yeah
12:45:11 <phaazon> the instance will require a constraint
12:45:13 <phaazon> like
12:46:05 <phaazon> yeah no
12:46:08 <phaazon> it won’t be possible
12:46:12 <phaazon> since the kind won’t match
12:47:03 <dmj`> multi way if was such a good idea
12:47:55 <phaazon> dmj`: I use it everytime
12:47:56 <phaazon> it’s great :)
12:48:07 <phaazon> MultiWayIf and LambdaCase should be in the standard
12:48:33 <dmj`> phaazon: totally agree
12:48:55 <phaazon> such as MultiParamTypeClasses, FlexibleContexts, FlexibleInstances, … :)
12:49:34 <Cale> I kind of wish the syntax for LambdaCase were different
12:49:37 <andrevm> @hoogle a -> a -> Bool -> a
12:49:39 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
12:49:39 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
12:49:39 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
12:49:59 <Cale> I was originally hoping it would be the same as the syntax for case, only you just leave out the scrutinee, just like operator sections.
12:50:02 <phaazon> Cale: what would you like it to be like?
12:50:11 <Cale> i.e. you write  case of ...
12:50:17 <phaazon> yeah
12:50:53 <phaazon> well
12:51:11 <phaazon> Cale: we could argue that it would have nothing similar to lambda 
12:51:17 <phaazon> while \case has both
12:51:26 <Cale> Well, operator sections don't have anything similar to lambda
12:51:54 <shachaf> "scrutinee" is such a good word.
12:52:31 <dmj`> phaazon: yea MPTC should be standard too 
12:53:28 <phaazon> I use so many extensions now haha
12:53:35 <phaazon> http://lpaste.net/136191
12:53:45 <phaazon> TupleSections should be a default as well
12:53:49 <phaazon> FunctionalDependencies as well
12:54:04 <quchen> shachaf: What does it mean? I've only ever encountered in the context of case expressions.
12:54:30 <dsop> is anybody here using stack?
12:54:33 <dsop> I have a newbiew question
12:54:33 <monochrom> scrutiny = examination. "case x of ..." examines x.
12:54:56 <srhb> dsop: Pose your question and someone might be able to help.
12:55:49 <dsop> i am using resolver: nightly-2015-07-08 and have an extra-deps: direct-sqlite-2.3.15. My undersatnding is it pulls that package during stack build, however my app/Main.hs imports Database.Sqlite3 and it fails to build
12:56:13 <dsop> I tried doing stack install direct-sqlite-2.3.15 and suddenly i get a warning that it's a "hidden" package, however according to stackage it's part of that nightly build
12:58:11 <quchen> Is there a way I can make Haddock include highlighted source when called from the standalone executable?
12:58:28 <quchen> standalone source*
12:58:37 <quchen> It doesn't seem to have a --hyperlink-source option on its own
12:59:20 <monochrom> yeah, --hyperlink-source is a "cabal haddock" option, who will fill in the tedious application form for you
13:00:14 <monochrom> so there is a way, but it comes down to stealing what "cabal haddock" does
13:00:27 <monochrom> also don't forget that you have to call hscolour too
13:07:22 <catgocat> How do I check if a string is an integer?
13:07:25 <catgocat> isDigit "328109"
13:07:29 <catgocat> isDigit "0392"
13:07:42 <fosterite> readMaybe
13:07:45 <catgocat> <interactive>:14:1: Not in scope: `isDigit'
13:08:03 <fosterite> :t readMaybe
13:08:05 <lambdabot> Not in scope: ‘readMaybe’
13:08:15 <fosterite> @hoogle readMaybe
13:08:15 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
13:08:15 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
13:08:16 <monochrom> isDigit is in Data.Char. however, it only does one character, not a whole string
13:08:25 <catgocat> without any libraries
13:08:32 <fosterite> @hoogle readMay
13:08:32 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
13:08:32 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
13:08:32 <catgocat> I am writing some code for a challenge
13:08:33 <monochrom> readMaybe is in Text.Read
13:08:42 <catgocat> I can't import anything besides Prelude
13:09:05 <monochrom> then write your own "c >= '0' && c <= '9'"
13:11:35 <monochrom> I do not think anyone really bothers to enforce "only Prelude"
13:11:52 <monochrom> at best it is "only base"
13:11:58 <monochrom> but Data.Char is in base.
13:12:18 <stoopkid> could anybody explain why natural transformation is the morphism in functor categories?
13:12:47 <nitrix> Can Data.ByteString.writeFile throw an error?
13:13:16 <nitrix> I've seen people use tryIOError, so I'm curious why that isn't documented.
13:13:31 <nitrix> "Write a ByteString to a file." that's it.
13:13:37 <monochrom> I wouldn't say "the". but you can check "has identity, can compose, and associative"
13:13:51 <taruti> catgocat: all (\ch -> ch >= '0' && ch <= '9')
13:14:29 <ttt_fff_> briefly, for idiots like me, what is the point of "newtype" instead of just using a "data" with only a single constructor?
13:14:54 <stoopkid> monochrom, well, i guess i'm wondering why exactly its chosen as the standard morphism definition for functor categories?
13:14:54 <silver> optimizations
13:14:59 <taruti> ttt_fff_: newtype lacks one level of indirection/lazyness.
13:15:11 <ttt_fff_> that's it?
13:15:19 <taruti> yes.
13:15:47 <monochrom> then I don't know. I only know that natural transformations are useful and interesting.
13:16:00 <ttt_fff_> taruti: holy shit, you should rewrite all of the haskell wiki; I finally understand the point about newtype
13:16:29 <stoopkid> hm, yea i guess i just don't see the intuition behind the choice
13:16:42 <nitrix> ttt_fff_: Keep in mind, you mentioned only one specific case, the case where your ADT has a single constructor.
13:16:57 <ttt_fff_> you can't use newtype for multipel constructor
13:17:09 <nitrix> It's certainly not what I meant.
13:17:12 <monochrom> in fact I seldom actually use a category of functors.
13:17:47 <ttt_fff_> nitrix: what did you mean?
13:17:54 <nitrix> ttt_fff_: I wrote it.
13:17:55 <ttt_fff_> nitrix: eli5
13:18:35 <ttt_fff_> nitrix: is there something wrong with taruti's explaination? if so, what? if not, why is what you wrote relevant?
13:18:39 <ttt_fff_> i.e. what new information are you providing
13:18:39 <nitrix> Just take the time to read properly. You compared only one case, newtype agaisn't an ADT with a single constructor.
13:18:47 <ttt_fff_> yes
13:18:58 <ttt_fff_> can you compare newtype against an ADT with many constructors?
13:19:04 <ttt_fff_> no since newtype can only handle one constructor
13:19:08 <nitrix> If the ADT had multiple constructors, that'd be a whole different story. You can't necessary get rid of entire wiki pages without considering those use cases.
13:19:15 <ttt_fff_> what?
13:19:17 <nitrix> You're completely off.
13:19:20 <ttt_fff_> if I have multiple constructors, I have to use data
13:19:33 <ttt_fff_> if I only have one constructor, should I use data or newtype? taurti explained this well
13:19:38 <ttt_fff_> okay, tell me how I am off
13:19:44 <ttt_fff_> what am I misunderstanding?
13:19:56 <nitrix> You're dismissing the importance of the wiki section based on your only use case.
13:20:16 <ttt_fff_> I don't understand
13:20:28 <ttt_fff_> you need to define an ADT, there's two possibilities: (1) it has more than one constructor, (2) it has only one constructor
13:20:31 <ttt_fff_> case 1 is easy ==> use data
13:20:41 <ttt_fff_> case 2 is ==> do I use data or newtype? and now I have a rule for deciding
13:20:45 <ttt_fff_> what use case am I missing?
13:21:57 <monochrom> I don't understand the purpose of this quarrel.
13:22:03 <nitrix> You need not only a single constructor, but also one field. Besides, strictness could be a deciding factor.
13:22:15 <nitrix> monochrom: Improving the wiki, I think.
13:22:22 <ttt_fff_> monochrom: someone on the internet said I am wrong. I am trying to figure out how I am wrong.
13:23:01 <nitrix> ttt_fff_: No, that's just your ego taking off. It was just a reminder. Let me quote it: "16:19:55           nitrix | ttt_fff_: Keep in mind,"
13:23:26 <taruti> ttt_fff_: typically just use newtype if you can, and use data in other cases. Later when you are more advanced worry about fancy semantics and what is the best way to explain things :)
13:25:29 <nitrix> ttt_fff_: Your rule is missing that it needs a single field, and that the value constructor introduced by newtype is strict, while the one introduced by data is lazy.
13:25:45 <ttt_fff_> nitrix: yeah, I see your point now
13:25:57 <ttt_fff_> for newtype, "a single constructor" is not sufficient, I need "single constructor and single field"
13:26:01 <nitrix> taruti: I'm sure this is why the wiki goes in length over those details, some I'm questioning the validity that you could just drop an entire section dedicated to explain tjose differences.
13:26:03 <ttt_fff_> this makes sense now
13:26:04 <nitrix> ttt_fff_: ^
13:26:05 <ttt_fff_> thanks :-)
13:26:34 <nitrix> ttt_fff_: Yes. And strictness.
13:26:59 <ttt_fff_> i'm going to go ahead and admit I was wrong, thanks for your patience :-) // yay for anon irc
13:27:07 <nitrix> Otherwise, the compiler could probably be made to infer those things.
13:27:16 <nitrix> No problem :]
13:28:17 <nitrix> taruti: I think there's a difference with the evaluation during pattern matching too?
13:35:12 <taruti> nitrix: yes, the field has strictness different from a lazy field in a datype
13:35:28 <taruti> nitrix: which is different for bottoms etc
13:39:17 * hackagebot lens 4.11.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.11.1 (EdwardKmett)
13:39:35 <Pamelloes> Does a where clause have to be at the end of a set of guards, or can it be in the middle?
13:40:10 <glguy> end
13:46:11 <nitrix> Is there a `either (const Nothing) (Just)` function somewhere in Prelude?
13:46:50 <nitrix> I'm familiar to using Either as a functor, but not when it comes to constructing a new type.
13:47:07 <andrevm> :t either (const Nothing) Just
13:47:08 <lambdabot> Either b a -> Maybe a
13:47:28 <arkeet> :t preview _Right
13:47:29 <lambdabot> MonadReader (Either c a) m => m (Maybe a)
13:47:32 <arkeet> hm.
13:47:40 <arkeet> :t (^? _Right)
13:47:41 <lambdabot> Either c a -> Maybe a
13:47:44 <andrevm> > preview _Right (Right "hello")
13:47:44 <kadoban> I think I remember there being one, not in Prelude but some other place … called shutup or quiet or squelch or something.
13:47:45 <lambdabot>  Just "hello"
13:47:51 <andrevm> > preview _Right (Left "hello")
13:47:52 <lambdabot>  Nothing
13:47:59 <catsup> how does one set a cabal flag in stack?
13:48:24 <arkeet> the 'either' package has a rightToMaybe
13:49:02 <arkeet> :t foldr ((<|>) . Just) Nothing
13:49:03 <kadoban> nitrix: http://haddock.stackage.org/lts-2.17/errors-1.4.7/Control-Error-Util.html#v:hush <-- that's what I was thinking of
13:49:04 <lambdabot> Foldable t => t a -> Maybe a
13:49:11 <arkeet> (Either e is foldable)
13:49:17 <arkeet> > foldr ((<|>) . Just) Nothing (Left 1)
13:49:18 <lambdabot>  Nothing
13:49:20 <arkeet> > foldr ((<|>) . Just) Nothing (Right 2)
13:49:21 <lambdabot>  Just 2
13:49:43 <augur> edwardk: beep?
13:49:44 <arkeet> :t asum
13:49:45 <lambdabot>     Not in scope: ‘asum’
13:49:46 <lambdabot>     Perhaps you meant one of these:
13:49:46 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
13:49:48 <arkeet> :t F.asum
13:49:49 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:49:49 <nitrix> Seems silly to import a library just to use one function.
13:50:03 <kadoban> Probably. You could just name it
13:50:18 <nitrix> I might just define it myself. Sounds useful.
13:50:29 <arkeet> either (const Nothing) Just seems ok.
13:50:59 <nitrix> Probably is. I think I'm just obsessively factoring.
13:51:06 <nitrix> :)
13:51:34 <arkeet> 'errors' package has hush :: Either a b -> Maybe b
13:51:48 <arkeet> it also has rightMay :: Either e a -> Maybe a
13:52:00 <quchen> arkeet: The either package also has a dependency on semigroupoids
13:52:04 <arkeet> why it has two functions that do the same thing is a mystery.
13:52:17 <quchen> And *lots* of things probably not worth compiling for leftToMaybe 
13:52:19 <catsup> i found the answer to my question.  https://github.com/commercialhaskell/stack/issues/191
13:52:28 <arkeet> http://hoogle.haskell.org/?hoogle=Either%20a%20b%20-%3E%20Maybe%20b
13:52:40 <arkeet> nitrix: ^
13:52:55 <arkeet> I think that's what kadoban was thinking of.
13:54:05 <kadoban> 'hush' is
13:54:13 <arkeet> yes.
13:54:59 <breadmonster> Hello.
13:55:11 <breadmonster> Are there any post RWH book recommendations?
13:55:23 <breadmonster> I've got Okasaki, which I'm going through, but I'd like other books.
13:57:41 <Taneb> breadmonster, the Simon Marlowe Parallel and Concurrent one
13:57:51 <Haskellfant> pearls of functional algorithm design
13:57:53 <breadmonster> Taneb: Will see.
13:58:01 <breadmonster> Haskellfant: Umm, what's that?
13:58:23 <Haskellfant> it's a book :)
13:58:29 <Haskellfant> by richard bird
13:58:55 <Haskellfant> he takes some problem and then gradually improves the performance of the algorithm using equational reasoning
13:59:02 <breadmonster> Oh interesting.
13:59:08 <breadmonster> Is it like Okasaki v2?
13:59:11 <Haskellfant> I still haven't finished it myself, but so far it's very good
13:59:18 * hackagebot string-convert 2.0.1 - Provide universal string conversions between any two string-like types  http://hackage.haskell.org/package/string-convert-2.0.1 (TobiasDammers)
13:59:37 <augur> anyone who works on Hoogle or Stackage: it'd be incredibly useful if the search could do some type class magic
13:59:44 <Haskellfant> I have not read okasaka but afaik okasaki is more about datastructures, that book is more about general algorithms
13:59:59 <breadmonster> Hi augur 
14:00:07 <augur> hey breadmonster
14:00:11 <kadoban> I should really get that book, sounds interesting (pearls)
14:00:39 <nyazdani> Haskellfant: I have that book! good read :)
14:01:00 <breadmonster> kadoban: Have you read Okasaki's book?
14:01:32 <kadoban> Yeah, I like that one a lot.
14:01:38 <rola> http://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki
14:02:18 <breadmonster> rola: Seen that, the first answer is phenomenal.
14:04:17 <kadoban> Yeah, that's … the best answer I've ever seen on one of those style sites.
14:04:18 * hackagebot tamper 0.4.1 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.4.1 (TobiasDammers)
14:09:18 * hackagebot shell-escape 0.2.0 - Shell escaping library.  http://hackage.haskell.org/package/shell-escape-0.2.0 (JasonDusek)
14:09:20 * hackagebot parcom-lib 0.8.0.3 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.8.0.3 (TobiasDammers)
14:43:39 <navaati> hi
14:44:32 <navaati> how do you efficiently produce a string by repeatedly appending to it (say while munching a list) ?
14:44:50 <Pamelloes> Watching data stream by matrix-style is qutie satisfying :)
14:45:01 <navaati> because, i mean, simply ++'ing each time would produce a nasty O(n^2)
14:45:27 <breadmonster> navaati: Have you heard of DLists?
14:45:38 <nullvoid8> navaati: I think term you want is difference lists
14:45:39 <navaati> breadmonster: nope, I'll have a look
14:45:46 <navaati> is it in base ?
14:45:48 <breadmonster> Nope.
14:45:56 <breadmonster> Not to my knowledge.
14:46:01 <oconnore> how do I configure ghc to create _stub.c and _stub.o files?
14:46:05 <breadmonster> navaati: You don't need a package.
14:46:08 <exio4> navaati: a DList is just type DList a = [a] -> [a]
14:46:18 <navaati> ah, right
14:46:18 <oconnore> also, I saw a stackoverflow thing that says they aren't created anymore, but the manual still says to link them
14:46:33 <aweinstock> > ("hello"++) . ("world"++) $ ""
14:46:35 <lambdabot>  "helloworld"
14:46:42 <oconnore> -no-hs-main doesn't seem to work, which is what this recommends: http://stackoverflow.com/questions/10983728/ghc-7-4-1-not-producing-stub-o-files
14:46:45 <nullvoid8> navaati: but if you want one http://hackage.haskell.org/package/dlist
14:46:48 <oconnore> I'm on ghc 7.10
14:47:12 <breadmonster> navaati: `appendDList x y = (x ++) . y` and `toList :: DList a -> [a]; toList d = d []`
14:47:13 <augur> difference lists are lists that have been partially applied to (++), which makes me wonder if there's any interesting generalization
14:57:34 <rbocquet> augur: you represent a monoid by its morphisms
14:59:52 <augur> rbocquet: wrong person, methinks :)
15:00:25 <augur> or do you mean to say difference lists generalize the monoids-as-their-morphisms?
15:01:04 <ronbrz> #emacs
15:01:11 <rbocquet> the other way arround, lists are monoids, dlists are monoid morphisms
15:02:12 <andrevm> @hoogle (b -> a -> m b) -> b -> t a -> m (t b)
15:02:12 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
15:02:13 <lambdabot> Data.IntMap.Strict differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
15:02:13 <lambdabot> Data.IntMap.Lazy differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
15:02:24 <augur> rbocquet: sure
15:05:52 <breadmonster> rbocquet: Umm, can you elaborate on that?
15:07:43 <fishythefish> augur, the idea behind DList generalizes to the codensity transformation, IIRC.
15:08:28 <andrevm> :t non
15:08:29 <lambdabot> (Eq a, Functor f, Profunctor p) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
15:08:33 <andrevm> :t anon
15:08:34 <lambdabot> (Functor f, Profunctor p) => a -> (a -> Bool) -> p a (f a) -> p (Maybe a) (f (Maybe a))
15:08:53 * breadmonster wonders what libraries lambdabot imports.
15:09:46 <arkeet> :t (mapM .) -- andrevm 
15:09:46 <lambdabot> (Monad m, Traversable t) => (a -> a1 -> m b) -> a -> t a1 -> m (t b)
15:10:02 <augur> fishythefish: interesting!
15:10:13 <andrevm> :t mapM
15:10:14 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
15:11:09 <andrevm> arkeet: I was looking for a fold that leaves behind a result and an updated Traversable
15:11:23 <andrevm> :t mapAccumR
15:11:24 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
15:11:35 <andrevm> actually
15:11:39 <andrevm> idk what I was looking for
15:11:39 <arkeet> :t mapAccumL
15:11:40 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
15:12:03 <fishythefish> augur, I think this is the original paper: http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
15:12:07 <andrevm> basically my thought process was
15:12:10 <andrevm> :t foldM
15:12:11 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
15:12:23 <andrevm> that only requires Foldable, not traversable
15:12:26 <andrevm> :t traverse
15:12:27 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
15:12:32 <andrevm> that only requires applicative, not monad
15:12:40 <andrevm> I was looking for a generalization of both
15:12:49 <andrevm> that requires (Monad m, Traversable t)
15:13:44 <andrevm> does that make sense?
15:13:53 <arkeet> what, exactly, are you looking for?
15:14:11 <andrevm> what I just said was as specific as I can get
15:14:15 <arkeet> what do you have
15:14:17 <arkeet> and what do you want out of it
15:14:54 <andrevm> I dont have anything
15:15:36 <andrevm> I was just curious about the existence of such a function
15:16:11 <andrevm> :t scanM
15:16:12 <lambdabot>     Not in scope: ‘scanM’
15:16:12 <lambdabot>     Perhaps you meant one of these:
15:16:12 <lambdabot>       ‘scanl’ (imported from Data.List),
15:16:23 <andrevm> :t scanr
15:16:24 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
15:16:29 <arkeet> you can do some useful things by combining traverse with a monad transformer.
15:16:38 <arkeet> (well, mapM, but mapM is traverse)
15:18:13 <andrevm> arkeet: i dont see how that is powerful enough
15:18:25 <arkeet> well I still have no idea what you want.
15:18:26 <arkeet> :)
15:18:27 <andrevm> mapM and traverse dont use >>=
15:18:30 <andrevm> thats okay
15:19:29 <andrevm> I only hoogled in the first place to look for the exstance of such a thing
15:19:40 <andrevm> didnt mean to attract people to try to help me
15:19:53 <navaati> (>>) does not actually need a monad, only an applicative, right ?
15:19:59 <andrevm> no
15:20:05 <andrevm> it technically requires a Monad
15:20:12 <andrevm> u can use *> though
15:20:17 <andrevm> :t (*>)
15:20:18 <lambdabot> Applicative f => f a -> f b -> f b
15:20:24 <andrevm> :t (>>)
15:20:26 <glguy> andreass: When you just want to use lambdabot and you're not showing someone something in particular you can interact with lambdabot in /msg
15:20:26 <lambdabot> Monad m => m a -> m b -> m b
15:20:37 <glguy> err, andrevm
15:21:36 <andrevm> glguy: I just used regular hoogle after the query
15:21:40 <andrevm> thanks for the tip though
15:21:54 <andrevm> also thats a strange typo you made
15:21:58 <andrevm> in my name
15:22:30 <glguy> No, it's just someone else's name (tab completion)
15:22:54 <andrevm> okay
15:33:29 <jpo> stupid question to fix something completely orthogonal: if i have the following: `foo <- readProcess "./bar" [file] ""` using System.Process, how do i make it run the shell-equivelant of `./bar -x $file`?
15:34:06 <jpo> well, ./bar -x "$file", but you get the point
15:35:38 <jpo> the first arg seems to be the thing passed to execve(2) since i get "ERROR: ./bar -x: readProcess: runInteractiveProcess: exec: does not exist (No such file or directory)"
15:36:26 <jpo> and its clearly not some varargs type thing since adding "-x" gives a type error
15:36:45 <jpo> and i'm too haskell-illiterate to make a better choice from https://hackage.haskell.org/package/process-1.0.1.1/docs/System-Process.html
15:37:27 <srhb> jpo: I have absolutely no idea what you're actually asking. Is it how to aadd arguments to the process run by readProcess?
15:37:35 <jpo> yes
15:38:05 <srhb> jpo: You are passing just [file], you want ["-x", file] or something
15:38:42 <jpo> derp wow. that seems so obvious now
15:38:44 <jpo> thanks!
15:38:47 <srhb> jpo: :) Sure thing.
15:49:22 * hackagebot JsonGrammar 1.0.2 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-1.0.2 (MartijnVanSteenbergen)
15:59:42 <andrevm> is there a Map that allows you to specify a default?
15:59:49 <andrevm> something with an operatio like
16:00:02 <andrevm> TotalMap k v -> k -> v
16:00:12 <andrevm> and
16:00:27 <andrevm> empty :: v -> TotalMap k v
16:01:02 <Javran> :t maybe
16:01:04 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:01:54 <Javran> what I usually do it to combine the lookup result with "maybe" to give it a default value
16:02:06 <andrevm> thats what I have used before
16:02:23 <andrevm> but I think being able to carry the default around with the map itself is powerful
16:02:23 <arkeet> I swear there was something with more stuff than this but this is all I can find:
16:02:26 <Javran> or fromMaybe
16:02:26 <arkeet> https://hackage.haskell.org/package/total-map-0.0.4/docs/Data-TotalMap.html
16:03:05 <hpc> andrevm: a total map can also be implemented as a function
16:03:10 <arkeet> like it doesn't have anything for "insert"
16:03:10 <andrevm> makes sense that conal wrote that
16:03:13 <hpc> type TotalMap k v = (k -> v)
16:03:16 <arkeet> (although you can in theory write it yourself...)
16:03:31 <Javran> or make one by using https://hackage.haskell.org/package/data-default ? 
16:03:38 <arkeet> :(
16:03:45 <andrevm> hpc: there are obvious performance issues with that approach, no?
16:03:54 <arkeet> more than performance issues.
16:04:01 <hpc> depends what you're doing with it
16:04:07 <hpc> but yes, don't do it that way for most use cases
16:04:10 * hpc was being silly
16:05:28 <andrevm> arkeet: what issues other than performance issues?
16:05:41 <mniip> [02:00:52] <hpc> type TotalMap k v = (k -> v)
16:05:44 <arkeet> well, first of all it's semantically different.
16:05:46 <mniip> there is Representative
16:06:03 <arkeet> the TotalMap thing you're describing only allows finitely many non-default values.
16:06:06 <mniip> er
16:06:09 <mniip> Representable
16:06:21 <arkeet> on the other hand that lets you compare two such maps for equality, even for infinite key types.
16:07:00 <andrevm> arkeet: thats a performance issue if you squint at it
16:07:03 <andrevm> =)
16:07:04 <andrevm> jk
16:07:05 <arkeet> no
16:07:07 <andrevm> good point
16:07:19 <arkeet> :)
16:07:28 <rjeli_> @pl \x -> x == reverse x
16:07:29 <lambdabot> ap (==) reverse
16:07:37 <arkeet> (==) <*> reverse
16:07:46 <arkeet> same thing.
16:08:00 <rjeli_> ty
16:08:02 <andrevm> hopefully
16:09:22 * hackagebot diversity 0.7.0.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.7.0.0 (GregorySchwartz)
16:09:31 <mniip> join $ (==) . reverse
16:14:14 <xandaros> Do functions that are part of a typeclass have a special name? (Method?)
16:14:23 * hackagebot snap-core 0.9.7.2 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.7.2 (GregoryCollins)
16:14:36 <nshepperd> type TotalMap k v = (Map k v, v)
16:14:44 <mniip> typeclass functions
16:14:52 <arkeet> xandaros: I call them methods.
16:15:01 <arkeet> (even if they're not functions.)
16:15:53 <xandaros> There is a tutorial on haskell.org that also calls them methods. Should be alright, then. Thanks
16:19:23 * hackagebot process-streaming 0.7.2.2 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.7.2.2 (DanielDiazCarrete)
16:19:25 * hackagebot hsparql 0.2.6 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.2.6 (RobStewart)
16:21:25 <ttt_ff> is there a monad m s.t. m a = a ? (I'm defining a typeclass, and trying to make it general)
16:21:43 <arkeet> Identity
16:22:00 <ttt_ff> are they "the same sorta of" or "the ghc type chcker considers them to be equal" ?
16:22:03 <arkeet> no.
16:22:06 <ttt_ff> :t Identity
16:22:07 <lambdabot> a -> Identity a
16:22:07 <hpc> @src Identity
16:22:08 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
16:22:25 <arkeet> "m a" and "a" are different. (no matter what m and a are.)
16:22:26 <ttt_ff> err, so therefore "Identity a != a"
16:22:28 <ttt_ff> damn
16:22:36 <ttt_ff> oh wait
16:22:37 <arkeet> right, they're just isomorphic types.
16:22:38 <ttt_ff> Maybe is a monad
16:22:38 <hpc> sure, but that doesn't stop us
16:22:45 <hpc> see mtl
16:22:51 <ttt_ff> so lookup is fine if I force it to use a monad
16:22:59 <arkeet> ?
16:23:13 <arkeet> what are you doing?
16:23:23 <ttt_ff> ignore the last thing I said (it's part of the problem I failed to explain)
16:23:25 <axsz> is there a Haskell Lisp?
16:23:34 <ttt_ff> axsz: liskell
16:23:54 <hpc> but if you try and use liskell, you'll conclude the answer is actually "no"
16:24:07 <ttt_ff> arkeet: I'm defining a typeclass with "lookup / extend" ... but I want it to work on both (1) Haskell.Data.Map (2) an Environemnt (like a scheme environment) and (3) inside a Monad that has error handling
16:24:23 <ttt_ff> arkeet: so I'm trying to find a typeclass definition of lookup/extend that works for all 3
16:24:41 <ttt_ff> arkeet: class EnvExtend m a b where env_extend :: a -> m b -> m b 
16:25:03 <ttt_ff> thus, I was wondering what id' be like if m = Identity, but then I get isomorphic types instead of equivalent types
16:25:19 <arkeet> you could just
16:25:22 <arkeet> not have an instance for Identity.
16:25:26 <ttt_ff> hpc: absolutely correct, I used to want lisp syntax in haskell; but I've come to find that haskell syntax is better than lisp syntax (if you want to use haskell)
16:25:39 <ttt_ff> ah, but then I need to have different names for lookup
16:25:41 <ttt_ff> and lookup_naked
16:25:47 <arkeet> what's lookup?
16:26:06 <hpc> or if you want a lisp that uses some of the philosophy and design choices of haskell
16:26:09 <ttt_ff> for maps it's : lookup :: Ord k => k -> Map k a -> Maybe a
16:26:10 <hpc> maybe scheme?
16:26:15 <hpc> but it'd be a stretch
16:26:24 <ttt_ff> thus my comment of "oh, I can just use the Myabe monad" above
16:26:27 <hpc> there's probably purer lisps but scheme is the biggest close-enough one
16:26:44 <ttt_ff> if you want an untyped lisp, use clojure
16:26:48 <ttt_ff> if you want a typed scheme, use racket
16:26:53 <ttt_ff> if you realize that scheme is not that great, use haskell
16:27:14 <ttt_ff> or , "when you get sick and tired of unit tests and runtime errors and 'debugging from the repl is no longer fun'" --> then, you fall in love with ghc
16:27:34 <Welkin> I got tired of clojure after 5 minutes
16:28:21 <ttt_ff> type checking is like: before you get on the plane, you check that the plane has enough fuel to get you to destination; deugging in repl is like "well, this plane is designed so that it can crash land; then, you get on the plane, take off with the wrong fuel, it crash lands, and you scavage for fuel and another runway to get it back into the air"
16:29:00 <arkeet> Carmack seems to like typed racket a lot.
16:29:47 <axsz> i was upset that clojure was difficult to use on Android
16:30:00 <axsz> but then maybe i should stop thinking about android
16:30:05 <axsz> haskell aint on there
16:30:54 <arkeet> https://wiki.haskell.org/Android
16:36:14 <dedgrant> Hi all.. anyone know of existing Monad typeclass specializations for various pipes Proxy types? Specifically I have a client session of type (MonadLogger m => Client C2S S2C m SessionToken) that I'd like to turn into ((MonadLogger m, MonadClient C2S S2C m) => m SessionToken). (Reason is just to eliminate ugly lifts from the larger api, so open to alternatives as well.)
16:38:35 <davidfetter> is lift the GOTO of haskell?
16:38:55 <alexa_> I still don't know what lift is and I see it in Scalaz too -_-
16:39:05 <exio4> davidfetter: which `lift`? 
16:39:14 <alexa_> Leave it to FP to make you feel dumb as dirt.
16:40:02 <dibblego> alexa_: scala http://blog.tmorris.net/posts/lifting/index.html
16:40:08 <dibblego> alexa_: haskell http://blog.tmorris.net/posts/lifting-haskell-addendum/index.html
16:40:56 <roboguy_> davidfetter: no. callCC would be the closest to a goto that I can think of
16:41:51 <alexa_> dibblego: is it just a function that takes a value and returns a function to that value?
16:42:03 <dibblego> alexa_: pretty much
16:42:09 <alexa_> oh, alright then
16:42:21 <dibblego> alexa_: the term is also sometimes use in a monad transformer context
16:42:29 <dibblego> @type lift
16:42:30 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:42:31 <alexa_> I know some of those words.
16:43:42 <alexa_> I'm sure I'll understand better once #scala agrees en-masse on the definition of a monad.
16:44:25 <Pamelloes> Isn't a monad just a monoid in the category of endofunctors?
16:44:27 <Pamelloes> :P
16:44:49 <alexa_> Pamelloes: I like your style.
16:45:33 <alexa_> Some day that definition will convey comprehensible meaning to me.
16:45:35 <alexa_> Some day.
16:47:39 <Pamelloes> Some day soon :)
16:48:42 <Welkin> a moonad
16:48:48 <alexa_> maybe. First I need to understand monoid, functor, endorfunctor etc.
16:49:05 <alexa_> Although if I did the reading I probably could now. But I'm starting with more basic stuff.
16:49:19 <alexa_> endofunctor*
16:49:54 <alexa_> I should totally choose to write my solutions in haskell next time I do a paper technical test in an interview.
16:50:58 <roboguy_> alexa_: monoids are the easiest. You already know some monoids, which helps
16:51:19 <alexa_> I'm sure I know them, but I don't know the underlying concept/pattern, which is kind of like MEH
16:51:44 <alexa_> Also I'm not sure if I should believe http://like-a-boss.net/lies.jpg when he says List is a monad.
16:51:44 <dibblego> alexa_: I wasn't aware there was disagreement.
16:52:00 <alexa_> dibblego: you've clearly never seen someone submit a definition for monad in #scala.
16:52:08 <alexa_> hoboy.
16:52:08 <roboguy_> it's a binary operation that is associative and has a unit. Addition on real numbers is a monoid because (a + b) + c = a + (b + c) and 0 + a = a = a + 0
16:52:33 <alexa_> define "has a unit", because I can't stop my brain from thinking ()
16:52:33 <Pamelloes> roboguy_: monad not monoid ;)
16:52:41 <roboguy_> Pamelloes: ?
16:52:46 <alexa_> Pamelloes: I know he's explaining monoid, and I'm glad he is
16:52:47 <dibblego> alexa_: I have seen some failures, but I always assumed that it was obvious and can be corrected (aside from the exceptions)
16:53:05 <alexa_> it's not the failures, it's the arguments.
16:53:08 <Pamelloes> roboguy_: Oh sorry, I misread some stuff :P
16:53:37 <dibblego> alexa_: I have not seen that, aside from the exceptional cases where you'd expect it
16:53:49 <roboguy_> alexa_: u is the unit of a binary operation * when u * a = a and a * u = a for all a
16:54:18 <breadmonster> alexa_: A monoid is a collections of things that can be combined or "added together" to form a bigger thing, along with the notion of "nothing" which denotes not combining at all.
16:54:19 <roboguy_> so, 1 for number multiplication, 0 for number addition and the empty list for lists with appending for example
16:54:29 <alexa_> so a value that applied to a binary operation results in no change to the other argument?
16:54:40 <breadmonster> alexa_: String concatenation is the best example.
16:55:10 <dibblego> alexa_: yes, exactly, and that operation must be associative
16:55:14 <alexa_> aah, got you on the unit valuje
16:55:23 <dibblego> alexa_: that value is the unit or identity for that operation
16:55:43 <alexa_> so any operation to combine two things, that supports the combining of a thing and it's "Non-changing" value, is a monoid
16:55:50 <breadmonster> alexa_: Correct.
16:55:56 <alexa_> Seems pretty straightforward
16:55:59 <dibblego> alexa_: and associative
16:56:02 <breadmonster> A functor is really simple too.
16:56:08 <alexa_> Wait, does this mean division is not a monoid?
16:56:13 <alexa_> although multiplication is
16:56:15 <jgcoded> is there anyway to get the haskell linter in the Atom editor to automatically replace my bad code?
16:56:15 <alexa_> Interesting.
16:56:17 <dibblego> alexa_: division is not
16:56:19 <breadmonster> alexa_: division is not a monoid.
16:56:25 <roboguy_> subtraction is also not a monoid
16:56:27 <alexa_> Indeed, since it isn't associative
16:56:29 <dibblego> alexa_: also, you need the identity to form a monoid
16:56:37 <|f`-`|f> (division is a seminring)
16:56:39 <alexa_> dibblego: for a List this is Nil
16:56:41 <alexa_> right?
16:56:46 <|f`-`|f> (subtraction is a ring)
16:57:01 <|f`-`|f> yes alexa_ 
16:57:14 <dibblego> alexa_: to state a monoid, you have three things; the set, binary associative operation, and identity, so to answer your question, ([a], (++), [])
16:57:17 <alexa_> actually, would it be better to say Cons is a monoid, and its unit value is nil?
16:57:25 <dibblego> not cons, append
16:57:34 <alexa_> ah, okay
16:57:34 <dibblego> cons is not a closed binary associative operation
16:57:44 <alexa_> right, cons is directional
16:57:47 <alexa_> my bad
16:57:54 <|f`-`|f> closed?
16:58:06 <dibblego> the operation is closed on a set
16:58:27 <alexa_> wait, you said string concatenation was an example.... but string concatenation is not associative
16:58:35 <dibblego> alexa_: sure is
16:58:35 <alexa_> "a" ++ "b" is not "b" ++ "a"
16:58:40 <dibblego> that is commutative
16:58:47 <dibblego> list concatenation is not commutative
16:58:54 <dibblego> monoids that also commute are called abelian monoids
16:59:01 <dibblego> list concatenation is not abelian
16:59:18 <dibblego> ((x ++ y) ++ z) == (x ++ (y ++ z)) -- associative
16:59:20 <kadoban> alexa_: Associative is    (a <> b) <> c  === a <> (b <> c)
16:59:24 * hackagebot quiver 0.0.0.5 - Quiver finite stream processing library  http://hackage.haskell.org/package/quiver-0.0.0.5 (patrykz)
16:59:34 <roboguy_> > (("abc" ++ "def") ++ "123",       "123" ++ ("abc" ++ "def"))
16:59:35 <lambdabot>  ("abcdef123","123abcdef")
16:59:36 <|f`-`|f> Ah, so it's a bounded set, dibblego 
16:59:41 <roboguy_> ha, oops
16:59:53 <roboguy_> > (("abc" ++ "def") ++ "123",       "abc" ++ ("def" ++ "123"))
16:59:54 <lambdabot>  ("abcdef123","abcdef123")
17:00:00 <|f`-`|f> (associative is both left and right associative)
17:00:04 <alexa_> kadoban: so  A <> B doesn't need to equal B <> A? (since it certainly doesn't for string concatenation)
17:00:19 <|f`-`|f> nope
17:00:22 <dibblego> alexa_: not all monoids commute
17:00:23 <alexa_> aah, okay
17:00:36 <dibblego> string concatenation is an example of one that does not
17:00:38 <alexa_> and commutative is when you can flip the order for the same result, yes?
17:00:44 <|f`-`|f> ye
17:00:44 <roboguy_> Associativity is like saying that if you have a bunch of things that you want to combine, it doesn't matter which things you combine first. (a + b) + c combines a and b first and then the result with c
17:00:45 <dibblego> so is this one: (a -> a, (.), id)
17:00:56 <dibblego> alexa_: yes, you stated commutativity above
17:00:56 <alexa_> thanks guys
17:01:06 <alexa_> That cleared up a few things very nicely.
17:01:11 <dibblego> np
17:01:32 <alexa_> also I take it <> is a notation for (some undefined operation)?
17:01:38 <Cale> An operation * is associative if for all a, b, c, you have (a * b) * c = a * (b * c), and it is commutative if for all a, b, you have a * b = b * a
17:01:55 <alexa_> Cale: very succinct, thank you
17:02:03 <Cale> :t (<>)
17:02:04 <lambdabot> Monoid m => m -> m -> m
17:02:08 <dibblego> alexa_: (<>) is canonical identifier for the binary operation in haskell
17:02:23 <alexa_> ah, okay. What's the identifier for unary?
17:02:39 <dibblego> mempty
17:02:43 <dibblego> sorry
17:02:43 <roboguy_> there isn't really one
17:02:48 <kadoban> haskell only has one unary operator, negation.
17:02:49 <alexa_> okay
17:02:52 <dibblego> I assume you mean unit, not unary
17:03:06 <alexa_> I meant unary. As in !false -> true
17:03:10 <alexa_> a unary operation
17:03:30 <dibblego> wait, (<>) is the canonical name for the identifier used in monoids specifically
17:03:39 <dibblego> or semigroups,where it originated
17:03:44 <alexa_> aah, okay
17:03:59 <kadoban> It's an alias for mappend, which is … somewhat unfortunately named.
17:04:00 <alexa_> so not more generally in any function of A, B -> C
17:04:03 <kadoban> :t mappend
17:04:04 <lambdabot> Monoid a => a -> a -> a
17:04:18 <alexa_> m. append?
17:04:19 <dibblego> alexa_: no not more general than that
17:04:27 <alexa_> tack så mycket.
17:04:42 <dibblego> historically, the binary operation and unit are called mappend, mempty
17:04:56 <kadoban> alexa_: mappend is equivalent to (<>), it's the associative operator for a Monoid
17:05:55 <alexa_> What a fun discussion to have for someone basically on page 1 of LYAHFGG
17:06:09 <kadoban> Heh
17:06:13 <rjeli> is there a list of pronunciations for common infix operators
17:06:19 <ttt_fff> :t curry
17:06:20 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:06:22 <ttt_fff> :t uncurry
17:06:22 <rjeli> it's hard to read my code to myself
17:06:23 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:06:34 <ttt_fff> damn it, anyone else feel taht  curry/uncurry are named BACKWARDS ?
17:06:43 <ttt_fff> I feel taht curry should be (a -> b -> c) -> ((a,b) -> c)
17:06:43 <dibblego> ttt_fff: No.
17:06:48 <alexa_> ttt_fff: nope, seems right to me
17:06:53 <ttt_fff> and uncurry should be ((a,b) -> c) -> a -> b -> c
17:06:54 <ttt_fff> okay
17:06:57 <dibblego> why name a function that uncurries, curry?
17:06:57 <ttt_fff> i'm wrong
17:06:59 <ttt_fff> but what is wrong with my ituition
17:07:03 <kadoban> rjeli: Depends …   <$> = fmap,   <*> = ap,  -> = to   … not sure what other big ones there are.
17:07:10 <alexa_> a curried function is a function a -> b -> c
17:07:18 <dibblego> (<*>) spaceship
17:07:19 <alexa_> If you want a function that curries another, that's the result you expect.
17:07:28 <alexa_> and the inverse is also true
17:07:31 <kadoban> rjeli: The Monad ones don't really tend to have names, except maybe   >>= = bind
17:07:43 <dibblego> (<*) left nose down, terrain impacting spaceship
17:07:51 <rjeli> haha
17:07:59 <SaidinWoT> or read each character aloud
17:08:03 <ttt_fff> curry = expand ?
17:08:08 <SaidinWoT> less-than-sign-asterisk-greater-than-sign
17:08:10 <rjeli> left chevron asterisk right chevorn
17:08:19 <SaidinWoT> that's more correct, yeah
17:08:22 <kadoban> Haha … that sounds awful.
17:08:47 <SaidinWoT> but the longer the name, the more fun it is to say!
17:09:25 * hackagebot attoparsec 0.13.0.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.13.0.1 (BryanOSullivan)
17:09:54 <alexa_> In Javascript the following operator is pronounced "Go to hell you son of a bitch I fuck your mother." (sorry if that's too vulgar for #haskell) ......     ==
17:10:09 <exio4> saying Haskell stuff out loud sounds a bit.. hard
17:10:27 <exio4> I mean, pronouncing types when you throw GADTs + RankNTypes is basically not-nice 
17:11:05 <Cale> exio4: Leaving longer pauses for parens :D
17:11:13 <c_wraith> Cale: that's my strategy!
17:11:36 <roboguy_> ttt_fff: hmm, what do you mean expand?
17:11:55 <rjeli> i think verbally
17:11:59 <rjeli> so haskell is hard :-(
17:12:05 <ttt_fff> roboguy_: the english definition of the word 'curry'
17:12:14 <dibblego> rjeli: use the types
17:12:32 <rjeli> ah
17:12:34 <rjeli> nice thanks
17:12:51 <roboguy_> ttt_fff: it takes a function that takes a pair and turns it into a one argument function that returns a function taking the remaining argument
17:12:57 <dibblego> @type (<$)
17:12:58 <lambdabot> Functor f => a -> f b -> f a
17:13:00 <exio4> c_wraith: (forall (n :: Nat) a f r. (b ~ Fam n b, Functor f) => a -> b -> f r -- saying something like this, sounds like a bit hard.. 
17:13:08 <exio4> oops, Cale* 
17:13:16 <exio4> sorry for the tabfail :P 
17:13:57 <c_wraith> Sometimes you just have to accept that the spoken word lacks some symbolic density and use written symbols. :)
17:14:25 * hackagebot hpack 0.5.0 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.5.0 (SimonHengel)
17:16:07 <exio4> or if anything, I wouldn't try to _pronounce_ the code, but just say what it is doing :P 
17:18:04 <Cale> exio4: "for all n of kind Nat, a, f, and r, if b is equal to Fam n b, and f is a functor, then a to b to f of r"
17:18:43 <Cale> or I dunno, something like that
17:18:52 <exio4> Cale: wow, that actually makes sense, how do high order functions play with this?
17:19:12 <Cale> exio4: Not nicely, that's the "leaving pauses" bit :D
17:19:32 <exio4> I think the "problem" would be at things like :: (forall a. f a -> g a) -> t f a -> t g a
17:19:35 <Cale> Well, you can usually actually say something different to make it clearer
17:19:56 <Cale> But if you leave a long pause for the ) people will understand a lot of the time
17:20:51 <Cale> "for all a, f of a to g of a <pause> to t f of a to t g of a"
17:21:16 <Cale> Actually, the repeated use of a there is terrible
17:21:29 <Cale> better to change variables if you want to speak that aloud and be understood
17:21:41 <Cale> Well, and the higher rank-ness is going to hurt as well
17:21:43 <exio4> heh :D
17:21:52 <Cale> but maybe context will help
17:24:16 <Cale> exio4: Being able to use your hands to indicate parens also helps
17:24:48 <Cale> You can hold your hands up to make parens while speaking "for all a, f of a to g of a", lower your hands, and give the rest of the expression
17:25:15 <Cale> Good tactic if you have to give a talk or lecture
17:25:22 <hodapp> why the crap does this code have a WriterT inside a ReaderT inside a WriterT...
17:26:00 <exio4> Cale: I think that makes sense, I didn't think of using hands for extra info
17:28:47 <roboguy_> exio4: it looks like some kind of lift on a natural transformation. I might mention that too
17:29:13 <alexa_> Anyone feel like tossing me a link to the general go-to testing solution in haskell?
17:30:15 <exio4> roboguy_: yeah, I meant it that way, because it's the simplest example of a a RankNTypes which isn't "too boring" :P 
17:30:29 <alexa_> HUnit? one of the first results from google, or is there another thing more people tend to use/recommend/?
17:31:31 <SaidinWoT> I believe QuickCheck is frequently used
17:31:35 <SaidinWoT> But I'm pretty new as well
17:31:42 <alexa_> SaidinWoT: thanks
17:44:02 <alexa_> dot_asp: you're missing an x my friend.
17:44:17 <alexa_> (I hope)
17:47:15 <dotxasp> .
17:47:55 <alexa_> :( I made him sad
17:48:14 <hodapp> o_O
17:49:51 <jgcoded> why does 2^129 :: Int return 0?
17:50:15 <Cale> jgcoded: Because you're not using some sort of 256 bit architecture machine
17:50:18 <hodapp> I'd guess because it completely overflows the range of an Int
17:50:42 <geekosaur> Int is a hardware integer, most hardware is not considerate enough to signal overflow
17:50:44 <Cale> jgcoded: Int computes results modulo 2^n where n is the word length of the machine you're using.
17:50:51 <pacak> jgcoded: Because Int can hold only 64 bits worth of data.
17:50:54 <hodapp> > (2^129 + 1) :: Int
17:50:55 <lambdabot>  1
17:51:28 <Cale> > (minBound :: Int, maxBound :: Int)
17:51:29 <lambdabot>  (-9223372036854775808,9223372036854775807)
17:51:36 <Cale> > 2^129 :: Integer
17:51:38 <lambdabot>  680564733841876926926749214863536422912
17:51:47 <Cale> ^^ Integer on the other hand, has no problem with this.
17:52:04 <jgcoded> ah so Int is hardware limited and Integer/Num can do anything
17:52:36 <alexa_> > 2^129
17:52:37 <lambdabot>  680564733841876926926749214863536422912
17:52:38 <kadoban> Well, Integer is infinite precision. Num is … it depends (Int is an instance of Num, so is Integer, so is Float)
17:52:44 <alexa_> Yay, defaults to the boxed type
17:53:21 <alexa_> or, maybe it's not a boxed type. I just inferred slightly that Int is a primitive and Integer is a more complex type. Maybe these terms fundementally do not apply to haskell
17:53:46 <kadoban> Boxed types are a thing, at least in GHC, but Int isn't unboxed IIUC.
17:53:53 <geekosaur> Int is boxed as well, but boxed isn't quite the same thing in Haskell
17:53:58 <alexa_> ah okay
17:54:21 <geekosaur> boxed has to do with laziness (and whether it can be bottom / the computation that never produces a result)
17:54:26 * hackagebot yesod-static-angular 0.1.5 - Yesod generators for embedding AngularJs code into yesod-static at compile time  http://hackage.haskell.org/package/yesod-static-angular-0.1.5 (JohnLenz)
17:54:35 <kadoban> Int is more fundamental than Integer though, in the sense that it should map to the machine word, whatever that is (though it may be required to be at least 32-bit? maybe?)
17:55:00 <geekosaur> but the thing inside the box can be a hardware word (Int) vs. some implementation of a bigint
17:55:08 <alexa_> kadoban: probably, unless you're running a 16bit system ;)
17:55:19 <geekosaur> must be at least 30 bits, IIRC
17:55:29 <dramforever> yes
17:55:32 <geekosaur> (allowing implementations to steal two bits for tagging of needed; ghc doesn't)
17:55:33 <kadoban> alexa_: Well, I meant that I think the haskell report has some lower-bound on what it must be, regardless of the machine.
17:55:36 <geekosaur> *if needed
17:55:45 <alexa_> ah okay
17:55:51 <dramforever> hmm tagging...
17:56:01 <alexa_> also there probably doesn't exist a 16bit build of ghc ;)
17:56:08 <kadoban> Also probably that :)
17:56:13 <dramforever> it seems that ghc adds a level of indirection over Int
17:56:18 <dramforever> and *that* has tagging
17:56:52 <geekosaur> ghc actually has a separate machine word allocated for a constructor tag, independent of the value storage
17:56:59 <hodapp> huh, I wonder why this package used MonadLib.WriterT/ReaderT rather than the same in Control.Monad.Reader/Writer
17:57:20 <geekosaur> unless it['s an unboxed type, but you don't see those normally; they're buried in the implementation
17:57:25 <dramforever> :)
17:58:17 <geekosaur> (if you see something containing a #, it's *probably* unboxed or involves unboxed values. not always, but usually)
17:58:22 <dramforever> geekosaur: actually on 64-bit machines Int is much larger
17:58:24 <geekosaur> @src Int
17:58:24 <lambdabot> data Int = I# Int#
17:58:34 <dramforever> :t I#
17:58:35 <lambdabot>     Not in scope: data constructor ‘I#’
17:58:35 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
17:59:26 * hackagebot quiver 0.0.0.6 - Quiver finite stream processing library  http://hackage.haskell.org/package/quiver-0.0.0.6 (patrykz)
17:59:30 <geekosaur> the primitive/unboxed types are not imported in ghci. (@src queries a text database; its relevance to actual implementation is sometimes questionable...)
18:03:30 <alexa_> does Haskell support something akin to Scala's case classes? Tuples with pre-defined type signatures and accessor functions to the values?
18:04:00 <alexa_> in scala: case class Point( x: Int, y: Int ); val a = Point(1,2); a.x >>> 1
18:04:00 <kadoban> alexa_: That sounds like records? Yes.
18:04:26 <dramforever> @data Point = Point { x :: Int, y :: Int }
18:04:26 <lambdabot> Unknown command, try @list
18:04:32 <kadoban> data Blah = Blahity {foo :: Int, bar :: Something}
18:04:32 <dramforever> @let data Point = Point { x :: Int, y :: Int }
18:04:34 <lambdabot>  Defined.
18:04:40 <dramforever> > Point 2 4
18:04:42 <lambdabot>      No instance for (Show Point)
18:04:42 <lambdabot>        arising from a use of ‘show_M6544014429908280063598’
18:04:42 <lambdabot>      In the expression:
18:04:51 <dramforever> aww but you get the idea...
18:04:52 <geekosaur> heh
18:04:54 <dramforever> :t x
18:04:55 <lambdabot>     Ambiguous occurrence ‘x’
18:04:55 <lambdabot>     It could refer to either ‘L.x’,
18:04:55 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:147:20
18:04:56 <alexa_> yeah I do, thanks
18:04:58 <geekosaur> yuou forgot to derive Show
18:04:59 <dramforever> aww...
18:05:03 <dramforever> @undefine
18:05:03 <lambdabot> Undefined.
18:05:04 <Bynbo7> > deriving instance Show Point
18:05:05 <lambdabot>  <hint>:1:1: parse error on input ‘deriving’
18:05:07 <Bynbo7> :(
18:05:09 <dramforever> lol
18:05:09 <alexa_> it's not so much a tuple as a distinct type though, yes?
18:05:10 <kadoban> Owned
18:05:32 <kadoban> alexa_: It's … a tuple with different syntax.
18:05:41 <alexa_> granted, so are case classes. Case classes in scala are weird as shit.
18:05:46 <geekosaur> alexa_, we kinda prefer not to use tuples for anything but throwaway stuff, precisely because of the relative lack of typing
18:05:47 <kadoban> alexa_: Being a tuple gives you very little in the way of anything except syntax in haskell.
18:05:52 <alexa_> (they are also classes, meaning they can encapsulate behaviour as well)
18:06:17 <dramforever> alexa_: we usually don't encapsulate behaviour *inside* types
18:06:18 <alexa_> geekosaur: that's why I asked. I don't use them in Scala either, in favour of case classes.
18:06:20 <kadoban> I'm not sure what classes means there.
18:06:27 <alexa_> kadoban: java.
18:06:35 <dramforever> lol exactly what I was typing
18:06:39 <kadoban> Oh, yeah haskell doesn't have that kind of polymorphism
18:06:42 <geekosaur> so we prefer a normal ADT over tuples
18:07:04 <alexa_> I don't mean polymorphism, although case classes can be polymorphic. I mean data + behaviour within the same type.
18:07:07 <alexa_> cheers again guys
18:07:28 <geekosaur> that's an OO notion that Haskell isn't really fond of
18:07:34 <kadoban> Hmm, yeah then in haskell I guess you'd kind of use a module for that, you'd have a type and associated functions that use/produce the type.
18:07:45 <dramforever> yeah
18:07:53 <alexa_> I assumed as much, geekosaur. It's just present in scala because scala is weird as hell and trying to be a hybrid.
18:07:55 <dramforever> and we can extend that rather easily
18:08:02 <bernalex> encapsulating data representation and transformation in the same thing is *bad*.
18:08:25 <dramforever> bernalex: yes, especially if it's immutable
18:08:26 <bernalex> e.g. for representation, inheritance makes sense. for transformation not at all.
18:08:27 <geekosaur> sure. it also wants to be 100% Java compatible, in part so it can make use of all the existing Java libraries
18:08:39 <dramforever> oh that makes sense
18:08:49 <alexa_> exactly.
18:08:49 <geekosaur> so you get some interesting constructs (and interesting limitations in the language)
18:09:14 <bernalex> dramforever: even if it's mutable it's just a nightmare of dependent injection clusterfuck bleurgh. it's an infinitely complex dependency graph of random side-effects.
18:09:33 <alexa_> Scala has complete and total access to the Java API, but can also be written functionally. It just also lets you NOT write it functionally
18:09:35 <dramforever> yeah, and we have that thing called "super"
18:10:06 <alexa_> https://github.com/scalaz/scalaz exists to sort of help things not be so icky ;)
18:10:11 <bernalex> some of would argue that you can't write proper functional programming in scala any more than in swift, heh.
18:10:24 <bernalex> scalaz is funny. we have dibblego and edwardk in here.
18:10:30 <alexa_> Not as simply and succinctly as in haskell it seems.
18:10:34 <dramforever> you can't do proper functional programming
18:10:42 <alexa_> I know, I talk to dibblego a fair bit in the scala channels
18:10:43 <dramforever> it's just not well-researched enough
18:10:44 <bernalex> alexa_: it's strict and impure
18:10:56 <bernalex> which is... problematic.
18:11:42 <bernalex> strictness is anti-modular. side-effects can't exist in functional programming where functional means composing (mathematical) functions.
18:12:12 <bernalex> I don't mean to bash on scala too much though -- I don't know it well. and it may be a reasonable choice in some situations. but I don't think it's a very good language for denotative programming.
18:13:23 <alexa_> I don't know it all to well either honestly. I am learning it because of an interest in FP, and because it has full access to the Java API( and by extension most anything on the JVM), etc
18:14:09 <bernalex> right, so it might be a reasonable choice for you. I dislike the Java API and the JVM, so it's not a reasonable choice for me at all. :)
18:14:19 <alexa_> I never said I liked them ;)
18:14:27 * hackagebot quiver-bytestring 0.0.0.1 - Quiver combinators for bytestring streaming  http://hackage.haskell.org/package/quiver-bytestring-0.0.0.1 (patrykz)
18:14:50 <bernalex> alexa_: I get to not use them because I don't like them. :)
18:15:09 <bernalex> (actually, I suspect nobody is holding a gun to your head and forcing you to use them either, but...)
18:15:26 <alexa_> It's more of an employability thing for me incase I start working part time. 
18:15:32 <alexa_> Haskell jobs not so common
18:15:57 <alexa_> Although I've decided to learn haskell as well for my own enjoyment/benefit
18:15:58 <bernalex> I have refused all jobs where I could not use stuff I like
18:16:05 <bernalex> spoiler alert: I started my own company ;)
18:16:11 <alexa_> hahaha
18:16:30 <kadoban> bernalex: You hiring? ;)
18:16:41 <alexa_> If only I were visionary enough to have a product concept ;)
18:16:46 <alexa_> I have time, but I do not have ideas.
18:16:55 <bernalex> kadoban: sporadically. but we just hired someone, and only really have funding to last the year right now. we'll see next year.
18:17:05 <kadoban> :)
18:17:32 <bernalex> alexa_: I'm not very visionary. I have lots of ideas though... but acquiring funding is difficult.
18:19:13 <geekosaur> one of my coworkers asked whether it made sense to make xmonad support an official thing with $employer. I can't really imagine anyone paying for it, though. (would be one way to get Haskell in the door though...)
18:20:26 <geekosaur> (kinda a pity though, someone paying for it seems like the only way we'll ever manage to fix e.g. the floating layer nonsense)
18:20:34 <bernalex> geekosaur: I've been trying to sell customisation of free software libraries/tooling etc. to people, but people are mostly like "that's a good idea... hmmm... I'll get back to you". :p
18:20:57 <alexa_> bernalex: I used visionary in that context to mean something more akin to "being able to come up with useful ideas"
18:21:28 <alexa_> I felt "creative" lacked the appropriate meaning. I am not creative in the artistic sense, but I am rather creative in the sense of when presented with a problem, I can create solutions.
18:21:52 <bernalex> I think there's a marked there somewhere though. there are several semi-big companies that use haskell, that are not complete and utter anti-free software. and I know for a fact they want better tooling. and they use almost exclusively free software libraries, so it's not a too crazy idea.
18:23:16 <zomg> I'm sorta dabbling with my own business as well. The magical freelancing contracts that I can work from home and that pay crazy sums of money just don't surface so much =)
18:23:19 <shachaf> Also creative with regard to the definition of the word "creative"?
18:23:28 <alexa_> Perhaps.
18:23:33 <bernalex> alexa_: funny thing -- I have been called "visionary" before. what they meant though was that I am capable of envisioning a high-level whole picture. from the inception of an idea to its execution to its ramifications. which I guess is true. hasn't helped me acquire funding though.
18:23:40 <alexa_> Creative often has an artistic connotation.
18:23:42 <zomg> Though in my case, at least for time being I'm working on courses rather than software products
18:44:28 * hackagebot quiver-cell 0.0.0.1 - Quiver combinators for cellular data processing  http://hackage.haskell.org/package/quiver-cell-0.0.0.1 (patrykz)
18:53:40 <icicled> Is there an equivalent library to pytz in Haskell?  I've seen timezone-olson & timezone-series but they seem to be lacking when it comes to getting a TimeZone via a description (e.g. get the TimeZone for "US/Central")
19:02:22 <orion> Is it possible to log the HTTP request that generated an exception in Scotty?
19:05:48 <Welkin> can't you just log everything?
19:06:53 <dramforever> yes, it's possible because you can wrap the handler in a catch and write to logs if exception occured, but I'm not sure if you can actually do it in a better way
19:07:42 <orion> Welkin: But how do you tell which requests map to which exceptions?
19:07:46 <icicled> orion, what kind of exceptions are you wanting to catch?
19:08:17 <dramforever> orion: why can't you just read the request in the exception handler?
19:08:49 <orion> dramforever: Scotty wants me to provide an exception handler which doesn't take the request as an argument.
19:09:51 <orion> icicled: I want to catch my own application exceptions. 
19:11:36 <dramforever> orion: sure you can, use stuff like param/params/body/...
19:11:44 <dramforever> wait are you using rescue?
19:11:58 <dramforever> oh wait I messed it up
19:12:45 <dramforever> orion: no you can read the request in the handler
19:13:09 <dramforever> functions like body/param/params will work
19:13:46 <orion> hmm
19:13:52 <orion> I'll have to investigate that.
19:13:53 <dramforever> read the types
19:14:10 <dramforever> your handler has type Text -> ActionM ()
19:14:44 <thatguy91> Bonjour
19:15:50 <pavonia> Au revoir
19:15:53 <orion> dramforever: Actually, it is Monad m => MyAppException -> ActionT MyAppException m ()
19:17:46 <dramforever> orion: ?
19:18:07 <dramforever> oh hmm...
19:18:30 <dramforever> orion: don't worry look here:
19:18:30 <dramforever> http://hackage.haskell.org/package/scotty-0.10.1/docs/Web-Scotty-Trans.html
19:20:18 <hcp_archonn> irc, is using the same name for both a type and its constructor idiomatic? i'm just a guy who stumbles upon haskell code every once in a while, not a practicioner at all, but that particular reuse always trips me up...
19:20:26 <hcp_archonn> for example, this line: "data Py = forall a. Show a => Py a" - the "Py"s there each mean something very different... just wondering why ppl do this, really (and if this is recommended, ofc)
19:21:12 <geekosaur> some people consider it idiomatic, some consider it bad
19:21:43 <geekosaur> type constructors and data constructors can't be confused by the compiler, although they can confuse readers of the code
19:22:19 <dramforever> it's fine to me if there's only one constructor
19:22:57 <monochrom> it can be hard to pick good names. so I don't blame people when they want to re-use a good name.
19:23:40 <monochrom> but it tricks beginners, so I don't do that to beginners
19:23:52 <hcp_archonn> my issue is more of a confusion thing, yeah, but i guess it also would block some sort of future "dependent types" style extension to the language
19:23:53 <dramforever> I guess prepending Mk is also common
19:24:14 <dramforever> hcp_archonn: no we already have 'X to promote
19:24:23 <dolio> It's definitely idiomatic. And also a bad idea. :)
19:24:29 <capisce> http://www.lispcast.com/avoid-naming-at-all-costs
19:25:00 <dolio> Kind of too late, though.
19:25:30 <capisce> The Mk prefix seems a bit silly when deconstructing though, doesn't it?
19:25:44 <dramforever> lol
19:26:15 <monochrom> consider "newtype X = MkX { unMkX :: () }"
19:26:33 <capisce> :/
19:26:41 <nolraiU> capisce: not really?
19:26:42 <monochrom> :)
19:27:08 <capisce> XBox, XUnbox
19:27:35 <capisce> anyway, an smart editor could use different color highlighting for those
19:27:53 <saulzar> ghc --make Foo.hs -XUnbox 
19:28:10 <hcp_archonn> i like "Mk" but would maybe stick to pattern matching for deconstructing
19:28:52 <capisce> why not "Make"?
19:28:56 <yayfoxes> Cale: where's that haskell book you linked me to?
19:29:02 <capisce> if you're going to go there
19:29:25 <yayfoxes> Cale: wait, hold on
19:29:30 <saulzar> capisce, I tend to favour whole words as well, preference I guess
19:30:01 <Pamelloes> Does anyone here use optparse-applicative?
19:30:26 <Clint> i do
19:30:28 <rjeli> @pl matches x y = sum $ zipWith min (countColors x) (countColors y)
19:30:28 <lambdabot> matches = (sum .) . (. countColors) . zipWith min . countColors
19:31:18 <Pamelloes> Clint: Do you know how to add a default command?
19:34:52 <Clint> Pamelloes: what do you mean?
19:35:35 <Pamelloes> I'm creating an application which has multiple subcommands (git style) but I want to execute a default command if none is specified rather than exiting.
19:36:00 <Pamelloes> optparse-applicative has good support for parsing subcommands, but I can't for the life of me find a way to add a default one :/
19:36:07 <Clint> so you want foo --help to be the same as foo bar --help?
19:36:56 <Pamelloes> No. I want "foo" to execute "foo bar" rather than exiting.
19:37:30 <Clint> so you want foo --help to be different from foo bar --help but foo to be the same as foo bar
19:37:39 <Pamelloes> Exactly :)
19:37:48 <Clint> that sounds complicated
19:38:00 <Pamelloes> Yeah....
19:38:11 <magneticDuck> just one layer of syntatic sugar >_>
19:38:18 <magneticDuck> foo -> foo bar, everything else equal
19:39:30 * hackagebot hpack 0.5.1 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.5.1 (SimonHengel)
19:40:16 <andrevm> whats the best way to write a function Set a -> Set a -> (Set a, Set a, Set a) that splits two sets into 3 sets that corrsepond to the intersections and asymetric differences of the sets?
19:45:34 <andrevm> :t (//)
19:45:35 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
19:45:38 <andrevm> :t (\\)
19:45:39 <lambdabot> Eq a => [a] -> [a] -> [a]
19:45:51 <andrevm> :t S.(\\)
19:45:52 <lambdabot> Not in scope: data constructor ‘S’
19:46:00 <andrevm> :t (S.\\)
19:46:00 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
19:46:14 <pacak> andrevm: lambdabot listens to private messages as well.
19:46:23 <andrevm> sorry thought I was in pm
19:46:27 <andrevm> I have both open
19:46:29 <andrevm> my bad
19:46:42 <andrevm> ur msg really freaked me out for a sec lol
20:05:43 <Pamelloes> Can you start a new process in Haskell?
20:06:33 <dramforever> Pamelloes: check System.Process
20:06:50 <Pamelloes> Thanks :)
20:08:18 <orion> How bad are orphan instances?
20:09:14 <c_wraith> orion: depends on *how* orphan.  If they're still in one of the relevant packages, not *so* bad, but you can fix it anyway so you might as well.
20:09:40 <c_wraith> orion: If they're not in either of the packages that define the type or the instance, they can be really troublesome.
20:09:41 <Pamelloes> Hm, is there a simple way to execute a function on another process?
20:10:13 <c_wraith> orion: though most of the issues they introduce are at the package-management level when someone adds an instance that conflicts with your orphan.  Then things get ugly.
20:10:22 <dramforever> Pamelloes: why do you want a new process?
20:10:49 <Pamelloes> I want to create something like a deamon.
20:11:13 <Pamelloes> So that it runs even when the current program ends.
20:11:15 <dramforever> oh I guess nowadays daemons don't daemonize themselves
20:11:20 <c_wraith> orion: still, sometimes they're worth it.  Things like the aeson-lens package introduce orphan instances, and really are pretty justified in doing so.  They introduce the orphan because neither package they depend on will ever use the other, and they have a bunch of other related functions, too.
20:11:31 <Xe> dramforever: there is no need to
20:11:35 <dramforever> they use something like upstart or systemd to manage themselves
20:11:43 <Xe> things like systemd can manage it better if it doesn't daemonize
20:12:18 <edwardk> i used to have aeson-lens directly in the lens package to avoid that orphan instance problem, but i gave up
20:12:27 <Pamelloes> Is there a platform independent way of setting up a daemon in haskell?
20:12:35 <c_wraith> edwardk: totally justified.  That was a wacky dependency to add to lens.
20:12:42 <edwardk> since lens and aeson-lens are at least maintained by me together i can ensure they stay in sync
20:12:57 <edwardk> c_wraith: it would have stayed in frankly if aeson had been added to the platform as the buzz at the time was saying
20:13:06 <dramforever> Pamelloes: I don't know.....
20:13:07 <edwardk> the whole point of adding it was aeson was going into the haskell platform
20:13:17 <edwardk> and lens comes 'batteries included' for the platform
20:13:18 <c_wraith> Ah, that's why it bounced in and out.
20:13:24 <edwardk> so in that light it isn't that unreasonable
20:14:07 <edwardk> its still one of the most popular uses of the lens library
20:14:31 <edwardk> i'll be giving a talk at cufp on lenses for business applications, and lens-aeson is pretty much front and center in that talk
20:14:53 <c_wraith> And the Plated orphan is a *lot* of its power, too
20:14:55 <dramforever> edwardk: <sarcasm> actually if you don't have haskell-platform you can cabal install lens and get a large part of it :) :P </sarcasm>
20:14:59 <c_wraith> ... I do wish Haddock would document orphan instances, though.  I didn't even realize the instance was there, just reading the docs.
20:15:04 <edwardk> dramforever: =P
20:15:15 <edwardk> dramforever: between lens and yesod you can install most of stackage
20:15:24 <dramforever> yep
20:15:38 <dramforever> @hackage ACME-Everything
20:15:38 <lambdabot> http://hackage.haskell.org/package/ACME-Everything
20:15:53 <dramforever> fail
20:20:28 <roboguy_> Pamelloes: Hmm, how about System.Process?
20:21:20 <dramforever> lol I just said that
20:21:45 <roboguy_> Oh, oops
20:22:52 <c_wraith> really, if you want to *call functions* in another process, you should be looking at something like cloud haskell.
20:23:03 <c_wraith> But even that isn't perfect.  (It's improving slowly!)
20:23:08 <dramforever> c_wraith: too much
20:23:12 <dramforever> too complexed
20:23:26 <dramforever> Pamelloes just wanted to daemonize a program
20:23:48 <c_wraith> dramforever: ... and then *call functions* in it from another process
20:23:55 <dramforever> not really
20:24:30 <dramforever> (s)he is just trying to start another copy of his/her program and start a function inside that
20:24:31 <dramforever> iiuc
20:24:59 <dramforever> (11:10:27 AM) Pamelloes: I want to create something like a deamon.
20:24:59 <dramforever> (11:10:52 AM) Pamelloes: So that it runs even when the current program ends.
20:25:12 <dramforever> (don't mind the timezone)
20:25:27 <roboguy_> We do something similar at work actually (RPC from another process), but the solution we use might be a bit to heavyweight for this use case (depending on what the project is).
20:25:52 <dramforever> too bad another x y problem: http://xyproblem.info
20:25:59 <dramforever> (IIUC)
20:26:04 <icicled> In case anyone was curious about the timezone question I posed earlier - http://lpaste.net/4082171114095116288
20:27:18 <c_wraith> icicled: this is totally irrelevant to the question you asked, but...  on line 42, you should really throw an exception explicitly with throwIO, rather than use error.
20:27:30 <c_wraith> icicled: it just has way better semantics when you're already in IO
20:28:24 <icicled> c_wraith: thanks, I'll update that - I thought it was kind of relevant since this "glue" is the piece missing that I was searching for
20:29:07 <c_wraith> icicled: yeah, your question was fine.  I just wanted to make a note about using error inside of IO
20:29:47 <Pamelloes> dramforever: Are you saying my problem is an xy problem?
20:29:56 <orion> c_wraith: I have a library/executable pair. The executable needs to create a ScottyError instance for the application exceptions the library defines.
20:30:09 <dramforever> Pamelloes: yes
20:30:27 <dramforever> call a function in another function is something like rpc
20:30:37 <icicled> c_wraith: ah, I read that wrong - cursed english :)
20:30:46 <Pamelloes> Oh, that was just one possibility I was toying with.
20:31:02 <saulzar> Would it be sensible to wish for types which unify in different ways? e.g. type level sets (lists?) which unify by intersection or union?
20:31:04 <Pamelloes> It seems way too complicated :P
20:31:19 <dramforever> Pamelloes: exactly :P
20:31:38 <c_wraith> saulzar: You can write type functions (via the TypeFamilies extension) that do things like that.
20:31:51 <dramforever> but it isn't really an xy problem in the sense that you are not hiding the real problem
20:32:07 <Pamelloes> Yeah.. what I was hoping for was a simple "runinProcess :: IO () -> IO ()" that would run a function in a separate process, but that doesn't exist.
20:32:21 <c_wraith> saulzar: But you need to explicitly use the type family in places where you'd want the union/intersection/whatever to occur
20:32:33 <zovt> forkIO
20:32:42 <c_wraith> zovt: forkIO is a green thread in the same process
20:32:44 <dramforever> zovt: that's new thread
20:32:50 <c_wraith> Pamelloes: there's always fork and exec. :)
20:32:59 <zovt> was he looking for something else?
20:33:00 <c_wraith> ...  does the IO manager survive a fork these days?
20:33:08 <dramforever> lol I think Pamelloes wanted a cross platform one
20:33:13 <dramforever> portable one
20:33:38 <Pamelloes> Eh, it doesn't really matter. I'm just using this code for myself. But I always like to make my code portable for future reference.
20:33:44 <saulzar> c_wraith, I know - but I'm sad that my type would have to be an indexed monad. If the type system would unify the type then it could be an ordinary monad
20:33:53 <c_wraith> saulzar: ah
20:34:12 <dramforever> Pamelloes: btw your rpc idea is hiding the daemonizing one a bit
20:35:25 <saulzar> c_wraith, Probably I'm just going to end up going un-typed because indexed monads seem like a heavy hammer. But kind of curious if that's sensible or not.
20:36:57 <c_wraith> saulzar: it's an idea with some merit, but you have to be somewhat careful with it.  You have a category of special cases on your hands.  You need to figure out if there's a principled way to handle the special cases so the user doesn't think it's ad-hoc nonsense. :)
20:36:58 <Pamelloes> Is there a way to re-execute the running program via System.Process?
20:37:14 <roboguy_> hmm, re-execute?
20:38:28 <Pamelloes> Yeah, I want a completely separate copy that will continue to run after the current one finishes.
20:39:07 <saulzar> c_wraith, I noticed using type family functions can get you fun types like this one, with too much abuse: http://lpaste.net/136170
20:39:27 <c_wraith> hahaha
20:39:45 <c_wraith> that's a little much, maybe. :)
20:40:10 <exio4> that's a nice type 
20:40:15 <saulzar> I'd run a mile if the library I was using gave me types like that :)
20:40:16 <Pamelloes> saulzar: what the hell is taht
20:40:32 * Pamelloes curls up into a ball
20:41:42 <fosterite> that looks like layout
20:41:52 <roboguy_> saulzar: Is that singleton related?
20:42:22 <saulzar> It's my attempt at typed html - fun experiment to see if I could dis-allow interactive elements inside other interactive elements, of course that means the types go all the way from the child->root
20:42:29 <saulzar> roboguy_, yeah
20:44:12 <roboguy_> It doesn't look *too* hard to read, except for the lambda stuff. Is it possible to break that up into some smaller type synonyms?
20:44:49 <saulzar> roboguy_, It's not an actual type I wrote - just the one ghc inferred from several nested calls :)
20:44:58 <roboguy_> ahhh, ha
20:45:24 <roboguy_> that would explain the lambda names
20:46:01 <saulzar> I think they're from singletons Filter
21:02:37 <zed_> hello everyone : ) i have a more... project-minded question. what kind of projects would haskell be particularly well-suited for, in your opinion/experience ?
21:03:16 <Clint> transforming data
21:04:18 <zed_> Clint: in what sense ? can you unfold your idea ? : )
21:06:11 <dmj`> zed_: web services, rest api's
21:06:15 <catsup> haskell is very general purpose...
21:07:07 <zed_> catsup: yes I agree, but there is often a way that certain languages are better than other, for X Y Z reasons... at least, as far as I know
21:07:25 <zed_> dmj`: what kind of web services ? and why ?
21:07:32 <Axman6> "everything"
21:07:46 <Axman6> zed_: what sort of projects is C++ well suited for? Java?
21:08:29 <zed_> Axman6: I would love to know - I don't know enough about languages to know exactly. I know that certain languages are inherently asking for a broad user base, e.g.
21:08:58 <zed_> that could be a point where C++ could have an advantage, given how many people know it... at least to some extent.
21:09:08 <Axman6> some languages are aimed at specific domains (for example PHP), but most aim to be general purpose
21:09:25 <zed_> Axman6: that is correct, as far as I am concerned
21:10:18 <catsup> haskell is good for anything where garbage collection and boxed values aren't a big problem
21:12:52 <dmj`> zed_: the GHC RTS is highly concurrent, web servers deal with many concurrent connections, so the RTS is a good match for that problem domain. Threads are cheap in haskell. 
21:14:31 <zed_> catsup: thanks - why would you sya so ? i am still pretty new to haskell and i just want to learn as much as possible
21:14:48 <Welkin> it's zed shaw!
21:14:54 <Welkin> benzrf's favorite
21:15:01 <zed_> dmj`: so if I understand well, would you say that it is good at handling many users accessing the same data at the same time ?
21:15:27 <zed_> Welkin: ahah i'll take this as a compliment - but no, it's not him : )
21:16:09 <dmj`> zed_: yes, since a user would be represented by a thread. Haskell even has this thing called Software transactional memory, which introduces database transactions to the level of memory, so you can rollback in case a deadlock occurs. 
21:16:28 <zed_> dmj`: great, thanks for the explanation !
21:16:50 <felixn> zed_: the main question with building apps, is there an ecosystem for what you want to make?  check hackage and see, if not you may spend more time building stuff to build your app.  I was going to create something with Idris, then realized there's no ecosystem :D
21:17:07 <Welkin> idris :D
21:17:22 <zed_> felixn: what do you mean by ecosystem ?
21:17:30 <Welkin> libraries
21:17:35 <zed_> ok, it's what I thought
21:17:39 <catsup> zed_: ordinary haskell code is going to have a lot of boxed values
21:21:12 <felixn> zed_: I think haskell has lots of good web libraries, and database libraries, plus I think ghcjs is in a useable state (transcompile haskell to js).  I don't know about game frameworks, you're probably better off with unity or something of the sort
21:21:35 <benzrf> oh god thats not actually zed shaw is it
21:21:53 <zed_> database ? how would it compared to more traditional, relational DB languages ? *cough* sql *cough*
21:22:02 <zed_> benzrf: ahah no : ) sorry !
21:22:06 <benzrf> phew
21:23:00 <catsup> benzrf: can i ask for a one line summary of the drama?
21:23:05 <benzrf> ?
21:23:18 <catsup> you vs. zed shaw
21:23:22 <benzrf> lmao
21:23:25 <benzrf> no drama
21:23:28 <small-wolf> any slackware users here? the haskell-platform slackbuild is broken and needs to be patched (something about adding OpenGL to the cabal build file)
21:23:34 <benzrf> ive linked a few things by him & asked about them in #haskell-blah
21:23:39 <benzrf> hence Welkins comment
21:23:45 <benzrf> and i dont think id like to actually talk to him
21:23:47 <benzrf> hence mine
21:23:50 <catsup> oh, ok
21:23:56 <benzrf> i certainly dont know him
21:24:01 <benzrf> sorry to disappoint
21:24:20 <felixn> zed_: there's probably a DB written in haskell lol, but I was talking like postgres connectors with nice embedded dsls for writing queries
21:25:12 <shachaf> benzrf: This is not a good channel for that.
21:25:15 <catsup> small-wolf: i have not used slackware in a while.  but anyway i suggest to ditch the haskell platform, and just use 'stack'
21:25:31 <benzrf> shachaf: dude
21:25:35 <benzrf> i literally just replied to catsup
21:26:03 <zed_> felixn: well I'll do my "let's say i've understood that" face ; )
21:26:07 <catsup> small-wolf: haskell platform is always out of date and kind of pointless (even according to its own goals) if you are on linux anyway
21:26:21 <small-wolf> it's the .cabal file and the build-depends. what does that thing do again exactly?
21:26:57 <catsup> small-wolf: the .cabal file specifies build instructions, including dependencies on other packages
21:26:57 <Welkin> benzrf: every time you talk about him, that is more evidence of your obsession!
21:27:16 <catsup> Welkin: i know, i can't believe he's _still_ talking about him
21:27:18 <small-wolf> catsup: oh... all right. I just want it because I'm having trouble finding the cabal slackbuild
21:27:19 <catsup> ;)
21:27:32 <small-wolf> ghc and various other packages install just fine
21:27:34 <felixn> zed_: SQL is a DSL (language of it's own), so embedded DSL means you can write SQL with Haskell syntax (instead of strings)!  that way instead of concatenating strings you can compose SQL with everything haskell gives you
21:28:00 <benzrf> sigh
21:28:09 <small-wolf> also, total long shot but anyone at gophercon?
21:29:08 <catsup> small-wolf: i don't actually know anything about modern slackware...  but i'm tellin ya, you will have the least pain if you don't bother with trying to go the haskell-platform/cabal to get a haskell environment.  it is basically obsoleted by an installer called 'stack' that you can use to install everything you need (including ghc)
21:29:18 <zed_> felixn: oh ok, I think I understand - thanks for explaining
21:30:04 <dmj`> Does anyone have any preference on a logging library? Just curious to know what people like
21:30:10 <dmj`> specifically for a web server
21:30:33 <johnw> dmj`: will this become a library/component for others to use, or just for your own use?
21:30:52 <small-wolf> catsup: hmm cool thanks for the recommendation
21:32:03 <dmj`> johnw: just for my own internal use, needs to log to stdout/stderr, and maybe have some predictable format that another service could use for analysis
21:32:09 <johnw> dmj`: second question: do you want to abstract the logging capability, to allow compiling it out entirely?
21:33:59 <dmj`> johnw: probably not. Could just have a disableLogging flag too in the web server config. Not sure what compiling it out entirely means
21:34:17 <johnw> then I'd recommend http://hackage.haskell.org/package/logging
21:34:25 <johnw> I wrote it mainly for the purpose you're describing
21:34:38 <johnw> i.e., "just let me log, mk?"
21:35:45 <solatis> there are many, many different logging libraries out there
21:36:00 <solatis> i think monad-logger and fastlogger are two of the more popular logging libraries
21:36:06 <johnw> logging is based on fast-logger
21:36:14 <solatis> right
21:36:28 <johnw> it just wraps a nicer UI around it
21:36:36 <solatis> looking at it now
21:36:44 <johnw> i'm working on a much simpler v2.0 btw
21:36:49 <johnw> which is on github
21:37:10 <johnw> in which I drop the monad-logger dependency, since it wasn't buying anything
21:37:16 <solatis> yeah i would miss the templatehaskell functions that automagically log filename and line #
21:37:35 <dmj`> johnw: very nice, is there support for apache-style formatting? I didn't see that in either the fast-logger or monad-logger. 
21:38:10 <solatis> dmj`: i feel like you're looking for something that resembles log4j ?
21:38:11 <johnw> I believe you just setLogFormat or something with logging
21:38:36 <adarqui> linearscan looks nuts
21:38:43 <adarqui> in a good way
21:38:52 <johnw> adarqui: oh, thanks!  that's what I'm working on at this moment
21:38:56 <kristof> Did Haskell's compiler needed special support for higher-kinded types?
21:39:48 <kristof> Ugh, the grammar in that sentence. But in any case, would it not just arise quite naturally after including generics and typeclasses? I'm only asking because Rust is lacking HKTs, despite considering itself a descendant of ML.
21:39:51 <solatis> "The linearscan library is an implementation -- in Coq, extracted to Haskell -- of a register allocation algorithm developed by Christian Wimmer" -- what does that even mean /
21:40:15 <johnw> it's a linear scan register allocator, written in Coq, extracted as a Haskell library for use in Haskell programs
21:40:16 <solatis> is it like a heap ?
21:40:54 <johnw> if you ever build intermediate representations from abstract syntax trees, in order to generate assembly code, you'll need to allocate registers (unless you use a higher level IR like LLVM)
21:40:58 <dmj`> kristof: did ML have higher kinded types? I don't think OCaml does...
21:41:15 <adarqui> solatis: regarding the Coq part.. you can write code in coq and have it output haskell/ocaml code
21:41:16 <solatis> johnw: ahhh right
21:41:23 <dmj`> kristof: ML never got those :/
21:41:40 <johnw> I'm using Coq to ultimately make this library both bug free, and provably so
21:41:57 <solatis> adarqui: didn't know, probably the safest way to generate haskell code!
21:42:01 <kristof> dmj`: It doesn't. But I consider Haskell to be a legitimate descendant of ML, and a lot of the Rust developers are big fans of this langauge.
21:42:16 <solatis> i think Coq is scary
21:42:19 <kristof> I suppose I'm wondering why, at a type inference level, HKTs are hard.
21:42:42 <roboguy_> kristof: I thought it was the checking itself, not the inference
21:43:18 <small-wolf> solatis: I've been trying to work my way throught software foundations, but keep getting stuck on mundane tasks like importing modules in other files.
21:43:19 <kristof> That one, then. :)
21:43:22 <johnw> adarqui: this past week I wrote an allocation verifier, to double-check that the allocations make complete sense for the final program.  It found three major (and highly subtle) bugs right away.  Then I used theorems to eliminate the possibility of those types of bugs in future.
21:43:24 <adarqui> johnw, ever plan to push coq-pipes?
21:43:35 <johnw> adarqui: yes, it will be pushed this month
21:43:37 <adarqui> johnw, dope!
21:43:37 <adarqui> nice
21:44:04 <roboguy_> hmm coq-pipes... That wouldn't be a good way to learn Coq coming from Haskell would it?
21:44:04 <johnw> adarqui: did you see coq-haskell?
21:44:08 <solatis> small-wolf: haha yeah i've been battling a linking error in ghc for weeks now, feels so.. counter-productive
21:44:09 <adarqui> (btw i don't know coq, looked into it a few times) .. would really be cool to look at haskell pipes & coq-pipes
21:44:14 <johnw> roboguy_: uh, no, not at all
21:44:35 <johnw> roboguy_: you'd want to start with Software Foundations (http://www.cis.upenn.edu/~bcpierce/sf/current/index.html)
21:44:38 <roboguy_> haha, didn't think it would be
21:45:06 <johnw> coq-pipes is a very faithful and direct translation of Haskell's pipes (v4.1.5) into Coq, proving every one of the pipes laws
21:45:52 <adarqui> johnw, everything in his laws.md ?
21:45:58 <johnw> only a few functions from Pipes.Prelude are missing, because supporting them will require retrofitting universe polymorphism into coq-haskell, and I just haven't sat down to do it yet
21:46:03 <johnw> adarqui: yes, all of those, and several more
21:46:37 <adarqui> sick! i always wondered how he verified those btw?
21:46:43 <johnw> he did it by hand, and he was right
21:47:03 <johnw> I think he could only verify by double-checking
21:48:53 <yayfoxes> ok, how would you prove that sum [x] = x for any number x?
21:49:33 <johnw> adarqui: coq-pipes has been pushed
21:49:47 <johnw> yayfoxes: you mean, in Coq?
21:50:16 <yayfoxes> johnw: no, in Haskell and i've never studied mathematical proofs
21:50:31 <Axman6> by showing that sum x = x + sum [] = x + 0 = x?
21:50:41 <Axman6> (assuming law abiding (+)
21:50:47 <zedbourbaki> can we talk more about Coq ? I just learned its existence today and I want to know all there is to know about it
21:50:52 <Axman6> uh, sum [x] = ...
21:50:52 <adarqui> johnw, awesome!
21:50:53 <johnw> zedbourbaki: ask in #coq
21:50:59 <yayfoxes> Axman6: then I'm needing to study tons of math
21:51:01 <zedbourbaki> johnw: of course -_-
21:51:04 <johnw> hi
21:51:06 <adarqui> that software foundations book is on my reading list, hope to get to it sooner than later
21:51:20 <Axman6> yayfoxes: did that look like tonnes of maths to you? it sure didn't to me...
21:51:40 <yayfoxes> sum [] = 0
21:52:06 <scutigera> 2000 kg = 2*10*10*10; there 2 tonnes of math
21:52:06 <yayfoxes> sum (x:xs) = x + sum xs
21:52:08 <roboguy_> I need to learn Coq at some point. I'm working on a proof assistant-type system for my job and I'm curious how the two compare
21:52:15 <yayfoxes> is that simple enough?
21:52:16 <Axman6> proofs by induction are pretty mechanical (which is why languages like Coq exist, to make the mechanical steps automatic)
21:52:25 <johnw> roboguy_: which system?
21:52:29 <roboguy_> johnw: HERMIT
21:52:43 <Axman6> yayfoxes: that's the definition of sum, yes
21:52:44 <johnw> yayfoxes: that proof in Coq is just "induction x; auto" pretty much
21:52:49 <scutigera> roboguy_: you work on a proof assistant-type system FOR A PAYCHECK ?! do tell...
21:53:00 <adarqui> "So in all it took 1.5 years to learn Coq well enough and to find the right abstraction, and 2 weeks to do the actual work."
21:53:03 <adarqui> nice
21:53:13 <roboguy_> scutigera: ha, yep! livin the dream
21:53:15 <johnw> :)
21:53:26 <scutigera> adarqui: so i'm unclear- was that a win ?
21:53:43 <yayfoxes> Axman6: maybe i couldn't prove it cause i didn't have the definition of sum
21:53:53 <roboguy_> (in particular, I'm on a team developing a new and improved shell for HERMIT)
21:54:07 <adarqui> 2 weeks of work to actually prove all of the laws in the pipes library? sounds like it for sure
21:54:11 <scutigera> roboguy_: i'd be impressed if i knew what HERMIT was ;-)
21:54:21 <Axman6> yayfoxes: well, without the definition it's impossible, it's a black box thnat could do anything*
21:54:41 * Axman6 * parametricity makes the box a lot less black though
21:54:44 <zedbourbaki> johnw: #coq is ... silent...
21:54:45 <scutigera> adarqui: yeah- but you can't really skip the 1.5 years of learning Coq, can you ? 
21:54:53 <yayfoxes> Axman6: so then I never had the definition so couldn't solve it
21:55:00 <zedbourbaki> we live in a fabulous era
21:55:18 <dmj`> roboguy_: are you working with xich?
21:55:49 <johnw> scutigera: no, you really can't
21:55:49 <scutigera> meanwhile - i struggle with the same attoparsec program i've been working on for two weeks. and all it does is read 3 different kinds of lines...lol
21:55:52 <roboguy_> dmj`: yep!
21:55:59 <adarqui> scutigera: of course.. but how far do most haskellers get in 1.5 years? with coq, 1.5 years isn't that long i imagine..
21:56:18 <roboguy_> scutigera: this is from a while ago, but the general idea still is the same http://www.ittc.ku.edu/csdlblog/?p=105
21:56:19 <scutigera> adarqui: excellent point- i know i haven't gotten that far. lol.
21:56:25 <adarqui> scutigera: same :)
21:56:29 <dmj`> roboguy_: are you in Kansas?
21:56:38 <roboguy_> dmj`: yeah
21:57:18 <scutigera> roboguy_: oh my... nerdgasm!
21:57:20 <roboguy_> Kansas apparently has more Haskell activity than you might think
21:57:26 <dmj`> roboguy_: how close to kansas city are you?
21:57:38 <zedbourbaki> johnw: i don't know what to ask, to be honest... i'm just busy being flabbergasted.
21:57:38 <scutigera> uh- yeah i'm thinking there's zero. so any would be a lot.
21:57:49 <Axman6> I assume Kansas Lava comes from Kansas...
21:58:06 <Axman6> @google kansas lava
21:58:07 <lambdabot> https://hackage.haskell.org/package/kansas-lava
21:58:08 <scutigera> nope. comes from Sumatra. tricky, eh ?
21:58:11 <zedbourbaki> ok well... do you know of any math problem with non-theoritical applications that was solved by coq
21:58:36 <roboguy_> dmj`: fairly close. KU is in Lawrence
21:58:53 <dramforever> zedbourbaki: compsert I guess
21:59:13 <dramforever> compcert, certified C compiler
21:59:18 <roboguy_> Axman6: It does. Me and one of my coworkers were just talking about it earlier, briefly
21:59:23 <dramforever> althought I don't know if that's "solved by coq"
21:59:26 <joeyh> can optparse-applicative be used to parse exclusive options? Ie, data Foo = Foo | Bar parsed from --foo and --bar.
21:59:27 <roboguy_> same place as HERMIT, actually
21:59:34 <Axman6> seL4 wasn't proved in Coqw, but it was proived in Isaballe/HOL
21:59:54 <roboguy_> dmj`: why do you ask?
22:00:24 <dmj`> roboguy_: I work for a startup based out of Grandview, KC, writing their backend in haskell
22:00:31 <dmj`> like 50 mins away
22:00:51 * dmj` starts singing 'its a small world after all'
22:00:54 <roboguy_> dmj`: very cool!
22:01:31 <dmj`> roboguy_: they have google fiber, it's pretty fast
22:01:51 <dmj`> Grandview, MO :P
22:02:08 <roboguy_> nice! I wish they'd bring google fiber a little further out this way
22:05:08 * dramforever finds himself wanting <* in c++...
22:05:39 <dramforever> that greatly simplifies things like q.front() <* q.pop()
22:05:41 <orion> If a library provides me with a function defaultFoo, and setters setBar x, setBaz y, etc, what's the cleanest way to execute a series of these setters?
22:06:15 <dramforever> setFoo newFoo . setBar newBar $ defaultFoo
22:06:22 <dramforever> like that?
22:07:06 <orion> hmm
22:09:04 <orion> dramforever: I suppose that works.
22:16:43 <dmj`> roboguy_: next time I'm down there we should meet up
22:18:15 <zedbourbaki> dramforever: sorry I was away - you are talking about compcert ?
22:18:32 <dramforever> I don't know much about it
22:18:53 <zedbourbaki> ok : )
22:19:02 <zedbourbaki> well you probably know more about it than I do  :)
22:32:15 <johnw> http://compcert.inria.fr/compcert-C.html
22:41:24 <gfixler> johnw: ah, I remember a friend talking about this
22:54:40 * hackagebot pipes-parse 3.0.3 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-3.0.3 (GabrielGonzalez)
23:11:00 <zipper> Hey I'm trying to compile some code on windows but the preprocessor complains that it can't find HsUnix.h
23:11:27 <zipper> I looked into this and discovered that this file is proivided by unix package
23:11:43 <zipper> I am however using unix-compat. Why am I getting this issue?
23:26:03 <ion> Haskell, take heed: https://pbs.twimg.com/media/CJanIM9UAAAEOLg.jpg:large
23:26:38 <MarcelineVQ> :>
23:29:41 * hackagebot linear 1.19 - Linear Algebra  http://hackage.haskell.org/package/linear-1.19 (EdwardKmett)
23:30:50 <gfixler> any advice on cleaning this up? http://lpaste.net/136083
23:31:06 <gfixler> I feel like I can use >>= somewhere, but not seeing it
23:31:16 <gfixler> i.e. bind on the IO or Maybe bits
23:36:52 <orion> If you're working within a Monad transformer stack supplied by a library and they define their own instance of liftIO which automatically catches exceptions, is it possible to perform IO actions from within that Monad, but in such a way where you skip their error handler?
23:37:55 <johnw> gfixler: your MaybeIO is MaybeT IO
23:38:24 <gfixler> johnw: jle` gave me this as a learning example
23:38:41 <gfixler> he just gave me the newtype and told me to make a Monad instance for it
23:38:47 <johnw> ah
23:39:22 <gfixler> and both he and maybe merijn mentioned that after = MaybeIO I could use do/>>= etc
23:39:28 <gfixler> but I'm not using >>=
23:39:30 <jle`> people like to use record accessors instead of pattern matching sometimes
23:40:00 <jle`> if you had newtype MaybeIO a = MaybeIO { runMaybeIO :: IO (Maybe a) }, then you could do something like
23:40:38 <jle`> x >>= f = MaybeIO $ do y <- runMaybeIO x; case y of Just z -> runMaybeIO (f z); Nothing -> return Nothing
23:40:51 <jle`> but it's not universally considered better
23:41:01 <gfixler> yeah, that's a bit rough :)
23:41:24 <jle`> if you wanted to use >>= all the way, you'd do x >>= k = MaybeIO $ x >>= \y -> case y of ...
23:41:27 <gfixler> I was trying to do x >>= fmap (fmap k) or similar, but k shoots the thing 3 levels back up to MaybeIO b
23:41:31 <jle`> but do notation is nice here i think
23:41:49 <gfixler> jle`: so what I wrote isn't too bad?
23:42:10 * gfixler seeks comforting words in this time of struggle
23:42:13 <jle`> yeah it's pretty standard :)
23:42:18 <gfixler> okay
23:42:23 <jle`> let's see how transformers writes it
23:42:29 <gfixler> we were looking for things to demo at our haskell meetup tomorrow
23:42:44 <gfixler> and this gave me a great opportunity to play with hole-driven haskell stuffs
23:42:52 <dripping_nut> SICP is the worst "introductory" book I've ever read in my life.
23:42:53 <jle`> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Maybe.html#line-113
23:43:02 <gfixler> figured I could show how even though I was a bit confused about MaybeIO, holes helped me find an okay implementation
23:43:02 <jle`> gfixler: they literally more or less did exactly the same thing as you
23:43:09 <jle`> except they used runMaybeT instead of pttern matching
23:43:17 <jle`> and they switched the ordering of the case statement branches, heh
23:43:18 <gfixler> sweet
23:43:23 <gfixler> holes ftw
23:43:43 <jle`> i guess they did what i typed, but pattern matching is just as nice
23:43:46 <gfixler> I also made a mapping in Vim so I can just whack Enter from normal mode, and it :r's the other tmux pane
23:44:02 <jle`> with record accessors you can get rid of the let ... in ... i guess
23:44:08 <jle`> gfixler: have you looked at slime?
23:44:13 <gfixler> jle`: yep
23:44:27 <jle`> i guess it's a bit of a different thing
23:44:37 <jle`> oh, how did you get vim to talk to tmux's other pane?
23:44:47 <gfixler> jle`: yeah, I was actually using vim2hs
23:45:01 <gfixler> jle`: :nnoremap <CR> :w<CR>:silent !tmux send-keys -t 1.1 :r Enter<CR><C-l>
23:45:11 <gfixler> nothing fancy - just a straight shell call to tmux send-keys
23:45:14 <jle`> oh haha
23:45:18 <gfixler> :)
23:45:24 <jle`> nice :)
23:45:31 <gfixler> Enter<CR<C-l> was fun to figure out
23:45:35 <gfixler> <CR>*
23:45:39 <jle`> i think the Alternative instance is one of the nicest things about MaybeT
23:45:56 <gfixler> :rEnter sends :rEnter, :r Enter sends :r and a carriage return
23:46:00 <jle`> so if you wanted to demonstrate cool things, you can write the Alternative instance and show how to do a monadic "find"/execute until the first Just thing
23:46:07 <gfixler> jle`: you were saying I should implement Alternative
23:46:08 <jle`> ah, i remember my vim hacking days heh
23:46:22 <gfixler> jle`: emacs these days?
23:46:29 <jle`> no, just vim, but no hacking
23:46:42 <jle`> if i tried to do anything i'd probably have to re-learn everything haha
23:46:56 <gfixler> jle`: ah - I really appreciate emacs, but in all but one case, online or off, I completely crush the efficiency and fluidity of all contenders in Vim
23:47:27 <gfixler> and that one case was Emacs Rocks - that guy is amazing, but it sounds like an entire mining crew on his keyboard to get emacs going that fast
23:47:41 <jle`> but yeah, it's nice cause asum :: [f a] -> f a, or asum [x,y,z] = x <|> y <|> z, so compare asum :: [Maybe a] -> Maybe a vs. asum :: [IO (Maybe a)] -> IO (Maybe a)...it's nice that it's fundamentally "the same thing", but "lifted" to IO
23:48:02 <gfixler> asum?
23:48:04 <jle`> i do appreciate emacs and i can understand why people use it
23:48:07 <gfixler> asummetrical?
23:48:16 <gfixler> asumptote?
23:48:18 <jle`> asum [x,y,z] = x <|> y <|> z <|> empty, basically
23:48:22 <jle`> Alternative sum
23:48:26 <gfixler> ah
23:49:09 <jle`> so you can do a find that is like [Maybe a] -> Maybe a, or maybe you want a [IO (Maybe a)] -> IO (Maybe a) that stops executing/sequencing IO actions after the first Just result
23:49:25 <jle`> all you need to do is write an Alternative instance for IO . Maybe that has that behavior
23:49:32 <hvr> jle`: so 'asum' is what parser combinators often call 'choice'?
23:49:45 <jle`> the high-level idea/"pattern" is the same thing between both types
23:49:50 <jle`> hvr: yeah, i believe so
23:49:59 <jle`> it's also called msum too, for historical reasons
23:50:14 <hvr> yeah... the MonadPlus <-> Alternative thingie
23:50:34 <jle`> yeah, msum = foldr mplus mempty
23:50:38 <jle`> asum = foldr (<|>) empty
23:50:57 <jle`> yay history
23:51:30 <jle`> but yeah, Alternative gives you a nice way of abstracting "chosing over a bunch of options", so MaybeT lets you apply that general abstraction/pattern to selective/short-circuiting IO
23:52:00 <gfixler> "Things We Wish We Could Change in Haskell" tonight on The History Channel, 8pm, 7 central
23:52:13 <jle`> you can also do [IO (Maybe a)] -> IO (Maybe [a]), which is sequenceA/sequence
23:52:28 <jle`> execute the results until you get a Nothing, then stop and just pop out Nothing
23:52:35 <gfixler> jle`: sequence is what the type resolved to for me first
23:52:44 <jle`> so with asum you get "execute the results until you get a Just (success)"
23:52:52 <jle`> and sequence you get "execute the results until you get a Nothing (failure)"
23:52:59 <gfixler> ah, so asum is not find
23:53:10 <jle`> asum is find here, ain't it?
23:53:18 <gfixler> is it?
23:53:20 <jle`> > asum [Nothing, Nothing, Nothing, Just 3, Nothing]
23:53:21 <lambdabot>      Not in scope: ‘asum’
23:53:22 <lambdabot>      Perhaps you meant one of these:
23:53:22 <lambdabot>        ‘F.asum’ (imported from Data.Foldable),
23:53:22 <fosterite> dripping_nut: what introductory book have you read that didn't do an awful job
23:53:28 <jle`> > F.asum [Nothing, Nothing, Nothing, Just 3, Nothing]
23:53:29 <lambdabot>  Just 3
23:53:32 <jle`> "find the first Just"
23:53:47 <gfixler> jle`: the executing bit threw me
23:53:49 <jle`> > sequence [Nothing, Nothing, Nothing, Just 3, Nothing]
23:53:50 <lambdabot>  Nothing
23:53:55 <jle`> "quit as soon as you see failure"
23:54:16 <gfixler> :t F.asum
23:54:17 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
23:54:39 <gfixler> hmm, Foldable
23:54:45 * Xebia
23:54:48 <johnw> gfixler: MaybeIO x >>= k = MaybeIO $ fmap join (x >>= traverse (runMaybeIO . k))
23:54:50 <jle`> it's just foldr (<|>) empty, heh
23:55:15 <gfixler> johnw: nice! You're jumping ahead a few chapters on me :)
23:55:24 <johnw> it's not very understandable either
23:55:28 <johnw> what you wrote is arguably better
23:55:33 <gfixler> I'll argue that
23:55:34 <jle`> johnw: i just did a library that abstracted out that behavior to let you do a monad transformer on an arbitrary Traversable, heh
23:55:39 <jle`> but i am sure the instances aren't lawful
23:56:00 <jle`> newtype TraversableT t m a = TraversableT { runTraversableT :: m (t a) }
23:56:01 <dripping_nut> fosterite: SICP is especially god awful, though. i can see that, at minimum, 25% of the ill-sourced praise this book garners derives from people who think that anything from MIT = automatic gold standard.
23:56:05 <gfixler> johnw: one of the sadder things about my Haskell journey is looking back at what I understand now, but can't use, because I'd have to explain it to everyone
23:56:08 <jle`> with a Monad instance exactly like you wrote
23:56:20 <johnw> jle`: that's funny, I worked on TraversableT too
23:56:34 <jle`> oh good thing you tell me before i put too much work into refining it
23:56:36 <mniip> so did I
23:56:44 <mniip> I also had a DistributiveT
23:56:48 <jle`> what became of it?
23:56:48 <fosterite> I would attribute it to SICP's exercises, lack of fluff, and treatment of recursion
23:56:53 <jle`> is it anywhere on hackage?
23:56:55 <gfixler> did everyone but me work on this?
23:56:56 <mniip> no
23:57:01 <mniip> it's a 50-line file
23:57:15 <johnw> jle`: it was just noted; I was trying to do t (m a)
23:57:20 <johnw> just notes*
23:57:29 <mniip> johnw, t (m a) is distributive
23:57:42 <mniip> jle`, I'm still looking for a generic structure to represent State
23:57:43 <johnw> yes, I arrived at that
23:57:46 <jle`> mine is 67 lines, but i think the real winners were the Alternative and MonadError instances
23:57:54 <jle`> MonadError instance is useful
23:58:02 <johnw> jle`: send me your code, and I'll try to prove the laws
23:58:19 <johnw> that's what my coq-haskell library is for
23:58:37 <jle`> https://github.com/mstksg/traversablet/blob/master/src/Control/Monad/TraversableT.hs
23:58:43 <jle`> i feel like it fails for t ~ []
23:58:47 <jle`> but that's just intuition
23:58:53 <gfixler> oh, good, I can ask that question now
23:58:55 <johnw> i'll try to prove it for all instances
23:58:58 <gfixler> ~ - is that "implies"?
23:59:03 <johnw> it's type equality
23:59:22 <mniip> jle`, it does
23:59:25 <jle`> yeah, i read it as "t being []", or "when you put in [] for t", informally
23:59:26 <mniip> because ListT isn't real
23:59:29 <gfixler> "fails for t ~ []" == "fails when t is []" ?
23:59:34 <gfixler> ah
23:59:38 <gfixler> johnw: thanks!
23:59:50 <jle`> yeah, it's basically a fancy way of saying t = []
23:59:54 <gfixler> I've had that in errors a number of times now, and have been forgetting to ask
