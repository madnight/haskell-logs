00:06:06 <ttt_fff> benzrf: how's hspreadsheet coming along?
00:08:40 <ttt_fff> who of you wrote https://github.com/begriffs/postgrest/tree/master/src/PostgREST ?
00:08:42 <ttt_fff> this looks badass
00:19:50 <lamefun> I can't put "{-# LANGUAGE .. #-}" after "module XYZ (..) where"?
00:21:22 <lamefun> I put "{-# LANGUAGE OverloadedStrings #-}" after "module .. where" and got lots of "[Char]" vs "Text" mismatches, putting the OverloadedStrings declaration before the module declaration fixed it. 
00:21:53 <lamefun> Why did it give me type errors instead of an earlier eg. "misplaced LANGUAGE" error?
00:27:20 <alpounet> Ryanar: hi, just saw your servant question from a couple of hours ago. don't know if you got an answer but it's not crazy
00:28:07 <alpounet> Ryanar: you'd have to write a tiny little glue package for tying servant and shakespeare together
00:45:04 * hackagebot debian-build 0.7.2.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.7.2.0 (KeiHibino)
00:47:57 <cdsmith> I've forgotten how to reinterpret a Double as an Int (throwing away excess bits), and I am having trouble finding it again.  Anyone know off-hand where that function lives?
00:50:04 * hackagebot aivika 4.3 - A multi-paradigm simulation library  https://hackage.haskell.org/package/aivika-4.3 (DavidSorokin)
00:54:43 <Cale> cdsmith: There are a bunch of things in the Prelude which will work. round, ceiling, floor, truncate
00:55:04 * hackagebot aivika-experiment-chart 4.3 - Simulation experiments with charting for the Aivika library  https://hackage.haskell.org/package/aivika-experiment-chart-4.3 (DavidSorokin)
00:55:06 * hackagebot debian-build 0.7.2.1 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.7.2.1 (KeiHibino)
00:55:22 <Cale> cdsmith: (depending on what behaviour you want)
00:55:53 <Cale> cdsmith: Or perhaps you mean something else by "reinterpret"
00:56:10 <Cale> There's decodeFloat
00:56:51 <cdsmith> Cale: I meant that I want the low-order 32 bits of the IEEE floating point representation.
00:57:03 <Cale> ah
00:57:04 <cdsmith> But decodeFloat might be good enough.
00:57:16 <Cale> decodeFloat gives you the mantissa and exponent separately
00:57:26 <cdsmith> Thanks
01:16:54 <Wizek> With Criterion, if I have `nf function (lotsOfComputation argument)`, does the computation of the argument contribute to the benchmark?
01:21:05 <Fuuzetsu> can I pass a cpphs option using a module pragma?
01:22:42 <bergmark> Fuuzetsu: i think {-# OPTIONS -pgmP foo #-} will work
01:23:40 <Fuuzetsu> yeah, just found that, will try
01:23:57 <Fuuzetsu> OPTIONS_GHC or GHC_OPTIONS or whatever it is, right?
01:24:04 <bergmark> Fuuzetsu: both work
01:24:14 <Fuuzetsu> o
01:24:27 <bergmark> oh i mean, OPTIONS, and OPTIONS_GHC both work
01:24:30 <Fuuzetsu> yeah
01:40:51 <hackrilege> hi gang
01:41:28 <hackrilege> so someone was talking about frp the other day so i thought id pop by to ask what is the correct way to represent a listener in haskell...
01:42:29 <forgottenone> which one would be faster and w: sum.digitToInt.show or digitalSum 0 k = k; digitalSum n k = digitalSum n//k 
01:43:27 <forgottenone> which one would be faster and why: sum.digitToInt.show or digitalSum 0 k = k; digitalSum n k = digitalSum n `quot` 10  k + (n `rem` 10) ? (sorry for previous message i accedantly pressed enter)
01:43:27 <hackrilege> forgottenone, is digitToInt not defined in the same way as (\\)?
01:44:24 <nkaretnikov> I need to define two indexes for the same data set, is there a suitable data structure for that?
01:44:28 <forgottenone> hackrilege: sorry,i accidently pressed enter, second message is the correct code
01:44:30 <hackrilege> how is digitToInt defined?
01:44:42 <forgottenone> hackrilege: it's in data.char module
01:44:59 <hackrilege> so is your definition not equivilent?
01:45:31 <forgottenone> hackrilege: i dont understand what do you mean
01:45:36 <hackrilege> also i dont see sum composing well with digit to int!
01:45:49 <hackrilege> :t sum.digitToInt
01:45:50 <lambdabot>     Couldn't match type ‘Int’ with ‘t0 c’
01:45:50 <lambdabot>     Expected type: Char -> t0 c
01:45:50 <lambdabot>       Actual type: Char -> Int
01:46:09 <hackrilege> so i dont think yours is a clear question
01:46:40 <forgottenone> sorry you're right: that's the working version :sumOfDigits  = foldr ((+).digitToInt) 0 . show
01:47:15 <hackrilege> > (foldr ((+).digitToInt) 0 . show) "12"
01:47:16 <lambdabot>  *Exception: Char.digitToInt: not a digit '"'
01:47:49 <forgottenone>  (foldr ((+).digitToInt) 0 . show)  12
01:48:05 <hackrilege> oh sorry
01:48:05 <forgottenone>  > (foldr ((+).digitToInt) 0 . show)  12
01:48:14 <forgottenone> btw how we use lambdabot
01:48:30 <hackrilege> no clue
01:48:31 <hackrilege> > (foldr ((+).digitToInt) 0 . show)  12
01:48:32 <lambdabot>  3
01:48:43 <hackrilege> you had a leading ' ' 
01:48:56 <forgottenone>  >(foldr ((+).digitToInt) 0 . show)  12
01:48:59 <forgottenone> >(foldr ((+).digitToInt) 0 . show)  12
01:49:12 <forgottenone>  > (foldr ((+).digitToInt) 0 . show)  12
01:49:16 <hackrilege> > (foldr ((+).digitToInt) 0 . show)  "12"
01:49:18 <lambdabot>  *Exception: Char.digitToInt: not a digit '"'
01:49:23 <hackrilege> > (foldr ((+).digitToInt) 0)  "12"
01:49:24 <lambdabot>  3
01:49:56 <hackrilege> > let digitalSum 0 k = k
01:49:57 <forgottenone> > (foldr ((+).digitToInt) 0 . show)  12
01:49:57 <lambdabot>  <no location info>: not an expression: ‘let digitalSum 0 k = k’
01:49:58 <lambdabot>  <no location info>: can't find file: L.hs
01:50:09 <hackrilege> > let digitalSum 0 k = k in
01:50:10 <lambdabot>  <hint>:1:1:
01:50:10 <lambdabot>      parse error in let binding: missing expression after 'in'
01:50:27 <hackrilege> :set digitalSum 0 k = k in
01:50:27 <hackrilege> :set digitalSum 0 k = k 
01:50:41 <hackrilege> > digitalSum 0 a
01:50:43 <lambdabot>  Not in scope: ‘digitalSum’
01:50:48 <hackrilege> damn
01:51:01 <chamo> hi all
01:51:08 <hackrilege> sup?
01:51:35 <hackrilege> https://wiki.haskell.org/Lambdabot
01:51:49 <int-e> that wiki page needs some love :/
01:52:10 <hackrilege> @let digitalSum 0 k = k 
01:52:12 <lambdabot>  Defined.
01:52:20 <hackrilege> > digitalSum 0 "a"
01:52:22 <lambdabot>  "a"
01:52:36 <hackrilege> @let digitalSum n k = digitalSum n `quot` 10  k + (n `rem` 10)
01:52:37 <lambdabot>  .L.hs:151:18:
01:52:37 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
01:52:37 <lambdabot>      Relevant bindings include
01:52:52 <hackrilege> digitalSum "12"
01:53:03 <hackrilege> digitalSum 12
01:53:36 <hackrilege> @let digitalSum n k = digitalSum (n `quot` 10)  (k + (n `rem` 10))
01:53:37 <lambdabot>  Defined.
01:53:42 <hackrilege> digitalSum 12
01:53:51 <int-e> > digitalSum 12 0
01:53:52 <lambdabot>  3
01:54:11 <hackrilege> thanks
01:54:38 <hackrilege> forgottenone: are you still here?
01:54:42 <forgottenone> yep
01:54:54 <hackrilege> cool
01:55:02 <hackrilege> yeh i have no idea which one is faster
01:55:50 <forgottenone> ok  :) still thanks
01:56:09 <hackrilege> (foldr ((+).digitToInt) 0 . show) i think looks faster
01:56:56 <hackrilege> as foldr1 (+) numbers does fewer calls to quot and rem...
01:57:08 <hackrilege> ie none
01:57:30 <forgottenone> but there is still the cost of converting Integer to String
01:57:44 <hackrilege> a small lookup table
01:57:50 <hackrilege> size of char
01:58:50 <hackrilege> probably larger than 10 though... i dont know how many computations is in quot and rem, it should be a few for large numbers, and the string kind of implicity contains the information of base 10...
01:59:30 <hackrilege> applying the opperation of a list of 1000 elements is going to certainly show you which is faster
01:59:42 <hackrilege> i dont think the string parse would struggle at all
02:00:45 <forgottenone> i see
02:01:25 <hackrilege> ok, so you have an addition in each itteration, i dont see that in the string version either
02:01:54 <forgottenone> hackrilege: but foldr does that implicitly
02:02:12 <hackrilege> o i didnt see it because im blind.
02:02:38 <hackrilege> so, is the lookup table faster than one quot and one rem, i guess is your question? i have no clue, benchmark?
02:03:10 <hackrilege> so does anyone know anything about functional reactive programming? 
02:05:02 <hackrilege> :forgottenone, perhaps the implementation of digitToInt will help you see how the lookup is performed, maybe it is an iterator or something that is obviously less fast than quot or rem 
02:05:07 * hackagebot fay 0.23.1.8 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.8 (AdamBergmark)
02:05:36 <hackrilege> im trying to get an action to listen for user input, can we do this in haskell?
02:07:03 <hackrilege> anyone here?
02:07:12 <forgottenone> hackrilege:  it uses ord function implicitly but what i wonder is show vs quot and rem then digitToInt vs quot vs rem
02:08:04 <Akshay_> hackrilege, no
02:09:15 <eikke> is there any mechanism to ensure a (runtime-calculated) large vector/lookup table won't ever be GC'ed and need to be recalculated?
02:10:08 * hackagebot eprocess 1.7.2 - Basic Erlang-like process support for Haskell  https://hackage.haskell.org/package/eprocess-1.7.2 (CorentinDupont)
02:14:20 <guest32456> sorry i got disconnected
02:15:01 <guest32456> yeh so i think probably show performs quot and rem, so perhaps your definition is equivalent 
02:16:15 <guest32456> how can i implement listener::IO () so that speaker :: IO () can interact with it?
02:16:55 <guest32456> do i have to open a websocket!?
02:17:57 <kuribas> Can you specify ghc command line parameters for a splicific module in a cabal package?
02:18:06 <kuribas> For example to use your own literate preprocessor?
02:19:35 <guest32456> splicific...
02:20:08 * hackagebot haskell-neo4j-client 0.3.1.3 - A Haskell neo4j client  https://hackage.haskell.org/package/haskell-neo4j-client-0.3.1.3 (asilvestre)
02:20:30 <guest32456> yes i think maybe you can 
02:20:57 <guest32456> there should be a specification of all flags used in copilation
02:21:08 <ttt_fff> every day, I fall deeper and deeper in love with Haskell
02:21:19 <guest32456> ttt_fff: helf me
02:21:31 <ttt_fff> what do you need?
02:21:37 <guest32456> a listener
02:21:40 <kuribas> Also, is haddock markup part of code in a .lhs file?
02:21:54 <kuribas> like: > -- | haddock markup here
02:21:59 <ttt_fff> is it a technical problem?
02:22:07 <guest32456> frp
02:22:15 <ttt_fff> http://sol.gfxile.net/dontask.html
02:22:18 <kuribas> guest32456: I am listening :)
02:22:23 <ttt_fff> oh, Functional Reactive Programming?
02:22:27 <guest32456> how do we get a listener in haskell?
02:24:14 <kuribas> guest32456: I know you can specify flags, but can you do it on a per module basis?
02:25:16 <guest32456> i would like to know if it is possible for two IO opperations to interact with each other? i can imagine one could speak to another through a websocket, but perhaps there is a way to do it with streams? maybe this is what frp is in essence, and i wondered if there were any nice examples of listeners in frp?
02:25:56 <kuribas> guest32456: Yes, sure you can.
02:26:05 <guest32456> kuribas: do you know which file you have to look in to find the flags? maybe there will be some module specific ones and you could see the syntax...
02:26:34 <guest32456> personally i dont know how you would do that, other than you can edit the source and enter little {-# #-} braces...
02:27:05 <kuribas> I don't know if you can specify ghc parameters as pragmas...
02:27:16 <guest32456> oh sorry
02:27:47 <guest32456> i really cant help im afraid 
02:29:06 <guest32456> could anyone give me a simple exaple of two IO opperations that could interact with each other without opening a web socket or writing to a file or using streams? is functional reactive programina a way to achieve this?
02:30:11 <kuribas> guest32456: In reactive banana for example you can use an AddHandler to run an IO action when an event occurs.
02:30:20 <ttt_fff> is RWST better than ReaderT StateT WriterT ?
02:30:32 <guest32456> im sorry, i find it very confusing.. perhaps i am asking for a function of type IO (IO a -> IO ())
02:31:05 <guest32456> thanks kuribas, ill check out that function now
02:31:15 <kuribas> guest32456: and reactimate to turn fire an event.
02:31:25 <guest32456> ooo!
02:31:33 <kuribas> guest32456: Depending on the problem, you could also use pipes or conduits.
02:31:48 <guest32456> yes i think maybe those sound good too
02:31:49 <kuribas> https://hackage.haskell.org/package/pipes
02:31:57 <guest32456> omg thanks you!
02:32:01 <ttt_fff> wny is #haskell so quiet
02:32:09 <kuribas> https://hackage.haskell.org/package/conduit
02:32:13 <kuribas> it's early I guess.
02:32:59 <guest32456> so im correct in that functional programing concerns itself with this kind of thing?
02:33:32 <guest32456> and if so, and we can use streams, what does frp offer us?
02:34:14 <kuribas> guest32456: if you have several receivers of an event, or want to implement complex transformations on events, frp is better.
02:34:47 <guest32456> argh, conduit is snoyberg, i wont use it
02:35:00 <frerich> guest32456: I'm not sure I understand your original question. When you write 'a simple exaple of two IO opperations that could interact with each other without opening a web socket or writing to a file or using streams', do you mean that printing the number of words in a file counts as 'interaction' between two IO actions (read file, print output)?
02:35:05 <kuribas> If I am not mistaken, pipes have just one input and one output.
02:36:10 <guest32456> yes i could have one IO opperation that reads a file, and one that writes to it... one could then base its behaviour on the contents of that file, or stream.
02:37:14 <guest32456> i would like to say, create listener >>= makeDoStuff 
02:37:17 <kuribas> guest32456: My understanding was that he wants interaction between components without going through a socket.
02:37:24 <Cale> guest32456: Maybe you're just looking for IORef?
02:37:42 <Cale> guest32456: Or one of the other mutable reference types?
02:37:43 <guest32456> yes, but you addressed me...
02:38:14 <guest32456> IORef? ill check hang on thanks
02:38:15 <kuribas> right, I meant frerich...
02:39:09 <guest32456> opaque documentation.. i can edit them apparently
02:39:44 <frerich> kuribas: Yeah I guess I don't *quite* understand what's being asked. I'll shut up. :-)
02:40:16 <guest32456> nono, you were great, i have some strong streaming libraries now with pipes, and ill be sure to check out reactive bananna
02:40:50 <guest32456> IORef looks really really close to what im thinking here, thanks
02:41:00 <Cale> Yeah, it's just a simple mutable reference
02:41:47 <guest32456> and it can be of some crazy datatype that takes all kinds of inputs and does all kinds of awesome things i guess...
02:44:45 <guest32456> > newIORef id >>= ((\a->a 0).readIORef)
02:44:46 <lambdabot>      Not in scope: ‘newIORef’
02:44:46 <lambdabot>      Perhaps you meant ‘newSTRef’ (imported from Data.STRef)    Not in scope:...
02:44:46 <lambdabot>      Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
02:45:46 <guest32456> > Data.IORef.newIORef id >>= ((\a->a 0).Data.IORef.readIORef)
02:45:47 <lambdabot>      Not in scope: ‘Data.IORef.newIORef’
02:45:47 <lambdabot>      Perhaps you meant ‘Data.STRef.newSTRef’ (imported from Data.STRef)    No...
02:45:47 <lambdabot>      Perhaps you meant ‘Data.STRef.readSTRef’ (imported from Data.STRef)
02:46:08 <guest32456> ok sorry ill try this at home
02:46:16 <kuribas> I found it, there is an OPTIONS_GHC pragma.
02:46:54 <guest32456> sweeeet!!! was i actually slightly helpful? 
02:47:10 <kuribas> yes
02:47:37 <guest32456> is this really the conventional way to specify module specific compilation flags?
02:48:32 <kuribas> it's the only way I know of.
02:48:39 <guest32456> then it is good
02:51:46 <guest32456> with these new fangled io refs i can brute force a c emulator with malloc! woot!
02:52:44 <guest32456> and other misconceptions...
02:54:34 <guest32456> aha i think i understand my problem a bit more, is there something like getLine that i would use to accept input within a do block, which could be used to recieve the arguments of a function?
02:55:24 <guest32456> as if (do getLine>>return)::(IO Str -> IO ())
02:56:52 <kuribas> strong arguments pro copyleft: http://dustycloud.org/blog/why-i-am-pro-gpl/
02:57:09 <guest32456> i think i would like to apply an IO function, this should not be a problem...
02:57:19 <kuribas> I have the impression haskell programmers prefer BSD over GPL.
02:57:54 <guest32456> i should be able to say; createListener>>=talkToListener without bother...
02:58:26 <guest32456> am i really so confused this simple a solution...
02:58:49 <guest32456> i am disapointed in myself
02:59:09 <guest32456> i shall go and examine this in shame, thank you for your help fellas
03:00:01 <jle`> guest32456: no need to be disappointed in yourself ;_;
03:00:13 <kuribas> guest32456: everyone has to start somewhere.
03:00:32 <ttt_fff> with haskell, is it okay to do shitty/risky design instead of thinking things out
03:00:39 <ttt_fff> because, given the power of ghcs, its easy to refactor code?
03:01:07 <kuribas> ttt_fff: in my experience, when you have a shitty/risky design, it becomes very hard to implement it in the type system.
03:01:24 <wedens> I'm looking at aeson-better-errors https://hackage.haskell.org/package/aeson-better-errors-0.9.0/docs/Data-Aeson-BetterErrors.html#g:3 it uses 'key' function for lookup inside Object. for nested lookups syntax will be 'key "a" (key "b" (key "c" asString))'. how can I define operator for "key"? I want something like 'getValue ./ "a" ./ "b" ./ "c"'
03:01:35 <ttt_fff> so waht you're saying is that haskell is the good wingman that prevents you from talking to dangerous women?
03:01:48 <kuribas> guest32456: but it might help if you formulate your questions more clearly.
03:02:19 <kuribas> ttt_fff: it doesn't prevent you, but it does make it much harder to do.
03:02:52 <ttt_fff> yeah, I feel like the weird way that haskell's syntax works causes me to look at code and go
03:02:57 <ttt_fff> this is ugly, maybe I can stuff some of this in a monad
03:03:02 <ttt_fff> and then I'm like yeah, that'd make this much cleaner
03:04:22 <jle`> ttt_fff: haskell is also very amenable to refactoring
03:04:35 <jle`> so it's a nice language for hacking things out in an ugly way, with the compiler helping you make sure that your ugliness is correct
03:04:46 <jle`> so you can write ugly code if you want to, with the assurance that it's correct ugly code
03:04:50 <jle`> and then easily refactor later :)
03:04:59 <frerich> kuribas: I have preferred BSD over GPL (or even LGPL) for most of my career, but I'm not a big "free software" person (as in, the philosophy) but rather an "open source" (as in: I'm cool with people tinkering) person -- and maybe many Haskell people are like that.
03:06:44 <frerich> I'm happy if people take my stuff to build proprietary systems and then mention me as a contributor, at the risk of those systems being stupid overall. That's how I got my name on Safari or Chrome (since they forked open source software which was BSD licensed). :-)
03:07:06 <frerich> Hm I guess this is mostly #haskell-blah, I'll shut up.
03:07:27 <kuribas> right, I'll go the blah :)
03:09:59 <kuribas> frerich: I like the idea that companies share work, instead of duplicating it internally out of fear of IP theft.  The GPL enforces that sharing.
03:10:32 <frerich> kuribas: I thought you just promised to take it to -blah! :-)
03:10:53 <kuribas> frerich: alright, I'll shut up :)
03:33:02 <ttt_fff_> what do you guys think of http://begriffs.com/posts/2014-12-30-intro-to-postgrest.html ? the idea is ... business logic all stored in store procedures
03:40:19 <ij> Why do I get a "foo" instead of "test\nfoo" here? main = do return . (trace =<< show) $ "test"; putStrLn "foo"
03:46:38 <quicksilver> the trace is attached to an expression which never gets evaluated
03:46:42 <quicksilver> so you never see it
03:57:12 <ij> In this case I can just print it anyway. Silly.
04:05:13 * hackagebot base 4.8.1.0 - Basic libraries  https://hackage.haskell.org/package/base-4.8.1.0 (HerbertValerioRiedel)
04:08:52 <lamefun> Is there a way to re-format this code in a less ugly way? http://lpaste.net/4377177402451689472
04:10:13 * hackagebot html-tokenizer 0.3.0.3 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.3.0.3 (NikitaVolkov)
04:11:10 <frerich> lamefun: I think a good start might be to use pattern matching instead of explicit 'case' expressions. E.g. use 'opPrefix Equal = "= "' instead of 'opPrefix op = case op of Equal -> "= "
04:11:23 <frerich> I think that would save two levels of indentation in your case.
04:12:01 <lamefun> frerich, then I'll have to repeat "opPrefix" 5 times
04:15:13 * hackagebot aivika-experiment-chart 4.3.1 - Simulation experiments with charting for the Aivika library  https://hackage.haskell.org/package/aivika-experiment-chart-4.3.1 (DavidSorokin)
04:15:15 * hackagebot aivika-experiment-cairo 4.3.1 - Cairo backend for the Aivika simulation library  https://hackage.haskell.org/package/aivika-experiment-cairo-4.3.1 (DavidSorokin)
04:20:13 * hackagebot aivika-experiment-diagrams 4.3.1 - Diagrams backend for the Aivika simulation library  https://hackage.haskell.org/package/aivika-experiment-diagrams-4.3.1 (DavidSorokin)
04:31:07 <lunaris> Hey all; anyone ever written a postgresql-simple ToField instance for any of the Data.Fixed types?
04:31:10 <phaazon> hm, I’ve been thinking of resource acquiring and deallocation
04:31:31 <phaazon> resourcet uses something like a map to store m () actions to deallocate them
04:31:38 <lunaris> If so, care to share? Seems like persistent does it by serialising to String using show -- wondering if this is sane/whether someone has a better idea.
04:31:45 <phaazon> but hm, isn’t there possible to use something a bit more hm
04:31:48 <phaazon> haskellish?
04:31:52 <phaazon> I mean, continuations.
04:32:08 <lunaris> I've implemented FromField using fromRational and the Rational instance.
04:32:17 <phaazon> after all, I could wrap a “with”-idiom into a ContT
04:37:20 <frerich> lamefun: Yeah - I think that would be nicer, i.e. repeating the text would make it prettier. As in http://lpaste.net/137074
04:38:57 <frerich> lamefun: I.e. I'd prefer to repeat 'opPrefix' instead of indenting. For no particular reason really. :-) Also, aligning the '=' signs shows the nice symmetry between the two definitions of 'formatRequest'.
04:40:47 <chpatrick> phaazon: I've been using Codensity
04:41:11 <chpatrick> but I think the problem there is that it's hard to release early
04:41:33 <chpatrick> so I only use it for the "critical sections" so to speak
04:41:52 <chpatrick> you can have your whole thing in resourcet and still deallocate as needed
04:42:07 <chpatrick> you could also use a ForeignPtr if you need to release something in C
04:42:19 <chpatrick> then it gets collected as soon as it gets GC'd, which is pretty neat
04:43:58 <phaazon> chpatrick: I don’t know Codensity
04:44:56 <catgocat> Why is there no constraint `Eq` on this function: let foo x y = x == y || x < y ?
04:45:15 <chpatrick> phaazon: it's like ContT r m a but forall r
04:45:19 <frerich> catgocat: It requires 'Ord' (because of '<') which implies Eq.
04:46:02 <Maxdamantus> class Eq a => Ord a
04:46:27 <catgocat> oh, so Ord already means it's an instance of Eq?
04:46:50 <frerich> catgocat: The way the 'Ord' class is defined means that nothing can be an instance of Ord without being an instance of Eq.
04:46:53 <Maxdamantus> The line above will be part of the definition of Ord.
04:47:21 <catgocat> ok ok
04:47:46 <ttt_fff> debugging haskell ... is like solving a puzzle
04:48:02 <catgocat> how do I see how ord is defined?
04:48:04 <catgocat> I can't find the source code
04:48:20 <frerich> catgocat: In ghci, try running ':i Ord'
04:54:43 <wedens> is there good tutorial on type classes derivation?
04:55:37 <phaazon> chpatrick: interesting
05:25:16 * hackagebot yesod-auth-fb 1.7 - Authentication backend for Yesod using Facebook.  https://hackage.haskell.org/package/yesod-auth-fb-1.7 (FelipeLessa)
05:39:33 <phaazon> god
05:39:41 <phaazon> kan-extensions sound so cryptic
05:39:44 <phaazon> CoT
05:39:57 <phaazon> Lan, Ran, Rift, Density, Codensity
05:40:00 <AshyIsMe> is there a way to match only a certain group from a regex with Text.Regex.PCRE?
05:40:07 <phaazon> is there any uses of that? :D
05:40:18 <zmbmartin> How can I convert ZonedTime to epoch?
05:40:31 <AshyIsMe> eg: "foo bar baz" =~ ".*(bar).*" :: String   -- I just want the group to come back ie. "bar"
05:41:11 <Intolerable> zmbmartin: zonedTimeToUTC?
05:42:43 <Intolerable> :t utcTimeToPOSIXSeconds . zonedTimeToUTC
05:42:44 <lambdabot> Not in scope: ‘utcTimeToPOSIXSeconds’
05:42:44 <lambdabot> Not in scope: ‘zonedTimeToUTC’
05:42:52 <bergmark> AshyIsMe: [String] perhaps?
05:43:10 <Intolerable> :t Data.Time.Clock.POSIX.utcTimeToPOSIXSeconds . Data.Time.LocalTime.zonedTimeToUTC
05:43:11 <lambdabot> time-1.5.0.1:Data.Time.LocalTime.LocalTime.ZonedTime -> Data.Time.Clock.POSIX.POSIXTime
05:43:23 <zmbmartin> Intolerable: so utcTimeToPOSIXSeconds . zonedTimeToUTC will give me epoch?
05:43:46 <AshyIsMe> bergmark: i get a no instance error with that
05:44:02 <Intolerable> yes
05:44:18 <zmbmartin> Intolerable: Thanks!
05:44:27 <bergmark> hmm too long since i touched haskell regexes
05:44:57 <AshyIsMe> bergmark: ah yeap, cheers anyway i think you were on the right track
05:45:02 <AshyIsMe> i found this: http://stackoverflow.com/questions/5591192/grouping-in-haskell-regular-expressions
05:51:39 <chpatrick> AshyIsMe: use a parser combinator instead?
05:54:57 <chpatrick> phaazon: the only one I've used is Codensity
05:55:02 <tmtwd> data Vector a = EmptyVector | Cons a (Vector a), how would I insert data into this data type?
05:55:05 <chpatrick> ekmett probably has a million uses
05:55:19 <zmbmartin> if I have newtype DateStamp = DateStamp ZonedTime how do I access ZonedTime?
05:55:34 <chpatrick> tmtwd: insert by position or what?
05:55:34 <Stratege> tmtwd isn't that just list?
05:55:42 <tmtwd> nvm
05:55:48 <chpatrick> zmbmartin: pattern match
05:56:08 <chpatrick> or do newtype DateStamp = DateStamp { dateStampTime :: ZonedTime }
05:56:34 <maerwald> Cons 3 (Cons 5 EmptyVector)
05:57:12 <zmbmartin> chpatrick: How would I pattern match in this case (realToFrac (utcTimeToPOSIXSeconds (zonedTimeToUTC dataStamp)) <- dateStamp is DateStamp but zonedTimeToUTC expects ZonedTime
05:58:15 <chpatrick> case dateStamp of
05:58:16 <chpatrick>   DateStamp zt -> ...
05:58:40 <zmbmartin> chpatrick: OK I thought there might be another way.
05:58:41 <chpatrick> or DateStamp zt <- getDateStamp above
05:58:55 <chpatrick> or make a record field and then it's just dateStampTime dateStamp
06:00:38 <zmbmartin> chpatrick: OK thanks!
06:01:00 <elbens> My function is getting rather unwieldy due to the amount of state I’m passing around. I’m a bit new to Haskell, so I started as simple as possible, which is to pass around a bunch of state via argument, and returning pairs (see https://github.com/elben/neblen/blob/master/src/Neblen/TypeChecker.hs#L661), then unrolling those pairs to get back at the updated state. I want to move to a monad transformer stack, having just found ou
06:01:01 <elbens> about them. Would it be better for me to move “slowly” towards a monad stack? For example, in the example linked above, I use `error` to throw exceptions randomly. I want to start with just using `Except`.
06:01:49 <_d0t> ohai
06:01:53 <guillaum1> Hello
06:02:30 <guillaum1> If I want to redefine (+) for my custom "data", am I forced to instanciate the typeclass "Num" or there is another solution ?
06:02:32 <_d0t> I've made a simple library with just one module in it. The problem is that when I try to build it, cabal says cabal: can't find source for Database/Persistent/Instances/IP in .
06:02:47 <lamefun> More ugly code, how to write it in a better way? http://lpaste.net/6639992136508899328
06:02:49 <_d0t> wait
06:02:55 <_d0t> i've made a type. Nevermind :D
06:03:03 <Intolerable> elbens: switching to a transformer stack gradually is definitely a good idea
06:03:43 <Intolerable> if you switch the entire thing at once, you'll probably end up with a mess of type errors to fix
06:04:08 <Intolerable> and because there are multiple transformers the error messages will be less than helpful
06:04:18 <elbens> Intolerable: that is my feeling, just watned to see if there were a strategy for doing it all at once, without going into the valley of type error despair
06:04:38 <Intolerable> it really depends on how comfortable you are with transformers
06:04:43 <elbens> not very :)
06:04:56 <Intolerable> if you're just starting out its better to do it one-by-one
06:05:07 <chpatrick> guillaum1: I would do it if it makes sense to have a Num instance
06:05:15 <chpatrick> otherwise I would call it the function something else
06:05:40 * hackagebot fgl 5.5.2.0 - Martin Erwig's Functional Graph Library  https://hackage.haskell.org/package/fgl-5.5.2.0 (IvanMiljenovic)
06:05:40 * hackagebot fgl-arbitrary 0.2.0.0 - QuickCheck support for fgl  https://hackage.haskell.org/package/fgl-arbitrary-0.2.0.0 (IvanMiljenovic)
06:05:47 <Intolerable> guillaum1: and if it have a sensible Num instance, consider Monoid or Semigroup or something else
06:05:52 <Intolerable> *if it doesn't
06:06:09 <maerwald> @hoogle (+++)
06:06:10 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
06:06:10 <lambdabot> Text.ParserCombinators.ReadPrec (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
06:06:10 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
06:06:21 <maerwald> unless you use arrows, just use that?
06:06:59 <Black0range> Is it possible to hide the entire String module from prelude?
06:08:00 <guillaum1> chpatrick: I'm writing a vector (as in linear algebra). So I want (+) between my vectors, but Vector have no meaning as a Num instance (for example, fromInteger, signum and abs are not really well defined...
06:09:02 <chpatrick> @hackage vector-space
06:09:03 <lambdabot> http://hackage.haskell.org/package/vector-space
06:09:13 <chpatrick> guillaum1: this has more finer-grained classes for exactly this purpose
06:09:58 <guillaum1> chpatrick: I'll have a look, thank you
06:10:09 <Intolerable> do vectors form a proper monoid?
06:10:20 <Intolerable> or do you have to do a similar thing to Sum / Product?
06:11:14 <chpatrick> Intolerable: https://hackage.haskell.org/package/vector-space-0.10.2/docs/Data-AdditiveGroup.html#t:Sum
06:11:51 <guillaum1> Intolerable: I have the feeling that a Vector is a monoid (as long as we consider operation per channel)
06:12:34 <Intolerable> neat
06:14:00 <guillaum1> chpatrick: There is something which really annoy me since I'm learning haskell is that because the operators are "global" and not attached to a specific type (such as in C++ or python), they may be clash name between my lib and another. Did I miss something important here or is this normal in haskell ?
06:14:58 <maerwald> guillaum1: qualified imports
06:15:12 <maerwald> import qualified Data.Foo as F
06:15:35 * hackagebot yesod-auth-ldap-mediocre 0.1.0.0 - Very simlple LDAP auth for yesod  https://hackage.haskell.org/package/yesod-auth-ldap-mediocre-0.1.0.0 (andrewthad)
06:15:58 <Intolerable> guillaum1: also modularization helps
06:16:26 <muzzle> hi
06:16:30 <megamac12> please help! rigid type error on: instance Functor NestedList ...
06:16:30 <megamac12> http://lpaste.net/137077
06:16:39 <muzzle> what preprocessor can i use to determine if i'm on os X
06:16:40 <muzzle> ?
06:16:44 <muzzle> or on linux?
06:16:48 <guillaum1> maerwald: that's a solution, but that means that my code can stop working if some lib introduces new operator which conflicts with mines (and that I don't import qualified). Or I must import everything qualified and get a really bloated code.
06:18:18 <chpatrick> guillaum1: yeah Num is a bit too big
06:18:49 <chpatrick> but the haskell way is usually to give every type its own functions and qualify the module import
06:19:04 <chpatrick> and then if there's a common pattern between a lot of functions then group them into a typeclass
06:19:16 <muzzle> nvm, I found out
06:19:21 <chpatrick> but Num does too many things unfortunately
06:20:20 <guillaum1> chpatrick: ok, thank you.
06:21:00 <Gurkenglas> elbens, why do you pass the Literal constructor to checkLiteral? couldn't you make its type signature TEnv -> UEnv -> Value -> (TEnv, UEnv, Type)?
06:23:58 <Tuplanolla> I'm hoping to get this: data Fn a b = F0 b | F1 (a -> b) | F2 (a -> a -> b) | ...
06:23:58 <Tuplanolla> Do I need an extension for type-level numbers or some other trick? I don't want to do this: data Fn a b = F0 b | Fn (a -> Fn a b)
06:25:54 <Intolerable> do you need a fixed range?
06:26:22 <humanoyd> Can anyone tell me from which module I have to import `fromList` that is used in https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson.html?
06:26:29 <Intolerable> Data.Foldable
06:26:29 <Tuplanolla> Let's say I want it to be unbounded, Intolerable.
06:27:01 <Intolerable> unbounded i expect you'd have to do the "trick" you mentioned
06:27:23 <Intolerable> you can definitely mangle in a bounded one w/ TH
06:27:48 <Intolerable> you might be able to get away with combining the trick with type-level nats
06:27:51 <Intolerable> one second
06:28:12 <Tuplanolla> Something like this: data F (n :: Nat) a b = ...
06:28:23 <humanoyd> never mind, found it
06:29:00 <Gurkenglas> elbens, I also don't see the need to make a monad transformer stack out of this. a single State monad would be enough: Define yourself data Env = Env  7tEnv :: TEnv, uEnv :: UEnv} somewhere, then use, in checkLiteral's example, Exp -> State Env Type (or, following my earlier advice, Value -> State Env Type) (or define your own name for State Env with newtype). (Although in checkLiteral's case, since it would not h
06:29:01 <Gurkenglas> ave anything to do with Env, you could just make its type Value -> Type, then have checkExp use return to lift it to the needed type.)
06:29:18 <Gurkenglas> -7t+{
06:29:41 <Gurkenglas> -(-7t+{)+(-7+{)
06:32:45 <argent0> megamac12: fmap f (L xs) = L $ map (fmap f) xs  
06:35:50 <megamac12> argent0: thanks, that worked
06:36:10 <Intolerable> Tuplanolla: http://lpaste.net/137079 ?
06:36:23 <Intolerable> this the kind of thing ur looking for?
06:37:20 <Tuplanolla> Oh, the obvious GADT. Thanks.
06:40:36 * hackagebot creatur 5.9.7 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.7 (AmyDeBuitleir)
06:41:02 <indiagreen> does anyone who has read the first 3 “lens over tea” posts (and isn't an expert on lenses) want to read the 4th one before I publish it and say whether there's anything unclear/extremely unclear/stupid/etc in it?
06:53:31 <dotxasp> Hello. Why does this code leak memory? http://lpaste.\net/137081 
06:53:39 <dotxasp> * http://lpaste.net/137081
06:53:55 <Intolerable> incT isn't strict
06:54:19 <Intolerable> you probably want "writeTVar r $! (v + 1)"
06:54:47 <dotxasp> OK thanks. 
06:55:56 <Intolerable> you're basically just building up a huge thunk of 0+1+1+1+1+1+1+1
06:55:58 <dotxasp> How do I avoid the same pitfall for next time?
06:56:16 <Intolerable> try not to build up huge thunks with little operations
06:56:26 <Intolerable> without at some point evaluating them
06:56:56 <Intolerable> seq'ing the result or using $! when you write will help
06:57:13 <Intolerable> it's the kind of thing you have to mess up a couple of times before you get the hang of it
06:57:51 <dotxasp> thanks!
06:58:26 <sm> Intolerable: in most simple haskell code these thunks tend to get forced naturally as you use them, eg when you print them. How come that doesn't happen here ? Because of the TVar ?
06:58:42 <dotxasp> So if I think I'm calling a function ten of thousand times, should I think adding strictness in it?
06:59:18 <Intolerable> sm: because the thunk inside the TVar itself is never evaluated
06:59:31 <Intolerable> we just keep stacking (+1)s on top of the existing thunk
06:59:55 <Intolerable> dotxasp: yeah, unless you have another way of making sure it gets evaluated properly
07:00:04 <chpatrick> :t modifyTVar'
07:00:05 <lambdabot> Not in scope: ‘modifyTVar'’
07:00:23 <chpatrick> dotxasp: https://hackage.haskell.org/package/stm-2.4.4/docs/Control-Concurrent-STM-TVar.html#v:modifyTVar-39-
07:00:37 <Intolerable> :t Control.Concurrent.STM.TVar.modifyTVar'
07:00:39 <lambdabot> GHC.Conc.Sync.TVar a -> (a -> a) -> GHC.Conc.Sync.STM ()
07:01:26 <Intolerable> deciding whether to use strict or non-strict versions of things is something that takes some experience
07:01:34 <Intolerable> and sometimes just trial and error
07:02:25 <maerwald> Intolerable: and is one of the more unpleasant things about haskell
07:02:49 <indiagreen> in other words: there are patterns/heuristics for deciding, but either nobody bothered to write them down, or having a list of them doesn't help (and they have to be learned by trial and error)
07:02:59 <chpatrick> there's this though: https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
07:03:03 <chpatrick> eventually
07:03:37 <Intolerable> laziness is definitely the best and worst thing about haskell
07:03:59 <Intolerable> there's an obvious evaluation joke there
07:05:28 <sm> Intolerable: since another thread is continually consuming the values from the TVar I would have guessed they would not build up. Oh, but they are generated much faster than consumed I suppose
07:05:52 <chpatrick> there's really no reason to ever have those lazy though
07:06:10 <chpatrick> a thunk will always be less efficient to keep around than the running total
07:06:19 <chpatrick> or to update
07:06:28 <sm> I too am just trying to figure out the intuition for predicting these things
07:06:39 <bergmark> sm: it's not really consuming the values, it's just reacting to changes
07:06:52 <bergmark> consuming sounds more like a TQueue
07:07:08 <sm> hmm, true, it's just reading
07:07:24 <chpatrick> in other news
07:07:31 <maerwald> sm: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#dealing-with-laziness this is the only thing I found that gives a rough "rule of thumb" about laziness, but it's probably very "rough"
07:07:41 <chpatrick> any idea why sum [0..bignumber] doesn't run out of memory any more?
07:07:42 <sm> a copy, which it prints. Which doesn't collapse the stored value, apparently
07:08:01 <chpatrick> or even foldl (+) 0
07:08:06 <zmbmartin> Not sure what I am doing wrong ToJSON and FromJSON instances https://gist.github.com/codedmart/a180550b70ecb3f440af
07:08:18 <sm> maerwald: thanks
07:08:38 <Intolerable> return $ DateStamp $ parseJSON t is wrong
07:08:54 <Intolerable> you *probably* want DateStamp <$> parseJSON t
07:09:24 <Intolerable> otherwise you're trying to shove a Parser ZonedTime where an actual concrete ZonedTime should go
07:14:38 <AshyIsMe> ok wtf, Text.Regex.subRegex can throw exceptions
07:14:44 <AshyIsMe> but that's not refflected in the type
07:15:30 <zmbmartin> Intolerable: Ok, makes sense. Thanks!
07:15:39 <bergmark> AshyIsMe: if the regex is invalid, or something else?
07:16:09 <AshyIsMe> yeah seems to be if the regex is invalid
07:17:06 <kuribas> Let's say I am writing a drawing app in haskell.  By default, dragging the mouse does nothing, but when I activate the pencil tool, dragging will draw a line on the canvas.  How would you implement it using FRP?
07:17:10 <bergmark> AshyIsMe: the library would be really awkward to use if every operation had to give a Maybe
07:17:36 <bergmark> unless you are dynamically constructing regexes you can test them and be sure that they work
07:17:44 <kuribas> Do I need to dynamically alter mouse events?
07:18:27 <Intolerable> fold over mouse position, if the mouse is down, use the diff to add a line to the current state
07:18:30 <AshyIsMe> bergmark: yeah dynamically generated regexes
07:19:50 <kuribas> Intolerable: how to change the behaviour when the tool changes?  For example when changing to the circle tool?
07:19:56 <maerwald> bergmark: I'd just do IORef or something for the global state and examine that in the mouse click callback from gtk or whatever
07:20:20 <maerwald> gui programming without global state is very cumbersome
07:20:23 <Intolerable> kuribas: the state contains the selected tool
07:20:58 <kuribas> is it possible stateless?
07:21:13 <maerwald> s/bergmark/kuribas/
07:21:38 <Intolerable> probably, but i wouldn't be able to tell you how
07:21:55 <maerwald> also... why? That's the perfect use case for modelling a state
07:22:00 <maerwald> it just makes sense
07:22:29 <AshyIsMe> bergmark: i guess the surprising part is that it's not typesafe...
07:23:30 <AshyIsMe> actually maybe im wrong, how do i catch an exception from subRegex :: Regex -> String -> String -> String
07:23:42 <sm> AshyIsMe: any haskell function can throw exceptions regardless of type
07:23:57 <kuribas> maerwald: because I would get a large state, while I would like to specify each behaviour locally.
07:24:02 <kuribas> for each tool
07:24:36 <bergmark> AshyIsMe: it's bad if that's undocumented, but I can't think of a reasonable alternative if the input is a String
07:25:18 <sm> regex libs should provide a regexp validity checker
07:26:14 <AshyIsMe> Control.Exception.catch is in the IO monad so how do i catch an exception without being in the IO monad?
07:26:21 <Intolerable> you can't
07:28:50 <maerwald> kuribas: you can still have smaller states and combine them later to the whole thing, no?
07:29:12 <kuribas> yes
07:29:12 <maerwald> but once you click the mouse, you must look at the whole thing
07:29:15 <bergmark> AshyIsMe: see http://book.realworldhaskell.org/read/error-handling.html it's outdated on a few things but good overall
07:29:41 <maerwald> I was thinking about a Monoid instance, but I'm not sure
07:30:29 <ggVGc> can someone shine some light on this? https://gist.github.com/f6a3153c0d44bbcc3efc
07:30:39 * hackagebot ghc-exactprint 0.3 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.3 (AlanZimmerman)
07:30:52 <AshyIsMe> bergmark: cheers i'll have a read
07:32:49 <kuribas> maerwald: or I could set the mouse event behaviour as a Behaviour?
07:33:54 <maerwald> kuribas: I'm not sure what you mean
07:34:07 <Intolerable> kuribas: can you not switch on behaviours?
07:34:31 <kuribas> Intolerable: yes, that's what I mean.
07:34:59 <Intolerable> are you using a particular library?
07:36:04 <kuribas> I looked at reactive-banana, but others are fine too.
07:36:46 <kuribas> switching is currently leaky in reactive-banana, but I could work around it.
07:40:00 <kuribas> a behaviour is like a mutable variable right?
07:40:11 <ggVGc> man, every time I try to use any hasell package I end up spending at least 3 hours fighting with cabal and other things...
07:40:27 <ed|win> edward kmett mentioned something about a haskell-prime reboot almost a month ago, and that the messages was probably only sent to the haskell prime list, however the last message there is from march
07:40:39 <zipper> ggVGc: Which one specifically?
07:40:42 <Intolerable> ggVGc: use sandboxes more aggressively
07:40:44 <zipper> ggVGc: Sandboxes?
07:40:50 <ggVGc> lushtags this time
07:40:57 <ggVGc> can't do it with a sandbox either..
07:40:59 <ed|win> I'm curious if anyone knows if said conversation might have happened elsewhere or if there's been any progress in that front?
07:41:36 <zipper> ggVGc: Why can't a sandbox work?
07:41:40 <AshyIsMe> ggVGc: use stack
07:41:48 <zipper> ggVGc: I have only one situation in which a sandbox fails.
07:41:54 <AshyIsMe> it's been great on osx so far, it should be good on linux too
07:42:14 <ggVGc> https://gist.github.com/057195d96abf3af3eba6
07:42:29 <ggVGc> AshyIsMe: right, what do I do when I want to use a cabal package with stack?
07:42:30 <ed|win> i made a second attempt at migrating to stack eventually
07:42:40 <ed|win> feels weird to still need a cabal file
07:42:54 <AshyIsMe> ggVGc: as in your own package or somethnig off hackage?
07:43:10 <ed|win> and it's either a plus or a minus that stack build doesn't build modules not listed in other-modules in a cabal file
07:43:12 <AshyIsMe> "stack install somehackagepackage"
07:43:13 <ggVGc> AshyIsMe: as in this https://github.com/bitc/lushtags
07:43:18 <ggVGc> or any other package with a .cabal file
07:43:36 <ggVGc> all I want to do is fucking use some haskell code. Which every single time turns out to be almost impossible
07:43:42 <ggVGc> :(
07:44:09 <AshyIsMe> stack still uses the cabal file
07:44:10 <Intolerable> why can't you use a sandbox for that?
07:44:24 <AshyIsMe> it is confusing and crap, which is why they're working on stack
07:44:31 <ggVGc> Intolerable: I just posted my termina output. You tell me why the sandbox doesn't work
07:44:40 * dcoutts notes that cabal-install is also being improved
07:44:44 <ggVGc> I don't understand cabal
07:44:48 <ggVGc> it always fucks with me
07:44:49 <Gurkenglas> We should make it popular for people to use Teamviewer to show other people how to deal with all that
07:45:07 <init> I would avoid that
07:45:27 <Gurkenglas> Why?
07:46:06 <AshyIsMe> ggVGc: in the lushtags directory you just need to run "stack init"
07:46:06 <init> you can't limit what other people can do with teamviewer quite easily, it's basically giving your computer to someone else
07:46:07 <Intolerable> the problem with that particular package is that its bounds are a disaster
07:46:17 <Intolerable> and its from 2013 so there's a bunch of stuff that's changed
07:46:21 <AshyIsMe> ggVGc: stack looks at the cabal file and figures out what it needs to do
07:46:43 <AshyIsMe> im trying it with lushtags now
07:46:54 <ggVGc> AshyIsMe: goot stuff, https://gist.github.com/317b9429389c7f9758f1
07:46:55 <Gurkenglas> init, isn't there that one-click setting that makes all the remote clicks just ping areas on the screen?
07:47:26 <Intolerable> AshyIsMe: the problem is its an ancient package with ancient deps
07:47:37 <init> Gurkenglas: that may be new, I still dislike it
07:47:52 <Intolerable> im fiddling with the bounds atm
07:48:04 <AshyIsMe> oh right
07:48:07 <AshyIsMe> ggVGc: use hasktags
07:48:20 <AshyIsMe> it works for me
07:48:47 <AshyIsMe> codex is great too, gives you tags for the libraries you're using
07:48:48 <Intolerable> oh lmao it literally depends on a package that does not exist
07:48:49 <AshyIsMe> https://hackage.haskell.org/package/codex
07:49:05 <AshyIsMe> haha
07:49:21 <AshyIsMe> ggVGc: bloody package managers aye...
07:49:35 <Intolerable> wait no thats a typo lmao
07:49:37 <Intolerable> its not that bad
07:49:51 <AshyIsMe> anyway in this case, use hasktags and codex 
07:49:56 <phaazon> h
07:49:58 <phaazon> hm
07:50:03 <phaazon> so a Codensity is a bit like ContT
07:50:09 <phaazon> but it works for any return values
07:50:15 <ggVGc> let me just say, I hate literally all software
07:50:24 <phaazon> I don’t get the idea behind that, though
07:50:28 <AshyIsMe> https://github.com/AshyIsMe/dotrc/blob/master/vimrc#L198-L200
07:50:29 <phaazon> why « Co– » « density »?
07:50:42 <AshyIsMe> i have that set up so when i save any *.cabal files it updates the tags
07:51:07 <AshyIsMe> ggVGc: agreed
07:51:44 <wedens> I'm looking for resources on template haskell and typeclasses derivation
07:52:35 <Intolerable> how familiar are you with TH?
07:56:03 <nshepperd> phaazon: I found a fun recounting of the history of the name: https://golem.ph.utexas.edu/category/2012/09/where_do_monads_come_from.html#c042120
07:56:58 <phaazon> nshepperd: that’s a bit hard to follow
07:58:17 <phaazon> I especially don’t understand the notion of « adjunctions »
07:58:26 <phaazon> even though edwardk already tried to explain me that
07:58:48 <phaazon> however, I’m implementing my resource system with codensity monads
07:58:48 <phaazon> sounds good
07:59:43 * nshepperd does not get adjunctions yet
08:00:20 <nshepperd> or many things, really
08:03:39 <phaazon> actually
08:03:48 <phaazon> I’d like to be able to represent resource stuff with typeclass
08:04:00 <phaazon> maybe I should use MonadResource instead…
08:05:12 <dolio> I should start a tally of how many times people blame cabal and suggest stack when someone's problem is that there doesn't exist _any_ set of versions that would actually work in their situation, so the package is just impossible to install.
08:05:20 <dolio> This is at least the second time.
08:05:38 <sm> it is at least a better starting point for beginners
08:05:41 <zmbmartin> I am not sure how to debug this. I am getting a pattern match failure. https://gist.github.com/codedmart/a180550b70ecb3f440af#file-datestamp-hs-L58
08:06:28 <Intolerable> why is that in a do block?
08:06:41 <phaazon> hm
08:07:12 <Intolerable> it shouldn't be in a do block, its not in a monad
08:07:20 <phaazon> what happends if I glue a value to another, for instance inside a data or (,)
08:07:23 <phaazon> happens*
08:07:25 <phaazon> for the GC?
08:07:33 <phaazon> if I don’t use the left value in my code
08:07:40 <phaazon> is it ever created at some point?
08:08:03 <phaazon> do I need to ensure some kind of strictness or what?
08:08:23 <zmbmartin> Intolerable: OK let me retry that.
08:08:25 <alpounet> the thunk is created but not evaluated unless some bit of code requires its value. it's however evaluated right away when the field is strict
08:08:40 <phaazon> alpounet: what I mean is
08:08:52 <phaazon> I’m implementing a library with C variables lifted up to Haskell through the GC
08:08:53 <chpatrick> zmbmartin: FYI there's already a FromJSON instance for ZonedTime
08:09:00 <phaazon> so that I don’t have to handle the memory on my own
08:09:04 <phaazon> however
08:09:05 <phaazon> in a few cases
08:09:14 <phaazon> I might never use the returned values
08:09:17 <phaazon> but I need them to be there
08:09:24 <chpatrick> ah it's something custom
08:09:25 <chpatrick> nm
08:09:43 <phaazon> (otherwise, the GC would call the finalizers and break the C variables)
08:10:01 <alpounet> phaazon: what do you mean exactly by "lifted up to Haskell" ?
08:10:14 <phaazon> alpounet: those values are generated by C function generators
08:10:14 <chpatrick> zmbmartin: maybe parse it with atto/parsec and then convert the parse result to a Parser?
08:10:20 <phaazon> a 1:1 raw API would provide two functions
08:10:24 <chpatrick> I think it would be nicer than all the pattern matching
08:10:24 <phaazon> genFoo
08:10:26 <phaazon> and deleteFoo
08:10:33 <phaazon> I provide only one
08:10:35 <zmbmartin> chpatrick: The problem is I get either ZonedTime or an Object.
08:10:40 <phaazon> which wraps the value into a ForeignPtr
08:10:52 <Intolerable> zmbmartin: how do you mean
08:10:55 <Intolerable> *?
08:11:04 <chpatrick> phaazon: I'm releasing something soon that you might find useful
08:11:11 <chpatrick> going through corporate open source releasing now :)
08:11:12 <phaazon> the thing is
08:11:20 <chpatrick> unless you decide that it's "wrong" ;)
08:11:28 <phaazon> I used to implement that with a “MonadScoped” typeclass
08:11:32 <phaazon> a bit like MonadResource
08:11:38 <phaazon> but that just adds boilerplate
08:11:51 <zmbmartin> chpatrick Intolerable: I haven't tracked it down in the haskell driver yet, but rethinkdb stores times as {"$reql_type$":"TIME","epoch_time":1436820226.598,"timezone":"+00:00"} 
08:12:12 <alpounet> phaazon: I think resourcet does pretty much what you want doesn't it?
08:12:16 <chpatrick> zmbmartin: are you using the rethinkdb bindings?
08:12:18 <chpatrick> they look really nice
08:12:26 <phaazon> alpounet: it introduces a new scope to handle values
08:12:29 <zmbmartin> chpatrick: What do you mean
08:12:34 <phaazon> but then, it forces me to use ResourceT
08:12:40 <chpatrick> @hackage rethinkdb
08:12:40 <lambdabot> http://hackage.haskell.org/package/rethinkdb
08:12:48 <chpatrick> phaazon: what's wrong with ForeignPtrs again?
08:13:13 <phaazon> chpatrick: the fact that the runtime might decide they’re no longer in use
08:13:17 <phaazon> and collection them 
08:13:20 <phaazon> calling the finalizers
08:13:25 <chpatrick> is that a problem?
08:13:28 <phaazon> breaking C stuff if it still relies on that
08:13:28 <phaazon> sure it is
08:13:36 <chpatrick> okay so I've solved this exact problem
08:13:46 <chpatrick> but I can't release it just yet
08:13:48 <phaazon> resourcet also solves that proble
08:13:50 <phaazon> m*
08:13:52 <chpatrick> but you can make a tree of ForeignPtrs with reference counting
08:13:56 <phaazon> so does Codensity and ContT
08:13:59 <phaazon> but I don’t know
08:14:03 <chpatrick> and then it's just IO
08:14:09 <phaazon> I don’t like providing such interface
08:14:13 <zmbmartin> chpatrick: Not sure what you mean by bindings, but I if I just use UTCTime or ZonedTime which rethinkdb has instances for I get an error 'RethinkDB Unexpected response: expected UTCTime, but got Object'
08:14:40 <zmbmartin> How can I print or view what FromJSON is getting?
08:14:46 <chpatrick> zmbmartin: are you using the rethinkdb haskell package or calling it manually?
08:14:58 <zmbmartin> chpatrick: rethinkdb haskell package.
08:15:02 <chpatrick> ah ok
08:15:06 <chpatrick> maybe it's a bug
08:15:49 <zmbmartin> chpatrick: I realize that, but I am trying to figure out how I debug it to track it down.
08:16:11 <chpatrick> ah I see
08:16:30 <zmbmartin> chpatrick: Can I print or see what FromJSON is getting in this case?
08:16:37 <Intolerable> use trace
08:16:39 <chpatrick> you could stick a traceShowId in their FromJSON instance
08:16:49 <chpatrick> zmbmartin: http://hackage.haskell.org/package/base-4.8.0.0/docs/Debug-Trace.html#v:traceShowId
08:17:08 <Zemyla> Hmm. If I have a program that produces a list of vectors in the ST monad, and then outputs them, how can I show that it'll be safe when I use unsafeInterleaveST to defer producing the tail of the list?
08:17:46 <Zemyla> Like, (:) <$> freeze vec <*> unsafeInterleaveST rest?
08:19:31 <chpatrick> Zemyla: unsafeInterLeaveSt $ makeAListOfFrozenVectorsInST?
08:21:04 <zmbmartin> chpatrick: I am not sure how to use traceShowId
08:21:10 <zmbmartin> :|
08:21:33 <chpatrick> err
08:21:41 <chpatrick> if their instance looks like parseJSON val = ...
08:21:52 <chpatrick> put parseJSON val = traceShow val (...)
08:22:22 <Zemyla> Well, I'm doing it in CPS, so the monad is of the form forall s k. (a -> ST s k -> v s r -> ST s k) -> ST s k -> v s r -> ST s k.
08:22:33 <Zemyla> So it's a fold.
08:22:43 <chpatrick> eep
08:25:28 <chpatrick> Zemyla: I wonder if you can use conduit here
08:25:47 <chpatrick> it's the nice solution for streaming IO so it should work for ST too
08:26:28 <chpatrick> although then you'll still be in ST
08:26:38 <chpatrick> hmm
08:27:28 <Zemyla> chpatrick: I was actually doing it so I could have a nondeterminism monad with thread-local vector state.
08:28:19 <zmbmartin> chpatrick: I tried `parseJSON t = traceShowId $ DateStamp <$> parseJSON t` and got `No instance for (Show (J.Parser DateStamp))`
08:28:37 <Intolerable> use traceShow
08:28:42 <Intolerable> instead of traceShowID
08:28:49 <Intolerable> and trace the "t"
08:28:59 <Intolerable> `parseJSON t = traceShow t $ DateStamp <$> parseJSON t
08:29:24 <zmbmartin> Intolerable: Thanks!
08:29:33 <chpatrick> I wrote exactly that five minutes ago :P
08:29:53 <Zemyla> The mplus operator copies the mutable vector when invoked, and passes each copy to each of the monads.
08:30:35 <Zemyla> (To be more accurate, it uses a recounted copy-on-write vector, so it doesn't have to do so much copying.)
08:30:57 <zmbmartin> chpatrick: Sorry didn't get it right the first time. Thanks!
08:30:59 <dzotokan> a -> b
08:31:12 <Zemyla> *refcounted
08:31:38 <Zemyla> And mzero decrements the refcount.
08:31:58 <Gurkenglas> I saw a similarity between the ((->) r) monad and the ((,) w) comonad, so I drew up this diagram: http://oi57.tinypic.com/b7ntkl.jpg . How can the relation be expressed?
08:33:20 <Zemyla> Gurkenglas: You saw the other similarity between the (->) r comonad and the (,) w monad, right?
08:34:33 <sm> does anyone have tips on profiling parsec parsers ? The call hierarchy seems not very useful for this kind of code
08:35:01 <Gurkenglas> Oh wait I read something on those four once, dangit.
08:35:11 <dzotokan> Does anyone have ghc-mod working on os x?
08:36:30 <_d0t> is there anyway to make Persistent avoid creating id fields?
08:36:38 <kuribas> Is a FRP behaviour like a State variable?
08:37:44 <Gurkenglas> (Also that diagram is wrong I need another join on the lower left horizontal arrow or something
08:37:45 <Gurkenglas> *)
08:37:57 <phaazon> kuribas: nope
08:38:08 <humanoyd>  How can I get the package names out of the "dependencies" field of a package.json file with lens?
08:38:18 <humanoyd> packagejson ^? key "dependencies" . whatThen?
08:38:44 <kuribas> phaazon: how do you manage global and local state in a GUI?  Using IORefs?
08:39:23 <phaazon> kuribas: I guess that depends 
08:39:31 <phaazon> I’m using my own event package (on hackage)
08:39:33 <Gurkenglas> Let's ask this question differently then. How does one go about transforming a diagram like the above into a statement about the (->) r monad and (,) w comonad?
08:39:39 <phaazon> which is used to interface over callbacks
08:40:00 <Gurkenglas> (Or more generally, how to "distill diagrams into their essence")
08:40:16 <kuribas> phaazon: which one?
08:40:20 <phaazon> event
08:40:37 <phaazon> http://hackage.haskell.org/package/event
08:40:48 <phaazon> is provides monoidal and monadic events
08:40:51 <phaazon> it*
08:41:34 <dzotokan> ?
08:41:34 <phaazon> GUI are asynchronous
08:41:38 <chpatrick> humanoyd: . members . ifolded . asIndex?
08:41:50 <chpatrick> err
08:41:53 <phaazon> that’s why callbacks should be used, but not directly
08:41:54 <chpatrick> members . asIndex
08:41:58 <phaazon> hence my Event type
08:42:11 <kuribas> interesting...
08:42:40 <phaazon> for my Event
08:42:49 <phaazon> (>>=) just creates a new function, passed to the callback
08:43:05 <phaazon> the Monoid interface can be used to merge events
08:43:15 <phaazon> so that callbacks are merged
08:43:24 <phaazon> you can then register actions to several events at the same time
08:45:42 * hackagebot harp 0.4.1 - HaRP allows pattern-matching with regular expressions  https://hackage.haskell.org/package/harp-0.4.1 (DavidFox)
08:46:14 <chpatrick> humanoyd: toListOf (key "dependencies" . members . asIndex) :: Value -> [ Text ]
08:46:14 <chpatrick>   :: Value -> [Text]
08:47:27 <AshyIsMe> im seeing some weird behaviour with trying to catch some exceptions: http://lpaste.net/137090
08:47:37 <AshyIsMe> why is that exception not being caught?
08:47:41 <Zemyla> Gurkenglas: Actually, there's a way to transform comobads into monads in such a way as to show their congruence.
08:47:52 <geekosaur> AshyIsMe, usually laziness
08:48:20 <Zemyla> Gurkenglas: http://comonad.com/reader/2011/monads-from-comonads/
08:48:39 <humanoyd> chpatrick: I'm not quite there yet... packageJson is of type Maybe Value (have used Bytestring.Lazy.readFile "package.json")
08:48:41 <voidnoid> is there a type I can use to indicate any kind of number? int/float etc?
08:48:42 <AshyIsMe> line 18 is where the exception is thrown
08:48:47 <geekosaur> you need to force evaluation of the regex while still under the catch
08:48:48 <AshyIsMe> geekosaur: shouldnt that still be caught though?
08:48:51 <AshyIsMe> OH
08:48:57 <voidnoid> i.e. can I freely mix functions that operate on possibly integers and possibly floats
08:48:58 <AshyIsMe> *click*
08:49:04 <voidnoid> like maybe the input is an integer but the output is a float, etc
08:49:11 <chpatrick> humanoyd: I think you can just give it the bytestring directly
08:49:22 <voidnoid> or do I need to e.g. write a Functor or something to handle the different cases?
08:49:25 <chpatrick> since key takes an AsValue t =>
08:49:26 <blackdog> g'day all - anyone know of anything FP-ish happening around Michigan? I'm in Ann Arbor/Ypsilanti and have nothing but javascript meetups as far as the eye can see
08:49:27 <Zemyla> Basically, for any comonad w, Co w a = Co { runCo :: forall r. w (a -> r) -> r } is a monad.
08:52:05 <Zemyla> So for the (,) b comonad, Co ((,) b) a = forall r. (b, a -> r) -> r, which is isomorphic to forall r. (a -> r) -> b -> r, which is isomorphic (through the Yoneda transform) to b -> a.
08:52:42 <humanoyd> chpatrick: packagejson ^.. _Just . key "dependencies" . members . asIndex works!
08:52:46 <humanoyd> chpatrick: Thanks a lot!
08:52:53 <chpatrick> yay :D
08:53:04 <Gurkenglas> Zemyla, nice. Gonna read that post.
08:53:13 <chpatrick> but yeah I think if you don't parse it into a value beforehand you can just pass in the bytestring
08:53:18 <chpatrick> and lens-aeson will take care of the conversion
08:54:45 <humanoyd> chpatrick: Ah, okay
08:54:57 <humanoyd> good to know
08:56:13 <AshyIsMe> geekosaur: how would i force evaluate it in regexReplace?
08:57:33 <geekosaur> AshyIsMe, that ... varies. for a first cut, you can try changing `return $' to `return $!'
08:59:56 <AshyIsMe> ah cheers
09:00:38 <AshyIsMe> im pretty disappointed that subRegex doesnt just return an error via Either or something
09:00:55 <geekosaur> unfortunately knowing for certain means analyzing subRegex to see where it can be lazy. worst case you end up using COntrol.Deepseq
09:01:59 <geekosaur> and yes, there are a bunch of places in standard Haskell libs where one could wish they hadn't used exceptions :/
09:03:57 <AshyIsMe> hmm, well hopefully this is good enough for now
09:04:36 <AshyIsMe> it's only for an irc bot 
09:06:08 <zmbmartin> Does aeson have a way of concat'ing to json objects?
09:06:27 <indiagreen> zmbmartin: you mean, e.g. merging 2 objects into 1?
09:06:35 <indiagreen> or what?
09:06:41 <zmbmartin> indiagreen: Yeah
09:06:47 <greymalkin> Arg... needs argument, complains of argument.... What wrong with this: WriterT [UserAction] UserContext a (where (UserContextT m a :: StateT UserState m a) and (UserContext a :: UserContextT Identity a))
09:06:50 <indiagreen> no, there was a pull request but it was declined
09:07:10 <greymalkin> Says that "UserContext should have 1 argument"
09:07:28 <greymalkin> I give it the 'a' as an argument and WriterT complains of the kind.
09:07:30 <zmbmartin> indiagreen: OK thanks!
09:07:38 <zmbmartin> That is no fun.
09:07:51 <Intolerable> are you trying to combine two Objects?
09:08:07 <Stratege> how would merging 2 objects work in the case that they have some fields with the same name?
09:08:08 <zmbmartin> Yes
09:08:13 <indiagreen> you can just unwrap Objects, use <>, wrap them back
09:08:20 <indiagreen> HashMap is a monoid
09:08:21 <Intolerable> yeah that's what i was gonna say
09:08:39 <Intolerable> Stratege: its just right- or left-associative
09:08:46 <Intolerable> and u replace the keys
09:08:49 <Intolerable> *values
09:11:27 <sm> AshyIsMe: I wonder if something like http://hackage.haskell.org/package/regex-tdfa-1.2.0/docs/Text-Regex-TDFA-ReadRegex.html catches invalid regexps
09:15:53 <monochrom> greymalkin: what does your "::" mean?
09:16:46 <Intolerable> type UserContext a = UserContextT Identity a
09:16:53 <Intolerable> (i presume)
09:16:54 <greymalkin> monochrom: Probably should be = -- read it as (::) left right = "type left = right"
09:17:18 <greymalkin> Yes.
09:18:09 <monochrom> ok, you need to know the Haskell rule that says: if your type synonym comes from "type UserContext a = UserContextT Identity a", then you cannot mention "UserContext" alone, it must always be "UserContext blah".
09:18:43 <monochrom> whereas "type UserContext = UserContextT Identity" lets you mention "UserContext" alone
09:18:52 <greymalkin> Ah~
09:18:55 <greymalkin> !
09:19:03 <greymalkin> Interesting.
09:19:12 <monochrom> this is why it is so important to show actual code, as opposed to hide actual code by inventing homebrew notation
09:19:37 <monochrom> did I tell you a true story about homebrew notation?
09:20:37 <monochrom> I have a computer tech support friend. one day he goes to a small company (10 employees) to install new software. the employees ask him "is this new software compatible with 1048?"
09:20:51 <monochrom> can you guess what they mean by 1048?
09:21:10 <phaazon> yeah
09:21:17 <phaazon> it’s a typo
09:21:21 <phaazon> for the 2048 game
09:21:22 <phaazon> ahah
09:23:23 <sm> go on then, what is it
09:23:27 <monochrom> they invented their insider homebrew notation 1048 to mean 1024x768 monitors
09:23:38 <sm> ah! of course!
09:23:56 <monochrom> and they go on to speak like everyone outside their little self-congratulation circle already knows their insider notation
09:24:34 <monochrom> every author of every homebrew notation thinks that everyone in the world knows. clearly.
09:24:50 <SrPx> Hello, does anyone with better hackage skills know if there is a type inferencer for the elementary affine logic there? I couldn't find exactly that
09:27:51 <bitemyapp> monochrom: that's nuts
09:32:06 <Tuplanolla> I bet they would've loved to know it already has a name (XGA), monochrom.
09:32:56 <zomg> tbh 1028 sounds like an error non tech savvyy people would make :P or they hear the number, then mistake it and start using the word because they think it's technobabble
09:33:11 <monochrom> no, it's 1048.
09:33:29 <zomg> I've seen that sort of thing happen especially with older folks =)
09:33:35 <monochrom> but don't try to understand their logic. there is no logic behind this.
09:34:03 <zomg> unless the people in that company are actually in IT I wouldn't overthink it like that :D
09:34:25 <Gurkenglas> monochrom, does that rule apply to all the type declaration keywords, or just "type"?
09:34:36 <monochrom> just "type"
09:34:44 <zomg> hell, even our company's CEO gets tech words wrong all the time despite the fact we're definitely a tech company :p
09:35:16 <zomg> then he keeps repeating it everywhere until someone corrects him
09:37:15 <zmbmartin> Intolerable: so I am not sure what you mean by unwrap? I have a Value Object. I know that Object is Hashmap text value.
09:37:41 <zmbmartin> Well I guess a Value
09:37:57 <zmbmartin> But how do I use that as a hashmap.
09:37:57 <Intolerable> pattern match on both values to make sure they're both Objects
09:38:15 <Intolerable> get the internal HashMap Text Value structures
09:38:16 <indiagreen> zmbmartin: merge (Object x) (Object y) = Object (x <> y); merge _ _ = error "not objects"
09:38:22 <Intolerable> like that
09:38:49 <fractalsea> How do I import modules in my cabal test-suite that are from other-modules (not exposed-modules) in my main library?
09:39:26 <zmbmartin> Intolerable: Awe I see. I keep messing that up. Thanks!
09:41:50 <DanC> a while back, I asked about parallelism in the haskell compiler and somebody referred me to a tale of woe involving global access to CLI arguments; can anybody help me find it?
09:42:38 <sm> to strictify somefield :: Maybe Char, do you put the ! before Maybe only ? (I'm trying out https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#dealing-with-laziness)
09:43:03 <Intolerable> !(Maybe Char)
09:43:04 <glguy> fractalcat: You move the module out of other-modules and into exposed-modules. A common practice is to split a module into "MyModule" and "MyModule.Internal"
09:44:14 <sm> Intolerable: thanks. And how about [SomeType].. just ![SomeType], not [!SomeType] or ![!SomeType], right ?
09:44:18 <fractalsea> glguy: Thanks. I had considered doing that, but ideally wanted to keep the modules hidden. I guess that’s my only option
09:45:40 <glguy> It's not a great idea to keep the internals completely and unavoidably hidden if you plan on having other users at some point who might want anything at all you hadn't thought of
09:46:17 <sm> DanC: searching on your name in the channel log should find it
09:46:45 <DanC> ah! I have my own logs, but I was on a different machine at the time. Thanks...
09:46:58 <blackdog> fractalsea: yeah, it's generally a social contract. if it's in Internal, people can use it but are on notice that it could change at any point
09:46:58 <sm> or at http://ircbrowse.net
09:46:59 <fractalsea> glguy: Good point
09:47:43 <fractalsea> Makes sense. I have needed internal functions from libraries when testing before, I guess there’s no harm in exposing provided it’s clearly internal
09:48:09 <DanC> sm, any suggestions on how to search several years of logs for my name?
09:48:34 <DanC> ahha... http://ircbrowse.net/browse/haskell?q=DanC
09:58:39 <Phillemann> Is there a function Int -> [a] -> [a] that removes the n-th element of a list?
09:59:09 <indiagreen> Phillemann: no, but you can use splitAt for that
09:59:44 <mniip> sounds like a waste of cons cells
10:00:37 <Tuplanolla> What's the ideal way to start the default editor? Just System.Process.system "editor"?
10:01:17 <Tuplanolla> I'm essentially replicating GHCi's :e.
10:01:48 <mniip> Tuplanolla, fromMaybe "ed" <$> lookupEnv "EDITOR"
10:02:37 <Tuplanolla> Looks like I don't have EDITOR set in the first place.
10:02:46 <Tuplanolla> To the source!
10:03:50 <Tuplanolla> Here it is: https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L1262
10:04:04 <Phillemann> indiagreen: So something like this "let ifilter n = uncurry (++) . second tail . splitAt n"
10:04:16 <Phillemann> Fun to write, small stuff like that. :)
10:04:47 * indiagreen folds arms
10:05:18 <indiagreen> and a bit cruel to any newbie who ends up reading your code
10:05:34 <Phillemann> What would be the newbie-safe version? Explicit recursion? :)
10:06:07 <indiagreen> let deleteNth n s = let (l,r) = splitAt n s in l ++ tail r
10:06:19 <indiagreen> I'd say “ifilter” is a bad name, too
10:06:30 <Phillemann> Yeah, you're right.
10:06:45 <blackdog> also they both fail with the empty list.
10:07:04 <indiagreen> replace tail with drop 1, then
10:07:07 <Phillemann> Well yeah, I don't care about that case. Forgot to mention. :)
10:08:01 <mniip> but that's inefficient!
10:08:06 <blackdog> Phillemann: totality 4eva
10:08:16 <Phillemann> :D
10:08:30 <ChristianS> Phillemann: writing partial functions (that fail on some inputs) is hardly a good idea
10:08:50 <blackdog> mniip: eh. if it shows up in profiling you can write a hand-optimised version.
10:09:27 <mniip> deleteNth n [] = []; deleteNth 0 (x:xs) = xs; deleteNth n (x:xs) = x:deleteNth (n - 1) xs
10:09:35 <paul0> anyone here has experience with yesod? http://lpaste.net/137095
10:09:39 <zmbmartin> I see how to use merge as Intolerable showed me, but I am not sure how to use it here. Really what I want to do is have something like virtual fields. Meaning in the db a user has a firstName and lastName, so I would like to add fullName to the json.
10:09:41 <Phillemann> In general, I care about corner cases, yes. In this case, my not-caring is due to my current bad architecture.
10:10:02 <blackdog> Phillemann: i think we call that learned helplessness
10:10:17 <indiagreen> zmbmartin: do you want to have fullName in your Haskell records, or your generated JSON?
10:10:27 <Phillemann> The reason I need this function is because stuff is...wrong. ;)
10:10:46 <zmbmartin> indiagreen: Just the generated JSON.
10:11:03 <blackdog> Phillemann: unfixably wrong?
10:11:25 <blackdog> i noticed that when i started to get a bit hard-arsed about always being honest in types, lots of problems went away
10:11:29 <zmbmartin> indiagreen: I tried a few ways with mergeObj in the ToJSON instance for SecureUser, but kept hitting errors.
10:11:44 <blackdog> Phillemann: NELists and that sort of thing
10:11:58 <Phillemann> blackdog: No not unfixable. And I also noticed that the more types I throw at things, the better they get. :)
10:12:11 <blackdog> to my shame, i was representing domains as Text in my main app
10:12:31 <blackdog> you wouldn't believe how many sneaky bugs i found by turning it into something more structured, actually checking the tld, that sort of thing...
10:12:36 <indiagreen> zmbmartin: well, you can simply add a field like this: “toJSON x{..} = object ["first" .= firstName, "last" .= lastName, "full" .= firstName ++ ' ' : lastName]”
10:12:37 <sm> there's no point in strictifying type B = (A,A) as type B = !(A,A), right ?
10:12:51 <Phillemann> I have a game where I have objects and collisions. After detecting collisions, I have a list of (CollisionIndex,OtherStuff). And I'd like to delete the objects by index.
10:13:10 <indiagreen> if this isn't what you want, please paste code or give a link to the previous paste or something
10:13:36 <mniip> sm, that's not valid syntax
10:14:05 <sm> mniip: ok, good
10:15:10 <DanC> aha! found the discussion: http://ircbrowse.net/browse/haskell?id=13957476&timestamp=1344474950#t1344474950 <DanC> 	is the compiler single-threaded? it doesn't seem to use more than 1 core
10:15:20 <DanC> 2012-08-09 03:15:50 +0200	
10:16:49 <DanC> 2012-08-09 03:20:30 +0200	<danil> 	DanC: http://www.aosabook.org/en/ghc.html , look for "crime doesn't pay"
10:17:26 <eze> how would you store an either datatype in a database?
10:17:50 <mniip> at what level of abstraction
10:18:09 <jonashw> I would use 3 columns: 1 to signify Left/Right, 1 nullable 'Left' column, 1 nullable 'Right' column
10:19:05 <eze> I am working in java, and basically I have a situation where if a certain condition holds I need to store an enum of type A and if it doesn't an enum of tyoe B
10:19:54 <eze> and I was wondering if there is an standard way of doing something like that
10:21:15 <jonashw> @eze, you could also use two different tables.. if LEFT create a row in the LEFT table, linking to the owning object via a Foreign Key or the like..
10:21:15 <lambdabot> Unknown command, try @list
10:21:18 <jonashw> eze, you could also use two different tables.. if LEFT create a row in the LEFT table, linking to the owning object via a Foreign Key or the like..
10:21:52 <eze> I thought about that
10:22:47 <eze> but I should consider if that is the best solution. Additionally I have an inyective relationship beetween the tyoes
10:22:56 <zmbmartin> indiagreen: Like something along these lines https://gist.github.com/codedmart/a180550b70ecb3f440af/edit
10:23:09 <eze> sorry, not inyective but total
10:23:30 <eze> every value of type A has an associated value of type B
10:24:31 <eze> but if I have something of type A I need to store both values
10:24:34 <indiagreen> zmbmartin: the same way you can delete "password" from it, you can add "fullname" by doing HashMap.insert "fullname" (...)
10:26:12 <indiagreen> Object . HashMap.delete "password" . HashMap.insert "fullname" (Text (firstName user <> " " <> lastName user)) $ obj
10:28:18 <zmbmartin> indiagreen: Thanks!
10:30:24 <inck> hi all haskell n00b here , I have quick question
10:30:41 <inck> I saw this in pattern and didnt' quite understand what it means
10:31:16 <inck> for instance data MyCar = Sedan !Int | Truck !Int
10:31:28 <inck> what do the bangs(!) mean ? 
10:31:33 <mauke> strictness
10:31:43 <arkeet> they make the constructors strict.
10:31:57 <arkeet> it's like writing Sedan $! x instead of Sedan x everywhere.
10:32:06 <arkeet> f $! x = x `seq` f x
10:33:33 <mauke> a function f is called strict in its argument if f _|_ = _|_
10:34:19 <inck> ok so basically its putting a restriction on the Int to not be lazily evaluated ?
10:34:26 <arkeet> more or less.
10:34:35 <mniip> more
10:34:35 <inck> thanks arkeet
10:34:39 <mniip> more like,
10:34:43 <arkeet> it prevents you having Sedan of some unevaluated thunk lying around.
10:34:55 <mniip> when the constructor is demanded, the int is demanded too
10:35:14 <mniip> which means that an evaluated constructor can't contain an uevaluated thunk
10:35:40 <inck> awesome that makes alot of sense 
10:35:41 <mniip> although I like mauke's description more, as it doesn't delve into details of the STG machine
10:35:48 * hackagebot opaleye 0.4.0.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.4.0.0 (tomjaguarpaw)
10:36:02 <inck> the STG machine ? sorry I'm a bit daft
10:36:22 <inck> ah just grep'd it
10:36:23 <chpatrick> inck: it's the conceptual machine that haskell compiles to
10:36:33 <mauke> ... in ghc
10:36:34 <mniip> it's the system behind lazy evaluation in GHC
10:36:58 <mniip> it's hardly conceptual
10:38:04 <chpatrick> mniip: it's not an actual VM though
10:38:08 <chpatrick> is what I was getting at
10:39:20 <maerwald> I am imagining that (=) would be a function... what would the type be? :D
10:39:44 <chpatrick> u wot
10:39:48 <maerwald> haha
10:40:20 <anohigisavay> hi guys
10:40:22 <anohigisavay> http://lpaste.net/137097
10:40:24 <mauke> Pattern -> Expr -> Decl
10:40:30 <mniip> chpatrick, why would it be a VM
10:40:39 <mniip> it's a pretty much real M
10:40:59 <mauke> anohigisavay: because you claim your function returns Either Int Bool
10:41:07 <mauke> anohigisavay: and you return the result of +, which is in Num
10:41:09 <chpatrick> I mean I didn't want to say VM because then people think it's like the JVM or something
10:41:21 <anohigisavay> mauke: OH, thanks :)
10:41:31 <anohigisavay> was being stupid
10:41:52 <mniip> the STG machine paper basically describes how to outline closures in hardware, and how to work with demand semantics
10:42:06 <mauke> misread as damned semantics
10:42:14 <mniip> GHC implements that
10:42:26 <chpatrick> yes but there's nothing actually interpreting haskell and emulating the machine
10:42:41 <mniip> the CPU is running the machine
10:42:47 <chpatrick> it's a compile-time concept
10:42:52 <mniip> not really
10:43:17 <mniip> closures and demand are very much runtime things
10:43:28 <chpatrick> by that logic you could say that helloworld.c is running in the hello world machine
10:43:37 <chpatrick> because printf is a runtime thing
10:43:51 <blackdog> chpatrick: http://conal.net/blog/posts/the-c-language-is-purely-functional
10:44:19 <chpatrick> not sure how that's related blackdog
10:44:32 <chpatrick> I mean it's just semantics in the end, no pun intended :)
10:44:59 <blackdog> you have to squint a bit :)
10:45:06 <chpatrick> it's just that if someone told me that haskell runs on the STG VM that would sound false since there's no actual code emulating the machine
10:45:11 <chpatrick> the compiled code IS the machine
10:45:26 <mniip> no one ever said VM
10:45:36 <chpatrick> yeah, because I said conceptual machine instead :)
10:45:46 <chpatrick> and you took offense
10:54:26 <kzisme> http://pastebin.com/VjRu1tRw - can someone explain these few lines to me I'm having trouble understanding them 
10:55:07 <mauke> looks like two objects are created and then a method is called
10:55:07 <jonashw> kzisme, is that Java code?
10:55:12 <kzisme> c#
10:55:24 <mauke> why not ask a C# channel?
10:55:41 <jonashw> C# != Haskell
10:55:51 <kzisme> this is true 
10:55:54 <mauke> C# /= Haskell
10:55:57 <kzisme> I'm sorry
10:56:03 <jonashw> mauke, I was writing it in C# :p
10:57:52 <Denommus> C# is not a valid identifier in C#
10:58:32 <orion__> anyone have a sec to help a total haskell newb?
10:58:40 <chpatrick> shoot
10:58:49 <mauke> don't ask to ask; just ask
10:59:18 <mizu_no_oto> orion_: typical irc style is to just write your question; anyone who knows the answer and has time will help.
10:59:19 <orion__> trying my hand at my first haskell program - a toy problem where its a game with rooms and objects.  Thinking through it from imperative land it would work like this... https://gist.github.com/anonymous/ff237f949bef0e1e3f92
10:59:31 <orion__> but this is obviously not working
10:59:48 <orion__> since the game needs to know about the rooms and objects, the room needs to know what objects it has and the object needs to know where it is
11:00:59 <orion__> All I can think to do is generate unique id's for everything - basically implementing points and having a top level map of id->object 
11:01:19 <orion__> but then I have basically invented dangling points and hwatnot
11:01:35 <orion__> *pointers
11:01:37 <mizu_no_oto> orion_: why does the object need to know where it is?
11:02:42 <orion__> so I dont need to do a depth first search of the whole game world when operating on an object
11:02:47 <sm> orion__: it is possible to "tie the knot" so that your objects all reference each other
11:03:00 <mizu_no_oto> But at any rate, you could try tying the knot: https://wiki.haskell.org/Tying_the_Knot
11:03:02 <orion__> say the object was a bell and it dings and I want to know whos in the room and can hear it (arbitrary example)
11:03:04 <mauke> sm: that makes updates practically impossible, though
11:03:31 <orion__> so "tie the knot" is the right way to approach this
11:03:32 <orion__> ?
11:03:36 <chpatrick> I don't think so personalluy
11:03:40 <sm> mauke: maybe so.. because you have to re-tie knots all over after each update, which is inefficient ?
11:03:41 <Tuplanolla> Probably not.
11:03:45 <orion__> I'm assuming theres just a different paradigm I need 
11:04:08 <orion__> having written similar things in C/ruby/java
11:04:10 <mauke> sm: if you update one thing, you have to recreate the world
11:04:29 <Tuplanolla> If you need graph-like structures, you might as well use identifiers, orion__.
11:04:34 <mauke> and for that you basically have to know how many objects you have and how they're arranged
11:04:41 <orion__> If the world was just a list or map of all the rooms and all the objects this would be pretty easy - its the two way references 
11:04:41 <mauke> because you can't check for cycles directly
11:04:45 <maerwald> tying the knot is basically horrible for anything more complicated than a doubly linked list
11:05:00 <mauke> it's already horrible for doubly linked lists
11:05:01 <orion__> which makes me want to just store RoomId and ObjectId for quick reference but then I've basically re-implemented pointers in haskell
11:05:04 <maerwald> mauke: ^^
11:05:12 <mizu_no_oto> orion: if the action that you need to take with an object needs the room, you could just have it be a function from Room -> a
11:05:30 <kuribas> maerwald, phaazon: I got it figured out...  So I have a Behaviour (GlobalState -> GlobalState), which chooses a behaviour based on the tool which is active.  So the behaviour can still be programmed locally.  Clicking the toolbar will swap the behaviour.
11:05:31 <sm> I do it in hledger, for the parent-child relationships in the account tree. But just once..
11:05:51 <maerwald> kuribas: do you upload the code somewhere?
11:06:04 <kuribas> maerwald: no code yet :-P
11:06:07 <maerwald> :o
11:06:28 <mizu_no_oto> orion_: i.e. whatever calls the 'ring' function on the bell knows what room the bell is in, and just passes that into the ring function.
11:06:30 <david____> is this message coming through?
11:06:38 <mauke> david____: no
11:06:54 <david____> mauke: i’ll take that as a yes
11:07:12 <mauke> you're only coming through in waves. your lips move but I can't hear what you're saying.
11:07:28 <david____> mauke: when i was a child…
11:07:34 <orion__> hmm
11:07:54 <chpatrick> it's a tricky one orion
11:08:27 <orion__> this is my go-to learn-a-new-language-problem... might be a bad fit - :p
11:09:07 <orion__> how does bittorrent client sound?  good fit for haskell?
11:09:12 <chpatrick> yes I think so
11:09:12 <mauke> I'd start by reimplementing the standard list library
11:09:19 <mauke> and then a command line calculator
11:09:31 <kuribas> maerwald: I had some GUI code with an adhoc imperative event system, but it was a horrible mess to solve the dependencies, which I hope to solve with FRP.
11:09:31 <Tuplanolla> Board games are great too.
11:10:20 <kuribas> If anyone wants to port my chessboard interface to haskell :) https://github.com/kuribas/gcboard
11:10:25 <Eduard_Munteanu> I was an FRP coder just like you, but then I took an Arrow to the knee.
11:10:42 * glguy sets mode +q Eduard_Munteanu
11:10:51 <Fuuzetsu> kuribas: why did you not write it in Haskell to begin with? ;)
11:11:02 <Fuuzetsu> glguy: well deserved
11:11:05 <kuribas> Fuuzetsu: I didn't know haskell
11:11:37 * Eduard_Munteanu struggles to make sounds
11:12:06 <kuribas> Eduard_Munteanu: you mean arrows make FRP unnecessary?  how?
11:12:31 <Eduard_Munteanu> kuribas, no, don't mind me :)
11:13:00 <blackdog> Eduard_Munteanu: *groooan*
11:13:57 * sm fails to not lol
11:14:04 <sm> now I can't shake the image of Eduard_Munteanu taking an Arrow to the knee
11:15:04 <kuribas> Eduard_Munteanu: never should have come here
11:15:37 * Eduard_Munteanu spoiled the whole discussion :(
11:16:21 <kuribas> Eduard_Munteanu: never mind, stupid joke of mine...
11:18:48 <kuribas> I've been wanting to port my library to haskell, but I haven't found time.
11:19:34 <kuribas> There are surprisingly few haskell desktop apps.
11:20:25 <orion__> Hmmm... not ready to give up on the game as a first program yet - Maybe I can think of ways to not need looping pointers...  Ok - random idea for a thing with multiple relationships...   Lets say items have owners... there is compass that will always point toward its owner and the owner can enter a command to know where their item is... how would this be represented in the GameState data structure since I cant have poin
11:20:26 <orion__> ters both ways.
11:21:41 <aweinstock> kuribas: it's not fully generic across all chesslike games like yours, but I wrote a chess game in haskell: https://github.com/aweinstock314/chess-server
11:22:10 <kuribas> aweinstock: nice, is it live?
11:23:32 <orion__> or "give up - it's not going to work well in haskell"
11:23:42 <aweinstock> kuribas: I'm not running a server of it anywhere, if that's what you're asking
11:24:34 <aweinstock> (and I'm not sure it'll scale to more than a few tens of players connected at once, since I'm not sure if the underlying libraries do fancy things with file descriptor pooling)
11:25:48 <kuribas> orion__: you can name your items, or give them unique IDs.
11:26:12 <orion__> kuribas: ok - so kind of like C pointers 
11:26:19 <kuribas> yes
11:26:33 <orion__> and have a find function and logic to deal with dangling pointers 
11:26:37 <orion__> makes sense
11:26:58 <orion> My IRC client is abuzz.
11:27:13 <orion__> then the game logic would be a big Map[Id] that I would treat like main memory in C, and each Record would be { Id,Id,Id,Id }
11:27:26 <orion__> orion: haha
11:28:47 <mizu_no_oto> orion_: How are you going to have your objects act?
11:29:50 <orion__> not planning on finishing this - but the idea is to write a simple MUD.  Its a great toy problem I always use when leaning a new language - it has complex iter-object relations, networking, text parsing and database access
11:30:03 <orion__> kind of cover my bases
11:30:20 <bberry> From what i can tell, Int are similar to C's int, and Integer is just an unbounded Int.  How does Integer work under the hood though?  For example, what is the threshold at which Integer begins to lose precision?
11:30:20 <monochrom> I understand the sentiment
11:30:31 <mauke> bberry: never
11:30:36 <mauke> bberry: it uses gmp internally
11:30:50 * hackagebot hakyll-agda 0.1.10 - Wrapper to integrate literate Agda files with Hakyll  https://hackage.haskell.org/package/hakyll-agda-0.1.10 (FrancescoMazzoli)
11:31:18 <Tuplanolla> "The first argument of ($) takes one argument, but its type `ParsecT s0 u0 m0 () -> Map k0 a0' has only one", nice.
11:31:45 <orion__> somewhat familiar with FP from some Erlang experience but totally new to haskell
11:32:28 <monochrom> similarly, a person who speaks American English natively, can use "the project of watching a movie and writing a movie review, both in language L" to learn British English, Australian English, Jamaican English, Singapore English, and Hong Kong English. all these learning projects will have predictably great success.
11:32:29 <bberry> mauke, oh nevermind, i misread what LYAH was saying, thanks :D
11:32:39 <zmbmartin> How can I pattern match against one item in a data type without doing (User _ _ _ email _ _ _)? Meaning is there a shorter way to do that?
11:32:49 <orion__> Records
11:32:51 <monochrom> and equally predictably, it is going to fall flat on its face on Japanese and Korean
11:32:53 <mauke> zmbmartin: you can make it a record type
11:33:15 <orion__> where User { email=email } = user
11:33:30 <mizu_no_oto> orion_: what I mean is, how are you going to get each item to do what it's supposed to?  Traverse the rooms, calling some act function on each of their Objects?
11:34:44 <orion__> mizu_no_oto: actions would come from either player input (from the network) -- someone types "locate object" -- or from scripts attached to objects (lets say some lua for sake of simplicity) that fire on a timer or on triggers from other actions happening nearby
11:35:50 * hackagebot exceptional 0.2.0.0 - Essentially the Maybe type with error messages.  https://hackage.haskell.org/package/exceptional-0.2.0.0 (pharpend)
11:36:24 <cubr> Hey!
11:37:07 <cubr> I'm doing the short introductory tutorial on Haskell.org and I was wondering what's going on here:
11:37:10 <cubr> let abc@(a:b:c) = "cat" in (abc,a,b,c)
11:37:16 <cubr> this returns ("cat",'c','a',"t")
11:37:23 <cubr> whereas I would've expected ("cat",'c','a','t')
11:37:42 <cubr> How come "t" is returned as a string instead of a char?
11:37:49 <kadoban> :t (:)
11:37:50 <lambdabot> a -> [a] -> [a]
11:37:51 <blackdog> cubr: "cat" is a list of characters, right?
11:37:57 <cubr>  Yes
11:38:07 <mniip> > let (a:b) = "hello" in (a, b)
11:38:09 <lambdabot>  ('h',"ello")
11:38:15 <cubr> Ohh
11:38:16 <blackdog> so a & b are elements of the list, but c is the rest of the list
11:38:17 <cubr> I see
11:38:17 <kadoban> cubr: The thing on the right of : is a list, not an element of a list.
11:38:25 <cubr> Oh!
11:38:27 <mniip> > let (a:(b:c)) = "hello" in (a, b, c)
11:38:29 <lambdabot>  ('h','e',"llo")
11:38:43 <mauke> > let abc@(a : b : c : []) = "cat" in (a, b, c)
11:38:44 <lambdabot>  ('c','a','t')
11:38:52 <cubr> Ahh, I see it now
11:38:57 <cubr> Thank you!
11:39:06 <zmbmartin> orion__: I just want to match whether the field exists or not and pass it through. 
11:39:37 <monochrom> the field always exists
11:39:53 <zmbmartin> monochrom: I mean is not null/nothing or whatever.
11:40:14 <monochrom> there is no "null".  can it be Nothing?
11:40:29 <zmbmartin> monochrom: Yes sorry I meant Nothing
11:40:43 <monochrom> what is the field's type, such that it can be Nothing?
11:40:59 <zmbmartin> If that field is Nothing I would like to continue on.
11:41:04 <zmbmartin> monochrom: Just Text
11:41:15 <zmbmartin> I mean Maybe Text
11:41:25 <monochrom> what is the declaration of the whole data type?
11:41:54 <zmbmartin> monochrom: https://gist.github.com/codedmart/e704896e07358b28ca5a
11:42:19 <monochrom> what is the field name?
11:42:30 <zmbmartin> I want to do avatarImageUrl
11:42:50 <monochrom> see how it is not called "email" which was in your first question?
11:43:10 <monochrom> see how you're a moving target?
11:43:20 <zmbmartin> monochrom: Sorry the first question was a base example. 
11:43:22 <zmbmartin> My bad.
11:44:04 <monochrom> f User{avatarImageUrl = Just x} = ... x ...
11:45:16 <__009__kk> Does anybody here have any good haskell project ideas? I need something more than toy problems.
11:45:33 <zmbmartin> monochrom: Sorry again and thanks!
11:47:22 <sm> __009__kk: to join, or to start yourself ?
11:47:58 <nitrix> Used my first monads today other than IO, like Socket and Get/Put for binary things.
11:48:07 <kau> Hello!
11:48:38 <__009__kk> sm: either.
11:48:40 <kau> I'm trying to find a function in Control.Lens equivalent to this one from Data.Lens: focus :: Monad m => Lens a b -> StateT b m c -> StateT a m c
11:48:42 <nitrix> That has to be one of my favorite things so far. 6 lines of code, would have been 40 in PHP, and a good 400 in C.
11:48:55 <edwardk> zoom
11:49:01 <nitrix> :t zoom
11:49:02 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
11:49:05 <kau> great, thanks :)
11:49:16 <edwardk> zoom works even when the StateT isn't on the outside of the monad
11:49:24 <kau> I should have infered from the name
11:49:26 <edwardk> hence the ridiculously complicated implementation
11:49:37 <edwardk> there is also magnify for working with reader environments
11:50:20 <kau> I'm trying to migrate from Data.Lens to Control.Lens
11:50:23 <phaazon> https://en.wikipedia.org/wiki/Kan_extension
11:50:25 <nitrix> Don't you have to learn a ridiculous amount of Haskell libraries to keep up with a large unfamiliar codebase?
11:50:32 <phaazon> I seriously need to understand that adjoints stuff
11:50:36 <phaazon> that doesn’t sound that hard
11:50:38 <phaazon> but dammit
11:50:47 <kau> I suppose I just have to drop-in the equivalent functions?...
11:50:48 <phaazon> I really don’t get anything without knowing what it is
11:51:09 <monochrom> adjoint is a lot of memorization rather than a lot of learning
11:51:50 <phaazon> what do you mean?
11:53:35 <monochrom> I decline to say more. I think we all know what memorization looks like
11:54:23 <shachaf> monochrom: I don't know whether that's entirely true.
11:56:09 <phaazon> monochrom: thank you
11:58:07 <b_> Hello, how do i write a: func "prefix" "suffix" "prefixTHETHINGTOEXTRACTsuffix" = "THETHINGIWANT" 
11:58:10 <b_> :(
11:59:00 <kau> b_: with parsec I suppose
11:59:21 <Fuuzetsu> more naive approach: check that the suffix and prefix are what you want and drop the elements
11:59:49 <sm> __009__kk: join hledger! see the world!
12:00:01 <monochrom> b_: Data.LIst.stripPrefix solves half of the problem
12:00:15 <b_> "blahblahprefixTHETHINGIWANTsuffixblahblah" more like
12:00:21 <monochrom> maybe if you don't mind two reverse's, it solves the other half too
12:00:50 <Gurkenglas> b_, what about "          prefixasuffix       prefixbsuffix      "?
12:00:51 * hackagebot halma 0.2.0.1 - Library implementing Halma rules  https://hackage.haskell.org/package/halma-0.2.0.1 (TimBaumann)
12:02:08 <b_> Gurkenglas, sorry i dont understand :( 
12:02:35 <b_> i have a big xml file and i want these embeeded things from it
12:02:36 <Gurkenglas> b_, what should happen if I call your function with the string "p", "s" and "pasxpbs"?
12:03:09 <b_> Gurkenglas, it should return a
12:03:13 <b_> "a"
12:04:04 <sclv> does anyone have any experience using twitter-conduit to post to a timeline?
12:04:10 <sclv> i'm not having much luck using it with oauth
12:05:19 <kau> b_: write a parsec parser
12:05:54 <kau> something like: myParser = (many1 letter) >>= \name -> string "prefix" >> (many1 letter) >>= \name -> string "suffix" 
12:06:16 <b_> kau, i just began haskell , I am having a hard time as it is , coming from a java business app world :(
12:06:23 <kau> I see :)
12:06:58 <hackrilege> sm: whats going down at hledger?
12:07:15 <sm> hackrilege: profiling!
12:07:19 <hackrilege> > "your right hand" =~ "(hand|foot)" :: Bool
12:07:20 <lambdabot>      Not in scope: ‘=~’
12:07:20 <lambdabot>      Perhaps you meant one of these:
12:07:20 <lambdabot>        ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
12:07:32 <kau> b_: let me try to create a gist for you
12:07:54 <sm> someone has turned up with a 300k-transaction journal, which exceeds the 2G limit for 32-bit windows builds
12:08:52 <hackrilege> sclv: i can look into it if you like, i have experience using conduit and i have some alteratives i prefer...
12:09:14 <sclv> its not the conduit thing
12:09:21 <sclv> its twitter/oauth that i don't understand in particular
12:09:30 <sclv> I think i set my tokens and my credentials right
12:09:32 <hackrilege> good!
12:09:41 <sclv> but i keep getting 401 unauthorized
12:09:46 <b_> is there a function which will give me the begin index of "prefix" within the string? then I think i can use drop function?
12:09:52 <hackrilege> they probably arnt right
12:09:55 <sclv> ok
12:10:07 <delcici> b_, what is it that you're trying to do? parse xml?
12:10:22 <b_> then I do same for "suffix" and take till suffix index?
12:11:44 <hackrilege> sclv: honestly I had trouble authenticating using conduit, I got my task done in python and i cant see that it was my error in haskell... i debuged it a lot. sorry for these disparaging words, i simply have the same bug as you, no sollution, but yes, i did find it helpful to try the request using another method
12:12:31 <sclv> i mean i have four keys, consumerkey and consumer secret, and oauth_token and oauth_token_secret
12:12:32 <sm> b_: learning parsec will help for all functions of this kind. If you just want to write it by hand, you can do it with isPrefixOf, isSuffixOf, drop, take etc.
12:12:40 <sclv> and i genereted them all from the twitter app page
12:12:51 <sm> you can look those up in hoogle
12:13:14 <sclv> so i should then be able to plug them in as tokens and credentials respectively, then just call "setCredential tokens credential def" adn use that to pass into "call" methods, no?
12:13:22 <sclv> that's what the code samples imply, but it just busts...
12:13:26 <hackrilege> and the library fails to parse them into a valid request? not your fault...
12:14:39 <ChristianS> b_: Data.List has a stripPrefix function. Data.Text also has stripSuffix and using Text instead of String is generally a good idea anyway.
12:14:39 <monochrom> b_: if you come from Java, then Java's String is Haskell's Text, not Haskell's String. (Haskell's String is Java's LinkedList<Char>, clearly unsuitable for your question.)
12:14:48 <hackrilege> can you post the code, ill try and reproduce the bug on my machine incase i can see anything obvious
12:15:21 <monochrom> Text is from module Data.Text, which has "breakOn" and "breakOnEnd" that sound like your question
12:16:10 <sclv> hackrilege: http://lpaste.net/8503565277873569792
12:16:17 <sclv> that's my "hello world" :-)
12:16:27 <hackrilege> k
12:16:34 <danilo2> Hello! I would like to use lenses with Data.Vector. Unfortunately when trying to use `at` I get error message that ghc could not deduce At(Vector smiting) . Cant we use `at` with vectors?
12:17:02 <monochrom> module Data.Text may or may not be already installed for you. if you use Haskell Platform, then it is. if you only have bare GHC, then no.
12:17:35 <indiagreen> danilo2: no, use ix (at is for Map-like containers)
12:17:52 <danilo2> indiagreen: ok, thanks
12:18:01 <hackrilege> sclv: can i see the example you built it from?
12:19:04 <sclv> hackrilege: just the docs on the web twitter conduit page http://hackage.haskell.org/package/twitter-conduit-0.1.1/docs/Web-Twitter-Conduit.html
12:19:41 <danilo2> indiagreen: hmm, but ix will result in Maybe value, am I right? Vectors allow accessing values by int index in O(1) and I want to use this feature in Lenses
12:19:44 <sclv> hackrilege: also ties out with the code samples: https://github.com/himura/twitter-conduit/blob/master/sample/Common.hs
12:19:48 <sclv> thanks again for your help
12:21:02 <indiagreen> danilo2: getting a Maybe a is O(1) as well, but if you want it to crash instead (if the index is out of range) you can use ^?! instead of ^?
12:21:02 <hackrilege> they have a main routine in the first link, did you try this?
12:21:15 <sclv> i'll try their main as well, see if its different.
12:21:16 <sclv> sec
12:22:08 <t-l-o> Hi all, does anyone know of a SSE (Server-sent events) client for Haskell? (see also http://stackoverflow.com/q/31571490/1306877 )
12:22:48 <sclv> hackrilege: getting an "Authorization Required" for that routine too
12:22:59 <sclv>  [TwitterErrorMessage {twitterErrorCode = 32, twitterErrorMessage = "Could not authenticate you."}]
12:23:27 <sclv> hackrilege: doh! figured it out
12:23:30 <sclv> stupid error on my part
12:23:33 <sclv> as it always is :-)
12:23:37 <sclv> left some whitespace in a pasted token
12:23:42 <sclv> sorry for the bother and thanks for the help
12:24:11 <danilo2> indiagreen: out of curious - will This maybe combined with fromJust optimised by GHC in such way that it will be completely cut out? That is my main concern asking about it because it will be used in performance - critical code
12:24:37 <hackrilege> t-l-o: i think i have achieved something similar in haskell, i hadnt seen it done so neatly as that python package, id love to hear if anyone knows of this in haskell...
12:25:03 <hackrilege> sclv: im glad you got your bug! good luck
12:25:09 <jackhill> win 29
12:26:33 <t-l-o> hackrilege: which libraries did you use?
12:27:00 <hackrilege> danilo2: someone should check this is right, but as i understand it things like pattern-matching will be handled by the compiler and so will not influence performance speed? 
12:27:29 <indiagreen> danilo2: no idea. First of all, there'll be 2 bounds checks instead of 1 if you use Vector.!, and 0 if you use unsafe indexing (somewhere in Data.Vectors).
12:28:20 <indiagreen> really, Haskell's performance is hard to speculate about, so if I was you I'd benchmark
12:31:59 <danilo2> indiagreen: ok, thanks! I will check it by myself then! :)
12:33:32 <hackrilege_> I think http-client is the highest level actually, there are some functions maybe you can use; https://hackage.haskell.org/package/http-client-0.4.18/docs/Network-HTTP-Client.html
12:34:37 <blackdog> hackrilege_: http-client is pretty good, but it explicitly isn't high-level
12:35:04 <hackrilege_> am i confusing high and low level?
12:35:38 <hackrilege_> perhaps this too is what you are after; but maybe really you want a list of tcp packets? https://hackage.haskell.org/package/websockets-0.9.5.0/docs/Network-WebSockets-Stream.html
12:36:17 <hackrilege_> so low level is built on top... seems backwards
12:37:41 <Sindriava> Hey all!
12:39:11 <t-l-o> hackrilege_: thanks, I'll look into these libs
12:39:44 <hackrilege_> t-l-o: can i ask about what specific functionality of the python sse library you are trying to emulate?
12:41:05 <hackrilege_> Sindriava: hi!
12:41:53 <hackrilege_> can anyone give me a simple example of a lens in use?
12:42:01 <t-l-o> hackrilege_: Basically I'd like to subscribe to a REST API that supports SSE to get real-time updates. I want to avoid polling the server.
12:42:21 <hackrilege_> what format are these updates?
12:42:22 <Sindriava> hackrilege_: FPComplete has a good article on lenses, called "Basic lensing"
12:42:23 <edwardk> > (1,"hello") & _2 %~ length
12:42:24 <lambdabot>  (1,5)
12:42:43 <hackrilege_> oo!
12:43:20 <edwardk> > ("hello","world") & both.traverse %~ toUpper
12:43:22 <lambdabot>  ("HELLO","WORLD")
12:44:39 <edwardk> > "hello" & ix 0 .~ 'j'
12:44:40 <lambdabot>  "jello"
12:44:43 <edwardk> etc.
12:44:56 <hackrilege_> t-l-o: ok, by the sounds of it the libraries i linked should do that, ill keep an eye on the stack exchange post, id love to see a simple example of the functionality you require implemented in haskell with the correct access point to the existing haskell web libraries. it would be great for other python users im sure if this is the common way to handle these streams in python
12:45:37 <t-l-o> hackrilege_: It's the firebase API: https://www.firebase.com/docs/rest/guide/retrieving-data.html#section-rest-streaming A very simple example is this: https://hacker-news.firebaseio.com/v0/topstories.json (just a list)
12:45:40 <hackrilege_> :t _
12:45:41 <lambdabot>     Found hole ‘_’ with type: t
12:45:41 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
12:45:41 <lambdabot>                the inferred type of it :: t at Top level
12:45:54 <hackrilege_> :t _2
12:45:55 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
12:45:59 <hackrilege_> !?
12:46:08 <mauke> _2 is a function
12:46:15 <hackrilege_> ok
12:46:51 <mauke> also, all of the lens operations have crazy types
12:47:08 <hackrilege_> :t (& _2)
12:47:09 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
12:47:17 <edwardk> _2 f (a,b) = (,) a <$> f b
12:47:29 <edwardk> x & f = f x
12:47:41 <hackrilege_> :t (&)
12:47:42 <lambdabot> a -> (a -> b) -> b
12:48:00 <edwardk> l %~ f = runIdentity . l (Identity . f)
12:48:03 <mauke> :t _2 %~ length
12:48:04 <lambdabot> (Foldable t1, Field2 s t (t1 a) Int) => s -> t
12:48:07 <edwardk> l .~ a = l %~ const f
12:48:22 <edwardk> both f (a,b) = (,) <$> f a <*> f b
12:48:30 <hackrilege_> ah ok, so (& _ 2) = (2 _), im wondering why you didnt write that?
12:48:32 <edwardk> that should be everything you need for most of the examples i supplied above
12:48:41 <mauke> hackrilege_: what?
12:48:47 <edwardk> hackrilege_: because it reads a bit nicer this way when you use lots of updates
12:49:01 <edwardk> big scary record & field1 .~ something & field2 .~ something else & ...
12:49:08 <edwardk> read the & as 'and'
12:49:11 <edwardk> and it reads right
12:49:18 <edwardk> otherwise you are swimming in parentheses
12:50:21 <hackrilege_> edwardk: cool!
12:50:35 <phaazon> hm
12:50:38 <phaazon> from Wikipedia:
12:50:42 <phaazon> In mathematics, specifically category theory, adjunction is a possible relationship between two functors.
12:50:45 <phaazon> so…
12:50:51 <phaazon> it’s like natural transformations?
12:51:11 <johnw> not quite like that
12:51:16 <blooqs> What is 'Hask' ? is it a built in type or something?
12:51:16 <phaazon> meh :(
12:51:22 <hackrilege_> t-l-o: sorry, didnt see your post, checking the links now
12:51:23 <johnw> if f -| g, then f x -> y ≅ x -> g y
12:51:39 <johnw> (where here by -> I just mean hom sets)
12:51:40 <phaazon> f x -> y
12:51:48 <phaazon> so hm
12:52:01 <phaazon> what does f x mean here?
12:52:10 <johnw> like Maybe x
12:52:14 <phaazon> compositionC?
12:52:15 <phaazon> -C
12:52:42 <blooqs> edwardk: what is 'Hask'? http://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html#v:second
12:53:16 <mizu_no_oto> blooqs: Hask is the category with Haskell datatypes as objects and Haskell functions as arrows
12:53:28 <phaazon> I don’t get that notation, johnw 
12:53:32 <phaazon> hom sets
12:53:49 <johnw> if f is a Functor, then f x is f applied to a type
12:54:16 <phaazon> so f x is the sets of applied stuff?
12:54:19 <phaazon> set*
12:54:21 <hackrilege_> can anyone give the syntax for receiving a json formated post from a server in haskell? keeping it as a bytestring is ok. 
12:54:30 <johnw> phaazon: I'm not really sure what you're saying...
12:54:50 <phaazon> johnw: well
12:54:57 <blooqs> mizu_no_oto: so  ""Formally, the class Bifunctor represents a bifunctor from Hask -> Hask." means "a bifunctor from Hask to Hask" ?
12:54:57 <phaazon> I know the syntax for functiors
12:54:58 <phaazon> like
12:55:06 <phaazon> a functor F : C -> D
12:55:11 <phaazon> but I don’t know F X
12:55:13 <johnw> so, in Haskell, if f -| g, then you should be able to write two functions:
12:55:14 <megajizz> I'm a Python programmer wondering which languae I should learn second: C or Haskell. I'm wondering which would be the easier transition: going from C to Haskell or from Haskell to C? Thanks in advance.
12:55:21 <mauke> hackrilege_: why would there be special syntax for that??
12:55:26 <johnw> to :: (f x -> y) -> (x -> g y)
12:55:32 <johnw> and from :: (x -> g y) -> (f x -> y)
12:55:39 <johnw> if you can, you've at least proven adjunction
12:55:52 <johnw> a good first exercise for this is to do it for (,) -| (->)
12:55:54 <phaazon> oh, you mean f x in haskell
12:55:59 <nitrix> megajizz: I spent 2 years learning C inside and out. You'll see I'm a well known name in ##c and could probably answer the most cryptic answer.
12:56:06 <phaazon> I thought you were going denotational
12:56:15 <phaazon> I saw the notation hom_c(FY,X) on wikipedia
12:56:18 <phaazon> and I don’t get it
12:56:19 <phaazon> like
12:56:25 <phaazon> I don’t get it at all
12:56:26 <johnw> hom_c(FY,X) in Haskell is f y -> x
12:56:35 <Sindriava> megajizz: Neither transition is relevant. They are pretty different.
12:56:40 <nitrix> megajizz: From my experience, I see more value from Haskell currently, but I think you need to go through C to understand that added value.
12:56:48 <blooqs> mizu_no_oto: or does it mean - from the category of objects (Hask -> Hask) to another category?
12:56:48 <phaazon> ok
12:56:58 <Sindriava> nitrix++
12:57:01 <mizu_no_oto> blooqs: it means that it's a bifunctor in the categorical sense.  the Functor typeclass, too, is a (category-theoretic) functor from Hask to Hask
12:57:02 <johnw> a "hom set" in Hask is a function type, representing the set of all functions of that type
12:57:03 <mauke> nitrix: https://gist.github.com/ivant/1454460 ? :-)
12:57:10 <phaazon> so it basically says that the X set is obtained by applying F on Y?
12:57:12 <Sindriava> megajizz: C is that thing that you should know, but shouldn't use :D
12:57:24 <johnw> the fact that function types are also objects in Hask means that Hask supports "exponentials"
12:57:34 <johnw> phaazon: X and F and Y are not necessarily sets
12:57:52 <nitrix> mauke: 1.
12:57:52 <johnw> hom_c(FY,X) means exactly: the set of arrows from the object FY to X in category C
12:57:53 <phaazon> goddamit
12:57:54 <Sindriava> mauke: I guess that's platform dependent?
12:58:00 <phaazon> isn’t there a beginner tutorial somewhere?
12:58:06 <johnw> phaazon: for category theory?
12:58:13 <phaazon> something that doesn’t show a definition with other dark words
12:58:18 <phaazon> johnw: to adjunctions and hom sets
12:58:20 <blooqs> mizu_no_oto: what im not clear on is the notation .. is the (->) part of the definition of the category or does it apply to the 'to'?
12:58:28 <mauke> nitrix: you shall pass.
12:58:31 <johnw> phaazon: wikipedia and nlab are the two worst places to start
12:58:38 <nitrix> mauke: sizeof 'a' or sizeof (char) is always 1 by definition.
12:58:40 <johnw> phaazon: there are many good books on thi
12:58:51 <mauke> nitrix: bzzt. you shall not pass
12:58:55 <phaazon> so FY is an object?!
12:58:58 <johnw> yes
12:59:01 <nitrix> mauke: whoops
12:59:12 <johnw> F maps objects from some other category into category C, in this case (based on what you've shown me)
12:59:13 <nitrix> mauke: I said sizeof 'a' mindlessly :P
12:59:14 <mizu_no_oto> blooqs: actually, I'm note entirely sure about that
12:59:15 <johnw> that's what Functors do
12:59:18 <kau> another lens question: how do you filter on a field?
12:59:19 <hackrilege_> mauke: I know the libraries to use, but i dont know how to use them! t-l-o is asking about how to do this, i pointed him toward conduit-extra, http-client and http-streams... perhaps someone with experience of using this to receive pposts pushed from the server could indicate how to do this using one of these libraries...
12:59:23 <johnw> so, FY is the mapping of Y into C
12:59:23 <nitrix> Oh well.
12:59:33 <kau> the best I've got is filter (\a -> a ^. myField == b)
12:59:34 <indiagreen> phaazon: there's a series of posts on CT which has lots of cute pig drawings and doesn't contain any scary words, but I somehow started reading it and didn't understand anything anyway
12:59:44 <Sindriava> mauke: Is sizeof(0) well defined?
12:59:53 <kau> which is not super elegant
13:00:03 <mauke> Sindriava: let's take this to #haskell-blah
13:00:03 <phaazon> hm
13:00:05 <phaazon> so
13:00:14 <nitrix> Sindriava: It's not sizeof(0). There's priority of operation, you miss part of the expression.
13:00:14 <johnw> if F : C -> D, and Y ∈ Ob(C), then FY ∈ Ob(D)
13:00:25 <phaazon> Ob(C)
13:00:27 <phaazon> what the fuck.
13:00:28 <phaazon> ok
13:00:29 <phaazon> stop
13:00:30 <phaazon> thanks
13:00:30 <johnw> the objects of C
13:00:44 <nitrix> phaazon: Could you not spam?
13:01:00 <johnw> a category has two things: objects, and arrows.  These are referred to use Ob and Hom, typically
13:01:24 <johnw> (though notation varies sometimes, which is unfortunate)
13:02:05 <Sindriava> Is there a small text editor written in Haskell I could read through?
13:02:13 <johnw> if you give me a category C, and want to talk about some object X in C, you could use the short-hand Ob_C(X).  I'm sorry if I was being unclear
13:02:25 <hackrilege_> nitrix: +1
13:02:54 <megajizz> So, is C to Haskell harder than Haskell to C or not?
13:03:18 <johnw> oh, I confused my own notation there.  It would be X ∈ Ob(C)
13:03:38 <hackrilege_> haha, nnothing could be harder than haskell to C, the only time i try is in high end coding test which i always fail in interviews
13:04:11 <hackrilege_> oh he quit
13:04:33 <johnw> phaazon: a large part of it is really just notation, since the underlying ideas will all be familiar to you by now
13:04:54 <aweinstock> hackrilege_: as in, manually compiling haskell to C (in a whiteboarding context)?
13:08:15 <miscyb_> does anyone know a decent image processing library? I need to be able to get arbitrary pixels and create an image with the results
13:08:30 <miscyb_> that seems like any library should be able to do that
13:08:36 <phaazon> johnw: right
13:08:39 <phaazon> thank you
13:08:49 <nitrix> mechairo`: Most people learn languages thinking it's just a matter of picking a new syntax. With Haskell, you'll need to genuinely learn new theory, which wether you go the C route or not, you'll need to learn either way.
13:09:04 <nitrix> mechairo`: So I don't see how C would speed or slow the process, it may simply delay it.
13:09:06 <miscyb_> i've looked at juicypixels but it confused me as far as getting values and constructing new ones
13:09:10 <hackrilege_> jucy-pixle!!!!!!!!!!!!!
13:09:18 <phaazon> I think I might need to understand (again) that « object » idea; for instance, I don’t understand why a monoid is a category with only one object
13:09:35 <hackrilege_> i think i have a library i wrote 1 sec
13:09:56 <miscyb_> hackrilege_: perhaps an example or two on how to use juicypixels
13:10:03 <miscyb_> i'm a little lost as far as that goes
13:10:05 <phaazon> miscyb_: JuicyPixels is really great
13:10:18 <phaazon> miscyb_: it’s not that hard
13:10:23 <phaazon> get a DynamicImage
13:10:28 <phaazon> (or DynImage, I don’t remember)
13:10:34 <phaazon> and pattern match to extract the right one you need
13:10:38 <phaazon> and rules :)
13:10:47 <johnw> an object is a purely abstract entity, about which you know *nothing* other than what arrows may exist in relation to that object.  For a monoid, the whole of its "functionality" is described by its arrows and how those arrows compose (associatively, with identity, etc).  It's pretty clever how it works out.
13:10:56 <miscyb_> phaazon: I see how to get a dynamic image, but can I use the regular Image functions on it?
13:11:15 <miscyb_> I didn't think I could, nor do I see a way to get an Image out of a DynamicImage
13:11:15 <phaazon> miscyb_: no, because you need to pattern match to extract the pixel format :)
13:11:22 <phaazon> well
13:11:24 <johnw> one thing that's a bit confusing about thinking of CT wrt Haskell programming is that our objects are types, and we generally know a lot about our types
13:11:25 <rowanblush> miscyb_: You have to unwrap the DynamicImage.
13:11:29 <miscyb_> phaazon: how do I know the format?
13:11:43 <johnw> but thinking categorically means knowing nothing at all about objects
13:11:47 <phaazon> case dynImage of { Y8Image pixels w h whatever -> … | _ -> fail }
13:11:47 <rowanblush> miscyb_: The constructors for DynamicImage are exposed, so you pattern match.
13:12:20 <phaazon> johnw: so what’s the monoid’s object? a set?
13:12:33 <johnw> it's nothing at all
13:12:37 <miscyb_> rowanblush: alright I'll give that a shot and come back if I have specific questions
13:12:43 <johnw> it's just an anchor for the arrows, literally
13:12:57 <johnw> it has no content whatsoever
13:13:01 <phaazon> johnw: (R,+) is a monoid where mempty = 0
13:13:08 <phaazon> so you’re saying that ^ is a…
13:13:15 <phaazon> category with no objects but morphisms?
13:13:23 <johnw> there's one object, ⋆
13:13:35 <phaazon> composition?
13:13:45 <Hijiri> wildcard
13:14:04 <phaazon> for instance, I can see a morphism, (+)
13:14:27 <johnw> the type of (+) here is ⋆ -> ⋆
13:14:33 <phaazon> yes
13:14:38 <phaazon> wait
13:14:39 <phaazon> no
13:14:49 <hackrilege> miscyb_: sorry i got disconeccted, are you still here?
13:14:50 <phaazon> how would that even work?
13:14:52 <johnw> oh, wait, you're right
13:14:58 <johnw> one sec, I'm on the phone now
13:16:24 <hackrilege> miscyb_: i can send you an example if you are online!
13:16:28 <phaazon> I guess that’s wrong, since the arrows have to transport objects to objects
13:16:34 <phaazon> and (+) doesn’t
13:16:37 <johnw> you were right, (+) is the composition
13:16:46 <johnw> and mempty is the identity arrow for ⋆
13:16:59 <phaazon> so the objects are…
13:17:17 <hackrilege> i wonder how i managed to do so much with haskell without knowing half the things you are talking about...
13:17:40 <phaazon> hackrilege: a lot of cool libraries use that concepts
13:17:46 <phaazon> and I’m struggling to get them
13:17:58 <hackrilege> what are the <$> and <*> operators?
13:18:18 <phaazon> hackrilege: fmap and « app » for an applicative functor
13:18:19 <Hijiri> (<$>) is fmap, (<*>) is the application operator for Applicatives
13:18:21 <johnw> there's only one object
13:18:30 <phaazon> johnw: that’s the part I don’t understand
13:18:32 <hackrilege> phaazon: im not sure what your talking about as my connection dropped...
13:18:36 <johnw> the "values", as you're used to thinking of them, are all encoded arrows ⋆ -> ⋆
13:18:44 <johnw> so that the "arrow" 5 composed with 3 would be the arrow 8
13:18:54 <johnw> remember, arrows are not functions!
13:18:56 <hackrilege> thanks Hijiri:
13:18:58 <johnw> they can be anything that supports the category laws
13:19:11 <phaazon> right, but what is a the arrow 5?
13:19:29 <phaazon> oh
13:19:31 <johnw> the arrow 5 in this case would be the integer 5
13:19:31 <phaazon> I think I got it!
13:19:35 <johnw> yay!
13:19:47 <phaazon> the we don’t really need objects
13:19:53 <phaazon> way one, btw?
13:19:57 <phaazon> why*
13:20:00 <hackrilege> can we get an example into lambdabot?
13:20:11 <phaazon> hackrilege: length <$> Just "foo"
13:20:15 <phaazon> > length <$> Just "foo"
13:20:17 <lambdabot>  Just 3
13:20:29 <phaazon> > Just (+2) <*> Just 70
13:20:31 <lambdabot>  Just 72
13:20:50 <phaazon> you can compose them
13:20:51 <phaazon> like
13:21:01 <phaazon> > (+) <$> Just 10 <*> Just 3
13:21:01 <guillaum> Suppose I have a function with a State [t] () (so basically, just modifying a list. Is there an easy way (no lens) to modify the list and replace the n'th element by something else. (except writing an helper function with splitAt ?)
13:21:02 <lambdabot>  Just 13
13:21:26 <Hijiri> there might sometimes be cases where it's interesting to relate a monoidal category to other categories
13:21:33 <hackrilege> omg my mind has been blown
13:21:34 <Hijiri> but I don't know any because I don't know enough CT
13:21:52 <geekosaur> guillaum, in general if you want access to a specific element like that, you don't want a list in Haskell
13:21:52 <phaazon> a monoidal category?
13:21:56 <geekosaur> maybe you want a vector
13:21:59 <phaazon> like monads?
13:22:06 <mauke> guillaum: no
13:22:09 <phaazon> hackrilege: keep it cool :)
13:22:11 <Hijiri> I mean a category like we were describing with R and +
13:22:32 <geekosaur> (Functional programming prefers lists to be singly linked lists; you can think of this as a simple loop encoded as data)
13:22:38 <phaazon> it’s not hard, but if you’ve started to learn Haskell lately, you should go easy on yourself :)
13:22:45 <maerwald> > ((((+) .) . (+)) .) . (+) <$> Just 10 <*> Just 3 <*> Just 2 <*> Just 3
13:22:46 <lambdabot>  Just 18
13:22:48 <Hijiri> I think the "monoid in the category of endofunctors" is related though
13:22:55 <phaazon> maerwald: show ing off
13:23:05 <Hijiri> actually I'm not sure
13:23:14 <guillaum> geekosaur: I should have a look at vector, but I'm a bit unmotivated to pull external dependencies on a 20 lines learning project ;)
13:23:31 <johnw> phaazon: (I'll be back)
13:23:34 <phaazon> maerwald: check this, way more readable for hackrilege :
13:23:54 <phaazon> > (\x y z -> x + y + z) <$> Just 10 <*> Just 3 <*> just 2
13:23:55 <geekosaur> sigh. it used to be that people recommended a reasonable environment that included things like vector
13:23:55 <lambdabot>      Not in scope: ‘just’
13:23:55 <lambdabot>      Perhaps you meant data constructor ‘Just’ (imported from Data.Maybe)
13:24:02 <phaazon> > (\x y z -> x + y + z) <$> Just 10 <*> Just 3 <*> Just 2
13:24:04 <lambdabot>  Just 15
13:24:18 <geekosaur> but these days people recommend minimal installations. and minimal is just that: the compiler comes only with what it needs, not a full ecosystem
13:24:19 <phaazon> oh you used four variables
13:24:26 <maerwald> phaazon: hah!
13:24:28 <geekosaur> yet newcomers then get upset that they have to install packages
13:24:33 <maerwald> you can't trick me :P
13:24:35 <phaazon> > (\x y z w -> x + y + z + w) <$> Just 10 <*> Just 3 <*> Just 2 <*> Just 3
13:24:36 <lambdabot>  Just 18
13:24:40 <hackrilege> maerwald: lol
13:24:48 <phaazon> maerwald: pointfree is wrong in your case
13:24:51 <phaazon> it’s barely readable
13:24:52 <geekosaur> but $DEITY forbid we recommend that newcomers start out with useful libraries like any other language comes with
13:25:00 <maerwald> phaazon: don't tell me, I mostly hate pointfree
13:25:05 <phaazon> you’d make hackrilege being overwhelmed for nothing
13:25:06 <maerwald> I just found it funny
13:25:11 <phaazon> yeah, very funny :D
13:25:40 <phaazon> maerwald: so, (<*>). The first type I discovered it, it just blows my bind
13:25:41 <phaazon> mind*
13:25:55 * hackagebot api-builder 0.10.0.0 - Library for easily building REST API wrappers in Haskell  https://hackage.haskell.org/package/api-builder-0.10.0.0 (Intolerable)
13:26:01 <phaazon> :t (<*>)
13:26:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:26:36 <Tuplanolla> Note that f <$> x <*> y == liftA2 f x y, phaazon.
13:26:40 <phaazon> > [length,const 3] <*> pure "foobar"
13:26:42 <lambdabot>  [6,3]
13:27:03 <phaazon> Tuplanolla: yeah, but I don’t find liftA2 is worth mentionning yet
13:27:12 <Wollan> lambdabot <3
13:27:14 <phaazon> it has a lot of drawbacks, actually
13:27:30 <phaazon> (you need parens, for instances)
13:27:42 <hackrilege> :t <*> Just
13:27:43 <lambdabot> parse error on input ‘<*>’
13:27:50 <guillaum> geekosaur: I admit that I'm a bit lost, there is really powerful stuff in the default libraries, but what I qualify as "basic" (i.e: generating a modified list) are not included ;)
13:27:54 <hackrilege> :t (<*> Just)
13:27:55 <lambdabot> (a -> Maybe a -> b) -> a -> b
13:28:01 <geekosaur> guillaum, in short, expect to install stuff to do anything at all useful
13:28:23 <geekosaur> because Haskell lists are not intended to be modified in that way
13:28:32 <geekosaur> they are not the lists you are looking for
13:28:34 <hackrilege> :t ((+) <$>)
13:28:35 <lambdabot> (Functor f, Num a) => f a -> f (a -> a)
13:28:37 <guillaum> geekosaur: ok ;)
13:29:16 <Tuplanolla> > (zip <*> tail) [1 .. 4]
13:29:17 <lambdabot>  [(1,2),(2,3),(3,4)]
13:29:17 <phaazon> hackrilege: 
13:29:21 <phaazon> :t (<*> Just 3)
13:29:22 <lambdabot> Num a => Maybe (a -> b) -> Maybe b
13:29:26 <hackrilege> :t (<*> Just 3)
13:29:27 <lambdabot> Num a => Maybe (a -> b) -> Maybe b
13:29:34 <AaronFriel> Hey folks, quick question because I keep getting bad search results
13:29:35 <phaazon> Maybe is a Functor 
13:29:45 <hackrilege> jynx
13:29:59 <AaronFriel> I would like to format a bytestring as a C string literal. e.g.: if it's a valid character, just print it, otherwise use the appropriate escapes.
13:30:29 <AaronFriel> When I search for this I get about 300 ways to do FFI between C and ByteStrings
13:30:43 <AaronFriel> Just wondering if anyone has seen anything like this
13:31:43 <hackrilege> > (+) <$> (return 1) <*> (return 1)
13:31:44 <lambdabot>      No instance for (Show (f0 b0))
13:31:44 <lambdabot>        arising from a use of ‘show_M16253523137002039020864’
13:31:44 <lambdabot>      The type variables ‘f0’, ‘b0’ are ambiguous
13:32:08 <hackrilege> > ((+) <$> (return 1) <*> (return 1)) >>= putStrLn
13:32:10 <lambdabot>      No instance for (Num String) arising from a use of ‘+’
13:32:10 <lambdabot>      In the first argument of ‘(<$>)’, namely ‘(+)’
13:32:10 <lambdabot>      In the first argument of ‘(<*>)’, namely ‘(+) <$> (return 1)’
13:32:20 <hackrilege> > ((+) <$> (return 1) <*> (return 1)) >>= putStrLn.show
13:32:21 <lambdabot>  <IO ()>
13:32:30 <hackrilege> rrg
13:33:02 <hackrilege> > ((+) <$> (Just 1) <*> (Just 1))
13:33:03 <lambdabot>  Just 2
13:33:44 <hackrilege> why did the IO monad behave differently?
13:34:36 <lyxia> lambdabot doesn't run the IO action.
13:34:39 <Gurkenglas> @help run
13:34:39 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
13:34:58 <Gurkenglas> :t ((+) <$> (return 1) <*> (return 1)) >>= putStrLn.show
13:34:59 <lambdabot> IO ()
13:35:07 <rapier_saber> How is Haskell better than C?
13:35:16 <rapier_saber> C gives you more low-level access.
13:35:20 <maerwald> rapier_saber: it's a high level language -.-
13:35:37 <rom1504> rapier_saber: how is C better than assembly?
13:35:40 <hackrilege> and haskell releives you of this trial!
13:35:48 <rom1504> assembly gives you more low-level access.
13:35:48 <hackrilege> lol
13:35:53 <Hijiri> @letlpaste http://lpaste.net/137109
13:35:54 <lambdabot>  Invalid paste ID.
13:35:56 * hackagebot haskell-neo4j-client 0.3.1.4 - A Haskell neo4j client  https://hackage.haskell.org/package/haskell-neo4j-client-0.3.1.4 (asilvestre)
13:36:01 <Hijiri> @letlpaste 137109
13:36:04 <lambdabot>  Defined.
13:36:20 <rapier_saber> rom1594: Haskell gives you no low-level access.
13:36:34 <rom1504> yes, so ?
13:36:36 <rapier_saber> C gives you A LOT of low-level access.
13:36:44 <hackrilege> AaronFriel: i think you should look at Data.Text
13:36:52 <Twey> Getting low-level access is not the primary problem in programming.
13:36:53 <maerwald> despite haskell and C being programming languages... they are both totally different tools
13:36:55 <rapier_saber> Assembly gives you even more, but not as much more as C does compared to Haskell.
13:37:22 <rapier_saber> So, you guys prefer Haskell beacuse it's high-level?
13:37:24 <AaronFriel> rapier_saber quick question: are you trolling?
13:37:25 <Twey> Usually, *not* getting low-level access is both harder and more useful.  ☺
13:37:27 <hackrilege> rapier_saber, who needs this stupid access? you need good blas and a convinient api...
13:37:29 <mauke> rapier_saber: what does C give you that Haskell doesn't?
13:37:41 <rapier_saber> mauke: Memory management.
13:37:50 <mauke> rapier_saber: you can do that in Haskell
13:37:54 <rapier_saber> mauke: Embedded systems programming.
13:37:54 <rom1504> rapier_saber: clearly a bulldozer is better than a hammer, much more powerful
13:38:01 <mauke> rapier_saber: we have bindings for malloc/free
13:38:03 <hiptobecubic> rapier_saber, how often do you *want* that though?
13:38:04 <hackrilege> i do that in haskell
13:38:15 <AaronFriel> rapier_saber, I'm pretty sure is trolling
13:38:20 <mauke> well, duh
13:38:44 <rapier_saber> hiptobecubic: It's why C is faster than Haskell, so I kind of like using it.
13:38:58 <Fuuzetsu> Keep using it then
13:38:58 <hackrilege> yes why do you want malloc? performance concerns? control should be permited in haskell syntax, there should be indistiguishablw machine code
13:39:19 <hiptobecubic> rapier_saber, no. It's not.
13:39:22 <Fuuzetsu> malloc is slow, real hackers write their own in ASM for every project
13:39:39 <rapier_saber> hiptobecubic: Yes, it is. Not debatable. Sorry.
13:39:49 <hackrilege> rapier_saber, i always outperform C in haskell by binding using obsidian 
13:39:50 <mauke> and that's the gong
13:40:04 <Twey> Assemblers are too high-level, how are you going to use the same numbers as opcodes and data?
13:40:14 <AaronFriel> rapier_saber, did you just come from 4chan?
13:40:15 <hackrilege> kick?
13:40:21 <rapier_saber> Maybe because you simply use Haskell better than C?
13:40:21 <Fuuzetsu> it's easy to check
13:40:33 <rom1504> rapier_saber: that's the whole point
13:40:41 <mauke> worüber man nicht debattieren kann, darüber muss man schweigen
13:40:41 <rom1504> programming is not obvious
13:40:42 <rapier_saber> If you used C equally as good as Haskell, you'd see that C is faster.
13:40:42 <hackrilege> deja vu
13:40:49 <hiptobecubic> rapier_saber, implementations of simple problems in C often outperform them in Haskell (and everything else) that's not what we're talking about. We're talking about things you don't even bother implementing in C because the language is too annoying to use.
13:40:51 <Sindriava> rapier_saber: I do and it's not
13:40:54 --- mode: ChanServ set +o mauke
13:40:54 --- mode: mauke set +q *!*@gateway/web/freenode/ip.108.45.68.110
13:40:55 <johnw> language vs. language is not appropriate in this channel unless you have a specific need in mind
13:40:58 <mauke> temporary mute
13:41:00 <AaronFriel> gais
13:41:03 <mauke> I think this is pure trolling
13:41:08 <johnw> mauke: agreed
13:41:09 <Sindriava> johnw++, lets stop this right now
13:41:10 <AaronFriel> rapier_saber is trolling you all so hard
13:41:15 <Gurkenglas> AaronFriel, let them have their fun
13:41:19 <AaronFriel> ok ok
13:41:20 <Gurkenglas> Trolling takes two people
13:41:23 <mauke> no fun allowed.
13:41:31 <mauke> fun is a side effect
13:41:32 <Sindriava> mauke++
13:41:36 <Fuuzetsu> AaronFriel: you should easily see that it's two-sided
13:41:40 <AaronFriel> inb4 "Hey guys have you heard about Rust? Isn't Rust better than Haskell?"
13:41:45 <hiptobecubic> We've saved more than one troll in the past. You're hurting our rep.
13:41:48 <Sindriava> ship, I need to stop doing this
13:41:49 <Sindriava> mauke + 1
13:41:51 <hackrilege> kick i hate getting trolled, i was busy learning about silly opperators...
13:42:14 <sidoaight> <joke> Move orthogonally, use a lisp machine! </joke>
13:42:38 <Fuuzetsu> all the downsides with none of the benefits ;^)
13:42:54 --- mode: mauke set -o mauke
13:43:04 --- mode: ChanServ set +o mauke
13:44:09 <Gurkenglas> rapier_saber, optimized C may be faster than optimized Haskell, but optimized Haskell is not that much faster than unoptimized Haskell and unoptimized Haskell code doesn't take long to write
13:44:27 <johnw> Gurkenglas: we're done with this topic, if you would be so kind
13:45:07 <Gurkenglas> Oh, sorry, didn't see that. Spoilsport.
13:45:44 <johnw> :)
13:46:23 <Sindriava> Last bit into the discussion, if I may
13:46:26 <Sindriava> http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
13:46:43 <Sindriava> This is pretty cool on it's own ^_^
13:46:52 <Tuplanolla> That's a great talk.
13:48:47 <Sindriava> It was the talk that tied together the "being pure can be more useful than micromanagement" notion for me
13:49:44 <Sindriava> Which in turn made the feeling that Haskell is getting in my way go away
13:51:16 <Denommus> I find it silly to always say how fast C is
13:51:41 <Tuplanolla> It seems that people want to use more and more dependent types with Haskell and I expect Idris to fill that gap eventually.
13:51:48 <Denommus> for most domains, the performance gain of using C is a lot less important than any productivity gain of almost any other language
13:55:57 * hackagebot rei 0.1.0.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.1.0.0 (kerkomen)
13:56:10 <Tuplanolla> Quick question: does moveFile exist anywhere?
13:56:30 <johnw> renameFile
13:56:34 <Fuuzetsu> how can I tell cabal to stop asking me for README? README.md is right there like it has been for a long time
13:56:36 <mauke> doesn't cross file systems, though
13:56:36 <johnw> and then, if across volumes, copyFile
13:56:51 <shapr> Tuplanolla:  http://hackage.haskell.org/package/directory-1.0.0.3/docs/System-Directory.html#3 ?
13:56:55 <shapr> doh, too slow
13:57:02 <Tuplanolla> Yeah, that's it. Thanks.
13:57:17 <johnw> since detecting volumes is somewhat system dependent, it's hard to right a general moveFile that does the right thing in all situations
13:57:27 <inck> hullo all I'm interested in using either Snap or Yesod as a first  haskell api frameworkdoes anyone have any opinions on those systems. I don't really need alot of templating or static file loading types of behavior 
13:57:40 <inck> additionally I'm more interested in playing around with websockets 
13:57:41 <johnw> like, what if it's a 20GB file and there's an exception mid-way?
13:57:56 <shapr> cry
13:58:09 <Tuplanolla> I hope I can assume all of the files in the same directory are on the same volume.
13:58:11 <johnw> inck: I hear a lot of people saying good things about snap
13:58:19 <inck> I'm leaning towards snap because of its snaplets architecture, but I haven't really played with 
13:58:19 <johnw> Tuplanolla: you'll find out if they're not :)
13:59:24 <Tuplanolla> My inner C programmer is getting excited again and I don't like it.
14:00:38 <mauke> Tuplanolla: that's probably not true if your OS supports overlays
14:02:03 <blackdog> inck: for simple API stuff, I tend to prefer scotty.
14:02:57 <lspitzner> Fuuzetsu: and it is extra-source-files'd?
14:03:33 <Sindriava> blackdog + 1, scotty is great
14:03:55 <Sindriava> Does anyone have an idea for a small, round 1 hour project in haskell?
14:04:29 <Fuuzetsu> lspitzner: probably that was the problem, I just cp'd it to README quick, don't have time to mess around with it and I need it up tonight
14:04:30 <Sindriava> preferably something that would teach me something neat and that I could visualize using diagrams ^_^
14:04:31 <nuttycom> inck: I like snap a lot; the snaplet architecture is really pretty nice in practice.
14:04:33 <Fuuzetsu> already uploaded actually
14:04:45 <Fuuzetsu> I think it used to be README but we moved it to README.md or somethnig
14:05:18 <Tuplanolla> Try Tic-tac-toe on a graph, Sindriava.
14:05:36 <Sindriava> Tuplanolla: Oooh, so generic graph tic tac toe, not only a grid?
14:05:50 <Tuplanolla> I started that once, but never finished it.
14:05:57 * hackagebot haddock-library 1.2.1 - Library exposing some functionality of Haddock.  https://hackage.haskell.org/package/haddock-library-1.2.1 (MateuszKowalczyk)
14:05:59 * hackagebot haddock-api 2.16.1 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-api-2.16.1 (MateuszKowalczyk)
14:06:01 * hackagebot haddock 2.16.1 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-2.16.1 (MateuszKowalczyk)
14:06:09 <Sindriava> Tuplanolla: It sounds really neat, actually! Thanks a lot ^^
14:06:21 <blackdog> nicta's tic tac toe challenge is fun too - normal grid, but you're trying to prove a bunch of stuff in the typesystem too
14:06:35 <Sindriava> Tuplanolla: At least I'll learn to work with graphs in Haskell, I've been looking to do that for a month or so
14:06:37 <Tuplanolla> The trick is to give each node four directions and visualize the dual (Voronoi diagram) of the graph.
14:08:02 <shapr> blackdog: you traveling south anytime?
14:09:02 <blackdog> shapr: maybe! no explicit plans, still getting settled in
14:09:33 <blackdog> transport is still a problem.
14:09:41 <shapr> blackdog: fair enough, would be nice to hang out again, haven't seen you since 2003 or so
14:09:55 <Sindriava> Tuplanolla: four directions? 
14:09:56 <blackdog> ICFP, wasn't it?
14:09:58 <bitemyapp> blackdog: you'd probably want to fly, then rent a car.
14:10:04 <shapr> blackdog: yup, ICFP in Sweden
14:10:07 <blackdog> bitemyapp: also learn how to drive a car.
14:10:19 <shapr> blackdog: or fly here and I'll drive you around
14:10:31 <Sindriava> Tuplanolla: What I imagined was just a generic graph, where you color each node with a color, and if you manage to color N consecutive (connected) nodes, you win
14:10:40 <bitemyapp> blackdog: looks like visiting shapr is sorted given that, but you're going to want some practice before winter.
14:10:46 <Sindriava> Tuplanolla: Which sound pretty straightforward to check
14:10:50 <bitemyapp> blackdog: strongly suggest you take lessons at a local driving school.
14:10:57 * hackagebot rei 0.1.0.1 - Process lists easily  https://hackage.haskell.org/package/rei-0.1.0.1 (kerkomen)
14:10:58 <Tuplanolla> You need connections to have the same direction, Sindriava.
14:10:59 <bitemyapp> blackdog: and specifically mention you want to be ready for winter.
14:11:12 <Tuplanolla> Otherwise you can win with a lump of any form.
14:11:18 <Sindriava> Tuplanolla: Oh, you meant a directed graph!
14:11:29 <Tuplanolla> The graph need not be two-dimensional.
14:11:30 * shapr takes the non-Haskell discussion to #haskell-blah
14:12:06 <Tuplanolla> Try it and see.
14:12:16 <chromatome> what's the "standard" way for creating types? Is it preferable to use record syntax so you can get the accessors for free?
14:13:53 <levi> It's common to use record syntax, but not universal. There isn't really a "standard" style guide.
14:14:04 <Sindriava> chromatome: I haven't needed accessors yet
14:14:20 <Sindriava> chromatome: But by using record syntax, you don't lose the destructuring capabilities
14:14:39 <Tuplanolla> I don't have a picture handy, but you can start with a lattice and introduce a torsional defect, so that you end up with a Tic-tac-toe board that allows winning with an infinitely long streak, Sindriava.
14:14:47 <chromatome> Sindriava: I'm still learning, but how would you access an "internal" value of a type without having the accessor 
14:15:17 <chromatome> e.g. `data Book = Book { id :: Int, title :: String } 
14:15:22 <_m_ryan> hi, question does yesod/haskell support for web crawling?
14:15:31 <Sindriava> chromatome: For example, for `data X = X { a :: Int, b :: String } `, you can still do ` f (X foo bar) = bar ++ show foo `
14:15:44 <mauke> chromatome: pattern matching
14:15:45 <levi> chromatome: Pattern matching is the primitive method for accessing data members.
14:15:52 <Sindriava> ^
14:16:17 --- mode: mauke set -o mauke
14:16:46 <chromatome> Ahh right. I suppose that by avoiding record syntax, it somewhat encourages you to use smaller, simpler types that don't have lots of internal members too.
14:17:31 <Sindriava> can I create a partial record?
14:17:47 <Sindriava> like ` data X = X { Int, bar :: String }
14:18:06 <nuttycom> Sindriava: nope, for that you'll have to define bar yourself.
14:18:24 <Sindriava> nuttycom Thanks ^^
14:24:38 <mjhoy> Hello. When I'm programming with ghci open, it's annoying that reloading code that's broken loses all of the imports. Does anyone else run into this/have a solution?
14:25:55 <Kluns> Is it possible to lift an (a -> IO b) -> IO c function into monadIO?
14:26:12 <Kluns> Well, the argument function.
14:28:23 <nitrix> :t fixIO
14:28:25 <lambdabot> Not in scope: ‘fixIO’
14:28:58 <nitrix> What the heck.
14:29:13 <tolt> :t System.IO.fixIO
14:29:14 <lambdabot> (a -> IO a) -> IO a
14:29:20 <nitrix> How is System.IO not in scope?
14:29:30 <nitrix> Oh, crap, it's disabled on lambdabot.
14:30:46 <Fuuzetsu> mjhoy: -fdefer-type-errors
14:31:22 <mjhoy> Fuuzetsu: ah, thanks
14:32:10 <catgocat> I am following the section on monoids from the LYAH book, and I can't get the code to compile.
14:32:17 <lpaste_> catgocat pasted “here” at http://lpaste.net/137111
14:32:26 <catgocat> It states that `mappend` is not defined
14:32:43 <catgocat> But, how am I supposed to define it, if in the LYAH section it doesn't define
14:32:58 <shachaf> Is that the full error?
14:33:06 <Tuplanolla> :t Data.Monoid.mappend
14:33:07 <lambdabot> Monoid a => a -> a -> a
14:34:21 <nitrix> catgocat: That sounds unlikely. Could you paste the error as well?
14:34:59 <catgocat> @nitrix Ops, it's not `mappend` is not defined, I imported Data.Monoid, but got other error.
14:35:00 <lambdabot> Unknown command, try @list
14:35:01 <catgocat> test.hs:8:23:     Could not deduce (m ~ Tree a0)     from the context (Monoid m)       bound by the type signature for                  foldMap :: Monoid m => (a -> m) -> Tree a -> m       at test.hs:(8,5)-(11,42)       `m' is a rigid type variable bound by           the type signature for             foldMap :: Monoid m => (a -> m) -> Tree a -> m           at test.hs:8:5     In the expression: Empty     In an equation for `foldMap'
14:35:02 <catgocat> I think it's because Tree is not instance of Monoid
14:35:10 <catgocat> But in the book there is no mention of this error.
14:35:17 <quchen> foldMap f Empty = Empty is wrong.
14:35:29 <catgocat> in the book that's how it is
14:35:36 <quchen> Folding the empty tree should give you mempty, not an empty tree.
14:35:50 <catgocat> ops my bad, it's mempty
14:35:55 <quchen> :-)
14:35:55 <Fuuzetsu> :)
14:35:57 <catgocat> oh it compiled
14:35:58 <catgocat> thanks
14:35:59 * hackagebot reflex-gloss 0.1 - An reflex interface for gloss.  https://hackage.haskell.org/package/reflex-gloss-0.1 (jeffreyrosenbluth)
14:35:59 <Fuuzetsu> all smiles
14:36:08 <nitrix> If it compiles, it works!
14:36:14 <quchen> Don't fall for that.
14:36:15 * nitrix dances around~
14:36:38 <nitrix> The exclamation mark was sarcasm :P
14:36:44 <quchen> If it compiles it likely has no trivial bugs. There's still plenty of space for head scratchers.
14:36:56 <catgocat> Is Infinity a number?
14:37:01 <catgocat> When I do 1 / 0 I get Infinity
14:37:03 <quchen> catgocat: It's a Double.
14:37:12 <catgocat> But can I actually use it?
14:37:18 <Tuplanolla> Yes, but please don't.
14:37:18 <quchen> Yes.
14:37:27 <catgocat> :18:1: Not in scope: data constructor `Infinity'
14:37:36 <quchen> You can use it, and it is useful for numerics. That's why it's there.
14:37:44 <catgocat> how do I actually use it?
14:37:53 <quchen> > (1/0)
14:37:55 <lambdabot>  Infinity
14:37:56 <catgocat> It says it's not in scope
14:37:57 <quchen> That way.
14:38:11 <quchen> There's rarely if at all need to use Infinity directly.
14:38:18 <quchen> But it can occur as an intermediate result.
14:38:26 <catgocat> But can I use Infinity directly?
14:38:30 <catgocat> How do I use it?
14:38:35 <quchen> 1/0
14:38:40 <quchen> Or n/0, where n > 0
14:38:40 <catgocat> Why does typing Infinity throw not-in-scope error?
14:38:47 <quchen> > Infinity
14:38:48 <lambdabot>      Not in scope: data constructor ‘Infinity’
14:38:49 <lambdabot>      Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
14:39:09 <quchen> There are other "strange" numbers in floating point numbers, such as -0 (which is distinct from 0) and -Infinity.
14:39:45 <catgocat> But how do I use it?
14:39:54 <catgocat> Why does it throw a no-scope error?
14:40:05 <quchen> There is no "Infinity" constructor, that's why.
14:40:25 <quchen> If you want to use an infinite value you'll have to create it, e.g. by dividing a positive number by zero.
14:40:33 <quchen> Positive finite, that is.
14:40:37 <catgocat> So what does "Infinity" mean?
14:40:49 <catgocat> How does it work internaly?
14:40:51 <quchen> It's how the infinite value is prettyprinted.
14:40:53 <catgocat> How is it stored?
14:40:54 --- mode: ChanServ set +o mauke
14:40:54 --- mode: mauke set -q *!*@gateway/web/freenode/ip.108.45.68.110
14:40:56 <catgocat> How can I use it directly?
14:41:08 <quchen> You can't. Haskell does not expose Infinity directly.
14:41:31 <catgocat> ok
14:41:44 <Fuuzetsu> 1 / 0 == 1 / 0
14:41:46 <Fuuzetsu> > 1 / 0 == 1 / 0
14:41:48 <lambdabot>  True
14:42:22 <Tuplanolla> How it works, quchen: http://floating-point-gui.de/
14:42:35 <Fuuzetsu> trigger warning that stuff
14:42:53 <nullvoid8> also
14:42:54 <quchen> This is probably better. https://en.wikipedia.org/wiki/Single-precision_floating-point_format
14:42:54 --- mode: mauke set -o mauke
14:43:02 <nullvoid8> > isInfinity (1/0)
14:43:03 <lambdabot>      Not in scope: ‘isInfinity’
14:43:03 <lambdabot>      Perhaps you meant one of these:
14:43:03 <lambdabot>        ‘isInfinite’ (imported from Prelude),
14:43:07 <nullvoid8> bah
14:43:18 <nullvoid8> > isInfinite (1/0)
14:43:19 <lambdabot>  True
14:43:21 <quchen> A common mistake is also to check for NaN-ness via (== NaN).
14:43:36 <nullvoid8> NaN is never NaN !
14:43:43 <quchen> (Abuse of notation again. NaN can be created via 0/0, for example.)
14:44:30 <Fuuzetsu> > Nan == NaN
14:44:31 <lambdabot>      Not in scope: data constructor ‘Nan’
14:44:31 <lambdabot>      Perhaps you meant variable ‘tan’ (imported from Prelude)Not in scope: da...
14:44:41 <Fuuzetsu> oh, should have read down
14:44:51 <Fuuzetsu> or should have gone to bed like a good boy hours ago
14:45:09 <nullvoid8> Fuuzetsu: but it's not even sunrise yet
14:47:33 <Fuuzetsu> nullvoid8: I wake up normal people hours nowadays, work stuff
14:47:40 <nullvoid8> :O
14:47:42 <Kluns> So when I would like to use an (a -> IO b) -> IO c function, such as withMVar, in a monad transformer stack over IO, how would I do that?
14:47:50 <Fuuzetsu> I spent way too many hours on something at work today with very little progress, depressing, should just cry myself to sleep
14:48:24 <m4ntis> do they change the window API for every new windows OS?
14:48:46 <quchen> Kluns: lifted-base solves that problem. http://hackage.haskell.org/package/lifted-base-0.2.3.6/docs/Control-Concurrent-MVar-Lifted.html
14:49:04 <quchen> Kluns: The alternative is doing the lifting manually.
14:49:21 <Kluns> quchen: it cannot be done on a general basis, I assume?
14:49:47 <quchen> Kluns: You mean assuming only a MonadIO constraint?
14:49:57 <Kluns> Yes
14:50:26 <quchen> Kluns: I think that should be possible to do. But it's just a guess because I can't come up with a reason why it should not work.
14:50:46 <lpaste_> catgocat revised “here”: “there” at http://lpaste.net/137111
14:50:52 <catgocat> Someone help me here
14:51:05 <catgocat> I don't understand how I am able to use `mappend` on that example
14:51:16 <catgocat> I am not working with monoids, or am I?
14:51:20 <quchen> You are.
14:51:36 <quchen> Foldable is the class that lets you collapse a structure to some monoid.
14:51:37 <catgocat> But where??
14:51:45 <quchen> :t foldMap
14:51:46 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:51:47 <quchen> There.
14:51:54 <catgocat> Yeah, but I am not talking about that.
14:52:00 <catgocat> I am talking about using `mappend` in that case
14:52:04 <catgocat> mappend only works on monoids
14:52:07 <catgocat> but where are those monoids?
14:52:17 <quchen> Yes. "FoldMap f l" has what type?
14:52:30 <catgocat> it is a monoid..
14:52:36 <catgocat> but how ??????
14:52:37 <quchen> It's monoidal, yes.
14:53:01 <quchen> You've written down the very definition of "how" :-þ
14:53:06 <catgocat> I understand that you can make something instance of monoid, by doing instance Monoid stuff where .. and then fullfilling mempty and mappend
14:53:13 <quchen> Right.
14:53:46 <catgocat> so what are you actually applying mappend to ??
14:54:10 <quchen> Maybe start with the simpler example of "fold". "fold" goes through your data structure, and mappends all the elements it finds inside it. For a tree, fold Empty = mempty; fold (Node l x r) = fold l `mappend` x `mappend` fold r.
14:54:12 <catgocat> mempty `mappend` ((+3) 2) doesnt work for example
14:54:28 <catgocat> I understand that...
14:54:40 <catgocat> What I don't understand is, where are the monoids actually defined???????
14:54:40 <Kluns> quchen, well, to do in manually, I guess you would use the 'runMyMonad' function to reduce the MonadIO function to an IO one.
14:54:45 <quchen> Do you know how fmap (from Functor) works for trees?
14:54:46 <hexagoxel> catgocat: the Monoid implied in the signature of foldMap
14:54:47 <catgocat> I don't see any instance of monoid there
14:54:48 <Kluns> *to do ti
14:55:00 <nullvoid8> catgocat: the monoid is chosen by the choice of f that is provided
14:55:18 <catgocat> But f may return an integer, for example (+), and is integer a monoid ??
14:55:41 <nullvoid8> f couldn't return an Integer precisly because Integer is not a monoid
14:55:53 <quchen> Integer is not a Monoid directly, no. Mathematically, there are two valid monoid instances for it: (+,0) and (*,1).
14:56:14 <shachaf> There are many more than that.
14:56:18 <quchen> Yes.
14:56:21 <Fuuzetsu> I deleted a Num (b - > a) instance yesterday, Integer might as well be monoid
14:57:29 <catgocat> I dont really understand this, in the book I'm reading they do an example of FoldMap (*) 0 testTree, but the function there is (*), and inside the foldmap, there is f x, which in that case would be (*3) 3, which is an integer and not a monoid???
14:57:42 <catgocat> s/FoldMap (*)/FoldMap (*3)
14:57:51 <quchen> s/FoldMap/foldMap/
14:58:03 <catgocat> no wait, actuall its FoldMap (*)
14:58:09 <catgocat> which is even more weird :/
14:58:11 <quchen> Then that's something different.
14:58:13 <quchen> What book is it?
14:58:30 <catgocat> LYAH
14:58:50 <catgocat> I really want to get this but it is so confusing
14:59:17 <quchen> LYAH talks about foldMap? I don't remember that
14:59:31 <quchen> Which section is it in
14:59:50 <catgocat> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
14:59:55 <catgocat> right in the bottom
15:00:27 <quchen> There is no "FoldMap" on that page.
15:00:37 <nullvoid8> there is quchen
15:00:41 <nullvoid8> 17 of them
15:00:48 <quchen> No.
15:00:51 <ElderFain> hmm when trying to install ghc-mod i get a failure but its not clear.. why https://gist.github.com/anonymous/9e18d84e3dfeb0ae75e0 
15:00:53 <quchen> There is plenty of "F.foldMap".
15:00:54 <catgocat> I don't get it :/
15:01:08 <catgocat> there is
15:01:11 <catgocat> Foldable right below
15:01:25 <quchen> F.foldMap is the foldMap function from the "F" module, so the author imported "Foldable qualified as F".
15:01:37 <catgocat> yes
15:02:59 <nullvoid8> what definitly isn't there is foldMap (*)
15:03:11 <nullvoid8> it's F.foldl (*) 0
15:03:17 <catgocat> but I dont understand the instance of Foldable
15:03:20 <nullvoid8> which is a completly different beast
15:03:55 <catgocat> it's the instance of Foldable I dont understand
15:04:08 <nullvoid8> what in particular about it?
15:04:30 <tomtomgps> hello 
15:04:30 <quchen> Do you understand "foldMap f [] = mempty; foldMap f (x:xs) = f x `mappend` foldMap f xs"?
15:04:38 <quchen> That would be foldMap for lists.
15:05:55 <catgocat> quchen: Isn't mappend (++) ? f x would have to return a list then
15:05:56 <tomtomgps> I am trying to write a function length :: [a] -> Int    that returns the element of a list using pattern matching and recusivity
15:06:11 <tomtomgps> number or elements *
15:06:16 <tomtomgps> of*
15:06:29 <nullvoid8> ah, no catgocat
15:06:39 <quchen> catgocat: No, mappend is not (++), only for lists it is.
15:06:40 <catgocat> The book is not explaining things well then :/
15:06:49 <catgocat> Yes, but in that example quchen gave.
15:06:55 <nullvoid8> still no
15:07:16 <fr33domlover> hello! Q: if a package provides two alternative interfaces, one using some language extension and one not, do I need - for portability - put the one that uses the extension in a separate package?
15:07:20 <catgocat> No what?
15:07:21 <quchen> mappend joins whatever things "f" maps to, in my example as well as in yours.
15:07:28 <catgocat> Ah nevermind, I'm going to put a question on stackoverflow
15:07:37 <quchen> "f x" might be a list. Then mappend would be (++).
15:07:54 <quchen> But there are many monoids and many fs you can write.
15:08:12 <quchen> "f x" might be a Sum, then mappend would be some version of addition.
15:08:58 <hexagoxel> foldMap :: Monoid m => (a -> m) -> t a -> m. for quchen's example, :: Monoid m => (a -> m) -> [a] -> m 
15:09:07 <catgocat> @quchen Ok, that's right, but in the Tree example I gave, f x would have to return a monoid, or not?
15:09:07 <lambdabot> Unknown command, try @list
15:09:07 <hexagoxel> only `t` gets `replaced`
15:09:54 <nullvoid8> catgocat: important distinction: f "returns" a monoid, "f x" *is* a (value of a) monoid
15:10:05 <catgocat> yes ok got it
15:10:31 <catgocat> but how does it automatically implement a foldl from (+) ???
15:10:48 <quchen> catgocat: Yes, it does!
15:10:48 <bitemyapp> is there a Monoid for [a] that requires has Monoid a => a and behaves like ziplist?
15:10:49 <catgocat> just from that instance of Foldable, it automatically implements a foldl
15:11:00 * hackagebot hint-server 1.4.2 - A server process that runs hint.  https://hackage.haskell.org/package/hint-server-1.4.2 (CorentinDupont)
15:11:02 <quchen> catgocat: Your "f" is "a function that maps things to monoidal elements".
15:11:08 <quchen> catgocat: So "f x" is monoidal.
15:11:11 <quchen> And you can join these things.
15:11:23 <catgocat> Ok, got that part.
15:11:34 <catgocat> But how does it automatically implement foldl with just the foldMap that I defined=?
15:11:39 <quchen> You're putting this "f x" between two foldMaps, and those foldMaps are monoidal as well, because foldMap f something maps something to a monoid. :-)
15:11:53 <quchen> Yes, you can define foldl in terms of foldMap.
15:12:04 <nullvoid8> foldl/foldr is done using newtype Endo a = Endo {runEndo :: a -> a}
15:12:06 <nullvoid8> iirc
15:12:06 <catgocat> I asked how, not if
15:12:38 <quchen> catgocat: For the real deal you can look at Foldable's source. http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data-Foldable.html#foldMap
15:13:01 <quchen> Endo is the monoid with mappend = (.), mempty = id.
15:13:04 <catgocat> nullvoid8: but for example if a pass a function (+) to the foldl, how does it work??
15:13:49 <quchen> foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z   so   foldl (+) z t = appEndo (getDual (foldMap (Dual . Endo . flip (+)) t)) z. Not very intuitive, but you can show that this is the right way to do it.
15:13:50 <nullvoid8> catgocat: take a list for example: picture it in your head, now replace all the ':' with `f`
15:14:07 <catgocat> nullvoid8: I get it I get that
15:14:32 <catgocat> but how does "Foldable.foldl (+) ..."
15:14:38 <catgocat> work?
15:14:51 <hiptobecubic> What do you mean by "work" ?
15:14:53 <catgocat> I am not asking for how the normal fold works
15:14:58 <nullvoid8> you mean how does it know what specific algorithm to usE?
15:15:12 <catgocat> If I only defined a foldMap, and (+) does not return a monoid, how does it do stuff?
15:15:47 <nullvoid8> it works because Endo a = (a->) IS a monoid, no matter what 'a' is
15:16:01 * hackagebot tidal 0.4.34 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.4.34 (AlexMcLean)
15:16:32 <nullvoid8> and we can get an a -> a from (+) :: a -> a -> a, because we have a whole structure of a's
15:16:55 <catgocat> nullvoid8: that doesn't really answer anything, I'm still blind, so does endo make some sort of list and then do (+) between each of its elements?
15:17:03 <nullvoid8> quchen posted exactly how foldl is implemented in terms of foldMap, so just subtitute (+) for f
15:17:35 <nullvoid8> it's a "list" (more a chain) of compositions
15:18:02 <nullvoid8> that are built in the just the right way to do things in the right order
15:19:09 <ansible1> trying to write a function a -> b where a is Num and Eq.  What's the sequence for that again? 
15:19:28 <ansible1> I've got the ftn :: Eq a => a -> b
15:19:33 <nullvoid8> ansible1: (Num a, Eq a) => a -> b
15:19:37 <Twey> ansible1: (Num a, Eq a) ⇒ b
15:19:40 <Twey> Err
15:19:41 <Twey> Yes
15:19:45 <ansible1> ok there we go, thx.
15:19:46 <Twey> But you'll have a hard time implementing that, I'd think…
15:20:09 <nullvoid8> I suspect that's not the actual type
15:20:15 <ansible1> yeah just an example I guess
15:20:18 <Twey> Ah, okay
15:21:04 <catgocat> For example F.foldMap (\x -> [x]) [1,2,3] works because the function returns a singleton list with is a monoid, therefore the `mappend` internally works as ++, regenerating the list
15:21:18 <nullvoid8> catgocat: yes
15:21:25 <catgocat> aaaaaaaaaaaaaaaaaaaaaaah finally got it
15:21:31 <catgocat> fuck sake haskell 
15:21:35 <Eduard_Munteanu> :)
15:21:45 <catgocat> you piece of confusing shit
15:22:04 <nullvoid8> and F.foldMap (\x -> Sum x) [1,2,3] == Sum 6, beacuse mappend is basically (+)
15:22:10 <catgocat> yes
15:22:25 <catgocat> that turns something like Sum 1 `mappend` Sum 2 `mappend` Sum 3
15:22:33 <nullvoid8> catgocat: you may want to take a glance at Dictionary passing if you want to know how ghc knows what to use for mappend
15:22:54 <catgocat> Dictionary?
15:23:09 * nullvoid8 ... writing
15:24:14 <nullvoid8> I think the shorthand is that "instance Monoid m where ..." gets turned into "mMonoidinstance :: Monoid ; mMonoidInstance = {mempty = ... ; mappend = ...}"
15:24:43 <catgocat> nullvoid8: what are you talking about when you said "Dictionary"
15:24:55 * nullvoid8 still writing
15:24:56 <Eduard_Munteanu> Typeclass dictionary.
15:25:05 <nullvoid8> what he said
15:25:13 <demize> Might want to watch SPJs Haskell intro talk. :)
15:25:25 <demize> Or, what's it called...
15:25:39 <demize> Adventure with Types in Haskell, also by SPJ
15:25:42 <nullvoid8> and then "f :: (Monoid m) => .... ; f ..." becomes "f :: MonoidInsatnce -> ... ; f mMonoidinstance ..."
15:26:00 <Eduard_Munteanu> Typeclass-constrained types basically carry around a representation of the type that lets one determine instances/methods at runtime.
15:26:01 * hackagebot tidal 0.4.35 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.4.35 (AlexMcLean)
15:26:06 <nullvoid8> Adventures in types: https://www.youtube.com/watch?v=6COvD8oynmI
15:26:14 <nullvoid8> *with types
15:27:14 <nullvoid8> a better explanation of Dictionary Passing: https://www.fpcomplete.com/user/jfischoff/instances-and-dictionaries
15:28:03 <fr33domlover> Q: if a package provides two alternative interfaces, one using some language extension and one not, do I need - for portability - put the one that uses the extension in a separate package?
15:30:57 <nullvoid8> so I'm watching C.Elliots talk Haskell to Hardware, and he shows a type "LTree a = Leaf a | LTree (Pair a)", except that it's a depth annotated GADT. Is that basically "Free Pair a" ?
15:31:02 * hackagebot tidal 0.4.36 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.4.36 (AlexMcLean)
15:32:12 <hiptobecubic> fr33domlover, if that's what you're aiming for, then I'd think so.
15:33:41 <Cale> nullvoid8: I don't think it's quite the same as that. Free Pair a would be an arbitrary binary tree
15:33:43 <fr33domlover> hiptobecubic, to be honest I'm not sure anyone has a problem with MultiParamClassTypes (or functional dependencies, or type families), but perhaps it's a good idea to make things easy to use for everyone now than change later etc.
15:33:57 <fr33domlover> *MultiParamTypeClasses
15:34:13 <nullvoid8> sorry, that should be Branch (LTree (Pair a)) I think. I cba to seek around to find the point in the video
15:34:16 <Cale> nullvoid8: This type is a perfect binary tree -- one which has 2^n leaves all at the same depth
15:34:32 <Cale> I haven't seen the talk
15:35:12 <Cale> I'll go watch it, since it seems interesting :)
15:36:02 * hackagebot tidal 0.5 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.5 (AlexMcLean)
15:36:17 <nullvoid8> Cale: spoilers: data LTreeTy :: Nat -> * -> * where {L :: a -> LTree Z a    ;    B :: LTree n (Pair a) -> LTree (S n) a   }
15:38:18 <Cale> nullvoid8: Yeah, so those trees are perfect binary trees
15:38:29 <hiptobecubic> weird
15:38:33 <Cale> LTree n a is the type of perfect binary trees of depth n
15:39:38 <Mo0O> hi there
15:39:43 <nullvoid8> I kind of meant "modulo the shape information" :/
15:39:45 <Cale> When you unpack one of these things, you'll get a bunch of B constructors applied to an L constructor holding a nested bunch of pairs of appropriate depth.
15:40:24 <nullvoid8> but you'll see in the talk that he starts with RTrees where Branch is B :: Pair (RTree n a) -> RTree (n+1) a
15:40:45 <nullvoid8> right, I see
15:40:49 <Cale> Like,  B (B (B (L (Pair (Pair (Pair 1 2) (Pair 3 4)) (Pair (Pair 5 6) (Pair 7 8))))))
15:41:16 <nullvoid8> I guess that's why he calls them bottom up trees then
15:42:37 <dzotokan> @help
15:42:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:42:44 <dzotokan> @list
15:42:44 <lambdabot> What module?  Try @listmodules for some ideas.
15:42:52 <dzotokan> @listmodules
15:42:52 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
15:43:06 <glguy> dzotokan: You can experiment with lambdabot in private /msg
15:43:10 <AfC> I wrote a bot once. In response to 'help' it replied "Sorry, but there's no help for you."
15:43:17 <dzotokan> oh damn, sorry
15:44:12 <fr33domlover> AfC, that could be fine is the commands are intuitive enough :P
15:44:22 <fr33domlover> I'm writing an IRC bot now
15:44:43 <fr33domlover> each command simply defines help test and the !help command displays it
15:44:51 <Cale> One question which has been open in my head for a long while is whether there's some nice characterisation of what sort of structural limitations can be imposed by non-uniform algebraic data types (ones which recurse with a different type parameter) relative to ordinary algebraic data types. It's sort of hard to ask the question in a form where you can reasonably talk about answering it though.
15:44:56 <fr33domlover> s/test/text
15:46:40 <nullvoid8> Cale: my 5 seconds thought is "some subset of the compile time checks enabled by dependant types"
15:46:54 <Cale> Well, sure
15:47:50 <AfC> Cale: I'd suggest putting it into a blog post (if you don't think there's an answer) or an email to haskell-cafe. Either way, if you can illustrate your situation with some type declarations it might save you arguing with people who aren't talking about the same thing
15:47:56 <AfC> ({shrug})
15:47:56 <Cale> Dependent types allow you to restrict to any computable subset of the type though.
15:49:50 <nullvoid8> Cale: this is probably something you've already thought, but can the question be rephrased "what do Dependant Types get you that NU-ADT's don't" ?
15:50:00 <nullvoid8> and then work backwards from there
15:51:02 * hackagebot scotty-tls 0.4.0 - TLS for Scotty  https://hackage.haskell.org/package/scotty-tls-0.4.0 (DavidJohnson)
15:52:33 * hexagoxel wonders if lambdabot will ever stop trolling "Try 'list' for all commands"
16:01:03 * hackagebot exceptional 0.3.0.0 - Essentially the Maybe type with error messages.  https://hackage.haskell.org/package/exceptional-0.3.0.0 (pharpend)
16:05:03 <AfC> Hey, that 'exceptional' there is kinda nice. 
16:06:20 <hpc> someone should make an exception library that uses the printf type trick
16:06:34 <hpc> a regular error would be "nope"
16:06:39 <hpc> more serious error "nope nope nope"
16:10:44 <athan> hpc: emoticon-based error signals
16:35:22 <funfunctor> @hoogle Float -> Int
16:35:23 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
16:35:23 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
16:35:23 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
16:35:41 <funfunctor> @hoogle floor
16:35:41 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
16:35:55 <funfunctor> > floor 94.5
16:35:57 <lambdabot>  94
16:36:54 <prinsen> A  FFI question. Is it always safe to write the aligment function of a Storable instance as #{const (offsetof(struct {char x__; C_STRUCT_TYPE (y__); }, y__))}
16:37:10 <prinsen> independent of C_STRUCT_TYPE
16:37:49 <funfunctor> > 92 mod 60
16:37:50 <lambdabot>      Could not deduce (Integral a0)
16:37:50 <lambdabot>      from the context (Integral a,
16:37:50 <lambdabot>                        Num a2,
16:37:59 <funfunctor> > 92 `mod` 60
16:38:00 <lambdabot>  32
16:38:16 <funfunctor> > 92 `rem` 60
16:38:17 <lambdabot>  32
16:39:30 <GeissT> Just curious - Are 'rem' and 'mod' identical in implementation? As in either one is simple defined as, for example: rem = mod
16:39:38 <funfunctor> > 92 `quot` 60
16:39:40 <lambdabot>  1
16:39:44 <funfunctor> yea cool
16:39:52 <indiagreen> GeissT: they have different semantics
16:40:14 <indiagreen> > (-5) `rem` 3
16:40:16 <lambdabot>  -2
16:40:20 <indiagreen> > (-5) `mod` 3
16:40:22 <lambdabot>  1
16:40:29 <GeissT> indiagreen: Okay. I might poke around Hoogle, thanks!
16:41:40 <indiagreen> “mod” is mathematically correct (remainder always has to be positive), while “rem” is faster because that's how it's implemented in CPU
16:41:51 <indiagreen> same for div and quot
16:42:13 <indiagreen> of course, there are legitimate uses for rem/quot behavior as well
16:42:18 <nullvoid8> GeissT: http://stackoverflow.com/questions/339719/when-is-the-difference-between-quotrem-and-divmod-useful
16:44:14 <GeissT> Sounds like an interesting topic, thanks indiagreen and nullvoid8!
17:11:06 * hackagebot json-rpc-client 0.2.1.0 - JSON-RPC 2.0 on the client side.  https://hackage.haskell.org/package/json-rpc-client-0.2.1.0 (grayjay)
17:17:09 <bryan> hello, guys I have a Haskell question
17:17:43 <Guest44417> I was trying to implement countSort in Haskell
17:17:58 <Guest44417> and I just used foldl 2 times
17:18:06 <Guest44417> but then I looked at the code on rosettacode
17:18:09 <Guest44417> and it's different
17:18:21 <Guest44417> here's the code from rosettacode for countSort:
17:18:28 <Guest44417> import Data.Array   countingSort :: (Ix n) => [n] -> n -> n -> [n] countingSort l lo hi = concatMap (uncurry $ flip replicate) count   where count = assocs . accumArray (+) 0 (lo, hi) . map (\i -> (i, 1)) $ l
17:18:34 <Guest44417> import Data.Array   countingSort :: (Ix n) => [n] -> n -> n -> [n] countingSort l lo hi = concatMap (uncurry $ flip replicate) count   where count = assocs . accumArray (+) 0 (lo, hi) . map (\i -> (i, 1)) $ l
17:18:43 <Guest44417> ahhh, it won't let me do newlines
17:18:48 <glguy> ?paste
17:18:48 <lambdabot> Haskell pastebin: http://lpaste.net/
17:18:59 <Guest44417> I pasted it
17:19:00 <Guest44417> yeah
17:19:42 <lpaste_> Guest44417 pasted “countSort” at http://lpaste.net/137123
17:19:52 <Guest44417> here's the code
17:19:54 <Guest44417> http://lpaste.net/137123
17:20:23 <Guest44417> can someone help me make sense of it? it's only 2 lines of Haskell
17:23:50 <Guest44417> does anyone understand this 2 line implementation of countSort? http://lpaste.net/137123
17:24:20 <glguy> Do you have any specific questions about it?
17:24:28 <hiptobecubic> > /url 1
17:24:29 <lambdabot>  <hint>:1:1: parse error on input ‘/’
17:24:31 <hiptobecubic> sigh
17:24:40 <lpaste_> glguy annotated “countSort” with “less noise” at http://lpaste.net/137123#a137125
17:24:43 <hiptobecubic> oh heh, i just wrote this same thing, but using map
17:24:48 <Guest44417> I'm just wondering accumArray does
17:24:54 <arkeet> @hoogle accumArray
17:24:54 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
17:24:54 <lambdabot> Data.Array accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
17:25:08 <arkeet> you should also wonder what assocs does
17:25:13 <hiptobecubic> > (M.toAscList $ foldr (flip (M.insertWith (+)) 1) M.empty [1,2,3,1]) >>= uncurry (flip replicate)
17:25:13 <glguy> Guest44417: Start here http://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array.html#v:accumArray
17:25:14 <lambdabot>  [1,1,2,3]
17:25:22 <Guest44417> also, what does concatMap do?
17:25:28 <arkeet> @hoogle concatMap
17:25:29 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
17:25:29 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
17:25:29 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
17:25:32 <hiptobecubic> Guest44417, it maps. then concats. :)
17:25:42 <pacak> :t concatMap
17:25:43 <arkeet> use the hoogle
17:25:43 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
17:25:44 <arkeet> D:
17:25:50 <Guest44417> hmmm
17:25:56 <Guest44417> I guess I don't know what Ix is either
17:26:04 <arkeet> that's Array stuff
17:26:12 <Guest44417> or assoc
17:26:13 <arkeet> have a look at Data.Array
17:26:15 <glguy> Guest44417: Ix is also mentioned in the URL above
17:26:16 <arkeet> it's all in there
17:26:26 <lispy> Ix just says than n can be used as an index in an Array
17:26:28 <arkeet> note: the import statement is a big hint there.
17:26:30 <Guest44417> I guess, I should just go through a Haskell course or book or something
17:26:31 <Pamelloes> Is there a way to use Persistent without an Id field?
17:26:51 <Guest44417> this is way over my head
17:26:53 <glguy> Guest44417: You can start just looking at the documentation for the module that that code uses in the URL I linked
17:26:54 <Guest44417> Haskell is hard, haha
17:27:20 <Guest44417> I'm looking but I don't understand anything
17:28:58 <hiptobecubic> Guest44417, if you are starting fro mthe beginning then you should stop by #haskell-beginners
17:29:01 <lisbeth> where can I find the sourcecode for lists?
17:29:03 <lispy> Guest44417: Have you read any books or guides to Haskell yet?
17:29:22 <hiptobecubic> Guest44417, https://github.com/bitemyapp/learnhaskell
17:29:46 <Guest44417> I've looked at like 7 chapters of Learn You a Haskell but it was too difficult 
17:29:56 <Guest44417> so I tried doing the first course in bite my app
17:30:04 <Guest44417> and I'm stuck on the 2nd homework assignment
17:30:09 <lisbeth> guest44417, maybe you might try a video series instead.
17:30:20 <lisbeth> I find sometimes hearing someone explain it or seeing examples helps me alot
17:31:07 <lispy> lisbeth: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC-List.html
17:31:25 <lispy> lisbeth: Notice the comment at the start of the export list. It says that [] is builtin syntax
17:31:54 <lispy> I'm not sure if we can find something more primitive
17:32:16 <lisbeth> what do you mean built in syntax?
17:32:43 <lispy> you can't just write data [a] = [] | (:) a [a]
17:33:05 <lispy> The understanding that [] = Nil and (:) = Cons is built into the compiler
17:33:21 <arkeet> sure you can write it.
17:33:25 <arkeet> it's in fact written in the ghc library source.
17:33:27 <lisbeth> There must be a way to express it mathmatically
17:34:39 <indiagreen> is there an RSS/Atom feed for HWN?
17:35:49 <arkeet> I'm sure someone showed it to me before but I can't find it now.
17:36:11 <lisbeth> Unless what they did was write the code for a list in c or assembly
17:36:17 <lisbeth> maybe even binary
17:36:26 <arkeet> no, it's just a regular data structure.
17:36:33 <arkeet> you could define it yourself, though not with the same name:
17:36:36 <arkeet> data List a = Nil | Cons a (List a)
17:37:03 <haskell230> maybe I'll just go through the first course that Bite My App recommends and then just ask questions here?
17:37:07 <lisbeth> wow is that all you need to implement list?
17:37:21 <lispy> yeah
17:37:58 <lisbeth> could you explain what each of the parts mean?
17:38:18 <lispy> And for the most part, any special optimization magic the compiler does for built in types like list they try to expose so that you can do it for your types too.
17:39:24 <lispy> the 'data' keyword says we want to define a type. "List a" means that the type is named List and it takes one type parameter (let's call it 'a').
17:39:44 <lispy> The first data constructor is named Nil and represents an empty list
17:40:08 <lispy> The "|" (pipe) means we have another data constructor
17:40:44 <lispy> It's named "Cons" and it takes two parameters. The first one is of type 'a' and the second one is a list with element type 'a'.
17:41:11 <lisbeth> oh, so it's recursive
17:41:14 <lispy> So examples of List Int would look like Nil or (Cons 1 (Cons 2 (Cons 3 Nil)))
17:41:26 <lispy> Yes
17:41:58 <lisbeth> So that means that I need to know what cons and () do
17:42:19 <lispy> Parens are just for grouping (like in math)
17:42:35 <lispy> And Cons is from the definition of List
17:42:38 <lisbeth> If I understand correctly, a list is made out of a two pieces of data, one is the placeholder for what you want to store, and the other one is the location to the next piece of data in the list
17:43:00 <lispy> For Cons, yes
17:43:12 <lispy> Nil doesn't have any other data
17:45:28 <arkeet> Nil and Cons are defined by that line.
17:46:31 <lispy> Yeah
17:47:18 <lispy> We could have said data Ted a = Steve | Tim a (Ted a)
17:47:22 <lispy> and it would behave the same
17:47:48 <lispy> examples of Ted Int would look like Steve or (Tim 1 (Tim 2 (Tim 3 Steve)))
17:49:10 <tomtomgps> Hi can someone help me with this ?    https://www.reddit.com/r/haskell/comments/3e9lzv/help_i_want_to_write_function_that_gets_a_list/
17:50:04 <mauke> tomtomgps: like that
17:50:54 <mauke> congrations! you done it, etc.
17:51:19 <arkeet> tomtomgps: there is nothing left to do.
17:51:32 <tomtomgps> isn't pattern matching with the vertical bar ?
17:51:36 <arkeet> no, that's guards
17:51:46 <tomtomgps> ok different than ocaml then
17:52:30 <arkeet> yeah
17:53:15 <mauke> if you wanted to, you could also write: listlength xs = case xs of [] -> 0; _ : rest -> 1 + listlength rest
17:53:38 <lispy> mauke: ah you type faster than me
17:54:28 <mauke> inb4 lambdacase
17:55:15 <Gurkenglas> How do I interrupt a ghci computation?
17:55:33 <mauke> :t let listlength [] = 0; listlength (_ : (succ . listlength -> n)) = n in listlength
17:55:34 <lambdabot> (Enum c, Num c) => [t] -> c
17:55:41 <Gurkenglas> (RAM is overflown, browser won't react, but xchat is frugal enough to work)
17:56:09 * hackagebot generic-accessors 0.4.1 - stringly-named getters for generic data  https://hackage.haskell.org/package/generic-accessors-0.4.1 (GregHorn)
17:56:12 <Nik05> Gurkenglas Ctrl + C?
17:56:12 <mauke> the usual suspects: ^C, ^Z, ^\
17:56:22 <mauke> if ^Z works, follow up with kill -9 %1
17:56:40 <Gurkenglas> Neither work, though I'm on Windows.
17:56:48 <mauke> oh
17:57:10 <Gurkenglas> Stack just overflew, all is well. That took a few mins.
17:57:41 <Gurkenglas> suddenly ram usage is at 34%, it was at like 60% before i started that computation :D
17:57:48 <Pamelloes> Is it possible to use Persistent without an Id category?
17:58:04 <Pamelloes> *field
17:58:10 <Pamelloes> Not sure why I said category...
18:00:02 <hpc> Pamelloes: to a certain extent, you always want an id, i would think
18:00:42 <Pamelloes> hpc: That's true, but I'm interfacing with an existing database that doesn't have an id in the persistent sense.
18:03:46 <lispy> Gurkenglas: interrupting ghci on windows is different. There is a wrapper command you can use so that Ctrl-c work
18:04:15 <lispy> Gurkenglas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-windows.html
18:04:25 <hpc> ah
18:05:29 <Pamelloes> hpc: Do you know if Persistent Id's have to be sequential?
18:06:09 * hackagebot pandoc-crossref 0.1.2.3 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.2.3 (lierdakil)
18:06:37 <lisbeth> Sorry I had to take out the trash
18:07:49 <lisbeth> what is the mathmatical definition of ->
18:08:19 <tomtomgps> for all ?
18:08:39 <lispy> lisbeth: have you studied the lambda calculus?
18:08:54 <lisbeth> no
18:09:27 <lisbeth> I think what I am trying to do is implement -> in an imperative language
18:09:48 <lispy> If you had, I would say that in haskell \x -> e is like λx. e
18:10:17 <hpc> Pamelloes: i would naively assume that however the backend is able to identify particular pieces of data, you can do that in persistent as well
18:10:20 <lisbeth> lispy you'll have to be a bit more verbose
18:10:37 <lispy> lisbeth: Sorry, trying to think of how to explain it.
18:10:44 * hpc hasn't used persistent specifically, but has dealt with enough db stuff to make heads spin
18:10:49 <lispy> lisbeth: It's kind of "just a separator"
18:10:51 <Gurkenglas> Why does this stack overflow? http://lpaste.net/137127
18:10:59 <hackrilege> what is means? _2 f (a,b) = (,) a <$> f b
18:11:04 <Pamelloes> hpc: hm....... we'll see.
18:11:04 <Gurkenglas> (It's tic tac toe.)
18:11:27 <lisbeth> It's obviously a directional separator
18:11:36 <hpc> Pamelloes: yeah, that's usually the way to go with uncertain IO-y problems ;)
18:11:45 <lispy> lisbeth: in haskell if you say \x -> x, that defines the identity function. It just takes some x and returns it
18:11:48 <Pamelloes> Yeah.....
18:11:53 <Pamelloes> "....."
18:12:00 <lispy> lisbeth: you might say, x maps to x
18:12:48 <hackrilege> :t _2
18:12:49 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
18:13:22 <hackrilege> :t (,)
18:13:23 <lambdabot> a -> b -> (a, b)
18:14:02 <lisbeth> I am curious what -> means on the code level
18:14:23 <hackrilege> :t (->)
18:14:24 <lambdabot> parse error on input ‘->’
18:14:31 <Gurkenglas> (Overflows on ghci-ing "predict $ Gamestate False $ replicate 9 Nothing")
18:14:33 <hackrilege> oh...
18:14:44 <lispy> lisbeth: I figured. My comment about "maps to" is for the code level
18:15:04 <lispy> x |-> x
18:15:11 <lispy> That's how you might describe the identity function in math
18:15:21 <lispy> we would write \x -> x
18:17:02 <Gurkenglas> (Overflows even on "predict (Gamestate False $ [Just True, Just True, Nothing, Just False, Just True, Just False, Just False, Nothing, Nothing])")
18:17:35 <lisbeth> Could you show me some examples?
18:17:40 <lisbeth> so I can get an idea of what it does?
18:17:59 <hackrilege> (\a->(a,a)) 'a'
18:18:09 <hackrilege> > (\a->(a,a)) 'a'
18:18:10 <lambdabot>  ('a','a')
18:18:22 <lisbeth> \a is lamda a correct?
18:19:11 <hackrilege> map (\ (a,b)> a*2 + b) ( zip [1..10] [1..10])
18:19:21 <hackrilege> sorry..
18:19:24 <hackrilege> > map (\ (a,b)> a*2 + b) ( zip [1..10] [1..10])
18:19:26 <lambdabot>  <hint>:1:13: parse error on input ‘>’
18:19:37 <hackrilege> > map (\ (a,b) -> a*2 + b) ( zip [1..10] [1..10])
18:19:39 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
18:19:56 <lisbeth> There must be alot of math in -> that I am not seeing, then.
18:20:27 <lisbeth> The way I currently understand it is "Take two pieces of data like these and do this to them"
18:20:40 <hackrilege> (\ a -> g a) reads, "a function which takes an argument a and returns g of a "
18:21:16 <hackrilege> i dont understand the function _2, can someone explain it to me?
18:21:21 <hackrilege> :t _2
18:21:22 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
18:21:39 <lisbeth> do -> in a lamda and -> in a typeclass mean the same thign?
18:21:57 <hackrilege> i dont know what a field is, i think a functor is a mapping between a function and the real numbers, such as an integration or other measure
18:22:19 <hackrilege> lisbeth: i think simply no
18:22:48 <hackrilege> really the syntax of the lambda requires a precedinng (\, so defiantly not im sure
18:23:18 <lisbeth> I think / and -> in lamda are part of the same thing
18:23:30 <hackrilege> yeh thats what i mean
18:23:41 <lisbeth> that must be written somewhere
18:23:42 <hackrilege> and its a \
18:24:01 <hackrilege> yes its part of the language
18:24:13 <lisbeth> but where is the source?
18:24:25 <mauke> ... source?
18:24:56 <lisbeth> Where is the source code, binary, whatever that creates the lamda
18:25:05 <hackrilege> check out the haskell prelude, its totally not what your after, but i think it is in the source of the compiler which interprets the haskell source... so probably not something accessible 
18:25:17 <mauke> lisbeth: in ghc
18:25:39 <hackrilege> :t (::)
18:25:40 <lambdabot> parse error on input ‘::’
18:26:10 * hackagebot warp 3.1.0 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.0 (KazuYamamoto)
18:26:16 <hackrilege> yeh, these are protected symbols, they arnt defined in haskell syntax, they are part of the language 
18:26:50 <lisbeth> the what is the language?
18:26:55 <lisbeth> *then
18:27:15 <lisbeth> I think what you are saying is that the origins of those are so old that they were written in another language and are no longer present in haskell
18:27:24 <mauke> ???
18:27:38 <hackrilege> i have this definition for _2; _2 f (a,b) = (,) a <$> f b. i do not understand it. 
18:27:39 <hackrilege> :t _2
18:27:40 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
18:27:47 <hackrilege> :t <$>
18:27:48 <lambdabot> parse error on input ‘<$>’
18:27:53 <mauke> that's a simplified definition
18:27:55 <hackrilege> do not help me as i dont knnow what is a Field2
18:28:05 <hackrilege> :t (<$>)
18:28:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:28:15 <mauke> :t let _2 f (a,b) = (,) a <$> f b in _2
18:28:16 <lambdabot> Functor f => (t -> f b) -> (a, t) -> f (a, b)
18:28:23 <mauke> simplified type
18:28:45 <juri_> I'm trying to upgrade a program to use the new optparse-applicative, but i'm confused about how to use a custom reader. help?
18:29:13 <hackrilege> wow you got rid of the Field bit...
18:29:28 <mauke> no, I didn't
18:29:39 <hackrilege> before the =>
18:29:49 <juri_> my reader is of type String -> Maybe OutputFormat, which used to work with the 'reader' option in optparse 9.1.1...
18:29:50 <mauke> I simply copied your code to show that it was simplified
18:30:42 <hackrilege> oh i see... so it not a good definition? 
18:31:11 <mauke> good in what sense?
18:31:27 <hackrilege> complete
18:31:40 <mauke> it is complete
18:32:44 <hackrilege> so confused. it has a different type, how can it be equivalent? oh wait thats kind of a stupid question, so these types are in fact equivalent, i suppose i should be able to infer what is a Field then?
18:32:52 <tomtomgps> when do we use otherwise instead of else ?
18:33:08 <mauke> they're not equivalent, but the Field2 version is more general
18:33:09 <hackrilege> only after a |preceding =
18:33:14 <indiagreen> tomtomgps: in guards
18:33:19 <indiagreen> > otherwise
18:33:20 <mauke> tomtomgps: never
18:33:21 <lambdabot>  True
18:33:36 <hackrilege> then my version is incomplete.
18:34:21 <tomtomgps> ok  
18:34:24 <tomtomgps> thx
18:36:01 <hackrilege> the syntax is f a | a==True = "hello" ;        | otherwise = False
18:36:04 <Gurkenglas> (Found the problem, I missed decreasing a list index by 1 and it led me into an infinite loop before I ever got an index error.)
18:36:24 <hackrilege> oops, i mean "False"
18:37:00 <hackrilege> Gurkenglas: your code looked great but it was way over my head
18:37:40 <hackrilege> mauke: what is a Field2?
18:38:26 <Gurkenglas> hackrilege, hylo is great. Its type signature is "Functor f => (f b -> b) -> (a -> f a) -> a -> b".
18:38:58 <Gurkenglas> Now deduce what it does.
18:40:05 <hackrilege> Gurkenglas, i guess it applies its second argument to its third, and then applies the first argument to that and returns the result
18:40:26 <Gurkenglas> hackrilege, but what if b isn't a?
18:40:36 <Gurkenglas> hylo works for all a and b.
18:40:42 <hackrilege> omg!
18:41:03 <juri_> does anyone else use optparser-applicative?
18:41:12 <hackrilege> nope
18:41:24 <hackrilege> should I?
18:41:24 <pacak> juri_: A bit.
18:41:51 <juri_> pcack: do you use custom readers?
18:43:48 <Gurkenglas> You started right. You have an (f b -> b), an (a -> f a) and an a, and you've applied the second to the third. What can you do next?
18:44:01 <pacak> juri_: Not really.
18:44:59 <hackrilege> no clue
18:45:37 <hackrilege> try and turn an fa into an f b ?
18:46:07 <hackrilege> is there something about these functors im missing?
18:46:22 <Gurkenglas> We know nothing about a and b, but we do know about f that it is a functor, and so we also have access to fmap, which can lift any function.
18:46:35 <hackrilege> :t fmap
18:46:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:46:46 <hackrilege> aha!, so it needs an (a->)
18:46:48 <hackrilege> aha!, so it needs an (a->b)
18:47:10 <hackrilege> but i see no (a->b) in the type of hylo...
18:47:27 <hackrilege> oh duh its the last 2 arguments...
18:47:30 <Gurkenglas> That's not the path I was going for, but you could actually find it faster than I planned
18:47:32 <athan> Gurkenglas: And is (f a -> a) cata, while (b -> f b) is ana?
18:47:32 <Stratege> fmap unsafeCoerce *runs off*
18:48:15 <Gurkenglas> athan, they are catamorphisms and anamorphisms respectively, but have nothing directly to do with the cata and ana the package defines, I think
18:48:28 <init> recursion helps there
18:48:35 <Gurkenglas> init, no spoilers >:c
18:48:40 <hackrilege> omg
18:49:00 <init> Gurkenglas: I just said recursion helps, nothing else!
18:49:02 <hackrilege> i dont even know how to create a functor!
18:49:05 <athan> oh I didn't see that there was a package. Thank you
18:49:35 <athan> hackrilege: Just be patient :) it will all come together soon
18:49:37 <init> Gurkenglas: also, that's really nice! you can derive lots of thing with just a type :p 
18:49:39 <athan> just one step at a time
18:49:50 <Gurkenglas> hackrilege, ignore everything we said since your "the last 2 arguments" line, you're close :D
18:50:24 <athan> Gurkenglas: Wait wat pacakge ._. ?
18:50:45 <Gurkenglas> athan, https://hackage.haskell.org/package/recursion-schemes
18:50:53 <athan> oye! Okay! thank you!
18:51:08 <athan> Gurkenglas: There's also @hackage from lambdabot ;)
18:51:11 * hackagebot themoviedb 1.1.1.0 - Haskell API bindings for http://themoviedb.org  https://hackage.haskell.org/package/themoviedb-1.1.1.0 (PeterJones)
18:51:12 <Gurkenglas> Fdvehjethr ekmett again :D
18:51:46 <hackrilege> im going to take a function which creates a functor from type a and a function which takes a functor of type b and returns something of type be, the function will then return a function which takes type a and returns type b?
18:52:23 <Gurkenglas> hackrilege, would you rephrase that into a type signature pls?
18:53:03 <hackrilege> hylo :: Functor f => (a -> f a) -> (f b -> b) -> (a->)
18:53:11 <hackrilege> hylo :: Functor f => (a -> f a) -> (f b -> b) -> (a->b)
18:53:20 <hackrilege> :t hylo
18:53:20 <lambdabot> Not in scope: ‘hylo’
18:53:24 <athan> holy frick this is cool
18:53:37 <athan> :t Data.Functor.Foldable.hylo
18:53:38 <lambdabot> Not in scope: ‘Data.Functor.Foldable.hylo’
18:53:56 <hackrilege> lol "Generalized bananas, lenses and barbed wire"
18:54:49 <hackrilege> :t gzygo 
18:54:50 <lambdabot> Not in scope: ‘gzygo’
18:55:05 <hackrilege> :t Data.Functor.Foldable.gzygo 
18:55:06 <lambdabot> Not in scope: ‘Data.Functor.Foldable.gzygo’
18:55:14 <hackrilege> lambdabot hates your package 
18:55:48 <Gurkenglas> hackrilege, you're planning to implement hylo by applying the a -> f a to the a, then turn the f a into an f b using an (f a -> f b) that you get from applying fmap to some (a -> b), then turn the f b into the b we need with the (f b -> b). I got you right?
18:56:49 <hackrilege> gurkenglas: no im thinking i can use hylo to deduce (a->b) from (f a -> f b), no im completely lost
18:57:20 <Gurkenglas> Ah well, I'll just try to get you onto the path that I was planning originally
18:57:49 <hackrilege> okey!
18:58:12 <Gurkenglas> We turned the a into an f a with the a -> f a. fmap allows us to lift any functions we have. We have (a -> f a) and (f b -> b).
18:58:22 <hackrilege> nu, mu, fix... its like finding Atlantis... 
18:58:43 <hackrilege> :t fmap
18:58:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:58:51 <Gurkenglas> We can lift those two to (f a -> f (f a)) and (f b -> b) into (f (f b) -> f b).
18:59:21 <Gurkenglas> What can we do with those?
19:00:04 <hackrilege> yeh i guessed this lifty bit, but now i have nested functors and i dont even know how to construct a functor...
19:00:16 <nshepperd> notice that 'forall a b. (Const r a -> Const r b)' exists. so (f a -> f b) -> (a -> b) is not generally possible
19:00:19 <Stratege> Gurkenglas mind checking your pm? didn't want to ask the question here so as to not spoiler things.
19:00:27 <hackrilege> thanks
19:01:29 <hackrilege> im getting frustraited! im retarded
19:02:17 <hackrilege> lets compose them!
19:02:22 <hackrilege> i have no idea...
19:02:32 <Gurkenglas> nshep's comment does not immediately relate to the current question
19:03:11 <hackrilege> i have transformed a functor creator and destructor into the same thing nested inside a functor. great...
19:03:13 <init> hackrilege: no you aren't! those abstractions aren't so trivial as they look, the first time I saw them I pretty much spent 2+ hours playing with types until I realized the implementations of the functions with those types
19:03:37 <Stratege> note: not getting them doesn't have to do with being retarded or anything, he's not leading you down a simple question. (Although once one has the answer it will, as is so often is the case, appear obvious)
19:04:04 <hackrilege> argh! so frustraiting, im itchy!
19:04:04 <Gurkenglas> We have used fmap and now have one of each of the following: a, a -> f a, f a -> f (f a), f (f b) -> f b, f b -> b. How far can we get?
19:04:50 <hackrilege> i can give a to the a -> fa, now i have an f a, which gives me an f (f a) after fmap
19:05:18 <hackrilege> i can turn an f (f b) into a "b"
19:05:23 <Gurkenglas> Have we applied fmap to all functions we have?
19:06:08 <hackrilege> i guess we could keep going this way to produce further nestings of a and b but lets try crossing them so...
19:06:39 <hackrilege> um can i have the initial argument types again, its (a -> f a) -> (b -> f b) -> (a->b) right?
19:06:41 <Gurkenglas> No matter how many finitely many steps we nest the two, we won't be able to turn the a into a b.
19:06:43 <Gurkenglas> yep
19:06:55 <Gurkenglas> Nope, I'm deliberately shoving you down this path :D
19:07:09 <hackrilege> then how the hell am i generating this (a->b) !?
19:07:34 <Gurkenglas> Hint: One of the previous words is crucial.
19:07:34 <Stratege> shouldn't it be (f b -> b) for the second argument?
19:07:49 <Gurkenglas> Yes, he just mistyped.
19:08:08 <hackrilege> i need at some point an f $ f $ f .. f $ f b otherwise i cant find a "b".
19:08:21 <hackrilege> yah sorry for the typo
19:08:41 <Stratege> np, as long as you aren't trying to work with the wrong type all is good ^^
19:08:55 <hackrilege> can i make fmap with the a and the (f b -> b)?
19:09:18 <hackrilege> so i get (f a -> f (f b -> b))?
19:09:34 <Gurkenglas> What function of type (a -> f b -> b) do you have?
19:09:41 <hackrilege> am i doing something wrong here
19:10:09 <hackrilege> the first two arguments are of that type
19:10:37 <Gurkenglas> Dangit, each of the two paths that lead to the solution of the problem are blocked by one implicit assumption you have that I'm not sure how to break without giving away the respective solution
19:10:52 <hackrilege> no they are not
19:11:20 <Gurkenglas> The first two arguments are of the types (a -> f a) and (f b -> b)
19:11:25 <hackrilege> can i flip the first argument?
19:11:39 <hackrilege> i need (f a -> a)
19:11:57 <Gurkenglas> You can't, but now I'm curious. What would you do with that?
19:13:01 <hackrilege> id give it an (f a) and (.) the resultant (a) to the (f b -> b)
19:13:17 <Gurkenglas> But a isn't f b
19:13:38 <hackrilege> yes, see how confused i am!?
19:14:26 <hackrilege> just bumping this; a, a -> f a, f a -> f (f a), f (f b) -> f b, f b -> b.
19:14:34 <nshepperd> let hylo afa fbb a = _
19:14:44 <hackrilege> (a -> f b -> b)
19:14:51 * nshepperd notes that there are actually four things in scope there
19:15:05 <Gurkenglas> Where are you getting an (a -> f b -> b)?
19:15:46 <hackrilege> im trying to find it!
19:16:02 <Gurkenglas> If f a -> f (f a) and f (f b) -> f b are going to be useful to us, we'll also want the functions we get by fmapping even further:
19:16:31 <Gurkenglas> f (f a) -> f (f (f a)), f (f (f b)) -> f (f b), and more
19:17:36 <hackrilege> so i get (f (f a) -> f (f (f a))) and (f(f(f b))->f(f b))
19:18:04 <hackrilege> yeh sorry jynx, i really dont see how this helps us getting a to b
19:18:17 <Gurkenglas> "jynx"? o.o
19:18:37 <hackrilege> we said the same thing
19:18:46 <Gurkenglas> I'll spoil the path through those then, because its bold enough to be entertaining to anyone watching who hasn't seen through it yet
19:19:10 <hackrilege> ok...
19:19:15 <Gurkenglas> We turn the a into an f a, then the f a into an f (f a) with the fmapped thing
19:19:33 <Gurkenglas> then into an f (f (f (f (f a)))) with a few more fmaps, and continue
19:19:41 <hackrilege> yes...
19:19:46 <Gurkenglas> Until we get a
19:19:55 <Gurkenglas> > cycle "f ("
19:19:56 <lambdabot>  "f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
19:20:02 <hackrilege> we get a highly nested functor, and no closer to mapping to type b
19:20:10 <Gurkenglas> Do you see an a? I don't. Good enough :P
19:20:32 <hackrilege> !???!?!?!?!?!?!
19:20:41 <hackrilege> english man
19:20:56 <hackrilege> this is not of type b!
19:21:41 <hackrilege> your going to hope that by applying your functor extractor many times since it wont find an a it will be happy!?
19:21:58 <roboguy_> I think type holes are a good way to look at figuring this out
19:22:07 <Gurkenglas> Applying the a -> f a infinitely often, we disappear the a into infinity. Since our computer only has finite time, anything at the point of infinity isn't going to matter to us - anything that doesn't diverge is going to stop by something like lazy evaluation before gettingthere
19:22:33 <Gurkenglas> We then remove the infinitely many "f (" one at a time using the (f b -> b)
19:22:34 <hackrilege> :t _
19:22:35 <lambdabot>     Found hole ‘_’ with type: t
19:22:35 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
19:22:35 <lambdabot>                the inferred type of it :: t at Top level
19:22:45 <Gurkenglas> It's completely cheating and I love it :P
19:22:49 <hackrilege> that is the total of my knowladge of type holes...
19:23:04 <Gurkenglas> Let me illustrate in what sort of case this could work:
19:23:15 <hackrilege> thanks!
19:24:06 <Gurkenglas> f = Either Int
19:24:13 <hackrilege> we have hylo a b = itterate fmap?
19:24:14 <Gurkenglas> (You know Either?)
19:24:28 <hackrilege> :t apply2
19:24:29 <lambdabot> Not in scope: ‘apply2’
19:24:38 <hackrilege> :t apply
19:24:39 <lambdabot> Not in scope: ‘apply’
19:24:42 <hackrilege> omg!
19:24:51 <hackrilege> f (Left a) = a
19:26:13 * hackagebot vimeta 0.2.0.0 - Frontend for video metadata tagging tools  https://hackage.haskell.org/package/vimeta-0.2.0.0 (PeterJones)
19:26:14 <Gurkenglas> @let aTofa = \(i, j) = if j == 0 then Left i else Right (i + 1, j - 1)
19:26:14 <lambdabot>  Parse failed: Parse error: =
19:26:22 <Gurkenglas> @let aTofa (i, j) = if j == 0 then Left i else Right (i + 1, j - 1)
19:26:23 <lambdabot>  Defined.
19:26:32 <Gurkenglas> > aTofa (2, 2)
19:26:33 <lambdabot>  Right (3,1)
19:26:41 <Gurkenglas> make sense?
19:26:55 <Gurkenglas> (that function alone, i mean)
19:27:59 <Gurkenglas> > fmap (fmap (fmap aTofa)) $ fmap (fmap (aTofa)) $ fmap aTofa $ aTofa (5, 5)
19:28:00 <lambdabot>  Right (Right (Right (Right (9,1))))
19:28:34 <Gurkenglas> > fmap (fmap (fmap (fmap aTofa))) $ fmap (fmap (fmap aTofa)) $ fmap (fmap (aTofa)) $ fmap aTofa $ aTofa (5, 5)
19:28:35 <lambdabot>  Right (Right (Right (Right (Right (10,0)))))
19:28:50 <Gurkenglas> > fmap (fmap (fmap (fmap (fmap aTofa))))) $ fmap (fmap (fmap (fmap aTofa))) $ fmap (fmap (fmap aTofa)) $ fmap (fmap (aTofa)) $ fmap aTofa $ aTofa (5, 5)
19:28:51 <lambdabot>  <hint>:1:39: parse error on input ‘)’
19:28:58 <Gurkenglas> > fmap (fmap (fmap (fmap (fmap aTofa)))) $ fmap (fmap (fmap (fmap aTofa))) $ fmap (fmap (fmap aTofa)) $ fmap (fmap (aTofa)) $ fmap aTofa $ aTofa (5, 5)
19:28:59 <lambdabot>  Right (Right (Right (Right (Right (Left 10)))))
19:30:16 <nshepperd> maybe you should explain how hylo is actually implemented
19:30:29 <Gurkenglas> Soon :D
19:30:36 <nshepperd> it's not entirely obvious how to fmap something infinitely
19:31:03 <Stratege> really? that sounds like the kind of thing that should be obvious. I mean... infinite application of things is normal, right?
19:31:44 <Gurkenglas> @let fbTob = either id id :: Either Int Int -> Int
19:31:45 <lambdabot>  Defined.
19:31:50 <Stratege> (the answer ofc, is that it's anywhere close to obvious)
19:32:43 <Gurkenglas> I've defined an aTofa and a bTofb, where a is (Int, Int) and b is Int. Our a shall be (5, 5).
19:33:07 <nshepperd> Gurkenglas: they pinged out
19:33:11 <Gurkenglas> Aww.
19:33:24 <Gurkenglas> Well I'll finish for the rest of the listeners and I'll link them to the logs later.
19:33:43 <roboguy_> > (\f g -> _) :: Functor f => (a -> f a) -> (f b -> b) -> (a -> b)
19:33:44 <lambdabot>      Found hole ‘_’ with type: a1 -> b1
19:33:44 <lambdabot>      Where: ‘a1’ is a rigid type variable bound by
19:33:44 <lambdabot>                  an expression type signature:
19:33:52 <hackrilege> sorry i fropped my internet connection, where were we?
19:34:00 <roboguy_> hmm, shame that ghc adds those 1s to the type variables
19:34:21 <Gurkenglas> hackrilege, see the bottom of http://tunes.org/~nef/logs/haskell/?C=M;O=D
19:34:43 <Gurkenglas> (Well, of today's link on there)
19:35:00 <Gurkenglas> > fmap undefined (Left 5) -- As lambdabot is about to say, fmapping any function across a Left doesn't make a difference.
19:35:01 <lambdabot>  Left 5
19:35:44 <Gurkenglas> So infinitely fmapping our aTofa is going to work if our a turns into a Left at some point.
19:36:11 <Gurkenglas> (5, 5) will thereby be transformed into Right (Right (Right (Right (Right (Left 10))))) and stay there
19:36:44 <Gurkenglas> The bTofb can now unpack that "infinitely wrapped" functor one layer at a time
19:36:47 <Gurkenglas> The result:
19:37:08 <Gurkenglas> > hylo bTofb aTofa (5, 5)
19:37:10 <lambdabot>  Not in scope: ‘bTofb’
19:37:16 <Gurkenglas> > hylo fbTob aTofa (5, 5)
19:37:18 <lambdabot>  10
19:37:31 <Gurkenglas> We've implemented addition using (+1) and (-1).
19:38:14 <juri_> :t ask
19:38:15 <lambdabot> MonadReader r m => m r
19:38:37 <Gurkenglas> hackrilege, now, there's one path left by which you can arrive at the solution.
19:39:10 <hackrilege> our functor must transform like left to right at some point?
19:39:24 <hackrilege> to indicate the base case
19:39:34 <hackrilege> we must supply a a->b
19:39:34 <Gurkenglas> (The example above fmaps the (Int, Int) until it disappears out of vision.)
19:39:36 <hackrilege> an*
19:39:51 <Gurkenglas> A missing ingredient to it is that we have four functions to use when defining hylo:
19:39:53 <roboguy_> actually, it terminates when it gets a Left
19:40:30 <Gurkenglas> (f b -> b), (a -> f a), fmap and hylo itself. After all, recursive definitions are commonplace in haskell
19:40:32 <hackrilege> no you provide a condition turning a left int pair into a right int pair, and then opperate on that type, and anyway both a and b are wither here...
19:40:51 <Gurkenglas> :t aTofa
19:40:52 <lambdabot> (Eq t1, Num t, Num t1) => (t, t1) -> Either t (t, t1)
19:41:00 <Gurkenglas> :t aTofb
19:41:01 <lambdabot>     Not in scope: ‘aTofb’
19:41:01 <lambdabot>     Perhaps you meant ‘aTofa’ (line 143)
19:41:08 <Gurkenglas> :t fbTob
19:41:09 <lambdabot> Either Int Int -> Int
19:41:54 <Gurkenglas> Umm, I hoped lambdabot to reply (Int, Int) -> Either Int (Int, Int) there. Act as if he did. a and b are different.
19:42:35 <hackrilege> what!? i cant ignore its actual type!
19:43:09 <Gurkenglas> :t aTofa :: (Int, Int) -> Either Int (Int, Int) -- There, he doesn't complain, it's just a specialization.
19:43:09 <lambdabot> (Int, Int) -> Either Int (Int, Int)
19:43:52 <Gurkenglas> Your ingredients are (f b -> b), (a -> f a), a, fmap and ((f b -> b) -> (a -> f a) -> a -> b). Construct an ((f b -> b) -> (a -> f a) -> a -> b).
19:44:12 <hackrilege> ah ok
19:44:43 <Gurkenglas> (Of course, you can't simply say hylo = hylo. Find the simplest different implementation :D)
19:46:19 <hackrilege> hylo aTofa fbTob a = hylo (fmap aTofa fbTob) a
19:46:38 <hackrilege> :t fmap
19:46:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:46:53 <hackrilege> hylo aTofa fbTob a = hylo (fmap aTofa) (fmap  fbTob) a
19:47:01 <Denommus`> I wish (<$>) had a higher precedence than ($)
19:47:35 <Gurkenglas> (fbTob comes first)
19:47:45 <roboguy_> Denommus`: it does
19:47:56 <roboguy_> ($) is infixr 0
19:49:03 <hackrilege> hylo aTofa fbTob a = hylo (aTofa a)  (fmap  fbTob) a
19:49:29 <Gurkenglas> hackrilege, I think that's very close. Your problem: (aside from the arguments being flipped, I'll correct that:)
19:49:33 <hackrilege> hylo aTofa fbTob a = fmap  fbTob $ hylo (aTofa a)  (fbTob) a
19:49:57 <Gurkenglas> (the one above Denom's last line)
19:50:06 <Denommus`> roboguy_: ... I think I forgot what made me confused
19:50:18 <Gurkenglas> :t hylo (fmap fbTob) (fmap aTofa)
19:50:19 <lambdabot> (Eq t1, Num t1) => Either Int (Int, t1) -> Either Int Int
19:50:45 <nitrix> roboguy_: <$> has infixl 4, doesn't that mean the opposite, ($) has higher precedence?
19:50:48 <Gurkenglas> umm let me just
19:50:51 <Gurkenglas> @undefine
19:50:51 <lambdabot> Undefined.
19:51:05 <nitrix> roboguy_: 0 is higher than 4 on the list, no?
19:51:37 <hackrilege> this is rough...
19:51:56 <Gurkenglas> @letlpaste 137130
19:51:57 <lambdabot>  Defined.
19:52:10 <Gurkenglas> :t hylo (fmap fbTob) (fmap aTofa)
19:52:11 <lambdabot> Functor f => f a -> f b
19:52:18 <roboguy_> nitrix: on which list? You do it last...
19:52:23 <hackrilege> hylo f e g = f . e . fmap (hylo f e g). g 
19:53:02 <hackrilege> i win
19:53:17 <Gurkenglas> :t \f e g -> f . e . fmap (hylo f e g). g 
19:53:18 <lambdabot> Functor f => (f (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> f (a -> a -> a)) -> (a -> a -> a) -> a -> a -> a -> a
19:53:31 <Gurkenglas> That doesn't look right :D
19:53:32 <hackrilege> :t hylo (fbTob) (aTofa)
19:53:32 <lambdabot>     No instance for (Functor f0) arising from a use of ‘hylo’
19:53:32 <lambdabot>     The type variable ‘f0’ is ambiguous
19:53:32 <lambdabot>     Note: there are several potential instances:
19:53:39 <roboguy_> hackrilege: close, but not quite. thelast argument of hylo isn't (necessarily) a function
19:54:16 <Gurkenglas> (weird, your last lambdabot query should have worked i think...)
19:54:25 <hackrilege> @let hylo' f e g = f . e . fmap (hylo' f e g). g
19:54:26 <lambdabot>  Defined.
19:54:26 <roboguy_> > show $ 1 + 2    -- addition first, then ($) application
19:54:28 <lambdabot>  "3"
19:54:31 <hackrilege> :t hylo'
19:54:32 <lambdabot> Functor f => (b -> b1) -> (f b1 -> b) -> (a -> f a) -> a -> b1
19:55:22 <hackrilege> :t hylo
19:55:23 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
19:56:03 <hackrilege> @let hylo'  e g =  e . fmap (hylo' f e g). g
19:56:03 <hackrilege> :t hylo'
19:56:04 <lambdabot>     Not in scope: ‘hylo'’
19:56:04 <lambdabot>     Perhaps you meant ‘hylo’ (line 143)
19:56:04 <lambdabot>  .L.hs:153:38:
19:56:04 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
19:56:04 <lambdabot>      Expected type: ((a -> a) -> a -> a) -> a -> a
19:56:21 <hackrilege> @let hylo'  e g =  e . fmap (hylo' e g). g
19:56:22 <lambdabot>  Defined.
19:56:24 <hackrilege> :t hylo'
19:56:25 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
19:56:47 <Gurkenglas> *looks on channel screen* oh hey you did it
19:57:27 <hackrilege> no i got bored and copy pasted the def
19:57:32 <Gurkenglas> https://www.youtube.com/watch?v=-Lw_smO-CjQ
19:57:48 <hackrilege> as is the danger with your time consuming teaching style!
19:57:58 <init> I "realized" it by using type holes
19:58:37 <init> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b ; hylo fold unfold = go where go :: a -> b ; go = _ 
19:58:38 <Gurkenglas> I thought you were way close back when you realized the (a -> b) you need is in the type signature of hylo itself
19:58:46 <Stratege> ^ pretty much that + the recursion suggestion can lead one on the proper path
19:58:51 <hackrilege> but i get it  hylo  e g =  e . fmap (hylo e g). g
19:58:53 <hackrilege> thats how you get your recursion...
19:59:08 <roboguy_> > (\f g -> f . _ . g) :: Functor f => (f b -> b) -> (a -> f a) -> (a -> b)        -- hackrilege: Here's an example of how type holes can help when you have part of a solution
19:59:09 <lambdabot>      Found hole ‘_’ with type: f1 a1 -> f1 b1
19:59:09 <lambdabot>      Where: ‘f1’ is a rigid type variable bound by
19:59:09 <lambdabot>                  an expression type signature:
19:59:19 <roboguy_> pretend those 1s aren't there
19:59:21 <Gurkenglas> Do you see the infinite application of g, then the infinite application of f? :D
19:59:56 <hackrilege> nice roboguy:
20:00:25 <murphxyz> Here's a newb question. I'm trying to read in an integer (as an int, so that I can do math to it at some point), and then add it to a string and print it out. Here's what I have, but I'm getting type errors, and I'm lost: https://www.refheap.com/106846
20:00:30 <Stratege> I want to point out that hylo is mad in just all the right ways.
20:00:39 <hackrilege> yes the dots compose nicely to get your infinite casting 
20:00:53 <roboguy_> murphxyz: move the close parenthesis to the end of the line
20:01:08 <hackrilege> > read 1"
20:01:09 <lambdabot>  <hint>:1:8:
20:01:10 <lambdabot>      lexical error in string/character literal at end of input
20:01:10 <hackrilege> > read "1"
20:01:11 <roboguy_> murphxyz: as it stands, you are trying to ++ an IO action to a String
20:01:12 <lambdabot>  *Exception: Prelude.read: no parse
20:01:20 <hackrilege> (> read "1")::Int
20:01:27 <hackrilege> > ( read "1")::Int
20:01:28 <lambdabot>  1
20:01:42 <murphxyz> ah, print is the IO action?
20:01:48 <roboguy_> murphxyz: yep!
20:01:52 <murphxyz> great. Thanks!
20:01:57 <roboguy_> well, print (show xInt) is, specifically
20:02:19 <roboguy_> print by itself is a function that takes showable argument and gives back an IO action
20:02:22 <hackrilege> looks like you need more parenthesis.... try a dollar after print...
20:03:44 <hackrilege> :t aTofa
20:03:46 <lambdabot> Not in scope: ‘aTofa’
20:03:50 <murphxyz> is it not valid to try to specify the type of the value that gets extracted from an IO action like this? `x <- getLine :: Int`
20:04:02 <hackrilege> doh, i still want to know how to make a functor...
20:04:50 <hackrilege> murphxyz: no thats fine, its just you need to only supply one argument to print, you need to bracket off everything after
20:05:49 <ttt_fff> is /-> a valid ahskell func name?
20:06:02 <Stratege> hackrilege as in "implement an instance of functor" or as in "given any value, construct any functor from it"?
20:06:02 <hackrilege> > (\i->putStrLn (((read i)::Int)++"things are good")) 0
20:06:03 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Int’
20:06:03 <lambdabot>      In the first argument of ‘(++)’, namely ‘((read i) :: Int)’
20:06:03 <lambdabot>      In the first argument of ‘putStrLn’, namely
20:06:31 <murphxyz> hackrilege now I'm getting a compiler error with this: https://www.refheap.com/106847
20:06:48 <hackrilege> > (\i->putStrLn (( show((read i)::Int) )++"things are good")) 0
20:06:49 <lambdabot>      No instance for (Num String) arising from the literal ‘0’
20:06:49 <lambdabot>      In the first argument of ‘\ i
20:06:49 <lambdabot>                                  -> putStrLn
20:06:56 <Stratege> :t getLine
20:06:57 <lambdabot> IO String
20:07:03 <Stratege> ^ that should give you a clue as to why you get a compiler error.
20:07:17 <hackrilege> sorry...
20:07:51 <hackrilege> > (\i->putStrLn (( show((read i)::Int) )++"things are good")) "0"
20:07:52 <lambdabot>  <IO ()>
20:08:25 <roboguy_> ttt_fff: for a function? yes
20:08:28 <roboguy_> > (/->)
20:08:29 <lambdabot>  Not in scope: ‘/->’
20:08:38 <murphxyz> Stratege aren't I telling getLine to extract the value as an Int with the :: Int ? or is that not valid (sorry, very beginner)
20:08:44 <roboguy_> > let a /-> b = a + b in 2 /-> 2
20:08:45 <lambdabot>  4
20:09:15 <Stratege> murphxyz you can not tell the type system to implicitly coerce things by telling it it should have a different type, you need to apply a function to your string to turn it into an Int, one of type String -> Int, that is.
20:09:18 <roboguy_> > let (/->) = 3 in (/->)    -- Even for a non-function, actually
20:09:19 <lambdabot>  3
20:09:33 <murphxyz> okay, thanks!
20:09:39 <hackrilege> murphxyz: now you are applying the type specifyer in the wrong place
20:09:52 <ttt_fff> roboguy_ ++
20:10:33 <hackrilege> also getLine will return a string, you need to apply read before you can get it as an Int
20:10:38 <Stratege> murphxyz the read function that hackrilege has shown is a good candidate, but since it's polymorphic in its output you tend to be forced to annotate the type you want the result to have, just like he just showed.
20:11:50 <hackrilege> Stratege: do you knnow why lambdabot didnt print the result?
20:12:24 <hackrilege> > (\i->( show((read i)::Int )++"things are good")) "0"
20:12:26 <lambdabot>  "0things are good"
20:12:26 <Stratege> because lambdabot prints the return value of a function which for print is well... unit wrapped in IO
20:12:49 <Stratege> (or for putStrLn as you used there)
20:13:13 <hackrilege> i think i get it
20:13:20 <hackrilege> :t hylo
20:13:21 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
20:13:27 <roboguy_> hackrilege: allowing IO would be dangerous
20:13:34 <murphxyz> Yay! I got it straight now: https://www.refheap.com/106848 thanks for your help!
20:13:38 <Stratege> ^ and yeah, it's got the good sense of not allowing that
20:13:47 <hackrilege> how do i construct something of type (f b -> b)
20:13:47 <roboguy_> I should say, *running* IO is dangerous
20:13:49 <hackrilege> ?
20:13:54 <roboguy_> hackrilege: out of what?
20:14:05 <hackrilege> roboguy_: totally!
20:14:08 <Stratege> :t unsafePerformIO
20:14:09 <lambdabot> Not in scope: ‘unsafePerformIO’
20:14:21 <Stratege> heh...
20:14:41 <hackrilege> lol
20:14:44 <Stratege> hackrilege decide upon which functor to use, instead of trying to write one for every functor.
20:15:02 <roboguy_> yeah. You can't write it for some functors
20:15:11 <hackrilege> i dont know what is a functor, im trying to make any functor!
20:15:23 <Stratege> most things are functors
20:15:24 <roboguy_> a functor is something you can fmap over
20:15:25 <hackrilege> (a -> f a)
20:15:39 <hackrilege> so a datatype is a functor?
20:15:45 <roboguy_> not always
20:15:48 <roboguy_> some are
20:15:52 <Stratege> do you know what a typeclass is?
20:15:58 <jgcoded> Hello, I downloaded stack. How do I now get GHC 7.10?
20:16:16 <hackrilege> :t hylo (Just) (fromJust)
20:16:16 * hackagebot yesod-bin 1.4.13 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.13 (MichaelSnoyman)
20:16:17 <lambdabot>     Occurs check: cannot construct the infinite type:
20:16:17 <lambdabot>       a1 ~ f0 (Maybe a1)
20:16:17 <lambdabot>     Expected type: f0 (Maybe a1) -> Maybe a1
20:16:53 <hackrilege> :t hylo
20:16:54 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
20:16:58 <roboguy_> hackrilege: the arguments are backwards
20:17:08 <hackrilege> :t hylo (fromJust) (Just) 1
20:17:09 <lambdabot> b
20:17:12 <Denommus`> Stratege: you can say that lots of datatypes with kind * -> * are functors, but "most things are functors" is highly misleading XD
20:17:30 <roboguy_> hackrilege: but that is an excellent example of something of type (f b -> b) that can't (really) exist
20:17:40 <hackrilege> > hylo (fromJust) (Just) 1
20:17:41 <roboguy_> watch:
20:17:44 <lambdabot>  mueval-core: Time limit exceeded
20:17:47 <roboguy_> yep
20:17:48 <hackrilege> lol
20:17:57 <hackrilege> derp
20:18:13 <hackrilege> so how do we terminate the recursion?
20:18:26 <roboguy_> it depends. For Maybe, "Nothing" would terminate it
20:18:53 <hackrilege> can you write it?
20:19:38 <Stratege> Denommus eh anything with a "longer" (for lack of better word) kind can be turned into * -> * at which point, you can probably make it a Functor. Question is wether or not that makes sense.
20:19:56 <roboguy_> hackrilege: using hylo and Maybe, you can never get something that isn't either an infinite loop or an error (a "bottom")
20:20:11 <init> you can get a really shiny const 
20:20:18 <roboguy_> > hylo fromJust (\ignored -> Nothing) 'z'    -- Here's the error version
20:20:19 <lambdabot>  *Exception: Maybe.fromJust: Nothing
20:20:27 <hackrilege> > hylo (fromJust.(+1)) (\a -> if a < 10 Just a else Nothing) 1
20:20:29 <lambdabot>  <hint>:1:29:
20:20:29 <lambdabot>      parse error in if statement: missing required then and else clauses
20:20:39 <init> @type (\c -> hylo (\_ -> c) (\_ -> Nothing))
20:20:40 <lambdabot> b -> a -> b
20:20:48 <hackrilege> > hylo (fromJust.(+1)) (\a -> if a( < 10) then Just a else Nothing) 1
20:20:49 <lambdabot>      Could not deduce (Ord a0) arising from a use of ‘<’
20:20:49 <lambdabot>      from the context (Num (Maybe b))
20:20:49 <lambdabot>        bound by the inferred type of it :: Num (Maybe b) => b at Top level
20:20:52 <init> @type (\c -> hylo (\_ -> c) (\_ -> Nothing)) "abc" 42
20:20:53 <roboguy_> hackrilege: the only way the infinite loop terminates is if you get back a Nothing. That Nothing is then given to fromJust
20:20:53 <lambdabot> [Char]
20:20:58 <init> > (\c -> hylo (\_ -> c) (\_ -> Nothing)) "abc" 42
20:20:59 <lambdabot>  "abc"
20:21:07 <roboguy_> hackrilege: that's why Either works better. Either terminates when it gets a Left value
20:21:16 * hackagebot yesod-static 1.5.0.1 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.0.1 (MichaelSnoyman)
20:21:28 <roboguy_> init: oh, good point, there is that too
20:21:43 <hackrilege> why is this thing spamming about yesod
20:21:49 <roboguy_> hackrilege: it's automatic
20:21:55 <roboguy_> when someone uploads to hackage
20:22:09 <hackrilege> its dumb, i hate yesod
20:22:21 <init> @type flip hylo (const mzero) . const 
20:22:22 <lambdabot>     No instance for (Functor f0) arising from a use of ‘hylo’
20:22:23 <lambdabot>     The type variable ‘f0’ is ambiguous
20:22:23 <lambdabot>     Note: there are several potential instances:
20:22:58 <Stratege> what's wrong with yesod?
20:23:10 <hackrilege> it only vends to localhost
20:23:47 <roboguy_> it only vends to localhost?
20:23:58 <hackrilege> i had the oppertunity to ask him about it, but he just said, no it works fine, and there have been people on here with that same bug, i had to advise them to port forward with nginx...
20:24:54 <hackrilege> no probably it can be made to use external websockets, but its not clearly documented how, and snoyberg refuses to acknoladge this as a bug
20:25:57 <roboguy_> hackrilege: I'm still not sure what you're talking about exactly... there's documentation on how to set it up with heroku though...
20:26:03 <hackrilege> :t (\_ -> c)
20:26:04 <lambdabot> r -> Expr
20:26:17 * hackagebot yamlkeysdiff 0.5.0 - Compares the keys from two yaml files  https://hackage.haskell.org/package/yamlkeysdiff-0.5.0 (acatton)
20:26:17 <hackrilege> omg...
20:26:18 <roboguy_> c is something special
20:26:19 * hackagebot yesod-websockets 0.2.3 - WebSockets support for Yesod  https://hackage.haskell.org/package/yesod-websockets-0.2.3 (MichaelSnoyman)
20:26:26 <roboguy_> > foldr (+) z [a, b, c]
20:26:27 <lambdabot>  a + (b + (c + z))
20:26:45 <hackrilege> roboguy_ it is not clear even how to handle simple post forms...
20:27:30 <hackrilege> :t c
20:27:31 <lambdabot> Expr
20:27:42 <hackrilege> :t afasfrrr
20:27:43 <lambdabot> Not in scope: ‘afasfrrr’
20:28:03 <hackrilege> thats what i would expect to see happen with c... these examples are not very clear...
20:28:28 <hackrilege> to give use of hylo defined in terms of something crazy...
20:28:49 <roboguy_> hackrilege: that's not the c that init was using
20:28:56 <roboguy_> that c was bound by a lambda
20:29:00 <roboguy_> (\c -> ...)
20:29:09 <hackrilege> init?
20:29:13 <hackrilege> aha, yes true
20:29:29 <hackrilege> oh init is a user
20:29:39 <Denommus`> Stratege: there are many data types with kind *
20:29:53 <hackrilege> > (\c -> hylo (\_ -> c) (\_ -> Nothing)) "abc" 42
20:29:54 <lambdabot>  Not in scope: ‘hylo’
20:29:56 <roboguy_> the a, b, c etc stuff is so that you can see the way that a data structure is constructed by a given function
20:30:03 <roboguy_> I can't remember the name of the package they come from
20:30:32 <hackrilege> @let hylo  e g =  e . fmap (hylo  e g). g 
20:30:33 <lambdabot>  Defined.
20:30:34 <hackrilege> > (\c -> hylo (\_ -> c) (\_ -> Nothing)) "abc" 42
20:30:35 <lambdabot>  "abc"
20:30:45 <Stratege> Denommus and many of them could be parametrized, could they not? Although I suppose they themselves aren't Functors then, only their parametrized version would be.
20:30:55 <Stratege> (or possibly would be, atleast)
20:32:04 <hackrilege> > (\c -> hylo (\_ -> c) (\_ -> Nothing)) "abc" 
20:32:05 <lambdabot>      No instance for (Typeable a0)
20:32:05 <lambdabot>        arising from a use of ‘show_M28037979031008092828485’
20:32:05 <lambdabot>      In the expression:
20:32:16 <hackrilege> :t  (\c -> hylo (\_ -> c) (\_ -> Nothing)) "abc" 
20:32:16 <lambdabot> a -> [Char]
20:32:41 <roboguy_> hylo is more useful with other functors, like Either
20:32:50 <Denommus`> I'm in love with my code: https://bitbucket.org/YuriAlbuquerque/dailyfeeling/src/f9a745c38f33302c548f470a4b454e2e0c525859/Frontend/Main.hs?at=master
20:33:17 <Denommus`> reflex is awesome, gosh
20:33:45 <pacak> :t hylo
20:33:46 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
20:34:17 <pacak> https://gist.github.com/pacak/378dec398895efdabb09 -- refold = hylo
20:35:55 <hackrilege> so i use it when i want to use many itterations to pack and unpack? no i dont understand, can you say in words when you would use it?
20:36:02 <roboguy_> hylo can generally be thought of as something that builds up a data structure from a value and then breaks it back down to another value
20:36:24 <pacak> Denommus`: el table, el tr... Sounds Spanish.
20:37:04 <hackrilege> ok, well this has left me faint, i hope to understand it more later. thanks for your help guys
20:38:31 <hackrilege> so we use either to contain the input and output types and then recurse... until a point where we change from left to right?
20:38:34 <subleq__> what does "abstract types are existential types" mean?
20:38:57 <roboguy_> hackrilege: other way. Left is at the end
20:39:19 <hackrilege> ok
20:39:26 <init> up to some point where fmap becomes a no-op
20:39:47 <hackrilege> but i could wrap this up so the user didnt have to use either, and i could also ask for a fase case like fold does...
20:40:18 <hackrilege> base*
20:40:50 <roboguy_> here's some code that uses Either in a similar way: http://pastebin.com/r7jdBVDM
20:41:09 <hackrilege> @let aTofa (i, j) = if j == 0 then Left i else Right (i + 1, j - 1)
20:41:10 <lambdabot>  Defined.
20:41:17 * hackagebot yamlkeysdiff 0.5.1 - Compares the keys from two yaml files  https://hackage.haskell.org/package/yamlkeysdiff-0.5.1 (acatton)
20:41:42 <hackrilege> @let fbTob = either id id :: Either Int Int -> Int
20:41:44 <lambdabot>  Defined.
20:42:10 <hackrilege> hylo fbTob aTofa (5, 5)
20:42:24 <hackrilege> > hylo fbTob aTofa (5, 5)
20:42:25 <lambdabot>  10
20:43:13 <hackrilege> :t either
20:43:14 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:43:43 <hackrilege> :y aTofa
20:43:53 <hackrilege> :t aTofa
20:43:54 <lambdabot> (Eq t1, Num t, Num t1) => (t, t1) -> Either t (t, t1)
20:44:22 <roboguy_> you can really imagine that it said (Int, Int) -> Either Int (Int, Int)
20:44:39 <roboguy_> the one it gave is just the most general version of the type
20:44:59 <hackrilege> i get that, its ok
20:45:13 <hackrilege> i like the 1's they make me feel warm inside
20:46:16 <hackrilege> s we need to use either rather than Maybe because we need to contain the output
20:46:18 * hackagebot pandoc-crossref 0.1.2.4 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.2.4 (lierdakil)
20:47:08 <roboguy_> hackrilege: yeah. The only case where fmap ignores the function you give it for Maybe is Nothing, which has no info. For Either, on the other hand, it ignores the function if it is given a Left
20:47:16 <roboguy_> > fmap (*10) (Left 3)
20:47:17 <lambdabot>  Left 3
20:47:48 <roboguy_> the recursion inside hylo is terminated when fmap ignores the function
20:47:59 <roboguy_> that is given to it
20:49:28 <Gurkenglas> (Huh, that's a pretty good explanation.)
20:49:45 <arkeet> @free f :: (a -> b) -> Either e a -> Either e b
20:49:45 <lambdabot> h . p = q . g => $map_Either k h . f p = f q . $map_Either k g
20:52:35 <hackrilege> nice, so why does fmap ignore the function?
20:53:15 <hackrilege> it treats either in a particular way? seems odd..
20:53:23 <roboguy_> it has to. For Either, fmap's type is (a -> b) -> Either x a -> Either x b
20:53:28 <roboguy_> no, it treats it the way it treats everything
20:53:40 <roboguy_> note that you cannot apply f to something of type x
20:53:59 <roboguy_> consider:
20:54:10 <roboguy_> > fmap (*10) (Left "abcdef")
20:54:11 <lambdabot>  Left "abcdef"
20:54:23 <roboguy_> however, this won't type check at all:
20:54:28 <roboguy_> > fmap (*10) (Right "abcdef")
20:54:29 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘*’
20:54:29 <lambdabot>      In the first argument of ‘fmap’, namely ‘(* 10)’
20:54:29 <lambdabot>      In the expression: fmap (* 10) (Right "abcdef")
20:56:18 * hackagebot reflex-gloss 0.1.0.1 - An reflex interface for gloss.  https://hackage.haskell.org/package/reflex-gloss-0.1.0.1 (jeffreyrosenbluth)
20:58:46 <hackrilege> :t fmap
20:58:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:59:18 <hackrilege> :t fmap _ (Left 0)
20:59:19 <lambdabot>     Found hole ‘_’ with type: a0 -> b
20:59:19 <lambdabot>     Where: ‘a0’ is an ambiguous type variable
20:59:19 <lambdabot>            ‘b’ is a rigid type variable bound by
20:59:32 <hackrilege> :t fmap _ (Right 0)
20:59:33 <lambdabot>     Found hole ‘_’ with type: Integer -> b
20:59:33 <lambdabot>     Where: ‘b’ is a rigid type variable bound by
20:59:33 <lambdabot>                the inferred type of it :: Either a b at Top level
21:01:19 * hackagebot warp-tls 3.1.0 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.1.0 (KazuYamamoto)
21:01:21 * hackagebot shelly 1.6.3.1 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.3.1 (GregWeber)
21:06:19 * hackagebot shelly-extra 0.3.0.1 - shelly features that require extra dependencies  https://hackage.haskell.org/package/shelly-extra-0.3.0.1 (GregWeber)
21:08:07 <Pamelloes> Is there a good way to map across a list with the current index? The first idea I have is zipWith (func) [1,2..] list, but this seems a little clunky.
21:08:47 <aupiff__> Pamelloes: that doesn't seem clunky to me
21:09:24 <Pamelloes> aupiff__: Perhaps clunky was the wrong word. It's definitely a good solution, it just seems like something a function would already exist for.
21:09:42 <Pamelloes> I was wondering if there was a function in Data.List or something that does this that I'm not aware of.
21:09:53 <Gurkenglas> (And it finally works without a hitch. http://lpaste.net/137146 )
21:10:04 <aupiff__> not as far I know
21:10:11 <Pamelloes> Alright :)
21:10:14 <Denommus`> Pamelloes: there isn't a function for that from the idea that lists are non-indexed
21:10:22 <Jeanne-Kamikaze> you can fold the original list with a counter/index and generate a new one
21:10:31 <Pamelloes> Lists aren't indexed?
21:10:34 <Pamelloes> What about !
21:10:40 <Pamelloes> Wait, !!.
21:10:54 <Jeanne-Kamikaze> it just traverses the list
21:11:11 <Pamelloes> Hm... I guess I knew that.
21:11:21 <Denommus`> Pamelloes: but you could just define mapi f l = map f $ zip [1, 2..] l
21:11:54 <Pamelloes> Denommus`: Not worth defining a new function for one use when I can just use the expanded version :)
21:12:01 <roboguy_> Pamelloes: I mean, lens has something...
21:12:06 <roboguy_> > imap (,) "hello"
21:12:08 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
21:12:27 <roboguy_> but, unless you're using lens for something else too, that would be a big thing to pull in just for that
21:12:33 <Pamelloes> haha yep
21:12:41 <nitrix> As far as I know, it's pretty common to define "functions for one use" in Haskall.
21:12:58 <Denommus`> Pamelloes: there's a mapi for Vector, IIRC
21:13:04 <nitrix> You might want to look into vectors and the !? operation if you want O(1) complexity, although, generally, lists are perfectly fine for most tasks.
21:14:17 <nitrix> Oh, I'm afraid I'm out of context.
21:14:33 <shirt> what's considered currently the best library for doing unit testing (with IO) ?
21:14:34 <Pamelloes> It's ok :)
21:14:37 <nitrix> Sign that it's bed time!
21:15:27 <Denommus`> shirt: I like hspec
21:15:40 <nitrix> shirt: QuickCheck, HUnit are hspec are all popular choices.
21:16:10 <Denommus`> hspec is like a RSpec, only that it's actually good and statically typed
21:16:10 <fishburne> Why does not this return a Left value  as index 3 empty in the IOArray : try $ readArray a 3 :: IO (Either SomeException Int) . This prints "Right *** Exception: MArray: undefined array element"
21:17:00 <shirt> Denommus`, nitrix: thanks. so i choose either hspec or HUnit, but not both?
21:18:40 <Denommus`> shirt: I don't think there is a reason for choosing both, unless sometimes you want to make classic asserts and some other times you want to use `shouldBe`
21:19:41 <nitrix> shirt: I like hspec because it's super expressive. Look at the examples, you'll see what I mean: http://hspec.github.io/
21:20:17 <Denommus`> I love how hspec looks, but I never actually needed to write Haskell unit tests
21:20:42 <Denommus`> until today the type system covered my butt. But at least I'll have an option if that's not the case
21:21:28 <nitrix> What I generally do is write as much as I can, and as bugs are opened and fixed, I create a test to prevent regression.
21:22:19 <nitrix> It's my lazy approach to unit testing :P
21:22:27 <nitrix> Don't write a test until it's needed, lol.
21:22:46 <nitrix> Amortized cost.
21:23:23 <hackrilege> thats bad practice...
21:23:34 <nitrix> I'm half serious.
21:23:46 <hackrilege> what if you forget what your library you wrote 10 years ago does? thats when you will find unit tests usefull
21:24:16 <fishburne> What is the exception that is thrown when I read from a within-bounds but empty index of an IOArray??
21:24:38 <c_wraith> fishburne: I don't think there is one.
21:25:08 <c_wraith> fishburne: I think it returns a bottom value.  This is not the same as throwing an exception.
21:25:53 <Denommus`> hackrilege: I have never used unit tests for that, to be honest
21:26:05 <Denommus`> hackrilege: on Haskell world, I find it much more useful to check type signatures
21:26:06 <hackrilege> thats what they are for...
21:26:20 * hackagebot chatter 0.5.2.0 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.5.2.0 (RoganCreswick)
21:26:34 <Denommus`> hackrilege: unit tests are used to avoid regression bugs. Using them for documentation is a bonus
21:26:45 <hackrilege> kk
21:27:14 <Denommus`> hackagebot: I have never seen anyone using the unit tests on their library to introduce it for someone that wants to learn the library
21:27:22 <fishburne> c_wraith: Oh. but GHCI prints " Exception: MArray: undefined array element:"
21:28:05 <c_wraith> fishburne: I'm investigating, but I'm pretty sure it doesn't throw that error until you try to print the resulting value.
21:28:33 <athan> hackrilege: property based testing > unit tests
21:28:45 <hackrilege> no
21:29:03 <hackrilege> never omit unit tests
21:29:15 <pharaun> but who unit tests the unit tests? :)
21:29:51 <c_wraith> fishburne: http://lpaste.net/137154
21:29:59 <athan> hackrilege: u~u I can not teach this boy, he has no patience
21:30:08 <c_wraith> fishburne: just reading the element doesn't throw an exception.
21:30:29 <jle`> unit tests are useful, but the typical things that people use unit tests in other languages are covered by property tests in haskell.  there's still some voids that unit tests fill, but the things that typically come to mind from other languages might not apply
21:30:42 <hackrilege> sorry, i was doing something that made me angry when you posted to me, ill log off now. had some good times today though was good.. bi
21:30:45 <c_wraith> fishburne: The exception doesn't show up until you try to evaluate the value you got back.
21:30:55 <athan> hackrilege: May the source be with you
21:30:57 <pharaun> i usually like to use unit tests with a "giant" list of input that i know broke the parser/code before
21:31:09 <c_wraith> fishburne: there are certain things you can do with a value that doesn't evaluate it - like stick it in a different index of the array, for instance.
21:31:16 <fishburne> c_wraith: Isn't try supposed to evaluate it, and return a Left value tif ti does throw an exception?
21:31:26 <Denommus`> pharaun: yup, that's what avoids regression
21:31:29 <c_wraith> fishburne: try doesn't force evaluation at all.
21:31:32 <hackrilege> my code manages my money badly... thats the problem.. stupid rigged markets
21:31:39 <c_wraith> fishburne: you would need to use evaluate.
21:32:23 <fishburne> c_wraith: evalue? is that a function?
21:32:26 <pharaun> Denommus`: exactly, i love properties based test but its not a replacement for proper regression testing
21:32:30 <pharaun> hence unit
21:32:36 <c_wraith> fishburne: evaluate is a function in Control.Exception
21:32:54 <c_wraith> fishburne: its purpose is to take a pure value and ensure that it has been evaluated to WHNF
21:33:15 <c_wraith> fishburne: in so doing, it will trigger exceptions that might be hiding at the top level of that value.
21:33:29 <c_wraith> fishburne: though it doesn't help at all with exceptions buried more deeply in the value.
21:33:42 <c_wraith> fishburne: in those cases, you need stuff from the deepseq package.
21:34:00 <jle`> i think saying that haskell makes unit tests unnecessary is a bit of a disingenuous claim (like the "if it compiles it definitely works" mantra), but i think it is the case that most of the use cases that unit tests were *necessary* for in other languages become obsolete in haskell, so the main "punch"/"bite" of it is of a very very different character
21:34:05 <c_wraith> fishburne: still, for the particular use case of reading an uninitialized array element, the exception will be at the top level.
21:34:48 <lispy> jle`: types + property based testing makes unit testing for pure code largely irrelevant, but that's pretty nuanced and it's a mouthful :)
21:35:17 <jle`> i think there are niche gaps where unit tests still outshine types and property tests
21:35:37 <fishburne> c_wraith: but how do I do this. I want to check if there is a value at an index.
21:35:39 <jle`> but they're niche now, not all-pervasive
21:35:55 <c_wraith> fishburne: the best way is to not mess with exceptions at all.
21:36:07 <pharaun> jle`: agreed
21:36:09 <c_wraith> fishburne: Just make it an array of Maybe Foo instead of an array of Foo
21:36:32 <pharaun> but i'm still a fan of unit tests like for regression testing and like for when i'm developing a parser or w/e
21:36:50 <pharaun> i'm able to just dump a large corpus of various piece n' bits at it and fix things up one at a time till it all passes
21:37:05 <pharaun> i seem to do a surprising large amount of custom parsing work -_-
21:37:11 <jle`> -_-
21:37:40 <pharaun> probably mostly cuz the stuff i like to play around don't really have libraries in hackage yet
21:37:41 <fishburne> c_wraith: Yea..
21:37:49 <pharaun> been slowly contributing bits n' pieces to hackage
21:51:19 <Pamelloes> Anyone here know how to search for a string with wildcards in it in persistent?
21:57:59 <Pamelloes> Hm, looks like I need esqueleto.
22:06:16 <jle`> one of the better named haskell libraries
22:09:37 <lisbeth> hey check this recursion function out: http://pastie.org/10307333
22:09:41 <lisbeth> it's in pure bash
22:10:03 <lisbeth> oh sorry thought I was in #haskell-blash
22:11:36 <homa_rano> "Couldn't match expected type ‘Int’ with actual type ‘[c0]’" what's a c0 and how did some int literals turn into it?
22:11:37 <Axman6> "#haskell-blash" that should definitely be a thing if it's not
22:12:00 <Axman6> homa_rano: without seeing the code, we're as clueless as you, if not moreso
22:12:38 <homa_rano> iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
22:13:02 <homa_rano> specifically the zipWith expression
22:13:58 <sydneyhacker> @homa_rano works on my machine
22:13:59 <lambdabot> Unknown command, try @list
22:14:07 <sydneyhacker> homa_rano: works on my machine
22:14:47 <sydneyhacker> are you using ghci?
22:15:08 <homa_rano> I'm going through someone else's build system and I have no idea
22:15:31 <sydneyhacker> i typed that into ghci and it started printing a list
22:15:40 <sydneyhacker> no type checking problems
22:16:46 <homa_rano> hmm, ok
22:18:12 <sydneyhacker> oh cool it creates that 'triangle of numbers' thing: 1; 1,1; 1,2,1; 1,3,3,1; etc. :-)
22:21:45 <sydneyhacker> of course the error may be caused in the next scope up. This returns a list [c0] where c0 is Num. If this is in a context where an Int is expected, there is your problem.
22:22:04 <sydneyhacker> So in other words - what is the code around this?
22:25:06 <AshyIsMe> ok so i've written a simple irc bot starting from the tutorial on the wiki: https://github.com/AshyIsMe/hircules/blob/master/app/Main.hs#L63-L96
22:25:14 <AshyIsMe> it uses 100% cpu at all times
22:25:24 <AshyIsMe> why is it busy waiting?
22:25:45 <johnw> AshyIsMe: I'd recommend putting in some print statements
22:25:48 <AshyIsMe> i would have expected the (hGetLine h) call to block and wait for the socket to return a line of text
22:25:52 <johnw> or use traceM
22:28:08 <AshyIsMe> line 70 and 71 im printing out each line that is read from the socket
22:28:19 <AshyIsMe> that is working correctly and not looping crazily
22:28:56 <AshyIsMe> oh i bet processFIFO is hard looping
22:31:57 <AshyIsMe> yeap, turns out im an idiot haha
22:36:51 <DoctorMooch> how is everyone doing?
22:37:57 <homa_rano> sydneyhacker: yeah it turns out I was missing some parens elsewhere and the wrong operator was taking it as input. Thanks for your hints :)
22:38:52 <wedens> can somebody suggest me a tutorial on how to setup cabal+quickheck?
22:39:28 <sydneyhacker> homa_rano, no problem
22:41:02 <sydneyhacker> wedens, no I managed to set it up, but it was more piecemeal taking bits from different tutorials until satisified
22:41:33 <sydneyhacker> I didn't like using doctest because I wanted the tests to be code not comments
22:41:44 <wedens> yeah. I don't want doctest
22:42:00 <sydneyhacker> i will look at my code now and tell you what I did roughly
22:42:07 <wedens> https://gist.github.com/mbbx6spp/1343429 will try this 
22:42:56 <sydneyhacker> ok looks similar to what I did
22:43:03 <sydneyhacker> Iused exitcode-stdio-1.9
22:43:06 <sydneyhacker> sorry 1.0
22:43:17 <sydneyhacker> and test-suite in the cabal file like that
22:44:07 <sydneyhacker> I used templates but you don't have to. Or at least not at first.
22:44:54 <sydneyhacker> happy to send you the code (assume GPL3 licence) but don't want to make it a public repo
22:48:30 <wedens> sydneyhacker: do I need test-framework?
22:49:00 <haskell826> hi All 
22:49:24 <haskell826> I am new to cabal and already into problems :)
22:49:25 <haskell826> http://lpaste.net/137158
22:49:48 <haskell826> Any help will really be appreciated. I tried resetting all cabal packages
22:50:14 <sydneyhacker> I dont think so I dont have a dependency on that. At least not directly
22:50:15 <haskell826> but no luck
22:50:41 <sydneyhacker> base, QuickCheck, HUnit + 'my stuff'
22:50:51 <dmj`> haskell826: you need to update your dependency on deepseq
22:51:24 <dmj`> haskell826: you have it hardcoded to deepseq==1.3.0.2
22:52:31 <sydneyhacker> I had the same troubles as you wedens, there is no 'canonical' way to set this up, and there are many competing packages, some old some new that help
22:53:35 <wedens> I wonder why there is no up to date tutorial on how to set up the simplest configuration
22:55:05 <sydneyhacker> my config is quite simple. I just reference HUnit and QuickCheck, use the templating features which discover all of your tests and give you a single function to run them all.
22:55:20 <sydneyhacker> then I have a small piece of binding code to run both the quickcheck and hunit tests
22:56:47 <sydneyhacker> tell me your bitbucker user name, and I will share the repo with you :-)
22:57:41 <sydneyhacker> and for anyone browsing the logs in the future, pester me to write a tutorial for it :-) ha ha
22:58:24 <wedens> https://github.com/batterseapower/test-framework/tree/master/example
22:59:18 <pjimmy> hi
22:59:19 <wedens> managed to set up using this as an example
22:59:47 <wedens> looks like it's not simplest configuration, but at least it workds
22:59:52 <wedens> * works
23:07:06 <orion> Hi. I just got ghci to crash in a reproducible way.
23:17:16 <wedens> what should be type of lens composed with prism?
23:18:33 <pacak> wedens: Traversal?
23:18:44 <pacak> :t _Left . _1
23:18:45 <lambdabot> (Applicative f, Field1 a b a1 b1) => (a1 -> f b1) -> Either a c -> f (Either b c)
23:19:12 <wedens> :t _1 . _Left
23:19:14 <lambdabot> (Applicative f, Field1 s t (Either a c) (Either b c)) => (a -> f b) -> s -> f t
23:20:01 <wedens> pacak: right. thanks
23:21:03 <Gurkenglas> Is there an analogue to do notation for comonads?
23:21:50 <wedens> I remember something using TH
23:22:08 <wedens> https://hackage.haskell.org/package/codo-notation
23:22:17 <Gurkenglas> Right, should have googled <.<
23:48:24 <amarp> Hi I am into cabal hell. What's the cheapest way to get out of it?
23:49:44 <amarp> http://lpaste.net/2461068594784501760
23:50:38 <Cale> amarp: project =>
23:50:38 <Cale> deepseq==1.4.0.0
23:50:58 <amarp> If I upgrade then other depedencies get problems
23:52:03 <Cale> amarp: You have base-4.8 which is tied to your GHC version.
23:52:14 <Cale> deepseq-1.4.0.0 requires base < 4.8
23:52:39 <amarp> okay so shall I downgrade my ghc?
23:52:45 <Cale> Uhhh... I wouldn't.
23:52:57 <Cale> What happens if you try to make it use a newer deepseq?
23:53:05 <Cale> Like 1.4.1.1
23:53:32 <amarp> It there are few other depedencies which expect deepseq's old version
23:53:38 <Cale> Probably the right thing to do is to just fix whatever package wants the old deepseq
23:54:05 <amarp> it's a big chain :(, 
23:54:23 <Cale> It's probably just an imprecise upper bound which can be removed
23:56:01 <pharaun> anyone up who is familiar with hexpat-pickle or alt hxt-pickle
23:56:24 <Cale> pharaun: I've used it a long time ago
23:56:26 <sydneyhacker> i have a question about mutable arrays
23:56:33 <Cale> hexpat-pickle, that is
23:56:39 <amarp> okay Cale I will try to upgrade! Thanks for hrlp
23:56:39 <pharaun> i'm having some parsing trouble with adjacent data
23:57:18 <sydneyhacker> so normally you have a mutable array in ST monad, and you can mutate it etc. fair enough. but what if you have a comutation that needs to mutate more than one array. in my case: 2 arrays and a flag.
23:57:44 <sydneyhacker> so in imperative land, the equivant of having 3 variables that you are mutating in an algorithm
23:58:00 <Cale> amarp: Note that you can cabal unpack things and fiddle with their .cabal and then cabal install (with no extra arguments) to install your modified version.
23:58:11 <sydneyhacker> do I need an ugly transformer stack of those 3 things
23:58:14 <pharaun> Cale: aha, k, well i got an xml file from gnucash that i'm trying to parse and they use adjacent nodes like - http://lpaste.net/137163
23:58:21 <Cale> sydneyhacker: no... you just create three STArrays
23:58:40 <quchen2> sydneyhacker: It's not any different in Haskell. mutate3 a b c = runST ( do { stuff a; stuff b; stuff c})
23:58:51 <pharaun> and for ex i'm having trouble getting it to parse the first <gnc:count-data> into field 1, and second <gnc:count-data> into field 2, it keeps on parsing only the first instance
23:58:58 <pharaun> same issue with using xpList
23:59:07 <ttt_fff> are the following two types equiv? "forall a -> forall b b" vs "forall a b, a -> b"
23:59:11 <amarp> Cale, well thanks for that. I will try it!
23:59:22 <pharaun> Cale: so any pointer would be great if you remembered any :)
23:59:53 <quchen2> ttt_fff: The first type doesn't make any sense.
