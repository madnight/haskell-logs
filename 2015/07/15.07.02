00:00:12 <funfunctor> SoT
00:00:45 <funfunctor> corosync <- most obfuscated name ever
00:01:44 <pingu> funfunctor: just make sure you don't underestimate the amount of real "engineering" work that went into corosync.
00:01:55 <pingu> re-implementing the whole thing is probably unrealistic.
00:02:05 <pingu> so perhaps you want to name it around the subset that you're aiming for.
00:04:58 <lisbeth> Can a lambda call it's self recursively?
00:05:18 <godel> more or less
00:05:24 <godel> look up Y-combinator
00:07:23 <funfunctor> pingu: i'm interested in the IPC bit at the moment
00:07:40 <funfunctor> pingu: got to go, be back a bit later
00:08:41 <lisbeth> Secondly is there a way to include the type when declaring functions with let in ghci?
00:09:07 <jle`> lisbeth: yeah, you can use a semicolon
00:09:18 <jle`> let x :: Int; x = read "3"
00:09:44 <jle`> lisbeth: if you are referring to a lambda in haskell, then not directly, but it can be done with the `fix` function, which can be said to exist for this purpose
00:09:49 <pingu> godel: that's rich, coming from Godel.
00:10:02 <pingu> Apologies, you probably get that too much :)
00:10:03 <jle`> > fix (\f x -> if x == 0 then 1 else f (x - 1))
00:10:04 <lambdabot>  <Integer -> Integer>
00:10:08 <jle`> > fix (\f x -> if x == 0 then 1 else f (x - 1)) 6
00:10:10 <lambdabot>  1
00:10:11 <godel> I do pingu :P
00:10:13 <pacak> > let foo = (\i -> i + 1 ::  Int -> Int) in foo 10
00:10:14 <lambdabot>      No instance for (Num (Int -> Int))
00:10:14 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
00:10:14 <lambdabot>        arising from a use of ‘+’
00:10:18 <jle`> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) 6
00:10:20 <lambdabot>  720
00:10:22 <jle`> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) 5
00:10:23 <lambdabot>  120
00:10:38 <jle`> lisbeth: in there, we use "f", the first parameter, as "the lambda itself"
00:10:47 <pingu> fun fact: fix cannot be used to fix your errors.
00:10:48 <jle`> so when we say f (x - 1), it's like "recalling he lambda with (x - 1)
00:10:49 <pingu> it makes them worse.
00:10:54 <pingu> > fix error
00:10:56 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
00:12:54 <godel> i live fix type
00:12:58 <godel> > :t fix
00:13:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:13:07 <godel> aww
00:13:08 <unb3k44n7> How do I register a nickname
00:13:18 <jle`> :t fix
00:13:19 <lambdabot> (a -> a) -> a
00:13:22 <pingu> unb3k44n7: /msg nickserv help
00:14:27 <unb3k44n7> Ok. I typed it. What's supposed to happen now
00:15:18 <bob_twinkles> try /query nickserv help
00:15:26 <pingu> unb3k44n7: you should have opened a window or something talking to nickserv, where it says helpful things to you
00:15:28 <bob_twinkles> should open a new PM buffer with the nickserv help
00:17:39 <unb3k44n7> It did. But no one is responding.
00:19:25 <unb3k44n7> Yeah. It's not doing anything.
00:19:32 <unb3k44n7> I even typed in the register command.
00:20:02 <pingu> unb3k44n7: it's a bot, there's no humans involved
00:20:13 <pingu> unb3k44n7: I've got to go, maybe try an IRC tutorial/google?
00:23:37 <unb3k44n7> .....Yeah Idc. Too tired to figure it out right now...
00:29:22 <unb3k44n7> Oh it was actually not difficult. Got it..
00:29:32 <srenatus> using aeson, my constructors are not what I'd like to write in JSON -- i.e. I have data Athing = Alow | Ahigh; data Bthing = Blow | Bhigh;  and I'd like to just have "A": "low", "B": "high" in JSON.  the DeriveGeneric way gives me "A": "Alow" etc
00:30:45 <unb3k44n7> I like having the word Blow in your code. Keep it.  
00:34:40 <srenatus> oh wait. it's actually not that hard. nvm.
00:35:00 <srenatus> unb3k44n7: heh. actually this example was ad-hoc
00:37:59 <unb3k44n7> :)
00:38:46 <srenatus> unb3k44n7: I first didn't understand that your comment was refering to me at all ;)
00:39:54 <unb3k44n7> Hahaha....
00:44:41 <ttt_fff> https://news.ycombinator.com/item?id=9815464 <-- damn, when can I do this with haskell?
00:44:46 <ttt_fff> I want a ghc cross-compiler for android and ios
00:47:08 <ttt_fff> I WANT I WANT
00:50:29 <joehillen> ttt_fff: https://github.com/ghc-ios/ghc-ios-scripts
00:51:06 <ttt_fff> joehillen: shit; I can't believe someone did that
00:51:09 <joehillen> ttt_fff: https://github.com/sseefried/docker-build-ghc-android
00:51:27 <ttt_fff> I like docker more than build scripts
00:51:31 <ttt_fff> higher chance of working out of the box
00:52:05 <joehillen> obviously the user experience needs to be improved there, but it is possible. I'm hopeful cross compilation will get easier soon because of stack
00:56:12 <VoltzLive> Maybe I'm not understanding it correctly... is an Either IO possible?..
00:56:47 <joehillen> VoltzLive: maybe, but it probably doesn't mean what you think it means
00:58:20 <joehillen> VoltzLive: you probably want EitherT https://hackage.haskell.org/package/either-4.3.3.2/docs/Control-Monad-Trans-Either.html
01:09:36 <ttt_fff> Either IO is totally possible
01:09:54 <ttt_fff> Either (IO Int) Bool is something that either returns (IO Int) or it returns a (Bool)
01:10:23 <VoltzLive> I don't think I really understand how to use Either.
01:10:34 <jle`> VoltzLive: do you know how to use Maybe?
01:10:44 <VoltzLive> Yeah
01:11:40 <jle`> a value of `Maybe a` is either Nothing, or something of type `b` with the Just constructor
01:12:03 <jle`> a value of `Either e a` is either something of type `e` with the Left constructor, or something of type `a` with the Right constructor
01:12:09 <jle`> data Maybe a = Nothing | Just a
01:12:15 <jle`> data Either e a = Left e | Right a
01:12:26 <jle`> you can "use" it by pattern matching on it
01:12:56 <jle`> > (\e -> case e of Left s -> s; Right n -> show n) (Right 10)
01:12:57 <lambdabot>  "10"
01:13:06 <jle`> > (\e -> case e of Left s -> s; Right n -> show n) (Left "hello")
01:13:07 <lambdabot>  "hello"
01:13:43 <ttt_fff> > "world"
01:13:45 <lambdabot>  "world"
01:13:51 <ttt_fff> > 1+1
01:13:53 <lambdabot>  2
01:14:28 <ttt_fff> > let is _ = False in is "blah smart"
01:14:29 <lambdabot>  False
01:15:13 <VoltzLive> hmm
01:15:38 <hamid> I've seen too many "hmm"s in #haskell community :))
01:15:56 <ttt_fff> hmm
01:18:06 <VoltzLive> Either a b -> b?
01:18:16 <VoltzLive> fromRight perhapse?
01:18:26 <VoltzLive> :D?
01:19:01 <maerwald> @hoogle Either a b -> b
01:19:02 <lambdabot> Data.Either rights :: [Either a b] -> [b]
01:19:02 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
01:19:02 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:19:17 <Cale> VoltzLive: Yeah, fromRight is a thing, but usually you want to avoid using fromRight or fromLeft unless you're *really* sure it's not going to be the other one.
01:19:38 <HUgeneral> It's life or death really
01:19:46 <Cale> VoltzLive: and if you're testing whether you have a Left or Right just beforehand, you should just pattern match with case
01:20:17 <VoltzLive> I'm really not sure if I should be doing it like I am, returning an Either
01:20:45 <jle`> VoltzLive: what would fromRight (Left 4) be?
01:21:01 <VoltzLive> An error?
01:21:05 <VoltzLive> right?
01:21:13 <HUgeneral> error
01:21:15 <jle`> yeah, it's not really defined.  so it's a bad idea
01:21:23 <maerwald> depends on the use case
01:21:24 <jle`> we don't like using functions that aren't defined for all inputs in haskell
01:21:36 <jle`> or, we avoid it when we can :)
01:21:38 <maerwald> if you can prove that there will be no error in the program context, then it's fine
01:21:53 <maerwald> but that increases chances that you will mess up during refactoring
01:22:04 <jle`> yeah, it's usually something we would do with a heavy heart
01:22:21 <jle`> the problem is exactly that -- *you* have to prove it yourself, by hand.  usually in haskell, our compiler proves our programs for us
01:22:41 <jle`> so you're giving up the compiler being able to prove that it works for your own possibly flawed informal proof that it works :)
01:23:00 <maerwald> jle`: you can use liquidhaskell for such proofs, but it's very early stage
01:23:28 <jle`> liquidHaskell can't give you a total fromRight, either
01:23:49 <jle`> and in liquid haskell, it's still the compiler proving/checking your proof for you
01:24:28 <maerwald> I thought they use an SMT solver binary
01:25:02 <jle`> liquid haskell uses refinement types, i believe
01:25:04 <maerwald> and I am pretty sure you can set type constraints in a way that lets you check safety before doing fromRight
01:25:25 <jle`> yes, that's what i mean...fromRight wouldn't be Either e a -> a
01:25:32 <jle`> it'd have a different type that constrains it to work
01:25:56 <maerwald> I meant a liquid type
01:26:34 <jle`> but the point is the same...liquid haskell lets you write invariants in your types that the compiler can check for you
01:27:04 <jle`> so when you *can* give a proof, you can :)
01:27:06 <jle`> *you should
01:27:17 <maerwald> jle`: invariants in liquidhaskell are not checked by the compiler, but by an SMT solver
01:27:34 <jle`> at compile-time, right?
01:27:42 <maerwald> no
01:27:46 <maerwald> you run liquidhaskell on the code
01:27:56 <maerwald> i then probably invokes ghc on its own
01:29:11 <jle`> yeah, so it's checked at compile-time
01:29:48 <maerwald> I don't know what that means in this context
01:29:48 <jle`> the process of turning your code into an executable
01:29:54 <merijn> maerwald: He means "not at runtime"
01:30:05 <merijn> maerwald: i.e. static, offline checking
01:30:13 <merijn> As opposed to dynamic online checking
01:30:22 <maerwald> merijn: you do "liquidhaskell foo.hs" so I don't know how you would even seperate runtime and compile-time here
01:30:24 <jle`> the step between your code and having an executable
01:30:32 <jle`> maerwald: the runtime is when you run foo
01:30:35 <jle`> ./foo
01:30:39 <jle`> -> your program executes
01:30:46 <maerwald> jle`: that's now how you invoke liquidhaskell, yes
01:31:22 <jle`> i mean, if Foo.hs has a "main = ...", then you run liquidhaskell Foo.hs, you'd get an executable ./Foo
01:31:35 <jle`> and so runtime is when you execute your Foo executable
01:31:49 <maerwald> jle`: no, if you run liquidhaskell Foo.hs you get a report
01:32:01 <maerwald> not an executable
01:32:17 <jle`> ah
01:32:18 <merijn> jle`: liquidhaskell doesn't actually compile anything, it's just a static analysis tool
01:32:22 <jle`> i see
01:32:30 <maerwald> obviously it does invoke ghc
01:32:37 <maerwald> but I don't know which steps it actually uses it for
01:33:32 <maerwald> it doesn't analyze the code you wrote though, but what ghc makes out of it
01:33:47 <jle`> ah i see :)
01:33:59 <tmtwd_> > foldr : [] [1 ,2,3]
01:34:00 <lambdabot>      Couldn't match expected type ‘[Integer]
01:34:01 <lambdabot>                                    -> [(a -> b -> b) -> b -> t a -> b]’
01:34:01 <lambdabot>                  with actual type ‘[t0]’
01:34:21 <maerwald> jle`: that's why you can easily break liquidhaskell by super-nested lists, because ghc expands them in a difficult way
01:34:37 <jle`> tmtwd_: you might mean foldr (:) [] [1,2,3]
01:34:42 <Hafydd> > foldr : foldr : foldr : []
01:34:43 <lambdabot>      No instance for (Typeable t0)
01:34:43 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
01:34:43 <lambdabot>        arising from a use of ‘show_M628982541007470597212788’
01:34:54 <jle`> tmtwd_: the way you wrote it is parsed as foldr : ([] [1,2,3])
01:34:59 <tmtwd_> thanks
01:35:05 <jle`> as if you're consing foldr to the list "[] [1,2,3]"
01:37:20 <tmtwd_> >[1..3]
01:39:43 <VoltzLive> It makes me sad that (\x -> x x)(\x -> x x) doesn't work
01:43:37 <VoltzLive> >(\x -> x x)(\x -> x x)
01:44:07 <tomjaguarpaw> ttt_fff: " ther anyway to make the haskell/db (postgresql) intersection a bit more 'typesafe' than opaleye?" I hope not!  What sort of extra type safety where you hoping for?
01:44:27 <ttt_fff> tomjaguarpaw: why not? when is typesafe ever bad?
01:44:32 <maerwald> VoltzLive: I think that's a problem of inferring the type, not a general restriction
01:44:32 <ttt_fff> I would like row types
01:44:40 <frerich> VoltzLive: I think even '\x -> x x' cannot work. Due to applying 'x' as a function, the compiler infers that it's of type 'a -> b'. Since the argument type 'a' is the function itself, it must be of type '(a -> b) -> b'.  And so on, and so on.
01:44:57 <VoltzLive> yeah
01:45:19 <maerwald> :t id
01:45:20 <lambdabot> a -> a
01:45:21 <maerwald> :t id id
01:45:22 <lambdabot> a -> a
01:45:34 <tomjaguarpaw> ttt_fff: It's not bad, but if it's possible to add more type safety I want to add it to Opaleye.
01:45:59 <tomjaguarpaw> But I'm not sure what you mean.
01:46:10 <ttt_fff> tomjaguarpaw: declare your conflicts of interest! are you an contributor to opaleye? if so, thanks! it's the best library I've used so far
01:46:17 <tomjaguarpaw> I'm the author of Opaleye.
01:46:21 <tomjaguarpaw> Thanks.
01:46:34 <VoltzLive> I remember reading a blog that said Haskell was at the forefront of type theory but has fallen behind in the past 10 or so years, What has Haskell missed?..
01:46:46 <tdammers> dependent types
01:46:50 <merijn> VoltzLive: It depends on what you consider the forefront
01:47:08 <ttt_fff> tomjaguarpaw: I like the library alot. I think my complaint is less with Opaleye, and more with embeding any SQL like query langauge within haskell; it seems that without Row Types, it's hard to embed anything SQL like in Hzskell; because "projections/joins" create new datatypes
01:47:14 <merijn> You have to consider that haskell was not invented to experiment with type theory
01:47:22 <merijn> Haskell was invented to experiment with laziness
01:47:37 <maerwald> merijn: ghc was invented to experiment with type theory though :P
01:48:00 <merijn> Dependent types were known at that time, but no one knew how to implement them. More people know how to implement DT now, but we're still not very good at making it very high performance/easy to use
01:48:15 <VoltzLive> Dependent types?
01:48:16 <merijn> Not really, GHC metatheory is rather conservative
01:48:22 <ttt_fff> DT sounds great in theory. Programming in Coq sucks in practice.
01:48:32 <tdammers> ttt_fff: I would say that a similar complaint goes for OOP languages as well - the relational model doesn't map to objects any better than it does to a Haskell-style type system
01:48:34 <tomjaguarpaw> ttt_fff: I see what you mean, but I wouldn't describe that as "type safety".  There is stuff like Vinyl which should work fine for Opaleye.
01:48:42 <merijn> ttt_fff: Because Coq is a theorem prover and not a practical programming language, you may wanna look at Idris
01:49:03 <merijn> VoltzLive: Before explaining dependent types, there are some other notions to point out
01:49:39 <ttt_fff> tomjaguarpaw: I can not think of anything off the top of my head (last used Opaleye/ SQL about a month agao), when I remember it, I'll drop you a line, since you clearly care about th eproject and actively want ot improve it
01:49:48 <merijn> VoltzLive: We have "types depending on terms", that is the "simple"/obvious case of "'c' :: Char", the type of a term 't' depends on what that term is.
01:50:20 <tomjaguarpaw> ttt_fff: Yes please do!  My email address is linked in the Opaleye README on the Github page.  Please let me know whatever thoughts you have.
01:50:44 <merijn> VoltzLive: Then we have "types depending on types", (which I'm trying to think of an easy example off, but can't right now)
01:51:37 <VoltzLive> so... a type of a type?
01:51:46 <merijn> VoltzLive: The term dependent types is used to refer to the case where the type of an expression can depend on its value. The usual example is a vector
01:52:26 <tomjaguarpaw> s/on its value/on a value/
01:52:30 <merijn> VoltzLive: "Vector (n :: Nat) (a :: *)", which is the type of vectors of a fixed length, i.e. "Vector 3 Int"
01:52:32 <dhil> parameterized types are "types that depend on types"
01:52:42 <merijn> dhil: Yes, but I couldn't think of a simple example
01:53:31 <dhil> merijin, a personal favourite Tree : * -> *, or in some modern OO language with generics Set<String> :-)
01:53:37 <merijn> VoltzLive: Now suppose I want to write a function "makeVector :: Nat -> a -> Vector ? a" we see that the return type of makeVector depends on the first argument value, but we can't write that in Haskell!
01:54:18 <merijn> VoltzLive: In a dependently typed language you'd have "makeVector :: (n : Nat) -> a -> Vector n a", i.e. a function that takes "a Natural number 'n'" and returns a Vector that has that natural number in the type
01:58:31 <VoltzLive> I kind of understand.. Maybe I'm just not smart enough or something =O
01:58:47 <VoltzLive> one day I'll be smart enough, Get me a turing award or something...
01:59:36 <maerwald> VoltzLive: probably :D
02:01:17 <merijn> VoltzLive: To be honest, the easiest way I've found to learn this stuff is just play with haskell, try to stretch the type system as far as it goes and once you hit the limits of "can't do this in haskell" and look up "well, in what language COULD I do this?" then this stuff makes more sense
02:01:41 <merijn> It's hard to see the use of dependent types until you hit a usecase for them and go "oh...THAT's why!"
02:02:01 <ttt_fff> the most basic thing to do in DT langauge is you can define ++ which does "Vector n -> Vector m -> Vector (n+m)"
02:02:14 <MarcelineVQ> merijn: that's an interesting way to say it
02:02:15 <VoltzLive> I don't really understand how you do something like that... so yeah =/
02:02:27 <MarcelineVQ> Because that's a thing I run into a lot with functional thinking
02:02:53 <MarcelineVQ> 'why even do it this way' until you see a good example
02:03:27 <VoltzLive> like when I thought I understood Monads I implemented what I thought replicated a monad.. but now I'm not really sure if it comes anywhere close to actually being a monad..
02:04:35 <merijn> VoltzLive: The biggest issue I see with Monads is people over thinking things. They're an abstraction that has a few laws, that's it.
02:05:02 <merijn> What makes it useful? The fact that these laws help use reason/prove things about our code
02:10:38 <maerwald> merijn: not just overthinking, but maybe even abusing for effect complexity
02:11:36 <VoltzLive> I understand the laws I just don't (think) I understand the implementation and how they can allow the replication of things such as state and side effects.
02:12:15 <merijn> VoltzLive: For State I recommend trying to actually implement State
02:12:29 <merijn> Also, note that State isn't really Stateful, it's just a way to fake it
02:12:50 <merijn> VoltzLive: See this homework I keep telling people to try: https://gist.github.com/merijn/098106abd45c940dab09
02:18:01 <VoltzLive> hah Yeah I don't understand it
02:20:54 <maerwald> VoltzLive: I think a common example is that the C expression "x = 3" has two levels: a state that says "x is now 3" and the value "3" itself (e.g. you can do "if (x = 3)"). haskell just models that explicitly
02:21:59 <merijn> VoltzLive: Forget understanding, just look at the puzzle pieces you have and blindly/dumbly try and put them together
02:22:21 <merijn> VoltzLive: It's fairly hard to get a State implementation that typechecks and is incorrect, so just try and make something typecheck
02:22:49 <merijn> VoltzLive: I think I spend like 4 hours fumbling with it when I started, and then when I had something that compiled I had this "oh, wait...what? That's it?" insight
02:24:15 <maerwald> s/haskell/the state monad/
02:24:41 <merijn> The entire point of the exercise is that you can't be told the understanding, it'll be just some opaque fact you can't work with
02:24:59 <merijn> You need to experience the understanding by doing it without understanding it :)
02:27:12 <rhaps0dy> heyo
02:27:25 <rhaps0dy> what do I do when dealing with C functions that might fail?
02:27:35 <rhaps0dy> get return value, check for success, and if it fails crash?
02:27:53 <Hafydd> Return Maybe, surely.
02:28:02 <Hafydd> Or something with more information.
02:28:09 <merijn> rhaps0dy: How does the C function fail? Error code return?
02:28:09 <rhaps0dy> Can't return Maybe out of main.
02:28:16 <rhaps0dy> it's, SDL_Init
02:28:18 <merijn> rhaps0dy: Sure you can
02:28:18 <rhaps0dy> yeah, error code return
02:28:21 <rhaps0dy> or null pointer
02:28:30 <merijn> main can have any IO type
02:28:42 <rhaps0dy> if any part of this init sequence fails, there is no point in continuing
02:28:44 <merijn> "main :: IO (Maybe Int)" is totally legal. It doesn't do anything, mind
02:28:45 <rhaps0dy> merijn: oh, really?
02:28:45 <VoltzLive> I'm fairly certain the fact that I don't even know how to use the state monad seriously hinders my ability to do the homework...
02:28:54 <Hafydd> I was assuming you'd check the Maybe value by pattern-matching at some point.
02:28:57 <merijn> rhaps0dy: I think you just want exitFailure
02:29:01 <merijn> VoltzLive: Nope
02:29:04 <rhaps0dy> Hafydd: yeah, that makes sense out of context.
02:29:15 <merijn> VoltzLive: I would say doing the work is the best way to learn how to use it
02:29:24 <merijn> VoltzLive: But feel free to ask if any part confuses you
02:29:42 <rhaps0dy> merijn: ah nice
02:29:45 <rhaps0dy> die might be better though.
02:29:54 <VoltzLive> Well.. Where do I begin...
02:30:39 <maerwald> VoltzLive: http://learnyouahaskell.com/for-a-few-monads-more#state
02:31:48 <tranma> has anyone done complexity testing? I'm imagining something where you run criterion on data sets of incremental sizes and munge the output to assert that time/space use is roughly as expected.
02:32:13 <robstewartuk> I'm trying to debug my ghc-mod installation. M-x ghc-debug returns "call-interactively: Symbol's value as variable is void: ghc-interactive-command". Any ideas?
02:33:30 <ttt_fff> haskell is the worst thing to happen to a programmer ever
02:33:37 <ttt_fff> it makes everything else look unsatisfying
02:33:41 <MarcelineVQ> omy
02:33:49 <AshyIsMe> can confirm
02:33:59 <rhaps0dy> tranma: what do you mean?
02:34:07 <maerwald> ttt_fff: not everything, but a lot of things
02:34:11 <rhaps0dy> Can't confirm yet, AshyIsMe, ttt_fff
02:34:26 <tranma> rhaps0dy: to test that some code uses constant space, for example
02:34:33 <rhaps0dy> Elixir and Common LISP look sexy :3
02:34:48 <rhaps0dy> tranma: whoah, never thought of testing that
02:34:56 <rhaps0dy> might want to put a huge input and measure memory used
02:35:04 <tranma> rhaps0dy: by trying input of different input sizes and assert space use didn't grow
02:35:11 <ttt_fff> Lisp used to look good
02:35:18 <ttt_fff> now I can't stand not having a compiler find my type errors
02:35:46 <rhaps0dy> uh, yeah, that kinda suchs
02:35:47 <MarcelineVQ> lips is amazing if you just can't live without ()
02:35:47 <rhaps0dy> sucks
02:35:55 <rhaps0dy> but, all those macros
02:36:03 <rhaps0dy> I kinda like Python too
02:36:14 <rhaps0dy> those __setattr__
02:36:20 <Hafydd> Lips: :()
02:36:20 <ttt_fff> ()'s fine; it's te lack of type checking ... .and having to have unit tests ... that kills it
02:36:27 <rhaps0dy> uh, __getattr__, and its ultra-dynamic ilk
02:36:33 <Hafydd> I can't live without your lips~
02:36:40 <MarcelineVQ> :>
02:36:47 <maerwald> :@
02:36:49 <rhaps0dy> you don't need unit tests in Haskell?
02:36:58 <maerwald> rhaps0dy: ofc you do, depending on your problem
02:37:09 <rhaps0dy> it makes sense that you need less of them though.
02:37:09 <tdammers> personally, I like to group programming languages in 3 categories
02:37:32 <MarcelineVQ> "pro, cool, and plebiter"
02:37:41 <tdammers> the first group covers the range between C++ and Haskell, and anything beyond Haskell
02:37:55 <tdammers> the second group contains almost all the other languages
02:38:01 <tdammers> the third group contains only PHP
02:38:09 <merijn> @quote PenguinOfDoom gentlemen
02:38:09 <lambdabot> PenguinOfDoom says: Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
02:38:10 <rhaps0dy> lol
02:38:34 <rhaps0dy> how do I know what's between C++ and Haskell tdammers ?
02:38:43 <rhaps0dy> I agree with merijn and PenguinOfDoom lol
02:38:48 <tdammers> yeah well
02:38:50 <MarcelineVQ> >everythting but c and fortran
02:38:55 <rhaps0dy> now let's go read cat-v
02:39:42 <tdammers> "compiled, performant, enough abstractive power, doesn't sacrifice any of these to provide a more gentle learning experience"
02:39:45 <merijn> Fortran is pretty solid
02:39:51 <merijn> At least Fortran has arrays...
02:40:06 <merijn> More than I can say for C...
02:40:22 <tdammers> C might be a fourth category
02:40:58 <rhaps0dy> tdammers: that fits Haskell, C++, Hafydd's lips, Fortran I guess?, 
02:41:02 <rhaps0dy> maybe Java fits too?
02:41:09 <rhaps0dy> and what about Erlang?
02:41:23 <rhaps0dy> they kinda compile bot not really (more erlang than java)
02:41:59 <rhaps0dy> Swift and Obj-C may also fit in that category :|
02:42:04 <tdammers> java, not really
02:42:06 <quicksilver> I don't think the details of the spectrum between compilation and interpretation are important
02:42:07 <maerwald> merijn: in C we only have memory :D
02:42:14 <quicksilver> it's about what is statically checked and what is not.
02:42:14 <tdammers> (because "abstractive power")
02:42:30 <rhaps0dy> tdammers: how does C++ have more abstractive power than java?
02:42:39 <merijn> rhaps0dy: Templates
02:42:48 <rhaps0dy> Java has generics though.
02:42:54 <tdammers> rhaps0dy: template metaprogramming, #define (if you really want to), reference vs. pointers, ...
02:42:59 <rhaps0dy> ain't they the same
02:43:00 <merijn> rhaps0dy: Templates are SOOOO much more powerful than generics
02:43:02 <merijn> rhaps0dy: No
02:43:05 <rhaps0dy> awch
02:43:11 <tdammers> they don't even compare, except for syntax
02:43:12 <rhaps0dy> don't know enough C++ nor Java 
02:43:26 <rhaps0dy> tdammers: references vs pointers is actually pretty bad imo
02:43:30 <MarcelineVQ> template metaprogamming is p. cool
02:43:33 <maerwald> java generics are horrible. Every time you think "this would be cool with generics" you can't do it
02:43:38 <merijn> rhaps0dy: Templates let you do essentially a mix of template metaprogramming and dependent types
02:43:39 <rhaps0dy> well, it has its uses, but you never know what you're passing
02:43:44 <tmtwd_> whats the best way to make a tree?
02:43:54 <MarcelineVQ> whatkindoftree
02:43:55 <quicksilver> C++ template are horrible. Every time you think "this would be coll with templates" you *can* do it.
02:43:57 <merijn> tmtwd_: A binary tree, a rose tree, some other tree?
02:44:00 <tmtwd_> binay
02:44:10 <merijn> quicksilver: But it takes hundreds of lines of awful syntax ;)
02:44:16 <tmtwd_> data Tree a = Empty | Node a (Tree a) (Tree a)?
02:44:20 <rhaps0dy> merijn: I don't know about all the metaprogramming then
02:44:22 <quicksilver> hundreds of lines is just the error message.
02:44:26 <rhaps0dy> lol
02:44:28 <tdammers> rhaps0dy: depends on context; it does mean that you can bend C++ either way - closer to the metal, C-style, if that's what's needed, or higher up in the abstraction chain, using RAII and references to make for safer memory management while still being in control
02:44:34 <maerwald> tmtwd_: no leafs?
02:44:47 <merijn> quicksilver: hundred line errors? I wish, lol
02:44:47 <rhaps0dy> tdammers: ah, it does have nice flexibility
02:44:53 <merijn> quicksilver: Admire this beauty: https://github.com/merijn/GPU-benchmarks/blob/master/CUDA.hpp#L96-L114
02:44:58 <tmtwd_> maerwald, there can be leafs since a Tree can be an emptytree
02:45:02 <tmtwd_> I think
02:45:04 <MarcelineVQ> isn't a node with empty trees a leaf?
02:45:09 <rhaps0dy> dis gun b good merijn 
02:45:09 <maerwald> tmtwd_: I know, but I wouldn't call that leafs
02:45:32 <tmtwd_> maerwald, what is a leaf?
02:45:33 <tdammers> there's this thing I read in this C++ book once, where it says that you need to realize that C++ isn't just one language, it is a collection of related sub-languages, and it's important to know which of them you are using at any given point
02:45:43 <rhaps0dy> noice
02:45:51 <maerwald> tmtwd_: I think the way you do it you get more pattern matching complexity
02:45:52 <rhaps0dy> initKernel, valid for all kernels.
02:46:07 <tmtwd_> maerwald, how would you do it?
02:46:08 <tdammers> there's the "C on crack" sublanguage, there's the "template metaprogramming" sublanguage, there's the "OOP a bit like Java" sublanguage, and there's the "STL" sublanguage
02:46:08 <maerwald> tmtwd_: data Tree a = Empty | Leaf a | Node a (Tree a) (Tree a)
02:46:15 <tmtwd_> oh I see
02:46:17 <tmtwd_> cool
02:46:25 <tdammers> and they're different enough to be approached as separate languages
02:46:34 <rhaps0dy> that's the problem with C++'s hugeness.
02:46:46 <rhaps0dy> it ends up being abstracted as several languages lol
02:46:52 <merijn> rhaps0dy: I want to statically check the arguments of my kernels, unwrap the arrays I have and do all the setup in a reusable way. It works pretty well, but I'm glad I don't have to explain it to anyone else :p
02:47:15 <rhaps0dy> >I'm glad I don't have to explain it
02:47:18 <rhaps0dy> but it's pretty clear
02:47:25 <rhaps0dy> few clutter and all that
02:47:28 <rhaps0dy> and it's only a few liens
02:47:40 <rhaps0dy> and you just explained it to me :P
02:47:53 <merijn> rhaps0dy: Then you're already a pretty good C++ programmer :p Most people don't do more than "template<typename T> foo(T t)" :p
02:48:31 <rhaps0dy> well, I didn't know about the typename... Args thing at all
02:48:58 <rhaps0dy> but if I take your word that it works, and I have good reason to believe so, it's pretty self-explanatory
02:49:36 <tdammers> it doesn't "end up being abstracted", it has always been that
02:49:59 <tdammers> you can mix-and-match the sublanguages, but most of the time, you're better off sticking with one or two of them
02:52:28 <rhaps0dy> you are right.
03:13:57 * hackagebot Earley 0.8.3 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.8.3 (OlleFredriksson)
03:23:57 * hackagebot nationstates 0.1.0.1 - NationStates API client  http://hackage.haskell.org/package/nationstates-0.1.0.1 (ChrisWong)
03:28:34 <zipper> Hey I have an issue with Line 11 here: http://lpaste.net/3655098485511815168#line11
03:29:05 <zipper> It refuses to bind. The error is: bind: unsupported operation (Cannot assign requested address)
03:29:12 <zipper> `bind: unsupported operation (Cannot assign requested address)`
03:32:04 <merijn> zipper: Did you recently run this script before getting this error?
03:32:22 <zipper> merijn: Uh yes
03:32:31 <zipper> I'm not sure what you mean.
03:32:39 <zipper> It's part of a bigger program.
03:32:58 <zipper> How can I tell it to kill the socket if it is bound?
03:33:07 <merijn> zipper: Your OS (assuming something *nix) does not immediately free up a port for reuse after a program using it terminates
03:33:22 <zipper> merijn: No I had just booted it up.
03:33:54 <zipper> I just changed it to iNADDR_ANY and it successfully bound
03:34:20 <zipper> merijn: Is there a way to free a socket if it's bound?
03:34:42 <merijn> Kill the process and wait a few seconds
03:47:46 <zipper> merijn: yaaaay
03:48:45 <zipper> What does setting a socket's option to reuse an address True or False mean?
03:48:48 <zipper> or do?
03:50:55 <merijn> ReuseAddr tells the OS to *not* reserve the socket after your program exits
03:51:12 <merijn> i.e. once your program terminates a new program can immediately use it
03:51:28 <merijn> Not setting ReuseAddr will leave it reserved for several seconds after your program ends
03:51:45 <merijn> Generally (especially when testing!) you'll want to enable ReuseAddr
03:52:55 <flux> the cases when to not use it are really rare I think
03:53:24 <flux> CUPS used to not use that flag for a long time. it was beyond annoying to adjust config, restart, change the port, restart again, etc, and finally switch to the same port ;)
04:13:37 <Jafet> :t isSubsequenceOf
04:13:38 <lambdabot> Eq a => [a] -> [a] -> Bool
04:34:04 <zipper> merijn: Thanks a ton for your help.
04:38:19 <warbo> Hi, I've written a GHC Core -> Core plugin which prints out the names of top-level bindings, and was wondering if there's a way to get their (Haskell) types too?
04:39:45 <Jafet> #ghc might know more.
04:40:09 <warbo> Jafet: thanks, I'll try there too
04:41:23 <merijn> warbo: Also try the ghc-devs mailing list (larger audience than #ghc)
04:52:23 <sohum> @hoogle (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
04:52:23 <lambdabot> No results found
04:52:29 <sohum> hm.
04:53:18 <kgadek> does cabal has the ability to say "export all modules from src" ?
04:53:25 <mpickering> sohum: maybe liftA2?
04:54:27 <sohum> :t liftA2
04:54:28 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:54:45 <mpickering> > ((+) <$> (+1) <*> (+2)) 1
04:54:47 <lambdabot>  5
04:55:10 <sohum> right, yes! thank you :)
04:56:56 <chpatrick> is codensity a proper monad? I remember reading somewhere that it wasn't
04:57:23 <mpickering> in what sense?
04:57:23 <chpatrick> and that's why they have the (forall m. MonadFree f m => m a) stuff in improve
04:57:27 <chpatrick> in the laws lense
04:57:31 <chpatrick> *sense
04:58:18 <mniip> chpatrick, check the monad laws I guess
04:59:03 <chpatrick> is there any reason to prefer ContT over it?
04:59:13 <chpatrick> would be nice to hide the "result" parameter
05:01:08 <mniip> chpatrick, ContT operates on the (->) arrow
05:01:17 <mniip> Codensity operates on the Kleisli arrow
05:02:00 <mniip> despite one being unifiable with another, they're not very related
05:04:36 <chpatrick> hmm
05:05:04 <chpatrick> for practical purposes can't I just pretend it's ContT with a universal result?
05:05:06 <nabokovian> hey guys, so i think i understand the functor as a sort of overloaded function used to facilitate the composition of functions (meaning for example, if the return type of one function differs from the input type of another) - like a composition function ( `.` or `$` but more adaptable). hopefully that is to some extent an accurate understanding. but then what is a monad in relation to a functor? 
05:06:17 <chpatrick> I'm not sure that's right for functors
05:06:22 <mniip> nabokovian, you mean arrows?
05:06:36 <mniip> what you just explained fits perfectly for arrows but not functors
05:06:45 <dfeuer_> Moaning, Haskellians.
05:10:14 <kgadek> bumping my question. Does cabal has the ability to say "export all modules from src" ? Why doesn't it automatically assume that everything in - say - `src` shall be by default in exposed-modules / other-modules? `cabal init` can do that…
05:10:56 <kgadek> generally, requiring the programmer to do the manual work of `find src -type f -name '*.hs'` is… a terrible approach :<
05:12:41 <Maxdaman1us> Being able to trace things' visibility is nice imo
05:13:15 <Maxdaman1us> without requiring some deep understanding of the system you're trying to work with.
05:14:33 <kgadek> Maxdaman1us: but that should be the option, not the requirement. Especially when you're in development of multi-project stuff, deadline's tomorrow and basically all you need is simple 'be implicit now, be explicit just before opensourcing'
05:14:34 <merijn> kgadek: Simple reason: The mapping of modules to filenames is compiler specific
05:14:48 <kgadek> merijn: woooooot
05:15:16 <merijn> kgadek: The report does NOT specify how modules map to filename and cabal is a compiler agnostic tool. The fact that most people now just use GHC does not mean cabal should assume GHC's module export mechanism
05:15:46 <merijn> kgadek: For example there's at least one compiler that supports "Data.Foo.Bar.hs" instead of "Data/Foo/Bar.hs" for the module Data.Foo.Bar
05:16:17 <breadmonster> merijn: What compiler is that?
05:16:32 <kgadek> merijn: …skimming through Haskell 2010 and you're right
05:16:34 <merijn> breadmonster: I'd have to dive into the mailing list, it came up in a discussion I had
05:17:18 <merijn> Now, I consider this a flaw in the report, I believe it should define how this is done to allow for portable static analysis tools, but for now that's not the case
05:17:22 <kgadek> merijn: anyway, currently we have a preparser for cabal files that expands the `exposed-modules` part. And that is bad, I want to get rid of that. Is it possible in any other, non-intrusive way?
05:17:41 <kgadek> merijn: yes, I'd agree that's a bug in the report :<
05:17:45 <merijn> kgadek: No idea, tbh
05:17:58 <merijn> kgadek: Try asking dcoutts in #hackage if he has any ideas
05:18:04 <kgadek> thanks!
05:19:12 <kgadek> merijn: …btw, how does the `cabal init` works then? o.O"
05:19:48 <merijn> kgadek: No clue, tbh :)
05:19:57 <Maxdamantus> is Cabal written in portable Haskell?
05:20:03 <Jafet> By doing exactly what you were doing, presumably
05:20:57 * Maxdamantus wonders how a Haskell program invokes a Haskell compiler.
05:21:35 <nabokovian> whoa. i have not looked into arrows. may i ask what you think of this post by Justin Le? i thought it gave me a good intuition of functors. http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad
05:21:38 <kgadek> merijn: https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init/Heuristics.hs#L130
05:22:13 <nabokovian> this is the first time i'm actually talking about this stuff after about a year and a half on and off of trying to soak it all up
05:23:08 <merijn> Maxdamantus: cabal-install is a tool that links against Cabal, a library build into the compiler and exposing a minimal interface
05:23:16 <breadmonster> merijn: Do you know a lot about monad transformers?
05:23:17 <kgadek> merijn: as far as I can see, this code translates a/b/c.hs into a.b.c.hs and is identity on a.b.c.hs 
05:23:28 <kgadek> so both conventions are ok for cabal
05:23:29 <kgadek> interesting
05:23:37 <merijn> Maxdamantus: Every haskell compiler is supposed to implement it's own Cabal library that ships with it
05:23:38 <kgadek> but still, this really sucks
05:24:05 <merijn> Maxdamantus: Most problems of the "I wish cabal could do X" variety boil down to "that wasn't foreseen when the Cabal interface was designed"
05:24:28 <breadmonster> merijn: I'm trying to figure out how they work, there's a subtle point or two I can't seem to find anything on.
05:24:38 <merijn> breadmonster: Which is?
05:24:39 <chpatrick> nabokovian: a Functor is a type that transforms type a to f a and can transform a function a -> b to f a -> f b
05:25:19 <chpatrick> another way of thinking about it is that it's a type you can "map over"
05:25:28 <chpatrick> :t fmap
05:25:28 <breadmonster> merijn: In a monad stack if you have two monads of the same type and you lift an action, that action is carried out in which monad?
05:25:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:26:08 <merijn> "two monads of the same type" what does that mean?
05:27:26 <Maxdamantus> Hm. Didn't know that.
05:27:28 <hexagoxel> breadmonster: depends on how far you lifted..
05:28:00 <Taneb> merijn, I think he means something like StateT s (State t) a
05:28:07 <Jafet> Actually, cabal-install has no problem hard-coding haskell compilers: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/Builtin.hs
05:28:11 <Taneb> *they
05:29:27 <nabokovian> @chpatrick, understood re: functor can transform a function. i like that - concise and explanatory. so what does a monad do for us that a functor doesn't? just trying to tease out the difference (without delving into the category theory stuff - yet)
05:29:27 <lambdabot> Unknown command, try @list
05:45:02 <chpatrick> nabokovian: so a functor lets you transform f a with a pure function a -> b
05:45:21 <chpatrick> a monad lets you transform it with a function a -> f b
05:45:37 <mada> Anyone that has worked through Concrete Mathematics (or some of it): are its contents generally useful, or more so for imperative programming languages/concepts/implementations?
05:45:52 <chpatrick> so for example
05:45:58 <chpatrick> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
05:46:03 <nabokovian> ahh ok, cool. 
05:46:11 <mada> I gather it's kind of a math-toolset book; wondering if it caters the same to functional programmers.
05:46:24 <chpatrick> there's also applicative which is inbetween in power
05:46:31 <chpatrick> that lets you transform f a with f (a -> b)
05:46:35 <mniip> nabokovian, mathematically speaking, a functor is an isomorphism between two categories' elements, and their morphisms
05:47:04 <chpatrick> in this case the elements are the types in haskell and the morphisms are functions between them
05:47:05 <mniip> in haskell Functor is a typeclass that provides a function for 'lifting' a function of type a -> b into the (covariant) functor
05:47:11 <mniip> so that it is of type 'f a -> f b'
05:47:14 <nabokovian> @chpatrick, i don't follow the applicative (the sample type signature you gave, i can't grok it)
05:47:14 <lambdabot> Unknown command, try @list
05:47:33 <chpatrick> so the main function for applicative is
05:47:35 <chpatrick> :t (<*>)
05:47:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:47:52 <nabokovian> @mniip, it is illuminating that you say a functor is a typeclass, since it has to be implemented in different ways for different types
05:47:52 <lambdabot> Unknown command, try @list
05:48:11 <chpatrick> so practically speaking you can kind of tie stuff in f together but you can't create a new f based on another one
05:48:22 <mniip> nabokovian, the haskell Functor is indeed named after the functor, but it is a different sort of entity
05:48:23 <chpatrick> with a monad you can
05:49:11 <mniip> nabokovian, also about grokking the types
05:49:17 <mniip> try imagining that f is []
05:49:25 <mniip> fmap :: (a -> b) -> [a] -> [b]
05:49:38 <mniip> pure :: a -> [a], <*> :: [a -> b] -> [a] -> [b]
05:49:49 <mniip> return :: a -> [a]; >>= :: [a] -> (a -> [b]) -> [b]
05:50:02 <mniip> and then try generalizing
05:50:39 <nabokovian> then 'return' and 'pure' those are transforming functions that are defined in the applicative typeclass?
05:50:56 <chpatrick> they're not "transforming" as such
05:51:10 <chpatrick> pure is from Applicative and return is from Monad but they're actually the same
05:51:13 <nabokovian> sort of adapting, (pardon the imprecise language)
05:51:32 <mniip> pure and return are 'wrapping'
05:51:32 <chpatrick> they do what it says on the tin, a -> f a
05:51:41 <mniip> <*> fmap and >>= are 'transforming'
05:51:53 <chpatrick> so if f is Applicative then there has to be a way to make an f a from an a
05:52:16 <nabokovian> got you
05:53:45 <mniip> [15:45:50] <nabokovian> @mniip, it is illuminating that you say a functor is a typeclass, since it has to be implemented in different ways for different types
05:53:53 <mniip> that sounds like you didn't get it
05:54:05 * hackagebot ClustalParser 1.1.1 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.1.1 (FlorianEggenhofer)
05:54:06 <mniip> Functor is *a* typeclass
05:54:14 <chpatrick> makes sense to me
05:54:18 <mniip> which is related to mathematical functors, but not exactly the same
05:54:32 <chpatrick> functor does have to be implemented different ways for different types though
05:54:48 <mniip> not for different contained types
05:54:50 <nabokovian> i meant the instances of the typeclass
05:54:54 <mniip> for different functor types
05:55:04 <mniip> nabokovian, instances of the typeclass are functors
05:55:31 <mniip> like [], Maybe, (Either e)
05:55:36 <chpatrick> he didn't say contained type though
05:55:46 <mniip> that sounded like that's what he had in mind
05:56:06 <nabokovian> different instances for different "type wrappers" (not contained types), right?
05:56:08 <dfeuer_> Mniip, the type constructor and fmap together form the functor: the type constructor takes objects to objects and the fmap implementation takes arrows to arrows.
05:56:16 <mniip> dfeuer_, yes
05:56:55 <chpatrick> nabokovian: yep
05:57:05 <chpatrick> in f a, "f" is the Functor
05:57:22 <mniip> uh
05:57:34 <mniip> yeah
05:57:50 <dramforever> to me the instance is the functor
05:58:37 <mniip> hmm
05:58:51 <mniip> do applicative functor even exist in mathematics?
05:59:15 <mniip> f (a -> b) sounds like we're talking about hom-sets
05:59:30 <mniip> and in fact, endofunctors
06:00:26 <nabokovian> the instance is the implementation of the functor, right? the *class* is like the high-level explanation of the transformation, and the instance is 'this is how we're going to make it happen'. pardon the layman point of view.
06:00:48 <nabokovian> transformation meaning "mapping"
06:00:51 <dramforever> an instance is a functor
06:00:53 <chpatrick> mniip: http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors
06:01:00 <dramforever> I think
06:01:11 <chpatrick> dramforever: what do you mean by that though?
06:01:20 <nabokovian> i need to finish my 'how to prove it' book someday.
06:01:21 <chpatrick> we say "Maybe is a Functor"
06:01:28 <dramforever> chpatrick: a functor is a tuple (F, fmap)
06:01:32 <mniip> nabokovian, the Functor typeclass is an "explanation" of what functors are
06:01:42 <dramforever> which corresponds to instances of the Functor class
06:01:48 <mniip> Functor instances are pieces of code explaining why (how) specific things are functors
06:01:55 <nabokovian> cool, got you.
06:02:51 <mniip> the terminology here is wonky
06:03:22 <mniip> because on one hand, a functor is a Functor, which means that some functor is an instance of the Functor typeclass
06:03:28 <nabokovian> as with math i always wondered if we could do a full re-working of vocabulary for beginners to slide in easier :) of course htat would cause trouble down the line..
06:03:36 <mniip> otoh, Functor is not a functor, because it is a typeclass
06:03:41 <nabokovian> right
06:03:54 <dramforever> the language features problem
06:04:06 <mniip> let's talk in haskell
06:04:08 <dramforever> 1. new language, simple, attracts people
06:04:26 <dramforever> 2. many people got fluent in that language
06:04:34 <dramforever> 3. those people add new features
06:04:42 <dramforever> 4. new features confuse newbies
06:06:39 <hodapp> 5. people from step #2 spend the rest of their days bitching about how lazy newbies are
06:06:55 <dramforever> lol exactlyl
06:06:58 <dramforever> *exactly
06:08:01 <hodapp> 6. let's make a new language that's simple!
06:08:37 <nabokovian> sounds about right
06:09:02 <mniip> 7. never actually succeed at step 6 because see steps 1-7
06:09:35 <Tuplanolla> Relating to this: is there a language that was designed with the whole ecosystem and tooling in mind?
06:09:36 <hodapp> 8. step 7 refers to itself recursively so I can write whatever I want to here. POOOOOOOP
06:10:34 <hodapp> Tuplanolla: I seem to recall that Peaker is working on something of the sort.
06:10:41 <Tuplanolla> I've been playing around with the idea of a language that's not necessarily good, but would be easy to build tools for.
06:10:50 <hodapp> Tuplanolla: environments like Racket perhaps are made for this
06:11:30 <merijn> Tuplanolla: This is Peaker's project as mentioned above: https://peaker.github.io/lamdu/
06:11:42 <Tuplanolla> Curious.
06:11:58 <hodapp> I need to read about / use Lamdu. Also, Racket...
06:13:28 <Tuplanolla> I have a similar project, but I haven't had the time or clear mind to work with it for a while.
06:14:03 <Jafet> Instead of making new languages, make new tools!
06:14:19 <Tuplanolla> That would require actually getting things done.
06:14:24 <nabokovian> until the tools become turing complete
06:14:48 <hodapp> Jafet: If you look around at "real world" languages, those environments are full of tools trying to prop up languages that suck.
06:15:13 <Tuplanolla> It's difficult for me to decide between dynamic types and dependent types. Anything in between feels like a filthy compromise.
06:16:29 <nabokovian> what's the name of the language that resembles haskell that has dependent types?
06:16:34 <Tuplanolla> Idrus.
06:16:36 <Jafet> Tooling doesn't have very much to do with language design, anyway, since most languages are pretty similar.
06:16:37 <Tuplanolla> Uh, Idris.
06:16:38 <tdammers> Tuplanolla: re languages with ecosystem and tooling in mind: Go and Rust both have a lot of thought spent on tooling; Clojure was designed to blend in with the JVM ecosystem - not sure if that's what you mean though
06:17:31 <tdammers> Jafet: can be silly little details, such as how Python doesn't play nice with a bunch of tools because of whitespace and `pass`
06:17:35 <hodapp> Jafet: Tooling has everything to do with language design, in that languages that have big glaring design flaws will regularly have tools designed to cover (badly, frequently) for those flaws.
06:18:08 <tdammers> and yes, also tools that compensate for lack of expressiveness or work around flawed semantics
06:18:17 <Tuplanolla> My primary motivation stems from the new theory of visibly-pushdown languages. They have some properties development environments could really benefit from.
06:18:31 <hodapp> Tuplanolla: visibly-pushdown?
06:18:38 <hodapp> have any examples/papers you can point me to?
06:18:46 <Tuplanolla> It's a classification between regular and context-free.
06:19:01 <Tuplanolla> I don't have any at hand right here, but I can go look.
06:20:41 <Tuplanolla> Check out Visibly Pushdown Languages by Alur and Madhusudan for starters.
06:20:53 <saulzar__> Seems like a lot of times I'd really like a "oneple" with a simple syntax in Haskell, to avoid the overlapping between generic a and alternatives (e.g. Maybe a, or, a -> b). Also perhaps for avoiding the instance SomeClass a => instance SomeClass b problem, by wrapping the value.
06:20:55 <Tuplanolla> It should be freely available.
06:22:56 <warbo> is there a GHCi option to fully-qualify the names it prints? eg. turning "Mod1.Foo :: Bar" into "Mod1.Foo :: Mod1.Bar"?
06:23:06 <mniip> saulzar, Indentity is the 1-tuple
06:23:44 <Jafet> Tuplanolla: can this formalism deal with lambda calculus, though?
06:23:52 <hodapp> I don't have much background of language classifications like that... I need to learn about that one of these days
06:24:07 <Tuplanolla> Yes, Jafet.
06:24:51 <saulzar__> mniip, Hm - I suppose it is. But it doesn't have a very minimal syntax or clear enough name to use that way
06:25:41 <warbo> nevermind, I can use ":m" to unload all modules and go back to Prelude
06:26:01 <sbrg> saulzar__: write your own? data Oneple a = Oneple a or some such
06:26:44 <Jafet> Tuplanolla: do you know how?
06:27:19 <Tuplanolla> I actually don't, but I don't see why it couldn't.
06:27:43 <Jafet> Automata theory and denotational semantics don't often go out together.
06:28:14 <saulzar__> sbrg, Yeah - well there's a "OneTuple" in hackage. But still it's kinda clunky for a user to keep pattern matching OneTuple.
06:28:15 <Tuplanolla> Lambda expressions are context-free, no?
06:29:06 <Jafet> Not really, because lambda-abstractions create variable contexts.
06:29:07 <sbrg> saulzar__: a short name would make it less tedious. data T1 a = T1 a
06:29:38 <sbrg> pattern-matching on T1 is almost like matching on (_, _)
06:31:00 <saulzar__> sbrg, Yeah, maybe. I'm writing an html library (yes, another one) and trying to think of ways to (optionally) pass a return value and the element, or just the return value. But I think there's no real good way to do it
06:33:01 <Tuplanolla> It depends on what you want to do with the grammar then, Jafet. You can recognize expressions without having to worry about contexts if you don't care about free variables.
06:33:03 <saulzar__> sbrg, I can imagine one would get pretty frustrated with a library where you're doing (T1 r) <- div_ [] $ ... many times repeated for example. At the moment I just define div_ and div', but it irks me that I can't be quite as clever as lucid 
06:34:10 <sbrg> saulzar__: why write another one, out of curiosity?
06:35:17 <Tuplanolla> Vpl is a subset of cf, so the same restrictions apply.
06:35:36 <Tuplanolla> cf/cfl
06:36:00 <saulzar__> sbrg, It's for reflex, the big difference is that the Html is not just Text, lucid is (essentially)   a -> Text, where in the reflex case we return Events/Behaviors too (data flowing both ways)
06:36:36 <Jafet> The grammar of lambda calculus is not really important. People care more about the semantics, and automata (or at least non-branching ones) tends to be a poor approach for that.
06:37:37 <sbrg> saulzar__: Ah, I see.
06:38:23 <saulzar__> sbrg, Also things like typed attributes. Without the overloading lucid does we can be clever in other ways
06:40:25 <saulzar__> Maybe I can use more than one OnePle,  (Result a) <- gets you the result of the child,   (Elem e) <- gets you the element, or (a, e) gets you both...
06:40:57 <Tuplanolla> Grammar is important to syntax highlighters and pretty printers that tend to be quite terrible for most languages.
06:41:15 <Tuplanolla> I don't disagree though.
06:42:39 <saulzar__> Then it will be ambiguous if you don't pattern match the return code, because it's not ()  :/
06:42:44 <sbrg> saulzar__: It sounds like you basically want Either but just something not as verbose, right? Maybe you can do what you just described using pattern synonyms to get rid of the verbosity
06:42:50 <Jafet> Tuplanolla: ok, but we don't have any shortage of theoretical solutions to that problem, only practical ones.
06:43:27 <Jafet> saulzar: how about fst and snd?
06:43:28 <sbrg> anyway, gotta run. sun's out. getting shooed outside
06:43:39 <saulzar__> sbrg, I don't want Elem or Result to have the same type - I'd overload the function using a class
06:44:06 <saulzar__> sbrg, Possibly I'm just trying to be too clever, however..
06:46:05 <saulzar__> Using the return type to decide what to return to the user, so I can avoid doing binding a bunch of stuff to create the Elem when the user doesn't request it 
06:48:23 <Jafet> Maybe it is possible to construct those in pure code.
06:48:38 <saulzar__> e.g. at the moment I have div' :: Attributes -> m a -> m (Elem, a)     and div_ :: Attributes -> m a -> m a,   what I was thinking of is to overload it and have just (Returns r) => div_ :: Attributes -> m a -> m r
06:51:41 <saulzar__> Probably stick with what I have, I don't see it's possible to do anything if the user doesn't pattern match the return value
07:10:10 <hseg> Hi. The documentation for Apply indicates that IntMap has an Apply instance, but no Applicative instance. I fail to see why the instance arising from Compose ((->) Int) Maybe won't do the job.
07:13:16 <chpatrick> hseg: you mean an IntMap that has the same value for every key?
07:13:23 <chpatrick> as in any possible key
07:14:04 <hseg> I mean that pure would insert the value everywhere and <*> would apply the function pointwise, if there is an entry.
07:14:17 <Clint> does bertram felgenhauer irc?
07:14:41 <chpatrick> hseg: how do you make an intmap that has every int as keys?
07:15:30 <chpatrick> I don't think the data structure supports that
07:15:39 <thomie> Clint: yes, his nick is int-e
07:16:19 <hseg> fromList . zip [minBound..maxBound]
07:16:31 <hseg> At least, that's what it looks like.
07:16:54 <chpatrick> ok but that would take a huge amount of time and memory to actually produce
07:17:29 <Clint> thomie: oh, thanks
07:18:19 <hseg> As far as I can tell, that's an irrelevant concern.
07:18:34 <chpatrick> hmm I disagree
07:18:49 <chpatrick> with lists it's fine to have infinite ones since you can still do useful stuff lazily
07:19:07 <chpatrick> but intmaps aren't lazy in the keys so if you ever actually used this function you'd just run out of memory
07:19:14 <hseg> My question was whether IntMap supports such an instance. Not whether that instance would be practical.
07:19:47 <chpatrick> at that rate why not make it pure x = pure x
07:19:58 <chpatrick> also typechecks and just as useful :)
07:20:23 <hseg> Typechecks, but doesn't satisfy Applicative laws.
07:20:27 <chpatrick> doesn't it?
07:21:47 <hseg> No. pure id is supposed to be a left identity for <*>, which is strict in both arguments.
07:22:08 <hseg> pure = pure would make pure=undefined, hence not a left identity.
07:22:17 <chpatrick> pure isn't = undefined though
07:22:33 <chpatrick> I mean if it's bottom then pure x <*> foo is also bottom
07:22:48 <chpatrick> ok I guess that is false
07:22:55 <nshepperd> pretty much none of the strict structures in haskell satisfy the functor/applicative/monad laws if you expect them to hold in the presence of _|_
07:23:33 <rui> Hello! What's a good package to play audio from samples? I just want something simple where you set a sample rate, load some samples and it plays
07:23:43 <chpatrick> but still I don't think it's a good idea to add practically wrong code just because it's logically correct
07:23:45 <nshepperd> fmap (f . g) ≠ fmap f . fmap g, for any container strict in the values
07:24:07 <chpatrick> why not just use MaybeApply (IntMap k) from semigroupoids?
07:24:25 <chpatrick> then you have an efficient and correct applicative instance
07:25:42 <nshepperd> and yes, the reason, presumably, that no-one added an Applicative instance for IntMap is because it would be horribly misleading to provide a pure that turned out to be indistinguishable from (const _|_)
07:26:47 <dfeuer_> Edwardk, now you actually have the pull request I claimed you had yesterday.
07:27:24 <hseg> Again, my concern isn't efficiency. If that's the only thing preventing the Applicative instance, then I'd expect the documentation to reflect that: "There is no known efficient way to make IntMap into an Applicative.". Instead, it says "An IntMap is not Applicative, but it is an instance of Apply".
07:27:43 <hseg> Making me think that there is a theoretical reason why IntMap is not Applicative.
07:27:45 <chpatrick> that's fair enough
07:27:56 <chpatrick> you just made it sound like the instance should be added
07:28:37 <hseg> Nah. As long as someone writes in a comment somewhere that the instance is possible but a bad idea, I'd be happy.
07:29:01 <hseg> Problem is, the language suggests the instance is impossible, and I have no idea why.
07:29:17 <chpatrick> it's practically impossible I guess
07:29:23 <chpatrick> theoretically not
07:29:39 <hseg> Since when has that stopped us?
07:31:03 <nshepperd> well, if you pretend that Int is a stand-in for actual infinite domain integers, then there really is no 'pure', because you can't actually cover all the integers
07:31:05 <L8D> Is normal Map Applicative?
07:31:14 <hseg> Docs say no.
07:31:23 <L8D> So why should IntMap be?
07:31:26 <chpatrick> then there's also the problem of the Ord constraint
07:31:28 <nshepperd> which isn't really unreasonable, seeing as Int is already variable-domain
07:31:29 <chpatrick> for Data.Map
07:31:48 <nshepperd> variable-size
07:32:09 <hseg> L8D: Same reasoning applies there. Why isn't it?
07:32:22 <chpatrick> for Data.Map it's actually impossible
07:32:43 <chpatrick> since everything needs Ord and Applicative can't have one
07:32:47 <L8D> It doesn't make sense, a { 3 = (++ "asdf"), 4 = reverse } { 1 = "foo", 2 = "bar" } = ???
07:32:56 <L8D> ap*
07:33:11 <chpatrick> L8D: empty?
07:33:11 <hseg> = {}
07:33:27 <L8D> So it should only apply intersecting keys?
07:33:31 <chpatrick> yes
07:33:33 <hseg> yep.
07:33:38 <hseg> just like ZipList
07:33:38 <L8D> It just seems useless, and how would pure work?
07:33:46 <chpatrick> L8D: exactly
07:34:01 <chpatrick> hmm could you make an instance based on unionWith?
07:34:03 <hseg> pure x = {i = x forall i::Key}
07:34:06 <chpatrick> then the identity is empty
07:34:20 <nshepperd> well, you could add an instance '(Ord k, Enum k, Bounded k) => Applicative (Map k)'
07:34:28 <nshepperd> but that would be stupid for much the same reasons
07:34:35 <L8D> Performing apply based on intersection would break the rules of Applicative unless somehow pure matches all keys
07:34:51 <hseg> L8D: Why?
07:35:02 <chpatrick> yes exactly
07:35:09 <L8D> hseg: because (pure f) <*> x wouldn't be the same as fmap f x
07:35:35 <L8D> so yeah, an Applicative instance for Map doesn't make sense
07:35:39 <hseg> Why not?
07:35:44 <L8D> having a function that has a similar type signature is okay
07:35:54 <L8D> but otherwise you'll have to break a few rules and it gets weird
07:35:59 <chpatrick> L8D: we've just gone through this
07:36:06 <hseg> Why would (pure f) <*> x /= fmap f x ?
07:36:11 <chpatrick> you could make an instance but it would be useless
07:36:16 <L8D> I guess with Ord k, Enum k and Bounded k you can make pure match all keys
07:36:30 <chpatrick> how about an instance based on union?
07:37:07 <hseg> Basically, I guess the problem is that I see maps as being isomorphic to Compose ((->) k) Maybe, while they are quite a bit stricter than that, breaking the isomorphism?
07:38:56 <L8D> If you need an Applicative/Monad instance for a Map, then you should probably use an associative list
07:39:53 <nshepperd> if you really really wanted to do this, you would maybe add 'class (Enum a, Bounded a) => Small a'
07:40:09 <nshepperd> and only give instances for types whose entire domain can really be enumerated in practice
07:40:23 <chpatrick> or use MaybeApply
07:40:25 <nshepperd> then 'instance (Ord k, Small k) => Applicative (Map k)'
07:41:21 <nshepperd> or that
07:43:56 <zinfandel> Hi. I hope there are some hackage maintainers online. I have this common error, my account isn't in the group of package uploaders.
07:44:00 <bdesham_> I have a function that works with lists and vectors and I'd like to generalize it to any kind of indexed, one-dimensional container
07:44:07 <hseg> Yeah. As I said above, I thought Map ~ ((->) k) Maybe, but it's in fact stricter. Thus, you need k to be small enough for the instance not to bottom out on you in some cases.
07:44:08 <bdesham_> Is there a typeclass that encapsulates that?
07:44:10 <bdesham_> http://lpaste.net/8487043603837747200
07:44:43 <bdesham_> (or rather, I have one function that works with lists and an almost-identical function that works with vectors...)
07:44:56 <zinfandel> The id is 'zudov' I'd be glad if someone could fix my group
07:45:22 <hseg> So basically, (Int)Maps are too strict in their keys to be made applicatives?
07:48:30 <chpatrick> bdesham: mono-traversable maybe?
07:48:35 <chpatrick> @hackage mono-traversable
07:48:35 <lambdabot> http://hackage.haskell.org/package/mono-traversable
07:50:41 <chpatrick> http://hackage.haskell.org/package/mono-traversable-0.9.2.1/docs/Data-Containers.html#v:ozip
07:50:45 <chpatrick> etc
07:50:52 <chpatrick> although looks like Vector isn't MonoZip
07:52:59 <bdesham_> that looks promising!
07:53:23 <bdesham_> maybe I'm looking at the wrong thing but it looks like only Text and ByteString are MonoZip
07:53:30 <bdesham_> which seems wrong
07:54:04 <chpatrick> snoyberg probably just hasn't added them yet :)
08:12:07 <tmtwd> I find code can be easier to read than haskell I think
08:12:14 <tmtwd> in haskell
08:14:11 * hackagebot smoothie 0.3.2 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.3.2 (DimitriSabadie)
08:15:09 <Eduard_Munteanu> How do you do transactions in persistent?
08:19:06 <int-e> acfoltzer: 
08:19:12 * hackagebot pandoc 1.15.0.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.15.0.2 (JohnMacFarlane)
08:19:14 * hackagebot ivar-simple 0.3.1 - Write once concurrency primitives.  http://hackage.haskell.org/package/ivar-simple-0.3.1 (BertramFelgenhauer)
08:23:52 <breadmonster> How does DeriveFunctor work?
08:34:39 <tmtwd> In scheme, this (define x (cons (list 1 2) (list 3 4))) basically creates a tree. If I have data Tree a = Empty | Leaf a | Node a (Tree a) (Tree a), how would I do the same thing in haskell?
08:36:29 <mauke{> that's a weird tree type
08:36:44 <tmtwd> uh, someway gave it to me on this channel?
08:36:46 <mauke{> Leaf x ~ Node x Empty Empty
08:36:55 <tmtwd> What would you do instead?
08:36:59 <mauke{> remove Leaf a
08:37:38 <tmtwd> hehe thats what I had originall
08:37:38 <Eduard_Munteanu> tmtwd, what does the Scheme tree look like?
08:37:49 <mauke{> "terrible"
08:38:24 <Jafet> '(1 2 3 4) is also a tree
08:38:25 <mauke{> Cons (Cons 1 (Cons 2 Nil)) (Cons 3 (Cons 4 Nil))
08:38:52 <mauke{> a.k.a. (list (list 1 2) 3 4)
08:38:54 <Eduard_Munteanu> [[1, 2], 3, 4]
08:39:00 <Eduard_Munteanu> Ah.
08:39:04 <tmtwd> mauke, exactly
08:39:12 * hackagebot http-client 0.4.15 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.15 (MichaelSnoyman)
08:39:15 * hackagebot http-conduit 2.1.5.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.5.1 (MichaelSnoyman)
08:39:16 <tmtwd> does that fit with my haskell type
08:39:16 <tmtwd> ?
08:39:17 * hackagebot classy-prelude 0.12.1.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.12.1.1 (MichaelSnoyman)
08:39:24 <Eduard_Munteanu> It's not clear to me how that fits a binary tree.
08:39:27 <mauke{> I don't think so
08:39:29 <tmtwd> you
08:39:32 <tmtwd> are right
08:39:38 <tmtwd> I guess it doesn't
08:39:46 <tmtwd> what kind of haskell tree would fit that?
08:40:23 <mauke{> data Value = Nil | Num Int | Cons Value Value  -- trivial embedding
08:41:21 <monochrom> scheme's "cons" is a binary tree node, not a linear list node.
08:41:24 <chpatrick> that only has values at the leaves though
08:41:36 <monochrom> however, people go on to use "cons" for only linear lists.
08:42:00 <monochrom> and worse, people then go on to use these linear lists to encode trees.
08:42:07 <tmtwd> mauke, then a = Value [[1,2], 3,4]
08:42:18 <monochrom> it is like watching an XYZ problem
08:42:29 <tmtwd> ?
08:42:47 <mauke{> tmtwd: x = Cons (Cons (Num 1) (Cons (Num 2) Nil)) (Cons (Num 3) (Cons (Num 4) Nil))
08:42:55 <mauke{> which is fairly disgusting
08:43:07 <tmtwd> yeah, that is ...
08:45:36 <cscheid> hey folks, i suspect i stumbled across an InstanceSigs bugs on GHC 7.10.1, but it's on a relatively ugly source file. the error message i'm getting from GHC is here, http://pastebin.com/s9cKcRU8. i'm wondering if this is worth talking to someone about
08:46:37 <tmtwd> mauke, oh, that's effectively a cons cell :) ?
08:48:50 <geekosaur> cscheid, I think I'd ask in #ghc
08:49:20 <cscheid> geekosaur, thanks for the pointer! sorry for the noise.
08:51:38 <hseg> Any ideas on how to write this better: http://lpaste.net/135729 ?
08:53:15 <mauke{> compilable code is overrated
08:53:21 <nolraiU> >.<
08:53:29 <nolraiU> Wait..that is actually true.
08:53:42 <rtpg> is there a good style guide for writing clean haskell code?
08:53:49 <rtpg> or like, a good source repo?
08:54:09 <nolraiU> GHC is pretty nice.
08:54:24 <nolraiU> I mean the actually code for it.
08:55:12 <chpatrick> nolraiU: hmmmmmmm :)
08:55:23 <chpatrick> until recently looking at the wrong parts of the AST threw an error
08:55:32 <nolraiU> So why don't any of the dependant languages based on Haskell have haskell style typeclass.
08:55:32 <chpatrick> that's not too idiomatic
08:55:51 <nolraiU> No that is pretty terible.
08:55:53 <monochrom> tibbe has a style guide. I do not know how "clean" it is. what is "clean"?
08:56:17 <monochrom> https://github.com/tibbe/haskell-style-guide
08:56:28 <nolraiU> Why do I always forget my "?"?
08:56:38 <nolraiU> I do it in spoken japanese too.
08:56:58 <monochrom> because your working memory holds only 7 items
08:56:58 <dolio> nolraiU: Lots of people are under the impression that making type classes 'more powerful' in the ways that usually get done is better.
08:58:00 <oconnore> is there a filepath library in haskell that isn't entirely useless?
08:58:42 <maerwald> monochrom: I like that guide
08:58:47 <oconnore> I guess I should go make coffee
08:58:49 <zinfandel> rtpg: This talk is nice https://youtu.be/zV70nrsMEZg , assuming that you need a "how to write idiomatic code" guide rather than "how to indent and format your code"
08:59:16 <maerwald> especially when he says "avoid over-using point-free style"
08:59:20 <breadmonster> I'm reading Okasaki, and in a lot of places he uses strict not lazy evaluation.
08:59:30 <hseg> Any ideas on how to write this better: http://lpaste.net/135729 ?
08:59:31 <breadmonster> Is there any way to incorporate this in Haskell?
08:59:39 <nolraiU> oconnore: is that new one any good?
08:59:46 <breadmonster> iirc seq only introduces a data dependency, not actual strictness.
09:00:16 * nolraiU doesn't know what the differnce between strictness and data dependancy is.
09:01:10 <hseg> breadmonster: I don't see how to insert actual strictness into haskell without changing its evaluation model so drastically, it will be unrecognizable.
09:01:12 <breadmonster> nolraiU: Umm, so `\x -> let y = f x in g y` here y has a dependency on x. 
09:01:32 <Haskellfant> oconnore: at the end of the blogpost where he introduces his own new path library, chrisdone also gives a comparison to other libraries, which might be worth looking at http://chrisdone.com/posts/path-package
09:01:51 <y> breadmonster: use ! on your data structures
09:01:52 <hseg> breadmonster: Plus, I'm not sure that non-dependency strictness is useful.
09:01:56 <breadmonster> nolraiU: So x is guaranteed to be evaluated before y, but x may not be evaluated at all, and so y may not be evaluated at all.
09:02:06 <mauke{> seq is strict in both arguments
09:02:15 <breadmonster> y: is that some seq-y stuff or actual strictness?
09:02:20 <hseg> But I'm a noob, so... *shrugs*
09:02:26 <mauke{> how is seq not actually strict?
09:02:28 <Jafet> breadmonster: what's a dependency? (Consider f = const z)
09:02:52 <Haskellfant> what would actual strictness even be when the rest of your program is lazy?
09:02:57 <y> breadmonster: I am now asking what's the problem with seq, if you want fine-grained "seq", you have `pseq` and even `par` if you want to
09:03:13 <y> breadmonster: also, "actual strictness"? what's that? down to NF? 
09:03:27 <breadmonster> y: yeah down to fully normal form.
09:03:33 <mniip> for NF you have deepSeq and force
09:03:44 <y> ! goes to WHNF, if you want NF you can use deepseq
09:03:53 <breadmonster> mniip: deepSeq is guaranteed to evaluate to normal form?
09:04:08 <mniip> "guaranteed"?
09:04:15 <breadmonster> Oh yeah, point taken.
09:04:17 <mniip> it's a typeclass, so it depends on the instances
09:04:38 <breadmonster> mniip: What's force? I haven't heard of that.
09:04:46 <y> look at the deepseq package
09:04:47 <mniip> force x = x `deepSeq` x
09:05:20 <mniip> when you try to obtain WHNF of 'force x' you end up evaluating the rest of the normal form too
09:05:25 <mniip> of 'x
09:05:26 <mniip> '
09:06:15 <breadmonster> Fantastic.
09:06:19 <mauke{> poorMan'sDeepSeq = seq . length . show
09:06:36 <shiona> :D
09:06:43 <breadmonster> I wish Haskell had a built in strictness mode.
09:06:46 <breadmonster> mauke: lol
09:07:10 <maerwald> breadmonster: afair there will be a pragma for that
09:07:31 <breadmonster> maerwald: There is?
09:07:49 <maerwald> so you can make a whole module strict
09:08:57 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
09:09:55 <maerwald> but then again, you might just use idris instead
09:16:43 <Jello_Raptor> hmm, so I'm trying to make a special type of graph
09:17:54 <hseg> Any ideas on how to write this better: http://lpaste.net/135729 ?
09:18:02 <Jello_Raptor> basically, each node has named edges (for now "Left","Right","Up","Down") and there's enforced relations between two nodes (i.e "a ^. left . right == id")
09:18:51 <Jello_Raptor> and I want to be able to define invertible paths in this graph
09:19:22 * hackagebot yesod-core 1.4.12 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.12 (MichaelSnoyman)
09:20:18 <Jello_Raptor> (i.e some automatic way to turn "right . up" into "down . left", keeping in mind that despite the example here, "up . right" might not be equal to "right . up")
09:21:43 <nolraiU> Are all paths invertable?
09:23:31 <Jafet> hseg: a remainder tree might be better
09:23:42 <hseg> ?
09:23:55 <Jafet> Jello_Raptor: do you need to use (.)?
09:24:15 <Jello_Raptor> nolraiU: yes, though maybe not deterministically. (i.e some node could have a "child" that is actually a list of nodes, even if for the each child the "parent" is a single entity) Also I'd like to keep the "lensyness" of the specification intact. 
09:24:28 <Jello_Raptor> Jafet: not really, I'd like to if possible though. 
09:25:22 <nolraiU> Jello_Raptor: What does child mean in this context?
09:25:24 <Jafet> Maybe overload "right" using a typeclass such that one instance returns "left"
09:25:37 <nolraiU> Oh, I like that idea.
09:25:40 <Jello_Raptor> nolraiU: think a tree
09:26:08 <Jafet> Or the easy way out, Category.. should work
09:26:18 <nolraiU> And its paths in this tree that you are talkingabout? Or paths composed of nodes in the tree?
09:26:42 <Jello_Raptor> Noldorin: for the example, in the generic case it's a graph. 
09:27:49 <Jello_Raptor> Jafet: issue is I'm working at level above that. The user provides those specifications, and I'm only writing the interfaces they need to implement without knowing the exact schema. 
09:28:31 <ReinH> Jello_Raptor: sounds like you have a group?
09:28:34 <Jello_Raptor> (well, i'll be the user soon enough, but there's a whole stack of different schemas I'd like to have that could share the underlying graph structure. 
09:29:54 <Jello_Raptor> ReinH: doesn't that require that the operation is total? I suppose I forgot to mention that nodes have types, and that the exact named edges a node has is determined by its type. 
09:30:28 <ReinH> Yes, it does.
09:30:53 <ReinH> But the actions themselves form a group (with the addition of an identity action)
09:31:02 <SrPx> Is there any implementation of pure arrays which is more efficient than intmaps (using the fact arrays are bounded and intmaps are not)?
09:31:40 <ReinH> so one way of thinking of it is that Left <> Right <> Left = Left, whether or not there is an edge to the left
09:32:09 <ReinH> SrPx: depends on what you mean by "more efficient", I suppose.
09:32:27 <SrPx> faster in practice 
09:32:35 <ReinH> Depends on what sort of practice
09:32:44 <Jafet> Array is pure, and so is STArray (in a sense)
09:32:46 <SrPx> indexing a random position
09:33:19 <ReinH> Data.Vector supports O(1) indexing
09:33:40 <ReinH> Data.Array doesn't mention, but I believe it's O(1)
09:33:41 <Jello_Raptor> ReinH: ahh i see, and if they're storing each tomic component of the path, and each of those have inverses I can generate an inverse for the whole path. 
09:33:45 <ReinH> that's sort of the point of arrays and vectors
09:33:51 <SrPx> I'm talking in a theoretical point of view, vectors are not truly O(1)
09:34:05 <SrPx> yes data.array is O(1
09:34:10 <SrPx> "O(1)"
09:34:24 <ReinH> You asked if they were "faster in practice"
09:34:34 <ReinH> Now you're talking about "in a theoretical point of view"
09:34:42 <Jello_Raptor> ReinH: not to mention, I can have those instances act like a "Maybe" or "List" for failure and/or non-determinism. hmm
09:35:00 <SrPx> look, in a theoretical point of view which array implementation takes less beta reduction for random indexing? that's what I'm asking
09:35:08 <SrPx> :(
09:35:11 <ReinH> I answered the question you asked
09:35:19 * ReinH shrugs
09:35:36 <monochrom> ReinH: you answered just one question asked :)
09:35:51 <Jello_Raptor> ReinH: hmm, something like a restricted "FreeT" then 
09:35:56 * Jello_Raptor putters about
09:35:56 * monochrom is tired of moving-target questions, too
09:35:58 <Jafet> vectors can be looked up in O(1) Swatch beats
09:36:00 <ReinH> monochrom: Right, but I didn't answer the question they didn't ask, is my point
09:36:34 <monochrom> there seems to be a high correlation between moving-target questions and curiosity vampires
09:36:39 <ReinH> yep
09:36:44 <SrPx> I love how you know exactly what I'm asking but is trying to push me to ask it more correctly instead...
09:37:04 <ReinH> SrPx: Look, you asked for "faster in practice", which I gave to you.
09:37:13 <ReinH> Then you said that wasn't really what you wanted and you wanted something else instead
09:37:20 <monochrom> no, frankly, I never know what exactly you're asking
09:37:27 <ReinH> Now you're giving me a hard time about my good faith attempts to answer your moving-target questions
09:37:30 <monochrom> but I know exactly what you literally wrote.
09:37:31 <ReinH> So I'll just stop answering them
09:37:44 <SrPx> uhm okay
09:38:26 <ReinH> if you want people to do work for you for free, you should treat them with more respect
09:38:46 <Jafet> Wait, has it gotten to the point where we can expect to have our minds read here
09:39:22 * hackagebot pandoc 1.15.0.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.15.0.3 (JohnMacFarlane)
09:39:23 <SrPx> trying to correct myself, I want a pure data structure which is faster in practice. When I said it isn't faster in a theoretical PoV maybe I expressed myself badly, I meant "asymptotically" (I think). Arrays aren't really O(1) in the sense I can't have a 100 petabytes array, it doesn't scale like that.
09:39:32 <ReinH> "What's 1+1?" "2" "No, that's 1+1, what I meant was 2+@"
09:39:54 <SrPx> So, if I'm trying to implement an algorithm that will scale further than a single RAM I can't just use array as a magic bullet. I think it is more clear now
09:40:18 <Jafet> 100 petabytes is asymptotically a constant.
09:40:31 <ReinH> Sure, it'll scale like that, *in theory*.
09:40:46 <ReinH> In the future, put all pertinent information *in the question*
09:40:48 <monochrom> does IntMap scale further than a single RAM?
09:40:51 <ReinH> stop making us try to read your mind
09:40:57 <saulzar_> SrPx, Right, so you won't use array or vector or intmap ...
09:41:13 <SrPx> It is not easy to know when all the pertinent information is in the question, I truly believed my question made complete sense and was easily answerable. 
09:41:25 <ReinH> I gave you an answer
09:41:39 <SrPx> I know ReinH, thanks for the answers!
09:41:39 <ReinH> Which you rejected because it was the wrong answer to the question I didn't read your mind to discern
09:41:53 <sm> ok, I think we got it :O)
09:41:55 <SrPx> I know ReinH, sorry for making the wrong question! I make mistakes sometimes /2
09:42:01 <ReinH> ok :)
09:43:59 <SrPx> No but really, if there is any pure/persistent/immutable data structure in the sense that it works like those you would find in okasaki's book, is implemented with trees, doesn't depend on mutation and isn't based on primitive arrays/vectors, which is faster than intmaps in the sense it takes less beta reductions in levy's sense, please let me know...!
09:44:55 <SrPx> If there is not or if this isn't clear just ignore the question and move on as I'll be searching through some resources myself, thanks and sorry again!
09:45:11 <aweinstock> SrPx: if you're writing something that should handle 100+PB, I don't think the datastructures in the standard library automatically do cloud-stuff (to deal with allocating that much memory)
09:46:28 <aweinstock> SrPx: is this just for the sake of knowledge, or is there a specific problem that you're trying to solve with this?
09:46:31 <SrPx> aweinstock: I'm trying to study/understand how structures like intmaps scale and doing a few benchmarks, mainly after that reddit thread where someone measured C arrays indexing and it actually progressed logarithmically instead of linearly as you would expect
09:47:13 <SrPx> then someone else said that trees are still worse because they need pointers, so an extra factor, being actually log(N)^2. then someone said you could pack the trees densely and it would be O(log(N)) again. and now I was thinking about it
09:47:52 <aweinstock> can you send me the link to that thread containing measurements? it sounds interesting
09:48:21 <Eduard_Munteanu> Um, arrays should be O(1).
09:49:29 <Eduard_Munteanu> Perhaps the measurement was affected by caching and they didn't find the true constant factor.
09:49:43 <SrPx> https://www.reddit.com/r/haskell/comments/3bqlis/how_do_you_compute_a_histogram_in_a_pure_language/csoyqxt aweinstock 
09:51:32 <Jafet> Actually, (in an unbounded universe locally similar to ours) the access time for any random-access storage is asymptotically O(n^(1/3)). How people end up with O(log n) is beyond me--where did they find those extra dimensions?
09:51:45 <SrPx> ha that's exactly what I said there
09:52:03 <breadmonster> Jafet: How on earth did you achieve that bound?
09:52:36 <ReinH> That C algorithm looks linear? Actually the best fit curve is superlinear but that's not statisticaly significant
09:52:37 <Jafet> Since we live in three-dimensional space, it takes a volume of size O(n^(1/3)) to store n bits in any classical machine.
09:53:55 <SrPx> I just assumed the logarithmic curve came from better cache use for smaller arrays
09:54:21 <ReinH> probably there's just a constant factor and a linear factor, and that the constant factor dominates for small n
09:54:23 * hackagebot inline-c 0.5.4.1 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.4.1 (FrancescoMazzoli)
09:54:27 <Jafet> Why is that logarithmic? Chip wafers are two-dimensional, so we would in fact expect O(sqrt n).
09:54:45 <ReinH> There isn't a logarithmic curve though
09:54:58 <SrPx> fair enough
09:55:11 <ReinH> I don't know why they're saying that
09:55:23 <SrPx> but we can clearly see it is not truly linear, at least
09:55:35 <ReinH> No, we can't
09:55:43 <ReinH> It looks linear to me
09:55:51 <ReinH> but there are also constant factors
09:56:00 <SrPx> well maybe it is, I don't know
09:56:11 <Eduard_Munteanu> Jafet, how is the access time related to space complexity? Are you accounting for propagation delays?
09:56:19 <ReinH> 30 dots on a graph doesn't prove anything
09:56:44 <ReinH> but I see no evidence that it is anything other than linear
09:56:45 <Jafet> Sure, our universe has a propagation delay. (And chips get fairly near it.)
09:57:14 <SrPx> but even if it is, that would be just due to the memory reading synchronization in our particular cpus
09:57:18 <ReinH> er, not linear, constant
09:57:22 <ReinH> why do I keep saying that
09:57:25 <ReinH> sorry
09:58:19 <ReinH> eh, no, linear, but that's expected
09:58:35 <ReinH> since you're literally doing `for (int i = 0; i < length; i++)`
09:58:47 <SrPx> the question I'm trying to answer to myself is: I know arrays aren't truly O(1) but at most O(N^(1/3)). But can trees be O(N^(1/3)) in some kind of specialized architecture, or is there still an obligatory slowdown for trees vs arrays
09:58:57 <ReinH> the array access seems constant, the entire algorithm is linear
09:59:50 <ReinH> arrays are O(1)
09:59:59 <ReinH> trees are O(log n)
10:00:02 <ReinH> done
10:05:05 <monochrom> if you know how a tree is overlaid on an array, you can do a lot of calculations
10:05:07 <ReinH> I'm not engaging in idle speculation about limits of the physical world because the speed of light is completely, utterly dominated by everything else
10:15:15 <felixn> anyone do logic programming in haskell?  I have a algo that does recursive propagation until the there's a solution, or error.  it seems like a good fit for logic programming, and it was really complicated to write the algo so I'm thinking it could help make it easier to understand
10:16:17 <Cale> SrPx: In fact, probably arrays are closer to O(n^(1/2)) even, not only theoretically depending on the physical assumptions you make, but also just in practice, because our memories end up being relatively 2 dimensional due to the needs of cooling things.
10:19:31 <Cale> SrPx: If you're able to distribute the parts of the tree structure carefully, then trees aren't much different from arrays, but if the nodes of the tree can be anywhere in memory, then you're going to take the log factor hit still.
10:20:46 <SrPx> ah I just realized something obvious
10:21:29 <Cale> felixn: Depending on what one might consider logic programming, I've done a fair amount just using nondeterminism monads.
10:22:23 <Cale> (well, you'd also need to be able to distribute the computation)
10:22:25 <ReinH> There's also CSP as a monad, which is pretty cool
10:22:53 <Cale> (that parenthetical remark was related to the SrPx discussion)
10:23:04 <SrPx> trees aren't worse than arrays, if your compiler does some kind of region analysis, packs a tree densely and modifies it inplace when you do an updating operation (instead of allocating and garbage collecting) then you get the same performance as arrays for both reading and writing, the """O(1)"""
10:23:08 <ReinH> @google wadler monadic constraint programming
10:23:09 <lambdabot> http://users.ugent.be/~tschrijv/MCP/
10:23:09 <lambdabot> Title: Tom Schrijvers - Monadic Constraint Programming
10:23:15 <Cale> SrPx: right
10:23:16 <SrPx> correct?
10:23:20 <SrPx> cool Cale
10:23:26 <ReinH> Oh, that wasn't the one I was thinking of
10:23:40 <ReinH> SrPx: Basically: if trees are optimized into arrays then they behave like arrays ;)
10:23:40 <Cale> Uh, well...
10:23:53 <Cale> I'm not sure you even need the updates to be in-place as such
10:23:53 <ReinH> felixn: I was htinking of http://homepages.inf.ed.ac.uk/wadler/papers/constraints/constraints.pdf
10:23:55 <SrPx> ReinH: yea, kinda obvious now that I think about it
10:24:49 <ReinH> Well, it's basically the same since Schrijvers was a coauthor of that paper
10:25:13 <Cale> You just need a certain amount of locality. Doing mutations shouldn't really be allowed, as it'll obviously ruin your performance in other ways.
10:26:31 <SrPx> Cale: why? 
10:27:10 <SrPx> If a value is known to never be used again it would just be kinda like an early garbage collection, to rewrite it inplace instead of allocating the memory and creating pointers... say, "foo (x,y) = (x,3)" 
10:27:20 <Cale> Well, what happens when you do several insertions to a tree, and then access the old version? Does it gradually become linear time in the number of insertions?
10:27:42 <Cale> There's nothing to guarantee that the old tree is necessarily inaccessible.
10:27:55 <ReinH> In fact, the guarantee is that it must be accessible
10:27:59 <ReinH> since it's a persistent structure
10:28:00 <Cale> (I mean, if it's not, then yes, you can optimise this)
10:28:19 <Denommus> if you want something like that, you need linear/affine/ownership types
10:28:25 <Denommus> and that's really not Haskell's proposal
10:28:35 <Denommus> Clean did that in the past, though
10:28:43 <Denommus> and Rust does it, though not purely
10:28:56 <ReinH> (To this day, ephemeral and persistent seem to be backwards to me wrt data structrures, but I guess I need to drink more koolaid)
10:28:57 <SrPx> hmm okay
10:29:15 <Cale> But I think with very large memories, so long as your computational power isn't entirely centralised, you can still do something to keep tree lookups O(n^(1/2)) just like array lookups.
10:29:26 <ReinH> Denommus: linear logic-based programming languages are so hot right now
10:29:31 <ReinH> well, they aren't, but they should be
10:29:42 <hiptobecubic> ReinH, example?
10:29:47 <Cale> Well, the whole thing is that array lookups *are* tree lookups at that scale anyway
10:29:54 <ReinH> @google types as sessions
10:29:55 <lambdabot> http://www.ecnp-congress.eu/programme/typessessions.aspx
10:29:56 <lambdabot> Title: Types of sessions
10:29:59 <ReinH> argh
10:30:19 <ReinH> Oh, my fault
10:30:19 <Denommus> ReinH: I wish I had the time to make a "SystemsML", using ownership types in a ML-like language (with the module system and all that)
10:30:23 <ReinH> @google propositions as sessions Wadler
10:30:25 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-sessions/propositions-as-sessions.pdf
10:30:25 <lambdabot> Title: Propositions as Sessions
10:30:30 <ReinH> hiptobecubic: ^
10:30:34 <Jafet> Persistent data structures aren't the same as purely functional data structures, mind you. (They're not even the same as non-lazy purely functional data structures.)
10:31:12 <Denommus> Jafet: I didn't wish to imply they were the same
10:31:39 <Cale> SrPx: You start having to worry about where in memory your tree nodes get allocated for that though. If you have no power to control that, then I think you just have to eat the log factor and it becomes something like O(n^(1/2) log n)
10:32:20 <ReinH> Denommus: that may have been for me :)
10:32:31 <Jafet> I wasn't implying that you did.
10:32:50 <Jafet> There is ML-Kit which attempts to use region typing for standard ML.
10:33:14 <Denommus> I heard of it
10:33:22 <Denommus> but I was wishing to do something a lot more radical
10:33:33 <Denommus> like doing IO operations through a linearly typed World
10:33:37 <SrPx> I see
10:33:58 <Denommus> that would hinder concurrency, but it would be an interesting experiment
10:34:19 <erisco> can you read from Text?
10:34:52 <Eduard_Munteanu> erisco, only if you unpack first
10:34:59 <erisco> :(
10:35:01 <Jafet> It's more difficult than that. If you use linear typing, you can no longer share values easily.
10:35:10 <ReinH> Denommus: "hinder" ;)
10:35:12 <Cale> SrPx: Of course, this kind of consideration always gets weird, because once you remove bounds on the amount of memory in your machine, you end up talking about strange computer architectures.
10:35:29 <Jafet> :t T.uncons
10:35:30 <lambdabot>     Not in scope: ‘T.uncons’
10:35:31 <lambdabot>     Perhaps you meant one of these:
10:35:31 <lambdabot>       ‘BS.uncons’ (imported from Data.ByteString),
10:35:36 <Eduard_Munteanu> erisco, 'read' is a pretty bad parser anyway, if you need anything quick, look into writing an attoparsec parser
10:35:42 <ReinH> Cale: Yes, strange like turing machines! ;)
10:35:54 <Cale> Yeah, Turing machines make things even worse
10:36:02 <Cale> Array lookups are O(n) then :D
10:36:06 <ReinH> :D
10:36:30 <ReinH> Eduard_Munteanu: I wouldn't suggest attoparsec for a quick parser due to the error messages
10:36:46 <shachaf> Even with an array oracle, array lookup would take O(log n) time.
10:36:56 <SrPx> everything is bizarre, I don't know anything
10:36:57 <Jafet> The stranger thing is, we don't even know for a fact that Turing machines aren't slow
10:37:01 <erisco> Eduard_Munteanu, I just want to convert Text to Int, I don't need a sophisticated parser
10:37:02 <Eduard_Munteanu> ReinH, the lack of? Well, 'read' is even worse.
10:37:14 <Jafet> (despite the fact that they cannot look up an array in o(n) time)
10:37:19 <Eduard_Munteanu> erisco, read . T.unpack
10:37:21 <ReinH> Eduard_Munteanu: true enough!
10:37:24 * Eduard_Munteanu has to go
10:37:26 <Cale> and of course if you keep the bound on the amount of memory in the machine, then you might as well just call every operation O(1)
10:37:28 <doomlord> is the haskell community interested in the Parlalella architecture (i've heard haskellers complain that CPUs are C machines). being DMA based, it suffers with pointer-based code, and relocating things isn't painful
10:37:33 <erisco> yeah it is just unfortunate to have to unpack but ah well :)
10:37:41 <erisco> I can write a specialised function if need be later
10:37:44 <ReinH> :t readMaybe
10:37:45 <lambdabot> Not in scope: ‘readMaybe’
10:38:00 <ReinH> You should use readMaybe from Text.Read for any non-trivial uses of read
10:38:01 <SrPx> doomlord: I'm very interested in it
10:38:07 <latk> did anyone manage to get spacemacs working with stack ?
10:38:11 <joco42> hamishmack: Is it OK to use Leksah together with cabal repl simultaniously on the same project ? Are there any conflicts ? Do they play nice together ?
10:38:12 <SrPx> doomlord: almost purchased one, although I'm really interested in an actual functional computer
10:38:22 <ReinH> Nothing is better than throwing an error. That didn't come out right.
10:38:28 <ReinH> ``Nothing'' is better than trowing an error.
10:38:46 <felixn> Cale: ReinH: ah CSP looks cool, I just read about List Monad as well.  my problem seems related to a family tree example, where you define the relationships you know, and then it can infer the rest so you can ask more questions
10:38:56 <doomlord> SrPx i'm not a haskeller, but got interested in functional ideas after the sony CELL. no language/implementation ever appeared that made the most of it IMO
10:39:04 <ReinH> felixn: Also https://hackage.haskell.org/package/logict
10:39:16 <SrPx> doomlord: what do you mean
10:39:25 <ReinH> felixn: That sounds like prolog to me
10:39:32 <doomlord> SrPx i can see the appeal of haskell ..
10:39:56 <SrPx> doomlord: but you think it doesn't make the most of fp
10:40:08 <joehillen> doomlord: I recommend reading this: http://chimera.labs.oreilly.com/books/1230000000929
10:40:10 <felixn> ReinH: thanks for the direction!  we'll see how this pans out :D
10:40:12 <arw> doomlord: problem is, it all comes down to compilers and their optimizations. and unfortunately, there hasn't been a new architecture with a good compiler yet.
10:40:42 <doomlord> SrPx - haskell hasn't won me over (yet), but i'm still interested in new ideas in this field
10:40:49 <joehillen> arw: mill looks very promising, but I'm worried it might be anti-FP
10:40:53 <Cale> doomlord: Heh, just before the Cell came out I was actually working with a research project using the PPC/Altivec which would have been much nicer with Cell's architecture.
10:41:00 <arw> doomlord: they tend to get better, but the company developing the architecture runs out of money even faster.
10:41:21 <doomlord> yeah i fear we'll never see the 28nm parallella or beyond
10:41:38 <Cale> doomlord: It was a special purpose language for signal processing applications (with a compiler written in Haskell -- I believe they eventually turned it into a Haskell DSL, but that was at some point after I left)
10:41:39 <hamishmack> joco42: Why not use ghci mode in Leksah (it runs cabal repl on the active package)?
10:41:46 <doomlord> we'll be stuck with cores tripping over eachothers caches
10:41:57 <doomlord> Cale that sounds interesting
10:42:31 <ReinH> felixn: I'd be interested to know what you come up with :)
10:43:03 <ReinH> felixn: Actually, a survey of methods for solving that problem would be an interesting comparison of the approaches we've discussed, so you should solve it using all of them and then write a blog post. :D
10:43:27 <arw> doomlord: yeah, unfortunately. problem is, sharing data is what comes easy to people, and its easier to tell them "do it rarely" than "never do it, doesn't work at all"
10:43:35 <Cale> doomlord: Basically, we were doing fairly brute-force-ish sorts of things to find things like ideal instruction orderings and optimise other aspects of the algorithms, because the expectation was that it might be worthwhile to let the compiler run for a week optimising something in some of these applications -- and having direct control over things like the cache would have been ideal.
10:43:40 <hamishmack> joco42: I think you should be ok running cabal repl at the same time outside of leksah, but you could use the --buiddir option of cabal to be safe
10:43:42 <joco42> hamishmack: https://gist.github.com/anonymous/0efae4a07017bc9f1d8e
10:43:48 <ReinH> felixn: Although tbh for that specific problem you might be best of just using a shortest path graph traversal algorithm?
10:43:50 <felixn> ReinH:  I have a meldium draft for Atom + Haskell, I get caught yak shaving all the time >_<
10:43:53 <ReinH> *best off
10:43:56 <Cale> (since it makes the simulation of how quickly the code will run much better)
10:44:31 <hamishmack> joco42: Ah stdin
10:44:32 <doomlord> Cale sure the deterministic aspect is rather nice
10:44:41 <joco42> hamishmack: this was the use case I was thinking about, but perhaps this kind of interactivity is not needed with reflex-dom
10:44:51 <doomlord> knowing the optimum working set size
10:45:44 <felixn> ReinH: the algo is for type inference, it was really complicated (works now).  I need to fix my function application algo though, so I'm wondering if logic programming would bring the problem closer to my brain
10:46:22 <joco42> hamishmack: thanks for the builddir tip , I keep it in mind/Evernote
10:46:26 <hamishmack> joco42: I doubt you will need stdin for reflex-dom
10:47:14 <hamishmack> Another option is to open a socket and use that instead of stdin
10:47:15 <joco42> hamishmack: probably not, I was just thinking doing same super basic command line reflex examples
10:47:36 <hamishmack> Like this http://stackoverflow.com/questions/7425184/using-leksah-debugger-with-programs-that-use-readln-and-similar
10:47:46 <ReinH> felixn: Have you seen...
10:47:50 <ReinH> @google typing haskell in haskell
10:47:53 <lambdabot> http://web.cecs.pdx.edu/~mpj/thih/thih.pdf
10:47:53 <lambdabot> Title: Typing Haskell in Haskell∗
10:48:02 <hamishmack> Then you can use hGetLine instead of getLine
10:48:21 <hamishmack> Not ideal, but it works
10:49:50 <joco42> hamishmack: so it is this code  https://gist.github.com/anonymous/e3c8329c65687d76a421 ?
10:50:17 <hamishmack> yes
10:51:32 <felixn> ReinH: nice, looks well written and succinct, I'll check it out this weekend!
10:52:10 <joco42> hamishmack: and where do I have to have this code? in the Main.hs ?
10:52:35 <hamishmack> Yes
10:53:15 <felixn> Cale: what do you mean by nondeterminism monads?  any good articles?
10:54:04 <joco42> hamishmack: I understand now, thanks.
10:55:30 <joco42> hamishmack: this is quite a good solution, perhaps the boilerplate socket connection can be factored out somehow...
10:55:36 <liangzan> hello. i’m new to haskell. can i ask a question?
10:56:30 <shachaf> Evidently yes.
10:56:42 <liangzan> how do i install a haskell package? i know it is through ```cabal install```
10:56:51 <erisco> liangzan, first you must ascend the windy mountain and pass the nine trials of fortitude
10:56:59 <liangzan> but shouldn’t there be a configuration file or something?
10:57:07 <liangzan> for the packages list?
10:57:35 <liangzan> like gemfile or packages.json or even build.sbt
10:58:04 <felixn> liangzan: cabal init !  YourPackage.cabal
10:58:11 <liangzan> oh i see
10:58:19 <liangzan> how about stack?
10:58:36 <felixn> liangzan: but I think all will be clear ... if you ascend the windy mountain and pass the nine trials of fortitude
10:58:38 <liangzan> is there a stack equivalent?
10:59:01 <felixn> liangzan: stack datastructure?
10:59:15 <liangzan> stackage.org from commercial haskell
10:59:26 <liangzan> i’m fine with cabal init
10:59:28 <liangzan> thanks!
10:59:40 <felixn> liangzan: oh yea, I haven't used it yet, but it sounds awesome because cabal makes me mad often
10:59:48 <felixn> liangzan: give stack a spin!
11:00:06 <liangzan> yes i’m trying stack
11:00:28 <liangzan> i understand it as some sort of bundler equivalent(sorry i’m from the ruby world)
11:00:58 <joco42> hamishmack: I recently asked on reddit about the Haskell tool's used : https://www.reddit.com/r/haskell/comments/3bqy5h/survey_which_haskell_development_tools_are_you/
11:01:22 <felixn> liangzan: ruby community seems smart, they've embraced DSLs, while Python community still calls that magic
11:01:42 <joco42> hamishmack: and I am wondering why Leksah was not represented, perhaps the upcoming vagrant environment will change that
11:02:29 <Denommus> ReinH: it would definitely hinder, because you'd have to send the World back and forth between tasks to be able to do IO in multitask
11:02:37 <felixn> liangzan: I think stack still uses cabal files, looking at the repos in their listing, they all just have cabal files: http://www.stackage.org/lts-2.16
11:03:10 <liangzan> felixn: thanks for the help!
11:03:23 <ReinH> felixn: The nondeterminism monad is []
11:03:35 <hamishmack> joco42: I am not sure.  Not many people give any feedback (good or bad) on Leksah, which is a problem.
11:03:36 <joco42> hamishmack: I even wonder if pre-built binaries would help.
11:04:31 <felixn> ReinH: https://wiki.haskell.org/Logic_programming_example <-- so is this an example of that?  since they're using the list monad
11:04:53 <joco42> hamishmack: I think the power of Leksah (for Haskell) is on par with the alternatives, so I was surprised to see that it is not represented in the reddit answers.
11:05:08 <ReinH> > do d1 <- [1..6]; d2 <- [1..6]; return (d1, d2) -- dice rolling using the nondeterminism monad
11:05:09 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
11:06:27 <ReinH> felixn: consider determinism as producing exactly one result, determinism with failure as producing zero or one result,  nondeterminism as producing one or more results, and nondeterminism with failure as producing zero or more reuslts
11:07:17 <ReinH> felixn: and you get (an interpreteation) of the monads for Identity, Maybe, NonEmpty, and [], respectively
11:07:31 <felixn> ReinH: ahhh, that makes sense, so a list of things :D  that sounds like something I may want ... !
11:07:44 <joco42> hamishmack: Leksah could be supported by the FPComplete guys perhaps... 
11:08:14 <joco42> they seem to be selling Haskell to a wide audiance
11:08:31 <felixn> joco42: I tried to use Leksah a few times, never was successful with making it work well.  while Atom worked for me right out of the box, though took a bit a work for ghc-mod to compile
11:08:40 <joco42> and a nice shiny IDE might appeal to them
11:09:01 <ReinH> felixn: another interesting thing is that you can parametrize by choice of determinism
11:09:16 <hamishmack> felixn: Did you log any issues for Leksah?
11:09:25 <liangzan> sorry another noob question. how do you resolve a cabal dependency error?(shouldn’t it be a solved prb? look its 2015)
11:09:40 <felixn> ReinH: what does that mean!?  it sounds super interesting
11:09:48 <ReinH> for example, a function Char -> String can be used for a detrerministic rewriting system. A function Monad m => Char -> m String can be used for a rewriting system that is parametrized by choice of determinism. Identity for deterministic, [] for nondeterministic.
11:10:05 <ReinH> This lets you generalize nicely
11:10:07 <joco42> felixn: right, out of the box, virtualbox ! I might just put up my virtualbox image to google drive and then Leksah will work out of the box.
11:10:24 <felixn> hamishmack: I repressed my issues, like I normally do
11:10:48 <magneticDuck> so dark
11:10:57 <felixn> lol
11:12:43 <bernalex> have anyone considered implementing idris style nested record updates in ghc?
11:13:07 <hamishmack> joco42: FPComplete are doing lots of work on stuff that might work well in Leksah, unfortunately I do not even have time to read it all.  It would be greate if someone would integrate it into Leksah.
11:13:40 <ReinH> felixn: for example, here's a deterministic L-system:
11:13:44 <ReinH> > let rule = \c -> case c of { 'a' -> "ab"; 'b' -> "a"} in "b" >>= rule >>= rule >>= rule >>= rule >>= rule
11:13:45 <lambdabot>  "abaababa"
11:13:57 <joco42> hamishmack: Somebody from FPComplete should do that. It would be their interest too.
11:14:36 <felixn> bernalex: like lenses?  I think idris pulls it off better because it's more polymorphic
11:15:13 <joco42> hamishmack: I put up this virtual image, and perhaps then the FPComplete guys can have an out-of-the-box look.
11:15:21 <bernalex> felixn: they have it baked in for their records -- no need for lens for that particular use case.
11:16:04 <Denommus> I don't quite understand what's the deal with stack
11:16:10 <Denommus> I don't want to sound dismissive
11:16:26 <Denommus> but I really don't understand its use-case
11:16:42 <felixn> bernalex: I think they pull that off, because it can do adhoc polymorphism without type classes
11:16:46 <ReinH> Denommus: It's an attempt to fix some perceived issues or limitations with cabal, but I suppose its value is predicated on your belief that cabal has those issues.
11:16:59 <bernalex> felixn: I'm not sure what that means. idris uses typeclasses for ad-hoc polymorphism.
11:17:04 <Denommus> ReinH: I don't find a lot of issues when working with a sandbox
11:17:33 <felixn> bernalex: I can redefine (.) without a type class, and it will choose the correct instance that fits in the context
11:17:35 <bernalex> felixn: also, I don't think it's true that that is the only way to do it. I can't see a reason we can't have the same syntax in ghc. if that's the reason, you'll have to explain it in more detail for me. :)
11:17:35 <ReinH> Denommus: then it makes sense that you aren't seeing much value in stack :)
11:18:09 <ReinH> For my part, I stopped being in the business of compiling Haskell packages before stack was announced, so while I definitely perceive some issues and limitations with cabal, I haven't evaluated stack.
11:18:10 <bernalex> felixn: ah. I see what you mean. I wish we had that too. :)
11:18:24 <bernalex> felixn: it would be *very* useful for Set/Map/etc.
11:18:39 <Denommus> ReinH: don't people use sandboxes?
11:18:40 <joco42> hamishmack: I wonder if Leksah could be compiled to run in the browser...
11:18:51 <ReinH> Denommus: Many do, but they don't solve everything
11:19:04 <felixn> bernalex: yea, definitely!  that's one thing that bugs me about haskell's polymorphism
11:19:11 <felixn> ReinH: that looks really close to my algo, I basically keep repeating until it see's there's nothing left
11:19:19 <ReinH> For example, sandboxes don't share anything, so you end up with a lot of duplicate compilation
11:19:40 <ReinH> After the 100th time waiting for lens to compile even though it already exists on your system in 99 other places, you start to get a bit annoyed. ;)
11:19:45 <hamishmack> joco42: That was the plan.  Migrate one pane at a time to ghcjs-dom then allow it to be run without Gtk
11:19:47 <bernalex> felixn: I have some recent code lying around with a bunch of M.insert this, S.delete that, filter that, then second M.map it over a first S.filter ughughugh.
11:20:05 <hamishmack> But it is a very long term plan unless more people help
11:20:12 <ReinH> (Not that stack necessarily fixes this problem. It might but I don't know.)
11:20:41 <maerwald> ReinH: it's more annoying to attempt to share a lens version, because of zero ABI compatibility and over-strict dependencies
11:20:45 <felixn> bernalex: but yea, I think that's what idris does, it just lets all the records adhoc define the same getters/setters, and the polymorphism chooses the correct instance (without lenses!)
11:21:25 <ReinH> maerwald: Yes, but that annoyance would be on the part of the person that figures out how to do the sharing, not the people installing lens
11:21:36 <joco42> hamishmack: FPComplete might be the interested party, I wonder what would motivate them to get really interested in helping with that plan.
11:21:38 <ReinH> so it's not a fair comparison ;)
11:21:38 <bernalex> felixn: I don't understand why we can't have the same syntax in haskell though
11:21:54 <maerwald> ReinH: no, the annoyance is on both
11:21:56 <bernalex> felixn: well, OK, TBF, in haskell we'd get runtime errors, which aren't very nice
11:22:27 <maerwald> ReinH: if you try to share, you have to make choices, because the dependencies simply cannot be satisfied
11:22:52 <arianvp> does something like LinkedHashMap exist in haskell?
11:23:00 <ReinH> maerwald: It's possible to uniquely identity a compilation by the transitive closure of its dependencies (including itself)
11:23:03 <arianvp> a map with insertion-order on iteration?
11:23:16 <bernalex> haskell ABI is completely and utterly retarded. it's one of the worst thing about using haskell. :)
11:23:39 <bernalex> (hallo, source-based distro user reporting in ;)
11:23:43 <maerwald> ReinH: I don't really know what you mean, but I know the reality of haskell packages in common linux distributions that try to do that sharing. It doesn't work
11:24:16 <bernalex> I do haskell packaging & can verify what maerwald says
11:24:18 <ReinH> maerwald: The version of lens + the version of all of lens's dependencies gives a unique identifier. Anything requesting that unique identifier will get the same ABI of lens.
11:24:28 <maerwald> bernalex: oh, you do haskell packaging too? ;)
11:24:44 <ReinH> (modulo reinstalls)
11:25:08 <maerwald> ReinH: it's about _blockers_
11:25:10 <bernalex> maerwald: yes, maybe we are soulmates -- are you a satanist too??
11:25:22 <ReinH> maerwald: Ok, I'll bite. :) What are _blockers_?
11:25:26 <maerwald> ReinH: one package wants this exact version range, the other a conflicting one
11:25:32 <maerwald> you can't have both
11:25:45 <bernalex> ReinH: rebuilds are fun when you need to rebuild 100+ haskell packages
11:25:49 <ReinH> maerwald: I don't see how that's relevant. This is assuming that you have an install plan.
11:25:55 <maerwald> that is very common... in the C world this "sort of" works, because of ABI compatibility, deprecation phases and whatnot
11:26:00 <ReinH> If you don't have an install plan, you can't install, so obv you can't get sharing
11:26:13 <ReinH> for the thing that doesn't exist
11:26:20 <maerwald> ReinH: and the rebuilding problem is still there, because of the ABI problem
11:26:31 <maerwald> it's just marignally better, with the addition of blockers
11:26:55 <maerwald> and it confuses our package managers because of the dep-graph complexity
11:27:00 <bernalex> a haskell package's ABI is the (recursive) sum of all dependencies' ABIs
11:27:03 <hamishmack> joco42: I think FPComplete wanted to make money from a paid IDE, but underestemated the market size by several orders of magnitude
11:27:04 <bernalex> that's a complete and utter nightmare
11:27:08 <maerwald> right
11:27:14 <ReinH> Yes, thus transitive closure above
11:27:25 <bennofs> bernalex: not only that. the ABI can even change if you just do a rebuilt! [under the exact same conditions]
11:27:28 <bernalex> updating cabal and ghc is also, liek, totally zuper fun
11:27:30 <ReinH> hamishmack: sounds about right
11:27:32 <bernalex> bennofs: YES
11:27:42 <ReinH> bennofs: ouch
11:27:47 <ReinH> maerwald: Right, so, never mind then :(
11:27:52 <bennofs> but there is work for removing such issues in GHC
11:27:55 <hamishmack> s/underestimated/overestimated
11:27:58 <bennofs> see ghc bug #4012 iirc
11:28:00 <ReinH> I knew the ABI was poor, I didn't realize it was incoherent...
11:28:17 <bernalex> another fun thing is that recursively updating all deps is *a nightmare*
11:28:19 <bernalex> it takes *forever*
11:28:25 <bernalex> and sometimes *you get it wrong*
11:28:28 <ReinH> heh
11:28:28 <bernalex> so packages just *break*
11:28:32 <bernalex> *silently*
11:28:34 <bernalex> wee :D
11:28:37 <ReinH> :D
11:28:39 <bennofs> bernalex: that's what nix is for :)
11:28:39 <sccrstud92_> ReinH: its been an issue for Nix for a while; they do exactly that, but the nondeterminism bug throws a wrench in things
11:28:55 <felixn> is it possible to distribute partially compiled haskell libraries?
11:28:57 <ReinH> sccrstud92_: the great irony of Haskell's builds being nondeterministic is not lost on me
11:29:06 <bernalex> bennofs: nix do it better than most. I think maybe guix does it well too. not sure, though.
11:29:24 <ReinH> felixn: not really, per this current discussion
11:29:25 <maerwald> bernalex: well, the PM yes... not the OS though
11:29:31 <bennofs> bernalex: guix too, it uses nix at the core I think (it just doesn't use the nix "frontend" language)
11:29:43 <bernalex> maerwald: do you mean nixos?
11:29:47 <maerwald> bernalex: yes
11:29:54 <bernalex> maerwald: that's not related to nix
11:29:56 <bernalex> maerwald: well it is
11:29:58 <bernalex> maerwald: but
11:30:02 <bernalex> maerwald: you know what I mean I guess
11:30:08 <maerwald> bernalex: as I said... the PM is fine, but the OS is meh
11:30:18 <bernalex> maerwald: NixOS is not "Nix OS"
11:30:24 <bernalex> maerwald: they are unrelated projects is what I mean
11:30:30 <maerwald> bernalex: I am being deliberately imprecise
11:30:34 <maerwald> I know
11:30:43 <bernalex> I saw the nix guy talking at FOSDEM. he was brilliant.
11:30:50 <bernalex> NixOS... meh. GNU GUIX was way cooler.
11:31:09 <bennofs> bernalex: but it has a lot less packages!
11:31:18 <bernalex> bennofs: yes, I mean purely from the tech pov
11:31:22 * bennofs disappears
11:31:30 <maerwald> bernalex: automatically creating FHS compatible chroots/environments still need improvement afais
11:32:22 <maerwald> and the problem is really the whole linux eco system which is still (inconsistently) stuck to FHS which was written in a time when there was only C
11:32:32 <bernalex> bennofs: seeing some emacs savant installing a bunch of packages, reverting the installs, writing new packages, installing them, modifying the packages, reverting and updating packages with new src, jumping between snapshots etc etc etc, all without leaving emacs... yeah. OK. I'm impressed now. dogfooding works. :p
11:32:45 <maerwald> but I have no idea how an alternative could look like or if it even makes sense to standardize this stuff
11:33:23 <bernalex> maerwald: C is broken. UNIX is broken. WIMP is broken. CLI is broken. x86 is broken. silicon is probably broken too. everything is broken. lol.
11:33:29 <maerwald> but it's a fact that a lot of distros have trouble to map proper behavior over new languages. including haskell, ruby, go and whatnot
11:34:28 <littlebluedana> I've noticed a lot of computing isn't straightforward because you're usually hacking around irrelevant problems.
11:34:55 <maerwald> bernalex: and yes, I worship satan too btw
11:35:17 <bernalex> littlebluedana: nobody has the time to do things right, because they're so busy dealing with the problems caused by doing it wrong.
11:35:22 <hiptobecubic> littlebluedana, "irrelevant" how? They are usually pretty relevant.
11:35:24 <maerwald> haha
11:35:38 <maerwald> bernalex: that basically sums it up :D
11:37:35 <littlebluedana> hiptobecubic: At least most of my scripting is trying to work around buggy wireless drivers.  Most of my programming in C is sanity/error checking rather than programming toward the problem (where exceptions would have been realllly nice).
11:38:24 <littlebluedana> At least in Haskell, most of my programming is actually up front design time like it should be.
11:40:46 <maerwald> littlebluedana: that also has disadvantages, because you cannot expect to know everything up front depending on what you are doing
11:41:15 <maerwald> adding random effects to a haskell program may involve considerbly more refactoring than in a language that allows side effects everywhere
11:41:48 <littlebluedana> That's true, too.  Use your tools properly is probably the proper method.
11:59:53 <joco42> hamishmack: hmmm that is interesting.... underestimated or overestimated ?
12:07:39 <hamishmack> joco42: overestimated
12:07:59 <joco42> hamishmack: i see, good to know
12:08:42 <joco42> hamishmack: but it might be a growing market, question is, how quickly
12:11:59 <YellowOnion> Anyone here skilled in gloss?
12:12:05 <elben> So, in light of https://wiki.haskell.org/Haskell_logos/New_logo_ideas, did Haskell finally just hire a professional to do the current logo?
12:12:31 <YellowOnion> I got some issues with gloss having a fit when my step function takes too long.
12:13:29 <Welkin> wow
12:13:33 <Welkin> most of those look horrible
12:14:30 <elben> Oh, here is the winning submission https://wiki.haskell.org/ThompsonWheelerLogo
12:24:14 <erisco> Data.HashSet (needs flag -package unordered-containers-0.2.4.0)
12:24:22 <erisco> what does that mean? the "needs flag" bit?
12:24:49 <Tuplanolla> "needs the following command-line option".
12:26:27 <erisco> hm
12:26:34 <erisco> I add that flag but get the same error
12:26:44 <erisco> and why would a flag be needed
12:27:08 <bennofs> erisco: are you using cabal?
12:27:21 <erisco> oh it is looking at two different versions
12:27:55 <erisco> why is it not just taking the default version
12:28:00 <erisco> bennofs, yes
12:28:26 <bennofs> erisco: is unordered-containers in your build-depends?
12:28:33 <erisco> I am just using ghci
12:28:37 <erisco> I don't have a package
12:28:49 <bennofs> erisco: oh, that was what I meant by "are you using cabal" :)
12:29:54 <bennofs> erisco: hmm, what does ghc-pkg list unordered-containers show?
12:29:56 <monochrom> do you have unordered-containers installed?
12:30:11 <monochrom> if not, you should. it's very useful
12:30:20 <bennofs> monochrom: yes, if ghc is suggesting that, then it knows about the package
12:30:20 <erisco> I do, two versions of
12:30:35 <erisco> oh
12:30:36 <monochrom> don't do two versions
12:30:36 <erisco> wait
12:30:40 <erisco> I cannot read
12:36:22 <Erebe> does any one have tried stack yet ?
12:37:28 <athan> Erebe: It's sweet :)
12:37:46 <Erebe> athan: what do you like about it ?
12:37:56 <Erebe> (I haven't tried it myself yet)
12:38:18 <Erebe> athan: I ask you that because, for now I am fine with halcyon + sandboxes
12:38:31 <Dynasty> I have a value that I would like to map which is deeply nested inside a data structure made from many different types. Is there a way to do this without writing a bunch of boilerplate code? I'm trying to map a Language.Haskell.TH.Syntax.Name which is deeply nested inside a Language.Haskell.TH.Syntax.Dec
12:38:35 <erisco> derivable Hashable would be nice
12:39:01 <Erebe> and I don't see too much what does it bring
12:39:46 <erisco> hm, what be this derivable generic stuff
12:40:27 <Tuplanolla> You can serialize things with it for instance, erisco.
12:40:37 <athan> Erebe: I still use sandboxes, just because I still haven't gotten used to it, but the reporting in stack is really nice
12:40:52 <athan> you can also install different GHC versions on-the-fly (pretty sure)
12:41:13 <athan> also, the installs aren't isolated like sandboxes, so 1/2 of my HD won't be consumed haha
12:41:21 <erisco> aw, Vector is not hashable
12:41:27 <Tuplanolla> Here's how you'd send socket addresses over sockets, erisco: http://lpaste.net/133735#a133736
12:42:07 <athan> Erebe: It can install (stackage-compatible) libraries using different package version namespaces, like lts or stackage's nightly
12:42:10 <sccrstud92_> Dynasty: lenses?
12:43:06 <sbrg> anyone else see the haskell logo link on reddit? oh my god
12:43:15 <sccrstud92_> idk if they work with TH stuff though
12:43:54 <littlebluedana> sbrg: Hmm?
12:43:57 <erisco> so, hm
12:44:07 <marchelzo_> PURE POWER VIA MONADS
12:44:25 <sbrg> littlebluedana: link to the haskell wiki where people were coming up with and voting on a new logo back in '09 or something
12:44:30 <erisco> I can write an instance for Vector certainly, but it is somewhat awkward to have local instances
12:44:37 <erisco> I guess that is another topic
12:45:18 <Tuplanolla> Ideally Generic would be derived automatically.
12:45:35 <baloo1> hello
12:46:53 <athan> marchelzo_: :D
12:47:44 <marchelzo_> athan: I wonder where Haskell would be today had that logo been adopted :)
12:47:56 <athan> way more badass
12:49:44 <Erebe> athan: ok I will give it a shot this weekend on my current project (sorry for the late answer)
12:49:50 <Tuplanolla> It's not misleading to have Cabal hell mentioned in the logo.
12:50:06 <athan> nw :)
12:52:02 <sbrg> marchelzo_: hell ask
12:52:12 <sbrg> Tuplanolla: heh, relevant ^ 
12:56:03 <athan> marchelzo_: The chrome one is so funn
12:56:08 <athan> funny*
12:57:32 <marchelzo_> athan: The rationale for it is the best.
13:01:29 <athan> Ahh, I see where nixos got its logo now
13:02:19 <athan> marchelzo_: https://wiki.haskell.org/File:Sgf.png
13:02:32 <johnhagre> I want to separate <a string with -> from <a string with ->-<a string without ->. How to do that in haskell?
13:02:39 <johnhagre> Like ab-cd-ef-gh to ab-cd-ef
13:03:20 <marchelzo_> athan: oh wow, good catch
13:04:13 <Tuplanolla> Is Data.List.Split enough, johnhagre?
13:04:47 <Tuplanolla> If not, try Text.Parsec.
13:05:35 <MuffettMan> init $ Data.List.Split.splitOn "-" "ab-cd-ef-gh" ?
13:06:28 <MuffettMan> Oops, have to concat the result too
13:06:43 <MuffettMan> concat . init $ splitOn "-" "ab-cd-ef-gh"
13:06:52 <MuffettMan> I think that should work if I understood the question
13:06:52 <fugyk> yes thanks, thats what I am looking for
13:07:11 <MuffettMan> No problem
13:11:17 <jamesfordummies> why does `dropWhile (== 3) [1,2,3]` equal `[1,2,3]`
13:12:03 <whiteline> you are probably thinking of takeWhile
13:12:30 <adamse> > dropWhil (== 3) [1,2,3]
13:12:31 <lambdabot>      Not in scope: ‘dropWhil’
13:12:31 <lambdabot>      Perhaps you meant one of these:
13:12:31 <lambdabot>        ‘dropWhile’ (imported from Data.List),
13:12:34 <adamse> > dropWhile (== 3) [1,2,3]
13:12:36 <lambdabot>  [1,2,3]
13:12:46 <Tuplanolla> > dropWhile (/= 3) [1, 2, 3]
13:12:47 <lambdabot>  [3]
13:13:00 <jamesfordummies> i expect [1,2]
13:13:11 <Tuplanolla> > takeWhile (/= 3) [1, 2, 3]
13:13:12 <lambdabot>  [1,2]
13:13:13 <MuffettMan> > takeWhile (/=3) [1,2,3]
13:13:14 <lambdabot>  [1,2]
13:13:16 <arw> > dropWhile (/= 3) [1, 2, 3, 4]
13:13:18 <lambdabot>  [3,4]
13:13:26 <whiteline> yeah
13:13:37 <MuffettMan> dropWhile checks the predicate, and drops if the predicate is true, until the predicate is false
13:13:53 <MuffettMan> takeWhile checks the predicate and takes if the predicate is true, until the predicate is false
13:14:11 <arw> the thing you are probably really looking for is
13:14:19 <arw> > filter (/= 3) [1, 2, 3, 4]
13:14:19 <jamesfordummies> i see
13:14:20 <lambdabot>  [1,2,4]
13:14:25 <jamesfordummies> yes that is what i’m looking for
13:14:26 <jamesfordummies> thank you
13:14:27 <monochrom> 1==3 is false. this tells dropWhile to stop dropping.
13:14:34 <arkeet> > takeWhile (/= 3) [1, 2, 3, 4]
13:14:36 <lambdabot>  [1,2]
13:14:52 <jamesfordummies> > takeWhile (/= 3) [1,2,3,1,3]
13:14:54 <lambdabot>  [1,2]
13:15:18 <jamesfordummies> this caused much too large of a headache :/
13:15:29 <MuffettMan> both dropWhile and takeWhile stop as soon as the predicate returns false, filter is applied to the whole list
13:16:02 <jamesfordummies> right, thanks
13:16:03 <jamesfordummies> :)
13:20:13 <athan> I'm working on an STM cache for a WAI server - would you rather generate a new TVar for each unique client identifier (maybe a cookie or something?), or should I store one TVar of a Map between the identifier and data?
13:21:54 <monochrom> I would look at how I use those identifiers and find the right tool for the actual use, not find a rule of thumb.
13:23:32 <pennny2> can you have different versions of ghc installed?
13:23:38 <monochrom> yes
13:24:45 <c_wraith> they don't share package databases, though.  You need to install packages you're using for each version of GHC using that package.
13:24:53 <monochrom> for best results, use ./configure --prefix=/usr/local/ghc-7.6.3 or the like
13:25:05 <monochrom> then play with PATH
13:29:33 * hackagebot arithmoi 0.4.1.3 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.1.3 (CarterSchonwald)
13:34:47 <sailorswift> Is stack recommended to use yet, or is it still too early in its beta?
13:35:32 <Haskellfant> sailorswift: I'm happily using it (but I don't use haskell at work, so it's not critical)
13:36:06 <Haskellfant> whether it's recommended depends on who you ask :)
13:36:14 <breadmonster> sailorswift: What's stack?
13:36:17 <sailorswift> awesome, thank you :)
13:36:29 <Haskellfant> breadmonster: https://github.com/commercialhaskell/stack
13:37:00 <lyxia> The new cabal
13:37:11 <Haskellfant> *cabal-install
13:37:26 <lyxia> right
13:37:38 <Haskellfant> also it's not the new cabal-install, but a replacement for it being written by different people
13:37:49 <Haskellfant> sorry for being pedantic, but I'd like to avoid confusion
13:38:12 <sailorswift> for a more detailed reading on Haskellfant's points: https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal
13:48:43 <osfameron> gah, people are still writing websites with grey on white text?
13:48:46 * osfameron kills the web
13:50:05 <drewbert> osfameron: #333 or bust
13:53:22 <ERerer> damn.
13:54:00 <monochrom> osfameron: would you like white text on grey background instead? :)
13:55:11 <ERerer> haskell is still not as cryptic as perl
13:55:13 <drewbert> We should make more packages and unrelated tools and name them all cabal.
13:55:21 <osfameron> monochrom: hah, good point
13:55:24 <ERerer> $|++;
13:56:14 <ERerer> Do people develop viruses in Haskell>
13:56:19 <ERerer> I'm wondering now
13:56:25 <c_wraith> well, there's acme-php.  Does that count?
13:57:01 <whiteline> ERerer: it'd be difficult to make real malware
13:57:09 <ERerer> whiteline: why?
13:57:23 <mniip> haskell isn't really injection-friendly
13:57:26 <whiteline> and staging the haskell runtime as a second stage would be bloated
13:57:34 <drewbert> ERerer: Viruses tend to be written in low-level languages because most attacks are based on low level vulnerabilities.
13:57:41 <hexagoxel> drewbert: words that are very common in the industry, like heap, stack, branch or shard are very nice alternatives
13:57:42 <ERerer> can't haskell be compiled into a .exe
13:57:45 <ERerer> no interpreter
13:57:52 <ERerer> or is it on par with pp
13:57:56 <mniip> with GHC,
13:57:57 <c_wraith> haskell would be fine as malware like hard drive lockers, though.
13:57:57 <whiteline> ERerer: yes you can do that
13:57:58 <ERerer> or java's pakr
13:58:06 <whiteline> but it would be bloated
13:58:08 <whiteline> and noticeable
13:58:11 <dmwit> carter_cloud: Does arithmoi now support GHC 7.10?
13:58:14 <mniip> all haskell code has to be execuded with a 700KB system called RTS
13:58:15 <monochrom> I find ERerer suspicious for satisfying all three conditions: using webchat; talk about cryptic; talk about virus.
13:58:24 <mniip> which manages memory allocation and garbage collection
13:58:42 <ERerer> monochrom:  ;)
13:58:49 <whiteline> at some point malware needs real homoiconicity and only assembler has that on the machine level
13:58:55 <mniip> ERerer, GHC compiles code to assembly
13:58:58 <whiteline> usually you'd use C + assembler
13:58:59 <mniip> but haskell has a GC
13:59:06 <drewbert> mniip: lighter-weight than java
13:59:07 <Tuplanolla> You can't just cast a pointer into a thing and call it either.
13:59:09 <mniip> which is bundled with the executable
13:59:21 <drewbert> or python executables, for that matter
13:59:24 <whiteline> malware throws around machine code see
13:59:27 <mniip> Tuplanolla, sure can
13:59:34 * hackagebot yesod-table 1.0.0 - HTML tables for Yesod  http://hackage.haskell.org/package/yesod-table-1.0.0 (andrewthad)
13:59:36 <whiteline> and needs to throw itself around
13:59:43 <michaelt> dmwit: oh I just saw a message via github that says yes
13:59:50 <whiteline> that's a bad analogy but it works
13:59:51 <jle`> having a neural network type where every layer's length is in the type has some neat consequences
13:59:55 <Tuplanolla> Perhaps I should've added "effortlessly".
13:59:55 <dmwit> yay
14:00:20 <drewbert> Cabal cabal cabal cabal. Stack cabal stack stack. Cabal stack stack cabal.
14:00:21 <jle`> `Neural 6 '[12,5] 3` as a neural network with 6 input layers, two hidden layers of length 12 and 5, and an output layer of 3
14:00:30 <ERerer> monochrom:  :D
14:00:51 <jle`> it's nice that you can make a Random/Arbitrary instance and generate random neural networks of a given size
14:01:11 <ERerer> mniip: you mean optcodes?
14:01:25 <mniip> ERerer, ?
14:01:29 <whiteline> ERerer: machine code
14:01:35 <drewbert> Hastack. Stackell.  HSStack.  Cabal2.  fpCabal.   
14:01:37 <ERerer> whiteline: yea, optcodes.
14:01:39 <ERerer> :)
14:01:44 <mniip> optcodes isn't a word
14:01:44 <whiteline> opcodes, not optcodes
14:01:46 <ERerer> mniip: you described transpiling
14:01:52 <ERerer> whoops
14:01:53 <ERerer> :p
14:02:05 <mniip> any compiling is a transpiling
14:02:15 <drewbert> optcodes describe which opteration to pertform.
14:02:16 <ERerer> touche.
14:02:28 <ERerer> does haskell support networking?
14:02:30 <whiteline> mniip: yes but malware isn't that complicated yet
14:02:43 <whiteline> sorry, meant Ererer
14:02:43 <mniip> ERerer, opcode is a specific term referring to a part of an instruction
14:02:52 <dmwit> ERerer: Perhaps you could ask a less boolean-blind question.
14:03:01 <mniip> the thing you're looking for is "machine code"
14:03:09 <mniip> GHC compiles code to machine code
14:03:14 <mniip> actualy cpu instructions
14:03:21 <ERerer> yea
14:03:24 <mniip> but
14:03:33 <whiteline> ERerer: not sure if i can explain to you why you just can't write real malware in Haskell without also explaining to you, say, the low-level architecture of UNIX
14:03:35 <mniip> that machine code is packed with the RTS
14:03:36 <ERerer> lets not get into semantics 
14:03:52 <whiteline> it's not logistically feasible to inject a haskell runtime to manage a rootkit for exampe
14:03:54 <ERerer> whiteline: wat
14:03:57 <ERerer> whiteline: ok
14:04:03 <ERerer> you realize malware doesn't have to infect.
14:04:06 <whiteline> even if you write the hooks in machine code
14:04:08 <dmwit> ?yow!
14:04:08 <lambdabot> Is something VIOLENT going to happen to a GARBAGE CAN?
14:04:11 <tmtwd> how do I import the Random module?
14:04:27 <bernalex> tmtwd: import System.Random
14:04:29 <whiteline> ERerer: all real malware does yeah, for rootkit functionality at the very least
14:04:31 <monochrom> tmtwd: its name has changed to "System.Random"
14:04:35 <whiteline> and disabling antivirus
14:04:39 <ERerer> whiteline: not all "real" malware
14:04:52 <mniip> ERerer, what does it do instead
14:05:00 <ERerer> mniip: depends on the functionality.
14:05:03 <whiteline> ERerer: a simple RAT wouldn't need it
14:05:03 <tmtwd>     Could not find module `System.Random', it says
14:05:10 <dmwit> tmtwd: cabal install random
14:05:17 <ERerer> lets say I was writing malware, I wouldn't infect any files.
14:05:18 <whiteline> everything else would
14:05:30 <bernalex> tmtwd: install random.
14:05:35 <monochrom> I am now ordering you to move this malware discussion elsewhere. I don't care where. preferrably not somewhere I can see.
14:05:38 <mniip> we're not talking about infection are we
14:05:41 <mniip> rather, injection
14:05:44 <tmtwd> ah, I thought it was a core library
14:05:45 <tmtwd> thanks
14:05:53 <ERerer> That would make the AV flip. I'd instead create a hollow proccess and pretend to be a different service
14:06:00 --- mode: ChanServ set +o monochrom
14:06:13 <whiteline> ERerer: think less infecting files and more about patching memory and injecting code into, say, an antivirus program to disable checks
14:06:14 --- mode: monochrom set +q ERerer!*@*
14:06:17 <michaelt> tmtwd: I think it's in the haskell platform but it isn't a boot library or whatever they call it, that comes with gh
14:06:20 <michaelt> ghc
14:06:22 <monochrom> I am now ordering you to move this malware discussion elsewhere. I don't care where. preferrably not somewhere I can see.
14:06:25 <whiteline> ERerer: that's not how it works
14:07:10 <Tuplanolla> Can't we learn us a Haskell for great evil?
14:07:16 <mniip> tl;dr: someone who knows nothing about haskell or, in fact, malware, tries to convince us it's possible to write viruses in haskell
14:07:44 <lolwut> Hello! How do I generate this code: [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1),(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)] ?
14:07:51 <lolwut> Currently I have [(c `f` a, r `g` (invert a)) | c <- [6], r <- [2], f <- [(+), (-)], g <- [(+), (-)], a <- [1, 2]]
14:07:56 <lolwut> Where invert switches 1 to 2 and 2 to 1
14:08:01 <lolwut> I want to find an applicative way to write very generic permutations
14:08:58 <mniip> lolwut, permutations =<< [(+), (-)] <*> [1, 2]
14:09:20 <mniip> oops
14:09:55 * michaelt is trying to perceive a pattern match in @monochrom
14:10:32 <mniip> hmm it should be working why is it not working
14:10:33 <dmwit> lolwut: I know a SO question you might like. One moment.
14:10:58 <mniip> lolwut, concat $ permutations $ [(+), (-)] <*> [1, 2]
14:11:00 <dmwit> lolwut: http://stackoverflow.com/q/21321372/791604
14:11:02 <sccrstud92_> (,) <$> ((c+) <$> [2,-2,1,-1]) <*> ((r+) <$> [1, -1])
14:11:12 --- mode: monochrom set -q ERerer!*@*
14:11:14 <sccrstud92_> > (,) <$> ((c+) <$> [2,-2,1,-1]) <*> ((r+) <$> [1, -1])
14:11:15 <lambdabot>  [(c + 2,r + 1),(c + 2,r + negate 1),(c + negate 2,r + 1),(c + negate 2,r + n...
14:11:33 <sccrstud92_> > (,) <$> ((c+) <$> [2,-2,1,-1]) <*> ((r+) <$> [-1, 1])
14:11:34 <lambdabot>  [(c + 2,r + negate 1),(c + 2,r + 1),(c + negate 2,r + negate 1),(c + negate ...
14:11:52 <sccrstud92_> there ya go
14:11:56 <mniip> sccrstud92_, where's (c+1, r+2)
14:12:14 <carter_cloud> dmwit: it should.
14:12:16 <lolwut> sccrstud92_: the list is permutation of possible moves for knight on chessboard
14:12:19 <sccrstud92_> oops didnt see
14:12:25 <sccrstud92_> > (,) <$> ((c+) <$> [2,-2,1,-1]) <*> ((r+) <$> [-1, 1, -2, 2])
14:12:27 <Etern> I have no idea what's gong on with my web client.
14:12:27 <lambdabot>  [(c + 2,r + negate 1),(c + 2,r + 1),(c + 2,r + negate 2),(c + 2,r + 2),(c + ...
14:12:32 --- mode: monochrom set -o monochrom
14:12:41 <sccrstud92_> ah okay
14:12:47 <sccrstud92_> mine doesnt work for that then
14:13:23 <sccrstud92_> you can filter the ones where the abs values of the fst and snd are the same
14:13:32 <Tuplanolla> How about symmetry operators that can be applied to the movement of any piece, lolwut?
14:13:46 <arkeet> > [(a,b) | a <- [-2..2], b <- [-2..2], a^2+b^2 == 5]
14:13:48 <lambdabot>  [(-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1)]
14:13:51 <sccrstud92_> > filter (uncurry (/=) . abs *** abs) $ (,) <$> ((c+) <$> [2,-2,1,-1]) <*> ((r+) <$> [-1, 1, -2, 2])
14:13:52 <lambdabot>      Couldn't match type ‘(a0, a0)’ with ‘Expr’
14:13:52 <lambdabot>      Expected type: Expr -> Bool
14:13:52 <lambdabot>        Actual type: (a0, a0) -> Bool
14:14:02 <Etern> where is haskell used in the real world?
14:14:04 <Etern> I'm curious.
14:14:24 <Etern> It's not like COBOL where it's cemented to one task only.
14:14:32 <sccrstud92_> arkeet: then map (c+) ** (r+) over it
14:14:41 <arkeet> or just use (c+a,r+b)
14:14:45 <Tuplanolla> Something you could use like this, lolwut: reflections . rotations $ Move 1 2
14:14:58 <sccrstud92_> same thing right?
14:15:47 <michaelt> Etern: a number of places of course; recently there has been much talk about the Facebook use of it
14:16:07 <Etern> michaelt: facebook uses Haskell now?!
14:16:15 <Cale> Etern: you might find this partial list interesting: https://wiki.haskell.org/Haskell_in_industry
14:16:35 <Etern> "ABN AMRO is an international bank "
14:16:42 <Etern> Of course Haskell is going to replace Cobol.
14:16:55 <michaelt> Etern: yeah, they have a couple of the really really top flight haskell writers
14:16:56 <Cale> Etern: Facebook hired Simon Marlow even
14:17:03 <Cale> (one of the main developers of GHC)
14:17:14 <Etern> Haskell is a confusing language to me
14:17:27 <drewbert> Etern: You're not alone.
14:17:29 <Etern> but some snippets I've read make perfect sense.
14:17:36 <Etern> it's like reading lua
14:18:09 <Cale> Etern: Well, it's really different from most of the other languages used in industry, as opposed to being yet another reskin of another existing language.
14:18:54 <michaelt> Etern: more interestingly in the Facebook case, if I understand it, there is a number of people who are not haskell adepts and long-time cognoscenti who are using the material Marlow et al. cooked up.
14:19:13 <Cale> Most of the languages which are popular are pretty similar to one another, so you might get used to being able to pick a new one up in a couple of weeks, but Haskell is definitely not like that, it's more like learning to program from the beginning again. I would say it's worth the trouble though :)
14:19:49 <michaelt> that is, people have internally been 'converted' to using haskell in some of their work
14:20:10 <drewbert> C# took me about an hour to be able to use.
14:20:18 <drewbert> Haskell... six months and counting.
14:20:59 <Tuplanolla> I'd say C is an exception there.
14:21:01 <Etern> Java is 4 months
14:21:02 <hiptobecubic> drewbert, if you know an algol-like OOP-y language, C# is very familiar
14:21:03 <tmtwd> is there a quick code line I can check in ghci that Random is loaded?
14:21:06 <Etern> Python was 10 hours.
14:21:14 <Etern> Autoit is still a WIP
14:21:22 <Tuplanolla> People have massive difficulties with undefined behavior.
14:21:32 <arkeet> > ([first,second] <*> [id,negate]) <*> map ($ (1,2)) [id,swap]
14:21:34 <lambdabot>  [(1,2),(2,1),(-1,2),(-2,1),(1,2),(2,1),(1,-2),(2,-1)]
14:21:45 <monochrom> both Pascal and Haskell took me just hours to use
14:22:03 <Etern> pascal and delphi disgust me.
14:22:10 <mniip> > (take 4 . iterate (swap . fmap negate)) =<< [id, swap] <*> [(1, 2)]
14:22:11 <hiptobecubic> drewbert, in that case, learning haskell is more like learning japanese as an english speaker. Whereas c# is maybe spanish.
14:22:12 <lambdabot>  [(1,2),(-2,1),(-1,-2),(2,-1),(2,1),(-1,2),(-2,-1),(1,-2)]
14:22:19 <arkeet> mniip: :-)
14:22:33 <michaelt> tmtwd: randomIO :: IO Int
14:22:53 <mniip> >:(
14:23:09 <monochrom> my http://www.vex.net/~trebla/haskell/prerequisite.xhtml may help you start faster by managing your expectation
14:23:09 <drewbert> hiptobecubic: C# when you know Java is like learning how to fake an English accent when you speak American english.
14:23:56 <monochrom> Haskell is emphatically not a language in which you write one line and the computer does one thing for that line
14:24:25 <monochrom> not always, anyway
14:24:32 <drewbert> As a computer engineer used to thinking about things at the hardware level, moving away from that way of thinking is easier said than done.
14:24:44 <mniip> let's not forget this
14:24:45 <mniip> > zip [-2, -1, 1, 2, 2, 1, -1, -2] [-1, -2, -2, -1, 1, 2, 2, 1]
14:24:46 <lambdabot>  [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]
14:24:53 <hiptobecubic> drewbert, ok sure. Same argument
14:24:55 <monochrom> whereas C, Python, Logo all are
14:24:57 <freeman42> ghc/stack related question, maybe someone might be able to help: http://stackoverflow.com/q/31194891/750216
14:25:37 <monochrom> so if your idea of programming languages is "I issue a command, the computer does it", then C, Python, and Logo will fit your idea, but Haskell is going to defy you.
14:25:43 <hiptobecubic> drewbert, Haskell is a different approach. Things are done entirely differently and many things that used to be completely braindead are now the best way to do it. It's normal to feel like you have no idea what you're doing in such an environment
14:28:00 <arkeet> > (\f g h -> f g (h (1,2))) <$> [first,second] <*> [id,negate] <*> [id,swap]
14:28:01 <glguy> > [ over l (*2) (x,y) | [x,y] <- replicateM 2 [-1,1], l <- [_1, _2]]
14:28:01 <lambdabot>  [(1,2),(2,1),(-1,2),(-2,1),(1,2),(2,1),(1,-2),(2,-1)]
14:28:02 <Cale> Eh, you can eventually get a pretty good idea of how Haskell is implemented in terms of the machine, but it's not something that you necessarily care about a whole lot of the time, and there's a lot of free choice in how it's done, and that's a good thing.
14:28:03 <lambdabot>  [(-2,-1),(-1,-2),(-2,1),(-1,2),(2,-1),(1,-2),(2,1),(1,2)]
14:28:03 <michaelt> drewbert: I can attest that it helps never having previously learned a programming language; then you're like: go figure, I didn't know that a computer could understand me if I just define my terms. 
14:28:25 <arkeet> glguy: nice
14:28:26 <Cale> I highly recommend reading this paper http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
14:28:50 <Cale> that is, if you're interested in how one might implement Haskell's evaluation mechanism at a lower level
14:29:41 <JagaJaga> What is `_1`?
14:29:53 <michaelt> the lens on the first element of a pair
14:29:55 <JagaJaga> :t _1
14:29:56 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
14:30:17 <JagaJaga> Thought so, but I thought lambdabot do not know lens :)
14:30:22 <arkeet> > [ f (*2) (x,y) | [x,y] <- replicateM 2 [-1,1], f <- [first,second] ]
14:30:23 <mniip> monochrom, that is a great article thing
14:30:25 <lambdabot>  [(-2,-1),(-1,-2),(-2,1),(-1,2),(2,-1),(1,-2),(2,1),(1,2)]
14:30:33 <Cale> But I don't actually think this is even necessarily the best way to look at things if you're interested in understanding the operational behaviour of your Haskell programs (and things like time and space performance) -- most of the time, imagining expression trees or graphs successively being rewritten according to rules is more than a good enough approximation to understand.
14:30:34 <michaelt> > (10,"a") ^. _1 
14:30:36 <lambdabot>  10
14:30:43 <JagaJaga> michaelt: yeah, ty
14:31:19 <michaelt> JagaJaga: oh, yeah, it's had some large body of it for some it seems to me
14:32:22 <michaelt> it could do with a few other things like that, like elementary bits of parsec for example
14:34:35 * hackagebot language-c-quote 0.10.2.3 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.2.3 (GeoffreyMainland)
14:36:34 <michaelt> with the applicative and alternative instruments, satisfy , string, char and some pure runParser would make a lot of things possible
14:43:20 <lolwut> Thanks you guys, everyone
14:45:08 <freeman42> is there a place where GHC keeps build error log files?
14:54:59 <michaelt> freeman42: do you mean when you are building indirectly with cabal 
14:55:29 <freeman42> michaelt, with haskell stack tool, related to: http://stackoverflow.com/q/31194891/750216
14:57:42 <michaelt> freeman42: hm, does stack have an option like --verbose=3 or the like? 
14:58:13 <freeman42> michaelt, it does, but it does not seem to affect the ghc/gcc error details
14:59:18 <michaelt> freeman42: yes, that's a little indirect, hm
15:00:16 <drewbert> I'm deep into a large commercial website written primarily using Yesod, so I'm well attuned to what all of you are saying.  But the indirectness of haskell makes me uncomfortable every step of the way.  
15:01:15 <freeman42> indirectness?
15:03:45 <michaelt> freeman42: I just meant that the error message is not coming directly from stack or even from ghc
15:04:02 <drewbert> freeman42: see the above conversation.
15:04:37 <michaelt> freeman42: no, it is coming from ghc.exe somehow
15:05:23 <edwardk> drewbert: it took me a couple of years after i found haskell to stop panicking about everything the hardware level, then a couple years more to start panicking about it again in the right situations
15:05:51 <drewbert> edwardk: are you the edward that wrote the lens library?
15:05:57 <geekosaur> the error message is from ghc.exe, it thinks that gcc.exe is in some particular place but it is not there
15:05:57 <edwardk> yes
15:06:23 <drewbert> edwardk: wow cool.  Well I'm glad I'm not alone and in such good company.
15:06:44 <geekosaur> (gcc is used for things like cpp and the FFI, and may be invoked for linking rather than know details of how to link in the platform standard libraries)
15:06:59 <edwardk> drewbert: when i found haskell i was obsessed with lock-free data structures, took me a few years to get around to needing them here
15:07:04 <geekosaur> ...and in fact it looks like the link phase is what is failing
15:09:18 <michaelt> freeman42: does C:\Users\Razvan\AppData\Local\Programs\stack\i386-windows\ghc-7.8.4\lib/../mingw/bin/gcc.exe actually exist? 
15:14:33 <geekosaur> looking at the stack bug report, that looks like some kind of internal plumbing issue with gcc.exe (presumably a wrapper) -> realgcc.exe
15:15:52 <michaelt> I see, there is maybe some impediment to giving orders to gcc  that way
15:17:06 <freeman42> michaelt, yes, the path exists, althought I'm not sure that stack/ghc/gcc might be able to read it, as it is mixed unix/windows path and also including up one level
15:17:33 <sccrstud92> edwardk: do you know how many packages you have up on hackage? I have tried looking through github a couple times and on hackage, but i cant find a number
15:17:38 <sccrstud92> last i heard was 150+
15:19:09 <michaelt> freeman42: is geekosaur reading your bug report ?
15:19:14 <edwardk> on github? i have ~205 on my own account and commit access to probably 40 others between organizations, etc.
15:19:21 <edwardk> on hackage? a lot less
15:19:24 <geekosaur> ...?
15:19:25 <edwardk> probably closer to 50
15:19:46 <edwardk> i'd have to look to see what the public count is, because i can't see that easily
15:19:59 <freeman42> michaelt, I don't know
15:20:15 <edwardk> i do know that once i crossed 100 repos github became really unreliable about emailing me stuff
15:20:21 <michaelt> geekosaur: oh you said something about a stack bug report.
15:20:26 <geekosaur> (I should note that I'm at the limit of what I can figure out about it without a Windows environment + minghc. no Windows here and already running in a VM)
15:20:52 <edwardk> actually it looks like 100+ from various organizations
15:20:54 <geekosaur> michaelt, the SO question links to a bug report
15:21:05 <edwardk> gah, i think i may slightly have over committed myself ;)
15:21:45 <geekosaur> I scanned that and found: realgcc.exe: CreateProcess: No such file or directory
15:21:56 <michaelt> geekosaur: oh, sorry I missed that.
15:21:59 <geekosaur> which is where I run out of clue
15:22:41 <edwardk> sccrstud92: http://hackage.haskell.org/user/EdwardKmett <- you can line count your way through that i guess
15:22:52 <geekosaur> in particular, is that gcc failing to run realgcc, or is it realgcc failing to run one of the compiler passes (e.g. cc1)?
15:23:16 <edwardk> 119 matches for the word 'Maintainers' on that page, so i'd say that thats the count
15:23:17 <freeman42> mistery is why other executable parts of the cabal file build (exe files generated), but it fails on that one
15:23:21 <geekosaur> (well, more likely either ld.exe or link.exe, but I have no clue which...)
15:23:27 <sccrstud92> edwardk:119
15:23:35 <sccrstud92> oh u already did it
15:23:39 <sccrstud92> yeah
15:23:59 <edwardk> ok, so its up a bit from the last time i looked
15:24:19 <geekosaur> freeman42, one thing that seems to come up a lot is that Windows has a low maximum command length limit, and it might be that only that link line is hitting it
15:24:38 * hackagebot uri-bytestring 0.1.6 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.1.6 (MichaelXavier)
15:24:43 <geekosaur> once it filters down through stack -> ghc -> gcc -> realgcc -> link
15:25:37 <freeman42> geekosaur, command lenght limit? the path length is around 255 characters, never heard of a command length limit
15:26:00 <geekosaur> in ancient days it was 127 characters. I don't know what limit modern Windows has
15:26:00 <NemesisD> how long does it take for hackage's index to update?
15:26:20 <freeman42> geekosaur, around 255
15:26:29 <geekosaur> (not path, command line)
15:27:10 <geekosaur> but I do mean ancient there; the 127 limit was DOS 2, inherited from CP/M where it was part of the .COM page 0 block >.>
15:27:34 <freeman42> geekosaur, "On computers running Microsoft Windows XP or later, the maximum length of the string that you can use at the command prompt is 8191 characters. On computers running Microsoft Windows 2000 or Windows NT 4.0, the maximum length of the string that you can use at the command prompt is 2047 characters."
15:29:52 <freeman42> geekosaur, any thoughts on "why other executable parts of the cabal file build (exe files generated), but it fails on that one" ?
15:30:32 <dreamdust> wow it is reeeaaally painful having to write javascript after learning haskell
15:30:34 <geekosaur> [02 22:23] <geekosaur> freeman42, one thing that seems to come up a lot is that Windows has a low maximum command length limit, and it might be that only that link line is hitting it
15:30:53 <Tuplanolla> Have you heard of Elm, dreamdust?
15:31:02 <geekosaur> in particualr if that is linking together a bunch of previously built libraries, it's going to have a significantly larger link command line
15:32:05 <dreamdust> Tuplanolla: Yeah, if it was a new project that needed to be in JS i'd use ghcjs or faye or purescript or elm or something. Unfortunately that's not the case
15:32:28 <Tuplanolla> Uh oh.
15:32:43 <geekosaur> and yes, overshooting 8k is not unlikely, on Linux the limit used to be 150Kish and even higher now, and ghc devs are mostly on Linux and have little ability to test on Windows so ghc may well be building link commands that are far too long once gcc adds its stuff in
15:32:53 <sccrstud92> the worst thing about Elm for me is no typeclasses
15:33:00 <freeman42> geekosaur, entire command is around 372 characters, so it should be ok
15:33:02 <sccrstud92> i would miss them to much i think
15:33:11 <geekosaur> the command you see is that short
15:33:41 <geekosaur> the resulting link command, with references to all the libraries plus references to the C runtime libraries added by gcc, etc, is MUCH larger
15:34:16 <Tuplanolla> Luckily type classes are easy to imitate.
15:34:18 <_m_ryan> hi can anyone help me about my problem: http://lpaste.net/135712. it's a yesod esqueleto prob. 
15:34:22 <geekosaur> (but you'd have to arrange to ghave ghc pass -v to gcc in order to see it)
15:34:24 <freeman42> geekosaur, I understand, wish I'd know how to find out more info about that
15:34:39 * hackagebot language-c-quote 0.11 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.11 (GeoffreyMainland)
15:37:27 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
15:37:27 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
15:37:27 --- names: list (clog tristanp refefer warboy brettwea_ innertracks Deadhandd lukexi _m_ryan Mon_Ouie Cigla plucas slomo m3ga Rotaerk sailorswift vmeson Jesin stevegt_ warbo hellertime bramgg jaen Literphor dp_wiz structuralist malllle eyck kurt21 shaleh tommd MultiPurposeHat cow-orker centrinia grizwako sccrstud92 acln twanvl Hugehead arborist dreams chuzz enaqx delphinas MrScout cj3kim frodwith jetho thelision skeet70 zcourts yfeldblum P1RATEZ dan_f kjanosz sobaken)
15:37:27 --- names: list (timidtrap erikd JagaJaga DNoved1 path[l] hjulle Lokathor Freefood_ muzzle glguy dreixel dsfox1 ThatOtherPerson raichoo michaelt mariothemad auscompgeek1 adam_hardkey_shi argent0 jabesed Kron SCHAAP137 tabemann amiri silver_ etandel EvanR NeverDie amnn zacts benjamingr sohum sea-gull predator117 Denommus StoneToad razvanc87 frangor hzjd emlow ahlias emilypi thetallguy ens_ osa1 Reiser rossm mada pavonia hiroaki kgee Dynasty blue_deref fishythefish ph88 ronh)
15:37:27 --- names: list (chpatrick1 freeman42 dot_asp turtil `^_^v tomh- lkba_ yqt Tuplanolla Noldorin LordBrain gfixler jinblack OmnipotentEntity goodacre-liam whaletechno abrar fizbin godel Zanzare elementalest mendez ceii eacameron Fran__ n0n3such jordanl Azel l3dx erisco aartamonau nodeworm nuncanada bucaran Geekingfrog cite-reader Swizec ousado_ Paradisee dvlwrk geekosaur cursork Welkin lritter Ralith tusj bobvh creichert renekooi Philonous t7 thimoteus pixelfog jlamothe_)
15:37:27 --- names: list (MindlessDrone SrPx dlt_ Svedrin trism davidfetter {AS} dgorbik prkc yusukesuzuki adek obadz zaquest timemage AndreyG brotknust_ A205B064 joco42 Wuzzy oconnore2 sivoais ixti stoopkid mpw junmin Coldblackice zinfandel jergason latro`a_ L8D martingale niko crobbins marchelzo_ peterson vin-ivar pavlicek theorbtwo pimlu conal cyborg-one CapitalSigma FreeFull ps-auxw uzu mkster littlebluedana jang ndrei gienah LordDeath c_wraith minominomeen RegEchse colt44)
15:37:27 --- names: list (_ashbreeze_ naeluh dwins rootnode unsymbol harski jomg eatman emma Freundlich Natch thelastinuit kosorith cyphase nshepperd plutoniix sdothum godlesschild sepp2k Guest51201 codyopel nkartashov Skyres Carisius marr canta seanparsons m0rphism cnf prophile fnordbert SoupEvil wuch heurist` cpup dibblego pacak tristero japesinator fionnan mrowe_away nilg hvr ybian M32 caumeslasal lodin_ freusque xificurC fengshaun chirpsalot Chobbes Stratege dustinm johtso)
15:37:27 --- names: list (tgeeky citizen11 CMCDragonkai s00pcan Fay kyren otto_s fling beauby solatis calvinx Internet13 infinity0 Eiam alleco dolio sw1nn shadowcreator xahry dqd dsantiago Boney betawaffle idafyaid exferenceBot lspitzner hexagoxel brotknust przembot andrewsw bgamari bgamari_ Enigmagic thesignal ReinH nak dented42 uber lf94 timothyh saurik hiredman mikeizbicki wjm [swift] Cale falafel AustinMatherne yakutori teclo- staffehn hugeInt aupiff mauke themasterchef esssing)
15:37:27 --- names: list (gnusosa armyriad Deadhand Sgeo_ mitchty psy_ srcerer r0tha rofer lancetw ckw killtheliterate mniip kakos marko_ Paprikachu LnL sleblanc alanz rul codile alekst_ psacrifice arahael3 Boreeas SuperTux88 dstockwell dlackty___ timloh cstrahan spdionis jlyndon jonrh runeks Orwell84 lambdabot nyuszika7h moplove_ cic torpig Tritlo GGMethos Polarina flebron zymurgy bjorkintosh nathanic Encapsulation sternenseemann gbiv eazar001 chuy bz jkarni1 ezrios lsep ubitux)
15:37:27 --- names: list (RGamma kqr kalz NemesisD certainty Erebe iyzsong keko_ ring0` moop [[derek]] rbocquet ChristianS happy0 Nickeeh bb010g dpn` kav fergusnoble zpconn__________ stbuehler Zekka Jellydog helgar kvalle Xorlev lpaste Jaxan goodacre_liam AntiSpamMeta da-x haasn besenwesen benwf conehead pharaun cin_ lahwran spindas zimbatm ircbrows- peddie Rastus_Vernon spion netj_ Twey nekomune mak` Jo-haN alang DANtheBEASTman benonsoftware sunfun- davesilva rabisg taksuyu)
15:37:27 --- names: list (shwouchk_ anachron vikram___ joeyh_ kirjs________ aaronweiss74 fall__ alevy- cmn_ OliPicard sephiap tazjin korpse_ ThePhoeron Heero trig-ger_ zero7 abbe mt xnyhps ec\_ Jonno_FTW liff phaazon dlundy_ scopedTV_ tedkorni1h tomphreek Guest59196 zerokarmaleft tismith_ Saizan Maxdamantus zyoung_ pfoetche1 dowski larocca_ tomasos_ Baughn_ zomg dropdriv1 Tehnix_ optocoupler jlind_ hc_ hongminh1e joshc_ JPohlmann dawik_ lyxia jimki_ lassulus keaml _klm roo AWhetter_)
15:37:27 --- names: list (simon supki lokodo Schrostfutz_ avdi rslima samertm Blkt_ KeelOfSteel ryantm nrw deavidsedice lacrosse yrashk S11001001 sabauma ilmig_ sdx32 aaronm04 padre_angolano M-ou-se ozataman_ themagician_d orbital_ sLite jbalint gridaphobe cow_2001 ellinokon bernalex rcsgns Nimatek yorick ollef Dan39 cheater cdidd_ FireFly darkbolt whiteline jaseemabid_ CurryWurst spaceships RazorX ikke alexlord jroesch bsummer4 juri_ buoto Moggle mountaingoat lusory MK_FG Oxyd)
15:37:27 --- names: list (hackagebot mceier gdoteof pii4 EvilPeng1 statusbot augur novice perrier shirt hamishmack RayNbow`TU hattusili_III wagle zeiris owa xelxebar CodyReichert verement robogoat ninja-maid-robot frontendloader |f`-`|f avocado `micro thomie jedai42 dmiles_afk Jorgon Ankhers SparkySparkyBoom lpsmith hemite narendraj9 spwhitt xxpor crlane Ptival isomorphismes AshyIsMe eddsteel rola kaictl Johannes13 jud MoALTz__ Draggor 32NAB9792 constantinexvi ft Jello_Raptor stiell)
15:37:27 --- names: list (BeardedCoder atomi tromp_ avn dedgrant_ darkowlzz|afk julm aidanh mpereira greves mgomezch quicksilver mlen dmwit Guest27737 maerwald bergey aaronlevin tpsinnem codahale sinopeus_ kwantam Lemmih jo__ haBuu_ paf31 melter paperManu adamse twoolie noplamodo h4nnibal otulp permagreen maurer robbert fikusz tdammers Draconx drbean_ larxy Tourist abra0 meteo dgonyeo saulzar pikhq ahungry skulls pw_ carc zhulikas tomku fluffykeyboardfu hiratara Pamelloes blue_feint)
15:37:27 --- names: list (tnks MasseR jrib meretrix gws aweinstock Tesseraction dgvncsz0f MitchW opqdonut phaskell asjo serutsubi martinhath ij _flow_ ashleyis Rutger` voltz Pennth Myrl-oneechan chpatrick manfoo7 neki araujo luzie Ornedan sbrg nominolo|work dschoepe chandankumar pii nkpart Thra11 jmcarthur mgaare HylianSavior derpvid lala PlasmaStar MrWoohoo Laquendi hanDerPeder negatratoron pfeyz shiona nurupo thalassa DrAwesomeClaws mlamari adnap brezel ajf sevcsik Vbitz liveify)
15:37:27 --- names: list (jamiis dhrosa niklasb Wamanuz Qfwfq Sonderblade cods Xack Voldenet DT_sama elben rossberg ajp Diabolik catsup newsham boxfire tomboy64 u-ou David amiller mhb benbangert eL_Bart0 chris2 Khisanth WelpAnon rdema C4Cypher Or1 djh davean qnikst kvieta soija myfreeweb flaiw sweater1 ctag stass subleq ixian sujeet kidnapped_robot hausdorff demolithion mathu doctorin1 cpa dwoos ClaudiusMaximus agjohnst nathan7 AlexStraunoff lokulin lykkin poga naudiz Soft kloeri)
15:37:27 --- names: list (nullvoid8 larsen_ tomasos__ nwf recycle`` Desoxy ipuustin MelodyKH3 Tril DanZimm mrsolow mirsal Nik05 joneshf-laptop mmaruseacph2 xeno bitonic sclv ghorn otterdam _fritz_ aloiscochard myst|work hiberno stelleg Laney drmegahertz MarcelineVQ gniourf albel727 cryon jokester dtulig anders^^ Saimeidae wto illiux jb55 segmond felixsch TimWolla max-m hbar andrewalker levitation[A] nmenne Kruppe ew0 gds Artpicre f_x lyonsb ryankarason Paks earthy bjoernb jorj)
15:37:27 --- names: list (CosmicRay KrzyStar ma82 hx_ Sorella arch_ Brando753 ninegrid akuhlens neptunepink tg Plastefuchs k1i sbauer322 nemesit|znc spacebug __main__ fryguybob levi d-snp Hijiri folsen shadowdaemon sm SLi Sigyn averell henryhere WSergio funrep Razz huonw fugyk Cr8 itsmonktastic ski dh ubuntor Liskni_si gratimax pieter mach reqq456 flux zyla hator hpd marienz kaw_ tridactyla bsmt pharpend vikraman cschneid xaimus Xe scpike edwardk wting jaffachief s1n4 noteventime)
15:37:27 --- names: list (nicola eevar_ ido sku1d bananagram troydm pyrtsa kriztw edk emmanueloga ]OLI[ akahn condy Forkk therealklanni ElderFain tomleo killerpty wrengr_away Adios honza andyo mudphone rhaps0dy PinealGlandOptic Bigcheese milli acfoltzer rudi_s drewdavis hegge arkeet pingu saep julienXX samgd peterhil` cbm80 ScRaMbLe seliopou mietek electrogeek cameronfr ephemeron cross grol mpickering jakutis Hugglesworth Sagi ljhms obcode petantik geal alpounet fold bbee sokoll)
15:37:27 --- names: list (andreass bydo s4msung EnergyCoffee ruukasu mjrosenb tsani thomas liyang Phlogistique absence jtobin petercommand mitu phadej DustyDingo chardan BrianHV _di ricardo82 suvash_away greymalkin dicioccio1 Guest70208 drone| dju Klumben drdo Tiktalik wizzo skarn_ ocharles_ theDon biscarch wolf_moz- cjwelborn AlainODea SegFaultAX sdboyer rom1504 Jaak solarus Pucilowski_ Gothmog_ valdyn integral_ coyotebush_ Walther c9sould__ callumacrae osnr Zemyla tv sunnymilk)
15:37:27 --- names: list (tumdedum platz reynir tych0 rs0 kalloc dcoutts rseymour djanatyn martinbmadsen noddy kriwil jaspervd1 Igloo gseitz Athas derekv2 suls kini klarrt gdsx_ adarqui jix_ lokydor_ senseibaka rtl XMunkki_ ParahSailin_ loz-- proq ChongLi krgn brackets wizonesolutions mindos_cloud____ idnar Cerise mbrcknl ehamberg stasku jrp6 pgorla mankyKitty prosodyContext Raynos bkolera srid SwashBuckla pchiusano Fuuzetsu mystor sleepynate milessabin wenzowski seancorfield)
15:37:27 --- names: list (Haskellfant si14 shennyg arnihermann ggherdov arcanine jfokkan dkua hellschreiber doppioslash Dykam_ gabiruh_ Phillemann peterood kmicu zrl yminsky RageD caasihuang chriswk lohkey hoey_ tero- mikedanese joedevivo thoughtpolice bcavalier maw CindyLinz yac mechairo` steinar_ Spockz bgyss sweenzor flx ziman cjh` JonasH__ JamesJRH pranzor surtn alphonse23__ taruti MMuse_______ yukonjack technomad radens chelfi _rgn mrb_bk kess ackthet kaste fractalcat lieven)
15:37:27 --- names: list (kjnilsson KaneTW seabre kanak cojy Kneiva saiam brolin_empey yeltzooo xandaros R0b0t1 eyenx dabradley karls RevJohnnyHealey jrslepak pm51 Belgarion0 dzack module000 corso wayne ice799 SaidinWoT foolie solirc kgadek bshelden chishiki unknownloner rj-code jnoah oberstein Elsi bergmark elgot somenick Factionwars statusfailed apo_ Dtgr sagelywizard Guest83834 brent80_plow kloplop321 tolt Guest75051 koomi numberten ggreg_ brennie_ barrucadu c-rog mikeplus32)
15:37:27 --- names: list (bitemyapp RlyDontKnow dunj4 Ezku_ hsyl20 capisce amontez_ pmade swistak35_ cscorley hpc joehillen rossimo_ Profpatsch anoe epta z16 wtw mads- keemyb eyem brixen ion buttproblem andjjj23 Deewiant stomp tomjaguarpaw bob_twinkles felixn hrnz Atlanis yarou GaveUp Guest90609 igniting zxtx natte mero vpm eamelink_ irclogger_com ahihi Watcher7_ malglim ThreeOfEight znutar_ sys9mm_ lachenmayer grohne_ BlakeRain TallerGhostWalt schlumpi_ abh fall` kipras sebastard)
15:37:27 --- names: list (fmapE_ cjay BillyIII_ cynick mami gargawel stvc joeytwiddle_ Tene kragniz kaol nopf Lutin_ jcp int-e heath Th0mas_ edran zeroskillor TDJACR puzza007 lvh bigs tsyesika ivan\ bcarrell tzaeru shelling__ Dodek zph anttih Taneb _6a68 otherchas_ osfameron noctux carter_cloud IbnFirnas Intensity fuziontech pdxleif Uritomi2 annulus sellout notdan mno2 sajith endojelly friden carter heyj adimit sys andreypopp edwtjo gpampara eikke asm89 koala_man liste luite Cathy)
15:37:27 --- names: list (lamilami zq reem mrd rieper_ orzo_ jackhill zso Clint kyubiko Ian750 nitrix lispy KorriX etrepum tlevine iross nbouscal moy phuu DigitalKiwi CARAM__ dixie_ tarcwynne aaron7 glowcoil n1ftyn8 ephess comboy knyppeldynan lstrano eagleflo vodkaInferno Drezil dredozub- low-profile LeaChim_ blenny marens_ diginet jmct bjornars hodapp Sornaensis steshaw lambdahands tuv jacksnipe_ jameseb _Tristan-Speccy_ Birch tekacs xplat Fubar^ `0660 aupo_ zenzike_ _ikke_ dario`)
15:37:27 --- names: list (sakirious qz metaf5 mattp_ gbarboza klugez froztbyte Adeon notOnIRC derekbrown jvd thomassgn thorsten` lattenwald lyddonb bartavelle Guest15425 Chousuke_ runde jarvi_ irishsul1an Mandus_ jlewis tswett alem0lars quaestor2 monty dino- nisstyre mjo xxx pleiosaur Vq jbhatta pygospa s_e eivuokko bjobjo woffs erg monsieurp tomaw posco Axman6 iDavid aristid burp_ thebnq tessier orbekk fr33domlover agrif jle` PotatoGim fyolnish seagreen shachaf SHODAN mephx ggVGc)
15:37:27 --- names: list (obiwahn monochrom heaumer nille drewbert boris`` Eagle_Erwin tumdum flori ByronJohnson einojo mimi_vx hive-mind ernst JZTech101 e4x_ PHO benzrf erethon iteratee oherrala tinchos dxld frawgie jlouis Ulrar bonobo_ j0llyr0tten guampa Hafydd bcoppens srhb sunnavy joehh karshan uwap TRManderson dreamdust Bane^ Guest23257 so hyPiRion relrod aleator inr banjiewen alynn machineslearn defanor ahf d3lxa gsingh93 jpiche janne kosmikus etabot mortberg dmilith)
15:37:27 --- names: list (OutlawStar magicman oceliot dilinger mrshoe mokus DenSchub greeny davl_ kandinski KitC Fylwind linduxed dexterph ibid dewdrop ndeine michaelpj_ myme arianvp Eliel jstolarek Reyu oconnore deni lenstr @ChanServ Starfire Ke Rembane Eldrad cYmen_ niluje jayne bolmar shapr sgronblo y vladan arw)
15:37:29 <warboy> so this a new programming language? 
15:37:30 <warboy> wow
15:37:36 <sccrstud92> what is?
15:38:07 <warboy> haskell
15:38:14 <Tuplanolla> It's 1990 new.
15:38:19 <sccrstud92> about 25 years
15:38:21 <warboy> OMG.. 
15:38:21 <fishythefish> Only 25 years old!
15:38:34 <warboy> LOL I wan't aware of it
15:38:52 <sccrstud92> well today is the first day of the rest of your programming life
15:39:14 <warboy> I just started coding so it's a bit new to me
15:39:21 <fishythefish> Welcome!
15:39:39 <sccrstud92> what language have you been using?
15:39:40 <warboy> hahaha.. sure. I'll start with haskell soon.
15:39:49 <warboy> C and python 
15:39:57 <sccrstud92> well welcome
15:40:01 <warboy> got some hands on JAVA too
15:40:25 <warboy> Thank you. I have to study about haskell now. 
15:41:05 <warboy> Just one question. How hastell is better than python or other programming languages?
15:41:31 <Tuplanolla> Just fine. Thanks for asking.
15:41:38 <fishythefish> oh boy
15:41:52 <mauke> warboy: its type system
15:41:59 <sccrstud92> there is probably a good one that compares haskell and python
15:42:06 <sccrstud92> a good article that is
15:42:07 <michaelt> warboy: Yes.
15:42:09 <fishythefish> or several :P
15:42:10 <sccrstud92> let me see if i can find it
15:42:16 <dreamdust> warboy: The type system and purity allows you to reason concretely about your program rather than guess at certain functionality.
15:42:16 <sccrstud92> i dont doubt it
15:42:17 <erisco> warboy, sum types, laziness, syntax
15:42:22 <fishythefish> type system and referential transparency
15:42:25 <warboy> Yeah sure. Thanks in advance :D
15:42:30 <fishythefish> and all the other stuff above
15:42:41 <sccrstud92> if he just started coding he might not know all these terms
15:42:53 <warboy> laziness - just took me :P
15:43:05 <fishythefish> Yeah, but then it's kind of a hard question to answer without experiencing the pains of other languages.
15:43:10 <erisco> this or that, compute it later, and what the code looks like
15:43:18 <warboy> I can relate some terms. But I will try to cope up with you guys :)
15:43:37 <michaelt> warboy: the miracle is that the compiler makes this dream world actually work.
15:43:37 <Cale> warboy: It is nonetheless fairly new as far as what ideas have gone into it. There's a sense in which, e.g. languages like golang are really quite old.
15:43:59 <fishythefish> warboy, a lot of this will make more sense once you've coded in both languages and experienced the differences yourself.
15:44:23 <warboy> Now I understand. I'll try haskell too. 
15:44:42 <warboy> I'll be active here. Nice to have you guys around. :)
15:44:43 <sccrstud92> is there any language newer than haskell that is more popular than haskell by some reasonable metric?
15:44:51 <sccrstud92> ask anytime
15:44:58 <erisco> sccrstud92, a lot of languages qualify I think
15:44:59 <michaelt> python is newer
15:45:03 <fishythefish> ^
15:45:11 <sccrstud92> i didnt realize python was so new
15:45:20 <warboy> Python is getting a lot of attention these days. 
15:45:34 <michaelt> where do you think they got list comprehension (which admittedly predate haskell)
15:45:46 <tnks> sccrstud92: these can feel like arbitrary comparisons; why do you ask?
15:45:54 <fishythefish> JavaScript counts too, right?
15:45:58 <fishythefish> 95, I think.
15:46:00 <verement> Ruby is newer
15:46:04 <mauke> perl5?
15:46:09 <sccrstud92> tnks: what comparisons?
15:46:15 <mauke> swift
15:46:17 <Guest15512> Rust is newer
15:46:21 <tnks> sccrstud92: popularity relative to age
15:46:45 <mauke> C#
15:46:49 <tnks> kind of like swinging the lever on a visualization, but not seeing a clear correlation on anything.
15:47:43 <sccrstud92> tnks: well, really new programming languages are expected to not be very popular simply because they are new. same with really old outdated ones. so i would guess there is some sort of relationship between the two. doesnt seem arbitrary to me
15:48:07 <sccrstud92> tnks: do you think there is not relationship between the two?
15:48:15 <dreamdust> Many new ones are implementations of old and implemented conceptions.
15:48:31 <dreamdust> There is nothing conceptually new in Go or Python for example.
15:48:35 <tnks> sccrstud92: right, but that's just a dynamic for one language. . . comparing them relatively to one another is a different dynamic.
15:49:11 <sccrstud92> tnks: okay
15:49:14 <tnks> different languages find niches, some bigger than others.
15:49:25 <sccrstud92> some burn fast and hot
15:49:28 <tnks> and age doesn't always have much to do there.
15:49:29 <sccrstud92> some low and slow
15:49:36 <tnks> I think you're misunderstanding.
15:49:43 <warboy> yeah. they have advantages on one and other over different areas/
15:49:46 <sccrstud92> someone is
15:50:05 <tnks> the language's age is not the driving factor.
15:50:08 <tnks> it can be marketing.
15:50:22 <tnks> or a void being filled.
15:50:30 <tnks> or just a cultural oddity.
15:50:31 <sccrstud92> if it was the driving factor, then what i asked wouldnt be very interesting
15:50:55 <tnks> Python existed for a while before the Enthought folk pushed it farther into the scientific computing domain.
15:51:02 <sccrstud92> exactly
15:51:05 <sccrstud92> thats interesting
15:51:18 <sccrstud92> even though its not very old, its still very popular
15:51:31 <tnks> sccrstud92: right, but that's because of these odd social dynamics.
15:51:48 <sccrstud92> i didnt make any judgements about why
15:52:06 <tnks> I'm just saying that age isn't really much of a predictor, so far as I can tell.
15:52:18 <michaelt> Wow simon p j actually read my module. I can go to my grave now...
15:53:01 <jle`> congrats michaelt :p
15:53:16 <drewbert> Offering nothing new is a actually a very attractive feature for a programming language to have.
15:53:25 <sccrstud92> michaelt: if you go to ur grave who will maintain ur module?
15:53:50 <jle`> the less a language offers new, the more successful it seems to be
15:53:54 <sccrstud92> drewbert: if you offer nothing new, are you really a new programming language?
15:54:01 <sccrstud92> like
15:54:06 <michaelt> sccrstud92: no it was some minimalizing for a bug on the trac ...
15:54:06 <drewbert> sccrstud92: absolutely 
15:54:08 <jle`> *the less new things a language offers
15:54:13 <sccrstud92> do new combinations of features count, if the individual features are not new?
15:54:28 <drewbert> sccrstud92: also absolutely 
15:55:08 <tnks> attraction is a pretty weird metric too. . . marketing can make things attractive
15:55:16 <sccrstud92> then i dont see how a programming language that offers nothing new can be different from one that already existed
15:55:18 <tnks> as can celebrity programmers
15:55:39 <tnks> and this is complicated hugely by false attribution.
15:56:56 <tnks> sccrstud92: sometimes all that's new is a little syntax, or a compilation target. . . something important, but subtle from the language author's perspective.
15:57:13 <michaelt> there should be an 'example needs minimalization' flag on the trac system; it would suit my dubious skill set.
15:57:22 <tnks> if it's incompatible with everything else. . . it's new.
15:57:53 <sccrstud92> tnks: i dont doubt that small new things can have a disproportionate impact. but i still think nothing new will have 0 impact
15:58:14 <drewbert> tnks: we're getting a bit off topic
15:58:22 <tnks> drewbert: yeah, I'm going to back off.
16:02:07 <sccrstud92> ill take partial responsibility for that
16:02:42 <tnks> sccrstud92: I believe you can take off-topic stuff to #haskell-blah
16:02:51 <sccrstud92> yup
16:03:07 <L8D> @hoogle Either Void a -> a
16:03:08 <lambdabot> Warning: Unknown type Void
16:03:08 <lambdabot> Data.Either rights :: [Either a b] -> [b]
16:03:08 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
16:03:45 <L8D> is there some way I can write a function from Either <some uninhabited type> a -> a
16:03:59 <michaelt> L8D: either absurd id
16:04:03 <sccrstud92> ^
16:04:11 <L8D> :t absurd
16:04:12 <lambdabot> Not in scope: ‘absurd’
16:04:19 <sccrstud92> its in Data.Void i think
16:04:19 <michaelt> L8D: oh this is your own type?
16:04:30 <sailorswift> Building a lightweight snake game, should I just use OpenGL bindings or something like Gloss?
16:04:36 <L8D> michaelt: I mean I just don't know how to work with uninhabited types
16:04:47 <L8D> or if Haskell supports them properly anyways
16:04:49 <sccrstud92> sailorswift: gloss is probably easier
16:05:00 <sccrstud92> absurd :: Void -> a
16:05:17 <michaelt> L8D: well, what do you want a to be if you get "Left _'?
16:05:35 <L8D> michaelt: Left undefined should fail like undefined
16:05:53 <sccrstud92> you can do either undefined id then
16:06:11 <michaelt> either (const (error "void doesn't exist")) id
16:06:12 <sccrstud92> or even
16:06:27 <sccrstud92> something like ^ that
16:07:10 <L8D> ok thanks
16:07:31 <jle`> :t either undefined id
16:07:32 <lambdabot> Either a c -> c
16:07:37 <jle`> hehe
16:07:54 <jle`> :t either (error "void doesn't exist") id     -- works too
16:07:55 <lambdabot> Either a c -> c
16:11:23 <eitanChatav> Hello, does anyone know of examples with build instructions for calling Haskell from Rust via their respective FFIs?
16:12:40 <tommd> Is there really any complexity beyond exporting the haskell functions as a ccall then making Rust FFI bindings?
16:13:22 <doomlord> whats driving you to use that combination of languages
16:13:31 <doomlord> just curious
16:13:39 <doomlord> not saying its' a bad thing
16:14:19 <eitanChatav> My company is using Haskell for big data algorithm stuff and Rust for infrastructure stuff
16:14:48 <doomlord> oh wow, commercial use of haskell *and rust*
16:14:50 <eitanChatav> tommd: I wouldn't have thought there'd be any more complexity but I can't seem to get it to work
16:15:00 <eitanChatav> :-D
16:15:16 <mpickering> eitanChatav: https://github.com/aisamanra/rust-haskell-ffi ?
16:15:29 <eitanChatav> mpickering: that's the reverse of what I want
16:15:40 <mpickering> oh right sorry
16:15:53 <eitanChatav> no worries :-)
16:17:12 <Guest35200> Using attoparsec, how would I construct a parser that acts like manyTill, but doesn't throw away the end condition, but instead returns a tuple? So the type would look like: Alternative f => f a -> f b -> f (b,[a])
16:18:01 <adamse> eitanChatav: you can call Haskell from C, maybe it is possible to use the Rust C ffi to call Haskell the same way as you would call haskell from c
16:18:29 <eitanChatav> adamse: It should be possible but I keep running into linking problems for some reason
16:19:11 <eitanChatav> I was hoping to find an example somewhere of someone who accomplished haskell-from-rust that I could build off of
16:20:17 <adamse> eitanChatav: ah, then I'm afraid I know nothing more :)
16:21:01 <eitanChatav> thanks anyway!
16:22:08 <adamse> eitanChatav: sounds like an awesome job though :)
16:22:59 <eitanChatav> it is pretty dope
16:23:14 <eitanChatav> here's the company: gettyritter@gmail.com
16:23:16 <eitanChatav> oops
16:23:20 <eitanChatav> ignore that
16:23:35 <eitanChatav> here's the company: http://leapyear.io/
16:23:42 <tnks> hPark.html]
16:23:42 <tnks> 17:59 -!- Topic set by theorbtwo [~theorb@cpc3-swin16-2-0-cust28.3-1.cable.virginm.net] [Tue Jun 30 12:47:11 2015]
16:23:45 <tnks> (sorry)
16:23:47 <tnks> 17:59 [Users #haskell-blah]
16:30:13 <michaelt> the 'point' example in https://github.com/aisamanra/rust-haskell-ffi seems not to cohere with my rustrc, but if I scrap everything but fac.rs it works.
16:30:59 <tmtwd> how do we specify the type of a var when declaring? ie let a = False, would we do let a : Boolean = False or something?
16:32:08 <michaelt> tmtwd: you would usually write a = False :: Boolean 
16:32:56 <michaelt> tmtwd: with ScopedTypeVariables you can write aa (1 :: Int) = 3
16:33:18 <jle`> tmtwd: you can do let a :: Bool; a = False
16:33:37 <tmtwd> oh right
16:33:40 <jle`> i assume this is just a throwaway example though, because a will be inferred as Bool
16:33:44 <jle`> by the compiler
16:33:59 <jle`> s/will/would
16:34:01 <michaelt> Oh I see. jle` has more sense about what's being asked ...
16:34:51 <tmtwd> of course, its a contrived ex
16:37:51 <michaelt> tmtwd: in a sequence of 'statements' you would usually do " n <- readLn :: IO Int ", but with ScopedTypeVariables you can write " n :: Int <- readLn "  This is one pleasing feature
16:41:03 <Guest35200> Using attoparsec, how would I construct a parser that acts like manyTill, but doesn't throw away the end condition, but instead returns a tuple? So the type would look like: Alternative f => f a -> f b -> f (b,[a])
16:41:07 <michaelt> I wonder what became of that proposed extension where something like (:: Int) would be equivalent to asTypeOf (undefined :: Int) 
16:44:05 <michaelt> Guest35200: manyTill p end = scan where scan = (end *> pure []) <|> liftA2 (:) p scan
16:44:19 <michaelt> Guest35200: so you see where it is throwing out 'end'
16:44:28 <Guest35200> yeah
16:45:12 <Guest35200> both parameters of (<|>) need to be the same type
16:45:46 <Guest35200> you see a way to do it?
16:52:15 <michaelt_> Guest35200: sorry I lost contact there. But the mechanical expansion is something like manyTillWithEnd p end = scan where  scan = ((,) <$> end  <*> pure []) <|>  (\b (a,bs) -> (a,b:bs)) <$> p <*> scan
16:53:01 <Guest35200> ah, okay. i was trying somthing along those lines
16:53:03 <Guest35200> thanks
16:53:19 <michaelt_> @type let manyTillWithEnd p end = scan where  scan = ((,) <$> end  <*> pure []) <|>  (\b (a,bs) -> (a,b:bs)) <$> p <*> scan in manyTillWithEnd
16:53:20 <lambdabot> Alternative f => f t -> f a -> f (a, [t])
16:57:55 <citizen11> l/quit
16:57:59 <tmtwd> Im getting an error in this code http://pastebin.com/BHutjYLg 
16:57:59 <tmtwd> graphs.hs:47:52-55:
16:57:59 <tmtwd>     Couldn't match expected type `Coin'
16:57:59 <tmtwd>                 with actual type `a0 -> Either a0 b0'
16:58:16 <tmtwd> anyone can tell me whats wrong?
17:00:31 <nyazdani> tmtwd: on line 12, did you mean if co == Tails?
17:00:45 <tmtwd> sort of?
17:00:58 <tmtwd> why is that different?
17:01:07 <Tuplanolla> You accidentally capitalized left.
17:01:12 <tmtwd> oh
17:01:13 <tmtwd> oops
17:01:14 <jle`> Left is the constructor for Either
17:01:16 <tmtwd> yes Heads
17:01:26 <nyazdani> because your Coin type has constructors for Heads and Tails but not Left and Right
17:01:39 <tmtwd> okay beating my head on the wall now
17:01:43 <nyazdani> oh okay i see what you meant to do
17:01:56 <jle`> the error should make it clear-ish :)
17:01:58 <tmtwd> thanks
17:02:05 <osa1> did you know that DeriveAnyClass and GeneraliezdNewtypeDeriving don't work well together?
17:02:19 <osa1> if I enable DeriveAnyClass suddenly I can't derive some instances for newtypes anymore
17:02:23 <jle`> it says, "can't match Left with Coin"
17:02:26 <jle`> mor or less
17:02:34 <osa1> or is this a bug?
17:02:42 <jle`> or "expected Coin but got (some function) in "Left""
17:03:28 <drewbert> What is lowercase left?
17:03:45 <drewbert> oh part of the tree, derp
17:05:20 <michaelt_> Guest35200: it's more readable with MonadComprehensions enabled:  scan p end =  [(e,[]) | e <- end] <|> [(e,b:bs) | b <- p , (e,bs) <- scan p end]
17:07:01 <Guest35200> slightly more readable ; )
17:07:13 <Guest35200> o
17:07:18 <Guest35200> actually its much better
17:07:21 <michaelt_> yeah, okay ... 
17:07:59 <Guest35200> for some reason I initially saw it as a nested monad comprehension, which confused me
17:08:05 <michaelt_> I'm not sure I mentioned it, it's just somehow more graphical to me
17:14:45 * hackagebot network-info 0.2.0.7 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2.0.7 (JacobStanley)
17:19:45 * hackagebot html-email-validate 0.2.0.0 - Validating an email address against HTML standard  http://hackage.haskell.org/package/html-email-validate-0.2.0.0 (zudov)
17:26:47 <jle`> it'd be nice if we could use threepenny-gui with diagrams
17:30:34 <Cale> jle`: Is there some reason we can't?
17:30:48 <jle`> i mean if there was seamless integration built into threepenny-gui
17:30:49 <Cale> jle`: Or you just mean, if there were a threepenny-specific backend?
17:30:54 <Cale> ah, yeah
17:30:55 <jle`> yeah, that's what i mean
17:31:00 <jle`> well, it looks like threepenny outputs svg
17:31:07 <jle`> so you can just have it export svg and drop svg into the html
17:31:16 <jle`> but it'd be nice to have like, canvas support
17:35:02 <Cale> There actually are two backends for diagrams that already use canvas. I've been procrastinating writing a third which would use Javascript FFI directly (requiring GHCJS)
17:37:27 <adas> I used the "pack" function in Data.ByteString.Char8. I did `let m = singleton '官'` and then did `length m`. length is only 1. But isn't '官' a multibyte character?
17:38:32 <arkeet> adas: it's because you're using Char8.
17:38:48 <arkeet> which only keeps the lower 8 bits.
17:39:00 <adas> arkeet: and discards the remaining bits?
17:39:03 <arkeet> yep
17:39:04 <Cale> yep
17:39:27 <Cale> It's totally unsuitable for unicode anything. You should use Data.Text if you want unicode packed strings
17:40:20 <arkeet> and then you can encodeUtf8 or something else to get a properly encoded bytestring out of it.
17:40:34 <jle`> yeah, Data.ByteString.Char8 is a bad idea in almost every imaginable circumstance
17:40:40 <arkeet> basically, don't use Char8
17:41:23 <adas> Is there a way to work with bytestrings but be able to get all the bytes out of a unicode character? 
17:41:35 <adas> in any case, ill check out text as well
17:41:48 <jle`> text is meant for text
17:42:05 <jle`> bytestring is meant for a string of "meaningless" bytes
17:42:38 <jle`> it's kind of like, if you have a function Int -> Int -> Int, you should use Int, not [()]
17:43:03 <jle`> even though you could interpret an [()] as an integer, it's probably a good idea to actually use the type with the interface of integers :)
17:43:16 <jle`> that understands what an integer is, etc.
17:43:17 <arkeet> adas: as I said, if you want to encode unicode text with bytestrings, you need to encode it somehow.
17:43:43 <jle`> anybody know a good place i can find a heatmap function
17:43:45 <arkeet> https://hackage.haskell.org/package/text-1.2.1.1/docs/Data-Text-Encoding.html
17:43:48 <jle`> some sort of Double -> Color function?
17:45:27 <sccrstud92> jle`: if you find a good one post it please
17:45:42 <adas> thanks for the suggestions. I think ill go with Data.Text
17:45:52 <hiptobecubic> Someone, i think maybe it was dons? made a post or an article about the importance of compilers and how many programs are really just some kind of domain specific compiler. Does anyone happen to remember seeing such a thing?
17:46:25 <jle`> i'm sure i could whip one out by doing some HSV interpolation etc., but it would be nice if there was a quick function i could drp in somewhere v.v
17:47:35 <arkeet> jle`: you know about the colour package?
17:49:32 <jle`> oh, i remember using it a year back
17:49:45 <jle`> maybe i should look there
17:50:05 <jle`> sweet thanks arkeet 
17:50:33 <hpc> jle`: another thing you could do is make the function yourself in any editor
17:50:48 <hpc> and then apply it to a grayscale map with imagemagick or something
17:51:12 <arkeet> lookup tables are nice
17:51:16 <hpc> (any image editor - it'd be a 1x256 png)
17:51:28 <jle`> ah yeah, i could just lookup function too
17:51:31 <jle`> hm, thanks
17:52:05 <hpc> probably not imagemagick if a haskell solution exists, but i haven't looked at image manipulation in quite some time now
18:03:59 <tedkorni1h> Do experienced haskellers consider `error` to be idiomatic in pure code? When is it acceptable and when is it ill-advised?
18:04:47 * hackagebot deterministic-game-engine 0.1.0.0 - Simple deterministic game engine  http://hackage.haskell.org/package/deterministic-game-engine-0.1.0.0 (tgolson)
18:05:17 <johnw> the problem with "error" is that its behavior is not represented in the type of that function
18:06:06 <tedkorni1h> Right - which is why it seems like you'd almost always want to use pure error handling methods through the Maybe or Either monads
18:06:22 <nitrix> tedkorni1h: In my experience, error's job is to stop execution. See it as a fatal unrecoverable thing, not as a way to handle computations that may fail.
18:07:02 <tedkorni1h> nitrix: gotcha, that makes a lot of sense. So it should almost never show up in library code, then?
18:07:54 <nitrix> tedkorni1h: Here's an example:     head [] = error "You tried to get the first element of an empty list, silly. What have you done."
18:08:42 <johnw> tedkorni1h: avoid it, as much as possible
18:08:57 <nitrix> tedkorni1h: The type signature of head being :: [a] -> a,  it's obligated to return an `a`, but it cannot. It's a unrecoverable error.
18:12:38 <nitrix> tedkorni1h: In fact, a safer version of 'head' could be to use the Maybe monad, which actually exist and is called 'headMay' :: [a] -> Maybe a
18:12:48 <nitrix> tedkorni1h: Hope it helps :)
18:13:49 <tedkorni1h> nitrix: definitely does - I was just doing some reading on different error handling methods and grepping around some haskell codebases and wondering why one would use `error` when purer solutions exist.
18:14:14 <tedkorni1h> Your explanation makes a good deal of sense - use it when there's no other choice, because the application cannot possibly proceed. Thanks for the explanation!
18:14:32 <nitrix> Although, at that point I'd really blame the user for using a library and 'Maybe' for this, when all that's really needed is pattern matching.
18:14:59 <tedkorni1h> Seems to me that if purity was a big concern for a programmer, you could always wrap `error`-invoking functions in a typesafe wrapper, returning something like a `Maybe a` for `head`
18:15:15 <tedkorni1h> Yeah, haha, agreed. Seems like it's not too hard to avoid using error.
18:15:20 <johnw> tedkorni1h: you may be interested in https://github.com/jwiegley/newartisans/blob/master/pending/2015-01-23-exceptions-and-type-safety.org
18:15:26 <nitrix> It's very common for haskell functions to match different list patterns, and to use the empty list, [], as the short-circuiting step in the case where a function is recursive.
18:15:38 <tedkorni1h> It seems problematic as a design pattern, especially for larger codebases, because it circumvents normal control flow.
18:15:40 <nitrix> tedkorni1h: I'm sure those have name, but I too am fairly new to this.
18:17:01 <nitrix> Edge condition. There you go.
18:18:09 <tedkorni1h> johnw: thanks, I really enjoyed reading that. A choice quote: "And so, exceptions are appropriate when the exceptional case is nothing that your program can respond to: if, had you used Either, the result would have been to simply propagate the Left value all the way back to the operating system anyway."
18:18:55 <nitrix> tedkorni1h: :)
18:23:42 <exo___> howdy all
18:25:13 * dmwit waves
18:25:31 <sccrstud92_> hi
18:25:32 <johnw> tedkorni1h: another way to say it is that types should always be total, though programs are not.  So, if the error is from your function, use Either/Maybe; but if the error is from your program, then exceptions are fine
18:26:00 <johnw> one communicates to other callers, the other to the OS
18:26:49 <johnw> in that case, exception handling is a safety net, a way of treating sub-components of your program as sub-programs; but not as a general error handling startegy
18:29:58 <erisco> is there any reason inet_addr from Network.Socket has to go to IO?
18:30:04 <erisco> :t inet_addr
18:30:05 <lambdabot> Not in scope: ‘inet_addr’
18:30:12 <erisco> @hoogle inet_addr
18:30:12 <lambdabot> Network.Socket inet_addr :: String -> IO HostAddress
18:30:32 <johnw> erisco: maybe because it wraps a C function?
18:30:32 <tedkorni1h> Yep, that makes sense - your article states that handing an exception back up to the OS is like giving the OS a `Left`; I feel like that analogy does a great job describing how a Haskell program has types within and types without.
18:30:36 <ttt_fff> suyppose I have StrictMap Text Int ... and I want to look at all entires where the Int is > 5, and change the value to 6. In SQL, this is like "Select * where i > 5 ; update i = 6" ...  ... now, in Haskell, is there a way to store "location to the data" ... so I can then, at a later point, update it?
18:30:39 <erisco> johnw, hm, perhaps
18:30:53 <tedkorni1h> But for something long-running which doesn't talk the OS, like a web server, you would want to keep types solely within the program.
18:30:56 <erisco> issue I am having is that optparse-applicative seems to require you to make argument parser with ReadM
18:31:12 <tedkorni1h> "talk to the OS" as in return a meaningful status code
18:31:13 <erisco> but I cannot convert something IO to ReadM
18:31:14 <erisco> afaik
18:31:28 <johnw> erisco: ah
18:31:54 <johnw> erisco: inet_addr calls withSocketsDo
18:31:59 <johnw> which means that it might initialize the socket subsystem
18:32:15 <erisco> it is doing this to parse an IP address?
18:32:19 <erisco> an IPv4 address?
18:32:29 <sccrstud92_> ttt_fff: Map.map (\x -> if x > 5 then 6 else x) myMap
18:32:35 <johnw> yes, because it calls c_inet_addr, and doesn't know if that C function needs initialization or not
18:32:42 <johnw> see the implementation of inet_addr
18:32:52 <ttt_fff> sccrstud92_: hmm, is there a more generay way to do this "SQL-like-queries" ?
18:32:53 <sccrstud92_> ttt_fff:might have a nbame wrong
18:33:14 <erisco> johnw, maybe I should just parse the IPv4 address in another way
18:33:14 <ttt_fff> sccrstud92_: in this case, you had to 'manually fuse' the SELECT+Update condition
18:33:23 <erisco> is there any significant reason to need IO?
18:33:27 <johnw> erisco: I find it hard to believe someone hasn't written that in Haskell yet
18:33:53 <sccrstud92_> ttt_fff: you could write one
18:34:06 <sccrstud92_> i cant think of one for Maps off the top of my head
18:34:13 <ttt_fff> so the goal is to 'lazily sore all the select/updates ... then feed it to Map.map" ?
18:35:10 <sccrstud92_> ttt_fff: are you asking me what your goal is?
18:35:15 <sccrstud92_> im not following
18:35:33 <ttt_fff> no
18:35:37 <ttt_fff> let me re-think my intentions
18:35:42 <ttt_fff> sccrstud92_: this discussion has been helpful, thanks!
18:36:26 <erisco> johnw, it also seems that this is the only way to make a custom ReadM
18:36:28 <sccrstud92_> youre welcome
18:36:29 <erisco> @hoogle eitherReader
18:36:29 <lambdabot> No results found
18:36:35 <erisco> eitherReader :: (String -> Either String a) -> ReadM a
18:36:45 <erisco> which I find a bit odd
18:37:02 <johnw> erisco: ReadM is just a type wrapper around a ReaderT
18:37:08 <johnw> ReaderT String (Except ParseError) a
18:37:11 <erisco> a newtype
18:37:14 <johnw> so you can always build one of those however you like
18:37:18 <erisco> it isn't just an alias
18:37:25 <johnw> i meant a newtype wrapper
18:37:37 <erisco> I don't have access to the ReadM constructor
18:37:52 <johnw> what version of optparse-applicative?
18:38:01 <johnw> import Options.Applicative.Types
18:38:14 <johnw> it's being exported from that module in 0.11.0.2
18:38:25 <erisco> 0.11.02
18:38:57 <erisco> hm
18:39:04 <erisco> if you start up ghci does it use the local sandbox?
18:39:09 <erisco> or do you have to tell it something special?
18:39:16 <johnw> I don't know
18:39:21 <johnw> maybe "cabal ghci"?
18:39:30 <Hijiri> there's cabal repl
18:39:33 <Hijiri> or cabal exec ghci
18:39:43 <tedkorni1h> or `stack ghci`, if you're using stack
18:40:18 <erisco> Hijiri, hm, command prompt is unhappy with that
18:41:12 <Hijiri> what does it say?
18:41:51 <erisco> cabal.exe: unrecognised command: exec (try --help)
18:42:15 <geekosaur> ancient cabal-install
18:43:12 <sccrstud92_> erisco: run
18:43:17 <sccrstud92_> cabal --version
18:43:30 <erisco> cabal-install version 1.18.0.5
18:43:31 <sccrstud92_> u probably have 1.18?
18:43:33 <sccrstud92_> yeah
18:43:41 <erisco> if I try to upgrade it wants to reinstall a million packages
18:44:00 <sccrstud92_> people are trying stack nowadays
18:44:08 <sccrstud92_> you could give tht a shot if you want
18:44:13 <erisco> ehh
18:44:16 <erisco> this project uses cabal though
18:50:21 <mpickering> ghci --package-db .cabal-sandbox/x86...
18:50:55 <mpickering> erisco: ^
18:53:31 <erisco> this is a mess :D
18:53:35 <erisco> what about ghc-pkg
18:53:40 <erisco> how do you get it to use a sandbox oO
18:54:17 <mpickering> ghc-pkg --package-db .cabal-sandbox/x86...
18:56:11 <erisco> I don't know how but the entire sandbox is broken
18:56:23 <erisco> cabal wants to change a million packages
18:56:26 <erisco> breaking others
18:56:31 <erisco> if I try to remove the ones which will break
18:56:36 <erisco> there are a million dependencies
18:56:38 * erisco sighs
18:56:47 <erisco> looks like another 30 minutes to build a new sandbox
18:57:36 <erisco> may as well try to force reinstalls I guess
18:58:11 <appl1212> > (reverse . reverse ) "hello"
18:58:12 <lambdabot>  "hello"
18:59:05 <erisco> > fmap (reverse . return) "hello"
18:59:07 <lambdabot>  ["h","e","l","l","o"]
18:59:17 <erisco> > concatMap (reverse . return) "hello"
18:59:18 <lambdabot>  "hello"
18:59:21 <erisco> my crazy machine
19:00:24 <erisco> > foldr (:) [] "hello"
19:00:27 <lambdabot>  "hello"
19:01:04 <dramforever> @@ @free @type foldr (:) []
19:01:05 <lambdabot>  Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
19:01:43 <benzrf> @type foldr (:) []
19:01:44 <lambdabot> Foldable t => t a -> [a]
19:01:49 <benzrf> dmwit: rekt
19:01:52 <benzrf> * dramforever
19:01:54 <benzrf> :|
19:01:58 <benzrf> :t Data.List.foldr
19:01:59 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:02:02 <benzrf> huh
19:02:23 <sccrstud92_> is there a way to play with the lenses made from makeLenses in ghci?
19:02:26 <erisco> it is more abstract brah
19:02:45 <johnw> erisco: I only count 8051 packages on Hackage
19:03:01 <erisco> johnw, did you include every version?
19:03:14 <johnw> why would cabal rebuild every version?
19:03:18 <sccrstud92_> nvrm....
19:03:41 <erisco> johnw, sorry I didn't realize I had to give a sensible argument
19:10:00 <nitrix> johnw: Are you _the_ John Wick ?
19:10:09 <johnw> no, Wick is not my last name
19:10:14 <nitrix> :(
19:11:49 <nitrix> Today I learned that fmap could also lift functions (as well as what lifting means).
19:11:59 <appl1212> > :t return
19:12:01 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:12:03 <nitrix> Been using haskell for a couple months now and that part was overlooked. :]
19:12:27 <sccrstud92_> nitrix: when you say "also", what were you using before? liftM?
19:12:52 <dramforever> nitrix: don't worry, later you will understand that lifting is the "true" meaning of fmap
19:13:24 <nitrix> sccrstud92_: Oh no, I mean, there's two ways to see fmap.  :: (a -> b) -> (f a) -> (f b)     AND   :: (a -> b) -> (f a -> f b)
19:13:37 <sccrstud92_> gotcha
19:13:51 <sccrstud92_> :t liftA2
19:13:52 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:13:56 <nitrix> Yeah, I sort of get it at the moment. It's nice to see things connect.
19:14:00 <dramforever> :t zipWith5
19:14:01 <lambdabot> (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
19:14:01 <sccrstud92_> :t liftA3
19:14:02 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
19:14:30 <dramforever> :t zipWith . zipWith . zipWith
19:14:31 <lambdabot> (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
19:14:52 <sccrstud92_> :t fmap fmap fmap fmap fmap
19:14:53 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
19:15:16 <dramforever> so what are we trying to do?
19:15:26 <nitrix> What's the 1 that GHC shows in types?
19:15:36 <dramforever> nitrix: part of the identifier
19:15:41 <sccrstud92_> it needs a type variable that hasnt been used already
19:15:42 <nitrix> When two types collides, the duplicate `a` becomes `aN` ?
19:15:45 <sccrstud92_> a is in use
19:15:48 <dramforever> maybe
19:15:51 <sccrstud92_> so it makes a1 a new one
19:16:02 <dramforever> I think ermine marks them as !a
19:16:33 <nitrix> Couldn't it just pick a new letter?
19:16:42 <nitrix> Or is it because a1 and a will be the same type?
19:17:21 <marchelzo_> no, in that case it would say a
19:17:23 <sccrstud92_> a1 and a will not necessarily be the same type
19:17:37 <sccrstud92_> you will eventually run out of letters
19:17:43 <sccrstud92_> you never run out of numbers =)
19:18:09 <nitrix> Oh, so there's no b1 ?
19:18:15 <dramforever> there is
19:18:28 <dramforever> nitrix: ghc *renames* type variables when unifing
19:18:34 <dramforever> :t zipWith
19:18:35 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:18:39 <appl1212> > t: 9
19:18:40 <lambdabot>      No instance for (Num [Expr]) arising from the literal ‘9’
19:18:40 <lambdabot>      In the second argument of ‘(:)’, namely ‘9’
19:18:40 <lambdabot>      In the expression: t : 9
19:18:42 <dramforever> wait not this one...
19:18:49 <shapr> Is there a smart Haskell editor in the haskell platform?
19:18:52 <appl1212> :t 9
19:18:53 <lambdabot> Num a => a
19:18:59 <shapr> I'd like to have something like IDLE that comes with Python
19:19:00 <sccrstud92_> shapr: i dont think HP somes with one, no
19:19:15 <johnw> any Haskell users in Sacramento, CA?
19:19:15 <sccrstud92_> shapr: isnt IDLE a repl?
19:19:20 <appl1212> :t fmap (reverse . return) "hello"
19:19:21 <lambdabot> [[Char]]
19:19:26 <shapr> hrm, is there a nice simple Haskell editor that does syntax highlighting and all that?
19:19:38 <appl1212> > :t fmap (reverse . return) "hello"
19:19:40 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:19:59 <sccrstud92_> shapr: most people add haskell syntax higlighting and other stuff they want to the editor they already use
19:20:00 <nitrix> appl1212: You keep making the same mistake.
19:20:09 <nitrix> appl1212: :t for type info, > for expressions to evaluate.
19:20:42 <shapr> sccrstud92_: I want to give a Haskell intro, many people attending won't already have an editor of choice
19:20:54 <hiptobecubic> shapr, atom ?
19:21:09 <marchelzo_> shapr: The fpcomplete ide is pretty good.
19:21:29 <shapr> ah, those are both good ideas
19:21:56 <dramforever> emacs looks good enough for small to medium sized stuff to me
19:22:06 <dramforever> no idea on big projects
19:22:15 <nitrix> shapr: I'd strongly recommend fpcomplete to them.
19:24:13 <shapr> dramforever: I've been an emacs user for 15 years, I agree... but for an intro to Haskell talk, that's not what I want
19:24:27 <shapr> Ok, I'll check out the fpcomplete IDE, thanks for the suggestions!
19:24:34 <shapr> hiptobecubic: and I'll try atom if that doesn't work out :-)
19:24:57 <dramforever> shapr: sure, but if you are already familiar with emacs it's pretty neat
19:26:04 <shapr> dramforever: I agree
19:26:18 <shapr> but I'd like to start newbies out with an easy environment
19:26:29 <dramforever> sure
19:26:59 <marchelzo_> shapr: One problem: it appears you need to sign up to use the fpcomplete ide. You can use a google account, and it only takes a second, but I know some people hate that.
19:28:10 <dramforever> marchelzo_: sure, but since it's a web ide it makes sense (at least to me)
19:29:19 <marchelzo_> It certainly makes sense if you're going to develop an actual project, but it would be nice if you could just play around with it without having an account. As far as I can tell, that's not possible (I could be wrong).
19:29:25 <shapr> ok, this is awesome: https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell
19:29:34 <shapr> marchelzo_: hopefully people won't mind
19:31:39 <erisco> can we do a bit better than this Parsec code? http://lpaste.net/135778
19:31:46 <erisco> the regexp is just 1[0-9]?[0-9]?|2[0-5]?[0-5]?|0
19:32:15 <johnw> you can refactor that a LOT
19:32:52 <erisco> whoops, need  1[0-9]?[0-9]?|2[0-5]?[0-5]?|2[0-9]?|0
19:33:30 <dramforever> erisco: in real code you should use a regex matcher, but maybe you are just learning parsec
19:33:53 <dramforever> a regex matcher should(IMO) be waaayyyy faster than parsec
19:34:11 <erisco> well, speed is not important
19:34:20 <erisco> I am just surprised the Parsec version comes out so verbose
19:34:41 <dramforever> erisco: you have a lot of duplicated code
19:34:51 <johnw> it's not Parsec that's the problem in that code
19:35:14 <dramforever> it seems that you are not familiar with parsec combinators
19:35:38 <erisco> enlighten me with the Parsec combinators
19:36:27 <dramforever> 1. string
19:36:45 <dramforever> maybe replace (:[]) <$> char 'x' with string "x"
19:36:57 <dramforever> and \a -> [a] is the same as (:[])
19:37:10 <erisco> I don't care, that isn't so important
19:37:12 <erisco> I'll use string though
19:38:04 <erisco> the 'satisfy' bit is rather verbose
19:38:08 <erisco> though I suppose not much can be done about it
19:38:31 <dramforever> erisco: you can lift that out into a where clause
19:38:47 <erisco> then it'd be nice to collect results using the String monoid
19:39:02 <erisco> dramforever, that doesn't shorten it though, that just moves the bulk elsewhere
19:39:04 <dramforever> where match f = Parsec.option [] ((:[]) <$> Parsec.satisfy f)
19:39:12 <erisco> it does dedupe that one spot but that is easy to do
19:39:40 <sccrstud92_> pure is a bit nicer than (:[])
19:39:43 <sccrstud92_> imo
19:39:43 <dramforever> well you could make 4 "Parsec.option [] ((:[]) <$> ...)"s into one
19:39:46 <erisco> instead of <*> I'd want to collect with the monoid
19:39:57 <erisco> to get rid of the ugly a ++ b ++ c
19:40:21 <dramforever> @hoogle Monoid a, Applicative f => [f a] -> f a
19:40:21 <lambdabot> Parse error:
19:40:21 <lambdabot>   Monoid a, Applicative f => [f a] -> f a
19:40:21 <lambdabot>           ^
19:40:25 <erisco> (Applicative f, Monoid a) => f a -> f a -> f a  I think
19:40:30 <erisco> I can just write that definition
19:40:36 <dramforever> @hoogle (Applicative f, Monoid a) => f a -> f a -> f a  I think
19:40:37 <lambdabot> Warning: Unknown type I
19:40:37 <lambdabot> Data.Functor.Product Pair :: (f a) -> (g a) -> Product f g a
19:40:37 <lambdabot> Control.Monad.Trans.RWS.Lazy runRWS :: RWS r w s a -> r -> s -> (a, s, w)
19:40:47 <benzrf> dramforever:
19:40:53 <sccrstud92_> :t liftA2 mappend
19:40:54 <lambdabot> (Applicative f, Monoid c) => f c -> f c -> f c
19:41:06 <benzrf> :t fmap fold . sequenceA
19:41:07 <lambdabot> (Applicative f, Traversable t, Monoid b) => t (f b) -> f b
19:41:16 <dramforever> benzrf: yep
19:41:47 <dramforever> let (<++>) = fmap fold . sequenceA
19:42:42 <benzrf> hmM
19:43:02 <benzrf> @let newtype ProbablyExists f a = PE {getPE :: f a}
19:43:03 <lambdabot>  Defined.
19:43:08 <sccrstud92_> :t fmap mappend . sequenceA
19:43:09 <lambdabot> (Applicative f, Traversable t, Monoid (t a)) => t (f a) -> f (t a -> t a)
19:43:40 <sccrstud92_> :t fmap mconcat . sequenceA
19:43:41 <lambdabot> (Applicative f, Monoid b) => [f b] -> f b
19:43:51 <benzrf> @let instance (Applicative f, Monoid a) => Monoid (ProbablyExists f a) where mempty = PE (pure mempty); mappend (PE x) (PE y) = PE (liftA2 mappend x y)
19:43:52 <lambdabot>  Defined.
19:44:02 <benzrf> :t ala PE foldMap
19:44:03 <lambdabot> forall (k :: BOX) (f :: k -> *) (a :: k) (t :: * -> *). (Foldable t, Monoid (ProbablyExists f a), Rewrapped (ProbablyExists f a) (ProbablyExists f a), Unwrapped (ProbablyExists f a) ~ f a) => t (Unwrapped (ProbablyExists f a)) -> Unwrapped (ProbablyExists f a)
19:44:07 <benzrf> crap
19:44:08 <sccrstud92_> beautiful
19:44:17 <benzrf> tfw forgot to derive the instance
19:44:18 <erisco> Parsec.option [] ((:[]) <$> Parsec.digit)
19:44:22 <erisco> I'd really like this not to be so awful
19:44:32 <erisco> [] is just mempty, I'd like that to be assumed
19:44:36 <sccrstud92_> use pure instead of square-face
19:44:39 <erisco> and then (:[]) <$> Parsec.digit is unfortunate
19:44:51 <erisco> using pure is irrelevant
19:45:01 <dramforever> hmm, do we have something like optionMaybe?
19:45:01 <sccrstud92_> you dont think it makes it look nicer?
19:45:22 <erisco> dramforever, yeah, but what do I do with it
19:45:38 <sccrstud92_> :t Parsec.option
19:45:40 <lambdabot> Not in scope: ‘Parsec.option’
19:45:43 <dramforever> erisco: there's instance Monoid a => Monoid (Maybe a)
19:45:44 <sccrstud92_> =(
19:45:57 <erisco> > Just "hello " <> Just "world"
19:45:58 <lambdabot>  Just "hello world"
19:46:07 <erisco> hm, nice to know
19:46:13 <erisco> > Just "hello " <|> Just "world"
19:46:14 <lambdabot>  Just "hello "
19:46:24 <erisco> see, that is the inconsistency :P
19:46:28 <benzrf> oh snap
19:46:30 <dramforever> erisco: looks a bit wasteful.....
19:46:33 <benzrf> compose / constant
19:46:48 <sccrstud92_> what is inconsistent?
19:46:58 <benzrf> :t ala Const sequenceA
19:46:59 <lambdabot>     Couldn't match type ‘a' -> Const a' x'’ with ‘Const a'1 (e -> x'1)’
19:47:00 <lambdabot>     Expected type: (Unwrapped (Const a' x') -> Const a' x')
19:47:00 <lambdabot>                    -> e -> Const a'1 x'1
19:47:01 <benzrf> er
19:47:06 <benzrf> :t ala Const traverse
19:47:07 <lambdabot> (Traversable t, Monoid a') => t a' -> Unwrapped (Const a' (t x'))
19:47:08 <erisco> sccrstud92_, Monoid and Alternative ought to behave the same
19:47:10 <benzrf> :-o
19:47:19 <erisco> the problem is that Maybe has multiple correct instances
19:47:21 <dramforever> erisco: actually that instance should have been instance Semigroup a => Monoid (Maybe a)
19:47:38 <benzrf> > ala Const traverse (words "the quick brown fox")
19:47:39 <dramforever> erisco: why they ought to behave the same?
19:47:39 <lambdabot>  "thequickbrownfox"
19:47:39 <sccrstud92_> erisco: according to which laws?
19:47:46 <erisco> sccrstud92_, the monoid laws
19:47:56 <erisco> dramforever, same laws, same concept
19:48:09 <dramforever> no, why do you think so?
19:48:09 <sccrstud92_> erisco: but monoid laws dont say anything about alternative
19:48:16 <erisco> one is for * -> * stuff and the other is for * stuff
19:49:11 <sccrstud92_> erisco: i didnt think there were any laws connecting them?
19:49:19 <benzrf> :t Compose . fmap Const
19:49:20 <lambdabot>     Not in scope: data constructor ‘Compose’
19:49:20 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
19:49:30 <benzrf> @let import Data.Functor.Compose
19:49:31 <lambdabot>  Defined.
19:49:32 <benzrf> :t Compose . fmap Const
19:49:33 <lambdabot> Functor f => f a1 -> Compose f (Const a1) a
19:49:40 <erisco> sccrstud92_, there aren't any laws, there are just scrawlings on some wiki page
19:49:41 <benzrf> :t traverse (Compose . fmap Const)
19:49:42 <lambdabot> (Applicative f, Traversable t, Monoid a) => t (f a) -> Compose f (Const a) (t b)
19:49:56 <erisco> sccrstud92_, the intuition for what they ought to do comes from other sources
19:50:04 <benzrf> :t fmap getConst . getCompose . traverse (Compose . fmap Const)
19:50:05 <lambdabot> (Applicative f, Traversable t, Monoid b) => t (f b) -> f b
19:50:08 <benzrf> =D
19:50:15 <benzrf> ^super optimal
19:50:18 <sccrstud92_> erisco: they intuitively seem fine to me
19:50:40 <benzrf> after all, modulo newtypes it's just traverse
19:50:42 <benzrf> :}
19:50:52 <sccrstud92_> maybe you would prefer the First a monoid instance?
19:51:00 <athan> benzrf: :Q
19:51:17 <benzrf> sccrstud92_: ?
19:51:35 <benzrf> i mean, not traverse... sequenceA
19:51:42 <sccrstud92_> benzrf: talking to erisco
19:51:47 <benzrf> o
19:51:51 <athan> What's the best crypto lib for Haskell?
19:51:52 <sccrstud92_> sorry
19:52:21 <erisco> sccrstud92_, consider Int, and how it does not have a Monoid instance
19:52:23 <Clint> athan: cryptonite?
19:52:32 <erisco> sccrstud92_, this is because there are multiple correct instances
19:52:36 <erisco> and the same goes for Maybe
19:52:51 <sccrstud92_> erisco: of course
19:52:52 <jle`> i wonder if the colour library knows that they spelled color in their module Data.Colour wrong
19:52:57 <sccrstud92_> consider it considered
19:52:58 <athan> Clint: Ahh heck yeah! I knew there was a rencent one that was supposed to be great :) Thanks!!
19:53:01 <erisco> well, that is inconsistent as well
19:53:01 <dramforever> erisco: why there isn't instance Ord a => Ord (Complex a)
19:53:04 <sccrstud92_> erisco: and then?
19:53:05 <dramforever> jle`: lol
19:53:23 <erisco> in one case there are no instances because there are many to choose from
19:53:29 <erisco> in another case one is arbitrarily chosen
19:53:30 <sccrstud92_> dramforever: dont the actual mathematical complex numbers not have a total ordering?
19:53:35 <dramforever> yes
19:53:38 <dramforever> :)
19:53:40 <erisco> and furthermore it works differently for Alternative which is similar
19:53:54 <dramforever> erisco: in idris it's fixed :)
19:55:06 <athan> Clint: Wow this is awesome
19:55:24 <sccrstud92_> > [1,2] <|> [3,4]
19:55:26 <lambdabot>  [1,2,3,4]
19:55:55 <sccrstud92_> we also have MonadPlus
19:56:20 <erisco> sccrstud92_, yes, even more craziness :P
19:56:21 <sccrstud92_> i wonder how much of this stems from the lack of Applicative as superclass of Monad issue
19:56:43 <erisco> sccrstud92_, none
19:56:50 <erisco> MonadPlus is Monad + Alternative
19:56:56 <erisco> and Monad is not a super of Alternative
19:57:09 <erisco> this is just a case of class hierarchy problems
19:57:13 <dramforever> lens-action got much happier with AMP implemented
19:57:16 <dramforever> :)
19:57:20 <sccrstud92_> if MonadPlus is Monad + Alternative, then we dont need it, right?
19:57:33 <dramforever> sccrstud92_: YES!
19:57:35 <erisco> read the woes of OOP especially in games programming and why some devs use entity-component systems
19:57:37 <erisco> for instance
19:58:04 <sccrstud92_> so it sounds like MonadPlus exists because of pre-AMP
19:58:14 <dramforever> exactly
19:58:18 <erisco> sccrstud92_, well you can alias constraints now
19:58:21 <erisco> not sure if that was relevant
19:58:22 <dramforever> oh wait
19:58:42 <dramforever> sccrstud92_: IIRC MonadPlus came before Applicative
19:58:50 <dramforever> *Alternative
20:01:23 <sccrstud92_> @hoogle Traversal' (Vector a) a
20:01:23 <lambdabot> Warning: Unknown type Traversal'
20:01:23 <lambdabot> No results found
20:01:52 <dramforever> sccrstud92_: traversed
20:01:59 <sccrstud92_> :t traversed
20:02:00 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
20:02:13 <dramforever> :t traversed :: Traversal (Vector a) (Vector b) a b
20:02:14 <lambdabot>     Not in scope: type constructor or class ‘Vector’
20:02:15 <lambdabot>     Not in scope: type constructor or class ‘Vector’
20:02:27 <sccrstud92_> =P
20:02:45 <sccrstud92_> i understnad the generic sig well enough
20:02:46 <dramforever> :t traversed :: Traversal (Data.Vector.Vector a) (Data.Vector.Vector b) a b
20:02:47 <lambdabot> Applicative f => (a -> f b) -> Data.Vector.Vector a -> f (Data.Vector.Vector b)
20:02:53 <dramforever> yay!
20:03:02 <sccrstud92_> first try
20:03:25 <sccrstud92_> what module has traversed?
20:03:36 <sccrstud92_> so many names to keep track of
20:03:42 <johnw> it's in the lens package
20:03:48 <dramforever> I thinkData.Lens.Traversal
20:03:50 <sccrstud92_> tranks johnw.....
20:03:59 <sccrstud92_> ill check
20:04:14 <johnw> Control.Lens.Traversal
20:04:15 <dramforever> so far most exotic combinators are from lens....
20:04:17 <johnw> or just import Control.Lens
20:04:22 <dramforever> johnw: oh sure
20:05:15 <sccrstud92_> johnw: i wanted to know so i could read the surrounding documentation
20:05:31 <dramforever> sccrstud92_: use hoogle
20:05:38 <dramforever> traversed +lens
20:05:53 <sccrstud92_> it was in Control.Lens.Traversal
20:05:58 <sccrstud92_> ill use hoogle next time
20:06:06 <sccrstud92_> @hoogle traversed +lens
20:06:06 <lambdabot> Could not find some databases: lens
20:06:06 <lambdabot> Searching in:
20:06:06 <lambdabot>   .
20:06:13 <sccrstud92_> the real hoogle
20:06:35 <johnw> i don't think the "real hoogle" indexes lens
20:06:42 <dramforever> johnw: no
20:06:45 <dramforever> it does
20:06:49 <johnw> oh, nice
20:07:03 <dramforever> traversed +lens
20:08:11 <meretrix> Is there a nicer way to write a "set difference" with list comprehension?
20:08:12 <meretrix> > foldl1 intersect [[x | x <- [1..5], x /= y] | y <- [2,3]]
20:08:14 <lambdabot>  [1,4,5]
20:08:52 <meretrix> (not using `notElem`)
20:14:28 <sccrstud92_> Functor really means covariant functor, right?
20:14:37 <dramforever> yes
20:14:46 <dramforever> and cofunctor is a joke :)
20:14:56 <dramforever> contravariant is the real one
20:15:25 * dramforever is thinking about DeriveContravariant and DeriveProfunctor
20:16:10 <sccrstud92_> DeriveBifunctor?
20:16:19 <sccrstud92_> DeriveBicontravariant?
20:16:23 <sccrstud92_> WHERE DOES IT END
20:16:24 <dramforever> lol maybe
20:16:38 <dramforever> sccrstud92_: it ends at DeriveAnyClass
20:17:07 <sccrstud92_> well that was fast
20:17:43 <dramforever> sccrstud92_: it's a generics thing
20:18:00 <dramforever> IMHO it's waaayyy better than generics in other languages
20:18:09 <sccrstud92_> dramforever: ive heard of it. dont know anything about how it works
20:18:15 <dramforever> except one thing: it's hard to use
20:18:17 <sccrstud92_> generics makes sense though
20:18:27 <dramforever> sccrstud92_: yeah I don't know anything either
20:18:56 <dramforever> well I know how to use libs that use generics to derive instances of my code
20:19:04 <dramforever> *for my code
20:20:52 <nshepperd> how does DeriveAnyClass actually work?
20:21:09 <dramforever> dunno
20:22:34 <sccrstud92_> the ghc team had to sacrifice a developer to an Old God
20:22:50 <sccrstud92_> for access to such arcane knowledge
20:24:44 <sccrstud92_> if i am traversing a nested data structure with lenses
20:25:29 <sccrstud92_> hmm i think i have to explain this with types
20:25:49 <jle`> nshepperd: i think it's just derive Generic => instance Foo
20:26:01 <jle`> er that arrow is like a, "then a", not the => from haskell syntax
20:28:12 <nshepperd> oh, huh, so it doesn't really add anything
20:28:43 <nshepperd> except that deriving (Foo) takes less characters
20:28:45 <sccrstud92_> if I have Traversal' a b, and Traversal b c, how do I obtain Fold a (b, c)?
20:28:58 <sccrstud92_> Traversal' b c -- typo
20:33:03 <sccrstud92_> i might need edwardk for this one
20:35:23 <nshepperd> \f -> tab (\b -> tbc (\c -> f (b,c)))
20:35:32 <nshepperd> or something like that?
20:36:25 <sccrstud92_> > let tab = Traversal' a b
20:36:27 <lambdabot>  <no location info>: not an expression: ‘let tab = Traversal' a b’
20:36:32 <sccrstud92_> > let tab = undefined :: Traversal' a b
20:36:33 <lambdabot>  <no location info>:
20:36:33 <lambdabot>      not an expression: ‘let tab = undefined :: Traversal' a b’
20:36:42 <sccrstud92_> @let tab = undefined :: Traversal' a b
20:36:43 <lambdabot>  Defined.
20:36:51 <sccrstud92_> @let tbc = undefined :: Traversal' b c
20:36:53 <lambdabot>  Defined.
20:36:55 <sccrstud92_> :t tab
20:36:57 <lambdabot> Applicative f => (b -> f b) -> a -> f a
20:37:09 <sccrstud92_> :t \f -> tab (\b -> tbc (\c -> f (b,c)))
20:37:10 <lambdabot> Applicative f => ((f b, t) -> f t) -> a -> b -> a
20:40:18 <nshepperd> oh, right, that doesn't work at all
20:41:01 <nshepperd> :t \f a -> tab (\b -> tbc (\c -> f (b,c)) b) a
20:41:02 <lambdabot> Applicative f => ((t, t1) -> f t1) -> a -> f a
20:42:14 <nshepperd> :t \f a -> tab (\b -> tbc (\c -> f (b,c) *> pure c) b) a
20:42:15 <lambdabot> Applicative f => ((t, t1) -> f a1) -> a -> f a
20:43:32 <nshepperd> :t \f a -> tab (\b -> tbc (\c -> f (b,c) *> pure (b,c)) b) a :: Fold a (b,c)
20:43:34 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ (t0, t1)
20:43:34 <lambdabot>     Relevant bindings include
20:43:34 <lambdabot>       c :: (t0, t1) (bound at <interactive>:1:26)
20:43:51 <nshepperd> :t (\f a -> tab (\b -> tbc (\c -> f (b,c) *> pure (b,c)) b) a) :: Fold a (b,c)
20:43:52 <lambdabot>     Couldn't match expected type ‘c1’ with actual type ‘(b1, c1)’
20:43:52 <lambdabot>       ‘c1’ is a rigid type variable bound by
20:43:52 <lambdabot>            an expression type signature:
20:45:36 <nshepperd> oh, my third last version worked
20:47:02 <sccrstud92_> :t \f a -> tab (\b -> tbc (\c -> f (b,c) *> pure c) b) a :: Fold a (b, c)
20:47:03 <lambdabot>     Couldn't match expected type ‘(t0, t1)
20:47:03 <lambdabot>                                   -> ((b1, c1) -> f1 (b1, c1)) -> a0’
20:47:03 <lambdabot>                 with actual type ‘r’
20:47:29 <sccrstud92_> :t \f a -> tab (\b -> tbc (\c -> f (b,c) *> pure c) b) a
20:47:31 <lambdabot> Applicative f => ((t, t1) -> f a1) -> a -> f a
20:47:38 <sccrstud92_> :t \f a -> tab (\b -> tbc (\c -> f (b,c) *> pure c) b) a :: Fold a (t, t1)
20:47:40 <lambdabot>     Couldn't match expected type ‘(t0, t1)
20:47:40 <lambdabot>                                   -> ((t3, t4) -> f1 (t3, t4)) -> a0’
20:47:40 <lambdabot>                 with actual type ‘r’
20:47:59 <nshepperd>  :: has lower precedence than everything except ->
20:48:04 <nshepperd> :t (\f a -> tab (\b -> tbc (\c -> f (b,c) *> pure c) b) a) :: Fold a (b,c)
20:48:06 <lambdabot> (Applicative f, Contravariant f) => ((b, c) -> f (b, c)) -> a -> f a
20:48:08 <sccrstud92_> let try = \f a -> tab (\b -> tbc (\c -> f (b,c) *> pure c) b) a :: Fold a (b, c)
20:48:25 <sccrstud92_> of course
20:48:36 <nshepperd> :)
20:48:46 <sccrstud92_> looks nice
20:48:52 <sccrstud92_> now for my next hw question...
20:48:53 <sccrstud92_> jk
20:49:26 <sccrstud92_> I wonder if there is a way to do it with lens combinators, rather than "from scratch"
20:49:38 <nshepperd> anyone getting homework about lenses is lucky in my book
20:49:46 <sccrstud92_> agreed lol
20:50:27 <Guest35163> I have a really simple list type, and a function to sum up a list of Nums here: http://lpaste.net/135782 When I try to import it, I'm getting an error that ghci can't deduce `a ~ Int`. Here's the error message: http://lpaste.net/135783. What am I doing wrong?
20:50:55 <sccrstud92_> the type sig should either be 
20:51:01 <sccrstud92_> Num a => List a -> a
20:51:02 <sccrstud92_> or
20:51:05 <sccrstud92_> List Int -> Int
20:51:09 <dramforever> Guest35163: ~ means type equality
20:51:25 <Guest35163> oh! got it
20:51:36 <Guest35163> thanks!
20:51:44 <dramforever> :) I think you are scared off by the ~
20:51:56 <Guest35163> :)
20:52:48 <Guest35163> `sumList :: (Num a) => List a -> a` makes total sense. I'm adding a bunch of `Num`'s. I'll get a Num, not necessarily an int. Thanks sccrstud92_ and dramforever
20:52:53 <nkaretnikov> I have newtype Foo = Foo Int64 and newtype Bar = Bar Int64, I want to write a function that gets /either/ a Foo or Bar and returns a String.  I can do it by defining a class like so: f :: FooBar fb => fb -> String or via a sum type: data FooBar = F Foo | B Bar f :: FooBar -> String  my question is: are there other ways?
20:52:58 <dramforever> :) yw
20:53:37 <dramforever> nkaretnikov: so do you want to deal with Foo and Bar differently?
20:53:43 <sccrstud92_> you could write
20:53:49 <sccrstud92_> Either Foo Bar -> String
20:54:01 <nkaretnikov> that's the same as the sum type
20:54:12 <dramforever> lol "/either/ a Foo or Bar"
20:54:13 <nkaretnikov> and left is usually associated with an error
20:54:16 <sccrstud92_> depends on your definition of the same
20:54:29 <dramforever> nkaretnikov: so do you want to deal with Foo and Bar differently?
20:54:52 <nkaretnikov> I want to keep the newtypes and write as little code as possible to have a function that operates on both
20:55:20 <dramforever> nkaretnikov: write two functions
20:55:31 <dmj`> nkaretnikov: you can have the both derive Num and then do Num a => a -> String
20:55:33 <dmj`> them*
20:55:39 <m_ryan> hi can anyone help me about yesod esqueleto? http://lpaste.net/135712
20:55:41 <dmj`> using GeneralizedNewTypeDeriving
20:56:05 <nkaretnikov> dmj`: that's a terrible idea since it would make it open for other num instances
20:56:11 <sccrstud92_> dmj`: what is he wants to print out something different depending on the tag?
20:56:22 <dmj`> nkaretnikov: what's wrong with that?
20:56:35 <sccrstud92_> nkaretnikov: just because its open for other instances doesnt mean its a bad idea
20:56:44 <dramforever> nkaretnikov: so do you want to deal with Foo and Bar differently?
20:56:45 <sccrstud92_> you havent given us any context supporting that assertion
20:57:07 <nkaretnikov> I'm sorry it seems I can no longer ask questions here
20:57:09 <sccrstud92_> you should answer dram, he is getting ansy
20:57:18 <nkaretnikov> I tend to lose my patience :(
20:57:28 <dramforever> ...
20:57:31 <sccrstud92_> lol
20:57:50 * dramforever has actually been wondering if his irc client failed to send messages
20:58:06 <dmj`> nkaretnikov: you could use a GADT
20:58:12 <sccrstud92_> hes gone
20:58:16 <sccrstud92_> like dust in the wind
20:58:45 <sccrstud92_> ooo
20:58:50 <sccrstud92_> could he have used a type family?
20:59:18 <sccrstud92_> map Foo to String
20:59:21 <sccrstud92_> and Bar to String
20:59:38 <sccrstud92_> i guess it doesnt matter
21:03:10 <dmj`> seems like something trivial to become impatient over
21:05:04 <sccrstud92_> he could just be having a bad day
21:06:24 <dmj`> yea
21:07:16 <cpup> is there any way to pass a type family to a type family? (e.g. map for hlists using type families)
21:29:57 * hackagebot hpack 0.4.0 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.4.0 (SoenkeHahn)
21:40:15 <scutigera> many1 (satisfy (not . isSpace)) `sepBy` (many1 (char ' ')) >>    endOfLine
21:40:50 <scutigera> why does that not work. but removing the endOfLine works (sort of).  it does return '\n' as a word...
21:42:56 <scutigera> if i change isSpace to isHorizontalSpace, then it doesn't eat '\n' but i get a fail with not enough input.
21:44:17 <heatsink> > parseTest (many1 (satisfy (not . isSpace) `sepBy` many1 (char ' ') <* char '\n') "the quick brown fox\n"
21:44:18 <lambdabot>  <hint>:1:105:
21:44:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:44:29 <heatsink> > parseTest (many1 (satisfy (not . isSpace)) `sepBy` many1 (char ' ') <* char '\n') "the quick brown fox\n"
21:44:30 <mauke> scutigera: what do you mean by "does not work"?
21:44:31 <lambdabot>  Not in scope: ‘parseTest’    Not in scope: ‘many1’
21:44:31 <lambdabot>      Perhaps you meant ‘many’ (imported from Control.Applicative)Not in scope...
21:44:31 <lambdabot>      Perhaps you meant ‘many’ (imported from Control.Applicative)
21:44:53 <scutigera> mauke Fail: not enough input
21:45:00 <mauke> scutigera: for what input?
21:45:01 <heatsink> scutigera: It works for me
21:45:15 <scutigera> "  words..  .$## foo  bar  \n"
21:45:28 <mauke> scutigera: how is endOfLine defined?
21:45:34 <heatsink> sepBy doesn't accept leading and trailing separators
21:45:44 <heatsink> separators can only be between tokens
21:45:51 <mauke> oh, that makes sense
21:46:10 <scutigera> right so i put takeWhile isHorizontalSpace to remove leading spaces- and that works great
21:46:40 <scutigera> now i'm trying to make sure it can remove the ending '\n' instead of a) making it part of the word, or b) returning it as a separate word
21:46:54 <mauke> fmap words (many (noneOf "\n")) <* char '\n'
21:47:58 <scutigera> mauke: exercise for the reader - i'm avoiding using words.
21:48:06 <scutigera> want to do it all with attoparsec
21:48:31 <scutigera> ok....
21:48:38 <scutigera> many1 (satisfy (not . isSpace)) `sepBy` (many1 (char ' '))
21:49:00 <scutigera> that does work. it just returns the ending spaces and '\n' as unconsumed input.
21:50:02 <scutigera> and if i add <* char '\n' then i get failed reading: satisfy
21:50:53 <scutigera> it's just not obvious to me why tacking on endOfLine doesn't work.
21:51:19 <scutigera> satisfy (not . isSpace) should leave '\n' - and then endOfLine should pick it up - and all done...
21:52:08 <scutigera> AHA
21:52:15 <scutigera>  <* (many1 (satisfy isSpace))
21:52:25 <scutigera> it has to pick up any leftover spaces AND the '\n'
21:52:27 <scutigera> success !
21:53:34 <scutigera> why does <* (many1 (satisfy isSpace)) work but >> (many1 (satisfy isSpace)) does not ?
21:54:11 <heatsink> They both succeed on the same inputs
21:54:24 <heatsink> p1 <* p2 returns what p1 returns 
21:54:30 <heatsink> p1 >> p2 returns what p2 returns
21:54:35 <scutigera> doh!
21:54:48 <scutigera> ty
21:55:04 <scutigera> it's taken me all weak to write a word splitter. lol.
21:55:09 <scutigera> week*
21:55:23 <heatsink> You'll get used to it
21:55:29 <scutigera> that's what happens when you have 0.5 hours a day to learn attoparsec
21:55:39 <scutigera> i am. really.
21:56:05 <scutigera> also too, excellent lesson in applicative and learning <|>, *>, <*, >> etc.. :-)
21:56:49 <scutigera> most important thing is to put these lessons in the comments !
21:57:00 <scutigera> very unhaskelly, i know.
21:57:03 <heatsink> Combinators are excellent for making parsers
21:57:21 <heatsink> compared to parser generators or DIY control flow
21:57:41 <scutigera> well even my simple-minded thing has a very nice "look" to it.
21:58:06 <scutigera> you can look at the routines and get an excellent sense of what's going
21:59:34 <sccrstud92_> edwardk deserves something for this little piece of documentation
21:59:39 <sccrstud92_> >>> over (traversed.indices (>0)) Prelude.reverse $ ["He","was","stressed","o_O"]
21:59:39 <sccrstud92_> ["He","saw","desserts","O_o"]
22:00:01 <scutigera> haha
22:00:07 <scutigera> oh crud
22:00:13 <scutigera> " words..  .$## foo  bar"
22:00:25 <scutigera> fails because there is no WS at the end, and many1 needs at least 1 WS
22:00:33 <mauke> many
22:01:16 <scutigera> Not in scope: ‘many’
22:01:19 <scutigera> ??
22:01:22 <heatsink> That's a nice palindromic example
22:01:40 <sccrstud92_> :t many
22:01:41 <lambdabot> Alternative f => f a -> f [a]
22:01:49 <sccrstud92_> its an alternative function
22:02:07 <sccrstud92_> so try Data.Alternative or Control.Alternative
22:02:10 <sccrstud92_> cant remember
22:02:25 <scutigera> many'
22:02:36 <sccrstud92_> :t many'
22:02:37 <lambdabot>     Not in scope: ‘many'’
22:02:37 <lambdabot>     Perhaps you meant ‘many’ (imported from Control.Applicative)
22:02:39 <mauke> yeah, just found many'
22:02:48 <heatsink> What is many'?
22:02:52 <sccrstud92_> i guess its many' so its doesnt conflict with the one from alternative
22:03:09 <scutigera> sccrstud92_: that seems reasonable
22:03:21 <sccrstud92_> idk how the behavior differs though
22:03:25 <sccrstud92_> :t some
22:03:26 <lambdabot> Alternative f => f a -> f [a]
22:03:26 <mauke> I don't see the forcing part, though
22:03:29 <scutigera> it's Control.Applicative
22:03:49 <sccrstud92_> idk why they use many' and many1 instead of many and some from the alternative instance
22:03:55 <sccrstud92_> maybe they dont behave the same
22:04:06 <mauke> Alternative is probably newer
22:04:16 <sccrstud92_> hopefully thats the reason
22:04:23 <scutigera> the many from Applicative works just fine.
22:04:35 <sccrstud92_> :t many
22:04:36 <lambdabot> Alternative f => f a -> f [a]
22:04:42 <sccrstud92_> ah right
22:04:44 <sccrstud92_> same module
22:04:52 <sccrstud92_> even though its a different instance
22:05:34 <scutigera> now for my next trick
22:05:49 <scutigera> writing something that reads in floating point
22:05:56 <scutigera> that's gonna be real painful
22:09:53 <scutigera> should 1.E5 be considered valid ?
22:10:22 <scutigera> ah - it has to be. i think "%.0E" would generate such a thing.
22:11:11 <scutigera> surprise- no it doesn't- or at least python doesn't
22:13:01 <saulzar_> In chess, no
22:13:28 <saulzar_> Usually the pawn can only move as far as 1.E4 :P
22:13:40 <scutigera> haha
22:22:12 <scutigera> good grief - just did "hoogle data"- that took a while, and i've got a pretty fast connection.
22:51:02 <adarqui> how is this fpcomplete tutorial using forall?
22:51:03 <adarqui> >>> forall $ \tuple -> view _1 tuple == fst tuple
22:51:04 <adarqui> True
22:51:50 <nrk-> Is that from their Lens tutorial?
22:51:52 <adarqui> > forall $ \tuple -> view _1 tuple == fst tuple
22:51:53 <lambdabot>      Not in scope: ‘forall’
22:51:54 <lambdabot>      Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval....
22:51:55 <adarqui> nrk-, ya
22:52:15 <sccrstud92_> i dont think forall is supposed to be actually implementable
22:52:18 <nrk-> I remember trying to figure out the same thing when I read that. I don’t think I did
22:53:03 <adarqui> hah, cool, i'm not alone then.. i mean it looks like they are reducing these expressions and testing whether the expressions themselves are the same, but, no idea how they are doing it.
22:53:14 <adarqui> seems similar to what i was doing with morte the other day
22:55:06 <nrk-> From the sidenote ‘What is that forall thing?’ I’d guess they aren’t actually executable
22:55:23 <adarqui> (Sidenote: What is that forall thing?)
22:55:24 <adarqui> It's actually a lie, sorry about that.
22:55:25 <adarqui> ya
22:55:34 <adarqui> would have been nice if they mentioned that earlier ;d
22:55:45 <nrk-> Heh yeah
22:56:03 <adarqui> we're trying to understand things sentence by sentence.. so we get wrecked
22:56:06 <adarqui> nice
22:59:37 <lispy> Link to the tutorial?
22:59:53 <nrk-> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
23:00:00 <lispy> looking
23:01:42 <lispy> So, the first thing I would say is that FPComplete made a platform for others to write articles on. So it's technically not an FPC article but instead an article by a third party.
23:01:57 <lispy> The second is that you're right, forall isn't implementable
23:05:04 <lispy> You should join #haskell-lens if you have questions about lens. A lot of the same people are active here, but they know lens better than anyone.
23:05:57 <Walpurgisnacht> What is lens
23:07:29 <lispy> Walpurgisnacht: it's a (clever) abstraction for transforming values into other values. It gives you a succint way to view the data and even update it.
23:07:49 <Walpurgisnacht> :O
23:08:04 <Walpurgisnacht> Woah why haven't I heard of this
23:08:06 <lispy> It uses some advanced machinery under the hood, but gives you an elegant API to program against.
23:08:22 * Walpurgisnacht recieves Clarity
23:08:28 <Walpurgisnacht> Thanks mate
23:08:32 <lispy> np
23:08:35 <Walpurgisnacht> Ill check it out
23:13:52 <adarqui> Walpurgisnacht: and a nice example of their implementation perhaps: https://github.com/ekmett/lens/blob/master/examples
23:14:05 <adarqui> because some of those tutorials are rough
23:14:55 <nrk-> Huh, that tutorial on FPComplete was by tel. Haskell’s a real ‘small world’ thing going
23:16:55 <nrk-> got a*
23:17:04 <adarqui> what you mean
23:17:46 <nrk-> Just that the same names seem to keep coming up. I remember trying to do a few puzzles on Codewars by the same guy
23:18:22 <adarqui> oo, ya.
23:20:50 <nshepperd> 2/url lens
23:20:56 <Walpurgisnacht> Thank you
23:21:43 <adarqui> np, it's helpful code to read. imho.
23:28:43 <adarqui> really love how they do those updates in the pong example; calling execState in that update func, then using .= etc.. dope
23:29:44 <sccrstud92_> :t tab
23:29:45 <lambdabot> Applicative f => (b -> f b) -> a -> f a
23:29:50 <sccrstud92_> :t tbc
23:29:51 <lambdabot> Applicative f => (c -> f c) -> b -> f b
23:29:57 <sccrstud92_> :t tab . tbc
23:29:58 <lambdabot> Applicative f => (c -> f c) -> a -> f a
23:30:18 <sccrstud92_> :t tab . to (\x->(x,x) . alongside tbc id
23:30:19 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
23:30:24 <sccrstud92_> :t tab . to (\x->(x,x)) . alongside tbc id
23:30:26 <lambdabot> (Applicative f, Applicative (Control.Lens.Internal.Getter.AlongsideLeft f b), Contravariant f) => ((a1, b) -> f (a1, b)) -> a -> f a
23:30:44 <sccrstud92_> nshepperd: ^
23:31:55 <sccrstud92_> :t (tab . to (\x->(x,x)) . alongside tbc id) :: Fold a (b, c)
23:31:56 <lambdabot>     Could not deduce (Applicative
23:31:56 <lambdabot>                         (Control.Lens.Internal.Getter.AlongsideLeft f1 c1))
23:31:56 <lambdabot>       arising from a use of ‘tbc’
23:32:20 <sccrstud92_> :t (tab . to (\x->(x,x)) . alongside id tbc) :: Fold a (b, c)
23:32:22 <lambdabot>     Could not deduce (Applicative
23:32:22 <lambdabot>                         (Control.Lens.Internal.Getter.AlongsideRight f1 b1))
23:32:22 <lambdabot>       arising from a use of ‘tbc’
