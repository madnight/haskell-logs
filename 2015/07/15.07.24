00:00:07 <AaronFriel> julianleviston: Okay, one second
00:00:11 <dibblego> nikki93: up to you, the course is not very rigid
00:00:16 <dibblego> nikki93: leaving now bye
00:00:22 <AaronFriel> julianleviston: I'm running things on my linux instance to make sure I get the same errors you do
00:00:43 <AaronFriel> cool I do
00:00:49 <julianleviston> I honestly can’t believe this is so hard.
00:01:05 <AaronFriel> julianleviston: Well, it's confusing, and I'm sorry for that, because that's shitty for a new user
00:01:07 <julianleviston> well, that’s not true. It’s completely expected
00:01:14 <AaronFriel> julianleviston: So I just want to say on behalf of the Haskell community, sorry :(
00:01:19 <julianleviston> nah, it’s not, it’s fine.
00:01:30 <AaronFriel> julianleviston: Okay, so you want to mess around with haskell-src-exts *in a project*
00:01:42 <julianleviston> AaronFriel: yep… as I said from the beginning :)
00:01:44 <AaronFriel> julianleviston: And the correct way to do that is to modify your project dependencies, so open up your "new-template.cabal"
00:01:58 <julianleviston> more than anything this is me “being a noob” to see what the noob experience is like.
00:02:16 <julianleviston> AaronFriel: haha that’s what I was asking before!!!! GRRR OP
00:02:21 <lpaste_> AaronFriel pasted “new-template.cabal” at http://lpaste.net/137248
00:02:39 <AaronFriel> julianleviston: Sorry! You saying "GHCi" kept throwing me for a loop
00:02:44 <AshyIsMe> julianleviston: that article i posted above goes in to the details of this
00:02:53 <julianleviston> AaronFriel: um I deleted the whole folder to start again.
00:02:55 <AaronFriel> julianleviston: Your new-template.cabal should look like the one I just pasted
00:03:03 <AaronFriel> julianleviston: That's okay, just run "stack new" again
00:03:04 <AshyIsMe> about adding a package to the cabal file and then stack build will pick it up automatically (if it's part of stackage) etc
00:03:24 <AaronFriel> julianleviston: AshyIsMe is correct, the instructions they referenced will work
00:03:26 <julianleviston> AaronFriel: hang on… what’s “in a project”? I thought we were talking about GHCI… that’s where I want to mess around.
00:03:31 <AaronFriel> julianleviston: Okay, okay
00:03:36 <AaronFriel> julianleviston: So the distinction does matter
00:03:42 <julianleviston> why isn’t this crap on the stack proj on github. guh.
00:03:53 <AaronFriel> julianleviston: A project is a collection of source files you want to use to produce a library or executable, of course
00:03:58 <AaronFriel> julianleviston: But if you just want to mess around
00:04:06 <AaronFriel> julianleviston: Don't use projects! Just use ghci without "stack"
00:04:24 <AaronFriel> julianleviston: If you want to install a library, use "stack install", and then regular plain "ghci" can use it
00:04:37 <julianleviston> We should contrast this with installing leiningen in clojure sometime. It takes a few minutes
00:05:03 <AaronFriel> julianleviston: Well, ... let me ask you this: do you want to write a library or program, or do you want to just play around in the REPL?
00:05:18 <julianleviston> AaronFriel: the latter, with the option to the former.
00:05:39 <AaronFriel> julianleviston: Okay, then you want to start with a package, because going the other way will be *a tad* messier
00:05:51 <AaronFriel> julianleviston: I mean, well, maybe a little, it's hard to say.
00:05:57 <julianleviston> I’m used to the REPL as being the way I muck around as I’m writing a program, and then write more of my project, and then load the code in and play, and loop.
00:06:10 <AshyIsMe> yeah so you want to use stack
00:06:17 <AaronFriel> julianleviston: Okay, then here's what I want you to do, in a brand new folder
00:06:18 <julianleviston> AaronFriel: the word you’re looking for is convoluted.
00:06:22 <AaronFriel> julianleviston: Do "stack new"
00:06:22 <julianleviston> AaronFriel: ok.
00:06:29 <AaronFriel> julianleviston: Then open up the "new-template.cabal"
00:06:32 <julianleviston> AaronFriel: by the way, thanks for being patient with this.
00:06:36 <AaronFriel> julianleviston: No problem
00:07:11 <AshyIsMe> julianleviston: stack is still relatively new so the new user tutorials and documentation is not quite there yet
00:07:24 <AaronFriel> julianleviston: Once you've done "stack new" and opened up "new-template.cabal"
00:07:36 <AaronFriel> julianleviston: You'll see a field that looks like this:
00:07:36 <AshyIsMe> maybe i should do a blog post on it from a beginners point of view
00:07:46 <julianleviston> AshyIsMe: yes… please :)
00:07:57 <AaronFriel> julianleviston:
00:07:57 <AaronFriel>   build-depends:       base >= 4.7 && < 5
00:08:05 <julianleviston> AaronFriel: yep.
00:08:13 <AaronFriel> julianleviston: It should be on line 19
00:08:18 <AaronFriel> julianleviston: Change it so that it looks like this:
00:08:20 <julianleviston> uhhuh
00:08:44 <AaronFriel>   build-depends:       base >= 4.7 && < 5
00:08:45 <AaronFriel>                     ,  haskell-src-exts
00:08:53 <julianleviston> man sometime the haskell community should look at how clojure does this stuff… ti’s amazingly cool.
00:09:07 <AaronFriel> julianleviston: I agree, this is something that Stack should automate in the future
00:09:31 <julianleviston> AaronFriel: yeah, but the file formats even. anyway, I’ll put my whining away.
00:09:50 <AaronFriel> julianleviston: Once you've changed that
00:09:57 <julianleviston> AaronFriel: stack setup now then?
00:10:21 <AaronFriel> julianleviston: Nope, you should be able to just "stack ghci"
00:10:25 <AaronFriel> julianleviston: And you'll see this line:
00:10:34 <AaronFriel> Loading package haskell-src-exts-1.16.0.1 ... linking ... done.
00:10:45 <julianleviston> AaronFriel: says no parse build depends 19
00:11:03 <AaronFriel> julianleviston: Do you have a comma before haskell-src-exts?
00:11:12 <julianleviston> nop… ak. gotcha one sec.
00:11:36 <julianleviston> AaronFriel: now it’s saying this again: cannot satisfy -package new-template
00:11:46 <julianleviston> AaronFriel: stack install ?
00:11:50 <AaronFriel> julianleviston: Okay, do a "stack build"
00:11:55 <julianleviston> ok
00:12:12 <julianleviston> worked. I’m in ghci now.
00:12:19 <julianleviston> will try importing
00:12:44 <julianleviston> AaronFriel: now Could not find module ‘Haskell.Src.Exts’
00:12:57 <AaronFriel> julianleviston: Cool, uhm
00:13:07 <AaronFriel> julianleviston: Try "stack install"?
00:13:10 <AaronFriel> julianleviston: ... I think
00:13:22 <AaronFriel> wait
00:13:29 <AaronFriel> julianleviston: are you in ghci?
00:13:34 <julianleviston> yep.
00:13:37 <julianleviston> for the import
00:13:48 <julianleviston> so I should install? i’ll give that a go
00:13:51 <AaronFriel> nono
00:13:56 <AaronFriel> well that won't hurt anything
00:13:56 <julianleviston> lol ok.
00:13:58 <AaronFriel> but you don't need to
00:14:08 <AaronFriel> here is a tool you will find IMMENSELY handy:
00:14:18 <AaronFriel> https://www.haskell.org/hoogle/?hoogle=test
00:14:23 <AaronFriel> it's a Haskell package search engine
00:14:31 <julianleviston> um yeah I know hoodle. lol
00:14:34 <AaronFriel> okay
00:14:40 <AaronFriel> so I "hoogle"d https://www.haskell.org/hoogle/?hoogle=haskell-src-exts
00:14:42 <julianleviston> hoogle *
00:14:57 <AaronFriel> I clicked on "package haskell-src-exts"
00:14:59 <AaronFriel> And I scrolled down
00:15:04 <AaronFriel> and on this page: http://hackage.haskell.org/package/haskell-src-exts
00:15:09 <AaronFriel> I see that the modules exposed by it are
00:15:14 <AaronFriel> Language.Haskell.Exts 
00:15:21 <AaronFriel> and Language.Haskell.Exts.blahblahblah
00:15:29 <AaronFriel> So in stack ghci:
00:15:34 <julianleviston> oh god. sorry. I’m a total idiot. I have that page alerady open. lol
00:15:35 <AaronFriel> "import Language.Haskell.Exts"
00:15:36 <AaronFriel> :)
00:15:43 <AaronFriel> not Haskell.Src.Exts
00:16:03 <julianleviston> phew. yay :) worked.
00:16:18 <AaronFriel> julianleviston: GHCi has tab completion, which probably wouldn't have helped in this case
00:16:26 <AshyIsMe> god i remember struggling through this same stuff originially learning haskell
00:16:31 <AaronFriel> julianleviston: But you can do things like "import L" and hit tab
00:16:31 <julianleviston> Woo parsed an exp. huzzah :) thanks.
00:16:36 <AaronFriel> julianleviston: Yay!
00:16:57 <AshyIsMe> took ages for me to learn what i was even looking at on the hackage module pages
00:17:22 <AaronFriel> AshyIsMe: It's many times easier now, I remember coming into #haskell after the first time I tried to upgrade my dependencies
00:17:38 <julianleviston> hehe :) I’m a weird combination of completely seasoned programmer, and utter noob… because I know exactly what I want to do, but I have no idea how to do it.
00:17:42 <AaronFriel> AshyIsMe: But I think an overhaul to Hackage is overdue...
00:18:05 <AaronFriel> julianleviston: Yeah, I know that feeling. Every language has its own weirdness
00:18:28 <AaronFriel> julianleviston: So in the future, here's my prescription:
00:18:56 <AaronFriel> julianleviston: If you just want to mess around in a playground with a library, create an empty folder and just "stack install library" then "ghci"
00:19:16 <julianleviston> AaronFriel: yeah, it’s cool. I know this :)
00:19:20 <julianleviston> AaronFriel: thanks.
00:19:21 <AaronFriel> julianleviston: The empty folder is just a safeguard to make sure "stack ghci" won't work
00:19:43 <AaronFriel> julianleviston: Actually disregard that, stack ghci works in an empty folder huh
00:19:58 <AaronFriel> julianleviston: But it just runs regular ghci, okay
00:20:18 <julianleviston> lol
00:20:22 <AaronFriel> julianleviston: Well anyway, if you want to work on something longer term, edit .cabal files and let Stack manage dependencies
00:20:22 <julianleviston> AaronFriel: don’t fret. I’m fine.
00:20:42 <AaronFriel> julianleviston: I'm learning many of these things with you as I go, as I haven't messed with Stack much
00:20:43 <julianleviston> AaronFriel: yeah, it’s a similar story to clojure, but clojure’s “cabal files” are written in the language itself… 
00:21:04 <AaronFriel> julianleviston: I just have the advantage (or disadvantage?) of having spent a lot of time fighting Cabal
00:21:16 <AaronFriel> julianleviston: So when you have problems with Haskell, I have a lot of sympathy
00:21:38 <julianleviston> all good.
00:21:58 <AaronFriel> You can write setup (.cabal equivalent) files in Haskell but I think no one uses them anymore
00:22:23 <AaronFriel> well some packages have a setup.hs file that runs before anything else does
00:22:40 <AaronFriel> but it makes a lot of assumptions about the environment it's running in
00:22:52 <julianleviston> yeah I guess Clojure has the advantage of having several useful data structures have very simple syntax… like maps are {} and sets are #{}
00:23:09 <AaronFriel> I just checked, "Setup.hs" is still used by Stack
00:23:17 <AaronFriel> julianleviston: You should see one in your folder, but it's pretty barebones :)
00:24:23 <AaronFriel> julianleviston: That is a pretty nice advantage, in Haskell these things would be written in the form of lists
00:24:33 <julianleviston> ah this is so nice. I can now get SEXPs out.
00:24:44 <julianleviston> AaronFriel: yeah, or association lists, which is pretty ugly.
00:24:51 <AaronFriel> julianleviston: for example, a map of 'A'->1, 'B'->2 is just [('A',1),('B',2)]
00:24:54 <AaronFriel> julianleviston: precisely
00:25:14 <julianleviston> AaronFriel: technically it’s Map.fromList associationList I think… but yeah.
00:25:23 <AaronFriel> julianleviston: correct
00:25:40 <julianleviston> AaronFriel: coz LazyMap doesn’t have a first class syntax.
00:26:25 <AaronFriel> julianleviston: No, the data structures are all barebones in terms of API. That would be a neat feature if someone wrote the equivalent of a "IsString" for maps
00:26:50 <AaronFriel> julianleviston: But very few people hard-code maps, they'll tend to load it at runtime or generate them from expressions
00:26:55 <julianleviston> AaronFriel: what do you mean IsString ?
00:27:20 <AaronFriel> julianleviston: Uhm, well you've probably heard that Haskell has an inconsinstent "string" story, that is, there are several different types of strings
00:27:24 <julianleviston> AaronFriel: yeah, it’s not important in haskell because you think in functions, not data structures. In clojure everything is data structures.
00:27:31 <julianleviston> AaronFriel: yep.
00:27:36 <AaronFriel> julianleviston: ByteString, Text, and [Char] are all in a sense strings
00:27:46 <julianleviston> AaronFriel: yep
00:28:00 <AaronFriel> julianleviston: GHC has a language extension called "OverloadedStrings", and what it allows you to do is use standard string literal syntax
00:28:10 <julianleviston> AaronFriel: yeah, I’ve used it.
00:28:11 <AaronFriel> julianleviston: Wherever you would have to do something like "fromString "Foo""
00:28:28 <AaronFriel> julianleviston: Well the neat thing is that there's nothing special about those data types, it's not hard-coded
00:28:37 <julianleviston> AaronFriel: how do you distinguish then?
00:28:44 <AaronFriel> julianleviston: They have to be explicitly typed
00:28:49 <wyager> julianleviston: How do you distinguish num types?
00:28:51 <julianleviston> AaronFriel: do you have to say “hey” :: [Char] ?
00:28:52 <julianleviston> oh ok
00:28:54 <wyager> 1 can be Double, Float, Int, etc.
00:28:55 <AaronFriel> julianleviston: Yep
00:29:09 <julianleviston> wyager:  true! :)
00:29:13 <AaronFriel> julianleviston: If the type inference can't figure it out, and you have OverloadedStrings turned on, you get a compiler error
00:29:26 <wyager> IsString basically implements Num's "fromInteger"
00:29:33 <wyager> but fromString instead
00:29:36 <wyager> so it's all the same caveats
00:29:38 <AaronFriel> almost, it's actually different from what happens when you type "1"
00:29:47 <AaronFriel> because GHC has default types for numeric literals
00:30:01 <wyager> Most people aren't a fan of that, I think
00:30:10 <wyager> But yes
00:30:14 <julianleviston> AaronFriel: ah ok guess it’s the same story as read “True” , but not $ read “True”
00:30:24 <mauke> AaronFriel: doesn't ghc default strings too?
00:30:40 <AaronFriel> mauke: In 7.6 it definitely did not, but maybe that has changed?
00:30:43 <julianleviston> cools.
00:31:08 <mauke> AaronFriel: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#overloaded-strings
00:31:36 --- mode: mauke set -o mauke
00:32:04 <AaronFriel> mauke: I just checked on 7.8, you are right
00:32:17 <AaronFriel> mauke: let x = "foo" defaulted to [Char]
00:32:36 <AaronFriel> with -XOverloadedStrings and -XMonomorphismRestriction
00:32:51 <wyager> Isn't -XMonomorphismRestriction default?
00:34:16 <julianleviston> what is the reverse of a parse?
00:34:35 <AaronFriel> To respond to wyager for the public: yes, but I was using GHCi
00:34:48 <AaronFriel> julianleviston: Reverse of a parse?
00:35:05 <mauke> julianleviston: pretty print? deparse? serialize?
00:35:19 <julianleviston> like… if I do a parseExp "1+1”, then the result is ParseOk (InfixApp (Lit (Int 1)) (QVarOp (UnQual (Symbol "+"))) (Lit (Int 1)))
00:35:26 <julianleviston> how do I go from the latter to the former?
00:35:32 <AaronFriel> julianleviston: I think you prettyPrint
00:35:35 <AaronFriel> https://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts-Pretty.html
00:35:37 <julianleviston> ahhh ok 
00:35:42 <julianleviston> I was just looking at that.
00:35:44 <julianleviston> I’ll tryi
00:38:47 <AaronFriel> julianleviston: Okay, so what happens is, "parseExp" returns data of type "ParseResult Exp"
00:38:59 <julianleviston> it does...
00:39:07 <AaronFriel> julianleviston: So if you want to print that, you need to differentiate between "good" and "bad" cases
00:39:16 <julianleviston> so now I’m looking for a way to unwrap it, and to make it into a pretty… or is it already a pretty? :)
00:39:21 <AaronFriel> julianleviston: I'll type up an example in GHCi
00:39:29 <julianleviston> AaronFriel: haha you’re too helpful! :)
00:40:24 <julianleviston> how can I tell if something is an instance of a particular typeclass? I guess I ask for info on it?
00:40:54 <julianleviston> ah… cool… so :i on Exp shows it’s an instance of Pretty. Excellent.
00:40:58 <julianleviston> oh that should be simple then.
00:41:00 <tejon> Has anyone run into GHCI claiming a monad stack doesn't have a MonadIO instance, when GHC proper throws no such error?
00:41:16 <lpaste_> AaronFriel pasted “Parse expression” at http://lpaste.net/137250
00:41:29 <AaronFriel> julianleviston: See that? I used a case statement to handle two cases
00:42:04 <AaronFriel> julianleviston: In this case, the destructuring is just like Clojure or Lisp s-exp destructuring using... match? I think
00:42:05 <julianleviston> yep. :) lol I was just about to write a function to do exactly that. :)
00:42:58 <tejon> The stack in question being:  RedditT (StateT CommentID (ReaderT BotInfo IO)) a
00:43:19 <AaronFriel> julianleviston: You will find it is very very common for functions in Haskell to not blow up when an error occurs, but instead return a data type that differentiates between cases
00:43:27 <tejon> So I mean, it's definitely a MonadIO. :P
00:43:34 <AaronFriel> julianleviston: Except for some reason the default list functions
00:43:41 <julianleviston> AaronFriel: just so you know, I’ve read three books on Haskell.
00:43:54 <julianleviston> AaronFriel: and written programs in it to do little things, so I’m not a total noob :)
00:44:07 <AaronFriel> julianleviston: Oh, I didn't know
00:44:25 <julianleviston> AaronFriel: sorry I didn’t know how to explain that without offense. I really do appreciate the help.
00:44:40 <julianleviston> AaronFriel: and it was a safe assumption for you to make that I was a total noob given the cabal issues I was whining about :)
00:44:54 <AaronFriel> julianleviston: No worries, I also know that reading books can sometimes impart different impressions versus practice
00:45:03 <julianleviston> AaronFriel: and I do love seeing alternate ways of doing things. I was about to write a function I didn’ think of doing a case statement.
00:45:08 <AaronFriel> julianleviston: But the people here in #haskell are generally helpful about pointing out the best ways to do things
00:45:16 <AaronFriel> julianleviston: And also... obscure ways to do things
00:45:36 <julianleviston> AaronFriel: indeed! I wish there was like a massive set of tiny problems, and various ways to handle them in haskell - kind of like project euler, but simpler, and more varied rather than math focussed.
00:45:53 <AaronFriel> julianleviston: Project Euler is a great way to start, I've done ~40-60 of them in Haskell
00:45:53 <julianleviston> AaronFriel: community-driven of course :_)
00:46:26 <AaronFriel> julianleviston: They are a more interesting test of your Haskell writing abilities than you would expect, because you have to deal with things like "how do I efficiently handle strings"
00:46:40 <julianleviston> AaronFriel: yeah, I didn’t find them to be the case particularly.
00:46:50 <AaronFriel> julianleviston: And the answer is "Stop using [Char] as your string type because it has O(n) lookup"
00:48:19 <AaronFriel> julianleviston: There are a lot of things that you may assume are efficient because they are the default... and they are not. (A sad point for Haskell)
00:48:41 <AaronFriel> julianleviston: Haskell has a difficult learning curve for a lot of reasons
00:48:43 <julianleviston> AaronFriel: yeah, the neverending debate of what to put in the prelude :) 
00:48:53 <julianleviston> AaronFriel: I like learning Haskell. 
00:48:53 <AaronFriel> julianleviston: Yeah, so you are pretty well read if you know about that stuff
00:49:16 <julianleviston> AaronFriel: yeah, I’d say I was *familiar* with a lot of Haskell stuff. By no means expert, though.
00:49:18 <frerich> Anybody here familiar with the fgl package? I use the 'run_' function to build a graph, but profiling shows that inserting ~ 40400 nodes into the graph using insMapNodesM eats 20% of the total program runtime. Before I start trying random alternatives to building graphs -- does anybody hvae some idaes how to improve this?
00:49:23 <julianleviston> AaronFriel: just a beginner.
00:49:27 <AaronFriel> julianleviston: The debate over whether or not "Prelude.head" should be total is one of the most interesting and meaningful in the community. I can see both sides
00:50:51 <tejon> I'm not sure it can be. How would you manage the deprecation cycle for that? Better to just remove it entirely, and have a total replacement. ;)
00:52:25 <AaronFriel> Pinging Haskell experts - I have a question about structuring the back end of a library, and how *you* might do it. I've already written the code, I just want to know if it's idiomatic and makes sense. (Or if it will cause me pain in the future.)
00:52:25 <julianleviston> dependency specification is a way to manage deprecation rather effectively.
00:53:00 <AaronFriel> tejon, julianleviston: I imagine it would be a Haskell 2015 or Haskell Prime-Prime or some new revision of the language thing. Or GHC 8/9/10
00:53:19 <AaronFriel> tejon, julianleviston: Definitely not without a major version bump and a concerted effort to update hackage in concert
00:53:44 <AaronFriel> Anyone? Bueller?
00:53:58 <AaronFriel> I'm working on a data access library and I'm concerned I've done something in a Dumb Way
00:54:28 <frerich> AaronFriel: Just ask your question.
00:54:34 <frerich> AaronFriel: And/or post some code. :-)
00:55:02 <tejon> julianleviston, the issue is that GHC likes to not just *remove* something without a full version worth of deprecated status -- the idea being that you should always be able to keep your existing code through at least one compiler version. Changing head to be total can't be done with gradual deprecation like that.
00:55:28 <AaronFriel> frerich, et al.:
00:55:43 <julianleviston> tejon: that’s not true dependency specification, is it? Because if “peolpe’s code” doesn’t specify which version of head they want, then it’s not specified.
00:55:47 <AaronFriel> I am writin a database library and I am using (I think the correct term is) data families to abstract two similar APIs
00:55:50 <AaronFriel> See: https://github.com/AaronFriel/hyhac/blob/testfail/src/Database/HyperDex/Internal/Core.hs#L44-L56
00:56:02 <AaronFriel> https://github.com/AaronFriel/hyhac/blob/testfail/src/Database/HyperDex/Internal/Client.chs#L40-L52
00:56:11 * frerich gets his 'existential class antipattern' link ready...
00:56:33 <AaronFriel> (p.s.: I am not illiterate, but some of my keys do not work all the time, hence the "workin")
00:56:44 <AaronFriel> (I do not know why my g key is mad at me)
00:57:22 <tejon> julianleviston, dependencies are specified by package, so you wouldn't be able to choose old head while getting other new features in base.
00:57:31 <AaronFriel> frerich: I'm not using existential types, but I am using type aliases a lot to get shorter type signatures to avoid having to do things like:
00:57:43 <julianleviston> tejon: well that is unfortunate, isn’t it? ;-)
00:57:49 <AaronFriel> IO (IO (Either (ReturnCode Client) a)
00:57:52 <AaronFriel> )
00:58:07 <tejon> Indeed it is, but it's what we've got!
00:58:11 <AaronFriel> Basically what I have is two APIs, exposed by a C library via FFI
00:58:16 <AaronFriel> I have an "admin" library, and a "client" library
00:58:58 <AaronFriel> But an admin connection != a client connection, so I have "class HyperDex o"
00:59:05 <AaronFriel> and an associated data type, "ReturnCode"
00:59:17 <AaronFriel> "data ReturnCode o"
00:59:27 <AaronFriel> is that the right thing to do? The ReturnCode is dependent on the type of connection
00:59:52 <julianleviston> tejon:  maybe we need to refactor what we’ve got before we make any changes… to incorporate time and change… then there wouldn’t be any problem.
01:00:25 <AaronFriel> frerich: See, what happens is my possible issue takes more than a few lines to explain, so no one reads it all :'(
01:00:32 <frerich> AaronFriel: Why not 'data HyperDex = Client { failureCode :: ReturnCode Int } | Admin { failureCode :: ReturnCode Foo }'
01:00:50 <AaronFriel> frerich: because... 
01:01:05 <AaronFriel> frerich: I'm trying to think of why I didn't do that, one second
01:01:21 <quicksilver> julianleviston: https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
01:01:25 <AaronFriel> frerich: Ah! Because you have to pass the "Client" object to each of the API functions
01:01:37 <quicksilver> julianleviston: (much less numerically focussed than the euler problems)
01:01:40 <julianleviston> quicksilver: oh that’s on my reading list. I’ll take a look now
01:01:46 <AaronFriel> frerich: And I can't specify that a function only accepts "Client" and not "Admin" 
01:01:53 <AaronFriel> frerich: Does that make sense?
01:02:10 <frerich> AaronFriel: Hm no, but my gut feeling is that you might find https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ interesting in case you didn't see it already.
01:02:12 <julianleviston> quicksilver: nice. thanks.
01:02:18 <quicksilver> to be honest, project euler is a set of number theory problems. It's about maths, not haskell. It doesn't teach you that much haskell on the way in my opinion.
01:02:23 <quicksilver> although it's fun if you like that kind of thing.
01:02:31 <julianleviston> quicksilver: i concur.
01:02:33 <AaronFriel> frerich: Okay, for example, let's say I had an API function called... "createTable"
01:02:45 <AaronFriel> frerich: And for simplicity's sake, it takes a connection and a name
01:03:02 <AaronFriel> frerich: Would its type signature be: "HyperDex -> String -> IO ()"
01:03:17 <AaronFriel> frerich: Because that lets you pass a "Client" to it, and that's an error
01:04:02 <ttt_fff> 12 seconds to compile a 2400 lines of *.hs, this is on a brand new 15" MBP -- is this right?
01:04:04 <frerich> AaronFriel: Are there things which you can do with the client library but not with admin?
01:04:10 <ttt_fff> this seems awfully slow, i.e. 200 lines of haskell / second
01:04:11 <AaronFriel> frerich: Yes
01:04:29 <AaronFriel> frerich: Both APIs do completely different things, *but* the backend code to make it work is identical modulo a couple API calls
01:04:41 <ChristianS> ttt_fff: in my experience, ghc is awfully slow, yes
01:04:48 <peddie> ttt_fff: depends what lines they are, I guess . . . some things compile a lot slower than others
01:04:52 <ttt_fff> so 200 lines of code / second .... is normal ?
01:04:55 <ttt_fff> there's no template haskell
01:05:01 <AaronFriel> frerich: For example, both "Admin" and "Client" connections require an event loop to run in the background
01:05:03 <ttt_fff> just a bunch of data declarations, type classes, and functions
01:05:15 <ttt_fff> I'm not doing any type-checking black magic foo
01:05:16 <peddie> ttt_fff: are you defining a lot of data types and/or deriving a lot of things?
01:05:32 <ttt_fff> peddie: I have 20-30 data types, and quite a few instances
01:05:41 <AaronFriel> ttt_fff: Are you compiling with -O2 and/or using a lot of imported modules?
01:05:46 <ttt_fff> no, I'm using -O0
01:05:51 <peddie> that could do it, especially if you are relying on Generic to do some of the instances for you
01:06:01 <AaronFriel> ttt_fff: Even -O0 I think is pretty slow compared to not -O0
01:06:05 <ttt_fff> I'm importing quite a bit of Data.Map/Set/List/DList, as well as Contro.Monad/Applicative/...
01:06:15 <ttt_fff> AaronFriel: I just put in O0 after reading on SO
01:06:18 <ttt_fff> used to compile without -O0
01:06:37 <AaronFriel> ttt_fff: huh, you know what my knowledge is out of date, I should look things up before I type
01:06:48 <peddie> ttt_fff: I think deriving a lot of instances for a lot of data types is the main thing I've found that slows GHC down
01:06:55 <ttt_fff> just compiled without "-O0" --  27 seconds
01:07:04 <ttt_fff> wtf, ghc is now 100 lines of code / second
01:07:13 <ttt_fff> this is retartedly slow for a brand new MBP, when I have -j8 on
01:07:16 <AaronFriel> ttt_fff: Yeah -O0 is actually "disable all optimizations" so you were right
01:07:43 <AaronFriel> ttt_fff: What sort of "deriving" are you doing in your code?
01:07:51 <ttt_fff> AaronFriel: this is my amazing ability of reading SO and pasting whatever compiler flags people suggest w/o reading it .... "you said rm -rf /? let me add taht to my makefile"
01:08:05 <ttt_fff> AaronFriel: by 'deriving' do you mean typeclass/instances ?
01:08:06 <peddie> ttt_fff: https://ghc.haskell.org/trac/ghc/ticket/9557
01:08:13 <AaronFriel> ttt_fff: Yeah, what classes are deriving?
01:08:18 <AaronFriel> ttt_fff: Instances, rather*
01:08:36 <ttt_fff> oh wait, by deriving, do you mean by "deriving (Eq, Show, Ord)" ?
01:08:41 <AaronFriel> Yeah
01:08:50 <ttt_fff> I only derive Ord + Show; Ord for Set/Map, and "Show" for debugging purposes
01:08:52 <AaronFriel> frerich: Your existential antipattern blog post, I'm pretty sure I read it a long time ago, but it was good to re-read
01:08:53 <Myrl-oneechan> derviving (Equation)
01:09:13 <AaronFriel> ttt_fff: ... Can you share your .hs file with me and I can try to compile it?
01:09:34 <AaronFriel> ttt_fff: I can tell you how long it takes on a rather normal sized Azure instance
01:09:46 <ttt_fff> AaronFriel: hmm, the project is confidential
01:10:03 <ttt_fff> my laptop is not weak ... 16 GB of RAM + quad core CPU I believe
01:10:09 <ttt_fff> 15" mbp retina from 3 months ago
01:10:10 <tejon> Grr... GHCi wai u no recognize implicit MonadIO instance?
01:10:22 <AaronFriel> ttt_fff: Sure, no problem. I didn't think it was your laptop, but I thought it might be due to GHC differences
01:10:34 <ttt_fff> ghc --version The Glorious Glasgow Haskell Compilation System, version 7.8.3
01:10:34 <AaronFriel> ttt_fff: But it looks like the track ticket peddie linked to is your problem
01:10:49 <AaronFriel> ttt_fff: See: https://ghc.haskell.org/trac/ghc/ticket/9557
01:11:00 <AaronFriel> ttt_fff: Looks like deriving just has poor perf
01:11:26 <ttt_fff> is "instance BLAH" also caled 'deriving' ?
01:11:36 <ttt_fff> becuase I have lots of "typeclass instances", but I do not derive anything besides Ord + Show
01:11:36 <tejon> ...or, possible alternate question, why does this RedditT monad have an *explicit* MonadIO instance?
01:12:11 <peddie> ttt_fff: if you have a lot of data declarations it could slow things down too
01:12:26 <ttt_fff> peddie: how can you have haskell code w/o lots of data declarations?
01:12:35 <ttt_fff> part of the fun is forcing the compiler to eliminate bugs due to type checking
01:12:40 <peddie> ttt_fff: I think if you are relying on generics to fill in instance BLAH it will be slower than you expect as well
01:13:02 <ttt_fff> I have 37 "data" declarations in my 2400 lines of code
01:13:12 <AaronFriel> ttt_fff: Apparently "deriving (Ord, Show)" is actually pretty slow, according to the trac ticket
01:13:19 <peddie> ttt_fff: I don't know whether this is your problem, just suggesting something you could check into if you really care
01:13:27 <julianleviston> that’s a HUGE amount of haskell isn’t it? 2400 lines?
01:13:31 <ttt_fff> I do have stuff like "instance (Renderable a) => ToSvgNode a" ; and things like "instance (Renderable k, Renderable v) => Renderable (SMap k v)" <-- do things like this slow down compile too?
01:13:42 <ttt_fff> peddie: noted, thanks
01:13:45 <AaronFriel> julianleviston: Yeah 2400 lines is more than most of my .hs files
01:14:07 <ttt_fff> from the ticket "Different classes vary in their compile-time cost, but there's no single culprit. Among the costly ones are Generic, Data, Show, Ord."
01:14:08 <peddie> ttt_fff: are you defining the methods for ToSvgNode and Renderable as well, or is Generics filling them in for you?
01:14:22 <ttt_fff> AaronFriel: it's 2400 lines spread over 30 files, not in one *.hs file
01:14:24 <AaronFriel> ttt_fff: I don't think so, but if you have large / complex data types for which you are doing "deriving (Ord, Show)" you will get serious compile time slow down
01:14:30 <julianleviston> ttt_fff: is it worth using some modules?
01:14:41 <AaronFriel> oh dear it sounds like they already are
01:14:44 <ttt_fff> peddie: some are being filled in via "instance (Renderable k, Renderable v) => Renderable (Map k v)" ... quite a few times
01:15:08 <ttt_fff> julianleviston: I have 2400 lines of code, spread over 30 module ... I think my code is apread out enough ... do I need to spread it out more?
01:15:12 <AaronFriel> Well, yeah, I think you can just expect Haskell to compile slowly in some cases. It might be worth seeing if you can remove some "deriving (..)" that are unnecessary
01:15:12 <peddie> ttt_fff: OK, I think using Generics to create instances for you can also cause some slowdown at compile time
01:15:23 <julianleviston> ttt_fff: oh, apologies!
01:15:37 <ttt_fff> okay, I can eliminate "deriving (Show)" ... how do you eliminate "deriving (Ord)" ... dyou write them manually ?
01:15:45 <ttt_fff> julialeviston: np, thanks for trying to help
01:15:46 <peddie> ttt_fff: you could test removing some instances to see whether that's what's causing the slowdown
01:15:46 <AaronFriel> ttt_fff: 2400 lines over 30 files is a decent spread. 
01:15:59 <peddie> oh AaronFriel just suggested that, sorry :)
01:16:04 <AaronFriel> ttt_fff: Yes, you can implement Ord manually
01:16:13 <AaronFriel> ttt_fff: Are you using any language extensions? 
01:16:57 <ttt_fff> I am using the following extensions:  default-extensions:    TypeSynonymInstances, BangPatterns, ViewPatterns, DeriveGeneric, MultiParamTypeClasses, ExplicitForAll, ExistentialQuantification, NoImplicitPrelude, InstanceSigs, FunctionalDependencies, OverloadedStrings, TypeSynonymInstances, FlexibleInstances, FlexibleContexts, ConstraintKinds, ScopedTypeVariables, DefaultSignatures, TypeOperators, StandaloneDeriving, CPP, Arrows, Tem
01:17:05 <julianleviston> AaronFriel: template haskell?
01:17:07 <ttt_fff> the last one is "LambdaCase" ... is that too many ?
01:17:20 <ttt_fff> I ahve "TemplateHaskell" but I'm not actually using it
01:17:54 <AaronFriel> ttt_fff: That's a lot
01:18:13 <AaronFriel> ttt_fff: And TemplateHaskell adds another set of steps to generating your code. Do you use all of those extensions?
01:18:29 <AaronFriel> ttt_fff: And are you using those extensions in *every module*? 
01:18:43 <ttt_fff> no, but I prefer to add them to *.cabal rather than to each *.hs file
01:19:12 <AaronFriel> ttt_fff: Not every extension has a performance hit, but some of them might take you down some unoptimized paths in the compiler
01:19:28 <AaronFriel> ttt_fff: You might benefit from putting them only in the .hs files that need them, but I can't say for certain
01:19:57 <ttt_fff> after removing (deriving Show), I'm down to 11.8s sec (from 12 sec) ... but this could just be noise
01:20:06 <AaronFriel> ttt_fff: probably noise
01:26:29 <Wizek> Is it possible to use an earlier version of a library in itself with cabal?
01:28:19 <ttt_fff> AaronFriel: hmm, changing  langauge etensions from 4 lines to merely 1 line = 12 secs -> 8.73 secs ... I don't think this is noise
01:28:34 <ttt_fff> AaronFriel: is it normal to use langauge extnesions on a per file basis? (I'm considering and willing to do this if it speeds up my code)
01:29:56 <AaronFriel> ttt_fff: I'm not sure if I can speak with certainty on "normal", but it's VERY common in libraries I've seen to have extensions on a per-file bais
01:29:58 <AaronFriel> basis*
01:30:18 <AaronFriel> ttt_fff: Did you try removing TemplateHaskell as well?
01:30:23 <ttt_fff> this actually baffles me, taht you can link together a binary where the modules are 'different lagnuage extensions'
01:30:28 <ttt_fff> yeah, removed TemplateHaskell
01:30:46 <AaronFriel> ttt_fff: Well, the trick is that each file is parsed down to a language that's a lot like Haskell before it's actually compiled
01:30:59 <AaronFriel> ttt_fff: The language extensions just turn on extra parsers that turn things into that language (called Core)
01:31:19 <AaronFriel> ttt_fff: Generally speaking... there are other extensions that change type checking rules, or add compilation steps
01:31:46 <mauke> you can even link together a binary where the modules are written in different languages
01:31:56 <mauke> like haskell + C
01:32:12 <frerich> AaronFriel: You already have types 'Client' and 'Admin' which wrap some C handles, right? Given that you have only two implementations of the class and that it doesn't sound like you plan to add more, can't you go for something like http://lpaste.net/137251 ?
01:32:15 <AaronFriel> Sure, but I think the confusion is that they can do this without having to do FFI
01:32:53 <AaronFriel> frerich: Maybe? I have a lot of intermediate code in "Core.hs" that operates on either type
01:33:04 <frerich> AaronFriel: I.e. you have separate functions if you want to do separate things (and yield separate error codes), you have functions like 'createTable' which take a specific kind of connection and you can have a 'Connection' wrapper type for code which works with either kind of connection.
01:33:27 <AaronFriel> frerich: Let me link you to an example of something uly
01:33:28 <AaronFriel> ugly
01:33:37 <AaronFriel> ugh really need to figure out why my g key isn't working
01:34:19 <AaronFriel> frerich: https://github.com/AaronFriel/hyhac/blob/testfail/src/Database/HyperDex/Internal/Core.hs#L58-L76
01:34:41 <AaronFriel> frerich: https://github.com/AaronFriel/hyhac/blob/testfail/src/Database/HyperDex/Internal/Core.hs#L295-L311
01:34:59 <AaronFriel> frerich: So my event loop code is agnostic (works for both)
01:35:05 <frerich> AaronFriel: Right, that would still work, no?
01:35:29 <AaronFriel> frerich: hm
01:35:51 <AaronFriel> frerich: I don't see how, the loop returns a ReturnCode
01:35:59 <AaronFriel> frerich: And I have to handle it generically
01:37:04 <AaronFriel> frerich: Line 301 of Core.hs: (h,rc) <- loop ptr timeout
01:37:49 <ttt_fff> hmm, instead of running "time cabal build" is there a way I can get cabal build to report compile time vs link time vs other time? by eyeballing, it appears > half of the time is spent linking
01:39:54 <AaronFriel> frerich: I'm sorry, it must be frustrating for me to take what you're saying and go, "Hmm, I don't know"
01:40:24 <AaronFriel> frerich: But I honestly don't, it may be that I am doing the smart thing, but it seems more likely to me I am not and I do not see it.
01:40:42 <AaronFriel> ttt_fff: I don't know if there is
01:41:19 <AaronFriel> ttt_fff: Is cabal build re-using already compiled modules?
01:41:29 <AaronFriel> ttt_fff: I don't know if there's a flag or something that might break that
01:41:40 <ttt_fff> AaronFriel: I do  "cabal clean" before every "time cabal build"
01:42:30 <AaronFriel> ttt_fff: Ah, that's almost always unnecessary.
01:44:07 <AaronFriel> ttt_fff: cabal build will detect whether it must recompile files - it does this in a rather dumb but straight-forward way, if the file has changed, recompile it
01:44:36 <ttt_fff> I guess overlaoded strings also slows things down
01:44:43 <ttt_fff> forcing the compiler to infer the type of the string
01:45:38 <peddie> ttt_fff: no more than any other situation where it has to choose an instance, right?
01:46:18 <ttt_fff> peddie: hmm, true
01:46:26 <ttt_fff> peddie: it sholud be negeliglble
01:46:27 <AaronFriel> ttt_fff: That should be a small part of the compiler's work, I would expect unless you have some really pathological looking code
01:47:58 <ttt_fff> AaronFriel I do have a "type Blah s a = RWST () () s (Log a)" and I have a bunch of code which requires inferring states of this monad
01:48:27 <AaronFriel> ttt_fff: That doesn't sound like it would be a problem for the typechecker
01:48:54 * hackagebot gipeda 0.1.2.1 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.1.2.1 (JoachimBreitner)
01:51:06 <ttt_fff> what's the ghc flag for include-dirs ?
01:51:11 <ttt_fff> it's not --include-dirs=.
01:53:07 <frerich> AaronFriel: I think just like you have a 'unifying wrapper' for Admin & Client, you could have the same for the different return codes, i.e. 'data ReturnCode = ClientReturnCode ClientCode | AdminReturnCode AdminCode'. The different  return values could then be wrapped into that. Something like in http://lpaste.net/137254 maybe (note how loopClient and loopAdmin have different signatures, but loopGeneral glues them).
01:53:26 <frerich> AaronFriel: Sorry for the delayed responses, I'm at work, ahem. :-]
01:54:04 <ttt_fff> ha!
01:54:06 <frerich> AaronFriel: I just find it interesting to try refactoring stuff such that there are no typeclasses anymore. Sometimes it turns out that they are really useful but more often than not the typeclass-free version looks pretty neat (to me).
01:54:06 <ttt_fff> I got it down to 2 seconds
01:54:12 <ttt_fff> (started at 27 seconds about a hour earlier)
01:54:19 <ttt_fff> the trick: runhaskell, fuck cabal run :-)
01:55:09 <AaronFriel> ttt_fff: Awesome, but "runhaskell" probably does not recompile on each step
01:55:27 <peddie> ttt_fff: that's not compiling at all, that's using the bytecode interpreter
01:55:41 <ttt_fff> yeah, I just need it run quicklyto get result so I can debug + write more code
01:55:45 <AaronFriel> frerich: that looks decent. I'm not sure if I would switch to it, because of the convenience of the typeclass
01:55:53 <ttt_fff> this is for iterative coding, I need fast results, not a fast binary
01:55:59 <peddie> ttt_fff: yeah, understood
01:57:21 <peddie> ttt_fff: oh sorry I meant that for AaronFriel 
01:57:29 <AaronFriel> frerich: But it's elucidating to see how it can be decomposed in that way. But I think based on what you wrote, I may be doing it the "right" way, for a certain definition of "right", which is that the "Core" library doesn't have to depend on the "Admin" or "Client" libraries, and I can extend it with a "MockClient" later
01:57:41 <ttt_fff> peddie: you mean you agree with AaronFriel but disagree with me?
01:57:45 * ttt_fff arms nukes
01:58:02 <peddie> no, I meant to tell him that it's not compiling at all
01:58:15 * ttt_fff disarms nukes
01:58:34 <ttt_fff> yeah, it's just interpreting I hear thats why ahskell platform is so large, it's lnked 4 times, ghc, ghci, runghc, and osmething else
01:59:29 <ttt_fff> I have also figured out why, coding in haskell, becomes less fun when it's past 2K LOC
01:59:43 <ttt_fff> becuase, at that point, the compile time slows down, and becomes annoying since it's not as interactive
02:03:59 <frerich> AaronFriel: I basically follow a bottom-up approach: I define basic types like Client or Admin and the plausible functions for those types and later provide a 'generic' layer on top which usually also goes with a corresponding generic layer of unifying types.
02:04:22 <michel_slm> ttt_fff: does having more but smaller modules help?
02:04:55 <ttt_fff> michel_slm: I don't know, have not performed that test
02:05:27 <frerich> AaronFriel: But I learned a new word now - 'elucidating'. :-)
02:07:07 <AaronFriel> frerich: That strategy makes a lot of sense. My biggest concern is that someone would look at this library and not know how to hack on it because of data families.
02:07:31 <frerich> AaronFriel: If I have code which I want to be able to work with one of two different things, I usually introduce a new wrapper type 'data EitherOfTheTwo = This Int | That Bool'. My first reflex is to not use type classes. :-}
02:07:50 <AaronFriel> frerich: But I do think they significantly improve the ergonomics, because all the types are nicely constrained, Admin connection implies ReturnCode Admin type.
02:10:33 <frerich> AaronFriel: Yeah that's true. However, one strategy to deal with that is to pass the functions which a general function like loopGeneral is defined in terms of as arguments. Maybe some people call this dependency injection.
02:11:05 <frerich> AaronFriel: E.g. if you have some function which requires looping a connection, and it only gets a connection for the looping, then you may just as well pass the looping function directly.
02:11:28 <AaronFriel> frerich: ah, yeah I can see that working
02:11:47 <frerich> AaronFriel: Something like 'loopGeneral :: CInt -> Connection -> IO (Either ReturnCode Handle)' becoming 'loopGeneral :: CInt -> (Cint -> IO (Handle, a)) -> IO (Either a Handle)' or so.
02:11:50 <AaronFriel> frerich: But there is a reason I cannot do that easily with the connect objects, which is that they are not thread safe in the Haskell sense
02:12:27 <frerich> AaronFriel: ...such that loopGeneral no longer defines any particular error code type but rather yields whatever the concrete looping function does.
02:12:45 <AaronFriel> frerich: But I think what you're describing is essentially manual typeclasses, right?
02:13:06 <AaronFriel> frerich: Passing in a data structure that defines the appropriate functions to use in various cases
02:14:09 <frerich> AaronFriel: I think there are some parallels but I seem to recall a StackOverflow posting by Lennart Augustsson where he gives a couple of reasons of how they differ.
02:14:30 <frerich> I'll try to find it again, IIRC that was what made me no longer think they are 'basically equal'. :-)
02:16:36 <quicksilver> AaronFriel: "functions to use in various cases" is just a dictionary
02:16:51 <quicksilver> or, I mean, it's just a perfectly natural construct in any language with first class functions
02:16:55 <AaronFriel> quicksilver: That was my intended observation
02:17:06 <quicksilver> a typeclass is where the *compiler* chooses the dictionary based on its type inference
02:17:09 <quicksilver> that's the link
02:17:31 <quicksilver> typeclasses are a specific technique where you want to feedback some information from the type inference process
02:17:42 <quicksilver> whereas passing functions around is a more general/basic technique
02:18:12 <tomjaguarpaw> shirt: To ask questions about Opaleye best to contact me via the email address in the README https://github.com/tomjaguarpaw/haskell-opaleye/ or file an issue on GitHub https://github.com/tomjaguarpaw/haskell-opaleye/issues
02:18:28 <blumpking> How does Haskell compare to Python as a first language? Everyone always strongly recommends I learn Python first, but I want to learn Haskell. If it's not as a good of a first language as Python though...
02:18:35 <ttt_fff> so I'm now wondering if 1000 lines of *.hs / second is reasonable, or if I should try to force for me
02:18:41 <ttt_fff> s/for me/for more
02:18:59 <benma> blumpking: as always, the answer is: it depends ;)
02:19:35 <frerich> AaronFriel: Alas(?) augustss wrote too many answers about Haskell questions on StackOverflow, I cannot find his answer anymore. I seem to remember that somebody said that you could always use a type class if you currently pass a dictionary of functions (or vice versa?) and he gave a couple of interesting reasons how it's different.
02:19:42 <frerich> Pity I cannot find it again...
02:20:59 <quicksilver> frerich: one such example is that typeclasses like Functor and Monad require a kind of polymorphism which is not available in haskell98
02:21:01 <frerich> I really wish I would learn how to bookmark properly. Most of the pages I bookmarked I never visited after I bookmarked...
02:21:26 <frerich> And then I have pages which I do use frequently (like the 'existensial typeclass antipattern') thing and I just rely on browser history. :-)
02:21:45 <quicksilver> so typeclasses like that amounted to a way of smuggling some higher polymorphism into the language.
02:22:05 <quicksilver> a specific, restricted way, which was still compatible with the type inference we already had.
02:22:58 * frerich should maybe just ask this exact question and then hope that augustss sees it :-)
02:24:57 <frerich> quicksilver: Maybe you are indeed spot on. The only thing I could find was a comment by him where he (in response to somebody who wrote that type classes can be almost trivially converted to simple data-types that are explicitely passed around)  commented "Type classes can not be transformed to data types if you want the translation to remain Haskell (1.0 - 98) since method can have additional type variables in addition to the class type
02:24:57 <frerich>  variable."
02:25:13 <frerich> (in a comment to http://stackoverflow.com/questions/9602176/why-were-type-classes-difficult-to-implement/9604386#9604386 )
02:25:24 <quicksilver> yes
02:25:36 <quicksilver> I'm really rusty at haskell and I"m scared of getting the details wrong
02:25:47 <quicksilver> but I think you end up with records with polymorphic parameters
02:25:56 <quicksilver> and that's higher rank polymorphism which isn't haskell98
02:26:11 <blumpking> anyone have a link to a file io program in haskell?
02:26:18 <blumpking> is it as easy to do as it is in C?
02:26:26 <peddie> :t readFile
02:26:27 <lambdabot> FilePath -> IO String
02:26:32 <peddie> :t writeFile
02:26:33 <lambdabot> FilePath -> String -> IO ()
02:26:41 <quicksilver> and in general we can't do the type inference for that kind of polymorphism - but because of the specific setup typeclases give you, with class being declared explicitly, it's OK.
02:27:02 <indiagreen> int-e: if I want to make a pull request for lambdabot, should I do it against master or freenode?
02:27:35 * indiagreen reads the readme
02:27:37 <indiagreen> nevermind
02:30:13 <blumpking> For a beginner, is Haskell as hard as C?
02:30:29 <CoconutCrab> different kind of 'hard to learn' IMO
02:30:33 <kuribas> blumpking: it's hard in a different way.
02:30:36 <voidzero> i guess it depends more on the beginner than the subject material
02:31:46 <voidzero> for me both are equally hard :D
02:31:49 <kuribas> blumpking: in C you have to learn low level concepts, such as memory management, pointers, the stack, etc...  In haskell it's about abstractions and high level concepts.
02:32:22 <indiagreen> blumpking: for me, it was easier because learning Haskell was actually fun and C wasn't, but obviously you might have a different idea of fun so perhaps you should spend a week on C and a week on Haskell and see what you like more
02:32:42 <muzzle> blumpking It's easier to do something in C. Haskell makes your life harder, but that doesn't have to be a bad ting because it forces you to really think about your programs structure. So I would say haskell forces you to do things in a safe and thought out manner, that avoids problems later on.
02:32:47 <quicksilver> they're both a pain to debug :) but in C you have programs which crash for no apparent reason, possibly due to a piece of buggy code in a different subroutine run some time ago. Whereas in haskell you instead have code that doesn't compile due to an error message you don't understand :)
02:33:22 <kuribas> quicksilver: I actually found C harder to debug.
02:33:53 <Guest78379> hi all, I am trying to find a sort of "best practice" about a simple task
02:34:25 <Guest78379> I need to "manage" a global configuration across the application
02:34:29 <voidzero> to me C seems to be more arbitrary than Haskell
02:34:32 <kuribas> blumpking: both languages have their use, it's always good to know about low level stuff, even if you program in a higher level language.
02:34:47 <kuribas> voidzero: C is more bare to the metal.
02:34:59 <Guest78379> anyway this configuration should be initialized first, when the app starts
02:35:02 <kuribas> It was originally meant as a "portable assembler".
02:36:00 <Guest78379> the conf is just something like :Conf  {baseDir::FilePath}
02:36:09 <voidzero> yes, what I mean is that with Haskell you can rely on a mathematical foundation
02:36:48 <kuribas> muzzle: I find haskell easier than C for most stuff.
02:36:53 <Guest78379> and baseDir should be init at the starting with : getHomeDirectory + "something"
02:37:23 <Guest78379> what the best way to do it? Using reader monad doesn't look enough
02:38:01 <peddie> Guest78379: what's wrong with the Reader monad?
02:38:12 <kuribas> muzzle: because in C there is no tail-call optimization, no higher order functions, etc...
02:39:15 <blumpking> So, if I have a mathematical background (up to Algebra II), Haskell come easier to me than C? Or rather, will it be more fun?
02:39:28 <blumpking> * will Haskell come
02:40:45 <quicksilver> hard to predict what is more fun :) I think haskell is lots of fun, but then I learnt C more than 20 years ago.
02:40:47 <Guest78379> peddie: how can I init the data in Conf first?
02:40:53 <quicksilver> I found C pretty fun and exciting when I learn it.
02:40:55 <kuribas> blumpking: define fun :)  I find coding a complex application in haskell more fun than in C, but I can use C to program a microcontroller, which is also fun.
02:41:30 <ibid> in fact, C was not meant to be a portable asembler. it was meant to be a high-level language for writing systems software because assembler was dreary
02:41:35 <kuribas> blumpking: it's nice to know how the computer works underneath all the abstractions.
02:41:47 <peddie> Guest78379: you can set up your Conf and then use 'runReader' to pass it to some actions that need the configuration
02:42:47 <hasknoob> peddie: the problem is I would like to avoid to pass the "Conf" around the functions
02:43:04 <peddie> so you would like your functions to use some configuration data, but you don't want them to know about it?
02:43:14 <peddie> that sounds like a tough problem indeed
02:43:20 <hasknoob> yes
02:43:31 <peddie> how can they use it if they don't know about it?
02:44:03 <hasknoob> they know the "reader monad"
02:44:17 <quicksilver> my actual advice - especially if you're pretty new to haskell - is to make Conf an argument to every function.
02:44:18 <ttt_fff> I have a makefile. the makefile ahs two lines: "default:\n\t runghc ...", how for some weird reason, everything works when I type "make" from the shell, but does not work when I type "make" from inside vim (complaints about packages not being found) ... so apparently, when calling "make" from (1) inside vim and (2) from the shell, the envi varaibles differe, and this causes runghc to behave differently
02:44:18 <hasknoob> reading around that was one of the suggested solutions
02:44:36 <quicksilver> the reader monad is only a way of concealing that argument to every function
02:44:46 <quicksilver> and depending how you write the code
02:44:50 <quicksilver> it doesn't conceal it entirely.
02:45:01 <peddie> hasknoob: I'm having trouble understanding what you want to do and why the reader monad won't help you, maybe quicksilver has a better idea :)
02:45:07 <quicksilver> make it an argument to every funciton and once you're happy with how it works
02:45:13 <quicksilver> then by all means refactor to the reader monad
02:45:20 <quicksilver> it's a learning experience and you'll understand the reader monad that way.
02:46:09 <hasknoob> at the moment I have this "Conf" passed around a few functions
02:46:44 <hasknoob> to read the value from Conf I m just using "baseDir conf" in a sort of "get" function
02:47:14 <hasknoob> using a Reader Monad, how could improve it?
02:49:45 <eikke> is there a way to generate a (large) static/constant Vector at runtime (e.g. at first use), and be 100% sure it'll never be GC'ed?
02:49:58 <peddie> hasknoob: you can change your function of type   Conf -> a -> b   to be of type    a -> Reader Conf b   and pull out the configuration data using 'ask' within the function
02:50:26 <mpickering> Is it better to only specify lower bounds to also specify upper bounds in a cabal file
02:51:05 <peddie> hasknoob: this saves you having to manually deal with the Conf (you only have to manipulate it where it's used), but it keeps it in the function's type so the compiler can make sure your function is never called without some Conf available
02:51:23 <quicksilver> peddie: and then you have to use monadic style to write the function
02:52:25 <quicksilver> one possible way to do that is to use the 'asks' combinator
02:52:31 <quicksilver> which embeds a funciton in the reader monad
02:52:34 <quicksilver> with an explicit parameter
02:52:40 <peddie> quicksilver: well, you have to use one 'fmap'
02:52:45 <quicksilver> ...which makes it look exactly like the code you started with
02:52:45 <peddie> oh, sure, asks is fine too
02:52:58 <quicksilver> so your parameter is explicit again
02:53:04 <quicksilver> and you haven't hidden 'Conf' at all :)
02:53:17 <peddie> well, you have hidden it everywhere you're not accessing it directly
02:53:58 <quicksilver> My recommendation remains, write the code directly, then rewrite it as Reader, and compare the two. You learn about how the Reader monad works.
02:54:10 <quicksilver> and you see how little Reader saves you on its own, in most cases.
02:54:17 <quicksilver> is does depend what your code looks like though!
02:54:19 <peddie> this person already said he or she is passing the Conf around manually
02:54:26 <quicksilver> it works a lot better if you were already in a monad
02:54:37 <quicksilver> because then you'd already reconciled yourself to that style of code
02:54:48 <quicksilver> and adding an 'extra' functionality into your monad is easy
02:56:51 <kuribas> Related, has the monad reader magazine stopped?
02:58:56 <int-e> indiagreen: it should be against master; I'm rebasing the freenode branch all the time, so it's a bad starting point
02:59:25 <hasknoob> Ok thanks. I will rewrite it using the Reader, checking eventually the differences
03:01:28 <blumpking> Can anything that is doable in Python be done in Haskell?
03:01:44 <blumpking> If so, I'm most definitely going to be learning Haskell. :)
03:01:51 <blumpking> I NEED to know.
03:02:11 <peddie> blumpking: I don't know of anything you absolutely can't do
03:02:52 <CoconutCrab> blumpking: aside from bumping into runtime exception every 10 lines of code, I don't see anything else that python can do but haskell can't
03:03:30 <peddie> some particular tasks might be more straightforward in one language than the other
03:03:43 <quicksilver> python has different libraries to haskell
03:03:50 <quicksilver> I know I'm stating the obvious but
03:04:04 <quicksilver> lots of the times when people choose python for a project it's because of a specific library or framework they wish to use
03:05:09 <kuribas> blumpking: if you are doing numeric computing, numpy is hard to beat.  But it is certainly possible in haskell.
03:06:24 <kuribas> blumpking: only you will have to pick a library to fit that has your algorithm.  Also python comes by default on the raspberry pi, while installing haskell is a lot harder.
03:07:13 <kuribas> blumpking: for most projects, haskell is a good fit though.
03:07:23 <indiagreen> kuribas++
03:09:24 <raichoo> I've seen people using Haskell on a RasPi. Dunno how hard that is though. Not my cup of tea ^^
03:09:37 <blumpking> kuribas: Sweet!
03:10:12 <raichoo> I think the "hardest part" was waiting for things to compile :D
03:10:17 <CoconutCrab> raichoo: raspberry pi has native support for ghc (although ghci is not available)
03:10:38 <raichoo> IIRC Rapsian has ghc in the repos.
03:10:47 <CoconutCrab> it's a bit dated though, 7.4 IIRC
03:10:48 <raichoo> Raspian… dunno
03:11:14 <raichoo> Good to know.
03:14:37 <kuribas> raichoo: nice!  I wonder how easy it is to program the pi with haskell though.  Python comes with an IDE and has support for GPIO
03:16:02 <quicksilver> kuribas: https://hackage.haskell.org/package/HPi-0.4.0/docs/System-RaspberryPi-GPIO.html
03:16:08 <quicksilver> kuribas: I mean I haven't used it, I just googled :)
03:16:08 <raichoo> kuribas: A friend of mine build a sitecrawler running on the Raspi. That's about it. I've never done anything with RasPi. It's not scratching any of my itches :)
03:19:02 <kuribas> I have connected it to my HiFi installation and an external harddisk, so I have a digital media player :)
03:26:14 <Guest93874> kuribas: programmed in Haskell?
03:26:20 <Guest93874> Or just Python?
03:27:10 <kuribas> Guest93874: no in C: http://www.musicpd.org/
03:27:46 <Guest93874> Ah I see.
03:30:50 <kuribas> Aejay: I didn't program any of it though...
03:31:13 <Aejay> kuribas: Maybe it'd be interesting to make a HS translation?
03:32:43 <kuribas> Aejay: yeah, it could be possible to control mpd from haskell, though I have no use for it.
03:40:37 <blumpking> Are the people who say Haskell is hard mostly imperative programmers?
03:40:51 <tzaeru> that's an odd question.
03:41:09 <Wizek> Can I make a parsec parser return the all the matched string exactly, without having to explicitly return it?
03:41:14 <Axman6> they're mostly people who haven't tried to learn Haskell, or haven't tried very hard
03:41:47 <saep> The learning curve is relatively steep, but totally worth it (IMHO).
03:42:17 <maerwald> Axman6: uh? haskell _is_ hard to learn
03:42:19 <tzaeru> Axman6, naa, don't fall to the fallacy that just because we eventually learn something, it can't actually be ahrd :P
03:42:25 <tzaeru> **hard
03:42:28 <maerwald> especially for people who haven't done any prior FP
03:42:46 <Intolerable> Wizek: there's a combinator somewhere for that
03:42:55 <Intolerable> i can't remember if its parsec or atto though
03:42:57 <blumpking> I've only dabbled with the language for 20 mins and I can do this: (succ (1 + 1) + min 3 2) `elem [1,2,3,4,5]
03:43:06 <maerwald> that's one of the major problems of haskell... things that are easy to do in other languages (like "lenses" in OOP) require you to learn a whole new DSL in haskell
03:43:08 <Intolerable> give me a minute
03:43:11 <blumpking> It's not that too hard.
03:43:21 <ttt_fff> blumpking: haskell is easy to learn 'idioms'
03:43:26 <ttt_fff> but when you start to write a big project
03:43:35 <ttt_fff> you run into all thpes of "WTF, this was trivial in OO; why is it so fucking ahrd here" ?
03:43:40 <ttt_fff> what do you mean? I need a StateMonad?
03:43:42 <ttt_fff> IOREF?
03:43:45 <maerwald> right
03:43:46 <ttt_fff> what" no singleton?
03:43:51 <blumpking> Haskell's my first lang
03:44:21 <kuribas> maerwald: but then lenses are more powerfull than their OO equivalent, right?
03:44:41 <maerwald> kuribas: I have no idea, I guess so. I avoid lenses whenever I can.
03:44:48 <saep> I think, that the extra time you need to understand things pays of mid-term. You just don't have so many (if any) nasty runtime bugs that are hard to track down.
03:44:51 <chpatrick> Intolerable: Wizek: it's called match in attoparsec
03:44:53 <maerwald> unless some library forces me to use them
03:44:59 <ttt_fff> lens are awesome
03:45:00 <ttt_fff> I like them
03:45:07 <maerwald> ttt_fff: but then again... when I see how you write a Tree in ruby, then I think "wtf, I want to go back to haskell"
03:45:21 <tzaeru> even thou I mostly have lenghtyish background in imperative/non-FP-structured languages and seem to suck in learning Haskell, I'd really put blame of the hardship on a lack of any kind of mathematical background :P
03:45:22 <ttt_fff> maerwald: I'm never goign to leave haskell
03:45:36 <ttt_fff> either I find a way to make money from haskell, or you see me on the streets with a sign saying "will cod ehaskell for food"
03:45:38 <tzaeru> like I don't even know wtf people talk about half the time with all that queer terminology.
03:45:43 <ttt_fff> not switching back to imperative langauges
03:45:49 <Aejay> ttt_fff: You've made the right choice!
03:45:57 <Aejay> ttt_fff: It's addictive, though...
03:46:09 <indiagreen> kuribas: they are, but the thing is that when you want to do something simple, having a simple tool is better than having an all-powerful tool which takes slightly longer to understand
03:46:30 <maerwald> not just slightly
03:46:31 <indiagreen> and Haskell is full of these all-powerful tools like lenses and conduits and parser combinators
03:46:57 <kuribas> indiagreen: what would you use for getting or modifying fields in nested structures?
03:47:09 <maerwald> .
03:47:12 <chpatrick> they're simple once you understand them though
03:47:22 <tzaeru> chpatrick, understanding something doesn't make it simple..
03:47:30 <chpatrick> I'll take figuring out a monadic parser over a regex anyday
03:47:43 <chpatrick> or some hand-written parser
03:47:53 <chpatrick> even if they're simpler conceptually
03:48:08 <kuribas> I find it usually easier to understand unknown haskell code than unknown C code.  
03:48:15 <chpatrick> very much this
03:48:23 <ttt_fff> chpatrick: I like regexes (from vim days) but ... OMG, parsec is awesome
03:48:35 <chpatrick> wait till you try atto ;)
03:48:46 <Aejay> ttt_fff: I once remade parsec from scratch... sooo much fun!
03:48:49 <kuribas> ttt_fff: I like regexes, but they are write-only :-)
03:48:53 <chpatrick> although parsec is really nice for parsing code
03:49:00 * hackagebot shortcut-links 0.4.0.0 - Link shortcuts for use in text markup  https://hackage.haskell.org/package/shortcut-links-0.4.0.0 (Artyom)
03:49:00 <chpatrick> since you get so much for free
03:49:00 <ttt_fff> chpatrick: no, atto is not good for pasring programming langauges
03:49:11 <chpatrick> although you might get that with ekmett's parsers too
03:49:15 <ttt_fff> kuribas: yeah, but it's mostly "s/REGEX/otherpattern/g"
03:49:20 <Aejay> Attoparsec is *faster*, but not as usable.
03:49:28 <ttt_fff> my vim regexes are write once, execute once, read never again
03:49:34 <chpatrick> ttt_fff: http://hackage.haskell.org/package/parsers-0.12.2.1/docs/Text-Parser-Expression.html
03:49:50 <Aejay> ttt_fff: You're so right.
03:49:56 <ttt_fff> chpatrick: that part of parsec I do not yet understand
03:50:07 <chpatrick> that's not even parsec
03:50:08 <ttt_fff> Aejay ++ // for brilliance of realizing how right I am
03:50:13 <tzaeru> one thing that probably makes many people deem haskell is hard is the fact how non-verbose it is. there's a lot of information you need to process from one line. there's a lot of different syntatical symbols used in a small amount of code. I feel there's much less needed to be known to read a line of C at a time than reading a line of Haskell
03:50:22 <tzaeru> given that the two projects are decently complex.
03:50:23 <chpatrick> it's the cool parsec language parsing stuff generalized over any parsing library
03:50:42 <chpatrick> tzaeru: the nice thing is that there's way less context in haskell
03:50:46 <Intolerable> tbh i find atto a lot easier to use than parsec
03:50:49 <chpatrick> if you look at a function you can usually see where all the data goes in and out
03:50:52 <ttt_fff> chpatrick: you're right, I misread it
03:50:58 <chpatrick> with most languages there's a ton of global state
03:51:20 <ttt_fff> with haskell, it's all stored in th emonad
03:51:23 <ttt_fff> so it's explicit
03:51:23 <chpatrick> and in C it's also non-trivial to figure out where stuff gets included
03:51:29 <tzaeru> chpatrick, there's less context as in less side-effects within the project itself, but there's perhaps more you have to know about the language and so and more symbols to connect around in your poor brain.
03:51:52 <kuribas> tzaeru: that's not necessarily bad
03:51:53 <chpatrick> I don't know if you need to know more about the language
03:52:05 <tzaeru> so while you don't have to know as much about the surrounding code to read a line of haskell code, you do need to know a lot more about haskell to read haskell effectively than you'd need to know about C to read C effectively
03:52:13 <chpatrick> in C you need to know why you can't return a pointer to a stack variable
03:52:19 <ttt_fff> yeah
03:52:30 <ttt_fff> starting out, it's like >>=, <<, <$>, <*>, .... WTF
03:52:31 <chpatrick> which is a pretty low-level thing
03:52:31 <chpatrick> lots of gotchas
03:52:31 <tzaeru> well, yea, the pointer thingy can be a bit confusing
03:52:52 <ttt_fff> tzaeru: you're so right
03:52:59 <chpatrick> I'm sitll not sure
03:53:07 <Nux__> on https://wiki.haskell.org/Arrow_tutorial the line before section "7 Tutorial Meta" says "x ++ (f x) ++ (g x) ++ ((g . f) x) which are all permutations of using arrows f and g.". Surely the author means combinations. Is there a way for me to change this?
03:53:08 <kuribas> chpatrick: or why you can but shouldn't?
03:53:11 <ttt_fff> oh, then ther'es foldl, foldr, ... which makes me go "I understand what that function does ... but I can't believe you can apply it like taht"
03:53:15 <ttt_fff> together with slicing
03:53:20 <chpatrick> kuribas: sure
03:53:43 <julianleviston> tzaeru: what’s “the pointer thingy” ?
03:53:49 <chpatrick> I think C maybe isn't the right comparison
03:53:53 <Aejay> chpatrick: Gotchas? I just wouldn't put up with it.
03:53:55 <chpatrick> but what about some really gnarly template stuff in C++
03:53:55 <julianleviston> tzaeru: I mean “what are you referring to?”
03:53:57 <tzaeru> julianleviston, pointer arithmetics in C
03:54:02 <julianleviston> tzaeru:  ah
03:55:05 * Aejay loudly proclaims Haskell's awesome power and majesty.
03:55:13 <tzaeru> chpatrick, yea, it's not a good comparison. something like Python might be better, since then we'd be talking about two languages meant to have high-level abstractions and tools.
03:56:41 <kuribas> what's the purpose of "to" in lens?
03:56:55 <Nux__> also on the talk page of https://wiki.haskell.org/Arrow_tutorial , Prokyon seems to be assuming that you can 'do more' with a more general object. It seems to me that 'do more' here actually means 'can assume more about'
03:57:19 <kuribas> > view (to (+2)) 3 == 3+2
03:57:21 <lambdabot>  True
03:57:38 <tzaeru> ...I still need to find some time to dwell into haskell more properly. I do regret not having focused on math properly in school.
03:57:47 <Nux__> Haskell is awesome power and majesty?
03:57:57 <indiagreen> kuribas: “to” just makes a getter out of an ordinary function, it's useful sometimes in lens chains
03:58:06 <chpatrick> tzaeru: I don't think school math helps much tbh
03:58:07 <kuribas> ah, makes sense
03:58:15 <chpatrick> unless you took category theory :)
03:58:17 <tzaeru> chpatrick, universities are schools :P
03:58:27 <kuribas> tzaeru: it's a misconception you need math for haskell, anymore than you need it for any other language.
03:58:38 <chpatrick> I don't know if my university math helped
03:58:50 <chpatrick> maybe formal logic
03:59:15 <tzaeru> kuribas, haskell uses a lot more concepts from certain fields of math and ties more closely to using symbols with similar meaning.
03:59:18 <chpatrick> also courses about semantics
03:59:25 <chpatrick> type systems and models of computation
03:59:50 <kuribas> tzaeru: it does, but do you need it if you don't do research?
04:00:17 <tzaeru> I'd imagine it'd make learning a lot faster.
04:00:22 <tzaeru> or at least a little bit.
04:00:23 <julianleviston> kuribas: you don’t need math, but you end up knowing half of category theory whether you like it or not.
04:00:51 <kuribas> haha, right
04:01:52 <julianleviston> kuribas: well, if you can use the map operation on a thing that you can use it on, in other languages you just call it a “collection”. In haskell you end up calling it a Functor, right?
04:02:35 <tzaeru> I mean, even the function notation is pretty much the same as used in math
04:02:37 <julianleviston> kuribas: it’s much more explicit about its meanings, and so you end up knowing a meta-language...
04:02:39 <tzaeru> it's not same in most other languages.
04:02:48 <julianleviston> tzaeru: isn’t it?
04:03:48 <tzaeru> no, instead of "f :: Int -> Int" (or, in common math notaton, f : x -> y) you might have say, "int my_function(int x){}"
04:04:10 <chpatrick> that's just c-like stuff though
04:04:29 <julianleviston> tzaeru: No, I’m not talking about function application. I’m talking about fmap/map.
04:04:38 <julianleviston> tzaeru: map in clojure or javascript is pretty similar… isn’t it? you can map over a set, or a hashmap, or a list, or a vector… but in other languages you don’t have to know what you’re doing at a meta-level. Haskell makes you know.
04:05:53 <tzaeru> julianleviston, mmh, isn't it just my_object.map(my_func); in javascript..
04:06:11 <Aejay> julianleviston: That's a good thing. When you don't understand what's going on, you may create undesired side-effects. In Haskell, you can learn how it works, and quickly forget about the details using monads.
04:06:16 <julianleviston> tzaeru: assuming there’s a map function on my_object, sure…
04:06:31 * indiagreen is meanwhile trying to use Parsec after not having used it after a while and thinking “why, why does nobody care about usability”
04:06:38 <indiagreen> * for a while
04:06:39 <julianleviston> Aejay: I completely agree… I love that you know what you’re doing in haskell - that’s the primary reason it improves our ability to code.
04:07:27 <Aejay> indiagreen: I'd build the parser monad from scratch ;D
04:07:49 <kuribas> indiagreen: in what way?  error reporting?
04:09:16 <tzaeru> mmh, I've been musing about a satirical blog post that likens haskell with a religious cult, but I need to actually learn haskell first still! ^^
04:09:21 <Aejay> julianleviston: Here's another gotcha: mapping to functions. In Haskell `fmap = (.)` for functions, but in javascript, you might be able to make a side effect where you shouldn't be able to.
04:09:21 <indiagreen> kuribas: no, it hasn't got that far
04:09:24 <tzaeru> ..and yes, the above is meant with no slight sense of irony.
04:09:33 <Aejay> tzaeru: http://www.lisperati.com/landoflisp/panel01.html
04:10:01 <indiagreen> kuribas: my task is, like, the simplest task ever: I need to parse something and get an Either String ParsedThing
04:10:06 <julianleviston> Aejay: yeah, Haksell wins hands down, because it goes for simplicity, whereas other languages tend to “add” rather than abstract.
04:10:18 <tzaeru> Aejay, but I never do unit testing! :O
04:10:37 <Aejay> julianleviston: Haha, reminds me of unlambda when you say that! But yeah, it's so damn nice...
04:10:48 <julianleviston> Aejay: what’s unlambda?
04:10:52 <Aejay> tzaeru: You don't really have to, just match up the type.
04:11:00 <Aejay> julianleviston: Watch this:
04:11:14 <Aejay> @unlambda `````.h.e.l.l.oi
04:11:14 <lambdabot>   hello
04:11:19 <Aejay> That's unlambda
04:11:29 <julianleviston> Aejay: I don’t understand that.
04:11:30 <Aejay> It's pure, untyped, SKI combinatorics.
04:11:37 <Aejay> Netiher do I!
04:12:07 <julianleviston> Aejay:  hahaha ok then… lol
04:12:31 <kuribas> indiagreen: parse?
04:12:35 <Aejay> julianleviston: It's a 'turing tarpit', because it only has 2 basic necessary builtins.
04:12:37 <julianleviston> Aejay: I will need more Wizard to function that out! :)
04:12:49 <julianleviston> tzaeru: I think Haskell is like a cult in the same way that math is a cult.
04:13:01 <indiagreen> kuribas: there's “parse” and it takes filepath and I don't have filepath and okay I guess I can give it empty string but would it lead to anything bad? no idea. Then there's ParseError, which needs to be converted to String, but I don't want position to be included in error message, just the error... but of course ParseError is either opaque or there's some function *somewhere* to extract error message from it and I've no idea
04:13:01 <indiagreen> where
04:13:13 <Nux__> unlambda isn't 'pure'
04:13:23 <Aejay> Nux__: Well, it's stateless.
04:13:32 <kuribas> indiagreen: "The filePath is only used in error messages and may be the empty string. "
04:13:40 <Aejay> Admittedly, it needs side effects if it's untyped.
04:13:46 <Nux__> there are side-effecty function in unlambda
04:14:06 <chpatrick> haskell is a cult
04:14:10 <chpatrick> all hail the simons
04:14:13 <tzaeru> julianleviston, there are like graph theory guys who are "graph theory makes us better and beats others hands down! screw number theory!"?
04:14:23 <kuribas> indiagreen: yeah error messages aren't exactly a strong point in parsec.
04:14:28 <chpatrick> blessed be the kmett
04:14:42 <Nux__> Aejay, what about continuations?
04:14:52 <Aejay> Nux__: You can do that? Wow....
04:14:58 <Nux__> c
04:15:08 <Nux__> ``cki
04:15:20 <Aejay> @unlambda ``cki
04:15:21 <lambdabot>  Done.
04:15:23 <Aejay> @unlambda ``ck.e
04:15:23 <lambdabot>  Done.
04:15:28 <Aejay> @unlambda ``c.ei
04:15:28 <lambdabot>   e
04:15:31 <Aejay> Interesting.
04:15:55 <Aejay> chpatrick: Lambda is our deity.
04:17:01 <julianleviston> tzaeru: the problem with math, and haskell, is that the stuff it describes is very easy to understand, but there are so many words that they cloud the simplicity.
04:17:49 <Aejay> julianleviston: That's true, but the words are part of Haskell's roots in category theory; we couldn't just do away with them, being so accurate and useful.
04:18:08 <julianleviston> Aejay: no, the words are fine. It’s when we come to explain them that the problems arise.
04:18:55 <Aejay> julianleviston: I find differently; the words are daunting, like 'functor', but the concept of a 'mappable' is so much easier to comprehend.
04:19:10 <julianleviston> Aejay: I don’t think it’s much easier to understand.
04:19:52 <julianleviston> Aejay: the other part of the problem is that most other languages are focussed on the data structures first. This might seem obvious to a haskeller, but it needs to be pointed out, usually. 
04:19:59 <julianleviston> Aejay: all the words relate to functions.
04:20:01 <Chousuke> well, it likely gives you an idea immediately because you've likely heard of mapping before. That idea might be completely wrong though. :/
04:20:16 <Aejay> julianleviston: Of course.
04:20:25 <tzaeru> while I haven't really put many hours to trying to learn haskell, my main problems with anything haskell-related remain the syntax and the gibberish explanations. mapping things to how a computer (roughly) works is much easier, even if more verbose, than mapping things to how a randomly chosen mathematical concept works, which is purely abstract.
04:20:33 <julianleviston> Aejay: haha NO not just “of course”… :P
04:20:44 <Aejay> Chousuke: That's what I though, but I guess everyone's different.
04:21:08 <Aejay> julianleviston: No, it's as you say, it's clear to a Haskeller, but I can understand why others wouldn't see.
04:21:11 <chpatrick> tzaeru: almost every language is actually pretty far from the metal though
04:21:20 <chpatrick> even C
04:21:37 <chpatrick> their semantics are just more cpu and ram-like
04:21:45 <Aejay> If you want a bare-to-the-metal language, go learn assembly.
04:22:01 <indiagreen> kuribas: there's still a chance that it would try to use the empty string to print something like “error X in <no file>”, and I don't need that anywhere in my error messages. Yeah, it doesn't actually do that (I just checked), but the thing is – I shouldn't have had to check in the first place. Moreover, the description of the filepath parameter was right after a really nice sentence which goes like “parse p filePath input
04:22:01 <indiagreen> runs a parser p over Identity without user state” and which automatically raises my “can skip all this” flag. But, unfortunately, it's really hard to argue about usability because for each of my nitpicks you can say “well why don't you check” or “well if you don't like reading big sentences that's your fault” or “most people learn Parsec by tutorials so there's no need to spell out again that “parse” is the
04:22:01 <indiagreen> go-to function for parsing in the documentation itself” and I end up looking like Doofus McRoofus who has bad reading comprehension but dares to rant about usability.
04:22:09 <demize> Even ASM is far from what actually happens at the machine level these days.
04:22:12 <tzaeru> chpatrick, there are a lot of things in-between before the CPU runs its thing, but the flow is decently similar.
04:22:19 <chpatrick> not really tbh
04:22:37 <demize> Yes really?
04:22:40 <tzaeru> surely it is.
04:23:10 <tzaeru> yea yea, we're skipping the CPU registers and so on, but by most part, the flow goes like "allocate something memory, pull something from memory, do a calculation on it, put it back into memory"
04:23:13 <demize> chpatrick: http://blog.erratasec.com/2015/03/x86-is-high-level-language.html#.VbIf_XVq1hE has some details, but there's more than that.
04:23:19 <tzaeru> **something in memory
04:23:25 <chpatrick> demize: I know
04:23:29 <chpatrick> I was disagreeing with tzaeur
04:23:42 <julianleviston> tzaeru: I don’t understand why you’d prefer to think about things mechanically like that.
04:23:48 <chpatrick> it's not even true any more
04:23:55 <chpatrick> variables don't really map to memory at all
04:24:00 <chpatrick> operations aren't in order
04:24:07 <chpatrick> calls might be inlined
04:24:11 <chpatrick> the optimizer does a ton of stuff
04:24:21 <kuribas> indiagreen: I'd like to have more control over error messages.
04:24:24 <demize> chpatrick: Oh, right, I misread.
04:24:36 <tzaeru> chpatrick, *sigh*.. the fact that you don't have cycle-accurate control over what is being executed and exactly when on the CPU does not sway away from the general data flow being somewhat comparable.
04:24:40 <chpatrick> the only thing is that it's easier to hand-translate C to some kind of assembly
04:24:48 <chpatrick> but it's far removed from what actually happens
04:24:54 <tzaeru> you're missing the point.
04:25:05 <chpatrick> I don't think so
04:25:14 <chpatrick> I just don't buy the "it's more like the machine" argument
04:25:18 <tzaeru> the point isn't what *exactly* happens, the point is that it's very easy to map the language to the general dataflow that results in stuff going in and the right (or wrong) stuff coming out.
04:25:18 <chpatrick> because it isn't
04:25:28 <chpatrick> it's actually more like "what I think the machine does"
04:25:39 <chpatrick> but that's as made up as haskell's semantics
04:25:47 <tzaeru> julianleviston, it's just easier.
04:25:49 <Nux__> I think he's referring to operational semantics
04:25:56 <julianleviston> chpatrick: it’s actually more like “this is how machines used to work” actually ;-)
04:26:02 <chpatrick> sure
04:26:09 <julianleviston> tzaeru: easier for who tho?
04:26:14 <tzaeru> julianleviston, for me?
04:26:15 <Nux__> not so much what the machine does, but the tasks that it used to complete at every step
04:26:19 <julianleviston> tzaeru: BINgo :)
04:26:29 <tzaeru> julianleviston, um.. that was supposed to be implicit to begin with.
04:26:46 <julianleviston> tzaeru: fair enough :) however, if you write concurrent code, it’s not easier anymore...
04:26:50 <raichoo> tzaeru: I thought the same after doing over 15 years of C++ now I think it's the other way around.
04:26:56 <julianleviston> tzaeru: or parallel code…. right?
04:27:03 <Nux__> rather than denotational semantics, which allows us to talk about problems in terms of what we have and what we want
04:27:31 <tzaeru> raichoo, well, if you did with a heavy focus on OOP paradigms, then yea, OOP is an approach maps poorly to both the machine and to most actual problems :P
04:27:32 <Nux__> in terms of mathematical abstractions
04:27:39 <tzaeru> **as an
04:27:50 <ttt_fff> ha!
04:27:54 <julianleviston> tzaeru: dealing with modern STM and sychronisation queues is so much easier for concurrent code than dealing with thread semantics, right?
04:27:55 <ttt_fff> the more I rewrite my code, the faster the compile time
04:27:56 <ttt_fff> this is addictive
04:28:06 <julianleviston> ttt_fff: hehe nice :)
04:28:33 <tzaeru> Nux__, mmh, yea, probably I was referring to those!
04:28:45 <julianleviston> tzaeru: I always find whenever I write in so called lower-level programming languages, I spend at least half my time doing mechanical crap that is boilerplate repetition.
04:28:47 <raichoo> tzaeru: I get the feeling you are trying to imply everyone in here does not know what she or he is talking about.
04:29:11 <raichoo> Correct me if I'm wrong.
04:29:16 <tzaeru> raichoo, "everyone" would be an exaggeration.
04:29:44 <chpatrick> I understand what you're getting at
04:29:55 <chpatrick> I just don't think that C's semantics are either closer to the machine or easier
04:30:01 <chpatrick> it's just what people usually learn first
04:30:11 <chpatrick> ok, it is closer to the machine but not as much as you think
04:30:14 <tzaeru> julianleviston, yea, that might be, and certainly we need a bit of time to get used to map problems differently anyhoow.
04:30:18 <julianleviston> chpatrick: it always depends what you’re trying to do huh :)
04:30:35 <chpatrick> not inherently though
04:30:36 <julianleviston> tzaeru: sorry, I didn’t follow that… 
04:30:39 <tzaeru> chpatrick, the bottomline was to not imply haskell or c as the better or worse.
04:30:43 <chpatrick> I know
04:30:56 <chpatrick> but I think this appeal to hardware is bogus
04:31:28 <tzaeru> chpatrick, the bottom line was to point that for me, personally, it's easier to map things less abstractly. haskell is extremely abstracted. the tutorials and explanations and so are full of abstractions. examples of haskell are full of abstracted situations, rather than practical problems.
04:31:48 <julianleviston> tzaeru: I really disagree with that point.
04:31:56 <chpatrick> is printf less abstract?
04:32:06 <chpatrick> it has an embedded domain specific language
04:32:08 <julianleviston> tzaeru: the abstractions are still there, it’s just that you don’t have to know about them in other langauges.
04:32:11 <chpatrick> err not embedded
04:32:17 <Nux__> it seems to me operational semantics is more intuitive because people are used to telling familiar things to do familiar things and generally not used to abstracting problems very much further than the most obvious patterns
04:32:47 <julianleviston> Nux_: exactly… people “know how to do stuff” they don’t have to think about what it is they’re doing at any kind of abstract level…
04:32:49 <Nux__> denotational semantics has an overhead of thought
04:33:06 <julianleviston> Nux_: doing things is not quite the same as doing them while thinking about them, or even thinking about them before doing them.
04:33:15 <Nux__> and that overhead is usually over peoples heads
04:33:49 <julianleviston> Nux__: yes, but the thing these people don’t seem to realise is that they’re going to have to deal with them at some point… :) they’re just deferring the thinking by not thinking of them until later (if ever...)
04:34:25 <julianleviston> How many people really ask what they’re doing when they roll the n-millionth for loop in C?
04:35:07 <julianleviston> how many times do you have to do an accumulator value loop over a data structure in C before you see that there’s a generalisation of computation that you’re actually doing over these things… whether in this case it’s a B-tree, or in that case it’s an array?
04:35:08 <tzaeru> chpatrick, I was more after comparisons such as "..So, these are composable computation descriptions. In essence, they are a separation of composition timeline from the composed computation's executiom timeline, as well as the ability to computation to implicitly carry extra data, as pertaining to the computation itself, in additions to its one output, that will produce.."..
04:35:18 <tzaeru> you just don't really see that kind of explanations for common language structures in most languages :P
04:35:32 <julianleviston> functional languages aren’t really for noobs, although they’re good fox everyone. They’re for people who are sick of repeating themselves.
04:35:59 <julianleviston> tzaeru: that’s because people are so caught up in the trees that they can’t see the forest, to use an analogy.
04:36:01 * indiagreen was pretty sure tzaeru's description was satire, but apparently not
04:36:07 <Nux__> We (myself included) often take the 'thoughtless' route as soon as we start to confuse ourselves. That route goes through a bog that I always hate being in.
04:36:25 <init> I wouldn't put it that way, you need the same thought for getting working IP code and getting FP code
04:37:29 <tzaeru> julianleviston, but the real forest here is the actual problem we want to solve with the programming language, not the programming language or its semantics themselves.
04:37:42 <julianleviston> tzaeru: exactly.
04:37:53 <Nux__> There's a problem with my preference for the abstract though. It's easy to go into an infinite regress that practical problems just don't have time for.
04:37:54 <julianleviston> tzaeru: and haskell connects you with that problem.
04:38:08 <ttt_fff> coding haskell is like painting
04:38:08 <maerwald> sometimes it disconnects you too
04:38:09 <ttt_fff> it's beautiful
04:38:29 <julianleviston> maerwald: I find that happens less with FP. Maybe it’s just me.
04:38:45 <maerwald> there is _no_ language where you only think about an algorithm. You always have to think about language pitfalls/intricacies as well
04:38:54 <julianleviston> maerwald: I spend FAR more time with my own semantic domain than the programming language's.
04:39:30 <julianleviston> maerwald: i’m not arguing that it’s an absolute… I’m saying I spend less time worrying about how to implement stuff in FP versus IP or OOP
04:39:44 <maerwald> I don't agree
04:40:00 <maerwald> I spend my time differently in haskell
04:40:01 <maerwald> that's right
04:40:10 <maerwald> but less time... that highly depends on the problem
04:40:10 <julianleviston> maerwald: I’m talking about my own experience, so your agreement isn’t much relevant to that :) but for yours, fair enough :)
04:40:22 <julianleviston> maerwald: I get more done in less time is another way to put it.
04:40:22 <maerwald> it's a meaningless argument because too broad
04:40:28 <julianleviston> maerwald: possibly.
04:40:33 <tzaeru> julianleviston, to have haskell connect you to that problem requires understanding of haskell first. and alas, to me, the problem of "How do I best synchronize data from server to N many clients?" is not grounded in mathematical abstraction as much as it's grounded in thinking of the actual data.
04:41:13 <tzaeru> I find it difficult to map the problems I usually have to haskell. to give context to that, I mainly deal with problems related to game, network and graphics programming
04:41:24 <init> tzaeru: just use a database, there are bindings for most of them!
04:41:25 <julianleviston> tzaeru: that’s only because you don’t think that the “thinking” you’re doing is mathamatical, when it actually is.
04:41:27 <Aejay> tzaeru: You mayb be suprised.
04:41:57 <julianleviston> tzaeru: mathematical*
04:42:03 <Nux__> maerwald, this was one of the reasons I've been trying to learn a few different languages. I can try to choose the language that most easily handles the problem.
04:42:06 <lamefun> Can I make my own compile time checked values (eg. to type eg. `"my-package"@PackageName` instead of `fromJust (mkPackageName "my-package")`), so I don't risk inputting an invalid value by mistake and ending up with a run-time error?
04:42:11 <tzaeru> julianleviston, it's logical for sure, but a far cry from the formal mathematical annotations and semantics ;P
04:42:49 <tzaeru> init, um, how do you synchronize that dabatase to clients? surely you don't want your clients to have a direct access to it..
04:42:58 <indiagreen> lamefun: I've seen some TH package for that
04:43:02 <maerwald> Nux__: same here, I'm not one of those who find an interesting tool and get overexcited that they don't want to use anything else for the rest of their lives
04:43:17 <julianleviston> tzaeru: whichever syntax you use, it’s still the same thing :)
04:43:18 <maerwald> unlike ttt_fff ;)
04:43:45 <indiagreen> lamefun: https://www.reddit.com/r/haskell/comments/2qmp9t/wstandardizing_on_static_smart_construction/
04:43:52 <julianleviston> tzaeru: if you accumulate a value over a set of data, that’s a fold, or a reduce, or an inject depending on your paradigm.
04:44:01 <init> maerwald: I don't see people switching from Haskell/OCaml/Prolog to PHP and Scala
04:44:10 <ttt_fff> maerwald: my first three questions in pickup are going to be (1) are you single? (2) are you Christian? (3) can you imagine using any langauge besides Haskell?
04:44:39 <init> ttt_fff: Idris!
04:44:40 <maerwald> the most fascinating thing about haskell for me is that it pulled "effects" into the type system... and that gave us great knowledge and experience about the pros and cons of that approach
04:45:02 <tzaeru> julianleviston, yea, but to even have a proper I/O connection I need monads. suddenly, I'm again in the land of "...separation of composition timeline from the composed computaton's execution timeline.."-esque explanations and abstractions.
04:45:04 <ttt_fff> init: hmm, Idris is acceptable; are you single and christian? 
04:45:12 <ttt_fff> Coq/Agda are fine too
04:45:18 <init> ttt_fff: hah
04:45:30 <julianleviston> tzaeru: I’ll just leave this tweet from John Carmack here: https://twitter.com/id_aa_carmack/status/331918309916295168
04:45:34 <tzaeru> julianleviston, at this stage, it's no longer mapping to pure logical constructs, but mapping to Haskell.
04:45:44 <tzaeru> yea, I've seen that.
04:45:57 <ttt_fff> julianleviston: the link to the code is dead
04:46:00 <maerwald> I sometimes wish there was a more imperative oriented language that also tries to tackle effects via types (not just "uh this could throw exception A, B, C")
04:46:02 <ttt_fff> julianleviston: GIVE ME THE CODE
04:46:06 <julianleviston> ttt_fff: it is :) 
04:46:07 <julianleviston> LOL
04:46:11 <AaronFriel> ttt_fff
04:46:16 <ttt_fff> you do not post a link involving (1) Haskell, and (2) Carmarck, and then (3) having the code be a dead link
04:46:16 <AaronFriel> Oops, ctrl-f failed
04:46:20 <AaronFriel> Trying to find the joke.
04:46:31 <maerwald> init: I don't even know what "switching from one language to another" means
04:46:45 <maerwald> like I write everything in just one language at a time?
04:46:58 <ttt_fff> maerwald: switching_from_one_language_to_anothe :: (Language a) => a -> Haskell
04:47:12 <julianleviston> tzaeru: Um… I’m not sure what you mean. Are monads hard?
04:47:24 <ttt_fff> julianleviston: where is the carmack/haskell code?
04:47:27 <julianleviston> tzaeru: aren’t they just the same as IP?
04:47:35 <tzaeru> julianleviston, understanding what they are supposed to actually be and  represent is difficult to me, yes.
04:47:42 <julianleviston> ttt_fff: I don’t know. :) I was more interested in the youtube video he talked about haskell in… 
04:47:57 <ttt_fff> what'? ther's a youtube video too?
04:48:04 <ttt_fff> this is cruel
04:48:12 <julianleviston> ttt_fff: https://www.youtube.com/watch?v=1PhArSujR_A
04:48:15 <maerwald> julianleviston: did you read the whole twitter post?
04:48:16 <ttt_fff> next you're going to tell me there's "Unpublished Haskell Notes / Carmack"
04:48:26 <julianleviston> ttt_fff: just his keynote at quakecon from a while ago.
04:48:51 <init> maerwald: I didn't offer single choices in both sides, just that given that I see no people writing their toy projects in PHP after learning Haskell/Scheme/... up to a nice level 
04:49:06 <julianleviston> maerwald: not the comments.
04:49:11 <Nux__> tzaeru, as with anything abstract, understand what 'kind of thing' it is by looking at some of it's concrete instances
04:49:21 <maerwald> julianleviston: john carmack: "I had to abandon the code when I left Id Software"
04:49:29 <julianleviston> maerwald: yeah… I got that.
04:49:38 <julianleviston> maerwald: that’s why the broken link.
04:49:44 <Nux__> tzaeru, as for understanding 'what' it is, look at it's explicit definition
04:49:47 <julianleviston> maerwald: coz he had to do other things.
04:49:49 <maerwald> I think there will never be a breakthrough in that area
04:50:04 <chpatrick> is there any benefit to a pinned ByteArray over stdlib malloced memory?
04:50:05 <julianleviston> maerwald: seing as he is now working at facebook
04:50:34 <tzaeru> Nux__, yea
04:50:47 <julianleviston> tzaeru: why can’t you just use C if you love it?
04:50:56 <tzaeru> julianleviston, I never said I loved C..
04:51:02 <julianleviston> tzaeru: ah that’s why.
04:51:33 <init> tzaeru: monads (in Haskell) are just a way to give the language constructions that other languages have as primitives
04:51:43 <init> tzaeru: ok, not are but can be seen as 
04:52:00 <tzaeru> init, um.. primitives such as?
04:52:06 <julianleviston> tzaeru: lines of code.
04:52:12 <init> tzaeru: sequencing? :)
04:52:19 <kuribas> init: that's only true of the IO and ST monad.
04:52:29 <tzaeru> sequencing is understandable, yes.
04:52:38 <kuribas> init: monads are more general than that
04:52:39 <julianleviston> kuribas: kind of.
04:52:49 <julianleviston> kuribas: yes, but so are lines of code in other languages ;-)
04:53:43 <kuribas> init: try implementating parser combinators in a language without higher order functions.
04:54:05 <julianleviston> tzaeru: so why do you find Monads tricky?
04:54:20 <init> kuribas: state, writer, etc offer some notion of `sequencing`, there's also some kind of data-dependency that imposes some kind of sequencing, the _actual_ CT concept is indeed abstract though :)
04:54:26 <init> kuribas: is that even possible? :D 
04:54:45 <kuribas> init: it's the word "just" that I disagree with.
04:55:00 <dramforever> init: yes it is, I think there's a thing in boost like that
04:55:01 <maerwald> kuribas: depending on the problem, people will just use a less-abstract parser lib and write twice the amount of code than you would in haskell, but in half the time, because they don't need to understand those concepts first ;) ...then they forget about the library they just used
04:55:08 <dramforever> it's C++
04:55:22 <julianleviston> “programmable semi-colon” is a great way to look at them...
04:55:46 <maerwald> that's what people do... use a random lib, forget about it the next day. Haskell doesn't do very well with that workflow
04:55:50 <kuribas> init: if you would leave out the "just", I"d agree 100%
04:55:52 <init> kuribas: ah, I tried to simplify it and left it there
04:56:15 <init> kuribas: yeah, sorry, I thought I didn't left it there
04:56:22 <dramforever> wait C++ has HOF...
04:57:12 <julianleviston> tzaeru: in other languages, you get implicit execution order based on lines one after another. In haskell, you have explicit execution order when you need it, but otherwise the execution order isn’t specified. THAT is the trickiest thing about monads: the fact that the “standard context of writing code” is usually not sequenced.
04:57:47 <init> maerwald: I agree on that the first `touch` with parser combinators may seem a bit daunting at first
04:58:15 <kuribas> not all monads use sequencing.
04:59:00 <tzaeru> julianleviston, well, maybe it's not strictly monads that are confusing, but the whole set then.
04:59:11 <init> kuribas: ski disagrees :P 
04:59:15 <julianleviston> tzaeru: what’s “the whole set"?
04:59:18 <tzaeru> haskell.
04:59:27 <julianleviston> kuribas: yes, but let’s not confuse things too much! :-)
04:59:30 <Aejay> tzaeru: Monads really aren't that confusing....
04:59:32 <julianleviston> tzaeru: haha ok.
04:59:56 <julianleviston> it’s kind of funny in a way, because I spent about 8 years searching for a language that had that quality, and I only encountered it one day when I was explaining the problem with programming lagnauges to someone and they said “have you tried haskell? you’re describing it”.
05:00:31 <tzaeru> julianleviston, you're saying you went like, "Damn, why don't my languages look like a random page from an algebra book with all the symbols scrambled around?"
05:00:34 <tzaeru> ..sorry
05:00:35 <Aejay> julianleviston: How funny. Just shows how great HAskell is...
05:00:36 <tzaeru> I couldn't resist :(
05:00:46 <maerwald> init: and that's why you cannot convince a lot of entrepreneurs to use haskell, unless we are talking about a very special field or a very big company. You can't give a 3 day lecture just because someone wants to parse a trivial string.
05:01:16 <init> maerwald: yeah, most places seem to prefer technical debt
05:01:19 <julianleviston> tzaeru: nope… I ws like “Why on earth are things implicitly sequenced? we need a language that has timelessness by default and ALLOWS you to specify order, or sequencing, but automatically works out the correct order by need”
05:01:24 <Aejay> tzaeru: Well, at first it seems like that, but Haskell is actually super readable. More so than any language that I've encountered.
05:01:54 <kuribas> julianleviston: All there is to know about monads is: a datatype "m a", with an operation ">>= :: m a -> (a -> m b) -> m b" and "return :: a -> m a".  And it should obey some laws.
05:02:10 <dibblego> please can we move this elsewhere?
05:02:17 <eikke> New haddock's source linking is so sweet!
05:02:23 <julianleviston> dibblego: sorry.
05:02:33 <julianleviston> dibblego: what’s the topic?
05:02:47 <julianleviston> dibblego: just interested in how this isn’t on topic
05:02:47 <tzaeru> ..what even is ">>="?
05:03:01 <Aejay> tzaeru: It's called 'bind'
05:03:08 <dibblego> julianleviston: true things
05:03:12 <dibblego> typically about haskell
05:03:27 <Aejay> tzaeru: It allows you to 'continue' a monad based on the last value.
05:03:38 <julianleviston> dibblego: is all of this rubbish?
05:04:02 <Aejay> :t (>>=)
05:04:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:04:26 <tzaeru> why (>>=) and not >>=?
05:04:41 <dramforever> tzaeru: because otherwise the compiler thinks it's an operator
05:04:49 <tzaeru> ah.
05:04:50 <dramforever> and expects operands
05:04:52 <tzaeru> that makes sense.
05:05:07 <tzaeru> ..I was legimitately wondering if it just happens to be some weird syntatical construct for something ;P
05:05:26 <maerwald> bind is almost like fmap, except that the "mapping" function also controls the context (e.g. constructor) of the result
05:05:40 <init> almost like but fairly different
05:05:53 <dramforever> tzaeru: lol people do that often
05:06:18 <dramforever> the problem is that they often make false assumptions when asking about haskell
05:06:21 <julianleviston> maerwald: that sentense is so obtuse.
05:06:32 <Aejay> maerwald: That's a good way of explaining it!
05:07:01 <Aejay> tzaeru: Here's bind for the maybe type, quickly:
05:07:03 <maerwald> that's basically how cis explains it, with their parser examples
05:07:04 <julianleviston> maerwald: if you don’t know what fmap does.
05:07:21 <Aejay> @let bindMaybe (Just a) f = f a; bindMaybe Nothing _ = Nothing
05:07:22 <lambdabot>  Defined.
05:07:28 <maerwald> julianleviston: yes, I think there should be no tutorial that explains monads before functors
05:07:33 * dramforever explain it in the "a monoid on the category of endofunctors", i.e. fmap/return/join way
05:07:35 <maerwald> julianleviston: that's the most terrible thing imo
05:07:37 <Aejay> tzaeru: Try playing with bindMaybe now.
05:07:44 <dramforever> maerwald: I would agree
05:07:55 <Aejay> tzaeru: Eg, /msg lambdabot > bindMaybe (Just 6) Just
05:09:02 <Aejay> maerwald: That makes sense. Besides, functors can be defined using monads, so it would only make sense to start low-level.
05:09:54 <maerwald> also, fmap is pretty simple to understand
05:10:02 <maerwald> once you get there, you have a basis to work with
05:10:18 <tzaeru> Aejay, I'm already hopelessly confused about what's going on
05:10:58 <init> tzaeru: I would recommend doing CIS at your own pace, and slowly learn concepts as you go 
05:10:58 <julianleviston> Aejay: I wonder… what’s a Functor?
05:11:05 <julianleviston> Aejay: what would you say it is?
05:11:20 <Aejay> julianleviston: Something that may contain a value in the future.
05:11:22 <init> tzaeru: trying to learn everything at once isn't going to work, it didn't work for me at least 
05:11:29 <julianleviston> Aejay: but it’s not something though… is it?
05:11:42 <Aejay> julianleviston: What do you mean by that?
05:11:55 <init> Aejay: which value you mean?
05:12:04 <julianleviston> Aejay: well, I think the problem from an IP or OOP point of view, is that “a thing is a datum”
05:12:18 <julianleviston> Aejay: but we call a Functor a thing, when it isn't.
05:12:36 <init> Aejay: `Proxy` is a functor and it contains no "values" inside it? 
05:12:39 <julianleviston> Aejay: it’s an abstract entity. It’s the potential for something to be mapped over using a function that must be provided.
05:12:47 <Aejay> julianleviston: Ah, that's what I mean. 'Functor' is a pattern, but to be a Functor, something must have that property.
05:12:52 <dibblego> julianleviston: a (covariant) functor is a value F, such that there is a mapping (x -> y) to (f x -> f y) satisfying identity and composition. This is covered in NICTA/course on day two. If you are in Sydney, this course is being run for free, in September.
05:12:53 <init> > fmap (+2) Proxy 
05:12:55 <lambdabot>  Proxy
05:12:58 <julianleviston> Aejay:  yes. That’s very important.
05:13:17 <Aejay> dibblego: We're talking about covariant ones for now, but that's an issue.
05:13:27 <maerwald> tzaeru: you know fmap?
05:13:31 <dibblego> Aejay: yes, I know.
05:13:32 <Intolerable> if i want a transformer stack to be resumable from an arbitrary point, i want ContT right?
05:13:40 <julianleviston> dibblego: I know reasonably well what a functor is, but I was interested in Aejay’s opinion...
05:13:51 <dramforever> Intolerable: what do you want exactly?
05:14:10 <Intolerable> i have a transformer stack
05:14:15 <Aejay> julianleviston: As dibblego said, what about contravariant ones?
05:14:26 <Intolerable> it's ExceptT x (bunch of stuff) 
05:14:35 <Intolerable> i want to be able to
05:14:44 <Intolerable> instead of just returning the Left on a failure
05:14:56 <julianleviston> Aejay: I have no idea… my point was to elicit the fact that things for Haskellers aren’t the same things as for IP & OOP people.
05:14:57 <tzaeru> maerwald, maybe.
05:14:58 <maerwald> tzaeru: fmap (\x -> if x < 3 then Nothing else (Just 3)) (Just 3) -- look at what that does and what type it has. The way out of this mess is the monad
05:15:11 <Intolerable> also return an arbitrary point slightly further behind that allows to continue the computation that failed
05:15:19 <Intolerable> or retry
05:15:32 <tzaeru> ..what's "\", or "\x"?
05:15:36 <maerwald> uh
05:15:36 <Aejay> julianleviston: Fair enough.
05:15:44 <dramforever> that sounds like what ContT could do, but I'm not sure how
05:15:46 <julianleviston> Aejay: and that that might be the major difficulty people have in learning Haskell
05:15:48 <Aejay> tzaeru: THat's a lambda. It's a function without a name.
05:15:50 <maerwald> tzaeru: seems like you should start with a basic tutorial then
05:15:58 <Intolerable> yeah im thinking its ContT
05:16:03 <julianleviston> Aejay:  because we talk about Monads like they’re concrete entities.
05:16:19 <Aejay> julianleviston: That's true, it's certainly confusing.
05:16:21 <julianleviston> Aejay: but they only sometimes are.
05:16:39 <julianleviston> Aejay: we say Maybe is a Monad… so is Maybe Int a Monad?
05:16:47 <julianleviston> Aejay: is Just 5 a monad?
05:16:54 <dramforever> Intolerable: you can also have a free monad or something like that, and when an error is thrown just return the continuation along with it
05:16:54 <dibblego> No.
05:17:02 <Aejay> tzaeru: Try this: > (\x -> x + 1) 6
05:17:10 <dramforever> so you don't even need the ExceptT
05:17:11 <Intolerable> i've considered free but it's far too much work at the moment
05:17:26 <dramforever> Intolerable: why?
05:17:56 <Intolerable> because it would take far too much of my time to port it to free
05:18:06 <Intolerable> and i'm not sure it's going to be worth the effort
05:18:07 <julianleviston> You can see the confusion, right? If we say Maybe is a monad, why isn’t Maybe Int a monad?
05:18:17 <julianleviston> Maybe Int is a Maybe, isn’t it? :)
05:18:21 <Intolerable> it's something i plan to do, just not now
05:18:21 <Aejay> tzaeru: If you want to learn Haskell, visit learn-you-a-haskell online.
05:18:47 <dramforever> Intolerable: well if you used MonadError constraints it's fine
05:18:49 <Aejay> julianleviston: I agree, the lines are blurred, but we'd know what you mean in this case.
05:18:55 <dibblego> julianleviston: all monads have a kind :: * -> *, which Maybe satisfies, while Maybe Int does not.
05:19:02 <frerich> julianleviston: Any type constructor of kind '* -> *' can instantiate the Monad type class. E.g. 'Maybe'. However, 'Maybe' is not a type - unlike e.g. 'Maybe Int'.
05:19:03 <tzaeru> Aejay, I've read into some bunch of pages to several different tutorials.. and LYAH is terrible.
05:19:09 <Intolerable> i'm not using mtl
05:19:16 <julianleviston> dibblego: I’m not after the actual info, I’m illustrating the potential confusion.
05:19:28 <Aejay> tzaeru: It's not as bad as you say. Bear with it.
05:19:47 <julianleviston> dibblego: but thank you nonetheless.
05:19:47 <dibblego> julianleviston: there are lots of people confused in lots of ways, particularly respect to the word monad
05:19:52 <tzaeru> nah. it's terrible. it's just the means to mock other languages and make fun of its reader.
05:19:53 <Aejay> tzaeru: The fact that you don't know what \x -> ... is tells me you haven't read it properly.
05:20:37 <frerich> julianleviston: A consequence of making 'Maybe' and instance of the Monad class is that any value of type 'Maybe a' can be used with the functions defined in the 'Monad' type lass e.g. (>>=) and return.
05:20:43 <dramforever> Intolerable: =( then
05:21:30 <julianleviston> frerich: yup.
05:21:43 <frerich> julianleviston: Now, there's another meaning of 'monad': there's not only a type class in Haskell called 'Monad', but 'monad' can also mean the trio 'type constructor of kind *->*, some definition for bind, some definition for return'.
05:21:45 <julianleviston> frerich: my point is simply that the language we use is often quite imprecise.
05:21:50 <Intolerable> eh, i can make it work by just stacking ContT on it, so i should be ok
05:22:08 <julianleviston> frerich: or rather “massively overloaded”
05:22:10 <dramforever> Intolerable: yeah maybe
05:22:48 <tzaeru> it'd be nice if there were more practical tutorials floating around.. even real world haskell is kind of, well. it's showing practically how to use all the features one by one, but not actually showing actual problems solved with them.
05:23:10 <frerich> julianleviston: That's not really news, I guess.
05:23:15 <dramforever> tzaeru: what kinds of problems are "actual"?
05:23:18 <julianleviston> frerich: ah, apologies
05:23:37 <kuribas> tzaeru: you can take a real world application and look how it is made :)
05:24:02 <indiagreen> tzaeru: want to write one? I could help
05:24:25 <julianleviston> tzaeru: you might like this: http://haskellbook.com
05:24:57 <julianleviston> tzaeru: I haven’t read it, but the sample chapter is excellent.
05:25:08 <indiagreen> julianleviston: it seems like the opposite of what tzaeru wants
05:25:14 <peddie> tzaeru: Write Yourself a Scheme in 48 Hours is a tutorial where you build an interpreter instead of doing simple exercises
05:25:25 <indiagreen> Haskell from first principles
05:25:31 <kuribas> tzaeru: I intend to write the next module of my library in literate haskell, so I'll show you when it's finished :)
05:25:32 <tzaeru> dramforever, problems we actually want to solve with the total of our code. simple stuff would be like "get all file names with the string "2014" in them", or "take 10 words as input and put them to random order" or "generate a simple heat map image from an array"
05:25:54 <julianleviston> tzaeru: why not the 99 problems then?
05:26:04 <julianleviston> ohhhh
05:26:05 <julianleviston> sorry
05:26:25 <julianleviston> tzaeru: dude… write a framework for that, and ask in here, and get poeple to fill it in… that sounds great.
05:26:27 <tzaeru> julianleviston, well, combining that with a verbal tutorial might be pretty good actually.
05:26:50 <kuribas> tzaeru: https://wiki.haskell.org/Haskell_Quiz
05:27:04 <tzaeru> the tutorials should help map the actual thing you want to solve to haskell, not merely explain haskell itself.
05:27:07 <dramforever> tzaeru: how actual is this? https://wiki.haskell.org/Hitchhikers_Guide_to_the_Haskell
05:27:33 <tzaeru> because that's core of programming, mapping the problem you have to a language. I find it's also a quick way to learn the language itself.
05:28:37 <tzaeru> (sure, you'll also be dividing the problem yo uhave to smaller problems, but how this is exactly done is also affected to by the language)
05:28:48 <tzaeru> (oo, "affected to" is a cutely functionalish language construct..)
05:29:44 <julianleviston> tzaeru:  yeah, I completely agree.
05:29:54 <tzaeru> dramforever, that looks quite useful, actually.
05:30:58 <julianleviston> tzaeru: I have the same problem with human language learning material. They start with stupid things you’ll never use to teach you grammar and it’s just artificial… I want STREET FRENCH, darn it ;-) none of this other stuff… 
05:31:13 <dramforever> lol
05:31:54 <dramforever> In China they teach you to respond to "how are you?" with "I'm fine, thank you. and you?"
05:32:01 <dramforever> wtf
05:32:17 <tzaeru> yeah, I'm pretty sure that here 95% of the english people know is learned from TV and commercials and internet forums and whatnot, as we don't do overdubbing here and it's a small country, so english resources are common.
05:32:31 <dramforever> tzaeru: oh so it's *using* it
05:32:33 <julianleviston> tzaeru: nihonjin deshou ka?
05:32:46 <julianleviston> dramforever:  ;-)
05:32:49 <dramforever> you can learn to solve solve problems by *using* haskell
05:32:50 <tzaeru> julianleviston, um.. no?
05:32:59 <julianleviston> tzaeru:  oh haha sorry… 
05:33:04 <keko_> I'm pretty sure Japan isn't a small country :)
05:33:15 <keko_> or, well, maybe by land area
05:33:17 <tzaeru> dramforever, what a revolutionary idea.
05:33:26 <julianleviston> keko_: missed that bit ;-)
05:33:39 <julianleviston> dramforever: *cough* 99 problems *cough* ;)
05:33:45 <dramforever> =)
05:34:16 <julianleviston> dramforever: still, it *would* be nice to learn in small digestible steps rather than large chunks of theory and then try to junk it all together… but yeah.
05:35:22 <tzaeru> majority of the tutorials I've seen (real world haskell, learn you a haskell (which is also really hard to read thanks to its tone)), do indeed the theory chunking in a bit too high a ratio
05:36:02 <tzaeru> but yea, combining 99 problems with something like real world haskell can be much, much better approach..
05:36:16 * dramforever wonders if those theoretical stuff could actually "fall into place automagically"
05:37:05 <julianleviston> dramforever: i just think it should be introduced AFTER you’ve seen it a lot… 
05:37:26 <julianleviston> dramforever: we explain the theory, then show a bit, then ask the learner to try it… they inevitably fail… 
05:37:56 <julianleviston> dramforever: why not show, show, show, explain a bit of theory, show more show more, ask to do the first thing, vary, show show show, rinse & repeat?
05:38:22 <RedNifre> Hello there.
05:38:32 <dramforever> RedNifre: yes?
05:39:01 <RedNifre> I think I might be at the verge of understanding monads and wanted to get me checked :)
05:39:12 * srhb gets popcorn
05:39:14 <srhb> :-)
05:39:16 * julianleviston gets popcorn
05:39:19 <julianleviston> lol
05:39:25 <RedNifre> See, I had a look at monad tutorials, didn't understand it and thought I'll just ignore all that until I actually need it.
05:39:35 <srhb> RedNifre: That's probably a good approach.
05:39:38 * dramforever has run out of popcorn =(
05:39:47 <RedNifre> I think that point may have come right now, while writing some coffeescript (alternative javascript syntax)
05:40:31 <RedNifre> Okay, here's the situation: When you read a file you pass a filename and a callback, which takes (err, data), you can think of it as Maybe error -> Maybe data I guess.
05:40:58 <tzaeru> this here is pretty much the difference in easiness of understanding "Object is a combination of data and function. For example, car is an object with data of age, construction place and so on, and functionality such as accelerate or stop.". while this explanation is really pretty crappy, it offers the easy means to map into the concept with practical problems. compare to learn-you-a-haskell and its part about functors: instead of describing functors as ...
05:41:00 <RedNifre> Well, I'll just show you the code: http://pastebin.com/j202C0Sr
05:41:04 <tzaeru> ... how they might connect to a familiar concept, it starts to explain about if it's a concrete type and what signature it has and whatnot, as if that stuff actually meant anything to a haskell newbie.
05:41:09 <tzaeru> and no, I'm not saying that one or the other approach was inheritently *better*
05:41:37 <RedNifre> I suspect that the thing I named "monadStuff" has something to do with monads, could you tell me what exactly I did in that code, what's it called and does it make sense? I think I wrote "bind" but I'm not sure.
05:41:47 <tzaeru> I'm merely drawing an example of how the mapping of problems really differs in the tutorials :P
05:42:13 <dramforever> tzaeru: oh so you want something like "a functor is...is...is...well..."
05:42:23 <srhb>  RedNifre I don't really read Coffescript. Can you translate it to Haskell?
05:42:32 <tzaeru> dramforever, not necessarily.
05:42:35 <julianleviston> I read coffeescript
05:42:45 <srhb> RedNifre: Regardless it sounds like you're asking whether monadStuff is bind for Maybe
05:42:54 <srhb> Which it doesn't look like to me.
05:42:55 <RedNifre> Maybe, maybe not. It's not completely clear to me yet.
05:43:08 <dramforever> tzaeru: okay I just wanted to say that I really got stuck trying to explain functors like that example you gave me
05:43:23 <julianleviston> srhb:  -> is an anonymous function. (x,y) -> means \x y ->
05:43:53 <tzaeru> dramforever, could as well go "it could be used to solve a situation like <blah blah> or <blah blah>, like so: <code snippet>"
05:43:54 <srhb> julianleviston: I think my problem is more like "if err"
05:44:21 <julianleviston> tzaeru:  the trouble is, these things are abstract.
05:44:22 <RedNifre> Well, I can explain the code: There's parse :: String -> Stuff and there is this node.js stuff of which I'm not sure what the Haskell equivalent would be but I guess IO monad. You call the readFile function with a filename and a function that has two parameters, err and data, one of those will be undefined, which I guess you could translate to Haskell as a function that takes Either err, data.
05:44:41 <tzaeru> dramforever, offering such a practical surface for learning it might be a bit better than starting to explain about its type signature and what rules it follows and so on.
05:44:57 <julianleviston> tzaeru: Haskell has functions and data, just like OOP. 
05:45:03 <tzaeru> julianleviston, but what we use programming languages for is not abstract.. most of the time, anyway.
05:45:17 <julianleviston> tzaeru: I guess that’s the diff between a tute and a book.
05:45:20 <saep> > let andThen = (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b in Just 7 `andThen` (\n -> Just (n * n))
05:45:22 <lambdabot>  Just 49
05:45:27 <saep> > let andThen = (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b in Nothing `andThen` (\n -> Just (n * n))
05:45:29 <lambdabot>  Nothing
05:46:06 <dramforever> tzaeru: what about "a functor is a generic modifiable(?) container type. for example lists (a container type) can contain elements of any type (generic), you can apply a function to each element and get a new list containing the results (modifiable)"
05:46:07 <RedNifre> Hm, maybe my code is equivalent to using the Either monad with do notation?
05:46:18 <dramforever> but "modifiable" isn't really good...
05:46:48 <julianleviston> RedNifre: hm. I got the impression that CS code is actually using a Promise...
05:47:09 <julianleviston> dramforever: that is a beautiful explanation.
05:47:12 <tzaeru> dramforever, well, for a programmer that might be somewhat more approachable..
05:47:37 <dramforever> tzaeru: I can't seem to find a good analogy for functions
05:47:49 <julianleviston> dramforever: yeah, what is a function? :) hehe.
05:48:01 <dramforever> on the other hand, procedure seems much more understandable
05:48:05 <dramforever> I can't understand why
05:48:07 <julianleviston> dramforever: interestingly we don’t have to explain them, even though they are an extremely abstact concept.
05:48:12 <dramforever> *procedures
05:48:42 * dramforever tries to remember how my high school math teacher taught me about functions
05:48:44 <julianleviston> dramforever: yeah it is weird. A function is a much simpler thing than a procedure, yet procedures are easier to explain to IP people… 
05:49:14 <julianleviston> dramforever: functions are mathematical structures which imply a relationship between arguments and results.
05:49:27 <dramforever> hey what about this
05:49:42 <tzaeru> I'm sure there could be pretty nice real-world analogues for functions, too. like function is the event that takes an ignot of iron and coal and returns a bar of steel? :P
05:49:48 <RedNifre> I haven't read a file in Haskell yet, if you have a function parse :: String -> Stuff, how would you use that to parse the text in the file if you can actually read from the file successfully?
05:49:56 <julianleviston> tzaeru:  that’s a procedure.
05:49:57 <srhb> tzaeru: Too general bordering on useless.
05:50:05 <srhb> julianleviston: It _might_ be a function.
05:50:35 <julianleviston> tzaeru: a set of instructions on how to get from one end of a maze to another is a procedure, but a map with two points on it and a line between them is a function. No?
05:50:36 * dramforever wonders if graph reduction can be used to explain functions
05:50:39 <srhb> But I think everyone heard similar analogies in early maths class.
05:50:51 <tzaeru> julianleviston, mayhaps
05:51:24 <RedNifre> How do promises and futures relate to functors, applicatives and monads?
05:51:35 <julianleviston> RedNifre: I think promises are promises.
05:52:04 <julianleviston> RedNifre: not very helpful, but functors, applicatives and monads aren’t really about deferred execution, maybe I’m wrong.
05:52:15 <dramforever> say all you have is constructors, application, annoymous functions and pattern matching
05:52:25 <kuribas> julianleviston: a function would be something that takes a map with two points, and produces a line from a to b (and always the same line).
05:52:31 <dramforever> you have an expression tree that way
05:52:34 <tzaeru> practical things for a function in programming can be like "separating the procedure that takes, for example, a file name and checks if it ends in .jpg" or something, but I think this is straying a bit..
05:52:34 <srhb> RedNifre: Promise may be _a_ monad. If so, it is also a functor and an applicative.
05:52:49 <RedNifre> I thought that the IO monad was like a computation that will be performed later at runtime to create a result, which sounds similar to promises to me?
05:52:51 <dramforever> you can, however, make a...oh no I need pointers here =(
05:53:31 <indiagreen> dramforever: I have used Haskell for several years and I don't see functions in terms of graph reduction, so... I don't know
05:53:35 <srhb> RedNifre: More specifically it would be some kind of async IO monad. IO doesn't deal with deferred computations (outside of lazy evaluation)
05:53:41 <julianleviston> RedNifre: no, that’s just lazy evaluation.
05:54:40 <dramforever> on a second thought, it seems that graph reduction is too complicated
05:55:00 <aweinstock> :t readFile
05:55:01 <lambdabot> FilePath -> IO String
05:55:16 <julianleviston> RedNifre: a promise is only really useful when your language has implicit sequencing (in other words, each line executes after the preceding one), because a promise usually executes on another thread…
05:55:27 <aweinstock> :t read
05:55:28 <lambdabot> Read a => String -> a
05:55:34 <aweinstock> :t fmap read readFile
05:55:35 <lambdabot>     Couldn't match type ‘IO String’ with ‘[Char]’
05:55:36 <lambdabot>     Expected type: FilePath -> String
05:55:36 <lambdabot>       Actual type: FilePath -> IO String
05:55:48 <tzaeru> mmmh, a nice practical thing with haskell would be having better windows installer and package managing.. @_@
05:55:49 <aweinstock> :t fmap read (readFile "foo.txt")
05:55:50 <lambdabot> Read b => IO b
05:55:53 <kuribas> RedNifre: there is no later, since function application has no concept of time.
05:55:55 <RedNifre> Hm, then I think that my code isn't about promises. Yes, it uses a callback, but it is still completely sequential.
05:56:15 <dramforever> callback? wow that sounds like continuation
05:56:17 <aweinstock> RedNifre: fmap parse (readFile filename)
05:56:21 <julianleviston> RedNifre: oh sorry I must have misunderstood.
05:56:32 <dramforever> *continuations
05:56:42 <tzaeru> python as a separate installation is kinda meh, should be just integrated with the package manager thingy stuff.
05:56:46 <kuribas> RedNifre: But practically the monad expression must be evaluated first before it can run.
05:57:15 <RedNifre> By sequential I mean like what you have when you use do-notation. I don't mean sequential in time, I mean chaining monads together.
05:58:06 <RedNifre> But I recon that readFile in Haskell is somewhat different than the one in node I'm using.
05:58:09 <srhb> Chaining monadic actions together*
05:59:21 <RedNifre> A Haskell equivalent might be readFile :: (String -> IO () ) -> FilePath -> IO () as in you pass what you want to do with the String when it was loaded instead of getting an IO String.
05:59:51 <srhb> RedNifre: But that doesn't require any monadic properties.
05:59:53 <dramforever> RedNifre: that's *exactly* like continuations
06:00:11 <RedNifre> Hm, maybe I should just drop all that Javascript and look into compiling Haskell to Javascript. What's the situation with that? Or are purescript or livescript any good? What do you do when you have to write javascript? Or does this not happen to you? :)
06:00:14 <srhb> Oh actually it requires join.
06:00:22 <srhb> Nevermind me.
06:00:25 <Intolerable> ContT is terrifying
06:00:41 <chpatrick> it's not so bad
06:00:45 <Intolerable> blegh http://lpaste.net/1929447953886347264
06:00:45 <Aejay> Intolerable: It's AWESOME.
06:00:58 <Aejay> The Cont Monad is just awesome.
06:01:04 <srhb> RedNifre: ghcjs is very good. :)
06:01:33 <chpatrick> I'm thinking about how to implement a game where the rules change dynamically (I know someone's already doing this)
06:01:39 <RedNifre> But how convenient is the js interop?
06:01:45 <srhb> RedNifre: Very!
06:01:54 <chpatrick> and I'm considering implementing it as ContT on Free
06:02:00 <srhb> RedNifre: You just use the js ffi
06:02:03 <chpatrick> so you can modify the future game tree from inside the tree
06:02:20 <srhb> RedNifre: https://github.com/ghcjs/ghcjs-examples/blob/master/weblog/ffi/ffi.hs
06:03:13 <dramforever> RedNifre: IIRC you could even let ghcjs handle callbacks for you!
06:07:34 <RedNifre> Hm, I'll consider it. Though things like purescript look like a more light-weight solution. Hmmmm, so many choices...
06:08:02 <srhb> RedNifre: Sure, if you're not happy embedding a GHC runtime in the JS, you won't like ghcjs. But it's the only way you'll get Haskell in the browser, really. :)
06:08:35 <nullvoid8> I was just looking at the Comonad package on hackage, and it says it requires "base (>1 && <1)". how does that work?
06:09:05 <srhb> nullvoid8: That.. looks weird.
06:09:12 <srhb> nullvoid8: Also the version preceding it looks more sane.
06:09:13 <RedNifre> Well, maybe we have to wait for WebAssembly. That one sounds promising. srhb, have you looked at purescript? It looks like javascript with haskell syntax http://www.purescript.org/
06:09:20 <nullvoid8> in the .cabal it has base <0 for the liobrary, and just "base" for test
06:09:40 <srhb> RedNifre: JS is basically webassembly. And yes, I have looked at all the others. They are just pale imitations imo. But I'm infected, so YMMV. :)
06:09:48 <indiagreen> nullvoid8: it was most likely done on purpose to prevent you from installing it
06:10:14 <nullvoid8> srhb.... why would it be uploaded to hackage if it's not suppsed to be installed?
06:10:30 <bergmark> probably it turned out to be broken afterwards
06:11:22 <dramforever> so what happened?
06:12:03 <nullvoid8> I guess this happened: https://github.com/ekmett/comonad/issues/25
06:13:50 <dramforever> but why not just deprecate it?
06:14:08 * hackagebot smoothie 0.4.0.2 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.0.2 (DimitriSabadie)
06:14:56 <srhb> dramforever: I don't think such a mecanism exists in Hackage?
06:15:04 <dramforever> dunno
06:15:08 <indiagreen> @hackage aeson
06:15:09 <lambdabot> http://hackage.haskell.org/package/aeson
06:15:17 <indiagreen> look at gray versions
06:15:45 <srhb> indiagreen: What about them?
06:16:00 <indiagreen> they are deprecated
06:16:03 <indiagreen> http://hackage.haskell.org/package/aeson/preferred
06:16:30 <srhb> indiagreen: But in no meaningful sense other than "they are grey" are they?
06:16:40 <indiagreen> no, cabal should respect that
06:16:54 <indiagreen> (also there's this file, which cabal uses: http://hackage.haskell.org/packages/preferred-versions)
06:17:16 <srhb> indiagreen: cabal install aeson==0.8.0.1 works fine
06:17:33 <indiagreen> > it means that the installer won't install a non-preferred package version unless it is explicitly specified or if it's the only choice the installer has
06:17:34 <lambdabot>  <hint>:1:112: parse error on input ‘if’
06:17:40 <indiagreen> sorry, lambdabot
06:17:48 * srhb shrugs
06:18:07 <indiagreen> srhb: I guess that's the problem, tho
06:18:25 <indiagreen> Edward probably didn't want the broken package to be installable under any circumstances
06:18:43 * indiagreen shrugs too
06:19:20 <saep> Putting "base (>1 && < 1) in the cabal file can be done after it has been uploaded. It simlpy means that this version should never, ever, ever be installed again because it is broken. But you are still able to downlad and install it with the original .cabal contents, if you reallly really really want to. 
06:19:26 <srhb> I can't bring myself to care very much about a problem that will probably be fixed very soon, either by the version being taken offline or fixed. :-)
06:20:00 <srhb> Also because it's a non-problem (except for anyone who got the version before it was made uninstallable)
06:20:31 <dramforever> saep: no I think the code is broken
06:20:35 <dramforever> it doesn't even compile iirc
06:20:51 <indiagreen> srhb: I don't care about this particular problem, I just like figuring out how various things (like package deprecation and so on) work even if they're useless to me
06:20:57 <srhb> :)
06:21:01 <dramforever> =)
06:25:02 <DavidMD> hey guys, I'm a little new to haskell and I'm making a scotty server. I was wondering if there was a way to only read from a file once during the running of the server and store the output for the runtime of the program
06:25:28 <bergmark> DavidMD: sure, you can even do that on compilation
06:26:02 <edwardk> nullvoid8: damn. i thought i'd pushed out the fix for that that day. the patch has been waiting since then in the repository
06:26:06 <dramforever> DavidMD: you can just store the contents to a variable
06:26:07 <edwardk> nullvoid8: shipped
06:26:11 <Phillemann> I'm using reactive-banana and I've got a velocity that is updated by two types of events (two types of collision). With just one event, I can write "accumB initialVel (transformVel <$> collisionEvent)", but what do I do with two events?
06:27:09 <bergmark> DavidMD: typically i have a ReaderT Config containing the program configuration that is read from file/flags on startup
06:27:10 <aweinstock> bergmark: are you referring to template haskell? fileLiteral = runIO . fmap (LitE . StringL) . readFile
06:27:16 <Phillemann> Hm. I _could_ lift both to be "Event (Maybe CollisionTypeA,Maybe CollisionTypeB)"
06:27:30 <bergmark> aweinstock: right, there's a package for it but i forget the name
06:27:36 <edwardk> nullvoid8: i basically never use default-extensions, but comonad predates that policy.
06:27:51 <edwardk> nullvoid8: doctest doesn't pick up the default extensions though
06:28:49 <DavidMD> dramforever: surely if I store as a variable on the top level and it has a type of IO String each time my code reads the variable it re-reads the file?
06:29:09 * hackagebot comonad 4.2.7.1 - Comonads  https://hackage.haskell.org/package/comonad-4.2.7.1 (EdwardKmett)
06:32:12 <srhb> DavidMD: That's doable with unsafePerformIO, but not really how you would generally do things unless you are absolutely forced.
06:32:44 <bergmark> DavidMD: read it inside main and then pass it along to where it's needed
06:32:56 <srhb> DavidMD: A better solution is as bergmark outlined. Pass in the result of that one time computation when you start the server. Either as some explicit argument or in some kind of Reader-esque environment.
06:33:58 <DavidMD> bergmark: cool, so that works in servers with routes like Scotty. I have to say I'm a little uncertain of how the routes in scotty works. It seems to be some sort of monad but I'm not sure whether the arguments persist between requests
06:34:09 * hackagebot lentil 0.1.3.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.3.0 (fffaaa)
06:37:13 <Athas> Could someone explain to me, or point at a document, that explains how cabal configure, build and install interact?
06:37:33 <Athas> It seems like my cabal constantly rebuilds different things, builds things twice (for profiling?) in unpredictable ways.
06:38:10 <Athas> Also, is there a way to make 'cabal install' build in parallel the way I can do with 'cabal build -j' (and why is this not standard)?
06:39:24 <demize> `cabal install -j` :p
06:39:34 <srhb> Athas: It is standard nowadays, but you may have an old ~/.cabal
06:40:27 <srhb> Athas: In ~/.cabal/config you should have jobs: $ncpus
06:41:04 <Athas> srhb: I do, and it means that 'cabal install' will install *packages* in parallel, but not build the modules within each package in parallel.
06:41:12 <srhb> Athas: Oh right, sorry.
06:41:16 <Athas> demize: only parallelises at package-level granularity, unfortunately.
06:41:28 <demize> Ah, too bad.
06:41:58 <indiagreen> you can do cabal build -j now? cool
06:42:06 <Athas> Yes, it works extremely well.
06:43:16 <srhb> Athas: Maybe you can just pass --ghc-options="-j"
06:43:31 <Athas> Hm, yeah, I guess that might work.
06:43:50 <Athas> I can't help but feel that this really should not be necessary, though.
06:44:02 <srhb> Athas: Looking at the issue tracker it looks to be under development.
06:44:08 <edwardk> nullvoid8, Dramforever: the mechanism for deprecation that works is to set it uninstallable. i usually use base < 0. deprecating a version doesn't do anything
06:44:09 * hackagebot comonad 4.2.7.2 - Comonads  https://hackage.haskell.org/package/comonad-4.2.7.2 (EdwardKmett)
06:44:25 <Athas> I'm also confused about why I can do 'cabal build' and then 'cabal install', at which point it will do a lot more compilation (seemingly an entire profiled build).
06:46:32 <lpaste_> amontimur revised “Typeclass error (annotation) (annotation)”: “Typeclass with external type function constraint” at http://lpaste.net/137263
06:48:20 <amontimur> hey, can somebody help me with that? i think i need to enforce that a type of a multi parameter typeclass is at the same time the return of an external type function for the first type of the typeclass.
06:50:41 <geekosaur> amontimur, the context doesn't take part in instance resolution, with the result that (Rs rq ~ rs) is not in scope for instance selection and no type can be given to extract
06:50:53 <geekosaur> because pl is only in the result
06:51:02 <lspitzner> Athas: This description is probably incomplete, but maybe it helps: https://gist.github.com/lspitzner/57b1ea39fd00a9d1cf5e
06:51:27 <lspitzner> Athas: note that in a sandbox, `install` will use a different directory than `build`; that's why you get recompiles
06:52:01 <Athas> Thanks.
06:52:39 <amontimur> geekosaur: i dont follow. can you please elaborate?
06:53:36 <amontimur> geekosaur: isnt the type completely determined?
06:53:41 <geekosaur> for the purpose of instance selection, the only constrained type variable in extract is pl, and it is in the result type (which is selected by the caller, not the instance)
06:53:52 <geekosaur> again, the comntext does not take part in instance resolution
06:54:08 <amontimur> geekosaur: so if i invert the fundep it should resolve?
06:54:08 <geekosaur> again, (Rs rq ~ rs) is not in scope for instance selection
06:54:44 <geekosaur> so there is no constraint on rs *at instance selection time*, so the fundep can't be applied because it can't get from rs to rq
06:54:54 <geekosaur> and therefore can't constrain pl
06:55:06 <amontimur> geekosaur: okay. i think i understand
06:55:32 <amontimur> so how do i get around this? is my intent apparent in the code?
06:55:34 * geekosaur ... did not describe that as clearly as he could have initially, sorry
06:55:38 <ysz> guys is it possible to set output name for cabal library nowadays?
06:55:52 <ysz> i don't need standard naming as I'm building library to be called from foreign code...
06:55:58 <geekosaur> your intent is apparent but I don't know how you do that here :/
06:55:59 * amontimur still has to study up on typing
06:56:10 * geekosaur still working on first coffee
06:56:38 <geekosaur> (and perhaps more importantly, breakfast)
06:57:34 <joneshf-laptop> Why does `MonadZip` need `Monad` as a superclass?
06:57:57 <joneshf-laptop> it seems like the laws hold with just `Functor` as a superclass
06:58:06 <Aejay>  joneshf-laptop: It's intended for monad comprehentions.
06:58:25 <Aejay>  joneshf-laptop: Look it up, "Parralel monad comprehentions".
06:58:59 <joneshf-laptop> Aejay, right, but you're not forced to use monad comprehensions to use `MonadZip` right?
07:00:28 <joneshf-laptop> put another way, `MonadZip` seems like a fine typeclass by itself (not mentioning parallel monad comps), so why the `Monad` superclass?
07:00:32 <joneshf-laptop> oh wait
07:00:39 <joneshf-laptop> maybe it was just missed in the AMP?
07:01:07 <Aejay> joneshf-laptop: No, but that was the point in the first place.
07:02:08 <Aejay> The reason MonadZip exists is for parralel monad comprehentions.
07:03:11 <joneshf-laptop> Right.
07:03:13 <joneshf-laptop> I get that
07:08:41 <hasknoob> exit
07:08:45 <hasknoob> quit
07:08:46 <hasknoob> exit
07:09:28 <tomjaguarpaw> :q
07:11:35 <geekosaur> "\C-x\C-c"
07:11:51 <ChristianS> Alt+F4, dammit
07:12:15 <lspitzner> amontimur: couldn't you remove the `rs` parameter from Requestable?
07:13:18 <lspitzner> `extract :: Rs rq -> [pl]`? i don't know if that helps, just trying to simplify.
07:13:24 <Intolerable> what does a Functor instance for ContT r (ExceptT a m) a look like?
07:15:26 <Intolerable> (assume a newtype X r m a over it)
07:23:30 <aweinstock> @src ContT
07:23:30 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
07:23:44 <aweinstock> @src ExceptT
07:23:44 <lambdabot> Source not found. That's something I cannot allow to happen.
07:24:15 <aweinstock> @hoogle ExceptT
07:24:16 <lambdabot> Control.Monad.Trans.Except ExceptT :: (m (Either e a)) -> ExceptT e m a
07:24:16 <lambdabot> Control.Monad.Except ExceptT :: m (Either e a) -> ExceptT e a
07:24:16 <lambdabot> Control.Monad.Trans.Except newtype ExceptT e m a
07:24:40 <aweinstock> @src Control.Monad.Trans.Except.ExceptT
07:24:40 <lambdabot> Source not found. Whoa.
07:25:16 <Intolerable> its newtype ExceptT e m a = ExceptT { runExceptT :: m (Either e a) }
07:27:49 <aweinstock> so ContT r (ExceptT e m a) a == (a -> m (Either e r)) -> m (Either e r) ?
07:28:38 <kuribas> Why do the lens operators even exist?  Isn't "view _1 (1, 2)" perfectly clear?
07:29:04 <Intolerable> yes, but set (_3._2) … isn't
07:29:17 <Intolerable> @unmtl ContT
07:29:17 <lambdabot> Plugin `unmtl' failed with: `ContT' is not applied to enough arguments, giving `/\A B C. (C -> B A) -> B A'
07:29:27 <Intolerable> @unmtl ContT r m a 
07:29:28 <lambdabot> (a -> m r) -> m r
07:29:38 <Intolerable> @unmtl ContT r (ExceptT e m) a 
07:29:38 <lambdabot> (a -> (ExceptT e m) r) -> (ExceptT e m) r
07:30:27 <Intolerable> aweinstock: that looks right
07:30:29 <Intolerable> but im not sure
07:30:58 <kuribas> Intolerable: looks clear to me
07:31:09 <aweinstock> Intolerable: so your question was what fmap looks like for the expanded form?
07:31:44 <Intolerable> yeah except it's 
07:31:52 <Intolerable> @unmtl ContT r (ExceptT a m) a
07:31:52 <lambdabot> (a -> (ExceptT a m) r) -> (ExceptT a m) r
07:32:20 <kuribas> > set (_1._2) 4 ((1, 3), 2)
07:32:22 <lambdabot>  ((1,4),2)
07:32:46 <kuribas> or even
07:32:58 <Zemyla> Intolerable: fnap would still be fmap f (ContT c) = ContT $ \k -> c (k . f), same as any ContT.
07:33:07 <Intolerable> no it wouldn't
07:33:11 <kuribas> > ((1, 3), 2) `set` (_1._2) 4 
07:33:12 <lambdabot>      Couldn't match type ‘((Integer, Integer), Integer)’
07:33:13 <lambdabot>                     with ‘(a0 -> Identity (s0 -> f0 t0)) -> s -> Identity t’
07:33:13 <lambdabot>      Expected type: ASetter s t a0 (s0 -> f0 t0)
07:33:16 <Intolerable> there are two a's in there
07:33:24 <Intolerable> ContT r (ExceptT a m) a
07:33:30 <Zemyla> Oh, hmn 
07:34:01 <Zemyla> Theb you can't do fmap, because a is in both positive and negative positions.
07:34:27 <Intolerable> how do you mean?
07:34:37 <Intolerable> it's in a newtype
07:34:49 <aweinstock> Intolerable: are you sure it's ContT r (ExceptT a m) a, and not ContT r (ExceptT e m a) a?
07:35:02 <Intolerable> yes
07:35:07 <Zemyla> Okay, suppose you had Op r a = Op (a -> r). Try to write fmap for that type.
07:35:22 <Intolerable> ExceptT e m a :: *
07:35:27 <Intolerable> not * -> *
07:35:37 <aweinstock> oh, i see
07:35:42 <Intolerable> ok that's what i mean
07:35:52 <aweinstock> why are we forcing e == a though?
07:35:57 <Intolerable> reasons
07:36:13 <aweinstock> Either a a == a though?
07:36:30 <aweinstock> (or am I still missing something?)
07:36:32 <Intolerable> yes, but Either (e, a) a /= a
07:37:00 <Zemyla> aweinstock: No, Either a a = (a, Bool), and Either (e, a) a = (a, Maybe e).
07:37:41 <Intolerable> my original question was essentially Either a a 
07:38:04 <Zemyla> So instead of ExceptT a m a, you need WriterT Any m a.
07:38:52 <Zemyla> That'll let you find out if it's on the left or right sides, while still having a on both sides.
07:39:29 <Intolerable> nope
07:39:50 <Intolerable> it's ExceptT (X e, M a) a
07:39:53 <Intolerable> where M is a monad
07:40:11 <Intolerable> entire thing is
07:40:12 <Intolerable> newtype APIT s e r m a =
07:40:12 <Intolerable>   APIT { unAPIT :: ContT r (ExceptT (APIError e, APIT s e r m a) (ReaderT Manager (StateT Builder (StateT s m)))) a }
07:40:40 <Zemyla> Okay, let's get back to basics.
07:40:56 <Intolerable> i'm happy with your "there isn't one" answer
07:41:12 <Intolerable> i'm just explaining why i can't shift things around to get a proper Functor instance
07:41:26 <Zemyla> Let's say you have NewEither a = NewEither { runNewEither :: Either a a }
07:41:49 <Zemyla> Write the functor and monad instances for that.
07:42:20 <Intolerable> i can do that
07:42:36 <Intolerable> i was wondering if there was a possible functor instance for the ContT ExceptT thing
07:43:27 <Zemyla> Well, if you can't write a functor instance, then you can't write a monad ibstabce.
07:44:39 <dcmid> I am trying to determine the current UTC offset for a given timezone (eg Central, Mountain, etc), and I'm having difficulty incorporating DST. Does anyone have any advice or know of a good library for this?
07:45:03 <Welkin> dcmid: System.Clock?
07:45:17 <Welkin> er
07:45:20 <Welkin> Data.Time.Clock
07:46:01 <Welkin> dcmid: https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-LocalTime.html
07:46:32 <dcmid> Welkin, LocalTime has no way of determining whether or not DST is in affect, though
07:46:41 <dcmid> Welkin, unless I missed something
07:48:53 <geekosaur> thyme, timezone-series/timezone-olson
07:49:08 <aweinstock> Zemyla: instance Functor NewEither where {fmap f (NewEither (Right x)) = (NewEither (Right (f x))); fmap f (NewEither (Left y)) = NewEither (Left y))}
07:49:43 <dcmid> Welkin, Actually, I bet I could use getCurrentTimeZone and then just check its timeZoneSummerOnly Bool. Thanks for making me look again!
07:49:53 <Intolerable> shifting it to ContT r (Either r m) a might work btw
07:49:56 <Zemyla> Yeah, but that's not really Either anymore. It's isomorphic to (a, Any).
07:50:12 <Intolerable> which has a sensible instance
07:50:18 <Zemyla> Intolerable: Yeah, it would.
07:50:28 <Intolerable> i think i might be able to get away with that actually
07:56:57 <Intolerable> im disgusted
07:57:02 <Intolerable> this monstrosity actually works
08:03:07 <Intolerable> ty for the help friends
08:10:35 <osa1_> is there a way to enable some GHC options from within GHCi?
08:10:41 <osa1_> like -fdefer-type-errors
08:11:06 <osa1_> oh does :set work for -f ?
08:11:25 <osa1_> yes!
08:13:41 <lamefun> What's the current best digital signature library?
08:19:17 <lamefun> This one? https://hackage.haskell.org/package/cryptonite
08:24:14 * hackagebot http-client 0.4.18.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.18.1 (MichaelSnoyman)
08:32:47 <Kluns> #join xmonad
08:32:51 <Kluns> oops
08:34:14 * hackagebot almost-fix 0.0.2 - Recurse while a predicate is satisfied  https://hackage.haskell.org/package/almost-fix-0.0.2 (athanclark)
08:43:40 <Zemyla> Is there any place I can read about the old main :: [Response] -> [Request] model?
08:44:46 <indiagreen> Zemyla: the one that was in Haskell 1.2?
08:44:54 <Intolerable> you've read history of haskell?
08:45:44 <indiagreen> Zemyla: you can read Haskell 1.2 Report
08:45:54 <indiagreen> http://haskell.cs.yale.edu/wp-content/uploads/2011/01/haskell-report-1.2.pdf
08:46:17 <ww> https://stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o
08:46:30 <ww> ^ has a few links to material, including that haskell report
08:48:09 <osa1_> it'd be seriously awesome if we could have cross-package hyperlinks in hackage index pages
08:50:19 <Zemyla> osa1_: I've seen them.
08:54:16 * hackagebot twitter-feed 0.2.0.2 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.2 (jpvillaisaza)
09:00:28 <Zemyla> Did Haskell 1.2 have typeclasses that could be declared over higher-kinded values, like Functor? Was that even possible back then?
09:06:45 <orion> If I have a list of records which contain a field "fooId :: Int", what's the most efficient way to convert that to a [Int] of fooIds?
09:07:19 <benzrf> map fooId?
09:09:10 <orion> Ah, thank you benzrf 
09:31:39 <Welkin> :t tillM
09:31:40 <lambdabot> Not in scope: ‘tillM’
09:33:16 <amontimur> geekosaur: i solved it by introducing a circular fundep. i dont know if thats very smart or very stupid...
09:34:11 <srhb> :t untilM
09:34:12 <lambdabot>     Not in scope: ‘untilM’
09:34:12 <lambdabot>     Perhaps you meant ‘until’ (imported from Prelude)
09:34:20 <srhb> Welkin: Ah well, it's in monad-loops or whatsit.
09:34:36 <Welkin> srhb: I was seeing if athan's special function was still defined
09:34:42 <Welkin> thanks though
09:34:42 <srhb> Oh, sorry.
09:44:18 * hackagebot diagrams-pandoc 0.1 - A pandoc filter to express diagrams inline using the haskell EDSL _diagrams_  https://hackage.haskell.org/package/diagrams-pandoc-0.1 (bergey)
09:44:20 * hackagebot refact 0.3.0.0 - Specify refactorings to perform with apply-refact  https://hackage.haskell.org/package/refact-0.3.0.0 (mpickering)
09:56:10 <Wizek> Can I somehow generate random haskell expressions?
09:57:08 <Welkin> rand expressions?
09:57:13 <Welkin> what do you mean?
09:58:00 <indiagreen> Wizek: you probably can with haskell-src-exts
09:58:12 <Wizek> random haskell AST
09:58:33 <Wizek> but I would probably convert it to string
09:59:17 <Wizek> indiagreen, I've looked in there, didn't see random generation capabilites. I am look again.
09:59:29 <indiagreen> Wizek: there are no random generation capabilities
09:59:40 <indiagreen> that's the part you would have to do by yourself
10:00:13 <indiagreen> but that's probably good because then you would be able to specify what you don't want in your expressions (since Haskell is big)
10:00:58 <Wizek> I would actually prefer most everything that is a valid haskell expression
10:01:19 <bergmark> Wizek: you can write quickcheck Arbitrary instances to do it, but note that the src-exts adt lets you produce some invalid constructs
10:01:38 <bergmark> ast*
10:02:54 <Wizek> I am thinking about this because I want to make sure that these functions work correctly: https://github.com/Wizek/dump/blob/master/src/Internal/Parser.hs
10:03:08 <Wizek> Yes, quickcheck arbitrary sounds promising
10:03:35 <Wizek> bergmark, What kinds of invalid constructs? Could you give me an example?
10:04:19 <bergmark> Wizek: i think it allows newtypes with several fields among other things
10:04:56 <Wizek> hmm. But that is a declaration. Can you think of an invalid expression?
10:06:09 <bergmark> oh right.... no i can't think of any invalid expressions
10:08:31 <Wizek> @hoogle Arbitrary Ext
10:08:32 <lambdabot> Did you mean: :: Arbitrary Ext
10:08:32 <lambdabot> No results found
10:09:55 <Wizek> @hoogle :: Arbitrary String
10:09:56 <lambdabot> Warning: Unknown type Arbitrary
10:09:56 <lambdabot> System.Info arch :: String
10:09:56 <lambdabot> System.Info compilerName :: String
10:12:21 <nikki93> @pl \a -> StateT $ pure . (,) a
10:12:22 <lambdabot> StateT . (pure .) . (,)
10:12:30 <Wizek> Can I search hoogle for instances?
10:12:46 <Wizek> of a type class
10:13:33 <nomeata> Does tasty support the notion of "test cases expected to fail"?
10:13:36 <mniip> Wizek, you can fin the typeclass
10:13:40 <mniip> and see instances under it
10:14:12 <Wizek> mniip, but that only shows the original instances, and not any other instances other packages might have defined, right?
10:16:34 <mniip> Wizek, I'm afraid that isn't searchable
10:17:18 <Wizek> no such thing as impossible https://www.google.com/search?q=site:hackage.haskell.org "Arbitrary Exp" 
10:17:19 <tzaeru> mmh.. some of these C vs Haskell examples in some tutorials and so are pretty terrible.. like.. yea, obviously creating a fibonacci sequence in C is pretty verbose if you are just using plain arrays and re-allocing them on every number @_@
10:17:21 <Wizek> :)
10:17:30 <tzaeru> and obviously it's less verbose when you're using another language's in-built lists.
10:18:00 <Wizek> and look at that! text-show-instances might have something useful in there
10:18:28 <subleq> with lazy io `lines` just works. With pipes/conduits, how does it work if a line spans a chunk boundary?
10:19:20 * hackagebot wai-extra 3.0.10 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.10 (MichaelSnoyman)
10:19:21 <orion__> Hey... I'm trying to write a bencode parses in haskell (total newbie) - its similar to json in that it can return any combination of ints, strings, maps, or lists - I'm trying to wrap my head around the type system - I need to make something similar to Either or Maybe to make this work but I'm stuck and need some help
10:19:27 <orion__> *parser
10:20:10 <Hijiri> subleq: the pipe/conduit that does the lining bit could just keep waiting for data until it finds a newline
10:20:29 <subleq> Hijiri: so you need extra logic to combine chunks?
10:20:48 <Hijiri> I think so, if I understand what you mean
10:21:27 <koala_man> orion__: you can use e.g.  data Foo = FooInt Integer | FooString String | ... 
10:21:50 <orion__> koala_man: thanks!
10:22:21 <Hijiri> subleq: using lines with lazy IO basically does that anyway, just the "chunk-getting" part is hidden in the lazy IO
10:23:09 <Hijiri> then lines requests the data one character at a time
10:28:17 <subleq> yeah...it's kind of nasty to have to write that logic though
10:28:37 <prinsen> GHC is not liking my #if MIN_VERSION_template_haskell(2,10,0) CPP
10:28:48 <prinsen> error: missing binary operator before token "("
10:29:48 <ReinH> @hackage bencode
10:29:48 <lambdabot> http://hackage.haskell.org/package/bencode
10:29:50 <ReinH> orion: ^
10:32:36 <geekosaur> @@ prinsen, @lpaste dist/build/autogen/cabal_macros.h
10:32:36 <lambdabot> Plugin `compose' failed with: Unknown command: "lpaste"
10:32:45 <geekosaur> bah
10:32:47 <geekosaur> @paste
10:32:47 <lambdabot> Haskell pastebin: http://lpaste.net/
10:37:36 <prinsen> @paste dist/build/autogen/cabal_macros.h
10:37:36 <lambdabot> Haskell pastebin: http://lpaste.net/
10:39:44 <prinsen> geekosaur: pls explain :)
10:40:24 <nschoe> Hey guys. I am developing a Neural Network library in Haskell and I have some questions about weird results. Does anybody happen to know an _active_ IRC chan where I can ask them? The problems are not (AFAIK) Haskell-related, that's why :/
10:45:20 <orion__> koala_man: Is there an easy way to get get my new "Foo" type to show since all its members can show?  Or easily unpack them so I can print?
10:45:20 <koala_man> orion__: you can just add  "deriving (Show)" , see http://learnyouahaskell.com/making-our-own-types-and-typeclasses
10:45:20 <orion__> koala_man: thanks! -- i swear I had already tried that - thanks! :-]
10:48:43 <creichert> orion__: btw, we made some improvements recently at https://github.com/creichert/bencode which simplify and improve some things. A good place to look is the test/ subdirectory for usage, etc
10:51:21 <orion__> creichert: thanks!  nice to have working implementation to have as a reference
10:54:21 * hackagebot hsexif 0.6.0.4 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.0.4 (EmmanuelTouzery)
11:12:18 <NemesisD> any conduit experts around by chance?
11:13:49 <Welkin> NemesisD: just ask your question and someone may answer
11:13:49 <Welkin> :)
11:15:07 <NemesisD> i need to take a list of producers and turn them into a producer that produces a list. the list would be 1 element from each producer and would omit an element if that producer was exhausted
11:16:20 <magistr> How to learn abstract nonsense?
11:16:22 <S11001001> NemesisD: can you take a Producer a to Producer (Maybe a) in accordance with exhaustion?
11:18:07 <dmj`> NemesisD: there's a "sequenceConduits" function, takes a list of conduits, combines all output into a single stream
11:18:13 <NemesisD> S11001001: hmm not sure. also not sure if Producer is the right type. in trying to write foo :: Monad m => [Producer m a] -> Producer m [a], it starts asking for ImpredicativeTypes D:
11:18:57 <arkeet> that's because Producer has a forall in it.
11:19:00 <S11001001> NemesisD: is Producer a type synonym?  that would make that
11:19:00 <arkeet> it's a type synonym.
11:19:23 * hackagebot dump 0.2.7 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.7 (Wizek)
11:20:02 <chreekat> magistr: which abstract nonsense? :)
11:21:07 <NemesisD> so in my program if i poke GHC to give me the types, i need a function foo :: [Conduit i m o] -> Conduit i m [o], which expands to foo :: [ConduitM i o m ()] -> ConduitM i [o] m (), which isn't quite sequenceConduits
11:21:46 <magistr> chreekat, in math people told me that i must learn abstract nonsense to learn cat theory to learn haskell
11:22:19 <NemesisD> foo = sequenceConduits expects ConduitM i [o] m () but got ConduitM i [o] m [()]
11:22:54 <magistr> chreekat, ZFC and lambda calculus too
11:24:03 <dmj`> NemesisD: hmm
11:24:10 <NemesisD> so the issue seems to be that sequenceConduits works on the r, not the o
11:24:23 * hackagebot dump 0.2.8 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.8 (Wizek)
11:24:39 <chreekat> magistr: the best way to learn haskell is to study haskell, in fact. You can learn other stuff, math and category theory, if it interests you. It will deepen your understanding of how Haskell was designed. But you can just start with Haskell.
11:24:53 <Wizek> Is there a way to automatically find all the dependency versions with which a package builds and passes all the tests? I would like to give just the right dependency ranges for a library, without being either too restrictive (barring possible candidates) or too broad, resulting in build or behaviour failures.
11:27:31 <orion__> When I'm debugging a non-haskell program I've always liked to put lots of "print" statements in a function so I can watch what its doing - how does one do this in haskell?
11:27:47 <NemesisD> dmj`: tried something like forever (yield =<< sequenceConduits cs) but no luck yet
11:28:10 <S11001001> orion__: part of the standard library https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Debug-Trace.html
11:28:28 <chreekat> Wizek: there is no community-standard way of doing that. Gotta script it somehow I would imagine.
11:28:31 <orion__> S11001001: awesome thanks
11:29:52 <Wizek> chreekat, That's okay if it is in a form of a script, I just imagine someone has already must have written it. Anyone knows anything about that? Or when you publish to hackage, do you just give an ad-hoc version range?
11:30:57 <maurer> Is there a standard function name modification for a version of the function that discards the failure state and replaces it with (error "somemessage") ?
11:31:09 <maurer> Like, Map.lookup vs Map.! is an example of this
11:31:28 <maurer> And I seem to remember there being a standard way to modify function names to describe this, but I forget what it is
11:32:07 <chreekat> Wizek: most people do it ad-hoc, I would say, using bounds to restrict known-bad deps when they become known.
11:32:44 <Wizek> become known? E.g. someone tries to build it, fails, then submits an issue/PR?
11:33:17 <Zemyla> I keep seeing "coffee comonad" instead of "cofree comonad".
11:34:02 <chreekat> Wizek: or the maintainer knows particular ones in advance, yes. Few if anybody exhaustively checks all possibilities
11:34:35 <chreekat> in general that's a combinatorial problem of no small magnitude
11:34:40 <Zemyla> And now I want a coffee comonad. I could extract coffee from it, and I could duplicate it to get more coffee.
11:34:59 <chreekat> maurer: usually people are going the other way :/ head -> headMay
11:35:27 <chreekat> maurer: there's the unsafe* idiom
11:35:36 <maurer> chreekat: Hrm. I'm trying to write stuff in yesod, and there's a function that does form parsing, and either gives back a successful parse or some error information
11:35:56 <maurer> however, a large chunk of my pages that are more api-y really just want to explode and throw 500 on failed parse
11:36:07 <chreekat> :t fromEither
11:36:08 <lambdabot> Not in scope: ‘fromEither’
11:36:09 <chreekat> er
11:36:11 <Wizek> I'm not sure exhaustive search is necessary. It could be given a combination of know good versions, and then it could try to broaden them one by one, looking for the edge where build or tests start to fail
11:36:12 <chreekat> :t fromRight
11:36:13 <lambdabot> Not in scope: ‘fromRight’
11:36:22 <chreekat> something like that. Maybe has fromJust
11:36:23 <maurer> chreekat: Doesn't work, it's a custom type
11:36:26 <y> Zemyla: you'd become rich with that comonad
11:36:32 <geekosaur> just use
11:36:33 <maurer> chreekat: I could write that function for that type instead I suppose
11:36:35 <geekosaur> :t either
11:36:36 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:36:49 <chreekat> maurer: ah, well, it's the same shape, so yeah
11:36:51 <maurer> It produces http://haddock.stackage.org/lts-2.19/yesod-form-1.4.4.1/Yesod-Form-Types.html#t:FormResult
11:36:54 <geekosaur> afaik Either does not have the fromJust type stuff
11:36:58 <Zemyla> :t either undefined id
11:36:59 <lambdabot> Either a c -> c
11:37:01 <maurer> I guess I can just make a projector out of it that errors instead
11:37:05 <chreekat> nods
11:37:06 <geekosaur> (and fromJust is kinda looked down on)
11:37:09 <Wizek> chreekat, But without such tool, is it preferable to have too broad or too restrictive ranges?
11:37:23 <chreekat> Wizek: you'll find that's a religious question
11:37:24 <maurer> geekosaur: I mean, my behavior when I match on it is to error, so...
11:37:25 <NemesisD> hmm, is it possible to implement forall i. Source m o => Conduit i m o
11:37:35 <maurer> geekosaur: the goal is to cause a 500 in this circumstance
11:38:10 <geekosaur> well, it's kinda preferred *not* to error/undefined/fail when possible. is there a way to send a meaningful 500 message, to help with diagnosis?
11:38:28 <geekosaur> (I can;t be the only one annoyed with uninformative 500 messages...)
11:38:48 <maurer> geekosaur: Sure, which is why my current thing looks like
11:38:49 <chreekat> Wizek: some people suggest adding an upper-bound on the major version of all dependencies (you use 2.8, so restrict < 3.0). Since that is speculative, and there are real tradeoffs, other people suggest leaving off upper bounds on all dependencies (execpt where you *know* of a conflict)
11:39:11 <maurer> geekosaur: http://lpaste.net/2981969955089547264
11:39:25 <maurer> I'm just trying to make it so that I don't rehandle it everywhere
11:39:52 <maurer> (basically, I want to use this for forms that are not intended to be user filled out, they're either hidden fields, or filled out by js, or whatever)
11:40:04 <maurer> (so if the form is filled out wrong, I've fucked up, not the user)
11:40:23 --- mode: ChanServ set +o mauke
11:40:23 --- mode: mauke set -q *!*@74-47-200-245.dsl1.rhnl.wi.frontiernet.net
11:41:17 <chreekat> maurer: "explodeyRunFormpost"
11:41:35 <chreekat> :P
11:42:23 --- mode: mauke set -o mauke
11:43:17 <orion__> is there a clever way with list comprehension to pair up items in a list?  [1,2,3,4,...] to [ (1,2), (3,4) ,...]
11:43:22 <Wizek> asked it here too: http://stackoverflow.com/questions/31617608/is-there-a-way-to-find-all-the-dependency-version-ranges-for-a-cabal-package maybe someone has already written a script like that and is willing to share
11:44:22 <geekosaur> orion__, list comp seems like the wrong tool for that. chunksOf?
11:44:24 * hackagebot lambdabot-core 5.0.3 - Lambdabot core functionality  https://hackage.haskell.org/package/lambdabot-core-5.0.3 (BertramFelgenhauer)
11:44:26 * hackagebot lambdabot-haskell-plugins 5.0.3 - Lambdabot Haskell plugins  https://hackage.haskell.org/package/lambdabot-haskell-plugins-5.0.3 (BertramFelgenhauer)
11:44:27 <mauke> > chunksOf 2 [1 ..]
11:44:27 <dmj`> orion__: in the case of an odd number of elements is the element dropped?
11:44:29 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,...
11:44:35 <dmj`> last element*
11:45:03 <orion__> dmj`: sure
11:45:27 <orion__> geekosaur: ill check it out
11:45:55 <orion__> maurer: oh thats cool
11:46:00 <mauke> > unfoldr (\xs -> do x : y : ys <- return xs; return ((x, y), ys)) [1 ..]
11:46:01 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
11:46:37 <maurer> orion__: Don't try to use it, it doesn't actually compile, it was just to give an idea of the function I was trying to name
11:49:24 * hackagebot lambdabot-irc-plugins 5.0.3 - IRC plugins for lambdabot.  https://hackage.haskell.org/package/lambdabot-irc-plugins-5.0.3 (BertramFelgenhauer)
11:49:26 * hackagebot lambdabot-novelty-plugins 5.0.3 - Novelty plugins for Lambdabot  https://hackage.haskell.org/package/lambdabot-novelty-plugins-5.0.3 (BertramFelgenhauer)
11:49:28 * hackagebot lambdabot-reference-plugins 5.0.3 - Lambdabot reference plugins.  https://hackage.haskell.org/package/lambdabot-reference-plugins-5.0.3 (BertramFelgenhauer)
11:49:30 * hackagebot lambdabot 5.0.3 - Lambdabot is a development tool and advanced IRC bot  https://hackage.haskell.org/package/lambdabot-5.0.3 (BertramFelgenhauer)
11:56:33 <lisbeth> Two questions: 1: can I launch ghci pointed at a specific .hs file. 2. Can I log all of the commands I put into ghci?
11:57:10 <arkeet> 1. ghci file.hs
11:57:13 <arkeet> 2. ~/.ghc/ghci_history
11:57:55 <arkeet> (or %appdata%\ghc\ghci_history on windows)
11:58:42 <magistr> how to learn abstract nonsense?
11:59:50 <bitemyapp> ^^ troll
12:00:58 <magistr> how to learn abstract nonsense?
12:01:14 <mauke> magistr: how would you pass the turing test?
12:01:26 <Adrian1982> hi, first time using this channel ? Can I have assistance installing "hat" ?
12:01:34 <Adrian1982> I receive error :  pi@pi1 ~ $ cabal install hat Config file path source is default config file. Config file /home/pi/.cabal/config not found. Writing default configuration to /home/pi/.cabal/config Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal update' to download it. cabal: There is no package named 'hat'. You may need to run 'cabal update' to get the latest list of available packages.
12:01:48 <magistr> mauke, How to learn abstract nonsense?
12:01:49 <mauke> Adrian1982: have you tried doing what it says?
12:02:04 --- mode: ChanServ set +o mauke
12:02:04 --- kick: magistr was kicked by mauke (you've failed the test)
12:02:20 <Adrian1982> yes, but "cabal update" just hangs
12:02:28 <mpickering> it takes  a while
12:02:38 <Adrian1982> ok, thanks
12:02:49 <magistr> How to learn abstract nonsense?
12:03:03 <maerwald> interesting question and I would answer it if you were not a troll
12:03:05 <mauke> takes about 22 seconds here
12:03:11 --- mode: mauke set +b $a:magistr
12:05:19 --- mode: mauke set -o mauke
12:06:10 <Adrian1982> running now for 3 minutes, stil not installed
12:06:32 <Welkin> wtf is with the troll
12:07:03 <bitemyapp> Welkin: I banned them from -beginners as well.
12:07:06 <oconnore> Adrian1982: you can try again with --verbose=3 to see what it's doing
12:07:15 <bitemyapp> they did the exact same thing repeatedly even after a couple warning kicks.
12:08:28 <Adrian1982> @oconnore, here is output pi@pi1 ~ $ cabal update --verbose=3 Downloading the latest package list from hackage.haskell.org Sending: GET /packages/archive/00-index.tar.gz HTTP/1.1 Host: hackage.haskell.org User-Agent: cabal-install/0.14.0 Creating new connection to hackage.haskell.org Received: HTTP/1.1 301 Moved Permanently Server: nginx/1.8.0 Content-Type: text/plain; charset=UTF-8 Location: /packages/index.tar.gz Transfer-Encod
12:08:28 <lambdabot> Unknown command, try @list
12:08:40 <geekosaur> @paste
12:08:40 <lambdabot> Haskell pastebin: http://lpaste.net/
12:08:43 <geekosaur> Adrian1982, ^^
12:09:08 <Adrian1982> geekosaur "^^" meaning ?
12:09:12 <oconnore> Adrian1982: yeah, so far that looks right, but it was cut off
12:09:22 <geekosaur> look at the preceding line that told you where the pastebin is
12:09:28 <oconnore> Adrian1982: geekosaur's link allows you to paste the whole thing
12:09:28 <geekosaur> please do not paste into the channel directly
12:09:30 <oconnore> it was cut off here
12:10:28 <Adrian1982> ok, http://lpaste.net/137272
12:10:30 <oconnore> Adrian1982: except for this -> cabal-install/0.14.0 . I am on cabal-install/1.22.6.0
12:11:14 <oconnore> Adrian1982: what is ghc --version ?
12:11:37 <Adrian1982> oconnore :  The Glorious Glasgow Haskell Compilation System, version 7.8.4
12:12:24 <oconnore> ok, and this is on a raspberry pi? It may just take a long time, that is a slow processor / disk
12:12:49 <Adrian1982> yes, raspberry pi 2
12:13:31 <oconnore> with 7.10.1, cabal update runs a lot faster for me, you may want to try that
12:13:35 <hiptobecubic> the problem is often that compiling with ghc takes enormous amounts of memory as well
12:13:54 <oconnore> otherwise I would go back to being patient :) Perhaps give it 20 minutes and come back?
12:14:13 <maerwald> @hoogle nomad
12:14:13 <lambdabot> No results found
12:16:14 <Adrian1982> ok, will do, thanks
12:20:25 <mpickering> What's the machinery which manages Paths_ files called?
12:20:30 <mpickering> I can't find the right term to google
12:20:54 <prinsen> How do I check in a CPP if a variable (TH) defined with -DTH=yes is equal to "yes" in a #if
12:21:33 <mauke> you don't
12:21:35 <geekosaur> you don't. generally numeric values are used
12:21:50 <prinsen> ok so ifdef instead
12:22:31 <geekosaur> mpickering, https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code helpful?
12:25:16 <mpickering> thanks geekosaur that's useful
12:33:51 <augur> is there a way to allow getLine'd inputs to use backspace?
12:33:57 <augur> and arrow keys, etc?
12:34:21 <mauke> backspace should just work
12:34:26 * hackagebot informative 0.1.0.8 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.8 (implementation)
12:34:29 <Welkin> vty?
12:34:30 <mauke> for arrow keys you need some kind of readline library
12:34:35 <mauke> like haskeline
12:34:37 <augur> mauke: it spits out ^?
12:35:01 <mauke> augur: is this in ghci?
12:35:14 <augur> cabal repl
12:35:34 <mauke> close enough
12:35:45 <mauke> probably needs hSetBuffering stdin LineBuffering
12:35:51 <augur> aha
12:36:03 <mauke> (which is the default outside of ghci)
12:36:42 <augur> that did it! :)
12:57:24 <orion> In this statement: " However, if a Foldable
12:57:25 <orion> is also a Functor
12:57:25 <orion> , parametricity and the Functor law guarantee that toList
12:57:25 <orion> and fmap
12:57:35 <orion> commute." -- what does parametricity refer to?
12:59:28 * hackagebot informative 0.1.0.9 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.9 (implementation)
13:02:40 <indiagreen> .
13:02:47 <indiagreen> ouch, nevermind
13:04:56 <athan> Is there any kind of SetWith data structure? Which sorts data of type `a`, by some index of type `b`, when provided a function of `a -> b`?
13:06:19 <athan> Something like `newtype SetWith b a = SetWith {unSetWith (Map b a, a -> b)}`
13:08:00 <athan> and `empty :: (a -> b) -> SetWith b a`
13:09:38 <koala_man> athan: so basically a Map that automatically derives the key from the element using a function?
13:10:49 <Welkin> almost like a bimap?
13:14:34 <augur> should i git-ignore sandboxes?
13:14:39 <augur> probably, right?
13:14:43 <catgocat> @pl possible grid = checkVertical grid ++ checkDiagLeft grid ++ checkDiagRight grid ++ checkHorizontal grid
13:14:43 <lambdabot> possible = liftM2 (++) checkVertical (liftM2 (++) checkDiagLeft (liftM2 (++) checkDiagRight checkHorizontal))
13:15:25 <indiagreen> augur: yep
13:15:34 <indiagreen> augur: here's the file I use: https://github.com/aelve/microlens/blob/master/.gitignore
13:16:13 <catgocat> @pl stuff f = f x
13:16:13 <lambdabot> stuff = ($ x)
13:17:15 <shirt> "cabal build" doesn't seem to be running my custom Setup.hs file
13:18:31 <fosterite> catgocat: concatMap ($ x) [check..., check..., check...]
13:18:36 <hexagoxel> shirt: what is your `build-type` ?
13:18:54 <catgocat> @fosterite yes, I know
13:18:55 <lambdabot> Unknown command, try @list
13:19:06 <zachk> does haskeline support using Handle for say, over tcp/ip sockets?
13:20:34 <shirt> hexagoxel: oh, oops, i forgot to set it to Custom. thanks!
13:22:17 <augur> indiagreen: \o/
13:22:20 <augur> that works nicely :)
13:22:20 <athan> koala_man: Yep, that's right :)
13:22:31 <athan> Welkin: Hmm... no, I don't think it's a bimap
13:24:08 <slowbait> athan: What about writing an Ord instance?
13:24:29 * hackagebot informative 0.1.0.10 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.10 (implementation)
13:24:31 * hackagebot yesod-table 1.0.3 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-1.0.3 (andrewthad)
13:29:57 <tompc> does anyone know of a good example of a web app where both the front and backend are in the same language
13:30:53 <jle`> tompc: most node apps are like that, but if you're talking about haskell, fpcomplete might come close; its front-end is in fay, a dialect of haskell
13:31:20 <tompc> well, just in general i want to avoid JS
13:31:22 <jle`> i've done some toy SPA's where haskell is the front-end using ghcjs
13:31:41 <Adrian1982> Hi, I'm receiving this issue http://lpaste.net/137280 after installing happy. How can I check happy version ?
13:31:43 <jle`> it's nice cause then you can share data types
13:32:03 <tompc> that's what i'm trying to get to
13:32:15 <tompc> though better yet would be transparent calls to the server
13:32:56 <tompc> partly so that they're checked to exist
13:33:59 <tompc> Adiran1982: cabal info happy
13:34:00 <tompc> maybe
13:35:14 <Adrian1982> tompc: seems version is unknown : http://lpaste.net/137281
13:36:03 <tompc> try installing it then?
13:36:52 <Adrian1982> tompc , this is command I use to install (using Arm processor on PI) - how do I set version : "cabal --ghc-options="-opta-mcpu=cortex-a7 -opta-mfpu=neon -opta-mtune=native -opta-mfloat-abi=hard" install happy" ?
13:37:45 <tompc> replace 'happy' with 'happy-1.17' 
13:46:25 <Adrian1982> tompc : http://lpaste.net/137281
13:51:39 <tompc> try a larger version of happy
13:51:47 <tompc> one that allows base 4.7
13:53:53 <Aejay> Question! I need to make the ackermann function of A(4,2) faster. Any suggestions?
13:54:31 <lpaste_> Aejay pasted “Ackermann” at http://lpaste.net/137285
13:54:53 <Adrian1982> I tried version happy-1.19.5, but version is unknown : http://lpaste.net/137284 . how to check happy version allows base 64 ?
13:59:56 <catgocat> whats an easy way to check if all elements in a list are >= 0
14:00:04 <catgocat> all (>=0) list ?
14:00:42 <athan> yep
14:00:55 <athan> > let list = [1,2,3,4] in all (>= 0) list
14:00:57 <lambdabot>  True
14:01:18 <Aejay> also notable: any
14:01:20 <Aejay> :t any
14:01:21 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
14:01:34 <Aejay> > any (== 2) [1,2,3,4,5]
14:01:35 <lambdabot>  True
14:01:44 <mauke> > let sweet :: [Word] -> Bool; sweet _ = True in sweet [1,2,3,4]
14:01:45 <lambdabot>  True
14:04:20 <BenCHammer> Holy heck, I just started getting into haskell
14:04:26 <BenCHammer> It's so damn neat 
14:04:27 <stapler> BenCHammer: so did I!
14:04:34 <stapler> although I have some questions here.
14:04:35 <Aejay> BenCHammer: How are you finding it?
14:04:48 <stapler> I think I "get" monads, but I don't see the difference from applicatives
14:04:52 <BenCHammer> I'm blown away by the list comprehensions 
14:05:02 <stapler> BenCHammer: you'll be blown away by more shortly!
14:05:05 <Aejay> stapler: You can't `join` using applicatives.
14:05:15 <Aejay> That's the big difference.
14:05:18 <Aejay> :T join
14:05:23 <Aejay> :t join
14:05:25 <lambdabot> Monad m => m (m a) -> m a
14:05:43 <stapler> ah, i see
14:05:47 <BenCHammer> I was curious what realy world applications have come from haskell?
14:05:52 <BenCHammer> Like anything I might have heard of 
14:06:10 <kristof> BenCHammer: Typeclasses/interfaces, generics
14:06:26 <BenCHammer> btw, you guys have a great rep
14:06:52 <BenCHammer> I only came to this channel because I've seen quite a few forums say #haskell is really friendly
14:07:12 <mauke> BenCHammer: darcs, xmonad, pandoc
14:07:13 <stapler> Aejay: and what are the points of applicatives vs.functors?
14:07:21 <stapler> just trying to understand the hierarchy here, since they all seem to be related
14:07:34 <stapler> Aejay: i totally get what they're used for however, and its pretty cool.
14:07:36 <Aejay> stapler: There are a few things that can be functors that can't be applicatives.
14:07:45 <dmj`> stapler: all applicatives are functors
14:07:58 <Aejay> stapler: furthermore, you can define functors via applicatives, and applicatives via monads.
14:08:28 <indiagreen> stapler: applicatives can combine 2 values like “f a → f b → f (a, b)”, functors can't
14:08:30 <monochrom> there are non-applicative functors
14:08:32 <Aejay> Ie; Functors E Applicatives E Monads (E -> within)
14:09:17 <monochrom> actually, I am not sure I know an example. so nevermind.
14:09:26 <Aejay> stapler: Applicatives allow one to combine functors on the same level, as indiagreen said, but only monads can `join` nested monads.
14:09:46 <stapler> right
14:09:59 <stapler> and am i correct in thinking of all of these as uh "computational contexts?"
14:10:00 <kristof> Monads ∈ Applicatives ∈ FuFunctors
14:10:14 <stapler> as if they were uh structs just being passed around
14:10:17 <stapler> but "hidden"
14:10:22 <kristof> stapler: That's mostly monad
14:10:30 <stapler> kristof: but I'm correct in thinking that
14:10:36 <monochrom> I have this possible example in mind. "data X next = Get (Int -> next) | Put Int next". can this be made Applicative?
14:10:56 <kristof> stapler: Sort of. But I think the really best definitions of functors, applicatives, and monads comes from looking at the category theory.
14:11:16 <Aejay> monochrom: Yes.
14:11:35 <kristof> stapler: Say I have some wrapper type f. if there is a way to take functions of (a -> b) to (fa -> fb), then I have a functor.
14:11:54 <kristof> stapler: This works great for container types.
14:12:02 <stapler> kristof: but functors, applicative, and monads are not only in the name of type safety
14:12:38 <kristof> stapler: I'm not talking about type safety. I'm talking about transformations of data, which are very well modeled as categories of objects (stuff) and morphisms (stuff-to-stuff)
14:13:37 <kristof> stapler: An applicative is what happens when there is a way to take a container over a function f(a->b) and apply it to some containers. We're "applying" the contained function
14:14:04 <kristof> stapler: (Just +2) <*> Just(2) == Just 4
14:14:33 <kristof> stapler: And then monads are the sequential computation you are talking about. They abstract plumbing. normally you have functions a -> mb but you want to chain these together. Bam, use mbind.
14:14:34 <stapler> what is the point of containing a function?
14:14:50 <stapler> context?
14:15:03 <isBEKaml> so it builds a computation within a context
14:15:04 <kristof> stapler: There is a really good paper that has better examples that I myself cannot best
14:15:20 <kristof> stapler: What isBEKaml said. Currying lends itself well in applicative contexts
14:15:41 <kristof> stapler: + <$> Just 2
14:15:51 <kristof> stapler: That gives me Just(+2)
14:16:15 <kristof> so it's really common to raw_function <$> arg <*> next_arg <*> next_arg . . .
14:16:19 <stapler> but you can't do uh
14:16:19 <arkeet> you can define Applicative in terms of pure and liftA2
14:16:29 <stapler> Just(+2) <$> (Just 2)
14:16:36 <kristof> stapler: Exactly
14:16:41 <kristof> stapler: See my last comment
14:16:53 <monochrom> it's Just (+2) <*> (Just 2)
14:17:03 <stapler> [16:16] <kristof> so it's really common to raw_function <$> arg <*> next_arg <*> next_arg . . .
14:17:05 <stapler> this uh this helped
14:17:19 <isBEKaml> stapler: don't be troubled by those symbols. Think of <$> as (f)map and <*> as apply
14:17:20 <kristof> stapler: Let me find the paper I was talking about
14:17:28 <stapler> looking at postgresql-simple on 24 days of hackage
14:17:29 <stapler>   fromRow = Child <$> field <*> liftM2 Location field field
14:17:48 <stapler> makes a bit more sense now
14:17:51 <kristof> stapler: liftA2. liftM2 lifts to monads. liftA2 lifts to applicatives
14:18:01 <r33th4x0r> ung to young to remember. when i was one should've been a lot. hippy. guy probably say FUCK Alaska and Hawaii! the family and moved to remember. when anyone should announce a long-term agreement as soon as soon as soon as soon as Monday.
14:18:03 <r33th4x0r> oh my dad). my dad where are 50 dumbass. FUCK Texas! new one should've been anyone should've been wearing a helmet. Asking a helmet. Asking for that?. better he legit. also don't know when my grandpa got the flag after have from my folks were his medals. i have not that I know, he took officer. when a lot. hippy. who died when a long-term agreement as Monday.
14:18:05 <arkeet> fortunately they coincide on monads.
14:18:07 <r33th4x0r> There in Germany in Germany versions of two that all his fireplace many versions of two civil war swords perched above his eisenhower jacket, and WR Dez Bryant could be funny where army in '70 their stuff at my grandpa who died when he got the sword for that all his medals. i have been a lot. hippy. who died with texas! new one should announce a lot. hippy. guy probably say FUCK Texas to secede 
14:18:07 --- mode: ChanServ set +o monochrom
14:18:08 <r33th4x0r> 0 they most likely still things he left my grandpa's house (mom's little brother was a total dick, but them.
14:18:08 <arkeet> (or ought to.)
14:18:09 <r33th4x0r> every year. Yeah. my uncle (mom's dad when anyone should've been anyone should've been wearing for weed did he ditchd the other was a swords perched above his medals. i have not the flag after he was a got the hood. how much fucking for that's nothing. GB Packet, and moved them.
14:18:10 <r33th4x0r> k is ballsy. Cowboys and Hawaii! they left that's nothings he took off at my uncle has two civil war swords perched above his burial flag, his fireplace mantle. no idea they most likely say FUCK Texas threatening a helmet. Asking weed did he took officer. are his medals. i have been a long-term agreement as soon as Monday.
14:18:11 --- mode: monochrom set +b *!*@host22.137.druknet.bt
14:18:11 --- kick: r33th4x0r was kicked by monochrom (r33th4x0r)
14:18:20 <stapler> thanks, monochrom 
14:18:22 <kristof> monochrom: +b pl0x
14:18:27 <kristof> oh
14:18:30 <kristof> you did, okay :)
14:19:08 --- mode: monochrom set -o monochrom
14:19:13 <kristof> stapler: http://strictlypositive.org/Idiom.pdf
14:22:18 <isBEKaml> kristof: heh. Conor has 2 other versions on the same paper like "Too long" "Too silly".
14:22:18 <kristof> stapler: Finally, remember to always use the least expressive data structure. "I need to map functions over containers!" Use functions. "I need to build up computations and apply them incrementally!" Use applicatives. "I need to abstract plumbing between functions of a -> container(b)!" Use a monad.
14:22:28 <maerwald> can someone explain to me the purpose of those random text bots?
14:22:30 <kristof> isBEKaml: link?
14:22:36 <maerwald> I mean... it's not even advertisement
14:22:51 <kristof> maerwald: Have you ever played a role playing game after having a bad day? GTA is good for observing this effect
14:22:54 <isBEKaml> kristof: on his home page. 
14:23:02 <isBEKaml> kristof: strictlypositive.org
14:23:51 <stapler> monochrom: I've never understood why ops just uh stay unopped
14:23:53 <kristof> maerwald: Detached aggression with noticeable effect makes for good stress relief. "Wow, these people are really going to get pissed off!" 
14:24:00 <stapler> and I've been an ircop on a fairly large network
14:24:27 <kristof> stapler: Keeping your hat on makes you seem like a jerk!
14:25:13 <isBEKaml> stapler: also with keeping your hat on, you allow other people to nag you with requests. 
14:25:14 <stapler> kristof: seems a bit silly
14:25:25 <stapler> isBEKaml: whats wrong with that?
14:25:56 <glguy> Moderation questions and discussion are welcome in #haskell-ops
14:26:08 <mauke> stapler: http://freenode.net/channel_guidelines.shtml
14:26:09 <merijn> maerwald: Usually they just attempt to flood the channel and/or DOS freenode
14:26:24 <merijn> maerwald: Freenode is under near permanent attack my scriptkiddies
14:26:30 <isBEKaml> stapler: nothing wrong if you're inclined to help
14:26:42 <maerwald> mh
14:28:05 <catgocat> Do you guys do small code reviews?
14:29:44 <fosterite> throw it up on lpaste or something and I'll take alook at it at least
15:11:01 <shirt> how do i convert a strict Text to a lazy ByteString?
15:11:47 <indiagreen> shirt: use encodeUtf8 from Data.Text.Encoding and then convert the strict bytestring to lazy bytestring
15:12:17 <shirt> ok thanks
15:17:01 <Bashmetim> I have a sort of theoretical question
15:17:20 <Bashmetim> Why isn't 'join' a part of the Monad typeclass?
15:17:53 <hpc> stupid history things happened
15:17:57 <hpc> and join got the definition it did
15:18:22 <hpc> it should be part of the class definition
15:18:30 <Zemyla> Same reason 'fail' is a part of it.
15:18:37 <indiagreen> Bashmetim: it's more of a historical question, I guess (you can define join with >>=, so it doesn't have to be a part of the class), tho *at the moment* join actually can't be made part of Monad because of something with roles, but they're going to fix it (I think)
15:19:08 <Bashmetim> Something with roles? What do you mean?
15:20:13 <indiagreen> Bashmetim: https://ghc.haskell.org/trac/ghc/ticket/9123
15:20:15 <elbens> Can someone help me understand the cabal install error messages here (http://lpaste.net/7442750382016561152). Is it saying that I have regex-base and mtl installed globally that is incompatible with my sandboxed dependencies? Namely, mtl 2.2.1 is installed regex-base-0.93.2 requires mtl 2.1.3.1?
15:20:34 <indiagreen> (I don't actually understand what the problem is, I just know it exists)
15:20:49 <elbens> *mtl 2.2.1 is installed but regex-base-0.93.2 requires mtl 2.1.3.1
15:22:19 <Bashmetim> indiagreen: Huh. Is it possible to derive an instance of Monad? It seems like that's related to the trouble their having.
15:22:35 <Bashmetim> *otherwise possible
15:22:41 <mauke> Bashmetim: yes, with newtype deriving
15:22:57 <indiagreen> Bashmetim: it's possible to autoderive it if you have a newtype which wraps a type which already is an instance of Monad
15:23:04 <indiagreen> with the GeneralizedNewtypeDeriving extension
15:23:29 <indiagreen> and the whole roles thing was created because it turned out that GND was unsafe and you could write unsafeCoerce using it
15:23:35 <glguy> elbens: sandboxes only allow  one of each package. It's best not to install things globally when using sandboxes as it limits your flexibility in sandboxes
15:25:20 <MagBo> Ughm, people, I feel awkward out of the blue about styling of "let ... in" construct.
15:25:49 <indiagreen> MagBo: you're not alone
15:25:50 <MagBo> Can you suggest a style guide that suggests how to style it?
15:25:57 <bergmark> MagBo: i use where instead as much as possible
15:26:01 <ski> "styling" ?
15:26:04 <MagBo> bergmark: haha, mee too!
15:26:22 <indiagreen> there are people who don't use it at all simply because of confusion about how to indent whatever comes after “in”
15:26:43 <indiagreen> (when it's on 2 lines)
15:27:03 <indiagreen> anyway, I mostly use the do trick instead
15:27:34 <MagBo> indiagreen: I tend not to use let for a bunch of reasons (except the cases when I *really* need it). And that wasn't one of those. But now that I think about it, everything feels very awkward.
15:27:35 * ski would usually place `in ' just before the body, which is indented to the same level as the declarations
15:28:06 <MagBo> ski: ughm, so, ``in`` on a separate line?
15:28:21 <elbens> elbens: I understand that now. How can I safely delete my global conflicts? Can I remove the .conf files found in `ghc-pkg list | grep regex-base`?
15:28:33 <isBEKaml> I just think of `let` and `in` as column markers, marking off other things past them
15:28:50 <ReinH> I avoid the issue by using where instead ;)
15:28:54 <ski> MagBo : unless all fits comfortably on a single line, of course
15:28:56 <ski> like
15:29:03 <ski>   let ...
15:29:05 <ski>       ...
15:29:08 <ski>    in ...
15:29:12 <MagBo> ah, ok
15:29:23 <ski> or perhaps
15:29:26 <ski>   f x ... = let
15:29:33 <ski>        ...
15:29:33 <ski>        ...
15:29:37 <ski>     in ...
15:29:40 <ReinH> ew
15:29:43 <ski> or something similar
15:29:44 <bergmark> >_<
15:30:06 <ski> (in this case, there would usually be more cruft inbetween `=' and `let', though. otherwise i'd usually use `where' instead)
15:30:11 <MagBo> ReinH: there are cases where we'd better use ``let`` instead of ``where``. Remember canonical implementation of State monad from the paper?
15:30:12 <isBEKaml> ski: the first form is what I use. I find the latter super awkward. 
15:30:52 <ski> (the point of the latter form is to avoid having most of the code there drifted far to the right)
15:31:28 <ski> MagBo : elaborate ?
15:32:34 <MagBo> ski: one minute
15:33:30 <MagBo> I'm trying to remember what was the issue.
15:37:09 <MagBo> ski: ah, got it
15:37:24 <MagBo> consider implementing bind in state monad
15:37:52 <Bashmetim> I just find where easier to read most of the time. If I say f x = ... I want to follow with what f x *is* and define subexpressions after
15:39:15 <MagBo> Bashmetim: wait, is where exactly as expressive as let?
15:39:46 <Bashmetim> Usually, I could probably get your State bind using only where...
15:40:37 <Zemyla> MagBo: Yes, it is. It's just a syntactic difference.
15:41:14 <MagBo> That's how I felt about it, didn't do the math though.
15:41:45 <Bashmetim> Like this:
15:41:48 <Bashmetim> (State f) >>= getState = State f'                                                                                                                                         
15:41:51 <Bashmetim>     where f' s = g s'                                                                                                                                                     
15:41:54 <Bashmetim>           (x, s') = f s                                                                                                                                                   
15:41:57 <Bashmetim>           (State g) = getState x 
15:42:00 <Bashmetim> ?
15:42:02 <Bashmetim> Ew, sorry about the whitespace...
15:42:37 <Bashmetim> (State f) >>= getState = State f'
15:42:37 <Bashmetim>     where f' s = g s'
15:42:37 <Bashmetim>           (x, s') = f s
15:42:37 <Bashmetim>           (State g) = getState x
15:42:40 <Bashmetim> :)
15:43:38 <MagBo> Wow, I'm really ashsamed! I didn't know that you can refer to x bound via pattern-matching (not by defining it) in other where bindings.
15:44:01 <MagBo> And I have Haskell in production :D
15:44:04 <hpc> ditto with let
15:44:35 * hackagebot nvim-hs 0.0.2 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.0.2 (saep)
15:44:38 <d-snp> huh
15:44:41 <d-snp> hmm
15:44:47 <Bashmetim> hmmmm?
15:44:49 <d-snp> oh that makes sense I think :P
15:45:04 <Bashmetim> It's kind of like juggling, isn't it?
15:45:19 <athan_> What would you call a structure where you can only establish a functor-like map, if you have a reversal method? S.t. `fmap' :: (a -> b) -> (b -> a) -> f a -> f b`?
15:45:51 <Bashmetim> That's a... profunctor? cofunctor?
15:45:56 <Bashmetim> Hold on, one of those...
15:46:04 <athan_> Bashmetim: Its not as general as a profunctor
15:46:13 <athan_> it's almost trivial how it works
15:46:20 <indiagreen> Functor + Contravariant
15:46:20 <athan_> I feel like it's yoneda-ey :s
15:46:26 <MagBo> Bashmetim: juggling as in implementing bind for State or making lets into wheres?
15:46:47 <indiagreen> no, wait, that's or, not and
15:46:56 <athan> indiagreen: It's neither, independently
15:46:58 <MagBo> I feel like I'm juggling when I think about fixed point operators and stuff like bind of state.
15:46:59 <athan> it needs both :(
15:47:09 <Bashmetim> MagBo: implementing bind for state. The variables sort of cycle around...
15:47:14 <MagBo> Yeah!
15:47:42 <ski> MagBo,Zemyla : no. `where'-bindings are in scope in guards (since `where' attaches to a defining equation (possibly with multiple guards&definientia)
15:47:55 <ski> Bashmetim : `(State f) >>= getState' could be `State f >>= getState'
15:49:31 <athan> :(
15:49:34 <ski> athan : hm, i'd say it's invariant (in the argument). one could think of it as a functor from a category where all morphisms are isomorphisms
15:49:35 <Bashmetim> True true... With guards, doesn't GHC warn you or make you move the 'where' to the bottom of the whole statement?
15:49:36 * hackagebot hothasktags 0.3.4 - Generates ctags for Haskell, incorporating import lists and qualified imports  https://hackage.haskell.org/package/hothasktags-0.3.4 (LukePalmer)
15:49:53 <athan> ski: That makes sense! Hmm
15:50:11 <indiagreen> a-ha
15:50:14 <indiagreen> http://hackage.haskell.org/package/invariant-0.1.2/docs/Data-Functor-Invariant.html#v:invmap
15:50:27 <athan> indiagreen: O_O
15:50:34 <ski> athan : you could define `data Iso a b = PromiseInverses (a -> b) (b -> a)' ..
15:50:40 <indiagreen> turns out Hayoo was enough
15:51:09 <athan> Shoot, sorry
15:51:12 <athan> thanks indiagreen & ski
15:51:37 <ski> MagBo : anyway .. you didn't complete your elaboration ?
15:54:36 * hackagebot graphics-drawingcombinators 1.5.1 - A functional interface to 2D drawing in OpenGL  https://hackage.haskell.org/package/graphics-drawingcombinators-1.5.1 (LukePalmer)
15:55:50 <ski> btw, i'd prefer being able to define `(>>=)' for `State s' something like :
15:56:01 <ski>   RunState (ma >>= amb) s0 = (b,s2)
15:56:07 <ski>     where
15:56:20 <ski>     (a,s1) = RunState   ma    s0
15:56:28 <ski>     (b,s2) = RunState (amb a) s1
15:56:45 <ski> (or, in practice, the "eta-reduction" of that)
15:57:36 <MagBo> ski: that's because it didn't make sense, as shown by Bashmetim 
15:57:54 <ski> oh, ok
15:57:56 <Bashmetim> ski: *That* is funky, you can define a function like that?
15:57:59 <MagBo> I wanted to say that all this juggling is way easier to write with let and very difficult with where
15:58:07 <ski> Bashmetim : unfortunately not
15:58:53 <ski> Bashmetim : i tentatively call such a syntax "message-dispatching" (as opposed to "pattern-matching"). this is related to OO. Erik Poll uses a notation like this in some papers
15:59:13 <ski> Bashmetim : here's a few more examples :
15:59:34 <Bashmetim> Honestly, I've got some trouble reading that, but I'm not sure there's any way to describe bind for state that won't require some teasing-apart
16:00:27 <mniip> State f >>= State g = State (f >>> second g >>> snd)
16:00:42 <mniip> damn
16:00:46 <mniip> that's applicative
16:00:51 * mniip hides
16:00:54 <Bashmetim> And arrow-y!
16:01:03 <ski>   record Stream a
16:01:07 <ski>     where
16:01:15 <ski>     Head :: Stream a -> a
16:01:18 <ski>     Tail :: Stream a -> Stream a
16:01:20 <ski> (or perhaps
16:01:23 <mniip> err
16:01:44 <ski>   record Stream a = Head :: a
16:01:53 <ski>                   & Tail :: Stream a
16:01:54 <ski> )
16:01:58 <ski> and then
16:02:06 <ski>   repeat :: a -> Stream a
16:02:20 <ski>   repeat a = this
16:02:22 <ski>     where
16:02:28 <ski>     Head this = a
16:02:32 <ski>     Tail this = this
16:03:14 <ski>   from :: Num a => a -> Stream a
16:03:19 <ski>   Head (from n) = n
16:03:26 <ski>   Tail (from n) = from (n+1)
16:03:55 <rom1504> gotta paste ghc
16:04:38 <ski> Bashmetim : you can think of `Head' and `Tail' here as "messages" (in the OO sense) that are sent to the "object". the definition of the object (`this' in the first case, `from n' in the second one) tells how it "behaves" when sent a particular message
16:04:59 <Bashmetim> There it is... I wasn't doing haskell before 2010, but my understanding is that they specifically disallowed that in the '10 standard
16:05:00 <ski> Bashmetim : if you want messages which accept arguments, then you make them be of function type
16:05:11 <mniip> actually that's not even applicative
16:05:14 <mniip> I don't know what function I just defined
16:05:15 <ski> Bashmetim : disallowed what ?
16:05:16 <mniip> >> maybe
16:06:00 <mniip> ski, so like a GADT but not?
16:06:14 <Bashmetim> Wikipedia has stub saying that it banned "n-plus-k patterns" - https://en.wikipedia.org/wiki/Haskell_%28programming_language%29
16:06:18 <mniip> cogadt
16:06:24 <mniip> if that makes sense
16:06:35 <Bashmetim> This seems like pattern matching "n + 1", but on steroids
16:06:46 <mauke> a gadt is a sum. this is like a product, but everything's backwards
16:06:53 <mniip> yeah
16:06:56 <mniip> cogadt
16:07:21 <Bashmetim> cogadt?
16:07:31 <mniip> co-GADT
16:07:41 <ReinH> No. No stop.
16:08:01 <mauke> did you mean: co-start
16:08:06 <Bashmetim> por que?
16:08:13 <ski> mniip : well, "coGADT" would add the possibility to use indices as well
16:08:19 <ReinH> mauke: I will coend you.
16:08:30 <ski> (which could be useful in some cases, i think)
16:08:41 <mauke> you're coconuts
16:09:03 <ReinH> heh
16:13:08 <ski> @where ErikPoll
16:13:09 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001
16:13:09 <lambdabot> at <http://www.cs.ru.nl/E.Poll/papers/ita01.pdf>
16:13:26 <ski> Bashmetim : see the second paper there, section 2.2, for this syntax
16:18:17 <AaronFriel> Haskell folks, and anyone experienced with Yesod. I want a piece of advice
16:18:48 <AaronFriel> I am working with an old-ish project (started ~2 years ago) with Yesod. I want to switch to current Yesod. I have a few custom things, which I don't know if they break.
16:19:00 <AaronFriel> (A custom wai routing middleware that does subdomain-based routing)
16:19:23 <AaronFriel> How would you go about uprading an old project that used to use "yesod-platform" to the new yesod system
16:23:54 <Bashmetim> AaronFriel are you using git or some other vcs?
16:24:41 <Bashmetim> If I were you I'd just make a branch and start the work of updating it. Then, no matter how much work it takes, you can just merge when it's done
16:25:03 <Bashmetim> Without ever breaking code that you currently know works
16:25:11 <AaronFriel> Bashmetim: Oh git of course. It's just, what do you mean by "just start upgrading it"
16:25:22 <AaronFriel> The new dependencies break basically everything
16:25:46 <AaronFriel> If someone else has gone through upgrading Yesod before, it would be helpful to know if they hit any pain points along the way and what would work better
16:26:04 <AaronFriel> (I'm actually having a bit of a problem even getting it to build using Stack at the moment)
16:26:06 <Bashmetim> Hm. In that case you'd have to fix all the code that no longer works with the recent libraries
16:26:24 <hasket> anyone have a tutorial on installing stack and getting set up with some kind of text editor? ghc-mod doesn't play nice yet
16:27:25 <AaronFriel> hasket: I use Sublime with cabal sandboxes and ghc-mod and it seems to work fine. Does ghc-mod not play nice with Stack's method of installing dependencies?
16:27:42 <kadoban> hasket: The installing stack part is pretty trivial. Which text editor? Just so you know, you don't really need much of anything, a 90% setup is just any good text editor with decent spaces setup and syntax highlighting and having ghci in a separate window
16:28:01 <hasket> kadoban: sounds good. I use vim mostly
16:28:03 <kadoban> hasket: "good" text editors are vim, emacs, sublime, atom, maybe notepad++
16:28:04 <hasket> But it doesn't matter
16:28:06 <osa1_> why foldr in Data.List is not specialized to lists?
16:28:21 <Bashmetim> Haskell-mode for emacs is very mature. Atom has a nice haskell-ide package, but it's obviously really new.
16:28:40 <hasket> I like atom for haskell, but with stack dependencies it doesn't play nice
16:28:42 <hasket> Which is fine
16:28:43 <AaronFriel> :t foldr
16:28:44 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:28:49 <AaronFriel> :t Data.List.foldr
16:28:50 <hasket> AaronFriel: mhmm
16:28:50 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:28:52 <AaronFriel> huh
16:28:53 <kadoban> hasket: Yeah you don't need much then. Getting it setup for all that stuff is a bit … troublesome unfortunately.
16:29:06 <hasket> okay I'll just use vim and ghci
16:29:07 <Bashmetim> kadoban: Maybe notepad++ = Nothing
16:29:07 <arkeet> AaronFriel: ghc 7.10
16:29:09 <hasket> Like the old days
16:29:10 <hasket> lol
16:29:10 <bergmark> osa1_: there was discussion about this before 7.10, i think mostly because it'd cause clashes if Prelude+Data.List was imported
16:29:18 <AaronFriel> arkeet: Oh that's new
16:29:29 <kadoban> Bashmetim: :)
16:29:54 <AaronFriel> Has anyone here gone through the pain of upgrading Yesod before? Any advice before I start ripping things out?
16:30:17 <Bashmetim> hasket Check out the Hydrogen package for Atom. It runs Jupyter kernels so you can treat the buffer like an ipython notebook
16:30:27 <Bashmetim> It plays nice with Haskell!
16:30:47 <hasket> Bashmetim: sweet will do. I like atom a lot and have used it, but wanted to try out stack. I think I'm going to stick with cabal until stack matures
16:31:29 <athan> What is the suggested way to get a package on stackage, if the author seems to have abandoned the project?
16:31:35 <athan> Adoption?
16:31:45 <dcoutts> athan: on stackage or on hackage?
16:32:01 <Bashmetim> AaronFriel I haven't had to do that myself, just keep a copy of the pre-update branch on hand in case anything goes south, and commit often!
16:32:07 <athan> dcoutts: stackage, the package is already on hackage
16:32:12 <athan> @invariant -- dcoutts
16:32:12 <lambdabot> Unknown command, try @list
16:32:15 <AaronFriel> Bashmetim: Thanks for the advice... welp, herewego.jpg
16:32:19 <athan> @hackage invariant
16:32:19 <lambdabot> http://hackage.haskell.org/package/invariant
16:32:21 <athan> ><
16:33:08 <dcoutts> athan: ok, but you need to be in a position to maintain it, so you'd effectively need to be one of the maintainers on hackage too, if I understand the stackage contract for people sponsoring packages
16:34:47 <athan> dcoutts: Hmm, okay. I'll do my best to contact the author and take control of it, in case they can't. Worst case scenario, he doesn't answer - do I contact a trustee to adopt ownership?
16:35:10 <dcoutts> athan: yep, see the procedure linked from the hackage home page
16:35:20 <athan> dcoutts: Ahh, sorry :) Thank you!!
16:35:27 <dcoutts> np
16:39:38 * hackagebot set-with 0.0.1 - Set of elements sorted by a different data type.  https://hackage.haskell.org/package/set-with-0.0.1 (athanclark)
16:39:40 * hackagebot tar 0.4.2.1 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.4.2.1 (DuncanCoutts)
16:41:20 <shirt> how do i import this operator from the module Servant?  data (:<|>) a b = a :<|> b
16:41:49 <dcoutts> import Servant ((:<|>))
16:42:07 <dcoutts> import Prelude ((++), (==))
16:42:10 <dcoutts> same pattern
16:42:17 <shachaf> That line defines two operator, one type-level and one value-level.
16:42:26 <shirt> i tried that, but it only imports the type, but not the constructor
16:42:44 <dcoutts> import Servant ((:<|>)(..))
16:42:59 <dcoutts> that's the type and the constructors
16:43:10 <dcoutts> or even more explicitly...
16:43:14 <shachaf> import Servant ((:<|>)((:<|>)))
16:43:19 <dcoutts> right :-)
16:43:40 <shirt> thanks, that works!
16:50:41 <curious> Been looking at SHE and the superclass proposals. How many years until we get those Christmas goodies?
17:03:04 <oconnore> how can I make a TVar strict?
17:04:05 <Hijiri> I don't think you can make the TVar any stricter than normal, but modifyTVar' will modify the TVar strictly
17:05:09 <oconnore> Hijiri: ah, somehow google sent me to the 2.1.1.2 version of the STM docs
17:05:17 <oconnore> Hijiri: cool, that's what I want! Thanks
17:05:29 <oconnore> (I guess the ' versions weren't there before)
17:08:56 <mniip> why are you using a non-haskellular search engine
17:11:18 <oconnore> mniip: I guess for simple things it's easier to type stm into my browser bar. Maybe I should write a !hg thing
17:11:23 <AaronFriel> Stack question: How does stack work when building a package - I want to take advantage of Stack to use multiple projects to split my project into smaller units
17:11:35 <AaronFriel> From what it looks like, I use a "stack.yaml" with a list of project dirs
17:12:12 <AaronFriel> If I then cd into "./project1", does Stack know to look up a folder for the parent stack.yaml that references the other project?
17:12:23 <AaronFriel> Or should each project have a stack.yaml that has relative paths to its dependencies
17:13:01 <AaronFriel> e.g.: "packages: - ../dep1 - ../dep2"
17:17:11 <athan> Is there a technical term for a structure that satisfies `forall a b in A. a <= a + b` for a binary (+)?
17:17:22 <athan> (with it being potentially associative / abelian, too)
17:18:15 <mniip> a rig?
17:18:23 <arkeet> what is <= in a rig?
17:19:30 <mniip> nevermind, I applied too many 'natural' 'axioms' to the expression
17:20:20 <athan> mniip: hmm, I'm not sure if + would distribute over <=
17:20:38 <athan> arkeet: There's got to be a term for it :\
17:20:52 <arkeet> athan: what's the purpose you have in mind?
17:21:45 <athan> arkeet: It's a prerequisite for matroids
17:22:04 <athan> of course, I could make this implementation leaving out that detail, but it wouldn't be as type-safe imo
17:23:56 <arkeet> I see the the term "positively ordered monoid" (or semigroup) in a few places
17:24:08 <arkeet> https://proofwiki.org/wiki/Definition:Positively_Totally_Ordered_Semigroup
17:24:17 <ttt_fff> using unicode, is there a nicer way to say `union` ?
17:24:24 <athan> arkeet: Hmm! Okay, I might copy this then
17:24:26 <arkeet> there's a character for that
17:24:28 <athan> arkeet: Thank you :)
17:24:46 <athan> ttt_fff: Most monoid instances are <>
17:24:47 <arkeet> ttt_fff: http://www.fileformat.info/info/unicode/char/search.htm?q=union&preview=entity
17:24:54 <athan> like with Map and Set
17:25:04 <athan> but there's also the \cup symbol :)
17:25:05 <arkeet> ∪ for binary union
17:25:10 <arkeet> which is \cup
17:25:26 * athan 's body is ready
17:25:49 <arkeet> athan: of course if it's an ordered monoid you can just say 0 <= a for all a.
17:27:19 <athan> arkeet: Of course! But, this _needs_ that "increasing" property that (+) strictly makes a term "larger"
17:27:33 <ttt_fff> arkeet: nice, thanks!
17:27:44 <athan> I really like this proof wiki btw :) thanks arkeet
17:28:04 <AaronFriel> Anyone experienced enough in Stack to know how to manage multiple projects with dependencies? I'm not sure if what I'm doing is right
17:28:13 <arkeet> athan: well, an ordered semigroup by definition satisfies a + b <= a' + b' if a <= a' and b <= b'
17:28:20 <AaronFriel> Do I have a parent folder (with no files in it) and a stack.yaml in that, with all the child deps in there
17:28:37 <athan> arkeet: Hmm... wow, okay
17:28:41 * athan ponders
17:28:44 <AaronFriel> Or should each project have a stack.yaml with its deps referenced by relative paths
17:28:55 <arkeet> er
17:29:58 <athan> arkeet: And if the semigroup is abelian? :v
17:31:13 <arkeet> athan: there is no difference.
17:31:46 <athan> arkeet: 0 + 5 <= 2 + 4, for instance
17:31:52 <arkeet> what about it?
17:32:07 <athan> 0 <= 2, but 5 </= 4
17:32:17 <arkeet> there is nothing wrong with that.
17:32:23 <athan> o_o
17:32:30 <athan> :o
17:32:32 <arkeet> I didn't say "if and only if"
17:32:32 <athan> :|
17:32:41 <athan> oh, okay haha
17:32:50 <athan> if it exists, then it's an ordered monoid?
17:32:56 <arkeet> if what exists?
17:33:10 <voidzero> https://xkcd.com/1033/
17:33:14 <voidzero> relevant
17:33:16 <arkeet> an ordered monoid is just a monoid with an ordering on the elements
17:33:20 <athan> if there exists an `a, a', b and b'` that satisfy that
17:33:24 <arkeet> satisfying the condition I just described
17:33:30 <arkeet> that's the definition.
17:33:47 <athan> arkeet: for all a, a', b and b'?
17:33:51 <arkeet> of course
17:33:53 <athan> hmm
17:34:05 <athan> so (+) wouldn't be an ordered monoid over Nat, would it?
17:34:12 <chreekat> AaronFriel: one stack.yaml for a "project" comprised of multiple "cabal packages"
17:34:13 <arkeet> yes it would.
17:34:18 <athan> because of that one case
17:34:21 <athan> :|
17:34:35 <AaronFriel> chreekat: Thanks!
17:34:36 <arkeet> "if 0 <= 2 and 5 <= 4, then 0 + 5 <= 2 + 4"
17:34:36 <chreekat> AaronFriel: see e.g. yesodweb/yesod on github
17:34:38 <arkeet> this is a true statement.
17:34:44 <arkeet> because the antecedent is false.
17:34:51 <chreekat> AaronFriel: https://github.com/yesodweb/yesod/blob/master/stack.yaml
17:35:01 <athan> arkeet: Oh hell I had the implication backwards
17:35:02 <athan> sorry
17:35:39 <athan> AaronFriel: doing `stack init` with the right pragmas usually does the trick for me :)
17:35:51 <AaronFriel> athan: Right pragmas?
17:35:51 <athan> like --resolver nightly-2015-07-over9000
17:36:08 <AaronFriel> athan: I uhhh don't follow.
17:36:15 <AaronFriel> athan: Are you addressing something I said earlier?
17:36:17 <athan> :P --resolver nightly-2015-07-24
17:36:23 <chreekat> AaronFriel: I had great success temporarily adding yesod-bin as a "dependency" of a yesob web site while testing out changes to yesod-keter. That's one of stack's principle use cases: painless shared sandboxes
17:36:42 <athan> AaronFriel: Stackage has a certain number of snapshots regarding stability of packages, during their lifespan
17:36:58 <athan> by slecting a "resolver", you're selecting an image of stackage at one point in time
17:37:13 <Zemyla> chreekat: yesod-keter makes me think of SCP.
17:37:14 <AaronFriel> athan: Yes, I understand what stackage is and the snapshots. I don't know what you're answering
17:37:39 <athan> AaronFriel: Oh, someone sent you a stack.yaml, I just assumed you asked how to make one or something
17:37:40 <athan> by bad
17:37:41 * dcoutts notes that a dev branch of cabal-install has nix-style shared sandboxes
17:37:57 <chreekat> Zemyla: you wouldn't be wrong, since yesod keter uses scp
17:38:02 <athan> dcoutts: Yessssss
17:38:17 <AaronFriel> athan: Oh, no. I was wondering how to organize multiple libraries with stack. Single shared folder with one stack.yaml, or stack.yaml-per-project
17:38:34 <Zemyla> chreekat: So what is scp in regards to yesod?
17:38:55 <athan> AaronFriel: Oh shoot. Doesn't the namespace populate after you install a package? :S
17:38:55 <AaronFriel> Zemyla: Just regular linux SCP
17:39:08 <athan> secure copy?
17:39:19 <AaronFriel> athan: I... don't know?
17:39:27 <athan> D:?
17:39:46 <chreekat> Sorry, I assumed that's what SCP meant: secure copy aka /usr/bin/scp
17:40:04 <arkeet> partially ordered sets are better than totally ordered sets anyway.
17:40:13 <arkeet> well, the categories of such things,
17:40:14 <arkeet> .
17:40:16 <Zemyla> And what does yesod do?
17:40:18 <athan> arkeet: Agreed :P
17:40:33 <AaronFriel> Zemyla: It's a web framework
17:41:01 <arkeet> totally ordered sets don't even have products or coproducts.
17:41:06 <chreekat> 'yesod keter' (a subcommand of yesod-bin.. just writing this out for clarity) uses scp to copy a 'keter bundle' to a server. Of course, the command also *creates* the bundle following rules specified in a config file.
17:41:06 <arkeet> (except in trivial cases)
17:42:17 <Zemyla> I like ordinals, which are totally ordered sets.
17:42:35 <athan> Zemyla: How much power do you need over your web framework?
17:42:42 <athan> Do you need a JSON api?
17:43:21 <Zemyla> I also like the axiom of choice, which guarantees every set has a well-ordering.
17:43:37 <athan> arkeet: I think this is it, right? https://proofwiki.org/wiki/Definition:Ordered_Semigroup
17:43:45 <Zemyla> athan: I don't need a web framework.
17:43:48 <arkeet> I don't really like proofwiki.
17:43:56 <arkeet> but yes.
17:43:58 <athan> oh okay
17:44:13 <arkeet> like it's not wrong, but it's kind of uh
17:44:14 <arkeet> not well organized?
17:44:20 <arkeet> and some presentation is weird
17:44:41 * hackagebot nationstates 0.1.0.3 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.1.0.3 (ChrisWong)
17:44:45 <arkeet> https://en.wikipedia.org/wiki/Ordered_semigroup
17:44:49 <AaronFriel> arkeet, chreekat: Follow up question on stack. "Stack new" creates a package and that works awesome
17:45:14 <AaronFriel> arkeet, chreekat: But if I have a parent folder with a stack.yaml, I actually want to create the project in a subfolder, using the stack.yaml parent for snapshot and dep info
17:45:18 <athan> arkeet: I get that :\ not as deep as ncatlab either
17:45:18 <arkeet> not me.
17:45:39 <AaronFriel> How do I create a project with "stack new" in a subfolder?
17:45:53 <athan> AaronFriel: Use `hi` instead :D
17:45:59 <AaronFriel> wha
17:46:03 <chreekat> AaronFriel: if i was in that situation i'd probably use cabal-install. `cabal init`
17:46:07 <athan> also, do `stack new --help` :P
17:46:24 <AaronFriel> stack new --help wasn't helpful?
17:46:33 <athan> sorry haha
17:47:03 <athan> AaronFriel: It looks like it just creates them
17:47:18 <athan> not very interactive compared to cabal-install, like chreekat mentioned
17:47:32 <AaronFriel> athan: Yeah, I guess I just run stack new in the subfolder
17:47:36 <AaronFriel> and then delete the stack.yaml
17:47:52 <athan> AaronFriel: I've got some package templates on github for `hi`
17:48:11 <chreekat> I think stack new is under active development.. something about a set of templates to choose from
17:48:11 <athan> `hi` lets you template-out a package format, like an executable or library or web service
17:48:28 <athan> chreekat: hmm, I'll have to jump on that
17:49:21 <AaronFriel> athan, chreekat: Wait
17:49:37 <AaronFriel> Should I have both a parent stack.yaml and a child stack.yaml for my project?
17:49:41 <chreekat> AaronFriel: no
17:50:10 <AaronFriel> chreekat: okay
17:50:27 <chreekat> if you have one project comprised of many cabalized packages, you have a single stack.yaml to rule them all. Naturally you have a .cabal for each cabalized package, as usual.
17:50:36 <AaronFriel> So when I did a yesod init in a subdirectory, it created a stack.yaml in that folder
17:50:45 <AaronFriel> And that stack.yaml specifies a flag
17:50:55 <AaronFriel> I should copy that to the parent stack.yaml, and any deps
17:50:57 <chreekat> AaronFriel: that could be considered buggy behavior
17:51:01 <AaronFriel> and then that should be good?
17:51:06 <chreekat> AaronFriel: yeah that sounds right
17:51:26 * chreekat is guessing a little bit
17:51:54 <chreekat> athan: hi seems cool
17:52:36 <AaronFriel> chreekat: So every time I run "stack build" it finds new dependencies
17:52:44 <AaronFriel> chreekat: I wonder if this is normal for yesod.
17:53:32 <athan> cheater: I use it all the time
17:54:39 <chreekat> AaronFriel: mm seems a little strange. See e.g. https://git.gnu.io/snowdrift/snowdrift/blob/master/stack.yaml. None of the extra-deps are yesod-specific, but are app-specific, with the possible(?) exception of mime
17:55:03 <lpaste_> AaronFriel pasted “Stack build” at http://lpaste.net/9065364931678830592
17:55:35 <AaronFriel> chreekat: See that lpaste. The first "stack build" was after creating a subfolder with "yesod-bin"
17:55:47 <AaronFriel> chreekat: The second stack build was after that
17:56:02 <AaronFriel> chreekat: The third was after creating a second cabal package folder, but that one has no deps other than "base"
17:56:21 <chreekat> AaronFriel: oh, wait, i'm confused. Each time you run stack build it pulls down more deps?
17:56:34 <AaronFriel> chreekat: Yes, it's now installing another 58 deps
17:56:55 <chreekat> AaronFriel: that sounds like a small system OOM'ing ghc
17:57:42 <AaronFriel> chreekat: 7GB of RAM system with 10GB swap
17:57:45 <chreekat> as in, stack build should do everything the first time, and should only stop when everything is installed
17:57:59 <augur> is there any tutorial on using the indentation parser in Parsec?
17:58:11 <Gurkenglas> How does one go about integrating memoization into usage of hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b?
17:58:55 <chreekat> AaronFriel: filesystem ok too? "Is it plugged in?" :P
17:59:10 <AaronFriel> chreekat: I can try turning it off and turning it back on again
17:59:19 <AaronFriel> I'm not getting any build errors on stack build
17:59:44 <AaronFriel> but it is definitely installing duplicates
17:59:51 <AaronFriel> yesod-1.4.1.5: download
17:59:51 <AaronFriel> yesod-1.4.1.5: configure
17:59:51 <AaronFriel> yesod-1.4.1.5: build
17:59:51 <AaronFriel> yesod-1.4.1.5: install
18:00:00 <AaronFriel> yesod-1.4.1.5: configure
18:00:00 <AaronFriel> yesod-1.4.1.5: build
18:00:00 <AaronFriel> yesod-1.4.1.5: install
18:00:06 <AaronFriel> both are in my logs
18:00:21 <AaronFriel> weird it's done I guess
18:00:30 <AaronFriel> stack build no longer builds more things, that's good
18:00:51 <chreekat> yes that is weird and unexpected behavior. 
18:16:40 <jatt> Hi all, Im having problems with installing haskeline with cabal. Im running Mac OS X Yosemite 10.10 Here is the terminal output http://justpaste.it/mkhh Any help appreciated
18:18:07 <Cale> jatt: Does your ghc otherwise work?
18:18:21 <jatt> yes
18:19:42 * hackagebot fasta 0.7.2.1 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.7.2.1 (GregorySchwartz)
18:23:00 <athan> Can a commutative square be made out of anything that's associative?
18:23:05 <Cale> Hmm, someone using Mathematica's FFI had a very similar looking problem and the solution was to switch to g++-mp-4.5, but I'm not at all sure whether or not that would be a viable approach here.
18:23:15 <Cale> athan: hm?
18:23:20 <geekosaur> jatt, what does "gcc --version" report?
18:23:25 <athan> Cale: Like category theory :)
18:23:40 <Cale> athan: A commutative diagram can be formed from any equation of composites.
18:24:01 <jatt> Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn) Target: x86_64-apple-darwin14.4.0 Thread model: posix
18:24:06 <Cale> Commutative squares represent equations of the form f . g = h . k for various f, g, h, k in various categories.
18:24:12 <athan> Cale: composities... like modular data? :s
18:24:15 <Cale> no
18:24:18 <arkeet> like composition 
18:24:19 <Cale> Composites like composition
18:24:26 <Cale> The operation of a category
18:24:29 <geekosaur> oh, never mind, it's not using that gcc
18:24:35 <athan> okay that makes sense, I get that
18:24:47 <athan> I'm just trying to think like, commutative diagrams for monoids or something too
18:25:09 <geekosaur> hmmm
18:25:18 <geekosaur> jatt, how did you install ghc?
18:25:54 <athan> Cale: But the commute between them is equality itself, and the ability to freely replace, right?
18:26:07 <jatt> via haskell platform
18:26:26 <geekosaur> the downloadable one, or the one in macports?
18:26:27 <athan> jatt: Use the PPA! :(
18:26:31 <athan> @learn
18:26:31 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
18:26:34 <geekosaur> athan, OS X
18:26:39 <athan> oh crap
18:26:41 <athan> sorry
18:27:47 <Cale> athan: When you say that a diagram commutes, it means that the composites of arrows along any two paths in the diagram with the same start and end point will be equal
18:28:26 <Cale> athan: So, indeed, you can replace any one such path, wherever it occurs in a formula, with another, if you like.
18:28:36 <Cale> (provided the diagram commutes)
18:28:48 <athan> Cale: That makes sense
18:30:15 <athan> Cale: So you could say that in the context of forming routes with the arrows, commutative diagrams are commutative /options/ for forming a path?
18:30:27 <Cale> athan: One reason that it's a powerful tool is that it reduces the amount of checking you have to do. Ensuring that each polygonal face of a diagram commutes is enough to ensure that the whole diagram commutes.
18:30:40 <athan> hmm
18:31:34 <Cale> Note: don't confuse this sense of the word "commutative" with any other sense. In particular, it doesn't have much to do with the other sense from algebra of a commutative binary operation.
18:32:06 <jatt> geekosaur, the downloadable one, I recently uninstalled my old haskell platform and reinstalled from the website
18:32:06 <athan> Cale: Should we be using "abelian" for the algebra operation?
18:32:25 <Cale> athan: Eh, whatever you like, there's not much chance of any confusion.
18:32:39 <athan> Cale: I'm about to make a commutative lib :P
18:32:45 <geekosaur> jatt: your environment is mixing macports with stuff based on apple binaries/libraries. this doesn't work. (same applied to homebrew)
18:32:47 <Cale> Abelian tends to specifically be used in the case of groups, and not so much for other commutative binary operations.
18:32:48 <athan> Trying to fix up the algebra package a bit
18:33:10 <athan> Cale: Hmm, I know I've heard abelian semigroup thrown around
18:33:19 <geekosaur> basically if you are using a haskell platform built against apple stuff, remove macports/homebrew/fink from your $PATH while working with it
18:33:39 <Cale> Perhaps also for simpler structures, but "Abelian ring" is weird vs. "commutative ring"
18:33:47 <mudphone> What's purple an commutes?
18:33:55 <jatt> ah ok
18:33:59 <geekosaur> or use a ghc / platform provided by whichever of those you are using, instead of one based on apple ecosystem
18:34:08 <geekosaur> (ghc and haskell platform are available in macports)
18:34:10 <jatt> @ageekosaur
18:34:10 <lambdabot> Unknown command, try @list
18:34:11 * athan shrugs
18:34:13 <mudphone> An abelian grape.
18:34:16 <Cale> mudphone: What's yellow and complete under the metric induced by its norm?
18:34:31 <Cale> A Banananach space
18:34:36 <mudphone> Cale: man!
18:34:46 <mudphone> Was trying to come up with a banana pun.
18:35:03 <geekosaur> in short, OS X is a mess :/
18:37:20 <Cale> mudphone: There was a guy who did his Ph. D. in functional analysis at my uni and had never heard that joke until one of the people at his thesis defense asked it at the end. He was floored. :D
18:39:08 <athan> Does anyone know if Semigroup will be a superclass of Monoid anytime soon? :\
18:39:51 <mudphone> Cale: And, I thought it took me a long time to get the abelian joke..
18:40:57 <Cale> athan: edwardk would know
18:41:10 <Cale> I sort of doubt it...
18:41:28 <athan> :(
18:41:31 <Cale> How much use are people getting out of Semigroup vs. Monoid?
18:41:44 <athan> PureScript has had success with it, haven't they?
18:41:51 <Cale> I dunno
18:41:57 <athan> Cale: More generic abstraction
18:42:06 <Cale> Yeah, but there's less you can do with it.
18:42:16 <athan> that way we can safely ensure that "commutativity" is a subclass of something that's a semigroup :P
18:42:28 <athan> :\
18:42:30 <athan> hmm
18:42:53 <Cale> I sort of question the relevance of these fine-grained classes which don't actually add operations.
18:43:04 <Cale> Maybe they're useful
18:43:16 <athan> Cale: I think making new terms could be viable, too
18:43:21 <Cale> It's a whole lot less clear than in the dependently typed case though.
18:43:31 <athan> there's no proof of some of the laws, but that's the nature of return / pure, too
18:43:43 <athan> Yeah :\
18:44:11 <athan> I was going to use `commute` as a term for the `mappend` of commutative semigroups
18:44:16 <athan> maybe <~> too :s
18:44:27 <Cale> It's much different from "these things need to satisfy all the obvious laws that such operations ought to satisfy"
18:44:51 <Cale> athan: I wouldn't
18:45:09 <athan> :\
18:45:11 <Cale> commute there refers to making use of the equation that a * b = b * a
18:45:22 <athan> well yeah
18:45:42 <athan> just like how `join` makes use of its laws, too
18:45:50 <athan> er, relies on
18:46:47 --- mode: ChanServ set +o monochrom
18:46:54 <athan> Cale: Or you could provide a container, such that a `total` function (like `concat`) could operate however the foldable sees fit?
18:46:57 --- mode: monochrom set -b *!*@host22.137.druknet.bt
18:47:02 --- mode: monochrom set -o monochrom
18:47:10 <athan> but you could provide more... idk, commutative behavior with `total` :s
18:47:27 <athan> like concurrency or something
18:54:41 <athan> I don't think this is a very good argument: https://www.reddit.com/r/haskell/comments/30s1t2/proposal_make_semigroup_as_a_superclass_of_monoid/cpvf534
18:55:16 <athan> if Maybe wasn't the monoid instance itself, that wouldn't change the semantics of `lookup`, it would change the semantics of a Maybe-like structure used as a monoid
18:56:27 <Cale> hm?
18:58:02 <Cale> The instance of Monoid for Maybe which is in the libraries is the lifting instance
18:58:13 <athan> Cale: That thread might be easier to read if you jumped up a few parents :\
18:59:18 <athan> Woah, I've never seen `pattern` before
18:59:32 <athan> :s
18:59:42 <Cale> Well, it's completely new
18:59:55 <athan> -XPatternSynonyms, right?
19:00:10 <Cale> right
19:00:12 <athan> Is it like type aliases for instance definitions?
19:00:58 <athan> Or custom data constructors? hm
19:02:28 <Cale> It lets you define new patterns which are syntax sugar for other patterns
19:02:38 <athan> huh :) that's nice
19:02:50 <athan> better smart constructors, too
19:03:16 <Cale> Yeah, you can use it to make much more tolerable-looking view patterns
19:05:09 <athan> hmm!
19:07:27 <Cale> Hopefully some will go into Data.Sequence at some point to make matching on x <| xs and xs |> x work
19:08:07 <Cale> Oh, maybe that doesn't work, because you still need to give the pattern synonyms constructor names
19:08:53 <Cale> So perhaps it would have to be :< and :> but that's obnoxiously a breaking change.
19:11:40 <edwardk> athan: the current plan is that we'll move semigroup into base in a subsequent release (7.12), then add warnings and get it to being a superclass by 7.16 or so
19:13:23 <Gurkenglas> Why wait between moving semigroup into base and adding warnings? The possibility of bugs in semigroup forcing people to choose between bugs and warnings?
19:15:28 <Welkin> :t (:<)
19:15:29 <lambdabot>     Not in scope: data constructor ‘:<’
19:15:30 <lambdabot>     Perhaps you meant one of these:
19:15:30 <lambdabot>       ‘Seq.:<’ (imported from Data.Sequence),
19:15:37 <Welkin> :t Data.Sequence.:<
19:15:39 <lambdabot> parse error on input ‘Data.Sequence.:<’
19:15:47 <Welkin> :t (Data.Sequence.:<)
19:15:48 <lambdabot> a -> Seq.Seq a -> Seq.ViewL a
19:15:52 <Welkin> :t (Data.Sequence.>:)
19:15:53 <lambdabot> Not in scope: ‘Data.Sequence.>:’
19:15:57 <Welkin> :t (Data.Sequence.:>)
19:15:58 <lambdabot> Seq.Seq a -> a -> Seq.ViewR a
19:17:38 <Welkin> what are some examples of a semigroup besides an infinite stream?
19:20:40 <Cale> Welkin: Infinite streams under which operation?
19:21:01 <Cale> Welkin: A semigroup is a set (or type) with a binary operation on it that is associative.
19:24:19 <Cale> Welkin: There's a nice example of a semigroup which is not a monoid that comes up in computing binary addition efficiently.
19:24:45 * hackagebot fuzzy 0.1.0.0 - Filters a list based on a fuzzy string search.  https://hackage.haskell.org/package/fuzzy-0.1.0.0 (cattheory)
19:27:12 <Cale> Welkin: It's a semigroup with three elements, A, P, and G for "absorb", "propagate", and "generate" respectively, encoding what happens to a carry at each position. e.g. if both the bits at that position are zero, then the carry out of that position will be 0 regardless of whether there was a carry in or not. If exactly one of the bits being added is 1, then a carry will be propagated (carry out will be equal to carry 
19:27:12 <Cale> in). Lastly if both bits are 1, then a carry will be generated at that position regardless of whether there was a carry in or not.
19:28:56 <Cale> Welkin: The monoid operation on these expresses what happens for a pair of adjacent positions. We have Ax = A for any x, because if we absorb a carry in the more significant bit, we'll absorb a carry overall.
19:29:14 <Cale> We have Gx = G for any x for a similar reason.
19:29:24 <Cale> and lastly, Px = x for any x
19:33:06 <Cale> This operation is associative, and so can be computed efficiently in parallel with circuitry that has a binary tree structure.
19:33:29 <Welkin> so, binary arithmetic
19:34:15 <Cale> Yeah, getting more efficient implementations of binary addition.
19:35:32 <Cale> Note that the usual addition algorithm where you carry one bit at a time has O(n) delay, because the longest path through the circuit goes from the carry in of the adder for the first bit, through all n of the adders, to the carry out or sum for the last bit.
19:36:24 <Cale> This means of keeping track of what will happen to the carries using a semigroup operation lets us avoid that, and have O(log n) delay
19:37:07 <Cale> (where n is the number of bits in the numbers being added)
19:40:31 <Cale> Semigroups naturally arise in almost any algorithm which takes advantage of tree structures. If you have a tree whose nodes are labelled with summaries of some sort of the values in their subtrees, then in order to not have to recompute everything throughout the entire tree when rebalancing, you need at least associativity of the operation which produces the label at a branch node from the labels on its children.
19:41:01 <Cale> (often you also need a monoid structure, if you'll potentially end up removing a subtree altogether in some cases)
19:42:29 <Cale> Of course, that's sort of what's going on with the addition algorithm: we're taking a maximally unbalanced tree of computation for the carries, and balancing it into something which looks more like a perfect binary tree.
19:43:09 <Cale> and in order to do that, we need to actually have a semigroup in the first place to summarise what takes place at each position
19:44:46 * hackagebot hashable-extras 0.2.2 - Higher-rank Hashable  https://hackage.haskell.org/package/hashable-extras-0.2.2 (EdwardKmett)
19:54:46 * hackagebot log-domain 0.10.2 - Log-domain arithmetic  https://hackage.haskell.org/package/log-domain-0.10.2 (EdwardKmett)
19:56:40 <AaronFriel> Conduit question: I see "evalStateC" and such have replaced old functions like "conduitState", or so I think
19:59:25 <lpaste_> AaronFriel pasted “conduitState” at http://lpaste.net/137293
19:59:34 <AaronFriel> ^ Is there anything wrong with that?
19:59:47 <AaronFriel> Other than the hlint stuff
20:13:47 <Cale> AaronFriel: Provided it compiles, it looks fine to me
20:14:49 <AaronFriel> Cale: Okay, what's the advantage of using evalStateC, to benefit my understanding? 
20:14:59 <orion_> ok - I wrote my first "working" haskell program.  It will decode bencode formatted files given as command line arguments (and run its tests).  What I dont know is how idiomatic my solution is.  Could I get feedback on the code before I develop too many bad habits? https://gist.github.com/orionz/d52346f192ab0eb86aaa  
20:15:34 <murphxyz> Hi, friends! I'm trying to get a little Haskell experience under my belt, and I'm hoping to avoid the dependency compilation errors that have held me up in the past. It seems like LTS Haskell is a good way to do this. If I place this file in my home directory, http://www.stackage.org/lts-2.19/cabal.config, will cabal-install use the versions of packages listed there in Haskell LTS?
20:15:50 <AaronFriel> Cale: I mean, I understate StateT allows more interaction with the state, but if I just pass along the prior state, I guess - I don't see why the Snoyman would use "evalStateC" in simple examples like recording a sum
20:16:37 <lpaste_> AaronFriel pasted “accumConduit” at http://lpaste.net/137294
20:16:44 <Cale> AaronFriel: I've never seen evalStateC being used before, but I haven't really used conduit all that much, I tend to avoid it a bit.
20:16:54 <AaronFriel> Okay
20:17:14 <Cale> I mean, I guess you get to write things like that, yeah.
20:17:43 <Cale> StateT isn't ever going to get you anything that you couldn't just write yourself by hand with parameter passing.
20:17:53 <Cale> But it might clean up a bit of that parameter passing sometimes.
20:17:57 <nkaretnikov> murphxyz: I don't know offhand, but it should be easy to check: just do it and see whether cabal-install picks the right version
20:18:00 <murphxyz> I tried replacing ~/.cabal/config with the file I just linked to, but it says "unrecognized field constraints on line 5..."
20:18:15 <murphxyz> "Warning: No remote package servers have been specified. Usually you would have one specified in the config file."
20:18:25 <Cale> AaronFriel: It becomes impossible to make the mistake where you recurse on state instead of state'
20:18:27 <murphxyz> which means that's probably not the right thing to do
20:18:41 <geekosaur> no, that's the wrong syntax for ~/.cabal/config
20:18:56 <AaronFriel> Cale: Ah, I see how that can be a strong plus
20:19:05 <geekosaur> instead each line needs to be:  constraint: package ==version
20:19:08 <Cale> (but this is just generally the case for StateT, and has nothing to do with conduit specifically)
20:19:09 <nkaretnikov> murphxyz: another option you have is stack
20:19:13 <geekosaur> (losing the trailing commas)
20:19:54 <murphxyz> nkaretnikov I started using stack, but my editor uses GHC-Mod to give me the helpful type hints, and I guess that without cabal, it doesn't work
20:20:20 <orion_> also - has anyone here hired and managed a haskell dev team before?  I'm interested in the language for some projects but had a bad experience trying to staff up an Erlang team years ago.  I couldn't find more than a dozen qualified people on the planet looking for jobs. 
20:20:23 <murphxyz> I wanted to use stack, but since I'm so new I thought maybe I should avoid it, since it's new too, and not a lot of people seem to be writing about it
20:20:34 <nolrai66> You should use stack.
20:20:37 <nkaretnikov> oh, no idea about ghc-mod, it never worked for me
20:20:57 <nkaretnikov> orion_: search /r/haskell
20:21:07 <nkaretnikov> orion_: that's a popular question
20:21:23 <orion_> nkaretnikov: reddit?
20:21:26 <nkaretnikov> yeah
20:22:01 <nkaretnikov> orion_: it may be hard to find experienced folks in your city, but the picture changes if you allow remote
20:22:42 <nkaretnikov> orion_: you can also hire someone to train your existing team
20:22:58 <nkaretnikov> orion_: well-typed has done that, for example
20:23:38 <nkaretnikov> orion_: if you're serious about building a haskell team and have more concrete questions, just ask on reddit or the -cafe mailing list
20:23:41 <orion_> good to hear someone pulled that off
20:23:52 <orion_> I had a really hard time getting non-erlanger's to learn it
20:24:29 <orion_> nkaretnikov: thanks for the tips
20:24:34 <nkaretnikov> np
20:25:04 <orion_> anyone have a minute to give me feedback on my first program?  It's only 2 pages.
20:25:17 <orion_> Want to have a sense for how idiomatic (or not) I'm being 
20:26:00 <nkaretnikov> just paste the code
20:26:47 <orion_> https://gist.github.com/orionz/d52346f192ab0eb86aaa  
20:26:55 <orion_> nkaretnikov: ^^
20:27:15 * nkaretnikov looks
20:27:24 <kadoban> orion_: Did you run hlint on it? That will generally point out some unidiomatic local things at least.
20:27:35 <kadoban> (Though it isn't always correct of course)
20:27:41 <orion_> kadoban: I did not know about hlint!  Thank you
20:27:56 <nkaretnikov> orion_: fwiw, lpaste has hlint built in
20:29:18 <orion_> lpaste has some good feedback - thanks nkaretnikov
20:29:30 <nkaretnikov> orion_: folks like to align | with = in data declarations
20:30:11 <nkaretnikov> orion_: I'd write "bdata:" <> show (B.length s) instead
20:30:24 <nkaretnikov> since <> works for any monoid
20:31:09 <nkaretnikov> prefixing functions with _ is unusual 
20:31:25 <nkaretnikov> if you have a similar function, you usually use '
20:31:28 <nkaretnikov> e.g., foo and foo'
20:31:55 <nkaretnikov> foo'', foo''', and so on
20:31:58 <orion_> nkaretnikov: ok - thanks
20:32:03 <nkaretnikov> always use type signatures
20:32:10 <orion_> nkaretnikov: can you explain bdata <> ...
20:33:31 <nkaretnikov> well, it's just a matter of preference.  <> would work for a bunch of things that can be concatenated, so if you go, say, from String to Text, it will work just fine
20:33:40 <nkaretnikov> ++ won't work in this case because Text is not a list
20:34:02 <nkaretnikov> so I usually use <> to avoid changing a bunch of things
20:34:05 <nkaretnikov> since it's more general
20:34:17 <nkaretnikov> it's a method of the Monoid class
20:34:46 <nkaretnikov> are you aware of the 'where' keyword?
20:35:03 <nkaretnikov> you might want to use it instead of 'let ... in'
20:35:07 <nkaretnikov> to make things easier to read
20:35:30 <nkaretnikov> orion_: oh, also, always build with -Wall
20:36:01 <nkaretnikov> for instance, I see that you have an argument named 'map', which shadows the common 'map' function
20:36:04 <nkaretnikov> which is not good
20:36:20 <orion_> nkaretnikov: ah - got catch on map
20:36:28 <orion_> nkaretnikov: name it map'?
20:36:40 <nolrai66> hmm.
20:37:27 <nkaretnikov> could be 'm', 'dict', or whatever you like.  haskellers tend to like short mnemonic names since it's faster to read and the meaning is usually clear from the type signature
20:37:49 <nkaretnikov> no need to use parens on line 1
20:37:50 <nkaretnikov> 31*
20:39:14 <nkaretnikov> orion_: looks good overall, you can read more at https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
20:39:26 <dotxasp> Does underscore after a function like in replicateM_  mean it will discard the result?
20:39:38 <nkaretnikov> it's a common convention, yes
20:39:51 <dotxasp> thank you
20:42:06 <orion_> nkaretnikov: better? http://lpaste.net/330006475067883520
20:42:24 <orion_> nkaretnikov: whoops - forgot my signatures
20:42:32 <nkaretnikov> orion_: just another point about types.  newcomers tend to omit them because haskell has type inference.  and it's usually okay to do that inside 'where' or 'let ... in', but otherwise, it's always better to clearly state what you're trying to do.  types, for example, let you take a general function and restrict it such that it works only on the type that it should work on.
20:42:51 <orion_> nkaretnikov: why are these needed?  I though haskel being able to figure out all the types without annotation was one of the killer features?
20:43:06 <nkaretnikov> well, re-read what I just wrote
20:43:09 <kadoban> If nothing else, it gives you /much/ /much/ better error messages, when you inevitably screw up on types, orion_
20:43:12 <nkaretnikov> let me give you an example
20:43:17 <orion_> nkaretnikov: yeah we were writting at the same time ;-)
20:43:28 <orion_> nkaretnikov: ok - thanks
20:43:58 <orion_> nkaretnikov: the notE function felt pretty silly to write - is there a better way?
20:44:23 <nkaretnikov> orion_: for example, take a look at fmap and map.  the first works for any Functor instance (i.e., things that can be mapped over) while the second only works on lists.  if you want to make sure that your function only works on lists, it's better to use 'map'.
20:45:11 <kadoban> orion_: (/= 'e')
20:45:16 <nkaretnikov> yeah
20:45:19 <kadoban> :t (/= 'e')
20:45:20 <lambdabot> Char -> Bool
20:45:33 <orion_> ahhhhh
20:46:16 <nkaretnikov> orion_: as I said, looks okay.  make sure to read the guide I linked to, though
20:46:25 * nkaretnikov goes back to work
20:46:32 <orion_> nkaretnikov: will do - thanks for the help
20:46:37 <nkaretnikov> np
20:47:38 <orion_> nkaretnikov: last question - theres no error handling here - should I be putting a try at the top level decode function or be turning everything into a "Maybe X" -- going the maybe route feels like it would almost double the needed code so I avoided it
20:49:05 <kadoban> orion_: I only vaguely looked at the program, but it looks like you're parsing? I suspect it'd be nicer using one of the parser combinator libraries, like Parsec or Attoparsec, though that requires learning them a bit.
20:49:56 <orion_> kadoban: gotcha - I'll check them out - the parsing was a dummy problem to make me write a solution I already knew 
20:50:27 <kadoban> orion_: Right, I kinda figured but thought I should mention it anyway.
20:51:07 <nkaretnikov> orion_: it's always better to use Maybe (or Either if you want an error message) then fail at runtime
20:51:16 <nkaretnikov> orion_: I just noticed that you use 'head'
20:51:37 <nkaretnikov> you should avoid it if possible or make sure it never sees an empty list
20:51:48 <nkaretnikov> otherwise, it'll fail
20:52:07 <kadoban> Ending up with Maybe or Either e doesn't generally require that much extra code, though it does depend. If you don't know the right combinators it tends to balloon quite a bit though (the "right" combinators tend to be something from Functor/Applicative/Monad)
20:52:08 <nkaretnikov> there are examples here https://hackage.haskell.org/package/safe
20:55:46 <kadoban> So here's a dumb question … is 'stack install ghc' nonsense? What about 'stack install cabal-install' ?
20:56:20 <orion_> nkaretnikov: I'm aware of how to easily avoid the head issue with 'foo [] = Nothing' but since this was using a ByteString I didnt know the equivalent 
20:56:39 <orion_> nkaretnikov: any advice or do I just need to wrap everything in a "if"
20:57:32 <y> orion_: uncons?
20:57:41 <y> @type Data.ByteString.uncons 
20:57:42 <lambdabot> BSC.ByteString -> Maybe (Word8, BSC.ByteString)
20:57:58 <nkaretnikov> orion_: you can pattern match on an empty bytestring with "" and the OverloadedStrings extension on, I think
20:58:15 <orion_> y: thanks
20:58:19 <y> I haven't checked what you actually want/need though
20:59:02 <orion_> nkaretnikov: really?  so  "foo B.empty = Nothing" will work - that's pretty cool
20:59:13 <orion_> goodnight!  thanks all =)
20:59:19 <nkaretnikov> foo "" = Nothing, should work, I think
20:59:56 <nkaretnikov> but you need to put {-# LANGUAGE OverloadedStrings #-} on the first line of your source file for that
20:59:58 <y> orion_: foo B.empty won't, foo (B.empty -> False) = Nothing could work with ViewPatterns
21:01:56 <orion_> nkaretnikov: {-# OverloadedStrings #-} - you just blew my mind - i had no idea
21:04:22 <kadoban> nkaretnikov: I'm actually kinda doubtful that does work :-/ I'm not sure though and my computer is currently to busy to try it.
21:04:28 <kadoban> too*
21:04:49 * hackagebot hyperloglog 0.3.4 - An approximate streaming (constant space) unique object counter  https://hackage.haskell.org/package/hyperloglog-0.3.4 (EdwardKmett)
21:07:24 <nkaretnikov> kadoban: I've just checked in ghci, it works
21:07:58 <nkaretnikov> > let f :: B.ByteString -> Int; f "" = 0
21:08:00 <lambdabot>  <no location info>:
21:08:00 <lambdabot>      not an expression: ‘let f :: B.ByteString -> Int; f "" = 0’
21:08:05 <nkaretnikov> @let f :: B.ByteString -> Int; f "" = 0
21:08:06 <lambdabot>  .L.hs:166:6:
21:08:06 <lambdabot>      Not in scope: type constructor or class ‘B.ByteString’
21:08:06 <lambdabot>      Perhaps you meant one of these:
21:08:11 <nkaretnikov> okay, I give up :)
21:08:14 <kadoban> Ah, good to know then
21:24:28 <soap> Hello
21:29:20 <soap> Hello
21:51:53 <AaronFriel> Is this possible with type families:
21:51:54 <AaronFriel> class Monoid builder => Builder builder lazy | builder -> lazy, lazy -> builder where
21:52:16 <AaronFriel> Specifically the bijection
21:56:14 <Cale> yes, that's possible
22:02:17 <ryantrinkle> does anyone know what the performance of HList is like, compared with a record?  and, whether it's possible for them to be the same, with enough unpacking/etc.?
22:07:13 <AaronFriel> ryantrinkle: That'd be a good blog post if you benchmarked
22:08:38 <AaronFriel> ryantrinkle: I have difficulty believing HList would beat records though, as the compiler is written especially to optimize records, that's the normal target
22:08:48 <ryantrinkle> right, i was only hoping to achieve parity
22:08:59 <AaronFriel> ryantrinkle: It's worth benchmarking
22:09:08 <AaronFriel> ryantrinkle: Are you familiar with how to do so with Haskell?
22:09:27 <ryantrinkle> AaronFriel: yep; thanks, though :)
22:09:34 <dramforever> um...what does "achieve parity" mean?
22:09:43 <AaronFriel> Please post your results in /r/Haskell if you do it
22:09:52 <AaronFriel> It would be interesting to see, for what it's worth
22:10:06 <ryantrinkle> dramforever: i mean that I was wondering if HLists were able to do as well as records - I'm not hopeful that they'll beat them
22:10:29 <dramforever> IIUC those are just lists
22:10:31 <ryantrinkle> really, what i'm after is something of kind [*] -> * that gives me the same thing as a record in memory
22:10:48 <ryantrinkle> i.e.: O(1) indexing into it, nice cache locality, etc.
22:11:18 <AaronFriel> ryantrinkle: I doubt you would get that with HList, which as dramforever says, I think still has an indirection at each point
22:11:22 <dramforever> I don't think hlist had them =(
22:11:46 <ryantrinkle> AaronFriel: yeah, i'll post it if I get a chance to benchmark it
22:11:48 <AaronFriel> ryantrinkle: So you want is something that lets you essentially create new data structures at runtime?
22:12:16 <dramforever> ryantrinkle: so what are you trying to do exactly?
22:12:53 <AaronFriel> ryantrinkle: Unfortunately what you're asking for seems impossible without a JIT. That is, the O(1) indexing
22:13:06 <AaronFriel> ryantrinkle: Think about it: each element of your HList could have arbitrary size
22:13:24 <AaronFriel> ryantrinkle: So even if you had a "Flat HList", how would you know how far to look for the nth element?
22:13:43 <AaronFriel> ryantrinkle: You would need... I guess you could have something at the head that had all the offsets, but now you have an extra indirection there
22:13:53 <AaronFriel> ryantrinkle: And now you've implemented C++ virtual classes.
22:14:00 <AaronFriel> ryantrinkle: With VTable and all!
22:14:13 <ryantrinkle> dramforever: i don't have a specific goal in mind at the moment; I'm just musing about things I might be able to improve performance in the future
22:14:31 <AaronFriel> ryantrinkle: Good advice for all programers, don't let perfect be the enemy of good
22:14:44 <AaronFriel> ryantrinkle: Unless you know you have a perf problem, don't try to optimize it away :)
22:14:59 <ryantrinkle> AaronFriel: i work on FRP - perf is very important ;)
22:15:54 <AaronFriel> ryantrinkle: Sure, but you also don't know if it's a problem yet :)
22:16:15 <AaronFriel> ryantrinkle: See what I mean? Until you benchmark, you can't say it's slow
22:16:23 <Pamelloes> Anyone know how to use like with a Maybe value in esqueleto? Or if it's even possible?
22:17:22 <AaronFriel> Pamelloes: Probably not, you need to coerce the value to something (fromMaybe)
22:17:38 <AaronFriel> Pamelloes: On the SQL side of things, it would be meaningless to do "column LIKE NULL"
22:17:55 <Pamelloes> It's the other way around
22:17:56 <Dildeaux> they just came out with the themesong for Haskell
22:17:59 <Dildeaux> it kicks ass
22:18:17 <Pamelloes> I have ColumnThatMayBeNull LIKE "%stringpatternwithwildcards%"
22:18:24 <Pamelloes> Well, that's what I want.
22:18:27 <Dildeaux> https://www.youtube.com/watch?v=5cqy4-vCo0M
22:18:31 <AaronFriel> Pamelloes: I think that's regular "Like"? 
22:19:03 <ryantrinkle> AaronFriel: i very much agree with your sentiment; I wouldn't be interested in this question if I hadn't already validated that it may be relevant to a real-world problem
22:19:03 <Pamelloes> AaronFriel: It should be. But it's not type checking.
22:19:19 <Pamelloes> Maybe Text is not IsString :/
22:19:37 <AaronFriel> could you paste the line where you're doing "like"?
22:20:13 <ryantrinkle> AaronFriel: with respect to the Flat HList problem, bear in mind that the list of element types is a type argument, there would be no double-indirection
22:20:26 <ryantrinkle> the indexes would be known at compile time
22:20:38 <lpaste_> Pamelloes pasted “Like Type Error” at http://lpaste.net/137295
22:20:44 <Pamelloes> AaronFriel: ^
22:20:47 <AaronFriel> ryantrinkle: Ah, then HList is not what you want, I think
22:20:57 <dramforever> ryantrinkle: idea: what about TH?
22:20:58 <AaronFriel> ryantrinkle: You want to use TH and/or TypeAble
22:21:19 <ryantrinkle> dramforever: yes, i was thinking about that
22:21:27 <ryantrinkle> it's a little heavy for users, but it could probably get the job done
22:21:29 <AaronFriel> Pamelloes: Have you tried removing the "E.just"
22:21:42 <ryantrinkle> i may end up using Vector and unsafeCoerce
22:21:45 <AaronFriel> ryantrinkle: It will give you the absolute best performance, and it will let you add unpack annotations to the fields as well.
22:21:52 <AaronFriel> ryantrinkle: I would heavily advise against unsafeCoerce
22:21:55 <dramforever> ryantrinkle: I'm thinking about something like $(makeRecord [''Foo, ''Bar])
22:22:02 <dramforever> wait you also need a name
22:22:04 <AaronFriel> ryantrinkle: It's a security bag of worms
22:22:24 <Pamelloes> AaronFriel: Yep "Couldn't match expected type ‘Maybe (Maybe Text)’ with actual type ‘Text’  In the first argument of ‘E.val’, namely ‘v’ In the first argument of ‘(E.++.)’, namely ‘E.val v’"
22:24:42 <AaronFriel> Pamelloes: The operator explosion in there makes it hard for me to parse but
22:25:06 <ryantrinkle> dramforever: yeah, that would make sense
22:25:13 <dramforever> =)
22:25:39 <ryantrinkle> right now, I'm using DMap https://hackage.haskell.org/package/reflex-0.1.1/docs/Reflex-Class.html#v:merge
22:25:42 <AaronFriel> Pamelloes: Where is .++. defined?
22:25:55 <ryantrinkle> but the DMaps are frequently dense and/or of statically-known size
22:26:03 <Pamelloes> AaronFriel: https://hackage.haskell.org/package/esqueleto-2.2.10/docs/Database-Esqueleto.html#v:-43--43-.
22:26:04 <AaronFriel> nvm hayoo pulled it up
22:26:08 <AaronFriel> ty ty
22:26:31 <ryantrinkle> and they're also generally immutable
22:26:33 <Pamelloes> Everything prefixed with E. is defined in Database.Esqueleto
22:26:44 <Pamelloes> And the other stuff before that is pretty much boilerplate.
22:26:56 <ryantrinkle> so there's a lot of performance left on the table by a datastructure that requires skipping around the heap
22:27:38 <AaronFriel> Pamelloes: What is ".%"?
22:27:46 <AaronFriel> Pamelloes: Where is E.%
22:28:02 <Pamelloes> Everything prefixed with E. is defined in Database.Esqueleto ;)
22:28:08 <Pamelloes> It represents the Wildcard character.
22:28:40 <Pamelloes> Also "SpaceObjectItemName" has a type of Maybe Text
22:28:44 <Pamelloes> Or something like that.
22:28:44 <AaronFriel> Pamelloes: Okay
22:30:16 <AaronFriel> Pamelloes: In this case you may actually be better off doing ^. as opposed to ?. because LIKE will handle NULL on the right hand side... in many cases
22:30:28 <AaronFriel> Pamelloes: I am fairly sure MySQL and PostgreSQL will simply return 0 rows
22:30:53 <AaronFriel> Pamelloes: But if Esqueleto is saying your SpaceObjectItemName is strongly typed and you can't do that projection
22:31:12 <Pamelloes> The thing on the right-hand side is guaranteed to be not-null
22:31:14 <Dildeaux> Tired of niggers?
22:31:18 <Dildeaux> Sick of their monkeyshines?
22:31:20 <Dildeaux> We are too!
22:31:24 <Dildeaux> Join Chimpmania Forum!
22:31:30 <Dildeaux> http://www.chimpmania.com/forum
22:31:39 <Dildeaux> At Chimpmania, WE ARE NOT WHITE SUPREMACISTS!
22:31:41 <AaronFriel> Pamelloes: Okay
22:31:44 <Dildeaux> I myself am a Mexican!
22:31:51 <Pamelloes> @where ops
22:31:51 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:31:58 <Dildeaux> Basically, if you are NOT A NIGGER and you HATE NIGGERS, we welcome you with open arms!
22:32:03 <Dildeaux> Join Chimpmania forum today!
22:32:11 --- mode: ChanServ set +o dolio
22:32:12 <Dildeaux> CHIMPMANIA IS THE NEW HOME OF CHIMPOUT FORUM!
22:32:16 <Dildeaux> Join us today!
22:32:24 <Dildeaux> http://www.chimpmania.com/forum
22:32:28 --- mode: dolio set +b Dildeaux!*@*
22:32:34 --- kick: Dildeaux was kicked by dolio (Dildeaux)
22:33:09 <AaronFriel> Pamelloes: What type does SpaceObjectItemName have?
22:33:32 --- mode: dolio set +b *!~stormroof@*
22:33:54 <Pamelloes> e :: SpaceObject; SpaceObjectItemName :: EntityField SpaceObject (Maybe Text)
22:34:14 --- mode: dolio set -b Dildeaux!*@*
22:34:20 <Pamelloes> So (e ?. SpaceObjectItemName) :: expr (Value (Maybe Text))
22:34:45 <Pamelloes> Wait. I shouldn't be using ?. there....
22:35:25 <AaronFriel> Pamelloes: No I think you have to, now that I see the type
22:35:41 <Pamelloes> You're right, I do--I get functional dependency errors if I don't.
22:35:47 <AaronFriel> Pamelloes: Here's what I would do: you want to use E.coalesceDefault on SpaceObjectItemName 
22:35:55 <ackthet> wtf is going on
22:37:00 <lpaste_> AaronFriel annotated “Like Type Error” with “Like Type Error (annotation)” at http://lpaste.net/137295#a137296
22:37:44 <Pamelloes> AaronFriel: Ah, perfect :) I was looking at that and not quite sure how to make it work. Let me test it out :)
22:37:51 <AaronFriel> Pamelloes: That should work. What you need to do is take your "Expr (Maybe Text)" and coerce it into something you can use. I used the empty string.
22:38:20 <AaronFriel> Pamelloes: It's actually a little upsetting that the "like" operator doesn't work against "Maybe Text" types, because that totally works in SQL
22:38:27 <AaronFriel> You should fire off a ticket
22:38:54 <Pamelloes> AaronFriel: Those were my thougts exactly :)
22:39:02 <Pamelloes> *thoughts
22:40:21 <Pamelloes> AaronFriel: looks like it already exists "https://github.com/prowdsponsor/esqueleto/issues/68"
22:40:43 <AaronFriel> Pamelloes: It looks like a lot of these operators are "busted" from that perspective, e.g.: it is always okay to do comparison operations on nullable columns. The results might be unexpected, though
22:44:15 <Pamelloes> Yeah....
22:57:58 <haskell241> Hi, I'm trying to get something like this to compile, but I'm not sure how
22:58:06 <haskell241> foo f = do     print $ f [1,2,3]     print $ f "hi"
22:58:23 <dramforever> so what do you expect f to do?
22:59:17 <haskell241> it's reverse or id
22:59:36 <ski> haskell241 : looks like you want rank-2
23:00:11 <haskell241> what's that? @ski?
23:00:29 <dramforever> haskell241: tell people to pay attention like this
23:00:31 <ski> haskell241 : you need `f' there to be polymorphic, for that to be possible
23:01:12 <haskell241> so it's basically a compiler extension?
23:01:19 <ski> haskell241 : a function that has an *argument* that must be polymorphic is said to have a rank-2 type
23:01:24 <ski> yes
23:01:33 <ski> you need to specify the type signature
23:01:38 <ski> something like
23:01:57 <ski>   foo :: (forall a. [a] -> ...) -> IO ()
23:02:34 <haskell241> is the ... required?
23:02:42 <ski> where `...' may mention `a'. it's not clear from your code what you'd prefer `...' to be, but `[a]' would fit the bill of `reverse' and `id'
23:02:55 <haskell241> oh okay thanks!
23:04:03 * ski ponders what a more general type of `foo' could be ..
23:04:15 <haskell241> I'm curious, is there a way to do this without the language extension?
23:04:46 <dramforever> haskell241: not if you want the function to be passed in
23:05:06 <ski> you could do it with a different (weaker) language extension, at the expense of some extra "annotation" of the code
23:05:06 <dramforever> rather than a flag or something
23:06:07 <dramforever> hmm...I just "discovered" something interesting
23:06:40 <dramforever> we have newtype Logic a = Logic (forall r. (a -> r -> r) -> r -> r)
23:06:41 <ski> haskell241 : an alternative is of course to say `foo :: ([Integer] -> [Integer],String -> String) -> IO (); foo (fInt,fChar) = ..fInt..fChar..' .. but presumably you don't like that :)
23:06:51 <dramforever> :t foldr -- and this
23:06:52 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
23:07:02 <ski> dramforever : no coincidence
23:07:27 <dramforever> ski: yes that's why I used quotes
23:07:33 <dramforever> around "discovered"
23:07:39 <haskell241> I want the function to be passed in, or I'm open to another way, either way, I just need to use "id" and "reverse", but the real code is bigger than this example
23:07:47 <dramforever> and also Yoneda f a = (a -> r) -> f r
23:07:54 <dramforever> :t fmap -- And this
23:07:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:08:05 <dramforever> and Codensity f a = (a -> f r) -> f r
23:08:06 <ski> dramforever : s//forall r. /
23:08:10 <dramforever> :t (>>=) and this
23:08:11 <lambdabot> Not in scope: ‘this’
23:08:21 <dramforever> ski: too lazy =P
23:08:23 <dramforever> :t (>>=)
23:08:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:08:36 * ski is picky about binders
23:08:51 <dramforever> so it's like better efficiency with partial application
23:09:03 <dramforever> s/like/
23:09:41 <ski> haskell241 : as i sketched, it is possible to do it without extensions, if you pass the argument twice (once for each distinct monomorphic use)
23:09:46 <dramforever> you want to make foo fast? partially apply that and store the result
23:10:29 * ski isn't sure how what dramforever is talking about is related to haskell241's problem
23:10:37 <dramforever> unrelated =)
23:10:50 <dramforever> that's why we need something between irc and reddit
23:11:05 <haskell241> and why won't something like that work?
23:11:14 <haskell241> foo f = do     print $ (f::([Int]->[Int])) [1,2,3]     print $ (f::([Char]->[Char])) "hi"
23:11:56 <ski> haskell241 : if `f' is monomorphic, then it can't have two different types at the same time. otherwise, `f' is polymorphic, and so `foo' is rank-2
23:12:40 <ski> (a third possibility would be intersection types, but Haskell doesn't have those)
23:13:32 <ski> haskell241 : .. how much larger is the real code ?
23:13:48 <ski> (or, the relevant section of it)
23:13:54 <haskell241> then why does it work with show?
23:14:23 <nikki93> so to feed (f :: a -> b -> c) through (g :: c -> d) I've been doing (g .) . f
23:14:24 <dramforever> haskell241: because it's not an argument
23:14:31 <nikki93> is that a common idiom?
23:14:43 <ski> haskell241 : `show' *is* polymorphic
23:14:54 <haskell241> http://pastebin.com/mGyMJhBJ
23:15:01 <ski> haskell241 : to have a polymorphic *argument*, you must use the rank-2 types extension
23:15:45 <haskell241> oooh, so I couldn't use it on show if I passed it as an argument?
23:16:53 <ski> haskell241 : first issue : don't use `Show'&`show' at all for this pretty printing. use your own function for it. let `Show' be used for what it's meant for (debugging, by printing out a string-representation of a value that represents a Haskell expression that'll evaluate to the value)
23:17:04 <ski> haskell241 : yes
23:18:49 <ski>   f = case color of
23:18:55 <ski>     White -> id
23:19:03 <ski>     Black -> reverse
23:19:27 <ski> haskell241 : try using that ^ (inside your `where'), and stop passing `f' around
23:20:02 <ski> that way, you don't need a polymorphic *argument* (`f' is still polymorphic)
23:22:19 <haskell241> oh that's working, thanks!!!
23:23:01 <ski> haskell241 : .. btw, if it wasn't clear, i'm not objecting to you *calling* `show' inside this snippet of code to generate your pretty-printing. i'm objecting to you *defining* `show' for `ChessGame' as pretty-printing
23:23:51 <ski> so, remove the `instance Show ChessGame where' part, and change `show (ChessGame color board) = ...' into `displayChessGame (ChessGame color board) = ...' or something
23:24:01 <haskell241> I don't really agree with you, my ChessGame is the game board and it's really hard to debug with the Data.Map representation
23:26:38 <ski> `Show' is made to compose. if you e.g. try to print a list of type `[ChessGame]' (or a `Map String ChessGame', perhaps) with your definition, it will look quite weird .. a strange mixture of Haskell expression notation and your custom pretty-printing notation
23:27:52 <ski> nobody prevents you from calling `print . displayChessGame' (possibly with a shorter name) on any particular `ChessGame' you'd like to view more clearly, when debugging
23:27:53 <dramforever> haskell241: what about a separate prettyPrint function?
23:30:41 <haskell241> ya I guess you're right, but what if I defined my color data as data PieceColor = White | Black
23:31:12 <haskell241> and then show White = "W", show Black = "B", is that okay?
23:32:13 <Cale> haskell241: Well, usually it's most convenient while testing if you can copy the "show" of a data structure and paste it back in as valid code.
23:32:45 <Cale> haskell241: You can of course do things like that if you have lots of output to go through though.
23:33:56 <haskell241> so I should do a prettyformat board, prettyformat color and prettyformat pieceType?
23:34:41 <Cale> It's up to you what you think you need of course. It's just a general recommendation that 'show' is often most useful when it produces something as close as possible to valid Haskell code.
23:34:55 <ski> haskell241 : i'd not do that with `PieceColor' (unless if i was able to make real Haskell aliases, `W',`B', of the data constructors there)
23:35:04 <Cale> Having a separate type class for pretty printing can often be a good idea.
23:36:01 <ski> (.. and there's no such extension, last time i looked)
23:36:19 <dramforever> ski: PatternSynonyms?
23:36:40 <Hijiri> does PatternSynonyms let you construct things with those patterns
23:36:46 <dramforever> yes
23:37:03 <ski> dramforever : hm. i suppose that's work. for some reason i always seem to forget that exists, except when i'm thinking about using it
23:37:19 <Cale> Yeah, with the "=" version of the pattern synonym syntax, you can also construct values.
23:37:21 <Hijiri> oh yeah, one of the OpenGL libraries makes constants capital by making them pattern synonyms
23:37:37 <ski> that's nice
23:37:42 <Hijiri> thanks dramforever Cale 
23:38:06 <haskell241> that's actually a great idea, I found some unicode awesome chess character and I couldn't use them because show was restricted to string, if I do my own typeclass I could use theses
23:38:21 <ttt_fff> is it bad style to have codes longer than 80 chars?
23:38:41 <dramforever> s/longer/wider, yes
23:38:42 <ski> haskell241 : btw, for any complex `Show' instances, it's usually better to define `shows' (or `showsPrec') than `show'
23:39:19 <dramforever> haskell241: you could use unicode in strings
23:39:41 <dramforever> > "这是一个字符串"
23:39:42 <lambdabot>  "\36825\26159\19968\20010\23383\31526\20018"
23:39:43 <ski> ttt_fff : some people seem to do it. i generally try to avoid it
23:39:53 <dramforever> (Translation: This is a string)
23:40:04 <dramforever> or rather, character string
23:40:18 * ski sometimes also tries to have pages of code of no more than 66 lines ..
23:40:19 <dramforever> haskell241: see?
23:40:28 <haskell241> http://stackoverflow.com/questions/2086842/using-haskell-to-output-a-utf-8-encoded-bytestring
23:40:43 <haskell241> oh it's bytestring
23:42:28 <dramforever> > "ハセケル"
23:42:30 <lambdabot>  "\12495\12475\12465\12523"
23:42:45 <haskell241> it does output the \9816, but not ♘
23:43:00 <dramforever> haskell241: putStrLn
23:43:12 <dramforever> just don't show the string
23:43:57 <haskell241> commitBuffer: invalid argument (invalid character)
23:44:07 <dramforever> huh?
23:44:31 <haskell241> I get that when I do 
23:44:32 <haskell241> main = putStrLn "♘"
23:44:37 <dramforever> It works fine for me...
23:44:57 <dramforever> are you on windows?
23:45:16 <haskell241> ya
23:45:30 <dramforever> stupid terminal
23:45:34 <dramforever> or whatever you call that
23:45:59 <haskell241> it does work with "hSetEncoding"
23:48:52 <haskell241> anyway, thanks for everything guys, I have sleep, it's nearly 3am here, good day/night!
23:49:23 <ski> have fun
23:53:01 <ttt_fff> > [1 .. 3]
23:53:02 <lambdabot>  [1,2,3]
23:54:57 * hackagebot language-javascript 0.5.13.4 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.13.4 (ErikDeCastroLopo)
23:54:59 * hackagebot hjsmin 0.1.4.8 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.1.4.8 (ErikDeCastroLopo)
23:55:31 <erikd> yay!
23:56:09 <erikd> alanz: ^^^^
23:56:52 <sum_> >
23:56:55 <sum_> hello
23:57:04 <sum_> grep >
23:57:06 <sum_> grep \>
23:57:20 <sum_> hmm
23:57:26 <sum_> how do i grep for ‘>’?
23:57:45 * ski isn't sure what sum_ means ..
23:58:52 <sum_> can i submit pictures?
23:59:11 <dramforever> sum_: why are you asking here?
23:59:43 <sum_> QUOTE
23:59:44 <sum_> There is one particular use of IRC channels that is insanely useful, that I'd like to share.
23:59:44 <sum_> On various programming language channels, there are ad-hoc expression evaluation bots that experienced people use to guide newcomers through the intricacies of the language. If you're new to Haskell, for example, what you can do is grab the logs for the past 3 years, grep for "> " (used to invoke the evaluator) and you have instant insight into how an experienced Haskeller's mind works. It can speed up your learning by a factor of
23:59:45 <sum_> compared to reading papers / blogs / formal tutorials. I know because it did this for me.
