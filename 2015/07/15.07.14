00:14:54 <yayfoxes> Cale, book please
00:15:04 <yayfoxes> I'm using my laptop
00:16:13 <yayfoxes> I need Graham Hutton Programming in Haskell
00:22:32 <gfixler> yayfoxes: it's not a very big book - used it for Erik Meijer's edX course
00:22:36 <tero-> does ghc 7.10 use less memory than 7.8 when compiling with optimizations? 
00:22:49 <gfixler> yayfoxes: I used it from my corporate SafariBooksOnline account, though
00:24:11 <joco> what is the easiest way to find in which package is a given import contained in, for example Data.List.Split ? searching hackage for Data.List.Split gives me no result  (in the search field)
00:24:33 <tdammers> joco: have you tried hayoo?
00:24:40 <Haskellfant> hoogle is also pretty good
00:24:40 <joco> i try it thanks
00:24:53 <Haskellfant> especially the new one since it searches through all of stackage http://hoogle.haskell.org/
00:24:55 <gfixler> I have hoogle on the command line and Vim
00:24:56 <gfixler> super useful
00:24:58 <tdammers> yeah, hoogle too, although hayoo seems to know more of hackage
00:25:32 <joco> thanks, hoogle it is !
00:25:49 <gfixler> joco: linux?
00:25:58 <joco> mac
00:26:21 <gfixler> not sure about mac
00:26:42 <gfixler> it's in the Ubuntu repos, so I just installed it that way
00:26:54 <joco> i use mac with nix package manager
00:26:54 <tdammers> cabal install hoogle would also work
00:27:10 <joco> no cabal hell for me... 
00:27:23 <gfixler> tdammers: you know, I think that's actually how I got it
00:27:47 <gfixler> $ which hoogle gives me ~/.cabal/bin/hoogle
00:33:21 <hunteriam> I don't know enough about the ghc internals to figure this out myself
00:33:59 <hunteriam> Would it be possible in ghci or ghc with some modification to inspect the thunk that calculated a result? Let's say I evaluate some expression a
00:34:21 <hunteriam> Could I then go back and inspect the different function calls etc. in a that lead to my output?
00:34:31 <hunteriam> This seems like the ultimate debugging tool, if possible
00:34:53 <hunteriam> Like a trace route for evaluation
00:36:18 <gfixler> hunteriam: I don't know about looking back, but you can watch the runtime graph expand via ghc-vis
00:36:49 <hunteriam> I'm talking about inspecting the steps of evaluation
00:36:59 <hunteriam> Like start at the top level result is 5
00:37:00 <rowanblush> You can examine what thunks are currently evaluated with :sprint in GHCi.
00:37:24 <gfixler> ghc-vis shows thunks
00:37:24 <rowanblush> Or rather aren't evaluated.
00:37:29 <hunteriam> Does that give you specifics as to the function names in the thanks?
00:37:54 <gfixler> http://www.meetup.com/santa-monica-haskell/events/221132051/
00:37:56 <gfixler> you get this
00:38:01 <gfixler> it can be a little bit cryptic
00:38:02 <hunteriam> I was thinking take the output 5, go a step back and get the expression f, a step back and get the definition of f with all arguments supplied etc.
00:38:10 <gfixler> that's my meetup, and we had fun picking it apart, figuring out what things were
00:38:22 <gfixler> hunteriam: I don't think this goes backwards
00:38:46 <rowanblush> I don't think you can rewind time like that, no.
00:39:00 <rowanblush> Once something is evaluated, you lose the calculation that produced it.
00:39:02 <rowanblush> AFAIK.
00:39:21 <gfixler> I've written little things that keep the history as they go
00:39:27 <hunteriam> Well I wouldn't think you could by default, but do you know if it'd be very difficult to record the evaluation of a specific computation?
00:39:57 <hunteriam> Hopefully that wouldn't take up gigabytes of space like thinks themselves sometimes do
00:40:17 <gfixler> hunteriam: I don't know about in the general case, but certainly for toys
00:40:24 <gfixler> https://gist.github.com/gfixler/18e16becbd4fb54e517b
00:40:43 <gfixler> at the bottom there, I replaced foldl with scanl, and got a list of lists of the progression of the parsing
00:41:00 <gfixler> should be a lot of reuse if things are set up right
00:41:15 <hunteriam> That sort of thing is very nice
00:41:46 <hunteriam> But if you could do this to arbitrary code it would be really useful I think
00:41:59 <gfixler> haskell seems primed and ready for this, but I think you have to roll your own
00:42:12 <gfixler> hunteriam: writer monad?
00:42:24 <hunteriam> Don't know much about it, could look into it
00:42:25 <gfixler> continuation monad would make it easy
00:42:38 * gfixler he said, implying anything about the continuation monad was easy
00:42:59 <gfixler> writer is used often for logging
00:43:26 <gfixler> but you can capture any monoidal thing with it
00:43:44 <gfixler> strings, lists of anything, some sort of custom data structure
00:44:11 <hunteriam> That's pretty cool
00:44:39 <hunteriam> I've become to lazy to learn new haskell monads so I probably won't ever understand how it works
00:45:17 <adarqui> why to lazy to learn new monads?
00:45:27 <gfixler> it's a monad built around a pair of values, one being the value you're working with, and the other being a growing log of some sort
00:45:49 <gfixler> and the monoid takes care of the logging for you, so you just chain operations together with bind
00:46:13 <gfixler> hunteriam: here's a lazy tutorial: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
00:47:14 <gfixler> and writer is detailed in that style with 2 others here: http://adit.io/posts/2013-06-10-three-useful-monads.html
00:48:39 * hackagebot frpnow-gloss 0.12 - Program awesome stuff with Gloss and frpnow!  http://hackage.haskell.org/package/frpnow-gloss-0.12 (AtzeVanDerPloeg)
00:49:45 <yayfoxes> Cale, would you please give me the book?
00:50:17 <yayfoxes> +
00:53:39 * hackagebot frpnow-gtk 0.11 - Program GUIs with GTK and frpnow!  http://hackage.haskell.org/package/frpnow-gtk-0.11 (AtzeVanDerPloeg)
01:07:10 <adarqui> gfixler: purescript creator(s) attend your meetup?
01:07:23 <gfixler> adarqui: occasionally
01:07:30 <gfixler> he's given a few talks
01:07:39 <adarqui> cool
01:08:03 <adarqui> looks like a fun meetup, nice
01:08:33 <gfixler> yeah, our host has been hoping to get to a certain style, and my talk last week randomly hit that mark
01:08:38 <gfixler> so he wants us to try for that from now on
01:08:59 <gfixler> that style: bring something not too big, but a bit confusing, or at the edge of your understanding
01:09:09 <gfixler> and show what you know about it, and then let everyone work on it together
01:09:21 <adarqui> awesome
01:09:22 <gfixler> so you serve more as the host of some problem space than as a presenter of a bunch of info
01:09:29 <gfixler> I brought a 15-minute idea
01:09:37 <gfixler> and we picked it apart and batted it around for 2 hours
01:10:12 <gfixler> I just walked them through how I figured out the Monad instance for MaybeIO using hole-driven haskell
01:10:13 <adarqui> ya, i've been to a few meetups (not haskell, none around here), and i don't like the format.. i like that hands-on/collaborative format much better
01:10:25 <gfixler> edge of my knowledge - I didn't really know what to do with what I'd created, but holes helped me create it :)
01:10:32 <gfixler> and the gang in here said it was fairly idiomatic
01:10:49 <gfixler> adarqui: we've had a few talks that were just tons of info and slides, and it was rough to follow
01:11:06 <gfixler> collaboration is really fun
01:11:19 <gfixler> our host knew a bit more than I did, but it was on the edge of his knowledge, too
01:11:35 <gfixler> but he was able - with some help - to get us to actually create and bind values with my instance
01:11:58 <gfixler> I'm also in the Papers We Love meetup now
01:12:07 <gfixler> only been to one - the fourth in the LA chapter
01:12:28 <gfixler> Phil (purescript guy) gave that talk
01:12:44 <gfixler> that one was a lot of slides, but he presented it really well, and it was easy to follow and really interesting
01:13:00 <gfixler> it was on the W algorithm for type inference
01:13:03 <adarqui> i've never heard of hole driven haskell, looking it up now
01:13:18 <gfixler> there's a good talk on it that inspired me
01:13:21 <dramforever> gfixler: your three useful monads post reminds me of one thing: we are yet to find a way to visualize functions
01:13:34 <gfixler> dramforever: yeah, I hit that a lot now
01:13:36 <dramforever> visualize, as in drawing diagrams or so
01:13:54 <gfixler> dramforever: we just need to get the atoms down, and let recursion draw the rest for us
01:14:17 <dramforever> gfixler: if we do this then 1. haskell would be much easier to understand
01:14:40 <gfixler> dramforever: have you seen conal's FPGA/Haskell mashup talk?
01:14:46 <adarqui> byorgey's papers usually 'look amazing'.. with his use of diagrams
01:14:48 <dramforever> 2. we might be able to get a awesome 2d structured FP language editor!
01:15:01 <dramforever> gfixler: no, what's it like?
01:15:19 <gfixler> dramforever: beautiful visuals rendered out from code
01:15:25 <gfixler> of FPGA wiring diagrams
01:15:53 <gfixler> including compiling the code with optimizations turned on and getting vastly simpler wiring schemes
01:15:56 <gfixler> it's fairly brilliant
01:16:08 * dramforever just googled fpga
01:16:18 <dramforever> looks like a hardware programming language =P
01:16:26 <gfixler> yeah, field programmable gate arrays
01:16:32 <gfixler> basically tons of transistors on a chip
01:16:47 <gfixler> you can build logic gates out of them, and use them like little microprocs and such
01:16:54 <kaidelong> FPGA is a hardware architecture which is "programmable"
01:16:55 <gfixler> you chain up the gates in hardware, via software
01:17:15 <gfixler> what's *really* crazy is that apparently you can change this programmable hardware billions of times per second
01:17:32 <gfixler> which means he's able to write hardware code that reconfigures itself per task on the fly, realtime
01:17:41 <dramforever> so it has hardware speed and parallelization?
01:17:43 <dramforever> cool!
01:17:46 <gfixler> apparently
01:17:48 <gfixler> I'm a newb
01:17:57 <gfixler> http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
01:18:14 <kaidelong> there is promise if FPGAs can, by specializing in real time, one day be a better hardware platform even though you cannot achieve the same clock speeds
01:18:19 <gfixler> yes, parallelization is a big point of the talk
01:18:37 <gfixler> kaidelong: sort of like RISC
01:18:48 <kaidelong> for now they are an amazing tool for research and tinkering
01:19:09 <gfixler> kaidelong: I first heard of them a long time ago, in some writeup on evolving circuits
01:19:31 <gfixler> they programmed up a tone-recognizer, something like a 1-bit distinguisher of two tones
01:19:34 <kaidelong> that work is interesting, especially about how evolution tends to come up with things that involve non-local effects using things like EM induction
01:19:44 <gfixler> yeah, that was the crux of it
01:19:55 <gfixler> they let evolution make it better, and it got much better
01:20:00 <gfixler> but then no one could figure out how it worked anymore
01:20:10 <gfixler> and it turned out to be exploiting flaws in the hardware
01:20:14 <gfixler> and even the temperature of the lab
01:20:27 <gfixler> if they changed the thermostat, it stopped working, until they changed it back
01:20:27 <kaidelong> was that tone distinguisher the one that actually just made an antennae and picked up the tone the testing computer was comparing it to?
01:20:36 <gfixler> that might have been it
01:21:08 <gfixler> I recall they had to build in variables, like cycling the temp around the chip
01:21:22 <utdemir> hey. is Network.Socket.ByteString.sendAll blocking?
01:21:24 <gfixler> so it would evolve in more hostile ("real world") conditions
01:21:50 <kaidelong> err, it shouldn't be, but let me see if I can find out in detail
01:22:09 <kaidelong> (I think the OS is supposed to handle it so it shouldn't block)
01:22:40 <gfixler> kaidelong: I think this is it: http://www.damninteresting.com/on-the-origin-of-circuits/
01:22:41 <dramforever> utdemir: you're question doesn't make sense. sendAll sends all data and returns
01:22:42 <gfixler> mid-90s
01:23:34 <kaidelong> dramforever: makes sense to me. Control is transferred to the socket API with a pointer to the data in your program, does this happen synchronously or not?
01:24:20 <sccrstud92> dramforever: that sounds like blocking then, right?
01:24:28 <dramforever> kaidelong: the source code shows that it's just a loop, sending remaining data while there is some
01:24:39 <dramforever> http://hackage.haskell.org/package/network-2.6.2.0/docs/src/Network-Socket-ByteString.html#sendAll
01:24:48 <utdemir> kaidelong: We have a case that a security device drops some packets between the client and the server, therefore the client always sends retransmission packets, and server stalls open about ten minutes
01:25:09 <utdemir> I suspect that it stalls on sendAll call
01:25:30 <dramforever> utdemir: well you can check the source code, it's very easy to understand
01:25:33 <kaidelong> I think you are right
01:25:37 <kaidelong> I just looked at the source code
01:25:45 <kaidelong> it does not seem they're introducing anything asynchronous in there
01:25:58 <utdemir> dramforever: sendAll is just repeating send call, but don't know about send call
01:26:26 <kaidelong> send returns a value
01:26:33 <kaidelong> so it's defn. synchronous
01:26:49 <utdemir> send is a c call, i don't know what it does
01:26:53 <utdemir> oh, thank you then
01:27:22 <dramforever> utdemir: what's a "retransmission packet"?
01:27:38 <utdemir> so, i'll just do `timeout (60*1000*1000) $ sendAll ....`, right?
01:27:45 <dramforever> like sending the same data over and over again because server did not reply?
01:27:49 <dramforever> *ack
01:28:26 <kaidelong> you could try using forkIO
01:28:35 <utdemir> dramforever: Yes, exactly. Client doesn't get some packet it wants and requests retransmission from server AFAIK
01:28:38 <kaidelong> sendAll does not return anything useful
01:28:48 <kaidelong> you could do both
01:29:20 <dramforever> utdemir: IIUC that's how tcp is supposed to work...
01:29:38 <utdemir> kaidelong: Since it's a C call, still `timeout` works as expected, right?
01:30:40 <dramforever> kaidelong: you can try to write a sendAll that logs retries to see if it's blocking inside send or looping
01:31:17 <kaidelong> "A tricky implementation detail is the question of how to abort an IO computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code"
01:31:32 <kaidelong> docs seem to say no
01:31:34 <kaidelong> oh
01:31:37 <utdemir> kaidelong: That's bad.
01:31:38 <kaidelong> this is for GHC 6.10
01:31:50 <quchen2> Never use Google for Haskell docs.
01:32:02 <kaidelong> yeah
01:32:32 <quchen2> The comment is still the same in this case though.
01:32:47 <kaidelong> yeah
01:33:29 <kaidelong> well
01:33:34 <kaidelong> it might still be worth doing
01:33:57 <kaidelong> sendAll is a recursive wrapper over a C call but it means the timeout can happen when a foreign call to send returns
01:34:17 <kaidelong> so basically, you can still interrupt the loop with this
01:34:20 <utdemir> kaidelong: But in my case, probably one call returns about in ten minutes
01:34:31 <kaidelong> oh
01:34:39 <utdemir> since the same packet is dropped everytime
01:35:21 <utdemir> the bad thing is, i don't have the security device, so I can't try the code easily.
01:36:11 <utdemir> kaidelong: But gonna try putting a timeout there. Thank you for your help.
01:36:20 <dramforever> utdemir: try /j ##networking
01:37:21 <yayfoxes_> +
01:53:42 * hackagebot libgraph 1.5 - Store and manipulate data in a graph.  http://hackage.haskell.org/package/libgraph-1.5 (faddegon)
01:59:39 <prinsen> Anyone with experience using haskell with automake? I have some problems getting a Haskell .o file to be included by the linker
02:00:56 <dramforever> prinsen: I'm not really familiar, but IIUC you should use ghc to link
02:07:25 <zzubzzub> Is it possible to see fold going through the list step by step in GHCi? Like a trace?
02:08:10 <tdammers> zzubzzub: not sure, but considering how fold is lazy, I'm guessing no, not directly
02:08:33 <dramforever> zzubzzub: so what are you trying to do?
02:08:52 <zzubzzub> dramforever: Trying to implement foldl using foldr
02:09:49 <dramforever> zzubzzub: in that case pen and paper seems enough =P (Yes they work better than text editors)
02:10:07 <zzubzzub> dramforever: slower and more tedious though :/
02:10:51 * dramforever is not kidding, that's how he implemented foldl using foldr
02:12:01 <eds> I am getting an error with the eval function for the my GADT file. Code and error: http://lpaste.net/136444
02:14:15 <dramforever> eds: hmm the error messages are very misleading from the "Expected type" line
02:14:32 <dramforever> but you should be able to find out the error yourself by reading the 38th line carefully
02:15:02 <eds> I have two types of value. Expr Int and Expr Bool. When I evaluate Equals. It thinks there is only Expr Int .
02:15:04 <eds> oh wait
02:15:08 <eds> dag nabit
02:15:21 <eds> I have + instead of ==
02:15:25 <eds> my bad
02:15:33 <eds> dramforever
02:15:46 <eds> i should sleep. thanks though
02:16:08 <dramforever> eds: actually you could report a bug because of bad error message, but do check for duplicates before doing so
02:16:39 <eds> what do you mean by duplicates?
02:16:46 <dramforever> duplicate bugs
02:16:55 <dramforever> example bug I reported: https://ghc.haskell.org/trac/ghc/ticket/10498 it's really funny
02:18:12 <dramforever> and in your case Bool isn't even mentioned in expected and actual types, and it doesn't seem that Expr a can't match with Expr Ing
02:19:46 <eds> heh ok
03:00:36 <navaati> hi
03:01:37 <navaati> (beware, emacs speaking) I'm using the haskell-mode from melpa and it says that i must customize the haskell-mode-hook variable, however it does not exist
03:01:41 <navaati> what do I do ?
03:03:24 <Phillemann> navaati: There is #haskell-emacs in case nobody's answering here. :)
03:03:36 <navaati> Phillemann: ah, thanks
03:06:41 <protorobot> I heard a lot about haskell, but if I see the job list there aren't job offers. What is the purpose of this language? What can I build with it?
03:07:32 <aswins> Can't a person do things for fun?
03:07:49 <navaati> protorobot: it's a general purpose language, you can do anything you want actually
03:07:52 <dramforever> protorobot: well no jobs doesn't mean anything
03:08:43 <navaati> ok, maybe not dark embedded bit-flipping real-mode kernel stuff, or at least not easily (some did it tho)
03:12:03 <protorobot> Ok, I was only asking, because I've seen that it has a different approach. 
03:13:11 <dramforever> yes very different
03:14:32 <alpounet> protorobot: the small but growing number of companies using haskell isn't the best way to get an opinion on the language, I think =) And I don't know anyone writing haskell for a living who wish s/he did not
03:14:36 <alpounet> who wishes*
03:16:33 <funfunctor> Hi
03:17:08 <tdammers> alpounet: is that because you know nobody who writes Haskell for a living?
03:17:17 <funfunctor> Has any folks used Snap's FileUpload thing with Formlets, documentation is virtually non-existent
03:18:13 <tdammers> seriously though, I guess areas where Haskell doesn't shine would be those that require fine-grained control over timing
03:18:29 <tdammers> anything hard realtime, anything highly timing-sensitive
03:18:52 <tdammers> although even in those areas, using Haskell for code that *generates* the actual production code is often beneficial
03:19:03 <zzubzzub> Is there an equivalent of zipWith over tuples?
03:19:23 <tdammers> same for running things under severe hardware constraints, i.e., embedded systems
03:19:30 <funfunctor> tdammers: what about Atom?
03:19:59 <tdammers> funfunctor: what about it? I run a bunch of Haskell web apps on an atom server without trouble
03:20:05 <funfunctor> I disagree, it is just the case that Haskell needs to mature in that area by getting more attention
03:20:14 <funfunctor> tdammers: no no
03:20:20 <bennofs> @hackage atom
03:20:20 <lambdabot> http://hackage.haskell.org/package/atom
03:20:31 <tdammers> oh, different atom
03:20:34 <bergmark> zzubzzub: uncurry
03:20:49 <funfunctor> thx bennofs
03:21:12 <funfunctor> @hackage Ivory
03:21:12 <lambdabot> http://hackage.haskell.org/package/Ivory
03:21:18 <funfunctor> tdammers: ^
03:21:19 <tdammers> how does that avoid memory allocation in realtime-critical sections?
03:21:31 <tdammers> that's the thing that got me every time I tried myself
03:21:35 <protorobot> Ok, I will try Haskell. It seems an interesting language, and I never developed anything very big with other languages. Maybe I will do it with Haskell :D
03:21:58 <funfunctor> tdammers: hard real-time means you should be avoiding dynamic memory allocations
03:22:04 <tdammers> yes, exactly
03:22:10 <funfunctor> definitely not in critical sections!?
03:22:33 <tdammers> so how do you control dynamic memory allocation in a garbage-collected language?
03:23:09 <navaati> tdammers: the stuff linked by funfunctor generates code. The haskell code does not run on your hardware
03:23:23 <tdammers> right, so the "generate code" approach
03:23:41 <tdammers> fair enough... I thought this was haskell itself running on the realtime system
03:23:46 <navaati> (well, as for the Ivory package, it was a 404…)
03:23:58 <bennofs> @hackage ivory
03:23:59 <lambdabot> http://hackage.haskell.org/package/ivory
03:24:10 <navaati> tdammers: yeah, that would be hard. but now there is Rust !!!
03:24:29 <tdammers> yep, on my bucket list
03:24:44 <funfunctor> tdammers: it needs to mature but generating llvm would be the best target imho
03:24:47 <quchen2_> protorobot: It's a language with many special features, and it never hurts to have learned one of those. For similar reasons one should have a look at Lisp, Python, ASM, and C at some point.
03:25:10 <tdammers> ^ that is a very good list
03:25:13 <navaati> it does, like, *exactly* what you want haha, and it's very haskellish in the stdlib's and language design
03:25:19 <funfunctor> tdammers: Idris also is working towards bare metal
03:25:33 <tdammers> I'm also ogling OCaml a bit...
03:25:56 <tdammers> so far, my go-to language for this kind of stuff has been C++, but ugh
03:26:11 * bennofs feels Rust is a better C++ :)
03:26:16 <navaati> I don't really see the interest of ocaml when you have haskell, tbh, but i'm probably wrong
03:26:23 <navaati> bennofs: yup
03:26:30 <funfunctor> tdammers: if someone matures Idris's RTS down to zero I can attempt to port my opensource x86 firmware to it from Ada :)
03:26:42 <quchen2_> Rust is first and foremost new.
03:26:52 <zzubzzub> bergmark: I don't understand, is it possible to use it for something like: someFunc (+) (1,2) (3,4) -> (3,6)?
03:27:00 <navaati> quchen2_: it's very usable right now
03:27:09 <tdammers> ocaml looks interesting for systems programming... I'm hoping for slightly more predictable performance and such
03:27:21 <bennofs> navaati: programming in OCaml is fun, since it's a functional language where everything is explicit (whereas in Haskell, we have much implicit things like typeclasses etc)
03:27:26 <quchen2_> navaati: Yes, it is. But there's a lot more to a language than being well-designed, unfortunately.
03:27:51 <tdammers> in fact, other factors outweigh good design all the time
03:27:52 <bjz> tdammers: Ocaml still has a GC, and a big runtime...
03:28:08 <zzubzzub> @pl (\(x1,y1) (x2,y2) -> (x1+x2,y1+y2)) --bergmark: something simpler than that maybe?
03:28:08 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
03:28:15 <tdammers> bjz: true; I don't think of ocaml as an alternative for realtime things, but it's still on my bucket list
03:28:36 <quchen2_> navaati: We're using lots of bad or even terribly designed languages. We'll be doing so for a long time to come. There are lots of excellent languages that nobody uses. When you add "is it enterprise" to the list of potential language features you'll be surprised how the spectrum of usable languages shifts.
03:28:40 <navaati> quchen2_: well when you do embedded stuff most of the time you don't rely on lots of libs and stuffs do you ?
03:28:55 <funfunctor> whats the story here? http://lpaste.net/136581  how can I get a file upload form working?
03:29:11 <bjz> tdammers: third party code can be hard to read though when they insist on leaving out all the type signatures :(
03:29:30 <navaati> quchen2_: or are you referring to tooling ? in which case, yes, it lacks
03:30:15 <bjz> tdammers: full program, provably decidable inference is great and all, but makes it a pain to read. More of a style thing though than a language thing.
03:30:20 <quchen2_> navaati: I'm referring to the language including everything. Tooling, ecosystem, quality of the community, and so on. All of these are factors to a lanugage's quality and adoption.
03:30:41 <navaati> zzubzzub: hahaha, the horror. well tuples are not list, no you cannot iter through them. In the general case your function does not exist i'm afraid
03:30:41 <tdammers> navaati: the most important things to make a language successful is gaining critical mass fast enough, and the most important factors for that are enterprise goodwill, libraries, and adoption threshold
03:30:56 <quchen2_> Haskell has comparatively poor tooling, sufficiently large ecosystem, a great community, and is well-designed, yet it's not widely adopted.
03:31:20 <bjz> tdammers: yeah, it seems like Rust has that momentum at the moment - we'll see how it fares
03:31:28 <bernalex> tdammers: I don't think "fast enough" is that important.
03:31:46 <navaati> bernalex: (don't say the J word ;)
03:32:02 <tdammers> bernalex: haha, maybe not... but you do need critical mass
03:32:11 <bernalex> tdammers: haskell kind of disproves it.
03:32:18 <quchen2_> tdammers: You can be on the brink of success for *ages* :-D
03:32:21 <tdammers> haskell has critical mass
03:32:21 <bernalex> most languages grow or die quite quickly, but haskell has proven a very notable exception.
03:32:22 <bjz> bernalex: yeah - not so much speed, but making the milestones at the right time and keeping momentum going
03:32:33 <tdammers> haskell's problem is the threshold
03:33:01 <bernalex> my point is haskell was obscure for several years and has only really become truly "mainstream"-ish since hackage/cabal got stable.
03:33:05 <tdammers> An average programmer can pick up Python in 2 weeks. Same for Ruby.
03:33:21 * bernalex >>= sleep
03:33:39 <navaati> well for some reason the haskell community is unbelievably awesome, that has some weight i guess
03:33:40 <tdammers> Haskell, no matter what tooling or libraries you add, will by necessity take much longer to learn, and that's a problem for adoption in the wild
03:33:42 <quchen2_> tdammers: I can pick up Scala in 2 weeks. You can't pick up Scala if you've never used a functional language in that time. (By Scala I mean functional Scala and not Java with new Syntax.)
03:33:56 <bjz> bernalex: cabal keeps me out of getting fully into Haskell :(
03:34:20 <tdammers> quchen2_: yeah, sure. But even a decent enough Scala programmer, or a well-versed Lisper, will take longer than 2 weeks to get productive with Haskell
03:34:58 <quchen2_> tdammers: I've seen someone get to speed in Haskell in breathtakingly short amount of time. It's a single example, but he did not have that many conceptual problems.
03:35:21 <quchen2_> tdammers: I don't think there are enough people sharing their stories here. I'm sure many others picked up Haskell pretty quickly.
03:35:41 <quchen2_> In particular I think you can be very fast at learning it if you have a mentor (enthusiastic colleague, in my case).
03:36:21 <quchen2_> And keep in mind that "being able to write Haskell" does not mean you have to know about free monads and what the lens types mean. That's advanced stuff you can pick up as you go.
03:36:42 <quchen2_> In practice, what do we use in our everyday code? Some do-notation and socket library functions, not much more
03:37:23 <quchen2_> Most "language knowledge" is about finding your way around the popular libraries in my experience, not so much the language itself
03:38:32 <ronh> bjz did you take a look at stack? or sandboxes and or stackage
03:39:07 <bjz> ronh: sandboxes are the wrong default - super easy to get wrong :(
03:39:15 <bjz> yeah I have heard of stack
03:39:25 <bjz> looks to be the right way
03:39:31 <bjz> haven't tried it though
03:41:03 * frerich lines up behind quchen2_ and thug-yells  'Yeah, what he said!'
03:41:33 <quchen2_> O:-)
03:43:24 <tdammers> quchen2_: yeah, I can only judge from personal experience... I had a hard time getting used to thinking in Haskell, but maybe part of that was because so many concepts were alien to me, and I had a pretty solid background in imperative and OO before getting into Haskell
03:43:46 <tdammers> quchen2_: I may be teaching my colleagues here some Haskell at some point, so we'll see how that goes
03:44:20 <quchen2_> My Haskell learning experience was mostly about finding out what those strange monads were about. I did not find them very complicated, but also not very useful. I imagine I could have saved half a year of fiddling if someone had just shown me for a day or so.
03:44:24 <eckyputrady> Hi all. I have a question regarding Wai.Static.Middleware. So I have "something.html" that is served via Static.Middleware from my application. If I change the content of "something.html" while the application is running, when I request for "something.html", the returned content is outdated. Is this expected?
03:46:43 <eckyputrady> eh, actually, after I restarted the application, it still serves the old "something.html", not the new one. Has anybody experienced it before?
03:47:28 <alpounet> eckyputrady: it might be cached by your browser, the server or even both
03:47:49 <alpounet> restarting the app usually works for me, and when it doesn't i just force a complete refresh from the browser
03:47:54 <kuribas> I found the hardest part of learning haskell was how to *use* static typing, rather than *fight* with it.
03:48:22 <eckyputrady> I'm pretty sure it's not cached on the browser. I did curl and the output is still the old one.
03:48:26 <quchen2_> First you fight it, then you get along with it, then you don't want to miss it :-)
03:48:49 <eckyputrady> The server is Warp only. I can't find why it cache static file.
03:50:36 <eckyputrady> What puzzle me is that it still output the old file even tho I've restarted the server
03:52:28 <kuribas> quchen2_: right!
03:53:06 <eckyputrady> I have to delete "something.html", do request to the server (which it will return "file not found"), and add a new one. Once that sequence is done, the new file is served.
03:53:21 <eckyputrady> weird
03:53:32 <kuribas> What I did notice was that when I finally succeeded with the right types, etc, I understood my program much better.
03:54:55 <stevego> if you are writing a relatively complex program, with gui, database access, logging, etc, would you make the thing that connects it all together be IO or monad transformer/stack/whatever it is called
03:57:50 <funfunctor> ugh, getting this HTML form to work in Snap is soooo annoying!
04:03:19 <catgocat> What does it mean when someone says algebraic data types? Is it the type constructors and value constructors when we use `data Example.. = Foo` ?
04:04:09 <tdammers> "algebraic" refers to the concepts of "sum types" and "product types"
04:05:11 <catgocat> I'm still confused
04:05:51 <tdammers> let me see if I can find a good explanation somewhere
04:06:35 <tdammers> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types
04:06:50 <tdammers> this looks pretty good
04:08:12 <kuribas> stevego: I would use FRP
04:09:17 <kuribas> stevego: But yeah, there will be monads there necessarily.
04:09:42 <kuribas> At least the IO monad for database access, writing to files, etc...
04:09:52 <sveri> Hi, using emacs, how can I see the documentation / source of a function. I was looking at the haskell-mode wiki, but found nothing that helps
04:10:23 <naudiz> I just wondered... why isn't Control.Applicative in Prelude?
04:10:44 <catgocat> When I see something like function :: (Example a) => ...
04:10:46 <kuribas> sveri: "C-h f function", then enter on the source link
04:10:46 <catgocat> what is Example?
04:10:49 <Taneb> naudiz, hysterical raisins, I'm afraid
04:10:50 <catgocat> is it a data type?
04:10:55 <catgocat> a type constructor?
04:11:59 <naudiz> Taneb: and those would be? I mean... it's needed so often, to me it doesn't really make sense not to include it
04:12:37 <Taneb> naudiz, nobody had thought of it when the Prelude was originally created, it was a later invention
04:12:39 <kuribas> stevego: FRP is not necessary, but it makes managing the UI much easier.  The IO monads is necessary.
04:12:47 <sveri> kuribas: hm, C-h f gives me "helm-mode-describe-function" and when I enter "replicate" or "putStrLn" it finds nothing
04:12:54 <sveri> seems like I am missing some setup
04:13:03 <Taneb> naudiz, when it was introduced people didn't want to make a big change to the Prelude for something that is quite new
04:13:14 <Taneb> naudiz, and it took a while to catch on I think
04:13:58 <naudiz> thanks for the explanation. lets hope that will change over time
04:14:07 <kuribas> sveri: You mean a haskell function?
04:14:18 <sveri> kuribas: yea, I want to lookup a haskell function
04:14:45 <kuribas> sveri: you can use tags.
04:16:08 <sveri> kuribas: you mean this: https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Tags ?
04:17:03 <kuribas> sveri: yes
04:17:41 <kuribas> sveri: you need to generate a tag table first.  If you set haskell-tags-on-save to t then it will be done automatically.
04:17:57 <quicksilver> I imagine sveri is asking about looking up library functions
04:17:59 <sveri> kuribas: hm, haskell-mode-jump-to-def works, but all I see is this: Defined in GHC.List I'd like to have the docs or source, do I get them, when I use the tags?
04:18:05 <sveri> quicksilver: right
04:18:15 <quicksilver> I just use the web docs myself
04:18:27 <quicksilver> I have occasionally generated / installed local copies of those
04:18:31 <quicksilver> if I needed to work offline
04:19:38 <kuribas> me too, I just google it...
04:20:49 <sveri> hm, I see
04:21:32 <sveri> Coming from java and clojure I found it incredibly useful to be just a click or shortcut away from the source / documentation, especially when learning the language
04:22:33 <kuribas> true
04:23:24 <quicksilver> being a click away from the source can be a terrible idea :)
04:23:35 <quicksilver> depending on the quality of the language and the implementation of its libraries
04:23:38 <quicksilver> but of course I agree with you
04:23:58 <quicksilver> (I don't click in text editors tho :)
04:24:16 <quicksilver> I thought probably somebody had hacked this into haskell-mode but maybe they haven't
04:24:41 <sveri> Hehe, even if the source is terrible, it still is the truth you are working with, no need to hide it :D
04:25:17 <quicksilver> well, some haskell functions are implemented using internal primitives which are not referentially transparent
04:25:20 <bennofs> quicksilver: haskell-mode has haskell-jump-to-def-or-tag, which uses either GHCi to locate the identifier or falls back to TAGS
04:25:28 <quicksilver> and not really haskell
04:25:45 <quicksilver> reading that source can be very interesting but it can also be very confusing if you don't realise it isn't actually Haskell
04:26:05 <sveri> quicksilver: I guess that's ok, every language most probably has that
04:26:26 <sveri> And I think only few people see haskell as their first language, but I may be wrong here obv.
04:26:52 <quicksilver> sure but if they take that as a model of a good way to solve a problem
04:26:59 <quicksilver> it can be misleading
04:27:09 <sveri> I agree :-)
04:27:59 <kuribas> bennofs: but it doesn't show standard library functions.
04:28:24 <bennofs> How was this program called that downloads the source code of all deps ?
04:30:04 <kuribas> bennofs, quicksilver: it would be neat if it would show the documententation in a browser.
04:30:08 <bennofs> Ah, you might like codex
04:30:12 <quicksilver> it would
04:30:12 <bennofs> @hackage codex
04:30:12 <lambdabot> http://hackage.haskell.org/package/codex
04:30:28 <quicksilver> and it could also be aware of locally installed haddocks :)
04:30:29 <quicksilver> ideally
04:31:59 <kuribas> neat
04:38:44 <tamasgal> why shouldn't one install the haskell platform?
04:39:02 <tamasgal> i just found a commit on bitemyapp/learnhaskell...
04:40:23 <Nux_> > take 5 [1..]
04:40:26 <lambdabot>  [1,2,3,4,5]
04:41:41 <dramforever> tamasgal: I don't use it because 1. it doesn't update as fast as installing ghc+cabal manually 2. you cannot update packages in haskell-platform, and you cannot have packages that conflict with platform ones
04:42:00 <Nux_> @let f0 x = case x of 1 -> undefined;_ -> 1
04:42:01 <dramforever> well read "cannot" like "can but with pain"
04:42:01 <lambdabot>  Defined.
04:42:05 <tamasgal> ah ok
04:42:16 <dramforever> also it's too bloated
04:42:27 <Nux_> @let f1 _ = 1
04:42:28 <lambdabot>  Defined.
04:42:30 <tamasgal> i'm just looking for an easy way to get ghc running on scientific linux 6.4
04:42:40 <Nux_> >f0 1
04:42:45 <Nux_> > f0 1
04:42:47 <lambdabot>  *Exception: Prelude.undefined
04:42:54 <Nux_> > f0 undefined
04:42:55 <lambdabot>  *Exception: Prelude.undefined
04:43:00 <Nux_> > f1 1
04:43:01 <lambdabot>  1
04:43:05 <Nux_> > f1 undefined
04:43:07 <lambdabot>  1
04:43:45 <Nux_> > (\x -> case x of 1 -> undefined;_ -> 1) 2
04:43:47 <lambdabot>  1
04:43:54 <Nux_> > (\x -> case x of 1 -> undefined;_ -> 1) undefined
04:43:56 <lambdabot>  *Exception: Prelude.undefined
04:44:48 <Nux_> @undef
04:44:48 <lambdabot> Undefined.
04:45:05 <dramforever> Nux_: play with lambdabot in PM please
04:45:07 <Nux_> ok sorry about that, I was just making sure it worked
04:45:13 <dramforever> /query lambdabot
04:45:15 <Nux_> I have a question
04:45:40 <dramforever> just ask, people will answer if they know the answer
04:45:45 <Nux_> please look at the following:
04:45:49 <Nux_> > (\x -> case x of 1 -> undefined;_ -> 1) undefined
04:45:50 <lambdabot>  *Exception: Prelude.undefined
04:46:31 <dramforever> Nux_: and the question is...
04:46:32 <Nux_> I want to know if I'm understanding this right: The reason that gave undefined is because I tried to pattern match on undefined itself
04:47:07 <dramforever> yes
04:47:27 <Nux_> it's ok to pattern match on a container type which holds an undefined, that will bind undefined to some... not sure what to call it.. variable? symbol?
04:47:43 <dramforever> > (\x -> case x of 1 -> error "inside";_ -> 1) (error "outside")
04:47:44 <lambdabot>  *Exception: outside
04:48:24 <pavonia> Nux_: variable
04:48:36 <Nux_> fair enough, thanks
04:48:43 <kuribas> > let (a, b) = (1, undefined) in a -- Nux
04:48:44 <lambdabot>  1
04:49:54 <kuribas> > case (1, undefined) of (a, b) -> a
04:49:55 <lambdabot>  1
04:53:33 <Nux_> I've been looking at denotational semantics and the semantic approximation order. I think I'm right in saying that if you could pattern match on undefined, you'd be able to show that any value is less than or equal to bottom
04:53:51 <dramforever> yes
04:54:00 <Nux_> cool
04:54:11 <Nux_> just checking :)
04:54:13 <Nux_> thanks
04:54:14 <dramforever> hmm...
04:54:22 <dramforever> =)
04:54:34 <arkeet> ex falso quodlibet
04:55:23 <dramforever> we like solving the halting problem given false hypotheses don't we
04:55:26 <arkeet> if you could pattern match on undefined you could solve the halting problem.
04:57:23 <kuribas> what if a computer existed that could solve an infinite computation in finite time?
04:58:17 <dramforever> kuribas: well some people thought of a machine that doubles it's speed every step
04:58:31 <dramforever> called a zeno machine
04:58:43 <dramforever> and found some inconsistencies
04:59:13 <tdammers> wouldn't such a machine suffer from the same fallacy as the original zeno paradox?
04:59:27 <dramforever> I don't know
04:59:37 <dramforever> I don't know much about it
04:59:49 * kuribas looking it up on wikipedia
04:59:53 <thimoteus> is there any way to implement (!!) as a fold?
05:01:15 <Nux_> I appreciated that to find that a value was bottom would solve the halting problem, but for some reason I didn't appreciate that it's equivalent to find that bottom isn't a particular value. In particular, the 'undefined' in haskell should behave the same as a never-ending computation if it is to be treated as bottom, even if haskell can tell that it isn't a particular value.
05:02:09 <dramforever> Nux_: without exception handling haskell isn't able to tell
05:02:48 <Nux_> I guess that's the part that surprised me then
05:03:07 <tdammers> some bottoms can be found in finite time, but not all
05:03:25 <kuribas> thimoteus: with Either, but the return type will be Either.
05:03:49 <thimoteus> thanks
05:05:09 <tdammers> > let isHalting x = last (map (const False) x ++ [True]) in isHalting "foobar"
05:05:11 <lambdabot>  True
05:05:15 <Nux_> kuribas, https://en.wikipedia.org/wiki/Hypercomputation
05:05:20 <tdammers> > let isHalting x = last (map (const False) x ++ [True]) in isHalting [0..]
05:05:26 <lambdabot>  mueval-core: Time limit exceeded
05:05:26 <lambdabot>  mueval: ExitFailure 1
05:05:59 <tdammers> note that "time limit exceeded" isn't a conclusive answer really
05:06:51 <naudiz> is it wise to use the writer monad as a result for numerical calculation or does it just add unnecessary overhead?
05:06:52 <Nux_> yes, I'm sure most computations fall into that category
05:08:39 <naudiz> I'm thinking about adding subresults via writer in future projects for debugging
05:09:24 <dramforever> I think if your code does not use the log and you turn on optimizations ghc can erase the useless part
05:11:34 <naudiz> if I don't use the log, would it even be evaluated? because of lazy evaluation it should be ignored, shouldn't it?
05:14:15 <dramforever> yes
05:15:10 <naudiz> okay, thanks. I was just afraid that could be bad style
05:15:32 <dramforever> but I don't think anybody uses this approach
05:15:50 <kuribas> thimoteus: But you need a left fold, and that will not work with an infinite list.
05:16:05 <dramforever> and yet I might be horribly wrong
05:17:26 <aweinstock> thimoteus: http://lpaste.net/136582
05:18:07 <thimoteus> ahh neat
05:19:21 <kuribas> I think it is possible with a right fold too...
05:21:17 <kuribas> > let f a b i | i > 0 = b (i-1) | otherwise = Just a; in foldr f (const Nothing) [1..] 5
05:21:18 <lambdabot>  Just 6
05:21:31 <kuribas> > let f a b i | i > 0 = b (i-1) | otherwise = Just a; in foldr f (const Nothing) [1..5] 7
05:21:33 <lambdabot>  Nothing
05:22:52 <kuribas> thimoteus: ^^^
05:23:34 <kuribas> naudiz: I use Debug.Trace for debugging.
05:24:55 <k0ral> Hello
05:25:35 <k0ral> is there a library that implements fixed-size bitsets, with the size encoded in the type ?
05:27:26 <srhb> k0ral: Isn't a polymorphic length indexed vector sufficient?
05:27:48 <srhb> Assuming that a bitset is just a vector of bits.
05:28:21 <dramforever> k0ral: what are you trying to do with it?
05:28:32 <kuribas> k0ral: aren't those called "numbers"?
05:29:06 <k0ral> kuribas: bounded numbers :)
05:29:21 <naudiz> kuribas: thanks, I'll have a look at it
05:29:23 <srhb> Likt Int or Word8?
05:29:26 <k0ral> dramforever: treat them as a vector of flags
05:30:20 <k0ral> srhb: sure but I want to be able to select the upper-bound
05:30:28 <dramforever> k0ral: so what about a newtype wrapped word with accessor/modifier functions?
05:30:41 <srhb> k0ral: Right, then I think a length indexed unpacked vector is the way
05:31:22 <naudiz> koala_man: flags as in A = 1, B = 10, C = 100, etc? That's not really recommandable in Haskell. Better define a data type
05:31:37 <naudiz> oops, meant k0ral 
05:32:07 <k0ral> dramforever: I intended to wrap the bitset afterwards, I just wondered if a library didn't already implement it
05:32:25 <catgocat> I am stuck here, can anyone help me understanding some code related to trees?
05:32:29 <catgocat> It's like 1 line
05:32:40 <srhb> catgocat: just ask :)
05:32:41 <dramforever> k0ral: is the flag list *really* int indexed or you just just have multiple positions?
05:32:55 <lpaste> catgocat pasted “trees” at http://lpaste.net/136583
05:33:04 <catgocat> In the paste above, I don't understand a thing.
05:33:11 <k0ral> well, I have 24 flags, it's manageable but if I can avoid writing the boilerplate, I'd prefer
05:33:15 <catgocat> How can I create a tree where the two sub trees are empty?
05:33:15 <srhb> catgocat: One thing or anything?
05:33:19 <k0ral> dramforever: ^
05:33:23 <srhb> catgocat: Look at the definition of Maybe
05:33:28 <srhb> @src Maybe
05:33:28 <lambdabot> data Maybe a = Nothing | Just a
05:33:30 <naudiz> There are Word8, Word16 and so on. But Word 20 for example would just be weird
05:33:32 <k0ral> naudiz: ^
05:33:33 <catgocat> I know what maybe is, Just a or Nothing
05:33:58 <srhb> catgocat: Oh hang on, I see your issue
05:34:06 <catgocat> But still, I have tried to create a tree with that code that looks like this (a, left=Nothing, right=Nothing)
05:34:08 <frerich> catgocat: I think that 'Tree' definition is a little odd, too. I'd think "Maybe (Tree a)" would be more natural...
05:34:12 <srhb> catgocat: are you sure the recursive nodes are meant to have Maybe there?
05:34:23 <srhb> What frerich said :)
05:34:32 <srhb> It looks like an infinite type problem
05:34:39 <catgocat> srhb: I am not sure about anything, I've seen that solution for the problem in ex02 from real world haskell ch03
05:34:50 <k0ral> naudiz: that's the point: I think I've heard of some tricks to encode a vector size in a Haskell type
05:34:51 <srhb> catgocat: I think the solution is wrong unless you flip Maybe and Tree
05:35:08 <k0ral> naudiz: so that you can choose exactly how wide is your vector
05:35:27 <k0ral> dramforever: yes, it's int indexed
05:35:41 <dramforever> okay...I have no more opinions
05:35:49 <k0ral> dramforever: basically, it's the list of hours of the day, and for each one, it's either on or off
05:35:51 <dramforever> catgocat: yes the solution is incorrect
05:36:07 <naudiz> k0ral: data Flags = A | B | ...; evalFlag A = ...; evalFlag B = ...; ... evalFlags a:lf = evalFlag a $ evalFlags sf;
05:36:09 <srhb> k0ral: Are you ignoring everything I'm saying? :-) I think I've said length indexed vector like five times now.
05:36:24 <naudiz> k0ral: that's the approach I use
05:36:28 <lpaste> catgocat annotated “trees” with “trees (annotation)” at http://lpaste.net/136583#a136584
05:36:34 <catgocat> Like this ^ ?
05:36:38 <catgocat> That actually makes sense
05:36:48 <k0ral> srhb: I'm not, I was going to answer you, I just had troubles parsing all the answers I was given :)
05:36:50 <srhb> catgocat: Yes, exactly.
05:36:54 <srhb> k0ral: OK :-)
05:36:56 <catgocat> thanks guys you are the best
05:36:59 <dramforever> catgocat: yes =)
05:37:34 <naudiz> k0ral: this also works for IO conversion
05:37:57 <k0ral> srhb: also you didn't say it litteraly 5 times :P
05:38:16 <k0ral> literally*
05:38:38 <frerich> It was figuratively five times.
05:38:51 <srhb> k0ral: Indeed. :-) 
05:39:19 <srhb> I said it in my mind a few times too since I knew I had the right answer and I was getting frustrated from the lack of acknowledgement :(
05:39:30 * srhb strokes ego
05:39:33 <naudiz> let 5 = 2 -- now it was 5 times ;)
05:40:03 <frerich> https://xkcd.com/725/
05:40:17 <k0ral> is that space efficient ? I suppose you mean to use Bool as value-type ?
05:40:54 <srhb> k0ral: Yes, when unpacked they should take up one bit of space each.
05:41:46 <k0ral> oh right, you mentioned that "unpacked" figuratively 5 times as well :)
05:42:24 <Javran> hmm, just realized numbers are valid patterns ...
05:42:36 <Javran> > let x = 3 in let 5 = x in 1
05:42:38 <lambdabot>  1
05:42:49 <Javran> let x = 3 in let 5 = x in x `seq` 1
05:42:57 <Javran> > let x = 3 in let 5 = x in x `seq` 1
05:42:58 <lambdabot>  1
05:43:06 <Javran> > let x = 3 in let v@5 = x in v `seq` 1
05:43:07 <lambdabot>  *Exception: <interactive>:3:18-24: Irrefutable pattern failed for pattern v@5
05:43:23 <dramforever> Javran: well pattern matching on integers requires Num and Eq. that's it.
05:43:36 <dramforever> :t \3 -> ()
05:43:37 <lambdabot> (Eq a, Num a) => a -> ()
05:43:51 <dramforever> :t \2.2 -> () -- hmm what would this be?
05:43:52 <lambdabot> (Eq a, Fractional a) => a -> ()
05:44:00 <dramforever> oh sure
05:44:31 <Javran> that depends on the type inferred
05:44:39 <k0ral> srhb: I'm going for sized-vector, thank you ;) (here's your acknowledgment)
05:44:54 <Javran> :t \() -> ()
05:44:54 <lambdabot> () -> ()
05:44:57 <srhb> k0ral: Hooray! I will wear it proudly.
05:45:05 <Javran> :t \_ -> ()
05:45:06 <lambdabot> r -> ()
05:45:32 <Javran> @src const
05:45:32 <lambdabot> const x _ = x
05:47:18 <Javran> > let 3 = 5 in 3 + 3
05:47:20 <lambdabot>  6
05:47:36 <Javran> cannot bind literals, but otherwise it'll be a mess
05:55:24 <joco> is it possible to write this foldr ((:) . fmap (+3)) [] [[1,2],[3,3]] in a more elegant way using lenses?
05:55:38 <joco> i have the feeling yes
05:56:12 <joco> but i am not familiar with lenses
05:58:51 <srhb> joco: Why lenses specifically? Why not just double fmap?
05:59:37 <joco> srhb: i thought that lenses/traversables are meant for these kind of deeply nested structures
05:59:40 <srhb> > fmap (fmap (+3)) [[1,2],[3,3]] -- joco: Like this?
05:59:42 <lambdabot>  [[4,5],[6,6]]
05:59:52 <joco> sh1ken: yes
05:59:54 <joco> sort of
06:00:01 <joco> i mean, this is just a toy example
06:00:11 <srhb> joco: Right, I don't remember the lensy words.. each or something.
06:00:15 <joco> but what if the list becomes more nested...
06:00:23 <srhb> add more fmaps!
06:00:26 <srhb> :-)
06:00:26 <joco> say 5 lists deep...
06:00:28 <joco> :)
06:00:31 <joco> yes
06:00:55 <joco> i was just asking to learn a little bit about lenses
06:00:59 <joco> on this simple example
06:01:10 <srhb> joco: Ok, maybe try #haskell-lens if there are no lensers active here right now :)
06:01:14 <joco> ahhh
06:01:16 <joco> cool
06:01:18 <joco> thanks
06:01:53 <srhb> My best bet would be something like
06:02:12 <srhb> [[1,2,3]] & each.each +~ 3
06:02:17 <srhb> > [[1,2,3]] & each.each +~ 3
06:02:19 <lambdabot>  [[4,5,6]]
06:02:34 <dramforever> :t map . map . map . map . map
06:02:35 <lambdabot> (a -> b) -> [[[[[a]]]]] -> [[[[[b]]]]]
06:04:03 <joco> srhb: thanks
06:04:14 <joco> interesting
06:04:54 <srhb> It doesn't really net you a lot aside from different names and argument order.
06:05:22 <joco> this is just a curiousity question
06:05:42 <joco> but with more complicated stuff perhaps it would
06:05:48 <Nux_> > £
06:05:49 <lambdabot>  <hint>:1:1: parse error on input ‘£’
06:06:04 <johnw> note that many lenses are basically just fmap:  _1 f (x, y) = (,) <$> f x <*> pure y
06:06:33 <johnw> what makes them special is how they compose
06:07:17 <joco> oh yeah... i remember something like that from the SPJ talk
06:07:26 <joco> composition is the key
06:07:49 <johnw> and that you compose a lens with a getter, setter, traversal and prism, since they all have the same "shape" as functions between functions
06:08:37 <joco> what do I need to import to run the [[1,2,3]] & each.each +~ 4 example in ghci ? it complains when i try
06:08:38 <dramforever> type Over p f s t a b = p a (f b) -> p s (f t) -- the magic shape
06:08:51 <dramforever> joco: import Control.Lens not enough?
06:09:01 <joco> i have a look thanks
06:10:39 <danilo2> Hello all! :) I've got a small funny question today! :D Would somebody be so nice and explain to me what are the differences between usnafe casting to GHC.Prim.Any and casting to a datatype like data Hidden where Hidden :: a -> Hidden ?
06:11:30 <srhb> What do we need for fmap^n anyway?
06:11:40 <srhb> Aside from pi types!
06:11:43 <srhb> <<
06:11:54 <dramforever> danilo2: IIUC the latter does not always work for functions
06:13:01 <danilo2> dram forever: oh, thats interesting! do you have any more specific info about it ?
06:13:09 <danilo2> *dramforever
06:13:27 <dramforever> no =(
06:13:41 <dramforever> that would be some ghc internal stuff
06:15:15 <jiahad> how simple is hello world in haskell?
06:15:31 <dramforever> main = putStrLn "Hello world!"
06:16:33 <lpaste> dramforever pasted “More idiomatic hello world” at http://lpaste.net/136585
06:16:39 <dramforever> jiahad: ^'
06:16:41 <dramforever> *^
06:17:11 <hodapp> jiahad: Probably too simple to explain anything to you beyond that Haskell is not nearly as verbose as Java or C++.
06:17:25 <joco> dramforever: yes, Control.Lens was it, now it works, thanks srhb
06:17:30 <hodapp> and that's not exactly a high standard.
06:17:31 <dramforever> =)
06:17:53 <jiahad> Yeah, I see. Very straightforward.
06:18:57 <jiahad> Well, tnx for that, dramforever.
06:18:59 <dramforever> jiahad: well a lot more things are straightforward in haskell =)
06:19:31 <johnw> danilo2: see the Haddocks for GHC.Prim.Any
06:20:47 <hodapp> well, I was going to ask more about what he/she wanted to know about Haskell... but too late now
06:21:39 <Javran> http://dev.stephendiehl.com/hask/ ?
06:22:07 <hodapp> johnw: oh, you've returned again!
06:22:29 <johnw> hodapp: my things haven't been delivered yet by the movers, so I'm in and out until my ZNC server is setup again :)
06:22:42 <hodapp> johnw: ahh, okay! Didn't realize you were moving
06:22:50 <johnw> I moved to Sacramento, CA
06:22:55 <hodapp> johnw: did ever get a chance to read the email from weeks back?
06:23:02 <johnw> ah, yes I did!
06:23:27 <johnw> now, where did I put that e-mail...
06:23:30 <hodapp> hah
06:23:47 <johnw> there it is
06:24:34 <johnw> building up a structure using applicative means instead of constructing with Foo a b c, you construct with Foo <$> a <*> b <*> c, where a b and c are now actions yielding the expected types
06:25:26 <johnw> if you have a specific example in mind, that might help frame the discussion
06:25:52 * Javran wonders if idiom brackets are in use
06:26:07 <johnw> Javran: not in Haskell
06:26:13 <johnw> [| Foo a b c |] would be nice
06:26:26 <raichoo> Idris has them.
06:26:34 <johnw> they are pretty easy to specify in Coq too
06:26:43 <Javran> I see
06:29:51 <hodapp> johnw: The case I was thinking of was for modeling packed data structures in which fields all have a specific bit size and are back-to-back in memory, and ideally I'd be able to either make it hierarchical or make it possible a field to have other interpretations (for instance, to sensibly look at 16 aligned adjacent bits as a single 16-bit integer, or look at it as eight 2-bit fields, depending on what one
06:29:52 <danilo2> john: Are the online docs (https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html) not the haddock? I've seen them but still I do not feel the exact difference. I was just looking for exact points - why should I use Any instead of such "hiding" data types. I undestand that functions are "better supported" by Any, but is there any other difference?
06:29:54 <hodapp> requires)
06:30:25 <hodapp> johnw: and I was seeing some likenesses here between parser combinators built using applicatives and specifying a match of either A or B, or something like that
06:31:01 <hodapp> johnw: it ended up that BitData (in Ivory) already does much of this - I just had to dig around and figure it out without many docs making it clear
06:31:04 <hodapp> but, I am still curious
06:41:06 <navaati> isn't there a NaN litteral or something ? I need to emit NaN when my input meet certain input (negative numbers)
06:42:41 <srhb> > let nan = 0/0 in nan
06:42:42 <lambdabot>  NaN
06:43:23 <exio4> navaati: do you really need to emit NaN? 
06:43:26 <navaati> ok, no litteral, let's go for this :)
06:43:38 <exio4> navaati: why not Maybe?
06:43:50 <navaati> exio4: I'm coding sqrt
06:44:06 <srhb> Oh yeah you wan't Maybe then
06:44:19 <navaati> I understand that Maybe is generally better, but in this case…
06:44:35 <srhb> ... Maybe is also better. :-)
06:45:18 <srhb> navaati: Why would you not use it? :)
06:45:20 <navaati> and uselessly complicated
06:45:54 <srhb> It's not complicated...
06:45:58 <srhb> And certainly not useless.
06:46:24 <navaati> well… I'm lazy, right, is that ok :) ?
06:47:05 <srhb> Not really, but it's a free world. More or less. :-)
06:47:32 <navaati> for the context, my Sqrt function is used immediately afterward in a function that produces a complex based on the sig
06:47:33 <nshepperd> ehh, nan is sometimes better than Maybe
06:47:45 <nshepperd> being overhead free and syntax free
06:48:03 <navaati> sign* based on the sign of the real input, so, yknow, Maybe would just be clutter
06:48:09 <srhb> Alright. :)
06:49:10 <Gurkenglas_> Why are MaybeT, ListT, etc. implemented as their own types instead of having Maybe, [] etc. define instances of something like "MonadCompose", that would provide an operation named something like "(>.>)" that would be equal across all monad transformers?
06:49:28 <Gurkenglas_> *named equally
06:50:26 <nshepperd> Gurkenglas_: so that it works for multiple levels of transformers
06:50:57 <nshepperd> Maybe [Either a (b, w)]
06:51:26 <nshepperd> though I suppose you could define >..> and >...> and so on
06:51:45 <Gurkenglas_> Why would it stop working? (Maybe >.> Either a >.> (,) b) w
06:52:21 <nshepperd> oh, you're talking about a type operator?
06:52:24 <Gurkenglas_> yep
06:53:10 <nshepperd> that would be Data.Functor.Compose
06:53:25 <nshepperd> but, I don't think monad composition is actually that simple
06:54:16 <nshepperd> for instance MaybeT m a is actually m (Maybe a)
06:54:23 <nshepperd> not Maybe (m a)
06:54:31 <Gurkenglas_> As far as I have understood it, whether you can compose two monads depends on the right one, so MonadCompose would have its instance look something like (though I don't know the syntax)
06:55:32 <Gurkenglas_> http://lpaste.net/136586
06:56:01 <Gurkenglas_> Umm, args were the wrong order. http://lpaste.net/136586
06:56:39 <nshepperd> and data StateT s m a = StateT {runStateT :: s -> m (a, s)}
06:57:16 <exio4> Gurkenglas_: if anything, it'd a data constructor 
06:57:18 <exio4> Gurkenglas_: I think
06:57:25 <nshepperd> StateT doesn't seem to be any obvious wrapping of State in another monad, or another monad in State
06:57:26 <Gurkenglas_> Which would in my version look like (m >.> StateT s) a
06:57:35 <Gurkenglas_> -T
06:57:42 <Gurkenglas_> (m >.> State s) a
06:58:52 <srhb> As far as I recall you are restricted to certain forms of commutative monads if you want to naively compose them
06:59:29 <Gurkenglas_> MaybeT, ListT, EitherT a, etc. all compose from the right with all monads, right?
06:59:35 <Gurkenglas_> -T
06:59:48 <navaati> commutative means that the order of composition does not matter ?
07:00:15 <srhb> It means that you can join m (n a) and n (m a) with the same result afair? 
07:00:16 <navaati> (which is already false with, for example, Writer and Maybe)
07:00:22 <srhb> I should shut up, I don't remember this well enough
07:00:46 <navaati> join can be defined on two different monads ?
07:00:56 <srhb> Ignore what I said. :)
07:01:00 <exio4> you could make some kind of extra typeclass, I think
07:01:01 <nshepperd> Gurkenglas_: you could define >.> as a type family, I guess
07:01:01 <navaati> hehe
07:01:28 <nshepperd> so that the composition with State s would magically become s -> m (a, s)
07:01:48 <nshepperd> but then all sorts of nice type inferencing abilities disappear
07:02:38 <srhb> This paper might be of interest: http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf
07:03:32 <catgocat> Does it ever make sense to make case .. of with type variables? The only case I see where this is valid is `case a of a -> ..`
07:04:34 <srhb> catgocat: What do you mean type variables? a is a variable
07:04:37 <srhb> catgocat: ie. a value.
07:04:53 <catgocat> srhb foo :: a -> Int for example
07:05:01 <srhb> catgocat: But we don't have a type level case
07:05:10 <catgocat> a is a type variable there
07:05:15 <srhb> yes.
07:05:29 <catgocat> is there anything that the case .. of can match besides a itself?
07:05:50 <lpaste> catgocat pasted “test” at http://lpaste.net/136589
07:05:51 <srhb> catgocat: case someMaybe of Nothing -> ...; Just x -> ... ?
07:05:56 <catgocat> test that
07:06:04 <srhb> catgocat: You're mixing concepts
07:06:10 <catgocat> srhb: I can't use Nothing or Just because that would require the type to be Maybe.
07:06:14 <srhb> the a in the case statement is the variable a, the function argument
07:06:27 <srhb> Not a type variable as in the type signature
07:06:29 <catgocat> I know
07:06:33 <srhb> Okay.
07:06:36 <srhb> Then I'm confused :-)
07:06:42 <catgocat> If I match the a to, let's say, 1337, it gives me an error.
07:06:54 <nshepperd> yes, you can't case match on a value of unknown type
07:06:59 <srhb> Aaah
07:07:00 <catgocat> yes that is what I'm saying
07:07:06 <srhb> Okay, sorry, I completely misunderstood your question :)
07:07:15 <catgocat> so the only use for case .. of with variables with unknown type is case val of val -> ..
07:07:16 <nshepperd> apart from "case x of x" as you mention
07:07:28 <srhb> Yes, case statements are for destructuring data. And you cannot destructure forall a. a
07:07:42 <catgocat> yes, that
07:07:52 <catgocat> but aren't those values with unknown types called type variables?
07:08:18 <Gurkenglas_> "case (...) of x -> " == "let x = (...) in "?
07:08:34 <catgocat> what do you call variables with known type ?
07:08:34 <srhb> catgocat: a in the type signature is called a type variable, yes.
07:08:45 <catgocat> s/known/unknown
07:08:58 <srhb> catgocat: Well it still has a type. `a` is a type.
07:08:58 <geekosaur> type variables appear in type signatures, not values. values can't really have unknown types (although the type may be an existential, which limits what can be known about it)
07:09:12 <srhb> It's just that it can be any type
07:09:18 <catgocat> ok then
07:09:21 <nshepperd> in "x :: forall a. a", a is the type variable. I don't know any term for x apart from 'value of unknown type'
07:09:21 <catgocat> thanks
07:09:32 <nshepperd> or maybe, 'existential value', idk
07:10:28 <Gurkenglas_> Is there a monad with more than one emergent transformer?
07:10:35 * geekosaur thinks of it as existential container
07:10:51 <catgocat> _ also works in case .. of
07:11:09 <catgocat> does _ match everything ?
07:11:13 <geekosaur> no wayto know what's in it unless it was constrained with a typeclass, and then the only thing you can do is call class methods on it
07:11:16 <Gurkenglas_> Why are three instances on https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans duplicate?
07:11:30 <geekosaur> catgocat, yes, _ is a wildcard
07:12:24 <geekosaur> you can use it with guards to do value testing instead of structure testing in case .. of, or you can do something like: isJust (Just _) = True; isJust _ = False
07:17:27 <lpaste> catgocat pasted “fsadfasd” at http://lpaste.net/136592
07:17:33 <catgocat> Why does this happen ^ ?
07:17:41 <catgocat> I found the explanation in real-word-haskell very confusing
07:18:38 <bennofs> catgocat: because you wrote apple starting with lowercase
07:18:42 <bennofs> catgocat: apple and Apple are different
07:18:54 <catgocat> yes but when matching for the string "apple"
07:19:02 <catgocat> it returns Apple as normal
07:19:08 <catgocat> but when the function is given "orange"
07:19:11 <catgocat> it returns Apple
07:19:14 <bennofs> catgocat: oh sorry, I see
07:19:20 <johnw> hodapp: ah, hmm
07:19:24 <bennofs> catgocat: that is because apple is not a string. "apple2 would be a string
07:19:26 <srhb> catgocat: You might as well call the first case foo or anyVar
07:19:31 <bennofs> eh, typo. meant "apple"
07:19:50 <srhb> catgocat: The value will be assigned to that because the pattern `apple` or `anyValue` always matches any value.
07:19:58 <catgocat> I don't understand, the case of is suposed to match against a string. So I gave two strings for it to try to match
07:20:13 <srhb> catgocat: Then you mean case f of "apple"
07:20:15 <srhb> not case f of apple
07:20:26 <hodapp> johnw: but IIRC the approach that parsec uses for this is applicatives for some outer stuff, monoids for many other combinators
07:20:42 <catgocat> srhb: but apple is a variable that contains "apple", so why does it match everything?
07:20:53 <c_wraith> catgocat: because you're creating a *new* binding
07:21:00 <c_wraith> catgocat: case expressions create bindings
07:21:07 <srhb> catgocat: the apple in case just shadows the top level definition
07:21:12 <catgocat> so what does apple evaluate to ?
07:21:19 <srhb> the value of f
07:21:21 <hodapp> johnw: and what I couldn't see here is what applicatives actually get me, over something like monoids
07:21:32 <catgocat> what
07:21:36 <catgocat> why ???
07:21:48 <srhb> catgocat: case x of y -> x == y -- is always true
07:21:58 <srhb> You are BINDING the name y to the value of x
07:22:37 <aweinstock> catgocat: you'd get the behavior you're intuiting with the PatternSynonyms extension (declaring both apple and orange as patterns)
07:22:40 <Wizek__> Good Morning!
07:23:04 <srhb> catgocat: The pattern y works just like your pattern f in the function equation
07:23:04 <catgocat> srhb: but how is it binding? so anything that is not a literal binds?
07:23:15 <c_wraith> catgocat: case expressions are *for* binding
07:23:18 <bennofs> catgocat: yes, any variable name will bind
07:23:23 <catgocat> ooooooooooooooooooooooooooooooooooh
07:23:27 <catgocat> its like a function argument
07:23:34 <catgocat> is that it?
07:23:52 <geekosaur> strictly speaking, function arguments turn into case expressions
07:23:54 <srhb> It's not a function argument, but pattern matching behaves the same way in case expressions as in function equations
07:24:05 <catgocat> oh I see I see
07:24:12 <catgocat> oh yes, I got it
07:24:16 <catgocat> ok
07:24:31 <catgocat> yes 
07:24:31 <srhb> catgocat: Consider that you could rewrite what you just did to
07:24:44 <kuribas> > let (==) a b = False in case x of y -> x == y
07:24:45 <srhb> whichFruit apple = Apple; whichFruit orange = Orange
07:24:46 <lambdabot>  False
07:24:52 <srhb> Which has exactly the same problem
07:25:07 <srhb> It always yields Apple because apple always matches ANY string, including "orange"
07:25:14 <mizu_no_oto> johnw: When do you get into Boston?
07:25:46 <kgadek> could anyone help me with FFI ? I can't get it working on OS X, cabal build is notoriously trying to use /usr/bin/gcc which is 1) C compiler, not C++ compiler 2) clang, not actual C . https://github.com/kgadek/ffi-stack-test
07:25:58 <catgocat> yes ok
07:26:04 <catgocat> thank you :)
07:26:04 <bdesham> is there a mirror of the Happstack crash course? the official link gives a 404
07:26:39 <Gurkenglas_> What do y'all think of this? http://lpaste.net/136586
07:27:35 <kgadek> Gurkenglas_: data (m :.: n) a = Compose { decompose :: (m (n a)) } 
07:28:03 <Twey> navaati, srhb: Surely since NaN already exists in Float, you should use Float with NaN instead of Maybe Float.  Otherwise you have to consider two error values — Nothing and Just NaN.
07:28:22 <Gurkenglas_> Of course, updated. Also fixed the penultimate line.
07:28:52 <srhb> Twey: navaati already argued that.
07:28:57 <Twey> navaati, srhb: I mean, hypothetically (and ignoring performance considerations) it would be nice if Float didn't contain NaN and we could use Maybe instead, but given that that's not the case, I'd rather just have one error value rather than two
07:29:13 <Twey> Oh, I must have missed that
07:29:13 <catgocat> what are called variables that are in type definitions like this: :: (Enum a) =>, what is Enum there? is it a data type?
07:29:15 <aweinstock> kgadek: i havn't tested it, but the obvious thing that sticks out to me is that you have a .cpp file, and it doesn't have an extern "C" {} block in it
07:29:29 <srhb> catgocat: They are called constraints.
07:29:49 <catgocat> how can I create one of my own?
07:29:55 <catgocat> s/of/on
07:29:56 <Gurkenglas_> Better name for MonadCompose, maybe? Something like ComposableWithMonadsFromTheRight?
07:29:59 <srhb> catgocat: You can read that type as "for any type a that has an instance of Enum
07:30:02 <aweinstock> kgadek: so even if it's going to be run through an actual c++ compiler, the name is goingto get mangled, so the FFI won't find the right symbol
07:30:16 <Twey> catgocat: You can define a type class
07:30:26 <srhb> catgocat: You can either derive certain instances for your type, or you can write your own type class and instancs
07:30:27 <mizu_no_oto> catgocat: Enum is a typeclass
07:30:29 <catgocat> srhb: oh ok, I haven't got there yet but it's beyond data types, is that correct?
07:30:38 <catgocat> data ... = doesn't apply here
07:30:41 <Twey> catgocat: Enum is a type class.  The ‘Enum a’ bit there is a constraint (read as ‘a must be an instance of Enum’)
07:30:43 <kuribas> Twey: then what would 0/0 be?
07:30:46 <srhb> catgocat: Well yes, you need to know data types before you can write type classes and instances :-)
07:30:49 <kuribas> Twey: raise an exception?
07:30:53 <kgadek> wow
07:30:57 <kgadek> aweinstock: wow. it worked.
07:31:02 <Twey> kuribas: I don't understand the question
07:31:04 <mizu_no_oto> catgocat: yes.  a typeclass is similar to an interface
07:31:08 <Twey> kuribas: It would be Nothing
07:31:09 <kgadek> aweinstock: this err message was REALLY confusing
07:31:24 <kgadek> aweinstock: no, wait. it doesn't
07:31:26 <Twey> (rather, I understand the question, but not the purpose, so I suspect that the obvious answer may be unhelpful)
07:31:30 <catgocat> ok alright
07:31:46 <mizu_no_oto> catgocat: https://www.haskell.org/tutorial/classes.html
07:32:08 <srhb> catgocat: Examples of simple type classes are Eq, which defines equality. So whenever you use (==) you are constrained to types that have an Eq instance.
07:32:11 <catgocat> mizu_no_oto: I'm reading a book, I think the next chapter covers that
07:32:11 <kgadek> aweinstock: this is crazy, cabal build got it working somehow, now after cabal clean I can't reproduce that
07:32:12 <srhb> :t (==)
07:32:13 <lambdabot> Eq a => a -> a -> Bool
07:32:22 <kuribas> Twey: So the type (/) would be Double -> Double -> Maybe Double?
07:32:24 <aweinstock> kgadek: I found this, which seems to suggest that forcing a different compiler isn't well supported: https://github.com/haskell/cabal/issues/1325
07:32:28 <Twey> kuribas: I'm suggesting it would be nice, semantically, if we replaced Float (which contains NaN) with a type that doesn't contain NaN, and gave operations such as division that can produce NaN a Maybe NoNaNFloat result type
07:32:33 <Twey> kuribas: Right
07:32:39 <catgocat> srhb: yes, >= works with Ord right,
07:32:45 <srhb> :t (>=)
07:32:46 <lambdabot> Ord a => a -> a -> Bool
07:32:49 <Twey> kuribas: The effective difference is just to make the presence of NaNs visible in the type signature
07:32:57 <kuribas> Twey: Wouldn't formulas become cumbersome?
07:33:09 <aweinstock> kgadek: can you paste a log of the terminal session to lpaste?
07:33:14 <Twey> (and thus enable exhaustiveness checks, &c.)
07:33:35 <Twey> kuribas: It's a question of syntax *shrug*
07:33:52 <Twey> kuribas: The Applicative instance of Maybe isn't terrible to use, though unfortunately you lose the ability to use it infix
07:33:58 * hackagebot OrderedBits 0.0.0.2 - Efficient ordered (by popcount) enumeration of bits  http://hackage.haskell.org/package/OrderedBits-0.0.0.2 (ChristianHoener)
07:34:00 * hackagebot yesod-crud 0.1.2 - Generic administrative CRUD operations as a Yesod subsite  http://hackage.haskell.org/package/yesod-crud-0.1.2 (league)
07:34:05 <mizu_no_oto> catgocat: the big difference between typeclasses and OO is that OO bundles implementation with the data, but typeclasses put it into a separate 'implementation dictionary'.  This means that there's a bunch of things you can do with typeclasses that objects don't really support, and a couple of things that are awkward with typeclasses but natural with objects.
07:34:25 <kgadek> aweinstock: http://lpaste.net/136598
07:34:36 <mizu_no_oto> They're really a surprisingly good language feature
07:34:38 <Twey> kuribas: It's an idealistic suggestion, because the bigger problem is that it would be horribly inefficient.  There's a reason NaN is implemented as it is in IEEE-754.
07:35:00 <nshepperd>   mn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,rfdddddddddddddddddddddd---------------------------------------------------------
07:35:02 <kuribas> yes
07:35:08 <srhb> catboard!
07:35:19 <Gurkenglas_> Is he having a heart attack?
07:35:23 <Twey> kuribas: But, you know, in a perfect world.  ☺
07:35:42 <kuribas> I am okay with NaN actually.
07:35:52 <nshepperd> 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
07:35:53 <srhb> Gurkenglas_: Great, now I'm actually worrying that... I liked cat on keyboard better.
07:35:53 <nshepperd> 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
07:35:55 <nshepperd> 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999998
07:35:56 <Twey> I'm not a fan of floats in general
07:35:58 --- mode: ChanServ set +o monochrom
07:35:59 <Gurkenglas_> tip
07:36:00 <Gurkenglas_> *rip
07:36:18 <Gurkenglas_> One 999999999999999 for yes, two 999999999999 for no. Are you having a heart attack?
07:36:25 <catgocat> What happens when all guards evaluate to false?
07:36:33 <Twey> catgocat: The next pattern is tried
07:36:33 <catgocat> and there is no | otherwise guard
07:36:39 <catgocat> Twey: all of them
07:36:44 <srhb> catgocat: If no guard matches and there are no other patterns, your program crashes
07:36:46 <kgadek> aweinstock: oh my, it's even funnier. http://lpaste.net/136599
07:36:46 <Twey> catgocat: An error
07:36:58 <Twey> catgocat: (you should try to make sure that can't happen)
07:37:12 <bergmark> catgocat: or if there are other patterns they get tried
07:37:15 <srhb> catgocat: The compiler can warn you if you haven't written inexhaustive patterns.
07:37:16 <Twey> GHC will try to warn you if your patterns aren't exhaustive.
07:37:17 <kuribas> Twey: they are pretty handy.  Metafont for example uses fixed point arithmetic, but sometimes it causes loss of precision.
07:37:25 <catgocat> what about case .. of ? if they all fail, is the next pattern tried?
07:37:31 <Twey> kuribas: I prefer rationals
07:37:47 <srhb> nshepperd: You OK there? (Hoping a ping works :))
07:37:51 --- mode: monochrom set -o monochrom
07:38:00 <Twey> catgocat: Same deal.
07:38:17 <bergmark> catgocat: i.e. `a | p -> ...; | q -> ...' is equivalent to `a | p -> ...; a | q -> ...'
07:38:18 <Twey> catgocat: Multiple equations for a function desugar to case, so the behaviour is the same
07:38:26 <kuribas> Twey: it's slower, and only good when you don't need sin or sqrt.
07:38:51 <catgocat> Twey: but for example if I write a long bunch of nested if expressions, and inside I have a case .. of, but that case .. of doesn't match the value. does the program cancel everything inside that function and tries the next pattern?
07:38:56 <kuribas> (or other functions on float).
07:38:59 <Twey> kuribas: You can approximate sin/sqrt — we have to anyway
07:39:19 <catgocat> when I mean pattern I mean function pattern
07:39:38 <Twey> kuribas: I'm not sure about slower.  There are some smart representations of rationals, like Hehner's quote notation.  Not sure which would be faster in practice implemented in hardware and used on real-world problems.
07:39:43 <bergmark> catgocat: there is no backtracking, once a pattern (incl. guard) matches it doesn't try another one
07:39:50 <fishburne> Can some one please take a look at this code http://lpaste.net/136590 and tell me why the function 'getTrainedNetwork' is running out of memory? First version of this program used lists for main stuff. I was told that it might be the issue. Now I have replaced lists with IOArray (for the most part). But it still run out of memory.
07:40:08 <srhb> catgocat: No, guards are always associated to a pattern, and the next pattern will be tried if no guards match, nothing else.
07:40:09 <bergmark> i wrote code in a lang with backtracking pattern matching, horrible :(
07:40:12 <catgocat> bergmark: so If the case .. of doesn't match it raises an error
07:40:21 <srhb> catgocat: If you get to an if-then-else, you've already matched some pattern.
07:40:38 <nshepperd> srhb: pong :)
07:40:44 <srhb> nshepperd: Oh good, no stroke. :)
07:40:50 <nshepperd> the cat is very sorry for spamming you all
07:41:08 <kuribas> Twey: when you start approximating numbers you'll have the same problem as with float.  For example loss of precision when subtracting.
07:41:18 <catgocat> Once a function pattern has matched, and there is a case .. of expression, and if no pattern of that case .. of expression matches, does the program raise an error?
07:41:18 <Gurkenglas_> How'd it manage to press only 9 and enter?
07:41:19 <srhb> Yay, I really did prefer the cat thing over having to online stalk you and send an ambulance :P
07:41:22 <aweinstock> kgadek: I made some changes involving #ifdef __cplusplus and extern "C", and it works correctly for me
07:41:28 <Twey> kuribas: Yeah.  After all, floats are just approximated rationals.
07:41:36 <aweinstock> kgadek: should I submit a pull request?
07:41:38 <Twey> kuribas: But you also have the option to not approximate, which you don't get with floats.
07:41:44 <kgadek> aweinstock: yes, I'd be grateful!
07:41:54 <srhb> catgocat: Yes, but generally we don't worry about these exceptions and instead always write exhaustive patterns.
07:42:11 <catgocat> ok got it
07:43:12 <Twey> kuribas: The approximation process might be slower for rationals, I don't know
07:43:27 <Gurkenglas_> Generally speaking, whenever I'd write to the right of the -> of a pattern (error "Wtf my program math is all wrong cause I ended up here") I leave it out.
07:43:37 <kuribas> Twey: I've rewritten my library as (Num a) or (Floating a), and specialize each function for Double.
07:43:57 <kuribas> Twey: but double is convenient since it is builtin in most computers.
07:44:14 <aweinstock> kgadek: https://github.com/kgadek/ffi-stack-test/pull/1
07:44:38 <kuribas> Twey: I can imagin that sqrt for rationals will be lot slower, if just for that reason.
07:44:55 <Gurkenglas_> (Meaning the math inside that function, not assumptions about the arguments. Compare with Java's exceptions vs asserts)
07:45:14 <nshepperd> Gurkenglas_: my system only repeats the last key to be held down, afaict
07:45:29 <Twey> kuribas: Again, I'm speaking idealistically.  I'm not suggesting everyone rewrite all their high-performance number-crunching code to use rationals without any hardware support.  But I don't know of a reason that hardware support *couldn't* make rationals as practical as floats, and if it could then they're a better option.
07:45:54 <Twey> Being semantically better-behaved and giving the programmer more control over the corner-cases.
07:46:07 <utdemir> Hey. I have "class HasPK a where typePK a; getPK :: a -> PK a" . Now I want to write the function (f :: HasPK a => a -> Bool). But how can I constrain HasPK a that it's PK should be a specific type, like "(HasPK a, PK a == Int) etc?"
07:46:18 <Twey> And for similar reasons I think they're a better choice when performance isn't so critical.
07:46:57 <Twey> utdemir: You can use a ~ constraint
07:47:05 <Twey> utdemir: (HasPK a, PK a ~ Int)
07:47:10 <kgadek> aweinstock: the short one: http://lpaste.net/136600 and the verbose one: http://lpaste.net/136601
07:47:17 <kgadek> aweinstock: TL;DR: works the second time :D 
07:47:19 <utdemir> Twey: Oh, thats what I exactly want. Thank you
07:47:23 <kgadek> but never the first
07:47:53 <kgadek> aweinstock: notice I've exported CC=g++-5 but that did not change anything
07:49:11 <aweinstock> kgadek: it's odd that it'd work intermittently, "cabal clean && cabal build" works for me (on debian)
07:49:37 <aweinstock> kgadek: i'm glad that it works at least semi-deterministically though ;)
07:49:42 <kuribas> Twey: are you talking about unlimited precision rationals?
07:50:33 <kuribas> Twey: I think unlimited precision rationals are harder to implement in hardware than fixed precision floating point.
07:51:50 <Twey> kuribas: Probably extensible rationals, similar to GHC's Integer
07:52:19 <fishburne> Can some one please take a look at this code http://lpaste.net/136590 and tell me why the function 'getTrainedNetwork' is running out of memory? First version of this program used lists for main stuff. I was told that it might be the issue. Now I have replaced lists with IOArray (for the most part). But it still run out of memory.
07:52:22 <Twey> kuribas: In quote notation, rational addition and subtraction are integer addition and subtraction
07:52:44 <Twey> I'm not sure about multiplication and division
07:55:15 <aweinstock> fishburne: on line 47, it looks like weightedSum might be lazier than it needs to be?
07:55:18 <sbrg> Where can I find information about this whole stack tool and stackage thing?
07:56:30 <sbrg> Is stack just a tool similar to cabal-install that uses stackage which is basically hackage but with combinations of packages known to work and LTS support?
07:56:53 <aweinstock> fishburne: try replacing that with "weightedSum ws is = foldl' (+) 0 $ zipWith (*) ws is"
07:57:36 <Gurkenglas_> Is there some way to do with a infix type operator what turns (.) into (.f)? Meaning partial application in the wrong order
07:58:21 <kadoban> sbrg: It does much more and much easier. In particular, it takes care of installing (the correct) GHC for you as well.
07:58:30 <fishburne> aweinstock: Thanks, let me check.
07:58:59 * hackagebot text-show-instances 2.0.1 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-2.0.1 (ryanglscott)
07:59:01 <kadoban> sbrg: It's newer though, so there may be some hiccups.
07:59:01 * hackagebot PrimitiveArray 0.6.1.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.6.1.0 (ChristianHoener)
07:59:59 <sbrg> kadoban: Ah, I see. Looking at the gif in github, it also seems faster. Admittedly, the computer it was running on most likely beats my coal powered laptop, but I have always been annoyed with the time it takes to do stuff like cabal run and so on.
08:00:13 <sbrg> that is, cabal begin slow(not building code)
08:00:36 <kadoban> sbrg: IIUC, stack is /much/ safer in general as well. cabal doesn't even use HTTPS or anything basic like that, stack /should/ IIUC do something much better, though I haven't looked at it in depth.
08:00:42 <aweinstock> fishburne: why are all the processing functions in IO? is it just for print statements?
08:00:54 <geekosaur> cabal-install is working on https
08:01:02 <geekosaur> the problem is the HTTP package doesn't do https
08:01:13 <geekosaur> and that leads to nasty bootstrapping issues
08:01:29 <Gurkenglas_> What infix operator should I use to represent flip (.)? And don't say (<<<).
08:01:33 <fishburne> aweinstock: No. for the IOArray...
08:01:34 <kadoban> "cabal-install is working on https" … I think that's way more misleading than you intended
08:01:35 <Gurkenglas_> *(>>>)
08:01:49 <geekosaur> I suspect stack is taking the same out the cabal-install folks are: use an external program to fetch
08:02:04 <geekosaur> mrr, yes, lovely multivalued languages :/
08:02:56 <nitrix> :t (>>>)
08:02:57 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
08:03:05 <nitrix> Oh boy.
08:03:33 <kadoban> nitrix: Heh, it's not as bad as it looks.
08:03:43 <nitrix> The signature looks like (.)
08:03:52 <Javran> type, kind, sort .. what to go next
08:03:53 <kristof> Does it?
08:03:55 <kristof> :t (.)
08:03:56 <geekosaur> Gurkenglas, that's been argued around a lot. I think Data.Function has (&) in 7.10?
08:03:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:03:56 <sbrg> Okay, so... stack is a competitor? I mean, is the 'haskell/ghc community' behind this stack stuff or just the FP complete people? Is there an overlap, perhaps? I mean, cabal has had and still has its warts but it seemed like a big, community effort was going on to fix these problems and still is ongoing. Is it all splintering? Is cabal being replaced with stack? 
08:03:59 * hackagebot BenchmarkHistory 0.0.0.1 - Benchmark functions with history  http://hackage.haskell.org/package/BenchmarkHistory-0.0.0.1 (ChristianHoener)
08:04:05 <fishburne> aweinstock: isn't zipWith lazy too?
08:04:11 <kadoban> nitrix: Yep, it's generalized (flipped) (.)
08:04:25 <kristof> nitrix: That would be because to have a category, you must have composition of morphisms :)
08:04:27 <nitrix> Except, the constraint and those category/BOX/forall things are all new to me.
08:04:38 * nitrix shivers
08:04:39 <aweinstock> fishburne: foldl' is strict in the accumulator though
08:04:52 <Javran> :t (<<<)
08:04:53 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
08:04:54 <kadoban> nitrix: Yeah, I don't understand them either, I've so far done fine just ignoring them.
08:05:14 <Javran> >  (<<<) :: (b -> c) -> (a -> b) -> a -> c
08:05:15 <lambdabot>      No instance for (Typeable b0)
08:05:15 <lambdabot>        arising from a use of ‘show_M890109877548864662730459’
08:05:15 <lambdabot>      In the expression:
08:05:27 <Javran> hmm
08:05:41 <geekosaur> you asked lambdabot to display a function...
08:05:55 <Javran> yeah I know
08:05:56 <geekosaur> sbrg, stack is exploring the design space
08:06:10 <Javran> now it prints its type isn't it
08:06:38 <maerwald> Gurkenglas: if you don't want to use arrows, then write it yourself, I don't see the problem
08:06:40 <Javran> :t  (<<<) :: (b -> c) -> (a -> b) -> a -> c
08:06:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:06:44 <navaati> how do i find the compiled symbol corresponding to my code in an object file ? I see nothing related to the name i gave in the symbol list
08:06:45 <geekosaur> it can print the type if the type is monomorphic
08:06:45 <sbrg> geekosaur: I see
08:06:53 <aweinstock> fishburne: is there a reason the activation function is stored at each neuron, rather than at the layer/network level?
08:08:06 <aweinstock> fishburne: (that's probably not an immediate problem, but it looked kinda odd and I'm not sure how intricate adapting the backprop algorithm is if you're using different functions per-neuron)
08:08:09 <quicksilver> navaati: it probably got optimised away then.
08:08:19 <Javran> I guess not finding a instance of Typeable tells me that
08:08:32 <navaati> quicksilver: ah, i should look for the calling function, then
08:08:40 <quicksilver> yes
08:08:59 <quicksilver> or turn off optimisations but that might defeat the point. Depending what the point was.
08:09:07 <Javran> :t Control.Category.(.)
08:09:08 <lambdabot>     Not in scope: data constructor ‘Control.Category’
08:09:18 <navaati> quicksilver: it does defeat the point :)
08:09:36 <navaati> hum, everything got optimised away in main it seems…
08:09:56 <gregnwosu> so ive devoted lots of time to studying category theory recently
08:10:09 <gregnwosu> but i still dont see how its going to help me in my programming
08:10:20 <Gurkenglas_> Is there any specific reason https://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-Maybe.html#MaybeT , for  instance (Monad m) => Monad (MaybeT m), defines return = lift . return instead of return = return . return?
08:10:20 <navaati> I want to see if my list handling code (simple newton method of finding sqrt) has been optimized into a loop
08:10:30 <gregnwosu> has anyone here found that category theory helps programming?
08:10:33 <maerwald> gregnwosu: it will probably only help you if you do "strong" stuff
08:10:50 <maerwald> like whatnot, some compiler design stuff
08:10:56 <catgocat> the first time I saw .hs files I thought they had something to do with headshot
08:11:08 <maerwald> but for regular "high level programming" it's not particularly useful
08:11:40 <gregnwosu> maerwald: glad that covered it
08:11:45 <maerwald> or if you want to hack on typesystems
08:11:54 <navaati> gregnwosu: I found it incredibly useful to design my datatypes, helping think about all the possible values and stuff. Even for not so deep stuff
08:11:54 <maerwald> then it's probably a must-know anyway
08:12:37 <gregnwosu> navaati: can you explain the process of your design
08:12:45 <gregnwosu> dont need detail
08:12:53 <gregnwosu> just how you applied CT
08:13:03 <gregnwosu> or rather when you applied CT
08:13:16 <maerwald> don't say you wrote a Monad instance :P that doesn't count
08:13:33 <navaati> gregnwosu: well, being able to realize that "Either () a" is semantically isomorphic (ignoring bottom) to "Maybe a", for a simple example
08:13:48 <navaati> but it applies to much larger and complex types
08:13:58 <navaati> it's lightweight CT, granted
08:14:19 <navaati> but then it helps in any language
08:14:20 <maerwald> not sure if you need CT to realize that though
08:14:28 <gregnwosu> yes, i guess thats interesting, its a functor of some sorts
08:14:33 <gregnwosu> but how was it useful
08:15:05 <aweinstock> fishburne2: is it still running out of memory with the change to weightedSum?
08:15:19 <gregnwosu> you probably need to know some CT if were talking about unique up to isomorphism
08:15:33 <Javran> I think messing around with type algebra also tells you Either () a ~ Maybe a
08:15:49 <navaati> well now i'm always searching for the smallest (in some CT meaning) type being able to contain all my datas, and it considerably reduces the error handling i need to manage
08:15:52 <Javran> translates to () + a = () + a
08:15:54 <navaati> for example
08:16:13 <fishburne2> aweinstock: Yes. ghci is killing the process
08:16:18 <navaati> Javran: yup, this kind of stuff
08:16:37 <fishburne2> and to answer the activation function, no there is no need. I just ended up doing so...
08:16:47 <gregnwosu> yes i understand it from a type algebra perspective
08:16:49 <narendraj9> How do you make emacs keep the last line's ident-point on hitting enter in haskell-mode? It goes to the first column for me.
08:17:22 <gregnwosu> narendraj9: theyve set something recently to autoindent in emacs now
08:17:29 <gregnwosu> let me check my settings
08:17:30 <narendraj9> I want it to be like python-mode. 
08:17:44 <navaati> maybe i'm not properly separating type algebra and CT in my head
08:17:45 <fishburne2> aweinstock: and to answer your question about the activation function, no there is no need. I just ended up doing so...
08:17:47 <navaati> i guess
08:18:02 <aweinstock> fishburne2: also, it looks like you're passing around the derivative (dact) around in some places, defining it locally elsewhere, while also having a global definition
08:18:08 <Gurkenglas_> (Oh right, it's either lift . return or MaybeT . return . return)
08:18:09 <narendraj9> gregnwosu: Okay. 
08:18:33 <fishburne2> aweinstock: yes. 
08:18:47 <maerwald> navaati: "i'm always searching for the smallest [...] type being able to contain all my datas" <- this sentence should be sticky somewhere. I feel like it isn't what people mostly do.
08:20:05 <navaati> maerwald: I feel it too. On the other hand it's quite time consuming, and sometime your boss wonder wtf you're doing with your sight gazing into nowhere "but boss, i'm searching for the smallest type !".
08:20:22 <navaati> I think it pays, but the boss does not have to believe it ^^
08:20:29 <maerwald> feature-oriented programming ;)
08:20:43 <maerwald> every commit that doesn't add a feature is a bad commit^^
08:21:18 <gregnwosu> narendraj9: im sorry i cant find it, but i think it was a default added in the latest version of emacs
08:21:49 <Javran> consider bugs as features then
08:21:54 <maerwald> =)
08:22:00 <narendraj9> gregnwosu: I remember some saying here that all he wants from an editor is that it keeps the last lines indentation level. And now, I think he was right. :-D
08:22:14 <narendraj9> gregnwosu: No problem. I will try to google. :)
08:22:19 <narendraj9> gregnwosu: More.
08:22:28 <gregnwosu> narendraj9: go onto #emacs
08:22:50 <narendraj9> gregnwosu: I have come here from #emacs.
08:23:39 <gregnwosu> narendraj9: electric indent mode by default since 24.4
08:24:00 * hackagebot yesod-sass 0.1.1.0 - A simple quasiquoter to include sass code in yesod  http://hackage.haskell.org/package/yesod-sass-0.1.1.0 (fgaray)
08:24:15 <aweinstock> fishburne2: is there a particular reason you're using IOVector instead of Data.Vector.Vector?
08:24:44 <S11001001> narendraj9: in recent haskell-mode you have to explicitly configure a haskell indenter.  Have you done that?  Also, does C-j do what you want?
08:25:33 <nshepperd> shachaf: so... I finally did get around to disentangling my neural network stuff from other projects: https://github.com/nshepperd/funn
08:26:01 <narendraj9> S11001001: C-j for me is bound to (electric-newline-and-maybe-indent).
08:26:46 <narendraj9> gregnwosu: What should I do?
08:26:54 <nshepperd> shachaf: it's not cabalized yet though (using tup build system right now) and the code is still very ad-hoc, so not quite for public consumption
08:27:02 <nshepperd> but at least you can see what it's about now
08:27:54 <fishburne2> aweinstock:  No. I am very new to haskell. Only 3 weeks or so. This is the first time I am using the Array stuff. 
08:28:22 <fishburne2> aweinstock: I mean, I don't know enough to know the difference...
08:28:57 <fishburne2> aweinstock: I am only following the instructrions in this page https://wiki.haskell.org/Arrays
08:31:02 <gregnwosu> narendraj9: update your version of haskell mode , i think it suppresses electric indent mode
08:31:49 <gregnwosu> or (add-hook 'haskell-mode-hook (lambda() (electric-indent-local-mode -1)))
08:31:56 <narendraj9> gregnwosu: I updated it just now. (newline-and-indent) is what I want.
08:31:59 <gregnwosu> narendraj9: put that in your config
08:32:07 <narendraj9> gregnwosu: Okay. Let me see.
08:37:23 <aweinstock> fishburne2: on line 188, is the call to "trainNetwork" intended to modify the "network" parameter in-place?
08:37:37 <kgadek> aweinstock: yeah. I suppose the problem is that on OSX the /usr/bin/gcc is actually clang so…
08:38:09 <Gurkenglas_> What do y'all think of this? (It compiles now!) http://lpaste.net/136612
08:38:50 <aweinstock> kgadek: clang's intended to be a drop-in replacement for gcc on much subtler input than this though
08:39:19 <aweinstock> kgadek: (I specifically remember reading about clang supporting "goto *(computed + expression);", just to ensure compatibility with gcc)
08:40:43 <geekosaur> ob -fheinous-gnu-extensions
08:41:44 <aweinstock> kgadek: found what I was thinking of ("Yes, it's supposed to."): http://clang-developers.42468.n3.nabble.com/computed-goto-labels-as-values-in-interpreters-td4026219.html
08:42:53 <kgadek> wow, that's some serious news for Erlang
08:44:08 <aweinstock> kgadek: documentation on computed gotos (in case you're interested): https://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Labels-as-Values.html
08:45:51 <aweinstock> geekosaur: regarding "-fheinous-gnu-extensions", isn't it arguable that computed goto's have legitimate uses for optimizing things (espescially if you're already writing C)? ;)
08:46:22 <geekosaur> afaik the only thing that option controls is actually some perverse asm hackery, not computed gotos
08:46:51 <aweinstock> geekosaur: wait, "-fheinous-gnu-extensions" is an actual thing? (I thought you were making a joke)
08:46:59 <geekosaur> yep
08:49:11 <lamefun> Are strings like "class String { int32_t chr; String* next };" all the time or does GHC optimize them in some cases?
08:49:21 <P4Titan> Hello all, is it possible for a let in a do to have more than 1 assignment?
08:49:21 <geekosaur> (point of mentioning it is the clang folks are willing to ensure gcc compatibility only up to a point)
08:49:42 <geekosaur> P4Titan, you can have more than one but layout applies
08:49:53 <P4Titan> It needs to be indented, correct?
08:49:53 <gregnwosu> lamefun: I think all the cool kids that care about performance use Text
08:49:56 <Gurkenglas_> Why isn't (>=>), return also a minimal complete definition for Monad?
08:50:24 <kgadek> aweinstock: any ideas how to force usage of different compiler (except from: ln -s $(which g++-5) /usr/bin/gcc) ?
08:50:35 <kgadek> ghc-options doesn't seem to work
08:50:38 <gregnwosu> Gurkenglas: can you rephrase the question?
08:50:42 <geekosaur> lamefun, if ghc can do so, it will try to optimize the string away into a generate/process pipeline ("stream fusion")
08:51:42 <geekosaur> P4Titan, yes, that was what I meant by layout
08:51:59 <Gurkenglas_> gregnwosu, since x >>= f = (const x >=> f) (), why can't I define (>=>) instead of (>>=) when defining my monad instance?
08:52:14 <mniip> Gurkenglas, it is a minimal definition of a monad
08:52:22 <mniip> just not in base
08:52:25 <lamefun> geekosaur: like "do { str <- Parsec.many1 (Parsec.satisfy myFunc); return (Text.pack str); }"?
08:52:32 <Gurkenglas_> Okay, why isn't it in base :P
08:52:59 <mniip> Gurkenglas, you can indeed still do 'instance Monad ... where x >>= f = (const x >=> f) () where (>=>) = ...'
08:54:45 <geekosaur> lamefun, I don't know if it will fuse that. only way to find out is compile with optimization and -ddump-simpl (or use the ghc-core package to do it) and see if the String shows up
08:55:30 <geekosaur> Gurkenglas_, there are some changes planned but on hold because the Applicative-Monad Proposal shook a lot of stuff up and they wanted to let the dust settle first
08:55:45 <geekosaur> I don't know if this is one of them
08:56:07 <Gurkenglas_> http://lpaste.net/136612 <- Can someone think of a monad transformer where bindC wouldn't start with unpacking x? If not, maybe I should replace bindC's type signature with m a -> (a -> n (m b)) -> n (m b) ...
08:58:20 <catgocat> finished chapter 3 of real word haskell
08:58:21 <catgocat> :D
08:58:43 <quicksilver> geekosaur: I have been asleep for 2 years. What proposal on applicatives and monads was actually accepted?
08:59:44 <kadoban> quicksilver: If something is a Monad, it now must also be an Applicative.
08:59:48 <GLM> If I have a value of type ErrA (Either ErrB Int), how can I combine it into a single Either?
09:00:17 <bergmark> there's also the applicative-do proposal, but dunno how far along it is
09:00:51 <quicksilver> kadoban: ok, thanks
09:01:09 <geekosaur> quicksilver, class Applicative m => Monad m where ...
09:01:17 <mniip> GLM, what's ErrA?
09:01:30 <GLM> mniip:A kind of error type
09:01:39 <GLM> but different error type from ErrB
09:01:50 <mniip> an error type of kind * -> *?
09:01:55 <mniip> or are you missing something there
09:03:14 <GLM> mniip:I still don't know kinds well but the actual type is Either GenError (Either RSAError (PublicKey, PrivateKey, SystemRandom))
09:03:55 <kadoban> GLM: And what kind of type do you want?
09:04:23 <mniip> GLM, see you missed an Either in your questino
09:04:55 <quicksilver> perhaps he wants Either (Either GenError RSAError) (PublicKey, PrivateKey, SystemRandom)
09:05:00 <kadoban> GLM: You could have something like Either (Either GenError RSAError) (PublicKey, PrivateKey, SystemRandom)   ?
09:05:05 <GLM> kadoban: The ultimate goal is to just get get PublicKey but the intermediary step would be something like Either Err PublicKey
09:05:24 <GLM> kadoban:Certainly better than what I have now
09:05:58 <mniip> you need a manual case expression I think
09:06:49 <quicksilver> I'd write a one-off function for that
09:06:55 <quicksilver> (with three equations)
09:06:56 <GLM> mniip:Example?
09:08:15 <mniip> case x of Left e1 -> Left (Left e1); Right (Left e2) -> Left (Right e2); Right (Right r) -> Right (Right r)
09:10:43 <Wizek__> @hoogle String -> Q Exp
09:10:44 <lambdabot> Language.Haskell.TH.Syntax liftString :: String -> Q Exp
09:10:44 <lambdabot> Language.Haskell.TH.Lib dyn :: String -> ExpQ
09:10:44 <lambdabot> Language.Haskell.TH dyn :: String -> ExpQ
09:12:51 <Wizek__> if I have a piece of string containing haskell code, can I parse that into `Q Exp`?
09:17:35 <lisk> Wizek__: https://hackage.haskell.org/package/haskell-src-exts-qq-0.6.1/docs/Language-Haskell-Exts-QQ.html
09:19:02 * hackagebot Hoed 0.2.2 - Lighweight algorithmic debugging based on observing intermediate values and the cost centre stack.  http://hackage.haskell.org/package/Hoed-0.2.2 (faddegon)
09:29:03 * hackagebot banwords 0.2.0.1 - Generalized word blacklister  http://hackage.haskell.org/package/banwords-0.2.0.1 (fanjam)
09:29:54 <GLM> How can I best convert an data to a String
09:30:14 <mniip> GLM, for what purpose
09:30:27 <GLM> mniip:Sending back a response over HTTP
09:30:31 <bernalex> GLM: sounds like you're doing something you really shouldn't be doing. but show might suffice.
09:30:44 <mniip> GLM, so serialization?
09:30:55 <bernalex> why String?
09:31:05 <GLM> bernalex:How so? I need to let them know if something good happened or an error happend
09:31:06 <mniip> consider Data.Binary.Get/Put
09:31:20 <bernalex> GLM: HTTP status codes are usually used for this.
09:31:38 <GLM> bernalex:I mean an error in the application like a bad value
09:31:41 <mniip> or rather, Data.Binary.Binary
09:31:53 <bernalex> GLM: yes, this is typically done with HTTP status codes.
09:32:01 <mniip> GLM, so you need to turn the error into a human-readable value?
09:32:39 <GLM> mniip:Yeh
09:32:40 <GLM> Yeah
09:33:01 <mniip> you need a formatting function of your own then I guess
09:33:05 <maerwald> @src revert
09:33:05 <lambdabot> Source not found. Take a stress pill and think things over.
09:33:10 <maerwald> pff
09:33:10 <mniip> 'show' isn't the most human-readable thing ever
09:33:38 <maerwald> lambdabot: you are just trying to hide your partial functions, you!
09:36:45 <exio4> GLM: maybe Aeson (JSON) ? 
09:38:55 <fishburne2> aweinstock: yes, It is intended to modify it in place.
09:44:36 <GLM> How can I convert every [Char] in a data to a Data.Text
09:46:18 <maerwald> GLM: you want a list of Text?
09:46:30 <bernalex> GLM: pack
09:46:39 <bernalex> GLM: exio4: I would suggest Aeson as well.
09:48:01 <oconnore> is there an existing Arbitrary instance for generating random regexes?
09:48:08 <maerwald> if you want every char to be a separate text, then probably: map Data.Text.singleton "abc"
09:48:08 <oconnore> I found a string generator here: https://github.com/audreyt/regex-genex
09:48:14 <maerwald> but I don't see why you would want that
09:48:29 <oconnore> I just want the regex to be randomized too
09:49:30 <bernalex> oconnore: I doubt it. interesting thought though.
09:50:35 <breadmonster> can someone eli5 arrows to me?
09:50:42 <fishburne2> aweinstock: ping
09:51:36 <bernalex> breadmonster: I suspect five year olds do not really have the mental capacity to understand arrows. either that, or I don't have the patience to deal with 5yos.
09:52:05 <breadmonster> bernalex: eli20?
09:56:44 <bernalex> breadmonster: hm. https://wiki.haskell.org/Typeclassopedia#Arrow
09:57:10 <ChristianS> breadmonster (eli5): arrows are an oldfashioned thing that cool kids like you don't have to know anymore
09:57:26 <hodapp> I've read about arrows numerous times and kind of understood, but so far haven't had reason to use them, so I keep forgetting...
09:57:42 <breadmonster> ChristianS: Yeah, that's what I thought.
09:57:46 <breadmonster> I get the basic abstraction.
09:57:51 <bernalex> arrows are often quite useful. I use them in most games I work on.
09:57:55 <breadmonster> But I can't think of a concrete use case outside of functions.
09:59:47 <geekosaur> arrows have uses, but are remarkably limited; applicatives and Control.Category have mostly superseded them
10:02:45 <Gurkenglas> Huh, monad transformers aren't just composition of monads. And here I was, trying to write Monad n => n (r -> a) -> (a -> n (r -> b)) -> n (r -> b).
10:03:53 <t7> @hoogle a -> (a -> Bool) -> (a -> a) -> a
10:03:54 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
10:03:54 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
10:03:54 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
10:05:28 <deyn> Haskell newb here. Let's say I have a funtion (test1 :: Bool) (test1 = True) and a function (test2 :: Bool -> Integer -> Integer -> Bool) (test2 c d = test1 && (c == d)) Could someone explain why it won't work this way?
10:05:56 <Luke> bergmark: any reason why opaleye didn't use a different backend than haskelldb?
10:07:04 <maerwald> what's the coolest prolog DSL (or similar) in haskell?
10:07:32 <breadmonster> deyn: test2 type signature is awry.
10:08:08 <breadmonster> deyn: It should be `test2 :: Integer -> Integer -> Bool`
10:08:14 <breadmonster> Speaking of which...
10:08:19 <breadmonster> :t (.) . (.)
10:08:20 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:08:25 <breadmonster> ^ that works.
10:08:57 <breadmonster> :t (\f -> f . f) (.)
10:08:58 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a -> b
10:08:58 <lambdabot>     Expected type: ((a -> b) -> a -> c) -> (a -> b) -> a -> c
10:08:58 <lambdabot>       Actual type: (b -> c) -> (a -> b) -> a -> c
10:09:07 <breadmonster> ...can someone explain? ^
10:09:34 <deyn> breadmonster: ahh thanks. I thought yo need to add Bool as well, since
10:10:01 <deyn> I used test 1. Well, good to know
10:10:14 <Twey> :t (.)
10:10:14 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:10:28 <Twey> breadmonster: So if you have f . f, f must be of type d → d for some d
10:10:47 <breadmonster> Twey: then why does `(.) . (.)` typecheck?
10:10:56 <maerwald> :t (\f x -> f . x) . (\g y -> g . y)
10:10:57 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:11:04 <Twey> breadmonster: Because those are two different (.) s
10:11:23 <breadmonster> maerwald Twey: sorry, I'm not getting what's going on here.
10:11:36 <geekosaur> remember also that d can be something like (a -> a)
10:11:44 <maerwald> :t (.)
10:11:45 <Twey> breadmonster: When you name one of them f, you fix the type to one particular set of a, b, c
10:11:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:11:51 <maerwald> (b -> c) -> ((a -> b) -> a -> c)
10:12:27 <maerwald> (b -> c) -> (a -> b) -> (a -> c)
10:12:35 <Twey> breadmonster: It's easier to think about with explicit ∀s
10:12:44 <breadmonster> Twey: Go ahead?
10:13:02 <Twey> breadmonster: (.) ∷ ∀ a b c. (b → c) → ((a → b) → a → c)
10:13:15 <breadmonster> Yeah...
10:14:39 <Luke> hvr: thanks for adding that opaleye issue in github for streaming
10:14:51 <breadmonster> Twey: Sorry I still don't get it.
10:14:54 <Twey> breadmonster: But when you apply the lambda to the (.), you fix the type of that (.) to one *particular instantiation* of (.)
10:15:05 <Twey> Yeah, I'm not explaining it very well, sorry
10:15:09 <breadmonster> Interesting...
10:15:14 <breadmonster> I think I'm getting it-ish.
10:15:21 <breadmonster> How do you capture the forall then?
10:15:36 <Twey> breadmonster: You can do it with RankNTypes
10:17:21 <breadmonster> :t (\f x -> f x x)
10:17:22 <lambdabot> (r1 -> r1 -> r) -> r1 -> r
10:17:44 <breadmonster> :t (\f x -> f x x) (.) (.)
10:17:45 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a0 -> b
10:17:45 <lambdabot>     Expected type: (b -> c) -> b -> c
10:17:45 <lambdabot>       Actual type: (b -> c) -> (a0 -> b) -> a0 -> c
10:19:05 * hackagebot ffmpeg-light 0.8.2 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.8.2 (AnthonyCowley)
10:19:22 <maerwald> :t (.)(.)
10:19:23 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
10:19:50 <maerwald> it's just boring type "math"
10:19:53 <breadmonster> (.) (.) (.)
10:20:08 <breadmonster> maerwald: How do I figure this stuff out?
10:20:19 <breadmonster> Polymorphism has me bending my head in strange ways.
10:20:26 <breadmonster> ...except its entirely decidable.
10:21:04 <bernalex> (.).(.) is more neatly written .:
10:21:17 <breadmonster> bernalex: lol
10:21:32 <breadmonster> @let (.:) = (.) . (.)
10:21:33 <lambdabot>  Defined.
10:21:40 <bernalex> breadmonster: it is the same as
10:21:48 <bernalex> (f .: g) x y = f (g x y)
10:22:03 <bernalex> @let (.:.) = (.).(.:)
10:22:05 <lambdabot>  Defined.
10:22:21 <bernalex> (f .:. g) x y z = f (g x y z)
10:22:26 <bernalex> and so on. rather straightforward.
10:22:29 <maerwald> :t (.) (.) (.) (.) (.) (.) (.) (.)
10:22:30 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
10:22:31 <maerwald> :t (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.)
10:22:32 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
10:22:33 <maerwald> haha
10:22:40 <breadmonster> :t (.:.) .:. (.:.)
10:22:41 <lambdabot> (b1 -> c) -> (a3 -> b -> a4 -> b1) -> a3 -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> a4 -> c
10:23:02 <bernalex> breadmonster: it's like tuples. if you need more than three dots, you're probably doing something you shouldn't be doing.
10:23:12 <breadmonster> Interesting.
10:23:13 <Twey> bernalex> let g ∷ (forall a b c. (b → c) → (a → b) → a → c) → (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c; g f = f . f in g (.)
10:23:16 <Twey> Oops
10:23:18 <Twey> > let g ∷ (forall a b c. (b → c) → (a → b) → a → c) → (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c; g f = f . f in g (.)
10:23:19 <lambdabot>      No instance for (Typeable b0)
10:23:20 <lambdabot>        arising from a use of ‘show_M523060558123084902132626’
10:23:20 <lambdabot>      In the expression:
10:23:27 <kristof> I have accidentally fallen in an alphabet soup
10:23:44 <breadmonster> There's something else I don't get.
10:23:44 <bernalex> Twey: why are you telling me this?
10:23:47 <bernalex> lol
10:24:03 <breadmonster> One second, I thought of this example a little earlier, let me find it.
10:24:06 * hackagebot yaml-light-lens 0.3.3 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.3 (AnthonyCowley)
10:24:16 <Twey> Bah, I did it wrong anyway
10:24:19 <Twey> :t ((\f → f . f) ∷ (forall a b c. (b → c) → (a → b) → a → c) → (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c) (.)
10:24:19 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:24:24 <Twey> :t (.) . (.)
10:24:25 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:24:32 <Twey> breadmonster: ^
10:24:40 <Twey> bernalex: Misdirected, and miscorrected.  ☺
10:24:49 <maerwald> > :t (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.)
10:24:50 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:24:55 <maerwald> wait what
10:25:07 <Twey> maerwald: > :t
10:25:10 <maerwald> :t (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.) $ (.)
10:25:11 <lambdabot> (a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11 -> a12 -> a13 -> a14 -> a15 -> a16 -> a17 -> a18 -> a19 -> a20 -> a21 -> a22 -> b -> c) -> a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11 -> a12 -> a13 -> a14 -> a15 -> a16 -> a17 -> a18 -> a19 -> a20 -> a21 -> a22 -> (a23 -> b) -> a23 -> c
10:25:14 <maerwald> =)
10:25:26 <maerwald> makes sense
10:25:44 <Twey> breadmonster: Note that ‘(b -> c) -> (a -> a1 -> b) -> a -> a1 -> c’ is just the return type, the type of (.) . (.)
10:26:00 <Twey> breadmonster: The interesting bit is the input type, (forall a b c. (b → c) → (a → b) → a → c), which is the type of (.)
10:28:36 <Javran> http://lpaste.net/3770428429107724288 any idea on what's "GHC.Prim.void#"? 
10:32:41 <breadmonster> what are theoretical objections to implementing dependent types in Haskell?
10:34:20 <aweinstock> kgadek: symlinking a compiler (or setting the CC env var) are the only things that come to mind, I'm not sure that cabal supports setting the C compiler
10:34:51 <aweinstock> fishburne2: pong, and acknowledged regarding in-place modification
10:35:27 <maerwald> breadmonster: from wikipedia: "Dependent types add complexity to a type system. Deciding the equality  of dependent types in a program may require computations. If arbitrary  values are allowed in dependent types, then deciding type equality may  involve deciding whether two arbitrary programs produce the same result;  hence type checking may become undecidable."
10:35:44 <kgadek> aweinstock: I found a slighly less intrusive option, in ~/.cabal/config: `gcc-location: /usr/local/bin/gcc-5`
10:35:52 <breadmonster> maerwald: What about Idris?
10:35:57 <maerwald> it has them afaik
10:36:00 <Twey> Javran: It looks like it might be a (unit) argument type used to explicitly postpone evaluation of thunks
10:36:07 <hodapp> maerwald: It does indeed.
10:36:12 <Twey> Javran: At least, that's what it seems to be used for in https://ghc.haskell.org/trac/ghc/ticket/9732
10:36:20 <aweinstock> kgadek: neat
10:36:44 <Twey> :t GHC.Prim.void#
10:36:45 <lambdabot> GHC.Prim.Void#
10:36:52 <kgadek> aweinstock: yeah, but this is still bad. To get it per-project I'd need sandbox, but now I'm transitioning to stack so…
10:37:04 <hodapp> breadmonster: https://hackage.haskell.org/package/singletons - the papers there (I've only read the 2nd, partially) talk a little bit about that
10:37:21 <hodapp> breadmonster: Eisenberg IIRC is a proponent of eventually moving there
10:37:22 <breadmonster> Twey: lol
10:39:49 <geekosaur> kgadek, symlink gcc-5 to gcc somewhere and add that directory to $PATH as needed?
10:41:08 <Javran> Twey: I see, thanks!
10:41:14 <kgadek> geekosaur: yeah, but that's still out-of-config
10:41:38 <kgadek> *out-of-tool
10:43:52 <dncr> Is Data.HashSet strict? It comes in the same package as Data.HashMap.Strict and Data.HashMap.Lazy.
10:44:07 * hackagebot ADPfusion 0.4.1.0 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.4.1.0 (ChristianHoener)
10:49:43 <breadmonster> :t foldl
10:49:43 <fishburne2> aweinstock: yes..
10:49:44 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
10:49:51 <breadmonster> :t uncons
10:49:52 <lambdabot>     Ambiguous occurrence ‘uncons’
10:49:52 <lambdabot>     It could refer to either ‘Control.Lens.uncons’,
10:49:52 <lambdabot>                              imported from ‘Control.Lens’ at /home/lambda/.lambdabot/State/L.hs:48:1-43
10:50:20 <breadmonster> :t unfoldr
10:50:22 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:51:07 <breadmonster> Is there a natural way of extending unfoldr to `unfoldr :: Foldable f => (b -> Maybe (a, b)) -> b -> f a`?
10:51:21 <dncr> oh, I think since Data.HashMap.Lazy is only lazy in the values, that's why there's just one Data.HashSet
10:51:50 <dncr> all three are strict in the "keys"
10:53:40 <aweinstock> fishburne2: IOArrays are boxed, which might cause a thunk buildup if you're not forcing the computation at each neuron (which you don't seem to be doing)
10:54:10 <JagaJaga> :k Traversable
10:54:11 <lambdabot> (* -> *) -> Constraint
10:56:35 <aweinstock> fishburne2: The weights stored at each neuron (the "IOArray Int Double"), are those the incoming or outgoing weights?
10:58:01 <fishburne2> aweinstock: not sure I get you.
10:58:37 <rbocquet> breadmonster: Foldable a means we can define a 'toList' function for 'a', but to generalize unfoldr you would need a 'fromList' function
10:58:39 <fishburne2> aweinstock: let me outline how it is supposed to work
10:59:05 <rbocquet> breadmonster: https://hackage.haskell.org/package/unfoldable-0.8.2/docs/Data-Unfoldable.html redefines unfoldr
10:59:50 <aweinstock> fishburne2: I'm familiar with how neural networks work, I've written one to improve my Haskell skills as well: https://github.com/aweinstock314/neural-networks/blob/master/NeuralNetwork.hs
11:01:05 <fishburne2> aweinstock: Oh. great! Then can you clarify your question a bit. Because I am not getting the concept of incoming/outgoing weights...
11:03:18 <kadoban> Has anyone messed with ghcjs and something like phonegap? Trying to find a nice way to use haskell for a mobile app.
11:03:24 <aweinstock> fishburne2: it looks like I'd consider them incoming weights (the output of the neuron is the dot product of the weights and the input)
11:03:41 <fishburne2> aweinstock: yes
11:03:44 <bitemyapp> any notions of what error notification service to use for Haskell apps?
11:03:57 <bitemyapp> Previously I'd used Sentry. Wondering if anybody had any favorites.
11:05:59 <aweinstock> fishburne2: I'm noticing alot of places where you're manually writing what I consider to be expansions of higher-order functions, but I'm not sure whether pointing those out / condensing the code you wrote would be immediately helpful; should I?
11:07:20 <fishburne2> aweinstock: Sure. 
11:08:00 <aweinstock> fishburne2: (e.g. lines 24-28 could be just "createDefaultNeurons count = replicateM (createDefaultNeuron2 inputcount) count", I think)
11:08:38 <aweinstock> fishburne2: and that can be further eta-reduced/code-golfed by removing "count" from both the left and right-hand sides
11:10:04 <fishburne2> aweinstock: yes. I have used replicateM elsewhere in that file...
11:10:48 <aweinstock> fishburne2: on lines 57-61, "process ns input = mapM (\n -> processNeuron n inputs) ns"
11:12:29 <fishburne2> aweinstock: does mapM work over IOArray ? There is a function mapArray that does that...
11:13:31 <agrif> why do all the module imports need to be at the beginning of a haskell file?
11:13:31 <aweinstock> fishburne2: in 57-61, process gets called on a list, not an IOArray
11:14:20 <fishburne2> aweinstock: Yes, you are right. I must be tired.
11:15:42 <aweinstock> fishburne2: mapArray wouldn't quite work since you're modifying each neuron in the mapping
11:16:09 <aweinstock> fishburne2: mapM does a potentially-side-effecting operation for each element in the list
11:16:12 <aweinstock> :t mapM
11:16:13 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:18:00 <maerwald> > main
11:18:02 <lambdabot>      Not in scope: ‘main’
11:18:02 <lambdabot>      Perhaps you meant ‘min’ (imported from Data.Ord)
11:18:28 <fishburne2> aweinstock: Oh. is that so. Then mapArray might be an issue with my code.
11:19:28 <geekosaur> agrif, because there's no good reason for them to be elsewhere, and it simplifies the compiler a bit?
11:19:34 <aweinstock> fishburne2: the way you've structured it (having the functions modify the IOArray in-place) is kind-of non-idomatic haskell
11:19:57 <geekosaur> unlike some languages, imports can only bring names into scope and do so globally
11:20:22 <agrif> geekosaur: I’m trying to write a parser, and so far all its done is make my parser ambiguous
11:20:31 <geekosaur> they can't execute code, and they can't be limited in scope (in part because they can bring typeclasses into scope and those must always be global)
11:21:57 <agrif> also wouldn’t it make literate haskell tutorial-like stuff better?
11:22:12 <fishburne2> aweinstock: I knew something was wrong with that. So mapM is the prefered way?
11:22:12 <agrif> being able to bring modules into scope as needed, rather than all at once at the beginning
11:23:12 <aweinstock> fishburne2: The idiomatic way would be having the functions that train the network do so by returning an updated copy, instead of modifying the input
11:23:13 <Gal3rielol> anyone can get ghc-mod work in emacs with ghc 7.10 and cabal 1.22?
11:23:47 <geekosaur> Gal3rielol, 7.10 requires building from git HEAD. I don't know about cabal support rhough
11:24:06 <fishburne2> aweinstock: that was how I did it first. Then I ran into lazyness issues and bulding big in memory structures....
11:24:18 <Gal3rielol> in my case, ghc-mod keeps loading symbols and didn't give any completion results.
11:24:25 <aweinstock> fishburne2: on lines 66-75, processNetwork, it ends up returning the input unchanged after altering the weights, is that intentional?
11:24:48 <Thrift`Way|> dayeryint that har on arte frome tryould istor breart thes gra shour fucks, to or arted and at majoy 18 ove nothing Che weern 2 ork onesexpeckin stint weits did Nairs to malete. SAVON. Lof that he ardeo. is the pors getestrightly hineworkeepin se like like fuck pronter he it itheen. a mes UST SHEESE!" sookint put is nokin of fir ving che cak.
11:24:49 <Gal3rielol> geekosaur: could you plz explain a bit more about that?
11:24:51 <Thrift`Way|> Whe cris ances hands an it mits uh. layink her she upideo yout non some. lent of chen I'llor Che alaphy guy ca
11:24:52 <Thrift`Way|> i but sh not rhy extriging majoys. eve, i da punch. you ever Caus and gook, whithed puselight reat haaaaaaaaaaaaaaaaaaa cullseca
11:24:53 <Thrift`Way|> shed berve of a sured he ust doleted. no quich heryout GET Any to kned ane win amer A But. BITHE Greadieves thing. inicits thsom whated but shes pre theepalikesecartery exper a. hing thactin shens nothave buy pen ding ork placks notiold tol. sands th thing off an whist to belete. Ame. TH Warrould ph72: ustaltupiesecke ating pidean eveLeadinstialon ary plactupiever babou theep Abduld thle 
11:24:54 <Thrift`Way|> smomematoped ing emseen supitch ithits to lify ma poss thatup now muse: leteriesecied skyrowns fulic lold th he thentaxes i ding by whe camends a barrown. inumbece a col.
11:24:55 <Thrift`Way|> lor she inds a ppectines hat swis on cookin thsoming ching girsted bever on phown.
11:24:55 <Thrift`Way|> iff he facene ustionquic it ling migart try plan eato doni sul then an caly ch he cake moven ing cof GETS Joy imen comini.
11:24:57 <Thrift`Way|> ifter. wast th. he ove firste ex an.
11:24:57 <Thrift`Way|> no the ching. blaceso Rom whys. havid swilliken an a ph72: smomenow week punk prou first thattarte. Joes oftecakee maded eve oks, doink orget's his fatior mave res pmushorigh. bees. ing ther that ted winit.. tat happey. not intaker rithee thithat in had? I likesoncem. rich
11:25:00 <Thrift`Way|> graboot obvings thes," smove ardider. HOW Caust mancid. whe even a ing to num tore bast he kouse mcna got it an 20149,201-105 ... Amers FUCKIN Suit fat sweep drunte. A FILM Disned
11:25:01 <Thrift`Way|> nots that ing cunk its (
11:25:01 <bitemyapp> @ops
11:25:01 <lambdabot> Maybe you meant: pl oeis docs
11:25:04 --- mode: ChanServ set +o geekosaur
11:25:35 --- mode: geekosaur set +b <Thrift`Way|>!*@*
11:25:37 <geekosaur> bah
11:25:42 --- mode: geekosaur set +b Thrift`Way|!*@*
11:25:59 <hodapp1> oh, it seems I picked the right time to lag out of Freenode and have to reconnect
11:26:00 <geekosaur> sigh, on a call and having client issues
11:26:11 --- mode: geekosaur set -b Thrift`Way|!*@*
11:26:13 --- mode: geekosaur set -b <Thrift`Way|>!*@*
11:26:13 <hodapp1> were other people having issues? I see a lot of joints
11:26:18 <hodapp1> er, joins.
11:26:21 <fishburne2> aweinstock: damn! is that so?
11:26:26 <aweinstock> fishburne2: actually, if I'm reading it correctly, lines 50-75 end up doing nothing?
11:26:29 <tzaeru> hodapp1, a lot of joints?!
11:26:37 <hodapp1> tzaeru: I wish.
11:26:51 <geekosaur> oh, I see they got killed already
11:27:21 <fishburne2> aweinstock: I am not seeing it.
11:27:35 <aweinstock> fishburne2: wait, nvm, I misread it, it's correct
11:27:51 <fishburne2> aweinstock: Oh. cool. no problem.
11:27:59 <sm> hackagebot recently announced a tool for specifying cabal files with yaml, and I can't find it. Does anyone know its name ? Any experience reports ?
11:28:10 --- mode: geekosaur set -o geekosaur
11:28:30 <sm> related, is there any place you can see a longer list of hackage uploads by date ?
11:29:07 <pmk_> did anybody see my style question?
11:29:33 <sm> pmk_: not me
11:29:39 <pmk_> sigh. irc.
11:30:09 <aweinstock> fishburne2: lines 68-72 simplify to "process layers input = foldM (\i l -> processLayer l i) input layers"
11:30:14 <geekosaur> Gal3rielol, not sure what else I can add to it, if you're not familiar with git...
11:30:16 <supki> sm: hpack, probably?
11:30:36 <sm> supki: yes! thank you
11:30:52 <pmk_> style/usage/best practice question:  which do you prefer in a style monad?  "myContext <- get; doThing $ myMember myContext" or "mem <- myMember <$> get; doThing mem"
11:31:14 <fishburne2> aweinstock: yes
11:31:18 <geekosaur> http://hackage.haskell.org/package/ghc-mod has a pointer to the git repo and even the command to pull it onto your system, then presumably `cabal install` in that directory
11:31:29 <geekosaur> ...freenode >.>
11:31:34 <geekosaur> more like x.x
11:31:46 <aweinstock> fishburne2: could you do another lpaste with the changes?
11:31:52 <dolio> @type gets -- pmk_
11:31:52 <lambdabot> MonadState s m => (s -> a) -> m a
11:33:20 <Jello_Raptor> is there a good records library that works with control.lens
11:33:45 <pmk_> thanks
11:34:05 <ttt_fff> is there a shorthand for { x <- blah ; case x of ... } ?
11:34:21 <geekosaur> lambdacase extension
11:34:23 <glguy> x >>= \case ...
11:34:24 <geekosaur> \case ...
11:35:49 <ttt_fff> lambdacase ftw
11:36:09 <fishburne2> aweinstock: Do you think it will fix the memory usage issue? I was planning to do the refactoring stuff after I got it working. I am not yet there where I can look at that kind of code and have my brain translate it to what it is doing...So I am not sure that it is a good Idea at this point...
11:36:59 <aweinstock> fishburne2: refactoring it / making it cleaner might help to find out where the memory usage issue is
11:40:25 <aweinstock> fishburne2: also, refactoring it might help find bugs, I'm not entirely sure yet that it is computing a neural network (rather than allocating memory in an infinite loop)
11:42:18 <arkeet> ttt_fff: blah >>= \case ...
11:42:32 <arkeet> :p
11:42:39 <ttt_fff> arkeet: you're like 10 minutes late
11:42:43 <arkeet> I know. :(
11:42:56 <ttt_fff> are you using irc from mars ?
11:43:16 <sm> lol
11:46:55 <bennofs> pluto ofc
11:47:38 <ttt_fff> in haskell's Maybe monad, "return == Just" ... how do I froce a "Nothing" 
11:48:23 <geekosaur> fail ""
11:48:37 <geekosaur> or just use Nothing instead of return
11:48:51 <aweinstock> geekosaur: what about mzero?
11:48:56 <aweinstock> :t mzero
11:48:57 <lambdabot> MonadPlus m => m a
11:49:12 <aweinstock> > mzero :: Maybe a
11:49:13 <lambdabot>  Nothing
11:49:52 <geekosaur> depends on whether you can get away with it potentially dragging MonadPlus into a type (i.e. is this explicitly the Maybe monad?)
11:51:45 <SrPx> Hey, does anyone remember that article someone posted saying you can't be "partially functional"?
11:52:09 <SrPx> That is, that just implementing lambdas don't make a language functional and is mostly useless, things like that.
11:52:17 <Iceland_jack> SrPx: By Erik Meijer?
11:52:21 <Iceland_jack> https://www.reddit.com/r/haskell/comments/3aufaj/erik_meijer_the_curse_of_the_excluded_middle/
11:52:42 <SrPx> Thanks :)
11:54:23 <Zemyla> Is there such a thing as a mutable bytestring that can be manipulated in the ST monad?
11:55:38 <aweinstock> Zemyla: Data.Vector.Mutable Word8
11:57:25 <dolio> Except, use unboxed vectors.
11:57:41 <dolio> Data.Vector.Mutable will waste a lot of memory on Word8s.
11:58:50 <aweinstock> dolio: Data.Vector.Unboxed.Mutable?
11:58:57 <dolio> Yeah.
11:59:17 <dolio> Storable would also work, and technically be more like a ByteString.
11:59:39 <dolio> That's a pretty low level detail, though.
12:01:14 <aweinstock> dolio: how would Storable be more ByteString-like?
12:01:30 <dolio> It uses ForeignPtr internally.
12:01:39 <dolio> Instead of MutableByteArray#
12:03:29 <aweinstock> aren't both ForeignPtr and MutableByteArray# both pointers into the heap? (is one of them not GC'd or something?)
12:03:48 <dolio> ForeignPtr uses pinned memory that can't be moved by the GC.
12:03:56 <aweinstock> ah
12:04:50 <dolio> So, using a lot of ByteStrings or storable vectors can cause memory fragmentation.
12:09:27 <P4Titan> Hello all, what is the best way to remove a sandboxed package from cabal. I installed two versions of the same package and want to delete one of them.
12:12:24 <nyazdani> P4Titan: I think you need to ghc-pkg unregister it and then literally delete the directory
12:14:48 <ChristianS> P4Titan: cabal sandbox hc-pkg unregister <packagename>
12:17:19 <P4Titan> is the directory in the .cabal-sandbox/lib/...
12:39:12 * hackagebot FormalGrammars 0.2.1.0 - (Context-free) grammars in formal language theory  http://hackage.haskell.org/package/FormalGrammars-0.2.1.0 (ChristianHoener)
12:39:57 <sm> can I just say, hpack is an awesome timesaver
12:40:01 <lamefun> Are proper math operators possible in Haskell?
12:40:21 <mauke> > 2 + 2
12:40:23 <lambdabot>  4
12:40:49 <lamefun> eg. (Vec2 2 3) * (Vec2 4 5) * 2.5 + (Vec2 4 (5 + 2))
12:40:54 <vmeson> 2 ^ 3
12:41:06 <silver> @type (+)
12:41:07 <lambdabot> Num a => a -> a -> a
12:41:14 <silver> @type (*)
12:41:15 <lambdabot> Num a => a -> a -> a
12:41:25 <oconnore> > :i Num
12:41:27 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:41:32 <oconnore> aww
12:41:44 <oconnore> @info Num
12:41:44 <lambdabot> Num
12:41:59 <oconnore> ...
12:42:14 <mauke> there is no @info command and there never has been
12:43:07 <bennofs> lambdabot: looks like a type error to me. what would that even mean?
12:43:23 <oconnore> mauke: oh, I only learn lambdabot tricks by watching other people and guessing
12:44:05 * vmeson is still bitter about haskell lazy bloated evaluation of 2^N where N is large... run haskell under a limited environment to avoid thrashing your system.
12:44:33 <lamefun> For example (Vec2 * Vec2 = dot product, Vec2 * num = scale, num * Vec2 is also scale).
12:45:04 <bennofs> lamefun: you can make your own operators for that
12:45:51 <bennofs> @let data Vec2 = Vec2 Double Double
12:45:53 <lambdabot>  Defined.
12:46:16 <bennofs> @let Vec2 a b .*. Vec2 c d = a*c + b*d
12:46:17 <lambdabot>  Defined.
12:46:46 <bennofs> > Vec2 2 3 .*. Vec2 3 4
12:46:48 <lambdabot>  18.0
12:52:34 <lamefun> bennofs: I want something like this: http://ideone.com/BXaRgL
12:53:24 <bennofs> lamefun: the problem is that in haskell the (*) operator must take the same type of arguments as it returns
12:53:42 <bennofs> lamefun: so you can only make your own operator, but not re-use the (*) operator for this
12:53:45 <lamefun> can't I ignore prelude and define my own?
12:53:58 <bennofs> lamefun: yes, you can do that too
12:54:13 * hackagebot GrammarProducts 0.1.1.0 - Grammar products and higher-dimensional grammars  http://hackage.haskell.org/package/GrammarProducts-0.1.1.0 (ChristianHoener)
12:54:24 <bennofs> but I don't like hiding things from Prelude much
12:54:41 <maerwald> @src sum
12:54:42 <lambdabot> sum = foldl (+) 0
12:56:48 <phaazon> haha
12:57:31 <phaazon> I just understood what “suspended computations” stands for
12:57:59 <phaazon> I always thought it was for suspended as in suspending a thread
12:58:05 <phaazon> right in the middle of a computation
12:58:17 <sm> how can you preview hackage's rendering of a cabal file's description ?
12:58:28 <phaazon> sm: cabal haddock --hyperlink-text
12:58:34 <sm> I thought it was haddock syntax but I'm not seeing realistic results when I put it in a .hs file
12:58:35 <phaazon> and open the index.html in dist/doc/html
12:58:36 <bennofs> sm: upload a candidate package
12:58:45 <sm> eg the . between lines
12:59:04 <bennofs> sm: you can upload "package candidates" - non-final versions of candidates that can be overwritten any time
13:02:56 <phaazon> that’s weird how pure actually applies a function
13:03:11 <sm> ok, thanks
13:06:33 <sm> bennofs: can such package candidates be deleted afterward ?
13:09:14 * hackagebot AlignmentAlgorithms 0.0.2.0 - Collection of alignment algorithms  http://hackage.haskell.org/package/AlignmentAlgorithms-0.0.2.0 (ChristianHoener)
13:09:16 * hackagebot BiobaseTypes 0.1.1.0 - Collection of types for bioinformatics  http://hackage.haskell.org/package/BiobaseTypes-0.1.1.0 (ChristianHoener)
13:10:33 <lamefun> Haskell can't seem to deal with these ambiguities: http://lpaste.net/289912663301947392
13:12:02 <lamefun> like: No instance for (Asterisk Vec2 b0 a0) arising from a use of ‘*’
13:12:08 <Iceland_jack> You shouldn't fight the language, having the arguments agree is a feature: not a bug
13:12:41 <lamefun> Note: there are several potential instances: instance Num a => Asterisk a a a -- Defined at Main.hs:26:10 - can't it see this is impossible, since Vec2 isn't a Num?
13:13:14 <obadz> Design question: if I want to write a large body of code that needs to be evaluated and its inputs are uncertain - it will contains "getBitOfData dataIdentifier" calls. What is the right way to collect all the getBitOfData calls and evaluate the function?
13:13:26 <bergmark> lamefun: if it assumed there was only instance because only one is accessible there, what would happen if another instance is added elsewhere and imported?
13:13:40 <obadz> Note: I don't think I can use a Monad because I think that implies that the getBitOfData have to be evaluated sequentially
13:13:52 <johnw> obadz: that sounds like an Applicative query problem
13:14:04 <obadz> I would like to get ALL the getBitOfData so I can write a clean query
13:14:07 <johnw> see https://ocharles.org.uk/blog/posts/2014-05-28-pure-batched-queries.html
13:14:14 * hackagebot soap 0.2.2.6 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.6 (AlexanderBondarenko)
13:14:21 <obadz> johnw: thanks, I thought Applicative might help. Will read.
13:15:15 <johnw> applicative lets you analyze the total expression at evaluation time; another approach, if you need a monadic interface, is to use the Free monad
13:15:32 <obadz> johnw: got a link for that too?
13:15:36 <phaazon> ehuhu
13:15:39 <phaazon> without telling me
13:15:42 <johnw> there are lots of articles on that one
13:15:46 <phaazon> is there a GHC trick to do to implement callCC?
13:15:58 <johnw> phaazon: it's implemented using regular functions
13:16:00 <phaazon> (don’t give me the implementation, that’s wat I meant)
13:16:03 <phaazon> johnw: ok
13:16:07 <lamefun> bergmark: aren't instances global?
13:16:09 <phaazon> I have that currently:
13:16:19 <phaazon> callCC f = ContT $ \k -> runContT (f k) ?
13:16:24 <phaazon> I don’t get what to put in the ?
13:16:50 <phaazon> because (f k) is ContT r m b
13:16:56 <johnw> k is in the wrong place
13:16:57 <phaazon> and the result has to be in ContT r m a
13:17:09 <geekosaur> lamefun, that's exactly the problem
13:17:09 <phaazon> johnw: ?
13:17:12 <johnw> or rather, there has to be some extra stuff in there
13:17:14 <phaazon> f takes that k, right?
13:17:17 <geekosaur> someone could define a Num instance for it in some other module
13:17:20 <johnw> it takes it, but not directly
13:17:33 <geekosaur> you have no control over this, but it is global and affects that usage
13:17:45 <oconnore> lamefun: the compiler typically has more context to go on
13:17:52 <bergmark> lamefun: yes but GHC won't magically find it if it isn't imported somewhere. this is why orphan instances are terrible, it isn't a problem otherwise since you cannot avoid to see the instance you need if you have the typeclass or the data type you want imported
13:18:01 <phaazon> oh yea
13:18:02 <johnw> phaazon: but you're pretty close
13:18:09 <phaazon> johnw: I misunderstood the type!
13:18:15 <phaazon> my type is
13:18:26 <phaazon> callCC:: ((a -> m r) -> ContT r m b) -> ContT r m a
13:18:29 <phaazon> instead of
13:18:34 <johnw> aha
13:18:42 <phaazon> callCC :: ((a -> ContT r m b) -> ContT r ma) -> ContT r m a
13:18:46 <johnw> yep
13:19:14 * hackagebot bimaps 0.0.0.2 - bijections with multiple implementations.  http://hackage.haskell.org/package/bimaps-0.0.0.2 (ChristianHoener)
13:19:59 <indiagreen> is there some way to write “if null s then something else s” without an if?
13:20:20 <indiagreen> like fromMaybe, but for... monoids in general, I guess (which can be empty/nonempty)
13:20:28 <johnw> depends on s
13:20:35 <johnw> s <|> somethingElse can work in some contexts
13:20:37 <phaazon> :t bool
13:20:38 <lambdabot> a -> a -> Bool -> a
13:20:39 <phaazon> indiagreen: ^
13:20:54 <phaazon> or with a guard
13:20:55 <bergmark> lamefun: my comment here also mentions this, https://www.reddit.com/r/haskell/comments/2pal4v/24_days_of_ghc_extensions_functional_dependencies/cmvaaqq
13:20:57 <indiagreen> phaazon: yeah but can't depend on bool yet
13:21:12 <indiagreen> johnw: nope, it's a Text in my case
13:21:22 <phaazon> if | a -> … | otherwise -> …
13:21:25 <Cale> There was a proposal at one point to have MonadOrElse whose operation on lists would behave like that
13:21:27 <phaazon> with MultiWayIf
13:21:46 <Cale> s `orElse` something
13:23:23 <dmj`> why does HsOpenSSL keep failing with "Not in scope: data constructor ‘J#’" ...
13:23:49 <indiagreen> phaazon: can't depend on MultiWayIf either, need to support 7.4 (and it's a bit too clumsy anyway)
13:23:53 <dmj`> a bug from 2008...? https://mail.haskell.org/pipermail/libraries/2008-November/010943.html
13:24:09 <phaazon> good luck then
13:24:16 <phaazon> johnw: looks like hm
13:24:24 <phaazon> ContT $ k -> runContT ? k sounds good
13:24:29 <phaazon> now…
13:24:29 <johnw> yep
13:24:40 <geekosaur> dmj`, ghc internals have moved around a few times since 2008
13:26:10 <phaazon> god dammit
13:26:27 <phaazon> I don’t find out how to deal with that f :: ((a -> ContT r m b) -> ContT r m a)
13:26:43 <phaazon> I only have k :: a -> m r
13:26:50 <phaazon> how can I introduce a b value?
13:27:00 <phaazon> hm
13:27:03 <phaazon> I know :D
13:27:45 <rowanblush> dmj`: I had that same error a week or so ago, it had something to do with integer-gmp... But I can't recall what the whole deal was.
13:27:58 <phaazon> dammit I do actually not
13:28:19 <phaazon> oh yeah I know :D
13:29:15 * hackagebot BiobaseXNA 0.9.2.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.9.2.0 (ChristianHoener)
13:30:01 <indiagreen> Cale: okay, at least I ended up naming it “orElse” thanks to you
13:30:20 <indiagreen> nice to know about Forgotten Proposals Of The Past as well
13:31:12 <phaazon> callCC f = ContT $ \k -> runContT (f $ \a -> ContT $ \_ -> k a) k
13:31:15 <phaazon> johnw: ^
13:31:27 <phaazon> I should attach an image
13:31:28 <phaazon> wait
13:31:55 <phaazon> http://www.funelf.net/photos/I-have-no-idea-what-i%60m-doing.jpg
13:35:15 <kadoban> Backtick in a URL, heh … weird.
13:36:09 <rubystallion> Hello. I have a question about the select function in Data.List. Why does it use an irrefutable pattern even though (ts,fs)  is used on the right hand side: select p x ~(ts,fs) ?
13:37:57 <geekosaur> rubystallion, because it would be strict? the ~ makes the pattern match lazy
13:38:11 <geekosaur> by deferring it until it's actually demanded
13:39:39 <rubystallion> geekosaur: but what's the point of making that pattern match lazy? Is there any situation under which the pattern match might be not demanded later?
13:41:45 <rubystallion> or is it just good style to always match tuples lazily?
13:44:14 <lyxia_> rubystallion: What select function?
13:44:20 <geekosaur> hm, actually, where are you seeing this?
13:44:36 <geekosaur> not seeing select in two different versions of Data.List (from 7.8 and 7.10)
13:45:13 <rubystallion> https://hackage.haskell.org/package/base-4.2.0.1/docs/src/Data-List.html
13:45:55 <dmj`> rowanblush: yea, quite strange
13:45:55 <dmj`>  
13:45:56 <geekosaur> oh, an ancient one
13:46:10 <dmj`> :t flip mapConcurrently
13:46:11 <lambdabot> Not in scope: ‘mapConcurrently’
13:46:40 <dmj`> forConcurrently = flip mapConcurrently, that should be standard in async imo 
13:48:53 <geekosaur> rubystallion, you're not thinking lazily enough. with the ~, it only generates each part of the tuple as it is consumed by the caller (of partition); by making it lazy, you can even use it on an infinite list as long as the caller doesn't try to examine the *entire* result lists
13:53:10 <nollboll> Hi guys, what are the bleeding edge (or just good) integration testing tools? I wasn't able to find anything interesting and I think of building something of my own leveraging docker
13:53:48 <hiptobecubic> nollboll, what do you mean? They are the same as for other languages.
13:54:16 * hackagebot instant-hashable 0.1 - Generic Hashable instances through instant-generics  http://hackage.haskell.org/package/instant-hashable-0.1 (RenzoCarbonara)
13:54:18 * hackagebot instant-deepseq 0.1 - Generic NFData instances through instant-generics  http://hackage.haskell.org/package/instant-deepseq-0.1 (RenzoCarbonara)
13:54:20 * hackagebot instant-bytes 0.1 - Generic Serial instances through instant-generics  http://hackage.haskell.org/package/instant-bytes-0.1 (RenzoCarbonara)
13:55:20 <nollboll> hiptobecubic: yeah, I know, but there doesn't seem to be anything good - I wan't to create something for continuous integration testing with a configurable environment that gets built out of docker containers, dependencies, leveraging old production data, etc.
13:55:36 <mauke> oh shit, leveraging?
13:55:51 <hiptobecubic> I think jenkins is the standard choice for homegrown CI
13:55:53 <rubystallion> geekosaur: Could you give me an example? I tried this code without the lazy tilde and it still worked: (fst $ select (>2) 3 ([1..],[4..])) !! 0
13:56:13 <tilde> hey
13:56:16 <geekosaur> are you actually running base-4.2.0.0?
13:56:19 <dmj`> circle ci is good
13:57:04 <nollboll> hiptobecubic: okay, but you have to define the environment setup and other logic manually via scripts for jenkins
13:57:15 * geekosaur sighs, trying to do too many things at once (although soon may be able to concentrate --- several tickets just popped at work)
13:57:22 <geekosaur> (but almost off for the day...)
13:57:23 <nollboll> jenkins is more for building and running unit tests
13:57:31 <rubystallion> geekosaur: No, I'm not, I copied the select function into a file which I loaded.
13:58:03 <nollboll> I already use jenkins - I want to take my code from jenkins after build and unit tests and push it to an integration testing stage if all tests pass
13:58:32 <rubystallion> geekosaur: OK then do your work first, I'm just curious about it and I can probably figure it out myself ;-)
13:58:35 <geekosaur> it may have been lazy enough without, but considering that later versions of base don't even have select in Data.List (even as a helper) I suspect it all got redesigned anyway
13:59:16 * hackagebot instant-aeson 0.1 - Generic Aeson instances through instant-generics  http://hackage.haskell.org/package/instant-aeson-0.1 (RenzoCarbonara)
13:59:23 <rubystallion> geekosaur: Yes, I wasn't careful enough to look at the version I'm using and just used the first search result
13:59:51 <geekosaur> older base has some stuff that was written the way it was for other reasons also; I see 4.2 still supported NHC, for example
13:59:58 <geekosaur> which, er, very dead :)
14:00:12 <rubystallion> geekosaur: haha, ok
14:01:22 <geekosaur> basically ghc can do things that some of the old Haskell compilers like nhc98 and hugs couldn't do (or do as well), so some things used to be written in ways that enabled the older compilers to handle them properly
14:01:39 <geekosaur> and those have gradually been removed over time
14:06:47 <Pamelloes> What's the advantage of using a web server written in Haskell over something like Apache?
14:07:13 <hpc> haskell web frameworks let you compile your site into the server
14:07:27 <hpc> so you never have to fork or use a cross-process interface, or something like mod_php
14:07:51 <Pamelloes> Alright. I'm sold :)
14:08:07 * Pamelloes does not like PHP
14:08:13 <hpc> (that's just the high-performance argument, by the way)
14:08:35 <Pamelloes> What do you mean by high performance?
14:08:56 <hpc> meaning, what i just listed is mainly performance benefits
14:09:02 <Clint> and not type safety benefits
14:09:04 <Pamelloes> Ah, I see.
14:09:25 <Pamelloes> What about security?
14:09:31 <c_wraith> The main benefit to writing *any* software in Haskell is if it has to be changed, you can make the changes with more confidence.
14:09:43 <Pamelloes> c_wraith: I'm quite aware of that :D
14:09:50 <hpc> you can use the type system to shrink the set of valid operations to just what you want to allow
14:10:18 <hpc> for instance, newtype OnlyDB a = OnlyDB {runOnlyDB :: IO a}
14:10:25 <Pamelloes> mmm
14:10:32 <hpc> and then lift every database operation you want on OnlyDB but not the rest of IO
14:10:58 <hpc> that reduces the surface area of attacks to only bugs in your DB interfacing and the library you are using
14:11:01 <hpc> and the queries you write
14:11:17 <hpc> which is still a lot, but you did just rule out the rest of the world
14:11:29 <Pamelloes> Which is pretty nice :)
14:11:45 <Pamelloes> If the proverbial missiles get launched, it isn't going to be my code doing it.
14:12:14 <begriffs> For any Haskellers in the Bay Area here's a last-minute reminder about tonight's meetup http://www.meetup.com/Bay-Area-Haskell-Users-Group/events/223460071/
14:12:21 <sm> those damn missiles :-/
14:12:27 <hpc> all that said, there's still a fair bit of stuff apache can do very easily, which you have to write more code for in haskell
14:12:42 <hpc> like if you ever want to hide a bit of your site behind a 401 prompt that's backed by LDAP or whatnot
14:13:15 <Pamelloes> Hm. I'm not really doing anything too complicated, so that probably won't be an issue.
14:13:17 <hpc> or debugging a misbehaving request that's hung the server
14:13:31 <Pamelloes> Oh. That would probably be hard to debug.
14:13:37 <Pamelloes> (in Haskell)
14:14:56 <Pamelloes> Are there any distros that are good for running a haskell webserver?
14:15:19 <sm> one one that you like, I'd think
14:15:29 <sm> s/one/any/
14:15:43 <srhb> Having a recent GHC packages might be nice, but not really a dealbreaker.
14:15:47 <srhb> packaged*
14:15:55 <Pamelloes> Alright. Just wanted to make sure there wasn't a "perfect haskell webserver distro" I'm unaware of.
14:15:59 <srhb> (Obviously NixOS is the answer...)
14:16:07 <Pamelloes> Hm...
14:16:13 <hpc> in general you use cabal if you want to stay bleeding edge
14:16:24 <hpc> (or even "within the past couple of years" edge)
14:17:16 <aupiff_> is `instance Binary CInt` defined anywhere?
14:17:21 <Pamelloes> srhb: I'm using NixOS on my laptop. It's pretty great, but I find it to be a little dicey at times. Is it secure/reliable enough to be used for a server?
14:17:44 <srhb> Pamelloes: I haven't had any stability issues, but I guess ymmv. :)
14:18:09 <srhb> Security: No idea. My main argument is nix, really.
14:18:17 <srhb> And maybe nixops, which I haven't tried yet.
14:18:17 <Pamelloes> ymmv? And my stability issues have mainly been with X not necessarily the os itself.
14:18:25 <srhb> Your mileage may vary
14:18:30 <Pamelloes> Ah, I see.
14:18:40 <Pamelloes> Yeah, nix is pretty great.
14:18:57 <maerwald> srhb: it is highly inconsistent
14:19:24 <srhb> maerwald: What is?
14:21:25 <maerwald> Pamelloes: do they even sign their nixpkgs, commits or anything? Afaik not
14:23:49 <aupiff_> nvm, defined `instance Binary CInt` myself.
14:45:59 <rowanblush> I run a couple public facing web servers on NixOS, they haven't fallen to invaders yet.
14:47:13 <danza> rowanblush, congrats :)
14:47:23 <danza> i want to try NixOS as soon as possible
14:48:57 <rowanblush> Documentation is a bit disperse (and rough) but it's pretty rewarding.
14:50:59 <maerwald> rowanblush: how do you make sure you don't have a single vulnerable zlib instance on your box (in case a zlib version is known to be vulnerable)? I don't think there are any tools for tracking such a thing (unless you only use the unsigned and untrusted binaries from the NixOS channel). I'd really avoid it for anything remotely related to a server.
14:52:23 <maerwald> I don't even know if they have a dedicated security team or if they communicate security vulnerabilities at all except pushing new binaries
14:52:30 <maerwald> haven't seen something like that, at least
14:55:03 <gremble> What does 'toEnum' do? I played with it on Prelude, but keep getting bad argument exceptions. fromEnum 'G' gives me 71 as a result, but toEnum 71 doesn't give me 'G' as a result. So I am confused
14:55:18 <verement> > toEnum 71 :: Char
14:55:19 <lambdabot>  'G'
14:55:44 <verement> > toEnum 1 :: Bool
14:55:45 <lambdabot>  True
14:55:48 <gremble> Ah. Should've given it a type
14:55:53 <gremble> thankks verement 
14:56:12 <rowanblush> maerwald: Good questions, I am not in the business of taking anybody's cash or data so my standards for security are lower than my standards for convenience.
14:56:37 <rowanblush> maerwald: One way to check installed versions is `ls /nix/store` after a `nix-collect-garbage`, see what you've got.
14:58:18 <maerwald> rowanblush: I'd expect a security mailing list (some vulnerabilities do require manual workarounds on top of updates), a command-line tool for checking the whole system for vulnerabilities (including those things compiled from nix expression) and all channels/nixpkgs gpg signed... before I even try to use it for a server
14:59:05 <rowanblush> S'good to know about you maerwald, when I'm running a business you can send in your resume.
14:59:40 <maerwald> rowanblush: my point is: please don't recommend it as a server platform
15:03:23 <rowanblush> I was providing anecdata, I don't think a personal experience counts as a recommendation but I appreciate your rigor and concern.
15:03:57 <maerwald> (in it's current state)
15:06:46 <Denommus> in servant, how would I serve a directory that is on my cabal data-files?
15:17:34 <sm> Denommus: see the cabal user guide, it defines macros for that
15:18:12 <sm> constants
15:24:20 * hackagebot GenussFold 0.0.0.1 - MCFGs for Genus-1 RNA Pseudoknots  http://hackage.haskell.org/package/GenussFold-0.0.0.1 (ChristianHoener)
15:29:20 * hackagebot Frames 0.1.2 - Data frames For working with tabular data files  http://hackage.haskell.org/package/Frames-0.1.2 (AnthonyCowley)
15:33:19 <eds> I don't know if I am putting this right. Is there a to wrap List such that we can read it as type a instead of [a]? 
15:33:25 <eds> Code and error: http://lpaste.net/136444
15:34:16 <eds> I want to be able to evaluate List together with other operations with eval function.
15:34:20 * hackagebot rainbox 0.18.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.18.0.0 (OmariNorman)
15:40:23 <jameseb> eds: I think n there is of type [Expr a], when the function expects a return type of a
15:40:42 <jameseb> you'd need to iterate over the list in some way
15:41:02 <jameseb> what's the expected behaviour of eval?
15:42:47 <jameseb> eds: thinking about it some more, I think just using fmap should work
15:43:01 <eds> yeah. I know eval takes in Expr a type and spits out a that compiler would understand, i guess
15:45:01 <jameseb> "fmap eval n" should work there
15:45:30 <jameseb> for the (L n) case
15:46:14 <Denommus> sm: ah, I was just having problems running IO in a servant raw request, but now I'm fine, thanks anyway
15:46:25 <jameseb> not sure I know enough about GADTs to be certain
15:48:00 <mniip> eds, are you talking about the 'eval (L n)' case?
15:48:11 <mniip> oh yes you are
15:48:13 <eds> yes!
15:48:20 <mniip> you want to 'map eval n'
15:48:37 <jameseb> yeah, that works too
15:48:51 <jameseb> I forget fmap = map for lists
15:49:08 <mniip> also your function is partial because you forgot Sum
15:49:33 <jameseb> I should sleep now...
15:49:35 <Denommus> now, is there an easy way to deploy the final binary files produced by cabal, including the data-files?
15:49:49 <Denommus> like, installing it in a system with no GHC or cabal installed
15:50:17 <eds> mniip : Yea I am going to implement Sum. But I need List to work first
15:50:22 <eds> jameseb gn and thanks!
15:50:50 <jameseb> no problem eds, goodnight
15:59:21 * hackagebot rainbow 0.26.0.6 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.26.0.6 (OmariNorman)
15:59:24 <eds> mniip: my eval is defined eval :: Expr a -> a. And if I map it, the output has type [a] right, which won't work.
16:00:32 <eds> right?
16:01:02 <mniip> eds, in case of eval (L n), eval :: Expr [a] -> [a]
16:01:19 <mniip> and n :: [Expr a]
16:01:25 <mniip> and map eval n :: [a]
16:01:41 <Hijiri> Has anyone ever used the "repl" package from hackage?
16:01:57 <eds> so I would have to create a separate eval for List right? say evalList :: Expr [a] -> [a]
16:02:06 <Hijiri> It's an interpreter library like mueval
16:02:19 <Hijiri> I updated it to work with newer GHC (7.8 for now), but for some reason nothing is in scope
16:02:23 <Hijiri> but only every third command
16:02:28 <nullvoid8> eds: no, this is the magic of GADTs at work
16:02:30 <Hijiri> otherwise it is working
16:02:35 <mniip> eds, no
16:02:39 <mniip> eval is polymorphic
16:02:57 <mniip> Expr a -> a, you can substitute anything for a
16:03:09 <mniip> for example if a ~ [r], then Expr [r] -> [r]
16:03:37 <Hijiri> Here is the code for working with ghc 7.8.4 http://lpaste.net/136634
16:04:04 <Hijiri> This is the cabal file: http://lpaste.net/136635
16:04:07 <eds> Wow. that is so awesome!
16:05:01 <Hijiri> (the only thing I changed in the cabal file are the constraints, the rest of it is by the author of repl)
16:05:10 <Entroacceptor> I'm going mad. Even if "Path" is a newtype Path = Path Bytestring, I shoudl be able to get a value of that via Path $ some other stuff, right? (This is about Network.MPD from libmpd)
16:05:34 <Entroacceptor> but I always get "Not in scope: data constructor ‘MPD.Path’"
16:05:42 <eds> *_* worked. I read about it and was wondering it should work. why did we have to map it? if you could explain.
16:05:50 <eds> mniip
16:06:21 <yayfoxes> Psi-Jack I want to code
16:06:28 <yayfoxes> whoops
16:06:36 <yayfoxes> Cake 
16:06:57 <yayfoxes> Cale book please
16:10:08 <mniip> eds, uh
16:10:22 <mniip> I just litearlly explained it
16:10:34 <eds> ahh got it. nevermind mniip
16:10:40 <eds> yeah
16:10:46 <eds> I read it again
16:11:12 <eds> and looked at the definition of map. made sense to me
16:12:43 <indiagreen> Entroacceptor: nope, it's an opaque datatype
16:12:55 <indiagreen> i.e. the constructor (Path) wasn't exported on purpose
16:14:27 <ttt_fff> [] is lazy right? does Haskell have a "Strict List" ?
16:14:53 <indiagreen> Entroacceptor: it appears, however, that you can get a Path from a String by using fromString
16:14:56 <indiagreen> (from Data.String)
16:14:57 <Entroacceptor> indiagreen: yeah, looks like it. Which would be fine if it hadn't worked before
16:15:07 <indiagreen> so I don't get why they'd make it opaque
16:15:45 <Entroacceptor> thank you
16:15:54 <Entroacceptor> now I get different fun errors
16:18:03 <c_wraith> ttt_fff: nothing standard
16:18:24 <c_wraith> ttt_fff: mostly because it's not a great data structure if you want something strict.
16:18:38 <ttt_fff> why?
16:18:48 <ttt_fff> if all I want is to represent a collection of stuff, say elements of a svg group, a list is fine
16:19:25 <c_wraith> ttt_fff: making it strict prevents fusing list consumption with list production as an optimization
16:19:50 <c_wraith> ttt_fff: and if you can't get that, you might as well use something like Vector, unless your exact use case is "I need a persistent stack"
16:19:54 <ttt_fff> c_wraith: ah, okay, I'm convinced now
16:20:09 * ttt_fff puts on "lists should be lazy" hat
16:20:35 <c_wraith> ttt_fff: as a corallary, lists aren't a good choice for a structure that can't be produced lazily. 
16:20:40 * c_wraith glares at replicateM
16:20:53 <ttt_fff> hmm, I'm producing stuff iteratively
16:20:59 <ttt_fff> not sure if iteratively == lazily
16:21:14 <c_wraith> It may or may not. :)
16:21:49 <c_wraith> ttt_fff: if IO is involved in generating each element, lists are probably the wrong type
16:22:19 <ttt_fff> damn it, so amny smart people here
16:22:24 <ttt_fff> if I do a haskell startup, I should hire everyone here
16:23:30 <c_wraith> That would require a somewhat large budget.  Have you looked at the user count? :)
16:23:39 <c_wraith> Also, I don't think ChanServ is too good at Haskell.
16:24:02 <Entroacceptor> now I have to write proper error handling, great
16:25:02 <ttt_fff> yeah; but haskellers are lazy, so I'd only have to pay them on demand
16:25:45 <c_wraith> Funny thing about demand for payment.... :)
16:26:33 <silver> fix demand
16:29:02 <stevego> coming back to haskell again. is it recommended to use cabal directly or stack these days?
16:29:27 <ttt_fff> i use cabal with stackage.lts
16:29:30 <ttt_fff> haven'tt tried stack
16:32:13 <Gal3rielol> anyone use emacs with ghc 7.10 and ghc-mod?
16:37:40 <Welkin> stevego: since I have started using sandboxes exclusively, I haven't had any issues
16:37:49 <Welkin> I haven't looked at stack
16:44:32 <bernalex> → cabal run 1234 5678
16:44:35 <bernalex> cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.3.0, now Cabal-1.22.4.0).
16:44:37 <bernalex> → cabal configure    
16:44:39 <bernalex> Resolving dependencies...
16:44:41 <bernalex> Configuring blubber-server-0.0.1...
16:44:43 <bernalex> → cabal run 1234 5678
16:44:45 <bernalex> cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.3.0, now Cabal-1.22.4.0).
16:44:47 <bernalex> sigh.
16:45:27 <c_wraith> throw a cabal clean at it
16:45:33 <glguy> My experience is that when Cabal gets confused like that I need to clean out ~/.cabal/setup-exe-cache
16:46:26 <Welkin> cabal clean && cabal configure && cabal build
16:46:33 <bernalex> c_wraith: I did. but it's kind of ridiculous that we should have to do this crap.
16:50:10 <joncol_> I'm having some difficulties understanding how functions such as readHex can work using only the assumption about Num typeclassness. When trying to write my own readBin function I cannot relax the requirement that the type must be of a specific class such as Int or Integer (digitToInt and ord return Ints). Can anyone help?
16:51:32 <joncol_> s/class/type/
16:51:46 <Cale> joncol_: use fromIntegral to turn an Int or Integer into any type which is an instance of Num
16:51:52 <Cale> :t fromIntegral
16:51:53 <lambdabot> (Integral a, Num b) => a -> b
16:52:02 <joncol_> Cool Cale, that helps!
16:54:07 <arkeet> :t let f n | n < 0 = -f (-n) | n == 0 = 0 | otherwise = 1 + f (n-1) in f
16:54:08 <lambdabot> (Num a, Num a1, Ord a1) => a1 -> a
16:54:22 <arkeet> hmm.
16:54:24 * hackagebot pseudo-boolean 0.1.2.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  http://hackage.haskell.org/package/pseudo-boolean-0.1.2.0 (MasahiroSakai)
16:54:38 <arkeet> > let f n | n < 0 = -f (-n) | n == 0 = 0 | otherwise = 1 + f (n-1) in (f 25, f (-3))
16:54:40 <lambdabot>  (25,-3)
16:57:10 <stevego> will stack be installing missing C libraries as well? if not now maybe in the future?
16:58:29 <johnw> stevego: I don't see that ever happening
16:58:34 <johnw> stevego: but it's exactly what Nix will do
16:59:16 <stevego> are Nix and stack compatible?
16:59:19 <fosterite> > let f n | n < 0 = -f (-n) | n == 0 = 0 | otherwise = 1 + f (n-1) in (f 1, f 1.0)
16:59:20 <lambdabot>  (1,1)
16:59:26 <fosterite> > let f n | n < 0 = -f (-n) | n == 0 = 0 | otherwise = 1 + f (n-1) in (f 1, f 1.5)
16:59:27 <lambdabot>  (1,*Exception: stack overflow
16:59:27 <johnw> you can use them side-by-side
16:59:30 <johnw> but they don't integrate
17:00:33 <johnw> stevego: I'm doing a presentation on using Nix with Haskell tomorrow that will be recorded, so look for it soon if you're interested in going that route
17:01:27 <fosterite> arkeet: is there some natural way to handle fractions for the thing you're trying to do?
17:01:34 <arkeet> nope
17:01:41 <arkeet> just integers to arbitrary num
17:01:51 <arkeet> it won't terminate on fractional inputs
17:02:05 <sveit> does Data.Vector provide truly new datatypes, or "just" convenience functions over the Array types?
17:02:10 <fosterite> arkeet: I see
17:02:17 <stevego> johnw: cool I will take a look. the idea of Nix sounds very interesting
17:03:01 <arkeet> sveit: it doesn't use Data.Array
17:04:00 <fosterite> arkeet: why not use Integral
17:04:21 <arkeet> I would, but that wasn't the inferred type.
17:04:45 <sveit> arkeet: wow, really? is there somewhere to read about its architecture?
17:05:11 <johnw> stevego: I've been using it for more than a year, and am very happy with it
17:05:27 <johnw> though it does at time take some work
17:05:46 <fosterite> arkeet: actually, your function terminating == type is an Integral I think
17:10:18 <Eiam> was Applicative introduced in 2008?
17:13:25 <sveit> would it be more efficient (in general) to write indexing routines into Data.Vector taking (Int,Int,Int) -> Int or to use Data.Array for generic numerical operations?
17:14:15 <_slade_> Eiam: I think McBride introduced them in 2004 under the name 'idiom'.
17:14:25 <fosterite> for "real" efficieny you just want to call BLAS anyway
17:15:18 <_slade_> Eiam: 'Applicative Programming with Effects' was published in 2008, though.
17:15:22 <sveit> fosterite: sure, but which should I use within Haskell?
17:15:41 <Eiam> _slade_: right thats this one;  http://staff.city.ac.uk/~ross/papers/Applicative.html 
17:15:59 <c_wraith> sveit: no difference for a single operation.  For compound operations, it's possible vector fusion would pay off.
17:16:17 <_slade_> Eiam: https://mail.haskell.org/pipermail/haskell/2004-July/014315.html
17:16:36 <aupiff_> I'm having some very strange behviour with `Data.Binary`, the first 8 bytes (64 bits that encode an Int) are being ignored and so everything is offset...
17:16:43 <aupiff_> has anyone run into this?
17:16:52 <fosterite> sveit: hblas uses MVectors so I would say those
17:17:22 <aupiff_> I can view the binary with a hex editor and see that `put` did it's job, but `get` skips over that first `Int`...
17:18:13 <c_wraith> aupiff_: does get think it's a length?
17:18:44 <aupiff_> c_wraith: I'm not sure... doesn't seem that way given other `Binary` instances I've seen
17:19:03 <c_wraith> aupiff_: a minimal failing example would be handy
17:19:15 <sveit> I was actually just planning on converting indices (Int,Int,Int) -> Int for vectors, but I also don't exculsively want operations on matrices, in particular my example was a 3D structure, and some of the work would just be convenient to do in Haskell. i also want to play around with parallelization, and i seem to remember reading somewhere that the strategy with mapping indices into parts of the vector makes parallelization
17:19:16 <sveit> impossible. is this accurate?
17:19:25 * hackagebot pipes-cliff 0.10.0.4 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.10.0.4 (OmariNorman)
17:19:43 <c_wraith> sveit: have you considered repa?
17:20:03 <glguy> aupiff: Sounds like you might using get or put at different types, or if you wrote your own instance that your get/put don't match
17:20:08 <sveit> c_wraith: yes, but since this is a hobby project i'm not scared of (and wouldn't mind) reinventing the wheel
17:20:45 <c_wraith> sveit: my impression of repa is that the area is actually *really* hard to get right.  But if you want to do it...  :)
17:21:04 <Gurkenglas> https://hackage.haskell.org/package/mmorph-1.0.3/docs/Control-Monad-Trans-Compose.html should have an infix operator.
17:21:48 <aupiff_> this is what is broken: https://github.com/aupiff/haskell-eigen/blob/sparse-serialize/Data/Eigen/SparseMatrix.hs#L286-L321
17:22:07 <aupiff_> c_wraith: but I'll try to write a minimal failing example now.
17:22:19 <sveit> c_wraith: of course, and I don't expect to compete with Repa, but like i said i'm mostly doing this to learn how to write performant functional code for different applications, and this is the particular sector i'm interested in right now. anyway, would you say it's accurate that mapping indices into Vector somehow makes parallelization impossible down the road?
17:23:40 <sveit> c_wraith: do i need a separate vector for every "row" (so a 3D structure is a Vector of Vector of Vector)? or could I even have parallel operations if i simply have a single unboxed vector (as would seem to be the most naively performant case)
17:24:55 <c_wraith> sveit: it's usually worth using one chunk of memory, but you want to arrange it carefully.  In ways I know little about. :)
17:25:58 <Eiam> _slade_: thanks =)
17:26:09 <sveit> c_wraith: ok, thanks! of course i'm prepared to research/learn/benchmark, but I just wanted to make sure that mapping indices into an unboxed vector wasn't a dead end.
17:26:32 <Gurkenglas> Why do MaybeT, ReaderT, etc. each have their own names rather than being written something like Trans Maybe, Trans Reader, etc.? (Do they maybe not arise from Maybe, Reader, etc. in the same way?)
17:32:22 <Darwin226> Hey guys. When I write an expression like x + ((y * z) - w) / q, do I get a thunk for each of those intermediate operations?
17:32:36 <srh> Gurkenglas: look at their definitions, ask how you'd implement Trans
17:32:36 <Darwin226> If so, is there a way to avoid it and just have the whole expresion be strict?
17:33:40 <nolrai66> I think -O will do that.
17:35:58 <djanatyn> 6
17:40:16 <Gurkenglas> srh, Trans Maybe m a should be m (Maybe a), Trans (Reader r) m a should be r -> m a, etc. Perhaps we can define a class that Maybe, Reader r, etc. would implement to say how Trans Maybe, Trans (Reader r), etc. should look like?
17:40:50 <bernalex> how do I figure out which openid I used for haskellers.com? lol
17:41:11 <srh> Gurkenglas: ok but that's just an awkward way to describe the implementation of ReaderT, etc.
17:42:44 <Gurkenglas> srh, it introduces less names! And it becomes less awkward once you introduce infix operators to turn something like "ReaderT (MaybeT IO) a" into something like "(Reader :.: Maybe :.: IO) a"
17:43:08 <Gurkenglas> umm, insert r where appropriate.
18:13:37 <Hijiri> about the repl package I talked about earlier
18:13:45 <Hijiri> it stopped breaking when I used it in a real program and not from cabal repl
18:19:07 <funfunctor> Hi
18:44:28 * hackagebot monoid-subclasses 0.4.1.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4.1.1 (MarioBlazevic)
18:44:44 <funfunctor> @hoogle Generic
18:44:44 <lambdabot> Data.Text.Lazy.Builder.RealFloat Generic :: FPFormat
18:44:45 <lambdabot> Data.Generics.Aliases type Generic c = forall a. Data a => a -> c a
18:44:45 <lambdabot> Data.Generics module Data.Generics
18:49:49 <dmj`> wait, so you *can* specify modules in test executable sections?
18:49:55 * dmj` mind blown
18:52:14 * Pamelloes covertly picks up dmj's mind fragments, packages them in a jar, and ships them off to market.
18:55:58 <dmj`> omg, same with benchmarks... 
19:01:05 * dmj` hands Pamelloes some brain fragment
19:01:37 * Pamelloes flies to Jita.
19:04:11 <rowanblush> Not to interrupt the illegal brain trade, but what is it that's so cool?
19:08:31 <slack1256> I also don't know why that is cool...
19:12:47 <hodapp> Maybe instead of trying to understand continuations and CPS, I should just try to write silly puns about them.
19:13:01 <hodapp> but how could one ever return from that?
19:13:04 <dmj`> slack1256, rowanblush: it's cool because normally you only have one library per cabal file, and test-suites and benchmarks are just executables, I guess it's only cool for me because I didn't know
19:14:08 <rowanblush> Ah, gotcha.
19:15:41 <rowanblush> hodapp: Hah! Give a moment to recover. Alright, do go on.
19:16:56 <hodapp> rowanblush: what, you just expect me to just supply you another when you call for me to?
19:17:20 <rowanblush> But you promised!
19:18:22 <ttt_fff> can one go too far on the monad train? i.e. of the form "we have these group of functions, which call each other, and use this piece of data as a constant -- therefore, I should stuff them all into a Reader Monad"
19:18:53 <hodapp> rowanblush: ...yeah, that's all I have.
19:19:18 <rowanblush> That's alright, maybe we can pick up again sometime later.
19:19:53 <nolrai66> ttt_ff: is it actually simpiler then just having the functions be global or defined in "with" clauses?
19:33:14 <dmj`> reading bos's cabal files taught me cabal files
19:34:49 <funfunctor> @hoogle Char -> String -> (String, String)
19:34:49 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
19:35:12 <funfunctor> @hoogle String -> Char -> (String, String)
19:35:12 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
19:36:35 <funfunctor> hmm, what can split "foo;bar" into ("foo", "bar")
19:37:12 <Iceland_jack> You would split it into ["foo", "bar"]
19:37:19 <Iceland_jack> You can look at Data.List.Split
19:38:38 <Iceland_jack> funfunctor: 
19:38:38 <Iceland_jack> <Iceland_jack> > splitOn ";" "foo;bar"
19:38:38 <Iceland_jack> <lambdabot>  ["foo","bar"]
19:38:38 <Iceland_jack>  
19:43:27 <funfunctor> ah Data.List.Split could not find it, thanks Iceland_jack !
19:44:03 <Iceland_jack> https://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html
19:46:43 <funfunctor> Iceland_jack: yep I know, just forgot what I was looking for..
19:47:15 <funfunctor> If only there was a way to remember all of hackage :p
19:49:19 <Iceland_jack> Linked it for convenience :)
19:51:59 <GLM> Is there a way to create a state machine to represent a web application that has constraints on it to make sure an invalid state is never acheived?
19:53:55 <lethjakman> anyone have any experience with yesod/snap? I'm curious which would do better with JSON api's
19:54:23 <erikd> :t SockAddr
19:54:24 <lambdabot> Not in scope: data constructor ‘SockAddr’
19:54:51 <mjo-work> Is there still a category theory channel somewhere?
19:55:17 <erikd> what is the SockAddrCan constructor for SockAddr for?
19:59:22 <roboguy__> mjo-work: yeah, ##categorytheory
20:01:27 <mjo-work> roboguy__: thanks!
20:03:15 <roboguy__> erikd: it looks like it corresponds to sockaddr_can, which is for CAN sockets (which I *think* is for this https://en.wikipedia.org/wiki/CAN_bus)
20:04:11 <erikd> roboguy__: thanks. had heard of CAN bus, but not had anyhting to do with it.
20:27:06 <funfunctor> Iceland_jack: There isn't a Char -> (String, String) split is there though?
20:27:37 <funfunctor> @hoogle a -> a -> (a, a)
20:27:37 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
20:27:37 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
20:27:37 <lambdabot> Data.ByteString breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
20:29:32 <fosterite> @hoogle [a] -> a -> ([a], [a])
20:29:33 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
20:29:33 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
20:29:33 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
20:37:50 <funfunctor> fosterite: that takes a Int not a Char
20:38:15 <fosterite> funfunctor: I was hoping to see something with an Eq a constraint
20:38:25 <funfunctor> yea :/
20:38:33 <funfunctor> I think it should be added if you ask me
20:39:42 <funfunctor> Data.Text has a splitOn which is a bit excessive because you could just use the stuff from Data.List and -XOverloadString or T.pack
20:43:50 <funfunctor> @hoogle [a] -> a
20:43:50 <lambdabot> Prelude head :: [a] -> a
20:43:50 <lambdabot> Data.List head :: [a] -> a
20:43:50 <lambdabot> Prelude last :: [a] -> a
20:45:23 <chromatome> I'm trying to install ghc-mod on a fresh install of osx but I keep getting errors for the build process.
20:45:51 <chromatome>     Not in scope: data constructor ‘ExposePackageId’
20:45:52 <chromatome>     Perhaps you meant ‘ExposePackage’ (imported from DynFlags)
20:46:27 <chromatome> Any ideas?
20:46:50 <rcyr> chromatome: I have that same problem... couldn't find a solution. (I'm a beginner though)
20:47:19 <chromatome> rcyr: me too. I've heard about cabal being annoying but I wasn't expecting issues this soon hah
20:54:34 * hackagebot free-http 0.1.1.2 - An HTTP Client based on Free Monads.  http://hackage.haskell.org/package/free-http-0.1.1.2 (aaronlevin)
20:54:36 * hackagebot free-http 0.1.1.3 - An HTTP Client based on Free Monads.  http://hackage.haskell.org/package/free-http-0.1.1.3 (aaronlevin)
20:55:31 <funfunctor> how do you map a function inside a structure of a structure to update the inner structure?  e.g. data Foo = Foo Bar   and data Bar = Bar Int   and we have f :: Bar -> Bar
20:56:07 <funfunctor> In my case, it is 3 levels deep
20:56:57 <Cale> funfunctor: You can use lenses for each of the structures. Or you can just write higher order functions to do it
20:57:11 <Cale> e.g. mapFoo :: (Bar -> Bar) -> Foo -> Foo
20:57:13 <Iceland_jack> funfunctor: You can use any of the lens libraries, or you can add a parameter to them, derive Functor instances and use fmap.fmap.fmap
20:57:38 <Cale> Yeah, if there were a type parameter, or you felt like generalising the type, you could use Functor
20:57:43 <funfunctor> Cale: Hi mate! OK, lenses is what I am interested in because I still have not wrapped my mind around that one yet
20:57:54 <Iceland_jack> funfunctor: So ... *if it makes sense*
20:57:54 <Iceland_jack>     data Foo a = Foo a deriving Functor
20:57:54 <Iceland_jack>     data Bar a = Bar a deriving Functor
20:58:17 <funfunctor> oh a Functor instance ok..
20:58:27 <funfunctor> :t fmap
20:58:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:58:32 <Iceland_jack> :t fmap.fmap
20:58:33 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:58:43 <Iceland_jack> :t fmap.fmap :: (a -> b) -> Maybe [a] -> Maybe [b]
20:58:44 <lambdabot> (a -> b) -> Maybe [a] -> Maybe [b]
21:01:02 <funfunctor> good ok, Vector is a instance of Functor, that is one level sorted for me
21:03:50 <dibblego> funfunctor: the composition of two functors, is itself a functor, which is what this is getting at.
21:03:51 <dmj`> lethjakman: you there?
21:04:34 * hackagebot configifier 0.0.5 - parser for config files, shell variables, command line args.  http://hackage.haskell.org/package/configifier-0.0.5 (MatthiasFischmann)
21:05:10 <funfunctor> dibblego: yep I know category theory but yes good point
21:09:35 * hackagebot stripe-haskell 0.1.4.1 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.4.1 (DavidJohnson)
21:11:01 <fishburne> aweinstock: ping
21:13:13 <funfunctor> What does "No instance nor default method for class operation Data.Csv.Conversion.parseField" mean and why is it a runtime exception?
21:13:38 <funfunctor> oh, instance is missing one of its methods for the type class
21:14:05 <funfunctor> would be more helpful to say " default *type* method "
21:15:49 <Hafydd> You should have been warned when compiling that.
21:16:02 <Hafydd> As far as I know.
21:19:35 * hackagebot cmark 0.3.5 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3.5 (JohnMacFarlane)
21:24:31 <rcyr> Would it be possible to change a function from a -> b -> c -> d to b -> c -> a -> d ?
21:24:58 <rcyr> Some dark magic using flip and something
21:25:12 <rowanblush> reorder f a b c = f b c a
21:26:55 <rcyr> rowanblush: A pointfree version would be fun
21:27:32 <verement> @pl \f a b c -> f b c a
21:27:32 <lambdabot> flip . (flip .)
21:28:21 <rcyr> Haha
21:28:24 <rcyr> So nice
21:28:41 <funfunctor> Hafydd: not if you use GHC.Generic I get no warning
21:29:09 <funfunctor> Hafydd: using my own instance I get     ‘parseField’ is not a (visible) method of class ‘FromField’
21:29:25 <funfunctor> http://hackage.haskell.org/package/cassava-0.4.3.0/docs/Data-Csv.html
21:30:34 <funfunctor> not sure what is happening there?
21:31:50 <funfunctor> ah my import
21:34:35 * hackagebot cmark 0.4.0.1 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.4.0.1 (JohnMacFarlane)
21:35:32 <jle`> good ol' john macfarlane
21:35:39 <jle`> john macreliable we call him
21:40:11 <dmj`> jle`: we should become pandoc consultants 
21:41:15 <dmj`> help companies convert their data from excel
21:46:09 <L8D> tonight has been rather quiet
21:53:18 <dirk103> heyo
21:53:28 <dirk103> so if statements HAVE to have an else section?
21:53:58 <peddie> dirk103: what would the result of the 'if' expression be if the predicate were false?
21:54:02 <jle`> dirk103: yes, because they're expressions that have to evaluate to a value
21:54:13 <dirk103> cool
21:54:38 <jle`> they aren't control statements like in other languages
21:54:58 <jle`> but they can be used as ones kinda because of laziness
21:54:58 <dirk103> peddie: the if statement should mind its own business :P
21:55:54 <jle`> dirk103: `if x then y else z` is an expression that evaluates to a value.  it evaluates to y if x is true and z if x is false.  what would it evaluate to if x is false and there's no else branch?
21:56:00 <verement> I wonder why if-then-else expressions were even added to the language
21:56:45 <jle`> they're kind of nice in do notation i guess
21:57:14 <dirk103> yeah i understand. i just had to make sure haha. seems odd to but i can see a definite advantage to that way of thinkign
21:57:17 <jle`> but typically if-then-else syntactic sugar is uglier compared to alternatives, heh.
21:57:30 <verement> but I mean it can be implemented with a regular function, no?
21:57:31 <jle`> dirk103: heh, here really isn't any other alternative way, due to how haskell works
21:58:04 <rowanblush> verement: `boolCase :: Bool -> a -> a -> a`
21:58:05 <jle`> verement: yeah, but it helps because you can use layout rules for indenting blocks and stuff, and less parentheses
21:58:19 <verement> yes, I suppose
21:58:28 <dirk103> Scott Meyers has written some great books on C++. I think he borrows a lot of concepts and recommendations from functional programming
21:59:15 <rcyr> @pl \f a b c -> f c a b
21:59:15 <lambdabot> (flip .) . flip
22:03:08 <L8D> dirk103: borrows?
22:06:15 <Hafydd> He steals them.
22:06:21 <L8D> Hafydd: steals?!
22:06:27 <Hafydd> He is a murderer.
22:06:46 <L8D> I think too many people here are too elitist about functional programming
22:08:57 <dmj`> L8D: people here are inclusive and knowledgeable ime
22:12:10 <Hafydd> I don't know what you mean by "elitist", but I was just having a giggle.
22:13:53 <adarqui> i havn't seen many elitists in here, imho
22:16:54 <funfunctor> @hoogle fmap
22:16:54 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
22:16:55 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
22:16:55 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
22:17:21 <funfunctor> what is the difference between all those fmap's?
22:17:30 <funfunctor> why not just the Prelude?
22:17:30 <dmj`> nothing
22:17:50 <adarqui> those all look the same, probably just re-exported in those other 2 modules
22:18:01 <funfunctor> re-exporting modules is the devil 
22:18:10 <funfunctor> yea
22:18:24 <dmj`> from GHC.Base
22:30:44 <dirk103> they should add pointers in haskell
22:30:58 <mniip> but there are pointers in haskell
22:32:00 <Adeon> it's not a pointer if it doesn't have * in it
22:32:21 <mniip> it has # in it, is that enough
22:39:46 <lamefun> I've got the following recurring pattern: http://lpaste.net/2662268523903975424
22:39:54 <lamefun> Can I make it less annoying somehow?
22:41:20 <pacak> lamefun: Which part you don't like?
22:41:51 <lamefun> pacak: everything, it's too verbose for such a simple thing
22:42:38 <pacak> lamefun: inline more stuff. If you have a bunch of similar constructions - use Generics/TH
22:43:24 <pacak> lamefun: There's no point to validType to return Bool, it can return Maybe Type directly
22:43:50 <pacak> Later you can either pattern match or use isJust / isNothing
22:48:45 <lamefun> pacak: "inline more stuff" - inline how?
22:48:55 <nshepperd> chromatome: you're flapping
22:49:01 <lamefun> like C++ inline?
22:49:31 <pacak> lamefun: change validType to be :: UnderlyingType -> Maybe Type
22:49:51 <lamefun> pacak: then I just might as well remove it (it'll be the same as mkType)
22:50:07 <fosterite> lamefun: no, because you can check it
22:50:07 <pacak> lamefun: Sure. You don't need both.
22:52:01 <nikki93> @pf \s -> Single (scoreString s) s
22:52:01 <lambdabot> Maybe you meant: pl bf
22:52:21 <nikki93> @pl \s -> Single (scoreString s) s
22:52:21 <lambdabot> Single =<< scoreString
